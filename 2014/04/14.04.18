00:02:41 <eatman> Ola!
00:41:14 * hackagebot network 2.4.2.3 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.2.3 (JohanTibell)
00:49:17 <jle`> is there an easy way to do Maybe (a,b) -> (Maybe a, Maybe b) ?
00:49:30 <jle`> hm
00:49:38 <jle`> (fmap fst &&& fmap snd)
00:49:48 <johnw> sounds about right
00:59:32 <haasn> I only know the inverse :(
01:00:13 <dibblego> funzip
01:00:27 <haasn> Bidistributive?
01:00:33 <haasn> I guess that would be the proper analog
01:00:47 <haasn> (Bitraversable gives you (Maybe a, Maybe b) -> Maybe (a,b))
01:00:50 <dibblego> http://comonad.com/reader/2008/zipping-and-unzipping-functors/
01:01:01 <dibblego> unfzip :: Functor f => f (a, b) -> (f a, f b)
01:01:47 <haasn> I guess that's why there isn't a class for it
01:03:50 <shachaf> Why is every Functor strong?
01:10:55 <haasn> I'm not sure if that's a trick question
01:11:22 <Saizan> shachaf: because Hask is self-enriched, i think
01:12:43 <shachaf> haasn: It's not.
01:14:00 <haasn> I think what edwardk is referring to is the fact that you can write Functor f => (a, f b) -> f (a, b) without any extra constraints on ‘f’. Were you looking for something more general than that?
01:16:16 <shachaf> haasn: I was looking for something slightly more "why"y than that.
01:16:29 <shachaf> But maybe Saizan's answer makes sense...
01:16:52 <shachaf> I guess I should figure out some examples of categories that are strong and some that aren't.
01:21:36 <Saizan> http://ncatlab.org/nlab/show/tensorial+strength#description <- it wasn't quite the whole story
01:24:44 <shachaf> Saizan: Ah, thanks.
01:51:22 <yoeight> Anyone get a working alex 3.1.3 and happy 3.19.3 on windows ? because those packages failed to compile on Windows with ghc 7.8.2 and cabal 1.18.0.3
01:57:14 <haasn> Weird, I just tried evaluating “(&) 1 "hello"” after defining “let (&) = flip (flip (&))” in GHCi and I could not terminate it other than SIGKILL on the ghc process - ^C, ^D, etc. did not work at all. I thought ^C would eventually get you out of programs, no?
01:57:50 <shachaf> haasn: What about ^\?
01:57:54 <tikhon> euh, ^C sometimes doesn't work for me either, especially if it's taking up a lot of memory
01:58:09 <haasn> tikhon: I know that ^C doesn't immediately terminate if GHC is stuck on an external libgmp call
01:58:15 <haasn> But it terminates as soon as the call is done
01:59:04 <shachaf> I imagine it's stuck in a non-allocating loop or something?
01:59:09 <haasn> shachaf: That prints “[1]+ Stopped  ghci” and halts the process. What did I just do?
01:59:42 <shachaf> I think the new version of GHC has a flag for that or something.
01:59:51 <shachaf> haasn: ^\ sends SIGQUIT
01:59:59 <shachaf> But it looks like maybe you pressed ^Z instead?
02:00:09 <erisco> compile :: (forall t. Frameworks t => Moment t ()) -> IO EventNetwork
02:00:13 <erisco> what does the forall restrict?
02:00:14 <haasn> Oh, that's likely, \ is right next to z
02:00:27 <haasn> shachaf: I just get ^\ on the screen
02:00:29 <startling> haasn, is your keyboard a torus?
02:00:44 <tikhon> erisco: I think it's just there to make sure you can't mix events/behaviors from different networks together
02:00:47 <haasn> shachaf: and kill -SIGQUIT $(pgrep ghc) does nothing
02:00:49 <tikhon> conceptually, t is "time"
02:00:53 <tikhon> ie start time
02:00:54 <haasn> startling: It might as well be, at this point
02:00:57 <shachaf> OK, then I guess it catches that too or something.
02:01:00 <dmj`> @where ops
02:01:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:01:01 <tikhon> but honestly, the details are a bit hazy for me
02:01:08 <erisco> tikhon, hm well I might be doing that... I am stuck really
02:01:20 <dibblego> dmj`: ?
02:01:21 <erisco> tikhon, you know about reactive-banana? there are not many who do... could you help for a couple minutes?
02:01:44 <tikhon> I can try to help, but I've only played around with Reactive Banana a little bit
02:01:51 <tikhon> my FRP knowledge is mostly theoretical :P
02:02:30 <erisco> tikhon, I am trying to use switching
02:02:31 <erisco> switchB :: forall t a. Behavior t a -> Event t (AnyMoment Behavior a) -> Behavior t a
02:02:51 <erisco> I have a behavior, so to get AnyMoment Behavior I have to use 'trimB', so it seems
02:02:57 <erisco> trimB :: Behavior t a -> Moment t (AnyMoment Behavior a)
02:03:29 <tikhon> hmm, that sounds plausible
02:03:36 <tikhon> but I haven't really used the switching stuff much at all
02:03:49 <ggreg> Hi al
02:04:00 <erisco> hm, well the problem I seem to be having is that my switch needs to occur on user input
02:04:29 <tikhon> could you put up your error message (and maybe the relevant code) to lpaste or something?
02:04:37 <erisco> there is too much code to paste sorry :(
02:05:21 <erisco> I guess it may be hard to explain otherwise
02:05:31 <tikhon> what about the specific error you get?
02:05:54 <erisco> http://lpaste.net/102861
02:07:50 <erisco> so to fire a change to the event I made (of type  Event t (AnyMoment Behavior x)) I need to use the handler which is of type  AnyMoment Behavior x -> IO ()
02:08:32 <erisco> well I have a Behavior that I want to fire as the event... so to get it as an AnyMoment I have to use trimB, which lands me in Moment, which then requires me to compile and actuate to get back to IO
02:09:08 <erisco> which seems odd because basically it is saying I have to compile a network every time I want to update the behavior
02:09:19 <tikhon> yeah, that part sounds really suspicious
02:10:25 <tikhon> but yeah, I'm not sure how to deal with it either
02:10:46 <tikhon> are you sure about having to use the handler?
02:11:01 <erisco> ah wait maybe I need to use   anyMoment :: (forall t. Moment t (f t a)) -> AnyMoment f a    rathern than trimB
02:11:27 <alpounet> johnw: around?
02:11:32 <erisco> well yes... to create the switch I am using   switchB :: forall t a. Behavior t a -> Event t (AnyMoment Behavior a) -> Behavior t a   so I have to fire events every time I want to switch
02:12:25 <erisco> with anyMoment I escape the Moment monad
02:12:33 <erisco> so I will not have to compile I think
02:12:36 <Aetherspawn> woo
02:12:40 <Aetherspawn> CLBG is running 7.8.2
02:12:45 <Aetherspawn> ghc smashes java all around the board
02:16:03 <erisco> tikhon, hm I still have problems with the quantifier
02:16:12 <erisco> if only I knew better what it meant
02:17:22 <erisco> I presume it means that I cannot assume any particular 't' when I use it
02:17:34 <tikhon> yeah, I think that's the idea
02:17:45 <erisco> thing is I am not sure how I am
02:18:00 <erisco> maybe I need to put the quantifier on my stuff too? *shrug*
02:18:16 <jle`> (Maybe a, Maybe b)...the poor man's kinda-sum type
02:19:00 <erisco> jle`, what is wrong with that?
02:19:04 <jle`> equivalent to Either a b, where Just a takes precedence over Just b
02:19:10 <jle`> *if
02:19:11 <Aetherspawn> http://benchmarksgame.alioth.debian.org/u64/haskell.php
02:19:14 <Aetherspawn> woops, wrong channel
02:19:30 <erisco> jle`, how so? it could be, for example, (Just 5, Just 6)
02:19:35 <tikhon> yeah, looking at it, compile expects a network that works for *every* possible t
02:19:40 <bezirg> hi, so I am playing with Cloud Haskell, and I need to transmit an existential type Foo (defined as data Foo = forall a. (Binary a) => Foo a) . To transmit this value, foo must be an instance of Serializable (i.e. Typeable and Binary) . Unfortunately, I cannot make or derive a Binary instance for an existential type. What can I do instead? I found this solution
02:19:40 <bezirg> <https://groups.google.com/forum/#!searchin/parallel-haskell/existential/parallel-haskell/mWe-MWqTcJo/i98S3JflF18J> , but I would like to hear your opinion too
02:19:41 <tikhon> erm, a Moment
02:19:48 <tikhon> a Moment that works for every possible t
02:19:54 <tikhon> but you're giving it a specific Moment
02:20:00 <jle`> you could interpret it as Either a b if you chose to have one value take precedence over the other if both are Just
02:20:06 <erisco> *shrug* I dunno
02:20:14 <jle`> and then you can have Either3 a b c
02:20:16 <tikhon> which you're producing from registerAnchorRouting?
02:20:19 <jle`> (Maybe a, Maybe b, Maybe c)
02:20:44 <erisco> jle`, I suppose but I have used that type to represent an or-like operation
02:20:44 <jle`> just...i noticed myself doing that when I didn't want to define my own sum type for the situation
02:20:52 <erisco> jle`, ie nothing, one, the other, or both
02:21:30 <jle`> yeah that's probably one way it would be useful
02:21:33 <tikhon> what exactly does the second argument of registerAnchorRouting do?
02:21:41 <jle`> but i feel like sometimes i use it like a substitute for a proper sum
02:21:46 <jle`> because i'm lazy :|
02:22:29 <erisco> tikhon, nothing it is just 'id' right now
02:22:39 <erisco> tikhon, I do not need to compile anymore because I found use of 'anyMoment'
02:22:47 <erisco> but I still get the same quantifier error
02:22:55 <erisco> which seems odd because I've had no problems using compile before
02:24:18 <erisco> oh I know now I think
02:24:25 <erisco> switchPage = fireSwitchPage . anyMoment
02:24:54 <erisco> and fireSwitchPage is my  AnyMoment Behavior x -> IO ()   function to fire the event
02:25:34 <dshad> there is list l :: [IO a] how can I get first element which satisfies predicate if I don't want to evaluate all elements?
02:25:55 <jle`> dshad: what kind of predicate?
02:25:58 <jle`> IO a -> Bool?
02:26:03 <jle`> a -> IO Bool?
02:26:03 <erisco> nah that doesn't seem right either
02:26:05 <dshad> yea
02:26:23 <dshad> pred :: a -> Bool
02:26:29 <jle`> ah
02:27:09 <erisco> dshad, you cannot
02:27:22 <erisco> that would leak information from the outside world
02:27:33 <jle`> well his entire function is in IO
02:27:38 <bartavel`> dshad, there is probably something in monad-loops, but it will be (a -> Bool) -> [IO a] -> IO a
02:27:54 <tikhon> erisco: I think dshad wants to stop as soon as the predicate is satisfied once
02:28:21 <pavonia> @hackage monad-loops has several variants
02:28:21 <lambdabot> http://hackage.haskell.org/package/monad-loops has several variants
02:28:38 <erisco> ah well you should be able to get [IO a] -> IO (IO a)  but no better
02:28:56 <tikhon> it's trivial to go from [IO a] -> IO (IO a) to [IO a] -> IO a
02:29:21 <erisco> yes it is
02:29:22 <erisco> odd
02:29:44 <erisco> well on second thought it would be okay :P
02:30:10 <pavonia> dshad: firstM from the package mention above
02:30:16 <dshad> pavonia: thanks
02:30:24 <tikhon> on the other hand, you would be in trouble if the [IO a] argument was an empty list
02:31:05 <erisco> something seems rather odd about that
02:31:08 <Yuu_chan> findM pred [] = return Nothing; findM pred (x:xs) = do v <- x; if p v then return (Just v) else findM pred xs
02:31:09 <shachaf> Or a list of things that don't satisfy the predicate.
02:31:11 <tikhon> or, I guess, if the predicate failed for every element
02:31:14 <simukis_> wouldn’t `fmap (takeWhile pred) . sequence` work?
02:31:31 <shachaf> simukis_: No, it would run all the actions.
02:31:57 <shachaf> The loss of compositionality is sad. :-(
02:31:59 <erisco> I guess there is nothing you can learn about which IO was selected
02:32:10 <shachaf> I,I unsafeInterleaveIO
02:32:15 <erisco> but it is odd that you technically are holding onto a different IO depending on side effects
02:32:30 <erisco> which was my original objection
02:34:17 <Yuu_chan> erisco: ability to flatten monad (monad a) into monad a is a fundamental property of any monad
02:34:39 <erisco> my favourites still are that you can move structures of statically known size out of IO and infinite structures out of IO
02:34:48 <vermeille> > 1
02:34:52 <lambdabot>  mueval-core: Time limit exceeded
02:35:09 <Yuu_chan> wat?
02:35:15 <Yuu_chan> > 42
02:35:19 <lambdabot>  mueval-core: Time limit exceeded
02:35:23 <erisco> the numbers, they are too large!
02:35:25 <erisco> > -1
02:35:26 <lambdabot>  -1
02:35:37 <vermeille> > do { (Just 42); return . (+1) }
02:35:39 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe b’
02:35:39 <lambdabot>              with actual type ‘b0 -> m0 b0’
02:35:46 <vermeille> How do I fix that?
02:35:48 <tikhon> oh, I guess dshad left :/
02:36:02 <tikhon> I wrote the straightforward recursive version with a base case, and that works fine
02:36:14 <Yuu_chan> > do {Just 423 >>= return . (+1)}
02:36:16 <lambdabot>  Just 424
02:36:47 <vermeille> I know that it works using >>=, but what if I just *want* to use do notation ?
02:37:09 <bartavelle> > do { a <- Just 42; return (a+1) }
02:37:13 <Yuu_chan> vermeille: ↑ that. Your (Just 42) is just discarded and then a function tries to be returned as Just smth.
02:37:13 <lambdabot>  mueval-core: Time limit exceeded
02:37:38 <Yuu_chan> vermeiile: okay, then do {v <- Just 42; return . (+1) $ v}
02:38:01 <vermeille> Yuu_chan: So I just misunderstood how do notation is de-sugared, will read again
02:39:07 <Yuu_chan> vermeiile: your variant is equivalent to Just 42 >> return . (+1). You can clearly see that the left value isn't used anymore.
02:40:05 <bartavelle> vermeille, also you should get a warning with -Wall when you do that
02:41:35 <Yuu_chan> Someone wondered why signature of >> isn't m () -> m a -> m a
02:41:40 <vermeille> Humm, okay, I just see the State monad syntax everywhere
02:42:02 <sipa> the syntax is the same for all monads
02:42:16 <sipa> a; b
02:42:18 <Yuu_chan> I can remember how F# forced me to insert "ignore" function in similar situations :)
02:42:33 <sipa> is desuraged into a >> b
02:42:34 <d3lxa> what's the difference between: f :: (m a, n a) => …  and f :: m a => n a => … ? I didn't know it was valid!
02:42:51 <sipa> a <- b; c
02:42:54 <startling> d3lxa: nothing
02:43:03 <Yuu_chan> d3lxa: me too o_O
02:43:24 <tikhon> you can enable a warning for that with do-notation
02:43:26 <Yuu_chan> Looks like the difference between \a b -> ... and \a -> \b -> ...
02:43:28 <tikhon> but it gets annoying quickly
02:43:30 <sipa> is desuraged into b >>= (\a -> CX)
02:43:35 <shachaf> d3lxa: It's not valid in Haskell 2010.
02:43:39 <Chousuke> do desugaring is pretty simple if you never omit the "x <-" part. Then you can replace the x <- with _ <- and realise that >> is equivalent to >>= \_ -> ...
02:43:43 <shachaf> It's valid in GHC and means the same thing.
02:44:09 <d3lxa> shachaf: ok, so it doesn't some form a type dependency?
02:44:12 <d3lxa> *create
02:44:22 <tikhon> if you really want to write "void" (our version of "ignore") all over the place
02:44:31 <shachaf> I don't know. What's a type dependency?
02:44:37 <tikhon> personally, I wasn't the biggest fan of "ignore" in OCaml, but I see how it could prevent some errors
02:45:11 <d3lxa> shachaf: if you have m a => n a, it would be something like: for this instance of m a there exists one n a (like a functional dep)?
02:45:17 <vermeille> sipa: what I meant is that with the State monad you don't explicitly write the variable which holds the state, and it's propagated implicitly
02:45:41 <shachaf> You mean as in "instance C a => D a"?
02:45:53 <shachaf> A functional dependency is yet another unrelated thing.
02:46:15 <shachaf> C a => D a => ... isn't an instance or class declaration so it doesn't declare anything like that.
02:46:21 <shachaf> It is parsed as C a => (D a => ...)
02:46:22 <d3lxa> shachaf: I mean like in: f :: m a, m b | a -> b => blabla
02:46:27 <shachaf> ?
02:46:37 <shachaf> I don't understand that syntax.
02:46:51 <d3lxa> shachaf: ok nevermind ^^ I'm not confortable with these concepts anyway
02:46:55 <vermeille> So ok, the do-notation is just horrible with the Maybe monad
02:47:15 <sipa> vermeille: you mean the monad instance for Maybe is horrible
02:47:35 <tikhon> I wouldn't say horrible, but you're probably better off with the Applicative functions instead
02:47:40 <vermeille> that's more accurate, yes
02:47:52 <sipa> it's often useful, though
02:48:04 <bartavelle> I don't find it horrible :/
02:48:07 <tikhon> ie instead of do a <- ...; b <- ...; f a b, have f <$> ... <*> ...
02:48:08 <sipa> for a sequence of computatiins, where if one fails, the whole thing fails
02:48:28 <vermeille> sipa: true, but it's better to use >>= rather than do, so
02:48:43 <sipa> vermeille: i don't understand
02:48:51 <sipa> better in what way?
02:49:02 <vermeille> code beauty, elegence etc
02:49:25 <tikhon> ooh, one neat trick I've learned is using monad comprehensions with Maybe
02:49:27 <sipa> i find do blocks often far more readable than long nested monadic binds
02:49:30 <vermeille> with the do-notation, if I'm not mistaken you have to store the result in a variable at every line
02:49:38 <vermeille> (for the Maybe monad)
02:49:45 <tikhon> one thing I do really often is say "if someCondition then Just x else Nothing"
02:49:56 <tikhon> which can be written as [x | someCondition] with monad comprehensions
02:49:56 <sipa> well you can still use higher order constructs if you need to
02:49:59 <sipa> for example
02:50:00 <d3lxa> I do think the maybe monad has its own uses, especially with lots of consecutive computations that can fail
02:50:01 <Chousuke> more elegant is to use higher-level combinators
02:50:10 <sipa> liftM2 (+) a b
02:50:10 <tikhon> well, "really often" is an overstatement, but it's a useful idiom
02:50:13 <bartavelle> vermeille, for absolutely all monads, if you want to result of the effects, you have to do that
02:50:29 <shachaf> Slightly odd that [x | True] means something different from [x].
02:50:41 <sipa> instead of aa <- a; bb <- b; aa + bb
02:50:42 <Chousuke> but it's very much situation (and user)-dependent what is "elegant"
02:51:05 <tikhon> shachaf: is the problem just overloading the list comprehension syntax, or is there some additional subtlety I'm missing?
02:51:54 <vermeille> bartavelle: State allows to "modify" a variable without name each of its temporary values
02:52:01 <vermeille> naming*
02:52:34 <tikhon> vermeille: that's a little different: the extra variable is separate from the result of each computation
02:52:34 <sipa> vermeille: even more importantly, it allows writijg code that doesn't know or care there is state being carried along
02:52:45 <sipa> *writing
02:52:49 <bartavelle> vermeille, yes, but it's not the result of the computation
02:53:07 <shachaf> tikhon: Just that I'd expect [x] to behave like a comprehension with nothing on the right side of |
02:53:08 <vermeille> True, that's just a composition of function, etc
02:53:19 <shachaf> But maybe that doesn't actually make much sense.
02:53:55 <tikhon> well, it sort of makes sense
02:55:24 <tikhon> I can't think of any good way to make it actually work that way though
02:55:48 <tikhon> I mean, the syntax of list comprehensions certainly hints towards that pretty heavily
02:55:57 <shachaf> Perhaps allowing [x |] would be something.
02:56:12 <tikhon> yeah, that could just be syntax sugar for return :þ
02:56:15 <erisco> anyone have an example for dynamic switching in reactive-banana?
02:56:19 <erisco> I am absolutely stuck on how to do it
02:56:19 <shachaf> Now I wonder whether the syntax of list comprehensions actually makes much sense.
02:56:30 <tikhon> I think it does
02:56:48 <tikhon> especially given how it very naturally mirrors do-notation
02:57:03 <tikhon> I guess I could see replacing the brackets with braces or something
02:57:13 <tikhon> { x | x <- [1..10], even x }
02:57:17 <tikhon> even more setty
02:57:37 <shachaf> I'm not sure how much sense the set notation makes either.
02:57:39 <tikhon> which is great except for the part where it wouldn't work for Set!
02:57:50 <shachaf> But list comprehensions are for lists, not sets, anyway.
02:58:19 <tikhon> I'm definitely happy overloading it for all monads (or monad plusses)
02:58:27 <tikhon> @ty guard
02:58:30 <lambdabot> MonadPlus m => Bool -> m ()
02:59:26 <tikhon> on the other hand, with the new overloaded list extension, it might have made sense to desugar list comprehensions as fromList [x | ...]
02:59:38 <tikhon> but we already have monad comprehensions, and having both is difficult at best
02:59:52 <shachaf> I'm not a big fan of the way overloaded lists desugar.
03:00:04 <tikhon> I haven't used it yet, so I'm reserving judgement
03:00:10 <shachaf> It would have been nicer to provide separate cons and nil, for instance.
03:00:32 <shachaf> So you could use it for things (like lists of existentials, maybe?) that you can't express as lists in the first place.
03:00:35 <tikhon> my main thought is that we now have overloaded numbers, overloaded strings and overloaded lists
03:00:47 <shachaf> Then again I don't know how much I like the idea of overloading lists in the first place.
03:00:50 <tikhon> and overloaded chars would make sense if we don't have them right
03:01:03 <tikhon> it's just begging for a more general "overloading" mechanism
03:01:28 <tikhon> the rule of thumb is to refactor if you see something three times
03:01:36 <tikhon> I figure it can apply to language design too :)
03:01:55 <shachaf> Maybe less overloading is the answer.
03:02:02 <shachaf> At least come up with a better answer for defaulting first.
03:02:05 <tikhon> but maybe I just want a more lispy Haskell without the parentheses
03:02:29 <shachaf> If I turn on OverloadedStrings in ghci, string literals become unusable. So I turned it off.
03:02:30 <tikhon> eh, I find overloading too useful for writing pretty code to throw away
03:02:35 <tikhon> but yeah, defaulting is annoying
03:07:51 <startling> shachaf, yeah, agreed re: cons and nil
03:08:54 <shachaf> Maybe you can use Codensity-style tricks to make monad comprehensions work with Set.
03:11:29 <tikhon> Oh, like the CPS set monad thing?
03:11:59 <shachaf> Yes.
03:12:07 <shachaf> Almost certainly not practical.
03:12:12 <tikhon> hmm
03:12:28 <tikhon> one of these days, we will just have a more general Monad class to play with
03:12:30 <tikhon> or something
03:12:57 <tikhon> until that day comes, we can just make stupid faces whenever anybody brings up the Set monad
03:13:53 <shachaf> The Set functor newtype that you can make is almost reasonable.
03:14:09 <tikhon> hmm?
03:16:13 <shachaf> @let data Tet a = forall x. Ord x => Tet (S.Set x) (x -> a)
03:16:13 <lambdabot>  Parse failed: Illegal data/newtype declaration
03:16:18 <shachaf> Hmph.
03:16:25 <shachaf> Anyway, a thing like that.
03:16:32 <tikhon> hmm, okay
03:16:36 <shachaf> instance Functor Tet where fmap f (Tet s k) = Tet s (f . k)
03:16:49 <shachaf> You can convert back and forth, and you can fmap.
03:17:06 <tikhon> yeah, I get the idea
03:17:19 <tikhon> that's pretty clever, actually
03:18:17 <supki> shachaf: why the Ord x => thing?
03:18:28 <tikhon> you need Ord for the underlying Set
03:18:30 <shachaf> Otherwise you can't use S.map at the end.
03:18:41 <shachaf> If it wasn't for that requirement you could just make Set a functor.
03:19:03 <supki> :t S.map
03:19:04 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
03:20:50 <shachaf> Oh, hmm.
03:21:14 <shachaf> I guess I'm just wrong.
03:21:54 <shachaf> You don't need the Ord dictionary since map only requires Ord b.
03:22:15 <shachaf> Oh, but that's new: http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Set.html#v:map
03:22:25 <shachaf> So when I last looked at this it required Ord a.
03:22:52 <shachaf> Great!
03:22:57 <shachaf> So we can use CoYoneda Set
03:23:11 <shachaf> We just need a different lowering function.
03:36:34 <atlasblade> hello
03:36:36 <atlasblade> https://www.youtube.com/watch?v=DgxAHjWhOIY
03:36:38 <atlasblade> hhhhhhhhhhhhhh
03:56:18 <erisco> I do not understand this type error http://lpaste.net/102863
03:56:56 <erisco> how can  m ()   fail to match with  (forall t. Frameworks t => Moment t ())   ?
03:57:00 <erisco> it could pick any monad it wants
04:00:18 <tibbe> eribeiro: I think we’re missing a bit of context
04:00:28 <tibbe> it can’t pick any monad
04:00:35 <tibbe> it needs Frameworks t
04:00:43 <tibbe> m () doesn’t guarantee that you have one
04:00:53 <tibbe> think of: Frameworks t => Moment t () as Frameworks t -> Moment t ()
04:01:13 <erisco> I am so confused at this point
04:01:38 <tibbe> erisco: can you paste a bit more code?
04:02:19 <erisco> http://lpaste.net/102864
04:02:47 <erisco> haven't had this much trouble debugging in a long time
04:03:21 <erisco> error was from line 6 on the paste
04:04:03 <tibbe> I’m trying to figure out what â? in your first paste is
04:04:14 <erisco> probably some ansi control sequence
04:04:20 <erisco> my terminal does not support ansi
04:04:27 <tibbe> ok
04:05:15 <tibbe> http://lpaste.net/102863
04:05:56 <tibbe> I’m not sure
04:06:52 <erisco> (actuate <=< compile) (return ())
04:06:56 <erisco> this alone does not compile
04:07:00 <erisco> I do not understand what has happened :s
04:07:57 <erisco> uh but  actuate =<< compile (return ())  did compile
04:08:23 <erisco> :t \f g -> (f <=< g) (return ())
04:08:26 <lambdabot> (Monad m1, Monad m) => (b -> m c) -> (m1 () -> m b) -> m c
04:08:34 <erisco> :t \f g -> f =<< g (return ())
04:08:36 <lambdabot> (Monad m1, Monad m) => (a -> m b) -> (m1 () -> m a) -> m b
04:09:21 <erisco> it is the same thing... wut...
04:09:51 <erisco> is this some inference bug?
04:13:02 <erisco> I don't even know
04:16:23 <jakex> is there no built in way to parse this?
04:16:23 <erisco> now I am getting rigid type problems
04:16:27 <jakex> > read "[1..10]" :: [Int]
04:16:30 <lambdabot>  *Exception: Prelude.read: no parse
04:16:42 <isomorphic> I'm just reading (http://www.haskell.org/pipermail/haskell-cafe/2012-March/100488.html) -  has anybody ended up implementing a dataframe-like concept in Haskell?
04:20:58 <steveo_> what argument parsing library do you recommend?
04:23:36 <simon> steveo_, parseargs?
04:23:50 <erisco> okay well it has been about four hours so I guess I give up
04:23:57 <erisco> and try again some other time
04:25:53 <bennofs> steveo_: I quite like optparse-applicative
04:26:17 <bennofs> It doesn't use any TH and is still not overly verbose
04:31:34 * hackagebot FontyFruity 0.2.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.2.1 (VincentBerthoux)
04:35:10 * steveo_ tried optparse-applicative, example on hackage doesnt compile :/
04:36:05 <steveo_> sorry my mistake, it does
04:41:27 <steveo_> how do you specify required argument (not an option) with optparse-applicative?
04:43:03 <bennofs> steveo_: 'argument' ?
04:43:58 <srhb> Not using "optional" in general. :)
04:44:00 <steveo_> <*> argument ( metavat "FOO" ) is what I tried, getting errors
04:44:09 <steveo_> metavar
04:44:20 <bennofs> steveo_: you need to use argument Just (...)
04:45:11 <bennofs> steveo_: see http://hackage.haskell.org/package/optparse-applicative-0.8.0.1/docs/Options-Applicative-Builder.html
04:46:01 <steveo_> how come Just is needed for argument but not for strOption and switch, as per example?
04:46:38 <bennofs> steveo_: because argument has a different type signature ?
04:47:30 <steveo_> ok, I think this is too complex for my current haskell. I like the syntax but I dont understand anything
04:47:36 <steveo_> haskell level
04:48:06 <srhb> steveo_: It will be a bit magical until you understand what Applicative is
04:48:12 <srhb> steveo_: But that's really all you need.
04:48:33 <steveo_> I thought I did understand it. guess not
04:48:42 <aphury> Hello. I’ve got a question about a special case pattern: http://lpaste.net/102868
04:49:17 <aphury> something like „typ inference“ ?
04:50:20 <fizruk> aphury: seems like ViewPatterns
04:52:36 <bergmark> aphury: you would need ghc generics to do something like that
04:53:03 <bergmark> with that you can match on the structure of the types
04:53:12 <aphury> fizruk, bergmark: so ViewPatterns aren’t part of vanilla ghc?
04:53:27 <bergmark> you need {-# LANGUAGE ViewPatterns #-}
04:54:17 <bergmark> you need to change your code a bit to use view patterns, but that sounds like a better option
04:55:18 <aphury> I’ve never heard before of such stuff. Thanks a lot.
04:58:31 <fizruk> aphury: here's some information with examples for ViewPatterns https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
04:58:55 <aphury> that’s what I’m trying to understand at the moment.  : )
05:00:24 <steveo_> ok optparser starting to make more sense now
05:00:50 <Guest7723> @pl \x -> mod x 3 == 0 || mod x 5 == 0
05:00:50 <lambdabot> ap ((||) . (0 ==) . flip mod 3) ((0 ==) . flip mod 5)
05:01:53 <srhb> Augh, my eyes.
05:02:01 <lieven_> heh project euler 001 rides again
05:03:26 <bennofs> > mapM (flip mod) [3,5] $ 15
05:03:30 <lambdabot>  mueval-core: Time limit exceeded
05:04:34 <bennofs> > all (mod 15) [3,5]
05:04:37 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Bool)
05:04:37 <lambdabot>    arising from a use of ‘GHC.Real.mod’No instance for (GHC.Num.Num GHC.Types...
05:04:37 <lambdabot>    arising from the literal ‘15’
05:05:18 <linduxed> hey guys
05:05:29 <linduxed> i'm building a password generation application
05:05:41 <linduxed> i'm trying to put stuff in reasonably named directories
05:06:04 <linduxed> i've got a directory called "cli" for command line related stuff like argument parsing and output
05:06:26 <linduxed> then i have a directory for "algorithms", since there a few different ones
05:06:48 <linduxed> but then i have a couple of things which kinda tie the CLI stuff with the algorithms
05:06:54 <linduxed> what would you call that?
05:06:57 <linduxed> plumbing?
05:06:59 <linduxed> misc?
05:07:16 <srhb> linduxed: Usually they are called Modulename.Internal....
05:07:30 <linduxed> srhb: i was thinking about "internal" actually!
05:07:37 <linduxed> but it sounded so... generic
05:07:44 <linduxed> then again "misc" isn't much better
05:07:58 <srhb> linduxed: Aren't you asking us about where to put your "internals" that are "generic" between two module interfaces? :P
05:08:09 <linduxed> haha, true
05:08:14 <srhb> ;)
05:08:30 <linduxed> but yeah i was curious if there was some other fancy word for that that i had forgotten
05:18:07 <steveo_> getting my way around optparse. I understand enough to use it now, I am just not sure what (String -> Maybe a) function is supposed to do in argument? documentation doesnt say.  https://hackage.haskell.org/package/optparse-applicative-0.8.0.1/docs/Options-Applicative-Builder.html
05:19:26 <bennofs> steveo_: it's a parser. For example, if you want to take a number as an argument, use 'argument numParser ...', where numParser (you'd have to define this function) takes a 'String' and returns 'Maybe Int'. The parser might fail, because the string is not a valid number. In this case, it should return 'Nothing'
05:19:58 <steveo_> bennofs: ah, neat
05:23:26 <steveo_> bennofs: passing readMay from Safe package worked, the right type is automatically inferred :)
05:25:56 <ZettaBlade> #webdev
05:26:30 <danilo2> Hello! I want to write a simple Haskell Daemon, that could be started and stopped like all daemons in the linux world. I want it to perform well (so not to eat CPU to much etc). And I would love to run it under both Linux and Windows - could you provide any suggestions for me please? Should I use any available library from hackage (and there are several) or just go and implement it by myself?
05:26:39 <danilo2> Any tip is very valuable :) Thank you!: )
05:28:07 <JagaJaga> danilo2: if you want it to run both linux and windows - I think it's not easy well
05:29:21 <tibbe> If I want to pack up a function `a -> Int` and an action `IO a` inside a Map value, what’s the right place to put the forall?
05:29:48 <danilo2> JagaJaga: Hmm, ok. What are the problems that you see? (I'm sorry, I've never written any daemon and I do not know this "part of world" well)
05:30:11 <tibbe> Should I use Map Key (forall a. DataTypeWithFnAndAction)?
05:30:18 <JagaJaga> danilo2: linux and windows daemons are different :)
05:30:25 <tibbe> or should the forall a. go inside DataTypeWithFnAndAction?
05:30:55 <orion> What's the difference between '->' and '<-
05:30:57 <danilo2> JagaJaga: Ok, so could you recommend any library for me to write the linux daemon first - and are there any libraries to help with the windows ones?
05:30:57 <orion> ' ?
05:30:58 <fizruk> tibbe: Map k (a -> Int, IO a) ?
05:31:19 <tibbe> fizruk: yeah, but the a varies
05:31:30 <tibbe> fizruk: I have different a’s in the Map
05:31:31 <srhb> orion: (->) is the function constructor
05:31:45 <srhb> orion: a <- b is syntax magic for b >>= \a -> ...
05:31:49 <srhb> In a do-block
05:32:04 <JagaJaga> danilo2: https://hackage.haskell.org/package/daemons try this?
05:32:25 <fizruk> tibbe: data MyType = forall a. MyType (a -> Int) (IO a)
05:32:32 <fizruk> tibbe: Map k MyType
05:32:41 <fizruk> tibbe: is that what you want?
05:32:46 <tibbe> fizruk: yes, I think so
05:33:01 <tibbe> is Map k (forall a. MyType a) also possible?
05:33:13 <tibbe> with data MyType a = MyType (a -> Int) (IO a)
05:33:16 <fizruk> tibbe: it's a different thing
05:33:18 <orion> b >>= a means, "evaluate b and pass the return value in to a" correct?
05:33:27 <tibbe> fizruk: what are the two different interpretations?
05:33:44 <tibbe> sad
05:33:51 <tibbe> misstype :)
05:33:54 <danilo2> JagaJaga: I wil ltry it - I'm asking only because there are some other librtaries like: http://hackage.haskell.org/package/hdaemonize-0.4.5.0  or  https://hackage.haskell.org/package/direct-daemonize  or  https://hackage.haskell.org/package/hdaemonize-buildfix
05:34:00 <srhb> orion: Yes, but that's not what I wrote
05:34:15 <fizruk> tibbe: when you write Map k (forall a. MyType a)
05:34:57 <fizruk> tibbe: you say "you can get value from the Map of type `MyType a` for any `a` you want"
05:35:30 <fizruk> tibbe: when you use existentials, you say "you can get value from the Map of type `MyType` with SOME `a` hidden inside"
05:35:35 <tibbe> right
05:35:40 <orion> srhb: Yup, I was asking a different question
05:35:49 <srhb> orion: Just making sure :)
05:36:00 <tibbe> the syntax here feels confusing, it’s clear to me that when the forall is at the top-level it means “caller chooses"
05:36:00 <fizruk> tibbe: and you can do with that is to apply (a -> Int) to IO a, getting IO Int
05:36:15 <tibbe> right
05:36:21 <tibbe> I definitely want the latter
05:36:41 <tibbe> so it’s clear to me what f :: forall a. … means
05:36:43 <fizruk> tibbe: yeah, forall's often confuse :)
05:36:54 <tibbe> but when you do: f :: … -> (forall a. ….)
05:36:58 <tibbe> we mean the SOME case
05:37:15 <tibbe> so I thought Map k (forall a. MyType a) it looks like the latter case for functions
05:37:22 <JagaJaga> danilo2: try the one you love more :) As for me, hdaemonize is good too because it is doing only daemon work
05:37:45 <JagaJaga> danilo2: direct-daemonize - is a wrapper
05:38:10 <fizruk> tibbe: f :: ... -> (for all a. ...) is not the SOME case
05:38:36 <danilo2> JagaJaga: Ok, thank you. At least I know I should stay with one of hdaemonize or daemons and not to look ffor something else :) thank you! :)
05:39:13 <tibbe> fizruk: oh?
05:39:22 <fizruk> tibbe: f :: a -> (forall b. b -> b); f _ = id
05:39:26 <tibbe> fizruk: in the runST case it’s the some case no?
05:39:28 <JagaJaga> danilo2: np man :)
05:39:39 <fizruk> :t runST
05:39:41 <lambdabot> (forall s. ST s a) -> a
05:39:54 <tibbe> I guess that’s different
05:41:47 <fizruk> tibbe: (forall s. ST s a) value is one agnostic of any particular `s` being used
05:42:01 <fizruk> tibbe: so it's a value which works for ANY `s`
05:42:09 <tibbe> right
05:42:25 <alpounet> tibbe: notice that in the runST case it's for the argument, not the result
05:42:32 <tibbe> yes
05:44:57 <alpounet> tibbe: is the use case ekg?
05:45:05 <tibbe> alpounet: yes
05:46:26 <alpounet> tibbe: so you want to store counters, indexed by some name, but letting each counter operate on a value of a non-fixed type
05:46:38 <tibbe> alpounet: kinda
05:46:52 <tibbe> alpounet: the issue is that some counters can only get their values dynamically, at sample time
05:46:54 <tibbe> think cpu temp
05:46:57 <alpounet> yeah
05:47:05 <tibbe> to complicated things more, a single sample might result in many counters
05:47:24 <JagaJaga> su
05:47:25 <tibbe> so I have a record ([Text, a -> Int], IO a]
05:47:29 <tibbe> (somewhat simplified)
05:47:51 <alpounet> tibbe: the 'a -> Int' is "getting the particular number for this counter", then
05:48:06 <alpounet> and the 'IO a' is for getting the whole sample
05:48:20 <tibbe> yes
05:48:27 <tibbe> and there are different such whole samples
05:48:29 <tibbe> one for gc, etc
05:48:36 <alpounet> yes ok
05:51:11 <alpounet> then yeah you want the 'some' case, probably packing the forall in a data type
05:55:52 <tibbe> alpounet: yes
05:55:58 <tibbe> alpounet: the syntax is confusing
05:56:00 <tibbe> at least to me
05:56:07 <tibbe> it’s not clear where the forall goes
05:56:42 * hackagebot conduit-combinators 0.2.5 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.5 (MichaelSnoyman)
06:06:54 <pozori> quick question: can I do whatever I can in Java in Haskell>
06:07:54 <Yuu_chan> pozori: no
06:08:47 <pozori> Yuu_chan: ok thanks, can you give some example?
06:10:30 <Fuuzetsu> Well well, that's certainly incorrect. Turing equivalence and such.
06:11:59 <Yuu_chan> pozori: you can't write "int i = 42;" in Haskell
06:12:34 <Yaniel> > i = 42 :: Int in i
06:12:37 <lambdabot>  <hint>:1:3: parse error on input ‘=’
06:12:41 <matheus23> GHC gives me "not in scope" errors on field definition identifiers when defining a "data"
06:12:42 <Yaniel> > let i = 42 :: Int in i
06:12:43 <Yuu_chan> That's different!
06:12:44 <lambdabot>  42
06:13:00 <MagneticDuck> you can also say
06:13:04 <matheus23> Oh, nevermind, fixed ;)
06:13:09 <MagneticDuck> > do { let i = 42; return i }
06:13:11 <lambdabot>  <hint>:1:27: parse error on input ‘}’
06:13:13 <MagneticDuck> uhhh
06:13:18 * MagneticDuck runs
06:13:23 <MagneticDuck> wait a second
06:13:52 <MagneticDuck> anyway, in that type of thing. "let i = 42" is the same thing as "i <- return 42"
06:13:55 <Yuu_chan> You can't define interfaces and classes in Haskell. You can't inherit types in Haskell. What can be done "equivalently" is another question.
06:13:55 <FreeFull> > let i :: Int; i = 32; in i
06:13:58 <lambdabot>  32
06:13:59 <pozori> Yuu_chan: I meant something more concrete than defining variable types. Like am I somehow limited in what kind of applications I can create with HaskeL?
06:14:23 <Yaniel> you aren't
06:14:50 <MagneticDuck> pozori: ??
06:14:57 <MagneticDuck> haskell is turing complete
06:15:03 <MagneticDuck> and it's a lambda calculus, which makes it awesome
06:15:11 <MagneticDuck> and you can has the foreign calls
06:15:25 <MagneticDuck> and do the low level stuff to; there's nothing you concretely can't do
06:15:30 <Yuu_chan> In fact, I don't really like using Turing equivalence IRL as long as it quickly mutate into Turing tar pit (google it). So more useful question would be "Can I do whatever in same or more convenient way?"
06:15:31 <Hodapp> Haskell is a lambda calculus?
06:15:37 <FreeFull> Haskell lets you be polymorphic on a return value (using typeclasses)
06:15:54 <MagneticDuck> Hodapp: it's a typed lambda calculus
06:15:59 <MagneticDuck> with sugar and stuff
06:16:03 <FreeFull> GHC implements Haskell on top of System F, which is typed lambda calculus
06:16:04 <MagneticDuck> and a bunch of other stuff too
06:16:57 <Yuu_chan> Hodapp: during compilation, Haskell is firstly translated into Core, which is almost pure kind of lambda calculus (with few syntactic extensions)
06:17:11 <Hodapp> huh...
06:17:22 <MagneticDuck> someday I'd like to learn a bit about how ghc works
06:17:27 <MagneticDuck> sounds fun
06:17:34 <Felicia18>  Hi! I give you some videos. I hope you like! http://j.mp/1gAh6Jy
06:17:40 <MagneticDuck> !!
06:17:46 <Yuu_chan> MagneticDuck: chapter 25 of RWH is excellent
06:18:01 <MagneticDuck> rofl Felicia18
06:18:16 <MagneticDuck> posts shortened link to some stuff, claims it's "videos", leaves
06:18:19 <MagneticDuck> what the...
06:18:39 <Hodapp> I clicked it anyway.
06:18:49 <MagneticDuck> don't, if you're on windows and if you don't know what you're doing xD
06:18:56 <MagneticDuck> I'll check it out safely
06:19:00 <Hodapp> why in the hell would I be on that tinker-toy bullshit OS?
06:19:09 <MagneticDuck> good <3
06:19:19 <Yuu_chan> Hodapp: please watch your tongue
06:19:33 <Hodapp> Yuu_chan: That IS watching my tongue.
06:19:58 <MagneticDuck> Yuu_chan: lol
06:20:09 <MagneticDuck> it's irc.freenode.net
06:20:13 <MagneticDuck> ofc we're all dissing windows
06:20:25 <MagneticDuck> ...but this belongs on #haskell-blah =P
06:20:31 <Yuu_chan> This is #haskell, not #windows-is-crap
06:21:03 <MagneticDuck> this is #haskell@irc.freenode.net =P
06:21:05 <srhb> Yuu_chan: Let it slide, your objection to his opinion is more noisy than his opinion. :)
06:22:20 <ScriptDevil> So, I finally got the cabal-install to build (It was previously failing because of HTTP 4000.2.4 failing to build) by downgrading network from 2.5.0.0 to 2.4.2.
06:22:44 <MagneticDuck> O.o
06:22:49 <MagneticDuck> what distro you on?
06:23:11 <Yaniel> oh, the bot is back... so Felicia this time
06:23:33 <ScriptDevil> MagneticDuck: Why? Ubuntu 12.04, but I have custom-built haskell-platform 2013.2
06:23:34 <Yuu_chan> A lot of spammers nowadays :(
06:23:36 <ScriptDevil> Why?
06:23:51 <Yaniel> MagneticDuck: "posts link, leaves" ... has quit (K-lined)
06:24:53 <ScriptDevil> MagneticDuck: https://github.com/haskell/HTTP/issues/55 This was the issue.
06:24:59 <MagneticDuck> I see
06:47:25 <spacekitteh> i keep getting "cabal: does not exist" when i try to update or upload. what?
06:52:37 <tobiasgw> Sorry if this is the wrong channel for noob questions, but if anyone could look at this http://lpaste.net/102872 and tell me how the string could be replaced by a random number I would appreciate it :)
06:52:46 <MagneticDuck> spacekitteh: paste full result of an offending command
06:53:28 <MagneticDuck> tobiasgw: first things first, why all the "do"s?
06:53:52 <MagneticDuck> just S.scotty 3000 . S.get . S.json $ <your string here>
06:54:01 <MagneticDuck> that's a function of type String -> IO ()
06:54:06 <srhb> tobiasgw: This is the right channel for noob questions, by the way. :)
06:54:10 <MagneticDuck> as for the random number...
06:54:21 <tobiasgw> thanks guys!
06:54:24 <MagneticDuck> "2" is a random number =P (determined by dice roll, guarenteed to be random)
06:55:17 <MagneticDuck> *ahem*
06:55:26 <tobiasgw> the reason for all the do's is because this is just a snippet from the real source file where there are multiple S.get
06:55:33 <tobiasgw> hehe
06:55:34 <MagneticDuck> ohk
06:55:43 <srhb> tobiasgw: So ScottyM is actually ScottyT Text IO
06:55:49 <MagneticDuck> but my way is probably a bit easier to understand
06:55:52 <srhb> tobiasgw: Which means you can lift IO-actions with liftIO
06:56:02 <MagneticDuck> anyway, you have your function String -> IO (), you can generate a IO String with System.Random
06:56:06 <MagneticDuck> use >>= to bind them...
06:56:11 <MagneticDuck> @type (>>=) bind
06:56:14 <lambdabot>     Not in scope: ‘bind’
06:56:14 <lambdabot>     Perhaps you meant one of these:
06:56:14 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
06:56:17 <MagneticDuck> lol >_>
06:56:19 <MagneticDuck> @type (>>=)
06:56:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:56:37 <MagneticDuck> or use do-notation to do it for you (a >>= b) is the same as (do x <- a ; b x)
06:56:40 <tobiasgw> wow, look at that
06:56:53 <MagneticDuck> what?
06:57:00 <tobiasgw> lambdabot
06:57:03 <MagneticDuck> @type fmap . fmap . fmap
06:57:04 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:57:07 <MagneticDuck> HAVE FUN KID
06:57:11 <spacekitteh> MagneticDuck: Downloading the latest package list from hackage.haskell.org
06:57:11 <spacekitteh> cabal: does not exist
06:57:19 <MagneticDuck> literally just that?
06:57:20 <srhb> tobiasgw: Do you know about transformers? :)
06:57:29 <tobiasgw> no
06:57:35 <MagneticDuck> srhb: I don't think so, given he's asking a question like that =P
06:57:37 <MagneticDuck> yeah
06:57:43 <spacekitteh> MagneticDuck: yep.
06:57:58 <srhb> tobiasgw: What they enable you to do is run actions from several monads via lifting
06:58:01 <MagneticDuck> spacekitteh: wow what an error message :D I interpret it to mean that cabal doesn't exist
06:58:16 <MagneticDuck> spacekitteh: lols? what kind of a system are you on?
06:58:16 <spacekitteh> MagneticDuck: it does though
06:58:16 <tobiasgw> srhb: any recommended reading?
06:58:18 <srhb> tobiasgw: In thise case you want to lift randomRIO (start,end) into the Scotty monad
06:58:28 <spacekitteh> gentoo. it was working yesterday ;-;
06:58:30 <MagneticDuck> spacekitteh: hm.
06:58:50 <srhb> tobiasgw: Hm, let me think, I don't quite remember where I studied it...
06:58:59 <MagneticDuck> spacekitteh: :<
06:59:07 <srhb> tobiasgw: Maybe this: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
06:59:17 <MagneticDuck> spacekitteh: just a check, run "whereis cabal"?
06:59:25 <MagneticDuck> just to make sure we're not making some huge mistake ;)
06:59:36 <spacekitteh> /usr/bin/cabal
06:59:43 <dcoutts> MagneticDuck: it's a message from cabal, reporting an exception
06:59:47 <MagneticDuck> yes
06:59:55 <dcoutts> the exception detail is that something, probably a file, does not exist
07:00:00 <tobiasgw> srhb: http://lpaste.net/102872
07:00:02 <dcoutts> but it's swallowing one part of the exception
07:00:04 <MagneticDuck> yes yes yes
07:00:11 <dcoutts> which is a pita :-)
07:00:21 <tobiasgw> that's how I would imagine it
07:01:23 <MagneticDuck> spacekitteh: well, the problem is probably that ▒▒▒▒▒▒▒ does not exist
07:01:33 <MagneticDuck> =P
07:01:52 <tobiasgw> but I guess calling randomIO inside the do causes trouble. Is this where lifting comes in?
07:02:17 <srhb> tobiasgw: http://lpaste.net/102872
07:02:21 <srhb> tobiasgw: Yes exactly
07:02:33 <srhb> tobiasgw: We need to transform IO Something into ScottyT foo IO Something
07:02:43 <srhb> tobiasgw: and that is exactly what liftIO does
07:03:29 <srhb> tobiasgw: The wikibooks page is quite good, you should really read it. Transformers are super powerful :)
07:04:03 <aphury> are ViewPatterns anything else but are more convenient way of writing case-statements?
07:04:31 <aphury> (well case-statements of the form „case f x of“ where f is a function a -> a
07:04:43 <aphury> or a -> b  …
07:05:03 <srhb> aphury: Not really, no.
07:05:09 <MagneticDuck> aphury: ?
07:05:22 <aphury> srhb: thanks.  : )
07:05:24 <aphury> hm?
07:05:37 <tobiasgw> srhb: aah, so "lifting" is sort of "wrapping"? Because we're not getting rid of IO, but rather wrapping it in ScottyT foo
07:05:43 <MagneticDuck> case statements are of the form "case x of ['pattern that could match a value of type x' -> 'value of type y']
07:05:52 <srhb> tobiasgw: I don't really like the term "wrap"
07:06:01 <tobiasgw> no?
07:06:15 <MagneticDuck> 'return' is the wrapper
07:06:18 <MagneticDuck> @type return
07:06:20 <spacekitteh> MagneticDuck: so any idea then? :\
07:06:21 <lambdabot> Monad m => a -> m a
07:06:22 <srhb> tobiasgw: We're making it sequencable inside the ScottyM monad, when before it was only sequencable in the IO Monad
07:06:29 <MagneticDuck> spacekitteh: nope xD
07:06:31 <MagneticDuck> nice name though
07:06:35 <spacekitteh> . -.
07:06:36 <spacekitteh> thanks
07:06:37 <MagneticDuck> it needs a complementing picture
07:07:05 <srhb> tobiasgw: Basically the transformer is a stack of monads layered atop each other, with IO at the bottom. liftIO "lifts" the IO action up into the monad you're working in.
07:07:46 <spacekitteh> MagneticDuck: http://i.imgur.com/yV1uFaf.jpg
07:07:50 <tobiasgw> my god this is difficult to wrap my head around (or should I say lift my head around)
07:08:04 <Yaniel> lift into your head?
07:08:10 <MagneticDuck> tobiasgw: what have you learned about so far in haskell?
07:08:17 <MagneticDuck> you're all caught up with monads?
07:08:26 <MagneticDuck> by caught up I mean you understand them
07:08:30 <MagneticDuck> spacekitteh: removed
07:08:40 <srhb> tobiasgw: :-) read the page, try some simpler examples with say MaybeT or StateT
07:08:43 <joneshf-laptop> what's the difference between intersperse and intercalate in the english use?
07:08:52 <srhb> tobiasgw: Once you get that it becomes really simple to work with
07:08:54 <tobiasgw> I thought I did, but this lifting business confuses me
07:09:06 <joneshf-laptop> they seem to mean very near the same thin, but i'm not sure the intuition that caused the names in haskell
07:09:11 <spacekitteh> MagneticDuck: http://i.imgur.com/yV1uHaf.jpg
07:09:18 <tobiasgw> I'll hit the books again
07:09:19 <srhb> tobiasgw: The "top monad" has no notion of how to do things that other monads do
07:09:24 <SaBer> I'm looking at some haskell code and it has "... $_f ..." where "... $ f ..." would work. When trying this in ghci it gives me an error. I can't figure out what it is and why it works in the code...
07:09:26 <MagneticDuck> spacekitteh: oo
07:09:31 <srhb> tobiasgw: Ie. State doesn't know how to putStrLn
07:09:39 <srhb> tobiasgw: It only knows put and get and modify
07:10:09 <MagneticDuck> SaBer: I'm not sure how well ghci deals with 'where' statements
07:10:12 <srhb> tobiasgw: By lifting an IO action, it becomes part of what your current monad "can do" -- broadly speaking
07:10:17 <MagneticDuck> SaBer: how are you using it exactly?
07:10:37 <MagneticDuck> > a where a = 1
07:10:40 <lambdabot>  <hint>:1:3: parse error on input ‘where’
07:10:41 <geekosaur> leading _ conventionally means it's unused (analogy to _ as the anonymous binding pattern). ghci may be doing some DMR+extended defaulting silliness
07:10:42 <MagneticDuck> yeah
07:10:51 <MagneticDuck> where doesn't work inside a do statement
07:10:53 <SaBer> MagneticDuck: it doesn't have where. I mean it is using $_ in a place where $ would work
07:11:01 <srhb> tobiasgw: But yeah, hit the books and try some simpler examples and come ask if you have any difficulties. :)
07:11:08 <MagneticDuck> SaBer: oh x|
07:11:13 <tobiasgw> srhb: but how does it know *how* to do the things the current monad can do?
07:11:17 <geekosaur> um. show actual code I think
07:11:32 <SaBer> specifically "hPutStrLn h $_joinMessage botname botkey" where "hPutStrLn h $ joinMessage botname botkey" works also
07:11:50 <MagneticDuck> @type ($_)
07:11:57 <lambdabot>     Found hole ‘_’ with type: a
07:11:57 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
07:11:57 <lambdabot>                the inferred type of it :: (a -> b) -> b at Top level
07:12:02 <srhb> tobiasgw: Not sure I follow. If you have say StateT Int IO () -- that's a state monad transformers where you can use get and put on the Int-state and also lift IO actions such that they can be sequenced normally
07:12:13 <MagneticDuck> oops x| yes, type holes.
07:12:20 <srhb> tobiasgw: If you want to know how it's done, you need to read the actual implementations :)
07:13:31 <geekosaur> _ is an identifier character, it would group with joinMessage not with $
07:14:01 <MagneticDuck> > let _a = 1 in _a
07:14:04 <lambdabot>  1
07:14:24 <MagneticDuck> is there even something called "$_"?
07:14:28 <MagneticDuck> I've never heard of it
07:14:33 <tobiasgw> srhb: thank you so much, I think I need to read more about monads and transformers :)
07:14:39 <fizruk> MagneticDuck: try perl
07:14:45 <MagneticDuck> fizruk: no :D
07:14:46 <srhb> tobiasgw: It's a glorious world of discovery, have fun ;)
07:15:02 <geekosaur> MagneticDuck, as I said, _ is an identifier character, $_ is two tokens in haskell not one
07:15:09 <fizruk> MagneticDuck: they have a plenty of $_ $@ $^ and other funny variables
07:15:22 <geekosaur> and $_joinMessage is $ _joinMessage
07:15:54 <geekosaur> unless TH is enabled in which case it's splicing _joinMessage
07:16:13 <MagneticDuck> cool
07:17:23 <Sgoettschkes> Hi
07:17:34 <MagneticDuck> HI
07:18:35 <SaBer> geekosaur: there's no _joinMessage. just "joinMessage :: String -> String -> String"
07:19:20 <SaBer> I think I'll just accept I don't know why it's there, and not use it, as it's not needed :)
07:19:23 <geekosaur> that will not cause $_ to somehow parse as an operator though. but it does perhaps suggest TH shenanigans.
07:19:31 <geekosaur> since that can create names
07:20:00 <SaBer> I've never used TH, but I don't see any indications that it would be in use in this code...
07:20:00 <Sgoettschkes> Does anybody have some good blog posts or something on how to structure a big project written in haskell (or any functional lanuage)?
07:20:43 <geekosaur> I wouldn't want to say much more without seeing a lot more of the code; in some ways haskell is fairly context sensitive
07:22:57 <SaBer> geekosaur: I was going to paste the code, and then noticed it's some strange character encoding issue. My emacs just happens to show it as $_ when it's actually $<some weird whitespace>
07:23:03 <SaBer> lol
07:23:07 <geekosaur> ah, heh
07:50:12 <kqr> is there a pointless way to write the function \x -> return () >> blah x that doesn't involve compisition of a section? (i find those hard to read)
07:50:39 <kqr> (return () isn't just that, but it's an effectful equivalent)
07:52:58 <kqr> basically "apply this function but first do this side effect"... it feels like something i should know
07:55:06 <kqr> written more concisely
07:55:30 <kqr> ma :: m a   ;   mf :: b -> m c
07:55:35 <kqr> and i want the composition
07:55:39 <kqr> \x -> ma >> mf x
07:55:47 <kqr> without the lambda, if legible
07:56:45 <tv> kqr: how about  (>>) (return ()) . blah  ?
07:56:52 * hackagebot permutation 0.5.0.4 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0.4 (spacekitteh)
07:57:21 <kqr> tv, that's slightly better than (ma >>) . mf
07:57:37 <kqr> tv, but not good enough to warrant replacing \x -> ma >> mf x in my opinion... maybe i'm wrong
08:01:48 <ReinH> kqr: I'd just use the lambda
08:01:50 <ReinH> or give it a name
08:02:43 <epta> Is there a short version of (\a b -> isNothing b || (return a) == b)?
08:03:00 <srhb> I.. doubt that
08:03:05 <kqr> ReinH, that's what i'll do!
08:03:06 <kqr> thanks
08:03:38 <ReinH> epta: did you mean || or |?
08:03:50 <shergill> so free applicatives. why is the signature of Ap :: f a -> Ap f (a -> b) -> Ap f b instead of Ap :: Ap f a -> Ap f (a -> b) -> Ap f b
08:03:58 <epta> @t (||)
08:03:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
08:04:09 <shergill> http://hackage.haskell.org/package/free-3.2/docs/Control-Applicative-Free.html
08:04:11 <ReinH> Apocalisp: oh I see
08:04:15 <ReinH> er epta
08:04:23 <epta> ReinH: (||)
08:04:29 <Apocalisp> hello, yes?
08:04:41 <ReinH> Apocalisp: sorry
08:04:42 <Apocalisp> oh
08:04:49 <Apocalisp> well, hi, how are you?
08:05:00 <ReinH> Apocalisp: hi :) I'm well and you?
08:05:13 <Apocalisp> Freaking amazing
08:05:18 <ReinH> :D yay
08:05:43 <kqr> epta, why not
08:05:54 <kqr> epta, \a b -> Just a == b
08:06:15 <ReinH> (\a b -> isNothing b || (pure a) == b) is shorter
08:06:17 * ReinH ducks
08:06:48 <ReinH> > (\a b -> isNothing b || (pure a) == b) undefined Nothing -- kqr
08:06:50 <lambdabot>  True
08:06:53 * hackagebot pdf-toolbox-core 0.0.2.1 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.2.1 (YurasShumovich)
08:06:55 * hackagebot pdf-toolbox-content 0.0.3.0 - A collection of tools for processing PDF files  http://hackage.haskell.org/package/pdf-toolbox-content-0.0.3.0 (YurasShumovich)
08:06:57 * hackagebot pdf-toolbox-document 0.0.3.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.3.0 (YurasShumovich)
08:07:54 <ReinH> (\a b -> isNothing b || pure a == b) is even shorter
08:08:07 <kqr> ReinH, man do i hate bottom
08:08:17 <ReinH> kqr: doesn't need to be bottom
08:08:29 <kqr> aha?
08:08:38 <epta> kqr: maybe because I'm incredible dummy. thanks
08:08:45 <ReinH> kqr: b just needs to be nothing
08:08:56 <kqr> epta, \a b -> Just a == b also happens to be the same thing as
08:09:00 <kqr> epta, (==) . Just
08:09:05 <kqr> epta, if you want it even shorter
08:09:08 <petrie> What exactly is "<-" do? like in "s <- openSerial"
08:09:09 <ReinH> epta: kqr's isn't the same as yours
08:09:26 <ReinH> @where lyah
08:09:26 <lambdabot> http://www.learnyouahaskell.com/
08:09:31 <srhb> petrie: a <- b; ... is b >>= \a -> ...
08:09:32 <ReinH> petrie: read the parts on monads :)
08:09:32 <kqr> ReinH, yeah but it only matters when bottoms are present, right?
08:09:48 <petrie> srhb: yeah that was my question if it was different from ,l,k.l
08:09:48 <ReinH> > (\a b -> isNothing b || pure a == b) "foo" Nothing -- kqr
08:09:50 <lambdabot>  True
08:09:58 <petrie> er
08:10:03 <ReinH> > (\a b -> Just a == b) "foo" Nothing
08:10:05 <lambdabot>  False
08:10:05 <petrie> if it was different from >>=
08:10:15 <srhb> petrie: No, it is syntax sugar for that.
08:10:36 <ReinH> kqr: different behavior
08:10:44 <kqr> ReinH, oh.
08:10:49 <kqr> ReinH, i'm the incredible dummy here, apparently
08:10:53 <ReinH> no
08:10:54 <petrie> srhb: thanks
08:10:56 <ReinH> you just missed something
08:10:57 <ReinH> :0
08:11:00 <ReinH> :p
08:11:01 <ReinH> it happens
08:11:10 <kqr> hah yeah, apparently
08:11:15 <kqr> i even made a truth table and everything to be sure
08:11:19 <ReinH> hahaha
08:11:23 <kqr> yet i steamed ahead assuming isNothing was isJust
08:11:43 <kqr> and || was &&
08:12:01 <shergill> demorgan would understand
08:12:01 <srhb> kqr: at least it compiles! :-)
08:12:54 <ReinH> @check \a b -> (isNothing b || pure a == b) == (Just a == b)
08:12:57 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
08:12:57 <lambdabot>  () Nothing
08:13:27 <ReinH> Apparently it tested Just () 3 times first?
08:13:53 <pmade>  > (\a b -> maybe True (==a) b) 1 Nothing
08:14:05 <pmade> darn space.
08:14:07 <shergill> not surprising. since quickcheck does random testing giving higher weight to 'special values'
08:14:12 <shergill> so it has a tendency to repeat
08:14:34 <kqr> pmade, that's quite neat though
08:14:44 <ReinH> @check \a b -> (isNothing b || pure a == b) == (maybe True (==a) b)
08:14:46 <lambdabot>  +++ OK, passed 100 tests.
08:15:06 <ReinH> It's neat. I prefer the original for readability.
08:15:19 <pmade> Yeah, the original reads better for sure.
08:15:45 <ReinH> although the pointfree version is rather pretty
08:15:48 <ReinH> @pl \a b -> maybe True (==a) b
08:15:48 <lambdabot> maybe True . (==)
08:16:53 <ReinH> Also I'd just like to remind people that the Num instance for functions is magical
08:16:54 * hackagebot acme-pointful-numbers 0.1.2.3 - Make more than one point in numeric literals  http://hackage.haskell.org/package/acme-pointful-numbers-0.1.2.3 (AntonNikishaev)
08:19:07 <ReinH> Part of the phi accrual failure detector involves computing `1 - (the cumulative distribution of the normal distribution of the detector's sample of accrued timing data)'
08:19:37 <pmade> Whoa, is that composition also doing some sort of partial application?  I haven't seen composition of functions that take more than one argument.
08:19:39 <ReinH> so pLater t detector  = 1 - (cumulative (getNormal detector) t)
08:19:51 <ReinH> or, with the num instance, pLater = 1 - cumulative . getNormal
08:19:52 <ReinH> MAGIC
08:20:52 <ReinH> @pl f a b = g (h a) b
08:20:53 <lambdabot> f = g . h
08:21:01 <epta> ReinH: yep, you're right, maybe True . (==) looks fine
08:21:17 <srhb> epta: eek, at least keep the a :P
08:21:30 <ReinH> epta: it makes sense to. Check Just a for equality otherwise return true
08:21:45 <Jafet> I like the implicit optimism expressed by the proposition
08:21:47 <ReinH> srhb: nah :p yolo
08:21:53 <ReinH> Jafet: heh :)
08:21:55 <srhb> :P
08:21:58 <ReinH> Jafet: did you get my pm yesterday?
08:22:22 <ReinH> pmade: does that show what's happening any more clearly?
08:23:04 <pmade> ReinH: Probably, I just need to stare at it some more ;)
08:24:48 <skypers> is there any guy who knows how lambdacube or any Haskell renderer system does when dealing with shared values? for instance shared shaders for several 3D objects?
08:24:51 <pmade> I'll get my whiteboard out and do some equational reasoning, that should help.
08:25:00 <ReinH> pmade: :)
08:25:37 <ReinH> @pl f a = g (h a)
08:25:38 <lambdabot> f = g . h
08:26:06 <ReinH> g (h a) = \b -> g (h a) b (eta expansion)
08:26:12 <ReinH> pmade: that about do it? :)
08:26:43 <pmade> Yes, that helps.  Thanks.
08:26:51 <ReinH> *eta abstraction
08:27:03 <skans> good evening
08:27:11 <skans> i happen to have problems with xmonad and chromium/certain games in fullscreen. in particular, those applications pop up in every workspace kind of as a background ...
08:27:18 <skans> i've tried the composer approach, as well as recompiling xmonad - neither seem to help
08:27:25 <skans> i've this problem on a gentoo machine, as well as on ubuntu with the new tahr version ...
08:27:32 <skans> does anyone happen to have an alternative fix for this problem?
08:27:40 <skans> thank you in advance for any help
08:27:44 <ReinH> skans: as this is a general Haskell channel, you might find your answer in #xmonad if no one here knows
08:28:01 <ReinH> I wouldn't be surprised if there are xmonad users here though
08:28:22 <prophile> I always hated the term "users"
08:28:25 <Jafet> Hmm, I would want chromium as a background
08:28:26 <prophile> makes software sound like drug habits
08:28:41 <ReinH> prophile: isn't it thouguh
08:29:01 <prophile> I could stop using GHC any time I wanted, I just don't want to
08:29:09 <skans> ReinH: i know. but the guys at xmonad forwarded me here as #xmonad seems to be ... filled only, but not active
08:30:08 <ReinH> skans: haha a "not my problem" redirection loop :D
08:30:38 <prophile> "chromium/certain games" sounds a lot like it might be borderless windows
08:30:40 <ReinH> prophile: you have a problem.
08:31:00 <skans> prophile: hrm. any way i could test that?
08:31:24 <prophile> skans: iirc, xeyes is borderless so I guess see what happens with that
08:32:22 <pii> how can i tell which module a function comes from?
08:32:55 <pyon> I have a monotone function "CompleteLattice a => a -> a", is there any library for computing its least/greatest fixpoints?
08:33:02 <tapuu> Does anyone here have any experience with running a haskell program in a minimal chroot?
08:33:14 <prophile> pii: :i in GHC
08:33:36 <Jafet> pyon: fix
08:33:49 <pii> prophile: cool, thanks
08:34:02 <ReinH> least and greatest coincide :)
08:34:27 <kqr> is default a keyword in haskell?
08:34:31 <tapuu> Does the GHC runtime require access to /dev?
08:34:42 <pyon> Um, I want to use knowledge about the values of a type... MINUS BOTTOM... being a lattice.
08:34:54 <srhb> kqr: I believe so
08:34:55 <ReinH> Jafet: hmm, not the typical fix f = let x = f x in x
08:34:59 <pyon> complete* lattice*
08:35:01 <prophile> tapuu: you could try stracing your program and seeing what it does
08:35:16 <ReinH> findFix f x = let x' = f x in if x == x' then x else findFix f x'
08:35:23 <ReinH> pii: ^
08:35:35 * pyon
08:35:47 <Jafet> pyon: so you mean the lattice of haskell values, not ones that you made up yourself. Then use lub.
08:35:55 <tapuu> prophile: That sounds like a good idea. It's just `main = putStrLn "hello world"` though :)
08:36:16 <prophile> well, strace whatever program it is you want to run in the chroot then :)
08:36:26 <ReinH> lub is still magic to me
08:36:29 <ReinH> :/
08:36:44 <tapuu> prophile: I'm trying to get it working with the hello world first
08:36:56 <prophile> then strace the hello world example
08:37:02 <Jafet> Heh, the lub package also exports a glb. Now that one sounds evil.
08:38:46 <pyon> Jafet: never mind, found this -- https://hackage.haskell.org/package/lattices-1.2.1.1/docs/src/Algebra-Lattice.html#lfp :-)
08:39:04 <Jafet> pii: :i is usually misleading. If you want to know the correct module for importing a name, read the module's documentation
08:39:51 <tapuu> ah, its reading proc
08:40:06 <Jafet> (For example, :i Prelude.foo almost never mentions "Prelude".)
08:41:54 <ReinH> So I'm reading the original applicative paper for maybe the 5th time. It's starting to click.
08:41:55 * hackagebot http-test 0.1.7 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.7 (glutamate)
08:42:13 <ReinH> I have to remind myself pretty constantly that I'm not stupid. Some things are just hard.
08:47:00 <skypers> 17:39 < ReinH> I have to remind myself pretty constantly that I'm not stupid. Some things  are just hard.
08:47:03 <skypers> which ones?
08:47:20 <ReinH> skypers: lots of things. :)
08:47:41 <ReinH> skypers: understanding monads, applicatives, comonads, hom-sets, you name it
08:52:09 <skypers> ReinH: currently I have difficulties to represent entity semantic
09:00:17 <ReinH> skypers: like what?
09:05:44 <Eduard_Munteanu> Let f :: A -> Double, 0 <= f x <= 1 forall x :: A. Is there a way to pick x randomly such that p(x) = f x without inverting f?
09:12:23 <skypers> 17:57 < ReinH> skypers: like what?
09:13:06 <skypers> like embedding objects in others and make them change automatically
09:16:03 <ReinH> like what? :)
09:19:25 <exicer> Stupid question - how do I know how many threads I can assign from a given computer ?
09:19:35 <exicer> I have two cores, but presumably each core can have several threads ?
09:19:48 <merijn> exicer: You're talking about forkIO threads?
09:20:02 <jakex> if you are, that would be several hundred thousand, or more..
09:20:40 <exicer> Hm, I just mean when I compile with -threaded
09:20:43 <c_wraith> exicer: Heck, even at the os level, you can have least thousands of threads.  (forkIO threads are much lighter than OS threads)
09:20:45 <exicer> what value of Nx can I put ? :p
09:20:57 <c_wraith> recent versionf of GHC, you can just put -N
09:21:02 <exicer> realy ?
09:21:08 <exicer> how recent ?
09:21:24 <c_wraith> I'm not sure it was an option before 7.6
09:21:29 <Heffalump> -N just controls the number of OS threads, AFAIK, not the number of Haskell forkIO therads
09:21:30 <c_wraith> Maybe it was
09:21:38 <epta> How to fix that? https://gist.github.com/dmalikov/c3a09b871d9e530eb0a5
09:21:41 <ReinH> -N controls the number of cores utilized
09:21:50 <exicer> Ah, so in my case I only want 2
09:22:00 <Eduard_Munteanu> Note -N controls how Haskell threads are multiplexed onto OS threads, but the number of Haskell threads depends on your code.
09:22:32 <merijn> Heffalump: -N controls the number of capabilities
09:22:51 <merijn> The number of OS threads can be greater due to foreign calls happening in separate threads
09:23:07 <sapog> Hi guys, anybody knows what's the problem here? len' = lenT 0 where     lenT acc [] = acc     lenT acc (x:xs) = lenT $ acc + 1 $ xs
09:23:11 <exicer> So in general is the best bet to just use -N ?
09:23:14 <c_wraith> epta: the simplest fix is to disable OverloadedStrings on that file.
09:23:26 <sapog> The error message is horrible
09:23:32 <ReinH> Right, -N is the number of OS threads, which you often want to match the number of cores.
09:23:33 <c_wraith> epta: otherwise, you'll have to explicitly indicate that each string constant has the type String
09:23:45 <ReinH> sapog: what is the error?
09:23:46 <geekosaur> epta: ideally don't use printf, it plays weird type games and will play very badly with overloaded literals
09:23:58 <sapog> hs.hs:40:23:     Occurs check: cannot construct the infinite type: t1 = [t0] -> t1     Expected type: [t0] -> t1       Actual type: [t0] -> [t0] -> t1     In the expression: lenT $ acc + 1 $ xs     In an equation for `lenT': lenT acc (x : xs) = lenT $ acc + 1 $ xs     In an equation for len':         len'           = lenT 0           where               lenT acc [] = acc               lenT acc (x : xs) = lenT $ acc + 1 $ xs  hs.hs:40:
09:24:18 <geekosaur> sapog: you are almost certainly misusing $
09:24:27 <jakex> sapog lenT acc (x:xs) = lenT (acc + 1) xs
09:24:28 <geekosaur> also don't paste stiuff like that directly into the channel
09:24:29 <jakex> try that
09:24:44 <ReinH> geekosaur: it was a single line?
09:24:54 <ReinH> seems ok to me but I don't make the rules
09:25:00 <geekosaur> a single incomprehensible line minus line breaks, yes
09:25:11 <geekosaur> I suppose if readability isn't of concern it's perfectly fine
09:25:26 <geekosaur> but, oddly, I am trying to read it and think readability helps
09:25:38 <geekosaur> maybe I'm completely off base here
09:25:59 <sapog> It wasn't one line. Well, now the error is smaller... Where is it better to paste it?
09:26:12 <ReinH> sapog: check /topic
09:26:12 <klugez> sapog: http://lpaste.net/
09:26:13 <geekosaur> @paste
09:26:13 <lambdabot> Haskell pastebin: http://lpaste.net/
09:26:16 <ReinH> or that
09:27:19 <sapog> Here is it. http://lpaste.net/102878 And why was there a problem with $ ? I thought I can put it everywhere when I'm applying a value to a function
09:28:10 <ReinH> sapog: f $ g $ x = f (g x), not (f g) x
09:28:48 <sapog> ReinH, wow, I got it, thanks
09:28:57 <jmcarthur> ReinH: I've taken to the idea that it is misleading to say that -N is the number of OS threads. It's not, exactly. Capabilities are not exactly OS threads. For example, safe foreign calls run in separate OS threads (unless called from a thread created with forkOS) so that the capability can be doing something else.
09:29:12 <ReinH> jmcarthur: ok, I'm just going by the GHC manual :/
09:29:22 <jmcarthur> really? hmm
09:29:31 <ReinH> oh an older version though
09:30:03 <ReinH> jmcarthur: yep, still "Use x simultaneous threads when running the program." in latest
09:30:21 <ReinH> http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html#parallel-options
09:30:45 <ReinH> jmcarthur: I'm not disagreeing with tyou
09:31:02 <jmcarthur> yeah i know
09:31:30 <jmcarthur> I am 90% confident that the manual is wrong.
09:31:39 <epta> Is there a justifyRight analog for String?
09:31:59 <thoughtpolice> well, it's a distinction that's really not relevant to most people. you have 8 cores, you use -N8. the fact the RTS sometimes schedules safe calls on 'extra' threads in the background managed by the RTS is really not a distinction most people care about when they say -N8
09:32:27 <jmcarthur> thoughtpolice: True. It is perhaps telling that this section of the manual is on "parallelism."
09:32:29 <thoughtpolice> it's technically correct, but saying -N roughly implies 'the number of OS threads/cores you use' is an accurate model for almost all cases.
09:32:32 <geekosaur> also not really relevant when the whole point of that thread is that it blocks instead of blocking the whole program
09:32:43 <thoughtpolice> geekosaur: right, that too
09:32:47 <geekosaur> and a blocked thread isn't really significant in terms of using cpu cores
09:33:21 <jmcarthur> geekosaur: the whole program blocks if a thread, say, makes an unsafe foreign call and then a GC needs to run at the same time
09:33:30 <jmcarthur> geekosaur: a *parallel GC
09:33:44 <ReinH> epta: If you're doing text-based stuff you should use Data.Text
09:34:37 <ReinH> epta: which does have strip, stripStart, and stripEnd
09:34:43 <ReinH> oh justify
09:34:50 <ReinH> but my point about Data.Text still stands
09:34:59 <ReinH> especially if you're doing stuff to the end
09:38:22 <quchen> Just wondering, are there places where String is preferrable over Text or ByteString?
09:39:18 <prophile> quchen: certainly to the latter
09:39:28 <prophile> it's good not to be tied to a specific encoding
09:39:49 <quchen> Just wondering, are there places where String is preferrable over (Text or ByteString)?
09:39:52 <quchen> :-)
09:40:04 <ReinH> quchen: when you're too lazy to use Text?
09:40:39 <copumpkin> when you use cons a lot
09:41:03 <sm> when you want to minimise installation hassles
09:41:20 <prophile> when you are happy and you know it
09:41:26 <quchen> copumpkin: Text has cons too, though
09:41:30 * mmachenry2 claps his hands
09:41:58 <mmachenry> What are the benefits of Text over String?
09:42:04 <epta> speed
09:42:10 <epta> bos
09:42:10 <quchen> copumpkin: Ah, Text.Lazy.cons is O(n)
09:42:14 <jmcarthur> not just speed
09:42:22 <mikeplus64> quchen: when it's Data.Text.Lazy, it might just be the same as list cons
09:42:28 <prophile> memory usage too I think
09:42:46 <merijn> Also, Text has better unicode support than String
09:42:46 <jmcarthur> it also has more "text"-oriented operations and is a bit more pedantic about correctly handling unicode
09:42:53 <quchen> mikeplus64: It's "subject to fusion", but not inherently O(1), as far as I can tell from the docs
09:42:54 <merijn> i.e. toUpper works better
09:43:26 <they> Is there a way to make a meta module, which exports functions from other modules?
09:43:38 <they> So, instead of manually importing 4 of my modules, I can just import the one?
09:43:40 <jmcarthur> they: yes. just put the functions in its export list
09:43:44 <bergmark> they: yes you can simply reexport functions or entire modules
09:43:49 <jmcarthur> they: you can also export entire modules
09:43:49 <mikeplus64> quchen: well, lazy Text is just a list of strict Text, so lazy Text cons it can be nearly identical to list cons
09:43:54 <merijn> they: Eh, normal modules can already do that :)
09:44:12 <copumpkin> mikeplus64: except
09:44:13 <jmcarthur> they: module MyBigModule (functionFromModuleA, module B) where import A; import B
09:44:14 <quchen> mikeplus64: "Adds a character to the front of a 'Text'.  This function
09:44:14 <quchen> -- is more costly than its 'List' counterpart because it requires
09:44:14 <quchen> -- copying a new array.  Subject to fusion.
09:44:14 <quchen> "
09:44:15 <bennofs> they: http://www.vex.net/~trebla/haskell/module.xhtml
09:44:36 <they> Thanks. That's really useful.
09:46:28 <mikeplus64> quchen: yeah. i doubt they would actually do what i said, but if you import Data.Text.Internal.Lazy, you can just have cons x xs = Chunk (Data.Text.Lazy.singleton x) xs
09:47:18 <`^_^v> @pl (\n x -> sequence (replicate n x)) :: Int -> [a] -> [[a]]
09:47:18 <lambdabot> (line 1, column 45):
09:47:18 <lambdabot> unexpected '>'
09:47:18 <lambdabot> expecting operator
09:47:26 <mikeplus64> oh uh, that's Data.Text.singleton, not Data.Text.Lazy.singleton
09:47:29 <`^_^v> @pl (\n x -> sequence (replicate n x))
09:47:29 <lambdabot> (sequence .) . replicate
09:49:14 <ReinH> `^_^v: split the difference and use \n -> sequence . replicate n
09:50:36 <quchen> Funny face: replicateM
09:52:30 <intrados> Does anyone have recommendations or comparisons between tasty, htf, test-framework and hspec?
09:53:38 <ReinH> quchen: oh I guess that's the same thing duh
09:53:48 <c_wraith> intrados: isn't hspec significantly different than the rest of those?
09:54:11 <jmcarthur> :t (fmap.fmap) sequence replicate
09:54:12 <lambdabot> Monad m => Int -> m a -> m [a]
09:54:16 <ReinH> intrados: Don't know about htf, the others are all pretty good. hspec will require some familairity with / tolerance for BDD style assertions
09:54:27 <ReinH> jmcarthur: fmap sequence . replicate if you must :p
09:54:42 <jmcarthur> i dislike mixing the two styles
09:54:58 <ReinH> jmcarthur: I dislike all versions of (.).(.)
09:55:13 <ReinH> including my own
09:55:24 <ReinH> but fmap . fmap is useful for other things
09:55:32 <jmcarthur> ReinH: I like chains of fmaps, traverses, etc... "lens" style
09:55:34 <jmcarthur> right
09:56:08 <copumpkin> fmap fmap fmap
09:56:14 <intrados> c_wraith: My very inexpert impression is that hspec differs most in syntax
09:56:15 <bennofs> :t replicate & mapped.mapped %~ sequence
09:56:17 <lambdabot> Monad m => Int -> m a -> m [a]
09:56:18 <ReinH> newtype Grid a = Grid [[a]]; instance Functor Grid where fmap = fmap . fmap -- or whatever
09:56:19 <jakex> :t fmap fmap fmap
09:56:20 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:56:22 <quchen> :t fmap fix return
09:56:23 <lambdabot> b -> b
09:56:27 <ReinH> intrados: correct :)
09:56:44 <copumpkin> :t fmap . fmap
09:56:45 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:56:46 <copumpkin> :t fmap fmap fmap
09:56:47 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:56:49 <copumpkin> magic!
09:57:03 <quchen> :t fmap `fmap` fmap
09:57:04 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:57:06 <jakex> huh
09:57:07 <jmcarthur> :t traverse traverse traverse -- no magic here
09:57:08 <lambdabot> (Traversable ((->) (a -> f b)), Traversable t1, Traversable t, Applicative f) => t (t1 a) -> (a -> f b) -> f (t (t1 b))
09:57:25 <jakex> oh right, fmap for functions is .
09:57:28 <jmcarthur> ugh, i forgot it would do that. expected outright failure
09:57:48 <jmcarthur> :t fmap traverse traverse
09:57:50 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
09:58:18 <Okasu> :t let x = (.).(.).(.).(.).fmap.map.fmap.foldl in x.x 1
09:58:19 <lambdabot> (Num (a7 -> a8 -> a7), Functor f3, Functor f2, Functor f1, Functor f) => ((a5 -> a6 -> f2 [f3 ([a8] -> a7)]) -> a4 -> a5 -> a6 -> f2 [f3 a7]) -> (a -> a1 -> a2 -> a3 -> f [f1 (a5 -> a6 -> f2 [f3 ([a8] -> a7)])]) -> a -> a1 -> a2 -> a3 -> f [f1 ([a4] -> a5 -> a6 -> f2 [f3 ([a8] -> a7)])]
09:58:41 <jakex> we heard you like fmap
09:58:56 <jmcarthur> some of the best non-lens-like chaining IMO is liftA2.liftA2.liftA2 etc.
09:59:30 * quchen thinks you should use the monomorphic variants whenever possible without loss of generality. "map f [a,b,c]" over "fmap f [a,b,c]", "fmap . fmap" over "fmap fmap fmap" etc. Non-general generality only obfuscates your code.
10:00:22 <jmcarthur> quchen: i would agree except that in my style there are so many exceptions to that rule that i don't know if it's worth me supporting
10:01:04 <jmcarthur> quchen: e.g. sometimes i remove the type signature from a function to see if there is some useful generalization lurking. that rule hinders this ability
10:01:29 <quchen> Hmm I agree. I should probably have limited that to (.) and map above.
10:01:45 <quchen> 'traverse' is a lot better than whatever monomorphic version a lib might offe.r
10:02:08 <jmcarthur> i don't follow it even for map
10:02:12 <jmcarthur> i do for (.) though
10:02:53 <jmcarthur> unless i (Control.Category..) is in scope
10:02:56 <jmcarthur> -i
10:03:26 <ReinH> quchen: agree, similarly I prefer (++) to (<>)
10:03:35 <ReinH> quchen: unless I actually *want* to abstract over the choice of monoid
10:04:06 <jmcarthur> i'm too attached to parametricity to risk overly monomorphising my code
10:04:26 <ReinH> jmcarthur: Right, on the other hand, parametricity can make your programs easier to reason about
10:05:25 <ReinH> There are also different tensions for library code and application code, and for libraries of different levels of abstraction, etc
10:06:00 <jmcarthur> polymorphism is one of the greatest tools in my arsenal, IMO. i use it generously.
10:06:12 <jmcarthur> very little is lost, apart from some type inference here and there
10:07:32 <ReinH> jmcarthur: free theorems amirite
10:09:00 <jmcarthur> ReinH: I actually only have some intuitions about parametricity and can't construct free theorems on my own. Even so, I get tremendous value from it.
10:09:20 <ReinH> :)
10:09:29 <miguel_> http://pastebin.com/zDcSQDng
10:09:47 <miguel_> I'm trying to create a function that applies a predicate to every consecutive element of a given list
10:10:05 <miguel_> for example: mapPair (\x y -> x+y) [4, 5, 6]          => [9,11]
10:10:25 <ReinH> miguel_: zipWith <*> tail
10:10:33 <hpc> yeah, that
10:10:40 <quchen> @quote zip`ap`tail
10:10:41 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
10:10:48 <ReinH> quchen: lmao awesome
10:10:49 <hpc> how do you guys read code so fast?
10:11:17 <quchen> Cybernetic addons!
10:11:24 <miguel_> Oo
10:11:34 <miguel_> that was quick, thx =D
10:11:45 <ReinH> miguel_: make sure you understand what <*> is doing there
10:12:04 * hackagebot cookbook 2.3.4.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.4.0 (NatePisarski)
10:12:11 <miguel_> ReinH: not quite
10:12:22 <ReinH> miguel_: first, which instance is being used?
10:13:05 <ReinH> :t (<*>)
10:13:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:13:20 <ReinH> miguel_: so zipWith has to be an f (a -> b) for some Applicative f
10:13:28 <miguel_> sorry, kinda first timer, which instance of what?
10:13:29 <ReinH> :t zipWith
10:13:31 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:13:38 <ReinH> miguel_: instance of Applicative
10:14:17 <ReinH> miguel_: so if zipWith is an f (a -> b) for some Applicative f, and the type of zipWith is (a -> b -> c), which instance of Applicative is being used for (<*>)?
10:14:20 <miguel_> yeah... no idea what an Applicative is
10:14:40 <ReinH> miguel_: for our purposes, it's just the typeclass that includes (<*>)
10:14:44 <miguel_> ok
10:15:16 <ReinH> miguel_: you need to find some f that unifies f (b -> c) ~ (a -> b -> c)
10:15:44 <miguel_> sorry, but i dont think it was supposed to be that complicated
10:16:02 <ReinH> miguel_: but this is an opportunity for learnings!
10:16:26 <miguel_> I know, but first I wanna know why I'm gettin "cannot construct the infinite type: t1 = (t0, t1)"
10:16:40 <ReinH> miguel_: you might know that if you knew what the <*> was doing :)
10:16:49 <miguel_> after that I'll look up what is an Applicative
10:17:00 <miguel_> but there's no <*> in my code
10:17:05 <ReinH> miguel_: oh. What's your code?
10:17:08 <miguel_> Oo
10:17:18 <miguel_> http://pastebin.com/zDcSQDng
10:19:08 <ReinH> miguel_: what code is causing the error?
10:19:28 <miguel_> mapPair (\x y -> (x,y)) [4 .. 7]
10:19:47 <miguel_> both x and y give this error in (x,y)
10:20:07 <sipa> :t mapPair
10:20:09 <lambdabot> Not in scope: ‘mapPair’
10:20:17 <sipa> what is mapPair?
10:20:22 <miguel_> I defined it myself
10:20:23 <MagneticDuck> sipa: it's a function he's making that's supposed to act like..
10:20:37 <miguel_> http://pastebin.com/zDcSQDng
10:20:48 <MagneticDuck> > let mapPair f xs = zipWith f xs (tail xs)
10:20:50 <lambdabot>  not an expression: ‘let mapPair f xs = zipWith f xs (tail xs)’
10:20:59 <MagneticDuck> > let mapPair f xs = zipWith f xs (tail xs) in mapPair (,) [4..7]
10:21:00 <lambdabot>  [(4,5),(5,6),(6,7)]
10:21:06 <MagneticDuck> miguel_: right?
10:21:19 <miguel_> Oo
10:21:20 <sipa> miguel_: mapPair takes two arguments of type a
10:21:30 <MagneticDuck> huh?
10:21:33 <sipa> but it returns not something of type a but (a,a,)
10:21:33 <ReinH> miguel_: what is the type of your mapPair?
10:21:39 <MagneticDuck> no, our mapPair :: (a -> a -> a) -> [a] -> [a]
10:21:50 <MagneticDuck> sipa: huh?
10:21:54 <sipa> the argument to mapPair i mean
10:21:58 <sipa> not mapPair itself
10:22:11 <MagneticDuck> uhm.. anyway, there's the type of mapPair
10:22:19 <MagneticDuck> apparently he's having trouble defining it recursively
10:22:31 <ReinH> miguel_: your mapPair requires the produced array to have the same type
10:22:44 <ReinH> and your combining function to be closed
10:22:47 <ReinH> :t (,)
10:22:52 <lambdabot> a -> b -> (a, b)
10:22:59 <miguel_> ah
10:23:03 <MagneticDuck> miguel_: (\a b -> (a, b)) == (,)
10:23:06 <ReinH> (,) is not a -> a -> a
10:23:10 <MagneticDuck> (,) is a data constructor too
10:23:19 <MagneticDuck> ReinH: oops my bad
10:23:29 <ReinH> so it doesn't typecheck
10:23:35 <MagneticDuck> mapPair :: (a -> a -> b) -> [a] -> [b]
10:23:36 <ReinH> :t \f -> zipWith f <*> tail
10:23:37 <MagneticDuck> sry x|
10:23:39 <lambdabot> (b -> b -> c) -> [b] -> [c]
10:23:52 <miguel_> so the signature should be (a -> a -> b) -> [a] -> [b] ?
10:23:57 <ReinH> the zipWith version is what you want
10:24:03 <ReinH> your version unifies b and c
10:24:16 <MagneticDuck> he's not familiar with functions as Applicative functors, so
10:24:24 <ReinH> > let mapPair f = zipWith f <*> tail in mapPair (,) [1,2,3]
10:24:27 <lambdabot>  [(1,2),(2,3)]
10:24:29 <MagneticDuck> mapPair f xs = zipWith f xs (tail xs)
10:24:32 <MagneticDuck> is easier to understand for him atm
10:24:33 <ReinH> MagneticDuck: I was trying to make him familiar :p
10:24:34 <miguel_> yeah, just started with haskell
10:24:39 <ReinH> MagneticDuck: agree :)
10:24:41 <MagneticDuck> ReinH: hehe
10:24:43 <ReinH> MagneticDuck: I was trying to bridge that gap though
10:24:47 <MagneticDuck> kkk
10:25:04 <miguel_> I'll look into Applicative functors later
10:25:13 <miguel_> still gotta understand monads Oo
10:25:14 <MagneticDuck> @type (<*>)
10:25:15 <ReinH> miguel_: this doesn't require applicative functors at all :)
10:25:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:25:25 <MagneticDuck> miguel_: applicative functors are actually "below" monads
10:25:26 <miguel_> I know, but I had no idea they even existed
10:25:28 <MagneticDuck> =P
10:25:33 <ReinH> it just requires the definitino of <*> for one of the types that instantiates Applicative
10:25:46 <miguel_> below in complexity?
10:25:53 <ReinH> it doesn't require understanding applicatives per se at all
10:25:59 <ReinH> just picking a definition out of a list :)
10:26:03 <miguel_> uhm
10:26:28 <ReinH> with a brief diversion into type unification, which is useful anyway
10:26:29 <MagneticDuck> miguel_: usually we progress Functors -> Applicative functors -> Monads -> <things that we won't discuss here >:|>
10:26:49 <johnw> writing <*> for an Applicative is often much easier than writing >>= for a Monad
10:27:07 <skuggi> MagneticDuck: now i'm curious about what comes after Monads :)
10:27:15 <MagneticDuck> all monads are applicatives, but not all applicatives are monads
10:27:18 <ReinH> skuggi: comonads, for one :)
10:27:31 <MagneticDuck> skuggi: lens-related stuff =P
10:27:34 <sipa> common ads?
10:27:38 <skuggi> MagneticDuck: ok :)
10:27:47 <johnw> there should be Duads
10:27:53 <ReinH> well, they don't come "after" monads. They come dual to mands.
10:27:56 <MagneticDuck> Polyads
10:27:58 <ReinH> *monads
10:28:00 <sipa> monad = monoid triad
10:28:02 <ReinH> there is only one.
10:28:07 <quchen> Monads are mostly the end of the Functor-Applicative-Monad hierarchy. After that, there are related concepts, but there's nothing (widely used) that comes after Monad and serves a similar purpose.
10:28:20 <johnw> MonadPlus is slightly "after" in the Haskell hierarchy
10:28:21 <MagneticDuck> yeah
10:28:46 <ReinH> *widely used*
10:28:48 <jmcarthur> johnw: I would be more inclined to agree if MonadPlus's laws were better established
10:28:48 <skuggi> has anyone done a graph of these things?
10:28:59 <johnw> jmcarthur: yeah, I'm a bit disappointed with MonadPlus too
10:29:10 <jmcarthur> johnw: as it is, it's more of a "There's this thing which is both a Monad and monoid-like."
10:29:12 <ReinH> skuggi: http://www.haskell.org/haskellwiki/Typeclassopedia
10:29:22 <ReinH> skuggi: in the introduction
10:29:40 <skuggi> ReinH: nice
10:30:00 <ReinH> jmcarthur: of course monads are monoids but not in that way
10:30:03 <jmcarthur> right
10:30:05 <quchen> MonadPlus' laws are as established as traffic rules. People follow most of them, but nobody cares about some (speed limit, foo >> mzero)
10:30:11 <MagneticDuck> skuggi: it's pretty awesome
10:30:29 <ReinH> quchen: doesn't bottom throw a wrench into MonadPlus?
10:30:44 <jmcarthur> quchen: And as with those traffic rules, making assumptions about who is following which ones can have bad consequences...
10:30:46 <ReinH> or something?
10:31:23 <quchen> ReinH: Not that I know of
10:31:44 <MagneticDuck> refresh my memory, what is the "bottom problem"?
10:31:51 <MagneticDuck> I knew about it a while ago
10:31:53 <MagneticDuck> I seem to have forgotten
10:32:10 <ReinH> quchen: oh ok, I thought it was a problem for the >> law or something
10:32:19 <quchen> jmcarthur: Not really. I ride my bicycle like nobody else obeys traffic laws. I use my MonadPlus like nobody else obeys the MonadPlus laws :>
10:32:52 <MagneticDuck> I ride my bicycle really fast on the sidewalk!
10:32:57 <jmcarthur> MagneticDuck: I've never heard it given a name, so I don't know if the things I know about bottom necessarily apply to your question...
10:32:58 <ReinH> quchen: something like m >>= \k -> mzero = mzero where m is bottom?
10:33:10 <MagneticDuck> jmcarthur: I'm curious about everything!!!1one!!
10:33:33 <quchen> ReinH: Hmm, maybe that's an issue. But there are ones not involving ⊥.
10:33:38 <jmcarthur> quchen: So you really just mean you use MonadPlus as though it has no laws. Which is effectively the same as it having no laws. :P
10:33:45 <ReinH> quchen: ah http://web.archiveorange.com/archive/v/nDNOvChfKzIQw0Fi3q7k
10:34:08 <ReinH> quchen: I think the solution is to define the laws where m /= bottom
10:34:11 <quchen> jmcarthur: It means I try to follow them, but don't put any faith in others doing so ;-)
10:34:16 <MagneticDuck> "haskell police" needs to exist
10:34:26 <MagneticDuck> we'd send people who don't obey monad plus laws to #haskell-jali
10:34:29 <quchen> ReinH:  http://www.haskell.org/haskellwiki/MonadPlus
10:34:29 <MagneticDuck> jail*
10:34:42 <jmcarthur> MagneticDuck: basically, _|_ is one of haskell's few side effects.
10:34:51 <MagneticDuck> jmcarthur: a side effect?!
10:34:55 <MagneticDuck> how so?
10:35:08 <ReinH> quchen: oh they threw out right zero altogether?
10:35:31 <quchen> Anyway, on the serious side, I think it's safe to just ignore the Left Distribution/Left Catch laws.
10:35:51 <jmcarthur> MagneticDuck: It means that an Int, for example, is not necessarily a value.
10:35:58 <ReinH> quchen: how I assume that went http://i.imgur.com/FG39BTa.gif
10:36:53 <jmcarthur> MagneticDuck: As with most side effects, one could argue that it's not a side effect anymore if you define its semantics denotationally, etc., but nonetheless, at the very least it greatly complicates things, and at worst it takes away from the value-oriented programming that we normally encourage in Haskell.
10:37:31 <ReinH> And makes it hard to treat Haskell categorically without hand waving away bottom
10:37:35 <jmcarthur> MagneticDuck: Other Haskell side effects include "pure" exceptions (e.g. error), making the CPU hot, taking time to compute things, etc.
10:38:13 <jmcarthur> some of those are obviously easier to get rid of than others
10:38:20 <MagneticDuck> hm.
10:38:30 <MagneticDuck> taking time to compute things is viewed as a side effect?
10:38:33 <jmcarthur> can be
10:38:40 <ReinH> jmcarthur: what's even more fun is that error *is* bottom, or would be except that Haskell allows you to catch the exception it produces.
10:38:43 <MagneticDuck> well, linguistically that totally makes sense =P
10:38:46 <MagneticDuck> but.. hm
10:38:47 <jmcarthur> ReinH: yeah...
10:39:01 <ReinH> jmcarthur: so it doesn't represent non-termination
10:39:07 <jmcarthur> MagneticDuck: Not all side effects have to be "observable" from the point of view of the program.
10:39:11 <MagneticDuck> I'm never comfortable around errors
10:39:13 <ReinH> and as such doesn't *actually* allow Haskell to solve the halting problem
10:39:24 <ReinH> which is a real shame if you ask me
10:39:28 <MagneticDuck> shouldn't everything just be Either a Text or something?
10:39:34 <MagneticDuck> lols
10:39:36 <ReinH> catching NonTermination $ do
10:39:42 <jmcarthur> ReinH: well, you can't exactly catch the exception in pure code, unless you are doing something weird with unamb or something
10:39:50 <ReinH> jmcarthur: no, in IO though
10:39:52 <jmcarthur> yeah
10:39:55 <ReinH> which is pure fsvo pure
10:40:06 <MagneticDuck> hmmm
10:40:17 <jmcarthur> IO allows you to observe most of the side effects resulting from ostensibly pure code.
10:40:30 <MagneticDuck> hey guys www.you.com isn't registered
10:40:31 <ReinH> except for nontermination.
10:40:33 <ReinH> damn you math.
10:40:43 <MagneticDuck> it suprises me how sometimes site names like that aren't registered
10:41:11 <MagneticDuck> but at least pure code can't see side effects of other pure code, right?
10:41:55 <`Jake`> side effects of pure code?
10:42:03 <MagneticDuck> yes
10:42:09 <jmcarthur> MagneticDuck: It's actually hard to define what it would mean for a pure expression to observe a side effect.
10:42:14 <ReinH> MagneticDuck: well, let's say some of our pure code causes a stack overflow.
10:42:22 <`Jake`> I thought the point of pure code was to not have side effects
10:42:31 <MagneticDuck> `Jake`: yeah well a few got through =P
10:42:32 <merijn> ReinH: Not a side effect
10:42:34 <MagneticDuck> ^ back log ^
10:42:37 <jmcarthur> `Jake`: You can't really avoid all side effects, which is the topic of conversation right now.
10:42:41 <`Jake`> I see
10:42:41 <merijn> ReinH: That just means your pure code is bottom
10:42:49 <jmcarthur> `Jake`: easy examples to see include making the CPU hot and taking time.
10:42:54 <ReinH> merijn: under this definition, bottom is a side effect
10:42:57 <`Jake`> right, okay
10:43:02 <ReinH> at least the one we're operating with right now
10:43:06 * ReinH shrugs
10:43:25 <johnw> jmcarthur: isn't that because Haskell is compiled to an imperative (i.e., assembly) language before it can be evaluated?
10:43:26 <ReinH> well no
10:43:29 <ReinH> never mind
10:43:53 <jmcarthur> johnw: Not sure where you're going with this question. Do you mean to say that I'm conflating "Haskell" with an implementation?
10:44:02 <johnw> in this case I meant GHC
10:44:02 <MagneticDuck> johnw: true, haskell never makes the cpu hot, the binary executable does =P
10:44:06 <johnw> Haskell itself isn't evaluated
10:44:12 <johnw> right
10:44:21 <MagneticDuck> actually, the cpu makes itself hot.
10:44:22 <carter> johnw: whats that sentence mean
10:44:32 <ReinH> fsvo Haskell and evaluated
10:44:35 <johnw> right
10:44:36 <MagneticDuck> fsvo?
10:44:36 <jmcarthur> Yet, when writing Haskell code, I certainly care how long it takes or sometimes even how hot it makes my CPU.
10:44:42 <ReinH> for some value of
10:44:47 <johnw> evaluated in my head right now meaning: processed by a CPU
10:44:55 <jmcarthur> So it is still true that I'm thinking about the "effects" of evaluating the expression I'm writing.
10:45:09 <johnw> i mean, just thinking about Haskell could be called a side effect too
10:45:10 <jmcarthur> Although those effects aren't defined by the language standard.
10:45:22 <carter> johnw: yes, haskell gets evaluated via a transformation that preserves the semantics and gives you a binary object
10:46:07 <jmcarthur> These arguments actually rile a lot of ML programmers up, because despite all this we still call Haskell "pure." In a sense, they are being more rigorous/pedantic than we are.
10:48:17 <jmcarthur> In that many of them would actually still call Haskell impure. I do think it's partly an attempt to say Haskell hasn't achieved its purported goals, but there is a hint of truth, too, which we don't often acknowledge. IO is part of the spec, and yet we call Haskell free of side effects. It's true from some points of view and not from others, and we don't really do a good job of explaining where we are coming
10:48:19 <jmcarthur> from when we say "pure."
10:49:33 <jmcarthur> Even in the sense that we usually mean, that evaluation itself has no side effects, it's not exactly true either, as exemplified by bottom, error, etc.
10:50:43 <`Jake`> Have you guys talked about how a haskell program changing values in the RAM can be seen as side effects yet?
10:50:57 <jmcarthur> It can totally be seen as a side effect.
10:51:13 <`Jake`> right, that's why I asked
10:51:34 <jmcarthur> It's worth emphasizing that most of these side effects are things you don't *normally* care about, which still distinguishes Haskell from most languages in which most code is written with specific effects in mind.
10:52:41 <`Jake`> Yeah, proper definitions of "side effect" and "pure" would be required to efficiently discuss this stuff
10:52:43 <quchen> ReinH: Re laws, ⊥ breaks other classes too, Reader isn't a proper Monad for example: `⊥ >>= return = ⊥ >>= const = const ⊥ ≠ ⊥`, violating `m >>= return = m`
10:52:43 <MagneticDuck> `Jake`: of course a haskell *program* can have side effects
10:52:57 <`Jake`> MagneticDuck: OK, I see what you mean
10:53:02 <MagneticDuck> but the evaluation of pure haskell code with a trivial IO layer can still have side effects
10:53:19 <MagneticDuck> "trivial IO layer" is obviously a bit lacking in rigour
10:53:33 <jmcarthur> quchen: it could be argued that this is not bottom's fault but the fault of the implementation for only evaluating to WHNF
10:54:49 <ReinH> quchen: this is why we cant have nice things
10:54:58 <quchen> jmcarthur:  You mean like  `!m >>= f = \r -> f (m r) r`?
10:55:22 <quchen> ReinH: This is why we can still have nice things: http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
10:55:28 <jmcarthur> quchen: i mean that if we evaluated to HNF or NF   const _|_ = _|_
10:55:33 <ReinH> quchen: yep
10:56:40 <`Jake`> Is there a mathematical equivalent of the Reader Monad? If so, is it just not defined for ⊥?
10:56:53 <quchen> jmcarthur: Hm, I'm not sure whether this is feasible though. seq allows distinguishing these two, and removing seq would probably have other bad consequences.
10:57:13 <jmcarthur> quchen: seq would have to evaluate to HNF or NF too
10:57:27 <quchen> jmcarthur: DeepSeq is NF, isn't it?
10:57:28 <carter> i do write really really imperative haskell code :)
10:57:41 <jmcarthur> quchen: so it claims, but it can't work on functions
10:57:41 <quchen> `Jake`: SKI calculus is what Reader does, for the most part
10:57:45 <letrec> How can I write a generic function :: ReaderT a STM b -> ReaderT a IO b    I'll need to use atomically obviously but not sure how
10:57:50 <`Jake`> quchen: thanks
10:58:00 <quchen> jmcarthur: Right, the function instance is just for convenience there. Hmm.
10:58:28 <lispy> tikhon: My Haskell is the same as anyone else's. I write my types one identifier at a time.
10:58:47 <jmcarthur> letrec: note that that is the same as   (a -> STM b) -> a -> IO b
10:59:15 <ReinH> :t liftIO
10:59:17 <lambdabot> MonadIO m => IO a -> m a
11:00:09 <ReinH> :t liftIO . Control.Monad.STM.atomically
11:00:10 <jmcarthur> letrec: just with newtype wrapping, of course
11:00:10 <lambdabot> MonadIO m => GHC.Conc.Sync.STM a -> m a
11:00:30 <jmcarthur> ReinH: this is more of a hoist-like thing, i think
11:00:33 <jmcarthur> ReinH: not really lift
11:00:35 <ReinH> jmcarthur: ah
11:01:29 <ReinH> we need more synonyms for lift to overload with different monad morphisms
11:01:32 <jmcarthur> letrec: letrec anyway, the key components here are going to be ReaderT, runReaderT, and atomically. your solution will be some combination of those
11:01:36 <edwardk> @tell shergill because you want to ensure that the associativity isn't observed, and hence that it really passes the applicative laws
11:01:37 <lambdabot> Consider it noted.
11:02:17 <jmcarthur> letrec: somewhere on hackage there is another combinator that would make this a little shorter to write, but it would take more explanation...
11:02:36 <letrec> jmcarthur: Ok, thx. Will look at it. But that's def possible right?
11:02:49 <jmcarthur> letrec: yes, it is a feasible function to write
11:03:43 <jmcarthur> letrec: it can even be generalized to    (forall a. m a -> n a) -> ReaderT a m b -> ReaderT a n b
11:04:25 <jmcarthur> or to     (m b -> n c) -> ReaderT a m b -> ReaderT a n c
11:06:40 <fizruk> is there a library with polygon collision detection?
11:06:43 <ReinH> or to (a -> a') -> (m b -> n c) -> ReaderT a m b -> ReaderT a' n c because why not
11:06:43 <c_wraith> jmcarthur: that somewhere is the mmorph package, if you're looking for exactly that type
11:08:32 <jmcarthur> c_wraith: it's what i was intentionally vaguely referring to, yes
11:08:54 <jmcarthur> ReinH: i think you mean (a' -> a)
11:09:02 <ReinH> jmcarthur: I'm sure I do :)
11:10:25 <jmcarthur> if you want a function for each parameter, it would have to be:     (r' -> r) -> (forall b. m b -> m' b) -> (a -> a') -> ReaderT r m a -> ReaderT r' m' a'
11:11:16 <ReinH> jmcarthur: :)
11:11:21 <jmcarthur> oh, and either m or n would have to be at least a functor
11:11:35 <jmcarthur> *m or m'
11:11:38 <ystael> I am trying to bootstrap from an old ghc distro package (7.0.4) to a current ghc.  I thought to build cabal in order to fetch and build alex and happy so I could compile ghc.  However, building cabal from source fails because ghc can't find Control.DeepSeq.  Does that sound like my ghc is misconfigured, too old, or just installed without supporting libraries?
11:12:14 <jmcarthur> ystael: there should be some script you can run to install cabal that gets all the dependencies for you too, i think
11:12:20 <jmcarthur> *cabal-install i assume you mean
11:12:41 <jmcarthur> ystael: it should be included with the cabal-install source
11:12:51 <ystael> jmcarthur: ah, i see, i should have got the cabal-install tarball which would fetch dependencies for me, rather than just the Cabal library tarball
11:12:54 <ystael> git it, thanks
11:12:58 <ystael> *got -- :)
11:13:11 <bennofs> ystael: IIRC that script is called boostrap.sh
11:13:13 <jmcarthur> ystael: you don't really want to install Cabal anyway. you should already have it.
11:13:19 <ystael> jmcarthur: I should, but I don't
11:13:19 <jmcarthur> ystael: just cabal-install
11:13:26 <ystael> or I may not
11:13:31 <jmcarthur> ystael: Cabal is a library. cabal-install is an executable
11:13:36 <carter> ystael: you need 7.64or newer to build 7.8
11:13:42 <carter> *7.4 or newer
11:13:43 <jmcarthur> ystael: the executable is called cabal, confusingly
11:13:52 <carter> what os?
11:14:10 <ystael> carter: CentOS 5 :|
11:14:16 <carter> ENTERPRISE :)
11:14:19 <carter> ?
11:14:22 <ystael> precisely
11:14:28 <jmcarthur> ystael: you could just install from binaries, no?
11:14:41 <carter> yeah
11:14:43 <carter> dothat :)
11:14:52 <jmcarthur> ystael: there is a build with an older libgmp dependency. that's what you probably want
11:14:58 <carter> yup
11:15:00 <carter> what jmcarthur  is saying
11:15:04 <carter> jmcarthur: making it to the meetup this month?
11:16:02 <jmcarthur> carter: prbbly not
11:16:17 <jmcarthur> but maybe
11:18:46 <epta> w 15
11:20:32 <ystael> jmcarthur, carter: thanks!  i'll try it and see what happens
11:22:07 <srhb> ystael: Building all the way up from source from that version would probably take several days anyway. :D
11:27:28 <jmcarthur> srhb: no way
11:27:31 <jmcarthur> that's crazy talk
11:27:39 <srhb> jmcarthur: :o
11:27:41 <jmcarthur> an hour tops
11:27:50 <jmcarthur> and that's with a pretty slow machine
11:28:06 <jmcarthur> but, assuming you know what you're doing already
11:28:11 <jmcarthur> if you don't i could see it taking longer
11:28:39 <jmcarthur> but still not several days. that's still crazy
11:32:04 <bennofs> jmcarthur: building a fully optimized GHC took about 3 hours on my machine
11:32:26 <bennofs> iirc
11:33:34 <srhb> Yeah, about the same here.
11:35:52 <srhb> And building lens and dependencies with an unoptimized one (that was fun...) took about an hour too. :P
11:35:55 <srhb> Funtimes.
11:36:32 <augur> you know
11:36:41 <augur> it'd be really useful if type errors didn't say like...
11:36:54 <augur> cant match Char with [Char] in ...
11:37:16 <augur> but instead showed the first place in the top-down process where the check and the infer mismatched
11:37:36 <augur> by first i mean the terms, not the types
11:37:46 <itsmonktastic> is it top down? I thought it went both ways :P
11:37:51 <augur> yes
11:38:05 <augur> well its top down deconstruction, bottom up construction
11:38:20 <augur> because often you get this cant match junk deep inside a type
11:38:44 <augur> like maybe you need   (Int -> Char) -> Bool   but you gave   (Int -> [Char] -> Bool
11:38:56 <augur> and it still says it cant match Char with [Char]
11:39:28 <augur> when it should really say something like "argument to f ought to be an Int -> Char, but in fact it's an Int -> [Char]"
11:40:24 <ReinH> augur: "You have a Char where you should have had a [Char]. Good luck finding where."
11:40:40 <augur> ReinH: thats what you get, yeah
11:40:54 <augur> it shouldnt give me info about sub-formulas of types
11:41:01 <itsmonktastic> augur: I've had the same desire also. I was thinking it'd be nice to be able to step through the inference sorta :P
11:41:03 <augur> it should just give me information about the whole type for some term
11:41:34 <itsmonktastic> right, that makes sense
11:41:56 <augur> also, is there a way to turn off shadow warnings in -Wall?
11:42:35 <augur> god this code is such a mess. :D
11:42:53 <augur> i should think of how to make it cleaner using monads
11:43:27 <augur> all i need is a nice state monad and it'll probably be clean and nice
11:48:51 <augur> state really classes with my style tho
11:49:07 <augur> cause i want to write parameters early
11:49:08 <augur> like
11:49:28 <augur> instead of writing f = \thingToMatchOn accumulator -> ...
11:49:40 <augur> i want to write f = \accumulator thingToMatchOne -> ...
11:49:57 <augur> it really cramps my style, man
11:49:59 <augur> oh well
11:50:09 <awestroke> :t flip
11:50:11 <lambdabot> (a -> b -> c) -> b -> a -> c
11:50:23 <augur> awestroke: yes thats not going to help :P
11:50:34 <byorgey> augur: I think you can do   -Wall -fno-warn-name-shadowing ?
11:51:11 <augur> awestroke: the type of the acc-first f is somethinglike   f :: Acc -> Foo -> (Acc, Bar)   which cant translate easily into state
11:51:25 <augur> but f :: Foo -> Acc -> (Acc, Bar)   is just   f :: Foo -> State Acc Bar
11:51:48 <augur> byorgey: \o/
11:51:50 <augur> that worked :D
11:52:27 <ReinH> augur: I was going to say... if you are having a lot of trouble tracing it maybe you need to extract some things out and give them explicit types.
11:52:38 <ReinH> give the inferrer less work to do
11:52:46 <augur> ReinH: ey?
11:52:48 <ReinH> but generally I agree with you
11:52:51 <byorgey> augur: there's basically a global state with a bunch of Bools saying which warnings are enabled.  Commands like -Wall and -fno-warn-... just modify the state, and they are executed left-to-right
11:53:08 <augur> byorgey: ah neat
11:54:27 <ReinH> augur: if there are less types to infer it's a smaller search space for you to figure out where it broke
11:55:03 <augur> ReinH: oh, no, its not that its hard to figure out where it broke, per se
11:55:13 <byorgey> picking the right level at which to present a type mismatch that is actually helpful sounds like a very hard problem.
11:55:31 <augur> its just that i have functions with lots of args and it does me no good to get a mismatch deep inside a type for an arg, rather than shallowly for the expression as a whole
11:55:32 <byorgey> what we really need are nice tools for interactively exploring all the information available after a failed typechecking
11:55:39 <augur> i mean, did i just forget an arg? thats usually the case
11:56:01 <byorgey> error messages are so 20th century.
11:56:04 <augur> byorgey: i think the expression-type is the optimal type to provide
11:56:20 <byorgey> augur: what is the expression-type?
11:56:22 <pozori> what was the term to the right side of this: type LocationMap = M.Map Int (LState,Code)
11:56:42 <augur> byorgey: the example was, if you have   foo :: (A -> [B]) -> C   and   bar :: A -> B
11:56:48 <byorgey> pozori: I don't understand your question
11:56:56 <augur> and you do   foo bar   the error with be `cant match [B] with B'
11:57:15 <ReinH> augur: right, and I'm suggesting that maybe your functions have too many args :)
11:57:30 <ReinH> complexity begets complexity
11:57:31 <augur> byorgey: what it should be is    `can't match argument type of foo, A -> [B] with type of bar, A -> B'
11:57:32 <byorgey> augur: well, yes, I agree with you in this specific case
11:57:47 <augur> byorgey: thats my only beef right now :p
11:58:06 <pozori> byorgey: I mean it can't be really type declaration because it's not primitive but bunch of types.. so confusing. I don't know how to refer to right side of =
11:58:11 <augur> ReinH: yeah possible. im going to try to replace them with state since usually the args are for state plumbing anyway ;P
11:58:35 <augur> i hate the State monad tho. the built in one is awful
11:58:52 <augur> because it uses StateT, it kicks up a whole mess of obnoxious, inscrutible type errors
11:59:04 <augur> because im expecting something else, so i dont know how the hell it works >_>
11:59:05 <byorgey> pozori: you could refer to it as the definition of LocationMap
11:59:14 <ReinH> augur: also there's the whole laziness thing
11:59:21 <augur> ReinH: ?
11:59:24 <byorgey> pozori: it is not a type declaration, but a type definition
11:59:32 <ReinH> StateT.Lazy vs StateT.Strict
11:59:50 <pozori> byorgey: okay thanks
11:59:50 <ReinH> augur: I don't have a good handle on when I want which but it seems like I usually want the strict version
12:00:07 <augur> ahh yeah
12:00:21 <augur> usually i just make my own version of State
12:00:26 <ReinH> seems similar to foldl vs foldl'
12:00:27 <augur> its too much hassle to use the prelude version
12:00:33 <augur> which is hilariously awful
12:00:34 <ReinH> when would you want to accumulate thunks in your state?
12:00:51 <ReinH> augur: what makes it awful aside from being StateT Identity?
12:01:04 <augur> that its confusing
12:01:11 <ReinH> in what way?
12:01:12 <augur> i mean, im sure its simple in principle, you know
12:01:20 <ReinH> not disagrring with you
12:01:23 <ReinH> or disagreeing
12:01:48 <ReinH> just curious
12:01:49 <augur> but like, ive never seen a tutorial that discusses actual Prelude state, only idealized state, so i only really know whats going on with an idealized state
12:02:03 <augur> when i see prelude state, im just overwhelmed by unexplained differences
12:02:51 <augur> i mean, here's where you go for state: Control.Monad.Trans.State.Lazy
12:02:57 <augur> gag
12:04:08 <ReinH> augur: ah right yes
12:04:30 <ReinH> wait that's the transformers one
12:04:32 <ReinH> what about the mtl one?
12:04:45 <augur> who knows
12:04:47 <augur> i just hoogled
12:05:01 <MagneticDuck> yo guys, I got a question... I have a project that imports, in one of its modules, Graphics.UI.GLUT.Raw.Functions
12:05:01 <augur> Control.Monad.State.Lazy ?
12:05:02 <ReinH> heh
12:05:06 <MagneticDuck> it's a module exported by glut...
12:05:11 <augur> thats another thing
12:05:14 <MagneticDuck> and I have glut in the build-depends of my package
12:05:19 <augur> whats the diff between the mtl and the transformers one?
12:05:21 <augur> i dont know
12:05:24 <augur> its all very confusing
12:05:32 <ReinH> http://hackage.haskell.org/package/mtl-2.1.3.1/docs/Control-Monad-State-Lazy.html yeah
12:05:35 <augur> which is prelude? who knows!
12:05:35 <ReinH> it is
12:05:41 <ReinH> also mtl vs transformers is confusing
12:05:47 <MagneticDuck> however, when I try to import that module, I get an error on cabal build, saying that it is a "hidden module of the package glut-<version>"
12:05:53 <MagneticDuck> uh, what do I have to do to use that module?
12:05:58 <augur> Haskell: Great for programming, absolutely awful for learning
12:06:22 <ReinH> Well, mtl wraps transformers so
12:06:24 <ReinH> I don't even
12:06:48 <ReinH> Maybe edwardk can explain what the plan is with mtl vs transformers
12:07:05 <augur> the real problem is, i suspect, is that too many haskell behind-the-scenes people have this horrible "not my problem" attitude towards explaining things
12:07:16 <augur> "i just write code, it's not my problem if you dont understand it"
12:07:19 <ReinH> heh
12:07:45 <augur> its true
12:08:14 <augur> anyway, im off for now
12:08:18 <augur> see ya
12:08:18 <bennofs> Mtl provides the classes (MonadReader, MonadState, etc)
12:08:31 <bennofs> the transformer types are only reexported from transformers
12:08:47 <ReinH> augur: One of the issues I think is that equational reasoning makes it really easy to go from a -> g and then forget about the intervening steps
12:09:03 <ReinH> augur: then someone else reads your code and sees g and has no idea that you originally meant a or how you got to g
12:09:10 <bennofs> so Control.Monad.State.Lazy.State is the same as Control.Monad.Trans.State.Lazy.State
12:09:18 <ReinH> bennofs: right
12:09:34 <MagneticDuck> lol.
12:09:36 <ReinH> bennofs: so should I be using mtl or tranformers usually?
12:10:21 <ReinH> augur: so Haskell's algebraic program transformation tools are maybe too powerful for their own good?
12:10:25 <bennofs> ReinH: depends. If you don't want to clutter your code with lift's everytime you need to access a layer that is not the top layer, use mtl (because you need the MonadXXX classes for that)
12:10:46 <ReinH> bennofs: ahhhh right
12:10:53 <ReinH> yeah I want mtl
12:11:14 <ReinH> Although I guess the MonadXXX classes are somewhat controversial?
12:11:21 <ReinH> or not everyone likes them?
12:11:36 <saml> what's MonadXXX ? is it sex?
12:11:49 <saml> @google Monadxxx
12:11:50 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2010-September/083012.html
12:11:50 <lambdabot> Title: [Haskell-cafe] Missing documentation in Haskell Platform on Windows
12:12:25 <ReinH> Soft: the various monad transformer typeclasses. MonadState, MonadReader, MonadIO, etc
12:12:32 <ReinH> er saml ^
12:12:32 <ReinH> sorry
12:12:51 <saml> ReinH, it used to be taht way. but community moved away to functor
12:13:20 <ReinH> saml: how do you mean?
12:13:35 <saml> i don't know. i remember someone saying that. and i tried to repeat as closely as possible
12:13:43 <saml> to sound smart
12:13:50 <ReinH> heh
12:13:53 <saml> let's think about it though
12:14:08 <ReinH> I mean... monad morphisms are functors.
12:14:46 <ReinH> er natural transformations
12:15:17 <saml> module FooMonadClass   defines type class.  module FooMonad  defines newtype Foo  and instance Monad Foo,  and other instances.. and transformer
12:15:26 <saml> taht's how I used to structure program
12:16:00 <ReinH> er no, they are functors in the category of endfunctors
12:16:12 <ReinH> that preserve the category structure, a.k.a. the monad laws
12:16:18 <ReinH> iinm
12:16:40 <bennofs> ReinH: the alternative to mtl would be monads-tf, which is like mtl but uses type families in places where mtl uses FunctionalDependencies
12:16:51 <ReinH> bennofs: ah
12:17:02 <johnw> ReinH: aren't monad morphisms morphisms in the category of endofunctors?
12:17:05 <ReinH> bennofs: how frequently is monads-tf used?
12:17:18 <saml> i bet a lot
12:17:26 <ReinH> johnw: Er. Yes ofc.
12:17:27 <saml> I hear about type families  a lot
12:17:44 <saml> and I remember setting -XFunctionalDependencies
12:18:27 <bennofs> ReinH: i think not so frequently. Most people use mtl I think, and it's not such a good idea to have both installed (because then you'd need to hide one or you always get an ambiguous module error in GHCi)
12:18:42 <bennofs> ReinH: lens has mtl in its dependencies, not monads-tf :=)
12:19:01 <ReinH> johnw: right they are arrows between the objects ofc and they preserve the monad laws because the monad laws are the category laws
12:19:03 <saml> oh i see
12:19:10 <saml> mtl ftw
12:19:18 <ReinH> bennofs: well that settles it.
12:19:32 <ReinH> also mtl is maintained by edwardk so presumably has his stamp of approval
12:19:45 <saml> yah he's real good
12:21:37 <ReinH> johnw: I get confused in functor categories :/
12:21:43 <johnw> don't we all :)
12:21:59 <ReinH> at least I don't have to deal with 2-categories
12:22:35 <johnw> can monad transformers be regarded as functors in the category of endofunctors?
12:22:42 <bennofs> does vector-10.0.1 fail to compile on GHC 7.4.2?
12:23:25 <carter> bennofs: ?
12:23:41 <bennofs> I', getting
12:23:45 <bennofs>     Not a data constructor: `forall'
12:23:47 <bennofs>     Perhaps you intended to use -XExistentialQuantification
12:24:22 <carter> thats not the newest vector though right?
12:24:46 <saml> monad transformer takes a monad and transforms right
12:24:51 <carter> 0.10.9.1 is
12:24:54 <saml> * -> *
12:25:03 <simon> if I do 'map f (zip xs ys)', this will be as efficient as 'zipWith f xs ys', right?
12:26:15 <pavonia> simon: Probably a bit less due to unwrapping the pair type, not sure though
12:26:20 <quchen> The map and zip should fuse, so probably yes.
12:26:24 <johnw> what I mean is, a functor MaybeT in the category of endofunctors would map, say, Identity to MaybeT Identity, and would map natural transformations forall a. Identity a -> Foo a to forall a. MaybeT Identity a -> MaybeT Foo a.  Or am I missing something?
12:26:28 <simon> quchen, that's what I mean.
12:26:33 <triliyn> saml: monad transformers are (* -> *) -> (* -> *), I think
12:26:49 <simon> pavonia, thanks. it warrants a little test.
12:26:52 <saml> oh
12:26:58 <saml> :k (+)
12:27:00 <lambdabot> Not in scope: type constructor or class ‘+’
12:27:24 <triliyn> :k ReaderT
12:27:25 <lambdabot> * -> (* -> *) -> * -> *
12:28:05 <saml> > ReaderT Int Num Bool
12:28:07 <lambdabot>  Not in scope: data constructor ‘Int’
12:28:07 <lambdabot>  Perhaps you meant one of these:
12:28:07 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
12:28:07 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)Not in scope: d...
12:28:07 <lambdabot>  Perhaps you meant ‘Sum’ (imported from Data.Monoid)Not in scope: data constr...
12:29:26 <pavonia> > return () :: ReaderT Int Identity ()
12:29:28 <lambdabot>  No instance for (GHC.Show.Show
12:29:28 <lambdabot>                     (Control.Monad.Trans.Reader.ReaderT
12:29:28 <lambdabot>                        GHC.Types.Int Data.Functor.Identity.Identity ()))
12:29:28 <lambdabot>    arising from a use of ‘M51761072879510509926435.show_M51761072879510509926...
12:29:45 <pavonia> :S
12:30:54 <saml> haskell types make you think before coad
12:31:11 <simon> pavonia, in GHCi, there is a difference in memory use, so that's probably the unwrapping. I don't know if fusion works in the REPL.
12:31:32 <simon> wrapping/unwrapping
12:32:30 <pavonia> simon: Hhm, what are you trying to do, optimizing?
12:33:03 <srhb> simon: Checking whether the rewrite rules work should be as simple as adding a bogus one. :0
12:33:07 <srhb> :)*
12:35:25 <insitu> anyone can help on troubleshooting fay+yesod error?
12:35:48 <iota_> insitu: don't ask to ask ;-)
12:35:58 <insitu> yeah, forgot that...
12:36:31 <insitu> I have a problem with a yesod+fay project I am trying to build (and understand)
12:36:36 <ReinH> iota_: but how will anyone know that if they don't ask to ask to ask?
12:37:41 <shapr> Yay! Nine days until the lucky 13th anniversary of #haskell !
12:37:46 <ReinH> shapr: :)
12:38:12 <shapr> Well, maybe 12 days... Anyway, April 30th is the #haskell anniversary.
12:38:18 <insitu> here is a code snippet http://lpaste.net/102886 that generates the following compiler error
12:38:37 <edwardk> bennofs: monads-tf is a mostly abandoned vestige of when mtl was being rewritten. there was transformers and monads-fd and monads-tf. to rectify the terrible split in the community this caused because _all 3 packages used the same module names_, mtl 2 was created on top of transformers out of monads-fd, and monads-tf was left to die in a fire.
12:38:39 <srhb> simon: The flag does not show as active in my ghci though
12:39:25 <insitu> when built with cabal http://lpaste.net/102887
12:39:57 <edwardk> bennofs: please do not use monads-tf for new code, if your code winds up installing it it makes for a _terrible_ user experience for new users who don't know how to hide packages, as ghci starts complaining at them about ambiguous choices when they go to use anything from the mtl.
12:40:12 <SrPx> Hello, is there a tutorial or examples on how to use Control.Unification?
12:40:19 <bennofs> edwardk: i see
12:40:56 <insitu> and here is the cabal file : http://lpaste.net/102888
12:42:09 <edwardk> in practice, monads-tf shows it would be possible to write the mtl in a world without fundeps. it also shows that that world would be much more verbose. ;)
12:42:25 <srhb> simon: An easier test would probably be to compile it with -fenable-rewrite-rules and -fno-enable-rewrite-rules respectively
12:42:50 <insitu> I do not understand why the Monad.Control.IO does get used...
12:43:19 <tobiasgw> hey, does anyone know of any good articles/blog posts/papers discussing experiences with using Haskell in large scale software. I mean large scale as in number of developers, LOC, longevity etc.
12:43:33 <prophile> tobiasgw: second episode of the haskellcast
12:44:01 <prophile> (is the first thing that comes to mind)
12:44:24 <tobiasgw> prophile: thanks! I'll check that out
12:45:28 <albeit> Is there a way to make this more succinct? "f v1 v2 = if v1==v2 then Nothing else Just v1"
12:46:04 <albeit> @pl: \v1 v2 -> if v1==v2 then Nothing else Just v1
12:46:04 <lambdabot> ap (flip . flip flip Nothing . (if' .) . (==)) Just
12:47:13 <dmp1ce> I have a pretty basic cabal file but I'm getting this error: http://lpaste.net/102889
12:47:55 <insitu> dmpc1ce missing native library, like gmp ?
12:48:35 <insitu> dmp1ce sorry for misspelling nickname: I would guess missing native library issue
12:48:37 <dmp1ce> I don't know. Probably.  I'm on Arch Linux.
12:48:46 <dmp1ce> OK.
12:48:58 <insitu> dmp1ce don't know exactly what are the dependencies of vector package
12:50:10 <ReinH> albeit: I feel like you already asked this earlier
12:50:25 <saml> dmp1ce, install text
12:50:25 <ReinH> oh not quite
12:51:15 <albeit> No.. but probably something similar. It just feels like it could be better, for some reason because Maybe is a monad, but I really don't konw
12:51:16 <dmp1ce> saml: I ran "cabal install --only-dependencies" Does that not install text?
12:51:20 <saml> your version might be mismatching
12:51:46 <saml> dmp1ce, pacman -Syu
12:52:17 <dmp1ce> My dependencies are base and mysql-simple
12:53:12 <dmp1ce> saml: I just ran it and I'm up to date.
12:53:35 <saml> you're using ghc and cabal-install from extra, right?
12:53:35 <srhb> dmp1ce: Have you updated ghc recently and not sorted your local packages?
12:53:51 <dmp1ce> saml: No, I'm using haskell-core
12:54:03 <ReinH> albeit: I don't think there's anything
12:54:37 <dmp1ce> #archlinux-haskell recommend [haskell-core] instead of [extra]
12:55:25 <dmp1ce> saml: I had tried extra but I had out of memory issues.
12:56:04 <dmp1ce> saml: So this is actually an improvement. :)
12:56:12 <saml> dmp1ce, i don't know :(
12:56:17 <saml> i never used haskell-core
12:56:21 <srhb> I'm using the haskell-core version without issue
12:56:26 <srhb> 7.8.2-1 that is
12:56:41 <dmp1ce> saml: No problem.  It is probably due to trying mysql-simple
12:56:50 <ReinH> > let mwhen = bool mempty in \x y -> mwhen (Just x) (x == y)
12:56:52 <lambdabot>  <() -> () -> Maybe ()>
12:57:06 <dmp1ce> What is a good mysql library?
12:57:07 <saml> dmp1ce, and you have marinadb installed right?
12:57:14 <dmp1ce> saml: Yes
12:57:18 <ReinH> woops
12:57:35 <dmp1ce> saml: mariadb
12:59:01 <ReinH> No, because that adds an unwanted monoid constraint
12:59:08 <ReinH> er, you don't need to generalize
13:00:15 <ReinH> > (\x y -> bool Nothing (Just x) (x == y)) 1 2
13:00:16 <lambdabot>  Nothing
13:00:21 <ReinH> I'm not sure that's any better than writing it with guards though
13:04:16 <numberten> so I wrote a simple takeOnce function takes a predicate of type (a -> a -> Bool) and a [a] and returns the list tail starting at the point where sequential values satisfy the given predicate
13:04:36 <numberten> i was wondering if there was a standard library function for this, because it seems like it would be a common pattern
13:04:40 <numberten> couldn't find anything on hoogle
13:05:49 <ReinH> numberten: the usual pattern is that foo = fooBy (==)
13:05:49 <srhb> numberten: dropWhile?
13:06:01 <ReinH> numberten: this is used for, e.g., deleteBy, but oddly not for takeBy
13:06:09 <ReinH> or takeWhileBy I guess
13:06:54 <pranz> :t splitAt
13:06:55 <lambdabot> Int -> [a] -> ([a], [a])
13:06:58 <ReinH> oh never mind, takeWhile uses a different pattern
13:07:02 <pranz> :t splitBy
13:07:03 <lambdabot>     Not in scope: ‘splitBy’
13:07:03 <lambdabot>     Perhaps you meant one of these:
13:07:03 <lambdabot>       ‘splitAt’ (imported from Data.List),
13:07:12 <pranz> hmm
13:07:23 <pranz> numberten: there is some split function that does what you want iirc
13:07:33 <numberten> alright i'll keep looking
13:07:52 <srhb> numberten: Am I misunderstanding your question?
13:07:54 <ReinH> numberten: oh and you want the tail
13:08:01 <srhb> What's wrong with dropWhile?
13:08:06 <numberten> :t dropWhile
13:08:07 <lambdabot> (a -> Bool) -> [a] -> [a]
13:08:17 <numberten> i want a predicate on 2 vals
13:08:23 <ReinH> numberten: once some (x:y:ys) matches on the x and y, do you return (x:y:ys) or (y:ys)?
13:08:24 <pranz> ah, right
13:08:28 <srhb> Ah
13:09:27 <numberten> so takeOnce (>) [2,5,6,3,4,9] would return [6,3,4,9]
13:09:38 <numberten> because 6,3 is the point in the list where it satisfies that predicate
13:10:40 <ReinH> numberten: ok
13:11:41 <ReinH> so something like
13:11:43 <ReinH> > let drop' _ [] = []; drop' comp (x:y:ys) = if comp x y then (x:y:ys) else drop' comp ys in drop' (>) [1,2,3,2,3,4]
13:11:44 <lambdabot>  [3,2,3,4]
13:12:15 <numberten> yeah
13:12:17 <ReinH> numberten: how should it behave for a singleton list?
13:12:22 <numberten> yes
13:12:28 <ReinH> since ^ will error
13:12:29 <numberten> i wrote the function, actually very similar to that
13:12:38 <numberten> i was just curious if there was a standard implementation
13:12:40 <ReinH> numberten: there's nothing like that already defined that I'm aware of
13:12:45 <numberten> so I didn't need to reinvent the wheel
13:12:49 <numberten> i see
13:13:08 <srhb> > concat . tail . groupBy (>) $ [2,5,6,3,4,9]
13:13:11 <lambdabot>  [5,6,3,4,9]
13:13:17 <srhb> eck
13:13:32 <srhb> > concat . tail . tail . groupBy (>) $ [2,5,6,3,4,9] --  BEAUTIFUL
13:13:52 <srhb> lambdabot disagress :(
13:14:06 <lambdabot>  can't find file: L.hs
13:14:11 <ReinH> > concat . tail . tail . groupBy (>) $ [1]
13:14:12 <lambdabot>  *Exception: Prelude.tail: empty list
13:14:18 <srhb> orite
13:14:32 <ReinH> > concat . tail . tail . groupBy (>) $ [2,1]
13:14:34 <lambdabot>  *Exception: Prelude.tail: empty list
13:14:39 <srhb> > tail . concat . tail . groupBy (>) $ [2,5,6,3,4,9]
13:14:41 <lambdabot>  [6,3,4,9]
13:14:46 <srhb> No sweat, safety is for scaredypants.
13:14:50 <ReinH> :)
13:14:57 <srhb> God that's hideous though :D
13:15:37 <t4nk791> Hello?
13:15:42 <srhb> a short-circuiting right fold would be the right tool for the job
13:15:45 <ReinH> t4nk791: hi
13:15:47 <pranz> yo
13:15:58 <ReinH> srhb: it would need to accumulate an extra value
13:16:03 <ReinH> which is possible but annoying
13:16:33 <srhb> ReinH: I don't think it's that bad.
13:16:49 <t4nk791> Stupid newbie question...I don't understand what the "!!" is doing in the memoized fibonacci function here: http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion
13:16:56 <ReinH> sure, it's just annoying that it's a manual process
13:17:08 <ReinH> :t (!!)
13:17:14 <lambdabot> [a] -> Int -> a
13:17:15 <ReinH> > [1,2,3] !! 1
13:17:17 <lambdabot>  2
13:17:25 <srhb> ReinH: True enough.
13:17:35 <ReinH> t4nk791: !! indexes into a list
13:17:36 <pranz> t4nk791: lookup by index
13:17:48 <jmcarthur> what exactly is the spec here? i missed it
13:18:04 <jmcarthur> for that tail.concat.tail.groupBy thing
13:18:18 <ReinH> jmcarthur: (a -> a -> Bool) -> [a] -> [a] that drops until the predicate matches successive chars
13:18:21 <prophile> t4nk791: the operator is written infix, like (4 +)
13:18:25 <ReinH> and returns the remainder including the match
13:18:37 <jmcarthur> ReinH: does the predicate have to match *all* successive chars in the result?
13:18:45 <srhb> jmcarthur: No.
13:18:46 <ReinH> jmcarthur: only once
13:18:49 <jmcarthur> okay
13:18:54 <ReinH> > let drop' _ [] = []; drop [x] = [x]; drop' comp (x:y:ys) = if comp x y then (x:y:ys) else drop' comp ys in drop' (>) [1]
13:18:55 <lambdabot>  Conflicting definitions for ‘drop'’
13:18:55 <lambdabot>  Bound at: <interactive>:1:5-9
13:18:55 <lambdabot>            <interactive>:1:38-42
13:18:58 <ReinH> woops
13:19:04 <ReinH> > let drop' _ [] = []; drop' [x] = [x]; drop' comp (x:y:ys) = if comp x y then (x:y:ys) else drop' comp ys in drop' (>) [1]
13:19:05 <lambdabot>  Equations for ‘drop'’ have different numbers of arguments
13:19:05 <lambdabot>    <interactive>:1:5-19
13:19:05 <lambdabot>    <interactive>:1:22-36
13:19:09 <ReinH> sorry
13:19:13 <ReinH> > let drop' _ [] = []; drop' _ [x] = [x]; drop' comp (x:y:ys) = if comp x y then (x:y:ys) else drop' comp ys in drop' (>) [1]
13:19:15 <lambdabot>  [1]
13:19:16 <ReinH> ok
13:19:26 <ReinH> jmcarthur: ^ is a reasonable spec modulo what you decide to do for singleton lists
13:19:29 <ReinH> which is arbitrary
13:20:08 <ReinH> it's a foldr that holds onto the previous element but those are cumbersome to write
13:20:51 <ReinH> jmcarthur: I'm actually surprised there isn't already a way to write those without manually tupling and untupling the accumulator
13:21:12 <srhb> Generally you'd want a short-circuiting fold for that kind of stuff anyway
13:21:31 <srhb> Otherwise you'd need two extra parameters, once for the last value and one for "are we done now?"
13:21:39 <srhb> Which truly is hideous.
13:21:40 <jmcarthur> ReinH: wouldn't one of the mapAccums be kind of what you are talking about?
13:22:26 <ReinH> jmcarthur: maaaybe
13:22:37 <srhb> just zipWith an offset list and select based on that, clearly.
13:22:39 <srhb> :-)
13:24:05 <ReinH> heh
13:24:12 <ReinH> zip`ap`tail strikes again
13:24:29 <srhb> :-)
13:24:31 <jmcarthur> yeah i'm looking at a version that does something like that
13:24:35 <jmcarthur> but it's a bit tricky anyway
13:24:43 <jmcarthur> you have to avoid dropping the last element
13:24:46 <jmcarthur> or the firsty
13:24:48 <jmcarthur> *first
13:24:52 <jmcarthur> depending on how you write it
13:26:59 <SplinterOfChaos> Is there any Haskell utility that would read a source file and say, given "f :: a -> b" and "g :: b -> c", produce a graph linking f to g representing a possible path?
13:27:24 * hackagebot arbtt 0.8 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8 (JoachimBreitner)
13:28:17 <dmp1ce> my issue was due to memory.  I bumped my VM up to 1G ram and it works now. :)
13:30:13 <jmcarthur> > (\p -> concatMap snd . take 1 . dropWhile (not . uncurry p . fst) . liftA2 zip (zip <*> drop 1) tails) (>) [2,5,6,3,4,9]
13:30:15 <lambdabot>  [6,3,4,9]
13:30:34 <jmcarthur> :(
13:31:35 <ReinH> jmcarthur: o_O
13:32:26 <jmcarthur> i like zip<*>tails about as much as i like zip<*>tail
13:32:54 <jmcarthur> > (zip <*> tails) [a,b,c,d,e,f]
13:32:55 <lambdabot>  [(a,[a,b,c,d,e,f]),(b,[b,c,d,e,f]),(c,[c,d,e,f]),(d,[d,e,f]),(e,[e,f]),(f,[f])]
13:34:07 <jmcarthur> if we had nice standard functions for using triples like we do for tuples, i'd have just done  zip3<*>tail<*>tails
13:34:30 <ReinH> jmcarthur: :)
13:34:38 <jmcarthur> > (zip <*> tail <*> tails) [a,b,c,d,e,f]
13:34:39 <lambdabot>  Couldn't match type ‘[[Debug.SimpleReflect.Expr.Expr]] -> b’
13:34:39 <lambdabot>                with ‘[(Debug.SimpleReflect.Expr.Expr,
13:34:39 <lambdabot>                        Debug.SimpleReflect.Expr.Expr)]’
13:34:39 <lambdabot>  Expected type: [Debug.SimpleReflect.Expr.Expr]
13:34:39 <lambdabot>                 -> [Debug.SimpleReflect.Expr.Expr]
13:34:41 <jmcarthur> > (zip3 <*> tail <*> tails) [a,b,c,d,e,f]
13:34:42 <lambdabot>  [(a,b,[a,b,c,d,e,f]),(b,c,[b,c,d,e,f]),(c,d,[c,d,e,f]),(d,e,[d,e,f]),(e,f,[e...
13:34:57 <ReinH> jmcarthur: zipWith3?
13:35:01 <ReinH> oh right
13:35:20 <jmcarthur> another way would be to just use tails and map some function over that
13:36:46 <ReinH> argh not quite :(
13:36:50 <ReinH> > map snd . dropWhile (not . id . fst) . (zipWith (\x y -> (x > y, y)) <*> tail) $ [1,2,3,2,3,4]
13:36:52 <lambdabot>  [2,3,4]
13:37:46 <ReinH> uh why did I compose with id
13:37:47 <ReinH> what was I thinking
13:37:48 <ReinH> anyway
13:38:10 <ReinH> also the function used for zipping doesn't have any nice combinator afaik
13:38:26 <ReinH> @pl \f x y -> (f x y, y)
13:38:27 <lambdabot> flip flip id . (liftM2 (,) .)
13:38:30 <ReinH> yeah no
13:41:49 <ReinH> flip flip is my (least) favorite combinator
13:42:20 <simon> I think mine is (.) . (.)
13:42:38 <simon> no offense to the Martian lady in Total Recall.
13:45:22 <jmcarthur> :t flip flip
13:45:23 <lambdabot> b -> (a -> b -> c) -> a -> c
13:45:26 <jmcarthur> :t flip flip flip
13:45:27 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:45:30 <jmcarthur> :t flip flip flip flip
13:45:31 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:45:33 <ReinH> stahp
13:45:38 <jmcarthur> it never gets better
13:46:08 <jmcarthur> wait
13:46:08 <mgdm> :t toUpper
13:46:08 <lambdabot> Char -> Char
13:46:10 <jmcarthur> it stops
13:46:22 <jmcarthur> amazing
13:46:27 <jmcarthur> :t flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
13:46:28 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:46:31 <jmcarthur> it gets no worse
13:46:51 <jmcarthur> we have a flipspoint
13:47:01 <ion> > flip flip 10 (*) 4
13:47:03 <lambdabot>  40
13:47:20 <jmcarthur> once you hit four flips you might as well stop
13:47:37 <simon> ion, you just made infix completely redundant!
13:48:28 <jmcarthur> > let infix_ = flip flip in infix_ 10 (*) 4
13:48:29 <lambdabot>  40
13:49:20 <jmcarthur> but it's backward
13:49:24 <davean> Maybe we should name that the inflips operator
13:49:30 <jmcarthur> > let infix_ = flip flip in infix_ "foo" (++) "bar"
13:49:31 <lambdabot>  "barfoo"
13:49:49 <davean> exactly, inflips
13:50:34 <jmcarthur> > let inflips = flip id in inflips "foo" (++) "bar"
13:50:35 <lambdabot>  "foobar"
13:51:28 <ion> > flip asks "foo" (++) "bar"
13:51:29 <lambdabot>  "foobar"
13:51:41 <pranz> :t asks
13:51:42 <lambdabot> MonadReader r m => (r -> a) -> m a
13:54:15 <augur> ReinH: i dont think its that haskell is too powerful for its own good. i think the problem is cultural
13:55:10 <augur> ReinH: that is to say, hackers are supposed to be l33t, they're supposed to be able to grok the hardest code at a glance. no true hacker has to ask for help, or have something explained to them, they're supposed to just get it, cause thats what it means to be a l33t hacker
13:55:52 <augur> ReinH: so writing docs is beneath the hacker. writing docs means you're writing for non-hackers, and no l33t hacker would sully themselves by interacting with the inferior non-l33t people of the world if they dont have to
13:56:21 <ion> > fmap (flip fmap asks) (flip asks) "foo" (++) "bar"
13:56:23 <lambdabot>  "foobar"
13:59:31 <ion> > fmap (fmap (flip fmap fmap) (flip asks) asks) (fmap (flip fmap asks) (flip asks)) "foo" (++) "bar"
13:59:33 <lambdabot>  "foobar"
14:01:23 <augur> ion: :|
14:01:28 <augur> :t asks
14:01:29 <lambdabot> MonadReader r m => (r -> a) -> m a
14:02:05 <fizruk> :t asks :: (a -> b) -> (a -> b)
14:02:06 <lambdabot> (a -> b) -> a -> b
14:02:22 <ion> :t asks `asAppliedTo` (undefined :: a -> b)
14:02:23 <lambdabot> MonadReader r m => (r -> a) -> m a
14:02:29 <ion> aww
14:02:34 <monochrom> I write clever Haskell code and write comments to explain it.
14:03:08 <ion> :t asks `asTypeIn` id
14:03:09 <lambdabot> MonadReader r m => (r -> a) -> m a
14:03:10 <monochrom> in fact, s/Haskell //. the language doesn't matter.
14:03:13 <ion> aww
14:03:45 <fizruk> :t asTypeOf
14:03:45 <ion> Oh, duh.
14:03:46 <lambdabot> a -> a -> a
14:03:49 <ion> yeah, asTypeOf
14:04:08 <fizruk> :t asTypeIn
14:04:09 <lambdabot> a -> (a -> b) -> a
14:04:24 <fizruk> @src asTypeIn
14:04:25 <lambdabot> a `asTypeIn` f = a where _ = f a
14:04:25 <lambdabot> infixl 0 `asTypeIn`
14:07:48 <augur> so, when i import Control.Monad and then Control.Monad.State.Strict, i get a redundancy warning
14:08:08 <augur> but how can i use the State instance in Control.Monad.State.Strict? it obviously conflicts with Control.Monad.State.Lazy, so they cant both be in scope as such
14:08:32 <lispy> if you only need instances import it like this: import Control.Monad.State.Strict ()
14:08:40 <augur> hm ok
14:08:42 <quchen> … as suggested by the warning :-)
14:08:43 <lispy> I believe the redundant import warning mentions that
14:09:22 <lispy> Also, it's very rare when you want the lazy one
14:09:37 <lispy> so you should actually try to avoid having it in scope :)
14:10:16 <augur> lispy: oh, but if i need the State tycon and junk?
14:10:26 <augur> i guess (State) instead
14:11:29 <lispy> and you can use qualified imports too
14:11:57 <lispy> The module system is pretty simple, but using it well is not obvious when you're new to it.
14:12:18 <augur> lispy: im used to Agda modules which are very very different from haskell modules :\
14:13:49 <monochrom> unforuntately, "Control.Monad.State" refers to the Lazy one
14:14:19 <lispy> monochrom: Do you have to use the transformers package to avoid it?
14:14:25 * lispy doesn't use mtl very often
14:14:42 <lispy> I know I've done it (or at least thought I had), just can't recall the details
14:15:12 <pranz> I'm getting "Exitfailure 11" when installing lens on a almost clean system
14:15:18 <pranz> "World file is already up to date"
14:15:22 <monochrom> no, I don't think anything avoids it
14:15:27 <pranz> Anyone have any tips?
14:15:30 <lispy> pranz: that can happen if you run out of ram during linking
14:15:41 <lispy> pranz: how much ram do you have?
14:15:57 <pranz> lispy: 512 MB
14:16:11 <koala_man> that would explain it
14:16:13 <lispy> pranz: It's very likely you won't be able to use ghc on that machine.
14:16:14 <mgdm> Should this work, using Text.Regex.Posix? "foo" =~ "o" :: [String]
14:16:27 <koala_man> I can just barely use it with 768 mb :/
14:16:34 <mgdm> I'd expect ["o", "o"] but I get an error instead
14:16:39 <pranz> that bad huh? bummer
14:16:50 <lispy> pranz: there are some things you can do to make it more likely to work. Like rebuilding ghc with splitobjs = false
14:17:09 <lispy> pranz: or build locally on a matching VM and copy to the machine that has limited ram
14:17:28 * hackagebot laborantin-hs 0.1.5.2 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.5.2 (LucasDiCioccio)
14:17:52 <lispy> pranz: typically what goes wrong here is that gnu ld allocates lots of space for each .o file and then ghc is feeding ld lots and lots of .o files.
14:18:38 <pranz> lispy: all right, thanks for the help
14:20:34 <klrr_> pranz: you might try ajhc, no idea if that actually solve this particular problem (or if it supports TH, which lens deps on?), but i remember the term "embedded" was used in conjunction with it.  http://ajhc.metasepi.org/
14:22:06 <lispy> I would be very surprised if ajhc can build lens
14:22:31 <jmcarthur> yeah, jhc/ajhc compile via C, and so should be able to target "embedded" things as long as C can. i also agree that it is unlikely to be able to handle lens
14:22:54 <lispy> (I don't even know if cabal works with ajhc)
14:23:04 <jmcarthur> certainly not jhc
14:23:09 <jmcarthur> maybe ajhc if it was changed in the right ways
14:23:22 <jmcarthur> but jhc was almost designed *not* to work with cabal...
14:23:28 <lispy> yeah...
14:23:31 <lispy> franchise
14:23:45 * lispy wonders how many people here remember franchise
14:24:37 <stolaruk> Here I'm using IORef in Reader to keep track of state. Will this be much slower than using StateT? http://lpaste.net/102891
14:24:37 <jmcarthur> i really like GRIN and wish the jhc family would take off
14:25:11 <jmcarthur> stolaruk: potentially. it depends on how much slower is too slow and in what ways it is acceptable to be slower
14:25:24 <monochrom> yes, readIORef-writeIORef is slower than passing parameters
14:25:54 <stolaruk> I would hope it would be negligibly slower
14:26:01 <jmcarthur> it hinders a ton of optimizations
14:26:13 <jmcarthur> plus extra level of indirection, write barrier, etc.
14:26:33 <augur> are there any proposals to give haskell an Idris-like ! operator?
14:26:37 <jmcarthur> i suppose we actually hit the write barrier a lot due to laziness
14:26:44 <jmcarthur> augur: what does it do?
14:27:06 <stolaruk> what is a write barrieor
14:27:11 <augur> jmcarthur:   foo !x !y  ==  do x' <- x ; y' <- y ; foo x' y'
14:27:23 <jmcarthur> stolaruk: generational garbage collectors have to do some extra checks when you mutate stuff
14:27:43 <jmcarthur> augur: so basically Applicative?
14:27:48 <augur> jmcarthur: not quite
14:27:55 <jmcarthur> oh
14:28:02 <augur> jmcarthur: its monadic, firstly, but it lifts arbitrary subexpressions out
14:28:05 <augur> so like, you can do
14:28:07 <stolaruk> jmcarthur: so would the barrier be when the gc has to do its work?
14:28:07 <jmcarthur> that is actually what i call bind2 in my own code
14:28:20 <jmcarthur> stolaruk: no, it's when you do the mutation
14:28:33 <augur> foo (bar !x (baz !y))   =   do x' <- x ; y' <- y ; foo (bar x' (baz y'))
14:28:43 <stolaruk> jmcarthur: Oh ok so its just overhead from the gc when you mutate
14:29:05 <jmcarthur> stolaruk: there's some extra bookkeeping. basically you have to avoid objects in the older generations depending on those in the younger generations
14:29:25 <jmcarthur> stolaruk: so if a mutation would cause that to happen you have to do some extra marks or preemptively move objects around a bit
14:29:33 <stolaruk> jmcarthur: ok
14:29:37 <jmcarthur> augur: i see
14:30:03 <jmcarthur> augur: i admit i'm not a big fan at first glance. i already don't like our special treatment of monads as it is
14:30:27 <jmcarthur> but i guess i can see some appeal in terms of convenience...
14:30:41 <augur> jmcarthur: it definitely does
14:30:44 <jmcarthur> augur: is the ordering of effects defined?
14:30:58 <augur> jmcarthur: yes, left to right afaik
14:32:28 <jmcarthur> augur: actually, the more i think about it, the more niche it seems. i rarely write functions that apply monadic effects from inputs before doing anything else in practice.
14:32:47 <jmcarthur> there's usually some wrapping involved or something
14:33:12 <augur> jmcarthur: im writing a type checker for a dependently typed language and i have expressions like this:
14:33:38 <jmcarthur> and when i *would* want to do that, it's usually better to accept the parameters without the effects involved, performing the effects before applying the function to its 'pure' arguments
14:33:50 <augur> Scope freshName (subst substInfo ty) (subst substInfo body)
14:34:01 <augur> and it would be really nice to make this monadic, and just be able to ! these like
14:34:17 <augur> Scope !freshName !(subst ty) !(subst body)
14:34:30 <jmcarthur> Scope is the monad?
14:34:42 <augur> no, it's inside some monadic expr tho
14:34:47 <monochrom> although ! is richer than <*>, I think <*> is good enough for me
14:34:58 <jmcarthur> augur: i'm confused about the type of that expression then
14:35:15 <jmcarthur> augur: Scope looks like it should be a constructor for the monad you're using
14:35:25 <augur> jmcarthur: why? its inside a bigger expr of the monadic type
14:35:28 <augur> thats all that matters
14:35:49 <monochrom> this ! is dangerously close to the "do what I mean" fallacy
14:35:58 <augur> monochrom: :)
14:35:59 <ion> {-# LANGUAGE DWIM #-}
14:36:18 <jmcarthur> augur: but based on what you've said so far, it looks like that should desugar to:     a <- freshName; b <- subst ty; c <- subst body; Scope a b c
14:36:37 <augur> jmcarthur: no no
14:36:42 <augur> the general rule is like so, jmcarthur:
14:37:27 <augur> do k[!m]   ===>   do x <- m ; k[x]
14:37:31 <FOOD_> i have a question about sharing, in the expression let foo = 0:1:foo in foo, is there some sort of guarantee this list takes up constant space? im looking for a reliable way to define cyclic graphs with just lets
14:38:07 <ion> food: Yes, but note that there is no such guarantee for the value of “map id foo”
14:38:18 <jmcarthur> augur: i'm confused. what does  Scope !freshName !(subst ty) !(subst body)  desugar to then?
14:38:23 <augur> jmcarthur: in this case its something like   k[!fn,...,...] = return (Scope !fn ... ...)
14:38:33 <jmcarthur> augur: where did the return come from?
14:38:41 <augur> jmcarthur: what do you mean?
14:38:50 <FOOD_> ion: alright. so any sort of processing on the graph must be handled carefully
14:38:50 <ion> augur: Your earlier substitution didn’t have a return.
14:38:52 <jmcarthur> augur: the rule you gave doesn't mention return
14:38:57 <augur> no it didnt
14:39:03 <augur> it was parametric
14:39:29 <augur> it doesnt matter _what_ the context around the !x is, as long as its a monadic type
14:39:36 <FOOD_> ion: and is this a guarantee of the language or of ghc or what
14:39:48 <jmcarthur> what is a "monadic type"?
14:39:51 <augur> jmcarthur: ...
14:39:58 <augur> m a for some monad m and type a?
14:40:00 <jmcarthur> no really. this is imprecise language
14:40:09 <augur> its pretty precise
14:40:13 <monochrom> FOOD_: it looks like a guarantee by most compilers and interpreters, even though they don't say it
14:40:21 <jmcarthur> i don't see how this rule works. why did you introduce a return there?
14:40:33 <ion> augur: I’m just as confused as jmcarthur.
14:40:41 <augur> jmcarthur: why not? the particular example requires it, but its tangential
14:41:35 <jmcarthur> augur: so you are saying   foo !x !y  ==  do x' <- x ; y' <- y ; foo x' y'   but  Scope !freshName !(subst ty) !(subst body)  ==  do a <- freshName; b <- subst ty; c <- subst body; return (Scope a b c)   ?
14:41:46 <augur> jmcarthur: no
14:41:47 <jmcarthur> if so why? if not, where did return come from?
14:42:01 <augur> when i wrote foo !x !y = ... i was telling you how ! worked
14:42:16 <augur> when i wrote Scope !fn ... ... i was telling you what i would like to write in place of the actual thing
14:42:39 <ion> …
14:42:43 <jmcarthur> so lost
14:42:59 <augur> jmcarthur: look
14:43:04 <augur> if i have some big bunch of code
14:43:16 <monochrom> I don't think we should grill augur on precision. augur is just introducing. for the precise definition, you should be reading Idris specifications
14:43:38 <augur> do blah ; some (junk (that (uses (Scope !fn ... ...))))) ; blah
14:43:40 <jmcarthur> i'm actually just really confused, not trying to be pedantic at all
14:43:50 <ion> jmcarthur: ditto
14:43:53 <augur> jmcarthur: do you see what i mean now?
14:44:14 <monochrom> my contention, however, is on how often these gimmicks manifest that programmers conflate abbreviations with abstractions.
14:44:20 <jmcarthur> augur: so what happens if, say, junk has type   blah -> Maybe a  ?
14:44:24 <jmcarthur> augur: Maybe is a monad, too
14:44:34 <augur> jmcarthur: doesnt matter
14:44:37 <augur> its a syntactic transformation
14:44:41 <augur> as i said:
14:44:54 <augur> k[!m]   desugars to   do x <- m ; k[x]
14:45:18 <augur> here k[!fn] = some (junk (that (uses (Scope !fn ... ...)))) ; blah
14:45:19 <jmcarthur> i'll just read about it
14:45:21 <augur> so this desugars to
14:45:37 <augur> do blah ; fn' <- fn ; some (junk (that (uses (Scope fn' ... ...)))) ; blah
14:45:42 <jmcarthur> so far it sounds like "do what i mean"
14:45:49 <augur> jmcarthur: its not
14:46:01 <augur> its really just CPS transform indicators
14:46:17 <augur> something like shift/reset (= delimited continuations) for monads
14:46:49 <jmcarthur> augur: why would it not be    do blah; some (junk (do fn' <- fn; that (uses (Scope fn' ... ...)))); blah   ?
14:47:02 <augur> jmcarthur: well, junk isnt a binder now is it?
14:47:02 <ion> “k[!m]   desugars to   do x <- m ; k[x]” – k[!m] does not need “do”?
14:47:04 <jmcarthur> again, i'm willing to just look it up
14:47:10 <monochrom> well, there are two conflations. abbreviations with abstractions. handwaving reasoning with abstract reasoning.
14:47:14 <augur> ion: im being cautious there.
14:47:25 <augur> jmcarthur: as i said, it pulls out to the nearest binder in Idris
14:47:46 <ion> full of women
14:47:57 <augur> ion: lol
14:48:04 <augur> ok admiral ackbar
14:48:13 <monochrom> distinction: if you write down and use formal (symbolic) axioms, then you have abstractions and abstract reasoning. if you can't, then you only have abbreviations and handwaving reasoning.
14:48:34 <augur> monochrom: thanks for that
14:49:09 <FOOD_> are we designing coffee haskell or what
14:49:23 <ion> ffee haskell
14:49:43 <jmcarthur> "In practice, a subexpression !expr will lift expr as high as possible within its current scope, bind it to a fresh name x, and replace !expr with x. Expressions are lifted depth first, left to right."
14:50:02 <jmcarthur> the most precise answer i've found in the idris tutorial, at least
14:52:11 <jmcarthur> so... it sounds like the amount of lifting depends on where the variables used in the expression are bound?
14:53:48 <augur> jmcarthur: like i said, it lifts out to the nearest binder
14:54:43 <jmcarthur> hmm
14:54:53 <jmcarthur> i believe i understand now
15:28:53 <ezrios> reading through a paper on Elm and we have the following: lift2 :: (a -> b -> c) -> Signal a -> Signal b -> Signal c
15:29:04 <ezrios> lift3 f s1 s2 s3 = lift2 ($) (lift2 f s1 s2) s3
15:29:17 <ezrios> doesn't this require that (lift2 f s1 s2) :: Signal (a -> b)?
15:30:21 <ezrios> where ($) is identical to function application (as in Haskell)
15:31:17 <triliyn> ezrios: I think it does, but that's not a problem; it just means c ~ a1 -> b1
15:31:32 <triliyn> (Where c is from the original lift2 type signature)
15:31:35 <shachaf> ezrios: Yep, that's how it works.
15:31:52 <shachaf> In Haskell lift2 ($) is called (<*>) and is used exactly like this.
15:31:55 <shachaf> :t (<*>)
15:31:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:31:57 <ezrios> shachaf: hm, okay
15:32:03 <ezrios> this just didn't jive with my intuition
15:32:33 <ezrios> I am familiar with applicatives, I just found it a bit strange that when lifting a function over three signals the second had to be an applicative signal
15:33:06 <ezrios> or an applicative functor rather
15:33:14 <orion> Hi. How come this code doesn't do what I expect?: http://ideone.com/SbNQ4P
15:33:36 <ezrios> ah wait, nevermind
15:33:39 <ezrios> I think I understand now
15:34:12 <petrie> If I have a function "myFunc x b = ..." and I only need to set x when I first call it from another function do I have to specify something for b to like "_"
15:34:46 <ezrios> and what I said above doesn't make sense
15:34:46 <geekosaur> orion: buffering, most likely, you need to turn off buffering or use `hFlush stdout` before `getLine`
15:35:21 <orion> How do I turn off buffering?
15:35:43 <evancz> Has anyone recently had issues installing the tls package?
15:35:52 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/System-IO.html#v:hSetBuffering
15:36:06 <evancz> I am trying to install tls-1.2.3 and there seems to be a type error
15:36:19 <geekosaur> mrrr, why does it link to that one and not base
15:36:27 <evancz> I assume this means their dependencies were loose and someone changed a type?
15:36:59 <bennofs> evancz: I think tls is one of the packages that doesn't use version bounds
15:41:06 <thetourist> Hi, working through typeclassopedia and was wondering what people thought the best way is to deal with prelude orverrides/conflicts say when implementing Functor for ((,) e) - not looking for the implementation itself - just how do I deal with the fact that prelude already provides it? NoImplicitPrelude?
15:41:40 <shachaf> No great way to do it. Define your own tuple type or your own Functor class.
15:42:41 <thetourist> was afraid there wouldn't be. many thanks
15:43:18 <bennofs> :t join bimap :: (a -> b) -> (a,a) -> (b,b)
15:43:19 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:47:46 <pranz> :t bimap
15:47:47 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
15:52:13 <orion> foo (x:xs) = bar x : foo xs -- what does the `:' do here?
15:52:56 <bennofs> orion: (:) :: a -> [a] -> [a], it prepends the element `bar x` onto the list `foo xs`
15:53:37 <orion> Thank you
15:59:57 <simon> orion, didn't you ask this yesterday?
16:00:35 <ezrios> orion: hoogle is a useful resource
16:00:39 <ezrios> @hoogle (:)
16:00:41 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
16:00:41 <lambdabot> Test.QuickCheck.Function data (:->) a c
16:00:41 <lambdabot> keyword ::
16:00:50 <ezrios> well
16:00:53 <simon> ezrios, heh :)
16:03:54 <monochrom> if you consider notations like [a,b,c] to be fundamental, then I can explain ":" by: a:[b,c] = [a,b,c]
16:03:59 <haasn> evancz: Might also be an incompatibility with GHC 7.8, if you've upgraded to that
16:05:18 <monochrom> however, this explanation is backwards. in reality, [a,b,c] is syntax sugar, ":" is fundamental. [a,b,c] desugared step by step is: [a,b,c] = a:[b,c] = a:(b:[c]) = a:(b:(c:[])).
16:05:41 <monochrom> the parentheses are redundant and deliberately added for disambiguity.
16:05:54 <Tstrike> howdy all
16:05:59 <Tstrike> how is everyone?
16:06:06 <Tstrike> ^-^
16:06:20 <monochrom> hungry. are you food?
16:06:35 * Tstrike shakes head... "No food here"
16:07:25 <orion> simon: I probably did ask yesterday.
16:07:26 <monochrom> you look edible and nutritious
16:08:09 <Tstrike> I have a question for you guys... trying to compile Mesa.. I have two versions of autoconf on Centos 5.10 ... I did change AUTOM4TE variable... now autogen.sh is just crapping out junk
16:08:10 <orion> simon: I am still decalcifying my Haskell gland.
16:08:37 * Tstrike throws mono a cookie
16:09:00 <haasn> Tstrike: what does this have to do with Haskell?
16:09:04 <bitemyapp> monochrom: down, bad mono. down.
16:09:23 <bitemyapp> Tstrike: you're in #haskell by the way.
16:09:32 <Tstrike> OOOOOPS wrong channel guys
16:09:38 <tobiasgw> this was really uplifting to read when struggling to understand monads: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
16:09:39 * Tstrike puts on dunce hat
16:10:09 <joelteon> Anybody know if it's possible to ignore HLint parse errors using annotations?
16:10:15 <monochrom> tobiasgw, I have the best and also shortest monad tutorial ever: http://www.vex.net/~trebla/haskell/Monad.xhtml
16:10:22 <Tstrike> laters and thanks for the heads up
16:10:37 * Tstrike throws mono a basket of biscuits
16:11:09 <simon> orion, no problem :) just curious.
16:11:23 <tobiasgw> monochrom: I'll give it a read ;)
16:13:02 <orion> TIL Monads are Burritos.
16:16:15 <simon> TIL?
16:18:19 <tobiasgw> today I learned?
16:19:43 <BeardedCoder> today I learned. I believe it came from Reddit, or is at least used frequently there for all sorts of fascinating finds like. "President John Adams had a dog named Satan"
16:23:27 <ion> @quote burrito
16:23:28 <lambdabot> kmc says: une monade est comme une crêpe. una mónada es como un burrito. eine Monade ist wie ein Strudel
16:23:36 <ion> @quote burrito
16:23:37 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
16:24:08 <BeardedCoder> What's a burrito with an onion in it?
16:24:18 <haasn> klasse Strudel mit
16:24:43 <orion> When you construct a data type, does Haskell remember which constructor you used?
16:25:27 <dmj`> orion: what do you mean by construct a datatype, define one or use one?
16:26:43 <orion> data Shape = Ellipse Float Float | Square Float | Polygon [(Float, Float)]
16:27:38 <orion> If I construct a Shape using Polygon, will the result be known as a Polygon kind-of Shape/;
16:28:17 <dmj`> orion: yes, since the arguments are different the only valid way to construct a polygon would be with a key value list, but yes, its type is still Shape
16:28:19 <ion> You can deconstruct it using pattern matching. e.g. case shape of Ellipse x y -> …; Square x -> …; Polygon xs -> …
16:29:06 <orion> Oh wow, so if I have a "Shape", I can break it down and find out specifically how it was constructed.
16:29:10 <dmj`> let shape = Polygon [(1,1)] in case shape of { Ellipse x y -> ...; Square z ->; etc.. }
16:29:11 <ReinH> orion: also you should use Double
16:29:14 <ReinH> orion: http://www.haskell.org/haskellwiki/Performance/Floating_point
16:29:30 <orion> ReinH: It was just an example to explain my question.
16:30:57 <orion> So if I can figure out how any given Shape was constructed, when would I want to use class/implements?
16:31:09 <orion> Certainly I could make "Shape" a class.
16:31:46 <ReinH> orion: what would making it a class give you?
16:32:14 <haasn> orion: You use a class for when you want to abstract over different *types*
16:32:20 <orion> ah
16:32:21 <haasn> orion: For example, Num
16:32:25 <haasn> :t (+)
16:32:26 <lambdabot> Num a => a -> a -> a
16:32:39 * hackagebot elm-get 0.1.1.1 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.1.1 (EvanCzaplicki)
16:32:44 <orion> :t Num
16:32:46 <lambdabot>     Not in scope: data constructor ‘Num’
16:32:46 <lambdabot>     Perhaps you meant ‘Sum’ (imported from Data.Monoid)
16:32:50 <haasn> I can use (+) to add any ‘a’ that is an instance of Num, be it Integer, Float, Rational, Complex Double or whatever
16:32:58 <orion> I see.
16:33:10 <orion> That makes sense.
16:33:11 <ReinH> haasn: (or (-> a))
16:33:18 <haasn> ReinH: (a -> b) you mean
16:33:31 <ReinH> Num b => Num (a->b)
16:34:00 * haasn .oO( Num b :=> Num (a -> b) )
16:34:15 <ReinH> :=> ?
16:34:47 <haasn> ReinH: http://hackage.haskell.org/package/constraints-0.3.5/docs/Data-Constraint.html#t::-61--62- :)
16:35:43 <ReinH> haasn: I don't get it
16:36:01 <haasn> oh, it's just the relationship made explicit
16:36:04 <haasn> in-Haskell
16:36:19 <SrPx> Hmm it would be really cool if we had a vim plugin that continuously tried compiling the current file, and highlighted missing arguments and type mismatches as errors in realtime, just like chrome highlights spelling errors. Just saying (:
16:37:40 * hackagebot playlists 0.2.0.0 - Library and executable for working with playlist files.  http://hackage.haskell.org/package/playlists-0.2.0.0 (PeterJones)
16:38:35 <dmj`> SrPx: you can ruby watch to monitor file events and re-run tests / recompile on file save.
16:38:38 <dmj`> use*
16:38:40 <ReinH> SrPx: well, Syntastic will do it on saves
16:38:56 <ReinH> using ghc-mod or hdevtools
16:38:59 <ReinH> it will also run hlint
16:42:51 <MitchellSalad> if only the hdevtools maintainer would accept the months old patches for cabal and ghc 7.8 support and push a new version to hackage
16:44:30 <SrPx> ReinH: dmj` trying, ty!
16:45:29 <dmj`> SrPx: haskell-mode has a nice C-c C-l "send-to-repl" thing that does that
16:45:46 <dmj`> recompiling all the time might get annoying
16:46:07 <SrPx> haskell-mode, hdevtools and hgc-mod are 3 things right
16:46:41 <MitchellSalad> hdevtools is ghc-mod but with a client/server architecture, much faster
16:47:41 * hackagebot cookbook 2.3.4.2 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.4.2 (NatePisarski)
16:47:56 <monochrom> very old haskell-mode had a command for :reload, but it was removed a long time ago, I don't know why.
16:50:14 <SwashBuckla> hi there, I am having trouble writing a pandoc filter. I am not sure why this is failing to run the filter: http://lpaste.net/102897
16:51:55 <SwashBuckla> it's very hacky in this current state (well, it doesn't actually work) but I'm essentially searching for codeblocks with "include" in the namevals Attr, and replacing it with a list of Inline
16:54:31 <SwashBuckla> perhaps I'm not allowed to inject [Inline] there
16:54:33 <ReinH> MitchellSalad: wah wah
16:55:37 <MitchellSalad> ReinH: are you mocking me or crying with me in unison?
16:55:50 <petrie> Is there a good writeup on working with lists?
16:55:59 <ezrios> petrie: in what sense
16:56:22 <petrie> Idk, I am having the hardest time manipulating lists and I have read lyah lists part a million times.
16:56:31 <ezrios> petrie: do a bunch of exercises
16:56:37 <ezrios> like h99 or 1haskelladay or hackerrank
16:57:12 <petrie> Oh cool, didn't even know about that. Thanks.
16:57:45 <ezrios> petrie: there are a bunch of sorting algorithms on hackerrank that may suit your needs
16:58:04 <ezrios> though if you are not familiar with monads their output requirements may impede your progress
16:58:21 <petrie> Ill have a look. Like right now I am trying to see if a string contains anything other than [' '..'~']
16:58:23 <petrie> I am not
16:58:28 <petrie> :|
16:59:33 <ezrios> @hoogle any
16:59:35 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
16:59:35 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
16:59:35 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
17:00:00 <ezrios> Note you probably want a function of type String -> Bool
17:00:03 <ezrios> where String is just [Char]
17:00:32 <petrie> Ah ok
17:10:59 <ReinH> MitchellSalad: the latter
17:11:28 <sm> is it best practice to do package-specific imports like import "PKG" Control.Monad.* everywhere to keep your code buildable in case someone has both mtl and monads-tf installed ?
17:12:46 <ReinH> > any (\c -> c < ' ' || c > '~') "~~~~"
17:12:47 <lambdabot>  False
17:13:16 <glguy> sm: Your .cabal file will handle that
17:13:32 <ReinH> sm: if someone has both mtl and monads-tf installed without sandboxing they deserve what they get
17:13:49 <sm> I guess I'm hitting this only when I build with make
17:14:12 <itsmonktastic> probably a bit harsh to say they deserve it. :P
17:14:15 <sm> I assume it's easy for someone installing more than one package to get both libs installed, but if they build only with cabal it'll just work
17:15:18 <ezrios> > any (`elem` [' '..'~']) "\n"
17:15:20 <lambdabot>  False
17:15:35 <sm> yes, ok I can ignore it then
17:16:01 <ReinH> ezrios: you want the opposite, but `elem` has to traverse the whole list every time
17:16:13 <ReinH> rather than two checks on the bounds
17:16:21 <ezrios> ah true
17:18:57 <ReinH> itsmonktastic: monads-tf needs to find a nice fire to go die in.
17:19:20 <ReinH> it's the betamax of monad transformer implementations
17:20:33 <itsmonktastic> maybe, but it'd be nice if people couldn't get themselves into such situations
17:20:45 <ReinH> It's true.
17:21:19 <ReinH> It's a shame that installing both can basically break people's haskell
17:27:20 <haasn> ghc-pkg hide monads-tf # should cover it imo
17:33:49 <sm> it does
17:40:56 <orion> When do I put a type context in an instance declaration?
17:41:55 <hpc> instance Applicative f => Monad f
17:42:00 <hpc> (on the left)
17:43:36 <orion> ok
17:44:03 <orion> Just 'h' :: Maybe Char     Just 8 :: Num a => Maybe a -- why is context needed in the latter and not the former?
17:48:00 <ezrios> orion: 8 can be any Num
17:48:04 <ezrios> Double, Float, Int, etc
17:48:21 <orion> hm ok
17:48:40 <orion> 8 is a polymorphic type then?
17:48:45 <orion> er
17:48:52 <orion> 8 is a value of a polymorphic type then?
17:48:53 <jakex> polymorphic literal
17:49:09 <orion> "literal" -- got it
17:49:35 <haasn> Is it “polymorphic type” or “polymorphic value”?
17:51:07 <jmcarthur> the literal 8 is roughly desugared as   fromInteger (8 :: Integer)
17:51:22 <haasn> if by roughly you mean exactly?
17:51:44 <jmcarthur> haasn: well, if it was exactly then it would desugar recursively infinitely or somesuch
17:51:55 <jmcarthur> haasn: since i didn't distinguish between source and target language
17:52:58 <maxx_> is there a function like this in standard lib? (\x -> -(abs x))
17:53:11 * haasn .oO( sign .~ (-1) )
17:53:15 <haasn> Wait, that's illegal
17:53:37 <orion> Say I have a function f a b = a + b. If my code repeatedly executes f 2 2, does a+b get executed every time, or (since there are no side effects) is the value stored in memory and NOT recomputed later?
17:53:43 <haasn> maxx_: negate . abs -- short enough
17:54:05 <maxx_> cool
17:54:30 <haasn> orion: there's a point of distinction that could be made between “execution” and “evaluation” in Haskell. Assuming you meant the latter: It depends on the implementation
17:54:38 <orion> GHC
17:54:49 <haasn> orion: It is a valid implementation strategy to store and re-use it, since as you correctly mentioned there are no side effects during evaluation
17:55:15 <haasn> GHC, as a rule of thumb, will not automatically memoize functions. It comes with more performance drawbacks than gains
17:55:22 <orion> I see.
17:55:39 <haasn> eg. because checking for a = 2, b = 2 and if so, finding the result value and returning that instead is much more complicated than just recomputing 2+2
17:55:52 <haasn> And cache unfriendly etc.
17:56:17 <orion> If a computation takes a long time to make and the result is used everywhere, is there a way I can signal to GHC that it might be beneficial to cache the result?
17:56:44 <haasn> orion: There are libraries in place to manually memoize functions, if you're positive (or can prove via benchmarks) that it's better for performance
17:56:52 <orion> ok
17:56:54 <haasn> orion: But if you just want sharing of results, GHC will share stuff bound to a (monomorphic) name
17:56:56 <haasn> so for example
17:57:08 <haasn> let x = ..complicatedexpression.. in x + x -- x will not be recomputed
17:57:57 <orion> ah ok
17:58:39 <haasn> or let f x y z = ... g x w ...; g x = ... x ... in f complicated y' z' -- the ’complicated’ expression gets shared in the bodies of f, g, and everything else the bound name is passed to
17:59:00 <haasn> So if you need to share some big result, you can pass it to all of the subfunctions instead of reiterating the expression
17:59:06 <haasn> s/big/complicated/
17:59:26 <orion> right
17:59:29 <orion> cool
17:59:30 <Hafydd> Is there a way to make GHC look for files named, for example, "A.B.C.hs" when loading the module "A.B.C", rather than "A/B/C.hs"?
18:03:51 <augur> anyone know of a nice solution (perhaps involving depending types or other fancy techniques) to take a function   f :: A -> B -> ... -> M   (where M is a monoid)
18:04:01 <augur> and to generalize it to   f' :: [A] -> B -> ... -> M
18:04:09 <augur> and f'' :: A -> [B] -> ... -> M
18:04:23 <augur> and f''' :: [A] -> [B] -> ... -> M  and so forth?
18:10:51 <BMeph_> augur: Are you familiar with mConcat? :)
18:11:01 <augur> BMeph_: yes
18:11:22 <augur> BMeph_: i suppose a bunch of <*>'s and pures would work
18:11:30 <augur> followed by mconcat
18:11:51 <edwardk> thoughts on http://lpaste.net/102898 ?
18:12:20 <BMeph_> edwardk: "Nuke it from orbit"? ;þ
18:12:56 <augur> edwardk: whats free unification?
18:12:57 <edwardk> finally realized i could do the unification kernel from my unfinished unification package and wren's unification-fd cleaner and with ghc.generics
18:13:14 <edwardk> augur: the monad used in unification-fd turns out to be a free monad
18:13:39 <edwardk> so with some tweaking we can do most of that package with a that typeclass and a couple of combinators
18:13:57 <edwardk> and with the GUnified class you can derive it for free for any syntax tree
18:14:15 <Hafydd> ...I suppose I should just omit the dots from my module names, if I want to do that.
18:14:43 <augur> edwardk: ill take your word for it
18:16:53 <augur> BMeph_: hm. i think i have a solution to my general problem them. :)
18:16:56 <maxx_> is there unwords equivalent that takes a chat separator?
18:17:02 <maxx_> char
18:17:30 <edwardk> my unified plays the role of wren's 'zipMatch'
18:18:34 <augur> BMeph_: which was, given an n-ary predicate, how to generalize it to work over list-y arguments, in arbitrary positions. reason being, verbs can have singular or plural arguments, so a verb like "copy" might have a predicate meaning with 3 slots, so you need 2^3 = 8 different versions
18:18:43 <jakex> > intercalate ";" (map show [1..10])
18:18:45 <lambdabot>  "1;2;3;4;5;6;7;8;9;10"
18:19:11 <maxx_> thanks
18:19:33 <augur> BMeph_: but: if you have one core meaning copy :: E -> E -> E -> Bool, and then every arg is required to be [E] (either by being plural, or by being singular and being lifted) then you can just generically apply the lifted version of copy!
18:19:49 <tristan__> I'm getting forbidden when trying to upload a package to hackage, can I not upload a new package with just any user?
18:21:00 <orion> I saw somewhere in a do block: let (Just blah) = expr -- what is this doing?
18:21:12 <hiptobecubic> orion, pattern matching
18:21:20 <byorgey> tristan__: is this a brand new package, or a new version of an existing package?
18:21:21 <hiptobecubic> orion, if the pattern match fails, it uses MonadError
18:21:27 <tristan__> byorgey: brand new
18:21:45 <hiptobecubic> orion, which is usually something sensible, like when using guard
18:22:09 <orion> Is the expression evaluated?
18:22:23 <orion> (At that point in the do block)
18:22:37 <byorgey> tristan__: hmm, that is supposed to be OK as far as I know.  Maybe ask in #hackage
18:22:54 <tristan__> ah, another channel :), thanks
18:24:08 <orion> What happens if I leave off the 'Just' and merely have it be: let blah = expr?
18:24:36 <hiptobecubic> orion, the type of blah will be different and it will probably not compile
18:25:00 <hiptobecubic> orion, the expression is evaluated to (Just <thunk>) because that's all that's needed there
18:25:18 <hiptobecubic> orion, if blah is never used later, blah will never be evaluated
18:25:49 <BMeph_> augur: I'm glad I could prompt some meaningful thought on the subject! :)
18:25:57 <augur> BMeph_: :)
18:26:43 <orion> hiptobecubic: So blah is of type Maybe?
18:26:52 <hiptobecubic> No
18:27:10 <hiptobecubic> (Just blah) is of type Maybe a, where a is the type of blah
18:27:41 <hiptobecubic> so if we have  blah = 3 :: Integer
18:27:50 <hiptobecubic> then Just blah :: Maybe Integer
18:27:59 <orion> ok
18:28:30 <hiptobecubic> if blah is of type (Integer, Integer), then Just blah is Maybe (Integer, Integer), etc
18:28:46 <hiptobecubic> except like i said, blah will not be evaluated in that expression
18:29:00 <hiptobecubic> so the value stays as a thunk
18:29:19 <orion> You said pattern matching was going on. What am I matching against?
18:30:00 <hiptobecubic> let (Just blah) = expr
18:30:12 <hiptobecubic> expr is type (Maybe BlahType)
18:30:31 <hiptobecubic> if the *value* of expr is not (Just blah) then it will fail
18:30:44 <hiptobecubic> the other possible value of expr is Nothing
18:30:54 <hiptobecubic> and let (Just blah) = Nothing clearly fails
18:33:42 <SrPx> So, if order doesn't matter, over foldl', foldl and foldr, the fastest and better option is foldr, right?
18:33:45 <orion> What is the type of the whole line, "let (Just blah) = expr"
18:33:50 <jakex> > let (Just x) = Just x in x
18:33:54 <lambdabot>  mueval-core: Time limit exceeded
18:34:14 <jakex> uhm
18:34:19 <jakex> > let Just x = Just 10 in x
18:34:21 <lambdabot>  10
18:34:57 <jakex> it "extracts" a value from a Maybe
18:35:14 <orion> :t Just x
18:35:16 <lambdabot> Maybe Expr
18:35:49 <orion> This line of code had no "in"
18:35:50 <jakex> @src Maybe
18:35:50 <lambdabot> data Maybe a = Nothing | Just a
18:36:01 <magicman> SrPx: If order doesn't matter, either foldl' or foldr. Use foldr when the function you fold is lazy in its second argument. foldl' if the function is strict in its second argument. At least, that's what I go by.
18:36:07 <jakex> in is optional in do notation
18:36:23 <maxx_> is there a read version that ignores case?
18:36:29 <hiptobecubic> orion, well "let Just x = Just 10" is not really useful, you don't use any of the vaulues
18:36:51 <orion> So does that mean that every single line following a let expression in a do block is "in" the let?
18:36:55 <hiptobecubic> orion, the "x" from "in x" is the actual value of the expression
18:36:56 <orion> hiptobecubic: I see.
18:37:05 <hiptobecubic> > let Just x = Just 10
18:37:07 <lambdabot>  not an expression: ‘let Just x = Just 10’
18:37:08 <haasn> orion: yes, look at the desugaring rules for do blocks
18:37:12 <SrPx> magicman: okay, thanks!
18:37:33 <haasn> orion: do let <decl> = <expr>; ...  desugars to let <decl> = <expr> in do ...
18:37:40 <haasn> (It's recursive)
18:38:02 <haasn> Since a block cannot possibly end with “let <decl> = <expr>” as the last line, it does not have to evaluate to any final expression itself
18:38:04 <haasn> and hence
18:38:09 <haasn> must not have a type of its own*
18:38:20 <hiptobecubic> not to mention it doesn't really "mean" anything
18:38:23 <haasn> There is no valid way to answer “what is the type of the whole line”
18:38:30 <orion> I see.
18:38:35 <hiptobecubic> "let Just x = Just 10"... ok done. So what?
18:38:37 <haasn> Because it needs an expression after it (or more) to be valid
18:40:02 <maxx_> > let (x:xs) = [1..5] in (x, xs)
18:40:04 <lambdabot>  (1,[2,3,4,5])
18:40:25 <maxx_> ^^ pattern matching you may be familiar with
18:40:40 <orion> So if the value of expr is not (Just blah), will the program terminate?
18:40:59 <ezrios> orion: if you fail to account for the case where expr is Nothing
18:41:02 <ezrios> you will die at runtime
18:41:41 <maxx_> it can only be Nothing or (Just x). otherwise it wont compile
18:42:34 <ezrios> > let f (Just x) = x :: Maybe Int -> Int
18:42:36 <lambdabot>  not an expression: ‘let f (Just x) = x :: Maybe Int -> Int’
18:42:39 <ezrios> @let f (Just x) = x :: Maybe Int -> Int
18:42:42 <lambdabot>  Defined.
18:42:46 <ezrios> > f Nothing
18:42:47 <lambdabot>  Ambiguous occurrence ‘f’
18:42:47 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:158:1
18:42:47 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
18:42:47 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:109:1-26
18:42:47 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.1:De...
18:42:53 <jakex> this is a useful flag for ghc/i by the way, to warn you about incomplete patterns: -fwarn-incomplete-patterns
18:43:00 <ezrios> ._.
18:43:11 <ezrios> @let incompleteF (Just x) = x :: Maybe Int -> Int
18:43:14 <lambdabot>  Defined.
18:43:16 <ezrios> > incompleteF Nothing
18:43:19 <lambdabot>  <Maybe Int -> Int>
18:43:39 <ezrios> well, in ghci I get an Exception
18:44:16 <haasn> orion: the technical answer is that “let .. in” bindings are irrefutable pattern matches; what this means is that the match will always work until you try to access any identifiers bound by the pattern, in that case an exception will be thrown if the pattern match failed
18:44:23 <haasn> orion: compare the following:
18:44:41 <haasn> > let Just x = Nothing in ()
18:44:43 <lambdabot>  ()
18:44:49 <haasn> > case Nothing of Just x -> ()
18:44:50 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
18:44:52 <haasn> > case Nothing of ~(Just x) -> ()
18:44:54 <lambdabot>  ()
18:45:12 <haasn> ~pat is syntax for ‘pat, but irrefutable’
18:45:20 <orion> Whenever I see "Just x" I feel like I am evaluating a constructor.
18:45:21 <haasn> > case Nothing of ~(Just x) -> x
18:45:23 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
18:45:28 <haasn> > let Just x = Nothing in x
18:45:29 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
18:46:08 <maxx_> orion: are you familiar with this syntax? foo (x:xs) = ... ?
18:46:21 <orion> For a function definition? Yes.
18:46:36 <orion> Pattern matching. The "Just" is throwing me off.
18:46:47 <maxx_> foo (Just x) = ... works just the same.
18:46:55 <orion> to me it feels like I am evaluating a constructor
18:47:00 <maxx_> and you can use same syntax in let
18:47:09 <ezrios> orion: you are deconstructing whatever values are provided to your function
18:47:47 <ezrios> "if we receive a value that has the structure (Just x) then do this"
18:47:50 * hackagebot ffmpeg-light 0.1.0.0 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.1.0.0 (AnthonyCowley)
18:47:53 <orion> So by their very nature, if you name a constructor in a pattern, you are actually deconstructing>
18:48:11 <maxx_> yes
18:48:27 <ezrios> you are trying to match that structure to whatever argument you receive
18:48:32 <ezrios> and when you find a match you evaluate the RHS
18:48:44 <maxx_> it works with all constructors, including your own
18:49:55 <haasn> orion: there are really two forms of declarations that can go here;  let <var> <pat1> <pat2> ... <patn> = <expr> introduces a new *function* named <var> that performs pattern matching on its parameters 1 .. n
18:50:21 <haasn> orion: and let <pat> = <expr> just directly pattern matches <expr> against <pat>, introducing new value bindings for everything bound by <pat>
18:50:48 <orion> hmm
18:51:05 <orion> So, the parentheses are 100% required.
18:51:35 <byorgey> for patterns which are more than just a single constructor or variable, yes.
18:52:16 <orion> ok
18:52:24 <orion> This is starting to come together in my head.
18:52:29 <haasn> orion: that's the magic about constructors in Haskell - they work both ways, constructing and *destructing*
18:52:37 <haasn> Which is what separates them from plain old functions
18:52:51 * hackagebot ffmpeg-light 0.1.0.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.1.0.1 (AnthonyCowley)
18:52:59 <orion> haasn: Yeah, the whole concept of deconstruction is new to me.
18:53:06 <haasn> So (C x) is not always a *construction*, in a pattern it's destruction (aka pattern matching)
18:53:10 <orion> Can deconstruction happen in places other than pattern matching?
18:53:17 <haasn> No
18:53:43 <orion> ok
18:54:09 <haasn> Haskell's core operating principles are really based on four key operations, which come in pairs:  function application and function abstraction,  pattern matching and value construction
18:54:22 <haasn> Function application and function abstraction are relatively well-known
18:54:35 <haasn> But pattern matching and value construction is what most people have to learn when getting into Haskell :)
18:54:48 <orion> Indeed -- thank you for taking the time to explain it to me.
18:55:42 <orion> So
18:56:15 <orion> let (Just x) = f blah
18:56:29 <orion> I could do: x <- f blah
18:56:44 <orion> But in that case, I am allowing x to *also* be Nothing.
18:56:49 <orion> Is that right?
18:57:03 <dario> yep
18:57:42 <dario> "allowing" as in "if it's Nothing, there will be a pattern-match-error at runtime"
18:58:02 <orion> right
18:58:46 <haasn> orion: well first of all it depends on what monad your ‘do’ block gets instantiate at
18:58:58 <haasn> Do you mean if you are in a Maybe-monad do block?
18:59:42 <haasn> If so, then yes; the difference is that in the former case accessing ‘x’ when f blah is Nothing will crash your program; whereas in the second case it will simply follow the rules of (>>=) which is Nothing >>= _ = Nothing
18:59:51 <haasn> so your whole do block will evaluate to Nothing instead
19:00:18 <orion> oh man
19:00:30 <orion> How do I determine what kind of do block I am in?
19:01:21 <orion> main = do ... let (Just x) = f a -- I am assuming I am in an IO () do block.
19:02:21 <haasn> orion: yes, it depends on the context
19:02:23 <augur> orion: that wont work because the let needs a scope
19:02:25 <haasn> (or hte operations)
19:02:41 <haasn> orion: also, as discussed above, “let x = y” can't be the last line of a do block
19:02:52 <haasn> I guess that's what augur is pointing out
19:03:17 <augur> but you could in general just stick in any wonky object, like, say, "foo" as the last line of the block and it should choke and tell you a useful error
19:03:37 <augur> alternatively you could try using typed holes
19:03:58 <augur> that'll tell you the goal and the stuff in scope
19:04:08 <jakex> he just learned how to pattern match Maybe.. :)
19:04:13 <augur> oh haha
19:04:20 <augur> well then why is he using do blocks!
19:04:36 <orion> What kind of do block am I in when I do: if a == b then do ... else do ... ?
19:04:54 <augur> orion: unknown
19:05:09 <augur> there is no answer to that, since it depends
19:05:27 <augur> orion: itll be the same kind of monad on either branch tho
19:06:12 <orion> So, the last line of the 'then' or 'else' do blocks should evaluate to the type of the parent do block (main, IO ())?
19:07:19 <augur> orion: its just a boring if statement
19:07:42 <augur> orion: in this statement:   if a then b else c   b and c must be the same type, and the whole thing is also that type
19:07:58 <augur> if that type happens to be a computation type (a monadic type) then so be it
19:08:47 <orion> ok
19:10:32 <orion> So, if you're reading code and you see an if a then do <...> else do <...> then you know the *type* of the final lines in <...> must be equal?
19:11:07 <augur> orion: sure. but the type of the final lines of the do blocks is just the type of the do blocks
19:11:28 <augur> orion: i think probably you're jumping way far ahead tho
19:12:30 <orion> So I can state this emphatically: The type of a do block is always equal to the type of the value of the last statement of the block.
19:13:55 <augur> yes
19:14:27 <augur> orion: the rules for translating from do to bind guarantee that
19:18:16 <orion> So, a do-block is the computational description of a Monad.
19:18:50 <ezrios> orion: a do-block is syntactic sugar for (>>=) and (>>)
19:19:04 <ezrios> http://www.haskell.org/haskellwiki/Monads_as_computation#Do_notation
19:20:44 * orion reads
19:22:53 * hackagebot prelude-extras 0.3.1 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.3.1 (EdwardKmett)
19:24:11 <augur> orion: i think you're jumping way far ahead
19:24:16 <augur> you should read lyah or something
19:26:18 <orion> augur: I probably am jumping far ahead. But my brain is funny like that.
19:26:35 <augur> orion: try to go through lyah, itll be better
19:26:37 <augur> @where lyah
19:26:37 <lambdabot> http://www.learnyouahaskell.com/
19:27:43 <orion> The problem is not that I didn't ingest lyah, the problem is that I need an antacid for my heartburn.
19:27:54 * hackagebot foldl-incremental 0.1.1.0 - incremental folds  http://hackage.haskell.org/package/foldl-incremental-0.1.1.0 (tonyday)
19:38:19 <augur> orion: oh so you've read lyah already? ok
19:49:05 <jakex> > read "1000" :: Int8
19:49:07 <lambdabot>  -24
19:49:17 <orion> In a Monad, every statement's output *and* input is the state of the world, right?
19:49:24 <jakex> any way to get an error in there?
19:49:34 <jakex> perhaps some other read function
19:49:38 <augur> blurgh
19:49:52 <Jafet> > fromEnum 1000 :: Int8
19:49:54 <lambdabot>  Couldn't match expected type ‘GHC.Int.Int8’
19:49:54 <lambdabot>              with actual type ‘GHC.Types.Int’
19:49:58 <augur> i find myself on the brink of writing a full blown dependently typed programming language :(
19:49:59 <Jafet> > toEnum 1000 :: Int8
19:50:00 <lambdabot>  *Exception: Enum.toEnum{Int8}: tag (1000) is outside of bounds (-128,127)
19:50:24 <Jafet> Though the fact that read succeeds there is totally a bug
19:50:37 <jakex> yeah that was weird
19:50:56 <augur> well i have, actually, but i find myself almost writing a DTPL with generic inductive types and pattern matching and/or elims
19:51:06 <augur> im torn between doing elims or not tho
19:51:46 <augur> i prefer pattern matching, but elims do offer some interesting benefits. if i could figure out how to cleanly implement pattern matching via elims i'd be even happier
19:53:12 <augur> ive considered going the Epigram route but im not 100% sure how to do that, alas
20:06:46 <ezrios> orion: wrong
20:08:05 <ezrios> orion: maybe you should read LYAH
20:10:10 <carter> summoning bitemyapp  to opine on reading for learning
20:25:30 <george2> Is there a way to do this?
20:25:33 <george2> [ if x == 0 then x else (if this is the first nonzero found then 0 else x) | x <- [0,3,5] ] -- Should return [0,0,5]
20:25:35 <george2> I'm probably thinking about it the wrong way.
20:27:42 <Jafet> > (\xs -> case span (==0) xs of (x, y:ys) -> x ++ 0:ys) [0,2,4,6]
20:27:44 <lambdabot>  [0,0,4,6]
20:28:00 <george2> case span? I have never heard of either of those...
20:28:53 <heatsink> > (\xs -> case span (==0) xs of (x, y:ys) -> x ++ 0:ys) [2,0,4,6]
20:28:55 <lambdabot>  [0,0,4,6]
20:29:08 <george2> oh that's just a regular case
20:29:14 * george2 reading lyah
20:29:38 <heatsink> > (\xs -> case span (==0) xs of (x, y:ys) -> x ++ 0:ys) [2,4,6,0]
20:29:39 <lambdabot>  [0,4,6,0]
20:30:40 <george2> huh, these are nice.
20:30:54 <george2> thanks Jafet
20:37:39 <smiller2> http://hackage.haskell.org/package/OpenGLRaw: "All API entries are loaded dynamically, so no special C header files are needed for building this package." - What exactly does "loaded dynamically" mean?  How do I link a particular OpenGL implementation to an executable?
20:42:11 <Jafet> http://hackage.haskell.org/package/OpenGLRaw-1.4.0.0/src/cbits/HsOpenGLRaw.c hackety hack
20:46:43 <carter> smiller2: do you know how dynamic linking works?
20:46:59 <carter> basically at runtime you ask the system opengl whats supported
20:47:01 <carter> and you get pointers
20:47:07 <carter> to those features
20:47:15 <carter> that you can use as functions
20:47:17 <carter> ish
20:51:49 <maxx_> with
20:55:46 * SrPx sighs
20:56:44 <SrPx> Working with Haskell is like a massage to your soul...
20:56:55 <smiller2> carter: Aha, I'm not sure why I was confused.  The bottom of http://hackage.haskell.org/package/OpenGLRaw-1.4.0.0/OpenGLRaw.cabal links to -lGL on linux, opengl32 on Windows, and OpenGL on OS X.
20:57:01 <SrPx> I still hate every single one of you for not solving the JS problem...
20:57:26 <carter> SrPx: consider purescript
20:57:37 <carter> or ask luite when he's going to decide ghcjs is good enough :)
20:57:43 <carter> or boht!
20:57:59 <carter> i'm parsing js using haskell right now
20:58:06 <SrPx> carter: yes but you have to code in two different languages \:
20:58:17 <carter> purescript is pretty nice
20:58:27 <SrPx> that is my only issue, I really love typescript and the work on it
20:58:30 <carter> oh
20:58:34 <carter> no, look at purescript
20:58:34 <SrPx> purescript, my bad
20:58:39 <carter> they're not the same :)
20:58:54 <SrPx> yes that is what I mean, typescript is just JS with types :P
20:59:04 <carter> purescript is NICE
20:59:07 <carter> take a look
20:59:12 <carter> probably not perfect
20:59:32 <carter> but pretty neat subject to "strict, needs good js interop, and REAL types"
20:59:41 <SrPx> I have! I know about it, I love everything about it, honestly. But it is still a different language so I can't share code between client and server...
20:59:49 <carter> true
20:59:52 <carter> so hack on ghcjs :)
20:59:54 <carter> and help luite
20:59:58 <carter> :)
21:00:08 <ruzu> purescript vs elm, fight
21:00:15 <carter> nah
21:00:17 <carter> totally different
21:00:18 <SrPx> Uh huh, that is what I plan to do, unfortunately that is impossible to the current project I'm working on as it needs every single drop of performance ;'(
21:00:23 <carter> ah
21:00:24 <carter> well
21:00:27 <carter> hence purescript :)
21:00:33 <carter> afaik it compiles pretty directly
21:00:35 <carter> or just
21:00:39 <carter> use whatever youre using
21:00:41 <carter> and finish it
21:01:18 <Platz> theres still a good chunk of framework code purescript runs inside though
21:01:33 <Platz> it looked something like 30k
21:02:26 <SrPx> Just a question, if YOU guys were hired to create a 3D webgl non-toyish game, what would you guys do? Would you accept going out of the Haskell comfort and coding in WebGL/JavaScript, or would you find a way?
21:02:27 <Platz> although the the code that you write is translated quite compactly and sanely
21:03:57 <carter> have you seen jmacro?
21:04:12 <carter> it really depends on if its a one off project
21:04:16 <carter> or recurrent engineering
21:04:19 <cwvh> I wouldn't burn client hours trying to wrangle JS transpilers in Haskell.
21:04:23 <carter> yeah
21:04:40 <carter> unless its got so much boilerplate engineering that its a win
21:04:54 <carter> that said, for perf, just do very disciplined js
21:04:59 <haasn> SrPx: I would reject the job offer
21:05:07 <carter> haasn: aren't you still a student?
21:05:15 <haasn> I am!
21:05:20 <carter> haasn: don't say that
21:05:22 <carter> you're still a student
21:05:29 <SrPx> haasn: haha fair enough
21:05:43 <SrPx> carter: );
21:05:55 <SrPx> carter: recurrent engineering?
21:06:01 <carter> you're doing somthing more than once
21:06:06 <carter> and its error prone by hand
21:06:30 <carter> http://hackage.haskell.org/package/jmacro is a macro system in haskell for js code gen
21:06:51 <carter> with quasiquoters and stuff
21:07:01 <SrPx> I kinda don't get jmacro's point, won't this be much more verbose and difficult than just writing javascript?
21:07:21 <carter> you get typed macros you can splice
21:07:43 <carter>  http://hackage.haskell.org/package/jmacro-0.6.8/docs/src/Language-Javascript-JMacro-Prelude.html#jmPrelude
21:07:59 <carter> ghcjs uses a patched version of it to implement its RTS
21:08:36 <maxx_> :t replace
21:08:37 <lambdabot>     Not in scope: ‘replace’
21:08:37 <lambdabot>     Perhaps you meant ‘replay’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
21:08:46 <SrPx> I see
21:09:55 <maxx_> there is replace for Text. is there an equivalent for String? it replaces every occurence of one substring with another
21:11:30 <carter> SrPx: https://github.com/ghcjs/ghcjs/blob/master/src/Gen2/Rts.hs is probably the largest most complex Jmacro esq code on the planet
21:11:36 <carter> its a slightly patched jmacro
21:11:54 <carter> but the point being, its a sound / faithful implementation of all the ghc RTS semantics
21:12:47 <SrPx> What!?
21:12:57 <carter> yes
21:13:22 <carter> yes, luite  (with fryguybob's help) implemented a semantically faithful ghc RTS using jmacro
21:13:34 <carter> even stable names and finalizers and stuff
21:13:39 <carter> and all the thready bits
21:13:45 <carter> that are exposed in haskell
21:14:25 <SrPx> but... why
21:15:44 <pavonia> maxx_: One of the regex packages provides substring replacement, but you could also use some combination of intercalate and splitBy from package split
21:18:02 * hackagebot prelude-extras 0.4 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.4 (EdwardKmett)
21:19:13 <pavonia> maxx_: Ah, it's called splitOn
21:20:04 <pavonia> > let replace r s = intercalate s . splitOn r in replace "foo" "bar" "Where's the next foo?"
21:20:05 <lambdabot>  "Where's the next bar?"
21:20:14 <maxx_> I wil try thanks
21:24:17 <carter> SrPx: i thought you wanted interop!
21:24:34 <SrPx> yes
21:30:25 <ruzu> can haskell dynamically load libs (a la c loading a .so)?
21:36:47 <heatsink> Only on OS X, ruzu
21:37:53 <carter> heatsink: false
21:38:02 <carter> should work on linux and windows on 7.8
21:41:13 <george2> If I have an "IO [Int]", how do I get just the [Int] part?
21:41:29 <george2> I'm trying to use >>=, but it doesn't seem to be working the way I expext it to
21:41:39 <george2> expect
21:41:39 <carter> :t (>>=)
21:41:40 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:41:47 <kardboardb> george2: What's the code you're using?
21:42:37 <george2> blah xs = do { putStrLn "a"; return xs }
21:42:47 <pavonia> george2: You can't get rid of the IO, if that is your question
21:42:58 <george2> where blah :: [int] -> IO [Int]
21:43:11 <kardboardb> george2: That will still return a value in IO [Int].
21:43:17 <george2> right
21:43:27 <carter>  blah [1] >>= \x -> putStrLn (show x)
21:43:55 <kardboardb> You can access and use the [Int] value in a function inside the IO monad, but you can't get the [Int] out of the IO monad.
21:43:57 <george2> but then I want to pass the [Int] part of the return value to another function that takes an [Int]
21:44:07 <kardboardb> Oh, then replace your "return" with the function name.
21:44:40 <kardboardb> do { mySpecialFunction xs }; or even better: fmap mySpecialFunction xs
21:44:53 <kardboardb> :t fmap
21:44:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:44:58 <pavonia> These are different things
21:45:35 <heatsink> Huh, so it links dynamically on major platforms now
21:45:49 <carter> heatsink: what does
21:45:52 <carter> ghci does
21:45:53 <carter> well
21:45:54 <george2> ok, I'm just getting more confused now. let me paste some code.
21:45:55 <carter> except on windows
21:46:01 <kardboardb> Sorry, the first example should be: do { unpackedXS <- xsInsideIO; mySpecialFunction unpackedXS }
21:46:03 <carter> but that'll change in 7.8.3
21:47:59 <george2> My code, with expanation. http://paste.kde.org/p5affrnsj
21:48:18 <george2> hopefully that makes sense
21:49:06 <george2> oh, whoops, wrong version. but whatever, same idea. humanIO should just be deleted and the contents moved inside humanTurn
21:50:42 <heatsink> george2: Since turns can do IO, they need to be IO actions, with type Board -> IO Board
21:50:52 <george2> right, that's what I was thinking
21:51:02 <george2> but then how do I get winner to operate on an IO Board?
21:51:15 <heatsink> Run the action first to get the new board
21:51:25 <heatsink> Just like row <- getLine returns a String
21:51:37 <heatsink> new_board <- humanTurn board returns a Board
21:51:50 <george2> that doesn't seem very functional :/
21:52:13 <heatsink> IO actions aren't really functions
21:53:01 <george2> hrm, ok. I'll try.
21:53:14 <kardboardb> george2: Does this help any? http://lpaste.net/102901
21:54:21 <george2> hm, maybe
21:54:22 <george2> thanks
21:58:42 <george2> that's giving me     The last statement in a 'do' block must be an expression
21:59:19 <augur> edwardk: whats the name of the version of the LC with let bindings and evaluation rules like   let x = (let y = M in N) in P  ~>  let y = M in let x = N in P
21:59:58 <george2> kardboardb: http://lpaste.net/102903
22:00:49 <kardboardb> george2: The like with two "return"s should be broken up before the second return.
22:01:11 <kardboardb> The formatting's a bit messed up: two lines are smooshed together.
22:02:20 <george2> yeah I don't know why...
22:02:27 <george2> this is what I have http://lpaste.net/102904
22:03:10 <kardboardb> george2: There's one extra space on the line beginning with "return $".
22:03:37 <kardboardb> It's indented four spaces instead of three.
22:03:42 <george2> I just tried without that... why does one space do that? I didn't realize haskell cared about whitespace like that
22:04:15 <kardboardb> It puts it on a "lower" indentation level than the preceding statement - that is, it makes it think it's a continuation of the preceding statement.
22:04:58 <kardboardb> For a more thorough explanation - http://en.wikibooks.org/wiki/Haskell/Indentation
22:08:07 * hackagebot Finance-Quote-Yahoo 0.8.0 - Obtain quote data from finance.yahoo.com  http://hackage.haskell.org/package/Finance-Quote-Yahoo-0.8.0 (BradClawsie)
22:08:10 <Javran> can someone explain why "each monoid is a category"? If each element in that monoid is an object, what is the morphism? We only have `mappend` which is a binary function
22:08:41 <tikhon> Javran: it's not each element
22:08:52 <george2> now I'm getting some type problems :/ http://lpaste.net/102905
22:08:53 <tikhon> the category only has one element, the monoid itself
22:09:26 <tikhon> the elements are the arrows in the category
22:09:36 <tikhon> mappend is composition and mempty is the identity arrow
22:09:57 <tikhon> it's pretty trippy: the "arrows" are not function-like at all, generally
22:10:59 <pavonia> george2: What is the expected type of humanTurn?
22:11:20 <george2> well I would think it would be Board -> IO Board
22:11:37 <kardboardb> It seems to be IO Board -> IO Board.
22:12:00 <kardboardb> Can you try specifying an explicit type signature for humanTurn, and see what comes up?
22:12:17 <george2> I tried with and without explicit, same error
22:12:18 <Javran> tikhon: so what about "each poset is a category", it seems make sense to me to interpret elements as objects and "greater-or-equal" as morphism, does this work?
22:12:31 <tikhon> yep
22:12:37 <pavonia> Giving type signatures to all top-level functions is a good idea in general :)
22:13:02 <kardboardb> As for the second error, take away the "return $"; I forgot that the code inside your case is already in IO.
22:13:24 <kardboardb> And then re-indent the case to match, after you drop that line.
22:13:57 <george2> Vim really doesn't like this indentation
22:14:31 <kardboardb> Not sure what could be causing the first error, other than the type signature for humanTurn ending up as :: IO Board -> IO Board... could you post the new source of that function?
22:15:18 <george2> so now I have http://lpaste.net/102906, which gives http://lpaste.net/102907
22:16:12 <kardboardb> Line 18 should be "return board"
22:16:21 <george2> ah
22:16:23 <kardboardb> "return" lifts :: Board up to :: IO Board
22:16:47 <george2> ok, that makes sense.
22:16:59 <george2> now I just need to actually implement humanTurn.
22:17:02 <george2> thanks for the help.
22:17:08 <kardboardb> Yay! Glad it's working now.
22:19:04 <Javran> tikhon: so there is a category called Mon, in which objects are monoids and in addition, each monoid is a category, is that true?
22:19:24 <tikhon> yes
22:19:45 <tikhon> but Mon is completely different from the category defined by any given monoid
22:20:13 <Javran> tikhon: I see
22:20:17 <shachaf> The important thing about a category isn't the objects but the arrows.
22:21:11 <Javran> I got little confused because I've messed up these two categories for a while.
22:21:40 <shachaf> Actually, the important thing isn't the arrows but composition. :-)
22:22:05 <shachaf> You can specify a whole category precisely by just specifying how composition works. But saying what the objects are tells you almost nothing.
22:22:44 <tikhon> if you think of monoids as categories, you can think of monoid homomorphisms as functors
22:23:57 <shachaf> Yes, and Mon is a (full) subcategory of Cat.
22:24:01 <Javran> I just get started reading Simmon's introduction to category theory, hope that will help me somehow
22:24:45 <Javran> btw what is "monoid homomorphisms"?
22:25:20 <tikhon> it's a function between monoids that preserves the structure
22:25:27 <tikhon> ie that's what the arrows in Mon are
22:25:39 <shachaf> https://en.wikipedia.org/wiki/Monoid_homomorphism -- a particular kind of functions between monoids.
22:26:58 <Javran> thanks, that make sense
22:29:11 <pingu> Is there a good introductory text to type theory, especially the kind which you see in language design?
22:29:29 <johnw> Types and Programming Languages
22:29:41 <johnw> http://www.cis.upenn.edu/~bcpierce/tapl/
22:30:31 <pingu> thanks
22:32:04 <pingu> johnw: do you know what kind of mathematical background I'd need to get through that book?
22:34:13 <tikhon> pingu: I don't think you need much beyond basic logic
22:40:39 <pingu> tikhon: thanks
22:42:06 <Welkin> pinguman?
22:42:26 <pingu> ? not me.
22:42:32 <johnw> pingu: you don't need much, but beware that the first couple chapters will seem exceedingly dry if you don't; just push through though, it gets much easier and better
22:42:48 <pingu> johnw: cool, I'll keep that in mind.
22:42:51 <Welkin> https://www.youtube.com/watch?v=2kyzi6-ekvE
22:43:01 <pingu> The other day I needed to de-duplicate a large list of elements whilst retaining the property that the first duplicate wins.
22:43:24 <pingu> I ended up just doing a merge sort (stable) and then copied all elements to a new buffer if they were not preceeded by a duplicate.
22:43:36 <pingu> Sorry, not a new buffer but the same buffer.
22:44:06 <pingu> This works fine, but it's O/n assuming a duplicate at the beginning, as all elements after have to be shifted back.
22:44:27 <pingu> Can anyone think of a better way to do this? Does it involve incorporating de-duplication into the sort?
22:44:52 <pingu> I'd prefer not to do that as I was using vector-algorithms and don't really want to build my own.
22:45:52 <Jafet> > map head . groupBy ((==) `on` fst) . sortBy (comparing fst) $ [("a", 1), ("b", 2), ("a", 3), ("c", 4)]
22:45:54 <lambdabot>  [("a",1),("b",2),("c",4)]
22:47:05 <pingu> Jafet: neat, yeah, that's basically what I'm doing now.
22:48:37 <Jafet> Ok, what's wrong with that?
22:48:40 <johnw> you could reverse the list and just do "Map.toList . Map.fromList"
22:49:02 <pingu> I'm looking to do millions of elements in the minimum possible time
22:49:02 <Jafet> No, if pingu is using vector it is unlikely that there is enough memory for Map.
22:49:11 <pingu> (this is what I got the other day)
22:49:13 <johnw> ah
22:49:17 <pingu> http://lpaste.net/102909
22:49:24 <pingu> It's basically a draft.
22:49:34 <pingu> But. I was just curious about the de-dup algorithm.
22:50:03 <Jafet> The standard deduplication algorithm is group.sort. Why don't you want that?
22:50:19 <pingu> I am currently. I figure it'll be a fair bit faster if I can merge the filter and the deDup into the sort algorithm though?
22:50:33 <pingu> But I can't think of a composable way to do that.
22:50:39 <george2> how can I operate on (subtract a value from) a certain index of a list? the list's values are non-unique.
22:50:40 <pingu> without implementing a custom sort.
22:50:44 <Jafet> The only way to find out is to time it.
22:51:03 <Jafet> You can copy the code from Vector.Algorithms and modify it.
22:51:21 <pingu> Yeah, seems a bit messy though. Okay. thanks.
22:53:02 <kardboardb> george2, http://lpaste.net/102910
22:54:26 <Jafet> If you just want to deduplicate items, you can also use a hash table.
22:54:27 <george2> nice
22:54:43 <george2> no, I need my duplicate items
22:54:49 <pingu> Jafet: that's going to be much slower is all
22:54:50 <SrPx> Just wondering, `red a >>= (\a -> red b >>= (\b -> Just (C a b)))` is always preferred to be written as `do x <- red a; y <- red b; Just (C x y)`, right?
22:54:53 <kardboardb> Jafet, wouldn't that be a set
22:55:00 <george2> oh, ha. nvm.
22:55:51 <pingu> SrPx: yes, or in applicative style
22:55:57 <pingu> or with say, liftM2
22:56:04 <SrPx> pingu: how
22:56:12 <pingu> SrPx: (not that people don't write it the first way a lot), and hurt my brain
22:56:37 <SrPx> show me your spells please
22:56:42 <pingu> C <$> red a <*> red b
22:56:51 * SrPx wtfs
22:57:16 <Jafet> pingu: a hash table will be much slower?
22:57:36 <pingu> Jafet: Yes I'd say so, compared to those vectors.
22:57:50 <SrPx> I won't even ask...
22:58:23 <pingu> SrPx: does that work for you? liftM2 might make more sense
22:58:46 <SrPx> pingu: where do I learn that <$> and <*> wizardry
22:58:59 <Jafet> I don't think hash tables tend to be much slower than sorting, whether you use vector or some other way to store them.
22:59:00 <pingu> SrPx: learn you a haskell for great good has a pretty good section
22:59:12 <pingu> SrPx: maybe take a look at http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#liftM2 too
22:59:13 <SrPx> pingu: okay ty
23:00:22 <pavonia> SrPx: also http://www.haskell.org/haskellwiki/Typeclassopedia
23:01:51 <pingu> Jafet: well the hash table method is at least n writes to memory for the entire dataset
23:02:15 <pingu> and if the hash table is not pre-defined to be the correct size then you might need to re-hash as it expands
23:02:26 <Jafet> I imagine sorting involves many more writes than that. (Cache-friendly, to be fair)
23:03:27 <pingu> The biggest reason for the sort is that I want it sorted at the end anyway
23:03:41 <pingu> (we had a Ord Map in place before this for sorting/deduplication)
23:03:52 <pingu> and that was a fair bit slower
23:03:56 <Jafet> Ok then.
23:04:07 <pingu> I'd say simply due to allocations
23:04:24 <Jafet> Map is also non-strict.
23:04:42 <pingu> learning that the standard way to de-duplicate is with group makes me feel a little better about this solution
23:04:53 <pingu> It's pretty fast, certainly fast enough for now
23:08:13 * hackagebot nats 0.1.3 - Natural numbers  http://hackage.haskell.org/package/nats-0.1.3 (EdwardKmett)
23:08:34 <george2> is there an indentation preference for Haskell? I've seen so many different styles.
23:08:56 <pingu> george2: there are style guides for various projects
23:09:08 <pingu> and stylish-haskell enforces some indentation guidelines
23:09:21 <pingu> It's quite... liberal, though
23:09:36 <george2> But nothing global, like PEP8 then
23:09:39 <pingu> I sometimes refer to this
23:09:40 <pingu> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
23:09:51 <pingu> I've not heard of anything global. I'm probably wrong, though
23:10:20 <george2> hm, interesting way of writing lists, with the comma on the next line.
23:10:34 <tikhon> I usually go by what Emacs does or just whatever looks the most reasonable
23:10:47 <tikhon> yeah, I do like that style for lists and records
23:10:50 <pingu> george2: that is pretty common. It has a sill name too
23:10:57 <pingu> but I don't remember it
23:11:26 <george2> yeah, I usually let vim handle my indentation. but with that last code, it needed 3 spaces while vim still wanted to put in 4
23:11:59 <george2> that document seems good, I'll keep that on hand.
23:12:59 <george2> the if statements especially were confusing me
23:13:12 * hackagebot tagged 0.7.2 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.7.2 (EdwardKmett)
23:13:56 <george2> This code was so nice before I added all the nasty IO, now it's a mess. :(
23:14:31 <Welkin> silly humans
23:14:43 <srhb> george2: Oh? Usually you don't need much IO and can leave most stuff pure.
23:15:03 <george2> any refactoring tips? http://lpaste.net/102911
23:15:36 <george2> I wish I could just get rid of the humans, that would make it so much prettier :)
23:16:18 <srhb> george2: Yes, instead of having eg. getRow return IO Int, let the caller pass in getLine >>= and leave it pure
23:16:23 <srhb> george2: Same with as much else as you can
23:16:38 <srhb> Or rather, fmap stuff. :)
23:17:31 <george2> so something like getLine >>= getRow board ?
23:17:45 <srhb> george2: Right, but getRow board <$> getLine probably
23:18:01 <george2> <$>?
23:18:04 <pingu> `fmap`
23:18:06 <pingu> same thing
23:18:07 <srhb> george2: infix fmap
23:18:24 <pingu> same as getRow board `liftM` getLine
23:18:29 <insitu> anybody knows how to configure emacs haskell mode to have ghci setup with all sources of my cabal file?
23:19:28 <srhb> george2: The idea is to lift your functions into the monadic context, something you can freely do as long as they are not bound to some specific m
23:19:32 <george2> strange.
23:19:32 <george2> so which is preferred? just whatever is more readable in the specific case?
23:19:32 <srhb> :t fmap
23:19:39 <srhb> @type fmap
23:19:47 * srhb pokes lambdabot
23:20:00 <george2> fmap f x versus f <$> x, I mean
23:20:04 <srhb> george2: I think <$> has become idiomatic enough with Applicative
23:20:07 <pingu> george2: pure functions are superior here
23:20:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:20:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:20:16 <pingu> as they allow you to refactor to any other monad
23:20:21 <pingu> without changing your logic
23:20:26 <pingu> (composability is key)
23:20:30 <srhb> What pingu said.
23:20:51 <pingu> they also allow you to test your simple pure functions really easily and thoroughly
23:21:55 <george2> yeah, I understand the reasoning behind lifting the return value, I'm just trying to understand what is the best way of passing in pure values, since fmap, >>=, and <$> all seem to do the same thing.
23:22:04 <george2> s/return/input/
23:22:08 <srhb> george2: >>= does not do the same thing
23:22:09 <jakex> >>= is quite different
23:22:14 <srhb> You'd have to stick a return on it in this case
23:22:17 <srhb> which is an antipattern
23:22:23 <jakex> :t (>>=)
23:22:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:22:39 <george2> oh, ok. I missed something there then.
23:23:09 <srhb> foo >>= return . bar == fmap bar foo == bar <$> foo
23:23:38 <srhb> I think <$> reads nicely because it's almost application, ($)
23:23:52 <george2> ok, makes sense
23:23:55 <cwvh> george2:  do { row <- read <$> getLine ; ...
23:24:29 <srhb> george2: Anyway that should get rid of most of your IO signatures. :)
23:24:48 <george2> very nice, I'll do that then.
23:24:56 <heatsink> george2: It's a good idea to separate UI from the underlying data.
23:25:10 <srhb> george2: After you've tried that you could consider trying to read up on monad transformers
23:25:14 <SrPx> How can I improve this absolutely monstrous monad spaguetthi ?  http://lpaste.net/102912 (I'm due to read more on monads but for now all I know is the do notation)
23:25:28 <heatsink> The UI uses IO, while steps of game logic do not.
23:25:39 <george2> yeah, I kind of skipped over the monad stuff. obviously I shouldn't have.
23:26:01 <pingu> SrPx: you are aware maybe is a monad?
23:26:03 <srhb> SrPx: What is Nothing >>= foo ?
23:26:15 <SrPx> pingu: yes , why?
23:26:25 <pingu> what SrPx said :D
23:26:38 <SrPx> srhb: pardon?
23:26:57 <srhb> > Nothing >>= undefined
23:26:58 <lambdabot>  Nothing
23:27:06 <srhb> So you can chain Maybe actions like that.
23:27:52 <pingu> srhb: actually, read it again ;)
23:27:52 <SrPx> wait I am lagging, what
23:27:54 <pingu> I don't think he cain
23:27:56 <pingu> *he can
23:27:58 <srhb> Oh?
23:28:05 <pingu> he is performing an action on Nothing
23:28:12 <SrPx> it is because I'm not propagating nothing, right?
23:28:13 <george2> hm... here's a problem. If I purify the functions, I can no longer print inside of them, which means I only get one prompt, even if the function calls itself multiple times.
23:28:14 * hackagebot free 4.7 - Monads for free  http://hackage.haskell.org/package/free-4.7 (EdwardKmett)
23:28:16 <pingu> in the first case
23:28:21 <srhb> Oh, right
23:28:27 <srhb> Hm, that's a bit weird using Maybe for that
23:28:31 <SrPx> the point is, whenever I get a correct match, I propagate that correct match to the end of the fold
23:28:39 <SrPx> srhb: maybe is all I know ^^
23:28:53 <Jafet> Oh boy tabs
23:29:17 <SrPx> Jafet: :%s/\t/    /g
23:30:44 <pingu> SrPx: you can still do the maybe trick for the inner case
23:30:59 <pingu> i.e. match from value >>= red foldr...
23:31:11 <pingu> SrPx: you could also clean it up by using let or where
23:31:18 <pingu> that would make it a *lot* more readable
23:31:23 <SrPx> pingu: true... maybe adding a helper function?
23:31:43 <george2> how can I maintain this behavior, while keeping getRow pure? http://lpaste.net/102913
23:31:46 <srhb> And once again we find ourselves wanting the short-circuiting right fold
23:31:51 <pingu> Yeah, I usually do folds like foldr f 0 ..
23:31:54 <pingu> where f =
23:32:03 <srhb> george2: That would be relegated to your IO-y game loop
23:32:08 <SrPx> srhb: what do you mean
23:32:56 <srhb> SrPx: For bailing out of a fold. :)
23:33:22 <pingu> I was thinking that too. SrPx the continuation monad might actually help you
23:33:29 <pingu> I don't know if the brain hurt is worth it though
23:33:34 <srhb> I agree
23:33:49 <srhb> Explicit recursion might be slightly cleaner tbh.
23:33:58 <srhb> But other than that and helper functions yeah, it's fine.
23:34:23 <george2> srhb: but the recursion is done by checking the bounds on the input. If I get the input outside of getRow, check the bounds outside of getRow, and print the prompt outside of printRow, then printRow is empty. :/
23:34:41 <srhb> george2: Ah, yes.
23:34:58 <srhb> george2: Time for StateT !
23:35:33 <SrPx> pingu: oh no brain hits for now I'm still due to learn more about monads ... srhb: yes but what do you mean, is there a fold that allows for that?
23:35:44 <pingu> SrPx: no there's not.
23:35:48 <george2> looks scary :3
23:35:52 <srhb> It's easily written, but can be done
23:35:52 <SrPx> how about this, improving? http://lpaste.net/102914
23:36:08 <SrPx> pingu: why? Would that be bad?
23:37:01 <pingu> SrPx: I just said there's no fold that does that
23:37:26 <pingu> SrPx: try putting your fold functions in a where section
23:37:28 <pingu> or a let at the top
23:37:46 <george2>  Not in scope: `<$>'
23:37:46 <george2> Is this from some import?
23:37:55 <srhb> george2: Control.Functor or Control.Applicative
23:37:57 <pingu> and then you will probably find that you can eta reduce it a fair bit ;)
23:37:59 <srhb> george2: Hoogle to the rescue
23:38:29 <srhb> Er, Data.Functor of course, or Control.Applicative
23:38:40 <george2> well, duckduckgo has a !hoogle bang, so I guess I'll be using that a lot from now on.
23:39:58 <SrPx> http://lpaste.net/102914 pingu what about this
23:40:20 <SrPx> eta reduce? hmm let me think what that means
23:40:46 <johnw> eta reduce is when the last argument can be dropped
23:40:51 <pingu> SrPx: (\x -> f x) 1 == f 1
23:41:01 <SrPx> that is what I was thinking, but I'm not sure I can apply that there, can I ?
23:41:02 <pingu> basically
23:41:05 <johnw> foo x y = (g x) y  ==>  foo x = g x  ==>  foo = g
23:41:20 <pingu> SrPx: can I get your whole file?
23:41:29 <pingu> Then I can have a play with it and make sure it typechecks
23:41:49 <pingu> (assuming it does now)
23:42:12 <pingu> at least this:
23:42:16 <pingu>       check_cases (from,to) (Just value) = Just value
23:42:19 <pingu> is a bit weird
23:42:22 <pingu> I'd have written it:
23:42:25 <SrPx> pingu: why not, http://lpaste.net/102919 notice I'm a newbie
23:43:08 <pingu> SrPx: ah, cool. I'll take a look.
23:43:17 <SrPx> okay (:
23:45:42 <johnw> SrPx: the simply-typed lambda calculus?
23:45:58 <SrPx> johnw: pardon?
23:46:04 <johnw> the code you pasted
23:46:16 <SrPx> yes with pattern matching and recursion
23:46:21 <SrPx> I guess
23:46:24 <SrPx> should be, at least
23:47:34 <pingu> SrPx: red is really not all that bad now.  You have three definitions though
23:47:41 <pingu> and I don't see how the final one wil ever be reached
23:47:43 <pingu> (of check_cases)
23:47:45 * SrPx has a feeling pingu is right now filling my code with clever hieroglyphs I will never ever understand
23:48:03 <pingu> SrPx: I didn't actually do anything yet
23:48:08 <SrPx> pingu: three?
23:48:12 <pingu> I want to make sure we know what it's doing currently
23:48:12 <SrPx> oh ok (:
23:48:16 * hackagebot propellor 0.4.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.4.0 (JoeyHess)
23:48:19 <Jafet> Are hieroglyphs legal identifiers
23:48:19 <SrPx> "we"
23:48:20 <SrPx> ?
23:48:43 <pingu> SrPx: 25, 26, 29
23:48:57 <SrPx> but 29 is check_case not check_cases
23:49:14 <SrPx> okay maybe I chose bad names
23:50:16 <pingu> SrPx: yeah I didn't notice. okay. I'll get back to you in 10 minutes or so I just have to do something.
23:51:43 <SrPx_> It improved a lot already, thanks. (not sure if the message went)
23:53:08 <Jafet> > generalCategory '𓀀'
23:53:10 <lambdabot>  OtherLetter
23:53:54 <Jafet> :t ?𓀀
23:53:56 <lambdabot> (?
23:54:09 <Jafet> > "𓀀"
23:54:11 <lambdabot>  "\77824"
23:54:12 <pingu> SrPx: Nope, that's pretty clean now :)
23:54:16 <Jafet> > text "𓀀"
23:54:17 <lambdabot>  𓀀
23:54:26 <johnw> Jafet: having fun? :)
23:54:37 <SrPx> (:
23:54:46 <pingu> SrPx: I wouldn't personally change much. Just because you can make it shorter doesn't make it better.
23:55:14 <Jafet> I can't actually see the glyph here. I hope it's not the glyph for "male".
23:55:16 <SrPx> alright, then (=
23:55:28 <SrPx> I'm still loving each second with that language, by the way
23:55:38 <pingu> SrPx: a few stylistic things: I've never seen a do like you used it on the next line
23:55:40 * SrPx can't get enough of saying this
23:55:49 <pingu> so... something =
23:55:53 <pingu> do x <- a1
23:56:01 <pingu> I'd normall write as something = do
23:56:04 <pingu>   x <- a1
23:56:08 <pingu> and that appears to be convention
23:56:10 <johnw> i've seen both
23:56:26 <SrPx> pingu: pingu you mean just mode the "do" up, or the entire line?
23:56:32 <SrPx> move*
23:56:33 <pingu> just the do
23:56:45 <johnw> structured-haskell-mode will generally do what SrPx does
23:56:58 <SrPx> okay, I actually prefer it your way as I can indent less, thanks
23:56:58 <johnw> but I also prefer do on the preceding line
23:57:22 <pingu> SrPx: also, if you'r not using an argument to a fuction, generally use _
23:57:35 <pingu> just so that it's clear
23:57:41 <johnw> _, or you can name the unused argument: _foo
23:57:56 <johnw> (in case someone wants to use it in future)
23:58:11 <SrPx> oh right, you mean the first (from,to) right?
23:58:12 <pingu> does that make ghc-mod lint happpy?
23:58:17 <pingu> SrPx: yeah
23:58:25 <SrPx> cool
23:59:07 <SrPx> just a question, is there a way to avoid the code duplication on the subs_ function aboee?
23:59:10 <SrPx> above*
23:59:14 <SrPx> I mean lines 9-16
23:59:41 <pingu> SrPx: yeah, define a helper function that does that duplicate stuff
23:59:47 <pingu> and pass in the bits that differ
