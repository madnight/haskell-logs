00:03:03 <pingu> SrPx: consider maybe:
00:03:06 <pingu>   red (App a b) = App <$> red a <*> red b
00:03:11 <pingu> and   red (L a) = L <$> red a
00:03:14 <pingu> etc
00:03:36 <SrPx> But the part that differ is a type constructor... hmm... let me see
00:04:48 <pingu> this:
00:04:49 <pingu>   match (C a b) (C c d) = match a c >>= (\x -> match b d >>= (\y -> Just (x ++ y)))
00:04:52 <pingu> also can become
00:04:53 <pingu>   match (C a b) (C c d) = (++) <$> match a c <*> match b d
00:05:20 <pingu> the first is well and truly the most longhand way to write it
00:05:27 <pingu> and I personally find it confusing
00:06:29 <pingu> SrPx: the final thing I'd take note of is just shadowing your variable names
00:06:50 <pingu> e.g. in (\x -> (\x -> f x))
00:06:56 <pingu> it's not immediately clear which x you mean
00:07:12 <_2_luciernaga3> :'(
00:07:15 <pingu> hence often it'll be (\x -> (\x' -> f x))
00:07:19 <_2_luciernaga3> bye
00:07:28 <pingu> x' I mean
00:07:50 <SrPx> pingu: for all that I'll be reading about <$> and <*>, don't know what they do exactly but sound powerful
00:08:23 <SrPx> and certainly looks very nice
00:08:47 <pingu> it seems complicated at first, it's not really.
00:09:00 <dmj`> > Just (\x -> x + 1) <*> Just 4
00:09:02 <pingu> if you're more comfortable with monads though, you can do the same with liftM2
00:09:02 <lambdabot>  Just 5
00:09:10 <johnw> f <*> x is just like f $ x, except that both f and x are "applicative values"
00:09:26 <dmj`> think fmap, but already lifted
00:09:37 * hackagebot propellor 0.4.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.4.0 (JoeyHess)
00:09:37 * hackagebot holy-project 0.1.1.0 - Start your Haskell project with cabal, git and tests.  http://hackage.haskell.org/package/holy-project-0.1.1.0 (yogsototh)
00:09:56 <johnw> joeyh is really onto this propeller project now
00:10:05 <johnw> guess that yak is making some sweaters for him by now
00:10:14 <Heather> what is data type describing operations
00:10:29 <johnw> Heather: hmm?
00:12:22 <pingu> SrPx: (oh and the lpaste has some warnings at the botttom for you that are valid)
00:12:59 <SrPx> pingu: uh huh, I'm taking account of those (: I didn't know lambdas were prohibited
00:13:28 <SrPx> I'm still not comfortable with monads, by the way...
00:14:08 <johnw> SrPx: it's more a question of being comfortable with >>=, because return is pretty comfy
00:14:21 <SrPx> (and I still have to read about fmap and what lifting even mean so... some way to go)
00:14:23 <pingu> SrPx: lambdas are fine, composition is just easier to read for most people
00:16:28 <SrPx> 4am... my brain is melting. Had a great time, thanks guys. Good night (:
00:16:47 <johnw> molten brain syndrome
00:19:11 <joeyh> johnw: http://joeyh.name/blog/entry/propellor-driven_DNS_and_backups/
00:19:25 <johnw> nice!
00:20:05 <johnw> joeyh: I wonder if propellor could become a Haskell DSL for Nix that some have wished for
00:21:04 <joeyh> I suspect that nixops is still yards ahead, especially in coordinating multi-server rollouts
00:21:59 <joeyh> which is the part of nix propellor more closely corresponds to than the package generation language part
00:22:04 <joeyh> s/nixops/disnix/
00:22:12 <johnw> right
00:24:22 <joeyh> btw, I had a lot of fun filling my personal propellor config file with ascii art that happens to be interpreted as haskell comments :) http://git.joeyh.name/?p=propellor.git;a=blob;f=config-joey.hs
00:24:35 * hackagebot yes-precure5-command 5.5 - Extended yes command to reproduce phrases in Yes! Precure 5.  http://hackage.haskell.org/package/yes-precure5-command-5.5 (igrep)
00:24:44 <johnw> hahahaha
00:24:50 <johnw> having lots of fun I see!
00:25:07 <joeyh> I especially am proud of how the submarine manages to be a comment
00:32:02 <george2> how can I use fmap with a function that accepts two parameters?
00:32:22 <johnw> you mean, you want to lift a -> b -> c to f a -> f b -> f c?
00:32:40 <johnw> you'd use liftA2 for that, which requires Applicative
00:33:33 <george2> hrm. Lemme take a step back then.
00:34:11 <george2> I want to get two random integers from within two different ranges, and pass them into a function
00:34:37 <george2> but randomRIO returns an IO Int, so I was trying to fmap them into my function, but that didn't work.
00:34:53 <johnw> you can liftA2 them
00:34:53 <george2> Should I be taking a different route entirely?
00:34:56 <johnw> IO is an Applicative
00:35:05 <johnw> liftM2 will work with IO too
00:35:21 <george2> ok. off to hoogle I go then.
00:39:01 <augur> hm
00:43:16 <george2> What does the type "f a" mean? Trying to LiftA (myFunc :: a -> b -> c) (x :: IO Int) (y :: IO Int) fails.
00:43:28 <george2> am I supposed to pass in fmap somehow?
00:43:40 <george2> :t liftA
00:43:42 <johnw> liftA2
00:43:42 <lambdabot> Applicative f => (a -> b) -> f a -> f b
00:43:47 <johnw> :t liftA2
00:43:48 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:44:04 <george2> sorry, that's what I meant to say
00:44:06 <george2> A2
00:44:13 <johnw> show me what you're trying to do?
00:44:58 <george2> http://lpaste.net/102920
00:45:03 <startling> joeyh: hey, propellor looks really nice.
00:45:20 <george2> updateBoard :: Board -> Int -> Int -> Board
00:45:27 <startling> I wonder if I can coopt it to configure machines over ssh?
00:45:35 <johnw> row and sticks are pure values
00:45:49 <johnw> oh, wait
00:45:55 <johnw> I see what you are doing
00:45:56 <george2> they're IO Ints
00:45:59 <johnw> this will not work
00:46:10 <johnw> computerTurn must have the type Board -> IO Board
00:46:19 <johnw> then s/let row =/row <-/
00:46:30 <johnw> and then you can return $ updateBoard board row sticks
00:46:31 <johnw> etc.
00:46:42 <george2> ok.
00:46:57 <george2> too bad, that means I've unpurified yet another function.
00:47:05 <johnw> well, you're using randomRIO
00:47:07 <joeyh> startling: propellor runs over ssh more or less by default
00:47:07 <johnw> that has a side-effect
00:47:17 <joeyh> including deploying itself to the machine, which is a bit fun
00:47:40 <joeyh> (not as much fun as deploying itself to inside a docker container that is of a different architectue than the host system, and lacks ghc however)
00:47:43 <startling> oh, perhaps I misunderstood?
00:48:01 <pavonia> george2: "liftA2 (!!) board row" won't work there too, randomIO needs pure parameter values
00:48:15 <joeyh> propellor --spin host will ssh to the host and run propellor there to satisfy the host's properties
00:48:17 <augur> curious fact:   we like to think of the type A -> B as an exponential object B^A in category theory, because of how the cardinalities work out, but the behavior with relation to tensoring isn't quite right
00:48:39 <george2> well now row should be pure, so board !! row will work.
00:48:41 <joeyh> often one of the properties enables a cron job which then runs propellor pulling from git
00:48:53 <augur> on the other hand, A -> B behaves more like division wrt tensoring:   A * (A -> B) ~> B   which is a lot like A * (B/A) = B
00:49:28 <pavonia> george2: row is a monadic action
00:49:42 <augur> so in some sense functions are exponentiations, in some other sense, they're divisions. is the a unification here?
00:49:53 <george2> pavonia: when I do row <- randomRIO, row becomes an Int.
00:50:08 <pavonia> Ah, right
00:50:26 <pavonia> but still
00:50:28 <pavonia> :t liftA2 (!!)
00:50:30 <lambdabot> Applicative f => f [c] -> f Int -> f c
00:51:21 <george2> My original purpose there was to somehow coerce row into being an int, so I could use it as an index in row. How would I accomplish that correctly?
00:51:35 <george2> s/index in row/index in board
00:51:55 <pavonia> "board !! row" is wha you want, I guess
00:52:03 <pavonia> *what
00:52:39 <george2> well, that complained that row was IO Int when it expected an Int. Now that row is pure, of course, it works fine.
00:53:31 <johnw> george2: what do you mean by "now that row is pure"?
00:54:32 <george2> I mean, http://lpaste.net/102920 became http://lpaste.net/102921
00:54:59 <johnw> I wouldn't really talk about purity here in that sense
00:55:15 <johnw> i mean, all values are "pure", because they can't have side-effects
00:55:21 <george2> sorry, what is the term for a non-monadic value?
00:55:32 <startling> "value"?
00:55:36 <george2> variable?
00:55:44 <johnw> we usually say a monadic value is an "action"
00:55:49 <johnw> other things are just values
00:55:57 <george2> ok
00:57:37 <johnw> but even "action" is not universally worth using
00:57:41 <johnw> Maybe Int is hard to call an action
00:57:58 <startling> it's an action in the general sense.
00:58:28 <startling> you can say "x function takes a monadic action" and that would be understood to include values like those of type Maybe Int.
00:58:37 <johnw> true
00:59:28 <johnw> I just wanted to distinguish from the meaning of "action" as "a thing that does something if I execute it".  Although, maybe that "something" is to "short-circuit on Nothing" in the case of Maybe
00:59:39 * hackagebot yes-precure5-command 5.5.1 - Extended yes command to reproduce phrases in Yes! Precure 5.  http://hackage.haskell.org/package/yes-precure5-command-5.5.1 (igrep)
01:00:56 <startling> yeah. it's a fuzzy situation. "action" is maybe not the best word.
01:01:20 <startling> in one sense 'maybe' is how you execute a Maybe.
01:01:48 <startling> so the action is "becomes a given value if ever there's a Nothing".
01:02:06 <johnw> you know you're talking about some serious abstraction when you can't find a word to describe the thing :)
01:02:28 <johnw> we need a Unicode symbol for "insert hand-waving here"
01:03:07 <Jafet> Java has beans, why can't we have curritos
01:03:32 <startling> sounds delicious.
01:03:43 <startling> can our curritos have beans, too?
01:03:49 <johnw> I worked with the guy who invented beans for Java; I bet he's quite surprised at how long the idea has lasted
01:04:33 <startling> I'm not sure I understan java beans.
01:04:50 <johnw> it's just a set of standards an object must adhere too in order to be interacted with in a more general way
01:05:14 <startling> so, an object?
01:05:24 <johnw> there are objects which aren't beans, but all beans are objects
01:05:59 <johnw> mostly it has to do with faking the concept of having "properties"
01:38:22 <george2> I need something that does exactly the opposite of Data.Bits.bit...
01:38:39 <johnw> :t Data.Bits.bit
01:38:42 <lambdabot> Bits a => Int -> a
01:40:38 <george2> bit 3 is 8, (100b) I need a function that returns 3 when I pass it 8.
01:41:08 <george2> isn't the source for these modules available somewhere?
01:41:15 <george2> I think I stumbled onto it once before.
01:41:15 <johnw> isn't that just a base-2 integer log?
01:41:31 <george2> maybe... I don't know what that means.
01:41:32 <johnw> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-Logarithms.html
01:41:36 <haasn> :t firstOf $ bits.filtered id.asIndex
01:41:38 <lambdabot> (Bits s, Num s) => s -> Maybe Int
01:41:55 <johnw> well, wordLog2# of 8 should be 3
01:42:39 <johnw> when taking about binary numbers, log-2 is "how many bits it takes to represent the number"
01:43:06 <george2> ghci seems to choke on the #
01:43:09 <george2> <interactive>:151:15: Not in scope: `#'
01:43:14 <johnw> you have to enable MagicHash I believe
01:43:21 <haasn> yeah, usually that's an operator
01:43:29 <haasn> with MagicHash it's a valid suffix of identifiers (or something similar to that)
01:44:42 <george2> how do I enable magichash? {-# LANGUAGE MagicHash #-} doesn't work, that must be just for files I guess.
01:45:11 <johnw> that should do it
01:45:12 <Jafet> :set -XMagicHash
01:45:18 <johnw> ah
01:45:20 <johnw> right
01:45:57 <fizruk> if I have a list and a partial order and I want to sort that list, I guess I need topological sort? is there an implementation somewhere already?
01:45:59 <haasn> (or :seti)
01:46:59 <johnw> fizruk: Data.Graph.topSort
01:48:08 <fizruk> johnw: thanks! is there an easy way to get graph from list and partial order function?
01:48:56 <george2> hrm, I just get     Couldn't match kind `*' against `#'. Another interactive setting?
01:49:03 <fizruk> i guess the only way is graphFromEdges
01:49:14 <johnw> or buildG, if you have edges instead of nodes
01:49:48 <fizruk> i see, thanks!
01:51:27 <Heather> :t ArgDescr
01:51:29 <lambdabot> Not in scope: data constructor ‘ArgDescr’
01:53:02 <Jafet> > I# (integerLog2# 123)
01:53:04 <lambdabot>  Not in scope: data constructor ‘I#’
01:53:04 <lambdabot>  Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)...
01:53:19 <Jafet> > fix In
01:53:21 <lambdabot>  Kind incompatibility when matching types:
01:53:21 <lambdabot>    f :: * -> *
01:53:21 <lambdabot>    Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f :: *
01:53:21 <lambdabot>  Expected type: f (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f)
01:53:21 <lambdabot>                 -> f (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f)
01:55:03 <george2> http://lpaste.net/102924
01:57:37 <george2> I don't know what to do. I just need to get the bit size of an unsigned int. It seems bit-level operations are not haskell's strong suit.
01:58:42 <george2> There's even a function called bitSize, but it seems to be dead.
01:58:49 <george2> > bitSize 3
01:58:50 <lambdabot>  *Exception: Data.Bits.bitSize(Integer)
01:59:13 <Jafet> It is unfortunate that this is hard to write in most languages, even though most hardware have a log_2 instruction
01:59:25 <Jafet> No idea how people blame this on haskell, though
01:59:56 <george2> In Ruby it was relatively easy, though I had to use number format conversion instead of this log2.
02:00:28 <ClaudiusMaximus> george2: something like  case 8 of I# i -> I# (wordLog2# i)  might work?
02:00:54 <george2>     Couldn't match expected type `GHC.Prim.Word#'
02:00:55 <george2>                 with actual type `Int#'
02:01:07 <johnw> or log2 (I# i) = I# (wordLog2# i)
02:01:36 <ClaudiusMaximus> oh oops, use the constructor for Word instead of Int
02:02:42 <Jafet> In ruby it is easy, turn everything into a string?
02:02:48 <ClaudiusMaximus> > bitSize (3 :: Word) -- looks like the Bits class is restructured to something safer in latest ghc
02:02:49 <lambdabot>  64
02:03:13 <george2> yeah, ruby is just 3.to_s(2)
02:03:27 <george2> bitSize says it is deprecated, is it on to use?
02:03:32 <george2> *ok
02:03:46 <johnw> deprecated usually means "will disappear someday"
02:03:57 <johnw> but it could take a really long time for that to happen :)
02:04:59 <george2> I'm missing this "Word" constructor
02:05:04 <george2> where is it from?
02:05:26 <ClaudiusMaximus> bitSizeMaybe is only there since latest ghc-7.8 (base-4.7)
02:05:28 <johnw> Data.Word
02:05:36 <Jafet> george2: do you then take the length of the base-2 string?
02:06:39 <george2> Jafet: in ruby I went a different route, http://lpaste.net/102925
02:07:36 <george2> 64 is not the correct value
02:07:40 <Jafet> You know that log_2 is not the same thing, right?
02:07:57 <george2> this seems to be using signed bits
02:08:06 <george2> I don't know what log_2 is at all
02:08:09 <Jafet> Signed bits? Oh dear.
02:08:27 <Jafet> log_2 is the base-2 logarithm (rounded down).
02:09:07 <george2> I'm afraid my math teachings haven't reached that point yet :)
02:10:01 <george2> wait, this would be like log base 2 of n?
02:10:15 <simon> george2, log_2(2^n) = n
02:11:02 <george2> well according to wolfram, log_2(3) is ~1
02:11:05 <Jafet> The number of bits in N is 1 + floor (log_2 N).
02:11:09 <simon> george2, i.e. the number of times you can halve a number before you reach 1.
02:11:39 <george2> is there a log_2 available in Haskell?
02:11:55 <simon> :t logBase
02:11:57 <lambdabot> Floating a => a -> a -> a
02:12:06 <Jafet> Not for integers, but you can write one.
02:12:17 <johnw> there's wordLog2# for Word, and integerLog2# for integers
02:13:04 <george2> but I can't get any of those to work. Maybe I should try in a file instead of interactive.
02:13:07 <simon> > logBase 2 64
02:13:09 <lambdabot>  6.0
02:13:13 <Jafet> And there's no reason why you can't do the same thing that your ruby code does.
02:13:36 <simon> > 2 ** 6
02:13:38 <lambdabot>  64.0
02:13:51 <george2> Well, I thought this would be simpler in Haskell. There is a lot of reversing that I don't like in the ruby.
02:14:02 <Jafet> > map (\n -> length $ showIntAtBase 2 (const '.') n "") [0..]
02:14:04 <lambdabot>  [1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6...
02:14:18 <george2> If I just and the two numbers, then get the size of the result, it should give me the integer I want.
02:14:59 <johnw> george2: see http://hackage.haskell.org/package/arithmoi-0.4.0.1/docs/src/Math-NumberTheory-Logarithms.html
02:15:16 <johnw> the function intLog2' is what you wanted to write
02:15:49 <johnw> wordLog2' is effectively what we wrote up above
02:17:38 <george2> This just uses the GHC.Integer.Logarithms functions, doesn't it?
02:17:40 <george2> I# (wordLog2# (int2Word# i#))
02:17:50 <johnw> yep
02:17:57 <johnw> because that's pretty much what you want
02:18:03 <johnw> i'm just showing you the function already-written
02:20:16 <merijn> > enumFrom False
02:20:17 <lambdabot>  [False,True]
02:20:47 <no-n> > enumFrom enumFrom
02:20:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
02:20:49 <lambdabot>    arising from a use of ‘M30584109822592308431740.show_M30584109822592308431...
02:20:49 <lambdabot>  The type variable ‘a0’ is ambiguous
02:20:49 <lambdabot>  Note: there are several potential instances:
02:20:49 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
02:20:54 <george2> even in ghc, these functions don't work for me.
02:21:40 <merijn> george2: You mean actually writing wordLog2# in your code?
02:21:44 <george2> http://lpaste.net/102926
02:21:48 <merijn> I think that requires -XMagicHash
02:22:07 <merijn> george2: Oh, yeah
02:22:19 <merijn> george2: polymorphic functions can't take unboxed types as arguments
02:22:28 <merijn> You need to rebox the result of wordLog2#
02:22:44 <george2> how?
02:22:57 <merijn> Assuming you want Int, use the I# constructor
02:23:05 <merijn> "I# :: Int# -> Int"
02:23:44 <george2> ok, that works
02:27:35 <merijn> Is boundedEnumFrom exported anywhere?
02:31:37 <george2> Should I be using Integer over Int in my type declarations?
02:31:49 <george2> These functions seem to want Integers.
02:33:32 <george2> Nevermind, everything blows up when I do that.
02:33:40 <simon> george2, Integer can be arbitrarily big, Int is bounded by word size. you probably want Int.
02:33:57 <george2> Is there a way to box things in an Int then, rather than I#?
02:34:43 <george2> Because right now I'm getting some     Couldn't match expected type `Integer' with actual type `Int'
02:34:44 <simon> george2, I guess the I# constructor makes an Int# into an Int.
02:35:14 <merijn> george2: I# is the constructor for Int\
02:35:22 <george2> :t (.&.)
02:35:24 <lambdabot>     Ambiguous occurrence ‘.&.’
02:35:24 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
02:35:24 <lambdabot>                              imported from ‘Data.Bits’ at /home/lambda/.lambdabot/State/L.hs:55:1-16
02:35:29 <merijn> george2: The error implies you're passing an Int to something expecting Integer
02:35:40 <simon> george2, maybe something else is provoking the expectancy of Integer.
02:35:43 <george2> Yes, Data.Bits.(.&.)
02:35:54 <merijn> > [1..1]
02:35:55 <lambdabot>  [1]
02:36:14 <george2> hm, the type is just Eq a
02:37:01 <george2> :t integerLog2#
02:37:02 <lambdabot> Not in scope: ‘integerLog2#’
02:37:05 <george2> integerLog2# :: Integer -> Int#
02:37:24 <george2> maybe that
02:38:11 <george2> right now I have
02:38:13 <george2> pickRow :: Int -> Board -> Int
02:38:13 <george2> pickRow sum board = I# (integerLog2# (length board .&. sum))
02:38:42 <george2> it dies at 'length' and 'sum'
02:39:37 <simon> george2, have you considered intLog2 rather than integerLog2?
02:40:14 <george2> Not in scope: `intLog2#'
02:40:14 <george2> Do I need to write this myself?
02:40:27 <simon> no. http://hackage.haskell.org/package/arithmoi-0.4.0.1/docs/src/Math-NumberTheory-Logarithms.html#intLog2
02:44:20 <george2> :t int2word#
02:44:21 <lambdabot> Not in scope: ‘int2word#’
02:50:37 <osa1> I updated ghc and cabal some time ago and just realized that .cabal/share/doc/index.html is removed. any ideas why it's not there?
02:51:00 <osa1> note that that folder has documentation in subfolders. just index file is missing
02:59:53 * hackagebot language-lua 0.3.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.3.1 (OmerAgacan)
03:00:23 <george2> I need to go to bed before I pass out.
03:00:40 <george2> thanks again for all the help.
03:04:58 <merijn> I don't suppose Haddock has a convenient way of grouping multiple pattern synonyms together in the generated docs?
03:16:27 <Saizan> osa1: do you have a doc-index-file line in your .cabal/config ?
03:26:43 <jtcwang1> Hey guys, I'm working with conduit here. I noticed that for Conduit type signature for source/sink always have IO as the monad
03:27:08 <jtcwang1> is this always the case? Even if the computation is pure
03:27:16 <jtcwang1> eg. conduit :: Conduit Int IO String
03:34:56 * hackagebot puzzle-draw 0.1.0.2 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.1.0.2 (vollmert)
03:34:58 * hackagebot puzzle-draw-cmdline 0.1.0.4 - Creating graphics for pencil puzzles, command line tools.  http://hackage.haskell.org/package/puzzle-draw-cmdline-0.1.0.4 (vollmert)
03:51:07 <merijn> jtcwang1: Well, if the computation is pure, I don't think it makes sense to bother with conduit? You could just use laziness and lists
03:51:19 <merijn> jtcwang1: The entire usecase for conduit and pipes are impure data streaming
03:51:34 <jtcwang1> in my case, it's file io
03:51:53 <merijn> jtcwang1: Right, so how would you have a conduit without IO if you wanna do file IO?
03:51:58 <jtcwang1> merijn, though my usecase isn't exactly 'infinite size file', but I want to take the opportunity to learn conduit
03:52:32 <jtcwang1> merijn, you got a point, since during streaming you could have file being deleted forcefully or what have you
03:52:57 <merijn> jtcwang1: Eh, more importantly
03:53:05 <merijn> jtcwang1: You're reading from a file, that's IO
03:53:17 <jtcwang1> merijn, my program is single input file, multiple output file. I'm trying to work out how i'd achieve that
03:53:17 <osa1> Saizan: just enabled it
03:53:44 <jtcwang1> merijn, yeah true, but what I thouht was the intermediate steps (the conduit) can be pure
03:54:04 <merijn> jtcwang1: The idea of conduit is that your orthogonal steps are composed into a single conduit which is run
03:54:24 <merijn> jtcwang1: Since your source and/or sink will have IO, the entire conduit will end up using IO
03:55:56 <merijn> Is it possible to have haddock generate docs from "fake" source (i.e. generate docs from different source then the actual compiled source)
04:04:10 <Saizan> osa1: if you install something that produces docs it should regenerate the index
04:08:13 <skuggi>    The lambda expression ‘\ as -> sum as / n’ has one argument,
04:08:13 <skuggi>     but its type ‘[a] -> a’ has only one
04:08:27 <skuggi> what the heck is ghc trying to tell me here?
04:10:40 <merijn> skuggi: Intriguing error
04:10:50 <merijn> skuggi: What happens if you delete the space between '\' and 'as'
04:12:55 <skuggi> merijn: same error
04:13:23 <merijn> skuggi: Can you paste the entire code?
04:14:09 <skuggi> i figured out the problem now. n is Int and as is Fractional.
04:15:28 <skuggi> merijn: http://lpaste.net/102929 here's the code that gave the error message
04:16:10 <merijn> skuggi: go returns a tuple
04:16:25 <merijn> Oh, wait you're using first
04:16:28 <merijn> That's really confusing
04:16:31 <skuggi> :)
04:17:02 <merijn> skuggi: Why not put "go n ([], g)" in the where clause and just do "sum blah / n" on that?
04:17:23 <skuggi> dunno, didn't feel like it :)
04:17:28 <Jafet> Should report that as a ghc bug
04:18:09 <merijn> skuggi: See annotation: http://lpaste.net/102929
04:19:56 <skuggi> merijn: i just edited that in too. (also you forgot about the StdGen)
04:20:00 * hackagebot tianbar 0.4.2.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.2.0 (AlexeyKotlyarov)
04:25:01 * hackagebot c2hs 0.17.2 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.17.2 (IanRoss)
04:28:14 <merijn> Anyone remember what Ian Ross' IRC nick is?
04:29:10 <alpounet> merijn: iross iirc
04:38:03 <iross> merijn: It's iross or iross_ or something like that...
04:38:36 <no-n> lol
04:53:56 <aloiscochard> how can I create a 'failed' property using a message string with quickcheck?
04:54:23 <aloiscochard> let say I have branching with if, and in one case I do 'property ...somecheck...' and in the other one I want to fail with a message?
05:15:18 <seanparsons> I'm a bit baffled as to why https://github.com/argonaut-io/argonaut-hs/blob/master/src/Data/Argonaut/Decode.hs#L29 is giving me this error: https://www.irccloud.com/pastebin/pc4vg655
05:16:00 <seanparsons> I've tried bending and twisting it in various directions, but it still seems to be fighting me for some reason.
05:24:14 <countoren> hello guys, im trying to install yesod and getting error installing conduit when im trying to install conduit
05:24:34 <countoren> hello guys, im trying to install yesod and getting error installing conduit when i tryed to install conduit by it self i got this error:
05:24:47 <countoren>                                                  ^  Data/Conduit/Internal.hs:371:4:      error: invalid preprocessing directive       #-}        ^
05:26:17 <countoren> any help?
05:28:10 <aloiscochard> seanparsons: does it work if you fix the right side of the Either (type param `a`)?
05:28:28 <kayloos> countoren: try upgrading cabal and ghc to the latest versions
05:29:03 <Kerrim> Hello, I'm just getting started with Haskell and I need help. GHC gives me a parsing error for a pattern match i wrote. I can't figure it out, all the types seem to be right. Here's a paste of the function: http://lpaste.net/102936
05:31:25 <kayloos> countoren: If you're running OS X Mavericks it might also be a problem with the new cpp compiler
05:31:26 <pyon> Kerrim: convertVecs (x:xs)
05:31:54 <pyon> Kerrim: those parentheses are needed there
05:32:43 <Kerrim> pyon: oh wow, thanks
05:32:50 <pyon> Kerrim: also, it would probably better to do "convertVecs = map (\x -> (angle x, x))"
05:33:17 <pyon> Kerrim: Or "convertVecs = map foo   where foo x = (angle x, x)", if you will
05:33:22 <Axman6> pyon: small steps
05:33:30 <Kerrim> pyon: aha! nice
05:34:59 <Kerrim> pyon: works beatifully, thank you very much
05:35:10 <pyon> :-)
05:38:30 <countoren> keyloos, i install haskell with homebrew latest homebrew latest haskell_package (for homebrew)
05:41:02 <dottedmag> wai-app-static fails to build on Mac OS 10.9: http://lpaste.net/102937
05:41:31 <dottedmag> Is it a known issue that ld rejects an .a file thinking it is for wrong architecture?
05:44:25 <Axman6> dottedmag: #ghc would be a much better place to ask
05:46:30 <dottedmag> Axman6: thanks
05:47:07 <dottedmag> BTW, is there any build farm for hackage trying to build packages for different environments?
05:55:37 <countoren> kayloos: i've just check and the homebrew installed haskell-platform-2013.2.0.0 which have Cabal 1.16.0.2 and ghc  Version 7.6.3, stage 2 booted by GHC version 7.4.2
05:56:02 <countoren> ghc and cabal are not the latest
05:57:12 <geekosaur> both are latest for that version of the platform (7.8 only just came out, a platform based on it is forthcoming)
05:57:38 <countoren> o ok
05:58:53 <countoren> so my problem should be ralted to the cpp compiler?
06:00:56 <kayloos> countoren: try to do 'brew install gcc'
06:01:13 <countoren> ok
06:01:16 <kayloos> countoren: i think a problem resembling yours
06:01:27 <kayloos> countoren: and for me it was changing the default compiler that fixed it
06:01:43 <countoren> kayloos:  No available formula for gcc
06:02:07 <jakex> @undo (\m -> nullOption $ reader parseTextLen `mappend` m)
06:02:08 <lambdabot> (\ m -> nullOption $ reader parseTextLen `mappend` m)
06:02:30 <countoren> kayloos: latest brew's formulas
06:02:32 <jakex> @pl (\m -> nullOption $ reader parseTextLen `mappend` m)
06:02:32 <lambdabot> nullOption . (reader parseTextLen `mappend`)
06:03:19 <geekosaur> the "for architecture" thing is not significant there, btw, on mavericks you are x86_64 period. (it used to mean something and then apple changed ld's behavior to always show it, sigh)
06:03:28 <kayloos> countoren: http://apple.stackexchange.com/questions/38222/how-do-i-install-gcc-via-homebrew
06:04:10 <countoren> kayloos: ye thanks was exactly on this site
06:04:36 <geekosaur> oh, I see, the ignoring file one. hrm. no idea what leads to that but I don't think gcc will matter
06:06:34 <geekosaur> -fvia-C is deprecated and has issues, so that object would be -fasm and gcc was not involved in its creation. it does sound like ld is confused for some reason
06:11:56 <countoren> geekosaur: i still have this problem : http://stackoverflow.com/questions/20174262/warning-when-trying-to-compile-haskell-programs-in-os-x-10-9
06:12:06 <countoren> geekosaur: it might be ralted
06:13:11 <geekosaur> it's not related, it's just clang being more pedantic than gcc. although I'm not sure what you're doing to bring clang into it, are you using the ffi?
06:13:35 <geekosaur> or is your ghc configured to use -fvia-C (not a good idea with ghc 7.6)?
06:14:19 <countoren> ffi? how can i check the configuration?
06:15:31 <geekosaur> foreign function interface
06:15:34 <countoren> i didnt worked directly with gcc
06:16:20 <jakex> where can I find a parser that can parse haskell ranges? [1..10], ['a'..'z'], etc
06:19:03 <Axman6> jakex: it would be pretty trivial to make with parsec or some other parser combinator
06:19:05 <insitu> How is stackage supposed to be used? Do I have to build it myself?
06:23:36 <mbkamble> Hi. I am noobie Haskeller. I've written a few simple pgms successfully but am now stumped at trying to use the functionality provided by "largeword" package.
06:23:49 <jakex> Axman6 I know, I just didn't want to reinvent the wheel
06:23:50 <geekosaur> insitu: I don't think you'd normally use it directly, unless you specifically intend to join the testing effort.
06:24:12 <Axman6> mfine15: never heard of it. what's it supposed to do?
06:24:15 <Axman6> uh, mbkamble
06:24:43 <insitu> geekosaur so how can I take benefit from it? Are stackage packages available for replacing hackage somewhere?
06:24:49 <mbkamble> from what I read, it allows one to use Word128 and higher size words
06:24:53 <Axman6> @hackage largeword
06:24:54 <lambdabot> http://hackage.haskell.org/package/largeword
06:25:06 <mbkamble> yes. that's the package
06:25:13 <geekosaur> insitu: no, and the way ghc works that wouldn't really be possible
06:25:20 <Axman6> mbkamble: what exactly don't you get?
06:25:50 <insitu> geekosaur why? AFAIK, packages references are given to ghc on the CLI right?
06:25:59 <mbkamble> so, what I have done is : created a lazy bytestring and parsed the bytestring into a self-defined data type like so:
06:26:12 <insitu> geekosaur or rather, reference to a package.conf file I think
06:26:38 <mbkamble> data KeePassHeader = KeePassHeaderCons {       sig1      :: !Word32     , sig2      :: !Word32     , flag      :: !Word32     , version   :: !Word32     , seed_rand :: !Word128     }
06:26:49 <geekosaur> insitu: because binary packages only work with the exact binary dependencies they were built against. ghc does not build objects that can be mixed and matched.
06:27:24 <geekosaur> (cross-module inlining is lovely for performance and terrible for package management)
06:27:28 <mbkamble> I parse the bytestring into KeePassHeader as: deserialiseHeader = do   sig1 <- getWord32le   sig2 <- getWord32le   flag <- getWord32le   version <- getWord32le   t1 <- getWord64le   t2 <- getWord64le   let seed_rand = LargeKey t2  t1   return (KeePassHeaderCons sig1 sig2 flag version seed_rand)
06:28:00 <mbkamble> all of this works fine. But now I am unable to print the header fields to stdout
06:28:26 <Axman6> is there a Show instance for LergeKey?
06:28:36 <Axman6> hmm, yes
06:28:41 <insitu> geekosaur understood. then I as a layman haskell dev am not supposed to use stackage?
06:28:52 <mbkamble> instance Show KeePassHeader where     show kp = printf "%08x %08x %08x %08x" (sig1 kp) (sig2 kp) (flag kp) (version kp) (largeWordToInteger (seed_rand kp))
06:29:06 <Jafet> What is even the point of this largeword thing, why not just use Integer
06:29:11 <geekosaur> for users, stackage is more of an assurance service that the stuff currently on hackage at the specified version is known to work
06:29:19 <thabersack> I hope someone can help me. I am running OSX. I installed Haskell Platform, then with cabal installed pandoc. All appears to have gone well, however I can't get it to run. It keeps saying Command not found. Any ideas? Apologies for the newb question, I did a lot of searching before I came here
06:29:24 <mbkamble> I get the error: Not in scope: lagreWordToInteger
06:29:26 <geekosaur> note that it gets the packages to build *from* hackage.
06:29:44 <Axman6> thabersack: have you run reshas in your terminal after installing it?
06:29:49 <geekosaur> thabersack, you need to add $HOME/Library/Haskell/bin to your PATH
06:30:18 <Axman6> rehash *
06:30:30 <geekosaur> Axman6, (a) it would be "hash -r" (b) if the command wasn't there before, there's nothing for the shell to forget
06:30:35 <Axman6> that s was a long way from gome...
06:30:50 <insitu> geekosaur yes that's what I understand. But then again why is it not possible to have binary packages provided they all come from same source?
06:31:00 <insitu> and are compiled "consistently" ?
06:31:15 <thabersack> Axman6: reshas = Command not Found
06:31:18 <Axman6> geekosaur: rehash has always worked for me, and I often find that my shell doesn't know about newly installed software until I run it
06:31:27 <Axman6> thabersack: rehash
06:31:36 <geekosaur> insitu: do you have the exact same ghc and boot libraries as the stackage server? and I do mean EXACT
06:32:06 <thabersack> Axman6: same thing, command not found. :/
06:32:15 <aloiscochard> Axman6: isn't zsh specific?
06:32:24 <Axman6> mbkamble: I'm inclined to agree with Jafet, why use largeword when you could use Integer to begin with?
06:32:33 <geekosaur> Axman6: "rehash" is csh. bourne shell derivatives use hash -r
06:32:46 <aloiscochard> csh and zsh then
06:32:49 <insitu> geekosaur boot libraries?
06:32:49 <Jafet> I don't think you should use this largeword library--it was written without serious purpose (and may have bugs)
06:32:49 <Axman6> aloiscochard: it could be, I've been using zsh for so long I thought it'd always been available to me
06:33:01 <aloiscochard> Axman6: yep, same happen to me often :-)
06:33:01 <mbkamble> so I needed some way to parse a 128bit field. How do I do it with the Get parser?
06:33:08 <geekosaur> zsh probably has it as an alias, yes, csh_junkie
06:33:32 <geekosaur> insitu: the libraries that come with ghc (base, containers, etc.) and cannot be replaced without breaking it
06:33:46 <thabersack> geekosaur: $HOME/Library/Haskell/bin that path doesnt exist. no Haskell dir in my Library dir
06:34:18 <Axman6> mbkamble: parse two 64 bit fileds, turn into Integer, shift the first by 64 and or the second onto it
06:34:33 <insitu> geekosaur why not? why would it not be possible?
06:34:36 <geekosaur> insitu: you are saying things that make a lot of sense for C libraries which you can swap out because there is a stable ABI. ghc does not have a stable ABI for compiled packages, the decision was made to allow hidden details to leak out in order to allow optimizations
06:34:42 <mbkamble> lok. so I should do the bit shuffling within my code itself.
06:34:52 <geekosaur> specifically cross-module inlining
06:35:09 <Axman6> mbkamble: it'll be a lot easier and faster
06:35:17 <geekosaur> which means that a library must have the exact same details exported from the things it depends on, and this is not reliable across builds
06:35:49 <geekosaur> thabersack, maybe you should have mentioned how you installed your ghc, then. the official platform package uses that path; some other ways oif installing it will use ~/.cabal/bin instead
06:36:11 <geekosaur> (but warning, it is not safe to use ~ in a PATH setting, use $HOME instead)
06:36:19 <mbkamble> yeah. I agree. But I saw a lot of code already written in that LargeWord.hs source code and thought that the correct thing to do is reuse libraries instead of reinventing the wheel.
06:36:42 <thabersack> geekosaur: I installed via: brew install haskell-platform
06:36:47 <Axman6> mbkamble: it's a good idea to reuse well known libraries
06:36:57 <Axman6> this doesn't appear to be one of them
06:37:00 <Jafet> mbkamble: what, exactly, are you reusing? Except for the Binary instance for parsing, which is trivial to do yourself
06:37:20 <insitu> geekosaur if I have the exact same ghc version, with exac same boot library versions, then when I build a given version, I got the exact same result
06:37:25 <insitu> ??
06:37:31 <geekosaur> insitu: you do not
06:37:51 <geekosaur> version itself is not specific enough, details change between actual compiles. that is the point
06:38:10 <mbkamble> Jafet: hmm. Agreed.
06:38:28 <insitu> geekosaur would like to have a better understanding of that, any pointer you would advice ?
06:38:52 <geekosaur> I gave you a specific thing to look for: cross-module inlining
06:40:10 <geekosaur> if you want a C analogy: KDE used to export a bunch of things as #include macros instead of methods, for performance. they stopped doing it because it led to exactly this issue, you had to use exactly the same object file, not just the same version, or you got weird link errors
06:40:26 <geekosaur> unfortunately ghc does not have that luxury, cross-module inlining is essential for performance. :(
06:41:34 <geekosaur> er #define macros
06:41:40 * geekosaur more coffee...
06:41:49 <insitu> geekosaur thanks, starting to look at http://www.aosabook.org/en/ghc.html
06:42:11 <geekosaur> that may not give much in the way of details, ghc has a developers wiki which says a lot more about it
06:42:47 <geekosaur> also see http://www.vex.net/~trebla/haskell/sicp.xhtml although it doesn't go into the ghc internals detail
06:42:50 <insitu> geekosaur right. Will check it... Yet I do not grok how each build could be different, all things being equal?
06:43:12 <insitu> and BTW I have already read that chapter :-)
06:43:16 <geekosaur> nobody's quite sure why it's not repeatable, I have heard there's a gsoc project to try to figure it out
06:43:39 <Jafet> mbkamble: Also, the code you're using had a bug fixed last week https://github.com/idontgetoutmuch/largeword/commit/9c190e and the cabal file is wrong (it doesn't build here)
06:43:44 <Jafet> Seriously why is this on hackage
06:43:52 <geekosaur> or something like that. there is interest in finding out why things sometimes change across builds with the same compiler and optimization / code gen flags
06:44:04 <geekosaur> but right now they *do* change and it's a pain
06:44:34 <insitu> geekosaur I bet it is!
06:44:37 <Jafet> It does nothing useful, doesn't build correctly, and is probably riddled with bugs
06:47:06 <insitu> geekosaur but (apologies for being insistant...) once compiled, a binary dependency graph couldn't be used as is?
06:47:16 <insitu> after all that's what ghc does locally
06:47:20 <noonan> So I have a function that I've used a few times, but I couldn't find it in Hoogle.  That makes me think I'm missing some more idiomatic way to write it.
06:47:33 <noonan> It's type is Monad m => a -> [a -> m a] -> m a
06:47:57 <Axman6> mapM . (flip ($))?
06:48:01 <insitu> then when I build my project, ghc can do its magic on my code, using pre-built binary packages
06:48:12 <c_wraith> Axman6: that's not gonna work
06:48:14 <Axman6> :t  mapM . flip ($)
06:48:15 <mbkamble> ok. thanks for your guidance Axman6 and Jafet
06:48:17 <lambdabot> Monad m => a -> [a -> m b] -> m [b]
06:48:20 <geekosaur> insitu: ghc relies on things that are not actually exported as part of the normal binatry interface being exported for its internal use for inlining. details of those hidden exports tend to change between compiles for some reason
06:48:29 <Axman6> oh, it's passing the value
06:48:33 <noonan> right
06:48:36 <certainty> can't I have a type alias for a function? Or doesn't make this any sense?
06:48:44 <c_wraith> :t foldr (<=<) return
06:48:45 <lambdabot> Monad m => [b -> m b] -> b -> m b
06:48:52 <geekosaur> I am not sure how to explain this more clearly without pointing you at the ghc dev wiki to learn how ghc's guts work...
06:49:09 <insitu> geekosaur now  worries, will read it then
06:49:14 <insitu> thanks for helping
06:49:44 <noonan> :t (<=<)
06:49:45 <insitu> BTW i stumbled months ago on the pointer you gave me
06:49:45 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
06:49:49 <geekosaur> it's not a situation anyone wants to be in, and it'd be considered insane were it not for the fact that performance of compiled code just plain tanks without these hidden exports for inlining
06:49:52 <noonan> I always forget about those..
06:50:01 <insitu> when I was caught in some "cabal hell" ...
06:50:03 <merijn> certainty: Sure you can, just do "type FooFunc = Int -> Bool -> Char"  or whatever?
06:50:10 <c_wraith> noonan: it's nearly the same as foldr (.) id
06:50:28 <Axman6> but... in the category of endofunctors?
06:50:29 <insitu> geekosaur I meant "no worries" of course :_)
06:50:34 <noonan> nice, that's pretty much the intuition I'd want.
06:50:50 <c_wraith> Axman6: in a kleisli category, actually. :)
06:50:57 <Axman6> damn, do close
06:52:10 <certainty> merijn: hmm I think i've tried that just before I asked. It works now :/
06:52:29 <certainty> thanks
06:54:54 <geekosaur> insitu: so, the fundamental problem is that everything in compiled libraries is output twice: machine code for the "official" implementation, and modified haskell code in the interface file for inlining. if these do not match exactly then things break.
06:55:42 <geekosaur> insitu: worse, they don't break immediately, they break when some other thing links against that package, getting the new version of the inlinable code, and also against some other package that was linked against an older version.
06:56:26 <merijn> geekosaur, insitu: Essentially it's just the ghetto way to fake doing "whole-program optimisation", no?
06:56:27 <geekosaur> since that other package will itself be exposing for inlining the probably incompatible older version.
06:56:47 <geekosaur> merijn: yes, and there are times when I really wish we'd just switch to whole program compiling and be done with it >.>
06:57:40 <insitu> geekosaur merijn I have been using haskell for years but mostly for small, self-contained things
06:57:47 <merijn> geekosaur: On the one hand, yes, on the other hand, program compilation lasting 12 hours isn't fun either :p
06:58:21 <insitu> and for years I have had troubles with these packages
06:58:37 <geekosaur> merijn: one of the proposed workarounds for this behavior in cabal was to always build every possible combination of libraries. which could easily go wellover that 12 hours
06:58:45 <insitu> now that I want to do more serious things, this is clearly a severe hurdle
06:58:46 <SwashBuckla> what's going wrong here? (error is at the bottom) http://lpaste.net/102897
06:59:56 <merijn> insitu: tbh, I haven't really had that much breakage (then again, most of my projects don't have significant amount of dependencies), mostly I see problems starting when cabal refuses to build something and people try to "fix" that (i.e. reinstalls, upgrading packages, etc.)
07:00:12 <merijn> insitu: I missed the initial problem, though. What happened?
07:00:14 <insitu> merijn right
07:00:49 <Axman6> SwashBuckla: seems it needs #!/usr/bin/env runhaskell
07:00:51 <insitu> merijn most of my problems were of that kind but this means that one has to have more understanding than is reasonable
07:00:56 <insitu> for not breaking things
07:01:09 <Axman6> SwashBuckla: under JSON Filters: http://johnmacfarlane.net/pandoc/scripting.html
07:01:24 <merijn> insitu: Right, monochrom always has his nice link for not breaking cabal
07:01:28 <merijn> @where sicp
07:01:28 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
07:01:44 <merijn> insitu: The last link is the one I mean
07:01:57 <insitu> merijn :-) I was asking how I could benefit from stackage
07:02:14 <geekosaur> merijn: the other point I'd make is that if you're already exporting the source in the .hi for cross module inlining, you are *already* doing whole program compilation, just doing it the hard way
07:02:33 <SwashBuckla> Axman6: ... nope
07:02:51 <insitu> merijn in my head, stackage was  like some kind of binary hackage... Looks I was wrong
07:03:08 <merijn> geekosaur: That's true, but afaik only relatively small or annotated functions go into the .hi
07:03:37 <insitu> merijn geekosaur you know, I do mostly java for a living so I am "tainted"
07:04:00 <Axman6> SwashBuckla: does it compile? can you run it by piping an empty JSON object into it or something?
07:04:13 <SwashBuckla> Axman6: yes it compiles.
07:04:24 <Axman6> no idea then
07:04:33 <SwashBuckla> Axman6: it doesn't take JSON as input
07:04:40 <merijn> insitu: Well, not so much tainted as it's just really hard to ship haskell in a similar portable binary way as Java without losing performance
07:04:46 <SwashBuckla> as far as I can tell (maybe it does?)
07:05:01 <merijn> insitu: Some packages really rely on their functions being inlined to not produce horrible performance in the result
07:05:28 <SwashBuckla> Axman6: echo '{}' | ./include ; include: when expecting a product (:*:), encountered Object instead
07:05:42 <insitu> merijn understood.
07:06:11 <insitu> I need to experiment and get a better understanding of this to stop tripping myself
07:07:13 <merijn> insitu: Certainly it'd helpto read that sicp link, as it covers things like the safe order of installing/changing packages (and always heed cabal's "warning this is dangerous" warnings :))
07:08:17 <insitu> merijn :-) geekosaur hinted at some effort to improve on that situation. Is this something openly discussed somewhere?
07:10:12 <geekosaur> there are mailing lists. most of what I'm aware of about it has been discussed on the glasgow-haskell-users and libraries lists. I am not subscribed to the cabal-dev list but I would expect detailed discussion of cabal trying to deal with the messes ghc hands it goes on there
07:10:17 <SwashBuckla> Axman6: oh, piping the json version of the foo.markdown document directly into the filter is interesting
07:10:26 <SwashBuckla> Axman6: thanks, I will play around with this and see what I find ;)
07:10:45 <Axman6> keep reading those docs too :P
07:10:52 <geekosaur> http://www.haskell.org/mailman/listinfo
07:11:05 <insitu> merijn geekosaur thanks for the pointers and the discussion, will try to educate myself
07:11:13 <geekosaur> lots of lists beyond the big 3...
07:17:08 <Peaker> I wonder if there's a good way to do efficient, shared-memory-based communication between a C process and a Haskell process.  For example, I'd like my Haskell process to expose a Map, Set or such to a bunch of C processes (Haskell is write-only, C is read-only), without round-tripping to do so
07:17:41 <merijn> Peaker: What do you mean by roundtripping?
07:17:59 <Peaker> merijn: I currently have a bunch of C processes talking to my Haskell server via local unix sockets
07:18:24 <Peaker> merijn: and they report all FS accesses captured via LD_PRELOAD to the Haskell server. that requires round-tripping to the Haskell server while the C code is paused
07:18:31 <geekosaur> Peaker, there are mmap packages on hackage, the big problem is getting C to make any sense at all out of haskell data structures. (and making sure that they're allocated in a pool living in the shared memory and are completely strict)
07:18:58 <merijn> Peaker: oh, you mean like sys-v shared memory between different processes?
07:19:00 <Jafet> Normally you just get the haskell code to write C structures
07:19:02 <Peaker> geekosaur: Yeah I figured that getting an actual Haskell structure placed upon an mmap'd zone would be too difficult. I don't mind the Haskell side using ugly IO actions to maintain the exposed map
07:19:05 <Peaker> merijn: yeah
07:19:36 <merijn> Peaker: I think you'd just have to have a C struct + Storable instance for it and then access C data structures from haskell?
07:19:54 <Peaker> merijn: it needs to be able to do efficient lookups and insertions by file path keys
07:20:15 * hackagebot pubnub 0.1.0.0 - PubNub Haskell SDK  http://hackage.haskell.org/package/pubnub-0.1.0.0 (tsloughter)
07:20:33 <tristan__> woot
07:20:44 <tristan__> now to add docs :(
07:20:46 <merijn> trie with path pieces as keys?
07:20:56 <Peaker> merijn: on top of a Storable instance? no thanks :)
07:21:05 <Peaker> merijn: might as well write it all in C and FFI to it on both sides
07:21:06 <merijn> Peaker: bah, pssh
07:21:15 <merijn> Peaker: That might be easiest, yes
07:21:26 <Peaker> merijn: I think I might just use my small_hash library after a small adaptation to run on a shared memory
07:21:34 <Peaker> and perhaps some concurrency-friendliness
07:22:25 <Peaker> oy, my bindings support Int keys only (they were meant to prove a point in an argument with JDH, heh)
07:23:13 <Peaker> ok, no big deal, I can write a C-type-specific wrapper around small_hash and bind to that
07:50:18 * hackagebot Omega 1.0.1 - Integer sets and relations using Presburger arithmetic  http://hackage.haskell.org/package/Omega-1.0.1 (ChristopherRodrigues)
07:51:45 <orion> How can I look at something like IO and know intuitively, "Oh, that's a one-way Monad"?
07:51:57 <merijn> What do you mean by "one way Monad"?
07:52:04 <SwashBuckla> d--(-!
07:52:10 <SwashBuckla> oops
07:52:15 <c_wraith> well, IO is opaque.  You can't really tell *anything* about it just by looking
07:56:58 <orion> merijn: "One-way monads allow values to enter the monad through the return function (and sometimes the fail function) and they allow computations to be performed within the monad using the bind functions >>= and >>, but they do not allow values back out of the monad."
07:57:49 <Axman6> simple, if there's a runFoo function, it's probably not one way :P
07:57:59 <yezariaely> orion: example for this?
07:58:08 <yezariaely> i.e. use case?
07:58:39 <Axman6> IO
07:58:45 <Axman6> is the example that's being discussed
07:59:08 <yezariaely> ah sure.
07:59:32 <c_wraith> orion: I'd argue that whoever wrote that...  really shouldn't have. It's non-standard terminology because it's kind of missing the whole point.
08:01:07 <c_wraith> orion: the real point is that the Monad abstraction is a pattern of composition.  If you want to do something other than composition, you need to be more concrete.
08:01:20 <orion> http://www.haskell.org/haskellwiki/All_About_Monads#No_way_out
08:01:35 <merijn> orion: The monad interface doesn't provide a way out
08:01:45 <c_wraith> Or at least abstract on an orthogonal axis.
08:01:59 <merijn> orion: But the monad interface doesn't put any restrictions on whatever you can do with a specific type
08:02:20 <ij> I'm trying to use deriving (Generic) as written in https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json. I'm not succeeding: http://sprunge.us/NPMd
08:02:31 <merijn> orion: The fact that you can't get anything out of IO has nothing to do with IO being a monad and everything to do with IO being an abstract type that doesn't export any constructors/functions to get anything out
08:02:52 <merijn> ij: Deriving generic requires an extension
08:03:23 <merijn> ij: Add {-# LANGUAGE DeriveGeneric #-} to the top of your file
08:05:04 <merijn> orion: It just happens that the monad interface is a convenient way of exposing limited access to abstract types like IO. Because you can implement the monad instance inside the same module (reaching into IO's constructors) and then export the monad instance without exporting the constructor
08:07:55 <orion> I see.
08:11:19 <c_wraith> orion: a type that provided no way to use it except the Monad interface would be about 100% useless.
08:12:02 <c_wraith> Ok, maybe 99% useless.  It'd still be usable as a proxy of kind * -> *
08:12:28 <merijn> c_wraith: Probably not a side note helpful to someone confused about this ;)
08:13:17 <remib> Hi, I was trying to write mergesort, and haven't found a way to implement the split part in a good fashion (recursively, in "one recursion"), google doesn't give anything useful, apart from that http://en.literateprograms.org/Merge_sort_%28Haskell%29#chunk%20def:split .But this code looks complicated. Is there a way to do it in one take ?
08:13:38 <c_wraith> remib: the standard approach is to invert the logic, and use a bottom-up merge sort
08:13:49 <c_wraith> remib: in that case, split is map (:[])
08:14:14 <merijn> remib: GHC has a (slightly) optimised merge sort in its libraries that's reasonably understandable
08:14:58 <merijn> remib: Wow, that example is really silly
08:15:11 <c_wraith> I really think merge sort is only presented as top-down in most algorithms textbooks because the stack is the only place that makes allocation easy in a bunch of languages.
08:15:17 <remib> So, there is no canonical good approach for split, but bottom-up is a way to get rid of the problem ?
08:15:24 <merijn> remib: Right
08:15:38 <remib> Interesting, thank you both!
08:15:38 <merijn> remib: Splitting linked lists is not really a sensible operation, imo
08:15:55 <merijn> remib: FWIW, here's GHCs: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#sort
08:16:07 <merijn> (look at the second definition too)
08:16:18 <merijn> It has several other sorts + comments on performance
08:16:28 <remib> Yeah, I did it by separating even index element from odd ones, but on literateprograms.org, they say that this could be bad if the list is "presorted"
08:16:37 <Jafet> Does that file still have like ten different versions
08:16:59 <merijn> Jafet: Yes
08:17:16 <Jafet> Whyyy
08:17:36 <merijn> Jafet: Posterity?
08:17:49 <Jafet> git log
08:18:15 <burtoberto>  hello, i don't know if this is the place to make this complaint, i've just installed eclipsefp for the first time, everytime it started it asked me to install scion-browser and buildwrapper because buildwrapper failed to install but even though it failed, eclipsefp didn't give me any feedback, so i had to try to install buildwrapper from the console and see that there were compatibility issues and i had to download the latest v
08:18:19 <c_wraith> Huh.  GHC's approach is interesting.  It splits into ascending and descending subsequences, so that the initial list of parts to join has every list at size 2, at least.  And it'll be O(n) if the input is already sorted, which is a nice touch.
08:18:24 <Jafet> Also, the decade-old benchmark
08:18:34 <orion> What is English word(s) is/are used to describe the following things?: Monad, Monad IO, IO, IO Integer. Would they be: abstract class, concrete class, abstract type, concrete type?
08:18:38 <c_wraith> or O(n) if the list is reverse-sorted
08:18:41 <burtoberto> and forcing cabal to install it even though it said that it could have broken some installed packages
08:18:55 <Jafet> c_wraith: it's also O(n log k) to get the first k items
08:19:03 <prophile> orion: is "pain in the ass" a valid answer for all four?
08:19:20 <merijn> orion: I dislike the terminology of "concrete type" and "abstract type", they're very confusing and not well specified
08:19:28 <Jafet> (The lower bound is O(n + k log k), but I can't think of a good way to do that lazily.)
08:19:32 <merijn> orion: What's wrong with the word "Monad" as English word for Monad?
08:20:06 <orion> merijn: I want to know what "Monad" is in terms of the language/syntax.
08:20:08 <c_wraith> Jafet: worst case, yes.  That implementation has a lot of best cases that turn into O(n) to take the k-element prefix
08:20:19 <merijn> orion: Monad is a typeclass, "Monad IO" refers to the IO instance of the Monad typeclass, IO is a type constructor and "IO Integer" is a value "in IO"
08:20:37 <Jafet> orion: "abstract class" is english? Where did you learn english
08:20:52 <Jafet> I imagine concrete class is where you can learn the properties of portland cement.
08:22:24 <orion> "IO Integer" isn't a type?
08:22:33 <merijn> orion: It is, but IO is a type too
08:22:47 <orion> :(
08:23:14 <prophile> they have different kinds
08:23:17 <merijn> orion: This may be the time to learn about "kinds", which are the "types of types". The "standard" kind is *, so "1 :: Int" (1 has type Int) and "Int :: *" (Int has kind *)
08:23:49 <merijn> orion: Now if you look at Maybe, "Maybe :: * -> *" (Maybe has kind * -> *), which says "Maybe takes a type of kind * and returns a type of kind *"
08:24:04 <merijn> Similarly, "IO :: * -> *" so IO takes a type of kind * and returns one of type *
08:24:44 <merijn> "data Either a b = Left a | Right b", "Either :: * -> * -> *" so Either takes a type of kind * and returns a type of kind "* -> *"
08:24:51 <remib> merijn: The code you linked is quite hard to digest, but on rosetta there is another version and they also explain the idea behind "your" version. Interesting!
08:25:06 <orion> Why the asterisk?
08:25:14 <merijn> orion: Historical and mathematical reasons
08:25:27 <merijn> orion: It's what GHC uses to print kinds
08:25:36 <merijn> orion: Try doing ":kind Either" in ghci
08:25:45 <orion> :kind Either
08:25:51 <merijn> lambdabot doesn't support :kind
08:25:56 <orion> :(
08:26:35 <merijn> orion: If you wanted to use "Type" as the name for * that'd work just as well, so "Int :: Type", but I find it helpful to use GHC's syntax so everyone understands what's going on
08:27:08 <merijn> So the * itself isn't really special other than "someone decided on that name a couple decades ago in a paper"
08:28:18 <orion> Is there a way to restrict a type constructor? So like, Blah :: Integer -> Char -> Bool
08:28:52 <skuggi> orion: GADTs
08:29:06 <merijn> orion: Yes, but that requires several other GHC features (specifically GADTs and possibly ConstraintKinds, depending on what you want)
08:29:14 <orion> wow
08:29:27 <merijn> orion: Anyway, this gives a convenient vocabulary to talk about types like "IO a" and "IO Int"
08:29:38 <skuggi> orion: that type signature makes no sense, though. :P
08:29:47 <merijn> orion: Both "IO a" and "IO Int" have kind * (and 'a' is a polymorphic type of kind *)
08:29:49 <skuggi> unless Blah is a constructor for Bool
08:30:15 <merijn> "IO Int" is also called "monomorphic" (i.e. not polymorphic, there's no type variables in there)
08:30:54 <merijn> So it can help to use the terms "monomorphic type" and "type of kind *" to clarify what people are talking about
08:31:57 <orion> So I can say: Monad = polymorphic typeclass, Monad IO = instance of Monad, IO = polymorphic type, IO Int = monomorphic type?
08:32:06 <merijn> orion: Here's an example "data Foo f g a = Foo ((f g) a) a", what would the kind of Foo be?
08:32:24 <merijn> orion: I would say "IO" is a type constructor and "IO a" is a polymorphic type
08:32:48 <orion> But "IO a" seems more abstract than "IO Int"
08:32:58 <iiian> That's why it's polymorphic
08:33:06 <iiian> v monomorphic
08:33:06 <merijn> orion: Yes, because 'a' is polymorphic
08:33:15 <orion> oh ok
08:33:35 <orion> So, it conceptually doesn't make sense to say *only* "IO", but rather "IO a"
08:34:06 <monochrom> Foo :: (* -> * -> *) -> * -> *
08:34:16 <monochrom> err, that's wrong
08:34:21 <orion> So, what is the difference between saying "Monad" and "Monad a"?
08:34:21 <merijn> monochrom: I was about to say :p
08:34:47 <monochrom> Foo :: (* -> * -> *) -> * -> * -> *
08:34:57 <merijn> orion: I would say that those two usually don't have a clear distinction and people just assume it will make sense in context which you mean
08:35:00 <merijn> monochrom: ...
08:35:03 <merijn> monochrom: Bad monochrom
08:35:17 <monochrom> it's what ghci tells me. talk to ghci
08:35:19 <merijn> monochrom: You may want to practice more :p
08:35:24 <hiptobecubic> orion, "Monad" and "Monad a" have different kinds
08:35:25 <merijn> lolwut
08:35:44 <merijn> monochrom: If that's true then ghci is broken
08:35:46 <hiptobecubic> or... rather one is specialized i guess?
08:35:55 <merijn> oh
08:36:00 <merijn> monochrom: Actually
08:36:01 <monochrom> hehe
08:36:02 <ij> merijn, Bedankt.
08:36:07 <orion> wait
08:36:10 <hiptobecubic> "Monad" isn't really meaningful. It's a typeclass
08:36:14 <merijn> monochrom: What I want may need a kind signature
08:36:15 <hiptobecubic> like Maybe
08:36:18 <hiptobecubic> vs Maybe a
08:36:31 <hiptobecubic> err
08:36:38 <hiptobecubic> I need some coffee
08:36:46 <orion> data Foo f g a = Foo ((f g) a) a -- if I type ":t Foo" in to ghci, is ghci going to spit back the type of the *function* that constructs a Foo?
08:36:57 <merijn> monochrom: I guess the type is right, but not what I wanted, I should've written "data Foo f g a = Foo ((f g) a) (g a)"
08:36:58 <hiptobecubic> Maybe a is a type, not a class, ignore that entirely
08:37:07 <merijn> orion: Yup
08:37:13 <orion> ok
08:37:15 <monochrom> "Monad a" doesn't make sense in isolation
08:37:17 <hiptobecubic> orion, yes
08:37:24 <hiptobecubic> monochrom, right.
08:37:35 <iiian> Heya people, sorry to jump in on this discussion with a topic change.  I was curious if anybody knew of any mature/growing NLP and/or Text analytics libraries in Haskell
08:37:59 <iiian> I ask because I'm about to write one myself >_<
08:38:13 <hiptobecubic> orion, Monad a doesn't tell you anything about the monad really. If you see it in a type signature it just means that the 'a' that appears in elsewhere in signature is an instance of Monad
08:38:54 <quchen> orion: It's a little confusing sometimes that data constructors and type constructors are in separate namespaces. :t always gives you types of values, :k always gives you "types" of types, i.e. kinds. In your example,  "data Foo f g a = Foo' ((f g) a) a", you define a data constructor Foo' of type ":t Foo'" that creates a value of type "Foo". Note the primes.
08:39:22 <orion> right
08:39:24 <orion> makes sense
08:39:29 <orion> You guys are so kind. :>
08:39:33 <orion> har har har
08:39:41 <quchen> We're well-typed humans.
08:39:52 <hiptobecubic> I type pretty poorly
08:40:31 <monochrom> I just ask ghci
08:41:17 <merijn> The earlier Foo definition would be identical to "data FooType f g a = FooValue ((f g) a) a"
08:41:29 <merijn> Since types and values are in different namespaces they can just overlap
08:42:18 <quchen> There were no Ca²pital letters the inventors of Haskell could use to signify yet another level up the chain :-)
08:43:01 <monochrom> haha Ca²pital
08:45:05 <orion> So: data Foo f g a = Foo ((f g) a) (g a) -- when you ask me for Foo's type, you're asking me to tell you how values are transformed by way of the Foo constructor. When you ask me for Foo's *kind*, you're asking me to tell you how types are transformed in the process of getting a Foo type?
08:45:19 <merijn> orion: Correct
08:45:40 <merijn> orion: And since types and kinds are different, it automatically infers which you meant based on ":type" vs ":kind" command
08:45:49 <orion> right
08:45:50 <merijn> eh, types and values, I meant
08:45:56 <quchen> The "Foo" oh the LHS of the "=" and on the RHS are completely isolated from each other.
08:46:16 <quchen> Hence merijn's comment above, "<merijn> The earlier Foo definition would be identical to "data FooType f g a = FooValue ((f g) a) a""
08:46:31 <eyebloom> Hi I'm curious if anyone can help compile this toy example using dependent types:
08:46:32 <orion> Values stand alone. All values have a type. All types have a kind.
08:46:57 <orion> Right?
08:47:01 <monochrom> yes
08:47:28 <eyebloom> http://lpaste.net/102939
08:48:22 <orion> I have no idea how to think about the kind of Foo.
08:48:39 <orion> I do not know how to parse that definition and say, "Oh, the kind is * -> *..."
08:49:09 <merijn> orion: Right, so another clue would be that in haskell all values can only have types of kind *
08:49:22 <eyebloom> I get this error: http://lpaste.net/102940
08:50:19 <merijn> orion: So the right hand side of Foo has two types "((f g) a) :: *" and "a :: *" (both are *, because all values must have types of kind *)
08:50:22 <eyebloom> I can explain pretty well why it doesn't work but I fear I can't do what I want within the type system...
08:50:56 <orion> so
08:51:15 <merijn> eyebloom: FYI, in 7.8 there's a built-in Nat type with comparisons
08:51:58 <orion> I'm operating on data Foo f g a = Foo ((f g) a) (g a)
08:52:08 <eyebloom> I see so do you think that's related  to my issue.
08:52:13 <orion> That's what you corrected it to be.
08:52:43 <merijn> eyebloom: There's also some builtin functions for lifting values to Nat, but I'm not sure whether they'd help you
08:52:43 <monochrom> "a" has kind * because it's the default
08:52:52 <monochrom> "g" has kind *->* because "g a"
08:52:56 <orion> So far, I know that "Foo" is a type, and in order to construct it you need to pass three parameters.
08:53:00 <eyebloom> I usually like to define most things in toy problems...
08:53:04 <merijn> orion: Correct
08:53:14 <monochrom> "f" has kind (* -> *) -> * -> * because "f g a"
08:53:49 <monochrom> Foo has kind built from the above because "data Foo f g a = ..."
08:53:57 <orion> f, g, and a refer to TYPES, not to values, right?
08:54:03 <monochrom> yes
08:54:04 <merijn> orion: Right
08:54:05 <orion> ok
08:54:05 <orion> so
08:54:28 <merijn> orion: the syntax for constructors is a constructor followed by 0 or more types (in this case, two types)
08:54:34 <orion> When you ask for the kind of Foo, you're asking for the combined kind of f, g, and a.
08:54:52 <merijn> orion: Well, Foo takes three arguments
08:55:08 <merijn> orion: f, g and a, and the kinds of these arguments must match the kinds of 'f', 'g' and 'a'
08:55:32 <orion> Ok
08:55:44 <merijn> "Foo :: ??? -> ?? -> ? -> *" (??? is the kind of 'f', ?? the kind of 'g' and ? the kind of 'a')
08:56:04 <orion> So, in your definition of Foo, you're creating two temporary types.
08:56:16 <orion> From three given types.
08:56:18 <merijn> And above monochrom wrote how you can infer the kinds of f, g and a
08:56:57 <merijn> orion: Not so much, you're creating a single type from three type arguments and the two VALUE arguments of the Foo CONSTRUCTOR depend on those three types
08:57:17 <eyebloom> merijn: I think the issue is that within the same function (mapRaise f x) and Raise (mapRaise f x) should have the same type. But within the same function f :: RisingInt n -> RisingInt n and f::RisingInt ('Succ n) -> RisingInt ('Succ n)
08:57:40 <eyebloom> and somehow f can't be polymorphic that way within the same function
08:57:57 <eyebloom> at least that's how I'm reading it so far
08:58:29 <shingshang> so uh.. what's the opposite of a list's tail? that is, everything except the last element of a list
08:58:40 <merijn> eyebloom: The problem is that if you do "I 3" it doesn't take the value of '3' into account for the Nat in the RisingInt
08:58:50 <bootvis> I have line 'col1 = "foo" :: String', with -Wall I get a warning that this is a top-level binding without a type signature. What is meant here, I thought that ':: String' is a type signature?
08:58:54 <merijn> "I 3 :: RisingInt 1" <- this typechecks
08:59:19 <merijn> bootvis: It's complaining that you didn't write 'col1 :: String; col1 = "foo"'
08:59:32 <bootvis> merijn: thanks
09:00:23 * hackagebot graph-generators 0.1.0.0 - Functions for generating structured or random FGL graphs  http://hackage.haskell.org/package/graph-generators-0.1.0.0 (ulikoehler)
09:00:38 <eyebloom> merijn: I see.
09:00:47 <monochrom> shingshang: init
09:01:10 <shingshang> monochrom: that's it, thanks
09:01:39 <orion> So, funcnions take values, not types, right? FooConstructor is a function which takes two values as arguments and spits out a value.
09:02:37 <monochrom> yes
09:02:45 <orion> And the TYPE of the VALUE FooConstructor spits back is wholely dependent on three type arguments.
09:03:36 <orion> ?
09:03:41 <eyebloom> merijn: I'm not sure that actually solves the problem, if I comment out the second example it still doesn't compile. The typechecker need some assurance that f is always the same.
09:03:56 <merijn> orion: Well, the TYPE of FooConstructor will just be "(f g) a -> g a -> FooType f g a"
09:04:54 <orion> oh
09:05:45 <orion> FooConstructor is a function, whose type is that. The TYPE of the VALUE spit back by FooConstructor is (FooType f g a)?
09:05:54 <merijn> @let data FooType f g a = FooValue ((f g) a) (g a)
09:05:55 <eyebloom> Unfortunately I think because f is lambda bound it can be polymorphic within the same function.
09:05:57 <lambdabot>  Defined.
09:06:04 <merijn> :t FooValue
09:06:05 <lambdabot> f g a -> g a -> FooType f g a
09:06:15 <merijn> orion: Right
09:06:17 <orion> ok
09:06:22 <eyebloom> *can't
09:06:25 <quchen> Remind me again, how does the new MINIMAL pragma work? Control.Applicative's Haddock shows a "minimal" section, but I cannot find the MINIMAL pragma.
09:08:03 <orion> So you asked for the kind of Foo. Is the kind derived from the type of the constructor?
09:09:05 <merijn> orion: Partially
09:09:23 <merijn> orion: In that, the type arguments of the constructor let you determine the kinds of the type argument to the Foo type
09:11:20 <merijn> orion: If you look at the simpler "data Either a b = Left a | Right b" then we see that 'a :: *' and 'b :: *', since (as mentioned earlier) all values must have types of kind *
09:11:23 <orion> f, g, and a are all types. Since they are all types, they all turn in to asterisks.
09:12:16 <merijn> orion: Therefor Either must be "* -> * -> *" as the return type of Either must have kind * and 'a' and 'b' were *
09:13:08 <orion> ANY function with two arguments is going to look like blah -> blah -> blah
09:13:25 <merijn> orion: "data Bar f a = Bar (f a)", here we know 'a :: *' (because * is the default kind for types) and 'f a :: *' because all values have types of kind *
09:13:53 <merijn> orion: From 'a :: *' and 'f a :: *' we can concluded that 'f :: * -> *', right?
09:14:24 <merijn> Thus 'Bar :: (* -> *) -> * -> *' because 'Bar :: kind of f -> kind of a -> *'
09:14:33 <orion> wait, I am not quite following
09:14:45 <orion> in Bar:
09:14:58 <orion> 'a' is a type. All types have kind *. I get that.
09:15:09 <merijn> orion: Not all types have kind *
09:15:10 <haasn> Not all types have kind
09:15:21 <merijn> orion: All *values* have *types* of kind *
09:15:22 <orion> I guess I don't get that. :)
09:15:30 <geekosaur> all *values* belong to types of kind *
09:15:31 <orion> Ok
09:15:33 <merijn> But not all types have kind * because not all types have values
09:15:39 <geekosaur> an example of a type that is not kind * is Maybe
09:15:59 <merijn> orion: For example "Either Int" <- this has kind "* -> *", but we cannot have *values* of type "Either Int"
09:16:00 <geekosaur> you can't make a value of type Maybe. you can make avalue of type, say, Maybe Int
09:16:17 <orion> So Maybe Int :: * ?
09:16:24 <merijn> orion: Right
09:16:26 <orion> ok
09:16:39 <merijn> Because Int :: * and "Maybe :: * -> *"
09:16:47 <geekosaur> "correct" might be less confusing there :p
09:17:15 <geekosaur> .oO { "who's on first" with constructors }
09:17:23 <eyebloom> merijn: Just as an example this compiles: http://lpaste.net/102939
09:17:30 <merijn> orion: For example: "Bar (Just 'c') :: Bar Maybe Char"
09:17:57 <orion> < merijn> orion: From 'a :: *' and 'f a :: *' we can concluded that 'f :: * -> *', right? <-- I don't follow.
09:17:58 <eyebloom> I took the parameter f out and used riseInt as if it had been applied inductively
09:18:06 <merijn> orion: Since we had "BarValue :: f a -> Bar f a"
09:18:29 <merijn> orion: Well, if 'f a :: *' and 'a :: *', what kind does 'f' have?
09:18:41 <eyebloom> This lambda binding thing comes up a lot.
09:19:22 <orion> hmm
09:19:51 <eyebloom> I guess I need a way to advance the type of a function: advance :: (x n -> x n) -> (x ('Succ n) -> (x ('Succ n))
09:20:07 <orion> 'f a :: *' means that two types are coming together to form another type.
09:20:38 <monochrom> I am not sure "coming together" is informative
09:20:42 <orion> heh
09:20:54 <Jafet> When two types love each other very very much
09:22:00 <eyebloom> This type marriage issue comes up alot.
09:22:11 <haasn> Is it possible to divorce types?
09:22:20 <merijn> orion: 'f a :: *' means "f applied to a"
09:22:39 <eyebloom> When will it end, pretty soon values will want to marry types!
09:22:42 <merijn> orion: Compare with 'succ 1 :: Int' and '1 :: Int'
09:22:47 <merijn> > succ 1
09:22:50 <lambdabot>  2
09:23:09 <Jafet> Some languages have very strange customs, where types can be with their dependents.
09:23:17 <merijn> orion: What's the 'type' of succ in that example? :)
09:23:29 <orion> Int -> Int
09:23:49 <merijn> orion: Now compare that question with "what's the *kind* of 'f' in 'f a :: *' and 'a :: *'" :)
09:23:54 <orion> heh
09:23:57 <orion> * -> *
09:24:00 <merijn> orion: Right
09:24:01 <monochrom> what kind of marriage is "Either Int Char"? :)
09:24:11 <haasn> higher-order marriage
09:24:22 <merijn> orion: Kind checking and type checking are essentially the exact same thing, but at different levels
09:24:29 <orion> right
09:24:46 <orion> I see the level of abstraction, but I am having trouble digesting it.
09:24:51 * orion grabs tums
09:24:56 <merijn> orion: Don't worry too much about it :)
09:25:02 <orion> I REALLY want to understand this
09:25:14 <haasn> digesting what?
09:25:19 <orion> haasn: kinds
09:25:55 <merijn> orion: My advice: Grab a pen and paper, write down some random datatypes like my examples, try to figure out how things fit together on paper
09:26:09 <merijn> orion: Load the datatype in ghci and check your result, if you get confused come back here and ask :)
09:26:43 <orion> < merijn> orion: "data Bar f a = Bar (f a)"
09:26:59 <monochrom> I think the current question is why "f a" forces f to have kind xxx -> yyy
09:27:11 <merijn> orion: What may also help is to use GADTSyntax for data declaration
09:27:21 <monochrom> but it is analogous to why "sin 4" forces sin to have type xxx -> yyy
09:27:29 <haasn> data Orion a b c d e f g h i j k l m n o p q r s t u v w x y z = Orion (h e l l o  w o r l d  o r i o n)
09:27:33 <haasn> What is the kind of Orion? :)
09:27:43 <merijn> GADT syntax is like this: "data BarType f a where BarValue :: f a -> BarType f a"
09:27:49 <eyebloom> orion: Sometimes it's helpful to take things back to lambda calculus and work something out by hand. I feel like some things in math etc are never "understood" they are just "gotten used to".
09:27:59 <merijn> orion: That's identical too "data BarType f a = BarValue (f a)"
09:28:04 <Algebr> Say I do: `let a = getLine`, haven't I now effectively aliased the function getLine to a?
09:28:06 <orion> merijn: indeed
09:28:10 <merijn> orion: But hopefully illustrates hings more clearly
09:28:15 <quchen> Algebr: Right.
09:28:16 <haasn> Algebr: getLine is not a function, but yes
09:28:32 <orion> Well, thank you for all your time.
09:28:40 <Algebr> haasn: Why is getLine not a function? Its certainly not a constant
09:28:40 <merijn> orion: Similarly, "data Either a b where Left :: a -> Either a b; Right :: b -> Either a b"
09:28:43 <orion> I don't want to beat this topic too much.
09:28:50 <haasn> Do my example. It's not as difficult as it seems at first glance
09:29:01 <eyebloom> orion: If you can find the type of a term on paper you can work out the kind of a type...
09:29:03 <monochrom> getLine is a constant
09:29:03 <merijn> haasn: Your example is *really* tedious >.>
09:29:04 <quchen> getLine *is* a constant.
09:29:19 <monochrom> you can also call it a value. you can also call it an I/O action.
09:29:30 <quchen> getLine is the constant value "fetch me a line from STDIN".
09:29:31 <monochrom> if the type doesn't contain "->", you don't have a function
09:29:36 <merijn> Algebr: See also: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
09:29:47 <haasn> monochrom: is [a -> a] a function?
09:29:52 <monochrom> no
09:29:59 <haasn> oh, you weren't saying iff
09:30:34 <monochrom> of all mistakes you can catch me on, a logic mistake isn't one of them.
09:30:48 * haasn doesn't bother arguing type synonyms
09:30:53 <quchen> CAPITALIZE THE BEGINNING OF YOUR SENTENCES, MONOCHROM! :-D
09:31:10 <Algebr> merijn: Awesome blog post, someone needs to make a compliation of all the best haskell blog posts.
09:31:13 <monochrom> finE!
09:31:19 <benmachine> to be fair, id is also a constant
09:31:39 <haasn> monochrom: is this true: f is a function iff “f undefined” type-checks?
09:32:02 <quchen> :t 2 undefined -- 2 is a function! :-)
09:32:03 <lambdabot> Num (t -> t1) => t1
09:32:08 <haasn> benmachine: everything is a constant!
09:32:12 <haasn> cc Algebr
09:32:46 <benmachine> haasn: the contents of an IORef is not constant (though an IORef itself is)
09:32:58 <haasn> every haskell value is a constant?
09:33:02 <benmachine> I suppose
09:33:05 <quchen> monochrom: Is "is a function" even a well-defined concept?
09:33:19 <benmachine> quchen: you can well-define it easily
09:33:30 <benmachine> it's another question whether or not you can get people to agree :P
09:34:00 <haasn> quchen: I think the biggest issue in that is “is”
09:34:16 * quchen goes grab his white flag
09:34:39 <benmachine> I think "f is a function if f undefined typechecks" is a reasonable take on it
09:34:55 <benmachine> one might also argue for "f is a function if the top-level constructor in its principal type is a (->)"
09:35:16 <benmachine> maybe the word "principal" is a bad idea there
09:35:25 <orion> Will the kind of a type ever be "... -> (* -> *)" ?
09:35:37 <quchen> :k StateT
09:35:39 <lambdabot> * -> (* -> *) -> * -> *
09:35:40 <benmachine> orion: -> is right-associative in kinds as well as functions
09:35:42 <benmachine> er
09:35:43 <haasn> orion: Either
09:35:45 <benmachine> kinds as well as types
09:35:49 <haasn> :k Either
09:35:50 <lambdabot> * -> * -> *
09:35:54 <benmachine> orion: so that's just the same as without the parens
09:35:59 <orion> oh, yes, indeed
09:36:12 <Algebr> Why does the last item in a do block have to be an expression?
09:36:26 <pyon> Algebr: As opposed to what?
09:36:41 <benmachine> Algebr: if it were a <- binding or a let binding, you'd immediately throw away the thing you just bound
09:36:47 <benmachine> so what would be the point?
09:36:58 <quchen> It's mostly to avoid bugs, I imagine.
09:37:30 <Algebr> that's what I was wondering about, whether it was actually needed or just the compiler enforcing a limitation of a feature source of bugs.
09:37:38 <quchen> You could define do { x <- action } == action if you wanted to, but it has zero use cases and only introduces bugs.
09:39:11 <benmachine> Algebr: well, the standard translation for do-notation is stuff like "do p <- x; y" -> "x >>= \p -> y"
09:39:25 <benmachine> Algebr: that doesn't make sense as a rule if p <- x is the last thing in the do-block
09:39:50 <Algebr> benmachine: ah, right right, thank you.
09:40:29 <Jafet> Why not allow let-bindings, while we're at it
09:40:50 <orion> data Color a b = Red (a b) -- how do I make a value out of this?
09:42:15 <benmachine> orion: Red Nothing :: Color Maybe Bool
09:42:33 <benmachine> orion: but I wonder if you didn't mean Red a b or Red (a, b)
09:42:39 <orion> I meant the latter.
09:42:42 <benmachine> oh
09:42:47 <orion> Because I am trying to up the complexity.
09:42:53 <benmachine> ...why :P
09:43:06 <orion> to learn
09:43:18 <benmachine> Red (7, 4) :: Color Integer Integer
09:43:30 <benmachine> does that help?
09:44:34 <merijn> orion: That type is equivalent too "data Color a b where Red :: (a b) -> Color a b"
09:44:43 <merijn> benmachine: That's wrong
09:44:46 <merijn> or
09:44:52 <merijn> I missed the typo :p
09:45:00 <merijn> orion: That type is equivalent too "data Color a b where Red :: (a, b) -> Color a b"
09:45:34 <brainacid> Hi. I dont know much about programming and im looking at haskel.
09:45:58 <ij> How's it going so far?
09:46:17 <brainacid> well im learning erlang as well so it looks promising
09:46:46 <eyebloom> Haskell changed my life.
09:46:53 <brainacid> really
09:46:57 <eyebloom> Restored my faith in comp sci
09:47:19 <brainacid> i have Real World Haskell
09:47:25 <brainacid> OReilly
09:47:38 <mgdm> I'm reading Real World Haskell, and just got to the bit about Functors, and I feel like I've missed an entire chapter somewhere
09:48:23 <eyebloom> RWH is great but I think it gets a little to practical.
09:48:52 <eyebloom> I doesn't really explain the beauty of the whole system.
09:48:58 <brainacid> tbh i never programmed before
09:49:01 <Jafet> RWH is rather dated.
09:49:02 <brainacid> so im overwhelmed
09:49:23 <eyebloom> What other languages have you worked with?
09:49:30 <mgdm> Jafet: is there anything better or more up to date that you'd recommend?
09:49:37 <brainacid> python very little
09:49:40 <Jafet> No, I don't know any.
09:49:54 <Jafet> Some chapters hold up well, some don't (the parsec one is 2.x?)
09:50:17 <mgdm> I noticed a bunch of the examples in the online edition have broken examples
09:50:23 <quchen> The chapter about concurrency is conceptually right, but the API has evolved a little since then.
09:50:33 <eyebloom> I see. It's hard for me to give you advice because came from Basic to C++ to Python to Haskell with a bunch of other stuff mixed in there.
09:51:28 <eyebloom> But I would say that the thing to keep in mind at all times is that Haskell is just an implementation of a typed lambda calculus with syntactic sugar added on top.
09:51:38 <brainacid> eyebloom, its all good i appreciate the intention
09:52:00 <brainacid> cool
09:52:13 <mgdm> I noticed there's another O'Reilly book in the works about the concurrency stuff
09:52:13 <eyebloom> If you learn to understand lambda calculus and types first then Haskell will be a lot easier to understand.
09:52:14 <brainacid> i know nothing of lambda calculus
09:52:41 * monochrom decides to answer a past question out of the blue
09:52:45 <monochrom> haasn: yes
09:52:47 <eyebloom> It's hard to say where to start then.
09:53:21 <Peaker> eyebloom: that's overly reductionist... Haskell is more than the core language it's reduced to
09:54:15 <Peaker> eyebloom: and even more than the sugar, too.  purity, non-strictness, type system quirks/etc don't fit into that definition and are somewhat important in understanding Haskell
09:54:24 <monochrom> "learn haskell first or learn typed lambda calculus first" is a "chicken first or egg first" problem
09:54:35 <benmachine> Peaker: I feel like none of what you are saying contradicts what eyebloom said
09:54:51 <eyebloom> Peaker: I think I'm just trying to guide people to an understanding of how it works.
09:54:53 <Peaker> benmachine: I'm really just against the "just" in that sentence
09:54:59 <monochrom> despite the chicken-and-egg problem, both chicken and egg managed to appear and live on
09:55:13 <benmachine> Peaker: oh, sorry, I missed that line :P carry on
09:55:24 <monochrom> learn haskell. then you will know typed lambda calculus as a side effect
09:55:52 <benmachine> Peaker: was thinking of "if you learn to understand" etc. which I think is basically true
09:55:57 <Lycurgus> see now I got busted for sayin' something like that
09:56:09 * Lycurgus <- JuanDaugherty
09:56:09 <eyebloom> It's helpful for me to break down haskell syntax into typed lambda terms.
09:56:11 <benmachine> although tbh I see learning Haskell an easier route to learning LC than the other way around, at least in terms of motivating it
09:56:33 <Lycurgus> and it was currying which is more fundamental here
09:58:13 <eyebloom> But we are all entitled to our opinions. One really helpful book is Types and Programming Languages by Benjamin C. Pierce, I'm not sure how helpful this is for a beginner but it's essential at some point.
09:58:31 <ReinH> We're talking about *learning to program using haskell*
09:58:41 <Jafet> It is not essential to haskell in any way.
09:58:50 <ReinH> Let's be realistic about what we expect someone to be willing and motivated to do to learn a programming langauge
09:59:27 <Algebr> Since Main is an IO Monad, I could have a return call at the very end, would that ever have a use-case?
09:59:33 <mgdm> I (re-)started this to learn a new way to approach programming, not specifically to learn lambda calculus, but if that's a side-effect I'm quite happy
09:59:43 <ReinH> I don't think either spending weeks manipulating abstract symbols (LC) or learning how types work at a fundemantal level (TaPL) are necessary to learn how to make Haskell do cool stuff to your computer.
09:59:55 <eyebloom> Then python might be easier. Gotta crawl before you walk.
10:00:28 <Jafet> You are entitled to your opinions, but they are wrong.
10:00:36 <ReinH> I don't think python : crawling :: haskell : walking is an accurate or useful analogy
10:00:40 <ReinH> it's also rather elitist
10:00:53 <ReinH> And frankly, we are not entitled to our opinions. We are entitled to what we can argue for.
10:00:56 <ij> What do you think about my hoogle wrapper? http://sprunge.us/KCfO
10:01:20 <monochrom> guess what, I think haskell : crawl :: python : run, don't walk. python is so much more complicated.
10:01:33 <eyebloom> The unfortunate thing about learning using haskell is that the compiler will reject a lot of programs because they don't type check. Which means you don't get to see how they run. Also lazingness makes tracing difficult.
10:01:47 <Jafet> monochrom: until you run the programs, then python crawls!
10:01:59 <monochrom> haha
10:02:07 <ReinH> I don't think type checking is unfortunate at all
10:02:20 <monochrom> at any rate, my global attitude is: concrete before abstract, specific before general. (from Piaget's theory)
10:02:26 <haasn> I don't get to see how my programs will crash and burn? What a shame :(
10:02:32 <dmj`> eyebloom: if they don't type check it's probably because they would cause a runtime error
10:02:35 <Jafet> eyebloom: every type error that you don't get in python is a bug
10:02:41 <eyebloom> I love haskell, it's the only language I use. But I think the frustration level could be extremely difficult for a begginer.
10:02:44 <Taneb> eyebloom, GHC 7.8 lets you defer type errors to runtime
10:03:03 <dmj`> Taneb: shame!
10:03:10 <dmj`> :P
10:03:11 <ReinH> eyebloom: Programming is frustrating.
10:03:17 <brainacid> im frustrated
10:03:27 <ReinH> Telling a computer exactly what to do in minute, exacting detail is frustrating
10:03:37 <Taneb> dmj`, it's for precisely the use case eyebloom mentioned
10:03:45 <ReinH> no matter what programming langauge you use, it will be frustrating
10:03:46 <monochrom> for example, the math enthusiasist's view of "teach category theory first, then universal algebra, then rings, then fields, then finally the reals" is doomed to fail
10:03:59 <Jafet> Heh, do people really teach that
10:04:10 <monochrom> thank God, no. but people do advocate that.
10:04:23 <Jafet> The new new math. Kids, today we're going to chase a diagram
10:04:24 <monochrom> I too once advocated it. when I was too excited about math.
10:04:42 <yogurt_truck> eyebloom: if you want to see frustration you should come to ##javascript
10:04:55 <jle`> category theory before algebra?
10:05:18 <ReinH> I guess I don't understand the idea that Haskell is harder than other programming langauges.
10:05:23 <ReinH> I think it's just different.
10:05:28 <ReinH> In many ways I find it easier.
10:05:35 <jle`> it's hard when you come from it from another language, i think
10:05:38 <Peaker> ReinH: there's just more to learn before you can get anything done
10:05:41 <Taneb> ReinH, it's harder to go C --> Haskell than it C -> Java
10:05:43 <jle`> your bad habits get in the way
10:05:44 <Taneb> for example
10:05:59 <Peaker> ReinH: it's not harder to use, it's harder to learn..  well, it is harder to use when you need to debug runtime behavior. Haskell runtime debugging sucks
10:06:01 <ReinH> Like I said, it's different.
10:06:09 <ReinH> C and Java are very similar comparatively
10:06:13 <jle`> i don't think it's harder to learn necessary
10:06:20 <jle`> necessarily
10:06:21 <phy1729> I get why I can't do ((++" ")++) but is there a better way than foo x y = x ++ " " ++ y  ?
10:06:35 <jle`> phy1729: you can only ++ lists
10:06:37 <Peaker> With Python one can get up and programming in a day or few days, depending on previous proficiency.. types are great, but they are extra things you need to learn
10:06:38 <yogurt_truck> (it turns out that the "freedom" of being able to ship incoherent nonsense to production, results in tons of maintainability-related frustration)
10:06:38 <jle`> but you ++  a function
10:06:42 <ReinH> I think someone who started with Haskell would find C very hard to learn
10:06:43 <Jafet> intercalate " " [x, y], may be a bit overkill
10:06:47 <ReinH> and ML relatively easy to learn
10:06:59 <ReinH> That doesn't imply that C is harder in some absolute sense
10:07:01 <monochrom> I would stick with x ++ " " ++ y
10:07:01 <phy1729> jle`: I get why I can't, is there a more sugary way to do foo?
10:07:02 <yogurt_truck> Peaker: you cannot not learn types
10:07:10 <jle`> phy1729: ah
10:07:13 <Clint> concat [x," ",y]
10:07:18 <Peaker> phy1729: not better, but:   foo x y = (x ++) . (++ y)
10:07:24 <jle`> that's cute
10:07:36 <monochrom> @pl \x y -> x ++ " " ++ y
10:07:36 <lambdabot> (. (' ' :)) . (++)
10:07:37 <phy1729> well I was passing it to zipWith
10:07:37 <int-e> @pl \x y -> x ++ " " ++ y
10:07:37 <lambdabot> (. (' ' :)) . (++)
10:07:52 <eyebloom> Peaker: I think that's why I'm suggesting Python is a better place to start. Because you need some time just writing programs and seeing what they do. Haskell is a lot of writing programs and seeing how they compile.
10:07:57 <monochrom> that is an option but I don't know about "better"
10:07:58 <yogurt_truck> in python and JS you still have to think in terms of types in order to ensure that whatever computation you're writing has meaning for certain types of values and not others
10:08:08 <Jafet> If you want sugar, make your own sugar: join2 a x y = x ++ a ++ y
10:08:19 <yogurt_truck> I love how people think they don't use types just because they don't use a static type _system_
10:08:22 <prophile> I'm inclined to agree with eyebloom, python is very easy to get people started with
10:08:26 <Peaker> eyebloom: I don't know if it is a better place to start, because it might be hard to crawl out of the pit later
10:08:30 <monochrom> and yes, when writing in lisp, python, and javascript, I write types in my comments
10:08:44 <prophile> it helps that there's a lot less handwaving to get someone started with python
10:08:58 <prophile> print "Hello, world!" is a valid program and you can explain every part of it to someone just starting out
10:09:06 <eyebloom> Peaker: you can't appreciate crawling out of a pit if you've never been in one.
10:09:08 <monochrom> and this is a backhand slapping to lisp by putting lisp, python, and javascript on the same footing :)
10:09:12 <ReinH> monochrom: Ruby has documentation systems with carefully designed ways to annotate type information that the interpreter, of course, completely ignores.
10:09:14 <prophile> where as you have to handwave out boilerplate in C or Java, or IO in haskell
10:09:15 <Peaker> eyebloom: after you're already productive in an inferior way to program, and need to become unproductive for a while to learn the superior way -- you may wish that you had started with the superior way in the first place, for a slightly more expensive upstart
10:09:26 <yogurt_truck> what do they think they're doing whenever they sprinkle `if (o.x != undefined && o.y != undefined) move_point(o)` kind of crap all over their codebase?
10:09:37 <Peaker> eyebloom: giving up the productivity you already have is hard
10:09:39 <prophile> Peaker: "an inferior way of programming"?
10:09:41 <jle`> print "hello world" is also valid in haskell :P
10:09:55 <jle`> i prefer putStrLn "hello world"
10:09:58 <prophile> jle`: not in a file on its own :)
10:09:59 <brainacid> i agree with Peaker
10:10:00 <Peaker> prophile: At least for those of us who believe untyped programming is an inferior way to program :)
10:10:03 <jle`> and it makes perfect sense
10:10:06 <jle`> ah
10:10:11 <orion> hm
10:10:17 <yogurt_truck> Peaker: that productivity is a lie
10:10:22 <prophile> Peaker: as was just argued above, dynamic typing is not untyped!
10:10:24 <Peaker> yogurt_truck: why?
10:10:33 <orion> Is it a bad idea to learn Haskell by doing a massive project in it?
10:10:45 <jle`> orion: how massive
10:10:48 <jle`> like 3/4 years?
10:10:51 <prophile> it's a bad idea to learn virtually anything by doing a massive project in it
10:10:57 <monochrom> I disagree that hello-world should be a benchmark of teaching and learning.
10:10:59 <Peaker> prophile: well, that's arguing terminology..
10:11:03 <orion> The equiv. of 12,000 lines of C++
10:11:10 <Peaker> prophile: we can call it "unityped" programming if you'd like?
10:11:11 <prophile> Peaker: we're haskell programmers, semantics are important
10:11:13 <yogurt_truck> Peaker: the whole "you have to get less things done or be slower in order to use a better tool" is an ignorant lie, based on zero evidence.
10:11:46 <prophile> it's not unityped, it's just types that are not statically determined
10:11:52 <pejo> orion, doing something you care about is a great way to stay motivated, but you need to find a way to break it down into managable pieces.
10:11:53 <jle`> orion: hm. i can't really relate to that metric
10:11:54 <monochrom> read my Haskell I/O tutorial at http://www.vex.net/~trebla/haskell/IO.xhtml
10:12:01 <orion> jle`: 1 year
10:12:10 <Peaker> prophile: I take "type" to mean a classification of terms
10:12:15 <jle`> i wouldn't recommend a 1 year project as your first haskell project
10:12:26 <Peaker> yogurt_truck: That's not the claim I made
10:12:33 <ReinH> I wouldn't recommend a 1 year project as your first for any language
10:13:06 <Peaker> yogurt_truck: I claimed that someone who invested in becoming productive in Python, and then decides to learn Haskell, would have to suffer through at least a temporary loss of productivity. That might stop him from learning Haskell altogether (and I've seen at least a few cases of this)
10:13:07 <jle`> i think haskell has a lot of interesting avenues of things to learn and a massive 1 year project would be more of a chore of organization and maintainibility than exploring haskell
10:13:21 <prophile> Peaker: that applies to learning any new technology
10:13:23 <jle`> short 1/2month projects probably give you enough flexibility to jump from new concept to new concept
10:13:25 <ij> Taneb, How that happens and how can I try it out?
10:13:29 <jle`> or even couple weeks
10:13:37 <prophile> most vim users didn't start with vim but there are plenty of them about
10:13:45 <eyebloom> member:merijn: Incidently I found a way to get that toy problem to compile... http://lpaste.net/102944
10:13:54 <Jafet> Well, I think of 12000 lines of C++ as a couple weeks
10:13:58 <yogurt_truck> Peaker: ah so you're talking about the difficulties of adopting haskell in industry?
10:14:05 <Peaker> prophile: it doesn't work the other way around. If you know Haskell, learning Python afterwards is much easier.. understanding unityped/dynamically/untyped programming after typed programming is easy
10:14:06 <mgdm> I learned vim more because it was on all the systems I needed to maintain rather than because I particularly wanted to
10:14:25 <prophile> Peaker: evidence?
10:14:26 <Peaker> prophile: Here is why "dynamic" is "unityped": http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
10:14:46 <prophile> ooh, a blog post
10:14:52 <prophile> it has italics too, just in case my attention span is short :)
10:14:58 <yogurt_truck> prophile: by bob harper
10:15:08 <prophile> yes, you can make dynamic types static by summing them all
10:15:19 <eyebloom> Peaker: I think the issue is that if you don't understand programming with values by themself it's hard to reason about types.
10:15:27 <yogurt_truck> he has a very good book (which he links there), btw
10:15:30 <prophile> you can also make static types dynamic by forgetting them when you're compiling
10:15:33 <orion> I am learning Haskell, but I don't want to make useless toy programs. What do you guys think of me writing a library which implements various root finding methods such as Newton's method, bisection, the secant method, etc?
10:15:42 <Peaker> prophile: a blog post by one of the most well respected PL authors in the world :P
10:15:42 <prophile> I don't see this as a good argument for going from one to the other
10:16:01 <prophile> Peaker: I know, I just couldn't resist a moment of trollishness
10:16:03 <prophile> forgive me :)
10:16:06 <eyebloom> A dynamic language allows you to ignore types at first,
10:16:14 <Peaker> prophile: the argument is that types are classification of terms -- and "dynamic types" are runtime tags on values
10:16:16 <monochrom> a language that says "if f(x)=x+x, then f(rand(6)) is not the same as rand(6)+rand(6)" is one that needs much handwaving or excuses during teaching and learning
10:16:24 <Peaker> prophile: very very different notions, should not use the same name
10:17:11 <Peaker> prophile: dynamic languages forego all classifications of terms -- and all terms are uni-classified in the same "huge sum type" of all possible values
10:17:24 <akegalj> does anyone have example of how to do redirects with keter (v10) config file? I'm watching https://github.com/snoyberg/keter/blob/master/Keter/Types/V10.hs but can't figure it out :/
10:17:26 <dmj`> I'd like to make a pure data structure in Haskell, like a map, except the keys and values are serialized and then gzip compressed. Is anything like this already available?
10:17:29 <jle`> i don't even know how dynamic languages can take advantage of types unless at runtime
10:17:32 <benmachine> I had great difficulty explaining to a friend of mine why x = 3; y = x; y += 7 didn't mutate x and x = [3]; y = x; y += [7] did
10:17:56 <ReinH> The thing is, you could claim that (say) Ruby doesn't have a type system. You might even right. But it wouldn't really change the usefulness of the language.
10:17:57 <benmachine> if we're going for "stories about why explaining Python is hard"
10:18:05 <dmj`> ideally w/ log(n) worst case lookup and insertion, and keep things pure
10:18:06 <ReinH> *be right
10:18:12 <eyebloom> brainacid: What are some of the issues you are running into with understanding Haskell?
10:18:23 <yogurt_truck> eyebloom: yeah maybe for the first like 10 seconds. As soon as you make anything non-trivial in a dynamic lang, you'll be sprinkling `if (o.x != undefined && o.y != undefined) move_point(o)` kind of manual type-checking all over your codebase. Types transcend type systems. Can't really escape thinking about and acting on them.
10:18:26 <prophile> Peaker: just so, but you could also just as well classify all haskell expressions as being "values"
10:18:30 <prophile> and attach runtime tags
10:18:38 <prophile> (as I think GHC does to some extent?)
10:18:40 <Peaker> prophile: which is quite restrictive in what you can do w.r.t compile-time verification, and not really liberating in any way, because you can always opt out of classification in a static language
10:18:42 <brainacid> eyebloom, none at the moment. im not a very inventive guy so its hard for me to practice what i learn.
10:18:47 <benmachine> orion: sounds like fun
10:19:01 <prophile> but the fact that you can opt out of classification means that they're essentially equivalent, no?
10:19:38 <monochrom> benmachine: actually, Java has the same semantics. but Java notation also makes a distinction and so the problem is much less common
10:19:53 <eyebloom> brainacid: Whatever you do I'd recommend finding an environment where you can start by creating some kind of graphics.
10:20:16 <eyebloom> drawing shapes etc, or building small games.
10:20:20 <Jafet> dmj`: log(n) lookup into a gzip stream?
10:20:26 <benmachine> monochrom: I'd be much happier with it if there was a notational distinction, otherwise it seems like notation doesn't have meaning in itself
10:20:30 <brainacid> eyebloom, that sound awesome
10:20:47 <brainacid> eyebloom, what do you mean by environment?
10:21:36 <Peaker> prophile: if you could also opt in to classifications they'd be equivalent
10:21:40 <eyebloom> I mean a platform of some kind, which is usually a programming language and some libraries for making graphics, or a programming language that has them built in.
10:21:44 <Peaker> prophile: but you can't opt in in so-called "dynamic" languages
10:22:24 <Peaker> prophile: Harper is saying that the unclassified-case is merely a (less interesting, somewhat useful) degenerate case of the classified case.. so "dynamic" languages are a subset of "static" languages
10:22:33 <eyebloom> Or a book that teaches "video game programming in language x"
10:23:16 <Peaker> prophile: anyway, at least in academic circles, it's quite common terminology that: "dynamic typing" = "unityped" = "untyped"
10:23:37 <yogurt_truck> brainacid: check out Elm. it's got a strong type system (not near as expressive/advanced as haskell's) and for learning _while_ creating interactive graphic-y things (on the browser, in this case) it's the best you will get
10:23:42 <prophile> but yet
10:23:49 <yogurt_truck> s/strong/static/
10:23:54 <prophile> any interpretation valid in a static language could be taken from the runtime tags
10:23:56 <ReinH> yogurt_truck: (and an amazing debugger)
10:24:03 <Peaker> Conor McBride tried getting the term-classification idea named "clue", so we could have "clueless" languages :)
10:24:20 <prophile> which just flips the whole thing on its head
10:24:37 <eyebloom> Brainacid: you could also take an existing simple game and learn to modify it.
10:24:50 <Peaker> prophile: what about invalid programs?
10:24:55 <monochrom> haha
10:25:22 <Peaker> prophile: what about  read "3" * 5?  what does    read "3"   do?
10:25:34 <prophile> the equivalent of _|_ one would imagine
10:25:56 <Peaker> prophile: why?
10:26:03 <yogurt_truck> brainacid: ReinH: right. A very cool debugger, which was btw only possible to implement properly thanks to the purity and typing of the language (so it's itself a good demonstration of the usefulness of these principles :D)
10:26:13 <prophile> for the same reason that sqrt -1 is _|_
10:26:16 <ReinH> yogurt_truck: yep :)
10:26:21 <Peaker> prophile: but read "3" is entirely valid
10:26:23 <eyebloom> brainacid: http://inventwithpython.com/, I gave this to my nephew.
10:26:24 <prophile> or head []
10:26:40 <prophile> ah
10:26:40 <prophile> sorry
10:26:43 <prophile> apologies, I misread you
10:27:00 <Peaker> prophile: also, there are some type systems that prove lack of deadlocks, for example.   A runtime interpretation cannot necessarily prove the same things (at least not by simple interpretation)
10:27:26 <prophile> presumably it would have the runtime tag of the equivalent of (Num a) => a
10:27:30 <eyebloom> I agree with most people tha's probably better to learn programming with Haskell, but I don't think a book like that exists for Haskell... yet!
10:27:39 <prophile> as it would in GHC
10:27:42 <Peaker> prophile: you mean:   (Read a) => a  ?
10:27:54 <prophile> actually neither, I mean (Read a, Num a) => a
10:28:07 <prophile> since it's being multiplied by 5
10:28:19 <Peaker> prophile: why?   to infer the "Num" constraint means doing static type inference
10:28:20 <monochrom> eyebloom: Hudak's "the Haskell school of expression" begins with graphics. and ends with graphics. and some music.
10:28:35 <Peaker> prophile: "dynamic typing" does not include type inference
10:28:44 <prophile> I disagree with the premise
10:29:05 <prophile> multiplying something of type (Read a) => a by something of type (Num a) => a
10:29:11 <Peaker> prophile:   dynamic typing says the "runtime type" of "5" is, say, Integer.   then the runtime type of "read" is problematic, because it doesn't have a concrete type it can return
10:29:16 <prophile> is a very straightforward case
10:29:28 <prophile> you're placing restrictions on what these runtime tags are that don't exist
10:29:30 <monochrom> tautology experts agree: a static checker proves during static time, a runtime checker proves during run time. :)
10:29:52 <prophile> monochrom: :)
10:30:18 <Peaker> prophile: how would you write the "read" function in Python (or some other dynamically typed language)?
10:30:18 <YawningAngel> How do I define algebraic data types in terms of regexes? Something looking like "data Capital = [A-Z]"
10:30:30 <orion> Does Haskell have syntax like 1e-8 for 1*10^-8?
10:30:43 <Peaker> YawningAngel: there's no such beast
10:31:14 <ReinH> > 1.3e8
10:31:16 <lambdabot>  1.3e8
10:31:16 <Jafet> YawningAngel: what would be the type corresponding to "A*"?
10:31:30 <ReinH> Jafet: [A] :p
10:31:33 <YawningAngel> ...so I would literally have to make something along the lines of "data Capital = 'A' | 'B' | 'C' ... " ?
10:31:41 <prophile> Peaker: I don't see the relevance, restrictions in any particular dynamic language don't mean it isn't possible for any dynamic language
10:31:46 <YawningAngel> It would be the type corresponding to [A-Z]+
10:31:48 <ReinH> 'A' is not a type
10:32:04 <ReinH> 'A' is a value of type Char
10:32:11 <YawningAngel> Agreed entirely
10:32:13 <orion> > :t 1e-8
10:32:14 <prophile> YawningAngel: you want to create a type inhabited only by strings matching a particular regex?
10:32:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:32:18 <YawningAngel> Yup
10:32:18 <orion> :t 1e-8
10:32:21 <lambdabot> Fractional a => a
10:32:24 <orion> col
10:32:26 <honza> how can i compile my code with ghc llvm?  i'm on osx and have installed llvm with homebrew but ghc can't seem to find it
10:32:36 <prophile> not easy in general
10:32:42 <prophile> try idris ;)
10:33:22 <Peaker> prophile: "dynamic typing" is about runtime tagging and checking tags.   "static typing" is about inference about terms.   You can have a hybrid, but inferring that "Num" thing is part of the latter, not the former
10:33:47 <YawningAngel> Assuming I don't want to switch the language my entire project is written in, is there anything I could do to approximate having such a type?
10:33:50 <Jafet> YawningAngel: that's strange, because A* is a different regular language to [A-Z]+
10:34:08 <prophile> "I am any readable type" is perfectly conceivable as a runtime tag
10:34:27 <Peaker> prophile: whenever you have a tagged term that doesn't happen to correspond to a runtime value in positive position -- the weak apparent correspondence between the two typing systems breaks
10:34:41 <monochrom> I would use Char. or a newtype of Char to remind me its restrictions
10:34:54 <Peaker> monochrom: there's a certain sad loss of static safety in that choice, though
10:35:17 <monochrom> it is predicate subtype. haskell doesn't have predicate subtype.
10:35:24 <prophile> YawningAngel: simplest way is to hide it behind a newtype and not export the constructor
10:35:46 <Peaker> monochrom: he could do the tedious thing: A | B | C | ...
10:35:47 <prophile> YawningAngel: only export a function from, say String -> Maybe RegexedString which checks the values as they go through
10:35:50 <monochrom> well, I accept that loss for other gains
10:35:59 <Peaker> and that would be slightly safer, but yeah, it's probably not worth the hassle
10:36:25 <Peaker> there's some ranged-Nat type in some library, maybe something like  Fin 26   can be used
10:36:25 <Jafet> It's not going to make the rest of the program any safer
10:36:26 <monochrom> the main gain is that you folks also use this language
10:36:52 <Peaker> Jafet: but it will make the implementation of that module safer
10:37:03 <YawningAngel> Jafet: you are correct, my example data type is entirely wrong. Specifically, I want to either define an algebraic type consisting only of entries matching [A-Z]+[0-9]*
10:37:15 <monochrom> I believe that most of you will not use a language that has predicate subtype and therefore, during static type checking time, you have to provide a few proofs.
10:37:54 <YawningAngel> prophile: So basically, create myself a class which checks whether a given string matches such a regex, fails if it doesn't, and exports the string if it does?
10:38:04 <dolio> Peaker: You can always do something like -fdefer-type-errors, except instead of statically inserting errors, link the type checker into the program and figure out whether something should be an error at runtime.
10:38:12 <Peaker> YawningAngel: http://www.haskell.org/haskellwiki/Smart_constructors
10:38:13 <dolio> Of course, doing that is pretty much pointless.
10:38:15 <prophile> YawningAngel: no need for a class
10:38:32 <Peaker> dolio: do you retain the original terms to do this?
10:38:39 <YawningAngel> That seems like it'll solve my problem, thanks very much <3
10:38:45 <honza> success; homebrew didn't link opt and llc into /usr/local/bin
10:38:45 <YawningAngel> I'll remember to use Idris next time, of course ;)
10:39:00 <dolio> Peaker: I don't think so. Unless you're dependently typed or something.
10:39:15 <dolio> Or your types aren't compositional in some other way.
10:39:43 <Peaker> dolio: then how do you handle a runtime value like   foo :: Proxy p,  where the "p" is forced from some other constraint in code that's not run yet, but should determine the current behavior
10:39:50 <dolio> Barring that, once you synthesize the type, you just carry it around and don't need the original term anymore.
10:39:55 <prophile> Peaker: https://gist.github.com/prophile/c3db1dbe69ceaf29baa0
10:40:32 <Peaker> prophile: you had to add an explicit type annotation there
10:40:49 <Jafet> Peaker: nondeterminism!
10:40:57 <dolio> Peaker: You leave a unification variable open, and wait for it to be unified with something.
10:40:57 <Peaker> prophile: before you said the static types arise from a valid interpretation of the program?
10:41:14 <dolio> Actually, that probably is worse than Hindley-Milner, because you can never generalize.
10:41:25 <dolio> So it's actually worse than the static version.
10:41:32 <Peaker> dolio: and not execute anything yet, but rather pile it up into some sort of deferred execution waiting for when the types become concrete?
10:41:58 <prophile> Peaker: there are no type annotations there, int and float are functions
10:42:15 <Jafet> If you do the piling up thing, you are essentially interleaving evaluation and typing
10:42:25 <prophile> what i'm demonstrating is that you can do what we were discussion earlier, in this case by putting things behind functions
10:42:29 <Jafet> Could be a fun idea to interpret a program that way
10:42:32 <dmj`> Jafet: suppose I kept the keys and their Ord instances, but serialized and gzipped the values
10:42:32 <Peaker> prophile: but this is not equivalent to the program    read "3" * 5     it required more annotations, precisely for the terms that did not correspond to runtime values in a positive position
10:42:51 <Jafet> dmj`: ok, I don't see why you can't store the serialized values in a Map.
10:42:59 <prophile> mul(read("3"), num(5)) is the equivalent of read "3" * 5
10:43:05 <prophile> there are no type annotations in there
10:43:20 <dmj`> then lookup would be log(n) + and constant time for decompressing and deserializing
10:43:22 <Peaker> prophile: runtimes "types" can only "flow" forward, within runtime values that carry them.   Compile-time types can "flow"/infer in any direction
10:43:24 <dmj`> a*
10:43:39 <Peaker> prophile: (which I'd use as more evidence that they're quite different beasts)
10:43:59 <Peaker> prophile: ok, how about:   read 'x' : "foo"
10:44:00 <dmj`> Jafet: and maybe decompressing could be done in parallel
10:44:03 <Jafet> prophile is basically doing dictionary-passing, in this case with trivial dictionaries (those of int and float)
10:44:29 <Jafet> In other words, the programmer still does all the typing in that program.
10:44:52 <Peaker> prophile: runtime types are always of values.  compile-time types can be of non-values (e.g: phantom type parameters)
10:45:16 <dolio> If you have to do dictionary passing by hand, then you have failed.
10:45:16 <brainacid> thanks eyebloom
10:45:20 <dmj`> Jafet: you can store them in a map, it's just no map performs serialization and compression on insertion and deserialization / decompression on lookup ootb, and totally pure
10:45:28 <brainacid> thanks yogurt_truck
10:45:37 <prophile> dolio: that's only a result of my demonstrating this in python
10:45:54 <prophile> it could easily be put behind other sugar in a dynamic language designed for this sort of thing
10:46:08 <Jafet> dmj`: you can write a little wrapper for Map that does the serialization.
10:46:16 <prophile> Peaker: I'm not sure what your point there is?
10:46:43 <Jafet> There is no Map for storing gzipped values because it is a special case of storing any values.
10:46:48 <prophile> I must put this argument on hold, I'm afraid
10:46:54 <prophile> my deadline for my bachelor's thesis looms
10:47:15 <Peaker> prophile: I'm bringing various clues that compile-time types and runtime "types" are different ideas. It's not just about when the types are checked -- but about whether the notion of static classifications of terms (which can do various things the dynamic classification cannot) even exists
10:47:36 <prophile> ok
10:48:06 <Jafet> prophile: the standard test to illustrate this difference is to implement Monad in, say, python, in full generality
10:48:18 <Jafet> Particularly return.
10:48:51 <Jafet> (The higher-order bind trips up many languages, too)
10:48:56 <prophile> I've done it before
10:49:01 <prophile> I survived by gnawing off my own legs
10:49:24 <prophile> http://i1.ytimg.com/vi/5jY6EPf5MHQ/hqdefault.jpg
10:49:40 <dolio> Peaker: There's nothing that prevents you from doing all the checking of types from static typing at runtime, though. It's just kind of pointless to delay that long.
10:50:38 <dolio> You can keep the notion of type as a classification of syntactic forms, and check them at runtime.
10:51:00 <dolio> And even delay doing so 'as long as possible.'
10:51:30 <Peaker> dolio: but then you have to carry the terms to runtime, because the values don't correspond to the terms
10:51:40 <dolio> But you'll have the same language as you would if you did the check during compilation, and you'll just get your errors later.
10:52:08 <Peaker> dolio: now that would really be "dynamic typing" :)  but what everyone calls "Dynamic typing" is just "unityping" or "untyped"
10:52:20 <dolio> You can store the types of the terms in the values they turn into.
10:52:40 <Peaker> that only works for most cases (not all)
10:52:45 <dolio> Yes, what most people call dynamic typing isn't the same thing as this.
10:52:55 <Peaker> because not all terms have corresponding runtime values
10:53:29 <dolio> That doesn't make sense.
10:53:37 <Peaker> and again, works for flowing information "forward", not "backward"
10:53:57 <Peaker> from argument to function to result.  Sometimes the type inference flows backwards from the result to the function to the argument
10:55:44 <Peaker> dolio: let x = return 5 in do { print x ; print $ fromMaybe "Only now we know x is a Maybe type, hah!" x }
10:55:54 <Jafet> dmj`: if some library uses IO, depending on how morally pure the IO is, you can wrap it in unsafePerformIO
10:56:26 <dolio> Peaker: I don't think that example is a problem.
10:56:34 <dolio> Although do notation obfuscates it.
10:56:52 <dmj`> Jafet: I ported Lemmih's compact-map to 7.8.2 and it seems to work well, but doesn't gzip compress the values
10:57:05 <Peaker> dolio: does the "print x" get interpreted before the "fromMaybe" sees light of day?
10:57:28 <dmj`> and it uses a lot of unsafePerformIO... not sure the motivation since gzip and serialize are pure functions
10:58:23 <dolio> Peaker: If it's a problem, the only problem is defaulting.
10:58:32 <Peaker> dolio: what do you mean?
10:59:08 <dolio> print x gets interpreted to Monad m => IO (), which accepts a Monad dictionary and gives an IO ().
10:59:13 <orion> If I clone a git repo, how do I compile the code and install it as a local package (non-root)?
10:59:36 <dolio> Then when you combine it with the other print, we figure out that m = Maybe.
10:59:49 <Peaker> dolio: OK, imagine I have >>= there instead of >>
11:00:05 <Peaker> dolio: so you cannot look inside the right-hand action before finishing execution of the left-hand action
11:00:06 <dolio> The problem is figuring out when to complain about ambiguous type classes.
11:00:33 * hackagebot hemokit 0.6.2 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.2 (NiklasHambuechen)
11:00:57 <Peaker> let prompt x = print x >> getLine ; x = return 5 in prompt x >>= \line -> ... here I force x to be a Maybe, the interpreter cannot see this ...
11:02:00 <dolio> Peaker: The right-hand side of the >>= would need to be annotated with its type as well.
11:02:11 <dpld> @pl \f xs e = f $ map ((flip ($)) e) xs
11:02:12 <lambdabot> (line 1, column 9):
11:02:12 <lambdabot> unexpected "="
11:02:12 <lambdabot> expecting pattern or "->"
11:02:13 <monochrom> @quote monochrom hugs
11:02:13 <lambdabot> No quotes match. Do you think like you type?
11:02:23 <dpld> @pl \f xs e -> f $ map ((flip ($)) e) xs
11:02:23 <lambdabot> (. flip (map . flip id)) . (.)
11:02:28 <dolio> Which you can do, because types come from the terms.
11:02:52 <dolio> It probably needs to include some way of specifying m ~ Maybe.
11:02:53 <Peaker> dolio: then you're no longer dynamic?
11:03:04 <dolio> You're doing type checking at runtime.
11:03:13 <dolio> So you're dynamic.
11:03:26 <dolio> It's the same type checking as the "static" type checking.
11:03:34 <Peaker> dolio: but then how can you carry  m ~ Maybe  from compile-time, if determining   m ~ Maybe  includes at least *some* type-checking to even figure that piece of information out
11:03:35 <dolio> But it's done at runtime, interleaving with execution of stuff.
11:03:39 <Jafet> I believe dolio is suggesting term-piling as well.
11:04:10 <monochrom> this is time to say what I always said: hugs postpones type checking to run time :)
11:04:20 <dolio> What is this m ~ Maybe at compile-time? You don't do type checking at compile time.
11:04:27 <Peaker> well, ghc also checks types at ghc's runtime :)
11:04:38 <dolio> There is no compile time, maybe. You're just interpreting syntax.
11:04:58 <Peaker> dolio: you said you carry   m ~ Maybe   from the terms to runtime -- is   m~Maybe   determined at compile-time?  Or do you carry all the terms inside the lambda to runtime and determine it then?
11:07:15 <monochrom> my thesis supervisor brought me to see these lines drawn between tokenising, parsing, various checkings, generating code, running... are not fundamental. great engineering lines, sure, but not fundamental. the boundaries can always be redrawn to suit particular situations.
11:07:47 <dolio> When you interpret the lambda-term or whatever into a runtime value, you compute the type, and tag the runtime value with it.
11:08:25 <dolio> When you go to ap two things, you ask for their previously computed types, compute the type of the result, and tag the result of the function with it.
11:08:50 <Peaker> dolio: well, if you carry the original terms/syntax/program to runtime -- I agree you can do it all at runtime.  if you lose the original terms, and try to carry the type information forward, piggy-backed on runtime values only (which is what dynamically typed languages generally do), then certain programs no longer work
11:09:42 <Peaker> dolio: corecursive stuff might be a problem even with that approach?
11:09:44 <dolio> The only hard part is representing context that kind of floats around ambiently in something like Haskell for type classes.
11:10:29 <dolio> But that seems achievable.
11:11:16 <dolio> Well, actually, there's another hard part.
11:12:09 <dolio> Actually, maybe not. Maybe you just compute the types for all things in a let when you go to evaluate it, in the standard way.
11:13:14 <dolio> The real other hard part is that Haskell has certain collapses of polymorphism, and it'd be difficult to translate that to runtime.
11:13:47 <dolio> Like, if the monomorphism restriction says to make something monomorphic, _uses_ of that thing can determine what it gets monomorphized to.
11:14:13 <dolio> So you have to figure out when in your execution to make that decision.
11:14:21 <dolio> That is non-local.
11:14:39 <dolio> But everything that is local shouldn't be hard to delay until runtime.
11:15:06 <dolio> Because you're just aggregating information as you combine things.
11:16:33 <dolio> But, I don't see the point. Because you don't get a 'more expressive' language or something. You just get the same language with errrors at less convient times.
11:18:51 <YawningAngel> The only way I can think of of making Haskell more expressive would be to extend the type system
11:19:39 <YawningAngel> But most things that use such systems are theorem proves rather than programming languages, for which I imagine there's a reason
11:20:42 <geekosaur> and yet ghc does extend haskell's type system, and is steadily creeping up on dependent types
11:21:02 <monochrom> the reason is anthropic, not technical. programming attracts a certain personality, and this personality does not want to write proofs.
11:21:34 <monochrom> if it wanted to write proofs, it would have already joined the math department long ago.
11:22:38 <monochrom> in fact, I almost joined the math department long ago.
11:22:50 <Jafet> Writing proofs for a computer is much harder than writing programs
11:23:18 <aloiscochard> YawningAngel: idris intend to be a general purpose PL
11:23:54 <monochrom> I wouldn't judge what is harder so easily
11:24:38 <monochrom> a professional gamer would tell you: coding a game on a computer is harder than defeating a game on a computer
11:24:53 <heatsink> To me, understanding a program feels a lot like writing a proof.
11:24:58 <monochrom> a professional programmer would tell you: defeating a game on a computer is harder than coding a game on a computer.
11:25:06 <monochrom> perhaps s/defeating/beating/
11:25:11 <aloiscochard> heatsink: the types yeah, agreed
11:26:15 <Jafet> Well, games that most people play are much easier to beat than to write. I would say the same thing holds for programs.
11:26:33 <Jafet> (There are, of course, many papers proving algorithms that are never implemented)
11:26:57 <heatsink> Not just the types.  Figuring out what a component of a program does or means is a lot like constructing lemmas.
11:27:11 <monochrom> not to me. every game is easier to write than to beat. to me.
11:27:41 <SwashBuckla> Do you know what is going wrong here? http://lpaste.net/102897  It successfully compiles (unfortunately). I am trying to write a pandoc filter to replace a code block include with the parsed version of the specified document namevar.
11:27:44 <aloiscochard> monochrom: it depend if you have to code the AI
11:27:45 <YawningAngel> monochrom let me know how http://www.myabandonware.com/game/robot-odyssey-6g treats you
11:27:57 <aloiscochard> monochrom: like for the game of GO
11:29:40 <Jafet> You need to play more mindless games sometime, like the one involving plants and zombies.
11:29:59 <heatsink> I actually wish I understood better how programming works for programmers who are bad at math and logic.
11:30:19 <aloiscochard> heatsink: it's basically a trial and error
11:30:23 <aloiscochard> game
11:30:40 <SwashBuckla> Axman6: I've not had any luck with the pandoc filter :(
11:30:43 <tobiasgw> heatsink: I'll gladly volunteer my brain
11:31:25 <SwashBuckla> it's hard to say how long I should spend on things. It's nice to figure them out myself, but it's been 2 hours writing (what should be) a simple pandoc filter
11:31:48 <SwashBuckla> it's annoying when Haskell programs compile, but they're just wrong
11:32:41 <monochrom> I did just purchase two Lego games from Steam. perhaps that will help. :)
11:33:44 <aloiscochard> those are probably easier to write indeed :-)
11:35:13 <raichoo> SwashBuckla: If you want stronger types, take a look at Agda and Idris ;)
11:35:33 <raichoo> Those can catch a few more bugs at compile time.
11:38:30 <SwashBuckla> yeah
11:40:25 <orion> woot!
11:40:35 <orion> I just wrote a fully functional haskell program!
11:40:37 * hackagebot graph-generators 0.1.1.0 - Functions for generating structured or random FGL graphs  http://hackage.haskell.org/package/graph-generators-0.1.1.0 (ulikoehler)
11:40:46 <orion> How can I spruce this code up?: http://ideone.com/sNC43t
11:48:28 <heatsink> tobiasgw: At the beginning of writing a piece of functionality, what design techniques do you use?
11:49:18 <heatsink> orion: Is that function solving (f x = 0) ?
11:49:23 <orion> yes
11:50:22 <heatsink> A good start would be to use consistent indentation
11:50:31 <heatsink> Are you using an editor that indents for you?
11:50:38 <heatsink> like emacs with haskell-mode
11:50:40 <orion> vim
11:50:59 <heatsink> I don't know how vim does indentation
11:51:50 <orion> "The following setup from merijn @ #haskell ensures you use spaces not tabs for indentation for generally sane behaviour: ..."
11:52:02 <orion> I'll use his settings
11:52:29 <heatsink> Here's how I would indent the code: http://ideone.com/buajbe
11:56:33 <orion> heatsink: I see.
11:56:43 <orion> Are there any logical things you'd modify?
11:56:48 <heatsink> if-then-else lines up; | and where are indented relative to the beginning of the function definition; RHS is indented 2 spaces from the guard code.
11:58:07 <heatsink> The logic is basically alright, but I would change things for clarity.   I'd encourage you to be more thoughtful about how you name things.
11:58:54 <orion> What things in particular aren't named well?
11:59:25 <heatsink> The "bisection" function is finding a solution to f, so "solve" would be a better name
11:59:42 <heatsink> "a" is the lower bound of the interval being searched, "b" is the upper bound
12:00:15 <heatsink> Lines 5-7 are finding new bounds, so it would be useful to give the new bounds names
12:01:07 <Jafet> You can't "solve" a function, try "findRoot"
12:01:13 <jakex> is there a more elegant way of writing this function? http://lpaste.net/102949
12:01:25 <Jafet> Or just give everything one-letter names, like real haskell programmers do anyways
12:01:38 <Jafet> @quote first.26
12:01:39 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
12:02:33 <Jafet> Ok, it was already renamed to findRoot.
12:02:51 <heatsink> I've edited the names
12:03:39 <orion> Awesome, thank you.
12:03:43 <quchen> jakex: Is it intentional that you're case-ing on "reads text" twice? That's redundant for sure.
12:03:58 <Jafet> > read "(1, 2)" :: (Int, Int)
12:04:00 <lambdabot>  (1,2)
12:04:19 <jakex> quchen one tries to parse for Int other for (Int, Int)
12:04:56 <quchen> Oh, right.
12:05:21 <jakex> "1" -> (1,1)  and  "(1,2)" -> (1,2)
12:05:45 <quchen> Don't use 'fail' by the way, it's evil.
12:05:53 <quchen> (Not usable for many Monads.)
12:06:22 <jakex> quchen I see. I thought it was neat how it worked with IO, Maybe and Either. with what monads wouldn't it work?
12:07:37 <jakex> I am passing this parser to optparse-applicative by the way, so I don't think I have a choice. this is how they expect parsers report errors
12:07:43 <jakex> +to
12:07:44 <quchen> As a rule of thumb, it works for MonadPlus instances, and fails for others.
12:08:14 <quchen> Reader and State cannot have 'fail', for example.
12:08:39 <quchen> Hmm. Optparse-applicative has its own methods for failing, doesn't it?
12:09:16 <quchen> Like so, http://lpaste.net/102950
12:09:19 <monochrom> yes, but it's an alias of mzero
12:09:33 <orion> In general, when do you want to use guards vs. pattern matching vs. if/then/else ?
12:09:40 <jakex> I am replicating this, basically. https://hackage.haskell.org/package/optparse-applicative-0.8.0.1/docs/src/Options-Applicative-Builder.html#auto
12:09:57 <monochrom> well, actually, some of them let you write a better error message, so I guess they are not exactly mzero
12:10:51 <Jafet> > let p s = head $ [ return (x, x) | (x, "") <- reads s ] ++ [ return x | (x, "") <- reads s ] ++ [fail $ "cannot parse " ++ show s] in map p ["1", "(2, 3)", "abc"] :: [Maybe (Int, Int)]
12:10:53 <lambdabot>  [Just (1,1),Just (2,3),Nothing]
12:12:03 <quchen> That 'auto' function by Optparse-Applicative is crap.
12:12:42 <quchen> It suggests it works for any Monad, but it doesn't, and the docs don't have a giant warning about it. Also, it should be called unsafeAuto and be deprecated and commented out.
12:12:45 <monochrom> my https://github.com/treblacy/random-read/blob/master/random-read.hs has a pretty realistic use of optparse-applicative, complete with my own argument format and my own error messages
12:13:29 <quchen> jakex, the usual way of handling parse errors is by returning an Either, and not a "might be failing monad".
12:13:39 <heatsink> orion: Guards are just a different syntax for nested if-else, so it's a style choice.  I prefer guards on function definitions.
12:13:55 <quchen> so "auto :: Read a -> String -> Either Err a" would be sensible.
12:13:57 <heatsink> orion: Use pattern matching when you're inspecting data that is not Boolean.
12:18:27 <orion> ok
12:19:11 <danilo2> Hello! I'm using daemons library to create my little daemon and its trival to create daemons, that are responding to commands with it, but I also want my daemon to constantly check for some situation and react in a defined way - for example to trakc how many users are logged into system and shut down the system if no more users are left. Is it possible to somehow simply code something like that with daemons ?
12:20:12 <epta> How to convert Data.Text.Lazy.Internal.Text to String?
12:20:49 <heatsink> unpack
12:21:17 <epta> heatsink: from where?
12:23:53 <heatsink> epta: from Data.Text.Lazy
12:25:15 <epta> ok
12:27:29 <quchen> orion: Here's another way of writing your parser: http://lpaste.net/102951 -- Maybe Alternative instance ("keep the first Just") based
12:28:12 <quchen> You could combine the two 'case' definitions to one if you wanted to, but I think it's clearer this way.
12:28:51 <danilo2> Hello! Does anybody knows Pipes or Daemons library? I'm trying to write daemon ewhich could recive a command and respond to it, but when no command is recived it will constntly check the amount of logged in users - how can I do it ? :)
12:28:52 <orion> parser?
12:29:49 <quchen> orion: You're writing a parser, yes.
12:29:58 <quchen> Or combining parsers, at least.
12:30:15 <quchen> Anyway, combined version can be seen in an annotation to the above paste. Obfuscated, but shorter. :-)
12:31:21 <orion> I'm writing a parser?
12:31:41 <quchen> You're converting a String to a Haskell value based on grammatic rules. That's what a parser does.
12:32:18 <orion> I thought I was writing a root finder.
12:32:26 <quchen> Ooh.
12:32:36 <quchen> I think I mixed you up with jakex.
12:32:49 <quchen> jakex: Everything I said to orion was directed at you.
12:33:03 <quchen> orion, everything I said to can be safely forgotten :-þ
12:33:18 <orion> hah ok. :>
12:34:52 <SwashBuckla> (Apologies for repost) Do you know what is going wrong here? http://lpaste.net/102897  It successfully compiles (unfortunately). I am trying to write a pandoc filter to replace a code block include with the parsed version of the specified document namevar.
12:39:38 <epta>  Couldn't match type `Data.Text.Internal.Text' with `Text'. How to fit it?
12:40:25 <monochrom> what is Text? I am serious. which module did you import it from?
12:40:36 <geekosaur> epta: usually that means you have a mismatch between strict and lazy Text
12:42:52 <danilo2> I'm sorry for reposting a question, but I'll try to rewrite it other way :) Is it possible to use "await" from pipes but tell them, that if there is nothing to wait for, just execute other function?
12:44:09 <epta> monochrom: Data.Text.Text
12:45:17 <monochrom> then they should match. find again.
12:45:29 <merijn> danilo2: No, because that question makes no sense in the way pipes is implemented. Have you looked at pipes-concurrency?
12:45:40 <monochrom> find again which module you imported it from.
12:45:42 * hackagebot app-settings 0.1.0.0 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.1.0.0 (EmmanuelTouzery)
12:47:44 <danilo2> merijn: No, I'm completely new to pipes, I will look into it. Maybe I'm looking at the wrong direction? I want to create a daemon (I'm using the daemons lib) and I want this daemon to both: respond to commands and constantly check how many users are logged into the system and shu it down if it drops to 0
12:48:23 <danilo2> merijn: I do not know if you could help me with htis, but If you've got any tip / idea - how it should be implemented, I would be very thankful
12:49:02 <SwashBuckla> any ideas?
12:54:32 <danilo2> merijn: hmmm the pipes-concurrent look like it help in this topic, thank you for pointing this out. I'll try to use it :)
12:54:40 <dmj`> let's say I have this type: type TinyMap k v = (Serialize v, Hashable k, Eq k) => TMap k v
12:54:49 <dmj`> and this function signature: lookup :: k -> TinyMap k v -> Maybe v
12:55:18 <dmj`> can't it be inferred that v in Maybe v has a class constrant of Serializeable ?
12:55:25 <dmj`> constraint*
12:55:37 <dmj`> ghc is telling me to resepcify the constraint
12:55:54 <geekosaur> it does that. it's forall-ed
12:56:09 <geekosaur> you can't carry constraints around that way, they won't unify :(
12:58:20 <dmj`> geekosuar: It's just that the type signatures in my API will have to repeatedly use Serialize and Hashable as constraints, is there any way I can hide these? I know I can specify class constraints in an ADT but I heard that is frowned upon...
12:58:26 <monochrom> if you're looking for an abbreviation, a reasonable abbreviation just deals with the (Serialize v, Hashable k, Eq k) part, and it can already be done with one of two extensions.
12:59:05 <monochrom> an abbreviation for the whole "(Serialize v, Hashable k, Eq k) => TMap k v" makes no sense to me, even if one day it could be done
13:00:45 <monochrom> precisely because most of the type sigs are not going to be exactly "f :: (Serialize v, Hashable k, Eq k) => TMap k v, period". they are more like "f :: (Serialize v, Hashable k, Eq k) => XXX -> TMap k v -> YYY"
13:00:53 <dmj`> monochrom: http://lpaste.net/102954
13:01:13 <dmj`> monochrom: yes excactly, the signatures will be differnet
13:01:13 <monochrom> does reading that paste change anything I said?
13:01:31 <dmj`> monochrom: no but it provides context for what I'm doing
13:04:04 <dmj`> monochrom: so ghc can't infer the types from the functions usage?
13:05:26 <monochrom> if you're looking for inference, first you would write no type sig, not even abbreviations.
13:07:02 <dmj`> monochrom: yes it infers correctly, but the signatures are long and ugly.
13:11:37 * SwashBuckla pokes channel
13:15:07 -Donations(~Donations@c0b85d74.ipv4.jackson.mtbnc.us)- Due to popular demand, Freenode is in the process of upgrading its servers to handle more bandwidth. This has put added costs on our organization and it has been a struggle.  For those interested in helping, a small donation to Freenode's Dogecoin wallet would go a long way. Account: D7nqwWstiWvLjkdHN3C68BGCntMNZBNWYi
13:15:07 <supki> dmj`: I wonder why would you need the bang patterns in insert
13:15:16 <supki> all three seem pretty useless
13:15:54 <geekosaur> ugh, that spammer
13:16:02 <geekosaur> not in the channel, they're using channel noticed
13:16:05 <geekosaur> *notices
13:16:48 <jakex> > fail "foo" :: Either String Int
13:16:49 <lambdabot>  *Exception: foo
13:16:55 <jakex> why not Left "foo" instead?
13:17:28 <jakex> > fail "foo" :: Maybe Int
13:17:29 <lambdabot>  Nothing
13:17:39 <jakex> with Maybe Nothing is returned, instead of exception being thrown
13:17:50 <geekosaur> it's a long and ugly story
13:18:04 <jakex> :/
13:18:09 <geekosaur> and I no longer remember the details
13:18:44 <supki> well, it can't be Left "foo"
13:19:07 <supki> unless you restrict Monad instance to Either String
13:19:14 <geekosaur> actually I think the problem is that the fail instance you tried to use only makes sense for Either String ... so a general fail for Either is not possible
13:19:17 <supki> which isn't very pleasant
13:19:22 <geekosaur> what should fail do for Either Int Int?
13:19:24 <jakex> yeah that makes sense
13:20:00 <geekosaur> iirc what you want is Error instead of Either
13:23:44 <bocaneri> Correct. That /notice from Donations is bogus.
13:24:15 <geekosaur> they've hit #perl twice so far, different nicks, coming back with a new address/nick each time it gets klined :(
13:45:47 * hackagebot haskell-src-exts 1.15.0.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.15.0.1 (RomanCheplyaka)
13:48:15 <notBurn> Hello =)
13:49:50 <notBurn> Hello =)
13:50:17 <mzero> we're here!
13:50:19 <mzero> what's up?
13:50:29 <notBurn> What systems is Haskell compatible with?
13:50:52 <mzero> as in what operating systems?
13:50:56 <notBurn> Yeah.
13:51:02 <Taneb> Most. Almost all.
13:51:08 <mzero> you can run the GHC compiler for haskell on Win / Linux / Mac
13:51:10 <Taneb> Windows, OS X, Linux certainly
13:51:15 <Taneb> BSD I think so
13:51:17 <notBurn> Awesome.
13:51:24 <Taneb> Haiku I'm not so sure
13:51:30 <Taneb> But who uses Haiku?
13:51:32 <mzero> the compiled programs can additional be compiled for iOS and (to some degree with ghcjs) JavaScript
13:51:41 <mornfall> So what about VMS? :-)
13:52:05 <monochrom> VMS would be lovely, but don't sweat on it :)
13:52:19 <notBurn> brb
13:52:20 <mzero> BSD too
13:52:24 <int-e> who wants a virtual memory system anyway (I looked up what "VMS" stands for earlier ... very original really)
13:52:49 <geekosaur> I don't think anyone has shown enough interest to port it to VMS. There's a Solaris port
13:52:53 <notBurn> Back
13:53:08 <monochrom> the thing I like most about VMS is versioning file system. when you modify a file, the old version is preserved.
13:53:30 <mornfall> int-e: It's from 77. It was a big deal back then.
13:53:50 <monochrom> some students may hate this because "I accidentally deleted my file" is no longer an excuse for extending homework deadline
13:53:53 <mzero> yeah, only the systems I could run it on didn't have enough disk space to really rely on the feature!
13:54:39 <int-e> mornfall: I shouldn't complain. I used to use something called "DOS".
13:54:41 <notBurn> hello aero
13:54:54 <Aerouk> o hello notBurn
13:55:03 <mornfall> int-e: MS-DOS or DR-DOS? :P
13:55:04 <monochrom> well, I only had tiny Pascal source files in my account. 5 versions of a 1000-byte file couldn't hurt. it was also in 1990. we had enough disk space for that in 1990.
13:55:12 <int-e> mornfall: mostly the former
13:55:24 <monochrom> I started with Apple DOS
13:55:56 <monochrom> "from the makers of iPhone..."
13:56:03 <mornfall> we had a computer dual-booting DR-DOS and Slackware, at some point...
13:56:39 <darthdeus> guys this is probably a noob question, but if I do  Network.connectTo "example.com" (Network.PortNumber 9999) with a host/port that is closed, i'll get an exception ... how can i rescue from that? it seems like it's calling `fail` or something
13:57:22 <orion> When I was in second grade (~1998) I used to watch my teachers type in their passwords to the systems.
13:57:34 <orion> I got in trouble a lot. :)
13:57:39 <orion> Windows 3.1
13:57:52 <monochrom> it makes me sad that no file system today is versioning. would be so easy to repair cabal hells by telling you how far to roll back.
13:58:06 <orion> monochrom: ZFS?
13:58:07 <aloiscochard> darthdeus: check `try` http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Exception.html
13:58:21 <monochrom> if you use ZFS, good for you
13:58:26 <darthdeus> aloiscochard: thanks!
13:59:11 <orion> monochrom: Why? What do you use?
13:59:23 <notBurn> Is Haskell efficient?
13:59:27 <monochrom> I am just lazy and use whatever ubuntu defaults to
13:59:29 <aloiscochard> notBurn: no
13:59:32 <monochrom> yes
13:59:35 <srhb> notBurn: Sometimes.
13:59:38 <carter> it can be pretty efficient
13:59:45 <carter> its as efficent as you ask it to be
13:59:49 <carter> same as any other tool
13:59:54 <carter> if you ask it to do slow stuff,i'tll be slow
13:59:57 <carter> same as C
14:00:06 <SwashBuckla> does anyone here use pandoc?
14:01:13 <monochrom> I should write a tutorial on exceptions as my next project
14:01:37 <monochrom> meanwhile, I have already written the I/O tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
14:01:37 <carter> pandoc rocks
14:01:52 <SwashBuckla> carter: it does!
14:02:35 <SwashBuckla> (Apologies for repost) Do you know what is going wrong here? http://lpaste.net/102897  It successfully compiles (unfortunately). I am trying to write a pandoc filter to replace a code block include with the parsed version of the document referred to in the namevar.
14:02:49 <geekosaur> SwashBuckla, not sure anyone here uses the API. you should probably send email to the author
14:02:57 <SwashBuckla> ok, I have done so
14:03:24 <carter> email the pandoc list
14:03:28 <carter> jgm is very responsive
14:03:31 <alemedeiros> hey guys, I have a noob problem. I want to read a specific number of lines from stdin and have them in a [String]
14:03:39 <monochrom> it is pretty sad. the one book that tells you about exception, RWH, was published just before the exception lib got changed. the book became obsolete so soon.
14:03:56 <alemedeiros> I already know how many lines I want to read and there will be lines after these lines
14:04:10 <darthdeus> aloiscochard: hmm try doesn't seem to be helping, or at least I think I'm missing something with the types http://lpaste.net/102959
14:04:14 <srhb> alemedeiros: replicateM ?
14:04:19 <monochrom> perhaps "replicateM 10 getLine" will help you
14:04:53 <aloiscochard> darthdeus: ask monochrom to write that damn tutorial about exceptions! ;-)
14:04:59 <orion> hmm
14:05:01 <darthdeus> :D
14:05:10 <alemedeiros> exactly this! thanks srhb monochrom
14:05:22 <darthdeus> monochrom: please :P
14:05:24 <aloiscochard> darthdeus: more seriously googling about it should give you guideline
14:05:32 <orion> I just thought of something: how do you prevent cache/timing attacks on cryptography libraries written in Haskell?
14:05:36 <srhb> alemedeiros: In the future, you can try searching for the type you need
14:05:46 <aloiscochard> orion: there was a thread about it on the cafe
14:05:51 <darthdeus> aloiscochard: i've tried, but the results seem to be very offtopic
14:05:53 <monochrom> the biggest difficulty is with the very general type. it is analogous to read etc.
14:06:13 <srhb> @hoogle Int -> IO String -> IO [String]
14:06:14 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:06:15 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:06:15 <darthdeus> I've only found this http://stackoverflow.com/questions/20301634/haskell-type-error-with-catch
14:06:19 <srhb> alemedeiros: See?
14:06:57 <alemedeiros> I didn't know hoogle had this type of search
14:07:07 <srhb> alemedeiros: One of its greatest powers.
14:07:22 <Aurelia18>  Hi! I give you some videos. I hope you like! http://j.mp/1gAh6Jy
14:07:24 <alemedeiros> I see, I'll be sure to use it
14:07:52 <monochrom> tryIO :: IO a -> IO (Either IOException a); tryIO = try.  now use tryIO instead.
14:08:30 <monochrom> because many different types serve as exceptions of various natures, and the computer cannot easily know which one you're after
14:09:00 <monochrom> especially if you only enter one line of code out of context into ghci
14:09:56 <carter> the answer, as with all things is "by engineering carefully and well"
14:10:26 <monochrom> I agree. but which question does it answer? :)
14:10:50 <aloiscochard> orion: http://ezyang.com/papers/stefan13-scheduling.pdf
14:11:16 <monochrom> I heard that there was a very snarky book review that said, "this book fills a much needed gap" :)
14:11:24 <orion> thank you
14:11:25 <aloiscochard> orion: that is fascinating, but I'm happy I don't have to deal with that ;-)
14:11:32 <aloiscochard> orion: yw
14:11:47 <orion> Are there any changes/updates due to happen to the language any time soon?
14:11:56 <notBurn> Don't know.
14:12:02 <monochrom> no
14:14:08 <carter> 7.8 is out
14:14:17 <carter> people are working on getting some bug fixes sorted out
14:14:24 <carter> for 7.8.3 and 7.10
14:14:28 <carter> then new dev again
14:15:23 <orion> What's the release schedule for the standard libraries?
14:15:37 <srhb> orion: Do you mean base? I think it ships with GHC
14:17:08 <geekosaur> the platform ideally updates spring and fall; it's been waiting on ghc 7.8 though, update is expected to be next month sometime
14:27:25 <notBurn> restart
14:30:50 * hackagebot simple 0.8.1.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.8.1.0 (AmitLevy)
14:30:53 * hackagebot simple-session 0.8.1.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.8.1.0 (AmitLevy)
14:31:45 <stolaruk> I'm getting "Unsupported GHC version Failed to install haddock-2.14.2" on my Mac OS X 10.9.2, GHC ver is 7.6.3... anyone have suggestions?
14:36:14 <mzero> stolaruk: you have to use the version of haddock that went with the compiler
14:36:47 <mzero> stolaruk: use haddock 2.13.2
14:37:04 <stolaruk> mzero: ok I'll try that
14:38:05 <notBurn> :)
14:39:00 <stolaruk> mzero: Looks like it worked, thanks!
14:39:32 <notBurn> :)
14:42:57 <monochrom> what is going on with people installing new versions of haddock?
14:43:36 <stolaruk> monochrom: In my case I was getting "Unsupported GHC version Failed to install haddock-2.14.2" on my Mac OS X 10.9.2, GHC ver is 7.6.3.
14:43:55 <monochrom> no, I mean what happened to them to cause them to install new versions of haddock?
14:44:18 <monochrom> haddock already comes with ghc. if you have ghc, you already have haddock.
14:45:07 <Smilex> Two days of almost constant reading, and I'm yet to figure out what I can use Haskell for. Anyone know some awesome examples of what has been done with Haskell. Just for motivation
14:45:09 <carter> you shouldn't ever cabal install haddock
14:45:12 <stolaruk> monochrom: I reinstalled everything Haskell on my Mac. I installed the Haskell Platform. My SublimeText SublimeHaskell plugin was telling me that it couldn't find haddock. That is what prompted me to try to cabal install it.
14:45:29 <carter> stolaruk: i don't use sublime haskell for a reason
14:45:31 <mzero> haddock comes with the platform
14:45:36 <carter> or evne ghc
14:45:46 <mzero> and is installed in /usr/bin
14:45:55 <mzero> so should have been there
14:45:56 <monochrom> SublimeHaskell wants an older, not newer, haddock. I read its README.
14:46:11 <Rotaerk_> are there any mature game engines available for haskell?  hogre looks like it's still "experimental"
14:46:15 <carter> sounds like a bug
14:46:24 <monochrom> much abridged wording, "if you're at GHC 7.6, your haddock is too new"
14:46:26 <mzero> SublimeHaskell has always been so finicky for me, I finally gave up on it
14:46:26 <stolaruk> carter: What do you use then
14:46:34 <carter> i use cabal build
14:46:36 <carter> to type check
14:46:51 <carter> partly because any of the auto tools die if i open my editor on a large project like ghc
14:47:05 <monochrom> I am neutral to whether you should use SublimeHaskell or not. I'm just setting the facts straight.
14:47:09 <mzero> shame... but sublime text w/cabal build works fine
14:47:22 <carter> mzero: i use cabal build
14:47:28 <carter> i don't use sublime haskell
14:47:31 <monochrom> its suggestion "use a newer haddock" is outdated. it doesn't even understand today's haddock.
14:48:31 <Ankhers> Could someone show my how to write takeWhile using a foldr?
14:48:48 <Ankhers> s/my/me/
14:51:06 <Smilex> Rotaerk_: http://hackage.haskell.org/packages/#cat:Game%20Engine
14:51:48 <Smilex> Rotaerk_: I don't know the specific Haskell engines, but I do know that Irrlicht is a good engine
14:53:24 <Rotaerk_> hmm thanks
14:53:51 <Rotaerk_> I'll check out IrrHaskell and HGamer3D
14:55:52 * hackagebot propellor 0.5.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.5.0 (JoeyHess)
14:57:11 <mzero> Ankhers: that sounds like HW - would you like help thinking about it?
14:57:49 <Lewix> how to think about recursion effectively
14:58:05 <ezrios> Lewix: understand your base case and your recursive case
14:58:43 <Lewix> ezrios: can you please give me an example
14:58:55 <monochrom> recursion is equivalent to divide-and-conquer
14:59:05 <Lewix> ezrios: i understand recursion but...seeing the whole picture is messy in one's head
14:59:31 <Lewix> ezrios: is there an effective way to draw a picture of it in my heead
14:59:33 <Smilex> Lewix: f 0 = 0; f x = f (x-1);
14:59:42 <Lewix> Smilex: oh im not an haskell guy
14:59:53 <Lewix> smarter: i figured you guys would know how to answer it best though
14:59:55 <Lewix> =)
15:00:03 <Smilex> Lewix: That's also plain maths
15:00:22 <Welkin> haskell is nearly standard math
15:00:39 <Lewix> k
15:00:55 <Smilex> Welkin: I was wondering, are "higher order functions" part of standard math?
15:00:56 <monochrom> to find a book on a large bookshelf, divide the large bookshelf into 3 regions. get help from 2 persons to search 2 regions, you search 1 region.
15:01:18 <monochrom> it may happen that those 2 persons are yourself again
15:01:31 <ezrios> @let addEach [] = []
15:01:32 <lambdabot>  .L.hs:157:1: Warning:
15:01:32 <lambdabot>      Pattern match(es) are overlapped
15:01:32 <lambdabot>      In an equation for ‘addEach’: addEach [] = ...
15:01:32 <lambdabot>  
15:01:32 <lambdabot>  <no location info>:
15:01:41 <ezrios> hm maybe I already defined it
15:01:48 <ezrios> @let addEach' [] = []
15:01:50 <lambdabot>  Defined.
15:01:56 <ezrios> @let addEach' (x:xs) = (x+1):(addEach xs)
15:02:00 <lambdabot>  Defined.
15:02:03 <Lewix> Smilex: im just amazed on how some folks come with solutions using recursion, and it seems so obvious to them
15:02:03 <mzero> Smilex: yes
15:02:04 <ezrios> > addEach' [1,2,3,4]
15:02:08 <lambdabot>  mueval-core: Time limit exceeded
15:02:11 <ezrios> > addEach' [1,2,3,4]
15:02:15 <BurnIrl> :)
15:02:15 <lambdabot>  mueval-core: Time limit exceeded
15:02:17 <Welkin> Lewix, it takes some practice
15:02:21 <ezrios> ._.
15:02:29 <Welkin> but once you start thinking in recursion, it is pretty straight forward
15:02:34 <Welkin> you must always find a base case
15:02:41 <ezrios> Lewix: work on a bunch of list problems from say h99
15:02:42 <Lewix> Welkin: whats
15:02:49 <Smilex> Lewix: It does put some strain on my brain. I'm currently going through the Haskell Wikibook, and I just can't solve some of the exercises
15:02:50 <Lewix> Welkin: What's a "base case"
15:02:53 <ezrios> Lewix: but essentially, if you look at the example I gave above to add 1 to each element of a list
15:02:56 <Welkin> the terminating condition
15:03:08 <ezrios> Lewix: you have two cases for a List - either it is empty, or it is an element attached to another smaller list
15:03:12 <Welkin> when does a branch "end"
15:03:18 <ezrios> if the list is empty, then you are done
15:03:30 <ezrios> otherwise you add one to the current element, and call the same function on the rest of the list
15:03:41 <Smilex> Lewix: the base case is a well defined predicate. To be formal
15:04:04 <Welkin> recursion is just another way of performing iteration
15:04:08 <Lewix> I see, i'll try to go with that
15:04:11 <Welkin> but it is better suited to some tasks than others
15:04:21 <monochrom> recursion is hard on people who approach from the "how to execute it" angle
15:04:23 <Welkin> traversing a tree, for example
15:04:38 <Lewix> Welkin: exactly..=) traversing a tree
15:04:40 <Welkin> it is very easy with recursion, but fairly complex to perform using iteration
15:04:53 <monochrom> recursion is easy on people who approach from "how to solve a big problem by solving smaller problems" angle
15:05:01 <Lewix> Welkin: the solution amaze me, it's so clean
15:05:05 <Smilex> Also, does anyone else find recursion to be a whole lot easier in imperative languages?
15:05:14 <monochrom> execution is meant to be hard on humans. it is why we build computers.
15:05:53 <monochrom> solving problems is meant to be easy for humans. it is why we don't build robots to replace humans.
15:06:12 <Smilex> monochrom: Isn't that exactly what we are doing?
15:06:54 <monochrom> well, so far, we build robots, but forbid them from replacing humans
15:06:54 <BurnIrl> Haskell looks cool.
15:06:55 <JagaJaga> Smilex: I can't agree that recursion in imperative is easier :(
15:07:06 <monochrom> recursion is easier everywhere
15:07:20 <monochrom> well, except in BASIC
15:07:46 <Ankhers> mzero: Not official homework. I'm going through the real world Haskell book, and I just don't understand how to do it.
15:08:39 <monochrom> there is a mechanical way to turn a function definition into foldr, if the function definition is already of the right form.
15:09:02 <mzero> well... look at it this way:     you are trying to find an f such that      foldr f z [a, b, c, d]  does what you want.....
15:09:24 <mzero> so      f a (f b (f c (f d z))))    is what you want
15:09:34 <Smilex> JagaJaga: Might just be that I'm used to it
15:10:48 <monochrom> there was a stackoverflow post saying exactly how
15:10:53 <mzero> now think....     if  you are writing     takeWhile p = foldr f z
15:11:04 <mzero> so think about if     a passes the test p, what does f have to do
15:11:13 <mzero> now what if   a doesn't pass the test p, what does f have to do
15:11:22 <mzero> then... basically, it writes itself
15:12:48 <Smilex> In an exercise, I need to add the previous element of a list, to the current element and store that in the same location. However, with recursion I don't know what the previous element was (unless I've misunderstood something). How can this be done? Example, [1,2,3,4,5] becomes [1,3,6,10,15]
15:13:55 <mzero> you need to transform the recursion over the list into    recursion over an "carry" and a list
15:14:16 <Smilex> mzero: Sorry, I didn't get that
15:14:38 <mzero> instead of writing      f (a:as) = ....  f as  .....       a recursion over just a list
15:15:05 <Ankhers> mzero: I've got it working, but I don't understand why it works.
15:15:06 <mzero> you are going to write         f v (a:as) =  .....    f v' as .....       a recursion over a value and a list
15:15:23 <mzero> Ankhers - put your code in the pastebin
15:15:34 <mzero> @pastebin
15:15:35 <lambdabot> Unknown command, try @list
15:15:38 <mzero> er....
15:15:42 <tremon> isn't it possible to just pattern match on a:b:as?
15:15:50 <mzero>  http://lpaste.net/new/haskell
15:15:51 <Smilex> mzero: But the exercise mentioned that the function should only have one parameter
15:16:15 <mzero> so - tremon - perhaps, I'm not sure I get the def of his function, but probably
15:16:37 <monochrom> @src takeWhile
15:16:37 <lambdabot> takeWhile _ []                 =  []
15:16:37 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
15:16:37 <lambdabot>                    | otherwise =  []
15:17:01 <mzero> Smilex: often the outer function is defined in terms of an inner one     which is the recrusive one
15:17:02 <Ankhers> http://lpaste.net/102960
15:17:28 <Ankhers> (it claims there is an error, but it works...)
15:17:49 <mzero> that is a lint error - not a real error
15:18:10 <mzero> so - let's look at takeValue    --- what is a? what b?
15:18:44 <Ankhers> a is a single value, b is a list (I realize the names are bad, I used the type signature to help me out)
15:18:56 <Ankhers> b is a list of a
15:18:57 <monochrom> b is a good name
15:19:16 <monochrom> I use x and y
15:19:23 <mzero> a is the first element of the list --- b is ..... the result of running takeWhile'' on the remainder of the list.....
15:19:23 <Ankhers> Wouldn't it be better to have used bs for a list though?
15:19:40 <mzero> a and as or x and xs is idiomatic
15:19:43 <mzero> but no matter
15:19:44 <monochrom> yes if you have decided it must be a list
15:20:24 <monochrom> the mechanical way of translation a function to foldr does not always assume a list. because it is not always a list.
15:20:33 <mzero> look at it this way, Ankhers ,      foldr takeValue []      expands into something like     takeValue a (takeValue b (takeValue c .... (takeValue z []) ) ) ) )
15:21:00 <mzero> so the second argument to takeValue is going to be... .the expansion over the remainder of the list
15:21:05 <Smilex> mzero: http://lpaste.net/102961 <- Something like that?
15:21:47 <Smilex> I don't think that should work, just wondering if I understood you correctly
15:22:14 <mzero> Smilex: should   scanSum [1, 2, 3] be  [1, 3, 5]   or [1, 3, 6]?
15:22:15 <Ankhers> mzero: yes.
15:22:27 <monochrom> http://lpaste.net/102962
15:22:28 <mzero> Ankhers: so do you "see it" now?
15:22:43 <Smilex> mzero: [1,3,6]
15:23:08 <mzero> does your code do that?  ;-)
15:23:29 <Smilex> mzero: Oh. I just wrote that in the paste bin, didn't test it. Sorry
15:23:47 <mzero> didn't test? the horrors!
15:24:06 <orion> hm
15:24:19 <monochrom> I didn't test my paste either
15:24:34 <monochrom> or rather, I already tested it a million times when I was learning
15:25:10 <Smilex> mzero: nope, it doesn't. But I might be able to fix this, thanks!
15:25:17 <mzero> welcome
15:25:19 <mzero> gotta run.
15:25:41 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml is also worth reading
15:25:43 <Ankhers> And it clicks just as he leaves...
15:25:56 * hackagebot graph-generators 0.1.2.0 - Functions for generating structured or random FGL graphs  http://hackage.haskell.org/package/graph-generators-0.1.2.0 (ulikoehler)
15:26:04 <monochrom> well, you can read my stuff
15:26:06 <Ankhers> Is there any way to leave a message for people in this channel?
15:26:23 <monochrom> yes, example is "@tell monochrom thank you"
15:26:25 <orion> What's the general form one would use to prompt for 10 numbers via stdin?
15:26:39 <orion> And store them all in one list
15:26:40 <Ankhers> @tell mzero Thanks for the help.
15:26:40 <lambdabot> Consider it noted.
15:26:48 <monochrom> oh well no onw wants to read my answers.
15:26:56 <Ankhers> monochrom: thanks
15:27:53 <Ankhers> Would anyone be able to give me a quick description of when you would want to foldl' instead of foldr? Or have a link to a really good tutorial or something on it?
15:28:04 <Smilex> monochrom: well you did decide to make your headers a strong blue. Just sayin'
15:28:16 <BurnIrl> Hello
15:28:29 <monochrom> what's wrong with strong blue. it's exactly right for headings
15:29:02 <Smilex> monochrom: Dark grey is the way. And now I'm officially a poet
15:29:07 <Ankhers> BurnIrl: Greetings
15:29:15 <monochrom> I have already seen strong black, strong white, strong green, and strong red, and they all look weird
15:29:55 <monochrom> dark grey is not so dark after seeing that the main text is pitch black
15:29:57 <orion> ah
15:29:59 <Smilex> monochrom: Never use full value on colors
15:29:59 <orion> replicateM
15:30:11 <monochrom> did I use full value?
15:30:12 <Smilex> monochrom: exactly. The text should then be a lighter grey
15:30:21 <BurnIrl> Hello
15:30:44 <Smilex> monochrom: I don't know. Just giving advice. But do note that I'm not a graphics designer
15:30:53 <monochrom> light grey text faints away.
15:31:17 <k00mi> > bool 1 2 True
15:31:21 <lambdabot>  mueval-core: Time limit exceeded
15:31:26 <k00mi> > bool 1 2 True
15:31:28 <lambdabot>  2
15:31:44 <k00mi> why is the second argument for True? :(
15:31:45 <Smilex> monochrom: depends on how light you make it. Just make it pleasant for the eyes. Fonts also have a lot to say for that
15:32:22 <sx> hi, i want to perform some output in a monad, but don't want the type bound to IO. what is the best way to abstract that part out?
15:32:33 <monochrom> Ankhers: if in "x `op` y `op` z", op is eager on both operands, for example integer addition, use foldl' to reduce memory usage
15:32:46 <Smilex> sx: there's a 'return' function. Maybe it does what you want
15:33:04 <Smilex> k00mi: what do you mean?
15:33:11 <monochrom> pitch black text is pleasant for the eyes. it is the text colour for 500 years.
15:33:25 <geekosaur> sx: can you provide a bit more detail as to what exactly you need?
15:33:34 <k00mi> Smilex: I expected "bool x y True" to evaluate to x
15:33:43 <Smilex> monochrom: Yes, when they were read on paper. Not lightbeams
15:34:45 <Welkin> actually, it only depends on the contrast
15:35:06 <Welkin> paper is not as bright at a white LCD
15:35:17 <Smilex> k00mi: Oh. Sorry, don't know the function bool
15:35:36 <Welkin> as a*
15:35:50 <sx> geekosaur: Well, I do some kind of loop computation in a Monad. In fact it's a simulator for executing parallel instructions on a CPU. Sometimes I want to output the current Simulator state in the loop function, but sometimes I don't want IO to be included.
15:36:21 <atlasblade> https://www.youtube.com/watch?v=bcuqxj5YTA8
15:37:27 <geekosaur> so Monad m => some type using m as a type constructor here
15:39:42 <sx> geekosaur: I still need some way to perform the output in a generic fashion then.
15:40:33 <geekosaur> I would suggest you pass in a function to do the output, and it can be something like (const ()) for the no-I/O case
15:40:43 <geekosaur> mm, not quite
15:41:11 <geekosaur> const (return ()) I think
15:41:29 <geekosaur> :t const (return ())
15:41:31 <lambdabot> Monad m => b -> m ()
15:42:02 <sx> geekosaur: I'll try that, thanks.
15:42:54 <NotBurn> hello
15:43:24 <int-e> k00mi: True is the second data constructor of Bool
15:44:32 <k00mi> int-e: ah, that makes sense
15:44:46 <int-e> > map fromEnum [False..]
15:44:49 <lambdabot>  <hint>:1:22: parse error on input ‘]’
15:44:53 <int-e> > map fromEnum [False ..]
15:44:54 <lambdabot>  [0,1]
15:47:02 <NotBurn> Hello =)
15:50:51 <copumpkin> :t constructN
15:50:54 <lambdabot> Not in scope: ‘constructN’
15:53:06 <abg> In general, is it preferable to not use newer versions of packages that come bundled with GHC?
15:53:37 <geekosaur> it's a very bad idea to upgrade packages that come with ghc
15:54:05 <geekosaur> you will, at the least, break ghc-as-a-library (used by, among other things, most IDEs)
15:54:17 <abg> I see. Thanks.
16:10:08 <Platz> took several hours, but finally got a working 7.8.2 with ghc-mod and cabal 1.21.  ghc-mod has some recent changes that require building from source
16:14:49 <orion> Haskell is to Python as Snowboarding is to Skiing.
16:15:05 <Welkin> that's a poor analogy
16:15:20 <Welkin> it's worse than using birds and bees to explain sex
16:18:42 <HugoDaniel> Haskell is to Python as Beens Snoboarding while having sex with birds is to skiing
16:18:56 <JagaJaga> :D
16:18:57 <augur> HugoDaniel: o_O
16:19:37 <geekosaur> is that the burrito of language comparisons?
16:20:33 <BurnIrl> Hello =)
16:21:01 * hackagebot data-ordlist 0.4.6.1 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.6.1 (LeonSmith)
16:35:15 <monochrom> I want to hear how to use birds and bees to explain sex :)
16:35:48 <Peaker> weird that the default parallelism (no -N) is 1. And weird that -N is significantly slower than 1 in my program
16:36:02 * hackagebot monads-tf 0.1.0.2 - Monad classes, using type families  http://hackage.haskell.org/package/monads-tf-0.1.0.2 (RossPaterson)
16:36:34 <haasn> monochrom: I hope it doesn't involve birds whose names are homonyms for.. other things
16:36:37 <monochrom> the default may be too afraid to use more cores without asking you
16:37:22 <haasn> Peaker: I guess part of the reason is that the threaded RTS introduces additional complexity that will slightly slow down the performance of certain core primitives that otherwise need not be synchronized?
16:37:50 <Peaker> haasn: but I've already built with -threaded
16:38:03 <haasn> Peaker: Maybe it still skips some of that logic if N=1
16:38:07 <monochrom> is -N2 faster?
16:38:10 <Peaker> haasn: maybe
16:38:16 <haasn> I wonder how threaded -N1 compares to non-threaded RTS
16:38:23 <Peaker> -N2 seems either same or slightly faster.. benchmarks have too much variance
16:38:49 <monochrom> "slightly faster" is still bad news
16:39:15 <Peaker> I'm not writing a highly parallel thingie
16:39:26 <haasn> Peaker: what happens when you black hole with -N1? Does it crash with <<<loop>>> or does it hang like with N≥2?
16:39:27 <Peaker> it has a bit of parallelism though it's not clearly worth parallelizing
16:39:36 <Peaker> (I run lots of subprocesses, they get parallelized anyway)
16:39:46 <haasn> solution: add more :P
16:39:50 <Peaker> haasn: not sure, try it out :)
16:41:24 <haasn> Hmm, I actually get <<<loop>>> regardless of what I set -N to, or even if I have -threaded enabled or not
16:41:52 <haasn> I assume it's some form of optimization or I-know-you-don't-need-parallelism-here detection, but I'm not sure what the condition for it is
16:48:28 <gamegoblin> Hmmm advice on using quickcheck with a data type that is exceedingly tedious to create an “arbitrary” class for?
16:49:18 <cdk> gamegoblin: what does your data type look like? It's usually pretty easy to make new arbitrary instances by reusing old ones
16:49:30 <gamegoblin> It’s a parser combinator
16:49:46 <gamegoblin> mmm I’ll go take a peek at what Parsec does
16:51:27 <gamegoblin> Mmmm I can’t find any tests for Parsec....
16:52:06 <gamegoblin> Suppose I could always just write manual proofs...
16:52:57 <vermeille> How do I use monad transformers to make that work? http://lpaste.net/102964
16:53:43 <vermeille> I would like my function getHostPort to behave like in the Maybe monad, and having Reader's facilities
16:54:32 <joseph07> How come there isn't an iff function in the Prelude like Bool -> a -> a -> a? I just wrote it again and I feel like it should exist
16:54:56 <gamegoblin> joseph07: example use case?
16:55:33 <gamegoblin> vermeille: reading… might be able to help
16:55:52 <vermeille> I already did.
16:56:14 <vermeille> pardon my IQ < 65
16:57:30 <joseph07> gamegoblin: As in iff isAny " = false;" " = true;"
16:57:47 <joseph07> gamegoblin: just shorthand for if isAny then " = false;" else " = true;"
16:58:01 <joseph07> gamegoblin: but with the added benefit of currying
16:58:45 <joseph07> gamegoblin: It exists in a number of libraries, according to hayoo
16:59:30 <gamegoblin> Mm gotcha. What I would really like is syntactic sugar like “if then x else y” which would be sugar for “\c -> if c then x else y”
16:59:42 <apples> :t bool
16:59:45 <lambdabot> a -> a -> Bool -> a
17:00:17 <shachaf> Your function is called if' and isn't in base.
17:00:22 <shachaf> "iff" is a confusing name for it.
17:00:43 <gamegoblin> But also the ability to leave off any of the arguments in the sugar, so like “if c then else y” would be short for “\x -> if c then x else y”
17:01:03 <gamegoblin> But I’m probably alone in that desire
17:01:28 <joseph07> shachaf: names aside, do you know why it isn't in base? it seems like something that might belong in Data.Bool or something
17:05:45 <joseph07> gamegoblin: you could define functions for those things like ifbxy, ifxy, ifbx
17:06:18 <joseph07> gamegoblin: just rearrange the arguments to if'-which-isn't-in-base
17:06:19 <gamegoblin> joseph07: I know, but I’d like the sugar in ghc base. But I’m not dying without it.
17:06:57 <joseph07> gamegoblin: yeah I guess we're not dying.. should probably not whine
17:07:27 <joseph07> gamegoblin: I could probably get by without if' too
17:08:58 <gamegoblin> Went to a 24hr hackathon yesterday/today. Realized I am getting old. Don’t really enjoy staying up late like that anymore.
17:23:11 <vermeille> Please, no one to help me with this? I read the RWH chapter thrice without getting why '<-' doesn't get the value out of the Maybe... http://lpaste.net/102964
17:24:53 <artyomkazak> vermeille: first of all, you can't combine `read` and `lookup`, types just don't match
17:26:31 <vermeille> artyomkazak: true, but that's not the issue, just consider I moved the "read" into the return with "return (h, read p)"
17:26:35 <vermeille> still doesnt compile
17:28:00 <vermeille> (updated http://lpaste.net/102964)
17:34:11 <stolaruk> I recently discovered "Control.Exception.Lifted". Is there something similar for "Control.Monad.Trans.State" so I can use "get" and "put" without having to "lift" them?
17:36:09 * hackagebot free 4.7.1 - Monads for free  http://hackage.haskell.org/package/free-4.7.1 (EdwardKmett)
17:37:38 <SrPx> is there a simple way to create a monadic foldr that will return Nothing if anything returns Nothing?
17:38:27 <SrPx> actually, a `map` that will return nothing if anything return nothing
17:39:44 <pavonia> stolaruk: Yes, mtl has MonadState and friends
17:40:07 <stolaruk> pavonia: I'm having a hard time figuring out what package to import
17:40:19 <pavonia> "mtl"
17:40:23 <simon> SrPx, that sounds like mapM inside the Maybe monad?
17:40:28 <stolaruk> ok let me see
17:41:08 <pavonia> module Control.Monad.State
17:42:12 <simon> > mapM (\x -> if x < 5 then Just x else Nothing) [1,2,3,4]
17:42:16 <lambdabot>  mueval-core: Time limit exceeded
17:42:25 <simon> > mapM (\x -> if x < 5 then Just x else Nothing) [1,2,3,4,5]
17:42:27 <lambdabot>  Nothing
17:42:53 <stolaruk> pavonia: Seems to be working, thanks! I don't know how I missed that.
17:43:38 <pavonia> no problem
17:43:48 <simon> SrPx, in spite of mapM sounding like a map, it really seems to have something in common with regular list folding.
17:44:23 <stolaruk> pavonia: I think I was mistakenly importing "import Control.Monad.Trans.State"
17:44:44 <zcd> what is the name of the >>- operator?
17:45:03 <stolaruk> :t (>>-)
17:45:04 <lambdabot>     Not in scope: ‘>>-’
17:45:04 <lambdabot>     Perhaps you meant one of these:
17:45:04 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
17:45:13 <stolaruk> zcd: Do you mean >>= ?
17:45:19 <artyomkazak> vermeille: http://lpaste.net/102969
17:45:43 <artyomkazak> but I've no idea if this is how it *should* be done, I just tried to make the types right
17:45:51 <artyomkazak> no experience with monad transformers
17:46:16 <zcd> stolaruk: not the bind.  i found >>- on http://www.haskellforall.com/2014/04/how-continuation-monad-works.html but not sure what it means
17:46:45 <zcd> the one in the constructor
17:47:07 <pavonia> It *is* the constructor
17:47:07 <stolaruk> zcd: "http://www.haskell.org/haskellwiki/Pronunciation" tends to help but it's not listed there apparently
17:47:47 <simon> SrPx, or you could use foldM.
17:48:32 <zcd> oh got it, thanks
17:48:49 <pavonia> Err wait, it's a record field here
17:50:29 <simon> > foldM (\result num -> if num < 5 then return (result + num) else Nothing) 0 [1,2,3,4]
17:50:31 <lambdabot>  Just 10
17:50:36 <simon> > foldM (\result num -> if num < 5 then return (result + num) else Nothing) 0 [1,2,3,4,5]
17:50:37 <lambdabot>  Nothing
17:51:55 <simon> I guess this is left-folding rather than what you requested.
17:53:18 <simon> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#foldM
17:54:19 <artyomkazak> vermeille: to understand what's going on, consider this version: http://lpaste.net/102972
17:54:57 <fffffff> hey, I'm currently debating whether or not to learn haskell to write server programs. I was wondering how the tooling for haskell (cross compilation, profiling etc.) is
17:55:21 <artyomkazak> you can say that `lookup` works in Maybe monad, and to make it an App action, you have to `lift` it
17:55:39 <artyomkazak> asks won't work here because it's more specific
17:56:38 <Aetherspawn> fffffff: it's pretty good
17:57:00 <Aetherspawn> I don't know why cross compilation is relevant for servers though
17:57:21 <danilo2_> Hello! :)) Is there in haskell any fuction which will return a list of logged in users (Unix systems) - so it would be equivalent to "who" command
17:57:36 <danilo2_> or even
17:57:41 <danilo2_> "users" command
17:58:19 <SrPx> simon: looking it, thanks
17:59:15 <Aetherspawn> danilo2: try the unix package
17:59:20 <Aetherspawn> but I doubt a function like that exists
18:00:16 <vermeille> artyomkazak: That's interesting, but none of your versions seems to compile properly neither :(
18:00:25 <Welkin> is there an easy way to filter a list for every other element?
18:00:55 <danilo2_> Aetherspawn: I was looking at unix package before ,, but without luck. Why such function does not exist? this is one of the most basic functions in unix world ...
18:01:06 <artyomkazak> vermeille: hm-m. They do compile on my system. Paste error logs, please
18:01:11 * hackagebot extensible-effects 1.5.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.5.0 (BenFoppa)
18:01:11 <simon> danilo2_, readProcess "who" [] []
18:01:15 <vermeille> artyomkazak: oh yes it does, I just wrote "asks" instead of "ask"
18:01:51 <simon> :t System.Process.readProcess
18:01:57 <lambdabot> FilePath -> [String] -> String -> IO String
18:01:58 <Aetherspawn> danilo2_: because if a function like that existed there would be some 300 other functions
18:02:16 <Aetherspawn> just invoke the command line utility and parse it.
18:02:40 <Aetherspawn> in haskell land we try as hard as we can not to write programs which are platform specific.
18:02:47 <danilo2_> simon, Aetherspawn: Hmm, ok, I'll do it this way, thanks :)
18:03:24 <danilo2_> Aetherspawn: exactly! And this was the reason I was asking about it - such function will work only in unix world
18:03:48 <vermeille> artyomkazak: I like your `lift . lookup "something" =<< ask` version
18:04:24 <simon> danilo2_, it might also have to address how this information is obtained, if not through parsing `who`.
18:04:28 <artyomkazak> yeah, the first one wasn't any obvious or idiomatic, I guess
18:04:42 <simon> danilo2_, different unix systems dot his differently.
18:04:53 <Aetherspawn> or at all.
18:06:26 <danilo2_> simon: Ok, parsing "who" output in such case is not wrong. But it would be much better to implement not platform specific version, whcih will work on windows also :)
18:07:04 <vermeille> artyomkazak: Okay I think I got it. It's not 100% clear in my mind, but way better than 10 minutes ago, thanks!
18:07:04 <simon> danilo2_, it sounds like you should write such a library. ;-)
18:07:14 <augur> so, how's this for an idea:   instead of   foo :: C a => ... ; foo = ...   you do   foo :: ... ; foo = require C a in ...
18:09:38 <danilo2_> simon: It looks like who is implemented distribution independed, here is its code: http://lpaste.net/102974 . I'm thinking about making such library. As always - I prefer asking before making something new :)
18:09:39 <Aetherspawn> danilo2_: what could you possibly be writing that needs `who` output
18:09:44 <Aetherspawn> which should not be platform specific?
18:10:24 <geekosaur> danilo2_, what is "who" on Windows?
18:10:35 <Aetherspawn> (and if you make a library to do it, please call it hoo!)
18:10:37 <danilo2_> Aetherspawn: Simple example - linux / windows server (yes, you can run servers on windows) - a program which tracks how many users are logged in - if the count drops to 0, the machine is shut down
18:11:12 <danilo2_> geekosaur: qwinsta
18:11:19 <Blabber> hey haskell programmers. What tools and ide's do you use for haskell?
18:11:27 <danilo2_> geekosaur: As always - name of the command is very intuitive :D
18:11:28 <geekosaur> but, if you want a POSIX general interface, you'll want to wrap the getut* functions via the FFI
18:11:32 <Aetherspawn> trying to use emacs
18:11:35 <Aetherspawn> had good times with vim
18:11:41 <Aetherspawn> sublime text is excellent for non power usage
18:11:44 <Blabber> eww vim...
18:12:11 <Aetherspawn> vim doesn't keep resetting my theme on me..
18:12:25 <startling> Aetherspawn, "resetting your theme"?
18:12:26 <Aetherspawn> despite pressing the "save this for the future" option, emacs still resets my theme every session. zzz
18:12:31 <startling> Aetherspawn: heh
18:12:32 <geekosaur> danilo2_, so did you happen to notice that GNU who doesn't know how to access that because it isn;t based on POSIX utmp functions?
18:12:38 <startling> Aetherspawn: that's a different "save this for the future"
18:12:39 <danilo2_> geekosaur: What is getut*?
18:12:42 <Blabber> so for haskell you don't use IDEs?
18:12:46 <Aetherspawn> oh?
18:12:58 <startling> Aetherspawn: it's "save the hash of this theme and consider it safe for the future"
18:13:06 <Aetherspawn> doh
18:13:11 <startling> Aetherspawn, you should put (load-theme 'whatever) in your ~/.emacs
18:13:34 <Aetherspawn> ooh, I thought the theme selector customizer thing might do that automatically
18:13:38 <Aetherspawn> thanks.
18:13:46 <startling> nope. emacs saves very little automatically.
18:14:08 <startling> cutomization groups are the main thing, but they're kinda gross
18:14:15 <Platz> Blabber: If you really want an IDE, there's a plugin for eclipse (EclipseFP), but I think more people use either vim or emacs
18:14:48 <Blabber> Ewwww. emacs.  Isn't that like 40 years old?
18:14:59 <danilo2_> geekosaur: To be honest, not. I do not know what are exacly utmp functions, but I'm just reading about it :)
18:14:59 <Aetherspawn> used the eclipse plugin in the past actually, it was quite good
18:15:02 <Aetherspawn> just, eclipse
18:15:04 <Aetherspawn> I can't get used to it
18:15:10 <Blabber> and i thought vim or vi was like 70 years old.
18:15:12 <artyomkazak> Welkin: from “Blow your mind” page on hwiki: fst . foldr (\a ~(x,y) -> (a:y,x)) ([],[])
18:15:56 <jakex> how can I handle this without removing either package? per file/ghci/cabal file basis. "Ambiguous module name `Crypto.Random': it was found in multiple packages: crypto-random-0.0.7 crypto-api-0.13"
18:15:57 <Platz> Aetherspawn: i like eclipse's stability, but not a fan of the keybindings
18:16:09 <geekosaur> danilo2_, http://linux.die.net/man/3/getutxent
18:16:17 <Aetherspawn> jakex: THAT particular conflict
18:16:21 <Aetherspawn> has caused me many a cabal nuking
18:16:27 <Blabber> Can you use Visual Studio for haskell?
18:16:29 <Aetherspawn> I don't touch crypto packages anymore for that very reason
18:16:38 <Aetherspawn> Blabber: no, I started writing a plugin
18:16:46 <Aetherspawn> but there is work that needs to be done in GHC before it can really be "nice"
18:16:46 <artyomkazak> jakex: use PackageImports?
18:17:10 <geekosaur> there used to be a VS plugin for Haskell but it broke with every new VS release and the maintainer gave up trying to track it
18:17:13 <Blabber> yo i gotta log out. Parents making me do sh*t.
18:17:26 <Aetherspawn> one of the major reasons ghc won't happen for visual studio is because
18:17:39 <Aetherspawn> visual studio has this uniform "link everything together" kind of environment setup
18:17:43 <danilo2_> geekosaur: Thank you
18:17:44 <Platz> Aetherspawn: they did a good job on the node.js VS plugin by keeping the feature set minimal.  I wonder if the same technique could make things easier
18:17:45 <Aetherspawn> but ghc can't link native on windows
18:18:53 <Platz> Aetherspawn: even if it shells out out ghc.exe ?
18:19:07 <Aetherspawn> it uses a mingw toolchain
18:19:12 <Aetherspawn> which is incompatible with visual studios link.exe
18:19:16 <jakex> artyomkazak thanks. what about third party packages that depend on either? I haven't encounter that problem yet, but how can I handle it if I do?
18:19:17 <Aetherspawn> object files are incompatible too
18:20:26 <Aetherspawn> a "non-adhoc" feeling haskell plugin for visual studio would use ghc to compile hs files to windows compatible object files and then use the visual studio linker to produce visual studio compatible binaries and stuff with information VS can understand
18:20:30 <Aetherspawn> also maybe link with C code and whatnot
18:20:38 <Aetherspawn> its .. a long while off.
18:20:46 <Welkin> interesting artyomkazak
18:21:26 <Aetherspawn> there's an 8(?) year old ticket on the trac that talks about it
18:21:39 <Platz> Aetherspawn: I say just make a clean separation, keep as much out of VS as possible
18:21:58 <Platz> but then again, I wouldn't know how to go about such things ;)
18:23:42 <Aetherspawn> that's the thing though. If you say "once you use haskell in a project, you must only use the gnu toolchain" you lose half of visual studios features
18:24:05 <Aetherspawn> project properties stop working, you have to write an entire mingw compatibility plugin thing too to do a custom mingw build
18:24:29 <Aetherspawn> it's almost like "well, why not just use Sublime Text then?" if you're only after syntax highlighting and project structure
18:24:47 <Aetherspawn> eclipsefp is a better match
18:24:54 <Aetherspawn> it's already designed for a mingw toolchain
18:25:58 <Platz> that makes sense
18:26:21 <Platz> is there any way to tell cabal to generate documentation for an installed package without reinstalling it?
18:26:22 <orion> What are <?> and <*> called?
18:26:36 <Aetherspawn> <?> is some documentation thing from parsec iirc
18:26:55 <Aetherspawn> and <*> is kind of like fmap
18:26:59 <Aetherspawn> :t (<$>)
18:27:00 <Welkin> I usually call <*> "Applicative star"
18:27:01 <Aetherspawn> :t (<*>)
18:27:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:27:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:27:09 <Welkin> I haven't seen an actual name for it
18:27:18 <startling> Platz, you can build it in a sandbox
18:27:51 <dmwit> I would call <*> "ap".
18:27:54 <Platz> startling: thanks that works
18:28:00 <dmwit> :t ap -- because it's this in disguise
18:28:01 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:28:17 <startling> I think ap is <*> in disguise, rather. :)
18:28:25 <Aetherspawn> @src ap
18:28:25 <lambdabot> ap = liftM2 id
18:29:17 <startling> (<*>) was at one point m a -> m b -> m (a, b) (which is equivalent), so the operator makes sense in that light.
18:29:22 <startling> it's "lifted product" or something.
18:30:13 <dwcook> I get an error while trying to install pipes-extra. Any ideas what to do? http://lpaste.net/102975
18:30:45 <Aetherspawn> dwcook: cabal update ?
18:31:01 <dwcook> Aetherspawn, did just beforehand.
18:32:04 <danilo2_> I understand there is also no such method in haskell like "halt" (shut down the computer)? I'm asking only because I could overlooked something :)
18:32:19 <dwcook> danilo2_, there could be in IO
18:33:23 <geekosaur> danilo2_, not very portably
18:34:04 <dwcook> halt = runProcess "/bin/halt" [] -- or something like this; not very portable, as mentioned
18:34:05 <geekosaur> (a) requires root access (b) depending on what you're running it on, it looks like "shutdown -h now" or "shutdown -y -g0 -i0" or ...
18:34:06 <danilo2_> dwcook: If you are talking about System.IO, there is no such method. geekosaur: ok, thank you
18:35:03 <geekosaur> there is no regular system call to halt the system. (there is one that you should never use directly because you prevent system daemons from cleaning up, shutting down things like database managers, etc.)
18:35:18 <geekosaur> and such syscalls are even less standard than shutdown commands
18:36:30 <danilo2_> geekosaur: Ok, so the only/preferred way to implement it on unix system is just by calling "halt" command? (Assuming I know the program is running as root)
18:37:07 <geekosaur> don't call halt directly, use the shutdown command. on linux it's "shutdown -h now" (and again it must be done as root)
18:37:55 <geekosaur> there may still be some linuxes where /sbin/halt skips the system shutdown commands and can screw things up as a result
18:38:06 <artyomkazak> jakex: I've just checked, cabal doesn't allow bringing into scope modules which don't belong to packages listed in build-depends
18:38:55 <Aetherspawn> osx seems to have halt. I don't really want to run it.
18:39:12 <artyomkazak> so in theory there can't ever be a module name clash
18:39:24 <danilo2_> geekosaur: ou, I did not know shutdown is not equal to halt. Thank you!
18:39:29 <geekosaur> I don't even know how you'd properly shut down PS X from the command line
18:39:51 <Aetherspawn> same way probably, shutdown
18:40:01 <geekosaur> danilo2_: on some but not all linux distributions, it will just run "shutdown -h now" unless passed a special option to do its old immediate halt behavior
18:40:21 <geekosaur> but what it does will depend on the linux distribution, and it can lead to (usually very unfortunate) surprises
18:40:41 <dwcook> I was actually unaware it wasn't just the same as `shutdown -h now`. Someone recently told me I could just do `halt` instead :P
18:40:54 <geekosaur> somestimes yes, sometimes no
18:40:56 * dwcook should've done the research
18:41:33 <geekosaur> it is not something I want to rely on. it's *probably* safe on the likes of fedora and debian, but I'd be afraid to try it on slackware
18:42:29 <danilo2_> geekosaur: Thank you for the info :) I will use shutdown instead :)
18:52:16 <dwcook> By the way, I managed to simplify my problem to just trying to install the categories package in a previously empty sandbox. It still gives "‘typeOf2’ is not a (visible) method of class ‘Typeable2’". This is with the very latest GHC and Cabal.
18:53:11 <dwcook> Do I just have to wait for the categories author to update their package for latest GHC?
18:53:39 <dwcook> Ah, looks like it's edwardk
18:53:42 <carter> yup
18:53:58 <dwcook> @tell edwardk categories fails to build in an empty sandbox with latest GHC and cabal.
18:53:59 <lambdabot> Consider it noted.
18:54:59 <startling> dwcook: yep, that's a 7.8 change
18:55:17 <startling> (there's no longer a Typeable2, just a nicer Typeable)
19:02:36 <dwcook> I suppose if I want to do any development in the meantime I should use an older GHC
19:04:59 <dwcook> edwardk, o/ I left you a message with lambdabot moments ago.
19:06:28 <edwardk> @mssages
19:06:30 <edwardk> @messages
19:06:30 <lambdabot> You don't have any messages
19:08:03 <dwcook> Odd
19:08:08 <dwcook> I said: categories fails to build in an empty sandbox with latest GHC and cabal.
19:08:40 <dwcook> The error is: ‘typeOf2’ is not a (visible) method of class ‘Typeable2’.
19:16:12 * haasn wonders if edwardk used that command to demonstrate to dwcook that he had already read it
19:16:55 <dwcook> That's a possibility I considered afterwards but it wasn't an important enough point to note
19:20:38 <haasn> We shall never know
19:39:40 <dwcook> How do I tell GHC to use a cabal sandbox's packages? I forget the relevant flags and/or terminology.
19:42:03 <edwardk> dwcook: what ghc?
19:42:16 <edwardk> dwcook: categories isn't 7.8 friendly yet
19:42:25 <edwardk> the HEAD branch is, but i don't like it yet
19:42:35 <dwcook> edwardk, 7.8.2
19:42:52 <dwcook> I've decided to revert to 7.6.3 for now so I can use it
19:43:19 <edwardk> i built the current master of github.com/ekmett/categories, to see what a 7.8 centric version would look like, but its not ready
19:44:13 <edwardk>  made som gratuitous API changes, broke older versions. my plan is to cherry pick some of the changes back to something closer to the released categories, since it has real dependencies
19:44:29 <edwardk> so i can't just gratuitously break it ;)
19:44:46 <dwcook> Yeah, I found the problem while trying to build pipes-extra
19:44:53 <dwcook> Which has (|||) which I really want :P
19:46:16 <dwcook> Wait, that's odd… The result that came up on Hoogle is not what I expected
19:46:33 <dwcook> Doh, I might be using the wrong package
19:47:57 <dwcook> Oh heh, pipes-extras, with an s
19:48:23 <gamegoblin> edwardk: Any chance you could take a peek and give some feedback at my toy parser combinator library I have written over the last few weeks? https://github.com/grantslatton/JustParse
19:55:44 <orion> "If you use the data keyword to wrap a type, there's some overhead to all that wrapping and unwrapping when your program is running. But if you use newtype, Haskell knows that you're just using it to wrap an existing type into a new type (hence the name), because you want it to be the same internally but have a different type."
19:55:58 <orion> What does "wrap a type" mean?
19:56:31 <artyomkazak> orion: data Wrap x = Wrap x
19:56:40 <artyomkazak> ouch
19:56:52 <artyomkazak> data Wrap = Wrap Int
19:57:42 <dwcook> orion, newtypes are representationally the same as the type on the right-hand side; types declared with data are not
19:58:23 <dwcook> (Even in the cases where newtype and data overlap)
19:58:43 <dwcook> (and by "overlap" I mean you can write one or the other and either would compile)
19:59:25 <orion> When does this come up IRL?
20:01:13 <dwcook> orion, the compiler can optimize a newtype away to the underlying type. It cannot do the same of data.
20:03:58 <dwcook> orion, you might find this article of use http://www.haskell.org/haskellwiki/Newtype
20:04:56 <orion> thank you
20:06:22 <zq> it can with -XBangPatterns
20:07:23 <geekosaur> actually BangPatterns isn't needed for ! in data
20:07:36 <edwardk> gamegoblin: there is a chance, but i'm kinda buried right now. bbiab
20:07:50 <zq> geekosaur: uh what?
20:09:13 <geekosaur> zq: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-710004.2.1
20:11:16 <geekosaur> that said, those !s are in the wrong place to enable a compiler to optimize away a `data`; it's the uses of that data, not just its contents, that would need to be strict
20:11:20 <hiptobecubic_> gamegoblin, codereview.stackexchange
20:12:09 <gamegoblin> hiptobecubic_: Complex haskell questions very rarely get answers on there. I’ve answered a few Haskell questions myself, but they were all fairly short.
20:14:37 <johnw> yeah "bang patterns" does sort of imply it has to do with patterns ;)
20:17:30 <Welkin> what is the purpose of ($) in zipWith ($) fs xs
20:17:43 <johnw> it applies every function in f to every argument in xs
20:18:14 <johnw> it should be equivalent to: getZipList $ ZipList fs <*> ZipList xs
20:18:39 <Welkin> okay
20:18:48 <johnw> > zipWith ($) [f, g, h] [a, b, c]
20:18:50 <lambdabot>  No instance for (GHC.Show.Show c0)
20:18:50 <lambdabot>    arising from a use of ‘M80513871084307007898137.show_M80513871084307007898...
20:18:50 <lambdabot>  The type variable ‘c0’ is ambiguous
20:18:50 <lambdabot>  Note: there are several potential instances:
20:18:50 <lambdabot>    instance [safe] GHC.Show.Show
20:19:00 <johnw> well, it would be: [f a, g b, h c]
20:20:00 <hiptobecubic_> gamegoblin, oh? I didn't realize it wasn't getting good traffic
20:20:23 <hiptobecubic_> gamegoblin, asking on regular stack overflow and wording it sneakily is probably more likely to work then
20:20:57 <gamegoblin> hiptobecubic_: codereview is good for common languages. Not as good for for Haskell. The people who answer on codereview are all in this channel anyway ;)
20:21:21 <hiptobecubic_> gamegoblin, yes but they don't have to be actively idling here to see it
20:21:30 <gamegoblin> hiptobecubic_: I asked edwardk specifically because he has a lot of experience with monadic parser combinators.
20:21:39 <Welkin> I'm going through the exercises on http://www.seas.upenn.edu/~cis194/lectures.html
20:22:04 <Welkin> there are no posted solutions, but it is helpful
20:22:28 <hiptobecubic_> gamegoblin, sure, but he has a lot of experience with a lot of things.
20:23:07 <gamegoblin> hiptobecubic_: That’s true, but those things aren’t why I asked him ;)
20:24:22 <Welkin> there is no way to use point-free style with guards,is there?
20:25:41 <gamegoblin> Welkin: no
20:29:00 <dmwit> Well, there certainly is. But without points there aren't very many interesting guards to write.
20:36:47 <jakedust> silly question: is anyone actually using Hugs?
20:38:06 <pavonia> Yes, even at university, unfortunately
20:38:24 <geekosaur> there are all too many intro haskell courses that use it, sadly
20:38:38 <geekosaur> someone needs to teach then about winghci already
20:39:10 <Welkin> why not just ghci?
20:39:54 <geekosaur> you'd think that, I might think that, they usually think they need a pointy-clicky
20:40:28 <pavonia> I think an argument for Hugs are the better/newbie-friendly error messages
20:40:50 <Welkin> if a student studying computer science needs a gui, they are in trouble
20:41:09 <geekosaur> not these days, sadly
20:41:21 <geekosaur> command lines are advanced topics
20:42:38 <jakedust> geekosaur: most cs courses I know focus on the theory, so this is the kind of thing they just hope the students will learn by themselves
20:43:05 <jakedust> (which in turn means we get interns who can't have never even heard of bash.)
20:43:14 <geekosaur> jakedust: I went through the early CS stuff at CMU. windows pointy clicky all the way. :(
20:43:15 <benwis> what's bash
20:43:26 <geekosaur> it was apparently the last year they used c++ instead of java too
20:43:35 <monochrom> one should learn both terminal and gui, both linux and windows
20:43:58 <Welkin> why any respectable university uses C++ or Java is a mystery
20:44:15 <augur> Welkin: its not that much of a mustery
20:44:19 <benwis> well C does have applications in microcontroller design
20:44:21 <monochrom> the other pole, "xterm is a container of all editors and emails, and launcher of more xterms", is just as ignorant
20:44:23 <Welkin> unless they are a vocational training facility for workers
20:44:30 <augur> respectable universities want to produce hirable graduates
20:44:32 <Welkin> rather than bastions of knowledge
20:44:40 <augur> knowing C++ or Java makes you very hirable
20:44:42 <geekosaur> Welkin: they more or less *are*
20:44:57 <geekosaur> because that is what industry wants from them
20:46:05 <geekosaur> and industry provides quite a few kickbacks to get what they want (in ECE we got Dell computers by the truckload in return for being a ready supply of grunts^Wfresh CS grads)
20:47:22 <Welkin> that is bothersome
20:47:40 <augur> Welkin: welcome to the world :)
20:47:46 <geekosaur> ^
20:47:53 <Welkin> it is true that every professor assumes you are only in uni to get a job
20:48:00 <Welkin> it irritates me
20:48:24 <augur> Welkin: its not just professors, its the culture
20:48:32 <Welkin> the job fairs are the worst
20:48:51 <Welkin> students line up like cattle to submit their credentials and be judged as worthy or not
20:50:53 <monochrom> I have met few profs who assume you just want to get a job
20:51:11 <Welkin> upon mentioning haskell/lisp/other language not commonly used in industry to another student, their response was, "Why would you learn such a useless language? Learn something that people actually use."
20:51:18 <spaceships> i find grad school to be a lovely culture for learning CS (willing to admit that this is not universal)
20:51:36 <monochrom> in fact, their demands in their courses are so obviously, utterly incompatible with getting a job
20:52:38 <Welkin> monochrom, they are not preparing you for a job, they are just there to hand out arbitrary grades based on some arbitrary scale with mostly arbitrary objectives
20:53:34 <gamegoblin> Welkin: I think you’re being a little too cynical
20:53:46 <Welkin> it is absolutely true
20:53:54 <Welkin> I took the same course with two different professors
20:54:04 <monochrom> although, there is common ground between job demands and intellectual demands. it is: there will be things you have to figure out on your own, there will be responsibilities you have to bear.
20:54:05 <Welkin> with one I would have received an F
20:54:06 <gamegoblin> It might be true in your experience
20:54:14 <Welkin> with the other, with the exact same work, I got a B
20:57:46 <gamegoblin> I had a pretty decent uni experience — not amazing, not awful. I think it was positive for sure. Learned plenty, got a good job, etc
21:16:27 <xunie-laptop> So I'm using HDBC, and I get to pass SqlValues to the 'execute' function. My question is: are these properly escaped when I run "INSERT INTO `table` (`name`) VALUES (?)"?
21:17:18 <xunie-laptop> The docs don't say anything... so.
21:17:27 <Welkin> I think re-implementing standard library functions is a good exercise for learning a language
21:17:56 <Welkin> I have been doing that so far tonight
21:26:51 <pavonia> xunie-laptop: What backend are you using?
21:28:53 <xunie-laptop> MySQL.
21:29:09 <xunie-laptop> (I forgot to mention that, sorry.)
21:33:11 <pavonia> xunie-laptop: It's hard to tell from the source, but it looks like it doesn't
21:33:50 <pavonia> At least I can't find any backend-independent function that does that
21:34:11 <pavonia> And the MySQL backend just copies the strings
21:45:42 <Javran> hi, when I look at the Set-R category, its description says "sets with a right action from a given monoid R", what does "set with an action" mean?
22:05:11 <augur> Javran: maybe try ##categorytheory :)
22:05:24 <augur> not that its active right now
22:06:57 <Javran> augur: thanks, I think I can understand that now.
22:10:29 <lesur> Does anyone know what version of opengl HOpenGl supports? Reddit seems to say 4.4. Is this correct?
22:12:45 <zq> fffffffffffffff
22:18:58 <redtricycle> What's the easiest database method?  i.e. I only want to store a list of hashes, and check against that list .
22:19:04 <redtricycle> ...flat text file?
22:19:09 <redtricycle> or is there an awesome haskell way to do it?
22:19:16 <carter> files ar enice
22:19:32 <carter> don't use read and show
22:19:38 <carter> you'll regret it 20 years later
22:19:42 <carter> when they get fixed
22:19:43 <carter> :)
22:19:58 <redtricycle> any recommendations on what to use instead?
22:20:03 <redtricycle> My haskell experience is ~2 weeks
22:20:04 <redtricycle> :/
22:20:11 <carter> well
22:20:13 <carter> honestly
22:20:18 <carter> you can abuse read and show that way
22:20:28 <carter> just know "tis quick an dirty"
22:20:29 <carter> :)
22:21:18 <carter> redtricycle: whats your cs / programming background
22:21:31 <carter> granted, its so quick and dirty, ghc uses it for its config file
22:21:34 <carter> :)
22:21:52 <carter> (though seriously, it ws surprising when i learned that)
22:22:22 <lesur> wait, so show and read are not good things to use?
22:22:41 <carter> well
22:22:41 <bts-> carter: what's the less quick-and-dirty method? Data.Serialize?
22:22:45 <carter> well
22:22:54 <carter> show and read are really for interactive stuff an debugging
22:23:01 <carter> like
22:23:09 <redtricycle> carter: python, several years. assembly, couple of months, c++, 1yr
22:23:12 <carter> cool
22:23:21 <carter> redtricycle: we'll get you contribing to ghc soon!
22:23:25 <redtricycle> >_>
22:23:26 <redtricycle> <_<
22:23:43 <carter> redtricycle: no, i'm serious
22:23:45 <redtricycle> just giving my haskell background so answers dont go above my weight class :p
22:23:54 <carter> ask anyone here
22:24:04 <carter> i spend too much time talking folks into writing their first ghc patch
22:24:05 <carter> :)
22:24:43 <carter> lesur: bts-  redtricycle  well, have you seen what the show instance for  Map and others look like?
22:24:52 <carter> its fromList [(k1,v1)....]
22:25:15 <carter> now
22:25:18 <carter> this is sometimes fine
22:25:29 <carter> but depends on the data structure size!
22:25:37 <carter> and what you want to do with it
22:26:30 <redtricycle> using an api to get a list of my bookmarks (each bookmark has a hash), and I want to email certain bookmarks and not email the ones I've already sent
22:26:42 <redtricycle> not going to be large...
22:26:52 <redtricycle> maybe adds 100 entries a year
22:27:11 <carter> ok :)
22:27:13 <carter> cool!
22:27:20 <carter> use read and show on things for now
22:27:26 <redtricycle> sounds good!  will look into it
22:27:37 <carter> figure out pretty things and schemas and data types and formats later
22:31:58 <Platz> redtricycle: pinboard?
22:32:38 <carter> oh
22:32:39 <carter> yeah
22:32:43 <carter> pinboard is awesome
22:32:49 <carter> i have ... several gigabytes there
22:32:54 <Platz> totally addicted
22:33:00 <carter> of bookmarked pdfs
22:33:03 <carter> that i never read
22:33:04 <carter> ever
22:33:13 <Welkin> hoarder!
22:33:22 <Welkin> you will drown in your own misery!
22:33:26 <Platz> i bookmark so i don't have to read :)
22:34:16 <carter> Welkin:  i have 4gbs of pdfs locally of every cool paper i've ever read or stumbled across
22:34:20 <carter> in ever topic i'm intersted in
22:34:49 <redtricycle> Platz: pinboard!
22:35:30 <Platz> i enjoy the admin's musings as well
22:35:30 <redtricycle> I actually already use ifttt with pinboard, that does the emailing, but recreating it in Haskell to learn :)
22:35:38 <Platz> maciej
22:36:38 <Platz> redtricycle: nice, lots of data to mine there
22:56:36 <startling> Can I use OverloadedLists with Set today, or do I have to wait until containers includes an instance or something?
22:57:58 <DarkFox> sinetek >>= sort >>= storeFile
22:58:52 <sinetek> haha
23:07:45 <carter> startling: you could write some orphans
23:08:05 <startling> carter: I guess so. I'm surprised they aren't anywhere yet though.
23:08:06 <carter> its weird, i'm writing a pointer arith lib in haskell, and its pretty
23:08:11 <carter> startling: write a patch
23:08:14 <carter> or check head
23:08:37 <carter> tibbes been busy getting the new cabal ready
23:09:25 <startling> ah, https://github.com/haskell/containers/commit/0e99ba8851f875c4b44631c7afad3b70e74842c2
23:09:40 <startling> 6 days old, probably have to wait for the next release. :)
23:10:05 <startling> or cabal sandbox add-source
23:10:40 <carter> or boht!
23:10:51 <startling> at the same time!
23:11:48 <frankbro> Anyone using ghcmod or hdevtools plugins for vim? It can't seem to find the tools within ~/.cabal/bin even tho its in both my system path and runtime path. It says TOOL_NAME: TOOL_NAME is not executable!
23:12:09 <frankbro> doing :!~/.cabal/bin/ghcmod works tho
23:15:25 <carter> frankddi you cabal install them?
23:16:08 <frankbro> carter, of course, running them manually works
23:16:31 <carter> ah
23:16:32 <carter> no clue
23:16:33 <Platz> frankbro: for ghc-mod vim you also need vimproc
23:16:39 <frankbro> I got it
23:16:46 <Platz> and manually compile it
23:17:00 <carter> startling: my deep insight this weekend was my new piece of magic   basicAddressRegion :: PrimMonad m => marr (PrimState m) rank a -> Address -> m AddressInterval
23:17:22 <carter> i'm really excited
23:17:25 <carter> about how it works
23:17:26 <carter> :)
23:17:43 <startling> I don't understand the type signature, but congrats!
23:17:45 <Platz> google poetics: http://i.imgur.com/oJJOGTY.png
23:18:07 <startling> Platz: that's pretty funny
23:18:21 <carter> startling:  you know how theres fortran and c order arrays?
23:19:12 <startling> carter: is that row-major vs column-major?
23:19:15 <carter> yes
23:19:21 <startling> yes.
23:19:24 <carter> so
23:19:27 <carter> when you slice them
23:19:38 <carter> you get thing sthat ar still in that format
23:19:57 <carter> *things that are still
23:20:08 <carter> BUT
23:20:14 <carter> you can't just +1
23:20:16 <carter> to get the next element
23:20:45 <carter> this crazy wee primop
23:20:48 <carter> lets me ask
23:21:12 <carter> "given where i am in the array, what range can i access with a uniform stride of +k"
23:21:14 <carter> where k could be 1
23:21:19 <carter> but migth be some other constant
23:22:24 <carter> ie i want looping over chunks of arrays to be as cheap as pointer arith
23:22:29 <carter> but a bit safe
23:22:31 <carter> r
23:24:56 <redtricycle> carter: was this what you were talking about Read/Show? http://stackoverflow.com/questions/830021/haskell-writing-text-files-and-parsing-them-back-to-original-format
23:25:32 <carter> :t show
23:25:33 <lambdabot> Show a => a -> String
23:25:34 <startling> carter: huh, neat
23:25:34 <carter> :t read
23:25:35 <lambdabot> Read a => String -> a
23:27:26 <carter> startling: so  its a bit bonkders
23:27:37 <startling> a bit. :)
23:27:52 <carter> startling:  but no ones ever done this in an array lib
23:27:53 <carter> afaik
23:32:37 <carter> startling: maybe bayhac
23:32:38 <carter> idk
23:32:41 <carter> dpeends on things
23:33:10 <startling> most things do.
23:33:58 <carter> mostly how my cash flow and workload sort out this next month
23:34:09 <carter> plus if my sister is free to host me
23:34:47 <startling> hm, I should probably figure out how I'd get to mtv and where I'd stay
23:37:01 <carter> my sister is in berkeley
23:37:11 <carter> caltrain and metro
23:37:17 <carter> bart + caltrain
23:37:19 <carter> i mean
23:37:30 <carter> plus hitching a ride from mv to dojo
23:43:25 <gamegoblin> Trying to make my first hackage package. Can anyone tell me why the Modules section doesn’t contain links? https://hackage.haskell.org/package/JustParse-1.0/candidate
23:44:28 <Taneb> gamegoblin, documentation is only made every 12 hours
23:44:32 <carter> gamegoblin: did you try building it locally?
23:44:37 <gamegoblin> oooooo I did not know that
23:44:40 <Taneb> In a big process across all the libs on Hackage
23:44:48 <gamegoblin> I’ll try it local
23:44:50 <Taneb> Well, the ones with new versions
23:45:01 <gamegoblin> … how do I do it locally?
23:45:06 <startling> gamegoblin: cabal haddock
23:45:14 <gamegoblin> brb trying
23:46:25 <gamegoblin> Ahhh excellent it’s beaaauuutiful
23:46:26 <gamegoblin> thanks
23:46:46 <gamegoblin> Think I may have gone a little overboard on the docs though.
23:46:48 <carter> Taneb: are you sure ets every 12 hrs?
23:47:04 <Taneb> carter, I think it definitely used to be on Hackage 1
23:47:12 <carter> hackage 2 is new!
23:47:38 <Taneb> But that's not the kind of thing they'd change?
23:47:59 <startling> Maybe it's every 11 hours now. Who knows?
23:48:10 <carter> no
23:48:20 <startling> A number relatively prime to 24 would make things interesting.
23:48:20 <carter> probably gamegoblin  doesn't have the haddock right
23:48:33 <carter> 3am is a bad time to debug why docs dont build
23:48:38 <gamegoblin> carter: it renders splendidly locally
23:48:49 <carter> cool
23:49:37 <gamegoblin> Though haddock doesn’t seem to be rendering my === headings
23:50:14 <carter> HINT
23:50:20 <carter> that might be what killed it
23:50:30 <gamegoblin> Huh?
23:50:50 <carter> do a candidate upload sans that
23:50:56 <gamegoblin> It’s just rendering them as regular equals signs rather than heading as markup
23:51:01 <gamegoblin> But the docs say that’s how to do headings...
23:51:19 <carter> gamegoblin: your mission is to figure out why they're not agreeing
23:51:20 <carter> :)
23:51:24 <carter> which addock are you using
23:51:28 <carter> and which is hackage using?
23:51:44 <gamegoblin> http://www.haskell.org/haddock/doc/html/
23:51:55 <carter> yes
23:51:59 <carter> thats the one in 7.8 :)
23:52:15 <gamegoblin> So… what should I use?
23:52:32 <carter> per se you can upload your own haddocks
23:52:51 <carter> but if you can figure out why you cant build candiates docs on hackage
23:52:53 <carter> vs can locally
23:52:59 <carter> thats a sweel bug report
23:53:10 <gamegoblin> Didn’t someone say they only generated them periodically?
23:53:20 <carter> they lie
23:53:26 <carter> also that was hackage 1
23:53:28 <carter> hackage 2
23:53:31 <carter> is bettererrerere
23:53:37 <gamegoblin> I seeee
23:53:56 <gamegoblin> So again why are my headings not working and how can I make them work?
23:54:01 <carter> no clue
23:54:07 <gamegoblin> damn
23:54:12 <carter> experiment and find out
23:54:17 <carter> and file a bug reprot
23:55:08 <gamegoblin> Hoping I’m just an idiot, but it seems pretty straightfoward…
23:55:16 <carter> nothing is easy or obvious
