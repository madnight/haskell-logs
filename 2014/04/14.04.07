00:01:00 <metzger> kazagistar: np
00:01:51 <kazagistar> metzger: perhaps you want to make tabDeliminatedField take a parser as a parameter?
00:02:36 <metzger> i have thought about it but it gets conceptually difficult at that point
00:03:51 <kazagistar> metzger: show the code for tab deliminated field and maybe we can work it out?
00:07:38 <metzger> the issue isn't really that field - it's all the other fields. i guess they would have to be able to parse all the characters that are not legal. i guess it's just a different concept. if you process everything sequentially, you break on the first field that's not legal. however if you process by way of delimiters, then you break up a record (say, a line) into fields, and those then get processed one by one. it's just a different way of thinking about 
00:07:57 <metzger> sorry, i meant "all the other parsers"
00:09:29 <cem__> @where ops
00:09:29 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
00:09:40 * hackagebot exception-mailer 0.4.1 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.4.1 (DavidPowell)
00:09:40 * hackagebot competition 0.2.0.0 - Helpers and runners for code competitions  http://hackage.haskell.org/package/competition-0.2.0.0 (yanatan16)
00:09:55 <pavonia> cem__: Why do you call for ops?
00:10:08 <edwardk> ?
00:11:05 <jle`> what if
00:11:19 <jle`> we changed (>>) to m () -> m b -> m b
00:12:03 <mr-> Code would stop working ;-)
00:12:16 <edwardk> jle`: i for one would scream bloody murder at folks making my code needlessly slower again.
00:12:37 <jle`> having it () would make code slower?
00:13:04 <edwardk> jle`: if i have to (() <$ x) >> y   that fmap isn't free.
00:13:10 <kazagistar> metzger: its more like a syntax tree then multiple phases of compiling. Plus, if you reparse the same thing multiple times, your performace will suffer. With combinators, it seems like a good idea to do as much work as possible in a single pass through the AST... the only time you should have to backpedal is the parser to chose isn't obvious from just the lookahead
00:13:16 <edwardk> so yes
00:13:36 <edwardk> its bad enough with the _ <- ... nonsense
00:14:09 <edwardk> also it has a _ton_ of knockon effects for library authors that are bad
00:14:18 <edwardk> consider the common parser patterns of saying things like
00:14:52 <metzger> kazagistar: aha
00:15:25 <edwardk> char '[' *> c <* char ']'  -- assuming you'd want to change those two functions *> and <* as well. then now the designer of parsing combinator libraries have to either make char less useful so it doesn't return the char or make all grammars users write turn into linenoise.
00:15:57 <jle`> ah
00:16:03 <ampharmex> Cale, You still there?
00:16:08 <jle`> wait
00:16:13 <jle`> is _ <- ...
00:16:16 <jle`> slower than just
00:16:17 <edwardk> safety against a problem that literally has never affected a single line of code I have ever written vs. something that clutters an appreciable fraction of code I have.
00:16:18 <jle`> ...
00:16:20 <jle`> ?
00:16:22 <jle`> forall ... .
00:16:34 <edwardk> jle`: that one isn't speed. that one is just n ugliness concern ;)
00:16:42 <jle`> ah
00:16:53 <jle`> () <$ is performance?
00:16:54 <no-n> hello
00:16:56 <jle`> but what about laziness
00:17:10 <jle`> i guess it adds a needless thunk?
00:17:16 <jle`> same as void, i'd presume, then
00:17:19 <edwardk> but it clutters up a bunch of random parsers of mine. well, less so now. because i never use _ <-   if i can help it... because I can use (>>). But if you take (>>) from me I'll probably go postal ;)
00:18:11 <edwardk> well technically i get away with not using it because I ca use (*>) and (<*). few real reasons to use (>>) in practice with those around other than fixity to match with (>>=)
00:18:38 <edwardk> jle`: its not a thunk. its a complete traversal of the functor/monad
00:18:51 <jle`> really?
00:18:58 <edwardk> sure its an fmap
00:19:05 <edwardk> you pay the whole fmap cost
00:19:12 <edwardk> then you go do a bind
00:19:32 <jle`> but if you bind on _, does it force the fmap?
00:19:32 <edwardk> if you have a non-trivial fmap that isn't cheap
00:19:45 <jle`> hm
00:20:10 <edwardk> um, the fmap can have to percolate trough an entire tree structure root to tip for a free monad style monad.
00:20:36 <edwardk> it isn't free unless the monad is trivial or cps'd
00:21:10 <edwardk> consider the difference between something simpler:
00:21:17 <jle`> i see
00:21:30 <cem__> which language should i go erlang or haskell ?
00:21:34 <edwardk> s <-get; put (f s)        and state $ \s -> ((), f s)
00:21:53 <edwardk> the former is 'two trips through the monad transformer stack. the latter is one
00:22:31 <jle`> i see
00:22:36 <Cale> ampharmex: http://lpaste.net/102354
00:23:27 <blackdog> so, wondering if anyone has some light to shed on this odd performance problem i'm having
00:23:30 <blackdog> https://gist.github.com/mwotton/125b22f410add6811053
00:23:37 <Cale> ampharmex: In order to get the laziness to work out right, I needed to factor out an x, and use (:) instead of 1 + x * (...)
00:23:50 <Cale> ampharmex: But that computes the sequence reasonably quickly
00:24:09 <blackdog> basically, if i do my parallelism through 'parallel', it finishes in 3s, if i use GHC threads, it takes 6.
00:24:13 <edwardk> cem__: erlang
00:24:30 <blackdog> the actual work is calling out through the FFI to sqlite
00:24:37 <cem__> http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell ...
00:24:48 <blackdog> and the vmstat trace shows massive amounts of context switching when i rely on GHC threads. Am I doing something silly?
00:24:57 <kazagistar> :t (flip const)
00:24:58 <lambdabot> b -> c -> c
00:25:37 <Cale> ampharmex: However, the 3456th element might still be too much to ask for
00:25:58 <Cale> well, hmm
00:27:31 <Cale> nah, with a little strictness, it'll be fine
00:28:05 <Cale> Just don't try to !! directly to the 3456th element, or you'll run out of space :)
00:29:49 <Cale> Let's see how long this takes...
00:31:51 <ampharmex> Cale, You running a time test?
00:31:54 <Cale> yeah
00:32:15 <Cale> I'm sure this could be optimised better
00:32:59 <ampharmex> What is it currently?
00:33:05 <Cale> Space is up to 91 MiB so far. I managed to compute the 2000th element no problem
00:33:17 <Cale> done
00:33:22 <Cale> 3m35s
00:34:03 <Cale> http://lpaste.net/102355
00:34:27 <Cale> Here, I'll repaste the code I actually ran
00:34:49 <Cale> http://lpaste.net/102356
00:35:56 <Cale> It's entirely possible (in fact, I guarantee it) that one could extract a recurrence from this functional equation for the generating series, and compute this thing much more quickly.
00:36:14 <Cale> (and probably in a good deal less space)
00:37:15 <Cale> edwardk: strictList ought to be in Data.List or something
00:37:36 <Cale> :)
00:37:41 <edwardk> what do you want it to do?
00:37:50 <Cale> strictList [] = []
00:37:50 <Cale> strictList (x:xs) = x `seq` x : strictList xs
00:38:28 <makalu> is there a paper on free monads or should Gabriel's article be enough to learn them?
00:38:29 <Cale> Or even the slightly lazier version
00:38:40 <Cale> with x : (x `seq` strictList xs)
00:39:11 <Cale> Either way, it's a useful device if you ever need to do something like !! into a lazily constructed list
00:39:20 <edwardk> strictList xs = xs `using` evalList rseq    ;)
00:39:27 <Cale> Indeed
00:39:48 <edwardk> i think tibbe would cry at the suggestion of the lazier one
00:40:13 <edwardk> you don't want to make him cry, do you?
00:40:14 <Cale> I've never run into a situation where the distinction between those two really mattered
00:40:34 <Cale> Why would he cry?
00:41:12 <edwardk> all the stuff in Data.Map.Strict and elsewhere that he writes that tries very very hard to be strict in everything consistently
00:41:44 <edwardk> sans corner cases like the empty map, or when you only have one element, etc.
00:42:28 <Cale> The goal with this one isn't really to force the entire list of course, but just to make it so that traversing the list will ensure the elements get evaluated as you pass them by
00:42:42 <edwardk> *nods*
00:42:49 <Cale> (I use it primarily on infinite lists, in fact)
00:43:02 <ampharmex> Cale, Is mm_freak still around?
00:43:20 <edwardk> oh good point. it isn't the xs `using` evalList rseq i thought it was
00:43:21 <Cale> good question, when was the last time I saw him...
00:43:31 <Cale> oh, yeah, it's not
00:43:33 <ampharmex> Cale, He enjoyed these sorts of problems
00:43:57 <jle`> he announced that he would not be on these channels much more
00:44:02 <jle`> but that he would still be online on freenode
00:44:03 <ampharmex> :(
00:44:10 <ampharmex> WHy is that?
00:44:17 <jle`> maybe to help himself focus
00:44:22 <ampharmex> Ah
00:44:49 <zomg> Focus? What's that?
00:44:50 <jle`> tekmo/gabriel gonzalez resolved to leave it all completely i think except for isolated times
00:45:00 <jle`> mm_freak still comes on to ask questions though
00:45:01 <zomg> Is that the thing that happens when your internet connection goes down, and nobody is talking on irc?
00:45:04 <zomg> =)
00:45:06 <jle`> =)
00:45:10 <ampharmex> =)
00:45:31 <zomg> tbh leaving channels is a good idea
00:45:56 <zomg> I just hit alt+a (Irssi's "active channel" shortcut) all the time to distract myself from doing anything useful
00:46:00 <zomg> :P
00:46:09 <edwardk> zomg: is that what that feeling is? it happened to me a couple of times during a netsplit and I had no idea what to do with myself.
00:46:10 <jle`> being on #haskell has only been doom and destruction for me
00:46:34 <jle`> zomg: oh thanks for reminding me what that shortcut was
00:46:36 <jle`> i had forgotten it
00:48:00 <metzger_> ampharmex: i know someone from the oeis, he uses haskell, i could ask him about that sequence if it's very important for you
00:49:13 <ampharmex> metzger_, it's not that important, but if you want to :P
00:50:00 <metzger_> it's ok, i have enough things to do atm
00:50:02 <ampharmex> Would be interesting how quickly you can actually calculate the 3456th element
01:10:22 <startling> I've learned tons for #haskell, but I've also procrastinated tons with it.
01:10:39 <startling> I think it helps me with explaining things to people, though.
01:10:44 <startling> So maybe it's a wash?
01:28:01 <b0bbi10> morning, how is this pattern (record syntax) being read? http://ideone.com/4qM4qu assign 'company' to 'c'? so assignment is done from left to right?
01:29:32 <Kinnison> It's not an assignment, more a statement of identity I think
01:32:02 <Cale> b0bbi10: "When tellCar is applied to a car whose company is c, whose model is m and whose year is y, the result is the string ..."
01:32:06 <b0bbi10> in that case, why is it put in that way and not the other way around, i. e. 'param = val'?
01:32:32 <Cale> b0bbi10: Because the same syntax is used to construct values of type Car
01:33:32 <Cale> You might have something like  Car { company = "Nissan", model = "Altima", year = 2002 }
01:33:53 <b0bbi10> yeah, that's constructing
01:34:50 <Cale> So, for instance,  tellCar (Car { company = "Nissan", model = "Altima", year = 2002 }) = "This " ++ "Nissan" ++ " " ++ "Altima" ++ " was made in " ++ show 2002
01:34:59 <b0bbi10> so the reverse (extracting?) would be Car { company = c, model = m, year = y } . can it be read that the value of company is "extracted" and assigned to c?
01:35:22 <Cale> Yeah, we'd tend to say that we're pattern matching
01:36:16 <Cale> But that's essentially what's going on, at some level, a tag is being checked to ensure that the constructor was Car, and then pointers are being dereferenced to look up the values of the fields for the Car value :)
01:36:41 <b0bbi10> I would pattern match a Car like so 'Car c m y' but because of the record syntax, the syntax is as like this Car { company = c, model = m, year = y }?
01:36:50 <Cale> You can do it either way
01:37:05 <b0bbi10> ok
01:37:09 <Cale> One important difference is that with the record syntax, you're not required to match all the fields.
01:37:17 <b0bbi10> I see
01:37:33 <b0bbi10> guess I just need to get used to that syntax of Haskell then :)
01:37:35 <b0bbi10> thanks
01:44:45 * hackagebot fay 0.19.1.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.1.2 (AdamBergmark)
01:44:47 * hackagebot fay-base 0.19.1.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.1.1 (AdamBergmark)
01:54:47 * hackagebot influxdb 0.1.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.1.0 (MitsutoshiAoe)
01:54:49 * hackagebot influxdb 0.1.0.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.1.0.1 (MitsutoshiAoe)
01:55:36 <darthdeu1> hey guys, is there a way I can view the dependency graph of my cabal packages?
01:55:52 <darthdeu1> I'm getting a weird error when trying to install a sandbox, though I managed to install the same hting on a different machine
01:56:32 <darthdeu1> specifically https://gist.github.com/darthdeus/3f62fa5564e877264d6d
01:58:00 <darthdeu1> li
01:59:34 <merijn> darthdeu1: Ok, wild ass guess from me
01:59:47 * hackagebot language-javascript 0.5.11 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.11 (AlanZimmerman)
02:00:02 <merijn> darthdeu1: It's complaining that it can't find Data.Conduit.Lazy which is in conduit-extras which is not in scotty's dependency list
02:00:28 <merijn> darthdeu1: I'm guessing: scotty has set wrong upperbound and is trying to use a newer version of conduit where Data.Conduit.Lazy is no longer in the conduit package and thus breaking
02:01:53 <darthdeu1> merijn: but i've added conduit-extra to my .cabal dependencies and it's still not working
02:02:39 <darthdeu1> also scotty isn't mentioning the dependency on conduit-extra at all, even though it's using it here https://github.com/scotty-web/scotty/blob/master/Web/Scotty/Route.hs#L15-16
02:04:05 <merijn> darthdeu1: I was saying the bug is in scotty
02:04:44 <merijn> darthdeu1: *scotty* doesn't mention conduit-extras, *probably* due to a wrong upperbound on conduits, which breaks due to Data.Conduit.Lazy no longer being in conduits
02:04:48 * hackagebot uhc-util 0.1.3.1 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.1 (AtzeDijkstra)
02:04:53 <darthdeu1> merijn: but why is it working for me on my other machine? I'm using a same repo that worked for me yesterday
02:05:05 <darthdeu1> merijn: is that because my other machine might have older version of conduit?
02:05:11 <merijn> darthdeu1: Because your other machine has an older conduits version installed and it tries to use that?
02:05:20 <darthdeu1> cool :) that makes sense
02:05:22 <darthdeu1> thanks
02:05:39 <merijn> darthdeu1: You can try tightening the upperbound on scotty and see if it compiles then
02:08:38 <darthdeu1> merijn:  this is weird though, conduit changelog says that this change was made in 1.1, and scotty has >= 1.0.9.3 && < 1.1
02:09:49 <merijn> hmmm
02:10:20 <darthdeu1> maybe this was fixed on git master but hackage has a wrong version of the package
02:10:31 <darthdeu1> hmm nope
02:10:44 <merijn> darthdeu1: If you look at your error, it's trying to install scotty 0.2.0
02:10:45 <darthdeu1> hackage says the same conduit (>=1.0.9.3 && <1.1)
02:10:47 <merijn> Which is ancient
02:10:56 <merijn> And has a different dependency
02:11:09 <darthdeu1> oh wow you're right
02:11:11 <merijn> scotty 0.2.0 says " conduit (>=0.1.1.1)"
02:11:39 <merijn> darthdeu1: So basically, you have conflicting dependencies or something and it's forcing cabal to search further and find this broken old version of scotty and go "oh, I should try this!"
02:11:46 <darthdeu1> can i somehow inspect why is it trying to install scotty 0.2?
02:12:04 <merijn> Presumably
02:12:08 <merijn> But I dunno how
02:12:32 <merijn> darthdeu1: This is because you're trying to build your own library depending on scotty, right?
02:12:42 <darthdeu1> yes
02:12:55 <merijn> darthdeu1: Put a lowerbound on your scotty dependency?
02:13:14 <merijn> i.e. "scotty > 0.4" or something?
02:13:39 <merijn> darthdeu1: That'll forbid cabal from trying such old scotty versions
02:13:59 <darthdeu1> merijn:  yay that works :) though I'm confused why would cabal use so old version
02:14:01 <merijn> (probably you want something newer than 0.4 even)
02:14:17 <darthdeu1> I thought the default is the newest possible version
02:14:22 <merijn> darthdeu1: No clue, there's probably a logical reason in its solver
02:15:26 <darthdeu1> I guess I'll have to be more pedantic about specifying versions, thanks so much for helping me on this!
02:19:50 * hackagebot romkan 0.1.0.0 - Japanese Romaji <-> Japanese Kana conversion library  http://hackage.haskell.org/package/romkan-0.1.0.0 (KarlVoigtland)
02:19:52 * hackagebot hserv 0.1.0.3 - Simple http server in haskell.  http://hackage.haskell.org/package/hserv-0.1.0.3 (rejuvyesh)
02:26:52 <MP2E> quit sleep
02:38:38 <darthdeu1> merijn: found this: cabal-db graph scotty -h base | tred | dot -Tpng > graph.png ... using the cabal-db package, kinda helpful as it shows dependency graph :)
02:53:02 <t7> how do i remove all my ghc/cabal packages?
02:53:14 <t7> so its like a fresh haskell platform install
02:57:53 <merijn> Nuke everything and freshly install haskell platform
02:58:07 <blackdog> and then sandbox everything
02:58:16 <bezirg> cabal related question: what is the purpose of source repositories in the .cabal specification? source-repository head , source-repository this
02:58:56 <tdammers> bezirg: mostly to provide links to the source repositories on hackage, I think
02:59:02 <merijn> bezirg: Not much, atm
02:59:21 <bezirg> ok, so you can just fetch a source repository with cabal get
02:59:30 <merijn> bezirg: No
02:59:40 <merijn> bezirg: cabal get will grab a packaged version from hackage
03:00:06 <merijn> afaik the repo entries aren't used at all atm, they're just there so future versions of cabal can use them and as documentation, I think
03:00:17 <bezirg> aha so it's just documentation
03:00:20 <bezirg> ty ppl
03:00:55 <tdammers> I don't expect any support for this to arrive anytime soon either
03:01:06 <bezirg> btw, do u know any way to add the git commit number after the cabal version in .cabal automatically?
03:01:11 <tdammers> if only because it would require supporting at least two or three version control systems
03:01:31 <tdammers> git commit number?
03:01:35 <tdammers> you mean the commit hash?
03:01:45 <bezirg> y sry commit hash
03:01:50 <tdammers> I don't think you're supposed to use non-numeric parts in version numbers
03:02:07 <bezirg> tdammers: I think Data.Version says otherwise
03:02:13 <bahamas> :t liftM
03:02:14 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:02:15 <bezirg> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Version.html
03:02:19 <bezirg> you can have version tags
03:02:25 <tdammers> right
03:02:26 <tdammers> anyway
03:02:27 <bezirg> that can be strings
03:02:50 <bahamas> is there any reason in particular why the type variables in the definition of `liftM` are "a1" and "r" instead of "a" and "b"?
03:03:22 <tdammers> what I do is I have a script that takes a version number, injects it into the relevant files (.cabal, a .hs that produces the help screen, README, etc.), commits with an automatic message ("Bumped version to {x}"), and tags the commit with that version number
03:03:30 <tdammers> tiny bit of sed magic, mostly
03:03:49 <tdammers> I never put anything on hackage that's not tagged with a version
03:03:54 <supki> bahamas: no
03:04:03 <opqdonut> bahamas: maybe for symmetry with liftM*
03:04:06 <opqdonut> :t liftM2
03:04:07 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:04:08 <opqdonut> :t liftM3
03:04:09 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
03:04:19 <supki> bahamas: I'd guess that's just that someone copied whatever type signature ghc generated into the source code
03:04:20 <opqdonut> (r is obviously for "result")
03:04:28 <bezirg> tdammers: y that's what I am thinking of too
03:04:50 <bahamas> opqdonut: makes sense
03:05:07 <bahamas> opqdonut: oh, so you can apply a function to several monads and return a monad. cool
03:05:29 <bahamas> supki, opqdonut: thanks
03:06:37 <bezirg> tdammers: I am gonna build it my self then. Do you think it should be an external tool, or sth that wraps over Distribution.Simple.defaultMain of Setup.hs?
03:07:57 <opqdonut> bahamas: terminological note: actually, the monad is the same, you apply a function to many "monadic values"
03:09:33 <tdammers> bezirg: it's a standalone bash script in my case, but that's mostly because I am totally unfamiliar with the internals of the haskell build infrastructure
03:09:45 <tdammers> I'm a total user in that regard
03:10:52 <bahamas> opqdonut: ah, you're right. otherwise it would have been m1 a1 -> m2 a2 -> m3 a3
03:10:59 <opqdonut> yeah
03:16:40 <bahamas> from what I understand, in haskell it's prefered to use the Maybe type instead of raising an error is this correct?
03:17:00 <bahamas> s/error/error./
03:17:35 <opqdonut> yes
03:17:44 <opqdonut> you can also use Either if you want to return e.g. a string error message
03:17:53 <opqdonut> instead of just an opaque "Nothing"
03:19:26 <bahamas> opqdonut: right. why does head not use Maybe then? histerical raisins?
03:24:31 <opqdonut> bahamas: yeah, and convenience. you're only supposed to use head when you know the list is nonempty
03:24:37 <opqdonut> otherwise pattern matching
03:24:58 <opqdonut> if you want an example of a standard library function that signals failure with maybe, lookup is one
03:25:01 <opqdonut> :t lookup
03:25:02 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:25:20 <opqdonut> :t Data.Map.lookup -- also
03:25:21 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
03:29:02 <bahamas> opqdonut: yup. I know lookup. I'm doing the 99 exercises. so because the function is dealing with lists, it makes sense to have the same behavior as "head"
03:39:52 <gleber> Hello Haskeleers! Can anyone help me understand what this error message means: http://lpaste.net/102364 ?
03:40:47 <Aetherspawn> gleber: lots of noise, buut
03:41:13 <gleber> I want GHC to derive "Binary" for Exps data type defined in CoreErlang package
03:41:14 <Aetherspawn> No instance for GBinary (Rep Exps) in usage of gdmput
03:41:17 <akegalj> i have some f1 :: a -> b -> m () and f2 :: a -> b -> m () . Now Im defining f3 :: a -> b -> m (). So this would be ok: f3 a b = f1 a b >> f2 a b, but can i do it with not repeating a b, maybe something like using Control.Arrow.&&& ?
03:41:52 <akegalj> something like f3 = f1 &&& f2
03:41:55 <Aetherspawn> are you sure you don't need some template haskell to do that?
03:42:23 <gleber> According to Data.Binary hackage page, GHC should be able to do that for me :)
03:42:53 <gleber> Aetherspawn: https://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html#g:3
03:43:12 <gleber> :t Rep
03:43:12 <Aetherspawn> I actually honestly have no idea :P
03:43:13 <lambdabot> Not in scope: data constructor `Rep'
03:43:29 <gleber> Aetherspawn: so there are two of us :)
03:43:50 <akegalj> is there any way of sequencing touples? (m a, m b) -> m (a, b) ?
03:45:32 <Yuu_chan> @quote pattern
03:45:36 <lambdabot> Cale says: GADT pattern match in non-rigid context. There are prescriptions available for that sort of thing.
03:46:02 <opqdonut> :t uncurry (liftM2 (,)) -- akegalj
03:46:06 <lambdabot> Monad m => (m a1, m a2) -> m (a1, a2)
03:46:25 <Yuu_chan> Does somebody remember the quote about OOP patterns? Something like «Patterns are result of compilation of functional programs into OOP languages»
03:46:25 <akegalj> opqdonut: wau, great. thnx
03:46:58 <opqdonut> akegalj: you might want to give that function a name if you use it though, something like sequenceTuple would probably be ok
03:47:12 <akegalj> opqdonut: yes, will do :)
03:48:02 <identity> en
03:48:06 <identity> eh, sorry.
03:48:21 <merijn> Yuu_chan: No, but I know a different one :p
03:48:25 <merijn> @quote design.patterns.are
03:48:25 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
03:49:47 <Yuu_chan> merijn: nice one :)
03:50:24 <Yuu_chan> I can vaguely remember that the author of that I mentioned was Peter Norwig, but can't find a proof.
03:50:52 <merijn> Perhaps you meant Peter Norvig?
03:50:55 <gleber> Aetherspawn: looks like adding deriving instance Generic and Binary for all data types which are used inside of S.Exps seems to be moving me forward
03:51:42 <Aetherspawn> you're in a better position than I am. I wasn't aware you could leave out "where" in instance declarations with nothing under them
03:51:50 <Yuu_chan> Ouch, right.
03:53:37 <gleber> Aetherspawn: discovered it today myself, but still doing most things in Haskell as if I am a blind person trying to find my way by touch only... I have a lot to learn still
03:54:02 <merijn> gleber: That feeling doesn't go away >.>
03:55:01 <gleber> merijn: lol
03:56:45 <Aetherspawn> I feel really comfortable in haskell
03:57:03 <Aetherspawn> until I like start dealing with transformer stacks and then I become "uneasy" but still pretty confident
03:57:12 <Aetherspawn> and then I touch an edwardk library and I feel like I'm drowning.
03:58:50 <lieven_> lol likewise. things could be made a lot better by simply adding a few examples or use cases
03:59:04 <gleber> Aetherspawn: Looks like edwardk's code is legendary. Heard similar comments about his code on reddit
03:59:36 <merijn> gleber: Well, before lens he went through a period where he didn't really understand the term "documentation" :p
03:59:39 <NikolajK> Is issues involving "undefined" the only problem standing between nice categorical semantics of Hask?
03:59:52 <merijn> @quote edwardk documentation
03:59:52 <lambdabot> edwardk says: normally i don't bother with little things like "documentation", "benchmarks" and "tests", but I recently discovered that when I do, I get these curious things called "users".
04:00:08 <pordan30> luckily the designer of haskell has taken to explaining edwardk's code in public talks, complete with slideshows and everything
04:00:55 <gleber> merijn: lol
04:05:24 <gleber> Aetherspawn: Found a solution: http://lpaste.net/102365
04:10:03 * hackagebot language-javascript 0.5.12 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.12 (AlanZimmerman)
04:11:48 <makalu> I'll re-ask my earlier question: where should I learn about free monads?
04:12:08 <makalu> I found Gabriel Gonzalez's tutorial but I thought maybe there's a nice paper about it?
04:12:20 <merijn> makalu: If there is I haven't really found many :\
04:14:03 <makalu> ok I'll read Gabriel's article then, thanks
04:17:16 <Aetherspawn> gleber: grats
04:17:19 <Aetherspawn> wow, that's a lot of instances
04:40:21 <AshyIsMe> so cabal can tell me which packages i need to add to my build-depends list, is there a way to make it just add them to the list?
04:40:53 <dcoutts> AshyIsMe: actually it's ghc that makes those suggestions, cabal doesn't actually know.
04:41:07 <dcoutts> AshyIsMe: so unfortunately at the moment the answer is no
04:42:15 <AshyIsMe> it comes across as not-quite-helpful and almost snarky haha
04:42:44 <AshyIsMe> "Perhaps you need to add `mtl' to the build-depends in your .cabal file.  You idiot."
04:43:14 <dcoutts> AshyIsMe: it's certainly not intended that way
04:43:31 <bahamas> does Data.Set preserve the order of insertion?
04:43:46 <dcoutts> bahamas: no, it's a set not a sequence
04:46:30 <siamsara> if it did, would insert (set [1,2,3]) 1 be set [1,2,3] or set [2,3,1]?
04:46:58 <siamsara> except less backwards
04:47:08 <bahamas> actually, I just realized Set is not good, because I have duplicate elements
04:47:16 <bahamas> that I need to preserver
04:47:28 <bahamas> -r
04:47:31 <mr-> is there a multiset-library?
04:47:40 <siamsara> bahamas: what operations do you need?
04:48:25 <merijn> 'Multiset a' is just 'Map a Int' :p
04:50:29 <bahamas> siamsara: I'm doing problem 8 here http://www.haskell.org/haskellwiki/99_questions/1_to_10
04:50:40 <bahamas> I think I've found a solution and it's pretty simple actually
04:51:15 <siamsara> eliminate consecutive duplicates?
04:51:20 <siamsara> why do you need a data structure at all?
04:54:32 <siamsara> > let c(x:(dropWhile(x==)->y))=x:c y;c _=[]in c"aaaabccaadeeee"
04:54:33 <lambdabot>  "abcade"
04:54:37 <bahamas> siamsara: well, I don't. I made an incorrect assumption. the current solution doesn't require one. I just check if the last added element is the same as the current one. if it is, I don't add the current one
04:55:08 * hackagebot music-util 0.9.3 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.9.3 (HansHoglund)
04:55:11 <siamsara> deobfuscation left as an exercise for the reader
04:55:11 <jmcarthur> the haskelly way to solve this is a very simple one-liner, by the way
04:55:18 <jmcarthur> simpler than siamsara's...
04:59:01 <bahamas> jmcarthur: yeah, I just used foldr
04:59:46 <bahamas> it's not a very short line, but it's easy to understand
05:00:54 <mr-> > map head $ group "aabcad"
05:00:56 <lambdabot>  "abcad"
05:01:13 <bahamas> :t group
05:01:13 <lambdabot> Eq a => [a] -> [[a]]
05:01:24 <mr-> it's in Data.List, I think
05:01:25 <mariomystic> I set a cpp flag Biz in a package Foo. Now Foo is a dependency for Bar. I want to set some extensions in cabal file depending on whether the cpp flag Biz is set or not. I dont see a way of doing that in cabal docs as the conditionals inside cabal file doesnot allow checking cpp flags.
05:01:27 <bahamas> I forgot about group
05:02:29 <bahamas> that's why I want to become a lot more acquainted with the standard lib
05:02:47 <bahamas> I miss python's "dir" function
05:02:48 <yitz> mr-: it's in Data.List.NonEmpty, from the semigroups library. those are the versions of head and group that you want to use. the ones from Data.List are not safe.
05:03:04 <mr-> yitz: group is not safe?
05:03:28 <yitz> mr-: well, it is, but the other one then allows you to use safe head.
05:03:50 <bahamas> yitz: safe in what way?
05:03:58 <mr-> yitz: thanks, but in this case I would not bother. It's short enough so that I can convince myself that it is safe ;-)
05:04:07 <yitz> mr-: bother?
05:04:27 <yitz> mr-: you're importing it anyway. why is it more bother to import from the correct library?
05:04:29 <dcoutts> mariomystic: you could communicate cpp stuff from Foo to Bar for use in source files by having Foo install a .h file
05:04:52 <mr-> yitz: Data.List is in my .ghci ;-)
05:05:09 <yitz> mr-: Data.List.NonEmpty should be, too, then.
05:05:41 <mr-> bahamas: in the sense that head is not total/crashes on the empty list. It's map head $ group is fine, because head will never be applied to the empty list. This is, however, not reflected in the types.
05:05:47 <mr-> And that's the point yitz makes, I think.
05:06:54 <bahamas> mr-: ah, so the other head handles empty lists. I didn't know this existed
05:07:13 <mr-> bahamas: it does not. But it knows that the list is not empty
05:08:56 <bahamas> importing that library doesn't work. I tried import Data.List.NonEmpty as NE
05:09:14 <mr-> Do you have semigroups installed (See, there is some bother)
05:10:07 <jmcarthur> > mapMaybe listToMaybe $ group "aaaabccaadeeee"
05:10:08 <lambdabot>  "abcade"
05:11:01 <jmcarthur> > concatMap (drop 1) $ group "aaaabccaadeeee"
05:11:02 <lambdabot>  "aaacaeee"
05:11:07 <jmcarthur> fail
05:11:09 <yitz> mr-: it's part of the haskell platform. so yes, everyone has it installed. except people who are advanced enough to have a reason not to use HP, in which case they will also have semigroups installed.
05:11:11 <jmcarthur> > concatMap (take 1) $ group "aaaabccaadeeee"
05:11:12 <lambdabot>  "abcade"
05:11:15 <bahamas> mr-: I don't know. I didn't install anything besides what comes by default
05:11:24 <mr-> bahamas: how does it fail?
05:11:33 <bahamas> :t mapMaybe
05:11:33 <lambdabot> (a -> Maybe b) -> [a] -> [b]
05:11:53 <jmcarthur> > mapMaybe (\x -> if even x then Just x else Nothing) [1..10]
05:11:54 <lambdabot>  [2,4,6,8,10]
05:12:25 <bahamas> mr-: well, I try to use NE.group and I get a message saying that it failed to load the interface for NE
05:12:59 <bahamas> :t listToMaybe
05:13:00 <lambdabot> [a] -> Maybe a
05:13:06 <bahamas> aha
05:13:09 <bahamas> cool
05:14:51 <jmcarthur> > group "aaaabccaadeeee" >>= take 1
05:14:52 <lambdabot>  "abcade"
05:14:56 <yitz> bahamas: did you do import qualified Data.List.NonEmpty as NE ?
05:15:03 <bahamas> yitz: yes
05:15:42 <bahamas> ghci> import qualified Data.List.NonEmpty as NE
05:16:51 <yitz> bahamas: we'd have to see the details of what you typed to figure what's wrong then. if the import worked, then NE.group ought to be there.
05:17:25 <mr-> yitz: group's type is cool. I was worried there might be a fromList needed somewhere :-)
05:17:51 <siamsara> yitz: more like the details of the error message
05:20:11 * hackagebot Chart 1.2.2 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.2.2 (TimDocker)
05:21:13 <bahamas> yitz: http://lpaste.net/102366
05:25:12 * hackagebot Chart-cairo 1.2.2 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.2.2 (TimDocker)
05:25:14 * hackagebot Chart-diagrams 1.2.2 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.2.2 (TimDocker)
05:25:16 * hackagebot Chart-gtk 1.2.2 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.2.2 (TimDocker)
05:25:18 * hackagebot Chart-simple 1.2.2 - A wrapper for the chart library to assist with basic plots  http://hackage.haskell.org/package/Chart-simple-1.2.2 (TimDocker)
05:33:16 <jophish> Further to the discussion about sum types the other day. What's a standard technique for excluding a specific constructor out of many from a result
05:33:55 <jophish> If there are only two constructors, then the input to this filtering function could be :: f (Either A B) -> f A
05:34:53 <jophish> but if there are a host of constructors, and f is only filtering out one of these, is there a neater way than :: f (OneOf A B C D) -> f (OneOf' A B C)
05:36:21 <jophish> I suppose it could be :: f (Either ABC D) -> f ABC
05:36:38 <jophish> but this puts an artificial divide between ABC and D
05:36:52 <jophish> bitemyapp: ^
05:42:00 <aspidites> is there a way to add default packages to a sandbox on creation?
05:42:24 <aspidites> perhaps some global config value that says "any time i create a sandbox, i want these packages"
05:44:55 <aspidites> actually, it looks like i can maybe do something with the cabal config and add-source command
05:46:52 <no-n> ih
05:50:15 * hackagebot matrix 0.3.0.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.0.0 (DanielDiaz)
05:55:16 * hackagebot concraft 0.9.2 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.9.2 (JakubWaszczuk)
05:57:11 <Nephro> http://pastebin.com/uY67CJbc -- what is wrong with this function?
05:58:03 <int-e> what is  b sum a b c - 1  supposed to mean?
05:58:27 <Nephro> parameters to fibonaccy
05:58:39 <Nephro> b (sub a b) (c - 1)
05:58:40 <jophish> This describes things pretty well http://lpaste.net/102367
05:59:07 <werdna> Lost on why I'm getting a parse error here:
05:59:08 <werdna> prop_insert_duplicate_check insertFunction integer = forAll searchTrees $ \tree (containsCount integer (insertFunction integer tree) ) <= 1
05:59:18 <werdna> Ex03.hs:52:54: Parse error in pattern: insertFunction
05:59:22 <siamsara> werdna: missing ->
05:59:24 <int-e> Nephro: try  fibonaccy (b+a) a (c-1)
05:59:36 <werdna> thank you siamsara
05:59:43 <werdna> eagle eye :)
06:00:16 * hackagebot code-builder 0.1.2.1 - Simple system for generating code.  http://hackage.haskell.org/package/code-builder-0.1.2.1 (ErikHesselink)
06:00:18 * hackagebot rest-client 0.2.3.1 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.2.3.1 (ErikHesselink)
06:00:20 * hackagebot rest-core 0.27.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.27.0.1 (ErikHesselink)
06:00:22 * hackagebot rest-gen 0.9.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.2 (ErikHesselink)
06:00:24 * hackagebot rest-happstack 0.2.9.4 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.4 (ErikHesselink)
06:00:49 <int-e> Nephro: in general, parentheses are not used for function application; f applied to x and y is just  f x y. but function application binds strong, so f a + b would be (f a) + b; to get f applied to a+b, you need to write f (a+b).
06:00:58 <Nephro> int-e, nope, still same error
06:02:34 <int-e> Nephro: really? fibonaccy a b c = if c > 0 then a : b : fibonaccy b (a+b) (c-1) else [a + b]  satisfies the typechecker here.
06:05:26 * hackagebot rest-snap 0.1.17.4 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.4 (ErikHesselink)
06:05:28 <Nephro> int-e, sorry, I had parentheses around my whole param list
06:05:28 * hackagebot rest-types 1.9.0.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.9.0.1 (ErikHesselink)
06:05:30 * hackagebot cab 0.2.10 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.10 (KazuYamamoto)
06:05:49 <Nephro> Must be the most common mistake when coming from imperative programming
06:05:53 <Nephro> works now
06:07:36 <siamsara> haskell has no parameter lists
06:07:47 <bahamas> when ghci tells me to use -v in relation to an import error, where do I use that -v?
06:08:19 <int-e> bahamas: good question; I'd try  :set -v  and reload
06:09:44 <bahamas> int-e: that's it. thanks. I don't understand why it doesn't find a module when it's right there in the same directory
06:15:18 * hackagebot mangopay 1.3 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.3 (FelipeLessa)
06:15:20 * hackagebot yesod-mangopay 1.3 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.3 (FelipeLessa)
06:15:59 <bahamas> so, I have a directory in which I have a file P9.hs and a file P10.hs. in P9.hs I define module P9. in P10.hs I try to `import P9`, but it fails. anyone have any idea what the problem could be?
06:17:30 <fizruk> bahamas: how are you trying to compile/execute those? for the same directory?
06:17:37 <fizruk> s/for/from/
06:17:52 <bahamas> fizruk: I'm trying to load P10.hs in ghci
06:18:02 <bahamas> ohh
06:18:15 <bahamas> I think my working directory is the problem
06:18:23 <fizruk> =)
06:19:02 <bahamas> yeah, thanks
06:22:57 <exicer> Is there much / any performance overhead for using type synonyms ?
06:23:45 <corgifex> hwat
06:23:58 <corgifex> types are compile time
06:24:09 <fizruk> exicer: unless you're using something non-obvious such as TypeSynonymInstances, I think there's no overhead at all
06:24:29 <exicer> so doing type Test = (Int, Int) has no overhead compared to (Int, Int) ?
06:24:48 <fizruk> exicer: no overhead there
06:25:15 <exicer> fizruk: Cool cool, thanks.
06:25:19 <corgifex> what kind of overhead are you thinking of?
06:25:32 <exicer> runtime.. I'm trying to do some numerical computations in haskell for the first time
06:25:41 <corgifex> types don't exist at runtime
06:25:51 <fizruk> corgifex: I guess he meant run-time representation overhead
06:26:09 <fizruk> corgifex: e.g. like in data MyInt = MyInt Int
06:26:14 <exicer> I'm not sure.. I mean how long will it take a compiled program to run, how much space it takes etc.
06:26:21 <exicer> memory, that is
06:26:45 <exicer> fizruk: What does run-time representation overhead exactly mean ?
06:28:03 <fizruk> exicer: type synonyms are just synonyms for readability and better error messages: your Test is identical to (Int, Int) at both compile-time and run-time
06:31:16 <fizruk> exicer: otoh, `data MyInt = MyInt Int` is not exactly the same as Int at both compile-time and run-time, because there exists an "extra" value for MyInt: (MyInt _|_)
06:32:23 <fizruk> exicer: there's also a `newtype` keyword in Haskell for cases when you want to separate types at compile-time, but represent them without overhead
06:33:10 <fizruk> exicer: e.g. `new type MyInt = MyInt Int` will behave like Int at runtime, but like `data MyInt` at compile-time
06:33:56 <fizruk> exicer: note that new type can be used only with single constructor and single argument
06:34:59 <geekosaur> exicer: a data type in Haskell comes with a constructor tag (which in ghc is a separate word) and an indirection (a pointer, as it were) which enables laziness (and bottom)
06:35:19 <geekosaur> you get those with data. you don't get them with type or newtype
06:37:16 <geekosaur> so this costs you in both memory usage (in ghc; some other implementations use bit stealing to hide it in the pointer; but that costs extra time to strip them out to use the pointer) and performance because it's got to do extra indirections
06:38:26 <exicer> geekosaur, fizruk: Hm, okay. So newtype seems like the best bet for simple things? You get type checking, but it is not slower ?
06:38:37 <exicer> or have I misunderstood
06:39:06 <geekosaur> it's better for some things. it has limitations; for example, since it can't track which constructor is used, it can have exactly one constructor
06:39:41 <geekosaur> type can't have any constructors at all, since it's just an alias. data is the workhorse that supports constructors etc.
06:39:48 <exicer> Right.. okay. I think for my purposes it sounds like it will be useful.
06:40:01 <exicer> I guess the best way to work it out is just to use it and benchmark etc :p
06:40:21 * hackagebot concraft-pl 0.7.1 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.7.1 (JakubWaszczuk)
06:40:23 * hackagebot gang-of-threads 3.2.0 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-3.2.0 (bholst)
06:40:25 * hackagebot hashed-storage 0.5.11 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.11 (PetrRockai)
06:41:11 <fizruk> i guess, types are useful for really simple aliases, like physical quantities: time, speed, distance — I
06:41:23 <fizruk> I'd define them as types
06:41:34 <fizruk> i mean `type`s
06:42:06 <geekosaur> type is a convenience. sometimes it's a straight renaming (type String = [Char]), sometimes it's making it easier to refer to something (look at ShowS)
06:42:57 <geekosaur> there are some limits to it since it has an implicit forall, so incautious usage of multiple `type`-declared types in a signature can lead to them not unifying
06:50:22 * hackagebot ghc-mod 4.0.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.0.2 (KazuYamamoto)
06:51:01 <davean> rrr/wi21
06:57:46 <tdammers> I consider `type` as mostly a code self-documentation feature
06:58:21 <tdammers> e.g., FilePath -> URL is more descriptive than String -> String
07:04:01 <jophish> I often write 'return' instead of 'pure' out of habit. What 'rules' do people follow as to use what when?
07:04:18 <jophish> pure is shorter by two characters, so it has that going for it
07:04:39 <prophile> I feel like most of the time it's just a matter of context
07:04:49 * Kinnison tends to write 'return' when he's writing monadic code and 'pure' for applicative code
07:04:53 <prophile> if you're using the monadic API, return; if you're using the applicative API use pure
07:05:14 <jophish> It's not always that clear cut though
07:05:19 <prophile> once the AMP is in I suspect the situation will change to "always use pure" though
07:05:24 * hackagebot twitter-types 0.2.20140407 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.2.20140407 (TakahiroHimura)
07:05:39 <jophish> for example, I'm using applicative functions to compose monadic functions
07:05:46 <jophish> sorry, that was poorly worded
07:06:02 <prophile> probably use return in that case then
07:06:29 <jophish> I have something like: f (X a b) = X <$> f a <*> f b
07:06:44 <jophish> and f Y = return Y
07:07:02 <jophish> given that f is using applicative functions in another case, it tends me to think I should be using pure here
07:07:28 <prophile> a fair observation, there's nothing monadic-looking in that line
07:07:37 <prophile> it doesn't really matter too much though
07:07:45 <jophish> yeah :)
07:08:03 <identity> if I simply want to blit an image, like a BMP, to the screen, preferably using hardware acceleration, which library should I be choosing?
07:08:08 <jophish> I'd like for other Haskellers to read my code and say to themselves: Golly, Joe is so good at writing idiomatic Haskell
07:08:10 <identity> not gloss, I assume?
07:08:46 <jophish> identity: depending on what exactly you need, you may find GL and SDL to be good
07:09:10 <jophish> Although there would probably be a fair amount of setup code in there compared to a library just for doing this
07:09:33 <jophish> actually, come to think of it, SDL may support exactly what you want to do without you having to dabble in GL
07:10:04 <identity> jophish: Hmm, alright. Thanks!
07:11:38 <jophish> identity: I've never used it like this, but there are a bunch of tutorials on drawing sprites using SDL
07:11:46 <jophish> so it probably should't be too hard
07:12:58 <identity> I basically just want to be manipulating the bitmap continuously(going to be using repa) and replace the display buffer with it, really
07:13:22 <jophish> identity: I've always used GL to do exactly that
07:19:53 <bartavelle> I have a parsing question with parser builders such as Text.Parser.Expression or Text.Parsec.Expr
07:19:57 <bartavelle> here is my code : https://github.com/bartavelle/language-puppet/blob/master/Puppet/Parser.hs#L293-L329
07:20:16 <bartavelle> the "checkLookup" part does seem to work with $a[5], but not with $a[5][6]
07:20:49 <bartavelle> this is the first time I use "Postfix" operators, so there is something I might be overlooking here ..
07:21:47 <randomclown> I have a string "(1 2 3) (3 4 5) 7 8", what's the easiest way to parse it into [[1,2,3], [3,4,5], [7],[8]]?
07:23:09 <bartavelle> randomclown, with a parser combinator library, it's quite simple
07:23:28 <randomclown> is it not doable without a parser combinator?
07:23:33 <randomclown> I'd just regex in python
07:23:34 <bartavelle> it probably is doable
07:23:49 <randomclown> why is so hard in haskell
07:23:54 <bartavelle> it's easier in haskell
07:24:06 <randomclown> show?
07:24:12 <bartavelle> I thought you needed to handle recursive parens
07:24:14 <bartavelle> is that the case ?
07:24:20 <randomclown> no
07:24:29 <randomclown> only one level
07:24:51 <bartavelle> well, you can reuse your regexp if you are familiar with that
07:25:25 <identity> it would be rather simple using parsec.
07:25:30 <identity> probably not more than a couple of lines
07:25:41 <bartavelle> I'd say a single line ...
07:27:00 <Sonderblade> funny how you all say how simple and easy it is, yet can't give randomclown an example :)
07:27:28 <identity> i'm actually looking at it in ghci right now
07:27:36 <identity> but it's a matter of remembering how to use parsec :)
07:28:18 <randomclown> hard mode: hackage's down
07:28:21 <randomclown> no docs
07:28:59 <bartavelle> nah I need 2 lines
07:29:01 <bartavelle> gimme a sec
07:29:13 <dcoutts> randomclown: wait a minute or two, it's undergoing maintenance
07:29:46 <haasn> many1 (integer <|> parens (many integer)) -- or something like that?
07:29:53 <dcoutts> randomclown: ok, it's done
07:29:57 <saml> is it lisp?
07:29:57 <haasn> pure <$> integer <|> ...
07:30:00 <bartavelle> haasn, you need to sepBy space
07:30:05 <bartavelle> or lex
07:30:13 <haasn> good point, yes
07:31:09 <artyomkazak> let num = (read `fmap` many1 digit) :: Parser Integer
07:31:17 <fizruk> is hackage down?
07:31:25 <saml> lparen = char '(' >> spaces;   rparen = spaces >> char ')'
07:31:45 <saml> fizruk, yes. wait a minute
07:32:23 <artyomkazak> let element = fmap (:[]) num   <|>   between (char '(') (char ')') (num `sepBy` spaces)
07:32:41 <artyomkazak> let parser = element `sepBy` spaces
07:32:53 <haasn> wow, I just stumbled across http://gentoohaskell.wordpress.com/2013/08/01/ghc-7-6-weak-symbols-and-ghci/
07:33:13 <haasn> I never realized the issue I had so long ago resulted in a huge blog post about it
07:33:13 <dcoutts> fizruk: no, it was just being upgraded
07:33:20 <dcoutts> fizruk: it's done now
07:33:54 <fizruk> dcoutts: saml: thanks!
07:36:27 <bartavelle> artyomkazak, I'm afraid you need to lex "num", or you wont parse "(3 4 5 )"
07:37:20 <saml> bartavelle, what are you trying to parse?
07:37:24 <saml> list of numbers?
07:37:32 <bartavelle> <randomclown> I have a string "(1 2 3) (3 4 5) 7 8", what's the easiest way to parse it into [[1,2,3], [3,4,5], [7],[8]]?
07:37:53 <artyomkazak> bartavelle: okay, I'll just replace “char '('” and “char ')'” with saml's lparen and rparen
07:38:30 <bartavelle> "7 8 " :)
07:38:35 <saml> expr := parenedNat | Nat
07:38:56 <saml> no there are spaces
07:39:05 <saml> do you want parsec? or manual function?
07:39:17 <saml> > words  "(1 2 3) (3 4 5) 7 8     "
07:39:20 <artyomkazak> bartavelle: then the easiest solution is to define num as “between spaces spaces ...” and not worry about spaces at all
07:39:22 <lambdabot>  ["(1","2","3)","(3","4","5)","7","8"]
07:39:39 <bartavelle> I'd agree
07:39:50 <bartavelle> well, I agree
07:40:22 <saml> is there string replace function?
07:41:05 <bartavelle> anyway, if someone has a clue about my expression parser problem ... I'd be interested
07:41:37 <randomclown> saml: not from default libs
07:42:53 <randomclown> the easiest way is actually s/ /,/g followed by a s/(/[/g, s/)/]/g and adding [ and ] to the beginning and end
07:43:03 <randomclown> then call read :: [[Int]]
07:43:08 <randomclown> then call read :: String -> [[Int]]
07:43:15 <randomclown> haha
07:43:40 <saml> randomclown, how do you want to parse (1 (2 3) 4)  ?
07:44:04 <saml> no nested parens, right?
07:44:09 <randomclown> saml: [[1], [2,3], [4]]
07:44:16 <randomclown> no nesting, the they won't allow it
07:44:20 <randomclown> the type*
07:44:22 <saml> how about  (1 (2 3) 4) 5 6  ?
07:44:27 <randomclown> not possible
07:44:30 <saml> okay
07:44:56 <saml> i think it'll take me about 2 hours to solve this
07:45:04 <randomclown> jesus
07:45:18 <bartavelle> saml, artyomkazak solution is ok
07:46:13 <bartavelle> but I'd object that a "replace + read" solution isn't easier. It is quick to type, but then you get an exception every time you have a parse error. You can't reuse it in a bigger parser either.
07:46:38 <saml> artyomkazak uses parsec?
07:46:43 <bartavelle> yes
07:46:59 <bartavelle> ah you mean you are looking for a base-only solution ?
07:47:19 <artyomkazak> actually it's not quite ok because spaces before brackets won't be processed. I'll write a base-only solution now if neede
07:47:20 <artyomkazak> *d
07:47:34 <no-n> @src runWriter
07:47:35 <lambdabot> Source not found. :(
07:47:37 <bartavelle> spaces before numbers would fail too
07:47:39 <no-n> :(
07:47:45 <bartavelle> I mean "( 1"
07:47:46 <randomclown> replace and read doesn't really work
07:47:47 <Sonderblade> randomclown: main = print $ map (T.splitOn (T.pack " ")) (filter (\x -> T.length(x) > 0) (map (T.strip . T.pack) (S.splitOneOf "()" "(1 2 3) (3 4 5) 7 8")))
07:47:50 <artyomkazak> I had to write a base-only parser for a small programming language once. God bless ReadP
07:47:51 <randomclown> which is a shame
07:48:05 <Sonderblade> randomclown: string > number conversion left as an exercise to the reader
07:49:24 <bezirg> question: I thought the cmd "cabal configure" of cabal-install is just a wrapper for runghc Setup.hs configure --user  . I have a custom Cabal hook in Setup.hs and it is not picked up from "cabal configure"
07:49:47 <bezirg> so what cabal configure runs then?
07:50:32 * hackagebot slot-lambda 0.1.0.0 - Write lambdas without naming the parameters. --\_ + _ = \x y -> x+y  http://hackage.haskell.org/package/slot-lambda-0.1.0.0 (ducis)
07:52:31 <corgifex> bezirg: what's your Build-Type?
07:55:34 * hackagebot slot-lambda 0.1.0.1 - Write lambdas without naming the parameters.  http://hackage.haskell.org/package/slot-lambda-0.1.0.1 (ducis)
07:55:47 <thomas358> http://lpaste.net/102371
07:56:34 <corgifex> type BasicLevel = Dequeue.BankersDequeue
07:57:35 <artyomkazak> bartavelle: now I wonder why there's no “sepBeginEndBy” in Parsec
07:57:48 <artyomkazak> with it, the whole thing would be like this: http://lpaste.net/102372
07:58:06 <bartavelle> artyomkazak, I think it's because you might use stuff from "Token" in that case
07:58:28 <thomas358> @corgifex:  Ah i see!
07:58:28 <lambdabot> Unknown command, try @list
07:58:34 <thomas358> corgifex++
07:59:09 <thomas358> <corgifex>++
07:59:40 <thomas358> karma corgifex
07:59:43 <thomas358> karma <corgifex>
08:00:08 <corgifex> @karma corgifex
08:00:08 <lambdabot> You have a karma of 1
08:00:57 <thomas358> @corgifex++
08:00:57 <lambdabot> Unknown command, try @list
08:01:01 <thomas358> @list
08:01:02 <lambdabot> What module?  Try @listmodules for some ideas.
08:01:05 <thomas358> @listmodules
08:01:05 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
08:01:08 <thomas358> @list karma
08:01:08 <lambdabot> karma provides: karma karma+ karma- karma-all
08:01:14 <thomas358> @karma+
08:01:15 <lambdabot> usage @karma(+|-) nick
08:01:22 <thomas358> @karma+ corgifex
08:01:22 <lambdabot> corgifex's karma raised to 2.
08:01:27 <thomas358> thanks corgifex!
08:03:45 <thomas358> @karma thomas358
08:03:45 <lambdabot> You have a karma of 0
08:04:00 <haasn> thomas358: why do you include ‘x’ in class OrderLevel?
08:04:09 <stolaruk> The linter complains when I don't write function bodies to match all patterns. However, I find that due to the logic of my code, there are functions for which certain patterns should never match. For such patterns, is it acceptable to just use "error"?
08:04:26 <haasn> stolaruk: if you're certain about it, yes
08:04:53 <stolaruk> haasn: Yes, for cases in which if the pattern matched, it would indicate serious programmer error
08:04:53 <haasn> stolaruk: a more principled solution would be to redesign your types so that you don't even have cases that cannot occur
08:05:23 <stolaruk> haasn: Yeah I've thought about that as well, though it's not always very practical
08:05:34 <Jonyyy> Hello I am trying to pass a own made type into a getColor method. Depending on the type which could be blue yello or red I want to run a particular line of code. I have done guards like this:  lpaste.net/102373
08:06:01 <Jonyyy> However it gives an error saying I dont use the objects right I think
08:06:06 <Jonyyy> Is my code correct??
08:06:31 <corgifex> fixed link: http://lpaste.net/102373
08:06:53 <corgifex> Jonyyy: what's the error?
08:07:07 <stolaruk> Jonyyy: Maybe you need an "otherwise" guard?
08:07:32 <Jonyyy> no instance for Eq kleur araising from a use of ==
08:07:42 <fizruk> Jonyyy: pattern match on kleur
08:07:57 <stolaruk> Make Kluer derive Eq
08:08:05 <geekosaur> either pattern match on the Kleur constructors or derive Eq for Kleur
08:08:11 <Jonyyy> no with otherwise, I get the same error
08:08:22 <thomas358> haasn: I don't
08:08:23 <mmachenry> Jonyyy: You made Kleur? You could also derive Eq for that type.
08:08:24 <Jonyyy> what do you mean with pattern match ?
08:08:27 <no-n> hmm. if I want to thread around a StdGen (as you might with the State monad), but thread around some logs (as you might with the Writer monad), as well, with the same object,  what's a good way to do both?
08:08:29 <thomas358> haasn: You're right
08:08:29 <geekosaur> pattern matching is typically peferred
08:08:38 <fizruk> Jonyyy: annotated here: http://lpaste.net/102373
08:08:59 <stolaruk> no-n: You could make a monad transformer stack
08:09:13 <no-n> hmm
08:09:21 <no-n> I haven't learnt about those yet hehe
08:09:29 <no-n> sounds good
08:09:54 <stolaruk> no-n: Check out RWH chapter 18
08:10:08 <no-n> stolaruk: how about "all about monads"?
08:10:31 <stolaruk> no-n: It's about combining monads by "stacking" them, so you can essentially use more than one monad at once
08:10:40 <stolaruk> no-n: What's that?
08:10:49 <no-n> http://web.archive.org/web/20061211101052/http://www.nomaware.com/monads/html/index.html
08:10:51 <no-n> has stuff about this
08:10:59 <no-n> in Part III
08:11:33 <stolaruk> no-n: I've never seen that before, but yeah looks like it explains monad transformers
08:11:40 <no-n> mmm
08:15:49 <bezirg> corgifex: my cabal build type is simple
08:15:51 <esmooov> no-n: My favorite monad transformers piece is http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html Even more so than monads, monad transformers are harder to think about than to use. I think.
08:16:04 <no-n> hehe
08:16:09 <no-n> thanks esmooov
08:16:09 <corgifex> bezirg: set it to custom if you have code in Setup.hs
08:17:11 <bezirg> corgifex: it works, thx!
08:17:37 <veg4n> Hi. I'm currently trying to swtich from using vim to emacs for my Haskell development. I never experienced any problems with vim using ghc-mod/hlint but I can't for the life of me figure out how to get the same state in emacs. Help would be much appreciated.
08:19:52 <shlevy> Should applications (e.g. https://github.com/zalora/sproxy) go on hackage?
08:20:28 <thoughtpolice> shlevy: totally :)
08:20:37 * hackagebot slot-lambda 0.1.0.2 - Write lambdas without naming the parameters.  http://hackage.haskell.org/package/slot-lambda-0.1.0.2 (ducis)
08:21:16 <alpounet> shlevy: glorious times ahead :)
08:25:54 <jle`> no-n: i think it might be misleading to say that monad transformers are about stacking monads
08:26:05 <jle`> or well
08:26:08 <jle`> that's what they are
08:26:17 <jle`> but it might not be the best way to approach their practical use
08:26:33 <jle`> and leads to fragile code
08:26:42 <quchen> A monad tansformer is an abstract concept, like a collection of things. A stack is one way of realizing it.
08:27:21 <quchen> A computational stack can be built with a linked list, an array, or whatever else you see fit.
08:27:41 <quchen> A monad transformer can be built out of anything that lets you add the effects of a new Monad to another one.
08:29:55 <no-n> how should I solve the problem of passing around a random generator and some logs then? (Possible that I'll be passing around more)
08:30:10 <no-n> (but perhaps not)
08:32:36 <quchen> no-n: I was just responding to jle`. "Passing around a RNG and logs" sounds like you want something like RWST.
08:33:17 <quchen> Transformers are the usual way of comining Monads, of course.
08:34:26 <no-n> quchen: Control.Monad.RWS.Lazy?
08:35:18 <quchen> I'm not sure what you want to do exactly. Writing a log sounds like Writer. Having implicit RNG state is State.
08:35:38 * hackagebot tz 0.0.0.3 - Time zones database and library  http://hackage.haskell.org/package/tz-0.0.0.3 (MihalyBarasz)
08:35:56 <no-n> yeah
08:36:08 <quchen> "RWST r w s m a" is pretty much "ReaderT r (WriterT w (StateT s m)) a" molded into a single thing.
08:36:18 <no-n> well maybe StateT StdGen (Writer [String]) Blah is enough
08:36:31 <no-n> ah, okay
08:36:36 <no-n> lol :)
08:37:13 <quchen> *R*eader *W*riter *S*tate *T*ransformer :-)
08:37:38 <no-n> dat rabbit-hole
08:38:07 <quchen> "RWST r w s m a" looks much scarier than it is :-þ
08:39:48 <no-n> yeah
08:39:55 <no-n> well, better than throwing it all together yourself
08:45:51 <dbeacham> @pl
08:45:51 <lambdabot> (line 1, column 1):
08:45:51 <lambdabot> unexpected end of input
08:45:51 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:46:05 <dbeacham> @pl \a b -> fromIntegral $ a + b
08:46:05 <lambdabot> (fromIntegral .) . (+)
08:46:24 <thomas358> http://lpaste.net/102376
08:48:23 <New2Haskell> Hello guys I have made my own datatype GeoFig Circle, Trinagle, Retangle, Square also I have made colors Red Blue Yellow. I am now trying to make a function that accepts a list of geofigs and a color and gives back a list of geofigs of that color. This is my code http://lpaste.net/102377, however I do not know how to "search" for styled typeclasses. Anyody has some advice?
08:48:57 <geekosaur> I have no idea what a styled typeclass is
08:48:57 <New2Haskell> the isRood method should check if the GeoFig has the rood attribute
08:49:25 <New2Haskell> I dont know how to explain it, I basicly made figures with color and dimension
08:49:45 <geekosaur> you have no typeclasses there (and indeed should not)
08:49:57 <New2Haskell> However I also gave them a type like Cirkel {straal :: Float, kleur :: Kleur}
08:50:29 <corgifex> isRood x = kleur x == Rood
08:50:39 <New2Haskell> just like that??
08:50:43 <geekosaur> but you need deriving Eq on the colors
08:50:57 <New2Haskell> oh
08:51:01 <geekosaur> so change the deriving (Show) to deriving (Show, Eq)
08:51:10 <New2Haskell> I see let me try that
08:51:44 <corgifex> getKleur k xs = filter (\x -> kleur x == k) xs
08:55:44 * hackagebot twitter-conduit 0.0.2.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.2.1 (TakahiroHimura)
09:01:17 <thomas358> hmm I htink I didn't fully understand the solution to my previous question
09:05:26 <tanmaig> Hi. Can someone help me out with figuring how to catch non IO monad exceptions.
09:05:51 <tanmaig> I have an exception in the zeromq monad.
09:05:53 <thomas358> tanmaig: do u mean _fail?
09:06:08 <tanmaig> thomas358: Let me check
09:06:23 <thomas358> tanmaig: as in http://www.haskell.org/haskellwiki/All_About_Monads#Failure_IS_an_option
09:06:59 <corgifex> that's fail, not _fail
09:07:48 <tanmaig> So fail is to throw exceptions right? And catching IO ones is with catch, handle, etc.
09:07:56 <corgifex> not really
09:08:53 <tanmaig> The problem I'm facing is I can't catch the errors inside some other monadic sequence (ZMQ)
09:09:07 <tanmaig> The zmq code looks something like this: main :: IO()
09:09:25 <tanmaig> main = runZMQ $ do { ...zmq actions ... }
09:09:31 <tanmaig> I'm sorry
09:10:01 <tanmaig> Oh no wait.
09:10:01 <corgifex> what's ZMQ?
09:10:04 <tanmaig> Yeah, thats right.
09:10:07 <tanmaig> ZeroMQ
09:10:15 <tanmaig> the message passing library.
09:10:24 <corgifex> yes, how does it work?
09:10:49 <tanmaig> So the think is once I'm inside runZMQ I can use liftIO to execute IO actions
09:10:56 <Paradoxic> Are you taking about this? http://zeromq.org/
09:10:59 <tanmaig> Like: liftIO $ putStrLn "Hello"
09:11:04 <tanmaig> Paradoxic: yes
09:11:17 <Paradoxic> tanmaig: It is pretty interesting.
09:11:54 <tanmaig> Paradoxic: Yes it is :) Except there are very few complex examples with Haskell. So I couldn't find an example of the error handling.
09:11:58 <corgifex> that looks like python, not haskell
09:12:20 <tanmaig> corgifex: It has bindings to a bazillion languages.
09:12:28 <tanmaig> corgifex: It's written in C I think.
09:12:50 <tanmaig> But anyway, how do I catch something that is not an IO action?
09:13:01 <tanmaig> Is there a generic way of doing something I'm missing.
09:13:06 <c_wraith> You don't
09:13:13 <tanmaig> Ah.
09:13:19 <c_wraith> catching exceptions violates the semantics of pure evaluation
09:13:26 <c_wraith> So it can only be done in IO
09:13:47 <tanmaig> But in MonadIO ?
09:13:57 <tanmaig> ZMQ is a MonadIO
09:13:59 <corgifex> tanmaig: which one are you using?
09:14:13 <c_wraith> Does it have a MonadCatchIO or a MonadControl instance, or something like those?
09:14:40 <tanmaig> corgifex: ZMQ3 Bindings are at: https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ4/Monadic.hs
09:14:50 <c_wraith> tanmaig: look at instance lists!  they're *really* important
09:14:54 <tanmaig> c_wraith: I'll just check.
09:15:16 <c_wraith> tanmaig: ah, there's a MonadCatch instance
09:15:19 <c_wraith> that probably does it
09:15:35 <tanmaig> c_wraith: Just saw it.
09:15:56 <tanmaig> c_wraith: Ok. This should do it. Thanks!
09:17:07 <thomas358> I'm still having issues with this http://lpaste.net/102372
09:17:21 <thomas358> it works fine if I don't use type in defining BasicOrderBook
09:17:25 <Algebr> Is IO a type class and therefore everything can have an IO version of it?
09:17:46 <corgifex> Algebr: no
09:17:47 <thomas358> IO is a monad.
09:18:08 <corgifex> thomas358: IO is also a functor
09:18:15 <pavonia> It's a type constructor
09:18:29 <pavonia> Like Maybe or []
09:18:38 <c_wraith> pavonia's answer is the best one.
09:18:43 <pavonia> \o/
09:18:48 <c_wraith> IO is a type constructor.  Nothing more, nothing less.
09:19:13 <Hafydd> Moreover, being a type class would not entail that there is a "version" of each type according to it.
09:20:01 <joelteon> so can typeclasses be called "constraint constructors"?
09:20:14 <joelteon> well, the class name
09:20:17 <Kaidelong> why not
09:20:19 <c_wraith> sure.
09:20:21 <bitemyapp> joelteon: sure.
09:20:33 <joelteon> don't be too enthusiastic, guys
09:20:44 <c_wraith> I've written code that uses kinds like k -> Constraint before!
09:20:46 <Kaidelong> then we can say haskell lacks the feature of first-class constraint constructors
09:20:51 <bitemyapp> joelteon: but do you know what is conceptually happening when you have a type signature like myF :: Num a => a -> a -> a ?
09:21:02 <joelteon> that's asking a lot of me right now
09:21:02 <hexagoxel> when i have nested monad-transformers, is there any way to remove the need for lifting stuff, or more general: to merge monad transformers?
09:21:11 <pavonia> thomas358: What's BasicOrderBook?
09:21:16 <bitemyapp> joelteon: no it's not. We can walk through it.
09:21:31 <bitemyapp> joelteon: so typeclasses are sometimes referred to as being like dictionary passing.
09:21:37 <c_wraith> hexagoxel: you can use classes, the way mtl does with MonadState and MonadReader
09:21:40 <joelteon> hexagoxel, I think transformers/mtl are written in such a way that lifting shouldn't usually be necessary
09:21:46 <bitemyapp> joelteon: the dictionary is the methods for the specific typeclass instance used when the function is invoked.
09:21:54 <thomas358> pavonia:it's a map where key is a float and value is a bankersDequeue parametized by OrderType
09:21:56 <c_wraith> hexagoxel: But I generally prefer being more explicit than that.
09:22:02 <joelteon> bitemyapp: ok
09:22:12 <bitemyapp> joelteon: there's not deep magic involved with a Num a => constraint. You're asking for instance of the Num typeclass dictionary to be passed along with the type it's to be used for.
09:22:17 <joelteon> that's cool
09:22:22 <bitemyapp> joelteon: so, if one has +, there's + for Ints, + for Doubles, etc. right?
09:22:28 <joelteon> yep
09:22:32 <bitemyapp> joelteon: the whole Num typeclass has dictionary objects associated by type
09:22:39 <bitemyapp> plusInt, plusDouble, etc.
09:22:43 <pavonia> thomas358: Oh well, Could you paste some more code? It's not clear where the problem is
09:23:13 <bitemyapp> joelteon: you can monomorphize 'Num a => a -> a -> a' yourself by splitting out the call sites into their constitutent types and Num dictionaries.
09:23:24 <joelteon> right
09:23:27 <jophish> Is PolyKinds safe?
09:23:34 <fizbin> Is there anything that type classes provide that couldn't be provided by passing another argument (a structure representing the instance)?
09:23:36 <Algebr> Okay, so IO is a type constructor and so there could be IO String, IO Integer, IO <anything>?
09:23:37 <bitemyapp> joelteon: I think of typeclasses as ways of expressing constraints, but I hadn't called them a constraint constructor before.
09:23:45 <joelteon> Algebr: yes
09:23:58 <bitemyapp> joelteon: from a different point of view, it's establishing the demand/constraint that an associated dictionary of "verbs" be provided.
09:23:59 <thomas358> pavonia: sure give me a few minutes.  I'll try to simplify the problem as much as possible
09:24:22 <pavonia> okay
09:24:40 <bitemyapp> joelteon: 'Num a => a -> a -> a' polymorphically turns into: 'NumDict a -> a -> a' which could then be monomorphized.
09:24:44 <thomas358> pavnoia:  I think the problem is that when using type synonyms in instances they have to be fully realized
09:24:46 <bitemyapp> joelteon: the dictionary is just another function argument.
09:25:03 <thomas358> pavonia: type synonyms in instances must be fully applied
09:25:16 <Kaidelong> NumDict a -> a -> a -> a you mean?
09:25:45 <pavonia> thomas358: Using type synonyms in instances isn't a good idea
09:25:46 <joejev> Are there any good resources for understanding when and why to use template haskell, I just used the text-rawstring-qq package for working with regex, and this seems really awesome.
09:25:48 <bitemyapp> Kaidelong: sorry, yes!
09:26:25 <thomas358> pavonia: do u have a referenc to why?
09:26:26 <bitemyapp> joelteon: notice that when we talk about safe/sane polymorphic code, we talk about parametricity. Also notice that our Typeclass dictionary (basically a record object of methods) is parameterized on type.
09:26:53 <bitemyapp> joelteon: the main difference to be aware of between typeclasses and ML functors is that typeclasses are canonical. There's supposed to be only one valid implementation of NumDict for a given type.
09:27:05 <bitemyapp> joelteon: can I stop force-feeding you now? :)
09:27:06 <pavonia> thomas358: Not really, but we could ask here who's in favour for it :p
09:27:12 <joelteon> bitemyapp: you can if you want
09:27:35 <thomas358> pavonia: if i use data rather than type, my code works fine
09:27:59 <pavonia> great
09:28:02 <bitemyapp> joelteon: did that help?
09:28:05 <joelteon> yeah
09:28:23 <thomas358> pavonia: but i still want to use a type synonym :p
09:28:25 <bitemyapp> joelteon: it's fine to think about typeclasses in terms of "constraint", it's a good abstraction. Just remember the canonicity.
09:28:47 <thomas358> are there any reasons why type synonyms should not be used in instances?
09:28:57 <bitemyapp> thomas358: in typeclass instances?
09:29:20 <corgifex> thomas358: it's potentially confusing
09:29:39 <corgifex> if you have type Foo = Bar, you can't have separate instances C Foo and C Bar
09:29:49 <bitemyapp> nuttycom: sorry, it was too easy.
09:30:06 <pavonia> thomas358: Say your type looks like "type Foo = Bar", you could define the instance for Bar and still use Foo in your code
09:30:12 <thomas358> yes
09:30:21 <thomas358> bitemyapp: yes, in typeclass instances
09:31:01 <pavonia> There may even be better options, depending on your actual code
09:31:43 <thomas358> okay.  i see.  that's probably why partially applied types are particularly nasty
09:33:28 <hexagoxel> c_wraith, joelteon: ah thanks, i was using WriterT and StateT already, but hadn't actively used that feature :)
09:34:35 <thomas358> guess I should just newtype
09:34:36 <thomas358> http://stackoverflow.com/questions/7320646/instances-for-nested-parameterized-types
09:34:44 <hexagoxel> i guess when you nest two StateTs (for example), stuff gets ambiguous pretty fast? let' see..
09:35:00 <joelteon> can you nest two StateTs?
09:35:18 <merijn> joelteon: Yes, why not?
09:35:24 <joelteon> well yeah, you can
09:35:32 <joelteon> I'm just wondering what would happen when you used get/put
09:35:39 <geekosaur> you can but you can only access one of them directly
09:35:43 <merijn> get/put gets the outer, "lift get" the inner
09:35:46 <geekosaur> the other one you'll need to use lift
09:35:51 <c_wraith> hexagoxel: it's not ambiguous.  You just get the outermost match
09:36:10 <c_wraith> hexagoxel: even if the type matches an inner value but not the outermost one
09:39:20 <hexagoxel> hmm interesting
09:40:03 <New2Haskell> Hello guys I have another question now, I finished filtering on the colors. Now I am trying to make a function that accepts a list of figures and outputs the figure with the largest surface. I already have a method that calculates the surface expecting a single figure and outputting just a float. I have tried playing arround with the max function but ofcourse I cannot use it in the biggestSurface
09:40:03 <New2Haskell> method.. Anybody has any advice?
09:40:31 <Algebr> So stuff that's in rts, all that C code could in principle be rewritten in Haskell, right?
09:40:58 <haasn> New2Haskell: have a look at maximumBy
09:41:06 <New2Haskell> i see
09:41:08 <haasn> (or implement it yourself as a learning experience)
09:41:22 <haasn> :t maximumBy
09:41:22 <lambdabot> (a -> a -> Ordering) -> [a] -> a
09:41:42 <corgifex> :t maximumBy (comparing ?area)
09:41:43 <lambdabot> (Ord a1, ?area::a -> a1) => [a] -> a
09:41:54 <kuribas> Would be it possible to define a heterogenous map, so I could do: "hlookup :: Hmap	-> Key a -> a", with Key being a GADT?
09:42:31 <corgifex> kuribas: I don't see why not
09:42:34 <shachaf> kuribas: http://hackage.haskell.org/package/vault
09:42:35 <nicoo> kuribas: I know a lib which does that
09:42:43 <corgifex> you may need a Typeable or two
09:42:56 <no-n> woot
09:42:59 <no-n> making some progress
09:43:23 <nicoo> kuribas: ixSet, IIRC
09:43:37 <kuribas> Oh, nice!
09:43:57 <nicoo> kuribas: http://hackage.haskell.org/package/ixset-typed
09:44:40 <Algebr> Is there any connection between the monad laws and linear functions?
09:45:22 <haasn> I'm not sure how ixset is relevant
09:46:23 <prophile> Algebr: yes
09:46:32 <prophile> in that they both obey category laws
09:47:02 <kuribas> Hm, not quite what I meant...
09:47:09 <prophile> the monad laws are the category laws for a kleisli category, linear maps obey the category laws for the category of modules(?)
09:47:25 <prophile> yes, modules over a given ring
09:48:04 <Algebr> nuts.
09:48:05 <monochrom> that is hardly a connection
09:48:25 <monochrom> I am moral. you are also moral. are we connected? I think not.
09:50:13 <no-n> now why does runRWS want an RWS r w s a AS WELL AS ANOTHER r and s???
09:50:19 <ReinH> monochrom: killjoy :p
09:50:39 <corgifex> no-n: what do you mean, "another"?
09:50:41 <geekosaur> no-n: an RWS does not contain an r or an s
09:50:48 <geekosaur> it *uses* them
09:50:53 <no-n> oh yes,
09:50:59 <no-n> it stores a function that takes, them
09:51:08 <no-n> my bad =)
09:51:10 <geekosaur> because it uses them, it must mention them in its type
09:51:20 <corgifex> that's like saying: why does map want an (a -> b) AS WELL AS ANOTHER list of a's?
09:51:21 <monochrom> @quote monochrom money
09:51:22 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
09:51:31 <no-n> gotcha
09:56:06 <geekosaur> (also if you think about this, you understand why IO String doesn't contain a String)
09:56:15 <geekosaur> it's exactly the same thing
09:56:33 <haasn> prophile: linear maps obeying the category laws of their respective category isn't a result of them being linear, though; those laws are free for all functions between sets
09:56:35 <quicksilver> also why a recipe book doesn't contain any cake!
09:57:08 <prophile> haasn: yes
09:57:13 <monochrom> my DNA doesn't contain me. I contain my DNA. hmm, so String contains IO String? :)
09:57:33 <haasn> monochrom: yes, you can extract it using ‘return’
09:57:40 <monochrom> \∩/
09:57:53 * haasn .oO( return :: Cake -> Recipe Cake )
09:58:02 <haasn> Ingredients: 1 Cake
09:58:10 <prophile> hah
09:58:14 <monochrom> tautological recipes
09:58:53 <ion> haasn++ monochrom++
09:59:49 <corgifex> I take it you haven't heard of recipe cake
09:59:55 <corgifex> it's made from various recipes
10:00:20 <monochrom> you're right, but I have heard of IO (IO Cake)
10:00:45 <monochrom> also [IO [IO ()]] etc
10:00:50 <ion> How do i get the Cake (Cake IO) out of an IO (IO Cake)?
10:01:02 <kuribas> Let's say I have a heterogenous map lookup, "hlookup :: Hmap -> Key a -> a", and I want to parametrize it over keys, I would have "hlookup :: Eq k => Hmap k -> k a -> a", it doesn't seem legal?
10:01:11 <corgifex> how do I get the constraint out of a constraint violation?
10:01:14 <geekosaur> IO, IO, it's off to (>>=) I go
10:01:25 <haasn> monochrom: duplicate (return cake)
10:01:51 <monochrom> @remember geekosaur IO, IO, it's off to (>>=) I go
10:01:51 <lambdabot> I will remember.
10:02:06 <geekosaur> pretty sure I'm remembering that from a past quote
10:02:16 <kuribas> Is what I am trying to do impossible?
10:02:16 <monochrom> hrm!
10:02:18 <ion> Иꙮ
10:02:23 <bitemyapp> geekosaur: LOL
10:02:57 <monochrom> I see
10:03:17 <monochrom> @quote iulus off.to
10:03:17 <lambdabot> iulus says: IO, IO, it's off to bind we go ...
10:03:25 <haasn> kuribas: that specific type signature is impossible; kind error
10:03:37 <monochrom> @forget geekosaur IO, IO, it's off to (>>=) I go
10:03:38 <lambdabot> Done.
10:03:47 <haasn> kuribas: you'd need to modify Eq to something that works on things of kind * -> *; and for a Map you probably also want Ord and not Eq
10:04:17 <haasn> I think you'd internally need something like compare :: Key a -> Key b -> Ordering
10:04:45 <kuribas> haasn: Not if I use an association list.
10:05:04 <haasn> yeah, fair point, if you can live with the asymptotic behavior
10:05:25 <kuribas> Yes, I was thinking about just a few values, maybe ten or less.
10:05:41 <kuribas> Anyway, that doesn't matter so much.
10:06:10 <kuribas> So "k a" could be legal with another type class?
10:08:45 <pordan30> i was told recently that for a map m and a list es of key/value pairs, it is sometimes more efficient to insert es into m by taking the union of m and a map constructed from es instead of inserting each pair in es into m. this just doesn't seem right to me, given the worst-case behavior of (hedge) union and insert. is there some edge case i'm missing?
10:10:27 <haasn> kuribas: perhaps; although you could also store the function inside the Hmap itself instead of using a TC
10:12:41 <augur> geekosaur: lolololol
10:12:52 <haasn> shachaf: I don't quite understand this package; what's the distinction between this and just using separate STRefs? solely the fact that you can delete a key from a vault?
10:13:02 <haasn> (what about something like STVar? does that exist?)
10:13:19 <haasn> (certainly IOVar seems to me like a replacement for Vault RealWorld)
10:13:28 <haasn> s/IOvar/MVar/
10:14:43 <bitemyapp> haasn: I was about to ask you what the hell an IOVar was.
10:17:14 <kuribas> haasn: I was thinking along this line, but this doesn't work: http://lpaste.net/102379
10:18:08 <kuribas> It doesn't infer that the types for event are the same from '=='.
10:20:56 * hackagebot puzzle-draw 0.1.0.0 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.1.0.0 (vollmert)
10:20:58 * hackagebot puzzle-draw-cmdline 0.1.0.0 - Creating graphics for pencil puzzles, command line tools.  http://hackage.haskell.org/package/puzzle-draw-cmdline-0.1.0.0 (vollmert)
10:23:05 <shachaf> haasn: ?
10:23:16 <shachaf> haasn: You don't need IO/ST to read.
10:23:22 <shachaf> Or even to insert, for that matter.
10:23:32 <geekosaur> kuribas, pretty sure you need to expose the a in KeyPair for that to work
10:23:51 <shachaf> In fact you don't need it for anything except making keys.
10:27:28 <haasn> shachaf: oh, yes, of course - you can generate a bunch of keys in IO and then pass around and work with vaults in a pure fashion; that makes sense
10:28:02 <kuribas> less elegant, but works: http://lpaste.net/102379
10:28:26 <kuribas> geekosaur: If I expose the a in KeyPair I get a homogenous map...
10:29:28 <haasn> shachaf: for ST it looks a bit more constrained, though; Vault and Key are parametrized over ‘s’ so they can't escape runST, so in the context of where Vault s can be make sense you could also just run ST operations - but that still doesn't let you mix it with other pure functions like foldr, I guess
10:29:32 <haasn> fair enough
10:35:58 * hackagebot tz 0.0.0.4 - Time zones database and library  http://hackage.haskell.org/package/tz-0.0.0.4 (MihalyBarasz)
10:40:17 <Algebr> Does anyone here use gtk2hs?
10:41:13 <Fuuzetsu> a bunch of people
10:41:18 <dcoutts> Algebr: ask your question, don't ask if you can ask a question :-)
10:42:49 <Algebr> 1) Is it basically the best/de facto GUI toolkit for Haskell, 2) For people on osx, does cabal install gtk-mac-integration work for you? I can't get it to install, I understand that the mac-integration makes your apps look native.
10:42:56 <solarus> kuribas: you could do this http://lpaste.net/102379 :)
10:43:34 <merijn> Algebr: The basic state of GUI toolkits for Haskell is that they're all kinda sucky, unfortunately :\
10:43:56 <dcoutts> Algebr: I think the answer to 1 is yes, as for 2 some people have got the native osx look working, but I've no idea how hard it is
10:44:30 <kuribas> solarus: Yeah, that's somewhat better.
10:46:04 <Algebr> But gtk2hs seems to have the most active development of the lot.
10:46:24 <Algebr> methinks.
10:48:19 <geekosaur> kuribas, yes you do. with that forall you cannot *use* what's inside it though, as you insist on doing. without it you must use the same types
10:48:30 <geekosaur> which means you're not approaching this correctly
10:48:35 <geekosaur> and must rethink what you are trying to do
10:49:01 <geekosaur> because it will not work the way you are trying to do it; you can't have it both have a type so you can access it directly and not have a type so you can store it in the same Map
10:50:24 <kuribas> geekosaur: Well, that's what the last versions do, right?
10:51:04 <kuribas> geekosaur: Which forall do you mean?
10:51:38 <geekosaur> the one that is implicit in your GADT because you talk about an "a" but don't specify what it is
10:51:46 <kuribas> Ah...
10:51:57 <geekosaur> nor do you let it be passed in
10:52:01 <geekosaur> (in the type, that is)
10:52:24 <geekosaur> so outside the GADT, there's an "a" and no way to know what it is
10:52:45 <kuribas> geekosaur: yes, through the "MyEvent a" ?
10:53:30 <geekosaur> the one you told me you couldn't use. (I'm still catching up after being booted by housekeeping....)
10:55:52 <kuribas> My last version seems to work: http://lpaste.net/102379
10:56:00 * hackagebot hakyll 4.5.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.1.0 (JasperVanDerJeugt)
10:56:30 <no-n> @pl \(x,y,_) -> (x,y,mempty)
10:56:30 <lambdabot> (line 1, column 7):
10:56:30 <lambdabot> unexpected "_"
10:56:30 <lambdabot> ambiguous use of a non associative operator
10:56:48 <no-n> @pl \(x,y,z) -> (x,y,[])
10:56:48 <lambdabot> (line 1, column 7):
10:56:48 <lambdabot> unexpected "z"
10:56:48 <lambdabot> ambiguous use of a non associative operator
10:57:06 <no-n> wut
10:59:02 <solarus> I think only tuples with two elements is supported
10:59:49 <kuribas> geekosaur, haasn: I added an example: http://lpaste.net/4371679208657649664
11:01:24 <kuribas> thanks to solarus
11:04:02 <gamegoblin> Huh. hlint just suggested to me something like:
11:04:18 <gamegoblin> if b then [something] else []
11:04:19 <kuribas> What I like about this is that I can take a pure datatype as key, instead of having to keep a reference to the key like in Vault.
11:04:25 <gamegoblin> can be [something | b]
11:04:36 <gamegoblin> Didn’t know you could have a list comprehension without a range to iterate over
11:05:07 <corgifex> I guess it makes sense since _ <- [()] is the identity
11:05:31 <gamegoblin> mmm I suppose so
11:05:41 <kuribas> or (guard b >> [something])
11:05:51 <corgifex> @undo [something | b]
11:05:51 <lambdabot> if b then [something] else []
11:06:04 <gamegoblin> ha
11:06:08 <gamegoblin> Funny
11:06:25 <gamegoblin> @undo
11:06:25 <lambdabot> Error: expected a Haskell expression or declaration
11:06:33 <gamegoblin> What does @undo do?
11:06:52 <merijn> gamegoblin: unsugars do-notation
11:06:58 <gamegoblin> ahh thanks
11:07:33 <merijn> @undo do { foo; bar; x <- xyzzy; baz x; return () }
11:07:34 <lambdabot> foo >> bar >> xyzzy >>= \ x -> baz x >> return ()
11:07:40 <no-n> would it be possible to make triplets Applicatives
11:07:59 <no-n> so I could go (id,id,const mempty) <*> blah
11:09:27 <corgifex> instance (Monoid a, Monoid b) => Applicative ((,,) a b) where pure x = (mempty, mempty, x); fmap f (a, b, x) = (a, b, f x); (a1, b1, f) <*> (a2, b2, x) = (a1 <> a2, b1 <> b2, f x)
11:09:43 <no-n> :D
11:10:52 <gdoteof> http://lpaste.net/102385  i am having trouble parsing Types with different constructors.  i am getting ane rror about the "command" key not being found
11:11:03 * hackagebot http-conduit-downloader 1.0.17 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.17 (VladimirShabanov)
11:11:15 <corgifex> > set _3 'x' (1, 2, 3)
11:11:17 <lambdabot>  (1,2,'x')
11:11:29 <gdoteof> if i make the same request with the file commented as above, the request works (there is indeed a command key) but if i uncomment the other contstructor, the parsing no longer works and it complains there is no 'command'
11:13:09 <no-n> :t set
11:13:09 <lambdabot> ASetter s t a b -> b -> s -> t
11:13:30 <no-n> I should probably just use a lambda
11:16:44 <corgifex> > (a, b, c) & _3 .~ x
11:16:46 <lambdabot>  (a,b,x)
11:17:13 <corgifex> > "abc" & _3 .~ 'x'
11:17:14 <lambdabot>  No instance for (Control.Lens.Tuple.Field3
11:17:14 <lambdabot>                     [GHC.Types.Char] a0 a1 GHC.Types.Char)
11:17:14 <lambdabot>    arising from a use of `e_13'
11:17:14 <lambdabot>  Possible fix:
11:17:14 <lambdabot>    add an instance declaration for
11:18:45 <k00mi> > "abc" & ix 2 .~ 'x'
11:18:47 <lambdabot>  "abx"
11:26:05 * hackagebot cao 0.1.1 - CAO Compiler  http://hackage.haskell.org/package/cao-0.1.1 (tfaoliveira)
11:32:37 <NikolajK> do people generally replace for loops with folds?
11:33:13 <pranz> NikolajK: depends on what you want to do in the loop
11:33:30 <ast_> anybody using gloss on linux?
11:33:43 <ast_> got 100% cpu usage with gtk(?)
11:34:22 <NikolajK> pranz: else you use do?
11:34:29 <pordan30> there are a number of recursion patterns in standard haskell - fold, map, mapAccum, among others - that replace loops in other languages
11:34:45 <NikolajK> PS: pranz is Viennese magic the gathering slang for having luck
11:35:08 <pranz> NikolajK: hmm? "do" has really nothing to do with loops
11:35:13 <pranz> oh really? that's interesting
11:35:42 <geekosaur> it sort of does
11:35:50 <geekosaur> because lists are monads
11:35:57 <pavonia> ast_: Do you have an example?
11:35:57 <bitemyapp> geekosaur: awwww shiiiiit fight fight
11:36:10 <geekosaur> and when you use the list monad, you are implicitly looping
11:36:24 <NikolajK> and it derives from peeing. brunzen is lower dialect for peeing in eastern austria
11:36:35 <geekosaur> (remember that (>>=) is concatMap in [])
11:37:05 <NikolajK> how does map do loops?
11:37:28 <corgifex> map loops over a list
11:37:40 <geekosaur> a Haskell list is a loop phrased as data instead of a control structure. so if you map over it, you are looping over it
11:37:43 <pranz> but I think it's a stretch to say that do and (>>=) has something to do with looping
11:37:48 <NikolajK> map f [a,bc] is [f a, f b, f c] right?
11:37:51 <geekosaur> likewise folds are looping with an "accumulator"
11:38:13 <geekosaur> yes. "f" is your loop body, in procedural syntax
11:38:19 <corgifex> > do { x <- [1, 2, 3]; y <- "ab"; return (x, y) }
11:38:20 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
11:38:31 <geekosaur> (in fact there's an arguments-flipped version of "map" called "for")
11:39:00 <NikolajK> kk
11:39:18 <NikolajK> the do notation is strange to me - it seems off, compared to the other notation
11:39:21 <geekosaur> laziness is what makes this equivalence possible
11:39:32 <NikolajK> foo <— bar in particular
11:39:48 <corgifex> > do { x <- [1 .. 10]; guard (even x); return (chr (64 + x)) }
11:39:49 <lambdabot>  "BDFHJ"
11:40:07 <pranz> NikolajK: I don't know if is any help to you, but that's just syntactic sugar that desugars into (>>=) calls
11:40:18 <geekosaur> it takes some getting used to. remember that -> is actually >>=, which in lists is concatMap
11:40:34 <pranz> do {x <- getLine; putStrLn x} = getLine >>= putStrLn
11:40:36 <geekosaur> so it does something to every item in the list and concatenates the result into a new list
11:40:59 <geekosaur> then you specify what you want to do with an item and the list monad implicitly applies that to every item in the list
11:41:05 <NikolajK> I must first build up some intuition for >>=
11:41:14 <NikolajK> it has type ma->a->mb right
11:41:20 <NikolajK> to something
11:41:24 <pranz> :t (>>=)
11:41:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:41:25 <corgifex> m a -> (a -> m b) -> m b
11:42:05 <NikolajK> that's very off, categorically speaking. In particular, the diagonal (a -> m b) map is weird
11:42:11 <geekosaur> so for the list monad, m is []. (here it helps to recall that [a] can also be written as [] a)
11:42:40 <geekosaur> so [a] -> (a -> [b]) -> [b]
11:43:09 <hc> speaking of list monads; is it a bad thing to do something like do a <- [1,2,3]; [a, a]
11:43:09 <NikolajK> yeah, I draw this pic
11:43:09 <NikolajK> http://axiomsofchoice.org/_media/my_monad_art.png?cache=
11:43:10 <geekosaur> which tells you exactly what it does: runs the function over every item in the list, resulting in a list of lists, and then concatenate the inner lists
11:43:13 <hc> in terms of style, i mean?
11:43:35 <hc> (sry for my bursting into thi,s i've got a laggy connection)
11:46:12 <pranz> NikolajK: mathemathicans usually define monads via the return and join functions, which I think is easier to understand
11:46:13 <pranz> :t join
11:46:14 <lambdabot> Monad m => m (m a) -> m a
11:46:16 <merijn> hc: Well, I'd prefer list comprehension to do-notation for lists (when that's clearer), but it's not particularly bad or anything
11:46:55 <geekosaur> NikolajK, return / join / fmap is definitely easier to understand for lists, because fmap is map and join is concat
11:46:58 <shachaf> superjoin :: Free m a -> m a
11:47:00 <hc> merijn: even though i'm explicitely using a monad constructor instead of return?
11:47:13 <pranz> a >>= f is just join (fmap f a)
11:47:19 <merijn> hc: Yeah, it just takes a bit longer to parse like that :)
11:47:20 <geekosaur> and return is (:[])
11:47:46 <shachaf> Given data Froo f a = Pure a | Froo (Froo f (f a)), you can also make superjoin :: Monad m => Froo m a -> m a
11:48:30 <NikolajK> is there any category emphasising book on Haskell?
11:48:30 <NikolajK> I know but don't quite like Learn yourself, Real world and Intro to Logic via
11:48:35 <shachaf> In some ways it seems more like what I was trying to get at -- it gives you (a | m a | m (m a) | ...) -> m a, whereas the Free thing is more complicated.
11:48:42 <Mango_Man> what do you haskellers think of reading this book for learning haskell? http://www.amazon.com/Beginning-Haskell-A-Project-Based-Approach/dp/1430262508/
11:49:46 <zerokarmaleft> Mango_Man: I'm reading it now and enjoying it thus far
11:50:19 <Mango_Man> zerokarmaleft: sounds good, i'm buying it
11:50:32 <Algebr> So just like the Prelude, if I import a module that itself imports modules, those 2nd-level imports are also available to me, correct?
11:50:48 <zerokarmaleft> Mango_Man: it's a nice complement to LYAH
11:51:13 <pavonia> Algebr: No
11:51:24 <merijn> Algebr: Only if those modules are re-exported
11:51:36 <byorgey> NikolajK: not that I know of.
11:51:51 <favetelinguis> after installing haskell platform, what more is reuired to use "import Data.Default"??
11:52:06 <favetelinguis> ghci says it cant find module
11:52:12 <NikolajK> I'd really like to learn the language with an attempt of conveying the categorical semantics of the type system you build
11:52:23 <geekosaur> favetelinguis, that is not part of the platform
11:52:39 <pavonia> @hackage data-default
11:52:39 <lambdabot> http://hackage.haskell.org/package/data-default
11:52:43 <geekosaur> you need to install the data-default package
11:52:48 <merijn> favetelinguis: I don't think the data-default package is in platform?
11:53:49 <favetelinguis> hmm ok thougt since Data.List was included that everything that starts with Data.* would work :s wrong conclution
11:55:29 <Kaidelong> isn't Data.Default considered crufty?
11:56:40 <favetelinguis> it is used in the book im following "Beginning Haskell" dont know much else about it
11:56:57 <jophish> Is PolyKinds safe?
11:57:12 <byorgey> jophish: yes
11:58:11 <geekosaur> I was not under the impression Data.Default was crufty...
11:58:43 <Clint> i think it's the opposite of crufty
11:59:11 <meretrix> Is using a FunPtr callback generally more efficient than having to malloc/free a returned pointer?  (I'm trying to return a CString to Haskell as a String.)
12:00:05 <meretrix> I guess I'm asking does the FunPtr need to be heap allocated.
12:00:41 <merijn> meretrix: You mean if you wrap a haskell function to create a FunPtr to pass to C?
12:00:55 <meretrix> merijn: Yes.
12:01:04 <merijn> meretrix: Allocating a FunPtr is *very* expensive
12:01:16 <merijn> meretrix: It involves allocating pinned pages and what not
12:01:53 <merijn> meretrix: So if the alternative to creating a FunPtr multiple times is malloc/free instead, malloc/free will almost certainly be cheaper
12:02:10 <meretrix> Ah ok.  This packages I'm trying to extend uses it quite a bit, so that's surprising.
12:02:29 <meretrix> Is it possible to create a FunPtr once and use it multiple times?
12:02:43 <merijn> meretrix: Yes, so if you do that it will amortize over time
12:02:49 <Algebr> Why do people give the signature for main? Isn't it always the same?
12:03:44 <merijn> Algebr: No, the report states any type of the form "IO ?" is fine, so there's two reasons: 1) consistency (always have top level signatures) and 2) ensuring you don't accidentally return a type different from you expected from main
12:04:34 <Nik05> hello, is there some lazy analysis tool (or noob tool), that shows steps that are done?
12:04:42 <Nik05> step by step?
12:05:48 <sm> Nik05: the cheapest form of that is to litter your code with trace statements and watch stdout as it runs
12:06:10 <Nik05> ok thank you :)
12:06:24 <Algebr> gtk2hs users, do you use Glade or just put everything in code?
12:06:27 <Nik05> oh and is there a less cheaper way? :P
12:06:34 <Algebr> Seems like glade is a nice tool.
12:06:56 <zerokarmaleft> Nik05: I prefer clojure.tools.trace
12:07:22 <Nik05> but thats clojure..
12:07:23 <sm> there have been some evaluation visualising tools posted, but I imagine they work only for small examples - is that what you're looking for ?
12:07:50 <zerokarmaleft> Nik05: oops, didn't realize what channel I was in :P
12:07:56 <Nik05> yes it a small sample from the real world haskell book (the foldl implemented with foldr :P)
12:08:30 <zerokarmaleft> though I believe haskell has something similar in the way of Debug.Trace
12:08:54 <Nik05> http://hackage.haskell.org/package/ghc-vis can this work?
12:09:15 <sm> Let us know. :) There's also some discussion  at http://stackoverflow.com/questions/799956/view-reduction-steps-in-haskell
12:09:44 <sm> perhaps Cale knows more about this
12:11:41 <sm> Nik05: also browse hackage, eg http://hackage.haskell.org/packages/#cat:Debug
12:12:28 <Nik05> thank you :) i will try to find if i can get one working
12:27:09 <no-n> how do I write to the RWS writer?
12:28:20 <dwcook> no-n, MonadWriter instance
12:29:23 <no-n> writer, tell, listen, pass? I don't understand how to use them.
12:29:53 <geekosaur> `tell` is how you append stuff to the writer
12:30:01 <dwcook> no-n, tell is the basic accumulation method
12:31:03 <no-n> could I get a simple example of tell?
12:31:28 <dwcook> tell "Message to add to the message queue"
12:31:37 <geekosaur> mhh? it just takes a w and uses mappend to add it to the writer
12:34:15 <dwcook> > runRWS (tell "Message 1\n" >> tell "Message 2\n") () ()
12:34:16 <lambdabot>  ((),(),"Message 1\nMessage 2\n")
12:34:36 <no-n> agh, i got it
12:34:38 <dwcook> (I could as well have used Writer instead of RWS here)
12:34:38 <no-n> thanks
12:34:40 <no-n> ahh*
12:34:44 <Algebr> So say I make my exectuable with ghc and I used gtk2hs, presumably the people I give the exectuable to, they also need all that gtk stuff installed as well for the run-time or does my executable contain all that stuff as well?
12:35:31 <geekosaur> if you built static, the libraries are installed. however gtk+ also has a bunch of data files (stock icons, menus, etc.) that they would need
12:35:34 <geekosaur> and can't be bundled
12:36:09 <Algebr> static is presumably a flag to ghc? And If I do that, then my exectuable will be much larger?
12:36:43 <geekosaur> or to cabal
12:37:01 <Algebr> ah, and then end users could just cabal install <mything>
12:37:20 <geekosaur> my point was mpore that even if you use it, it doesn't help you much because they still need a bunch of stuff that is part of gtk+ but not stored in your executable
12:37:33 <geekosaur> so you might as well build dynamic and accept that they need to install gtk+ from somewhere
12:38:30 <Algebr> So cabal abstracts away the platforms for me as well? like someone doing cabal install <something> gets the same result if they are on linux or windows?
12:38:51 <S11001001> Algebr: insofar as you aren't doing nonportable things in your haskell program.
12:39:39 <geekosaur> depends. ingeneral you need C libraries from somewhere
12:40:11 <geekosaur> I *think* I had heard that the cabal gtk+ stuff bundled windows libs these days? because otherwise installing gtk+ on windows is something of a pain
12:41:05 <geekosaur> so you should get everything needed for windows, but for linux you (= the installer of your program) need to use your package manager to install at least the runtime stuff (usually preinstalled on most linuxes) and possibly the dev packages (not generally preinstalled)
12:41:14 * hackagebot GlomeTrace 0.3 - Ray Tracing Library  http://hackage.haskell.org/package/GlomeTrace-0.3 (JimSnow)
12:41:16 * hackagebot GlomeView 0.3 - SDL Frontend for Glome ray tracer  http://hackage.haskell.org/package/GlomeView-0.3 (JimSnow)
12:42:58 <no-n> @pl \x -> tell ["hello","world"] >> return x
12:42:58 <lambdabot> (tell ["hello", "world"] >>) . return
12:43:26 <Platz> For some reason I never thought of it myself, but I found out it's pretty easy to set runghc in the shebang line on linux scripts.  Might be nice to just write scripts in haskell and have the OS run them transparently.
12:43:55 <ion> no-n: x <$ tell ["hello","world"]
12:44:03 <jle`> x <$ tell ["hello", "world"]
12:44:15 <no-n> ty
12:44:19 <jle`> oops
12:44:28 <no-n> how am i going to get the x if it's pl tho
12:44:48 <no-n> hmm, section i guess
12:44:54 <no-n> :t (<$)
12:44:55 <lambdabot> Functor f => a -> f b -> f a
12:44:57 <jle`> (<$ etc.)
12:45:00 <no-n> ye
12:45:13 <jle`> but consider not making it point free
12:45:20 <no-n> that was a silly question. i'm so sleep deprived.
12:46:10 <Nik05> hm that ghc-vis works really well... assertion failed :P
12:49:16 <ion> no-n: If you find it an effort to make some expression pointless, it will most likely be an effort to understand the expression when reading it later. One should avoid obfuscation.
12:49:33 <no-n> couldn't agree more
12:49:49 <no-n> but sometimes there's a good way to do it that I didn't know about
12:50:56 <dwcook> Eta reduction is usually okay, at least with non-infix, I'd say
12:51:29 <dwcook> Actually eta reduction in general
12:52:42 <Mango_Man> reading Beginning Haskell: A Project-Based Approach right now. this is so fun. :D
12:56:45 <davidfetter_disq> Mango_Man, is that paper-only?
12:56:56 <Mango_Man> davidfetter_disq: there's a kindle version
12:57:19 <davidfetter_disq> hrm. don't have a kindle. i'll look around for something else, or the paper if that fails
12:57:34 <Platz> davidfetter_disq: there's an electronic version as well
12:57:40 <davidfetter_disq> http://www.apress.com/9781430262503 <-- aha!
13:03:50 <hakujin> for creating a small, efficient protocol on top of TCP should I be using Network.Socket.ByteString (recv/sendMany) or just opening a Handle and using Data.ByteString.Builder's hPutBuilder?
13:09:51 <gaze__> hey folks, what's the status of GHC on ARM? There seems to be that neurocyte's repository on github, but HEAD seems to have some mention of androideabi in it
13:10:18 <geekosaur> 7.8 will have ARM support; it's in release candidate
13:10:29 <jophish> If something is a monoid, and it's used as such, it doesn't seem to always be the case that people use the monoid.
13:10:49 <gaze__> erp, sorry, android, not ARM support
13:10:52 <gaze__> I know ARM support is there
13:10:59 <jophish> To phrase that differently, why don't people use mempty and mappend more?
13:11:18 * hackagebot tzdata 0.1.20140324.0 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20140324.0 (MihalyBarasz)
13:11:41 <gaze__> jophish: because people haven't recognized the algebraic structure of the data they're working with, or they feel that what they're doing is somehow more semantically understandable
13:11:56 <gaze__> a monoid is obviously a very general thing
13:12:01 <geekosaur> I think native android is work in progress, it's a bit harder than on iOS where it really is native instead of being weirdshit that has to interact with a mostly java^Wdalvik ecosystem
13:12:04 <Cale> Maybe they don't need to abstract over the choice of monoid
13:12:08 <dwcook> jophish, Monoid is a tool for abstraction; with it you can write functions that work on any Monoid. But if you're writing to a particular type, there isn't as much motivation to do that.
13:12:11 <Cale> There are a *lot* of monoids
13:12:26 <gaze__> geekosaur: Say we ignore the java stuff
13:12:30 <dwcook> Which isn't to say people don't underuse it
13:12:33 <gaze__> and just wanna compile for the NDK
13:12:45 <Cale> They're almost unavoidable -- asking everything to go through that narrow interface would make a lot of code less readable.
13:12:51 <chirpsalot> geekosaur: does GHC have an iOS backend?
13:13:04 <gaze__> I did the ARM valgrind port back in the day. I really want to see the GHC android stuff wrapped up
13:13:07 <geekosaur> you can't ignore it completely, unfortunately. unless you are working rooted in which case ghc is probably not targeting your use case
13:13:08 <chirpsalot> It does! Neat.
13:13:31 <jophish> gaze__: yeah, that's pretty much what I though. What threw me was that in my case I think that mempty and <> would be a little nicer
13:14:22 <gaze__> geekosaur: I don't understand. If I just want to crank out .so files, which android supports packaging with APKs... is it an ABI thing?
13:14:44 <chirpsalot> gaze__: I was under the impression that the Android NDK wasn't really suitable for writing full applications yet?
13:14:56 <geekosaur> I am pretty sure they want to support paplications, not just .so-s
13:15:05 <yitz> jophish: frankly the cases where you need to abstract over multiple monoids are quite rare in my experience. but:
13:15:45 <gaze__> geekosaur: Well... fine, but how about the machinery to crank out arm-linux-androideabi compatible .so files. Is it there in GHC?
13:15:54 <gaze__> I just want to do my business logic in haskell.
13:15:55 <yitz> jophish: sometimes code is clearest when you use the very concise <>. other times it's clearest when you use a more type-specific function or operator.
13:16:03 <gaze__> and do my frontend stuff using java/JNI
13:16:05 <yitz> jophish: so i just flow with that.
13:16:10 <geekosaur> maybe you can talk them into believing that your use case is the only one that matters and they shouldn't waste time on the rest, but I wouldn't bet on it
13:16:13 <gaze__> err, using java and then talk to the haskell stuff over jni
13:16:39 <geekosaur> I don't know. my point is I expect the ghc devs consider that only a waypoint and they won't consider the android stuff *ready* until it handles the whole thing
13:16:42 <jophish> As another example, in this code I'm reading there is an operator (@@) which satisfies the monoid laws, and there is a valid mempty. I'd prefer to see (<>) used, because that has (a little) more information attached to it
13:16:44 <Platz> chirpsalot: one of the issues with functional programming on mobile devices is garbage collection is much more sensitive due to constrained resources.  If you're creating lots of short-lived state it can bog down the system
13:16:48 <jophish> yitz: good advice, thanks
13:16:58 <geekosaur> yes, I understand you can get by with less. this does not mean it is considered sufficient
13:17:02 <gaze__> geekosaur: Okay. Who would be most up to date on the android port status?
13:17:19 <gaze__> that does make sense definitely
13:17:27 <geekosaur> I don;t know. maybe ask in #ghc?
13:17:44 <gaze__> ahhh okay!
13:17:45 <gaze__> thank you
13:17:55 <chirpsalot> Platz: Android has a garbage collection issue already :(.
13:19:07 <pash> How do I build a Tasty test executable with cabal-dev? I have things set up so I can run `cabal-dev test`, but I can't figure out how to compile tests/test.hs directly inside the cabal-dev sandbox ...
13:19:37 <yitz> pash: use cabal's native sandboxes now. no reason to use cabal-dev anymore.
13:19:57 <gaze__> Platz: Ugh. Good point.
13:20:00 <pash> yitz: I know, but unfortunately I'm stuck with cabal-dev on this project for the moment ...
13:20:25 <yitz> pash: why?
13:20:51 <chirpsalot> Platz: maybe I'm just expecting the compiler to be way smarter than it already is, but I always feel like functional languages can do black magic with memory management. I think there are a lot of interesting things you can do with it, anyway... But that's just baseless intuition on my part.
13:20:59 <yitz> pash: i'm really not sure how well cabal-dev will work anymore. the code base isn't really supported.
13:22:02 <athan> Hey guys, this is probably splitting hairs, but would a "non-strict" language be the same as a "preferably lazy" one?
13:22:11 <pash> yitz: OK, maybe better to turn my efforts to moving to a newer version of cabal ...
13:22:41 <yitz> pash: i was worried about that for a while for my team. then we just did it, and it was smooth sailing.
13:23:23 <yitz> pash: the trick is: the cabal you need might not be the one that comes with your basic toolset, e.g. HP.
13:24:35 <pash> yitz: Yes, we're using Cabal 1.16 for this project because it's supposed to work with Platform out of the box.
13:24:40 <yitz> pash: so you bootstrap like this: 1. install a fresh HP. 2. immediately install cabal-dev, and nothing else. 3. use cabal-dev to install cabal-install from hackage. 4. put the new cabal binary in your path and kiss cabal-dev goodbye.
13:25:10 <athan> yitz: What's the major caveat of cabal-dev vs. cabal sandbox?
13:25:13 <dcoutts> pash: you can use a later cabal binary and the same older platform version
13:25:18 <yitz> pash: once the next HP comes out, that won't be necessary anymore.
13:25:53 <dcoutts> pash: in particular it's not necessary to have the newer Cabal lib installed (once cabal-install has been built)
13:26:43 <gamegoblin> is there a prelude function that does: \f x -> f x x
13:26:55 <yitz> pash: right, as dcoutts says, with my bootstrap procedure you only install new Cabal in that single cabal-dev sandbox, and then after that it's gone and everything still works fine.
13:27:21 <dcoutts> @pl \f x -> f x x
13:27:22 <lambdabot> join
13:28:24 <yitz> athan: 1. new cabal has critical features that you really want, and it doesn't work with cabal-dev.
13:28:30 <athan> dcoutts: Now, that's interesting...
13:28:34 <dcoutts> gamegoblin: just use \f x -> f x x, it's not worth obscuring your code
13:28:35 <yitz> athan: 2. cabal-dev isn't supported by anyone now
13:28:44 <athan> ahhh okay, thank you yitz
13:28:52 <athan> I had a feeling it was a migration of interests
13:28:53 <miniBill> I'm trying to use leksah, but everytime I expand a tree's node in the GUI, it crashes
13:29:08 <glguy> The only time to use join for that purpose is when you're intentionally writing obfuscated, point-free code for one-liners in IRC :)
13:29:21 <dcoutts> gamegoblin: though it's fun to work out why join does what you asked for
13:29:22 <gamegoblin> :t join
13:29:22 <lambdabot> Monad m => m (m a) -> m a
13:29:29 <gamegoblin> I am still trying to figure it out
13:29:32 <dcoutts> :-)
13:29:38 <yitz> athan: 3. native sandboxes are strictly better than cabal-dev - you can choose cabal-dev style add-source by using --snapshot, or by default you get a source link that tracks changes in the remore sources.
13:29:49 <dwcook> @type \f x -> f x x
13:29:50 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
13:29:52 <dcoutts> gamegoblin: hint: import Control.Monad.Instances
13:30:14 <pash> yitz: Yeah, I was hoping to wait for the next version of HP, but maybe I'll give it a shot. With sandboxes, is there any trick to building a test executable from the test suite's main module specified in the .cabal?
13:30:16 <dcoutts> gamegoblin: but please don't ever use it in a real program like that :-)
13:30:22 <gamegoblin> Never would
13:30:25 <dwcook> For what m do "m (m a) -> m a" and "(t1 -> t1 -> t) -> t1 -> t" unify?
13:30:29 <dwcook> gamegoblin, ^
13:30:31 <gamegoblin> I was hoping there was a base function called doubleUp or something
13:30:33 <miniBill> anyone could help me understand what's wrong?
13:30:49 <miniBill> dwcook: m = (t1 ->) ? ;)
13:30:59 <miniBill> dwcook: just a wild guess tho
13:31:11 <dwcook> miniBill, that's right.
13:31:16 <yitz> pash: cabal install --enable-tests
13:31:56 <dwcook> It helps to remember that t1 -> t1 -> t is actually t1 -> (t1 -> t) or (->) t1 ((->) t1 t)
13:32:04 <athan> dcoutts: Is that the (->) implementation of `join`?
13:32:38 * dcoutts isn't going to spoil the challenge
13:32:45 <athan> ><!
13:33:07 <athan> dcoutts: Is there a channel for people that would? :)
13:33:38 <miniBill> anyone could help me for my leksah issues?
13:33:55 <athan> miniBill: I wish I could :( I'm currently not able to get it to work
13:34:16 <athan> miniBill: Have you tried yi?
13:34:19 <gamegoblin> It took me the longest time to realize leksah is haskell backwards (almost)
13:34:25 <miniBill> athan: what's yi?
13:34:32 <gamegoblin> miniBill: another editor
13:34:35 <miniBill> gamegoblin: :O didn't notice
13:34:38 <miniBill> gamegoblin: lemme try
13:34:49 <athan> gamegoblin: ! I thought it was a convolution of "lexer" lol
13:35:00 <athan> it's emacs based (fair warning)
13:35:07 <Platz> I've seen 'join either' before
13:35:10 <Platz> :t join either
13:35:11 <lambdabot> (a -> c) -> Either a a -> c
13:35:15 <gamegoblin> ew ew ew
13:35:21 <athan> Platz: Whiggity what?
13:35:33 <Platz> commenting on old conversation, nevermind
13:35:52 <Platz> i.e. f x -> f x x
13:36:21 <yitz> @type on either
13:36:22 <lambdabot> (a -> a1 -> c) -> a -> a -> Either a1 a1 -> c
13:36:45 <aloiscochard> bitemyapp: ha!
13:36:48 <miniBill> athan: I'm emacslergic :(
13:36:50 <aloiscochard> bitraten: here you are :-)
13:36:57 <aloiscochard> oops s/bitraten/bitemyapp
13:37:30 <miniBill> @type on
13:37:31 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:37:41 <miniBill> oic
13:38:13 <athan> hahaha, me too miniBill
13:39:14 <Platz> chirpsalot: My only evidence was a podcast about scala guys doing android development.  Perhaps GHC can optimize better
13:39:40 <bitemyapp> aloiscochard: hola.
13:40:03 <Platz> chirpsalot: but the native API's don't really give you a functional interface, so some mutation is assumed
13:40:04 <geekosaur> scala has the problem that it's generating java code and requires a rather large jvm runtime support library
13:40:14 <bitemyapp> aloiscochard: http://lpaste.net/102389 my travails :)
13:40:44 <geekosaur> you can convert it to dalvik fine, what you can't really do is optimize it or leave out the parts you don't care about, unless you generate a customized runtime by hand
13:41:00 <athan> bitemyapp: Got that blog post up yet??
13:41:06 <aloiscochard> bitemyapp: that's exactly what I call ADTDD to make it sound buzy (Algebraic Data Type Driven Development), haha
13:41:26 <aloiscochard> bitemyapp: I'll follow your stuff, I'm really interested into that, it mach two techs I really like!
13:41:42 <yitz> aloiscochard: i like that. then there's GADTDD
13:41:50 <aloiscochard> bitemyapp: and cool to know you are here, we can avoid the twitter latency
13:41:55 <bitemyapp> athan: which one?
13:42:08 <chirpsalot> Platz: well, I would certainly believe that it's still an issue. You would be able to do manual memory management with the NDK, though, no? So you probably can squeeze out maximum cleverness? Like you don't have to be a layer on top of "Java" / Dalvik which also garbage collects, at least.
13:42:10 <bitemyapp> athan: http://bitemyapp.com/posts/2014-04-05-grokking-sums-and-constructors.html you want this?
13:42:14 <bitemyapp> aloiscochard: yep! :)
13:42:29 <aloiscochard> bitemyapp: have to run, talk to you soon!
13:42:29 <bitemyapp> aloiscochard: yeah sketching out the types lends a lot of clarity.
13:42:31 <athan> bitemyapp: I think it was like an implementation of dependent types or something...
13:42:32 <athan> idk
13:42:33 <bitemyapp> aloiscochard: cheers.
13:42:37 <aloiscochard> cheers
13:42:43 <bitemyapp> athan: 'ish. It doesn't implement DTs, it avoids needing them.
13:42:46 <ReinH> shachaf: I just signed up for BayHac 2014 :)
13:42:46 <aloiscochard> yitz: true! :-)
13:42:46 <athan> you should still give me the link to your blog so I can stalk you
13:42:48 <bitemyapp> athan: take a look at the post I linked.
13:42:49 <athan> er... learn from oyu
13:42:58 <bitemyapp> athan: bitemyapp.com is my blog :P
13:43:10 <geekosaur> also I have a recollection that, while dalvik can do everything that jvm bytecode can, some of the things that scala jvm bytecode does requires some roundabout foo to translate to dalvik bytecode
13:43:15 <athan> ahh hell yeah! (learnlearnlearn)
13:43:20 <bitemyapp> athan: have fun :)
13:43:21 <geekosaur> so it's less than optimal
13:43:25 <chirpsalot> Platz: I would imagine you could theoretically do about as good of a job as Java, but maybe it's still not ideal. Garbage collection on mobile is kind of questionable... Though I don't know too much about the subject.
13:44:35 <gaze__> I'd actually like to see some evidence
13:44:49 <Platz> chirpsalot: me neither ;)
13:45:04 <gaze__> that lazy pure functional languages are bad for mobile devices
13:45:20 <bitemyapp> gaze__: and Java *isn't*? Hahahahaha
13:45:31 <gaze__> java works just fine
13:45:38 <chirpsalot> gaze__: it's all going to depend upon what the compiler can do.
13:46:31 <colDrMcBeardman> in the age of cell phones with over a gigabyte of ram, is memory pressure really much of a problem?
13:46:52 <bitemyapp> colDrMcBeardman: latency is more important I'd argue.
13:47:01 <bitemyapp> colDrMcBeardman: something languages without green threads aren't known for being great at :)
13:47:05 <gaze__> and GHC's latency isn't even that bad
13:47:05 <Cale> It depends on what you're doing, but generally things ran pretty well
13:47:21 <bitemyapp> gaze__: my point is that JVM implementations are usually worse on that front :)
13:47:21 <gaze__> it's interactive. It's not real-time or audio quality, but it'll do
13:47:37 <Cale> A few years ago, major GCs caused ~300ms hiccups
13:47:42 <Cale> But I don't know about now
13:47:54 <gaze__> bitemyapp: Well, a haskell program will produce more garbage than your average java program will, yeah?
13:48:00 <Cale> (major GCs being like once every 5 minutes or so)
13:48:19 <gaze__> Cale: Two orders of magnitude less, yo
13:48:46 <Cale> Yeah, probably
13:48:49 <erisco> is it possible to explicitly trigger GC in order to reduce individual collection times?
13:49:00 <Cale> yes
13:49:03 <colDrMcBeardman> although if we're comparing with java's GC, would it not be fair to point out that it is pretty bad implementation-wise?
13:49:10 <erisco> can't be that bad then
13:49:21 <colDrMcBeardman> of course, i haven't kept up on java much since 07
13:49:22 <monochrom> GHC's allocator and garbage collector are also crafted to fit that behaviour of producing more garbage than your average java program
13:49:23 <chirpsalot> gaze__: is all garbage of the same value? I feel like while Haskell may produce more garbage it might be able to be smarter about it / clean up the bulk of it more efficiently.
13:49:48 <gaze__> this is all so speculative
13:49:58 <Cale> chirpsalot: This is also true. GHC's GC is really good at picking up short-lived garbage.
13:49:59 <Algebr> A haskell package is just a module that exports other modules, right?
13:50:10 <gaze__> there has to be data for this
13:50:11 <colDrMcBeardman> chirpsalot, also it's much easier to get circular refs in java
13:50:15 <monochrom> no, a haskell package is not even a module
13:50:20 <Cale> gaze__: Well, all my data is really old
13:50:48 <monochrom> you can produce data
13:50:56 <Cale> gaze__: (I was working for a startup that was working on an ARPG for iPhones and other mobile devices in Haskell a few years back)
13:51:04 <Algebr> monochrom: What then is a haskell package
13:51:12 <Cale> gaze__: I'm reasonably convinced that it's technically possible, at least.
13:51:15 <colDrMcBeardman> Algebr, usually a package in the context of haskell is a cabal package.
13:51:19 <colDrMcBeardman> @where cabal
13:51:20 <lambdabot> http://www.haskell.org/cabal
13:51:33 <kadoban> Algebr: a way of packing up some module(s) and/or executable(s) in a convenient form, afaik
13:51:34 <monochrom> is that a philosophy question? I don't know what kind of answer you want.
13:51:44 <chirpsalot> Haha. Is there much on using Haskell for embedded systems? That might be a more meaningful metric for the "would it work on a phone" stuff. I assume it's mostly in the form of DSLs?
13:51:45 <gaze__> monochrom: I think I will... I'm trying to get an arm-linux-androideabi targeting GHC
13:51:59 <chirpsalot> Like the Atom stuff...
13:53:04 <monochrom> at this rate we'll soon be discussing "what is computing?"
13:53:07 <erisco> Cale, does the GC pose a problem for realtime games wrt frame drops?
13:54:11 <chirpsalot> erisco: there was some information about that on the paper with Frag I believe? But that was also really old.
13:54:12 <Platz> remember the JVM is only one of the most tuned VM's ever
13:54:15 <colDrMcBeardman> monochrom, let's just get them all to agree that since any phone can act like a turing machine that yes, we can put haskell on it.
13:54:29 <chirpsalot> erisco: http://is.gd/ozG7XL
13:54:40 <Platz> don't know about dalvik though
13:54:58 <Javran> can someone give me an intuition about what "fusion law for foldr" is saying?
13:55:23 <monochrom> remind me the exact formula of the fusion law for foldr
13:55:53 <erisco> :t foldr
13:55:54 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:55:54 <c_wraith> uh.  darn it, I looked this up like 2 days ago.
13:56:09 <[swift]_> hmm, how can i apply "foo :: A -> Maybe B" to a value of type Maybe A and get back a Maybe B? "foo <$> mayA" yields a Maybe (Maybe B), which i can collapse using 'join', but it seems like there should be something more elegant
13:56:20 <artyomkazak> foo =<< mayA
13:56:26 <Platz> chirpsalot: my understanding is a lot of folks use haskell as a DSL to generate C code to run on embedded systems
13:56:59 <Javran> I found it in "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
13:57:17 <[swift]_> artyomkazak: ahh dang, i tried that but wrote "foo =<< return mayA" by mistake, which of course still results in two Maybe's in the end =)
13:57:29 <monochrom> should I go find and read that paper myself?
13:58:13 <Javran> "f . h = g if f b = c and f (a + as) = a * (f as)" something like that.
13:58:42 <monochrom> there is no foldr in that formula. so what is the exact formula of the fusion law for foldr?
13:58:50 <Javran> the problem is I don't know what it is saying so I dont know how to describe it..
13:59:08 <monochrom> no, I am not asking you to describe it. I am asking you to type in the formula.
13:59:22 <monochrom> I am asking you to copy-paste
14:00:29 <Javran> sorry but it doesn't mention it explicitly.. it just said "For example the Fusion Law for catamorphisms over lists reads:"..
14:00:49 <Javran> well I need a screenshot.
14:01:51 <nabilhassein> I'm using CentOS and had success reported after installing ghc with `yum install ghc`, but `which ghc` shows it's not on the path. Anyone have any idea where it might be?
14:02:32 <geekosaur> try using type instead of which, first off; type is the official one, different implementations of which can lie
14:02:56 <geekosaur> I don't currently have any active centos vm-s but I recall ghc going in /usr/bin as usual...
14:03:16 <Javran> here it is: http://imgur.com/BnDryg6
14:04:01 <kadoban> nabilhassein: maybe look for it with a version number appended or something weird? seems unlikely though
14:04:20 <geekosaur> also, from epel?
14:04:38 <nabilhassein> yeah I used epel
14:04:43 <Javran> monochrom:  http://imgur.com/BnDryg6
14:05:12 <monochrom> ok, in haskell notation, it becomes: f . foldr b (+) = foldr c (*) ⇐ f b = c ∧ f (a + as) = a * (f as).  The + and * here refer to arbitrary binary operators, not necessarily plus or times.
14:05:54 <geekosaur> epel's ghc is a metapackage, the compiler is ghc-compiler package... contains /usr/bin/ghc and /usr/bin/ghc-7.0.4
14:06:02 <geekosaur> among others
14:06:37 <monochrom> intuitively it says that f . foldr b (+) can be replaced by foldr c (*), or vice versa, very often.
14:07:31 <pash_> pash
14:07:44 <geekosaur> (I am assuming rhel6/centos6)
14:07:51 <Nik05> wow i just wrote down foldl implemented with foldr, with a list of length 2, damn that already long :P
14:08:40 <nabilhassein> ah, ghc-7.0.4 is in /usr/bin, along with ghci-7.0.4, and some other stuff. I'll just create symlinks myself. Thanks!
14:09:59 <Javran> monochrom: so no matter what (+) and (*) are, as long as "f b = c ∧ f (a + as) = a * (f as)", "f . foldr b (+)" and "foldr c (*)" should be the same?
14:10:07 <monochrom> yes
14:10:24 <Javran> monochrom: thanks for help!
14:11:25 * hackagebot bugzilla 0.2.0.0 - A Haskell interface to the Bugzilla native REST API  http://hackage.haskell.org/package/bugzilla-0.2.0.0 (sethfowler)
14:11:54 <miniBill> is there a more idiomatic way to write this -> http://dpaste.com/1773314/ ?
14:12:15 <monochrom> f (foldr b (+) [x,y]) = f (x + (y + b)) = x * f (y + b) = x * (y * f b) = foldr (f b) (*) [x,y]
14:12:34 <monochrom> this may be a convincing demo of what is going on
14:13:08 <miniBill> the lambdabot suggests Program i `fmap` mapM f defs
14:13:20 <eyebloom> Is there a way for ghc to suppress displaying types when outputting the results of core optimization passes?
14:13:21 <glguy> miniBill: What you wrote is perfect
14:13:42 <miniBill> glguy: is it?
14:14:20 <Platz> miniBill: if you want to compress it.. mapmM f defs >>= return . Program i
14:15:00 <miniBill> mh...
14:15:03 <Javran> monochrom: seems like it can be proved by structual induction
14:15:12 <glguy> miniBill: You could generalize it to work in any applicative
14:15:13 <glguy> http://dpaste.com/1773316/
14:15:13 <int-e> Platz: at that point I'd prefer the `fmap` (or <$>) version.
14:15:18 <monochrom> yes eyebloom, find it in the GHC user's guide
14:15:18 <joelteon> fmap (Program i) (mapM f defs)
14:15:25 <miniBill> or I could use the fmap for Result (which is just a glorified Either)
14:15:30 <glguy> miniBill: but you don't get achievement points for squashing things into one line
14:15:41 <benbange1t> don't suppose anyone knows if the haskell pure ssl implemention in tls is vulnerable to http://heartbleed.com/ ?
14:15:43 <erisco> to take advantage of stream fusion you would have to write your code to work with Stream, yes?
14:15:55 <monochrom> yes Javran, if you know that you just want list's foldr
14:15:57 <miniBill> glguy: traverse
14:15:59 <eyebloom> I've been looking through the flags and haven't located it. Do you know what it's called?
14:16:43 <glguy> miniBill: Data.Traversable.traverse is the generalized version of mapM (generalized to the Applicative constraint instead of the Monad constraint)
14:16:51 <monochrom> -dsuppress-type-signatures
14:17:29 <eyebloom> Many thanks
14:17:35 <monochrom> -dsuppress-type-applications may also be needed
14:17:44 <miniBill> glguy: ok
14:17:51 <eyebloom> Gotcha
14:18:05 <monochrom> the service fee is 1 bitcoin
14:18:34 <nabilhassein> sorry, more CentOS install problems. cabal won't work for mysterious reasons:
14:18:40 <nabilhassein> [nabil@localhost parse]$ cabal install attoparsec
14:18:41 <nabilhassein> cabal: The program ghc-pkg is required but it could not be found.
14:18:41 <nabilhassein> [nabil@localhost parse]$ which ghc-pkg
14:18:41 <nabilhassein> /usr/bin/ghc-pkg
14:18:44 <nabilhassein>  
14:19:24 <monochrom> what about "ls -l /usr/bin/ghc-pkg"?
14:19:37 <monochrom> well I guess it is really there
14:20:00 <monochrom> fairly sure cabal does try /usr/bin
14:20:20 <dcoutts> well, it just uses the system search path
14:20:38 <dcoutts> which on unix is the $PATH env var
14:21:06 <geekosaur> I see which is still considered definitive
14:21:38 <geekosaur> I will remember not to tell people to use the definitive one because they'll use the usually broken one anyway because they know better
14:22:22 <monochrom> well, this one may be fine because the problem with "which" is usually false negative but not false positive
14:23:19 <geekosaur> traditional which did lovely things like reading dotfiles to find out $PATH and aliases, which meant it shows you what it'll be the next time you log in, not what it is right now
14:23:29 <dcoutts> nabilhassein: ghc -e 'System.Directory.findExecutable "ghc-pkg"'
14:23:31 <geekosaur> sometimes which is aliased to type, but you can't rely on that
14:25:28 <geekosaur> (there's also the hash -r issue but that can't apply here since ghc wasn't already installed)
14:26:26 <monochrom> well, the general phenomenon is that humanity sees one piece of evidence and bets all eggs on it. as opposed to the scientific method of looking for multiple confirmations for crosschecking
14:28:03 <monochrom> just yesterday there was the other question about: «sed '' <<<"hi"» produces a newline, but calling sed via readProcess does not.
14:28:18 <nabilhassein> dcoutts: Just "/usr/bin/ghc-pkg"
14:28:31 <monochrom> the whole question bet on shell's <<<"hi" not adding a newline behind your back
14:28:45 <monochrom> the bet lost. it does add a newline behind your back
14:28:52 <dcoutts> nabilhassein: and does /usr/bin/ghc-pkg --version report something sensible?
14:29:07 <nabilhassein> dcouts: yes, 7.0.4
14:29:41 <monochrom> and for like 10 minutes the asker did not cross-check with a file i.e. sed '' < file. clearly did not think that one needs multiple confirmations.
14:30:19 <dcoutts> nabilhassein: can you run the original command with -v3 and post the log somewhere
14:30:46 <Nik05> did i do this correct? http://lpaste.net/5163408927336955904
14:32:04 <jophish> What is something if it isn't a variable in a type. For example foo :: a -> Int; 'a' is a type variable. Is Int a Concrete type?
14:32:12 <jophish> what's the term?
14:32:24 <nabilhassein> dcoutts: very helpful! I symlinked "ghc" in my local bin since /usr/bin only had ghc-7.0.4. The output to that command yielded:
14:32:30 <nabilhassein> looking for tool "ghc-pkg" near compiler in /home/nabil/bin
14:33:56 <dcoutts> nabilhassein: heh, I should have suggested that. I implemented that logic years ago. Forgetting things.
14:34:23 <monochrom> this is a scandal! I must report it in my article!
14:34:51 <monochrom> hmm where should I put it?
14:36:54 <chagall>  
14:39:46 <no-n> {-# LANGUAGE stuff goes BEFORE module Foo where?
14:39:55 <monochrom> yes
14:39:59 <no-n> ty
14:40:02 <no-n> just making sure ;)
14:40:13 <monochrom> GHC calls it "header pragma"
14:40:25 <no-n> ahh yep
14:40:31 <no-n> thought it was special like that
14:41:05 <geekosaur> goes at the top of the file before anything else, usually
14:41:23 <no-n> now i have to change a whole bunch of stuff in this program
14:41:25 <geekosaur> there are some pragmas that get interspersed but you need to specify language pragmas before anything else
14:41:46 <no-n> demolish/rebuild
14:56:30 * hackagebot wai-predicates 0.4 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.4 (ToralfWittner)
14:56:32 * hackagebot wai-routing 0.5.3 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.5.3 (ToralfWittner)
15:01:32 <nabilhassein> is there a nice short attoparsec equivalent to the "brackets" function in the top answer here: http://stackoverflow.com/questions/18957873/haskell-parenthesis-matching-for-find-and-replace
15:01:32 <nabilhassein> ?
15:03:36 <Fuuzetsu> nabilhassein: but that definition should work out of the box in Attoparsec too
15:05:18 <kuribas> Is a function a datatype with two type variables?
15:05:35 <nabilhassein> Fuuzetsu: there's no "noneOf" I can find in Attoparsec
15:05:39 <monochrom> I guess so
15:05:53 <kuribas> Which can be used like any other datatype?
15:06:09 <monochrom> yes
15:09:08 * thoughtpolice notes www.haskell.org is down for a minute or so as he does a routine upgrade
15:09:28 <Fuuzetsu> haskell.org is down, panic!
15:10:23 <thoughtpolice> back online
15:10:39 <malinus> Hello. I'm learning haskell. How would I do a simple "and" check without stacking two if expressions together? Like I want to make sure that two functions are true, and do that in a guard.
15:10:46 <ZettaBlade> Oh, for a sec I thought my internet was wonking out. Phew, crisis averted.
15:10:58 <pavonia> :t (&&)
15:10:58 <lambdabot> Bool -> Bool -> Bool
15:11:08 <malinus> oh right
15:11:32 * hackagebot mcmaster-gloss-examples 2013 -   http://hackage.haskell.org/package/mcmaster-gloss-examples-2013 (yuriyt)
15:11:40 <gamegoblin> mmm wish there was a prelude function called skipM that was defined as \m0 m1 -> m0 >>= \x -> m1 >> return x
15:11:47 <gamegoblin> Find myself using that pattern a fair bit
15:12:12 <malinus> thanks pavonia. I feel stupid now
15:12:15 <gamegoblin> mainly with parsing and whatnot
15:12:23 <glguy> gamegoblin: Control.Applicative.<*
15:12:25 <Fuuzetsu> gamegoblin: <*
15:12:30 <Fuuzetsu> …
15:12:33 <gamegoblin> mmmm thans didn’t know that one
15:12:39 <pavonia> malinus: That wasn't my intention :)
15:12:51 <gamegoblin> Wonder why hlint doesn’t suggest that
15:13:22 <glguy> gamegoblin: It isn't universally a good substitution, it just happens to exist
15:13:30 <glguy> and also Applicative isn't a super-class of Monad yet
15:13:31 <haasn> thoughtpolice: did you upgrade openssl? :)
15:13:33 <Fuuzetsu> also you're not necessarily going to have Applicative
15:13:38 <Fuuzetsu> god damn it
15:13:43 <gamegoblin> aaah gotcha
15:13:45 <glguy> You're going to have to type faster than that ;-)
15:13:46 <gamegoblin> glguy beat you ;)
15:13:48 <gamegoblin> heh
15:13:52 <Fuuzetsu> gamegoblin: twice!
15:13:55 <haasn> Fuuzetsu needs sleep
15:13:57 <thoughtpolice> haasn:
15:13:57 <thoughtpolice> 17:02  * thoughtpolice updates www.haskell.org
15:13:57 <thoughtpolice> 17:02 < thoughtpolice> openssl_1.0.1e-2+deb7u4_amd64.deb
15:13:57 <thoughtpolice> 17:02 < thoughtpolice> so we need to wait for deb7u5, probably coming soon
15:14:04 <Fuuzetsu> haasn: I need to wake up ;P
15:14:09 <thoughtpolice> https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=743883
15:14:19 <haasn> thoughtpolice: awesome
15:14:21 <thoughtpolice> haasn: also yes, we're even looking into revoking the current certs and issuing new ones
15:14:28 <thoughtpolice> Maximum Paranoia
15:14:36 <haasn> The only way to do it, we distribute compilers
15:14:42 <Fuuzetsu> https://ghc.haskell.org/trac/ghc/changeset/762e083ca29c3aaef6d85b786c9cfeac500e1ddf/ghc ;)
15:14:48 <thoughtpolice> on an unrelated note: https://github.com/ghc/ghc/commit/762e083ca29c3aaef6d85b786c9cfeac500e1ddf
15:14:50 <Fuuzetsu> it's happening!
15:14:51 <haasn> And we all know what security leaks inside compilers means
15:14:53 <Fuuzetsu> thoughtpolice: ha!
15:14:54 <thoughtpolice> see also: http://cdn0.dailydot.com/uploaded/images/original/2014/1/7/its-happening-ron-paul-gif.gif
15:14:59 <thoughtpolice> Fuuzetsu: damnit
15:15:06 <Fuuzetsu> ha x2
15:15:06 <Earnestly> http://heartbleed.com/ :p
15:15:37 * thoughtpolice works out the tagging and all that right fast
15:16:49 <nabilhassein> is there an Attoparsec equivalent to Parsec's "noneOf"?
15:17:08 <Fuuzetsu> nabilhassein: nope
15:17:19 <bitemyapp> Fuuzetsu: is there a reason for that limitation?
15:17:31 <nabilhassein> Fuuzetsu: thanks. I'll try to rewrite a matching braces thing in some other way
15:17:52 <gamegoblin> nabilhassein: what are you trying to parse
15:17:53 <Fuuzetsu> bitemyapp: I don't remember, any time I needed such a thing I danced around it instead
15:17:57 <sgregory_> http://cdn.memegenerator.net/instances/500x/48253677.jpg
15:18:00 <gamegoblin> There may be a more attoparsec-y way of doing it
15:18:40 <Fuuzetsu> you can use scan and takeWhile and all that to emulate it
15:18:49 <zzo38> Is there indexed continuation monad?
15:19:12 <nabilhassein> gamegoblin: some scala actually. long story
15:19:18 <nabilhassein> just a very restricted subset
15:19:34 <gamegoblin> nabilhassein: no no just describe the parser you are trying to implement with the noneOf
15:19:54 <nabilhassein> I want to match everything inside of balanced {}
15:20:48 <Fuuzetsu> nabilhassein: you can do that, one sec
15:20:58 <zQ> @hoogle [a] -> [b] -> (a -> b -> c) -> [c]
15:20:59 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:21:00 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:21:00 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:21:02 <Fuuzetsu> things like this worked around
15:21:04 <Fuuzetsu> oops
15:21:07 <Fuuzetsu> like this https://github.com/sol/haddock/blob/master/src/Haddock/Parser.hs#L224
15:21:22 <zzo38> I thought, something like ((a -> x) -> y) and if you have (((a -> x) -> y) -> y) -> z) to "join" making ((a -> x) -> z), since "-> y) -> y)" is a kind of "continuation monad" that you can (\x y -> y x) for example.
15:21:29 <zzo38> I don't know what it really, is, though.
15:21:31 <Fuuzetsu> or like https://github.com/sol/haddock/blob/master/src/Haddock/Parser.hs#L224
15:21:38 <Fuuzetsu> god damn it
15:21:39 <Fuuzetsu> like https://github.com/sol/haddock/blob/master/src/Haddock/Parser.hs#L170
15:22:05 <bitemyapp> zzo38: http://hackage.haskell.org/package/indexed-extras-0.1.1/docs/Control-Monad-Indexed-Cont.html
15:22:36 <Conc4t> I have a function that returns [[Char]]... I want the basecase of my recursion to do NOTHING. What's the correct way of doing this?
15:22:38 <zQ> given a list of x, a list of y, and a function x -> y -> z, is there a short way to compute a list of applications of the function on every pair of x and y?
15:22:43 * thoughtpolice wonders if there's a selection monad package on Hackage yet
15:22:52 <thoughtpolice> after that nifty paper and all
15:23:05 <zQ> besides something hacky like map (\(x:y:[]) -> g x y) $ sequence xs ys
15:23:26 <zzo38> bitemyapp: Yes, that looks like it, would join be similar to how I mentioned?
15:23:37 <erisco> Conc4t, well that depends on what your function is doing and how it is defined
15:23:53 <bitemyapp> zzo38: I don't really understand that Indexed Cont, I googled your question :)
15:23:54 <pavonia> :t zipWith
15:23:55 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:24:11 <bitemyapp> zzo38: any answer to your question would just be me clicking on "Source" and squiting :)
15:24:40 <erisco> Conc4t, you cannot have the base case do nothing, but you can make use of identities... for example xs ++ [] == xs
15:25:15 <pavonia> zq: ^ is this the function you'r elooking for?
15:25:24 <zq> pavonia: no
15:25:45 <Conc4t> erisco: identities? Care to expound?
15:25:46 <zq> more like
15:26:00 <pavonia> Oh, every possible pair
15:26:06 <zq> :t \g xs ys -> map (uncurry g) [(x, y) | x <- xs, y <- ys]
15:26:07 <lambdabot> (a -> b1 -> b) -> [a] -> [b1] -> [b]
15:26:08 <erisco> Conc4t, what is your base case?
15:26:12 <zq> pavonia: ^
15:26:38 <nabilhassein> Fuuzetsu: maybe I'm misunderstanding but it doesn't look to me like that will handle more curly braces inside the "{}"
15:26:47 <zzo38> bitemyapp: O, OK. They don't define join in there; they are all defined in terms of bind but I think it should be better both having join and bind as class methods, each one automatically define in terms of another. (It ought to be, not >>= but in terms of =<< since =<< is really a kind of a functor.)
15:27:21 <bitemyapp> zzo38: I'll take your word for it, haha.
15:27:52 <Fuuzetsu> nabilhassein: oh, correct, sorry I got distracted; You can use ‘scan’ to do that.
15:28:27 <nabilhassein> Fuuzetsu: ah, okay. thanks for the help
15:28:28 <Fuuzetsu> https://github.com/sol/haddock/blob/master/src/Haddock/Parser.hs#L125 , we use Bool here but you can just use the number of open { braces
15:28:52 <Fuuzetsu> probably a better example https://github.com/sol/haddock/blob/master/src/Haddock/Parser.hs#L373
15:28:52 <pavonia> zq: I think you want liftA2
15:29:03 <Fuuzetsu> let me know if you still struggle, I can probably hack up an example for you
15:29:11 <pavonia> > liftA2 (,) [1..3] "abc"
15:29:12 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:29:20 <zq> oh wow magic
15:29:46 <Fuuzetsu> > [(x, y) | x <- [1 .. 3], y <- "abc"]
15:29:47 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:29:52 <Fuuzetsu> it's just a shorthand
15:30:00 <Conc4t> erisco: Here it is http://lpaste.net/3546407882750689280
15:31:04 <erisco> Conc4t, I do not understand your function ... print returns in the IO monad, so how are you intended to write a function of type [[Char]] -> [[Char]] ?
15:31:33 <erisco> it is possible that you would want this...
15:31:47 <erisco> > sequence_ . fmap print $ ["hello","world"]
15:31:48 <lambdabot>  <IO ()>
15:32:15 <erisco> printHelper :: [a] -> IO (); printHelper = sequence_ . fmap print
15:32:40 <pavonia> Conc4t: Don't use tabs in your Haskell code, you will get in trouble if spaces and tabs get mixed
15:33:23 <erisco> :t mapM
15:33:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:33:39 <erisco> printHelper = mapM_ print
15:33:50 <zzo38> pavonia: At least, if you don't use explicit {;} it can be confusing to use tabs in that way.
15:34:45 <zzo38> If you do use explicit {;} then probably it should be OK to indent with tabs, although still be careful it will be formatted correctly!
15:34:54 <erisco> Conc4t, I annotated with how you might write an explicitly recursive definition
15:35:51 <pavonia> zzo38: In my expierence beginners actually don't know that you can use braces and semicolons Haskell
15:36:01 <pavonia> in Haskell
15:36:06 <zzo38> pavonia: Then, they should learn that both ways are possible.
15:36:23 <zzo38> I prefer to disable layout mode myself, although it is a matter of preferences. But, I suggest that you do not mix both styles in the same file.
15:36:25 <haskell-newbie> hi
15:36:41 <haskell-newbie> i'm trying to familiarize myself with persistent
15:37:28 <erisco> Conc4t, oops sorry I forgot to pass xs back to printHelper http://lpaste.net/102391
15:37:32 <zzo38> pavonia: Such document to tell beginners, ought to tell, that it is possible to use braces/semicolons if you want to, but it is optional, and that indentation sensitive mode (similar to Python) also possible.
15:37:45 <haskell-newbie> I want to select 1 user with id == 1, trying this: oneUser <- selectList [UsersId ==. 1] [LimitTo 1]
15:37:49 <zzo38> So, it is a failure of the documentation
15:38:01 <haskell-newbie> getting No instance for (Num (KeyBackend SqlBackend (UsersGeneric SqlBackend)))
15:38:18 <haskell-newbie> is it possible to get user by id with persistent?
15:39:31 <zzo38> I know it can be done with SQL, but I don't know how this Haskell library works, sorry. (I generally write the program in SQL if doing this kind of stuff)
15:39:46 <Platz> how often do you guys use the Cont monad?  Is it better to avoid or are there some cases where you need it?
15:39:51 <malinus> Hi again. I'm learning haskell, and I wrote my first program. Fizzbuzz. However I'm not happy with how I solved it. Could someone explain how I would "merge" the function fizz and fizzCheck into one nice function? Or is this acceptable? http://hastebin.com/yumuwocaqu.hs
15:40:19 <Platz> I've only seen it used in tutorials so far
15:41:35 <haskell-newbie> zzo38: no problem :)
15:41:37 <zzo38> Platz: I have mainly used it to implement a monad that builds data structures, not much
15:41:46 <erisco> malinus, well you can write function definitions which are locally scoped
15:42:00 <erisco> > let f x = x + 1 in f 5 -- malinus
15:42:00 <lambdabot>  6
15:42:07 <zzo38> Platz: What cases would you thinking of you might use it? See, if it is a useful way.
15:42:09 <Platz> zzo38: well at least thats something
15:43:01 <Platz> zzo38: I'm just musing, no application yet.  I figure Cont would be useful if you want to trampoline something, but I didn't think trampolining was needed in haskell
15:43:02 <malinus> erisco, sorry but I fail to see how to apply that.
15:43:04 <pavonia> haskell-newbie: Could you paste some more code? Having a glance at the documentation that functions call looks fine
15:43:06 <erisco> malinus, also, fizz == fmap fizzCheck
15:43:53 <dwcook> or map fizzCheck for that matter
15:43:53 <erisco> malinus,  fizz = let fizzCheck = ... in fmap fizzCheck
15:43:58 <Platz> maybe something with threads and resuming work , but there might be better things for that
15:44:07 <haskell-newbie> pavonia: sure http://lpaste.net/4911100446468210688
15:44:15 <erisco> dwcook, sorry I'm just more used to fmap
15:45:19 <jophish> Text.PrettyPrint.HughesPJ seems to eat unicode characters
15:45:31 <haskell-1ewbie> pavonia: sorry, ogt disconnected
15:45:38 <malinus> eribeiro, where/how would I look up specific functions. Like fmap
15:45:43 <haskell-1ewbie> http://lpaste.net/4911100446468210688 with full error messagfe
15:45:50 <dwcook> malinus, Hoogle
15:45:57 <dwcook> @hoogle fmap
15:45:58 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:45:58 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:45:58 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:46:03 <dwcook> The web interface links to them too
15:46:08 <dwcook> s/them/the documentation/
15:46:22 <pavonia> haskell-1ewbie: Hhm, I think I can't help with that, sorry
15:46:46 <jophish> > text "★"
15:46:47 <lambdabot>  ★
15:46:47 <dwcook> malinus, for that matter Hoogle can be used to find a function based on its signature
15:46:53 <dwcook> @hoogle (a -> b) -> [a] -> [b]
15:46:53 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
15:46:53 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
15:46:53 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:46:58 <malinus> I see, thanks
15:47:01 <jophish> > render $ text "★"
15:47:02 <lambdabot>  "\9733"
15:47:10 <jophish> I can't explain that!
15:47:12 <Fuuzetsu> :t text
15:47:13 <lambdabot> String -> Doc
15:48:10 <zzo38> Platz: I don't know about trampolining either, but, I figured out if you don't want callCC you can also make "law of excluded middle" continuations; it is possible to make callCC out of it, and vice versa.
15:48:14 <jophish> somewhere while going from String -> Doc -> String things get flattened
15:48:25 <FireFly> @ty render
15:48:26 <lambdabot> Doc -> String
15:48:30 <AshyIsMe> > text "™ ™"
15:48:31 <lambdabot>  <hint>:1:7:
15:48:31 <lambdabot>      lexical error in string/character literal at character '\63743'
15:48:38 <AshyIsMe> haha, oops
15:49:52 <zzo38> I don't know, if possibly some people can understand "law of excluded middle" continuations a bit better. I think I have used it once, but I haven't used callCC (except, to specify one way of defining lemCC; it can also be defined just as simple as callCC without using it though)
15:50:54 <Fuuzetsu> > let 1  2 = 3 in 1  2
15:50:55 <lambdabot>  <hint>:1:7: lexical error at character '\63743'
15:50:55 <Conc4t> erisco: sorry I was afk
15:50:57 <Fuuzetsu> boo
15:51:02 <Conc4t> erisco: thanks for the advice
15:51:40 <zzo38> In Haskell it would have:  Cont r (Either a (a -> Cont r b));  Have you used continuations like this, or seen it?
15:55:19 <jophish> Fuuzetsu: I suppose that's not listed as being a letter or a symbol
15:55:34 <Platz> it even says on the hackage page for the mtl library that "Before using the Continuation monad, be sure that you have a firm understanding of continuation-passing style and that continuations represent the best solution to your particular design problem. Many algorithms which require continuations in other languages do not require them in Haskell, due to Haskell's lazy semantics."
15:56:23 <zzo38> Platz: Yes, I have said too, ensure it is a help to you.
15:56:50 <zzo38> However, the way it is used doesn't necessarily have to have much to do with continuations in Scheme and so on; it has other uses too.
15:58:40 <leo_> Hello, I'd like to receive a little coding help
15:58:57 <leo_> I am a newbie both in Haskell and F#
15:59:07 <leo_> I am translating a little F# program to Haskell
15:59:20 <leo_> http://codepad.org/LRwx8Sg8
15:59:57 <leo_> The part where I'd like some help is the function solve from line 69
16:00:34 <leo_> I'd like to receive suggestions regarding the translation of those yield and yield! parts.
16:01:08 <leo_> (In the precedent simpler functions I have translated the yield with just list comps)
16:09:10 <leo_> BRB
16:11:39 * hackagebot tidal 0.3.5 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.5 (AlexMcLean)
16:14:52 <AshyIsMe> Fuuzetsu: omg unicode is valid isnt it? god let's hope people don't start making haskell like the original apl
16:16:18 <haasn> > generalCategory '\63743'
16:16:19 <lambdabot>  PrivateUse
16:16:29 <haasn> not a valid character in Haskell names
16:17:16 <hexagoxel_> leo_: so deos anything stop you from using a list-comprehension for the yield! ?
16:17:20 * leo_ is back
16:17:38 <leo_> hexagoxel_: my ignorance, I guess
16:18:08 <hexagoxel_> [solve pos dir (Set.add pos state) trace shape | moves <- getValidPositions pos dir part state, (dir, pos) <- moves, (trace, _, _) = pos]
16:18:28 <leo_> That's it? :-)
16:18:34 <hexagoxel_> the trace, _, _) = pos part might be wrong
16:18:39 <leo_> OK
16:18:46 <hexagoxel_> i don't know what tuple element is trace
16:19:08 <hexagoxel_> and i don't know F# :D
16:19:41 <leo_> A trace is [Part] that is a (Color, Kind)
16:19:49 <leo_> But this is not so important, I think
16:20:05 <leo_> I'll try to adapt your code.
16:20:09 <leo_> Thank you.
16:20:24 <hexagoxel_> leo_: i mean the translation of "pos::trace"
16:20:31 <hexagoxel_> ah, thats an append?
16:20:32 <gamegoblin> Not haskell: What would I call a directed acyclic graph that contains at least one node that can lead to all others? Like a rooted acyclic graph. Is there a real graph theory word for it?
16:20:40 <leo_> I see, it's just pos : trace
16:20:46 <hexagoxel_> yeah ofcourse it is
16:20:48 <hexagoxel_> i see
16:20:54 <hexagoxel_> yeah than adapt that part :D
16:21:01 <leo_> OK
16:21:45 <leo_> See you later. I'll be back in a short time if I can't find a way to make that code work.
16:21:46 <hexagoxel_> the other yield can just be omitted, right?
16:22:00 <leo_> The first one can't be omitted
16:22:34 <leo_> In F#
16:23:22 <leo_> Later.
16:24:27 <hexagoxel_> *then.. man i hate to mess up then vs than
16:25:03 <jophish> Is it true to say that kind inference can be done in its entirety before type inference?
16:26:25 <jophish> I notice that GHC doesn't seem to quite do it like that
16:29:21 <bitemyapp> jophish: in principle it sounds like kind inference could be done first but I can't make any assertions about GHC.
16:30:51 <taktoa> well hac nyc was nice
16:31:06 <bitemyapp> taktoa: oh yeah? I'm a bit envious. Might try to go to BayHac.
16:31:42 * hackagebot bugzilla 0.2.1.0 - A Haskell interface to the Bugzilla native REST API  http://hackage.haskell.org/package/bugzilla-0.2.1.0 (sethfowler)
16:31:43 <taktoa> I didn't get to talk to many people since I came in at like 2 PM and all the tables were full
16:32:24 <taktoa> anyone know if there are pictures up from hac nyc
16:32:56 <[swift]_> it'd be nice if haddock limited the width of the generated documentation
16:33:22 <jle`> gamegoblin: it's a word
16:33:22 <[swift]_> it'd be much more readable
16:34:16 <jophish> bitemyapp: I'm trying to figure out how much information I need to preserve after kind inference. As far as I can tell, there's no need to keep any information other than: "The kinds are all correct"
16:34:31 <jophish> type inference doesn't need to know any more than that, I think
16:34:54 <bitemyapp> taktoa: I only saw pics on twitter.
16:35:02 <bitemyapp> taktoa: maybe search around on there?
16:35:11 <taktoa> I'll try that, thanks
16:37:44 <hakujin> anyone have experience with Blaze.ByteString.Builder vs Data.ByteString.Builder?
16:38:08 <hakujin> what are the use cases for each?
16:38:14 <geekosaur> they're the same thing
16:38:37 <geekosaur> Blaze started out as a separate project and was rolled into Data.ByteString
16:38:39 <hakujin> literal same thing? or perform same function
16:38:46 <hakujin> ah! thanks
16:39:31 <Kaidelong> mm, why does yesod still depend on blaze-builder then?
16:39:37 <geekosaur> backward compat
16:39:42 <dwierenga> hi, just starting to learn Haskell.  when i type ":type map" into ghci, it returns "map :: (a -> b) -> List a -> List b".  am i correct in reading the *(a -> b)* part as "the first parameter is a function that takes a type 'a' as input and returns a type 'b'" ?
16:39:52 <geekosaur> soi they don't have to play CPP games to be compatible with older ByteString
16:39:58 <taktoa> yes dwierenga
16:40:44 <dwierenga> taktoa: excellent thank you  :)
16:42:12 <Kaidelong> geekosaur: isn't cabal powerful enough to deal with this?
16:42:28 <Kaidelong> wouldn't it be a variation on packages that depend either on unix or win32
16:42:28 <geekosaur> not really, no, not when they have different module names
16:42:29 <hakujin> geekosaur: any experience with Network.Socket.ByteString.sendMany vs Data.ByteString.Builder.hPutBuilder?
16:42:52 <geekosaur> you need to play ugly CPP games, and that has its own problems
16:42:55 <Kaidelong> geekosaur: but you could make a dependency that is satisfied by blaze builder OR a sufficiently large version of bytestring
16:43:38 <geekosaur> a wrapper module, yes. but that then makes migrating from that to the official ByteSrtring API more painful later
16:43:48 <geekosaur> in other words you're just deferring the pain
16:44:22 <Kaidelong> wrapper module? if the issue is that you need to change Blaze.* to Data.* you could just use the C preprocessor
16:44:46 <geekosaur> [07 23:40] <geekosaur> you need to play ugly CPP games, and that has its own problems
16:45:07 <geekosaur> anyone on a Mac can tell you you don't "just use the C preprocessor"....
16:45:12 <Hodapp> yeah, why not use a cleaner solution like C++?
16:45:14 * Hodapp ducks
16:45:15 <copumpkin> dcoutts: if I want to hook cabal's call to link a dynamic library, what do I do to BuildInfo? ldoptions only seems to apply to foreign stuff, and shared ghc options only seems to apply for generating the dyn_o files
16:45:23 <Kaidelong> oh, CPP doesn't work well on OS X
16:45:26 <Kaidelong> ?
16:45:34 <joelteon> it works fine, it just doesn't do the right thing
16:45:36 <joelteon> :)
16:45:36 <hexagoxel> gamegoblin: "arborescence" seems to be pretty close
16:45:50 <gamegoblin> hexagoxel: thanks
16:45:53 <Kaidelong> I imagine gtk2hs must be a bigger nightmare on OS X than it is on windows then
16:45:55 <geekosaur> apple switched cpp from gcc's to clang's. clang's is grumpy about being invoked in Haskell instead of C
16:46:00 <hakujin> Kaidelong: no, because as of Mavericks clang is the only c compiler
16:46:13 <hexagoxel> maybe "directed tree"
16:46:15 <hakujin> or I guess xcode 5 and not Mavericks
16:46:20 <geekosaur> you can work around it but if you can avoid CPP you avoid lots of potential problems
16:46:29 <dcoutts> copumpkin: you don't get direct control of that by default
16:46:32 <gamegoblin> hexagoxel: all trees are directed, no? And it’s not a tree, because there can be several simple paths from one node to another
16:46:38 <Hodapp> huh, you can't call clang's CPP in isolation? or what?
16:46:44 <geekosaur> (we should never have been using cpp to begin with, since ANSI cpp is tightly tied to C syntax)
16:46:49 <dcoutts> copumpkin: 'cos it's well complicated and changes every ghc release :-)
16:46:56 <copumpkin> dcoutts: well, what I'm trying to do is to add additional .lo files for it to link into the final product. Is there a clean way to do that? or even a dirty one?
16:47:01 <gamegoblin> consider the diamond directed graph, A leads to B and C, and B and C lead to D. A would be the “root”, but it’s not a tree because there are two paths to D
16:47:09 <Kaidelong> are there no macro systems for haskell?
16:47:13 <Kaidelong> other than CPP
16:47:15 <copumpkin> Kaidelong: template haskell?
16:47:22 <Kaidelong> isn't that a quasiquoter?
16:47:30 <leo_> hexagoxel: I am getting closer, but I am not there yet:  http://codepad.org/2BXGqQuW
16:47:31 <Kaidelong> not sure how that'd work for things without types like import decl's
16:47:41 <geekosaur> gcc's cpp has a special option to switch it to a permissive form. clang doesn't support that option and while there is a more permissive mode, it's not 100% reliable
16:47:49 <copumpkin> Kaidelong: ah, then no
16:47:49 <dmwit> Who needs macros when you have laziness?
16:47:59 <gamegoblin> arborescence is very close, but not quite. Oh well.
16:48:06 <geekosaur> you can still come up with valid Haskell that will error out in clang's cpp even if you disable the strict syntax checking
16:48:19 <dcoutts> Kaidelong: there's hscpp which is an impl of traditional cpp, but in Haskell and for Haskell
16:48:27 <Kaidelong> dmwit: to change Blaze.ByteString to Data.ByteString
16:48:31 <geekosaur> there is cpphs as an alternative but that has had license problems (I am under the impression that this has been resolved and ghc 7.8 has gone that route?)
16:48:33 <leo_> hexagoxel: yield! and yield are two different things. The first yields and the second yields all
16:48:41 <dcoutts> oophs cpphs not hscpp
16:48:46 <dcoutts> erm oops :-)
16:48:48 <leo_> hexagoxel: well, the opposite
16:48:49 <Hodapp> Can Programming Be Liberated From the C Syntax?
16:48:51 <hexagoxel> leo_: i noticed that there probably is a straightforward translation: yield is return, and yield! is an omitted "return" in haskell's do-notation
16:49:03 <hexagoxel> yeah i read up on yield!
16:49:10 <dmwit> Kaidelong: Yeah, it was a bit tongue-in-cheek. I use CPP at the very least in most of my serious projects.
16:49:34 <geekosaur> Kaidelong, also you cannot change "Blaze.ByteString", you can only change "Blaze". are you 100% certain that that only occurs in places where it is safe to change it to "Data"?
16:49:38 <dcoutts> copumpkin: you'd have to use a custom Setup.hs, but I can't think ottomh the best way to do it
16:49:46 <Kaidelong> dcoutts: unrelated, did you get my gtk2hs related PM earlier?
16:50:10 <Kaidelong> I saw you were one of the people on the github project for it so I figured I should perhaps mention the problem to you
16:50:15 <geekosaur> . is not an identifier character in C, so Blaze.ByteString is not a valid identifier
16:50:21 <dcoutts> Kaidelong: oh, sorry I see it now
16:50:42 <geekosaur> (it's not in Haskell either, for that matter, but it's how cpp sees it that is important here)
16:50:59 <copumpkin> dcoutts: yeah, already using a custom Setup.hs. I tried jumping in preBuild and adding to various sorts of ghc flags to see if I could jump in at the point where it linked the final executable together into the shared lib, but couldn't :( then tried to find if I could affect the list of object files it wanted to pass in directly, but couldn't :(
16:51:08 <hexagoxel> leo_: http://codepad.org/hmKpdarn
16:51:44 <dcoutts> Kaidelong: presumably it'd need to import that C type from Foreign.C, and probably then fix a few follow-on type errors
16:51:56 <hexagoxel> leo_: do-notation probably prettier than a loong comprehension
16:52:05 <leo_> hexagoxel: I agree
16:52:05 <dcoutts> Kaidelong: or just build using 32bit
16:52:22 <Kaidelong> Mm, 32-bit causes a different problem
16:52:26 <hexagoxel> leo_: in the last line, s/trace/trace'/
16:53:06 <leo_> hexagoxel: right. But how do you put that code in the case?
16:53:29 <Kaidelong> dcoutts: modifying gtk2hs buildtools to import the type causes a different problem, must be the follow-on type errors. Look at the reply and the comment in the stackoverflow thread?
16:53:43 <Kaidelong> I was figuring that was one thing I might be able to figure out but I haven't had much luck
16:54:03 <copumpkin> dcoutts: my approach to doing the same thing in static land was sadly to unpack the .a files, inject my additional .o files, and repack the .a :P it'd be nice to have a cleaner approach there too, but at least it's possible. Shared libs are much harder to mangle than a .a file :(
16:54:18 <Kaidelong> essentially sizeof(guint) is returning bogus values
16:54:22 <hexagoxel> leo_: just.. insert?
16:54:24 <hexagoxel> http://codepad.org/scJEu8UI
16:54:52 <Kaidelong> so the CPP macro is generating ridiculous types in the form of IntReallyHugeNumber and WordReallyHugeNumber
16:55:21 <Kaidelong> (sizeof(guint) and a few other calls to sizeof on things from glib)
16:55:39 <dcoutts> Kaidelong: 32bit does at least work (see e.g. the pre-built windows binaries of threadscope)
16:55:53 <Kaidelong> I could try 32-bit build again
16:56:01 <dcoutts> copumpkin: heh
16:56:06 <copumpkin> :) :) :)
16:56:07 <Kaidelong> last time I did the build failed there too, although with a different error
16:56:22 <copumpkin> dcoutts: I have two different libraries where I actually want this, too
16:56:33 <copumpkin> both of them involve bundled custom builds of C libraries
16:56:42 <leo_> hexagoxel: OK, I presume  trace' = pos:trace  means   trace' <- pos:trace
16:56:42 <copumpkin> where the build is complicated enough that I can't just list extra-c-files
16:56:58 <hexagoxel> leo_: ah no
16:57:16 <hexagoxel> http://codepad.org/egv6b73M
16:57:22 <dcoutts> copumpkin: where does the .o file come from? Could you make it or pretend it's a .c file?
16:57:45 <hexagoxel> (oops :)
16:57:48 <dcoutts> copumpkin: ah ok
16:57:51 <copumpkin> dcoutts: pretend it's a .c file? it gets built by a big ./configure && make with additional steps
16:58:05 <copumpkin> both of these packages are a bit messy, unfortunately
16:58:19 <dcoutts> copumpkin: how about building it as a .a file and adding it as an extra ld options?
16:58:34 <copumpkin> dcoutts: will that work for shared?
16:58:49 <copumpkin> I get .lo files for PIC objects
16:59:28 <copumpkin> also, when I tried adding to extra ld options, it didn't seem to appear anywhere in my cabal invocation :(
17:00:10 <leo_> hexagoxel: right. Getting there: http://codepad.org/YjdvEHX4
17:00:19 <copumpkin> ah, I see you mentioned this ages ago: http://www.haskell.org/pipermail/cabal-devel/2007-April/000507.html
17:00:25 <Taslem> Is it possible to tell whether input is available on a Handle without blocking or possibly throwing an error?
17:00:27 <copumpkin> ld options are only used when linking the final product
17:01:17 <dcoutts> copumpkin: ok, how about this, what happens when we link a shared lib and we specify a local static .a lib to link in?
17:01:39 <dcoutts> copumpkin: I'd expect it statically links it into the shared lib
17:01:56 <copumpkin> how do I make sure the .a is somewhere accessible after the build?
17:02:03 <dcoutts> copumpkin: so you'd be able to use the extraLibs and extraLibDirs
17:02:16 <dcoutts> copumpkin: no, that's the point, it'd be linked into the .so
17:02:21 <copumpkin> hrm
17:03:14 <dcoutts> copumpkin: for dynamic linking that is. For a static link it's totally different (adding extra .o files to the .a is a closer effect)
17:03:25 <copumpkin> yeah, I think I have static under control
17:03:36 <copumpkin> still not quite sure I grasp your suggestion, will reread now :P
17:04:13 <leo_> hexagoxel: better: http://codepad.org/tsGMrjpM
17:04:28 <copumpkin> dcoutts: so "and we specify a local static .a lib to link in?"
17:04:39 <dcoutts> copumpkin: try it with ghc/gcc on its own. Link a .so and tell it to -lmyextrathing -L.  where libmyextrathing.a exists locally
17:04:49 <copumpkin> okay
17:05:06 <Kaidelong> I think the problem with the 32 bit version might simply be that my user name has a space in it
17:05:44 <dcoutts> copumpkin: and while you're at it, send us a cabal patch for "extra o files", at least so Setup.hs can use it (it doesn't make a lot of sense in .cabal files)
17:06:31 <hexagoxel> leo_: ah you probably need a "let .. = .." instead of "<-" for moves as well
17:06:56 <hexagoxel> after all, it is a let in the original :)
17:06:57 <copumpkin> dcoutts: just as a new kind of hook in BuildInfo or something?
17:07:46 <copumpkin> dcoutts: that worked :)
17:07:56 <dcoutts> copumpkin: mm, that's supposed to reflect the info from the .cabal file so it's not really appropriate
17:08:06 <copumpkin> dcoutts: hrm
17:08:10 <dcoutts> copumpkin: I suppose I was thinking of something in the LocalBuildInfo
17:08:23 <copumpkin> I meant the "that worked" was your suggestion to add -Ldist/build -lHSrounded-0.1
17:08:38 <leo_> hexagoxel: I hope to not waste too much of your time.  Do you mean    let (dir, pos) <- moves   ?   it doesn't work
17:08:51 <copumpkin> so I think I can see how to translate that to Setup.hs shenanigans
17:08:59 <dcoutts> copumpkin: We already have a per-component blob of info in the LBI
17:09:25 <dwcook> leo_, =, not <-
17:09:43 <copumpkin> dcoutts: look what your suggestion just got me:
17:09:44 <copumpkin> Prelude Numeric.Rounded> pi :: Rounded TowardZero 512
17:09:44 <copumpkin> 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481
17:09:51 <copumpkin> isn't it beautiful?
17:09:54 <dcoutts> heh
17:09:54 <copumpkin> :P
17:10:03 <hexagoxel> leo_: http://codepad.org/utlj3Xem
17:10:40 <hunt> guys ghci :m cant find any files...
17:10:46 <dcoutts> copumpkin: did I mention that my alternate april 1st blog post / proposal was going to be to add tau to the Floating class? :-)
17:10:51 <hunt> except ones that were imported by the loaded file
17:10:59 <hunt> which is pretty useless
17:11:19 <copumpkin> dcoutts: hah, that'd be great! "minimal complete definition: one of pi or tau"
17:11:29 <dcoutts> copumpkin: right :-)
17:11:46 <dcoutts> copumpkin: and actually that works without loss of precision of course in base 2 floating rep :-)
17:11:56 <copumpkin> https://www.dropbox.com/s/8usd87h07izd2br/Screenshot%202014-04-07%2020.09.28.png
17:12:00 <copumpkin> yeah!
17:12:00 <dwcook> It's kind of a joke that even pi is a method :P
17:12:06 <copumpkin> dwcook: really?
17:12:12 <copumpkin> dwcook: it allows me to do what I just did :)
17:12:41 <dcoutts> copumpkin: heh nice
17:12:49 <dwcook> Well, why include pi but not phi? :P
17:12:51 <dcoutts> copumpkin: so is this MPFR?
17:12:55 <copumpkin> dcoutts: yeah
17:12:58 <dcoutts> nice
17:12:59 <copumpkin> finally resurrecting rounded
17:13:07 <copumpkin> I've updated all the CMM to be new style and so on
17:13:16 <copumpkin> the build is still a bit janky, unfortunately
17:13:20 <copumpkin> but I'm cleaning it up
17:13:25 <hunt> guys im not sure why im getting "Pattern matches are overlapped" for this, help? http://lpaste.net/102394
17:13:36 <hexagoxel> hunt: :load
17:13:37 <copumpkin> dwcook: I can compute phi trivially from other units
17:13:51 <hunt> hexagoxel: yea thanks, i didnt realize i could load more than one file
17:13:55 <Algebr> Why is ghc creating *.hi and *.o files for me?
17:13:57 <dcoutts> copumpkin: why does it need so much hairy C code to be inlined? why isn't it just -lmpfr or whatever?
17:13:59 <copumpkin> if I have the trig methods I can compute pi too, but possibly less efficiently
17:15:13 <copumpkin> dcoutts: it uses the GMP allocator, which is GHC's allocator, so we use ByteArrays for the innards of the MPFR floats. Unfortunately, it goes and stashes away some of those floats for caching common constants like pi and e, and they're outside of GHC's field of view, so the GC cleans them up
17:15:15 <dcoutts> hunt: presumably because line 8 (in the paste) is impossible / overlapped.
17:15:42 <leo_> hexagoxel: two more bugs fixed, now it even runs:  http://codepad.org/XgUnYIZ4
17:15:48 <copumpkin> dcoutts: my previous solution was super hacky, if you remember; it involved inspecting the stack and rewriting code to ensure my allocator got used rather than the standard one set by integer-gmp
17:16:09 <dwcook> copumpkin, meh, efficiency is the compiler's job :P
17:16:41 <hunt> dcoutts: it is impossible... good point lol thanks
17:16:42 <tristan__> damn right
17:16:43 <copumpkin> dcoutts: so the cleanest solution to that problem we've been able to come up with is to rewrite a handful of functions to do some special stuff when stashing away those hidden MPFR constants
17:17:04 <copumpkin> dcoutts: I could do that for a system MPFR with some in-memory code rewriting but I figured I'd avoid it if possible
17:17:18 <dcoutts> copumpkin: I see, and so that code lives as part of MPFR
17:17:25 <copumpkin> yeah
17:17:29 <dcoutts> copumpkin: ie a patched mpfr
17:17:44 <copumpkin> yup, so we bundle a vanilla MPFR with four C files modified
17:17:47 <leo_> hexagoxel: I'll try go go on my own. Thank you.
17:17:50 <copumpkin> it's a little frustrating
17:17:53 <copumpkin> feels very inefficient
17:18:03 <dcoutts> copumpkin: ok, which explains why it's a pain to build
17:18:08 <copumpkin> yup :)
17:18:36 <copumpkin> ****ing compilation
17:18:36 <dcoutts> copumpkin: complained to the mpfr devs about the gmp allocator? :-)
17:18:55 <copumpkin> I think we filed a bug ages ago in 2010/11 when we last worked on this
17:19:18 <copumpkin> not sure there's much interest except in our niche
17:19:44 <copumpkin> I wonder what a good solution would be; perhaps some sort of callback saying "register this hidden value"?
17:19:58 <copumpkin> that we could then store in a mutable global IORef in Haskell-land so the GC sees it
17:20:01 <bitemyapp> copumpkin: this would be easier if we didn't have to compile anything
17:20:08 <copumpkin> bitemyapp: RUBY FTW
17:20:10 <copumpkin> >_>
17:20:17 <bitemyapp> I actually meant "sheafs of paper"
17:20:21 <bitemyapp> but yeah sure, we can do that too.
17:20:26 <copumpkin> presheafs of paper?
17:20:33 <bitemyapp> oh good you got the joke.
17:21:20 <hexagoxel> !tell leo_ look at shape vs shape'
17:21:45 <copumpkin> dcoutts: anyway, thanks for the help :) I think this unblocks me! as for that patch, should I stick the object files in LocalBuildInfo then?
17:21:45 <hexagoxel> hmm is there a message-relay bot around?
17:22:11 <dcoutts> copumpkin: yes, either some way to find the cached values so a GC can include them in the root set, or a callback so we find out when they're saved/discarded. ie current status or state change style API
17:22:11 <copumpkin> hexagoxel: try @tell or ?tell
17:22:32 <dcoutts> copumpkin: yeah I think so, but note that it's per-component
17:22:42 <hexagoxel> @tell leo_ look at shape vs shape'
17:22:42 <lambdabot> Consider it noted.
17:22:46 <copumpkin> dcoutts: yeah, that's fine. I think I just need it on the library?
17:22:53 <hexagoxel> copumpkin: ah cool
17:23:16 <dcoutts> copumpkin: sure you do, but if we add it as a feature we'd want it in exes too, static & dynamic.
17:23:34 <copumpkin> yeah, but "users" could take care of inserting that wherever appropriate?
17:23:44 <copumpkin> let me poke around and see where LocalBuildINfo is even used
17:31:33 <copumpkin> dcoutts: filed an MPFR bug :)
17:31:38 <dcoutts> :-)
17:38:36 <leo_> hexagoxel: Success. fixing another silly bug the code works and gives the right output :-)  Thank you
17:38:47 <Algebr> can't believe I'm saying this but ghc is actually helpful, love the "perhaps you meant "..." prompts
17:39:01 <hexagoxel> :)
17:39:20 <dwcook> Those are handy. Conversely, the "maybe you meant to declare an instance for this type" is often misleading
17:39:55 <leo_> I should write a paper on this ;-) See you later.
17:41:11 <hunt> guys when i try and load 2 files into ghci only exports from 1 are visible
17:43:28 <monochrom> what exact command did you use to "load"? exact verbatim command.
17:43:41 <nh2> do some of the accelerate authors hang around here?
17:44:43 <tommd> They don't tend to sit still.
17:50:44 <tree_vor> @nh2 actually I am here, for once... but it is probably better to send me an email
17:50:44 <lambdabot> Maybe you meant: thx ghc
17:53:26 <edwardk> Could not deduce (Functor f (Dual r) t)   arising from a use of ‘fmap’ from the context (Functor f (Dual r) t) -- thanks GHC! ;)
17:54:47 <nh2> tree_vor: I'm just asking because I *might* try to write an implementation of KinectFusion in accelerate and will quite surely require some good accelerate tips for that
17:55:01 <athan> lol
17:56:38 <tree_vor> @nh2 ooh, that would be cool.
17:56:38 <lambdabot> Maybe you meant: thx ghc
17:56:51 <athan> ^ edwardk
17:57:01 <athan> they can read your mind
17:57:49 <tree_vor> but yeah, I am basically never here. you can use the github issue tracker to ask questions though, that seems to work wel
17:58:44 <edwardk> =)
17:59:36 <nh2> tree_vor: it's for a masters project with limited time, so it's a bit risky. I've only written a totally trivial thing in accelerate so far. Do you know if there are some heavy show-stoppers that might make an Accelerate implementation too slow at the time being (like the dot product using two kernels before you implemented that fusion in 0.14)?
17:59:44 <athan> I hope you don't mind me asking, but you've read Types and Programming Languages, right edwardk? What was your favorite chapter? Most difficult?
18:01:31 <edwardk> athan: my favorite bit was the proof that type inference for F_sub is undecidable
18:02:01 <edwardk> my copy is out on loan, so not sure i can remember well enough to answer most difficult. i read it out of order.
18:02:25 <edwardk> i got about half way through, went 'yeah yeah yeah' then ran off to play with pure type systems for ~2 months before finishing
18:02:30 <tree_vor> nh2: I don't know the KinectFusion algorithm well enough to comment. do you have a basic reference implementation? (can be super simple, using lists or whatever). If you can write it using the current functions it should work
18:02:32 <edwardk> by then i'd leveled up a lot ;)
18:02:35 <athan> woah!! Awesome, thanks!
18:02:40 <athan> right hahaha I can only imagine
18:02:56 <athan> hahaha
18:03:09 <ReinH> edwardk: are you going to BayHac?
18:03:13 <athan> I think sleep is a waste of time now
18:03:25 <athan> I don't even want it lol
18:03:54 <athan> *tweak*
18:04:30 <edwardk> ReinH: doesn't look like it. i'm traveling pretty much every 2nd or 3rd week all summer and, well, it'd be the farthest trip someone else isn't paying for on my schedule. so i think i'm going to just take the downtime
18:05:19 <tree_vor> nh2: although, getting accelerate-cuda to run on windows in the first place might be an issue (I know people have done it, but I have no windows box to test...)
18:05:44 <ReinH> edwardk: Alrighty. I made a deal with davean that if he attends BayHac then I'll attend the one in Boston
18:05:47 <ReinH> edwardk: so I guess I'll see you anyway
18:05:48 <tree_vor> nh2: (assuming you need windows to talk to the sensor)
18:05:55 <edwardk> hah
18:06:17 <edwardk> i like this deal
18:09:16 <nh2> tree_vor: this is the smallest kinectfusion CUDA implementation I know of, and the one I would be porting: https://github.com/GerhardR/kfusion/blob/master/kfusion.cu. Core parts are camera tracking using the ICP point cloud alignment algorithm, merging a depth image into a voxel grid containing the 3d model, and raycasting the voxel grid to get a 2d image for displaying the result
18:09:23 <nh2> tree_vor: no, I'm on Linux
18:09:49 <acowley> nh2: I'm doing KF-related work in Haskell and developing an OpenCL EDSL!
18:10:05 <acowley> nh2: So I'd be very interested how it goes writing an implementation in Accelerate
18:10:18 <nh2> acowley: that's cool! Where do you work?
18:10:32 <acowley> Mine is plain OpenCL driven by Haskell, so not totally Haskell-awesome
18:10:38 <acowley> nh2: grad student at Penn
18:11:01 <acowley> ("Mine" refers to my reference KF implementation)
18:11:19 <kwindla> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
18:11:19 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
18:13:00 <nh2> acowley: sounds really cool. Is your implementation already working/available? I am eager to compare different ones, since the PointCloudLibrary one ("kinfu") I've used before frequently messed up the tracking for me, and just today started using kfusion
18:14:05 <acowley> nh2: No, it's not really fit for public consumption. It exists so I can swap it in and out with my in-development solution to related problems.
18:14:18 <kwindla> @undo counter@(Counter c) <- get ; put $ Counter (c+1) ; return $ show i ++ show counter
18:14:18 <lambdabot> <unknown>.hs: 1: 21:Parse error in expression: counter@(Counter c)
18:14:48 <acowley> nh2: It's not CUDA and it's not Accelerate, but if it can help you we can try to work something out
18:14:54 <acowley> nh2: It just reads back log files at the moment
18:15:01 <acowley> nh2: I'd expect PCL's to be better
18:15:03 <kwindla> @undo do counter@(Counter c) <- get ; put $ Counter (c+1) ; return $ show i ++ show counter
18:15:03 <lambdabot> get >>= \ a -> case a of { counter@(Counter c) -> put $ Counter (c + 1) >> return $ show i ++ show counter; _ -> fail ""}
18:16:06 <acowley> nh2: But it uses shared OpenCL/OpenGL surfaces for a reasonably pretty visualization (which I guess a couple people at HacNYC saw)
18:17:10 <acowley> Another caveat is that I tend to aim for much slower hardware, so I typically run KF with a smaller grid than most people (e.g. 256^3)
18:17:24 <acowley> Because I demo it on an HD5000
18:19:24 <nh2> acowley: I was pretty disappointed I couldn't run it on my own hardware at all, since my Sandybridge Intel integrated Thinkpad doesn't even support OpenCL
18:19:45 <acowley> nh2: Haswell was a big improvement
18:20:11 <acowley> nh2: But you're two generations back, right?
18:20:43 <acowley> One thing I'd like to try is if POCL can support image types on a CPU
18:20:48 <nh2> acowley: yes, but that's not actually the problem; the problem is that Intel's open source OpenCL drive (beignet) only supports Ivy Bridge GPUs at the moment
18:20:50 <acowley> since Intel's CPU driver doesn't afaik
18:21:06 <acowley> I'm on OS X, so I get what they give me and nothing more
18:21:12 <acowley> which for OpenCL is actually a pretty good deal
18:21:53 <tree_vor> nh2: I think this should be possible... I can't see anything immediately obvious that would stop it
18:22:21 <nh2> well that's a plus already
18:22:30 <tree_vor> nh2: (of course, it is difficult to know for sure without trying...)
18:22:30 <chirpsalot> acowley: OS X is certainly better than most for OpenCL, at least in my experience.
18:22:40 <kwindla> @undo do put "foo"
18:22:41 <lambdabot> put "foo"
18:23:14 <acowley> chirpsalot: Yeah, I've been quite happy with it! I had some crazy hard crashes pre-Mavericks, but none recently.
18:23:15 <chirpsalot> ... Is "undo" what I think it is? Cute.
18:23:54 <chirpsalot> @undo putStr "Hello"; putSTr " world!"
18:23:55 <lambdabot> <unknown>.hs: 1: 15:Parse error: ;
18:24:10 <khyperia> @undo do foo <- getLine; putStrLn foo
18:24:10 <lambdabot> getLine >>= \ foo -> putStrLn foo
18:24:13 <chirpsalot> Err.
18:24:16 <chirpsalot> Yeah.
18:24:20 <khyperia> have yo have the "do" up front
18:24:25 <chirpsalot> Whoops!
18:24:25 <khyperia> to*
18:24:28 <haasn> @undo do (x:xs) <- getArgs; putStrLn x
18:24:29 <lambdabot> getArgs >>= \ a -> case a of { (x : xs) -> putStrLn x; _ -> fail ""}
18:24:32 <chirpsalot> khyperia: thanks :).
18:24:36 <haasn> undo++
18:24:47 <ion> @karma undo
18:24:47 <lambdabot> undo has a karma of 1
18:24:50 <ion> @karma blah
18:24:50 <lambdabot> blah has a karma of 31337
18:25:06 <haasn> @karma unsafeCoerce
18:25:06 <lambdabot> unsafeCoerce has a karma of -2
18:25:17 <chirpsalot> It seems weird that lambdabot would support postincrement :P.
18:25:22 <monochrom> @karma unsafeInterleaveIO
18:25:23 <lambdabot> unsafeInterleaveIO has a karma of 0
18:25:31 <ion> @karma @karma
18:25:31 <lambdabot>  @karma has a karma of 2
18:25:36 <haasn> unsafeInterleaveST--
18:26:01 <nh2> @karma reallyUnsafePtrEquality#
18:26:02 <lambdabot> reallyUnsafePtrEquality# has a karma of 0
18:26:18 <ion> reallyUnsafeDWIM
18:26:38 <athan> karma?
18:26:42 <joelteon> @karma unsafePerformIO
18:26:42 <lambdabot> unsafePerformIO has a karma of 0
18:26:55 <newsham> somewhat n00b question -- lets say you're working with a large haskell project that is made up of several large local libraries, each with their own cabal file..  and you want to make frequent changes to code that is in a library..  is there an easy way to run tests without having to repeated rebuild all the libs and the eventual app cabal?
18:26:55 * hackagebot diagrams-builder 0.5.0.7 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.7 (BrentYorgey)
18:27:34 <athan> @karma DataKinds
18:27:34 <lambdabot> DataKinds has a karma of 0
18:27:41 <newsham> also if you debug such an app, will you get symbols from each of the local libs too?
18:28:42 <athan> newsham: You should be able to localize your tests suites to each library, is the test suite monolithic for the whole app?
18:28:55 <acowley> nh2: Can I ask who your advisor for your project is?
18:28:59 <athan> If so, you might be out of luck and would spend your time better by refactoring your project
18:29:05 <nh2> acowley: Andrew Davison
18:29:13 <newsham> i want to test the app holistically, not rerun individual test suites
18:29:15 <werdna> haha, "andrew" pings me
18:29:18 <acowley> nh2: Excellent!
18:29:29 <akraut> werdna: me too
18:30:04 <newsham> think: maintenance and QA
18:30:19 <athan> newsham: Not sure man, best of luck
18:31:01 <sm> newsham: I use a makefile to run ghc over the whole project in such cases
18:31:05 <athan> newsham: Have you thought about setting up your own travis build for pull's to the repo?
18:31:16 <acowley> nh2: Let me know if you want any input on putting things together, feel free to email me
18:31:17 <athan> but, configuring travis to integrate a dependency graph?
18:31:26 <newsham> athan: in this particular case its not code that I own.
18:31:43 <athan> ahhhh crud
18:31:50 <athan> yeah I wish I could help whoever you're helping lol
18:32:03 <newsham> sm: do you mean you have the makefile run each cabal step?  or that you run ghc on the files yourself without using cabal?
18:32:24 <JustMe> hi
18:32:32 <sm> the latter
18:32:49 <JustMe> what editor or IDE is best for haskell?
18:33:02 <davean> JustMe: openssl
18:33:15 <chirpsalot> JustMe: there's not really a best? The standard set of editors should all work fine.
18:33:30 <davean> With the right commands I'm sure you can upload a compiler and edit your code on other peoples servers :/
18:33:40 <nh2> acowley: that's very nice. I'm currently exploring how to exactly do what I want. My project's core goal is using simple geometry to improve building the model, e.g. I want to detect walls so that I can stitch rooms together which I scan separately (since KF likes to lose track when going through doors). I'm considering writing a Haskell implementation because it *might* be an easier way to get there than to deal with the huge thing that is PCL
18:33:47 <nh2> but I'm not confident about that
18:34:41 <nh2> kfusion seems to work better, but it is very minimalistic, doesn't have shifting volumes and you can't even move around in the scanned model properly, only rotate around a fixed point
18:34:52 <newsham> sm: danke.  perhaps that would be easiest here..
18:34:53 <acowley> My advisor and I have some prior work on extracting floor plan type information from walls you could take a look at.
18:35:07 <sm> newsham: https://github.com/simonmichael/hledger/blob/master/Makefile#L516 is an example
18:35:10 <acowley> nh2: Kintinuous does a great job with moving the volume, but I don't know what you can get your hands on
18:35:22 <newsham> thank you
18:35:36 <nh2> acowley: I emailed them, they don't want to make their code useful (== available)
18:35:47 <acowley> nh2: It's a problem
18:36:12 <acowley> nh2: I try to push out OpenCL and OpenGL libraries for Haskell as it's hard to release the integrated systems
18:37:31 <nh2> I find their non-releasing a real problem, since with kinfu_large_scale being the only one, its really hard to tell if its shortcomings are because the algorithm's aren't good enough or because the implementation is buggy
18:38:13 <acowley> nh2: Here's the paper I mentioned on using walls http://www.cis.upenn.edu/~cjtaylor/PUBLICATIONS/pdfs/TaylorCowleyRSS12.pdf
18:39:25 <acowley> nh2: what do you need out of the KF system?
18:39:35 <acowley> nh2: I don't know how easy it would be to pull mine out
18:39:44 <nh2> acowley: awesome! that looks really useful.
18:39:46 <acowley> nh2: I also don't know how well mine works, frankly
18:40:35 <acowley> Do you have a data set you're using?
18:43:18 <nh2> acowley: my optimal end result would be: A system with which a non-programmer user (e.g. an interior architect) can walk through different rooms of a house, use KF in each room to get room models, an automatic matcher that suggests which walls might be adjacent across the different rooms, and a simple UI for the user to associate walls manually when the heuristic can't do it by itself. Then it should generate the full model by merging the rooms toge
18:43:46 <acowley> nh2: That's ambitious
18:43:50 <nh2> acowley: no, I would really like to have one; currently I'm trying to record the rooms in my flat but tracking often messes up
18:44:16 <acowley> nh2: By data set, I meant an .oni file
18:44:23 <acowley> nh2: Just the range images
18:44:26 <Platz> oh my god: 20 type parameters, 19 of them with constraints: http://source.roslyn.codeplex.com/#Microsoft.CodeAnalysis/Emit/NoPia/EmbeddedTypesManager.cs#19
18:45:49 <nh2> acowley: because the tracking often messes up, and I have to move the camera back a lot to get back working, I can't just blindly record an oni file unfortunately
18:45:59 <acowley> ah
18:46:05 <nh2> I also haven't found a way to run PCL's kinfu and record an .oni file at the same time
18:46:58 * hackagebot diagrams-haddock 0.2.2.5 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.5 (BrentYorgey)
18:47:09 <hunt> is there a suave way to implement crossproduct of (a,b,c) and (d,e,f) because as it stands im just going to use a bunch of weird zipWiths
18:47:15 <hunt> and drops and cycles
18:47:25 <nh2> acowley: I recognized it is more ambitions than I thought when I noticed that KF (or at least kinfu) only works really well when you face inside into a room; as soon as you face outwards to the walls (which I need to, obviously), tracking becomes a real issue
18:47:26 <copumpkin> don't use triples?
18:47:38 <hunt> copumpkin: me?
18:47:44 <copumpkin> yup
18:47:48 <hunt> why not?
18:47:57 <hunt> i need to, im going to use it on 3d vectors
18:47:59 <acowley> nh2: Is there stuff in your room?
18:48:15 <acowley> hunt: consider linear
18:48:23 <acowley> ?hackage linear
18:48:23 <lambdabot> http://hackage.haskell.org/package/linear
18:48:45 <hunt> acowley: well but i want to implement my own crossproduct atm
18:48:47 <nh2> acowley: yes, I even put some stuff to make the geometry more complex (and covered the mirrors :D)
18:49:36 <acowley> nh2: If you'd like, I can run an .oni through my code to see how it tracks
18:49:43 <nh2> acowley: the main problem is, I believe so far, that I have to use kinfu_large_scale to fully cover a room. kinfu itself has an option to increase the volume size, but it works very badly when it's not the default 3 meters for unknown reason
18:50:01 <acowley> 3 meters cubed is pretty big
18:50:04 <heatsink> 3D vector cross product is six multiplications and three additions.  That's small enough that you don't have to feel bad about writing * six times and write + or - three times.
18:50:17 <nh2> acowley: but it can't fit a room
18:50:40 <nh2> also, kinfu's reset functionality doesn't work
18:50:44 <hunt> heatsink: eh alright thanks, is there a generalzed cross product for n-vectors?
18:51:23 <nh2> acowley: that's a great offer! I'll try to record one that fails with kinfu and send it to you
18:51:26 <heatsink> cross product is only defined in 3 dimensions IIRC
18:51:33 <alang> hunt: for 7-vectors
18:51:46 <alang> as well
18:51:57 <nh2> acowley: what camera do you use and do you calibrate for it?
18:51:59 <acowley> nh2: Is it possible you're suffering from poor calibration? A benefit of using published data sets is that they are (sometimes) quite well calibrated
18:52:30 <newsham> is there a way to tell cabal to reinstall a particular version of a package and rebuild/relink all the programs which depended on the version that used to be used?
18:52:30 <alang> hunt: also 0-vectors i guess
18:53:05 <hunt> weird
18:53:14 <hunt> i dont even know what cross products are
18:53:16 <sjy> it's the weirdest math fact since the proven nonexistence of a quintic formula
18:53:37 <athan> heatsink: Really???
18:53:47 <acowley> nh2: We have the usual suspects about (Kinect, Xtion, and KOne). I think the first two were calibrated using whatever PCL recommends. I'm currently using data sets from http://vladlen.info
18:53:52 <athan> heatsink: I feel like you could (categorically) change that :P
18:54:24 <athan> hunt: Cross products are like... the merge of two vectors
18:55:08 <sjy> athan: i find the simplest definition is 'a vector orthogonal to to the two input vectors'
18:55:09 <heatsink> Well, given two directions in 3D that are not parallel, there is one unique direction perpendicular to both of them.  That's not true in any other dimensionality.
18:55:31 <athan> hunt: Actually nevermind, cross products are like the relationship of two vectors, but described in the dimension the two are perpenticular to
18:55:40 <athan> hmm!
18:55:41 <sjy> it gives some insight as to why there's no definition in R2 since you can't have a vector in R2 that's orthogonal to two others
18:56:17 <sjy> that doesn't tell you anything about the magnitude of a x b, but magnitudes are kind of beside the point of vectors
18:56:57 <athan> hmm
18:57:08 <acowley> nh2: I've got to run, but keep me posted!
18:57:41 <athan> I feel like the cross product is like a tensor, relating the "magnitudes" of two vectors to each other
18:57:56 <Rastus_Vernon> Why is `-1` equivalent to `negate 1` even though `(-)` is a function representing the subtraction operation?
18:58:00 <athan> it's just hard to describe in multiple dimensions, because each combined create a new sense of magnitude
18:58:12 <athan> sugar?
18:58:16 <Rastus_Vernon> Is it syntactic sugar or is the - in -1 a function?
18:58:29 <athan> I think it's syntax, Rastus_Vernon
18:58:34 <nh2> acowley: one last question: the data sets downloadable from there? I can't seem to find them yet
18:58:38 <athan> :t (-1)
18:58:39 <lambdabot> Num a => a
18:58:51 <athan> :t ((-) 1)
18:58:51 <lambdabot> Num a => a -> a
18:59:16 <acowley> nh2: http://www.stanford.edu/~qianyizh/projects/scenedata.html
18:59:23 <acowley> and now I'm really gone!
18:59:46 <Rastus_Vernon> ((-) 1) seems to throw an error
18:59:49 <C6R> What subject are you all discussing?
18:59:51 <Rastus_Vernon> So it is probably that.
19:00:03 <athan> C6R: Subject?
19:00:29 <athan> :P
19:00:33 <C6R> What is being discussed?
19:00:47 <heatsink> There is a special parsing rule for -
19:00:51 <athan> I don't think anything right now, I was just talking with Rastus about (-1) vs ((-) 1)
19:01:41 <C6R> and that one went right on over..
19:01:50 <athan> your head?
19:01:58 <C6R> precisely
19:02:01 <athan> lol
19:02:06 <athan> it's actually pretty simple:
19:02:14 <athan> @type (-1)
19:02:14 <lambdabot> Num a => a
19:02:16 <sjy> athan: what do you mean by "magnitude" though? i think there are more natural ways to relate the magnitude of two vectors (namely, calculating the magnitude :P)
19:02:41 <athan> sjy: I see magnitude, in the context of vectors, to be multidimensional, yet still distinguished
19:02:42 <athan> like
19:02:50 <athan> normally people only take it in the 1d sense
19:02:51 <sjy> i don't think that is the definition of magnitude...
19:02:54 <athan> one sec :P
19:03:26 <athan> C6R: So, that type basically means "a is a member of typeclass Num, and we are returning it's value)
19:03:29 <athan> "*(
19:03:31 <athan> gah
19:03:32 <athan> anyway
19:03:44 <sjy> sorry to drag you away from discussing actual haskell ;)
19:03:46 <athan> so (-1) is merely the value of that number
19:03:49 <athan> :D
19:04:03 <athan> now, if you look at the type signature of ((-) 1)
19:04:08 <athan> @type ((-) 1)
19:04:08 <lambdabot> Num a => a -> a
19:04:20 <athan> you can see that it's still pending for an argument
19:04:37 <athan> ((-) 1) needs one more argument before it gets to the result
19:04:47 <athan> ...because (-) itself is a function!
19:05:06 <athan> a binary operation, subtraction if you wanna be specific ;P
19:05:23 <newsham> hackage would be nicer if i could point it at N-cabal files all at once, and have it properly solve the constraints across all of them simultaneously
19:05:31 <newsham> and avoid installing things that would cause conflicts later
19:05:48 <athan> So, the difference between (-1) and ((-) 1) is that the former is a value, while the latter is a function that subtracts whatever it's argument is from 1
19:06:10 <Rastus_Vernon> … while the - in -1 is just syntactic sugar. Although it could have been an unary operation: arithmetic negation.
19:06:21 <athan> @type negate
19:06:22 <lambdabot> Num a => a -> a
19:06:24 <athan> :)
19:06:36 <athan> Rastus_Vernon: You've got it :)
19:06:46 <athan> sjy: Now, regarding our matter :P
19:07:02 <heatsink> @where paste
19:07:03 <lambdabot> Haskell pastebin: http://lpaste.net/
19:07:27 <C6R> Ok understood. This language is? and back to... whats the subject? lol. I truely aprreciate your willingness to teach. I've totally opened this door (irc channel) to the netherlands.
19:07:41 <athan> sjy: I believe that the definition of magnitude should be decoupled from 1-dimensional context
19:07:54 <athan> LOL
19:07:55 <newsham> cabal hell..  time to call it a day..
19:08:01 <athan> C6R: You came to the right place
19:08:29 <athan> sjy: For instance, what's the magnitude of `i`? ( sqrt $ -1 )
19:08:54 <athan> sjy: I believe that it does have a... direction. An "offset"
19:09:03 <athan> and I see that displacement as magnitude
19:09:18 <athan> which, itself, could be described with multiple dimensions
19:09:34 <athan> C6R: This language is my favorite :)
19:09:44 <athan> C6R: Are you a programmer? What languages do you know?
19:10:18 <C6R> Intro: (besides "duh...") Complete beginner in this digital world. 0-100 score.. I'll be gracious and go with 1.5 . I want to learn computer security in general. I don't want to use the term "hacker" either. White- sure w/e lol.
19:10:25 <Rastus_Vernon> Any particular reason this… thing… is recommending using camelCase? http://lpaste.net/102403
19:10:32 <Rastus_Vernon> I like underscores. :(
19:10:47 <athan> C6R: Learn Haskell :P
19:10:52 <monochrom> religious reason. I reject it as well.
19:10:56 <heatsink> it's the commonly used style convention
19:10:57 <athan> C6R: It'll be the best thing you can do for yourself
19:11:11 <Rastus_Vernon> heatsink: Thank you.
19:11:17 <C6R> I've started learning HTML , CSS, JS. and now i'll go google what Haskell is. brb. lol
19:11:23 <monochrom> it is the main reason why I refuse hlint
19:11:37 <athan> Rastus_Vernon: Why have personal beliefs when you could sell your soul??
19:11:43 <C6R> Athan, I like how you use "lol" to. We have established common ground.
19:11:50 <heatsink> So I recently discovered it's possible to use operators as data field names...
19:11:51 <athan> C6R: It's one of the most advanced languages out there man
19:12:00 <heatsink> http://lpaste.net/102404
19:12:02 <athan> :D
19:12:08 <C6R> Athan: whats it used for?
19:12:13 <athan> C6R: Dude...
19:12:26 <athan> C6R: I'm pretty sure Operating systems have been written in it
19:12:26 <Rastus_Vernon> monochrom: Does that mean we need to create a fork and name it “hhint” as a parody of JSLint and JSHint, for which the same thing happened?
19:12:31 <athan> highly advanced web servers
19:12:31 <heatsink> It seems weird though.  I wonder if that's intentional.
19:12:42 <athan> really really rediculous financial systems
19:12:58 <C6R> That'd be a little much for a beginner no? haha
19:12:59 <monochrom> I don't know about "need". let the free market decide.
19:13:23 <athan> C6R: It will give you a leg over EVERY SINGLE ONE of the web app programmers out there
19:13:29 <athan> ...except the ones that know haskell :P
19:13:41 <athan> it's beauty is in it's simplicity
19:13:53 <athan> although the design is difficult to conceptualize at first
19:13:59 <C6R> Is it "avoided" from popularity to actually learn due to its dificulty?
19:14:02 <athan> once you get it, you will master the art of... automation
19:14:09 <athan> well...
19:14:13 <athan> kinda. Maybe
19:14:15 <Rastus_Vernon> It isn’t difficult.
19:14:20 <athan> it's really just not popular
19:14:28 <athan> it's super popular in the financial industry
19:14:29 <C6R> I know one thing.. I need to expand my vocab. XD
19:14:39 <Rastus_Vernon> It is just different from the most common programming languages, which are all imperative, while Haskell is declarative.
19:14:54 <athan> the only reason why it's difficult is because it's designed "right"
19:14:57 <athan> (totally up for debate)
19:15:18 <C6R> Athan: what are you
19:15:19 <athan> but, once you get that design understood, it pretty much changes your life
19:15:22 <heatsink> Well, Haskell is side effect free.  "Declarative" doesn't mean much.
19:15:23 <athan> ALIVE!
19:15:24 <Rastus_Vernon> C6R: Read this if you want to dramatically expand your vocabulary: https://en.wikipedia.org/wiki/Programming_paradigm.
19:15:24 <athan> lol
19:15:54 <C6R> who are you
19:16:17 <athan> Well, my name's Athan, I'm a 22 year old programmer who obsesses over programming
19:16:23 <athan> aaaaand that's pretty much it
19:16:31 <athan> I've got some projects that I really want to make
19:16:40 <athan> and haskell seems like a really good way to make them happen.
19:16:42 <athan> That's about it lol
19:16:49 <athan> Who are you, C6R?
19:16:51 <C6R> What would you like to make? last one or ignore lol
19:16:59 <athan> oh dude
19:17:01 <athan> naw man
19:17:09 <athan> I couldn't ignore lol
19:17:17 <athan> but, I really like to make... widely accessible things
19:17:29 <C6R> Im a 22 y/o explorer still looking for myself.
19:17:33 <athan> the more people that can use it, and make use of it, the better it is imo
19:17:33 <C6R> and I gotta get on the ball
19:17:44 <athan> DUDE I'll help a nigga
19:17:49 <C6R> Well thats the key to the riches brother.
19:17:53 <athan> my email's athan.clark@gmail.com!
19:18:01 <C6R> no shiz?
19:18:04 <athan> yeeee
19:18:30 <athan> hmu, I should be on gmail's chat
19:18:37 <athan> I'll give you the scoop on all this
19:18:52 <C6R> Brb..
19:18:53 <bitemyapp> athan: brave.
19:19:08 <C6R> im harmless bitemyapp..
19:19:10 <C6R> literally
19:19:11 <athan> bitemyapp: I really needed new pr0n anyway
19:19:22 <athan> lol
19:19:23 <bitemyapp> C6R: literally?
19:19:28 <bitemyapp> C6R: LITERALLY?!
19:19:32 <C6R> well.. digitally
19:19:32 <C6R> lmao
19:19:35 <bitemyapp> C6R: or figuratively?
19:19:38 <athan> inductively???
19:19:42 <sjy> athan: i'm confused. the magnitude of i is 1?
19:19:49 <C6R> Conclusively
19:19:51 <monochrom> please don't get carried away
19:19:51 <Rastus_Vernon> athan: abductively?
19:19:55 <athan> sjy: OH SHEEEEIIIIITTTTT
19:20:54 <Rastus_Vernon> athan: non-deterministically?
19:20:55 <athan> monochrom: I'm trying to write a communications design that's opinion-able, hopefully it'll be compatible with irc soon :/
19:20:58 <athan> lol
19:21:07 <athan> sjy: Hmm. I think you're right
19:21:23 <athan> sjy: So magnitude is the context-free displacement, where 0 is the start
19:21:28 <sjy> athan: magnitude/norm is a way to reduce a vector in R^n to a scalar in R
19:21:39 <sjy> it's the length of an arrow in 2d space
19:21:45 <athan> hmmmmmm
19:21:49 <sjy> or in 3d space for that matter (euclidean norm)
19:21:53 <athan> so the sense I've been seeing, is value, directly
19:22:01 <athan> shoot
19:22:16 <sjy> yup. the whole concept of a vector is to extend a bare "magnitude" (ie. real number) to multiple dimensions
19:24:03 <athan> sjy: This is interesting... how would you represent i as a vector?
19:24:10 <athan> i feel like that's beyond a dimension...
19:24:12 <sjy> athan: the reason why i say magnitude is really besides the point of a vector is because vectors are defined to be closed under scalar multiplication, distributive wrt scalar multiplication etc
19:24:23 <sjy> athan: (0 1), or 0 + 1i are the usual notations
19:24:46 <heatsink> The complex numbers are different from 2D space, but they are still vectors
19:24:53 <monochrom> you can say the complex plane is a 2D vector space over R.
19:25:08 <athan> monochrom: Now that's what I'm talking about
19:25:09 <sjy> C (the complex numbers) is R^2 with some extra axioms beyond the 8 vector space axioms
19:25:16 <monochrom> or a 1D vector space over C, to make things worse
19:25:16 <hunt> is there a built in function that converts c style truths to Bools
19:25:23 <hunt> ie 0 to false and everything else to true
19:25:23 <hunt> ?
19:25:39 <heatsink> (/= 0)
19:25:44 <athan> :)
19:25:57 <monochrom> there is none, apart from obtaining one through FFI
19:26:00 <hunt> ah good
19:26:01 <athan> heatsink: I'm still going for lambdas! 'Doh!
19:26:06 <hunt> ok (== 1) is actually what i want
19:26:37 <athan> hm....
19:27:18 <monochrom> (/= 0) can be written as (\x -> x /= 0) if you like lambda
19:27:38 <jle`> (/=) 0 is also cool too if you're into that kinda stuff
19:27:43 <heatsink> (0 =/ x <- x\)
19:28:01 <jle`> because of that one equality law
19:28:14 <jle`> um
19:28:15 <athan> data (Num a, Integral n) => VectorN a n = RealV Vector n a | SurrealV Vector n a
19:28:16 <jle`> what was it again
19:28:21 <monochrom> symmetric
19:28:29 <athan> I'm thinking dependent types here, give me a minute...
19:28:34 <jle`> yes that's it
19:28:40 <jle`> bitemyapp: nice article
19:28:48 <bitemyapp> jle`: thanks.
19:28:52 <bitemyapp> jle`: want to help me out?
19:28:59 <jle`> bitemyapp: it's good to see you post regularly
19:29:01 <jle`> yeah, sure?
19:29:33 <bitemyapp> jle`: I've got a recursive filter sum type whose members sometimes contain [Filter] (sometimes they're sinks)
19:29:38 <bitemyapp> jle`: I'd like nicer syntax than lists.
19:30:15 <athan> monochrom: What courses gave you the insight to say things like "C is a 2d vector plane over R..."?
19:30:23 <athan> if you took any I mean :P
19:30:25 <bitemyapp> an "exists" filter inside of an "or" nested inside an "and" looks like: AndFilter [OrFilter [ExistsFilter "message"]]
19:30:49 <bitemyapp> naturally the equivalent Scala library cheats and does stuff like:  def must(queries: FilterDefinition*)
19:30:53 <bitemyapp> note the *
19:30:57 * bitemyapp eye-roll
19:30:59 <monochrom> a course on complex analysis. sometimes. this aspect is not very important.
19:31:04 <bitemyapp> jle`: thoughts?
19:31:09 <athan> I'm just intrigued
19:31:35 <heatsink> A course on abstract algebra is probably a prerequisite
19:31:47 <sjy> anything that introduces the formal definition of a vector space
19:32:34 <bitemyapp> jle`: thanks for the pat on the back about the post. Those comments do help a lot.
19:32:48 <heatsink> What is the article?
19:32:50 <bitemyapp> I was surprised nobody nitpicked the mention of dependent types.
19:32:58 <bitemyapp> heatsink: http://bitemyapp.com/posts/2014-04-05-grokking-sums-and-constructors.html
19:33:32 <athan> bitemyapp: We really should support eachother more
19:33:34 <athan> i mean
19:33:37 <athan> i actually have no idea
19:33:45 <athan> but humans in general are terrible at being human
19:33:52 <bitemyapp> even if we pretend for the sake of argument that I can have variable arity here, it'd mean more parens than I'd save in brackets.
19:33:54 <jle`> recursive filter sum type
19:33:56 <athan> ...in my opinion.
19:33:58 <monochrom> the need for a tutorial on sum types makes me sad.
19:34:02 <bitemyapp> so [Filter] remains compact.
19:34:11 <jle`> do you mean some sort of recursive data structire reifying filters?
19:34:24 <bitemyapp> jle`: it's wrapping a JSON based DSL for a search engine.
19:34:37 <bitemyapp> jle`: it can have arbitrarily nested and/or of "sinks", sinks being actual constraints/filters.
19:34:59 <jle`> would it be similar at all to the dsl persistent provides for generating queries
19:35:29 <bitemyapp> whenever I want a reminder of what a library looks like, "Haskell ocharles Persistent" to the rescue.
19:35:47 <jle`> heh
19:35:52 <jle`> he is the man.
19:35:57 <bitemyapp> jle`: close'ish. Esqueleto uses lists too.
19:36:04 <jle`> ah yeah
19:36:12 <bitemyapp> I'm going to assume that dude knew more than I did...so I should stick with [Filter] for now?
19:36:26 <jle`> what do you mean by a sink
19:36:51 <bitemyapp> jle`: 'and' and 'or' are all well and good, but it has to terminate in some kind of constraint to make any sense.
19:36:58 <bitemyapp> jle`: some kind of filter.
19:37:21 <jle`> so you mean like ExistsFilter
19:37:24 <jle`> in your case
19:37:30 <bitemyapp> a sink is anything that doesn't have Filter in the type.
19:37:34 <bitemyapp> jle`: yep!
19:38:31 <bitemyapp> my example earlier turns into: "{\"and\":[{\"or\":[{\"exists\":{\"field\":\"message\"}}],\"_cache\":false}],\"_cache\":false}"
19:39:04 <jle`> hm
19:39:07 <jle`> well
19:39:17 <jle`> i guess this is kind of like a rose tree right?
19:39:22 <jle`> except with different colored nodes
19:39:28 <athan> Doth any-whom know'ith how to gain insight to cabal "ExitFailure 1"s? O.o
19:39:29 <bitemyapp> jle`: in some parts of the sum type, yeah.
19:39:41 <bitemyapp> some sum lol
19:40:02 <athan> like, how do I debug with cabal's lack of details?
19:40:03 <jle`> what kind of thoughts are you looking for?
19:40:17 <bitemyapp> athan: http://www.haskell.org/cabal/FAQ.html#exitfailure-1
19:40:25 <bitemyapp> jle`: uh. I dunno. :( make it prettier?
19:41:00 <jle`> well
19:41:08 <jle`> you could use some sort of writer-like monad to build it?
19:41:37 <athan> hmmm
19:41:44 <bitemyapp> I don't know how to make that not-horrible at present.
19:41:49 <athan> There's no error for the library that didn't install
19:41:51 <bitemyapp> But I'll let it rattle around in my head.
19:41:56 <bitemyapp> athan: re-run?
19:42:01 <bitemyapp> jle`: thanks for the idea.
19:42:06 <athan> It literally installed one of them sucessfully, then spat out the next one without even trying
19:42:08 <athan> :/
19:42:09 * bitemyapp goes back to the salt mines
19:42:16 <athan> hahaha
19:42:49 <jle`> are you making it data Filter = AndFilter [Filter] | OrFilter [Filter] | SinkFilter Sink ?
19:43:03 <bitemyapp> lot uglier than that mate.
19:43:08 <bitemyapp> jle`: do you see the code?
19:43:16 <bitemyapp> https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Client.hs
19:43:58 <jle`> bitemyapp: can you turn it into a monoid?
19:43:58 <Fuuzetsu> what's with all the commented out blocks, just delete them and get them back from git later if you need them
19:44:24 <bitemyapp> Fuuzetsu: the commented out blocks are to scare people away
19:44:29 <jle`> actually
19:44:34 <bitemyapp> "crazy here! run while you still can!"
19:44:34 <jle`> this kinda sounds like some sort of ring
19:44:35 <Fuuzetsu> https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Client.hs#L247 isn't this the instance you get when you deriveJSON?
19:44:44 <jle`> if or is + and and is *
19:44:55 <jle`> and your sinks are your items
19:45:06 <bitemyapp> Fuuzetsu: you can't deriveJSON with a parametric type.
19:45:18 <bitemyapp> Fuuzetsu: or, if you're supposed to, it hasn't worked for me.
19:45:35 <jle`> it is a ring with no inverses
19:45:39 <jle`> if you can think of an identity
19:45:45 <Fuuzetsu> oh, I don't know about that then
19:45:46 <jle`> which...i'm sure you could
19:45:52 <bitemyapp> Fuuzetsu: welp.
19:46:05 <jle`> it looks like a near semi ring maybe
19:46:17 <jle`> if...it's distributive.
19:46:25 <bitemyapp> jle`: uhhhh kinda but it would either be a broken filter or I'd have to rip out the redundancy the moment something was added.
19:46:26 <Fuuzetsu> is near semi ring maybe formalised anywhere ;)
19:46:42 <jle`> near semi ring maybeT
19:46:48 <jle`> :)
19:46:50 <monochrom> . o O ( it is nearly formalized somewhere )
19:46:57 <Fuuzetsu> (maybe)
19:47:00 <jle`> nearly semi-formalized
19:47:01 <bitemyapp> Fuuzetsu: I lost like 45 minutes yesterday trying to get the bloody deriveJSON/Generics/TH working with a parameterized type. No love.
19:47:22 <Fuuzetsu> bitemyapp: you could try asking on MLs
19:47:41 <bitemyapp> CBA
19:47:42 <jle`> is there a haskell typeclass corresponding to near semi rings?
19:47:46 <jle`> i mean...
19:47:50 <jle`> it could be a superclass of Monoid
19:47:54 <bitemyapp> jle`: like product and sum types you mean?
19:48:08 <jle`> well, two operations
19:48:09 <bitemyapp> aren't the + and *'s in Haskell seminearrings?
19:48:18 <jle`> it's on the data level
19:48:24 <jle`> you'd have <> :: a -> a -> a
19:48:31 <joelteon> ok, this is strange. Data.Thyme is giving me vastly differing values for getCurrentTime
19:48:36 <jle`> and also... >< :: a -> a -> a
19:48:41 <peddie> http://hackage.haskell.org/package/monoids-0.1.2/docs/Data-Ring-Semi-Near.html
19:48:42 <jle`> (there is probably a bette roperator heh)
19:48:57 <jle`> where both form "monoids", with an identity
19:49:00 <jle`> for both
19:49:01 <joelteon> I know that sounds funny on the face of it, but replicateM 10 getCurrentTime will give me values that are 1 hour to 1000 years apart
19:49:17 <codygman> I'm trying to use the mysql-simple package and I have an error. I know it's because I'm not specifying the type, but I'm not sure how to figure out what type it needs to be from the type errors. I would really like to know how to figure out the error myself fromt he type errors/source code/instances it leads to. Here is my code+errors: http://lpaste.net/102405
19:49:24 <jle`> but (a <> b) >< c == (c >< b) <> (c >< a)
19:49:25 <bitemyapp> joelteon: you invented a time machine. Congrats.
19:49:40 <joelteon> awesome
19:49:43 <bitemyapp> jle`: the question is, is that preferable to AndFilter []?
19:50:09 <jle`> also the identity of the <> must return itself when ><'d with anything
19:50:12 <jle`> hm.
19:50:13 <Rastus_Vernon> Haskell variables can contain the ' character?!?
19:50:15 <jle`> well say you have two filters
19:50:19 <joelteon> guess I gotta use Data.Time
19:50:21 <jle`> and you want to "or" them
19:50:25 <jle`> you can use ><
19:50:27 <jle`> er
19:50:29 <jle`> <>
19:50:32 <jle`> and say you have two filters and you want to 'and' them
19:50:34 <jle`> you can ><
19:50:48 <monochrom> yes Rastus_Vernon. I use it all the time.
19:51:05 <jle`> Rastus_Vernon: it comes up a lot in math ... x, x' ...
19:51:07 <Rastus_Vernon> That can be useful.
19:51:20 <jle`> yes it also contributes to the trend of unhelpful variable names :)
19:51:31 <jle`> which is a stylistic canon in haskell
19:51:39 <Rastus_Vernon> I realized that trend was very present in Haskell code…
19:52:09 <jle`> but who prefers longAndUnwieldyCamelCapsJavaIdentifier ?
19:52:17 <heatsink> jle`: Well, what would _you_ name the operands of ($)?
19:52:21 <jle`> (of course there is no intermediate/in between)
19:52:42 <jle`> heatsink: ?
19:52:47 <jle`> g2g, though. best of luck bitemyapp
19:52:54 <Kaidelong> jle`: that distribution law doesn't look right unless you restrict the monoid for multiplication to be abelian
19:52:59 <bitemyapp> jle`: thanks, it at least lets me know what category I'm in.
19:53:02 <jle`> i might think it over
19:53:06 <bitemyapp> jle`: should help me. Thanks!
19:53:09 <heatsink> f $ x = f x
19:53:13 <jle`> Kaidelong: yeah, you're right
19:53:14 <bitemyapp> I probably won't change it for now though, haha :)
19:53:24 <Rastus_Vernon> One-letter variables are very common in Haskell, but they’re still better than things like is_coercible_into_enumeration_element.
19:53:28 <heatsink> Hard to make names less helpful than 'f' and 'x'
19:53:41 <jle`> heatsink: yeah, def.
19:53:49 <jle`> i have totally bought into it
19:53:54 <jle`> but sometimes i like to reflect as an outsider.
19:54:03 <bitemyapp> heatsink: f is a function, x is a polymorphic value.
19:54:24 <Rastus_Vernon> heatsink: You could use firstArgument and secondArgument.
19:54:51 <monochrom> dividend / divisor. applicend $ applier.
19:55:02 <Rastus_Vernon> heatsink: If you wanted to look smart (read: stupid), you would write firstArgumentOfTheFunction and SecondArgumentOfTheFunction.
19:55:18 <heatsink> functionArgumentWhoseNameBeginsWith'f' $ valueArgumentWhoseNameBeginsWith'v' = functionArgumentWhoseNameBeginsWith'f' valueArgumentWhoseNameBeginsWith'v'
19:55:24 <bitemyapp> usually my types are the ones being descriptive.
19:55:32 <bitemyapp> but sometimes the args are descriptive...liiiike...
19:55:40 <bitemyapp> toJSON (MustNotMatch term)
19:55:46 <bitemyapp> alright, so you gotta term!
19:56:02 <bitemyapp> toJSON (Term termField termValue) =
19:56:08 <bitemyapp> termField and termValue. Self-explanatory.
19:56:18 <bitemyapp> could easily be chopped down to field and value, or f and v without losing much though.
19:56:55 <bitemyapp> nary a ' or x or xs to be found.
19:57:32 <bitemyapp> Fuuzetsu: http://www.folklore.org/StoryView.py?story=Make_a_Mess,_Clean_it_Up!.txt
19:57:46 <bitemyapp> Fuuzetsu: re: commented out blocks
20:01:52 <hunt> built-in for finding all (==a) in [a]
20:01:54 <hunt> ?
20:02:15 <hunt> im trying to find all the duplicates in a list
20:03:26 <heatsink> nub removes all duplicates in a list
20:03:46 <hunt> ok i can work with that
20:03:49 <hunt> out of curiosity
20:03:54 <heatsink> It has poor asymptotic performance so you don't want to use it for big lists
20:03:58 <hunt> is there anything i could replace find with
20:04:02 <hunt> this is just personal analysis
20:04:04 <hunt> not production
20:04:10 <hunt> anyways
20:04:19 <hunt> what could i replace find with in "map ($ a) . map find . map (==) $ a" to findAll instead
20:05:05 <heatsink> :t \a -> map ($ a) . map find . map (==) $ a
20:05:06 <lambdabot> Eq a => [a] -> [Maybe a]
20:05:38 <ion> Why is that expression so obfuscated?
20:05:47 <hunt> i couldnt think of a better way to write it
20:05:50 <Kaidelong> is it?
20:05:58 <heatsink> This searches for each element of a... in a?
20:06:03 <hunt> yea
20:06:04 <heatsink> Of course each element of a is in a...
20:06:07 <hunt> i know
20:06:11 <hunt> thats why i want to change find
20:06:12 <hunt> to findall
20:06:17 <hunt> i wanted it to find all instances of a in a
20:06:58 <Kaidelong> @ty find
20:06:58 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:07:03 <hunt> how would you guys write this function
20:07:08 <heatsink> > group $ sort [6, 3, 7, 3, 8, 8, 1, 6]
20:07:09 <lambdabot>  [[1],[3,3],[6,6],[7],[8,8]]
20:07:14 <hunt> well
20:07:21 <hunt> thats ... better
20:07:48 <hunt> @hoogle group
20:07:49 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
20:07:49 <lambdabot> Data.ByteString.Lazy group :: ByteString -> [ByteString]
20:07:49 <lambdabot> Data.ByteString.Lazy.Char8 group :: ByteString -> [ByteString]
20:07:54 <hunt> @src group
20:07:54 <lambdabot> group = groupBy (==)
20:07:59 <hunt> @src groupBy
20:08:00 <lambdabot> groupBy _  []       =  []
20:08:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:08:00 <lambdabot>     where (ys,zs) = span (eq x) xs
20:08:22 <Kaidelong> @ty map head . filter ((1<) . length) . group . sort
20:08:23 <lambdabot> Ord b => [b] -> [b]
20:09:04 <hunt> > map head . filter ((1<) . length) . group . sort $ [1..5]
20:09:05 <lambdabot>  []
20:09:06 <ion> Computing the length and then comparing to an Int isn’t very efficient.
20:09:39 <Kaidelong> nope
20:10:09 <Kaidelong> you could do
20:10:22 <Kaidelong> not . null . drop 2
20:10:31 <ion> > [ a | (a:_:_) <- group (sort [1,1,2,2,3,4,5,5]) ]
20:10:32 <lambdabot>  [1,2,5]
20:11:09 <Kaidelong> hi, fail
20:11:18 <Kaidelong> I guess I didn't think of using that
20:12:00 <Kaidelong> I was thinking in the back of my head "if only haskell had first class patterns" but that gets pretty close
20:12:08 * hackagebot dyre 0.8.12 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.12 (WillDonnelly)
20:15:54 <jle`> fail is my favorite usage of list comprehensions
20:16:02 <jle`> actually it's normally the only time i use list comprehensions
20:16:21 <bitemyapp> jle`: you like fail?
20:16:28 <ion> Do list comprehensions (as opposed to monad comprehensions) actually use fail?
20:16:41 <ion> in GHC
20:16:41 <jle`> > [ x | x@(Left _) <- [Right 5, Right 3, Left 7, Right 8, Left 8] ]
20:16:42 <lambdabot>  [Left 7,Left 8]
20:17:02 <jle`> easiest way to filter on a constructor i think.
20:17:02 <erisco> conal, I am working with reactive-banana and realised a weakness in the way I would model the events of an ajax response.
20:17:02 <bitemyapp> jle`: oh right.
20:17:09 <dmwit> ion: They use something indistinguishable from fail.
20:17:13 <geekosaur> non-monad list comprehensions use filter. I think if you do a list comp when MonadComprehensions is enabled, it uses fail?
20:17:15 <ion> dmwit: yes
20:17:25 <jle`> instead of writing those ugly case expressions and manually writing your predicate
20:17:29 <jle`> as a lambda or pointfree or whatever
20:17:33 <geekosaur> (by using a pattern match instead of filter)
20:17:46 <hunt> function for rounding a float to 3rd decimal?
20:17:48 <jle`> credit to Iceland_jack for pointing this out to me
20:18:01 <dmwit> hunt: (/1000) . round . (*1000)
20:18:04 <hunt> round . (*1000(
20:18:04 <hunt> yea
20:18:07 <jle`> i still remember the day like it was yesterday.
20:18:07 <hunt> thanks
20:18:07 <conal> erisco: i don't know much about reactive-banana. i can can talk from a frp theory and history perspective, but might not be very helpful.
20:19:00 <ion> @type (/1000) . round
20:19:01 <lambdabot> (Fractional c, Integral c, RealFrac a) => a -> c
20:19:06 <dmwit> yes, well
20:19:10 <erisco> conal, reactive-banana defines behaviours as having value over continuous time and events as a list of future values, so if we can talk in those terms I think it will be fine
20:19:16 <dmwit> (/1000) . fromIntegral . round . (*1000)
20:19:26 <jle`> geekosaur: wait, do list comprehensions really use filter as a desugar?
20:19:30 <conal> erisco: you bet. so far sounds like frp.
20:19:37 <dmwit> hunt: Alternately, use realToFrac and a 3-digit fixed-point type.
20:19:54 <geekosaur> that's my recollection. possibly they only do something equivalent to it
20:20:12 <jle`> how is something like [ x | x@(Left _) <- ... ] done then?
20:20:17 <hunt> dmwit: how do i use a 3-digit fixed-point type?
20:20:23 <jle`> what is the predicate?
20:20:25 <ion> @type \a -> ((/1000) . fromIntegral . round (*1000)) a `asTypeOf` a
20:20:26 <lambdabot>     Could not deduce (RealFrac (a0 -> a0))
20:20:26 <lambdabot>       arising from a use of `round'
20:20:26 <lambdabot>     from the context (Fractional a, Integral b, Integral (a -> b))
20:20:29 <ion> @type \a -> ((/1000) . fromIntegral . round . (*1000)) a `asTypeOf` a
20:20:30 <lambdabot> RealFrac a => a -> a
20:20:35 <geekosaur> hm
20:20:45 <jle`> i'm curious
20:20:49 <jle`> but it's probably in the report
20:20:49 <dmwit> hunt: import Data.Fixed; 42 :: Fixed E3
20:20:53 <erisco> conal, anyways there are three event types. Progress, Response, and Exception. Therefore, the events could be modelled as (Event Progress, Event Response, Event Exception)
20:21:52 <conal> erisco: maybe. are Progress & Response naturally (rather than habitually) discrete?
20:22:05 <erisco> conal, however what I noticed is that this model does not encode the temporal relationship the events have. For example, Response and Exception events will only happen once, and only one of the two will occur
20:23:08 <erisco> conal, the Progress event informs of new downloaded data, which naturally happens in chunks. While you could imagine a Progress behaviour, it would be stepped anyways because the data is digital
20:23:42 <dmwit> hunt: I suppose it's also possible you just want to know about formatting a string, in which case you can use printf or the Numeric module's show[EFG]Float functions.
20:23:44 <erisco> conal, the Response provides and informs that the complete data is downloaded
20:24:07 <conal> erisco: you might want to combine response and exception.
20:25:43 <ion> @type let fixedType f x = f x `asTypeOf` x in (/1000) . fixedType (fromInteger . round) . (*1000)
20:25:44 <lambdabot> RealFrac c => c -> c
20:25:55 <conal> erisco: and i see your point about not capturing the at-most-once vs any-number properties of Progress vs the rest.
20:26:14 <erisco> conal, that would be possible. However, I was thinking of how I might encode the temporal relationships in the types, and I did come up with a simple idea
20:26:34 <conal> erisco: and i'd go with behavior for Progress, since it's a quantity. that it's a step function might not be important.
20:27:03 <conal> erisco: i.e., a dynamic (time-varying) property
20:27:40 <ion> @type (/1000) . fromInteger . round . (*1000) `asTypeOf` id
20:27:41 <lambdabot>     Precedence parsing error
20:27:42 <lambdabot>         cannot mix `.' [infixr 9] and `asTypeOf' [infixl 9] in the same infix expression
20:27:54 <ion> @type ((/1000) . fromInteger . round . (*1000)) `asTypeOf` id
20:27:55 <lambdabot> RealFrac c => c -> c
20:27:56 <erisco> conal, hm, that would improve things
20:29:47 <erisco> conal, let me describe my idea and maybe you will have some thoughts about it. A way I might model the request, as a type, is  Many Progress `Then` (A Response `Xor` An Exception)
20:30:23 <conal> erisco: sure. sort of regexp-like
20:30:32 <conal> erisco: or more generally, grammar-like
20:30:38 <erisco> conal, basically there are higher order types for multiplicity (one, many, some) and for temporal relationship (then, simultaneously)
20:30:43 <erisco> conal, yes indeed
20:31:27 <conal> erisco: sounds worth exploring.
20:31:27 <erisco> conal, I thought it was interesting that how the events would occur might be neatly stated by the type
20:32:24 <conal> erisco: yeah. a sort of hybrid discrete/continuous grammar.
20:32:43 <conal> erisco: with maybe some sort of temporal parser combinator library.
20:33:55 <conal> erisco: with context-free & context-sensitive flavors
20:34:15 <conal> erisco: ... with applicative and monadic parsers, respectively
20:36:23 <erisco> conal, I think my two challenges are how to compose producers of events and how to compose consumers of events
20:36:56 <erisco> conal, for that reason I thought pipes might be the direction to look, but at the moment I am not sure
20:38:23 <conal> erisco: i recommend that you first get precise/clear about the meaning you want (semantics), and then look to see what approach/library supports your intended meanings correctly and conveniently.
20:39:51 <erisco> conal, makes sense. I'll have to do more thinking
20:40:05 <conal> erisco: glad to hear. it'll pay off.
20:41:24 <conal> erisco: thanks to IO, haskell can be used as a hacking language (implementation without denotation), but it needn't be. precise thinking encouraged.
20:49:10 <erisco> thanks for your time conal
20:49:23 <conal> erisco: you bet. ttyl.
21:03:41 <jle`> conal is a living legend
21:09:07 <athan> Anyone wanna make the web bug-free with me? n.n
21:14:41 <bitemyapp> athan: (no)
21:14:56 <athan> :t (no)
21:14:57 <lambdabot>     Not in scope: `no'
21:14:57 <lambdabot>     Perhaps you meant one of these:
21:14:57 <lambdabot>       `not' (imported from Data.Bool),
21:16:00 <newsham> so i'm in cabal hell, and i would like to back out a bunch of packages..  anyone know if there's an easy way to identify which packages came from ghc itself, which packages came from haskell-platform and which ones are from neither of those?
21:16:20 <newsham> i would like to restart the installation of the third party stuff
21:16:21 <athan> ._.
21:16:23 <shachaf> Did you install the package user-locally or globally?
21:16:29 <newsham> globally
21:16:45 <athan> `cabal install --force-reinstalls` (if you're guts-y)
21:16:46 <newsham> i guess this would be a lot easier if i didnt :)
21:16:49 <shachaf> "don't do that"
21:16:53 <shachaf> I guess that doesn't help you now.
21:16:55 <newsham> yah i'm not doing force reinstall
21:17:06 <bitemyapp> newsham: delete everything and use a sandbox.
21:17:14 <newsham> i am debating just wiping ghc and cabal and reinstalling
21:17:16 <athan> ^ +`
21:17:18 <athan> 1
21:17:25 <bitemyapp> athan: wut
21:17:32 <athan> you get +1
21:17:35 <bitemyapp> newsham: might be faster if you don't know how to ghc-pkg unregister.
21:17:36 <athan> for your... value
21:17:44 <bitemyapp> athan: I don't...what.
21:17:47 <athan> lol
21:17:51 <athan> tell the people I work with
21:18:01 <athan> they use it on skype religiously
21:18:17 * bitemyapp blinks vacantly
21:18:19 <zq> @hoogle a -> [a] -> [a]
21:18:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:18:20 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
21:18:20 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
21:18:23 <bitemyapp> newsham: ghc-pkg unregister.
21:18:24 <newsham> i know how to ghc-pkg unregister, but i dont know what to ghc-pkg unregister
21:18:43 <bitemyapp> newsham: make a sandbox. try installing the same package in that sandbox.
21:18:51 <bitemyapp> newsham: put a shotgun to the head of anything it complains about it.
21:18:57 <bitemyapp> if this breaks your GHC install, *then* reinstall.
21:19:15 <bitemyapp> this could actually be automated if anybody in the Haskell community found packaging *exciting*
21:19:24 <bitemyapp> can we steal a few dullards from NPM or something?
21:19:28 <shachaf> How did you typically install things?
21:19:31 <bitemyapp> jk jk :)
21:19:57 <bitemyapp> newsham: alternately, you can use an hsenv for isolation from your global packages.
21:20:16 <bitemyapp> newsham: you have *sweeping one-armed motion at the sky* a universe of options available to you.
21:20:33 <delimax> bitemyapp: strong imagery 10/10
21:21:08 <bitemyapp> newsham: makes you feel any better, I only know because I banged my head against packaging for $HOURS hours.
21:21:10 <zq> @hoogle wrap
21:21:10 <lambdabot> package wraparound
21:21:10 <lambdabot> Text.Regex.Posix.Wrap wrapCompile :: CompOption -> ExecOption -> CString -> IO (Either WrapError Regex)
21:21:10 <lambdabot> Text.Regex.Posix.Wrap wrapCount :: Regex -> CString -> IO (Either WrapError Int)
21:21:30 <zq> isn't there a wrap function that tacks on an x onto the front and back of my xs?
21:21:44 <zq> \x xs -> x : xs ++ [x]
21:21:49 <bitemyapp> zq: you want a cons snoc?
21:22:07 <bitemyapp> @pl \x xs -> x : xs ++ [x]
21:22:07 <lambdabot> liftM2 (.) (:) (flip (++) . return)
21:22:10 <bitemyapp> sweet.
21:22:35 <bitemyapp> yis it works.
21:22:44 <bitemyapp> zq: you know that'll be hella slow right?
21:22:49 <zq> duh
21:22:53 <bitemyapp> JUST SAYIN
21:22:55 <zq> everyone knows that ++ is n^2
21:23:06 <bitemyapp> interesting definition of everyone.
21:23:31 <athan> lol
21:23:32 <zq> erryone who read that cabal reverse foldr n^2 fiasco a while back
21:23:45 <bitemyapp> I think that was nub.
21:24:04 <bitemyapp> and if the authors of cabal and fuck up O(n^2), so can you :)
21:24:12 <bitemyapp> s/and/can/g
21:24:25 <athan> bitemyapp: wtf does that mean
21:24:29 <zq> schadenfreude helps me learn from the mistakes of giatns
21:24:33 <athan> s/and/.../?/...
21:24:40 <bitemyapp> athan: HOW DO I REACH THESE KEEEEEEDS
21:24:45 <bitemyapp> athan: oh that? sed yo.
21:24:48 <bitemyapp> and vim.
21:24:52 <athan> DOH
21:25:01 <Cale> zq: Er, (++) isn't O(n^2), fully evaluating xs ++ ys takes O(length xs) steps.
21:25:09 * bitemyapp takes the derp cap away from jophish and plants it on athan
21:25:17 <athan> :D
21:25:46 <zq> Cale: for a single xs, sure. then ++ wouldn't even be a concern. this was all in the context of a loop.
21:26:04 <bitemyapp> yeah but the loop is the other n innit?
21:26:56 <zq> Cale: were you at hac nyc? i swear i heard your name thrown around
21:27:25 <Cale> I wasn't, but my name might've been mentioned nonetheless. I know some of the people who were there.
21:27:52 <Cale> (++) is as efficient as possible at what it does, but sometimes the surrounding algorithm can be modified in such a way that (++) isn't needed.
21:28:30 <Cale> The usual trick is to replace the lists [a] being concatenated with functions of type [a] -> [a] which add elements to the beginning of a given list
21:28:38 <Cale> The empty list [] becomes id
21:28:45 <bitemyapp> dlists
21:28:45 <Cale> A singleton list [x] becomes (x:)
21:28:51 <Cale> and (++) becomes (.)
21:29:00 <lispy> Is there a two value type with a Num instance in the standard libraries? Basically, a Bit type.
21:29:27 <Cale> Since (.) is always constant cost, this can reduce the time complexity
21:29:52 <Cale> and you can then apply the resulting function to [] at the end to obtain the desired result
21:29:57 <derp> Cale: Then, do you flatten the list or something?
21:30:06 <derp> my god
21:30:07 <derp> that's awesome!
21:30:14 <bitemyapp> derp: http://www.haskell.org/haskellwiki/Difference_list
21:30:33 <Cale> As an example, suppose we have this tree type:
21:30:41 <newsham> is there a way to have "cabal" fetch some dependencies from a local dir?
21:30:42 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
21:30:48 <Cale> and we'd like to do an inorder traversal
21:30:53 <newsham> err meant the quotes on the fetch not the cabal
21:31:00 <Cale> inorderNaive :: Tree a -> [a]
21:31:06 <Cale> inorderNaive Tip = []
21:31:11 <lispy> basically, I want to write data Bit = Z | O deriving (Eq, Ord, Enum, ...), instance Num Bit where ..., and I'm just wondering if it exists already.
21:31:22 <Cale> inorderNaive (Branch x l r) = inorderNaive l ++ [x] ++ inorderNaive r
21:31:39 <lispy> newsham: if you're using sandboxes you just use add-source
21:31:46 <Cale> This will take quadratic time in any case where the tree leans to the left at all.
21:31:56 <newsham> i dont know what cabal sandboxes are yet.
21:31:58 <lispy> newsham: if you're not using sandboxes, you can cabal install <somedirectory>
21:32:01 <Cale> So, we can do this:
21:32:06 <Cale> inorder' Tip = id
21:32:17 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
21:32:26 <derp> Cale: That's genius
21:32:33 <Cale> here, we have  inorder' :: Tree a -> ([a] -> [a])
21:32:33 <lispy> newsham: this looks like a reasonable intro: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
21:32:42 <Cale> and then we can write:
21:32:44 <derp> you assemble the constructors instead of pulling the data and reassembling it
21:32:47 <Cale> inorder t = inorder' t []
21:32:54 <lispy> newsham: sandboxes are a nice way to keep the things you install from conflicting with the other things you install.
21:33:11 <newsham> lispy: can I do   "cabal install dir1 dir2 dir3 dir4 dir5" to make it install all of them in one go, calculating the deps all together?
21:33:14 <lispy> newsham: I highly recommend using sandboxes for haskell stuff.
21:33:27 <lispy> newsham: maybe? I haven't tried that.
21:33:37 <derp> What's your favorite language, lispy?
21:33:38 <derp> lol
21:33:54 <lispy> derp: english :)
21:33:57 <derp> ha!
21:34:41 <derp> lispy: Do you find scheme to be an advancement over lisp? Also, is lisp metacircular? I'm not sure if lisp has an eval, apply sequence :/
21:35:19 <lispy> derp: I stopped programming in lisp circa 2005. I never learned scheme so I can't comment there. lisp is metacircular.
21:35:45 <derp> ahh right on. Are you working on any cool projects atm?
21:36:50 <lispy> Kind of. I've been studying up on the 6502 (using the NES as a case study). I'm making slow progress towards having an assembler, emulator, and fpga around the NES.
21:37:19 <lispy> my emulator just does the 6502. No graphics support yet.
21:37:37 <lispy> I just started the assembler and it doesn't even have all the instructions defined yet.
21:37:50 <lispy> The fpga stuff is totally stalled and non-existent :)
21:38:13 <lispy> the emulator and assembler are in Haskell.
21:38:22 <lispy> I'm using vhdl for the fpga stuff.
21:38:40 <lispy> derp: how about you?
21:38:49 <derp> No way!!!! That's too cool man!!!
21:39:04 <derp> I'd really like to get into fpga stuff
21:39:42 <derp> I glanced over a blog post about a guy who made a proxy or web server with one.
21:40:05 <zq> if i had a nickel for everytime Aerlinger reconnected
21:40:28 <derp> but I've also got some pseudo-projects going haha. Right now I'm trying to make web design (via yesod (maybe)) bug-free
21:40:58 <derp> I'm also trying to kick around a category diagramming tool to help me learn lol
21:41:05 --- mode: ChanServ set +o shachaf
21:41:29 <derp> I think it would be cool to have category diagrams be a media of communication
21:41:50 --- mode: shachaf set +b *!~aerlinger@*$##fixyourconnection
21:41:53 --- mode: shachaf set -o shachaf
21:42:18 <lispy> derp: wow. ambitious :)
21:42:22 <derp> zq: I wish I had an irc free monad that I could dynamically add filtrations to
21:42:31 <derp> lispy: More like obsessed lol
21:42:36 <derp> :P
21:43:19 <derp> thank you though, lispy :)
21:43:29 <derp> are you in school?
21:46:00 <erisco> :t foldr1
21:46:01 <lambdabot> (a -> a -> a) -> [a] -> a
21:48:29 <haasn> thoughtpolice: haskell.org still seems affected
21:48:34 <haasn> thomas358: http://filippo.io/Heartbleed/#haskell.org
21:48:38 <haasn> thoughtpolice: *
21:50:15 <joelteon> does the pointer used by allocaBytes point to a zeroed chunk of memory?
21:52:15 <joelteon> looks like not
21:56:29 <joelteon> are there any utilities for that in the stdlib? i cannot find one
21:57:22 <erisco> :t iterate
21:57:23 <lambdabot> (a -> a) -> a -> [a]
22:00:33 <derp> haasn: Affected?? Is this an ssl thing? What's the issue?
22:01:11 <c_wraith> derp: pretty severe issue in openSSL, that allows remote clients to grab random chunks of server memory contents
22:01:41 <c_wraith> derp: proof of concept tests found it easy to grab SSL private keys, at the very least
22:02:05 <derp> c_wraith: My god!!! Are there any other utilities / tests that check vulnerabilities like these?
22:02:25 <derp> this is really interesting
22:07:21 * hackagebot slot-lambda 0.1.0.3 - Write lambdas without naming the parameters.  http://hackage.haskell.org/package/slot-lambda-0.1.0.3 (ducis)
22:20:57 <conal> I'm having some trouble with GHC HEAD just git-pulled and built. When I try installing mtl (or installing cabal-install tries to install mtl), I get "Failed to install mtl-2.1.3.1" and then "World file is already up to date." I've not installed HEAD from sources before, so I might be missing something very basic. Any ideas?
22:22:04 <newsham> I think I solved my cabal issues.     $ cabal install --max-backjumps 1000 */*.cabal      seemed to do the trick.
22:22:23 <newsham> (i also had to narrow down what i was building by getting rid of some local dirs that I had that were causing conflicts)
22:22:40 <newsham> this after getting a fresh ghc installed, without any of the haskell-platform
22:23:19 <newsham> cabal is neat, but in practice it has issues that need to be resolved.
22:23:28 <newsham> (not entirely cabal's fault, but none-the-less)
22:28:33 <pordan30> is there a standard name for folds that "consider" or "ignore" parts of a structure, for instance, here are a series of folds that "ignore" certain portions of a structure, followed by one that "considers" each portion. <http://lpaste.net/102408> another example would be the folds in the implementation, namely fold and foldWithKey in Data.Map
22:35:26 <carter> conal: are you building 7.8 or HEAD 7.9?
22:35:27 <carter> mac or not mac?
22:36:06 <conal> carter: HEAD 7.9. I've been failing on my attempts to install 7.8 RC1 and RC2.
22:36:14 <carter> conal: mac or not mac?
22:36:26 <conal> carter: mac.
22:36:27 <carter> cabal --version
22:36:49 <carter> you have an old haskell platform lying around as your prior ghc dont'cha?
22:36:53 <carter> gcc --version?
22:37:06 <conal> carter: "cabal-install version 1.16.0.2. using version 1.16.0 of the Cabal library "
22:37:09 <carter> ok
22:37:19 <carter> which cabal
22:37:23 <carter> "which cabal"
22:37:44 <conal> carter: /usr/bin/cabal
22:37:48 <carter> ok
22:38:04 <carter> would you like me to give you a cabal1.18 binary?
22:38:20 <carter> and a 7.8.1 binary?
22:38:22 <carter> hangon
22:39:27 <conal> carter: in my 7.8 attempts (rc1 & rc2), I got errors about missing dylibs.
22:39:46 <carter> conal: you don't use brew do you? :)
22:39:52 <carter> conal: you need to use cabal 1.18
22:39:57 <carter> lemme give you a link to a 1.18 binary
22:39:59 <conal> carter: i do use brew
22:40:03 <carter> ok
22:40:09 <carter> you don't have 1.18 cabal install though
22:40:15 <carter> which GHC 7.8 needs
22:40:23 <conal> carter: i do have a 1.18.0.3
22:40:29 <conal> cabal 1.18.0.3
22:40:33 <carter> nope, cabal --version says nope
22:40:34 <carter> :)
22:40:40 <conal> ... compiled with ghc 7.6.3, i think.
22:40:41 <carter> you need cabal-install 1.18 :)
22:40:58 <conal> carter: clarification: i *also* have cabal 1.18.0.3.
22:41:05 <carter> your ~/.cabal/config file is still 1.16 style
22:41:12 <conal> carter: and i get the same cabal install error with that executable
22:41:15 <carter> you need to delete it and let 1.18 cabal generate the same thing
22:41:16 <carter> ok
22:41:17 <carter> well
22:41:25 <conal> carter: oh!!
22:41:34 <conal> carter: how did you know?
22:41:35 <carter> first mv ~/.cabal/config ~/.cabal/config-OLD
22:41:50 <carter> because i'm the OS X support monkey for haskell
22:41:51 <carter> :)
22:42:06 <carter> also add ~/.cabal/bin to your path
22:42:20 <carter> if you didn't before
22:42:33 <carter> 7.8 NEEDS 1.18
22:42:37 <carter> and the associate defaults
22:42:48 <carter> which now mean everything is built both shared and static ways
22:43:00 <carter> conal: dling the link i pmd?
22:52:15 <Sgeo> Is plugins unmaintained these days?
22:58:29 <carter> jah
22:58:33 <carter> use ghc api :)
22:58:35 <carter> its pretty good
22:58:38 <carter> theres also hint
22:58:41 <carter> and a few oether tings
23:01:46 <Sgeo> What other things? And can hint use non-.hs files? As in, precompiled modules?
23:17:31 * hackagebot propellor 0.2.3 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.2.3 (JoeyHess)
23:44:04 <jle`> are the talks from popl out yet?
23:54:23 <zRecursive> :t (***)
23:54:24 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:57:36 * hackagebot hails 0.11.1.0 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.1.0 (DeianStefan)
