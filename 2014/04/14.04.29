00:04:15 * hackagebot reheat 0.1.5 - to make notes and reduce impact on idle time on writing other programms.  http://hackage.haskell.org/package/reheat-0.1.5 (palo)
00:08:38 * hackagebot hblas 0.3.0.0 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.0.0 (CarterSchonwald)
00:08:38 * hackagebot reheat 0.1.5 - to make notes and reduce impact on idle time on writing other programms.  http://hackage.haskell.org/package/reheat-0.1.5 (palo)
00:13:28 <johnw> I had no idea how much slower Data.Foldable.forM_ mx f is over case mx of Nothing -> return (); Just x -> f x
00:15:38 <carter> johnw: :)
00:16:04 <johnw> I spent 2 hours tracking down a 6x performance degradation over my base case... and half of it was simply that
00:18:51 <shachaf> Are you sure about that?
00:18:57 <johnw> yes, very sure
00:19:15 <shachaf> In the case that Maybe is known they compile into nearly the same thing.
00:19:20 <johnw> I was able to take a use of forM_, replace it with case, and then replace it back, and watched the timing change
00:19:43 <johnw> hmm.. maybe it's because I was actually using a lambda in the forM case?
00:19:51 <johnw> forM_ mx $ \x -> ...
00:20:58 <shachaf> Who knows. Come up with a small test case that reproduces it.
00:21:06 <johnw> good idea
00:22:11 <shachaf> The only difference, actually, is that forM_ x f turns into something like case x of Nothing -> return (); Just x -> f x >> return ()
00:22:31 <johnw> i'll let you know when i have real information (i.e., Core)
00:22:31 <shachaf> Which is to say that it doesn't reuse your ().
00:23:00 <shachaf> (Which it can't, with its type, because your function might not return a ().)
00:23:06 <johnw> right
00:57:38 <zipper> Can I get help on how to make the result of `Data.Text.Lazy.IO.readFile FilePath` a FormValue? FormValue is http://hackage.haskell.org/package/wreq-0.1.0.1/docs/Network-Wreq.html#t:FormValue the file and error are at https://gist.github.com/urbanslug/11393369
01:00:10 <johnw> you'll need to x <- readFile first, then use x
01:00:26 <johnw> and you'll need to do that inside another IO function
01:00:50 <johnw> you can't use IO in pure functions like you're trying to here
01:04:53 <zipper> johnw: I did in fact try that
01:05:22 <zipper> but that function seemed to return IO Text and not Text
01:05:34 <johnw> that's correct
01:05:45 <johnw> it has to be IO Text, otherwise where would it get the Text from?
01:06:07 <zipper> johnw: look at the function called fileReading
01:06:24 <zipper> johnw: but := wants Text
01:06:35 <johnw> you'll need to read the text elsewhere and then pass it in
01:07:22 <zipper> johnw: So the function fileReading was the right way to go?
01:07:40 <johnw> fileReading is identical to readFile itself
01:09:21 <zipper> johnw: Yeah :(
01:11:28 <zipper> johnw: So what you mean in "< johnw> you'll need to read the text elsewhere and then pass it in" is I need to convert IO Text into Text.
01:11:58 <johnw> you can't do that
01:12:14 <zipper> I can't?
01:12:21 <johnw> no, you can't
01:12:24 <awestroke> johnw: yes you can't
01:12:29 <awestroke> that's what the IO monad is all about
01:12:31 <johnw> but you can read a file within another IO function
01:12:35 <zipper> I was thinking of using an applicative but...
01:12:43 <johnw> that's why I said "x <- readFile ..." above
01:12:55 <awestroke> readFile >>= (function that takes a String as input)
01:13:43 <awestroke> >>= or "<-" notation "converts" IO to the underlying type and passes it into the function that wants to use it
01:13:44 <zipper> johnw: To use <- I need to use do and when I use do I can't use let for some reason
01:14:04 <awestroke> zipper: let ... in do ...
01:14:09 <shachaf> No it doesn't. :-(
01:14:23 <awestroke> shachaf: simplifications are useful
01:14:29 <awestroke> not correct
01:14:29 <shachaf> Not this one.
01:14:39 <shachaf> You can't "convert" IO Foo to Foo because they're completely different.
01:15:08 <zipper> awestroke: Let me show you the updated code
01:15:27 <awestroke> shachaf: unbox? unwrap? the meanings are similar enough to get the point across, and start building an understanding for what the IO monad is good for
01:16:05 <zipper> awestroke: https://gist.github.com/urbanslug/11393369
01:16:48 <shachaf> awestroke: Those words all have a similar meaning and that meaning is suggestive, appealing, and wrong.
01:17:34 <shachaf> @quote /bin/ls
01:17:34 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:17:54 <d1323> suggest a "correct" word then instead of just criticizing others
01:18:01 <awestroke> shachaf: how would you describe the concept of >>= so that it becomes accesible to somebody who doesn't yet grasp monads?
01:18:49 <awestroke> zipper: what's ":="?
01:18:53 <Maior> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html wfm
01:18:59 <Yuu_chan> zipper: according to the do-block, makeRequest must return IO [[FormParam]]
01:19:13 <shachaf> OK, that's enough. Have fun.
01:19:29 <Yuu_chan> shachaf: nice quote!
01:19:30 <Maior> :t (:=)
01:19:30 <lambdabot>     Not in scope: data constructor ‘:=’
01:19:30 <lambdabot>     Perhaps you meant one of these:
01:19:30 <lambdabot>       ‘:+’ (imported from Data.Complex),
01:21:04 <zipper> I've updated with a better positioned do
01:21:12 <Yuu_chan> awestroke: that's from the Network.Wreq probably. According to context, it adds a value to the parameter to form a request URL (like ?foo=bar&...)
01:21:26 <zipper> Network.Wreq.(:=)
01:21:31 <zipper> :t Network.Wreq.(:=)
01:21:32 <lambdabot> Not in scope: data constructor ‘Network.Wreq’
01:21:32 <lambdabot>     Not in scope: data constructor ‘:=’
01:21:32 <lambdabot>     Perhaps you meant one of these:
01:23:02 <zipper> Yuu_chan: I think I have that almost fixed now.
01:23:09 <zipper> Yuu_chan: in http://hackage.haskell.org/package/wreq-0.1.0.1/docs/Network-Wreq.html#t:FormValue
01:23:23 <zipper> Yuu_chan: I mean https://gist.github.com/urbanslug/f52a3f3c4a5c7a6012c3
01:23:56 <Yuu_chan> Oh, I wasn't able to find this package in hoogle o_O
01:24:40 <Yuu_chan> zipper: types are still wrong
01:25:44 <zipper>  (:=) :: FormValue v => C.ByteString -> v -
01:25:44 <Yuu_chan> „What happens in IO, stays in IO“.
01:25:46 <zipper> > FormParam where C is Data.ByteString.Char8
01:25:48 <lambdabot>  <hint>:1:11: parse error on input ‘where’
01:25:52 <johnw> Yuu_chan: :)
01:26:19 <zipper> awestroke: `(:=) :: FormValue v => C.ByteString -> v -> FormParam` where C is Data.ByteString.Char8
01:26:45 <zipper> Yuu_chan: I don't know how to get it out of IO
01:26:48 <Yuu_chan> zipper: you readFile in IO, but return pure FormValues.
01:26:56 <Yuu_chan> zipper: you shouldn't!
01:27:33 <Yuu_chan> A function that does input-output must return IO Something.
01:28:08 <zipper> So you're saying that makeRequest should return IO something?
01:28:25 <Yuu_chan> Yes, IO [[FormValue]], I suggest.
01:28:41 <Maior> zipper: do you understand how, because IO is a Functor and a Monad, you can use >>= and fmap to deal with "things 'inside' IO"?
01:28:54 <Maior> (where does makeRequest come from?)
01:29:02 <Maior> ah there
01:29:08 <Yuu_chan> I think mapM or forM fits well here
01:29:42 <Maior> zipper: yes if you want to be doing IO-y things inside makeRequest, makeRequest needs to return an IO-something
01:30:20 <Yuu_chan> Huh, is the second list (of Maybe String's) unused?
01:31:13 <Maior> `ghc-options:         -Wall -Werror -fno-warn-missing-signatures` ;)
01:31:56 <Maior> (I do need to learn a way to selectively disable some of that though; warning on unused things is annoying sometimes during development)
01:33:48 <zipper> Yuu_chan: It will be used.
01:34:04 <Yuu_chan> So it could be smth like formRequest length files = forM files $ \file -> do {contentsAsText <- Q.readFile; return [toByteString <...>]}
01:34:48 <Yuu_chan> :t forM
01:34:49 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
01:35:44 <Yuu_chan> Foreach a from [a], forM does the monadic computation a -> m b and gathers all results into single m [b]
01:36:51 <Yuu_chan> In your case a is FilePath, m is IO and b is [FormParam]
01:46:23 <zipper> Yuu_chan: Won't that break recursion?
01:46:45 <zipper> Oh forM
01:49:54 <Yuu_chan> zipper: break where?
01:50:30 <Yuu_chan> You don't really need an explicit recursion here, this is a common map-like pattern, after all
01:51:02 <haskellephant> anyone else excited about overloaded record fields?
01:52:07 <awestroke> haskellephant: wat
01:52:40 <srhb> Definitely :)
01:53:13 <merijn> awestroke: OverloadedRecordFields is the work-in-progress extension to allow multiple records to have a field with the same name
01:53:41 <awestroke> merijn: so the currect field is inferred by type?
01:53:44 * hackagebot nanospec 0.2.0 - A lightweight implementation of a subset of Hspec's API  http://hackage.haskell.org/package/nanospec-0.2.0 (SimonHengel)
01:53:48 <awestroke> correct*
01:55:07 <Yuu_chan> Will it be way better than DisambiguateRecordFields?
01:55:25 <merijn> awestroke: It's not quite type directed name lookup
01:56:05 <merijn> awestroke: I think it's more like builtin compiler support for having a "class HasX a b | a -> b where getX :: a -> b"
01:56:55 <merijn> See https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
01:59:37 <zipper> Yuu_chan: To be honest I didn't get your version. However I wrote both of them and sadly none of those work. Here https://gist.github.com/urbanslug/f52a3f3c4a5c7a6012c3
01:59:51 <zipper> s/get/understand/
02:01:31 <Yuu_chan> zipper: when a do-block is written in 2d syntax, both parentheses and semicolons are omitted
02:02:35 <haskellephant> merijn: I think the HasX type class is somewhat more complicated isnt it?
02:06:38 <zipper> Yuu_chan: Well now it works rookie mistake. Worst part is I don't know how to get the [[FormParam]] off it. I will try use <- in the send function.
02:08:15 <zipper> I mean out of it
02:11:00 <Yuu_chan> zipper: send probably works in IO itself (it sends data, after all)
02:12:15 <merijn> haskellephant: This was more of a "rough example to guide intuition" than a "this is what it actually does" kind of example :)
02:12:19 <Maior> a/win 49
02:12:21 <Maior> sorry
02:12:46 <haskellephant> merijn: Of course =D
02:13:04 <haskellephant> merijn: But I was surprised at how complicated the type became in the end
02:13:26 <zipper> Yuu_chan: I wrote send maybe you mean post?
02:14:43 <merijn> haskellephant: Well, mine was just a getter, what ORF tries to do is also allow setters and then it becomes more complex to do polymorphic update (compare data-lens' inability to do polymorphic update vs lens' ability to do so)
02:15:13 <Yuu_chan> zipper: dunno, your code isn't accessible anymore
02:15:49 <nschoe> hi everyone, I'm running into a little problem. I used DeriveGeneric extension, made my type deriving (Show, Eq,Generic) and then wrote "instance Binary MyDataType" but I get a runtime error : "No instance nor default method for class operation Data.Binary.put". Am I missing something here ? I thought GHC could automatically derive an instance for Data.Binary ?
02:16:00 <merijn> haskellephant: Let's use tuples as a simple example, suppose I have "x :: (Int, Char)" and I want to update the first field of the tuple to be Bool, a simple "class HasX a b | a -> b where updateX :: b -> a -> a" won't work
02:16:42 <merijn> Because "updateX True (1, 'c')" should return (Bool, Char), not (Int, Char)
02:17:09 <haskellephant> merijn: That is true.
02:18:20 <merijn> So it'd become like "class (a b ~ c) => HasX a b c where getX :: c -> b; updateX :: x -> c -> a x; modifyX :: (b -> x) -> c -> a x" or whatever
02:18:45 <zipper> Yuu_chan: Sorry about that https://gist.github.com/urbanslug/11394924 post takes [FormParam]
02:19:56 <merijn> nschoe: The Data.Binary docs refer to the GBinary class for Generic derivation
02:20:00 <haskellephant> merijn: But SPJs SORF proposal was a lot easier to understand than the current design document, at least in terms of the type classes generated.
02:20:17 <zipper> Yuu_chan: No it takes wreq-0.1.0.1:Network.Wreq.Internal.Types.Postable
02:21:24 <merijn> haskellephant: Perhaps, on the other hand the more complex proposal allows various lens implementations to do more fancy things "automatically" without using TH
02:21:51 <haskellephant> merijn: That is definitly an all round win.
02:21:55 <nschoe> merijn, yes I saw that, but further down in the page : hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html under the paragraph "Generic Support" they show a simple way for Foo and this doesn't work with my data type.
02:22:03 <nschoe> merijn, But I'm looking in GBinary right now
02:22:46 <merijn> nschoe: Well, you'd need to do "instance GBinary MyDataType" instead of "instance Binary MyDataType"
02:23:07 <nschoe> merijn, ah ? Okay I'll try this then. Thanks !
02:23:18 <merijn> nschoe: Wait, maybe not
02:23:24 <merijn> nschoe: What's your actual datatype?
02:23:58 <Yuu_chan> zipper: Ew. Who calls send?
02:24:05 <nschoe> merijn, this is my actualy data type : http://lpaste.net/103338
02:25:02 <merijn> nschoe: Well, are UserName, HashPassword and ContactList all either 1) Binary instance or 2) Generic instances?
02:25:17 <zipper> Yuu_chan: LOL
02:25:28 <merijn> nschoe: If not, how did you expect GBinary to magically determine a serialisation for those types? :)
02:26:20 <zipper> Yuu_chan: I am not sure yet. I wrote the functions first and wanted to make sure they work independently.
02:26:22 <nschoe> merijn, yes sorry, shoudl have mentionned that. UserName is just a String, HashPAssword is just a ByteString and ContactList is [Contact] where Contact I used deriving (Generic) and instance Binary Contact
02:26:53 <Yuu_chan> zipper: so send should take pure arguments, not IO actions that compute them
02:27:01 <merijn> hmm, that'd odd then. Hard to say without seeing the exact error for the entire code
02:28:38 <Yuu_chan> send :: [[FormParam]] -> IO ()
02:28:38 <Yuu_chan> formRequest :: Int ->  [FilePath] -> [Maybe String] -> IO [[FormParam]]
02:28:38 <Yuu_chan> then they could be chained in some another function with >>= or do-block
02:29:04 <nschoe> merijn, http://lpaste.net/103338 : I updated the lpaste so that I can show you the relevant part of the code
02:30:07 <nschoe> merijn, and when I compile, I get the following warning :  No explicit method or default declaration for `put'    In the instance declaration for `Binary Contact'
02:32:41 <zipper> Yuu_chan: Thanks. I will try use (>>=) do blocks are from hell
02:32:45 <nschoe> merijn, I'm sorry I think I messed things up. While checking my .cabal file it seemed I was linking against an olv version (0.5) of the binary package
02:33:01 <merijn> nschoe: It happens :)
02:33:09 <zipper> Yuu_chan: I have read on monads on typeclassopedia and LYAH but still IO is an issue
02:33:09 <nschoe> I just changed to binary >=0/7 then used cabal install --dependencies-only and it worked perfectly.
02:33:18 <nschoe> Sorry for the disturbance and thanks for the help ;)
02:33:36 <zipper> Yuu_chan:  and so are do blocks and (>>=) when it comes to actually applying this knowledge
02:34:48 <zipper> hahaha I have so many imports in that code it makes me want to slit my wrists.
02:50:04 <augur> goodness
02:50:09 <augur> $7mil for HoTT
02:50:19 <augur> what will they spend it all on???
02:50:24 <haskellephant> @let peopleExcitedForOverloadedRecordFields = [merijn,haskellephant]
02:50:25 <lambdabot>  .L.hs:141:43: Not in scope: ‘merijn’
02:50:25 <lambdabot>  
02:50:25 <lambdabot>  .L.hs:141:51: Not in scope: ‘haskellephant’
02:50:40 <haskellephant> @let peopleExcitedForOverloadedRecordFields = ["merijn","haskellephant"]
02:50:41 <lambdabot>  Defined.
02:50:53 <exicer> If I'm using Aeson and Lens, is there some way I can have makeLenses and the automatically derrived JSON instances work together (e.g. the json instances don't have _recordname) ?
02:51:11 <exicer> or do I have to do it manually ?
02:53:01 <supki> exicer: no, the rules for makeLenses are hardcoded
02:53:17 <supki> exicer: but see makeLensesWith and lensField
02:55:15 <exicer> supki: I guess I actually want the default lens behaviour, but would like aeson to ignore the _, but I would rather not have to manually declare every to/fromJSON instance
02:58:52 * hackagebot snap-cors 1.2.4 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.4 (OliverCharles)
03:03:53 <Yuu_chan> zipper: by the way, you can import different modules into a single "namespace"
03:04:29 <Reite> exicer, I usually use Aeson.TH to derive the instances, something like: $(deriveJSON defaultOptions{fieldLabelModifier = drop 1} ''MyType)
03:05:44 <exicer> Reite: Oh, that looks like what I want. Cool, cheers.
03:13:25 <zipper> augur: HoTT?
03:13:29 <zipper> Yuu_chan: What do you mean?
03:13:47 <augur> zipper: Homotopy Type Theory
03:15:31 <Yuu_chan> zipper: I mean that it could be more convenient to import related modules with a same prefix.
03:21:04 <Cale> augur: People for the most part, I hope
03:21:56 <augur> Cale: thats a lot of people
03:22:14 <augur> thats >100 people at US GDP per capita for a year
03:22:23 <zipper> Yuu_chan: For something like a pastebin it's better to use text and not bytestring, right?
03:22:28 <Cale> Or a few people over a more significant amount of time :)
03:23:37 <Cale> augur: Voevodsky was talking about the need for money to spend on development of proof assistants
03:23:48 <Cale> augur: in his talk the other week
03:24:36 <zipper> Is the next haskell cast about to be out yet?
03:26:12 <augur> Cale: lots of people for a long time :o
03:26:22 <augur> 10 people for 10 years!
03:27:17 <zipper> Are programmers likely to be in the upper part of the American middle class?
03:27:38 <zipper> Sorrry wrong channel
03:27:53 <augur> lol
03:28:58 * hackagebot http-kit 0.2.2 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.2.2 (SimonHengel)
03:29:16 <Maior> (quite unlikely, but maybe less unlikely for American programmers)
03:29:45 <augur> Maior: -blah
03:33:24 <zipper> I'm starting to think that maybe GetOptSimple was the wrong thing to use.
03:33:52 <zipper> s/GetOptSimple/GetOpt-Simple
03:34:10 <zipper> http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
03:38:15 <identity> zipper: take a look at cmdargs.
03:38:40 <Yuu_chan> zipper: right, ByteString shouldn't be used for text (unless you REALLY know what you're doing). We don't want unicode problems i n 2014.
03:40:31 <identity> > peopleExcitedForOverloadedRecordFields
03:40:33 <lambdabot>  ["merijn","haskellephant"]
03:41:04 <identity> I want this as well
03:42:22 <haskellephant> >peopleExcitedForOverloadedRecordFields
03:42:27 <haskellephant> > peopleExcitedForOverloadedRecordFields
03:42:29 <lambdabot>  ["merijn","haskellephant"]
03:43:05 <zipper> Yuu_chan: Luckily I used text to read it! w00t!
03:43:17 <haskellephant> @let peopleExcitedForOverloadedRecordFields = ["identity",merijn","haskellephant"]
03:43:17 <lambdabot>  Parse failed: Improperly terminated string
03:43:35 <haskellephant> @let peopleExcitedForOverloadedRecordFields = ["identity","merijn","haskellephant"]
03:43:36 <lambdabot>  .L.hs:143:1:
03:43:36 <lambdabot>      Multiple declarations of ‘peopleExcitedForOverloadedRecordFields’
03:43:36 <lambdabot>      Declared at: .L.hs:141:1
03:43:36 <lambdabot>                   .L.hs:143:1
03:43:52 <haskellephant> @unlet peopleExcitedFOrOverloadedRecordFields
03:43:52 <lambdabot>  Parse failed: TemplateHaskell is not enabled
03:43:56 <zipper> but post wants the first arg of (:=) to be strict bytestring
03:44:01 <zipper> Yuu_chan: ^
03:44:15 <identity> @let peforf = peopleExcitedForOverloadedRecordFields
03:44:16 <lambdabot>  Defined.
03:44:18 <haskellephant> @undef peopleExcitedFOrOverloadedRecordFields
03:44:19 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
03:44:30 <haskellephant> ahh damn
03:44:31 <identity> @let peforf = "identity" : peforf
03:44:31 <lambdabot>  .L.hs:144:1:
03:44:32 <lambdabot>      Multiple declarations of ‘peforf’
03:44:32 <lambdabot>      Declared at: .L.hs:143:1
03:44:32 <lambdabot>                   .L.hs:144:1
03:44:42 <haskellephant> @undefine
03:44:42 <lambdabot> Undefined.
03:44:45 <haskellephant> @let peopleExcitedForOverloadedRecordFields = ["identity","merijn","haskellephant"]
03:44:47 <lambdabot>  Defined.
03:45:14 <nclarke> > head peopleExcitedForOverloadedRecordFields
03:45:16 <lambdabot>  "identity"
03:45:18 <merijn> Is there a way to depend on "whatever Cabal version cabal-install uses"?
03:46:22 <Yuu_chan> zipper: ;)
03:46:24 <haskellephant> I think the lambdabot define plugin needs a redesign
03:46:41 <merijn> I was hoping to just include a "Distrbution.Simple.Program.Foo" module which has the relevant UserHooks for my preprocessor and have people link that into their Setup.hs, but if that module is linked against the wrong Cabal version, it refuses to build...
03:47:04 <merijn> haskellephant: Why?
03:47:19 <haskellephant> @undefine peopleExcitedForOverloadedRecordFields
03:47:19 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
03:47:37 <haskellephant> That thing
03:47:40 <merijn> I think that's a feature, not a bug ;)
03:47:46 <haskellephant> he he he
03:47:53 <merijn> Stops people from cluttering it up with tons of defines
03:48:42 <zipper> haskellephant: Well I can't get lambdabot to find what I want.
03:48:43 <nclarke> No reason you couldn't have a blanket @undefine as well
03:49:11 <haskellephant> zipper: what do you want?
03:50:38 <benj_> is there any way to put a set of GHC arguments in a conf file in a user's home directory, and have them automatically used for every ghc run?
03:50:59 <haskellephant> benj_: there is the .ghci file at least.
03:51:11 <merijn> benj_: This sounds like you should be switching to cabal for your GHC code and put the flags in the .cabal file
03:51:49 <benj_> merijn, I don't want these options to be forced on other users of the project. They are specific to a particular machine.
03:52:40 <benj_> i.e. a machine with limited memory, where GHC often runs out of memory when building large packages
03:53:48 <benj_> passing --ghc-options="+RTS -M1G -RTS" avoids this problem, but it's a chore having to use this all the time, and sometimes I forget, so a project gets nearly built before crashing out
03:54:00 <merijn> ~/.cabal/config ?
03:55:11 <identity> benj_: you could replace ghc in your path with a shell script using the options you desire plus everything else that gets passed to it
03:55:31 <identity> I was going to say alias, but that wouldn't work with cabal
03:55:43 <benj_> identity, I might do that, thanks
03:56:57 <zipper> :t Data.Bytestring.Lazy.IO.readFile
03:56:58 <lambdabot> Not in scope: ‘Data.Bytestring.Lazy.IO.readFile’
03:57:13 <benj_> merijn, thanks, I wasn't aware of that. But it would be nice for it to work for all invocations of ghc, not just via cabal
04:00:11 <merijn> benj_: Then the only thing I can think of is 1) mak ghc a shell script that calls actual GHC with the right options or 2) make GHC an alias
04:00:29 <benj_> yeah I think I'll go with the shell script, thanks
04:01:30 <benj_> interestingly I also have a machine with even less memory (a 5-year-old netbook) which compiles anything, albeit slowly, without issue
04:02:26 <merijn> I remember this link that had a list of "constraint: Parsec installed", etc. for all Platform packages. Any clue where I can find that again?
04:09:33 <osa1_> is there a name given to values that are pattern matched?
04:10:45 <pjdelport> bindings, perhaps?
04:13:45 <osa1_> yeah I saw that term used but I also remember seeing something like "scrutinee" but I'm not even sure if that's valid English word...
04:13:57 <osa1_> (trying to write some documentation but couldn't find what term to use)
04:20:56 <pjdelport> scrutinee sounds like something from a more specific context
04:29:16 <identity> auto away features like that are rather annoying.
04:29:59 <NinjaPenguin> Indeed.
04:38:15 <Algebr> I'm finally getting to the point where I'm not fighting the type system but rather its guiding me to solutions.
04:40:50 <pjdelport> Welcome to type club.
04:41:10 <Axman6> SSHHHHHHH!
04:41:11 <Algebr> pjdelport: Yes, its making me like Python less and less.
04:41:41 <pjdelport> Algebr: Your Python is probably going to become more and more Haskell-flavored.
04:42:16 <Maior> Algebr: I know that feeing!
04:42:19 <Maior> +l
04:43:07 <Algebr> Probably the most common haskell rooted feeling I get when working with Python now is: WHY DID THIS EVEN COMPILE??
04:43:19 <a3gis> eheh
04:43:27 <nicferrier> quick question #haskellers
04:43:29 <a3gis> and in javascript it's: WHY DID THIS EVEN RUN?
04:43:38 <Algebr> haha
04:43:42 <nicferrier> is a haskell compiler required by any sort of language spec to implement tco?
04:43:56 <Axman6> I don't believe so
04:44:13 <merijn> nicferrier: No, but note that tail call optimisation is not as amazing in haskell as in other languages
04:44:29 <Algebr> merijn: What languages is it amazing in?
04:44:38 <merijn> nicferrier: It helps in some cases, but some blatantly non-tail recursive functions still have constant stack usage
04:44:46 <tdammers> Algebr: strict ones :D
04:44:55 <merijn> Algebr: Scheme manadates it so that recursive loops use constant stack space
04:45:29 <merijn> nicferrier: In fact, note that GHC's Haskell implementation does not have a call stack at all. Therefore recursive functions can't overflow the call stack
04:45:37 <tdammers> basically, if you want recursion-heavy code with strict evaluation, TCO is pretty much mandatory
04:46:00 <merijn> (There are other stacks you *can* overflow in GHC, but those are not directly caused by tail-recursion vs non-tail recursion)
04:46:04 <nicferrier> thanks
04:46:15 <nicferrier> I guess lazyness obviates the need. didn't think of that.
04:46:22 <nicferrier> helpful as ever #haskell - thank you
04:46:42 <merijn> nicferrier: Consider "map f (x:xs) = f x : map f xs", this would be terrible in a strict language
04:47:03 <merijn> nicferrier: In haskell this returns immediately because "x : y" is in WHNF
04:47:17 <buckmaster> Algebr: now I roll my eyes when reading Python documentation that has to specify the types of functions :P
04:47:57 <merijn> nicferrier: Well, in some cases tail recursion can make code more efficient by avoiding large thunk buildups
04:47:59 <nicferrier> merijn: of course. spot on. didn't think of that before I asked.
04:48:39 <Algebr> ha. Question, any software out there that I can run on library and it generates a pdf with graphs of the inheritances of typeclasses/
04:50:11 <f-a> hello. Longshot, but let me try: I recall I read some time ago an article on how, in the beginning, "record access" wasn't even meant to be included. Do you recall reading something similar? And most importantly, where?
04:50:42 <Fernandos> hi
04:51:32 <Fernandos> In what other languages can I convert/transpile Haskell code to? And which of these is still readable?
04:51:59 <f-a> I am pretty sure you can haskell -> js, no idea how readable is that, Feuerbach_
04:52:17 <merijn> Fernandos: JS, C and LLVM, probably unreadable in all cases
04:52:30 <Fernandos> I have read about jhc which allows to convert to C, but I never tried that. NO experience with it. Would like to learn from you experts =)
04:53:22 <f-a> UHC does that too, again, I think no one claims "readability" as a feature
04:54:30 <Maior> but source maps exist
04:54:30 <davean> I found Fay fairly readable
04:54:36 <Maior> and I think ghc jenerates them
04:54:38 <Maior> ...generates
04:54:41 <Maior> *ghcjs
04:54:44 <Maior> brain, sorry
04:56:33 <thrustfault> Could someone help me understand this list implementation
04:56:35 <thrustfault> data List a = Nil | a ::: List a
04:56:52 <thrustfault> I can;t figure out the purpose of :::
04:57:00 <c_wraith> thrustfault: it's the name of the constructor
04:57:02 <lieven_> it's just an operator
04:57:16 <thrustfault> ::: denotes the name of a constructor?
04:57:21 <haasn> @let data List a = Nil | a ::: List a
04:57:22 <Fernandos> davean: Fay??
04:57:23 <lambdabot>  Defined.
04:57:24 <haasn> :t (:::)
04:57:24 <lambdabot> a -> List a -> List a
04:57:29 <lieven_> they could have used data List a = Nil | Cons a (List a)
04:57:31 <c_wraith> thrustfault: just like Nil is the name of a constructor
04:57:33 <fizruk> data List a = Nil | a `Cons` List a
04:57:44 <thrustfault> ah ok, that makes sense
04:57:45 <haasn> or data List a = Nil | a :+-*%~ List a
04:57:55 <thrustfault> thnks for your help guys, that was impossible to google/hoogle for
04:58:13 <haasn> Note: constructors in operator form start with :
04:58:14 <davean> Fernandos: https://github.com/faylang/fay/wiki
04:58:18 <haasn> that's the operator equivalent of “a capital letter”
04:58:32 <haasn> Beyond that, you can use operator symbols you want, eg. ::: perfectly valid
04:58:39 <haasn> or :+
04:58:43 <thrustfault> interesting
04:59:01 <haasn> An analog to name-based operators would be “NNN” and “Nil”
04:59:20 <haasn> Both perfectly valid names
05:33:09 <ocharles> Can anyone see a way to get the following code to *NOT* type check?
05:33:13 <ocharles> https://www.irccloud.com/pastebin/6JC43jAV
05:33:46 <ocharles> Note how on the last line I use "_Greet" in "Two", but "Two" should be restricting the context to be `Increment e => ...` which shouldn't let me use _Greet
05:33:53 <f-a> doesn't show to me, ocharles
05:33:57 <f-a> oh, now it does
05:34:01 <ocharles> I can see why it does - the top level type fixes e to be Either String Int, which has instances of both type classes
05:34:31 <ocharles> What I'm looking to do is have a restricted context in each GADT pattern match, but have a catch-all type for the top level
05:34:38 <ocharles> cc edwardk who suggested this in the first place :)
05:35:10 <ocharles> I feel like there's some sort of higher rank trick that I can play, but I can't see it
05:36:31 <ocharles> Just putting a type on go doesn't work, because I'd have to mention all possible type classes, which is unworkable
05:38:46 <Fuco> hmm, I'm reading a SO post, and they compare 'StateT s IO' with 'ReaderT (IORef s) IO'... is there any particular reason why I should use the second?
05:39:03 <Fuco> seems to me I won't gain much, and instead I'd have to "readIORef . ask" to get the data
05:39:47 <Lethalman> Fuco, I usually put reader first, because it's easier to call ReaderT functions that do not need to modify the state
05:40:33 * Lethalman read it wrong
05:43:56 <olalonde> hi all.. haskell noob. I was reading https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json and came across this notation which I had never seen before "firstName  :: !Text" what is the ! before Text?
05:44:17 <Fuco> it makes the thing strict
05:44:27 <merijn> olalonde: ! stands for a strict field
05:44:54 <merijn> olalonde: To have a simpler example "data Foo = Foo Int" and "data Bar = Bar !Int"
05:45:13 <olalonde> oh at least i can google that now :P
05:45:31 <merijn> olalonde: If you write "Foo (1+1)" then haskell will evaluate this to "Foo <thunk for 1+1>", i.e. the 1+1 is not yet computed (laziness and all that)
05:45:54 <olalonde> merijn: right
05:45:58 <merijn> olalonde: However, "Bar (1+1)" will evaluate to "Bar 2", i.e. the 1+1 is evaluated immediately
05:46:08 <olalonde> ah ok, understood
05:46:17 <a3gis> merijn: what is a standard usecase for this?
05:46:40 <bennofs> @let data Foo = Foo Int
05:46:42 <lambdabot>  Defined.
05:46:42 <olalonde> I'm not sure what it would mean for a Text type to be lazy evaluated though..
05:46:47 <bennofs> @let data Bar = Bar !Int
05:46:48 <olalonde> maybe it helps with performance?
05:46:48 <lambdabot>  Defined.
05:47:02 <merijn> a3gis: Avoiding huge buildup of thunks
05:47:11 <ocharles> Hmm, I wonder if Data.Constraint will let me do what I want
05:47:14 <merijn> > foldl (+) z [1..5]
05:47:15 <lambdabot>  z + 1 + 2 + 3 + 4 + 5
05:47:29 <pjdelport> olalonde: It's a trade-off; sometimes strictness is better, sometimes laziness is better.
05:47:53 <merijn> a3gis: That does "(z + 1)" which is not evaluated, but gets used as argument in the thunk "(z + 1) + 2", etc.
05:48:01 <vanila> I was wondering, what are the main advantages of lazy programming?
05:48:01 <pjdelport> It affects performance, but also your ability to work with undefined / bottom values.
05:48:23 <merijn> a3gis: So you build up a huge lists of thunks which you then need to evaluate at the end (effectively causing linear growth in space consumed)
05:48:24 <vanila> I read on auguustuss blog that reusable (higher order) functions is one main reason
05:48:36 <a3gis> right, that makes sense
05:48:48 <merijn> a3gis: Using a struct datatype for the sum would cause the + to be immediately collapsed, using O(1) space
05:48:57 <vanila> but what else would be most useful about lazy evaluation?
05:49:19 <a3gis> vanila: infinite data structures?
05:49:21 <pjdelport> vanila: Lazy / non-strict evaluation lets you represent more things. Infinite lists are a common example.
05:50:30 <a3gis> @let fib = 0 : 1 : zipWith (+) fib (tail fib)
05:50:31 <lambdabot>  Defined.
05:50:36 <a3gis> > take 10 fib
05:50:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
05:50:59 <pjdelport> Algorithms with lazy evaluation can be faster, when the lazy evaluation avoids doing unnecessary work (but also sometimes slower, if the overhead of delaying evaluation is greater).
05:51:06 <vanila> I feel likr that's not such a big deal, it is very nice and easy to do in haskell - but I can build streams and things just the same with a bit o extra work in strict language (as long as they have lambda)
05:51:15 <mr-> vanila: another cool application can be found in cabal: The dependency solver builds a _huge_ dependency-tree (won't ever fit in memory), lazily, prunes and searches it. All in _seperate_ stages. No convoluted mess of doing everything at once.
05:51:43 <vanila> mr- oh that is very impressive actually
05:51:46 <pjdelport> Lazy evaluation can write things  more expressively; for example, you can define "if" as a plain function in Haskell, and not worry about both branches being evaluated.
05:52:41 <pjdelport> vanila: strict languages commonly have lazy streams, but with Haskell you get the same benefits for everything (like lazy trees, lazy strings, etc.)
05:52:42 <mr-> vanila: the code for that really then is something like solution = searchTree . pruneTree . applyPreferences . buildTree
05:52:59 <vanila> wow :D
05:53:55 <a3gis> vanila: well essentially parameterless lambdas are thunks (and that's the way lazyness works in haskell afaik) so yep, you can do the same in most languages, but in haskell it's built-in
05:54:16 <vanila> I see!
05:54:46 <ocharles> https://stackoverflow.com/questions/23365220/how-can-i-use-restricted-constraints-with-gadts if anyone wants to get some lovely SO points :)
05:55:01 <bennofs> ocharles: what do you want to do? Right now, the instance is separate from the GADT. In fact, your example even compiles if you remove the constraints from your GADT
05:55:05 <pjdelport> vanila: The trade-off is basically between having non-strictness by default, with explicit strictness (like Haskell), or having strictness by default, with explicit non-strictness (like Scheme or whatnot).
05:55:13 <ocharles> bennofs: exactly, and that's a problem
05:55:38 <ocharles> bennofs: In each pattern matching, I want to only have access to the context I learn about by knowing which constructor I'm at
05:56:01 <a3gis> vanila: pjdelport: in Scala for example you have lazy vals and call-by-name parameters
05:57:10 <f-a> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf (found my answer, if someone was interested)
05:57:28 <ocharles> bennofs: The final type needs to provide an instance for *all* possible constraints though, and I don't want to have to manually type all the constraints out again
05:59:15 * hackagebot haskintex 0.5.0.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.5.0.0 (DanielDiaz)
06:01:29 <ocharles> bennofs: the difficult thing is that I can't put the information of the constraint in the type of the GADT itself, because then I can't use it in a free monad
06:01:43 <pjdelport> f-a: What was your question?
06:03:52 <f-a> pjdelport: I read somewhere that record-syntax wasn't planned in the beginning of haskell and it was implemented only because of external pressure. I wanted to recall where I read it (to see if the author went deeper on how to write haskell programs sans record syntax). Alas, there are only a few lines on the matter (section 5.6).
06:04:20 <vanila> are records problematic in some ways?
06:05:07 <f-a> unfortunately, yes
06:05:40 <f-a> apparently, record updating is not first class
06:06:46 <nisstyre> f-a: they probably never published anything because they *knew* it sucked
06:06:49 <vanila> hmm
06:07:08 <vanila> can't you just do \x -> <record update>
06:07:14 <vanila> to get it as a first class value?
06:07:19 <nisstyre> yeah
06:07:24 <nisstyre> that's clunky
06:07:37 <nisstyre> and then generalize it to nested updates
06:07:38 <vanila> I guess the whole point of the syntax is to be shorter, so that defeats the purpose
06:07:41 <nisstyre> even more clunky
06:08:16 <tdammers> let fooNew = foo { fooSomething = fooSomething foo + 1 }
06:08:17 <tdammers> ugh
06:08:31 <f-a> I guess that's why lenses were invented/developed
06:08:33 <tdammers> yes
06:08:41 <tdammers> lenses solve this, sort of
06:09:03 <f-a> I know I am being ungrateful, but I would like something which does not requires template haskell in the future
06:09:16 <tdammers> I think that's a reasonable wish
06:09:25 <tdammers> also, lens is a rather large library
06:09:26 <vanila> oh so the lenses can't actually be one entirely in pure haskell?
06:09:29 <f-a> (because I could not compile on my old machine)
06:09:52 <tdammers> vanila: they can, but then you have to provide lenses for all your record types by hand
06:09:59 <f-a> I guess creating those Lenses manually is tiresome
06:10:04 <f-a> and quite boilerplatish
06:10:08 <tdammers> yeah
06:10:11 <vanila> I was wondering, instead of template haskell - what if there was a way to implement your own "deriving"'s
06:10:23 <nisstyre> f-a: you get to experience what people like Isaac Newton and co. did though
06:10:24 <vanila> like maybe it provides with an broken down form of the data type to work with
06:10:33 <vanila> would this be enough to implement lenses?
06:10:42 <tdammers> I think there is a way, I think
06:10:49 <tdammers> Aeson uses it
06:10:50 <f-a> indeed indeed nisstyre
06:10:55 <tdammers> something about Typeable
06:10:56 <d1323> vanila, lenses are written in pure haskell, template haskell use is optional
06:11:10 <tdammers> I don't know enough about that to form an educated opinion though
06:11:15 <vanila> okay
06:11:17 <f-a> d1323: I guess that's not optional in 'real life'
06:11:28 <vanila> but there's some kind of boilerplate right?
06:11:34 <f-a> (as in, creating instances for biggish types)
06:11:39 <dabelingHaskell> Hi there, I want to split a string on whitespace, how do I do that in haskell?
06:11:40 <quchen_> tdammers: Generics are typically used for that.
06:11:49 <vanila> > words "a b c"
06:11:50 <lambdabot>  ["a","b","c"]
06:11:52 <Iceland_jack> dabelingHaskell: words
06:11:53 <f-a> dabelingHaskell: words?
06:11:54 <nisstyre> lense generation code should be called Grinder
06:11:57 <Iceland_jack> @ty words
06:11:58 <lambdabot> String -> [String]
06:12:05 <dabelingHaskell> thanks!
06:12:12 <edwardk> nisstyre: grindLenses ''Foo
06:12:14 <edwardk> =)
06:12:18 <quchen_> @hoogle String -> [String]
06:12:20 <lambdabot> Prelude lines :: String -> [String]
06:12:20 <lambdabot> Data.List lines :: String -> [String]
06:12:20 <lambdabot> Data.String lines :: String -> [String]
06:13:02 <f-a> still, I wonder what the original plan was (as in, how to overcome the lack of record syntax)
06:13:24 <f-a> or maybe it was just a "we haven't figured out an elegant solution yet"
06:13:52 <tdammers> quchen_: yeah, that was it
06:15:21 <bennofs> ocharles: would this work? http://lpaste.net/ note that I had to generalize the type of run, and for some reason I also had to lift out the go function
06:15:24 <vanila> is there such a thing as a telescope?
06:15:42 <bennofs> vanila: you mean 'Optic'?
06:15:44 <ocharles> bennofs: hard to say, given that link
06:15:45 <ocharles> ;)
06:15:52 <bennofs> ocharles: oops sorry
06:16:01 <bennofs> ocharles: http://lpaste.net/103340
06:16:45 <ocharles> bennofs: Does that type check if you change line 28 to be _Increment?
06:16:52 <ocharles> I would imagine now neither of them type check
06:16:57 <bennofs> ocharles: yes it does
06:17:01 <ocharles> Hmmm
06:17:14 * ocharles tries that
06:18:16 <quchen_> tdammers: There's a recent talk by Andres Löh about Generic, it's pretty good
06:18:38 <quchen_> So if you're unclear about what they do then maybe give that a shot. (It's not only useful, but also interesting.) :-)
06:19:17 <Iceland_jack> quchen_: Is the talk available online?
06:19:22 <ocharles> bennofs: Oddly you now can't write: go :: GADT e a -> Either String Int; go = run
06:19:36 <tdammers> quchen_: certainly will. It's not high on my priority list, because I haven't found the need so far, but was going to read up on that stuff eventually
06:19:39 <ocharles> doh, of course you can't
06:19:45 <bennofs> ocharles: yeah, you cannot fix e
06:19:49 <ocharles> Hm
06:19:57 <ocharles> I need to eventually provide e
06:20:02 <ocharles> obviously :)
06:20:40 <quchen_> Iceland_jack, tdammers: https://skillsmatter.com/skillscasts/3932-a-haskell-lecture-with-leading-expert-andres-loh
06:20:48 <Iceland_jack> thanks :)
06:21:00 <tdammers> quchen_: thx
06:21:13 <ocharles> :t run (One "Hello")
06:21:13 <ocharles> run (One "Hello") :: Greet e => e
06:21:14 <lambdabot>     Not in scope: ‘run’
06:21:14 <lambdabot>     Perhaps you meant one of these:
06:21:14 <lambdabot>       ‘un’ (imported from Control.Lens),
06:21:15 <ocharles> that's kinda cool
06:21:19 <ocharles> shush lambdabot
06:21:41 <dabelingHaskell> another dumb question: if i have my splitstirng via: let x=words "aa b ccc d"   ; How do I print all the split strings, this doesnt seem to work? :  map putStrLn x
06:21:55 <vanila> you need to use mapM_ because it's a monad function
06:22:06 <vanila> (the _ means you throw away the result)
06:22:22 <bennofs> ocharles: well, you could make run be of type GADT (Either String Int) a -> Either String Int and only have go be fully polymorphic
06:24:26 <dabelingHaskell> apparently mapM_ did the trick :D
06:25:45 <quchen_> There is no way to prioritize Haskell threads somehow, is there? For example if I want to have a cleanup function that should only run when there's not much load
06:26:10 <pjdelport> dabelingHaskell: note that mapM_ is just a shortcut for sequence_ . map
06:26:22 <quchen_> mapM_ f = sequence_ . map f.
06:26:36 <quchen_> The "f" matters, `sequence_ . map` won't work.
06:27:04 <quchen_> … mumble mumble traverse
06:27:22 <pjdelport> dabelingHaskell: you can think of "map putStrLn x" as producing a list of IO actions, of type [IO ()]
06:27:45 <pjdelport> sequence_, as the name suggests, sequences them all together, to run one after the other
06:28:08 <dabelingHaskell> pjdelport: ok thanks
06:28:28 <pjdelport> (and mapM_ just does both)
06:29:41 <albeit> Is there any way to tell when during the execution of a program Haskell is garbage collecting?
06:30:43 <vanila> I think that you can't because garbage collection usually stops your haskell program until it is completed
06:30:50 <bennofs> albeit: your haskell program is stopped when GC takes place, so you can at least not "observe" it
06:31:14 <albeit> Is there any signal that GC is about to begin, or has just ended?
06:31:33 <bennofs> albeit: no I think not. Why do you need this?
06:31:59 <Axman6> you can explicitly start a GC if you want (under GHC anyway)
06:32:53 <albeit> I was thinking of rewriting a soft real-time system in Haskell, but I'm getting a little nervous about the GC...
06:33:08 <albeit> If I could know when it was GC, it would be great.
06:34:04 <albeit> Ah didn't know about that, thanks Axman6.
06:34:11 <ocharles> bennofs: that did indeed fix it all btw, if you didn't see my reply in #haskell-lens
06:34:19 * hackagebot instrument-chord 0.1.0.8 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.8 (AlanHawkins)
06:34:37 <dabelingHaskell> ok , how do I "groupBy" on identity in haskell? in f# i would use soemthing like this:  Seq.groupBy (fun x -> x)
06:35:07 <Axman6> > group [1,1,1,2,2,3,2,3,4,]
06:35:08 <lambdabot>  <hint>:1:26: parse error on input ‘]’
06:35:12 <Axman6> > group [1,1,1,2,2,3,2,3,4]
06:35:14 <lambdabot>  [[1,1,1],[2,2],[3],[2],[3],[4]]
06:35:35 <bennofs> ocharles: nice :)
06:37:32 <dabelingHaskell> Axman6: thanks, this works in try haskell, do yiou know what i have to add to make it work in the fpcomplete.com web/ide? it says : "group" not in scope?
06:37:44 <vanila> you might need to import Data.List
06:37:55 <Iceland_jack> dabelingHaskell: add 'import Data.List' to the top
06:38:20 <dabelingHaskell> thanks!
06:38:22 <Axman6> dabelingHaskell: import Data.List
06:39:06 <MikeLeman> http://www.twitch.tv/hoochRRR
06:51:19 <benzrf> hmmm
06:51:38 <benzrf> in reactive banana how do i make an event that triggers every x millis
06:51:47 <benzrf> & can i make a behavior that's literally a function of time
06:52:39 <dabelingHaskell> How do i map over a list of tuples? this doesnt work  :  fmap (\(a,b) -> (length b))[(1,"abc") (2,"ff")]
06:52:52 <vanila> > fmap (\(a,b) -> (length b))[(1,"abc") (2,"ff")]
06:52:53 <lambdabot>  Couldn't match expected type ‘(t2, [GHC.Types.Char]) -> (t0, [a0])’
06:52:53 <lambdabot>              with actual type ‘(t1, [GHC.Types.Char])’
06:52:59 <vanila> > fmap (\(a,b) -> (length b))[(1,"abc"), (2,"ff")]
06:53:00 <lambdabot>  [3,2]
06:53:14 <vanila> you can just use map here, fmap isn't needed
06:53:36 <benzrf> dabelingHaskell: that didnt work because you forgot a comma
06:53:53 <dabelingHaskell> vanila: thanks
06:53:54 <benzrf> dabelingHaskell: btw, composing with fst or snd is better than writing a pattern-matching lambda
06:54:42 <dabelingHaskell> benzrf: ah thx!
06:55:26 <quchen_> I don't think it's better. It's mostly a different way of writing the same.
06:55:46 <benzrf> well it looks less bullshit
06:56:08 <benzrf> (\(a, b) -> f a) or (f . fst)
06:56:13 <benzrf> or even better
06:56:15 <benzrf> (first f)
06:56:16 <quchen_> Using patterns allows you to name the contents. (\(index, value) -> length value)
06:56:17 <benzrf> :t first
06:56:18 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
06:56:23 <benzrf> no wait
06:56:26 <benzrf> mb thats wrong
06:56:44 <quchen_> first maps (arrows) over the first component.
06:56:51 <benzrf> yeah
06:56:54 <benzrf> ik :p
06:57:51 <benzrf> whats the ghci command for setting the continuation prompt
06:58:04 <quchen_> :s prompt
06:59:48 <merijn> quchen_: Well, the pattern matching lambda is kinda noisy
07:02:37 <benzrf> quchen_: thats only for the non continuing ling
07:02:38 <benzrf> *line
07:02:45 <benzrf> Haskell> let foo = 3
07:02:45 <benzrf> Prelude Reactive.Banana Reactive.Banana.Combinators Reactive.Banana.Model Control.Applicative Control.Monad|
07:03:47 <d1323> is there an elegant way of finding a sublist within a list?  I thought I got it with (any (==sub) (inits list)), but it won't find [2,3] in [1,2,3]
07:04:43 <Axman6> @hoogle subsequence
07:04:44 <lambdabot> Data.List subsequences :: [a] -> [[a]]
07:04:47 <Iceland_jack> d1323: subsequences
07:04:54 <d1323> @src subsequences
07:04:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:05:05 <Iceland_jack> > subsequences [1,2,3]
07:05:07 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
07:05:14 <Iceland_jack> from Data.List
07:05:17 <Axman6> though, there are better ways that the bruteforce solution using subsequences
07:05:28 <Axman6> @hoogle indices
07:05:28 <Kinnison> (any (isPrefixOf [2,3]) (tails [1,2,3]))
07:05:29 <jnj> Is this assumption correct, http://lpaste.net/103344 ? Any better ideas?
07:05:30 <lambdabot> Data.Array.IArray indices :: (IArray a e, Ix i) => a i e -> [i]
07:05:30 <lambdabot> Data.Array indices :: Ix i => Array i e -> [i]
07:05:30 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
07:05:32 <Kinnison> is a cheesier option
07:06:00 <d1323> > any (isPrefixOf [1,2]) (tails [1,2,3])
07:06:01 <lambdabot>  True
07:06:02 <Axman6> that's pretty good Kinnison
07:06:08 <d1323> > any (isPrefixOf [2,3]) (tails [1,2,3])
07:06:09 <lambdabot>  True
07:06:24 <Kinnison> > any (isPrefixOf [2,3]) (tails [1,2,3, 4])
07:06:25 <benzrf> help ;-;
07:06:26 <lambdabot>  True
07:06:32 <d1323> huh, I just should have used tails instead of inits? *scratches head*
07:06:46 <d1323> and prefix too
07:06:51 <d1323> anyway, nice one
07:07:00 <Kinnison> d1323: My trick is 'tails' produces all the list tails and isPrefixOf is like == but only for the length of the first list
07:07:01 <Axman6> remember that inits always starts with the same subsequence
07:07:10 <Axman6> > inits [1..6]
07:07:11 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6]]
07:07:19 <Kinnison> Also, (I think) tails is cheaper than subsequences
07:07:19 <Axman6> > tails [1..6]
07:07:21 <lambdabot>  [[1,2,3,4,5,6],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6],[]]
07:07:31 <d1323> right. we would need to check equality from the back, which would also be less efficient
07:07:47 <Kinnison> Since tails won't involve any copying
07:08:32 <benzrf> i have problem ;-;
07:08:32 <merijn> Kinnison: Wouldn't it have to be "flip isPrefixOf [2,3]"?
07:08:40 <jnj> I am wondering if I could somehow make the IO monad part of the HumanPlayer data and thus avoid having all choseRule being "in the IO monad".
07:08:42 <Axman6> > let f = takeUntil null . iterate tail in f [1..6]
07:08:43 <lambdabot>  Not in scope: ‘takeUntil’
07:08:50 <Axman6> takeUntil should be a thing
07:08:51 <Kinnison> merijn: I thought isPrefixOf takes the prefix? on the left.
07:08:54 <Kinnison> merijn: so you can do:
07:08:56 <benzrf> jnj: why do you need IO
07:09:02 <merijn> Kinnison: Right, which is wrong, no?
07:09:03 <Kinnison> merijn: blah `isPrefixOf` longfoo
07:09:21 <merijn> > [2,3] `isPrefixOf` [2,3,4]
07:09:23 <lambdabot>  True
07:09:31 <jnj> To display on screen and read reply from the human player, see http://lpaste.net/103344
07:09:35 <merijn> oh, wait
07:09:41 <merijn> You were looking for subsequence
07:09:42 <merijn> nvm
07:09:45 * Kinnison grins
07:09:48 <merijn> I misunderstood the problem :)
07:09:50 <Kinnison> :-)
07:10:24 <merijn> jnj: Well, why does choseRule have to be in IO?
07:11:02 <jnj> I need to read input from the user, I assume that is done using IO.
07:11:12 <jnj> (and i need to display stuff also)
07:11:14 <merijn> jnj: The Haskell approach would be to make choseRule pure and then use fmap
07:11:50 <benzrf> jnj: write all of your logic purely
07:11:54 <Kinnison> jnj: Write as much as you can without using IO because it's much easier to test
07:11:57 <benzrf> jnj: then call into it from iota_
07:11:58 <benzrf> *IO
07:12:01 <Axman6> jnj: remember, you want as little IO in your program as possible.
07:12:06 <merijn> jnj: i.e. have a list of rules, do the printing/reading in IO and have a function "[Rule] -> UserInput -> Rule"
07:13:04 <jnj> It's not really logic though, it's presenting options to the human and making him chose one. The other instances of Player are pure.
07:13:08 <jnj> hm
07:13:39 <jnj> FifoPlayer, MonteCarloPlayer etc. there is no UserInput
07:13:53 <benzrf> jnj: pure code cannot call io
07:13:57 <benzrf> only vice versa
07:14:05 <merijn> jnj: i.e. do something like "data GameState = GameState [Rule]; printState :: GameState -> IO (); readRule :: IO Rule; choseRule :: Rule -> GameState -> GameState"
07:14:43 <merijn> jnj: Your function that takes a state and updates it based on user input can be pure, even when the printing/reading isn't
07:16:00 <dabelingHaskell> how would I print most easily data of type : [([Char],Int)] ?
07:16:22 <vanila> dabelingHaskell, show x  can work for most things, including that
07:16:23 <merijn> dabelingHaskell: "print" :)
07:16:34 <merijn> vanila: show turns it into a String, it doesn't print said String
07:18:45 <dabelingHaskell> merijn: is there a print "line"?
07:19:07 <Axman6> what do you mean?
07:19:07 <benzrf> i want finn in adventure time to exclaim 'MONADIC!' at some point
07:19:29 <merijn> dabelingHaskell: "print = putStrLn . show" <- putStrLn prints a String to stdout and "show" converts values to String
07:19:37 <vanila> benzrf, write an email to the cartoonist, this needs to happen...
07:19:58 <Axman6> benzrf: I imagine that would involve some kind of monster eating something, then pooping it into another monster's mount, ad infinium
07:20:04 <benzrf> ahaha
07:20:11 <Axman6> (where mouths are the inputs to the function monster)
07:23:37 <dabelingHaskell> ok now only sorting is left
07:24:01 <dabelingHaskell> to which function do I pass my sort function?
07:24:07 <dabelingHaskell> sortBy?
07:25:18 <Iceland_jack> You pass your comparison function to sortBy
07:25:44 <Iceland_jack> If you want to compare on length you can do
07:25:44 <Iceland_jack> :t sortBy (comparing length)
07:25:45 <lambdabot> [[a]] -> [[a]]
07:27:18 <Iceland_jack> > sortBy (comparing length) (words "the quick brown fox")
07:27:19 <lambdabot>  ["the","fox","quick","brown"]
07:27:27 <Iceland_jack> > sortBy (comparing (Down . length)) (words "the quick brown fox") -- This reverses the comparison
07:27:28 <lambdabot>  ["quick","brown","the","fox"]
07:28:13 <Iceland_jack> (note that the latter is not the reversed version of the former)
07:28:13 <tdammers> > sort . concat . words $ "the quick brown fox jumps over the lazy dog"
07:28:14 <lambdabot>  "abcdeeefghhijklmnoooopqrrsttuuvwxyz"
07:28:21 <tdammers> > nub . sort . concat . words $ "the quick brown fox jumps over the lazy dog"
07:28:22 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
07:28:28 <tdammers> now we're talking :D
07:28:30 <Earnestly> lol nice
07:29:01 <Iceland_jack> > sort "the quick brown fox is tired of these examples"
07:29:03 <lambdabot>  "        abcdeeeeeeffhhiiiklmnooopqrrssstttuwxx"
07:30:58 <Eduard_Munteanu> What's a nice abstraction for generating values for a datatype from a grammar? QC's Arbitrary?
07:31:18 <Eduard_Munteanu> Generating randomly, that is.
07:31:43 <Eduard_Munteanu> (not exhaustively, but uniformly distributed)
07:32:09 <dabelingHaskell> can anyone tell me how I define this function in a single line? : sortGT (a1, b1) (a2, b2)   | a1 < a2 = GT   | a1 > a2 = LT   | a1 == a2 = compare b1 b2
07:32:36 <merijn> dabelingHaskell: Why do you want it to be a single line?
07:32:47 <merijn> dabelingHaskell: btw, the "==" on the last line is redundant
07:33:06 <dabelingHaskell> merijn: so that it does stop complain about indention errors!!
07:33:06 <vanila> dabelingHaskell, I think that already exists though
07:33:09 <merijn> Presumably if neither "a1 < a2" nor "a1 > a2" then the "a1 == a2" is by definition
07:33:13 <vanila> > (1,2) < (1,3)
07:33:15 <lambdabot>  True
07:33:24 <Iceland_jack> dabelingHaskell: Indentation errors?
07:33:25 <merijn> dabelingHaskell: Are you mixing tabs and spaces?
07:33:27 <dabelingHaskell> the first type is string in my case
07:33:39 <dabelingHaskell> merijn: yes propably
07:33:42 <merijn> Or using tabs at all?
07:33:48 <Eduard_Munteanu> dabelingHaskell: sort does that already for the default Ord instance of pairs
07:34:02 <Eduard_Munteanu> Oh, it's flipped around.
07:34:10 <vanila> :t compare :: (String,Integer)
07:34:11 <lambdabot>     Couldn't match expected type ‘(String, Integer)’
07:34:11 <lambdabot>                 with actual type ‘a0 -> a0 -> Ordering’
07:34:11 <lambdabot>     Probable cause: ‘compare’ is applied to too few arguments
07:34:17 <vanila> oops
07:34:22 <vanila> I think it can work though
07:34:42 <dabelingHaskell> Eduard_Munteanu: no sort its not enough
07:34:42 <dabelingHaskell> https://www.fpcomplete.com/project/36760/9Yynn16PAC
07:35:05 <danilo2> Hello! :) Could somebody help me please and tell why the following 10-line code produces error "Functional dependencies conflict" (http://lpaste.net/103347) ? Where is the conflict?
07:35:23 <arj> dabelingHaskell: why not create a function inverseSort: Ordering -> Ordering and create sortGT by using inserveSort ?
07:35:36 <dabelingHaskell> arj: ok , how do i do that?
07:35:40 <Iceland_jack> dabelingHaskell: You can do 'inverse sorting' by using Down
07:35:45 <Iceland_jack> like in the example above
07:35:51 <Eduard_Munteanu> :t flip compare
07:35:55 <lambdabot> Ord b => b -> b -> Ordering
07:36:09 <Iceland_jack> or that
07:36:28 <arj> dabelingHaskell: I basically meant what Eduard_Munteanu suggested.
07:36:30 <benzrf> danilo2: for one thing, have you tried using fmap instead of your do-notation stuff
07:36:33 <benzrf> oh wait monad >.>
07:36:39 <benzrf> >tfw applicative isnt a superclass
07:37:03 <dabelingHaskell> let sorted = flip compare transf  ( doesnt work)
07:37:13 <ccc> mplayer /home/ron/download/ch9-haskell-lectures/*.mp4
07:37:28 <Iceland_jack> dabelingHaskell: Are you by any chance doing everything in GHCi?
07:37:32 <c_wraith> danilo2: the functional dependencies conflict because the two instances have the same c
07:37:33 <Iceland_jack> If so, don't
07:37:40 <dabelingHaskell> Iceland_jack: no im using fpcomplete
07:37:49 <dabelingHaskell> Iceland_jack: https://www.fpcomplete.com/project/36760/9Yynn16PAC
07:38:20 <benzrf> danilo2: just taking a wild guess (i dont know fundeps that well)
07:38:20 <danilo2> c_wraith: hmm, but that should nto raise a problem, should it? look, the fundeps tell only - take a and b and infer c. The c could be the same as far as I know
07:38:21 <Clint> dabelingHaskell: is sortBy (comparing (Down . fst) <> comparing snd) what you want?
07:38:31 <benzrf> wait gmm :{
07:38:32 <benzrf> *hmm
07:38:47 <c_wraith> danilo2: well, also, they overlap
07:38:58 <Iceland_jack> I doubt that's actually what dabelingHaskell wants
07:39:06 <c_wraith> danilo2: ((->) a) is a monad, and all
07:39:39 <danilo2> c_wraith: ahhh, here it is! ((->) a) is a monad!
07:39:41 <Iceland_jack> dabelingHaskell: Why is everything defined using let's in main?
07:39:57 <danilo2> c_wraith: hmm, is there any way to write these two instances and make them work? somehow?
07:40:16 <Iceland_jack> Have you looked at resources like LYAH? They teach you how to structure your program
07:40:39 <merijn> Is Coq worth learning in addition to Agda? Yes? No?
07:40:50 <dabelingHaskell> Iceland_jack: thanks I know its bad structure, i simply want to get the sorting issue resolved :)
07:40:53 * Iceland_jack now understands why dabelingHaskell wanted a way of writing it in a single line :)
07:41:33 <Iceland_jack> dabelingHaskell: You do 'map (\x -> (x, length x)) …', are you only computing the length to sort by it?
07:41:50 <danilo2> c_wraith: I want to take the most accurate instance. In case of function it should choose the (->) one - is it possible? I was trying with incoherentInstances etc (I've heard in ghc-7.8 they changed behaviour, but without success)
07:41:51 <ocharles> I feel like GHC should be able to derive a Functor instance for a GADT with UserCreate :: (AsFailCreateBasic e, AsFailCreateUser e) => User -> (UserId -> n) -> CommandF e n
07:41:55 <merijn> dabelingHaskell: The problem is that guards don't need repetition of the function name
07:41:55 <ocharles> am I missing anything obvious?
07:42:03 <ocharles> I mean it can't, because someone presumably needs to do more work
07:42:06 <ocharles> but it doesn't look impossible
07:42:12 <benzrf> i need reactive banana help :o(
07:42:13 <Feuerbach_> ocharles: try standalone deriving
07:42:13 <c_wraith> danilo2: I have no idea how to make a class that does either of those. I'd just write two different functions to do two different things.
07:42:19 <ocharles> Feuerbach_: oh yea
07:42:19 <merijn> ugh
07:42:26 <dabelingHaskell> merijn: how i fix that syntactically?
07:42:28 <merijn> I dunno how to change this example via fpcomplete
07:42:47 <ocharles> I find it so odd that standalone deriving is different from the normal deriving mechanics
07:43:10 <ocharles> nope, still can't derive it
07:43:14 <Feuerbach_> oh well
07:43:14 <ocharles>  Can't make a derived instance of `Functor (CommandF e)': Constructor `UserCreate' must not have existential arguments
07:43:24 <merijn> dabelingHaskell: like this: http://lpaste.net/103349
07:44:05 <dabelingHaskell> merijn: thanks a ton
07:44:09 <merijn> dabelingHaskell: See this haskell syntax cheat sheet: http://blog.codeslower.com/static/CheatSheet.pdf
07:44:29 <dabelingHaskell> merijn: how would I express that with let { ... ; .. }  syntax?
07:44:38 <ocharles> Feuerbach_: I wonder if https://ghc.haskell.org/trac/ghc/changeset/cdac487bcd9928d77738f6e79ead7b9bb4bc00fd/ghc is the fix :)
07:44:52 <danilo2> c_wraith: hmm, ok thnak you :) I cannot write two separate functions in this case . I'll dig further :) thanks! :)
07:45:21 <merijn> dabelingHaskell: You mean without the | guards? You can't, unless you put a nested if inside the function body
07:45:55 <Iceland_jack> I'm not sure you should be helping them write sortGT better when it's probably not what they want to write
07:45:59 <merijn> dabelingHaskell: i.e. "if a1 < a2 then GT else if a1 > a2 then LT else compare b1 b2"
07:46:11 <dabelingHaskell> merijn: but here fact is a multiline definiton, no? http://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
07:46:23 <c_wraith> danilo2: well, they're both just fmap.
07:46:40 <merijn> dabelingHaskell: That question is asking about ghci
07:46:52 <merijn> dabelingHaskell: What I wrote isn't valid syntax in ghci, it's perfectly fine in haskell files
07:47:18 <merijn> dabelingHaskell: But you shouldn't be writing non-trivial code in ghci anyway
07:47:25 <c_wraith> :t (\f x -> fmap ($ x) f, fmap)
07:47:26 <dabelingHaskell> merijn: ah ok, i messed that
07:47:26 <lambdabot> (Functor f1, Functor f) => (f (a -> b) -> a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
07:48:41 <dabelingHaskell> merijn: Iceland_jack  thanks guys/gilrs :) !
07:48:59 <merijn> dabelingHaskell: In fact, you can get rid of all the "let" and just write: http://lpaste.net/103349
07:49:27 <Iceland_jack> You're welcome dabelingHaskell, take a look at the link merijn posted
07:50:07 <Iceland_jack> in reality you wouldn't create 5 top-level definitions for that, but it's a start
07:50:29 <Iceland_jack> 6 counting the string
07:50:49 <merijn> ocharles: GHC's functor deriving is really dumb, so no it can't do that without someone making it smarter :)
07:51:08 <ocharles> merijn: I think it can do that, it just needs https://ghc.haskell.org/trac/ghc/ticket/8678
07:53:19 <ocharles> I might try and whip something together with instant-generics
07:54:13 <bennofs> does GHC already use GHC.Generics for DeriveFunctor or similar internally?
07:54:21 <ocharles> I don't think so
07:55:29 * bennofs wishes Generics would support GADTs or ExistentialQuantification
07:56:16 <ocharles> Exception when trying to run compile-time code: impossible Code: deriveRepresentable ''CommandF
07:56:18 <ocharles> FFFFUUUUU
07:57:05 <Feuerbach_> ocharles: yes, that commit looks promising
07:57:19 <ocharles> repCon _ (ForallC _ _ _) _ = error "impossible"
07:57:20 <ocharles> :(
07:57:35 <ocharles> dreixel: don't suppose you have any final tricks? ;)
07:59:45 <danilo2> c_wraith: ok, thank you :)
08:03:36 <haskell-newbie> hello
08:04:00 <dreixel> bennofs: no
08:04:20 <dreixel> ocharles: is this instant-generics?
08:04:45 <Taneb> haskell-newbie, hi
08:05:00 <haskell-newbie> how to describe set named X which containes element y and much more but y in particular in math symbols?
08:05:09 <haskell-newbie> X { ... y ... } ?
08:05:22 <vanila> Just write "Let X be a set containing y"
08:05:28 <Taneb> ^
08:05:39 <nclarke> X : y \in X
08:05:54 <vanila> I wouldn't understand nclarke
08:06:01 <vanila> if I just saw those symbols
08:06:08 <merijn> ocharles: Clearly the solutions is to hack support into GHC :D
08:06:10 <haskell-newbie> vanila: that doesn't shows that X contains more than just y
08:06:18 <ocharles> dreixel: indeed
08:06:26 <ocharles> merijn: it's in GHC, but 7.10+ :)
08:06:31 <tromp_> let X in {X | y in X} :)
08:06:36 <nclarke> vanila: Well, 'math symbols' was asked for
08:06:43 <gilbertomelfe> Hi everybody!
08:06:52 <ocharles> dreixel: I'm working with this GADT, and I'd like a Functor instance:
08:06:53 <dreixel> ocharles: what is your datatype?
08:06:56 <ocharles> https://www.irccloud.com/pastebin/NtEZpLIq
08:07:02 <gilbertomelfe> Got a question!
08:07:14 <Sculptor> shoot
08:07:15 <ocharles> GHC.Generics is no option, because it's a GADT. instant-generics might be able to support it, but TH certainly can't derive a Representation
08:07:47 <dreixel> ocharles: that one doesn't look too bad
08:07:58 <haskell-newbie> nclarke: does \in that implies that X contains other things which are out of interest? X : y \in not empty X  closer but not empty is not math symbol
08:08:01 <gilbertomelfe> In ghci I "load" :m + Data.Text and then :t takeEnd, but it can't find that function!!
08:08:15 <haskell-newbie> sorry for my rediculus questions just really curious
08:08:22 <ocharles> dreixel: promising!
08:08:52 <nclarke> haskell-newbie: No, all \in (which is just LaTeX notation for the symbol which looks like a reverse epsilon) implies is that X contains y
08:09:18 <dreixel> ocharles: it might work in GHC.Generics with a handwritten Generic instance...
08:09:28 <haskell-newbie> nclarke: is it possible specify that X is contains other elements besides y?
08:09:35 <nclarke> You could say X : y \in X and X\y != emptyset
08:09:47 <dreixel> instance (AsFailCreateBasic e, AsFailCreateUser e) => Generic1 (CommandF e) where ...
08:09:54 <ocharles> dreixel: ok, but the whole bit of work I'm doing is eliminating boiler plate
08:09:58 <SLi> ∈
08:10:03 <nclarke> It's not a 'usual' thing to specify
08:10:06 <ocharles> so while I have eliminated one bit of boiler plate, it kinda sucks I have to write more :)
08:10:07 <nclarke> SLi: thanks!
08:10:26 <ocharles> dreixel: oh, this data type has about 50 constructors, each with different constraints
08:10:29 <gilbertomelfe> It is on the documentation in Hackage! Do I need to update the module?
08:10:32 <geekosaur> gilbertomelfe, I don't see a takeEnd anywhere (nor does hayoo). where did you get it?
08:10:41 <ocharles> https://www.irccloud.com/pastebin/WYiYrYxn
08:10:41 <bennofs> ocharles: write TH to write the Generic instance :)
08:10:43 <ocharles> That's what it actually is
08:10:50 <ocharles> bennofs: well that's what instant-generics does
08:10:55 <bennofs> ah ok
08:10:56 <ocharles> but it can't handle the existential part of this type
08:11:01 <SLi> Hm, I wonder if there's a keyboard layout (apart from some APL keyboard) that includes all these clearly relevant symbols like set membership. There should be!
08:11:08 <dreixel> ocharles: oh... O_o
08:11:26 <ocharles> SLi: I just use a tex input method in emacs. then I can x \member foo
08:11:29 <nclarke> X : y ∈ X, X\y ≠ ∅
08:11:30 <gilbertomelfe> geekosaur, http://hackage.haskell.org/package/text-1.1.1.1/docs/Data-Text.html
08:11:31 <dreixel> ocharles: in quick analysis, though, the problem is the same. These are all class constraints, no equality constraints, and no existential quantification
08:11:47 <ocharles> dreixel: right
08:12:03 <geekosaur> oh, newer version than is in the Platform
08:12:03 <nclarke> Says, basically, X is a set such that y is in X and y is not the only thing in X
08:12:05 <ocharles> dreixel: that's what made me wonder if it's just a case of improving the TH module of instant-generics
08:12:21 <haskell-newbie> nclarke: thank you very much!
08:12:27 <dreixel> ocharles: it might...
08:12:32 <gilbertomelfe> how can i find out what is the version I have installed?
08:12:37 <geekosaur> the platform got delayed by ghc 7.8 taking about 6 months longer than intended to come out (needed for proper OS X support)
08:13:10 <dreixel> ocharles: there might be a nice way of generalising the CEq there, to support arbitrary constraints, not just equality constraints
08:13:11 <nclarke> Some sources would prefer you say X\{y} or X-y, reserving \ for set difference
08:14:20 <dreixel> ocharles: data CEq c (k :: Constraint) a where C :: k => a -> CEq c k a
08:14:26 <nclarke> Since we're in a Haskell channel, I should probably encourage you to use those, since they're more strongly typed!
08:14:40 <dreixel> ocharles: and then change the TH code to properly generate those |k|s...
08:14:53 <hexagoxel> gilbertomelfe: ghc-pgk list | grep text
08:15:04 <dreixel> ocharles: which will prob not be trivial.
08:15:05 <geekosaur> "ghc-pkg"
08:15:20 <bennofs> hexagoxel: isn't that just ghc-pkg list text?
08:15:41 <ocharles> dreixel: ok. i'll probably have to study instant-generics a bit more before diving in
08:16:04 <hexagoxel> ah yes pkg, not pgk
08:16:13 <bernalex> skypers: I mean that languages like scala are "not enough".
08:16:19 <gilbertomelfe> OK, got it! I have     text-0.11.3.1
08:16:23 <ocharles> I forget how the equality stuff works
08:16:36 <dreixel> ocharles: Chapter 10 of my thesis :P
08:16:45 <ocharles> yep, I haven't got there yet :)
08:16:50 <ocharles> but it's within arms reach!
08:16:55 <dreixel> :-D
08:17:06 <gilbertomelfe> hexagogel, how can i update it? Should I?
08:17:12 <geekosaur> that's the current platform version, yes. upgrading it is not particularly recommended because ghc is a bit of a pain; I'd wait a month for the new platform
08:17:25 <gilbertomelfe> I've heard of Cabal Hell!
08:17:35 <geekosaur> yes, the misnamed cabal hell
08:17:42 <geekosaur> cabal is the messenger, ghc is the hell
08:18:12 <bennofs> doesn't GHC 7.8 finally support ignoring the global pkg db?
08:18:40 <nclarke> cabal 1.18 has sandboxes, which are a very good idea
08:19:28 <gilbertomelfe> but then I would have to install Yesod (taking a lot of space) for every single project right ?
08:19:28 <nclarke> Setting 'require-sandbox : True' in ~/.cabal/config is a good idea, and should be the default
08:19:47 <nclarke> You can have shared sandboxes
08:20:27 <nclarke> And I think the actual package source may be cached somewhere centrally
08:24:25 <gilbertomelfe> OK Thank You all!
08:24:35 * hackagebot largeword 1.2.2 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.2.2 (DominicSteinitz)
08:32:31 <gamegoblin> How does `read` compare to writing your own fromString sort of function with Parsec? Speedwise.
08:35:34 <dwcook> gamegoblin, well, you could try timing it yourself, however a Parsec parser is basically always preferable over read for real programs.
08:36:04 <gamegoblin> Huh, I figured it would be the other way around. Interesting!
08:36:05 <dwcook> Mainly because read has an error case.
08:36:20 <dwcook> Well, Parsec lets you handle errors whereas read doesn't*
08:37:19 <dwcook> (* - it sort of does, but something is likely wrong if you have to)
08:39:38 * hackagebot sqlite-simple 0.4.7.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.7.0 (JanneHellsten)
08:39:40 * hackagebot arrow-list 0.6.1.4 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.6.1.4 (AdamBergmark)
08:43:02 <magicman> @type asks . lift
08:43:03 <lambdabot>     Kind incompatibility when matching types:
08:43:03 <lambdabot>       m1 :: * -> *
08:43:03 <lambdabot>       r0 :: *
08:43:52 <hexagoxel> how can i do a per-user installation with cabal if i have a sandbox in the current directory? i tried --user and --package-db=user, but these seem to have no effect (?)
08:44:49 <dwcook> hexagoxel, `cabal install cabal-install` gives you your own local cabal. Then just add $HOME/.cabal/bin to the front of your path
08:45:02 <dwcook> hexagoxel, do that outside of a sandbox, that is – I don't know what effect it'd have within one
08:46:26 <hexagoxel> dwcook: i successfully use cabal install already; my question is more in the sense "why are my flags ignored if i am in a sandbox, is this a bug?"
08:46:58 <geekosaur> hexagoxel, because a sandbox is implemented as a user package database
08:47:04 <geekosaur> so all you're doing is telling it to use the sandbox
08:47:50 <hexagoxel> so could i do --package-db=~/.ghc or something instead?
08:49:06 <geekosaur> I suspect ~ doesn't work there, plus it needs to be a more complete path
08:49:38 <dwcook> It's the shell that would expand ~. If it goes through a shell then it should be fine
08:49:53 <geekosaur> $HOME/.ghc/platform-spec-here/package.conf.d
08:50:13 <geekosaur> dwcook, if your shell will expand the ~ after a = instead of requiring it to be the start of a shell-word, yes
08:50:18 <dwcook> Well, I guess it also depends on some other things
08:50:26 <dwcook> Ah, yeah
08:52:43 <hexagoxel> tried "cabal install --user --package-db=/home/lsp/.ghc/x86_64-linux-7.6.3/package.conf.d/ $PACKAGE", it still installs into sandbox.
08:53:15 <hexagoxel> well it is not an important question anyway, one can always switch to a non-sandboxed directory
08:53:39 <hexagoxel> (omitting --user does not change the outcome)
08:54:02 <hexagoxel> thanks dwcook, geekosaur
08:54:17 <geekosaur> yeh, I think you need dcoutts at this point
08:59:40 * hackagebot attoparsec 0.11.3.0 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.3.0 (BryanOSullivan)
09:04:41 * hackagebot fay-dom 0.4 - DOM FFI wrapper library for Fay  http://hackage.haskell.org/package/fay-dom-0.4 (AdamBergmark)
09:10:11 <bernalex> can someone explain me the implications of: https://upload.wikimedia.org/math/1/3/6/136aebbd25951472d4bc410a058e686b.png (strictly speaking lambda calculus, not haskell)
09:11:30 <Iceland_jack> bernalex: Implications? Do all the symbols look familiar to you?
09:11:33 <vanila> link?
09:11:45 <c_wraith> bernalex: isn't that just saying that Free over gamma is the union of free over each value in gamma?
09:11:51 <bernalex> Iceland_jack: I'm not sure how the union thing works here since there's nothing beside it.
09:12:07 <vanila> oh it's the union over all x:sigma in Gamma
09:12:09 <Iceland_jack> Nothing beside it? What about 'free(σ)
09:12:09 <Iceland_jack> '
09:12:19 <vanila> so basically if gamma is [x : A, y : B, z :C]
09:12:27 <bernalex> oh, right, so because of that subscript it's more spacious than usally.
09:12:30 <bernalex> usually
09:12:30 <vanila> then free(gamma) is going to be union of free(A) with free(B) with free(C)
09:12:33 <nclarke> This is in a typed LC?
09:12:37 <bernalex> Iceland_jack: so the U is on free ( sigma )?
09:12:55 <Iceland_jack> Yes this is something analogous to the simply typed lambda calculus
09:12:59 <bernalex> nclarke: hindley-milner
09:13:00 <Iceland_jack> bernalex: yes
09:13:30 <bernalex> right, then I get it. thanks Iceland_jack & c_wraith.
09:14:30 <bernalex> Iceland_jack: also, on wikipedia, a few lines up, it says that e is empty, and with such wonky graphics, the e in this picture looked like the empty e instead of the element e, and I didn't want to assume anything. :-P
09:15:44 <Iceland_jack> the 'empty e'?
09:16:02 <Iceland_jack> the context definition is just a normal cons list
09:16:03 <bernalex> i.e. e as a symbol for empty, as opposed to e as a symbol for element.
09:16:08 <Iceland_jack> right
09:16:23 <Iceland_jack>     data Γ = ε | Γ, x ∶ σ
09:16:41 <bernalex> I should bother logging in, because I'm told you can get mathjax or something more readable if you log in to wikipedia and set user preferences.
09:16:48 <Iceland_jack> where the constructors are ε and ,
09:16:59 <bernalex> yes, I get that. thanks.
09:17:17 <c_wraith> man, I'm bad at greek.  Is that rho?
09:17:24 <bernalex> do you mean sigma?
09:17:25 <Iceland_jack> σ is sigma
09:17:31 <c_wraith> d'oh
09:17:33 <bernalex> rho is more p-liek
09:17:35 <Iceland_jack> ρ is rho :)
09:17:35 <bernalex> like
09:17:39 <skypers> 17:14 #haskell: < bernalex> skypers: I mean that languages like scala are "not enough".
09:17:39 <Iceland_jack> ρ'h
09:17:45 <c_wraith> :)
09:17:45 <skypers> you were talking about your tweet? :)
09:17:54 <bernalex> skypers: yes. responded on twitter too, since you weren't active.
09:18:21 <skypers> I saw
09:18:31 <skypers> why do you thing scala’s not enough?
09:18:35 <skypers> think*
09:19:39 <bernalex> skypers: I find it incredibly frustrating to work in a non-pure functional language. everything that's valid and compiles *will* end up in your codebase if the project is big enough. if side-effects are permitted, people *will* use them. it will start out small, "just this one time!", then three years down the line you have a nightmare on your hands.
09:20:36 <skypers> bernalex: I agree, but if you work with small people, that won’t happen
09:20:41 <skypers> smart*
09:20:45 <skypers> small people, whaaat :D
09:21:05 <monochrom> I like to work with smart people, too.
09:21:08 <bernalex> skypers: I disagree completely. smart people will be enticed by the short-term solution appeal of side-effects if the project is big enough.
09:21:19 <bernalex> i.e. if deadlines are close enough ;-)
09:21:33 <merijn> Smart people will make the inevitable screwup all the more complex and spectacular
09:21:37 <merijn> Evidence: me :p
09:21:42 <bernalex> merijn: :-)
09:21:57 <skypers> bernalex: if deadlines are close enough, people will choose the fastest solution
09:22:03 <monochrom> oh, there is a surprise for you. smart people may also insist on side effects because "I can deal with it"
09:22:09 <oio> how can i edit lines in getLines ?
09:22:15 <bernalex> monochrom: :-D
09:22:28 <skypers> and in such cases, fastest == best
09:22:30 <BeardedCoder> I have to agree with bernalex and have seen it on our Scala projects.
09:22:33 <skypers> oio: you can’t
09:22:33 <monochrom> I know examples of such smart people. this is not speculation.
09:22:44 <oio> skypers: any other function?
09:22:52 <skypers> what do you want to do?
09:22:57 <skypers> getLine get you a line back from IO
09:23:02 <bernalex> even if we accept some alternate reality where the side-effects won't ruin your scala program -- why is it there then? ;-) better to remove the temptation entirely.
09:23:12 <skypers> it doesn’t permit you to “edit” a line, which makes no sense ; what do you want to achieve?
09:23:22 <merijn> monochrom: I like Haskell, because I *will* do horrible stuff to code when allowed :p
09:23:38 <monochrom> similarly, some smart people also refuse static typing.
09:23:40 <bernalex> merijn: this is the core of my point. everyone would, right? side-effects *are* tempting. too tempting.
09:23:41 <skypers> bernalex: I agree
09:23:42 <Maior> merijn: hah likewise
09:23:48 <oio> an alternative to getline with editing capabilitties?
09:23:54 <skypers> but I had an interesting talk about that with friends
09:24:00 <xcthulhu> monochrom:  A lot of algorithms run faster when you can change some stuff
09:24:06 <merijn> Evidence: templating implemented using CPP, horrific stack pointer abuse during my ASM coding, etc.
09:24:07 <skypers> the difference between being able to, and wanting to
09:24:08 <Maior> oio: you mean something like GNU readline?
09:24:09 <BeardedCoder> Also, trying to explain to management why typesafe config is not typesafe enough, is a loosing battle. <- in my experience.
09:24:12 <Iceland_jack> oio: Haskelline
09:24:15 <geekosaur> oio, haskeline?
09:24:20 <Maior> (http://hackage.haskell.org/package/readline-1.0.1.0/docs/System-Console-Readline.html)
09:24:21 <Iceland_jack> if you want a readline clone
09:24:23 <skypers> oio: what do you mean by “editing?”
09:24:27 <merijn> xcthulhu: Haskell has plenty of ways to do mutable stuff if needed
09:24:37 <xcthulhu> monochrom:  And if you’ve ever read the Functional Pearls book, the pure functional alternatives can be mind-bending
09:24:41 <monochrom> basically, the smart people behind Racket are examples of refusing purity and static typing.
09:25:00 <merijn> monochrom: And they're trying to add it back in aftr realising their mistake xD
09:25:08 <FreeFull> There is typed racket
09:25:14 <FreeFull> Which doesn't use HM!
09:25:20 <quchen> ಠ_ಠ
09:25:21 <oio> skypers: when i delete on getLine y get ^? ^? ^?
09:25:27 <xcthulhu> merijn:  Sure; if you need speed you can get it in Haskell
09:25:38 <skypers> oio: do you read a file?
09:25:41 <oio> haskeline seems convoluted
09:25:44 <quchen> I should not have come here right now, the backscroll is creepy
09:25:44 <skypers> or something like that?
09:25:51 <oio> skypers: no
09:25:52 <xcthulhu> merijn:  But side effects will still always get you in the ned
09:25:53 <skypers> I really don’t get want you want to do
09:25:55 <geekosaur> oio: yes, line editing is convoluted
09:25:55 <xcthulhu> *end
09:26:01 <skypers> getLine gets you a line from IO
09:26:08 <geekosaur> if you don't like haskeline's interface, you'll hate readline's version
09:26:10 <monochrom> you are provably hosed because smart people rightly refuse to be disciplined and non-smart people look up to smart people as role models.
09:26:11 <skypers> you can “edit it” in any way you want
09:26:18 <ff0066> several functions in Data.Foldable require that a structure is "non empty"
09:26:22 <merijn> skypers: He wants commandline editing like readline
09:26:35 <monochrom> Dijkstra is about the only smart people who ask to be disciplined
09:26:35 <skypers> oh
09:26:37 <skypers> ok
09:26:43 <geekosaur> that said, it does sound like your tty settings are wrong
09:26:44 <merijn> skypers: i.e. history, search, deleting words forward/backward, jumping to end of line, start of line, etc.
09:26:51 <oio> geekosaur: lol you once gave me the answer to this question but i forget itlolol..
09:26:53 <ff0066> is there a generic way to decide if something is non-empty and therefore safe for use with Data.Foldable.maximum, etc..?
09:26:55 <skypers> monochrom: yeah
09:27:11 <skypers> 18:22 < skypers> the difference between being able to, and wanting to
09:27:14 <bernalex> ff0066: monad comprehensions with Maybe?
09:27:23 <c_wraith> ff0066: use Data.Foldable.toList and check if it's null
09:27:26 <skypers> this something Haskell tends to deliberately ignore
09:27:31 <bernalex> or what c_wraith said :-)
09:27:45 <fizruk> semigroupoids has Foldable1 iirc :p
09:27:46 <c_wraith> ff0066: after all, Foldable is the class of things that can be mapped to lists
09:28:51 <ff0066> c_wraith: great point
09:28:58 <ff0066> thank you!
09:29:11 <quchen> Maximum is a monoid for Bounded things, so you can just use foldMap in that case.
09:29:12 <skypers> the important gap between Haskeller and others is that we do the things the correct way ; but I’m not sure we do things faster though
09:29:18 <skypers> Haskellers*
09:29:23 <merijn> ff0066: How about "Data.Foldable.foldr max minBound"
09:29:40 <merijn> ff0066: Although that'll return minBound for an empty container, not sure whether that's a problem
09:30:45 <ff0066> quchen: I'm not finding Maximum on hoogle.. where is it defined?
09:31:00 <quchen> Semigroups probably has it
09:31:01 <fizruk> max forms a semigroup, why semigroups are not in base?..
09:31:20 <skypers> isn’it that in Monoid?
09:31:29 <ff0066> merijn: in my case it is an error to provide an empty-structure and i wanted to be able to detect this case
09:31:31 <quchen> Semigroup has a couple of monoids.
09:31:52 <skypers> it’s not in Monoid neither Semigroup
09:32:08 <merijn> ff0066: Probably using the toList and null approach is best then
09:32:16 <merijn> ff0066: Should be reasonably efficient still
09:32:22 <quchen> It's in semigroups.
09:32:23 <fizruk> http://hackage.haskell.org/package/semigroups-0.13.0.1/docs/Data-Semigroup.html#t:Max
09:32:30 <fizruk> Max it is ^
09:32:41 <ff0066> quchen: yep; found it
09:32:52 <ReinH> ff0066: max does form a monoid.
09:33:02 <ff0066> merijn: i'm leaning toward; null . toList, thank you
09:33:02 <quchen> No, max alone isn't a monoid.
09:33:10 <ReinH> quchen: yes, it is.
09:33:18 <quchen> It has no zero.
09:33:23 <ReinH> you need to add an element to represent negative infinity
09:33:31 <quchen> In other words, max is not a monoid.
09:33:32 <ff0066> i'll check out Max and see how it behaves; thanks all
09:33:39 <ReinH> quchen: yes, it is.
09:33:45 <fizruk> ReinH: it’s like any semigroup is a monoid because Maybe a is a monoid if `a` is
09:33:52 <quchen> "Non-empty lists are monoids. You just need to add an empty case"
09:33:53 <ReinH> yes
09:34:12 <ReinH> quchen: yes, any semigroup is a monoid if you add an empty element
09:34:17 <ReinH> this is quite useful
09:34:17 <merijn> ReinH: Right, so Max is not a Monoid
09:34:18 <fizruk> ReinH: so not any semigroup is a monoid
09:34:27 <ReinH> I didn't say Max is a monoid
09:34:30 <ReinH> I said that max forms a monoid
09:34:37 <quchen> Everything is a monoid if you add the necessary structure to make it one.
09:34:42 <quchen> Therefore, everything is a monoid.
09:34:50 <quchen> :-(
09:34:53 <merijn> ReinH: You literally said to quchen's "max alone isn't a monoid" "quchen: yes, it is."
09:34:55 <fizruk> [a] is a monoid for every a
09:35:47 <ReinH> for the right underlying set, max alone is a monoid, yes
09:35:51 <vanila> (Integer, max, 0) is a monoid
09:36:16 <c_wraith> quchen: max alone isn't a monoid, because a monoid is a function *and* an element.
09:36:17 <fizruk> :t max
09:36:17 <lambdabot> Ord a => a -> a -> a
09:36:26 <ReinH> c_wraith: right
09:36:26 <quchen> c_wraith: That's what I said, yes.
09:36:26 <oio> how can i hSetBuffering stdin NoBuffering and still be able to edit input?
09:36:27 <c_wraith> vanila: (-1) would argue with that
09:36:27 <ReinH> Ok. max alone isn't a monoid.
09:36:28 <vanila> c_wraith, oh what would you argue?
09:36:36 <fizruk> :)
09:36:36 <ReinH> But it's also true that an operator isn't sufficient to define any monoid
09:36:36 <vanila> oh negative  numbers
09:36:40 <c_wraith> vanila: max 0 (-1) is 0, not (-1)
09:36:59 <vanila> yeah, need to ignore negative numbers/remove them
09:37:08 <joelteon> (Nat, max, 0)
09:37:16 <quchen> "max defines a semigroup" is arguably right. "max defines a monoid" is wrong.
09:37:23 <ReinH> quchen: no, neither are right
09:37:27 <vanila> quchen, it's not wrong, it's just informal
09:37:46 <fizbin> vanilla: Either that, or extend integers to include a "negative infinity"-like element.
09:38:56 <ReinH> This monoid forms part of a tropical semiring
09:39:01 <ReinH> http://en.wikipedia.org/wiki/Tropical_semiring
09:40:20 <ReinH> And is an example of the fact that any semigroup can be extended to form a monoid by adding an element to the underlying set and defining it to be the identity element
09:42:08 <quchen> Every semigroup can be extended to a monoid. That's what Maybe does.
09:42:11 <ReinH> (This is the Monoid instance that Maybe should have had.)
09:42:18 <fizbin> I suppose you could form a monoid with Either () Integer, Left (), and a function closely related to max.
09:42:34 <ReinH> fizruk: liftA2 max, yes
09:42:43 <ReinH> and Either () is isomorphic to Maybe
09:42:52 <fizbin> ReinH: No, not quite:
09:43:06 <quchen> Isomorphicic.
09:43:09 <ReinH> ignoring undefined, yes
09:43:11 <fizbin> > (Left ()) `liftA2 max` (Right 4)
09:43:12 <lambdabot>  <hint>:1:19: parse error on input ‘max’
09:43:21 <ReinH> ...
09:43:30 <merijn> fizbin: You can't have partially applied functions infix
09:43:32 <cschneid> ReinH: "The tropical hypersurface can be generalized to a tropical variety by taking the non-archimedean amoeba of ideals" -- you sure that page you linked is a real thing? :)
09:43:43 <ReinH> > max <$> Nothing <*> Just 1
09:43:44 <lambdabot>  Nothing
09:43:46 <fizbin> > let lmx = liftA2 max in (Left ()) `lmx` (Right 5)
09:43:47 <lambdabot>  Left ()
09:43:49 <ReinH> cschneid: yes.
09:43:52 <cschneid> Sufficiently advanced math is indistinguishable from a markov generator.... :)
09:44:01 <cschneid> at least to me
09:44:13 <ReinH> roconnor has a nice page about the usefulness of tropical semirings
09:44:25 <merijn> cschneid: oh, are you familiar with arXiv vs snarXiv?
09:44:35 <fizbin> See, ReinH, with "liftA2 max", you have (Left ()) behaving like 0 does w.r.t. multiplication, whereas I want it to behave as 0 does w.r.t. addition.
09:44:47 <cschneid> merijn: nope.
09:44:52 <ReinH> fizbin: yep
09:44:56 <merijn> cschneid: snarXiv is filled with markov generated paper (titles?)
09:45:04 <merijn> cschneid: It makes you guess which title is real: http://snarxiv.org/vs-arxiv/
09:45:04 <ReinH> fizbin: what you actually want is the correct Monoid instance for Maybe
09:45:11 <merijn> cschneid: I'm worse than a monkey :(
09:45:15 <cschneid> hah
09:45:38 <ReinH> So you could just say `Just (Max 1) <> Nothing'
09:45:54 <ReinH> and not get the spurious Monoid a => Monoid (Maybe a) constraint
09:46:22 <fizbin> ReinH: It seems that your objection to Maybe's Monoid instance is primarily in its constraint, then, not in the computation done. Is that correct?
09:46:30 <ReinH> fizbin: right
09:46:37 <ReinH> the constraint should be Semigroup a => Monoid (Maybe a)
09:46:44 <ReinH> but semigroups aren't in base :/
09:47:05 <ReinH> Option provides the correct Monoid instance but is annoying to work with
09:47:39 <fizbin> So the problem is with an overly restrictive constraint. Plus the same sort of "Monoid should really have a constraint of Semigroup" complaint that's behind the AMP.
09:48:01 <ReinH> fizbin: right
09:48:09 <ReinH> the monoid instance as is is pretty useless
09:48:43 <ReinH> and a significant number of people seem to expect Alternative-like behavior
09:48:58 <quchen> First does that.
09:49:00 <ReinH> rather like I did
09:49:14 <ReinH> True
09:49:36 <bahamas> :i Reader
09:49:44 <fizbin> This kind of complaint really makes me sympathetic to the attitude that typeclasses should be done without, and we should just pass explicit operation objects instead.
09:49:50 <bahamas> @src Reader
09:49:50 <lambdabot> Source not found. I feel much better now.
09:50:14 <ReinH> luckily Alternative forms a monoid even if it doesn't form a Monoid
09:50:30 <fizbin> There was a blog post from... 2010, maybe? ... that laid out the "down with type classes" concept better.
09:50:57 <merijn> fizbin: You mean Tekmo's post?
09:51:18 <merijn> fizbin: Much later than 2010, but: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
09:51:25 <nclarke> Personally, I think that this is an area where Scala has done it 'right', using implicits (but configurable)
09:52:02 <fizbin> merijn: Right, that's the post I meant.
09:52:55 <fizbin> nclarke: I think scala's gotten this mostly right. There are times and situations where I think that more strongly than at other times.
09:53:58 <nclarke> fizbin: Yeah. I think the implicit resolution is horribly complicated by the OO stuff mixed in there, along with assorted stuff like compantion objects
09:54:25 <nclarke> And implicit defs are possibly just a bad idea
09:54:56 <bitemyapp> fizbin: tekmo has since backed off the notions expressed by that post.
09:54:57 <fizbin> nclarke: I'm not so sure of that. There are multiple different uses of implicit defs.
09:55:32 <nclarke> But treating it as a combination of a first-class module system along with implicit objects I think it very powerful
09:56:28 <nclarke> fizbin: There are, but are there many of them which wouldn't be better served by a typeclass-style approach?
09:56:50 <fizbin> For the implicit, silent conversion thing where you can go and add random new operations to an established class by making an implicit def to convert to your class, okay. That's an idea whose potential for abuse may well overwhelm its usefulness.
09:57:26 <nclarke> Hmmm. I would have thought that's one of the better uses :-)
09:57:36 <nclarke> But that's sort of handled by the new implicit class mechanism
09:57:53 <fizbin> However, for making new implicit values (e.g., for making an implicit Converter[List[A]] anytime there's an implicit Converter[A] in scope), that's very nice.
09:58:07 <nclarke> The bigger problem to me is being able to pass a string to something which requires an Int, say, because there's an implicit conversion in scope
09:58:58 <fizbin> nclarke: Yeah. When it's limited to parameters marked implicit already, I don't mind so much. But the magic anywhere aspect of them I find surprising.
10:00:01 <nclarke> That's a good point. I had forgotten their use in extending type-classes
10:00:35 <humanoyd> When using Template Haskell functions, does it matter whether I put $(func) or simply func?
10:00:43 <merijn> humanoyd: Yes
10:00:48 <fizbin> nclarke: So you seem to be making a distinction between implicit conversions that happen upon something that will be the value of "this" inside the function that can now be called and implicit conversions that will happen on things that will be declared parameters in the function that can now be called.
10:00:56 <merijn> humanoyd: simply "func" is only correct at the top level
10:00:56 <fizbin> I suppose I can see that.
10:01:04 <merijn> humanoyd: You need $(func) everywhere else
10:01:16 <nh2> humanoyd: I believe you can choose from $(func) and $func (or is $func also only allowed in certain places?)
10:01:23 <merijn> humanoyd: You used to need $(func) even for top level, but that changed in a recent version
10:01:46 <humanoyd> merijn: Thanks! So I guess it is still good practive to simply put $(...) everywhere?
10:01:49 <nh2> probably making TH very explicit with $() is a good idea
10:01:53 <rmorgan> I have a question about some code I wrote: http://pastebin.com/Y5iWkwB1.  The program is supposed to take a string "ack" and turn it into "acckkk".  However, upon compilation, I receive this message: "strBlowUp.hs:3:61: Not in scope: `l'. Any thoughts?
10:02:23 <vanila>  n <- [1..length ys]
10:02:30 <humanoyd> s/practive/practice
10:02:37 <vanila> would fix that error, but it wont fix the code
10:02:39 <nh2> rmorgan: in list comprehensions, the things after | have lexical scope left to right
10:03:06 <vanila> rmorgan, i think you should make a function String -> Int -> String, so that you can pass the blowup number in recursion
10:03:19 <rmorgan> ahh okay
10:03:28 <vanila> strBlowUp ys@(x:xs) n = replicate n x ++ strBlowUp xs (n+1)
10:04:10 <merijn> Also, contrary to expectactions, list comprehensions aren't used nearly as much as you'd expect :)
10:04:16 <quchen> > let strBlowUp = concat . zipWith replicate [1..] in strBlowUp "hello"
10:04:17 <lambdabot>  "heelllllllooooo"
10:04:33 <nh2> I love list comprehensions and use them a lot
10:04:39 <merijn> quchen: Nice
10:05:09 <merijn> nh2: I used to love list comprehensions for everything in python, now I can't remember the last non-trivial one I wrote (trivial ones being [1..] and [1..10], etc.)
10:05:18 <rmorgan> vanila, yeah, I had tried to implement it without a list comprehension, but couldn't figure out a way to get the integer argument to iterate and have the integer argument to replicate change with each one
10:05:51 <merijn> rmorgan: vanila's example is nice and quchen's is even nicer in terms of elegance :)
10:06:14 <rmorgan> Thanks!  I've started working on The Haskell Road to Logic, Mathematics and Programming, and this is one of the exercises that has gotten me a bit stuck
10:06:28 <merijn> rmorgan: See also the 99 haskell problems
10:06:30 <merijn> @where exercises
10:06:30 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
10:06:46 <quchen> You can also use the (parallel) list comprehension version to achieve the same, if you like the looks of this better.
10:06:47 <quchen> > let strBlowUp xs = concat [ replicate n x | x <- xs | n <- [1..] ] in strBlowUp "hello"
10:06:49 <lambdabot>  "heelllllllooooo"
10:07:41 <rmorgan> merijn: i've made it through about 8 of the 99 problems -- lots of that is pretty hard o.o
10:09:16 <merijn> rmorgan: Well, most of them are fairly straightforward examples of thinking recursively. But until you get the knack for that it's really hard :)
10:09:42 <merijn> quchen: That only works with -XParallelListComprehensions though
10:09:44 <flebron> So c++ is now considering adding future.then(f), to compute f(x) when x is available (it was async). Cross-polinization as it happens :p
10:10:10 <rmorgan> merijn: yeah -- truth is haskell is my second language after R, so there is still so much to learn.  Code is so much cleaner than R, though
10:10:24 <quchen> merijn: Which is why I mentioned "(parallel)" :-þ
10:10:49 <ReinH> rmorgan: R is probably a better language to come from than, say, C
10:11:00 <ReinH> not that C is a bad language, but it sets you up with assumptions that Haskell loves to break
10:12:26 <dawik> haskell is my sixth
10:14:37 <dawik> rmorgan: the code/syntax is the cleanest imo
10:14:55 <flebron> I had a long history of broken affairs before I met Haskell :p
10:15:19 <flebron> (Though to be fair I still have a few paramours on the side, namely C++.)
10:16:32 <dawik> flebron: like newer versions of C++? with immutable types and lambdas?
10:16:55 * dawik codes C professionaly, haskell is my muse, erlang is my ace in the hole :P
10:16:59 <rmorgan> flebron: yeah, i like to cheat on R and Haskell by exploring strange languages like prolog
10:17:06 <merijn> dawik: Poor you :)
10:17:09 <rmorgan> or trying things out in python
10:17:54 <flebron> dawik: Yep. Though I can't always stay atop the ivory tower, and sometimes need to descent to monstrosities like reinterpret_cast and its ilk.
10:18:19 <flebron> (Not like Haskell is free of them, it's basically the same as unsafeCoerce :p)
10:18:28 <nh2> funnily enough, reinterpret_cast is very hard to do in haskell
10:18:35 <nh2> I'm currently writing a library that does it
10:19:21 <nh2> for Word32 <-> Float and Word64 <-> Double for now. I was wondering in this very second how to name the library
10:19:42 <nh2> currently it's called float-cast, but I'm wondering whether I should call it reinterpret-cast
10:20:13 <nh2> that might allow for putting other useful casts in, but Haskellers might not know what this means and find it hard to find the obvious float<->word conversions
10:27:09 <pjdelport> nh2: does data-binary-ieee754 not do this?
10:27:32 <bahamas> I have a question about the Reader monad, specifically the implementation of "bind" here http://dev.stephendiehl.com/hask/#reader-monad. what's the type of "k"?
10:28:01 <n-dolio> a -> r -> b
10:28:20 <n-dolio> Oh, actually, a -> Reader r b.
10:28:29 <n-dolio> But they're equivalent.
10:28:32 <bahamas> n-dolio: yeah, that's what I thought
10:29:00 <nh2> pjdelport: yes, but it uses the slower FFI version of the possibilities discussed at http://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-floa
10:29:00 <pavonia> You just need to replace "m" in the type signature by "Reader r"
10:29:11 <pavonia> :t (>>=)
10:29:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:29:45 <nh2> pjdelport: the one attributed to Simon Marlow (first answer) is around 5 times faster
10:29:46 <quchen> bahamas: (>>=) has type "m a -> (a -> m b) -> m b". Now substitute m for "Reader r", which gives you "Reader r a -> (a -> Reader r b) -> Reader r b". Your definition reads "m >>= k", so m has to have type "Reader r a", and k "a -> Reader r b" to match the type signature of (>>=).
10:30:45 <nh2> of course its quite silly that it's not a no-op at all, but that needs the GHC support
10:30:49 <bahamas> quchen: yeah, I guess I was confused. thanks all
10:33:23 <eizo> how can i get all the strings matching a pattern from a string?
10:33:58 <eizo> > "bla bla hoh" =~ "\\w+" :: [String]
10:33:59 <lambdabot>  Not in scope: ‘=~’
10:33:59 <lambdabot>  Perhaps you meant one of these:
10:33:59 <lambdabot>    ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
10:33:59 <lambdabot>    ‘&~’ (imported from Control.Lens)
10:35:18 <jle`> there's a regexp library somewhere, but haskell has a lot better solutions than regexp
10:35:25 <jle`> regexp is usually a bad idea anyway :|
10:35:37 <dagle> Depends.
10:35:37 <jle`> in any language
10:35:56 <dagle> So, developing your own search syntax is a better solution?
10:36:16 <jle`> parser combinators
10:36:50 <jle`> first-class parsers
10:37:23 <dagle> what? Regex isn't parsers.
10:37:39 <eizo> ok, to be more specific, basically i have a latex file with a bunch of \commands, and i want to filter the "\commands" string which appear only once in the file
10:38:13 <eizo> so i wanted to define the regex: let rr = "\\\\\\w+" and the get all the matches from the file, and filter those which appear only once
10:39:24 <peddie> eizo: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
10:40:11 <eizo> peddie: yes that's what i've been reading; they say "If we use [String], we get a list of every string that matches." but haskell doesn't let me type "bla bla bla" ~= rr :: [String]
10:40:16 <davidfetter> "now you have *two* problems"
10:41:09 <peddie> eizo: isn't it =~ not ~=?
10:41:56 <merijn> eizo: Any specific reason you're not using parsec or similar for parsing?
10:43:51 <peddie> eizo: "blah blah blah" =~ "blah" :: [[String]]    -- seems to work for me
10:44:12 <peddie> eizo: but like everyone else has told you, you should probably look into a parser combinator library instead :)
10:44:51 <eizo> peddie: merijn: do i really need that? i just want to extract substrings of the form "\\\w+"
10:44:52 * hackagebot fay 0.20.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.0 (AdamBergmark)
10:44:54 * hackagebot fay-base 0.19.1.2 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.1.2 (AdamBergmark)
10:44:56 * hackagebot fay-text 0.3.0.2 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.0.2 (AdamBergmark)
10:44:58 * hackagebot snaplet-fay 0.3.3.5 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.5 (AdamBergmark)
10:45:00 * hackagebot fay-builder 0.1.0.7 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.1.0.7 (AdamBergmark)
10:45:38 <eizo> peddie: thanks, i was trying [String] instead of [[String]]
10:47:59 <tremon> in this case, what's wrong with map words? or is \w not the same as [^\S] ?
10:48:24 <geekosaur> it's not
10:48:57 <tremon> oh good. at least it's not my limited haskell knowledge that let me down this time ;)
10:49:04 <geekosaur> \w is [[:letter:][:digit:]_], \S is [^[:space:]]
10:49:05 <Ankhers> \w is effectively [a-z0-9_]
10:49:25 <eizo> ok i was able to extract the strings i wanted, now what's a simple way to get the elements which appear only once? usually i would make a map "element" -> number of times the element appear in the list, and then filter for the elements such that the map == 1
10:49:31 <geekosaur> although [^\S] is better written \s which is whitespace, did you mean that?
10:50:00 <tremon> I meant the collection of all that's not whitespace
10:50:03 <eizo> maybe some kind of "fold" with a Set as an accumulator?
10:50:28 <orion> hmm
10:52:11 <geekosaur> so you wanted \S+?
10:52:56 <pjdelport> eizo: that's a reasonable way to approach ti
10:53:49 <tremon> oh. \S is the complement of \s ? Damn I really need to dust off my regex library
10:54:07 <Earnestly> tremon: \S and \s isn't standard "regex" though
10:54:28 <Earnestly> It's not even extended regex
10:54:42 <geekosaur> right, it's perl / pcre (which are also not quite the same thing)
10:54:53 * hackagebot hblas 0.3.0.1 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.0.1 (CarterSchonwald)
10:57:36 <orion> I want to receive `n' bytes on a TCP socket. Is doing a recursive recv a bad idea?
10:57:40 <Earnestly> geekosaur: awk has a few added bits as well, not sure they use, extended-extended-regex? ;p
10:58:03 <geekosaur> per POSIX it's supposed to be the same as POSIX ERE
10:58:27 <geekosaur> in reality... before POSIX, every utility had its own independent regex implementation, with its own private extensions
10:58:36 <tremon> guess I need to unlearn javascript (yet again)
10:59:08 <eizo> http://lpaste.net/103353 i'm getting a possibly incorrect indentation
10:59:12 <eizo> is the where clause forbidden here?
10:59:50 <vanila> eizo, the | needs to be under the function name addif
10:59:58 <geekosaur> the actual error would be handy. but I think the where itself is permitted (if perhaps not what you intended) but the |s are wrong
11:00:34 <geekosaur> like that, yes, need to be indented beyond the a in addif
11:01:01 <eizo> http://lpaste.net/103354
11:01:10 <eizo> at 13:13 parse error (possibly incorrect indentation or mismatched brackets)
11:01:46 <pavonia> eizo: | has to be further indented than "addif"
11:01:47 <tremon> is there a canonical style for that? I tend to prefer a newline and indent after a where clause, so the function name and guards have a regular indentation
11:02:19 <eizo> oh thanks
11:05:44 <pjdelport> eizo: A simpler way, probably, is to count them in a map.
11:07:47 <jle`> why can't you just put addiff in a let
11:08:00 <eizo> pjdelport: it finally compiles http://lpaste.net/103355, i wasn't able to hoogle a function [a] -> (a -> Int) (which counts all elements at once)
11:09:02 <jle`> best solution is to count them in a map
11:09:07 <jle`> but if you only want one
11:09:10 <jle`> and only one element ever
11:09:25 <jle`> you can just length . filter (== yourthing)
11:09:37 <gilligan_> evening
11:10:32 <jle`> > foldr (\x m -> M.insertWith (+) x 1 m) mempty "hello world how are you today"
11:10:33 <lambdabot>  fromList [(' ',5),('a',2),('d',2),('e',2),('h',2),('l',3),('o',5),('r',2),('...
11:10:55 <jle`> ^ eizo
11:10:58 <jle`> then you can index with !
11:11:02 <jle`> or M.lookup
11:12:17 <eizo> jle`: nice
11:12:20 <pjdelport> eizo, jle`: You can do that more concisely with something like: histogram = fromListWith (+) . (`zip` repeat 1)
11:14:00 <eizo> pjdelport: oh interesting thanks
11:14:18 <fprivacy> Is there a version of ghc that compiles with another implementation such as uhc or jhc?
11:14:26 <eizo> to print my set "s" with new lines in between, i use: print . L.intercalate "\n" . map show . S.toList $ s but that feels wrong
11:14:40 <fprivacy> or hugs
11:15:32 <pjdelport> > let histogram = fromListWith (+) . (`zip` repeat 1); singles m = [k | (k,v) <- assocs m, v == 1] in singles . histogram $ "abracadabra"
11:15:33 <lambdabot>  Not in scope: ‘fromListWith’
11:15:33 <lambdabot>  Perhaps you meant one of these:
11:15:33 <lambdabot>    ‘IM.fromListWith’ (imported from Data.IntMap),
11:15:33 <lambdabot>    ‘M.fromListWith’ (imported from Data.Map),
11:15:33 <lambdabot>    ‘IM.fromAscListWith’ (imported from Data.IntMap)
11:15:49 <pjdelport> > let histogram = M.fromListWith (+) . (`zip` repeat 1); singles m = [k | (k,v) <- M.assocs m, v == 1] in singles . histogram $ "abracadabra"
11:15:50 <lambdabot>  "cd"
11:16:32 <pjdelport> eizo: you can use unlines to add newlines like that
11:16:35 <pjdelport> :t unlines
11:16:36 <lambdabot> [String] -> String
11:17:19 <eizo> pjdelport: thanks i see; but do i still need to S.toList and "map show"?
11:17:28 <quchen> :t F.traverse_ print -- eizo
11:17:29 <lambdabot> (Foldable t, Show a) => t a -> IO ()
11:17:50 <quchen> Ah wait, Set isn't Foldable.
11:18:03 <quchen> Eeeh nevermind.
11:18:08 <quchen> Got confused by "traverse_"
11:18:31 <quchen> Delete this line and the 3 before ;-)
11:18:31 <pjdelport> eizo: I would go the Map route, personally, rather than the two sets.
11:21:29 <reederz> hello guys, I just started learning haskell. Anybody is in charge of http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes page? I think there's a mistake in one of the code examples.
11:21:54 <quchen> What's the mistake?
11:22:54 <eizo> pjdelport: after filtering the map, you just "unlines" and print
11:23:05 <reederz> one of the code examples explaining how you can use indentation does not compile
11:23:24 <reederz> main = do putStrLn "What is 2 + 2?" (the first line)
11:23:59 <quchen> That compiles.
11:24:00 <fprivacy> is unregistered builds of ghc supported in the latest version?
11:24:15 <quchen> reederz: Paste your code?
11:24:18 <geekosaur> looks valid to me
11:24:20 <sgregory_> reederz: it may be a problem with indentation copy/pasting something from html
11:24:33 <reederz> :quchen only compiles if I move putStrLn to the next line
11:24:39 * quchen is going to guess there are tabs involved
11:24:50 <zomg> reederz: sounds like an indentation issue then
11:25:06 <nclarke> > do putStrLn "What is 2+2?"
11:25:07 <lambdabot>  <IO ()>
11:25:08 <quchen> Don't use tabs. Don't make your editor convert spaces to tabs. ಠ_ಠ
11:25:24 <nclarke> Erm... tabs to spaces?
11:25:30 <zomg> quchen: Haskell is the only reason I would want to use spaces :/
11:25:37 <zomg> it gives me mixed feelings
11:25:37 <zomg> lol
11:25:46 <geekosaur> you haven't worked with python yet, have you?
11:25:54 <pjdelport> reederz: Try copying and pasting it again, making sure unintended indentation changes don't sneak in?
11:25:57 <reederz> anw, if I move putStrLn to the next line and indent it- works
11:25:58 <zomg> geekosaur: I have and I recall tabs actually worked sorta ok with it :p
11:26:10 <zomg> I could be mistaken, been a while
11:26:15 <Eduard_Munteanu> They work in Haskell too.
11:26:25 * dmwit_ mutters a mandatory "tabs are fine if you know the rules"
11:26:31 <zomg> Eduard_Munteanu: sure but at least I find doing a lot of more specific indentation in haskell where tabs no longer do the job :)
11:26:35 <joehillen> never use tabs!
11:26:38 <dmwit> http://dmwit.com/tabs
11:26:49 <reederz> so tabs or no tabs?
11:26:50 <pjdelport> dmwit: The rule of "Don't use tabs."? :)
11:26:57 <pjdelport> reederz: No, don't use tabs.
11:27:01 <quchen> Here's everything I have to say about tabs. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
11:27:02 <Eduard_Munteanu> I have mixed feelings about indentation in Haskell too.
11:27:10 <dmwit> I will not say any more than what's on the page I linked, unless there is some new argument not addressed there.
11:27:22 <Eduard_Munteanu> Mainly because lining things up nicely is alright until you realize it's fragile.
11:27:40 <dmwit> I am 99% certain that whatever knockdown argument you think you have against tabs I've already heard it and talked about it.
11:27:44 <Eduard_Munteanu> e.g. patches = reindenting large blocks = large patches :)
11:28:14 <pjdelport> reederz: The code is valid, so the problem is almost certainly some unintended local change. If your editor automatically converts spaces to tabs, for example, that might break the example.
11:28:16 <zomg> I find the issue with something like that is a bit same as one of the primary issues people always seem to quote when you gotabs vs spaces
11:28:28 <zomg> the tools just don't do a good job of dealing with it
11:28:29 <quchen> "n spaces repeatedly" are the achilles heel of modern compression algorithms, yeah.
11:28:44 <Eduard_Munteanu> Which isn't a critique of Haskell, rather one regarding the treatment of code as styled plaintext.
11:28:53 <zomg> I feel with modern tools the issue is much less of a problem with tabs, but certainly version control tools still fail to understand code AST structure which is silly
11:28:59 <reederz> :pjdelport I use tabs. I suppose I should use spaces
11:29:08 <pjdelport> reederz: There's your problem. :)
11:29:17 <pjdelport> Yeah, spaces, definitely.
11:29:19 <dmwit> Ugh. Just paste your code instead of trying to guess what's wrong with it.
11:29:33 <reederz> main = do putStrLn "What is 2 + 2?"
11:29:33 <reederz>           x <- readLn
11:29:33 <reederz>           if x == 4
11:29:33 <reederz>               then putStrLn "You're right!"
11:29:33 <reederz>               else putStrLn "You're wrong!"
11:29:37 <reederz> this doesn't work
11:29:44 <quchen> @paste
11:29:44 <lambdabot> Haskell pastebin: http://lpaste.net/
11:29:44 <reederz> main = do
11:29:44 <reederz> 	putStrLn "What is 2 + 2?"
11:29:44 <reederz> 	x <- readLn
11:29:44 <reederz> 	if x == 4
11:29:44 <reederz> 		then putStrLn "You're right!"
11:29:46 <reederz> 		else putStrLn "You're wrong!"
11:29:49 <quchen> Not here. Paste to LPaste.
11:29:50 <reederz> this does
11:29:53 <reederz> k
11:29:54 <dmwit> ?lpaste
11:29:55 <lambdabot> Haskell pastebin: http://lpaste.net/
11:30:04 <dmwit> Especially since tabs will likely not be preserved correctly here on IRC.
11:30:33 <dmwit> However, I agree that for the style "main = do putStrLn; ..." one should use spaces for alignment.
11:30:43 <dmwit> Since that is not indentation.
11:30:44 <reederz> http://lpaste.net/103356
11:31:22 <dmwit> Your "works" and "doesn't" is completely unrelated to tabs vs. spaces.
11:31:38 <dmwit> if-then-else does not preserve "inside-a-do-block-ness".
11:31:44 <pjdelport> reederz: For the second example, the else block needs a "do"
11:31:47 <dmwit> So if you want a do block inside a branch of an if, use another do.
11:32:08 <pjdelport> reederz: The <- syntax in "sunglasses <- getLine" is part of do blocks
11:32:35 <reederz> k, thanks. Let's do it this way- can someone tell me where I should start?
11:33:04 <dmwit> Start with what?
11:33:08 <reederz> haskell
11:33:15 <Eduard_Munteanu> dmwit: your ideal solution isn't very idealistic, it's in fact a bit pragmatic. :)
11:33:28 <dmwit> I enjoyed the Gentle Introduction, though LYAH+RWH seems a more popular combination these days.
11:33:35 <dmwit> Eduard_Munteanu: Terrible, isn't it? =)
11:34:47 <pjdelport> reederz: I annotated your paste with a syntax-fixed version
11:34:48 <Eduard_Munteanu> dmwit: just not very idealistic... if it were up to me, I'd suggest scrapping the monospaced plaintext file concept of code, in favor of structured code + layout rules (extra markup perhaps).
11:34:51 <croyd> reederz: check out https://gist.github.com/bitemyapp/8739525
11:34:57 * hackagebot cases 0.1.0 - A converter for spinal, snake and camel case  http://hackage.haskell.org/package/cases-0.1.0 (NikitaVolkov)
11:35:27 <dmwit> Eduard_Munteanu: See the second footnote: "I dream of coding in a proportional font.". =)
11:35:47 <Eduard_Munteanu> Oh. Hm, ok. Same page. :)
11:35:55 <dmwit> Eduard_Munteanu: Also, the last "related work" paragraph, on "elastic tabstops, but with some user interface".
11:36:10 <dmwit> That's my true "ideal world".
11:36:13 <dmwit> But we don't live in that one yet.
11:36:15 <reederz> croyd: this is great
11:37:27 <reederz> pjdelport: thx
11:38:33 <Eduard_Munteanu> dmwit: I don't think it's very difficult to make something like that; it might be difficult to integrate it into popular editors like Vim and Emacs though.
11:39:14 <Eduard_Munteanu> They're pretty much hardwired to split the canvas into equal cells, even in the X variants.
11:39:50 <cschneid> the cases lib that hackagebot just mentioned has a top-level Cases package. Is there a guide on when to insert a package into Data.* or Control.* and similar existing trees, and when to make top-level ones?
11:39:58 <n-dolio> Emacs does proportional fonts.
11:41:31 <Eduard_Munteanu> n-dolio: hm, I remember asking #emacs about it and I think the bottom line was it isn't quite usable with proportional fonts. Maybe I misremember though.
11:42:20 <n-dolio> I don't know the details, because I don't use it. But I know that there are modes for making your comments formatted with proportional fonts and such.
11:42:36 <Eduard_Munteanu> Hm, interesting.
11:42:44 <kadoban> That would look so weird to me
11:43:21 <Eduard_Munteanu> There's also the preview-latex stuff, but that renders images.
11:43:49 <n-dolio> Also, working with Agda will sometimes pull in glyphs from fonts with different sizes, and it doesn't cut them off, the alignment just becomes slightly off, as you'd expect.
11:44:02 <klrr_> is a semigroup the same as an Monoid?
11:44:09 <nclarke> klrr_ No
11:44:19 <klrr_> but <+> looks similar to <>
11:44:19 <Iceland_jack> klrr_: monoid is a semigroup + unit element
11:44:24 <klrr_> aa
11:44:27 <klrr_> thanks!
11:44:37 <n-dolio> I can't recall how things work otu vertically, but horizontally I can't recall seeing any problems.
11:45:48 <Eduard_Munteanu> I remember vertical alignment issues with Agda in some cases, but I blamed it on mixing different fonts.
11:46:24 <n-dolio> Yeah. I'm actually not sure what happens. Maybe it's pulling in some of the glyphs from a proportional font.
11:46:43 <n-dolio> Like, some things are clearly wider than the monospace.
11:46:54 <n-dolio> Which would be pretty bad behavior for a monospace font.
11:47:45 <kadoban> I know in vim I had big problems with bold glyphs in a font that were bigger than the usual...it just cuts them off, which I guess is correct behavior, but it looks like crap
11:47:59 <n-dolio> I actually like the idea of that monospace font with ligatures that preserve the multi-character width.
11:48:49 <augur_> seriously people, whats with everyone talking about parametric polymorphism when i asked about free theorems
11:48:49 <dmwit> Vim can do proportional fonts as well.
11:49:00 <dmwit> But it doesn't work very well without "real" elastic tabstops.
11:49:02 <dmwit> I think.
11:49:17 <n-dolio> Vim doesn't display proportional fonts proportionally.
11:49:23 <n-dolio> Unless I'm just missing a setting.
11:49:26 <dmwit> err
11:49:37 <dmwit> Hm, I didn't remember that being a problem. But my memory is notoriously bad.
11:49:41 <n-dolio> It just sets the size of the boxes they're in to the size of the widest character.
11:49:55 <n-dolio> Which looks pretty bad for proportional fonts, usually.
11:51:22 <n-dolio> And if you have characters wider than an M, it cuts them off.
11:51:55 <n-dolio> Oh, you can also turn on a setting for extra-wide characters, and then everything above some ascii range is two boxes wide, which is also not very good.
11:52:12 <kadoban> Yeah, that sounds rather awful
11:54:19 <n-dolio> Free theorems come from parametric polymorphism.
11:56:13 <augur_> seriously, this is ridiculous
11:56:38 <augur_> bring up free theorems and all i get is irrelevant junk on parametricity. wtf people :|
11:56:48 <n-dolio> Free theorems are a special case of parametricity.
11:57:00 <augur_> no, they're a consequence of parametricity
11:57:01 <n-dolio> That is what they are.
11:57:06 <klrr_> what does "a statement that has been proven by previously established statements" mean in haskell?
11:57:51 <Iceland_jack> http://www.reddit.com/r/haskell/comments/24adiv/meditations_on_learning_haskell_from_an_exclojure/ch5903y is this conversation repeating itself on #haskell
11:58:08 <c_wraith> Iceland_jack: it's an infinitely recursive process
11:58:25 <Iceland_jack> God I hope not :)
11:58:26 <bitemyapp> Iceland_jack: yes it is.
11:58:28 <carter> johnw: you're not lurking on #numerical-haskell no more :(
11:58:33 <bitemyapp> Iceland_jack: I'm responsible. I'm sorry.
11:58:36 <augur_> Iceland_jackyes, it is :D
11:58:37 <bitemyapp> carter: release!
11:58:47 <carter> johnw: the benchmarks on the forM thread are bonkders and wrong
11:58:50 <carter> bitemyapp: you did?
11:58:50 <bitemyapp> augur_: so you've read the theorems for free paper?
11:58:58 <bitemyapp> carter: no, it was an imperative aimed at you :)
11:59:04 <carter> i'm workin on it
11:59:06 <Iceland_jack> carter: Thanks for reminding me to re-join the channel :)
11:59:12 <augur_> bitemyapp: yes. im well aware of _what_ free theorems and parametricity are all about
11:59:32 <augur_> but edwardk (i assume edwardk = E) said he uses free theorems to do the work, which is a very interesting thing, if true
11:59:47 <augur_> and all i get in responses is junk about parametricity, which is not a very interesting thing
11:59:57 <carter> augur_: whys it junk
11:59:58 <SrPx> Does anyone have a minimal example of how I could sum 1048576 (1024x1024) numbers in parallel on the GPU?
12:00:05 <carter> SrPx: opencl code
12:00:10 <SrPx> carter: in haskell
12:00:12 <carter> or foldl
12:00:23 <augur_> carter: because its irrelevant to the question
12:00:23 <vanila> wow! can you run haskell on the GPU??
12:00:33 <carter> vanila: nope, you can write a DSL that gets compiled to gpu
12:00:38 <carter> @hackage accelerate
12:00:38 <lambdabot> http://hackage.haskell.org/package/accelerate
12:00:45 <vanila> cool
12:00:48 <SrPx>  that is what I am asking, sorry
12:00:54 <carter> SrPx: foldl
12:00:58 <carter> or par fold
12:01:01 <carter> or whatever
12:02:04 <SrPx> carter: sure I'll try that out, thanks
12:02:15 <carter> SrPx: but have you ever ever writen programs for GPU
12:02:32 <SrPx> carter: only some graphic shaders and similars, why?
12:02:44 <carter> any code that has branching is bad for gpu
12:02:52 <carter> basically
12:03:15 <carter> even more precisely, what performs well is actually gpu card depdendent
12:03:20 <SrPx> carter: yea I was brain dead yesterday when I posted that, it was 4am here lol
12:03:20 <carter> theres some general rules of thumb
12:03:26 <SrPx> carter: but I still want to benchmark to get a feeling of it
12:03:32 <carter> SrPx: then write it
12:03:38 <SrPx> I am trying!!
12:03:39 <SrPx> ):
12:03:50 <carter> thats the other thing
12:03:55 <nh2> carter: can you try wget'ing  the file like I just wrote in the email? The criterion thing looks like a very weird bug
12:04:05 <carter> nh2: nope
12:04:08 <carter> you can wget it :)
12:04:23 <nh2> how do you mean
12:04:28 <carter> you asked me to
12:04:30 <carter> why can't you? :)
12:04:38 <nh2> I already did it and it fixed the problem for me
12:04:41 <carter> oh
12:04:41 <carter> well
12:04:43 <SrPx> carter: to be hyper honest I was trying to do that on webgl as an experiment to see if I could do graph reductions in parallel
12:04:53 <carter> SrPx: skip that, use reduceron
12:04:55 <SrPx> carter: but I have no idea on how to operate on floats instead of those damn Vec4's
12:05:03 <carter> @google reduceron
12:05:04 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
12:05:04 <lambdabot> Title: The Reduceron
12:05:06 <SrPx> carter: ... isn't reduceron a hardware?
12:05:08 <carter> yes
12:05:09 <carter> faster!
12:05:11 <carter> :P
12:05:32 <SrPx> carter: haha lol one day
12:05:40 <carter> SrPx: but.... do you have a use case
12:05:43 <SrPx> carter: I don't have a fgpu
12:05:45 <SrPx> fgpa
12:05:52 <carter> you can get them cheap
12:05:58 <carter> @google cheap fpga
12:06:00 <lambdabot> http://www.joelw.id.au/FPGA/CheapFPGADevelopmentBoards
12:06:01 <lambdabot> Title: Cheap FPGA Development Boards | Joel's Compendium of Total Knowledge
12:06:28 <shapr> carter: or just buy a novena for xtra awesome
12:06:46 <carter> @google novena
12:06:47 <lambdabot> http://en.wikipedia.org/wiki/Novena
12:06:47 <lambdabot> Title: Novena - Wikipedia, the free encyclopedia
12:06:57 <carter> @google novena fpga
12:06:59 <lambdabot> http://www.kosagi.com/w/index.php?title=Novena_Main_Page
12:07:00 <lambdabot> Title: Novena Main Page - Studio Kousagi Wiki
12:07:02 <zerokarmaleft> augur_: https://github.com/ekmett/lens/wiki/Derivation seems like a good example of where free theorems to do the work as the code gets more generalized
12:07:10 <SrPx> carter: but the point of the browser is running on client's computers :C
12:07:11 <augur_> this thread just keeps getting worse and worse
12:07:18 <carter> SrPx: then use wegbl
12:07:20 <SrPx> carter: I'll experiment with reduceron one day for sure
12:07:31 <carter> SrPx: no browser supports webcl
12:07:35 <carter> none
12:07:54 <carter> SrPx: do you really wanna write a accelerate 2 webgl compiler?
12:08:07 <SrPx> carter: yep. while we are on that, I always wondered, if FGPA runs haskell faster than our computers, and Haskell is already almost as fast as C... why aren't people seriously investing in actual reduceron-like processors?
12:08:15 <SrPx> That sounds like the holy grail of gpu computing
12:08:21 <carter> SrPx: you should talk with conal :)
12:08:30 <carter> (conal elliot)
12:08:30 <SrPx> carter: hm maybe? why
12:08:33 <Hodapp> holy grail of GPU computing?
12:08:35 <darthdeus> guys, anyone got an idea why this runs so slow? http://www.reddit.com/r/programming/comments/248abo/range_comprehensions_c/ch56g7b I've tried profiling it but my profiling skills don't really help :\
12:08:38 * Hodapp fills in square on bingo sheet
12:08:42 <quchen> edwardk: How would someone, call him "E", get the free theorems of complex types?
12:08:45 <carter> Hodapp: hahaha
12:08:55 <SrPx> Hodapp: functional computing *
12:09:04 <carter> SrPx: because linkingers
12:09:06 <carter> and tooling
12:09:12 <quchen> edwardk: All I know is @free, does E do it by hand, can @free be used for more complex types somehow?
12:09:21 <carter> quchen: :)
12:09:22 <darthdeus> (i'm not the op)
12:09:28 <carter> its called "write generic code"
12:09:35 <SrPx> Hodapp: ¬¬
12:09:43 <quchen> carter: Was ^^ for me?
12:09:43 <Hodapp> bah?
12:10:01 <ReinH> quchen: I'm not sure how complex you can get but there's http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
12:11:12 <bitemyapp> ReinH: holy shit that is cool.
12:11:22 <zerokarmaleft> wow that's awesome
12:12:58 <quchen> ReinH: Neat, thanks!
12:15:08 <ReinH> quchen: :)
12:15:08 <skypers> hm
12:15:18 <skypers> I want to share a Handle over two threads
12:15:30 <skypers> I put it in a TMVar
12:15:46 <skypers> but I don’t know how I’m supposed to perfom the IO action in STM
12:15:48 <skypers> liftIO?
12:15:57 <quchen> You can't.
12:16:03 <skypers> hm
12:16:21 <skypers> I can’t synchronize Handle?
12:16:46 <edwardk> @remember roconnor oh no. edwardk and I can never meet otherwise it will be revealed that I am actually him in a very short costume.
12:16:46 <lambdabot> It is stored.
12:17:33 <carter> skypers:  only trascational operations are safe in STM
12:17:44 <carter> you can run an STM operation in IO, but not IO in STM
12:18:03 <skypers> ok, so what do I need to synchronize IO?
12:18:10 <skypers> somekind of locks?
12:18:20 <carter> MVar
12:18:55 <skypers> from Control.Concurrent?
12:19:12 <carter> theres only one MVar
12:19:30 <skypers> oh yes
12:19:32 <skypers> something like
12:19:45 <skypers> withMVar :: MVar a -> (a -> IO b) -> IO b
12:19:46 <bitemyapp> akurilin: <3
12:19:50 <skypers> something like that might exist, right?
12:19:56 <quchen> Two thread writing to the same handle is usually not a good idea (what happens when they both write at the same time?). You can do explicit locking, or use a dedicated thread that does only IO and receives instructions over a channel for example.
12:20:12 <c_wraith> skypers: did you check? :P
12:20:17 <skypers> I am
12:20:36 <exicer> I'm trying to use aeson to decode some json returned by a server. Unfortunatley the returned json is interspursed with \n\r. Is there some built-in-to-aeson way of dealing with this ?
12:20:44 <skypers> it exists!
12:20:51 <skypers> with the exact same signature
12:20:55 <skypers> I feel soooo strong right now
12:20:56 <skypers> :D
12:21:18 <c_wraith> skypers: pay attention to the "however" note in its docs, though.  That's an important caveat.
12:22:26 <yorick> sum [1..1000000000] -- runs out of memory?!
12:22:52 <quchen> Yes, 'sum' is non-strict.
12:22:57 <quchen> @src sum
12:22:57 <lambdabot> sum = foldl (+) 0
12:23:21 <quchen> If you want to sum things, I suggest you write your own "sum' = foldl' (+) 0".
12:23:29 <c_wraith> or compile with optimizations enabled
12:23:37 <yorick> quchen: hm, ew.
12:23:46 <skypers> c_wraith: ?
12:23:59 <d1323> why didn't they switch to foldl' when it became available?
12:24:06 <c_wraith> skypers: I was talking to Yoctogon and quchen there
12:24:29 <quchen> d1323: That version would be less polymorphic. :-\
12:24:29 <c_wraith> err, yorick
12:25:08 <quchen> skypers: If another thread puts something in the MVar you're using in withMVar while it's executing, the putMVar will fail, blocking the withMVar thread indefinitely.
12:25:18 <skypers> oh
12:25:23 <skypers> so it’s not synchronized?
12:25:27 <skypers> what’s the point then?
12:25:30 <c_wraith> well, it won't fail, it'll just block
12:25:45 <vanila> "Every time I see a post like this about C++, it reminds me of stoners who claim to have found another incredible utilisation of hemp."
12:25:46 <c_wraith> it's synchronized, it's just not atomic
12:25:47 <vanila> haha
12:25:56 <skypers> quchen: in theory, the other thread can’t do that right?
12:26:03 <skypers> since it’ll wait for the first thread to free the lock
12:26:20 <c_wraith> skypers: mvar isn't a lock.  it's a storage box protected by a lock.
12:26:34 <vanila> so did anyone figur it out ? http://www.reddit.com/r/programming/comments/248abo/range_comprehensions_c/ch56g7b
12:26:40 <vanila> why its slow
12:26:51 <zerokarmaleft> exicer: parse with attoparsec?
12:26:55 <skypers> c_wraith: yep
12:26:57 <skypers> but hm
12:27:02 <skypers> when I do something like
12:27:05 <skypers> withMVar myMVar …
12:27:12 <skypers> it locks, right?
12:27:58 <c_wraith> vanila: wow, that's a terrible algorithm.  it's generating pythagorean triples by generating tons of triples that aren't pythagorean and throwing them out.  Instead of working on them more constructively.
12:28:04 <quchen> withMVar works as follows. 1. Take MVar contents out. 2. Execute action. 3. Put MVar contents back in. 4. Done.  If in part 2 there's another thread filling the MVar, 3. blocks.
12:28:30 <c_wraith> skypers: MVar is still not a lock.
12:28:31 <vanila> that's true but isn't he saying the same [bad] algorithm is much faster in C++?
12:28:50 <c_wraith> skypers: you don't lock an MVar.  They don't have locked/unlocked states.
12:28:59 <c_wraith> skypers: MVars have full/empty states.
12:29:11 <skypers> I don’t get their use then
12:29:37 <kadoban> They can be used to create a huge number of synchronization primitives
12:29:59 <edwardk> Hac Boston is officially a go, August 1st-3rd.
12:30:14 <ReinH> edwardk: oh cool I'll see about coming
12:30:54 <zerokarmaleft> will talks be recorded?
12:30:56 <quchen> c_wraith: You're right, but why do you insist in the distinction here? MVars can be used for purposes similar to locks at least
12:31:00 <BeardedCoder> Who all's going to BayHac?
12:31:09 <ReinH> BeardedCoder: me
12:31:15 <ReinH> BeardedCoder: lots of people it looks like
12:31:24 <zerokarmaleft> for all the poor schmucks that live in the midwest
12:31:26 <BeardedCoder> ReinH: cool, me and a coworker are coming
12:31:28 <c_wraith> skypers: you might think of MVar () as being like a lock, but it's very important to note that the thread that takes the () from it need not be the thread that puts a different () into it.
12:31:53 <skypers> They can be used in multiple different ways:
12:31:55 <skypers> As synchronized mutable variables,
12:32:02 <skypers> so it can snychronize stuff
12:32:35 <paf31_> BeardedCoder: I hope to be there on Sat/Sun
12:33:22 <skypers> so hm
12:33:25 <skypers> I have two threads
12:33:28 <skypers> and a Handle
12:33:30 <c_wraith> skypers: you can use an MVar as a lock, but you have to do it right.  That was my whole point all along.  The docs include a warning on withMVar about when it might work differently than how you think.  Understand that warning, and don't end up in that state.
12:33:50 <BeardedCoder> ReinH: Hey, you mind telling me your name so I can say hi. I don't remember everyones handles
12:34:06 <skypers> c_wraith: yeah but hm
12:34:10 <skypers> I do have race conditions
12:34:41 <skypers> maybe I should reconsider the way I use the Handle
12:36:04 <edwardk> BeardedCoder: I'll be there.
12:36:12 <BeardedCoder> cool
12:36:18 <augur_> edwardk: thank you for the clarification
12:36:20 <edwardk> BeardedCoder: but IIRC there are something like 150+ registrants so far
12:36:37 <BeardedCoder> oh wow, got room?
12:37:02 <carter> BeardedCoder: i might be there, who are you?
12:37:06 <edwardk> BeardedCoder: Hacker Dojo's current digs are huge.
12:37:10 <carter> oh yeah
12:37:11 <carter> they are big
12:37:42 <edwardk> If it was the old dojo from a couple years ago they'd have trouble, but now they should be fine.
12:37:42 <BeardedCoder> My name is Curtis Carter. I work at rackspace. Used to work with tnks. He's started his own team though at RS.
12:38:06 <carter> your name is Curtis, or Curtis Carter
12:38:08 <carter> ?
12:38:18 <BeardedCoder> my last name is Carter =)
12:38:21 <carter> damn it
12:38:24 <carter> theres too many carters
12:38:26 <carter> name space
12:38:28 <BeardedCoder> hehe
12:38:39 <edwardk> We'll just call you Tazio
12:38:51 <carter> :'(
12:38:59 <ReinH> BeardedCoder: I'm Rein Henrichs. Afaik there's only one of me.
12:39:19 <bitemyapp> BeardedCoder: I'm Chris Allen. I successfully cloned myself so there's more than one of me. That's how I keep my twitter account going 24/7.
12:39:27 <bitemyapp> BeardedCoder: also I'm a bear.
12:40:12 <edwardk> bitemyapp: you're not supposed to talk about cloning technology in public or people will figure out how we get stuff done and still chat online all day.
12:40:30 <carter> wait
12:40:31 <carter> darn
12:40:41 <bitemyapp> edwardk: oh right. sorry.
12:40:48 <bitemyapp> BeardedCoder: you heard nothing.
12:40:56 <BeardedCoder> cool, can't wait to meet you guys in person. I got some intermediate Haskell questions I'd like to have an expert help me with.
12:41:02 <edwardk> carter has the chatting online side of the equation down at least ;)
12:41:07 * edwardk ducks.
12:41:22 <carter> ;'(
12:41:28 <carter> edwardk: hey, i've been productive lately
12:41:34 <ReinH> sick burn
12:41:36 <carter> sleep + prescription stimulates + exercise
12:41:42 <carter> *stimulants
12:41:44 <carter> well
12:41:54 <carter> ermm
12:42:10 <quchen> skypers: You can write a small module to get a custom locking mechanism yourself, like so: http://lpaste.net/103363
12:42:37 <quchen> Note that the "Lock" data constructor is not exported, so you cannot fill the MVar from outside by accident.
12:43:09 <skypers> quchen: does it support race condition?
12:43:16 <shelf> wish I could afford to bayhac ;;;
12:43:20 <carter> whats that mean?
12:43:28 <carter> shelf: ... student?
12:44:23 <d1323> "<quchen> d1323: That version would be less polymorphic. :-\" <- why?
12:44:53 <artyomkazak> Which library would you recommend, hscurses or ncurses? They have almost equal downloads counts and the whole curses thing is a new topic for me so I doubt I can understand which one is better purely by reading the docs
12:45:05 <quchen> d1323: Oh, I meant to say "less strict", pardon
12:45:36 <quchen> d1323: sum right now is as general as it can be. Unfortunately that's often not what you need, but changing such a core function is probably hard.
12:46:45 <quchen> And by less strict I mean more strict. I should take a break.
12:47:31 <d1323> you can't sum a list of numbers without summing all of them, no?
12:48:10 <carter> unless you ave a closed form equation
12:50:53 <prinsen> I have several pipes that currencly all has a RWST-monad as its base monad. The pipes communicates with eachoter using the state. However different pipes needs different state, and im stuck how to solve that
12:55:11 <d1323> what makes sum with fold more general than with fold'?
12:55:22 <d1323> foldl and foldl', even
12:57:46 <quchen> Hmm, investigating. I thought there would be a straightforward example for lazy nats (which is what usually breaks these things).
12:59:06 <covi> What is the unsigned val of  -65731789774776 (ie. treated as unsigned long)
12:59:31 <Total_1mmersion> Would the use of the ST monad be appropriate for operations on a list of elements, where the some elements refer to each other?
12:59:57 <c_wraith> Total_1mmersion: the only time it's not appropriate is if it doesn't work.
13:00:13 <c_wraith> Total_1mmersion: well, ok, or when there are faster approaches that don't use it
13:00:25 <dna6> any hints for how, given bounding Data.Scientific values, to generate a new Data.Scientific value randomly within that range?
13:00:39 <quchen> c_wraith: Objection,
13:00:40 <quchen> @quote shachaf length
13:00:40 <lambdabot> shachaf says: (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })  That's the best way to square all the
13:00:40 <lambdabot> elements of a list in Haskell, by far.
13:01:06 <Total_1mmersion> For example: data Op = OInt | OAssg Op; modify :: [Op] -> [Op]
13:01:58 <c_wraith> quchen: which would be why I said the second line
13:02:36 <Total_1mmersion> c_wraith, speed is not a high priority. I just can't figure out how to represent the data besides using a Map Int Op, but unfortunately lookups can fail.
13:03:54 <eikke__> anyone familiar with LiquidHaskell around?
13:03:56 <quchen> c_wraith: I don't think speed is the issue here. If it's wildly unidiomatic, I would say it's inappropriate.
13:03:58 <c_wraith> Total_1mmersion: ok, you've finally provided close to enough context to give a non-useless answer.  If I've got this straight, you're *actually* asking what a good representation for modeling mutable memory cells in a similation is?
13:05:19 <c_wraith> *simulation.  What the heck's a similation?  A simulation of a simile?
13:07:41 <pavonia> the process of making something similar
13:09:17 <dna6> Answering my own question: the best way I found is to first force the Scientific value to a float with:  fromRational . toRational $ scientific :: Float, then make a random Float, then go back to Scientific with fromFloatDigits.
13:09:37 <sedeki> why does [20, 19..1] produce 20,19,...,1 ?
13:10:02 <c_wraith> sedeki: that syntax desugars to enumFromThenTo
13:10:02 <Iceland_jack> sedeki: What did you expect
13:10:28 <Iceland_jack> > [20,19..1]
13:10:30 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
13:10:31 <Iceland_jack> > enumFromThenTo 20 19 1
13:10:32 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
13:10:51 <sedeki> what does "then" mean in that context?
13:11:00 <sedeki> i thought 20 was step
13:11:01 <c_wraith> sequence.
13:11:17 <corgifex> sedeki: dude, are you reading what you're writing?
13:11:18 <c_wraith> first element, then the second element, then the final element
13:11:27 <c_wraith> sedeki: there is no "step"
13:11:28 <corgifex> "why does [20, 19 .. 1] produce 20, 19 ... 1"
13:11:34 <Iceland_jack> > [20,17..1]
13:11:36 <lambdabot>  [20,17,14,11,8,5,2]
13:11:38 <sedeki> aaah
13:11:47 <Iceland_jack> here the 'step' is -3
13:11:52 <Iceland_jack> if you will
13:21:20 * hackagebot hashtables-plus 0.2.0 - Extensions for a "hashtables" library  http://hackage.haskell.org/package/hashtables-plus-0.2.0 (NikitaVolkov)
13:21:22 * hackagebot jcdecaux-vls 0.1.0 - JCDecaux self-service bicycles API client  http://hackage.haskell.org/package/jcdecaux-vls-0.1.0 (Herzult)
13:23:53 <quchen> d1323: Hmm, I can't come up with anything. I'm confused now :-(
13:28:51 <d1323> quchen, that makes two of us :)
13:29:31 <tomejaguar> Can I get cabal to build just one of my many executables?
13:30:11 <quchen> d1323: HA! http://lpaste.net/103365
13:30:28 <identity> tomejaguar: won't it just build the one you changed?
13:30:48 <quchen> Ah wait. Crap.
13:30:49 <identity> or do you have executables that share dependencies?
13:30:52 <quchen> Hold on! :-D
13:31:51 <tnks> heard my name. . . yeah, I worked with BeardedCoder; carter, we met at NEScala this year (ate with copumpkin).
13:31:58 <carter> oh yeah
13:31:59 <apples> RIP
13:32:01 <carter> that was fun
13:32:05 <tnks> yeah.
13:32:30 <apples> oops, sorry, wrong channel
13:32:32 <tomejaguar> identity: Well yes it will, but it still takes some time deciding that the other ones don't need to be built.  Actually I think it links them all as well because they all depend on the library in the same cabal file.
13:33:45 <tnks> bitemyapp: I'm working towards getting everything you asked for at Rackspace; a room with a lot of computers kicked to Ubuntu with VirtualBox installed.
13:33:57 <tnks> and a screen you can present on, if necessary.
13:34:04 <bitemyapp> tnks: <3
13:34:13 <bitemyapp> tnks: that would be amazing.
13:34:15 <BeardedCoder> tnks: woah, when is this happening?
13:34:36 <tnks> BeardedCoder: yes. . . I'm talking to bringing to the room next door to your team!
13:34:49 <tnks> talking to our IT folks and the culture people.
13:35:10 <BeardedCoder> tnks: What type of event?
13:35:36 <tnks> BeardedCoder: well it's kind of up to bitemyapp, but he's got some material to work through in a lab settings.
13:35:44 <tnks> maybe something along the lines of the NICTA class.
13:35:52 <BeardedCoder> tnks: In Haskell?
13:35:56 <tnks> and he suggested biweekly labs. . . maybe monthly.
13:35:57 <bitemyapp> tnks: probably Yorgey course exercises, they're gentler.
13:35:58 <tnks> yeah, in Haskell.
13:36:05 <tnks> that's the point.
13:36:12 <bitemyapp> NICTA course is *thorough* but it will brutalize people that don't have any prior experience.
13:36:24 <bitemyapp> good follow-up if you want a "kata-esque" experience after learning via the Yorgey course.
13:36:24 <tnks> so we'd work with stdlib (is he here?) to kind of fold it into the Austin Haskell Meetup.
13:36:28 <tnks> probably advertise it there.
13:36:38 <bitemyapp> tnks: yeah he seemed interested. he's thoughtpolice on here though.
13:37:02 <tnks> awesome, I assumed you all know each other and are mutually supportive.
13:37:05 <bitemyapp> tnks: I know who you are, who's BeardedCoder? BH?
13:37:19 <bitemyapp> I haven't met thoughtpolice yet, only bugged him on IRC a couple of times. :)
13:37:20 <tnks> he'd the guy I mentioned running a Yesod app at Rackspace.
13:37:24 <tnks> from my previous team.
13:37:26 <BeardedCoder> I'm Curtis
13:37:28 <bitemyapp> tnks: oh sweet.
13:37:31 <bitemyapp> BeardedCoder: hi friend!
13:37:52 <bitemyapp> BeardedCoder: I came to ATX from SF 3 months ago, trying to continue my Haskell teachins' here :)
13:38:00 <tnks> I don't think Rackspace is completely ready for the "Powered by Haskell" press.
13:38:11 <BeardedCoder> hehe
13:38:23 <tnks> but hopefully we can get enough stability between our two groups to concretely say "powered by type-checked FP"
13:38:43 <bitemyapp> "Free theorems protect your servers!"
13:38:54 <tnks> hell yeah.
13:39:24 <tnks> BeardedCoder and I talk about how some of our T-Shirts have logos that don't make sense.
13:39:32 <BeardedCoder> bitemyapp: ya awesome. Didn't realize you were in Austin.
13:39:50 <BeardedCoder> Ya, "No More Servers" haha
13:41:00 <jnj> Is there any way to shorten f :: (TypeC a,TypeC b,TypeC c) => .. (a,b and c are required to all be an instance of TypeC)
13:43:38 <quchen> d1323: That should be it. http://lpaste.net/103366
13:43:43 <jfischoff> can more than one thread share the same socket, or will the data get interleaved when sent and recieved?
13:44:01 <yorick> http://pastie.org/private/ui0xqzjg0wp4du32eakliq hey, I'm trying to make this function strict, but have no idea where to sprinkle $! and `seq`. can anyone help?
13:44:31 <bitemyapp> jfischoff: need a queue
13:44:43 <bitemyapp> jfischoff: in Clojure I use agents, in Haskell you'd use channels or MVar.
13:44:59 <identity> yorick: You could consider looking at bangpatterns, which make some stuff easier for you
13:45:09 <jfischoff> bitemyapp: heh wrong channel, but thanks that what I thought
13:45:14 <bitemyapp> jfischoff: incidentally, all the guarantees of TCP weaken to UDP's the moment you use more than one socket to communicate with the same service :)
13:45:18 <identity> And you should consider profiling your application as well, and looking at the output, which will probably teach you more
13:45:30 <identity> (The section on profiling in RWH is pretty decent IMO)
13:45:50 <bitemyapp> jfischoff: np. wrote a pipe-lined database client over TCP + protobufs. Only reason I know this.
13:46:01 <bitemyapp> agents + promises
13:46:20 <identity> agents and promises. Ah, Hollywood.
13:46:24 <yorick> identity: this is my profiling output: http://dl.dropbox.com/u/22989236/temp/20140429223921.png
13:47:35 <identity> yorick: It's a bit hard to help in detail without real context, but if you want to make it more strict, and 'add' is lazy, you could use the BangPatterns extension and put a bang in front of newC
13:49:43 <identity> yorick: As for general tips for efficiency, based on your small code example: You're appending to the end of a list which is O(n) and thus not awesome if you're doing it a lot or for large lists
13:50:22 <yorick> identity: the list isn't ever going to be more than 10
13:50:28 <identity> alright
13:52:35 <yorick> identity: do all of the things I use in `add` have to be lazy?
13:56:12 <identity> yorick: it's really hard to say without any real context
13:56:50 <identity> let's say you're appending to a really long list.. then you don't want to evaluate the entire list just to append to it. Strictness isn't the solutino to all efficiency problems
14:03:46 <carter> bitemyapp: as far as I can tell, mvars are strictly more awesome than promises
14:07:10 <michaelbaker> More awesome in what respect?
14:08:45 <bitemyapp> carter: promises in conventional languages are IVars.
14:08:57 <bitemyapp> carter: what's awesome or not depends on how "big" you want the type to be and what semantics you want to allow.
14:09:06 <carter> fair
14:09:14 <carter> i justlike the blocking semantics mvar does
14:09:17 <carter> the more i understand it
14:09:20 <bitemyapp> carter: IVar blocks too.
14:09:21 <carter> the more i think "oh, thats clever"
14:09:28 <bitemyapp> but it's write-once
14:09:48 <bitemyapp> I like the cycle-resolution Clojure does with its promises, I haven't investigated how that looks with IVar/Mvar
14:10:03 <bitemyapp> carter: a comparable situation would be when I used Seminearring instead of Alternative, because Alternative was imprecise/too big.
14:10:14 <bitemyapp> I wanted strictly Seminearring only.
14:10:21 <carter> IVar is a write once Mvar right?
14:10:24 <bitemyapp> yeah.
14:10:32 <bitemyapp> carter: do MVars do cycle resolution?
14:10:39 <bitemyapp> or do I get a dead lock if MVars depend on each other?
14:10:49 <carter> if you ahve cycles, use STMVars
14:10:56 <carter> or whatever they're called
14:11:01 <bitemyapp> in Clojure I can deliver to one promise that a cycle depends on and it will unravel.
14:11:04 <bitemyapp> carter: TVar?
14:11:07 <carter> yes
14:11:15 <bitemyapp> I should test this.
14:11:17 <carter> because progress doesn't break
14:11:21 <carter> when you have a cycle
14:11:25 <carter> but fairness does
14:11:29 <bitemyapp> I believe you, I just think I should test this.
14:11:32 <carter> yeah
14:11:53 <bitemyapp> now I'm wondering if the Clojure version resorts to using the STM for solving this problem. Seems doubtful.
14:11:54 <carter> i think as long as you stick to a DAG like data flow grph, mvars are safe and fster
14:11:56 <tomejaguar> What happens if you write to an IVar twice?
14:12:07 <carter> @hoogle Ivar
14:12:08 <lambdabot> package ivar-simple
14:12:08 <lambdabot> Network.CGI.Protocol cgiVars :: CGIRequest -> Map String String
14:12:08 <lambdabot> Network.CGI.Monad cgiVars :: CGIRequest -> Map String String
14:12:12 <carter> @hoogle IVar
14:12:13 <lambdabot> package ivar-simple
14:12:13 <lambdabot> Network.CGI.Protocol cgiVars :: CGIRequest -> Map String String
14:12:13 <lambdabot> Network.CGI.Monad cgiVars :: CGIRequest -> Map String String
14:12:18 <bitemyapp> @hoogle data-ivar
14:12:18 <lambdabot> package data-ivar
14:12:19 <carter> ummm
14:12:32 <carter> https://hackage.haskell.org/package/lvish
14:12:37 <bitemyapp> tomejaguar: http://hackage.haskell.org/package/data-ivar-0.30/docs/Data-IVar.html
14:12:46 <carter> http://www.cs.indiana.edu/~rrnewton/haddock/lvish/Data-LVar-IVar.html
14:12:59 <bitemyapp> "Write a value to an IVar. If the IVar already has a value, throws an error "Attempt to write to an IVar twice" "
14:13:02 <bitemyapp> tomejaguar: so, "don't do that"
14:13:11 <tomejaguar> Yeah, that sounds sad :(
14:13:22 <carter> http://www.cs.indiana.edu/~rrnewton/haddock/lvish/Data-LVar-IVar.html is another one
14:13:23 <tomejaguar> What happens if you write to an MVar when it currently contains a value?
14:13:30 <bitemyapp> tomejaguar: in my world, it's better to crash and die than to mutate something that isn't supposed to be mutated.
14:13:32 <carter> Put a value into an IVar. Multiple puts to the same IVar are not allowed, and result in a runtime error, unless the values put happen to be (==).
14:13:45 <tomejaguar> bitemyapp: Yeah but I was hoping for a typechecked property :(
14:13:49 <carter> tomejaguar: bitemyapp  i'm now comfy doing unholy type class recursions
14:13:52 <carter> is weird
14:14:02 <bitemyapp> tomejaguar: that requires linear or dependent typing I'm pretty sure.
14:14:07 <tomejaguar> "Put a value into an MVar. If the MVar is currently full, putMVar will wait until it becomes empty. "  That's nice.
14:14:13 <tomejaguar> bitemyapp: Or indexed monads?
14:14:13 <bitemyapp> tomejaguar: you could wrap it in an indexed.
14:14:19 <tomejaguar> Yeah
14:14:24 <bitemyapp> right, but you have to do it yourself.
14:14:28 <tomejaguar> Sure
14:14:34 <tomejaguar> I probably would
14:14:37 <tomejaguar> but then I'm crazy like that
14:14:40 <bitemyapp> sounds like a blog post to me.
14:14:44 <tomejaguar> Hahah
14:14:48 <bitemyapp> wrapping IVars with indexed monads for put type-safety.
14:14:56 <bitemyapp> I'm serious. I was wondering what to post on next anyway.
14:15:11 <carter> i have a lot of cool tricks internally in numerical-core that sound cool, but i dont think people should generally use
14:15:12 <tomejaguar> Please do, I think it would be great.
14:15:17 <carter> but are worth it for the internals to be good
14:15:21 <tomejaguar> carter: Sounds like a blog post to me.
14:15:26 <carter> nope
14:15:40 <MrRacoon> win 12
14:15:44 <simukis_> how does one properly generate compiler errors in a QuasiQuoter?
14:15:44 <simukis_> `error "error message"` inside quoteExp doesn’t quite work as it stops the whole compilation and other errors won’t be printed.
14:15:49 <bitemyapp> tomejaguar: I've talked to carter about some of his voodoo, you really don't want Haskellers going nuts with that stuff :)
14:15:49 <tomejaguar> bitemyapp: By the way I first thought of this idea when thinking about how to prevent a 0MQ socket being written to when it's in a write state.
14:16:10 <bitemyapp> tomejaguar: I just got done telling jfischoff about how to manage sockets.
14:16:31 <carter> bitemyapp: tomejaguar   arelaly great thing about mvars is when you're blocked on a reador write,  the thread idles
14:16:46 <bitemyapp> tomejaguar: I made an asynchronous and pipelined database client connection manager in Clojure, used serialized queues for in/out (agents) and promises.
14:17:00 <bitemyapp> tomejaguar: I could replicate the same deal with channels/mvars + IVars + forkIO
14:17:05 <tomejaguar> Yeah these concurrency primatives look really cool.  I should think of a problem that needs concurrent programming so I can implement it.
14:17:08 <bitemyapp> separate reader and writer threads too :)
14:17:36 <bitemyapp> I'm pretty sure the client I wrote is the most efficient community made db-driver for RethinkDB.
14:17:37 <tomejaguar> Well I look forward to this blog post :)
14:18:04 <tomejaguar> Nice recent Reddit post by the way.  I had fun arguing on that :)
14:18:19 <bitemyapp> tomejaguar: thanks. Yeah I thought throwing a steak into the dog pound would be fun.
14:18:27 <bitemyapp> most of the other ones are completely synchronous or single connection. Mine allowed arbitrary n-connections + async + pipelining.
14:18:46 <carter> bitemyapp: rethinkdb seems neat, i've yet to have something thats a good match for it
14:19:00 <tomejaguar> bitemyapp: How did you learn concurrent stuff?
14:19:03 <carter> the whole "you only have doubleas as numbers" thing freaked me out
14:19:10 <bitemyapp> incidentally, you can't write a nice db client like that without out-of-order response id stamping.
14:19:23 <bitemyapp> carter: sigh, yeah. JSON.
14:19:24 <tomejaguar> carter: Err that sounds scary :(
14:19:30 <bitemyapp> carter: that's my least favorite thing about RethinkDB.
14:19:37 <carter> bitemyapp: out of order ids is also IMAP
14:19:38 <bitemyapp> I wish they'd standardized on a faux-JSON type like MongoDB.
14:19:47 <bitemyapp> tomejaguar: fucking around, reading. I didn't go to Uni.
14:20:08 <carter> bitemyapp: i actually wanna do  a "properly haskelly transcation IMAP" haskell lib
14:20:10 <bitemyapp> tomejaguar: one thing you have to be super careful about with concurrency is you can write something that is actually broken/will lose data/will corrupt data but will seem to "test out" okay.
14:20:11 <carter> for imap
14:20:13 <carter> at some point
14:20:27 <bitemyapp> carter: hrm. I wonder what that would look like.
14:20:34 <carter> becaue the right way to handle IMAP is to heavily pipeline your operations
14:20:45 <carter> and also allow the result to run in the order you get them
14:20:51 <bitemyapp> tomejaguar: so you need some formal theory foundations to validate how you're thinking about the stuff. There's a lot of cross-over between databases/concurrency/distributed systems.
14:21:01 <carter> which means you need to have your "callbacks" for each query be transactional
14:21:10 <bitemyapp> tomejaguar: just reading up on CAP can help improve your understanding a lot.
14:21:11 <yorick> identity: I'm folding over a list to make a (Data.Trie, Data.Map)
14:21:25 <bitemyapp> tomejaguar: this book is excellent: http://chimera.labs.oreilly.com/books/1230000000929
14:21:28 <carter> tomejaguar: bitemyapp  or you could read this:  http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:21:33 <carter> these are the best lecture notes i know about http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:21:40 <bitemyapp> carter: maybe I should make a gist on github for learning concurrency, dist-sys, etc?
14:21:45 <carter> yes
14:21:54 <bitemyapp> tomejaguar: also: http://aphyr.com/tags/jepsen
14:21:56 <MingsPing> hi, i've got a question about some "debugging": what is the easiest (not prettiest or safest) method of printing something out even if i am in a pure function? (my function is fun :: [[Int]] -> [[Int]] but I want to see, what some elements are doing, so printing something out would be nice, without changing everything to IO)
14:21:57 <carter> also http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:21:58 <carter> http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:21:59 <carter> http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:22:01 <carter> http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:22:04 <carter> ok?
14:22:05 <bitemyapp> carter: easy there killer.
14:22:06 <carter> :)
14:22:07 <tomejaguar> What all of them?
14:22:11 <carter> just this http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf
14:22:16 <carter> start there
14:22:20 <carter> if you want the theory
14:22:32 <carter> its the only sane exposition of all the theory i've seen
14:22:38 <carter> (and i took the class it went with)
14:23:03 <bitemyapp> tomejaguar: you don't have to go down a theoretical rabbit-hole. You can play around and learn via Marlow's book and then start on some theory once you have a basic idea of what you want in place.
14:23:13 <tomejaguar> I've got interested in concurrent programming all of a sudden.  This is dangerous.
14:23:20 <carter> yup
14:23:22 <carter> very dangerious
14:23:30 <bitemyapp> tomejaguar: an example of what I mean by making something dangerous because you don't understand the theory is what I said about multiple TCP sockets.
14:23:50 <mietek> Is there a way to specify a custom cabal config location somewhere, to avoid having to say "cabal --config-file=$FOO" each time?
14:24:09 <bitemyapp> tomejaguar: TCP provides various guarantees, such as ordering, but if you use more than one TCP socket to the same service those guarantees evaporate and you're actually now dealing with the same guarantees as UDP, but in TCP's clothing.
14:24:11 <mietek> Or, should I just symlink ~/.cabal/config?
14:24:56 <tomejaguar> bitemyapp: Ah that sounds like a quagmire of open research questions! :)
14:25:12 <mietek> carter: cool beans
14:25:15 <bitemyapp> tomejaguar: anyway, I'm kinda bad at dist-sys/concurrency stuff, but I do really enjoy it.
14:25:18 <bitemyapp> I love databases too.
14:25:28 <bitemyapp> tons-o-fun.
14:25:33 <carter> mietek: what OS
14:25:45 <carter> just accept ~/.cabal/config
14:25:50 <carter> and ignore the OCD :)
14:26:17 <carter> mietek: do you have a godo reason for doing it?
14:26:25 <mietek> I have a good reason for doing it
14:26:29 <bitemyapp> carter: my next library will probably be named after a French political economist.
14:26:36 <carter> mietek: whats the reason
14:26:40 <carter> and what OS
14:26:51 <mietek> Automating things; UN*X
14:26:55 <carter> you could write a wrapper script for the cabal
14:27:05 <carter> that always provides that flag
14:27:08 <mietek> Sure.
14:27:23 <zq> can cabal be told to compile in parallel?
14:27:40 <zq> right now a plain old cabal build only hits one core
14:27:43 <mietek> zq: it should be doing this by default in 1.20.0.0
14:27:54 <mietek> zq: "jobs: $ncups" in ~/.cabal/config
14:27:57 <carter> yeah, make sure you ahve an up to date cabal config
14:28:00 <mietek> zq: or "-j" on the command line
14:28:05 <d1323> quchen, interesting. so it may matter with sum in some cases. but as far as I can see, foldl' is not used anywhere in the standard library, even where it wouldn't make a difference (apart from not potentially blowing up memory). what is the reason for that?
14:28:12 <mietek> zq:  $ncpus  rather
14:28:16 <zq> mietek: there's a 1.20 now?
14:28:26 <mietek> zq: yes, and it's interesting
14:28:40 <zq> just installed 1.19 a few weeks ago
14:29:00 <mietek> If only there was a way to avoid installing things altogether...!
14:29:17 <tomejaguar> 7.6 is much faster than 7.4
14:29:44 <mietek> zq: BTW, "-j" ought to work with earlier cabal-install, too
14:29:48 <carter> tomejaguar: and 7.8 has -j
14:30:03 <tomejaguar> Yeah I'm not allowed to use that.
14:31:19 <mietek> So has anyone else ran into "Setup: /usr/bin/ar: permission denied" when bootstrapping cabal-install 1.20.0.0 with ghc-7.6.3 yet?
14:31:30 <quchen> d1323: Historical reasons, mostly. The examples where foldl is strictly better than foldl' are usually pretty artificial.
14:32:22 <carter> mietek: #hackage is the channel to ask for help
14:32:35 <mietek> Thanks, I am on it
14:33:22 <zq> mietek: thanks for -j
14:33:46 <zq> mietek: well no, -j doesn't merely installs but not build in parallel
14:33:59 <mietek> zq: come again?
14:34:26 <tomejaguar> mietek: Have you tried to build on a pristine Ubuntu 10.04 yet?
14:34:43 <quchen> d1323: I think everyone here who has legitimately used foldl over foldl' knows that story forever ;-)
14:35:00 <zq> mietek: cabal install -jN doesn't build the package at ./ with N jobs
14:35:20 <mietek> zq: have you tried just "-j"?
14:35:46 <mietek> tomejaguar: no.  I don't see that as helpful to solving the ar question
14:36:30 * hackagebot codex 0.0.1.7 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.1.7 (aloiscochard)
14:36:38 <awestroke> are there any plans on more fine-grained control over how  GHC chooses package versions? That would solve a lot of cabal problems
14:36:59 <bitemyapp> awestroke: you can force a particular package version with cabal install.
14:37:00 <mietek> tomejaguar: ghc-7.8.2+cabal-install-1.20.0.0 bootstraps fine; it's just ghc-7.6.3+cabal-install-1.20.0.0 — and I think I had the same failure on my local machine, which is OS X
14:37:29 <bitemyapp> Ubuntu 10.04? Yeesh.
14:37:36 <bitemyapp> tomejaguar: do you mean 12.04?
14:38:01 <tomejaguar> mietek: Ah I see.  I guess people must have come across it then.
14:38:07 <mietek> awestroke: with cabal-install-1.20.0.0, you can do a "cabal freeze" and get a cabal.config file out, with exact version numbers of each package in your dependency tree
14:38:11 <tristan__> 7what is someone trying to build on 10.04?
14:38:17 <tristan__> I build a couple apps on 10.04
14:38:20 <tomejaguar> bitemyapp: Ubuntu 10.04 is LTS I think and it's what Heroku uses, according to Mietek.
14:38:21 <mietek> 10.04 is not the point
14:38:36 <tomejaguar> Yes that was my completely irrevelant diversion, sorry.
14:38:37 <awestroke> bitemyapp: but I can't have several versions of a package installed, and right now I must break some of my packages to install criterion due to version conflicts (even with --upgrade-dependencies)
14:38:41 <mietek> The question is, has anyone tried to bootstrap cabal-install-1.20.0.0 with ghc-7.6.3, at all
14:38:48 <bitemyapp> tomejaguar: current LTS is 14.04, previous was 12.04
14:38:56 <bitemyapp> tomejaguar: 10.04 is annnnnnciiieeeennnnt
14:39:00 <tomejaguar> OK ignore me, I don't know what I'm talking about.
14:39:07 <bitemyapp> it's okay, just saying.
14:39:09 <tristan__> 10.04 is still maintained until 2015
14:39:20 <bitemyapp> 10.04 *was* LTS, it's just the oldest still supported one.
14:40:06 <tomejaguar> Anyway, mietek's point is that cabal-install-1.20.0.0 doesn't seem to bootstrap with ghc-7.6.3
14:40:49 <bitemyapp> tomejaguar: really? it did on my thinkpad.
14:41:02 <bitemyapp> mac is 7.8 + 1.20, Thinkpad is 7.6 + 1.20
14:41:09 <bitemyapp> Ubuntu 14.04 :P
14:41:09 <mietek> 7.6.3?
14:41:17 <bitemyapp> mietek: yessum.
14:41:25 <mietek> hm
14:41:42 <mietek> Can you look through your ghc-pkg for Cabal-1.20?
14:42:02 <bitemyapp> not riiiight now, working.
14:42:06 <bitemyapp> mietek: but if you're here later tonight, yes.
14:42:08 <mietek> As in, do you have the Cabal-1.20 library installed?
14:42:14 <mietek> I am always here. Lurking.
14:42:21 <bitemyapp> in the darkness...in wait...
14:47:52 <awestroke> cabal install x --upgrade-dependencies --force-reinstalls does what I want, without breaking everything too!
14:47:59 <awestroke> it should be advertised more
14:48:44 <carter> ..... its not guaranteed to afaik :)
14:49:41 <bitemyapp> awestroke: brave.
14:50:59 <awestroke> bitemyapp: what else should I do if I have packages x and y but can't get z otherwise? Nuke and attempt "cabal install x y z" ?
14:51:17 <carter> nuke === "rm ~/.ghc"
14:51:18 <carter> :)
14:51:45 <bitemyapp> awestroke: I think your command is fine, but when I do that I'm prepared to nuke the universe is if it gets ugly :)
14:52:13 <carter> never do a global iinstall
14:52:15 <carter> or you'll be sad
14:52:17 <carter> NVER
14:52:19 <bitemyapp> ^^ yep.
14:52:31 <carter> then you'll have to burn you whole install of ghc
14:52:42 <carter> unless you know how to do surgery
14:52:46 <bitemyapp> carter: I really think that should go to more trouble to lock out global installs.
14:53:02 <carter> cant
14:53:14 <carter> runghc setup.hs will defualt to global
14:53:19 <carter> cabal defalts to user
14:54:18 <carter> bitemyapp: my solution is to refuse to provide surgery in that case :)
14:54:31 <carter> "sorry, you have to kill it"
14:54:56 <int-e> well, installing ghc isn't that hard
14:55:17 <carter> yup
14:55:23 <carter> and it cures all crazies
14:56:19 <LordBrain> I wish i could scroll back before I came in
14:56:55 <carter> LordBrain: znc
14:57:32 <LordBrain> Those letters mean nothing to me
14:58:22 <carter> @google znc
14:58:23 <lambdabot> http://znc.in/
14:58:23 <lambdabot> Title: ZNC
14:58:34 <carter> is how you can get scroll back
14:59:20 <LordBrain> oh i see
14:59:55 <tomejaguar> Typechecking in 7.6 really is superfast.  -fno-code whizzes by.
14:59:56 <LordBrain> well, is surgery a cabalized package? Or are you talking about actually cutting people?
15:00:18 <carter> LordBrain: no, talking aobut never use cabal install --global
15:00:19 <carter> everrr
15:01:00 <LordBrain> you'd have to run it as root to do that, right?
15:01:06 <carter> depends
15:01:07 <mietek> awestroke: require-sandbox: True
15:01:35 <zomg> How far does it make sense to take the sort of monadic type safety you can get via stuff like reader/state/writer etc.?
15:01:54 <zomg> Basically I have a changing state, and a set of functions which depend on a variety of parts on said state
15:01:58 <zomg> but those functions never change the state
15:02:10 <zomg> then there's a handful of functions which do change it
15:02:33 <zomg> would it make sense to wrap it so the non-mutating ones would receive it wrapped in a reader or something? Or does this border on over-engineering?
15:03:33 <mmachenry1> zomg: That's a pretty deep question and involves a lot of decisions personal to your project and potentially team.
15:04:04 <mmachenry1> zomg: I'd say, in general, if it's state that you are mutating just not in a particular function, go ahead and keep it in the state monad.
15:04:16 <tomejaguar> zomg: I wouldn't bother doing that kind of thing until you've got a working program.  Then go back and tighten up the types.  I have even found bugs that way!
15:05:07 <mmachenry1> zomg: But there's definitely a line where you want to protect certain code from changing it. Especially if it's likely to be changing a lot and it's important because, perhaps, it's in a sector of the code that needs to be kept ignorant of issue in the other branch.
15:05:18 <mmachenry1> You might want to set up some kind of guarantee there.
15:05:19 <zomg> mmachenry1: ok, figured it might be something that might depend on a more case by case analysis of the situation
15:05:34 <zomg> tomejaguar: yep, that's actually what I'm doing :) wrote something that is now working and wanted to clean it up a bit
15:05:51 <mmachenry> In short, it becomes less of a Haskell question and more of a good software engineering question which always depends very heavily on the project.
15:05:55 <mizu_no_oto> What's the easiest way to create lenses for custom datatypes that work with Aeson?  i.e. what's the best way to make something like "foo :: AsValue t => Traversal' t Foo" so I can say "key "bar" . key "baz" . foo"?
15:06:27 <tomejaguar> zomg: I say go for it.  Worst case you'll learn the situations in which it's too much bother to be worthwhile.   Best case, you'll find some bugs!
15:07:00 <zomg> yeah I think I'll see if it would actually make the code more or less clunky :)
15:07:30 <zomg> it's just a personal project that I did for fun (hello world open 2014 bot) so can pretty much do whatever I feel like with it :P
15:07:32 <mmachenry> tomejaguar: Not bad idea.
15:08:20 <bitemyapp> zomg: I try to avoid premature type-hardening.
15:08:34 <bitemyapp> I prefer to do it in layers.
15:08:52 <bitemyapp> that said, working from the abstract rather than the concrete from the start can have benefits if you can do it.
15:09:05 <bitemyapp> and working abstractly can mean better typed code from the start.
15:10:27 <zomg> Yep
15:10:57 <zomg> Need to see if I can make it work in some neat way without having to resort to some nonsense like having to do runReaderT blah blah every time I want to call one of the non-mutating ones from the mutating kinds :P
15:11:03 <exicer> I've heard it mentioned that generally exceptions are not a good way to deal with errors. In this article they make pretty heavy use of them (https://www.fpcomplete.com/school/to-infinity-and-beyond/competition-winners/interfacing-with-restful-json-apis), and I don't see why they are bad. Can anyone enlighten me?
15:12:48 <LordBrain> they're bad in haskell... because they are less predictable in a purely functional lazy language.
15:13:03 <LordBrain> there's a wiki about th is somewhere
15:13:59 <exicer> So generally people would advocate wrapping it all in Either or something ?
15:15:03 <orzo> yes Either or something
15:16:36 <orzo> i avoid use of 'head' and 'tail' because they throw exceptions
15:17:18 <orzo> take 1 and drop 1 are usually as convenient
15:17:46 <joehillen> orzo: https://hackage.haskell.org/package/safe-0.3.4/docs/Safe.html
15:17:56 <quchen> exicer: The problem with normal exceptions is that you can throw them from anywhere (including pure code), they don't appear in type signatures (so you cannot know whether something throws without reading the source), and they can only be caught in IO. That said, using exceptions in IO (using throwIO) etc. is similar to using exceptions in other languages. They're not inherently bad, but you have to keep track of where to catch them careful
15:17:56 <quchen> ly, you cannot miss catching an exception or everything crashes, and an exception can leave your program in an unwanted state because there is not enough cleanup happening.
15:18:37 <quchen> I'd say best practice is avoiding them by leveraging the type system as much as possible.
15:18:42 <exicer> quchen: Okay, that makes sense.
15:18:55 <exicer> Would you extend that to, eg, catching all http exceptions and wrapping them ?
15:20:02 <orzo> joehillen: tailSafe could be written as drop 1 which seems better as its in the prelude.
15:20:54 <quchen> Most of the time you can do better by using IO (Either ...), I suggest you do that instead.
15:21:22 <quchen> Make your own HTTPError data type. If you forget to catch a "Left Foobar", the compiler will tell you about that.
15:21:33 <quchen> If you forget to catch an Exception, the runtime will tell you about that by crashing.
15:25:01 <exicer> quchen: Cool, I think I will do just that!
15:25:34 <orzo> by the way, convention has Left used for the error/exception branch
15:25:38 <orzo> heh
15:28:04 <akurilin> someone pinged me on here, sorry I missed that, no idea who it was
15:28:26 <felixn> is there an fmap2? fmap2 fn _a _b = do { a <- _a; b <- _b ; return (fn a b) }
15:28:40 <quchen> orzo: It's not only convention, the type system kind of dictates this order. You couldn't make a Functor that maps over "Left" values.
15:28:40 <vanila> :t liftM2
15:28:41 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:28:46 <vanila> sort of close
15:29:23 <felixn> vanila: oh crap you rock
15:29:27 <vanila> :D
15:29:28 <joehillen> quchen: can you please explain?
15:29:39 <felixn> I got my type wrong when I searched hoogle...  I need to switch to a real IDE that tells me my type
15:31:07 <quchen> orzo, joehillen: The reason for this is that you have to write the Functor instance as "instance Functor (Either e)", which is has "Either e" as a curried type constructor. If you wanted to make a "Left-based Either instance", you would have to flip Either's arguments, and that you cannot do.
15:31:17 <LordBrain> dons made a nice little vim plugin once that inserts the type using ghci, but he didn't maintain it and it seems to have evaporated.
15:31:34 <quchen> So there is no "instance Functor (\a -> Either a e)" or something of the likes.
15:32:12 <LordBrain> if anyone knows of a vim plugin which does the same thing but is actively maintained, let me know...
15:32:28 <quchen> felixn: Your "fmap2" is pretty much what (<*>) is there fore, from Applicative.
15:32:45 <quchen> Or equivalently, liftA2/liftM2.
15:36:56 <Algebr> How do I use command line hoogle to search a specific library
15:37:14 <quchen> Try "length +bytestring", Algebr
15:37:30 <quchen> size +containers
15:38:19 <quchen> It even works in here,
15:38:20 <quchen> @hoogle map +containers
15:38:20 <lambdabot> Data.IntSet map :: (Key -> Key) -> IntSet -> IntSet
15:38:20 <lambdabot> Data.IntMap.Strict map :: (a -> b) -> IntMap a -> IntMap b
15:38:20 <lambdabot> Data.IntMap.Lazy map :: (a -> b) -> IntMap a -> IntMap b
15:38:43 <Algebr> ah, nice! Thanks!
15:39:09 <Algebr> @hoogle windowNew +gtk3
15:39:09 <lambdabot> Could not find some databases: gtk3
15:39:10 <lambdabot> Searching in:
15:39:10 <lambdabot>   .
15:39:29 <Algebr> Can I get regexes?
15:40:44 <oio> is there something like a Data.Map.lookupBy ?
15:42:53 <zq> oio: what would it do?
15:44:08 <oio> zq: samchar x y = zst == [(q,w) |(q,w)<- zst, q == w || abs ((ord q) - (ord w)) ==32]
15:44:08 <oio>               where zst = zip x y
15:46:25 <oio> zq: if i have a key "hOlA" in the 'dictionary' i will be able to search for it typing "hola"
15:51:37 <orzo> oio: and also you could use "hol!" right?
15:52:00 <aloiscochard> if I do `zipWith` with 'xs' and 'fmap f xs', that will be fused right?
15:52:32 <orzo> i would expect so
15:53:42 <mietek> Is there a -j equivalent flag for Setup.hs?
15:56:01 <ReinH> if you actually want case-insensitive lookup, why not transform all keys to lowercase before insert/lookup?
15:57:18 <pjdelport> oio: You can't do a normal search tree lookup like that, because the tree is constructed with the original ordering, not with whatever can be supplied to such a lookupBy.
15:57:18 <pjdelport> oio: You can define a String wrapper that does case-insensitive comparison and build the tree out of that, though.
15:57:26 <oio> orzo: that would be nice though lookup already does something like that
15:57:29 <LordBrain> i think there's actually unicode aware functions for doing this
15:58:17 <quchen> mietek: Yes, -j :-þ
15:58:21 <pjdelport> oio: http://www.haskell.org/haskellwiki/Wrapper_types
15:58:57 <quchen> mietek: It's fairly new though. But since 1.18, Cabal allows building packages in parallel, and since 7.8 GHC supports parallel compilation on a per-module basis.
15:59:06 <pjdelport> oio: Oh, and there's Data.CaseInsensitive
15:59:10 <mietek> quchen: doesn't appear to work via EXTRA_BUILD_OPTS=-j for bootstrap.sh
15:59:27 <quchen> What's bootstrap.sh?
15:59:42 <quchen> If you're bootstrapping Cabal I'm not sure this works.
15:59:47 <mietek> Yeah
16:00:14 <mietek> Not sure why, though
16:00:14 <quchen> What's the error message?
16:00:28 <mietek> I just checked, and the Setup binaries that were bootstrapped have -j in their "build --help"
16:00:33 <quchen> What are your Cabal/GHC versions?
16:00:35 <mietek> No error message, it just doesn't do stuff in parallel
16:00:44 <quchen> Oh, did you specify a number?
16:00:48 <quchen> -jN, where N is the number of jobs
16:01:00 <quchen> Just -j is degenerate, I'm surprised it works
16:01:02 <mietek> The help message says "$ncpus if no NUM is given
16:01:12 <quchen> Hmm.
16:02:09 <quchen> Anyway, bootstrapping Cabal is kind of a special case. I wouldn't worry about parallelism there too much.
16:02:33 <mietek> Thanks, it's my job to worry about it
16:03:28 <quchen> Maybe you have to specify +RTS -Nx there?
16:03:40 <quchen> Cabal does this automatically, but again, bootstrapping is special
16:03:51 <mietek> -Nx literally?
16:03:58 <quchen> -N<number of jobs>
16:04:05 <quchen> Like running an ordinary GHC program in parallel
16:04:21 <quchen> Try "+RTS -Nx -RTS" to be sure
16:04:51 <mietek> I will.
16:04:53 <mietek> Meanwhile, https://github.com/haskell/cabal/blob/master/cabal-install/bootstrap.sh#L229
16:05:09 <mietek> I would expect EXTRA_BUILD_OPTS=-j to get passed through to Setup here
16:05:10 <quchen> I haven't bootstrapped Cabal for some time (in particular not after anything was parallel), so I can only guess around until someone with actual knowledge comes around
16:06:44 <stephenmac7> Any way I could get the functionality of lpaste (it's suggestions) but without pasting?
16:06:56 <quchen> stephenmac7: cabal install HLint
16:07:01 <mietek> quchen:        Setup: the flag -N8 requires the program to be built with -threaded
16:07:02 <quchen> @hackage hlint
16:07:02 <lambdabot> http://hackage.haskell.org/package/hlint
16:07:02 <stephenmac7> Got it, thanks
16:07:04 <mietek> Aha!
16:07:08 <mietek> That's very interesting
16:07:19 <quchen> mietek: If it wasn't built threaded I'm not surprised it had no parallelism ;-)
16:07:39 <mietek> So it's missing flags for the way the Setup was built
16:07:45 <mietek> Again
16:13:36 <lavorno> @mietek if u have doubts about what is passed to Setup, maybe you can write your own shell setup and just print all the parameters it receives, before invoking the proper setup.. or run in -v mode ?
16:13:36 <lambdabot> Unknown command, try @list
16:14:03 <mietek> lavorno: yes, thanks
16:14:26 <lavorno> mietek: np
16:15:08 <zcd1> anyone familiar with xmobar and know how to pipe icons in from loghook?
16:16:22 <zcd1> i'm using the <icon=.../> format but it outputs as plaintext :(
16:18:13 <ocharles> dreixel: data C k ... where C :: k => ...  requires -XUndecidableInstances, it seems
16:18:31 <ocharles> dreixel: whenever you have an instance Whatever (C k ...), to actually construct k => C, you need k as a context
16:18:49 <ocharles> dreixel: so you get  instance k => Whatever (C k ...), and you're in undecidable territory
16:19:50 <triliyn> zcd1: I'm not sure, but you might need to use unsafeLogHook
16:20:05 <triliyn> Or something like that
16:20:21 <triliyn> By default it doesn't interpret anything and just displays the text, I think
16:21:46 * hackagebot tinylog 0.8 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.8 (ToralfWittner)
16:21:48 * hackagebot wai-routing 0.6 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.6 (ToralfWittner)
16:24:36 <oio> so.. got disconected
16:25:22 <triliyn> zcd1: oh, that's right, you need to make xmobar use UnsafeStdinReader instead of normal StdinReader
16:25:38 <oio> same question is there a Data.Map.lookup but lookupby?
16:29:45 <sipa> oio: what would that do?
16:30:42 <oio> sipa: i have a 'dictionary' i would like to be able to look up for the "hOlA" key by using "hola"
16:31:10 <sipa> so you need a case-insensitive ordering on your data
16:31:24 <oio> sipa: indeed
16:31:34 <oio> sipa: samchar x y = zst == [(q,w) |(q,w)<- zst, q == w || abs ((ord q) - (ord w)) ==32]
16:31:34 <oio>               where zst = zip x y
16:31:37 <vanila> or you could put everything lowercase
16:31:39 <koala_man> oio: if you want to look up by something other than the key, you'd have to iterate it
16:31:39 <sipa> you can always put a newtype wrapper around your datatype, giving it an alternate Ord instance
16:31:50 <evancz> For the function `(==) :: Eq a => a -> a -> Bool` what is the minimal example where not all uses of (==) can be given a concrete implementation?
16:31:57 <oio> no is the key
16:32:18 <oio> lowercase uppercase is important here
16:32:20 <nisstyre> evancz: you mean like floats vs. ints?
16:32:28 <oio> sipa: can you point me a direction
16:32:48 <nisstyre> or even just signed vs. unsigned ints would work I guess
16:32:56 <koala_man> oio: so how do you know to look up hOlA and not HolA?
16:32:56 <evancz> nisstyre: the typical implementation uses dictionaries to make the implementation available for any instance
16:33:12 <nisstyre> evancz: I'm sorry I didn't understand your question
16:33:13 <evancz> so the question is, what's a minimal example where the dictionary cannot be optimized away
16:33:20 <nisstyre> are you asking how it gets instantiated, or how the implementations differ?
16:33:45 <nisstyre> evancz: f a b = a == b
16:34:15 <nisstyre> >.>
16:34:21 <nisstyre> or is that too minimal?
16:34:22 <evancz> in that program, the optimizer can just output nothing
16:34:24 <oio> koala-man: doesnt matter
16:34:33 <nisstyre> evancz: what do you mean output nothing?
16:34:59 <evancz> For the program you gave, no output is necessary. It's all dead code.
16:35:15 <sipa> oio: newtype CaseInsensitiveString = CIString String
16:35:15 <pyon> Is ParsecT s u m not an Applicative? :-O
16:35:19 <nisstyre> you mean it can be inlined to (==) right?
16:35:23 <nisstyre> that doesn't matter
16:35:28 <evancz> I'm trying to find a program in which not all uses of (==) can be resolved to a single type statically
16:35:41 <nisstyre> how about f a xs = map (== a) xs ?
16:35:44 <pavonia> pyon: It is
16:35:49 <sipa> oio: instance Eq CaseInsensitiveString where CIString a == CIString b = toLower a == toLower b
16:36:06 <evancz> nisstyre: no, as soon as anyone uses f, it can be resolved to a specific type
16:36:14 <nisstyre> evancz: that goes for any function
16:36:31 <evancz> do you see what I mean?
16:36:39 <nisstyre> then no, you can't find such a program
16:36:43 <nisstyre> at least one that works
16:36:53 <evancz> as soon as someone says (f 3 [1,2,3]) you know it's for ints
16:36:55 <evancz> optimize it
16:37:11 <pyon> Why does parsec expose a custom <|> if it is already an instance of Alternative?
16:37:28 <pavonia> Historical reasons
16:37:39 <pyon> So, which one do I use?
16:37:56 <nisstyre> evancz: you might've been misinformed about type classes I think
16:38:07 <sipa> evancz: no, f 3 [1,2,3] does not force it to be Ints
16:38:08 <pavonia> pyon: It shouldn't matter, IIRC
16:38:15 <pyon> Ah!
16:38:18 <oio> sipa: i will conserve case but lookup will be able to do this "hola"== "HoLA"
16:38:34 <sipa> oio: yes
16:38:48 <evancz> nisstyre: I don't think so, I'll try to come up with one
16:38:58 <evancz> sipa: f 'a' "abc"
16:39:05 <evancz> something like that to be more precise
16:39:06 <nisstyre> evancz: also ghc defaults to Integer not Int
16:39:13 <sipa> evancz: yes, ok
16:39:13 <Taneb> Is there in IRC channel for Scotty?
16:39:41 <nisstyre> Int is a fixed width type
16:40:22 <evancz> data Value where Value :: forall a. Eq a => a -> Value
16:40:26 <oio> sipa: thanx
16:40:34 <evancz> haha, I'm not sure how to do it :)
16:41:39 <evancz> I'm thinking that with closures or passing around higher-order functions or GADTs you could get a situation where you can't know with certainty that a function will be specialized to a specific type
16:41:48 <evancz> statically
16:42:16 <roboguy_> evancz: numeric literals are polymorphic in haskell. so 3 is not necessarily an Int
16:42:19 <roboguy_> :t 3
16:42:20 <lambdabot> Num a => a
16:42:51 <evancz> roboguy_: I know, I gave a sloppy example
16:42:56 <evancz> the char one should clarify
16:43:17 <evancz> does the question make sense?
16:43:33 <evancz> "Are there cases where you have to pass a dictionary around at runtime?"
16:43:42 <sipa> yes
16:43:48 <evancz> What's a minimal example?!
16:44:12 <evancz> or any example really, I just want to see the technique
16:44:30 <sipa> so, in practice it's probably done much more often than "necessary"
16:45:10 <sipa> as you could specialize polymorphic code for every type that is known at compile time, but that isn't done unless you explicitly specialize
16:45:54 <sipa> but to come up with an example where that certainly isn't possible
16:47:06 <sipa> sec
16:47:09 <roboguy_> evancz: I know it happens but I can't think of too many good examples off the top of my head
16:47:20 <roboguy_> you could do something with Void but that might not be too convincing
16:49:26 <sipa> evancz: http://lpaste.net/103371
16:49:33 <sipa> evancz: f calls itself with a different type
16:49:43 <sipa> evancz: and the resulting type grows unbounded
16:50:15 <roboguy_> :t \x -> absurd x == absurd x
16:50:16 <lambdabot> Not in scope: ‘absurd’
16:50:16 <lambdabot> Not in scope: ‘absurd’
16:50:24 <roboguy_> :t \x -> Data.Void.absurd x == Data.Void.absurd x
16:50:25 <evancz> sipa: yow, that will pass the type checker?
16:50:25 <lambdabot> Data.Void.Void -> Bool
16:50:31 <sipa> evancz: yes
16:50:49 <evancz> without any extensions?
16:50:59 <sipa> just works in ghci at least
16:51:25 <evancz> okay, makes sense, thank you!
16:51:35 <roboguy_> that makes sense. a can be any instance of Show
16:51:41 <evancz> is the main case functions like this?
16:52:05 <evancz> I'm trying to think how I might accidentally write something like this
16:52:43 <sipa> evancz: the alternative (knowing all possible instances used at compile time) is pretty restricting, and may cause a huge blowup in compiled code size
16:53:38 <evancz> I get the argument about why you wouldn't want to specialize
16:54:13 <evancz> but I still don't have a good handle on what kind of things get restricted
16:54:34 <evancz> I don't know how to describe the technique you used in a more general way, though I can copy the pattern now
16:55:10 <evancz> essentially, combining forall, a type constraint, and recursion
16:57:06 <evancz> well, okay, that at least proves the point that it can't all be done statically even in principle
16:57:09 <evancz> Thanks!
16:58:32 <vanila> could someone give me a rough idea of what fpcomplete is?
17:00:22 <c_wraith> vanila: if it was only one thing, that'd be much easier.
17:00:58 <quchen> A startup using Haskell. And giving back a lot to it.
17:05:12 <sm> I know, they should document this on a www site on the internet!
17:05:20 <benbangert> does anyone have an example of using HUnit + QuickCheck2? ie, to test some stuff in the IO monad
17:05:50 <benbangert> as much as I want to read a 20+ page PHD paper that QuickCheck2 'docs' link to....
17:07:04 <merijn> I dunno about the QuickCheck2 docs, but many of the papers I've read linked from docs were pretty good explanations of what's what
17:07:49 <quchen> I don't get why PDF documentation is portrayed as academic, or why academic articles are portrayed as useless all the time.
17:08:35 <benbangert> quchen: oh, its absolutely not useless. but when every, "I just want to do X really quick" turns into, "get the popcorn, time to read another paper".... well.... something that could take 5 mins becomes an hour way too often
17:08:56 <quchen> Many papers on Haskell have excellent introductions, examples, tutorials in them.
17:09:13 <arboris> quchen: PDF is just one step above dead tree documentation, on an interactive computer you would ideally expect the documentation to contain runnable code examples
17:09:14 <benbangert> agreed, though they frequently go to math notation vs. valid haskell notation, which doesn't help
17:09:35 <benbangert> arboris: or you might even expect a simple example *in the docs of the package itself*
17:09:54 <benbangert> I mean..... really?? http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck-Monadic.html
17:10:09 <quchen> Yeah that's crap.
17:10:45 <arboris> :), but the types already tell you everything you will ever want to know
17:10:48 <benbangert> the main Test.QuickCheck module has docs more along what I was expecting
17:11:30 <quchen> arboris: Really? What's the difference between 'pre' and 'assert'?
17:11:42 <benbangert> arboris: if I could draw, I'd make some cartoon about ppl that die on a spaceship cause the only 'docs' to launch the escape pod were buried in the types+property tests....
17:11:45 <arboris> that was a joke...
17:11:49 <benbangert> ;)
17:11:52 <quchen> Oh.
17:12:07 <merijn> quchen: Walked right into that one
17:12:28 <quchen> PUBLIC APOLOGY
17:12:32 <benbangert> lol
17:12:33 * quchen apologizes
17:12:36 <quchen> END PUBLIC APOLOGY
17:13:12 * arboris accepts apology
17:13:13 <dfarm> One thing I'll say, I read a lot of research papers and I've found anything with Hughes name on it to be pretty excellent.
17:14:00 <quchen> I should work more with pipes. Just so I have to and can read the docs.
17:14:03 <dfarm> I guess the 20 page paper you were talking about is the 12 page "Testing Monadic Code with Quickcheck" paper?
17:14:33 <benbangert> dfarm: technically 11 pages I guess when ignoring the citations
17:14:58 <dfarm> (It's 13, I already backed 1 off for the cites ;))
17:15:04 <dfarm> But yeah
17:17:23 <benbangert> quchen: using pipes is fun, great docs, I had stuff working in maybe 10 mins
17:22:02 <benbangert> ah ha
17:22:10 <benbangert> the answer was on stack overflow.... the example I so wanted... http://stackoverflow.com/questions/2259926/testing-io-actions-with-monadic-quickcheck
17:23:26 <[swift]> if i need to restrict a package to GHC 7.8.x and above, it's enough to require base >= 4.7, right?
17:27:10 <oio> how can i get overloadedstrings already inside ghci?
17:27:24 <c_wraith> oio: :set -XOverloadedStrings
17:27:36 <tristan__> oio: in your ~/.ghci
17:29:37 <oio> c_wraith: ok
17:33:37 <oio> c_wraith: is this normal "malformed integer argument in -OverloadedStrings"?
17:34:15 <c_wraith> oio: it is if you leave out the X
17:34:38 <c_wraith> oio: -X is the option for setting language features
17:35:03 <prophile> I believe the available optimisation options for GHC are 0, 1, 2 and 3, "verloadedStrings" probably isn't one of them :)
17:35:45 <oio> c_wraith: doesnt seems to be working     Couldn't match expected type `Text' with actual type `[Char]'
17:35:46 <oio> ?
17:36:16 <oio> c_wraith: "hola"::Text
17:37:12 <c_wraith> oio: then you probably didn't actually set it
17:38:09 <oio> c_wraith: :set -OverloadedStrings
17:38:09 <oio> ghc: <no location info>: malformed integer argument in -OverloadedStrings
17:38:09 <oio> Usage: For basic information, try the `--help' option.
17:38:38 <c_wraith> oio: it's *still* :set -XOverloadedStrings
17:38:45 <c_wraith> oio: as I've mentioned a few times now
17:38:46 <oio> c_wraith: lol forgot the x
17:38:53 <csdrane> Hi I was wondering what module I need to import to use 'catch'
17:39:07 <c_wraith> csdrane: Control.Exception
17:39:26 <c_wraith> csdrane: if you are using a paritcularly old tutorial, there used to be a catch in Prelude
17:39:40 <identity> csdrane: When you'd like to find out where a function comes from, using hoogle is a good bet in most cases
17:39:42 <c_wraith> csdrane: but it was removed, and the one in Control.Exception doesn't work exactly the same way
17:40:01 <csdrane> Yeah I'm using code from LYAH
17:40:11 <csdrane> I saw Control.OldException on Hoogle but not a replacement
17:40:34 <csdrane> I see it now though, looks like I missed it. Thanks guys
17:45:35 <oio> c_wraith: ghci doesnt load a file pragma does it?
17:49:31 <c_wraith> oio: ghc doesn't enable pragmas from files it loads in the interactive session.
17:49:46 <oio> c_wraith: ok
17:49:50 <c_wraith> oio: you can create a .ghci file, though
17:50:06 <c_wraith> as tristan__ mentioned
18:00:30 <manuel_> hi, total noob, enjoying myself. is there a way to define an "additional accessor" for a datatype, something like this: http://lpaste.net/103372 (the last line fails)
18:01:17 <cococo> NOOB alert! What does "do" mean in Haskell?
18:02:04 <Cale> cococo: It's part of a syntax which lets you glue together IO actions (and more generally, actions in an arbitrary monad) to form more complicated ones
18:02:16 <ParahSailin> @undo do {return a}
18:02:16 <lambdabot> return a
18:02:24 <dwcook> cococo, it's syntactic sugar for (>>), (>>=), and lambdas
18:02:41 <cococo> ty
18:02:41 * quchen suggests treating 'do' as abstract notation for sequential blocks until the monad chapters
18:03:02 <Cale> manuel_: The reason why the last line fails is that the Individual data constructor has two fields, but you only match on one of them
18:03:36 <Cale> manuel_: You probably want something like  clientName (Individual { person = x }) = ...
18:04:09 <manuel_> it says "multiple declarations of clientName
18:04:12 <Cale> You can use the record syntax to pick out a single field like that
18:04:21 <Cale> Oh, right, because you already have something called clientName
18:04:23 <manuel_> but yeah that would have been the next error
18:04:32 <manuel_> so it's not possible for me to define like a "virtual record accessor"
18:04:36 <Cale> Yeah, you can't do that
18:04:43 <manuel_> too bad
18:04:45 <manuel_> thanks
18:04:58 <Cale> But what you could do is define a function with another name
18:05:21 <manuel_> yep, that's what i did. so my next question
18:05:37 <dwcook> cococo, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
18:05:42 <Algebr> How can I use .t2t files?
18:06:09 <Cale> Algebr: What is a t2t file?
18:06:44 <Algebr> Cale: That's the thing, I don't know either. I found them in the doc directory of the gtk2hs repo
18:06:51 <manuel_> cale: http://lpaste.net/103372 <- is there a nicer way to avoid the redundancy of the two lower cName declaration?
18:07:09 <Cale> cName x = clientName x
18:07:30 <Cale> You could use that after the line with the Individual match
18:07:32 <manuel_> obvious in hindsight
18:07:33 <manuel_> :}
18:07:41 <manuel_> thank you
18:08:06 <cococo> ty dwcook
18:08:33 <Cale> Also, you might want something like unwords [firstName x, lastName x]
18:08:49 <Cale> Or just stick a " " in between :)
18:10:50 <manuel_> a very wise remark
18:14:41 <Algebr> For anyone interested, .t2t was for txt2tags and its on brew.
18:15:56 <triliyn> manuel_: is cName even necessary there? clientName works on all the constructors
18:18:08 <manuel_> triliyn: how?
18:18:16 <manuel_> I get : "*** Exception: No match in record selector clientName
18:18:31 <triliyn> manuel_: hmmm, maybe it doesn't work then
18:19:19 <triliyn> It's kind of a weird case, because you have a "record selector" and a normal function, but they both have the same name and both have similar behavior
18:19:31 <Cale> triliyn: Yeah, the clientName definition afterward isn't allowed
18:19:41 <Cale> triliyn: He presumably got rid of that
18:19:49 <triliyn> It would have been cute (but possibly unintuitive in some cases) if they kind of stuck together into a total function
18:34:31 <Zekka> Lens expects Applicative and I don't know why: code sample here: http://lpaste.net/4034349664026230784
18:34:58 <Zekka> also TestT was a bad name and I'm not sure why I picked it
18:36:26 <Zekka> Now might have been a poor time to ask: I'll need to leave pretty soon
18:39:12 <manuel_> it's funny how much haskell feels like javascript to me
18:40:53 <manuel_> in the way i think about programs... i guess it's due to the functional nature of a lot of js libraries
18:40:59 <Zekka> Anyone here use Lens and know enough about its use of types to explain why it's doing that?
18:42:16 <d1323> manuel_, have you tried to do IO yet? :)
18:42:25 <Zekka> Hold up, I may have found the problem
18:42:45 <Zekka> it looks like _head may have changed types since the version whose source code I looked at, although I'm not sure
18:43:04 <Zekka> singular seems to have fixed it
18:44:29 <coleman-> hello
18:44:59 <edwardk> Zekka: you can also use ^?!foo instead of ^.singular foo
18:45:20 <Zekka> edwardk - That doesn't work in my current usage but it would work otherwise
18:45:33 <Zekka> in my current usage I'm actually assigning the composition of a few lenses to a variable
18:45:44 <edwardk> Zekka: anyways be warned inner2 will blow up spectacularly if the list is empty
18:45:47 <Zekka> the actual line in the source code is this "topFrame = vmStack.frames.singular _head"
18:46:06 <Zekka> edwardk - Yeah, fully aware that it will explode
18:46:27 <Zekka> but it should be OK because I have some type machinery that should keep it from ever being empty and my program is irrevocably broken if it does
18:47:15 <Zekka> At least here's hoping
18:50:42 <Zekka> I've got to go, at least for a bit. Thanks for the help, folks
19:09:54 <Total_1mmersion> Could someone help me understand why "runST $ newSTRef 3" fails to typecheck?
19:13:00 <geekosaur> because it returns an STRef, and runST cannot return that
19:13:09 <roboguy_> Total_1mmersion: you can't use an STRef outside of the ST
19:13:15 <Cale> :t runST
19:13:16 <lambdabot> (forall s. ST s a) -> a
19:13:31 <Cale> :t newSTRef 3
19:13:32 <lambdabot> Num a => ST s (STRef s a)
19:14:03 <Cale> Actually, let me rewrite that first type:
19:14:15 <Cale> runST :: forall a. (forall s. ST s a) -> a
19:14:42 <geekosaur> runST forall-s the `s`; if you try to return something referring to it (in this case Num a => STRef s a) then `s` cannot be given any type at all
19:14:47 <chance> if i have a value of type "Foo" and I wanted to lift it to type "Maybe Foo", how would i do so? im reading the docs and strugglinga b it
19:14:48 <Cale> That is, a is fixed before s is in scope, and so cannot contain any occurrences of s
19:15:01 <dwcook> @type Just
19:15:01 <lambdabot> a -> Maybe a
19:15:02 <dwcook> chance, ^
19:15:23 <chance> not working though :\
19:15:27 <roboguy_> chance: ?
19:15:31 <dwcook> chance, show what you tried
19:15:33 <chance> hmm something else must be wrong then
19:15:41 <geekosaur> @paste
19:15:41 <lambdabot> Haskell pastebin: http://lpaste.net/
19:15:46 <geekosaur> ^ send your code there
19:15:58 <chance> im so close, and its HW, so i dont feel good about getting the answer
19:16:11 <chance> its just this last function definition im on the struggle bus for
19:16:21 <Cale> Total_1mmersion: The s type parameter is there simply to prevent smuggling STRefs out of ST computations, and to ensure that even if you do something clever to get hold of one anyway, it will be unusable
19:16:44 <dwcook> chance, we can give you a nudge in the right direction instead of an answer
19:16:58 <Total_1mmersion> I had read about that s parameter being used to ensure values couldn't escape ST. Is that it's only purpose?
19:16:59 <chance> oh shit i think i might have figured it out
19:17:03 <Cale> yes
19:17:17 <chance> i was wrapping my entire expression in a Just, when the function i was calling returns a Maybe
19:17:22 <chance> so i was getting an extra
19:17:23 <chance> let me test..
19:17:38 <Cale> That's really all there is to it, ensuring that the mutable state doesn't escape any particular call to runST
19:17:38 <dwcook> chance, ah, so instead of an a -> Maybe b you got a Maybe (a -> b)?
19:17:40 <Total_1mmersion> So does s actually take on a concrete type within the ST monad?
19:18:10 <Cale> It doesn't really, but if you want, you can conceptually think of it as being instantiated with the type of the heap
19:18:17 <chance> dwcook: ill show you, one sec
19:18:53 <Cale> It's really just a type system trick to prevent STRefs created by one runST from being used in any other.
19:19:32 <geekosaur> in reality, nothing actually refers to it as anything but a type (it's a "phantom type"), so it goes away completely after the typechecker is done with it.
19:19:54 <Total_1mmersion> Hmm, I'm still having a hard time understanding why runST can't return an s. I remember seeing a function of type (a -> r) before, which meant it could never return. Is this similar?
19:20:17 <roboguy_> Total_1mmersion: Cont?
19:20:23 <Total_1mmersion> I believe so
19:20:50 <geekosaur> sort of. you cannot refer to the value outside of runST, because its type is only defined inside of runST (that's what the forall s. inside the parentheses means)
19:21:04 <geekosaur> since it has no type outside of runST, it cannot exist outside of runST
19:21:27 <roboguy_> Total_1mmersion: there is no value that matches "forall s. s" other than something like undefined
19:22:24 <Total_1mmersion> Interesting. But it is possible to have "forall s. [s]" right?
19:22:30 <Total_1mmersion> [] is the only such value?
19:22:42 <Cale> It's not that it can't return an s
19:22:58 <Cale> It's that when the choice of the type 'a' is made, the appropriate 's' is not in scope.
19:23:13 <Cale> runST :: forall a. (forall s. ST s a) -> a
19:23:33 <Cale> The s in ST s a is bound by the forall s. in the type of the parameter to runST
19:23:34 <dwcook> Total_1mmersion, [] is not a single value, there's a [] for every type
19:23:42 <zq> how does one prove rigorously that forall s. s is solely inhabited by bottom?
19:24:07 <dwcook> (At least conceptually; it can be implemented as a single value)
19:24:08 <Cale> So, when choosing 'a', you can't make reference to it.
19:24:21 <Total_1mmersion> dwcook, ah yes you are right
19:24:44 <chance> dwcook: https://gist.github.com/ecnahc515/55906bb4c866188d950d#file-hw2-hs-L88
19:24:44 <Cale> and if you pick some particular 's', that also won't work, because the parameter to runST must be polymorphic in its 's' type
19:24:45 <dwcook> zq, not sure, but you could start by demonstrating that there exists a type containing just bottom
19:24:48 <chance> thats where i had problems
19:25:43 <dwcook> zq, and use bottom :: forall a. a, which is practically an axiom of Haskell
19:26:32 <zq> dwcook: that proves that forall a. a is inhabited by bottom, but not only by it
19:26:53 <dwcook> zq, yes, that's what the first thing I said is for
19:27:04 <Total_1mmersion> Cale, runST cannot return something of type s because s is not in scope on the right hand side of ->?
19:27:47 <Cale> Total_1mmersion: This all makes much more sense if we're explicit about type parameters, which Haskell isn't
19:27:49 <dwcook> zq, proving that there exists a type containing only bottom also proves that there does not exist a non-bottom value that inhabits every type
19:28:17 <Cale> Total_1mmersion: Think of each forall as being like an extra function parameter, which is going to accept a type argument
19:28:21 <Total_1mmersion> Cale, you mean explicitly writing the foralls and scopes?
19:28:38 <Cale> So, when we go to apply  runST :: forall a. (forall s. ST s a) -> a
19:28:44 <Cale> we first need to supply some type a
19:29:09 <Total_1mmersion> Ohh this is starting to make sense now
19:29:20 <Cale> and then we need to supply a function of type forall s. ST s a (which accepts the type s as a parameter), and finally produces a value of type a
19:29:34 <zq> dwcook: the first step is just a restatement of the original question, right? how would you construct it?
19:29:47 <Cale> But when we supply 'a', the 's' there isn't in scope yet, so we can't involve it in any way
19:32:11 <dwcook> zq, here's such a type: data Void. I'm not sure how you'd go about actually enumerating its values though
19:32:49 <Cale> and if we invent some new type variable t (we might confusingly name it s, but it'll still be separate), and try to supply a = STRef t Integer, then the fact that the STRef gets created by newSTRef :: a -> ST s (STRef s a) will make sure that t will unify with s, and that will cause a problem because our computation isn't of type  forall s. ST s a  anymore, it's monomorphic: ST t (STRef t Integer)
19:32:58 <Total_1mmersion> Ok, let me see if I can write it out. ((forall a. ((forall s. ST s a) Char) -> a) Int) would become ((forall s. ST s Int) Char) -> Int) and finally (ST Char Int -> Int)
19:33:13 <Cale> errr
19:33:28 <roboguy_> dwcook: can't you say that it has no values other than bottom by it's definition?
19:33:39 <Cale> If we're writing the type parameters explicitly, they'll be part of the terms, not the types
19:33:43 <Cale> So:
19:33:50 <Cale> Our attempt to call runST might look like
19:34:01 <dwcook> roboguy_, I think so. I think you'd have to make Haskell's axioms explicit to be absolutely rigorous about it though
19:34:48 <dwcook> I mentioned that one such axiom is bottom :: forall a. a. But what axiom tells us that a type doesn't contain extraneous fluff not already mentioned?
19:34:48 <Cale> runST (STRef ??? Integer) (/\s. newSTRef s Integer 0)
19:35:01 <Cale> Where now /\ is a type lambda
19:35:42 <Cale> (this isn't Haskell, but a similar language where in order to use polymorphic things, you have to give the type you're using them at explicitly)
19:36:04 <Cale> (and in order to create polymorphic things, you use type lambdas)
19:36:18 <Total_1mmersion> I'm a bit confused about the ???. In which order are terms applied here?
19:36:40 <Cale> The ??? is the part we can't reasonably fill in, which causes your type error
19:37:12 * hackagebot hledger-web 0.22.8 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.8 (SimonMichael)
19:37:49 <Cale> So, runST takes as its first parameter the type 'a', corresponding to the "forall a." at the start of its type signature
19:38:38 <Cale> and then it takes something of type (forall s. ST s a), which itself needs to be a function accepting this type 's' as a parameter
19:38:59 <Cale> We don't write these type parameters explicitly in Haskell, the compiler figures them out for us (or complains when it can't)
19:39:12 <Cale> But they're still "there" in a sense
19:39:24 <Cale> (with zero runtime cost)
19:40:09 <Cale> newSTRef :: forall s a. a -> ST s (STRef s a)
19:40:09 <Total_1mmersion> Oh, so you can think of runST as taking 2 arguments where the first argument is a type?
19:40:12 <Cale> yes
19:40:58 <Cale> and the problem is that you can't give an appropriate type there, because the 's' which occurs in the type of the computation you gave for the second argument to runST isn't in scope
19:41:21 <Cale> (in fact, it's even bound by the type lambda)
19:41:35 <Total_1mmersion> Ok, that way of thinking about polymorphic functions is new to me.
19:41:48 <Cale> Yeah, so, as a simpler example, imagine we had something like
19:41:55 <Cale> reverse :: forall a. [a] -> [a]
19:43:00 <Cale> in order to apply it in this language with explicit type parameters, you'd have to write things like  reverse Integer [1,2,3,4]
19:43:57 <Cale> It might also be a bit more awkward to write because you might have to supply explicit type parameters to constructors like [] and such
19:44:56 <Cale> So, like:   reverse a [] = [] a; reverse a (x : xs) = (++) a xs ((:) a x ([] a))
19:44:58 <Total_1mmersion> So "(forall s. ST s a) -> a" can be written as "(forall a. (forall s. ST s a) -> a)". Applying this to some some concrete type T gives "(forall s. ST s T) -> T". Now it's obvious that runST cannot return something of type s.
19:45:12 <Cale> (it starts to get really mangled and tedious)
19:45:26 <Cale> right
19:45:44 <Cale> or anything which so much as mentions s anywhere inside
19:46:09 <Cale> (like the STRef s a)
19:46:14 <Total_1mmersion> Oh yeah, good point
19:46:31 <Total_1mmersion> Because the return type was fixed before s was chosen
19:46:38 <Cale> yep
19:46:42 <manuel_> d1323: yes i did some IO
19:46:49 <manuel_> monads seem very obvious to me actually
19:46:54 <Cale> runST gets to "choose" what type s is, we don't
19:46:54 <Total_1mmersion> Awesome, thank you and everyone else for helping me understand this!
19:47:18 <manuel_> threading async execution blocks makes you think monadically
19:47:22 <manuel_> i guess
19:47:47 <Cale> (it doesn't really choose a particular type either, but instead does some magic, but theoretically, you could imagine that it uses that 's' parameter as the type of the heap which is being manipulated by newSTRef etc.
19:47:48 <Cale> )
19:48:16 <manuel_> or threading futures with error handling for that matter
19:50:54 <Total_1mmersion> What's a good way to represent a mutable list of assembly instructions (which refer to one another)?
19:51:15 <dwcook> Total_1mmersion, an array of some sort perhaps
19:51:21 <dwcook> gotos can consist of indices
19:51:53 <dwcook> (I'm not that familiar with assembly)
19:51:54 <roboguy_> manuel_: have you looked at other monads yet? IO might not be the most representative monad
19:52:03 <Total_1mmersion> Is there a safer way? If an index is stored as an Int, not much is preventing it from being set to a negative index.
19:52:48 <Total_1mmersion> I imagine an assembly instruction could store STRef to other instructions
19:52:50 <roboguy_> Total_1mmersion: in what way is it mutable? do you need random access?
19:53:08 <manuel_> roboguy_: maybe and state
19:53:16 <manuel_> io is not very conducive to "understanding" the concept
19:53:22 <manuel_> i guess
19:53:37 <roboguy_> manuel_: ah, well other good examples would be the function monad and the list monad
19:53:43 <manuel_> oh yeah list
19:53:43 <Total_1mmersion> The instructions that an instruction refers to can change, and no I don't need random access
19:54:13 <manuel_> i don't know i remember i tried to get into haskell a decade ago or so, and kind of didn't pursue it because of not groking stuff, and now it kind os seems obvious
19:54:14 <manuel_> weird
19:54:30 <manuel_> i'm more struggling with syntactic / library kind of stuff right now going through exercises
19:54:38 <Total_1mmersion> So Add 2 4 could change to Add 3 4. Here I use 2, 3, and 4 to represent other instructions, not necessarily the indices of instructions.
19:54:56 <roboguy_> Total_1mmersion: what about a labeled rose tree kind of thing?
19:55:13 <manuel_> ok gotta run peepz
19:55:41 <manuel_> cu soon
19:55:46 <roboguy_> Total_1mmersion: actually, can only certain instructions refer to other instructions?
19:56:03 <Total_1mmersion> For example, due to a limit in registers, a value might need to be stored on the stack, so a store instruction will be inserted right after the value is computed, and load instructions will be inserted before each reference to that value.
19:56:47 <Total_1mmersion> Is a rose tree a tree with arbitrary number of branches at each node? And how would the labels and references to other instructions work?
19:57:11 <Total_1mmersion> Yes, some instructions will not refer to any others. For example, an integer literal does not refer to anything else.
19:58:02 <roboguy_> Total_1mmersion: yeah. actually it probably wouldn't work, now that I think about it
19:59:34 <Total_1mmersion> data Op = IntLiteral Int | Add Instruction Instruction; data Instruction = Instruction Op [Instruction]; -- This is hard to work with because it's all immutable
19:59:36 <roboguy_> Total_1mmersion: can an instruction ever refer to something with an "address" that is past the computer word size?
20:00:20 <roboguy_> or can it have more than 2^wordsize instructors?
20:00:21 <Total_1mmersion> No, the list of instructions will not exceed a few thousand
20:00:24 <roboguy_> *instructions
20:00:33 <roboguy_> hmm, what about an IntMap?
20:00:48 <roboguy_> you'd still have to shuffle things though
20:00:52 <Total_1mmersion> That would work, except I would rather avoid Maybes
20:00:52 <ion> Word# http://heh.fi/tmp/Word%23.jpeg yo
20:01:45 <monochrom> heh, #
20:04:27 <Total_1mmersion> Using the ST monad would probably work, but I'm not sure how to represent it. Would it be ST s [STRef s Instruction]?
20:06:36 <roboguy_> Total_1mmersion: what about a mutable vector?
20:07:08 <roboguy_> I don't think you'd be able to take the STRef out of the ST
20:08:02 <Total_1mmersion> Right, there would be some conversion function which would take an STRef s Instruction and return an Instruction
20:08:12 <roboguy_> that's why I'd just use an MVector
20:08:15 <Total_1mmersion> And that conversion would be applied before returning
20:08:29 <Total_1mmersion> I'm looking into it now
20:10:30 <RaulFPL> i'm having the folowing error when trying to install a package with cabal: http://lpaste.net/103377
20:10:51 <NemesisD> does anyone know if its possible in pipes to know when a stream starts and ends?
20:12:11 <NemesisD> in otherwords. I've got a Producer a m (), and i'd like to peek the first element off that producer, yield an a, drain the stream and then yield a final a
20:13:00 <roboguy_> RaulFPL: hmm what version of ghc does "cabal info ghc" give you?
20:13:42 <RaulFPL> cabal: There is no package named 'ghc'
20:14:42 <roboguy_> RaulFPL: how did you install ghc?
20:16:06 <roboguy_> also what does "ghc --version" tell you
20:16:38 <RaulFPL> ghc --version gives me "The Glorious Glasgow Haskell Compilation System, version 7.6.3"
20:16:54 <RaulFPL> i'm trying to find out how did i install ghc
20:20:12 <roboguy_> there's something weird with the ghc installation because the ghc package should always come with ghc
20:22:10 <zomg> this is nice, explicit forall finally makes sense :P https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/explicit-forall
20:22:37 <RaulFPL> i think i installed it in a nontraditional way
20:23:18 <roboguy_> RaulFPL: hmm, what does "ghc-pkg check" say?
20:24:53 <RaulFPL> ghc-pkg check > http://lpaste.net/103379
20:25:42 <roboguy_> hmm, nothing about the ghc package just warnings
20:28:55 <roboguy_> you might need to reinstall ghc
20:35:02 <RaulFPL> i found out that i installed ghc with the ghc-compiler fedora package an it looks that the cabal info about it lives in another package
20:38:28 <RaulFPL> roboguy_: can you tell me in which file the ghc cabal package information lies?
20:39:16 <roboguy_> RaulFPL: probably in ~/.ghc/<arch-name-and-ghc-version/
20:43:03 <startling> Can I say "cabal, install all the dependencies, reinstalling everything that you know to reinstall except the ghc pseudopackage"?
20:43:45 <startling> the first part is apparently --upgrade-dependencies, but that tries to reinstall some of the dependencies `ghc`.
20:43:57 <startling> (I'm in a cabal sandbox)
20:53:05 <roconnor> @seen bennofs
20:53:05 <lambdabot> Benn0ph5
20:53:23 <roconnor> @tell bennofs http://r6research.livejournal.com/27476.html
20:53:24 <lambdabot> Consider it noted.
20:54:41 <RaulFPL> looks like the ghc cabal package was in the ghc-ghc-devel fedora package.
20:54:44 <RaulFPL> it's working now
20:56:35 <gsingh93> g
21:05:34 <gamegoblin> Is there something I can put in my .cabal file to make it so it compiles with -O2 optimization?
21:05:55 <napping> It seems to work in ghc options
21:06:45 <napping> that's probably not the best way to do it - I see cabal configure takes an -O n flag
21:07:57 <napping> I've also found that putting it in the .cabal gets annoying really fast if you want to do something like git bisect
21:09:34 <GeneralMayhem> How is it that `read "asdf" :: String` has a no-parse error? What does it take to `read` to String?
21:10:42 <ion> read "\"asdf\"" :: String
21:10:57 <ion> > show "asdf"
21:10:59 <lambdabot>  "\"asdf\""
21:11:23 <GeneralMayhem> aha
21:12:03 <GeneralMayhem> so is there any way to get the behavior I was originally going for, where read will be transparent?
21:12:31 <GeneralMayhem> the use case is for a data type where the parameter might be String, in which case I just want read to grab whatever's there
21:12:37 <GeneralMayhem> and not fall over for lack of quotes
21:12:41 <ion> That’s not what read is made for.
21:12:59 <ion> If you want to parse something with optional quotes, use a parsing library such as Parsec.
21:15:37 <GeneralMayhem> i'm trying to get `instance Read a => Read (MyDataType a)`
21:15:39 <roboguy_> > reads "abc" :: [(String, String)]
21:15:40 <lambdabot>  []
21:16:11 <GeneralMayhem> where the string representation depends on the representation of a and then on a common part after that
21:17:52 <GeneralMayhem> oh, nvm, after thinking that through, i'd have to change the read/show instances of String to not use quotes
21:18:16 <roboguy_> GeneralMayhem: what are you doing?
21:19:07 <GeneralMayhem> @roboguy_: data Annotated a = Annotated a String
21:19:07 <lambdabot> Unknown command, try @list
21:19:11 <dibblego> @type \f -> mapState (f . snd) -- can this be improved?
21:19:12 <lambdabot> (b1 -> (b, b1)) -> State b1 a -> State b1 b
21:19:47 <GeneralMayhem> roboguy_: where the input would look like "content/note"
21:20:08 <roboguy_> GeneralMayhem: you need a custom Read instance for that
21:20:15 <roboguy_> well
21:20:18 <roboguy_> that would still be a bad idea
21:20:35 <roboguy_> because this should hold: read . show = id
21:20:41 <GeneralMayhem> roboguy_: yeah, i know, but since it's parameterized i want the content part to delegate to the existing read instance
21:21:06 <GeneralMayhem> roboguy_: yes, that would be the case; the show instance knows to insert the slash
21:21:55 <roboguy_> the show instance would need to remove quotes too
21:22:45 <GeneralMayhem> roboguy_: yes, i got that now, which is why it won't work; it would have to know to use that custom read/show for Annotated String, which is significantly less than ideal
21:22:58 <GeneralMayhem> roboguy_: i had just completely forgotten about the quotes with String
21:23:05 <GeneralMayhem> roboguy_: brainfart, it's after midnight here
21:23:16 <roboguy_> it would be hard because you sometimes want to use the Read instance but for a specific type (namely String), you want to do something different. you might be able to do something with closed type families
21:24:22 <roboguy_> actually maybe not, hmm
21:25:59 <GeneralMayhem> i should just be able to turn on overlapping instances and then define instance Read (Annotated String) and then also instance Read a => Read (Annotated a) as a fallback
21:26:13 <GeneralMayhem> ?
21:26:20 <roboguy_> yeah, that should work
21:30:18 <Jaood> in what language was GHC written in first? (to bootstrap it)
21:30:48 <zomg> I feel like I'm staring the obvious to the face and not seeing it.. but is there a version of find that works with monads? Similar to filter becomes filterM
21:31:02 <startling> :t find
21:31:03 <lambdabot> (a -> Bool) -> [a] -> Maybe a
21:31:08 <startling> zomg: it's not clear what you want
21:31:11 <roboguy_> Jaood: looks like it was Lazy ML
21:31:23 <startling> :t filterM
21:31:23 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
21:31:24 <zomg> startling: basically (a -> m Bool) -> [a] -> Maybe a
21:31:27 <Kaidelong> HGL requires X11 or Win32
21:31:34 <Kaidelong> is X11 satisfied on Apple systems?
21:31:35 <zomg> Maybe I should go sleep because it seems like this should be obvious
21:31:35 <zomg> lol
21:31:38 <Kaidelong> OS X
21:31:40 <Kaidelong> I mean
21:31:51 <zomg> startling: actually the return would be m (Maybe a)
21:31:53 <zomg> but yeah
21:32:05 <roboguy_> Jaood: and it sounds like that was a brief period and it was soon after rewritten in haskell
21:32:06 <Kaidelong> I know OS X used to include X11 but I don't think that's true anymore
21:32:28 * hackagebot yesod-fay 0.5.2 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.5.2 (MichaelSnoyman)
21:32:41 <startling> :t \f -> liftM listToMaybe . filterM f
21:32:42 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
21:32:42 <roboguy_> Kaidelong: I thought you still had to get X11, it was just officially supported (or something like that)
21:32:42 <Kaidelong> weren't there existing haskell implementations by the time GHC came on the scene?
21:32:48 <startling> zomg: ^
21:32:52 <startling> Kaidelong: yeah, I think so too
21:32:55 <Jaood> roboguy_: is there lots of C todays GHC?
21:33:02 <Jaood> +in
21:33:07 <roboguy_> Kaidelong: I don't think so
21:33:15 <zomg> startling: ha, I knew it should've been obvious =) thanks
21:33:26 <roboguy_> Jaood: not really. just the run time system
21:33:37 <roboguy_> I don't think there was ever any C other than that
21:34:01 <roboguy_> this reminds me, I still need to read SPJ's history of haskell
21:34:11 <Kaidelong> Jaood: I think GHC is, like other optomizing compilers, intentionally restricted to the language it is written in so that it benefits from its own optomizations
21:34:31 <Kaidelong> but I think there is a severe amount of perl and python in the GHC project for configuration and scripting purposes
21:35:07 <roboguy_> the GHC GitHub has a breakdown of the languages used
21:35:44 <roboguy_> right now, 82.5% Haskell, 12.2% C, 2.2% TeX (documentation I guess) and 2.9% other
21:35:58 <Jaood> Kaidelong: k
21:36:26 <Kaidelong> restricted to the language it compiles*
21:41:05 <Jaood> I'm learning clojure but internetz hypes are making me consider in switching my efforts to haskell ;)
21:43:57 <impureThoughts> Anyone recall the language extension that permits -1 instead of (-1)?
21:45:06 <Kaidelong> Jaood: Clojure is pretty hyped too, it seems nice
21:45:19 <startling> Clojure is pretty solid.
21:46:37 <roboguy_> impureThoughts: are you sure that exists? that seems like it could cause some ambiguity problems
21:47:28 <roboguy_> also x-1 would probably be x (-1) instead of x - 1, which seems unintuitive
21:47:29 * hackagebot yesod-form 1.3.8.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.8.3 (MichaelSnoyman)
21:47:31 <startling> impureThoughts: NegativeLiterals
21:47:32 <impureThoughts> roboguy_: I'm pretty sure it was needed for some library I used once.
21:47:42 <roboguy_> oh, huh
21:48:06 <impureThoughts> roboguy_: I just fired up ghci, and let x = -1 worked...
21:48:18 <roboguy_> impureThoughts: ?
21:48:31 <startling> impureThoughts, that's normal
21:48:33 <startling> > -1
21:48:34 <impureThoughts> roboguy_: But let x = 5 + -1 doesn't.
21:48:35 <lambdabot>  -1
21:48:41 <startling> > 5 + -1
21:48:43 <lambdabot>  Precedence parsing error
21:48:43 <lambdabot>      cannot mix ‘GHC.Num.+’ [infixl 6] and prefix `-' [infixl 6] in the same ...
21:50:08 <impureThoughts> I suppose for my case it doesn't matter, I just want a simple, readable list of values. But I was fairly sure there was some language extension that only worked in newer GHC versions that would have parsed 5 + -1
21:50:23 <startling> > [-1, -2, -3] -- ??
21:50:24 <lambdabot>  [-1,-2,-3]
21:50:32 <impureThoughts> Right... That'll work.
21:50:51 <chance> so, perhaps i have this snippet: https://gist.github.com/ecnahc515/44fa1c17dd571ac0c9dd#file-hw2_snippet-hs-L25 how could i change the highlighted line 25, to a where statement?
21:51:05 <chance> i was getting syntax errors originally with a where clause so i just made it into a let
21:51:34 <Jaood> Kaidelong: startling: yeah, I guess its haskell type system that make it more attractive than clojure for some
21:51:55 <startling> Haskell's type system is pretty nice.
21:52:30 * hackagebot pandoc-types 1.12.3.3 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.3.3 (JohnMacFarlane)
21:52:31 <Jaood> and some care more about the platform it runs (the jvm)
21:52:54 <chance> hmm nvm
21:52:58 <chance> i guess it works when i try now
21:53:04 <chance> must have been an indentation error
21:54:55 <Jaood> so how you guys build ghc in linux? you install the distro version and then remove it?
21:55:44 <pavonia> You install the Haskell Platform, I guess
21:56:22 <pavonia> Jaood: Or is there a special reason you want to build it yourself?
21:56:47 <impureThoughts> pavonia: I think he means the bootstrapping issue.
21:57:12 <pavonia> Oh, I didn't read the messages above, sorry
21:57:21 <Jaood> pavonia: not a good one :P
21:57:45 <Jaood> just to have latest ghc
21:58:29 <napping> Jaood: different versions of ghc don't necessarily interfere
22:02:05 <roboguy_> Jaood: the latest version has a prebuilt version for several platforms
22:04:15 <Jaood> roboguy_: oh right http://www.haskell.org/ghc/download_ghc_7_8_2#x86_64linux
22:04:39 <Jaood> napping: yeah, was going to install it on my home dir anyways
22:05:28 <roboguy_> chance: where did you put the where clause?
22:05:38 <roboguy_> it should come after the function body
22:05:55 <roboguy_> in this case, after the "_ -> Nothing" line
22:07:01 <TallerGhostWalt> have any of the great parsing libraries been ported over to the haskell-like java engines?
22:07:16 <TallerGhostWalt> like Fay or Haste?
22:07:27 <roboguy_> you mean javascript?
22:07:32 <TallerGhostWalt> I guess haste is more than haskell like
22:07:33 <TallerGhostWalt> sorry
22:07:35 <TallerGhostWalt> yeah javascript
22:11:12 <TallerGhostWalt> I use a lot of angular, but if there were a parsing library of sufficient quality I could see switching over to one of those and then just writing the dom re-writer thing
22:13:21 <Kaidelong> what you're looking for is a "monadic parser combinator library"
22:13:35 <Kaidelong> knowing that term might be useful for finding something for javascript
22:13:43 <Kaidelong> I found this: https://github.com/jneen/parsimmon
22:14:00 <nisstyre> if you're interested in just javascript, there is also JSMeta
22:15:21 <nisstyre> er, actually it's just ometa I guess: http://tinlizzie.org/ometa/
22:16:39 <TallerGhostWalt> really more html
22:17:29 <TallerGhostWalt> I was wanting to experiment with building something like the react stuff for a haskell thign
22:17:41 <TallerGhostWalt> or the angular dom manip stuff
22:18:25 <TallerGhostWalt> just that dynamic html style on client side that angular makes possible w/o having to write angular controllers and all that kludgy stuff
22:18:29 <TallerGhostWalt> thanks, I will look around
22:26:19 <TallerGhostWalt> exit
22:26:25 <TallerGhostWalt> lol
22:27:45 <cococo> What does the "in" keyword do/mean in Haskell? For example, taken out of tryhaskell.org: let square x = x * x in square 52
22:28:05 <Kaidelong> where does the cabal package cache live on windows?
22:28:18 <m09> cococo: it's part of the let ... in form
22:28:51 <sgronblo> it means that in square 52, square has the definition that comes from the let before the in
22:30:27 <m09> cococo: and note that let is used alone in list comprehensions, such as [y | x <- [1..50], let y = x * 2, y < 20]
22:30:44 <m09> but that you do need the `in` in other situations
22:31:25 <angerman> m09: do notation is another notable let without in example, I would think.
22:33:14 <m09> oh sure, my bad
22:34:14 <cococo> so isn't "let square x = x * x in square 52" the same as just "let square = 52 * 52"?
22:35:05 <mmachenry> cococo: No it's the same as "52*52"
22:35:05 <sgronblo> Yeah but that is probably just an example?
22:35:47 <mmachenry> square is defined to be a function within the scope of the expression after the IN.
22:36:44 <mmachenry> cococo:  Does this help?
22:36:47 <mmachenry> > let f x = x+1; g x = x+2 in f 2 + g 2
22:36:48 <lambdabot>  7
22:37:42 <mmachenry> In that expression we definite two function in the let that we can use in the body.
22:38:04 <cococo> mmachenry: not really. Haskell is totally weird compared to any language I've ever learned. I'm sure I'll get it eventually though :)
22:38:26 <mmachenry> cococo: Well you've probably never used a functional programming language.
22:38:28 <m09> let is a common idiom though, not only haskell
22:38:48 <mmachenry> let is common to that set. OCaml, Hakell, Lisp, Scheme
22:39:16 <angerman> cococo: think about let x = y as "define x to be y, but just for the current scope, in which I'm goign to use this definition"
22:39:23 <sgronblo> to me let and where seem to be about breaking up a complex expression, one by defining the branches first and the other by defining them after.
22:40:09 <m09> cococo: http://learnyouahaskell.com/syntax-in-functions#let-it-be
22:40:11 <m09> if that helps
22:40:31 <cococo> thanks, I'll read that
22:40:46 <m09> btw the whole book is great
22:40:53 <m09> if you feel like reading other parts of it
22:41:38 <cococo> m09: I read the first few sections of it and it was a great introduction. I guess I'll just continue going through there.
22:43:33 <angerman> cococo: learnyouahaskell, is really good, especially the first few chapters, the end is a bit wordy I would say :) But it definitely gives you a great jump start into haskell.
23:02:13 <levi> The "let" ... "in" syntax is borrowed pretty straightforwardly from the mathematical idiom for introducing variables.
23:02:37 <hunt> hey haskell, this is not strictly a haskell question but im having trouble proving that the limit of a fraction such as (2/3)^n as n increases actually approaches 0. any tips? ive exhausted all my other resources afaik
23:02:52 <jle`> hunt: try #math?
23:03:01 <hunt> ahh kk thanks jle`
23:03:04 <jle`> or at least #haskell-blah
23:03:17 <jle`> cococo: have you ever taken a math class? it's similar notation to there
23:04:20 <jle`> cococo: you can think of it like a sed/substitution in a way.  let (x = blah) in (x + 4) means "wherever you see "x" in "x + 4", replace it with "blah"
23:05:17 <m09> jle`: with the added benefit that you know it won't be recomputed
23:05:18 <cococo> thanks jle`
23:10:19 <chance> so i know this syntax isnt immediately correct, but im curious how i could go about this: https://gist.github.com/ecnahc515/4b341475e16118baf49f
23:10:23 <l0cust> hunt: It's pretty simple - the denominator is increasing faster than the numerator. Hence, the number approaches zero
23:10:46 <hunt> l0cust how do you prove that, the derivatives dont give you anything
23:11:15 <l0cust> hunt: You could reverse l'hopital's rule
23:11:20 <chance> basically if i have a recursive data type that takes two of its own type, and a form that isnt recursive. ex Seq and MoveTo, how do i go from a List of MoveTo to a single Seq composed of MoveTo
23:11:33 <hunt> l0cust: really? what does that imply
23:11:55 <f-a> chance: , as it is, it's obviously Cmd -> Cmd
23:12:02 <chance> yeah, i know
23:12:05 <chance> well
23:12:07 <chance> [Cmd] -> Cmd
23:12:10 <f-a> yeah
23:12:36 <f-a> you could
23:12:43 <chance> so im just not sure how to handle dealing with cases where Cmd is not MoveTo
23:12:46 <f-a> chance: , you could make an intermediate type
23:13:00 <f-a> data Foo = blalblalb
23:13:03 <chance> cause ideally id just have a list of [(x,y)] pairs
23:13:10 <chance> and i could convert that to a list of MoveTo
23:13:15 <f-a> data Cmd = CFoo Foo
23:13:17 <SrPx> Is there any paper explaining the epic compiler? My googlefu is failing on me
23:13:19 <chance> and if I have a form of seq i can draw it
23:13:19 <pavonia> chance: You could also use GADTs for giving more restrictive types
23:13:37 <chance> basically i have a pre-existing function id like to conver the list of moveto into a Cmd
23:13:54 <l0cust> hunt: Actually, l'Hopital's rule wouldn't really be of use, because you would have to do an indefinite integral. I would suggest something like let x be the numerator, y be the denominator. because x < y, x^n < y^n, so every (x^i / y^i) <  (x^{i+1} / y^{i+1})
23:14:02 <l0cust> oh oops
23:14:13 <l0cust> (x^i / y^i) >  (x^{i+1} / y^{i+1})
23:14:55 <l0cust> hunt: or rather |x^i / y^i| <  |x^{i+1} / y^{i+1}|. Thus, the limit as n approaches infinity is zero
23:15:16 <hunt> frustrating that the only legitimate solution seems to be centered around induction
23:15:19 <chance> pavonia: yeah thats what im doing basically
23:15:49 <l0cust> hunt: What's wrong with induction?
23:16:48 <l0cust> hunt: Oops, I did it again. this is correct: |x^i / y^i| >  |x^{i+1} / y^{i+1}|
23:16:49 <hunt> l0cust: this is part of a collection of problems im solving for my calc class and induction feels out of place
23:17:42 <l0cust> hunt: It's probably not quite the answer they're looking for, but it's definitely the best way to do the problem.
23:17:49 <l0cust> hunt: that I can think of
23:18:32 <l0cust> hunt: It's a perfectly valid way of solving a convergence problem tho
23:19:21 <shouya> @where ops
23:19:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:20:21 --- mode: ChanServ set +o glguy_
23:20:57 <glguy_> <_<
23:20:58 --- mode: glguy_ set -o glguy
23:26:47 <richy_> Can someone please help me in cpannel on my web host's server i'm having trouble running a php script, plz I have $19 on my mom's card. I need help making a   form for my middle school I have teamviewer 9, plz some1
23:27:11 <richy_> plz my mom unplugs the router at 1 am at night
23:27:15 --- mode: ChanServ set +o corgifex
23:27:16 <richy_> cause she says I dnt get enough sleep
23:27:22 <jle`> :|
23:27:30 <corgifex> richy_: how is that a haskell question?
23:27:35 <l0cust> richy_: I don't know anything about php, so I can't help you
23:27:39 <richy_> im sorry its not
23:27:45 <l0cust> richy_: Maybe a php channel
23:27:45 <richy_> but no one talks to me
23:27:48 <richy_> in other channels
23:27:51 --- mode: corgifex set +q $a:shouya
23:27:55 <richy_> they told me to grow up
23:27:58 <richy_> and banned me
23:28:03 <corgifex> so?
23:28:08 <corgifex> still not a haskell issue
23:28:14 <richy_> sorry
23:28:19 <richy_> plz can u help me tho
23:28:31 <richy_> i already have the script working
23:28:32 <jle`> maybe try #haskell-blah
23:28:41 <Zekka> I don't know PHP very well but depending on your problem I can try to help -- query me?
23:28:42 <richy_> but it wont work
23:28:44 --- kick: richy_ was kicked by corgifex (not a haskell question)
23:28:56 <l0cust> ahbl
23:29:03 <richy_> what happened
23:29:11 <corgifex> I kicked you out
23:29:13 <Zekka> He kicked you because your question didn't pertain to haskell
23:29:32 <corgifex> more like because you're aggressively, persistently off-topic
23:31:50 <l0cust> corgifex: thank you
23:34:49 <l0cust> Is it all concerning that so many people are joining #haskell at 2 in the morning?
23:35:12 <mayski> 2 in the morning for you
23:35:40 <l0cust> mayski: silly finnish people. Everyone is american
23:36:05 <mayski> ah right I forgot
23:36:41 <l0cust> mayski: It's honestly a trope, though. I have a habit of assuming everyone is American. I think most Americans do too.
23:36:55 <mmachenry> I don't.
23:37:02 <mmachenry> But it is 2am for me too.
23:37:08 <l0cust> mayski: I should have known by your perfect English that you couldn't possibly be American.
23:37:19 <mmachenry> Well 2:35
23:37:42 <l0cust> I'm actually in mountain time, so it's only 00:35. But, i'
23:37:43 * mayski blushes
23:38:08 <l0cust> I'll probably be here at 2:35
23:39:34 * l0cust tips fedora
23:39:35 <bergmark> top of the morning to you!
23:39:56 <l0cust> bergmark: nice try, texas
23:41:10 <mmachenry> l0cust: Server you connect to doesn't mean much, Mr Helsinki, FI from Mountain Time
23:41:12 <l0cust> bergmark: oops, your freenode mirror is in texas. My apologies for calling you a texan
23:41:16 <mmachenry> Finish mountains?
23:41:54 <l0cust> mmachenry: I'm in Utah, in the United States. My time zone is called Mountain Daylight Time, or "Mountain time"
23:42:11 <mmachenry> I know what the time zones are :)
23:42:31 <l0cust> The rocky mountains run through my region. Ah sorry, forgot you were american
23:42:41 <corgifex> @time bergmark
23:42:41 <lambdabot> Local time for bergmark is Wed Apr 30 08:41:16 2014
23:42:44 <mmachenry> I'm just pointing out that you called bergmark out for being in Texas based on his IRC server when you yourself are connected through Finland.
23:42:55 <l0cust> mmachenry: Really? hm
23:43:02 <corgifex> @time l0cust
23:43:03 <lambdabot> Local time for l0cust is Wed Apr 30 00:41:14 2014
23:43:10 <l0cust> Yeah, I forgot to look at the ip address
23:43:19 <l0cust> @time lambdabot
23:43:19 <lambdabot> I live on the internet, do you expect me to have a local time?
23:43:28 <Feuerbach_> haha
23:43:41 <mmachenry> lambdabot: Yes
23:44:50 <Feuerbach> hey bergmark
23:45:16 <l0cust> Why is it that someone in finland is connected through texas, and I'm connected through finland?
23:45:24 <l0cust> I'm thinking freenode needs to evaluate themselves
23:45:43 <l0cust> Or do I just not know how this IRC stuff works?
23:45:50 <corgifex> dns round robin
23:46:47 <tdammers> l0cust: the "which server do you get" thing is pretty simplistic actually
23:47:05 <tdammers> it doesn't take geographic vicinity into account, just distributes people over available servers as they come
23:47:25 <l0cust> I suppose it isn't a big deal, since it's only dealing with plain text
23:48:08 <tdammers> well, I think the biggest concern is for the network to survive netsplits
23:48:15 <l0cust> ah yes
23:48:19 <l0cust> what are those
23:48:49 <tdammers> a netsplit happens when enough servers lose connection between them to split the network in two
23:48:56 <l0cust> ah.
23:49:12 <mmachenry> It's where your link look used to totally be able to pwn someone's channel until everyone got all these chanserv guard dogs. :)
23:49:13 <corgifex> "enough servers" == 2
23:49:32 <tdammers> corgifex: hmm, really?
23:49:44 <d1323> sure
23:49:49 <Zekka> Fixed richy's problem for anyone who cares (wouldn't blame you if you didn't)
23:49:59 <Zekka> he hasn't realized it yet but it should be fine now
23:50:12 <l0cust> Zekka: What was his problem?
23:50:20 <corgifex> tdammers: irc connections are generally non-redundant
23:50:26 <Zekka> l0cust - Strangely, something that wasn't his fault. His host seems to handle case-sensitivity strangely
23:50:32 <m09> damn I would never have asked him to query me that was some noble action back there
23:50:33 <Zekka> I can't request files from his server whose names contain a capital letter
23:51:44 <tdammers> corgifex: hmm, I was under the impression that the network would just re-route things when a server drops out
23:51:58 <tdammers> you'd lose connections to that one server, but not all of them
23:52:10 <l0cust> Zekka: that's odd
23:52:12 <tdammers> s/all of them/more
23:52:39 <Zekka> l0cust - I have no idea what the cause is but an easy bandaid is just renaming anything that needs to be served to a client
