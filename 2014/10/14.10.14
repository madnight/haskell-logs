00:00:58 <solatis> https://gist.github.com/roman/1252086
00:01:04 <solatis> that seems to be pretty much what i want
00:04:41 <Lutin`> solatis: Yeah most of the time you want to define appropriate instances of Arbitrary
00:04:52 <Lutin`> Instead of just creating a generator using combinators
00:05:19 <Lutin`> As you'll end up doing the same thing either way, just one way will be properly encapsulated
00:05:34 <solatis> yeah but the amount of boilerplate code required seems to be a lot more than it would take me to generate a huge set of url's
00:06:14 <solatis> but just for the heck of it, i'll use quickcheck in this case
00:07:44 <Lutin`> Well how would you generate that huge set of urls?
00:11:01 * hackagebot thyme 0.3.5.3 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.3 (LiyangHu)
00:48:58 <srenatus> "cabal: fromFlag NoFlag. Use fromFlagOrDefault" when trying to follow the stackage instructions, i.e. adding the snapshot's remote-repo line to .cabal/config. any hints?
01:01:04 * hackagebot cluss 0.3 - simple alternative to type classes  http://hackage.haskell.org/package/cluss-0.3 (Kinokkory)
01:04:07 <hello> ghc
01:06:04 <hughfdjackson> ski: hrm - it seems like my interpreter and haskell output the same thing
01:06:27 <hughfdjackson> ski: https://gist.github.com/hughfdjackson/5f2a6d82054a43dd9ca4
01:07:46 <Aleksejs> > isPrefixOf "" "why this is true?"
01:07:48 <lambdabot>  True
01:08:09 <merijn> Aleksejs: Because
01:08:25 <merijn> > "" ++ "why is this true?" == "why is this true?" --this
01:08:27 <lambdabot>  True
01:08:43 <Aleksejs> I see
01:09:17 <Aleksejs> just got andless recursion because of this, couldn't figure out where is a problem for 1/2 hour
01:09:24 <Aleksejs> endless*
01:09:48 <Twey> Heh
01:10:03 <Twey> > "" ++ "why is this true?" == "why is this true?" -- ""
01:10:05 <lambdabot>  True
01:10:11 <hughfdjackson> ski: ooh, yes, my BNF comment is totally wrong
01:10:18 <hughfdjackson> ski: fixing :D
01:11:05 * hackagebot tidal 0.4.14 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.14 (AlexMcLean)
01:11:23 <Aleksejs> merijn: but
01:11:31 <Aleksejs> > "a" ++ "ba
01:11:33 <lambdabot>  <hint>:1:11:
01:11:33 <lambdabot>      lexical error in string/character literal at end of input
01:11:39 <Aleksejs> > "a" ++ "abc" == "abc"
01:11:40 <lambdabot>  False
01:12:09 <Aleksejs> > isPrefixOf "a" "abc"
01:12:11 <lambdabot>  True
01:12:44 <Aleksejs> @src isPrefixOf
01:12:44 <lambdabot> isPrefixOf [] _          = True
01:12:44 <lambdabot> isPrefixOf _  []         = False
01:12:44 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
01:15:04 <Aleksejs> hmm, not sure if 1st statement in isPrefixOf src makes sense
01:15:39 <simpson> Aleksejs: Sure it does. It's one of the base cases.
01:16:06 * hackagebot defargs 0.3 - default arguments in haskell  http://hackage.haskell.org/package/defargs-0.3 (Kinokkory)
01:19:11 <merijn> Aleksejs: What else would it be?
01:20:22 <Aleksejs> I understand why it's there, but it just not obvious that isPrefixOf [] any_list is True
01:23:23 <nulpunkt> Aleksejs: Up untill that happens the first list has been a prefix of the second
01:23:37 <nulpunkt> Aleksejs: Thus because the first list i empty, it must still be
01:25:35 <nulpunkt> This implies that "" `isPrefixOf` "abc" is true, however
01:26:15 <jle`> yeah, i agree, it's a funny definition of prefix
01:26:43 <osfameron> it's the base case
01:26:45 <nulpunkt> it kinda makes sense
01:27:00 <nulpunkt> I'd say the empty set is a subset of every other set
01:27:24 <merijn> I don't think it's funny? I'm not sure what else you'd define it as?
01:29:15 <Aleksejs> Here's a proof of nulpunkt statement http://math.stackexchange.com/a/528651
01:30:14 <merijn> nulpunkt: It is, traditionally
01:30:30 <nulpunkt> merijn: Yeah :)
01:46:07 * hackagebot hadoop-rpc 0.1.1.0 - Use the Hadoop RPC interface from Haskell.  http://hackage.haskell.org/package/hadoop-rpc-0.1.1.0 (JacobStanley)
01:46:09 * hackagebot hadoop-tools 0.4 - Fast command line tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.4 (JacobStanley)
02:16:09 * hackagebot aeson 0.8.0.2 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.8.0.2 (BasVanDijk)
02:31:09 * hackagebot hadoop-rpc 0.1.1.1 - Use the Hadoop RPC interface from Haskell.  http://hackage.haskell.org/package/hadoop-rpc-0.1.1.1 (JacobStanley)
02:36:37 <jle`> i read that as hadoop-rpg
02:36:42 <jle`> and i got excited
02:36:54 <jle`> but now, am sad
02:54:47 <solatis> hmm i'm using quickcheck, and i see it uses the Bounded typeclass to define ranges for numbers to generate, for example
02:55:00 <solatis> but my google fu doesn't let me find any practical examples on how to define those bounds
02:55:33 <solatis> for example, in my case, i want port numbers -- so [0 1 ... 65535]
02:55:55 <solatis> how can I define these bounds for an Int ?
02:56:11 * hackagebot fft 0.1.7.3 - Bindings to the FFTW library.  http://hackage.haskell.org/package/fft-0.1.7.3 (HenningThielemann)
02:56:24 <solatis> will I have to define my custom instance Bounded PortNumber where ... ?
02:57:13 <solatis> and would it actually mean that it's maybe an idea to define this bounded PortNumber as a type of the class/struct i'm testing, rather than using an Int ?
02:57:32 <solatis> (sorry for the loud thinking..)
03:00:06 <solatis> maybe i should actually be looking at the definition of Int, since it appears to be a bounded Number
03:08:15 <Qfwfq> To instance 'Bounded', just provide terms representing the smallest and largest term. instance Bounded PortNumber where { minBound :: PortNumber 0, maxBound :: PortNumber $ 2^16-1 }.
03:15:16 <quchen> solatis: Where do you see the "Bounded" in QuickCheck? It's only there in a handful of functions as far as I can tell
03:18:05 <quchen> To generate a random port number, you could also generate a random Int in the desired range and then wrap it in PortNumber, like  `fmap PortNumber (choose (MIN, MAX))`
03:18:43 <Qfwfq> Yeah, that'd give you a generator.
03:26:22 <aleator> My intuition about Haskell efficiency sucks: http://pastebin.com/w5ZZ9c56
03:26:28 <aleator> Any easy explanations?
03:28:09 <ocharles> Anyone here familiar with PHOAS? I'm trying to write a STLC, but I get an ambiguous type error if I try and encode `const`: http://wiki.ocharles.org.uk/Name%20Binding%20in%20EDSLs
03:29:26 <ocharles> Doh, I guess if I actually gave `const` all its arguments in `App` I wouldn't have a problem
03:31:01 <aleator> Is there some rewrite rule magic  for (take l xs, drop l xs)?
03:31:56 <zwer_z> > take l &&& drop l
03:31:58 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
03:31:58 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
03:31:58 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
03:32:03 <zwer_z> > :t take l &&& drop l
03:32:04 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
03:32:14 <zwer_z> > :t (take l) &&& (drop l)
03:32:15 <ClaudiusMaximus> splitAt l xs  (but it's not automagic)
03:32:16 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
03:32:51 <aleator> I mean, why is doing (take l xs, drop l xs) where l = length xs `div` faster than directly recursive versions (http://pastebin.com/w5ZZ9c56)
03:36:13 * hackagebot hsc3-sf 0.15 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.15 (RohanDrape)
03:36:15 * hackagebot hsc3-sf-hsndfile 0.15 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-hsndfile-0.15 (RohanDrape)
03:36:35 <gregnwosu> lo
03:36:37 <shiona> I have a boardgame in the makes. Up until this point I've had 'data Square = Black | White | Wall | Empty', and had a state 'whiteTurn :: Bool'. I'm trying to make the code less ugly by moving to 'inTurn :: Player', but I don't know if I should leave the Square as is and have 'data Player = BlackP | WhiteP', or have 'data Player = Black | White; data NoPlayer = Wall | Empty; data Square = Either Player NoPlayer'
03:36:56 <shiona> any ideas?
03:37:04 <shiona> or pros/cons
03:37:48 <jle`> factoring out data types is usually nice, custom sums are often preferred too i think
03:38:25 <shiona> Oh, I didn't have Empty there, because the board was a Map Coord Square
03:38:58 <shiona> ok, so I'll see how this refactoring goes
03:39:51 <linduxed> while i don't know the structure of your application that well, i would think that i'd use a Matrix of Maybe(Piece) to implement a board
03:40:24 <solatis> quchen: they have generators for, for example, arbitraryBoundedIntegral
03:40:35 <solatis> my type is Int
03:40:47 <solatis> which represents a port number
03:41:17 <solatis> but I think that I should actually refactor my port number to have type PortNumber, which is instance Bounded PortNumber { ... }
03:41:31 <shiona> linduxed: That's what I always end up thinking. But reading tutorials on this stuff I get the feeling everyone else uses Maps, so I thought maybe the matrix-centric idea comes from my C-background
03:41:52 <linduxed> yeah, maybe
03:42:14 <linduxed> i remember having a problem where i implemented a Battleship game using matrices
03:42:44 <linduxed> a problem arose where the input from the player ("where do you shoot next") was integers in string format
03:42:51 <linduxed> this needed to be converted to a string
03:42:57 <linduxed> sorry, to an integer
03:43:18 <linduxed> which in turn i tried to apply to the coordinate system provided by the Matrix
03:43:33 <pjdelport> aleator: A big difference there would be that "drop middle x" can stop in the middle of the list, and simply re-use the tail without reallocating anything.
03:43:40 <linduxed> unfortunately, this makes an out-of-bounds checking mechanism an absolute necessity
03:43:48 <pjdelport> aleator: So it potentially does half the work of the other solutions.
03:43:54 <linduxed> so you have to test that thing to make sure that it doesn't break
03:44:15 <quchen> aleator: There is no magic rule, but you can do it yourself: split
03:44:39 <quchen> Or was it splitAt
03:44:48 <linduxed> what i would prefer in that situation (and i haven't figured out how one would do this) is to have some sort of data structure that could provide the notion of coordinates (as is necessary for a board) but have a structure which one could map over safely
03:44:57 <linduxed> with no risk of doing an out-of-bounds move
03:45:25 <linduxed> i haven't given it much thought, but that would be the kind of data structure i'd like to use for a board game like system
03:45:29 <quchen> aleator: And I don't think dealA does the same thing as dealB.
03:45:46 <linduxed> but, as said, i haven't figured what data structure that would be
03:46:00 <pjdelport> aleator: By comparison, the other solutions *must* end up reallocating space proportional to the size of the entire list.
03:47:11 <aleator> quchen: Yeah, they are only the same that they approximately split things in half
03:50:06 <aleator> pjdelport: I see. So drop can actually re-use the existing list.
03:50:35 <pjdelport> aleator: Right: it only "skips" the given number of elements, and returns the remaining tail directly.
03:50:57 <aleator> pjdelport: And apparently traversing is light so length doesn't matter as much as allocating new elements
03:53:09 <pjdelport> aleator: Right, traversal will always be cheaper, because allocation is just traversing *plus* allocation.
03:53:21 <pjdelport> (speaking hand-wavily, here)
03:53:26 <solatis> ok, now what is this error
03:53:31 <solatis> `Illegal literal in type (use DataKinds to enable): 0`
03:53:39 <solatis> and should I care, or just enable DataKinds?
03:53:39 <quchen> aleator: Some more implementations! http://lpaste.net/112563
03:54:02 <solatis> type PortNumber = Int
03:54:03 <solatis> instance Bounded PortNumber where {
03:54:05 <solatis>   minBound :: PortNumber 0,
03:54:08 <solatis>   maxBound :: PortNumber 2^16-1
03:54:10 <solatis>   }
03:54:13 <solatis> the problem arise with the '0' number
03:54:20 <solatis> what makes that illegal?
03:54:29 <quchen> The second one uses a neat trick to split a list in two parts of equal size, and it works even when the lists are infinite (only the first tuple element will be defined though)
03:54:50 <quchen> solatis: You're using `::`, that's for types.
03:54:53 <quchen> What you want is `=`.
03:54:59 <solatis> d'oh
03:55:16 <quchen> And you'll need parentheses in the maxBound definition.
03:56:06 <ThreeOfEight> solatis: you probably also want newtype PortNumber = PortNumber Int
03:56:10 <aleator> quchen: Let's bench them..
03:56:14 * hackagebot hydrogen-version 1.1 - Hydrogen Version type  http://hackage.haskell.org/package/hydrogen-version-1.1 (JulianFleischer)
03:56:23 <solatis> ThreeOfEight: alright
03:56:46 <pjdelport> quchen: That's a neat trick!
03:56:57 <ThreeOfEight> Like this, PortNumber is only an abbreviation for int
03:57:01 <ThreeOfEight> *Int
03:57:16 <aleator> quchen: dealE is slowest according to criterion (84ms vs 20ms of C)
03:57:18 <ThreeOfEight> so what you're doing is you're actually giving a Bounded instance for Int
03:57:24 <ThreeOfEight> which you can't, since Int already has one
03:57:25 <aleator> quchen: dealF is faster (49ms)
03:57:30 <aleator> Small variance.
03:57:39 <ThreeOfEight> (and even that requires TypeSynonymInstances)
03:58:10 <ThreeOfEight> by wrapping the Int in a newtype (which is semantically the same as data), you can give instances like this
03:58:28 <quchen> aleator: You cannot compare two functions that don't do the same.
04:01:10 <shiona> at least the code is now .. strange
04:01:58 <shiona> \board coord color -> if Map.lookup coord board == Just Right color then ...
04:02:20 <shiona> I feel I'm doing something wrong having Either inside a Maybe, but I'll let it slide for now
04:02:22 <quchen> That looks strange indeed. Paste the entire thing?
04:02:51 <shiona> quchen: It's in the middle of refactoring, the code is not working right now
04:03:06 <shiona> But I guess I could paste it if you want to see some newbie code
04:03:56 <quchen> Nah I'd rather wait for something with a concrete question :-)
04:04:07 <shiona> :D
04:08:15 <solatis> hmz and now haskell wants my PortNumber to be a Integral
04:08:30 <solatis> but it appears to not be as easy as deriving (Integral) ?
04:08:44 * solatis feels like he's finally getting into the world of typeclasses
04:10:10 <gigabytes> hi
04:10:48 <gigabytes> I notice all those modules that provide names clashing with the prelude and suggesting to use the module qualified. Beside the prelude, all those module clash with each other
04:11:08 <gigabytes> has anybody ever proposed a hierarchy of typeclasses to overload those functions?
04:11:18 <gigabytes> like lookup, (!), insert, etc...
04:13:39 <solatis> ahhh it's too late for this kind of nonsense now anyway
04:13:43 <solatis> i'll look into it tomorrow
04:16:15 * hackagebot twentefp-eventloop-graphics 0.1.0.4 - Used as Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-eventloop-graphics-0.1.0.4 (sebaslafleur)
04:16:17 * hackagebot twentefp-graphs 0.1.0.1 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-graphs-0.1.0.1 (sebaslafleur)
04:22:54 <assia_t> Hey people
04:23:35 <EvilMachine> And machines too? :/
04:23:39 <EvilMachine> ;)
04:23:44 <assia_t> Has anyone tried to set-up a vagrant box with haskell? I'm trying to, but when I do `cabal update`, it runs out of memory (hehehe), consuming all 1048576bytes available
04:24:31 <assia_t> My real problem is a lot earlier than that; I'm trying to install the `friday` package on my OSX system, but it doesn't find the devil header files
04:26:46 <EvilMachine> assia_t: I don‚Äôt know what a vagrant box is, but tiny memory like that will probably not work unless you got some kind of swap file/partition.
04:27:17 <assia_t> Isn't that 1GB?
04:27:32 <assia_t> I'm not even compiling anything, this is just `cabal update`...
04:27:53 <assia_t> Fetching the package listing from hackage consumes 1GB of memory?
04:28:18 <EvilMachine> assia_t: No, 1024*1024 bytes is 1MB.
04:28:27 <assia_t> ooohhh...
04:28:43 <assia_t> mm...
04:29:11 <assia_t> Weird. It must use some dynamic memory reservation thing...
04:29:23 <EvilMachine> Could it be that this is a balloning memory driver? (Where it only becomes bigger if requested)
04:29:46 <zmbmartin> Can I use FlexibleContexts on one method only? Rather then the file?
04:30:36 <assia_t> EvilMachine: Yeah... That's probably it. Still weird though.
04:30:55 <bartavelle> zmbmartin, I *think* this is something planned for the future (or perhaps it's FlexibleInstances)
04:31:51 <ThreeOfEight> What are the downsides of using FlexibleContexts everywhere?
04:33:16 <EvilMachine> assia_t: You may find this helpful: http://en.wikipedia.org/wiki/Order_of_magnitude (Except in computing it‚Äôs not *1000 but 1024, since that‚Äôs a power of 2.)
04:34:30 <assia_t> EvilMachine: For some reason my mind skipped `kilo` before going to `mega`, but I think I'm cool with that; thanks
04:34:36 <EvilMachine> assia_t: It‚Äôs definitely weird. But since I have no idea what a ‚Äúvagrant box‚Äù is‚Ä¶ I‚Äôm gonna assume it‚Äôs a tiny virtual machine for artificial life swarms :)
04:34:57 <assia_t> Yes, it's just a virtual machine
04:56:16 * hackagebot hindent 3.8 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.8 (ChrisDone)
04:59:19 <Guest63568> salve
04:59:23 <Guest63568> lista
05:03:08 <XniX23> are functions that deal with IO still pure? or is the IO type in signature a sign of impurity
05:05:37 <Cale> XniX23: Evaluation of expressions is pure, whether or not they compute IO actions
05:05:59 <Cale> XniX23: Execution of IO actions is what has effects
05:07:29 <Cale> XniX23: Evaluating the expression  getLine :: IO String  will always result in the same IO action, but executing that action might produce a different String result each time.
05:08:01 <Cale> XniX23: Does that help?
05:08:35 <Cale> XniX23: Evaluation refers to the process of turning expressions into values, generally for the purposes of pattern matching
05:09:17 <Cale> XniX23: Execution of IO actions means carrying out the instructions that they describe, which may have effects.
05:10:24 <XniX23> Cale, so on the surface you have purity, but executing a part of it is doing side effects?
05:11:07 <Cale> So long as you're only concerned with which value an expression will evaluate to, it's pure, there are (almost) no effects to worry about.
05:11:07 <XniX23> what's the result of evaluating getLine?
05:11:23 <Cale> Well, since IO is an abstract type, we can't really see it
05:11:55 <Cale> But you can imagine that it's like some syntax for a program that reads a line of text from the user
05:12:48 <Cale> and then that the runtime system has some kind of interpreter which pattern matches on 'main' and carries out the effects described
05:13:40 <Cale> This isn't how it really works in GHC, but it could work that way, and it's a more useful mental model than the actual hackery which goes on :)
05:14:01 <XniX23> and how would one create his own side effects
05:14:10 <XniX23> like read from db or something
05:15:09 <Cale> I'm not entirely sure what you mean, but if you want to write a binding to a C library for instance, there's the FFI which will let you "foreign import" C procedures
05:15:18 <Cale> (giving IO actions)
05:15:37 <Cale> It really depends on how one is meant to communicate with the database
05:15:45 <Cale> There are a bunch of existing database libraries
05:16:16 <zq> FFf
05:16:22 <filoteo> Can we say it is intended effect, explicit in the args, but not side-effect ?
05:16:24 <XniX23> yeah there are, i'm just not sure how you communicate with the outside world not via IO
05:16:33 <Cale> XniX23: You don't.
05:16:52 <Cale> XniX23: Expression evaluation doesn't generally communicate with the outside world.
05:17:14 <XniX23> Cale, so basically the only way to do side effects is IO?
05:17:23 <Cale> To do effects at all, yes.
05:17:33 <kstt> Hi. Template haskell seems to load all packages in the deps tree before outputing splices. On MS Windows, this causes a bug when loading GTK packages, making GHC crash. Is there an option to limit the packages that TH loads, as a workaround ?
05:17:45 <Kaidelong> there are no side effects, the fact that IO exists at all gets rid of the need for side effects
05:17:46 <pjdelport> filoteo: Yes, it makes sense to call IO actions "first class effects"
05:17:49 <Cale> (Calling them side effects is a bit weird in the case of IO actions, because the main purpose of an IO action is to describe effects)
05:17:55 <XniX23> Cale, why do so many people say monads are about side effects if it's only one monad that actually does it lol
05:18:08 <Kaidelong> you need side effects in other languages because they have nothing analogous to IO
05:18:13 <pjdelport> filoteo: "First class" in the sense that they are first-class values that you can treat like any other data.
05:18:18 <Cale> XniX23: I dunno. This really doesn't have anything to do with monads.
05:18:35 <Cale> XniX23: We could neglect to recognise the fact that IO was a monad, and we'd be just fine.
05:18:46 <Kaidelong> Monads are not about side effects, it's kind of hard to think about what they're about, I would say sequencing/collapsibility
05:18:51 <filoteo> thanks
05:19:00 <pjdelport> You can use IO just as a Functor or Applicative a lot of the time, and not even as a Monad.
05:19:06 <Cale> The more important thing is that IO actions are values, and evaluation doesn't cause effects, but something separate from evaluation is interpreting those values to cause effects.
05:19:11 <Kaidelong> which really both are just about carrying around some extra information that's not directly accessible
05:19:58 <Cale> When you think about various monads computationally, they do sort of capture different kinds of abstract machines.
05:20:08 <filoteo> pjdelport: like a magnet moving lime without touching it ?
05:20:10 <pantsman> a huge amount of literature refers to e.g. "IO monad" and "Maybe monad" when in fact is is describing the data type, not the monad. This leads to confusion AFAICT
05:20:28 <Cale> Like, the list monad sort of captures nondeterministic computation (in the sense of nondeterministic Turing machines or other automata)
05:20:36 <chaosfisch> Okay, I think this can't be shortened any further? http://lpaste.net/4391670048037535744 Detects if a,b,c,d,e are distinct with 22 "tokens"
05:20:43 <Cale> and if you're willing to call that an "effect" then go ahead :)
05:24:35 <XniX23> Cale, does every db lib use IO to communicate then (since the only way to communicate outside is io and db is on the outside)?
05:24:39 <lieven_> chaosfisch: fromList -> set -> size == 5
05:27:22 <chaosfisch> lieven_: I don't know how to write that in terms of the comparison, while maintaining the words . printf hack. Your solutions acctually looks the same length!?
05:27:35 <pjdelport> pantsman: Yeah; that's why it's better to talk about "IO actions", or even just "IO values"
05:28:42 <pjdelport> XniX23: Most probably do, but that's not an absolute requirement: there are other ways to do I/O in Haskell.
05:28:45 <lieven_> chaosfisch: something like (size (fromList [a,b,c,d,e]))==5
05:29:14 <pjdelport> XniX23: Haskell didn't start out with the IO type, in fact: it used to use an older and much less convenient way of doing I/O.
05:30:21 <pjdelport> (And then Moggi descended from the mountain bearing monadic goodness, if i understand my history correctly.)
05:33:39 <Fernandos> hi
05:33:51 <Fernandos> is there a scala to haskell converted by coincidence??
05:33:56 <Fernandos> "converter"
05:34:10 <Fernandos> that'd be 'classy' ==)
05:36:27 <pjdelport> Fernandos: I think you'd have to hire one.
05:36:46 <filoteo> well, if you escape scala, that would an heskallator :)
05:37:55 <paldrudley> Hi guys
05:38:38 <filoteo> did anyone notice in yesod they dropped the linked-list String to favor raw bytes, that remind much how in erlang they did the same thing, same context.
05:39:34 <Cale> XniX23: yeah, at some level
05:39:55 <Cale> XniX23: You can have other fancy abstractions built on top
05:40:23 <Fernandos> pjdelport: hehehe, good one!
05:40:46 <Fernandos> my clojure prof hates haskell
05:40:58 <pantsman> why take the spiral stairs when you can take the haskellator
05:41:51 <pjdelport> Does a heskallator keep you at the bottom, until you desire to be at the top, and then teleport you?
05:42:35 <pantsman> unfortunately it's non-total you may find yourself back at the bottom
05:42:39 <Fernandos> he said it's for elitists who talk about monads, not knowing it's not that useful. I don't agree with him, because it's a rude generalization.. however shouldn't try to argue with a prof, if one cares about the grades..
05:43:28 <filoteo> you never know what profs do behind clojed doors.
05:43:29 <vohof> hello, is anyone here.
05:43:31 <Fernandos> he's teaching logic and is a clojure fanatic
05:43:40 <Fernandos> :D
05:44:15 <Sorella> Fernandos: with MiniKaren-in-clojure-aka-core.logic?
05:44:21 <Sorella> Oh, Monads are definitely not that useful.
05:45:55 <vanila> Sorella, minikanren is based on a monad internally
05:46:28 <pjdelport> Fernandos: That's a pretty self-defeating opinion for a professor to have.
05:47:03 <pjdelport> Haskellers certainly don't speak about monads all the time; if anything, they're the ones trying to explain "It's not all about monads!"
05:47:25 <filoteo> Maybe monads arent meant to be too useful, they delegate schores, this way they can remain pure.
05:47:51 <pjdelport> Monads are one of the less interesting bits of Haskell; they just have the most memorable name, somehow.
05:48:10 <pjdelport> So that's all everyone else goes on about.
05:48:16 <bernalex> monads are super important because of monadic IO being a very real and very important breakthrough. let's not go overboard understating their influence.
05:48:42 <vanila> they're also useful to structure pure computations and in formal proofs about programs
05:48:51 <pjdelport> filoteo: Monads in general have nothing to do with purity, as such. *IO* is about having a pure representation of effects, but that's specific only to IO, not to monads.
05:49:01 <geekosaur> they are widely used but there is less here than meets the eye :)
05:49:05 <mr-> filoteo: did they go from String to ByteString?
05:49:09 <gigabytes> hi
05:49:12 <pantsman> look at you, all talking about monads! His prof was right!
05:49:22 <Fernandos> Sorella: We were talking about a book called problem frames by michael jackson, thought it might be based on category theory.. apparently it isn't according to the prof, then he went on bashing haskell in general and stating CT as useless and abstract bs
05:49:29 <_rai> hi. just started learning haskell and trying to understand this function. does there exist a way to trace values at certain points easily, e.g. to check what is bound to let (h,t) at each point https://gist.github.com/anonymous/cf2fe70a3480e06cc569
05:49:33 <hughfdjackson> eh, there's a lot of times you want to carry implicit context without having to break purity - monads seem to be doing a nice job of that :)
05:49:46 * hughfdjackson butts out so there's less people talking about monads
05:49:54 <Sorella> vanila: oh, sure, lots of things can form a monad. (I'm not familiar with MiniKanren internals), but they're really not the most useful thing ever devised in computation, as some monad tutorials would make it to be.
05:49:59 <pjdelport> _rai: Do you know the trace function from Debug.Trace?
05:50:22 <Sorella> They're useful ofc, but so are applicatives, lists and zippers.
05:50:27 <mr-> pjdelport: I have the impression that the syntactical sugar that monads enjoy make them somewhat magical
05:50:42 <_rai> pjdelport: yes, i actually just found that. how might i apply it here without radically changing the structure of the function?
05:50:53 <geekosaur> mr-, nope
05:51:01 <pjdelport> mr-: Do syntax? Once you learn how it desugars, it doesn't seem very magical. :)
05:51:18 <pjdelport> _rai: Yes: you can insert trace basically anywhere.
05:51:22 <mr-> pjdelport: I know, but it takes some time to realize.
05:51:25 <pjdelport> :t trace
05:51:27 <lambdabot> Not in scope: ‚Äòtrace‚Äô
05:51:28 <mr-> geekosaur: ok :-)
05:51:28 <asfp> > let r = readMaybe :: String -> Maybe String in r "a"
05:51:30 <lambdabot>  Not in scope: ‚ÄòreadMaybe‚Äô
05:51:48 <gigabytes> I have a use case for something similar to list comprehension, I mean [something x y | x <- listOfX, y <- listOfY]. The problem is that I don't have a fixed number of variables. Instead I have a list of lists [[a]], and I have to apply a function [a] -> b with a list of all the possible combinations of elements choosen from different lists, in order.
05:51:49 <Sorella> Fernandos: category theory is definitely too abstract, but that's not necessarily a bad thing :P
05:52:00 <asfp> > read "a" :: String
05:52:03 <gigabytes> I don't know if I've explained myself well
05:52:03 <mr-> geekosaur: how about syntactical sugar and IO ?
05:52:03 <pjdelport> _rai: It acts like the identity function, but just happens to print a message when its argument gets evaluated.
05:52:19 <gigabytes> I think the list monad could help but I can't figure out how
05:52:23 <asfp> why can't read read a string?
05:52:28 <_rai> alright so i can wrap an expression with trace
05:52:30 <geekosaur> mr-: IO is weird, but the same mechanical (even banal) transformation does the same thing with it as with anything else
05:52:33 <pjdelport> _rai: traceShow and traceStack might also be interesting, depending.
05:52:38 <pjdelport> _rai: Yep, exactly.
05:52:59 <asfp> > let r = Text.Read.readMaybe :: String -> Maybe String in r "a"
05:53:04 <lambdabot>  Not in scope: ‚ÄòText.Read.readMaybe‚Äô
05:53:06 <gigabytes> it's like list comprehension with variable number of x y z.. with lists of possibilities for each variable taken from a list of lists
05:53:31 <Cale> gigabytes: sequence or mapM perhaps?
05:53:40 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
05:53:42 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
05:54:00 <geekosaur> this sounds like the list monad, somehow
05:54:24 <_rai> pjdelport: trace seems to change the type. Expected type: String Actual type: [[a]]
05:54:29 <geekosaur> so yes, sequence probably involved somewhere, but need more detail
05:54:31 <gigabytes> Cale: hm.. I'm not used to think about the list monad, that's the problem. I'll try to visualize what sequence really "mean" in this monad
05:54:31 <shanthakumar> Hi all, I'm trying to write a point-free function. Could someone help me get rid of that x
05:54:31 <shanthakumar> f = flip ( zipWith (\x -> (,) x . length . filter (<x) ) ) =<< inits
05:54:37 <pjdelport> _rai: Did you give trace a message?
05:55:09 <nkar> is there a way to write 'insert if not exists' in esqueleto?
05:55:11 <Cale> gigabytes: "running" a list means picking an element from it in all possible ways
05:55:26 <geekosaur> asfp: because "a" is not a string, it's a character. "\"a\"" is a string
05:55:26 <gigabytes> ok
05:55:27 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
05:55:32 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
05:55:43 <pjdelport> _rai: If you have an expression (foo), you'll want to say: trace "Some message" (foo)
05:55:45 <gigabytes> Cale: yes, I got it with the do notation in that way, pretty clear.
05:55:52 <geekosaur> read does not read arbitrary stuff, it reads something similar but not quite the same as Haskell syntax
05:56:25 <geekosaur> > read "Just 5" :: Maybe Int
05:56:28 <lambdabot>  Just 5
05:56:45 <geekosaur> how do you make that work with the way you want strings to work?
05:57:00 <pjdelport> gigabytes: You can read "sequence [[1,2,3],[4,5],[6,7,8]]" as mean "A list of three elements, where the first element is chosen from [1,2,3], the second element is chosen from [4,5], etc."
05:57:05 <pjdelport> as meaning, even
05:57:44 <gigabytes> okey I think I got it! The point I was missing is that here the "actions" are simply lists!
05:57:48 <pjdelport> So the outer list is the actual list in sequence's type, while the inner lists are all "choice" values.
05:59:11 <_rai> pjdelport: yep, added it now. the output is confusing, trying to make sense of it
05:59:19 <gigabytes> yes now it's clear
05:59:21 <gigabytes> thank you!
06:00:14 <pjdelport> gigabytes: The same thing applies when you see things like (+) <$> [1,2,3] <*> [4,5,6]
06:00:54 <gigabytes> pjdelport: hm, applicative style seems clearer
06:00:56 <pjdelport> Each list value that gets treated as a functor or monad gets interpreted as a list of "choices" for the position it appears in.
06:02:39 <pjdelport> You can squint, and think of it as a "fuzzy" value, that has all its contained values at once.
06:02:57 <Total_1mmersion> Any idea how to fix a build error for process-1.1.0.2? System/Process/Internals.hs:283:30: Not in scope: ‚ÄòunsafePerformIO‚Äô
06:03:05 <pjdelport> (That's just an intuition, though.)
06:09:18 <_rai> getting No instance for (Show a) arising from a use of `traceShow'; traceShow (x,xs) $ splitOn f xs
06:09:36 <Twey> _rai: What's the type of xs?
06:09:56 <_rai> [Char] i think
06:11:16 <geekosaur> Total_1mmersion, it needs to import System.IO.Unsafe. possibly it was relying on an old version of the FFI?
06:12:18 <Total_1mmersion> It's possible. I simply relaxed the dependency on process to 1.* and now it compiles.
06:16:20 * hackagebot module-management 0.20.2 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.20.2 (DavidFox)
06:20:11 <shanthakumar> @pl f = flip ( zipWith (\x -> (,) x . length . filter (<x) ) ) =<< inits
06:20:12 <lambdabot> f = flip (zipWith (liftM2 (.) (,) ((length .) . filter . flip (<)))) =<< inits
06:21:20 * hackagebot module-management 0.20.2.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.20.2.1 (DavidFox)
06:25:08 <kuribas> @dice 3d6/2
06:25:08 <lambdabot> kuribas: (3+4+5) / 2 => 6
06:26:52 <kuribas> @unlambda ```sski
06:26:53 <lambdabot>  Done.
06:28:41 <kuribas> @hello world
06:28:41 <lambdabot> Maybe you meant: tell help
06:31:21 * hackagebot arith-encode 1.0.0 - A practical arithmetic encoding (aka Godel numbering) library.  http://hackage.haskell.org/package/arith-encode-1.0.0 (emc2)
06:34:55 <albeit> You can read substrings of a ByteString in constant time and memory, but is it possible write substrings in constant time and memory? As in, replace the 3,4,5th characters of a Strict ByteString with "XYZ"?
06:39:54 <Total_1mmersion> How do you tell cabal to compile with -O2? I've tried --PROG-options and --enable-optimizations
06:40:50 <shanthakumar> @pl f xs = zipWith (\x ys -> (x, length $ filter (<x) ys) ) xs (inits xs)
06:40:50 <lambdabot> f = ap (zipWith (liftM2 (.) (,) ((length .) . filter . flip (<)))) inits
06:41:43 <kuribas> What's a good package for writing irc bots?  Or is it better to roll my own?
06:42:10 <hexagoxel> Total_1mmersion: ghc-options: -O2
06:42:34 <exio4> kuribas: I can't say about other libraries, but simpleirc was good enough for my tests
06:42:56 <Total_1mmersion> hexagoxel, awesome, thanks!
06:45:18 <hexagoxel> kuribas: i tried a few, and also stuck with simpleirc. had to write a ping thread for some reason, but easy enough otherwise.
06:46:21 * hackagebot hydrogen-prelude 0.7 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.7 (JulianFleischer)
06:47:07 <dcoutts_> Total_1mmersion: you can do it as the person building the package (as opposed to the package author) by configuring with -O2
06:47:18 <dcoutts_> Total_1mmersion: e.g. cabal install ./ -O2
06:47:34 <dcoutts_> Total_1mmersion: hexagoxel's suggestion is appropriate for the package author, not the package builder.
06:47:51 <Total_1mmersion> dcoutts_, I didn't know that, thanks
06:47:56 <dcoutts_> Total_1mmersion: -O2 is the same as --enable-optimization=2
06:48:03 <dcoutts_> see the --help text
06:48:15 <dcoutts_>  -O --enable-optimization[=n]      Build with optimization (n is 0--2, default is 1)
06:51:22 * hackagebot hydrogen-util 0.7 - Hydrogen Tools  http://hackage.haskell.org/package/hydrogen-util-0.7 (JulianFleischer)
06:56:22 * hackagebot hydrogen-syntax 0.7 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.7 (JulianFleischer)
07:03:53 <zmbmartin> Can you add a type constraint to a func for a data named filed. Like this function only works with data that has an id field?
07:04:12 <kuribas> exio4, hexagoxel: right, I'll take a look at it then :-)
07:11:23 * hackagebot hydrogen-prelude 0.7.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.7.1 (JulianFleischer)
07:11:24 * hackagebot hydrogen-util 0.7.1 - Hydrogen Tools  http://hackage.haskell.org/package/hydrogen-util-0.7.1 (JulianFleischer)
07:13:43 <kuribas> hexagoxel: what was that about the ping thread?
07:15:05 <kuribas> hexagoxel: something I should be aware of?
07:16:04 <hexagoxel> kuribas: IrcConfig contains cPingTimeoutInterval, which i set to 20secs. in my tests, when there was no traffic at all, that timeout struck the bot, even when the connection was fine theoretically
07:16:23 * hackagebot helics 0.4.0 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.4.0 (HirotomoMoriwaki)
07:16:25 * hackagebot hydrogen-syntax 0.7.1 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.7.1 (JulianFleischer)
07:16:27 * hackagebot helics-wai 0.4.0 - New RelicÆ agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.4.0 (HirotomoMoriwaki)
07:16:35 <hexagoxel> kuribas: so i added a thread that just pings the server every 10 seconds
07:19:16 <kuribas> hm, I see...
07:21:03 <nkar> how do I change the indentation offset in haskell-mode?
07:24:34 <kuribas> nkar: which indentation mode?
07:26:08 <nkar> I use the default
07:26:33 <nkar> kuribas: is there a way to configure it to use the project's indentation?
07:27:04 <kuribas> If you use haskell-indentation, it is configurable.
07:27:55 <kuribas> nkar: you can do m-x customize-group haskell-indentation
07:28:19 <kuribas> There are several indentation variables.
07:29:02 <kuribas> nkar: The easiest would be to try them out.
07:29:11 <kuribas> Change them and see what effect it gives.
07:33:21 <nkar> kuribas: thanks, I can do that for now.  but can't it be configured to pick what the project uses?
07:35:05 <albeit> Is there some way to kill all child threads spawned by a main thread with forkIO, without keeping track of them?
07:35:49 <kuribas> nkar: You mean like detecting the settings based on the input file?
07:35:58 <nkar> yes
07:36:11 <nkar> kuribas: ^
07:36:15 <kuribas> nkar: The only thing you could do is set buffer variables.
07:36:24 * hackagebot helics 0.4.1 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.4.1 (HirotomoMoriwaki)
07:36:33 <kuribas> Automatic detection is not possible.
07:37:34 <kuribas> For example using file variables:
07:39:19 <kuribas> -- -*- haskell-indentation-indent-leftmost: 2; haskell-indentation-layout-offset: 4; -*-
07:40:38 <kuribas> Or otherwise:
07:40:44 <kuribas> {- Local Variables: -}
07:41:01 <nkar> kuribas: can I put that in the project's root somewhere, so all the files use it?
07:41:06 <kuribas> {- haskell-indentation-indent-leftmost: 2 -}
07:41:13 <kuribas> {- End: -}
07:41:17 <kuribas> nkar: no
07:41:32 <kuribas> It works only per file.
07:41:45 <nkar> unfortunate
07:42:03 <nkar> thanks for the tips, though!
07:42:10 <kuribas> nkar: you can setup a coding-style document for contributors.
07:42:26 <kuribas> And show the emacs variables that you use.
07:43:36 <kuribas> You also may find chrisdone's mode useful: https://github.com/chrisdone/structured-haskell-mode
07:44:34 <kuribas> nkar: You could do that with elisp though...
07:45:07 <kuribas> nkar: Detect indentation variables in the document root.
07:45:58 <kuribas> But it would not be portable, so file local variables are a better way.
07:46:27 <nkar> re detection: any pointers?  I don't know much elisp.
07:47:32 <kuribas> nkar: That would be not trivial...
07:48:18 <kuribas> nkar: Add a hook to haskell-mode-hook, that finds the document root, and then looks for a file containing the definitions.
07:50:25 <kuribas> But everyone using that hook would need to add it to their .emacs configuration, that kind of beats the purpose.
07:50:39 <predator217> nkar: you should check out https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html
07:50:49 <predator217> never used them myself though
07:51:10 <kuribas> predator217: oh nice, I didn't knew they existed!
07:51:40 <kuribas> nkar: forget what I said then :-)
07:53:05 <nkar> predator217: will do, thank you.
07:56:01 <eraare> A
07:57:24 <a1_> How do you write a Haskell program that takes in binary values ?
07:58:05 <tdammers> a1_: what do you mean? read binary data from stdin?
07:58:13 <a1_> Yeah
07:58:19 <tdammers> a1_: in that case, probably Data.ByteString.IO
07:58:44 <tdammers> that module provides most of the Prelude IO functions for bytestrings
07:59:04 <tdammers> alternatively, you'd use something like conduits, although I haven't looked into those myself
08:01:05 <a1_> oh cool! Thanks! Also I'm pretty new to Haskell. Would you be able to show me how to write a Haskell program that takes in an arbitrary binary value and outputs a decimal number?
08:02:13 <lifter> a1_: Haskell is a general purpose language and plenty of libraries exist for it, so you can do most things with ti
08:03:51 <pranz> a1_: If you want to learn haskell I suggest following a short introduction to haskell
08:03:56 <pranz> and look at some exemaple programs
08:08:52 <pjdelport> > let integerFromBytes = BS.foldl' (\n w -> 0x100*n + fromIntegral w) 0 in integerFromBytes (BSC.pack "fnord")
08:08:54 <lambdabot>  439939461732
08:09:20 <pjdelport> a1_: There's one way to write such a function.
08:09:55 <pjdelport> a1_: That just treats the bytes as a base-256 numeral.
08:10:27 <pjdelport> a1_: If you're new to Haskell, the foldl' function might be unfamiliar, but i'd be happy to try and explain it. :)
08:10:51 <a1_> yeah that'd be awesome! :)
08:16:09 <pjdelport> a1_: There are actually a number of related "fold" functions, like that.
08:16:11 <pjdelport> :t foldr
08:16:12 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:16:16 <pjdelport> :t foldl'
08:16:17 <lambdabot> (b -> a -> b) -> b -> [a] -> b
08:16:27 * hackagebot SConfig 0.2.0.0 - A simple config library  http://hackage.haskell.org/package/SConfig-0.2.0.0 (fgaz)
08:16:29 <pjdelport> Those are the generic ones, for plain Haskell lists.
08:17:20 <pjdelport> (Note that there is both foldl and foldl': the latter is stricter in its arguments, and the reasons for it are a bit technical, but probably not important while you're still learning: you can think of them as being the same thing.)
08:20:14 <pjdelport> What these folds do is take a binary function like (a -> b -> b), and an initial value b, and then accumulate all the values in a list with it.
08:20:54 <pjdelport> foldr accumulates right-associative, while foldl' accumulates left-associative; it's easiest to show with examples:
08:21:19 <pjdelport> > foldr (+) z [a,b,c,d,e] :: Expr
08:21:21 <lambdabot>  a + (b + (c + (d + (e + z))))
08:21:26 <pjdelport> > foldl' (+) z [a,b,c,d,e] :: Expr
08:21:28 <lambdabot>  z + a + b + c + d + e
08:21:54 <ReinH> :t foldl
08:21:55 <lambdabot> (b -> a -> b) -> b -> [a] -> b
08:21:58 <pjdelport> (Note that the second one is identical to having the parens all toward the left: they're just omitted because that's the default for (+).)
08:22:07 <ReinH> pjdelport:  they use different folding functions
08:22:28 <pjdelport> Right, that too.
08:23:00 <pjdelport> The function passed to foldr has the accumulator argument to the right, while the one passed to foldl' has it on the left, as you can see from the type signatures.
08:23:30 <pjdelport> Now, the ByteString folding function is very similar, but specialized for ByteStrings:
08:23:30 <pjdelport> :t BS.foldl'
08:23:32 <lambdabot> (a -> Word8 -> a) -> a -> BSC.ByteString -> a
08:24:33 <pjdelport> Here you can see that the accumulator is generic (the 'a' type), but that the function that you pass in must always accept a Word8 value as its second argument.
08:25:01 <pjdelport> And foldl' will just call it for each character in the ByteString, updating the accumulator as it goes along.
08:25:16 <pjdelport> (starting with the initial accumulator that you give)
08:25:35 <pjdelport> So back to that function above: integerFromBytes = BS.foldl' (\n w -> 0x100*n + fromIntegral w) 0
08:26:19 <pjdelport> That inner lambda takes two arguments: n is the number accumulated so far, and w is the Word8 base-256 "digit".
08:27:16 <pjdelport> So to add each digit to the number accumulated so far, you multiply the number so far with 256 (or 0x100 as i prefer to write it above), and then add the digit's value.
08:28:05 <pjdelport> and the "fromIntegral" is just there to convert the type from Word8 to whatever numeric type you are accumulating to (which has to be larger than Word8, to be meaningful).
08:33:00 <albeit> If I have three maybes, and all are Nothing, I want to return Nothing, otherwise I want to return Just a function of the maybes. How can I do that?
08:33:45 <cdk> albeit: how will your function work if 1/3 of the Maybe are Nothing?
08:34:16 <albeit> cdk: They are turned into mempty, and mappended to the rest
08:34:38 <albeit> If all are nothing, instead of having a final mempty, I want a Nothing
08:34:56 <Fuuzetsu> what should I use on 7.6.3 instead of tryReadMVar?
08:34:58 <albeit> Because as far as I can tell it's not possible to check for mempty
08:38:15 <pjdelport> albeit: Is your function of one value, or of three?
08:38:34 <cdk> @define foo _ Nothing Nothing Nothing = Nothing; foo f x y z -> foldMap (maybe mempty f) [x, y, z]
08:38:34 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:38:50 <geekosaur> o.O
08:39:04 <cdk> @define foo _ Nothing Nothing Nothing = Nothing; foo f x y z = foldMap (maybe mempty f) [x, y, z]
08:39:07 <lambdabot>  Defined.
08:39:33 <cdk> albeit: does that work?
08:39:51 <lzm> what does the ! in !Text mean? (from https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json )
08:40:19 <geekosaur> strict
08:40:39 <pjdelport> lzm: Strictness annotation: it means the field is declared strictly-evaluated.
08:44:06 <UtuEI> Why this code doesn't work ? http://paste.kde.org/pgrjhe3se/qhow17
08:44:20 <UtuEI> the problem is the printf statement
08:44:26 <UtuEI> What's wrong with it?
08:44:39 <UtuEI> Why I can't printf multiple arguments like that
08:45:52 <albeit> pjdelport: Of the three
08:46:07 <albeit> cdk: Yes... I'm just using "all isNothing" right now, but was hoping for a better solution
08:46:17 <geekosaur> UtuEI, what's the error message?
08:46:19 <pjdelport> UtuEI: Did you mean to say "(a + b + c) a b c" ?
08:46:20 <k00mi> UtuEI: that is parsed as (printf " %d\n %d\n %d\n %d\n " a) + b + (c a b c)
08:46:33 <k00mi> UtuEI: the commented out version is correct
08:46:42 <pjdelport> albeit: liftA3 f a b c ?
08:46:49 <UtuEI> printf " %d\n %d\n %d\n %d\n " (a + b + c) a b c doesn't work either
08:46:56 <pjdelport> (or f <$> a <*> b <*> c if you prefer)
08:47:17 <albeit> pjdelport: But wouldn't that make it Nothing if any of a b c were Nothing?
08:47:29 <geekosaur> also you shouldn't really use printf if you can help it, it's a horrid hack originally intended to show off how to abuse the type system to do varargs
08:47:33 <pjdelport> Right, but what else can you do if f expects three values?
08:47:35 <UtuEI> error code http://paste.kde.org/psr8ko47a/fwyzxx
08:47:53 <UtuEI> geekosaur: ^
08:48:17 <albeit> pjdelport: It can deal with Nothings, but if it gets three Nothings it will output mempty, and I can't check for mempty afterwards like I can check for Nothing
08:48:31 <pjdelport> albeit: With mempty / mappend, are you referring to the Maybe values, or the things inside them?
08:48:51 <albeit> pjdelport: Actually different monad, the ByteString.Builder
08:48:52 <geekosaur> UtuEI, so the problem looks like it would normally infer a type that you didn't specify, but printf's type hackery interferes with that
08:49:07 <geekosaur> give an explicit type somewhere in there or avoid printf
08:49:51 <pjdelport> albeit: Can you describe the context a bit more? What is making that distinction for?
08:50:09 <UtuEI> This works: printf "a + b + c = %d\na = %d\nb = %d\nc = %d\n " ((a + b + c)::Int) (a::Int) (b::Int)
08:50:13 <UtuEI> type inference my ass
08:50:20 <geekosaur> printf breaks type inference
08:50:28 <geekosaur> as I said, printf is not really intended for normal use
08:50:43 <geekosaur> beginners think it looks familiar and reach for it immediately, but it should be avoided
08:51:14 <pjdelport> UtuEI: Haskell will infer types, but it needs somewhere to start from. In that example, they're completely ambiguous.
08:51:19 <UtuEI> Actually doing this is enough: printf "a + b + c = %d\na = %d\nb = %d\nc = %d\n " ((a + b + c)::Int) a b c
08:51:22 <UtuEI> the problem is arg0
08:51:31 <geekosaur> any of them will do
08:51:33 <UtuEI> yeah, printf sucks
08:51:41 <UtuEI> I know it from C
08:51:43 <geekosaur> given any one of them it can infer the rest
08:51:45 <pjdelport> UtuEI: If you gave concrete types for fac, ack, fib, or a, b, and c, Haskell would infer the rest of it.
08:51:50 <UtuEI> it has bitten me countless times
08:51:57 <geekosaur> but defaulting is broken in the presence of printf because it does really evil things
08:51:59 <UtuEI> why it can't infer they are ints?
08:52:13 <albeit> Actually, might have a solution... if I call toLazyByteString on a Builder.mempty, is it practically free?
08:52:16 <UtuEI> pjdelport: I call the functions with Int params
08:52:17 <geekosaur> that PrintfType can't be defaulted through
08:52:18 <pjdelport> UtuEI: Why would it? Nothing says they have to be Ints; they could also be Integer, Double, etc.
08:52:31 <UtuEI> pjdelport: because I call them with Int
08:52:40 <geekosaur> defaulting only works with standard Haskell Report typeclasses, PrintfType is not one of them
08:52:49 <pjdelport> UtuEI: You actually don't: integer literals are overloaded in Haskell. They're not Int unless you say they are.
08:52:56 <UtuEI> :(
08:52:59 <pjdelport> Consider:
08:52:59 <pjdelport> > 5 :: Int
08:53:01 <lambdabot>  5
08:53:03 <pjdelport> > 5 :: Double
08:53:05 <lambdabot>  5.0
08:53:05 <pjdelport> 5 :: Rational
08:53:08 <geekosaur> more to the point
08:53:11 <geekosaur> :t 5
08:53:12 <lambdabot> Num a => a
08:53:16 <pjdelport> > 5 :: Rational
08:53:17 <pjdelport> etc.
08:53:18 <lambdabot>  5 % 1
08:53:49 <t7> is 5 translated to (fromInteger 5) or something
08:53:56 <geekosaur> yes
08:54:00 <pjdelport> > (2 + 3) / 4
08:54:02 <lambdabot>  1.25
08:54:05 <pjdelport> > (2 + 3) / 4 :: Rational
08:54:07 <lambdabot>  5 % 4
08:54:54 <pjdelport> UtuEI: By specifying the concrete type, you determine which Num instance gets used, and how it gets treated. printf is no exception: it needs to know a concrete type before it can know how to convert and print it.
08:54:57 <geekosaur> this is all specified in the language report
08:55:49 <pjdelport> UtuEI: So it's powerful, and flexible: you can declare them to be Int, like above, but you can also declare them to be Integer (like Int, but arbitrary-precision), or Double, or Rational, or any other concrete numeric type.
08:55:59 <geekosaur> again: under normal circumstances defaulting kicks in, and since Integer will work it gets used. bu the PrintfType hackery defeats it
08:56:07 <geekosaur> because printf is evil
08:58:03 <UtuEI> I always get to discover the nasty parts of things
08:58:12 <UtuEI> I have a strange personality
08:58:30 <geekosaur> join the club
08:58:38 <UtuEI> :-)
08:58:48 <geekosaur> I have been threatening to get a "human fuzzer" tshirt for myself for about 25 years now
08:58:57 <dispersed> UtuEI: you are probably a monad.
08:59:18 <UtuEI> If only I understood what that trully is (me: haskell noob)
09:00:15 <UtuEI> sounds like abstract math
09:00:55 <UtuEI> a monad is a a functor ?
09:01:00 <UtuEI> like in C++?
09:01:27 <pjdelport> albeit: I'm not sure.
09:01:34 <UtuEI> i.e. a class with operator() defined
09:01:35 <pjdelport> UtuEI: It's a Functor as in Haskell, but not as in C++ :)
09:01:42 <pjdelport> No, C++'s usage is unrelated.
09:01:45 <UtuEI> I guess much more powerful than that
09:02:34 <UtuEI> The math in that wiki page makes my eyes hurt
09:02:36 <silver> meaning of these two concepts are not directly related
09:02:39 <pjdelport> UtuEI: You can think of Functor (and Monad) as being an abstraction for values with some kind of context or structure to them.
09:03:22 <pjdelport> You might have already encountered IO actions: that's a prominent example, but there are many others.
09:03:53 <pjdelport> albeit: Where do the Maybe's come from, exactly?
09:05:04 <albeit> pjdelport: An external source
09:06:56 <edyu> does anyone know how to make a function type an instance of a typeclass? for example, I keep on getting errors when I do instance Calculable (Double -> Double -> Double) where ...
09:07:36 <ccshan> Does the error say "Use -XFlexibleInstances if you want to disable this"?
09:07:43 <a1_> How do you write a haskell function with if/elseif/else conditions?
09:08:01 <edyu> @ccshan yes it does
09:08:01 <lambdabot> Unknown command, try @list
09:08:05 <johnw> edyu: by default you cannot create type class instances for "specific" types, but only for fully general type variables
09:08:10 <ccshan> @edyu: Use -XFlexibleInstances
09:08:10 <lambdabot> Unknown command, try @list
09:08:16 <Cale> a1_: Well, there's guards
09:08:16 <johnw> i.e., Calculable (a -> a -> a) would work
09:09:13 <edyu> @ccshan: I get more errors if I use FlexibleInstances
09:09:14 <lambdabot> Unknown command, try @list
09:09:22 <pjdelport> a1_: Depends what you want to do exactly, but perhaps cond?
09:09:30 <pjdelport> a1_: Err, case, not cond.
09:09:35 <ccshan> @edyu: What do those errors say?
09:09:35 <lambdabot> Unknown command, try @list
09:09:39 <edyu> @johnw: I couldn't get a -> a -> a work
09:09:39 <lambdabot> Unknown command, try @list
09:09:48 <johnw> edyu: what was the error?
09:09:52 <edyu> 1 sec
09:10:18 <NemesisD> i've noticed that cabal sandboxes will prefer installed versions when new dependencies get added that require newer versions. is there a safe way to have cabal conservatively bump dependencies where necessary or do i need to blow away my sandbox
09:10:37 <a1_> I'm tyring to write a program that evaluates mods, and based on the output, changes a state
09:10:40 <NemesisD> i'm hesitant to blow away my sandbox on my current project because the dependencies take quite a while to install
09:11:15 <edyu>  Illegal instance declaration for ‚ÄòCalculable (a -> a -> a)‚Äô
09:11:15 <edyu>       (All instance types must be of the form (T a1 ... an)
09:11:15 <edyu>        where a1 ... an are *distinct type variables*,
09:11:17 <edyu>        and each type variable appears at most once in the instance head.
09:11:19 <edyu>        Use FlexibleInstances if you want to disable this.)
09:11:21 <edyu>     In the instance declaration for ‚ÄòCalculable (a -> a -> a)‚Äô
09:11:29 * hackagebot DAV 1.0.3 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.3 (ClintAdams)
09:11:45 <edyu> @johnw: @cchan: that's the error I'm getting
09:11:45 <lambdabot> Unknown command, try @list
09:11:54 <ccshan> @edyu What errors do you get if you use FlexibleInstances ?
09:11:55 <lambdabot> Unknown command, try @list
09:12:42 <pjdelport> albeit: Does the following do what you want?
09:12:42 <pjdelport> foo f Nothing Nothing Nothing = Nothing
09:12:42 <pjdelport> foo f x y z = Just $ f (opt x) (opt y) (opt z) where opt = fromMaybe mempty
09:13:09 <edyu> Couldn't match expected type ‚ÄòDouble‚Äô with actual type ‚Äòa‚Äô
09:13:09 <edyu>       ‚Äòa‚Äô is a rigid type variable bound by
09:13:13 <pjdelport> (It's still a bit of a strange thing to do, but that's how far i understand your request so far.)
09:14:13 <nyuszika7h> edyu, ccshan: you don't need to prefix nicks with "@", that's just annoying here because the bot will say "Unknown command"
09:14:24 <nyuszika7h> it has no significance on IRC
09:14:24 <albeit> pjdelport: Yes, that is fine. Its effectively what I'm doing now, but I guess thats the best way
09:14:27 <albeit> Thanks
09:14:32 <edyu> got it nyuszika7h
09:14:32 <ccshan> nyuszika7h Thanks!
09:14:50 <pjdelport> albeit: There might be a better way to acheive whatever you want to achieve in context, though!
09:14:59 <pjdelport> Are you sure you want a maybe out of it?
09:15:17 <ccshan> edyu, Looks like your instance definition has a type error. Maybe it's assuming that something is a Double when it actually could be anything.
09:15:45 <pjdelport> albeit: What does this get used for?
09:15:56 <pjdelport> albeit: It definitely feels like something that should have a simpler solution.
09:16:18 <edyu> cchan: I really only want it to be Double, so can I do Double -> Double -> Double?
09:16:28 <edyu> instead of a -> a -> a?
09:16:46 <ccshan> edyu: Yes, with FlexibleInstances
09:17:47 <edyu> cchan: johnw: basically what I wanted to do is to have a function that can take another function of various arity
09:18:03 <edyu> and that function of various arity i created a typeclass of Calculable
09:18:38 <edyu> so I'd like something like process :: [Double] -> Calculable -> Double
09:18:42 <seanparsons> Anyone got any experience with Warp 3.0? I'm staring at the Response data type, being a bit puzzled as to how I return a "IO Response" instead of just a bare Response instance.
09:19:19 <lnostdal> hello, what's the "best" and most up to date book on haskell at the moment?  .. i come from a lisp, clojure, sql and javascript background
09:19:36 <edyu> i still like Real World Haskell lnostdal:
09:20:00 <Ankhers> LYAH is good too.
09:20:08 <Ankhers> (Learn You A Haskell)
09:20:20 <edyu> i come from the clojure too and both LYAH and RWH are great books to read together :)
09:20:28 <Ankhers> @where RWH
09:20:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:20:33 <Ankhers> @where LYAH
09:20:33 <lambdabot> http://www.learnyouahaskell.com/
09:20:56 <ccshan> edyu, maybe you want: class Calculable a where process :: [Double] -> a -> Double; instance Calculable Double where process [] c = c; instance Calculable a => Calculable (Double -> a) where process (x:xs) c = process xs (c x)
09:21:52 <josephle> while the examples of RWH are old, the concepts are still good :)
09:21:52 <lnostdal> ok, thanks guys
09:23:01 <edyu> ccshan: let me try but it looks similar to what I have, let me write it out and test it so I know for sure, thank you
09:27:01 <edyu> ccshan: let me explain better, I have a process function which is processUnary :: [Double] -> (Double -> Double) -> Double, processBinary :: [Double] -> (Double -> Double -> Double) -> Double and I want to unify them so I can use the same process function to take both (Double -> Double) and (Double -> Double -> Double)
09:27:48 <edyu> so I thought the best way to do so is to create a TypeClass of Calculable and have both (Double -> Double) and (Double -> Double -> Double) instances of Calculable
09:28:15 <edyu> but I don't know what's the best way to make functions instances of TypeClasses, thus I'm stuck. but maybe I'm doing it wrong
09:28:48 <edyu> I assumed that since functions are values as well, that I could make them instances of TypeClasses
09:30:22 <gigabytes> edyu: instance YourClass (Double -> Double) where ....
09:30:37 <gigabytes> edyu: instance YourClass (Double -> Double -> Double) where
09:41:31 * hackagebot boomerang 1.4.5 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.5 (JeremyShaw)
09:49:03 <harlanhaskins> Anyone here have much experience with criterion?
09:51:26 <johnw> harlanhaskins: I've used it; what's your question?
09:51:35 <a1_> how do you return in haskell
09:51:41 <johnw> a1_: "return"?
09:52:06 <a1_> like return a bool or something
09:52:20 <johnw> the value of any function is the value of its last expression
09:52:27 <johnw> foo = True
09:56:26 <dv-> there's no return like in C
09:56:31 <merijn> johnw: "last expression"? :)
09:56:46 <harlanhaskins> johnw: I'm having trouble doing a few things.
09:57:02 <harlanhaskins> johnw: My benchmark is reading 1,000,000 credit cards from a file and validating them.
09:57:12 <harlanhaskins> I'd like to benchmark just the validation, and not the file IO.
09:57:35 <harlanhaskins> But I can't get any of it running.
09:57:49 <harlanhaskins> Or rather, I can't get a benchmark running
09:58:47 <nshepperd> only do-blocks have a "last" expression
09:58:48 <Sorella> a1_: a function in Haskell is just a name for a mathematical expression with some variable parts. So `return` doesn't make sense. If you have `f x = x + 2` and then do `f 3`, that's the same as `3 + 2`. Literally. You just replace the `f 3` by the whole body of the function.
09:59:08 <josephle> nshepperd: and do-blocks desugar into one expression anyway :)
10:00:18 <harlanhaskins> johnw: And of course, the second I ask for help, I figure something else.
10:00:32 <harlanhaskins> s/else/out/
10:01:32 * hackagebot yi-language 0.1.0.4 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.4 (MateuszKowalczyk)
10:01:34 * hackagebot web-routes 0.27.7 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.7 (JeremyShaw)
10:01:47 <Denommus> uh, pontarius-xmpp uses Data.Text.Internal.Text for username and password, how do I create such variables?
10:01:53 <Sorella> a1_: it's also interesting to note that Haskell implementations don't have a call stack. They work by running down the graph formed by your source code, and replacing nodes like `f 3` by the nodes of the definition of `f` at runtime. So, in a sense, GHC works more or less like you would solve any mathematical expression :)
10:01:57 <PDani> hi
10:02:25 <johnw> harlanhaskins: :)
10:02:28 <pjdelport> harlanhaskins: The most obvious way would be to read the credit card numbers from the file outside of Criterion's defaultMain.
10:02:50 <josephle> Sorella: I'm pretty sure LLVM and Cmm have call stacks...although I wish the world of computers executed code the way you described
10:03:31 <Sorella> josephle: doesn't the Receron work something like that?
10:03:39 <pjdelport> Sorella: GHC does actually have an evaluation stack, but it's not like the call stack of something like C.
10:03:52 <edyu> gigabytes: thank you
10:04:13 <josephle> Sorella: the Reduceron is an experimental computer architecture which I wish was more than just experimental :)
10:04:19 <harlanhaskins> pjdelport: Yeah, I've got a function cards = readFile "cards.txt", and then I just catMaybes . (map readMaybes) into an [Integer] from there.
10:04:26 <harlanhaskins> In another function.
10:04:30 <harlanhaskins> Split up, cleanly, I hope.
10:04:33 <edyu> does anyone know how do I annotate the type for (+) so that it's (Double -> Double -> Double)?
10:04:48 <pjdelport> edyu: (+) :: Double -> Double -> Double
10:05:13 <pjdelport> :t let plusDouble = (+) :: Double -> Double -> Double in plusDouble
10:05:14 <lambdabot> Double -> Double -> Double
10:06:05 <edyu> pjdelport: so can I say process [1,2,3] (+) :: Double -> Double -> Double?
10:06:16 <edyu> assume process is a function
10:06:17 <pjdelport> edyu: I'm not sure what you mean by that.
10:06:22 <pjdelport> Ah
10:06:34 <edyu> process :: [Double] -> (Double -> Double -> Double)
10:06:40 <edyu> and I want to use (+)
10:07:00 <edyu> i mean process :: [Double] -> (Double->Double->Double) -> Double
10:07:09 <pjdelport> edyu: In that case, you'd have to say ((+) :: Double -> Double -> Double) at the end, otherwise the :: applies to the whole expression on the left.
10:07:19 <edyu> ok, let me try, thank you pjdelport
10:07:29 <pjdelport> edyu: However, you can also simply say: process [1,2,3] (+) :: Double
10:07:43 <edyu> what does :: apply to?
10:07:48 <edyu> the whole expression?
10:07:55 <pjdelport> edyu: That associates like "(process [1,2,3] (+)) :: Double", and declares that the result of process must be Double.
10:08:07 <edyu> ah, let me try that too :)
10:08:18 <pjdelport> edyu: Haskell's type inference will then actually figure out that (+) must be double (assumic process is actually polymorphic)
10:08:23 <pjdelport> (assuming, even)
10:08:50 <Fuuzetsu> :t foldl1 (+)
10:08:51 <lambdabot> Num a => [a] -> a
10:08:58 <pjdelport> edyu: And right, :: binds loosely, so it will generally apply to the entire expression on the left of it unless you group it with parens.
10:10:13 <Philonous> Denommus, You could enable {-# LANGUAGE OverloadedStrings #-} and use string literals ( "foo") or use the pack function to convert a String
10:11:33 * hackagebot yi-language 0.1.0.5 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.5 (MateuszKowalczyk)
10:11:33 <edyu> pjdelport: even though I gave it :: Double
10:11:34 * hackagebot happstack-server 7.3.9 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.9 (JeremyShaw)
10:11:45 <Denommus> :i pack
10:11:53 <Denommus> :t pack
10:11:54 <edyu>   No instance for (Calculable (a0 -> a0 -> a0))
10:11:54 <edyu>       arising from a use of ‚Äòprocess‚Äô
10:11:54 <edyu>     The type variable ‚Äòa0‚Äô is ambiguous
10:11:54 <lambdabot>     Not in scope: ‚Äòpack‚Äô
10:11:54 <lambdabot>     Perhaps you meant one of these:
10:11:54 <lambdabot>       ‚ÄòBS.pack‚Äô (imported from Data.ByteString),
10:11:56 <edyu>     Note: there is a potential instance available:
10:11:58 <edyu>       instance Calculable (Double -> Double -> Double)
10:12:10 <pjdelport> edyu: Can you paste more of the code?
10:12:15 <pjdelport> @where lpaste
10:12:15 <lambdabot> http://lpaste.net/new/haskell
10:12:34 <pjdelport> edyu: It's probably also better to post bigger error messages on there. :)
10:13:14 <edyu> pjdelport: http://lpaste.net/112575
10:13:17 <edyu> thank you
10:13:28 <edyu> i'll use lpaste from now on
10:16:33 * hackagebot happstack-server-tls 7.1.4 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.4 (JeremyShaw)
10:17:05 <pjdelport> edyu: Ah, in that case, you do actually need to put the type signature on (+) itself, rather than on the end result.
10:17:23 <pjdelport> edyu: Since the latter isn't enough to determine which instance you want.
10:17:35 <edyu> gotcha! thank you so much pjdelport
10:17:57 <edyu> do you see any problem in doing FlexibleInstances?
10:18:13 <edyu> i'm assuming it's not the default for a reason pjdelport
10:18:21 <joshc> what do you want/expect to happen if I do: calculate [1] (+) ?
10:18:34 <NemesisD> how do you rebuild local haddocks for your dependencies in a cabal project
10:19:11 <edyu> joshc: this is just an example program so i'm simplifying no error handling :)
10:19:31 <Fuuzetsu> NemesisD: enable Haddock (in your cabal file or else) and rebuild deps
10:19:42 <NemesisD> *weeps*
10:19:44 <joshc> edyu: okay, just making sure you're thinking through these cases :)
10:19:46 <Fuuzetsu> yup
10:20:16 <Fuuzetsu> NemesisD: on nix you'd get binary caches which come with Haddock docs already ;)
10:20:18 <NemesisD> Documentation: True has been set forever but apparently my haddock was built with a different version of ghc and so it was quietly failing
10:20:21 <edyu> joshc: :) yes, my full program is too complicated to use as sample code to ask help :) you'll all hate me if i post the full program and ask for help :)
10:20:24 <NemesisD> i'm assuming that's what you mean by enable haddock
10:20:30 <Fuuzetsu> yes, probably
10:20:43 <Fuuzetsu> Haddock 2.15.0 is compatible with 7.8.2 and 7.8.3
10:20:59 <NemesisD> this'll be the 3rd time i build this hundreds-of-dependencies sandbox today
10:21:33 <Fuuzetsu> really look into nix
10:21:33 * hackagebot yi-language 0.1.0.6 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.6 (MateuszKowalczyk)
10:22:23 <NemesisD> i'm not sure if i have the time. i guess i'd have to develop in a vm since my main os is ubuntu
10:22:32 <NemesisD> also i've heard a lot of FUD about nix
10:22:45 <lpaste> pjdelport annotated ‚ÄúNo title‚Äù with ‚ÄúFixed, plus style tweaks‚Äù at http://lpaste.net/112575#a112580
10:23:12 <Fuuzetsu> NemesisD: what FUD?
10:23:43 <NemesisD> fuuzetsu: mostly around immaturity and lack of packages. i haven't looked into it in too much detail
10:23:55 <haasn> Fuuzetsu: when does nix get an alternative to systemd?
10:23:59 <haasn> nixos*
10:24:14 <Fuuzetsu> haasn: when someone motivated sits down and does it
10:26:33 * hackagebot yi-language 0.1.0.7 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.7 (MateuszKowalczyk)
10:26:45 <pjdelport> I think that FlexibleInstances is not the default purely because the standard is conservative: as far as i know, there isn't really any strong drawback to enabling it.
10:27:01 <pharpend> i didn't realize yi was still an active project
10:27:21 <pjdelport> edyu: I think there is consideration to enable it by default: https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
10:29:07 <edyu> pjdelport: thank you and I'm assuming that 4 space is the accepted indentation since your fix shows 4 spaces :)
10:36:31 <pjdelport> edyu: Oh, it's a variable style. I don't think there isn't a strong standard.
10:36:43 <pjdelport> err, I don't think there *is* a strong standard, even.
10:37:01 <pjdelport> edyu: You'll see 2 and 3 spaces too.
10:37:11 <edyu> thank you again pjdelport that was bothering me for whole night so i'm so glad you helped me fixing it
10:37:18 <ReinH> pjdelport: no no no never 3
10:38:11 <pjdelport> edyu: Do you understand why in that case, declaring the result type as Double is not enough to constrain the instance?
10:38:51 <edyu> because of the arity pjdelport I'm assuming because both (Double->Double) and (Double->Double->Double) use Double
10:39:00 <edyu> i mean both return Double
10:39:09 <edyu> so dispatching on return type was not enough
10:39:16 <pjdelport> edyu: Cool, right. :)
10:39:35 <pjdelport> But for other functions, constraining the result type alone can be enough.
10:39:45 <pjdelport> :t foldl' (+) 0
10:39:46 <lambdabot> Num a => [a] -> a
10:39:54 <pjdelport> :t foldl' (+) 0 :: Integer
10:39:55 <lambdabot>     Couldn't match expected type ‚ÄòInteger‚Äô
10:39:55 <lambdabot>                 with actual type ‚Äò[a0] -> a0‚Äô
10:39:55 <lambdabot>     Probable cause: ‚Äòfoldl'‚Äô is applied to too few arguments
10:40:05 <pjdelport> err
10:40:30 <Fuuzetsu> :t foldl' (+) 0 :: [Integer] -> Integer
10:40:31 <lambdabot> [Integer] -> Integer
10:40:41 <pjdelport> :t \xs -> (foldl' (+) 0 xs) :: Integer
10:40:42 <lambdabot> [Integer] -> Integer
10:41:03 <Fuuzetsu> > foldl' (+) ?xs :: Integer
10:41:05 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Integer.Type.Integer‚Äô
10:41:05 <lambdabot>              with actual type ‚Äò[a0] -> a0‚Äô
10:41:11 <Fuuzetsu> > foldl' (+) 0 ?xs :: Integer
10:41:13 <lambdabot>  mueval-core: internal error: PAP object entered!
10:41:13 <lambdabot>      (GHC version 7.8.2 for x86_64_unknown_linux)
10:41:13 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
10:41:16 <pjdelport> In that example, fixing the result to Integer is enough to declare that both the input list and (+) must also work on Integers.
10:41:18 <Fuuzetsu> ‚Ä¶
10:41:22 <Fuuzetsu> why GHC
10:41:26 <merijn> Fuuzetsu: It can't print an ImplictParam, duh
10:41:33 <muricula> Hey what's a good graphing library for haskell?
10:41:36 <Fuuzetsu> :t ?x + ?y
10:41:37 <lambdabot> (?y::a, ?x::a, Num a) => a
10:41:46 <Fuuzetsu> sure it can
10:41:52 <Fuuzetsu> oh
10:41:55 <merijn> Fuuzetsu: It can show the *type* :)
10:41:57 <Fuuzetsu> ok, I see
10:42:03 <Fuuzetsu> yeah, should have used :t
10:42:07 <Fuuzetsu> still, it shouldn't panic‚Ä¶
10:43:07 <merijn> muricula: I dunno if there is one. We have diagrams, but that's not really all that useful for plotting, I think? I could be wrong, though!
10:43:51 <ClaudiusMaximus> muricula: http://hackage.haskell.org/package/Chart perhaps
10:44:17 <jle`> that's that library that calls to gnuplot
10:44:43 <muricula> ClaudiusMaximus: thanks!
10:45:18 <jle`> good job Fuuzetsu
10:45:37 <jle`> well now we know the architecture and ghc version that lambdabot runs on
10:45:42 <jle`> 7.8.2 has some bad bugs right
10:45:54 <ClaudiusMaximus> jle`: i don't think Chart uses gnuplot
10:46:03 <jle`> oh, i meant to say
10:46:06 <jle`> *there's that library that...
10:47:21 <_rai> how do I compose elem and not while partially applying with a list
10:48:02 <simpson> @pl \x xs -> not $ x `elem` xs
10:48:02 <lambdabot> (not .) . elem
10:48:17 <simpson> _rai: ^^^, but TBH writing it out sounds much easier.
10:48:24 <simpson> @pl \x -> not $ x `elem` xs
10:48:24 <lambdabot> not . (`elem` xs)
10:48:31 <simpson> Sorry, didn't read right.
10:48:47 <jle`> it's nicer to write it with at least one point
10:49:25 <joseph07> :t notElem
10:49:26 <lambdabot> Eq a => a -> [a] -> Bool
10:49:34 <jle`> oh yes there's also that
10:49:41 <mox> Hi, I am doing a home work but I am stuck on a data type like that: "data foo = foo (Int, String)" I can create a variable with the data type like that: foo(1, "bar"), but how do I access the Int or String value "inline" in the code? Thanks!
10:49:51 <_rai> ah nice
10:51:35 * hackagebot yi 0.10.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.10.0 (MateuszKowalczyk)
10:52:34 <pjdelport> mox: You generally use pattern matching to match the contents of a constructor.
10:53:01 <pjdelport> mox: So you might say: f (Foo (x, s)) = ...
10:53:36 <pjdelport> Then f takes a Foo value, and the x and s variables are the Int and String values that you can then reference in the body.
10:54:16 <mox> pjdelport: I have created a function called "getFooInt (foo (fooInt, _)) = fooInt" but the teacher don't want me to create additional funcitons
10:54:58 <harlanhaskins> johnw: Okay, so I've got it benchmarking, but how can I get it to benchmark JUST the pure functions without the File IO?
10:55:13 <mox> Can I do pattern matching inline?
10:55:42 <yukko> mox you can use let or where
10:55:47 <hexagoxel> mox: also, you can just write {data Foo = Foo Int String} and construct using {Foo 1 "bar"}, and case-match {case x of Foo i str -> ...}
10:56:15 <pjdelport> pjdelport: You can do pattern matching in any binding context, more or less. A "binding context" is where you can introduce variables, like in function definitions, let, case, where, and so on.
10:56:20 <pjdelport> err, mox -^
10:56:35 * hackagebot yi-contrib 0.10.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.10.0 (MateuszKowalczyk)
10:57:18 <mox> I see, so I should start my function with a "do" followed by the pattern matching inside a variable before doing my if-then-else stuff if I understand right
10:57:27 <pjdelport> mox: It's not necessarily a bad idea to create functions like getFooInt (that's what record syntax effectively does), but it's probably not the best thing in general: direct pattern matching is often simpler and shorter.
10:57:39 <johnw> harlanhaskins: collected the IO data before you run the benchmark
10:57:50 <pjdelport> mox: No, you can just do the pattern matching in the function's argument itself.
10:58:11 <pjdelport> mox: Like that example above: someFunction (Foo (x, s)) = ...
10:58:35 <pjdelport> someFunction just deconstructs its argument directly, no need for anything more complicated.
10:58:45 <mox> pjdelport: I'm not used to Haskell, I was seeing this "getFooInt" more like a "getIndex" private function for the class.. looks like it's not what's needed in the homework
10:59:19 <pjdelport> mox: Well, pattern matching is used very pervasively in Haskell. You'll probably get used to it soon. :)
10:59:20 <harlanhaskins> johnw: How? Right now my main is this:
10:59:20 <harlanhaskins> main = defaultMain [ bgroup "luhn" [ bench "1,000,000,000" $ whnf check integerLines ] ]
10:59:22 <mox> pjdelport: Ok, I will have to try that, this is interesting.. I did not know I could do that in the function arguments
10:59:42 <johnw> you won't be able to use defaultMain
10:59:48 <harlanhaskins> johnw: :(
11:00:01 <johnw> you'll need main = do <collect lines> ; <run benchmark over lines>
11:00:13 <johnw> defaultMain is cute, but running the tests yourself is no harder
11:00:21 <pjdelport> mox: You can do it in many places, yeah. It's comparatively rare in Haskell to use accessors like getFoo: most of the time, it's simply not needed.
11:00:53 <pjdelport> (The only exception is data types with very many fields, and for those, you usually use record syntax or such.)
11:00:54 <hexagoxel> mox: but you already used that in getFooInt :)
11:06:36 * hackagebot happstack-hsp 7.3.3 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.3 (JeremyShaw)
11:06:37 * hackagebot hydrogen-data 0.7.1 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.7.1 (JulianFleischer)
11:06:56 <mox> hexagoxel: you're right, I just didn't realize the difference lol
11:07:18 <mox> pjdelport: Thanks for your help, my code compile without the added functions :-)
11:07:32 <pjdelport> mox: Cool. :)
11:08:11 <mox> Like you said, eventually I'll get used to it.. I guess I'm too used languages like C/Perl
11:09:15 <NemesisD> it should be noted that record fields tend to be a problem if your api is going to change
11:09:32 <NemesisD> ive seen it argued that not exporting record fields and instead exporting lenses is preferable
11:09:49 <buttons840> how would you times a two tuple, IE: (1, 0) * 2 == (2, 0) ?
11:10:37 <NemesisD> buttons840: fmap (*2)
11:10:46 <NemesisD> wait no
11:11:30 <buttons840> I know how to make a new function to do it, but I was wondering if there's a more general approach
11:11:52 <pjdelport> :t bimap
11:11:53 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:11:56 <NemesisD> yeah was just gonna say
11:12:01 <NemesisD> the redundancy is unfortunate
11:12:06 <harlanhaskins> johnw: This seems to be working here...
11:12:11 <harlanhaskins> https://gist.github.com/harlanhaskins/06a276850950f0d3e4c7
11:12:12 <pjdelport> buttons840: That might be the most obvious generalization.
11:14:21 <maimuni> is here discusion about Cryptography?
11:15:03 <NemesisD> buttons840, there's also lens: over both (*2) (2,4) == (4,8)
11:15:24 <johnw> maimuni: if it's Cryptography in Haskell
11:15:54 <wakalabis> Hey guys. What would be the type signature of a generic function that takes an MVector and mutates it? I would like it to work for both IO and (ST s) vectors.
11:16:07 <wakalabis> I tried this: foo :: PrimMonad m => MVector (PrimState m) Int -> m a
11:16:11 <wakalabis> But it won't type check
11:16:30 <johnw> wakalabis: there aren't examples in the vector library?
11:16:36 * hackagebot happstack-jmacro 7.0.9 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.9 (JeremyShaw)
11:16:38 * hackagebot happstack-lite 7.3.5 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.5 (JeremyShaw)
11:16:40 <wakalabis> I tried to follow the type of `read`: read :: PrimMonad m => MVector (PrimState m) a -> Int -> m a
11:17:12 <wakalabis> johnw: I tried looking here http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
11:17:18 <edwardk> > (2,4) & both *~ 2
11:17:20 <lambdabot>  (4,8)
11:17:36 <wakalabis> johnw: but I couldn't find exactly what I was lookin for
11:17:41 <maimuni> johnw: no
11:17:50 <johnw> wakalabis: i mean looking at the vector Haddocks
11:17:57 <johnw> there are plenty of generic vector mutating functions in there
11:18:35 <maimuni> johnw: is the chanell about computer science?
11:18:45 <wakalabis> johnw: There is this: write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()
11:18:47 <johnw> no, it is about the Haskell language, and implementations thereof
11:19:29 <johnw> wakalabis: what type error did you get with your foo?
11:19:35 <wakalabis> johnw: But if I try compiling that type signature I get an error: The first argument of ‚ÄòMVector‚Äô should have kind ‚Äò* -> * -> *‚Äô,
11:19:35 <wakalabis>       but ‚ÄòPrimState m‚Äô has kind ‚Äò*‚Äô
11:20:14 <johnw> did you import Data.Vector.Generic.Mutable?
11:20:21 <wakalabis> johnw: I copied and pasted `write`'s signature to foo, but it doesn't work
11:20:36 <johnw> see http://hackage.haskell.org/package/vector-0.10.12.1/docs/Data-Vector-Generic-Mutable.html
11:20:51 <johnw> there write is: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()
11:21:00 <wakalabis> johnw: Yes, I did
11:21:19 <wakalabis> johnw: wait...
11:21:36 * hackagebot hsx-jmacro 7.3.6 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.6 (JeremyShaw)
11:21:38 * hackagebot web-routes-happstack 0.23.8 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.8 (JeremyShaw)
11:21:54 <Denommus> in netwire, could I describe the position of a character as position = integral initialPosition . velocity and just define how the velocity varies with the events?
11:22:11 <wakalabis> johnw: It worked, thanks... I was looking at the wrong place. I was looking at Data.Vector.Mutable instead of Data.Vector.Generic.Mutable
11:22:25 <johnw> yeah, I've made that mistake a few times :)
11:22:59 <wakalabis> :)
11:24:32 <merijn> Denommus: That's the general idea, yes
11:24:41 <mauris> "If defined, some and many should be the least solutions of the equations:
11:24:41 <mauris> " what does "least" mean?
11:26:10 <johnw> usually it means, having the smallest size or weakest definition
11:26:36 * hackagebot web-routes-hsp 0.24.5 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.24.5 (JeremyShaw)
11:26:38 * hackagebot helics 0.5.0 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.5.0 (HirotomoMoriwaki)
11:26:40 * hackagebot pdf-toolbox-core 0.0.3.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.3.0 (YurasShumovich)
11:26:42 * hackagebot pdf-toolbox-content 0.0.3.1 - A collection of tools for processing PDF files  http://hackage.haskell.org/package/pdf-toolbox-content-0.0.3.1 (YurasShumovich)
11:26:44 <mauris> is it not a formal term?
11:26:45 * hackagebot pdf-toolbox-document 0.0.4.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.4.0 (YurasShumovich)
11:27:17 <becha> Hello, I'm learning Haskell and have a short question. Let's assume I have a function taking three integer arguments - what's the easiest way to define my function body to insert these three arguments into an IntegerSet?
11:29:02 <Philonous> foo x y z = fromList [x,y,z]  ?
11:29:39 <Philonous> Oh, insert, so presumably there's already another set
11:29:54 <Philonous> foo s x y z = fromList [x,y,z]  <> s
11:30:10 <johnw> mauris: I thought it was, but I'm having difficulty finding an exposition of the term
11:30:15 <becha> well, there is no set before. I need the set to eliminate duplicates
11:31:46 * hackagebot helics-wai 0.5.0 - New RelicÆ agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.5.0 (HirotomoMoriwaki)
11:31:49 * hackagebot pdf-toolbox-viewer 0.0.3.0 - Simple pdf viewer  http://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.3.0 (YurasShumovich)
11:31:50 * hackagebot state-plus 0.1.1 - MonadPlus for StateT  http://hackage.haskell.org/package/state-plus-0.1.1 (BorisSukholitko)
11:32:06 <Philonous> becha, I'd use fromList
11:33:51 <becha> ok, thank you. At least I'm really new to the idea of functional programming. In Java, Python or somewhere else I must instantiate my Set before using it - do I have to do this in Haskell to or is just calling fromList returning a new set?
11:34:57 <Philonous> becha, formList [x,y,z] evaluates to the IntSet directly
11:36:35 <becha> Philonous, thank you. How can I access this set? What's it's name?
11:36:37 * hackagebot web-routes-boomerang 0.28.3 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.28.3 (JeremyShaw)
11:36:39 * hackagebot alea 0.1.1.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.1.1.0 (rnhmjoj)
11:36:41 * hackagebot web-routes-wai 0.24.1 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.24.1 (JeremyShaw)
11:37:05 <merijn> becha: It doesn't have a name, the "fromList [x,y,z]" expression evaluates to a Set
11:37:20 <vanila> How does liquidhaskell work?
11:37:21 <merijn> :t S.fromList [1,2,3,4]
11:37:23 <lambdabot> (Ord a, Num a) => S.Set a
11:37:26 <Philonous> becha, In Haskell, you're usually working with values rather than reference cells. This IntSet is a value, like an Int or a String, it doesn't have a value.
11:37:30 <merijn> :t S.fromList [1,2,3,4] :: Set Int
11:37:31 <lambdabot>     Not in scope: type constructor or class ‚ÄòSet‚Äô
11:37:31 <lambdabot>     Perhaps you meant one of these:
11:37:31 <lambdabot>       ‚ÄòS.Set‚Äô (imported from Data.Set),
11:37:49 <Philonous> becha, Sorry, it doesn't have a name
11:37:52 <merijn> > S.null (S.fromList [1,2,3,5])
11:37:54 <lambdabot>  False
11:37:58 <merijn> Or
11:38:16 <Philonous> becha, But you can bind it to one, like this:  let myIntSet = fromList [1,2,3] in <expression involvinf myIntSet>
11:38:49 <merijn> > let mySet = (S.fromList [1,2,3,5]) in (S.null mySet, S.member 5 mySet, S.member 10 mySet)
11:38:51 <lambdabot>  (False,True,False)
11:39:03 <becha> Thank you! It's a little bit hard to get used to all of this, but I guess that will help me a lot!!
11:39:31 <Philonous> becha, Not that you have merely given a name to a (single) value. It's not like a Python-variable, that holds different values at different times.
11:39:50 <becha> what's the difference merijn's answer?
11:40:18 <becha> *compared to
11:41:08 <Philonous> I'm not sure what you mean. He gave some examples of how to work with sets
11:41:29 <edyu> is it possible to have a Map.Map of a String to a function of various arity?
11:41:33 <becha> :t S.fromList [1,2,3,4] :: Set Int      isn't that doing the same?
11:41:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:41:37 * hackagebot reform 0.2.6 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.6 (JeremyShaw)
11:41:39 * hackagebot reform-hsp 0.2.5 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.5 (JeremyShaw)
11:41:42 * hackagebot test-simple 0.1.7 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1.7 (BorisSukholitko)
11:41:43 * hackagebot reform-happstack 0.2.4 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.4 (JeremyShaw)
11:41:45 * hackagebot reform-blaze 0.2.3 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.2.3 (JeremyShaw)
11:42:10 <Philonous> edyu, Not directly, but you could define a data type that has Constructors that hold functions of the respective arities
11:44:00 <edyu> Philonous: ah, let me see if I can make that work
11:45:27 <becha> you said giving the set a name is not like in python. can i call functions on my named set? e.g. myIntSet.finMax?
11:46:38 * hackagebot reform-hamlet 0.0.4 - Add support for using Hamlet with Reform  http://hackage.haskell.org/package/reform-hamlet-0.0.4 (JeremyShaw)
11:46:58 <edyu>     Illegal polymorphic or qualified type: Calculable a => a
11:46:58 <edyu>     Perhaps you intended to use ImpredicativeTypes
11:47:09 <edyu> Philonous: what does this mean? ^
11:47:49 <edyu> i was using Map.Map String (Calculable a => a)
11:48:32 <Philonous> becha, Sure, though haskell doesn't have dot-syntax, so its findMax (fromList [x,y,z]) or even let mySet = fromList [x,y,y] in findMax mySet
11:49:21 <becha> ah, ok. Thanks!
11:51:28 <asfp> does haskell-mode support automatically figuring out which import is needd when ghc gives an unknown error message?
11:51:37 <thoughtpolice> Fuuzetsu: nice job with yi, btw. happy to see it being worked on still :)
11:52:18 <Fuuzetsu> I just can't deal with ELisp for the rest of my life
11:53:10 <Philonous> edyu, Well, that type is invalid. And I don't think it's what you mean, either. You saying your Map contains values that have _all_ types a (with the Calculable constraint), rather than that it's of _some_ type that has a Calculable constraint
11:53:19 <becha> is it possible that findMax is out of scope? i have import Data.IntSet (IntSet) at the beginning of the file
11:53:56 <Philonous> becha, You have to add findMax to the import list : import Data.IntSet (IntSet, findMax)
11:54:08 <becha> ah!
11:54:09 <edyu> Philonous: I have a calculable typeclass that has instances of (Double->Double) and (Double->Double->Double) and I'd like to have both of those instances in the value of a Map
11:54:33 <becha> fromList too?
11:54:43 <edyu> so I want something like [("plus", (+)), ("factorial", (!))]
11:55:11 <edyu> is that possible?
11:55:37 <Philonous> becha, Presumably, if you want to use it. Or you could import qualified: import qualified Data.IntSet as IntSet, then you can refer to everything that the module exports by tacking "IntSet." infront of it (e.g. IntSet.fromList )
11:56:05 <becha> like in python. thank you
11:56:38 * hackagebot happstack-heist 7.2.4 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.2.4 (JeremyShaw)
11:56:40 * hackagebot happstack-foundation 0.5.6 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.6 (JeremyShaw)
11:56:48 <Philonous> edyu, Even if it was, how would you know how many arguments the functions take when you retrieve them from the map?
11:57:38 <edyu> Philonous: doesn't (+) already know it's a binary operator?
11:58:49 <Philonous> edyu, No, (+) is a name, and the value it refers to (the addition function) doesn't have any dynamic typing information attached to it. It's all static, and once you forget it it's gone for good
11:59:07 <edyu> Philonous: i'm also annotating the type for example [("+", (+) :: (Double->Double->Double)]
11:59:12 <pjdelport> edyu: You can view (+) either as a two argument function, or as a one-argument function that itself returns a function.
11:59:32 <pjdelport> That is, (+) :: Double -> (Double -> Double)
11:59:50 <oconnore> what is the ":|" in "data List t = Nil | t :| List t deriving Eq"?
12:00:01 <pjdelport> The -> in types is right-associative, so the parens on the right are always there implicitly.
12:00:06 <Philonous> edyu, Yes, but the information would be lost once you have a collection that can contain all sorts of types.
12:00:17 <pjdelport> oconnore: It's an infix constructor.
12:00:18 <vanila> oconnore, that's a constructor
12:00:58 <pjdelport> oconnore: the ":" prefix is special for operators, and declares it to be a constructor instead of a function, similar to how capital letters are the distinction between prefix functions and constructors.
12:01:51 <edyu> Philonous: pjdelport: so I guess I cannot have a map of a string to a function of various arity. If i have to, i should have 2 different maps, one for unary and one for binary, am I correct?
12:02:06 <pjdelport> oconnore: If you used `Cons` instead of :| then you read that as: data List t = Nil | t `Cons` List t
12:02:09 <oconnore> pjdelport: ok, so how do I parse that type? I'm used to seeing things like "data Tree a = EmptyTree | Leaf a | Branch a (Tree a) (Tree a)" where each constructor is named
12:02:51 <pjdelport> edyu: That's one way of doing it. You can also make a Map with Either values, one for each type.
12:03:03 <oconnore> pjdelport: So I can create a List Int with "let x = | 34 Nil"?
12:03:26 <Philonous> edyu, actually, it's not that bad. You just have to hellp the compiler out. You could have data Function = Single (Double -> Double) | Dual (Double -> Double -> Double) | Triple ( Double -> Double -> Double ->Double)
12:03:30 <pjdelport> oconnore: You'd write it as let x = 34 :| Nil
12:03:37 <edyu> ah pjdelport, what if I have 3 types, unary, binary, and something that operators on an array of data
12:03:51 <Philonous> edyu, And then you can pattern match on the constructors and ghc can statically retrieve the typing information
12:03:53 <oconnore> pjdelport: ah, ok
12:03:57 <oconnore> pjdelport: thank you
12:04:03 <pjdelport> edyu: Then you'd need a value type with three alternatives :)
12:04:06 <edyu> ok, let me ponder that Philonous to see if i can make that work
12:04:36 <pjdelport> edyu: Pretty much what Philonous said: you can add as many cases as you need.
12:04:52 <steffen> I always run cabal build, even if I only want to know whether my code typechecks, is there a better way to use cabal and typecheck the project?
12:05:16 <pjdelport> (Either is just a built-in one that's convenient for two cases, since that's common.)
12:05:32 <Philonous> edyu, If you find the proliferation of constructors (one for each arity) distateful, you can invent a more sophisticated scheme: data Function = Returns Doubele | Takes (Double -> Function)
12:06:39 * hackagebot web-plugins 0.2.7 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.7 (JeremyShaw)
12:06:47 <Philonous> Of course, that's a bit more cumbersome to work with, since you have to wrap each of the arguments individually, but it can handle an arbitrary number of arguments
12:07:29 <pjdelport> You can also do things with existential qualification, most likely, but that's probably getting ahead of things.
12:07:30 <Philonous> So, (+) becomes: Takes (\x -> Takes (\y -> Returns (x+y)) :: Function
12:09:38 <alenn> Does Integral include Eq?
12:10:26 <alenn> I can do: numberName :: (Integral a) => a -> String %% numberName 1 = "Number One!" - but not (Num a)
12:10:33 <alenn> Wondering why
12:10:51 <trap_exit> is 1.0 == 1 ?
12:11:01 <trap_exit> or is frac 2/2 == 1 ?
12:11:05 <trap_exit> I think that is difference between integral and num
12:11:14 <trap_exit> (this is purely me guessing)
12:12:16 <alenn> numberName :: (Num a) => a -> String
12:12:17 <alenn> numberName 1 = "Number One!"
12:12:21 <alenn> why cant I do this?
12:12:36 <geekosaur> Num doesn't have Eq, Integral does via Real
12:12:55 <geekosaur> so you will need (Num a, Eq a) => ...
12:13:20 <alenn> thanks!
12:13:22 <geekosaur> (also pattern matching on a number is a dirty hack that translates into an application of (==)_
12:14:31 <edyu> pjdelport: Philonous: thank you again
12:14:38 <alenn> you mean that I should rather have: numberName x = if x == 1 ...
12:15:08 <geekosaur> considering the weird corner cases, yes
12:15:26 <geekosaur> because it can't actually do it as if it were a constructor
12:16:18 <zwer> what weird corner cases?
12:16:38 <vjeranc> anyone used regex-tdfa library? I can't seem to make [:alnum:] work, it just behaves as an ordinary selection among alnum:
12:16:38 <vjeranc> I've tried with bytestring, string and text, nothing works..
12:18:00 <zq> vjeranc: regex-tdfa isn't posix complete
12:18:09 <zq> vjeranc: [a-zA-Z0-9]
12:18:32 <joseph07> Philonous: that Function type is kind of fun. You can write toFunctionN for various aritys and a runFunction :: Function a -> [a] -> Maybe a
12:19:09 <vjeranc> zq: yep, I thought that was the problem, although "The character classes like [:alnum:] are supported over ASCII only, valid classes are alnum, digit, punct, alpha, graph, space, blank, lower, upper, cntrl, print, xdigit, word." is on the first page of docs...
12:21:16 <joseph07> Philonous: Plus toFunction3 f = Takes (\x -> toFunction2 $ f x)
12:21:39 * hackagebot haskintex 0.5.0.2 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.5.0.2 (DanielDiaz)
12:41:40 * hackagebot HSH 2.1.1 - Library to mix shell scripting with Haskell programs  http://hackage.haskell.org/package/HSH-2.1.1 (JohnGoerzen)
12:43:01 <Fuuzetsu> is there a way to tell cabal to include all files under some directory in the tarball? We have hundreds of test files
12:46:40 * hackagebot dash-haskell 1.0.0.1 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.1 (jfeltz)
12:48:12 <luite> Fuuzetsu: you can do *.someExtension, but no "include whole subtree" (which is intentional as far as i know, to prevent people from accidentally including a whole bunch of junk)
12:48:42 <Fuuzetsu> ‚Ä¶
12:48:53 <Fuuzetsu> guess it's time for ‚Äòfind‚Äô
12:49:24 <luite> Fuuzetsu: yeah some packages like Cabal include some comment in their cabal file that shows how to generate some section
12:50:01 <luite> Fuuzetsu: for GHCJS we include a few .tar files that have the bundled libraries, test suite and runtime system and have a script that generates them
12:50:22 <Fuuzetsu> can I say foo/* rather than foo/*.someExtension?
12:52:11 <luite> hm, i don't think so
12:55:42 <zipper> Is there a way to implement a function with this type:
12:55:44 <zipper> ex6 :: (a -> a) -> a
12:55:49 <zipper> ?
12:55:55 <joshc> :t fix
12:55:56 <lambdabot> (a -> a) -> a
12:56:15 <zipper> joshc: Oh shock on me
12:56:18 <joshc> uh oh, hope I didn't give something away :\
12:56:38 <cmtptr> is that the function you use when your code is broken?
12:56:43 <zipper> joshc: You didn't
12:56:54 <exio4> fix x = x (fix x)
12:57:22 <YurasS> is Hackage documentation builder still broken?
12:57:28 <pjdelport> Obligatory joke:
12:57:29 <pjdelport> > fix error
12:57:29 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:57:41 <zipper> It's exercise 6 at http://www.seas.upenn.edu/~cis194/hw/04-poly.pdf
12:57:57 <YurasS> should I upload docs manually to Hackage or what for builder?
12:58:09 <YurasS> s/what/wait
12:58:24 <zipper> exio4: I don't see how x will be a value that will act on the result of (fix x) as in x (fix x)
12:59:28 <pjdelport> Does it help to call it f instead of x?
12:59:45 <pjdelport> > fix (1:)
12:59:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:00:33 <zipper> it fails to typecheck for me
13:00:39 <zipper> let me paste the error
13:00:42 <pjdelport> fix (1:)  ‚Üí  1:fix (1:)  ‚Üí 1:1:fix (1:)
13:00:43 <pjdelport> etc.
13:00:56 <kuribas> @djinn help
13:00:56 <lambdabot> -- f cannot be realized.
13:01:06 <kuribas> @djinn (a -> a) -> a
13:01:06 <lambdabot> -- f cannot be realized.
13:01:11 <kuribas> @djinn ((a -> a) -> a)
13:01:11 <lambdabot> -- f cannot be realized.
13:01:17 <merijn> kuribas: Won't work
13:01:41 * hackagebot HaTeX 3.14.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.14.0.0 (DanielDiaz)
13:01:43 * hackagebot yi 0.10.1 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.10.1 (MateuszKowalczyk)
13:01:45 * hackagebot yi-contrib 0.10.1 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.10.1 (MateuszKowalczyk)
13:02:14 <kuribas> @hoogle ((a -> b) -> a)
13:02:16 <lambdabot> Data.Function fix :: (a -> a) -> a
13:02:16 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:02:16 <lambdabot> Data.ByteString.Builder.Prim (>$<) :: Contravariant f => (b -> a) -> f a -> f b
13:02:21 <merijn> kuribas: djinn is based on the whole "types as logic" thing and if you look at the type you can immediately tell it's not a valid logic statement
13:02:29 <kuribas> merijn:  yeah :)
13:03:12 <kuribas> (a -> a) is a tautology right?
13:03:45 <merijn> Yes
13:04:02 <merijn> But you cannot conclude "a" from "a implies a"
13:04:18 <Fuuzetsu> sure you can
13:04:19 <Fuuzetsu> :t fix
13:04:21 <lambdabot> (a -> a) -> a
13:04:21 <Fuuzetsu> ;^)
13:04:55 <kuribas> So if reality has fixed points, then reality isn't logical?
13:05:32 <kuribas> Or causality doesn't exist?
13:06:17 <urbanslug> Ok this is the error I get from `ex6 f x = x`
13:06:19 <urbanslug> http://sprunge.us/Ohbf
13:06:22 <urbanslug> It's zipper
13:06:25 <kuribas> @djinn (Int -> a -> a)
13:06:26 <lambdabot> Error: Undefined type Int
13:08:29 <cjenkin1> The type of fix is 'a blatant lie' :)
13:08:48 <cjenkin1> At least according to WDTM
13:08:57 <kuribas> zipper: ex6 has 1 arg, your function 2.
13:09:58 <joshc> cjenkin1: WDTM?
13:10:00 <caseof> I can't make my little DSL with free monad compile: https://gist.github.com/gip/82aee58d0eb76a61e077  Any idea / pointer to help me here?
13:10:12 <kuribas> zipper: try "ex6 f = ..."
13:10:26 <cjenkin1> joshc: "Why Dependent Types Matter"
13:10:34 <joshc> cjenkin1: ah, thanks.
13:16:42 * hackagebot leveldb-haskell 0.6 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.6 (KimAltintop)
13:20:47 <zipper> cjenkin1: So it was all a joke?
13:22:34 <gigabytes> hi
13:22:49 <gigabytes> trying to somewhat "invert" a Data.Map k a into a MultiMap a k
13:22:54 <felixn> caseof: not sure, but looks interesting, let me know when you figure it out!
13:22:59 <gigabytes> invert = Map.foldrWithKey (flip MMap.insert) []
13:23:10 <gigabytes> it works, but I have to specify the type
13:23:44 <gigabytes> why can't the compiler infer the constraints? I get an error saying the type variable is ambiguous
13:23:57 <gigabytes> I get those kind of errors a lot also when using monad transformers
13:24:18 <gigabytes> specifying the type solves the problem, but I want just to know what is happening
13:27:20 <Elite6809> Hey, I'm learning F# at the moment - is there any overlap between F
13:27:23 <Elite6809> # and Haskell?
13:27:34 <Elite6809> Or are they 2 different types of functional languages?
13:28:07 <S11001001> Elite6809: there are many similar features, and several significant differences.
13:28:40 <S11001001> Elite6809: Probably the main basic things they have in common that are missing from many other languages are ADTs and [what F# calls] automatic generalization.
13:28:50 <zipper> Elite6809: I don't know f sharo but I infer that there must be some overlap since they're both FP langs ;)
13:29:00 <cjenkin1> zipper: A joke?
13:29:29 <zipper> cjenkin1: So fix doesn't exist, right? Because it won't typecheck and makes no sense to me.
13:29:43 <Elite6809> OK, thanks
13:29:44 <cjenkin1> zipper: fix does exist in Haskell, because of lazy evaluation
13:29:46 <zipper> cjenkin1: I can take a joke :)
13:29:56 <cjenkin1> >:t fix
13:29:57 <Elite6809> I might pick up both books then so get the best of both worlds
13:30:00 <cjenkin1> >t fix
13:30:04 <zipper> cjenkin1: Ok I can't get it to typecheck
13:30:09 <zipper> :t fix
13:30:10 <lambdabot> (a -> a) -> a
13:30:12 <cjenkin1> ah
13:30:13 <zwer> @src fix
13:30:13 <lambdabot> fix f = let x = f x in x
13:30:32 <cjenkin1> I did it with fix f = f $ fix f
13:30:34 <Elite6809> I come from a C# background so F# is more natural to me, but I want to learn Haskell too so I'm not tied to Windows
13:30:57 <caseof> felixn: Thanks! Also, I found this: https://www.fpcomplete.com/user/chowells79/types-not-tutorials  Not sure it's relevant, but I'll read through it
13:31:03 <cjenkin1> Provided f is a data constructor, it at least is coinductive
13:31:20 <zipper> zwer: What will the x in f x be?
13:31:22 <zwer> it could also be defined like this: fix' f = f (fix f)
13:31:36 <mioltr> caseof: think you want 'String' not 'Text'
13:31:37 <zipper> cjenkin1: I get yours more but still
13:31:42 * hackagebot phantom-state 0.2.0.2 - Phantom State Transformer. Like State Monad, but without values.  http://hackage.haskell.org/package/phantom-state-0.2.0.2 (DanielDiaz)
13:32:09 <zwer> zipper it is recursive definition
13:32:14 <S11001001> Elite6809: Many people use F# on Mono.  You may wish to experiment with that on non-Windows systems; all of my F# has been done on Mono+GNU/Linux.  But overall the Haskell learning experience is probably better.
13:32:43 <cjenkin1> zipper: the 'let' binding just gives the result of fix f a name
13:33:14 <zipper> cjenkin1: Yeah all it says is f x but x is out of scope.
13:33:33 <zipper> or wait x is f x
13:33:36 <zipper> wow
13:33:38 <zipper> ummmm#
13:33:51 <cjenkin1> take 10 $ fix (1:)
13:33:56 <cjenkin1> what am I doing wrong?
13:34:13 <cjenkin1> >take 10 $ fix (1:)
13:34:15 <S11001001> zipper: let your lack of surprise when a *function* is referred to in its own definition generalize to all values
13:34:28 <S11001001> > take 10 $ fix (1:)
13:34:29 <Fuuzetsu> cjenkin1: you have to precede your expression with ‚Äò> ‚Äô
13:34:30 <zwer> cjenkin1 you are missing a space
13:34:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:34:42 <cjenkin1> with a space
13:34:45 <cjenkin1> gotcha
13:36:12 <zipper> I see we're evaluating the next value in an infinite list. The rest remains as a thunk
13:36:33 <zipper> f is being partially applied
13:37:20 <zwer> > fix (\rec x -> x : rec (x+1)) 0
13:37:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:37:33 <lpaste> worldsayshi pasted ‚ÄúSimple Lens test fail‚Äù at http://lpaste.net/112590
13:37:36 <cjenkin1> zipper: You can think of "let x = f x in ..." as a rewrite rule
13:37:53 <cjenkin1> So x first gets rewritten as f x, then f $ f x, etc
13:38:41 <zipper> Oi I'm going to sleep. I don't see why I'm not getting this seemingly simple concept.
13:38:52 <worldsayshi> Hmm, I‚Äôve created a paste above. Trying to use fclabels but fail with very simple case. What am I doing wrong? Maybe I need some ghc extension?
13:38:53 <zipper> I'm going to try it tomorrow.
13:38:56 <cjenkin1> zipper: It actually isn't so simple imo
13:39:00 <cjenkin1> So don't feel bad :)
13:39:10 <zipper> cjenkin1: lol you knew I felt bad?
13:39:11 <worldsayshi> Although that doesn‚Äôt make sense :)
13:39:26 <zipper> cjenkin1: I didn't give up though.
13:39:26 <cjenkin1> zipper: no one likes not understanding something
13:39:38 <cjenkin1> That's the spirit :)
13:39:48 <zipper> cjenkin1: I'll look at it tomorrow when I'm not sleepy.
13:39:52 * zipper is out.
13:41:43 * hackagebot monad-supply 0.6 - Stateful supply monad.  http://hackage.haskell.org/package/monad-supply-0.6 (GeoffHulette)
13:42:27 <cjenkin1> So there's no 'bottom' type in vanilla Haskell?
13:44:15 <Ralith> @hackage void
13:44:15 <lambdabot> http://hackage.haskell.org/package/void
13:46:47 <cjenkin1> Ralith: I see a constructor for Void there...
13:47:06 <Ralith> really? where?
13:48:03 <cjenkin1> data Void = Void !Void
13:48:07 <cjenkin1> Am I reading this wrong?
13:49:03 <Ralith> cjenkin1: do you understand how ! works?
13:49:18 <cjenkin1> Ralith: I suppose not. I'm not actually a very experienced Haskeller
13:50:56 <Fuuzetsu> cjenkin1: what does ! change here?
13:51:40 <StoneToad> isn't that a strict recursive datatype? won't that hang the compiler?
13:51:43 <Fuuzetsu> cjenkin1: the constructor can only be applied to Void which can only be created by Void‚Ä¶
13:52:00 <Fuuzetsu> StoneToad: Why would it hang the compiler?
13:52:14 <joelteon> :t fix Void
13:52:16 <lambdabot> Not in scope: data constructor ‚ÄòVoid‚Äô
13:52:31 <cjenkin1> :k Void
13:52:32 <lambdabot> Not in scope: type constructor or class ‚ÄòVoid‚Äô
13:52:37 <Ralith> StoneToad: recursive datatypes are used all the time; how do you think lists work?
13:52:45 <Fuuzetsu> joelteon: you might as well undefined :: Void, at least it will fail faster
13:52:49 <StoneToad> Ralith: with a strictness modifier?
13:53:05 <Ralith> StoneToad: why would that cause the compiler to hang?
13:53:31 <StoneToad> Ralith: because I thought about it the wrong way obviously :)
13:53:31 <cjenkin1> Ah, I see. The ! forces the Void argument to be evaluated, causing an error
13:53:49 <cjenkin1> (not at compile time)
13:54:27 <Fuuzetsu> not sure why it doesn't just ‚Äòdata Void‚Äô, that's Haskell 2010 right?
13:54:44 <Ralith> if you read the docs, it states that Haskell98 compat is an objective.
13:54:44 <StoneToad> Fuuzetsu: there's defines, it's < 700 GHC version
13:54:58 <StoneToad> otherwise it's newtype Void = Void Void
13:55:04 <Fuuzetsu> StoneToad: yes, my question holds though
13:55:44 <StoneToad> well, if you can just do data Void, why do you need to import anything?
13:55:44 <Ralith> I just answered your question -_-
13:56:13 <Fuuzetsu> ah, H98, thought that might be the case
13:57:27 <c_wraith> caseof: by the way, I wrote the article you mentioned above (types not tutorials) so if you have any questions about it, feel free to ask.
13:57:58 <Fuuzetsu> c_wraith: post link
13:58:19 <Fuuzetsu> nvm, got it
14:07:20 <caseof> c_wraith: Thanks!
14:08:54 <lpaste> worldsayshi revised ‚ÄúSimple Lens test fail‚Äù: ‚ÄúSimple Lens test fail (solved)‚Äù at http://lpaste.net/112590
14:09:27 <chrisdone> ja know what would be neat. making a demo web browser that could be scripted with haskell instead of javascript
14:09:41 <chrisdone> and it would sandbox in the same way lambdabot does
14:09:55 <chrisdone> (no unsafe imports, and a restricted Web monad or w/e)
14:10:51 <justin_smith> chrisdone: if they can compile java into js, they can compile ghc into js
14:11:00 <chrisdone> forget js
14:11:23 <justin_smith> pnacl is another option
14:11:24 <chrisdone> i'm just talking about haskell
14:11:50 <justin_smith> OK I was talking about a reasonable way to get a haskell compiler into a random browser
14:11:52 <doismellburning> cute idea, but I suspect metcalfe's law and friends will crush you
14:12:29 <chrisdone> ah, i forgot i joined #partypoopers
14:12:54 <chrisdone> where's a guy gotta go to get some excitable people around here?
14:13:01 * chrisdone misses ManateeLazyCat
14:13:06 <merijn> justin_smith: We already have three or so compilers compiling hs to JS :p
14:13:06 <justin_smith> chrisdone: if you compile to js, or use pnacl or something similar, it will run in a standard browser, and metcalfe isn't working against you
14:13:15 <justin_smith> merijn: figures!
14:13:42 <merijn> justin_smith: One of them supports all GHC extensions, threading, STM and a JS FFI \o/
14:13:52 <justin_smith> link? name?
14:15:08 <merijn> ghcjs
14:15:37 <caseof> c_wraith: I guess my question would be if it is possible to implement a DSL using (Mini)Operational that deal with more than one type? https://www.fpcomplete.com/user/chowells79/types-not-tutorials DSL basically deals with Int only in a given program.
14:15:40 <merijn> tbh, I've haven't really done anything with it yet, I'm just easily excited :)
14:17:05 <edyu_> for pattern matching, is it possible to pattern match on several data types the same time? for example, can I do Just (_ op) -> dosomething, and _ can be either Unary or Binary?
14:17:47 <geekosaur> no, you can't wildcard a constructor
14:18:00 <binary> my choice of nick might have been bad for this kind of channel.
14:18:01 <edyu_> ok, thanks geekosaur
14:18:18 <S11001001> binary: not as bad as lens
14:18:19 <jle`> decimal: base 10
14:18:22 <jle`> binary: base 2
14:18:26 <edyu_> it makes sense when you called it the constructor
14:18:27 <Fuuzetsu> geekosaur: couldn't you use a view pattern to marshall into a different type?
14:18:58 <geekosaur> Fuuzetsu, yes, that or several other tricks, but not a direct pattern match like that. I am not sure how deep into fancy stuff to go with that
14:19:25 <Fuuzetsu> sure
14:20:02 <edyu_> it just feels like bad code smell, when I do Just (A f) -> f x; Just (B f) -> f x
14:20:20 <iwasbinary> I dont know if this is the right place for me, but I'm totally new to haskell, but I have a growing interest for it. It seems that every time I talk to haskell users, they try to convert me.
14:20:28 <trap_exit> wtf
14:20:33 <trap_exit> -> is valid syntaxin haskell ?
14:20:34 <Fuuzetsu> edyu_: Just (view -> V x) ‚Ä¶ ?
14:20:37 <trap_exit> I thought there was only <-
14:20:45 <jle`> trap_exit: have you ever used a case statement?
14:20:49 <iwasbinary> Where should I begin? Is there a "right" way of learning haskell=
14:20:54 <jle`> iwasbinary: welcome :D
14:20:57 <trap_exit> jle` : ohh ; yes, I did not see the case part
14:20:59 <edyu_> Fuuzetsu: what does that mean? I don't understand view
14:21:06 <iwasbinary> Thank you! jle`
14:21:07 <jle`> iwasbinary: a lot of people suggest lyah
14:21:09 <jle`> @where lyah
14:21:10 <lambdabot> http://www.learnyouahaskell.com/
14:21:21 <jle`>  alernatively,  https://github.com/bitemyapp/learnhaskell has a lot of resources
14:21:21 <edyu_> @where rwh
14:21:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:21:28 <jle`> and is well maintained
14:21:44 * hackagebot chatter 0.4.0.0 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.4.0.0 (RoganCreswick)
14:22:03 <Fuuzetsu> edyu_: you make a new type such as ‚Äòdata V a = V a‚Äô and a function ‚Äòview :: YourType a -> V a‚Äô ‚Äòview (Unary a) = V a; view (Binary a) = V a‚Äô and turn on ViewPatterns
14:22:08 <c_wraith> caseof: it's certainly possible to create far more complex APIs with it.
14:22:12 <Fuuzetsu> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
14:22:14 <iwasbinary> Ah, thank you! jle`
14:22:23 <c_wraith> caseof: I just did an absolutely minimal thing in the example there.
14:22:29 <iwasbinary> I'll get right on that
14:22:45 <Fuuzetsu> edyu_: it basically allows you to apply a function inside the match which you can use to unify the underlying type into the value you need
14:22:50 <edyu_> thank u Fuuzetsu
14:23:07 <edyu_> it's amazing how deep type system can go lol there is almost always a way
14:23:10 <jle`> iwasbinary: if you do use rwh then keep in mind that some parts of it are a bit dated.  there should be an SO post detailing the main changes since it was written
14:23:23 <Fuuzetsu> well, it's not really a type system feature, it's more like sugar
14:23:41 <jle`> iwasbinary: also LYAH has a chapter using the `mtl` library that has notably been updated to a slightly incompatible api
14:23:49 <jle`> so be aware of that
14:23:50 <Fuuzetsu> it'd be the same as foo (Just x) = case view x of V a -> ‚Ä¶
14:24:08 <jle`> but other than that LYAH has aged fairly well
14:24:48 <iwasbinary> jle`: Okay, thanks, this seems like a very nice channel
14:25:06 <jle`> we try! :D
14:26:35 <c_wraith> caseof: More or less, you work by designing a GADT that contains the "primitive" operations in your custom monad, and then write an interpreter that converts those "primitive" operations into whatever you want to be doing.
14:26:45 * hackagebot binary-list 0.3.3.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.3.0 (DanielDiaz)
14:35:26 <mathu> i'm beginning to look at haskell and functional programming again. i read LYAH, and it was lovely, but i couldn't quite get comfortable with the functional paradigm. aside from rereading that, does anyone have any great resources in mind to suggest?
14:35:52 <josephle> @where RWH
14:35:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:36:02 <mathu> i thought people didn't like RWH
14:36:06 <kadoban> mathu: Personally I just read LYAH and real world haskell, going back and forth when I got bored/confused. You also have to practice
14:36:22 <jle`> mathu: i like https://github.com/bitemyapp/learnhaskell
14:36:28 <joseph07> mathu: https://github.com/bitemyapp/learnhaskell
14:36:30 <josephle> mathu: it definitely has some outdated code samples, but the concepts are still good
14:36:34 <kadoban> I liked it. Some people have some valid criticisms, but I still found it useful.
14:36:41 <joseph07> jle`: well played
14:37:06 <edyu_> mathu: i like both books but i ended up writing a lot of code while going through the books and I found i learn a lot more when i do pet projects
14:37:07 <josephle> bytemyapp's stuff is good too from what I hear
14:37:26 <jle`> it's mostly a link to nice courses presented in a reasonable order
14:37:31 <jle`> with some nice exercises
14:37:38 <mathu> edyu_: yeah, i tried several pet projects
14:37:42 <jle`> so if you like exercises, it's much better than LYAH/RWH
14:37:52 <mathu> irc bot was the only one i completed
14:37:53 <jle`> also in #haskell-beginners people just spend all day working through them so you are in good company
14:38:06 <mathu> and a card-game engine was where i got fed up :P
14:38:12 <mathu> alright, cool, i'll start lurking there
14:38:26 <jle`> if you're on an exercise in the courses in that bitemyapp guide, there's usually someone in #haskell-beginners working on the same one
14:38:32 <jle`> heh
14:39:29 <mathu> thanks all
14:39:53 <mathu> i was thinking about how i wanted to start learning rust, and somehow wound up trying haskell again isntead
14:40:42 <jle`> haha
14:42:22 <jle`> mathu: it happens more often than you'd think
14:42:22 <sbrg> anyone here use rlwrap for ghci? Because it's not working for me.
14:43:51 <mathu> i remember the semantics of haskell still, and understand eg currying, laziness, first class functions, algebraic data types... i'm missing the understanding of the actual FP paradigm, though, or rather how to design following it
14:44:35 <mathu> and i decided to try again over rust because i'm giving a quick talk in a month, and i can fill 10 minutes raving about haskell as it is but it'd be more honest if i actually understood FP
14:45:21 <kadoban> mathu: Ah yeah, you just need a lot of experience then. Kinda same boat I'm in on haskell I think.
14:45:26 <justin_smith> mathu: best thing is to make something non-trivial, hit the "how the fuck do I do this wall" a few times, come out the other side
14:46:00 <mathu> justin_smith: yeah, i wrote a lil IRC bot, but it was just hand-waving to me. and i tried to write a card-game engine for it, and that uhhhh didn't go so well
14:46:12 <mathu> i'm generally less dumb now though so i'm giving it another proper effort
14:46:34 <justin_smith> mathu: if you make a habit of repeatedly being slightly less dumb, amazing things could happen
14:46:51 <mathu> haha, that's the plan
14:51:34 <kadoban> Does ghc-mod work with cabal sandboxes? I'm guessing probably not, huh?
14:51:46 * hackagebot hakyll-agda 0.1.8 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.8 (FrancescoMazzoli)
14:55:31 <mgsloan> kadoban: Cabal 1.20 has the "exec" command to run binaries in the sandbox environment.  I haven't tried that with ghc-mod, but I imagine it would work
14:56:49 <kadoban> mgsloan: Hmm, right...trying to work out how to actually get syntastic and ghc-mod to work with my sandboxes...maybe I just need to mess with the syntastic settings
14:57:15 <latk> Is there some way to get a list of all the warnings generated when installing via cabal? Many of them seem to get lost in the compilation messages.
15:03:23 <sbrg> Anyone here use haskeline vi mode in ghci and notice the delay between hitting esc and 'normal mode' actually getting enabled?
15:04:57 <geekosaur> it's been suggested the delay might be a bit too long. unfortunately some delay is necessary
15:05:13 <geekosaur> it probably doesn't need to account for 300 baud modems though :p
15:06:31 <sbrg> geekosaur: Well, zsh has a similar delay in that if I hit esc, the 'cursor doesn't show it' so to speak until after, well, roughly the same delay as haskeline. the difference is that I can immediately perform 'normal mode' commands after hitting esc in zsh but not in haskeline. typing something before the delay puts me back into insert mode
15:08:43 <Fuuzetsu> geekosaur: why is some delay necessary?
15:09:01 <geekosaur> what's the ASCII code for an arrow key?
15:09:50 <geekosaur> specifically: there are no dedicated control codes for arrows, function keys, etc. and per ANSI X3.64 the sequences sent for all such keys start with esc
15:10:12 <sbrg> aaah.
15:10:23 <geekosaur> so you need a delay to figure out if it's part of an arrow key or standalone
15:10:27 <mauke> you can do zero-delay with speculative execution
15:10:35 <Fuuzetsu> if it's noticable then it's already too much of a delay‚Ä¶
15:10:43 <sbrg> I'm looking for the delay in the source code.. not quite able to find it
15:11:06 <Fuuzetsu> I doubt you'll ever have problems because you got mid-way between esc and special key‚Ä¶
15:11:08 <mauke> treat esc as esc, but if you see the codes for an arrow key within some short frame, roll back
15:11:32 <geekosaur> Fuuzetsu, not these days you won't. my comment about 300 baud modems was actually relevant though :)
15:11:45 <geekosaur> I used to confuse vi all the time
15:11:50 <cjheath> I implemented generalised (for any type of terminal, not just ANSI) keyboard escape sequence parsing in the80‚Äôs and 90s, using a trie - anytime there‚Äôs the alternative of a completion or a continuation ytuo need a small delay. If it‚Äôs noticable, it‚Äôs too long.
15:12:18 <cjheath> Es[ecially with xterms etc, the escape sequences all arrive at the same time‚Äù modulo kernel races
15:12:21 <geekosaur> but yes, it does sound like haskeline is using a very simplistic key parser and handling exceptions badly
15:12:29 <cjheath> you can wait 1ms and get reliable parsing
15:12:53 <mauke> cjheath: unless ssh
15:13:10 <cjheath> eve then - ssh reads the bytes all at once, sends them in a single packet
15:13:19 <geekosaur> you hope
15:13:21 <cjheath> *almost always* :)
15:13:21 <merijn> cjheath: You don't know that
15:13:31 <mauke> I've had issues with vim over ssh
15:13:41 <mauke> special key codes getting split and such
15:14:09 <jle`> really?
15:14:14 <cjheath> IIRC we implemented a default of 100ms
15:14:16 <geekosaur> yes
15:14:30 <FireFly> I belive this wouldn't be a problem if the C0 CSI (\xB2 or something) would be used instead of ESC [
15:14:38 <cjheath> anything above 200ms is too noticable
15:14:51 <FireFly> Because then an Esc would always be an Esc
15:15:02 <cjheath> below 70ms it‚Äôs practically undetectable
15:15:35 <geekosaur> thing is, ssh does not read the bytes all at once, it has the tty/pty in single character mode (experiments with using vmin tend to lead to unfortunate failure modes)
15:15:59 <sbrg> I really just want to find the delay in the source code, rebuild haskeline and the rebuild ghc against my own version
15:16:07 <cjheath> the 70ms number corresponds to 14 Hz, which (not entirely incidentally) is the maximum rate at which separate drum-strokes are detectable in percussion
15:16:15 <geekosaur> also vmin > 1 doesn't work well because vtime is in seconds
15:16:15 <Fuuzetsu> it still seems better to rarely get a wrong key due to key split rather than having a constant noticable delay
15:16:34 <sbrg> ^
15:16:46 <mauke> I believe vim does the speculative execution thing
15:16:50 <cjheath> SSH should implement a short delay when it sees Escape from a tty device, that‚Äôd fix it
15:17:03 <Fuuzetsu> in Yi there's a comment in-source from a vim user complaining that 100ms delay from ESC to mode switch is too annoying and too noticable
15:17:11 <Fuuzetsu> I don't know how anyone could live with 200ms
15:17:12 <sbrg> it seems zsh is doing the right thing. If I'm not hitting something that can be composed into some fancy control sequence during the delay, it isn't ambiguous what I'm trying to do
15:17:22 <FireFly> geekosaur: I'm pretty sure ECMA-48 (aka ANSI X3.64) specifies a single-octet CSI, though I'm not sure if it requires the two-character one to be used for encoding keypresses..
15:17:38 <geekosaur> there is one, but it's rarely used
15:18:06 <mauke> vim also has a mode where it completely disables the timeout and you have to hit esc twice
15:18:28 <cjheath> I believe Vim also has a mode where ~ is used
15:18:31 <FireFly> vim also barfs on control sequences it doesn't recognize :\
15:18:50 <geekosaur> you go convince all the terminal emulators to use 0x9b instead of ESC [ in all cases
15:19:10 <Fuuzetsu> brb convincing everyone ever
15:19:23 <geekosaur> (I'm so surprised I remembered that one at all, I had to double check)
15:19:28 <mauke> you also need to change all terminfo entries
15:19:34 <geekosaur> (which indicates about how often it's ever seen in the wild)
15:21:16 <FireFly> Well, if terminal applications would treat 0x9B properly (AIUI they don't in general, at least not vim) then at least an individual user could decide to configure their terminal emulator to use 0x9B and therefore get a more pleasant experience
15:21:44 <cjheath> Switching CSI doesn‚Äôt really help - just moves the problem - keycodes should be OOD
15:21:47 <cjheath> OOB
15:22:07 <mauke> terminal applications can't assume ANSI :-)
15:22:21 <cjheath> These days, most can and do
15:22:27 <merijn> Fuuzetsu: Oh god yes, 100ms is too much...vim over transatlantic SSH is already no fun :(
15:22:33 <mauke> and terminfo only allows a single string for each key
15:23:41 <geekosaur> I think assuming ANSI is reasonable these days. I didn't cry much when I consigned my last real terminal to a dumpster (and even then it was a vt420...)
15:24:50 <Fuuzetsu> merijn: well, personally I don't use vim but I'm of the opinion that no matter what, you should edit locally and only send the changes over once you save
15:25:18 <merijn> Fuuzetsu: That's not always workable
15:25:19 <Fuuzetsu> editors can make this transparent-ish (tramp)
15:25:22 <Fuuzetsu> why?
15:25:28 <Fuuzetsu> if you have ssh then it's workable
15:25:43 <merijn> Fuuzetsu: For example, I use syntastic to error check my files, but I can't compile on my machine
15:26:02 <sbrg> Any of you wizards have an idea what I should be looking for in haskeline's code to find the source of the delay?
15:26:03 <merijn> Fuuzetsu: So I run vim on the machine that *can* compile so I get error checking while editing
15:26:14 <cjheath> Who needs to see the result of every keystroke immediately anyhow? I just don‚Äôt want my keystrokes misinterpreted
15:26:28 <Fuuzetsu> merijn: sounds lame, trading whole local setup for syntastic
15:26:45 <icy3ragonsigh> hello.
15:26:53 <cjheath> and as for needing continuous compilation to avoid typing the wrong program, where there‚Äôs your problem right there.
15:27:43 <icy3ragonsigh> wopuld anyone desire to develop a social ecommerce platform prototype?
15:27:54 <icy3ragonsigh> *would
15:28:15 <mauke> ew
15:28:17 <sbrg> that's never been done before
15:28:19 <cjheath> another one?
15:28:24 <sbrg> that's revolutionary, man!
15:28:53 <cjheath> Do you have a new concept?
15:28:55 <Fuuzetsu> what's a social ecommerce platform? facebook with ads?
15:29:02 <Fuuzetsu> store with comments?
15:29:07 <mauke> acebook with fads?
15:29:32 <carter> boht?
15:30:40 <Fuuzetsu> http://www.forbes.com/sites/nicoleleinbachreyhle/2014/08/12/soldsie-social-shopping-services-announces-new-advances/ the first photo here is the poorest attempt at censoring I've seen in a long time
15:31:44 <mauke> http://blogs-images.forbes.com/nicoleleinbachreyhle/files/2014/08/SoldsieScreenShot-922x1940.jpg
15:31:59 <Fuuzetsu> thanks, I tried getting that link
15:32:09 <icy3ragonsigh> i was thinking of something that banked on combining instragram product photos with someone's facebook network, linkedIn profile and whatever social media, their own store url if they have one, an ebay/amazon taxonomy and SEO wizard to sort and categorize products, faceted search, ranks, ratings and review system, drones (which go pubic in 2015), mobile pay solutions like iPay, and store qtc codes/avatars like those popular
15:32:09 <icy3ragonsigh> in asia.
15:32:35 <mauke> you sound like an idea guy
15:32:43 <icy3ragonsigh> girl :3
15:32:56 <Fuuzetsu> ‚Äúthrow all the things I can think about into one!‚Äù
15:32:57 <icy3ragonsigh> i prototype in axure but don't code...
15:33:14 <merijn> Fuuzetsu: "my whole local setup", my entire setup is commandline anyway
15:33:20 <icy3ragonsigh> yes!! but efficiently good design..
15:33:24 <sbrg> well, I have no idea where to look for the delay <.<
15:33:25 <sbrg> meh.
15:33:36 <merijn> Fuuzetsu: The only thing I lose by running over SSH is the shared clipboard between vim and my local OS and I have plans to fix that
15:33:50 <mauke> I like the pubic drones part
15:34:28 <justin_smith> mauke: that should go over well in Japan
15:35:00 <icy3ragonsigh> i read about them today.  http://www.businessinsider.com/commercial-drones-will-disrupt-the-retail-and-e-commerce-industries-first-2014-4
15:35:12 <merijn> Fuuzetsu: Without syntastic it my error checking loop gets much slower, it's C++ so checking for errors/warnings is fairly critical and running a full compile is too slow
15:35:19 <Fuuzetsu> icy3ragonsigh: what makes you think trying to pitch your‚Ä¶ ‚Äòidea‚Äô is good to do in this particular channel?
15:35:40 <sbrg> icy3ragonsigh: i'm confused. so you have instagram for product photos, the owner's facebook network and linkedin profile, their own store url .. for the products as well? and ebay/amazon stuff? .. wut
15:35:53 <sbrg> who are the people you are targeting for this? people who have their fingers in *everything*?
15:36:07 <Fuuzetsu> sbrg: and you're integrating something that he/she/it read about today!
15:36:09 <icy3ragonsigh> wild long shot. i took a risk. like fishing..
15:36:11 <Fuuzetsu> is that bleeding edge or what
15:36:22 <cjheath> ewwww, pubic drones. I don‚Äôt even‚Ä¶
15:36:24 <orb__> sbrg, sounds like something out of dilbert.
15:36:42 <icy3ragonsigh> :)
15:36:45 <sbrg> it's like the entire internet at once on one website.
15:36:48 * hackagebot llvm-general-quote 0.2.0.0 - QuasiQuoting llvm code for llvm-general  http://hackage.haskell.org/package/llvm-general-quote-0.2.0.0 (TvH)
15:36:50 * hackagebot helics 0.5.0.1 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.5.0.1 (HirotomoMoriwaki)
15:36:52 <orb__> icy3ragonsigh, sorry, Haskell can't be used for anything practical.
15:36:53 <sbrg> my brain would probably explode
15:37:18 <sbrg> imagine the ad revenue you could rake in, though! all those companies would pay you to display their ads on your site!
15:37:19 <cjheath> If it succeeded, it‚Äôd probably violate the TOS of linkedin or facebook or ...
15:37:31 <icy3ragonsigh>  i work for the financial digital industry doing interface design for fraud systems. my brain explodes often.
15:37:32 <Fuuzetsu> orb__: he'd probably get better replies if he came in here saying ‚ÄòI bet Haskell can't even do <this thing>, what a useless language‚Äô
15:37:44 <mauke> *she
15:37:46 <sbrg> cjheath: it would violate The Holy Agreement between Heaven and Hell and you would suffer cosmic justice
15:37:54 <orb__> Fuuzetsu, people would have coded her up some prototypes to prove it's possible.
15:38:21 <sbrg> .. wait, you guys aren't already working on your prototypes for that concept? <.<
15:38:30 * sbrg puts away his editor
15:38:37 <jhance> I bet Haskell can't even solve the halting program, what a useless language
15:38:38 <icy3ragonsigh> I bet Haskell can't even do <bestPornUXEver>
15:38:42 <orb__> sbrg, mine runs in the type system.
15:39:20 <orb__> jhance, I have solved the halting problem for a variety of languages.  I am particularly fond of the regular expression version.
15:39:30 <sbrg> I have a very early prototype for you, icy3ragonsigh. Bare with me, it's, like, really early. But just try to picture the possibilities.
15:39:30 <icy3ragonsigh> i always wanted to improve the IA of porn sites, the lack of useful search filters drive me nutty.
15:39:33 <sbrg> Here it goes:
15:39:38 <sbrg> main = return ()
15:39:41 <mauke> I do not wish to "bare" with you
15:39:55 <jhance> main :: [String]
15:39:56 * icy3ragonsigh waits patiently
15:40:06 <jhance> actually scratch that, main :: String
15:40:07 <ReinH> mauke: not ursine enough?
15:40:08 <sbrg> yeah, that was an unfortunate typo and not meant as sexual harassment.
15:40:13 <jhance> your prototype is no longer valid
15:40:19 * icy3ragonsigh puts on music
15:41:16 <icy3ragonsigh> i can either do profit sharing or hit up developers in 3rd world countries
15:41:30 <orb__> Why not both?
15:41:38 <sbrg> do all the things.
15:41:41 <icy3ragonsigh> good!
15:41:45 <sbrg> that's what you were already doing anyway.
15:41:46 <merijn> ok, why is this typical nonsense still going on?
15:42:23 <orb__> merijn, feeding the troll.
15:46:48 * hackagebot jwt 0.4.2 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.2 (StefanSaasen)
15:53:00 <mgaut72> I have a recursive data type, and want to fold over it.  I have `foldMyType :: (a -> MyType -> a) -> a -> [MyType] -> a` already defined.  What is best practice for declaring a Foldable or Functor instance?
15:54:23 <YurasS> @hoogle Foldable
15:54:25 <lambdabot> Data.Foldable module Data.Foldable
15:54:25 <lambdabot> Data.Foldable class Foldable t
15:54:25 <lambdabot> package mono-foldable
15:54:46 <YurasS> > :i Foldable
15:54:48 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
15:54:52 <merijn> mgaut72: MyType can't be a Functor or Foldable there, since it has the wrong kind
15:55:33 <mgaut72> merijn: I don't exactly follow
15:55:44 <YurasS> how to get info for typeclass from lambdabot? ^)
15:56:00 <merijn> mgaut72: Functor and Foldable are classes for types of "* -> *", your "MyType" has kind *
15:57:23 <mgaut72> ok, so I guess what I want is a special way to fold a list of MyType, that is not the standard "foldl"
15:57:29 <YurasS> mgaut72: try mono-foldable package
15:58:08 <YurasS> it is for kind *
15:58:31 <merijn> I dislike mono-foldable
15:58:43 <merijn> Might as well just define "foldMyType" like you already have
15:58:47 * YurasS too
15:59:21 <merijn> Or, if you plan to rely on qualified imports, use "import qualified Blah.MyTypeModule as MyType" and use "MyType.fold" as function name
15:59:41 <mgaut72> then, since this "foldMyType" isn't exactly the "standard" fold for [MyType] should I just not declare and instance of anything?
16:00:41 <YurasS> mgaut72: ah, you are folding over list
16:00:49 <YurasS> not MyType
16:01:21 <josephle> can you elaborate on why your fold is not "standard"?
16:01:32 <mgaut72> YurasS: yes, I wrote the typesignatue of what I had previously.  for reference it was `foldMyType :: (a -> MyType -> a) -> a -> [MyType] -> a`
16:01:40 <merijn> :t foldl
16:01:41 <lambdabot> (b -> a -> b) -> b -> [a] -> b
16:01:56 <merijn> Looks like it should be you fold?
16:02:11 <YurasS> mgaut72: you don't need any instance then
16:02:14 <mgaut72> josephle: my fold is not standard because MyType is a recursive type
16:02:33 <YurasS> just use instance Foldable List
16:02:33 <mgaut72> data MyType = T1 Foo MyType | Bar
16:02:34 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
16:03:05 <mauke> that's a list
16:03:11 <mauke> [Foo]
16:04:02 <mgaut72> mauke: its actually more like `data MyType = T1 Foo MyType | T2 Foo Foo Bar | T3 Zap Foo | Bar`
16:04:03 <phaskell> T3: Move wiki mysql to mysql01 - https://phabricator.haskell.org/T3
16:04:03 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
16:04:07 <mgaut72> I was just trying to simplify
16:04:45 <mgaut72> oops, I goofed.  pretend T1, T2, T3 all have some "recursive" component ie. a MyType
16:05:50 <josephle> hmm, but couldn't you do the fold over MyType in the (a -> MyType -> a) argument?
16:06:22 <mgaut72> josephle: yes, but then my combining function gets tedious, and it would always be handling the recursive type the same, regardless
16:07:41 <josephle> you can just have another function MyFold that folds over MyType, then use in in a fold over [MyType]. Shouldn't hurt readability :)
16:10:25 <mgaut72> thanks.  Ill have to think about the best route forward once I have all my use cases defined, but I appreciate the advise
16:15:45 <Denommus> in a Gtk2Hs + Glade project, how do I deploy the xml with the binary, and how to make the binary read the xml in a relative path to it?
16:21:50 * hackagebot haskell-awk 1.1 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.1 (gelisam)
16:23:06 <vanila> Does anyone know a good IRC channel for people interested in creating and implementing programming languages?
16:23:16 <vanila> @messages
16:24:06 <johnw> vanila: there should really be a PL channel
16:24:16 <johnw> we could start ##plt
16:24:25 <josephle> only if that channel has this in the topic: http://colinm.org/language_checklist.html
16:25:04 <merijn> johnw: I'm in favour :)
16:25:13 <johnw> ok, come join me :)
16:25:20 <merijn> johnw: btw, how's your vim to emacs switch working out, still happy with it?
16:25:29 <johnw> did I switch from vim???
16:25:50 <merijn> johnw: oh, wait, I think I'm confusing you with someone else from OPLSS >.>
16:25:54 <johnw> yeah
16:26:19 <FireFly> vanila: #proglangdesign exists
16:26:30 <FireFly> though it's usually pretty quiet and quite small
16:26:52 <Sorella> > [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed
16:26:55 <lambdabot>  <hint>:1:10: parse error on input ‚Äòtype‚Äô
16:27:00 <vanila> thanks!
16:27:03 <Sorella> I would like to understand what makes people create those kinds of language TODAY
16:27:36 <merijn> Sorella: They don't know better
16:27:49 <Sorella> Well, Dart people should know better =/
16:28:06 <merijn> Sorella: Look at Erlang, Joe Armstrong has mentioned that the only reason it's not statically typed is because he didn't know about type systems when he started
16:28:07 <Sorella> Though I don't think anyone in their team cares about type systems
16:28:51 <trap_exit> what does haskell need to achieve until haskell users believe that haskell > erlang for writing distributed code
16:28:59 <Sorella> Didn't know that. I always assume people make untyped languages because "it's easier!"
16:29:05 <kvanb> trap_exit: lol
16:29:06 <merijn> trap_exit: I already believe haskell is about equal to erlang
16:29:17 <kvanb> distributed-process has very few "big examples"
16:29:19 <kvanb> its hard to start
16:29:20 <trap_exit> merijn: hmm, with cloud haskell ?
16:29:23 <kvanb> I'm trying *right now*
16:29:25 <kvanb> ;_;
16:29:25 <merijn> trap_exit: Haskell has nicer syntax, a type system and high quality IO subsystem
16:29:26 <kvanb> its painful
16:29:42 <merijn> trap_exit: Erlang has a nicer async exception monitoring model and hot swappable code
16:29:51 <merijn> plus a nice library ecosystem in OTP
16:29:59 <kvanb> haskell is twice as fast
16:30:05 <trap_exit> merijn: yeah, I don't think haskell isever goign to hit the hot swappable level; but I'd like OTP + exception handling
16:30:07 <kvanb> at least.
16:30:43 <Sorella> Well, the Erlang VM isn't really optimised for raw speed, is it?
16:30:43 <josephle> failure/exception propagation in erlang is very nice
16:31:22 <trap_exit> I'd like Haskell forkIO threads to ahve per-thread heaps
16:31:26 <trap_exit> that'd make me happy
16:31:50 <merijn> Sorella: Erlang is optimised for throughput
16:32:01 <kvanb> trap_exit: I thought they did
16:35:33 <merijn> kvanb: No
16:35:47 <merijn> Although I'm pretty sure there's a per-thread nursery?
16:39:22 <kvanb> merijn: whats the downside of per thread heaps?
16:39:25 <felixn> weird idea for a haskell code editor: what if code floated around, and when you're working on a function, all statically related appears to the right ... the sort of my haskell source files feels very arbitrary ... since I'm stating things instead of writing a sequence of instructions
16:39:46 <vanila> cool idea felixn!
16:39:53 <carter> kvanb: thrres per thread capability nurseries
16:40:19 <AshyIsMe> yeah that's a pretty cool idea
16:40:19 <peddie> http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/31/slides/simon.pdf (about Haxl) refers to some form of hot code swapping using GHC's built-in linker
16:40:20 <trap_exit> felixn: you mean like light table?
16:40:40 <AshyIsMe> so you get the ghc-mod type lookups automatically as you move your cursor around
16:40:49 <trap_exit> I think there's an easy way to do hot code swapping in haskell
16:40:56 <trap_exit> per thread heap + easy to kill / start threads
16:41:02 <trap_exit> then you write a new thread, type check it, and switch it
16:41:08 <trap_exit> and threads only talk via messag epassing
16:41:14 <felixn> I'm imagining a mathematica style editor, where it feels less like a text editor, and you have to add a new block ... also I'd imagine copious use of "jump to"
16:41:30 <merijn> felixn: If you wanna see "neat prototypes for completely different editors" check out lamdu
16:41:31 <carter> trap_exit: thats just called "each thread is a different haskell process"
16:41:32 <carter> :)
16:41:38 <felixn> trap_exit: I saw a demo early on where related code would show up ... but it feels mostly like vaporware
16:41:43 <trap_exit> carter: yes, but cheaper, hopefully
16:41:43 <carter> kvanb: did you wind up trying courier?
16:41:55 <merijn> felixn: https://github.com/peaker/lamdu
16:41:56 <kvanb> yeah
16:41:57 <carter> trap_exit: depends on the work load
16:42:04 <kvanb> I wrote pipes bindings too
16:42:05 <carter> and how long you can wait till you can do it
16:42:11 <kvanb> and fusion rules for them
16:42:12 <felixn> merijn: holy poop, that looks insane
16:42:22 <carter> i miss peaker
16:42:37 <kvanb> what happened to peaker
16:42:47 <carter> he's not been on irc in a while :)
16:42:50 <merijn> felixn: I saw a demo last year at IFL, the UI is pretty neat already. It doesn't actually do any code generation, but the type checking and inferrence, etc worked
16:42:51 <carter> i've seen him on twitter i guess
16:43:01 <merijn> He started a new job at IBM, I think?
16:43:05 <kvanb> ok, thats better than what I expected you to say
16:43:06 <kvanb> lol
16:43:23 <carter> merijn: israel office or something?
16:43:24 <kvanb> you made it sound like he died kind of
16:43:26 <kvanb> ;_;
16:43:26 <carter> nope
16:43:29 <trap_exit> hmm
16:43:30 <carter> kvanb: you died
16:43:31 <carter> :)
16:43:34 <trap_exit> that looks like haskel + lsd
16:43:37 <felixn> merijn: nice, I tried to make a haskell source visualizer way back, but I couldn't really figure out the GHC api, felt like I had to reimplement all the static analysis
16:43:56 <kvanb> please
16:44:03 <kvanb> quote+ what trap_exit just said under "lambdu"
16:44:17 <felixn> lol
16:44:50 <felixn> I use sublime text + terminal right now, and it really blows for debugging ... makes me daydream
16:44:53 <trap_exit> the problem I see with somethign like lambdu, is that I don't thikn it's as concise
16:45:03 <trap_exit> i.e. the entire screen shot, is like 4 lines of haskell code if one didn't have the fancy graphics
16:45:13 <kvanb> I use sublime text and terminal too
16:45:16 <kvanb> works well enough
16:45:30 <trap_exit> I use emacs + eshell
16:45:34 <kvanb> can get real fancy with ligatures in atom.io
16:45:42 <kvanb> but atom.io lags too freaking much to use it for real coding still
16:46:11 <kvanb> carter: I looked at ekg
16:46:21 <carter> oh?
16:46:22 <carter> and?
16:46:26 <carter> st3 ftw
16:46:32 <kvanb> its absolutely what we need at work
16:46:32 <felixn> I'm using doctest as my repl, it's ok ... but I'm building a compiler right now, and it's getting really confusing and I keep zoning out
16:46:36 <kvanb> just need some extra functionality
16:46:47 <vanila> felixn, What kind of compilerar you writing? :)
16:46:50 <kvanb> like the ability to make "lists" and click on them and view whats inside that particular client or whatever
16:46:59 <kvanb> kind of inspires a new library ...
16:47:06 <kvanb> but I can't be bothered to make it
16:47:46 <kvanb> carter: because we want to see how many requests from some particular client you see
16:47:53 <kvanb> and send an event back to the server from the web interface
16:47:55 <kvanb> like "kick"
16:48:08 <carter> cool
16:48:09 <felixn> vanila: prototyping a little language .. it's kind of weird, but testing out a language feature
16:48:20 <carter> kvanb: thats the nicest thing i've ever heard you say about someone elses code!
16:48:37 <kvanb> awww really
16:48:42 <carter> yup
16:48:44 <kvanb> i feel all warm and fuzzy now
16:48:47 <carter> good
16:48:56 <kvanb> in general I like tibells code
16:49:06 <vanila> felixn, That's cool! Ive been learning about writing compilers recently
16:49:08 <kvanb> tibbel
16:49:09 <kvanb> I tried.
16:49:12 <carter> kvanb: i've been writing some evil haskell codes this past 2 days
16:49:13 <vanila> do you have a blog or something?
16:49:27 <kvanb> evil haskell D:
16:49:43 <carter> https://github.com/cartazio/HetList/blob/master/HetList.hs
16:49:50 <carter> generalizing overloaded list syntax
16:50:01 <taktoa_> those pragmas.
16:50:03 <merijn> Evil haskell is my favourite haskell :D
16:50:06 <felixn> haha dat pragma
16:50:07 <kvanb> holy crap
16:50:09 <kvanb> that is the most
16:50:09 <kvanb> pragma
16:50:12 <kvanb> I have seen in my life
16:50:18 <merijn> taktoa_: Learn to love {-# LANGUAGE KitchenSink #-}
16:50:22 <carter> really?
16:50:53 <merijn> carter: Seems like the normal amount of pragmas to me ;)
16:50:56 <carter> yeah
16:51:05 <carter> i was trying to do only 2-3
16:51:06 <Enigmagic> looks normal to me, except i like to sort mine ;-)
16:51:12 <carter> but then ghc kept asking for me
16:51:18 <merijn> Enigmagic: Alphabetically? :D
16:51:20 <kvanb> I feel like
16:51:20 <carter> Enigmagic: would this work for your llvm-general-typed notations?
16:51:23 <Enigmagic> merijn: yep
16:51:31 <kvanb> haskell would be a whole lot cooler if instances could overlap by default
16:51:35 <kvanb> and were chosen in specifivity order
16:51:38 <merijn> Enigmagic: Same here :)
16:51:43 <carter> kvanb: theres stuff in HEAD for allowing something like that
16:51:55 <carter> where you can choose the matching trial order
16:51:56 <kvanb> I got blown over the other day on that ticket for random
16:52:00 <kvanb> because I thought it already did that!
16:52:08 <kvanb> I swear, I've done something like it before.
16:52:09 <carter> what for random/
16:52:21 <kvanb> when I proposed Bounded a, Enum a => ...
16:52:21 <Enigmagic> nice and sorted https://github.com/alphaHeavy/llvm-general-typed/blob/master/llvm-general-typed-pure/src/LLVM/General/Typed/Instructions/GetElementPtr.hs#L1
16:52:28 <kvanb> for that default random instance
16:53:06 <carter> kvanb: if you newtype wrapp the a, i think hyou could get that ok'd
16:53:19 <carter> Enigmagic: is there any hlisty stuff in your code?
16:53:28 <carter> struct element?
16:54:13 <Enigmagic> carter: just structs yeah
16:54:15 <kvanb> carter: we don't have much like that though
16:54:25 <carter> kvanb: nopes we totes do for monoid
16:54:27 <carter> sum an dproduct
16:54:39 <kvanb> oh and I guess there's Down too
16:54:49 <kvanb> > sort $ Down [1..5]
16:54:52 <lambdabot>  Couldn't match expected type ‚Äò[a]‚Äô
16:54:53 <lambdabot>              with actual type ‚ÄòData.Ord.Down [t0]‚Äô
16:55:01 <kvanb> uhh, needed a map
16:55:02 <kvanb> forget it.
16:55:17 <carter> Enigmagic: wheres struct stuff live?
16:55:29 <kvanb> > sort $ map Down [1..5]
16:55:31 <lambdabot>  [Down 5,Down 4,Down 3,Down 2,Down 1]
16:55:44 <jle`> omg
16:55:55 <jle`> hm
16:56:05 <jle`> i would just do sortBy (flip compare)
16:56:06 <kvanb> > sortBy (comparing Down) [1..5]
16:56:07 <jle`> but
16:56:09 <lambdabot>  [5,4,3,2,1]
16:56:23 <kvanb> thats more effecient
16:56:52 <kvanb> I would be happier if it read like a query language though
16:56:59 <kvanb> sortBy (comparing Asc) :: id
16:57:04 <kvanb> sortBy (comparing Desc) etc
16:57:19 <Enigmagic> carter: it just uses regular records
16:57:28 <jle`> that'd be cute
16:58:20 <mgaut72> :t comparing
16:58:21 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
16:58:22 <carter> kvanb: so you like lense?
16:58:33 <kvanb> lens has too much runtime overhead
16:58:35 <kvanb> I dont use it
16:58:38 <jle`> it does?
16:58:44 <jle`> whaaaa
16:58:54 <jle`> i thought it all basically compiled/inlined down to the same thing
16:58:59 <kvanb> sometimes, sometimes not
16:59:01 <kvanb> depends on the code around it
16:59:09 <carter> jle`: i tend to not believe things  till someone shows me benchmarks
16:59:10 <jle`> that sounds unideal
16:59:22 <jle`> i tend to believe everything i read
16:59:24 <carter> i know david f gives me benchamrks
16:59:34 <carter> jle`: you owe me 50,000 dolloars
16:59:35 <carter> bam
16:59:36 <carter> :)
16:59:39 <carter> hows grad school?
16:59:40 <jle`> sounds legit
16:59:43 <kvanb> I dont know about benchmarks, but I know it looks shit in the core even after -O2 sometimes
16:59:56 <jle`> it's ok, in my multivariate statistics class now
16:59:56 <Enigmagic> carter: actually nevermind, i forgot about Struct  https://github.com/alphaHeavy/llvm-general-typed/blob/4f847dc967a7b9ff0cc86aa6bf82c2f1961766e6/llvm-general-typed-pure/src/LLVM/General/Typed/Value.hs#L34
16:59:59 <kvanb> and I have ocd about my core tyvm
17:00:08 <jle`> it's probably easier if i just don't log onto the computer in front of me
17:00:31 <carter> kvanb: you should collab with david f
17:00:39 <kvanb> whosthat
17:00:43 <carter> Enigmagic: yeah, but thats not got any witness values
17:00:43 <kvanb> oh defuer
17:00:44 <kvanb> guy
17:00:45 <carter> yes
17:00:52 <carter> Enigmagic: so tis easy right?
17:01:02 <kvanb> I admire what he does
17:01:05 <kvanb> I couldn't do what he does.
17:01:10 <carter> kvanb: you totes could
17:01:12 <sbrg> Any ghcmod-vim users here? I'm getting some strange error about it not understanding the -g flag as a command which is clearly documented
17:01:56 <Enigmagic> carter: Struct is just a specialized Proxy
17:01:59 <carter> yeah
17:02:12 <Enigmagic> it also doesn't need to be Typeable anymore.
17:02:17 <kvanb> idk how busy tibbe is but he should make ekd-dash
17:02:24 <kvanb> then I would buy him lots of beer
17:04:35 <carter> whats the -dash do?
17:06:27 <kvanb> carter: lets you fire events from the web interface back to the server
17:06:41 <carter> why can't you wriite it?
17:07:01 <kvanb> already writing other things which I dont want to stop
17:07:16 <carter> fair
17:07:35 <Enigmagic> carter, you sure you don't want to start working on EKG right now? ;-)
17:07:37 <kvanb> I have a library for putting an advanced haskell server type thing together
17:07:39 <kvanb> like lego
17:07:47 <carter> Enigmagic: if someone paid me sure
17:07:49 <kvanb> but for binary protocols like game servers and stuff
17:07:53 <AshyIsMe> felixn: i mocked this up manually in vim: http://i.imgur.com/hAEfKfa.png
17:08:03 <carter> Enigmagic: you know i've income fretting on the brain
17:08:24 <Enigmagic> carter: i was joking :P
17:08:35 <AshyIsMe> left is the code, right is the "explorer buffer" that would dynamically show a bunch of useful inforamtion about the curent definition the function is in
17:08:36 <kvanb> AshyIsMe: looks like the idris interactive prompt
17:08:46 <kvanb> kinda
17:09:39 <felixn> AshyIsMe: are ">>" errors?  that's already more sophisticated than what I have!
17:09:48 <AshyIsMe> implementing it for real would be a bit of a rabbit hole im sure but you could probably get pretty far with some vimscript calling ghcmod and tags functionality
17:09:53 <kvanb> carter: bye
17:10:06 <carter> ok
17:10:07 <AshyIsMe> felixn: syntastic
17:11:17 <AshyIsMe> ghc-mod and syntastic make working in haskell with vim quite nice
17:11:27 <felixn> AshyIsMe: yea too much work now, but I can think about it!  it would be cool if the right side followed your cursor
17:12:35 <AshyIsMe> yeah
17:13:03 <AshyIsMe> oh i use codex too to generate tags for all the libraries im using
17:13:19 <AshyIsMe> so i can basically put my cursor on anything and hit Ctrl-] to jump to it's definition
17:13:31 <carter> Enigmagic: is there any sort of standard lock / mutex in modern C?
17:13:39 <carter> or do i have to cry and roll my onw?
17:13:47 <felixn> man I need xzibitz to pimp my editor
17:13:59 <merijn> carter: C++ ok?
17:14:04 <carter> nope
17:14:08 <carter> actually i literally cant
17:14:11 <carter> for this use case
17:14:18 <merijn> carter: Oh, actually, with just C you might still be fine
17:14:23 <merijn> carter: Check out stdatomic.h
17:14:28 <carter> umm
17:14:34 <AshyIsMe> and ghc-mod allows me to put my cursor on something and hit <leader>ht  (mnemonic for Haskell Type) and it shows me what ghc thinks it's type is
17:14:36 <carter> does any version of clang / gcc ahve it?
17:14:46 <merijn> carter: stdatomic.h is c11
17:14:49 <AshyIsMe> <leader>hT  - does the same thing but inserts it into the code for me
17:14:55 <merijn> carter: So recent gcc/clang should have it
17:15:20 <felixn> AshyIsMe: is there anyway to get all this goodness without setting things up?!  I literally only have highlighted text, it's mondo lame
17:15:34 <felixn> I just want to install an editor and go
17:15:57 <carter> merijn: nope
17:15:57 <orb__> AshyIsMe, what's <leader>?
17:15:57 <carter> https://gcc.gnu.org/wiki/C11Status
17:16:10 <carter> " Threading [Optional] Library issue (not implemented) "
17:16:15 <AshyIsMe> felixn: unfortunately no, vim (and emacs) both have a steep learning curve
17:16:36 <AshyIsMe> so it'll take you a good week to get going properly, and then you'll be improving your setup for months
17:16:47 <ReinH> "week" "months"
17:16:48 <merijn> carter: Threading is optional, stdatomic is not
17:17:03 <carter> merijn: but stdatomic doesn't give me a mutex
17:17:05 <merijn> carter: _Atomic and stdatomic.h are listed as being in 4.9
17:17:11 <AshyIsMe> orb__: <leader> is a vim thing. it's a way to set up user defined bindings without clobbering the default bindings.  i have my leader bound to <space>
17:17:12 <carter> yes
17:17:14 <carter> but those aren't a mutex
17:17:21 <ReinH> Those are optimistic lower bounds ;)
17:17:31 <merijn> carter: Should be fairly easy to write one using CAS on an int, no?
17:17:35 <carter> merijn: no
17:17:37 <carter> i'm not doing that
17:17:39 <felixn> AshyIsMe: xmonad+vim used to be my primary setup, but then I switched to mac now I'm all clicky ... I see there's a SublimeHaskell library that I'll check out
17:17:50 <carter> merijn: i have enough other stuff i need to do
17:17:51 <merijn> carter: Ok, then no
17:17:54 <carter> pthread mutexes it is
17:18:32 <ReinH> felixn: you might try https://github.com/begriffs/haskell-vim-now
17:18:38 <AshyIsMe> felixn: im on a mac, it's perfectly fine for typing goodness!
17:18:46 <ReinH> I haven't used it but it's pretty similar to my setup
17:18:47 <AshyIsMe> iTerm2, tmux, vim
17:18:48 <felixn> does anyone have a doctest plugin into their editor that shows inline results?
17:18:53 <felixn> that would be awesome
17:18:59 <orb__> AshyIsMe, thanks.
17:19:08 <merijn> AshyIsMe: Is there any compelling reason to use iTerm2 over Terminal.app?
17:19:42 <AshyIsMe> i can't remember what my reason was, something to do with colors or fonts, or maybe certain keys not working in Terminal.app
17:20:12 <AshyIsMe> i don't use any of the iterm advanced features though, i do split windows and tabs in tmux only
17:20:14 <ReinH> orb__: `vim -c :help leader` ;)
17:20:46 <merijn> AshyIsMe: oh, Terminal.app has supported 256 colours for a while now :)
17:21:07 <orb__> ReinH, wouldn't $(`vim -c :help leader) be better? ;o)
17:21:21 <ReinH> orb__: only if you're on bash ;o)
17:22:38 <ReinH> merijn: are any of these interesting to you? http://iterm2.com/features.html
17:23:54 <merijn> ReinH: Not really, so I guess I can blissfully stay in tmux world
17:24:04 <merijn> Time to go home
17:24:09 <ReinH> You can use tmux with iTerm2...
17:24:18 <ReinH> but probably no real reason to switch terminals
17:24:38 <AshyIsMe> yeah i can't remember why i did
17:25:40 <AshyIsMe> so long as tmux and colors work in the terminal it doesnt really matter which one it is
17:26:32 <AshyIsMe> felixn: visual studio with C# is the only really easy "just start working" ide ive ever really seen unfortunately
17:26:59 <AshyIsMe> intellij is nice for some languages too but it has feature overload that gets confusing too
17:27:11 <felixn> AshyIsMe: I recently saw F# on HN, it actually looks pretty cool
17:27:21 <AshyIsMe> i can't do without vim bindings though, they're just so productive
17:27:33 <AshyIsMe> yeah f# is growing really quickly
17:27:36 <josephle> after I got YouCompleteMe for vim, I never felt a compelling need to have an IDE
17:28:17 <AshyIsMe> i still havent set up YouCompleteMe
17:28:31 <AshyIsMe> ive been meaning to
17:28:39 <felixn> josephle: nice that looks infinitly better than nothing
17:28:46 <pingu> it's a pain to set up, but worth it.
17:29:18 <josephle> there's even haskell support for YCM in neco-ghc
17:29:22 <josephle> although it's somewhat limited
17:44:13 <Enigmagic> i use YCM with neco-ghc + ghcmod-vim
17:52:04 <mhall> does anyone know, is there a standard equivelent to the `-:` operator used in LYAH? (defined as: `x -: f = f x`)?
17:53:10 <josephle> > 1 & (+1) -- mhall
17:53:13 <lambdabot>  2
17:53:30 <Fuuzetsu> from lens
17:53:30 <josephle> although that requires you to import Control.Lens...
17:53:50 <Fuuzetsu> josephle: recently I add lens right after git init
17:54:16 <MP2E> you could always just define '(-:) = flip ($)'
17:54:22 <MP2E> not sure if -: is used by something already or not though
17:55:14 <josephle> Fuuzetsu: you never know if some people have an aversion to lens or not
17:59:21 <Fuuzetsu> weird-ass scoping issues caused by the TH can scare anyone off‚Ä¶
18:07:16 <benzrf> isnt -: a prolog thingie
18:07:49 <joe9> I am reading up on continuations.  http://codepad.org/GWuFkGZW from http://www.defmacro.org/ramblings/fp.html#part_9 . I vaguely recall that in haskell every function has one argument. Is haskell implemented using CPS?
18:08:14 <joe9> Does it not use the stack for storing return addresses?
18:09:02 <joe9> s/it/haskell/^^
18:09:49 <orb__> joe9, haskell is not normally implemented using cps.
18:10:01 <_tca> currying is different than cps joe9
18:10:10 <orb__> I'm not even sure whether cps works for lazy languages.
18:10:17 <orb__> Currying has not much to do with cps.
18:10:26 <joe9> _tca: oh, ok. got currying and cps mixed up.
18:10:55 <orb__> You can pretend that other languages also only have one argument functions, just that their single argument is a tuple.
18:11:38 <benzrf> orb__: in some sense that is true!
18:12:22 <sbrg> this is typical. I was going to spend the evening beefing up my xmonad setup and making it nicer to look at and now I'm balls deep in ghc-mod source trying to fix a bug
18:12:27 <joe9> With recursive functions in haskell, the stack increases for every recursive call?
18:12:41 <joe9> or, for that matter, just a normal function too.
18:12:49 <_tca> joe9: cps is also not essential for proper tail calls
18:12:53 <benzrf> joe9: n o t exactly
18:12:55 <joe9> with recursion, tail call optimization could be done.
18:13:07 <benzrf> joe9: haskell's evaluation model is not how you normally think
18:13:11 <benzrf> joe9: example:
18:13:28 <benzrf> > let f n = f (n - 1) in f 10
18:13:32 <lambdabot>  mueval-core: Time limit exceeded
18:13:40 <benzrf> notice that that runs out of time rather than overflowing
18:13:55 <benzrf> oh wait it's a tail call... eh poor example!
18:14:03 <benzrf> > let f n = 1 + f (n - 1) in f 10
18:14:08 <lambdabot>  mueval-core: Time limit exceeded
18:14:12 <benzrf> better
18:15:21 <ReinH> @where lazy -- joe9
18:15:21 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
18:15:24 <benzrf> on the other hand...
18:15:33 <ReinH> joe9: it would be a very good idea for you to read that link right now :)
18:15:41 <benzrf> > let f n acc = f (n - 1) (acc + 1) in f 10 0
18:15:44 <joe9> ReinH: ok, thanks.
18:15:45 <lambdabot>  mueval-core: Time limit exceeded
18:15:51 <benzrf> oh hmmmmmmm
18:16:28 <ReinH> benzrf: er, you don't have a base case. n will decrease until it reaches minBound :: Int, at which point...
18:16:56 <ReinH> Not even. If it defaults to Integer, it will decrease until you run out of memory.
18:18:33 <orb__> joe9, haskell isn't even guaranteed to have a stack to run out of.  (if memory serves right.)
18:18:38 <ReinH> joe9: It might also be good to differentiate between *Haskell's* evaluation model and *GHC's* evaluation model
18:18:57 <orb__> Haskell doesn't prescribe too much in terms of evaluation model, doesn't it?
18:19:36 <ReinH> Since the Haskell standard does not give the operational semantics
18:20:03 <ReinH> orb__: So basically, no
18:20:25 <ReinH> benzrf: Ah, you were trying to generate a stack overflow. Sorry.
18:20:54 <orb__> > let l = 1 : l
18:20:56 <lambdabot>  not an expression: ‚Äòlet l = 1 : l‚Äô
18:21:04 <orb__> > @ let l = 1 : l
18:21:05 <lambdabot>  <hint>:1:1: parse error on input ‚Äò@‚Äô
18:21:12 <orb__> > @let l = 0:l
18:21:14 <lambdabot>  <hint>:1:1: parse error on input ‚Äò@‚Äô
18:21:14 <Fuuzetsu> > let l = 1 : l in l
18:21:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:21:30 <ReinH> joe9: GHC does not do "tail call optimization", i.e. replacing tail calls with some sort of jump to avoid allocating a stack frame.
18:21:45 <xpika> @src (!!)
18:21:45 <lambdabot> xs     !! n | n < 0 = undefined
18:21:45 <lambdabot> []     !! _         = undefined
18:21:45 <lambdabot> (x:_)  !! 0         = x
18:21:45 <lambdabot> (_:xs) !! n         = xs !! (n-1)
18:21:51 <orb__> Thanks, Fuuzetsu.  joe9, see, this was not a stack overflow either, even though it wasn't a tail call.
18:22:07 <ReinH> GHC *does* do lazy evaluation, which is able to optimize tail calls as well as other calls that can't be optimized with traditional TCI
18:22:30 <ReinH> The link I gave explores this evaluation strategy in some detail
18:23:04 <ReinH> joe9: These SO answers might help a bit as well: https://stackoverflow.com/questions/24370549/foldleft-v-foldright-does-it-matter/24370977#24370977 https://stackoverflow.com/questions/23893320/why-isnt-this-recursive-function-being-optimized-haskell/23894550#23894550
18:23:19 <ReinH> s/TCI/TCO
18:23:53 <ReinH> Also the stack in GHC is not a "call stack" in the traditional sense
18:29:23 <merijn> ReinH: Well, another way of looking at it is that GHC performs TCO on all functions, even those that are not tail recursive ;)
18:30:13 <merijn> ReinH: I'm not sure that lazy evaluation is really related to GHC's calling convention, though
18:31:05 <ReinH> merijn: normal-order evaluation causes left-most outermost redexes to be reduced first. Those happen to be "tail calls". ;)
18:31:12 <merijn> ReinH: afaict that mostly due to Core's model mapping onto CPS rather trivially and every call being a tail call in CPS
18:33:19 <ReinH> merijn: well, perhaps we're talking about different things
18:33:43 <ReinH> "tail calls" like foldr get reduced, while "non-tail calls" like foldl don't.
18:35:00 <ReinH> (referring to where the recursive call is located)
18:36:59 <ReinH> also holy netsplit
18:43:46 <CrazyM4n> I have a quite simple bit of code that uses repa and gloss-raster, and it fails with an error that makes me think that my repa install is messed up http://lpaste.net/3754360694460383232
18:43:58 <CrazyM4n> Does anyone know how to fix this?
18:44:20 <Fuuzetsu> you have two version of repa in scope
18:44:32 <Fuuzetsu> get rid of one
18:44:55 <Fuuzetsu> make sure all your deps are using the same one
18:44:57 <CrazyM4n> How do I uninstall cabal packages then?
18:45:03 <Fuuzetsu> ghc-pkg --help
18:45:06 <CrazyM4n> and yeah, that was what I was kind of thinking
18:45:06 <CrazyM4n> ok
18:45:21 <Fuuzetsu> you didn't --force-reinstalls, did you?
18:45:31 <CrazyM4n> No
18:48:05 <Axman6> phc_pkg unregister <package> "uninstalls" it
18:48:07 <CrazyM4n> Hey, it works now! Thanks
18:49:02 <Fuuzetsu> Axman6: phc a new compiler?
18:49:13 <Fuuzetsu> Plymouth Haskell Compiler
18:49:21 <merijn> CrazyM4n: Alternatively, use cabal to build your own code, cabal should only pick one library version at a time
18:49:28 <Axman6> yes
18:49:29 <Axman6> >_>
18:49:45 <Axman6> I guess that shows how much haskell I
18:49:51 <Axman6> I'm writiing at the moment
18:49:52 <CrazyM4n> merijn: It's my fault that happened, I installed repa and then went and installed gloss-raster
18:50:20 <CrazyM4n> Unbeknownst to me, gloss-raster installed it's own version of repa
18:50:33 <Fuuzetsu> is there a way to have cabal not produce any output? I just need a cabal file (because reasons) and I don't want to waste time compiling a dummy Main.hs
18:50:51 <Fuuzetsu> i.e. cabal build should just say OK
18:53:46 <Fuuzetsu> I guess a library section without any modules listed works
18:57:00 * hackagebot cplusplus-th 1.0.0.0 - C++ Foreign Import Generation  http://hackage.haskell.org/package/cplusplus-th-1.0.0.0 (MaxwellSwadling)
18:58:44 <marchelzo_> Why does forever have the signature Monad m => m a -> m b? Is it just because the only way a function could ever have that signature is if it never returned?
18:59:08 <merijn> marchelzo_: Pretty much
18:59:22 <simpson> marchelzo_: It's because nothing constrains the `b` value to be more specific.
18:59:25 <simpson> @src forever
18:59:25 <lambdabot> Source not found. Just try something else.
18:59:45 <simpson> forever a = a >> forever a -- derp
19:00:46 <simpson> That said, there *are* Monads for which `forever` does not run forever.
19:00:56 <simpson> > forever Nothing
19:00:58 <lambdabot>  Nothing
19:01:15 <marchelzo_> ah
19:01:22 <marchelzo_> > forever []
19:01:24 <lambdabot>  []
19:01:28 <marchelzo_> That makes sense
19:01:30 <johnw> marchelzo_: it could have ended with m (), but by ending with m b, the return type can unify anywhere that you use it
19:01:36 <benzrf> > forever alone
19:01:39 <lambdabot>  Not in scope: ‚Äòalone‚Äô
19:01:54 <merijn> johnw: Plus, () doesn't tell you it can't return
19:01:58 <benzrf> > forever Just "lol"
19:02:03 <lambdabot>  mueval: ExitFailure 1
19:02:04 <benzrf> > forever (Just "lol")
19:02:06 <johnw> sure, nothing says that
19:02:08 <lambdabot>  mueval-core: Time limit exceeded
19:02:14 <benzrf> lammmmmmmmmmmmmmme!
19:02:15 <merijn> johnw: "m b" does
19:02:19 <johnw> oh
19:02:24 <nshepperd> forever :: m a -> m Void
19:02:27 <johnw> point to merijn
19:02:33 <johnw> nshepperd: that would be very hard to call I think
19:02:42 <merijn> nshepperd: Yeah, but Void is not in base
19:02:44 <johnw> fmap absurd (forever Nothing)?
19:02:52 <johnw> :t absurd
19:02:54 <lambdabot> Not in scope: ‚Äòabsurd‚Äô
19:03:06 <merijn> johnw: "fmap absurd (forever Nothing)" == Nothing
19:03:13 <benzrf> @let data Void
19:03:16 <lambdabot>  Defined.
19:03:22 <benzrf> @let explosion v = case v of {}
19:03:22 <lambdabot>  Parse failed: Parse error: }
19:03:25 <benzrf> u wot
19:03:31 <merijn> johnw: absurd never gets called due to fmap on Nothing :)
19:03:32 <nshepperd> yeah, it's a bit pointless to require the user to put 'fmap absurd' in everywhere
19:03:47 <johnw> ah
19:03:47 <benzrf> @let explosion v = v `seq` error "u wot m8"
19:03:49 <lambdabot>  Defined.
19:04:00 <benzrf> :t fmap explosion
19:04:01 <lambdabot> Functor f => f a -> f b
19:04:09 <benzrf> oh. wait
19:04:11 <johnw> clearly my mind is elsewhere...
19:04:13 <benzrf> der
19:04:22 <benzrf> @let explosion :: Void -> a
19:04:24 <lambdabot>  Defined.
19:04:24 <benzrf> :t fmap explosion
19:04:25 <lambdabot> Functor f => f Void -> f b
19:04:29 <benzrf> cool
19:05:02 <benzrf> fmap explosion, n: what happens when you pack lots of fmaps into a small space with some tnt
19:06:51 <johnw> yoneda is known to defuse fmap explosion :)
19:16:50 <lurker6> I have a slow function (f :: Int -> [Float]), and (f fixed_n) was getting called a lot. So I changed my code to cache the result via (let x = f fixed_n) and replaced other calls to f fixed_n with x, which makes it run much faster. Is there a way to get GHC to cache the result in a more elegant way?
19:18:23 <Hijiri> if you're using it throughout an entire definition I think a where clause would look nicer
19:18:33 <Hijiri> but that's probably not the answer you were looking for
19:18:34 <merijn> lurker6: Not any that are very reliable
19:19:09 <merijn> lurker6: where/let clause is the most reliable way to ensure a value is only ever evaluated once
19:20:11 <lurker6> Ah, I can live with that.
19:21:03 <lurker6> I did try putting it in a where clause, but the function with the where clause was itself getting called a lot. So I'm guessing that was the issue.
19:21:56 <lurker6> I'll try using a where at the topmost function. Thanks!
19:27:15 <joe9> Are coroutines in Haskell implemented using the cont monad?
19:27:36 <merijn> I think you can implement them that way
19:28:44 <joe9> merijn: thanks. I was under the misimpression that coroutines needed cps.
19:28:50 <joe9> or, the cont monad to work.
19:28:56 <lurker6> Oh...So I was using the let in do notation, so the (let/where) suggestion is actually more elegant than what I had.
19:29:27 <merijn> lurker6: Generally I prefer "where" whenever possible, because I one find it cleaner and two it avoids this confusion :)
19:29:32 <fragamus_> cont monad is some weird voodoo
19:29:53 <merijn> joe9: The Cont monad *is* CPS
19:30:12 <fragamus_> CPS?
19:30:19 <merijn> fragamus_: Continuation Passing Style
19:30:29 <joe9> http://hackage.haskell.org/package/monad-coroutine-0.7.1/docs/Control-Monad-Coroutine.html Is this the recommended package for haskell coroutines?
19:30:50 <merijn> joe9: What do you plan to use coroutines for?
19:31:16 <joe9> merijn: I want to write a simple process scheduler. just to learn how things work.
19:31:42 <joe9> merijn: it appears that I could use coroutines to do that.
19:32:10 <lurker6> merijn: Is where/let as used in a function monadic in the same way, say... let x = 1 === x <- return 1 ...is?
19:32:56 <merijn> lurker6: No
19:33:15 <merijn> @undo do { x <- foo; bar; baz x; return 1}
19:33:15 <lambdabot> foo >>= \ x -> bar >> baz x >> return 1
19:33:45 <lurker6> merijn: Ok good. So my point was that your (and Hijiri's) suggestion was more helpful than you realized, I think :)
19:33:48 <merijn> lurker6: Do notation binds desugar to a lambda, let/where just define names and are identical to top level definitions
19:33:51 <exio4> I thought (return x >>= f) = f x was a monad law?
19:34:07 <merijn> exio4: Yeah
19:34:37 <merijn> lurker6: Well, not entirely identical, let/where can access local variables and are invisible outside the function, but you get the idea :)
19:35:04 <cschneid> I'm using the UUID package, and Aeson. I want to spin a UUID out as json, but it doesn't implement ToJSON, and Aeson doesn't define it for that type either.  I can do it myself, but I get warnings about orphan instances. How to avoid?
19:37:04 <merijn> cschneid: You can't
19:37:45 <merijn> cschneid: You'll have to live with the orphan, but it should be okay in this scenario
19:38:20 <cschneid> ok, I figured there wasn't a way around it. Is there a way to tell GHC that, I know its mildly ugly, shut up?
19:38:24 <cschneid> but only for this one
19:39:31 <merijn> cschneid: oh, actually
19:39:38 <merijn> I just remembered something :)
19:39:58 <merijn> cschneid: You could newtype the UUID datatype and instance ToJSON for the newtype
19:40:03 <merijn> That avoids the orphan entirely
19:40:09 <cschneid> ahh, interesting.
19:40:25 <cschneid> UUIDWithJSONDamnIt
19:40:30 <cschneid> merijn: clever - thanks
19:41:29 <orb__> UUIDWithJSONDamIt [dam this flood of warnings!]
19:50:01 <Javran1> hi, my emacs keeps telling me there is a "not in scope" error, but the source code is totally fine since it can be executed by runghc, this file is inside a cabal project so I guess something might be wrong there, how can I figure out what exactly is the problem?
19:52:49 <haskell_noob> Hello. I come to you because I am trying to do something, and am unable to, despite vast efforts and lots of googling.
19:53:16 <Fuuzetsu> Javran1: start by elaborating what you mean by ‚Äòemacs keeps telling me‚Äô; what tool inside emacs is telling you this? What does it actually say?
19:53:20 <Fuuzetsu> haskell_noob: ask away
19:53:56 <haskell_noob> I would really like to compile a binary on Debian x86, upload to a RHEL x86_64 amazon ec2, and have it working.
19:54:16 <haskell_noob> It does, unless I use, directly or indirectly, the network.bsd library.
19:54:42 <Fuuzetsu> merijn: ‚Ä¶you forgot about newtypes and said to live with the orphan instead?
19:54:45 <haskell_noob> In which case it tells me ("no such protocol name: tcp")
19:55:55 <haskell_noob> I tried many things, including building a dynamically linked executable and uploading the libs, building a static exec, and it always just does that same error.
19:56:05 <haskell_noob> any help gladly accepted.
19:58:15 <Fuuzetsu> Seems like the kind of question you'd have more luck sending to the mailing lists honestly, you probably want someone who deploys Haskell programs up to pitch in and not many of those folk pay much attention to IRC
19:58:36 <merijn> haskell_noob: Try opening "/etc/protocols"?
19:58:48 <merijn> Fuuzetsu: I'm betting the linux setup is borked
19:58:51 <Fuuzetsu> unless merijn knows ;P
19:59:29 <Fuuzetsu> merijn: Yes, that's also my guess but I know nothing about ec2 nor how to troubleshoot this normally‚Ä¶ Don't those things come set-up out of the box?
19:59:37 <haskell_noob> I did that, both on the source and target machine, and they look similar.
20:00:07 <merijn> haskell_noob: What's the permissions on /etc/protocols
20:00:42 <merijn> haskell_noob: Looking at the Network source indicates that that error indicates that "man 3 getprotobyname" is returning an error
20:00:43 <haskell_noob> -rw-r--r-rr on both sites
20:01:01 <merijn> Try using getprotobyname from C and see if that does work?
20:01:29 <haskell_noob> ok. Gimme a sec.
20:05:50 <haskell_noob> Right. If I build on debian (gcc main.c, no other flags) and upload to ec2, it tells me that protocol is not found, if I build on ec2, it works properly.
20:06:16 <merijn> haskell_noob: Looks like your local libc is not the same as on EC2, causing the error
20:06:40 <merijn> haskell_noob: Haskell libraries are linked statically, but C libraries are not. If they're not compatible you're in trouble like here
20:07:17 <haskell_noob> @merjin: ok, thank you very much. Do you think it would be possible to install the build machine library on the target?
20:07:18 <lambdabot> Unknown command, try @list
20:07:37 <merijn> The other way around would be easier, most likely
20:07:53 <merijn> The most reliable way would be to install your target OS in a vm and build on that
20:10:26 <haskell_noob> Mhkay. That's a good solution.
20:11:31 <haskell_noob> Not as good as a good cross-compile. But thanks either way.
20:16:36 <madmax88> Are there any Haskell wizards who are willing to help me help a friend debug a (pretty) basic program?
20:19:11 <orb__> madmax88, just ask.
20:19:21 <orb__> If it's super basic, you might also want to look into #haskell-beginners
20:20:20 <madmax88> it's not __super__ basic, it's a fast fourier transform algorithm implementation
20:21:12 <madmax88> I apologize profusely about the lack of comments and type signatures, I was just as irritated when I read the code: http://pastebin.com/bbqLPWaX
20:21:52 <madmax88> the error is "No instance for (RealFloat Int) arising from a use of ‚Äò+‚Äô     In the first argument of ‚ÄòzipWith‚Äô, namely ‚Äò(+)‚Äô" and I can't figure out the problem for the life of me
20:22:13 * hackagebot h2048 0.2.0.0 - a haskell implementation of Game 2048  http://hackage.haskell.org/package/h2048-0.2.0.0 (javran)
20:22:14 <merijn> madmax88: Int is not an instance of RealFloat :p
20:22:23 <merijn> madmax88: Probably mixing integral and floating point types
20:22:37 <merijn> Use fromIntegral to convert Int to the appropriate floating point type
20:22:44 <merijn> @quote monochrom fromIntegral
20:22:44 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
20:24:16 <madmax88> I figured something like that was happening, 1ambdabot pretty funny:) trying fromIntegral right now
20:27:13 * hackagebot hly 0.15 - Haskell LilyPond  http://hackage.haskell.org/package/hly-0.15 (RohanDrape)
20:27:15 * hackagebot hts 0.15 - Haskell Music Typesetting  http://hackage.haskell.org/package/hts-0.15 (RohanDrape)
20:29:42 <madmax88> still no luck identifying what type isn't correct. The functions involved (fft_even, getRoots, and fft_odd) all return [Complex a]
20:30:16 <madmax88> can fromIntegral work to convert a Complex Int to a RealFloat?
20:30:17 <tsani> I have a monad transformer stack at the bottom of which is IO. I'd like to use withMVar on a function X -> MyStack Y, but the types don't check out. Is there some way to lift withMVar so that it's signature becomes MVar a -> (a -> MyStack b) -> MyStack b ?
20:30:29 <haskell_noob> Ah, there, one of the c libs linked to linux-gate.so.1, and I just realized that I'm screwed but in a much more interesting manner than I thought.
20:30:42 <orb__> tsani, yes.  Let me look it up.
20:30:50 <orb__> tsani, monad base control.
20:31:16 <orb__> https://hackage.haskell.org/package/monad-control
20:32:01 <orb__> tsani, I solved the exact same problem a few years ago.
20:33:01 <orb__> tsani, you want (Control.Monad.Trans.Control.liftBaseOp withMVar), I think.
20:34:02 <orb__> tsani, have fun wrapping your head around the types.
20:34:18 <madmax88> yeah, trying to use fromIntegral on a Complex doesn't work: "No instance for (Integral (Complex Int))"
20:34:49 <tsani> orb__: Yeah, I'm looking through these now and my head is aching haha
20:35:03 <tsani> But thank you ! This looks exactly like what I need.
20:37:41 <MagBo> https://gist.github.com/paf31/9c4d402d400d61a49656 in case it wasn't posted here still.
20:38:08 <orb__> tsani, a coworker of mine came up with a home-made solution to this problem, afterwards I found that package.  It was a fun exercise proving that his solution was equivalent to the one from the package.  (His types were simpler, not rank-n).
20:38:32 <orb__> madmax88, I suggest adding all the type signatures and running through hlint.  Perhaps your problem will become trivial, then?
20:39:59 <madmax88> orb__, will do. Thanks for the help:)
20:42:52 <Javran1> seems like @haskellstackoverflow @hackage on twitter have stopped updating for a while?
20:47:28 <cristian4> who is monochrom?
20:51:23 <chirpsalot> Hmmmm. Distributing linux executables of Haskell programs isn't going to be pleasant is it?
20:52:29 <merijn> chirpsalot: Not any different than for C/C++ programs
20:52:35 <haskell_noob> @chirpsalot: dynamic languages running on virtual machines has spoiled us, eh?
20:52:35 <lambdabot> Unknown command, try @list
20:52:40 <haskell_noob> ; )
20:52:43 <chirpsalot> I want to distribute a solution for students to test against as a binary, but I'm scared :P.
20:52:46 <merijn> chirpsalot: Actually slightly better, because at least all haskell libraries are linked statically
20:52:58 <chirpsalot> merijn: are they linked statically?
20:53:05 <chirpsalot> merijn: or is that a GHC option?
20:53:07 <merijn> By default, yes
20:53:27 <chirpsalot> Really? I can carry them to machines with no GHC installed whatsoever no problem?
20:53:54 * chirpsalot doesn't have a "no GHC machine" to test at the moment.
20:54:06 <merijn> chirpsalot: Yes IF you have the C dependencies
20:54:26 <merijn> chirpsalot: GHC doesn't link C libraries statically by default, use ldd to check
20:54:29 <chirpsalot> merijn: ah. I'm assuming that's mostly glibc.
20:54:35 <merijn> chirpsalot: libgmp
20:54:44 <merijn> Plus whatever's wrapped by FFI libraries
20:54:53 <chirpsalot> Ah.
20:55:06 <chirpsalot> Well, cool! I shall have to try that out. Thanks :).
20:56:00 <chirpsalot> I'm slowly oozing Haskell into every crevice I can such that GHC is installed on as many machines as possible. I'm not quite there yet ;).
20:58:04 <haskell_noob> Oh yeah, another potentially crazy question... Is it possible to build, uh, a *not* linked binary with GHC and use ld on the target machine to link it against the libraries on the target?
20:58:16 <haskell_noob> Should I ask that to people who use C more heavily?
20:58:41 <merijn> haskell_noob: Well, the answer to a different question is:
20:58:52 <merijn> haskell_noob: You can build dynamic libraries using haskell, yes
20:58:59 <merijn> i.e. .so and link those
21:00:20 <haskell_noob> Ah, merjin, thanks to you, I'm finally making tangible and appreciable progress down the rabbit hole ; )
21:01:34 <chirpsalot> Wait.
21:01:50 <chirpsalot> You pretty much just asked the exact same question as me, and I didn't even notice, haha.
21:02:29 <johnw> haskell_noob: you can use ghc -v -v -v to see what it's linker command would be, and then just use --ld-command to replace the linker it uses with 'echo' or something
21:02:40 <johnw> there should be another flag to make it keep intermediate objects
21:03:21 <orb__> johnw, -vvv should probably work as well.
21:03:28 <haskell_noob> ohhhhhhhh
21:06:46 <haskell_noob> @chirpsalot: yeah. Really, normally I don't use irc, but all the documentation I found about my problem via Google was either related to building a cross-compiler (which looks like a pretty delicate operation), or really really old mailing list threads without real solutions.
21:06:46 <lambdabot> Unknown command, try @list
21:07:15 * hackagebot PastePipe 1.6 - CLI for pasting to lpaste.net  http://hackage.haskell.org/package/PastePipe-1.6 (MateuszKowalczyk)
21:11:36 <octopuscabbage> how would i go about running a function in 4 sparks and then returning whichever evaluates first
21:14:08 <Axman6> octopuscabbage: http://www.haskell.org/haskellwiki/Amb perhaps? I'm sure there's something better and I'll keep looking for it
21:14:21 <octopuscabbage> i'm currently trying an unsafe mvar operation
21:14:31 <Axman6> https://hackage.haskell.org/package/unamb-0.2.5/docs/Data-Unamb.html
21:18:16 <Axman6> octopuscabbage: did you see the unamb link?
21:18:36 <jle`> is ReaderT like a "Free MonadReader" ?
21:18:46 <johnw> um
21:18:55 <johnw> that seems like a confusion of terms
21:19:49 <johnw> I think you could say that MonadReader abstracts representable functors
21:19:51 <johnw> as in http://hackage.haskell.org/package/representable-functors-3.2.0.2/docs/Control-Monad-Representable-Reader.html
21:22:31 <tsani> orb__: It turns out that I opted for a homemade solution to my problem with MVars
21:25:03 <jle`> johnw: ReaderT gives any Monad a free
21:25:03 <tsani> orb__: The point was to use forkIO to separate the rendering and event handling in a little game I'm making, but I needed to use MVars to wait for the drawing to complete before flipping the buffers. Anyway, I was able to make a function MyStack a -> MyStack (IO a), and from there it wasn't too bad.
21:25:11 <jle`> sorry, internet is being weird
21:27:01 <jle`> johnw: ReaderT r gives any Monad m a MonadReader r m instance, without adding any extra structure.  a lawful instance
21:27:17 <jle`> any structure other than is necessary...and guarunteed by construction to satisfy MonadReader laws
21:27:37 <jle`> just like [] gives any a a Monoid [a] instance without adding any more structure than necessary, lawful by construction
21:28:35 <jle`> Free gives any Functor f a Monad instance, lawful by construction
21:29:12 <johnw> so you meant the general use of the word "free"?
21:29:13 <jle`> w/out anyhing extra, right?
21:29:23 <johnw> I thought you mean that MonadReader was somehow equivalent to the Free monad
21:29:36 <jle`> free in the sense of the free in Free Monad, free in Free Monoid
21:29:52 <jle`> imbues any Monad m with a free MonadReader instance that satisfies the laws with minimal structure
21:29:59 <johnw> free as in a free object
21:30:50 <jle`> ah, yes
21:31:08 <orb__> The Monad Reader is a free magazine.
21:32:11 <orb__> tsani, what influenced your decision to go / not to go with the library?
21:32:59 <justin_smith> orb__: I'm picturing bearded CS professors going door to door in pairs, asking "do you have a few moments to talk about your immutible soul"?
21:33:37 <justin_smith> oh, the monad reader actually exists, cool
21:34:41 <orb__> justin_smith, the beard separates the Haskellers from the Mormons.
21:34:53 <orb__> The Monad Reader is great.
21:35:29 <jle`> so is ReaderT r a free MonadReader?
21:35:29 <justin_smith> of course I should have said, "going door to door in tuples"
21:36:07 <jle`> if so i suggest we change the name to FreeReader
21:36:29 <dfeuer> orb__, there's a lively discussion on libraries@haskell.org regarding the isSuffixOf matter.
21:37:14 <jle`> and change MonadReader to Reader
21:43:02 <Lutin`> Aww man no one has made NTL bindings
21:43:06 <Lutin`> Looks like I have a project now
21:43:46 <Lutin`> Thought it's probably going to be a pain in the ass since it's a Cxx library
21:44:15 <Lutin`> And as of late uses lots of templating
21:45:48 <starfishwife_> hi, I have a quick question. what do I need to import so that my quickCheck tests run only on NonEmpty lists?
21:46:48 <kadoban> starfishwife: I think you need something like...: prop_whatever xs = (not . null $ xs) ==> <your property here>
21:47:11 <Fuuzetsu> or a newtype which just throws away empty lists
21:47:29 <starfishwife_> kadoban, thank you for your answer. I am trying to figure out the newtype thing
21:47:34 <starfishwife_> which is what I have used before
21:47:53 <starfishwife_> I'm just not on my usual computer, and can't reference old code
21:47:55 <kadoban> Ah, I don't know what that is wrt quickcheck
21:50:33 <orb__> starfishwife_, please post your code to lpaste.net.
21:50:57 <orb__> starfishwife_, Fuuzetsu, QuickCheck already has NonEmptyList.
21:51:12 <orb__> starfishwife_, your test needs to take a NonEmptylist Int, instead of [Int].
21:51:16 <Fuuzetsu> orb__: probably
21:51:17 <orb__> (Assuming you are taking Ints.)
21:51:33 <orb__> prop_whatever (NonEmpty xs) = <your property here>
21:52:33 <starfishwife_> ord__ so it should be something like test :: NonEmptylist Int -> Bool?
21:55:12 <Javran1> wondering if something is an instance of Enum, will it have better performance by using Data.IntMap?
21:55:18 <orb__> starfishwife_, yes.
21:58:28 <starfishwife_> and it works, thanks!
21:58:48 <orb__> Javran1, criterion is your friend.
22:15:30 <filoteo> in the pattern design of function guards and the likes, what was it do decide on matching by "listed first, matched first", rather than, "more specific, matched first" ?
22:16:16 <merijn> filoteo: listed first, matched first
22:16:28 <merijn> filoteo: Simple
22:16:40 <merijn> filoteo: It's easier to implement and easier to understand
22:17:01 <merijn> filoteo: Deciding which pattern is "more specific" can become an arbitrarily complex task for complicated patterns
22:17:26 <filoteo> merijn: so it is about efficiency ?
22:17:26 <merijn> filoteo: Keep in mind pattern matches can be nested arbitrarily and functions can have multiple arguments
22:17:59 <merijn> filoteo: "f (x:xs) ys = undefined; f xs (y:ys) = undefined" <- which pattern is "more specific"?
22:18:53 <filoteo> merin: they designed so, that the compiler won't have to check branching patts etc. ?
22:19:03 <filoteo> mirjn: I see, readability as well.
22:19:24 <filoteo> (merijn:)
22:20:02 <merijn> filoteo: So basically, there's not really all that many reasons to use "more specific" and lots of pragmatic reasons not too (readability, ease of implementation, etc.)
22:22:00 <monochrom> if you imposed a "most specific" rule, you would still have to resolve ties by "first come first served" anyway
22:23:48 <monochrom> at the end of the day, the cost would be not worth the gain. (be it the cost of teaching/learning the rules or the cost of implementing)
22:23:56 <edwardk> filoteo: how would the more specific rule work? how do you tell a predicate is more specific than another one? run them all?
22:24:01 <johnw> filoteo: imagine if a simple change in a library's data type suddenly changed the behavior of programs everywhere in very hard to track down ways
22:24:28 <johnw> matching by "most specific" was be at a cost to sanity, I'm sure
22:27:19 * hackagebot http-media 0.4.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.4.0 (TimothyJones)
22:44:43 <filoteo> well I had in mind the Hope language, which always favors the more specifific
22:45:51 <filoteo> and from there I thougtht he haskell designers must have taken that in consideration, and found some other reasons (than efficiency, readability, mind sanity) to for by listed order.
22:46:45 <filoteo> I haven't used Hope, only was reading the wikipedia.
22:49:46 <filoteo> specifically they write about Hope: "Unlike in Haskell, changing the order of the clauses would not change the meaning of the program, because Hope's pattern matching always favors more specific patterns over less specific ones."
22:51:18 <filoteo> and Hope was from the 70s & 80s, so I'm confident they knew of it.
22:52:07 <solatis> funny how Hope looks a bit like a merge of Haskell and Python
22:53:23 <solatis> the language has its charms
23:10:31 <joe9> Which of these is recommended? monad-coroutine, Streaming component combinators, resumption monad (http://people.cs.missouri.edu/~harrisonwl/papers/amast06.pdf)
23:10:51 <joe9> they all seem to have similar functionality. but, I cannot figure out which is better by reading at their papers.
23:11:13 <joe9> Just wanted to check which is more popular.
23:16:09 <filoteo> joe9: a superficial reading - the papers highlight is that resumptions have been much undervalued - althought not necessarily better.
23:17:16 <joe9> ok, thanks. will check out resumption monad more seriously.
23:17:56 <joe9> http://hackage.haskell.org/package/monad-coroutine-0.8/docs/Control-Monad-Coroutine.html btw, I could not figure out what the integer parameter to yield is for.
23:18:00 <joe9> any thoughts, please?
23:18:14 <filoteo> perhaps he thougth "resumptions are less powerful, but cheaper, so they must have some good value in concurrency".
23:18:53 <joe9> filoteo: thanks.
23:23:20 <marvimias> Anyone got any interesting and fairly advanced Haskell programming challenges/problems?
23:23:29 <marvimias> Involving mathematics.
23:25:11 <kadoban> marvimias: project euler maybe?
23:25:52 <marvimias> kadoban, Done 456 PE problems. Looking for some that people may have thought of here.
23:25:58 <marvimias> Also done UVA judge online
23:26:29 <kadoban> Ah. Wow that's a lot of pe problems
23:27:00 <merijn> @where exercises
23:27:01 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
23:27:07 <bernalex> anyone happen to know why GHCi detects loops? I assume it's because it's "special".
23:27:22 * hackagebot protobuf-native 1.0.0.0 - Protocol Buffers via C++  http://hackage.haskell.org/package/protobuf-native-1.0.0.0 (MaxwellSwadling)
23:27:23 <merijn> bernalex: What do you mean? You mean <<<loop>>>?
23:27:26 <simpson> marvimias: Show that, if the Collatz conjecture is true for all multiples of 2 and multiples of 3, it is true for all positive integers.
23:27:30 <bernalex> merijn: yeah the exception.
23:27:38 <merijn> bernalex: Compiled programs do too
23:27:41 <Cale> bernalex: That's what happens when a blackhole gets entered.
23:27:54 <bernalex> merijn: not here. runhaskell doesn't seem to do it at least.
23:28:04 <merijn> bernalex: Optimisations?
23:28:18 <Cale> When an expression begins evaluating, the first thing it does is rewrite the code pointer which was just followed to point at a blackhole which throws that exception.
23:28:31 <bernalex> merijn: just running ghc tst.hs && ./tst
23:28:35 <merijn> bernalex: Loop detection is a "best-effort" kinda thing
23:28:52 <Cale> Then, when it's done, it rewrites it again to point at a shorter piece of code to return the already computed value immediately
23:28:59 <filoteo> joe9: yield would be what the other coro waits for. a message passing mech. yield,await,request.
23:28:59 <merijn> bernalex: Whether it's able to detect it depends on lots of variables (else it'd have solved the halting problem)
23:29:37 <bernalex> merijn: I'm pretty sure GHC did that ages ago with the HaltingNoProblem pragma
23:29:42 <Cale> Well, if you're using the threaded runtime or not makes a difference
23:29:58 <filoteo> joe9: like in other languages, doing non-premptive multitasking.
23:30:02 <bernalex> Cale: don't I need to compile it with -threads or whatever?
23:30:14 <Cale> -threaded
23:30:21 <bernalex> yeah that one
23:30:49 <Cale> The threaded runtime uses grey holes, which are a little different
23:31:00 <bernalex> feel free to elaborate.
23:31:49 <Cale> Okay, so if some variable gets evaluated, we enter its code pointer and update it to point at the black hole (which will have detected a loop: if we need to evaluate x in order to evaluate x, we're definitely looping)
23:32:12 <Cale> But in a threaded system, another thread might need to evaluate x during this process
23:32:19 <Cale> and we don't want it getting an exception
23:32:34 <bernalex> ok that's straightforward.
23:32:45 <Cale> So, the threaded runtime uses grey holes which wait for the value to finish computing (and use 0% cpu)
23:32:56 <bernalex> my code was something as overwhelmingly complicated as 'let a = a in a >> return ()' btw.
23:33:40 <Cale> I thought they were adding something to try to detect if any other threads were around and produce <<loop>> exceptions more often in the threaded runtime
23:41:43 <nshepperd> > let x = 1 + x in x
23:41:47 <lambdabot>  mueval-core: Time limit exceeded
23:42:09 <nshepperd> oh, I thought that would blackhole
23:58:30 * hackagebot http-media 0.4.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.4.0 (TimothyJones)
23:58:30 * hackagebot protobuf-native 1.0.0.0 - Protocol Buffers via C++  http://hackage.haskell.org/package/protobuf-native-1.0.0.0 (MaxwellSwadling)
