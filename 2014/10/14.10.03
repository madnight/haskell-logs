00:07:03 * hackagebot curlhs 0.1.2 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.2 (KrzysztofKardzis)
00:07:03 * hackagebot Win32-services-wrapper 0.1.2.0 - Wrapper code for making a Win32 service  http://hackage.haskell.org/package/Win32-services-wrapper-0.1.2.0 (GaneshSittampalam)
00:08:34 <trap_exit> is there any library that provides dep OSX bindings?
00:08:47 <trap_exit> I want something where I can write a haskel app, where when I press Ctrl-9, it intercept sht ekey code
00:08:57 <trap_exit> then it pops up a window, where I can typue in some command, and after evaluating it, it closes the window
00:09:08 <trap_exit> so I need to be able to write a haskell app that can "capture keys even when it's not focused"
00:09:12 <trap_exit> so it can listen to the C-9
00:09:14 <trap_exit> to know when to load itself
00:09:29 <trap_exit> (application: think a todo list --- I'm working, then I wnat to view my todo list, so I hit C-9, it displays some info
00:09:34 <trap_exit> I manip my dtodo list, and then the app vanishes)
00:20:58 <merijn> trap_exit: You can use the OSX accessibility API to do this (although it requires a user to give you access to said API, which is a hassle and requires a scary prompt), plus I don't think bindings for that exist in haskell, so you'd have to wrap the API yourself
00:21:28 <trap_exit> hmm
00:21:29 <merijn> trap_exit: It would be easier to write an installer to add a global keybinding + a service that starts your app when the user presses those keys
00:21:30 <trap_exit> I have ot write my own bindings
00:21:32 <trap_exit> outch
00:21:52 <trap_exit> merijn: does that require the app to restart every time the hotkey happens?
00:22:14 <merijn> trap_exit: No, you could spawn a daemon that runs in the background and have a new process connect to that daemon
00:25:50 <trap_exit> ah
00:25:52 <trap_exit> I like
00:38:37 <Saizan> are there tricks to reduce build times for a large project with ghc?
00:38:44 <Saizan> aside from -O0?
00:39:41 <jle`> Saizan: maybe turn on parallel compilation?
00:39:44 <jle`> ...
00:39:47 <jle`> is that a thing?
00:44:41 <Saizan> i don't think it's a thing within a single project yet
00:52:07 <Enigmagic> Saizan: ghc has some support for parallel builds with -j
01:34:52 <Biffsnadder> Hello, im searching for an app devolper. (ios)
01:35:11 <opqdonut> Using haskell?
01:35:12 <caulagi> Hello!  What am I missing here?
01:35:13 <caulagi> accumulate :: fn -> [a] -> [a]
01:35:13 <caulagi> accumulate fn [] = []
01:35:16 <caulagi> accumulate fn (x:xs) = (fn x):(accumulate fn xs)
01:35:44 <opqdonut> caulagi: the type signature is wrong, "fn" is just a single type variable
01:35:49 <Axman6> caulagi: fn is just a type variable, like a. you need (a -> b) instead of fn
01:35:53 <opqdonut> i.e. that type is equivalent to "b -> [a] -> [a]"
01:36:03 <Axman6> you've basically written b -> [a] -> [a]
01:36:08 <Axman6> heh
01:36:13 <opqdonut> accumulate :: (a -> a) -> [a] -> [a] is the type signature you want
01:36:24 <opqdonut> (or perhaps even accumulate :: (a -> b) -> [a] -> [b])
01:36:30 <Axman6> or, accumulate (a -> b) -> [a] -> [b]
01:36:36 <Axman6> damnit opqdonut :P
01:36:37 <opqdonut> echo echo echo :)
01:36:45 <Axman6> @quote stereo
01:36:45 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
01:36:48 <Axman6> @quote stereo
01:36:48 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
01:36:48 <caulagi> my first argument is a function - like toUpper
01:36:52 <Axman6> rarg
01:37:03 <Axman6> caulagi: yes, you need to say what type fn is
01:37:25 <Axman6> :t map
01:37:27 <lambdabot> (a -> b) -> [a] -> [b]
01:37:29 <Axman6> @src map
01:37:29 <lambdabot> map _ []     = []
01:37:29 <lambdabot> map f (x:xs) = f x : map f xs
01:38:17 <Axman6> map is a function which takes a function hich can accept things of some type a and return things of some type be, and a list of a's and return a list of b's
01:38:34 <Axman6> that's what map :: (a -> b) -> [a] -> [b] says, in english
01:38:47 <Axman6> uh, s/be/b
01:39:05 <caulagi> Axman6, lambdabot, opqdonut - thanks.  the map example is helpful.  Let me try that
01:39:22 <Axman6> caulagi: do you understand my explanation of what the type of map means?
01:39:47 <solarus> caulagi: map is a function in the standard library and not just an example
01:40:23 <caulagi> solarus: I just wanted the signature
01:40:30 <caulagi> Axman6: Not fully
01:40:44 <caulagi> the first argument to map is a function, right
01:40:54 <caulagi> so i am missing the distinction
01:41:04 <mauke> what distinction?
01:41:28 <caulagi> between say - map :: fn -> [a] -> [a]
01:41:43 <caulagi> and map :: (a -> b) -> [a] -> [b]
01:41:56 <mauke> :: b -> [a] -> [a] claims that the first argument can be any type at all
01:42:11 <mauke> it doesn't have to be a function
01:43:09 <mauke> map takes its first argument and applies it to list elements, so it has to be a function
01:43:25 <mauke> that causes a type error in the definition
01:43:46 <caulagi> mauke: I got that.  I am not sure how it is conveyed in the type signature of map.  The fact that first argument is a function
01:43:53 <mauke> that's the -> bit
01:44:07 <mauke> X -> Y is the type of a function that takes an X and results in a Y
01:45:46 <caulagi> mauke: got it.
01:45:48 <caulagi> thanks
02:26:17 <tomqq> hey all, i'm new to haskell and i've written the classic 'drawing program' where you make lines on a n x m array. I was really hoping someone could take a look at it on pastebin and show me how to refactor it (it works but I imagine is v far from idiomatic)
02:28:02 <bennofs> tomqq: people here probably prefer lpaste to pastebin (i head pastebin has some annoying ads)
02:28:05 <bennofs> @where lpaste
02:28:05 <lambdabot> http://lpaste.net/new/haskell
02:28:35 <lpaste> tomqq pasted “drawing program” at http://lpaste.net/111998
02:29:23 <tomqq> wow very cool. and has already found a million warnings
02:29:45 <tomqq> bennofs: thanks :)
02:31:28 <wei2912> https://bpaste.net/show/a33440676f38
02:31:38 <wei2912> whoops, misclicked paste instead of copy
02:34:59 <tomqq> is there an IDE that produces errors and warnings for you like lpaste does??
02:35:22 <bennofs> tomqq: there is a command-line program, hlint
02:35:26 <bennofs> @hackage hlint
02:35:26 <lambdabot> http://hackage.haskell.org/package/hlint
02:36:52 <tomqq> bennofs: awsm tyvm
02:38:27 <mayski> there's probably a plugin for your editor of choice that uses that, too
03:12:16 <wknapik> EHLO
03:12:42 <wknapik> $ cabal update
03:12:42 <wknapik> Downloading the latest package list from hackage.haskell.org
03:12:43 <wknapik> cabal: <file descriptor: 4>: resource exhausted
03:12:47 <wknapik> what's up with that ?
03:14:04 <mauke> try strace?
03:15:06 <wknapik> out of space on /
03:15:13 <wknapik> great error message ffs
03:18:26 <lpaste> tomqq revised “drawing program”: “No title” at http://lpaste.net/111998
03:22:31 <SwashBuckla> > let eachLine f = unlines . map f . lines
03:22:32 <lambdabot>  not an expression: ‘let eachLine f = unlines . map f . lines’
03:22:42 <SwashBuckla> > eachLine f = unlines . map f . lines
03:22:43 <lambdabot>  <hint>:1:12: parse error on input ‘=’
03:22:50 <SwashBuckla> oh?
03:23:16 <SwashBuckla> > :t unlines . map f . lines
03:23:17 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:23:23 <SwashBuckla> :t unlines . map f . lines
03:23:23 <lambdabot>     No instance for (FromExpr [Char]) arising from a use of ‘f’
03:23:24 <lambdabot>     In the first argument of ‘map’, namely ‘f’
03:23:24 <lambdabot>     In the first argument of ‘(.)’, namely ‘map f’
03:23:27 <SwashBuckla> oh dear
03:23:52 <bitonic> I'm trying to generate etags with ghci.  I've got an alex file Lex.x in my project.  When I give :etags I get "*** Exception: bnfc/Syntax/Raw/Lex.x: openFile: does not exist (No such file or directory)*
03:24:03 <bitonic> does anybody have an idea on what's going on?
03:24:40 <mauke> try strace?
03:25:28 <bitonic> I suppose I could
03:25:48 <Aruro> hi guys i have a question about wildcards why (x:_) and (_:x) are different? in first case _ will give you whole rest of the list while in second case it will be just first element? Why it is like that?
03:26:18 <mauke> er
03:26:22 <mauke> because of how : is defined
03:26:44 <Aruro> it is confusing since _ changes its meaning from being everything to being just one
03:26:51 <mauke> I think you're thinking of a list as a bunch of elements
03:26:54 <mauke> but that's not how it works
03:26:55 <bitonic> oh damn I'm on OS X now, linux laptop broken
03:27:08 <Aruro> who does it work ?
03:27:11 <Aruro> how
03:27:12 <mauke> a list is a pair (of an element and another list)
03:27:34 <mauke> (1 : (2 : (3 : [])))
03:27:37 <Aruro> so another list is always on the right side you mean?
03:27:40 <mauke> yes
03:27:45 <Aruro> k
03:27:47 <mauke> @src []
03:27:47 <lambdabot> data [] a = [] | a : [a]
03:28:00 <Aruro> at least this explains this unusual behaviour of _
03:28:27 <mauke> > case (42, "hello") of (_, x) -> x
03:28:28 <lambdabot>  "hello"
03:28:31 <mauke> > case (42, "hello") of (x, _) -> x
03:28:32 <lambdabot>  42
03:28:43 <mauke> here _ is a string or an integer
03:28:51 <mauke> ~magic~
03:29:02 <Aruro> ok so in your example _ does work as i expected
03:29:08 <Aruro> it always takes one element
03:29:15 <mauke> > case (1 : (2 : (3 : []))) of (x : _) -> x
03:29:17 <lambdabot>  1
03:29:22 <mauke> > case (1 : (2 : (3 : []))) of (_ : x) -> x
03:29:24 <lambdabot>  [2,3]
03:29:38 <mauke> in the second case x gets bound to (2 : (3 : []))
03:29:49 <Aruro> ok i think its clear now
03:30:01 <Aruro> ty so the whole problem it the definition of list
03:30:07 <mauke> yeah
03:30:12 <Aruro> if i will use it on tuple instead i will get desired action
03:30:14 <Aruro> clear
03:30:33 <Aruro> where _ will be on equal footing with x from your example
03:30:44 <mauke> > case (1, (2, (3, ()))) of (x, _) -> x
03:30:46 <lambdabot>  1
03:30:47 <Aruro> each representing a fixed amount of elements (1 in our case)
03:30:50 <mauke> > case (1, (2, (3, ()))) of (_, x) -> x
03:30:52 <lambdabot>  (2,(3,()))
03:31:21 <Aruro> yes
03:31:27 <Aruro> here its effectively one tuple
03:31:38 <Aruro> but assume something like  (1,2,3,4,5,6)
03:32:20 <mauke> in that case the numbers are all at the "top level" of the tuple
03:32:27 <Aruro> yes
03:32:28 <mauke> there's no way to do that with a list
03:32:46 <Aruro> yeah
03:33:01 <Aruro> this was a problem not pointed out in lhfygg
03:33:04 <Aruro> book
03:34:03 <Aruro> ty
03:34:20 <Aruro> u really cleared this point for me
03:34:29 <Aruro> so _ always means one element
03:34:43 <Aruro> just in lists it happens to mean many sometimes
03:34:56 <Aruro> cause of leveling
03:35:12 <mauke> _ in patterns behaves like a nameless variable
03:35:24 <Aruro> yes
03:35:29 <mauke> it "eats" a value but doesn't bind it
03:36:02 <Aruro> yes
03:36:08 <Aruro> it can be easier
03:36:13 <Aruro> (x:y)
03:36:24 <Aruro> case will give same assymetry
03:36:30 <Aruro> between x and y
03:36:34 <Aruro> for the lists
03:36:55 <Aruro> as u pointed out because of nested structure
03:37:25 <mauke> > case "asdf" of (x : y) -> (x, y)
03:37:26 <lambdabot>  ('a',"sdf")
03:37:45 <Aruro> yes
03:39:02 <Aruro> no i actually made mistake
03:39:09 <Aruro> this does not demonstrate this assymetry :D
03:39:13 <Aruro> which is even more interesting
03:39:19 <Aruro> only wildcard does
03:39:35 <Aruro> because in case of the names it will just exchange positions
03:39:59 <Aruro> really the assymetry is in construction (_:x) vs (x:_)
03:40:29 <Aruro> where x and _ change from being many elemet lists to being just one element
03:40:37 <doismellburning> :t (:)
03:40:38 <lambdabot> a -> [a] -> [a]
03:41:17 <Aruro> so pattern mathcing goes level by level
03:41:29 <Aruro> and at the top level of lists it produces this behaviour
03:41:35 <Aruro> right?
03:42:28 <Aruro> thanks for help mauke
03:42:36 <Aruro> u solved my question
03:43:20 <Aruro> > case "asdf" of (x : y : z) -> (x, y, z)
03:43:21 <lambdabot>  ('a','s',"df")
03:43:51 <Aruro> > case "asdf" of (x : _ : z) -> (x,  z)
03:43:52 <lambdabot>  ('a',"df")
03:44:06 <Aruro> > case "asdf" of (x : _ :_ : z) -> (x,  z)
03:44:07 <lambdabot>  ('a',"f")
03:44:27 <Aruro> > case "asdf" of (x : _ : z : _) -> (x,  z)
03:44:28 <lambdabot>  ('a','d')
03:45:02 <Aruro> > case "asdf123123123234234" of (x : _ : z : _ : y) -> (x,  z, y)
03:45:03 <quchen> A list is literally either an empty list, or "element, then a colon, then another list".
03:45:04 <lambdabot>  ('a','d',"123123123234234")
03:45:20 <Aruro> yes
03:45:29 <Aruro> thank you that really clears it up
03:45:45 <quchen> (:) is right-associative. Everything else follows from those things.
03:45:46 <Aruro> the whole point was to demonstrate that _ always takes just one element
03:46:01 <Aruro> just this one element happens to be a list
03:46:05 <quchen> _ is not special. "x" is semantically equivalent to "_" in a pattern when you don't use it on the RHS.
03:46:14 <Aruro> yes
03:46:20 <Aruro> true
03:46:30 <quchen> (x:xs) is the same as (x:_) and (x:_xs) as much as pattern matching is concerned.
03:46:50 <quchen> Pattern *matching* I mean :-)
03:47:00 <Aruro> in (x:_xs) wildcard is part of name?
03:47:24 <quchen> You can give your underscores names if you want, which makes it clearer which part of a pattern is discarded.
03:47:34 <doismellburning> quchen: TIL, thanks
03:48:00 <quchen> It's particularly useful in "case" blocks, where I like to write "_else" instead of just "_" because it's easier to see.
03:48:06 <mauke> you_can_use_underscore_in_names
03:48:18 <quchen> I think "_" counts as a letter in Haskell.
03:48:27 <Aruro> let me think
03:48:50 <Aruro> if i use (_:x) x will be the last element of the list right?
03:49:04 <Aruro> no
03:49:05 <quchen> What I do know is that the Report says "When a pattern is matched but not used, the compiler should warn, unless the pattern starts with an underscore."
03:49:06 <Aruro> sorry
03:49:14 <Aruro> it will be whole list except first element
03:49:35 <quchen> There is no whole list, there is always only "head of list and rest of list", maybe many times repeatedly.
03:49:54 <Aruro> yes so lets see like this 1:2:4:5:[]
03:50:17 <Aruro> than the (_:x) should give me 5 for the x right?
03:50:20 <Aruro> then*
03:50:24 <quchen> With parentheses that is 1 : (2 : (4 : (5 : [])))
03:50:29 <quchen> Now match that against (_:x)
03:50:37 <vanila> no
03:50:40 <Aruro> ok so parentheses are important
03:50:41 <ChristianS> Aruro: no, x will be the tail of the list, i.e. everything except the first element
03:50:43 <Aruro> i got it
03:50:49 <Aruro> yesyes
03:50:50 <Aruro> i see it now
03:50:53 <vanila> pattern  matching acnt find the last
03:50:59 <Aruro> whole problem lies in parentheses
03:51:14 <quchen> As I said, (:) is right-associative.
03:51:20 <Aruro> yes :)
03:51:21 <quchen> (It couldn't typecheck the other way.)
03:51:25 <Aruro> you said that i did not hear :D
03:51:26 <Aruro> ty
03:52:04 <Aruro> > 1:2:3:[]
03:52:06 <lambdabot>  [1,2,3]
03:52:19 <Aruro> hm
03:52:42 <exio4> > case [1,2,3,4,5] of (_:xs) → xs
03:52:43 <lambdabot>  [2,3,4,5]
03:52:48 <Aruro> sorry but why do we need parentheses? lambda bot accepts above?
03:52:57 <quchen> 1 : (2 : (3 : [])) = 1 : (2 : [3]) = 1 : [2,3] = [1,2,3]
03:53:00 <Iceland_jack> Aruro: You don't need parentheses
03:53:01 <Aruro> he accepted my notation of just 1:2:3:[]
03:53:05 <Iceland_jack> Because (:) is right-associative
03:53:06 <ChristianS> > (head . reverse) [1,2,3,4,5]
03:53:07 <lambdabot>  5
03:53:21 <Aruro> ok im thinking :D
03:53:40 <Iceland_jack> If (:) were left-associative, it would parse
03:53:40 <Iceland_jack>     1:2:3:4:[]
03:53:40 <Iceland_jack> as
03:53:40 <Iceland_jack>     (((1:2):3):4):[]
03:53:43 <Iceland_jack> which doesn't type check
03:53:44 <solarus> Aruro: parentheses was added to show that 1 : (2 : []) is the same as 1 : 2 : []
03:54:02 <Aruro> so parentheses are important in pattern matching algorythm
03:54:07 <Iceland_jack> no
03:54:13 <Aruro> no?
03:54:24 <Aruro> i mean how to detemine the level for expression?
03:54:35 <quchen> Parentheses are important for the parser.
03:54:42 <Aruro> in case of matching (_:x) vs (x:_)
03:54:46 <quchen> Let's say "parentheses are important for what your code means".
03:54:47 <vanila> Aruro, thnk of patterns as data
03:55:04 <vanila> > case Just 3 of Just x -> x
03:55:06 <lambdabot>  3
03:55:09 <bitonic> mauke: so yeah, I get a nice "open("Lex.x\0", 0x20004, 0x1B6)		 = -1 Err#2" in the trace
03:55:13 <bitonic> and Lex.x is not there
03:55:15 <vanila> > case Just (3, "foo") of Just (y,x:z) -> x
03:55:17 <lambdabot>  'f'
03:55:19 <bitonic> curiously it's the only file it tries to open
03:56:45 <Aruro> ok guys
03:56:49 <Aruro> i think i finally got it
03:56:56 <Aruro> pattern matching of (x:_)
03:57:06 <Aruro> just searches of the first left most operator : right?
03:57:19 <Aruro> and that gives this behaviour
03:57:33 <vanila> yes
03:57:50 <Aruro> as quchen said before because : is right associative
03:58:01 <vanila> > case Just (3, [Just 'f', Just 'o']) of Just (y, Just x:z) -> x
03:58:02 <lambdabot>  'f'
03:59:17 <Aruro> ok thank you all so pattern matching is bindede to OPERATOR it tries to match and corresponding arguments of that operator(function)
04:00:28 <chrisdone> hey quchen =)
04:12:32 <bitonic> mauke: found the problem, basically the thing that generate etags picks up on LINE pragms
04:12:44 <bitonic> but those LINE pragmas might refer to files that are not reachable anymore
04:18:02 <bitonic> now I guess it makes sense to try and open such files
04:56:14 <bitonic> so I'm using haskell-mode interactive mode
04:56:35 <bitonic> and it seems really nice, the only problem is that when I hit C-cC-l it seems to recompile everything
04:56:56 <bitonic> is there a command to reload the file?
05:03:15 <bitonic> found it, you need to set this haskell-reload-p variable
05:05:25 <bitonic> or use C-uC-cC-l.  nice
05:19:26 <aleator__> Anyone teach Haskell here?
05:19:38 <wei2912> aleator__: most likely
05:20:22 <aleator__> wei2912: Well, perhaps I should've asked if there is anyone who does and wouldn't mind chatting about that a little bit.
05:20:44 <aleator__> I have few students in my course, who, unlike the majority, really can't get a grasp of the syntax.
05:20:49 <wei2912> ah, i see
05:21:39 <aleator__> I really get that Haskell has slightly beginner hostile syntax, but I was wondering if others have an explanation why that hits some pupils so much harder than others
05:22:12 * hackagebot http-conduit-downloader 1.0.21 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.21 (VladimirShabanov)
05:22:23 <doismellburning> aleator__: I don't mean to do "that thing", but er, "beginner hostile syntax"?
05:23:34 <aleator__> doismellburning: Well, it has lot more more syntactic constructs than python/java and lacks helpful signposts such as parenthesis around function arguments. That is, it seems harder for the beginner to read than simple java.
05:28:32 <Fuuzetsu> I think what you're actually trying to say is that ‘it doesn't read like Java which I already know’
05:29:18 <exio4> Lisp has no syntax and it looks scary for a lot of people too
05:29:23 <aleator__> Fuuzetsu: Not at all. I've been doing Haskell for some ten years and teaching it for four and syntax is hard.
05:29:39 <aleator__> It has bit the same problem as scheme/lisp in that everything looks the same for a beginner.
05:29:55 <Fuuzetsu> exio4: saying that Lisp has no syntax just sounds stupid
05:29:58 <bennofs> Maybe it's because java is based more on keywords, while in haskell you have more special symbols / constructs for syntax
05:30:27 <aleator__> As an example thing that I see hundreds of times is something like 'sum x:xs = x + sum xs'
05:30:33 <exio4> Fuuzetsu: you're just writing an AST
05:30:41 <Fuuzetsu> so? it's still syntax
05:30:43 <Fuuzetsu> exio4: http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html
05:30:44 <aleator__> exio4: reader macros?
05:30:47 <Fuuzetsu> wow, look at all that no syntax!
05:31:01 <Saizan> Fuuzetsu: no need to be that confrontational about it
05:31:04 <vanila> aleator__, just tellt hem that function application binds tighter than operators
05:31:15 <aleator__> vanila: Doesn't help :)
05:31:24 <exio4> I was over-exaggerating, obviously :P
05:31:34 <Fuuzetsu> please don't exaggerate like that ;P
05:31:41 <vanila> aleator__, ?
05:32:19 <aleator__> vanila: If I tell them to, say, identify the principal operator of an expression or draw an ast, they mostly get it correct. But when they write code..
05:32:23 <aleator__> not so much
05:32:53 <bennofs> aleator__: in your example, do you mean students often forgot parentheses around x:xs when pattern matching?
05:33:26 <aleator__> bennofs: Yes, consistently. And not just in pattern matching but in other places too
05:33:50 <aleator__> Such as doing `total = sum xs ++ ys`
05:33:56 <bennofs> aleator__: just tell them to always surround patterns by parentheses?
05:34:49 <Fuuzetsu> aleator__: I struggle to understand how Java doesn't have this problem
05:34:52 <bennofs> aleator__: it's really kind of confusing that you can omit the parentheses in let x:xs = [1,2,3], but not when pattern matching.
05:35:06 <aleator__> bennofs: I did that in case of :, but do you mean that I'd write examples so that each parameter is in parenthesis?
05:35:12 <vanila> bennofs, let is keyword, where as sum x is a function application
05:35:21 <Fuuzetsu> is it because foo(x) + z rather than foo (x + z)
05:35:39 <aleator__> Fuuzetsu: compare: haskell: atan2 x i+j vs. java: atan2(x,i+j)
05:35:48 <Fuuzetsu> they are two different functions
05:35:59 <vanila> with syntax coloring it will be easier to see
05:36:18 <aleator__> Since there is no currying etc. in Java you get this regular syntax with separators, which you kindof trade away to get the nice things in Haskell
05:36:30 <Fuuzetsu> you can define atan2 to take a pair if you want to
05:37:01 <Fuuzetsu> in Haskell you get this nice syntax without spurious separators everywhere ;P
05:37:34 <aleator__> Fuuzetsu: Yes. I like that. But it is hostile for newbies, atleast if I can't figure out a better way of explaining it.
05:37:53 <Fuuzetsu> I think it's just different rather than hostile
05:38:09 <aleator__> Fuuzetsu: I've toyed with an idea of uncurrying everything in prelude, but at that point I could just start using pyret or something else.
05:38:25 <Fuuzetsu> if you want things to be grouped together then put parenthesis around the groups, that's pretty simple
05:38:51 <aleator__> Fuuzetsu: I'd go as far as to claim that it is more difficult than java-like parenthesis around all arguments, commas in between.
05:38:52 <Saizan> aleator__: i had to learn lisp before haskell, because at the time no haskell tutorial explained how to use parentheses, maybe that could work for your students too :)
05:39:11 <aleator__> Saizan: Heh :)
05:40:20 <aleator__> Perhaps I should just start overparenthesising everything during early part of the course..
05:41:02 <Fuuzetsu> maybe parenthesis when operators are present would be sufficient
05:41:08 <Fuuzetsu> and skip $
05:41:10 <Saizan> i think it really helps to think of functions as something on their own, rather than "function calls"
05:41:26 <aleator__> Fuuzetsu: Skipping the $ and . early on is a lesson I learned the hard way :)
05:41:52 <Fuuzetsu> you'd have no such issues if you taught it all in point-free style!
05:42:06 <Fuuzetsu> you might have other issues of course
05:42:14 <leo_h> hey guys, why there are so many regexp libraries in haskell but only several cover all regexp possibilities? And is there any 'standard' regexp lib?
05:42:26 <Fuuzetsu> regex-tdfa
05:43:06 <Fuuzetsu> I don't know what you mean by ‘all regexp possibilities’, there are so many different ‘regular’ expression engines that it's insane to expect a library to even try and cover a considerable fraction
05:43:31 <Fuuzetsu> the standard lib for the standard regex is regex-tdfa
05:44:00 <leo_h> thanks :)
05:44:06 <aleator__> Saizan: That's one of the things that's really nice to teach people coming from java. As a silly exercise we compute 'unwords . map reverse . words' with pen and paper and then take away the pen when the student (always) adds a string at the end of the expression.
05:44:19 <Fuuzetsu> actually, regex-base seems to import regex-tdfa and all the other little libs so you probably want that
05:45:07 <leo_h> Can regex-tdfa do substitution with grouping? Ex.: replace "(<)=" with "(1) = "
05:46:29 <Fuuzetsu> probably
05:46:45 <Fuuzetsu> pretty sure it has groups
05:48:45 <asfp> is there something like safecopy that works with the binary package?
05:49:12 <Fuuzetsu> What would it do?
05:50:01 <asfp> handle versioning, schema changes.
05:51:50 <eikke> anyone knows whether there's some binding for 'access' (the syscall) in base?
05:54:11 <joehh> is this a suitable forum for questions about using bytestring?
05:55:44 <leo_h> joehh, if you has a question, just ask )
05:57:36 <joehh> according to the hackage docs, BL.unpack (import qualified Data.ByteString.Lazy.Char8 as BL) should have type ByteString -> [Word8], but when I check using cabal repl, I get a type BL.ByteString -> [Char]
05:57:55 <joehh> Is this because I have overloaded strings or something similar?
05:59:23 <asfp> joehh: I thought it was the elements of the ByteString that were Word8.
05:59:40 <joehh> that was what I thought
05:59:59 <joehh> I'm using ghc 7.8.3 on debian with the latest haskell platform
06:00:10 <asfp> no, I mean, I expect BL.unpack to return [Char], because it has nothing to do with what the ByteString is composed of.
06:00:42 <tomqq> has anyone done bucket fill in a 'drawing program' before? where you fill every neighbouring pixel with a colour. I just CANNOT get my head round how to do it in haskell
06:00:54 <mauke> joehh: what docs?
06:01:43 <joehh> I'm reading from https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#v:unpack
06:01:55 <mauke> that's not .Char8
06:02:27 <sbrg> tomqq: depends on your representation of the image(probably some kind of a 2d array?) -- you'd want to color all pixels of the same color that are adjacent to it and those adjacent to those etc..
06:02:32 <wei2912> how do i define Sublist(Equal, Sublist, Superlist, Unequal)
06:02:57 <tomqq> sbrg: yes exactly that, but I can't think how to implement it. I can link you to what I've got so far?
06:03:07 <sbrg> tomqq: sure
06:03:24 <joehh> mauke: I'm sorry, but I don't understand your last reply
06:03:39 <lpaste> tomqq revised “drawing program”: “drawing program” at http://lpaste.net/111998
06:03:53 <tomqq> can you see that?
06:04:09 <tomqq> sbrg: much appreciated btw
06:04:15 <mauke> joehh: you're using module A while reading the documentation of module B
06:04:16 <joehh> I'm trying to convert the bytestring to a list of word8 to then xor each successive word8 against each other
06:04:41 <sbrg> tomqq: your image is a [String]?
06:04:49 <joehh> mauke: now i see
06:05:13 <tomqq> sbrg: yeah it's just a list of strings that gets outputted
06:05:34 <sbrg> tomqq: I see. The problem with this representation is that you don't have constant time random access
06:05:35 <tomqq> e.g. ["ooooo\n", "xxoox\n"]
06:05:42 <joehh> thanks mauke (and others)
06:05:51 <sbrg> that is, it is possible to 'index into' lists, but it is O(n) and it will be really inefficent done repeatedly.
06:06:17 <tomqq> how should I represent it instead?
06:06:31 <sbrg> tomqq: an Array or Vector would be good choices.
06:06:42 <sbrg> As for the logic, it isn't so hard. Let me write something up, sec
06:06:48 <sbrg> (logic for bucket fill)
06:06:49 <tomqq> sbrg: thank you so much :)
06:08:34 <joehh> thank you all again - back to making progress
06:19:42 <sbrg> tomqq: https://gist.github.com/saevarb/1ad2823cac343222f702
06:19:46 <sbrg> here is the general idea
06:19:48 <sbrg> anyway
06:20:23 <sbrg> A lot of those functions are just 'general ideas' in that they depend on the underlying datatypes that you use to represent the pictures. Array, Vector, whatever.
06:20:42 <sbrg> but the logic is sound, I believe.
06:22:00 <sbrg> You would use that function on the coordinate where you want to 'bucket color' from and get a list of coordinates that are the same color as the original. You would then repeatedly apply this function to those coordinates to generate more, etc, until you find no more new pixels that have the same color.
06:22:14 <sbrg> Oh, you probably also want to not include the original coordinate.
06:22:27 <ben_vulpes> what does a type declaration with multiple types after the equal sign imply?
06:22:34 <ben_vulpes> type Foo = Bar Baz Quux
06:22:38 <sbrg> I really need to run now, though. good luck.
06:22:50 <tomqq> sbrg: thanks a lot !!! Very useful stuff
06:31:22 <wei2912> 21:22 < wei2912> import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)
06:31:25 <wei2912> 21:23 < wei2912> what's the "Sublist(Equal, Sublist, Superlist, Unequal)" thing called? :P
06:31:28 <wei2912> sorry for the rather noobish question :P
06:32:25 <nulpunkt> Hi, I'm trying to extract the headers from a Request in a Snap application, I've tried with the getHeader and header function, but to no avail. Given i have the request how do i get the acompanying headers
06:32:29 <nulpunkt> ?
06:38:00 <seye> is a z-combinator the same as an applicative order y-combinator?
06:44:24 <vanila> seye, what ddo you mean the same?
06:44:45 <nulpunkt> nm, I'm an idiot :)
06:46:21 <seye> are they different words for the same thing
06:46:25 <seye> ?
06:47:03 <vanila> seye, where are you reading "applicative order y combinator"? I could find z combinator on wikipedia but not this one
06:47:30 <vanila> oh i found it here and these are exactly the same http://people.csail.mit.edu/namin/writings/y_combinator.html  you acn tell by comparing them
06:47:51 <vanila> http://lpaste.net/112012
06:48:03 <wei2912> 21:22 < wei2912> import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)
06:48:07 <wei2912> 21:23 < wei2912> what's the "Sublist(Equal, Sublist, Superlist, Unequal)" thing called? :P
06:48:19 <vanila> it didn't eta expand the first inner lambda but that's not important
06:48:29 <wei2912> just to repeat the question again. thanks in advance!
06:49:05 <seye> vanila: i was reading this - http://mvanier.livejournal.com/2897.html
06:49:20 <seye> i've also since had it confirmed that they refer to the same thing
06:53:07 <wknapik> i want to build shellcheck as a static binary, using cabal. i ran `cabal configure -f "-O9 -optl-static -optl-pthread --make" && cabal build', but my flags were not passed to ghc at all. then i read up on cabal a bit and it seems i should run `cabal configure -fO9 -foptl-static -foptl-pthread -fmake -v && cabal build', but those flags were not passed to ghc either.
06:53:12 <wknapik> any hints ?
06:55:09 <wknapik> :/
07:01:08 <vanila> http://axisofeval.blogspot.co.uk/2014/06/attack-of-monadic-morons.html
07:01:27 <vanila> that's so dumb
07:01:43 <sagittarian> @src (++)
07:01:44 <lambdabot> []     ++ ys = ys
07:01:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:01:44 <lambdabot> -- OR
07:01:44 <lambdabot> xs ++ ys = foldr (:) ys xs
07:01:55 <sagittarian> ah there we go
07:02:16 * hackagebot cluss 0.1 - Simple Alternative to Type Classes  http://hackage.haskell.org/package/cluss-0.1 (Kinokkory)
07:02:24 <sagittarian> @pl \xs ys -> foldr (:) ys xs
07:02:25 <lambdabot> flip (foldr (:))
07:15:44 <tromp> flip (++) == foldr (:)
07:20:38 <sagittarian> > flip (++) == foldr (:)
07:20:40 <lambdabot>  No instance for (GHC.Classes.Eq ([a0] -> [a0] -> [a0]))
07:20:40 <lambdabot>    arising from a use of ‘GHC.Classes.==’
07:26:37 <zwer> vanila article was deleted
07:26:55 <vanila> yeah
07:27:05 <augur> :t flip (++)
07:27:06 <lambdabot> [a] -> [a] -> [a]
07:27:09 <vanila> delete article, calling people morons
07:27:11 <augur> :t foldr (:)
07:27:13 <lambdabot> [a] -> [a] -> [a]
07:27:17 <vanila> not healthy
07:27:31 <augur> oh, yes, they're equal
07:27:34 <vanila> oh augur i saw something that maybe very interesting to you
07:27:51 <augur> well, not flip (++) but just (++)
07:27:59 <augur> sagittarian: (++) = foldr (:)
07:28:06 <sagittarian> there is something deeply wrong with the order of the arguments of foldr that we have to flip them to get (++)
07:28:23 <sagittarian> otherwise that would just be amazingly elegant
07:28:28 <vanila> http://www.cs.uu.nl/foswiki/pub/Center/CompilerConstructionInHaskell/C11-AG-icfp2012.pdf these slides describe how to use Attribute Grammars as an alternative way to solve that problem about only giving some cases of folds
07:28:31 <augur> > (++) [1,2,3,4] [5,6,7,8]
07:28:32 <lambdabot>  [1,2,3,4,5,6,7,8]
07:28:42 <augur> oh no you're right it's flipped, yes
07:28:42 <augur> haha
07:28:52 <sagittarian> > foldr (:) [1..4] [5..8]
07:28:54 <lambdabot>  [5,6,7,8,1,2,3,4]
07:28:54 <augur> no that makes sense
07:29:22 <augur> i mean, personally i'm not a fan of the order of foldr's arguments in general -- i think base case should be first
07:31:45 <augur> vanila: hm. ill give it a look
07:32:04 <tromp> both foldr and ++ have the correct order of arguments
07:32:34 <tromp> that doesn't mean you expressing one in terms of the other should avoid flips
07:32:42 <augur> tromp: why do you like the order of foldr?
07:33:11 <tromp> because the most variable argument comes last
07:33:25 <augur> im not sure what you mean
07:33:42 <vanila> @src []
07:33:42 <lambdabot> data [] a = [] | a : [a]
07:33:45 <tromp> man y useful functoins can be defined as foldr f z
07:33:50 <vanila> according to this [] case should come first
07:33:58 <augur> tromp: no no i mean i would prefer   foldr z f
07:34:00 <sagittarian> ah okay that's a good point
07:34:09 <vanila> I would match the foldr exactly to the data type definition
07:34:30 <augur> im ok with the cased argument last, since foldr is supposed to be combinator-y
07:34:30 <sagittarian> what is the data type definition?
07:34:32 <vanila> that doesn't mean we shouldn'tchange the data type definition to put (:) first
07:34:41 <vanila> saggitarian: data [] a = [] | a : [a]
07:34:51 <augur> i just prefer it when the fold's match the declarations
07:34:58 <vanila> fold can be considered to come systematically form data type definition
07:35:16 <augur> vanila: not merely "can be" but "definitely does"
07:35:37 <vanila> augur, Currently in haskell we have to write them all out by hand
07:35:42 <augur> so much so that, at least for regular data types, you can derive fold automatically!
07:36:09 <augur> vanila: well yes, thats because haskell doesn't have very good support for this stuff yet
07:36:19 <augur> Epigram 2 has all folds defined automatically
07:36:22 <augur> actually thats not true
07:36:26 <tromp> foldr f z is preferable to foldr z f; since foldr f is more likely to be useful than foldr z
07:36:32 <augur> it defines one fold, which is generic to *all* data types
07:36:53 <tromp> foldr (:) being one example
07:37:08 <augur> tromp: thats possible. tho i find myself writing out both args often
07:37:14 <augur> and it would be _very_ useful to just be able to write
07:37:19 <augur> foldr base $ \x xs -> step
07:37:40 <nkar> cabal install --only-dep fails for one package.  I need to install it with a certain flag to solve that.  will cabal install -f package-name-version do the right thing or break the dependencies?
07:37:57 <tromp> no more useful than foldr  (\x xs -> step) base
07:38:03 <augur> way more useful
07:39:29 <augur> the base-first order makes it easier to read whats going on with foldr when you have both cases
07:40:09 <augur> tho i guess i should just define aux functions. folds are nice in theory, but thats where they belong sort of
07:40:17 <tromp> this is of less concern than ability to leave base case out entirely
07:40:35 <augur> i disagree
07:40:50 <tromp> indeed we'll just have to disagree on that:(
07:44:02 <vanila> Attribute Grammars
07:44:22 <vanila> http://www.cs.uu.nl/foswiki/pub/Center/CompilerConstructionInHaskell/C11-AG-icfp2012.pdf
07:44:30 <augur> vanila: so what about AGs do you think is relevant to the partial-homomorphism thing?
07:44:47 <vanila> it's a different way to solve that problem
07:45:19 <augur> but how
07:45:41 <vanila> slide 31 to 50 shows what they are, slide 76 about default rules
07:46:03 <tromp> this month's Ponder This is easy t do in haskell : What are the last 10 decimal digits of 2^(3^(4^(5^(6^(7^(8^9))))))?
07:47:33 <mmachenry> Is that easier to do in Haskell than most other programming languages?
07:48:01 <augur> vanila: mm. im not sure thats quite the same
07:48:20 <exio4> > take 10 . reverse . show $ (2^(3^4))
07:48:22 <lambdabot>  "2532149438"
07:49:17 <vanila> How would I know if i got the correct answer
07:49:19 <Hodapp> are bignums a lazy structure or something?
07:49:25 <tromp> well, it fits well with haskell's pure functions
07:49:36 <vanila> tromp: I expect I should use Eulers totient function?
07:50:11 <tromp> exactly, vanila (or in this case, a specialized version for 2&5 powers)
08:05:34 <caulagi> hello - where can I see the functions defined in, say, Data.List on my system?
08:06:01 <mmachenry> Google for "data.list"
08:06:01 <mmachenry> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html
08:06:55 <caulagi> mmachenry: on my local machine?  I am using Ubuntu
08:06:59 <caulagi> from ppa
08:10:58 <ClaudiusMaximus> caulagi: in ghci, :m + Data.List  then   :browse
08:12:48 <CXXVIIta> Is there a way to "loop" over enum data structure? Such that calling 'successor' on the last label would return the first label
08:13:02 <CXXVIIta> and vice versa for predecessor on the first label would return the last label
08:14:17 <mmachenry> CXXVIIta: I tried doing that once. I ended up writing a circular function.
08:14:31 <mmachenry> CXXVIIta: It needs to be of type class Bounded.
08:14:57 <mmachenry> Then you check to see if the item == maxBound. If so you return minBound othersise succ(item)
08:15:00 <CXXVIIta> Ok, I'm deriving bounded as well. Could you elaborate on this circular function?
08:15:00 <RchrdB> You could do so by writing a pair of functions that check whether the input is minBound/maxBound. You need the Bounded typecast.
08:15:06 <CXXVIIta> ah
08:15:25 <RchrdB> *typeclass
08:15:35 <mmachenry> next item = if item == maxBound then minBound else succ item
08:15:54 <mmachenry> next :: Bounded a => a -> a
08:16:14 <mmachenry> And it needs to be bounded and enum I guess.
08:16:22 <CXXVIIta> makes sense, cheers.
08:17:16 <RchrdB> > let next x = if x == maxBound then minBound else succ x in iterate next (252::Word8)
08:17:18 <lambdabot>  [252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,...
08:19:02 <tromp> > drop 252 $ cycle [minBound..maxBound] :: [Word8]
08:19:04 <lambdabot>  [252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,...
08:20:44 <wknapik> any hints on building a project with cabal, with musl instead of glibc ? how should i modify the .cabal file ?
08:21:19 <caulagi> ClaudiusMaximus: thanks, just what I needed.  Can I see individual function definition also?
08:24:37 <ClaudiusMaximus> caulagi: not in ghci
08:25:34 <Rags> I am stuck on a simple thing and need help.. I have a function to remove a string from a string. however i am getting an extra space. remove "the" "this is the string." -> "this is string."; however myoutput is "this is  string" with an extra space before string
08:25:57 <caulagi> ClaudiusMaximus: any other option?  Local would be good
08:27:13 <ClaudiusMaximus> caulagi: maybe there's a doc package with documentation that might also have hyperlinked source, otherwise get the source package (which will probably contain vastly more than you need, like the compiler source code)
08:27:33 <caulagi> ClaudiusMaximus: thanks
08:28:05 <caulagi> One more question - how can I say whether a function definition is 'private' or 'public'?  Can I tell by looking at the signature onlY
08:28:13 <caulagi> are there some conventions?
08:29:07 <rudi_s> Hi. I'm looking at Data.Time.Format which uses TimeLocale. But defaultTimeLocale seems to be not localized. Is there a way to get a TimeLocale with localized names?
08:29:09 <ClaudiusMaximus> caulagi: either everything is exported , or the exports are explicitly listed in the module declaration at the top of the source file
08:30:16 <Aruro> guys
08:30:42 <Aruro> how can i translate ["1","2","3"] into "123"
08:30:53 <Rags> :t concat
08:30:53 <lambdabot> [[a]] -> [a]
08:30:56 <Aruro> first one is a list of strings
08:31:02 <fryguybob> > unwords . filter (/="the") . words $ "This is the string."
08:31:03 <lambdabot>  "This is string."
08:31:21 <Aruro> ty
08:31:22 <Aruro> rags
08:31:26 <Rags> concat ["1","2","3"]
08:31:43 <wei2912> is there an ideal way to convert a boolean into an integer?
08:31:44 <Aruro> > concat ["1","2","3"]
08:31:45 <lambdabot>  "123"
08:31:46 <Pure> Hi!
08:31:48 <wei2912> True -> 1, False -> 0
08:31:54 <Aruro> ty
08:31:57 <exio4> fromEnum_
08:32:01 <exio4> > fromEnum 1 ∷ Bool
08:32:02 <Aruro> again concat is what i needed
08:32:03 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
08:32:03 <lambdabot>              with actual type ‘GHC.Types.Int’
08:32:08 <wei2912> with some built-in function
08:32:13 <exio4> eh
08:32:16 <vanila> if b then 1 else 1
08:32:20 <exio4> > fromEnum True ∷ Int
08:32:22 <lambdabot>  1
08:32:27 <exio4> > fromEnum False ∷ Int
08:32:29 <lambdabot>  0
08:32:33 <wei2912> exio4: thanks!
08:32:47 <exio4> you don't need the type annotation
08:33:08 <Rags> thanks fryguybob
08:33:28 <Pure> I'm trying to list all possible rolls of a 4d6 (or xdy for all intents and purposes), what would be a way to do so?
08:34:23 <exio4> > do { d1 ← [1..6]; d2 ← [1..6]; d3 ← [1..6]; return (d1,d2,d3); }
08:34:25 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,2,1),(1,2,2),(1,2,3),(1,...
08:34:49 <exio4> > [ (d1,d2,d3) | d1 < [1..6], d2 ← [1..6], d3 ← [1..6] ]
08:34:51 <lambdabot>  Not in scope: ‘d1’
08:34:51 <lambdabot>  Perhaps you meant one of these:
08:34:51 <lambdabot>    ‘d’ (imported from Debug.SimpleReflect),
08:34:51 <lambdabot>    ‘_1’ (imported from Control.Lens)Not in scope: ‘d1’
08:34:51 <lambdabot>  Perhaps you meant one of these:
08:35:01 <ClaudiusMaximus> > replicateM 4 [1..6]
08:35:03 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,1,6],[1,1,2,1],[1,1,...
08:35:04 <exio4> oops, well
08:35:18 <Pure> Okay, so it is possible to do it as a 1 liner
08:35:55 <ClaudiusMaximus> Pure: there remains the question whether 1 2 2 3 is distinct from 1 2 3 2 etc
08:37:22 * Pure believes that permuations would be what he wants, since they're seperate events (ish)
08:38:25 <Pure> If I wanted combinations though?
08:40:04 <lf94> I almost feel like I could create nearly anything in Haskell in a fraction of a time than other programming languages
08:40:26 <ClaudiusMaximus> > filter (\xs -> xs == sort xs) $ replicateM 2 [1..6]  -- Pure, this picks a canonical ordering and discards other permutations
08:40:28 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[2,2],[2,3],[2,4],[2,5],[2,6],[3,3],[3,...
08:42:32 <argent0> combinations n (x:xs) = [h:y | h ← (x:xs), y ← (combinations (n-1) (coset h (x:xs)))] where coset h (x:xs) = tail (dropWhile (≠h) (x:xs))
08:46:05 <Rags> filter (/="the") ["this"," ","is"," ","the"," ","string","."]
08:47:17 <Rags> filter (/="the") ["this"," ","is"," ","the"," ","string","."] ->  ["this"," ","is"," "," ","string","."] why is there an extra space between "is" and "string" and how to remove it?
08:47:54 <geekosaur> because it can't read your mind and realize that you intended it to drop both "the" and the following space which is a separate list item
08:47:57 <mada> Rags: there are spaces on both sides of "the"
08:48:12 <pointed_set> Rags: you filtered out the word "the" - it has 2 spaces around
08:48:25 <caulagi> One more question - is there a lint or a code critic that Haskellers use?
08:48:35 <Rags> hlint
08:48:43 <pointed_set> Rags: try use "words" function
08:48:47 <pointed_set> :t words
08:48:48 <lambdabot> String -> [String]
08:49:18 <geekosaur> or you may want to use a loop involving span or break, so you can manually drop the space token after a match
08:49:19 <Rags> words is not good for me as it remove \n and other characters
08:49:43 <caulagi> Rags: thanks
08:50:10 <albeit> With attoparsec, how can I have I have it skip until it finds a specific string? (It's fine if it consumes the matched string)
08:50:49 <Rags> geekosaur - the string is just "This is the string." there are no extra spaces
08:51:13 <geekosaur> the way you tokenized it, you are left with extra spaces
08:51:27 <geekosaur> you told it to remove "the", not ["the", " "]
08:51:57 <geekosaur> if I remove "the" from [..., " ", "the", " ", ...], I am left with [..., " ", " ", ...]
08:52:30 <Rags> filter (=="the") ["this"," ","is"," ","the"," ","string","."] -> ["the"]
08:52:40 <geekosaur> yes
08:53:03 <geekosaur> notice the    " ","the"," "    part?
08:53:09 <Rags> oh got it
08:53:12 <geekosaur> what do you think happens if you filter "the" out from that?
08:53:21 <Rags> thanks geekosaur
08:54:38 <pointed_set> :t \tokens -> let (before, it : after) = break (== "the") tokens in before ++ dropWhile (== " ") after
08:54:39 <lambdabot> [[Char]] -> [[Char]]
08:55:33 <criado> Hello, Haskell people. I have a problem simulating dependent types. May I ask your help?
08:55:39 <vanila> criado, yes
08:56:02 <pointed_set> Rags: try the function above I posted
08:56:11 <criado> Well, I want to create a type representing the algebraic group Zp given p prime
08:56:17 <criado> I mean, integers mod p
08:56:20 <Rags> thanks pointed_set , yes trying it
08:57:48 <vanila> criado, I don't think that you can do that, maybe you can hard code a few primes
08:58:02 <Rags> pointed_set that worked like a charm. thanks
08:58:21 <argent0> criado: Z5 = [-4..4] ?
08:58:22 <pointed_set> Rags: was glad to help!
08:58:30 <criado> vanila: Ok. I thought you would say that.
08:58:41 <vanila> criado, you could build it in Coq
08:58:45 <criado> argent0: Z5=[0..4] with 4+1=0
08:58:47 <pointed_set> criado: try in Agda
08:59:06 <criado> Well, I want to make it in Haskell. So I will hardcode some primes
08:59:36 <criado> In fact, I will then implement finite fields, those depends also on a polynomial...
09:00:17 <criado> Well, vanila and pointed_set thank you anyway!
09:02:52 <pointed_set> did any one work with a Data.Fix?
09:05:29 <pointed_set> Is there any way to suppress recursion in some cases?
09:11:46 <prosper_> Hahaha
09:12:48 <daf> pointed_set: that sounds like an unfold
09:15:33 <ClaudiusMaximus> criado: you might be able to do it with the reflection package on hackage
09:15:54 <criado> ClaudiusMaximus: Oh, thanks. I will research that
09:15:55 <ClaudiusMaximus> criado: see the monoid example https://github.com/ekmett/reflection
09:16:04 <cite-reader> Do we have anything like Perl's HTML::Entities::decode_entities somewhere on Hackage?
09:17:36 <pointed_set> daf: I have a "(Name, Ast) :-> Ast" ctor (lambda) which typechecks into (Name, Ast) :=> Ast (pi-type). Direct usage of fold-by-some-algebra will traverse the first Ast arg, but it need not
09:18:31 <pointed_set> daf: the first Ast arg only needs to be normalized
09:20:55 <arielsanflo> help
09:20:57 <arielsanflo> make a function to order a list of integers without predetermined functions
09:21:45 <pointed_set> arielsanfo: http://haskellexists.blogspot.ru/2014/09/a-non-recursive-sorting-algorithm.html through [co]algebras! ;)
09:21:56 <criado> arielsanflo: you can try implementing selection sort: http://en.wikipedia.org/wiki/Selection_sort
09:23:02 <pointed_set> daf: and I cannot declare Functor such a way, that it ignores any ast param
09:23:25 <arielsanflo> fine thanls
09:24:05 <daf> pointed_set: is your type a functor?
09:24:53 <vanila> pointed_set, do you know if morte source code is available? I don't understand rthe claims it makes
09:25:16 <vanila> seems to solve halting problem
09:26:05 <pointed_set> vanila: it is, i think its called morte-library on github
09:26:11 <vanila> ty
09:26:23 <pointed_set> vanilla: you can cabal unpack moret
09:26:48 <pointed_set> * cabal install moret
09:26:51 <pointed_set> * morte
09:27:04 <pointed_set> * cabal unpack morte
09:27:26 <daf> vanila: the halting problem is only a problem if you have recursion
09:27:50 <vanila> haha
09:28:34 <pointed_set> daf: to use the Data.Fix, my type is nessesary a Functor over a recursor. It declared as data Ast self = ... | self :@ self | (Name, self) :-> self
09:28:55 <pointed_set> It is functor over a "self" arg
09:29:06 <merijn> daf: *unbounded* recursion
09:29:11 <daf> merijn: indeed
09:29:20 <daf> pointed_set: if it's a functor, you should be able to write fmap
09:30:35 <merijn> daf: The idea behind most total languages is not "solving the halting problem", but "trying to see how flexible a language you can make without accidentally adding non-termination"
09:30:41 <merijn> eh
09:30:45 <merijn> s/daf/vanila
09:30:55 <merijn> Typing is hard :)
09:31:04 <pointed_set> daf: if I write fmap, I have no way to do what I need: all occurences of "self" must be applied an "f", but the domain requires that some should remain unchanged
09:33:03 <daf> pointed_set: then your type can't be a functor, AIUI
09:33:55 <pointed_set> daf: I know. The type of [("T", Univ 0) :-> ("a", var "T") :-> var "a"] is [("T", Univ 0) :=> ("a", var "T") :=> var "T"] - so, I'm interested, could be there any trick to do this?
09:37:17 <pointed_set> daf: the one I figured now is to return from typecheck some (x `HasType` y) expression & then decide, what side is interesting
09:40:25 <wei2912> how could i merge two tuples together? something like ("aaa", "bbb") ++ ("aa", "bb") = ("aaaaa", "bbbbb")
09:41:27 <pointed_set> declare [both op (a, b) (c, d) = (a `op` c, b `op` d)]
09:41:46 <arielsanflo> help me
09:41:48 <arielsanflo> make a function that takes a list and split into two [1,3,5,6,7,8,9,4] to [1,3,5,6] [7,8,9,4]
09:42:13 <wei2912> pointed_set: there's no built-in function for that?
09:43:05 <pointed_set> arielsanflo: let breakApart list = splitAt (length list `div` 2) list
09:43:10 <josephle> > ("aaa", "bbb") <> ("aa", "bb") -- you're always going to be lucky with monoids
09:43:12 <lambdabot>  ("aaaaa","bbbbb")
09:43:14 <josephle> *not always
09:43:46 <pointed_set> oh, yes, monoids... :i Monoid
09:43:54 <wei2912> arielsanflo: josephle thanks! :P
09:44:04 <wei2912> err, josephle*
09:44:08 <arielsanflo> find thanks
09:44:11 <wei2912> arielsanflo: sorry for that, lol
09:44:38 <arielsanflo> no speacking inglish
09:44:42 <arielsanflo> i am from colombia
09:45:47 <arielsanflo> gracias por su ayuda
09:46:00 <arielsanflo> fin thanks for help
09:47:19 <arielsanflo> partirigual :: [Int] ->([Int],[Int])
09:47:32 <arielsanflo> function
09:52:57 <rqiu> data (,) a b = (,) a b deriving Show, Generic
09:53:17 <rqiu> got the following error: parse error on input ‘,’
09:55:56 <rqiu> Has anyone tried this?
09:56:06 <daf> I think , is not allowed in type names
09:56:12 <lf94> Maybe try (_,_)
09:56:48 <pointed_set> rqiu: the (,) is hardcoded
09:56:52 <cite-reader> rqiu: When you derive multiple classes, you need to enclose the list in parentheses. That will clear up the immediate error, but then GHC will complain that you're trying to redefine built-in syntax.
09:57:28 <josephle> you'll also need the TypeOperators extension
09:57:57 <albeit> How I can I import a hidden module in a package?
09:58:00 <rqiu> indeed, now this: Illegal binding of built-in syntax: (,)
09:58:19 <pointed_set> albeit: add it to the dependencies
09:58:57 <albeit> pointed_set: The package already is, but I'm trying to import a hidden module of the package
09:59:42 <josephle> albeit: you'll have to use another data constructor as (,) is reserved :/
09:59:45 <monochrom> hidden modules cannot be imported. that is the sole meaning of hidden.
10:00:03 <albeit> I don't like being protected from myself...
10:00:29 <albeit> What's the rationale behind hiding some modules of a package?
10:00:29 <monochrom> oh, you authored the package? then don't mark that module as hidden...
10:00:36 <pointed_set> albeit: Copy the source tree of the package to your code OR better, add the package to the "exported" section in dat package
10:00:39 <albeit> monochrom: No, not my package
10:01:34 <pointed_set> cabal unpack <it>, edit cabal-file - add the module to the exported list, install the package
10:01:41 <monochrom> pointed_set, I propose that it should be "add the module to ..."
10:02:13 <merijn> albeit: The rationale is to stop you from breaking assumption said package makes
10:03:56 <josephle> it's like the private/public distinction OOP makes. Anything that is private should not be "relevant" to the public facing interface.
10:05:08 <labancle> can anyone explain to me how the fusion law for catamorphisms works?
10:05:41 <kuznero> Hi All!
10:06:11 <Jeanne-Kamikaze> yo
10:06:36 <labancle> I'm reading "Functional programming with bananas, lenses envelopes, and barbed wire"
10:07:03 <labancle> but the definition of catamorphism fusion given in that paper doesn't seem to make sense
10:08:05 <bjorkintosh> labancle, you will first need to acquire a morphic cat.
10:08:07 <bjorkintosh> :)
10:09:10 <labancle> bjorkintosh: I have one, but I'm trying to fuse it into my brain
10:09:24 <bjorkintosh> pet it. gently.
10:09:53 <labancle> I tried but it hylowed out loud
10:09:59 <vanila> There should be a vote
10:10:12 <vanila> ask the community whether they want traversable in prelude or not
10:11:54 <simpson> vanila: The Prelude should be small.
10:11:59 <merijn> vanila: There was a vote
10:12:03 <vanila> That's my position too
10:12:14 <vanila> oh ! shows how out of touch i am! that's good then
10:12:42 <kuznero> noobs question: how do I chain either values such that in case of first left it should stop processing and return first left value?
10:12:44 <merijn> Discussion on changes likes this happen on the libraries@ list, if you want to share your opinion, you should subscribe to it
10:12:48 <dgpratt> I think putting such matters to a community vote is...ill-considered
10:13:06 <ThreeOfEight> kuznero: I think there is an Either monad
10:13:11 <dgpratt> even if you could make the vote visible and accessible to everyone you deem to be "the community"
10:13:13 <merijn> dgpratt: It's not a pure vote, it's the standard "rough consensus, running code" thing
10:13:40 <dgpratt> the community is filled with people like myself who may have an opinion based mostly on ignorance
10:13:45 <merijn> dgpratt: The core libraries committe and GHC HQ end up deciding what happens for core libraries like that
10:14:01 <dgpratt> and so it should be, imo
10:14:43 <kuznero> ThreeOfEight: I've guessed it's monads - is there any simple examples that any can understand? :)
10:14:46 <merijn> > let f x = if even x then Left x else Right x in sequence (map f [1..10])
10:14:49 <lambdabot>  Left 2
10:15:32 <merijn> kuznero: Consider the following type:
10:15:35 <merijn> :t (>>=)
10:15:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:15:53 <merijn> "Either e a -> (a -> Either e b) -> Either e b"
10:16:16 <ThreeOfEight> kuznero: http://lpaste.net/112022
10:16:36 <kuznero> Yes! Thanks gents!
10:16:39 <ThreeOfEight> that returns Left "fdsa", because Left basically means "This is an error, abort"
10:16:45 <merijn> kuznero: Since the function requires an 'a', we can conclude that the only thing the >>= instance for "Either e" can do for Left values is past it along unchanged
10:17:08 <kuznero> ok, get it. Thank you!
10:18:54 <LesZedCB> exit
10:19:45 <albeit> With attoparsec, what's the fastest way to skip X characters? I'm currently using P.take 4, but would that be slower as records the read chars then throws them out?
10:23:28 <bryanedds> Is Left used as alternative in Haskell, or just error?
10:23:55 <daf> both
10:24:05 <ThreeOfEight> It can mean whatever you want it to mean
10:24:20 <ThreeOfEight> but if one of the two alternatives means "something went wrong", it is convention to take Left
10:24:33 <ThreeOfEight> because of the pun with "Right"
10:24:50 <bryanedds> ok - cool :)
10:24:58 <bryanedds> I mean, right :)
10:25:14 <ThreeOfEight> although I for one like to define my own datatypes for alternatives often
10:25:24 <pointed_set> albeit: in Parsec there are getInput/setInput primitives
10:25:28 <bryanedds> why so?
10:25:29 <ThreeOfEight> because you can give the constructors more descriptive names
10:25:35 <bryanedds> ah hmm
10:25:37 <geekosaur> don't push your handedness on me :p
10:26:08 <ThreeOfEight> but that has the slight disadvantage of foregoing all the existing functions for either
10:27:01 <johnw> we could rename Left to TheRoadLessTraveledBy
10:27:47 <Kinnison> TheRoadLessTraveledBy = left
10:27:50 <Kinnison> damnit
10:27:53 <Kinnison> Left
10:29:22 <josephle> albeit: (count X (skip True)), but I feel like this is sillier than just using take
10:29:57 <albeit> josephle: I'll see what criterion says!
10:31:16 <josephle> oops
10:31:19 <josephle> that wouldn't type check
10:31:19 <benzrf> :t skip
10:31:20 <lambdabot> Not in scope: ‘skip’
10:31:36 <josephle> gotta change True to (const True)
10:35:27 <albeit> Hmm can't really tell if one is faster or not
10:37:55 <josephle> hmm, what if you change count to replicateM_?
10:38:12 <josephle> since count still builds a list of ()s in this case
10:41:41 <albeit> Woah, way faster. ~2x looks like
10:41:46 <newsham> > Just Nothing :: Maybe $ Maybe a
10:41:48 <lambdabot>  Just Nothing
10:42:04 <josephle> albeit: nice!
10:42:10 <albeit> Thanks!
10:46:49 <albeit> Actually, the replicateM_ version is much faster for large X, but much slower for small X. Why would that be?
10:47:30 <merijn> albeit: Look at the generated Core?
10:47:48 <albeit> Oh boy, new things ;)
10:48:16 <benzrf> albeit: whoaaa
10:48:20 <benzrf> h-how did you do that
10:48:27 <benzrf> :k ($)
10:48:28 <lambdabot> (k1 -> k) -> k1 -> k
10:48:32 <benzrf> _
10:48:52 <albeit> * newsham ^
10:53:06 <newsham> [06:31] < Melvar> @let type ($) f a = f a
10:53:12 <newsham> [07:17] < Melvar> So what I’m wanting to know is why I haven’t seen type-level ($) before.
10:56:19 <Kron> Is there any way to stop flycheck from bugging me about missing top level type signatures?
10:58:57 <josephle> albeit: my uninformed theory is that at some Y the cost of allocating space for the chars overcomes the difference between calling skip and consuming a character
10:59:07 <chrisdone> -fno-warn-missing-signatures
11:01:50 <digitalmentat> is there anyway to specify a package specific build flag in the Build-depends field for that package?
11:03:12 <digitalmentat> wait I think I figured it out
11:03:25 <Kron> I'm not sure how to put that into my flycheck...
11:03:27 <albeit> Since attoparsec deals with strict ByteStrings, shouldn't there be some way to just "drop" X characters?
11:03:28 <digitalmentat> I can pass the flag at cabal install --only-dependencies -fpackageflag
11:03:37 <Kron> chris, how goes structural haskell mode?
11:03:38 <albeit> Since ByteString's drop is O(1)
11:04:46 <chrisdone> kron: fine =)
11:05:04 <chrisdone> i don't know how to tell flycheck things either
11:05:18 <Kron> it's so good and yet so hands off :(
11:05:22 <chrisdone> albeit: you mean O(n)?
11:05:34 <Kron> is the shm package on the package-list a good way to install structural haskell mode?
11:05:39 <Kron> or is it better to get it from git
11:05:43 <chrisdone> better from git
11:05:48 <Kron> gotcha
11:05:49 <chrisdone> i don't know what the package-list is =)
11:06:03 <albeit> chrisdone: No? Hackage says drop is O(1) for Data.ByteString
11:06:45 <Kron> http://melpa.milkbox.net/#/shm
11:06:53 <Kron> someone put SHM on melpa, chris
11:07:16 <chrisdone> albeit: oh, i guess it's just pointer arithmetic modulo chunks
11:07:30 <monochrom> melpa tracks git commits, so getting from melpa should be observationally equivalent to getting from git. except for manual dependency chasing.
11:07:34 <chrisdone> kron: i think melpa is sourced from git anyway
11:07:41 <Kron> gotcha
11:08:02 <monochrom> I now get haskell-mode from melpa, too :)
11:08:51 <monochrom> and of course, strictly speaking, s/git/github/
11:09:36 <chrisdone> i tried to sit and relax and watch the pilot episode House of Cards. i got 5 minutes into it before turning it off and opening emacs
11:09:59 <johnw> chrisdone: haha
11:11:07 <Kron> cabal update is taking ages
11:11:22 <monochrom> "the cabal update of all ages"
11:11:45 <chrisdone> "may you have interesting build plans"
11:11:53 <chrisdone> the ultimate haskeller curse
11:12:49 <Kron> is something up with cabal that I've missed?
11:13:24 <chrisdone> depending on the age of your cabal, it might have a bug in downloading the tarball
11:13:34 <chrisdone> which makes it not performant
11:13:52 <monochrom> yeah, there is an old algorithm taking quadratic time
11:15:01 <monochrom> something as embarrasingly simple as f n = f (n-1) ++ [x]
11:16:30 <bakibour> Hiho
11:17:17 <monochrom> cabal-install 1.16 and before used the old slow algorithm
11:18:24 <bakibour> How much data per second do you churn in finance with real time chartings etc?
11:19:08 <c_wraith> about 3 datas per second.
11:19:28 <bakibour> That much?
11:19:44 <chrisdone> 4 datas per second with GHC 7.8's I/O manager
11:19:58 <monochrom> how timely. I'm just reading today's xkcd about "data" being singular vs plural
11:20:29 <bakibour> It is the same with currency :)
11:20:43 <bakibour> So its not Dollars, but Dollar
11:20:50 <chrisdone> yes, nobody but old people and hypercorrectivists use "data" in the plural anymore
11:21:00 <mauke> ahem
11:21:04 <Kron> "Downloaded to /home/ashley/.cabal/packages/hackage.haskell.org/00-index.tar.gz
11:21:04 <Kron> cabal: Codec.Compression.Zlib: premature end of compressed stream"
11:21:09 <Kron> it collapsed with that error
11:21:10 <Kron> how strange
11:22:58 <dfeuer> chrisdone, I guess I'm a hypercorrectivist?
11:23:27 <monochrom> Kron, there is likely some buggy middleman between your computer and the hackage server
11:24:10 <chrisdone> dfeuer: probably!
11:24:42 <Kron> probably
11:27:28 * hackagebot graphmod 1.2.4 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.4 (IavorDiatchki)
11:37:28 * hackagebot hxt-css 0.1.0.0 - CSS selectors for HXT  http://hackage.haskell.org/package/hxt-css-0.1.0.0 (MariosTitas)
11:58:49 <albeit> :t flip (,)
11:58:50 <lambdabot> b -> a -> (a, b)
11:58:52 <johnw> haha, awesmoe hlint message: https://gist.github.com/040ae6e4f9cd96348c40
11:58:54 <johnw> why not, indeed?
11:59:27 <chrisdone> looks like hlint is buggy there too
11:59:28 <chrisdone>  
11:59:41 <bitemyapp> johnw: pretty cute.
11:59:44 <chrisdone> "EnableExtension" is part of HSE
12:00:16 <chrisdone> somebody used a `show' where they shouldn't've ought to've not done so
12:00:20 <chrisdone> =3
12:00:58 <monochrom> hahahaha
12:01:20 <johnw> I had to have had having to have had said
12:01:38 <chrisdone> right
12:03:57 <monochrom> @remember johnw haha, awesmoe hlint message: https://gist.github.com/040ae6e4f9cd96348c40
12:03:57 <lambdabot> It is forever etched in my memory.
12:04:48 <monochrom> (that is actually more for that sake of Haskell Weekly News)
12:05:15 <chrisdone> haskellnews had quotes
12:05:54 <bitemyapp> TIL: https://github.com/bgamari/hoogle-index
12:06:15 <chrisdone> yeah i'm gonna librify that mother
12:06:32 <chrisdone> well, possibly
12:06:39 <bitemyapp> chrisdone: I'm just glad it exists.
12:06:49 <bitemyapp> drives me nuts that hoogle is useful for the stuff I don't need it for
12:06:53 <bitemyapp> (usually)
12:06:55 <johnw> bitemyapp: ah, similar to what my hoogle-local package in Nix does
12:09:32 <Apocalisp> is there a semicomonad class somewhere?
12:09:58 <Apocalisp> (assuming somewhere in edwardk's things)
12:10:18 <vanila> I don't believe such a structure exists
12:10:35 <bitemyapp> Apocalisp: you mean extend by itself?
12:10:43 <Apocalisp> bitemyapp: Yeah
12:10:54 <bitemyapp> Apocalisp: that's more of Scalaz/Tony thing.
12:11:17 <c_wraith> Apocalisp: yes
12:11:18 <bitemyapp> Apocalisp: similarly to how Apply doesn't get split out generally speaking. How'd you contrive one? :)
12:11:27 <bitemyapp> c_wraith: I couldn't find one, where?
12:11:46 <c_wraith> one of edwardk's packages...  looking
12:11:57 <bitemyapp> there's ComonadApply but not Extend by itself.
12:11:59 <Apocalisp> yeah, I'm not really sure what such a structure means
12:11:59 <c_wraith> https://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Extend.html
12:12:04 <bitemyapp> oh ffs
12:12:04 <VBlizzard> hmm, I'm tempted to learn Haskell.
12:12:13 <bitemyapp> Apocalisp: welp ^^
12:12:24 <chrisdone> VBlizzard: http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310408064982.jpg
12:12:25 <bitemyapp> c_wraith: now I know why Tony likes that library.
12:12:33 <Apocalisp> if it's not produced by two adjoint functors who love each other very much, does the stork bring them?
12:12:49 <c_wraith> Apocalisp: the semigroupoids package, as I pasted above - in case you missed it
12:12:52 <VBlizzard> chrisdone, I have no idea what that means.
12:12:54 <VBlizzard> so ok.
12:13:06 <johnw> chrisdone: sometimes I wonder about your GIF/JPG choices... :)
12:14:12 <chrisdone> johnw: you could say they're… wonderful!
12:14:36 <yukko> if I have a module A.B in /A/B.hs, and I have a module A in /A.hs, how do I import A from B?
12:14:58 <c_wraith> yukko: import A
12:15:07 <yukko> hm
12:15:13 <bitemyapp> note to self, read more semigroupoids.
12:15:14 <c_wraith> yukko: beware of circular imports - GHC doesn't support them
12:15:26 <johnw> bitemyapp: what do you need a semigroupoid for?
12:15:34 <bitemyapp> grrr the chart doesn't even mention extend.
12:15:44 <bitemyapp> johnw: nothing really.
12:15:51 <bitemyapp> johnw: I just like knowing more stuff.
12:16:06 <bitemyapp> johnw: really what I *need* is a solid comprehension of the Kafka protocol and how it works with Zookeeper.
12:16:11 <bitemyapp> and a client for both :\
12:16:21 <johnw> extend might also be called cojoin
12:16:27 <bitemyapp> actually I don't even need that. I could just drink beer and pet my dog. But I want more libraries so here we are.
12:16:32 <bitemyapp> johnw: cobind?
12:16:43 <johnw> oh, yeah
12:16:55 <johnw> i'm still waiting on the day when I have a need for a comonad
12:17:01 <bitemyapp> extract is cojoin I think
12:17:07 <johnw> extract is coreturn
12:17:11 <bitemyapp> oh right.
12:17:21 <yukko> c_wraith it doesn't seem to be working
12:17:23 <bitemyapp> johnw: Game of Life demonstrations? Matrix convolution? zippers? ...I'm ou of ideas.
12:17:46 <johnw> i've helped other people find uses for them
12:17:48 <johnw> just nothing yet for me
12:18:37 <yukko> B.hs:3:8: Could not find module 'A'
12:19:20 <c_wraith> yukko: sounds like you didn't specify the root of the source tree
12:19:24 <yukko> ahh
12:19:36 <yukko> if I do that in a .cabal file, will ghci be able to figure it out?
12:19:46 <c_wraith> no, ghci doesn't use cabal at all
12:19:51 <yukko> : (
12:20:01 <bitemyapp> yukko: cabal repl?
12:20:20 <yukko> bitemyapp I didn't know about that!
12:20:32 <yukko> but also, calling ghci from the root of the source directory seems to work as well
12:20:44 <yukko> thanks for the help
12:21:16 <bitemyapp> yukko: "calling ghci from the root of the source directory" will get old really fast as you start using more libraries.
12:21:31 <bitemyapp> yukko: you should call cabal repl with verbosity turned on in a non-trivial project and look at the command it generates.
12:21:39 <bitemyapp> yukko: further, are you using sandboxes?
12:21:46 <c_wraith> I really find cabal repl to be hostile
12:21:46 <bitemyapp> yukko: Always Be Sandboxing (™)
12:21:56 <bitemyapp> c_wraith: I find comonads life-threatening.
12:22:06 <bitemyapp> monads are ego-threatening. Maybe because of duality.
12:22:13 <c_wraith> cabal repl insisted everything be compilable before working last time I used it.
12:22:24 <c_wraith> which totally defeats the purpose of using the repl, in my experience.
12:22:30 <bitemyapp> c_wraith: you can turn on defer type errors.
12:22:34 <chrisdone> c_wraith+1
12:22:43 <c_wraith> That's a bad solution to something that shouldn't be a problem.
12:22:43 <bitemyapp> just use defer type errors ;_;
12:22:56 <c_wraith> Just don't load files until I say to load them!  even easier!
12:23:00 <johnw> i wonder if defer runtime errors could be anything other than just sleep()
12:23:19 <chrisdone> c_wraith: i have my own ghc-server which acts like cabal repl in terms of enabling extensions, package config and include dirs, but doesn't try to load everything for no reason
12:23:22 <bitemyapp> c_wraith: why not patch it to be so?
12:23:37 <bitemyapp> I'm filing an issue right now.
12:23:39 <c_wraith> bitemyapp: I reported it as a bug, but couldn't really convince people
12:23:43 <yukko> bitemyapp how does sandboxing work?
12:23:54 <yukko> I've not really been using cabal at all to be honest
12:24:56 <bitemyapp> c_wraith: I'm reporting it again
12:25:05 <bitemyapp> c_wraith: I will haunt them until it gets fixed.
12:26:10 <bitemyapp> ttuegel: https://github.com/haskell/cabal/issues/2144
12:27:29 <bitemyapp> yukko: https://github.com/bitemyapp/learnhaskell#what-are-haskell-ghc-and-cabal
12:27:39 <ttuegel> bitemyapp: the point being cabal shouldn't try to build code before entering the repl?
12:27:46 <bitemyapp> ttuegel: yes, precisely.
12:28:07 <bitemyapp> ttuegel: so that you at least *have* a repl while things are still broken and can attempt imports and expressions selectively.
12:29:09 <bitemyapp> ttuegel: this is the sort of thing ex-lisp weenies like me will whine about incessantly.
12:29:42 <ttuegel> oh no, it's not just ex-lispers
12:29:49 <ttuegel> i've been bitten by this too
12:30:02 <ttuegel> especially if you use emacs and try to enable interactive-haskell-mode
12:30:04 <bitemyapp> ttuegel: oh sure, just saying, lispers are accustomed to kicking around broken stuff in the REPL as part of the dev process.
12:30:11 <bitemyapp> enabling defer type errors clearly isn't a reasonable alternative
12:30:23 <chrisdone> yeah, i have had many bug reports to haskell-mode because cabal repl just ends when you start it
12:30:44 <bitemyapp> ttuegel: part of what this frustrates is that I'll have blocks of code A and B. A is mostly correct, B is mostly broken/in-dev, but B will have stuff *in terms of* A and I need to kick around expressions from A before I can finish B
12:31:00 <chrisdone> for me it's not even that things might be broken
12:31:02 <bitemyapp> having the REPL choke on a biscotti and die on B when I really wanted to poke at A is just counter-productive.
12:31:07 <chrisdone> who's to say i want my time wasted loading 100 modules?
12:31:11 <bitemyapp> that too
12:31:12 <ttuegel> tbh, i don't know why repl does anything besides 1) preprocess sources as needed 2) call ghci with appropriate options
12:31:22 <ttuegel> also, ghci doesn't look at the modules cabal compiles!
12:31:27 <bitemyapp> ttuegel: that means the fix shouldn't be too involved then right?
12:31:50 <ttuegel> bitemyapp: heh, no :( there's probably a  *lot* of code floating around to do the wrong thing
12:32:22 <bitemyapp> ttuegel: then there's two questions. How hard will it be to get it fixed and how hard would it be to get a fix past the guards?
12:33:01 <ttuegel> it would be trivial to get it past the guards
12:33:15 <bitemyapp> ttuegel: where's the REPL code?
12:33:22 <ttuegel> that's what i'm lookup up now :)
12:33:27 <bitemyapp> did a cursory lookabout and coudn't find it.
12:33:29 <bitemyapp> cool :)
12:34:57 <chrisdone> probably it'll be hard because it's not a bug but someone decided it was a good idea
12:35:12 <ttuegel> bitemyapp: entry point here https://github.com/haskell/cabal/blob/master/cabal-install/Main.hs#L362
12:35:15 <bitemyapp> chrisdone: this is what I was born for.
12:35:31 <bitemyapp> ttuegel: oh wow in Main.hs
12:35:33 <ttuegel> it doesn't have it's own module because it's just hacked together out of pieces
12:35:35 <bitemyapp> no wonder I couldn't find it.
12:35:43 <bitemyapp> I kept trying to find a module for it.
12:36:06 <ttuegel> if you break it out into it's own module like a *real* feature, it will be an even easier sell :)
12:36:24 * chrisdone goes back to his hermetic hacking on ghc-server
12:36:39 <bitemyapp> chrisdone: halp
12:36:49 <bitemyapp> I can't suffer another yak ;_;
12:37:52 <bitemyapp> just realized I'd done a very minor patch to Cabal long ago.
12:40:29 <bgamari> chrisdone, pull requests welcome
12:40:45 <bgamari> it's admittedly pretty messy
12:41:11 <chrisdone> i'm working on my own replacement for ghc and cabal repl, so i've no incentive to PR anything ;)
12:41:21 <bitemyapp> chrisdone: why
12:41:33 <bitemyapp> bgamari: what's admittedly pretty messy?
12:42:22 <chrisdone> bitemyapp: freedom
12:42:37 <bitemyapp> chrisdone: damn jacobins.
12:42:56 <ttuegel> not working on cabal does give you nice freedoms. like monad transformers.
12:43:15 <ttuegel> or even just... monads besides IO
12:44:04 <mr-> State and Reader are ok :-)
12:44:52 <bitemyapp> ttuegel: I don't really know Cabal dev - what are the limitations?
12:44:56 <bitemyapp> ttuegel: it uses mtl.
12:45:29 <ttuegel> bitemyapp: cabal-install uses mtl, Cabal the library can only use things that have shipped with GHC for >= 3 years
12:45:44 <bitemyapp> ahhhh okay.
12:45:44 <T_X_> how can I check which module version of System.Process I have? I want to use System.Process.callProcess
12:45:53 <ttuegel> cabal-install really just needs to stay within the platform
12:46:00 <T_X_> I'm on a Ubuntu 14.04 (armhf) here
12:46:43 <ttuegel> bitemyapp: sorry, let me rephrase that: Cabal the lib can only use deps that ship with GHC HEAD and that *build* with all GHCs in the last 3 years
12:46:51 <ttuegel> i wrote the policy, i should know it :)
12:46:58 <ttuegel> without having to look it up
12:47:01 <bitemyapp> ttuegel: happens to me all the time.
12:47:11 <bitemyapp> ttuegel: "what does ${YOUR_LIBRARY} support?" "uhhh..."
12:47:18 <bitemyapp> "lets do science and find out!"
12:48:17 <chrisdone> bitemyapp: https://github.com/chrisdone/ghc-server
12:48:57 <chrisdone> bitemyapp: i'm making my SLIME for haskell =)
12:52:51 <sveit_> are updates on mutable vectors (from Data.Vector) O(1)?
12:52:56 <sveit_> it doesn't seem to say in the documentation
12:54:34 <geekosaur> I think that's hard to say? mutables are probably fast immediately but cause GC some heartburn
12:55:42 <sveit_> so what do people do if they have algorithms that are obviously most efficient in an imperative way? just bite the bullet? or can I use some better datatype?
12:55:58 <bitemyapp> sveit_: what problem are you solving?
12:56:47 <sveit_> a fairly basic network generation problem; something i would normally do in python or C if i cared about speed, but i wanted to play around with haskell
12:57:26 * geekosaur is tempted to say that an "obviously most efficient in an imperative way" algorithm is not ideal for playing around with haskell
12:58:01 <sveit_> specifically, the task is: generate a network of nodes, starting from 1 up to N, where each node is randomly connected to some other existing node with some calculable probability for each node
12:58:09 <geekosaur> ...then again, "if I cared about speed" is not a primary argument for writing it in python
12:58:17 <mm_freak> hi there
12:58:36 <sveit_> geekosaur, i meant "in python, (or C if i cared about speed)"
12:58:50 <sveit_> not "in (python or C) if i cared about speed" :)
12:58:53 <mm_freak> would i want to use binary/cereal if i need interoperability between different platforms and compilers?
12:58:58 <bitemyapp> sveit_: when you say network, you mean graph?
12:59:09 <sveit_> bitemyapp, sure
12:59:10 <bitemyapp> sveit_: https://hackage.haskell.org/package/fgl
12:59:15 <bitemyapp> sveit_: first rule of pure FP
12:59:18 * geekosaur chaks up another point for "english, the infinitely ambiguous language"
12:59:22 <bitemyapp> sveit_: when your problem can't be solved with a tree
12:59:28 <bitemyapp> sveit_: change the problem so it can be solved with a tree
12:59:59 <bitemyapp> sveit_: adjacency list via mutable vectors is sometimes appropriate but it wouldn't be my first resort.
13:01:41 <sveit_> bitemyapp, i'm not sure how i would do this in pure fp still... my algorithm right now is quite basic, start with a vector of N zeros, then loop n = 1..N, set vector(n) = vector(n) + 1, then choose based on my probability distribution (which in general depends on connections made so far) some random index r, and set vector(r) = vector(r) + 1;
13:01:48 <bitemyapp> carter: small arrays in 7.10, mutable or no?
13:01:52 <bitemyapp> carter: does it matter?
13:02:01 <carter> whats your questions?
13:02:07 <carter> small arrays ARE in HEAD
13:02:25 <carter> < 100 or whaever elements  dont need the mark table thingy
13:03:15 <mm_freak> sveit_: sounds like a job for my favourite array type:  (->)
13:04:07 <sveit_> i think
13:04:21 <bitemyapp> carter: yeah but are they mutable or immutable?
13:04:26 <sveit_> sorry, i think i'm starting
13:04:31 <carter> both are supported
13:04:35 <bitemyapp> carter: cool beans.
13:04:45 <sveit_> wow, keyboard is dying. anyway, mm_freak i'm confused what you mean
13:04:47 <carter> though mutability does have implciations for gc tracing
13:05:24 <mm_freak> sveit_: every immutable data structure can be defined in terms of its operations…  does that make sense?
13:05:28 <monochrom> Data.Vector mutable vectors have O(1) reads and writes per cell
13:05:49 <stepkut> is there a haskell-mode hook that will automatically add 'imports'. Seems like an easy extension of the thing that automatically shows documentation...
13:06:01 <sveit_> mm_freak, sure, but i'm still puzzled as to how i can map my problem onto that kind of "array" efficiently
13:06:12 <monochrom> as for the constant multiplier hidden by O(1), I don't really know, you'll have to measure it.
13:06:37 <mm_freak> sveit_: be patient…  an immutable array is a very simple data structure:  it has only two operations…  which ones?
13:07:44 <sveit_> mm_freak, sorry. indexed access, and length queries?
13:07:52 <mm_freak> sveit_: exactly!
13:08:05 <monochrom> stepkut: if you use haskell-interactive-mode (as opposed to inf-haskell), and have hoogle, then see https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Compiling#auto-adding-of-modules-to-import
13:08:10 <chrisdone> all yours, babooshka, babooshka, babooshkayayaaa
13:08:13 <nh2> can somebody give me a quick update, does Hackage currently build packages or not?
13:08:46 <mm_freak> sveit_: so the traditional way is to have an actual array (x :: Array Ix A) and two functions (get :: Array ix a -> ix -> a) and (bounds :: Array ix a -> (ix, ix))
13:09:57 <carter> bitemyapp: context?
13:09:58 <mm_freak> sveit_: but there is more:  the array can be identified with its defining operations:  instead of an actual array and two operations the array /is/ the two operations:  data Array ix a = Array { get :: ix -> a, lowerBound :: ix, upperBound ix }
13:10:33 <mm_freak> sveit_: at that point you have liberated yourself from a concrete array representation (which may still be a sequence of words in memory, but that's now an implementation detail)
13:10:37 <carter> I will say this: storable / unboxed arrays are several orders of magntiude more awesome (though less general) for performance in haskell
13:10:37 <mm_freak> sveit_: still with me?
13:10:42 <carter> at least wrt GC  time
13:10:51 <sveit_> mm_freak, yep
13:11:00 <carter> theres certain classes of things you cant do nicely with those though
13:11:18 <mm_freak> sveit_: but once you have liberated yourself from that you can go one step further:  ignore the existence of bounds
13:11:25 <mm_freak> type Array ix a = ix -> a
13:11:31 <frihd1> sveit_:  do you have a gist in another language, just to have a clear idea of your algorithm
13:11:37 <mm_freak> that leaves you with:  type Array = (->)
13:11:41 <trap_exit> someone once made an argument that you should never create a typeclass if it only has one function, and that instead you should do BLAH ... what is BLAH ?
13:11:57 <sveit_> mm_freak, ok...
13:11:58 <monochrom> I don't want to drop the bounds, unless the get operation is ix -> Maybe a
13:12:09 <trap_exit> I'm about to create a function called "JS_Loggable", which only has one function, ffi__console_log ... which is the typeclass of all objects that can be logged in a JS console window
13:12:09 <carter> mm_freak: but depending on the computation, that will be painfully slow
13:12:15 <mm_freak> sveit_: so before you used a loop to iterate your array and add 1 to each element
13:12:18 <carter> monochrom: i actually do ix -> maybe a in my array lib
13:12:19 <trap_exit> what should I be doing instead?
13:12:22 <carter> its actually the correct semantics
13:12:29 <frihd1> maybe there exists a formula to generate a list of edges matching the distribution from your algorithm
13:12:32 * hackagebot AesonBson 0.2.2 - Mapping between Aeson's JSON and Bson objects.  http://hackage.haskell.org/package/AesonBson-0.2.2 (NiklasHambuechen)
13:12:32 <mm_freak> sveit_: what if your array is identified by its getter function…  how do you add 1 to every element?
13:12:36 <HeladoDeBrownie> trap_exit, well, you could pass explicitly, but I'm not sure what you're referring to in particular
13:12:46 <sveit_> mm_freak, composition?
13:12:48 <carter> monochrom: specifically, doing  ix -> a induces only allowing dense representations
13:12:50 <carter> which sucks ;)
13:12:51 <mm_freak> sveit_: exactly
13:13:00 <monochrom> ah
13:13:09 <mm_freak> carter: (->) is about the fastest array type you can get, if you use it properly =)
13:13:23 <carter> mm_freak: yes, as a wrapper around a concrete buffer
13:13:32 <mm_freak> carter: not necessarily
13:13:32 <carter> recomputation can be pricey depending on the algorithm
13:13:36 <carter> matrix mult
13:13:37 <carter> done
13:13:39 <carter> :)
13:13:41 <mm_freak> what is an array that is filled with zeroes?
13:13:48 <carter> then its sparse
13:13:52 <carter> i've solved that too :)
13:14:03 <mm_freak> carter: what is an array where every element has the value of its index?
13:14:04 <sveit_> frihd1, sure. in pseudo-python: "for i = [1..N]; vector(i) = vector(i) + 1; r = generateRandomIndex(vector, i) # r < i; vector(r) = vector(r) + 1"
13:14:21 <carter> mm_freak: these semantic zeros and logical zeros
13:14:30 <monochrom> I think the "if you use it properly" part makes the whole statement tautological
13:14:36 <mm_freak> carter: an array doesn't have to be sparse…  the circumstances that require an actual array in memory are rare:  for example when you read data from a file or some other I/O source
13:14:47 <carter> mm_freak: no
13:14:49 <carter> whats your application domain
13:14:58 <carter> youre implicitly making claims based upon that
13:15:00 <carter> please make it explicit :)
13:15:10 <carter> monochrom: my Layout type class here http://www.wellposed.com.s3.amazonaws.com/examples-cached/numerical-0.1-prerelease-docs/Numerical-Array-Layout-Base.html
13:15:13 <mm_freak> carter: currently i'm using sveit_'s algorithm
13:15:26 <mm_freak> and in general every application domain that would allow you to take advantage of repa
13:15:30 <carter> ok
13:15:35 <carter> repa assumes dense
13:15:45 <carter> my stuff is a bit more general :)
13:15:47 <mm_freak> it doesn't
13:15:50 <carter> no
13:15:51 <carter> it does
13:15:57 <carter> show me how it doesnt
13:16:04 <mm_freak> a delayed array can be sparse
13:16:05 <carter> it assumes everything is rowmajor dense
13:16:09 <carter> yes
13:16:15 <carter> but you can still query every position
13:16:19 <carter> thats a lot of extra work
13:16:23 <carter> :)
13:16:29 <carter> at least for my domains
13:16:39 <carter> repa is valid too
13:16:57 <mm_freak> and completely irrelevant nitpicking for what sveit_ is currently doing…  you're not exactly helping by destroying my attempt to promote the correct data structure for a certain problem
13:17:06 <carter> what problem?
13:17:31 <sveit_> carter, in pseudo-python: "for i = [1..N]; vector(i) = vector(i) + 1; r = generateRandomIndex(vector, i) # r < i; vector(r) = vector(r) + 1"
13:17:48 <sveit_> where vector is a large vector of zeros
13:17:57 <mm_freak> nevermind
13:18:10 <mm_freak> i'll shut up =)
13:18:24 <carter> sveit_: oh, so you wanna randomly increment through?
13:18:27 <sveit_> mm_freak, sorry if i'm being dense, but i still don't see the mapping onto your technique? i'm still interested
13:18:48 <sveit_> carter, essentially yes.
13:18:56 <carter> sveit: i see two things there
13:19:01 <monochrom> IMO (->) is an interface rather than an implementation
13:19:01 <carter> a deterministic compoentn
13:19:09 <carter> and a random update compoennt
13:19:11 <carter> right?
13:19:12 <mm_freak> thanks monochrom
13:19:33 <monochrom> but data structure talks about implementation. the whole point of data structure.
13:19:33 <carter> sveit: so every spot will be >=1 at the end?
13:19:45 <sveit_> carter, precisely. i could just initialize the whole thing as a vector of 1's if it weren't for the generateRandomIndex(v,i) function, which depends on which elements are zeros in general
13:19:54 <mm_freak> sveit_: in essence what you're doing comes up a lot in multimedia processing, and you can use a functional array approach to make this efficient and even get parallelism for free
13:20:10 <carter> # r < i; ---- thats a comment right?
13:20:11 <mm_freak> but right now i'm too irritated to go further…  next time =)
13:20:13 <mm_freak> see you
13:20:20 <sveit_> carter, yes
13:20:46 <carter> sveit_: you can init everything to 1
13:20:49 <sveit_> mm_freak, you sure?
13:21:01 <carter> then do a monadic scanL kinda thing?
13:21:15 <carter> for each position i, randomly pick a point in its prefix
13:21:25 <carter> sveit_: those will all happen independently
13:21:26 <carter> right?
13:21:43 <sveit_> carter, what do you mean prefix?
13:21:49 <carter> things before i
13:22:17 <sveit_> carter, they're not quite independent. for example, the distribution might depend on how many connections have already been made to a node
13:22:24 <carter> really how?
13:22:28 <carter> thats not in the code you wrote
13:22:30 <carter> :)
13:22:39 <sveit_> carter, it is, hidden in the generateRandomIndex(v,i)
13:22:40 <sveit_> :)
13:22:45 <frihd1> carter it is: the generateRandomIndex needs current state
13:22:49 <frihd1> sveit_:  i don't understand how you represent a graph with a vector of ints
13:22:53 <carter> https://hackage.haskell.org/package/hakaru
13:23:03 <carter> frihd1: he cant!
13:23:03 <sveit_> frihd1, i'm only interested in the number of connections each node makes
13:23:14 <frihd1> ok sveit_ =)
13:23:14 <carter> sveit_: sooooo whats the REAL thing you wanna modle
13:23:17 <carter> graph formation?
13:23:27 <carter> lets talk about the problem taht motivated the code
13:23:41 <sveit_> carter, unfortunately, in this case it's literally this toy problem
13:23:56 <carter> sveit_: https://hackage.haskell.org/package/hakaru is an interested WIP probabilistic modelling DSL
13:24:08 <carter> http://indiana.edu/~ppaml/HakaruTutorial.html
13:24:16 <sveit_> frihd1, so each element of the vector is the number of connections from that node to any other node
13:24:52 <frihd1> yes, it's a degree distribution
13:25:09 <daf> is there a type that's like lazy bytestrings, but for types other than Char/Word8? it's not hard to make a simple approximation but it seems like something that should exist already
13:25:12 <frihd1> i bet you want to draw a sample from a distribution, but if you want to do it your way, go for a mutable array
13:25:27 <daf> (e.g. starting with type Stream a = [Vector a])
13:25:45 <daf> then defining map, fromList, toList etc.
13:25:53 <sveit_> frihd1, it isn't for a real-life problem, i am just trying to train myself to take algorithms that seem extremely imperative and make them functional
13:26:10 <sveit_> frihd1, but in this case it seems the best way may actually be imperative?
13:26:50 <frihd1> ah, yes, I thought you were looking for a haskell lib for imperative-style arrays =)
13:27:14 <carter> sveit_: your trying to design a sampler basically
13:27:17 <carter> y/n
13:27:41 <JagaJaga> hello! How to send broadcast message using network lib?
13:27:50 <carter> JagaJaga: lets look at the docs!
13:27:55 <carter> @hackage network
13:27:56 <lambdabot> http://hackage.haskell.org/package/network
13:27:57 <sveit_> carter, in a sense, yes, i do want to sample the possible distributions of vectors given my constraints
13:28:24 <carter> JagaJaga: Broadcast	
13:28:24 <carter> SO_BROADCAST in  http://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket.html ?
13:28:24 <sveit_> sveit_, the problem seems to be (including with the DSL you sent out) that my process is inherently dependent on the order things are done
13:28:38 <sveit_> whoops, meant carter, sorry
13:28:40 <carter> :P
13:29:07 <carter> JagaJaga: so that plus maybe setSocketOption :: Socket -> SocketOption -> Int -> IO () ?
13:29:10 <frihd1> sveit_:  the correct way (imho) is to think about what you want in/out, and not "how you do it"
13:29:19 <carter> yeah
13:29:52 <carter> sveit_: describe what the code is supposed to mean
13:30:00 <CrazyM4n> So has anyone gotten gloss-raster to work on windows?
13:30:11 <carter> CrazyM4n: if you disable the -fllvm flag it should work
13:30:29 <CrazyM4n> carter: How do I disable that?
13:30:37 <carter> CrazyM4n: so do cabal get gloss-raster
13:30:40 <JagaJaga> carter: oh, stupid am I. Thx!
13:30:47 <carter> then open the gloss-raster.cabl file
13:30:54 <carter> then remove -fllvm
13:31:07 <CrazyM4n> carter: Now to find gloss-raster.cabl
13:31:07 <frihd1> if you really want a degree distribution, I'm tempted to say, wolfram alpha zipf :-D
13:31:16 <carter> CrazyM4n: i can't spell
13:31:32 <carter> CrazyM4n: it'll be in the base dir of the the folder
13:31:39 <CrazyM4n> Sounds good, thanks
13:31:52 <CrazyM4n> What is LLVM anyway? The website was really techical
13:31:53 <carter> CrazyM4n: or figure outhow to use llvm backedn on windows :)
13:32:01 <carter> CrazyM4n: its a library for compielr backends
13:32:02 <CrazyM4n> *technical
13:32:03 <carter> compiler
13:32:16 <sveit_> frihd1, carter, ok, i will try to be clearer than the code :) ignoring the particular mechanics of how i will handle randomness (i.e. using an infinite list vs one of the mersenne packages vs...) i want a function that takes a number of nodes and some function F that will generate a random place to connect to given the nodes that exist so far and how many connections they have, and generate a size N degree distribution
13:32:17 <carter> ghc has 2-3-4 backedns depending on how you count it
13:32:22 <CrazyM4n> Why would gloss-raster need it then? :P
13:32:49 <sveit_> frihd1, carter, but I think the pseudo-code i gave is clearer than my explanation :)
13:33:01 <carter> sveit_: which distribution
13:33:04 <carter> theres a lot of graph distibution
13:33:05 <carter> s
13:33:27 <frihd1> carter i think the distribution is a parameter too
13:33:32 <carter> frihd1: yeah
13:33:34 <carter> i agree
13:33:51 <sveit_> carter, sorry, i was using frihd1's terminology, "degree distribution" <=> a vector where the ith element indicates how many connections the ith node (in order of "creation") has
13:33:51 <carter> frihd1: i've done some graph theoryish projects before for grad school (that i'd like to finish some time)
13:33:58 <carter> umm
13:34:12 <carter> @google graph degree distribution
13:34:13 <lambdabot> http://en.wikipedia.org/wiki/Degree_distribution
13:34:13 <lambdabot> Title: Degree distribution - Wikipedia, the free encyclopedia
13:34:20 <carter> lets establish some standard vocabulary
13:35:03 <sveit_> carter, apologies, given that i meant a vector of node degrees
13:35:13 <carter> ok,
13:35:14 <carter> now
13:35:20 <frihd1> we wants something like     gen :: Size -> IterationCount -> SampleFunction -> DegreeDistribution
13:35:22 <carter> thats not a distribution :)
13:35:35 <frihd1> ok =)
13:35:47 <CrazyM4n> carter: I can´t find the gloss-raster.cabal file, and I´m looking in %APPDATA%/cabal
13:35:50 <CrazyM4n> Where would it be?
13:35:57 <carter> CrazyM4n: did you cabal get
13:36:08 <carter> and look in the gloss-raster-somethingversions
13:36:10 <carter> folder
13:36:11 <CrazyM4n> Yes
13:36:12 <carter> taht appeard in that fodler
13:36:19 <CrazyM4n> All that´s there is a tar.gz of the package
13:36:22 <CrazyM4n> Is it in there?
13:36:25 <carter> oh
13:36:26 <carter> yeah
13:36:28 <carter> probably
13:36:31 <CrazyM4n> Oh, ok then
13:36:31 <carter> on my mac it unpacks it
13:36:41 <carter> CrazyM4n: ... what √ersion of cabal do you ahve
13:36:48 <carter> ~/D/repoScratcher $ cabal get gloss-raster
13:36:48 <carter> Downloading gloss-raster-1.8.2.1...
13:36:48 <carter> Unpacking to gloss-raster-1.8.2.1/
13:36:54 <carter> is what happened when I just did a cabal get
13:37:03 <CrazyM4n> 1.16.0.2
13:37:15 <CrazyM4n> unrecognized command: get
13:37:17 <CrazyM4n> :S
13:37:22 <carter> lets upgrade your live
13:37:23 <sveit_> carter, frihd1, thank you so much for helping me! second, is this any clearer: i want to generate a vector of node degrees. the way i do this is to say that the nodes are created one by one and connected to an existing node, with probability that i will connect to node "i" dependent on the degree it has at the time of the creation
13:37:24 <carter> *life
13:37:26 <carter> gimme a sec
13:37:44 <carter> sveit_: lets now make that a reasonable probability distribution
13:37:50 <CrazyM4n> Should I just redownload haskell? It´s a couple versions behind anyway
13:38:00 <carter> CrazyM4n: haskell platform has a new distro for windows
13:38:12 <carter> 7.8 + etc
13:38:22 <carter> CrazyM4n: whats ghc --version say?
13:38:26 <CrazyM4n> I´m still on 7.6.3
13:38:35 <CrazyM4n> Is there an update command or should I redownload?
13:38:46 <carter> CrazyM4n: gimem a second
13:38:51 <dreams> is 1 a nullary constructor in Haskell?
13:39:22 <carter> CrazyM4n: so what you could do in 5 seconds is http://www.haskell.org/cabal/download.html has a link to a cabal-install 1.20 binary
13:39:25 <carter> CrazyM4n: BUT
13:39:27 <frihd1> sveit_:  your algorithm is imperative, hence I'd use something like a State monad to define a "step" and then you can replicateM_ this step
13:39:37 <carter> CrazyM4n: i'd suggest doing full haskell platform update
13:39:45 <carter> https://www.haskell.org/platform/windows.html
13:39:49 <CrazyM4n> carter: Sounds good
13:40:03 <carter> CrazyM4n: if only because i don't know how to help with any more clever approach on windows
13:40:15 <CrazyM4n> carter: Do the old cabal packages get redownloaded? Or do I have to manually download the new versions
13:40:20 <carter> cabal update
13:40:26 <CrazyM4n> KK
13:40:27 <carter> will dl the pkg index
13:40:30 <carter> CrazyM4n: BUT
13:40:36 <carter> dl and run the windows installer
13:40:37 <frihd1> then your "step" function draws a random number from your random generator and mutates the current state (possibly with a mutable array)
13:40:39 <carter> for platform
13:40:42 <carter> yeah
13:40:45 <carter> frihd1: ++
13:40:54 <CrazyM4n> also, do you know how well the 64-bit version works? I´m scared to use it after the terrible experience with 64-bit python
13:41:06 <carter> CrazyM4n: if it doesnt work, rais hell on the issue tracker
13:41:16 <CrazyM4n> Sounds good, haha
13:41:22 <carter> https://github.com/haskell/haskell-platform/issues
13:41:29 <chrisdone> anyone ever got "unable to load package `atomic-primops-0.6.0.6'" in ghci?
13:41:35 <CrazyM4n> In python 32-bit and 64-bit are practically seperate specifications
13:41:36 <sveit_> frihd1, ok, so back to the beginning of the discussion, there's really nothing better than a mutable array for this? I'm willing to overhaul the algorithm, it just bothers me that so many problems seem like they are inherently imperative and i was hoping something simple like this could be made functional
13:41:43 <carter> chrisdone: its a ryan newton package
13:41:49 <chrisdone> yup
13:41:51 <carter> chrisdone: depending on the GHC version, it uses CMM i think
13:42:03 <chrisdone> what does that imply?
13:43:28 <frihd1> well you can use a probably use a heap or a map to represent your vector, but if your problem calls for a mutable vector, why would you shoehorn something else?
13:45:52 <sveit_> frihd1, because maybe i'm an idiot and there's an elegant, performant, functional way to solve my problem :)
13:45:56 <carter> chrisdone: lemme look
13:46:02 <carter> chrisdone: what ghc version are youon too?
13:46:09 <carter> chrisdone: does it work with cabal repl?
13:46:21 <carter> ohh, you cabal installed and tried to use?
13:46:34 <merijn> CrazyM4n: The 64-bit version works excellent, but you may not necessarily want to use 64bit
13:46:56 <merijn> CrazyM4n: 64bit code is generally significantly slower than 32bit
13:47:02 <carter> merijn: ..... wat
13:47:07 <chrisdone> carter: ghc 7.8.3. it's just a transitive dependency of a larger project. i get: unknown symbol `store_load_barrier
13:47:07 <chrisdone> carter: reading this https://github.com/rrnewton/haskell-lockfree/issues/10#issuecomment-53515930 i think dynamicness might be related
13:47:09 <merijn> carter: C too
13:47:10 <carter> merijn: only if youre memory traffic bounded
13:47:26 <merijn> carter: double pointers size wrecks your cache too
13:47:31 <carter> merijn: yes
13:47:34 <carter> but MOAR registers
13:47:39 <carter> so inner loops are awesome
13:47:40 <chrisdone> carter: loading in ghci works, but i get this trying to load via the ghc api. i must be missing a dynamic-by-default setting that ghc 7.8 enabled?
13:47:50 <carter> oh yeah
13:47:52 <carter> that could do it
13:47:58 <carter> ghc api might default to static loading
13:48:07 <chrisdone> right.lemmie try changing that
13:48:59 <merijn> carter: The whole program benchmarks I've seen so far looks like 64bit code tends to be around 10%-20% slower in most cases (C/C++ benchmarks in this case)
13:49:01 <frihd1> sveit_:  you're probably not, but I don't really know what you're after. maybe you just need to wander in the containers package to learn what are the elegant data structures =)
13:49:09 <carter> merijn: what benchmarks
13:49:12 <carter> merijn: on windows or period?
13:49:21 <merijn> linux
13:49:32 <carter> merijn: ... i suspect those aren't floating point heavy things
13:49:36 <merijn> Sure
13:49:44 <carter> i need those 16 simd + 16 gpr
13:49:50 <carter> or i will get mad/sad
13:50:00 <merijn> carter: Sure, but I was talking to CrazyM4n asking about 32bit vs 64bit
13:50:15 <carter> merijn: ooth, depends  on what his heap sizes are
13:50:15 <frihd1> then, if you really need perfs, you'll probably won't beat space and lookup/modify efficiency of a mutable array
13:50:26 <merijn> carter: I assume you know what you want, but most people seem to assume 64bit is always faster
13:50:29 <sveit_> frihd1, it seems unfortunate that so many simple problems are "inherently" imperative. it seems as you scale up things begin to become functional, but the details seem to be imperative
13:50:33 <frihd1> besides changing your algorithm to directly sample the distribution =)
13:50:44 <carter> frihd1: and sveit_  should use  storabe/unboxed >>> boxed
13:50:45 <carter> :)
13:51:37 <sveit_> frihd1, is there a generic way to do that given how general i want my process to be, with the probability function being of arbitrary complexity?
13:51:58 <carter> sveit_: i think frihd1  sketech one out
13:51:59 <carter> :)
13:52:15 <carter> traverse + statemonad + stuff
13:52:28 <chrisdone> carter: do you know the right flag to make ghc use dynamic loading?
13:52:37 <carter> you mean in dynflags?
13:52:45 <chrisdone> yeah, or as parseable
13:53:00 <sveit_> carter, but at the base that's still doing what i was doing from the beginning, hidden in a state monad...?
13:53:02 <carter> parseable?
13:53:11 <carter> sveit_: not quite...
13:53:12 <carter> :)
13:53:17 <chrisdone> carter: either text flags or the well typed dynflags will do
13:53:31 <carter> chrisdone: honestly dont know that part of ghc that welll
13:53:45 <carter> chrisdone: trying to finish up some work work so i can't help dig around righ tnow :)
13:54:10 <sveit_> carter, sorry to keep bothering you, but how's it different? i still store the vector in the state monad, i still need random updates to do what i want, etc.
13:54:30 <carter> sveit_: i gotta go finish some work work sadly
13:54:35 <carter> so i can't help you for an hour or two
13:54:46 <sveit_> carter, ok, thanks anyway
13:55:02 <CrazyM4n> carter: thanks for the help with gloss-raster
13:55:16 <carter> :)
13:56:04 <frihd1> sveit_: yes, I think it's gonna be mostly similar but with a different way to pass the state and the random-sampler function around
13:56:28 <carter> generality can induce better formulations
13:56:31 <carter> or confusion :)
13:56:54 <frihd1> when the essence of your algorithm is   read & flip a coin / write ; there are little ways out
13:58:06 <carter> frihd1: i wonder if he can do it in paralle
13:58:30 <frihd1> I don't think so, the "flip a coin" is biased on the previous state
13:59:03 <carter> in this formulation, yes
13:59:04 <frihd1> if the "flip a coin" function has some special structure, he may flip two coins
13:59:36 <carter> frihd1: you coudl do speculative flips
13:59:43 <carter> and only commit the ones that dont conflict
13:59:48 <carter> like
13:59:59 <carter> what if you picked uniformly on all the edges
14:00:09 <carter> and used that to induce the degree distribtuion
14:05:04 <Rags> how to reverse the sort order on a list using compare?
14:05:15 <frihd1> carter i've no idea
14:05:34 <carter> Rags: you could swap the GT and LT constructors
14:05:57 <carter> flipCompare  EQ = EQ ; flipCompare LT = GT ; flipCompare GT = LT
14:06:02 <carter> then flipCompare . compare
14:06:40 <shiona> There's also Ord a => Ord (Down a)
14:06:42 <geekosaur> wouldn't the easier way just be flip compare?
14:06:45 <HeladoDeBrownie> Wouldn't this server, or is it different? flip compare
14:06:49 <merijn> carter: ...
14:06:49 <HeladoDeBrownie> serve*
14:06:53 <benmachine> everyone always kicks themselves when they realise
14:06:58 <merijn> Why not "sortBy (flip compare)"?
14:06:58 <carter> geekosaur: good point
14:07:03 <carter> merijn: derp
14:07:06 <carter> that w'ork
14:07:11 <HeladoDeBrownie> Woops, a mountain of people just jumped on that
14:07:24 <carter> i'm kinda juggling sorting out what work i'm doing for october right now
14:07:36 <carter> so i'm more so in "make surepeople are happy and wanna pay me for projects / things"
14:07:36 <carter> mode
14:08:21 <koala_man> sort's stable, right? if so, arguably you'd want to reverse the list before sorting it too
14:10:35 <Rags> merijn -> my list is [(String, Int)] and using sortBy( compare `on` snd )
14:11:24 <Rags> where do i add flip to sortBy( compare `on` snd )
14:12:07 <geekosaur> :t flip compare `on` snd
14:12:08 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
14:12:28 <Rags> that worked
14:12:34 <frihd1> Rags where it typechecks ;)
14:13:31 <HeladoDeBrownie> frihd1, am I doing it right? compare `flip` snd -- :P
14:13:41 <merijn> :t comparing
14:13:42 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:13:58 <HeladoDeBrownie> (was being facetious, ignore that)
14:15:59 <frihd1> HeladoDeBrownie:  no problem, i come from a land of cheeses and sarcasms =)
14:18:29 <SideEffffECt> hello,
14:18:31 <SideEffffECt> I have problem with installing packages from Stackage
14:18:33 <SideEffffECt> the error is
14:18:35 <SideEffffECt>         Failed to install monoid-subclasses-0.3.6.1
14:18:37 <SideEffffECt>         Last 10 lines of the build log ( /home/ubuntu/.cabal/logs/monoid-subclasses-0.3.6.1.log ):
14:18:39 <SideEffffECt>         cabal: /home/ubuntu/.cabal/logs/monoid-subclasses-0.3.6.1.log: does not exist
14:18:41 <SideEffffECt> the full logs are verbose, but very unhelpful, maybe you will see more than I do now, here they are:
14:18:43 <SideEffffECt> https://app.wercker.com/#deploystep/542de11d3e1d33741c0529ce
14:18:45 <SideEffffECt> thank you for help :)
14:19:35 <mcbears> resource request - I once saw philip wadler talk about why having methods in the top object of a subtyping hierarchy (e.g. toString in java's Object) is bad. I know it would invalidate reasoning about parametricity, but does anyone know of a place where someone's recorded thoughts about this?
14:20:23 <gdoteof> how do i get a string out of a conduit source?  i have `  resValue <- responseBody res $$ ?????
14:20:49 <gdoteof> i just want to fully consume it and spit it out as a [char]
14:21:40 <Clint> gdoteof: Data.Conduit.List.consume?
14:22:53 <gdoteof> seems perfect
14:23:55 <carter> mcbears: basically everything has to provide it then
14:24:11 <carter> mcbears: eg, not everything has a sane string rep or hash value
14:24:17 <carter> but eerything has to pretend to have one in java
14:25:27 <ReinH> Anyone here use Shelly and had an issue where output isn't interleaving correctly? i.e. if I have an echo and then a run, the first lines of the echo and run are interleaving character by character in a weird way. Can I correct this with setBuffering or so?
14:26:34 <ReinH> (the stdout output)
14:27:11 <CrazyM4n> Oh goody, cabal says that it doesn´t exist
14:27:29 <lpaste> Clint pasted “GADT / Reader confusion” at http://lpaste.net/112029
14:27:37 <Clint> can anyone help me figure out how to do R correctly? ^
14:27:50 <ReinH> Will try `hSetBuffering stdout LineBuffering'
14:28:25 <CrazyM4n> http://prntscr.com/4ss3v4 Uhm, I don´t have any idea where to go from here
14:28:51 <CrazyM4n> I blame 64-bit haskell, I´m going to try the 32-bit version
14:28:56 <CrazyM4n> No need to change what worked before
14:31:14 <stulli> tp://lpaste.net/112029
14:31:14 <stulli> 23:28 (     Clint:#haskell ) can anyone help me figure out how to do R correctly? ^
14:31:17 <stulli> 23:28 (     ReinH:#haskell ) Will try `hSetBuffering stdout LineBuffering'
14:31:19 <stulli> 23:28 (  CrazyM4n:#haskell ) http://prntscr.com/4ss3v4 Uhm, I don´t have any idea where to go from here
14:31:26 <stulli> ups, sorry
14:39:19 <RedNifre> How do I make a function right associative, like $
14:40:05 <mcbears> infixr $
14:40:07 <mcbears> at the toplevel
14:40:22 <egasimus> What do I do? cabal build says "Could not find module 'Control.Monad.Except'", even though `mtl` is added to my (only) executable's build-depends
14:41:11 <mcbears> infixr <operatorname> <precedencelevel> (and there's also "infixl" for left associativity, and just "infix" for non-associative operators)
14:42:08 <mcbears> (er, infix declaration at the same level as the operator definition)
14:42:38 <RedNifre> is "operator" a synonym for function, or are those different?
14:43:00 <HeladoDeBrownie> RedNifre, "operator" refers to a function in its infix-applied form.
14:43:07 <HeladoDeBrownie> Roughly.
14:43:13 <CrazyM4n> Where does cabal get installed? I have to add it to the path
14:43:14 <mcbears> $ is an operator, ($) is a function
14:43:25 <mcbears> so you would use $ in an infix declaration, not ($) :)
14:43:46 <RedNifre> is there a convention which things are infixr and which are infixl?
14:44:25 <HeladoDeBrownie> Not really, but there may be reasons for doing one or the other, like how $ lets you get rid of parens
14:44:26 <mcbears> sometimes certain things are more efficient one way or the other (++ is linear time associated to the right and quadratic associated to the left)
14:45:11 <mcbears> other than that, you can think about what operators you might use it together with and choose the one that meshes best
14:45:50 <hexagoxel> CrazyM4n: ~/.cabal/bin/cabal (if you install using cabal)
14:46:05 <HeladoDeBrownie> Keeping in mind that you cannot mix left and right at the same precedence
14:46:19 <HeladoDeBrownie> You'd have to use parens to disambiguate if you ran into that
14:46:40 <RedNifre> hm. (maybe (should (like (use language parethesis) lisp)))
14:46:59 <mcbears> you can do that if you want! just be sure you have a hiding place ready
14:47:13 <RedNifre> :)
14:48:54 <hexagoxel> egasimus: what version of mtl do you have installed? (probably not the required one)
14:50:18 <egasimus> hexagoxel: `cabal info mtl` -> Versions installed: 2.1.3.1, 2.2.1
14:50:38 <egasimus> `cabal build` says `Control.Monad.Except` is member of hidden package `mtl-2.2.1`
14:51:53 <hexagoxel> egasimus: have you specified the correct version (2.2.1) in your dependencies?
14:52:28 <egasimus> hexagoxel: it just says `mtl` currently
14:52:36 * hackagebot pwstore-fast 2.4.4 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.4.4 (PeterScott)
14:52:38 * hackagebot pwstore-purehaskell 2.1.4 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.1.4 (PeterScott)
14:52:57 <hexagoxel> egasimus: "mtl >= 2.2.1", maybe
14:53:10 <CrazyM4n> So, I still haven´t been able to get gloss-raster working
14:53:17 <CrazyM4n> I finally got cabal get working
14:53:29 <CrazyM4n> Ahhh, I found the file
14:54:01 <CrazyM4n> Now that I removed the -fllvm, how do I take an unpacked cabal package
14:54:03 <CrazyM4n> And install it?
14:54:26 <egasimus> hexagoxel: hooray! it worked. however I'm getting a warning about depending on multiple versions of the same package
14:55:00 <egasimus> and I get a list of things that depend on mtl-2.1.3.1; and transformers-0.3.0.0 while mtl-2.2.1 depends on transformers-0.4.1.0
14:55:11 <egasimus> but if I specify mtl >= 2.1.3.1, I get that error again.
14:55:29 <CrazyM4n> http://www.haskell.org/ghc/docs/7.0.2/html/Cabal/builders.html Are these instructions still correct?
14:55:29 <hexagoxel> (because mtl 2.1.3.1 does not have Control.Monad.Except)
14:56:53 <egasimus> hexagoxel: yeah... how much of a pain in the ass are the mixed up dependencies though?
14:57:10 <RedNifre> I don't quite understand how naming operators work. ,, is not a valid name, but where would you write ,, ? And why can't I name my operator :^ ?
14:57:11 <CrazyM4n> How do I purposely install an older version of a package?
14:57:16 <CrazyM4n> I need Repa 3.2 but I have 3.3
14:57:27 <hexagoxel> egasimus: dunno, i only use sandboxes and this has not happened to me.
14:57:44 <HeladoDeBrownie> @type (,,)
14:57:46 <lambdabot> a -> b -> c -> (a, b, c)
14:57:50 <hexagoxel> egasimus: maybe you can update the dependencies that depend on 2.1.3.1?
14:58:07 <glguy> egasimus: You should be using the transformers that came with your GHC and the matching version of mtl, generally
14:58:07 <HeladoDeBrownie> RedNifre, : means it's an operator data constructor
14:58:24 <HeladoDeBrownie> Since there's no such thing as an upper case symbol that's the distinction used instead
14:58:27 <glguy> egasimus: so transformers-0.3.0.0 and mtl-2.1.3.1
14:58:45 <egasimus> glguy: what if I need Control.Monad.Except though
14:58:57 <glguy> then use tranformers-compat package
14:59:51 <egasimus> glguy: that only seems to have Control.Monad.Trans.Except, and I don't think that module has ExceptT
15:00:52 <CrazyM4n> Well, I give up
15:00:54 <egasimus> glguy: hmm, or it might have it actually
15:00:57 <merijn> RedNifre: Read the haskell report, it describes exactly which characters are valid in which names
15:01:00 <glguy> egasimus: That's the point of that module
15:01:26 <merijn> RedNifre: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html
15:02:15 <egasimus> glguy: so I'm apparently on ghc 7.8.3, which seems to be the latest stable release -- where are the newer libraries from then? betas?
15:02:21 <hexagoxel> CrazyM4n: cabal install Repa-3.2
15:02:35 <CrazyM4n> hexagoxel: It still detects only 3.3
15:02:37 <RedNifre> thanks
15:02:42 <glguy> egasimus: transformers-0.4 will get included in the next GHC release presumably
15:03:11 <hexagoxel> CrazyM4n: you are not using sandboxes, right?
15:03:36 <CrazyM4n> http://prntscr.com/4ssglt
15:03:45 <CrazyM4n> No, I´m not, and yet this still happens
15:06:10 <RedNifre> So, I created my own list operator that works like 5 ^: "hello" ^: [], but I neither like that I have to end every list with ^: [] nor the Applicative solution of using e.g. ^^: before the last element of the list. Is there a way to write something like [5 ^, "bla"], where I can define where the last ^, and the other ^, map to?
15:06:13 <hexagoxel> CrazyM4n: what if you just do "cabal install gloss-raster"?
15:06:17 <t4nk252> Hello dear Haskelles, i have researched for about 3 hours, why should I learn Haskell.The two most prominent answers that come up are: it changes the way you think and your code is less error prone then compared to specific languages for example imperative languages.I want to know your thought/critics on it. Im sorry if  there are any grammatical errors, Im still learning the English language.Thank you for your time. :)
15:06:37 <CrazyM4n> hexagoxel: It doesn´t find llvm
15:06:42 <CrazyM4n> So I had to get it to disable llvm
15:06:49 <CrazyM4n> And now I can´t compile it from here
15:06:54 <merijn> egasimus: transformers, etc. are a bit weird in that they are not *part* of GHC, but GHC uses them (i.e. GHC is implemented using transformers, etc.) so any package that links against GHC can never use a version then whatever GHC uses
15:07:00 <hexagoxel> CrazyM4n: did you edit the .cabal?
15:07:06 <CrazyM4n> hexagoxel: Yes
15:07:26 <RedNifre> wait, that made no sense. I meant something like [5 ^, "bla"] where I can define what is implicitely at the right side  of "bla", namely "^, []" in this case.
15:07:37 * hackagebot haste-compiler 0.4.3 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.3 (AntonEkblad)
15:07:40 <merijn> egasimus: The developers of transformers develop independently of GHC, which means that they release new versions in between GHC releases, but these are not practically usable until the next GHC release updates the version it ships with
15:07:55 <RedNifre> Just like where [1,2] has an implicit :[] at the right side of the 2.
15:08:07 <egasimus> merijn: well, that explains things.
15:08:32 <egasimus> the question then becomes: what version was srhb using when he wrote the code i'm trying to run :D
15:08:37 <merijn> egasimus: You can use them if you're 100% sure you and none of your dependencies will ever link with ghc/ghc API, etc.
15:09:05 <merijn> RedNifre: You can't get the behaviour of what [1,2] has, it's baked into GHC
15:09:06 <CrazyM4n> hexagoxel: Do I have to unpack repa and gloss also?
15:10:04 <merijn> RedNifre: What is "[5 ^, "bla"]" supposed to be? Right now that's a list with a single item (the result of applying (^,) to 5 and "bla")
15:10:06 <hexagoxel> CrazyM4n: i don't think that would help
15:10:32 <hexagoxel> what do you mean "you can not compile it from here"?
15:10:43 <RedNifre> Well, a ^, b = toSql : b
15:11:04 <CrazyM4n> hexagoxel: I mean that it tells me that it doesn´t have either repa or gloss
15:11:16 <CrazyM4n> Even though the correct versions of both of those are installed
15:11:18 <RedNifre> so (5 ^, "hello" ^, []) becomes a list of the SqlValues of what I concatenate
15:11:37 <RedNifre> So it works like : except that it works with Convertible a SqlValue
15:13:31 <RedNifre> The way I picture it is this:   5:3:[] has this annoying :[] at the end. When using [ ] with , in it, the , gets substituted with : and it adds an :[] at the end. Therefor [5,3] = 5:3:[]. Now, I would like to declare that a ^, used in [ ] gets substituted with my ^: with a ^: [] at the end.
15:13:52 <RedNifre> Maybe you could even skip the explicit "add :[] at the end" and have that as a default.
15:14:04 <hexagoxel> CrazyM4n: you i see the corresponding output?
15:14:25 <RedNifre> As it [a * b * c] just means a * b * c * []
15:15:09 <CrazyM4n> hexagoxel: http://prntscr.com/4sskgh
15:15:09 <RedNifre> Then I could write [5 ^, "hello" ^, "something"] and it would compile as (5 ^, "hello" ^, "something" ^, [])
15:15:27 <RedNifre> Does this make sense?
15:15:33 <vanila> RedNifre, not 100%
15:15:51 <hexagoxel> CrazyM4n: that's not the output of "cabal install gloss-raster"
15:16:27 <CrazyM4n> Oh, oops
15:16:47 <CrazyM4n> http://prntscr.com/4ssl0q
15:17:00 <CrazyM4n> And yes, I have attempted to install LLVM, but haskell doesn´t detect it on windows
15:17:03 <RedNifre> Okay, say you have an imaginary list of things that don't have the same type, which is impossible in Haskell. Now you want to map that list to items of the same type, which you can do because all of the items are Convertible a SqlValue.
15:17:41 <ReinH> RedNifre: (you can have a heterogeneous list in Haskell)
15:17:43 <RedNifre> Since you can't write that imaginary list I put the mapping in my own ^: operator, namely a ^: b = fromSql a : b
15:17:50 <RedNifre> Really?
15:18:06 <RedNifre> I thought that only worked for tuples
15:18:11 <ReinH> @hackage HList
15:18:11 <lambdabot> http://hackage.haskell.org/package/HList
15:18:19 <ReinH> There are usually better solutions, but it exists
15:18:19 <RedNifre> > [5,"hello"]
15:18:21 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
15:18:21 <lambdabot>    arising from the literal ‘5’
15:19:12 <CrazyM4n> hexagoxel: Any ideas?
15:22:53 <RedNifre> Well, I don't want to create a heterogenous list, I want to write a statement in list syntax with heterogenous elements that results in a homogenous list.
15:23:25 <RedNifre> What is the process for getting language extensions into GHC? ;)
15:24:00 <glguy> RedNifre: https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/AddingFeatures
15:24:29 <zmbmartin> How would you handle a global config that you want to be able to access around the a scotty app?
15:24:41 <glguy> It involves writing out what you want, having discussions, implementing it, testing it, etc
15:24:51 <hexagoxel> CrazyM4n: not really. afaik "cabal install" should install the package in the current directory. if you removed the -fllvm, the error you have does not make much sense.
15:25:17 <hexagoxel> CrazyM4n: maybe, just to make sure, increase the version number in .cabal, and install that specific version?
15:25:41 <CrazyM4n> hexagoxel: i could try
15:25:57 <RedNifre> Thanks glguy
15:27:30 <glguy> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists might be relevant to you. I haven't been following your discussion closely
15:27:56 <CrazyM4n> hexagoxel: Nope, doesn´t even work if you make the versions really broad
15:29:29 <hexagoxel> hmm i already use mtl-2.2.1 atm.. good to know i might not want to, yet :D
15:30:28 <hexagoxel> there should be .. some kind of notice "this is the version of this library's interface you want to be using with latest stable ghc" on hackage
15:30:44 <CrazyM4n> I have no incentive to stay on windows other than my files
15:30:57 <CrazyM4n> I´m just going to go install ubuntu or something
15:31:02 <CrazyM4n> This is kinda the last straw, lol
15:31:31 <joseph07> RedNifre: there may be another way: http://okmij.org/ftp/Haskell/polyvariadic.html#introduction
15:33:29 <juanpablo_> quick question: is bind a natural transformation?
15:33:44 <juanpablo_> is >=> a natural transformation?
15:34:16 <CrazyM4n> Is the latest version of ubuntu pretty good? I don´t have room to dual boot
15:34:30 <CrazyM4n> I also don´t have too many files I´m afraid to lose
15:35:39 <vanila> :t (>=>)
15:35:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:35:51 <vanila> this can't be seen as a natural transform
15:37:38 * hackagebot ghc-mod 5.1.1.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.1.1.0 (DanielG)
15:37:39 <juanpablo_> So if one considers monad as monoid in the category of endofunctors, then what's the "mconcat" for monads?
15:38:10 <vanila> :t mconcat
15:38:11 <lambdabot> Monoid a => [a] -> a
15:38:20 <vanila> :t mappend
15:38:21 <lambdabot> Monoid a => a -> a -> a
15:38:34 <juanpablo_> mappend sorry. I mixed up the terms
15:38:50 <HeladoDeBrownie> join, no?
15:39:11 <vanila> :t msum
15:39:12 <lambdabot> MonadPlus m => [m a] -> m a
15:39:16 <vanila> :t mplus
15:39:16 <lambdabot> MonadPlus m => m a -> m a -> m a
15:39:17 <vanila> thismaybe?
15:39:21 <vanila> not al monads have it
15:39:41 <HeladoDeBrownie> You're just asking what's the monoidal operation, and that would be join
15:39:56 <HeladoDeBrownie> (F, join, return) form the monoid
15:40:06 <HeladoDeBrownie> where F is the underlying functor
15:40:14 <vanila> what monoid
15:40:14 <HeladoDeBrownie> s/monoid/monad/
15:40:17 <vanila> oh ok
15:40:31 <Thooms> is there any monad not build upon a functor ?
15:40:34 <HeladoDeBrownie> And join would then be the analog of the monoidal operation
15:40:36 <HeladoDeBrownie> Thooms, no
15:40:50 <Thooms> ok
15:41:15 <Thooms> is that structural, or more like a mathematical result?
15:41:49 <HeladoDeBrownie> Monad can be defined directly in terms of functor, and with any equivalent formulation you can pick out the underlying functor. (I have no proof of this readily at hand, read up on ncatlab or the like)
15:42:29 <Thooms> will do, thx :)
15:43:06 <juanpablo_> So, if there's a monoid in the category of endofunctors then what's the associative operation in such a monoid?
15:43:07 <RedNifre> joseph07 fascinating
15:44:04 <davidthomas> juanpablo_: (>=>)?
15:44:24 <HeladoDeBrownie> No, that's composition in the Kleisli category over that monad
15:44:40 <HeladoDeBrownie> I think the question is just a rephrasal of the one I already answered by saying join
15:45:13 <etandel> :t join
15:45:14 <lambdabot> Monad m => m (m a) -> m a
15:45:33 <juanpablo_> :t mappend
15:45:34 <lambdabot> Monoid a => a -> a -> a
15:45:43 <juanpablo_> Those don't look isomorphic to me
15:45:58 <HeladoDeBrownie> It helps if you imagine join's type as m . m → m
15:46:10 <HeladoDeBrownie> I hope I wrote that correctly
15:46:11 <vanila> m . m → m  it'sa natural transform!
15:46:21 <vanila> between functors
15:46:46 <benzrf> :t uncurry mappend
15:46:47 <lambdabot> Monoid c => (c, c) -> c
15:46:54 <benzrf> :t join
15:46:55 <lambdabot> Monad m => m (m a) -> m a
15:47:03 <benzrf> m . m -> m
15:47:06 <HeladoDeBrownie> juanpablo_, Haskell's type system can't express the CT formulation of join as it is written; it has to bring in the a to apply m to.
15:47:12 <juanpablo_> benzrf: It makes sense now!
15:47:20 <benzrf> the a's are there becaues it's being expressed as a polymorphic morphism
15:47:20 <HeladoDeBrownie> I wrote that weird, let me know if I should rephrase
15:47:24 <benzrf> instead of as a natural transformation
15:47:32 <juanpablo_> HeladoDeBrownie: rephrasing would help :)
15:47:51 <HeladoDeBrownie> benzrf, want to take this? I think you can explain better
15:47:55 <benzrf> oh sure :-)
15:48:04 <benzrf> juanpablo_: how familiar are you with CT
15:48:46 <juanpablo_> benzrf: I know up to some natural transformations, but not much more than that
15:49:00 <benzrf> that's fine!
15:49:05 <benzrf> do you know what a bifunctor is?
15:49:58 <juanpablo_> benzrf: more or less, yes. Go ahead and I'll decode your answer for a few minutes :)
15:50:07 <benzrf> OK!
15:50:16 <benzrf> juanpablo_: consider a category C.
15:50:26 <benzrf> and a bifunctor ⊗
15:50:46 <benzrf> ⊗ (A, B) will be denoted as A ⊗ B, just like with monoids in abstract algebra :v
15:51:37 <benzrf> a "monoidal category" is a combo of a category and a bifunctor such that the bifunctor acts more or less monoidally on the category's objects
15:51:43 <benzrf> to be precise,
15:52:02 <benzrf> a category C with a bifunctor ⊗ is a monoidal category if and only if:
15:52:22 <Arahael> As a naive, total Haskell newbie, could I have a simple explaination of the various types of strings and what OverloadedStrings does?
15:52:31 <benzrf> 1. for all objects A, B, C: (A ⊗ B) ⊗ C ≅ A ⊗ (B ⊗ C)
15:52:39 * hackagebot hindent 3.6 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.6 (ChrisDone)
15:53:03 <benzrf> 2. there is an 'identity' object I such that for all objects A: A ⊗ I ≅ A and I ⊗ A ≅ A
15:53:08 <benzrf> juanpablo_: follow?
15:53:12 <Arahael> Because right now I have ByteString, Lazy ByteString, CI ByteString, Text, Lazy Text, and String.  I have found (from documentation) that ByteString concatenation is O(n), so I want to know what I should be using for "generic" unicode-aware strings.
15:53:34 <stephenmac7> I have a question: If I have types that need to simulate with (simulated) passage of time, how would I apply the time passage to them (expecially if they are fields of other types)?
15:53:49 <juanpablo_> benzrf: mostly. go ahead :)
15:53:57 <benzrf> juanpablo_: mostly is bad! what part don't you follow?
15:54:04 <benzrf> juanpablo_: please please PLEASE ask clarifying questions
15:54:41 <geekosaur> generic unicode strings typically should be Text or Lazy Text. ByteStrings should be used for octet strings (e.g. network streams), not Unicode. The bult-in String type is appropriate for very short strings or when you have a reasonable expectation that operations will fuse them away, because otherwise they're fairly inefficient linked lists.
15:54:57 <geekosaur> Arahael ^^
15:55:28 <Arahael> geekosaur: Thanks for that summary - I'll use Text, converting to and fro from ByteString as neccessary.
15:55:40 <juanpablo_> benzrf: ok so we need a bifunctors as the operation on the monads, that's what I got
15:55:50 <stephenmac7> So, for example, if I have a data types: data Company = Company { employees :: [Employee], age :: Int} and Employee { age :: Int }, then how would I apply aging to both without manually traversing the structure
15:55:52 <juanpablo_> benzrf: that bifunctor is join?
15:55:57 <geekosaur> when to use a strict vs. lazy type mainly is an issue of whether you are processing an entire string as a chunk or working incrementally; processing a 3G document as a strict string is usually a mistake
15:56:02 <benzrf> juanpablo_: no!!
15:56:16 <benzrf> juanpablo_: i'm not talking about monads right now!
15:56:31 <Arahael> geekosaur: I think the distinction isn't important for me at this stage, although I do want to know what 'OverloadedStrings' does.
15:56:55 <juanpablo_> benzrf: ok. I was trying to relate it to monads
15:57:02 <benzrf> juanpablo_: don't worry about that yet
15:57:06 <benzrf> Arahael: it makes "literals like this" polymorphic the way numeric ones are
15:57:13 <geekosaur> it's a way to let developers write functions that can operate on any string type; when enabled, it converts literal strings to things of type IsString a => a
15:57:26 <benzrf> juanpablo_: ok
15:57:30 <geekosaur> similarly to how literal numbers become Num a => a
15:57:37 <benzrf> juanpablo_: notice that i'm using ≅ and not =
15:57:43 <Arahael> benzrf: So that's why they somehow seemed to work for Text as well as String types - nifty.
15:57:47 <benzrf> juanpablo_: i assume you're familiar with ≅?
15:58:10 <RedNifre> Text is real Unicode, String is a list of values between 0 and about 1114111 which is sort of okay for unicode but can also contain invalid code points.
15:58:23 <geekosaur> (most specifically, it wraps string literals in fromString so they get turned from linked lists to the appropriate string type based on usage)
15:58:28 <juanpablo_> benzrf: not really. I'm guessing isomorphic?
15:58:51 <benzrf> juanpablo_: yeah.
15:58:59 <geekosaur> (like integer literals are wrapped in fromInteger and decimal literals wrapped in fromRational)
15:59:06 <stephenmac7> RedNifre: That is the first real explanation I've heard about what String is and why it's bad
15:59:15 <benzrf> juanpablo_: to be precise, the isomorphisms in these laws are named
16:00:23 <RedNifre> Great, then this was my first helpful Haskell comment :)
16:00:25 <benzrf> juanpablo_: first we have the natural isomorphism (just a natural transformation where all of the morphisms are isomorphisms) α (for associative)
16:00:59 <benzrf> juanpablo_: for any objects A, B, and C, \alpha_A,B,C : (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C)
16:01:24 <juanpablo_> benzrf: ok, still following
16:01:27 <benzrf> juanpablo_: next we have the natural isomorphism λ (for left identity)
16:01:56 <benzrf> for any object A, λ_A : I ⊗ A -> A
16:02:00 <stephenmac7> Anyone use the unicode mode for haskell?
16:02:15 <benzrf> and finally there's ρ (for right identity), which is just λ in reverse:
16:02:17 <Arahael> The documentation for 'Data.Text' has many functions, some of which contains the phrase: "Subject to fusion" <-- What the heck is "fusion"?
16:02:20 <stephenmac7> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
16:02:25 <benzrf> for any object A, ρ_A : A ⊗ I -> A
16:02:34 <stefan_1_> Hi, is there a good resource for beginner-intermediate haskell video tutorials somewhere?
16:02:39 <benzrf> juanpablo_: let me give you an example of a monoidal category!
16:02:50 <juanpablo_> benzrf: cool :)
16:02:53 <benzrf> juanpablo_: Hask with (,) is monoidal!
16:03:05 <geekosaur> Arahael: in a lazy language, one trick that's available is that you can arrange to pipeline creation, processing, and disposal of values together
16:03:19 <geekosaur> so if you have a notional string, you may never create it
16:03:20 <benzrf> @let associate ((a, b), c) = (a, (b, c))
16:03:22 <lambdabot>  Defined.
16:03:24 <karshan_> benzrf: what is mempty ?
16:03:24 <benzrf> :t associate
16:03:25 <lambdabot> ((t, t1), t2) -> (t, (t1, t2))
16:03:25 <geekosaur> we say the string was fused away
16:03:28 <benzrf> karshan_: hold on
16:03:31 <Arahael> geekosaur: Nifty.
16:03:34 <benzrf> juanpablo_: there's α
16:03:46 <Arahael> geekosaur: Why might that matter to us? (Isn't it "just" optimisation?)
16:03:56 <benzrf> juanpablo_: () is I, because:
16:04:01 <geekosaur> it's not always possible to fuse strings away, but when it is its a major performance and memory win
16:04:07 <benzrf> @let leftID ((), v) = v
16:04:09 <lambdabot>  Defined.
16:04:10 <geekosaur> s/its/it's/
16:04:11 <benzrf> :t leftID
16:04:12 <lambdabot> ((), t) -> t
16:04:17 <benzrf> juanpablo_: that's λ!
16:04:17 <moldy> hi
16:04:24 <benzrf> juanpablo_: you'll notice that it's an isomorphism
16:04:32 <benzrf> juanpablo_: you can always get back by putting a () in the left
16:04:33 <geekosaur> and yes, it's "just" an optimization. but it's a really powerful optimization
16:04:35 <RedNifre> stephenmac7 I cant' see the double arrow tails
16:04:36 <benzrf> juanpablo_: unlike snd in general
16:04:47 <juanpablo_> benzrf: seems simple enough until now.
16:04:50 <benzrf> yep!
16:04:50 <Arahael> geekosaur: So it might matter becuase someone who needs fusion and is optimising their app to leverage it, would be specifically looking for functions that specifically allow it?
16:04:53 <benzrf> @let rightID (v, ()) = v
16:04:54 <lambdabot>  Defined.
16:04:57 <geekosaur> it's the kind of thing that, when you can pull it off, makes Haskell faster than well written C
16:05:00 <benzrf> juanpablo_: that's ρ
16:05:09 <stephenmac7> RedNifre: I second that
16:05:26 <benzrf> juanpablo_: so that's what a monoidal category is
16:05:35 <benzrf> juanpablo_: you can only have monoids in monoidal categories!
16:05:38 <geekosaur> (mind, you wrould write the same thing in C as well, but you have to write it very differently. most people don't)
16:05:42 <Arahael> geekosaur: Thanks for the explaination - I had better get started. Trying to learn one new thing about haskell each day.
16:05:48 <benzrf> juanpablo_: let's talk about monoids in categories!!!
16:05:54 <benzrf> juanpablo_: this is where it gets a bit tricky
16:06:02 <geekosaur> s/wrould/could/   not sure where that came from
16:06:23 <juanpablo_> benzrf: ok so monoids in categories is different from monoidal categories?
16:06:25 <Arahael> geekosaur: Well, C _does_ have optimisation of strings, string interning, and the like, but those are mostly space improvements.
16:06:27 <benzrf> juanpablo_: yeah
16:06:36 <benzrf> juanpablo_: a monoid in a category must be in a monoidal category
16:06:38 <benzrf> but it's not the same thing
16:06:45 <geekosaur> in Haskell you can write things the obvious way and the compiler will fuse what it can, rather than requiring you to write your program inside out, as it were
16:06:52 <benzrf> `monoid object' is probably better than `monoid in a category'
16:06:56 <Arahael> Totally awesome. :)
16:07:02 <benzrf> juanpablo_: let's start with the definition of a regular old [haskell-style] monoid
16:07:10 <juanpablo_> benzrf: monoid object makes more sense
16:07:26 <Aruro> why do i get parse error on input `='
16:07:35 <geekosaur> @paste
16:07:35 <lambdabot> Haskell pastebin: http://lpaste.net/
16:07:38 <benzrf> juanpablo_: well
16:07:42 <benzrf> let's make a tweak or twopoint818
16:07:43 <benzrf> *two
16:07:56 <benzrf> juanpablo_: traditionally monoids work on pairs, so mappend :: (m, m) -> m
16:08:00 <benzrf> juanpablo_: haskell just likes currying
16:08:14 <benzrf> juanpablo_: how is a monoid defined, then?
16:08:21 <Aruro> guys is parse error on input `=' related to formatting??
16:08:33 <juanpablo_> benzrf: with mappend and mempty
16:08:39 <benzrf> juanpablo_: types?
16:09:16 <juanpablo_> benzrf: mappend :: a -> a -> a
16:09:33 <juanpablo_> benzrf: mempty :: a
16:09:38 <dibblego> Aruro: it could be, do you have the code?
16:09:48 <Aruro> yes let me paste eit
16:09:49 <benzrf> juanpablo_: we'll use tuples for mappend
16:09:49 <Aruro> it
16:09:51 <Aruro> its small
16:09:52 <benzrf> 07:08 < benzrf> juanpablo_: traditionally monoids work on pairs, so mappend :: (m, m) -> m
16:09:58 <benzrf> juanpablo_: you'll see why in a minute
16:09:59 <geekosaur> use the pastebin please
16:10:02 <juanpablo_> benzrf: ok, cool
16:10:03 <geekosaur> that's why I did @paste
16:10:07 <benzrf> juanpablo_: now, what are the monoid laws?
16:10:11 <Aruro> ty :D lol
16:10:13 <Aruro> i will now
16:10:16 <Aruro> collect :: [a] -> [a]
16:10:16 <Aruro> collect [] = []
16:10:16 <Aruro> collect a = let b = filter (/='+') a
16:10:16 <Aruro>    c = rdup b
16:10:16 <Aruro>    d = map (\x -> length (filter (==x) b) ) c
16:10:16 <Aruro>    in [(show d!!x) ++'*'++c!!x | x <-[0..(length c)-1]]
16:10:27 <Aruro> rdup is another function
16:10:28 <geekosaur> channel's busy enough that even short code could be hard to follow, plus some of us use proportional fonts for IRC
16:10:32 <juanpablo_> benzrf: they must be associative and have an empty element
16:10:40 <Arahael> Aruro: pastebin is a website.
16:10:41 <geekosaur> which messes up signifcant indentation but good >.>
16:10:46 <geekosaur> @paste
16:10:47 <lambdabot> Haskell pastebin: http://lpaste.net/
16:10:49 <Aruro> sry if messed up
16:10:50 <geekosaur> again
16:10:58 <benzrf> juanpablo_: express them!
16:11:02 <benzrf> juanpablo_: what do those laws mean?
16:11:04 <geekosaur> and your indentation is probably wrong, from the look of it
16:11:05 <benzrf> how do they look?
16:11:11 <juanpablo_> benzrf: mappend mempty x = x
16:11:12 <Aruro> ok ok sorry will paste to bin now
16:11:17 <juanpablo_> benzrf: mappend x mempty = x
16:11:19 <benzrf> juanpablo_: we're using tuples, rewrite >:{
16:11:40 <juanpablo_> benzrf: mappend  (mempty, x) = x
16:11:41 <geekosaur> indentation is significant in Haskell, your `c = rdup b` looks less indented than the `let` so it's not part of it
16:11:41 <stephenmac7> Why doesn't Data.Text have docs on Hackage?
16:11:49 <dibblego> Aruro: the (c) in in (c = rdup b) needs to be under the (b) in (b = filter (/='+') a)  same for following lines up to (in)
16:11:52 <Arahael> Aruro: paste only short (one-line, <80 char) code in channel... everything else to the website.
16:12:43 <benzrf> juanpablo_: ok cool
16:12:51 <benzrf> juanpablo_: how about associativity
16:13:20 <Aruro> http://lpaste.net/112032
16:13:31 <Aruro> ty for teaching me how to post :) sry for mess above
16:13:49 <juanpablo_> benzrf: mappend (x, mappend (y, z))  = mappend (mappend(x,y), z)
16:13:54 <juanpablo_> benzrf: something like this, right?
16:13:59 <benzrf> juanpablo_: yeah looks rightr
16:14:08 <benzrf> juanpablo_: ok, that's the definition of a regular monoid
16:14:13 <Denommus> hi
16:14:24 <benzrf> juanpablo_: but we have a problem
16:14:32 <benzrf> juanpablo_: your definitions are talking about values!
16:14:46 <juanpablo_> benzrf: so we make them pointfree?
16:14:49 <benzrf> juanpablo_: remember, category theory NEVER deals in values (at least, not in this case :p)
16:14:52 <Aruro> so i have to allign everything to the first expression after let?
16:15:01 <benzrf> juanpablo_: you can talk about morphisms and objects and applying functors to them
16:15:08 <benzrf> juanpablo_: but you certainly cannot apply!
16:15:33 <Arahael> Aruro: always first time, dont worry about it. (but do note that most busy channels have this information in the /topic, always a good idea to read it)
16:15:36 <benzrf> juanpablo_: a monoid needs an identity element and we can't talk about elements, thoughtpolice
16:15:40 <benzrf> *though
16:15:44 <benzrf> juanpablo_: so let me make another tweak:
16:15:50 <benzrf> mempty :: () -> m
16:16:01 <benzrf> (you can implement this as mempty = const oldMempty)
16:16:16 <benzrf> now you can compose it without needing to talk about a specific value
16:16:26 <benzrf> just morphisms!
16:16:37 <juanpablo_> benzrf: how would that work out? you mean pointless style?
16:17:02 <Aruro> can formatting errors be cause by using of tabs?
16:17:03 <benzrf> yeah
16:17:04 <benzrf> juanpablo_: remember
16:17:10 <benzrf> in category theory THERE ARE NO VALUES
16:17:14 <benzrf> you deal in morphisms
16:17:18 <Aruro> i see that from notepad++ it does not copy correctly to pastebin
16:17:19 <benzrf> and their equivalence when composed
16:17:24 <juanpablo_> benzrf: so how do we pointless when using tuples?
16:17:30 <benzrf> juanpablo_: good question!
16:17:36 <benzrf> juanpablo_: let me show you
16:17:53 <benzrf> juanpablo_: (,) is a bifunctor, right?
16:18:00 <juanpablo_> benzrf: right
16:18:25 <benzrf> juanpablo_: so we can lift functions over tuples by applying the functor to them
16:18:29 <benzrf> here's a convenience function for you:
16:18:43 <benzrf> @let bifirst f = bimap f id
16:18:45 <lambdabot>  Defined.
16:18:47 <benzrf> and another:
16:18:54 <benzrf> @let bisecond f = bimap id f
16:18:56 <lambdabot>  Defined.
16:19:02 <benzrf> > bifirst (+1) (3, 5)
16:19:03 <moldy> i am looking at learnyouahaskell. i am wondering why some code only works in source files, but not when entered into ghci. why is that?
16:19:05 <lambdabot>  (4,5)
16:19:21 <Aruro> ok i solved it
16:19:27 <HeladoDeBrownie> moldy, ghci is weird, mostly. What code in particular?
16:19:30 <Aruro> ghci does not like tabs
16:19:31 <benzrf> juanpablo_: you're allowed to apply bifirst in your definition because at the category level it's a functor and not a regular morphism
16:19:37 <juanpablo_> > bisecond (+1) (4,6)
16:19:38 <benzrf> juanpablo_: see?
16:19:41 <lambdabot>  (4,7)
16:19:54 <benzrf> juanpablo_: mathematically, it looks like
16:19:58 <geekosaur> ghci isn't an interactive haskell compiler, it's more of an interactive desk calculator
16:20:00 <karshan_> moldy: in general ghci has different syntax than haskell source files. multiline functions are an example
16:20:12 <benzrf> bifirst(f) = f ⊗ id
16:20:14 <benzrf> where ⊗ is (,)
16:20:53 <moldy> HeladoDeBrownie: function definitions
16:21:28 <Dashkal> moldy: let f x = id x
16:21:28 <HeladoDeBrownie> That's not "particular" code :) But at that general a description, it's mostly what they said
16:21:41 <benzrf> juanpablo_: it's the same reason you can write:
16:21:44 <Dashkal> ghci works very much like do notation
16:21:46 <benzrf> fmap f . fmap g = fmap (f . g)
16:22:04 <benzrf> there's no morphism application there, only functor application
16:22:14 <benzrf> or at least, there's a mathematical translation that works that way
16:22:37 <juanpablo_> benzrf: yes, because there's no values there?
16:22:41 <benzrf> juanpablo_: right!
16:22:49 <karshan_> moldy: this is how to do multiline function definitions in ghci: let { f 0 = 1; f n = n * f (n - 1) }
16:23:04 <benzrf> juanpablo_: tip: you may need another tool or two
16:23:09 <benzrf> :t associate
16:23:10 <lambdabot> ((t, t1), t2) -> (t, (t1, t2))
16:23:17 <benzrf> :t leftID
16:23:19 <lambdabot> ((), t) -> t
16:23:19 <benzrf> :t rightID
16:23:20 <lambdabot> (t, ()) -> t
16:23:23 <karshan_> moldy: also note that all definitions in ghci must be prefixed with a let
16:23:47 <benzrf> juanpablo_: with those 3, plus bimap/bifirst/bisecond, plus custom mempty, can you describe Monoid purely compositionally?
16:23:48 <Aruro> guys how to i make string out of character? '1'->"1"
16:23:55 <Aruro> apparently it is not same thing
16:24:09 <HeladoDeBrownie> Aruro, \x -> [x]
16:24:09 <benzrf> juanpablo_: (remember i declared that mempty is now :: () -> m and is implemented as const oldMempty)
16:24:10 <RedNifre> Why does cabal tell me that I need to run "cabal configure" before I can use "cabal build"? Why does it not simply run "cabal configure" by itself if it knows what to do already?
16:24:17 <Aruro> ok
16:24:17 <HeladoDeBrownie> Aruro, in other words, throw it in a list by itself
16:24:18 <Aruro> ty
16:24:33 <HeladoDeBrownie> Aruro, (you don't literally need to write \x -> [x] if you can just write the list directly)
16:24:41 <Aruro> can i do it like this [c!!1] ? where c is string?
16:25:08 <HeladoDeBrownie> You could, though I find it curious that you would want that
16:25:20 <Aruro> i need to add string to character
16:25:26 <Aruro> string i get from show
16:25:29 <juanpablo_> benzrf: I'm trying to figure out association
16:25:34 <Aruro> even though its usually just 1 digit
16:25:44 <HeladoDeBrownie> Aruro, more specific?
16:25:53 <benzrf> juanpablo_: write it non-compositionally
16:25:54 <Aruro> wait
16:25:56 <benzrf> juanpablo_: then try refactoring :-)
16:26:14 <HeladoDeBrownie> Aruro, also note that c !! 1 fails on strings shorter than length two. And by "fails", I mean "crashes your program".
16:26:33 <Aruro> http://lpaste.net/112032
16:26:37 <Aruro> last line
16:27:11 <Aruro> it gives me complain that does not want to add char to [char]
16:27:18 <HeladoDeBrownie> Aruro, that's a little opaque to me - What should the input and output of collect be?
16:27:47 <HeladoDeBrownie> Aruro, one thing to watch out for, though, is operator precedence. Try using :i in ghci to find out the precedence of (++) and (!!), for example.
16:28:01 <juanpablo_> benzrf: I can use mappend, right?
16:28:04 <Aruro> collect "x+x+y+z+y" should return string "2*x+2*y+z"
16:28:29 <benzrf> juanpablo_: of course
16:28:34 <benzrf> juanpablo_: that's a morphism :P
16:29:26 <HeladoDeBrownie> Aruro, sounds like a job for a parser to me, although I don't understand how collect would be polymorphic given that example.
16:29:38 <Arahael> How does pure code raise an exception? (And still be pure)
16:29:51 <benzrf> Arahael: Either
16:29:53 <HeladoDeBrownie> Arahael, Maybe or Either is common
16:30:10 <Aruro> it is not polymorphic
16:30:11 <Arahael> Either or Maybe isn't being used: I'm talking about Data.Text.Encoding.
16:30:15 <Aruro> its just example
16:30:18 <Aruro> for myself
16:30:31 <benzrf> Arahael: oh, do you mean like this:
16:30:34 <benzrf> > 3 + error "shit"
16:30:37 <lambdabot>  *Exception: shit
16:30:52 <Arahael> benzrf: Yes.
16:30:54 <benzrf> Arahael: the answer is that it is not pure and that is why the entire program blows up
16:31:02 <benzrf> it's like going into an infinite loop; there is not an answer
16:31:04 <juanpablo_> benzrf: mappend (x, mappend (y, z))  = mappend (mappend(x,y), z) should be bifirst mappend == bisecond mappend? but that just deals with two elements, not three
16:31:08 <benzrf> you cannot catch an exception like that except from IO
16:31:13 <Arahael> benzrf: That suggests that pure code might become impure.
16:31:23 <HeladoDeBrownie> Arahael, did you read the documentation for that? It's quite explicit about how to "catch" the exceptions generated
16:31:30 <benzrf> juanpablo_: keep refactoring :-O
16:31:32 <Arahael> HeladoDeBrownie: That's not the question.
16:31:33 <benzrf> you're getting there!~
16:31:47 <benzrf> Arahael: it's not quite impure
16:31:54 <benzrf> Arahael: there are no actual effects. it's just bottom
16:32:01 <benzrf> Arahael: you might as well ask about infinite recursion
16:32:05 <benzrf> it's denotationally equivalent
16:32:10 <Arahael> benzrf: I'm wondering why it's such a good idea for the likes of encodeUtf8 to throw errors like this.
16:32:32 <HeladoDeBrownie> Arahael, it sounds like your question ought to have been: What does Data.Text.Encoding mean when it says it raises an exception?
16:32:35 <dreams> ugh, cost centres are complicated.
16:32:40 <HeladoDeBrownie> Is that right?
16:32:44 <benzrf> Arahael: it really isn't
16:32:49 <Arahael> HeladoDeBrownie: No, because the documentation explains that.
16:33:05 <Aruro> ok you were right about polymorphism
16:33:11 <Arahael> benzrf: How can I avoid functions or designs like that?
16:33:12 <juanpablo_> benzrf: mappend (x, mappend (y, z))  = mappend (mappend(x,y), z) should be bimap (bifirst mappend) == bimap (bisecond mappend). I'm trying to "get" into the inner tuple
16:33:27 <benzrf> juanpablo_: you can use (.), you know
16:33:28 <Aruro> i had to put explicitly char in type of the function
16:33:28 <Arahael> benzrf: Or do I just have to be careful, and manually ensure that the functions I call don't, or shouldn't, raise an exception?
16:33:34 <benzrf> juanpablo_: composition is the category operation, remember?
16:33:42 <Arahael> benzrf: (ie, the compiler won't help me?)
16:33:42 <juanpablo_> benzrf: yes
16:33:42 <benzrf> juanpablo_: and remember:
16:33:44 <benzrf> :t bimap
16:33:46 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
16:33:55 <benzrf> bimap takes 2 morphisms
16:34:42 <Aruro> thank you Helado and all
16:34:47 <HeladoDeBrownie> Arahael, in general you want to avoid using things that have a possibility of using undefined or error, which will crash the program (or thread).
16:34:51 <Aruro> solved problem was in map
16:35:06 <Aruro> or even list comprehension
16:35:22 <Arahael> HeladoDeBrownie: So I shouldn't use encodeUtf8, then.
16:35:38 <HeladoDeBrownie> Arahael, at a glance, I would advise against it.
16:36:00 <Aruro> sorry, problem was that i did not define type of function correctly
16:36:01 <HeladoDeBrownie> Arahael, sorry, misread: encode is safe, I believe.
16:36:07 <Aruro> i had [a]->[a]
16:36:21 <Aruro> when in reality it was [Char]->[[Char]]
16:36:31 <Aruro> when i wrote that everything went smooth
16:36:31 <Arahael> HeladoDeBrownie: Ah, but not decodeUtf8.
16:36:47 <HeladoDeBrownie> Arahael, right. It's decodeUtf8 I would advise avoiding, in favor of another version mentioned.
16:37:04 <Arahael> HeladoDeBrownie: So I should rewrite those lines in my program using it, to something more like decodeUtf8With, or decodeUtf8'?
16:37:14 <HeladoDeBrownie> Arahael, yeah, that's what I'd suggest.
16:37:30 <Arahael> HeladoDeBrownie: Now, how woudl I make the compiler warn me of this?
16:37:51 <Arahael> HeladoDeBrownie: Ala "checked exceptions" or the like.
16:38:01 <benzrf> Arahael: Either
16:38:12 <Arahael> benzrf: I don't see "Either" in the signature for decodeUtf8.
16:38:18 <benzrf> Arahael: regular "exceptions" are impossible to encode in the type system, just as infinite recursion is
16:38:21 <HeladoDeBrownie> Arahael, I don't know. It's possible there's a flag that tells you when you use undefined or error but I don't know of it.
16:38:27 <benzrf> Arahael: at least in haskel
16:38:46 <Arahael> benzrf: So it's a really hateful design for Data.Text.Encoding?
16:38:51 <benzrf> yep!
16:39:15 <juanpablo_> benzrf: mappend (x, mappend (y, z))  = mappend (mappend(x,y), z) should be `mappened . bifirst mappend == mappend . bisecond mappend`
16:39:29 <Arahael> benzrf: Is there a higher level, cleaner wrapper for it, then?
16:39:54 <Arahael> HeladoDeBrownie: Thanks, this has been insightful. :)
16:39:56 <glguy> Arahael: Are you looking at the documentation? https://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Lazy-Encoding.html
16:39:56 <HeladoDeBrownie> Arahael, unfortunately, these so-called "partial functions" are scattered throughout the Prelude as well, e.g., head, tail, last, read
16:40:04 <benzrf> juanpablo_: very, very close!
16:40:11 <glguy> Arahael: this topic is covered in the documentation for that function
16:40:15 <benzrf> juanpablo_: you're missing one small detail...
16:40:22 <benzrf> @let mappend' = uncurry mappend
16:40:24 <lambdabot>  Defined.
16:40:28 <benzrf> :t mappend . bifirst mappend
16:40:29 <lambdabot> (Bifunctor p, Monoid (p (a -> a) d), Monoid a) => p a d -> p (a -> a) d -> p (a -> a) d
16:40:37 <benzrf> oh wait
16:40:40 <benzrf> eek
16:40:41 <Arahael> HeladoDeBrownie: Ugh.  What sort of exception could 'head' result in?
16:40:44 <Arahael> glguy: Yeah?
16:40:47 <HeladoDeBrownie> > head []
16:40:49 <lambdabot>  *Exception: Prelude.head: empty list
16:41:07 <benzrf> :t mappend' . bisecond mappend'
16:41:08 <lambdabot> Monoid c => (c, (c, c)) -> c
16:41:15 <benzrf> :t mappend' . bifirst mappend'
16:41:16 <lambdabot> Monoid c => ((c, c), c) -> c
16:41:16 <HeladoDeBrownie> Arahael, the solutions to avoiding them vary; in the example of head, you generally want to use an explicit pattern match or perhaps a fold of some sort.
16:41:18 <Aruro> sum ["1","2"] does not work, what will?
16:41:24 <benzrf> juanpablo_: not the same type!
16:41:53 <Arahael> HeladoDeBrownie: Oh, yeah.  I've tended to only use the explicit pattern matches so far.  I guess the takewaway message is to learn how to put up with this, such that we can still use the type system to it's best?
16:42:41 <Arahael> HeladoDeBrownie: I guess at least such exceptions are unlikely to be sporadic/environmental, except for running out of memory or disk space.
16:43:32 <HeladoDeBrownie> Arahael, Haskell's type system is weakened somewhat by the presence of bottom, the value representing non-termination or no information; consequently, we usually ignore or avoid it as necessary.
16:43:58 <Arahael> HeladoDeBrownie: I'm guessing that it's far too late to investigate fixing that?
16:44:01 <benzrf> juanpablo_: you are very very very close
16:44:06 <HeladoDeBrownie> Arahael, the best defense, I think, is to know which things use it and to avoid those in the cases where they do. However, head may be safe to use, e.g., on the output of a function that always outputs a non-empty list.
16:44:13 <juanpablo_> benzrf: mappend (x, mappend (y, z))  = mappend (mappend(x,y), z) should be `bimap (mappened . bifirst mappend) id == bimap id (mappend . bisecond mappend)? ... I don't know`
16:44:33 <benzrf> :t associate
16:44:34 <Arahael> HeladoDeBrownie: Is there a "lint" that checks for these cases?
16:44:34 <lambdabot> ((t, t1), t2) -> (t, (t1, t2))
16:44:38 <HeladoDeBrownie> Arahael, it's a fundamental weakness of most programming languages; if you want to learn about how it's being addressed, look into total functional programming.
16:44:39 <Aruro> > foldr (++) ["1","2"]
16:44:41 <lambdabot>  <[[[Char]]] -> [[Char]]>
16:44:46 <benzrf> juanpablo_:
16:44:57 <benzrf> :t mappend' . bisecond mappend'
16:44:58 <lambdabot> Monoid c => (c, (c, c)) -> c
16:45:00 <benzrf> :t mappend' . bifirst mappend'
16:45:01 <HeladoDeBrownie> Arahael, Haskell is only special in that its semantics include it as a value.
16:45:01 <lambdabot> Monoid c => ((c, c), c) -> c
16:45:12 <Arahael> HeladoDeBrownie: That was part of my attraction to Haskell!
16:45:29 <Arahael> HeladoDeBrownie: Could you recommend a website for me to read about this?
16:45:30 <HeladoDeBrownie> Arahael, in practice you can often program *as if* Haskell were total, you just have to avoid certain corner cases like these.
16:45:45 <HeladoDeBrownie> Arahael, not in particular, but Idris is a very Haskell-like total language, and there's also Agda.
16:45:48 <Arahael> HeladoDeBrownie: Yeah - I want to have some tips that will help me avoid it, hopefully in the form of a lint.
16:46:34 <benzrf> juanpablo_: do you have it?
16:46:36 <HeladoDeBrownie> Arahael, beware, there are tradeoffs. You lose unrestricted recursion, for example.
16:46:40 <juanpablo_> :t mappend' . mappend' bifirst
16:46:41 <lambdabot>     Couldn't match expected type ‘(a -> (c, c), a -> (c, c))’
16:46:41 <lambdabot>                 with actual type ‘(a0 -> b0) -> p0 a0 d0 -> p0 b0 d0’
16:46:41 <lambdabot>     Probable cause: ‘bifirst’ is applied to too few arguments
16:47:03 <benzrf> juanpablo_: you can't use mappend' on bifirst o-o
16:47:04 <Arahael> HeladoDeBrownie: I'm definitely interested in those languages, although in practice I think I'll stick to learning Haskell.
16:47:09 <Aruro> > fold (+) [1,2]
16:47:11 <lambdabot>  No instance for (GHC.Show.Show t0)
16:47:11 <lambdabot>    arising from a use of ‘M76458232902195698751343.show_M76458232902195698751...
16:47:11 <lambdabot>  The type variable ‘t0’ is ambiguous
16:47:11 <lambdabot>  Note: there are several potential instances:
16:47:11 <lambdabot>    instance [safe] GHC.Show.Show
16:47:12 <benzrf> juanpablo_: for one thing, you're not allowed to apply mappend'
16:47:15 <benzrf> it's a morphism, not a functor
16:47:24 <juanpablo_> benzrf: yes, sorry :)
16:47:26 <Aruro> why fold does not work?
16:47:31 <benzrf> for another it's the wrong type :P
16:47:38 <monochrom> Aruro, you need more parameters, and probably a better order of the parameters.
16:47:41 * hackagebot hxt-css 0.1.0.1 - CSS selectors for HXT  http://hackage.haskell.org/package/hxt-css-0.1.0.1 (MariosTitas)
16:47:42 <HeladoDeBrownie> Arahael, that's about my thinking, besides that Haskell has a quite developed community and is "close enough" in many respects for my satisfaction.
16:48:10 <Aruro> this is exact copy from haskell wiki
16:48:24 <Aruro> > fold (+) [1,2,3,4,5]
16:48:26 <lambdabot>  No instance for (GHC.Show.Show t0)
16:48:26 <lambdabot>    arising from a use of ‘M18578141690564070801368.show_M18578141690564070801...
16:48:26 <lambdabot>  The type variable ‘t0’ is ambiguous
16:48:26 <lambdabot>  Note: there are several potential instances:
16:48:26 <lambdabot>    instance [safe] GHC.Show.Show
16:48:44 <Arahael> HeladoDeBrownie: Heck, even Node.js is "close enough" in many respects, so I'd agree with that.
16:48:44 <glguy> > foldl1 (+) [1,2]
16:48:45 <lambdabot>  3
16:48:51 <Aruro> http://www.haskell.org/haskellwiki/Fold
16:49:04 <codygman> Lens seems to be failing to install: http://lpaste.net/112036
16:49:09 <benzrf> juanpablo_: want me to just show you :p
16:49:16 <Aruro> what is  foldl1?
16:49:17 <juanpablo_> benzrf: at this point, yes haha
16:49:22 <Aruro> at least what is 1
16:49:48 <monochrom> in short haskell wiki quality varies.
16:49:55 <HeladoDeBrownie> Arahael, my learning Haskell significantly hampered my ability to learn JavaScript. That's another tradeoff, and not one you can so easily go back on if you're the sort that that happens to. :P
16:50:01 <HeladoDeBrownie> Arahael, s/learn/enjoy/
16:50:02 <Aruro> well fold is super basic stuff
16:50:04 <glguy> codygman: You need to use a newer version of lens with GHC 7.8.3
16:50:10 <benzrf> juanpablo_: mappend . bifirst mappend = mappend . bisecond mappend . associatve
16:50:12 <benzrf> er
16:50:15 <benzrf> juanpablo_: mappend . bifirst mappend = mappend . bisecond mappend . associate
16:50:19 <benzrf> :t mappend . bifirst mappend
16:50:20 <lambdabot> (Bifunctor p, Monoid (p (a -> a) d), Monoid a) => p a d -> p (a -> a) d -> p (a -> a) d
16:50:22 <Aruro> > foldr1 (+) [1,2,3]
16:50:23 <benzrf> aa
16:50:23 <lambdabot>  6
16:50:31 <juanpablo_> :t associate
16:50:31 <benzrf> :t mappend' . bifirst mappend' -- juanpablo_
16:50:32 <lambdabot> ((t, t1), t2) -> (t, (t1, t2))
16:50:32 <lambdabot> Monoid c => ((c, c), c) -> c
16:50:40 <benzrf> :t mappend' . bisecond mappend' . associate -- juanpablo_
16:50:41 <lambdabot> Monoid c => ((c, c), c) -> c
16:50:42 <monochrom> in long, I don't even know what its "fold" is supposed to be. is it pseudocode? is it actually defined somewhere on the same page? (but I can't find it.) at any rate, there is no "fold" in the Prelude. or Data.List.
16:50:46 <codygman> thanks glguy
16:50:57 <benzrf> > mappend' . bisecond mappend' . associate $ (("foo", "bar"), "baz")
16:50:59 <lambdabot>  "foobarbaz"
16:51:04 <Aruro> > foldr1 (++) ["1","2","3"]
16:51:05 <benzrf> > mappend' . bifirst mappend' $ (("foo", "bar"), "baz")
16:51:06 <lambdabot>  "123"
16:51:06 <lambdabot>  can't find file: L.hs
16:51:09 <benzrf> > mappend' . bifirst mappend' $ (("foo", "bar"), "baz")
16:51:10 <lambdabot>  "foobarbaz"
16:51:25 <Aruro> i would put fold in haskell :D
16:51:32 <benzrf> juanpablo_: here's a diagram! https://upload.wikimedia.org/wikipedia/commons/b/b1/Monoid_mult.png
16:51:33 <juanpablo_> lambdabot: So I didn't know about associate :/
16:51:40 <Aruro> good nice named function
16:51:42 <benzrf> juanpablo_: i showed you before ._.
16:51:51 <Arahael> HeladoDeBrownie: Heh, well I already know some Javascript, but I am very used to dynamic languages so I doubt that's goign to be an issue for me.
16:51:59 <Aruro> ty glguy!
16:52:11 <Arahael> HeladoDeBrownie: But I have noticed that many other programmers used to the more strict/typesafe languages tend to have a hard time with the dynamic languages.
16:52:12 <Aruro> for solution
16:52:16 <juanpablo_> benzrf: I didn't think it was relevant in this example. Damn myself. Sorry :(
16:52:25 <HeladoDeBrownie> Arahael, I hope my typo correction was clear: Learning Haskell made it hard for me to *enjoy* JavaScript. I already knew JS before Haskell, I just haven't used it much since.
16:52:33 <Aruro> > foldr2 (++) ["1","2","3"]
16:52:34 <lambdabot>  Not in scope: ‘foldr2’
16:52:34 <lambdabot>  Perhaps you meant one of these:
16:52:34 <lambdabot>    ‘foldr’ (imported from Data.List),
16:52:34 <lambdabot>    ‘BSC.foldr’ (imported from Data.ByteString.Char8),
16:52:34 <lambdabot>    ‘BSLC.foldr’ (imported from Data.ByteString.Lazy.Char8)
16:52:40 <benzrf> juanpablo_: it's ok!
16:52:46 <Aruro> ok 1 is just name :D
16:52:49 <Arahael> HeladoDeBrownie: Heh, I already find it hard to enjoy Javascript. :)
16:53:13 <benzrf> juanpablo_: so you see how associativity can be expressed purely in terms of (,) as a bifunctor, plus associate for it?
16:53:21 <benzrf> remember,
16:53:22 <benzrf> :t bifirst
16:53:23 <HeladoDeBrownie> Arahael, an interesting point about dynamically typed languages which you may or may not have been introduced to: They're essentially degenerate statically typed languages, having only a single type. :)
16:53:23 <lambdabot> Bifunctor p => (a -> b) -> p a d -> p b d
16:53:23 <juanpablo_> benzrf: yes!
16:53:27 <benzrf> juanpablo_: excellent!
16:53:30 <Arahael> HeladoDeBrownie: I still use it though for my personal project - it's hard to justify the overhead of another language for short, 3-line event handlers.
16:53:30 <benzrf> let's look at identity!
16:53:43 <benzrf> juanpablo_: mempty :: () -> m, so that it's a morphism instead of a value
16:53:49 <benzrf> juanpablo_: for this you may need:
16:53:50 <benzrf> :t leftID
16:53:51 <lambdabot> ((), t) -> t
16:53:53 <benzrf> :t rightID
16:53:53 <lambdabot> (t, ()) -> t
16:53:54 <Arahael> HeladoDeBrownie: I disagree; rather, Everything is Maybe T.
16:54:02 <HeladoDeBrownie> Arahael, how so?
16:54:21 <Arahael> HeladoDeBrownie: It either looks close enough to teh type you want...  Or it has a well defined failure.
16:55:03 <Arahael> HeladoDeBrownie: Mind you, I do distinguish between strong, and weak, typing in dynamic languages.
16:55:23 <HeladoDeBrownie> Arahael, I think it would become obvious what I'm talking about if you tried implementing a dynamically typed language in Haskell – and yes, you may have non-termination or lack of result, but that's already a part of that single type.
16:56:06 <benzrf> juanpablo_: remember, leftID also has an inverse t -> ((), t) (and same for rightID). it is just an isomorphism between `a' and ((), a), which are the same thing
16:56:08 <Arahael> HeladoDeBrownie: No, I'm not sure.  See, there's actually three major type systems that I know of.
16:56:15 <benzrf> juanpablo_: that's not useful for this, but it's important to remember
16:56:52 <Arahael> HeladoDeBrownie: Haskell puts the type as a type constraint - you can't use the variable _except_ via a type constraint strongly enforced by the compiler.
16:56:53 <juanpablo_> benzrf: so I need to express mappend (x, mempty) == mappend (mempty, x) pointfree style
16:57:05 <HeladoDeBrownie> Arahael, "strongly typed" and "weakly typed" in common parlance don't pertain to types, per se, at least not how the term is used in statically typed language literature.
16:57:18 <benzrf> juanpablo_: not quite
16:57:27 <benzrf> juanpablo_: you want x = mappend (mempty, x)
16:57:31 <Arahael> HeladoDeBrownie: Languages such as Javascript or Python have typed variables, but the variable itself contains the type, so you are correct actually, in that the "name" of the type has only static type.
16:57:34 <HeladoDeBrownie> Arahael, or is it that you meant something else? Perhaps it would be useful to define them.
16:57:36 <juanpablo_> benzrf: yes, sorry. mistyped that :3
16:57:41 <Aruro> why monads are needed if we have just imperative do construction? does it have something to do with types?
16:57:42 <benzrf> juanpablo_: this one is slightly tricky.
16:57:49 <benzrf> juanpablo_: just remember:
16:57:52 <benzrf> :t leftID
16:57:52 <HeladoDeBrownie> Arahael, I disagree, Python variables don't carry types; rather, values are tagged.
16:57:53 <lambdabot> ((), t) -> t
16:57:54 <benzrf> will be needed
16:57:58 <Arahael> HeladoDeBrownie: And I guess languages such as Perl and C don't put the type with either the variable or the name.
16:58:08 <HeladoDeBrownie> Arahael, JS is the same way for that matter
16:58:14 <benzrf> Aruro: do doesn't do anything special
16:58:18 <benzrf> Aruro: it is just syntactic sugar
16:58:19 <simpson> HeladoDeBrownie: If Python objects had a uniform calling convention, I would be tempted to consider the argument, but it doesn't really follow.
16:58:29 <Arahael> HeladoDeBrownie: You can, at least, with python ask the object what type it has.
16:58:36 <HeladoDeBrownie> simpson, what do you mean?
16:58:42 <glguy> > 10 + do 20
16:58:42 <Aruro> yes the point is that i do not see what monads do
16:58:43 <lambdabot>  30
16:58:46 <HeladoDeBrownie> Arahael, doesn't that indicate that it's the value and not that variable that has the type tag?
16:58:50 <Aruro> just chains of events
16:58:55 <Aruro> do no see their point
16:58:59 <Arahael> HeladoDeBrownie: Yes, it does, doesn't it? :)
16:59:16 <Aruro> i have a feeling it has to do something with type system
16:59:22 <Aruro> but did not have time to dig it
16:59:30 <HeladoDeBrownie> Arahael, it's possible I don't know enough about Python; however, JavaScript, I can tell you for quite certain, has tagged values, not tagged variables.
16:59:34 <monochrom> Aruro, the do-notation is a syntax for using monads.
16:59:47 <Arahael> HeladoDeBrownie: Javascript has only a very small number of primitive types. :(
16:59:49 <HeladoDeBrownie> Arahael, perhaps we should take this to #haskell-blah.
16:59:51 <Aruro> yes but what is this using?
16:59:53 <simpson> HeladoDeBrownie: It is possible to construct objects, in Python, which do not behave like other objects in a fundamental way. This ruins the argument that an object-based language, due to a uniform and opaque calling convention, has no way to distinguish values of being as distinct types. (I'm assuming you're talking about that one polemic article...)
16:59:54 <Aruro> just chaining?
17:00:11 <monochrom> it uses the >>= operator of the Monad type class
17:00:22 <benzrf> monochrom: also >>
17:00:24 <HeladoDeBrownie> simpson, care to come along as well?
17:00:31 <mcbears> "do x <- thing; return (x + y)" is just sugar for "thing >>= \x -> return (x + y)"
17:00:35 <Aruro> yes so its main point is to provide something to class system?
17:00:38 <simpson> HeladoDeBrownie: Nope; not sufficiently interesting. Take it easy.
17:00:44 <benzrf> mcbears: more like fmap!!!
17:00:54 <Aruro> yes mcbears that i know
17:01:07 <Aruro> but why not just to call >>= an operator
17:01:14 <Aruro> and avoid monads and so on
17:01:20 <mcbears> because >>= works for any monad :o
17:01:22 <Aruro> who cares what it is
17:01:26 <benzrf> Aruro: because you'd have monads anyway
17:01:27 <Aruro> hm
17:01:29 <benzrf> why not define them?
17:01:30 <monochrom> I don't understand the latest question. I only understand the former question "why have monad when there is do-notation", and it reflects a misunderstanding.
17:01:50 <Aruro> i have types i have functions
17:01:54 <Aruro> why do i need monads?
17:02:03 <Aruro> im fine with unsafe functions who cares
17:02:08 <mcbears> ohhhhh
17:02:10 <Aruro> i do not see conceptual need
17:02:14 <mcbears> then you probably shouldn't use haskell :)
17:02:19 <Ralith> people who want their software to work care, usually.
17:02:20 <Aruro> nah
17:02:25 <Aruro> i dont think it is the right answer
17:02:35 <benzrf> Aruro: you seem to have a case of blub
17:02:49 <benzrf> Aruro: monads definitely aren't obviously useful
17:02:53 <Aruro> so here is my question why monad help vs my naive thinking
17:02:57 <benzrf> but that doesn't mean they aren't actually useful
17:03:04 <benzrf> Aruro: genericism
17:03:13 <benzrf> Aruro: we can write functions that work for any type with a Monad instance
17:03:14 <Aruro> ok close
17:03:15 <benzrf> like sequence
17:03:29 <Aruro> so it has something to do with type system versatility?
17:03:35 <benzrf> i'm not sure what you mean
17:03:40 <mcbears> it happens that a lot of common patterns fit the monad blueprints, so we abstract over them (as is common in software)
17:03:42 <juanpablo_> :t bisecond
17:03:42 <lambdabot> Bifunctor p => (c -> d) -> p b c -> p b d
17:03:44 <benzrf> oh, it also lets us cut down on names
17:03:46 <Aruro> i mean more advanced type system
17:04:03 <Aruro> ok than monad is just a type
17:04:07 <Aruro> or not?
17:04:09 <benzrf> no, it's a typeclass
17:04:17 <Aruro> ok typeclass
17:04:35 <Aruro> if i get rid from them i still get haskell right?
17:05:02 <mcbears> it happens that Haskell as a language deals with IO using a monad, but in other cases you aren't tied to them
17:05:08 <mcbears> after that it's just a library issue
17:05:09 <juanpablo_> benzrf: leftID bifirst mappend == rightID bisecond mappend? Something like this?
17:05:25 <Aruro> ok seems more clear
17:05:38 <simpson> Aruro: Somewhat. Without typeclasses, you can't perform any input or output; you need them for the IO Monad.
17:05:43 <Aruro> so it is nothing new conceptually to what is there already in haskell?
17:05:47 <benzrf> juanpablo_: no, we're just looking at left identity here
17:05:47 <simpson> Also you'll have problems dealing with numbers.
17:05:55 <benzrf> juanpablo_: x = mappend (mempty, x)
17:05:58 <benzrf> juanpablo_: you only need leftID
17:06:07 <juanpablo_> benzrf: oh okay
17:06:08 <benzrf> juanpablo_: want me to show you?
17:06:11 <benzrf> this one is non-obvious
17:06:16 <juanpablo_> benzrf: yes please :)
17:06:22 <Aruro> you mean i can not fit IO fucntion into static typsystem?
17:06:34 <benzrf> leftID = mappend . bifirst mempty
17:06:45 <simpson> I mean that Haskell's IO Monad is deliberately defined without any exported constructors.
17:06:51 <HeladoDeBrownie> Referring to the IO type as "the IO monad" is pretty misleading.
17:06:55 <juanpablo_> benzrf: rightID = mappend . bisecond mempty?
17:07:02 <Aruro> yes im thinking same
17:07:04 <benzrf> @let mempty' = const mempty :: Monoid m => () -> m
17:07:06 <lambdabot>  Defined.
17:07:06 <benzrf> juanpablo_: yes!
17:07:09 <benzrf> juanpablo_: look:
17:07:12 <benzrf> :t leftID
17:07:13 <juanpablo_> benzrf: cool!
17:07:13 <lambdabot> ((), t) -> t
17:07:17 <Aruro> why do i need IO monad i do my won io type :)
17:07:18 <benzrf> :t bifirst mempty'
17:07:19 <lambdabot> (Bifunctor p, Monoid b) => p () d -> p b d
17:07:22 <benzrf> eep
17:07:24 <Aruro> own*
17:07:27 <simpson> Okay. Good luck!
17:07:34 <Aruro> :D
17:07:35 <benzrf> juanpablo_: it genericized
17:07:40 <benzrf> juanpablo_: imagine (,) instead of p
17:07:44 <benzrf> but:
17:07:49 <Aruro> i just see this question over and over
17:07:54 <benzrf> > bifirst mempty' $ ((), "foo")
17:07:56 <lambdabot>  ((),"foo")
17:08:02 <Aruro> and it looks like misunderstanding
17:08:03 <benzrf> wait, wtf
17:08:04 <HeladoDeBrownie> Monad is simply a way you can compose IO values (among others) together to get new ones. It's not fundamental to how IO works in Haskell.
17:08:14 <benzrf> oh i see
17:08:23 <benzrf> > (bifirst mempty' $ ((), "foo")) :: (String, String)
17:08:26 <lambdabot>  ("","foo")
17:08:26 <benzrf> juanpablo_: ^
17:08:29 <Aruro> if it is a way can i call it typefunction?
17:08:33 <benzrf> > (mappend' . bifirst mempty' $ ((), "foo")) :: (String, String)
17:08:34 <lambdabot>  Couldn't match expected type ‘(GHC.Base.String, GHC.Base.String)’
17:08:34 <lambdabot>              with actual type ‘[GHC.Types.Char]’
17:08:35 <benzrf> > (mappend' . bifirst mempty' $ ((), "foo")) :: String
17:08:37 <lambdabot>  "foo"
17:08:58 <HeladoDeBrownie> Aruro, if you're asking whether IO is a type-level function, yes, you can think of it that way.
17:08:59 <juanpablo_> benzrf: I get this one I think
17:08:59 <benzrf> juanpablo_: so if i have a ((), m), then collapsing that to just m is the same as swapping out the () for mempty and combining
17:09:04 <benzrf> good!
17:09:15 <Aruro> yes i  think i was asking that
17:09:19 <benzrf> juanpablo_: this works because ((), m) is always the same as m
17:09:26 <HeladoDeBrownie> IO :: * -> *; that is, it takes a concrete type and gives you a concrete type
17:09:33 <benzrf> juanpablo_: they're isomorphic
17:09:41 <Aruro> ok sounds simple
17:09:47 <benzrf> juanpablo_: so if i use the isomorphism in particular, that's the same as mempty'ing
17:09:55 <Aruro> than what is a problem with controversy around it?
17:10:00 <benzrf> juanpablo_: here's a diagram https://upload.wikimedia.org/wikipedia/commons/1/10/Monoid_unit.png
17:10:09 <benzrf> juanpablo_: 1 means id
17:10:17 <HeladoDeBrownie> Aruro, I think most of the controversy is people getting overhyped about Monad.
17:10:18 <Aruro> does monad has something to do with purity?
17:10:28 <benzrf> Aruro: no
17:10:30 <Aruro> ok i did get overhyped lol :D
17:10:43 <benzrf> Aruro: monad is pretty interesting but it's not THAT interesting
17:10:50 <benzrf> Aruro: learn haskell, then learn monad
17:10:50 <Aruro> :D
17:10:53 <juanpablo_> benzrf: can you do that with any value? as to "make a value pointless"
17:10:59 <benzrf> juanpablo_: explain
17:11:12 <Aruro> i thought monad helps to somehow remedy IO damage to purity but perhaps im wrong
17:11:29 <benzrf> Aruro: no, monad is just a useful interface for interacting with the way haskell IO works
17:11:41 <Aruro> yes i will learn haskell ty
17:11:51 <HeladoDeBrownie> Aruro, nope, Monad is not some way to contain impurity. Rather, IO values *represent* impure programs. These can be executed by the runtime system, but not by evaluation of expressions.
17:11:52 <juanpablo_> benzrf: nvm. I somehow read ((), m) -> m ...
17:11:53 <benzrf> Aruro: you might as well say that busybox is the key to unix filesystems since it has the tools for messing with them
17:12:07 <benzrf> juanpablo_: that's correct?
17:12:09 <HeladoDeBrownie> Aruro, the only impure thing happening is in the act of *intepreting* IO values.
17:12:11 <Aruro> ok than in my system of values i do not care about monads if it is not conceptually important :)
17:12:18 <HeladoDeBrownie> Aruro, and that happens "outside" the language.
17:12:19 <benzrf> Aruro: they're important
17:12:21 <benzrf> just not THAT important
17:12:51 <Aruro> ty helado
17:12:54 <Aruro> sounds interesting
17:13:09 <juanpablo_> benzrf: yes, but ((), m) -> m doesn't express a value :3. Just mixed up "((), m) -> m" with just "((),m)"
17:13:13 <Aruro> so untill i read IO values in on pure side of universe?
17:13:20 <Aruro> read=interpret
17:13:30 <benzrf> Aruro: IO values are like code, Monad is like a text editor, the runhaskell program is like an interpreter
17:13:35 <benzrf> juanpablo_: ah
17:13:46 <benzrf> juanpablo_: ok, do you think you follow this formulation of regular ol monoids?
17:13:52 <juanpablo_> benzrf: yes, i do
17:13:54 <Aruro> ty interesting analogies :)
17:13:57 <benzrf> excellent!
17:14:05 <benzrf> juanpablo_: you may have noticed this already, but
17:14:29 <Aruro> ok i think i could get something valuable out of conversation
17:14:35 <benzrf> juanpablo_: the only things you needed to express the laws besides mappend and mempty morphisms were:
17:14:38 <benzrf> juanpablo_: 1. a bifunctor
17:14:41 <Aruro> so you say monad is imporant in its interpretation step
17:14:44 <benzrf> juanpablo_: 2. associate for that bifunctor
17:14:52 <benzrf> juanpablo_: 3. leftID and rightID for that bifunctor
17:15:03 <HeladoDeBrownie> Aruro, theoretically you can even write pure interpreters for IO, although, in practice, since IO's representation is rather opaque, this is infeasible.
17:15:07 <benzrf> juanpablo_: and nothing you wrote was specific to (,)!
17:15:12 <juanpablo_> benzrf: yes, that's what we used for expressing the laws
17:15:25 <Aruro> helado
17:15:35 <benzrf> juanpablo_: remember i explained monoidal categories first?
17:15:38 <Aruro> you claim it is possible to have pure language which has IO?
17:15:42 <juanpablo_> benzrf: yes
17:15:46 <benzrf> juanpablo_: C, ⊗, α, λ, ρ
17:15:53 <benzrf> juanpablo_: just generalize your formulation to any of those
17:15:57 <benzrf> you have a categorical monoid
17:16:01 <HeladoDeBrownie> Aruro, it's possible for a pure language to build and reason about *representations* of impure programs.
17:16:11 <HeladoDeBrownie> Aruro, and what I've been telling you has little to do with Monad, but rather with IO.
17:16:11 <Aruro> that is interesting
17:16:26 <Aruro> yes i already do not care about monad
17:16:33 <Aruro> since i has little value to conception
17:16:38 <Aruro> i heard now
17:16:45 <Aruro> i=it
17:16:46 <HeladoDeBrownie> Aruro, as I said earlier: Monad can be used to *compose* these programs, these IO values, together. That's done in the pure "build and reason about" stage.
17:17:18 <HeladoDeBrownie> (although the reasoning about is rather limited for IO in particular)
17:17:32 <Aruro> ok
17:17:49 <juanpablo_> benzrf: I have learned so much. I stayed two extra hours at work following your explanation. Didn't even notice the time :). Now I need to go home before it gets too dark
17:17:52 <juanpablo_> benzrf: thanks so much again
17:17:58 <benzrf> juanpablo_: no problem!
17:18:02 <juanpablo_> benzrf: hopefully i can connect from home with more questions :3
17:18:06 <Aruro> i was just trying to understand perhaps historical logic for introduction of it
17:18:13 <benzrf> juanpablo_: see you
17:18:35 <HeladoDeBrownie> Aruro, well, composing (parts of) programs is super handy, and it happens that one way we can do it generalizes well to other data structures.
17:18:56 <geekosaur> because main :: [Response] -> [Request] was a PITA
17:19:22 <Aruro> ok that seems plausible
17:20:01 <Aruro> what did you mean by *representations* of impure programs? it is different from impure programs themself?
17:20:37 <HeladoDeBrownie> Aruro, sure. Think about an IO value as a list of instructions for building a chair. This is distinct from the act of building that chair.
17:20:55 <HeladoDeBrownie> Aruro, with that list, you can do things like add more steps to the front or end, for example.
17:21:09 <HeladoDeBrownie> Aruro, this is a very loose metaphor, do not take it too seriously.
17:21:11 <Aruro> ok that is already clear
17:21:21 <Aruro> sure
17:21:37 <HeladoDeBrownie> And then the interpreter could be a person who reads the list and carries out the steps one by one.
17:21:59 <HeladoDeBrownie> In Haskell, we reason about lists of steps for building chairs. We do not build chairs.
17:22:09 <Aruro> so in this way what stops me from declaring parts of my haskell program to be imperative?
17:22:20 <Aruro> do handle real life situations?
17:22:41 <Aruro> do=to
17:22:42 * hackagebot Ebnf2ps 1.0.12 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.12 (FranklinChen)
17:22:50 <HeladoDeBrownie> Not quite sure what you're asking.
17:23:10 <HeladoDeBrownie> Once your Haskell program has built your program (or list of instructions), the IO system can interpret/execute it.
17:23:32 <Aruro> i mean i could just switch paradigm  and write c-like code where i need it
17:23:35 <HeladoDeBrownie> Sure.
17:23:43 <Aruro> inside haskell code
17:23:54 <Aruro> what would be my problem with that?
17:23:54 <HeladoDeBrownie> Do notation was designed in part to allow the appearance of imperative-style code.
17:24:00 <Aruro> yes
17:24:06 <Aruro> i was asking about do from start
17:24:20 <HeladoDeBrownie> It might even be considered the raison d'etre of do notation.
17:25:10 <HeladoDeBrownie> Careful not to confuse syntax and semantics. Do notation is just syntax, it has nothing to do with what I've been telling you about IO.
17:25:31 <CrazyM4n> The Ubuntu installation is nearing completion
17:25:38 <Aruro> yes u mean it is represented in another way inside compiler?
17:25:38 <CrazyM4n> #doitforthegloss
17:26:18 <nitrix> Can I just use ADTs and assume I wont need classes and intances for most work?
17:26:46 <HeladoDeBrownie> Aruro, it's quite a bit stronger of a distinction than that :)
17:26:59 <Aruro> yes
17:27:00 <nitrix> I'm having a hard time understanding what beneficial they'd bring to me in my software, so is falling back to ADT a sane thing to do?
17:27:11 <Aruro> but practically it is reduced to that isnt it?
17:27:22 <HeladoDeBrownie> Aruro, I'm actually not entirely sure what you're asking
17:27:24 <nitrix> My understanding is, when I'll need them, I'll just know that something doesn't feel right and the answer will come by itself?
17:27:27 <HeladoDeBrownie> Mind rephrasing?
17:27:31 <Aruro> yes
17:27:43 * hackagebot graphmod 1.2.5 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.5 (IavorDiatchki)
17:28:08 <Aruro> i was actually just adressing your comment about syntax and semantics
17:28:10 <HeladoDeBrownie> nitrix, ADTs are practically ubiquitous in Haskell. Classes are a means of polymorphism. They have different applications, so it depends what you're trying to do.
17:28:39 <Aruro> ok i think monads i "understood" enough for my stage :D
17:29:32 <Aruro> helado u mentioned before pure languages (theoretical) that can muse about non pure programs? is there any work on this?
17:29:53 <Aruro> i mean some articles
17:30:51 <nitrix> HeladoDeBrownie: I want to have a list of X, that each provide a different implementation of the same function.
17:31:29 <nitrix> HeladoDeBrownie: Ideally, that could be passed around to functions as some more abstract type that can just invoke the function, whatever its implementation is.
17:31:59 <benzrf> nitrix: what, like [a -> b]?
17:32:29 <nitrix> [Endpoint] where an Endpoint would have a getPage and setPage function.
17:33:26 <HeladoDeBrownie> Not sure which of my messages went through, but my connection dropped. Give me a moment.
17:33:37 <Aruro> none
17:33:45 <Aruro> last one was to nitrix
17:33:49 <benzrf> nitrix: sounds like Endpoint should be an ADT containing them
17:33:52 <Aruro> about adts
17:33:53 <silver> "ADTs are practically ub..." is last one
17:34:01 <Aruro> yes
17:34:30 <nitrix> You'd really need an IRC bouncer (:
17:34:47 <Aruro> im using kiwiirc i like it :D
17:34:55 <HeladoDeBrownie> Aruro, I can't point you at specific articles, but there should be reading on the design choice behind Haskell's IO online somewhere
17:35:12 <Aruro> ok np
17:36:38 <nitrix> Aruro: The way it was explained to me; had you worked in a functional language for long enough, you'd end up creating Monads yourself. It comes naturally.
17:36:48 <HeladoDeBrownie> Aruro, this is related https://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/
17:37:11 <HeladoDeBrownie> Now it's dinner time for me. I'll probably be back later. Have fun all.
17:37:17 <Aruro> ty! i will look in it
17:37:22 <Aruro> yes
17:37:26 <Aruro> enjoy dinner
17:37:31 <Aruro> was fun talking with you
17:38:02 <nitrix> Aruro: Not the best talk, very long, but it's the most fresh one I have in mind:   https://www.youtube.com/watch?v=ZhuHCtR3xq8
17:39:09 <Aruro> yes ty!
17:39:27 <Aruro> i came across that video
17:39:34 <Aruro> in my to watch list
17:40:02 <Aruro> i have question about curried functions
17:40:37 <Aruro> (++) is perfectly accepted in foldr for example
17:40:50 <Aruro> why (++"1"++)
17:40:58 <Aruro> is not accepted as curried fucntion
17:41:06 <Aruro> with same 2 arguments as just (++)
17:41:34 <Aruro> am i missing somthing? i know it is possible to rewrite in lambdas
17:42:06 <benzrf> Aruro: that's just not syntax
17:42:07 <benzrf> is all
17:42:11 <Aruro> k
17:42:17 <benzrf> you may want (++) . (++"1")
17:42:36 <benzrf> oh wait
17:42:53 <benzrf> that's more inefficient than a lambda with proper associativity :v
17:43:03 <benzrf> although i suppose laziness will fuse it
17:43:45 <Aruro> how do you see it is less effective?
17:45:59 <jjap> Hi, all. Can I rant? I'm looking for a bit of guidance: It seems that there's a huge barrier between what the introductory tutorials/classes/books teach, and what "modern" haskell looks like.
17:46:36 <jjap> Are Beginners are taught bad habits? They teach us to use strings, but it turns out that String is something of a wart. We're supposed to use Text. Lists are given special place, but I should have been using HashMap all along. Language extensions are intimidating and fustrating: Why isn't the language the "right way" by default?
17:46:54 <benzrf> jjap: Lists are given special place, but I should have been using HashMap  all along.
17:47:00 <benzrf> jjap: i dont think so
17:47:05 <benzrf> that's only true of assoclists
17:47:15 <benzrf> also, strings are fine in many cases
17:47:29 <solatis> ok, this is a totally noob question, but i'm still trying to figure out best practices -- is using liftIO considered a bad practice?
17:47:36 <benzrf> language extensions are because you don't want things that aren't 100% approved in the spec
17:47:41 <jjap> We're taught Prelude. But now I learn that Prelude has partial functions (which I should avoid) and simplier versions of more powerful functions. Certain third party libraries (like ones dealing with the file system, date, etc) are clearly superior to the ones that come with Haskell Platform, but I'm only learning that now.
17:47:44 <benzrf> what is Officially Haskell is very tightly guarded
17:47:56 <benzrf> jjap: haskell platform is not necessarily #1
17:47:57 <solatis> since that essentially makes a function unpure
17:48:00 <jjap> Hell, I'm now being recommended to not use the platform at all. The "what I wish I knew when I was learning haskell" list is getting larger. Is this language in need of a reboot? There seems great unwillingness to do so. Can someone at least update "Real World Haskell"? :)
17:48:00 <benzrf> jjap: Prelude is indeed flawed
17:48:14 <CrazyM4n> I agree with jjap: why do we need language extensions when the default should work?
17:48:18 <jjap> </rant>
17:48:18 <benzrf> solatis: it does not make it impure
17:48:46 <benzrf> CrazyM4n: the default DOES work.
17:48:56 <josephle> if you have the power to make don stewart or bryon o'sullivan write RHW2, then please make of that power now
17:48:59 <dibblego> {-# LANGUAGE NoImplicitPrelude #-} every time
17:49:04 <josephle> *make use
17:49:22 <solatis> benzrf: hmm but liftIO essentially means "perform side effects", not ?
17:49:35 <jjap> II understand that language extensions are a useful way to test drive new features. But, it's turning into scheme: Once you learn the "simple" language spec, you now have to study 70 language extensions.
17:49:49 <dibblego> solarus: No, liftIO just converts to an IO action  at no point is there impurity
17:50:37 <solatis> dibblego: ok
17:50:42 <benzrf> jjap: yeah that's a bit lame
17:50:42 <josephle> dibblego: actually liftIO converts an IO action...it's an easy mistake to make :)
17:50:59 <benzrf> solatis:
17:51:02 <benzrf> :t liftIO
17:51:03 <lambdabot> MonadIO m => IO a -> m a
17:51:05 <benzrf> that's not impure!
17:51:09 <dibblego> s/to/from
17:51:21 <benzrf> you only have a problem if there's an m a -> a for something that has a MonadIO instance
17:51:28 <solatis> benzrf: but but.. how does it differ from unsafePerformIO ?
17:51:32 <benzrf> you only have a problem if there's an m a -> a for something that has a MonadIO instance
17:51:43 <dibblego> solarus: equational reasoning is preserved (therefore it is pure)
17:51:51 <solatis> aha
17:51:54 <dibblego> solarus: unlike unsafePerformIO, which is insafe
17:51:56 <dibblego> *unsafe
17:52:00 <CrazyM4n> I know the default works, but shouldn't the default be the best way?
17:52:13 <benzrf> CrazyM4n: Don't ask Me
17:52:29 <CrazyM4n> I'm just asking the Haskell irc in general ;)
17:52:30 <solatis> but the function can return different results when called multiple times -- i thought the defintion of a 'pure' function was repeatability?
17:52:34 <dibblego> when we have to fight to fix something as boring as mapM, then no, the default won't be the best way
17:52:38 <benzrf> solatis: no it cant
17:52:48 <dibblego> solatis: no, it cannot  it returns the same value every time
17:52:48 <benzrf> solatis: liftIO will always return the same result given the same inpot
17:52:58 <solatis> hmz
17:53:07 <dibblego> note that (IO String) is not String
17:53:15 <dibblego> it returns the same (IO String) every time
17:53:22 <dibblego> do not substitude (String) in that statement
17:53:30 <solatis> ah yes, so the unsafe actions are inside the monad, not the function that calls liftIO
17:53:39 <dibblego> there are no unsafe calls
17:54:34 <solatis> sorry for the newbie questions, i'm still trying to understand everything
17:55:01 <dibblego> that's ok, coming to terms with IO is often not a good place for a beginner though
17:55:08 <solatis> for context, i'm wrapping a database access layer
17:55:12 <piss-christ> convert = map (pred . read)
17:55:17 <piss-christ> is this example of currying?
17:55:22 <slack1256> Does any of the webframework have documentation presuming I don't have any experience with web-development?
17:55:23 <dibblego> @type curry
17:55:24 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:55:27 <dibblego> that is currying
17:55:39 <dibblego> all haskell functions take one argument (every single one, no exceptions)
17:55:40 <slack1256> snap and yesod assume it.
17:55:43 <dibblego> this is not currying though
17:55:53 <piss-christ> yes, but it's enabled by having currying, right?
17:56:04 <dibblego> currying is exactly the function above
17:56:07 <solatis> dibblego: i know, i think i should just accept it and use it, and accept that i will start to understand everything somewhere down the road... :)
17:56:10 <dibblego> you might mean partial application
17:56:45 <jjap> piss-christ: the (pred. read) is an example of function composition. The fact that `convert` is now "map with this function, but still waiting for a list" is currying
17:56:48 <HeladoDeBrownie> And just for fun, partial application isn't well defined in Haskell either
17:56:54 <Dashkal> curry and uncurry bother me still.  I need to work out the truth table on a -> b -> c vs b -> a -> c.
17:56:56 <piss-christ> right, I thought being able to do partial application is implied by being able to curry
17:56:58 <piss-christ> ok, thanks
17:57:14 <cellopin> Any recommendations installing haskell for ubuntu 12.04. I don't even have an idea how to do it :(
17:57:24 <piss-christ> yeah, I didn't mean the composition
17:58:05 <piss-christ> yeah, could have used just convert = map read
17:58:50 <HeladoDeBrownie> piss-christ, the main useful language feature I see that exhibiting is functions as values. Having that implies you can have functions as input or output to other functions.
17:59:06 <jjap> cellopin: https://github.com/bitemyapp/learnhaskell
17:59:10 <HeladoDeBrownie> piss-christ, which is how we're allowed to have (.), for example.
17:59:13 <HeladoDeBrownie> As well as map.
17:59:46 <jjap> cellopin: Specifically "Get Started", "Ubuntu"
18:00:06 <cellopin> jjap: i'll take a look. thanks.
18:01:47 <cellopin> oh by the way, does haskell have a virtual environment or something similar?
18:02:15 <dibblego> you mean cabal sandboxes?
18:03:51 <jjap> cellopin: http://dev.stephendiehl.com/hask/#cabal
18:04:07 <cellopin> shoot a lot to learn :)
18:04:36 <jjap> cellopin: Indeed
18:08:04 <jkbbwr> Howdy all
18:08:14 <jkbbwr> Anyone here sum up dependant types for me
18:09:28 <benzrf> jkbbwr: types & values live at the same levle
18:09:30 <jjap> jkbbwr: Types and values no longer live in two worlds. Great power. Great tradeoff that Haskell decided againt.
18:09:41 <jkbbwr> This still doesn't really explain stuff
18:09:50 <benzrf> how so
18:09:58 <jjap> jkbbwr: How much do you wanna know?
18:10:05 <jkbbwr> What can I do with it
18:10:08 <jkbbwr> example or something
18:10:31 <piss-christ> oh, dibblego, you are the weird dude from twitter
18:10:55 <piss-christ> I often can't tell wheter you are being ironic or not
18:11:13 <jjap> Bad example, but think [a] -> [b -
18:11:27 <jjap> Bad example, but think [a] -> [b] -> [a+b]
18:11:56 <jkbbwr> jjap: rememeber I don't actually know haskell
18:12:12 <benzrf> jkbbwr: eek
18:12:34 <jkbbwr> I havent converted to the great type dynasty
18:13:37 <jjap> jkbbwr: What do you know about types? Java, C, etc?
18:13:56 <jkbbwr> Err Java stuff, C#, C all those C like things
18:14:01 <jkbbwr> and stuff like that
18:15:38 <jjap> So, instead of your function being `a: int, b:int -> c:int`... that is "a function that takes two ints and returns an int... you can now write `a:int, b:int -> c:A+B`
18:16:08 <jjap> jjap: All of a sudden you're doing operations on your types, so to speak
18:16:18 <jkbbwr> jjap: that sounds confusing and horrible to keep track of
18:16:21 <jjap> types are no longer "annotations", but are "part of the code" (my terms)
18:16:37 <jjap> jkbbwr: Sounds like Real Ultimate Power!
18:16:46 <jkbbwr> jjap: until people start abusing it
18:17:00 <jjap> jkbbwr: With great power, comes great power
18:17:29 <jjap> jkbbwr: In functional languages, types aren't a chore (well, aren't supposed to be).
18:17:42 <jkbbwr> jjap: so does this mean I no longer actually have to write return a + b
18:17:48 <jkbbwr> I just know that it will return int + int
18:17:48 <jkbbwr> wait
18:17:58 <jkbbwr> why do I care its adding types, doesn't int satisfy something that can be added
18:18:04 <jjap> jkbbwr: it means that if you don't return a+b, the compiler will say "wait, that's not what you promised to do"
18:18:33 <Hijiri>   generally in functional languages you don't need to write return
18:18:42 <Hijiri> because you just have a value
18:18:48 <jkbbwr> Hijiri: mhm
18:18:55 <jjap> like, if you did "return a", the compile will say "wait, you didn't say you'd return any old int. you say it would be an int that's like `a` and `b` combined"
18:19:19 <jkbbwr> jjap: but what if I move a + b to somewhere else
18:19:20 <jjap> Hijiri: I'm developed a Dependently Typed Java... on the fly... in jkbbwr's head
18:19:34 <jkbbwr> c = a + b; c == a+b
18:19:40 <jjap> jkbbwr: somewhere else?
18:19:47 <jkbbwr> jjap: c is still a + b
18:19:49 <jkbbwr> just already completed
18:20:00 <jjap> jkbbwr: yeah that's fine
18:20:10 <jkbbwr> jjap: but suddenly dependant types freaks out
18:20:12 <rom1504> how can A+B be a type ?
18:20:30 <rom1504> will it somehow generate a prooth for the function ?
18:20:44 <jjap> rom1504: i'm trying to say "a type that is like what a and b would be combined"
18:21:22 <jkbbwr> jjap: see now returning c doesn't satisfy a + b
18:21:26 <jkbbwr> but it is still a + b
18:21:34 <jjap> jkbbwr: My example is flakey, the but the idea is straightforward: You can now express things with types that you couldn't before
18:21:47 <jkbbwr> jjap: oh? new before things?
18:22:07 <jjap> jkbbwr: if `c` has the properties of and Int and an Int combined, sure it would work
18:22:30 <jkbbwr> jjap: but how do you know that any int doesnt satisfy an int and an int combined without tracking its history
18:23:09 <silver> maybe it tracks its history with type inference
18:23:15 <xcv_> hey guys, I'm watching this presentation on YouTube https://www.youtube.com/watch?v=F7F-BzOB670#t=137 and am trying to grok the function body in 2:47:
18:23:29 <jjap> jkbbwr: Let me try another example... say you have a function that combines two arrays...
18:23:34 <xcv_> loeb fs = xs where xs = fmap ($ xs) fs
18:23:52 <jkbbwr> jjap: [1,2,3] extend [4,5] gives [1,2,3,4,5] right?
18:24:03 <xcv_> the type signature is loeb :: Functor f => f (f a -> a) -> f a, which I understand
18:24:38 <jjap> jkbbwr: instead of simplely `list1:ArraySizeN, list2:ArraySizeM -> list3:ArraySizeP`, you can now say `-> list3:ArraySizeN+M`
18:24:41 <xcv_> so the xs are recursively defined as the result of fmapping the functions in fs over fs (considered as a functor)
18:24:58 <jkbbwr> jjap: but arn't list lengths runtime dependant?
18:25:28 <benzrf> jkbbwr: aye, there's the rub
18:25:36 <benzrf> jkbbwr: you have two choices
18:25:46 <jjap> jjap: Lists have a length when they are being operated on, and a new list is being returned
18:25:46 <benzrf> wait no just 1
18:26:03 <benzrf> jkbbwr: you *write a mathematical proof* that the list will be long enough
18:26:05 <jjap> jkbbwr: Perhaps i should have said Vector or Fixed Sized Array to make the xampel cleaer
18:26:08 <benzrf> and that interfaces with the type system
18:26:24 <xcv_> am I understanding this right?
18:26:27 <ray_caster_> Hey, guys! I could use some help. Please forgive me if this is the wrong channel... Long story short; install via cabal failed (segfault) and now I'm missing 3 gigs of HDD space. Where does cabal store temp build files on OSX?
18:26:57 <jkbbwr> so given an int[] of length 40 and int[] of 55 you can say that int[]<40> + int[]<55>
18:27:35 <ray_caster_> Alternatively, is there a way to clear temporary build files using cabal?
18:27:43 <jjap> ray_caster_: Not sure, but for your next attempt at install, I recommend: https://ghcformacosx.github.io/
18:29:07 <jjap> jkbbwr: you can specify, *inside your type signature* that a:int[]<40> and b:int[]<55> will *always* be c:int[]<95> and *the compiler* will confirm this
18:29:24 <jjap> asterisks for emphasis :)
18:29:31 <jkbbwr> jjap: so carrying on with my syntax
18:30:03 <jkbbwr> jjap: public merge(int[]<40> a, int[]<50> b) -> int[]<95> { ... }
18:30:10 <jkbbwr> jjap: random imaginary syntax
18:30:11 <codygman> I'm at a hackathon. What is the easiest option for web framework + auth? I'm making what is basically a directory with profiles, user categories, and search (going to use bloodhound + elasticsearch).
18:31:10 <jjap> codygman: snap + an auth snaplet i assume
18:31:36 <jkbbwr> jjap: this is fine if I was writing a method to merge two arrays of preknown length.
18:31:38 <codygman> jjap: Thanks, that's what I'm looking at.
18:32:10 <codygman> ooh found this: https://github.com/noteed/snaplet-auth-example I'll probably use it unless someone has experience with another and recommends it.
18:32:18 <jjap> jkbbwr: better is `int[]<a> arrayone, int[]<b> arraytwo) -> int[]<a+b> { ... }`
18:32:21 <gdoteof> on osx im getting "thread blcoked indefinitely in an mvar operation"
18:32:25 <gdoteof> on linux, it is fine
18:32:26 <jkbbwr> jjap: RIGHT
18:32:44 <gdoteof> if i may, WAI GOD?!?
18:33:10 <jjap> jkbbwr: notice how you can now add *inside* your types!
18:33:17 <jkbbwr> jjap: sorta
18:34:03 <jjap> jkbbwr: with the normal java types, you could give an int[]<11> and an int[]<10> and return an int[]<4>.... Java wouldn't complain
18:34:12 <jkbbwr> jjap: gotcha
18:34:23 <jkbbwr> jjap: more "compile time safety" you folk love
18:34:45 <jjap> jkbbwr: but if you could say "my return value will ALWAYS be the size of arrayone + arraytwo", the compiler can now do more
18:34:53 <jjap> jkbbwr: right
18:35:59 <jkbbwr> jjap: I think so
18:37:32 <jkbbwr> jjap: One day when I walk these typed lands, I will see the power of the magical dependant type
18:37:33 <jjap> jkbbwr: One of the main guys of haskell is the person who added generics to Java
18:37:41 <jkbbwr> jjap: I am no typed monk
18:38:35 <jjap> jkbbwr: Heh. Dependent types are still at the forefront. Haskell doesn't go into that terroritory but Adga and Idris do
18:38:44 <jkbbwr> jjap: Good for them
18:39:09 <jjap> jkbbwr: Indeed. Their success of failure will decide the future of us all!
18:39:18 <jkbbwr> So say the great typed monks
18:39:48 <jjap> jkbbwr: Now, back to your koans!
18:40:08 <jkbbwr> jjap: Back to my python and java and c# and kotlin and away from these hallowed halls
18:40:21 <jkbbwr> jjap: though thank you for the explanation. Its cleaned up a great deal.
18:40:37 <jjap> jkbbwr: My pleasure. You helped me find a good way to explain it
18:40:47 <jkbbwr> jjap: wicked
18:41:29 <jjap> jkbbwr: Indeed.
18:42:57 <jjap> ray_caster_: have you tried nuking your tmp directory?
18:44:25 <ray_caster_> jjap: I want to, but I have no idea where cabal stores it...
18:45:04 <jjap> ray_caster_: which os are you on?
18:45:12 <ray_caster_> jjap: OSX 10.6.8
18:45:43 <jjap> ray_caster_: if cabal uses the global, default tmp dir, It's /var/tmp
18:46:13 <jkbbwr> jjap: naugty. it should use /tmp
18:47:35 <jjap> jjap: Hmm. osx does have both /tmp and /var/tmp. I'm not sure what the difference is (no use quoting FHS. Apple does things their way)
18:47:53 <ray_caster_> jjap: folder is only a few kb on my system, although I'm pretty sure cabal is installing packages locally (home folder *somewhere*)
18:48:06 <ray_caster_> jjap: yeah, I noticed, checked both
18:48:12 <jjap> ray_caster_: ~/.cabal then?
18:49:00 <ray_caster_> jjap: only 8 kb I'm afraid...
18:49:24 <jjap> ray_caster_: ~/Library/Haskell
18:50:12 <ray_caster_> jjap: yes, I checked there as well. cabal does seem to store finished products there, but not temporary stuff, so that folder only accounts for about 300 mb on my machine
18:51:07 <jjap> ray_caster_: Doh. I'm not sure. Diff your last backup... or try daisy disk :)
18:51:52 <jjap> ray_caster_: if it is in a real tmp folder, it should go away after a reboot
18:52:47 <bryanedds> hey Cale - you are needed in #haskell-game :)
18:52:48 <ray_caster_> jjap: lol, no backups. I like living on the edge. btw, I'm checking through my ~/Library/Caches folder and suspiciously enough it's 3.7 gigs large...
18:52:57 <merijn> ray_caster_: I dropped in the middle, you're trying to find out where your disk space is going?
18:53:03 <jjap> ray_caster_: Yay
18:53:19 <jjap> merijn: failed cabal build of ghc, yeah
18:53:25 <merijn> wait
18:53:30 <bryanedds> paging Dr. Cale to #haskell-game :)
18:53:34 <merijn> Cabal build of ghc?!
18:53:52 <merijn> You're aware that you cannot build ghc using cabal, right? :)
18:54:17 <ray_caster_> merijn: no, I tried installing ghc-mod and cabal segfaulted after eating 3 gigs of HDD space
18:54:38 <jjap> merijn: sorry, ghc-mod :P
18:55:48 <jjap> ray_caster_: can you confirm that cabal was using ~/Library/Caches? That's not a great choice of temporary directories..
18:56:29 * geekosaur has disliked that since discovering it
18:56:37 <ray_caster_> jjap: no... I'm just looking through the folder names, but I'm not removing anything if I'm not 100% sure
18:58:02 <slack1256> ray_caster: in which part of the installation of ghc-mod did it segfault?
18:58:08 <slack1256> installing haskell-src-exts?
18:58:58 <ray_caster_> slack1256: I believe the installation of src-exts completed. I think it failed when generating documentation
18:59:23 <slack1256> Mmm let me check that out
19:00:37 <ray_caster_> Noob OSX question: Is there a way to get past output in the terminal? I closed the window that had the failed cabal run on it.
19:01:55 <merijn> ray_caster_: No
19:02:07 <ray_caster_> damn
19:03:31 <jjap> ray_caster_: There's also $TMPDIR... try this: du -hcs $TMPDIR
19:04:26 <threestrikes> does anyone here use travis CI
19:04:30 <ray_caster_> jjap: 4k in total
19:04:34 <cellopin> to create a new package you will need a .cabal file right?
19:04:43 <merijn> cellopin: correct
19:05:01 <jjap> ray_caster_: sudo du -hcs /var/folders
19:05:07 <threestrikes> if you do can you pm me?
19:05:08 <merijn> cellopin: If your next question is "How to write one?", try "cabal init"
19:05:16 <cellopin> okay
19:05:29 <cellopin> hah.. thanks
19:05:48 <ray_caster_> jjap: only 252M
19:06:47 <jjap> cellopin: if using sandboxes -> cabal sandbox init
19:06:58 <merijn> jjap: That does something entirely different
19:07:10 <merijn> They're not even related
19:07:18 <carter> yeah
19:07:33 <carter> sandbox init is for consuming a package
19:07:36 <carter> init is for authoring one
19:07:37 <cellopin> Yeah i created a sandbox before I did a cabal init
19:08:35 <jjap> we were talking about sandboxes earlier. I wanted to make sure he didn't skip it if needed
19:09:04 <slack1256> ray_caster_: I did and install and completed succesfully :/
19:09:18 <slack1256> if you could output a build output on lpaste it would be great!
19:10:16 <cellopin> okay here's another question.. difference between a .hs and a .lhs file?
19:10:30 <ray_caster_> slack1256: does cabal log the build output somewhere besides the terminal? if not, I dun goofed (I closed the terminal where I ran cabal-install)
19:10:48 <cellopin> the default is .hs but .lhs is for what?
19:10:58 <slack1256> you could run the "cabal install | tee logOfTheInstall"
19:11:16 <jjap> cellopin: Literate programming in haskell. (Haskell implements a simplified version of literate programming) https://en.wikipedia.org/wiki/Literate_programming
19:11:47 <ray_caster_> slack1256: could you be more precise? (I'm very new to Haskell)
19:11:53 <jjap> ray_caster_: you'll have to run it again
19:12:25 <ray_caster_> jjap: ugh, that sounds risky...
19:12:37 <jjap> ray_caster_: to the victor go the spoils
19:12:59 <merijn> cellopin: Basically, in a .hs files, the default is code and you need to indicate comments. In a .lhs files the default is comments and you need to indicate code. It's useful for authoring "runnable/compilable" blog posts/papers
19:13:54 <cellopin> wow that is cool.. i'll dig a little dipper
19:15:19 <jjap> cellopin: http://scholarslab.org/research-and-development/shell-programming-in-haskell-converting-s5-slides-to-pdf/ See: "Second conclusion"
19:16:50 <jjap> ray_caster_: It's past my bed time. Good luck :)
19:16:51 <slack1256> ray_caster_: Oh okay, in the terminal you should have a program "tee myfile " that grabs stdout and redirect it to both myfile and the screen
19:17:26 <slack1256> ray_caster_: you should then install "cabal install ghc-mod | tee myfile" and then upload myfile to a paste site as lpaste
19:18:14 <ray_caster_> slack1256: gotcha! still pondering whether I'm willing to do this again
19:20:30 <argent0> :t (return .)
19:20:31 <lambdabot> Monad m => (a -> b) -> a -> m b
19:20:44 <slack1256> ray_caster_: no need to do it :-) this is me being lazy. Try it another day and if still has problem you can open a issue on github
19:21:15 <argent0> How could I define `arr` for: instance Monad m ⇒ Arrow (Kleisli m)
19:21:26 <argent0> ?
19:21:27 <slack1256> return?
19:22:05 <slack1256> @type arr
19:22:06 <lambdabot> Arrow a => (b -> c) -> a b c
19:22:14 <ray_caster_> slack1256, are you a maintainer? if so you should note that I am running on OSX 10.6 which is no longer officially supported. at this point in time I don't expect software to work under my OS
19:23:10 <argent0> slack1256: So what would be " arr f = return . f " ?
19:23:19 <slack1256> ray_caster_: I sometimes send patches, always looking for stuff under my domain of expertise :-). As long as the haskell platform runs on you machine you should be able to install haskell programs
19:23:39 <slack1256> argent0: at least to me that is correct
19:24:21 <cellopin> omg my fav ide doesn't have a plugin for haskell..:'( what are you guys using?
19:24:38 <slack1256> I meant yours "arr f = return . f"
19:24:55 <slack1256> cellopin: emacs or vim mainly (with plugins)
19:24:58 <argent0> slack1256: Ok thanks!
19:25:07 <ray_caster_> slack1256: okay, good to know. either way I'm going to bed right now, but I could pop my head in tomorrow and maybe give cabal-install a try
19:25:11 <slack1256> argent0: no need to thank me, you did all the work :-)
19:25:26 <cellopin> wow.. that's another learning curve for me..
19:25:48 <slack1256> ray_caster_: OK, no need to do stuff RIGHT NOW :-)
19:25:54 <slack1256> go to sleep xD
19:26:24 <ray_caster_> slack1256, yeah, it's like 4:30 AM here so I *should* go to bed...
19:26:35 <slack1256> cellopin: although using a simple editor with ghci on a terminal on the side isn't that bad, I did that for a year and it was good.
19:27:26 <ray_caster_> okay, I'm off! thanks for the help, people!
19:27:26 <cellopin> okay let me search those..
19:27:39 <slack1256> see ya
19:36:47 <stephenmac7> Is it okay to use String instead of Data.Text for showing the user output?
19:37:07 <dmj`> stephenmac7: How much user output? T.putStrLn works too
19:37:21 <dmj`> Data.Text.IO.putStrLn .. ?
19:37:43 <stephenmac7> dmj`: No, I just want to use the convinient instances of the show typeclass
19:38:48 <stephenmac7> Not very much output... it's not really about performance (the output can be read in a few seconds).
19:39:04 <stephenmac7> I'm planning on switching to vty though (http://hackage.haskell.org/package/vty) soon
19:39:33 <merijn> stephenmac7: It's ok, just slow
19:39:42 <dmj`> yea
19:40:01 <stephenmac7> What if it will have possibly a large amount of unicode?
19:40:06 <merijn> stephenmac7: Note that String can take up to 24 bytes per character on some machines
19:41:01 <apo_> what
19:41:34 <stephenmac7> merijn: So, how would I avoid it if I want to, say, use show
19:41:48 <merijn> apo_: pointer to : constructor, pointer to list item, pointer to tail
19:41:59 <apo_> ~_~
19:42:06 <stephenmac7> (Also, why doesn't GHC just replace String with Text?)
19:42:13 <merijn> apo_: That's already 3x pointer size, not counter the unicode codepoint (another 4 bytes or so)
19:42:37 <merijn> apo_: There's a reason why Text is usually orders of magnitude faster for text processing :)
19:43:21 <merijn> apo_: Text is approximately 1-2 bytes per character plus like a few pointers overhead per block (default block size is 32kb, so that overhead is negligible)
19:43:27 <codygman> For some reason my css files are showing "index" in my snap project, can anyone help me?
19:44:16 <apo_> I should take another look at haskell some time
19:44:19 <codygman> nevermind, I was editing something wrong
19:44:30 <apo_> I took a course last year, but haven't done anything since then
19:44:32 <merijn> stephenmac7: Because String is convenient to work with for small strings, easier to understand for beginners and changing it would break backwards compatibility :)
19:50:51 <phao> Hey... how would one type a function that can take itself as a parameter and returns, say an integer?
19:51:16 <Dashkal> fix?
19:51:24 <slack1256> > fix (const 5)
19:51:26 <lambdabot>  5
19:51:41 <slack1256> @type fix (const 8)
19:51:41 <lambdabot> Num a => a
19:53:13 <phao> Thanks.
19:54:39 <benzrf> time for slepe
19:54:41 <benzrf> oops
19:54:43 <benzrf> bye
20:02:15 <jayunit100_4g> let [] = [1] in 234 --- why does compile ?  Shouldnt a "let" function not be allowed to bind a primitive like [] to anything?
20:02:58 <Taneb> jayunit100_4g, it's using [] as a pattern
20:03:10 <Taneb> > let [x,y,z] = [1,2,3] in x + y + z
20:03:11 <lambdabot>  6
20:03:16 <jayunit100_4g> ohhh ok
20:03:27 <jayunit100_4g> how can we know when let is referencing a pattern vs an actual binding
20:03:46 <Taneb> jayunit100_4g, bindings are legal names for variables
20:04:14 <Taneb> ie., starts with a lower case character, or is entirely symbols and starts with something other than :
20:04:17 <jayunit100_4g> so your saying, i could have a variable called "let [] = 1"
20:04:33 <Taneb> Sorry, it has to be 1 word, alphanumeric
20:04:39 <jayunit100_4g> in that case, if "let [] = 1" was a binding, certainly there is no way i could refer to it as a variable?
20:04:43 <Taneb> (or a handful of other symbols)
20:05:04 <Taneb> jayunit100_4g, that's OK, it's not a binding
20:05:09 <jayunit100_4g> so i could write  afunction which disabled lists, entirely ?
20:05:09 <geekosaur> "variable" is, um, a questionable concept
20:05:25 <geekosaur> but [] is a constructor, and can't be (re)defined that way
20:06:05 <geekosaur> (it's also built-in syntax, I believe, because lists have syntactic sugar so you can write [a,b,c] instead of (a:b:c:[])
20:06:14 <jkbbwr> Howdy all
20:06:22 <jkbbwr> Woops
20:06:25 <jayunit100_4g> so… (1) [] is a constructor but i can do (2) let <constructor> = [1] -- ?
20:06:42 <geekosaur> constructors cannot be defined with let
20:07:03 <geekosaur> they are defined with data or newtype, or aliased with type
20:07:12 <jayunit100_4g> but they can be substituted into let , correct?
20:07:39 <jayunit100_4g> let [] = [1] -- syntax = (((( let <constructor> = <another_constructor> )))))
20:07:41 <geekosaur> I am not sure what you are asking
20:07:45 <geekosaur> no
20:08:22 <geekosaur> you cannot let a constructor, you must use data or newtype
20:08:40 <jayunit100_4g> but [] is a constructor, correcT?
20:09:04 <jayunit100_4g> > let [] = [1]
20:09:05 <lambdabot>  not an expression: ‘let [] = [1]’
20:09:14 <zereraz> hello there, can someone explain
20:09:15 <zereraz> :t fmap compare "HI THERE"
20:09:16 <lambdabot> [Char -> Ordering]
20:09:18 <geekosaur> [] is a constructor. you cannot `let` it
20:09:19 <jayunit100_4g> > let [] = [1] in 2
20:09:22 <lambdabot>  2
20:09:28 <zereraz> why is there a square bracket outside
20:09:34 <zereraz> the type signature
20:09:40 <merijn> zereraz: Because compare takes two arguments
20:09:44 <jayunit100_4g> geekosaur: ^^^ WTH just happened ? somehow that whole monstrosity returned "2" :) ?
20:09:45 <merijn> :t compare
20:09:46 <lambdabot> Ord a => a -> a -> Ordering
20:09:48 <merijn> :t fmap
20:09:48 <geekosaur> ok, I get it. I mentioned syntactic sugar earluer
20:09:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:09:53 <merijn> :t fmap compare
20:09:54 <lambdabot> (Ord a, Functor f) => f a -> f (a -> Ordering)
20:09:58 <geekosaur> it's not letting [] the nullary list constructor
20:09:58 <zereraz> merijn: even then shouldn't it be [Char] aswell
20:10:15 <geekosaur> the list syntactic sugar is odd
20:10:21 <merijn> zereraz: No, you're mapping a two argument function over a list, the result is a list of 1 argument functions
20:10:31 <merijn> :t map (+) [1..10]
20:10:32 <lambdabot> (Num a, Enum a) => [a -> a]
20:10:52 <merijn> :t map compare [1..10]
20:10:53 <lambdabot> (Ord a, Num a, Enum a) => [a -> Ordering]
20:10:56 <merijn> hmmm
20:11:06 <merijn> Maybe not the most helpful with those typeclasses :)
20:11:08 <zereraz> wow
20:11:16 <merijn> :t map compare ([1..10] :: [Int])
20:11:17 <geekosaur> oh, wait. no. that;s just a pattern match, because it was a constructor
20:11:17 <lambdabot> [Int -> Ordering]
20:11:29 <merijn> :t map
20:11:30 <lambdabot> (a -> b) -> [a] -> [b]
20:11:54 <zereraz> merijn: great, got it!!
20:12:03 <geekosaur> > let [a,b] = [1,2] in a -- jayunit100_4g, this is deconstructing a list by constructor, and using syntactic sugar.
20:12:04 <zereraz> merijn: list of functions!!
20:12:05 <lambdabot>  1
20:12:11 <merijn> zereraz: Remember the function arrow is right associative, so matching "compare :: Ord a => a -> a -> Ordering" with "a -> b" GHC infers that "b = a -> Ordering" :)
20:12:27 <geekosaur> I am not let-ing the list, I am telling it how to break the list up
20:12:33 <jayunit100_4g> so, "in a" -- what is a ?
20:12:43 <jayunit100_4g> thanks btw geekosaur for ratholing with me on this :)
20:12:49 <geekosaur> that is what I am trying to explain to you
20:13:15 <zereraz> merijn: so if I do this let a = fmap compare "Hi there"
20:13:26 <zereraz> merijn: fmap a "HI THERE"
20:13:27 <geekosaur> [a,b] there is a pattern. it means: whatever is on the right of = as ther pattern of a list with tweo elements. locally bind the first element to a and the second to b
20:13:31 <jayunit100_4g> ah ! That is the point of issue.  the right hand side of in  …. it seems like it can be anything…. with no consistent requirement.
20:13:39 <geekosaur> > let [a,b] = [5] in a
20:13:40 <zereraz> merijn: I get error
20:13:43 <lambdabot>  *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern [a, b]
20:13:59 <geekosaur> erp, did I just kill the bot, or just my network
20:14:09 <geekosaur> ah, there we go
20:14:28 <geekosaur> notice it says it couldn't match [a,b] pattern against [5]
20:14:57 <geekosaur> the "let ... in" is the normal form of a let. you are probably used to the one in ghci, which is a variant of the one in `do`, which is another form of syntactic sugar
20:15:24 * jayunit100_4g reading above statements…… initially, seems like a is superfulous, but havent read fully through chat above yet....
20:15:26 <geekosaur> `let a = 5; ...` in a `do` becomes `let a = 5 in do ...`
20:16:10 <geekosaur> the point is we can use patterns to deconstruct things like lists, or tuples, or more complex constructs created with constructors
20:16:18 <geekosaur> and then use those parts after `in`
20:16:31 <jayunit100_4g> OH !!!!
20:16:40 <geekosaur> instead of providing a procedure to take a list apart, we *describe* it
20:16:46 <geekosaur> which is a pattern
20:16:49 <jayunit100_4g> geekosaur: okay i see.  so the let binding happens FIRST
20:16:55 <geekosaur> yes
20:16:55 <jayunit100_4g> then the "a" is evaluated.
20:17:10 <jayunit100_4g> :) thats not so crazy after all  :)
20:17:21 <geekosaur> and then we can evaluate random stuff using the pieces we described
20:17:41 <jayunit100_4g> >  let [] = [1] ; in 2
20:17:44 <lambdabot>  2
20:17:51 <jayunit100_4g> so in this case, the [] = [1] is meaningless >
20:17:55 <jayunit100_4g> let [] = [1]
20:18:00 <jayunit100_4g> > let [] = [1]
20:18:02 <lambdabot>  not an expression: ‘let [] = [1]’
20:18:27 <jayunit100_4g> funny, my ghci allows either
20:18:43 <geekosaur> what's meaningless there is that lambdabot takes expressions, and "let [] = [1]" is a "statement" from a do block or ghci
20:18:58 <geekosaur> it is not the natural form of a `let`.
20:19:02 <merijn> ghci is weird
20:19:08 <geekosaur> in ghci it's pretty much a hack to let you bind things
20:19:11 <merijn> Don't take whatever it does for normal :)
20:19:13 <jayunit100_4g> ghci is sooo weird
20:19:20 <geekosaur> on do it's syntactic sugar to maintain the ullusion of being procedural
20:19:29 <jayunit100_4g> would you agree that ghci actually makes it harder to learn haskell sometimes?
20:19:42 <HeladoDeBrownie> At least marginally.
20:19:43 <geekosaur> > let [] = [1] in 0 -- pattern match fail, empty list pattern vs. length-1 list
20:19:45 <lambdabot>  0
20:19:55 <geekosaur> hm, is that lazy?
20:20:02 <jayunit100_4g> i prefer running programs with explicit syntax.  haskell's strenght is in its unified compiler and interprability.
20:20:12 <geekosaur> or am I just up too late?
20:20:13 <merijn> geekosaur: Of course it is
20:20:27 <geekosaur> anyway ghci does do things a lot differently from compiled haskell, yes
20:20:27 <merijn> geekosaur: Why would it ever force that pattern match?
20:20:33 <jayunit100_4g> yup, it just returns 0 and avoids looking at the other bs
20:20:36 <jayunit100_4g> makes sense
20:20:38 <geekosaur> and lambdabot does them still differently
20:20:55 <geekosaur> merijn, I tend to assume patterns are strict, I forget the rules where they aren't
20:21:43 <geekosaur> anyway that gives me a chance to mention that patterns can be lazy, not actually used to deconstruct a value unless you refer to something matched. you can force this by using ~ prefix
20:22:04 <geekosaur> I... think that `let` is normally lazy while top level bindings aren't?
20:22:32 <geekosaur> pattern matches are pretty much the only things that actually force strictness in most cases
20:22:44 <merijn> Well, yes
20:23:00 <merijn> In fact, they're the only thing that cause strictness in Core
20:23:05 <jayunit100_4g> ah okay
20:23:13 <jayunit100_4g> by strictness , you mean …..
20:23:20 <geekosaur> so I guess not having used the binding (or indeed being able to) and being in a `let`, it ignored the pattern
20:23:34 <geekosaur> since [] as a pattern gives us nothing to use.
20:23:43 <jayunit100_4g> yes. makes sense
20:23:45 <geekosaur> > let x@[] = [1] in x
20:23:48 <lambdabot>  *Exception: <interactive>:3:5-14: Irrefutable pattern failed for pattern x@[]
20:23:51 <merijn> jayunit100_4g: In Core (and to a first approximation in Haskell) evaluation *only* happens when it's forced to happen by pattern matching
20:24:09 <geekosaur> there, that gave me a "handle" to reference the matched thing, and forced the pattern match to happen
20:24:24 <geekosaur> at which point it noticed that a 1-element list does not match a 0-element pattern
20:25:07 <geekosaur> the x@ thing is an as-pattern, and lets us assign names to larger parts of patterns
20:25:30 <jayunit100_4g> merijn: so what i f i have no pattern matching in my code?
20:25:33 <geekosaur> name@(some other pattern that can do its own bindings, and even include more as-patterns)
20:25:35 <jayunit100_4g> (or is that impossible )
20:25:40 <nshepperd_> > let x@[] = [1] in 2
20:25:42 <lambdabot>  2
20:26:03 <geekosaur> you didn't use the x so it still didn't actually do the pattern match
20:26:16 <geekosaur> jayunit100_4g, it is possible but you can't generally do much
20:26:18 <jayunit100_4g> is the statement "  3 " doing any pattern matching ?
20:26:23 <jayunit100_4g> > 3
20:26:25 <lambdabot>  3
20:26:32 <jayunit100_4g> -- no pattern matching there ^ ?
20:26:40 <jayunit100_4g> but certainly, evaluation is occuring.
20:26:46 <geekosaur> main = putStrLn "hello world" -- look ma, no pattern matching. but not very useful
20:26:54 * jayunit100_4g feigning ignorance for pedagogical purposes
20:27:02 <geekosaur> (can't feed that to lambdabot, since it's not an expression and the bot doesn't do IO)
20:27:12 <merijn> jayunit100_4g: Well, if your code has no pattern matches it can't do anything, so it's a no-op
20:27:21 <jayunit100_4g> > 3
20:27:22 <lambdabot>  3
20:27:34 <jayunit100_4g> ^^ certainly thats an operation, isnt it ?  its evaluated, and returned,
20:27:44 <jayunit100_4g> and there is no pattern matching there ?
20:27:44 <nshepperd_> the show instance of 3 does do pattern matching
20:27:46 <geekosaur> the bot is actually doing a pattern match internally to get the value, but it's part of the bot machinery
20:27:48 <nshepperd_> and putStrLn
20:27:51 <jayunit100_4g> AH okay !
20:27:52 <jayunit100_4g> thanks 1
20:27:59 <nshepperd_> how else would it know what to print
20:41:18 <piss-christ> what are haskell packages called?
20:41:34 <piss-christ> Just "packages" ?
20:42:41 <HeladoDeBrownie> Yes, Haskell packages are a thing, usually spoken of in context of cabal-install.
20:42:48 <HeladoDeBrownie> Or Hackage.
20:42:53 * hackagebot stable-tree 0.5.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.5.0 (tsuraan)
20:43:16 <zereraz> hello, can someone please explain this, pure (+3) <*> Just 9 . How does pure know that it needs to use the Maybe instance of applicative functor. Is it because haskell saw the right side?
20:43:35 <zereraz> type inference?
20:43:50 <HeladoDeBrownie> zereraz, sure, it knows that Just is a constructor of Maybe so when it unifies the types it comes up with that
20:44:02 <jle`> zereraz: yeah, we play the unficiation game
20:44:12 <jle`> :t (<*>)
20:44:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:44:15 <jle`> :t pure
20:44:16 <lambdabot> Applicative f => a -> f a
20:44:18 <jle`> :t (Just 9)
20:44:19 <lambdabot> Num a => Maybe a
20:44:22 <jle`> :t (+3)
20:44:23 <lambdabot> Num a => a -> a
20:44:47 <jle`> plug everything you solve, and the "most general solution" to all of them is what haskell infers
20:45:09 <jle`> note that this is all done at compile-time...haskell literally just compiles the same thing as the Just construct or there
20:45:24 <zereraz> haskell is amazing
20:45:35 <zereraz> thanks guys
20:47:03 <jle`> thank Hindley and Milner!
20:47:16 <jle`> and Damas
20:48:01 <zereraz> haskell has strong roots
20:48:22 <CrazyM4n> It is complete
20:48:28 <CrazyM4n> I have installed ubuntu
20:48:33 <CrazyM4n> Formatted all my files
20:48:41 <CrazyM4n> But you know what?
20:48:46 <CrazyM4n> Haskell works
20:48:54 <CrazyM4n> So I'm happy
20:49:37 <jle`> :)
20:49:56 <CrazyM4n> jle`: The things I do for gloss-raster
20:49:57 <CrazyM4n> :P
20:51:10 <CrazyM4n> No
20:51:15 <CrazyM4n> Please, don't to this to me LLVM
20:51:17 <CrazyM4n> NO
20:51:32 <CrazyM4n> I went through all this trouble... and haskell still couldn't find LLVM
20:52:06 <jle`> ;_;
20:52:31 <CrazyM4n> I... I fixed it!
20:52:32 <CrazyM4n> :D
20:52:35 <jle`> :D
20:54:01 <CrazyM4n> Here goes nothing
20:56:04 <CrazyM4n> Of course, haskell decides to not find the gloss-raster package
20:56:06 <CrazyM4n> What do I do now?
20:56:27 <HeladoDeBrownie> Did you `cabal update`? `cabal install gloss-raster`?
20:56:33 <CrazyM4n> Yes and yes
20:56:41 <CrazyM4n> I can give a paste of the outputs
20:56:44 <HeladoDeBrownie> Do
20:58:16 <CrazyM4n> HeladoDeBrownie: http://lpaste.net/5169034857753346048
20:59:02 <HeladoDeBrownie> Haven't the faintest, although the reinstall makes me nervous. Have you tried in a sandbox?
21:00:34 <CrazyM4n> HeladoDeBrownie: The reinstall was just to show where it was being installed
21:00:38 <CrazyM4n> How do I do it in a sandbox?
21:01:22 <roboguy_> CrazyM4n: I'm not sure you can just import Graphics.Gloss.Raster
21:01:30 <BMeph> CrazyM4n: Would you, could you, in a sandbox? Would you, could you, with a red fox? ;þ
21:01:31 <roboguy_> you might need to import one of the submodules
21:01:35 <CrazyM4n> lol
21:01:42 <CrazyM4n> and let me look at some examples
21:02:07 <jle`> cabal sandbox init
21:02:12 <jle`> to start a standbox
21:02:14 <roboguy_> I don't see a module that would correspond to Graphics.Gloss.Raster
21:02:22 <jle`> i think you might have to cabal init first
21:02:26 <CrazyM4n> roboguy_: gloss-raster
21:02:38 <HeladoDeBrownie> You can `cabal sandbox init` without `cabal init`, though you'll often want to do the latter anyway
21:03:13 <HeladoDeBrownie> I think roboguy_'s onto the problem though
21:03:15 <CrazyM4n> Aha, it's import Graphics.Gloss.Raster.Array
21:03:17 <roboguy_> CrazyM4n: no, I mean that package would need a file named Graphics/Gloss/Raster.hs in order to just import Graphics.Gloss.Raster and I don't see one. You might need to import one of the submodules (Graphics.Gloss.Raster.Array or Graphics.Gloss.Raster.Field)
21:03:22 <CrazyM4n> Thanks roboguy_!
21:03:27 <roboguy_> np!
21:03:36 <CrazyM4n> :D
21:04:17 <CrazyM4n> How do you not import something from a module?
21:04:32 <CrazyM4n> I don't want System.Console.ANSI.Color, but I want everything else
21:05:12 <roboguy_> CrazyM4n: import System.Console.ANSI.Color hiding (...)
21:05:37 <CrazyM4n> You're the best man!
21:06:20 <jle`> am i invited to the wedding too?
21:06:26 <roboguy_> haha
21:06:32 <CrazyM4n> lol
21:07:20 <CrazyM4n> And even better, league of legends just finished installing!
21:07:22 <CrazyM4n> This is great!
21:07:35 <CrazyM4n> I'm so hyped right now!
21:08:45 <CrazyM4n> I've never used so many exclamation marks in my life! This must be special!
21:10:32 <cellopin> okay so I'm in an haskell interpreter ran in emacs.. I'm trying x::Integer then It says x not in scope
21:10:49 <cellopin> what does this mean?
21:11:10 <hiptobecubic> "x :: Integer" is saying "the variable 'x', as an integer"
21:11:15 <hiptobecubic> but there is no variable 'x' defined
21:11:20 <hiptobecubic> so it shits the bed
21:11:50 <hiptobecubic> Which is sailor talk for compiler errors
21:12:30 <coiler3> shits the bed, my new favorite term
21:12:52 <cellopin> okay I'm defining it as x =1 but parse error on input `=`
21:13:02 <CrazyM4n> Related: http://xkcd.com/371/
21:13:09 <coiler3> try ' let x = 1 '
21:13:13 <hiptobecubic> cellopin, that's an unfortunate consequence of ghci doing everything in the IO modan
21:13:19 <hiptobecubic> monad, rather
21:13:30 <jle`> really?
21:14:22 <cellopin> oh so `let` is the keyword to declare variables?
21:14:31 <CrazyM4n> Only in ghci
21:15:16 <modan> well... no
21:16:33 <modan> it's kind of terrible to explain if you don't know anything else about haskell, but basically ghci runs in a special context which looks like the top level of a program, but isn't. As a result you can't just declare things, you have to use let
21:16:47 <jle`> i'm not sure if that's necessary
21:16:53 <jle`> you can just say it's a ghci keyword
21:17:10 <modan> it's not though?
21:17:19 <CrazyM4n> ghci runs as if you're in main, and you can't declare variables inside of functions
21:17:22 <jle`> ghci has special syntax
21:17:27 <CrazyM4n> without let of course
21:17:28 <jle`> it doesn't act as if you're in main
21:17:32 <CrazyM4n> erll
21:17:34 <CrazyM4n> well
21:17:37 <coiler3> so, I'm using "import Control.Monad.Writer  " but it seems it won't let me use its constructor?
21:17:37 <CrazyM4n> it acts similarly
21:17:37 <jle`> and it doesn't actually act if you're in an IO monad
21:17:43 <CrazyM4n> really?
21:17:57 <jle`> it doesn't act similarly enough to really warrant making a comparison to a new haskell user :P
21:18:03 <modan> sure it does
21:18:29 <cellopin> so my first goal for today is to compile and run a script outside the interpreter..
21:18:31 <merijn> coiler3: You probably want to use Control.Monad.Trans.Writer
21:18:31 <jle`> coiler3: try `writer`
21:18:40 <nshepperd_> IO monad doesn't let you write "1 + 2" on a line by itself
21:18:41 <modan> Prelude System.Random> randomIO -293176676066375592
21:18:43 <modan> it :: Integer
21:18:48 <merijn> coiler3: And if you're reading LYAH, the "Writer" constructor no longer exists, use "writer" instead
21:18:55 <coiler3> hmm
21:18:56 <modan> that's missing a newline break
21:18:57 <jle`> it treats some lines as if it's inside an IO monad...some lines as if it isn't
21:19:03 <jle`> so...
21:19:12 <jle`> i think it's ad-hoc enough to say that it's its own syntax
21:19:14 <modan> it's a little crazy i guess
21:19:41 <CrazyM4n> GHCi is weird and not to be trusted
21:19:43 <CrazyM4n> That's the moral here
21:19:53 <jle`> it's to be trusted...it makes perfect sense...
21:19:56 <jle`> it just has its own syntax
21:19:59 <jle`> that isn't too hard to understand :)
21:20:08 <CrazyM4n> Well no point in complicating things :P
21:20:09 <coiler3> I thought constructors are supposed to start with a capital letter?
21:20:13 <mgsloan> Well, other than allowing some top level declarations, it really is like do notation.  The extra bits are just writing a bit of boilerplate based on the types
21:20:21 <CrazyM4n> How do you turn on dark mode on webchat.freenode.net
21:20:22 <CrazyM4n> ?
21:20:25 <jle`> no need to complicate it by bringing in "monad do block" and fancy stuff like that...
21:20:28 <merijn> coiler3: correct, writer is not a constructor
21:20:49 <mgsloan> Well, ghci does allow you to do "x <- readLn :: IO Int"
21:20:59 <jle`> well.  some lines act like IO.  some lines don't
21:21:08 <mgsloan> Right, but its not syntax directed, its type directed
21:21:09 <CrazyM4n> I'm gonna go get like a terminal IRC client
21:21:10 <coiler3> so its a factory method for making WriterMonad?
21:21:19 <coiler3> MonadWriter*
21:21:21 <modan> CrazyM4n, weechat
21:21:28 <merijn> coiler3: Basically, in the time since LYAH was written, it was realised that the Writer monad and the WriterT monad transformer could be unified into a single type. So "Writer" actually no longer exists and is just a type synonym for the WriterT transformer specialised to Identity
21:21:29 <mgsloan> so it isn't a special syntax, it's the types determining some extra convenience boilerplate
21:21:45 <jle`> i'm not sure what you mean
21:21:51 <mgsloan> Now, the fact that you can write "import" or "data", that's rather special
21:21:55 <jle`> how do you explain things like "data ...", "type ..", "import ..."
21:21:56 <jle`> and :t
21:21:59 <jle`> etc.
21:22:03 <jle`> :browse
21:22:04 <merijn> coiler3: No and "MonadWriter" is overcomplicated nonsense from mtl. When you are just starting out you'll want to stick to transformers and use "import Control.Monad.Trans.Writer"
21:22:16 <mgsloan> Well, sure ":" prefixed things are special
21:22:17 <merijn> coiler3: That way you avoid all the "MonadWriter" complication
21:22:22 <jle`> mgsloan: exactly...
21:22:26 <jle`> ghci is its own special environment
21:22:43 <CrazyM4n> brb
21:22:56 <mgsloan> true true, especially if you go :{ multiline }:
21:22:58 <mgsloan> blech
21:23:01 <coiler3> someone should update LYAH :)
21:23:20 <merijn> coiler3: The types from that module are much simpler and straightforward than Control.Monad.Writer
21:23:21 <jle`> i think...to a new hasell user...saying "let here acts like a ghci keyword" is both accurate and sufficient and simple enough
21:23:44 <CrazyM4n> XChat is nice
21:23:54 <merijn> coiler3: http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Writer-Lazy.html
21:23:55 <mgsloan> Fair 'nough! It took me a long time to realize that it was due to do notation, though
21:24:03 <mgsloan> always seemed rather arbitrary till I realized that
21:24:18 <mgsloan> It still is rather arbitrary, now that other top level declarations are allowed
21:24:23 <mgsloan> but ohwell
21:24:26 <coiler3> @undo
21:24:26 <lambdabot> Error: expected a Haskell expression or declaration
21:25:06 <merijn> coiler3: Basically, "writer" is a function that mimics the behaviour of the old "Writer" constructor, so replacing that in the LYAH examples they should still work
21:25:16 <coiler3> thanks merijn
21:25:29 <coiler3> > logNumber x = Writer (x, ["Got number: " ++ show x])
21:25:30 <lambdabot>  <hint>:1:13: parse error on input ‘=’
21:25:36 <coiler3> > let logNumber x = Writer (x, ["Got number: " ++ show x])
21:25:38 <lambdabot>  not an expression: ‘let logNumber x = Writer (x, ["Got number: " ++ show x])’
21:25:50 <coiler3> guess you can't define functions :o
21:25:54 <merijn> > let logNumber x = writer (x, ["Got number: " ++ show x])
21:25:55 <lambdabot>  not an expression: ‘let logNumber x = writer (x, ["Got number: " ++ show x])’
21:25:57 <merijn> eh
21:26:02 <merijn> > let logNumber x = writer (x, ["Got number: " ++ show x]) in logNumber 5
21:26:04 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
21:26:04 <lambdabot>    arising from a use of ‘M62314867157864135625837.show_M62314867157864135625...
21:26:04 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
21:26:04 <lambdabot>  Note: there are several potential instances:
21:26:04 <lambdabot>    instance [safe] GHC.Show.Show a =>
21:26:08 <merijn> oh, blah
21:26:15 <jle`> you can ;)  but ghci is a much better place to play around than #haskell :)  lots more toys
21:26:22 <merijn> > let logNumber x = writer (x, ["Got number: " ++ show x]) in runWriter $ logNumber 5
21:26:23 <lambdabot>  (5,["Got number: 5"])
21:26:28 <merijn> There we go :)
21:26:31 <coiler3> didn't mean to play here, just wanted to use @undo :)
21:26:48 <jle`> ah, yeah
21:26:53 <jle`> i guess lambdabot has some fun toys too
21:27:10 <jle`> you can always /q lambdabot to play around as much as you want
21:27:24 <coiler3> good idea
21:28:56 <CrazyM4n> Want to know why my script was erroring?
21:29:06 <CrazyM4n> (InWindow "Game of Life" (640, 480), (0, 0)) I wrote
21:31:00 <CrazyM4n> So I'm getting an instance error that I don't quite understand
21:31:04 <CrazyM4n> I'm going to uplod a paste
21:32:30 <CrazyM4n> http://lpaste.net/2515072457002450944 and http://lpaste.net/2381696937729458176
21:32:36 <CrazyM4n> I'm haskelling late again...
21:32:59 <CrazyM4n> Color is from Graphics.Gloss
21:34:11 <Taneb> CrazyM4n, repa doesn't know how to put a Color in an unboxed array
21:34:29 <CrazyM4n> Taneb: Then how can I tell it how?
21:34:48 <zereraz> hello, 1 more doubt , in (++)<$>getLine<*>getLine
21:35:03 <zereraz> first the <$> is done
21:35:06 <Taneb> CrazyM4n, I don't know, I don't think you can
21:35:18 <zereraz> fmap (++) getLine <*> getLine
21:35:29 <CrazyM4n> Taneb: http://hackage.haskell.org/package/gloss-raster-1.8.1.2/docs/Graphics-Gloss-Raster-Array.html#v:animateArray
21:35:41 <zereraz> fmap (++) "myString" <*> getLine?
21:36:33 <zereraz> am I correct so far?
21:36:57 <Taneb> CrazyM4n, you're going via unboxed rather than straight to delayed
21:37:03 <merijn> zereraz: nope, doesn't type check
21:37:06 <dmj`> @typ \str -> fmap (++) str <*> getLine
21:37:07 <lambdabot> IO [Char] -> IO [Char]
21:37:13 <CrazyM4n> Taneb: Yes, because I don't know how to do otherwise, sorry :c
21:37:26 <merijn> zereraz: fmap over string uses the list functor, getLine uses IO
21:37:30 <merijn> :t fmap
21:37:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:37:32 <zereraz> yeah
21:37:34 <merijn> :t fmap (++)
21:37:35 <lambdabot> Functor f => f [a] -> f ([a] -> [a])
21:37:39 <zereraz> so It can't use both?
21:37:41 <merijn> :t fmap (++) "test"
21:37:42 <Taneb> CrazyM4n, probably with fromFunction
21:37:42 <lambdabot>     Couldn't match type ‘Char’ with ‘[a]’
21:37:42 <lambdabot>     Expected type: [[a]]
21:37:42 <lambdabot>       Actual type: [Char]
21:37:54 <merijn> zereraz: Actually, double type error
21:38:01 <merijn> zereraz: You can't use ++ on Char either :)
21:38:08 <merijn> :t fmap (++) getLine
21:38:09 <lambdabot> IO ([Char] -> [Char])
21:38:21 <merijn> :t (fmap (++) getLine <*>)
21:38:22 <lambdabot> IO [Char] -> IO [Char]
21:38:25 <Taneb> CrazyM4n, http://hackage.haskell.org/package/repa-3.3.1.2/docs/Data-Array-Repa.html#v:fromFunction
21:38:42 <Taneb> (disclaimer, I've had little experience with repa)
21:38:56 <zereraz> so always IO
21:38:58 <CrazyM4n> Uh, ok
21:39:17 <zereraz> fmap (++) IO String <*> IO String
21:39:19 <zereraz> ?
21:39:57 <jle`> :t (++) <$> getLine <*> getLine
21:39:58 <lambdabot> IO [Char]
21:40:01 <merijn> zereraz: Not "always IO", but "always the same Applicative on both sides
21:40:20 <zereraz> merijn: because of getLine it will be IO right?
21:40:24 <merijn> > (+) <$> Just 1 <*> Just 2 -- works, both Maybe
21:40:26 <lambdabot>  Just 3
21:40:34 <merijn> zereraz: Yes, in case of getLine it will always be IO
21:40:41 <zereraz> merijn: yeah I understand
21:40:45 <zereraz> thanks
21:43:20 <zereraz> how do I see the applicative instance IO here
21:43:26 <zereraz> the internal structure
21:43:57 <zereraz> like the command for lambdabot
21:44:46 <jle`> the internal sturcture of the IO data type is abstracted away for performance reasons ;_;
21:44:56 <jle`> however, you can inspect it by using a wrapper around the type
21:45:20 <jle`> er, you can inspect what using Applicative/Monad/Fmap stuff does, using a wrapper
21:46:05 <zereraz> inside irc
21:46:40 <jle`> do you mean you want to see the definition of the Applicative instance?
21:47:15 <zereraz> jle`: yes
21:47:26 <zereraz> jle`: for IO
21:47:51 <zereraz> instance Applicative IO where
21:50:02 <CrazyM4n> Is there a "safe" !! that returns Nothing if it is out of bounds?
21:50:12 <jle`> ah.  well, there wouldn't be a meaningful one...the structure of the IO data type is specially abstracted away for performance reasons.
21:51:08 <zereraz> ok
21:51:31 <jle`> i think the best we can do is describe what it does, semantically
21:51:51 <nshepperd_> wouldn't such things be built into the compiler
21:52:20 <jle`> (<*>) takes an IO action producing a function and an IO action producing a value, and gives you a new IO action that executes both and returns the first applied to the second
21:52:31 <jle`> *the result of the first applied to the result of the second
21:52:50 <nshepperd_> I mean "structure of IO"
21:53:26 <pointed_set> :t noDuplicate
21:53:27 <lambdabot> Not in scope: ‘noDuplicate’
21:54:41 <nshepperd_> (<*>) executes its first argument first, too
21:54:46 <jle`> ah, yes
21:55:23 <zereraz> (->) r is a type constructor right
21:55:25 <zereraz> not a function
21:57:39 <merijn> CrazyM4n: You can use drop + listToMaybe for that
21:57:42 <CrazyM4n> Anyone know how to end an unresponsive wine application when it's not actually in a process?
21:57:53 <CrazyM4n> And merijn: I fixxed it so I didn't need to do that
21:58:27 <merijn> > let safeIdx x = listToMaybe . drop x in (safeIdx 2 [1,2,3,4], safeIdx 10 [1,2,3,4])
21:58:29 <lambdabot>  (Just 3,Nothing)
21:59:16 <merijn> zereraz: The Applicative instance for IO is...not very enlightening for beginners :)
21:59:51 <merijn> zereraz: IO is implemented using a lower level compiler built-in type and seeing how it's implemented is more likely to make you *more* rather than *less* confused
22:00:07 <zereraz> merijn: but I kind of understood it
22:00:22 <jle`> the actual built in applicative instance definition is probably not even enlightening for advance-rs.  it's probably only useful for people who want to implement haskell or GHC :P
22:00:32 <jle`> but the Applicative instance...the idea of it...is probably enlightening
22:00:34 <merijn> jle`: It's not *that* hard
22:00:36 <jle`> the semantics, at least
22:00:40 <zereraz> I am at functions as applicatives
22:00:42 <jle`> merijn: not hard, but not useful
22:00:44 <zereraz> in lyah
22:01:07 <dmj`> @typ (,) <$> getLine <*> getLine
22:01:08 <lambdabot> IO (String, String)
22:03:36 <CrazyM4n> @hoogle Int -> Float
22:03:39 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
22:03:39 <lambdabot> Prelude (!!) :: [a] -> Int -> a
22:03:39 <lambdabot> Data.List (!!) :: [a] -> Int -> a
22:03:55 <CrazyM4n> Uh, how would I do that?
22:04:09 <jle`> :t fromIntegral
22:04:10 <lambdabot> (Num b, Integral a) => a -> b
22:04:21 <CrazyM4n> > fromIntegral 3 :: Float
22:04:23 <lambdabot>  3.0
22:04:25 <CrazyM4n> Ahhh
22:04:26 <jle`> incidentally, Int is an Integral
22:04:29 <jle`> and Float is a Num
22:04:46 <jle`> :t unround
22:04:47 <lambdabot>     Not in scope: ‘unround’
22:04:47 <lambdabot>     Perhaps you meant ‘round’ (imported from Prelude)
22:04:52 <jle`> heh
22:05:01 <jle`> :t round
22:05:02 <lambdabot> (RealFrac a, Integral b) => a -> b
22:05:24 <jle`> let unround = invert round
22:05:44 <jle`> > unround 3 :: Float
22:05:46 <lambdabot>  3.0
22:06:26 <jle`> > round (3.0) :: Int
22:06:28 <lambdabot>  3
22:07:47 <CrazyM4n> OH BABY
22:07:49 <CrazyM4n> IT WORKS
22:08:08 <CrazyM4n> If you call 0.1 FPS working
22:10:23 <CrazyM4n> It eats 100% of my CPU and hangs
22:10:30 <CrazyM4n> I made a mistake, and I don't know where
22:10:44 <CrazyM4n> http://lpaste.net/260917987626713088
22:15:05 <CrazyM4n> Any ideas?
22:40:40 <Arahael> Hey, I'm trying to write a function that: Given a CI ByteString, converts it to Text; and Given a ByteString, also converts it to Text.
22:40:49 <roboguy_> CrazyM4n: did you profile it?
22:40:59 <CrazyM4n> roboguy_ How?
22:41:06 <Arahael> I'm not sure how to do this, I'm thinking that I need to have two signatures (ie, effectively overload the function)?
22:41:41 <roboguy_> CrazyM4n: compile with -prof -auto-all and when you run it, give your program the option +RTS -pa
22:41:54 <jle`> Arahael: there is a way, but needing to do something like this is usually a good red flag of an antipattern
22:42:22 <Arahael> jle`: Could you elaborate?
22:42:43 <jle`> the preferred solution is to just have two different functions that do either
22:43:13 <Arahael> jle`: Fair enough - but why is it an anitpattern?
22:43:34 <jle`> the simplest solution to overload a function like that is with a typeclass
22:44:01 <Arahael> Fair enough.
22:44:03 <jle`> but introducing a new typeclass is...very recommended against
22:44:05 <jle`> um
22:44:10 <jle`> i guess i didn't answer your question at all
22:44:12 <jle`> huh
22:44:26 <CrazyM4n> jle`: You know how to profile stuff, right?
22:44:30 <CrazyM4n> The other guy hasn't answered
22:44:37 <jle`> i know woefully little
22:44:52 <roboguy_> CrazyM4n: I thought I did...
22:45:01 <jle`> trust me, i read most of the messages here...if i had the ability to help, i usually try :)
22:45:03 <CrazyM4n> Oh... I didn't see
22:45:04 <CrazyM4n> Sorry
22:45:07 <Arahael> jle`: You kind of have, although now i wnat to know why introducing a new typeclass is not recommended.
22:45:15 <CrazyM4n> My bad roboguy_:
22:45:18 <roboguy_> np
22:45:32 <Arahael> jle`: My haskell is _very_ basic though, I'm actually currently working out how to do CI a -> Text in the first place.
22:45:59 <CrazyM4n> Of course
22:46:03 <CrazyM4n> Could not find module prelude
22:46:49 <roboguy_> ohh, maybe you don't have profiling libraries installed
22:46:53 <Arahael> jle`: (CI ByteString -> Text worked, but not CI a -> Text; I am not sure why)
22:47:13 <CrazyM4n> Evidently not
22:47:33 <dmj`> Arahael: how do you go from a -> Text w/o a Show constraint?
22:48:19 <Arahael> dmj`: I was expecting that the compiler could infer that I'm using it with ByteStrings only?
22:48:35 <jle`> ah.
22:48:40 <CrazyM4n> roboguy_: Do you see anywhere in that code where it's obvious that I screwed up though?
22:48:51 <jle`> a type signature of CI a -> Text is actually "forall a. CI a -> Text"
22:49:13 <jle`> what it says is, "this function can take a CI a with *any* a, and give you a Text"
22:50:09 <CrazyM4n> http://lpaste.net/260917987626713088 for the code btw
22:51:02 <Arahael> jle`: It's working the opposite way to what I thought it was. :)
22:51:12 <Arahael> (And more logical, too, come to think about it)
22:51:42 <jle`> this does trip a lot of people up at first...myself as well
22:51:44 <Arahael> So now I have two functions: decodeBS, and decodeCI.
22:51:46 <jle`> *it tripped me up as well
22:51:59 <Arahael> jle`: Glad to see I'm not the only one. :)
22:52:25 <Arahael> I'm wondering how I should make a function decode that could handle ByteStrings, or CI ByteStrings.
22:53:14 <Arahael> Btw, they return a Maybe Text now, not just Text.
22:53:42 <roboguy_> CrazyM4n: hmm, I'm afraid not off the top of my head
22:53:59 <CrazyM4n> roboguy_: Hmm. I'll look at it more, maybe try to get profiling  set up
22:55:18 <roboguy_> CrazyM4n: it's actually too unresponsive on my computer for it to profile. all it looks like it does is say "Test: Prelude.(!!): index too large" and then use up CPU
22:55:32 <CrazyM4n> I know why it has that error
22:55:52 <CrazyM4n> Line 70
22:55:56 <CrazyM4n> x and y are swapped
22:57:45 <jle`> Arahael: the short answer is that typeclasses are a pretty powerful language feature that, without discpline, is easily abused to create overly complicated APIs that make code difficult to reason with...also, typeclasses are not first-class members of the language.
22:59:00 <Arahael> jle`: That just argues that they should be understood?
22:59:09 <Arahael> jle`: How do they produce overly complicated API's?
22:59:26 <CrazyM4n> roboguy_: I'm out of ideas
22:59:33 <CrazyM4n> If you change the main to the commented out bit
22:59:35 <CrazyM4n> It works fine
22:59:43 <CrazyM4n> So we can narrow it down to a couple functions
23:00:01 <pjdelport> Arahael: Like many tools, type classes can both simplify or complicate APIs. It depends a great deal on the case.
23:00:15 <jle`> Arahael: that argues that typeclasses are a crazy powerful feature that can potentially undo a lot of what makes haskell great in the first place
23:00:27 <pjdelport> Using type classes prematurely can be a mistake.
23:00:34 <Arahael> jle`: Actually I couldn't understand that statement there.
23:00:48 <Arahael> pjdelport: I'm crashing in Haskell by writing a snapframework-powered site.
23:00:54 <pjdelport> OTOH, using them for certain thing can be amazingly effective.
23:00:59 <Arahael> brb
23:01:26 <pjdelport> The trick is to know when they're the solution. :)
23:07:14 <pjdelport> Arahael: A rule of thumb for introducing a type class is that it should capture some common abstraction that can be relatively well-defined in a way that isn't tied to a particular concrete type.
23:08:10 <pjdelport> Arahael: So, given your function, ask yourself: would it make sense to implement the type class methods for types other than CI ByteString and ByteString?
23:08:22 <roboguy_> CrazyM4n: oh, when I swapped the x and y I can profile it
23:08:36 <CrazyM4n> roboguy_: That's what I tried to say :P
23:08:38 <CrazyM4n> Sorry
23:08:41 <roboguy_> the garbage collector is taking up the most time at 68%
23:08:51 <pjdelport> And can you describe what the method does in the abstract, without reference to those types specifically?
23:09:00 <roboguy_> with populationMap.addGrids in a distant second at 12.1% time
23:09:00 <CrazyM4n> roboguy_: What is invoking the garbage collection?
23:09:20 <pjdelport> Can you state any useful laws that all implementations of the method must obey?
23:09:38 <pjdelport> Can you think of other methods that would go along with the type class?
23:11:16 <pjdelport> Would client code benefit, and become simpler, if they could use those type class methods, instead of just using plain type-specific or fully polymorphic functions?
23:11:46 <pjdelport> Arahael: If you can answer all those questions, then a type class might be appropriate.
23:11:50 <CrazyM4n> roboguy_: addGrids isn't troublesome, as if you run it in ASCII mode, you'll see it's completely smooth
23:12:29 <CrazyM4n> I'm getting the feeling it's the iterate line
23:12:41 <CrazyM4n> That's just been my creeping suspicion
23:12:45 <roboguy_> CrazyM4n: there's probably a memory leak in that part of the code
23:12:58 <pjdelport> Arahael: A useful exercise is to try and answer all the above questions for the type classes in the Prelude and base libraries, by the way. That helps you see why they are there, and what benefit they bring.
23:13:01 <CrazyM4n> Well lets find out where, we can isolate it
23:18:45 <roboguy_> CrazyM4n: one thing I notice is that n stays at the same value for long periods of time. I'm not sure if it's supposed to
23:19:54 <roboguy_> CrazyM4n: you can see it list the values if you import Debug.Trace and change applyNTimes to applyNTimes n = traceShow n $ (iterate (lifeIteration) grid) !! (floor n)
23:20:00 <CrazyM4n> roboguy_: n, in iterateGridXTimes, is supposed to be the amount of time since the start
23:20:21 <CrazyM4n> import Graphics.Gloss.Raster.Field
23:20:24 <CrazyM4n> err
23:20:28 <CrazyM4n> http://hackage.haskell.org/package/gloss-raster-1.8.1.2/docs/Graphics-Gloss-Raster-Field.html#v:animateField
23:33:01 * hackagebot ctkl 0.27.0.0 - packaging of Manuel Chakravarty's CTK Light for Hackage  http://hackage.haskell.org/package/ctkl-0.27.0.0 (MarkWotton)
23:38:32 <roboguy_> @tell CrazyM4n One of the major problems is that you are recalculating xLength and yLength each time. If you replace them with 19 and 20 respectively you get a noticeable speed up. It's still laggy but it helps
23:38:32 <lambdabot> Consider it noted.
23:58:03 * hackagebot xml-push 0.0.0.17 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.17 (YoshikuniJujo)
