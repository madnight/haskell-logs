00:15:00 <bakibour> Greetings
00:16:04 <bakibour> Is there any project written in Haskell that builds a software rasterizer or even better implements a software rasterizer on the GPU, like cuda raster, voxelpipe or Piko?
00:18:58 <joehillen> bakibour: try https://www.reddit.com/r/haskellgamedev
00:20:13 <bakibour> joehillen: https://research.nvidia.com/publication/voxelpipe-programmable-pipeline-3d-voxelization  ,  https://code.google.com/p/cudaraster/
00:20:25 <bakibour> Not sure if games head in this direction at all.
00:20:43 <bakibour> I would like to have more freedom for raster stages etc.
00:21:17 <bakibour> This is what i would be especially interested in http://arxiv-web3.library.cornell.edu/pdf/1404.6293.pdf
01:05:08 * hackagebot jsonresume 0.1.0.0 - Parser and datatypes for the JSON Resume format  http://hackage.haskell.org/package/jsonresume-0.1.0.0 (DanielWright)
01:15:08 * hackagebot jsonresume 0.1.0.1 - Parser and datatypes for the JSON Resume format  http://hackage.haskell.org/package/jsonresume-0.1.0.1 (DanielWright)
02:05:11 * hackagebot snaplet-mysql-simple 0.2.1.0 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.2.1.0 (ibotty)
02:22:09 <Athas> Does anyone have examples of working with vectors that encode their size in the type, GADT-style?
02:22:57 <Qfwfq> Athas: See the 'sized-vector' package.
02:23:28 <Athas> Thanks.
02:24:41 <Qfwfq> Athas: The Ordinal/Index tricks are especially neat.
02:41:25 <zereraz> is there any good resource to read more about functors?
02:41:29 <zereraz> apart from lyah
02:42:33 <dfeuer_> zereraz: there isn't much to say about functors in Haskell.
02:42:49 <zereraz> dfeuer_: I don't know why I keep getting confused about it
02:43:00 <Qfwfq> zereraz: You might be overthinking it. What're you struggling with?
02:43:00 <zereraz> dfeuer_: sometimes I think I get it
02:43:37 <zereraz> :t fmap
02:43:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:43:46 <zereraz> f is a type constructor
02:43:59 <zereraz> (a->b) is a function
02:44:10 <dfeuer_> zereraz: don't worry so much about the Functor. Focus on its fmap.
02:44:15 <zereraz> fmap (*3) (+100) 1
02:44:29 <zereraz> I got confused again with this part
02:44:39 <zereraz> I understand that here fmap become composition
02:44:51 <zereraz> but what is f and what is (a->b)
02:45:09 <Qfwfq> ((->)r) is f
02:45:12 <dfeuer_> @type fmap (*3) (+100)
02:45:13 <lambdabot> Num a => a -> a
02:45:35 <zereraz> and (*3) (+100) is the (a->b) ?
02:45:41 <Qfwfq> (a -> b) is (r -> a) -> (r -> b)
02:45:53 <zereraz> -> Int Int ?
02:45:56 <zereraz> in this case
02:46:04 <Qfwfq> Int has kind *.
02:46:23 <zereraz> I need to re read the kind part
02:46:52 <zereraz> Qfwfq: I am so confused
02:47:28 <zereraz> (r->a) should be f a
02:48:17 <Qfwfq> (r -> a) ~ ((->) r) a -> f a
02:48:22 <Qfwfq> (r -> a) ~ ((->) r) a ~ f a
02:49:09 <zereraz> :t fmap
02:49:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:49:14 <Qfwfq> afk caffeine
02:49:26 <zereraz> Functor f
02:49:30 <zereraz> takes a function
02:49:34 <zereraz> a -> b
02:49:39 <zereraz> ?
02:49:54 <zereraz> then f a and returns f b
02:50:19 <doismellburning> zereraz: no, fmap takes a function of type (a -> b) then an `f a` where f is a Functor instance and returns `f b`
02:50:56 <doismellburning> zereraz: that `Functor f =>` bit means "f is a functor instance"
02:51:01 <zereraz> and (*3) (+100) is the (a->b) ?
02:51:46 <zereraz> what does f a mean
02:51:53 <zereraz> what does the instance do with a
02:52:01 <zereraz> converts to b?
02:52:20 <dfeuer_> zereraz: you might find it easier to think about newtype Reader r a = Reader (r -> a)
02:52:35 <doismellburning> zereraz: consider Maybe
02:53:00 <doismellburning> zereraz: specifically the (type? kind? thingy?) Maybe a; Maybe is an instance of Functor
02:53:04 <dfeuer_> Reader produces a value given an "environment".
02:53:49 <doismellburning> > fmap (+1) (Just 1)
02:53:51 <lambdabot>  Just 2
02:54:20 <zereraz> ok
02:54:22 <silver> fmap sort of extracts a from f, applies function and puts result back to f
02:54:33 <zereraz> I know that
02:54:36 <dfeuer_> fmap f (Reader doIt) = Reader (f . doIt)
02:54:41 <zereraz> in the implementation of Maybe
02:55:06 <zereraz> f Just a = Just f a
02:55:09 <zereraz> I think
02:55:13 * hackagebot yesod-auth-hashdb 1.4.0 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.0 (paulrouse)
02:55:50 <zereraz> can you give me another example, other than Maybe
02:55:55 <silver> well if you know that there is nothing more to know :)
02:55:58 <dfeuer_> When you "unwrap" reader, fmap just turns into (.), unless I'm confused.
02:56:36 <doismellburning> > fmap (+3) [1,2,3]
02:56:37 <hmot> Hi all, I'm getting stuck with aeson's FromJSON. I have a function hmotParse :: String -> hmotData. (or Data.Text -> hmotData). I'd like to be able to use this to derive an instance of FromJSON. The tutorials all focus on a different use case.
02:56:37 <lambdabot>  [4,5,6]
02:57:10 <zereraz> dfeuer_: unwrap?
02:57:18 <zereraz> dfeuer_: do you mean f b?
02:57:26 <dfeuer_> zereraz: get rid of the newtype I introduced.
02:57:42 <zereraz> dfeuer_: ok
02:57:43 <dfeuer_> Your "f" is confusing.
02:57:48 <zereraz> yup
02:57:54 <zereraz> I get confused with functions
02:57:55 <zereraz> and f
02:57:56 <doismellburning> zereraz: or even `fmap (\x -> "LINE PREFIX> " ++ x) getLine` :: IO String
02:58:05 <dfeuer_> And it's confusing because -> looks weird.
02:58:17 <zereraz> and because I used f as functions before
02:58:26 <dfeuer_> So you can wrap it up in a newtype to make it easier to look at and think about.
02:58:29 <zereraz> as parameter name
02:58:49 <dfeuer_> instance Functor (Reader r) where ....
02:58:54 <doismellburning> zereraz: sure
02:58:56 <zereraz> doismellburning: here what is f and what is (a->b)
02:58:58 <zereraz> doismellburning: IO is f
02:59:09 <dfeuer_> zereraz: f = Reader r
02:59:09 <zereraz> doismellburning: and getLine is action
02:59:14 <doismellburning> :t \x -> "LINE PREFIX> " ++ x
02:59:15 <lambdabot> [Char] -> [Char]
02:59:18 <doismellburning> zereraz: ^
02:59:31 <doismellburning> zereraz: what is "action"?
02:59:35 <doismellburning> zereraz: dym "IO String"?
02:59:43 <silver> @type Just
02:59:44 <lambdabot> a -> Maybe a
03:00:03 <dfeuer_> zereraz: this is a good opportunity for type-directed programming. Figure out the type that fmap needs to have, then figure out what it must be.
03:00:07 <dfeuer_> Good night.
03:00:24 <zereraz> doismellburning: I used action to mean getLine, sorry
03:02:03 <zereraz> I should try again tomorrow, I started it yesterday. I think I get it, I forget something important then I get stuck. Thanks allot guys, again I think I get it, but still not confident.
03:10:14 * hackagebot json-schema 0.7.0.2 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.0.2 (ErikHesselink)
03:15:14 * hackagebot PBKDF2 0.3.1.5 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1.5 (ErikHesselink)
03:35:15 * hackagebot curlhs 0.1.2 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.2 (KrzysztofKardzis)
03:37:43 <kazagistar> I want to write a attoparsec parser that chunks text into lines... If I just grab Text words, Text spaces, and then glue them back togeather, can that be optimized nicely?
03:39:27 <Haskellfant> kazagistar: couldn't you just use many (takeWhile (/= '\n')) or something similar?
03:39:57 <kazagistar> Haskellfant: I dont want to break a word
03:40:11 <kazagistar> oh I see what the confusion is
03:40:36 <Haskellfant> you said you wanted to split it into lines?
03:42:36 <kazagistar> lineify 15 "This is a sentence. There is stuff here too." -> ["This is a", "sentence. There", "is stuff here", "too."]
03:43:15 <doismellburning> kazagistar: ooi what's the output of `lineify 2 "Hello"`?
03:43:46 <doismellburning> (["Hello"] or ["He", "ll", "o"]?)
03:44:29 <kazagistar> doismellburning: right, I was gunna ignore it for now, and turn it into a special case... ["H-","e-","l-","lo"]
03:50:07 <kazagistar> I am just not used to thinking about it this way... from an imperative perspective, this can be done with a simple "mark and revert" and counter
03:53:44 <SwashBuckla> how might I split a number into a list of it's integers?, e.g. splitIt 1234 -> [1,2,3,4]
03:53:56 <SwashBuckla> I'm trying to do   map reads . show
03:54:23 <SwashBuckla> I need to specify what type I want from reads, but I don't know where to do this
03:55:19 <kazagistar> SwashBuckla: lots of possible places... where do you use it?
03:55:59 <kazagistar> and I think your problem the types are wrong...
03:56:14 <kazagistar> :t map reads
03:56:16 <lambdabot> Read a => [String] -> [[(a, String)]]
03:56:49 <SwashBuckla> map reads :t map read
03:56:54 <SwashBuckla> oop
03:56:57 <SwashBuckla> :t map read
03:56:58 <lambdabot> Read b => [String] -> [b]
03:57:09 <kazagistar> :t show
03:57:10 <lambdabot> Show a => a -> String
03:57:16 <kazagistar> :t (.)
03:57:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:57:50 <kazagistar> String does not match [String]
03:57:57 <SwashBuckla> yeah I see that
04:02:50 <hmot> Continuing my quest to parse my json string into an hmotData object. The aeson documentation seems to want me to solve the problem like this:
04:03:18 <hmot> instance FromJSON hmotData where
04:03:35 <SwashBuckla> > map show ([1234])
04:03:37 <lambdabot>  ["1234"]
04:03:40 <hmot>   parseJSON = withObject expected myOFn
04:03:41 <kazagistar> like, the Java InputStream supports mark() and reset() cause it is such a common usage... I just really was hoping to get something I could use in a similar way in attoparsec
04:03:54 <SwashBuckla> > map show [1234]
04:03:56 <lambdabot>  ["1234"]
04:04:10 <SwashBuckla> > map show (1:2:3:4:[])
04:04:12 <lambdabot>  ["1","2","3","4"]
04:04:12 <hmot> and withObject is object -> Parser hmotData, which might be easy to write
04:04:23 <SwashBuckla> what
04:04:24 <hmot> but what is "expected"?#
04:04:33 <hmot> the documentation doesn't say
04:04:33 <hmot> https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:FromJSON
04:04:57 <SwashBuckla> ah I see
04:06:34 <kazagistar> hmot: could you link your code in lpaste/gist or something?
04:07:04 <hmot> well, the code is just three lines long
04:07:11 <hmot> I could summarise it
04:08:54 <hmot> data HmotData = HMotData ...
04:09:00 <hmot> instance FromJSON HmotData where
04:09:09 <hmot>   parseJSON = withObject myOFn
04:09:11 <hmot> myOfn :: Object -> Parser HMotData
04:09:30 <hmot> hmm, that would have worked better without the quit + join
04:09:48 <hmot> the problem is that withObject takes another string at the front
04:09:55 <hmot> "expected", in the documentation
04:10:08 <hmot> but I can't see what it would correspond to in the json
04:10:36 <hmot> the json is just { a:{whatever}, b:{whatever}}
04:10:45 <hmot> which would be represented by an object at this stage
04:10:59 <hmot> here's the documentation again: https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:FromJSON
04:11:34 <kazagistar> right, I see it... what types are a and b?
04:12:33 <hmot> well, I think that it shouldn't matter: mid-parse, they'd just be represented by the Value type
04:12:51 <hmot> but let's say for the purposes of argument that they are an inhomogenous mess
04:18:08 <kazagistar> hmot: dunno, im working it out.. so the problem is that you want to inspect stuff inside a subobject to build your data structure?
04:18:48 <hmot> well, it was originally that I wanted to use a String->HmotData function to parse
04:19:13 <hmot> but I think now that it enforces a constraint that the json parser has to stick with the JSON structure
04:19:46 <hmot> and a side effect of that is that you can't use a String -> HmotData function, since that wouldn't force the JSON correctness
04:20:38 <hmot> and so, it seems to want you to convert it to an object (Which is a synonym for a Hashmap String Value), and then construct your type from that
04:20:40 <hmot> which is fine
04:20:43 <kazagistar> I really would rather see the code + sample data, I am really confused... are you trying to parse non-json data with a json parser?
04:20:49 <hmot> it is json data
04:21:38 <hmot> the particular example was that the structure back is of form {'a':{whatever}, 'b':{whatever}}, and I want it to be parsed into a [(String, something)]
04:21:39 <hmot> type
04:22:03 <hmot> I could make the something match the whatevers above
04:22:33 <hmot> but I would like to be able to parse them myself
04:26:58 <kazagistar> hmot: right, that sounds like an ugly way to do things... but if you really want to, I guess you could use the FromJson Value and then ToJson Value to get the Text back...?
04:27:22 <kazagistar> but aeson is actually quite nice...
04:30:17 * hackagebot reroute 0.1.0.0 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.1.0.0 (AlexanderThiemann)
04:34:50 <hmot> It's impressive that the aeson structures are thought out to the extent that if you try to do something ugly with them (parsing one json structure to a different haskell structure in my case), you can't.
04:34:57 <hmot> but also slightly annoying at times
04:35:17 * hackagebot curlhs 0.1.3 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.3 (KrzysztofKardzis)
04:35:18 <hmot> and I'm trying to do this for an ugly reason: the true data structure can't be traversed in the way we want to
04:35:27 <hmot> so we were hoping that we could parse it to a more friendly structure
04:35:47 <hmot> but I now think this is probably the wrong approach
04:37:01 <Sonderblade> hmot: lenses!
04:37:50 <hmot> not sure if lenses do the trick. We want to take a big sprawling object, and convert everything in it to [(String, Double)]
04:38:10 <hmot> or NaN if the object has no object called 'z'
04:38:22 <hmot> maybe you can use lenses.
04:38:25 <hmot> but perhaps not
04:38:50 <kazagistar> hmot: can you show us an small example?
04:39:04 <hmot> (apologies to anyone who saw the same problem yesterday)
04:39:56 <Sonderblade> ofcourse you can do that
04:40:03 <hmot> {'a':{'asdfasdf': 'asdf', 'dfghd':'dfgh', z:2.0}, 'b':{'adsf':'dfghd'}}         this should map to [('a',2.0),('b',NaN)]
04:41:56 <Sonderblade> and {'a':{x:33,y:44}} gives?
04:42:12 <hmot> [('a',NaN)]
04:43:16 <Sonderblade> and {'b':{'a':{x:33,y:44}}} ?
04:43:35 <hmot> [('b',NaN)]
04:44:14 <kazagistar> and {'b':{'a':{z:33}}}?
04:44:32 <hmot> [('b',NaN)]
04:45:17 * hackagebot Spock 0.7.0.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.0.0 (AlexanderThiemann)
04:45:19 * hackagebot pontarius-xmpp 0.4.0.2 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.4.0.2 (JonKristensen)
04:46:25 <hmot> maybe it could be parsed to a dynamic type
04:46:31 <hmot> and then more easily traversed
04:46:49 <hmot> (not sure I'm using the word 'traversed' correctly?)
04:47:58 <kazagistar> :t traverse
04:47:59 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:48:12 <jayunit100_4g> how do you recurse when your final result needs to be a "Maybe" ?
04:49:22 <jayunit100_4g> i.e.  tailSafe :: List -> List -- for example
04:49:40 <jayunit100_4g> tailSafe :: List -> Maybe List -- sorry, thats what i meant....
04:50:05 <jayunit100_4g> if im building the tail up recursively, but the final return needs to be wrapped in a Maybe clause …. how would i do that?
04:50:18 * hackagebot edentv 4.9.2 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.9.2 (horstmeyer)
04:51:08 <kazagistar> :t traverseObject
04:51:08 <lambdabot> Not in scope: ‘traverseObject’
04:51:30 <kazagistar> I guess that wouldnt be in lambdabot haha
04:51:47 <hmot> jayunit100_4g: could you wrap your function in this: toMaybe a = Right a          (type = a -> Maybe a)
04:52:00 <jayunit100_4g> Right ?
04:52:10 <jayunit100_4g> what does Right do  ?  :) thats a new one 4 me : )
04:52:15 <jayunit100_4g> thanks hmot
04:52:22 <jayunit100_4g> and good mornin  !
04:52:42 <hmot> oops
04:52:47 <hmot> "Just", not "Right"
04:52:48 <kazagistar> hmot...  traverseObject :: (FromJSON v, ToJSON v) => IndexedTraversal' Text (Maybe Value) (Maybe v)
04:52:54 <jayunit100_4g> i guess a function wrapper would be good.  but id like something more elegant.  i assume there is such a thing
04:53:08 <kazagistar> its a somewhat fancy lens, and I am still a lensnoob, but I think it does the right thing
04:53:13 <jayunit100_4g> i assume recursion and Maybe are so common in haskell that someone has found a way to get them to live happily together
04:53:26 <_tca> jayunit100_4g: an inner function that is maybe list -> maybe list
04:53:34 <edwardk> kazagistar: you're looking at the wrong package
04:53:37 <edwardk> aeson-lens should die
04:53:41 <edwardk> lens-aeson is the one you want
04:53:57 <edwardk> aeson-lens doesn't make sense. none of the lenses are actually you know, actually lenses.
04:54:05 <kazagistar> edwardk: oh, my bad, thanks
04:55:01 <jayunit100_4g> okay thanks _tca .. i actually have to run but ill try that idea
04:56:24 <hmot> kazagistar, edwardk: it might be the wrong package, but would it do what I was hoping?
04:56:44 <hmot> I'm not determined to use lenses
04:57:06 <edwardk> hmot: lens-aeson can do anything you need to manipulate aeson with lenses. aeson-lens is just incoherent
04:57:18 <hmot> ok, let me have a look at that
04:57:42 <edwardk> so 'would it do what you are hoping'? probably not, unless what you are hoping is to write a bunch of illegal lenses that seem to sort of work at first blush =)
05:01:33 <hmot> So, the last thing to try, is to use Parsec or AttoParsec (not yet sure of the difference) and a custom parser
05:02:14 <hmot> anyway, I'm off for lunch. Thanks to everyone who's helped, especially kazagistar, edwardk
05:02:19 <kazagistar> aaand I accidentally installed it in global, and probably broke my cabal and everything
05:02:24 <hmot> @karma+ kazagistar
05:02:24 <lambdabot> kazagistar's karma raised to 4.
05:02:33 <hmot> @karma+ edwardk
05:02:33 <lambdabot> edwardk's karma raised to 43.
05:02:34 <kazagistar> wow, I had karma
05:02:42 <hmot> now you have even more :)
05:02:53 <hmot> it does seem like such a token way to thank someone
05:02:54 <kazagistar> wow, edwardk only has 43
05:03:23 <edwardk> @karma shachaf
05:03:23 <lambdabot> shachaf has a karma of 76
05:03:36 <koluzio> hello :) I'm trying to learn Haskell. In http://www.seas.upenn.edu/~cis194/hw/02-dict.pdf around page the mid of page 3, a problem is given then solved: sum all numbers in a list till the sum passes 20. While I understand the solution, it seems overly complicated to me, and I was wondering if there's anything more elegant?
05:04:48 <koluzio> (even if it's far more advanced than where the current tutorial I'm reading is at, pedagogically)
05:08:05 <kazagistar> koluzio: scanl is a foldl that gives you all the intermediate results, then you take the first item in the resulting list greater then 20?
05:08:24 <Axman6> > scanl (+) 0 [4,9,10,2,8]
05:08:26 <lambdabot>  [0,4,13,23,25,33]
05:08:40 <Axman6> > dropWhile (< 20) $ scanl (+) 0 [4,9,10,2,8]
05:08:42 <lambdabot>  [23,25,33]
05:09:02 <Axman6> > head . dropWhile (< 20) $ scanl (+) 0 [4,9,10,2,8] -- not so great
05:09:03 <lambdabot>  23
05:09:10 <kazagistar> head is unsafe :/
05:09:31 <Axman6> hence the comment =)
05:09:31 <kazagistar> and I know you know Axman6
05:09:42 <Axman6> > listToMaybe . dropWhile (< 20) $ scanl (+) 0 [4,9,10,2,8] -- not so great
05:09:43 <lambdabot>  Just 23
05:09:44 <kazagistar> I just wanted to clarify why
05:09:44 <pjdelport> Slightly better is: sumTo20 = listToMaybe . dropWhile (< 20) . scanl (+) 0
05:10:42 <koluzio> tyvm all! :)
05:10:43 <kazagistar> or just sum up to 20 if there is 20, otherwise sum, depending on what they want
05:10:49 <pjdelport> koluzio: With this version, the function will return Nothing instead of 0, as a default value.
05:11:13 <pjdelport> Which is clearer and more explicit: it lets you distinguish a valid sum from a list that fell short.
05:11:39 <bartavelle> > foldM (\a b -> let s = a + b in if s > 20 then Left s else Right s) 0 [4,9,10,2,8]
05:11:41 <lambdabot>  Left 23
05:11:48 <bartavelle> > foldM (\a b -> let s = a + b in if s > 20 then Left s else Right s) 0 [4,9,1,2,1]
05:11:49 <lambdabot>  Right 17
05:12:17 <Axman6> heh, nice
05:16:55 <kazagistar> ... Data.Either needs a {pickEither :: Bool -> a -> Either a a } (with a better name)
05:20:27 <pjdelport> pickEither b x = bool (Left x) (Right x) b
05:20:36 <vengelmann> hello
05:21:06 <pjdelport> If you swap the arguments of pickEither, then: pickEither = bool <$> Left <*> Right
05:21:09 <grohne> is there a type class that captures most of Data.Map's functionality?
05:21:16 <pjdelport> which seems rather neat :)
05:23:18 <bartavelle> pickEither = bool Left Right
05:25:19 * hackagebot rest-stringmap 0.2.0.2 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.2 (ErikHesselink)
05:31:09 <pjdelport> bartavelle: Even better! :)
05:31:57 <bartavelle> heh
05:33:04 <kazagistar> :t bool
05:33:05 <lambdabot> a -> a -> Bool -> a
05:33:27 <kazagistar> ah, I kept looking in Either, but it was in Bool all along, it makes so much sense
05:35:03 <pjdelport> @hoogle bool
05:35:05 <lambdabot> package bool-extras
05:35:05 <lambdabot> package boolexpr
05:35:05 <lambdabot> package bools
05:50:20 * hackagebot rest-example 0.1.2 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.2 (ErikHesselink)
05:53:05 <zmbmartin> Is there a certain convention to the type errors? I am trying to return m a from a function but it say actual type is t0 m a? Does t0 mean something specific or is it different per situation?
05:54:21 <pjdelport> zmbmartin: t0 is probably just a generated type variable name.
05:54:45 <zmbmartin> pjdelport: So it is different per code/situation?
05:54:47 <pjdelport> It doesn't necessarily mean anything, except to line up with other occurrences.
05:55:25 <avaritia> is there a smart way of converting Map k (m a) into m (Map k a) different than switching between map and list?
05:55:36 <pjdelport> It depends: GHC will generally try to use the same type variables as you originally used in your code, for clarity, but sometimes type inference will introduce new variables that just get a random name.
05:56:51 <zmbmartin> pjdelport: Thank you!
05:56:54 <pjdelport> :t T.sequence
05:56:55 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
05:57:31 <pjdelport> > T.sequence $ M.fromList [(1,Just "one"),(2,Just "two")]
05:57:33 <lambdabot>  Just (fromList [(1,"one"),(2,"two")])
05:57:56 <avaritia> pjdelport: but map is not listed as traversable
05:57:58 <leino> is there anything like librsync for Haskell?
05:58:54 <pjdelport> avaritia: It is: http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html#t:Map
06:00:16 <avaritia> pjdelport: hmm blunder on my side, but i'm pretty sure that where i was looking this wasnt listed, thank you for help
06:00:20 <pjdelport> avaritia: Note that not all instances will be listed under "Traversable" itself: many will just be listed under the type itself.
06:03:14 <Javran> hi, I
06:03:28 <chpatrick> hi everyone
06:03:53 <chpatrick> does anyone know if it's possible to make a datatype that has the same internal representation as a typeclass dictionary with multiple methods?
06:04:10 <chpatrick> I know it's possible to do it for one method a la Reifies
06:04:16 <chpatrick> but if I try it with Num it segfaults
06:04:19 <Javran> I'm wondering if there are some ways to apply hlint suggestions? saying I'm using flycheck / flymake in emacs
06:06:10 <lpaste> chpatrick pasted “Black magic attempt” at http://lpaste.net/111955
06:06:37 <chpatrick> I guess this is too naive
06:09:29 <pjdelport> chpatrick: You can just make a record with multiple members.
06:09:42 <pjdelport> Or do you mean automatically?
06:09:48 <chpatrick> I tried that but it segfaults
06:10:05 <chpatrick> I mean the black magic ghc internals way
06:10:25 <chpatrick> something I can pass to a function that internally takes a constraint
06:14:08 <RedNifre> Hey there.
06:20:41 <baadupo__> How to deconstruct a dataconstructor elegantly?
06:21:07 <ij> Pattern matching, I think.
06:21:13 <baadupo__> I don't think I'm meant to write a function for every parameter like this: http://pastebin.com/C8Lp3NYt .
06:21:49 <RedNifre> the compiler can generate those for you.
06:22:30 <chpatrick> try NamedFieldPuns
06:22:42 <RedNifre> I'm not sure if you actually have to do anything for this or if it happens by default.
06:22:52 <pjdelport> baadupo__: You can use record syntax: data WAVE = WAVE { header :: Header, samples :: Samples }
06:23:08 <chpatrick> WAVE { waveHeader, waveSamples } <- getWaveFile ...
06:23:11 <pjdelport> baadupo__: (replace those types with what you actually want)
06:23:23 <pjdelport> baadupo__: That will give you "header" and "samples" accessors just like what you wrote there.
06:24:14 <RedNifre> Ah, I think they are called waveHeader and waveSample
06:24:48 <silver> http://hackage.haskell.org/package/WAVE-0.1.1/docs/Data-WAVE.html#t:WAVE
06:24:49 <silver> yep
06:24:56 <hexagoxel> *waveSamples
06:25:46 <baadupo__> Ok, thanks
06:25:52 <RedNifre> is your example accurate?
06:25:57 <RedNifre> If so, why not use putWAVEFile "output.wav" $ input
06:26:17 <RedNifre> If it's a simplification you could try putWAVEFile "output.wav" $ WAVE (waveHeader input) (waveSamples input)
06:26:24 <baadupo__> Because I want to process the samples
06:26:49 <baadupo__> and add some computations in between
06:27:06 <baadupo__> I think I'll be using NamedFieldPuns.
06:28:51 <kazagistar> working with lenses... I have {iconcatMapOf (members <. key "z") :: AsValue s => (Text -> Value -> [r]) -> s -> [r] } and I want { ???  :: AsValue s => (Text -> Maybe Value -> r) -> s -> [r] } or something, every member is seached for a value, the function is called even when "z" isnt a key (with Nothing)
06:29:18 <Phillemann> How do I get the modification (or creation) time of a file? I see getModificationTime in System.Directory, but what about files?
06:30:07 <Phillemann> Ah, getFileStatus
06:31:06 <kazagistar> Phillemann: does getModificationTime not work on files?
06:32:14 <RedNifre> Hm, I'm confused how to best model the four calculator operations with data / class / instance.
06:32:29 <Phillemann> kazagistar: I didn't try, actually.
06:32:57 <RedNifre> So, there's 4 ops, plus, minus, mul, div, they can be shown, they are constructed with an int, they have a function that takes an int and returns a maybe int
06:34:01 <RedNifre> If I do something like data Op = PLUS {..} | MINUS, but every op has a first operand, do I have to add the first operand to each ... what are the data things called again?
06:35:03 <RedNifre> how do you call this again? data example = WHATS_THIS | WHATS_THAT
06:35:19 <kazagistar> RedNifre: why are you doing it this way?
06:35:22 * hackagebot language-c-quote 0.10.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.1 (GeoffreyMainland)
06:35:25 <hexagoxel> constructor
06:35:37 <RedNifre> kazagistar I want to understand data, instance and class
06:36:49 <RedNifre> Basically, I want this in three parts: you initialize an operation with the first operand, you can show it(string) and you can execute it with a second operand (Int -> Maybe Int)
06:37:40 <RedNifre> hm, maybe I just need to think more to figure it out by myself...
06:38:45 <hexagoxel> the straightforward model i can think of is data Binop = Binop Op Int Int; data Op = Plus|Minus|..
06:39:13 <RedNifre> yeah, I think partial constructors are the way to go.
06:39:13 <hexagoxel> why do you want such a half-applied model?
06:39:18 <kazagistar> why does the operation need to hold an operand?
06:39:18 <RedNifre> Wait, no. Those can't be shown...
06:39:49 <Athas> Does anyone know of a nice guide to type-level programming in GHC Haskell?
06:39:51 <RedNifre> Well, if it's a visual calculator a half applied operation needs to be showable
06:40:40 <Athas> In particular, I'm having trouble with functions requiring equality proofs 'x ~ y' in their context.  I can construct terms that ought to be witnesses, but how can I put them into the context?
06:40:49 <bezirg> hi, I have a type error: couldn't match type 'Control.Monad.Trans.RWS.Lazy.RWST ....' with 'transformers-0.3.0.0:Control.Monad.Trans.RWS.Lazy.RWST' it seems it is picking up the latest transfomers. If i hide the new transformers, then it works. How can I fix this without resorting to hide package?
06:40:50 <kazagistar> RedNifre: right, so a calculator state consists of a number and a maybe operation?
06:41:08 <RedNifre> a maybe number and a maybe operation
06:41:45 <RedNifre> but i think it's getting clearer, give me a minute :)
06:41:59 <bezirg> oh, I figured it out, I have to better rely on cabal for building this .hs file
06:43:19 <mbuf> what do the parenthesis in (Monoid w), and (Writer w) mean in https://gist.github.com/shakthimaan/c953f023e439174b5bce?
06:44:07 <Athas> mbuf: the parentheses around 'Monoid w' are superfluous, but the ones aroung 'Writer w' are important.
06:44:29 <Athas> If they were not there, it would read '(Monad Writer) w', which means something else (and wrong).
06:44:48 <Athas> Normal application associativity rules apply at the type level too.
06:44:57 <mbuf> Athas, thanks!
06:45:17 <RedNifre> can i do a partial constructor of a data where one parameter is a function that reads one of the fields of the data that will be constructed by this constructor?
06:45:25 <kazagistar> mbuf: you were doing the json right?
06:45:44 <albeit> Do you normally include your cabal sandbox and packages in your repository (git or otherwise)?
06:45:54 <mbuf> kazagistar, which JSON?
06:46:05 <kazagistar> mbuf: nevermind then I guess :P
06:46:09 <hexagoxel> mbuf: if there was more than one constraint, you would need parens, that's why some people always write them
06:47:16 <mbuf> hexagoxel, okay
06:48:04 <mbuf> one more question, how does the let statement work in line 3 here https://gist.github.com/shakthimaan/55d3bbf70e564d5da233
06:48:10 <kazagistar> albeit: standard git protocol excludes binaries... just save the configs, and reinitialize the sandbox
06:48:31 <albeit> kazagistar: Good to know, thanks
06:48:32 <nomeata> Hi. Has anyone seen this error message before?
06:48:34 <nomeata> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
06:48:36 <nomeata>    __x86.get_pc_thunk.bx
06:48:40 <nomeata> whilst processing object file
06:48:42 <nomeata>    /usr/lib/haskell-packages/ghc/lib/i386-gnu-ghc-7.6.3/vty-5.2.1/libHSvty-5.2.1.a
06:49:04 <nomeata> (I get this when compiling yi)
06:50:20 <grohne> nomeata: possibly something similar to http://stackoverflow.com/q/21272056/3168666?
06:50:55 <grohne> nomeata: but if you are doing this with debian packages, I wonder how you could end up with two versions of a library.
06:52:00 <nomeata> grohne: that’s what I’m thinking
06:52:06 <nomeata> full log at https://buildd.debian.org/status/fetch.php?pkg=yi&arch=kfreebsd-i386&ver=0.7.1-3&stamp=1410882226
06:52:13 <nomeata> happens only on 32bit-archies
06:53:05 <hexagoxel> mbuf: uhm what do you mean "how does it work"?
06:53:24 <geekosaur> someone is linking static libraries against other static libraries?
06:54:54 <mbuf> hexagoxel, I have updated with an example, https://gist.github.com/shakthimaan/55d3bbf70e564d5da233
06:56:36 <grohne> nomeata: wild guess: maybe this is due to a change in gcc in how it adds that symbol to your build? i.e. the build happened when it would be added to your build but now gcc provides it in start files or similar?
06:56:58 <pjdelport> mbuf: That's just standard Haskell syntax: let <definitions> in <expression>
06:57:12 <nomeata> grohne: probably something weird like that that’s beyond my C skill, yes
06:58:42 <pjdelport> mbuf: So that is pattern-matching on the result of "f x", extracting the values y and v', and then using those in the final result.
06:59:06 <mbuf> pjdelport, in the given example, what is f, x, y and v'?
06:59:07 <grohne> nomeata: can you try a rebuild with an older gcc?
06:59:41 <pjdelport> mbuf: f, x, and v are just the arguments to (>>=)
07:00:18 <pjdelport> mbuf: Just to check, how much Haskell have you done? That is, more or less where is your familiarity with everything? :)
07:00:31 <pjdelport> Just so i know where to aim the explanation at.
07:00:35 <nomeata> grohne: hmm, sounds annoying to do
07:00:58 <mbuf> pjdelport, I am failing to see how runWriter $ double 2 >>= double calls these functions; you can treat me as newbie :)
07:01:22 <nomeata> heh, the problem is not new: blog post from 2006 about it: http://www.fxp0.org.ua/2006/oct/18/multiple-definition-i686getpcthunkbx/
07:01:43 <pjdelport> mbuf: Well, the >>= operator in there is calling the function defined in Writer's Monad instance.
07:01:43 <mbuf> pjdelport, double 2 returns a Writer (4, "doubled 2")
07:01:50 <pjdelport> Right.
07:01:55 <hexagoxel> mbuf: first, you can read it as "runWriter ((double 2) >>= double)"
07:02:14 <pjdelport> mbuf: Have you worked with other Monad instances before? Or type classes in general, for that matter?
07:02:23 <mbuf> pjdelport, yes type classes
07:02:37 <mbuf> pjdelport, just been reading code trying to understand Monads
07:02:49 <pjdelport> Hmm, Writer is maybe not the easiest Monad instance to start with.
07:03:02 <pjdelport> Do you have a good understanding of Maybe, [], and so on?
07:03:09 <pjdelport> And Reader?
07:03:20 <mr-> Identity :-)
07:03:34 <pjdelport> Those would probably be the best Functor / Monad instances to get familiar with first.
07:03:40 <pjdelport> Then Writer :)
07:03:53 <pjdelport> And State, and so on.
07:04:47 <hexagoxel> mbuf: are you familiar with how (>>=) is defined as an infix operator?
07:09:00 <hexagoxel> 'Writer (4, " doubled 2") >>= double'  ==>  x==4, v=="doubled 2", f==double
07:15:24 * hackagebot sphinx 0.6.0.1 - Haskell bindings to the Sphinx full-text searching daemon.  http://hackage.haskell.org/package/sphinx-0.6.0.1 (GregWeber)
07:24:01 <Kron> is traversable/foldable already in prelude?
07:26:53 <RedNifre> is there syntax for changing just one field in a data?
07:27:38 <pjdelport> RedNifre: <variable> { field = newValue }
07:28:29 <alpounet> e.g, pos { x = 15 }, where pos :: Position, and data Position = Position { x :: Int, y :: Int }, for example.
07:32:00 <RedNifre> So like digit c@(Calc _ Nothing) d = c { number = Just d }
07:32:14 <RedNifre> Calc is the calculator state, the second parameter is the number.
07:32:38 <k00mi> Kron: not in GHC 7.8, the current release
07:32:42 <RedNifre> IT's a bit confusing that the number field name only appears on the right. Hm...
07:33:11 <silver> it's not for me
07:33:38 <silver> since you're not changing state
07:34:01 <RedNifre> But when you read that line of code, how would you guess that the Nothing on the left is related to the number on the right?
07:35:05 <lyxia> digit c@(Calc { number = Nothing }) = c { number = Just d } -- RedNifre
07:35:35 <RedNifre> Thanks, that is nicer. But why is it = instead of ==
07:37:17 <lyxia> RedNifre: It does pattern matching with records. It does not use Eq.
07:38:17 <lyxia> foo c@(Calc { number = Just x }) = <x is in scope here>
07:40:12 <pjdelport> In a pattern-match context (that is, on the left) you can read "Calc { number = Just x }" as "a Calc value where the number field is Just x"
07:40:39 <pjdelport> Or rather, "Calc { number = Nothing }" as "a Calc value where the number field is Nothing"
07:41:07 <pjdelport> And then in an expression context (that is, on the right) "c { number = Just d }" can read as "c, where the number field is replaced with Just d"
07:41:57 <RedNifre> This seems weird to me. I thought "x = y" means "I declare x to be y" and "x == y" to mean "I want to know whether x is y"
07:42:30 <pjdelport> RedNifre: It does at the top level, but inside the { } brackets of record syntax it means the above.
07:42:30 <lpaste> damianfral pasted “Free monad + gnuplot” at http://lpaste.net/111958
07:42:34 <RedNifre> I guess you could read the left side as "Compare the parameter with this calc value where I declared the numebr field is Nothing"
07:42:48 <pjdelport> RedNifre: The { } brackets of record syntax are a thing of their own.
07:43:16 <RedNifre> strange
07:43:32 <damianfral> I'm working on a EDSL to plot graphs built over the free monad: http://lpaste.net/111958
07:43:32 <pjdelport> RedNifre: It's probably not too accurate to think of patterns as values, like that. They are patterns without actually being a value: they get *compared* against values.
07:44:38 <pjdelport> So in a pattern context, "Calc { number = Just x }" does not create a Calc value where the field is set to Just x: it's a pattern that will *match* against a calc value whose number field happens to be a Just value.
07:44:39 <damianfral> the problem I have is related with the function "extract" (line 127)
07:45:11 <pjdelport> (and the result of the pattern match will be to bind the value of the Just constructor to the binding 'x'.)
07:45:25 * hackagebot rest-gen 0.16.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.0.2 (ErikHesselink)
07:45:42 <damianfral> If I add a new "instruction" to the free monad, I have to extend "extract" to support it
07:45:54 <kgadek> hi. let's say I want to implement functional dependencies for something that is similar to Hs98. Any pointers on what to see (papers, presentations, videos, etc)?
07:46:10 <damianfral> how could I solve this "problem" and make my EDSL more extendable?
07:52:06 <asfp> where do I find a fixed time string/bytestring/text comparison function?
07:55:08 <asfp> hs-securemem?
08:05:25 <Emi23>  Hi! I give you some videos. I hope you like! http://is.gd/GHJqQj
08:10:26 * hackagebot simtreelo 0.1.0.0 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.0.0 (mgmillani)
08:10:28 * hackagebot accelerate-cuda 0.15.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.15.0.0 (TrevorMcDonell)
08:15:27 <mbuf> hexagoxel, thanks, will look into it
08:15:30 <mbuf> hexagoxel, BRB
08:16:45 <LesZedCB> hi guys
08:18:01 <edwardk> @remember xplat "non-evil Grothendieck" is spelled "Street"
08:18:01 <lambdabot> It is forever etched in my memory.
08:20:42 <albeit> I just criterion'ed a program on a new server, nothing else running, and its running about 2x slower than my dev machine (which is significantly less powered). Why would this be?
08:21:15 <zmbmartin> Can anyone enlighten me on what I am doing wrong or missing here -> https://gist.github.com/codedmart/334d20354fe98b87c3cb#file-main-hs-L29-L39
08:22:59 <zmbmartin> I am trying to reuse a mongodb connection pipe instead of calling connectMongo all the time by using the Reader monad to hold some config stuff for my app.
08:25:08 <zmbmartin> Sorry wrong error -> updated https://gist.github.com/codedmart/334d20354fe98b87c3cb#file-main-hs-L29-L39
08:30:27 * hackagebot clock 0.4.1.3 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.1.3 (CetinSert)
08:34:15 <nkar> how can I tell haddock to generate documentation for a specific module in a sandbox?
08:38:37 <nkar> cabal exec sh followed by haddock --html Main.hs seems to work.
08:42:27 <yyttr3> How can I make my haskell project of mine installable by other people?
08:42:55 <nkar> cabal init
08:43:31 <nkar> yyttr3: this will generate a cabal file, so they'll be able to install it via cabal install
08:43:54 <yyttr3> I mean, with make, make install.
08:44:15 <yyttr3> how do I specify what I want to be globally available?
08:49:36 <danilo2> Hello! Are we able to link sandboxes in cabal in parent-child relation? I mean - I want to create a sandbox with some libraries installed - and few other sandboxes that will have access to these installed packages - just like they are available in the system ?
08:50:17 <ReinH> danilo2: you can point to the same sandbox from multiple places but I don't think you can do what you want
08:50:59 <dcoutts_> danilo2: cabal sandbox doesn't support that directly. However, each sandbox has a ghc package db, and so long as you know what you're doing then it's possible to use multiple dbs together
08:51:50 <albeit> If I "cabal install" something in a sandbox on one computer, and then just copy that sandbox to another computer, is that bad? Does "cabal install" install different things depending on the host (but both are Ubuntu 14.04)?
08:52:42 <danilo2> ReinH, dcoutts_: hmm ok, so If I would like to use the dbases, then should I pass them as cabal options or how can I configure a sandbox to use more databases?
08:52:58 <dcoutts_> albeit: might work. The way cabal expects to create installable images is by cabal copy --destdir=./image
08:53:03 <danilo2> albeit: good question! I would love to know that too
08:53:54 <dcoutts_> danilo2: you can cabal configure with additional specific package dbs, and I think you can put the same thing in a local config file
08:55:12 <danilo2> dcoutts_: Ok, good to know that. I'll try to do it, thank you! :)
08:56:19 <ReinH> albeit: I literally just did this and it worked fine, but surely it will depend on the arch and such.
08:57:05 <mkscrg> i started playing with datakinds this morning, got stuck in a corner
08:57:10 <mkscrg> given a promoted type like   data C = C1 | C2 | C3, can one defined a constructor   WithC :: (c :: C) -> WithC c  ?
08:57:56 <mkscrg> (i.e. WithC's argument is polymorphic over types w/ kind C)
08:58:20 <albeit> Hmm okay... I just seem to be getting a huge performance drop on the computer I just moved everything too, but its a far faster machine, and no idea why...
08:59:48 <k00mi> mkscrg: data or type constructor?
09:00:00 <mkscrg> if anyone wants to take a look: http://lpaste.net/111960
09:00:26 <mkscrg> k00mi: data constructor
09:01:07 <mkscrg> k00mi: s.t.   :t WithC C1 :: WithC 'C1
09:01:23 <mkscrg> k00mi: and s.t.    WithC Int   does not compile
09:01:35 <mkscrg> rather, isn't a valid type
09:02:32 <k00mi> mkscrg: ok, so you want dependent types
09:03:33 <k00mi> have a look at the singletons library for a hackish way to do it in haskell or at a language with proper dependent types like agda, coq or idris
09:03:55 <mkscrg> k00mi: i dunno about that. i think i just want to restrict a type parameter to a type in a closed set
09:04:17 <RedNifre> is it possible to declare a postfix function? bla .= = does not work it seems
09:05:45 <k00mi> mkscrg: what that code is trying to do is make the return type of (the data constructor) WithC depend on the value of it's argument
09:05:46 <ReinH> RedNifre: no
09:07:06 <mkscrg> k00mi: heh, i guess that does sound like DT :P
09:07:17 <pjdelport> RedNifre: GHC does have the http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators hack
09:08:09 <ReinH> pjdelport: huh
09:08:28 <pjdelport> RedNifre: Define "(.=) x = ..." as a normal function, and then you can use the the left section (foo .=) as an effective postfix application
09:08:38 <pjdelport> (With the above extension enabled, that is.)
09:09:03 <k00mi> mkscrg: the problem is that, in haskell, the type C and the kind C are entirely sperate entities and there is no relationship between them or their inhabitants
09:09:26 <k00mi> singletons create that relationship, with dependent types they are the same entity
09:11:58 <RedNifre> ah, thanks pjdelport
09:27:01 <bennofs> GHC Core doesn't seem to contain any data type information. Does that mean that core isn't enough to compile a program?
09:34:13 <albeit> Criterion question... when estimating clock resolution, it says "found 1079308 outliers among 639999 samples (168.6%)". How is that even possible?
09:35:30 * hackagebot descrilo 0.1.0.0 - Loads a list of items with fields  http://hackage.haskell.org/package/descrilo-0.1.0.0 (mgmillani)
09:43:40 <avaritia> hmm is there a way to put a qualified name into pattern matching in a function?
09:44:30 <merijn> avaritia: eh, just type it?
09:45:35 <avaritia> merijn: i did i got "Qualified name in binding position: Map.empty"
09:46:10 <merijn> avaritia: That's because you can't pattern match on non-constructors
09:46:23 <merijn> > let f (Data.Maybe.Just x) = x in f (Just 1) -- this works
09:46:24 <lambdabot>  1
09:46:49 <nkar> is there a way to copy a sandbox from one directory into another one?
09:46:58 <avaritia> merijn: thanks
09:47:09 <merijn> avaritia: You should use a guard and Map.null instead
09:47:20 <nkar> if I simply copy .cabal-sandbox, cabal can't find the dependencies
09:48:30 <MedDev> nkar, not as far as i know :/
09:49:06 <merijn> Are you trying to make a sandbox use a locally modified version from another sandbox?
09:49:43 <nkar> merijn: both directories are essentially the same project
09:50:20 <nkar> I've run cp foo bar where foo has a sandbox.  now I want the same sandbox in bar without reinstalling everything
09:50:58 <merijn> No clue, then
09:52:03 <RedNifre> To understand types, classes, data and instances I wrote a little calculator, but the code looks odd. Any advise how to improve this?: http://pastebin.com/rg3Af6ci
09:52:53 <RedNifre> The calculator contains maybe a peding operation and maybe a number. You enter digits or operators.
09:54:17 <MedDev> nkar, you can share a common sandbox between two projects
09:54:31 <pjdelport> RedNifre: I think the use of "Operand" to refer to operators is a bit confusing there.
09:54:33 <nkar> merijn, MedDev: I've figured it out.  you need to run cabal init in a fresh directory to generate a .cabal.sandbox.config file, then you can copy the .cabal-sandbox from the other directory
09:54:43 <pjdelport> RedNifre: "operand" usually refers to what the operators operate *on*
09:54:50 <pjdelport> (that is, the numbers)
09:54:56 <RedNifre> oh, yeah, that is a typo sort of
09:55:07 <RedNifre> should be operator
09:55:16 <MedDev> nkar, cabal sandbox init --sandbox /path/to/shared/sandbox/.cabal-sandbox
09:56:06 <merijn> RedNifre: I think you can simplify this by eliminating the typeclass and turning your operations into a "proper" AST
09:56:53 <nkar> MedDev: yeah, I'm aware of that.  I wanted a copy, not a shared sandbox.
09:57:04 <MedDev> nkar, ah ok. good to know you can do that then :)
09:57:30 <SrPx> I've just installed split using cabal in a sandbox, but "import Data.list.Split" still doesn't work, why?
09:57:42 <NemesisD> woah. i'm getting some weird behavior, if i do cabal info random-1.0.1.3, it lists dependencies as base >=5 && <5, time -any, random -any, base >=3 && <5, random -any, base >=3 && <5, random -any, base >=3 && <5
09:57:45 <glguy> Because list is not uppercased?
09:57:58 <NemesisD> which is totally not true. i have no idea where it gets >=5 && < 5 from
09:58:26 <danilo2> Hello! Is it possible in GHC to throw an error but in such way, that the output will not have prefix containing the file name ? I want to put my filename there
09:58:48 <RedNifre> merijn what do you mean?
09:58:51 <dcoutts_> SrPx: to start ghci in the sandbox environment, use cabal repl
09:58:56 <SrPx> glguy: eh no, it is actually uppercased on my code, my bad
09:59:18 <glguy> NemesisD: random-1.0.1.3 is deprecated and probably has that version bound to stop cabal from using it
10:00:23 <NemesisD> glguy its weird that the site doesn't show those messed up bounds. also something in my dep chain depends on random < 1.1 :(
10:00:27 <nkar> danilo2: putStrLn?
10:00:29 <dcoutts_> NemesisD: right, it's listed there in the .cabal file
10:00:32 <dcoutts_> http://hackage.haskell.org/package/random-1.0.1.3/random.cabal
10:00:43 <SrPx> dcoutts_: I'm not sure what cabal repl is, but `ghci` doesn't recognize it too
10:00:43 <lpaste> merijn pasted “simplified” at http://lpaste.net/111963
10:00:48 <merijn> RedNifre: See that paste
10:01:14 <danilo2> nkar: no, it does not vbreak the runtime
10:01:31 <RedNifre> does this show "5+"?
10:01:40 <MedDev> SrPx, `cabal repl` = ghci in your sandbox
10:01:41 <dcoutts_> SrPx: ghci does not know about sandboxes, that's a cabal concept. But you can ask cabal to run ghci for you in the appropriate context. That's what cabal repl does.
10:01:49 <RedNifre> It looks like it can only show complete syntaxes
10:02:05 <RedNifre> I meant complete statements.
10:02:12 <MedDev> SrPx, you have to build with `cabal configure && cabal build` so it knows about the sandbox. simply using ghc won't work in a sandbox
10:02:29 <merijn> RedNifre: Ah, true. If you want to support partial statements, you may want to modify the Expr type a bit
10:02:59 <merijn> RedNifre: Like adding a "Empty" constructor to Expr that serves as a placeholder for missing data
10:03:21 <merijn> Then "5+" would be "Plus (Num 5) Empty"
10:03:29 <merijn> Or Missing, or whatever
10:04:40 <jfischoff> or `Infix (Maybe Expr) Sym (Maybe Expr)` like TH
10:05:37 <SrPx> merijn: sorry I'm not sure what I'm supposed to do, could you tell me the commands? "mkdir test; cd test; cabal init; touch test.hs;  echo "mycode" >> test.hs; now what??"
10:06:43 <MedDev> SrPx, set your main module and dependencies in the .cabal file, run `cabal configure` then `cabal build`
10:08:14 <RedNifre> hm, I guess I should remove the Executable class, because there is only one record that is an instance of Executable? Or is there another reason?
10:08:51 <MedDev> SrPx, then an executable file will be in /ProjectDir/dist/build/ProjectName/ProjectName where projectname is defined in your cabal file
10:09:07 <MedDev> file will be*
10:09:20 <dcoutts_> MedDev: did SrPx really want to create a package, or just use ghci with a package SrPx installed in a sandbox?
10:10:31 <SrPx> dcoutts_: I just want to use ghc (not ghci) with a package installed in a sandbox, but I guess using "cabal init" is the best form to start a file in haskell, even when it is just a small throwaway script, right?
10:10:55 <SrPx> I don't want global installs anymore since last time I had too many headaches from doing so
10:11:14 <ReinH> SrPx: if you're using a cabal sandbox then you're best off using cabal to build things
10:11:18 <MedDev> yeah :/
10:11:33 <SrPx> I find it amazing that my learning process on haskell is pretty much breeze through the functional concepts, all to waste hours/days/months trying to figure out cabal
10:11:52 <dcoutts_> SrPx: ok, then yes, making your program into a package is the simplest thing
10:12:07 <SrPx> :) hope I learn it this time
10:14:01 <RedNifre> Thanks for the code, merijn, it is really helpful.
10:14:05 <MedDev> SrPx, http://www.haskell.org/cabal/users-guide/developing-packages.html check out this part of the cabal manual on creating a simple cabal package
10:14:09 <vanila> I asked some haskell programmers I know: Have you ever usd Traversible
10:14:10 <SrPx> This tutorial http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Recommended_tools comments about "Setup.hs" without giving a reference or explaining what it is
10:14:12 <vanila> none of them had
10:14:23 <vanila> so I don't think this belongs in prelude
10:15:24 <MedDev> SrPx, for compiling external libraries and running precompile scripts. a lot of large projects use a Setup.hs that acts kinda as a prebuild script
10:16:20 <SrPx> MedDev: it is just a file that is called when you do "cabal build"?
10:16:23 <marvin-hh> vanila: I have used it.
10:16:41 <vanila> marvin-hh, I've only used it in lens
10:16:41 <marvin-hh> vanila: perhaps your acquintances are just not that awesome.
10:16:55 <vanila> marvin-hh, that's pretty rude
10:17:09 <johnw> vanila: I use Traversable in almost every module I ever work in
10:17:34 <dcoutts_> johnw: interesting, I almost never use it
10:17:56 <marvin-hh> vanila: you are the one who comes in claiming that people need to change the prelude as a complete n00b.
10:18:05 <johnw> I use it to replace mapM forM sequence and msum
10:18:13 <marvin-hh> vanila: no advanced user requires any changes to Prelude.
10:18:16 <josephle> maybe Traversable is one of those typeclasses that is really useful but people don't realize it
10:19:10 <dcoutts_> johnw: how much do you use it at types other than the normal ones?
10:19:23 <MedDev> SrPx, yeah, for your purposes you can leave it to whatever `cabal init` creates
10:19:25 <dcoutts_> ie normal fold, mapM etc
10:19:29 <johnw> not a huge amount
10:19:31 <marvin-hh> Does it really matter how often something is used?
10:19:31 <portnov> hi all
10:19:42 <portnov> is hackage's documentation generator down?
10:19:44 <johnw> I mostly use it so that I only need an Application constraint
10:19:54 <portnov> it does not generate docs for my package for a few days
10:19:59 <portnov> http://hackage.haskell.org/package/iso8583-bitmaps
10:20:06 <marvin-hh> If the most general type is made available and the compiler specializes it, there is nothing to discuss.
10:20:20 <SrPx> the tutorial mentions using "cabal install", but as I said I guess I'm not installing global libs anymore, is it ok to just install everything in a sandbox?
10:20:22 <marvin-hh> If the compiler doesn't, the compiler needs to be fixed. Still nothing needs to be discussed.
10:20:28 <marvin-hh> Why are we discussing this again?
10:20:30 <marvin-hh> Thanks
10:21:24 <MedDev> SrPx, if you're in a sandbox all cabal commands will run inside the sandbox
10:21:55 <josephle> portnov: I thought I was going insane when I saw the most recent library versions on hackage had no docs...
10:22:37 <SrPx> ah doh of course, thanks MedDev
10:27:05 <MedDev> SrPx, good luck. gotta go to work. hope you get it compiling :)
10:27:24 <SrPx> thanks a lot MedDev ! see you
10:29:31 <SrPx> btw, is there a quick overview of the licenses? I'm clueless
10:29:38 <SrPx> kinda off topic
10:33:46 <josephle> SrPx: tldrlegal.com
10:33:55 <SrPx> josephle: ty
10:33:57 <josephle> seems okay
10:34:53 <josephle> SrPx: here's a pretty nice one if you don't want to care about the nuances
10:34:55 <josephle> http://choosealicense.com/
10:35:33 * hackagebot language-c-quote 0.10.1.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.1.1 (GeoffreyMainland)
10:40:33 * hackagebot XSaiga 1.0.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  http://hackage.haskell.org/package/XSaiga-1.0.0.0 (InBetweenNames)
10:47:58 <albeit> How can I upgrade which version of the Cabal library I'm using? I'm using cabal-install version 1.20.0.3, but with Cabal library 1.20.0.0... I'd like to use Cabal library 1.20.0.2
10:48:35 <dcoutts> albeit: cabal install cabal-install Cabal-1.20.0.2
10:48:58 <albeit> dcoutts: Thanks!
10:49:11 <dcoutts> or more-or-less equivalently: cabal install cabal-install --constraint=Cabal==1.20.0.2
10:53:44 <parkman> Hey im having a hell of a time setting up gtk2hs on windows 8, can anyone help me out?
11:00:11 <marvin-hh> parkman: you should follow the instructions. If they are wrong, send a message to the maintainer. If the maintainer doesn't respond with an acceptable answer abandon your attempt or fork it.
11:00:34 <albeit> Are -f options to GHC compile options or link options?
11:02:03 <josephle> albeit: are these the -fasm, -fllvm, etc. options?
11:02:21 <albeit> josephle: No things like -fno-full-laziness
11:02:35 <albeit> Just wondering if I need to cabal clean and recompile when I change them...
11:05:12 <josephle> that seems to be a compile option
11:06:33 <geekosaur> the manual does a decent job of splitting up -f options by when they apply
11:07:00 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
11:12:00 <artyomkazak> What's the canonical name for the functor transformer `SF a (f x)` where f is a functor itself? Basically a product of Const and <given functor>
11:15:35 * hackagebot yesod-auth-oauth2 0.0.10 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.10 (PatrickBrisbin)
11:18:45 <RedNifre> Has anyone used Haskell on Android?
11:30:01 <raichoo> RedNifre: It's possible but I didn't really write anything useful with it yet. Just "yay, also works on my phone \o/"
11:31:15 <RedNifre> How does it work in practice? Can you write the GUI in Java and call Haskell from there?
11:31:40 <dysinger> I think it compiles to native arm
11:32:00 <SrPx> something I really miss on Haskell is the metaprogramming ability of scheme
11:32:11 <SrPx> it is a shame that I can't call "eval" and get a function from a file I'm parsing :(
11:32:21 <RedNifre> I meant, how do you for example implement that when you tap a button, a text on the screen changes its content based on what the user entered into an input field?
11:34:21 <dysinger> You’d have to probably use JNI from java to leverage the haskell code.
11:34:23 <dysinger> more here http://www.haskell.org/haskellwiki/Android
11:34:27 <RedNifre> Using ONLY haskell on Android might only work for apps that don't interact with the OS at all, e.g. games that don't use the standard GUI. For everything else, avoiding Java is probably not practical since Haskell can't use the OS api (the Android api is all Java)
11:34:55 <RedNifre> I had a look at that side but the content is three years old and mostly no longer relevant it seems.
11:36:41 <RedNifre> I haven't really mixed programming languages so far. How does it work if for example you use Haskell in C? Is each call to the haskell code a separate runtime? How do return values work? I mean, I guess you can get ints and Strings, but what if you want something more complex?
11:37:41 <RedNifre> Say, if you had a function that returned a tuple with a boolean and a string (success, message), how would you call that function from C code?
11:38:43 <dmj`> why is CSS more complicated than haskell
11:39:49 <RchrdB> RedNifre: uh, with a little difficulty. The Haskell FFI is mostly designed for having Haskell call into C rather than C calling into Haskell. It does have provision for working with C APIs that requrie callbacks, though.
11:42:03 <RedNifre> Hm. Maybe if every function I want to call from Java returned a String with JSON in it... then the Java part could just turn that into Java objects again.
11:42:15 <RchrdB> RedNifre: oh wait, here's a nice example: http://rosettacode.org/wiki/Use_another_language_to_call_a_function#Haskell
11:43:11 <RchrdB> with GHC, you need to initialize the RTS once in your process, and then you can call functions that have been exported with "foreign export ..."
11:43:33 <RchrdB> RedNifre: sorry, it isn't *that* hard, I just mis-remembered what was in the FFI. >_>
11:44:07 <RedNifre> That looks very interesting, thanks :)
11:44:38 <zmbmartin> I am trying to use the reader monad with scotty to store a mongodb pipe (connection), but am not sure how to get the pipe back out as it's original type Pipe -> https://gist.github.com/codedmart/26722b790be730d70ddd#file-main-hs-L9-L13
11:46:28 <RchrdB> RedNifre: for your stated use case, "an IO action that returns a string and an int", I'd export a function that takes a pointer to a buffer and its length (a char* and a size_t*), and a pointer to an int.
11:46:56 <RchrdB> RedNifre: I'm not sure if you can foreign export something returning a tuple, but a C programmer would be hoping for an API that has output pointers instead anyway. :)
11:49:30 <RchrdB> RedNifre: it's pretty dry and not at all tutorial-like, but the FFI section of the Haskell 2010 report is the canonical description of Haskell's C FFI https://www.haskell.org/onlinereport/haskell2010/haskellch8.html
11:51:18 <alrunner4> zmbmartin: i don't see anything particularly wrong there other than the type of mpipe - seems like it ought to be TnIO Pipe rather than just Pipe
11:52:17 <albeit> When criterion is profiling something that spawns threads, does it include the time required for any spawned threads to complete in the mean duration?
11:53:44 <RchrdB> RedNifre: note that for calling C interfaces that use callbacks, you typically don't use foreign exports, but instead FunPtrs. https://hackage.haskell.org/package/base-4.2.0.1/docs/Foreign-Ptr.html#t%3AFunPtr
11:56:02 <zmbmartin> alrunner4: So then do I just use p <- mpipe to get it to Pipe? I updated my gist with what I am trying to do and the error https://gist.github.com/codedmart/26722b790be730d70ddd
11:56:05 <RchrdB> RedNifre: http://www.haskell.org/haskellwiki/GHC/Using_the_FFI has a bunch of information too, that's especially relevant if you want to make DLLs that have Haskell code in them.
11:56:09 <RedNifre> I'm not sure, all these solutions seem to completely bypass the Android OS api, which IMHO is only a sensible thing to do when creating games.
11:56:15 <zmbmartin> alrunner4: Thanks also :)
11:57:46 <RedNifre> Maybe the Android app would start an Android service which contains a haskell binary with scotty in it, running on a local port. Then the Android app could make calls via REST with automatic JSON conversion.
11:58:34 <RedNifre> I wonder how much performance that would cost. hm...
12:00:27 <RedNifre> Well, I guess I'll put that on my to do list for later. On a more practical note, what do you guys recommend for persistence?
12:02:00 <RedNifre> I haven't done any persistence with haskell yet, I heard a podcast about pipes and conduit and didn't understand which one would be better. And I wonder which DB I should use... SQLite is simple, Postgres has a new JSON type which might (?) be good to store records? And what about mongoDB and couchDB? How to do persistence in haskell?
12:03:01 <RchrdB> GHC pretty much only has a C FFI. To call Haskell from Java, I expect you'd have to use Java's C FFI (JNI) to call C(++) stubs that in turn call GHC's FFI. I'm not aware of any existing program that could automatically generate those stubs for you.
12:04:00 <RedNifre> Yeah, that's what I think. So Java -> GSON -> Retrofit -> Scotty -> Haskell it is then.
12:07:50 <RchrdB> The performance overhead of talking to the other process in JSON depends on how much data you're moving around and how many calls there are between the two. At minimum you're looking at one process context switch (like a microsecond, I think, on modern CPUs) per call plus the expense of turning parsing and producing HTTP requests and JSON (you should expect to be able to make up to a few thousand HTTP
12:07:51 <RchrdB> requests per second on a small CPU, and JSON parsing/formatting time varies)
12:08:30 <albeit> Is there a recommended library for benchmarking/timing multithreaded programs?
12:10:01 <RchrdB> albeit: I'm pretty certain that you can test programs that use multiple threads under criterion.
12:10:36 <RyanGlScott> Suppose I have data Double a b. Is there a way to create a Functor Double b instance instead of a Functor Double a instance?
12:10:48 <albeit> RchrdB: Except if a thread spawns new threads, it seems to wait for those new threads to complete... but I need to know how long it takes just for the origianl thread to return
12:11:30 <RchrdB> albeit: does your interface not include a way to ask those threads to shut down?
12:12:26 <albeit> RchrdB: Not sure what you mean?
12:13:33 <RchrdB> albeit: the action you're calling spawns threads and leaves them lying around instead of cleaning them up? Why does it do that?
12:15:05 <albeit> RchrdB: The threads aren't loops, they just, for example, write an unimportant log, and then return fairly quickly. Do I need to explicitly clean those threads up?
12:15:37 * hackagebot hydrogen-prelude 0.5 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.5 (JulianFleischer)
12:16:14 <RchrdB> So they do actually complete, not hang around? I think that you *do* want them included when computing the cost of your program, then.
12:16:25 <zmbmartin> Anyone that can give me a pointer of what I am missing -> https://gist.github.com/codedmart/26722b790be730d70ddd#file-main-hs-L9-L18
12:17:16 <albeit> RchrdB: Yes, they complete. But I *dont* want them included. They are purposely spun off so that main thread can continue doing things... I'm trying to measure how long that main thread takes, not how long the child threads take as well
12:17:34 <Cale> zmbmartin: mpipe doesn't need to be a Pipe, it needs to be an IO Pipe, while it's actually a ReaderT TnConfig IO Pipe
12:17:51 <Cale> zmbmartin: You could use runReaderT on it, with the config
12:18:01 <Cale> However, that config isn't in scope
12:19:00 <Cale> zmbmartin: ReaderT isn't magic, it's just sugar for parameter passing, you still have to pass the parameter in *somehow*, even if that's just using ReaderT in more places
12:19:16 <Cale> zmbmartin: If it were me, I'd probably skip the ReaderT and just pass the config as a function parameter
12:19:58 <albeit> RchrdB: I guess I could keep track of the child threads, then when the test function completes, explicitly kill any of the child threads.
12:20:26 <zmbmartin> Cale: Yeah I don't know how to use ReaderT obviously well yet.
12:20:37 <RchrdB> Nah, I only suggested killing the child threads because I thought you meant that they were loops (in which case there would be a good reason to need to provide a function that shuts them down.)
12:20:40 <zmbmartin> Cale: I just want to use the same pipe/connection around the app.
12:21:01 <zmbmartin> This was a similar solution that someone else used just not with mongodb so I am trying to adapt it.
12:21:03 <RchrdB> albeit: I would be slightly wary of trying to micro-benchmark just the main thread part because you don't have any guarantee that the main thread will be scheduled ahead of the child threads. Um, if this is part of a HTTP service, then where you're sitting I'd try "ab" (apachebench) or one of the other generic HTTP benchmarks.
12:21:49 <zmbmartin> Cale: How would I use your idea to pass around the pipe/connection
12:22:27 <Cale> Well, what I'd do is just add a TnConfig parameter to anything which needed it
12:22:34 <albeit> RchrdB: No not an HTTP service. But if it's running on a system with "enough" (very vague) cores, then the main thread and child threads are going to be scheduled roughly simultaneously, so I shouldn't need to worry about that?
12:22:35 <Cale> and pass down the config explicitly
12:22:53 <RchrdB> albeit: probably fine, yeah.
12:23:35 <albeit> RchrdB: Sounds good, got some new ideas to try at least ;) thanks
12:23:36 <Cale> It's bound to be less trouble than using ReaderT unless your plan is to build up a solid abstraction where you don't use many or any raw IO actions anymore, just the actions of this new monad that you've defined using ReaderT, but that involves building up a lot of stuff
12:24:17 <Cale> Most people who are using ReaderT over IO are doing something a little questionable imo.
12:24:27 <zmbmartin> Cale: Is it possible though to get that from TnIO Pipe -> Pipe?
12:24:31 <Cale> (Or StateT for that matter)
12:24:58 <Cale> You can get a function of type  TnConfig -> TnIO Pipe -> IO Pipe
12:25:10 <RchrdB> albeit: here's a slightly better idea: forkIO a thread that takes 2 (Control.Concurrent.Chan a) values, one for input, one for output, then reads the input queue and calls your function, putting results onto the output queue. Use criterion to benchmark a function which calls putChan on the input queue and readChan on the output queue.
12:25:37 * hackagebot hydrogen-util 0.5 - Hydrogen Tools  http://hackage.haskell.org/package/hydrogen-util-0.5 (JulianFleischer)
12:25:48 <Cale> That's just  flip runReaderT
12:26:25 <RchrdB> Make sure that you benchmark it against another program that does the same thing, only with a trivial function like "const 1" in place of your actual complicated function, to get an idea of how much overhead that channel thing is adding.
12:26:42 <Cale> You can't go from a TnIO action to an IO action without supplying a TnConfig value though
12:27:01 <Cale> TnIO a is effectively the same thing as TnConfig -> IO a
12:27:19 <zmbmartin> Cale: I appreciate your help. What would that function look like. Just trying to learn and better understand?
12:27:21 <RchrdB> and be *slightly wary* about the results, because their validity might be very contingent on the number of cores in the machine and the exact version of the RTS
12:27:25 <Cale> zmbmartin: Which function?
12:27:32 <Cale> flip runReaderT
12:27:33 <Cale> ?
12:27:47 <RchrdB> albeit: does that make sense, please? ↑
12:27:57 <albeit> RchrdB: Still digesting it
12:28:06 <zmbmartin> Cale: TnConfig -> TnIO Pipe -> IO Pipe <- that is what you are saying is like flip runReaderT?
12:28:10 <Cale> yes
12:28:16 <Cale> :t flip runReaderT
12:28:17 <lambdabot> b -> ReaderT b m a -> m a
12:28:30 <Cale> b = TnConfig, m = IO, a = Pipe
12:30:37 <codygman> Why can't I use ♥ as a function name?
12:30:39 <albeit> RchrdB: Ah got it, that's pretty clever! But, if the main thread is very quick, and spawns a lot of child threads that take a while to complete, theres a risk of wayyy too many threads being built up and the later functions calls being significantly slower than the earlier calls, yeah?
12:30:48 <Cale> codygman: You should be able to use it as an infix operator
12:31:08 <Cale> let x ♥ y = x^2 + y^2 in 3 ♥ 4
12:31:12 <Cale> > let x ♥ y = x^2 + y^2 in 3 ♥ 4
12:31:13 <lambdabot>  25
12:31:16 <geekosaur> codygman, its Unicode character type is "symbol", so it can't be an identifier character. it *can* be an operator character
12:33:05 <Cale> I sometimes wonder whether monad transformers are a good thing to have around. They have some really cool applications, but I think there are more cases of abuse than cases where someone's code was affected in a positive way.
12:33:21 <merijn> > generalCategory '♥'
12:33:22 <lambdabot>  OtherSymbol
12:33:26 <RchrdB> albeit: yes! criterion should show you in its histograms, and it's one of the reasons why I personally think that it's probably for the best to have the cost of the child threads included in your timings.
12:33:55 <merijn> codygman: Use generalCategory to figure out the type of a unicode codepoint and refer to the Haskell Report to see which categories are valid for which names
12:34:53 <albeit> RchrdB: Its just that in production the calls of the main threads will be far less frequent that criterion doing a couple thousand in a second, so there will be less buildup of threads
12:35:38 * hackagebot hindent 3.5 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.5 (ChrisDone)
12:35:40 <albeit> Btw, how fast are forkIO and killThread? Does killThread sometimes need to wait on the thread its trying to kill?
12:36:14 <merijn> albeit: Yes
12:36:41 <RchrdB> albeit: I'm not certain that criterion will actually do very well at running a program like that. You might have to resort to sticking an external API on it, and continually calling it over and over again until the rate at which calls to it stabilises, since it may have complicated dynamics.
12:36:47 <merijn> albeit: killThread blocks until the exception is received by the other thread and that blocks if the other thread is executing with "mask/uninterruptibleMask"
12:36:59 <RchrdB> um, if it's not being called all that often, why are you even benchmarking it? ;P
12:37:21 <albeit> RchrdB: When it is called, it has be very fast ;)
12:38:08 <albeit> merijn: I'm guessing something like writing a large quantity of data to a socket would mean its executing with "mask/uninterruptibleMask"?
12:38:30 <albeit> (Like a 1GB ByteString, just for example)
12:38:35 <merijn> no
12:38:46 <merijn> Unless you're masking it yourself...
12:39:12 <RchrdB> albeit: you're only really worried about its end-to-end latency? I'd stick an external API on it, and write a program that looks at the clock, hits the API, looks at the clock again.
12:40:37 <albeit> RchrdB: Yeah just end-to-end latency. I may just do a simple timing api like you're suggesting
12:41:08 <albeit> merijn: Are there any rules of thumb that can help to tell when a thread may be masked?
12:42:04 <albeit> RchrdB: But how would that be different than just using criterion with the Chan setup or explicitly killing the threads after each function call?
12:42:26 <RchrdB> because you'd run that program once, wait half a second, run it again…
12:42:33 <RchrdB> as opposed to running it thousands of times per second
12:43:03 <albeit> But if killing threads is fast enough, running it thousands of times per second shouldnt matter?
12:43:45 <RchrdB> I would not do that because it's not something that you're going to be doing when you put this code into production, so it makes your test less realistic.
12:44:57 <albeit> True. I guess I couldn't use the results directly as the "true" latency, but they may be good enough for optimizing
12:47:50 <RchrdB> albeit: oh yeah sure, you can get away with all kinds of things when you're only measuring for the sake of knowing whether an optimisation that you tried is working or not. I just would be unwilling to use such a test for actual acceptance-testing. :)
12:48:44 <SwashBuckla> has anyone here done CIS194? I have a question that relates to one of the homework exercises that I have completed, but does not match their answers
12:49:00 <SwashBuckla> (aka B. Yorgey's UPenn class)
12:50:10 <SwashBuckla> my answer for the credit card validation question is here: https://bitbucket.org/nicholasgross/cis194/src/b17fc1cdfc33c37237a8ac38a95db72349a3ae12/Course/answers/01-intro.hs?at=master
12:50:39 * hackagebot cuda 0.6.5.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.5.0 (TrevorMcDonell)
12:51:01 <SwashBuckla> however, they have an example in the exercise which does not match the algorithm description: "Example: validate 4012888888881881 = True
12:51:10 <SwashBuckla> Example: validate 4012888888881882 = False
12:51:16 <SwashBuckla> these are not what I get
12:51:32 <zmbmartin> Cale: Thanks for your insight I am still lost. I would like to try and get the Pipe out and see if I can get it to work. Anyways I might just go a different avenue.
12:52:00 <zmbmartin> I am not sure I like the idea of providing a seperate TnConfig in different spots that is why I was trying this route.
12:58:31 <albeit> RchrdB: Okay. Thanks for the guidance and help!
13:00:39 <lpaste> SwashBuckla pasted “Does this code implement the described algorithm?” at http://lpaste.net/111968
13:00:57 <SwashBuckla> what do you guys think?
13:03:11 <RchrdB> albeit: apologies in advance if it all leads you hopelessly flying off a horrible cliff in a pile of burning wreckage! and good luck!
13:04:37 <gunnarsson> SwashBuckla: dunno, but it looks rather pretty, all that point-freeing.
13:07:26 <stolaruk> Is it somehow risky to call "unsafePerformIO . threadStatus . asyncThreadId $ a" inside an STM transaction?
13:07:37 <benzrf> stolaruk: probably
13:07:44 <benzrf> stolaruk: unsafePerformIO is usually risky
13:08:05 <stolaruk> benzrf: OK. I have a workaround in mind so I'll do that instead.
13:08:46 <SwashBuckla> gunnarsson: I may have gotten a bit obsessed
13:10:39 <Cale> stolaruk: It seems to me that it'd be a little weird to need the result of that inside an STM transaction, but I don't know what you're doing
13:10:41 <Cale> brb
13:11:19 <pjdelport> SwashBuckla: You have to double every second digit starting from the right, not the left.
13:11:32 <helpppls> is there documentation somewhere for the Trifecta parsing library?
13:11:35 <helpppls> I can't seem to find it...
13:12:15 <stolaruk> Cale: I'm operating on a list of asyncs inside a TMVar and I want to purge the list of asyncs which have finished
13:12:31 <pjdelport> SwashBuckla: In other words, doubleEveryOther [1,2,3,4] should get you [2,2,6,4], not [1,4,3,8]
13:12:35 <SwashBuckla> pjdelport: so I need doubleEveryOther = zipWith (*) (cycle [2,1])?
13:12:50 <pjdelport> SwashBuckla: No, that will still count from the left.
13:12:53 <SwashBuckla> ah
13:12:55 <SwashBuckla> no I see
13:12:58 <SwashBuckla> thanks
13:13:28 <pjdelport> SwashBuckla: The most straightforward way is to have doubleEveryOtherRev = reverse . doubleEveryOther . reverse
13:13:39 <SwashBuckla> yep
13:13:57 <SwashBuckla> or toDigitsRev (as in the spec)
13:17:29 <SwashBuckla> pjdelport: yeah that worked. Thanks for that -- I figured it didn't make a difference whether we start from the right or left, but of course it does
13:18:01 <c_wraith> CC# verification?  I love how often that's given as an "easy" assignment that really has lots of tricky bits
13:18:25 <SwashBuckla> :P
13:18:47 <Darwin226> How would I express something like this http://lpaste.net/111969 in the haskell typesystem? Basically, I want to capture a tree consisting of maps and zipwiths on lists that has [a] as a final result type. I don't care about the b and c types but I do care that they match like they should.
13:19:02 <SwashBuckla> c_wraith: *luckily* I have done CS and worked through LYAH
13:19:15 <SwashBuckla> I would say it's still not particularly easy
13:19:33 <c_wraith> SwashBuckla: yeah, you clearly know how to solve problems in general.  This one really does have tricky bits, though.
13:20:13 <merijn> Darwin226: I think you might be able to capture that using RankNTypes (I don't think this requires existentials, but I'm not sure)
13:20:36 <merijn> Darwin226: i.e. "forall b c . Zip (b -> c -> a) (Tree b) (Tree c)"
13:21:06 <Darwin226> merijn: I see, I'll look into it. Thanks
13:21:48 <albeit> :t (:)
13:21:49 <lambdabot> a -> [a] -> [a]
13:23:31 <c_wraith> Darwin226: it can be encoded with rank n types, but the existential formulation is way cleaner (especially with GADT syntax). What are you doing that needs that representation in the first place?
13:23:43 <pjdelport> SwashBuckla: Do you want feedback on the rest of that, too, or are you planning to learn and improve more as you do the course?
13:24:11 <rqiu> :t (.)
13:24:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:24:23 <rqiu> @:t
13:24:23 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
13:24:44 <SwashBuckla> pjdelport: if you don't mind feedback would be great!
13:24:51 <SwashBuckla> I will of course keep on with the course
13:24:59 <Celestic> Hey
13:25:14 <Celestic> I've been having an issue with an assignment I'm working on
13:25:21 <Celestic> if anyone with some php exp has a minute I'd appreciate it
13:25:28 <SwashBuckla> I've just realised lpaste has done some hlint stuff, for example. I could enable that :)
13:25:40 <c_wraith> Darwin226: that is, what operations do you need to perform that you don't get from just [a]?
13:25:45 <pjdelport> SwashBuckla: Cool. :) Some small things: you can rewrite some of those list comprehensions much more simply using e.g. map
13:25:55 <Darwin226> c_wraith: I want to translate that tree into OpenCL C to run on the GPU. Unfortunately, I was hoping there was some trivial way to do it that I could also use in F#. There are so many nice type system features missing in that language
13:25:58 <pjdelport> SwashBuckla: toStrings = map show
13:26:21 <c_wraith> Darwin226: hmm.  can you do that with an opaque function representation?
13:26:44 <Darwin226> c_wraith: opaque function representation?
13:27:02 <pjdelport> SwashBuckla: You make pretty good use of "functional pipeline" style for the other functions, though.
13:27:32 <pjdelport> SwashBuckla: The biggest stylistic advice would be to avoid using read and show for parsing and unparsing integers, like that.
13:27:44 <c_wraith> Darwin226: well, all you know is that there's *some* function.  You don't have a clue what that function does. If you want to run that function in OpenCL, that sounds problematic.  Though maybe this is just a simplification, and you have a bigger case where there's an openCL function type.
13:27:49 <SrPx> Hello, does anyone know where is a talk of some guy who claimed type systems are good, but most statically typed languages get modules wrong?
13:27:51 <SwashBuckla> yeah I realise it was a bit mischevious
13:27:59 <SrPx> arg not talk, a blog post *
13:28:04 <SwashBuckla> better to do the computation
13:28:13 <c_wraith> SrPx: sounds like something from robert harper.
13:28:17 <SrPx> the guy mentions racket as the "biggest proponent of dynamic typing" as of today
13:28:25 <pjdelport> SwashBuckla: It's a quick&dirty thing, but it's not *really* ideal: read and show will happily accept and produce negative integers and all kinds of other things potentially.
13:28:42 <Cale> stolaruk: Use pollSTM perhasp
13:28:45 <Cale> perhaps*
13:28:45 <Darwin226> c_wraith: Honestly, I would be already done if I was doing it in haskell. This is just my 7th (or something) attempt to be as typesafe as possible in a langauge without typeclasses
13:29:00 <c_wraith> Darwin226: ah, ok.  In that case - good luck.
13:29:07 <Darwin226> c_wraith: Yeah, thanks.
13:29:07 <pjdelport> SwashBuckla: It would be a good exercise to implement a mathematically sound base-10 digit extraction function.
13:29:12 <SrPx> c_wraith: yay thank you!!!
13:29:15 <pjdelport> SwashBuckla: Do you know how to do that in general?
13:29:17 <Cale> stolaruk: The results for which pollSTM gives Nothing are the asyncs which are still running
13:29:23 <SrPx> c_wraith: that was neat, how did you do that! :) +++
13:29:51 <c_wraith> SrPx: he's the most vocal proponent of strong modules in staticly typed languages I know of - but it was just a guess.
13:29:57 <stolaruk> Cale: Ok... yeah, I'd been looking for an async library function that would give me the "status" of an asyn... I guess I looked that one over :(
13:29:59 <stolaruk> thanks
13:30:07 <SwashBuckla> pjdelport: mod 10, 100, 1000 etc to get each position?
13:30:50 <pjdelport> SwashBuckla: Well, there's a slightly easier algorithm: you can repeatedly divMod by 10 (or any other fixed base) to extract the lowest digit, and get the remaining number.
13:30:56 <pjdelport> in one operation.
13:31:17 <SwashBuckla> oh wow
13:31:39 <pjdelport> SwashBuckla: Have you worked with folds / unfolds before?
13:32:16 <SwashBuckla> not much, no
13:32:48 <SwashBuckla> perhaps it will be something I can come back to after going through the course a litte more?
13:32:56 <SwashBuckla> I don't know if it is encountered
13:33:04 <SwashBuckla> could play around with it now :)
13:33:27 <c_wraith> this can be done with unfoldr, but unfoldr's signature really bugs me.  can't say why.  :)
13:33:49 <SwashBuckla> :t unfoldr
13:33:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:34:01 * SwashBuckla faints
13:34:45 <Enigmagic> they tend to follow the same pattern tho ;-)
13:34:47 <c_wraith> > unfoldr (\x -> if x > 0 then Just ('!', x - 1) else Nothing) 10
13:34:48 <lambdabot>  "!!!!!!!!!!"
13:34:55 <Enigmagic> :t Data.Tree.unfoldTreeM
13:34:56 <lambdabot> Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
13:35:33 <c_wraith> yeah, I can write terrible unfolds!
13:36:08 <SwashBuckla> haha
13:36:53 <blume> I have a B-Tree which has up to, but at most 4 elements in it. Is there a difference concerning usefulness to having the type like Branch (Btree a) (Btree a) (Btree a) (Btree a) compared to Branch (Btree a, Btree a, Btree a, Btree a)? Also, is there a more elegant way to say "at most 4 nodes in the branch" or does it suffice to just have empty nodes?
13:38:02 <mauke_> > let foo n = case n `divMod` 10 of (d, m) -> (if d /= 0 then foo d else "") ++ [intToDigit m] in foo 123
13:38:03 <lambdabot>  "123"
13:38:06 <Cale> blume: You could invent a type for "at most 4 things of type a" if you like. I suppose whether that's a good idea depends on how you end up using it
13:39:28 <pjdelport> c_wraith: unfoldr's signature makes a lot more sense when you consider a "truer" signature for foldr: (Maybe (a, b) -> b) -> [a] -> b
13:39:39 <blume> i guess i'll just go with the tuple-variant and see where it gets me, thanks Cale
13:39:41 <Cale> It may be more convenient than the tuples in some cases, because you'll have fewer cases to deal with where the empty nodes occur in various positions, for instance.
13:41:08 <baadupo__> I Want to use the Math.FFT library, more specific the dht function. But the type  (dht :: (FFTWReal r, Ix i, Shapable i) => CArray i r -> CArray i r )is scary, and the documentation is not helping me. What is a function [double] -> [double] that wraps that transformation?
13:42:50 <baadupo__> :t Math.FFT.dht
13:42:50 <lambdabot> Not in scope: ‘Math.FFT.dht’
13:44:11 <Cale> baadupo__: So, at present, the only instance of FFTWReal as far as I can see is Double
13:44:38 <r444> can i explicitly state module build order in cabal manifest?
13:44:44 <Cale> and CArray is an instance of IArray, which means that you can create one of those using listArray
13:44:56 <Cale> and get its elements with elems
13:45:17 <Cale> So, perhaps something like...
13:45:53 <Cale> elems . dht $ listArray (0, length xs - 1) xs
13:45:58 <merijn> blume: The former (without the tuple) could be faster
13:46:13 <merijn> blume: The tuple adds an extra layer of indirection, unless GHC unboxes it
13:46:44 <Cale> The only instances of Shapable are Int and tuples of Int, so you are restricted in what sort of indices you use for your arrays
13:47:41 <Cale> baadupo__: Most of the important operations on CArrays are in here: http://hackage.haskell.org/package/array-0.4.0.0/docs/Data-Array-IArray.html#t:IArray
13:48:20 <ReinH> Cale: you can't spell FFTWReal without FTW.
13:48:34 <blume> merijn: i just realized i need extra data in every branch anyways, so ill drop the tuples. It just looked kind of bloated to have 4 arguments.
13:48:46 <Cale> FFTW stands for Fastest Fourier Transform in the West
13:48:55 <ReinH> Cale: I figured.
13:48:58 <baadupo__> Cale, thanks.
13:49:22 <ReinH> merijn: GHC can't unbox it because of bottoms?
13:50:47 <SwashBuckla> thanks for your feedback/help all :)
13:51:02 <latk> I'm trying to understand the Attoparsec Parser type. Most tutorials, and how I've used it thus far, say things like Parser Int, which means that  the parse returns an Int. What do the two parameters in the definition (http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-Types.html#t:Parser) mean? The docstring talks about the internal state t, but I can't even see a reference to t..
13:51:44 <Cale> latk: I think the documentation is a little out of date
13:51:47 <Cale> (probably)
13:52:05 <albeit> I'm using an IOStreams OutputStream attached to a socket, and writing a ByteString takes an unsually variable amount of time... the range is between 30 and 60 microseconds (from criterion). Is that normal? The test computer is a production server with zero load
13:52:05 <latk> Cale: Ah, okay so presumably a referres to the internal state?
13:52:46 <geekosaur> latk, i there is the type of the thing you are parsing: String, Bytestring, Text, etc.
13:52:51 <geekosaur> (very roughly)
13:52:55 <geekosaur> a is the result
13:52:56 <Cale> yeah
13:53:59 <latk> Hm, okay. I'm looking at it in the context of Prefix (found in this package http://hackage.haskell.org/package/attoparsec-expr-0.1.1.1/docs/Data-Attoparsec-Expr.html). The type Parser t (a -> a) means that it parses something of type t, and returns a function ?
13:55:00 <Cale> Yes, that's right
13:55:16 <latk> Cale: Cool, thanks.
13:56:04 <Cale> So, it might look for "-" and produce negate as its result, for instance.
13:56:35 <Cale> See the example for buildExpressionParser below
13:56:57 <latk> Cale: Sadly the example was lifted directly from the Parsec version, so its a little different.
13:57:07 <latk> I don't know what reversedOp does, for example :p
13:57:16 <Cale> oh
13:58:03 <Cale> Yeah, it's mostly just "look for this string made up of symbol characters and eat trailing whitespace" iirc.
13:58:25 <latk> Hm, okay
13:58:32 <latk> That would make sense
13:58:37 <Cale> Or you might imagine that it's a token parser, and it'll look for an appropriate sort of token
13:59:38 <Cale> (though I'm not sure attoparsec does token parsers)
14:00:41 <benbangert> I just noticed in https://github.com/facebook/Haxl/tree/master/example/sql that the example shows "data UserReq a where", whats the 'where' bit mean when applied in a data declaration?
14:00:58 <mauke_> GADT
14:01:17 <benbangert> mauke_: ah, thats the reason for the language ext, thanks
14:02:02 <thang1thang2> I love the idea of ADTs and GADTs but I'm still fuzzy on what they actually are, tbh... It feels like that for a lot of the language, personally, but ah well
14:04:02 <mauke_> ADTs are things made of (a, b) and Either a b
14:04:54 <vanila> GADT is more complex, leave it to later
14:05:17 <thang1thang2> Yeah GADTs are something I'm not even worrying about. It's one of those things I'm pretty sure come when you need them and not a second before
14:05:32 <benbangert> or unless you want to implement a request type / datasource for haxl ;)
14:05:41 * hackagebot llvm-pretty 0.2.0.0 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.2.0.0 (TrevorElliott)
14:05:43 * hackagebot llvm-pretty-bc-parser 0.1.2.2 - LLVM bitcode parsing library  http://hackage.haskell.org/package/llvm-pretty-bc-parser-0.1.2.2 (TrevorElliott)
14:05:50 <mauke_> GADTs let you set the result type of constructors
14:06:16 <benbangert> yea, just skimmed http://en.wikibooks.org/wiki/Haskell/GADT on that
14:06:40 <benbangert> should be enough to define my own haxl request types at least
14:07:39 <thang1thang2> Hopefully :p
14:13:48 <benbangert> thang1thang2: I'm sure the compiler will guide me as usual ;)
14:14:17 <thang1thang2> After all, if it compiles it's correct, eh? lol
14:14:52 <josephle> benbangert: just don't do too crazy things. GHC might tell you "My brain just exploded"
14:15:07 <benbangert> josephle: so far my brain always explodes before the compilers
14:15:32 <josephle> with existentials and GADTs, it might happen at the same time ;)
14:15:41 <benbangert> thang1thang2: I heard some PhD ppl proved that for surez ;)
14:15:42 * hackagebot hlint 1.9.7 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.7 (NeilMitchell)
14:15:44 * hackagebot hydrogen-syntax 0.5 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.5 (JulianFleischer)
14:15:47 <thang1thang2> I suppose it's testament to how awful of a programmer I am that I've managed to compile a haskell program that was utterly incorrect
14:16:11 <benbangert> thang1thang2: once I used ADT's + record types, that occured quite quickly
14:17:54 <thang1thang2> What were you trying to build?
14:18:27 <benbangert> thang1thang2: nothing fancy, but I used a record accessor and it wasn't constructed with that... so kaboom
14:18:49 <benbangert> compiler was fine with it, runtime ... not so much
14:20:18 <thang1thang2> So basically you tried to access things that weren't able to be accessed because you had no method to access things?
14:21:16 <benbangert> uh, maybe?
14:21:47 <karshan> Hey, does anyone know if you can get ghc-mod or equivalent working with ghcjs ?
14:21:56 <thang1thang2> lol okay, just making sure I understood everything you said. I still consider myself more or less a mildly educated idiot when it comes to haskell
14:22:27 <napping> benbangert: Mixing records and ADTs tends to lead to partial functions
14:23:43 <benbangert> thang1thang2: I have a datatype like http://paste.ofcode.org/sGJKz5g4BArFk95A6rfDMF, and called treeUsage in a func without verifying it was constructed with Tree (it was an Empty)
14:24:05 <benbangert> compiler is fine calling those record accessors on a "Tree" type, it didn't know it was an Empty till run-time
14:24:23 <napping> hmm, yeah
14:24:30 <napping> that's a bit annoying
14:25:20 <thang1thang2> http://covariant.me/stuff/posts/2013-06/vado-and-newbuild.org this seems to suggest that someone's used ghcjs with ghc-mod together
14:25:31 <benbangert> napping: yea, I learned quickly that when making something like that, don't expose the record accessors as a public API, make something similar that returns Maybe's
14:26:32 <napping> The safest solution using separate types for non-empty tree and maybe-empty trees
14:26:51 <napping> probably remove the Empty case from Tree, and change Tree to Maybe Tree everywhere?
14:27:07 <benbangert> yea
14:27:38 <benbangert> would be nice if hlint complained about it
14:27:38 <thang1thang2> What trees would be guaranteed to be non-empty?
14:28:00 <napping> I'm surprised, HLint complains about all sorts of things, and stuff that seems way less bad
14:28:09 <napping> partial record fields seem like exactly the sort of thing it should warn about
14:28:27 <merijn> napping: HLint doesn't full parse the code, afaik
14:28:35 <thang1thang2> It sounds like the kind of thing most people forget about becaue they quickly learn to "never do it" I guess?
14:28:37 <merijn> napping: So it can't tell if record fields are partial
14:28:47 <merijn> Also, GHC should warn about that with -Wall
14:28:48 <thang1thang2> ooh, that's a good reason for it :p
14:29:10 <merijn> You should always use -Wall and selectively disable warnings
14:29:33 <napping> oh, huh. What does HLint do instead?
14:29:48 <merijn> It just looks for patterns in the source
14:30:00 <napping> I'd think even the most cursory parser would be enough to tell you have multiple record-style constructors in one type
14:30:09 <tommd> merijn: I think GHC 8.0 is adding a -Whenever flag. The idea is if you always believe there is a legitimate warning you will think harder about your code prior to distribution.
14:31:08 <SwashBuckla> how would you format the following so it is not on a single line?
14:31:09 <SwashBuckla> intToString n = case (n `divMod` 10) of (d, m) -> (if d /= 0 then intToString d else "") ++ [intToDigit m]
14:31:18 <thang1thang2> a -whenever?
14:31:21 <merijn> SwashBuckla: liberal use of let/where
14:31:37 <merijn> SwashBuckla: FYI parens around "n `divMod` 10" are redundant
14:31:50 <SwashBuckla> ok :)
14:31:53 <Iceland_jack> SwashBuckla: You can also do
14:31:53 <Iceland_jack>     intToString ((`divMod` 10) -> (d, m)) = ...
14:31:53 <Iceland_jack> using ViewPatterns
14:32:02 <thang1thang2> That code also looks really procedural like
14:32:06 <merijn> Iceland_jack: I think that's worse, not better
14:32:11 <vanila> Use unfoldr
14:32:51 <Iceland_jack> merijn: Well then you can do this: :)
14:32:51 <Iceland_jack>     intToString (DivBy10 d m) = ...
14:33:02 <napping> tommd: what?
14:33:14 <mauke_> thang1thang2: it's C code :-)
14:33:36 <thang1thang2> That explains it, but why c code inside haskell?
14:33:42 <vanila> > let foo (0,0) = Nothing ; foo (p,q) = Just (q,p) in unfoldr (foo . flip divMod 10) 323513
14:33:43 <lambdabot>  [3,1,5,3,2,3]
14:34:05 <mauke_> > let foo (0,0) = Nothing ; foo (p,q) = Just (q,p) in unfoldr (foo . flip divMod 10) 0
14:34:06 <lambdabot>  []
14:34:13 <mauke_> > let foo n = case n `divMod` 10 of (d, m) -> (if d /= 0 then foo d else "") ++ [intToDigit m] in foo 0
14:34:15 <lambdabot>  "0"
15:04:00 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
15:04:00 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
15:04:13 <napping> begriffs: I think it mostly comes up with the historical IOException, where various types of problems were constructors in the same type
15:06:03 <gdoteof> how can i do  `  let foo = if something; then val; else valueFromMonadicAction
15:06:19 <gdoteof> without a do; val <- monadicAction; val
15:07:27 <mauke> foo <- if something then return val else action
15:08:32 <mauke> (if something then ($ val) else (action >>=)) (\foo -> ...)
15:08:54 <benzrf> gdoteof:
15:08:56 <benzrf> :t return
15:08:57 <lambdabot> Monad m => a -> m a
15:09:29 <mauke> (if something then (val &) else (action >>=)) (\foo -> ...)
15:10:09 <gdoteof> benzrf: i think i need the opposite of return?
15:10:19 <benzrf> gdoteof: there is no opposite of return for monads
15:10:24 <gdoteof> mauke: that's what i was trying, but it it doesn't seem to work
15:10:28 <benzrf> 06:07 < mauke> foo <- if something then return val else action
15:10:34 <gdoteof> benzrf:   <- is opposite of return
15:10:40 <benzrf> gdoteof: n
15:10:44 <monochrom> (\foo -> ...) & (... (val &) ... (action >>=))  :)
15:10:47 <benzrf> <- is just sugar for bind
15:11:15 <gdoteof> i see.  okay i was trying to do like mauke's 2nd eample
15:11:59 <gdoteof> i keep getting parsing errors though
15:12:34 <mauke> that means you're not cool enough
15:12:43 <gdoteof> obv
15:13:20 <thang1thang2> did you forget to `import coolness.factor`?
15:14:17 <mauke> {-# LANGUAGE IceCold #-}
15:14:18 <gdoteof> well, i didn't forget, but i couldn't figure out how
15:15:42 <etandel> lol
15:15:44 * hackagebot riak 0.7.2.1 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.7.2.1 (MarkHibberd)
15:16:40 <etandel> cool :: (Uncool a, Cool b) => a -> b
15:21:26 <acowley> Is "memcycler" a terrible package name for a foreign allocation manager (that recycles allocations)?
15:21:33 <benzrf> @let class Uncool a where intify :: a -> Int
15:21:36 <lambdabot>  Defined.
15:21:44 <benzrf> @let class Cool b where deint :: Int -> b
15:21:46 <lambdabot>  Defined.
15:21:56 <benzrf> @let cool = deint . intify
15:21:57 <lambdabot>  Defined.
15:21:58 <benzrf> :t cool
15:21:59 <lambdabot> (Uncool a, Cool c) => a -> c
15:22:03 <benzrf> B)
15:22:06 <mauke> :t toEnum . fromEnum
15:22:07 <lambdabot> (Enum a, Enum c) => a -> c
15:22:11 <benzrf> mauke: aw
15:22:40 <mauke> > fromEnum (1 % 2)
15:22:42 <lambdabot>  0
15:22:50 <mauke> > fromEnum (1 :+ 2)
15:22:51 <lambdabot>  No instance for (GHC.Enum.Enum (Data.Complex.Complex a0))
15:22:51 <lambdabot>    arising from a use of ‘GHC.Enum.fromEnum’No instance for (GHC.Num.Num a0) ...
15:22:51 <lambdabot>  The type variable ‘a0’ is ambiguous
15:22:51 <lambdabot>  Note: there are several potential instances:
15:22:51 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
15:23:15 <monochrom> "take this advice, as an Enum to an Enum: use Int"
15:25:22 <joe9> anyone here involved with barrelfish OS http://www.barrelfish.org/ ?
15:26:35 <simpson> joe9: It doesn't appear to have much to do with Haskell...is there Haskell involved?
15:28:15 <thang1thang2> "research operating system" with a confusing mission statement and outdated website sounds like haskell related to me :p
15:30:36 <acowley> Does haskell-cabal-mode help with formatting at all? Writing a description section is a pain.
15:30:38 <thang1thang2> It sounds interesting, though. It's basically an operating system designed to be highly scalable to multi-core systems, and I'm thinking the hope is to make an OS that can manage all the resources so that applications can be made as if you were running a "single core" machine and have the OS itself do the multi-threading and multi-coring, etc for free
15:32:26 <cite-reader> Do we have an equivalent to Perl's HTML::Entities::decode_entities anywhere?
15:33:52 <joe9> thang1thang2: I read somewhere that barrelfish OS is geared towards haskell concurrency.
15:34:14 <joe9> simpson: https://ghc.haskell.org/trac/ghc/wiki/Porting%20GHC%20to%20Barrelfish
15:34:34 <damianfral> I'm working on a EDSL to plot graphs built over the free monad: http://lpaste.net/111958. The problem I have is related with the function "extract" (line 127). If I add a new "instruction" to the free monad, I have to extend "extract" to support it...  How could I solve this "problem" and make my EDSL more extensible? (I don't care if this needs a complete refactoring, I'm learning :) )
15:39:05 <thang1thang2> when you see a function that has the same exact content for 4 lines, it's a good indicator you probably generalize it :p
15:39:45 <thang1thang2> You have two cases for extract, basically, the Pure a = a and the Roll (something _ n) = extract n
15:41:18 <damianfral> thang1thang2: I think that's wrong; "something" needs to be a constructor, I am right?
15:42:46 <damianfral> thang1thang2: line 129, column 24:
15:42:46 <damianfral>   Parse error in pattern: something
15:42:53 <hexagoxel> when profiling, is there a way to distinguish class methods? my profile contains a sequence of (==)'s at one point, and it might be helpful to know what is being compared
15:43:05 <thang1thang2> oh, sorry, when I said "something" I didn't mean "something" literally, I was using that as a placeholder
15:44:01 <pjdelport> hexagoxel: You can manually insert cost center annotations.
15:44:27 <pjdelport> hexagoxel: Have you read https://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#scc-pragma ?
15:44:40 <damianfral> thang1thang2: so, <something> must be a contructor... so I need to pattern match against every contructor
15:45:37 <damianfral> thang1thang2: I would need something like retract, but retract requires a Monad, and Graph is "only" a Functor
15:46:28 <simpson> joe9: Nifty.
15:49:21 <hexagoxel> pjdelport: meh.. i had already opened but not read that page.. thanks :)
15:52:36 <thang1thang2> The easiest way I can think of to do the pattern matching is to have your first Pure a, and then have the general case since the only thing you're changing is the constructor
15:54:01 <thang1thang2> I can't figure out how to do it with just a functor, though...
15:54:47 <SrPx> I guess I understand something wrong about haskell's runtime. A recursive sum function such as `s x = if x == 0 then 0 else x + s (x - 1)` takes less time to compute than the time it would take to fill the memory with empty values!
15:55:46 <SrPx> For example, `s 50000000` computes in no time, while filling that memory with zeros take some time. But for computing `s 50000000` you need to AT LEAST fill the memory with the recursive calls, `5000 + 4999 + 4998 + s 4997` ... etc
15:56:09 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:56:09 <SrPx> so how is that possible? Am I understanding it wrong, does haskell somehow not fill the memory when calling a recursive function like that?
15:56:42 <ThreeOfEight> SrPx: What do you mean by "filling the memory"?
15:56:57 <thang1thang2> He probably means zeroing out the memory allocation space
15:57:14 <ThreeOfEight> It will not expand the expression to 5000 + 4999 + … + 0 and then evaluate it
15:57:18 <SrPx> I mean that, when you are computing the recursive calls of "sum x", you need to fill the a stack somewhere in memory...
15:57:22 <pjdelport> SrPx: GHC's GC is very good.
15:57:43 <pjdelport> SrPx: In general, stuff that's allocated and not referenced again takes close to zero overhead to collect.
15:57:44 <ThreeOfEight> oh
15:57:46 <SrPx> pjdelport: but you still can't garbage collect a half-done compution...
15:57:47 <Axman6> SrPx: that memory will only be filled if you demand the value returned by s 50000000
15:57:48 <ThreeOfEight> it's not tail-recursive
15:57:52 <ThreeOfEight> in that case, it will, yes
15:58:37 <SrPx> Axman6: exactly what I think, and I am printing the result. Maybe I am measuring it wrong? Is there a recommended way to measure memory/time usage of a haskell program?
15:58:54 <ReinH> SrPx: when you say that it "computes", what did you do to compute it?
15:58:58 <ThreeOfEight> :set +s in GHCI
15:59:03 <ReinH> Did you print the result?
15:59:03 <Axman6> SrPx: in ghci, you can use :set +s (I think, cinsult :help to be sure)
15:59:10 <SrPx> ReinH: `main = print $ s 500000...`
15:59:16 <SrPx> yea
15:59:17 <Axman6> > let s 0 = 0; s n = n + s (n-1) in s 50000000
15:59:18 <ThreeOfEight> although the results in GHCI may differ greatly from those in GHC
15:59:21 <lambdabot>  mueval-core: Time limit exceeded
15:59:24 <Axman6> > let s 0 = 0; s n = n + s (n-1) in s 5000000
15:59:27 <ReinH> How did you compile it?
15:59:28 <lambdabot>  mueval-core: Time limit exceeded
15:59:34 <SrPx> ReinH: no optimizations
15:59:43 <ThreeOfEight> if you compiled your program, you can just run it with "time Main" on Unixoid systems
15:59:52 <ThreeOfEight> and it will at least display the time it took (though not the memory)
15:59:54 <SrPx> okay since you guys are surprised I must be doing something wrong in my benchmark, never mind me
16:00:07 <Axman6> feel free to share the code
16:00:12 <Axman6> @where lpaste
16:00:12 <lambdabot> http://lpaste.net/new/haskell
16:00:15 <pjdelport> SrPx: Are you actually printing out the result?
16:00:33 <pjdelport> If not, the benchmark is probably doing nothing :)
16:04:55 <activeaspect> hello, i have a question about dynamic linking libraries at runtime that im hoping someone might be able to help me answer.
16:05:41 <activeaspect> i want to build a cli tool that checks a rest endpoint to see if there is an updated library and download it. then use it to run its job.
16:06:55 <SrPx> okay guys I had a zero wrong
16:07:04 <activeaspect> my initial thoughts was that this would need to spawn a child process and delegate the inputs to it. another option may be to compile src using System.Eval (plugins package)
16:07:27 <SrPx> http://lpaste.net/111976 still, it is just 5x slow than filling a stack with nothing
16:07:36 <SrPx> it is almost like a recursive call is costless
16:07:43 <SrPx> which makes no sense
16:09:53 <alrunner4> tail recursion makes sense, doesn't it?
16:11:00 <karshan> alrunner4: the function he is talking about isn't tail recursive
16:11:53 <karshan> SrPx: what are you assuming for the stack activation record size ?
16:24:40 <merijn> SrPx: recursive calls are pretty much costless in haskell
16:25:22 <merijn> SrPx: In fact, all fuction calls are pretty much costless in haskell
16:26:31 <merijn> Also, don't underestimate GHC optimiser
16:26:59 <ThreeOfEight> But non-tail-recursive recursive function calls can rack up a significant amount of memory usage
16:27:06 <pjdelport> GHC brings your overheads inline. :)
16:27:15 <ThreeOfEight> And failing to enforce strictness can also sometimes be problematic
16:27:43 <merijn> ThreeOfEight: No
16:27:52 <merijn> ThreeOfEight: Only strictness can cost memory
16:28:18 <merijn> ThreeOfEight: Whether a call is a tail call is irrelevant for memory consumption in haskell
16:28:37 <merijn> (it might affect allocation and thus speed, but not memory usage)
16:28:39 <ThreeOfEight> Even with integers?
16:29:14 <merijn> ThreeOfEight: Yes, the only leaks are thunk leaks
16:29:28 <ThreeOfEight> in the above example, don't you get s 5000 → 5000 + s 4999 → 5000 + 4999 + s 4998 …
16:29:32 <merijn> ThreeOfEight: i.e. SrPx's call leaks, but not because it's not a tail call, but because the thunk build up
16:30:01 <ThreeOfEight> Yes, but if it were a tail-recursive call, the thunk would not grow like this, would it?
16:30:06 <merijn> ThreeOfEight: Trivial counter example: "map f (x:xs) = f x : map f xs" <- not a tail call, O(1) memory
16:30:22 <ThreeOfEight> Yes, because you don't have to evaluate the entire list
16:30:29 <merijn> ThreeOfEight: If it was a tail call *and* added strictness, then it wouldn't leak, correct
16:30:47 * hackagebot Hclip 3.0.0.3 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-3.0.0.3 (JensThomas)
16:31:30 <ThreeOfEight> I used to think that operations on primitive types in connection with non-tail-recursive calls and/or lazy evaluation can be problematic
16:31:50 <ThreeOfEight> Whereas if you compute something like a list, tail recursion doesn't matter
16:32:14 <merijn> "s x = go 0 x where go r 0 = r; go r x = let next = r + 1 in next `seq` go next (x - 1)"
16:32:43 <merijn> ThreeOfEight: It's not a matter of primitive-ness, but strictness and WHNF
16:33:24 <merijn> ThreeOfEight: The result of map is in WHNF, the result of (+) requires evaluating both arguments before returning (well, for Int, you can implement lazy implementation of + for other types)
16:33:51 <ThreeOfEight> Yes, that is what I meant by primitive
16:34:05 <ThreeOfEight> I didn't really know a better word for it
16:34:41 <ThreeOfEight> So you are still saying that non-tail-recursive functions never cost memory?
16:34:43 <ThreeOfEight> Even with integers?
16:35:05 <Axman6> no..
16:36:02 <monochrom> everything costs memory
16:36:08 <merijn> ThreeOfEight: I'm not saying they never cost memory, I'm saying that "whether they cost memory is orthogonal to whether they're tail calls"
16:36:13 <SrPx> merijn: what happens when I call a function, specifically? How does `(\x → (+ (+ x x) (* x x)) 7` becomes `(+ (+ 7 7) (* 7 7))`at a point? What if 7 is a huge structure, is it copied? Wouldn't it make the thing too big, if there are many occurrences of `x` on the function body?
16:36:22 <SrPx> whoops, not supposed to be to you, merijn
16:36:48 <merijn> ThreeOfEight: GHC doesn't do "tail call optimisation" (alternative point of view: GHC does tail call optimisation on all functions, even those that aren't tail recursive)
16:38:03 <monochrom> non-tail vs tail is a false dichotomy. there are ways both cost the same amount of memory, by different routes in some sense. see my http://www.vex.net/~trebla/haskell/lazy.xhtml
16:38:05 <merijn> ThreeOfEight: The issue is thunk leaks, a common form of thunk leaks is a "too lazy" accumulator, which can be resolved by making the accumulator strict, which you can't do without passing it as an argument
16:38:54 <merijn> ThreeOfEight: So solving that particular type of thunk leak requires making the function tail recursive, but that doesn't mean that the lack of tail recursion is what was the problem with the original
16:39:27 <ThreeOfEight> That sounds a bit contradictory
16:39:36 <ThreeOfEight> How can it not be a problem if fixing it solves the problem
16:40:29 <monochrom> if you want "take 1 (map f xs)" to use O(1) space, you do not want map to be tail-recursive.
16:40:38 <hpc> it masks the underlying issue
16:40:42 <ThreeOfEight> I am aware of that.
16:40:59 <merijn> ThreeOfEight: Just making it tail recursive doesn't fix it
16:41:13 <merijn> ThreeOfEight: If you just make it tail recursive, but don't add strictness it *still* leaks
16:41:20 <merijn> ThreeOfEight: Adding strictness stops the leak
16:41:44 <ThreeOfEight> As I said, tail-recursive+lazy is good for "composite" types such as ADTs, bad for "primitive" types such as integers, doubles, …
16:41:47 <ThreeOfEight> that's what I learned
16:41:59 <merijn> ThreeOfEight: "sum (x:xs) = x + sum xs" <- leaks, right?
16:42:25 <ThreeOfEight> just adding strictness doesn't solve the problem either, does it
16:42:41 <merijn> ThreeOfEight: It would, but it's not possible
16:43:20 <ThreeOfEight> I am not sure how to interpret that statement.
16:43:34 <monochrom> list is a composite ADT, yet the way "take 1 (map f xs)" takes O(1) space is not by going tail-recursive. this refutes the "tail+lazy is good" theory.
16:43:43 <merijn> ThreeOfEight: "sum l = go 0 l where go r [] = r; go r (x:xs) = go (r+x) xs" <- tail recursive, still leaks
16:44:02 <ThreeOfEight> merijn: because it isn't strict, right?
16:44:20 <merijn> ThreeOfEight: "sum l = go 0 l where go r [] = r; go r (x:xs) = let next = r + x in next `seq` go next xs" <- doesn't leak, because seq adds strictness
16:44:33 <ThreeOfEight> oh
16:44:34 <ThreeOfEight> sorry
16:44:47 <merijn> ThreeOfEight: Now, try adding strictness to "sum (x:xs) = x + sum xs" without rewriting it to tail recursive form
16:44:54 <ThreeOfEight> What I meant was tail-recursive+strict is good for primitive types, non-tail-recursive+lazy is good for composite ones
16:45:10 <merijn> ThreeOfEight: Not all primitive types behave like this
16:45:15 <monochrom> then I agree.
16:45:20 <ThreeOfEight> merijn: which ones don't?
16:45:35 <ThreeOfEight> I never claimed that tail-recursive alone is enough or that strict alone is enough for this example
16:45:36 <merijn> ThreeOfEight: In fact, given that it's possible to add your own primitive types there's not a single thing you can say that holds for all primitive types :)
16:45:48 * hackagebot haskades 0.2.1 - Utility to generate bindings for BlackBerry Cascades  http://hackage.haskell.org/package/haskades-0.2.1 (StephenWeber)
16:45:54 <ThreeOfEight> As I said, I used the term “primitive” because I wasn't aware of a better term
16:46:12 <ThreeOfEight> What I mean is “Types where partial information is of no use”
16:46:21 <ThreeOfEight> like, with a list, it is already nice if you only know its head
16:46:30 <merijn> ThreeOfEight: Anyway, your intuition is probably mostly correct
16:46:31 <ThreeOfEight> but an integer is kind of opaque
16:47:11 <monochrom> you may like the word "flat" for those all-or-nothing types
16:47:12 <merijn> Integer is, but Int is not, for example :)
16:47:19 <merijn> "data Int = I# Int#"
16:48:13 <monochrom> "partial information" is exactly right, literally, for ADTs
16:52:46 <monochrom> merijn: Int is as opague as Integer. at the level you find "data Int = I# Int#", at the same level you will find "data Integer = S# ... | J# ...". however, this is all moot if you're merely working with Num's (+) for example, which does not give you enough access to I#, J#, or S#. for all you can observe through (+), Int and Integer are flat.
16:57:40 <mraa0> Hey, I am working on an exercism exercise and having trouble understanding what my module has to implement when the test asks for `import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)`
16:58:02 <ThreeOfEight> ah, that one
16:58:15 <ThreeOfEight> mraa0: data Sublist = Equal | Sublist | Superlist | Unequal
16:58:31 <ThreeOfEight> and sublist :: Eq a => [a] -> [a] -> Sublist
16:58:39 <ThreeOfEight> or something like that, I do not recall correctly
16:58:45 <ThreeOfEight> s/correctly/exactly/
16:59:21 <ThreeOfEight> maybe it was also [Integer] -> [Integer] -> Sublist or [String] -> [String] -> Sublist, but the code will be the same anyway
17:00:03 <mraa0> ThreeOfEight: ah, so the `import Sublist (Sublist` part is asking for a type definition?
17:00:33 <monochrom> the first Sublist is module name. the second Sublist is type name.
17:01:03 <monochrom> and if there is (X,Y,Z) right after type name, this means the type has constructors X, Y, Z.
17:01:17 <Axman6> and the third is a data constructor...
17:01:33 <monochrom> however, all this says nothing about the fields needed for the constructors. you will have to find out from elsewhere
17:01:42 <Axman6> module Sublist where; data Sublist = Equal | Sublist | Superlist | Unequal
17:01:51 <Axman6> is whar the Sublist module looks like
17:01:54 <ThreeOfEight> and the sublist in the end is a regular function
17:02:00 <ThreeOfEight> yes, there are no constructor fields
17:02:04 <Axman6> wow, much sublist
17:02:12 <ThreeOfEight> I did this exercise ages ago, I remember what it looked like to some degree
17:03:11 <mraa0> I see, so something like `import <module> (<type> (<constructor>, <constructor2>), <data constructor>)`?
17:03:53 <Axman6> the last <data constructor> in this case is actually a function
17:04:12 <ThreeOfEight> anything lower case in an import clause is a function
17:04:22 <ThreeOfEight> an upper case thing is a type
17:04:30 <Axman6> or a constructor
17:04:33 <argent0> Hi, How I can define pure in this Applicative instance? http://lpaste.net/111977
17:04:37 <mraa0> I see thanks.
17:04:48 <ThreeOfEight> if it's a datatype, it can be followed by a list of data constructors in parentheses
17:04:51 <ThreeOfEight> Axman6: huh?
17:04:55 <ThreeOfEight> a lower case constructor?
17:04:58 <Axman6> Ankhers: well, Pair needs two arguments right?
17:05:16 <Axman6> "an upper case thing is a type" or a constructor
17:05:32 <Axman6> uh, argent0, not Ankhers, sorry
17:05:53 <ThreeOfEight> Axman6: but constructors only within parentheses after a type
17:05:59 <ThreeOfEight> if I do recall correctly
17:06:11 <Axman6> argent0: pure a = Pair a  --> pure a = Pair a a
17:06:46 <argent0> Axman6: so It would be: pure a = Pair a a -- I've tried it
17:07:06 <argent0> now I get new error: No instance for (Functor Pair)
17:07:16 <Axman6> right, now you need to implement Functor
17:07:26 <argent0> But I think I'm missing the functor implementation
17:07:36 <argent0> Ok, Thanks Axman6!
17:07:38 <Axman6> instalce Functor Pair where fmap f (Pair x y) = Pair (f x) (f y)
17:07:47 <Axman6> instance even
17:08:00 <SrPx_> Is this currently used? http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel-gc/par-gc-ismm08.pdf
17:08:43 <Axman6> I believe GHC does have a parallel GC, I assume it's the one discussed there
17:09:19 <jfischoff> it is the default, and oddly slow many times
17:11:23 <CatMtKing> hello
17:11:29 <CatMtKing> i'm trying to understand how this works http://www.haskell.org/haskellwiki/Foldl_as_foldr
17:11:59 <CatMtKing> but i think i don't have such a good understanding of partial application because i can't tell what's being applied to what
17:12:27 <CatMtKing> foldl f a bs = foldr (\b g x -> g (f x b)) id bs a
17:16:32 <akurilin> quick question: which files under ~/.cabal should I nuke to redownload and build everything from scratch?
17:16:48 <akurilin> I don't want to delete .cabal/bin ideally because it's got the latest cabal binary in there
17:16:57 <akurilin> even though I'll need to update the yesod tool i nthere
17:17:59 <bitemyapp> akurilin: don't delete anything in ~/.cabal
17:18:09 <bitemyapp> akurilin: reinstall should overwrite I think. If not, delete binary.
17:19:14 <bitemyapp> akurilin: notably, your config is in ~/.cabal. Pretty important.
17:19:22 <jle`> CatMtKing: try to follow the types out, and it should work out
17:19:25 <srhb> CatMtKing: In the lambda or outside of it?
17:19:30 <jle`> what type is b, what type is g...what type is id in this case
17:19:32 <jle`> etc.
17:19:44 <jle`> esp g
17:19:51 <SrPx_> Uhm just something that occurred, lists are considered really slow so we often try to use arrays when dealing with critical code, right? But aren't the same problems that apply to lists, valid to *any* Haskell data structure?
17:19:58 <akurilin> bitemyapp: hm yeah I was having trouble matching the right versions for the latest yesod-bin so I was tryign to restart the whole thing from scratch
17:20:04 <srhb> SrPx_: How so?
17:20:12 <dfeuer> I think I found a place where someone came up with a really smart idea, then forgot the idea. Specifically, they defined  between x a b = a <= x && x <= b, which makes perfect sense, but only if it's written x `between` a b, which they didn't do.
17:20:27 <bitemyapp> akurilin: I'm not a fan of installing yesod into user package-db anyway.
17:20:33 <jle`> heh
17:20:43 <srhb> SrPx_: And it really depends on the specific issue whether switching from list to something else makes sense.
17:20:44 <SrPx_> after all, something like `f (g (b x))` when `f`, `g` and `b` are accessors, are just several pointer references
17:21:00 <exio4> srhb: what kind of "problems"?
17:21:06 <SrPx_> as opposed to C's x.b.g.f, which gets converted to a straight access on the right spot in memory during compilation
17:22:26 <SrPx_> in other words, a struct inside a struct inside a struct in C is converted to a flat memory location... not true in haskell, right?
17:22:38 <dfeuer> SrPx_, sometimes things get optimized a lot. Also, you can *make* it happen.
17:23:15 <RchrdB> If you have a fixed-size non-recursive aggregate data type which is strict, you can use the UNPACK pragma to make it have a flat memory representation.
17:23:27 <dfeuer> SrPx_, in particular, look at the {-# UNPACK #-} pragma.
17:23:34 <dfeuer> Yeah, what RchrdB said.
17:23:48 <SrPx_> oh I just asked about it, I thought it was meant for primitives such as Int
17:25:00 <Axman6> it can also be used to unpack product types with primitive types too
17:25:21 <SrPx_> alright
17:25:42 <RchrdB> e.g. data Point = Point { {-# UNPACK #-} !x :: Float, {-# UNPACK #-} !y :: Float } -- will probably get a representation that's 12 or 16 bytes long, which would look almost exactly like: struct { void *tag; float x; float y; }; in memory.
17:25:42 <SrPx_> It could be a little... prettier
17:25:46 <dfeuer> RchrdB, I seem to recall that there is some way to do it for some weird polymorphic recursive stuff too, like binomial heaps, but I could be misremembering.
17:26:19 <SrPx_> RchrdB: void* tag? Also, it looks exactly like this, no lies? Or is there something else?
17:26:22 <RchrdB> dfeuer: oh really? Cool!
17:26:32 <dfeuer> RchrdB, remember, I could be misremembering.
17:26:46 <dfeuer> Do not to forget that part!
17:26:56 <dfeuer> That part is very important.
17:27:47 <akurilin> bitemyapp: well you need the tool somewhere so that you can generate the yesod scaffold
17:27:58 <RchrdB> SrPx_: AIUI, as a GHC-specific implementation detail, there's one pointer-sized variable at the front of every boxed Haskell value which is used for a bunch of things internal to the run-time system, such as permitting the GC to track which fields are pointers.
17:28:31 <dfeuer> SrPx_, it could be prettier, but that would take a syntax extension, making the code work only in GHC. Using pragmas there allows the same code to compile, less efficiently, in any implementation.
17:28:58 <SrPx_> I see... how wide is the use of other implementations ?
17:29:02 <RchrdB> there's also the -funbox-strict-fields flag for GHC, which unpacks every strict field in every data type.
17:29:17 <bitemyapp> akurilin: yeah, sandbox.
17:29:19 <SrPx_> RchrdB: hmm I see, thanks
17:29:20 <bitemyapp> akurilin: add sandbox to path.
17:29:54 <dfeuer> SrPx_, not very wide at the moment. The classic alternatives have died, and the new ones are still very green, but recognizing them and supporting them is good for bot Haskell in general and even GHC in particular.
17:30:01 <Axman6> rqiu: not every strict field, I don't think it can unpack sum types
17:30:06 <Axman6> uh, RchrdB
17:30:18 <RchrdB> Axman6: ?
17:30:27 <dfeuer> SrPx_, we want to *encourage* the development and use of non-GHC implementations.
17:30:48 <dfeuer> We being everyone who likes Haskell :P
17:31:01 <SrPx_> dfeuer: what are them? :)
17:31:05 <Axman6> RchrdB: you can't unpack sum types IIRC
17:31:31 <RchrdB> Axman6: I don't think I said that you could?
17:31:52 <Axman6> you said -funbox-strict-fields could unpack all strict fields
17:32:04 <RchrdB> Axman6: oh my bad.
17:32:21 <CrazyM4n> > map (:[]) "0001101101"
17:32:22 <lambdabot>  ["0","0","0","1","1","0","1","1","0","1"]
17:32:25 <CrazyM4n> yiss
17:32:30 <dfeuer> SrPx_, I know there's jhc. I don't know what else.
17:33:37 <benzrf> > map pure "0001101101"
17:33:39 <lambdabot>  No instance for (GHC.Show.Show (f0 GHC.Types.Char))
17:33:39 <lambdabot>    arising from a use of ‘M609089449981022772210115.show_M6090894499810227722...
17:33:39 <lambdabot>  The type variable ‘f0’ is ambiguous
17:33:39 <lambdabot>  Note: there are several potential instances:
17:33:39 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:33:43 <benzrf> > map pure "0001101101" :: [String]
17:33:44 <dfeuer> SrPx_, I seem to remember someone trying to implement Haskell on top of Clean's intermediate language; don't know if that went anywhere.
17:33:44 <lambdabot>  ["0","0","0","1","1","0","1","1","0","1"]
17:33:55 <CrazyM4n> @type pure
17:33:56 <lambdabot> Applicative f => a -> f a
17:34:04 <CrazyM4n> :S
17:34:20 <Axman6> @instances Applicative
17:34:21 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
17:34:25 <Axman6> D:
17:34:32 <CrazyM4n> ohh, I get it, [] is an applicative
17:34:35 <Axman6> @instances-importing  Control.Applicative
17:34:35 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
17:34:46 <Axman6> @instances-importing  Data.Applicative
17:34:46 <lambdabot> Couldn't find class `Data.Applicative'. Try @instances-importing
17:34:47 <CrazyM4n> And pure lifts a value to an applicative
17:34:55 <Axman6> yep
17:35:01 <CrazyM4n> > pure 'a' :: String
17:35:02 <lambdabot>  "a"
17:35:06 <CrazyM4n> makes sense
17:35:38 <SrPx_> dfeuer: intersting, but why?
17:35:45 <SrPx_> dfeuer: why the idea, what is
17:36:00 <SrPx_> and haskell is much faster than clean nowadays, isn't it?
17:37:03 <dfeuer> SrPx_, having more than one implementation, with very different internal structures, trying to implement new extensions, helps give a sense of how much those new features constrain implementation techniques, helping keep things flexible. Why implement Haskell on the Clean intermediate language? Not sure.
17:37:45 <AshyIsMe> > pure 42 :: [Int]
17:37:46 <lambdabot>  [42]
17:37:47 <CrazyM4n> @type map (:[] . read) (filter (\c -> (head c /= '#') && (words c /= 2)) )
17:37:48 <lambdabot>     Couldn't match expected type ‘b0 -> c0’ with actual type ‘[t0]’
17:37:48 <lambdabot>     In the first argument of ‘(.)’, namely ‘[]’
17:37:48 <lambdabot>     In the second argument of ‘(:)’, namely ‘[] . read’
17:38:14 <CrazyM4n> @type map (:[] . read) (filter (\c -> (head c /= '#') && (words c /= 2)) "02103010201020104018")
17:38:15 <lambdabot>     Couldn't match expected type ‘b0 -> c0’ with actual type ‘[t0]’
17:38:15 <lambdabot>     In the first argument of ‘(.)’, namely ‘[]’
17:38:15 <lambdabot>     In the second argument of ‘(:)’, namely ‘[] . read’
17:38:52 <CrazyM4n> @type map ((\i -> i:[]) . read) (filter (\c -> (head c /= '#') && (words c /= 2)) "02103010201020104018")
17:38:53 <lambdabot>     Couldn't match type ‘Char’ with ‘[Char]’
17:38:53 <RchrdB> jhc is specifically interesting because it has a much smaller runtime than ghc, so it can be used on smaller machines (like embedded stuff).
17:38:53 <lambdabot>     Expected type: [String]
17:38:53 <lambdabot>       Actual type: [Char]
17:39:01 <dfeuer> CrazyM4n, you can query lambdabot.
17:39:13 <dfeuer> Have a private discussion with the robot.
17:39:27 <AshyIsMe>  /msg lambdabot > "yo"
17:39:33 <CrazyM4n> dfeuer: Sounds good, sorry haha
17:40:17 <dfeuer> RchrdB, jhc seems interesting because it seems like it might have enough energy to go somewhere. The one thing I saw in its docs that looks unfortunate is that it apparently does not have such nice Int semantics as GHC.
17:40:36 <AshyIsMe> haha https://twitter.com/DeTreville/status/517781424653348866
17:40:45 <RchrdB> SrPx_: I think that there are (several?) Haskell implementations that target javascript, at least one of which actually supports full H98 :)
17:41:59 <karshan> @src List
17:41:59 <lambdabot> Source not found. My brain just exploded
17:42:00 <RchrdB> dfeuer: its semantics for Int are no worse than what's in the Haskell report though, right? IIRC the standard specifies awful semantics for Int, undefined behaviour on overflow and -1<<29 to +1<<29-1 range?
17:42:08 <karshan> @src Data.List
17:42:09 <lambdabot> Source not found. stty: unknown mode: doofus
17:42:44 <dfeuer> RchrdB, yeah, but it's very nice when Int is a ring, as it is in GHC.
17:43:06 <dfeuer> It lets you be a little less verbose about some things.
17:43:12 <RchrdB> fair
17:43:34 <RchrdB> Can (integers modulo n) form a ring? I can't remember what the conditions that division has to satisfy are.
17:44:05 <SrPx_> new error, any idea? http://lpaste.net/111979
17:44:40 <RchrdB> Oh yes. *Fields* have to have multiplicative inverses, rings don't.
17:45:53 <dfeuer> SrPx_, in GHC, I can write (fromIntegral (ord c - ord 'a') :: Word) < 26, whereas in jhc I'd have to write (fromIntegral (ord c) - fromIntegral (ord 'a') :: Word32) < 26
17:46:16 <RchrdB> dfeuer: I think you meant me, there? :)
17:46:29 <dfeuer> Uh... yes, RchrdB.
17:46:55 <SrPx_> oh but it fixed my problem
17:46:57 <SrPx_> o.o
17:47:00 <RchrdB> SrPx_: what the "Intern package repository"? I would guess that your problem is that the .cabal file doesn't specify a dependency on the "hashable" and "intern" packages
17:47:38 <SrPx_> yea that is what my new .cabal-aware mind thought, but it does
17:47:44 <SrPx_> :(
17:47:58 <SrPx_> this one: https://hackage.haskell.org/package/intern
17:48:52 <RchrdB> why're you building it from source from the repo?
17:50:38 <bms1> Is there something strange about the FFI on 64-bit Windows GHC?
17:50:50 <bms1>  I am making an FFI call to a library and get the wrong result (though the equivalent C code gets the right result)
17:50:51 * hackagebot hoogle-index 0.1 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.1 (BenGamari)
17:50:53 <RchrdB> SrPx_: uh, what version of… anything, are you using?
17:51:05 <exio4> can you define multiple modules in a single file?
17:51:10 <bms1> And I find it is because the library I'm linking to wants 32-bit size types instead of 64-bit
17:51:20 <bms1> exio4: no
17:52:00 <bms1> (I don't have this issue with the equivalent Linux library with GHC on 64-bit Linux)
17:52:02 <RchrdB> SrPx_: I just ran "git clone git://github.com/ekmett/intern.git; cd intern; cabal sandbox init; cabal update; cabal install" and it quite happily built intern's HEAD for me and registered it in that sandbox.
17:52:26 <RchrdB> SrPx_: btw, "cabal install && cabal configure && cabal build" is a really weird thing to type
17:52:38 <bms1> (if I use Word32/Int32 instead of Word/Int when communicating with the library, the library works properly)
17:53:23 <RchrdB> cabal will automatically run the configure step when you ask it to run the "build" step, and it will automatically run the "build" step when you ask it to run the "install" step (in each case, assuming that the previous hasn't already been done)
17:53:37 <RchrdB> s/really weird thing to type/slightly weird thing to type/
17:55:55 <SrPx_> ah I see
17:56:32 <SrPx_> well I managed to get it working that way, thank you
17:56:41 <CrazyM4n> Is there a chunksOf function that works on strings?
17:56:48 <CrazyM4n> Or how do I get strings into text?
17:58:07 <karshan> CrazyM4n yes its in split
17:58:28 <karshan> http://hackage.haskell.org/package/split-0.2.1.1/docs/Data-List-Split.html#v:chunksOf
17:58:44 <CrazyM4n> Thanks!
17:59:00 <karshan> :t Data.List.Split.chunksOf
17:59:01 <lambdabot> Int -> [e] -> [[e]]
18:01:03 <tyberious> what are some good resources to get started in Haskell? I am currently using the wikibook.
18:01:16 <CrazyM4n> tyberious: I love the wikibook, personally
18:02:04 <slack1256> yesod uses conduit, is there any webframework that uses pipes?
18:02:09 <tyberious> great just wanted to verify that it is a good source
18:04:39 <SrPx_> Suppose that, on my module, I have a constraint such as `f . g = h`. Except `h` is faster than `f . h`. Can I make GHC optimize every occurrence of `f . g`, replacing by `h`?
18:04:42 <luite> slack1256: yesod doesn't depend on conduit very much anymore since wai switched away from it (looks like there still is a dependency, but i'm not sure where it's used)
18:04:56 <SrPx_> faster than `f . g`
18:05:23 <luite> SrPx_: that's what rules annotations are for
18:05:36 <SrPx_> thanks that what I was looking for
18:06:05 <slack1256> oh. Well I still want a web-framework that uses pipes.
18:06:10 <slack1256> if possible though
18:09:30 <luite> slack1256: why do you want the framework to use them? you can probably connect wai/yesod's callbacks or snap's io-streams to a pipe without too much trouble.
18:14:18 <karshan> luite: is there any way I can use ghc-mod with ghcjs ?
18:16:07 <luite> karshan: i don't think there's support in ghc-mod for that yet
18:16:43 <hamishmack> karshan: If your application can be build on top of ghcjs-dom, then you can use ghc and all your existing tooling for dev
18:16:59 <hamishmack> then switch to ghcjs when it is done
18:17:03 <luite> it'd need to link against the ghcjs lib and can call some stuff for that
18:18:32 <CrazyM4n> How can I convert a character to a digit?
18:18:50 <CrazyM4n> Got it, nevermind
18:19:22 <CrazyM4n> > digitToInt '1'
18:19:24 <lambdabot>  1
18:29:55 <luite> karshan: if you want to try to get it to work, you probably have to add the ghcjs hooks (use Compiler.GhcjsPlatform.setGhcjsPlatform) to the session in Language.Haskell.GhcMod.Monad.initSession and replace the hardcoded (Just libDir) from GHC.Paths
18:32:07 <karshan> luite: thanks I will look into that. Also going to try ghcjs-dom first though
18:32:49 <CrazyM4n> Do you guys know if http://sourceforge.net/projects/console/ works well with GHCi?
18:32:58 <CrazyM4n> I don´t see why not but with some things it´s kinda meh
18:40:50 <VBlizzard> I have a question. what exactly is Haskell good for? I plan to go to college in 2 years.
18:40:59 <VBlizzard> so will Haskell still be 'popular'?
18:41:27 <swgillespie> haskell forces you to think about the correctness of the code you are writing
18:41:48 <swgillespie> it forces you to think about the side effects of the things you're doing
18:41:58 <swgillespie> it also changes the way you think about programming as a whole
18:42:47 <Yxven> I think Haskell is gaining in popularity but I don't know that I would call it popular
18:43:44 <dmj`> VBlizzard: do you plan on studying computer science?
18:45:19 <dmj`> VBlizzard: I asked what you plan on studying
18:45:30 <roboguy_> VBlizzard: well, it's a general purpose programming language, so writing programs
18:46:06 <VBlizzard> oh, sorry, dmj. I plan on studying in Web Development and maybe some SoftwareDev.
18:46:08 <VBlizzard> Mostly Web.
18:46:15 <VBlizzard> roboguy_, thanks.
18:47:34 <xcv> VBlizzard: Even if you end up not using it in production, I'd say learning Haskell is a very worthwhile pursuit.
18:48:32 <xcv> it shows you things in a more abstract light, which (at least for me) helps to show the underlying patterns in the code one just grinds out in most other languages
18:48:42 <xcv> and the type system is a big aid to abstraction
18:49:06 <xcv> I'm pretty new to Haskell, but it does seem to bring some serious benefits
18:49:23 <dmj`> its well worth the effort do it, it keeps programming fun
18:50:16 <xcv> I'm a pretty experienced ruby/rails/javascript developer, but I'm starting to think Haskell has significant advantages to e.g. Ruby (although Ruby is and will always be a fun language)
18:50:57 <xcv> I'm also getting the feeling that Haskell is just as, if not more, productive for pounding out code as the dynamic languages (such as Ruby or Python) once one knows it well enough
18:52:06 <CrazyM4n> xcv: Depends on the code, but I love just sitting down and writing whatever comes to mind in Haskell
18:52:08 <xcv> i.e. I think most dynamic language guys overestimate the onerousness of the type system and underestimate the benefits
18:52:23 <CrazyM4n> It flows nicer as you type it than my other favorite languages
18:52:42 <dmj`> xcv: this is true, the benefit being the type system saves you as the code base grows. Refactoring / adding new features is trivial since ghc will point out every spot that's broken
18:53:49 <xcv> yes indeed
18:54:41 <xcv> I've hardly written a line of Haskell, but I've been hearing a lot of good stories from very awesome engineers on the interwebs that corroborate these things
18:55:29 <merijn> I once decided to try and fix a bug in mercurial, 2 hours of staring at code trying to figure out where all the identifiers came from and what they did, I gave up
18:55:54 * hackagebot hoogle-index 0.2 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.2 (BenGamari)
18:55:56 * hackagebot hoogle-index 0.2.1 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.2.1 (BenGamari)
18:56:18 <merijn> I once decided to extend the pandoc rST parser to follow the rST spec more accurately, 2 days later I still had no clue how pandoc worked, but my rST parser extension worked fine and got merged with no trouble :)
18:56:29 <merijn> That's the difference between types and no types :p
18:57:18 <xcv> I guess what I was worried about initially is that the type system would often prevent me from writing a perfectly reasonable program, just because the type system wasn't expressive enough. I figured that's the kind of thing that has to be figured out by people writing hardcore, real-world software.
18:57:42 <merijn> I feel that anyone that understands the basics of parsec should be able to add/extend pandoc parsers, which is not something I'd say for python projects of comparable size
18:57:43 <xcv> but it does seem that the types are plenty expressive, provided that the engineer knows his stuf
18:57:45 <xcv> *sfuff
18:57:49 <xcv> aah
18:57:51 <xcv> *stuff
18:57:51 <thang1> Well obviously your time type for the first one was of type `hours` and the second one was of type `days`, that's probably why
18:58:03 <xcv> anyway, /rant
18:58:19 <merijn> thang1: I was able to hack on pandoc within 30 mins, it took the rest of the time to implement what I wanted
18:58:28 <thang1> I was joking, anyway :p
18:58:56 <merijn> xcv: Before you know it, you keep wanting more and more expressive types and before you know it, you're writing in Coq :p
18:59:00 <xcv> haha!
18:59:14 <xcv> yeah, that's actually a very fascinating angle
18:59:25 <merijn> That and/or programming with "{-# LANGUAGE KitchenSink #-}" :p
18:59:29 <xcv> I studied maths at university, so this whole dependent types thing is fascinating
19:00:10 <xcv> because it's even more like math reaching into programming than Haskell is
19:00:10 <merijn> xcv: If you're looking for a fun hobby...
19:00:39 <xcv> ... then I should contribute to Idris?
19:00:43 <xcv> :P
19:00:51 <merijn> xcv: "Software Foundations" steps you through the basics of proving (in the mathematical sense) properties of increasingly complex programs (really, at the start the programs are basically functions) using Coq
19:00:54 * hackagebot hydrogen-data 0.5 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.5 (JulianFleischer)
19:01:11 <merijn> xcv: It's a fun game of "trying to make the interpreter swallow your proofs"
19:01:16 <xcv> ah, wow
19:01:18 <merijn> @where sf
19:01:18 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
19:01:18 <lambdabot> assistant."
19:02:10 <thang1> oooh that sounds like fun
19:02:12 <roboguy_> merijn: the thing about Coq is I'm not sure I could get used to the syntax. I want to give it a shot, but it always puts me off a little bit. I might just be used to Haskell-style stuff though, and I just need to give it more of a chance
19:02:21 <merijn> xcv: It basically starts of with writing simple functions in Coq (which is just functional programming like haskell) and then moves into proving that "rev (rev xs) == xs" for your xs implementation
19:02:46 <merijn> roboguy_: The syntax is pretty ugly, but for interactive theorem proving I find it much more workable than Agda
19:03:00 <merijn> roboguy_: Also, SF is a pretty good book to guide you through things
19:03:01 <xcv> yeah, I really should look into that
19:03:12 <xcv> also just to read up on the fundamentals of type theory
19:03:18 <xcv> been reading a bit of math about that recently
19:03:30 <xcv> (just getting started with this whole thing)
19:03:35 <merijn> I recommend using Proof General (emacs) or Coquille (vim) for interactive use, without that it's not nearly as nice
19:03:41 <rqiu> @undo do { x <- getLine; print x }
19:03:41 <lambdabot> getLine >>= \ x -> print x
19:03:52 <xcv> never thought I'd find a use for commutative diagrams after university until I ran into category theory!
19:03:53 <thang1> What's the "SF" book?
19:03:56 <merijn> There's a GUI IDE, but it's pretty terrible (it doesn't have "jump to startend of line"
19:04:08 <merijn> thang1: Software Foundations, I just linked it a few lines back
19:04:10 <roboguy_> merijn: good to know. Thanks! someday I want to tackle HoTT stuff and I know a lot of the code for that was (originally) in Coq
19:04:14 <thang1> oh right, got it
19:04:31 <merijn> rqiu: Also known is "getLine >>= print" :)
19:04:35 <merijn> s/is/as
19:05:25 <rqiu> thanks. :-) i was just trying out lambdabot, never used it before
19:05:48 <xcv> if I'm not mistaken, one of the tradeoffs is that the dependently typed langs have more "local reasoning power" at the expense of "global inference power", so they're not nearly as nice to refactor as Haskell
19:06:14 <xcv> but maybe that's something they'll figure out in due course
19:06:17 <roboguy_> xcv: hmm, I'm not sure if global inference usually helps with refactoring
19:06:22 <merijn> xcv: Well, basically, there's no decidable type inference algorithm for full dependent types
19:06:37 <thang1> I'd say that the refactoring is more a byproduct of the fact that global state is almost never modified in a haskell function (due to purith)
19:06:42 <merijn> xcv: But everything that's inferrable in, for example, haskell is still inferrable
19:06:51 <xcv> aha, ok
19:07:05 <thang1> if you're not modifying anything outside of the function, you can chang eit around willy nilly and not break anything else (besides that function and those that rely on it)
19:07:12 <merijn> xcv: Also, I barely use type inference (i.e. all top level function get a signature anyway and often times so do a lot of local definitions)
19:07:12 <roboguy_> I think the main thing it lacks is type inference at the top-level and most of the time you should probably have explicit top-level types anyway
19:07:25 <xcv> yeah
19:07:26 <thang1> Whereas in C if you change something you can break some other completely unrelated thing
19:09:33 <xcv> man, I've been on a Haskell reading binge for around three weeks now, started as an innocent investigation of the relative pros and cons of static vs dynamic (e.g. Haskell vs Clojure) in FP
19:09:47 <thang1> That's how they get you :p
19:09:47 <xcv> and before I know it I'm listening to Edwin Brady talking about the operational semantics of Idris
19:09:56 <xcv> nowhere near the bottom of this rabbit hole!
19:10:06 <xcv> haha
19:10:12 <xcv> thang1: I guess so!
19:10:20 <Axman6> it's types all the way down
19:10:55 * hackagebot hydrogen-data 0.5.1 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.5.1 (JulianFleischer)
19:12:05 <merijn> Edwin's shirt: http://asset-d.soup.io/asset/7964/5774_d880_960.jpeg
19:12:13 <xcv> is there a general feeling about how long it's going to be before we have "production quality" dependently typed languages that are nice to use for general purpose programming?
19:12:13 <xcv> haha
19:12:28 <merijn> xcv: Idris, hopefully :p
19:12:36 <merijn> So, a couple more years?
19:12:48 <xcv> mm, that would be great
19:13:00 <thang1> Well one of the biggest factors, I think
19:13:22 <thang1> is that C/C++ remains the dominant language for servers, the linux kernel, embedded software and high performance software in general
19:13:39 <merijn> xcv: Or you take the Stephanie Weirich approach and try to make haskell more dependently typed :p
19:14:18 <thang1> so until C or C++ develop dependent types and a more robust type system I don't know how fast a more advanced type system will catch on
19:14:53 <merijn> C99 had some dependent types, but they got made optional in C11 since compiler writers considered them too hard
19:15:16 <thang1> man that's a shame
19:15:28 <merijn> thang1: The only dependent bit was tracking array size
19:15:39 <merijn> So they weren't very *interesting* dependent types
19:16:01 <thang1> Ah, true. It's hard to get creative that low of a level anyway :p
19:16:09 <bms1> thang1: have you heard of the ATS language?
19:16:11 <Axman6> but also the canonical example of dependant types :P
19:16:21 <merijn> bms1: heard of, never looked at
19:16:24 <thang1> I'm surprised C++ has gotten as convulted as it is, honestly
19:16:51 <thang1> half of the stuff in there I didn't think you could do with such a low level language until they crammed it in there with a ritual or two and probably a virgin sacrifice
19:17:07 <thang1> bms1: I haven't heard of ATS
19:17:14 <merijn> C++ is getting pretty usable, imo :p
19:17:24 <octopuscabbage> i'm having a bit of trouble getting Data.Tree to do what I want. so how would I go about adding something to the bottom node of the tree?
19:17:34 <thang1> I didn't say it was unusable, but good lord is it ridiculous some of the stuff they have in there :p
19:17:57 <CrazyM4n> It´d be hard to change C++ at this point
19:18:05 <merijn> thang1: Sure, it's horrifically ugly. But with only a moderate amount of effort I get a ton more static guarantees than with C
19:18:08 <CrazyM4n> inb4 c++14 is a functional language
19:18:33 <merijn> thang1: <3 enum classes, for example
19:18:34 <thang1> oooh nice, I like the idea of ATS
19:19:02 <thang1> but... but... c++14 has, like, lambdas and shit...
19:20:02 <thang1> They wouldn't change c++ as much as just tack on a ton of stuff to the base code and slowly start discouraging certain stuff
19:20:24 <CrazyM4n> "like, lambdas and shit"
19:20:37 <CrazyM4n> that´s the essence of functional programming right there, haha
19:20:55 <thang1> I can imagine some sort of bull like "okay guys we made a new type of integer and we're gonna call it Int. Don't confuse it with int, kay?"
19:21:13 <CrazyM4n> then another type called ínt
19:21:52 <thang1> and lastly a tuple type called ïnt, which you can tell because of the two dots on the i
19:22:08 <thang1>  /obviously
19:22:35 <xcv> haha
19:23:22 <thang1> Did you guys know that the templates in C++ are actually turing complete?
19:23:29 <xcv> hehe
19:23:30 <thang1> the templates, not even the language, just the damn templates...
19:23:32 <xcv> yeah, I heard that once
19:23:56 <thang1> Also, magic the gathering is so complex and intricate that the rules can be used with a magic simulator to create a turing machine as well
19:24:03 <thang1> good thing I play yugioh instead
19:24:07 <merijn> thang1: C++11 already has lambdas
19:24:14 <xcv> hahaha
19:24:21 <dmj`> thang1: I still play pokemon blue
19:24:40 <thang1> but these these lambdas go up to 14, not 11, so they're 3 better
19:24:53 <thang1> pokemon is great, but sucks ass as a card game
19:25:14 <xcv> yeah, definitely one of the better Game Boy games imho
19:25:28 <xcv> Do you know of any high-profile examples of seasoned Haskellers leaving the language to work in a dynamic language instead? Or does it seem like a one-way trip?
19:25:39 <merijn> xcv: Pretty much one way trip
19:25:42 <thang1> One of the better video games in general, tbh. I really enjoyed it, but it just doesn't work for card games
19:26:09 <thang1> xcv: I almost always hear of seasoned Haskellers who really enjoy the language and love it, but are also skilled in other languages and may work jobs which require said other languages
19:26:28 <thang1> But the power of the typesystem is pretty addictive
19:26:31 <xcv> A lot of the more prominent Clojure guys do dabble in Haskell, but it seems they prefer coding in a dynamic functional language.
19:26:34 <merijn> xcv: At least, assuming you mean of their will, I've heard people switch for job related reasons (i.e. the entire code base is in language X), but other than that
19:26:47 <roboguy_> octopuscabbage: what if there's more than one bottom node?
19:27:16 <xcv> Then again, I'm not sure how many of them have actually taken a deep dive into Haskell. But many of them are very interested in PL theory.
19:27:22 <thang1> Being able to look at some nasty and difficult problem and then code a solution the first try and hit the compile button while lighting some candles and chanting "follow the types" is amazing
19:27:43 <Axman6> octopuscabbage: what've you tried so far?
19:28:30 <thang1> It's interesting how everyone's like "dude I don't need a degree for proramming, I have a career and everything, learned how to code in 4 weeks on adderall" but when you get super heavy into the theory, man, that stuff is intense...
19:28:45 <xcv> yeah...
19:28:49 <thang1> I'm lucky if I understand the thesis of a lot of PL papers I attempt to read, especially haskell/type system related ones
19:28:52 <xcv> I thought I understood FP pretty well
19:28:56 <xcv> and then I ran into Haskell
19:29:03 <xcv> and now I don't know anything :P
19:29:11 <xcv> it's a great feeling
19:29:12 <HeladoDeBrownie> I wonder if there are studies done on whether studying the theory makes a difference in career.
19:29:13 <thang1> Is your name also john snow?
19:29:37 <CrazyM4n> https://www.youtube.com/watch?v=lt5_6s9cmMo Kind of a shameless plug, but I made a video talking about my game of life in Haskell
19:29:41 <dmj`> HeladoDeBrownie: depends on what you do and how you evaluate success
19:29:43 <CrazyM4n> Maybe it would be interesting to someone
19:30:04 <xcv> haha
19:30:27 <dmj`> HeladoDeBrownie: generally yes, I'd say
19:30:28 <HeladoDeBrownie> dmj`, sure, I assumed the study would specify that. I'd be curious to see *any* measures though.
19:30:50 <thang1> I think it's fairly obvious that studying the theory will make someone a BETTER prorammer, perhaps a more skilled one as well
19:30:51 <HeladoDeBrownie> See them, then evaluate whether they're good.
19:31:17 <thang1> but whether it'll improve their career, that depends on so many factors I'd imagine it could easily swallow even a large objective increase in skill of the programmer
19:31:19 <HeladoDeBrownie> thang1, sure, but obvious isn't the same as true. It seems obvious to me as well but I would be wary of stating it as fact without anything backing me up.
19:31:31 <orb__> Career might actually be easier to improve than programmer skill.
19:31:43 <orb__> For career you can get pretty far by being good in job interviews.
19:31:50 <orb__> Theory can help with that, easily.
19:32:08 <thang1> Definitely. See "idiot who's uncle got them hired" or "I studied psychology so I know how you work, let me manipulate you to get a better job"
19:32:25 <orb__> If only psychology worked that well.
19:32:29 <dmj`> haskell is the new lisp in paul graham's "beating the averages" essay
19:32:36 <thang1> It can get you surprisingly far, honestly
19:32:44 <orb__> PG is still a Lisp fanboy.
19:32:57 <orb__> He doesn't like static typing.  (Or at least didn't the last time I checked.)
19:33:01 <xcv> dmj`: My thoughts exactly.
19:33:09 <orb__> I'm moving to Agda.  Haskell's becoming to main stream.
19:33:10 <Oksana> How do I add an environment \begin{X}content\end{X} to Pandoc LaTeX reader, if I want this environment to be printed as X: content? I do not understand Haskell well enough... https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
19:33:38 <thang1> I need food...
19:33:57 <thang1> I also need to stop becoming so impossibly sidetracked from homework
19:34:23 <Lutin`> I'm trying to not go insane from database migrations
19:34:33 <Lutin`> keyword is trying lol
19:34:41 <thang1> What are you migrating? That sounds like hell...
19:34:56 <orb__> thang1, Wizard needs food.
19:35:11 <Lutin`> thang1: Unfortunately a Django project
19:35:20 <xcv> I think this Venn diagram shows part of the problem: http://www.lispcast.com/img/typing.png
19:36:11 <CrazyM4n> xcv: Haha, that´s great
19:36:42 <CrazyM4n> Personally, I don´t care, but after using static typing for a while, using dynamic typing just feels like there´s something missing
19:36:55 <orb__> Contracts might help a bit.
19:37:07 <xcv> Interestingly enough, the dude who writes that blog used Haskell in his day job for a couple of years, and is now using Clojure because he prefers it. Would be interesting to find out why.
19:37:12 <orb__> The Racket people are into them, and someone made them work for Haskell.  (Ie in a lazy setting.)
19:37:27 <jonmorehouse> Hi I'm pretty new to haskell
19:37:29 <orb__> xvc, he wishes to get paid? ;o)
19:37:41 <jonmorehouse> I'm trying to write a function that takes an integer in
19:37:42 <orb__> xvc, only joking, I used to get paid for Haskelling for 4.5 years.
19:37:47 <xcv> haha!
19:37:49 <jonmorehouse> and returns a sorted string
19:38:00 <orb__> jonmorehouse, f _ = []
19:38:07 <orb__> Or do you have any more requirements?
19:38:13 <orb__> Sorry, I'm being troll-y.
19:38:26 <orb__> What's your function supposed to do?
19:38:30 <CrazyM4n> Very funny orb__
19:38:33 <CrazyM4n> :P
19:38:36 <jonmorehouse> orb__: its supposed to take in a n digit integer
19:38:45 <jonmorehouse> and then return a string of all those integer's characters (in order)
19:38:59 <CrazyM4n> Well how would you turn an int into a string, first of all?
19:39:00 <HeladoDeBrownie> sort . read -- ?
19:39:08 <HeladoDeBrownie> Wait woops, other way
19:39:09 <jonmorehouse> so if I run `method_name 45431`
19:39:09 <HeladoDeBrownie> sort . show
19:39:11 <orb__> show, not read, I'd say.
19:39:15 <Axman6> jonmorehouse: so what do you have so far?
19:39:21 <jonmorehouse> then it should return 13445
19:39:31 <jonmorehouse> so far I have sort . show
19:39:31 <orb__> 13445 or "13345"?
19:39:41 <jonmorehouse> so `id a = sort . sho`
19:39:46 <dmj`> people seem to love haskell, but not enough to quit their jobs to be entrepeneurial or freelance with it
19:39:46 <dmj`>  
19:39:49 <orb__> (disregard the extra 3.)
19:40:06 <jonmorehouse> https://gist.github.com/anonymous/524ab395384aa9239560
19:40:07 <dmj`> it's always, "I couldn't convince my boss :("
19:40:11 <orb__> dmj`, you can sneak some Haskell into your day job, often.
19:40:11 <thang1> I'd bet money it's without quotes, orb__
19:40:20 <jonmorehouse> orb__: it should be with quotes
19:40:27 <zomg> dmj`: I'd say the problem is probably more about finding a job that guarantees money. Can't really go freelancing with haskell (or anything else) unless you have some way of making ends meet
19:40:30 <jonmorehouse> actually ... you know what ... it doesn't matter
19:40:30 <dmj`> we shouldn't have to 'sneak' around in dark places writing haskell
19:40:46 <jonmorehouse> whichever is easiest. I'm planning to use it as an id in a hash
19:41:00 <orb__> jonmorehouse, with quotes is easier.  Someone already posted the answer: f i = sort (show i)
19:41:04 <HeladoDeBrownie> jonmorehouse, looks like your problem is in your definition of main. putStrLn permutationId 55 is ill-typed, perhaps you meant putStrLn (permutationId 55)
19:41:09 <orb__> You need to import Data.List to get sort.
19:41:22 <orb__> jonmorehouse, what are you actually trying to do?
19:41:39 <jonmorehouse> so I'm working on a code challenge
19:41:41 <dmj`> zomg: true, but more often than not business guys don't care about what language you use, use haskell to provide value. Tell them you're a solutions provider, done. They don't care about your career or your learning / interests.
19:41:53 <jonmorehouse> I've written the solution in a nother language. But this is one of my first times in haskell
19:42:17 <jonmorehouse> my goal right now is to store the result of that function in a hash like structure
19:42:27 <jonmorehouse> I'm getting "sort not in scope"
19:42:29 <bms1> dmj`: I just tried to sell doing something in Haskell today
19:42:31 <zomg> dmj`: that assumes ability to find business guys that will hire you. Often especially for beginning freelancers, they'll have much more luck with projects which already have been sort of defined and need an extra hand
19:42:32 <HeladoDeBrownie> jonmorehouse, that doesn't sound so much like a goal as an implementation
19:42:40 <dmj`> bms1: nice! how'd it go?
19:42:43 <CrazyM4n> So did anyone watch my video? Maybe did you guys feel like I left anything out or didn´t elaborate enough?
19:42:45 <bms1> dmj`: I was told that I should make it in Java so "everyone could use it"
19:42:46 <jonmorehouse> yeah ... I'm just starting small :)
19:42:47 <HeladoDeBrownie> jonmorehouse, import Data.List
19:43:14 <thang1> ouch, that must hurt :(
19:43:15 <jonmorehouse> HeladoDeBrownie: still getting some type errors when I run that ... now that sort is found :(
19:43:21 <HeladoDeBrownie> jonmorehouse, okay, what does it say?
19:43:38 <jonmorehouse> Couldn't match type ‘a0 -> [a1]’ with ‘[Char]’
19:43:40 <thang1> Program it in java but go to great lengths to obfuscate the entire code and make it purely functional, and use unicode for the variable names? :p
19:43:47 <bms1> dmj`: it's hard to use Haskell if you need to make something your coworkers will be using
19:43:53 <HeladoDeBrownie> jonmorehouse, it's what I said earlier, line 6 is written incorrectly
19:44:24 <jonmorehouse> https://gist.github.com/anonymous/e5dafd8ab541efa362c4
19:44:35 <jonmorehouse> hmm .. still getting issues with that ... am I missing something?
19:44:45 <bms1> So I end up only using Haskell when I'm doing a project by myself, where there's no expectation that someone else will take over the codebase
19:44:46 <jonmorehouse> oh  ... nvm I figured out what I'm missing
19:44:48 <HeladoDeBrownie> Hmm, looks good at a glance to me. I'll try running it
19:44:56 <thang1> What were you missing?
19:45:11 <jonmorehouse> actually ... still not running :(
19:45:15 <HeladoDeBrownie> jonmorehouse, oh, your problem is the extra a parameter. You don't need that, just sort . show is fine
19:45:26 <HeladoDeBrownie> jonmorehouse, or if you want to include the explicit parameter, sort (show a)
19:45:27 <dmj`> there comes a point when as a community we're just going to have to start using haskell in industry, spreading our seed and let other people get stuck with it. Imagine the reaction a developer would have when he's told he got stuck with a haskell project. What good fortune.
19:45:52 <jonmorehouse> HeladoDeBrownie: got it !
19:45:55 <bms1> thang1: we want to embed what is like an object-oriented scripting language into a real programming language. I've actually *already* done it in Haskell for my own use
19:46:05 <jonmorehouse> whats the difference between sort . show and sort (show ...)?
19:46:13 <bms1> I meant object-oriented description language
19:46:26 * hackagebot yesod-fay 0.6.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.6.1 (MichaelSnoyman)
19:46:26 <dmj`> bms1: I think anyone in industry would take well-written haskell over 50k lines of crappy java, that's a death sentence
19:46:28 <HeladoDeBrownie> jonmorehouse, do you know what function composition, in the mathematical sense, is?
19:46:40 <jonmorehouse> yes, to some degree
19:46:41 <HeladoDeBrownie> @type (.)
19:46:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:46:44 <HeladoDeBrownie> Well (.) is just that
19:46:53 <HeladoDeBrownie> It takes two functions and gives you a function, their composition
19:46:59 <dmj`> bms1: do you think you'd get fired for using haskell? lol
19:47:16 <HeladoDeBrownie> jonmorehouse, g . f = \x -> g (f x)
19:47:28 <HeladoDeBrownie> jonmorehouse, so the second way I wrote is really just expanding (.)'s definition
19:47:41 <bms1> dmj`: Heh. Well I've been trying to get my coworkers to pick up Haskell for the year since I've started
19:47:51 <bms1> I run a local hackage server and have a bunch of packages up
19:48:24 <bms1> but I haven't succeeded in getting others to use Haskell
19:48:35 <jonmorehouse> so basically that means that the result on the right, is passed to the function on the left?
19:48:45 <HeladoDeBrownie> jonmorehouse, not sure what you're asking
19:48:57 <dmj`> bms1: yea, that's tough, you can't make people learn if they have no desire
19:49:13 <HeladoDeBrownie> jonmorehouse, think of definitions as ways you can substitute. So that when you see permutationId, you can replace it with sort . show wherever it appears.
19:49:23 <HeladoDeBrownie> jonmorehouse, so permutationId 55 = (sort . show) 55
19:49:30 <HeladoDeBrownie> which = sort (show 55)
19:49:35 <jonmorehouse> ahh .. that makes sense!
19:50:08 <dmj`> bms1: haskell hits facebook and everyone there wants to switch to that team... coincidence? Maybe write it for your company and tell them they have to manage it, baptism by fire
19:50:39 <thang1> hmm
19:50:55 <thang1> I'd write the project in haskell on my own, personally
19:51:51 <thang1> make it as beautiful and efficient as possible
19:52:11 <fuzzyhorns> http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
19:52:20 <fuzzyhorns> so i dont really get what is different about ML modules
19:52:21 <thang1> and then work on the java one with the team or whatever. Show both of them to your manager and say "the haskell one is 10 times more refactorable and extesnible and 3 times faster and 1/5th the code"
19:52:29 <thang1> and then ask them which one they want :p
19:52:32 <fuzzyhorns> ive never programmed in an ML :x
19:53:42 <fuzzyhorns> thang1: ime at work, refactorable and extensible would equal "some other people in the office have already written in this" and "we are not afraid of the hiring process of finding more people who have written in this" :c
19:53:56 <fuzzyhorns> thang1: so haskell is straight out, while scala is now vaguely possible
19:55:02 <thang1> ah, got it
19:55:27 <thang1> Well at least scala has some FP principles...? I might shoot for scala as a compromise and slowly introduce the FP side of it where possible and see if you can ease into haskell over time?
19:55:51 <fuzzyhorns> thang1: my hope x)
19:55:59 <gcganley> :ReinH hey thanks for the help yesterday it cleared up alot about monads
19:56:33 <S11001001> fuzzyhorns: "Edward Z. Yang: What’s a module system good for anyway?" - http://feedproxy.google.com/~r/ezyang/~3/JgcsQmUUj3k/
19:57:09 <ReinH> gcganley: np!
19:57:27 <CrazyM4n> Programming for a company sounds terrible
19:58:05 <gcganley> thang1: I started at clojure for learning FP
19:58:44 <S11001001> fuzzyhorns: the Haskell diaspora in scalaland hangs out in #scalaz, though #scala is also mostly dominated by FP and typelevel.org people
19:58:45 <jonmorehouse> for some reason I can't seem to figure out how to write a function to cube a value ...
19:58:48 <jonmorehouse> https://gist.github.com/anonymous/6b8fa0da829cc145f142
19:58:58 <jonmorehouse> a ** 3 should return an Int type correct?
19:59:03 <jonmorehouse> assuming a is an int
19:59:32 <gcganley> :t (**)
19:59:32 <lambdabot> Floating a => a -> a -> a
19:59:38 <gcganley> thats why
19:59:50 <gcganley> :t (^)
19:59:51 <lambdabot> (Num a, Integral b) => a -> b -> a
20:00:06 <fuzzyhorns> S11001001: ive never done scala myself, but my bf does and likes it, and my workplace uses java, so i feel like its a more plausible sell than haskell ;-;
20:00:09 <CrazyM4n> Is /r/haskell ok with videos?
20:00:15 <gcganley> > a ^ 3
20:00:17 <lambdabot>  a * a * a
20:00:17 <fuzzyhorns> also any of you know the skinny on ML modules?
20:00:23 <gcganley> > a ** 3
20:00:24 <fuzzyhorns> and why they are better than haskell modules??
20:00:25 <lambdabot>  a**3
20:01:18 <jonmorehouse> hmm ... still can't get these working?
20:01:28 * hackagebot coordinate 0.0.14 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.14 (TonyMorris)
20:01:29 <jonmorehouse> ahh ... I just got a ^ 3 working
20:01:32 <roboguy_> CrazyM4n: they seem to be, yeah
20:01:43 <CrazyM4n> roboguy_: I think I´ll post mine then
20:01:45 <jonmorehouse> but for some reason ... a ** 3 and a**3 and a(**)3 doesnt work
20:02:07 <gcganley> jonmorehouse: did you look at the type signiture for **?
20:02:10 <gcganley> :t (**)
20:02:10 <lambdabot> Floating a => a -> a -> a
20:02:19 <S11001001> fuzzyhorns: unfortunately there are limits.  if you want to do pure IO, for example, you have to encode it in a carefully chosen Free monad structure so the end of the universe doesn't crush your stack
20:02:21 <roboguy_> jonmorehouse: well, a(**)3 shouldn't work, because the parentheses turn it into a prefix function
20:03:12 <S11001001> fuzzyhorns: vaguely, ML modules can take modules as arguments
20:03:27 <gcganley> is there an instance of Int for Floating?
20:03:30 <roboguy_> jonmorehouse: also, (**) works on floating point values. ^ is for Ints (and other integral types) as gcganley mentioned
20:03:47 <fuzzyhorns> S11001001: ah, what problem does that solve?
20:04:23 <gcganley> jonmorehouse: does that clear it up?
20:04:25 <S11001001> fuzzyhorns: see link I posted above
20:04:36 <fuzzyhorns> ah ty!
20:04:42 <jonmorehouse> yep! that makes sense ...
20:04:55 <jonmorehouse> I'm a little lost on some of the details because I'm on a strict time limit and moving fast
20:05:05 <jonmorehouse> but I think I'm getting it down ... there's different operators based on types
20:05:19 <fuzzyhorns> totally missed that message before, ty S11001001
20:05:44 <gcganley> jonmorehouse: just remember to understand typeclasses and which types have instances
20:06:44 <thang1> Has anyone linked him typclassopedia yet?
20:06:56 <gcganley> nope
20:07:14 <thang1> http://www.haskell.org/haskellwiki/Typeclassopedia
20:08:38 <gcganley> @pl (>>=)
20:08:38 <lambdabot> (>>=)
20:09:00 <jonmorehouse> gcganley: yeah makes sense
20:09:10 <jonmorehouse> I dove into haskell a while back, but only for like a half day
20:09:15 <jonmorehouse> and that was like a year ago :(
20:10:03 <gcganley> jonmorehouse: I started like 2 months ago and I've taken the deep dive into it. It took me 3 trys for it to stick
20:10:11 <jonmorehouse> gcganley: I bet, its hard!
20:10:24 <jonmorehouse> so now ... I'm trying to find cube permutations
20:10:32 <gcganley> :jonmorehouse its hard to grok but once you start you cant stop
20:10:37 <jonmorehouse> which means I need to store a data map of minimum cube sums
20:11:12 <argent0> Hi, I'm reading "http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_3" The monads laws, where it says 'm >>= return    =  m' does it means 'm x >>= return    = m x' ?
20:11:42 <benzrf> argent0: that's the same thing
20:12:25 <argent0> benzrf: But onlt the second is 'valid' haskell code?
20:12:32 <jle`> argent0: it also means that x >>= return = x
20:12:42 <jle`> argent0: they are both valid
20:12:44 <Oksana> How do I add an environment \begin{X}content\end{X} to Pandoc LaTeX reader, if I want the output to be "X: content."? https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
20:12:50 <jle`> m is just a normal value variable
20:13:12 <argent0> jle`: Is it not the type constructor?
20:13:13 <jle`> so i can say let y = m x in y >>= return, and y >>= return = y
20:13:14 <gcganley> :jonmorehouse i dont get what im trying to do by that short definition, do you have a formal definition or a wikipedia article
20:13:19 <Lutin`> jonmorehouse: How is 442221 a permutation?
20:13:24 <jle`> argent0: ah, no.  we are at the value level
20:13:29 <jle`> (>>=) is a value-level function
20:13:34 <jle`> so it takes two values
20:13:39 <jle`> return is also a value-level function
20:13:50 <jle`> like... show, or (+ 3), or length
20:14:04 <jle`> m is just a variable
20:14:04 <jonmorehouse> so basically what I'm trying to do
20:14:19 <jle`> you could rewrite the law as aardvark >>= return = aardvark
20:14:28 <jle`> where aardvark :: Monad m => m a
20:14:42 <jonmorehouse> is start at 1 ... and calculate the cube for each integer. For each interation, I need to store a unique id (the permutation string from before) and cache the smallest cube and the number of times that permutation has been used
20:14:50 <jle`> argent0: are you familiar with the difference between values and types?
20:15:02 <jle`> Maybe vs. [1,2,3]
20:15:25 <gcganley> > take 5 [x^3 | x <- [1..]]
20:15:27 <lambdabot>  [1,8,27,64,125]
20:15:31 <thang1> jonmorehouse: wut
20:15:32 <gcganley> like that?
20:16:04 <gcganley> > take 10 [x^3 | x <- [1..]]
20:16:05 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000]
20:16:12 <argent0> jle`: Maybe is a typeclass and [1,2,3] is a value of typeclass [Int] ?
20:16:16 <jonmorehouse> https://gist.github.com/fb5b2c07739f536370aa
20:16:25 <thang1> Why do you need a unique ID, the smallest cube, or the number of times that a permutation has been used? That has nothing to do with calculating cubes
20:16:39 <jle`> argent0: Maybe is a type
20:16:41 <jle`> constructor
20:16:49 <jonmorehouse> thang1: because I'm trying to figure out what numbers have the most amount of cubes for the smallest sum possible
20:16:54 <roboguy_> argent0: no, Maybe is a type (specifically a type constructor) and so is [Int]
20:17:00 <jonmorehouse> ie ... a number such as 403432 that has 3 cubes ...
20:17:01 <roboguy_> a type class is a class of types
20:17:13 <jonmorehouse> I've written the algo in python ... just trying to figure out a solid way to write it here
20:17:18 <Lutin`> jonmorehouse: Is this modulo some number?
20:17:40 <jonmorehouse> Lutin`: no module needed
20:17:49 <Lutin`> or are you saying there exist a,b,c such that a^3 + b^3 + c^3 = 403432
20:18:08 <jonmorehouse> Lutin`: yes
20:18:15 <gcganley> :jonmorehouse oh...
20:18:24 <jonmorehouse> and I'm trying to figure out whats the smallest number, a / b or c
20:18:48 <jle`> argent0: so, Int is a type.  [Int] is a type.
20:18:52 <jle`> Eq is a typeclass
20:19:02 <jonmorehouse> so first step I'm trying to do is keep a map of how often a permutation occures
20:19:04 <jle`> all things that are "instances" of Eq have (==), (/=) defined
20:19:13 <gcganley> show the python and i'll try and get what youre saying
20:19:26 <jonmorehouse> so say I have hash t ... I need to increment t[p_id]
20:19:44 <jonmorehouse> https://gist.github.com/anonymous/91750370ff050e1fa208
20:19:46 <thang1> I feel seeing the python would be far clearer, too. You're trying to tell us the implementation in haskell using a procedural mindset and the idea isn't getting across
20:19:53 <gcganley> first off when you say hash you mean map no?
20:20:07 <jonmorehouse> gcganley: yeah ...
20:21:34 <Lutin`> I think I just don't follow how these are permutations
20:22:24 <jonmorehouse> Lutin`: well the permutation comes from the fact that the set of integers composing the sum are the same
20:22:47 <jonmorehouse> so [2,2,1] == [1,2,2] and a^3 = 221 and b^3 == 122
20:23:01 <gcganley> :jonmorehouse i have to go to bed lol, goodnight
20:24:10 <mm_freak_> hi there
20:24:35 <Qfwfq> Anyone know of an existing packaging of WaitHandle? I could pull out the definition in openshake, but don't want to do so redundantly.
20:24:46 <mm_freak_> could you recommend a deterministic (!) cryptographic PRNG library?
20:25:06 <mm_freak_> cprng-aes is impure, and DRBG uses crypto-api, which insists on reseeding
20:25:43 <thang1> This python code is strangely practically incomprehensible to me for some reason
20:26:32 <Lutin`> jonmorehouse: What do you mean a^3 = 221
20:26:38 <Lutin`> There is no such integer
20:29:21 <orb__> jonmorehouse, in ghci :m + Data.List Control.Arrow Data.Map
20:29:30 <orb__> fromListWith (++) $ fmap ((sort.show)&&&(:[])) [1..1000]
20:30:13 <orb__> Oh, I forgot to cube.
20:30:41 <jle`> mm_freak_: you're not looking for something like random-tf ?
20:31:01 <orb__> fromListWith (++) $ fmap ((sort.show.(^3)) &&& (:[])) [1..100]
20:31:16 <orb__> jonmorehouse, but not sure whether that helps you understand.
20:33:13 <orb__> And filtering out only the ones that have more than 1 cube: Data.Map.filter ((>1) . length) . fromListWith (++) $ fmap ((sort.show.(^3))&&&(:[])) [1..1000]
20:33:28 <thang1> I still don't know wtf this program is trying to do
20:34:25 <orb__> thang1, I assume, look for all numbers (in a range), whose cubes have the same digits?
20:35:09 <mm_freak_> jle`: can't find random-tf
20:35:26 <jonmorehouse> orb__: Yeah ... I'm pretty loste
20:35:37 <jonmorehouse> so I basically need to iterate over a series of numbers
20:35:41 <mm_freak_> jle`: and i think i'll just use AES-CTR, since seekability will be very useful
20:36:01 <jonmorehouse> and I need to store permutationIds (sorted list of integers that make up a number)
20:36:02 <Lutin`> jonmorehouse: So you're looking for the first n primes such that the digits of their cubes are permutations of each other?
20:36:10 <jonmorehouse> Lutin`: yes
20:36:16 <Lutin`> i.e. in your python n = 3
20:36:21 <thang1> Oh well that makes sense, why didn't you just say that in the first place?
20:36:33 <jonmorehouse> sorry, just having trouble articulating it all
20:36:45 <Lutin`> Or wait, not just primes
20:37:13 <jle`> mm_freak_: oh, i mean tf-random
20:37:20 <jonmorehouse> yeah ... sorry, that wouldn't be just primes
20:37:21 <jle`> wait
20:37:23 <jle`> do i?
20:37:36 <jle`> yeah
20:37:41 <orb__> jonmorehouse, do you have a link to the task description?
20:38:30 <jonmorehouse> https://gist.github.com/34bed104dc96d376bdcf
20:38:37 <thang1> problem 62 of project euler seems to be it
20:38:45 <pharpend> hi jle`
20:39:06 <thang1> yeah that's word for word copy and paste of project euler's 62nd problem
20:39:23 <jonmorehouse> thang1: yup!
20:39:50 <jle`> hi pharpend !
20:39:59 <thang1> That would've been way more useful to know. "Hey can I have some help with problem 62 of euler in haskell? I did it in python but I'm lost" would've gotten us knowing exactly what you were struggling with in about 3 seconds :p
20:40:11 <thang1> vs like 25 minutes later just finally figuring out you're doing project euler
20:41:01 <jonmorehouse> I know, I know
20:41:04 <mm_freak_> jle`: "Please note that even though the generator provides very high-quality pseudorandom numbers, it has not been designed with cryptographic applications in mind."
20:41:09 <jonmorehouse> I've been trying to be stubborn and figure this out ...
20:41:15 <orb__> Data.Map and fromListWith should give you a naive solution.
20:41:22 <jonmorehouse> but I'm failing. I'm on a hard time crunch and what not ...
20:41:34 <jonmorehouse> orb__: for my question?
20:41:35 <orb__> jonmorehouse, why no time?
20:41:37 <thang1> it's all good, but it's good to give us as much info as possible so we can help faster :p
20:41:39 <orb__> jonmorehouse, yes.
20:41:48 <jonmorehouse> ohh geez ... I'm lost there
20:41:52 <Oksana> How do I add an environment \begin{X}content\end{X} to Pandoc LaTeX reader, if I want the output to be "X: content."? https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
20:42:07 <orb__> Data.Map is the equilavent to Python's dicts.
20:42:12 <mm_freak_> jle`: thanks, but i'll go with AES-CTR for now (and probably for a long time)
20:42:27 <roboguy_> Oksana: it would help if you gave a little more context. that file is 1294 lines of code
20:42:32 <orb__> the *With functions in Data.Map allow you to merge values with a same key, given a merging function.
20:43:33 <jonmorehouse> hmm ... so high level, I should create a list with each entry being (n, n**3, sort (show sum))
20:43:37 <jonmorehouse> and then I can do a merge on that?
20:43:37 <thang1> It's also useful to note that haskell is comfortable with infinite structures of data
20:43:40 <orb__> Ie we merge by their normalize version of (sort . show . (**3))
20:43:52 <Oksana> roboguy_: I want to add a new member to the list 'environments' at line 971
20:44:14 <orb__> thang1, yes, but would be hard to use infinite lists here.
20:44:21 <merijn> thang1, jonmorehouse: tbh, I think project euler is a pretty bad way to practice haskell anyway :)
20:44:23 <orb__> jonmorehouse, sort-of.
20:44:28 <Oksana> It would go something like : , ("
20:44:32 <orb__> merijn, unless you already know haskell.
20:44:41 <Oksana> It would go something like : , ("X", Haskell code)
20:44:47 <jonmorehouse> orb__: anyway you could throw together that code? I'm so lost
20:44:58 <orb__> jonmorehouse, what would you learn? ;o)
20:44:59 <jonmorehouse> I literally started haskell 2 hrs ago, for all intents and purposes ...
20:45:12 <orb__> Try LYAH, that's a better intro, I guess.
20:45:16 <thang1> actually
20:45:22 <orb__> I could give you the solution, but I'm not sure you'd learn anything from it.
20:45:28 <thang1> I don't recommend LYAH or real world haskell tbh
20:45:33 <jonmorehouse> orb__: well it would help me out of a bind
20:45:37 <thang1> not that they're bad but I tend to find CIS 194 a better introduction
20:45:47 <orb__> jonmorehouse, why?  You getting paid to solve project euler?
20:45:47 <jonmorehouse> I'm going to dive in to the solution, I just need to get on the right path
20:45:58 <jonmorehouse> nope, just a code challenge for a job
20:46:04 <orb__> Can you past your python solution?
20:46:13 <orb__> jonmorehouse, applying for a job?
20:46:14 <jonmorehouse> to them? no, they want a functional language
20:46:17 <jonmorehouse> yeah
20:46:35 <thang1> But if you don't know one, why would you apply for a job that wants you to code in one?
20:46:36 <jonmorehouse> but not in haskell. Its just a brain buster. I'm not looking to turn the solution in, I just need to dive through and figure out what the hell I'm doing
20:46:40 <orb__> jonmorehouse, if I give you the solution, they should hire me. ;o)
20:46:58 <mm_freak_> thang1: personal growth =)
20:47:02 <jonmorehouse> I know! Well the job is a ruby job and would give time to learn erlang/haskell in a more reasonable timeline
20:47:24 <jonmorehouse> orb__: indeed, yeah, I'm struggling though! any help would be awesome
20:47:37 <Oksana> Where Haskell code should be (maybe) "Keywords: " blocks "."
20:47:38 <thang1> if it's a ruby job, requiring code that isn't in ruby seems weird
20:47:39 <orb__> jonmorehouse, can you paste the python solution as a gist (or hpaste).
20:47:58 <jonmorehouse> https://gist.github.com/1bfcc3a07841d5c2c65c
20:48:20 <Oksana> If spaces work like concatenation, and if blocks is equal to content inside the environment.
20:49:24 <thang1> https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
20:49:38 <thang1> This is one of my favorite "introduction to haskell" courses. It's based off of CIS 194 which is my favorite intro
20:50:04 <argent0> is it posible to instance a laws-abaiding monad with ' data Pair a = Pair a a'? How could one define (>>=)?
20:50:13 <orb__> jonmorehouse, try head $ sortBy (comparing $ minimum . snd) . toList . Data.Map.filter ((==5) . length) . fromListWith (++) $ fmap ((sort.show.(^3))&&&(:[])) [1..1000000]
20:50:39 <orb__> (needs :m + Data.List Control.Arrow Data.Map Data.Ord first, in ghci.)
20:50:49 <thang1> man that is an ugly function when it's all in one line like that :p
20:51:19 <jonmorehouse> whoa ... just trying to wrap my head around that and get something compiling
20:51:28 <thang1> you know how to use ghci right?
20:51:30 * hackagebot coordinate 0.0.15 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.15 (TonyMorris)
20:51:48 <thang1> It's a oneliner you can basically copy and paste into ghci and it should work
20:51:57 <orb__> thang1, need to import the modules first.
20:52:12 <jonmorehouse> I can put it in my script as well
20:52:17 <thang1> well yeah, but other than that...
20:52:20 <jonmorehouse> just seeing some syntax I didn't even know exists
20:52:41 <thang1> You can simplify the syntax some
20:52:46 <jle`> i'm not sure how helpful these one liners are
20:52:52 <jle`> to someone learning haskell
20:52:56 <lpaste> orb pasted “Euler” at http://lpaste.net/111986
20:52:58 <jle`> haskell isn't about one liners
20:53:10 <jle`> but that's all people are exposed to a lot of times
20:53:15 <roboguy_> argent0: I don't think so. It is a functor though, so there is a free monad for it
20:53:17 <orb__> jle`, indeed.  But I'm not paid to write a sustainable solution here.
20:53:40 <jle`> orb__: well, what is your aim? :)  to help people?
20:53:57 <orb__> jle`, getting jonmorehouse a job. ;o)
20:54:08 <jle`> ah. is this an interview question?
20:54:11 <orb__> jle`, feel free to unpeel the oneliner and explain.
20:54:54 <jonmorehouse> orb__: thanks
20:55:08 <jonmorehouse> so I'm digging through that right now actually ... a few things are sticking out
20:55:14 <jonmorehouse> let me process for a few and come back with a few questions :)
20:55:19 <mm_freak_> dibblego: that's quite an unfortunate package name =)
20:55:20 <jonmorehouse> and thanks, you guys are helping me a ton
20:55:33 <lpaste> orb revised “Euler”: “No title” at http://lpaste.net/111986
20:55:41 <dibblego> mm_freak_: ?
20:56:03 <mm_freak_> dibblego: 'coordinate'
20:56:14 <roboguy_> argent0: the free monad on Pair is a binary tree
20:56:30 * hackagebot wait-handle 0.1 - Packaging of 'WaitHandle', extracted from Max Bolingbroke's OpenShake. Wait  handles are MVars which can only be written to once, and from which values  can never be removed.  http://hackage.haskell.org/package/wait-handle-0.1 (vi)
20:56:37 <jonmorehouse> I'm a little confused...
20:56:44 <jonmorehouse> some modules import functions into the current namespace ...
20:56:48 <orb__> jonmorehouse, by the way, there's no syntax you haven't seen.  But some of the operators (which are not strictly syntax in haskell) will be new.
20:56:51 <jle`> not just any binary tree :O
20:57:00 <jonmorehouse> ie import Data.List ... and you can call toList
20:57:04 <orb__> jonmorehouse,  You can rewrite that to be easier to read.
20:57:08 <orb__> toList comes from Data.Map
20:57:52 <thang1> hmm... running the code just gives the answer "01234556790"
20:58:00 <orb__> fromList takes a list of key-value tuples and produces a Map (like a python dict).  toList takes a Map and produces a list of key-value-tuples.
20:58:14 <thang1> which is the sorted version of the answer, but not the actual answer :p
20:58:25 <orb__> runghc Test.hs: ("012334556789",[8384,8288,7202,7061,5027])
20:58:27 <orb__> For me.
20:58:35 <jonmorehouse> thang1: yeah, just realizing that now
20:58:39 <jonmorehouse> it should be the smallest sum ...
20:59:01 <Oksana> How do I concatenate in Haskell?
20:59:10 <orb__> Oksana, lists?  Use ++
20:59:13 <thang1> well it's the answer as the five numbers given are the primes you're looking for
20:59:22 <orb__> Primes?
20:59:24 <mm_freak_> btw, to a haskell programmer python can be summarised very easily:  type Object = Map String Dynamic
20:59:28 <thang1> the numbers are just arranged wrong :p
20:59:32 <Oksana> Two or three variables.
20:59:34 <thang1> my bad, not primes, I meant cubes
20:59:38 <orb__> mm_freak_, Python ain't that consistent.
20:59:42 <pharpend> Hi guys
20:59:48 <orb__> Don't they have unboxed ints, too?
21:00:05 <ReinH> Oksana: what do you want to concatenate?
21:00:07 <Oksana> Like, "X: " && var && "." How can it be done?
21:00:11 <orb__> thang1, I give the five pre-cubes that have the smallest minimum.
21:00:13 <thang1> Python compiles into some fairly optimized C, and it can get really good if you use things like Cython
21:00:17 <ReinH> Oksana: what type is var?
21:00:29 <Oksana> Text [I think so]
21:00:43 <ReinH> Oksana: Well, the answer will depend on the types
21:00:57 <roboguy_> you could use <> if those are all Text
21:00:59 <threestrikes> I've asked this before so I apologize I didn't write it down but, what are some nice haskell projects to get involved with on github for a beginner?
21:01:00 <ReinH> Although you could use <> for both
21:01:09 <mm_freak_> Oksana: if all components are of the same type, a safe choice is to import Data.Monoid and then use the '<>' operator
21:01:20 <mm_freak_> Oksana: "abc" <> "def" <> "ghi" = "abcdefghi"
21:01:39 <ReinH> but if you want to use string literals as Text values then you'll need the OverloadedStrings extension
21:02:04 <jle`> if you have String, then you can use ++, if you have Text, you can use <>; <> works for both
21:02:47 <threestrikes> ls
21:02:57 <thang1> lol
21:03:00 <mm_freak_> Oksana: and keep in mind that there are multiple text types, each for a different use case…  in particular standard strings are of type String, while compact strings are of type Text
21:03:31 <mm_freak_> and they will not cooperate without conversion =)
21:05:27 <jonmorehouse> orb__: I'm working on a rewrite
21:06:14 <jonmorehouse> so my first step is I'm trying to build that initial map in a function
21:07:51 <roboguy_> :t Data.Map.fromList
21:07:52 <lambdabot> Ord k => [(k, a)] -> M.Map k a
21:08:01 <roboguy_> ^ jonmorehouse: you'll probably want that
21:08:07 <Oksana> Hn... I better go and re-read the code, to understand what type of variables is used, and how it is used. Line 971, adding a new environment to https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
21:08:40 <jonmorehouse> roboguy_: not sure where/how
21:08:43 <jonmorehouse> but working on it
21:08:57 <roboguy_> jonmorehouse: it is a function that takes a list of key/value pairs and gives you a map
21:08:59 <Axman6> roboguy_: or fromListWith as someone suggested earlier (if this is still the same problem)
21:10:01 <roboguy_> Axman6: ah, good point
21:10:05 <argent0> roboguy_: Thanks for the answer! Is that a "free theorem"? The binary tree monad on Pair?
21:10:08 <roboguy_> :t Data.Map.fromListWith
21:10:10 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
21:10:24 <roboguy_> argent0: no, a free theorem is something that you get from a polymorphic type signature
21:10:43 <roboguy_> a free monad is the monad that is created by a functor for "free"
21:11:03 <roboguy_> here's a package that implements it: http://hackage.haskell.org/package/free/docs/Control-Monad-Free.html
21:11:14 <argent0> roboguy_: Ok, I'll check it out =)
21:11:15 <CrazyM4n> Can someone test how smooth something runs on linux?
21:11:34 <CrazyM4n> http://lpaste.net/7482254408873410560 I just want to know if it has the weird spazzy effect
21:11:37 <CrazyM4n> If it is windows only
21:11:50 <roboguy_> argent0: I'd skip the MonadFree type class for the moment. I think that just exists to help out with monad transformers
21:12:20 <Axman6> hmm, can pairs make a Monad? I thought there were issues in implementing join
21:12:35 <jonmorehouse> roboguy_: I can't get that to compile
21:12:41 <AshyIsMe> threestrikes: i just made the lambdatwit twitter bot https://github.com/ashyisme/lambdatwit
21:12:47 <AshyIsMe> threestrikes: you can mess around with that if you like
21:12:51 <jonmorehouse> anyway you could send me a gist with what it should look like?
21:12:59 <AshyIsMe> it uses the same engine as lambdabot in this channel
21:13:40 <roboguy_> CrazyM4n: what should the grid file be?
21:13:51 <CrazyM4n> roboguy_: oops, let me upload it
21:14:04 <CrazyM4n> http://lpaste.net/3565033055674433536try that
21:14:08 <CrazyM4n> http://lpaste.net/3565033055674433536
21:15:15 <orb__> Axman6, join is easy.  But how do you do return / pure for a pair?
21:15:19 <CrazyM4n> Anyone experienced with gloss that can help me convert that from ASCII graphics to Gloss?
21:15:24 <roboguy_> CrazyM4n: looks really smooth on the OS X terminal actually. what does that effect look like?
21:15:41 <CrazyM4n> roboguy_: I´ll upload a video, it´s jittery
21:15:48 <orb__> join (a,(a',b)) = (a,b)
21:15:54 <orb__> or (a', b)
21:16:08 <Axman6> orb__: someone was working on data Pair a = Pair a a earlier. join (Pair (Pair a b) (Pair c d)) = ?
21:16:17 <orb__> Oh, that kind of pair.
21:16:17 <roboguy_> CrazyM4n: hmm might be a Windows thing then. I don't see any jitter
21:16:30 <CrazyM4n> roboguy_: I´ll run it in cygwin and cmd side by side
21:16:33 <CrazyM4n> You´ll see
21:16:35 <orb__> You could do a join that forgets?
21:16:50 <Axman6> I think that breaks one of the monad laws
21:17:06 <orb__> join (Pair (Pair a b) (Pair c d)) = Pair a b, or Pair a d, or Pair a c?
21:17:08 <roboguy_> yeah that at least breaks the second law
21:17:11 <orb__> Axman6, oh, probably.
21:17:33 <roboguy_> you can apply Free to it though to get a binary tree
21:17:44 <thang1> don't run it in cmd, run it in powershell
21:17:53 <thang1> cmd is really old and shitty at times
21:17:55 <CrazyM4n> thang1: How?
21:18:02 <mm_freak_> orb__: data Pair a = Pair a a?
21:18:04 <thang1> should be able to run it the same way you would in cmd ._.
21:18:16 <CrazyM4n> thang1: Don´t worry, it works fine in cygwin
21:18:17 <orb__> mm_freak_, that's what Axman6 said.
21:18:33 <thang1> I'm guessing it's the fact that cmd's probably got a frame limitation or something in it somewhere
21:18:41 <mm_freak_> then it's:  join (Pair (Pair a _) (Pair _ b)) = Pair a b
21:19:05 <mm_freak_> a strict version of that is defined in the 'linear' library called V2
21:19:12 <mm_freak_> data V2 a = V2 !a !a
21:19:16 <orb__> mm_freak_, roboguy_ says that breaks the second monad law.
21:19:29 <mm_freak_> how?
21:20:57 <mm_freak_> it's the usual diagonalising zipping monad for fixed length vectors and streams
21:21:21 <mm_freak_> in particular:  Pair f g <*> Pair x y = Pair (f x) (g y)
21:21:26 <CrazyM4n> roboguy_: https://www.youtube.com/watch?v=xd_AnVL5TzA&feature=youtu.be
21:21:28 <roboguy_> oh, maybe I'm wrong
21:21:42 <mm_freak_> and that's exactly what 'ap' gives you with that definition of 'join'
21:21:56 <CrazyM4n> How do you, you know, make a video private
21:22:10 <thang1> It should be in the youtube settings for the video in your account channel
21:22:23 <jonmorehouse> hey so I'm trying to break down the solution
21:22:26 <jonmorehouse> and just can't get this working
21:22:33 <thang1> what do you have so far
21:22:33 <roboguy_> CrazyM4n: yeah, it looks like the one on the right for me. cmd is probably slow at clearing the screen
21:22:35 <thang1> ?
21:22:46 <jonmorehouse> could anyone show me how to make this a function...
21:22:50 <CrazyM4n> roboguy_: Probably, but it´s terrible and ugly and I don´t like it :C
21:22:51 <jonmorehouse>   let a = map (^3) [0..99999]
21:23:02 <jonmorehouse> so thats in the do nomad block (if I'm correct on the wording)
21:23:07 <jonmorehouse> and I want to make it a function
21:23:19 <jonmorehouse> so i have sumMap = (^3) [0..9999]
21:23:37 <Axman6> where's map there?
21:23:41 <orb__> jonmorehouse, that doesn't type.  What should the inputs and outputs of your function be?
21:24:03 <orb__> jonmorehouse, you don't need no monads for your euler problem.  Forget about monads for now.
21:24:04 <jonmorehouse> the input should be nothing
21:24:09 <jonmorehouse> ok
21:24:13 <orb__> jonmorehouse, than it's just a constant, not a function.
21:24:20 <jonmorehouse> the output should just be a map with the cubes for each value
21:24:24 <jonmorehouse> orb__: yes
21:24:35 <orb__> just plop down a = map (^3) [0..9999] on its own line at somewhere in your program.
21:24:44 <orb__> At the top level, not embedded in anything.
21:24:49 <CrazyM4n> What´s the white block character in command prompt?
21:24:55 <orb__> CrazyM4n, cursor?
21:25:11 <stolaruk> what command prompt
21:25:28 <CrazyM4n> Never mind, I meant this █
21:25:30 <jonmorehouse> kkkok orb ... got that
21:25:33 <CrazyM4n> Haha
21:25:36 <jonmorehouse> so the next one I'm trying to figure out
21:25:46 <jonmorehouse> is how do I write a function ,where I pass in that sumMap
21:25:48 <orb__> jonmorehouse, in general, Haskell doesn't care too much whether you are defining a function or a constant.
21:25:50 <jonmorehouse> and return a nother map ...
21:26:00 <orb__> what's your function supposed to do?
21:26:02 <roboguy_> jonmorehouse: what do you want to do with it
21:26:29 <orb__> By the way, that thing is just a list of cubes, produced by the map function, but no (capital M) Map involved.
21:26:33 <jonmorehouse> I'm trying to just dig through this example and break it down and understand small principles
21:26:46 <orb__> The naming is a bit confusing here, the map function has nothing to do with the Map datatype.
21:26:51 <orb__> jonmorehouse, ok.
21:27:00 <jonmorehouse> orb__: well that makes a lot sense. Lightbulb!
21:27:13 <jonmorehouse> what does the dollar sign mean?
21:27:23 <orb__> function application.
21:27:26 <stolaruk> jonmorehouse: When you say "return a map" you probably mean "return a list"
21:27:29 <orb__> It's only to avoid parens.
21:27:29 <thang1> the dollar sign applies the values of the left to the right
21:27:33 <haasn> @src ($)
21:27:33 <lambdabot> f $ x = f x
21:27:38 <orb__> a $ b $ c $ d == a (b (c d))
21:27:45 <thang1> e.g. 3 + 4 + 5  is the same as (3 + 4) + 5
21:27:56 <thang1> but if you want to force it you can type 3 + (4 + 5) right?
21:28:05 <orb__> thang1, yes, but that wouldn't work for $.
21:28:22 <thang1> meh true, just trying to get the idea across intuitively
21:28:24 <orb__> ((a $ b) $ c) $ d =/= a $ b $ c $ d
21:28:33 <orb__> thang1, sure.
21:28:36 <thang1> ignore me then :p
21:28:58 <thang1> I had a better example I had off the top of my head but I've forgotten it
21:29:01 <orb__> When you can pop your parens whereever you want them, eg for + and *, we call those operations associative.
21:29:26 <orb__> $ is not associative.  Function composition written as . is
21:29:42 <thang1> right, thanks for the reminder
21:29:49 <thang1> your example was better anyway lol
21:31:32 * hackagebot conduit 1.2.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.1 (MichaelSnoyman)
21:31:33 <orb__> thang1, nah, your's was good, too.
21:31:49 <thang1> I'm touched, truly :p
21:31:59 <orb__> jonmorehouse, http://lpaste.net/111990 separates the actual computation from the IO stuff (printing).
21:34:09 <orb__> jonmorehouse, http://lpaste.net/111990 avoids
21:34:20 <orb__> avoids Arrows.  Ie should be easier to read.
21:36:39 <lpaste> orb revised “Euler, too”: “No title” at http://lpaste.net/111990
21:36:47 <orb__> Now with some type annotation.
21:37:50 <stolaruk> Is there any way to runhaskell a project in a cabal sandbox? Compiling every time w/ "cabal run" takes a while.
21:38:52 <karshan> stolaruk you can just compile with cabal install and run with .cabal-sandbox/bin/projectname
21:39:42 <noonan> I have a hopefully easy parsec question: I want to parse sums of products like "a b + c d e + f"
21:39:44 <stolaruk> karshan: I'd like to be able to make a small change in my code and just run (interpret) the project
21:39:55 <stolaruk> karshan: without having to compile again
21:40:17 <orb__> noonan, ok, how much do you already know?
21:40:52 <noonan> I tried something like p_sum = p_product `sepBy` (spaces *> char '+' <* spaces) and p_product = p_term `sepBy` spaces, but it doesn't work because sepBy wants to parse a p_term after the spaces before a +
21:40:59 <karshan> stolaruk: well if you make a change you have to your source recompile :(. cabal will also only recompile files that were changed, but unfortunately recompilling takes a while. mostly due to startup. I find if I run cabal repl and use :r to recomiple it is usually a bit faster
21:41:14 <noonan> orb__, Real World Haskell-ish level
21:41:41 <stolaruk> karshan: Yeah, I guess it just comes with the territory of writing in a compiled language. Thanks.
21:41:53 <orb__> noonan, let me think.  Seems like you already know a bit, so I need to think harder to be of help.
21:42:52 <nitrix> What would be the type signature of a function that takes a string, and potentially returns a string or nothing, based on a side-effect (http request) ?
21:43:07 <orb__> String -> IO (Maybe String)
21:43:08 <nitrix> :: String -> Maybe (IO String) ?
21:43:19 <nitrix> oh okay
21:43:34 <orb__> nitrix, Maybe (IO String) would only work, if you could tell what to do before doing the side effect.
21:43:40 <nitrix> orb__: right.
21:43:42 <orb__> Ie if you could tell just by looking at the input string.
21:43:47 <nitrix> Makes sense.
21:44:11 <roboguy_> You could do MaybeT IO String if you wanted to work with transformers
21:44:15 <roboguy_> @unmtl MaybeT IO String
21:44:16 <lambdabot> IO (Maybe String)
21:44:54 <nitrix> roboguy_: Too much of a beginner to do any of that yet ;)
21:45:53 <orb__> lambdabot, <*
21:45:57 <orb__> lambdabot, :t (<*)
21:46:12 <orb__> <* came from Control.Applicative, didn't it?
21:46:17 <Axman6> :t (<*)
21:46:17 <noonan> right
21:46:18 <lambdabot> Applicative f => f a -> f b -> f a
21:46:23 <jle`> i think you could work with String -> IO (Maybe String) without involving transformers
21:46:25 <Axman6> @hoogle (<*)
21:46:27 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
21:46:27 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:46:27 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:46:33 * hackagebot webdriver-snoy 0.6.0.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-snoy-0.6.0.2 (MichaelSnoyman)
21:46:34 * hackagebot webdriver-snoy 0.6.0.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-snoy-0.6.0.3 (MichaelSnoyman)
21:46:36 <jle`> no need to involve trasnformers
21:47:05 <orb__> Which module has the Applicative instance for Parsec?
21:47:53 <noonan> I'm just using regular old Control.Applicative and Text.ParserCombinators.Parsec
21:47:54 <roboguy_> yeah you can go overboard with transfomers
21:47:59 <roboguy_> *transformers
21:48:02 <roboguy_> @unmtl ReaderT String (MaybeT IO) String
21:48:02 <lambdabot> String -> (MaybeT IO) String
21:48:54 <orb__> noonan, strange, I must have an old version or something.
21:49:04 <noonan> but even if you assume exactly one space everywhere, I still have problems (e.g. p_sum = p_product `sepBy` string " | "; p_product = p_term `sepBy` char ' ')
21:49:14 <jle`> if you really want to work with IO (Maybe Strings), try making a newtype wrapper and writing a Monad instance on IO (Maybe a)
21:49:27 <FreeFull> @unmtl String -> (MaybeT IO) String
21:49:27 <lambdabot> String -> (MaybeT IO) String
21:49:31 <FreeFull> @unmtl String -> MaybeT IO String
21:49:32 <lambdabot> String -> MaybeT IO String
21:49:35 <FreeFull> Odd
21:49:35 <jle`> that way you can use (>>=)/do blocks/etc. with IO and short-circuiting
21:49:37 <benzrf> bye
21:49:37 <jle`> hoorah
21:49:40 <roboguy_> @mtl String -> MaybeT IO String
21:49:40 <lambdabot> Maybe you meant: url unmtl pl msg
21:49:43 <FreeFull> I'd expect it to go further
21:50:08 <roboguy_> yeah, I did too. I could have sworn I've seen it reduce things further before...
21:50:22 <orb__> jle`, someone already wrote those short-circuiting things, if I remember right.  But that probably involved transformers.
21:50:44 <jle`> transformers has it pre-built, but there's almost no effort involved in writing your own
21:50:53 <CrazyM4n> What´s a Repa array? https://hackage.haskell.org/package/gloss-raster-1.8.1.2/docs/Graphics-Gloss-Raster-Array.html if you wanna know why I know
21:50:57 <jle`> transformers also abstracts it a bit
21:51:04 <jle`> by parametrizing on what is IO here
21:51:08 <jle`> parameterizing
21:51:17 <CrazyM4n> Err, how do you convert a list to a Repa array is a better question
21:51:21 <noonan> ooh, I think I've got it: p_product = p_term `sepBy` try (char ' ' >> lookAhead something) seems to do the trick
21:51:24 <jle`> CrazyM4n: isn't there a toList?
21:51:27 <FreeFull> CrazyM4n: Repa is a library that provides very fast arrays
21:51:33 * hackagebot webdriver-snoy 0.6.0.4 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-snoy-0.6.0.4 (MichaelSnoyman)
21:51:38 <jle`> and...free parallelism through fusion
21:51:40 <jle`> yay!
21:51:53 <FreeFull> And vectors too
21:52:02 <zmthy> noonan, the sepBy is getting confused because it sees a space and so expects another term
21:52:13 <CrazyM4n> jle`: Uh, toList does the opposite
21:52:17 <jle`> CrazyM4n: oops :P
21:52:22 <FreeFull> CrazyM4n: fromList?
21:52:43 <noonan> zmthy: yeah, I got confused about where to put a try to get it to properly backtrack
21:52:54 <Axman6> fusion gives you free deforestation
21:52:59 <Axman6> not free parallelism
21:53:02 <jle`> this is my favorite repa reference http://chimera.labs.oreilly.com/books/1230000000929/ch05.html
21:53:09 <CrazyM4n> Oh. yeah. What´s the difference between a boxed and an unboxed array?
21:53:25 <Axman6> CrazyM4n: int[] vs int * []
21:53:33 <Axman6> if you know C that is...
21:53:43 <jle`> repa takes advantage of fusion to do implicit parallelization
21:53:45 <CrazyM4n> Not rally
21:53:48 <Axman6> (that should probably be int * [] vs int[])
21:53:48 <CrazyM4n> *really
21:53:52 <FreeFull> A boxed array has more indirection
21:53:57 <jle`> ...i think
21:54:18 <Axman6> unboxed means you have a contiguous section of memory full of value, boxed is a contiguous array of poiinters to values
21:54:22 <FreeFull> It lets you have each element have independent strictness
21:54:41 <orb__> noonan, try sepEndBy.
21:54:58 <noonan> :t sepEndBy
21:55:01 <lambdabot> Not in scope: ‘sepEndBy’
21:55:32 <orb__> Text.ParserCombinators.Parsec.Combinator.sepEndBy
21:55:43 <mm_freak_> orb__, roboguy_: proved the monad laws for Pair for fun: http://lpaste.net/111994
21:55:51 <CrazyM4n> https://hackage.haskell.org/package/repa-3.3.1.2/docs/Data-Array-Repa-Eval.html#v:fromList I read the docs, but I don´t quite understand the shape argument
21:55:55 <orb__> mm_freak_, cool.
21:56:03 <noonan> orb__: nice, that looks like it would work out too
21:56:12 <orb__> noonan, doesn't work for preceeding spaces, though.
21:56:17 <orb__> But for spaces at the end it seems to help.
21:56:24 <orb__> Just slap some optional spaces at the front, then.
21:56:31 <jle`> CrazyM4n: did you look at the link i posted?
21:56:33 * hackagebot wait-handle 0.1.1 - Wait handles are MVars which can only be written to once, and from which values can never be removed.  http://hackage.haskell.org/package/wait-handle-0.1.1 (vi)
21:56:45 <CrazyM4n> jle`: No, oops
21:56:49 <Axman6> mm_freak_: huh, nice work
21:57:44 <jle`> mm_freak_: now make it inductive to work for all fixed length vectors
21:57:51 <orb__> mm_freak_, now make lenses. :o)
21:57:56 <mm_freak_> i'd rather do that in agda =)
21:58:15 <orb__> jonmorehouse, any progress?
21:58:17 <mm_freak_> jle`: actually i did that once, but haven't saved it
21:58:34 <jle`> i started but i'm not sure what happened.  i don't remember finishing it
21:58:36 <jle`> hm
21:58:38 <mm_freak_> jle`: coinductive in fact
21:58:47 <orb__> jle`, I can do zero and one length vectors.
21:59:00 <jle`> orb__: ;D
21:59:04 <orb__> since mm_freak_ already proved 2, we can use induction.
21:59:19 <mm_freak_> orb__: i proved 2, not n → 1 + n ;)
21:59:54 <orb__> mm_freak_, details.
22:00:23 <jle`> orb__: you can use induction if you can prove that n being true implies n + 1 being true, for all n > base case
22:00:36 <orb__> https://proofwiki.org/wiki/All_Horses_are_the_Same_Colour
22:00:47 <jle`> so just proving two values of n doesn't cut it ;)
22:01:26 <jle`> ah, is joke
22:01:33 * hackagebot sdl2 1.1.1 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.1.1 (Polarina)
22:01:53 <jle`> mm_freak_: i wonder if the coinductive proof would be related at all to the fact that (0 or 1) length vectors have a Monad instance
22:02:03 <orb__> jle`, yeah, I know.  By the way, the horses proof took me a while to figure out (I didn't have the solution back then).
22:02:16 <jle`> as in, V(0) + V(1)
22:02:32 <Axman6> it should be somewhat trivial to do though: join (Three (Three a b c) (Three t u v) (Three x y z)) = Three a t z and return is trivial
22:02:43 <Axman6> and that should hold for all n
22:03:05 <orb__> :t id id id id id id id id id id id id id id id id id id id id id id id id
22:03:06 <lambdabot> a -> a
22:03:16 <stolaruk> (boom)
22:03:21 <orb__> :t id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id
22:03:22 <lambdabot> a -> a
22:03:32 <AshyIsMe> > fix id
22:03:36 <lambdabot>  mueval-core: Time limit exceeded
22:03:37 <orb__> Hmm, lambdabot is faster than ghci.
22:03:49 <dmj`> > do do do 4 + 4
22:03:50 <lambdabot>  8
22:04:04 <jle`> Axman6: you have a system for generating the instances; can you prove that all such instances follow the laws?
22:04:14 <orb__> dmj`, what instance of Monads is that?
22:04:27 <stolaruk> IO I would think
22:04:35 <jle`> it doesn't quite matter
22:04:37 <jle`> hm
22:04:39 <Axman6> orb__: none, it's basically just taking advantage of rewriting
22:04:41 <dmj`> orb__: do doesn't require a monad!
22:04:44 <Axman6> > do 7
22:04:45 <orb__> 4 is not of type IO a, is it?
22:04:45 <lambdabot>  7
22:04:47 <jle`> @undo do 5
22:04:47 <lambdabot> 5
22:04:48 <dmj`> its a trap!
22:04:51 <jle`> @undo do x
22:04:51 <lambdabot> x
22:04:55 <jle`> do x desugars to x
22:04:57 <orb__> dmj`, oh, what does do require?
22:04:59 <dmj`> in pure functions you can use let with do as well
22:05:00 <orb__> ok.
22:05:02 <Axman6> the rewrtiting happens before type checking I think
22:05:06 <jle`> it's simple desugaring
22:05:09 <orb__> OK.
22:05:39 <orb__> > do 1; 2
22:05:40 <lambdabot>  Could not deduce (GHC.Num.Num (m a0))
22:05:40 <lambdabot>    arising from the ambiguity check for ‘e_112’
22:05:40 <lambdabot>  from the context (GHC.Num.Num (m b),
22:05:40 <lambdabot>                    GHC.Num.Num (m a),
22:05:40 <lambdabot>                    GHC.Base.Monad m)
22:05:42 <orb__> Good.
22:05:50 <jle`> @undo do x; y
22:05:50 <lambdabot> x >> y
22:05:58 <orb__> @undo do 1; 2
22:05:58 <lambdabot> 1 >> 2
22:05:58 <jle`> so you need Monad m to use (>>)
22:06:02 <orb__> Yes.
22:06:08 <Axman6> jle`: I think mm_freak_'s proof should be essentially the same for all sizes of tupleish monad instances
22:06:23 <orb__> Axman6, apart from zero, I guess.
22:06:36 <dmj`> jle`: that 1 >> 2 can't be right
22:06:36 <Axman6> assuming in join that element n of the result comes from the n'th element of the nth tuple
22:06:39 <jle`> Axman6: that's not a proof, though
22:06:54 <jle`> that's an infinite amount of proofs ;)
22:06:55 <dmj`> @typ do 1; 2
22:06:56 <lambdabot> (Num (m b), Num (m a), Monad m) => m b
22:07:01 <roboguy_> dmj`: I don't think @undo type checks
22:07:02 * dmj` gasps
22:07:11 <Axman6> jle`: I think the proof would be a lot easier with dependant types
22:07:16 <orb__> do 1; 2 certain typechecks, with the right instances.
22:07:21 <roboguy_> @undo do 'a'; 'b'
22:07:21 <lambdabot> 'a' >> 'b'
22:07:29 <orb__> :t do 'a'; 'b'
22:07:30 <lambdabot>     Couldn't match expected type ‘m a0’ with actual type ‘Char’
22:07:30 <lambdabot>     In a stmt of a 'do' block: 'a'
22:07:30 <lambdabot>     In the expression:
22:07:31 <Axman6> well, io can see how to do it with length indexed Vectors anyway
22:08:06 <jle`> of 0-or-1 length vectors are Monads...can any sum of n-length vectors be monads?
22:08:14 <jle`> zippy-monads
22:09:04 <Axman6> join Nil = Nil; join ((v:vs):vss) = v : join (map tail vss)
22:09:25 <Axman6> should work fgine in Idris (substituting : with ::)
22:10:29 <Axman6> the typer system ensures all the inner vectors are the same type because you'd need to have join : Vector n (Vector n a) -> Vector n a
22:10:43 <Axman6> far out, I need to quit hitting extra keys
22:11:38 <mm_freak_> jle`: i'm doing the proof right now
22:12:28 <jle`> i haven't found a good answer to the sum-of-fixed-length-vectors generalization
22:12:34 <jle`> i will keep on thinking about it
22:12:42 <jle`> by sum i mean coproduc
22:12:44 <jle`> t
22:14:12 <CrazyM4n> How can I convert an [[Int]] to an Array U DIM2 Int?
22:14:23 <CrazyM4n> I can´t really figure it out
22:14:54 <CrazyM4n> (The [[Int]]´s [Int]s are all the same length so it will work fine)
22:15:35 <dv-> :t listArray
22:15:35 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
22:15:46 <Axman6> wronf Array though
22:15:50 <dmj`> @typ accumArray
22:15:51 <lambdabot> Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
22:15:51 <Axman6> g*
22:16:25 <CrazyM4n> I meant a Repa array
22:16:35 <CrazyM4n> Unless those are equivalent to Repa arrays
22:16:39 <mm_freak_> CrazyM4n: fromListUnboxed
22:16:52 <Axman6> @hoogle fromListUnboxed
22:16:53 <lambdabot> No results found
22:16:59 <CrazyM4n> mm_freak_: But how would I do it to an [[Int]]?
22:17:16 <Axman6> just concat the list
22:17:32 <mm_freak_> CrazyM4n: what Axman6 said
22:17:44 <CrazyM4n> Oh. I really need to take a step back sometimes, haha
22:17:46 <Axman6> fromListUnboxed (concat lists)
22:17:50 <mm_freak_> CrazyM4n: but in general try to avoid the [[Int]] in the first place
22:18:04 <CrazyM4n> mm_freak: It´s just readability´s sake
22:18:10 <CrazyM4n> Not anything seirous ;)
22:18:22 <jle`> hm
22:18:25 <mm_freak_> CrazyM4n: i don't really agree with that =)
22:18:35 <jle`> i wonder if we could extend haskell with custom []-like type level syntax
22:18:41 <jle`> <> a = <<a>>
22:18:45 <jle`> er, <> a = <a>
22:18:46 <CrazyM4n> Well, I´d remake it only using Repl, but meh
22:18:47 <jle`> idk
22:18:50 <CrazyM4n> :S
22:19:12 <mm_freak_> CrazyM4n: allow me to provide a different perspective:  i'd start with a DIM2 -> Int
22:19:36 <mm_freak_> using fromFunction that gives you an Array D DIM2 Int
22:19:41 <mm_freak_> (notice the D rather than U)
22:20:18 <mm_freak_> you would want to avoid U until the very last moment when you actually compute the array
22:20:42 <roboguy_> jle`: don't we already have type level lists with [] syntax?
22:21:02 <jle`> roboguy_: i mean, to be able to make your own type constructors act like [] syntax
22:21:23 <jle`> type <a> = Array Int a
22:21:27 <roboguy_> ah
22:21:34 <jle`> so i could do foo :: <a> -> <b> -> <c>
22:21:54 <jle`> instance Functor <> where...
22:21:59 <CrazyM4n> mm_freak_: This is the last step, but what´s the difference between D and U?
22:22:20 <mm_freak_> CrazyM4n: a D is not an actual array in memory, but just a function from index to value
22:22:25 <CrazyM4n> Just looked it up
22:22:35 <CrazyM4n> Makes sense, but this needs to be a U array
22:22:37 <roboguy_> jle`: if you were determined, you could make a preprocessor like SHE
22:22:59 <mm_freak_> CrazyM4n: why?
22:23:01 <dmj`> jle`: we have those unicode things
22:23:13 <Axman6> mm_freak_: for Gloss I believe
22:23:26 <dmj`> {-# UnicodeSyntax #-}
22:23:33 <dmj`> not the same tho
22:23:39 <CrazyM4n> mm_freak_: Scratch that https://hackage.haskell.org/package/gloss-raster-1.8.1.2/docs/Graphics-Gloss-Raster-Array.html#v:animateArray
22:23:45 <CrazyM4n> It has to be a D array
22:24:15 <CrazyM4n> How can I go from U to D when I already have a U
22:24:58 <CrazyM4n> @hoogle delay
22:24:58 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
22:24:58 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
22:24:58 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
22:25:22 <CrazyM4n> whatever, the function is called delay. I don´t quite get the type signature though
22:25:44 <CrazyM4n> Never mind, I get it
22:25:54 <thang1> lol
22:26:34 * hackagebot clean-unions 0.0 - Open unions without need for Typeable  http://hackage.haskell.org/package/clean-unions-0.0 (FumiakiKinoshita)
22:29:17 <Axman6> mm_freak_: how's that proof going?
22:31:24 <jle`> 1. assume an n-length vector has a lawful monad instance
22:31:37 <jle`> 2. give Axman6 the instance and ask him to write an (n+1) length vector instance
22:31:45 <jle`> 3. therefore, having n implies n+1
22:31:56 <jle`> 4. n = 0 has a lawful instance
22:32:08 <jle`> therefore, n length vectors are monads for all n
22:34:31 <mm_freak_> Axman6: i'm having trouble defining 'join' =/
22:35:45 <Axman6> mm_freak_: did you see my length indexed type vector version above?
22:36:17 <Axman6> join Nil = Nil; join ((v:vs):vss) = v : join (map tail vss)
22:36:29 <Axman6> to, sort of, use Idris syntax
22:37:45 <mm_freak_> Axman6: i'm trying to define it in agda right now
22:37:55 <CrazyM4n> Any way not to have to do Repa. everything?
22:38:08 <CrazyM4n> If I don´t import qualified it gives me a bunch of errors of conflicting functions
22:38:58 <mm_freak_> CrazyM4n: you can have two imports
22:39:10 <mm_freak_> one qualified, the other with an explicit import list
22:39:12 <mm_freak_> or a hide list
22:39:24 <mm_freak_> import qualified Data.Array.Repa as R
22:39:46 <mm_freak_> import Data.Array.Repa (Array, U, DIM2, fromFunction, computeP, …)
22:40:10 <mm_freak_> Axman6: http://lpaste.net/111996
22:40:20 <CrazyM4n> Couldn´t I just do that second import alone?
22:40:47 <mm_freak_> Axman6: i can't define 'join' there, because agda disagrees with the lengths
22:41:01 <mm_freak_> CrazyM4n: yes, you could, if those are all you need
22:41:09 <CrazyM4n> Sounds good
22:41:23 <carter> how do you define Join on size lists?
22:41:33 <mm_freak_> carter: diagonalisation
22:41:49 <mm_freak_> join ["abc", "def", "ghi"] = "aei"
22:42:19 <Axman6> mm_freak_: what on earth is {!!}?
22:43:09 <Axman6> let along the sharp and flat symbols
22:43:18 <Axman6> alone*
22:43:43 <CrazyM4n> mm_freak_: http://lpaste.net/146050770922373120 line 69
22:43:48 <CrazyM4n> Why do I have to put the R. there?
22:44:20 <Axman6> CrazyM4n: so you can refer to all other Repa functions a R.foo
22:44:22 <Axman6> as*
22:47:11 <mm_freak_> Axman6: the {!!} is a hole
22:47:27 <Axman6> why not put xss in there?
22:47:31 <mm_freak_> Axman6: and the sharp and flat symbols are coinduction guards and unguards
22:47:37 <mm_freak_> Axman6: because that's a type error
22:47:39 <Axman6> ... sure
22:47:50 <mm_freak_> it works for Vec, but not for Covec
22:47:58 <mm_freak_> i can't convince agda that xss is valid there
22:48:19 <mm_freak_> now i'm doing the proof separately for Vec and Stream
22:48:36 <Axman6> can you give it an explicit type signature or something? (xss :: Vec n (Vec (n+1) A))
22:49:27 <yashi> Is there a C to Haskell translator?
22:49:39 <CrazyM4n> There´s BF to haskell
22:49:40 <wz1000> If I have no implicit prelude, and I define (>>=) and (>>) myself, will a do block desugar to use my definations of (>>=) and (>>)? Also, will I have to abide by their type signatures?
22:49:54 <yashi> BF?
22:49:56 <CrazyM4n> And haskell to BF
22:49:59 <Axman6> wz1000: there's an extension that allows that
22:50:05 <Axman6> yashi: brainfuck
22:51:35 * hackagebot yesod-test 1.4.0.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.0.3 (MichaelSnoyman)
22:51:37 * hackagebot jobqueue 0.1.3 - A job queue library  http://hackage.haskell.org/package/jobqueue-0.1.3 (ikehara)
22:52:18 <CrazyM4n> Lint really doesn´t like my style :P
22:52:48 <orb__> CrazyM4n, Neil has peculiar tastes. ;o)
22:53:13 <jle`> wz1000: {-# LANGUAGE RebindableSyntax #-} or something like that
22:56:36 * hackagebot yesod-core 1.4.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.1.1 (MichaelSnoyman)
23:00:55 <CrazyM4n> Maybe I´m being dumb, but how can I do a function n number of times?
23:01:35 <CrazyM4n> > foldl 0 ($) (replicate 20 (2+))
23:01:35 <Axman6> > iterate (*3) 1 !! 7
23:01:36 * hackagebot curlhs 0.1.3 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.3 (KrzysztofKardzis)
23:01:37 <lambdabot>  can't find file: L.hs
23:01:37 <lambdabot>  2187
23:01:58 <CrazyM4n> Oh, both ways work, am I not correct?
23:02:13 <CrazyM4n> > foldl 0 ($) (replicate 20 (2+))
23:02:15 <lambdabot>  Could not deduce (GHC.Num.Num
23:02:15 <lambdabot>                      (((a -> b) -> a -> b) -> (a0 -> a0) -> (a -> b) -> a -> b))
23:02:15 <lambdabot>    arising from the ambiguity check for ‘e_10202’
23:02:15 <lambdabot>  from the context (GHC.Num.Num
23:02:15 <lambdabot>                      (((a -> b) -> a -> b) -> (a1 -> a1) -> (a -> b) -> a -> b),
23:02:28 <CrazyM4n> Never mind, yours is better
23:02:34 <Axman6> foldl (.) id (replicate n f) $ x would be more canonical
23:03:04 <Axman6> :t \f n x -> foldl (.) id (replicate n f) $ x
23:03:05 <lambdabot> (s -> s) -> Int -> s -> s
23:03:45 <CrazyM4n> I like the iterate way more, thank you :P
23:05:05 <Axman6> yeah,. I think it's a bit clearer
23:05:20 <Axman6> and if you use it right, you can get sharing between different runs
23:07:12 <Axman6> > let times f x = let xs = iterate f in \n -> xs !! n in let pow3 = times (*3) 1 in (pow3 7, pow3 4)
23:07:15 <lambdabot>  Couldn't match expected type ‘[a1]’ with actual type ‘a -> [a]’
23:07:15 <lambdabot>  Relevant bindings include
23:07:15 <lambdabot>    xs :: a -> [a] (bound at <interactive>:1:21)
23:07:15 <lambdabot>    f :: a -> a (bound at <interactive>:1:11)
23:07:15 <lambdabot>    times :: (a -> a) -> t2 -> GHC.Types.Int -> a1
23:07:25 <Axman6> > let times f x = let xs = iterate f x in \n -> xs !! n in let pow3 = times (*3) 1 in (pow3 7, pow3 4)
23:07:27 <lambdabot>  (2187,81)
23:08:22 <Axman6> (pow3 4 reused the result computed during pow3 7)
23:08:41 <Axman6> but memory won't be freed unwil pow3 goes out of scope
23:14:35 <ungov> Hi, I just built a library in a sandbox. Now I want to make te library available as a dependecy to build another library. How can I go about it?
23:15:35 <ungov> I see this command should work: cabal sandbox add-source /my/patched/library
23:16:21 <ungov> But after I do that, cabal still tries to build the library...
23:16:36 * hackagebot wai-app-file-cgi 3.0.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.2 (KazuYamamoto)
23:16:52 <CrazyM4n> Sorry for the screenshot, but I have no idea what to do http://prntscr.com/4sl916
23:17:47 <Axman6> do you have llvm installed?
23:18:16 <CrazyM4n> I´m on windows, I can´t just apt-get install llvm
23:18:40 <CrazyM4n> Let me try to find binaries
23:19:05 <CrazyM4n> found one
23:19:36 <Axman6> hmm, I see clang binaries, that should give you llvm too
23:19:58 <CrazyM4n> LLVM is currently installing
23:20:39 <CrazyM4n> ok, it still can´t find LLVM
23:20:45 <CrazyM4n> how do I point it to where LLVM is installed?
23:21:37 * hackagebot curlhs 0.1.2 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.2 (KrzysztofKardzis)
23:24:39 <CrazyM4n> https://ghc.haskell.org/trac/ghc/ticket/7143 So much for ever wanting gloss-raster
23:26:16 <CrazyM4n> doesn´t look like it comes with the nessecary binaries on windows
23:26:22 <CrazyM4n> Hm
23:36:38 * hackagebot Win32-services-wrapper 0.1.2.0 - Wrapper code for making a Win32 service  http://hackage.haskell.org/package/Win32-services-wrapper-0.1.2.0 (GaneshSittampalam)
