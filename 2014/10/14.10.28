00:07:37 * hackagebot simpleirc-lens 0.1.0.0 - Lenses for simpleirc types  http://hackage.haskell.org/package/simpleirc-lens-0.1.0.0 (RickyElrod)
00:08:52 <jle`> Axman6: have fun in melbourne
00:14:08 <mrenaud_> Hello everyone
00:15:11 <mrenaud_> I'm having some issues using state transformers, namely MaybeT (State [Int])
00:15:58 <mrenaud_> If I have the type: type ErrorWithState a = MaybeT (State [Int]) a
00:18:06 <mrenaud_> And a function foo :: Int -> ErrorWithState Int where foo x = return x and bar x = return (x+1)
00:18:26 <mrenaud_> I can chain them together with foo 4 >>= bar and then run the MaybeT
00:19:25 <mrenaud_> I cannot figure out how to get foo to return Nothing
00:20:52 <jle`> @unmtl MaybeT (State [Int]) a
00:20:52 <lambdabot> (State [Int]) (Maybe a)
00:21:22 <jle`> :t MaybeT
00:21:23 <lambdabot> Not in scope: data constructor ‘MaybeT’
00:21:58 <jle`> MaybeT should have a MonadPlus instance
00:22:31 <mrenaud_> It does
00:22:37 <varuser> 11:11 < tdammers_> Monad is a typeclass. Monads are types that implement this typeclass.
00:22:44 <jle`> but to literally do what you want... remember that MaybeT (State [Int]) a is just a newtype wrawpper over State [Int] (Maybe a)
00:22:54 <jle`> so how would you have a State [Int] (Maybe a) that is Nothing?
00:23:08 <jle`> return :: a -> State [Int] a
00:23:34 <jle`> MaybeT :: StateT [Int] (Maybe a) -> MaybeT (State [Int]) a
00:23:47 <jle`> so get your State thing that basically returns "Nothing", and then wrap it into the type with MaybeT
00:23:52 <jle`> or just use the MonadPlus/Alternative instnace
00:24:24 <mrenaud_> I'm not sure how you would use the MonadPlus instance
00:25:12 <mrenaud_> As you said return :: a -> State [Int] a, but the value I want to put in the value of thtype ErrorWithState a = MaybeT (State [Int]) a
00:25:21 <mrenaud_> oops
00:25:33 <mrenaud_> The value I want to put in the value of the state monad is Nothing
00:25:46 <jle`> yeah...so what does `return` do?
00:26:09 <jle`> MaybeT is just a newtype wrapper over State [Int] (Maybe a).  it's nothing special or magical
00:26:21 <jle`> so you basically want a State [Int] that "returns" Nothing
00:26:36 <mrenaud_> return x = \s -> (x, s)
00:26:57 <joelteon> return = (,)
00:28:09 <mrenaud_> That is a much more terse way of writing it but yes :P
00:30:22 <mrenaud_> Ahh, so mzero for MaybeT (State [Int]) Int is just \s -> (Nothing, s)
00:30:38 <jle`> mhm.
00:30:45 <jle`> with a decent amount of newtype wrappers
00:31:17 <mrenaud_> Yup, that makes sense
00:32:54 <mrenaud_> Thanks :) I was not aware that MaybeT is just State [Int] (Maybe a)
00:33:18 <jle`> if you ever had the time, try implementing the Monad instance for something like MaybeIO
00:33:28 <jle`> newtype MaybeIO a = MaybeIO IO (Maybe a)
00:33:33 <jle`> newtype MaybeIO a = MaybeIO (IO (Maybe a))
00:33:48 <jle`> and see that it's nothing really too magical other than the only meaningful Monad instance over that
00:34:21 <mrenaud_> I'll have to try that sometime, maybe after I'm a bit more comfortable with Monads
00:34:53 <jle`> well...it'll really help you understand what MaybeT even is.
00:35:08 <jle`> :)
00:35:14 <jle`> so you can actually use it.
00:35:36 <zdavid408> anyone here good with VBA?
00:35:38 <mrenaud_> Okay, I'll try that now
00:37:27 <mrenaud_> Which newtype of the ones you wrote is it? The second on?
00:37:39 <jle`> the second one is the one that is proper syntax, heh.
00:44:18 <mrenaud_> So, let's see if I have the types right. return :: a -> IO (Maybe a)   and    (>>=) :: IO (Maybe a) -> (Maybe a -> IO (Maybe b)) -> IO (Maybe b)
00:45:29 <mauke> that doesn't look right
00:45:56 <mauke> if your M = IO . Maybe, then the second argument to >>= should take a, not Maybe a
00:47:02 <mrenaud_> Okay
00:47:49 <mrenaud_> Wait, are you sure?
00:47:52 <mrenaud_> :t (>>=)
00:47:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:48:25 <mrenaud_> If my m is IO then a would be Maybe a, or is that not how it works?
00:50:17 <mrenaud_> It is very possible that I have a fundamental misunderstanding :P
00:58:22 <jle`> mrenaud_: your (>>=) should be, unwrapped, (>>=) :: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b)
00:58:43 <jle`> mrenaud_: in your case, your m is (Maybe . IO)
00:58:46 <jle`> mrenaud_: not IO
00:58:53 <jle`> er sorry, IO . Maybe
00:59:01 <jle`> look at your first argument, IO (Maybe a)
00:59:02 <mrenaud_> Oh, definitely did not know that :P
00:59:06 <jle`> right?
00:59:15 <mrenaud_> Yes, correct
00:59:17 <jle`> what does `m` have to be for IO (Maybe a) to be `m a`?
00:59:23 <jle`> not IO
00:59:30 <jle`> not Maybe :)
01:00:01 <mrenaud_> No, no Maybe, but couldn't Maybe x be a?
01:00:11 <mrenaud_> Or can the a type not be a monadic type?
01:00:21 <mauke> then you'd have Maybe a -> IO (Maybe a) for return
01:00:41 <jle`> return :: a -> IO (Maybe a) implies that your "value" is `a`
01:00:54 <mrenaud_> Ahh, that makes much more sense now :P
01:00:58 <jle`> :t return
01:00:59 <lambdabot> Monad m => a -> m a
01:01:33 <jle`> but...it's easier to just slap on a newtype wrapper and let the compiler correct you :)
01:01:38 <solatis> hmm
01:01:46 <solatis> ok, so, haskell has the continuation monad
01:02:10 <solatis> which is supposed to fix callback hell in haskell (withFoo $ \foo -> withBar $ \bar -> do ...)
01:02:17 <mrenaud_> Is there an IO data constructor?
01:02:30 <solatis> but the continuation monad accepts only one data structure it is supposed to pass along
01:02:38 <jle`> mrenaud_: not exposed
01:02:42 <mauke> mrenaud_: no
01:02:43 * hackagebot libhbb 0.4.0.2 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.4.0.2 (wolfch)
01:02:49 <jle`> and not meaningfully, either, really
01:02:50 <solatis> what i would like to have is something like runCont (withFoo >>= withBar) $ \foo bar -> do ...
01:02:58 <solatis> is something like that possible in haskell?
01:03:13 <mrenaud_> Hmm, for return I want to do something like return a = (somefunction . Just) a
01:03:23 <solatis> or in other words: what novel things have people come up with to fix callback hell in haskell?
01:03:23 <jle`> mrenaud_: what is the type of somefunction ...?
01:03:36 <jle`> think :)
01:03:36 <mrenaud_> Maybe a -> IO (Maybe a)
01:03:43 <jle`> okay
01:03:49 <jle`> i think... a function like that already exists
01:03:59 <jle`> and you might have used it in the past
01:03:59 <mrenaud_> To the hoogles
01:04:07 <jle`> b -> IO b
01:04:10 <jle`> hm.
01:04:39 <mrenaud_> Looks a lot like return ;P
01:04:56 <jle`> nice hunch :)
01:05:31 <jle`> :t return `asAppliedTo` Nothing
01:05:32 <lambdabot> Monad m => Maybe a -> m (Maybe a)
01:06:27 <mrenaud_> What is this asAppliedTo?
01:06:43 <mrenaud_> My first try when I first started was (return . Just), but that doesn't work :/
01:06:44 <jle`> oh it is just for lambdabot fun.  it shows that the type of the function would be if it was applied to that thing
01:07:11 <jle`> mrenaud_: do you have a newtype wrapper?  your result has to be MaybeIO a, so you have to wrap it up
01:07:32 <jle`> your compiler should give an error here that you can learn from :)
01:07:40 <jle`> what does "doesn't work" even mean, anyway
01:07:43 * hackagebot hbb 0.4.0.2 - Haskell Busy Bee, a backend for text editors.  http://hackage.haskell.org/package/hbb-0.4.0.2 (wolfch)
01:07:48 <jle`> does your computer explode or something >_>
01:08:39 <mrenaud_> Haha, that was a poor description :P Expected type MaybeIO a, actual type MaybeIO (Maybe a)
01:09:44 <jle`> that must mean that you're wrapping up an IO (Maybe (Maybe a)) somehow...
01:11:22 <mrenaud_> return a = MaybeIO $ (return . Just) a    appears to have worked
01:11:32 <mrenaud_> I didn't have the MaybeIO out front before
01:11:54 <jle`> interesting usage of $ and .
01:12:09 <jle`> why not just (MaybeIO . return . Just) a ...?
01:12:20 <jle`> i guess it's nice to conceptually separate them out
01:12:30 <pharaun> i'm bad about mixing up $ and .
01:12:53 <jle`> some people do it i guess to put in mental splits
01:13:19 <jle`> not really for me personally though
01:13:43 <mrenaud_> Yeah, I like MaybeIO . return . Just better :P Not sure why I did it that way
01:15:47 <mrenaud_> Now on to >>=
01:20:32 <jle`> yaay
01:20:56 <jle`> do notation is really helpful here
01:21:25 <jle`> but first, think about what (>>=) would even conceptually do
01:26:48 <mrenaud_> It would first extract the Maybe a from the IO monad, then if it is Just v, then apply f to v and re-wrap. If it is Nothing, then return Nothing
01:29:31 <dibblego> sounds like MaybeT to me
01:29:39 <mrenaud_> My initial thought was v >>= f = do { m <- v; case m of (Just x) -> f x; Nothing -> MaybeIO (return Nothing) }
01:29:45 <jle`> dibblego: we are re-implementing MaybeT :D
01:29:49 <dibblego> ok
01:30:08 <jle`> mrenaud_: so..what's the error? :)
01:31:39 <jle`> conceptually, that's right, but you need to deal with the ugliness of newtype wrappers, heh.
01:31:41 <mrenaud_> Couldn't match expected type ‘a’ with actual type ‘Maybe a’
01:32:05 <mrenaud_> To be honest, I'm not exactly sure what newtype does, so that may be part of the problem :P
01:32:10 <jle`> oh
01:32:13 <jle`> do you know what `data` does?
01:32:38 <mrenaud_> Yes
01:32:49 <mrenaud_> As well as `type`
01:33:00 <jle`> so in this case it's the same as data MaybeIO a = MaybeIO (IO (Maybe a))
01:33:15 <jle`> sorta.  there are some differences
01:33:18 <mrenaud_> So MaybeIO becomes the data constructor
01:33:21 <jle`> yeah
01:33:25 <mrenaud_> Is newtype transparent?
01:33:33 <jle`> yes, at compile time
01:33:38 <jle`> but you have to deal with it in your code
01:33:46 <mrenaud_> Okay, gotcha
01:33:49 <jle`> what does (v >>= f) have to return?
01:34:10 <mrenaud_> MaybeIO b
01:34:16 <jle`> btw, it might be easier if you did newtype MaybeIO a = MaybeIO { runMaybeIO :: IO (Maybe a) }, for easy access
01:34:47 <mrenaud_> Could I also just do    (MaybeIO v) >>= f = ...?
01:34:48 <jle`> mrenaud_: okay.  so, it looks like you need to make an IO (Maybe b), and then wrap it all in MaybeIO constructor
01:34:58 <jle`> yeah, you can do that too.  but runMaybeIO comes handy later too.
01:35:10 <jle`> (MaybeIO v) >>= f = MaybeIO (... some IO (Maybe b) ...)
01:37:00 <mrenaud_> Doesn't f return MaybeIO b though?
01:37:16 <mrenaud_> So I would only need to wrap the case where the Maybe a value is Nothing
01:38:30 <jle`> mrenaud_: but you can only know if the Maybe a value is Nothing or Just inside IO
01:38:57 <jle`> your first line,  { m <- v }, already puts you inside IO
01:39:02 <jle`> so you're in IO no matter what
01:39:07 <mrenaud_> Ahh, gotcha
01:39:21 <jle`> you can only "know" if you get Just/Nothing by executing/binding it in IO
01:40:03 <mrenaud_> Okay, so after m <- v, m should be either Just x or Nothing? Or am I missing something.
01:40:10 <jle`> yes
01:40:52 <jle`> so you get something like v >>= f = MaybeIO $ do ....  , where the do block has to be IO (Maybe b), so it returns a (Maybe b) in the end
01:41:14 <jle`> so the Nothing branch should be simple enough...you want IO (Maybe b), so you can just
01:41:17 <jle`> ...
01:41:37 <mrenaud_> mzero
01:42:11 <jle`> i was thinking "return Nothing"
01:42:12 <jle`> but...yeah
01:43:00 <Adeon> anyone happen to have an intuition on when to use INLINEABLE?
01:43:15 <Adeon> https://stackoverflow.com/questions/9709823/is-there-any-reason-not-to-use-the-inlinable-pragma-for-a-function there is this SO question that answers how it works so no confusion there
01:43:31 <Adeon> but I can't think of when it might be a good idea to use it as opposed to the other pragmas
01:43:46 <lpaste> mrenaud pasted “MaybeIO Monad Instanc” at http://lpaste.net/113310
01:43:59 <mrenaud_> It works, I have a feeling it could be cleaner though :P
01:44:59 <lpaste> mrenaud revised “MaybeIO Monad Instanc”: “MaybeIO Monad Instance” at http://lpaste.net/113310
01:45:42 <mrenaud_> Okay, well it just disappeared when I edited it :P
01:46:17 <lpaste> mrenaud pasted “MaybeIO Monad Instance” at http://lpaste.net/113312
01:52:22 <aleator__> If I said that all contravariant functors are like functions in sense that they 'consume' values, would I be lying very much?
01:52:44 <edwardk> Axman6: slightly more dynamic scene added, better retina support
01:53:11 <gamegoblin> @hoogle [Maybe a] -> [a]
01:53:13 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
01:53:13 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:53:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:01:44 <mrenaud_> jle`: Thanks for all the help! I'm heading out for the night
02:06:41 <gamegoblin> What’s the extension that gets you guard-like if-statements?
02:06:54 <gamegoblin> can’t remember it and google-fu is failing me
02:07:28 <shiona_> umm, do you mean unless and when?
02:07:35 <jle`> gamegoblin: multi-way if?
02:07:40 <gamegoblin> jle`: that’s the way
02:07:41 <gamegoblin> the one*
02:07:52 <shiona_> ah, that guard
02:08:26 <gamegoblin> If you google for multi way if you find almost nothing useful
02:08:50 <gamegoblin> "multi way if haskell" yields nothing about the actual extension
02:08:52 <gamegoblin> somewhat annoying
02:09:12 <tdammers> if haskell then multi way
02:09:20 <bernalex> people don't really use it
02:09:41 <bernalex> I'm going to go as far as saying that including if-then-else was basically a mistake. :-]
02:09:49 <gamegoblin> bernalex: wat
02:10:09 <capisce> http://www.haskell.org/haskellwiki/MultiCase ?
02:10:15 <jle`> it encourages booleans
02:10:31 <gamegoblin> what is wrong with booleans
02:10:35 <jle`> everything
02:10:46 <bernalex> gamegoblin: they convey very little information.
02:10:58 <bernalex> furthermore, if-then-else is completely 100% redundant in haskell.
02:11:08 <gamegoblin> Can you provide an example of when they are used that there is a better option?
02:12:15 <capisce> gamegoblin: http://dev.stephendiehl.com/hask/#boolean-blindness
02:15:39 <gamegoblin> capisce: that seems to cover an extremely small use case of booleans
02:17:15 <capisce> gamegoblin: there's a link at the bottom to this article too: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
02:17:43 <capisce> and booleans are a problem in other languages too: http://ariya.ofilabs.com/2011/08/hall-of-api-shame-boolean-trap.html
02:21:03 <gamegoblin> capisce: Just because you can use booleans poorly is hardly an argument against their existence
02:22:14 <capisce> gamegoblin: true
02:22:42 <gamegoblin> There are some things that just need one bit of information. Say you want to make a function that determines if something is legal or illegal. Sure, you can say Data Legality = Legal | Illegal … but that looks an awful lot like a boolean to me
02:23:26 <gamegoblin> so rather than having isLegal you’d have judgeLegality or something
02:23:44 <gamegoblin> which, from a type theory point of view, is probably somewhat superior
02:24:09 <gamegoblin> but from a practical perspective, I have never found myself having issues using the former
02:26:05 <Cale> gamegoblin: Well, the problem isn't generally possible to fix in Haskell.
02:26:10 <lieven_> gamegoblin: foo :: Legality -> Ethical -> Action is safer and better documented than foo' :: Bool -> Bool -> IO ()
02:26:20 <Cale> gamegoblin: That datatype has exactly the same problem that Bool does
02:26:45 <Cale> The real problem is that in Haskell, it's *always* type correct to swap the branches of an if expression.
02:27:06 <Cale> because the result type of a case expression can't depend in any way on the value it matches against
02:27:20 <Cale> In a dependently typed language, you can avoid boolean blindness
02:28:49 <Cale> GADTs and other extensions have started to make things more interesting for Haskell though, moving it closer to dependently typed languages in terms of what one can express.
02:29:17 <gamegoblin> Would it be possible to represnent something like this without booleans or ifs
02:29:28 <gamegoblin> if age > 70 then "OLD!" else "youngin"
02:30:08 <gamegoblin> that seems like a fairly legitamate use of booleans
02:31:01 <raphaelgruber> hi guys, somebody here that can help me real quick?
02:31:10 <gamegoblin> raphaelgruber: probably
02:31:20 <tdammers> data Oldness = Old | Young
02:31:33 <tdammers> isOld :: Age -> Oldness
02:31:43 <Cale> tdammers: That is exactly the same as boolean blindness
02:31:44 <gamegoblin> tdammers: show me the body if isOld
02:31:50 <raphaelgruber> got this function checksum crossSum i 12         | i == 0 = '' 13         | i `mod` 2 == 0 = '0' ++ checksum ( i `div` 2) 14         | i `mod` 2 == 1 = '1' ++ checksum ( i `div` 2) 15         where   crossSum 0 = 0 16                 crossSum x = (x `mod` 10) + crossSum (x `div` 10)
02:31:51 <tdammers> isOld age = if age > 70 then Old else Young
02:31:55 <raphaelgruber> got this function
02:32:01 <gamegoblin> tdammers: you just used an if statement, thus booleans
02:32:20 <Cale> To not be boolean blind would be to make Oldness be a datatype consisting of a proof that the age of something is over 70, say.
02:32:21 <gamegoblin> tdammers: you just changed my strings to enums, not my booleans
02:32:21 <tdammers> I used condition
02:32:25 <raphaelgruber> i wanna call crossSum once at the beginning of the function
02:32:36 <tdammers> but ok, fine
02:32:38 <raphaelgruber> how can i do that?
02:32:46 <tdammers> isOld 70 = Old
02:32:49 <tdammers> isOld 0 = Young
02:32:54 <tdammers> isOld age = isOld (age - 1)
02:33:08 <tdammers> no booleans
02:33:10 <gamegoblin> isOld (-1)
02:33:22 <tdammers> I never said it was total
02:33:32 <tdammers> also, I didn't give an implementation of the Age type
02:33:33 <gamegoblin> The previous one was
02:33:56 <Cale> tdammers: The problem is that Oldness is effectively the same thing as a Boolean
02:33:59 <tdammers> it is total for an Age type that only allows nonnegative ages
02:34:02 <tdammers> Cale: sure
02:34:04 <sgronblo> Are we just trying to say that booleans are magic numbers?
02:34:21 <raphaelgruber> FFF
02:34:32 <Cale> tdammers: You still have boolean blindness: having a value "Old" doesn't actually tell you that anything in particular is old. :)
02:34:34 <gamegoblin> raphaelgruber: please pastebin your code or something
02:34:45 <gamegoblin> Cale gets it
02:34:49 <tdammers> hehe
02:35:00 <gamegoblin> the problem is sometimes users of software want to know fairly boolean things
02:35:04 <tdammers> so
02:35:05 <Cale> Like, if Haskell were dependently typed, you might be able to have  data Oldness x = Young (age x <= 70) | Old (age x > 70), where <= and > were suitable type constructors of proofs of inequalities.
02:35:20 <tdammers> data Person = OldPerson { ... } | YoungPerson { ... } -- pfff
02:35:44 <raphaelgruber> http://pastebin.com/BBNJ5yzp
02:35:45 <gamegoblin> tdammers: you still have to have a mapping from age to person
02:35:48 <Cale> and in order to construct a value of type Oldness x, you'd have to prove that x was actually old :)
02:35:53 <jle`> gamegoblin: one example is something like using null & head/tail instead of pattern matching
02:35:59 <Cale> (or not)
02:36:12 <jle`> safeHead xs = if null xs then Just (head xs) else Nothing
02:36:19 <jle`> you do the "work" twice
02:36:33 <jle`> you check if it's null, and then, you take the head
02:36:46 <Cale> Yeah, in the simplest examples, we can avoid boolean blindness in Haskell like jle` is suggesting
02:36:54 <gamegoblin> I totally get that
02:36:58 <Cale> But in anything beyond those, it gets hard
02:37:09 <gamegoblin> I am mainly just arguing against the guy who said that booleans and if statements shouldn’t be there at all
02:37:17 <Cale> yeah, I disagree with that
02:37:29 <Cale> Bool is still useful, there are still cases where we really need it
02:37:43 <gamegoblin> raphaelgruber: you are mixing chars and strings and whatnot
02:37:43 <Cale> and replacing it with isomorphic types doesn't really solve anything
02:37:57 <tdammers> my gripe with `if` is not that it uses booleans, but that it's a special language construct
02:37:59 <jle`> it's just that people use Bool in situations where it's not optimal
02:38:09 <jle`> how about something that is like `isLeft`, `isRight`
02:38:11 <tdammers> it could just be a built-in function or something
02:38:12 <raphaelgruber> gamegoblin: yea, im relatively new to this
02:38:18 <tdammers> like `when`
02:38:20 <jle`> should we have isLeft :: Either a b -> Bool?
02:38:25 <Cale> raphaelgruber: Single quotes are for characters, double quotes are for strings
02:38:27 <jle`> or getLeft :: Either a b -> Maybe a ?
02:38:32 <jle`> getRight :: EIther a b -> Maybe b
02:38:37 <gamegoblin> raphaelgruber: also your function has an argument called "crossSum" but then you are defining crossSum in the where-block
02:38:42 <jle`> getLeft/getRight are more useful than isLeft
02:38:52 <Cale> i `mod` 2 == 0 can also be written as even i
02:39:01 <tdammers> jle`: isLeft is useful if all you want to know is whether something failed
02:39:03 <jle`> a lot of times you might ask "isLeft", and then get the value.  but that's duplicating the work
02:39:08 <Cale> (similarly, i `mod` 2 == 1 can be written as  odd i)
02:39:14 <tdammers> if you need the value anyway, why not just pattern match
02:39:19 <gamegoblin> raphaelgruber: I think you want to remove "crossSum" as an argument, and use " instead of '
02:39:34 <raphaelgruber> gamegoblin: yea i added that at the end cus i thought maybe that would call crossSum on i at the begging of the function, apparently not
02:39:36 <jle`> tdammers: yeah, just showing an example of alternatives to isLeft, avoiding a Bool
02:39:41 <gamegoblin> raphaelgruber: you don’t need to pass in the things in your where-block. The things in your function know about it.
02:39:55 <Cale> Yeah, you're binding crossSum as an argument and then instead of using it, locally shadowing it with the definition in the where clause
02:40:24 <gamegoblin> Cale: I think he doesn’t know that the where-block stuff is known to the stuff in the function body and he has to pass it in explictly
02:40:26 <Cale> and you never actually use crossSum anywhere
02:40:38 <Cale> (apart from in its own definition)
02:41:18 <jle`> i like to think of boolean blindness as usage of bools that can be written incorrectly and still typecheck
02:41:31 <jle`> you can accidentally "swap" the branches of if null xs then ... else ...
02:41:32 <gamegoblin> seems reasonable
02:41:35 <jle`> and it'll still typecheck
02:42:07 <jle`> people often refer to things like (==) and (>)
02:42:18 <Cale> jle`: Well, that's always the case, it just depends on how wrong it makes your program, and whether you care about statically checking for that kind of wrongness :)
02:42:19 <jle`> you can completely "reverse" the definition of (>)
02:42:23 <raphaelgruber> :gamegoblin yea but how do i call crossSum only once
02:42:30 <jle`> and it'll still check out
02:42:36 <gamegoblin> raphaelgruber: that depends, what do you want to call it on? What is its argument?
02:42:39 <jle`> but if you used somehting better than a Bool, then...it won't
02:42:42 <Cale> For things like deciding which string to display to the user, it might be questionable to try to enforce things about that statically.
02:42:57 <jle`> go hard or go home
02:43:21 <jle`> i talk about "Int" blindness all the time
02:43:26 <jle`> or Num blindness
02:43:32 <raphaelgruber> gamegoblin: i wanna calculate the crossSum from the argument, so 101 -> 2 and then create a string that represents that number in binary
02:43:40 <jle`> but i'm not sure if that's an abuse of the term or not.
02:43:43 <jle`> oh, i have been meaning to ask.
02:43:54 <jle`> in Free f a, what is "the free object"?
02:43:57 <gamegoblin> raphaelgruber: if you just want to calculate it once, you can put that calculation in your where-block, or in a let-statement
02:43:58 <jle`> is it Free?
02:44:02 <jle`> or is it (Free f) ?
02:44:37 <jle`> i guess because in [a], the free object (free monoid) is []...i think?
02:44:47 <jle`> so it makes sense that Free is the free object (free monad)...?
02:45:38 <gamegoblin> With stuff like Free monad, I like to the f is the free monad, and Free is just the way of declaring it as such
02:46:04 <jle`> but wait...does that mean that `a` is the free monoid in [a]?
02:46:15 <gamegoblin> jle`: guess so
02:46:33 <gamegoblin> makes… a bit… of sense to me
02:47:05 <gamegoblin> maybe...
02:47:55 <gamegoblin> When you’re referring to the noun, I think about data. So for Free f, I think about f as being the free, and Free as being the behavior that makes it a monad
02:50:02 <raphaelgruber> gamegoblin:            ( aufgabe1.hs, interpreted )
02:50:11 <raphaelgruber> gamegoblin: http://pastebin.com/eUGsFR4k
02:50:24 <jle`> sorry, i'm not completely convinced :|
02:50:46 <raphaelgruber> gamegoblin: my problem now is that i always pass the same number to the recursion
02:50:49 <supki> jle`: Free F is the free monad on F, [A] is the free monoid on A
02:50:59 <gamegoblin> jle`: neither am I
02:51:03 <jle`> supki: i see
02:51:07 <jle`> okay, that makes sense
02:51:18 <jle`> but then what is Free and [] here?
02:51:24 <jle`> does it have a name?
02:51:34 <gamegoblin> raphaelgruber: I don’t understand what you are trying to do, so it’s hard to help
02:51:48 <gamegoblin> raphaelgruber: what do you want to do with crossSum
02:52:45 <pingu> jle`: my abstract algebra is really bad but maybe it being a 'free algebra' doesn't sound terribly wrong to me
02:53:02 <pingu> perhaps googling along that line will elucidate something if you're better at maths than me ;)
02:53:21 <jle`> hm
02:53:25 <jle`> thans
02:53:49 <jle`> i think (Free f) being the free monad on f makes sense...because (Free f) is a monad.  and [a] is a monoid, the free monoid on a.
02:54:16 <jle`> i just wanted some sort of language to be able to talk about it without being incorrect
02:56:33 <jle`> `ReaderT r m` is the free `MonadReader r` on `m`.
02:56:54 <jle`> it takes a monad and imbues it with the minimal structure required to satisfy MonadReader laws
02:59:39 <jle`> if you have an `a` and want to make it a monoid without saying anything extra about it, you can use [a], and `mappend` and mempty satisfiy the monoid laws by construction
02:59:57 <raphaelgruber> gamegoblin: got it .. http://pastebin.com/HPRraL5u, sorry for the confusion
03:00:09 <jle`> if you have a monad `m` and you want to make it a `MonadReader r`, you can use `ReaderT r m`, and use ask/etc. and they will satisfy the laws by construction
03:00:14 <raphaelgruber> gamegoblin: i want to calculate the crosssum of a number and return the binary representation in a string
03:00:15 <jle`> the MonadReader laws
03:00:21 <gamegoblin> raphaelgruber: nice job
03:00:23 <jle`> who nows what those are though.
03:00:26 <jle`> *knows
03:00:57 <jle`> someone tell me i am wrong pls
03:01:47 <raphaelgruber> gamegoblin: thanks for the help!! any tips about how i could write it more elegantly?
03:02:39 <raphaelgruber>  
03:02:56 <raphaelgruber>  
03:04:34 <gamegoblin> raphaelgruber: there is a builtin function for determining even/odd. Also you can pattern-match on the 0 so that binRep 0 = ""
03:05:13 <gamegoblin> raphaelgruber: and if you really want, you can change it to "checksum = binRep . crossSum"
03:05:39 <raphaelgruber> gamegoblin: are pattern matches preferable?
03:05:46 <gamegoblin> raphaelgruber: almost always
03:06:03 <gamegoblin> raphaelgruber: that was actually quite the topic of conversation for the last 30 minutes in this channel ;)
03:06:45 <gamegoblin> raphaelgruber: but sometimes for numeric code, it’s not super possible. Like, you can’t pattern match on "things less than 1234"
03:06:59 <gamegoblin> But if you find yourself doing an == on a numeric argument… might consider pattern matching!
03:07:56 * hackagebot th-orphans 0.8.2 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.8.2 (MichaelSloan)
03:08:58 <raphaelgruber> gamegoblin: good to know :)
03:11:14 <solatis> hmmm
03:11:22 <solatis> i am not able to find this out in this docs
03:11:41 <solatis> in Control.Concurrent, there is a forkFinally function
03:12:08 <solatis> this allows you to provide a callback-style function for when the thread execution is finished
03:12:53 <solatis> however, it doesn't specify which thread this function is executed within -- is it executed within the spawned thread, or the master thread?
03:13:15 <solatis> (i need to know this because of thread safety guarantees)
03:14:32 <solatis> i suspect the callback function is called from within the spawned thread, and i guess i have to use a thread-safe queue to push the result value back to the master thread?
03:14:57 <solatis> or am i digging too deep into implementation specific details?
03:23:40 <edwardk> extra screenshot: https://raw.githubusercontent.com/ekmett/quine/master/data/chains.png
03:29:57 <Kinnison> edwardk: pretty :-)
03:32:59 * hackagebot extra 0.5 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.5 (NeilMitchell)
03:36:33 <solatis> nevermind, i figured out that Control.Concurrent.Chan is what i need
03:38:10 <edwardk> Kinnison: realtime for some value of "real" =)
03:38:21 <Kinnison> edwardk: :-)
03:38:35 <edwardk> Kinnison: need to make these faster, the art isn't mine
03:39:02 <Kinnison> What sort of frame rate are you at?
03:43:39 <trap_exit> the more that I code haskell, the more it feels like lemmas in a math proof -- has anyone develope da nice way of writing haskell on paper,
03:43:44 <trap_exit> and then just typing it up once everything works?
03:43:53 <trap_exit> i.e. iterally coding out on paper
03:44:00 <ThreeOfEight> trap_exit: I have some students in my tutorials who don't have a laptop with them
03:44:00 <trap_exit> then just copying it over once it's mostly written
03:44:05 <Darwin226> I have a function a -> b where a will be a value known after the program starts and b is diffictult to calculate. What would be the best way to cache b as soon as a is first known?
03:44:08 <ThreeOfEight> usually because they forgot it
03:44:18 <trap_exit> ThreeOfEight: not financial reasons?
03:44:22 <ThreeOfEight> some of them, despite being beginners, wrote perfectly correct Haskell code on paper without ever testing it
03:44:34 <ThreeOfEight> I should not think so
03:44:40 <ThreeOfEight> you /can/ borrow laptops from the university
03:45:09 <ThreeOfEight> and there is a special group in a room with thin clients they can use
03:45:11 <edwardk> Kinnison: depends on the resolution 7fps to 60fps, but i'm handicapped by being on a mac using Intel hardware at retina resolutions so ouch
03:45:16 <ThreeOfEight> for people who don't own a computer
03:45:26 <ThreeOfEight> and it's full of people using their own laptops
03:45:35 <edwardk> Kinnison: the mission now is to make it fast now that it works
03:45:38 <Kinnison> :-)
03:45:44 <ThreeOfEight> Our lecture has about 500-600 students; there seem to be about 2 or 3 who don't have a laptop.
03:45:50 * Kinnison still needs to learn how to spot when things he writes will be slow
03:45:51 <trap_exit> what's a good (paper) notebook for writing haskell code?
03:45:55 * Kinnison has a knack for writing super-slow code :-)
03:46:03 <trap_exit> I think erasing quite painful, and the moleskines to have too narrow lines
03:46:26 <trap_exit> Kinnison: look in the *.hs files
03:46:42 <Kinnison> heh
03:46:50 <ThreeOfEight> Kinnison: avoid multiple evaluation of the same expression, avoid unnecessary intermediate data structures, avoid unnecessary list traversal
03:47:13 <ThreeOfEight> when doing inherently stateful things, consider to use the ST monad
03:47:24 <Kinnison> all good advice, though why ST rather than State ?
03:47:34 <Darwin226> Is there a way to construct a map by supplying a function from key to value?
03:47:43 <ThreeOfEight> I honestly don't know anything about the State monad
03:47:45 <trap_exit> konw when to use !
03:47:46 <ThreeOfEight> I don't think I ever used it
03:47:48 <Darwin226> So that basically only use the map for memo
03:48:01 <ThreeOfEight> but it was my understanding that the State monad was just for convenience
03:48:07 <tdammers> State just wraps up explicit state passing in a monad, yes
03:48:18 <ThreeOfEight> whereas the ST monad offers things like STrefs, STArrays and so on
03:48:39 <ThreeOfEight> Of course, if you can avoid it, don't modify arrays
03:48:53 <tdammers> those come with a bit of overhead; unless you need concurrency / parallel access, there is no real advantage AFAIK
03:49:02 <trap_exit> dude
03:49:06 <trap_exit> no one has mentioned profiling
03:49:07 <ThreeOfEight> but some algorithms require modifying state (such as an array), and the ST monad can do that very efficiently.
03:49:15 <trap_exit> premature optimization is the root of everyone saying fuck it i'm going to rewrite this in C
03:49:21 <ThreeOfEight> I never quite got the hang of profiling
03:49:31 <ThreeOfEight> mostly how to set it up
03:49:50 <ThreeOfEight> it seems that whenever I want to profile something, I have to reinstal all my libraries with profiling enabled
03:49:56 <trap_exit> i've never used it, but I heard it's important
03:50:02 <ThreeOfEight> and look up all the configuration stuff
03:50:07 <ThreeOfEight> and then all of that will break other stuff later
03:50:16 <ThreeOfEight> Profiling is nice, but to me, it's rarely worth the effort
03:50:18 <Kneiva> Darwin226: is memoization a familiar term to you?
03:50:26 <trap_exit> alright; back to important things
03:50:39 <Darwin226> Kneiva: Yeah, but it's hard to think about when you can't mutate global state
03:51:06 <ThreeOfEight> Darwin226: there are memoisation combinators
03:51:29 <Darwin226> Kneiva: It feels like having a structure that you provide with a function and then just use it AS that function but it implicitly mutates it self in the background to save the result, would be pretty great
03:51:45 <Kneiva> Darwin226: there is something written here: http://www.haskell.org/haskellwiki/Memoization (I'm not very familiar on the subject, though.)
03:52:04 <ThreeOfEight> http://hackage.haskell.org/package/data-memocombinators-0.3/docs/Data-MemoCombinators.html
03:52:37 <Darwin226> ThreeOfEight: Do they come packed with haskell platform?
03:52:48 <ThreeOfEight> Darwin226: no.
03:52:52 <ThreeOfEight> cabal install data-memocombinators
03:53:02 <Darwin226> ThreeOfEight: Damn.. Can't do that
03:53:09 <ThreeOfEight> how not?
03:53:18 <raphaelgruber> exit
03:54:16 <Darwin226> ThreeOfEight: I need to upload my code somewhere where only the packages from HP are available
03:54:21 <trap_exit> damn
03:54:25 <trap_exit> why is filler paper so expensive
03:54:32 <trap_exit> 100 sheets of college ruled fille r paper = 3.50
03:54:44 <trap_exit> wtf ... it'd be cheaper to buy a notebook and rip the paper out
03:57:54 <ThreeOfEight> Darwin226: what kind of function would you like to memoise?
03:58:21 <Darwin226> (Int, Int) -> Map (Int, Int) Integer
03:58:50 <ThreeOfEight> that sounds quite memory-intensive
03:59:29 <Darwin226> ThreeOfEight: The first pair will be unique. Only one ever used when the program is ran
04:00:03 <Darwin226> ThreeOfEight: Basically, there should only ever be one Map there. I just don't know which one before hand
04:00:53 <Darwin226> ThreeOfEight: I mean, I can probably live with wrapping it in a closure of the function that will actually receive that pair. Generate it on the spot and store it in the where block
04:01:11 <Darwin226> ThreeOfEight: But that seems kind of clunky.
04:01:19 <ThreeOfEight> Darwin226: I don't think you can do something like that with memoisation combinators
04:01:44 <ThreeOfEight> those are more for recursive definitions that query the same values a lot
04:01:57 <ThreeOfEight> that kind of thing I think you can only do with an IOref or an STref
04:01:59 <Darwin226> ThreeOfEight: See, it's not that I can't think of a solution. It's just that it feels like there should be a more elegant solution. Because haskell and stuff
04:02:46 <Darwin226> ThreeOfEight: Like a structure that does implicit self mutation as you take values from it. A wrapper for a function that memoizes every time it's called
04:03:26 <ThreeOfEight> that sounds like you'd probably need unsafePerformIO for it
04:03:40 <Darwin226> ThreeOfEight: It doesn't seem like that would break purity from the users point of view since referential transparency is still there and you couldn't mess with it's internal structure
04:04:07 <Darwin226> ThreeOfEight: Yeah. I'll see if I can cook something up
04:04:29 <ThreeOfEight> Darwin226: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028187.html
04:05:14 <ThreeOfEight> also see this: http://t0yv0.blogspot.com/2009/01/haskell-memoization-with.html
04:06:31 <Darwin226> ThreeOfEight: Very interesting. Thanks
04:13:03 * hackagebot neil 0.6 - General tools for Neil  http://hackage.haskell.org/package/neil-0.6 (NeilMitchell)
04:17:13 <t7> what happened with darcs patch theory stuff ?
04:17:24 <t7> did any more work go into proving ?
04:24:56 <trap_exit> damn it
04:24:59 <trap_exit> no one has a good blog post
04:25:01 <trap_exit> on writing haskell on paper?
04:25:24 <trap_exit> I really think that paper and pencil coding is the future of haskell
04:26:54 <t7> :|
04:27:04 <t7> why do you hate trees?
04:27:17 <trap_exit> when I was young, I was biking
04:27:21 <trap_exit> and a tree got in my way
04:27:24 <trap_exit> and I had scraped knees
04:27:45 <trap_exit> but honestly, I think I think better on paper than staring at eamcs
04:28:17 <t7> most things are better than staring at emacs
04:28:46 <trap_exit> not when the data structures / algorithms aren't even sketched out yet
04:30:14 <trap_exit> on osx (I don't have a2ps) what's the best way to convert *.hs files to a *.ps or a *.pdf so I can print?
04:38:06 * hackagebot ghcid 0.3.1 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.1 (NeilMitchell)
04:43:06 * hackagebot extra 0.5.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.5.1 (NeilMitchell)
04:54:32 <xificurC> I'd like to try and write a simple interpreter/compiler in Haskell but I don't have the needed background. I have the dragon book for compilers and was wondering if it is a good idea to read that first and then try to use the skills learned in Haskell or if the approach should be different
04:57:08 <wei2912> xificurC: i wonder why it's called the dragon book
04:57:19 <wei2912> oh, the cover has a dragon on it
04:57:43 <xificurC> wei2912: yes sir
04:57:58 <narendraj9> The same holds true for the dino book on Operating Systems.
04:58:28 <wei2912> xificurC: well, no idea, but you may want to read the book and write the interpreter/compiler at the same time
04:59:12 <xificurC> wei2912: and is haskell a good target language? (for writing the i/c, not generating haskell code ofc)
05:01:20 <wei2912> xificurC: i just started with haskell too, so no idea. it may be good for reasoning about your code though
05:01:33 <wei2912> it's easier to write correct code
05:02:41 <xificurC> wei2912: I went through 2 online courses for haskell so I know some basics and generally like the language
05:02:52 <exio4> have you checked http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours ?
05:03:12 <exio4> I would say functional languages from the ML-family are really nice for compilers/interpreters
05:07:02 <xificurC> exio4: nice shot, I actually learned Common Lisp before haskell and was thinking of writing the interpreter in Racket
05:07:18 <xificurC> exio4: this might be a better starting point, thanks
05:09:29 <exio4> xificurC: well, I really think algebraic datatypes make the job easier, experiment a little bit, I only wrote interpreters (not compilers), and I find pattern matching+ADTs a nice combo :P
05:22:14 <Cale> xificurC: A lot of the stuff in the dragon book, iirc, is really technical stuff related to parsing which you probably don't have to care about if you just want to use a library like Parsec.
05:22:40 <xificurC> Cale: that's good to know, thanks
05:23:24 <xificurC> I'm looking through Parsec, why is there a Text.Parsec and a Text.ParsecCombinators? The latter says its a compatibility layer
05:23:42 <Cale> Text.ParserCombinators.* is there for backwards compatibility
05:23:51 <xificurC> the wikibook uses the ParserCombinators module
05:23:53 <Cale> You're expected just to use Text.Parsec.*
05:24:10 <xificurC> Cale: does that mean the book is outdated
05:24:23 <Cale> Yeah, a bit. I suppose it wouldn't be hard to update it :)
05:24:29 <xificurC> is there a lot that changed
05:26:24 <Cale> I'm not sure exactly. Parsec has changed a bunch over the years, but the basic ideas required to use it (and other parser combinator libraries) haven't changed much
05:28:27 <xificurC> Cale: well I'll guess I'll try to work with the old module as the book uses it and will later try to move it to the new one
05:30:03 <xificurC> hm, can I supply arguments to main when running it through cabal repl?
05:30:28 <xificurC> main is ofc IO () but the body has a args <- getArgs
05:32:00 <RchrdB> xificurC: quick suggestion: write realMain :: [String] -> IO (), and "main = getArgs >>= realMain"
05:32:34 <RchrdB> You might want to do that with environment variables, too.
05:38:12 * hackagebot hasql 0.1.1 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.1 (NikitaVolkov)
05:39:02 <xificurC> RchrdB: thanks
05:43:13 * hackagebot hasql 0.1.2 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.2 (NikitaVolkov)
05:48:13 * hackagebot MissingH 1.3.0.1 - Large utility library  http://hackage.haskell.org/package/MissingH-1.3.0.1 (JohnGoerzen)
05:52:38 <atomx> hi
05:52:57 <atomx> there are lots of members on this channel!
05:53:14 * hackagebot hasql 0.1.3 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.3 (NikitaVolkov)
05:53:28 <atomx> 1446
05:54:32 <atomx> I wrote my first program in haskell, and I try to open in emacs a repl and execute it. How can I open a repl in haskell-mode ?
05:54:46 <atomx> double x = x + x
05:54:52 <atomx> This is my first program.
05:55:16 <atomx> I try to compute the double of 100, and I do not know how to do it in emacs
05:55:20 <indiagreen> atomx: if it's in a file which you have open in Emacs, do C-c C-l and you should get a repl window
05:55:23 <Freundlich> C-c C-l is the default.
05:56:19 <indiagreen> and if you have the repl opened already but you closed the window or something, C-c C-b will bring it back
05:56:51 <atomx> indiagreen: Freundlich: C-c C-l says so:
05:57:05 <atomx> haskell-mode-enable-process-minor-mode: You tried to do an interaction command, but an interaction mode has not been enabled yet.
05:57:05 <atomx> Run M-x describe-variable haskell-mode-hook for a list of such modes.
05:57:05 <atomx>  
05:58:45 <BoR0> is there a variant in the standard lib which acts like splitOn but only splits the first occurence?
05:59:04 <BoR0> (...and ignores the rest)
05:59:10 <tdammers> takeWhile?
05:59:21 <bennofs> splitAt ?
05:59:24 <bennofs> :t splitAt
05:59:25 <lambdabot> Int -> [a] -> ([a], [a])
05:59:36 <tdammers> :t splitOn
05:59:37 <lambdabot> Eq a => [a] -> [a] -> [[a]]
05:59:41 <bennofs> :t span
05:59:42 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:59:43 <BoR0> > splitAt "*/" "ending comment*/test"
05:59:45 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
05:59:46 <lambdabot>              with actual type ‘[GHC.Types.Char]’
05:59:54 <BoR0> ah, it asks for Int
06:00:21 <BoR0> > splitOn "*/" "ending comment*/test"
06:00:23 <lambdabot>  ["ending comment","test"]
06:00:25 <bennofs> :i splitOn
06:00:29 <bennofs> @index splitOn
06:00:29 <lambdabot> bzzt
06:00:32 <BoR0> > splitOn "*/" "ending comment*/test*/test"
06:00:33 <lambdabot>  ["ending comment","test","test"]
06:00:53 <BoR0> I need ("ending comment", "test*/test")
06:01:25 <bennofs> @let import qualified Data.Text as T
06:01:26 <lambdabot>  .L.hs:111:1:
06:01:26 <lambdabot>      Data.Text: Can't be safely imported!
06:01:26 <lambdabot>      The package (text-1.1.0.1) the module resides in isn't trusted.
06:01:34 <bennofs> @ty Data.Text.breakOn
06:01:35 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
06:01:40 <bennofs> BoR0: ^^^ like this?
06:02:08 <BoR0> > breakOn (T.pack "*/") (T.pack "ending comment*/test*/test")
06:02:09 <lambdabot>  Not in scope: ‘breakOn’
06:02:09 <lambdabot>  Perhaps you meant one of these:
06:02:09 <lambdabot>    ‘break’ (imported from Data.List),
06:02:09 <lambdabot>    ‘BSC.break’ (imported from Data.ByteString.Char8),
06:02:09 <lambdabot>    ‘BSLC.break’ (imported from Data.ByteString.Lazy.Char8)Not in scope: ‘T.pack’
06:02:11 <bennofs> (ignore the Data.Text.Internal, it's because lambdabot can't import text)
06:02:21 <BoR0> let me try that in GHCi, but yeah something like that
06:02:39 <BoR0> yeah, that works! thanks :)
06:03:11 <atomx> indiagreen: probably I did something bad during installation of haskell-mode ?
06:03:15 * hackagebot HSH 2.1.2 - Library to mix shell scripting with Haskell programs  http://hackage.haskell.org/package/HSH-2.1.2 (JohnGoerzen)
06:07:04 <narendraj9> atomx: This is straight from the info page for haskell-mode : ;; Check haskell-mode info page if anything breaks!
06:07:04 <narendraj9> (eval-after-load "haskell-mode"
06:07:04 <narendraj9>   '(progn
06:07:04 <narendraj9>      (define-key haskell-mode-map (kbd "C-x C-d") nil)
06:07:04 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
06:07:04 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-file)
06:07:04 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-b") 'haskell-interactive-switch)
06:07:05 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
06:07:05 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
06:07:06 <narendraj9>      (define-key haskell-mode-map (kbd "C-c M-.") nil)
06:07:06 <narendraj9>      (define-key haskell-mode-map (kbd "C-c C-d") nil)
06:07:07 <narendraj9>      (define-key haskell-mode-map (kbd "C-,") 'haskell-move-nested-left)
06:07:51 <narendraj9> sorry. https://gist.github.com/narendraj9/63676c13da91098fba9f
06:08:31 <narendraj9> atomx: Add this to your init file.
06:08:49 <slomo> did anybody ever try mixing netwire and gloss in one application? does it make sense? all code i found so far is using netwire with SDL, but i really like the simplicity of gloss and it can do all i need :)
06:10:01 <MrNosco> hello
06:10:36 <atomx> narendraj9: thanks a lot!
06:11:32 <MrNosco> Could anyone help me re-write a function, so that is can be lazy?
06:11:43 <MrNosco> it*
06:12:44 <narendraj9> Laziness is the default in Haskell.
06:13:33 <ThreeOfEight> narendraj9: nevertheless, you can write functions that exploit laziness and functions that don't
06:14:02 <MrNosco> binarily a (b:bs) = binarily (a ++ (map (b+) a)) bs
06:14:05 <ThreeOfEight> people coming from eager languages often write list functions with accumulators for no reason
06:14:21 <ThreeOfEight> and that prevents partially evaluating the result list
06:15:01 <MrNosco> since I have binarily in the beggining of the RHS, it cannot evaluate lazily
06:17:45 <atomx> narendraj9: now it started. but when I start the repl,  it asks me about the directories, project name, etc, and when it starts it did not load the file associated to the current buffer.
06:17:59 <atomx> how can I make it load the file when it starts ?
06:18:01 <lechip> Hello everyone! i got a complete binary tree structure and im trying to find a recursive function that tells me how many different wasy of visiting the complete tree are they but I can only visit a lower leel noce if I have visited it's parent.
06:18:07 <narendraj9> atomx: just hit enter.
06:18:19 <narendraj9> as many times as required, you will have the repl.
06:18:26 <narendraj9> ThreeOfEight: Right. I agree.
06:18:50 <padrian2ss> hello. I have a question regarding this: putStrLn $ show 3++"D"                   why the output in 3D without " in ghci :)
06:19:23 <tdammers> padrian2ss: because ghci detects that you're outputting something yourself
06:19:29 <atomx> narendraj9: I _have_ the repl.
06:19:33 <ThreeOfEight> padrian2ss: I don't get your question. What output /would/ you expect.
06:19:36 <ThreeOfEight> ?
06:19:42 <atomx> narendraj9: The repl did not load the file
06:19:48 <lechip> my question?
06:19:49 <padrian2ss> I expect an error? :)
06:20:02 <ThreeOfEight> padrian2ss: why?
06:20:02 <MrNosco> lechip, I'm thinking
06:20:08 <tdammers> padrian2ss: basically, if you type something that evaluates to some value that implements Show, ghci will print that value; but if your code yields an IO action, ghci runs it and doesn't output anything itself
06:20:09 <atomx> I defined in the buffer the function double x = x + x. I start the repl
06:20:15 <nshepperd> padrian2ss: that parses as `putStrLn $ (show 3) ++ "D"`
06:20:18 <atomx> when it starts, it says so:
06:20:23 <lechip> MrNosco: need an example?
06:20:29 <MrNosco> lechip, sure
06:20:29 <atomx> λ> double
06:20:29 <atomx>  
06:20:29 <atomx> <interactive>:7:1-6: Not in scope: `double'
06:20:46 <nshepperd> padrian2ss: show 3 = "3", so that's `putStrLn "3D"`
06:20:47 <lechip> MrNosco: Node 1 (Node 2) (Node 3) has 2 possible linealizations: 1,2,3 and 1,3,2
06:20:53 <padrian2ss> the show is IO for show 3 and >>= "D" ?
06:21:02 <MrNosco> lechip, oohh
06:21:13 <hexagoxel> MrNosco: what is `binarily a []` ?
06:21:22 <fizbin> So this is a puzzle. Anyone know an easy way to test "does cabal support the cabal sandbox command"? I'm trying to write a makefile that'll also work on old versions of cabal.
06:21:31 <MrNosco> hexagoxel, a
06:21:34 <lechip> MrNosco: But gets trickier if I add an element, say Another Examle: Node 1 (Node 2 (Node 4) Empty) (Node 3)
06:21:48 <padrian2ss> nshepperd, tdammers: the show is IO type for show 3 and >>= "D" ?
06:21:55 <ThreeOfEight> fizbin: run cabal --version, sed out the version number and check for ≥ 1.18?
06:21:56 <MrNosco> lechip, hmmm
06:22:04 <lechip> MrNosco>: ah is my own tree, like this data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)
06:22:09 <fizbin> Right. Got that sed script handy?
06:22:11 <nshepperd> padrian2ss: `show` itself has nothing to do with IO
06:22:49 <fizbin> Ah. "cabal --help | grep sandbox" seems obvious, and usable.
06:22:51 <padrian2ss> nshepperd...  sorry you are right
06:23:43 <ThreeOfEight> fizbin: cabal --version | head -n 1 | sed 's/[^0-9.]*\([0-9]*\)\.\([0-9]*\).*/\1.\2/'
06:23:48 <atomx> ok. I think I will work from bash with ghci, as it is impossible to understand how haskell mode can correctly start a repl
06:23:54 <ThreeOfEight> outputs 1.20 for me
06:24:03 <atomx> from bash I do ghci file.hs, and it works
06:24:34 <dcoutts_> ThreeOfEight: cabal --numeric-version
06:24:36 <fizbin> ThreeOfEight: That works on my modern system. Let me check the ancient one...
06:24:48 <fizbin> dcoutts_: OOh. Shiny
06:24:56 <ThreeOfEight> dcoutts_: ah, I suppose that is better. :)
06:25:22 <padrian2ss> nshepperd thanks for your kind explanation, but how come the output is without " for putStrLn $ show 3++"D"
06:25:23 <dcoutts_> ThreeOfEight: if there's one thing the Cabal authors appreciate, it's that grepping for version numbers in command output is a pain in the posterior :-)
06:25:31 <nshepperd> padrian2ss: putStrLn $ show 3 ++ "D"  =  putStrLn (show 3 ++ "D")  =  putStrLn ("3" ++ "D")  =  putStrLn "3D"
06:25:36 <dcoutts_> Cabal has a whole little framework for finding version numbers of other tools
06:25:38 <MrNosco> lechip, so Node 1 (Node 2 (Node 4) (Node 5)) (Node 3 (Node 6) (Node 7)) have the linearizations ["1245367","1254267",etc]?
06:26:00 <fizbin> dcoutts_: Now I just need a good version number comparator...
06:26:19 <lechip> MrNosco: exactly, all combinatins but you cannot visit a children without divisitng a parent
06:26:25 <dcoutts_> fizbin: of course Cabal parses version numbers as the Version type, and then does comparisons there
06:27:33 <nshepperd> padrian2ss: now, putStrLn is an IO action that outputs the given string followed by a newline. But when you evaluate an IO action in ghci it gets executed
06:28:03 <narendraj9> MrNosco: helper = \a b -> foldr (\x xs -> (map (+x) a) : xs) [] b ; main a b = concat (helper a b).
06:28:29 <padrian2ss> nshepperd: thanks again for your kind explanation ! :)
06:28:30 <fizbin> Ah. Found a good version-comparison makefile recipe.
06:29:00 <dcoutts_> fizbin: if you have access to ghc, you can use a ghc -e '....' script
06:29:56 <tdammers> padrian2ss: no. I tried to describe what ghci does, at a global / conceptual level
06:29:59 <fizbin> dcoutts_: Sure, but this recipe I found has the advantage of working with the unfortunate situation that non-haskell people will need to review this makefile.
06:30:22 <MrNosco> lechip, lin (Node a (Node b) (Node c)) = [a++b++c|x<-lin Node a,y<-lin Node b,z<-lin Node c]
06:30:31 <atomx> narendraj9: It works only when I do (ghc-core-create-core)
06:30:34 <padrian2ss> nshepperd, tdammers: thank you guys!
06:30:35 <dcoutts_> fizbin: yep that's fair enough
06:31:02 <atomx> This works correctly. It creates a buffer having the whole evaluation, including the results
06:31:12 <MrNosco> lechip, or something like that. Then you just need to figure out the edge cases: lin (Node a Empty Empty) = ...
06:31:18 <narendraj9> atomx: It worked for me without any trouble.
06:31:34 <narendraj9> atomx: I just read the info page.
06:31:45 <MrNosco> narendraj9, is this for the problem I asked about earlier?
06:31:54 <narendraj9> MrNosco: Yes.
06:32:13 <atomx> ok, thanks
06:33:49 <narendraj9> MrNosco: let main = \a b -> concat  (foldr (\x xs -> (map (+x) a) : xs) [] b)
06:36:06 <Zyxoas> .
06:37:16 <hexagoxel> narendraj9: that is not semantically equivalent
06:38:34 <atomx> narendraj9: It worked after I executed :cd and :load file
06:39:51 <narendraj9> hexagoxel: Oh. Yes, it's wrong.
06:40:49 <narendraj9> atomx: It should do that automatically.
06:41:31 <atomx> I know. I will discover in the time. I cannot spend much time debugging haskell mode now
06:41:51 <atomx> I need to debug to see how it starts, and see what vars are bad set
06:42:01 <atomx> it is giid like that
06:42:10 <atomx> thank you
06:42:11 <narendraj9> atomx: Okay.
06:42:34 <MrNosco> narendraj9, an example output would be: binarily [0] [1,10,100] = [0,1,10,11,100,101,110,111]
06:43:13 <MrNosco> narendraj9, te functions you showed gave [1,10,100] as output for the same inputs
06:53:20 <hexagoxel> MrNosco: one solution can be found by starting with `binarily a b = a ++ f a b where f [TODO]`
06:54:37 <MrNosco> hexagoxel, thanks for the tip!
06:57:33 <batchm> say I wanted to make [1,2] + [10,100,1000] work, what would you expect the result to be? [11,102] (stripping to shortest) or [11,102,1000] (leaving longest elements intact), or [11,101,1001,12,102,1002] (adding each number from one list with each from another)
06:58:57 <MrNosco> batchm, the last option
07:00:52 <MrNosco> batchm, but the sorting of it would have to be different, it has to go diagonally, if that makes sence
07:01:10 <batchm> I see.. I just did liftA2 (+)
07:01:11 <Cale> > liftM2 (+) [1,2] [10,100,1000]
07:01:12 <lambdabot>  [11,101,1001,12,102,1002]
07:01:46 <MrNosco> from what package?
07:02:13 <batchm> liftA2? Control.Aplicative
07:02:19 <batchm> Applicative
07:02:40 <batchm> it is in base
07:11:15 <albeit> I'm currently using a State monad to pass around a large datastructure, but most of the time I just need to read from it, and only occasionally modify it... is State still the best thing to use?
07:11:45 <albeit> (It's in fact a StateT m IO)
07:12:41 <simon> albeit, sounds fine.
07:12:45 <albeit> I guess what I'm asking is if there any way to specify a function is only allowed to read from the the State structure, and not allowed to write, and that is somehow checked?
07:13:04 <simon> albeit, you could divide a part of your state into a separate Reader monad.
07:13:58 <albeit> Hmm okay, might try that. Thanks!
07:14:55 <simon> albeit, e.g., ReaderT Env (StateT m IO) for some suitable Env.
07:15:56 <simon> hm. I'd probably call that StateT s IO, by the way :)
07:16:00 <EvanR> you can also run a reader inside a state action using the state as the environment
07:16:20 <simon> EvanR, that's pretty cool.
07:16:36 <EvanR> but you can "escape out" in the middle and modify something
07:16:38 <EvanR> cant*
07:24:22 <Fellmin> @unpl (foldr g v . map f)
07:24:22 <lambdabot> (\ c -> foldr g v (map f c))
07:34:50 <Vithar> Does anyone know how to pull a column out of a two-dimensional Repa array by any chance?
07:47:20 <xificurC> I'm lost at this exercise.. I'm parsing a string, e.g. "\"hello\"" as input returns MyString "hello". Now the exercise is asking me to handle \" differently - instead of terminating the string it should simply include a double-quote
07:47:32 <xificurC> but how should I terminate the string then?
07:47:46 <tdammers> end-of-input?
07:47:49 <tdammers> literal " ?
07:49:15 <xificurC> tdammers: the function shouldn't eat up all of the string, this is part of a parser
07:49:27 <xificurC> it should read the string up to some point and then give control back to the parser
07:49:59 <dfeuer> A string!
07:50:09 <bartavelle> xificurC, doesn't it just mean you should check for escaped " ?
07:50:51 <xificurC> bartavelle: but that was my terminator before
07:50:57 <dfeuer> Ozy and Millie: Blue String Theory:  http://ozyandmillie.org/1998/07/17/ozy-and-millie-69/
07:51:14 <xificurC> parseString = do
07:51:16 <xificurC>                 char '"'
07:51:18 <xificurC>                 x <- many (noneOf "\"")
07:51:20 <xificurC>                 char '"'
07:51:22 <bartavelle> exactly
07:51:22 <xificurC>                 return $ String x
07:51:24 <xificurC> this was the definition given by the book
07:51:27 <dfeuer> xificurC, you probably need to terminate on unescaped quote.
07:51:43 <bartavelle> you can parse "xxx" properly, but not "xx\"xx"
07:51:50 <xificurC> $ ./simple_parser "\"this is a string\""
07:51:52 <xificurC> Found value
07:51:55 <xificurC> this is an example input
07:51:56 <geekosaur> also, please use a pastebin for more than one line
07:51:58 <geekosaur> @paste
07:51:58 <lambdabot> Haskell pastebin: http://lpaste.net/
07:52:04 <xificurC> that is parsed as "this is a string"
07:52:10 <xificurC> geekosaur: fair enough
07:52:39 <xificurC> bartavelle: "xxx" is parsed as a symbol
07:52:43 <bartavelle> this is equivalent to $ ./simple_parser '"this is a string"' (not sure it's visible, it's enclosed in simple quotes)
07:52:48 <xificurC> bartavelle: "\"xxx\"" was a string
07:52:56 <bartavelle> oh wait
07:53:06 <bartavelle> there is shell interpretation happening here
07:53:21 <bartavelle> if you putStrLn the argument, you'll see "this is a string"
07:53:27 <bartavelle> not "\"this is a string\""
07:54:15 <bartavelle> but it looks like you are asked to handle escaped ", for example you can write in haskell `let a = "x\"y"`
07:54:26 <bartavelle> putStrLn a will print x"y
07:54:39 <dfeuer> Do not to using a command line argument for that of which no! Yourself you will confuuuuuse.
07:54:48 <jsam> jackhookers
07:55:32 <dfeuer> What's that mean, jsam?
07:55:47 <jsam> typo, sorry
07:56:02 <albeit> If I use a ByteString.Builder as a prefix for other Builders, are the prefix builder components evaluated just once, or every time its used as a prefix?
07:56:21 <xificurC> bartavelle: I know that, hm, why can't I explain well what I mean
07:56:55 <xificurC> parseExpr = parseAtom <|> parseString <|> parseNumber
07:57:03 <bartavelle> probably because I have some idea of what you want to say, and I am not actually listening to you ;)
07:57:41 <xificurC> so parseExpr "this" will return an Atom
07:57:56 <xificurC> parseExpr "\"this\"" will return a MyString
07:58:05 <bartavelle> err
07:58:18 <bartavelle> ok
07:58:40 <bartavelle> it will return an Expr constructed with the MyString constructor
07:59:53 <xificurC> imagine a parser that will read your source code from a file
07:59:57 <bartavelle> xificurC, I *think* you are asked to be able to have this work properly : parseExpr "\"this is escaped : \\\" \""
08:00:15 <xificurC> so if you have (literally) "a string" in your file, once loaded in haskell it will be "\"a string\""
08:00:49 <xificurC> bartavelle: I see
08:00:49 <td123> is there a deb package/ppa of ghc 7.8 that works under ubuntu 14.04?
08:00:51 <bartavelle> xificurC, now what if you have (literally) "a \" b" in your file ?
08:01:12 <xificurC> bartavelle: so that would become "\"a \\\" b\"" from what you showed, correct?
08:01:23 <bartavelle> I would expect so
08:01:32 <xificurC> escape hell
08:01:44 <td123> i guess https://launchpad.net/~hvr/+archive/ubuntu/ghc is probably the one i want
08:01:58 <bartavelle> yes, but don't worry, this is something you'll have to reinvent all the time :p
08:08:31 * hackagebot type-level-bst 0.1 - type-level binary search trees in haskell  http://hackage.haskell.org/package/type-level-bst-0.1 (Kinokkory)
08:33:33 * hackagebot polyparse 1.10 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.10 (MalcolmWallace)
08:53:36 * hackagebot HaXml 1.25 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.25 (MalcolmWallace)
08:56:43 <dsfox> td123: http://deb.seereason.com/ubuntu/pool/main/g/ghc/
08:57:50 <dsfox> td123: launchpad possibly better
08:58:29 <bernalex> uhm how do I do this
08:58:44 <bernalex> foo $ case bleurgh of [] -> words <$> bar ; xs -> xs   ?
08:58:57 <bernalex> the first case there needs a compose somewhere to give foo . words <$> bar.
08:59:12 <bernalex> is it even possbile to write it like this? lol
09:01:33 <bernalex> ah of course
09:02:00 <bernalex> foo <$> case bleurgh of [] -> words <$> bar ; xs -> return xs
09:05:52 <haskell_noob> hi anyone here?
09:05:58 <pharpend> yes
09:06:01 <tdammers> no
09:06:13 <josephle> maybe
09:06:21 <pharpend> well tdammers says no, an dI'm inclined to believe him
09:06:23 <tdammers> :t maybe
09:06:24 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:06:34 <haskell_noob> im lost with a haskell task
09:06:42 <tdammers> haskell_noob: don't ask to ask, just ask
09:07:31 <haskell_noob> i have to build a function "conjunction :: [Bool] -> [Bool]" which checks if a list only has "True" in it
09:07:43 <haskell_noob> i dont know how i should do it
09:08:24 <hexagoxel> why does it return [Bool]?
09:08:34 <Vithar> Would the function return "True" if there is any true value in the input list?  If so, it looks like "conjunction :: [Bool] -> Bool"
09:08:51 <haskell_noob> sorry vithar, thats what i ment
09:08:56 <phz> hey
09:08:56 <pharpend> okay
09:08:57 <haskell_noob> [Bool] -> Bool
09:09:27 <pharpend> let conjunction = or in conjunction [False, False, True]
09:09:31 <pharpend> > let conjunction = or in conjunction [False, False, True]
09:09:32 <haskell_noob> it returns True, if ALL values in the list are "True"
09:09:33 <lambdabot>  True
09:09:45 <pharpend> > let conjunction = and in conjunction [False, False, True]
09:09:46 <lambdabot>  False
09:09:55 <pharpend> > let conjunction = and in conjunction [True]
09:09:56 <Vithar> conjunction = elem True
09:09:57 <lambdabot>  True
09:10:13 <Vithar> You're just looking to see if the input list contains the element.
09:10:14 <pharpend> Vithar: and is what he's looking for
09:10:29 <pharpend> Vithar: elem True = or
09:10:38 <Vithar> Either way.
09:10:41 <haskell_noob> example: [True, True, True] would return True
09:10:52 <josephle> :t and
09:10:53 <lambdabot> [Bool] -> Bool
09:10:55 <pharpend> Vithar: which tests if *one* of them is true, but he wants All of them to be true, so he wants and
09:10:55 <haskell_noob> [True, False, True] would return false
09:11:12 <glguy> haskell_noob: What part are you struggling with?
09:11:19 <pharpend> haskell_noob: just write "conjunction = and"
09:11:29 <TallerGhostWalt> so I write a lot of Generic ToJSON , FromJSON and want to have tests that check to make sure the serialization hasn't changed on me
09:11:45 <TallerGhostWalt> is there a aesonGenerateTest ''SomeType
09:11:48 * glguy suspects that the task isn't to see if someone on IRC knows that library function that does this
09:11:49 <TallerGhostWalt> floating around out there?
09:11:52 <ReinH> Vithar: you are describing disjunction
09:11:53 <josephle> of course if haskell_noob also wants to learn how to write "and"
09:11:59 <haskell_noob> pharpend: how do i put the parameter in it?
09:12:08 <josephle> glguy: yeah, that's what I'm suspecting too
09:12:10 <phz> I’v added a few stuff into lambdabot for you to understand my issue. I have a pair type (:.) and a functor type Arg i a used to replace value in (:.). For instance, True :. "test" has type Bool :. String. Arg i a enables me to change a a into a i, basically. I wrote a function that does that for the left type of the (:.) (see argify in lambdabot). Now, I’d like to find an abstraction or way to transform any kind of a :. b to inject Arg
09:12:10 <pharpend> haskell_noob: it doesn't need a parameter
09:12:11 <phz> http://lpaste.net/113331
09:12:15 <phz> any idea? :/
09:12:18 <pharpend> haskell_noob: that's the beauty of Haskell
09:12:21 <haskell_noob> someone told me i should do "conjunction x = foldr (&&) True x" but i dont get how thatworks
09:12:29 <SwashBuckla> I like git hunks
09:12:30 <ReinH> haskell_noob: Are you familiar with folds?
09:12:32 <SwashBuckla> a) it sounds odd
09:12:32 <pharpend> haskell_noob: that's a very convoluted method
09:12:34 <SwashBuckla> b) it's actually a nice way of documenting intemediary states in an edit
09:12:43 <ReinH> pharpend: no, it is a normal method
09:12:45 <ReinH> @src and
09:12:45 <lambdabot> and  = foldr (&&) True
09:12:50 <glguy> pharpend: No, that's definitely not convoluted
09:12:51 <josephle> haskell_noob: can you write conjunction with explicit recursion?
09:12:54 <haskell_noob> ReinH: not at all
09:12:55 <ReinH> It is how and works
09:13:09 <haskell_noob> josephle: task doesnt tell me how to do it
09:13:29 <SwashBuckla> glguy: :)
09:13:31 <ReinH> > foldr f a [b,c,d]
09:13:32 <lambdabot>  Ambiguous occurrence ‘f’
09:13:32 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:183:1
09:13:32 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
09:13:32 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
09:13:32 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:13:37 <ReinH> :(
09:13:42 <ReinH> > foldr f a [b,c,d] :: Expr
09:13:44 <lambdabot>  Ambiguous occurrence ‘f’
09:13:44 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:183:1
09:13:44 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
09:13:44 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
09:13:44 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:13:50 <ReinH> really
09:14:02 <ReinH> Did someone define f?
09:14:05 <phz> I reckon it’s related to functor, because fmap (argify (succ i) $ argify i enables me to do that for two layers; I’m just looking for a way to do that for an infinite number of layers
09:14:15 <ReinH> @unlet f
09:14:15 <lambdabot>  Parse failed: TemplateHaskell is not enabled
09:14:16 <pharpend> @@ haskell_noob > let conj y = case y of ; (x:xs) -> x && conj xs ; [] -> x
09:14:16 <lambdabot>  haskell_noob > let conj y = case y of ; (x:xs) -> x && conj xs ; [] -> x
09:14:21 <pharpend> ack
09:14:27 * ReinH sighs
09:14:31 <pharpend> > let conj y = case y of ; (x:xs) -> x && conj xs ; [] -> x
09:14:32 <josephle> haskell_noob: do you know how to do recursion in haskell?
09:14:32 <lambdabot>  not an expression: ‘let conj y = case y of ; (x:xs) -> x && conj xs ; [] -> x’
09:14:32 <sivteck> @undefine
09:14:32 <lambdabot> Undefined.
09:14:46 <phz> …
09:14:46 <ReinH> > foldr f a [b,c,d] :: Expr
09:14:47 <lambdabot>  f b (f c (f d a))
09:14:52 <pharpend> > let conj y = case y of ; (x:xs) -> x && conj xs ; [] -> x in conj [True, False, True]
09:14:54 <phz> thank you sivteck …
09:14:54 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
09:14:54 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
09:14:54 <haskell_noob> pharpend: that look quite complicated for a newbie
09:14:59 <pharpend> erg
09:15:02 <ReinH> haskell_noob: foldr is a way to combine elements in a list
09:15:04 <silver> pharpend, please stop that
09:15:07 <pharpend> haskell_noob: you would spread that over multiple lines
09:15:32 <haskell_noob> i tried what you told me pharpend
09:15:40 <haskell_noob> with conjuction = and
09:15:42 <sivteck> phz, lol, sorry
09:15:42 <phz> yeah now everything has disappeared from λbot, I just have this http://lpaste.net/113331 ; is there a cool abstraction for that?
09:15:47 <haskell_noob> without parameter and it works
09:15:48 <haskell_noob> weird
09:16:06 <pharpend> haskell_noob: in haskell, you can "partially apply" functions
09:16:20 <pharpend> haskell_noob: so (f x = g x) can be reduced to (f = g)
09:16:36 <pharpend> haskell_noob: so (conjugate x = and x) can be reduced to (conjugate = and)
09:16:38 <lyxia> haskell_noob: That's because the function you are looking for is in Prelude and is called "and".
09:17:14 <pjdelport> haskell_noob:
09:17:14 <pjdelport> conjunction (x:xs) = x && conjunction xs
09:17:14 <pjdelport> conjunction [] = True
09:17:27 <pjdelport> haskell_noob: That's the conventional way of writing what pharpend wrote.
09:17:48 <phz> ok, I guess I can turn the a :. b :. c into f a (f b c)
09:17:55 <pharpend> phz: if Arg i is a monad and a monoid, yes
09:17:56 <phz> I might find something to fix that then
09:18:00 <adarc> i often find myself wrecked when i fork a haskell repo on github and use cabal-meta to install my package.. it'll download my github version of the code (via sources.txt) but then it'll use some pre-existing version of it somewhere else (~/.cabal/etc) and then everything breaks
09:18:07 <adarc> anyone ever run into this or know how to work around it?
09:18:07 <haskell_noob> pjdelport: that would be kind of recursive right?
09:18:09 <josephle> haskell_noob: if you want some more guidance, I think #haskell-beginners is the place to be
09:18:23 <pjdelport> haskell_noob: Yes: exactly recursive. :)
09:18:36 <pharpend> adarc: use a sandbox.
09:18:39 <haskell_noob> thx josephle ill check it out :D
09:18:44 <adarc> ya, i am pharpend
09:18:45 <haskell_noob> thx so far
09:18:49 <haskell_noob> one more question
09:18:49 <adarc> that's the weird part about it..
09:18:50 <pharpend> hmm
09:18:58 <pjdelport> haskell_noob: In fact, it's such a very common recursion pattern for lists that there's a helper for it: that's just what foldr does.
09:19:06 <phz> http://lpaste.net/113333
09:19:09 <ReinH> pjdelport: (not quite)
09:19:11 <pharpend> adarc: make sure the dependency list in the cabal file is correct
09:19:18 <ReinH> (that's foldl)
09:19:32 <haskell_noob> i have to print the collatz function for a number n, is it more easy to do it recursive or iterative?
09:19:33 <pharpend> phz: I'm not familiar with the :. operator
09:19:37 <phz> now I have to generalize the Arg stuff
09:19:43 <phz> pharpend: data a :. b = a :: b
09:19:43 <dcoutts_> adarc: if the source version is added to your sandbox then everything else within the sandbox can only use that version, there is no choice. If you can show a situation when that does not happen then it's a bug and you should report it.
09:19:45 <phz> :. *
09:19:48 <phz> it’s just a pair
09:19:56 <phz> pharpend: data a :. b = a :. b
09:20:01 <ReinH> haskell_noob: in Haskell, it's always recursive.
09:20:06 <adarc> pharpend: it is.. so, for example, i fork'd 'cron' from the original.. so, in my sources.txt I have https://git.../cron, and in the Blah.cabal I have 'cron' listed as a build-depends... but it seems like cabal/cabal-meta is struggling between the two different code bases
09:20:20 <pharpend> hmmm\
09:20:28 <haskell_noob> ReinH: is it the only way, or is it just easier?
09:20:37 <phz> http://lpaste.net/113334
09:20:39 <phz> ok
09:20:47 <phz> I guess I can find a way to do that then
09:20:54 <ReinH> haskell_noob: iteration is done via recursion as well
09:20:55 <dcoutts_> adarc: I can't help you with cabal-meta, but if you can show this happening with just cabal sandboxes then please report it.
09:21:09 <phz> it looks like a bit Free
09:21:18 <phz> without Pure
09:21:38 <adarc> ya.. it's not cabal, i think it's related to meta.. i'm using 'meta' to pull down repos from my personal gitub account.
09:21:41 <adarc> can cabal do this yet? do you know?
09:22:04 <dcoutts_> it can fetch the git version, as a one off, just like it can fetch the tarball
09:22:12 <dcoutts_> see cabal get --help
09:22:44 <haskell_noob> thank you guys so far, you helped out a lot!
09:22:57 <haskell_noob> ill probably check in more often now for questions if that is okay
09:23:21 <adarc> cool.. so i would have to cabal -get -s https://github.../blah in say, a makefile, before running cabal install ? would it then use my package instead of pulling it down from hackage etc?
09:24:24 <dcoutts_> adarc: there's a couple things you can so, you can simply tell cabal to install the given local packages, e.g. cabal install ./this ./that
09:24:59 <dcoutts_> adarc: for a one-shot build script that's the simplest
09:25:41 <adarc> cool thanks.. im reading up on it.. i need to somehow figure out how to avoid this because it stops my coding dead in it's tracks
09:25:53 <joshc> phz: unfortunately I think it's still unclear what you are asking for
09:25:57 <adarc> i could use submodule perhaps and use cabal sandbox add-source etc
09:25:59 <adarc> too
09:26:15 <phz> joshc: http://lpaste.net/113336
09:26:16 <dcoutts_> adarc: the other approach is that people add the source to the sandbox but this approach is better suited for interactive hacking than build scripts
09:26:48 <phz> I want to find a way, given a a :. b, to inject a g at each left values in a :. b, so g a :. (g ? :. (g :. ??…)
09:27:33 <phz> I guess I have to find a structure that enables me to map that g
09:27:42 <adarc> cool, cabal sandbox add-source worked..
09:27:47 <adarc> i really need to get away from using cabal-meta
09:28:16 <adarc> thanks folks.. maybe this will finally end up resolving it
09:28:17 <adarc> pc
09:28:21 <ReinH> phz: what is the type of (:.)?
09:28:34 <ReinH> Can you make it a Functor?
09:28:37 <phz> ReinH: data a :. b = a :. b
09:28:38 <phz> yes
09:28:48 <phz> fmap f (a :. b) = a :. f b
09:28:49 <ReinH> Oh, no, you can't
09:28:58 <ReinH> Well, you can, but not in a useful way.
09:29:03 <phz> ReinH: well
09:29:09 <phz> it’s a bifunctor, though
09:29:20 <phz> note that the problem becomes easy if a ~ b
09:30:14 <phz> I’m gonna try with existential quantification
09:30:21 <phz> please don’t undefine  λbot
09:30:21 <ReinH> That's a strange data type
09:30:27 <phz> I don’t have any ghci here
09:30:29 <phz> thanks
09:30:42 <ReinH> phz: Please don't use lambdabot as your personal ghci
09:30:54 <ReinH> Defining `f' is not really ok.
09:31:06 <phz> ReinH: I don’t, it’s just for a few minutes in private
09:31:11 <ReinH> lambdabot is for everyone to use
09:31:19 <phz> I don’t define f, don’t worry :)
09:31:45 <ReinH> People will continue to feel free to undefine lambdabot. It is not your personal ghci.
09:32:01 <phz> ok, got it he
09:32:07 <phz> eh*
09:32:10 <bernalex> what's the list monad trick again? the [ foo | bar ] something
09:32:31 <bernalex> so if foo is empty bar is used, if not foo is used. or something.
09:32:55 <ReinH> [ foo | bar ] is if bar then [foo] else []
09:32:59 <ReinH> > [ 1 | False ]
09:33:01 <lambdabot>  []
09:33:12 <bernalex> ReinH: ah
09:33:26 <bernalex> ReinH: is there a "if foo is not empty use that, else use bar" trick?
09:34:10 <ReinH> Not afaik. (<|>) = (++) for lists
09:34:52 <sivteck> :t fromMaybe
09:34:53 <lambdabot> a -> Maybe a -> a
09:34:53 <bernalex> it would be nice
09:35:04 <EvanR> > head ([] ++ ['a'])
09:35:06 <lambdabot>  'a'
09:35:09 <johnw>  bernalex: I've wanted it before also
09:35:54 <bernalex> what should I use to fork of a program? :-]
09:35:58 <bernalex> I forget
09:36:01 <benzrf> ok so
09:36:13 <benzrf> my friend was axing me "y no 1-tuples"
09:36:24 <benzrf> and i said "well itd just be the type u put in it, thats not terribly useful"
09:36:30 <benzrf> but then i realized that's exactly what Identity is
09:36:39 <MrNosco> yo benzrf, fancy seeing you here!
09:36:45 <benzrf> oh hey MrNosco
09:36:47 <benzrf> why not baked-in 1-tuples for use as Identity
09:37:32 <ReinH> bernalex: is (1 + 1) 2 or (2)?
09:37:44 <bernalex> ReinH: wat?
09:37:45 <joshc> > Identity undefined `seq` 4
09:37:47 <lambdabot>  *Exception: Prelude.undefined
09:37:48 <ReinH> It would make the syntax ambiguous
09:38:04 <ReinH> Should (1 + 1) be parsed as 2 or the 1-tuple containing 2?
09:38:27 <ReinH> bernalex: sorry, bad tab complete
09:40:28 <dfeuer> It's back just in time for Choptoberfest! http://choppingblock.keenspot.com
09:40:36 <MrNosco> what's the use for the Identity monad?
09:41:39 <johnw> MrNosco: http://blog.sigfpe.com/2007/04/trivial-monad.html
09:42:21 <ReinH> johnw: I wish he had called it T ;)
09:43:59 <dfeuer> ReinH, do we need the transformer too? TT?
09:44:09 <ReinH> ^_^
09:44:52 <ReinH> Identity per se isn't very useful, but it can be a useful parameter to higher order types
09:46:15 <ReinH> Free Identity is a list, Cofree Identity is an infinite stream.
09:46:52 <phz> ReinH: ok, my idea:
09:47:05 <MrNosco> hmm
09:47:12 <phz> data Foo f g = forall a b. (f (g a) (Foo f g))
09:47:22 <phz> and…
09:47:43 <phz> foo :: (Bifunctor f) => (a -> g a) -> f a b -> Foo f g
09:47:53 <kgadek> hi. I want to convert datastruct into itself with changed type param. The easiest, simplified example is: I have `Maybe Int`, I want to make `Maybe Char`. I pattern match on Just, do appropriate conversions — easy. But how to change `Nothing` from `Maybe Int` to `Maybe Char`?
09:47:54 <kgadek> More precisely, I have complex datatype with multiple constructors, each having some params. One of this constructors does not use type param and thus I can't simply `convert others = others` since types not match.
09:47:54 <phz> foo g = Foo . bimap g (foo g)
09:47:58 <ReinH> No, Free Identity is not a list, sorry
09:47:59 <phz> but that doesn’t work :(
09:49:05 <phz> since (:.) is a Bifunctor
09:49:13 <phz> I can use foo with it
09:49:22 <phz> and I can end it with the common Z
09:49:27 <phz> data Z a b = Z
09:49:32 <DarkCthulhu> I need to extend simply typed lambda calculus in haskell with the unit type, but I don't understand what syntax I should use for the unit type
09:49:40 <phz> instance Bifunctor Z where bimap _ _ _ = Z
09:50:02 <ReinH> :t let f :: Maybe Char -> Maybe Int; f Nothing = Nothing in f
09:50:03 <lambdabot> Maybe Char -> Maybe Int
09:50:45 <ReinH> kgadek: (you are defining fmap for Maybe)
09:51:07 <kgadek> ReinH: yeah, but this is impossible for my case
09:51:13 <ReinH> kgadek: what is impossible?
09:51:25 <kgadek> actually I could've given other example: how to convert phantom type?
09:52:50 <kgadek> ReinH: I have a complex datatype that has no reasonable Functor. Yet I need to convert the type. In `Functor Maybe` it's easy since Nothing is a singleton
09:53:14 <kgadek> actually I could rewrite the record field-by-field but that's fugly
09:53:51 <ReinH> kgadek: Same way:
09:53:51 <ReinH> :t let convertConst :: Const a String -> Const a Int; convertConst (Const a) = Const a in convertConst
09:53:55 <lambdabot> Const a String -> Const a Int
09:54:49 <kgadek> ReinH: ok, rewrite is a way to go. any other way? I'm talking about 5 params per constructor
09:55:04 <kgadek> (or suppose that it's that many, whatever)
09:55:23 <phz> how do you say in a constraint that two types are the same?
09:55:33 <phz> (Functor f,Functor g,f ~ g) ?
09:56:03 <kgadek> phz: yes but you need additional LANGUAGE features, FunctionalDependencies if I recall well
09:56:15 <phz> yeah well
09:56:23 <phz> I think I’m trying impossible things
09:56:23 <phz> so…
09:56:56 <phz> http://lpaste.net/113336
09:57:05 <phz> that doesn’t work, because b is not a Bifunctor
09:57:14 <phz> and I can’t make it a Bifunctor because it’s recursive
09:57:23 <ReinH> phz: what are you trying to accomplish with this type?
09:57:40 <phz> ReinH: a :. b is a type for defining vertices
09:57:51 <phz> like V3 Float :. V3 Float :. V3 Word32 :. Z
09:57:57 <phz> I want to be able to express shaders
09:58:02 <phz> which are something like
09:58:15 <phz> E (V3 Float) :. E (V3 Float) :. E (V3 Float :. E Z
09:58:23 <phz> so I have to “inject” E
09:58:50 <phz> so that E discards any value and represents them
10:00:39 <albeit> What's the best way to criterion time something that sends data over a socket? I just want to know how long it takes, but if I run a receiving thread for the socket, the receiving time may be included in the total time
10:01:21 <kgadek> albeit: is that UDP or TCP?
10:01:27 <albeit> kgadek: TCP
10:01:49 <kgadek> albeit: if I'm not mistaken, in TCP you can't say "just send" without receiving
10:01:54 <kgadek> vide: retransmissions, etc
10:02:34 <phz> I have an example for that ReinH
10:02:43 <phz> > True :. "foo"
10:02:44 <lambdabot>  True :. "foo"
10:02:51 <phz> > two 0 $ True :. "foo"
10:02:53 <lambdabot>  Arg {unArg = 0} :. Arg {unArg = 1}
10:03:00 <albeit> True... so I guess I need to figure out a way to make the receiving end not part of the Haskell runtime, and make it as fast as possible
10:03:04 <phz> I want to generalize that to any (:.) :(
10:03:14 <phz> :t two 0 $ True :. "foo"
10:03:15 <lambdabot> (Num i, Enum i) => Arg i Bool :. Arg i [Char]
10:03:22 <kgadek> albeit: try netcatting that into /dev/null
10:03:28 <kgadek> should be fast enough
10:03:51 <ReinH> albeit: send it to /dev/null
10:03:58 <ReinH> :p
10:04:00 <phz> hm, maybe I can define a special typeclass
10:04:23 <albeit> kgadek: Ah I'll look into that, cool
10:04:55 <albeit> ReinH: Though you may not be serious... would there be additional overhead associated with writing to a socket as opposed to just /dev/null?
10:05:16 <ReinH> albeit: well, you can't write to /dev/null directly. /dev/null won't perform a TCP handshake.
10:05:37 <albeit> ReinH: Yeah I was thinking more writing to a file handle of /dev/null
10:05:59 <ReinH> This was originally done as a joke: https://gist.github.com/raggi/560087
10:06:25 <Hijiri> I haven't done much with pipes or conduit yet, what would criteria would should I consider when picking one over the other?
10:07:34 <kgadek> Hijiri: this is not an answer to your question, just wanted to note that there was a Haskellcast on them both.
10:08:10 <Hijiri> maybe I'll look that up, thanks
10:12:35 <albeit> kgadek: netcat into /dev/null worked perfectly, thanks!
10:12:45 <kgadek> albeit: good to hear that :)
10:12:51 <ReinH> Hijiri: Enjoy the cast :)
10:12:58 <ReinH> albeit: :)
10:13:12 <ReinH> Personally, I use Conduit
10:13:52 <ReinH> kgadek: thanks for the plug ;)
10:15:01 <Faucelme> Hijiri: pipes can be bidirectional. conduits aren't.
10:15:52 <Faucelme> conduits have integrated "pushback" of leftovers. pipes have an additional abstraction for parsers with pushback.
10:17:58 <ReinH> Conduits also have better resource management, at least last time I looked at pipes
10:28:49 <phz> @undefine
10:28:49 <lambdabot> Undefined.
10:29:08 <adarc> anyone have any idea how to remove cabal-src?
10:29:52 <adarc> local-repo: /root/.cabal/packages/cabal-src/
10:30:14 <adarc> i have that in my ~/.cabal/config
10:30:22 <adarc> but i can't find the cabal-src package aywhere
10:35:01 <adarc> getting rid of local-repo worked.... nice.
10:54:46 <albeit> A test program runs about 25% faster on a test 4 core @ 2Ghz machine versus the production 24 core @ 2.5Ghz machine (which has zero cpu usage). Is there some Haskell configuration/setup that may be contributing to that?
10:56:14 <kgadek> albeit: just checking - have you passed +RTS -N option?
10:56:39 <kgadek> eg. ./program +RTS -N24 -RTS
10:56:53 <kgadek> and compiled the program with -threaded flag
10:57:00 <albeit> kgadek: Yep, I've actually tried using 1/4/24 cores and the speed difference remains. It is a single threaded test, so I would think #cores doesnt matter
10:57:15 <kgadek> ah ok.
10:57:42 <kgadek> so… disable threading?
11:00:26 <albeit> Actually it's not Haskell related.... super_pi also ran slower. Shoot
11:01:15 <koala_man> albeit: what kind of cpus are these?
11:01:51 <exio4> IIRC GHC's runtime has a peak with 8 cores(?) or something like that, and after that, the GC becomes a bottleneck
11:02:01 <exio4> I don't actually remember the exact numbers though, can anyone confirm this?
11:03:10 <josephle> I remember the last time this conversation happened, people suspected RAM ended up being the bottleneck
11:03:56 <josephle> ah, this is the runtime and not parallel compilation
11:04:47 <k00mi> kgadek: what version of ghc?
11:05:06 <albeit> Oh nevermind, I'm not thinking clearly, mixed up the specs. Break time
11:05:08 <k00mi> albeit ^
11:08:14 <k00mi> there are a lot of factors other than clock speed playing into the performance of a single core
11:09:30 <albeit> exio4: So, if running a single Haskell runtime, it would never really make sense to have a computer with more than 8 cores?
11:09:54 <Hijiri> you could run three haskell runtimes
11:10:03 <Hijiri> on 24 cores
11:10:05 <Hijiri> oh, sorry
11:10:12 <Hijiri> I didn't see the "single"
11:10:25 <cdk> isn't the new (7.8) GHC IO manager supposed to scale up to 30+ cores?
11:10:26 <Hijiri> but you could have other jobs running, I guess
11:10:31 <zmbmartin> Looking for some help on this error. Not sure if this is enough code to get an idea, but if someone can look I would appreciate it -> https://gist.github.com/codedmart/fb0e08e84c395859d224#file-main-hs-L15
11:10:59 <zmbmartin> I tried using lift on line 15 but that gives me another error.
11:13:33 <Hijiri> well it says that  u <- getByToken $ T.unpack auth is type TnIO
11:13:49 <Hijiri> is there some function to lift TnIO to IO?
11:13:56 <zmbmartin> Hijiri: Right? This is where I get lost.
11:13:59 <Hijiri> oh
11:14:04 <Hijiri> runReaderT?
11:15:47 <zmbmartin> Hijiri: like this u <- runReaderT . getByToken $ T.unpack auth
11:16:24 <Hijiri> runReaderT needs the environment in the first argument
11:16:43 <Hijiri> so u <- runReaderT env . getByToken $ T.unpack where env :: TnConfig
11:17:04 <Hijiri> what's the type of Middleware?
11:17:12 <Hijiri> I mean, is it a type synonym?
11:18:16 <zmbmartin> Hijiri: Probably it is part of Network.Wai
11:19:23 <sinelaw> is there a relation between strong normalization and turing completeness?
11:19:45 <cryzed> I'm relatively new to Haskell and wrote this: http://lpaste.net/113339. Intended use is to simply being able to remove a single element at a certain index from an array. Is this a good/efficient/idiomatic way to do it?
11:20:39 <josephle> sinelaw: well, what is the definition of strong normalization that you're using?
11:20:40 <Hijiri> so yeah, you need to use runReaderT
11:20:46 <Hijiri> but why are you binding the result to u?
11:21:01 <Hijiri> it doesn't look like it's used anywhere
11:21:13 <sinelaw> cryzed, [(thing, index) | (thing, index) <- zip things [0..length things]]
11:21:21 <sinelaw> can be simplified
11:21:30 <zmbmartin> Hijiri: I haven't got that far yet.
11:21:32 <cryzed> sinelaw, can you give me a hint?
11:21:44 <albeit> sinelaw, cryzed: Or just "zip things [0..]"
11:21:56 <Hijiri> ok
11:21:58 <dgpratt> was just looking over https://github.com/nikita-volkov/hasql/blob/master/demo/Main.hs and I noticed something weird...
11:21:59 <cryzed> ah, since it will just be an infinite list?
11:22:00 <sinelaw> albeit, the idea was to lead him/her to it :0
11:22:00 <zmbmartin> Hijiri: TnConfig takes a few args though so that gives me errors as well.
11:22:12 <albeit> sinelaw: Oh my bad ha
11:22:13 <sinelaw> cryzed, what does the list comprehension do?
11:22:21 <dgpratt> what's going on with this type declaration? rows :: [(Int, Int)] <- H.tx Nothing $ H.list $ [H.q|SELECT * FROM a|]
11:22:23 <cryzed> sinelaw, which?
11:22:26 <Hijiri> well put it in parens then, or use a let/where binding or something
11:22:28 <cryzed> sinelaw, the one in enumerate?
11:22:28 <dgpratt> am I just being dense?
11:22:30 <sinelaw> the one for enumerate
11:22:31 <sinelaw> yes
11:22:49 <Hijiri> parens around the TnConfig constructor + args
11:22:57 <cryzed> it creates a tuple with index, element. SO for example "hello" = (0, "h"), (1, "e")
11:22:57 <cryzed> etc.
11:23:01 <dgpratt> it looks more like a dependent typing sort of type
11:23:03 <sinelaw> josephle, wikipedia: ", if every sequence of rewrites eventually terminates to an irreducible term "
11:23:24 <dgpratt> oh, nvm
11:23:26 <sinelaw> cryzed, what does the "zip" do
11:23:30 <dgpratt> I am being dense
11:23:31 <albeit> cryzed: You may have the tuple order reversed
11:23:41 <pharpend> cryzed: Here's a (marginally) more idiomatic way - http://lpaste.net/113341
11:23:42 <cryzed> I have
11:23:44 <sinelaw> josephle, this: http://en.wikipedia.org/wiki/Normalization_property_%28abstract_rewriting%29
11:23:52 * hackagebot gitit 0.10.6 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.6 (JohnMacFarlane)
11:23:53 <josephle> sinelaw: of course, the same wikipedia article also has the answer of to your question ;)
11:24:00 <josephle> *answer to your question
11:24:01 <cryzed> and sinelaw it uhm creates those kind of tuples?
11:24:06 <sinelaw> oh oops. search is my friend :)
11:24:09 <sinelaw> josephle, hah.
11:24:22 <sinelaw> cryzed, so why do you need both the zip and the comprehension?
11:24:28 <cryzed> albeit, I did yes, thank you
11:24:31 <pharpend> cryzed: that's not a good function, however, because if the index is not there, the list is returned as-is (maybe that's what you want).
11:24:50 <zmbmartin> Hijiri: I don't have the params for TnConfig at this stage?
11:25:01 <zmbmartin> I just want the user out of it.
11:25:07 <cryzed> pharpend, that case is not of importance for now, but I'll keep it in mind thank you
11:25:11 <sinelaw> josephle, i'm ridiculous. but then my question is - since System F is strongly normalizing, isn't also System Fw and by extension...haskell?
11:25:12 <Hijiri> well how would you run getByToken without the TnConfig?
11:25:43 <cryzed> sinelaw, because I don't see any other way to distribute the values from both lists to a tuple
11:25:59 <sinelaw> cryzed, look to the types (in haskell that's always a good idea)
11:26:02 <Hijiri> It's Reader TnConfig m (m might be IO, I don't know the definition), so you need a TnConfig to run it
11:26:02 <zmbmartin> Hijiri: This all works fine within the context of scotty but Middleware is outside of scotty so maybe I need a db call outside of scotty then.
11:26:05 <josephle> sinelaw: so system F is definitely not turing complete without some enhancements
11:26:11 <pharpend> cryzed: either way, this is probably better - http://lpaste.net/113342
11:26:17 <sinelaw> josephle, obviously not - is it because of recursion? what's the name for "System F + recursion" ?
11:26:39 <josephle> sinelaw: interestingly, you only need iso-recursive types to get recursion
11:26:43 <sinelaw> cryzed, look to the types (always helps in haskell)
11:26:50 <sinelaw> @type \things -> zip things [0..length things]
11:26:51 <lambdabot> [a] -> [(a, Int)]
11:27:14 <pharpend> @@ sinelaw @type \things -> zip things [0..]
11:27:15 <lambdabot>  sinelaw (Num b, Enum b) => [a] -> [(a, b)]
11:27:17 <sinelaw> cryzed, ^^ so the "zip" is already what you want. the list comprehension is the identity function almost
11:27:23 <Hijiri> maybe
11:27:30 <cryzed> oh...
11:27:31 <cryzed> damn
11:27:32 <cryzed> of course
11:27:32 <sinelaw> @type \things -> [(thing, index) | (thing, index) <- zip things [0..length things]]
11:27:33 <lambdabot> [t] -> [(t, Int)]
11:27:43 <cryzed> wait let me see if I actually understood
11:27:44 <zmbmartin> Hijiri: Just to confirm I need TnConfig with params to runReaderT?
11:27:47 <Hijiri> I don't know anything about TnConfig, so I can't tell you anything about how to get one
11:27:48 <pharpend> sinelaw: that,s a little better imo because of brevity
11:28:09 <Hijiri> zmbmartin: do you understand monad transformers and ReaderT?
11:28:10 <cryzed> sinelaw, thank you so much -- it seems obvious in hindsight
11:28:12 <sinelaw> pharpend, sure, the issue here is the redundant use of list comprehensions
11:28:15 <cryzed> zip [0..] things is enough
11:28:17 <pharpend> sinelaw: aye
11:28:20 <josephle> sinelaw: so Haskell's (and SML/Ocaml's) version of System Fw is enhanced with recursive types
11:28:24 <zmbmartin> Hijiri: Not so well yet :)
11:28:31 <Hijiri> You should try to grok it
11:28:37 <Hijiri> but you do need a value of type TnConfig
11:28:41 <pharpend> sinelaw: I posted a solution that does a decent job (IMO) of handling out-of-bounds indeces
11:28:48 <Hijiri> you should know what you're typing
11:28:51 <sinelaw> josephle, true, but it would have been enough to support only recursive values
11:28:55 <sinelaw> for turing completenes..
11:28:57 <sinelaw> josephle, no?
11:29:09 <Hijiri> if you don't know what your typing means you should try to learn it
11:29:13 <cryzed> sinelaw, any suggestions regarding the dropAt function that was in the same paste? (Except out-of-bounds checking)
11:29:33 <josephle> sinelaw: of course you could just have fix be a primitive expression, and that's enough to get Turing Completeness
11:29:43 <Hijiri> The Reader monad and the ReaderT monad transformer represent operations where you have a read-only value to work with
11:30:04 <Hijiri> TnIO here is ReaderT TnConfig IO, which means that value is a TnConfig
11:30:15 <pharpend> cryzed: ffr, the way to do out-of-bounds checking is with guards and the Either type
11:30:19 <Hijiri> so you need to provide a TnConfig for it to run
11:30:23 <zmbmartin> Hijiri: OK I will dig more into it. Thanks!
11:30:24 <karshan> Hey is it possible to write generic string functions like f :: (Data.String.IsString a) => a -> a. because there isn't a toString in IsString. I could use show, but show adds \" around the string
11:30:29 <Hijiri> np
11:30:33 <sinelaw> cryzed, look at pharpend's link
11:30:39 <cryzed> pharpend, thank you
11:30:56 <cryzed> ah I found it now
11:30:56 <pharpend> np
11:30:59 <cryzed> thanks pharpend!
11:31:43 <pharpend> I might not be remembering the convention correctly, but IIRC the Left value is if the computation failed, and the Right value is if the computation succeeded.
11:31:51 <sinelaw> true
11:32:17 <pharpend> okay, mine is a bit passive-agressive, because it just sends back the list with a different constructor
11:32:26 <pharpend> typically you put an error message there
11:32:42 <cryzed> pharpend, the advantage here being that it just aborts after the index was dropped
11:32:46 <cryzed> instead of iterating over the rest, right?
11:32:48 <sinelaw> josephle, is there a name for system F + fix (or equivalent) ? seems like a basic construction
11:34:23 <pharpend> cryzed: http://lpaste.net/113342 <- updated it, it now sends back an error
11:34:57 <pharpend> cryzed: yeah
11:35:05 <josephle> sinelaw: I don't know of a name. People just do System F + {list of extensions} as far as I know
11:35:11 <cryzed> pharpend, thank you so much :)
11:35:19 <sinelaw> ok
11:35:29 <pharpend> cryzed: there's a way to make it more efficient, one second
11:38:15 <BMeph> Isn't that one of the list comprehensions: [y | x <- list] ==> map (\x -> y) list
11:38:19 <sinelaw> if you skip bounds checking, something like:
11:38:20 <sinelaw> dropAt n [] = []
11:38:20 <sinelaw> dropAt n (x:xs) = if n == 0 then rest else x : rest
11:38:21 <sinelaw>     where rest = dropAt (n-1) xs
11:38:43 <sinelaw> should be much more efficient
11:39:16 <lpaste> pharpend pasted “More efficent dropAt” at http://lpaste.net/113346
11:39:29 <pharpend> sinelaw: http://lpaste.net/113346
11:39:54 <BMeph> sinelaw: Shouldn't that be "dropAt 0 (_:xs) = xs"? :)
11:40:33 <BMeph> sinelaw: Otherwise, you're going to be dropAt'ing negative indices..
11:41:23 <cryzed> wow this seems rather advanced for me yet. But I'll keep it FFR
11:42:17 <pharpend> Mine still takes O(n+1) steps, but they are faster steps
11:43:21 <lpaste> pharpend revised “More efficent dropAt”: “No title” at http://lpaste.net/113346
11:43:36 <jle`> O(n+1) is O(n)
11:44:23 <pharpend> cryzed: my new thing uses the Vector type, which is more efficient than normal list.
11:44:26 <pharpend> hmm
11:44:31 <cryzed> :)
11:44:53 <pharpend> Mine just cuts up to right before the point, then cuts right after the point on, and then stitches the two together
11:45:35 <pharpend> If (Vector a, Vector a) would be an acceptable return type, I could make it O(2)
11:45:53 <pharpend> the thing that takes so long is concatenating the lists
11:46:06 <exio4> O(2) = O(1)
11:46:20 <armlesshobo> O(k)
11:46:28 <lf94> all hail lambdas
11:48:08 <sinelaw> BMeph, as I said "if you skip bounds checking". but yeah.
11:53:50 <shapr> I still wish I had a good solid Haskell framework for generating Arduino code.
11:54:03 <dmj`> shapr: you should write one
11:55:15 <shapr> dmj`: there are many things I could write that would improve the world, I hope to get around to all of them at some point :-)
11:56:03 <dmj`> shapr: just write what will improve your life, and odds are it will improve someone elses, o/w its hard to find motivation
11:56:16 <zmbmartin> Hijiri: you were right. I had the params backwards though. I got it working but I still need to get a better understanding. Thanks again!
11:56:40 <shapr> dmj`: truly
12:04:42 <xintron> I just gave hayoo a go and what was surprising was that it did search methods across packages, unlike what hoogle does. Is this configurable for hoogle (cli) to get the same functionality?
12:12:58 <dmj`> Fuuzetsu: ping
12:13:30 * YurasS is looking for Haskell developer from Belarus, Ukraine or Russia for remote full time job
12:18:34 <joe9> Is it possible to have a list of functions as this: [(a -> b), (b -> c), (c -> d)]?
12:18:47 <vanila> joe9, not a list but you can create a GADT that does that
12:18:48 <jle`> joe9: is that a type?
12:18:50 <joe9> basically, functions returning different types.
12:18:52 <vanila> data Thrist a z where
12:18:55 <vanila>  Nil :: Thrist a a
12:18:55 <jle`> are you missing parentheses
12:19:04 <jle`> [((a -> b), (b -> c), (c -> d))] ?
12:19:07 <vanila>  Cons :: (a -> b) -> Thrist b z -> Thrist a z
12:19:11 <jle`> a list of tuples of functions?
12:19:18 <vanila> Now you can do e.g.
12:19:24 <vanila> Cons f (Cons g (Cons h Nil))
12:19:37 <vanila> where f :: a -> b, g :: b -> c ; h :: c -> d
12:19:42 <vanila> and it will have type Thrist a d
12:20:01 <joe9> vanila, with a gadt, you are restricted to a certain number of elements ,correct? I want to have a list of functions.
12:20:43 <jle`> do you mean the length of the list...? no, that data type can have an unbounded amount of elements
12:20:45 <josephle> in this case the gadt doesn't influence the size of the list
12:20:54 <vanila> joe9, you can make the list as long as you like - there's no limit
12:21:10 <vanila> you can also write a "compose :: Thrist a b -> (a -> b)"
12:21:12 <vanila> recursively
12:21:23 <joe9> oh, got it. Thansk.
12:21:39 <Fuuzetsu> dmj`: what's up
12:22:06 <dmj`> so, you see how the hedis docs say, "The hedis package" at the top
12:22:07 <dmj`> http://hackage.haskell.org/package/hedis
12:22:20 <Fuuzetsu> yes
12:22:24 <dmj`> it strips the version number out of it
12:22:27 <dmj`> mine says, "stripe-haskell-0.1.0.0: Stripe API for Haskell"
12:22:30 <dmj`> which is ugly
12:22:35 <dmj`> how do I remove the 0.1.0.0
12:22:47 <Fuuzetsu> that page is generated by Hackage, not Haddock
12:23:29 <Fuuzetsu> so if you upload your package then it should look nice, I think
12:23:34 <Fuuzetsu> upload a candidate and see I guess
12:23:43 <dmj`> Fuuzetsu: you're right
12:23:50 <dmj`> intellesting
12:24:22 <Fuuzetsu> FTR there's #haddock where I'm less likely to miss a ping if I'm not around
12:26:19 <dmj`> ah ty
12:26:32 <dbushenko> hi all!
12:26:50 <success> So there is micropython to run Python on microcontrollers, what about uHaskell?
12:27:00 <geekosaur> jhc?
12:27:09 <geekosaur> ghc's a bit much for embedded
12:27:09 <success> Would it be possible to run a perhaps smaller variant of haskell on a micro controller?
12:27:23 <dbushenko> can anyone explain why cabal can't find module  src/controllers/home.hs when I import it from src/main.hs like this: import Controllers.Home (home, login) ?
12:27:23 <geekosaur> @where jhc
12:27:23 <lambdabot> http://repetae.net/john/computer/jhc/
12:27:39 <dbushenko> I have this line in cabal-file: hs-source-dirs:      src
12:28:05 <tremon> dbushenko: should that be Home.hs or are you on windows?
12:28:33 <dbushenko> tremon: yes, I'm on windows most of the day, except when I get home...
12:28:50 <dbushenko> I need to rename and have a look...
12:29:40 <dbushenko> tremon, thanks!
12:29:43 <dbushenko> it worked!
12:30:55 <success> geekosaur, so would it be feasible to port jhc do for example AVR 8 bit micro controllers? maybe that to small bit 32 bit ones?
12:32:41 <geekosaur> jhc produces ANSI C and includes the runtime. it's written in ghc so you can't really run it on the microcontroller but you can output to C and compile that for (or on if it has a compiler) the microcontroller
12:32:49 <adarc> anyone have a sec & want to help me out with a sandbox issue i'm having? basically, I have two repos: https://github.com/adarqui/Cron and https://github.com/adarqui/Cron-Sched .. if you were to clone Cron-Sched & run "make", it sets up the sandbox, init/updates my git submodule (deps/Cron), adds deps/Cron via cabal sandbox add-source deps/Cron and then run cabal install etc.. So, the problem i'm having is: I can build Cron fine by itself.. however, when I attempt to
12:33:14 <adarc> that error is happening inside of the Cron build but.. like i said before, it doesn't happen when I compile Cron indepdendently..
12:33:41 <geekosaur> there's also embedded solutions for even tighter spaces, for example use the atom package to build bare-metal microcontroller programs
12:34:01 <jonass> hi, is there a function like intersperse that also adds before and at the end like, intersperse '-' [1,2] => [-,1,-,2,-]
12:34:13 <geekosaur> (atom is essentially a dsl for microcontroller/embedded programming)
12:35:11 <adarc> dcoutts: any idea why that would be happening? it's similar to what I was experiencing earlier with the cabal-meta behavior
12:35:36 <stephenmac7> Anyone have any experience with dependency resolution?
12:37:03 <hexagoxel> xintron: default hoogle does search a specific set of packages, i think. have you read http://www.haskell.org/haskellwiki/Hoogle#Database_Creation ?
12:39:17 <dmj`> stephenmac7: you mean like, how to fix cabal hell
12:39:42 <stephenmac7> dmj`: No, _make_ something like cabal
12:39:48 <adarc> ya i'm in some cabal hell myself
12:39:48 <adarc> :D
12:42:16 <dmj`> stephenmac7: like build a cabal replacement?
12:42:34 <stephenmac7> dmj`: No, I'm making a package manager for something else
12:43:08 <dbushenko> what does the claim mark mean before the type declaration like this: firstName  :: !Text ?
12:43:18 <stephenmac7> But it needs to have dependency resolution and I can't quite figure out how to resolve those dependencies
12:43:45 <stephenmac7> I can't find anything online because all the information is on using package maangers, not developing them
12:44:01 * hackagebot drawille 0.1.0.5 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.5 (yamadapc)
12:44:53 <edlinde> is there a good video for Monads?
12:45:04 <edlinde> like an intro to Monads but goes a bit deeper into it
12:45:07 <yukko> dbushenko it's a bang pattern, it means that it's strictly evaluated
12:45:18 <vanila> edlinde, monad monads or haskell mondas?
12:45:21 <vanila> monads*
12:45:23 <dbushenko> so may I use it without bang?
12:45:35 <edlinde> vanila: is there a big difference?
12:45:52 <yukko> removing it might have unforeseen consequences but yes it will probably work without it
12:46:00 <edlinde> vanila: eventually I have to use monads in scala too.. but I think I find it easier to understand in Haskell due to the type system
12:46:03 <vanila> i feel like there is - not everyone agrees
12:46:22 <vanila> well  i think you would be fine to just go straight into it in scala
12:46:45 <edlinde> nah in scala the monads aren’t explained that well
12:46:52 <jle`> edlinde: there is a pretty big difference i think between understanding monads in math and practically using them in haskell
12:47:12 <jle`> but in any case i don't think that "learning monads" is that big of a deal
12:47:25 <jle`> i don't think it's really necessary to understand monads
12:47:36 <jle`> it's important to understand your types, of course...
12:47:38 <edlinde> jle`: really?
12:47:39 <rai> what does forall b a. mean? I've seen it around but not in LYAH so far
12:47:41 <jle`> IO is important to understand
12:47:44 <foreignFunction> stephenmac7: well, don't you just recursively collect all dependencies into a list, and then sort it so that dependees are processed before dependents?
12:47:45 <jle`> Maybe is important to understand
12:47:52 <jle`> but they're not important because they are monads
12:47:56 <jle`> they're important just because they are useful
12:48:08 <edlinde> yeah but if you got to write your own Monads?
12:48:12 <jle`> they're ont useful because tehy're monads...they're useful because they're useful
12:48:17 <edlinde> then I am sure it would save you a lot of code right?
12:48:23 <jle`> write your own monads?
12:48:24 <yukko> rai generally in Haskell it is used for existential quantification
12:48:30 <jle`> what do you mean?
12:48:31 <stephenmac7> foreignFunction: Yes, but what happens if there are multiple packages which can provide what's needed, or two things conflict and you have to find another solution?
12:48:34 <dbushenko> yukko, thanks!
12:48:37 <jle`> data Maybe a = Nothing | Just a
12:48:44 <jle`> i just wrote my own monad :)
12:48:48 <rai> yukko: can you explain what that means?
12:48:53 <edlinde> yeah like if you were designing your own library or API.. you probably would like to create a Monad?
12:48:53 <exio4> nah, that is just a datatype
12:48:54 <stephenmac7> In this case, the order of installation doesn't make any difference
12:48:55 <foreignFunction> stephenmac7: ask the user. Or crash.
12:49:01 <exio4> you need the implementation of return and >>= jle`
12:49:02 <jle`> edlinde: you would need to create a type
12:49:04 <jle`> a data type
12:49:15 <jle`> exio4: that's writing the monad instance
12:49:19 <stephenmac7> foreignFunction: It'd be nice if it was a little smarter than that...
12:49:34 <edlinde> I found this on youtube —> https://www.youtube.com/watch?v=b0EF0VTs9Dc
12:49:36 <exio4> damn
12:49:39 <jle`> edlinde: you would probably need to write your own types
12:49:39 <jonass> anyone?  is there a function like intersperse that also adds before and at the end like, intersperse '-' [1,2] => [-,1,-,2,-]
12:49:40 <foreignFunction> Or add extra logic to solve that, which is not exactly relates to dependency management.
12:49:40 <jle`> for your library
12:49:43 <edlinde> but its using examples from java script… so not fun
12:49:47 <exio4> utf8 characters don't work under windows, yet they do under linux
12:49:53 <exio4> (using hsSDL2-ttf)
12:49:56 <jle`> edlinde: and your types might offer a monadic interface
12:50:00 <edlinde> jle`: ok I get that I need to define my own types
12:50:07 <edlinde> ok
12:50:12 <jle`> so understand monads isn't really useful
12:50:17 <jle`> understanding how to make useful types is useful
12:50:24 <yukko> rai well "forall a. a" basically means that a must be a value that inhabits every single type, which isn't very useful (the only thing that qualifies for this is something like "undefined" or "error")
12:50:27 <edlinde> nevertheless I would like to understand monads a bit better
12:50:35 <edlinde> so that I can write an interface for it
12:50:38 <foreignFunction> *does
12:50:48 <stephenmac7> edlinde: http://learnyouahaskell.com/a-fistful-of-monads
12:50:54 <jle`> edlinde: an interface for your type, you mean?
12:51:00 <edlinde> yes
12:51:10 <yukko> but sometimes people use existential types to restrict types inside of data definitions to certain typeclasses
12:51:34 <stephenmac7> foreignFunction: Would you, by any chance, know of some resource that outlines that "extra logic?
12:51:38 <stephenmac7> *"?
12:51:59 <jle`> rai: imagine a function that takes a ([a] -> Int), like `length`, and applies it to two items in a tuple
12:52:01 <foreignFunction> stephenmac7: ahha! So that is your actual question.
12:52:10 <jle`> rai: foo f (x, y) = (f x, f y)
12:52:13 <stephenmac7> foreignFunction: Was I too vague?
12:52:16 <jle`> rai: can you think about what type foo must be?
12:52:21 <yukko> so ie you can do something like data Heterogenous a = forall a. Show a => Heterogenous a, and then whenever you take a value out of a Heterogenous constructor, you know it'll be in the Show typeclass
12:52:39 <jle`> rai: where x :: [a], b :: [b]
12:52:48 <foreignFunction> stephenmac7: but no, and I don't think there is one. It's too dependent on specifics of what you're doing, I reckon.
12:52:57 <jle`> er, y :: [b]
12:53:20 <stephenmac7> foreignFunction: Okay. I guess it's time to sit for an hour or two with paper and pencil...
12:54:04 <jle`> yukko: um, i don't think that works
12:54:23 <foreignFunction> stephenmac7: also keep in mind that most real-world package managers use beforementioned approach of asking-the-user-or-crashing-or-both.
12:54:27 <jle`> oh wait, it does
12:54:29 <jle`> nvm :)
12:54:31 <fritz269> whats paper?
12:54:45 <stephenmac7> foreignFunction: The package manager on my system doesn't...
12:54:48 <stephenmac7> pacman
12:55:04 <jle`> yukko: but it doesn't really give you heterogeneous lists, because you are still parameterizing over a
12:55:11 <stephenmac7> I'm pretty sure apt-get and cabal also try to resolve first
12:55:20 <jle`> yukko: so you can't have a list of different showable types that way
12:56:40 <foreignFunction> stephenmac7: I use pacman too. When it encounters two packages, which both satisfy the dependency and both aren't installed, it asks the user.
12:56:45 <yukko> jle` that would be true if you had a list l :: [forall a. Show a => a] but since it's inside the constructor for Heterogenous, you can have different types inhabit the constructors in [Heterogenous]
12:57:06 <jle`> yukko: that's not well-kindeed according to your onstructor
12:57:15 <stephenmac7> foreignFunction: That's a case where it would, unless one of those conflicts with a package that's already installed or will be installed
12:57:27 <stephenmac7> Then it will pick the other package
12:57:37 <jle`> yukko: you can't have a (* -> *) list
12:57:48 <stephenmac7> If both conflict, it will try to find another path, and if none can be found, it crashes
12:57:57 <stephenmac7> Or "exits gracefully"
12:58:17 <rai> jle`: not sure
12:58:24 <jle`> rai: give it a shot :)
12:58:52 <yukko> jle` oh whoops, the a shouldn't be on the left side of the equality
12:58:56 <athan> Does the simply typed lambda calculus automatically include hindley-milner polymorphism and type inference, due to the fact values & functions in the STLC simply declare terms & apply them to each other?
12:58:58 <jle`> yeah, that sounds better
12:59:01 <yukko> it should be data H = forall etc...
12:59:47 <foreignFunction> stephenmac7: oh, didn't know that. But then, it means you know what your package manager should do too in such cases. Implementing this shouldn't be too hard, even without a textbook.
13:00:13 <vanila> athan, it does not have polymorphism
13:00:16 <stephenmac7> foreignFunction: It'll just take some thinking, I guess.
13:00:29 <stephenmac7> I'm trying to figure it out on paper now.
13:00:54 <athan> vanila: can you make terms for types?
13:01:07 <vanila> athan, I don't understand what you mean exactly?
13:01:38 <foreignFunction> stephenmac7: well, when programming wouldn't require thinking, it would be the end of programming, I reckon.
13:02:02 <athan> vanila: I'm not quite sure either haha. Maybe something like `a :: A, b :: A -> B, b a :: B`
13:02:02 <stephenmac7> foreignFunction: You can get away without thinking for the most part in many types of programming
13:02:26 <vanila> certainly b a :: B is valid in that context
13:02:34 <foreignFunction> stephenmac7: THE END IS NEAR °д°
13:02:51 <athan> vanila: can you make type aliases in it? Or does that really matter?
13:03:01 <stephenmac7> No, just the beginning of an age where most programmers are only interested in making shallow websites
13:03:09 <vanila> type aliases aren't part of the calculus but you can do that if you want
13:03:23 <athan> vanila: Thank you tons :)
13:04:07 <athan> vanila: Oh one last thing, wikipedia says that it's "stronly normalizing" - does it just reference eta expansions?
13:04:15 <athan> er, is it referencing etas?
13:04:33 <vanila> athan, it probably means strongly normalizing under beta reduction
13:04:47 <vanila> strongly normalizing itself means that every reduction terminates with the same value
13:05:08 <athan> vanila: Oh, wow I had the wrong impression
13:05:22 <jp_rider> I see many resources that say Template Haskell can be used to access private variables, but no explanation how it can be done. Does anyone know how to do this?
13:05:36 <benzrf> jp_rider: private variables?
13:05:53 <rai> jle`: i have no clue. it clearly takes a function that has as a parameter some type that is compatible with [a] and [b] but i don't know how to express that
13:05:55 <benzrf> vanila: what about bottom, though
13:05:59 <athan> vanila: it has nothing to do with a smaller input, like structural recursion?
13:06:05 <athan> s/input/output
13:06:10 <benzrf> vanila: some expressions reduce to bottom or not, depending
13:06:37 <josephle> the context that vanila is talking in is Simply Typed Lambda calc
13:06:43 <vanila> athan, there's some kind of a relationship between these things
13:07:09 <indiagreen> benzrf: maybe ne means that TH can be used to access things not exported from a module? “module-private” variables/functions, in this case
13:07:28 <vanila> athan, in particular if the relation |> is strongly normalizing i.e. chains A |> B |> ... |> Z like this always terminate (with the same value). Then in a sense you can say Z is smaller than A
13:07:41 <jp_rider> yea basically not exported
13:07:44 <jle`> rai: it's kind of like foo :: ([a] -> Int) -> ([b], [c]) -> (Int, Int), right?
13:07:54 <indiagreen> jp_rider: see this example: https://github.com/dterei/SafeHaskellExamples/tree/master/thReify
13:07:56 <jle`> rai: except you want to be able to say that that function can take a list of *any* `a`.
13:08:05 <jle`> rai: that function is supposed to work for *all* possible a's
13:08:09 <jle`> there are some functions like that...
13:08:12 <jle`> like, `length`
13:08:16 <jle`> there are some functions that aren't like that
13:08:18 <jle`> like, `sum`
13:08:21 <vanila> athan, the term itself might be larger in number of characters it takes to write, or some other measure though
13:08:43 <jle`> rai: so you want to be able to say, "give me a funtion like `length`, that an turn a list of anything into an Int, and not a function like `sum`, which can only work on some `a`'s."
13:08:46 <jle`> rai: that's what forall is for
13:09:00 <jle`> foo :: (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)
13:09:14 <jle`> that's what the "forall" "says"
13:09:22 <jle`> that that [a] -> Int has to work for *any* `a`
13:09:48 <athan> vanila: Hmm, okay. Thank you again :)\
13:10:01 <rai> not having forall a. then would mean?
13:10:33 <zeitgeist> hi guys, im trying to get the biggest prime number that's smaller than a certain number ... here's my code: http://pastebin.com/sfpKkipY, but it doesn't work because the last function in "smaller" won't finish. i know why - but i'm not sure how to fix it
13:10:45 <benzrf> wait, so stlc is total?!
13:11:08 <jle`> rai: hm, i don't quite understand that question
13:11:10 <jle`> oh
13:11:20 <josephle> benzrf: yep. You'd need to enhance it with fix or recursive types in order to make it non-total
13:11:24 <jle`> not having forall a: foo :: ([a] -> Int) -> ([b], [c]) -> (Int, Int)
13:11:37 <jle`> that would mean that that foo is instantiated to be of one specific `a`
13:11:45 <josephle> actually, you'd need polymorphism and recursive types for non-totality I think
13:11:57 <jle`> as in, you can call foo with any function that can take a list of whatever type it wants and turns it into an int
13:11:59 <vanila> zeitgeist, you could rearrange things a little to program this nicely
13:12:02 <jle`> like sum :: ([Int] -> Int)
13:12:08 <vanila> zeitgeist, shall I show you what i mean?
13:12:14 <jle`> `a` is restricted to be one specific type
13:12:18 <jle`> for each instane of `foo`
13:12:18 <rai> ok i see
13:12:48 <zeitgeist> vanila: yes please
13:12:49 <jle`> rai: and because of that, you can't apply it to both [b] and [c]
13:12:55 <jle`> rai: because it can only take one type
13:13:11 <jp_rider> indiagreen: cool thanks
13:13:17 <dmj`> does anyone know how to put "->" in the description section of a cabal file where code is being specified? Escaping -/> or -//> doesn't seem to work
13:13:23 <rai> i think i get it
13:13:25 <jle`> in fact, you can't even apply it to the [b], because a isn't guarunteed to be b
13:14:05 <rai> does haskell denote this property somehow when i use :t
13:14:13 <jle`> what property?
13:14:19 <jle`> that a function can work for any `a`?
13:14:19 <vanila> zeitgeist, like this might be a bit more efficient too: http://lpaste.net/113351
13:14:22 <rai> yea
13:14:23 <jle`> it's actually implicit
13:14:30 <jle`> :t length
13:14:31 <lambdabot> [a] -> Int
13:14:38 <jle`> every "top-level" type signature has an implifit forall a.
13:14:43 <jle`> so length :: forall a. [a] -> Int
13:14:52 <jle`> id :: forall a. a -> a
13:15:16 <jle`> foo :: forall b c. (forall a. [a] -> Int) -> ([b],[c]) -> (Int, Int)
13:15:29 <jle`> i'm not sure if you can get ghci to show it explicitly
13:15:41 <jle`> oh
13:16:11 <zeitgeist> vanila: nice, i'm gonna try that :)
13:16:25 <vanila> good luck & feel free to post progress
13:16:32 <zeitgeist> vanila: thanks for now, i will :)
13:17:47 <rai> jle`: what if a appeared multiple times in the signature, would it have to be the same type always
13:18:10 <Bubblegum> Hi, may I ask for directions regarding a problem in defining a serial expansion?
13:18:21 <jle`> rai: if they are in the same scope, yes
13:18:27 <jle`> like in the type signature of `id`
13:18:38 <jle`> but in the type signature of `foo`, the "forall a." creates a little mini-scope inside the parentheses
13:18:52 <jle`> it's kind of like shadowing
13:19:09 <vanila> Bubblegum, yes
13:19:16 <jle`> so foo :: forall a b. (forall a. [a] -> Int) -> ([a], [b]) -> (Int, Int)
13:19:25 <jle`> the `a` inside the first parameter and the `a` outside are different
13:19:38 <jle`> inside the (forall a. [a] -> Int), the `a` is shadowed
13:19:46 <jle`> it's kind of like
13:19:54 <jle`> > let foo x = (\x -> x + 2) x in foo 5
13:19:55 <lambdabot>  7
13:21:39 <lpaste> Bubblegum pasted “sumlist” at http://lpaste.net/113353
13:22:26 <Bubblegum> vanila, here it comes :http://lpaste.net/113353
13:23:10 <rai> jle`: just to make sure, forall a b. is same as (forall a) (forall b) and they don't have any special relationship right?
13:23:19 <Guybrush_T> hi all - can maybe somebody link me to a resource or explain to me how i can achieve the following in a simple way: i have a list of integers and i want them printed as a string. So [1,0,1,1,0] should be printed as 10110. Is there an easy solution?
13:23:34 <vanila> Bubblegum, to check, you don't mean [(1,2),(2,3),...... (n, n+1)] do you?
13:23:37 <jle`> rai: forall a b. ... is like forall a. (forall b. ...), i think
13:23:38 <exio4> concatMap show?
13:23:44 <exio4> @type concatMap show
13:23:45 <lambdabot> Show a => [a] -> [Char]
13:23:49 <exio4> @type concatMap show
13:23:50 <lambdabot> Show a => [a] -> [Char]
13:23:52 <jle`> rai: basically the same as \x y -> .. being syntactical sugar for \x -> (\y -> ...)
13:24:00 <rai> rightright
13:24:01 <Guybrush_T> ookay
13:24:03 <exio4> oops, sorry, scrolled up and thought I didn't write it :P
13:24:21 <Guybrush_T> ill look it up thanks
13:24:21 <shiona_> > concaMap show [1,0,1,1,0]
13:24:22 <lambdabot>  Not in scope: ‘concaMap’
13:24:22 <lambdabot>  Perhaps you meant one of these:
13:24:22 <lambdabot>    ‘concatMap’ (imported from Data.List),
13:24:22 <lambdabot>    ‘BSC.concatMap’ (imported from Data.ByteString.Char8),
13:24:22 <lambdabot>    ‘BSLC.concatMap’ (imported from Data.ByteString.Lazy.Char8)
13:25:32 <Bubblegum> vanila: unfortunately it'S 1,1. I will post an img of the sum expression, just loading it up.
13:25:33 <mauke> :t map (chr . ((ord '0') +))
13:25:34 <lambdabot> [Int] -> [Char]
13:26:01 <int-e> :t intToDigit
13:26:02 <lambdabot> Int -> Char
13:26:06 <mauke> > map intToDigit [1,0,1,1,0]
13:26:07 <lambdabot>  "10110"
13:26:54 <int-e> > map intToDigit [0..]
13:26:56 <lambdabot>  "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
13:27:19 <Bubblegum> vanila: http://imageshack.com/a/img661/5996/MtJDNq.jpg
13:27:28 <benzrf> > fix error
13:27:29 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:27:30 <jle`> > map intToDigit (randomRs (0,9) (mkStdGen 10))
13:27:32 <lambdabot>  "317439548482727767826325378331948572156742798066316696732535843230783966191...
13:27:44 <mauke> > fix fail
13:27:45 <lambdabot>  ""
13:27:54 <vanila> Bubblegum, I see!
13:28:01 <jle`> > fix . const $ "no thanks"
13:28:01 <vanila> I'll write something
13:28:03 <lambdabot>  "no thanks"
13:28:11 <shiona_> > [(n, sum [1..n]) | n <- [1..5]]
13:28:12 <lambdabot>  [(1,1),(2,3),(3,6),(4,10),(5,15)]
13:28:22 <vanila> yeah just gve me a sec to write something
13:28:36 <Bubblegum> vanila: sadly, I don't.... must be very tired or not experienced enough :/
13:28:51 <glguy> > zip [1..] (scanl1 (+) [1..])
13:28:52 <lambdabot>  [(1,1),(2,3),(3,6),(4,10),(5,15),(6,21),(7,28),(8,36),(9,45),(10,55),(11,66)...
13:29:07 * hackagebot serial-test-generators 0.1.0 - Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time  http://hackage.haskell.org/package/serial-test-generators-0.1.0 (scottmurphy09)
13:30:58 <vanila> Bubblegum, like this http://lpaste.net/113356
13:31:19 <vanila> Bubblegum, oops, bugfix - that might need a reload
13:31:34 <glguy> > (\n -> zip [1..n] (scanl1 (+) [1..])) 10
13:31:35 <lambdabot>  [(1,1),(2,3),(3,6),(4,10),(5,15),(6,21),(7,28),(8,36),(9,45),(10,55)]
13:31:50 <vanila> so to call this you could use generate 3 1 0
13:35:10 <Bubblegum> vanila, thank you
13:38:50 <ocharles> Quick FFI question. Am I meant to creating new finalizer FunPtrs every time I create an object? I seem to be forced to, as the foreign wrapper to get the FunPtr for the finalizer seems to live in IO
13:39:08 <rai> jle`: hey cool. i found this by accident https://en.wikibooks.org/wiki/Haskell/Polymorphism
13:39:09 <ocharles> But it seems weird, because the finalizer is always doing exactly the same thing
13:39:28 <ocharles> (calling out to the C library's own "free" routine)
13:39:38 <jle`> :D
13:40:00 <glguy> Each time you allocate memory and want the GC to know how to free it you have to tell it
13:41:07 <ocharles> glguy: but i don't need to reallocate the finalizer function itself
13:41:36 <ocharles> obviously i have to attach finalizers to every piece of data I create, but I assume I can use the same finalizer for multiple allocations
13:42:32 <ocharles> I think I should just be importing the C library's destroy function (SDL_DestroyRenderer) as: foreign import ccall "SDL.h &SDL_DestroyRenderer" :: FunPtr (Ptr x -> IO ())
13:42:41 <ocharles> then I can certainly use the same FunPtr
13:42:57 <glguy> Yes, that's right
13:44:16 <ocharles> k, makes much more sense than what I was doing :)
13:46:15 <raphi011> vanila: got it! http://pastebin.com/F4sFwiBr
13:46:42 <vanila> that looks great
13:46:58 <vanila> something to try is run tightPrimeEmbedding 100 or so in ghci
13:47:00 <vanila> and then do it again
13:47:03 <vanila> it should be much faster the second time
13:48:19 <raphi011> vanila: yea did that already, but it seemed exactly as fast as the first time
13:48:23 <vanila> hmm
13:48:25 <vanila> maybe with a larger number
13:49:58 <raphi011> yea wow - 100000 takes ages - still hasn't finished
13:50:17 <raphi011> now it has finished, second time is instantaneous
13:53:18 <vanila> raphi011, ah great!
13:53:37 <vanila> the reason that works is because the top level definitions are not recomputed, thanks to lazy evaluation
13:59:09 <TimeToRocknRoll> heya
13:59:29 <TimeToRocknRoll> EnCt2183aee90c518f146485655742eeda6b94f091ef8183aee90c518f14648565574YZ1lVzFgPwD XnHr6T1QtCNJsQdU8yAEFCTsoYgyCKiddXVf88NfxjYgPoOMCYSptN2o8nOy13262ErPHBncrrR79Jwm ObzQbd0CQSAXCpio7DTqhaMgU9Quddzu3f7LEP4ZbS9zJqfkg+bvPA0CDXssV5FlIdvv/Yxn/6NBBvn/ QV82eI/RVUZMr+4LoVcZDGSvrvaXM7sYalnQQsjwgqx1koVey7B/xIYx1D8yoMS0rcPGuG/6TLMGbl+b Q9YTN7QKgfTmAHdpXGhjiChkb8V+Cz2froMHpACotl3IBkhZ+6EFlBi7MRIopWLbMFvDceiiZPMxkK/v 3lxZn+qx0FP3j0OHP3hlw6IY
13:59:29 <TimeToRocknRoll> anyone willing to have fun with a corrupted company..
13:59:57 <TimeToRocknRoll> x56eR/xQ7qd02wC 8uysuabk7V2X5e+b0L2vUMA==IwEmS  Decrypt it at https://encipher.it with Pass: timeToRocknRoll1337
14:00:18 <simpson> Wrong channel.
14:01:53 <pold> Hi, I've started a Haskell project (https://github.com/Pold87/haggressive) and wanted to omit duplications in the build-depends (like so: http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file). However, after running cabal build, I get an error that cabal could not find the modules Data.Vector and Data.Map in my test suite. What have I done wrong here?
14:03:13 <bernalex> what should I be using for a simple "fork with args"?
14:04:00 <cdk> bernalex: just partially apply the function, forkIO (f x y :: IO ())
14:04:16 <bernalex> cdk: yeah I meant what function. forkIO is what I'm using though, so I guess it's right
14:10:11 <albeit> pold: Which answer from that SO did you follow?
14:11:02 <pold> albeit: The first one, from Toxaris.
14:11:06 <lf94> When will Web.Site type be available? It would be great to just create one with one function call.
14:11:52 <benzrf> heh
14:13:49 <albeit> pold: I haven't done this for my cabal, but am interested. can you post your .cabal file?
14:13:53 <albeit> @where lpaste
14:13:53 <lambdabot> http://lpaste.net/new/haskell
14:14:13 * hackagebot stripe-haskell 0.1.0.0 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.0 (DavidJohnson)
14:15:27 <qsuscs> anyone got an idea how to make 2+2=5 in a crazier (and not that dumb) way? http://ideone.com/z3wGV6
14:15:38 <qsuscs> (please don’t hit me)
14:15:42 <lpaste> pold pasted “Cabal build-depends” at http://lpaste.net/113359
14:16:10 <shiona_> qsuscs: you could make your own type and write a Num instance for it
14:17:01 <qsuscs> shiona_: nothing that _I_ could, but sounds interesting
14:17:06 <albeit> pold:  You may need to add Data.Map and Data.Vector to the library exposed-modules
14:17:21 <shiona_> hmm, let me see..
14:18:03 <sivteck> > 2 L.+ 2
14:18:05 <lambdabot>  5
14:18:22 <sivteck> @undefine
14:18:22 <lambdabot> Undefined.
14:19:21 <qsuscs> whut? o_O
14:19:46 <sivteck> λ > let 2 + 2 = 5
14:19:46 <sivteck> λ > 2 + 2
14:19:46 <sivteck> 5
14:19:57 <albeit> sivteck: Is "L.+" a lens thing?
14:20:02 <zmbmartin> How do you get the readerT env not just a specific piece. Like now I use Config p _ <- ask. Can I just get Config?
14:20:07 <qsuscs> sivteck: that’s what i already did
14:20:10 <sivteck> albeit, no, in ghci
14:20:35 <sivteck> albeit, it's a lambdabot thing
14:21:02 <albeit> :t (L.+)
14:21:03 <lambdabot> Not in scope: ‘L.+’
14:21:16 <albeit> Guess not a type bot thing too
14:21:17 <sivteck> @let 2 + 2 = 5
14:21:19 <lambdabot>  Defined.
14:21:24 <phaazon> ReinH: hey, I haven’t found any way to fix my issue of earlier :(
14:21:27 <sivteck> > 2 L.+ 3
14:21:28 <lambdabot>  *Exception: L.hs:155:1-9: Non-exhaustive patterns in function +
14:21:29 <phaazon> have you thought about it?
14:21:36 <haasn> qsuscs: You could prove that 0 = 1
14:21:56 <qsuscs> haasn: how that?
14:22:04 <haasn> That's what I've been trying to figure out, too
14:23:11 <geekosaur> zmbmartin, just capture to a binding instead of to a pattern match. e.g. c <- ask
14:23:36 <qsuscs> we already collected some other examples here—mostly in C, one in php and my cheap haskell one (it’s in german, just have a look for the “Code” blocks) https://www.winhistory-forum.net/showthread.php?tid=13076
14:23:48 <pold> albeit: Thanks, I think that's it. However, I get the error "cabal: can't find source for Data/Map in src/lib, dist/build/autogen" now
14:24:16 <shiona_> qsuscs: http://ideone.com/VkWYv4
14:24:47 <zmbmartin> geekosaur: I tried that but I get this error https://gist.github.com/codedmart/e38937a82a10fee3574f
14:25:07 <shiona_> you could make any number of strange definitions for any of the operations in the instance
14:25:12 <qsuscs> shiona_: thanks
14:25:42 <geekosaur> zmbmartin: then I would expect the other one to not work either; your porblem is you're in the IO monad, not a ReaderT. perhaps show a bit more code?
14:28:09 <zmbmartin> geekosaur: https://gist.github.com/codedmart/e38937a82a10fee3574f#file-main-hs-L6
14:28:44 <albeit> pold: Hmm not sure! Maybe to try and replicate this example .cabal a bit more, maybe try moving src/lib to src-lib and src/exe to src-exe, but just a wild hope
14:28:50 <zmbmartin> Not sure if that is enough code, but I pass in TnConfig right now so I can runReaderT but I would rather get it like ln 6 if it is possible.
14:28:55 <albeit> *his example
14:29:22 <albeit> (as in rename the folders, and then rename the hs-source-dirs appropriately)
14:29:51 <phaazon> ok, I guess ReinH is away, maybe someone else here can help with my question. I have a type (data a :. b = a :. b), and I’d like to be able to transform a chain of this type (a :. b :. c :. d…) into (f a :. f b :. f c :. f d…) ; any idea?
14:29:53 <geekosaur> then I think you want to run it in a ReaderT and use liftIO to run the callback. again, would need more information/code
14:31:23 <zmbmartin> geekosaur: OK trying to see which pieces of code to paste. It is spread out right now.
14:31:54 <phaazon> I think I’m gonna ask on reddit
14:32:10 <geekosaur> well, most important is what's calling authenticate there, and what the type Middleware is.
14:32:57 <albeit> pold: Or, it might not even be reading the ", vector \n , containers" lines... not sure how how identation and comments are handled in .cabal files, but maybe move the commas to after the previous line
14:33:18 <albeit> *identation and commas
14:33:52 <albeit> pold: Can you repost the latest .cabal?
14:34:15 * hackagebot stripe-haskell 0.1.0.1 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.1 (DavidJohnson)
14:35:11 <pold> albeit: Yes, of course. I tried renaming and moving the commas but had no success
14:35:23 <zmbmartin> geekosaur: maybe can you post me to an example of what you mentioned?
14:35:37 <lpaste> pold pasted “Cabal build-depends #2” at http://lpaste.net/113361
14:36:03 <zmbmartin> geekosaur: Or I can go read more :)
14:36:56 <albeit> pold: Try removing the commas in the exposed-modules list
14:37:28 <geekosaur> well, the trivial way is you have a ReaderT TnConfig Middleware a, then you can ask the TnConfig and lift the callback into Middleware.
14:37:29 <albeit> Thats all I got, out of ideas ;)
14:38:07 <geekosaur> but I'm wondering how TnConfig relates to Middleware; maybe it's already in there and you just need to derive MonadReader when making the Middleware type?
14:38:25 <albeit> pold: I'm just trying to match up your .cabal to this one https://github.com/Toxaris/pts/blob/master/pts.cabal
14:38:29 <geekosaur> rather, deriving (MonadReader TnConfig) if the Middleware already has a ReaderT TnConfig in it somewhere
14:39:16 <zmbmartin> geekosaur: OK I dig a little more, Thanks!
14:40:11 <meretrix> How can I package up a single module and all of its dependencies into a single file that can be loaded as a library in ghci?
14:41:27 <hugo_dc> Hi everyone, I'm looking for a Haskell function to extract the Hexdigest (SHA1) from a string
14:42:15 <phaazon> ohoh
14:42:16 <phaazon> type Nat f g = forall x. f x -> g x
14:42:21 <phaazon> is this a natural transformation?
14:42:36 <phaazon> isn’t that a bit… biased?
14:43:02 <pold> albeit: Great, thanks! Unfortunately, removing the commas is not working either. Maybe it's an error in my Main.hs file in src-lib/Haggressive?
14:44:13 <josephle> phaazon: what do you mean...biased?
14:45:36 <phaazon> josephle: well, in math, a natural transformation is a functor morphism, so I guess it should involves x and y, no?
14:46:09 <josephle> what is x and y?
14:48:28 <josephle> phaazon: are x and y the "arguments" to f and g?
14:49:01 <albeit> pold: Maybe try a cabal clean, and you have done "cabal install containers vector"?
14:50:03 <albeit> pold: And shouldn't "Main.Data.Vector" be "Data.Vector" in exposed modules?
14:50:07 <albeit> I gotta run, good luck
14:50:21 <pold> albeit: Yes, I did a clean before and installed the libraries
14:50:22 <phaazon> josephle: yeah
14:50:34 <pold> albeit: Thanks again! Bye
14:50:52 <pold> albeit: Yes, that was just a wild try, will remove that again
14:50:56 <josephle> phaazon: so a natural transformation also has laws that come with it
14:51:21 <josephle> phaazon: can you guess what laws you'd need for Nat f g?
14:52:44 <phaazon> josephle: well, f :: C -> D, g :: C -> D, so the natural transformation works on (C -> D) (C -> D)
14:52:47 <phaazon> oh
14:52:52 <phaazon> ok, I guess why we can only use x
14:53:00 <phaazon> since it maps the x to the x
14:53:02 <phaazon> and y to the y
14:53:14 <phaazon> (C -> C) (D -> D)
14:55:37 <josephle> I'm not sure if I understand the (f :: C -> D) part, but you seem to get the overall idea :)
14:55:45 <phaazon> josephle: f is a functor
14:55:56 <phaazon> it maps objects from category C to objects in category D
14:55:58 <josephle> ah, so we're talking math functors
14:55:59 <josephle> ok
14:56:04 <phaazon> yeah
14:56:28 <phaazon> Cale taught me that yesterday or the day before
14:56:33 <phaazon> I’m trying to fix that in my mind :)
14:56:52 <josephle> in this case, I think f :: C -> D, g :: C -> D'
14:57:15 <josephle> no wait
14:57:26 <josephle> your original signatures are right
14:57:29 <phaazon> :)
14:57:29 <josephle> f,g :: C -> D
14:57:32 <phaazon> yeah
14:57:47 <phaazon> and nat (f,g) :: (C -> D) -> (C -> D)
14:57:47 <jle`> i am so over the whole f <$> x <*> y idiom
14:57:51 <jle`> liftA2 for lyfe
14:57:57 <phaazon> josephle: I prefer <$> and <*>
14:58:02 <phaazon> for a very simple reason: parns
14:58:04 <phaazon> parens*
14:58:15 <jle`> hi
14:58:28 <phaazon> liftA2 (,) (longArgs a b c) (longArgs2 a d b)
14:58:30 <jle`> idk, (<$>) and (<*>) seem a lot more like line noise than parens do
14:58:30 <phaazon> versus
14:58:40 <phaazon> (,) <$> longArgs a b c <*> longArgs2 a d b
14:58:42 <jle`> <$>/<*> just looks noisy
14:58:54 <jle`> after my years of haskell i have trained myself to not notice them anymore
14:58:59 <jle`> but every once in a while i become painfully aware of them
14:59:00 <jle`> and i'm like
14:59:02 <jle`> whoa
14:59:14 <phaazon> jle`: I like using them on each line as well
14:59:15 <phaazon> like
14:59:21 <phaazon> hm, wait, I have a nice example in my codebase
14:59:34 <jle`> yeah, using them line-by-line is my favorite use of (<$>) and (<*>)
14:59:39 <jle`> that's where i would normally use them
14:59:57 <phaazon> https://github.com/phaazon/photon-opengl/blob/master/Photon/Render/OpenGL/Forward/Renderer.hs#L151
15:00:21 <josephle> if only we had banana brackets, i.e. (| (,) (longArgs a b c) (longArgs2 a b d) |)
15:00:36 <zmbmartin> geekosaur: Really the authenticate (Middleware) is outside of my scotty application somewhat so am I better doing it how I am. Just passing it in?
15:00:58 <geekosaur> likely yes in that case
15:01:23 <zmbmartin> geekosaur: Or should there be one place where I am runReaderT that lifts it out so I can use what I need else where?
15:02:23 <geekosaur> does it get used anywhere else? but this is an app design question and I have no idea what your app looks like / how it is structured, so all I can really do is throw pebbles at it >.>
15:02:56 <zmbmartin> geekosaur: I get it. I mean it works how it is. I can always refactor as I learn more.
15:06:13 <meretrix> Can ghc create a single object file for my library rather than just separate files for each module?
15:08:58 <bernalex> what should I be using to get STDIN if there are no arguments?
15:09:39 <bernalex> I am doing as <- getArgs; cs <- words <$> getContents -- and the latter is wrong I assume, and then I want to do bleurgh $ if as /= [] then as else cs
15:10:55 <benzrf> bernalex: that looks fine.....
15:11:24 <bernalex> benzrf: I'm pretty sure it's not. I don't want my program to hang. I want to use it like echo lol | ./program, or ./program lol.
15:11:37 <bernalex> benzrf: right now if I do just "./program", it will hang.
15:11:53 <benzrf> bernalex: it's not hanging...
15:11:55 <benzrf> it's waiting for stdin
15:11:58 <benzrf> duh
15:12:03 <bernalex> benzrf: well yeah duh
15:12:09 <benzrf> bernalex: oh i see
15:12:15 <benzrf> do this:
15:12:16 <tremon> bernalex: don't assign as and cs in the same do block
15:12:17 <bernalex> benzrf: good lol
15:12:26 <bernalex> tremon: ok -- why?
15:12:58 <benzrf> do as <- getArgs; if not (null as) then bleurgh as else getContents >>= bleurgh . words
15:13:14 <bernalex> ohh yeah of course
15:13:19 <benzrf> duh =p
15:13:20 <tremon> every statement in a do block is a sequence point, you can't take advantage of laziness
15:13:46 <benzrf> bernalex: alternatively,
15:14:10 <benzrf> do as <- getArgs; cs <- if not (null as) then words <$> getContents else return []
15:14:15 <benzrf> neither feels quite clean
15:14:21 <benzrf> there should be a better solution for this :|
15:14:44 <benzrf> imperative languages are slightly beating our asses, guys!
15:14:58 <kadoban> Abstract it out into a separate function.
15:15:06 <EvanR> wait do is still lazy, just IO is not
15:15:09 <bernalex> benzrf: I'm doing something weird tho
15:15:17 <bernalex> benzrf: let t = if not (null as) then build as else getContents >>= build . words
15:15:21 <bernalex> omg such typefail
15:15:43 <bernalex> because uh build returns a Maybe String and this uh gives an IO String because of >>=, I guess?
15:16:29 <meretrix> Hmm.. supposedly ghci can load .a files. but it just says "ignoring unrecognized input".  Do I need to pass the .a file with some special flag?
15:16:59 <benzrf> actually much of IO is lazy
15:17:05 <benzrf> although in another sense, i suppose!
15:17:22 <bernalex> benzrf: meh. worked it out. :-]
15:17:26 <kadoban> meretrix: Maybe just add it to the module list? :m + Whatever  *guessing*
15:17:42 <bernalex> benzrf: errr
15:17:49 <bernalex> benzrf: OK worked out/ got it to typecheck / the program always hangs now
15:17:59 <benzrf> kek
15:18:02 <bernalex> as <- getArgs ; cs <- if not (null as) then words <$> getContents else return [] ; then I build cs
15:18:42 <bernalex> er
15:19:22 <bernalex> yeah all of this is just nonsense and completely wrong :-]
15:20:24 <bernalex> benzrf: I just realised I want the behaviour I thought I didn't want anyway :-P
15:20:38 <pold> I've a very simple project at https://github.com/Pold87/BadTest that is build in a sandbox. However, if I try to cabal build it, it fails with "cabal: cant find source for Data/Map in src, dist/build/autogen". Where'S the error here?
15:20:50 <parsons2> hi all, could anyone give me a hint how to print utf8 string on system console? right now I'm getting messed up encoding
15:21:46 <geekosaur> make sure your console and locale are utf8? (this is somewhat annoying on windows, I think)
15:21:55 <benzrf> bernalex: lol
15:22:06 <bernalex> benzrf: it's late here :-]
15:23:08 <parsons2> geekosaur: but what if console encoding is different, is there any hope?
15:23:45 <geekosaur> if your console encoding is not utf8 then what do you expect it to do with utf8?
15:24:21 * hackagebot postgresql-simple-sop 0.1.0.1 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.1 (glutamate)
15:24:50 <parsons2> geekosaur: first, I'd like to get the console encoding, then convert utf-8 string to that encoding, and print it
15:25:25 <geekosaur> ghc's runtime does that already. not all utf8 can be converted to e.g. an iso8859 encoding
15:25:45 <geekosaur> ghc will default to iso8859-1 if it can't figure out your encoding
15:28:47 <EvanR> @faq can haskell convert any utf8 string into iso8859-1
15:28:47 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:28:52 <parsons2> geekosaur: seems that's my ide messed up that encoding
15:29:14 <parsons2> geekosaur: tried to run in the system console and all works find, thx
15:30:20 <simon``> what's the best way to install Haskell on Mac? I am considering installing ghc and cabal through homebrew, and using a binary installer.
15:30:44 <simon``> (I have read the HaskellWiki page, but I'd like some opinions from people who use it.)
15:34:13 <fragamus> guess what sucks
15:34:32 <fragamus> conduit's CSV parser and writer
15:35:19 <EvanR> guess what sucks, CSV
15:36:12 <yukko> how can a CSV parser be bad
15:37:40 <EvanR> csv in practice has a lot of details quirks variations
15:38:48 <kadoban> Yeah, it's not a very well specified format
15:39:44 <yukko> ah
15:39:58 <EvanR> you know what also sucks, MS excel CSV import
15:40:04 <EvanR> which claims to support utf8 and doesn't
15:40:37 <Hodapp> MS Excel CSV import is a pile of shit.
15:41:03 <EvanR> that is, at least on OSX
15:41:15 <EvanR> they specifically broke it for osx
15:41:15 <Hodapp> There are a lot of "correct" ways of handling CSV, even though they differ from each other. Excel consistently picks a way that manages to just be wrong.
15:44:24 * hackagebot stripe-haskell 0.1.0.2 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.2 (DavidJohnson)
15:50:48 <simon``> EvanR: I've experienced MS Excel CSV imports on Mac, and yes, they suck.
15:51:50 <RchrdB> EvanR: IME, if you want Excel to actually work, you really want to be feeding it xlsx files.
15:52:14 <EvanR> yet people send csv files to each other
15:52:58 <RchrdB> EvanR: we have exports in work that target Excel, and all of our data has interesting unicode in it (mostly peoples' names…), and the *only* "csv" format that MS Excel reliably imports cleanly is utf-16le with tab separators and (IIRC) no BOM.
15:53:03 <simon``> I want to believe that CSV is a better format than OOXML or what they call it.
15:53:15 <EvanR> yes
15:53:21 <RchrdB> EvanR: and this is totally undocumented aside from being mentioned in some PHP webapp hosting forum six years ago.
15:53:36 <EvanR> there are complaints about it on ms forums
15:53:53 <EvanR> coincidence that utf16LE is standard on windows?
15:54:12 <RchrdB> think so
15:54:50 <RchrdB> if I had all the time in the world, I'd change all our applications to generate utf-8 CSVs for consumption by software written by grown-ups (e.g. SPSS, python's "csv" module), and I'd put in xslx exports everywhere for the Excel users.
15:55:24 <RchrdB> *ahem* that may have been overly nasty >_>
15:55:29 <pikhq> simon``: Unfortunately, CSV has a lot of utter morons using it.
15:56:42 <lpaste> pold pasted “cabal test” at http://lpaste.net/113364
15:56:54 <pold> I'm trying use cabal test, however, I get the error "could not find module Data.Vector". However my library has "build-depends: vector" and my test-suite has "build-depends haggressive (the name of my library"). Code at http://lpaste.net/113364
15:56:55 <pikhq> I mean *wow*, using a semicolon as a delimiter when your local uses comma as the decimal mark?
15:58:02 <pold> If a add vector to the build-depends of test-suite, it works, but I don't want to have the same dependencies twice. Anyone any idea?
15:58:54 <acowley> How do you explicitly export a data family instance and its constructors?
15:59:28 <kadoban> acowley: TheType(..) ?
15:59:47 <acowley> But there is no name like that
16:00:00 <acowley> I have an instance of a family T A b c d
16:00:27 <kadoban> Oh. I don't know what that is
16:00:38 <RchrdB> EvanR: just checking the BOM thing: it's utf-16le, *with* one BOM at the start, "\r\n" line separators, "\t" field separators, every field is surrounded by double-quotes, and quotes are escaped by doubling them up. (i.e. escape_for_cell s = '"' : concatMap (\c -> if c == '"' then ['"', '"'] else [c]) s ++ ['"'])
16:00:39 <acowley> So a data family named T indexed by concrete type A and type variables b c d
16:00:53 <zmbmartin> How do you go from ReaderT IO to IO?
16:01:06 <EvanR> liftIO
16:01:21 <acowley> and exporting T A b c d(..) doesn't work
16:01:56 <RchrdB> EvanR: and there's at least one hilarious condition where things blow up I-can't-remember-how if you have any one line that is longer than... I-can't-remember-how-long (16ki characters? 64ki characters?)
16:02:02 <davidthomas> zmbmartin: liftIO or runReaderT
16:02:18 <EvanR> RchrdB: dat c++ memory management
16:02:33 <davidthomas> zmbmartin: depending on whether you mean "I have something that is ReaderT IO and I need something that is IO" (runReaderT)
16:02:52 <davidthomas> zmbmartin: or "I am working in context ReaderT IO, and I need context IO" (liftIO)
16:03:14 <zmbmartin> davidthomas: Thanks!
16:03:20 <RchrdB> Quite. You don't get crashes, you get... truncation of cell data and then bits of the table end up in weird places because the commas got misconstrued?
16:03:46 <RchrdB> EvanR: short story: I _strongly_ recommend generating xlsx files if you want Excel to read them cleanly!
16:05:30 <acowley> Turns out, it's just T(..)
16:05:33 <acowley> no mention of the indices
16:06:51 <acowley> Which makes a lot of sense
16:07:29 <acowley> huzzah! Now I don't export a pattern synonym, my ghc-modi process is only using 600MB of RAM instead of 1.8GB
16:09:48 <intrados> If I want to add support for a custom element to Hakyll, is it best to do that via Hakyll itself or via Pandoc?
16:10:30 <kadoban> intrados: What do you mean by a custom element?
16:11:37 <intrados> For example, I want to be able to use the HTML5 details element. So I'd come with some syntax for that in markdown and have it translated into <details>
16:12:51 <kadoban> intrados: Yeah I think you'd have to modify the pandoc markdown parser then. Which I have a feeling isn't fun. Or I guess maybe you could do some kind of precompilation step, and run it through both?
16:13:58 <kadoban> That's probably the way I'd go, seems like it'd be pretty easy.
16:14:20 <intrados> I'm pretty unfamiliar with Pandoc. There's not good support for extending like that?
16:15:05 <indiagreen> intrados: there are filters, but the amount of syntax you can add with them is pretty limited
16:15:33 <kadoban> intrados: I've done...very little with it, but the sense I get is that it's not fun to try to add stuff like that.
16:15:43 <indiagreen> e.g. you can do something crude like transform -all lists which have “!!details” as their 1st element- into something you want
16:16:26 <intrados> Okay. I suppose I'll just go with a Hakyll pre-compiler then. Thanks all
16:17:07 <indiagreen> on the other hand, extending the parser is actually pretty easy – I could guide you thru it if you wanted
16:17:37 <begriffs> How do you extract the "version:" number from a cabal file?
16:19:28 * hackagebot xdot 0.2.4.6 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.6 (DennisFelsing)
16:19:30 * hackagebot ghc-vis 0.7.2.7 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.7 (DennisFelsing)
16:20:16 <intrados> indiagreen: It'd be actually editing the existing parser? (i.e. recompiling Pandoc)
16:20:25 <begriffs> It looks like the Cabal library exposes functions to parse a project cabal file ( http://hackage.haskell.org/package/Cabal-1.20.0.2/docs/Distribution-PackageDescription-Parse.html ), but I'm wondering if there's a way to do it from the shell.
16:21:20 <indiagreen> intrados: recompiling Pandoc is easy – it builds nicely from git without any makefiles or mumbo-jumbo
16:21:41 <indiagreen> the parser module uses parsec
16:22:34 <indiagreen> there are 2 blocks in the module, one is a list of block parsers used by pandoc, the other – inline parsers
16:22:47 <indiagreen> http://hackage.haskell.org/package/pandoc-1.13.1/docs/src/Text-Pandoc-Readers-Markdown.html#block and http://hackage.haskell.org/package/pandoc-1.13.1/docs/src/Text-Pandoc-Readers-Markdown.html#inline
16:24:15 <indiagreen> writing your own parser and sticking it one of the lists isn't hard; it might be slightly harder if your syntax interferes with e.g. syntax for lists or links or what-not, but still not that hard
16:25:05 <indiagreen> I've spent some time dabbling with Pandoc's Markdown parser and I'll be glad to help you
16:25:58 <indiagreen> s/sticking it one/sticking it into one/
16:26:18 <kadoban> (one thing to beware of is that hakyll seems to require that very specific version of pandoc currently, 1.13.1 IIRC)
16:28:06 <indiagreen> kadoban: it says on hackage that hakyll requires pandoc (>=1.12.4 && <1.14) ..?
16:28:21 <indiagreen> or is this dependency incorrect?
16:28:54 <kadoban> indiagreen: It says that, but the only one that seems to fit the rest of the dependencies every time I try is that one.
16:29:08 <benzrf> if haskell didnt have let bindings would it be possible to implement fix
16:29:23 <kadoban> indiagreen: IOW I've tried changing that (because that version of pandoc has an annoynig bug) and it can't find any matching set of deps then.
16:39:31 * hackagebot gitit 0.10.6.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.6.1 (JohnMacFarlane)
16:48:29 <mrenaud> Hey, I was wondering if it's possible to combine monads with RWS.
16:49:26 <joelteon> RWS is already one, so it should be easy.
16:49:42 <mrenaud> For example, I would like to do something like:  RWS Config (WriterT [String] IO) World Int
16:49:52 <EvanR> RWST
16:50:30 <EvanR> > return () :: RWST () () IO ()
16:50:31 <lambdabot>  Expecting one more argument to ‘GHC.Types.IO’
16:50:31 <lambdabot>  The third argument of ‘Control.Monad.Trans.RWS.Lazy.RWST’
16:50:31 <lambdabot>    should have kind ‘*’,
16:50:31 <lambdabot>    but ‘GHC.Types.IO’ has kind ‘* -> *’
16:50:50 <EvanR> blub
16:57:46 <heatsink> > return () :: RWST IO () () ()
16:57:47 <lambdabot>  Expecting one more argument to ‘GHC.Types.IO’
16:57:47 <lambdabot>  The first argument of ‘Control.Monad.Trans.RWS.Lazy.RWST’
16:57:47 <lambdabot>    should have kind ‘*’,
16:57:47 <lambdabot>    but ‘GHC.Types.IO’ has kind ‘* -> *’
16:58:38 <heatsink> > return () :: RWST () () () IO ()
16:58:39 <lambdabot>  No instance for (GHC.Show.Show
16:58:39 <indiagreen> > return () :: RWST () () () IO ()
16:58:39 <lambdabot>                     (Control.Monad.Trans.RWS.Lazy.RWST () () () GHC.Types.IO ...
16:58:39 <lambdabot>    arising from a use of ‘M44453395186931128312767.show_M44453395186931128312...
17:01:36 <hexagoxel> > runIdentity $ runRWST (return () :: RWST () () () Identity ()) () ()
17:01:38 <lambdabot>  ((),(),())
17:07:25 <bitonic> is there a known bug in the code that checks class cycles?  because 7.8.3 loops when type checking <http://lpaste.net/113369>
17:09:25 <mrenaud> I'm not sure what's going on :P
17:09:53 <bitonic> mrenaud: if you're talking to me, me neither.  I just distilled it from a fairly large piece of code
17:10:20 <bitonic> if you take out `class2` you get a reasonable error
17:14:02 <adarc> hey, just wondering how i should approach this.. i'm creating a simple timer system. It takes in a CronSchedule record for example, and based on a 'tick' it's job is to notify/fire off IO actions.. I don't want to forkIO every time, nor do I want to run the computations directly from a list of functions etc.. i'm thinking about writing to an mvar but using the nonblocking version (tryPutMVar) and the various listeners would be performing takeMVar (blocking version)
17:14:16 <hexagoxel> it loops when trying to detect loops? :)
17:14:36 <guestaccount11> I like FP Complete as an editor because of the "thumbs up/down" notification. But I prefer an editor I can use offline. Anyone know of another editor which gives such a notification and does not require an internet connection?
17:14:42 <hpc> don't be afraid to forkIO, the overhead is nothing unless you're doing it thousands of times per second or something nuts
17:14:44 <adarc> i don't want to get any events 'queued up', that's kind of why i'm thinking about just using an mvar
17:14:51 <c_wraith> adarc: you might be surprised by how nicely forkIO works
17:14:52 <benmachine> bitonic: there are known bugs, yes, let me see if I can dig one up
17:15:06 <adarc> ya, i'm not afraid of forkIO, i know it is very performant
17:15:14 <hpc> (er, hundreds of thousands per second)
17:15:20 <bitonic> benmachine: danke
17:15:31 <c_wraith> adarc: in particular, that's exactly a use case GHC's thread manager is designed for.  (hundreds of thousands of sleeping threads)
17:16:12 <benmachine> bitonic: might be https://ghc.haskell.org/trac/ghc/ticket/5722
17:17:09 <bitonic> benmachine: mhm.  I never use the functions though.
17:17:20 <adarc> so you guys think i should simply forkIO the list of computations etc, every tick?
17:17:23 <adarc> something like that?
17:17:30 <bitonic> benmachine: and it's during type checking
17:18:03 <c_wraith> adarc: until it becomes a performance problem, yes
17:18:05 <benmachine> bitonic: shrug. there are pleny more bugs on the tracker, that's the closest one I know about
17:18:10 <adarc> cool thanks
17:18:16 <bitonic> benmachine: okay.  maybe I'll just report it.
17:18:44 <bitonic> benmachine: doesn't happen in 7.6
17:18:50 <hexagoxel> bitonic: wait, you can simplify that testcase more
17:19:05 <benmachine> it's a regression? that seems definitely worth reporting
17:19:37 * hackagebot language-c-inline 0.7.7.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.7.0 (ManuelChakravarty)
17:19:42 <bitonic> hexagoxel: I tried a bit but at this point removing anything makes the problem go away
17:19:57 <bitonic> ah no.  you can remove class4
17:20:00 <bitonic> Class4
17:21:07 <adarc> ok cool, going to experiment.. thanks c_wraith & & hpc
17:22:40 <bitonic> and also TypeFam t ~ t...
17:24:10 <hexagoxel> bitonic: and the functional dependency
17:24:19 <hexagoxel> see http://lpaste.net/113371
17:24:43 <bitonic> hexagoxel: yeah you can also remove the type family
17:25:30 <hexagoxel> oh, yeah
17:25:48 <hexagoxel> bitonic: maybe ask in #ghc as well?
17:27:24 <nolrai66> Hey, are all co-monads aplicative fuctors?
17:27:47 <bitonic> hexagoxel: too late <https://ghc.haskell.org/trac/ghc/ticket/9739#ticket> :P
17:28:32 <hexagoxel> ;)
17:30:51 <dfeuer> Should I open up a bug report for lambdabot: "Not yet sentient?"
17:32:25 <josephle> nolrai66: one question I would ask is how would you implement pure using a comonad?
17:32:44 <edwardk> nolrai66: no
17:32:51 <dfeuer> Nice bug, bitonic!
17:33:04 <josephle> or edwardk can just give out the definitive answer :)
17:33:11 <bitonic> dfeuer: not my first time I make GHC loop!  ah!
17:33:17 <bitonic> *the first time
17:33:27 <nolrai66> Ah, yes. hmm. thanks both of you!
17:33:31 <dfeuer> Infinite loops are not supposed to happen in the typechecker without UndecidableInstances, I don't think.
17:34:04 <bitonic> dfeuer: I would hope so.  decidable type-checking is something I got used to having
17:34:09 <dfeuer> Hah. I was about to do what ezyang just did.
17:35:32 <nolrai66> Oh, right I was getting unit and counit confused.
17:45:54 <haasn> Which nontrivial comonads *are* applicative functors?
17:47:09 <haasn> (Trivial meaning “pure . extract = id”)
17:47:37 <merijn> haasn: I don't think that's possible
17:47:42 <bitonic> so if I have `class C1 a b | a -> b`, `instance C1 (Maybe a) a`, and `instance C1 a b => C1 [a] b`, GHC complains that there is no dependency between [a] and b.  But there is, from the constraint C1 a b.  couldn't GHC infer that?
17:47:48 <haasn> merijn: It's possible for things isomorphic to Identity
17:47:53 <haasn> (If that was a response to the latter)
17:48:03 <haasn> It's definitely possible for the first, because Stream is a perfectly fine applicative and comonad
17:48:07 <merijn> haasn: afaict parametricity guarantees that law abiding implementations of pure and extract must be identity when composed
17:48:50 <benmachine> extract . pure = id, but not the other way around, necessarily
17:48:55 <bitonic> the TypeFamilies equivalent works
17:49:02 <merijn> benmachine: oh, right
17:49:05 <merijn> benmachine: Agreed
17:49:17 <benmachine> or at least, the other way around is much less obvious, it might still be true :P
17:49:40 <haasn> It certainly isn't true for streams: repeat . head  is not id
17:49:53 <benmachine> right
17:50:18 <haasn> NonEmpty and Tree are also both fine applicatives and comonads
17:50:25 <benmachine> (Monoid m) => (->) m is applicative and comonad
17:50:41 <benmachine> (pure . extract) f = const (f mempty)
17:51:05 <benmachine> and (Monoid m) => (,) m
17:51:19 <benmachine> (pure . extract) (w, a) = (mempty, a)
17:54:41 * hackagebot linux-namespaces 0.1.0.0 - Create new or enter an existing linux namespaces  http://hackage.haskell.org/package/linux-namespaces-0.1.0.0 (MariosTitas)
17:55:46 <adarc> haskell has given me too many ideas
17:55:57 <adarc> and too much stuff to play/experiment with
17:56:00 <merijn> adarc: And it just keeps piling on more :)
17:56:01 <bitonic> I mean the coverage condition is weaker than that, but I wonder if it could be better
17:56:21 <adarc> merijn: it's ridiculous.. i've always had fun programming but nothing like this..
17:56:24 <adarc> ;f
18:25:03 <Taneb> How can I have a timeout on a pure computation?
18:25:18 <Taneb> (I do not mind if this forces me into IO)
18:26:55 <bitonic> Taneb: what do you mean?  you want an io action to execute when a pure computation is done?
18:27:17 <Taneb> No, I want to cancel a pure computation after 3 seconds
18:28:04 <bitonic> Taneb: forkIO + killThread + rnf + threadDelay
18:28:48 <bitonic> Taneb: e.g. do pid <- forkIO (case rnf pureComputation of () -> return ()); threadDelay 3000000; killThread pid
18:29:17 <bitonic> Taneb: what do you need to do anyway?
18:29:32 <Taneb> Implementing a brainfuck interpreter as an IRC bot command
18:29:39 <Taneb> I want to time out after 3 seconds
18:29:48 <bitonic> Taneb: use mueval for this stuff <http://hackage.haskell.org/package/mueval>
18:30:21 <bitonic> a 3 secs timeout is not going to be enough to avoid easy peasy ddos
18:31:03 <Taneb> This is a brainfuck interpreter, I'm not interpreting Haskell?
18:31:21 <bitonic> Taneb: presumably your interpreter is a haskell function
18:31:46 <Taneb> Yes?
18:32:01 <bitonic> Taneb: so you can use mueval to run the haskell code that interprets the brainfuck.
18:32:08 <Taneb> That feels very overkill?
18:32:20 <bitonic> Taneb: why?
18:32:51 <Taneb> Because that'd be using a Haskell interpreter to interpret brainfuck?
18:33:53 <indiagreen> Taneb: what about the timeout function from System.Timeout? Combined with evaluate (and force, if needed)
18:34:30 <bitonic> Taneb: well mueval uses GHC to interpret Haskell.  if you want to do an IRC bot that runs some sort of haskell looking at lambdabot & co seems the best thing.  in any case, if you want the timeout, what I wrote will work
18:34:56 <bitonic> or something nicer like System.Timeout :)
18:35:42 <merijn> Taneb: Rather that writing this yourself, use the async library
18:35:57 <merijn> (timeouts, that is)
18:36:00 <sebastiankg> what is it mean to have two apostrophes before a datatype?
18:36:08 <merijn> sebastiankg: Template Haskell quoting
18:37:56 <sebastiankg> Oh. Thanks, I'll look that up now that I know the keywords
18:42:35 <TallerGhostWalt> I am looking at the MarkupM type in blaze
18:42:36 <TallerGhostWalt> https://hackage.haskell.org/package/blaze-markup-0.6.1.1/docs/src/Text-Blaze-Internal.html#MarkupM
18:42:44 <TallerGhostWalt> I don't see how he is using foldr on it
18:42:54 <TallerGhostWalt> deriving (Typeable) ?
18:44:06 <TallerGhostWalt> nm I am an idiot
18:44:21 <solatis> if i do not run my program with -N, is it guaranteed to use only a single CPU core (eg: when using lightweight threads, they are guaranteed not to be executed concurrently) ?
18:44:33 <c_wraith> solatis: yes
18:44:41 <solatis> ok
18:44:48 * hackagebot irc-conduit 0.1.1.0 - Streaming IRC message library using conduits.  http://hackage.haskell.org/package/irc-conduit-0.1.1.0 (barrucadu)
18:44:52 <TallerGhostWalt> wait, I still don't get it
18:45:02 <c_wraith> TallerGhostWalt: where do you see a use of foldr?
18:45:07 <TallerGhostWalt> wait I do now lol
18:45:08 <TallerGhostWalt> geeze
18:45:09 <merijn> Taneb: It's a partial application of foldr
18:45:11 <merijn> eh
18:45:17 <merijn> s/Taneb/TallerGhostWalt
18:45:23 <TallerGhostWalt> yeah
18:45:33 <TallerGhostWalt> stupid stupid
18:45:52 <merijn> solatis: There's only a single haskell thread at a time, yes. But it depends on what you mean by executing concurrently
18:46:14 <merijn> solatis: Even in the single-threaded backend there's multiple threads (for foreign calls)
18:46:16 <solatis> well, basicly i have a socket that is not thread safe
18:46:39 <merijn> solatis: And potentially one thread could be executing a foreign call while another is executing haskell code
18:46:49 <solatis> ah right
18:46:56 <piskrist> heh, foldr .. sounds like some startup to help you organize your files
18:47:04 <solatis> that's a good point actually
18:47:05 <merijn> solatis: ZeroMQ sockets? :p
18:47:11 <solatis> yes :)
18:47:48 <solatis> but i think i will do the right thing, and implement my own concurrency model using internal zeromq sockets
18:47:52 <solatis> and base my code on message passing
18:48:03 <merijn> solatis: I'll take that as my weekly reminder to go back to implementing tests so I can actually put my native haskell ZMQ on hackage :)
18:48:22 <solatis> i was looking at control.concurrent.chan tho
18:48:35 <solatis> merijn: you have a pure haskell implementation of zeromq ready?
18:48:49 <solatis> count me in if you need someone to test-drive it
18:49:00 <merijn> solatis: Within haskell code it'll be much cheaper and better scaling to use Chan/TQueue/TBQueue than ZMQ
18:49:12 <solatis> yeah i know
18:49:43 <solatis> i was actually considering solving this on a higher level (running multiple processes rather than in-process concurrency), but that doesn't scale nearly as good
18:49:48 <merijn> solatis: It's mostly alpha-ready (i.e. it implements all sockets and can connect to real ZMQ, but lots of features are unimplemented), I just need to finish implementing my
18:49:58 <merijn> *my interoperability tests
18:50:24 <merijn> So I can actually test whether all the sockets behave correctly and interoperate with their C++ counter parts. But it's an obnoxious testing challenge
18:50:26 <solatis> ok
18:50:31 <solatis> i'm using very basic zeromq
18:50:36 <solatis> push/pull sockets, basicly
18:50:44 <solatis> and that's it
18:51:04 <merijn> solatis: tbh, a single Chan would be a good alternative
18:51:16 <solatis> i think i'm looking for a TQueue actually
18:51:18 <merijn> solatis: Chan's are multi-producer, multi-consumer threadsafe
18:51:31 <pold> How can I test with HUnit that something is not equal (i.e., the test should pass if the two expression are not equal)
18:51:42 <trap_exit> given how powerful are
18:51:47 <trap_exit> why are haskell teams still large
18:51:52 <trap_exit> rather than, say, maxing out at 10 people
18:51:57 <merijn> trap_exit: Coding is hard
18:51:58 <trap_exit> sinc ehaskell itself is so powerful
18:52:00 <trap_exit> and thus not need many people
18:52:17 <solatis> merijn: thanks, i think i know what to do now
18:52:30 <merijn> trap_exit: Regardless of haskell's power, if you have codebases measured in millions of lines you can't have a single programmer
18:53:19 <Welkin> why would anyone want to work on a project that large?
18:53:29 <solatis> one jobs channel for reading from zeromq pull socket and putting into a queue, and one responses channel for writing back the job responses and writing it to the zeromq push socket
18:53:30 <Welkin> well, alone anyway
18:53:38 <solatis> and two threads that perform each task
18:54:00 <merijn> solatis: Why do you want to use zeromq for single process communication?
18:54:17 <solatis> merijn: i'm not, i'm talking about control.concurrent.chan now
18:54:25 <merijn> ah, ok :)
18:54:47 <merijn> Yeah, that seems reasonable
18:55:31 <solatis> and of course a pool of threads that read from the jobs queue and write to the responses queue
18:55:36 <solatis> ehr, s/queue/channel/
18:56:45 <solatis> why would i want to use a STM.TChan instead of a Chan ?
18:57:00 <solatis> as in, is STM always the better choice/
18:57:51 <trap_exit> what haskell baase is that large?
18:58:01 <trap_exit> it seems like with tyhpes and purity, much code can be in libraries
18:58:04 <joelteon> Microsoft Windows
18:58:13 <trap_exit> windows is not written in haskell
18:58:16 <joelteon> wait, you're right
18:58:52 <c_wraith> Despite the fact that MSR put much of the money into GHC's development, historically.
18:59:30 <c_wraith> is SPJ still with MSR?
19:00:14 <c_wraith> Wikipedia claims he is.  Good enough for me!  So yeah.  Microsoft still funds a good bit of GHC development.
19:00:16 <trap_exit> why the fuck did ms kill msr sv ?
19:00:35 <trap_exit> who is going to work for msr again after this?
19:00:48 <Eduard_Munteanu> SV?
19:00:55 <c_wraith> silicon valley, iirc
19:01:48 <solatis> i think it is microsoft research in the UK that funds most of GHC's development, tho
19:01:52 <geekosaur> I thought that was an experiment and they decided it wasn't successful?
19:01:58 <geekosaur> and yes, MSR Cambridge
19:02:54 <meretrix> solatis: I think Chans are lighter weight and faster than TVar, so use them if you don't need they concurrency benefits of TVar.
19:02:57 <c_wraith> I don't know if it's "most" at the moment, since GHC has opened up to a much greater number of developers in the last year.
19:05:23 <merijn> trap_exit: Standard Chartered Bank has approximately 1 million lines of Haskell and 1.5 million of Mu (their internal strict haskell), last I heard
19:05:36 <trap_exit> whoa
19:05:43 <trap_exit> is Mu for real time trading ?
19:05:49 <solatis> meretrix: that was my gut feeling also (TChans provide more advanced features, and thus Chans are more lightweight)
19:06:11 <merijn> trap_exit: There's several other banks with haskell code bases measured in 100k+ lines
19:06:16 <barx> oh wow.  I work at a bank and wish I could use Haskell at work.
19:06:19 <barx> we use Scala.
19:06:25 <joelteon> Standard Chartered sponsors Liverpool!
19:06:28 <merijn> trap_exit: No clue, ask augustss when's he around, Mu is his baby :)
19:06:55 <trap_exit> strict haskell sounds awesome
19:06:57 <trap_exit> is it open source ?
19:06:58 <solatis> a strict haskell -- oh my, imagine the learning curve
19:06:59 <trap_exit> is it on github?
19:07:14 <trap_exit> we don't care about scala :-)
19:07:20 <piskrist> kinky
19:07:21 <merijn> solatis, meretrix: In general TVar's are subject to thundering herd problems, which makes them more expensive in cases where you have many threads and frequent updates
19:07:31 <merijn> trap_exit: No, hence why I said "internal"
19:07:52 <joelteon> just write your own!
19:07:56 <trap_exit> so it is open source
19:08:02 <trap_exit> just only to people inside the company
19:08:22 <merijn> joelteon: That's augustss' motto :p
19:08:43 <HeladoDeBrownie> I'm curious why one would want a strict Haskell
19:09:06 <joelteon> why would one want a lazy Haskell?
19:09:06 <trap_exit> ability to reaon about running time
19:09:10 <trap_exit> strack frames when debugging
19:09:24 <trap_exit> i want explicit lazy operator
19:09:30 <trap_exit> for putting stuff into thunks
19:09:34 <trap_exit> rat erhtn axplicit wnhf via $
19:09:35 <solatis> i think reasoning about running time would be a bank's biggest reason
19:09:51 * hackagebot irc-conduit 0.1.1.1 - Streaming IRC message library using conduits.  http://hackage.haskell.org/package/irc-conduit-0.1.1.1 (barrucadu)
19:09:55 <solatis> then again, if you care about reasoning about running time, you shouldn't use a GC-based language imho
19:10:07 <merijn> It's hard to reason about realtime guarantees without having to do whole program analysis in lazy languages
19:10:34 <merijn> trap_exit: Most consensus seems to be that lazy by default is more usable than strict by default
19:10:48 <merijn> trap_exit: Why do you need to whnf so frequently?
19:10:59 <joelteon> just use C
19:11:02 <trap_exit> yeah, but consensus among programmers is that Java + PhP are the best languages
19:11:11 <trap_exit> just use C? create your own asic
19:11:25 <solatis> joelteon: they're banks -- the most obvious choice would be COBOL
19:11:30 <joelteon> yeah
19:11:52 <joelteon> not to trivialize how usable PHP is
19:11:58 <Eduard_Munteanu> I suppose in a strict Haskell, one would rather go for explicit producers rather than a lazifying operator.
19:12:27 <Eduard_Munteanu> Similar to conduits vs lazy IO.
19:15:35 <Eduard_Munteanu> e.g. 'Source m a' might be a better model for lazy infinite lists
19:24:53 * hackagebot irc-conduit 0.1.1.2 - Streaming IRC message library using conduits.  http://hackage.haskell.org/package/irc-conduit-0.1.1.2 (barrucadu)
19:26:19 <benzrf> i should write a pipes <-> conduit  plumbing library
19:26:21 <benzrf> get it? PIPES
19:27:33 <merijn> benzrf: Snoyman and Tekmo are already doing that
19:28:57 <benzrf> oh
19:28:59 <benzrf> ;=;
19:29:05 <benzrf> wait, is tekmo gabriel
19:29:18 <MP2E> afaik, yep
19:29:19 <Welkin> ;=; is edwardk's newest combinator
19:30:00 <benzrf> top kek
19:30:15 <benzrf> what does it do
19:30:38 <benzrf> sequence kan extentional double adjunct comowhozits?
19:31:51 <Welkin> benzrf: you ain't no James Joyce
19:32:15 <benzrf> u cant tell me who i aint
19:50:54 <marchelzo_> which module exports the (++=) lens for appending to lists in MonadState
20:01:05 <indiagreen> maybe <>=?
20:02:39 <marchelzo_> indiagreen, that will work :) thanks
20:09:59 * hackagebot plumbers 0.0.3 - Pointless plumbing combinators  http://hackage.haskell.org/package/plumbers-0.0.3 (MichaelSloan)
20:32:38 <codygman-> ghci turned my "Fruit" into "main::Interactive.Fruit" and I am bewildered: http://lpaste.net/113378
20:33:21 <DanielDiaz> containers module "Data.Sequence" claims to have "strict operations". What do they mean by that? For example: Data.Sequence.index (Data.Sequence.fromList [undefined,2,undefined]) 1 = 2
20:34:41 <psik187> hello haskell geniuses, i have what I think should be a fairly simple question for you all
20:36:24 <f-a> shoot, psik187
20:38:39 <dfeuer> DanielDiaz, are you familiar with strictness vs. laziness?
20:39:07 <DanielDiaz> dfeuer: I am.
20:39:14 <psik187> im decently comfortable with haskell and I was reading this article: http://www.haskell.org/haskellwiki/Monad/ST    about the ST monad to learn more about it... scan the article (it's short) and I'll ask my question
20:39:23 <dfeuer> codygman, it looks like GHC is saying that what you called main has type Fruit, where Fruit is imported from the module called Interactive.
20:39:39 <dfeuer> psik187, most of us are familiar with the ST monad.
20:40:02 <dolio> DanielDiaz: I don't know what it means, exactly. Seq makes essential use of laziness for its performance.
20:40:27 <dolio> It evaluates certain things more eagerly than an analogous list would, though.
20:40:33 <dfeuer> dolio, that doesn't mean certain operations aren't strict in certain things. Which in what is another question.
20:41:14 <DanielDiaz> dolio, dfeuer: exactly. That's why I am asking. I would like to know the details, if anybody knows. What is and what is not strict in sequences.
20:41:38 <dolio> Read the paper. :þ
20:41:48 <dolio> Or the source, I guess.
20:42:12 <DanielDiaz> it's in transformers, what I would call a "core" module, and these things should be explained clearly. In my opinion.
20:42:20 <psik187> cool, in the article, they did " a <- readSTRef acc'; writeSTRef acc' (f a x)" in the body of their foldlST function... as an exercise for myself, i didnt read so far and implemented my foldlST by saying "modifySTRef a' (flip f x)"   please quickly refer to the article to understand variable names
20:42:36 <dolio> It's mainly more structure that will be 'stricter' if anything, though.
20:42:45 <dfeuer> DanielDiaz, I believe that from a *semantic* standpoint, you can pretend that Seq is implemented like this:
20:42:46 <DanielDiaz> dolio: I have read the paper some time ago, and I am looking at the code right now (which is the best way to see the strictnees).
20:42:47 <psik187> my question is, is one way better than the other, performance wise? or are they both the "same thing"?
20:42:55 <dolio> It won't be elements.
20:43:12 <dfeuer> data Seq a = Empty | Scons a !(Seq a)
20:43:41 <DanielDiaz> dfeuer: so is spine-strict, ok.
20:43:47 <dolio> No, it is not.
20:43:49 <dfeuer> DanielDiaz, it's not actually.
20:43:53 <DanielDiaz> : (
20:44:00 <dfeuer> But from a purely semantic perspective, you can pretend it is.
20:44:06 <dfeuer> Not from a performance perspective.
20:44:21 <Hijiri> modifySTRef just does the read then write . function
20:44:27 <Hijiri> so it should be the same
20:44:31 <DanielDiaz> hmmm
20:44:56 <dolio> Delaying evaluation of nodes toward the middle is part of the amortization.
20:45:10 <Hijiri> actually
20:45:14 <dfeuer> DanielDiaz, you can't (generally) play games with infinite Seq like you can with lists. Although you can probably make that work in some cases because of the fusion rules, you should not do so.
20:45:24 <Hijiri> I think that example isn't strict
20:45:28 <Hijiri> oh
20:45:32 <Hijiri> you didn't use strict
20:45:34 <dfeuer> Well, maybe you should.
20:45:37 <dfeuer> I don't know.
20:45:42 <Hijiri> so yeah it should be the same
20:45:49 <dfeuer> Er ... I'm thinking stupid. You just can't.
20:45:50 <dfeuer> Sorry.
20:45:53 <Hijiri> see http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-STRef.html#modifySTRef
20:46:02 <dfeuer> Mixing stuff up.
20:46:32 <dolio> DanielDiaz: I think, for instance, the spine of the outermost 8 elements will be as evaluated as the whole value, though.
20:46:56 <dolio> Well, maybe not quite. Between 2 and 8.
20:47:10 <dolio> At the front and end. Which is different from a list.
20:47:46 <DanielDiaz> dolio: maybe I am missing something... but does not "Data.Sequence.index (Data.Sequence.fromList [undefined,2,undefined]) 1 = 2" contradicts that?
20:48:02 <psik187> @dfeuer im enough of a haskell n00b that idk if you were responding to me or not haha my question still stands
20:48:02 <lambdabot> Unknown command, try @list
20:48:07 <dolio> No. Your undefined things are elements.
20:48:11 <dolio> Not spine.
20:48:22 <DanielDiaz> dolio: right, I misunderstood you.
20:48:32 <codygman-> dfeuer: Maybe it's related to interactive haskell mode...
20:48:35 <DanielDiaz> sorry about that
20:48:39 <dolio> No problem.
20:48:51 <dolio> I probably could have worded it better.
20:50:24 <DanielDiaz> so the "strict operations" sentence means that "part of the spine might be evaluated strictly"?
20:50:53 <dfeuer> > let foo = 3 Data.Sequence.<| foo in Data.Sequence.viewl foo
20:50:54 <lambdabot>  Not in scope: ‘Data.Sequence.<|’Not in scope: ‘Data.Sequence.viewl’
20:50:57 <dolio> Yeah. Some operations might touch parts of the spine that equivalent list operations wouldn't.
20:51:25 <dfeuer> > let foo = 3 S.<| foo in S.viewl foo
20:51:26 <lambdabot>  Not in scope: ‘S.<|’Not in scope: ‘S.viewl’
20:51:27 <lambdabot>  Perhaps you meant ‘Seq.viewl’ (imported from Data.Sequence)
20:51:30 <dolio> Of course, other operations won't access parts that equivalent list operations would, so I don't think it's a very good statement, really.
20:52:02 <DanielDiaz> dolio: it's, imo, above all, confusing (the statement)
20:52:13 <dfeuer> > let foo = 3 Seq.<| foo in Seq.viewl foo
20:52:17 <lambdabot>  mueval-core: Time limit exceeded
20:52:22 <dfeuer> THERE WE GO
20:52:37 <dolio> Like, if you index into the end of a Seq, it won't touch the middle, but for a list it will touch the whole list.
20:52:39 <Hijiri> psik187: look at the source of modifySTRef, it's the same as reading it, applying the function and writing that
20:53:17 <DanielDiaz> dolio: that makes sense. But it is obvious from the finger-tree perspective. I don't see any additional strictness.
20:53:27 <dfeuer> DanielDiaz, one way to look at it is that a list in Haskell is a control structure, but a sequence is not.
20:53:29 <DanielDiaz> the code, however, makes some uses of 'seq'
20:53:49 <dfeuer> Yes, it'll use seq however it likes on the spine.
20:53:52 <DanielDiaz> and since the code was relatively large, I wanted to ask first :)
20:54:00 <dfeuer> But it won't touch the elements.
20:54:27 <DanielDiaz> thank dfeuer, dolio
20:57:36 <psik187> Hijiri: ok, so my very plain question is (to understand haskell better): does it make any difference at all??
20:58:43 <f-a> did you take a look how foldSt is implemented, psik187 ?
21:00:30 <Hijiri> I don't think it should make any difference, except being slightly more verbose
21:01:11 <Hijiri> but I don't really know for sure
21:01:17 <Hijiri> but I don't see any reason why it would be different
21:01:39 <psik187> i looked at how it is implemented in the haskellwiki article... what i am still trying to understand is, are the two ways (my way and the way in the article) the "same thing", or is there any reason to write the code one way or the other
21:02:00 <Hermit> psik187: I'm not sure I caught everything (I just entered the channel). What's exactly your question? the readSTRef writeSTRef vs modifySTRef?
21:03:52 <Hijiri> It's pretty much the same thing, just giving it an explicit name might make it more clear what is happening
21:04:05 <Hijiri> giving the value pulled from the STRef, I mean
21:04:07 <psik187> Hermit: yes, i guess my question boils down to writeSTRef vs modifySTRef, but i am curious in a more general sense if one way is "better" than the other
21:04:41 <ReinH> writeSTRef is good if you want to write a value to an STRef. modifySTRef is good if you want to modify a value that's already in an STRef. ;)
21:04:47 <psik187> as in, the code "does the same thing", but is one way "better"
21:06:01 <Hijiri> It just coes down to readability
21:06:09 <Hijiri> which way seems clearer?
21:08:00 <psik187> please excuse my n00bness, but i guess what im asking is does it "matter" how i write haskell code, if the functions end up doing the same thing (disregarding strict vs lazy or anything like that)
21:08:25 <f-a> no reason to apologise psik187
21:09:02 <Hermit> psik187: they are exactly the same. modifySTRef is just a convenience. Pretty much boils down to  readSTRef st >>= writeSTRef st (fn a)
21:09:23 <psik187> cool that is exactly what i was wondering
21:09:37 <Hermit> readSTRef st >>= writeSTRef st . fn
21:11:14 <psik187> you can probably understand how coming from imperative programming, "what the code looks like" and "how many function calls" is still embedded in my head
21:12:47 <psik187> just curious talking to you smart people, what kind of projects are you all using haskell for?
21:12:54 <jle`> psik187: because you come from imperative programming, you might also know that premature optimization is often fruitless :)
21:13:24 <psik187> tell me about it... :(
21:14:09 <jle`> web, games, simulation/computation
21:14:43 <Hermit> psik187: you got to forget it all. Pure code can be rearranged beyond resemblance to the original code and work exactly the same but way more efficient. Sometimes even the bias towards creating an object, and then a new modified one and then another (having many intermediate objects) isn't really going into the compiled code.
21:15:12 <Hermit> psik187: just write code that's simple, correct and easily composable, then if you have a performance issue, profile
21:16:18 <psik187> so I can really trust GHC? its hard to... im so used to working in bytes and words haha
21:17:08 <Hermit> you are no longer working with orders, you  should be working with definitions
21:17:42 <psik187> no one answered me, what kind of cool things are you all doing with haskell??
21:18:15 <psik187> whos using haskell at work?
21:18:15 <Hermit> some systems programming and pretty much everything I need to do every now and then
21:18:39 <mrenaud_> psik187: Unfortunately not me
21:19:34 <fragamus> :t read
21:19:35 <lambdabot> Read a => String -> a
21:20:08 * hackagebot serial-test-generators 0.1.1 - Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time  http://hackage.haskell.org/package/serial-test-generators-0.1.1 (scottmurphy09)
21:20:13 <fragamus> > read "123.4"
21:20:15 <lambdabot>  *Exception: Prelude.read: no parse
21:20:26 <merijn> > read "123.4" :: Double
21:20:27 <lambdabot>  123.4
21:20:28 <fragamus> > (read "123.4" :: Double)
21:20:29 <lambdabot>  123.4
21:20:34 <fragamus> yeah
21:20:43 <merijn> fragamus: Use Text.Read.readMaybe (GHC 7.6 and later)
21:20:51 <merijn> :t Text.Read.readMaybe
21:20:52 <lambdabot> Read a => String -> Maybe a
21:20:58 <fragamus> good that's what I needed
21:21:11 <psik187> Hermit: when you say systems programming... care to go into more detail?
21:21:20 <fragamus> > (Text.Read.readMaybe "123.4" :: Double)
21:21:21 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
21:21:30 <fragamus> > (Text.Read.readMaybe "123.4" :: Maybe Double)
21:21:30 <merijn> lambdabot doesn't import it
21:21:31 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
21:21:36 <fragamus> doh
21:21:48 <fragamus> lambdabot needs to get with the times
21:21:59 <fragamus> and so does hoogle
21:22:01 <Hermit> psik187: last work was a backup system that deduplicates data and sends a diff to a server through sshfs
21:22:27 <fragamus> I'm using FP Complete's hoogle
21:22:31 <psik187> interesting, how did haskell help?
21:22:34 <Hermit> got to rewrite it though, it's kind of messy and a few components are poorly designed
21:23:04 <Hermit> making trivial most of the task and the porting to windows
21:23:16 <Hermit> the part that's really ugly is the GUI part
21:23:36 <Hermit> my first gtk gui, didn't go as I expected
21:23:47 <Hermit> happened to be more complicated than I foresaw
21:24:22 <Hermit> gtk's fault mainly, and incompatibility with the OOP model
21:24:23 <psik187> im just curious cuz im really new to haskell... how did Monads or Arrows or other FP things help in your system?
21:25:09 <Hermit> I modeled logs with Applicatives, config keeping and propagation with Monads. Didn't use arrows at all
21:25:52 <psik187> why chose haskell over say... python??
21:25:59 <Hermit> cause python sucks
21:26:11 <wei2912> it doesn't
21:26:15 <simpson> psik187: Mu.
21:26:16 <psik187> haha agreed
21:26:20 <wei2912> though compraed to haskell probably
21:26:32 <Hermit> psik187: reliability and speed
21:26:34 <simpson> Why would you choose only one language?
21:26:34 <psik187> compared to some other imperative language
21:26:59 <Hermit> psik187: but mainly reliability
21:27:18 <psik187> makes sense
21:27:25 <wei2912> simpson++
21:27:26 <fragamus> I must say this is the freeking coolest language I have ever encountered
21:27:37 <wei2912> you choose whatever language is suitable for your task
21:27:47 <psik187> in a general sense what sort of organization did you work for?
21:28:08 <Hermit> lone freelancer really
21:28:27 <psik187> and ur doin ok?
21:28:29 <Hermit> switched to haskell about a year and half ago
21:28:43 <Hermit> still struggling with some of it's denser shit
21:29:07 <Hermit> have to say there is no learning curve in haskell... it's more like a brutal wall of death till you get to do something useful
21:29:10 <psik187> but you make money writing haskell??
21:29:22 <Hermit> not for the moment
21:29:27 <nisstyre> I've made money writing Haskell, partially
21:29:32 <Hermit> I'm entering an ISP in a couple of days
21:29:36 <nisstyre> actually, totally last summer
21:29:41 <nisstyre> before that only partially
21:29:42 <Hermit> maybe there I'll write some systems for them
21:29:53 <nisstyre> but last summer doesn't count since it was a research position
21:29:54 <Hermit> reliability is most wanted in such an environment
21:30:17 <psik187> any sports fans here?
21:30:23 * Hermit rises hand
21:30:41 <Hermit> ski here
21:30:44 <Hermit> and ping pong
21:30:46 <mrenaud_> fragamus: I definitely have to agree with you
21:30:59 <barx> +1
21:31:03 <mrenaud_> Mountain biking anyone?
21:31:16 <psik187> none of you could even try me in table tennis, just saying
21:31:30 <nisstyre> psik187: the question you should be asking yourself is why choose Haskell over something like Racket, Scala, OCaml, etc
21:31:47 <nisstyre> it's not comparing apples to oranges then
21:31:50 <Hermit> psik187: I'll write that down, see if you are up to your claim when the time comes
21:31:54 <wei2912> nisstyre++
21:31:55 * Hermit laughs evily
21:31:57 <psik187> i ask myself the question every day and i really dont know the answer
21:32:22 <simpson> psik187: Learn languages. Learn many languages.
21:32:53 <psik187> i learned "web programming" in school and none of the langages are cool anymore (PHP)
21:32:54 <nisstyre> there are lots of research languages like http://disciple.ouroborus.net/
21:33:34 <psik187> simpeson: i know many languages
21:34:00 <psik187> im floudering now though, im unemployed lookng for a job
21:35:18 <nisstyre> psik187: the trick to interviewing is, ime, not trying to come off as better than you actually are
21:35:18 <Hermit> psik187: well, marketwise any crap language like java has more dominance than haskell at the moment
21:35:23 <nisstyre> if you really know your stuff then it shows
21:35:56 <nisstyre> but there's less competition in niche areas
21:36:23 <nisstyre> I don't see much use of functional programming in areas like information security, I bet you could blow away the competition there
21:36:35 <nisstyre> but you also have to know infosec well...
21:36:45 <psik187> thanks guys, im waiting to hear back from a few places... what makes it tough for me is i got kicked out of school before getting my degree
21:37:06 <Hermit> and that haskell is hard to secure against timing attacks so you must know your stuff well if you are going to try the security department
21:37:28 <nisstyre> Hermit: well you can use things like seq
21:37:33 <nisstyre> but, yeah
21:37:51 <nisstyre> it makes it trickier I guess, because you never want to short circuit things where there could be a sidechannel
21:38:15 <Hermit> yep, where everything is modelled on top of lazy eval, forcing it is pretty tricky
21:38:37 <nisstyre> I was thinking more in the area of penetration testing, intrustion detection, fuzzing, etc
21:39:18 <Hermit> nisstyre: I will need that knowledge soon, any suggestion?
21:39:19 <nisstyre> especially the last one is something you could run with
21:39:37 <nisstyre> Hermit: well do you know anything about web app security?
21:39:48 <nisstyre> that's probably the most sought after area
21:40:10 <Hermit> yeah, but in this case it's mostly going to be securing services and routing stuff maybe
21:40:11 * hackagebot serial-test-generators 0.1.2 - Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time  http://hackage.haskell.org/package/serial-test-generators-0.1.2 (scottmurphy09)
21:40:14 <nisstyre> there's a lot of resources here https://www.owasp.org/index.php/Main_Page
21:40:23 <nisstyre> you could even get training
21:42:24 <nisstyre> Hermit: are you qualified to do any kind of sysadmin stuff? IF you really need a job that's something else to look at.
21:43:14 <prinsen> I have an AST type and I want to create a special fold that folds over a certain type in the AST, do you do this with a newtype?
21:44:16 <nisstyre> prinsen: is the AST parametric already?
21:44:57 <prinsen> nisstyre: What do you mean?
21:45:01 <nisstyre> prinsen: like, do you want to fold over all if expressions or something?
21:45:15 <nisstyre> prinsen: I mean are there type variables involved? What's the actual type?
21:45:16 <prinsen> nisstyre: All vardecls in a JS AST
21:45:48 <nisstyre> prinsen: and you want to enforce that the accumulator only touches those?
21:45:51 <Hermit> nisstyre: yeah, I've worked as sysadmin before, nothing big but this isn't either for the moment.
21:46:13 <prinsen> nisstyre: I have a StmtList = [Stmt], Stmt = Expr | VarDecl | ..
21:46:42 <prinsen> nisstyre: I want to fold over a StmtList with forM, applying an action to all VarDecls
21:47:09 <prinsen> thats a simplified AST
21:47:12 <nisstyre> prinsen: ok, I guess you could wrap VarDecl in a newtype then..., and then unwrap it
21:47:20 <fragamus> hey I am running 7.8.2 and I want to use    allMaybes         do I need to upgrade
21:47:41 <nisstyre> prinsen: it seems kind of weird to do though
21:47:50 <prinsen> nisstyre: Dont you mean wrapping StmtList in a newtype and writing a foldable instance for that newtpye?
21:48:02 <nisstyre> prinsen: you didn't mention foldable
21:48:15 <nisstyre> prinsen: but if that works, sure
21:48:35 <prinsen> is it the common way to do it? if there is such a thing as common here
21:48:51 <nisstyre> prinsen: it seems strange to do a single pass over an AST just to touch variable declarations
21:49:02 <nisstyre> usually you want to minimize the number of passes
21:49:21 <prinsen> nisstyre: from the ECMA 262 specs: For each VariableDeclaration and VariableDeclarationNoIn d in code, in source text order do
21:50:19 <nisstyre> prinsen: ok, but your interpreter or compiler doesn't have to be organized exactly in the same way as the spec as long as its behaviour conforms to it
21:51:16 <nisstyre> prinsen: one way to think about it is that you have a "desugar" function that does a bunch of different transformations that leave the code in an equivalent but simpler state
21:51:16 <prinsen> nisstyre: True, hard to prove tough
21:51:25 <fragamus> I remember upgrading to 7.8.2 was a little bit of work because I was an early adopter of 7.8.2 so Im scared to upgrade
21:51:55 <prinsen> The JS language is fishy enoguh as it is
21:51:57 <nisstyre> prinsen: well you can keep extending your desugar function and show that for each case (each constructor it can match) that the transformation is valid
21:52:22 <fragamus> do I get the platform or what
21:52:35 <nisstyre> but I don't know, I've never tried doing anything with interpreting JS :(
21:52:51 <nisstyre> I know there's all kinds of crazy stuff like semi-colon insertion
21:53:04 <DarkCthulhu> I have http://pastebin.com/AuMt312W which is doing alpha-renaming in a simply typed lambda calculus example. Could someone tell me how exactly the "alpha rename" definitions are working?
21:53:15 <prinsen> I skipped over that when I wrote my parser
21:55:17 <DarkCthulhu> Is "alpha rename" a different function? How can I use "rename" as a parameter there? Is that taking the tuple (from, to) into itself?
21:59:50 <lambda> DarkCthulhu, "rename" is the first argument to alpha in that case
22:00:14 <DarkCthulhu> lambda, got it just now :)
22:00:36 <DarkCthulhu> I have a different question. It's about ascription, which I'm now trying to add to this implementation of lambda calculus
22:00:49 <DarkCthulhu> Is that just a syntactic form? What is the point of ascription?
22:01:28 <prinsen> Hm, is it possible to write Foldable instances for an unparameterized type?
22:01:29 <Total_1mmersion> I've never heard of ascription in the context of lambda calculus, sorry
22:01:56 <prinsen> guess you write a spezialised function istead
22:01:57 <DarkCthulhu> Total_1mmersion, Ascription is the same as annotation, in which it becomes possible to explicitly state a type
22:03:46 <DarkCthulhu> Total_1mmersion, Of the form "t as T"
22:05:27 <Total_1mmersion> prinsen: I don't think so because class Foldable (t :: * -> *) where
22:08:30 <Total_1mmersion> DarkCthulhu, perhaps you could add something like data TermTyped = TermTyped Type Term? Or pass around a pair (Term, Type)?
22:11:20 <DarkCthulhu> Total_1mmersion, Hmm.. I see your point. Term, Type pair would do it. I can just pretty print it with the "as".
22:11:25 <DarkCthulhu> Total_1mmersion, Trying that :) ty
22:11:45 <Total_1mmersion> Cool, np =)
22:19:03 <DarkCthulhu> I want data Term to be of (Term Type). Is that sort of recursive definition not valid?
22:21:21 <DarkCthulhu> Total_1mmersion, ^
22:22:28 <Total_1mmersion> You want Term to be parameterized by a type? data TypedTerm a = MakeTerm Term a
22:24:08 <DarkCthulhu> Total_1mmersion, I am trying to add the rule http://i.imgur.com/aeXL7rI.png?1
22:24:27 <DarkCthulhu> the term t may be of the type t as T
22:27:42 <Total_1mmersion> I'm not sure what you're trying to achieve, can you elaborate?
22:29:16 <Total_1mmersion> You can represent "t as T" in Haskell with a pair (t, T) which has type (Term, Type). You need to come up with definitions of Term and Type.
22:30:06 <DarkCthulhu> Total_1mmersion, That's what I was trying. The existing definitions are http://pastebin.com/83MBQW9z
22:30:42 <Total_1mmersion> Do you have a definition of Type?
22:31:06 <Total_1mmersion> Something like data Type = Int | String | Float ...?
22:31:15 <DarkCthulhu> Total_1mmersion, I think I get it. What you said earlier
22:31:34 <DarkCthulhu> Term = .. | .. | MkAsc (Term, Type)
22:31:48 <DarkCthulhu> Total_1mmersion, ^ isn't this what you mentioned as being valid?
22:32:00 <Total_1mmersion> That is valid, yes
22:32:31 <DarkCthulhu> Total_1mmersion, So, this MkAsc is a constructor of arity 1?
22:32:40 <DarkCthulhu> Do I need to invoke it that way every time?
22:32:57 <Total_1mmersion> But I don't know if that's what you really want. Can an ascribed term contain a non-ascribed term? If not, then you want a different definition.
22:33:40 <DarkCthulhu> Total_1mmersion, yes, it can contain a non-ascribed term
22:33:42 <Total_1mmersion> Here is value constructor arity: data Something a = Zero | One a | Two a a | Three a a a ...
22:33:53 <Total_1mmersion> Ok, then that definition is good
22:34:17 <Total_1mmersion> So yes, MkAsc has arity 1
22:34:27 <DarkCthulhu> okay.. cool! understood :)
22:34:54 <DarkCthulhu> Hmm.. I now need to tell the type checker to test within MkAsc(Term, Type) if Term is of type Type or else throw an error.
22:35:19 <Total_1mmersion> Pattern match!
22:36:01 <DarkCthulhu> Yeah
22:38:20 <Total_1mmersion> Do you know how to pattern match on the Type?
22:40:54 <DarkCthulhu> Total_1mmersion, I do. I'm writing it now.
22:41:20 <DarkCthulhu> Total_1mmersion, Some of the syntax throws me off sometimes, like the correlation between a lambda term and its haskell equivalent
22:41:52 <DarkCthulhu> I just did the pretty printing necessary to show it as "t as T". Now adding rules to the type checker, and then the evaluator
22:42:48 <DarkCthulhu> The typechecker has some monadic thing it's wrapped in. It's a little confusing. Total_1mmersion, will you be around for a while?
22:46:06 <Lewix> Hi
22:48:03 <fragamus> :t allMaybes
22:48:04 <lambdabot> Not in scope: ‘allMaybes’
22:48:39 <c_wraith> :t catMaybes
22:48:40 <lambdabot> [Maybe a] -> [a]
22:51:48 <DarkCthulhu> Why do you need the "Just" data constructor?
22:52:11 <DarkCthulhu> It's only useful within Maybe?
22:52:12 <jle`> DarkCthulhu: what is the alternative?
22:52:49 <jle`> would you rather data Maybe a = Nothing ...?
22:53:19 <jle`> the type has a whole other meaning, that way :)
22:53:52 <DarkCthulhu> jle`, I still wonder why I can't put in data Maybe a = Nothing | String?
22:53:53 <jle`> data Maybe a = Nothing | Just a    ... juuuuuust right :)
22:54:09 <jle`> DarkCthulhu: you can...but...it wouldn't be what you think it does
22:54:30 <jle`> only constructors can go in that position in a data declaration
22:54:42 <jle`> so you are basically making two constructors: Nothing and String
22:54:46 <DarkCthulhu> Yeah
22:54:48 <DarkCthulhu> Ohh.. okay
22:54:52 <DarkCthulhu> I can't take a value in either
22:54:52 <jle`> this is equilvant to data Maybe a = Foo | Bar
22:55:00 <DarkCthulhu> I see..
22:55:04 <DarkCthulhu> I need something of arity 1
22:55:20 <jle`> i'm still a big confused by what you mean by "need"
22:55:22 <jle`> but
22:55:24 <jle`> cool :)
22:55:26 <fragamus> I really need allMaybes and it's not in Data.Maybe I think because im on 7.8.2
22:55:38 <merijn> fragamus: What does "allMaybes" do?
22:55:50 <jle`> i'm not sure allMaybes exists anywhere...
22:56:04 <fragamus> Collects a list of Justs into a single Just, returning Nothing if there are any Nothings.
22:56:14 <fragamus> http://haddocks.fpcomplete.com/fp/7.8/20140916-162/ghc/Maybes.html#v:allMaybes
22:56:20 <jle`> that's interesting
22:56:23 <merijn> fragamus: How would it collect them?
22:56:31 <DarkCthulhu> jle`, I don't understand "Maybe". What happens if I do "data a = Nothing | Just a"
22:56:41 <jle`> sequence :: [Maybe a] -> Maybe [a]
22:56:48 <jle`> > sequence [Just 4, Just 9, Just 10]
22:56:50 <lambdabot>  Just [4,9,10]
22:56:58 <merijn> :t fmap mconcat . sequence
22:56:58 <jle`> > sequence [Just 5, Nothing, Just 4]
22:56:59 <lambdabot> (Monoid b, Functor f, Monad f) => [f b] -> f b
22:56:59 <lambdabot>  Nothing
22:57:05 <DarkCthulhu> O_o
22:57:18 <merijn> Or I guess maybe just mconcat?
22:57:22 <jle`> DarkCthulhu: hm. do you understand what algebraic data types are?
22:57:30 <merijn> > mconcat [Just 4, Just 9, Just 10]
22:57:31 <lambdabot>  No instance for (GHC.Show.Show a0)
22:57:32 <lambdabot>    arising from a use of ‘M867702594352132427118573.show_M8677025943521324271...
22:57:32 <lambdabot>  The type variable ‘a0’ is ambiguous
22:57:32 <lambdabot>  Note: there are several potential instances:
22:57:32 <lambdabot>    instance [safe] GHC.Show.Show
22:57:39 <jle`> merijn: you'd probably have to do (map . fmap) concat
22:57:47 <jle`> wait
22:57:53 <jle`> mconcat . (map . fmap) (:[])
22:58:05 <merijn> > mconcat [Just "test", Just "blah", Just ""]
22:58:06 <lambdabot>  Just "testblah"
22:58:09 <merijn> there we go
22:58:19 <merijn> > mconcat [Just "test", Nothing, Just "blah", Just ""]
22:58:21 <lambdabot>  Just "testblah"
22:58:23 <merijn> hmm
22:58:26 <merijn> ok, maybe not
22:58:35 <DarkCthulhu> jle`, Yes, I think I kinda do understand what they mean.
22:59:02 <jle`> DarkCthulhu: "data Maybe a = Nothing | Just a" means that you're making a new type, "Maybe a", which you can construct in (or deconstruct by handling) two ways: "Nothing", and "Just x", where x is of type `a`
22:59:05 <jle`> that's just...what it does.
22:59:25 <jle`> "data a = Nothing | Just a"....what is that even supposed to do? :)
22:59:45 <DarkCthulhu> jle`, Isn't that what a normal data definition looks like?
22:59:52 <jle`> not quite
23:00:10 <DarkCthulhu> data Something  = Constructor1 | Constructor2 | ...
23:00:20 <jle`> ah, that's an uppercase identifier
23:00:29 <DarkCthulhu> ohh
23:00:31 <jle`> `a` is a type variable here
23:00:39 <jle`> you can think of data Maybe a = Nothing | Just a
23:00:43 <jle`> as something kind of like but not really like
23:00:47 <jle`> data Maybe Int = Nothing | Just Int
23:00:52 <jle`> data Maybe String = Nothing | Just String
23:00:55 <jle`> etc.
23:00:58 <DarkCthulhu> I seeee
23:01:00 <jle`> if you are used to C++ templates
23:01:11 <DarkCthulhu> So, when it's lowercase, it's talking types and not data
23:01:12 <jle`> it's actually not like this, but...if you come from C++, it might help you with an ituition
23:01:17 <jle`> it's basically like Maybe<Int>
23:01:22 <jle`> er, Maybe<a>
23:01:32 <jle`> and that makes a bunch of different `Maybe` types, for every type `a`
23:01:40 <DarkCthulhu> I understand.. The a could be instantiated with any of the types that come under that typeclass?
23:01:43 <jle`> DarkCthulhu: lowercase here refers to the fact that `a` is a type variable
23:01:53 <jle`> DarkCthulhu: no typeclassess here
23:01:59 <DarkCthulhu> okay
23:02:09 <DarkCthulhu> so, it's a generic type variable
23:02:16 <jle`> so "concrete" types, like Int, and type constructors, like Maybe, have to begin with a capital letters
23:02:21 <jle`> in this case, the lower case `a` is a type variable
23:02:39 <DarkCthulhu> okay.. I'm beginning to get it now :)
23:02:41 <jle`> so saying data Maybe a = Nothing | Just a gives you a (Maybe Int) type, a (Maybe String) type, a (Maybe Bool) type, etc.
23:02:55 <jle`> the difference between making a hundred different data declarations and this is...
23:03:09 <jle`> if you had like data MaybeInt = NothingInt | JustInt Int, data MaybeString = NothingString | JustString String
23:03:20 <jle`> then you wouldn't be able to talk about "all Maybe-things"
23:03:20 <DarkCthulhu> so, when I read it, it is data (Maybe a) is defining a new type which is (Maybe a). Something like that?
23:03:28 <jle`> kinda.
23:03:38 <DarkCthulhu> okay.. I wasn't even reading the thing right :(
23:03:44 <jle`> defining (Maybe a) here gives you a bunnch of new types, Maybe Int, Maybe String, Maybe Bool...
23:03:50 <merijn> jle`: I recommend against use of the term "concrete type"
23:03:55 <jle`> yeah, i winced a bit
23:03:59 <DarkCthulhu> jle`, Is "Maybe" special?
23:04:01 <merijn> jle`: It's an ill-defined and ambiguous term
23:04:13 <jle`> i hoped that my usage of quotes would indicate that i am not advocating it v.v
23:04:27 <jle`> and that it is not a well defined word
23:04:27 <jack_rabbit> DarkCthulhu, nope. You can define any data types like that.
23:04:37 <jle`> DarkCthulhu: any identifier with an upper case letter is fair game
23:04:44 <jle`> data Either a b = Left a | Right b
23:04:49 <DarkCthulhu> so Maybe is not special at all? :-o It's just convention
23:04:52 <jle`> ya
23:04:58 <jle`> well, it's provided by the base libraries
23:05:01 <DarkCthulhu> mind = blown several times over.
23:05:05 <jle`> but it's only in the libraries
23:05:07 <jle`> it's not built-in at all
23:05:17 <jle`> some languages have built-in option types, but...not us, apparently
23:05:20 <jle`> we don't need it :)
23:05:36 <jack_rabbit> DarkCthulhu, You can define your own "maybe" or "either" data structure, and it'll work just the same.
23:05:45 <DarkCthulhu> cool.. that clears up SO much!
23:05:58 <jle`> the only difference is that Maybe has a lot of functions pre-defined on it...and typeclasses it is an instance of...so you lose a lot of convenience
23:06:28 <jle`> but a many times a library will provide a "maybe-like" data structure and explicitly refuse to provide the constructors and convenience functions and typeclass instances
23:06:33 <DarkCthulhu> jle`, Maybe has functions defined?
23:06:40 <DarkCthulhu> err.. what is "Maybe"
23:06:40 <jle`> yeah, in Data.Maybe
23:06:45 <jle`> mostly helper functions
23:06:54 <jle`> helper functions to make working with a `Maybe a` type a lot less of a headache
23:06:57 <DarkCthulhu> How does someone use them? I thought it wasn't special :-|
23:07:08 <jle`> they're just normal functions
23:07:12 <jle`> defined like any other normal functions in haskell
23:07:24 <jack_rabbit> DarkCthulhu, It's not special. You could write functions for your own "maybe" structure too. It'd just be a lot of work.
23:07:28 <jle`> isJust (Just _) = True
23:07:31 <jle`> isJust Nothing = False
23:07:32 <DarkCthulhu> ah.. okay..
23:07:36 <jle`> you could write that yourself
23:07:37 <DarkCthulhu> Just for convenience
23:07:41 <jack_rabbit> yep.
23:07:46 <jle`> it's just that the base libraries have them defined for you in Data.Maybe for convenience
23:07:53 <jle`> you can browse through the docs for Data.Maybe to see a few of them
23:07:57 <DarkCthulhu> So, I guess it is advisable to stick to the Maybe type constructor just for that?
23:08:06 <jack_rabbit> DarkCthulhu, Just like any standard library, it's all for convenience.
23:08:21 <jle`> yeah.  and people immediately know what you are talking about when you say `Maybe`
23:08:36 <jle`> instead of saying like, `CanteloupeSquirrel a`
23:09:05 <DarkCthulhu> I see
23:09:07 <DarkCthulhu> So, with the "data" keyword, I can define data types with a data constructor and new types themselves with a type constructor. Is there anything else it does?
23:09:11 <jle`> and if you provide option-like types in an api, people can use the convenience functions on Data.Maybe on what you return.  or they don't have to convert or unconvert between different maybe types
23:09:31 <DarkCthulhu> grr.. why couldn't there be different syntax to define new types
23:09:41 <jle`> the data constructor doesn't give you new data types
23:09:49 <jle`> it gives you new "normal functions" to create things of those types
23:09:58 <jle`> data Maybe a = Nothing | Just a
23:10:05 <jle`> gives you a function and a value
23:10:08 <jle`> Just :: a -> Maybe a
23:10:11 <jle`> Nothing :: Maybe a
23:10:20 <jle`> they're just like normal functions and values, in value-land
23:10:39 <jle`> there is only one type/type constructor here, `Maybe a`, `Maybe`
23:10:43 <DarkCthulhu> jle`, I meant in the usage data X = Constr Blah | Constr2 | ... Isn't this a new data type?
23:11:01 <jle`> yes, a new data type.  some people like to say it creates a new type
23:11:20 <jle`> the terms are interchangeable-ish here
23:11:21 <DarkCthulhu> O_o but.. but.. data Maybe a = Nothing | Just a created a new type and it was different
23:11:33 <DarkCthulhu> Terminology quite confusing
23:11:39 <jle`> well... foo = 5
23:11:43 <jle`> and bar x = 5 + x
23:11:52 <jle`> one is a constant, and the other is a function
23:11:55 <jle`> but they both have the same syntax
23:11:58 <jle`> it's the same deal here
23:11:59 <jle`> data X = ...
23:12:02 <jle`> data M a = ...
23:12:07 <jle`> one just has a parameter...one doesn't
23:12:09 <jle`> foo = 5
23:12:11 <jle`> bar x = ...
23:12:18 <DarkCthulhu> ohhhkay..
23:12:30 <jle`> right?
23:13:02 <jle`> do you think `foo = ...` and `bar x = ...` should have different syntax?
23:13:06 <DarkCthulhu> so, they are equivalent in some way. I don't see it very clearly how they're equivalent yet :/ but at least now I can tell the difference
23:13:12 <DarkCthulhu> jle`, No, they shouldn't
23:13:25 <DarkCthulhu> but types and the data itself should be different
23:13:26 <DarkCthulhu> ?
23:13:44 <jle`> `foo` gives you an Int right away, without asking for anything more
23:13:53 <jle`> `bar` gives you an Int after taking one parameter
23:14:00 <jle`> `X` gives you a type right away, without asking for anything more
23:14:07 <jle`> `Maybe` gives you a type as soon as you give it a parameter
23:14:10 <DarkCthulhu> Ohhh
23:14:15 <DarkCthulhu> jle`, I understand now
23:14:32 <DarkCthulhu> It's the arity changing on the left
23:14:51 <DarkCthulhu> So data always constructs types
23:15:00 <jle`> the word `type` might be a bit loaded, so i will clarify: "something that a value can have as a type of it."
23:15:09 <jle`> you can have a value of type (Maybe Int)
23:15:15 <jle`> but you can't have a value of type Maybe
23:15:25 <DarkCthulhu> okay.. very clear now :)
23:15:26 <jle`> Maybe is waiting for another parameter....say, Int.
23:15:33 <jle`> before you can have a value of that type
23:16:01 <DarkCthulhu> right.. It's a type constructor, which takes a type as parameter and constructs another
23:16:08 <jle`> exactly
23:16:19 <jle`> and you can make values of type `Maybe Int` from scratch in two different ways:
23:16:27 <jle`> by using Nothing :: Maybe Int
23:16:32 <jle`> or Just :: Int -> Maybe Int
23:16:46 <jle`> Nothing is just a plain ol' value here, and Just is just a plain ol' function here
23:16:55 <jle`> that takes an Int and gives you a Maybe Int
23:17:11 <DarkCthulhu> jle`, I get it. It Maybe <Type> can be used in any place where i could use <Type>
23:17:22 <DarkCthulhu> Including definitions of functions and so on
23:17:52 <jle`> yeah.  it is the 'kind' of things that can have values
23:18:01 <DarkCthulhu> So, when I consider something like Num, which is a type constructor, it has a similar definition?
23:18:09 <jle`> Int, Maybe Bool, String ....
23:18:14 <jle`> Num isn't a type constructor, actually
23:18:17 <jle`> it's a typeclass
23:18:23 <jle`> so, the rules are slightly different
23:18:30 <DarkCthulhu> Oh yeah -_- I forgot about the third distinction here
23:18:37 <jle`> as you learn more haskell, you'll find that there are ways to unify the two sorta in a common framework
23:18:42 <jle`> but for now, it's not too relevant
23:18:58 <DarkCthulhu> Hmm... so, for a typeclass, one would have an instance ... declaration?
23:19:13 <jle`> well, you can declare typeclasses
23:19:19 <jle`> class Num a where ...
23:19:27 <jle`> and then you use `a` in the type signatures of the functions in the definition
23:19:34 <levi> Most of the things you write at the top level of a Haskell program are technically declarations.
23:19:36 <jle`> if you are going through a course, they should talk about this in more detail :)
23:19:37 <DarkCthulhu> How do I make a typeclass which "contains" the types "Maybe Int" and "String" for example?
23:19:52 <jle`> DarkCthulhu: you make typeclasses.  and then you write their instances
23:20:12 <jle`> so you can make `Maybe Int` a member of a typeclass
23:20:20 <levi> Type classes are "open", so you can add new types to them at any time just by writing an instance declaration for them.
23:20:21 <jle`> instance MyTypeclass (Maybe Int) where ...
23:20:35 <DarkCthulhu> Hmm..
23:20:37 <jle`> and if i come along and make a new type, i can also write a MyTypeclass instance for it, possibly.
23:20:57 <jack_rabbit> DarkCthulhu, typeclasses are *kind of* analogous to interfaces in Java.
23:21:00 <jle`> try writing a Num instance for (Maybe Int) if you are ever bored
23:21:09 <jack_rabbit> DarkCthulhu, or abstract classes in C++
23:21:16 <DarkCthulhu> Hmm.. like mixins they seem.
23:21:30 <DarkCthulhu> Since they bring an implementation along
23:21:37 <jle`> you have to provide your own implementation
23:21:44 <DarkCthulhu> But they have something coming in for free?
23:21:50 <levi> But you can only have one instance for a given type class at a specific type. E.g. you can only one instance for Int as a Num.
23:21:58 <jle`> if you make (Maybe Int) an instance of Num, then you have to define (+) for Maybe Int
23:22:13 <jle`> i mean...if i have a function like addsub x y z = x + y - z
23:22:22 <jle`> then i can use addsub on any Num instance
23:22:30 <DarkCthulhu> Hmm.. I see
23:22:34 <jle`> so if i defined (+), (-), etc. for (Maybe Int), then i could throw it into addsub
23:22:38 <solatis> in haskell, it is always said that threads are lightweight (sparks) and you shouldn't worry about forking / killing threads, since it's lightweight
23:22:46 <DarkCthulhu> jle`, How does one read this line in English? class PP a where pp :: a -> PP.Doc
23:22:52 <levi> The closest thing in C++ to type classes are some of the 'concept' proposals that haven't quite made it to the standard yet.
23:23:00 <solatis> however, coming from a c++ world, i have the tendency to design my threads "properly", whatever that means, and make them long-lived
23:23:13 <solatis> as in, with a proper thread pool, etc
23:23:22 <solatis> is that an anti-pattern in haskell?
23:23:36 <levi> solatis: The GHC runtime already does that for you.
23:23:42 <jle`> "new typeclass PP, where every instance of PP `myInstance` has to have, defined, a function of type `myInstance -> Doc`
23:24:01 <solatis> levi: so i should just fork my threads ad-hoc instead of maintaining my own pool?
23:24:32 <DarkCthulhu> jle`, what is `myInstance` there a placeholder for?
23:24:42 <levi> solatis: Definitely don't make your own pools. These are not the threads you're used to.
23:24:45 <jle`> whatever type you are going to write an instance for
23:25:05 <solatis> levi: ok, so http://hackage.haskell.org/package/threads-0.5.1.2/docs/Control-Concurrent-Thread-Group.html is not something i should be using
23:25:07 <jle`> if i am writing an instance for Int, then it'll be Int -> Doc
23:25:15 <jle`> if i'm writing an instance for Bool, it'll be pp :: Bool -> Doc
23:25:33 <levi> solatis: Have you seen the book http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:25:35 <jle`> consider the Eq typeclass
23:25:45 <merijn> solatis: Having a thread pool makes little sense
23:25:50 <jle`> class Eq a where (==) :: a -> a -> Bool; (/=) :: a -> a -> Bool
23:25:58 <solatis> understood
23:26:10 <jle`> now i want to make MyType an instance of Eq...allow it to be compared/used in functions expecting an Eq
23:26:16 <solatis> levi: ah seen it, but forgotten about it
23:26:18 <jle`> then i would have to define (==) :: MyType -> MyType -> Bool
23:26:19 <solatis> merijn: ok
23:26:24 <DarkCthulhu> jle`, Okay, so that is definition of those 2 function "signatures"
23:26:30 <solatis> merijn: got it -- i will fork my threads ad-hoc as input comes in
23:26:42 <jle`> or (/=) :: MyType -> MyType -> Bool
23:26:46 <jack_rabbit> DarkCthulhu, They can have default implementations, too.
23:26:46 <levi> solatis: That's not so much a thread pool as it is a management group, so you can e.g. kill a bunch of related threads at the same time.
23:26:52 <solatis> will haskell also take care of not forking too many threads ?
23:26:58 <DarkCthulhu> jack_rabbit, how would that look?
23:27:05 <solatis> wait
23:27:10 <solatis> let me just post some code
23:27:16 <solatis> to explain what i'm trying to do
23:27:21 <merijn> solatis: The runtime system maintains a thread pool consisting of some threads for foreign calls (so that the FFI doesn't block haskell code) and N (user specifiable number) of capabilities
23:27:31 <DarkCthulhu> jle`, class PP a where pp :: a -> PP.Doc -- how is PP.Doc defined? Isn't that the new typeclass I defined?
23:27:43 <merijn> solatis: All haskell threads are multiplexed onto those N capabilities by the runtime system
23:27:45 <jle`> not really...it's in a different namespace
23:27:49 <jle`> it's kind of a bad example
23:27:51 <lpaste> solatis pasted “Producer / Consumer / Workers” at http://lpaste.net/113382
23:27:57 <jle`> PP.Doc means "the type Doc from the module imported as PP"
23:28:03 <levi> solatis: GHC has a thing called 'capabilities' that determines how much OS-level parallelism to try to introduce. They're somewhat like 'threads' in C++, except you don't typically explicitly manage them.
23:28:05 <DarkCthulhu> jle`, Ahhh
23:28:05 <solatis> see that pastie
23:28:05 <jle`> that's module qualification syntax
23:28:10 <jack_rabbit> DarkCthulhu, you just define the function underneath the type signature.
23:28:19 <jack_rabbit> DarkCthulhu, are you reading a book to learn haskell?
23:28:19 <DarkCthulhu> I see
23:28:20 <merijn> solatis: You can have considerably more haskell threads than OS threads, i.e. on a server machine 100k threads is not outrageous
23:28:28 <jle`> so if i say, import Data.Bool as B
23:28:31 <solatis> ok
23:28:34 <jle`> or something
23:28:36 <solatis> the thing is, i want this:
23:28:39 <jle`> then i qualify all of the imports...
23:28:41 <jle`> um...
23:28:42 <merijn> solatis: forkIO has a similar (probably cheaper!) cost as Go goroutines and erlang processes
23:28:45 <jle`> yeah this would really be covered under a course :)
23:29:14 <solatis> i have a kind of standalone, zeromq push/pull processing application -- one of the many worker processes in my architecture
23:29:20 <jle`> the PP module and the PP typeclass you are defining are different things, they just happen to have the same string representation, which is pretty unfortunate
23:29:23 <DarkCthulhu> I understand :) ty for being so patient jle` and jack_rabbit. I did pick up LYAH but left it one-third way through, and then the syntax partially started to make sense to me.
23:29:26 <jle`> and a bad design decision :P
23:29:33 <solatis> the requirements are pretty simple: input is an url, output should be contents of the url
23:29:43 <solatis> the zeromq sockets are *not* thread safe
23:29:46 <jack_rabbit> DarkCthulhu, I was just about to recommend that book. Finish it. It's really good.
23:30:05 <jle`> be aware of the different syntactical "namespaces" in haskell...it's a bit confusing at first
23:30:09 <solatis> as input urls come in, i want a pool of worker threads to consume these urls and start fetching these contents
23:30:15 <jle`> because you can have ad-hoc name overlap as long as they are in different syntax roles
23:30:22 <solatis> some mechanism of a max level of concurrency is thus desired
23:30:24 <jle`> usually we try to design our libraries around this
23:30:41 <solatis> because 100k threads would mean 100k simultaneous HTTP requests
23:30:49 <DarkCthulhu> jle`, Okay.. that sounds complicated. First thing, I should rename the PP typeclass :)
23:30:53 <jle`> yes :P
23:31:08 <jle`> it's not that it's complicated, it's that you just need to pick your names correctly :P
23:31:18 <solatis> this is definitely a bottleneck in my application, as in: input urls come in faster than the application can fetch
23:31:39 <jle`> data Just = String is completely fine...it's defining a type called `Just` with a constructor `String`
23:31:42 <solatis> thus, if i would forkIO a thread for every input url that comes in, that would be bad
23:31:48 <jle`> but it's kind of silly to do
23:31:54 <jle`> because you already have a type `String` and a constructor `Just`
23:31:58 <solatis> so i need some kind of mechanism to maintain a max amount of concurrency
23:32:00 <Hijiri> you could use QSem or something to keep track of a max thread count
23:32:08 <jle`> please don't do this :)
23:32:13 <DarkCthulhu> jle`, Yeah, I understand why that is silly now. :)
23:32:24 <levi> solatis: Why would that be bad?
23:32:46 <jle`> data Maybe maybe = Maybe (Maybe maybe) | String String
23:32:48 <solatis> levi: because that would mean a LOT of concurrent http requests
23:32:52 <jle`> yeah, don't do that :)
23:33:25 <solatis> or wait... my http-conduit library has a http connection pool manager
23:33:32 <levi> solatis: Well, as long as you don't run out of OS file descriptors... ;)
23:33:41 <DarkCthulhu> jle`, So far, Maybe was just a type constructor. How is it also a monad?
23:33:44 <solatis> yeah well that's my fear
23:33:50 <jle`> DarkCthulhu: Monad is just a normal typeclass
23:33:57 <jle`> so you need to write an instance for it
23:34:10 <jle`> instance Monad Maybe where ....
23:34:17 <jle`> and you can go crazy
23:34:21 <DarkCthulhu> Is that given to us by default?
23:34:28 <jack_rabbit> yep
23:34:28 <jle`> yes, it is provided
23:34:31 <solatis> in c++-world, i would elegantly handle this using async I/O with epoll under the hood
23:34:38 <jle`> i think there's actually one sensible Monad instance for it
23:34:40 <solatis> so everything would be handled with 1 thread
23:34:41 <jle`> so
23:34:47 <jle`> can't give them too much credit ;)
23:34:48 <solatis> in haskell, things apparently are done differently
23:35:16 <solatis> i guess i should just not care at this point.. :)
23:35:26 <DarkCthulhu> jle`, Is this an accurate statement: Monad is a typeclass, whose functionality is pulled into other type constructors sometimes.
23:35:29 <peddie> solatis: async I/O with epoll is exactly what the runtime is doing under the hood :)
23:35:37 <jle`> DarkCthulhu: er
23:35:45 <solatis> yeah i figured i should embrace the haskell way
23:35:48 <jle`> Monad is a typeclass, and type (constructors) can be instances of Monad
23:35:49 * DarkCthulhu hangs his head in shame
23:35:55 <jle`> Eq is a typeclass, and Int is an instance of Eq
23:35:59 <jle`> so is Bool
23:36:02 <DarkCthulhu> okay.. instance of
23:36:06 <solatis> i just don't want to DoS my own server :)
23:36:11 <jle`> but when you make Bool an instance of Eq, you have to define (==)
23:36:17 <levi> Monad is a slightly different sort of type class than something like Num or Eq, though.
23:36:27 <jle`> when you make Maybe an instance of Monad, you have to define return and (>>=)
23:36:35 <jle`> you could say it's a different kind of typeclass ;D
23:37:03 <levi> Num's class has members of kind *, while Monad has members of kind * -> *, the type constructor kind.
23:37:17 <jle`> when you have a function of foo :: Eq a => a -> a -> Bool
23:37:25 <jle`> if you write an Eq instance for your class
23:37:28 <DarkCthulhu> jle`, But when Maybe is an _instance of_ monad, we don't mean that in the same way as conventional languages right? It's sort of like saying that the operations defined for the monad typeclass will be available for Maybe.
23:37:30 <jle`> you can throw it into `foo`, and it will work
23:37:44 <jle`> DarkCthulhu: well, there are methods in the Monad typeclass
23:37:49 <jle`> and tehy will be available once you write the instance
23:37:54 <jle`> but that's because...you write them yourself :P
23:37:54 <DarkCthulhu> right
23:38:16 <jle`> but then, later on, when you use (>>=) etc. on Maybe-things, the operations will be already be defined. (by you)
23:38:25 <jle`> or by whoever wrote the Maybe instance
23:38:51 <levi> solatis: Well, there are plenty of ways you could limit the number of concurrent socket operations; the Parallel and Concurrent Haskell book ought to have good advice on how to do it.
23:38:56 <jle`> so whenever you use (>>=) in real life, on a Maybe, then it's using the definition that someone originally gave by hand
23:39:03 <jle`> in Data.Maybe, i think
23:39:24 <solatis> levi: i will read through it
23:39:25 <DarkCthulhu> jle`, Ohh.. okay. I'll check out the definitions for the monad methods.
23:39:28 <jle`> > Nothing >>= (\x -> Just (x + 3))
23:39:30 <lambdabot>  Nothing
23:39:35 <jle`> > Just 4 >>= (\x -> Just (x + 3))
23:39:36 <lambdabot>  Just 7
23:39:42 <jle`> thank you, person who wrote the Monad instance for Maybe
23:39:49 <jle`> ....that was your tribute
23:39:59 <DarkCthulhu> jle`, You're sequencing and passing the 4 onward to the second expression right>
23:40:00 <DarkCthulhu> ?
23:40:12 <DarkCthulhu> That's what >>= does, which is also what the do.. block would do
23:40:13 <jle`> yeah.  but that's not because of Monad
23:40:25 <jle`> that's because of the Maybe instance, where you define (>>=) to do that
23:40:25 * hackagebot bindings-codec2 0.1.0.0 - Very low-level FFI bindings for Codec2  http://hackage.haskell.org/package/bindings-codec2-0.1.0.0 (RickyElrod)
23:40:41 <jle`> and your (>>=) that you write for Maybe will determine what it does
23:40:50 <DarkCthulhu> jle`, Err.. isn't >>= coming from Monad?
23:40:56 <jle`> the name is
23:40:58 <jle`> but
23:41:04 <jle`> the actual implementation, is provided in Data.Maybe
23:41:06 <DarkCthulhu> The implementation is in Maybe
23:41:07 <DarkCthulhu> Ah
23:41:08 <DarkCthulhu> I get it
23:41:08 <jle`> yeah.
23:41:16 <jle`> Nothing >>= _ = Nothing
23:41:21 <jle`> (Just x) >>= f = f x
23:41:25 <levi> The point of a type class is to have ad-hoc polymorphism that's not *completely* ad-hoc. It's a form of overloading.
23:41:32 <DarkCthulhu> Hmm..
23:41:32 <jle`> someone wrote that somewhere at some point in history
23:41:36 <jle`> and to this day, we can now use it
23:41:37 <jle`> thank you
23:41:41 <DarkCthulhu> wow
23:41:49 <jle`> someone wrote it in Data.Maybe, that is.
23:41:53 <jle`> it could have been you!
23:41:56 <DarkCthulhu> reusability is at a whole different level with Haskell
23:42:01 <DarkCthulhu> jle`, Wasn't me :P I can assure you
23:42:10 <jle`> i mean...you could have written it, if you were around at the time
23:42:12 <jle`> :)
23:42:38 <DarkCthulhu> Okay.. last few questions before I go read the book (just to fill in my partial understanding)
23:42:40 <DarkCthulhu> Reader monad
23:42:47 <jle`> read the book
23:42:49 <jle`> :)
23:43:13 <DarkCthulhu> :D I will.. just this one, so I can understand some code at hand.
23:43:15 <levi> The thing about overloading is that you get a whole bunch of operations with the same name, but different implementations. This is very different from standard Haskell polymorphism, which is *one* implementation of a function that works uniformly over all types.
23:43:15 <jle`> btw, i wrote a little piece about the Functor and Monad instance for Maybe here.  and Reader too, incidentally -- http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad . if you were interested
23:43:52 <DarkCthulhu> jle`, What is Functor?
23:44:00 <jle`> read the book ;)
23:44:23 <jle`> it's hard to gauge exactly where you are, and the book offers a nice in-order exposition :)
23:44:37 <jle`> my post sort of explains what it is too though.
23:44:50 <levi> I wrote an extensive blog post about the history of the term Functor: http://pinealservo.com/posts/2014-10-22-ManyFunctionsOfFunctor.html
23:44:57 <DarkCthulhu> jle`, okay.. thanks for all the explaining!! I'll read that.
23:45:03 <DarkCthulhu> levi, Awesome. Reading that first
23:45:11 <levi> Not actually very relevant to Haskell at all, but I found it interesting enough to research for a couple of days.
23:45:58 <DarkCthulhu> levi, I like history in general. Sometimes makes it clear why X is called X :)
23:49:25 <levi> Generally it's called 'functor' because its 'like a function' but not.
23:49:31 <levi> That's the short of it, anyway.
23:51:24 <levi> Another one of the interesting trivial bits of information I gleaned from that research is the origin of the term "Polish Notation"
23:52:18 <levi> Which lives on, in inverse at least, in "Reverse Polish Notation" as found on HP calculators and stack-based languages like Forth.
23:52:24 <Maxdamantus> ? is what Polish notation
23:54:50 <merijn> Maxdamantus: Polish notation is prefix operator notation, invented by a Polish dude whose colleagues had trouble with his name, hence they dubbed it "Polish notation". Reverse polish notation is the postfix form of the same notation
23:56:07 * Maxdamantus was trying to ask the question in Polish notation, in case noone noticed.
23:56:13 <levi> I was constantly cutting/pasting the Polish names while writing the section about them in that article.
23:57:11 <levi> The only one I could remember was Tarski. :P
23:57:55 <Maxdamantus> You should say przepraszam to all Poles for that.
23:58:19 <levi> Łukasiewicz is apparently the guy who invented Polish Notation though.
23:59:06 <shmookey> levi: in a way it also lives on in machine code :)
23:59:09 <shmookey> in the sense that an expression `(5+4)*3` may be calculated by something like `push 3; push 5; push 4; add; multiply`
23:59:09 * Maxdamantus has exhausted his Polish vocabulary.
23:59:23 <levi> Apparently he met Alan Turing later on, who remarked on the appropriateness of Polish Notation for computers.
23:59:28 <Maxdamantus> oh wait, I know another word, but I can't type it on my phone.
