00:00:01 <mornfall> dfeuer: you can't put it into a variable of any kind
00:00:07 <mornfall> maybe, yeah :)
00:00:12 <mornfall> I'm not really up to speed
00:01:21 <mornfall> “When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation.” from 7.8.1 docs
00:02:25 <dfeuer> mornfall, I'm not using 7.8....
00:02:47 <dfeuer> but that is true, I think, still. Just ... extended.
00:03:48 <mornfall> you are on ghc-HEAD?
00:04:01 <dfeuer> Yes, mornfall.
00:04:09 <mornfall> crazy people here
00:04:17 <dfeuer> ?
00:04:19 * ski idly wonders where to get ghc-TAIL
00:04:30 <dfeuer> ski++
00:04:48 * ski blinks
00:04:55 <merijn> If release is prepend, then tail would be all historic ghc versions, no?
00:05:10 <ski> maybe
00:05:38 * dfeuer is trying to do crazy shit that probably won't work right even if it eventually typechocks.
00:05:56 <ski> sounds like fun
00:06:26 <dfeuer> Well, it'll work, but I'm trying to do seriously wonked fusion stuff, and I'll be very surprised if it actually makes good code.
00:06:48 <dfeuer> It'll work if it typechecks, I mean, unless there's some wonkiness I'm not seeing.
00:07:12 <ski> what kind of fusion ?
00:07:49 <dfeuer> ski, I'm attempting, likely in vain, to make foldr/build fusion to something impossibly nice with unwords . words
00:08:20 <dfeuer> ski, I'm attempting, likely in vain, to make foldr/build fusion to something impossibly nice with unwords . words
00:08:30 * hackagebot hailgun 0.2.1.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.2.1.0 (RobertMassaioli)
00:08:45 <dfeuer> It's possible to fuse unwords . words  specially, but tah doesn't help if you put even the slightest anything in between.
00:08:52 <dfeuer> Good night.
00:09:02 <ski> mhm
00:09:22 <ski> i suppose the inbetween stuff would have to be a good producer and a good consumer
00:09:34 <dfeuer> It would have to be something absurdishly good, probably.
00:09:50 <dfeuer> Like .. this is probably not even worth trying.
00:09:54 <dfeuer> GOOD NIGHT.
00:10:03 * ski ponders whether a push-based fusion could handler `unwords . words'
00:10:11 <ski> s/handler/handle/
00:11:10 <Fuuzetsu> unwords . words is not id though
00:12:01 <ski> @check \x -> (words . unwords) x == x
00:12:04 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 3 shrinks):
00:12:04 <lambdabot>  [""]
00:12:12 <ski> @check \x -> (unwords . words) x == x
00:12:13 <lambdabot>  *** Failed! Falsifiable (after 17 tests and 5 shrinks):
00:12:14 <lambdabot>  " "
00:15:34 <ski> @check \x -> all (liftA2 (&&) (not . null) (all (not . isSpace))) x ==> (words . unwords) x == x
00:15:36 <lambdabot>  *** Gave up! Passed only 52 tests.
00:21:49 <larsrh> Say I want to include the latest git hash into my build, how would I do that with cabal?
00:22:57 <larsrh> I guess that'd be similar to how cabal generates a 'Paths' module
00:24:54 <heudebeu> @pl \x -> (== 0) $ mod 5 x
00:24:55 <lambdabot> (0 ==) . mod 5
00:25:14 <bernalex> what's the most general typesig for map that makes sense?
00:25:22 <bernalex> Traversable t => ... ?
00:25:56 <Fuuzetsu> larsrh: if you ever want to publish that code then you should not
00:26:07 <ski> bernalex : you want something more general than `fmap' ?
00:26:18 <bernalex> ski: I'm asking what would be the logical extreme
00:26:29 <larsrh> Fuuzetsu: Could be optional, I guess
00:26:34 <bernalex> ski: I guess Functor might just be it
00:26:55 <larsrh> Fuuzetsu: apart from that, it's an internal application
00:28:08 <merijn> larsrh: You can hook Setup.hs and make it insert a -D flag with the git hash that way?
00:28:10 <Fuuzetsu> then you can probably mess with Setup.hs to get that info or maybe even splice it in with TH
00:28:21 <merijn> larsrh: But then it won't build on anyone not using git
00:29:32 <Fuuzetsu> at least he is not embedding date and time which is worse
00:30:03 <Aquana> ski: okay, got it
00:30:21 <larsrh> merijn: I would obviously write the Setup.hs in a way that it won't fail if you don't have git installed
00:30:21 <Aquana> sorry, i had an important phone call
00:30:31 <larsrh> merijn: My problem right now is that I'm confused which hook I should use
00:30:36 <larsrh> I'm looking at the docs
00:30:41 <ski> Aquana : ok
00:30:55 <larsrh> 'preConf' looks relevant, but I have no idea what that needs to return
00:31:33 <larsrh> Ideally I would just generate an additional source file with a binding 'hash :: Maybe String'
00:32:30 <larsrh> But an preproc argument would work as well.
00:32:31 <larsrh> *a
00:32:35 <ski> Aquana : anyway, in `length :: [a] -> Int', which is short for `length :: forall a. [a] -> Int', we can replace the `a' by any particular type `T' we like (also removing the `forall a.') getting `length :: [T] -> Int' -- this is parametric polymorphism
00:32:53 <juliotcm> Hello, any idea why this code throws index out of bounds?  https://www.fpcomplete.com/user/fpuser1739565/euler
00:34:19 <joshino77> http://freenode.net/faq.shtml#gettinghelp
00:35:23 <ski> Aquana : now, consider the multiplication function `(*) :: Num a => a -> a -> a', which likewise is short for `(*) :: forall a. Num a => a -> a -> a'. the `forall a.' bit means that this will (potentially, at least) work for any type `T' we can replace `a' by, as before (as long as we replace all the `a's (except in the to-be-removed `forall a.') by the same type `T')
00:36:53 <Aquana> ski: okay
00:37:09 <ski> Aquana : the `a -> a -> a' part means that the function will ultimately accept two arguments (of the same type) and return a result (of the same type)
00:37:12 <ski> Aquana : e.g. we can get *instantiations* `(*) :: Num Integer => Integer -> Integer -> Integer', `(*) :: Num Float => Float -> Float -> Float', `(*) :: Num Bool => Bool -> Bool -> Bool'
00:38:13 <juliotcm>  I owe you a beer, if you tell me why this code throws index out of bounds:
00:38:13 <juliotcm>  vector2Diag:: Num a => V.Vector a -> Matrix a
00:38:14 <juliotcm> vector2Diag vec = setDiag (identity (V.length vec)) 0 vec where
00:38:14 <juliotcm>     setDiag m i v | V.null v= m
00:38:14 <juliotcm>                 | otherwise = setDiag (setElem (V.head v) (i,i) m) (i+1) (V.tail v)
00:38:14 <juliotcm> print (vector2Diag (V.replicate 3 2))
00:38:16 <ski> Aquana : now, we know that `Integer' and `Float' are *numeric* types, iow they belong to the `Num' type class, iow we know they have the `Num' *property*. so we know `Num Integer' and `Num Float' are *true* statements
00:38:34 <merijn> larsrh: I don't know of the top of my head either, you can try asking in #hackage, dcoutts can help when he's around with cabal questions
00:38:53 <ski> Aquana : however, since `Bool' isn't a numeric type (i.e., it isn't an instance of the type class `Num'), we know that `Num Bool' isn't true
00:39:05 <larsrh> merijn: thanks, I'll try
00:40:33 <ski> Aquana : since we know that `Num Integer' and `Num Float' holds, we can simplify the two former instantiations of `(*)' to `(*) :: Integer -> Integer -> Integer' and `(*) :: Float -> Float -> Float', and now we see that we can either apply `(*)' to two `Integer's (getting an `Integer' back), or to two `Float's (getting a `Float' back) .. and similarly for any other type in the `Num' type class
00:41:48 <ski> Aquana : but since we don't know `Num Bool', we can't simplify away the `Num Bool =>' part of `(*) :: Num Bool => Bool -> Bool -> Bool', and hence we can't apply `(*)' to two `Bool's (expecting to get a `Bool' back). the system will complain that it doesn't find the `Num' instance for `Bool'
00:42:22 <ski> Aquana : each `Num' instance for a type specifies how `(*)' (and a couple of other basic numeric functions as well) will operate on the given type
00:42:56 <Aquana> okay
00:43:16 <rai> what is the relationship of monads and functors?
00:43:32 <ski> Aquana : multiplication on `Integer' is implemented quite differently from multiplication on `Float' -- however, the overloading of `(*)' here is supposes to be of "conceptually the same thing"
00:43:41 <ski> rai : every monad is a functor
00:44:35 <ski> Aquana : now, consider a numeral / numeric literal like `5'. it has type `Num a => a'. this is, as before, short for saying `5 :: forall a. Num a => a'
00:45:12 <ski> Aquana : this means that for any numeric type `T' (i.e. type `T' being an instance of `Num'), we get `5 :: T'. e.g. `5 :: Integer',`5 :: Float',&c.
00:46:14 <ski> Aquana : what happens is that when you write `5' in an express, where a `Float' (e.g.) is expected, then this is implicitly translated to `fromInteger 5' (where *this* `5' always has type `Integer')
00:46:49 <ski> Aquana : an instance for `Num' has to define the overloaded `fromInteger' function, to specify how to convert integer literals like `5' to the particular numeric type being used
00:47:20 <Aquana> hm
00:47:31 <ski> Aquana : something similar is used for literals like `5.43', except that a different class and a different implicit literal/numeral conversion function is used
00:47:34 <ski> @type 5
00:47:35 <lambdabot> Num a => a
00:47:36 <ski> @type 5.43
00:47:38 <lambdabot> Fractional a => a
00:47:43 <ski> @type fromRational
00:47:44 <lambdabot> Fractional a => Rational -> a
00:47:49 <ski> @type fromInteger
00:47:51 <lambdabot> Num a => Integer -> a
00:47:54 <ski> @src Num
00:47:55 <lambdabot> class  (Eq a, Show a) => Num a  where
00:47:55 <lambdabot>     (+), (-), (*)       :: a -> a -> a
00:47:55 <lambdabot>     negate, abs, signum :: a -> a
00:47:55 <lambdabot>     fromInteger         :: Integer -> a
00:48:33 <ski> that's the definition of the type class `Num', specifying which operations an instance of `Num' must implement
00:49:19 <ski> Aquana : did this help ?
00:49:55 <Aquana> i don't understand fromInteger
00:50:26 <ski> > fromInteger 5    :: Integer
00:50:29 <lambdabot>  5
00:50:32 <ski> > fromInteger 5    :: Float
00:50:33 <lambdabot>  5.0
00:50:35 <ski> > fromInteger 5    :: Rational
00:50:37 <lambdabot>  5 % 1
00:50:39 <ski> > fromInteger 5    :: Complex Flaot
00:50:40 <lambdabot>  Not in scope: type constructor or class ‘Flaot’
00:50:41 <lambdabot>  Perhaps you meant ‘Float’ (imported from Prelude)
00:50:41 <ski> > fromInteger 5    :: Complex Float
00:50:43 <lambdabot>  5.0 :+ 0.0
00:51:18 <ski> `5.0 :+ 0.0' means `5 + i * 0', where `i' is the imaginary unit (a square root of `-1')
00:51:43 <ski> `5 % 1' means `5 / 1', with a numerator of `5' and a denominator of `1'
00:51:49 <ski> > 15 % 3
00:51:51 <lambdabot>  5 % 1
00:52:38 <ski> `fromInteger' is called implicitly, everytime you write an explicit numeric literal (iow a numeral) in your code
00:53:24 <ski> if it wasn't, you'd have to explicitly write `fromInteger' anytime you wanted to write an integer literal and use it with another (numeric) type than `Integer'
00:53:32 <Aquana> I think I understand
00:54:57 <Aquana> and this is part of haskells specification and not implemented in haskell itself?
00:57:37 <Hijiri> I don't think you can implement implicit literal conversions just by writing haskell
00:59:24 <Aquana> thank you very much, ski!
00:59:44 <Aquana> and you too, Zekka
01:00:52 <ski> Aquana : `Num' is implemented in Haskell. but the syntactic sugar that inserts calls to `fromInteger' around integral literals is a part of the language specification
01:09:36 <winobes> so i'm writing a paper about haskell.... does anyone know what you call the feature of a language that allows you to define functions in any order?
01:10:15 <winobes> or is this just an immediate consequence of lazy evaluation
01:12:21 <ski> winobes : i suppose all declarations at a common indentation level are mutually recursive with each other
01:12:21 <ChristianS> winobes: any order? many languages do that, i think it's mostly a detail of how the compiler/interpreter works
01:12:51 <CodeWeaverX> No reason a strict language couldn’t allow it… C for example could fefer connecting usages of sybols to their definitions.  Just makes the compiler’s jobtrickier…
01:13:16 <CodeWeaverX> fefer -: defer
01:14:14 <rai> ski: so for example what happens in 1.5 * 5 is 1.5 * fromInteger 5?
01:14:20 <hyPiRion> CodeWeaverX: Interpreted/interactive languages have a harder time if they also want to be statically typed
01:14:23 <CodeWeaverX> With stating prototypes it can do just that.
01:14:33 * ski was wondering why CodeWeaverX was writing a clause in the opposite order ..
01:14:38 <winobes> In C though you would need to forward declare a function, and then have it linked to some object file I think
01:14:50 <winobes> right right
01:14:56 <ski> rai : well, it becomes `fromRational 1.5 * fromInteger 5', but yes
01:14:59 <CodeWeaverX> *nod*
01:15:22 <ski> winobes : linking is unrelated to this
01:15:37 <CodeWeaverX> Not really.
01:16:18 <hyPiRion> But I came over an interesting result
01:16:21 <CodeWeaverX> I mean it just depends on when you decide to resole the usage of a symbol to its declaration.  When that happens is kind of immaterial.
01:16:22 <hyPiRion> > let a = (2,b); b = 1; in a
01:16:23 <rai> ski: is this concept similar to "foo" being same as 'f':'o':'o':[]
01:16:25 <lambdabot>  (2,1)
01:16:40 <ski> rai : yes. it's a case of syntactic sugar
01:17:21 <ski> hyPiRion : *nod*, that doesn't work with `letrec' in Scheme e.g.
01:17:23 <hyPiRion> I had the assumption that let a = b; c = d; in ... was equivalent to let a = b in let c = d in ..., but that's clearly not the case
01:17:51 <ski> `let' (and `where') in Haskell is (/ are) recursive
01:19:19 <CodeWeaverX> Sure.  Seperating the lets out like that sort of enforces a sequential binding.  But that’s just syntactic sugar.  Doing the lets all at once is sort of like requiring you to up-front declare all your funciton prototypes in C — after which, any function can refer to any other.
01:19:46 <CodeWeaverX> Including recursion or mutual recursion.
01:20:25 <CodeWeaverX> Haskell jsut has a different way of allowing self and mutual recursion.
01:21:08 <jle`> in many interpreted languages, a function declaration is like registering a symbol/variable
01:21:15 <jle`> so it is like a side-effect
01:21:40 <hyPiRion> > let c = 1:b; a = 2:c; b=3:a in take 10 a
01:21:41 <jle`> def foo(): ... etc. is something like assinging something to a "variable" foo of sorts
01:21:42 <lambdabot>  [2,1,3,2,1,3,2,1,3,2]
01:21:48 <hyPiRion> feels very dataflow-y
01:22:11 <mrenaud> ignore -channels #haskell * JOINS PARTS QUITS NICKS
01:22:30 <mrenaud> Oops :P
01:23:09 <CodeWeaverX> Indeed.   But to the extent that you do that sort of thing on the command-line in an interpreter, its forced to take things one at a time and allow yout o evaluate on what’s been seen so far.  When reading a file full of stuff, it doesn’t necessarily need to, and can wait for future definitions to help sort out currrent definitions.
01:23:36 <CodeWeaverX> It would be hard to have a C interpreter for that reason, wher emutual recursion is involved, but no….. syntax that expressly arranges it.
01:24:02 <CodeWeaverX> haskell *has* that sort of syntax, by doing multiple-let-bindings in one statement.
01:24:36 <haje111> can one tell me a book in foundation of functional programming?
01:25:35 <CodeWeaverX> haje111:  Well, Learn You A Haskell is a pretty fun read that takes you through functional programming specifically in Haskell, which will probably do will for introducing concepts for most functional languages.
01:27:33 <haje111> CodeWeaverX: I need a book, which speaks more formal stuffs like foundation of functional prorgamming
01:27:39 <haje111> do you know such book?
01:27:42 <louisjb> haje111: Programming in Haskell (Hutton) is a really nice, simple, thin book to get started on Haskell, it's FP without being too hardcore, very accessible and a nice easy read
01:28:09 <CodeWeaverX> Formal functional programming book….. something deeper than a tutorial on a given language…. hmmm.
01:28:24 <ski> haje111 : if you want lambda-calculus, there's a book by Barendregt ..
01:28:43 <CodeWeaverX> I guess that would be pretty foundational.
01:29:04 <heudebeu> Has anyone read the new book by Richard Bird? Thinking functionally with Haskell?
01:29:23 <CodeWeaverX> Not yet, but now I just might. :)
01:30:09 <ski> CodeWeaverX has lazily read the book
01:30:46 <ski> forcing her/him to answer may perhaps take a few days or weeks, i suspect
01:30:49 <louisjb> haje111: Russell's Principia Mathematica ? :D
01:31:43 <ski> louisjb : hm, Per Martin-Löf's "Intuitionistic Type Theory" is more apropos, i think, though quite terse
01:32:36 <CodeWeaverX> ski wins the internetz for making me snort coffee.
01:32:38 <louisjb> anyone tried this one? Applications Of Functional Programming Hardcover – 29 Jun 1995
01:32:50 <louisjb> (Applications Of Functional Programming Hardcover – 29 Jun 1995
01:33:01 <louisjb> (by Colin Runciman)
01:37:37 <haje111> :)
01:37:55 <haje111> what is a good book of Haskell for beginers?
01:38:11 <haje111> is there something introduction to programming in Haskell?
01:38:32 <ski> hm, for beginner programmers ?
01:38:40 <haje111> yes
01:38:53 <ski> i'm not sure
01:41:31 <ski> i suppose the few first programs i wrote was one computing a function, so i could plot points of it on paper, one translating a string according to Caesar crypto, and one showing a (crude) animated aircraft
01:52:11 <Cale> ski: There's Learn You A Haskell...
01:52:18 <Cale> But the guy left
01:52:33 <ski> is it good for programmer beginners ?
01:52:39 <Cale> I dunno
01:52:57 <Cale> It has cute cartoons, how bad could it be? ;)
01:53:14 <Cale> I suppose Graham Hutton's book might be better
01:54:28 <jle`> i think LYAH was intended for an audience who has had some previous programming experience
01:54:57 <jle`> this is kind of embarassing because we often talk about how good haskell is for new programmers but i don't know if we really have any good text or course or book for it
01:55:52 <ski> well, here they teach Haskell before Java, and it seems to work
01:56:16 <aleator__> jle`: Well, theres edx and the nishant shuklas courses at least. Plus plenty of free-to-view university courses.
01:56:32 <jle`> designed for beginner programmers?
01:56:35 <jle`> ah well, that works then :)
01:56:44 <ski> ("Haskell: The Craft of Functional Programming", plus course-specific lecture, study and exercise notes)
01:57:14 <aleator__> Also, birds intro to fun is just brilliant but seems to require a very specific kind of a reader.
01:58:30 <aleator__> I'd claim my course is rather beginner friendly, but admittedly it really sucks at places. Though I've got order of magnitude better web exercises than edx fp.
02:01:06 <rai> what's a good monad to understand after maybe
02:01:55 <aleator__> rai: Writer is the next easiest in my opinion
02:03:45 <ski> rai : also `Either e'
02:03:57 <ski> rai : and perhaps `[]', the list monad
02:06:38 <aleator__> I've been thinking.. I've got a decent material for teaching FP and all kinds if niceties like online coding exercises. But I don't have enough resources to truly polish the material. Would it make sense to try to push it as a community effort?
02:06:49 <aleator__> (Or will I just get bikeshedded to oblivion?)
02:08:10 <jle`> aleator__: the community recognizes this need
02:08:23 <jle`> i'm not sure how much more pushing could be made or how effective it would be
02:08:31 <jle`> oh, you mean polishing your material?
02:08:36 <jle`> or do you mean material made to polish skills
02:08:54 <absence> http://lpaste.net/7470097147459796992 <- why do i get a warning about pattern match overlap here?
02:09:22 <jle`> absence: presumably, the last case will never be reached
02:09:35 <jle`> because you've covered all of the constructors
02:09:39 <absence> ohhh
02:10:05 <aleator__> jle`: Take a look at functional-programming.it.jyu.fi. I have plenty of nice things, but some of my material is actual crap.
02:10:05 <jle`> such error though
02:10:08 <jle`> why not Nothing?
02:10:29 <aleator__> jle`: But it still is in category of an 'online' beginner FP course.
02:12:04 <absence> jle`: wow, didn't think i had them all covered, but you're right, thanks! and they won't be errors eventually, i just want it to crash when these cases come up so i'm sure to implement them ;) early experimental code etc
02:13:02 <jle`> :)
02:13:22 <absence> jle`: btw, are there ways to make code like that shorter? without TH..
02:29:05 * hackagebot pagerduty 0.0.0 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.0 (BrendanHay)
02:37:39 <structuralist> I'm trying to run hp2any-graph and getting a "canonicalizePath: does not exist" error
02:45:52 <bernalex> deleteAttribute :: forall val. (PersistEntity val, PersistEntityBackend val ~ Connection) => Maybe (Entity val) -> ReaderT Connection (ResourceT ActionE) ()
02:46:00 <bernalex> what do I need to do to make the equational constraint legal?
02:48:25 <bernalex> oh. just allow GADTs. heh.
02:52:00 <supki> or type families
02:52:28 <bernalex> supki: yeah GHC told me about this. but I thought it meant I needed to implement something, not just allow it.
03:03:31 <rai> aleator__, ski: thanks
03:23:41 <iota_> hello, I'm trying to implement a simple DSL for computational "pipelines", and I figured out it could be expressed as Arrows, but without 'arr', does somebody have any feedback on this ?
03:25:14 <isomorphic> iota_:  I'm guessing you have you seen pipes, conduits, and machines?
03:25:34 <bennofs> isomorphic: then you probably have a category instance?
03:25:48 <isomorphic> bennofs: me?
03:25:57 <iota_> isomorphic: I've indeed seen the first two, but not machines
03:25:59 <bennofs> oops, meant iota_ .
03:26:35 <iota_> bennofs: I have the category instance, but I would like to use something like the Arrows DSL
03:26:48 <iota_> (though it's a bit more complicated without arr)
03:27:41 <isomorphic> https://github.com/ekmett/machines <- i haven't used it
03:47:31 <gilligan_> hi
03:49:08 <gilligan_> i'm trying hard to recall the name of some tool that I /think/ I read about on /r/haskell : It was basically just a cabal project file watcher that would output warnings/compiler errors on file changes - someone also had a blog post about it. I just really can't get myself to recall what it was called - Does anyone happen to know what I am referring to ?
03:52:11 <jna_sh> gilligan: possibly GHCID? http://www.reddit.com/r/haskell/comments/2hnmjr/neil_mitchells_haskell_blog_ghcid/
03:52:50 <gilligan_> jna_sh, yeah, thanks!
03:54:15 <gilligan_> jna_sh, not the most memorable name ;]
03:55:00 <jna_sh> gilligan: Neil gives some reasoning for it in his blog post, it's a bit more memorable after that :)
04:07:25 <yesthisisuser> I am running "cabal freeze" but nothing happens in my .configure-file. Maybe I misunderstood the intention of cabal freeze but my expectation was that the constraints should be automatically added to the configuration.
04:07:51 <yesthisisuser> .cabal-file I mean..
04:08:55 <adarc> anyone here ever use the statgrab package?
04:09:34 <adarc> i'm trying to figure out how to use this lib.. process = runStats $ (snapshot :: Stats Process)
04:09:57 <adarc> that will give me one process.. "init". Wondering how I can retrieve all of them. Same for network interfaces etc
04:12:42 <adarc> https://github.com/brendanhay/statgrab
04:12:47 <adarc> anyone have any idea?
04:12:48 <adarc> <- confused
04:14:07 <titusg> when i use :i in ghci I don't get instance info -- do I need to turn this on somehow?
04:14:47 <adarc> try :i Eq
04:14:58 <ClaudiusMaximus> titusg: maybe you need to import some more modules which define instances, but :i Integral  for example works here
04:15:55 <titusg> oh i see you call it on the typeclass not the instance...what if I want to see what typeclasses a type is in?
04:16:21 <yesthisisuser> to follow up on my own question, I realized that there is a separate cabal.config file which specify the constraints
04:16:25 <adarc> :t
04:16:28 <adarc> titusg: use :t
04:16:56 <yesthisisuser> although I am not sure exactly how and when it is used
04:17:33 <titusg> adarc: that takes a value though right? I want to see all typeclasses that, say, String is in
04:18:26 <adarc> ah, hm dno
04:19:24 * hackagebot conduit-extra 1.1.4.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.4.1 (MichaelSnoyman)
04:19:26 * hackagebot http-client 0.4.2.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.2.1 (MichaelSnoyman)
04:19:28 * hackagebot http-conduit 2.1.4.7 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.7 (MichaelSnoyman)
04:21:18 <indiagreen> titusg: “:i” does show instances for some stuff, but not for “String”
04:23:48 <Marti____> i would like to create an approximate Double type using the approximate-equality package. in the following code example from hackage, where is "Five" supposed to be defined?
04:23:50 <Marti____> > type ApproximateDouble = AbsolutelyApproximateValue (Digits Five) Double
04:23:52 <lambdabot>  <hint>:1:1: parse error on input ‘type’
04:24:18 <adarc> it's weird. i'd expend to find more utils on github that have used the statgrab lib from brendanhay
04:24:37 <adarc> that libstatgrab library is nice
04:31:07 <adarc> anyone here that's good with the haskell C FFI that can help me out for a sec?
04:31:32 <RchrdB> adarc: maybe. What's your boggle, please?
04:32:27 <adarc> hey.. well, i am wrecked. I'm trying to figure out how to use this StatGrab library.. They give a small example which works fine, however, I'm unable to obtain a "list of results", for example if I runStats $ (snapshot :: Stats Process) , it only returns ONE process
04:32:31 <adarc> http://brendanhay.github.io/statgrab/System-Statgrab.html
04:32:51 <adarc> but the libstatgrab C library returns lists of results for processes, network interfaces, etc
04:33:22 <adarc> so i'm wondering if it's something simple i'm missing.. in how to work with a program that uses an FFI like that
04:33:49 <adarc> here's another link which has a simple example: https://github.com/brendanhay/statgrab
04:34:11 <adarc> here's the actual C code which is called for network interfaces: http://www.i-scream.org/libstatgrab/docs/sg_get_network_iface_stats.3.html
04:34:23 <bernalex> god I swear my brain is asleep today
04:34:59 <adarc> https://github.com/brendanhay/statgrab/blob/master/src/System/Statgrab/Base.hsc
04:35:13 <adarc> foreign import ccall safe "statgrab.h sg_get_network_iface_stats_r" sg_get_network_iface_stats_r :: Entries -> IO NetworkInterfacePtr
04:35:42 <bernalex> if I have f a b c = ..., and want to apply f 1 to a list of b -> c, how do I do it?
04:35:49 <bernalex> well, actually, flip f 1
04:35:57 <adarc> so.. i'm wondering why I only get access to "one" result.. is it just that I don't know how to work with the values they gave me? maybe I'm able to obtain a next value given the result they gave me?
04:36:07 <adarc> ie, it somehow has a ptr to a next val
04:36:29 <adarc> i'm confused because there's no way this guy wrote a libstatgrab library that only returns '1' of processes, networkinterfaces, filesystems, etc
04:37:31 <bernalex> so f :: a -> b -> c -> d and flip (f 1) :: a -> c -> d.
04:37:44 <bernalex> and I have a list of as and a list of cs
04:38:00 <bernalex> this is not hard. I have done it probably 20 times this week. but my brain fails me. (I should go get breakfast after this.)
04:38:31 <bernalex> right
04:38:37 <bernalex> zipWith ($) was what I was looking for ofc
04:39:23 <adarc> sometimes you just have to talk it out.. hah
04:39:44 <bernalex> adarc: yeah. I spent a few minutes earlier talking out my persistent problems in #yesod. I worked those out too lol.
04:40:24 <adarc> nice
04:40:51 <bernalex> I guess I could use a list comprehension & zip as well
04:44:20 <yesthisisuser> ok so one thing I have never figured out is how, when and to what extent one should specify constraints on package versions in the cabal configuration on your project
04:45:02 <iota_> isomorphic: thanks for the link. I've read about machines, but I have still the same problem, the computations I want to describe are abstract, and these packages handle concrete data
04:45:21 <iota_> maybe I'm thinking about it the wrong way
04:46:44 <yesthisisuser> maybe this is just a "black art", like debian packaging
04:47:35 <snoopybbt> hello everybody
04:47:59 <yesthisisuser> hello
04:48:10 <snoopybbt> i'm learning haskell from the book "Programming in Haskell" by Graham sutton. I am writing the signum function, but i have a problem
04:48:36 <snoopybbt> I have msignum :: Int -> Int
04:48:45 <snoopybbt> and the guarded-expression based function body
04:49:09 <snoopybbt> now, I tried setting expression type as: msignum :: Num t => t -> Int
04:49:16 <snoopybbt> but it won't work this way
04:49:21 <snoopybbt> ... why is that ?
04:50:12 <indiagreen> snoopybbt: can you paste your code? if it's only 3–4 lines, do it here
04:50:12 <Fuuzetsu> because these two signatures say two different things
04:50:14 <snoopybbt> I mean, fractional numbers can be negative or positive too, right ?
04:50:27 <snoopybbt> okay indiagreen , just a sec
04:50:58 <snoopybbt> msignum :: Num t => t -> Int
04:50:58 <snoopybbt> msignum n | n < 0     = -1
04:50:58 <snoopybbt>           | n == 0    =  0
04:50:58 <snoopybbt>           | otherwise =  1
04:51:07 <Fuuzetsu> snoopybbt: your signature says that for any Num t => t at all, you're able to somehow produce an Int; ‘Num t => t -> t’ would make more sense
04:51:27 <snoopybbt> mmmh...
04:51:49 <Fuuzetsu> hm, that could work perhaps
04:51:56 <indiagreen> sure it could
04:51:58 <snoopybbt> Fuuzetsu: yes, that's right. but shouldn't i use some sort of... uhm... best-fit set for values ?
04:51:59 <yesthisisuser> The < requires Ord for one thing
04:52:21 <Fuuzetsu> indiagreen: I jumped to the usual assumption that they're returning t underneath ;P
04:52:27 <snoopybbt> i mean, -1, 0, 1 they all are Integral
04:52:35 <snoopybbt> why should i use a larger set ?
04:52:42 <Fuuzetsu> snoopybbt: you should post the error message
04:53:01 <snoopybbt> Fuuzetsu: it's like 10-11 lines, do I use pastebin ?
04:53:04 <Fuuzetsu> lpaste.net
04:53:38 <indiagreen> snoopybbt: there are 2 plausible definitions of signum
04:54:19 <lpaste> snoopybbt pasted “msignum error” at http://lpaste.net/113146
04:54:38 <snoopybbt> gh, there's a lpaste bot
04:54:43 <snoopybbt> wow, fucking neat! :D
04:54:58 <Fuuzetsu> snoopybbt: what those errors complain about is that you didn't say that we need to be able to compare (<) and check for equality (==) your t
04:55:40 <Fuuzetsu> you could try ‘(Num t, Ord t) => t -> Int’
04:55:43 <Fuuzetsu> Ord implies Eq
04:55:53 <snoopybbt> uhm.. okay
04:56:03 <snoopybbt> so how do i specify a set of "superclasses" ?
04:56:11 <snoopybbt> (i'm not into haskell terminology yet)
04:56:16 <phaazon> oh god
04:56:17 <Fuuzetsu> you write what I just said
04:56:25 <snoopybbt> okay
04:56:28 <phaazon> I just read the Simple example of bound
04:56:33 <phaazon> it’s not that simple actually :D
04:56:46 <phaazon> I especially don’t get this: https://github.com/ekmett/bound/blob/master/examples/Simple.hs#L74
04:57:05 <snoopybbt> ah, it works now, Fuuzetsu
04:57:14 <phaazon> how does the recursive inst stops?
04:57:15 <phaazon> -
04:57:16 <Fuuzetsu> cool
04:57:20 <phaazon> -s
04:57:20 <snoopybbt> so i get what you meant
04:59:01 <indiagreen> snoopybbt: one definition is that “signum x” it's one of the values [0, 1, -1], which denote whether x is bigger than 0, smaller than 0, or equal to 0, where 0 is the value provided by the “fromInteger” function which is supposed to make a <number> out of any integer. The other definition is that “signum x” is such a value that “signum x * abs x == x”. The former definition seems simpler, but the latter is more general
04:59:01 <indiagreen> and useful in mathematics because this way you can define signum for e.g. complex numbers which wouldn't necessarily have to be 0, 1, or −1
04:59:15 <indiagreen> > signum (2 :+ 3)  -- sign of 2i+3
04:59:16 <lambdabot>  0.5547001962252291 :+ 0.8320502943378437
05:00:53 <dv-> > sqrt(0.5547001962252291^2 + 0.8320502943378437^2)
05:00:55 <lambdabot>  1.0
05:04:54 <snoopybbt> wow
05:05:28 <snoopybbt> wait, but complex number don't have the concept of "positive" and "negative"
05:05:38 <snoopybbt> the complex set isn't an ordered set
05:06:10 <snoopybbt> signum (-3)
05:07:00 <indiagreen> add “>”
05:07:04 <indiagreen> > signum (-3)
05:07:05 <snoopybbt> uhm... btw okay, i'll keep on study
05:07:06 <lambdabot>  -1
05:07:09 <snoopybbt> oh there it is
05:07:15 <snoopybbt> > signum (-3)
05:07:16 <lambdabot>  -1
05:07:20 <snoopybbt> ah!
05:07:21 <snoopybbt> :D
05:07:33 <snoopybbt> cool :D
05:10:29 <Evilsparza> where would I have to look if I wanted to reduce "(\x -> (f x, f (x+1)))"? I found out you can rewrite it using arrows as "(\x -> join (***) f (x, x+1))" but that doesn't really "reduce" it :)
05:12:47 <xcombelle> hi very beginner question: in ghci prompt Prelude> x = 1 does this result <interactive>:2:3: parse error on input `=' but Prelude> let x  = 1 Prelude> x does the expected result 1 why ?
05:13:08 <phaazon> xcombelle: because let introduces binding
05:13:12 <phaazon> and you want to bind x to 1
05:13:25 <phaazon> x = 1 is not a valid syntax in ghci
05:13:33 <phaazon> (even though it’s Haskell valid syntax in a file)
05:15:04 <phaazon> is there people used to bound here?
05:15:43 <phaazon> I have a Let in my expression (Let [Scope Int E a] (Scope Int E a)) and I’d like to reduce an expression to whnf
05:15:51 <phaazon> I have no idea how to deal with the list of scopes
05:16:04 <phaazon> since I guess I have to reduce all scopes first using others
05:16:20 <phaazon> and then reduce the “in” scope using the already reduced values
05:17:30 <xcombelle> thanks phaazon
05:18:46 <adarc> ok so ive been looking into Storable etc.. i dont think this library (statgrab) can provide 'lists of results'
05:18:51 <adarc> they only do a 'peek'
05:19:14 <adarc> i imagine i'd need to specify an instance that can use peekElemOff or something
05:24:09 <indiagreen> > let f = show in (both %~ f) . (_2 +~ 1) . join (,) $ 1  --  an incredibly elegant and concise solution with almighty lenses for Evilsparza
05:24:10 <lambdabot>  ("1","2")
05:25:21 <piskrist> hrm, I suppose it will be difficult toupdate unordered-containers without update ghc as well, right
05:26:22 <pjdelport> > let f = show in (,) <$> f <*> f . (1+) $ 5
05:26:23 <lambdabot>  ("5","6")
05:26:37 <piskrist> oh
05:26:39 <pjdelport> Yay for Applicative :)
05:26:52 <pjdelport> Evilsparza: -^
05:26:55 <indiagreen> hey, you used f twice, it's Code Duplication
05:27:17 <Evilsparza> thanks pjdelport piskrist ^^
05:27:26 <Evilsparza> I'll look into it
05:28:52 <pjdelport> Evilsparza: The intuition is that whenever you see multiple parts of an application being applied to some shared value themselves, like: f (g x) (h x)
05:29:59 <pjdelport> Then you can treat the functions of the environment (g and h in this case) as Reader / (e ->) values, and just apply to them using Applicative instead.
05:30:21 <pjdelport> So the above just becomes f <$> g <*> h, or liftA2 f g h
05:30:52 <pjdelport> You can also see the pattern more clearly by stating it as: pure f <*> g <*> h
05:31:17 <pjdelport> So you see that all the parts are equal: the pure just means that "f" goes not get applied to the environment first, and ignores it instead.
05:31:42 <pjdelport> But you could say f <*> g <*> h to get \x -> (f x) (g x) (h x)
05:34:14 <Evilsparza> thanks for the insight
05:34:38 * hackagebot ObjectName 1.0.1.0 - Explicitly handled object names  http://hackage.haskell.org/package/ObjectName-1.0.1.0 (SvenPanne)
05:35:37 <snoopybbt> uh, I am facing another error, while reading the book
05:35:44 <snoopybbt> i'm writing this function:
05:35:47 <snoopybbt> mypred :: Int -> Int
05:35:47 <snoopybbt> mypred 0 = 0
05:35:48 <snoopybbt> mypred (n+1) = n
05:35:51 <joneshf-laptop> > show &&& show . (+1) $ 5 -- Evilsparza , another option
05:35:54 <lambdabot>  ("5","6")
05:36:02 <yesthisisuser> aah.. n+1 pattern
05:36:13 <snoopybbt> but i get this error:
05:36:15 <snoopybbt> funzioni.hs:37:8: Parse error in pattern: n + 1
05:36:24 <yesthisisuser> n+1 are not supported anymore
05:36:40 <snoopybbt> yesthisisuser: ah, so is it just that ? nothing wrong with ghci ?
05:37:04 <mgsloan> I think it is supported still, but as an extension - NPlusKPatterns
05:37:09 <snoopybbt> but are them literally dropped from the standard ?
05:37:21 <yesthisisuser> http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
05:37:28 <snoopybbt> btw it's okay, i'll just skip that :)
05:37:34 <ClaudiusMaximus> you can add {-# LANGUAGE NPlusKPatterns #-} to your file or use :set -XNPlusKPatterns in ghci to enable them
05:37:45 <maurer> Is there a way to hide a module from a package?
05:37:50 <yesthisisuser> I should say "n+k" btw ..
05:37:51 <mgsloan> It's just not on by default, because they were probably a mistake :)
05:38:08 <snoopybbt> it's fine, i'm just learning the language, don't really need that at the moment :)
05:38:10 <pjdelport> Evilsparza: There's also a fun but dubious syntax hack you can use for "infix" Applicative application. :)
05:38:10 <pjdelport> > let (·<) = flip (<$>); (>·) = (<*>); f = show in f ·<(,)>· (f . (1+)) $ 5
05:38:12 <lambdabot>  ("5","6")
05:38:20 <maurer> e.g. say some package a defines M and B, and another package b defines M and C, and I want to use a.M, a.B, and b.C
05:38:23 <maurer> is this feasible?
05:39:00 <ClaudiusMaximus> maurer: there's a pacakge imports extension, that lets you disambiguate
05:39:51 <pjdelport> maurer: Yes, you can always refer to names using their fully-qualified names, like Foo.M and Bar.M, or qualify your inputs to use shorter prefixes, like F.M and B.M
05:40:09 <maurer> pjdelport: they aren't in separate prefix trees
05:40:20 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
05:40:32 <pjdelport> maurer: Do they define a conflicting module name?
05:40:33 <maurer> ClaudiusMaximus: yeah, this looks like what I want
05:40:42 <maurer> pjdelport: yeah, ClaudiusMaximus has it figured out
05:40:49 <snoopybbt> what character is used for 'lambda' sign ? (as in lambda expressions)
05:41:23 <pjdelport> > (\x -> x*x) 5
05:41:25 <lambdabot>  25
05:41:31 <pjdelport> snoopybbt: \ like the above
05:41:38 <snoopybbt> i see, thanks pjdelport
05:41:45 <snoopybbt> let me try, lol
05:41:52 <snoopybbt> > (\x -> 2*x) 5
05:41:54 <lambdabot>  10
05:42:06 <snoopybbt> > :type > (\x -> 2*x)
05:42:07 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:42:14 <snoopybbt> lol, okay
05:42:15 <pjdelport> (The \ character is supposed to be look mnemonic for an actual lambda)
05:42:23 <pjdelport> :t \x -> 2*x
05:42:24 <lambdabot> Num a => a -> a
05:42:28 <snoopybbt> pjdelport: yeah it really looks like that
05:42:37 <snoopybbt> :t \x -> x*2
05:42:38 <lambdabot> Num a => a -> a
05:42:43 <snoopybbt> okay, got that
05:42:43 <pjdelport> For lambdabot, you omit the > before :t
05:42:45 <snoopybbt> :D
05:42:52 <snoopybbt> uhm, i see
05:43:25 <pjdelport> snoopybbt: Note that you can also /query lambdabot, by the way! That's useful to play around without getting in the way of conversation here. :)
05:54:24 <snoopybbt> oh thanks pjdelport, i'll do that :)
05:54:32 <snoopybbt> sorry for annoying :)
05:54:46 <pjdelport> snoopybbt: Not at all!
05:55:14 <pjdelport> Welcome to Haskell, by the way. :)
05:56:05 <pjdelport> Feel free to ask questions! (And if you feel that this channel sometimes gets a bit too busy, you can also try #haskell-beginners and #nothaskell )
05:56:32 <pantsman> welcome, snoopybbt
05:56:48 <benzrf> #haskell-blah also
05:58:05 <sivteck> #haskell*
05:59:41 * hackagebot Tensor 1.1.0.0 - Tensor data types  http://hackage.haskell.org/package/Tensor-1.1.0.0 (SvenPanne)
06:06:43 <snoopybbt> thanks pjdelport, pantsman benzrf, sivteck :)
06:06:51 <Intolerable> does anyone know if there's a way to get makeLenses to generate class definitions but not instances for a type?
06:06:53 <deech> Hi all, how do I convert from a CFloat to a Float. Hoogle and Hayoo don't seem to know.
06:06:57 <snoopybbt> i'm learning haskell via the FP101x mooc on edx
06:07:37 <snoopybbt> but i've quickly realized that the professor is basically explaining the content of the "Programming in Haskell" book by Graham Sutton, which he recommends
06:08:04 <snoopybbt> I had some experiences with Scala but... Didn't like it that much.
06:08:20 <snoopybbt> but maybe it's just me, a lot of people seems to like scala
06:08:50 <pantsman> my advice is: avoid Scala unless you have a really good reason to use the JVM
06:08:58 <clrnd> snoopybbt, yeah I also heard a friend say he is just reeding the book, but it's a good book nevertheless
06:09:26 <pantsman> Haskell is a much better place to learn functional programming than Scala.
06:09:55 <pantsman> I use Scala because it's possible to do functional programming with it, but it's hard work.
06:10:06 <ClaudiusMaximus> deech: realToFrac is the proper way, but depending on optimisation rules it might end up slow (realToFrac = fromRational . toRational), alternatives include   uncurry encodeFloat . decodeFloat  (but that will fail for +/-inf and nan), and  unsafeCoerce  if you're evil (and 100% sure that Float and CFloat have the same representation)
06:10:08 <yesthisisuser> "keep the palette pure" :)
06:10:09 <snoopybbt> pantsman: plus yesod/warp seems to be fucking fast and good-performing
06:10:17 <clrnd> also what pantsman says, Scala is the C# of FP
06:10:33 <yesthisisuser> i thought F# was the C# of FP :)
06:10:53 <clrnd> F# is trying hard but hasn't got there yet
06:11:08 <joneshf-laptop> what do those metaphors even mean?
06:11:21 <myfreeweb> Haskell is a much better place to learn pure functional / HM type system
06:11:31 <snoopybbt> scala has the huge advantage of running on the jvm, thus you can reuse a decade of libraries alredy-written and have rock-solid foundations that is the java api
06:11:34 <myfreeweb> for learning basics, ruby -> clojure IMO
06:12:03 <deech> ClaudiusMaximus: Cool. It's in a callback to C code. C passes in a C float and the Haskell function accepts a Float.
06:12:15 <snoopybbt> but whatever, i'm still in university :P
06:13:33 <pantsman> those java libraries can be hard to use correctly. People have made them work because they had no alternative.
06:13:53 <pantsman> calling them "rock solid" is generous, I feel.
06:14:57 <snoopybbt> haha, lol :P
06:16:41 <snoopybbt> i'm reading about sections, i want to try it but don't have a xor symbol, of course... i'm trying using __ as operator but it doesn't seem to work... what character could i use to create an operator? maybe one who's not alredy used ? suggestions ?
06:17:04 <snoopybbt> can I use random letters (a, b, k, w) to create operators ?
06:17:30 <saep> > 12 `xor` 4
06:17:32 <lambdabot>  8
06:17:43 <sbrg> woo, learning Haskell is paying off
06:17:46 <yesthisisuser> but sections and operators are not the same
06:17:53 <sbrg> I'm going to be TA'ing a haskell course
06:18:20 <bergmark> snoopybbt: see http://www.haskell.org/onlinereport/lexemes.html
06:21:40 <quchen> "_" is more of a letter than a symbol in Haskell.
06:21:43 <yesthisisuser> snoopybbt: A function, e.g., plus can also be called using infix notation:  5 `plus` 3. Similarly, infix operators (e.g. +) can be called using "prefix" form: (+) 5 3. Not sure if that was what you were asking.. lol
06:22:42 <yesthisisuser> Where in my example, "plus" would be a function.. say plus x y = x + y
06:23:07 <quchen> > let plus = (+) in (`plus` 3) 5
06:23:09 <lambdabot>  8
06:23:47 <augur_> sbrg: a haskell course, ey? where?
06:23:50 <snoopybbt> mmmhh..
06:24:24 <triliyn> Operators can be made out of lots of symbols, like @$%^&*+-=/ and perhaps more
06:24:54 <triliyn> Almost any string that contains only operator symbols is a valid operator name (exceptions are things like = which is already syntax)
06:25:48 <yesthisisuser> So a section is a kind of shorthand for partial application of infix operators. Like quchen was demonstrating
06:26:56 <snoopybbt> hey how do i define an operator ? I tried: (x) :: Char -> [Char] -> [Char]
06:26:58 <snoopybbt> and body
06:27:07 <snoopybbt> x a arrs = [a] ++ [arrs] ++ ['x']
06:27:28 <snoopybbt> mmhhh.. i'm messing up
06:27:32 <indiagreen> “x” can't be an operator, as ‘x’ is a letter
06:27:51 <indiagreen> try replacing “x” with e.g. “?”
06:28:13 <snoopybbt> ah, http://stackoverflow.com/questions/9356442/haskell-how-do-i-create-an-operator :D
06:28:16 <snoopybbt> StackOverflow <3
06:28:38 <snoopybbt> ok indiagreen, i'm going to try right now
06:32:37 <lpaste> clrnd pasted “catching exceptions” at http://lpaste.net/113153
06:32:43 <clrnd> woah wat
06:32:50 <clrnd> well, that ^
06:33:07 <clrnd> I'm trying to catch the exception Wreq.get throws
06:33:32 <clrnd> inside 2 monad trans
06:34:04 <sbrg> augur_: yeah, well, the functional programming language part of a "programming languages" course
06:34:16 <sbrg> we were going to have scala, but the scala guy is on leave or some such
06:34:16 <augur_> ahh neat
06:34:18 <augur_> where at?
06:34:21 <sbrg> Denmark
06:34:22 <augur_> thank goodness
06:34:24 <augur_> scala, blegh
06:34:27 <augur_> which uni?
06:34:35 <sbrg> University of Southern Denmark
06:34:57 <snoopybbt> ok got something simple to work
06:34:59 <snoopybbt> (?) ::  Char -> Char -> [Char]
06:34:59 <snoopybbt> a ? b = [a] ++ [b]
06:35:37 <snoopybbt> sbrg: i've always heard the rumor that denmark is a nice place to study, is it true? is it also true that it is fu**ing expensive ?
06:35:45 <clrnd> I know I can use Exception.try but I have to add an AWFUL inlined type signature
06:36:10 <sbrg> snoopybbt: it is true IMO, but I haven't studied abroad. Is studying expensive or living in denmark?
06:36:52 <augur_> sbrg: fun :)
06:37:07 <sbrg> Because studying in denmark is not only free, but the government pays you for it :)
06:37:11 <sbrg> monthly tuition thing
06:37:42 <snoopybbt> sbrg: dunno. my rent for a single room near (less than 600m) university is 425€/month. how is it compared to denmark ?
06:38:12 <snoopybbt> sbrg: also, will danish government pay for my studies if i am european but not danish ?
06:39:01 <k00mi> clrnd: I usually define something like "safeIO" that takes an IO action and converts the exceptions to Left err
06:39:27 <sbrg> snoopybbt: you can get cheaper than that, easily, dorm room thing. there are no rooms that close to this uni, though, as it is gigantic and kind of by itself because it's so big. they are building new places to live though. And no, probably not. anyway, we're probably a bit too offtopic. we can do #haskell-blah if you wish
06:39:48 * hackagebot lojysamban 0.0.8.1 - Prolog with lojban  http://hackage.haskell.org/package/lojysamban-0.0.8.1 (YoshikuniJujo)
06:40:20 <clrnd> k00mi, Exception.try does that, but I end up having to type the signature
06:40:28 <clrnd> @t try
06:40:28 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
06:40:40 <clrnd> @type try
06:40:41 <lambdabot> Exception e => IO a -> IO (Either e a)
06:40:45 <snoopybbt> sbrg: may I query you ?
06:41:08 <sbrg> snoopybbt: sure
06:41:51 <k00mi> clrnd: which is why I define safeIO once so I only have to do that and the lifting once
06:42:59 <clrnd> k00mi, hehe it's okay, I'm ding that I think
06:56:10 <piskrist> I have [IO ()] and I want to fire them off concurrently
06:56:17 <piskrist> what's my simplest option there?
06:56:27 <michi7x7> let x ❤ y = x ++ " loves " ++ y in "michi7x7" ❤ "Haskell"
06:56:35 <michi7x7> > let x ❤ y = x ++ " loves " ++ y in "michi7x7" ❤ "Haskell"
06:56:36 <lambdabot>  "michi7x7 loves Haskell"
06:57:29 <snoopybbt> lol michi7x7
06:57:33 <ClaudiusMaximus> piskrist: parMapIO_ from http://hackage.haskell.org/package/spawn-0.3/docs/Control-Concurrent-Spawn.html
06:58:33 <michi7x7> the Haskell compiler can do more UTF-8 than many IRC clients :)
07:03:45 <emre`> Selamin aleykum kardesler
07:03:59 <emre`> Did you know that Haskell sucked?
07:04:25 <piskrist> yeah, it sucks all the ignorance into a black hole :)
07:04:40 <wei2912> piskrist++
07:05:07 <emre`> Does it suck my dick?
07:05:54 <piskrist> emre`: I'm afraid you will have to do that yourself
07:06:09 <emre`> How about you do it?
07:06:20 <piskrist> thanks, but no thanks
07:06:31 <pmade> I don't know, with some Haskell and an Arduino almost anything's possible.
07:06:59 <emre`> Is it possible to make a copy of your mom and recreate a clone of you to suck my dick?
07:07:25 <pmade> Sounds like a question for a biology channel.
07:07:38 <capisce> a deep or a shallow copy?
07:07:49 <indiagreen> actually, it might be connected to bioinformatics
07:07:59 <michi7x7> more like a question for the ethics channel
07:08:09 <indiagreen> emre`: see http://biohaskell.org/
07:08:17 <michi7x7> or philosophy, that could keep them busy
07:08:36 <benzrf> jeez emre` do you have to be lik ethis
07:08:39 <pmade> emre`: Have you tried Haskell yet?
07:08:54 <benzrf> emre`: learn haskell, maybe then you will be happier and less trollish :-)
07:08:59 <emre`> I didn't say if it was right, I asked if it was possible. It's not a topic of ethics
07:09:07 <emre`> Just your mom and myself
07:14:01 <SwashBuckla> Haskell types are erased by the compiler after being checked: at runtime,
07:14:11 <SwashBuckla> Haskell types are erased by the compiler after being checked: at runtime,
07:14:43 <SwashBuckla> sorry
07:14:52 * hackagebot tasty 0.10.0.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.0.3 (RomanCheplyaka)
07:14:55 <benzrf> SwashBuckla: there is no runtimme type info!!
07:15:04 <SwashBuckla> haha
07:15:39 <SwashBuckla> benzrf: indeed!
07:15:41 <fizbin> Isn't that what the Typeable type class if for?
07:15:41 <hexagoxel> piskrist: just fire? mapM_ forkIO
07:16:19 <piskrist> thanks, I used the parMapIO_
07:16:27 <ClaudiusMaximus> hexagoxel: that has the issue that everything dies when main exits...
07:17:32 <benzrf> fizbin: yeah, but there's still no runtime type info
07:17:39 <Evilsparza> How can I "increase" my function in map? e.g. if I map (+1) to [1,1,1], I don't want it to be [1+1,2+1,3+1], but [1+1,1+2,1+3]?
07:17:44 <benzrf> fizbin: typeclasses get compiled to passing around dictionaries of methods
07:17:57 <benzrf> so what happens is that the runtime "type info" gets passed around with the values
07:18:01 <benzrf> just like any typeclass
07:18:17 <ClaudiusMaximus> Evilsparza: zipWith (+) [1,1,1] [1,2,3]
07:18:36 <fizbin> Right, but using Typeable means that the dictionary you're passing around contains information from which you could reconstruct anything you'd usually want runtime type information for.
07:18:46 <Evilsparza> yoink Thanks :D
07:19:44 <fizbin> Evilsparza: Not sure that's what you asked.
07:20:04 <fizbin> Another possibility for what you were asking for involves foldl'
07:20:24 <hexagoxel> or using (1+) instead of (+1)..
07:23:35 <fizbin> Or possibly iterate
07:23:38 <fizbin> > take 20 $ iterate (+1) 1
07:23:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:26:07 <shiona_> to me "map that changes" sounds like zipping with a list of generated functions
07:27:04 <michi7x7_> yeah great, now I have this ugly underscore sticking to me :(
07:27:40 <narendraj9> How is the function fix ever going to work?
07:27:56 <bennofs> > head $ fix (1:)
07:27:57 <lambdabot>  1
07:28:56 <narendraj9> Okay. Where can I find more examples?
07:30:15 <S11001001> narendraj9: any recursive function you write can be rewritten with fix instead of "direct" self-reference
07:30:48 <exio4> > fix (\fact x → if x == 0 then 1 else fact (x-1)) 6
07:30:50 <lambdabot>  1
07:31:05 <exio4> > fix (\fact x → if x == 0 then 1 else x*fact (x-1)) 6
07:31:06 <lambdabot>  720
07:31:07 <exio4> there
07:37:07 <benzrf> :t fix
07:37:09 <lambdabot> (a -> a) -> a
07:37:16 <benzrf> :t (\fact x → if x == 0 then 1 else x*fact (x-1))
07:37:17 <lambdabot> (Num a, Eq a) => (a -> a) -> a -> a
07:39:15 <fizbin> :t fix (\fact x → if x == 0 then 1 else x*fact (x-1))
07:39:16 <lambdabot> (Num a, Eq a) => a -> a
07:49:34 <spacebug_> hi, so I was wondering: why isn't it possible to have several versions of the same library to coexist globally?
07:49:48 <spacebug_> (asking respectfully - what was the trade-off?)
07:49:56 * hackagebot ghcid 0.3 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3 (NeilMitchell)
07:51:04 <ClaudiusMaximus> spacebug_: it is possible to have multiple versions installed, but you can't use more than one version of the same lib in the same program/library/ghci-session/etc
07:51:23 <michi7x7> speaking about fix, why doesn't this work? https://gist.github.com/michi7x7/85b32c36c0b5d1517e6f
07:51:30 <geekosaur> spacebug_, same reason you can't link two versions of the same C library into aprogram --- their symbols will conflict
07:51:41 <geekosaur> and in Haskell their *types* will conflict
07:51:48 <ClaudiusMaximus> spacebug_: and you risk the dreaded diamond dependency issue (lib A depends on B-1.0, lib C depends on B-2.0, now you can't use A and C in the same thing)
07:56:14 <RchrdB> spacebug_: you can have several versions of the same library installed side by side if you have a package manager that supports that, and can manage issues like the diamond dependency issue (lib A depends on B-1.0, lib C depends on B-2.0, so to compile something which depends on both A and C, you'll have to compile another version of either or both of A and C that both depend on the same version of B)
07:57:16 <RchrdB> spacebug_: cabal can't do this at the moment. Nix can, which is why some Haskell users recommend it.
07:58:00 <bergmark> and some package managers like npm just ignore this problem and your program fails horribly at some point :-)
07:58:16 <RchrdB> michi7x7: rand' isn't lazy. fix and fixIO can only work with lazy input.
07:58:55 <chaosfisch> How is this behavior called: "function x = doSomething x" gets "function = doSomething"
07:59:08 <narendraj9> fizbin: I don't understand how it works for factorial. Can you please explain a little?
07:59:57 * hackagebot gluturtle 0.0.58.1 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.58.1 (YoshikuniJujo)
08:00:02 <fizbin> narendraj9: First off, you should understand that when a function has type (a -> a) -> a -> a, that's the same as saying that it has the type (a -> a) -> (a -> a)
08:00:02 <RchrdB> michi7x7: offhand, I think you want to write that as rand' = fix (\r v -> if v > 2000 then return v else randomIO >>= r)
08:00:05 <hyPiRion> chaosfisch: the pl command for lambdabot?
08:00:13 <joshc> chaosfisch: eta reduction
08:00:30 <hyPiRion> oh.
08:00:32 <fizbin> narendraj9: That is, the -> in types associates to the right.
08:00:41 <RchrdB> michi7x7: iirc fixIO is primarily for making circular data structures.
08:01:05 <narendraj9> fizbin: yes.
08:01:18 <michi7x7> RchrdB: I've never used either
08:01:40 <narendraj9> fizbin: I get this.
08:01:53 <fizbin> narendraj9: So what "fix" does is it basically uses laziness to pass the result back in as an argument.
08:02:06 <fizbin> So let's look at (\fact x → if x == 0 then 1 else x*fact (x-1))
08:02:09 <Guest69923> @src fix
08:02:09 <lambdabot> fix f = let x = f x in x
08:02:23 <Guest69923> fix f passes (fix f) to f
08:02:55 <fizbin> That's a function that, if given a function that computes factorial, will compute factorial.
08:03:41 <Wingsorc> i've been writing my haskell stuff on notepad, is there any good ide out there (for windows)?
08:03:56 <dv-> emacs
08:04:01 <exio4> Wingsorc: you may take a look at leksah if you want a nice gui
08:04:04 <narendraj9> fizbin: Okay. It's a function that takes a function and a value as arguemtns.
08:04:08 <michi7x7> Wingsorc: you could try leksah
08:04:30 <fizbin> So fix (\fact x → if x == 0 then 1 else x*fact (x-1)) is the same as saying: let realfact = (\fact x -> if x == 0 then 1 else x*fact (x-1)) realfact in realfact
08:04:35 <chaosfisch> joshc: Ok thanks. That means: If I have something like: function a = doSomething a 2 - and order of arguments is important -> I can't reduce it!?
08:04:54 <exio4> fizbin: take the "nice" version; fix f = f (fix f)
08:05:06 <fizbin> Now, since we have a function application in there (a lambda expression, followed by an argument of "realfact")
08:05:18 <exio4> oh
08:05:23 <joshc> chaosfisch: correct, order of arguments is important, so in that particular instance you could not reduce
08:05:23 <fizbin> We can then substitute that through, so we have:
08:05:44 <fizbin> let realfact = (\x -> if x == 0 then 1 else x*realfact (x-1)) in realfact
08:05:59 <fizbin> And that is a traditional recursive definition of factorial.
08:06:10 <narendraj9> fizbin: We are finding fixed points wherein the domain is a set of functions. It's hard to imagine fixed-points there.
08:06:18 <narendraj9> fizbin: Okay. I see.
08:07:05 <ReinH> narendraj9: you might want to read http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
08:07:07 <fizbin> narendraj9: True, it does conflict with the intuition of "fixed point" as the fixed point of some continuous function from R^3 -> R^3
08:07:59 <narendraj9> fizbin: So, if I have a recursive funtions say f, then fix  (\f val -> if (base case) some_value else recursion_with_f) will give the same recursive function.
08:08:02 <ReinH> fizbin: does it?
08:08:03 <fizbin> narendraj9: But that's because you need to divorce the concept of "fixed point" from your topological intuitions.
08:08:19 <narendraj9> fizbin: Yes.
08:08:46 <chaosfisch> Ok, so far I've understood this. Can then this be reduced? Currently, I'd say yes - but I'm failing in doing so: decodeIntPairs xs = map decodeIntPair $ filter (>= 0) xs
08:09:06 <RchrdB> michi7x7: ah, correct way to write rand' using fix, is: fix (\r v -> if v > 2000 then return v else randomIO >>= r) 0
08:09:12 <narendraj9> ReinH: Thanks. I will read it :-)
08:09:23 <fizbin> ReinH: The usual intuition of what a fixed point is is closely tied to continuous deformations.
08:09:33 <narendraj9> fizbin: I think about fixed-point in two dimensions only
08:09:47 <narendraj9> Intersection with y = x.
08:09:58 * hackagebot snap-app 0.6.1 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.6.1 (ChrisDone)
08:10:01 <fizbin> Ah, to fixed point of R->R functions.
08:10:18 <narendraj9> fizbin: yes.
08:10:33 <fizbin> Well, in any case you're probably only really used to continuous or at least piecewise-continous R->R functions.
08:10:34 <RchrdB> michi7x7: arguably this: rand' = let innerRand' v = if v > 2000 then return v else randomIO >>= innerRand' in innerRand' 0 -- is clearer.
08:10:38 <ReinH> narendraj9: fix f = undefined
08:11:14 <ReinH> narendraj9: and also http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
08:11:32 <narendraj9> fizbin: Yes.
08:11:44 <fizbin> And the space of haskell functions isn't even a topological space (unless you want a trivial topology, like the point-set topology), so all your continuity-based intuitions don't really apply.
08:11:55 <michi7x7> RchrdB: yeah, sure it is
08:12:22 <narendraj9> ReinH: fix f = undefined. What is it for?
08:12:24 <michi7x7> I was just trying if you could actually write this kind of code shorter by using fix
08:12:28 <narendraj9> fizbin: Okay.
08:12:32 <narendraj9> I see.
08:12:46 <ReinH> narendraj9: I mean that the fixed point of your `f' is bottom
08:13:14 <michi7x7> I'll try to implement a higher order function that tries values until one passes a test ^^
08:13:24 <ReinH> fix "finds" the least-defined fixed point
08:14:27 <narendraj9> ReinH: What confused me is that I have a simple function \x -> x**2
08:14:37 <narendraj9> The fixed points are x = 0 and 1
08:15:24 <ReinH> No, the fixed point is the least-defined fixed point: bottom.
08:15:37 <ReinH> > fix (\x -> x**2)
08:15:40 <lambdabot>  mueval-core: Time limit exceeded
08:16:03 <lericson> :t fix
08:16:04 <lambdabot> (a -> a) -> a
08:16:08 <ReinH> the *least fixed point* that is, which is what fix finds.
08:16:11 <lericson> \
08:16:19 <ReinH> bottom is less defined than 0 or 1
08:16:20 <exio4> > fix (\f x → x*2) 5
08:16:21 <lambdabot>  10
08:16:21 <lericson> > fix (\x -> 2)
08:16:23 <lambdabot>  2
08:16:32 <RchrdB> > fix (\x -> 1 : x)
08:16:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:16:44 <RchrdB> Bottom isn't a fixed point of (1:), for instance.
08:17:04 <narendraj9> RchrdB: Hey! Are you Richard Bird?
08:17:08 <ReinH> It's instructive to ask why that is.
08:17:13 <RchrdB> narendraj9: no! Barrell!
08:17:25 <narendraj9> RchrdB: Okay. Sorry.
08:17:29 <RchrdB> narendraj9: and I'm considering changing my IRC nick because of that man. :(
08:17:44 <RchrdB> You're like the third person to ask in two days, I'm not sure how I'll cope.
08:17:56 <RchrdB> ;)
08:17:59 <narendraj9> RchrdB: His new book just got published.
08:18:09 <RchrdB> That explains a lot.
08:18:11 <narendraj9> Anyways. Please explain to me what you were explaining.
08:18:17 <narendraj9> How bottom is smaller than 0.
08:18:50 <RchrdB> I wasn't explaining, I was waffling. ReinH was explaining.
08:19:20 <ReinH> narendraj9: denotational semantics. :)
08:19:29 <RchrdB> Bottom is less-defined than 0. forall f, if (f 0 == bottom) then (f bottom == bottom).
08:19:40 <narendraj9> ReinH: Okay, I will go and read the wikibook. :-)
08:20:02 <RchrdB> Botton is also strictly less-defined than 0, because there exist some f such that (f bottom == bottom) but (f 0 == (something other than bottom))
08:20:07 <RchrdB> *Bottom
08:20:20 <ReinH> For fix (\x -> 1 : x), try x = bottom
08:20:28 <ReinH> Do you obtain an equality?
08:20:42 <narendraj9> I have to go now. I'm sorry. We'll read and come back later.
08:20:50 <narendraj9> *Will
08:21:13 <ReinH> _|_ = 1 : _|_ is false, so _|_ is not a fixed point
08:21:47 <ReinH> (this is only true in a lazy language)
08:21:52 <michi7x7> Haskell is weird
08:22:05 <exio4> the good weird!
08:27:57 <EvanR> keep haskell weird
08:41:26 <gganley> was the boston meetup yesterday?
08:49:28 <Aleksejs> Hi, is it possible to install haskell platform un R-Pi Arch?
08:50:02 * hackagebot propellor 0.9.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.9.1 (JoeyHess)
08:50:04 * hackagebot eibd-client-simple 0.0.3 - EIBd Client  http://hackage.haskell.org/package/eibd-client-simple-0.0.3 (vapourismo)
08:50:17 <shiona_> Aleksejs: the base platform yes IIRC
08:50:25 <phaazon> ola
08:50:37 <shiona_> Template haskell did not work on ARM last time I checked
08:51:30 <phaazon> if there’s a “bound” (the lib) guru here, or any people with HOAST knowledge, I’d like to be able to type my ast at compile time and it has to remain a monad, any idea? https://github.com/phaazon/ash/blob/master/src/Ash.hs
08:56:23 <favetelinguis> in haskell i can use currying for take 1 for example, but how does it work if i want to give take the list and later have it take the Int, is this possible?
08:57:12 <ClaudiusMaximus> favetelinguis: flip take
08:57:14 <exio4> favetelinguis: are you talking about flip?
08:57:19 <YurasS> lambdabot @hoogle flip
08:57:27 <YurasS> @hoogle flip
08:57:27 <exio4> @type flip
08:57:29 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
08:57:29 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
08:57:29 <lambdabot> package flippers
08:57:30 <lambdabot> (a -> b -> c) -> b -> a -> c
08:57:50 <YurasS> :| I'll never remember
08:58:06 <michaelt> > flip take "California" 3
08:58:07 <lambdabot>  "Cal"
08:58:40 <phaazon> > flip take (fix $ (:) 1) 4
08:58:41 <oleo> nevvaaarrrrr!
08:58:42 <lambdabot>  [1,1,1,1]
08:58:50 <oleo> lol
08:58:52 <michaelt> > map (flip take "California") [0..10]
08:58:54 <lambdabot>  ["","C","Ca","Cal","Cali","Calif","Califo","Califor","Californ","Californi",...
08:58:56 <favetelinguis> ok so it is no problem to take a function of any number of parameters and curry it in any order?
08:58:56 <RchrdB> phaazon: you hate points? ;)
08:59:21 <phaazon> > flip take (fix . (:) 1) 4
08:59:22 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘[a0] -> c0’Couldn't mat...
08:59:22 <lambdabot>  Expected type: [a0] -> c0 -> c0
08:59:22 <lambdabot>    Actual type: [a0] -> [a0]
08:59:29 <michaelt> favetelinguis: no problem, there just arent a pile of other combinators in scope like flip
08:59:29 <phaazon> points are wrong
08:59:31 <phaazon> :D
08:59:31 <RchrdB> favetelinguis: yeah, you can always write a function a bit like flip to rearrange some arguments.
08:59:36 <phaazon> (that was a joke)
09:00:01 <favetelinguis> ok ty
09:01:11 <michaelt> > let swap3_1 f a b c = f c b a in swap3_1 foldr [1..10] 0 (+)
09:01:13 <lambdabot>  55
09:02:34 <phaazon> http://www.reddit.com/r/haskell/comments/2k7g1h/typing_an_ast_without_loosing_the_applicative/ if you have an idea…
09:03:05 <joelteon> Loose the applicatives!
09:03:15 * joelteon war cry
09:03:53 <ReinH> cry havoc
09:04:05 <Aleksejs> shiona_: I'm trying to install it on RPi, and it shows "target not found: haskell-platform"
09:05:25 <joelteon> All joking aside, <*> seems like it would be very painful to be hit by.
09:06:26 <ReinH> phaazon: I... commented.
09:06:44 <ReinH> phaazon: what are you asking for?
09:07:07 <phaazon> ReinH: typed AST
09:07:15 <phaazon> with my AST
09:07:20 <phaazon> I can do for insttance
09:07:25 <phaazon> float 3 .+ int 1
09:07:31 <phaazon> that results in a correct expression
09:07:37 <phaazon> and I’d like it doesn’t
09:08:01 <phaazon> in order to do that, I have to turn GADTs on
09:08:01 <ReinH> phaazon: sounds like you want GADTs
09:08:09 <phaazon> but, it would break the monad instance :/
09:08:10 <ReinH> Yes.
09:08:27 <phaazon> and I won’t be able to bind anything then, since bound requires the expression to be a Monad
09:08:31 <shiona_> Aleksejs: so, arch? haskell-platform is in AUR (and not installable straight though pacman).
09:09:23 <shiona_> Arch wiki recommends installing only their packages, but nowadays I personally prefer installing only ghc and cabal-install with pacman, then using those to bootstrap cabal install cabal-install and remove the cabal arch provides
09:09:44 <phaazon> shiona_: that’s what I do as well
09:09:53 <piskrist> https://gist.github.com/yaccz/41f9a50c928bdf890cc6 what's going on here?
09:10:05 * hackagebot wai-middleware-static 0.6.0.1 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.6.0.1 (AndrewFarmer)
09:10:16 <phaazon> ReinH: I guess it’s impossible then?
09:10:46 <mrenaud> Hey everyone, I'm relatively new to Haskell and had a question I was hoping someone could answer.
09:10:53 <phaazon> I have to choose: either typecheck at compilation but no bindings or runtime typeck with bindings
09:11:38 <mrenaud> What the difference is between Control.Monad.X.Class and Control.Monad.X.Lazy (or any package that has a similar naming pattern)?
09:11:51 <michaelt> mrenaud: yes?
09:11:57 <michaelt> oh sorry
09:12:21 <pjdelport> mrenaud: Some monadic types have both lazy and stricter variations.
09:12:27 <michaelt> mrenaud: that a dispute arose on the libraries list about something  being too lazy or too strict
09:12:32 <ReinH> mrenaud: A module ending in "Class" would generally provide things relating to a typeclass. A module ending in "Lazy" would generally provide a lazy implementation of that module.
09:12:47 <JagaJaga> Insn't there a ($) for a (++) or smth like that? :)
09:12:57 <phaazon> JagaJaga: ?
09:13:04 <ReinH> mrenaud: So they aren't very related. More related would be a "Foo.Strict" and a "Foo.Lazy" typeclass, for instance with Data.Map, Data.ByteString, etc
09:13:07 <michaelt> mrenaud: thats why there's X.Lazy and X.Strict one of which will be re-exported by X
09:13:15 <JagaJaga> im bored with brackets :(
09:13:20 <ReinH> mrenaud: sometimes the .Class is used to provide a generic interface for both strict and lazy versions, though
09:13:32 <phaazon> JagaJaga: print $ "your " ++ show stuff ++ " that way"
09:13:54 <phaazon> or…
09:14:16 <ReinH> More often it's for something like ReaderT at Control.Monad.Reader and the MonadReader typeclass at Control.Monad.Reader.Class
09:14:19 <phaazon> or nothing actually
09:14:29 <JagaJaga> phaazon: no. I mean this situation `show $ func lala ++ " | " ++ show $ haha bar $ foo`
09:14:33 <piskrist> phaazon: JagaJaga print "your %s that way" $ show stuff
09:14:33 <mrenaud> Ahh, that makes sense. So if I import Control.Monad.X for example, does that pull in the Lazy one?
09:14:46 <ReinH> piskrist: you mean printf?
09:14:52 <piskrist> ReinH: right
09:15:06 * hackagebot hplayground 0.1.2.1 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.2.1 (AlbertoCorona)
09:15:08 <JagaJaga> piskrist: but if I nead just string concat? :)
09:15:10 <ReinH> mrenaud: it pulls in whichever is the "default", you have to check the docs to be sure. But often it's the lazy one.
09:15:17 <piskrist> JagaJaga: printf anyway
09:15:18 <JagaJaga> or smth
09:15:22 <michaelt> mrenaud: that tends to be the case, e.g. with Control.Monad.Trans.State
09:15:30 <JagaJaga> piskrist: thx!
09:15:34 <ReinH> JagaJaga: show $ func $ ... or show . func $ ... work
09:15:46 <phaazon> piskrist: printf you mean?
09:15:51 <ReinH> I'm ambivalent about printf
09:16:15 <ReinH> e.g., http://chrisdone.com/posts/formatting
09:16:25 <ReinH> It's not typesafe.
09:16:40 <ReinH> So I don't generally recommend it.
09:18:46 <michaelt> mrenaud: if you are trying to figure out the standard monad transformers, you might do well to ignore mtl and the mtl classes like MonadReader and MonadState at first.  The `transformers` types and the the MonadTrans class are the main business.
09:19:15 <ReinH> michaelt: I don't think they are, I was just providing an example
09:19:18 <piskrist> ReinH: it's easier for newbies
09:19:25 <piskrist> ReinH: but the formatting thing looks cool
09:19:54 <michaelt> ReinH: Oh, yes, I wasn't objecting to anything, just making a point to mrenaud
09:20:13 <HeladoDeBrownie> I look at printf more as "Look, Haskell can do variadicity too!" as opposed to anything particularly practical
09:20:13 <ReinH> I don't really think printf "foo %s" aString is *easier* than "foo " <> aString, and lack of type safety might very well make it hard in ways that are quite difficult to understand
09:20:39 <ReinH> given that GHC already has mediocre type error messages and these type errors will be basically impossible to understand
09:22:47 <CodeWeaverX>  I suppose because lots and lots of people already know printf inside and out, and it has a very very compact means of specifying things like padding, leading characters, bases, decimals to use, enabling and disabling scientific notation, and so on.
09:23:06 <ReinH> I just don't think it's worth introducing incredibly complex type machinery to format a string.
09:23:35 <CodeWeaverX> I find formatting output in haskell a bit of a nuisance in comparison, frankly.  So to each their own.  (I mean, I’ll try to do it a haskelly way anyway, for type safety, but its still a nuisance)
09:23:43 <ReinH> Especially when the downside is runtime errors because you used, e.g., %s instead of %d
09:24:16 <CodeWeaverX> *shrug*
09:24:19 <ReinH> I like the idea of formatting libraries, I just don't like the implementation of printf. Chris's new formatting library is nice.
09:24:43 <JagaJaga> If I need mutable vector of my data type, it better to use what? Array, vector? Or on what does it depend? I'm going to use it in `forever`, modify and searching elements oftenly.
09:24:48 <CodeWeaverX> Actually its a fair point — what *would* you recommend as an alternative that *isn’t* onerous to use?
09:26:11 <ReinH> Chris's library is pretty good, and I imagine one could write a quasiquoter for it pretty easily that would reduce the " % " line noise.
09:26:22 <CodeWeaverX> Jagajaga: Data.Vector.Mutable perhaps?
09:26:30 <CodeWeaverX> I don’t know what Chris’s library is called.
09:26:43 <ReinH> JagaJaga: Given that this is Haskell, why do you need a mutable data structure?
09:26:50 <ReinH> CodeWeaverX: http://chrisdone.com/posts/formatting
09:27:57 <CodeWeaverX> Ah hah, gotcha.  I’ll check it out.  I’m certainly up for less painful ways of controlling formatting.
09:28:20 <ReinH> CodeWeaverX: and for Text and ByteString there are various builder libraries
09:28:21 <JagaJaga> ReinH: well, I'm going to support live table of current connections. Connection can be created and they can be closed. What's the way to store them then? :)
09:28:48 <wz1000> Is there any better way to write '\x -> x { f = a }'?
09:29:38 <geekosaur> barring lens/fclabels/etc., no
09:30:05 <ReinH> JagaJaga: a Data.IntMap?
09:30:31 <ReinH> or Data.Map if you want to use non-Int keys
09:31:16 <ReinH> JagaJaga: how many connections are you talking about?
09:31:43 <michaelt> wz1000: in lens it's f .~ a  where f is a lens not an ordinary field
09:31:49 <ReinH> A Vector is a reasonable way of storing something like a connection pool, for sure
09:31:59 <ReinH> You don't even necessarily need the Mutable interface
09:32:19 <michaelt> > _1 .~ "Bye" $ ("Hi", 19)
09:32:20 <lambdabot>  ("Bye",19)
09:32:22 <JagaJaga> ReinH: no, that's now a map. In fact it's like [MyDataType]. I need to add/delete items. About 0-1000 records.
09:32:52 <JagaJaga> s/now/not
09:34:18 <CodeWeaverX> Unless you need O(1) lookup and mutation, a map does avoid having to do your updates outside of pure code.
09:34:36 <michaelt> wz1000: with the standard lens libraries you write (or have derived) something more powerful than the record accessor f in '\x -> x { f = a }'
09:35:13 <CodeWeaverX> …and still have them pretty performant.
09:35:15 <ReinH> JagaJaga: I would probably use a Map.
09:35:26 <JagaJaga> CodeWeaverX: Ineed mutation of the i'th element :( Anyway map is good this point? New map every modification..
09:35:48 <ReinH> That's fine.
09:35:48 <JagaJaga> ReinH: CodeWeaverX well, ok, I will try. Thx, guys :)
09:35:50 <CodeWeaverX> Well, that would be true of a non-mutating vector — new vector every update.
09:36:07 <ReinH> Purely functional data structures have great GC behavior.
09:36:08 <CodeWeaverX> But with a map, the map is built as a tree, usually, or something similar — and branches are shared.  Rebuilds are tiny.
09:36:29 <CodeWeaverX> So an update takes… I think O(log n) time just like an insert.
09:36:38 <ReinH> And you're only updating a portion of the structure, the rest is shared
09:36:42 <CodeWeaverX> Right.
09:36:53 <JagaJaga> Got it. Nice.
09:37:09 <ReinH> JagaJaga: If you're using Haskell, you shouldn't shy away from using purely functional data structures. ;)
09:37:18 <ReinH> We've gotten pretty good at them.
09:37:25 <JagaJaga> ReinH: ^_^
09:37:38 <CodeWeaverX> Exactly.  I mean, there are some rare situations where you have to do mutations, but this *probably* isn’t one of them.
09:38:33 <CodeWeaverX> Actually for, say, only a thousand connections, even a non-mutating vector that has to be copied probably wouldn’t be that bad.
09:38:33 <JagaJaga> I'm right that -O2 disables GC?
09:38:50 <michi7x7> JagaJaga: and leak memory around?
09:39:13 <CodeWeaverX> Nothing disables the GC at the compiler level.  You can tell the runtime to run absurdly infrequently if you wish.
09:39:21 <JagaJaga> michi7x7: no, i mean some other ways of memory managing.
09:39:25 <JagaJaga> CodeWeaverX: oh, ok.
09:39:46 <CodeWeaverX> But high optimizations often optimize away intermediate lists and box up structures tightly, and strictify functions, where appropriate, reducing GC use.
09:40:41 <CodeWeaverX> Best bet:  Write the code first, optimize later with equivalent, but less memory-gobbling operations by profiling where your bad use cases are.
09:40:50 <CodeWeaverX> GHC has some great profiling tools.
09:40:54 <michi7x7> I think I got something wrong when using parallel evaluation... https://gist.github.com/michi7x7/777da6cec047c4f60e04
09:41:09 <pjdelport> No point in optimizing non-bottlenecks, even when they're slow.
09:41:29 <michi7x7> line 27 should spawn m evaluation threads for the elements of the sol array... but I don't get any speed improvement at all
09:41:32 <ReinH> JagaJaga: for reference, bos's "high-performance striped pooling abstraction" uses a Vector of lists, where the common use case is a vector of length 1, so it only adds overhead on the list of pool items.
09:41:45 <CodeWeaverX> True.  Also, without the GC, Haskell’s sort of screwed.  You don’t *do* manual memory management, generally.  It has to be done once in a while.  But it is one of the best GCs going.
09:42:29 <pjdelport> michi7x7: Are you compiling and running with all the right flags for multicore?
09:42:41 <michi7x7> pjdelport: -threaded -O2
09:42:45 <ReinH> So even lists are "high performance" enough for some applications
09:42:55 <michi7x7> no rtsopts and no -Nx
09:42:58 * geekosaur wonders if that's just building thunks in parallel
09:43:00 <merijn> michi7x7: Are you actually spawning multiple capabilities?
09:43:27 <merijn> michi7x7: Right, without rtsopts and no -N there won't be multiple capabilities to run your threads in parallel...
09:43:38 <pjdelport> michi7x7: Maybe run with +RTS -sstderr (IIRC) and see if the sparks are running or fizzling?
09:43:46 <michi7x7> merijn: I used setCapabilits 2
09:43:54 <pjdelport> merijn: The code does do setNumCapabilities 2
09:44:27 <mrenaud> michaelt, ReinH: Thanks!
09:44:56 <pjdelport> michi7x7: "if n < 1 then sol `using` parList rseq else sol"
09:45:02 <pjdelport> michi7x7: Is that check the right way around?
09:45:30 <michi7x7> pjdelport: first level, spawn m workers... well gotta go now
09:45:32 <michi7x7> be back later
09:45:41 <pjdelport> michi7x7: Ah, okay.
09:46:22 <JagaJaga> ReinH: CodeWeaverX thx.
09:56:32 <CodeWeaverX> Okay, the “formatting” library’s pretty nifty.  Adopted. ;)
10:02:41 <ReinH> CodeWeaverX: :)
10:05:12 * hackagebot HSmarty 0.2.0.2 - Haskell implementation of a subset of the PHP-Smarty template language  http://hackage.haskell.org/package/HSmarty-0.2.0.2 (AlexanderThiemann)
10:18:44 <Raghs> what is the desugared version of http://lpaste.net/113161
10:20:15 <Aleksejs> @undo do{a <- logNumber 3; b <- logNumber 5; tell ["Gonna multiply these two"]; return (a*b)}
10:20:16 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> tell ["Gonna multiply these two"] >> return (a * b)
10:20:22 <Aleksejs> Raghs:
10:21:13 <Raghs> Aleksejs thanks.
10:21:52 <Raghs> i thought that the desugared would help me understand tell
10:23:11 <ReinH> Raghs: you should look at the definition of tell and the definition of >>=
10:26:21 <fragamus> did you guys ever marvel at all of the category theory that has gone into constructing Linear
10:26:33 <simpson> Yes.
10:26:38 <ReinH> fragamus: Yes.
10:26:41 <fragamus> it is absolutely amazing
10:27:04 <CodeWeaverX> Not really.  I’m a bit of a pragmatist.;)
10:29:31 <Aleksejs> Could anyone help me install haskell-platform on Arch@RPi?
10:29:55 <Aleksejs> tried to ask on #archlinux and #archlinux-arm - no response
10:30:17 <Aleksejs> tutorials on the internet offer to add some repo that responses with 404
10:32:20 <merijn> Aleksejs: There is not haskell platform on ARM, afaik
10:32:25 <phaazon> @hoogle e -> Maybe a -> Either e a
10:32:28 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
10:32:28 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
10:32:28 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
10:32:32 <haasn> fragamus: I think the amount of category theory that has gone into constructing lens is more impressive
10:32:33 <phaazon> I guess it’s tag
10:32:38 <phaazon> but not sure
10:32:47 <merijn> ARM is only a tier2 support platform for GHC atm, so you need to get a GHC that can cross-compile
10:32:48 <haasn> Although linear and lens are technically related :)
10:32:55 <fragamus> well the reason he made lens was to make Linear
10:33:03 <fragamus> yah
10:33:10 <phaazon> oh it’s note
10:33:14 <merijn> Aleksejs: Also, you probably don't wanna run GHC on a Raspberry Pi, they have very little resources and GHC is a hungry beast
10:33:39 <fragamus> but a gentle beast
10:33:52 <fragamus> when treated with consideration
10:33:57 <Aleksejs> :)
10:34:01 <merijn> :t maybe (Left "error") Right -- phaazon
10:34:02 <lambdabot> Maybe b -> Either [Char] b
10:34:12 <merijn> eh
10:34:26 <merijn> :t \e -> maybe (Left e) Right -- I guess
10:34:28 <lambdabot> a -> Maybe b -> Either a b
10:34:48 <phaazon> merijn: yeah, it’s already packed in errors
10:34:51 <phaazon> Control.Error.Util
10:35:15 * hackagebot git-annex 5.20141024 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141024 (JoeyHess)
10:35:20 <Aleksejs> I wanted to experiment with haskell+gpio. I see here that there is ghc version for arch@rpi http://www.haskell.org/haskellwiki/Raspberry_Pi#GHC_Status
10:41:39 <simpson> Is there a library function Eq a => [a] -> [a] -> [a] which concats two lists, optionally overlapping them if their suffix and prefix overlap?
10:42:51 <shiona_> not in any library I've come across
10:43:56 <CodeWeaverX> Intriguing problem though.  Could be tricky to get bulletproof, especially if the prefix and suffix in question have near repeats.
10:45:29 <simpson> Yes, it is, isn't it.
10:46:13 <haasn> xs ++ dropElementsWhileEqualTo (tail xs) ys -- ?
10:46:16 <haasn> s/tail/reverse/
10:46:35 <haasn> Oh, no. That would be the wrong order
10:47:08 <narendraj9> :t [1, [1,2,3]]
10:47:09 <lambdabot> (Num [t], Num t) => [[t]]
10:47:18 <narendraj9> Why?
10:47:38 <haasn> narendraj9: Lists are homogeneous in Haskell, so in [x, y] the types of x and y have to be identical
10:47:41 <mauke> why not?
10:47:48 <haasn> So here you're saying 1 has the same type as [1,2,3]
10:48:00 <haasn> Which requires that 1 be a list
10:48:05 <haasn> (Which requires the Num [t] instance)
10:48:07 <narendraj9> Can 1 be a list?
10:48:27 <HeladoDeBrownie> 1 is a polymorphic value which could potentially be of a list type
10:48:32 <HeladoDeBrownie> @type 1
10:48:33 <lambdabot> Num a => a
10:48:52 <HeladoDeBrownie> However, in practice, we aren't likely to have an appropriate Num instance in scope
10:49:02 <HeladoDeBrownie> > [1] + [2]
10:49:04 <lambdabot>  No instance for (GHC.Show.Show t0)
10:49:04 <lambdabot>    arising from a use of ‘M892783710202711318110648.show_M8927837102027113181...
10:49:04 <lambdabot>  The type variable ‘t0’ is ambiguous
10:49:04 <lambdabot>  Note: there are several potential instances:
10:49:04 <lambdabot>    instance [safe] GHC.Show.Show
10:49:05 <haasn> It's possible in theory to construct a sensible Num [t] instance
10:49:09 <HeladoDeBrownie> Woops
10:49:14 <HeladoDeBrownie> > ['a'] + ['b']
10:49:15 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
10:49:16 <lambdabot>    arising from a use of ‘GHC.Num.+’
10:49:17 <narendraj9> How can one make 1 a list?
10:49:18 <haasn> But it's not usually done
10:49:25 <shiona_> http://pastebin.com/B3Bb9g4L
10:49:37 <shiona_> might not be correct, but should be a start
10:50:01 <geekosaur> narendraj9, numeric literals get fromInteger or fromRational applied to them as appropriate
10:50:17 <geekosaur> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
10:50:29 <mauke> narendraj9: create an instance of Num [a]
10:50:57 <geekosaur> so if you used a literal 1 in a context which required an instance of Num [a] and such an instance were in scope, its fromInteger would be used to turn it into a list
10:52:24 <narendraj9> Okay. I see.
10:54:40 <rai> liftM seems like a map of sorts
10:54:47 <mauke> map is a liftM
10:54:53 <rai> is there a relation to fmap
10:54:59 <mauke> it's the same thing
10:55:01 <kqr> liftM is fmap but specialised for monads
10:55:07 <rai> ah great
10:55:12 <mauke> :t [fmap, liftM, map, (<$>), liftA]
10:55:13 <lambdabot> [(a -> b) -> [a] -> [b]]
10:55:17 <kqr> much like map is fmap but specialised for lists
10:55:45 <geekosaur> liftM is kinda historical
10:55:46 <kqr> and liftA is fmap but specialised for applicatives
10:55:48 <kqr> yeah
10:55:51 <geekosaur> well, will be soon, we hope
10:55:51 <kqr> all the liftM* functions are
10:56:06 <phaazon> ok, my EDSL shading language starts to be something!
10:56:29 <phaazon> http://lpaste.net/113165
10:56:30 <phaazon> :)
10:56:31 <geekosaur> Haskell doesn't currently force Monad-s to be Functor-s, so you can't depend on fmap being usable on them, whereas liftM is written using only Monad
10:58:12 <kqr> won't it in 7.8 or 7.10 or something?
10:58:20 <geekosaur> 7.10, yes
10:58:21 <kqr> it was too long since I updated myself on the current state of affairs
10:58:27 <kqr> maybe 7.8 is out already
10:58:37 <geekosaur> 7.8's been out a couple months
10:58:55 <kqr> is there a plan for when 7.10 is ready?
10:59:01 <kqr> there was something else about it I really liked
10:59:02 <geekosaur> we're on 7.8.3 and 7.8.4 is planned "soon" (of ocurse, look how well that's worked with the rest of 7.8 :p )
10:59:22 <kqr> it being 7.10
11:00:20 <simpson> Actually, related: Is there a data structure for storing an ordered subset of an enumeration?
11:00:53 <jle`> good catch rai
11:01:10 <geekosaur> they're talking about february-ish next year for 7.10, last I heard
11:01:17 <kqr> ah
11:01:23 <geekosaur> per https://ghc.haskell.org/trac/ghc/blog/weekly20141020
11:01:23 <kqr> maybe it's partial type signatures that looks really neat
11:01:38 <piskrist> is there some way to use libssh4 from haskell?
11:01:44 <piskrist> or at least it's capabilities
11:02:01 <ReinH> CodeWeaverX: Fun fact: the type in formatting is an instance of Category so you can use `"text is: " . text'  instead of `"text is: " % text' if you replace Prelude.(.) with the one from Category.
11:02:07 <piskrist> I found some libraries like simplessh and libssh2 but it seems they can't connect to my servers
11:02:32 <piskrist> simply because the libssh2 doesn't support the newer cipher
11:02:34 <piskrist> s
11:03:30 <phaazon> *Ash> let e = vec2 (int 1) (lam "x" ("x" .* int 10) .$ int 2)
11:03:30 <phaazon> *Ash> typecheck FloatE e
11:03:30 <phaazon> Left (TypeError FloatE IntE)
11:03:35 <phaazon> :)
11:03:45 <phaazon> I would have love to have that at compile-time
11:03:47 <phaazon> but well
11:03:53 <phaazon> it’s at least working
11:04:43 <ReinH> CodeWeaverX: Oh, I lied, it isn't an instance of Category, but it could be made one.
11:05:10 <phaazon> *Ash> let e = let_ [("x",int 3)] $ "x" .+ float 1
11:05:10 <phaazon> *Ash> polyTypecheck e
11:05:10 <phaazon> Right FloatE
11:05:13 <phaazon> oh shit :(
11:05:32 <CodeWeaverX> ReinH:  This doesn’t help me as I don’t really understand Category yet.
11:05:42 <ReinH> Ok :)
11:05:55 <ReinH> Category is for things that are like functions (in that they have an id and can be composed)
11:06:20 <ReinH> One way to look at it is as a generalization of Monoid where the type can change
11:07:35 <CodeWeaverX> I’m a pragmatic programmer.  I really appreciate the abstractions in haskell, but sometimes decoding the things people say in here is an exercise in university level academia that I don’t need (even if I frequently want to understand) in “getting things done”.  So… digging into abstractions like Monoid, Category, Arrows, and so on take me time to figure out, especially wnhen their actual utility for things I want to sol
11:07:54 <ReinH> CodeWeaverX: fine by me :)
11:08:05 <CodeWeaverX> Mmm, good straightforward definition of Category.  I can live with that.
11:08:24 <CodeWeaverX> Don’t get me wrong.  Someone brings up Arrows and I go looking.  It *is* interesting.
11:08:30 <kqr> CodeWeaverX, despite their mathematical names, they are very pragmatically implemented in haskell
11:08:56 <kqr> CodeWeaverX, learning them is well worth it if you want to make nicer code
11:09:00 <exio4> "a generalization of monoid where the type can change" I like that definition!
11:09:03 <ReinH> CodeWeaverX: there are some laws: id should be an identity, i.e., f . id = f and id . g = g
11:09:22 <ReinH> exio4: A monoid is a one-object category :)
11:09:38 <ReinH> And composition should be associative: f . (g . h) = (f . g) . h
11:09:44 <ReinH> That's about it.
11:10:18 <CodeWeaverX> Oh, I realize that.  I *love* that.  But there’s a heavy presumption in chat and documentation to know a lot of terminology that actually clutters the issue for beginners.  I totally understand how a lot of people find Haskell unapproachable even though, once you get over the hump, its remarkably easy to do a lot of things.
11:10:18 <CodeWeaverX> I mean, I’d like to think I’m no longer an outright beginner, but I do roll my eyes a lot in here. ;)
11:10:43 <kqr> yeah
11:10:50 <kqr> it's sort of like when you first started programming
11:10:51 <ReinH> CodeWeaverX: That's why I prefer to explain things simply if I can do so without misleading too much
11:11:06 <kqr> and people were talking about classes and imports and methods and variables and conditionals and such
11:11:08 <CodeWeaverX> See, that I do like.  So that’s why I’m getting more determined to get further over the hump.
11:12:13 <CodeWeaverX> Well, sure, but all that stuff still applies, and a lot of the terminology isn’t useful to pragmatic understanding.  Its a great label to use after the fact, but its opaque when people talk in what appears to be greek about things that are pretty ordinary.
11:12:18 <CodeWeaverX> Anyway, enough about my quibbles.
11:12:38 <CodeWeaverX> Fun stuff to learn.
11:12:38 * CodeWeaverX catches up with the room in a burst
11:15:09 <begriffs> How long does it take hackage to build docs? I uploaded a candiate package yesterday and its docs are still unavailable.
11:15:15 <CodeWeaverX> kqr:  Its interesting you should say ‘it makes for nicer code’, but that’s often in the eye of the beholder.  ‘shorter’ or ‘more typesafe’ or ‘more composiable’ might be a measurable metric, but I’ve seen some stuff that looks ‘clever’…. at the cost of any readability at all.
11:15:15 <phaazon> oh gosh
11:16:07 <phaazon> nvm
11:16:08 <phaazon> :D
11:16:27 <mauke> we should just say Category is a design pattern
11:17:25 <exio4> design patterns in the FP world are nicer
11:17:48 <merijn> CodeWeaverX: Most of my category theory knowledge I picked up just from picking up the occasional discussion here :p
11:17:55 <CodeWeaverX> Not sure moving to buzzwords is better, but it does have the advantage of being recognizable as a term to imperative coders.
11:18:17 <merijn> CodeWeaverX: tbh, Category is like the simplest typeclass in existence :)
11:18:28 <CodeWeaverX> merijn:  Oh, fair enough, I’ve probably got more in my head than I realize by the sheer act of getting any of my bigger programs to compile, and studiously avoiding manual recursion. ;)
11:18:29 <clrnd> why is haskell so sexy?
11:18:53 <phaazon> clrnd: because it’s pure
11:19:20 <merijn> CodeWeaverX: I mean if you understand function composition "(a -> b) -> (b -> c) -> (a -> c)" and id "a -> a" you already understand the entire Category class :)
11:19:28 <CodeWeaverX> merijn:  That’s not a selling point without knowing both its properties, and what it actually buys one.  I can make a pretty simple typeclass that’s completely useless. ;)  But anyway.
11:19:29 <merijn> :t (Control.Category..)
11:19:30 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
11:19:38 <merijn> :t (Control.Category.id)
11:19:39 <lambdabot> Category cat => cat a a
11:19:53 <merijn> CodeWeaverX: Mentally replace "cat" with "->" and you see what it does :)
11:19:55 <CodeWeaverX> Fair enough, merijn.  Category is probably a bad example of what I’m quibbling about anyway.
11:20:31 <benzrf> gatecories are breddy gool
11:20:33 <jle`> CodeWeaverX: other languages have their fair share of terminology too
11:20:34 <merijn> CodeWeaverX: On the one hand I agree that names like "monoid" can be opaque, on the other hand it's nice to have precise, non-ambiguous names for things
11:20:44 <jle`> CodeWeaverX: terminology that is opaque to newcomers
11:20:46 <CodeWeaverX> I agree with all of that. ;)
11:20:56 <jle`> the difference in Haskell is that we pick names that aactually have well-defined meanings elsewhere
11:21:01 <jle`> instead of making up names without meaning :P
11:21:17 <merijn> CodeWeaverX: In most other languages people seem to have a hard time settling on precise non-ambiguous terminology, so you don't only get the problem of not knowing terms, but no one else knowing a precise definition either!
11:21:25 <CodeWeaverX> …except they often have no meaning to people coming from other languages , particularly imperative ones.
11:21:34 <merijn> Look at the occasional "is X design pattern Y?" discussio
11:21:40 <jle`> CodeWeaverX: neither do those opaque words in other progrmaming languages
11:21:42 <jle`> so what's the difference?
11:21:43 <CodeWeaverX> Hence, opaque.  Not permanently opaque, but opaque nonetheless.
11:21:49 <merijn> CodeWeaverX: "dependency injection" has no meaning to me either
11:21:56 <jle`> i learn a new progrmaming language, there are opaque words there
11:21:58 <CodeWeaverX> There is none.  I didn’t imply anything of the sort.
11:22:01 <jle`> ah, mk
11:22:13 <jle`> but then in this case it seems that haskell is even better than other languages in this respect
11:22:24 <jle`> both haskell and other languages have their share of opaque terminology
11:22:30 <merijn> Every time I hear the java guys say "dependency injection" I have to look it up. (It subsequently go, "wait, why is this even a problem?")
11:22:32 <ReinH> It's not *just* whether you know the word or not, it's the amount of effort required to learn the word
11:22:33 <jle`> but in haskell, the words are picked to be unambiguous
11:22:41 <ReinH> "string" is easier to learn than "pointer"
11:22:44 <CodeWeaverX> Not in terms of getting programs actually written.  Perhaps in academic exercises.
11:22:58 <ReinH> "function" is easier to learn than "hylomorphism"
11:23:15 <ReinH> We can't make hylomorphisms easier to learn by using a smaller word.
11:23:47 <CodeWeaverX> Indeed.
11:24:03 <ReinH> There are difficult concepts in other languages, but I'd say Haskell exposes you to a fair amount more than most.
11:24:04 <CodeWeaverX> On the other hand, if it just means ‘function’ to people trying to solve a problem you’ve bought nothing.
11:24:22 <ReinH> (At least it doesn't expose you to pointers unless you ask it to)
11:24:28 <CodeWeaverX> And its probably worth learning it all, eventually.
11:24:35 * michaelt totally got it when he started just calling them 'hylos' 
11:24:36 <CodeWeaverX> Don’t get me wrong, I appreciate conciseness and correctness.
11:24:59 <CodeWeaverX> *snort*
11:25:09 <CodeWeaverX> Missing the point, but hilarious. ;)
11:25:19 <monochrom> consider "functor"
11:25:21 <ReinH> CodeWeaverX: Maybe not even. I'm sure you could have a successful career without ever understanding "zygohistomorphic prepromorphisms" ;)
11:25:46 <CodeWeaverX> OUCH.
11:25:54 <ReinH> heh
11:26:09 <CodeWeaverX> Successful career or no, I want a successful solution to a problem. ;)
11:26:09 <michaelt> ReinH: thems I call 'zhps'
11:26:27 <CodeWeaverX> Anyway, I’m sounding like an old grump, and that wasn’t really my intent.
11:26:40 <CodeWeaverX> *opens up hackage description of Category for giggles*
11:27:02 <ReinH> CodeWeaverX: you aren't :)
11:27:08 <jle`> ah, them ol' zhps
11:27:13 <jle`> love em, hate em, can't live without em
11:27:14 <ReinH> jle`: :p
11:27:18 <ReinH> Yes. Yes you can.
11:27:27 <ReinH> Now, natural transformations you actually can't live without.
11:27:32 <ReinH> At least not in Haskell
11:27:53 <ReinH> Unless you avoid using polymorphic functions somehow.
11:27:58 <jle`> i can try
11:28:00 <robert__> hello, is this an appropriate place to ask about absolute beginner help with haskell?
11:28:02 <jle`> don't tell me what i can't do
11:28:04 <ReinH> jle`: good luck
11:28:06 <ReinH> robert__: yes!
11:28:10 <jle`> :D
11:28:12 <ReinH> jle`: I didn't.
11:28:13 <ReinH> :p
11:28:28 <michaelt> robert__: oh yes.
11:28:29 <piskrist> how do you ssh in haskell?
11:28:31 <jle`> robert__: we just sit around here all day waiting for absolute beginners to ask for help
11:28:32 <jle`> so
11:28:36 <jle`> thank you for coming
11:28:39 <robert__> ok cool
11:28:45 <clrnd> phaazon, not only, because I said that after playing with MVars, it's like sexy imperative programming
11:28:46 <jle`> :)
11:28:58 <merijn> jle`: I only do that when our development machines are down *again*
11:29:07 <michi7x7> pjdelport: did you find anything suspicious in my horrible code?
11:29:10 <merijn> clrnd: Haskell's my favourite imperative language. No joke :)
11:29:16 <jle`> you have development machines?
11:29:21 <ReinH> piskrist: Have you tried something like simplessh?
11:29:29 <jle`> what ever happened to ol fashioned punch cards
11:29:37 <jle`> it's a lost art form
11:29:38 <piskrist> ReinH: that's only libssh2, it doesn't work with a lot of ciphers and stuff
11:29:42 <monochrom> Haskell is also SPJ's favourite imperative language :)
11:30:02 <merijn> jle`: I can't run our code on my desktop :>
11:30:02 <ReinH> piskrist: it's at least one answer to "how do you ssh in haskell?" :)
11:30:20 <ReinH> monochrom: I've been very happy with it, especially with strict/streaming IO.
11:30:28 <robert__> I am using a library computer and I am using an online IDE called fpcomplete and am completely baffled on how to print out or do something to verify what's in a list
11:30:39 <ReinH> monochrom: I'm currently converting some bash scripts to Haskell with Data.Conduit.Process and it's wonderful.
11:30:40 <piskrist> ReinH: I'm looking into the bindings but it seems updating it will be harder than just switching the libraries and renaming some functions
11:30:44 <monochrom> jle`: merijn's development machines use punch cards. thus the two of you are reconciled :)
11:30:55 <robert__> Something about using non IO function in main
11:30:56 <jle`> robert__: are you following some sort of book or course?
11:30:57 <simpson> > let f l = zip (inits l) (tails l) in f [a, b, c, d] -- hm, is this the best way?
11:30:58 <lambdabot>  [([],[a,b,c,d]),([a],[b,c,d]),([a,b],[c,d]),([a,b,c],[d]),([a,b,c,d],[])]
11:31:10 <ReinH> robert__: Are you baffled by FP Complete's interface or by how to print something in Haskell?
11:31:14 <funrep> i also use haskell for scripts :)
11:31:18 <ReinH> You can print many things with `print':
11:31:20 <ReinH> > print [1,2,3]
11:31:21 <lambdabot>  <IO ()>
11:31:21 <robert__> yea, but the thing is that I don;t have GHCI
11:31:34 <funrep> :t print
11:31:35 <ReinH> (That's lambdabot showing you that it *would* do IO there)
11:31:35 <lambdabot> Show a => a -> IO ()
11:31:36 <michaelt> Haskell is even Robert Harper's favorite imperative programming language.  He favors sml for functional programming.
11:31:38 <funrep> ^
11:31:42 <jle`> main has to be an IO action...so... (print x) gives you an IO action that prints out x
11:31:43 <monochrom> robert__: consider "main = print [False, True]"
11:31:45 <Aleksejs> robert__: main = print [1,2,3]
11:31:49 <jle`> FPcomplete then takes that IO action and then runs it for you
11:31:56 <ReinH> robert__: iirc there's some sort of console in the FP Complete IDE
11:32:05 <ReinH> jle`: if you have a main, I believe it will attempt to run it for you.
11:32:07 <monochrom> haha michaelt
11:32:10 <ReinH> er
11:32:14 <ReinH> robert__: ^
11:32:22 <jle`> FPcomplete can only run IO actions, so.  it's handy to have some useful ones to work with
11:32:24 <ReinH> robert__: You might look at some of FP Complete's documentation for help as well
11:32:29 <jle`> to give to FPComplete so it can run it for you
11:32:39 <jle`> some useful ones are (print x), the IO action that prints out x
11:32:48 <sivteck> robert__, if you could watches in it, try https://www.youtube.com/watch?v=qDgz63n_4t4
11:32:49 <jle`> (putStrLn x), the IO action that prints out the *string* x
11:32:53 <jle`> um
11:32:55 <jle`> ...that's all i got.
11:33:03 <ReinH> ha
11:33:10 <ReinH> That's all you need.
11:33:11 <jle`> i can't imagine other ones being useful in fpcomplete
11:33:14 <jle`> does it do interactive stuff?
11:33:29 <sivteck> s/watches/watch videos/
11:33:50 <robert__> ok cool it was the "do" that wouldn't let me print
11:33:54 <jle`> in real life haskell code there are a lot more neat IO actions that you can get GHC (a haskell compiler) to run for you.  but in FPcomplete those should be all you need
11:34:44 <ReinH> sivteck: I like how the fake screen is curved for no reason to make it harder to read :D
11:34:47 <robert__> So what's the difference between print and printStrLn?
11:34:53 <ReinH> Kind of a cool use of green screen though
11:34:53 <robert__> Like what does the "do" do?
11:34:55 <ReinH> :t print
11:34:56 <lambdabot> Show a => a -> IO ()
11:34:57 <ReinH> :t printStrLn
11:34:58 <lambdabot>     Not in scope: ‘printStrLn’
11:34:59 <lambdabot>     Perhaps you meant one of these:
11:34:59 <lambdabot>       ‘putStrLn’ (imported from Prelude),
11:35:00 <sivteck> ReinH, hehe
11:35:05 <Aleksejs> :t putStrLn
11:35:06 <lambdabot> String -> IO ()
11:35:09 <ReinH> robert__: Well, printStrLn doesn't exist ;)
11:35:22 <exio4> putStrLn . show = print
11:35:25 <Aleksejs> :t print 5
11:35:26 <lambdabot> IO ()
11:35:31 <ReinH> robert__: print takes things that can be shown (are instances of the typeclass Show), putStrLn takes strings
11:35:32 <robert__> err
11:35:33 <Aleksejs> :t putStrLn 5
11:35:34 <lambdabot>     No instance for (Num String) arising from the literal ‘5’
11:35:34 <lambdabot>     In the first argument of ‘putStrLn’, namely ‘5’
11:35:34 <lambdabot>     In the expression: putStrLn 5
11:35:35 <robert__> putStrLn
11:35:39 <cutgovspend> does haskell play well with unix files?
11:35:50 <ReinH> cutgovspend: yes. Any more specific concerns?
11:36:01 <michaelt> cutgovspend: you can open them, for example, also write them.
11:36:05 <jle`> robert__: "do" lets you combine IO actions.  so if you have two IO actions, you can put them one after another in a `do` block to make them one giant IO action that does all of those things one after the other.
11:36:05 <ReinH> @where lyah
11:36:05 <MitchellSalad> lol
11:36:05 <lambdabot> http://www.learnyouahaskell.com/
11:36:11 <ReinH> robert__: ^ might be a good place for you to start
11:36:14 <jle`> robert__: but that's not too important for now :)
11:36:38 <jle`> without ways to combine IO actions, haskell IO would be kind of boring
11:36:38 <ReinH> robert__: I also have a list of recommended reading material if you're ever interested: http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
11:37:02 <ReinH> jle`: (pedantic note that *do* doesn't do that. >>= does that. :p)
11:37:19 <robert__> cool I'll take a look
11:37:19 <jle`> which statement is that in reference to?
11:37:35 <michaelt> cutgovspend: but what do you want to do? Is the difficulty about the names of files, or the use of them or ...?
11:37:35 <ReinH> jle`: "do lets you combine IO actions."
11:38:04 <cutgovspend> I want to make a lot of money with websites and consulting.
11:38:14 <cutgovspend> build a metal house
11:38:28 <ReinH> cutgovspend: This is a Haskell channel. Let's talk about Haskell.
11:38:48 <michaelt> Hm, yes
11:38:57 <ReinH> You can talk about metal houses in #haskell-blah if you want.
11:40:18 <JagaJaga> Isn't there a way to print map's elements on new lines? I mean `print map` -> `a \n b \n c` (smth like this, not `fromList[a,b,c]`)
11:40:52 <jle`> you can mapM print, if that's what you are looking for
11:40:54 <Aleksejs> > putStrLn "a\nb"
11:40:55 <lambdabot>  <IO ()>
11:40:59 <exio4> mapM_ print . fromList?
11:41:08 <exio4> er
11:41:08 <mauke> hwat
11:41:10 <exio4> toList
11:41:29 <exio4> @type mapM_ print . M.toList
11:41:30 <lambdabot> (Show a, Show k) => M.Map k a -> IO ()
11:42:16 <cutgovspend> ok
11:42:29 <JagaJaga> exio4: thx.
11:42:32 <robert__> Is there a way to disambiguate or cast or something a generic function? For example I have a function "safetail xs = if null xs then [] else tail xs" and I want to "print (safetail [])" to make sure it works
11:42:32 <ReinH> Data.Map is a Traversable:
11:42:34 <ReinH> er, a Foldable:
11:42:36 <ReinH> :t F.traverse_ print (M.fromList [("key", "value")])
11:42:36 <lambdabot> IO ()
11:42:45 <cutgovspend> anyone using a haskell web framework? or lib? to make a dynamic site? any free online blog done in haskell?
11:42:47 <ReinH> You can traverse it directly without converting it to a list.
11:43:13 <Aleksejs> cutgovspend: happstack is pretty easy
11:43:19 <ReinH> cutgovspend: There are a number of web frameworks: yesod, snap, scotty, etc. hakyll is a statis site generator that can be used for blogging.
11:43:28 <ReinH> *static
11:43:28 <monochrom> robert__: no, safetail has a type error, and casting does not make sense for it.
11:43:53 <robert__> So I can't force the empty list to an empty list of ints
11:43:54 <robert__> ?
11:44:10 <monochrom> empty list of ints is still wrong type
11:44:27 <jle`> robert__: can you state what you are trying to do in types?
11:44:30 <mauke> monochrom: what type error?
11:44:38 <cutgovspend> anyonehere using one? got a site I can see?
11:44:39 <jle`> > drop 1 [1..10]
11:44:41 <lambdabot>  [2,3,4,5,6,7,8,9,10]
11:44:43 <jle`> > drop 1 []
11:44:44 <lambdabot>  []
11:44:47 <mauke> robert__: ([] :: [Int])
11:44:50 <phaazon> 20:32 #haskell: < clrnd> phaazon, not only, because I said that after playing  with MVars, it's like sexy imperative programming
11:44:50 <cutgovspend> hapsptack looks awesome, esp since don't need postgresql
11:44:53 <phaazon> yeah, well
11:44:58 <phaazon> I tend not to use them
11:45:04 <monochrom> mauke, in "safetail [False]", you have to unify the two types [a] and Bool
11:45:04 <robert__> Well so I wrote that function per a tutorial and I want to verify that it works
11:45:10 <ReinH> Um.
11:45:17 <robert__> So what I want to do is print the result so I can verify it
11:45:20 <mauke> monochrom: ... no?
11:45:32 <ReinH> > let safetail xs = if null xs then [] else tail xs in safetail [False]
11:45:33 <lambdabot>  []
11:45:34 <monochrom> oh, sorry, tail is not last
11:46:08 <jle`> cutgovspend: what is a free online blog? :P
11:46:08 <monochrom> well then, safetail is already correct, no casting needed, and no error.
11:46:17 <jle`> my blog is on scotty and is dynamic-ish
11:46:23 <jle`> http://jle.im
11:46:32 <jle`> but it doesn't do a lot of things you might expect from a site like auth
11:46:42 <jle`> source is on github
11:46:44 <ReinH> jle`: did you update the design? Looks good.
11:46:46 <cutgovspend> I use liverjournal, like free place to blast all my opinons to world
11:46:48 <cutgovspend> :)
11:46:59 <jle`> ReinH: no updates since i started it besides formatting posts, heh
11:47:02 <mauke> monochrom: casting is needed because [] is ambiguous
11:47:19 <monochrom> I see
11:47:34 <robert__> yea, how do I cast?
11:47:39 <ReinH> > show []
11:47:40 <lambdabot>  "[]"
11:47:41 <mauke> robert__: ([] :: [Int])
11:47:45 <mauke> like I said before
11:47:48 <ReinH> Defaulting.
11:47:50 <robert__> basically I want to do "print []"
11:47:50 <mauke> except it's not a cast, etc
11:47:53 <robert__> but that doesn't work
11:47:55 <mauke> robert__: HELLO
11:47:57 <cutgovspend> is a phd in compsci worth it? what do you learn aside from O(n) and omega(n) ?
11:48:08 <jle`> cutgovspend: this might be more appropriate for #haskell-blah :)
11:48:09 <johnw> cutgovspend: is it VERY worth it, if you have that interest
11:48:12 <cutgovspend> hek I don't even have a bachelors
11:48:19 <johnw> cutgovspend: but yeah, let's discuss in #haskell-blah
11:48:22 <robert__> ok cool that works thank you
11:48:33 <cutgovspend> I have 17 years in computer biz
11:48:37 <cutgovspend> ok moving to blah
11:48:53 <michi7x7> pjdelport: SPARKS: 724 (0 converted, 0 overflowed, 724 dud, 0 GC'd, 0 fizzled) ... well
11:49:44 <ReinH> michi7x7: welp
11:50:14 <michi7x7> ReinH: Seems like I'm evaluating a little late
11:50:15 <MitchellSalad> i thought you guys were kidding about #haskell-blah, it's actually a channel...
11:51:06 <michi7x7> I'm not using any strict folds or maps though (except those using rseq)
11:51:49 <jle`> dud
11:51:53 <jle`> that's a nice way to put it
11:53:30 <lpaste> simpson pasted “concatOverlap - can it be improved?” at http://lpaste.net/113166
11:53:36 <pjdelport> michi7x7: Maybe you need more than rseq?
11:53:51 <simpson> ^^^ I answered my concatOverlap question. Any suggestions on what could be done to improve its performance?
11:53:59 <cutgovspend> haskell seems to take little code
11:54:10 <cutgovspend> I saw an avg a list of numbers solution was quite short
11:54:13 <johannes__> I am starting to feel that Debian/Ubuntu is not the best distro for Haskell development and considering switching to Arch. Any useful advice on that from someone more experienced?
11:54:23 <michi7x7> pjdelport: I tried rdeepseq before (I also thought it made more sence... lemme check)
11:54:40 <simpson> johannes__: I use Debian for Haskell development and consider Arch to be insane. Debian's a little out of date but that doesn't really affect me.
11:54:56 <michi7x7> oh... wow SPARKS: 724 (724 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)
11:55:01 <kuznero> Hi All!
11:55:14 <ReinH> kuznero: Hi
11:55:23 <ReinH> I wish there was a tar conduit.
11:55:24 <johannes__> simpson: Do you use Haskell platform? Maybe it is better to stick to Debian but skip Haskell platform then?
11:55:44 <simpson> johannes__: I use the Platform shipped with Debian.
11:55:55 <ReinH> simpson: I wouldn't use platform packages for Haskell anyway (unless you're on nixos)
11:55:57 <cutgovspend> arch install is not fun anymore
11:56:06 <cutgovspend> prepare to write some crib notes before you reboot
11:56:08 <kuznero> what about nixos?
11:56:17 <cutgovspend> ubuntu 14.04 when upgraded seems ok
11:56:25 <ReinH> kuznero: it has up-to-date, well managed haskell packages.
11:56:44 <ReinH> And a system that actually provides some benefits for using it instead of cabal
11:56:56 <johannes__> hmm.. It just feels like more and more "Build for package x fails on ..."
11:56:59 <cutgovspend> why do some package installs barf on ur-bung-2?
11:57:08 <ReinH> johannes__: Are you using sandboxes?
11:58:31 <johannes__> yes.. sandboxes are definitely helping .. I probably need to get a better understanding of cabal in general
11:59:15 <ReinH> johannes__: A few helpful things from monochrom: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
11:59:42 <cutgovspend> if you have ghc
11:59:51 <cutgovspend> cant you install anything else with cabal?
12:00:10 <cutgovspend> can you upgrade ghc with cabal? openbsd here amd64, I am guessing an older ghc
12:00:20 <ReinH> cutgovspend: Yes. And no.
12:00:30 <cutgovspend> oh
12:00:31 <ReinH> But compiling ghc is relatively painless.
12:00:38 <kuznero> ReinH: do you think it is possible employ some ideas implemented in NixOS in the cabal system? AFAIU, NixOS is based on symlinking, which is not supported on Windows, but still ideas in NixOS might be rather fruitful...
12:00:45 <johannes__> the thing I don't understand is how/when to specify constraints. It feels like this is just a "black art"
12:00:46 <cutgovspend> openbsd aamd64 friendly?
12:00:57 <ReinH> cutgovspend: sure
12:01:14 <ReinH> johannes__: what do you mean by constraints?
12:01:37 <johannes__> I mean version constraints in the project build configuration
12:01:55 <ReinH> johannes__: Use lower bounds, don't use upper bounds without a reason.
12:02:26 <ReinH> i.e. you know that versions past X actually don't work with your package.
12:03:10 <johannes__> so I introduce a constraint if something becomes an issue, but not otherwise.. or?
12:03:14 <ReinH> (upper bound on next-major-version is usually ok though)
12:03:42 <ReinH> johannes__: pretty much. Pessimistic upper bounds (put in place *in case something breaks*) are a real annoyance.
12:04:04 <johannes__> yes I know :)
12:04:12 <yukko> cabal init makes upper bounds automatically, it's a bit silly
12:04:19 <ReinH> PVP (the package version policy) should imply that next-major-version upper bounds are correct
12:04:59 <ReinH> But it's even possible that the part of the API you're using doesn't change in that version, etc.
12:05:13 <ReinH> I would really prefer if people didn't use upper bounds unless they had a specific reason
12:05:21 <geekosaur> back to this argument, I see
12:05:39 <ReinH> yukko: yes :(
12:05:45 <geekosaur> yes, the massive breakage that comes from leaving upper bounds ourt never happens. just every couple months for people who weren't expecting anything, not a problem
12:06:18 <ReinH> I experience the other form of breakage *way* more often.
12:07:01 <geekosaur> the people who get broken by missing upper bounds are the ones who generally have no idea what to do about it; it;s spooky action at a distance
12:07:55 <ReinH> predicting which future versions of someone else's package will break yours is an impossible game to play
12:08:22 <ReinH> Testing your package against released versions frequently is not.
12:08:31 <johannes__> so, I have my brand new shiny cloud server running Debian with Haskell platform.. I have set up my sandbox and cabal install resource-pool and boom "Build fails". What to do now?
12:08:55 <ReinH> johannes__: describe the error in enough detail that we can help you? :)
12:09:58 <geekosaur> yes, I just have to field all the complaints from people who had no idea their stuff was about to shatter brittlely, it's never *your* problem as a dev, this of course makes it perfect
12:10:17 <geekosaur> never mind, yes, I know this is The Future where the little person is screwed
12:11:07 <ReinH> I think they are similarly screwed by upper bounds and that the screwing happens more often, but it isn't really worth rehashing.
12:11:43 <ReinH> johannes__ asked for opinions about upper bounds and I gave him mine.
12:11:46 <geekosaur> you "think". I don't usually have to help people deal with upper bounds that exist, only ones that don't exist
12:12:07 <ReinH> geekosaur: let's table it.
12:12:13 <monochrom> I throw in the data point I see.
12:12:38 <monochrom> yesterday, a beginner had a problem with a tutorial that instructs the beginner to use "base == 4.6.*"
12:12:44 <hexagoxel> ReinH, geekosaur: your arguments both seem off the mark.. the question is "which policy leads to less problems? leads to problems that are better to understand (for the user)? leads to problems that are faster to fix (for the maintainer)"
12:12:45 <johannes__> ReinH: But this surely is a dependency issue with resource-pool. In this case it is complaining that "Not in scope: `swapTVar'" during the build. I am just wondering if there is a workaround
12:13:12 <ReinH> johannes__: is swapTVar in scope? Do you expect it to be in scope?
12:13:24 <ReinH> I wasn't trying to start this argument again. I was answering a question.
12:13:48 <ReinH> Especially when my point of view is discredited because I used the word "think".
12:13:53 <johannes__> ReinH: the error comes from resource-pool
12:14:51 <ReinH> johannes__: interesting.
12:15:54 <kuznero> I was challenged to present benefits of Functional Programming and Haskell in particular to my team at workplace (mostly very experienced Java and C# developers). Can anybody recommend good slides or material that could help me making this presentation more effective? Maybe advices or code samples?
12:16:00 <hexagoxel> swapTVar seems to suggest stm>=2.3
12:16:14 <hexagoxel> + you need
12:16:50 <ReinH> Looks like a missing lower bound in resource-pool
12:16:57 <hexagoxel> correct
12:17:06 <ReinH> You should be able to add --constraint="stm >= 2.3" (I think that's the option syntax)
12:17:46 <johannes__> let me try that
12:18:18 <pjdelport> kuznero: Perhaps look at some of SPJ's stuff?
12:19:18 <monochrom> kuznero: Erik Meijer, who made much contribution to C#'s LINQ, had this to say: http://queue.acm.org/blog/?p=360
12:19:35 <kuznero> pjdelport: SPJ's slides are mostly to the point covering specific areas. In my case I need most a sales pitch I think
12:19:36 <monochrom> actually http://queue.acm.org/detail.cfm?id=2611829
12:19:48 <ReinH> hexagoxel: https://github.com/bos/pool/pull/20
12:20:08 <johannes__> ReinH: hexagoxel: yes that worked. Thanks.
12:20:09 <pjdelport> kuznero: For example https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency, which introduces STM
12:20:14 <ReinH> johannes__: sweet
12:20:49 <ReinH> kuznero: basically all of Marlow's Parallel and Concurrent Programming with Haskell is an advertisement for the awesomeness of Haskell and specifically GHC's runtime system
12:20:55 <hexagoxel> ReinH: you could have added && < 2.5      :p
12:20:56 <eacameron> I am disappointed in the lack of directionality communicated by Functor's <$>. I would prefer $> and <$ so that I can more easily chose between the two. But am I alone in this? Am I missing something?
12:20:59 <ReinH> (Book is available for free atm)
12:21:03 <ReinH> hexagoxel: But I did not.
12:21:06 <ReinH> hexagoxel: :)
12:21:16 <kuznero> monochrom: I happened to discuss this subject with Ms. Meijer himself on one of the conferences in Copenhagen. But, that does not stay in his way making a new MOOC on FP101 :)
12:21:22 <hexagoxel> ReinH: :)
12:21:48 <ReinH> eacameron: "lack of directionality"? In the order of arguments?
12:22:00 <ReinH> eacameron: Do you think $ has a lack of directionality as well?
12:22:04 <ReinH> Because they are analogous.
12:22:43 <ReinH> hexagoxel: Others are free to make that change and send a PR, and we'll see of bos accepts it ;)
12:22:48 <eacameron> ReinH: Very true. I suppose that's what led to the current naming.
12:22:48 <ReinH> *if
12:23:07 <ReinH> eacameron: Yep.
12:23:07 <kuznero> ReinH: this book might be rather uphill for a sales pitch talk, don't you think? Or that might be just me not been proficient enough in this particular subject :)
12:23:20 <ReinH> kuznero: You might read through it for ideas :)
12:23:39 <monochrom> eacameron: you may be happy to know that <* and *> are like what you want. however, I still can't remember which direction is <* and which direction is *>.
12:23:42 <ReinH> kuznero: the RTS's spark scheduling system is very powerful
12:24:05 <eacameron> monochrom: right. that's my inspiration ;)
12:24:05 <kuznero> ReinH: :) I am actually, but I thought folks have same challenges already and did something that others can reuse :)
12:24:29 <pjdelport> monochrom: The < or > points at the result.
12:24:41 <ReinH> Some cool technology in there, Cilk-like work-stealing double ended queues, etc
12:25:15 <ReinH> kuznero: The Mio paper on GHC's new IO subsystem is pretty amazing too
12:25:27 <eacameron> I guess adding ($>) = fmap and (<$> = flip fmap to the bottom of the file isn't so bad
12:25:30 <kuznero> ReinH: thanks, will try finding it
12:25:37 <ReinH> kuznero: TL;DR: Haskell's IO subsystem is now fast enough that it exposed a bug in the kernel's `select'.
12:25:39 <eacameron> oops. (<$) = flip fmap
12:25:42 <pjdelport> monochrom: So getLine <* getLine reads two lines and returns the first, getLine *> getLine does the same but returns the second.
12:25:43 <ReinH> @google haskell mio paper
12:25:46 <lambdabot> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
12:25:46 <lambdabot> Title: Mio: A High-Performance Multicore IO Manager for GHC
12:25:51 <hexagoxel> ReinH: on a more serious note: is it correct that (indirect) bootlib dependencies are the only thing that could truely break stuff if (upper) version constraints are too hard? if i use sandboxes for everything, at least? and i don't mean to imply that this makes breakage unlikely, i am just interested in narrowing down the cause.
12:26:08 <kuznero> ReinH: that was fast :) thanks!
12:26:11 <ReinH> hexagoxel: I'm not sure.
12:26:42 <ReinH> eacameron: Lens uses (&) = flip ($) and (<&>) = flip (<$>)
12:26:54 <ReinH> I would not expect <$ to be flip <$> by analogy to other similar naming conventions.
12:27:06 <ReinH> <* is not flip <*>, for example
12:27:37 <pjdelport> eacameron: x <$ f is already defined as const x <$> f
12:28:01 <eacameron> pjdelport: I figured it was *something*... but (&) is a good idea, I might start doing that
12:28:14 <ReinH> eacameron: you can already do it if you import lens! ;)
12:28:38 <ReinH> I recommend the 4 minute compile time to import 2 functions that can be defined in about 8 characters each ;)
12:28:47 <eacameron> ReinH: Next time I'll do that. I'm writing a build script with Shake right now so < deps the better
12:29:17 <edwardk> ReinH: (&) is going in Data.Function for 7.10
12:29:18 <felixn> has anyone seen cool examples of visualizing code?  what I think of is like hardware RTL designs when I think of visualizing haskell code http://goo.gl/d0yOaN
12:29:32 * edwardk is expecting the hatemail to start flowing from Cale any minute now ;)
12:29:38 <ReinH> eacameron: I should try Shake.
12:29:40 <ReinH> edwardk: :)
12:29:50 <johnw> ReinH: Shake is very nice
12:29:59 <ReinH> johnw: :)
12:30:00 <monochrom> I want to see Cale's hate mail. I want to know what is there to hate. :)
12:30:01 <eacameron> edwardk: glad to hear it.
12:30:03 <johnw> edwardk: how did you get that past the bike-shedders?
12:30:10 <ReinH> johnw: I've been converting bash scripts with Data.Conduit.Process and it's been great.
12:30:23 <ReinH> johnw: What color do you want to paint the &?
12:30:33 <johnw> "Edward Kmett Green"
12:31:03 <monochrom> I prefer "Edward Kmett Verdi"
12:31:08 <edwardk> johnw: it was proposed, a lot, i finally offered to let the core libraries committee decide, recused myself, and they decided to let it in unbikeshedded
12:31:18 <edwardk> johnw: and thus it is here
12:31:37 <johnw> oh nice!
12:31:40 <johnw> i'm glad to hear that
12:32:02 <edwardk> its buried in Data.Function but at least its not out in lens ;)
12:32:11 <ReinH> johnw: Although I don't really need the shell part, just the scripting. I don't need cd to work or $PATH or etc, really.
12:32:27 <monochrom> yeah, at least it's 30 minutes building GHC rather than 4 minutes building lens :)
12:32:33 <ReinH> johnw: shelly and shell-conduit and other things that implement cd via magic are scary to me.
12:32:42 <ReinH> monochrom: :p
12:32:57 <monochrom> all magic is scary
12:33:01 <johnw> ReinH: they just keep the current directory as part of the action's state
12:33:13 <ReinH> johnw: yes, I realize that it is in fact technology and not magic.
12:33:21 <ReinH> johnw: :p
12:33:30 <ReinH> johnw: but that kind of thing is brittle.
12:33:35 <johnw> ?
12:33:42 <ReinH> There are other ways to change PWD
12:33:50 <ReinH> And if you are using them, you will have a bad time.
12:34:10 <johnw> there are always ways to break the system, that doesn't invalidate all the libraries out there though
12:34:18 <monochrom> all magic is scary because all magic is ad-hoc, non-composable, and just one step away from total inconsistency
12:34:20 <johnw> i can stick unsafePerformIO anyway
12:34:24 <johnw> anywhere*
12:34:34 <ReinH> johnw: I'm not suggesting that it invalidates *all the libraries out there*. I am suggesting that it makes me wary of using those libraries for shell-scripting.
12:34:47 <johnw> but you're throwing out the baby with the bathwater
12:34:56 <johnw> because it *can* be circumvented, you don't want to use shelly?
12:35:01 <ReinH> Data.Conduit.Process is a prettier baby anyway.
12:35:02 <johnw> anything can be circumvented by a malicious user
12:35:09 <ReinH> I also had other issues with both of them.
12:36:35 <ReinH> Anyway, I really like the low-level control over streams that I get with Data.Conduit.Process. It's easy to integrate ResourceT on top for managing other resources that aren't managed directly by the conduits, etc.
12:37:03 <johnw> i've come to dislike ResourceT
12:37:09 <ReinH> I might have been using shell-conduit wrong, but so far I haven't missed it.
12:37:13 <ReinH> johnw: how so?
12:37:19 <snoopybbt> hello guys
12:37:21 <johnw> it allows for too many faulty scenarios
12:37:25 <ReinH> snoopybbt: hi
12:37:29 <johnw> I ran into subtle issue with it several times
12:37:31 <snoopybbt> hi ReinH :)
12:37:42 <johnw> that's one reason I like simple-conduit: it gets rid of the need for ResourceT
12:37:47 <ReinH> johnw: what kind of faulty scenarios?
12:37:57 <johnw> ResourceT uses exactly the kind of magic that you don't like
12:38:05 <johnw> it manages resources by mutating IORefs
12:38:18 <ReinH> That actually isn't the kind of magic I don't like ;)
12:38:20 <johnw> this makes it too easy to do type-safe things that are definitely not ResourceT safe
12:38:37 <ReinH> And I guess I can turn your "because it *can* be circumvented, you don't want to use shelly?" around on you :p
12:38:47 <johnw> yes, you can
12:38:56 <johnw> thing is, I was bit by it as an innocent user, not a malicious one
12:39:05 <ReinH> johnw: As was I with mine :)
12:39:10 <johnw> fair enough :)
12:39:23 <ReinH> I did a cd-equivalent thing without using the exported `cd' :)
12:39:38 <johnw> i guess you might wrongly use another library that does a 'cd' in its bowels too
12:39:42 <johnw> that would be an innocent bad
12:39:50 <fragamus> who can I talk to to get Linear to be included in Hoogle
12:39:54 <ReinH> I'm interested to see how ResourceT bites me in the future :)
12:39:55 <chrisdone> shell-conduit's cd is just setCurrentDirectory
12:40:32 <ReinH> fragamus: Unsure, but try https://www.fpcomplete.com/hoogle
12:40:34 <carter> fragamus:  try hayoo http://hayoo.fh-wedel.de/?query=linear
12:40:36 <k00mi> fragamus: you can search the contents if a package if you include "+package" in your query
12:40:42 <carter> hayoo works nicely too
12:41:19 <ReinH> chrisdone: fair enough, I will say that I vastly preferred shell-conduit to shelly.
12:41:35 <ReinH> k00mi: nice
12:41:38 <chrisdone> ReinH: fun =)
12:41:42 <fragamus> thanks carter
12:41:51 <carter> fragamus: i'm usually more helpful thanI am this week
12:41:55 <carter> but busy with work stuff
12:42:05 <carter> fragamus: also youre really pushign linear in ways' its not mean to
12:42:06 <ReinH> chrisdone: Basically I wanted finer-grained control over how the process's handles were... handled. That was the main reason I switched to D.C.P
12:42:18 <ReinH> chrisdone: Oh, and I wanted to wrap everything in a ResourceT
12:42:19 <carter> I do think you should try using the Data.Vector linear instances
12:42:20 <johnw> ReinH: one thing: make sure you never "hoist runResourceT"
12:42:24 <carter> or try them out
12:42:27 <johnw> there's an idiom you have to use instead
12:42:27 <ReinH> johnw: heh :)
12:42:35 <johnw> it _should_ be obvious, since runResourceT is not a monad morphism
12:42:40 <johnw> but the type checker doesn't enforce such things
12:42:44 <fragamus> I got exactly what I needed, and continue to be blown away by the power of Linear and all of it's class instances
12:42:46 <ReinH> johnw: makes sense
12:42:54 <ReinH> fragamus: it's pretty great
12:43:24 <fragamus> er, all of its class instances
12:43:37 <carter> yeah, linear is pretty sweet
12:43:45 <carter> :)
12:45:18 <chrisdone> ReinH: pretty much doing all my scripting with conduit these days
12:45:30 <ReinH> chrisdone: Yep. Pretty great.
12:45:40 <chrisdone> like this keylogger http://lpaste.net/113168
12:45:42 <cutgovspend> whats conduit?
12:45:44 <ReinH> I might revisit shell-conduit.
12:45:49 <chrisdone> also uses Data.Conduit.Process
12:46:10 <ReinH> chrisdone: but... but you aren't using shell-conduit! ;)
12:46:45 <chrisdone> ReinH: it started out like that but i moved it into a cabal project ;)
12:46:58 <chrisdone> (seems inappropriate to use shell-conduit in a library)
12:47:22 <chrisdone> currently writing some conduit code to process the output of the logging
12:47:29 <chrisdone> for delicious quantified self charts
12:47:42 <cutgovspend> whats shell conduit?
12:47:44 <chrisdone> cutgovspend: it's a stream library
12:47:54 <cutgovspend> whats it do?
12:48:04 <chrisdone> consume things from upstream, send things downstream
12:48:05 <ReinH> chrisdone: Are you quantifying... your keypresses?
12:48:22 <chrisdone> ReinH: yep. press, release, keycode, timestamp
12:48:31 <ReinH> chrisdone: That's... impressive.
12:48:38 <ReinH> chrisdone: What do you do with this data?
12:48:55 <chrisdone> ReinH: not sure yet, i just sat down to start processing the data =)
12:49:03 <ReinH> Any ideas?
12:50:01 <chrisdone> i want to know how fast i type in "bursts" (where bursts are defined to be clusters of key presses), how fast i type when typing english vs code/symbols, whether i have bad habbits, how much my fingers linger on certain keys, how much i use left-control vs right control, stuff like that
12:50:06 <marchelzo_> Am I using the State Monad wrong here? http://lpaste.net/442942983713587200
12:50:20 <marchelzo_> I can't figure out why this ends up being an infinite loop
12:50:31 <chrisdone> e.g. if my average speed is 40wpm, then i know that dvorak is probably not worth the investment
12:50:50 <chrisdone> ReinH: while searching to see if anyone else had done such research i just found this http://blog.wolfram.com/2012/06/14/how-do-you-type-wolfram-analyzing-your-typing-style-using-mathematica/
12:51:08 <chrisdone> mathematica's charts are pretty nice
12:51:53 <monochrom> marchelzo_: to understand this, I ask you to explain why it should eventually exit the recursion.
12:52:24 <marchelzo_> monochrom, it should exit when g(a) and g(b) have different signs
12:52:39 <monochrom> right, so when should they have different signs?
12:53:07 <marchelzo_> well that depends on the function
12:53:15 <monochrom> yes, so what is the function?
12:53:45 <ReinH> chrisdone: nice
12:53:56 <marchelzo_> oh dear
12:54:03 <monochrom> :)
12:54:10 <marchelzo_> I've been using x^2 + 1 :|
12:56:07 <luite> does anyone know anl alternative to the layout algorithm used by wl-pprint that does a better job for things with shorter first lines, but is fast enough for practical use (turning the 'fits' function into exhaustive search isn't)
12:57:14 <chrisdone> ReinH: this "research" last year motivated god-mode http://chrisdone.com/posts/emacs-key-analysis
12:59:24 <ReinH> Runs of non-unique C-/M- clusters: min/max/avg/stddev: 1/189/3.35/7.04... 189???
13:00:24 <Keeper> What does "qualified" mean in Haskell? i.e. import qualified Prelude?
13:00:33 * hackagebot simple-eval 0.1.0.0 - Evaluate a Text to an Integer: "1 + 1" -> 2  http://hackage.haskell.org/package/simple-eval-0.1.0.0 (m)
13:02:15 <chrisdone> ReinH: in other words, holding down C-f to go forward or C-n to go down a line 189 times. that's a bad habbit of not using search (probably when search is difficult)
13:02:37 <ReinH> Ah.
13:02:41 <chrisdone> ReinH: one advantage of such analyses, telling you your bad habbits =)
13:03:10 <eitan_chatav> Keeper: "import qualified Library as L" means to use a function f exported from Library, you must write "L.f". This is used to disambiguate when there are functions with the same name in different imports.
13:03:12 <hexagoxel> Keeper: https://www.haskell.org/haskellwiki/Import
13:03:28 <ReinH> Keeper: qualified means that you must qualify the use of any names in the module, so if Foo.Bar exports quux, then import qualified Foo.Bar means you must say `Foo.Bar.quux'. More info here: http://www.haskell.org/haskellwiki/Import_modules_properly
13:03:44 <ReinH> eitan_chatav: o/
13:03:53 <Keeper> Oh I get it. Sort of a priority order.
13:04:14 <ReinH> Keeper: Not an ordering of any kind, a flag that says to fully qualify the names. :)
13:04:28 <JagaJaga> What's the way to do smth like readChan, but if we can't do it in 3 seconds just do next things? smth like readChan :: IO Maybe a? Because I've read that isChanEmpty is depricated.. And I don't want to mess with stm (ChanT)
13:05:13 <monochrom> JagaJaga: the library package "async" may help along that line
13:05:33 * hackagebot process-streaming 0.6.2.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.2.0 (DanielDiazCarrete)
13:06:03 <JagaJaga> monochrom: thx.
13:06:53 <chrisdone> @dict qualify
13:06:53 <lambdabot> There is no dictionary database 'qualify'.
13:07:07 <chrisdone> lambdabot: just DWIM
13:07:13 <monochrom> @wn qualify
13:07:14 <lambdabot> *** "qualify" wn "WordNet (r) 3.0 (2006)"
13:07:14 <lambdabot> qualify
13:07:14 <lambdabot>     v 1: prove capable or fit; meet requirements [syn: {qualify},
13:07:14 <lambdabot>          {measure up}]
13:07:14 <lambdabot>     2: pronounce fit or able; "She was qualified to run the
13:07:16 <lambdabot> [19 @more lines]
13:07:40 <monochrom> @more
13:07:41 <lambdabot>        marathon"; "They nurses were qualified to administer the
13:07:41 <lambdabot>        injections" [ant: {disqualify}]
13:07:41 <lambdabot>     3: make more specific; "qualify these remarks" [syn: {qualify},
13:07:41 <lambdabot>        {restrict}]
13:07:41 <lambdabot>     4: make fit or prepared; "Your education qualifies you for this
13:07:43 <lambdabot> [14 @more lines]
13:07:57 <monochrom> I think we're using 3
13:08:57 <chrisdone> =)_
13:09:46 <absence> is there an elegant way to express map in terms of foldl?
13:10:17 <chrisdone> there's a way... elegant depends on the reader
13:10:23 <monochrom> no, i think not. only an elegant way using foldr
13:10:27 <sipa> :t foldl
13:10:28 <lambdabot> (b -> a -> b) -> b -> [a] -> b
13:10:51 <CodeWeaverX> Sure, but you could implicitly or explicitly implement foldr using foldl. ;)  That would get less elegant though.
13:10:55 <cutgovspend> is haskell like sorcery?
13:11:08 <CodeWeaverX> Or use foldl with a reverse.
13:11:17 <monochrom> is that an important question?
13:11:42 <CodeWeaverX> Anyway, basic idea would be to use a fold that combines each element of the source list into an accumulating parameter which itself is a list… using something that adds to one end of the list or the other (preferably the front).
13:11:46 <simpson> cutgovspend: Are you looking for a useful simile?
13:12:09 <chrisdone> cutgovspend: SICP characterizes programming as magic. so haskell is like a language for your spell book ;)
13:14:32 <cutgovspend> I am at least a 4th level magic user.
13:14:51 <chrisdone> respek
13:14:53 <bitemyapp> byorgey: could I ask a favor? I'm on the cis194s13 repo, would you please allow me to see the new Fall one as well?
13:15:16 <bitemyapp> chrisdone: there's an argument to be made for APL/K/J being the runic languages of grimoires.
13:15:24 <CodeWeaverX> I’m arguably still working on not gating to the keeps of beholders every time I cast Traversable.
13:15:34 * hackagebot simple-eval 0.1.0.1 - Evaluate a Text to an Integer: "1 + 1" -> 2  http://hackage.haskell.org/package/simple-eval-0.1.0.1 (m)
13:15:36 * hackagebot process-streaming 0.6.2.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.2.1 (DanielDiazCarrete)
13:18:00 <absence> hm, so what is the best way to process a list from left to right, maintaining some state to be used and updated for each step? [Type] -> [Type]
13:18:16 <cutgovspend> I think polymorph other would pretty much be the best thing ever.
13:18:48 <cutgovspend> foldr?
13:18:55 <CodeWeaverX> absence:  Well, a fold would do that, if your ‘initial value’ for the accumulator is, say, a tuple (x,y) where one of them is the thing your’e building up, and the other is your ‘state’.
13:19:03 <chrisdone> absence: mapAccumL/mapAccumR
13:19:03 <merijn> absence: recursion with State monad and/or fold
13:19:12 <ReinH> absence: foldl doesn't have the necessary laziness.
13:19:36 <chrisdone> :t mapAccumR
13:19:38 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:19:50 <chrisdone> oh, i like that type signature
13:19:59 <chrisdone> they used "acc" instead of a single letter. descriptive
13:20:01 <ReinH> map f = foldr ((:) . f) [] -- is sufficiently lazy, and in fact could be considered a foldr law.
13:20:10 <CodeWeaverX> well, I’ll be dipped.  I didn’t know about mapAccum. How the heck have I dodged that.
13:20:12 <ReinH> I think it's a fusion rule in fact?
13:20:45 <chrisdone> CodeWeaverX: TBH i've never used it either, i always reach for fold*
13:21:04 <ReinH> bitemyapp: APL, absolutely. People call perl the read-only language, but it's got nothing on APL ;).
13:21:14 <bitemyapp> ReinH: srsly.
13:21:20 <bitemyapp> ReinH: at least you name things in Perl. Usually.
13:21:29 <chrisdone> it would be interesting to see J but with the ascii replaced with words
13:21:32 <chrisdone> perhaps it would be pretty
13:21:39 <ReinH> bitemyapp: Have you seen the Game of Life in APL video on Youtube? As impressive as it is inscrutable.
13:21:41 <bitemyapp> ReinH: writing a J or K dialect as a deeply embedded Haskell DSL is a long-standing yak of mine.
13:21:49 <ReinH> bitemyapp: nice
13:21:52 <bitemyapp> ReinH: yes I have. I've long admired APL and its children from afar. I used to write J.
13:22:05 <bitemyapp> mostly for arithmetic / matrixy stuff.
13:22:27 <chrisdone> i've a todo list to play with one of the array languages one day. just to grok the paradigm, i think there're some neat ideas there
13:22:44 <bitemyapp> chrisdone: I'd say J is the most Haskell-user-friendly APL dialect.
13:23:11 <chrisdone> yeah i seem to know several J-liking haskellers
13:23:19 <bitemyapp> chrisdone: J is like writing everything in PF code but with functions whose semantics change depending on whether it's one or two arguments.
13:23:20 <Keeper> http://pastebin.com/raw.php?i=nrTfMVGL What's the right way to call main?
13:23:32 <bitemyapp> the problem is that the overloading is uh...mostly adhoc and based on "taste" rather than laws.
13:23:38 <bitemyapp> it's a mnemonic sort of thing.
13:23:47 <chrisdone> ah, i thought it was more like a stack language
13:24:03 <chrisdone> like factor but with all the words replaced with symbols
13:24:06 <bitemyapp> chrisdone: it's an APL derivative.
13:24:15 <absence> chrisdone: i think mapAccumL will do the trick, thanks! does it have problems like foldl that i have to be aware of, or is it "safe"? :)
13:24:17 <chrisdone> s/it/APL and all of its ken/
13:24:17 <bitemyapp> chrisdone: so it's as stacky as that family is.
13:24:46 <bitemyapp> chrisdone: it's difficult for me to relate Forth and Factor to J. There are some similarities to be sure, but J is less like manipulating a stack and more like piping data through pointfree functions.
13:24:58 <ReinH> Keeper: main currently returns a String. To print a string, you can use putStrLn, so: main = putStrLn $ ... your stuff ...
13:25:00 <chrisdone> absence: i think it's non-strict in the function like foldl, so it has the same problem as foldl
13:25:10 <bitemyapp> chrisdone: the word used I think is "array language".
13:25:27 <bitemyapp> chrisdone: there's not an implicit stack state being manipulated unless you simulate/create one.
13:25:43 <chrisdone> bitemyapp: yeah i said array language above. i'm saying my conception was that it was more stackish than just like some lambda-calculus with ad-hoc overloaded functions
13:26:03 <cutgovspend> what do hasklers think of tcl?
13:26:06 <ReinH> Forth and APL are both "tacit languages"
13:26:24 <absence> chrisdone: hm, there's no mapAccumL' though
13:26:30 <Keeper> ReinH: Thanks again :)
13:26:33 <bitemyapp> cutgovspend: awful idea taken to its ultimate conclusion :)
13:26:36 <chrisdone> absence: seems not =)
13:26:57 <cutgovspend> lol
13:27:03 <ReinH> Keeper: it's useful to give main an explicit type: main :: IO ()
13:27:12 <ReinH> Then type errors will be a bit easier to understand
13:27:19 <cutgovspend> is haskell hard to learn for someone with no cs degree?
13:27:26 <chrisdone> bitemyapp: do all functions take an array?
13:27:42 <chrisdone> bitemyapp: i.e. every function is some variation on Array -> Array
13:28:00 <muyfine> having trouble figuring out how to use MonadTransformers.... which is what I think I need (suggested last night):
13:28:01 <Keeper> ReinH: Will keep it in mind :)
13:28:01 <muyfine> http://lpaste.net/3752956588046942208
13:28:02 <chrisdone> (as opposed to Stack -> Stack)
13:28:04 <benmachine> I don't think mapAccumL has the same problem as foldl, because you have access to the intermediate results and can force them directly
13:28:08 <benmachine> I might be thinking of scanl though
13:28:16 <bitemyapp> chrisdone: Num, Char, boxed.
13:28:27 <benmachine> I guess it depends a little on what your function is and what its strictness profile is like
13:28:28 <muyfine> have accumulating contexts that I want to flatten: IO (Either Bool [IO (Either Bool [String])])
13:28:43 <muyfine> (they keep nesting as I make calls)
13:29:38 <benmachine> muyfine: what result do you want?
13:30:22 <josephle> benmachine: I think the comment in his lpaste states his goal?
13:30:32 <bitemyapp> chrisdone: 1-rank array is list, 2-rank is table.
13:30:34 <benmachine> josephle: it states what type they are looking for, but not what value
13:30:40 <josephle> that's true
13:31:31 <chrisdone> > foldl (+) 0 [1..10000000]
13:31:35 <lambdabot>  mueval-core: Time limit exceeded
13:31:37 <chrisdone> > foldl' (+) 0 [1..10000000]
13:31:39 <lambdabot>  50000005000000
13:31:46 <chrisdone> > mapAccumL (\acc x -> let !y = acc + x in (y,x)) 0 [1..10000000]
13:31:51 <lambdabot>  mueval: ExitFailure 1
13:31:55 <chrisdone> benmachine: can you strictify that properly?
13:32:13 <benmachine> chrisdone: let me think about it a bit
13:32:30 <cschneid> is there a tutorial out there for modeling classic OO problems - I'm thinking about a roguelike, so in OO, I'd have a shared base class with common behavior, then specialized to distinct monsters.
13:32:32 <cschneid> I know I can fake the OO style inheritance tree with typeclasses & such, but that feels a bit janky.
13:32:58 <absence> chrisdone: heh :(
13:33:23 <chrisdone> benmachine: it seems to me that mapAccumL needs to force the value as a prerequisite of moving down the spine, if you know what i mean
13:33:38 <benmachine> chrisdone: right, so surely the thunk never gets too large?
13:33:39 <chrisdone> benmachine: whereas in this case it seems like the thunk will never *truly* be forced until the end
13:33:49 <benmachine> oh, wait
13:33:52 <benmachine> hm
13:34:05 <chrisdone> seems like it's not doing so:
13:34:05 <chrisdone> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#mapAccumL
13:34:06 <benmachine> I think your example is strict enough as long as you force the elements as well as the spine as you walk
13:34:10 <chrisdone> which is consistent with foldl
13:34:19 <chrisdone> yeah -- a mapAccumL' could be done
13:34:32 <benmachine> but I mean, you don't need mapAccumL', you can force the elements yourself
13:34:36 <chrisdone> hmm. how?
13:34:41 <benmachine> just look at them :P
13:34:45 <chrisdone> > mapAccumL (\!acc !x -> (acc+x,x)) 0 [1..10000000]
13:34:46 <lambdabot>  <hint>:1:21: parse error on input ‘->’
13:34:50 <chrisdone> > mapAccumL (\(!acc) (!x) -> (acc+x,x)) 0 [1..10000000]
13:34:56 <lambdabot>  mueval: ExitFailure 1
13:35:07 <benmachine> I claim that's not a strictness failure, just a big list
13:35:13 <chrisdone> ah, we can easily test this?
13:35:17 <chrisdone> > snd (mapAccumL (\(!acc) (!x) -> (acc+x,x)) 0 [1..10000000])
13:35:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:35:26 <chrisdone> aha!
13:35:39 <piskrist> haskell is great
13:35:41 <chrisdone> so therefore the values are not forced as part of the spine?
13:35:46 <piskrist> I can read twitter while it is compiling :)
13:35:57 <chrisdone> you just have a big thunk, right?
13:36:02 <benmachine> chrisdone: where's the big thunk?
13:36:11 <chrisdone> the `fst'
13:36:12 <benmachine> wait a sec
13:36:21 <benmachine> I think I misread your accumulator
13:36:28 <benmachine> I was thinking (acc + x, acc)
13:36:43 <benmachine> sure, your example is fine then
13:36:49 <benmachine> but you're also just doing a foldl in that case :P
13:37:17 <chrisdone> sure, the point of mapAccumL is just an embellished foldl
13:37:22 <benmachine> usually when you do a mapAccumL, I'd think you'd want the list elements to depend on the accumulator
13:37:31 <chrisdone> hmm, true
13:37:32 <chrisdone> let's try that
13:37:34 <benzrf> :t mapAccumL
13:37:35 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:37:39 <benmachine> if they do that, then looking at the list elements forces the accumulator
13:37:46 <benmachine> incrementally
13:39:15 <chrisdone> > mapAccumL (\(!acc) (!x) -> (acc+x,x+acc)) 0 [1..10000000]
13:39:20 <lambdabot>  mueval: ExitFailure 1
13:39:28 <chrisdone> hmm, i feel like this should complete okay
13:39:42 <chrisdone> if you're right about its strictness characteristics
13:40:20 <cutgovspend> so haskell is fine for building a website?
13:40:33 <shelf> sure is!
13:40:34 <JagaJaga> how to write properly `map (show $ _2 ^.) [(TypeFoo, TypeBar)]` ?
13:40:45 <ReinH> muyfine: whatever it is, it'll be some ridiculously complicated thing involving binds and `sequence', and you'd be better off not constructing such a value in the first place.
13:40:52 <benmachine> chrisdone: I don't think ExitFailure 1 is proof of very much, to be fair
13:40:54 <absence> > snd $ mapAccumL (\(!acc) (!x) -> (acc+x,x+acc)) 0 [1..10000000]
13:40:56 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
13:41:06 <shelf> cutgovspend: static sites see Hakyll, dynamic sites see scotty or yesod
13:41:12 <ReinH> JagaJaga: (_2 ^.)
13:41:18 <absence> > snd $ mapAccumL (\acc x -> (acc+x,x+acc)) 0 [1..10000000]
13:41:20 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
13:41:36 <chrisdone> benmachine: sure
13:41:36 <benmachine> (_2 ^.) looks wrong
13:41:42 <benmachine> shouldn't it be (^. _2)?
13:41:44 <mauke> ReinH: that looks like a function
13:41:57 <ReinH> muyfine: you are using a lot of fmaps, you probably want to replace those
13:42:03 <absence> are the bangs not really necessary?
13:42:41 <ReinH> Well, it needs to be a section, I didn't bother to check for semantic correctness :p
13:42:54 <ReinH> It could also just be (view _2), I think
13:42:58 <chrisdone> absence: they don't seem to help for the interpreter
13:43:17 <ReinH> > view _2 (1,2)
13:43:20 <lambdabot>  2
13:43:23 <ReinH> Yep.
13:43:27 <JagaJaga> ReinH: view worked
13:43:29 <JagaJaga> thx
13:43:31 <ReinH> For some reason I can never remember the order.
13:43:38 <benmachine> I don't think the bangs make /much/ difference
13:43:47 <benmachine> but they're not completely meaningless
13:44:10 <ReinH> Well, the tuple is still not being evaluated, right?
13:44:14 <chrisdone> the bangs create an implicit wrapper around the tuple to say "forcing this tuple will force these args"
13:44:25 <chrisdone> but yeah, the tuple's slots are still lazy
13:44:44 <cutgovspend> can you replace mysql with something like linda in haskell? for web apps?
13:45:03 <ReinH> you really need let a = acc+x, b = x+acc in a `seq` b `seq` (a,b) or so
13:45:11 <ReinH> Although I don't know why those would be different?
13:45:14 <benmachine> ReinH: I think that's what the bang patterns do
13:45:14 <chrisdone> ReinH: that's equivalent
13:45:23 <ReinH> benmachine: is it?
13:45:40 <benmachine> roughly, f !x !y = blah gets translated into f | x `seq` y `seq` False = undefined | otherwise = blah
13:45:53 <benmachine> well, not operationally, but semantically
13:45:57 <ReinH> You need to force both the tuple and its fields, right?
13:46:28 <benmachine> no if you force the tuple you will force the fields
13:46:37 <benmachine> er
13:46:37 <benmachine> no
13:46:40 <ReinH> Er.
13:46:40 <benmachine> force the args
13:46:46 <benmachine> right
13:46:47 <ReinH> That can't be true? Pair exists after all?
13:46:51 <absence> > last . snd $ mapAccumL (\(!acc) (!x) -> (acc+x,x+acc)) 0 [1..10000000]
13:46:52 <benmachine> I see what you were saying :P
13:46:55 <lambdabot>  mueval-core: Time limit exceeded
13:47:15 <absence> > last . snd $ mapAccumL (\(acc) (x) -> (acc+x,x+acc)) 0 [1..10000000]
13:47:19 <benmachine> ReinH: you're right
13:47:20 <lambdabot>  mueval: ExitFailure 1
13:47:22 <chrisdone> forcing the tuple resulting from the lambda will force the args, because you've constructed the tuple using args which are banged
13:47:25 <exio4> wouldn't that be the same as "fst $ .."?
13:47:26 <ReinH> The point of Pair is to add the space invariant that (a,b) lacks: if the constructor is forced then the fields are forced.
13:47:28 <absence> ah
13:47:33 <ReinH> benmachine: phew :)
13:47:50 <benmachine> chrisdone: right, but forcing the tuple forces x and acc, not x + acc
13:47:55 <absence> so without the bangs it explodes if elements aren't accessed sequentially
13:48:04 <chrisdone> benmachine: sure, which will be forced in the next iteration
13:48:14 <chrisdone> right?
13:48:16 <absence> > last . snd $ mapAccumL (\(!acc) (x) -> (acc+x,x+acc)) 0 [1..10000000]
13:48:20 <lambdabot>  mueval-core: Time limit exceeded
13:48:44 <benmachine> chrisdone: yeah, I'm not saying the difference changes behaviour, just that's what me and ReinH were getting confused about
13:48:49 <chrisdone> gotcha
13:48:51 <absence> \o/
13:48:55 <benmachine> apparently my only method of speech this evening is at cross-purposes
13:48:55 <ReinH> chrisdone: yep
13:49:19 <ReinH> The space invariant your enforces is: if the previous element is evaluated then the fields of the next element are evaluated
13:49:19 <chrisdone> do we have a strict Pair defined in lambdabot?
13:49:22 <ReinH> which is subtly different
13:49:23 <chrisdone> > Pair 1 2
13:49:25 <lambdabot>  Not in scope: data constructor ‘Pair’
13:49:32 <ReinH> chrisdone: That's what you're saying, right?
13:49:33 <chrisdone> @src data Pair x y = Pair !x !y
13:49:33 <lambdabot> Source not found. Whoa.
13:49:39 <ReinH> Should be similar in observable behavior
13:49:44 <benmachine> > foldl' (+) 0 . snd $ mapAccumL (\(!acc) (x) -> (acc+x,x+acc)) 0 [1..10000000]
13:49:48 <lambdabot>  mueval-core: Time limit exceeded
13:49:52 <benmachine> hrm
13:49:55 <exio4> @let data Pair x y = Pair !x !y deriving (Show,Eq)
13:49:58 <lambdabot>  Defined.
13:50:00 <chrisdone> exio4: thanks
13:50:02 <exio4> > Pair 2 3
13:50:03 <ReinH> Either way you don't have a built up of thunks in the fields of the tuple
13:50:04 <lambdabot>  Pair 2 3
13:50:11 <ReinH> Which is what matters
13:50:35 <chrisdone> right
13:50:38 <absence> > fst $ mapAccumL (\(!acc) (x) -> (acc+x,x+acc)) 0 [1..10000000]
13:50:43 <lambdabot>  mueval-core: Time limit exceeded
13:50:51 <chrisdone> assuming the tuple is actually forced
13:50:57 <chrisdone> mapAccumL f s (x:xs)    =  (s'',y:ys)
13:50:57 <chrisdone>                            where (s', y ) = f s x
13:50:57 <chrisdone>                                  (s'',ys) = mapAccumL f s' xs
13:50:58 <chrisdone> i think this
13:50:58 <ReinH> chrisdone: right
13:51:01 <chrisdone> is equivalent to
13:51:07 <chrisdone> case f s x of ~(s',y) -> …
13:51:11 <chrisdone> right?
13:51:22 <chrisdone> irrefutable patterns are inherently lazy
13:51:28 <chrisdone> afaik
13:51:38 <chrisdone> > foldl' (\(Pair acc _) x -> (Pair (acc + x) ())) (Pair 0 ()) [1..10000000]
13:51:41 <ReinH> chrisdone: super lazy :)
13:51:42 <lambdabot>  mueval-core: Time limit exceeded
13:51:44 <chrisdone> hrm
13:51:57 <chrisdone> oh wait
13:52:22 <chrisdone> perhaps lambdabot is simply failing us in these tests because it's interpreted
13:53:00 <ReinH> > foldl' (+) 0 [1..10000000]
13:53:02 <lambdabot>  50000005000000
13:53:02 <chrisdone> benmachine: but yeah i think that foldl is not forcing with every spine iteration due to that laziness
13:53:26 <chrisdone> just by observing the code, ignoring the actual runtime behaviour
13:54:01 <chrisdone> err, sorry, s/foldl/mapAccumL
13:54:02 <ReinH> chrisdone: Maybe it's secretly compiling on LLVM and optimizing to n(n+1)/2 ;)
13:55:59 <piskrist> how can I catch any exception?
13:56:07 <chrisdone> right, with -O2 this returns immediately
13:56:07 <chrisdone> main = print (foldl' (\(!acc,_) x -> ((acc + x),())) (0, ()) [1..10000000])
13:57:55 <muyfine> ReinH what would I replace the fmaps with?
13:58:11 <chrisdone> whereas
13:58:11 <chrisdone> main = print (fst (mapAccumL (\(!acc) x -> (acc+x,x+acc)) 0 [1..10000000]))
13:58:11 <chrisdone> completes in 5 seconds. which tends to imply too much laziness
13:58:46 <ReinH> muyfine: Here's an example of why the fmaps might be "getting in the way":
13:59:42 <muyfine> (fwiw, I'm having a hard time working with this api that's doing all this nesting... greatly appreciate any help I wade the waters from beginner haskell into realworld haskell)
13:59:49 <piskrist> oh, I just missed type declaration
13:59:57 <ReinH> :t let readLine = undefined :: IO String in readLine >>= putStrLn
13:59:58 <lambdabot> IO ()
14:00:12 <absence> http://www.haskell.org/pipermail/libraries/2012-November/018757.html <- Proposal: Strict scanl, scanl1 and mapAccumL
14:00:13 <ReinH> :t let readLine = undefined :: IO String in fmap putStrLn readLine
14:00:14 <lambdabot> IO (IO ())
14:00:18 <absence> no idea what came of it
14:00:20 <ReinH> muyfine: see the difference?
14:00:40 <ReinH> You've got IOs inside IOs. fmap might be part of the cause of that.
14:01:18 <muyfine> yeha, I definitely have context inside context... not sure how to flatten it or remove that with removing fmaps
14:01:36 <ReinH> muyfine: try replacing the (fmap . fmap . fmap) with do notation
14:02:01 <ReinH> remembering that fmap f k = do { x <- k; return (f x) } might help
14:02:21 <ReinH> muyfine: might make it easier to see where the extra context is being added
14:03:30 <muyfine> ReinH I tried this: getAll = ((fmap . fmap . fmap) $ getPresents) getGifts
14:03:39 <muyfine> and get the same type signature
14:04:04 <muyfine> the extra context is being added by the library I'm using - everything is being wrapped in IO (Either a b)
14:04:18 <muyfine> So when I nest calls, I get nested context
14:04:29 <muyfine> trying to figure out how I can de-nest
14:04:32 <ReinH> muyfine: Right, but the fmaps are preserving that "nesting"
14:04:34 <muyfine> and flatten things
14:04:42 <mauke> so ... don't use fmap?
14:04:55 <ReinH> So replacing them with equivalent do notation might make it more obvious where the extra nesting is happening (probably with a return that shouldn't be there)
14:05:53 <muyfine> If I don't use fmap, then I have this whole case nest pulling everything apart
14:06:06 <muyfine> I wanted to merge the outer contexts if possible
14:06:15 <ReinH> Ok.
14:06:18 <muyfine> just not sure how to
14:06:27 <ReinH> Well, I gave you an option. Up to you if you want to use it. :)
14:06:37 <muyfine> cool, I'll try that out
14:07:36 <absence> :t sequence
14:07:37 <lambdabot> Monad m => [m a] -> m [a]
14:07:45 <absence> muyfine: that function might be of use
14:10:19 <lpaste> chrisdone pasted “mapAccumL' in terms of foldl' ” at http://lpaste.net/113172
14:10:38 <mrenaud> Hey, I was wondering if someone could give me some "best practice" advice
14:11:23 <chrisdone> benmachine: ReinH: absence: ^ out of interest
14:12:50 <mrenaud> I'm pretty new to haskell so this may be a silly question :P If I have a typeclass Foo and a bunch of data types that implement Foo, can I create a list that can contain any of the data types?
14:12:59 <mauke> mrenaud: no
14:13:45 <spiftheninja> anyone know a reliable way to time my autoperform so i don't flood? PLEASE PM ME, WILL TIP
14:14:20 <mrenaud> That's the answer I expected :P So, my next question is if I wanted to do this would I have to make an ADT with different types and write the functions in Foo with pattern matching?
14:14:52 <chrisdone> you can achieve something similar with an existential type with a context specifying that class
14:15:10 <chrisdone> class Foo a -- your class
14:15:11 <chrisdone> data Fooish = forall a. Foo a => a
14:15:18 <chrisdone> [Fooish] -- a list of things that implement Foo
14:15:43 <favetelinguis> i have just taken a course in logic, i understand that programming languages are build upon logic but i dont get in what way. For example for the sematics of predicate logic we define a model as an non empty set A a set of all terms (functions and constants) and a set of predicates. Would this be the same as the definition of a computer program and if so is programming languages build on predicate logic?
14:15:44 <chrisdone> [Fooish 1,Fooish 'c'] -- how you would specify the values
14:15:56 <mrenaud> chrisdone: I haven't seen that before, that sounds like it would work though, thanks
14:15:57 <chrisdone> (assuming int/char had instances)
14:17:07 <mrenaud> Also, if I have this [Fooish], can I show and read it back in to their original types?
14:17:09 <chrisdone> mrenaud: it depends whether you want an open set or a closed set of things
14:17:31 <mrenaud> chrisdone: Let's assume it's closed and I know all of the instances
14:17:54 <chrisdone> if it's closed you may just be fine with a simple ADT ;)
14:18:13 <chrisdone> but yeah, if you want to Show the things then you add a Show constraint
14:18:22 <chrisdone> data Fooish = forall a. (Show a,Foo a) => a
14:18:22 <absence> chrisdone: nice idea, but the list is backwards :)
14:18:27 <chrisdone> or add it to your Fooish class
14:18:55 <chrisdone> absence: oops ;)
14:19:28 <ReinH> @google Curry-Howard Correspondence
14:19:28 <lambdabot> http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
14:19:28 <lambdabot> Title: Curry–Howard correspondence - Wikipedia, the free encyclopedia
14:19:32 <ReinH> favetelinguis: Are you familiar with ^?
14:19:45 <chrisdone> mrenaud: if you want to get them back to a concrete type, you either need a Typeable constraint, so you can cast it back, or you just use a normal ADT which gives you this for free
14:19:46 <absence> chrisdone: it's the same problem i ran into before i asked the initial question :)
14:19:56 <favetelinguis> ^? newer seen that
14:20:07 <ReinH> favetelinguis: That would be a good place to start.
14:20:22 <ReinH> favetelinguis: Oh, by ^? I meant "the thing above?"
14:20:35 <ReinH> Sorry
14:20:38 <mrenaud> Ahh, ADT may be nicer to use in this case then. I'm not familiar with Typeable though, brb looking it up
14:20:54 <chrisdone> absence: i'd perhaps just implement the strict mapAccumL' manually then =p
14:21:18 <ReinH> chrisdone: Commutativity is nice :)
14:21:39 <bitemyapp> ReinH: I need to learn lattices still.
14:21:45 <chrisdone> ReinH: what about it?
14:22:11 <favetelinguis> ReinH: Thanks now i know where to start
14:22:22 <ReinH> chrisdone: Well, you would at least guarantee that the result was the same, although with mapAccumL you probably want the list to be the same order too :/
14:23:19 <ReinH> chrisdone: You could use a diff list optimization though?
14:23:49 <ReinH> if you the folding operation were commutative but you wanted the list back in order
14:23:53 * ReinH shrugs
14:25:17 <chrisdone> reinh =)
14:25:54 <absence> does lambdabot have tekmo's foldl library?
14:26:25 <absence> :t Control.Foldl.scan
14:26:27 <lambdabot> Not in scope: ‘Control.Foldl.scan’
14:26:33 <absence> guess not :p
14:35:48 <gridaphobe> does anyone know of techniques for adding source locations to an eDSL? (preferably something that doesn't involve TH)
14:36:34 <bgamari> gridaphobe, if you want actually source locations (not locations in the AST) I think you'll need TH
14:36:49 <begriffs> I'm building a package and want to lock the versions of its dependencies to be as permissive as possible while still building ok. Is there a tool that can try building my project under various package versions to determine appropriate version constraints?
14:36:51 <benmachine> or some other preprocessor
14:38:00 <gridaphobe> hmm yea, a preprocessor would probably work, i just want it to be more transparent to users than TH
14:38:45 <Welkin> conduit-1.2.1 failed to install, which made my yesod-bin install fail
14:39:18 <Welkin> Data/Conduit/Internal/Pipe.hs:275:4:
14:39:18 <Welkin>      error: invalid preprocessing directive
14:39:21 <Welkin>       #-}
14:39:34 <Welkin> is this a problem with ghc 7.6.3?
14:39:36 <gridaphobe> i've also considered trying to postprocess the AST and add source info from haskell-src-exts or ghc, but that sounds painful and error-prone
14:39:54 <merijn> Welkin: OSX?
14:40:07 <Welkin> yes
14:40:29 <Welkin> switch from clang to gcc?
14:40:40 <merijn> Welkin: You installed a wrong GHC. Since 10.8 OSX only ships clang and not gcc and the old GHC gcc config doesn't work with clang
14:40:42 <Welkin> I know I had to do that with hakyll
14:40:48 <merijn> Welkin: How'd you install ghc?
14:40:52 <Welkin> I am on 10.9
14:41:22 <Welkin> I compiled gcc seperately
14:41:44 <merijn> GHC has been patched to work on OSX for a while now
14:41:58 <merijn> Did you use homebrew/macports?
14:42:00 <Welkin> you mean 7.8.x?
14:42:17 <absence> chrisdone: Control.Foldl.scan seems to do the trick. it doesn't return the final accumulator (fine in my case), and evaluating only the last element is almost as fast as foldl', and at least an order of magnitude faster than mapAccumL
14:42:19 <Welkin> I am using haskell platform 2013
14:42:45 <merijn> Welkin: ok, you can't, get the new one from the platform site, it's compatible with new OSX
14:43:03 <merijn> Welkin: Alternately, install ghc manually using the binary distribution
14:43:23 <Welkin> will that break any dependencies?
14:44:32 <lpaste> mgomezch pasted “I'm very sorry about this.” at http://lpaste.net/113173
14:44:56 <merijn> Welkin: Hard to say
14:45:21 <sivteck> Welkin, this might help http://ghcformacosx.github.io/
14:49:49 <jabesed> from ghc-mod :   IMPORTANT: if your haskell-mode-hook includes (flymake-mode), please remove it.
14:50:09 <jabesed> doesn't ghc-mod do on the fly compilation anymore
14:50:11 <jabesed> ?
14:50:35 <geekosaur> I think the point is that it does, and the standard flymake's compilation on the fly conflicts with it?
14:50:57 <jabesed> geekosaur: I thought so to but it's not doing it... let me recheck
14:51:56 <jabesed> or maybe I just don't have ghc-mod activated
14:52:01 <jabesed> weird
14:56:19 <jabesed> weird, it's not working properly but it's also not ... off
14:56:30 <jabesed> i.e. some commands do work, like C-M-i
14:56:37 <jabesed> so it is somwhat loaded
14:57:01 <jabesed> but I don't have a ghc-mod menu, nor anything indicating ghc-mod to be activated, and most commands just fail
14:57:27 <jabesed> I tried putting the ghc-mod config *after* haskell-mode's but it didn't work
14:57:53 <jabesed> this line, (add-hook 'haskell-mode-hook (lambda () (ghc-init)))   interfered with haskell-mode
14:58:08 <jabesed> so I put it before
14:58:30 <jabesed> but it's not working
15:06:04 <malllle> parse (endBy letter endOfLine) "" "A\nB -- do i get this to parse ("A\n\B\n" works)
15:06:24 <malllle> ^+how
15:06:33 <icbm> What is the preferred way to install GHC on OS X? Homebrew, Platform, GHC.app, something else?  I generally use brew for things, but...
15:07:05 <piskrist> is there a function to drop trailing whitespace from String?
15:07:37 <benzrf> icbm: https://github.com/bitemyapp/learnhaskell
15:07:42 <benzrf> icbm: ctrl+f os x
15:07:50 <malllle> piskrist: strip?
15:07:54 <Hafydd> piskrist: dropWhileEnd isSpace
15:08:09 <benzrf> icbm: https://github.com/bitemyapp/learnhaskell#mac-os-x tbp
15:08:26 <piskrist> Hafydd: cool
15:09:38 <piskrist> oh wait, Hafydd dropWhileEnd works on Text not String
15:10:07 <Hafydd> piskrist: there is a version in Data.List.
15:10:10 <piskrist> well I guess it will be better to use Text
15:10:31 <icbm> benzrf: OK, so they recommend the GHC.app way.
15:10:36 <Hafydd> (In later versions of GHC, anyway -- it's not strictly in the standard Prelude.)
15:15:14 <piskrist> hrm, dealing with outer world is annoying
15:15:44 <dmj`> icbm: I'd do it all from scratch
15:16:11 <dmj`> icbm: you can wget the cabal binary and ghc, then ./configure, make, make install ghc
15:19:29 <icbm> dmj`: Thanks. If I was going to build from source, I'd rather have homebrew do it, so that it can upgrade it for me later.
15:22:51 <dmj`> icbm: I had issues with that, /usr/local/bin/ghc is where make install ghc goes, I keep cabal in ~/.cabal/bin/cabal, tbh, how often are you upgrading ghc? Cabal yea, but you can just mv it to ~/.cabal/bin/cabal and overwrite
15:24:52 <merijn> icbm: Installing GHC from homebrew is highly recommended *against*
15:25:02 <merijn> icbm: The formula's are woefully undermaintained
15:25:46 <dmj`> icbm: what merijn said
15:25:48 <merijn> icbm: Personally I just use platform and then install binary releases from haskell.org/ghc for newer compiles
15:26:05 <merijn> plus git checkout for the newest of the newest
15:26:53 <merijn> GHC works pretty well with user local installs since all package databases are sandboxed per ghc-version and cabal automatically uses whichever GHC comes first in path
15:27:34 <merijn> dmj`: You do realise you can ask the source/binary installs to install elsewhere, no?
15:27:57 <merijn> dmj`: the make install just obeys your ./configure (which defaults to /usr/local)
15:28:08 <icbm> merijn/dmj`: Sounds like a plan.  I might take a look at the brew formula to see if it could use a PR or two.
15:28:39 <dmj`> merijn: I like defaults
15:28:43 <icbm> FWIW, I actually have my brew in ~/.brew, not /usr/local.  I know the risks and it generally works well for me.
15:28:53 <merijn> icbm: Also note that while the binary GHC release uses "make install" it doesn't actually compile anything
15:29:12 <merijn> Compiling GHC to install GHC is silly, as you need GHC to compile GHC in the first place :)
15:29:31 <merijn> dmj`: I just install ghc versions to ~/ghc/version and switch by alternating paths
15:29:43 <merijn> dmj`: Then I can just "rm -rf ~/ghc/version" to uninstall :)
15:29:55 <merijn> Much easier than finding the relevant files under /usr/local
15:31:16 <dmj`> merijn: yea, I just use whatever is latest (not head), I don't switch too often, if ever
15:33:16 <merijn> dmj`: You need more adventure in your life! ;)
15:33:27 <muyfine> @pl \xs n -> take n xs ==> flip take
15:33:27 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
15:34:10 <muyfine> @pl \as bs -> length . filter not . map (uncurry (==)) $ zip as bs
15:34:10 <lambdabot> ((length . filter not . map (uncurry (==))) .) . zip
15:34:19 <merijn> icbm: Last more practical summary, I would say: If you're lazy/just playing around with Haskell: Platform, starting to seriously develop and wanting to use bleeding edge libraries: manually install binary distribution of GHC/cabal
15:34:39 <merijn> icbm: Want to hack GHC/are a masochist: source install/snapshots :p
15:36:25 <phaazon> hm
15:36:36 <phaazon> new shot at my edsl, now using GADTs, no more bound
15:36:48 <phaazon> I actually don’t even need bound since I don’t want to evaluate the AST
15:37:37 <dmj`> merijn: I keep a copy of ghc locally, just to say I have it, not that I ever look at it.
15:38:49 <dmj`> merijn: ghc is beast, I ran a gource on it, it's like a universe inside of a universe
15:38:51 <dmj`> http://www.youtube.com/watch?v=cNBtDstOTmA
15:39:09 <phaazon> I can’t show the Lam ctor of my expression
15:39:13 <phaazon> which… makes sense actually
15:39:21 <phaazon> > print $ \x -> x + 1
15:39:22 <dmj`> merijn: its more like this: http://www.youtube.com/watch?v=AhDiYPLo3p4
15:39:23 <lambdabot>  <IO ()>
15:39:29 <phaazon> > show $ \x -> x + 1
15:39:32 <lambdabot>  "<Integer -> Integer>"
15:39:48 <phaazon> oh, it uses Typeable
15:39:51 <phaazon> nice :)
15:40:09 <icbm> merijn: I'm a lazy, intermediate stage Haskeller: well past the monad tutorial stage, but not yet comfortable with real codebases.
15:40:44 <icbm> Thanks for the help. I've got a plan now.
15:44:20 <phaazon> woah woah
15:44:22 <phaazon> what’s that
15:44:37 <dmj`> phaazon: hmm?
15:44:54 <chrisdone> phaazon: that's a computer. you're sat in front of it
15:44:57 <phaazon> I wrote a type, newtype Var t = Var { unVar :: String } deriving (Eq,Ord,Show)
15:45:09 <phaazon> :i Var gives me that as a first line :
15:45:09 <phaazon> type role Var phantom
15:45:24 <Wingsorc> I got a problem with where clauses. The code works if I use the commented out code but if I try to do it in a where clause it doesnt compile. http://pastebin.com/ySP8a8h8
15:45:53 <phaazon> I heard of roles, but I don’t know what they are exactly
15:45:53 <chrisdone> that's part of the new roles functionality in ghc 7.8 for coercing your newtypes
15:46:11 <phaazon> coercing, like a -> b ?
15:46:21 <chrisdone> Var t -> String
15:46:36 <phaazon> oh
15:46:43 <phaazon> but, that’s just obvious right?
15:46:44 <phaazon> it’s unVar
15:46:54 <chrisdone> theoretically, but in practice no
15:46:54 <phaazon> coerce = unVar
15:47:03 <phaazon> hm?
15:47:17 <chrisdone> consider: map unVar xs
15:47:26 <dolio> Wingsorc: What's the error message?
15:47:33 <chrisdone> is this a "free" coercion?
15:47:53 <phaazon> well
15:48:01 <Wingsorc> 99.hs:41:46: parse error on input `='
15:48:03 <Wingsorc> Failed, modules loaded: none.
15:48:04 <chrisdone> [Var] -> [String] should be free
15:48:04 <phaazon> what do you mean by “free”?
15:48:14 <chrisdone> it should be a no-op. compile-time only
15:48:36 <phaazon> chrisdone: since a newtype has no trace in runtime
15:48:40 <chrisdone> but actually map unVar will have runtime overhead
15:48:45 <dolio> Wingsorc: Which line is 41 in your file?
15:48:48 <phaazon> I guess unVar hasn’t
15:48:53 <phaazon> oh?
15:49:02 <Wingsorc> 41: combine y all@(x:xs) = if (y==x) then all else y:all	
15:49:12 <phaazon> why would it?
15:49:19 <phaazon> everything is constant
15:49:23 <dolio> Wingsorc: Are you using tabs?
15:49:39 <Wingsorc> I think so
15:50:10 <chrisdone> phaazon: that's just how it's implemented in ghc. map unVar isn't optimized to id
15:50:11 <dolio> That might be the problem. I think tabs are 8 spaces, so your code might be mis-indented.
15:50:36 <Wingsorc> how am I supposed to intend? I thought only the beginning of each line matters
15:50:44 <phaazon> chrisdone: that sucks
15:50:52 <phaazon> what’s the point with newtypes then…
15:50:57 <Wingsorc> or do the equal sign have to be on the same height?
15:50:59 <merijn> Wingsorc: lpaste the full file + error
15:51:21 <phaazon> only optimizing memory consumption?
15:51:32 <chrisdone> phaazon: well, now you can just use "coerce"
15:51:46 <merijn> phaazon: Read the release notes/manual on roles
15:51:53 <chrisdone> phaazon: thanks to the "roles", you can coerce a [Var] to a [String] with zero runtime overhead
15:51:54 <merijn> phaazon: That explains exactly what the problem is
15:51:58 <chrisdone> SPJ has a good talk about it
15:52:01 <chrisdone> let me find it…
15:52:12 <phaazon> I tried merijn
15:52:17 <dolio> Wingsorc: The 'combine's have to begin at the same logical column.
15:52:28 <phaazon> I felt like a baby reading some quantum materials papers.
15:52:37 <chrisdone> http://www.reddit.com/r/haskell/comments/2iqrr5/video_simon_peyton_jones_zerocost_coercions_in/
15:52:41 <phaazon> thank you
15:52:48 <Wingsorc> in my file they begin on the same height, but If I paste the file it changes
15:53:01 <phaazon> I think I’ve never used coerce yet
15:53:13 <phaazon> are coercions only valid for “down” coerce?
15:53:15 <dolio> Wingsorc: But, for instance, GHC might think your second line is indented more, and so thinks it's a continuation of the previous line. And = isn't a valid expression character.
15:53:20 <phaazon> (from the wrapper to its content?)
15:53:21 <merijn> phaazon: Of course you haven't, they're new in 7.8
15:53:24 <chrisdone> phaazon: they go both ways iirc
15:53:26 <dfeuer> phaazon, coerce is kind of weird.
15:53:42 <phaazon> merijn: I thought I saw that a few years ago
15:53:52 <phaazon> in some dark package
15:53:53 <merijn> phaazon: Are you thinking of unsafeCoerce?
15:53:54 <phaazon> for reification
15:54:00 <phaazon> ah, maybe
15:54:11 <merijn> phaazon: Because, as the name implies, that's something wildly different :)
15:54:17 <dolio> Wingsorc: It doesn't matter how it looks in your text editor. It matters how it is according to GHC's rules about how many spaces are equivalent to a tab, assuming you're using tab characters.
15:54:25 <phaazon> :t unsafeCoerce
15:54:26 <lambdabot> Not in scope: ‘unsafeCoerce’
15:54:33 <merijn> phaazon: "unsafeCoerce :: a -> b"
15:54:56 <chrisdone> coerce is a "safe" coerce because the compiler requires the right instances for the two types
15:54:58 <merijn> phaazon: This is like a few thousand times more dangerous than unsafePerformIO
15:55:01 <chrisdone> and those instances are generated automagically
15:55:11 <merijn> phaazon: unsafePerformIO gives you "confusing order of operations"
15:55:20 <merijn> phaazon: unsafeCoerce gives you segfaults
15:55:20 <chrisdone> (well, conceptual instances)
15:56:06 <freeman42> could someone tell me how to use sort or group with a generic type constraint Eq? I fried my brain thinking about it with no result yet, or better yet how to think about solving this question :)
15:56:20 <dolio> Wingsorc: Anyhow, there's no tabs in the paste. But maybe there are in your file (the space after the where suggests that to me). Maybe I'm wrong, though.
15:56:27 <HeladoDeBrownie> freeman42, Eq is not sufficient for a sort
15:56:30 <phaazon> merijn: why do we have that then… it’s like Prelude, Data.List, and a lot of other stuffs I don’t understand. why head doesn’t return Maybe a? why are there those ultra dangerous function (unsafe*)? why…
15:56:32 <chrisdone> freeman42: sounds like homework =)
15:56:53 <freeman42> chrisdone, codewars.com exercise :)
15:56:53 <Wingsorc> dolio: ok now I found an intendation level where the file compiles, but I dont understand how im supposed to intend the file since it doesnt look aligned in my editor
15:57:08 <dolio> Wingsorc: Use all spaces.
15:57:15 <merijn> phaazon: Why do we have it? Because sometimes smart programmers are smarter than GHC
15:57:21 <dolio> Or lay out your code so that you aren't using tabs for vertical alignment.
15:57:22 <chrisdone> phaazon: WHYYYYYY (╯°□°）╯
15:57:47 <phaazon> ok, so Coercible makes me think of MonadBase
15:58:07 <phaazon> hm, not MonadBase actually
15:58:22 <chrisdone> i once implemented a MonadBaseControl instance
15:58:24 <dolio> Most text editors should be able to expand tabs into spaces, though.
15:58:25 <chrisdone> three people died
15:58:27 <freeman42> HeladoDeBrownie, I don't care about the sort order :D just... to sort the ones equal to eachother sequencially, eg [0,0,3,4,1,1,6,3,3,3]
15:58:48 <merijn> phaazon: unsafeCoerce is an escape hatch for dons-level programmers who 1) know better than the compiler and 2) see how that makes their code faster, but 3) can't convince GHCs conservative type system of this
15:58:51 <phaazon> chrisdone: yeah
15:58:58 <phaazon> dealing with the StM is awful :D
15:59:20 <chrisdone> freeman42: consider: [5,2,9] how do you sort this list with Eq only?
15:59:20 <phaazon> merijn: I would say “write some C”
15:59:29 <phaazon> but you’d tell me I’m trolling :D
15:59:36 <Wingsorc> So only the amount of tabs and spaces matter, not the optical alignment?
15:59:54 <Wingsorc> if I put the whole thing one line below it works
16:00:03 <freeman42> chrisdone, leave it as it is, the sort should basically just make the equal items be adiacent to eachother (let's call it random sort as a joke :D )
16:00:06 <chrisdone> :t cast
16:00:07 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
16:00:07 <phaazon> merijn: I think a flag on the compiler should be passed for being able to use those functions
16:00:08 <Wingsorc> the stuff in the where block
16:00:09 <dolio> Wingsorc: The problem is likely that '\twhere\t' lines up with '\t\t' in your editor, but the former is 21 columns wide in Haskell, and the latter is 16 wide.
16:00:11 <int-e> phaazon: a fairly straight-forward use of unsafeCoerce is in Data.Typeable.
16:00:16 <merijn> phaazon: Code using these optimisations is not nearly as easy to produce
16:00:25 <chrisdone> :t cast
16:00:26 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
16:00:26 <int-e> phaazon: (see the cast function that chrisdone just queried for)
16:00:26 <chrisdone> ^ this function uses unsafeCoerce
16:00:40 <merijn> phaazon: You can block unsafeCoerce, read up on SafeHaskell
16:00:51 <Wingsorc> dolio: where can I get that info how haskell handles spaces and tabs?
16:00:56 <phaazon> that’s way beyond my scope I guess
16:01:05 <dolio> I'm sure the Haskell report says it.
16:01:14 <dolio> Somewhere.
16:01:31 <Wingsorc> ok thanks im going to search it
16:01:38 <phaazon> thank you for your warm answers guys :)
16:01:51 <phaazon> I’m returning to my hoast with gadt now :)
16:02:47 <merijn> There's a indentation wikibook
16:03:00 <merijn> Also, the report says that "tabs indent to the nearest 8 space tabstop"
16:03:01 <dolio> Oh, I guess I'm not right exactly. Tab characters go to the next tab stop. And tabstops are 8 characters apart.
16:03:18 <dolio> If you're displaying tabs as something other than 8 characters apart, though, it will still mess you up.
16:03:29 <Wingsorc> another question: so is everyone just using spaces since tabs are sometimes weird to handle?
16:03:31 <dolio> http://www.haskell.org/onlinereport/syntax-iso.html#layout
16:03:47 <dolio> Most people recommend using only spaces, I think.
16:04:11 <dolio> Wingsorc: People who do use tabs wouldn't start definitions on the same line as a where, though.
16:04:24 <phaazon> god, IsString + OverloadedStrings is so handy :D
16:04:28 <phaazon> I say that every single night
16:04:29 <dolio> They'd distinguish indentation from alignment.
16:04:33 <phaazon> but yeah, that ext rocks hard.
16:04:41 <dolio> Tabs being for indenting, and spaces for alignment.
16:04:53 <Wingsorc> I see that makes sense
16:05:18 <dolio> You could also not use layout at all, if you wanted.
16:05:24 <dolio> That's even less popular, though.
16:08:41 <n4x> @type unsafeCoerce
16:08:42 <lambdabot> Not in scope: ‘unsafeCoerce’
16:08:52 <n4x> why can't we crash λbot? ;P
16:10:15 <phaazon> we can already make it to do stupid things, don’t abuse it! :D
16:10:20 <phaazon> > let e = e in e
16:10:24 <lambdabot>  mueval-core: Time limit exceeded
16:11:05 <phaazon> > [0..] !! maxBound
16:11:08 <lambdabot>  mueval-core: Time limit exceeded
16:11:29 <Hafydd> > let e = sum [1/product [1..n] | n in [0..]] in e
16:11:30 <lambdabot>  <hint>:1:35: parse error on input ‘in’
16:11:40 <Hafydd> > let e = sum [1/product [1..n] | n <- [0..]] in e
16:11:44 <lambdabot>  mueval-core: Time limit exceeded
16:12:13 <Forkk> I'm trying to run hdevtools, but I keep getting this error. I know it has something to do with Template Haskell and -fno-code, but I can't seem to get figure out how to fix it. http://paste.ubuntu.com/8662756/
16:13:01 <phaazon> ahah
16:13:10 <phaazon> [0..] !! maxBound takes… time :D
16:13:38 <phaazon> it’s beautiful to see how the memory footprint is constant :)
16:13:46 <simpson> > [0..] !! maxBound :: Word16
16:13:47 <lambdabot>  *Exception: Prelude.(!!): index too large
16:13:55 <phaazon> what :D
16:14:01 <phaazon> > maxBound :: Word16
16:14:03 <lambdabot>  65535
16:14:17 <phaazon> > [0..] !! (maxBound :: Word16)
16:14:18 <lambdabot>  can't find file: L.hs
16:14:24 <Wingsorc> >product [1..10]
16:14:28 <phaazon> you destroyed lambdabot simpson
16:14:31 <n4x> > [(0∷Word8)..] !! (maxBound ∷ Word8)
16:14:33 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
16:14:33 <lambdabot>              with actual type ‘GHC.Word.Word8’
16:14:35 <simpson> > last [0..] :: Word16
16:14:36 <lambdabot>  65535
16:14:43 <n4x> > [(0∷Word8)..] !! (fromℤ (maxBound ∷ Word8))
16:14:44 <lambdabot>  Not in scope: ‘fromℤ’
16:14:44 <lambdabot>  Perhaps you meant ‘from’ (imported from Control.Lens)
16:14:46 <n4x> er
16:14:51 <phaazon> simpson: huh…
16:14:55 <phaazon> I really don’t get it
16:15:38 <phaazon> last [0..] stops when
16:15:43 <phaazon> yeah, when what?
16:15:47 <phaazon> this is pretty interresting
16:15:58 <mauke> at the end of the list
16:16:02 <phaazon> > last [0..] :: Word8
16:16:03 <lambdabot>  255
16:16:06 <phaazon> :–’
16:16:15 <phaazon> oh
16:16:19 <phaazon> I got it.
16:16:24 <simpson> [0..] !! 2 :: Word8
16:16:33 <simpson> > [0..] !! 2 :: Word8
16:16:35 <lambdabot>  2
16:16:46 <phaazon> since we ask a Word8
16:17:01 <phaazon> [0..] is an “infinite” list from 0 to maxBound
16:17:38 <phaazon> > take 3 [0..] :: [Integer]
16:17:39 <lambdabot>  [0,1,2]
16:17:53 <phaazon> but Integer is not in Bound…
16:18:02 <phaazon> Bounded*
16:19:38 <benzrf> shit
16:19:57 <benzrf> argument order can affect whether a function type checks :|
16:20:05 <benzrf> owch
16:20:44 <simpson> benzrf: Wait what?
16:20:55 * hackagebot hsebaysdk 0.1.0.0 - Haskell eBay SDK  http://hackage.haskell.org/package/hsebaysdk-0.1.0.0 (ChristopherReichert)
16:21:25 <benzrf> @let data Wat a where Int' :: Int -> Wat Int; Str' :: Wat String
16:21:29 <lambdabot>  Defined.
16:21:43 <benzrf> no wait.
16:21:53 <benzrf> @undef
16:21:53 <lambdabot> Undefined.
16:22:04 <benzrf> oh crap no that'll work
16:22:06 <benzrf> @let data Wat a where Int' :: Int -> Wat Int; Str' :: Wat String
16:22:08 <lambdabot>  Defined.
16:22:39 <benzrf> @let nope :: a -> Wat a -> a; nope x (Int' y) = x + y; nope s Str' = s
16:22:40 <lambdabot>  Defined.
16:22:43 <benzrf> wait, whaa?
16:22:53 <benzrf> well, my current code is a little more complicated
16:23:13 <benzrf> the point is that if i put the gadt first it typechecks but if i put the thing whose type needs to match the gadt's first it won't
16:27:56 <merijn> benzrf: Correct
16:28:11 <merijn> benzrf: A GADT pattern match adds constraints for the remaining typechecking
16:28:30 <benzrf> :|
16:28:38 <merijn> benzrf: Therefore, if you want to use typechecking facts for which the GADT is a witness, you need to match the GADT first
16:28:43 <benzrf> well that is something i wish i'd known before :|
16:30:18 <mauke> why?
16:37:23 <merijn> mauke: Why what?
16:38:15 <mauke> why the flat face?
16:38:30 <mauke> I mean, it doesn't have to affect your external interface
16:40:42 <merijn> Well, it can make composition a bit more awkward in your code
16:50:59 * hackagebot aeson-t 0.0.2 - Transform JSON  http://hackage.haskell.org/package/aeson-t-0.0.2 (begriffs)
16:55:45 <phaazon> I tried to read something about codensity monads
16:55:46 <phaazon> I tried.
16:57:29 <phaazon> we show that the codensity monad of the inclusion of (finite-dimensional vector spaces) into (vector spaces) is double dualization.
16:57:40 <phaazon> have I hit my head on something?
16:57:41 <phaazon> :D
16:58:07 <mauke> just use a zygohistomorphic prepromorphism
16:59:03 <benmachine> eh, the double dualisation of V looks a bit like Cont F V, so maybe it's not that weird
16:59:07 <exio4> I need the thing you are smoking
16:59:19 <exio4> because I am sure you are tripping right now!
17:01:57 <phaazon> 02:01 < mauke> just use a zygohistomorphic prepromorphism
17:02:03 <phaazon> this is exactly how I feel
17:02:08 <phaazon> “yeah, right, sure.”
17:02:20 <phaazon> that reminds me how I suck at category theory :(
17:02:48 <exio4> well, I suck at programming and mathematics, so you are good!
17:02:55 <phaazon> :D
17:06:42 <phaazon> ok, I think my DSL is a bit too ambitious yet :(
17:07:24 <Hijiri> I tried making a DSL for describing mahjong groups and I still haven't gone back to that
17:12:20 <phaazon> Hijiri: I’m writing a DSL to abstract shaders
17:12:34 <phaazon> so that anyone could write a shader an make it compiled on a specific backend
17:12:34 <MP2E> neat!
17:12:59 <phaazon> I think I’ll go with the not-that-typed AST
17:13:10 <phaazon> I got terribly confused with the GADT and instances
17:16:00 <phaazon> off to bed
17:16:03 <phaazon> see you later
17:16:08 <phaazon> night
17:27:14 <NJBS> Anyone know why this doesn't work for negative numbers? http://i.imgur.com/V6lSZ4o.png I get this error http://i.imgur.com/dBjXHpA.png
17:28:15 <indiagreen> NJBS: you have to surround negative numbers in brackets
17:28:19 <indiagreen> *parens
17:28:25 <indiagreen> at least when you're applying a function
17:28:41 <haasn> imgur is my favorite pastebin
17:28:58 <indiagreen> that is, “if ... then n else -n” is fine, but “abs -1” means “abs” minus “1”, and it doesn't make sense
17:29:33 <NJBS> Yep, thanks indiagreen.
17:32:46 <nkar> why was the IO instance removed from MonadLogger?
17:35:36 <isocliff_> does anyone know what to do about "Lambdabot.Plugin.Haskell.Eval.Trusted: Can't be safely imported!"?
17:39:38 <Aleksejs> Hi, does anyone here know something about spherical coordinates?
17:40:13 <darks> what about spherical Aleksejs ?
17:40:17 <isocliff_> what do you need to know?
17:40:24 <Aleksejs> http://math.stackexchange.com/a/833110 here is a formula to calculate distance between 2 coordinates
17:41:27 <Aleksejs> I implemented it in haskell and it fails: the results are obviously wrong. I checked wiki, and there is quite a mess with those coordinates:
17:42:03 <Aleksejs> first of all, different notations use theta for azimuth or elevation angle
17:42:37 <Aleksejs> and then, there's also can be 0..180 or -90..90 ranges
17:43:04 <Aleksejs> I wish to know what should I assume to use that formula the right way
17:46:33 <cutgovspend> we have the formula!
17:46:33 <cutgovspend> gi joe will never suspect!
17:48:56 <isocliff_> well theta is conventionally from 0-180, thats the angle away from the z axis, and phi goes from 0-360
17:49:28 <peddie> Aleksejs: did you check radians vs. degrees?
17:50:22 <Aleksejs> peddie: I use radians
17:50:28 <isocliff_> 0-180 and -90-90 doesn't matter because all the trig functions are periodic
17:50:45 <peddie> Aleksejs: just checking :)
17:51:52 <Aleksejs> isocliff_: I guess you're right. The only problem was because I used phi as z axis angle (as described on wiki http://upload.wikimedia.org/wikipedia/commons/d/dc/3D_Spherical_2.svg)
17:52:36 <Aleksejs> I switched them, and everything works fine
17:52:57 <isocliff_> yeah that diagram shows the coords used pretty much universally these days
17:53:14 <isocliff_> glad you solved it ;)
17:56:05 * hackagebot DifferenceLogic 0.1.0.1 - A theory solver for conjunctions of literals in difference logic  http://hackage.haskell.org/package/DifferenceLogic-0.1.0.1 (dillonhuff)
18:07:35 <romildo> Is a function   (flip . map)   defined in some library?
18:08:22 <CodeWeaverX> Probably not, given that you can just flip.map
18:08:37 <schell> romildo: yes - flip and map are defined (separately) in base
18:09:00 <schell> i think lambdabot can show you the source, tho i don’t know how to command it
18:09:23 * CodeWeaverX frequently misunderstands the nature of asked questions here it appears. ;)
18:10:29 <romildo> I meant  (flip map).
18:11:06 <schell> flip map is just map with the arguments flipped
18:12:16 <kadoban> romildo: I don't think there's one in prelude or any of the common packages
18:12:29 <kadoban> flip map is pretty concise though when you really need that...
18:12:32 <romildo> I would like to have a function named something like for or foreach for that.
18:12:39 <u-ou> :t map
18:12:40 <lambdabot> (a -> b) -> [a] -> [b]
18:12:41 <u-ou> :t mapM
18:12:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:12:59 <indiagreen> :t for
18:13:00 <lambdabot>     Not in scope: ‘for’
18:13:00 <lambdabot>     Perhaps you meant one of these:
18:13:00 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
18:13:02 <kadoban> :t forM
18:13:02 <indiagreen> :t T.for
18:13:03 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
18:13:04 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
18:13:33 <indiagreen> well, there is one “for” in utility-ht as well
18:13:43 <indiagreen> with signature “f a -> (a -> b) -> f b ”
18:13:52 <u-ou> call it flap
18:26:00 <orbital_> hi
18:26:41 <benzrf> hi
18:27:43 <orbital_> a very beginner question: say you have a schema where a column can be either a boolean, an int or a "composite" - a list of columns which can only be booleans
18:28:04 <orbital_> what would a reasonable data type look like?
18:29:06 <jueqingsizhe66> hi
18:29:37 <CodeWeaverX> If it’s the ‘list of columns’ variant, presumably those columns cannot also be boolean, int, and composite… like, this isn’t recursively defined?
18:32:12 <orbital_> correct, a "list of columns" may only include other boolean columns
18:32:49 <orbital_> the intent of this would be to instruct a client on how to construct a data representation in the UI, for example
18:33:20 <orbital_> rather than to represent the data in the database
18:34:30 <orbital_> i.e., if this is a composite column, look at other columns, else look in the database
18:34:57 <orbital_> i suspect i'm not expressing this adequately, which is half of my problem :)
18:35:17 <CodeWeaverX> This is meant to be a cache of data?  Like, the columns in this case contain rows, each of which is a boolean?
18:35:38 <holo> hi
18:36:18 <CodeWeaverX> Or are these just strings to represent names in a real database somewhere?
18:37:15 <orbital_> CodeWeaverX: to put this into concrete context, the data itself arrives at the client as JSON dicts. The client then constructs a "view", using only certain columns of that data - some of them coming directly from the data, some tranformed a little, like the composite columns. The "schema" is to describe the "view".
18:37:36 <orbital_> s/columns/fields/
18:37:43 <orbital_> (the data is tabular)
18:38:45 <holo> I noticed that haskell programmers frequently don't specify used functions in the imports. Why?
18:39:05 <benzrf> holo: just convention
18:39:09 <benzrf> conflicts dont happen all that much
18:39:28 <kadoban> I pretty much always do
18:39:36 <CodeWeaverX> orbital_: Ah, so this data structure is a description, not actually data from the JSON.
18:39:38 <kadoban> But I'm not very good at haskell, so not sure that says anything.
18:39:47 <orbital_> benzrf: but when they do...
18:40:03 <orbital_> CodeWeaverX: correct. A metaschema. :)
18:40:17 <Hijiri> sometimes I don't realize names will clash and then I go back and do sloppy things like import twice, but with qualification for some functions
18:40:31 <holo> kadokan. i'm pretty horrible at haskell yet. prolly I just have the bad habit of telling where stuff comes from yet. who needs to know that anyway :o)
18:40:44 <benzrf> holo: get a tool to tell you
18:40:48 <benzrf> haskell is fantastic for static tools
18:41:22 <Hijiri> I'm not a static tool
18:41:28 <monochrom> I am.
18:41:35 <orbital_> in the Python world i've learned to respect "import *" as one of the greater evils
18:41:51 <CodeWeaverX> orbital_: sounds like you need something like a structure BooleanColumn to represent one of those, an probably containing only a string or column ID as its data…. and then a Schema data type that would have three variant types (three constructors), for the single-column case, the integer case, and the composite column case, and the two cases involving columns use the BooleanColumn type.
18:42:12 <CodeWeaverX> s/structure/data type/
18:43:00 <orbital_> CodeWeaverX: thanks. I was thinking separate datatypes (corresponding to field types) would be the answer, good to know I wasn't that far off.
18:43:20 <monochrom> in http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml , I write explicit imports, mostly for pedagogical reason: I want to tell you where to find the things I use.
18:44:05 <monochrom> however, I simply asked "ghc -ddump-minimal-imports" to tell me :)
18:44:05 <solatis> is there any recommended practice for this?
18:44:16 <solatis> personally i like to always do named imports
18:44:35 <CodeWeaverX> orbital_:  You could do this essentially with two ‘data’ declarations, but with one of them having three ways to construct it… three constructors… corresponding to the variations you suggested.
18:44:50 <kadoban> I've used exercism.io for learning haskell style, they all seem to recommend named/minimal imports. Not sure if that's just a local thing though.
18:45:15 <kadoban> Whatever they're called, explicit imports I guess
18:45:46 <monochrom> it is easy and unfair for Java or Python people to talk down upon Haskell people on explicit imports.
18:45:58 <solatis> kadoban: yeah i like that too
18:46:02 <monochrom> suppose you have 2 classes, each class has 100 methods.
18:46:09 <solatis> i want to know where my parseUrl function is coming from, for example
18:46:09 <orbital_> <- not talking down
18:46:21 <holo> I'll still tell where functions come from for three reasons: i don't care about the extra typing, it's not obtrusive, and it's more informative, even if just a little more
18:46:27 <monochrom> in Java and Python, that means only 2 lines of imports, no matter how explicit and detailed you are
18:46:27 <m00nlight> If i want to replace unicode character "∀" in a string
18:46:29 <m00nlight> how can I do
18:46:45 <orbital_> i'm just well in touch with my painful memories
18:46:46 <monochrom> or rather, 2 names to import.
18:46:47 <m00nlight> subRegex produce very string result
18:46:49 <m00nlight> subRegex (mkRegex "∀") "dumy :: Double -> Double -> Double" "forall"
18:46:53 <orbital_> CodeWeaverX: right
18:46:56 <m00nlight> "foralldforalluforallmforallyforall forall:forall:forall forallDforalloforalluforallbforalllforalleforall forall-forall>forall forallDforalloforalluforallbforalllforalleforall forall-forall>forall forallDforalloforalluforallbforalllforalleforall"
18:47:20 <monochrom> in Haskell, that means 202 names to import, because you don't have 2 classes, you have 2 types and 200 functions.
18:47:21 <m00nlight> seems insert forall between every adjancent character
18:47:53 <orbital_> why not simply qualified imports?
18:48:15 <monochrom> until one day Java or Python become purely functional, the comparison is simply biased.
18:48:30 <kadoban> qualified imports can be nice..but they suck for operators and types
18:48:36 <monochrom> qualified imports are pretty common
18:48:55 <kadoban> Of course you can just re-import the operators and types explicitly
18:49:04 <monochrom> but yeah, until you are looking at "sin Data.Functor.<$> [1,2,3]"
18:49:22 <kadoban> Heh, right
18:49:36 <monochrom> so, in addition, until one day Java or Python supports user-defined operators, the comparison is also simply biased.
18:49:45 <solatis> :)
18:49:58 <solatis> ah but user-defined operators are evil, not? :)
18:50:21 <kadoban> In haskell? Naw, they're pretty great
18:50:32 <solatis> yeah i know, it's a common complaint about c++ tho
18:50:47 <kadoban> Ya, in C++ they tend to be a mistake more often than not.
18:51:16 <monochrom> anyway, it is so easy to be talked into the moral high ground of explicit imports, until you realize that castrated languages clearly have so few issues to worry about
18:51:16 <solatis> yeah, if you're not defining a library with a DSL, you probably don't need operator overloading
18:51:27 <solatis> but it does allow for some great functionality
18:52:06 <kadoban> I guess I'll just do explicit imports until they become unwieldy
18:52:21 <holo> one of the reasons i wanted to learn haskell was the ability to print and read it on paper.. but now i need to use a tool!
18:52:46 <solatis> wait, what
18:52:49 <holo> nah i'm just kidding..
18:52:54 <solatis> people actually print code on paper?
18:53:10 <monochrom> of course, whenever practical, I give you explicit imports, I want to help you find where things come from
18:53:19 <kadoban> I do occasionally...when I'm going somewhere my laptop would be annoying to bring
18:53:54 <exio4> if my laptop is too annoying to bring somewhere, I think that gives me the hint that I shouldn't be coding there :P
18:53:59 <solatis> hmmm
18:54:56 <solatis> or maybe it's a hint you shouldn't go there ;)
18:55:12 * solatis die hard nerd
18:55:35 <benzrf> solatis: "is a" here u dropped this
18:56:03 <m00nlight> why subRegex (mkRegex "∀") "dumy :: Double -> Double -> Double" "forall" produce very strange result
18:56:11 <kadoban> Anyone know if the code for hakyll is any good quality? Looking for interesting projects to learn from
18:56:20 <m00nlight> "foralldforalluforallmforallyforall forall:forall:forall forallDforalloforalluforallbforalllforalleforall forall-forall>forall forallDforalloforalluforallbforalllforalleforall forall-forall>forall forallDforalloforalluforallbforalllforalleforall"
18:56:22 <holo> I had a teacher of algorithms who compressed code of his book examples in funny ways. one day i asked him why, and he told me that, because he printed them, for each program to fit entirely in a A4 sheet, he had to do it that way
18:56:36 <kadoban> m00nlight: A regex is a pretty bad way to replace one single character
18:57:56 <dmwit> m00nlight: Perhaps your regex implementation does not support Unicode properly.
18:58:00 <dmwit> What implementation are you using?
18:58:03 <nkar> why does let !(foo, bar) = ... force just 'foo'?
18:58:06 <m00nlight> Text.Regex
18:58:14 <m00nlight> dmwit: Text.Regex
18:58:29 <m00nlight> kadoban: So only use list transform to replace one character?
18:58:33 <nh2> anybody here using solaris?
18:58:49 <kadoban> m00nlight: Use Data.Text.replace, or just a manually coded map, yeah
18:58:56 <kadoban> m00nlight: Using a regex is super heavyweight for that
18:59:08 <dmwit> m00nlight: "Note that the posix library works with single byte characters, and does not understand Unicode."
18:59:17 <dmwit> m00nlight: From the documentation here: http://hackage.haskell.org/package/regex-posix-0.95.1/docs/Text-Regex-Posix.html
18:59:39 <dmwit> m00nlight: Linked at the top of http://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html
19:00:02 <m00nlight> dmwit, kadoban: Thanks
19:28:24 <kadoban> Any recommendations for a module that allows globbing? I essentially need S.D.doesFileExist except it needs to work with "blah.*"
19:28:44 <kadoban> Or something that allows me to implement same of course
19:31:16 * hackagebot colchis 0.2.0.2 - Rudimentary JSON-RPC 2.0 client over raw TCP.  http://hackage.haskell.org/package/colchis-0.2.0.2 (DanielDiazCarrete)
19:31:33 <pharpend_> kadoban: i don't know of any
19:31:59 <pharpend_> kadoban: https://hackage.haskell.org/package/Glob
19:33:42 <kadoban> Hmm, thanks
20:01:19 * hackagebot hans 2.4.0.0 - IPv4 Network Stack  http://hackage.haskell.org/package/hans-2.4.0.0 (TrevorElliott)
20:06:31 <Hodapp> :t (foldr (<>))
20:06:32 <lambdabot> Monoid b => b -> [b] -> b
20:06:42 <Hodapp> :t (foldr (<>) id)
20:06:43 <lambdabot> Monoid a => [a -> a] -> a -> a
20:07:12 <benzrf> Hodapp: perhaps you want endo
20:07:29 <benzrf> :t ala Endo foldMap
20:07:30 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
20:07:49 <Hodapp> I'm just confused as to how that 2nd one produces the typeclass constraint it does
20:08:02 <benzrf> Hodapp: because the default monoid instance for funcs is pointwise
20:08:12 <benzrf> @src Monoid (a -> b)
20:08:12 <lambdabot> Source not found. There are some things that I just don't know.
20:08:15 <benzrf> er
20:08:49 <benzrf> instance Monoid b => (a -> b) where mempty = const mempty; mappend f g x = f x <> g x
20:08:54 <benzrf> iircc
20:08:56 <benzrf> *iirc
20:09:09 <benzrf> for composition you want Endo
20:09:10 <benzrf> @src Endo
20:09:10 <lambdabot> Source not found. Just try something else.
20:09:13 <benzrf> bleh
20:09:20 <benzrf> newtype Endo a = Endo (a -> a)
20:09:31 <benzrf> :t getEndo
20:09:32 <lambdabot> Not in scope: ‘getEndo’
20:09:36 <benzrf> what's it called...
20:09:40 <benzrf> @hoogle Endo a -> a -> a
20:09:43 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
20:09:44 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:09:44 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
20:09:48 <benzrf> ah, appEndo
20:09:50 <benzrf> Hodapp:
20:10:12 <benzrf> > appEndo (mappend [(+1), (*2), (-5)]) 17
20:10:14 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Endo a’
20:10:14 <lambdabot>              with actual type ‘[a0 -> a0] -> [a0 -> a0]’
20:10:18 <benzrf> heuh?
20:10:22 <benzrf> oh der
20:10:29 <benzrf> > appEndo (mappend [Endo (+1), Endo (*2), Endo (-5)]) 17
20:10:31 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Endo a’
20:10:31 <lambdabot>              with actual type ‘[Data.Monoid.Endo a0] -> [Data.Monoid.Endo a0]’
20:10:49 <benzrf> what the heck??
20:10:56 <benzrf> oh DAMMIT
20:11:07 <benzrf> > appEndo (mappend [Endo (+1), Endo (*2), Endo (subtract 5)]) 17
20:11:09 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Endo a’
20:11:09 <lambdabot>              with actual type ‘[Data.Monoid.Endo a0] -> [Data.Monoid.Endo a0]’
20:11:18 * benzrf sobs
20:11:36 <benzrf> inb4 shachaf yells at me
20:12:21 <benzrf> omg how did i miss that
20:12:45 <benzrf> > appEndo (mconcat [Endo (+1), Endo (*2), Endo (subtract 5)]) 17 -- Hodapp, FINALLY
20:12:46 <lambdabot>  25
20:20:17 <Hodapp> benzrf: thanks. The code was morphed over from something where it wasn't immediately clear that composition was going on, till now...
20:23:49 <benzrf> Hodapp: fun fact: `Endo a' is the monoid you get by restricting the category Hask to a single object (a)
20:26:22 * hackagebot Randometer 0.1.0.1 - Randomness intuition trainer  http://hackage.haskell.org/package/Randometer-0.1.0.1 (So8res)
20:27:17 <cutgovspend> oow yesod and snap!! wow awesome web haskell stuff!!!
20:28:42 <Hodapp> http://hodapple.com/files/spiral_thingy.svg
20:28:48 <Hodapp> that's the silly thing that you just helped unlock
20:28:52 * Hodapp is poking around in Diagrams
20:29:37 <benzrf> iiiim    gonna sleepp
20:29:44 <benzrf> bye
20:32:22 <cutgovspend> should ghc work fine on openbsd?
20:32:28 <cutgovspend> amd64
20:38:16 <chrisdone> first export of my haskell keylogger =) http://jsfiddle.net/0ohc61oo/embedded/result/
20:42:39 <cutgovspend> u spy
20:43:48 <kvanb> no u
20:44:09 <kvanb> nominolo: hey I saw you push that stuff to lambdachine
20:44:26 <kvanb> but ghc is ripping Integer out of its core, if you didn't know.
20:49:59 <cutgovspend> so ghc should work fine on openbsd
20:52:46 <dfeuer> edwardk, what makes Trifecta good (if it is)?
20:52:57 <Polarina> Is it possible to define a type synonym such as "type OpenGL = MonadIO m => ReaderT Scope m"?
20:53:33 <dfeuer> No, Polarina.
20:54:22 <Polarina> dfeuer, isn't there an extension that can provide this functionality?
20:54:47 <dfeuer> Dunno.
20:56:53 <octopuscabbage> is haskell a good language for machine learning
20:56:59 <octopuscabbage> err i should say
20:57:01 <octopuscabbage> learning machine learning
20:57:25 <octopuscabbage> given that i also know python, c++
20:57:33 <Polarina> octopuscabbage, do you have any particular concerns?
20:57:44 <kvanb> dfeuer: the errors
20:57:45 <kvanb> are incredible
20:57:49 <kvanb> the speed, not so much.
20:58:01 <kvanb> and the api ... more to be desired
20:58:07 <octopuscabbage> Polarina, no, i just know those three languages the best and figured it would be fairly easy to do functionally
20:58:15 <octopuscabbage> assuming there is decent library support for it
20:58:16 <kvanb> feels lacking compared to other parser combinator libraries imo
20:58:18 <dfeuer> kvanb, interesting. Do you think the speed will go up?
20:58:31 <kvanb> I dont think edwardk is actively working on it right now
20:58:35 <dfeuer> Ah.
20:58:42 <dfeuer> Got it.
20:58:46 <kvanb> I heard at a lambda jam there was plans to make it cool?
20:58:50 <kvanb> or maybe thats not the case anymore
20:59:19 <kvanb> I do like hte idea of generic parser combinator frontends though
20:59:22 <kvanb> that part is cool
21:00:26 <dfeuer> Thanks, kvanb.
21:02:21 <dibblego> use parsers, of which trifecta is one of several instances
21:03:25 <cutgovspend> do most haskellers use ubuntu?
21:04:10 <pepper_chico> who would know that
21:08:46 <cutgovspend> on openbsd amd64 should haskell ghc work fine?
21:08:48 <cutgovspend> :)
21:08:58 <cutgovspend> ghci launches fine
21:09:07 <cutgovspend> I wonder about kqueue and performance....hmm
21:26:46 <ajrouvoet> Can somebody explain this to me: let x = [1,[2,3]] :: (Num [t], Num t) => [[t]]
21:27:16 <shiona_> ajrouvoet: that is a list that contains both a number and a list of numbers
21:27:44 <shiona_> that's something base haskell list cannot do, as a list needs to consist on only one type
21:28:09 <dmj`> are there any dynamo db projects for haskell outside of the 'aws' package?
21:28:21 <dmj`> a hackage check tells me no, but wanted to be sure
21:28:56 <ajrouvoet> but I tried this in base haskell
21:29:49 <shiona_> let x = [[1],[2,3]] is the closest thing that does work
21:29:57 <jle`> um
21:30:01 <jle`> i'm pretty sure base haskell can do this
21:30:16 <jle`> can't it?
21:30:27 <jle`> :t [1,[2,3]]
21:30:28 <lambdabot> (Num [t], Num t) => [[t]]
21:30:32 <ajrouvoet> i defined x like that and that type was inferred by ghci
21:30:43 <dmj`> :t [1,[2,3], 3, [[4,5],6]]
21:30:44 <lambdabot> (Num [[t]], Num [t], Num t) => [[[t]]]
21:30:55 <u-ou> what!
21:31:09 <jle`> that's because a numeric literal like 1 can stand for any Num instance
21:31:21 <jle`> so if you had a Num instance for [Int]
21:31:26 <u-ou> oh
21:31:31 <u-ou> yeah, lol
21:31:56 <Hijiri> > [1, [2,3]]
21:31:58 <lambdabot>  No instance for (GHC.Show.Show t0)
21:31:59 <lambdabot>    arising from a use of ‘M554233162782671333321416.show_M5542331627826713333...
21:31:59 <lambdabot>  The type variable ‘t0’ is ambiguous
21:31:59 <lambdabot>  Note: there are several potential instances:
21:31:59 <lambdabot>    instance [safe] GHC.Show.Show
21:33:45 <jle`> @let instance Num a => Num [a] where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
21:33:48 <lambdabot>  Defined.
21:33:53 <jle`> > [1, [2,3]]
21:33:56 <lambdabot>  [[1],[2,3]]
21:34:06 <dmj`> :t ["a", ["j", [["aa"]]]]
21:34:08 <lambdabot>     Couldn't match expected type ‘Char’ with actual type ‘[Char]’
21:34:08 <lambdabot>     In the expression: "j"
21:34:08 <lambdabot>     In the expression: ["j", [["aa"]]]
21:35:14 <jle`> > [1,2] + [5,6]
21:35:16 <lambdabot>  [6,7,7,8]
21:35:28 <jle`> > 3 * [5,6]
21:35:32 <lambdabot>  [15,18]
21:36:01 <jle`> matlab in haskell
21:36:19 <ajrouvoet> I see
21:36:43 <jle`> so (3 * [5,6])... it tries to match both sides of (*) to the same type
21:36:54 <jle`> the right side matches with [Int]
21:37:03 <jle`> and so does the left side, because [Int] is a Num instance now
21:37:53 <ajrouvoet> Yes, makes perfect sense
21:38:24 <jle`> something like "3" is parsed as (fromInteger (3 :: Integer))
21:38:45 <jle`> so [1,[2,3]] is [fromInteger 1, [fromInteger 2, fromInteger 3]]
21:38:47 <jle`> but you probably get it already
21:39:05 <ajrouvoet> I also got tricked by 7.8 ghci, which has NoMonomorphismR by default -_-
21:39:25 <ajrouvoet> Thanks!
21:41:58 <jle`> ah the DNMR
21:46:38 <Hermit> wtf
21:46:48 <Hermit> :t [1,[2,3]]
21:46:49 <lambdabot> Num t => [[t]]
21:46:56 <Hermit> 0_o
21:46:59 <Hermit> w-t-f
21:48:01 <Hermit> hmm, I guess 1 is being treated as [1] but rendered without the brackets
21:49:25 <Hermit> since when does this work like this
21:49:54 <jle`> Hermit: i defined a Num instance earlier
21:50:11 <Hermit> [Int]?
21:50:11 <jle`> a literal like 1 is interpreted as (fromInteger (1 :: Integer))
21:50:17 <jle`> :t fromInteger
21:50:18 <lambdabot> Num a => Integer -> a
21:50:25 <jle`> so it could really represent any Num instance
21:50:33 <jle`> so in this case, we have a Num instance defined for [Int]
21:50:42 <jle`> so a 1 can be interpreted as [Int]
21:51:01 <Hermit> yeah, it's clear, it took me off guard though
21:51:42 <jle`> weird num instances throws everyone off :P
21:51:50 <pavonia> Shouldn't the type be (Num [t], Num t) => [[t]] be then?
21:51:55 <Hermit> 2am and I saw something unheard of...
21:52:10 <jle`> because you can pretty much write a Num instance for anything, there are some weird things you can do
21:52:20 <jle`> one interesting thing is that you can get a lawful Num instance for any Applicative
21:52:28 <jle`> so for any Applicative instance, you get a free Num instance
21:53:04 <jle`> pavonia: there's a Num instance earlier defined earlier as Num t => Num [t], so [t] is a Num if t is a Num.  so t has to be Num
21:53:52 <pavonia> Oh, I see
21:53:59 <jle`> @undef
21:53:59 <lambdabot> Undefined.
21:54:02 <jle`> :t [1,[2,3]]
21:54:03 <lambdabot> (Num [t], Num t) => [[t]]
21:55:42 <shiona_> > [1,2,3] :: [[[[Int]]]]
21:55:43 <lambdabot>  No instance for (GHC.Num.Num [[[GHC.Types.Int]]])
21:55:44 <lambdabot>    arising from the literal ‘1’
21:56:06 <Hermit> I still think something like 3 * [2,3] should be avoided. Smells like java's 3 + "abc"
21:56:17 <shiona_> ah, just undeffed
21:56:52 <shiona_> Hermit: yes, that's why we have maps and lifts.
21:57:03 <Hermit> and zips
21:57:17 <Hermit> zipWith (+) [1,2] [5,9]
21:58:22 <Hermit> ...
21:58:28 <Hijiri> liftA2 (*) [[0,1,0,0]] [[1,2,3,4],[3,4,5,6]]
21:58:44 <Hijiri> > liftA2 (liftA2 (*)) [[0,1,0,0]] [[1,2,3,4],[3,4,5,6]]
21:58:46 <lambdabot>  [[0,0,0,0,1,2,3,4,0,0,0,0,0,0,0,0],[0,0,0,0,3,4,5,6,0,0,0,0,0,0,0,0]]
21:59:25 <Hermit> damn, sometimes I miss ad-hoc polymorphism where shit like [1,2] + [3,4] is perfectly legal, but I know where that road ends: a bunch of funky overloading leading to gotchas everywhere
21:59:38 <Hermit> despite the convenience, it's no good
22:00:20 <Hijiri> is that supposed to be zip (+) or ++?
22:01:38 <Hermit> I wonder what's worse, funky overloading or funky use of combinators
22:03:25 <jle`> Hijiri: it's a cartesian product
22:03:31 <jle`> > liftA2 (,) [1,2,3] [4,5,6]
22:03:33 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:03:45 <shiona_> that would be a third possibility
22:04:31 <jle`> Num with zipWith is another valid instance, but it's a little less useful (or interesting?) because fromIntegral would give you an infinite list
22:05:10 <Hijiri> well I meant what hermit meant
22:05:19 <Hijiri> not specifically your instance
22:05:19 <jle`> ah mk
22:05:38 <jle`> but basically, we could make a Num instance so that [1,2] + [3,4] = [4,6]
22:06:27 <Hermit> Hijiri: ah, yeah, I was thinking of zipWith (+)
22:12:04 <pjdelport> A num instance for Num a => [a] shouldn't actually lead to much gotchas in Haskell. It stays principled and well-typed.
22:14:07 <nshepperd> except then you would be able to write [1, [2, [3, 4, 5]]]
22:14:21 <nshepperd> and that's just entirely freaky
22:17:04 <merijn> pjdelport: "Num a => [a]" is not very sensible, but "Num [()]" is :p
22:17:23 <fragamus> I am using a V 9 in Linear, but I really would like to make it choose the size at run time. Am I screwed?
22:30:00 <dfeuer> merijn, just because you *can* doesn't mean you *should*.
22:31:25 <haskell_cabal> Hi guys, I am trying to install the latest version cabal on linux but I keep seeing 1.16.0. I followed multiple steps on this site here:
22:31:26 <haskell_cabal> http://www.haskell.org/cabal/download.html
22:31:32 <haskell_cabal> tried to install from source
22:31:41 <haskell_cabal> tried to install via sudo-apt get install cabal-install
22:31:47 <haskell_cabal> and thyen do the sudo cabal install cabal cabal-install
22:32:05 <haskell_cabal> I followed the readme insided the source download too
22:32:11 <haskell_cabal> but still, I keep getting 1.16
22:32:13 <haskell_cabal> any ideas?
22:32:26 <haskell_cabal> I also tried the binary downloads
22:32:26 <haskell_cabal> thanks
22:34:22 <Hijiri> put your ~/.cabal/bin in your path
22:34:29 <Hijiri> so that the binaries there will be found
22:34:46 <haskell_cabal> Hey at Hijiri , I tried looking for ~/.cabal but i didnt seem to have such a dir
22:34:46 <haskell_cabal> hmm
22:34:49 <haskell_cabal> let me check again
22:35:07 <haskell_cabal> okay nvm i see it now
22:35:43 <haskell_cabal> okay i did that
22:35:48 <haskell_cabal> but i still see 1.16
22:36:20 <haskell_cabal> i'm going to sudo apt-get remove cabal-install
22:36:21 <haskell_cabal> see if that helps
22:36:23 <Hijiri> restart the terminal?
22:36:47 <Hijiri> make sure it's actually in ~/.cabal/bin
22:37:15 <haskell_cabal> i do see cabal executable in there
22:37:33 <haskell_cabal> hmm
22:37:41 <Hijiri> make sure that the cabal bin directory comes before the global bin directories in your path
22:37:48 <Hijiri> so that it gets checked first
22:37:51 <haskell_cabal> i see
22:38:57 <haskell_cabal> Finally thanks
22:59:34 <torpet> hi, why does this function work even though no arguments are passed
22:59:37 <kvanb> joelteon: hey
22:59:50 <kvanb> could you merge Magiclouds PR on concurrent-state please?
22:59:57 <torpet> http://lpaste.net/488296034473082880
23:00:56 <Hijiri> the definition is saying that concatNumbers is the composition of concat and map show
23:01:14 <Hijiri> the composition operator, (.), takes two functions and composes them together
23:01:35 <solatis> hmmm i find myself lately to prefer to use non-monadic code of a library instead of the monadic code, because it seems more easy and intuitive to use the non-monadic code
23:01:53 <Hijiri> (f . g) x = f (g x)
23:01:55 <solatis> is that a bad habit, and should i just continue to fight with the monads until i finally 'get it' ?
23:02:07 <Hijiri> and then you can leave off the x to get the definition of f . g
23:02:34 <Hijiri> sometimes you don't need the monadic instances
23:02:48 <torpet> Hijiri: So it's valid because there is no other point where the argument could go?
23:02:51 <Hijiri> but if you want to decide what stuff to use based on the result of a computation, you need it
23:03:08 <Hijiri> torpet: it's valid because the (.) operator returns a function
23:03:11 <solatis> an example, consider a database library -- the monadic code wraps all the connections and context, but exposes a FooDb f monad -- i find it easier and more intuitive to use the non-monadic code and wrap my code in some brackets () () () to handle the allocation and cleanup of resources
23:04:44 <Hijiri> are you making any more DB things based on the results of a query?
23:05:11 <kvanb> solatis: it depends
23:05:14 <solatis> ok
23:05:19 <solatis> consider this example: http://hackage.haskell.org/package/http-conduit-1.6.0/docs/Network-HTTP-Conduit.html#g:4
23:05:23 <kvanb> if you dont want people using the previous version of something, use a monad
23:05:51 <solatis> the withManager () to me is incredibly opinionated and unintuitive to use
23:06:09 <solatis> i rather just use bracket to do a newManager and closeManager
23:06:36 <solatis> the manager here is used to keep-alive http connections between requests
23:07:26 <solatis> i understand that with a monad, you can, for example, guarantee isolation of a context
23:07:40 <solatis> (in this case, guarantee that a http manager is always cleaned up after it goes out of scope)
23:08:09 <johnw> solatis: the with* CPS idiom guarantees no escaping of the scoped resource
23:08:17 <solatis> exactly
23:08:27 <solatis> and my with* usually is a curried bracket ()
23:08:39 <solatis> withHttp :: (HC.Manager -> IO a) -> IO a
23:08:40 <solatis> withHttp = bracket
23:08:42 <solatis>            (HC.newManager HC.conduitManagerSettings)
23:08:44 <solatis>            (HC.closeManager)
23:08:46 <solatis> that kind of thing
23:08:53 <johnw> withManager isn't a bracket?
23:09:14 <solatis> no it uses conduit streams and resources
23:09:59 <solatis> https://github.com/snoyberg/http-client/blob/56d05024c6930b32221a2f79d73bbe2bda5b464f/http-conduit/Network/HTTP/Conduit.hs#L282
23:10:09 <solatis> it's a bracket, but it uses runResourceT f
23:10:17 <solatis> so your function cannot return IO () anymore
23:10:32 <johnw> he's using the wrong monad-control idiom there to
23:10:32 <solatis> but must return some conduit resourceT
23:11:25 <solatis> and yes, i know the differences between bracket and runresourcet
23:11:33 <johnw> it should be liftBaseOp (bracket (newManager set) closeManager) (runResourceT . f)
23:12:04 <johnw> i'm pretty sure snoyberg knows this too, or maybe he learned it recently, because I've seen him use that elsewhere I thought
23:12:20 <solatis> yeah anyway, i like to keep my code simple and clean
23:12:36 <johnw> well, I'm pretty sure he has his reasons
23:12:39 <solatis> yeah
23:12:50 <johnw> he's thought a *lot* about this domain
23:12:54 <solatis> i know
23:13:00 <solatis> so that's why i'm wondering
23:13:18 <johnw> ask him,  he follows the Haskell subreddit pretty closely
23:13:23 <solatis> whether i should just accept his opinion and try to embrace it
23:13:32 <solatis> is he on irc?
23:13:37 <johnw> very very rarely
23:13:43 <johnw> I prefer not using ResourceT when I can avoid it
23:14:15 <solatis> yeah but that's what i get for using http-conduit
23:14:22 <solatis> i could expect ResourceT there :)
23:14:28 <johnw> I find it too easy to get into "double-free" scenarios, because you used liftResourceT in a place where you should have using liftIO $ runResourceT; and the bug is reported very distant from the problem
23:15:36 <solatis> well for me, i just find it harder to understand what's going on under the hood
23:15:42 <johnw> sure, and that
23:15:47 <johnw> "action at a distance" always has that effect
23:16:16 <solatis> yeah exactly, errors should emerge as closely to the source as possible
23:17:33 <solatis> but i'm just wondering whether this is still my c++/imperative programmer-habits emerging, or an actually good opinion (that these 'monads' add more complexity than they solve for my use case)
23:18:04 <johnw> it's the "for my use case" part that makes it impossible for me to answer that :)
23:18:42 <solatis> i understand
23:18:56 <solatis> and that's the only correct answer you could give :)
23:19:19 <solatis> guess i'll follow my gut intuition on this one then
23:21:42 * hackagebot hs-php-session 0.0.9.3 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.3 (elblake)
23:31:53 <haskell_cabal> Anyone here have any luck installing yesod?
23:32:01 <haskell_cabal> I am getting this weird erro:
23:32:02 <haskell_cabal> yesod-static-1.4.0.2 depends on language-javascript-0.5.13 which failed to install.
23:32:15 <haskell_cabal> I am following this:
23:32:16 <haskell_cabal> http://www.yesodweb.com/page/quickstart
23:32:21 <haskell_cabal> the stackage server
23:32:44 <haskell_cabal> part, trying to run the cabal install --enable
23:33:11 <haskell_cabal> I suppose I should install stackage
23:33:12 <haskell_cabal> hmm
23:34:28 <solatis> is that an error raised by cabal, or by some configure script/
23:34:34 <solatis> as in
23:34:49 <solatis> it says it attempted to install language-javascript
23:34:55 <solatis> which failed
23:35:13 <solatis> what are the error logs that lead to that failure?
23:35:36 <haskell_cabal> I have a bigger set of errors , which paste bin do you guys prefer on this channel?
23:35:38 <haskell_cabal> any?
23:35:46 <solatis> lpaste.new/new/haskell
23:35:56 <solatis> ehr
23:35:58 <solatis> t
23:35:59 <jle`> haskell_cabal: it's in the topic :)
23:36:10 <jle`> ^^
23:37:20 <haskell_cabal> http://lpaste.net/113188
23:37:54 <haskell_cabal> I'm reading about this stackage server
23:37:59 <haskell_cabal> I'm suppposed to add this
23:38:00 <haskell_cabal> remote-repo: stackage:http://www.stackage.org/stackage/ef349de08b9be4ebaff08c85dcaa2a6258d0f5e4
23:38:07 <haskell_cabal> to my cabal configure
23:38:42 <haskell_cabal> i see a config but no cabal.config
23:40:10 <solatis> language-javascript-0.5.13 failed during the configure step. The exception
23:40:12 <solatis> was:
23:40:14 <solatis> ExitFailure 1
23:40:16 <solatis> that's not saying a lot
23:40:31 <solatis> but you need to get that message
23:40:44 <solatis> otherwise there's no way of knowing why it failed to install
23:40:45 <haskell_cabal> I keep seeing those, last time I saw those , fixed by adding sudo =/
23:40:53 <haskell_cabal> how do I get that message?
23:41:53 <merijn> haskell_cabal: If there's cabal errors, rerun with "-v3"
23:41:57 <solatis> cabal install --help
23:42:04 <solatis> there's a verbosity level there
23:42:10 <solatis> you probably need to change that
23:42:13 <haskell_cabal> hmm
23:43:40 <solatis> i would focus on cabal install language-javascript now
23:43:58 <haskell_cabal> It is complaining about happy version not installed
23:44:06 <haskell_cabal> or a version not compatible
23:44:08 <solatis> ah
23:44:12 <solatis> welcome to cabal dependency hell
23:44:16 <haskell_cabal> =-(
23:44:18 <solatis> i'll leave this discussion right here
23:44:21 <haskell_cabal> this is worse than npm hahaha
23:44:44 <solatis> hint: you need to use cabal sandboxes
23:44:49 <haskell_cabal> hmm
23:44:57 <haskell_cabal> I was following the yesod docs
23:45:04 <haskell_cabal> I was gonna try their other install instructions next
23:45:12 <haskell_cabal> but the entire point of doing the stuff i'm doing is to avoid dep hell
23:45:16 <solatis> i don't think that will fix this issue, to be honest
23:45:31 <solatis> if you want to avoid dep hell, look at nix
23:46:00 <solatis> it has almost all the packages available on hackage in its repository
23:46:08 <solatis> and it works well, very very well
23:46:37 <solatis> it's what i switched to after reaching my first cabal dependency hell moment
23:46:43 <haskell_cabal> hmm I heard haskell was working on fixing all this dep hell.. is this it?
23:47:35 <solatis> no that's the cabal maintainers saying "we're looking closely at how nix solves the problems, and trying to work them back into cabal"
23:48:03 <solatis> that's a valid and logical path for them to follow, and is probably what i would be doing
23:48:11 <solatis> in the meantime, look at nixos and the nix package manager
23:48:20 <solatis> you can use the nix package manager on top of any distro
23:48:33 <solatis> (for example, i use it on top of ubuntu)
23:49:03 <haskell_cabal> hmm I am using ubuntu too
23:49:06 <haskell_cabal> Will check it out
23:49:09 <solatis> but be prepared for a steep learning curve when looking at nixos, but imho it Does Things Right
23:49:19 <johnw> yeah, I use it on top of OS X
23:49:38 <haskell_cabal> That's kinda funny, considering cabal is already a bit steep... tried this a few months back and ran into hell
23:49:42 <haskell_cabal> trying again see if things have changed
23:50:05 <solatis> i personally don't count on anything changing any time soon
23:50:10 <haskell_cabal> and you were right, i am getting the same errors
23:51:01 <haskell_cabal> http://lpaste.net/113189
23:52:16 <damncabbage> I'm trying to find an alternate place to get one of these things: http://www.macdecals.com/macbook-haskell :)
23:52:29 <solatis> ah
23:52:37 <damncabbage> That site is sporting "out of disk space" (!) and "syntax error" dialogs.
23:52:38 <solatis> https://github.com/alanz/language-javascript/blob/master/language-javascript.cabal#L40
23:52:40 <solatis> look at that
23:52:42 <solatis> it does some Magic
23:53:10 <solatis> otoh, it will not solve your problem
23:53:59 <kadoban> haskell_cabal: Did you try just 'cabal install happy' first?
23:54:23 <haskell_cabal>  So what I am seeing, is i need ghc > 7.8
23:54:29 <haskell_cabal> So I see I have 7.6
23:54:33 <haskell_cabal> 7.6.3
23:54:45 <haskell_cabal> kadoban: I did
23:54:52 <haskell_cabal> But I might have an old version of ghc right?
23:55:34 <solatis> no
23:55:57 <solatis> what i'm seeing, is that if you have ghc > 7.8, you need happy > 1.9, otherwise happy > 1.8.5
23:55:59 <haskell_cabal> hmm
23:56:06 <haskell_cabal> i see
23:56:10 <haskell_cabal> yeah i just noticed the else
23:56:16 <haskell_cabal> how do i check which version of happy i have?
23:56:48 <solatis> i do not know to be honest, but google will probably be able to help you there
23:57:09 <kadoban> happy --version
23:57:30 <haskell_cabal> I seem to be on 1.19.4
23:57:31 <haskell_cabal> hmm
23:58:53 <haskell_cabal> I dont see anything higher than 1.19
23:58:58 <haskell_cabal> http://hackage.haskell.org/package/happy
23:59:17 <haskell_cabal> I think there is a typo in there somehwere?
23:59:47 <kadoban> Not sure what you mean?
