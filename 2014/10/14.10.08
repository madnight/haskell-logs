00:00:32 <prinsen> merijn: How do i construct a ptr?
00:00:46 * hackagebot portaudio 0.2.3.1 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.3.1 (AnilVaitla)
00:01:54 <dfeuer> prinsen, why are you dealing with all this nasty yuckiness?
00:02:08 <dfeuer> Sorry, I know that's not a good question.
00:02:13 <longqm> hello, does any library provide erlang-style bit field pattern match?
00:02:33 <prinsen> dfeuer: I havea big library and wanted to try out FFI :)
00:03:30 <prinsen> dfeuer: the resulting .hs file from the generated .hsc file is ~7k lines :p
00:03:53 <dfeuer> prinsen, I don't even know what an hsc file is yet :-P
00:03:59 <prinsen> merijn: cant figure out how to create a ptr :(
00:03:59 <dfeuer> But 7k lines is a LOT
00:04:32 <dfeuer> prinsen, have you checked the haddocks?
00:05:26 <prinsen> dfeuer: yes
00:05:46 * hackagebot portaudio 0.2.4 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.4 (AnilVaitla)
00:07:56 <dfeuer> Oh man, this is disgusting.
00:08:22 <merijn> COnstructing a Ptr requires a Storable instance
00:08:40 <johnw> does anyone know a good resource to read about signature logic?
00:09:42 <prinsen> merijn: I have that, but cant find a function a -> IO (Ptr a)
00:12:43 <prinsen> merijn: new from Foreign.Marshal.Utils
00:35:30 <taurus_> this channel have only quits and joins in conversation? :D
00:35:48 <Enigmagic> @hoogle a -> IO (Ptr a)
00:35:49 <lambdabot> Foreign.Marshal.Utils new :: Storable a => a -> IO (Ptr a)
00:35:49 <lambdabot> Foreign.Marshal.Alloc mallocBytes :: Int -> IO (Ptr a)
00:35:49 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
00:36:36 <Enigmagic> hoogle wins again ;-)
00:37:35 <blueonyx> @hayoo a
00:37:35 <lambdabot> Unknown command, try @list
00:39:57 <structuralist> can anyone recommend tutorials for doing complexity analysis on haskell programs?
00:40:31 <hexagoxel> how do i specify multiple -with-rtsopts options for ghc in cabal file?
00:41:03 <Thooms> structuralist: there's a chapter in RWO addressing this IIRC
00:41:44 <hexagoxel> if i used ghc directly, i could write -with-rtsopts="-H2G -M4G -N"
00:42:09 <hexagoxel> but i am unable to find a way to translate that to the .cabal file
00:42:31 <adamse> structuralist: I think Okasaki has written something on time complexity in lazy languages
00:42:59 <bartavelle> hexagoxel, does it work with a space ?
00:43:16 <bartavelle> "ghc-options:         -Wall -rtsopts -threaded -with-rtsopts "-A2M -M2M" -eventlog
00:43:41 <bartavelle> (I added -M2M, I don't know if it works, I ditched the = though)
00:43:46 <bartavelle> (which works)
00:44:12 <hexagoxel> bartavelle: ah, it does. thanks a lot!
00:44:16 <bartavelle> np
00:45:48 * hackagebot ghc-heap-view 0.5.3 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5.3 (JoachimBreitner)
00:49:44 <jle`> does [] form a module over Num a => a
00:50:34 <opqdonut> with suitable operations, yes
00:50:41 <opqdonut> there is no Num a => Num [a] instance though
00:50:55 <jle`> does there need to be for a module?
00:51:20 <opqdonut> are we talking about the same thing? a module over a ring?
00:51:23 <jle`> yea
00:51:38 <jle`> oh yeah, (+) is not (+) from Num
00:51:46 <jle`> maybe it is liftA2 (+) or zipWith (+)
00:51:51 <opqdonut> yeah
00:51:57 <jle`> i think...they both work
00:52:02 <opqdonut> zipWith truncates, does it work?
00:52:15 <jle`> yes but all the laws seem to still be satisfied
00:52:25 <opqdonut> hmm, right
00:52:27 <opqdonut> yes
00:52:51 <jle`> i don't know what a tensor product would look like though...to begin to see if it makes an algebra
00:53:24 <jle`> is it just liftA2 (*)?
00:54:56 <Axman6> listA2 (+) is (*) for molynomials represented as lists isn't it?
00:55:04 <Axman6> polynomials*
00:55:11 <jle`> molynomials
00:55:15 <jle`> is that what the kids are all on these days
00:56:12 <AshyIsMe> cool, ghc 7.8 is actually using 4 cores now when building a package with cabal
00:56:29 <AshyIsMe> (someone told me it did but it's nice to see it working locally:
00:56:35 <AshyIsMe> :)
00:56:39 <jle`> Axman6: i don't think that (a x^2 + b x + c) * (d x^2 + e x + f) = (a + d) x^2 + (b + e) x + (c + f), if that's what you mean
00:56:56 <jle`> oh
00:56:58 <jle`> liftA2
00:57:03 <jle`> not zipWith
00:57:04 <jle`> hm.
00:57:10 <Axman6> > liftA2 (+) [1,2,3] [4,5,6]
00:57:12 <lambdabot>  [5,6,7,6,7,8,7,8,9]
00:57:27 <jle`> oh my
00:57:29 <Axman6> hmm, no it's not
01:00:41 <jle`> is liftA2 (*) bilinear...
01:02:53 <rlp10> How do you delete an item from a list using a lens? "preview (ix 1) mylist" gives me the element at index 1. What do I replace "preview" with in order to delete it rather than showing it?
01:08:13 <jle`> @check \xs ys z -> liftA2 (*) xs (map (*z) ys) == map (*z) (liftA2 (*) xs ys)
01:08:16 <lambdabot>  +++ OK, passed 100 tests.
01:08:27 <jle`> i guess so!
01:09:03 <jle`> oh i ned to check addition too
01:20:02 <tero-> any idea why Network.Wreq spends 0.53s to load https://www.google.com while curl loads it in 0.046s?  the code is at http://lpaste.net/112299
01:22:44 <jle`> rlp10: i feel like the lens laws prohibit any Lens from doing that, so you might want to redirect your attention to prisms and traversals and stuff like that
01:26:45 <zerosign> hi
01:27:00 <zerosign> it seems like http://hackage.haskell.org/package/cookie
01:27:09 <zerosign> are kind of lost ?
01:27:18 <zerosign> did it hackage faults ?
01:27:22 <zerosign> *was it
01:30:08 <Haskellfant> zerosign: are you talking about the missing docs?
01:31:18 <zerosign> nope the package are missings
01:31:44 <Haskellfant> zerosign: the download seems to be working for me
01:31:53 <zerosign> hmm
01:32:31 <rlp10> jle`: Thanks for that. You're right, a lens can only focus on one thing and I want a list of things, so it must be a traversal or something else. I'll keep looking.
01:32:31 <zerosign> Haskellfant : my cabal fails in downloading http://hackage.haskell.org/packages/archive/cookie/0.4.1.4/cookie-0.4.1.4.tar.gz :"
01:33:01 <jle`> rlp10: i think lens also has to preserve structure, so deletion is a no-go
01:33:07 <Haskellfant> zerosign: hm I'm using stackage, might be related to this
01:33:17 <Haskellfant> the download link works just fine in firefox
01:33:18 <jle`> maybe prisms?
01:34:18 <zerosign> Haskellfant : hmm something looks fishy here
01:34:37 <zerosign> Haskellfant: I'll try stackage
01:34:51 <Haskellfant> zerosign: I guess you have tried a simple cabal update?
01:35:12 <zerosign> Haskellfant : yes, I do, about several minutes ago
01:35:51 * hackagebot yesod-auth-kerberos 1.4.1 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.4.1 (ArashRouhani)
01:37:52 <zerosign> Haskellfant : somehow, I could download it only using https protocol but not http
01:38:14 <zerosign> Haskellfant : just found out right now :late:
01:39:53 <rlp10> jle`: i'll keep looking at the docs and see if I can figure it out. thanks for your comments.
01:40:02 <jle`> np
01:40:07 <jle`> rlp10: there's also #haskell-lens
01:40:21 <jle`> if you want more places to ask :)
01:44:50 <latermuse> lambdabot: True
01:47:52 <sivteck> > True
01:47:54 <lambdabot>  True
01:49:58 <rlp10> jle`: ah, good idea. i'll do that
01:50:52 * hackagebot prefork 0.0.9 - A library for building a prefork-style server quickly  http://hackage.haskell.org/package/prefork-0.0.9 (ikehara)
01:54:15 <latermuse> > False
01:54:17 <lambdabot>  False
01:54:28 <latermuse> > let (====)=(==);o=8in  8====o -- ~~~
01:54:30 <lambdabot>  True
01:56:15 <blueonyx> i'm not even mad
01:56:37 <blueonyx> amazing
02:00:25 <t7> latermuse: creative
02:01:28 --- mode: ChanServ set +o Saizan
02:01:39 --- mode: Saizan set +b *!*ron@112.209.22.*
02:01:40 --- kick: latermuse was kicked by Saizan (latermuse)
02:01:53 --- mode: Saizan set -o Saizan
02:02:48 <dv-> ?
02:04:13 <Saizan> just that silly ascii art is not appropriate here
02:04:35 <dv-> could've just said that
02:04:49 <Qfwfq> That was cute tho
02:04:55 <Saizan> or i can temporarily ban
02:06:31 <jTT> Anyone know about the issue with conduit not exporting runResourceT anymore?
02:06:51 <erikd> jTT: its moved to the resourcet package
02:07:07 <jTT> ah ok, cheers
02:07:27 <dfeuer> Saizan, I think that did seem a bit harsh...
02:08:04 <zwer_r> agreed
02:08:36 <pjdelport> Saizan: They should have one warning, at least, given that the rest of their conduct was fine.
02:09:22 <Saizan> come to #haskell-ops if you want to discuss this
02:13:50 <lericson> so... robotic
02:14:43 <lericson> it was just a let expression :-)
02:16:01 <Saizan> it wasn't a huge deal, but i'd rather make a point
02:17:02 <Saizan> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib -- this is a nice one
02:17:04 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:20:34 <jle`> edwardk: did you ever consider having (=>=) be a part of the Comonad typeclass?  so we can provide efficient implementations?
02:23:39 <lericson> Saizan: very nice, i had an assignment to make a fibonacci sequence in haskell and never came up with that. was blown away once i saw it, very elegant
02:26:34 <Saizan> lericson: i saw it first when i was still learning lazyness and it was quite hard to grasp
02:26:48 <Saizan> > fix ((0:) . scanl (+) 1) -- this is cool too
02:26:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:28:49 <J_Arcane> Heh. I was so impressed with the quicksort in LYAH I tried rewriting it in Racket, but while I could reproduce the logic easy, it was the type system I couldn't.
02:30:27 <Saizan> J_Arcane: what in particular?
02:30:48 <pjdelport> Obligatory nitpicking: That algorithm is not quicksort, but a deforested tree sort.
02:31:49 <J_Arcane> Saizan: You can write the same algo almost line for line, but ironically, Haskell's generic types make it more flexible: you can pass any value type list to it and it works; Racket's needs to be a higher-order function that takes a comparator for the same type as the list.
02:32:28 <Saizan> J_Arcane: ah, so it's the typeclass part
02:32:32 <J_Arcane> Yup.
02:32:53 <pjdelport> http://www.reddit.com/r/programming/comments/2h0j2/real_quicksort_in_haskell/
02:33:06 <J_Arcane> Because Racket has separate comparison functions for strings, numbers, etc.
02:33:21 --- mode: ChanServ set +o Saizan
02:33:39 --- mode: Saizan set -b *!*ron@112.209.22.*
02:33:43 --- mode: Saizan set -o Saizan
02:34:57 <hyPiRion> J_Arcane: Doesn't Racket have multimethods? I haven't used it extensively, but I would be surprised if they don't have something similar
02:40:28 <J_Arcane> hyPiRion: I think you could write a function that does the same thing, but it would be much longer, because even in Typed Racket the functions to compare strings are different from numbers.
02:40:48 <J_Arcane> It's the Ord typeclass that makes the Haskell version so succint, I think.
02:44:47 <dfeuer> The Ord typeclass is a very nice thing in general.
02:47:13 <J_Arcane> Yeah.
02:49:35 <Qfwfq> GHC have three-byte integers hiding somewhere?
02:49:48 <hyPiRion> J_Arcane: Right, I mean something similar to defmethods in Clojure/CL. In Clojure at least, the quicksort implementation can be done in same fashion as the Haskell variant
02:58:14 <J_Arcane> It's possible; there's a thread here about it: http://comments.gmane.org/gmane.comp.lang.racket.user/10957
02:59:36 <hyPiRion> ah
03:01:18 <J_Arcane> There's almost nothing you can't do in Racket; but sometimes that means you have to write it yourself. ;)
03:10:56 * hackagebot websockets 0.9.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.1.0 (JasperVanDerJeugt)
03:17:31 <nkar> cabal build complains about missing modules.  is there way to insert them automatically to the 'build depends' field?
03:23:52 <Fuuzetsu> do you mean missing packages?
03:24:08 <Fuuzetsu> AFAIK there are tools that can insert stuff for you but I don't remember specifics
03:25:31 <nkar> Fuuzetsu: couldn't find module 'foo' it is a member of the hidden package 'bar'.
03:27:51 <Haskellfant> nkar: something™ asks me in emacs if I want to insert them
03:27:58 <Haskellfant> probably haskell-mode
03:28:28 <osa1> does anyone here use llvm-general?
03:28:31 <pantsman> grr I get so frustrated when emacs says something and I spend the rest of the day wondering which script said it so I can debug the darn thing
03:28:59 <nkar> Haskellfant: oh, thanks.  I should install the development version.
03:29:03 <osa1> I'm wondering if moduleLLVMAssembly is doing some optimizations by default
03:29:20 <Haskellfant> pantsman: heh, I know that feeling
03:30:28 <pantsman> "hey user, I just invoked an executable, tried to parse the output, and barfed it into a buffer. I won't tell you which executable or which arguments I supplied, have fun!"
03:37:28 <jTT> Hey, can someone help me with this error message:     Couldn't match expected type ‘Text’ with actual type ‘Data.Text.Internal.Lazy.Text’; NB: ‘Text’ is defined in ‘Data.Text.Internal’;‘Data.Text.Internal.Lazy.Text’; is defined in ‘Data.Text.Internal.Lazy’
03:38:59 <nkar> jTT: it seems you need to convert your value using 'toStrict'.
03:40:01 <jTT> nkar: thanks will try
04:58:03 <greeny> > try (print $ 5 `div` 0)
04:58:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable e0)
04:58:05 <lambdabot>    arising from a use of ‘M178712884056893972515523.show_M1787128840568939725...
04:58:05 <lambdabot>  The type variable ‘e0’ is ambiguous
04:58:05 <lambdabot>  Note: there are several potential instances:
04:58:05 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:58:32 <greeny> how can i fix that issue?
04:59:04 <greeny> must i always declare the exception type?
05:01:38 <Cale> greeny: You can use the exception in some way which makes which type it is clearer
05:02:02 <Cale> greeny: But which type it is matters, because it determines which exceptions will be caught
05:02:03 <greeny> > try (print $ 5 `div` 0)::IO (Either SomeException ())
05:02:05 <lambdabot>  <IO (Either SomeException ())>
05:12:56 <Logiar> Complete beginner here, could anyone help me with how I can get http://pastebin.com/Wd7fzfev into a form that doesn't give a parse error on c1?
05:13:57 <Fuuzetsu> you need to align your c1 under b1
05:14:41 <Fuuzetsu> http://lpaste.net/112308 something like this I guess
05:14:53 <Fuuzetsu> you also had a missing ‘=’ after otherwise
05:15:10 <Logiar> my bad
05:15:23 <Logiar> identation is that detailed in haskell? :o
05:15:34 <Fuuzetsu> alignment, not indentaation
05:15:37 <Fuuzetsu> indentation*
05:17:20 <Logiar> Uhm. now the = in c = eval2 c gives a parse error
05:17:43 <Logiar> I mean c1 = eval2 c
05:18:12 <Fuuzetsu> huh
05:18:21 <Fuuzetsu> I don't see why it would, did you copy it down carefully?
05:18:42 <Fuuzetsu> oh
05:18:55 <Fuuzetsu> != is not inequality check
05:18:56 <Fuuzetsu> /= is
05:19:06 <Fuuzetsu> I don't think that'd be a problem though…
05:19:19 <Fuuzetsu> maybe it's getting confused with bang patterns or something
05:19:55 <Fuuzetsu> no, it should just complain about != not being in scope
05:22:54 <Logiar> I fixed it by.. doing nothing..
05:22:56 <Logiar> D:
05:23:09 <Logiar> I hate it when that happens.
05:23:22 <Fuuzetsu> maybe you didn't save the file or something
05:23:50 <Logiar> I did
05:24:40 <cmtptr> maybe you didn't save hard enough
05:29:03 <Logiar> And now the exact same problem on the next guard
05:29:16 <Fuuzetsu> post your full code and full error message
05:30:54 <Logiar> Well.. that explains it I think.
05:31:20 <Logiar> When copied from notepad++ to pastebin the pastebin version gives a significantly different alignment
05:31:35 <Fuuzetsu> use lpaste.net
05:32:27 <gcganley> Logiar: lpaste
05:32:50 <Logiar> Yeah same thing there. I fixed it in the paste and copied back to notepad++ and now it works
05:33:01 <Logiar> but it looks messed up in notepad++
05:33:26 <hexagoxel> using tabs?
05:33:34 <Fuuzetsu> he's not AFAICT
05:34:10 <gcganley> pastebin uses typewriter font no?
05:34:28 <Fuuzetsu> His problem is most likely his editor.
05:34:46 <Fuuzetsu> Or font. Or something.
05:34:54 <gcganley> i've never had a problem with n++ misusing tabs and spaces :/
05:35:03 <gcganley> maybe its a crlf thing
05:35:19 <gcganley> Logiar: what OS is this on?
05:35:22 <Fuuzetsu> I doubt it's line-endings.
05:35:31 <Fuuzetsu> gcganley: Isn't Notepad++ Windows-only?
05:35:42 <gcganley> Fuuzetsu: no
05:36:22 <Fuuzetsu> gcganley: Their site and Wikipedia seem to disagree
05:36:43 <Logiar> Windows
05:36:53 <Logiar> and I've been using tabs, yes.
05:37:10 <Fuuzetsu> Don't use tabs.
05:37:26 <int-e> (tabs are for web browsers)
05:37:37 <Logiar> Sorry for the slow replies. been working at this for a while now without much progress and finally figuring out how to do it
05:37:48 <Fuuzetsu> int-e: now I'm not sure which tabs he's talking about ;;
05:37:58 <cmtptr> you can use tabs just as long as you don't begin the identifier on the same line with let
05:38:09 <Fuuzetsu> cmtptr: Don't encourage tabs
05:38:16 <cmtptr> why not?  they're better
05:38:19 <MagneticDuck> tabs suck!
05:38:27 <MagneticDuck> they're like whitespace, but somehow... larger?
05:38:32 <Fuuzetsu> cmtptr: They are probably the #1 offender of people comming in here with ‘why doesn't this work’.
05:38:35 <MagneticDuck> that doesn't work! monospace is the best! I hate tabs!
05:38:38 <MagneticDuck> raaaarrr
05:38:48 <MagneticDuck> also, haskell hates tabs
05:38:49 <cmtptr> Fuuzetsu, then I would prefer to encourage people to understand it
05:39:07 <Fuuzetsu> cmtptr: I would encourage people to not recommend tabs because they like them more
05:39:11 <Fuuzetsu> http://urchin.earth.li/~ian/style/haskell.html is the standard guide
05:39:40 <cmtptr> I don't see how that's relevant to me
05:39:48 <Fuuzetsu> Haskell is alignment sensitive, trying to restrict everything to your-tab-width (which is always taken as 8 by GHC) is silly at best
05:40:20 <cmtptr> that's why, as I said, if you're going to use tabs don't use them to align things with columns
05:40:31 <cmtptr> begin your identifiers on a new line
05:40:41 <Fuuzetsu> What you should have said is ‘don't use tabs’.
05:40:54 <cmtptr> but I didn't, and I'm happy with my response
05:41:21 <Fuuzetsu> But it's a bad response that will only cause more confusion.
05:41:52 <Fuuzetsu> Somewhat related: GHC was recently completely detabbed and will no longer accept code with tabs.
05:41:58 <Fuuzetsu> (in its codebase)
05:42:00 <edwardk> i tend to advocate against storing physical tabs in projects, because they are embarassingly one of the single largest painpoint for multiuser projects in haskell, ghc is riddled with them and we're still trying to stamp them out. =P
05:42:11 <cmtptr> well, good thing I'm not contributing to ghc
05:42:11 <Fuuzetsu> edwardk: All gone now ;)
05:42:19 <edwardk> Fuuzetsu: _finally_! =)
05:42:23 <Fuuzetsu> cmtptr: You sure as hell are confusing to newbie confusion.
05:42:28 <Fuuzetsu> are contributing to*
05:42:49 <cmtptr> are you saying this as a newbie who is confused?
05:43:11 <Fuuzetsu> No, I'm saying this as someone who sees newbies in here daily with problems because they used tabs.
05:43:13 <edwardk> cmtptr: i'm saying this as someone who has watched a stream of newbies come in here for 6 years confused by this very issue
05:44:02 <cmtptr> then maybe if you guys actually explained the indentation rules rather than just saying "use spaces. move along", there'd be less confusion
05:44:21 <Fuuzetsu> cmtptr: There are no indentation rules, there are alignment rules.
05:44:33 <Fuuzetsu> So tabs which are used for indentation don't come into play here.
05:44:38 <vanila> make the tab key insert spaces
05:44:49 <Fuuzetsu> vanila: but hard tabs are so much better apparently
05:46:30 <edwardk> the issue is that too many people who casually use haskell have had their editor set up to hard tab at 4 characters or whatever, because it didn't matter in the languages they used before, so things get all misaligned despite being visually aligned. the major culprit is things like xs = do bar\n\tbaz -- where the visual alignment with the line above breaks.
05:48:19 <edwardk> so we tend to recommend folks just don't do and it greatly reduces the screaming of the damned ;)
05:49:20 <vanila> I dont understand why any one would want to use tab, it's weird - it's not the same length as other characters
05:49:29 <hexagoxel> (notepad++ has option to insert spaces with tab key)
05:49:37 <vanila> also terrible: caps lock
05:49:50 <Fuuzetsu> hexagoxel: as just about any other editor
05:50:59 <hexagoxel> Fuuzetsu: yeah i know. was meant for Logiar, if still reading
05:51:48 <cmtptr>  edwardk> so we tend to recommend folks just don't do and it greatly reduces the screaming of the damned  -- there's already no avoiding that when the language treats whitespace significantly.  I don't understand why there's such an opposition to just explain the rule, and let the user decide how he wants to handle it
05:52:24 <Fuuzetsu> there is only one rule to do with tabs, that is it expands to 8 spaces
05:52:38 <edwardk> cmtptr: i believe in explaining the rule and then explaining the fact that the norms of the community have pushed against using it in practice ;)
05:52:41 <int-e> cmtptr: because explaining the rule visually is not enough if the editor and the compiler interpret tabs differently.
05:53:20 <cmtptr> edwardk, fair enough, but that's not what I saw happen.
05:53:42 <vanila> cmtptr, because tabs is a needless complication
05:53:56 <cmtptr> int-e, doesn't it not matter if you begin identifiers on their own line and are consistent with it?
05:54:13 <vanila> it could be removed from the language spec, compiler could just error "tab character found here"
05:54:16 <int-e> cmtptr: we *still* explain the rule. but often there are people who have more or less grasped the rule and don't understand the compiler rejecting their program because it looks correct in their editor. besides, there is almost a consensus that tabs should not be used in haskell code, with a minority advocating programming styles where tab width doesn't matter.
05:55:07 <vanila> it's also a problem that you cannot see by looking whether some whitespace is a tab, spaces or a mi
05:55:07 <vanila> x
05:55:11 <int-e> which sometimes lead to the requirement of repeating prefixes like <tab><space><space><tab> for several lines
05:55:14 <vanila> you have to enable a special mode in emacs for it
05:55:50 <int-e> not using tabs at all is easier.
05:56:04 <vanila> TAB only exists in ascii for the same reason as things like ACK, BEL and DLE (data link escape)
05:56:18 <Fuuzetsu> how many BELs to make a tab?
05:56:23 <cmtptr> int-e, I admit I'm relatively new to the language but I've never seen or can even imagine a scenario when it would be necessary or even a good idea to mix tabs and spaces
05:56:49 <Fuuzetsu> cmtptr: Correct, because if you're using tabs, it's already a lost cause
05:57:25 <Fuuzetsu> It is *possible* to use hard tabs, no one is denying it, but you need to be very, very strict in how you use them.
05:57:58 <cmtptr> the language is already very strict in how you align things.  what's the difference?
05:57:58 <Twey> GHC 7.12 should make hard tabs a syntax error…
05:58:12 <bennofs> Twey: -fwarn-tabs -Werror exists already
05:58:26 <Fuuzetsu> cmtptr: The difference is that you can only ‘align’ things in multiples of 8 with hard tabs.
05:58:31 <Twey> Is -fwarn-tabs part of -Wall?
05:58:37 <bennofs> -fwarn-tabs should probably be default
05:58:42 <doismellburning> +1
05:58:58 <cmtptr> Fuuzetsu, that's why you begin things that need to be aligned on a new line.  how are you not getting this?
05:59:28 <Fuuzetsu> cmtptr: Because that's a stupid thing to do, you need to change the structure of half of your program to accomodaate for some weird-ass requirement of tabs-only.
06:00:02 <cmtptr> I don't need to change the structure of /my/ program, because I write in the first place that way.  I'm not advocating that you go change all of yours
06:00:03 <Fuuzetsu> No one is ever going to want with the code you write in this style but yourself
06:00:13 <doismellburning> ideally I would change "Haskell's" behaviour here
06:00:17 <doismellburning> but, meh
06:00:20 <Fuuzetsu> cmtptr: But you just advised a newbie to use tabs
06:00:25 <bennofs> Fuuzetsu: actually, it's not that bad to write haskell without requiring things to be aligned
06:00:26 <cmtptr> no, I didn't
06:00:48 <Fuuzetsu> bennofs: Sure, but that's not the point here
06:00:48 <cmtptr> I told him if he wanted to use tabs, he needs to take an extra step to make it work
06:00:50 <Logiar> hexagoxel: Thanks for the tip
06:01:05 <bennofs> Fuuzetsu: well, if you don't require things to be aligned, you can just as well use tabs
06:01:24 <Fuuzetsu> <cmtptr> you can use tabs just as long as you don't begin the identifier on the same line with let
06:01:28 <Fuuzetsu> that' is hardly the single step required
06:02:12 <edwardk> cmtptr: i don't advocate for the 'start all things that can need alignment on a new line' for pragmatic reasons. a bunch of old psychometric studies showed that error rates increased exponentially as the code under consideration exceeded the height of your screen, so i tend to treat vertical space as rather precious, and this style is rather profligate with its use.
06:03:00 <edwardk> cmtptr: if i was in a culture that used variable width fonts, etc. then what you want would be pretty much necessary
06:03:43 <Logiar> Now.. another question. I have a function with the signature: eval::AST -> Context -> Memory -> (AST,Context,Memory)
06:04:36 <Fuuzetsu> :t uncurry3
06:04:37 <lambdabot>     Not in scope: ‘uncurry3’
06:04:37 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
06:04:39 <Fuuzetsu> hm
06:04:47 <Fuuzetsu> thought that was somewhere
06:04:52 <int-e> :t (,,)
06:04:53 <lambdabot> a -> b -> c -> (a, b, c)
06:05:09 <tdammers> who uses variable-width fonts for code??? that'd be insane!
06:05:15 <Fuuzetsu> well, curry3 is probably what I wanted
06:05:19 <int-e> but presumably there's some actual computation inside 'eval'
06:05:20 <vanila> tdammers, It would be nice if you had a syntax-based editor
06:05:21 <Logiar> now I'm not doing anything with the context or memory yet so I do something like  eval x context memory = let (do something with x) in (newx,context,memory)
06:05:22 <hyPiRion> tdammers: why?
06:05:50 <tdammers> oh no
06:06:01 <tdammers> looks like I fueled the structural editor debate again
06:06:04 <Logiar> and I it complains that it couldn't match the expected type with the type it gets
06:06:28 <vanila> Logiar, take off the type signature
06:06:32 <tdammers> but actually, hmm, come to think of it, there is no good reason to use fixed-width fonts...
06:06:34 <vanila> see what the compiler infers for you
06:06:37 <Fuuzetsu> Logiar: clearly your ‘do something with x’ is not type of AST
06:06:40 <vanila> you can check :t eval
06:06:51 <tdammers> except for things like layout syntax, maybe, but even then...
06:06:53 <hexagoxel> Logiar: add type signature newx::AST in the let
06:06:59 <vanila> Logiar, I also noticed that you might use a monad eval :: State (AST, Context, Memory) ()
06:07:05 <vanila> but maybe this can come later on
06:07:21 <Fuuzetsu> probably best to not suggest using a monad for this yet ;)
06:07:51 <Logiar> Fuuzetsu: it is though
06:08:04 <Logiar> AST is the only thing that is as expected
06:08:09 <int-e> tdammers: it's nice for writing down tables. (For example, if one defines  f x y  by exhaustive case analysis of x and y, one can align the arguments)
06:08:13 <Fuuzetsu> Logiar: well, clearly it isn't considering GHC is saying otherwise
06:08:28 <Logiar> It's complaining about context and memory part
06:08:41 <Fuuzetsu> Why not post the error message? We can't read minds yet.
06:08:55 <Fuuzetsu> also the relevant code
06:09:09 <int-e> tdammers: and that improves readability a lot. you could advocate tab stops for that purpose, of course... but that brings us to the beginning of the discussion.
06:10:00 <Logiar> Right so
06:10:43 <Logiar> Oooh
06:10:49 <Logiar> nevermind
06:11:03 * hackagebot libhbb 0.3.0.0 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.3.0.0 (wolfch)
06:11:05 * hackagebot hbb 0.3.0.0 - Haskell Busy Bee, a backend for text editors.  http://hackage.haskell.org/package/hbb-0.3.0.0 (wolfch)
06:11:08 <Fuuzetsu> Next time read the error carefully, the errors are your friends.
06:16:03 * hackagebot hbb 0.3.0.1 - Haskell Busy Bee, a backend for text editors.  http://hackage.haskell.org/package/hbb-0.3.0.1 (wolfch)
06:24:15 <Fuuzetsu> edwardk: is there a library somewhere about presheaves?
06:26:07 <bmm> I would like to run values of a Map through an IO function. But there is no Data.Map.mapM. Anybody has a hint for me?
06:26:42 <bartavelle> bmm, see Traversable
06:27:21 <bmm> bartavelle: on it...
06:27:37 <bartavelle> especially the "traverse" function, which should be exactly what you are looking for
06:28:31 <bartavelle> (or the mapM function from Traversable !)
06:30:25 <bmm> bartavelle: Thanks! Works like a charm!
06:30:36 <bartavelle> glad to hear
06:31:14 <bartavelle> bmm, there is also "itraverse" if you also need the key, but I think you'll need the lens package for it
06:35:32 <kgadek> hi. is there the equivalent of zipWithM for Data.Map?
06:35:54 <kgadek> the perfect one would be similar sth. like unionWithKeyM
06:37:55 <Logiar> my git message "eval works a little bit" :P
06:38:04 <Logiar> At least I'm on the right track I think
06:39:14 <kgadek> @self: ok, found one: https://github.com/hguenther/gtl/blob/master/lib/Data/MapMonad.hs
06:39:15 <lambdabot> Unknown command, try @list
07:01:05 * hackagebot ssh 0.2.13 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.13 (SimonMichael)
07:03:38 <kstt> Hi. How would to write a print function for floats that use a coma as a decimal separator ?
07:04:00 <kstt> printf ?
07:04:43 <Fernandos> hi
07:04:55 <kgadek> kstt: printf doesn't seem to provide that
07:05:03 <kgadek> kstt: http://stackoverflow.com/questions/3752898/haskell-format-number-with-commas
07:06:05 * hackagebot ssh 0.2.13.1 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.13.1 (SimonMichael)
07:06:08 <Fuuzetsu> post-processing show output seems sub-par…
07:06:18 <kstt> thank you kgadek
07:06:38 <Fernandos> I'm studying CS (MSc) and have the urge to understand category theory, since it's not thought at our university. Is that normal for computer science, so that only Mathematics students get thought in that discipline?
07:06:40 <kstt> ideally I would have like a fast method. This is for large collection of floats.
07:06:59 <ekuam> Fernandos: yes
07:07:11 <ekuam> CT is an "exotic" subject
07:07:50 <Fernandos> ekuam: hmm, why exotic? I thought it's a generalization of many fields of maths, isn't it?
07:08:14 <kgadek> Fernandos: take a look at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf
07:08:41 <ekuam> many generalizations are weird
07:09:06 <kgadek> and if you seem to like it, buy it (of course)
07:09:13 <kgadek> never studied that though
07:09:24 <kgadek> but that seems like would be a good fit for you
07:10:04 <blueonyx> @where cat
07:10:05 <lambdabot> I know nothing about cat.
07:10:26 <kgadek> @where stolen food
07:10:26 <lambdabot> I know nothing about stolen.
07:10:31 <kgadek> damn ;)
07:10:39 <kgadek> @where stolen_food
07:10:39 <lambdabot> I know nothing about stolen_food.
07:10:44 <Fuuzetsu> Fernandos: I'm reading Category Theory for Computing Science
07:11:03 <Fuuzetsu> Slowly.
07:11:52 <Fernandos> ekuam: We have had Math1-4 in the BSc, but there is only specific Maths in the MSc program. I acknowledge that CT is more or less essential for understanding Haskell in a way that makes the language practical and useful. How much time do you think is required to grasp it? (I have the natural urge to know everything, but I actually just want to know what's practically useful.)
07:12:06 <ekuam> CT is not essential at all
07:12:10 <ekuam> I don't know any CT
07:12:15 <Fernandos> What is essential then?
07:12:23 <Fuuzetsu> hence you don't know any Haskell ∎
07:12:24 <vanila> I do not apply any category theory knowledge to programming haskell
07:12:29 <vanila> ive never seen this being useful
07:12:40 <ekuam> Fernandos: dunno. general programming stuff?
07:12:46 <ekuam> but that comes with learning haskell
07:12:47 <Fuuzetsu> type theory helps
07:12:49 <ekuam> it's not a prerequisite
07:12:50 <kgadek> Fernandos: just start using haskell
07:13:01 <kgadek> CT will come in different places but you can freely skip it
07:13:08 <Twey> You can form analogies between Haskell and category theory, and sometimes we get cool stuff out of them.  But it's far from essential to know category theory in order to use Haskell.
07:13:09 <Fernandos> ekuam: I've had that already. Type Theory was my next stop, but I thought CT is more important, shuld I learn TT first?
07:13:34 <kgadek> Fernandos: and after getting some intuition you could get into CT, but already knowing what to look for
07:13:34 <Fuuzetsu> TT is also not *essential*
07:13:58 <Twey> Well, type theory is pretty essential, but you'll learn most of the basics just by using Haskell.
07:14:22 <Fuuzetsu> just like, line up types
07:14:25 <Twey> (and if you know e.g. Java you've probably good a good foothold already)
07:14:30 <Twey> got**
07:14:45 <kgadek> I think that to start quickly with Haskell, you need no TT or CT
07:14:56 <kgadek> but then again, those will reappear
07:14:57 <joe9> Is there a haskell library to analyse data sets. I parsed some data into haskell records and am writing functions to analyse the data. Just wanted to check if there is any haskell analysis library.
07:14:57 <silver> agreed
07:15:01 <etandel> Fernandos: you don't need CT to use haskell, but It will definitely help in understanding the nuances of it.
07:15:05 <kgadek> you don't need to understand it though
07:15:07 <kgadek> for example
07:15:11 <kgadek> if you know how monads work
07:15:18 <kgadek> that's all you need to write Haskell
07:15:33 <etandel> joe9: I've never used it, but there's an interesting newproject called hakaru
07:15:36 <Fernandos> I want to learn CT and TT, though what's the recommended order?
07:15:46 <joe9> etandel: ok, thanks.
07:15:55 <kgadek> Fernandos: I believe they are orthogonal to each other
07:15:57 <Fernandos> kgadek: Monads are part of CT :/
07:15:58 <Twey> Fernandos: There's a book called ‘Categories for Types’ that might teach you a bit of both :þ
07:16:00 <etandel> joe9: though it seems to be quite new and docs are sparse. http://www.indiana.edu/~ppaml/
07:16:07 <silver> theory may help to produce some new cool ways of doing something general, but logic of practical program is not general at all
07:16:10 <Twey> But yes, pretty orthogonal.
07:16:22 <Fuuzetsu> kgadek: stop, you don't need to know how monads work to before writing Haskell
07:16:29 <Fernandos> I know how they work since I wrote a paper about it, but that's one out of many topics and it was pretty general
07:16:36 <kgadek> Fuuzetsu: that's what I actually mean
07:16:50 <kgadek> that you just use some things
07:16:59 <Fuuzetsu> Fernandos: just start writing Haskell and if you want a deeper insight, learn alongside (CT or TT or whatever you want)
07:17:03 <kgadek> and then suddenly someone tells you "oh, you just used a monad"
07:17:08 <kgadek> which can be read as
07:17:16 <kgadek> "oh, you just used a 'computation'"
07:17:32 <kgadek> which does not seem that difficult, does it?
07:17:45 <kgadek> Fuuzetsu: exactly
07:17:59 <etandel> people are afraid of monads, but no one seems to be afraid of jquery
07:18:02 <etandel> or linq
07:18:14 <kgadek> or lists :)
07:18:31 <silver> somewhat related http://www.willamette.edu/~fruehr/haskell/evolution.html
07:18:40 <Fuuzetsu> etandel: https://twitter.com/kmett/status/93883284362248192
07:19:04 <Fernandos> nah I'm not afraid of such things..
07:19:52 <kgadek> good. start writing http://codewars.com or http://projecteuler.net with haskell
07:20:04 <kgadek> and only learn what you need to solve particular problems
07:20:14 <Fuuzetsu> PE is terrible for learning a language
07:20:34 <MagneticDuck1> PE is for learning math and algorithms and number theory, not learning a language
07:20:38 <Fuuzetsu> anyway Fernandos, you seem more than well equipped to just start writing
07:20:43 <MagneticDuck1> you don't learn a language by writing small programs
07:20:55 <MagneticDuck1> you learn a language by understanding how larger programs can be efficently structured
07:20:57 <etandel> Fuuzetsu: I actually don't know jquery (or a lot about JS for that matter). But so many people say it's a monad... thanks for the reading.
07:20:59 <MagneticDuck1> imo
07:21:01 <kgadek> well… maybe, but I found that pretty useful because that allowed me to see actual problems solved with Haskell. For me that was fun
07:21:20 <ekuam> you also learn a lot by writing 1000 small programs
07:21:26 <Fuuzetsu> kgadek: blindly repeating what people say is usually not a good idea ;)
07:21:50 <kgadek> that was my opinion
07:22:07 <Fuuzetsu> sorry, wrong highlight
07:22:08 <etandel> Fuuzetsu: maybe you meant me?
07:22:10 <Fuuzetsu> meant for etandel
07:22:11 <Fuuzetsu> es
07:22:12 <Fuuzetsu> yes
07:22:15 <etandel> ha
07:22:24 <kgadek> ;)
07:22:31 * Fuuzetsu is reading abstract nonsense right now so his mind is elsewhere
07:23:23 <etandel> Anyway, PE is very fun indeed but I agree that it may not be the best way to learn a language, because you spend more time worrying about the maths of it then tha language itself.
07:23:38 <etandel> but i guess it's pretty subjective
07:24:50 <kgadek> in that case I would suggest http://exercism.io instead of PE
07:25:09 <Fuuzetsu> I'm sure he has projects he wants to write already.
07:25:52 <kgadek> probably, but I believe it's better to start small
07:25:56 <kgadek> especially with Haskell
07:26:06 <kgadek> which requires some mind-shift
07:27:08 <etandel> "some" is an understatement. ;-)
07:29:06 <kgadek> I said PE because when I got to… dunno, 10th problem I was a bit stuck. I needed mutable arrays and though "can't do, this is Haskell". So wrong I was… Anyway, that was a good lesson :)
07:29:40 <Fuuzetsu> maybe your method just wasn't good enough
07:29:45 <Fuuzetsu> no mutable arrays on paper ;P
07:34:16 <Fernandos> I'm afraid of nonlinear mathematics only :P
07:34:32 <Fernandos> It's freaking difficult to even get an idea of what it is about..
07:36:36 <sm> good morning all
07:37:07 <sm> after cabal sandbox add-source, I get "Some add-source dependencies have been modified. They will be reinstalled" on every build. How can I prevent this ?
07:43:37 <Fernandos> Hmm, this is somewhat stupid, but is graph algebra generalized within CT?
07:44:09 <Fuuzetsu> there's category of graphs and graph homomorphisms but I don't know if that's what you're after
07:44:20 <Fuuzetsu> anyway, the answer to that question is almost certainly ‘yes’
07:44:30 <Fernandos> oh awesome!
07:45:22 <Fernandos> There was a course that required anti-unifaction of Graphs into Trees..
07:45:45 <Fernandos> That could be expressed with CT too?
07:46:09 <hexagoxel> sm: afaik this does not happen normally, maybe you have files with timestamps from the future?
07:46:18 <Fuuzetsu> probably
07:46:38 <Fuuzetsu> I know less about graph theory than about CT and I don't know a whole lot of CT yet ;)
07:46:46 <sm> hexagoxel: that would be weird, good to know it's not usual
07:47:19 <Fernandos> Fuuzetsu: oh looks like it can http://erikjacobsen.com/pdf/unification.pdf
07:47:31 <Fuuzetsu> I am not surprised in the slightest
07:49:55 <Fernandos> Maybe this is out of scope, but does memristance play any role in CT? (Keeping memory of paths/transformation taken)
07:52:20 <Fuuzetsu> I don't know
07:52:55 <Fuuzetsu> if there's some part of maths that deals with this then there are good chances are there is a CT generalisation
07:53:00 <adas> > :i ($)
07:53:02 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:53:26 <Fuuzetsu> adas: lambdabot does not do ‘:i’
07:53:40 <Fuuzetsu> and if it did, it would certainly not be after ‘> ’
07:54:12 <Fernandos> Fuuzetsu: it seems there is some work in that direction, but I don't know from just taking a glance http://www.thinkartlab.com/pkl/lola/Diamond-Category-Theory.pdf
07:54:33 <adas> oh .. if i have something like "infixr 0 $" .. does it mean it has the highest or the lowest precedence?
07:55:01 <Fernandos> seems they try to formalize systems theory to category theory
07:55:35 <Fuuzetsu> jesus was this typeset in Word or something
07:56:00 <Fernandos> Fuuzetsu: I found it here: http://www.thinkartlab.com/pkl/lola/Memristics/Memristics:Memristors,%20again.html
07:56:30 <cmtptr> :t (,)
07:56:32 <lambdabot> a -> b -> (a, b)
07:56:34 <cmtptr> > 1,2
07:56:37 <lambdabot>  <hint>:1:2: parse error on input ‘,’
07:56:40 <cmtptr> ^ why does that need parentheses?
07:57:03 <Fuuzetsu> because that's what a pair is defined to be
07:57:32 <cmtptr> but it looks like , is an infix function that creates pairs from two arguments
07:57:42 <ekuam> it's not, though
07:57:44 <cmtptr> I don't need parethenses to do x:xs
07:57:45 <cmtptr> oh
07:57:48 <ekuam> because that would make [1,2] ambiguous
07:57:54 <cmtptr> ah
07:57:57 <Fuuzetsu> or [ _ | x, y ]
07:58:02 <Fuuzetsu> or a lot of other things
07:58:16 <ekuam> ( , ) together form the constructor
07:58:21 <Fuuzetsu> [ _ | _ ← x, y ] rather
08:03:08 <Fernandos> Fuuzetsu: And where would one need HoTT in Haskell?
08:03:51 <Fuuzetsu> I have not started reading HoTT so I can't answer that but from what I gather, you probably wouldn't apply it to Haskell directlly but to languages with stronger type systems
08:04:16 <Fernandos> Ok, I'm lucky to not have to bother about that then :)
08:05:26 <adas> 0 is lowest precedence
08:19:35 <geekosaur> HoTT is more of a side interest, yes
08:19:46 <geekosaur> since high powered haskellers tend to be type theory wonks
08:23:59 <Fuuzetsu> what's a cartesian context…
08:24:03 <Fuuzetsu> Google is not helping
08:26:09 <gcganley> Fuuzetsu: sounds like set theory
08:32:27 <Marce> hey
08:35:26 <h1d3m3> just getting started with Haskell, so sorry if this question is really easy or worded incorrectly. Is there a way to turn “hello” into [‘h’,’e’,’l’,’l’,’o’]..I need to pass each character into a function….but not have the array of chars still be a string (though array of chars and string seem to be the same thing)
08:35:47 <Fuuzetsu> "hello" is already that
08:36:00 <solarus> > "ab" == ['a','b']
08:36:02 <lambdabot>  True
08:36:05 <Marce> "hello" is the same as ['h','e','l','l','o'] already
08:36:07 <Fuuzetsu> :t map (undefined :: Char -> Char) "hello"
08:36:08 <lambdabot> [Char]
08:36:09 <mroman_> h1d3m3: A String is just a list of characters
08:36:14 <ClaudiusMaximus> > ['h','e','l','l','o']
08:36:17 <lambdabot>  "hello"
08:36:18 <Hafydd> The function that does that is called "id".
08:36:33 <mroman_> You can think of ghc/ghci providing you syntactic sugar to turn "abc" into ['a','b','c'] _behind the scenes_
08:36:52 <tromp> :t interact
08:36:53 <lambdabot> (String -> String) -> IO ()
08:37:00 <Marce> what do you wanna do with it?
08:37:06 <h1d3m3> but if I had a function that only takes a single char, how can I get each char from the string? (just use (x:xs) where x will be a single char I guess?)
08:37:22 <Fuuzetsu> I just told you, map
08:37:23 <Fuuzetsu> :t map
08:37:24 <lambdabot> (a -> b) -> [a] -> [b]
08:37:27 <mroman_> > map (toLower) "ABCD"
08:37:29 <lambdabot>  "abcd"
08:37:38 <h1d3m3> great. I’ll check it out. thx.
08:37:50 <mroman_> > map (\c -> if c == 'a' then '1' else '0') "ahthana"
08:37:52 <lambdabot>  "1000101"
08:38:50 <mroman_> unless you wan't to write map by yourself. But it's already there ;)
08:38:53 <mroman_> *want
08:39:17 <solarus> > map (fromEnum . (=='a)) "ahthana"
08:39:17 <mroman_> @source map
08:39:17 <lambdabot> Unknown command, try @list
08:39:19 <lambdabot>  Syntax error on 'a
08:39:19 <lambdabot>  Perhaps you intended to use TemplateHaskell
08:39:32 <solarus> > map (fromEnum . (=='a')) "ahthana"
08:39:33 <lambdabot>  [1,0,0,0,1,0,1]
08:39:35 <mroman_> no source anymore?
08:39:40 <Fuuzetsu> @src map
08:39:41 <lambdabot> map _ []     = []
08:39:41 <lambdabot> map f (x:xs) = f x : map f xs
08:39:43 <mroman_> ah
08:39:53 <h1d3m3> I got it. Thanks. Map works perfect….
08:40:57 <mattbrandt> I'm trying to create an arm cross compiler on OS X and I'm getting "error memory barriers unimplemented on this architecture" when building.
08:41:21 <mattbrandt> using ghc-head
08:43:26 <codygman> I'm getting this error trying to cabal install vector onto my flash drive, I'm guessing it's trying to build statically: http://lpaste.net/112318. I have "shared: True" in my cabal.config file in that same folder.
08:46:12 <k00mi> mattbrandt: try #ghc-dev
08:46:21 <mattbrandt> will do. thanks
08:46:33 <Fuuzetsu> there's ghc-dev?
08:46:36 <Fuuzetsu> don't you mean #ghc/
08:46:51 <k00mi> uhm
08:47:22 <k00mi> not sure, but it's not hard to find out ;-)
08:47:27 <Fuuzetsu> k00mi: #ghc is the wrong place for that question anyway, user questions go here
08:48:34 <k00mi> ok
08:53:05 <gcganley> are there any guides for cross compilation from a linux desktop onto a linux raspberry pi
08:53:05 <kgadek> is it possible for GHCi to reload all packages? modules are easy to reload :)
08:53:31 <kgadek> https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi
08:53:58 <kgadek> gcganley: is that sufficient?
08:54:49 <gcganley> kgadek: this helps but im also looking for using cabal and the rest of it
08:55:49 <adnam_> kgadek: what do you mean by reload packages? the source isn't available for installed packages
08:55:56 <kgadek> gcganley: do you mean "using cabal" here? https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
08:57:05 <kgadek> adnam_: my use case is to load package foo via :m +foo then work on some file bar via :load bar.hs
08:57:14 <kgadek> and sometimes I need to fix the package foo
08:57:30 <kgadek> so I do that and cabal install it
08:57:48 <kgadek> and would like to do :m +foo that would reload that
08:58:00 <Fuuzetsu> you can't do that
08:58:28 <kgadek> :(
08:58:43 <kgadek> any technical reasons or "just no such feature implemented"?
09:00:08 <Fuuzetsu> you would at the very least have to go out into the world recompile the package, point at the new info, unload the old one and load up the new one
09:00:28 <Fuuzetsu> why not just use -ipackagedirectory?
09:02:07 <Fuuzetsu> that's pretty much what you're after anyway
09:02:33 <kgadek> I'm fine with recompiling package in other console (actually I have a guard script to do that continously in background). And I would be fine with "get back to clean state, reload all user passed with :m+ and finally reload whatever was :load"
09:03:03 <kgadek> that would be super-useful when working with multiple packages at once
09:03:37 <Fuuzetsu> but -i solves all this
09:04:11 <Fuuzetsu> although that depends how complex your packages are I suppose
09:04:23 <kgadek> still I need to quit ghci, start it and then load… hmr, 20 modules
09:05:01 <kgadek> I believe that would be problematic since they would conflict with each other
09:05:18 <carter> current status: building a 32bit version of 7.8.3 for OS X
09:05:20 <Fuuzetsu> if -i works for your setup then you just reload the module
09:05:55 <Fuuzetsu> anyway, no such feature as you describe
09:08:01 <kgadek> pitty :(
09:08:04 <daniell> Hey, I'm trying to get the Int from a type. k = Constructor 5. I want to get the 5. How do I do this in a nice way? What I do now: http://pastebin.com/NQpkPsB1
09:08:24 <carter> getInt (Constructor i)= i
09:11:00 <quchen> And you probably should not be using `head`, and rely on pattern matching instead.
09:11:11 * hackagebot grid 7.6.7 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.7 (AmyDeBuitleir)
09:11:36 <daniell> carter: doh, yes that'll do.
09:12:09 <daniell> carter: thanks
09:18:47 <vanila> http://lpaste.net/112319
09:18:53 <vanila> what am I supposed to do in this situation
09:18:53 <vanila> ?
09:19:12 <vanila> is there some kind of cabal "reset" so i can try again
09:19:19 <quchen> Sure, delete .cabal
09:19:29 <quchen> And possibly .ghc
09:19:41 <ekuam> oh, ouch
09:19:56 <ekuam> quchen: isn't it the other way round?
09:19:59 <quchen> That's the hardest reset you can do that I'm aware of
09:20:17 <quchen> Well, you can try working your way around, but in my experience that takes considerably more time and nerves than doing it the hard way.
09:20:26 <ekuam> i.e. you always delete the package db, and you also may delete the library files
09:20:28 <quchen> The important thing is to remember what you did wrong the first time.
09:20:30 <kgadek> vanila: just wanted to note that "nix" exists, if you have tried that ignore my comment
09:20:53 <merijn> vanila: Did you happen to run --force-reinstalls at any time?
09:20:54 <kgadek> that would prevent such situation in the future
09:21:01 <vanila> kgadek, I want to use it I just don't know how to
09:21:11 <merijn> kgadek: No, what would prevent this in the future is not doing reinstalls
09:21:28 <kgadek> vanila: https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
09:21:53 <quchen> --force-reinstalls just reinstalls everything that is needed by one installation I think. It does not ask anyone else whether what you're reinstalling breaks things.
09:22:02 <vanila> ty :)
09:22:47 <Taneb> What does "/usr/bin/ld: cannot find -lHStransformers-compat-0.3.3.4-ghc7.8.3" mean, and how do I fix it?
09:22:53 <merijn> I think we should make cabal's --force-reinstalls warning scarier
09:22:59 <merijn> People keep trying to use it...
09:23:27 <johnw> morning all
09:23:28 <kgadek> merijn: well, I believe they are rather forced to do so.
09:24:05 <carter> johnw: i'm building 32bit 7.8 for mac
09:24:24 <johnw> interesting!
09:24:32 <Fuuzetsu> kgadek: force-reinstalls nearly always makes things worse
09:24:42 <merijn> s/nearly always/*always*
09:24:57 <Fuuzetsu> force-reinstalls nearly always makes things worse immediatelly*
09:25:05 <merijn> --force-reinstalls *never* makes things better, it's basically --reenable-cabal-hell
09:25:23 <Fuuzetsu> isn't cabal hell enabled by default?
09:25:47 <merijn> Fuuzetsu: Only the new meaning of the term
09:25:55 <kgadek> that's why I mentioned nix, as too often I get into situation that (something something) I would need to --force-reinstalls
09:26:06 <merijn> Fuuzetsu: The original meaning of cabal hell was "cabal silently corrupted my package DB and now nothing works"
09:26:40 <Fuuzetsu> what is it now?
09:26:43 <vanila> Just did cabal install --force-reinstalls and everything works! will look into nix soon :)
09:26:51 <Fuuzetsu> I hope you're joking
09:26:54 <gcganley> vanila: NO!!!
09:26:55 <Fuuzetsu> >everything works
09:26:59 <Fuuzetsu> I'm dying
09:27:13 <kgadek> vanila: please don't do that
09:27:16 <kgadek> and if you have
09:27:17 <merijn> Fuuzetsu: "my dependency are inconsistent" in some way that cabal refuses to build due to my dependencies being a mess
09:27:25 <kgadek> please save yourself time
09:27:27 <merijn> vanila: I guarantee you, you've just broken everything
09:27:34 <kgadek> and rm ~/.cabal ~/.ghc now
09:27:47 <gcganley> rm -r ~/.cabal ~/.ghc
09:27:56 <merijn> See, I told you --force-reinstalls needs a *way* scarier warning
09:28:12 <bergmark> even before i started using sandboxes i never managed to break my istallation with --force-reintalls
09:28:13 <merijn> "THIS WILL KILL YOURS KIDS AND MURDER YOUR PETS" in bright red, blinking text or something
09:28:27 <merijn> bergmark: Count yourself extremely lucky
09:28:40 <johnw> I've used force-reinstalls many a time, without incident
09:28:47 <johnw> although now I never use cabal at all
09:28:51 <kgadek> merijn: I'm against that. 'force' means 'force'. I don't want to be treated like a baby
09:28:52 <merijn> johnw: You know what you're doing
09:29:17 <kgadek> we are adults, right?
09:29:28 <johnw> --unsafe-force-reinstalls
09:29:46 <merijn> kgadek: Except not a single newbie realises the consequence of force being "none of your currently and installed and working libraries are guaranteed to keep working after this"
09:30:00 <Fuuzetsu> unsafe-coerce-packages
09:30:03 <kgadek> then probably johnw is right
09:30:09 <kgadek> unsafe-perform-reinstall
09:30:16 <vanila> johnw, How do you avoid cabal?
09:30:21 <johnw> vanila: Nix
09:30:33 <johnw> Nix is the most wonderful thing that could ever happen to a Haskell developer
09:30:42 <Fuuzetsu> *cough* packageIds *cough*
09:30:47 <vanila> ok!
09:30:48 <johnw> implicit, binary-sharing sandboxes everywhere, multiple GHCs that don't collide, etc.
09:30:52 <lpaste> aranea pasted “No title” at http://lpaste.net/795768581370413056
09:30:58 <johnw> and system-level sandboxing no less
09:31:05 <johnw> not just Haskell package sandboxing
09:31:12 * hackagebot timeplot 1.0.26 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.26 (EugeneKirpichov)
09:31:17 <johnw> anyone who's interested, hop into #nixos and ask away!
09:31:21 <aranea> Could someone have a look at the code I pasted?
09:31:40 <Fuuzetsu> aranea: I can't see anything that would make a big improvement over what you have
09:31:47 <johnw> aranea: you could use applicative there to good effect
09:32:11 <Fuuzetsu> it'd probably be ugly
09:32:12 <Twey> aranea: You might like RecordWildcards, alternatively
09:32:19 <johnw> Proposal <$> field decimal "ID" <*> field ... <*> (skipSpace *> takeText)
09:32:20 <aranea> In particular, those six lines just for getting the values into the record are annoying.
09:32:22 <Twey> return Proposal { .. }
09:32:35 <Fuuzetsu> RWs are evil ;P
09:32:39 <Twey> Fuuzetsu: Why so?
09:32:43 <johnw> I like RWs
09:32:49 <Fuuzetsu> they just feel too damn fragile
09:32:52 <johnw> he'd just need to rename his local variables
09:32:56 <Fuuzetsu> I use them sometimes but I always feel they'll break
09:33:00 <Twey> I like them more than applicative here
09:33:18 <Twey> When I have a record constructor I usually expect to make changes to the order of the fields later
09:33:28 <Twey> It's a pain if that breaks everything
09:33:30 <johnw> Fuuzetsu: have you experienced this fragility?
09:33:37 <Fuuzetsu> no, it's not a well-founded fear
09:33:40 <johnw> ok
09:33:50 <johnw> I use RWs pretty heavily, and never had isseus
09:34:05 <johnw> the assignments side of them, as Twey is suggesting, I use less often
09:34:08 <johnw> but I'll have to keep that trick in mind
09:34:47 <aranea> johnw: Yes, Twey is right, that's why I didn't use Applicative syntax.
09:35:18 <aranea> I'll have a look at RecordWildcards, I never heard of those before.
09:35:18 <Twey> Or worse, *doesn't* break everything and silently swaps two fields with the same type
09:36:01 <Fuuzetsu> stonger typing could have stopped this
09:36:36 <Twey> Aye.  Unfortunately, I'm in Haskell and not Agda 3.0, so ‘Int’ is a type that people use :þ
09:37:06 <aranea> Alternatively, perhaps some other data representation instead of records could ease things? I'm thinking of lens/fclabels/something similar.
09:37:21 <johnw> is Agda up to 3.0?
09:37:24 <Fuuzetsu> no
09:37:25 <Fuuzetsu> 2.4.2
09:37:26 <Twey> johnw: Nope.  ;)
09:37:38 <aranea> I've never used those, but as far as I've understood they have something to do with records.
09:37:51 <Twey> aranea: Lens doesn't help you with construction.  Vinyl does, but I think it's overkill here.  RecordWildCards serves you fine.
09:37:58 <Fuuzetsu> there is some talk on the Agda ML about someone writing a new Agda → Haskell compiler
09:38:07 <Fuuzetsu> are you ready for Agda 3.0 to take over the world?
09:38:57 <Twey> (I can never remember whether that's capitalized)
09:40:24 <aranea> So, I'd just have to do some renaming and then I could write "return Proposal {..}"?
09:40:52 <Fuuzetsu> yes
09:41:57 <aranea> Great!
09:42:12 <johnw> yeah, RWs are pretty magical when you use them right
09:42:22 <Fuuzetsu> black magic
09:42:28 <johnw> used wrongly, they can make code nearly unreadable
09:42:54 <johnw> since the reader is probably used to always reading field accessors as functions
09:43:27 <johnw> with RWs they become locally shadowed by names with a context-specific meaning
09:43:53 <bergmark> i recommend never using them
09:44:16 <johnw> when you deal with lots of records and lots of field accesses, RWs can also really help clarity of code
09:44:22 <johnw> I recommend sometimes using them
09:44:29 <bergmark> :-)
09:44:47 <bergmark> i'd rather use NamedFieldPuns to make it explicit
09:44:51 <bergmark> but i never do that either
09:44:54 <johnw> how the world of Fay, bergmark?
09:45:09 <bergmark> johnw: i still dread upgrading to the latest haskell-src-exts :-(
09:45:47 <aranea> bergmark: Yes, I guess I'll do that for clarity. "return Proposal {pID, pAuthor etc.}"
09:46:33 <bergmark> but i haven't done much fay work lately, too many other projects!
09:48:31 <SrPx> Hi, IntMap.update from Data.IntMap expects a function (a → Maybe a). Why not just (a → a)? Is there an alternative? I don't see why I have to use Maybe when all I'm doing is incrementing a value in a map
09:48:52 <monochrom> it can also delete things
09:48:54 <Twey> SrPx: Nothing allows you to delete the value
09:48:55 <merijn> SrPx: Because update can delete values
09:49:00 <SrPx> ah nvm, adjust is what I want
09:49:02 <SrPx> thanks :)
09:49:16 <johnw> update is like .~ for maps in lens
09:49:34 <SrPx> .~ ?
09:49:53 <johnw> fromList [(1,2)] & at 1 .~ Nothing
09:49:59 <johnw> would drop the element at index 1
09:50:32 <johnw> I've found at least two things that lens can do better than any alternative I've ever come across: manipulating maps, and manipulating State
09:50:56 <johnw> even though it's usually billed as a better way to manipulate records, although the win there isn't as big I don't think
09:51:08 <SrPx> I ...? I guess I should learn lens someday
09:51:25 <johnw> yes, it can be super handy
09:51:32 <johnw> it's like having Perl inside your Haskell :)
09:51:57 <SrPx> oh now I'm sold
09:52:00 <cite-reader> Now tempted to write Acme.Perl.
09:52:10 <SrPx> I didn't want to read my code anyway
09:52:21 <merijn> cite-reader: Oh, please do :)
09:52:39 <cite-reader> I'll think about what should go in.
09:52:45 <Fuuzetsu> re-export lens
09:53:02 <FCatalan> it's great, like XSLT *ducks*
09:53:32 <aranea> johnw: The other thing lens can do better is cluttering your installation with hundreds of obscurely named packages.
09:54:45 <merijn> aranea: Which is great, because now you can rely on people having bifunctors installed, etc. :D
09:59:29 <johnw> merijn++
09:59:48 <Fuuzetsu> aren't bifunctors going into base soon
10:00:07 <gcganley> Fuuzetsu: I havent seen any news on that...
10:00:08 <johnw> if they do, profunctors should as well
10:00:25 <johnw> (and contravariant functors)
10:00:27 <merijn> Fuuzetsu: I wish...
10:00:51 <Fuuzetsu> there's a thread on libraries@
10:01:18 <merijn> edwardk should adopt Tekmo's mmorph into transormers, that'd be nice too
10:02:00 <gcganley> Fuuzetsu: you could ask edwardk
10:02:00 <Fuuzetsu> there is in fact no -1 in that thread
10:02:16 <Fuuzetsu> edwardk: any news on bifunctors in base? Seems it was +1 from everyone on libraries@
10:02:22 <johnw> merijn: I wish monad-control would go in there as well
10:02:26 <johnw> I think it's proven its usefulness
10:03:05 <edwardk> Fuuzetsu: we're still planning to bring in the 3 major classes from that package, its stalled a bit because right not getting Foldable/Traversable right is highest priority and impacts the way that happens
10:04:08 <merijn> johnw: tbh, I've started liking monad-control less and less
10:04:15 <johnw> why?  I use it constantly
10:04:27 <merijn> I prefer exceptions
10:04:36 <johnw> umm
10:04:44 <merijn> johnw: (the package)
10:04:46 <johnw> not seeing how those two libraries really intersect
10:05:12 <Fuuzetsu> edwardk: ok, awesome
10:05:50 <merijn> johnw: Last I used it was to do exception handling in a transformer stack
10:06:00 <SrPx> Why can't I `MyConstructor { foo x = y }` ? :(
10:06:10 <Fuuzetsu> what would that do?
10:06:16 <johnw> merijn: I use it for things like carrying a reader environment transparently into a thread, things like that
10:06:25 <SrPx> The same as `MyConstructuor { foo = \x → y }` does
10:06:41 <toblerone> Can anyone point me to a guide on updating GHC on OSX? It feels like the recommended approach changes constantly. Is using homebrew a bad idea?
10:06:46 <merijn> johnw: I prefer doing that explicitly these days
10:06:57 <Fuuzetsu> SrPx: eh, could probably be hacked in on GHC side, I just think no one cared enough
10:07:03 <merijn> toblerone: homebrew has always been bad, the 2 sane ways are 1) platform 2) GHC binary release
10:07:29 <SrPx> Fuuzetsu: wow ... really? That seems weird, it sounds like a very common pattern to me to be ignored.
10:07:35 <Fuuzetsu> merijn: 3) nix ;)
10:07:47 <SrPx> I mean anytime anyone has to create an instance of any type that has functions...!
10:07:49 <merijn> Nix people are like vegans >.>
10:08:00 <Fuuzetsu> I will spread my veganism all over #haskell
10:08:04 <merijn> They compulsively have to bring it up...
10:08:06 <Fuuzetsu> you can not stop the vegetables
10:08:15 <johnw> merijn: I use Nix to cook vegetables here at home
10:08:20 <Fuuzetsu> merijn: because people compulsively have package problems ;P
10:08:41 <jle`> SrPx: I can see the benefit
10:09:02 <merijn> Fuuzetsu: I don't, but I accept that I'm probably an outlier because I don't use packages with Yesod-levels of dependency complexity
10:09:19 <Fuuzetsu> SrPx: most people probably find \x → … more idiomatic anyway
10:09:34 <Fuuzetsu> like when you have a type alias for a function, many people still use \… on the RHS
10:09:46 <SrPx> Fuuzetsu: why is \x→ more idiomatic inside a constructor, but not outside?
10:10:29 <Fuuzetsu> that's just how things seem to be; guess you look at the type field expects and fill in the RHS rather than transform LHS to match
10:10:35 <toblerone> merijn: ok. and the haskell platform should work like a simple installer... even on OSX? I seem to remember there being some complications with using the installer. Really I just want to be able to use base >= 4.7
10:10:43 <quchen> "foo = \x -> …" means "foo is something that has a function as value" to me. "foo x = …" means "foo is a function of one parameter and when given one it evaluates to (...)". Since you want to assign the value of a field to be a function, the first one seems more logical. But that's just one way of seeing it.
10:12:23 <Logiar> I googled something I'm trying to do, checking of something is of a specific type and the answer they recieved was pretty much that they're thinking wrong in haskell if they're trying to do that. So.. If I got dosomething LList(x:xs) and i want to throw an error if x is a number. What would be the right way to do it?
10:12:55 <Fuuzetsu> you know if x is a number already through the type of LList
10:13:05 <quchen> The right way to do this is not to do this. You don't throw errors out of pure code.
10:13:26 <merijn> toblerone: I've installed the platform on 10.9 just 10 minutes ago :)
10:13:28 <Fuuzetsu> quchen: he's writing an evaluator for something (RPN calculator I'm guessing) so his list is strings
10:13:31 <quchen> You can make the result `Nothing` or `False` or whatever, but an error is the equivalent of your car blowing up when you forget the seatbelts.
10:13:50 <merijn> toblerone: The platform was broken for a while due to the 10.9 switch to clang, but since the newest release it works just fine on OSX again
10:14:01 <toblerone> ah okay great to hear
10:14:03 <toblerone> thanks : )
10:14:05 <quchen> Fuuzetsu: I guess that means "be quiet quchen the problem is much easier let's not get hung up on this"? :-)
10:14:20 <stef1a> how can i determine where a function is documented?
10:14:25 <stef1a> i.e. in what package or lib
10:14:38 <Logiar> actually I'm writing an evaluator for an AST of LISP type expressions
10:14:46 <josephle> merijn: do you if the platform is compatible with 10.10?
10:14:49 <josephle> *do you know
10:14:58 <merijn> stef1a: hoogle, if it's indexed by that, or if you configure cabal to install local docs, consult the index of your local documentation install
10:15:04 <Fuuzetsu> Logiar: www.cs.virginia.edu/~wh5a/personal/Transformers.pdf if you're filling adventurous, might be too much for beginner
10:15:04 <Logiar> And I've been told to do error handling through the use of errors in evaluation
10:15:15 <Fuuzetsu> it uses an evaluator as a running example
10:15:19 <merijn> josephle: I think it is, with the usual "beta OS, things may be buggy" caveats
10:15:33 <stef1a> merijn: okay. if i'm using hoogle, i assume that if i find a function on the Prelude.html page, then the function belongs to the Prelude?
10:15:35 <Fuuzetsu> quchen: more or less ;P
10:15:51 <Fuuzetsu> but he *is* using error so you're not in the wrong either (at least he was earlier)
10:16:14 <merijn> stef1a: Well, that means it's exported by Prelude, it may be defined elsewhere (for example, in the GHC modules) and re-exported by Prelude
10:16:48 <stef1a> merijn: alright. how can i determine where it's defined, then?
10:16:57 <Logiar> I would be feeling adventorous maybe, but been given very specific signatures for the functions I'm supposed to make
10:17:13 <Fuuzetsu> ok, what's your signature?
10:17:45 <Logiar> eval::AST -> Context -> Memory -> (AST,Context,Memory)
10:18:24 <Fuuzetsu> unless AST can carry extra info than just the tree structure, you can't signal errors (bar unchecked exceptions I guess)
10:18:28 <Fuuzetsu> i.e. that type is bad
10:19:04 <Logiar> data AST = Atom String | Number Int | LList [AST] deriving (Eq,Show,Ord)
10:19:22 <quchen> Maybe maybe maybeee oooh maybee maybe maybeee oooooh -- I'm so sorry.
10:19:33 <Fuuzetsu> it looks to me that you're meant to assume you are always given a valid program
10:19:59 <Logiar> We're also told to check for errors and do error handling by using "error" during evaluation
10:20:10 <Fuuzetsu> …that's hardly error handling
10:20:14 <Fuuzetsu> that's aborting when something goes wrong
10:20:24 <Fuuzetsu> unless that's what they mean
10:20:27 <Logiar> Well..
10:20:35 <Logiar> That how I've understood it
10:20:37 <Logiar> I mean..
10:20:49 <Logiar> I can hardly continue evaluation of an expression with errors in it
10:21:09 <Logiar> without making assumptions about the error
10:21:51 <Fuuzetsu> one would normally back out and have error handling else where which did nice source pretty printing and all that gunk
10:22:12 <Fuuzetsu> :t all . map isDigit
10:22:14 <lambdabot>     Couldn't match type ‘[Bool]’ with ‘a -> Bool’
10:22:14 <lambdabot>     Expected type: [Char] -> a -> Bool
10:22:14 <lambdabot>       Actual type: [Char] -> [Bool]
10:22:15 <Fuuzetsu> uh
10:22:17 <Fuuzetsu> :t all isDigit
10:22:19 <lambdabot> [Char] -> Bool
10:22:31 <Fuuzetsu> I guess that's what they want you to do?
10:22:51 <quchen> Do you have a link to the description of the problem you're trying to solve, Logiar?
10:22:58 <Logiar> But the type is Number int though
10:23:01 <quchen> It's really hard to guess all the boundary conditions
10:23:06 <zwer_r> :t all isDigit
10:23:07 <lambdabot> [Char] -> Bool
10:23:20 <Logiar> I'm also guessing here D:
10:23:24 <zwer_r> mhmm late to the party
10:23:36 <Logiar> And unless you know Norwegian I'm afraid not
10:23:56 <Fuuzetsu> Logiar: ok, I read up; you can just pattern-match on your Number and use error like they told you
10:24:17 <Fuuzetsu> eval (LList (Number _:_)) = error "bad spec"
10:26:44 <gcganley> :t eval
10:26:46 <lambdabot>     Not in scope: ‘eval’
10:26:46 <lambdabot>     Perhaps you meant ‘ival’ (imported from Data.Number.Interval)
10:26:54 <Taneb> text won't install and I can't work out why
10:26:54 <toblerone> merijn: okay, and just to check before i do something i may end up regretting, it is a good idea to uninstall the previous version with uninstall-hs... right? : )
10:26:57 <Fuuzetsu> it's the function he's defining
10:27:08 <Fuuzetsu> Taneb: lpaste the log
10:28:02 <Taneb> http://lpaste.net/8951660920967266304
10:29:39 <Fuuzetsu> yeah, I don't know
10:29:50 <Fuuzetsu> hm, I wonder what the error code 9 was
10:29:57 <Taneb> Could it be because cabal was compiled with an old ghc?
10:30:04 <supki> Taneb: that looks like OOM
10:30:10 <osa1> is there a hope for loading FFI modules into GHCi in the future of GHC?
10:30:13 <Taneb> supki, OOM?
10:30:15 <Fuuzetsu> isn't 9 OOM
10:30:17 <Fuuzetsu> fug
10:30:19 <supki> out of memory
10:30:23 <Taneb> Aw, crap
10:30:34 <Fuuzetsu> downloadmoreram.com
10:30:44 <gcganley> osa1: only if the IO monad starts accepting dynamic loading of c librarys
10:30:57 <gcganley> hes right, downloadmoreram.com
10:31:05 <osa1> gcganley: any plans for that?
10:31:38 <gcganley> osa1: not that I know of...
10:32:06 <gcganley> osa1: thats probebly not under edwardk's jursdiction so i have no clue where to send you to look
10:32:08 <Logiar> :( programming this makes me feel bad, I'm handling an if statement by writing an if statement...
10:32:31 <Fuuzetsu> more types, fewer ifs
10:36:27 <Zoxc> Can you force the evaluation of a function with exceptions as side effects?
10:37:43 <ReinH> Zoxc: can you give me an example of a function with exceptions as side effects?
10:38:08 <seanhess> If I run "cabal sandbox add-source" to work with a patched dependency, where does that get stored, in the local database? Is there any way to add that to version control so other devs can build the project?
10:38:39 <Fuuzetsu> add-source simply puts a note somewher in the sandbox files in the repo that it should look at that path
10:38:50 <Fuuzetsu> other devs won't have your checkout so it won't work for them
10:39:07 <Zoxc> ReinH: I want to verify that a data structure is valid before returing it (Using the error function)
10:39:19 <merijn> toblerone: Correct
10:39:38 <Fuuzetsu> why would your data structure ever be invalid?
10:39:52 <Taneb> Is it OK to compile a library on one computer and copy-paste it to another if they have the same GHC version?
10:40:06 <Fuuzetsu> probably not
10:40:13 <merijn> Taneb: GHC version is irrelevant, OS and architecture are relevant
10:40:34 <merijn> Taneb: Well, GHC version is *also* relevant, but OS and architecture more so :)
10:40:44 <Taneb> merijn, they have the same architecture and OS :)
10:41:04 <ReinH> seanhess: Not directly, but we use a tool a lot like yesod's "cabal-meta" to list git dependencies in a file and add them (https://github.com/yesodweb/cabal-meta/blob/master/main.hs)
10:41:13 <merijn> Taneb: Oh, actually, it depends on for what purpose
10:41:17 <ReinH> Er https://github.com/yesodweb/cabal-meta
10:41:24 <merijn> Taneb: Copying over the library won't let GHC see it as installed
10:41:32 <Taneb> Because this server does not have enough memory to install text :(
10:41:48 <Fuuzetsu> ReinH: who's ‘we’?
10:42:14 <ReinH> Fuuzetsu: the company I work for :)
10:42:23 <Fuuzetsu> merijn: FTR nix could also solve that… ;)
10:42:26 <ReinH> seanhess: it's 33 lines of bash, so not very difficult to do :)
10:42:31 <Fuuzetsu> ReinH: I'm wondering what that is
10:42:38 <ReinH> Fuuzetsu: and I am being cagey ;)
10:42:58 <ReinH> Fuuzetsu: http://www.alephcloud.com
10:42:59 <Fuuzetsu> ReinH confirmed for NSA
10:43:02 <ReinH> hahaha
10:43:06 <ReinH> pretty close actually
10:43:11 <wz1000> ReinH: You write haskell for a living? Nice.
10:43:13 <ReinH> except we're the good guys
10:43:25 <Fuuzetsu> what does Haskell run there?
10:43:27 <ReinH> wz1000: Well, right now I'm writing a lot of bash ;)
10:43:32 <Fuuzetsu> secure!
10:43:34 <ReinH> Fuuzetsu: all the core systems
10:43:50 <ReinH> @hackage tls
10:43:50 <lambdabot> http://hackage.haskell.org/package/tls
10:44:01 <ReinH> the author of ^ does our crypto stuff :)
10:44:09 <Fuuzetsu> can't fool me
10:44:11 <Fuuzetsu> bet he put backdoors in
10:44:18 <ReinH> probably
10:44:46 <ReinH> I don't think we actually use the tls package. It's really hard to mitigate side channel attacks in a language like Haskell :/
10:44:50 <Logiar> This annoys me a little, error checking is supposed to be done through evaluation, but for if statements I'm not supposed to evaluate the then/else parts unless they're needed. So part of the expression could never be checked for errors.
10:45:25 <ReinH> I've been trying Shelly and so far it's pretty nice, but I haven't replaced any of my bash scripts with it in production yet
10:46:02 <ReinH> There seems to be a weird buffering issue where output interleaves even in line buffering mode o_O
10:46:06 <ReinH> I blame lazy IO?
10:46:33 <ReinH> Maybe I'll try Chris's new conduit-based thing
10:47:08 <geekosaur> line buffering is not per thread
10:47:12 <geekosaur> it's per handle
10:47:48 <geekosaur> if multiple threads are doing concurrent output to the same handle, they will interleave, just as in any other language. send stuff to a logging thread via a (T)Chan instead
10:48:36 <wz1000> ReinH: I tried replacing my bash scripts with haskell, but interprocess communication was too much of a hassle.
10:48:48 <ReinH> wz1000: Shelly is pretty nice
10:49:03 <geekosaur> multiprocessing same issue, again you will need something to collate
10:50:49 <sagittarian> let's say i'm typing out a long arithmetic calculation
10:51:17 <geekosaur> also there's some complexity with routing stdout and stderr to the same place, either across processes or in a single process. it works on console because stderr is dup()ed
10:51:18 <ReinH> geekosaur: I'm not sure that I'm using multiple threads, though, unless Shelly is doing so for me under the hood
10:51:25 <sagittarian> i type out a bunch of operations, and then i realize, ah that's just the numerator, now i need the denominator
10:51:43 <sagittarian> but i'm too lazy to go back and surround what i already wrote with parens
10:51:43 <merijn> ReinH: Thanks for reminding me, I need to bug thoughtpolice to finish his NaCl library bindings so we can have side-channel free crypto in haskell too :)
10:51:43 <ReinH> Which would be a weird thing for Shelly to do
10:51:46 <geekosaur> I hadn't caught up on backscroll. you have multiple *processes*, same problems arise only more so
10:51:51 <ReinH> merijn: :)
10:51:55 <ReinH> merijn: seems good
10:52:05 <sagittarian> is there a way to get the grouping that i want, something like ($) for function application, without going back to the beginning of the line?
10:52:23 <merijn> thoughtpolice: How's haskell NaCl coming along? :)
10:52:25 <ReinH> merijn: Vincent basically writes thin Haskell wrappers around C crypto :p
10:52:39 <geekosaur> ($) IS function application
10:52:42 <Fuuzetsu> ReinH: do they thinly segfault
10:52:43 <ReinH> That's a bit of an overstatement
10:52:49 <geekosaur> can you explain a bit more clearly?
10:52:58 <ReinH> But he does lean on FFI for memory management, etc, quite a bit
10:53:11 <sagittarian> right, so how would i apply it in this case
10:53:12 <sagittarian> ?
10:53:25 <Fuuzetsu> sagittarian: you haven't given actual code example
10:53:26 <sagittarian> i can't do a + b * c + e $ (/e)
10:53:42 <Fuuzetsu> use parens
10:53:42 <sagittarian> something like that
10:53:58 <sagittarian> Fuuzetsu: the stated problems is that i'm too lazy to use parens
10:54:03 <ReinH> geekosaur: Ah, multiple processes, yes.
10:54:16 <Fuuzetsu> sagittarian: then become less lazy, parens are THE solution here
10:54:19 <ReinH> geekosaur: Any suggestions for solving this with Shelly specifically?
10:54:27 <sagittarian> why isn't 'use parens' the solution to the problem that ($) solves?
10:54:38 <Fuuzetsu> it is
10:54:42 <ReinH> sagittarian: it is.
10:54:42 <Fuuzetsu> some people just prefer $
10:54:43 <geekosaur> I'd have to see specific examples. and am not sure I could poke any time soon
10:54:50 <sagittarian> there you go
10:55:11 <Fuuzetsu> $ is not magic
10:55:15 <Fuuzetsu> it is just an operator
10:55:17 <sagittarian> no, it's just convenient
10:55:18 <geekosaur> sagittarian, your problem there is you want $ to be magic syntacx
10:55:22 <gcganley> $ is just another function
10:55:35 <ReinH> geekosaur: The examples seem to be of the form `shelly (echo "Thing" >> cmd "something" "with" "lots" "of" "output" >> echo "Another thing")`
10:55:36 <gcganley> @src $
10:55:36 <lambdabot> f $ x = f x
10:55:36 <sagittarian> no, i don't, i was asking if there's something equally convenient for what i'm trying to do
10:55:48 <Fuuzetsu> no
10:55:48 <gcganley> :t ($)
10:55:49 <lambdabot> (a -> b) -> a -> b
10:55:56 <ReinH> er shelly . verbosely (...)
10:55:57 <geekosaur> you are, perhaps you don't realize it
10:56:16 <Fuuzetsu> anything that would be equally convenient would be magic syntax
10:56:17 <gcganley> ReinH: does shelly work well?
10:56:19 <geekosaur> let's try this: show me the type of the thing you want
10:56:29 <sagittarian> Fuuzetsu: can that be proven rigorously?
10:56:35 <geekosaur> perhaps in figuringt hat out, you will realize why it does not exist
10:56:38 <sagittarian> okay, let's see
10:56:39 <geekosaur> and can't
10:57:25 <Fuuzetsu> sagittarian: I know precisely what you want and know how $ works and also know that no operator exists that will work with those precedences that will do what you want and somehow be less work than ()
10:57:45 <geekosaur> ^ what I said, expanded
10:57:57 <Fuuzetsu> you would have to define division that binds weaker than all those operators before it I guess
10:58:01 <Fuuzetsu> which is more work than parens
10:58:10 <karshan> Hello, I am toying with writing a static analysis tool for java in haskell and I had a question about how I should be keeping "pointers" into the AST. Specifically, say I want to define the function getType :: Row -> Col -> Maybe Type. where Row and Col are Int's specifying the row and column number of the identifier I want to find the type of. The idea is to go through the AST, find the node that most closely matches the given sou
10:58:23 <karshan> and then backtrack out to figure out the type of that identifier
10:59:35 <sagittarian> i don't necessarily want it to be specific to division, i can provide (/) as an argument
10:59:40 <Fuuzetsu> karshan: keep source locs and perform a search, not sure where the problem is
10:59:44 <glaebhoerl> what's the dual of "expressiveness"? a type system with greater expressiveness is able to express a greater number of correct programs (e.g. with increasing levels of support for polymorphism). while on the other hand is the ability to _reject_ a greater number of _incorrect_ programs (e.g. with GADTs). but what's a good thing to call that? "restrictiveness" gives the wrong impression (it should have a positive connotation, for
10:59:45 <karshan> It is very easy for me to find the identifier at a source location using Data.Data.Lens's template, except that lenses give me values not "pointers" anyone have any suggestions on how I should do this ? Maybe zippers are the solution ?
10:59:46 <glaebhoerl> one thing - and ideally also be a single and descriptive word)
10:59:49 <Fuuzetsu> sagittarian: which is why I'm saying you want magic syntax
10:59:53 <sagittarian> i think i want flip ($) with a sufficiently low precedence
11:00:30 <sagittarian> can i define precedence of custom operators in ghci?
11:00:38 <Fuuzetsu> yes
11:00:38 <karshan> Fuuzetsu: The problem is how to go back up the tree once I have found the node I'm looking for
11:00:41 <Fuuzetsu> I think
11:01:08 <Fuuzetsu> glaebhoerl: stronger/weaker is what is normally use I guess?
11:01:21 <glaebhoerl> Fuuzetsu: but that's both, I think
11:01:29 <glaebhoerl> I'd like to distinguish them
11:01:43 <c_wraith> glaebhoerl: the way I think of it is that GADTs allow me to express more restrictions. :)
11:01:48 <Fuuzetsu> ^
11:02:01 <Fuuzetsu> I don't think it makes sense to judge restrictiveness
11:02:09 <Fuuzetsu> at least not in the way you are doing
11:02:32 <c_wraith> glaebhoerl: GADTs are strictly an increase in expressiveness.  They add the ability to say things you couldn't say without them.  It's just that those things are restrictions on types.
11:02:34 <Fuuzetsu> karshan: not sure what a good solution would be, a zipper might work I suppose but I don't have a specific implementation in mind
11:02:41 <glaebhoerl> c_wraith: well I know how to think of it - I just don't have a good way to express it :p
11:03:28 <c_wraith> glaebhoerl: something like "GADTs allow you to control the types of your data more precisely"?
11:03:38 <glaebhoerl> c_wraith: IINM you could write the same programs removing the extra type information as just ADTs and they would still work, it's just that you could then go on to change them in incorrect ways
11:04:12 <Fuuzetsu> because your type system wasn't expressive enough to impose restrictions
11:04:39 <c_wraith> glaebhoerl: actually, that's not quite true.  To get what GADTs provide, you'd also need type classes.
11:05:10 <c_wraith> glaebhoerl: that's because the restriction is bidirectional - constructors limit the possible types, types limit the possible constructors.
11:06:21 <c_wraith> glaebhoerl: without GADTs, to recover the effect you get from constructors depending on types, you need to involve a type class in some way.
11:06:22 <glaebhoerl> yeah, that's possible. what about something like LiquidTypes then? (haven't actually looked at that -- but iirc it's annotation-based which leads me to suspect that it would accept a strict subset of the programs that GHC otherwise would)
11:06:50 <c_wraith> glaebhoerl: yes, liquid haskell is a strict subset of standard (or GHC) haskell.
11:07:57 <c_wraith> glaebhoerl: it's a special case - refinement typing.  It allows you to specify refinements to the types (usually numeric properties in LiquidHaskell's case) in the annotations, and those refinements are treated as subtypes, of a sort.
11:08:28 <glaebhoerl> anyways, the value of a type system is in the correct programs that it accepts and the incorrect programs that it rejects, and I feel that some features add more value along one axis and other features along the other (though it's not usually *just* on one side, see GADTs)
11:09:23 <c_wraith> glaebhoerl: indeed.  LiquidHaskell is solely about rejecting more invalid programs.  RankNTypes is solely about accepting more valid programs.  Many extensions to the type system are some of each.
11:11:16 * hackagebot app-settings 0.2.0.3 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.3 (EmmanuelTouzery)
11:11:26 <glaebhoerl> and that this is a tradeoff that one can weigh when deciding which features to spend the complexity budget on when designing a language - some prioritize expressiveness, other prioritize ??? more
11:11:36 <glaebhoerl> but I don't have a word for the other thing :)
11:11:51 <merijn> glaebhoerl: I think both affect expressiveness
11:11:59 <merijn> I don't think those axis are opposites
11:12:07 <glaebhoerl> (if you think "expressiveness" should mean both, then OK - give me *two* words that distinguish the one from the other :)
11:12:16 <seanhess> ReinH: thanks!
11:12:26 <merijn> I mean, DataKinds gives me more expressiveness AND the ability to reject more programs
11:12:49 <merijn> glaebhoerl: I think talking in terms of "false positives" and "false negatives" is more sensible
11:13:04 <glaebhoerl> hm, that's at least getting somewhere
11:13:19 <merijn> False negatives are "sensible but rejected programs" and false positives are "silly but accepted programs"
11:13:41 <merijn> Some extensions focus more on letting you reduce false negatives, others more on reducing false positives, some on both
11:14:28 <merijn> glaebhoerl: Expresiveness covers boths sides, because "being able to more accurately express what to X" is more expressive, regardless of whether X is "reject" or "accept"
11:14:29 <glaebhoerl> (wrt DataKinds - really? in olden GHCs without it we just duck typed at the type level and it worked fine. does DataKinds let you implement anything you couldn't before, or does it just let you write the same things with greater clarity and confidence?)
11:14:51 <glaebhoerl> (or I guess, duck kinded)
11:15:54 <c_wraith> DataKinds allows you to add restrictions not present before
11:15:55 <merijn> glaebhoerl: It's lets you add more safety at the type level, compare "data Control; data Content; data Message :: * -> * -> *" vs "data MsgType = Control | Content; data Message :: MsgType -> * -> *"
11:16:09 <glaebhoerl> I know what DataKinds is.
11:16:10 <c_wraith> yeah, exactly merijn's example
11:16:13 <merijn> glaebhoerl: The latter rejects "Message Int Bool", whereas the former does not
11:16:24 <merijn> glaebhoerl: Therefore you can reject more "wrong" types
11:16:51 <glaebhoerl> we're not disagreeing
11:16:56 <glaebhoerl> more like talking past each other
11:17:03 <glaebhoerl> but let me gather some thoughts
11:17:17 <ReinH> seanhess: Another option would be to run a private hackage server and upload your dependencies.
11:17:35 <merijn> glaebhoerl: You were asking "does it let you implement anything you couldn't before?" and I list an example where yes, you can implement something you couldn't before
11:18:53 <glaebhoerl> but misunderstanding what I meant by "implement", because clearly the first example is the same thing "in some sense" (you tell me what sense -- it's hard to find really clear words) and it works, it's just less precise
11:19:58 <merijn> glaebhoerl: I have an example that uses this stuff to implement something you couldn't before
11:20:14 <merijn> Although it'll take until the new exhaustiveness check is in GHC to make it truly work as intended
11:21:44 <merijn> glaebhoerl: I wanted a record type whose fields dependend on it's type, which, unfortunately, isn't possible. However I kinda fake it now by having a function taking a GADT and limiting which options the function has to implement http://lpaste.net/111788
11:22:29 <jonsterling> merijn: I may be misunderstanding you, but you can indeed have a record type whose fields depend on its type
11:22:35 <glaebhoerl> let's suppose you had one type system with good support for RankNTypes and ImpredicativeTypes (something like MLF), and another type system with good support for LiquidHaskell-style refinement types, DataKinds, and GADTs.
11:22:52 <glaebhoerl> how would you describe their relative strengths in a clear and concise way, without referring to the specific features?
11:22:53 <jonsterling> merijn: Just put equality constraints in the fields.
11:23:02 <Denommus> which GUI toolkit do you recommend me to use?
11:23:05 <glaebhoerl> I might say that one is more "expressive" and the other is better at "theorem proving"
11:23:11 <glaebhoerl> but I'm not really satisfied with this vocabulary
11:23:32 <merijn> jonsterling: No, I mean the *number* of fields differs dependent on it's types
11:23:36 <merijn> jonsterling: Not just their types
11:23:57 <merijn> jonsterling: i.e. indexed records
11:24:08 <jonsterling> merijn: Oh... You mean like making a flat extensible record rather than a recursive one...
11:24:16 <merijn> jonsterling: Yes
11:24:21 <merijn> jonsterling: recursive one has overhead
11:24:26 <merijn> You need to walk the list
11:24:37 <jonsterling> merijn: I yes, I have been trying to find a way to do this for a long time to no avail.
11:28:12 <stulli> what does a ? mean in this context:     initState :: (?backendPermanent :: bp) => BackendPermanentM bp ()
11:28:46 <stulli> i only extensions are FlexibleContexts and RankNTypes
11:28:48 <mauke> oh god, implicit parameters
11:29:12 <stulli> mauke: i thought you would need to add an language extension to use them?
11:29:16 <mauke> :t [?hello]
11:29:17 <lambdabot> (?hello::t) => [t]
11:30:41 <aranea> If I have to manipulate directory contents, I almost always define "getDirectoryContents' dir = map (dir </>) <$> getDirectoryContents dir". Why isn't that in the library?
11:31:43 <geekosaur> possibly it should be. the library gives you what the API does
11:31:50 <geekosaur> a directory has filenames in it
11:31:54 <geekosaur> not pathnames
11:34:03 <aranea> geekosaur: Yes, I know the posix api. But you can't do anything with those filenames.
11:34:14 <aranea> I'll propose it.
11:34:53 <Angry> :t </>
11:34:55 <lambdabot> parse error on input ‘</>’
11:35:01 <Angry> what is that?
11:35:32 <geekosaur> @index (</>)
11:35:32 <lambdabot> Text.Html
11:35:37 <geekosaur> wrong one
11:36:28 <mihaineacsu> Hi everyone! Does anyone here have some experience with EclipseFP?
11:36:38 <Hijiri> It just inserts the proper directory separator
11:36:54 <Hijiri> in posix/unix it's a forward slash, but on windows it can be a backwards slash
11:36:58 <geekosaur> http://www.haskell.org/platform/doc/2014.2.0.0/ghc/libraries/filepath-1.3.0.2/System-FilePath-Posix.html#v:-60--47--62-
11:37:04 <geekosaur> sorry for delay
11:37:35 <Angry> thanks, you just stomped a bug on something I'm working on before I knew I had it.
11:37:39 <WilliamDhalgren> hi! I'm considering biting the bullet and compiling ghc 7.8 for arm myself. reason is hoping to get template haskell support working on a debian system. doesn't seem to with 7.6 binaries, and apparently they won't have arm 7.8 binaries any time soon.
11:38:10 <WilliamDhalgren> just thought to preliminary ask if ppl here had some experiences in doing so before digging about the procedure too far - for eg would it be better to use the source for the 7.8 deb src package or using an ghchq official tarball; whether to crosscompile from an x86 machine (if that's doable) or compile on the system etc
11:38:59 <aranea> Angry: Even though I exclusively work on unix systems, I always use </>. It's just nicer than "++ '/' ++"
11:39:25 <Twey> Except when: "foo" </> "bar" </> "baz"  vs.  "foo/bar/baz"
11:39:32 <Twey> But a necessary evil, I guess.
11:39:40 <Hijiri> I have 7.6.x on debian testing and I have TH support
11:39:54 <Hijiri> does 7.8 have new interesting features?
11:39:59 <WilliamDhalgren> Hijiri: on arm though?
11:40:07 <Hijiri> oh, sorry, didn't see that part
11:40:16 <waxjar> can ghc compile a program without leaving *.o and *.hi files behind?
11:40:49 <simukis_> `ghc make Something && rm *.{o,hi}`?
11:40:58 <simukis_> these files are useful, though.
11:41:12 <WilliamDhalgren> Hijiri: right, well its got fun typesystem features sure, but mostly because it was said to have better arm support - and specifically ghci and th working - that I'd want to go through that hassle
11:41:21 <kadoban> waxjar: Use 'runhaskell' or 'runghc' ?
11:41:46 <waxjar> even better! thanks :)
11:41:56 <simukis_> kadoban: these won’t compile, though.
11:42:40 <waxjar> that's alright, i'm just playing around a little.
11:43:06 <kadoban> simukis_: Yeah, I made some assumptions about what he was trying to do...if he didn't want the .o and .hwhatever, it seemed like maybe that :)
11:50:59 <sagittarian> @hoogle sortBy
11:51:01 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
11:51:01 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
11:51:01 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
11:51:17 <sagittarian> @src sortBy
11:51:17 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:51:40 <sagittarian> > 1 + 1
11:51:42 <lambdabot>  2
11:51:57 <sagittarian> is everything alright, lambdabot?
11:53:49 <Logiar> Fuuzetsu: Thank you very much for the help you've given me today :)
11:55:01 <Fuuzetsu> np
11:55:15 <sagittarian> waita sec
11:55:15 <sagittarian> :t insertBy
11:55:17 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> [a]
11:56:14 <Fuuzetsu> WilliamDhalgren: Asking in #ghc and posting on ghc-dev is probably worthwhile
11:56:52 <geekosaur> lambdabot has been slow of late
11:56:52 <sagittarian> @src insertBy
11:56:53 <lambdabot> insertBy _   x [] = [x]
11:56:53 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
11:56:53 <lambdabot>                                  GT -> y : insertBy cmp x ys'
11:56:53 <lambdabot>                                  _  -> x : ys
11:56:54 <Fuuzetsu> I believe there are some pages on ARM on the GHC wiki
11:56:54 <WilliamDhalgren> ahh  thx Fuuzetsu , didn't even know of #ghc
11:57:22 <sagittarian> wait, so sortBy is O(n^2)?
11:57:25 <sagittarian> srsly?!?
11:57:37 <mauke> sagittarian: don't believe everything you read
11:57:37 <sagittarian> using insertion sort?
11:57:40 <Angry> How do I get the correct </> to use for the system? I don't see a way to have ghc decide between System.FilePath.Windows and System.FilePath.Posix
11:57:52 <mauke> Angry: don't you just import System.FilePath?
11:57:59 <sagittarian> @src sort
11:57:59 <lambdabot> sort = sortBy compare
11:58:06 <Fuuzetsu> Angry: you import System.FilePath which exports the right module based on the OS
11:58:49 <Fuuzetsu> sagittarian: @src doesn't print actual sources
11:59:12 <godel> Fuuzetsu: what does it print?
11:59:13 <Fuuzetsu> it is pointless to use it if you're looking for actual implementations and not for some implementation that produces the same result
11:59:33 <Fuuzetsu> godel: it looks up a code snippet from a large file created just for this purpose
11:59:43 <sagittarian> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#sortBy
12:00:17 <sagittarian> i guess it's a good point, it's not so straightforward to sort a linked list (as opposed to an array) in subquadratic time
12:00:40 <sagittarian> but i would think that (unless i misunderstand how difficult it is) the ghc library functions could get it right
12:01:05 <Hijiri> it looks like the n^2 sortBy is only used if USE_REPORT_PRELUDE is defined
12:01:23 <sagittarian> btw how do i get the file that lambdabot uses for @src?
12:01:36 <Fuuzetsu> it's uh, somewhere
12:01:57 <kadoban> Doesn't merge-sort do O(n lg n) sort pretty trivially on linked lists?
12:02:04 <Fuuzetsu> http://hackage.haskell.org/package/lambdabot-4.2.1/src/State/source
12:02:08 <LtRipley> hi
12:02:32 <Fuuzetsu> http://hackage.haskell.org/package/lambdabot-4.3.0.1/src/State/source more recent
12:02:39 <sagittarian> hi LtRipley
12:03:58 <godel> @src (==)
12:03:58 <lambdabot> x == y = not (x /= y)
12:04:01 <godel> @src (/=)
12:04:01 <lambdabot> x /= y = not (x == y)
12:04:03 <godel> hahaha
12:04:40 <sagittarian> :t sortBy (\(a, b, c) -> b)
12:04:41 <lambdabot>     Occurs check: cannot construct the infinite type:
12:04:41 <lambdabot>       t1 ~ (t, t1, t2) -> Ordering
12:04:42 <lambdabot>     Relevant bindings include
12:04:46 <pjdelport> godel: Those are just the default implementations of the type class, so you only have to implement one of the two.
12:04:48 <Fuuzetsu> nothing strange about that considering you have to implement one or the other (or both) for Eq
12:04:54 <sagittarian> oh oops
12:05:30 <mauke> :t sortBy (comparing (\(a, b, c) -> b))
12:05:31 <pjdelport> :t sortBy (comparing $ \(a, b, c) -> b)
12:05:31 <lambdabot> Ord a => [(t, a, t1)] -> [(t, a, t1)]
12:05:32 <lambdabot> Ord a => [(t, a, t1)] -> [(t, a, t1)]
12:05:52 <pjdelport> @quote majestic stereo
12:05:53 <lambdabot> No quotes for this person. There are some things that I just don't know.
12:06:14 <pjdelport> well then
12:06:35 <sagittarian> @pl \f -> sortBy (comparing f)
12:06:36 <lambdabot> sortBy . comparing
12:06:42 <mauke> :t sortBy (comparing (^. _2))
12:06:44 <lambdabot> (Field2 a a a1 a1, Ord a1) => [a] -> [a]
12:07:04 <pinterest_mom> hey i need help with http://lpaste.net/112329
12:07:14 <pinterest_mom> just testing out random functions
12:07:22 <pinterest_mom> but it won't load the file into ghci
12:07:58 <sagittarian> @src comparing
12:07:58 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:08:09 <pinterest_mom> it seems like it doesn't find the instance declaration
12:08:10 <sagittarian> where is comparing defined?
12:08:14 <sagittarian> @hoogle comparing
12:08:16 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:08:16 <pinterest_mom> even though i did import System.Random
12:08:33 <mauke> pinterest_mom: what instance declaration?
12:08:50 <pinterest_mom> oh nvm
12:09:11 <mauke> pinterest_mom: what happens if you remove the type signature?
12:09:44 <pinterest_mom> still doesnt work
12:09:44 <sagittarian> @src groupBy
12:09:45 <lambdabot> groupBy _  []     =  []
12:09:45 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
12:09:46 <lambdabot>     where (ys,zs) = span (eq x) xs
12:09:49 <pinterest_mom> but i get a different error message
12:09:50 <pinterest_mom> let me paste it
12:09:59 <sagittarian> @src span
12:09:59 <lambdabot> span _ xs@[]                  = (xs, xs)
12:10:00 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
12:10:00 <lambdabot>                   | otherwise = ([],xs)
12:10:21 <pinterest_mom> i added an annotation to the paste
12:11:02 <Fuuzetsu> sagittarian: please use /query if you're going to use lambdabot heavily
12:11:18 * hackagebot ekg-log 0.1.0.1 - Push metrics to a log file.  http://hackage.haskell.org/package/ekg-log-0.1.0.1 (ParnellSpringmeyer)
12:11:34 * mauke is puzzled
12:11:51 <pinterest_mom> does it work for you?
12:12:11 <mauke> no, I don't have ghc
12:12:49 <Fuuzetsu> not having a GHC might be a problem
12:12:57 <pinterest_mom> oh wait
12:13:02 <pinterest_mom> i got it
12:13:06 <mauke> what is it?
12:13:11 <pinterest_mom> i had -XNoMonomorphismRestriction
12:13:13 <pinterest_mom> in my .ghci
12:13:33 <pinterest_mom> removed it and it works
12:13:38 <Fuuzetsu> monores'd
12:13:52 <mauke> ooh
12:14:12 <mauke> ok, that might make sense
12:14:14 <pinterest_mom> so i guess it was too polymorphic
12:14:30 <pinterest_mom> how would i have to update that code if i wanted it to work with xnomonomorphismrestriction
12:14:39 <mauke> what if you rewrite to: case random gen of (value, newGen) -> value : randoms' newGen
12:14:46 <pinterest_mom> probably add :: StdGen somewhere
12:15:11 <pinterest_mom> let me check
12:15:22 <asfp> If I have     class T a where { data Foo :: * },  how can I create type aliases using Foo, something like type MaybeFoo = Maybe Foo?
12:16:33 <pinterest_mom> mauke: yeah if i rewrite it like that it works
12:16:45 <pinterest_mom> not exactly sure why though
12:17:01 <pinterest_mom> i'm getting back into haskell but i forgot the intricacies of the monomorphism restriction
12:17:01 <mauke> 'let' polymorphicalizes bindings
12:17:20 <pinterest_mom> oh and case monomorphisez them?
12:17:23 <mauke> yes
12:17:34 <pinterest_mom> ahh i see, thx for your help
12:23:12 <zipper> OMFG I was looking for the `for element in list` function equivalent in haskell and after really searching I figured that it's just map.
12:23:24 <zipper> The haskell one is so much more consice.
12:24:03 <mauke> there's also forM_
12:24:06 <mauke> :t forM_
12:24:07 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
12:24:11 <RchrdB> zipper: list comprehensions are available too, if you prefer that form. :)
12:24:37 <mauke> forM_ [1 .. 10] $ \i -> do print i  -- for that imperative feeling
12:24:58 <Fuuzetsu> does ‘forM_ [1 .. 10] print’ no longer feel imperative?
12:25:04 <BeardedCoder> zipper: stop now or you will be sad at your day job. =)
12:26:10 <zipper> BeardedCoder: lol
12:26:16 <LtRipley> i think "concise" is a bad word
12:26:30 <kaol> I'd think that foldr is more akin to a for loop. Unless it actually involves building a new list.
12:26:30 <zipper> LtRipley: Which is the right word?
12:27:09 <LtRipley> zipper: i don't know, in my day job i hear the word mostly by people that defend unreadable code
12:27:26 <zipper> Looking for a functor a -> a but not sure what to hoogle
12:27:40 <Fuuzetsu> :t Identity
12:27:41 <lambdabot> a -> Identity a
12:27:57 <Fuuzetsu> no idea what you're looking for ;P
12:28:15 <Fuuzetsu> :t Endo
12:28:16 <lambdabot> (a -> a) -> Endo a
12:28:33 <zipper> I like want to get the x out of a Just x but with a type I defined myself.
12:28:46 <Fuuzetsu> sorry, Endo is the wrong thing here I think
12:28:58 <Fuuzetsu> zipper: fmap?
12:29:05 <zipper> I don't want to pattern match.
12:29:15 <Fuuzetsu> :t maybe
12:29:15 <zipper> Fmap won't unwrap it
12:29:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:29:18 <Bor0> zipper, Monad?
12:29:19 <stef1a> given that i know where a function is documented, how can i determine where it's defined? (e.g. if something is documented in Prelude)
12:29:42 <Fuuzetsu> also
12:29:42 <Bor0> > (Just 3) >>= return . (+1)
12:29:43 <lambdabot>  Just 4
12:29:44 <Fuuzetsu> :t fromMaybe
12:29:45 <lambdabot> a -> Maybe a -> a
12:29:51 <zipper> I don't know I forgot a lot of haskell :( I know there was something.
12:29:57 <bergmark> stef1a: :i in ghci
12:30:01 <Bor0> @src fromMaybe
12:30:01 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
12:30:06 <zipper> Well this is not a maybe but it's a functor or so I think.
12:30:15 <zipper> It's an algebraic type that's for sure.
12:30:15 <stef1a> bergmark: thanks! that's great.
12:30:19 <Fuuzetsu> no functor will unwrap it
12:30:24 <Bor0> > fmap (+1) (Just 3)
12:30:26 <lambdabot>  Just 4
12:30:27 <Fuuzetsu> Functor gives you fmap
12:30:28 <Fuuzetsu> that's it
12:30:40 <zipper> Bor0: Will it work if I haven't written a monad instance for it?
12:30:57 <Bor0> it should, but you should have a Functor instance I think
12:31:12 <zipper> I want something like a Just 3 that gives me 3
12:31:13 <Fuuzetsu> zipper: you should clearly state what you want to do…
12:31:14 <Bor0> (for fmap, that is)
12:31:18 <Fuuzetsu> :t fromJust
12:31:20 <lambdabot> Maybe a -> a
12:31:27 <Fuuzetsu> also known as ‘the thing you shouldn't use’
12:32:50 <Fuuzetsu> I wonder if people would use the partial functions less if they all started with unsafe*
12:32:54 <Bor0> you can convert Just (Just (Just ...))) to Just x, but not unwrap it any further
12:33:09 <Bor0> > join (Just (Just 3))
12:33:11 <lambdabot>  Just 3
12:33:43 <Fuuzetsu> Bor0: not quite correct is it, you can flatten (Maybe (Maybe a)) to (Maybe a), not an arbitrarily nested amount
12:33:54 <Fuuzetsu> of course you can re-apply join multiple times…
12:34:03 <mauke> an arbitrary amount, even!
12:34:14 <Bor0> Fuuzetsu, so why not an arbitrarily nested amount if we can apply join multiple times?
12:34:21 <dv-> > fromMaybe 0 (Just 3)
12:34:23 <lambdabot>  3
12:34:33 <asfp> how can I provide a default when using type families.  for example  'class C a where { data D :: *; ?? data D = DefaultD; ?? }'  ?
12:34:43 <Fuuzetsu> because there is no function that will apply join the right amount of times based on the type
12:35:19 <mauke> Fuuzetsu: we don't need such a function
12:35:22 <mauke> we have programmers
12:35:39 <Fuuzetsu> mauke: yes, just pointing out lack of precision in what Bor0 said
12:36:03 <mauke> ?
12:36:23 <mauke> your reply is just as imprecise
12:36:29 <Fuuzetsu> ok
12:36:32 <Fuuzetsu> let's drop it at that
12:36:33 <Bor0> well, I didn't say such function existed. I just said that you can convert (m (m (m ...))) in general to (m ...)
12:36:35 <Fuuzetsu> seems to small to aurge over
12:36:40 <Fuuzetsu> argue*
12:36:49 <zipper> I am trying to get a MaybeLogMessage -> LogMessage in http://sprunge.us/HKgV
12:36:53 <zipper> Fuuzetsu: ^^
12:37:01 <zipper> Bor0:                      ^^
12:37:05 <Bor0> what I said means that you can have 5 wrapped instances, or 10, or 100 :)
12:37:18 <zipper> It's from http://www.seas.upenn.edu/~cis194/lectures.html
12:37:19 <Fuuzetsu> zipper: there is no such function that is not partial
12:37:37 <zipper> Fuuzetsu: What?
12:37:49 <zipper> So you're telling me to pattern match it?
12:37:49 <meoblast001> hi. in cabal i have exposed-modules: Data.Mesh3D.MD2, and i have Data/Mesh3D/MD2.hs... i compile and i get 'can't find source for Data/Mesh3D/MD2 in src'
12:37:58 <meoblast001> should this be happening?
12:38:03 <Fuuzetsu> zipper: that's part of it, still doesn't give you the right type in a safe manner
12:38:06 <meoblast001> of course the answer is yes but why is it happening
12:38:10 <Fuuzetsu> unless you have a default value
12:38:33 <mauke> zipper: you don't need such a function
12:38:43 <zipper> Fuuzetsu: I don't need safety. I am pattern matching. I want something like fromMaybe the same way fromMaybe has no safety
12:38:49 <zipper> mauke: What do I need?
12:38:55 <Fuuzetsu> zipper: fromMaybe is safe
12:38:58 <Fuuzetsu> :t fromMaybe
12:39:00 <lambdabot> a -> Maybe a -> a
12:39:06 <Fuuzetsu> > fromMaybe 1 Nothing
12:39:08 <lambdabot>  1
12:39:12 <mauke> zipper: validMessagesOnly :: [MaybeLogMessage] -> [LogMessage]
12:39:20 <hexagoxel> meoblast001: what is the hs-source-dirs? if it is 'src', is your Data dir inside src/ ?
12:39:30 <mauke> at least that's what exercise 2 says
12:39:38 <meoblast001> hexagoxel: 'src/' and yes
12:39:39 <zipper> mauke: Yes that's the one I'm writing
12:39:46 <meoblast001> well, 'src', not 'src/'
12:40:06 <Fuuzetsu> zipper: then who said you need MaybeLogMessage -> LogMessage ? That's not what the type mauke gave says
12:40:23 <mauke> even if you had such a function, I'm not sure how that would help you
12:40:25 <zipper> mauke: This is what I have --> http://sprunge.us/BDBE
12:40:27 <Fuuzetsu> > [ x | Just x <- [Nothing, Just 2, Nothing, Just 4, Just 5 ]]
12:40:29 <zipper> Fuuzetsu: ^^
12:40:29 <lambdabot>  [2,4,5]
12:40:46 <mauke> zipper: that looks almost correct
12:40:56 <mauke> the last line needs two changes
12:41:11 <zipper> mauke: but it lacks one function from a MaybeLogMessage to a LogMessage to work on x
12:41:13 <Fuuzetsu> mauke: two?
12:41:14 <mauke> no
12:41:20 <mauke> zipper: just use pattern matching
12:41:24 <mauke> I mean, you're already in a case/of
12:41:28 <Fuuzetsu> mauke: he could shadow ;P
12:41:34 <mauke> pfft
12:41:35 <zipper> mauke: Can I pattern match in a case?
12:41:44 <mauke> ... that's the only thing you can do in 'case'
12:41:47 <Bor0> @src fromMaybe
12:41:48 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
12:41:49 <mauke> I mean, that's what 'case' is for
12:42:19 <zipper> mauke: Wait I think I know what you mean.
12:42:20 <stef1a> i have a datatype that takes three args, xs, ys, and deg. i want xs and ys to be of the same (variable) type. how can i specify this in the type declaration?
12:42:23 <zipper> brb
12:42:37 <mauke> stef1a: have it only take two args
12:42:53 <Fuuzetsu> stefan_1: T a b = MkT a a b
12:42:57 <Fuuzetsu> stef1a: ^
12:44:18 <zipper> mauke: Fuuzetsu Heh pattern matching it was easier than I expected http://sprunge.us/FADa
12:44:28 <Fuuzetsu> good
12:44:36 <stef1a> Fuuzetsu and mauke: thanks!
12:44:39 <mauke> yay
12:44:48 <Fuuzetsu> you can use the list comprehension form I posted earlier if that's what you're into ;)
12:45:04 <hexagoxel> meoblast001: that should work, and i don't spot the mistake, assuming that you made one :p
12:45:29 <mauke> you could also write MaybeLogMessage -> Maybe LogMessage, then apply catMaybes
12:45:44 <zipper> I don't know why I thought pattern matching was so hard.
12:46:04 <zipper> Fuuzetsu: I didn't see it.
12:46:20 * hackagebot ekg-log 0.1.0.2 - Push metrics to a log file.  http://hackage.haskell.org/package/ekg-log-0.1.0.2 (ParnellSpringmeyer)
12:46:28 <Fuuzetsu> validMessagesOnly xs = [ x | ValidLM x <- xs ]
12:46:51 <Fuuzetsu> I don't use this form much myself
12:47:27 <meoblast001> hexagoxel: sorry.. turns out my text editor blows
12:47:27 <zipper> Fuuzetsu: Jesus. I haven't seen mattern matching like that since...
12:47:54 <geekosaur> it's just a list comp
12:48:12 <zipper> Fuuzetsu: Your solution is so... so the result of the comprehension will be x?
12:48:32 <zipper> Fuuzetsu: What if it gets an empty list?
12:48:33 <Fuuzetsu> no, it will be a list of things that were bound to x inside the comprehension
12:48:41 <Fuuzetsu> then nothing, it ends up as empty list
12:48:55 <mauke> > [ "hello" | x <- [] ]
12:48:56 <lambdabot>  []
12:49:09 <mauke> > [ "hello" | x <- [1,2,3] ]
12:49:10 <lambdabot>  ["hello","hello","hello"]
12:49:11 <Fuuzetsu> here it just works as filter with use of a pattern instead of explicit function
12:49:16 <zipper> Fuuzetsu: I need to read on list comprehensions. I haven't touched them since when I was writing python
12:49:27 <Fuuzetsu> ew, Python comprehensions
12:49:32 <mauke> > [ x*2 | x <- [1,2,3] ]
12:49:33 <lambdabot>  [2,4,6]
12:50:06 <josephle> [ y | x <- xs ] would be [ y for x in xs ]. But python syntax gets ambiguous once you start nesting your comprehensions...
12:50:39 <zipper> Fuuzetsu: lol yeah
12:50:46 <Fuuzetsu> josephle: and you can't do nice filters
12:51:17 <zipper> I meant since when I was learning python. It doesn't really matter. Just felt that I needed to correct that.
12:51:22 <josephle> Fuuzetsu: well you can filter, but it won't be nice :P
12:51:40 <Fuuzetsu> hence ‘nice filters’
12:51:40 <josephle> [ y for x in xs if p y ] # Yuck!
12:51:51 <Fuuzetsu> josephle: and now 3 levels deep ;P
12:51:59 <zipper> josephle: I don't see where y comes in.
12:52:12 <Fuuzetsu> that should be x
12:52:15 <josephle> oops... [ y for x in xs if p(x) ] # Yuck!
12:52:21 <josephle> zipper, you're right
12:52:29 <Fuuzetsu> [ x for x in xs ]
12:52:37 <Fuuzetsu> who thought this was a good idea
12:53:04 <mauke> people who think punctuation is scary
12:53:07 <Fuuzetsu> afaik the official style guide even tells you to use these instead of map and reduce
12:54:10 <n4x> wasn't Guido like "functional programming sucks"?
12:54:22 <mauke> more like "what's a functional??"
12:54:39 <Fuuzetsu> isn't he like ‘I DON'T LIKE THING’ for everything that is getting removed?
12:55:02 <josephle> lambdas managed to survive, surprisingly
12:55:03 <n4x> mauke: functional programming is a weird thing only used by weird guys with PhDs
12:55:17 <Fuuzetsu> josephle: just barely I believe
12:55:24 <josephle> even though the implementation of lambdas in python is pretty icky
12:55:33 <Fuuzetsu> Python lambda sucks
12:55:38 <vanila> n4x, Guido doesn't even do tail call optimization
12:55:48 <mauke> heh
12:55:49 <Fuuzetsu> by design WONTFIX
12:55:52 <mauke> /usr/bin/guido
12:55:58 <n4x> vanila: that is how I "learned" he didn't like FP :P
12:56:12 <vanila> it's bizarre, it would improve the language and yet there's some opposition to it
12:56:23 <n4x> I made a little tail-recursive function and well, it didn't work well
12:56:28 <mauke> https://twitter.com/gvanrossum/status/1838308947
12:56:41 <Fuuzetsu> isn't the opposition ‘it's hard ;(((’
12:56:51 <kadoban> mauke: Hah
12:56:58 <mauke> the usual counterargument is that it breaks stack traces
12:57:10 <Fuuzetsu> so what I said
12:57:25 <Fuuzetsu> maybe I *want* broken stack traces!
12:57:38 <mauke> maybe you should've used perl then :-)
12:57:38 <n4x> but then you are using a loop...
12:57:55 <mauke> (perl still doesn't to automatic TCO but there's an operator for it)
12:58:02 <Fuuzetsu> …operator for TCO?
12:58:05 <mauke> yeah
12:58:14 <Fuuzetsu> that's uh
12:58:14 <kadoban> There's a special operator? Weird
12:58:16 <Fuuzetsu> on way to do it
12:58:20 <Fuuzetsu> one*
12:58:46 <mauke> goto &myfunc;
12:59:02 <Fuuzetsu> hue
13:01:40 <notdan> mauke: this is hilarious! (re: guido's twitter)
13:01:51 <notdan> Also: http://funcall.blogspot.nl/2011/03/tail-recursion-and-debugging.html
13:02:52 <kadoban> notdan: Nice
13:02:57 <Fuuzetsu> notdan: golden
13:02:59 <monochrom> IMO people should adjust their idea and expectation of "stack trace" to accomodate for TCO.
13:03:46 <monochrom> it's really time to move on and learn how to debug efficient programs
13:04:37 <n4x> what is an efficient program in Python? a script that basically calls the C code that does everything?
13:04:46 <monochrom> heh
13:04:54 <Fuuzetsu> >You're using a Java servlet stack trace to argue with a strawman that Python should have TCE? Not only wrong target, but that's a design flaw of the servlet spec, it should be an array of filters to loop over, not a chain. The best way to eliminate tail calls is by eliminating recursion. Recursion is a crutch for mathematicians who can't be bothered to learn how to program a real computer.
13:05:19 <vanila> n4x, asI've heard there is a very cool python copiler
13:05:37 <vanila> which compiles the code as it executes it
13:05:46 <n4x> vanila: PyPy? :P
13:05:49 <vanila> yeah
13:05:53 <vanila> I thought that was interesting
13:06:07 <monochrom> one might answer that by "python is a crutch for scripters who can't be bothered to write asm"
13:06:08 <vanila> apparently you need a different approach if you wanted to do the same for haskell though
13:06:12 <josephle> Fuuzetsu: by that guy's reasoning, we should eliminate loops and just have jumps/gotos :P
13:06:27 <Fuuzetsu> start giving out magnetic needles in local schools
13:14:18 <asfp> if I have  class A a => B a ...   and class A a => C a ...   then a type  (B b, C c) => f b c, how can I say that I want the instances for A b and A c to be the same?  I'm getting "cannot deduce blah..." from ghc.
13:14:47 <mauke> (B b, C b) => f b b
13:17:32 <asfp> mauke: right.  actually what I want to say is that the type families(?) in the b and c instances are the same.  so I have class A where { type X :: * } and I want to say that the Xes are the same.
13:37:24 <Javran> is there a value of type "forall a b, (a,b) -> Either a b" ?
13:38:14 <Javran> :t Left . fst
13:38:15 <lambdabot> (b, b2) -> Either b b1
13:38:16 <benzrf> Javran: there are 2
13:38:21 <simpson> Javran: There are two, in fact: f (a, _) = Left a; and f (_, b) = Right b
13:38:55 <Javran> benzrf: simpson: I see, thanks!
13:39:20 <benzrf> @djinn (a, b) -> Either a
13:39:21 <lambdabot> Error: kind error: (KVar 2,KStar)
13:39:21 <benzrf> @djinn (a, b) -> Either a b
13:39:22 <lambdabot> f (a, _) = Left a
13:40:13 <trap_exit> where can I read about how to debug haskell code? since the problem is that (1) we don't have stack frames and (2) I may create a thunk that has an error, but the error doesn't pop up until I need the value -- and at that time, we no longer have the stack frames
13:41:00 <Javran> but the other way around isn't true, i.e. Either a b -> (a,b) doesn't exist?
13:41:11 <joelteon> trap_exit: force it earlier
13:41:20 <joelteon> build with profiling, prof-all, auto-all, caf-all, +RTS -xc
13:41:21 <trap_exit> ... so use ! everywhere?
13:41:24 <joelteon> no
13:41:26 <Clint> Javran: what would Left 2 become?
13:41:30 <joelteon> then you get stack traces
13:41:47 <ReinH> trap_exit: tie the evaluation of the thing that might error with the place you expect the error
13:42:10 <ReinH> So using strictness in a targeted way to enforce an invariant
13:42:17 <ReinH> "if this is evaluated then this is also evaluated"
13:42:20 <Javran> Clint: yeah I can fill in the `snd` part.
13:42:21 <Fuuzetsu> trap_exit: Debug.Trace
13:42:33 <trap_exit> hmmm
13:42:36 <Javran> Clint: /can/cant/
13:42:38 <trap_exit> Debug.Trace .. . I wonder if it also works in Haste
13:43:01 <ReinH> Heinrich calls this "strictness invariants" (go figure): http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
13:43:03 <ReinH> er sorry
13:43:05 <ReinH> space invariants
13:43:11 <ReinH> but the idea can be used for other things as well
13:51:23 * hackagebot hailgun 0.1.1.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.1.1.0 (RobertMassaioli)
13:51:48 <aranea> I'd like to propose that (<<) = flip (>>) be added to Control.Monad. What do you think, and where can I do so?
13:52:32 <geekosaur> aranea: there are two possible semantics
13:52:41 <geekosaur> they've been fighting it out for years
13:52:56 <geekosaur> propose all you want, to start round N+1 of the ongoing argument
13:53:02 <aranea> Oh, I didn't know that.
13:53:07 <napping> Two?
13:53:27 <aranea> How do those semantics differ from each other?
13:54:11 <aranea> flip (>>) works fine for me.
13:54:24 <napping> the only reasonable things meeting m a -> m b -> m a are flip (>>) and (<*)
13:54:27 <napping> and we already have (<*)
13:55:08 <geekosaur> napping, that's exactly it
13:55:10 <ReinH> aranea: Ordering of effects
13:55:27 <aranea> I see.
13:55:28 <geekosaur> we have (<*) but until the AMP goes in, not all monads support it
13:55:35 <napping> why in the world would anyone want << for <*, when =<< is already right-to-left
13:55:41 <aranea> But I don't see why that's a problem.
13:56:04 * geekosaur is still multiplexing with company meeting
13:56:18 <aranea> Some people want (<<) = (<*)?
13:56:21 <ReinH> aranea: it isn't a technical problem
13:56:25 <geekosaur> I don't have a horse in the race, just know it's an ongoing fight
13:56:26 <geekosaur> and yes
13:56:27 <napping> No proposal for base would go in before 7.10,
13:57:04 <geekosaur> it's a political issue, it's been ongoing, from my point of view it's an annoying argument and sometimes I want to stuff a sock into both sides' mouths :p
13:57:43 <benmachine> I think (<<) = (<*) is a profoundly bad idea
13:57:46 <aranea> It's just that I'm used to working from right to left with (.), so I try to do the same for monads.
13:57:51 <aranea> benmachine: So do I.
13:58:02 <mauke> benmachine: I think it's a great idea
13:58:06 <mauke> (balance restored)
13:58:07 <aranea> It wouldn't work for me.
13:58:08 <napping> I've never seen anyone actually argue for it
13:58:17 <benmachine> yeah I'm not sure such people exist
13:58:20 <benmachine> I'm not sure mauke exists
13:58:28 <aranea> mauke: Why?
13:58:32 <mauke> I've defined (<<) like that before Applicative existed (or at least before I knew about it)
13:58:32 <napping> I mean like actually advance any coherent argument for it
13:58:41 <aranea> We already have (<*) for those semantics, after all.
13:58:51 <mauke> and we already have *> for >>
13:58:53 <mauke> I propose dropping >>
13:59:03 <benmachine> the main reason for my opinion is that << should match =<<
13:59:18 <mauke> << should match <* because >> matches *>
13:59:32 <mauke> and also because it looks cool in monadic parsers
13:59:37 <benmachine> mauke: a reasonable point
13:59:40 <aranea> mauke: But that would leave you unable to write right-to-left.
13:59:45 <mauke> good
13:59:46 <benmachine> I think my real opinion is that << should not exist at all
13:59:54 <mauke> why would I write my parsers right to left?
14:00:22 <mauke> expr = ... <|> char '(' >> expr << char ')'
14:00:59 <aranea> mauke: I write my parsers left-to-right. But when I'm not parsing, but composing monadic functions in other contexts, it seems more intuitive to write right-to-left.
14:01:16 <mauke> isn't composing monadic functions done with >=>?
14:01:31 <benmachine> aranea: could you give an example of such a context?
14:01:48 <napping> Hmm, I suppose you really want a flip (*>)
14:04:05 <seanhess> I can't get cabal sandbox add-source to work. I have a fork of a package in a folder. I ran cabal sandbox add-source path/to/folder. The patched version seems to show up in cabal list. But when I run cabal install it keeps trying to install the version on hackage. Help?
14:05:10 <aranea> benmachine: I don't have a good example right now. I'd grep my projects for (<<), but most of them aren't on this box.
14:05:25 <benmachine> aranea: I'm a big fan of examples
14:05:31 <aranea> So am I.
14:06:16 <benmachine> it upsets me that some things get through the library proposal process without a single line of library/application code being involved in the discussion
14:06:24 * hackagebot diagrams-lib 1.2.0.4 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.4 (bergey)
14:06:26 * hackagebot hlint 1.9.8 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.8 (NeilMitchell)
14:06:28 * hackagebot diagrams-cairo 1.2.0.3 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.3 (bergey)
14:07:00 <benmachine> well, it's fair to say that it upsets me when things that I don't want to get in get in, and then I try to come up with a reason why the process was invalid because that's the only way I could possibly have not got what I wanted :P
14:07:40 <ReinH> napping: are (>>) and (*>) expected to be equivalent under the AMP?
14:08:28 <ReinH> I realize that the Applicative can have either ordering, but iinm it's expected that the ordering will coincide with the Monad instance under the AMP?
14:08:40 <napping> Well, I don't actually have the documentation, but I would assume so
14:09:01 <napping> any laws relating monad and applicative operations would probably imply that, no?
14:09:28 <napping> I'd exepect at least <*> = liftM2 ($) or something
14:09:45 <floresiensis> I am using getElems to fold an IOArray, which works but seems like brute force. foldM is no good because it has type [a]. Is there a nice way to fold an IOArray without resorting to getElems?
14:10:25 <aranea> benmachine: I only have one bad example: Right now, I've got 10 lines of right-to-left composition with (=<<). But among them, there's one where I have to to it left-to-right. The relevant part is "hPutStrLn stderr str >> exitFailure"
14:11:14 <Ralith> what's the streaming IO library du jour?
14:11:16 <aranea> I'd rather write "exitFailure << hPutStrLn stderr str" because it seems counterinituitive to have ten lines of RTL code and one LTR:
14:11:21 <Ralith> carter?
14:11:24 * hackagebot hexpat 0.20.7 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.7 (StephenBlackheath)
14:11:26 * hackagebot diagrams-rasterific 0.1.0.3 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.3 (bergey)
14:11:28 * hackagebot diagrams-canvas 0.3.0.1 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.3.0.1 (bergey)
14:11:29 <carter> Ralith: whats?
14:11:30 * hackagebot reroute 0.2.0.0 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.0.0 (AlexanderThiemann)
14:11:43 <Ralith> carter: do you happen to know what the streaming IO library du jour is
14:11:43 <ReinH> napping: Well, the applicative ordering isn't implied by any current laws, but I'm not sure what the AMP adds
14:12:02 <ReinH> Ralith: conduit or pipes, probably, depending on your specific needs
14:12:08 <carter> or Io-streams
14:12:17 <carter> fucking hell roman
14:12:22 <ReinH> what?
14:12:22 <stef1a> can someone explain why i'm getting this error? http://lpaste.net/204301325003915264 why does Haskell expect a list of Polys?
14:12:39 <carter> ReinH: tasty has a bad version constraint setup
14:12:48 <ReinH> carter: :(
14:13:04 <benmachine> aranea: I suppose that does make sense, but I personally basically never use more than one =<<
14:13:06 <carter> he did a bug fix "0.0.0.1" bump to tasty that ddrops opt-parse 0.10
14:13:12 <carter> and now requires >=0.11
14:13:27 <carter> ReinH: if my fucking test framwork aint stable, icant use it
14:13:32 <carter> i dont care how shinny it is
14:13:58 <ReinH> carter: argh
14:14:02 <carter> https://hackage.haskell.org/package/tasty
14:14:07 <napping> carter: I think you're supposed to fork his package if it's not fixed in ten minutes or something
14:14:11 <Clint> did 0.11 break the api again
14:14:14 <carter> Clint: yeah
14:14:20 <carter> napping: hows circleci?
14:14:21 <Clint> hilarious
14:14:32 <napping> circleci?
14:14:38 <ReinH> carter: I don't know about circleci, but you know what's terrible? Jenkins.
14:14:46 <carter> napping: nvm
14:14:53 <napping> Yeah, I'm just joking about the -rc variants of stuff
14:14:54 <carter> ReinH: go and bake
14:14:56 <mauke> stef1a: because map takes a list
14:15:05 <aranea> stef1a: map just expects a list as second argument.
14:15:17 <ReinH> carter: Bake is very young and doesn't quite do what I want. I'm going to replace Jenkins with a very specifically designed CI system soon. It will be open source.
14:15:25 <Ralith> ReinH: I'm looking to write code where it's convenient for an input handler for one IO stream to create another and arrange to handle input on the other by writing to the first
14:15:29 <carter> ReinH: i have hasbuild.com
14:15:49 <carter> i will host what ever CI tool i decide i like most (obvs another yak)
14:15:59 <ReinH> carter: My build system will be based on Docker and CoreOS and the assumption that all your builds are set up as docker containers
14:16:04 <napping> ReinH: I don't think the applicative interface gives you enough to express computations in different orders? hmm, I guess you do have flip ($) <$> b <*> a
14:16:21 <ReinH> napping: Applicative is ambiguous about ordering
14:16:24 * hackagebot ekg-log 0.1.0.3 - Push metrics to a log file.  http://hackage.haskell.org/package/ekg-log-0.1.0.3 (ParnellSpringmeyer)
14:16:25 <carter> ReinH: io-streams is probably the simplest one to start with
14:16:30 <carter> Ralith:
14:16:33 <Ralith> ReinH: bonus points for having a http client impl available
14:16:36 <stef1a> mauke aranea: if i change a to polyCoeffs a, which is a list, then i get this error: http://lpaste.net/204301325003915264 why does it expect Poly ( Poly )?
14:16:41 <Ralith> carter: not necessarily looking for the simplest one
14:16:48 <Clint> ah, https://github.com/pcapriotti/optparse-applicative/issues/108
14:16:50 <ReinH> Ralith: everything is going to run off of a JSON API, including the web front-end
14:16:50 <carter> https://hackage.haskell.org/package/http-streams
14:16:56 <Ralith> ReinH: what?
14:16:57 <hexagoxel> seanhess: i can only tell you: i have done the same before, and it worked. cabal list $package lists only the add-source'd version in that case.
14:17:02 <monochrom> floresiensis: you may use Data.Array.Unsafe.unsafeFreeze (O(1)) or Data.Array.MArray.freeze (O(n), makes a copy) to get an immutable Array. Array is an instance of Foldable and Traversable, you may find useful functions in Data.Foldable and Data.Traversable
14:17:03 <aranea> Let me check what you're trying to do.
14:17:03 <napping> ReinH: I'm not sure what the problem is?
14:17:05 <stef1a> oh i think i see why
14:17:07 <ReinH> Ralith: oh you're talking about something else
14:17:12 <ReinH> napping: what are we arguing about again? ;)
14:17:18 <Ralith> ReinH: yes :p
14:17:20 <stef1a> my polyEval function takes a Poly, not a list...
14:17:22 <carter> Clint: ReinH  anyone who doesn't use package upper bounds on my libs is a sucker
14:17:22 <carter> :)
14:17:25 <carter> or asknig for it
14:17:25 <carter> :)
14:17:30 <napping> ReinH: I mean, >>= has an order. I suspect AMP will have some laws relating <*> to something built with join
14:17:33 <carter> major versions are major because they're major
14:17:40 <carter> napping: oh?
14:17:43 <seanhess> hexagoxel: it wasn't selecting the patched version for some reason. I had to manually update the version number in the patched version and set it to == in the cabal file
14:17:52 <ReinH> napping: Right, makes sense.
14:17:57 <ReinH> That's what I would expect as well
14:18:04 <napping> Or at least some kind of laws relating the monad and applicative
14:18:08 <ReinH> A codification of the current expectation that >> and *> coincide
14:18:19 <napping> which is what you asked
14:18:22 <ReinH> napping: yep
14:18:25 <ReinH> napping: ok then :)
14:18:51 <ReinH> carter: fun story, one of our developers is on a campaign to remove upper bounds from our cabal files :D
14:18:59 <napping> I thought you might have some argument against my vague feeling that just about any laws relating Monad and Applicative would imply something about how they relate
14:19:01 <carter> ReinH: kill him
14:19:03 <carter> he dumb
14:19:10 <ReinH> carter: Nah, he ain't.
14:19:11 <carter> that destroys future repbuildability
14:19:17 <carter> convince me
14:19:19 <ReinH> Nah, it doesn't.
14:19:30 <carter> dpeends on a lot of other context otherwise
14:19:38 <ReinH> You add bounds when needed. What he objects to is automatically adding < $NEXT_MINOR_VERSION to every dependency
14:19:42 <carter> oh
14:19:50 <carter> ReinH: i bound on major versions
14:19:50 <carter> only
14:19:53 <carter> unless theres a bug
14:19:55 <ReinH> That's my policy as well
14:20:00 <stef1a> no, actually, i'm still unsure what's up with my code
14:20:02 <carter> but so many projects punt on that
14:20:05 <ReinH> and I think he agrees with it, more or less
14:20:14 <ReinH> carter: it's almost like PVP has semantics that should be respected
14:20:14 <carter> ReinH: i'm saying "always bound the major version range of all your deps"
14:20:19 <carter> I KNOW
14:20:19 <ReinH> carter: me too.
14:20:25 <stef1a> http://lpaste.net/204301325003915264
14:20:31 <carter> ReinH: i'm kinda pissed that all the test libs DONT do this
14:20:31 <ReinH> I also love that PVP is also the acronym for "player vs. player"
14:20:47 <ReinH> which is basically what cabal versioning is right now
14:20:49 <carter> kill you
14:20:51 <carter> now
14:20:56 <ReinH> haha
14:20:57 <mauke> stef1a: why are you trying to use map?
14:20:58 <carter> ReinH: does ANY testing stack have version bounds
14:21:02 <ReinH> carter: nfi
14:21:08 <carter> 'cause otherwise i fucking have write my own
14:21:24 <carter> 'cause a lot of the deps are more like "people will yell if you do breaking changes in a new major vesion"
14:21:35 <stef1a> mauke: i want to evaluate a function (given by its coefficients) at a point
14:21:48 <mauke> ok, use polyEval
14:21:48 <stef1a> mauke: and i want to do this at several x coordinates to generate a list of y coordinates
14:22:23 <mauke> start with one point
14:22:25 <stef1a> like mapping from a list rather than a point
14:22:32 <stef1a> mauke: yeah i have that, it's called polyEval
14:22:41 <mauke> ok, now call it
14:23:08 <mauke> that should give you something like polyEval a 1.0
14:23:11 <aranea> stef1a: So, where's the problem? Map polyEval over a list of x values.
14:23:30 <stef1a> the problem is http://lpaste.net/204301325003915264
14:23:31 <mauke> then we generalize to list/map: map (polyEval a) [1.0, 42.0, -4.0]
14:23:43 <mauke> the problem with your code is that it makes no sense
14:23:45 <stef1a> oh
14:24:10 <mauke> you're using a single x point and trying to treat the poly as a list? ... or something
14:24:31 <stef1a> mauke: you're right; thanks
14:26:33 <floresiensis> monochrom: thanks, I saw that earlier but didn't quite understand it. freeze and unsafeFreeze give me something inside a monad -- so for an IOArray, it gives an IArray inside an IO monad?
14:26:43 <monochrom> yes
14:26:50 <floresiensis> ok thanks
14:26:54 <mauke> s/monad/action/g
14:27:03 <Ajkthx> should i learn haskell as a first language?
14:27:04 <benzrf> :t unsafeFreeze
14:27:06 <lambdabot> Not in scope: ‘unsafeFreeze’
14:27:08 <benzrf> Ajkthx: why not!
14:27:18 <benzrf> Ajkthx: be warned that many resources out there assume you already know an imperative language
14:27:22 <monochrom> stef1a: it seems that you need simply flipPolyEval 1.0 a
14:27:31 <benzrf> Ajkthx: do you know about functions and expressions in mathematics?
14:27:47 <ReinH> Ajkthx: Haskell is a great first language!
14:27:53 <ReinH> I wish I had learned Haskell first.
14:28:22 <floresiensis> monochrom: so if I don't modify the array any further, unsafeFreeze is "safe"?
14:28:26 <Ajkthx> im learning python atm
14:28:28 <monochrom> yes
14:28:31 <hiptobecubic> I'm glad i didn't learn haskell first actually
14:28:34 <floresiensis> k thanks again
14:28:35 <benzrf> Ajkthx: python is also a fine first language
14:28:43 <benzrf> imo haskell is a better language overall than python
14:28:52 <joelteon> it's not hard
14:29:18 <benzrf> Ajkthx: fwiw haskell and python are so utterly different that your learning order between them will probably not be particularly important
14:29:20 <hiptobecubic> Not because it isn't great, but because having a big ecosystem and community to contribute to was really helpful for me early on. Also gui programming in python is too easy for its own good.
14:30:00 <monochrom> partitioning your brain into two halves. use one half to learn haskell, the other half to learn python. you can do it concurrently. :)
14:30:02 <hiptobecubic> benzrf, if you assume that being turned off from one isn't going to affect your chances of learning the other, sure. But I don't think that's a given when the average person is just poking around with programming the first time
14:30:13 <benzrf> eh
14:30:21 <Ralith> carter: well, io-streams has soundly unimpressed me; http-streams depends on an outdated version
14:30:37 <carter> outdated how?
14:30:49 <Ralith> io-streams-1.1.4.6 (latest: 1.2.0.0)
14:30:50 <aranea> I imagine it might be hard to convince yourself to learn other languages after learning Haskell. ;)
14:31:09 <Ralith> aranea: to the contrary, learning agda becomes a very interesting prospect.
14:31:25 * hackagebot Spock 0.7.1.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.1.0 (AlexanderThiemann)
14:31:26 <carter> http-streams isn't used by the io-streams author
14:31:28 <aranea> Ralith: Okay, other non-functional languages.
14:31:34 <carter> io-streams is the core of snap 1.0
14:31:39 <tommd> Ralith: The latest http-streams has an upper bound <1.3 so io-streams 1.2 should be fine.
14:31:46 <aranea> I really must learn Agda.
14:31:47 <Yxven> Ralith What is the appeal of agda?
14:32:00 <Ralith> tommd: the the transitive dependencies don't resolve due to openssl conflicts
14:32:30 <benzrf> Yxven: dependent types O:
14:32:35 <carter> Ralith: lpaste the bulid error
14:32:40 <carter> Ralith: i used it last month i thin
14:32:40 <Ralith> http://sprunge.us/KHQH
14:33:14 <Ralith> that's in a clean sandbox with http-streams and io-streams constrained to latest
14:33:22 <carter> Ralith: ohhhhh
14:33:31 <carter> Ralith: do --allow-newer=network
14:34:38 <carter> or --allow-newer (but lets first try network)
14:34:48 <Ralith> carter: http://sprunge.us/EecW and I don't particularly like the idea of forcibly overriding package constraints
14:35:09 <carter> Ralith: haha
14:35:13 <carter> at least they put upper bounds in
14:35:20 <carter> thats better than the alternatives
14:35:47 <carter> just do  --allow-newer
14:35:50 <carter> see what happens
14:36:01 <carter> same as what yesod does :P
14:36:05 <Ralith> --allow-newer=openssl-streams appears to be all that's needed
14:36:08 <carter> cool
14:36:56 <ReinH> carter: proposal to add a synonym for --allow-newer called --yolo
14:37:09 <carter> Ralith: --yesod
14:37:12 <carter> ReinH:
14:37:14 <ReinH> hahaha
14:37:15 <Ralith> tommd: looks like the author updated the http-streams bound but forgot the openssl-streams bound
14:37:29 <Ralith> er
14:37:30 <carter> whcih project?
14:37:33 <Ralith> updated the io-streams bound
14:37:35 <Ralith> carter: http-streams
14:37:37 <carter> ah
14:37:44 <monochrom> I wouldn't be able to guess what --yolo is for, frome its name. but I would be able to guess --yesod :)
14:37:46 <carter> open a ticket, he'll respond pretty fast
14:37:53 <carter> monochrom: "pray"
14:38:11 <Ralith> carter: https://github.com/afcowie/http-streams/issues/73
14:38:13 <Ralith> pretty fast, eh? :p
14:38:22 <Ralith> oh, wait, that's the author
14:38:29 <Ralith> well I guess that counts as a fast response
14:38:34 <monochrom> haha
14:38:50 <carter> Ralith: HVR reported it
14:38:50 <Ralith> if it's just a bound fix I wonder why he's putting it off, though
14:38:56 <carter> Ralith: he's running a haskell shop
14:39:01 <carter> finite code time managing
14:39:11 <AfC> carter: fixing it now
14:39:15 <carter> AfC:++
14:39:30 <Ralith> carter: I mean, time to report > time to update the bound, so I'd assume there's more to it than that, and as such allow-newer might break it.
14:39:34 <carter> Ralith: see, he uses version bounds AND he's faster to fix than roman :)
14:39:42 <ReinH> hahaha
14:39:44 <Ralith> which lib is roman's
14:39:48 <carter> tasty
14:39:54 <Ralith> never even heard of that one
14:39:57 <carter> testing lib
14:40:02 <carter> its nice
14:40:05 <AfC> Ralith: actually, I don't use version bounds; these particular bounds were gcollins's idea, and they're his dependencies so I let him have his way
14:40:12 <monochrom> Roman has to spend some time on haskell-cafe, too :)
14:40:17 <AfC> s/use/use in general/
14:40:20 <Ralith> AfC: well fixes make me happy regardless ^^
14:40:25 <AfC> still haven't made up my mind on the bounds vs not bounds debate
14:40:32 <carter> AfC: major version bounds are good
14:40:35 <monochrom> w00t today is Wednesday and there will be Haskell Weekly News!
14:40:35 <Ralith> ^
14:40:45 <Ralith> major version bounds mean you can still build idris with the llvm codegen
14:41:05 <carter> Ralith: the lack of major version bounds on opt-parse in idris HOSED it
14:41:25 <carter> Ralith: i got the ok to fix adding the bound for the most recent release
14:41:32 <carter> but i have no interest in fixing all the older ones
14:41:33 <Ralith> \o/
14:41:36 <Ralith> fair enough
14:41:42 <Ralith> who cares about those anyway :p
14:41:49 <carter> Ralith: dos mean that if anyone tries 0.11 + idris, it'll pick those old ones and break
14:41:56 <monochrom> yeah, optparse-applicative's API changed for real when incrememting major version numbers
14:42:09 <Ralith> semantic versioning ftw
14:42:23 <Ralith> carter: aaaand the build broke.
14:42:32 <carter> oh/
14:42:32 <Ralith> knew it wasn't going to be that simple :p
14:42:34 <Ralith> I can wait on AfC though.
14:42:49 <AfC> The only problem is that the current 'master' is a major API bump, so I'll have to create a release branch and back-port the dependency bump. Give me a few minutes.
14:43:08 <Ralith> http://sprunge.us/QdKW for the record
14:43:19 <Ralith> AfC: don't rush for my sake, I'm in no hurry
14:43:27 <Clint> the major number should be the "0", not the "10"
14:43:40 <carter> pvp says we have to places fo rmajorness
14:43:43 <carter> two
14:43:45 <Clint> yes, that's silly
14:44:04 <merijn> I don't think so
14:44:16 <AfC> carter: {shrug} A.x.y.z where A.x is major. It's fine
14:44:21 <merijn> You might wanna change the API without overhauling it significantly (i.e. change one type)
14:44:29 <Ralith> yeah, I was gunna say that
14:44:38 <AfC> "two point oh" is a marketing statement, not a code one
14:44:39 <merijn> major versions are like "I completely overhauled the API"
14:44:44 <Ralith> it's nice to have a way to distinguish "large-scale redesign" vs "breaking change"
14:44:48 <carter> yeah
14:44:50 <merijn> Compare Pipes 1 vs Pipes 2
14:44:50 <Clint> right, like how optparse-applicative broke everything with 0.10
14:44:59 <carter> "you will have to rewrite EVERTYING"
14:45:04 <stef1a> i don't understand what's going on here: http://lpaste.net/975925335403003904 a is a type variable and it should be free to be whatever, as long as it can be added to a Complex Double. so why is Haskell complaining?
14:45:08 <carter> "some stuff changed in breaking ways but mostlyt he same"
14:45:23 <AfC> with the problem that some people interpret "one point oh" as stable release. If it weren't for that, then we could do x.y.z with x major and no one would complain.
14:45:34 <Ralith> ultimtaely it's on the author's head to research the versioning scheme of his deps and bound appropriately
14:45:43 <merijn> stef1a: You can only add ONE thing to Complex Double and that's Complex Double
14:46:07 <stef1a> merijn: why doesn't the Int implementation complain?
14:46:20 <stef1a> oh nvm
14:46:31 <merijn> stef1a: You just noticed that complains too? :)
14:46:51 <stef1a> i just realized why it wouldn't complain at compile time
14:47:01 <AfC> Bloody hell. I forgot to tag the latest release.a
14:47:21 <monochrom> stef1a: you are probably thinking "a is free, therefore, I, the author, can choose a = Complex Double". but that is simply false. it is instead "a is free, therefore, users can choose a = String or a = Bool or ..."
14:47:41 <stef1a> monochrom: that is not what i was thinking.
14:47:41 <monochrom> programming is a dialectic class struggle between the author and the users.
14:48:19 <benzrf> stef1a: remember, think of variables in types as pattern matching
14:48:21 <monochrom> ok. you can only add Complex Double to Complex Double
14:48:38 <benzrf> stef1a: the type of a value is a pattern, and the usage of the value specifies the type that the pattern should match
14:48:53 <benzrf> stef1a: literals are literals and variables are variables
14:49:32 <benzrf> stef1a: so if you say in the pattern that it will match any value for this particular spot...
14:50:44 <carter> @ask johnw could i ask you to see how validate works out  for ghc HEAD using my 32bit 7.8 OS X build? (i dont have enough compute to do that and anything else at the same time )
14:50:45 <lambdabot> Consider it noted.
15:00:25 <AfC> carter, Ralith, hvr: fixed
15:01:14 <Ralith> AfC: the error I pasted remains
15:01:21 <Ralith> http://sprunge.us/QdKW
15:01:26 * hackagebot http-streams 0.7.2.3 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.2.3 (AndrewCowie)
15:01:27 <Ralith> (except .3 now)
15:01:59 <carter> if you pick >2.5 , you need to pick up the network URI package
15:02:07 <Ralith> if I pick what?
15:02:16 <carter> network
15:02:16 <Ralith>   build-depends:       base >=4.7 && <4.8, io-streams == 1.2.*, http-streams == 0.7.*
15:02:20 <Ralith> I'm not picking anything
15:02:24 <carter> i'm explaining to AfC  :)
15:02:26 <Ralith> ah
15:02:38 <carter> network > 2.5.* splits URI into a new package
15:02:39 <Ralith> so network is missing a dep?
15:02:42 <carter> no
15:02:45 <carter> well
15:03:01 <Ralith> so http-streams is missing a dep because network made a breaking change
15:03:07 <Ralith> kay
15:03:41 <merijn> Ralith: Because http-streams' dependency on network didn't properly have a bound to stop that change from breaking it, you mean
15:04:04 <Ralith> merijn: indeed
15:04:39 <merijn> I'm really happy with network dropping parsec and lens dropping aeson as dependencies, that massively shrink my own dependency graph :)
15:05:33 <merijn> Plus it opens the way to replacements for network-uri that don't depend on parsec :)
15:05:36 <phaazon> hey
15:05:53 * Ralith grumbles something about continuous integration testing
15:06:43 <merijn> Ralith: Yeah and who pays for the hardware to run that as open source dev? :)
15:06:46 <hyPiRion> Is there any dual-ish thing for the compositional data types described in Data Types à la Carte? I don't actually need modular fixed-point sum types that much, but would really enjoy modular product types (not fixed-point).
15:07:09 <Ralith> merijn: travis CI does, typically.
15:07:10 <hyPiRion> Usually I don't put in all the annotations in a single AST pass
15:07:25 <Ralith> merijn: it's what we use for Idris.
15:07:33 <jfischoff> hyPiRion: modular products ~ HList ?
15:08:02 <merijn> Ralith: Sure, but Travis is not that fast and only has lik 50 mins of time, no?
15:08:02 <hyPiRion> jfischoff: that.. may be it? I don't know
15:08:24 <hyPiRion> jfischoff: I'll have a look at that, thanks for the pointers
15:08:38 <jfischoff> hyPiRion: sounds like what you “want”
15:09:30 <Ralith> merijn: http-streams doesn't take 50 minutes to build :p
15:09:52 <Ralith> might not work for yesod, but it'll work for most things.
15:10:11 <hyPiRion> It's definitely in the right ballpark, so I'll paper my way around to grok it. Thanks!
15:10:14 <AfC> carter: I'm like super distracted with other things. What's going on?
15:10:22 <carter> AfC: i can explain later
15:10:32 <carter> basically network >= 2.6 doesn't have .URI package
15:10:34 <AfC> carter: is http-streams 0.7.2.3 broken?
15:10:49 <Ralith> AfC: yes, you're missing a dep.
15:11:05 <carter> network-uri
15:11:07 <Ralith> AfC: I'd recommend performing test builds in a clean sandbox to avoid this in the future.
15:11:14 <carter> @hackage network-ur
15:11:14 <lambdabot> http://hackage.haskell.org/package/network-ur
15:11:14 <AfC> Ralith: I can't replicate the problem here, so can someone tell me what it is?
15:11:16 <carter> @hackage network-uri
15:11:16 <lambdabot> http://hackage.haskell.org/package/network-uri
15:11:26 <carter> "In network-2.6 the Network.URI module was split off from the network package into this package. If you're using the Network.URI module you can automatically get it from the right package by adding this to your .cabal file:"
15:11:44 <carter> @lpaste
15:11:44 <lambdabot> Haskell pastebin: http://lpaste.net/
15:11:45 <AfC> Ralith: thank you so much for your advice. I *did* build in a sandbox, and it was fine.
15:11:54 <carter> AfC: http://lpaste.net/112335
15:12:03 <carter> AfC: you probably have network 2.5 installed?
15:12:08 <Ralith> AfC: was it a clean sandbox? because ^
15:12:13 <carter> Ralith: stop
15:12:22 <carter> you adding snark rather than help
15:12:39 <carter> AfC:, if you look at the top level of http://hackage.haskell.org/package/network-uri, it explains things nicely
15:13:08 <carter> AfC: the fix for that veersion you put on hackage is to edit its bound to be < 2.6 network
15:13:23 <carter> and then do a bug fix version that uses the suggested stanza at the top of http://hackage.haskell.org/package/network-uri
15:13:34 <carter> ohhh
15:13:35 <carter> wait
15:13:40 <carter> i can add that to the cabal file
15:13:40 <AfC> carter: um
15:13:47 <carter> AfC: i can fix it for you live
15:13:53 <AfC> Is adding a flag the right thing?
15:13:53 <carter> with your permssion
15:14:02 <carter> AfC: the flag encodes the boolean or
15:14:35 <carter> every time you see OR in the version constraints, its encoded via flags
15:14:48 <Ralith> adding a flag allows you to support network < 2.6; if that's not important, adding the missing dependency should be sufficient.
15:15:00 <carter> AfC: http://hackage.haskell.org/package/http-streams/maintain
15:15:19 <trap_exit> what does $! do ? (context: haste compiler)
15:15:27 <trap_exit> what does $! do ? (context: reading haste compiler source code)
15:15:28 <carter> trap_exit: same that it does in ghc i hope
15:15:30 <mauke> @src ($!)
15:15:30 <lambdabot> f $! x = x `seq` f x
15:15:44 <trap_exit> oh damn
15:15:53 <trap_exit> so it's like put arg into WHNF
15:15:55 <trap_exit> then call f
15:16:00 <trap_exit> right?
15:16:24 <carter> AfC: g2g, but if you want i can do the fixup for you, and then you just retagg your repo side with a revision tag
15:16:27 <AfC> hm. I've managed to avoid those until now. So shouldn't it react to whatever is present? Anyway, if you say < 2.6 is viable I can try that; but that seems awfully prescriptive
15:16:39 <AfC> carter: no, I'd rather fix it in code
15:16:45 <carter> AfC: its on the cabal file size
15:16:47 <carter> side
15:16:50 <carter> not a problem elsewhere
15:17:23 <carter> that is, just adding http://lpaste.net/112335 (with the ... handled suitable :) ) to your cabal file is all you need to do
15:17:35 <carter> anyways, g3g
15:17:41 <AfC> carter: sure. I just don't want to track changes to the code anywhere other than git [c.f. our conversation in Gothenberg about the absurdity of hackage's edit feature]
15:18:32 <Johannes13> @src seq
15:18:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:19:08 * Ralith decides to see how far he can get with conduit instead
15:20:22 <benmachine> I used conduit once
15:20:29 <benmachine> I got confused about my resource usage
15:20:37 <benmachine> this is, I think, exactly the opposite of what is supposed to happen
15:21:06 <Ralith> hah
15:21:59 <AfC> Anything wrong with just depending on network >= 2.6?
15:22:26 <AfC> Ralith: jesus, what do you expect? You reported a problem, upstream authors are fixing it.
15:23:47 <AfC> So we'll try that again
15:23:50 <mauke> if you use Network.URI, you also need to depend on network-uri >= 2.6
15:24:05 <AfC> mauke: sure, I can add that
15:24:26 <AfC> mauke: just wondering if depending on network 2.6 would be one of those breaks-everything-else deals
15:24:59 <AfC> carter: you were right, by the way. My sandbox had network-2.5 in it
15:28:12 <Ralith> AfC: I expect upstream authors not to take it personally if I experiment with other libs in the meantime :p
15:29:50 <Ralith> also, for that matter, not to respond with sarcasm when I explain the standard approach for detecting this class of error.
15:31:24 <AfC> Ralith: hey, you go ahead and use http-conduit or wreq or anything else. Doesn't worry me in the slightest. Haskell has wonderful modular properties and you can usually mix and match to your heart's content.
15:32:22 <AfC> Ralith: as for the other thing, I told you I had it built and tested in a clean room sandbox and didn't encounter the problem you were having. I'm really sorry if my performance wasn't up to your expectations. Hopefully we will do better for you in the future.
15:32:58 <Ralith> AfC: if your sandbox was clean, how did network-2.5 get in it?
15:33:36 <Ralith> am I confused about how sandboxes work?
15:34:20 <AfC> Ralith: It would appear that system hadn't had a `cabal update` in a few weeks is I think what happened.
15:37:32 <Ralith> AfC: that's odd; network-2.6 was Aug 16.
15:38:05 <AfC> Maybe it was something else then
15:38:26 <monochrom> time flies like an arrow
15:38:32 <AfC> {ha}
15:38:37 <monochrom> @quote monochrom time.flies
15:38:37 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
15:39:01 <monochrom> hmm, maybe space leaks like a foldl instead
15:39:07 <monochrom> @quote monochrom syntax.rules
15:39:07 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
15:39:37 <monochrom> oh, I see! it was Arrow : Monad
15:40:05 <monochrom> fortunately, there are ways free monads leak space, so the sentence is not entirely wrong
15:40:15 <Ralith> hah
15:41:27 * hackagebot http-streams 0.7.2.4 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.2.4 (AndrewCowie)
15:41:29 * hackagebot hoogle-index 0.3.0 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.3.0 (BenGamari)
15:42:09 <sm> bgamari++
15:46:28 * hackagebot stdf 0.1.0.0 - Parse Structured Test Data Format (STDF)  http://hackage.haskell.org/package/stdf-0.1.0.0 (m)
15:56:37 <gcganley> Can someone explain to me how (*) meaning multiplication and (*) meaning concrete type in kind signatures are implemented differently
15:58:13 <merijn> gcganley: What sort of explanation are you expecting?
15:58:21 <merijn> gcganley: "That's just how the parser was written"?
15:58:39 <dibblego> gcganley: there is no relationship, except the same symbol with very different meaning in a different context
15:59:14 <gcganley> Merijn: is it the lexical scoping that it recognizes the difference in (*) the function and (*) the type signiture?
15:59:26 <merijn> gcganley: It's not even lexical scoping
15:59:55 <merijn> gcganley: Kind signatures and expressions are in different scopes altogether
16:00:23 <merijn> gcganley: The parser is either parsing a kind signature OR an expression and how it interprets * depends on that
16:00:42 <floresiensis> I have tried resolving this ambiguity by writing my own myfreeze = freeze function with a specific type signature, but so far I've been unsucessful. https://gist.github.com/anonymous/b5f250c288db71137f00
16:02:17 <gcganley> Sorry irc crashed
16:02:18 <jfischoff> post your custom function version
16:02:24 <jfischoff> floresiensis: ^
16:03:18 <floresiensis> jfischoff: myFreeze :: IOArray Int Char -> IArray (IOArray Int Char) Char, but it says the kind is wrong. Needs to be the MArray expansion of IOArray?
16:06:10 <jfischoff> I think the type signature is :: IOArray Int Char -> IO (Array Int Char)
16:09:20 <SrPx> Hello, what is a fast Priority Queue implementation ?
16:09:34 <SrPx> There are too many around, I don't know which I chose.
16:10:30 <floresiensis> jfischoff: thanks, that works. I suppose freezing or unsafe-freezing is the usual way to compare IOArrays?
16:11:16 <jfischoff> um, maybe? probably not actually. i bet people iterate through the elements
16:11:59 <SrPx> eh I actually need a priority queue with a remove operator :( found none
16:13:41 <floresiensis> I wrote an iterative comparison too, but considering it wasn't already written I figured there was a more usual way. Unsafe freezing might be faster, dunno.
16:14:04 <merijn> floresiensis: unsafe freezing is faster, but, obviously, unsafe :)
16:16:11 <benmachine> hm, the array API is kind of sparse
16:18:08 <benmachine> floresiensis: if performance isn't critical for you, I'd say do a safe freeze and use the Array
16:18:23 <benmachine> immutable arrays have a better API
16:19:58 <floresiensis> benmachine: right, but still a little surprising that there's no comparison function.
16:21:01 <benmachine> floresiensis: well, less surprising when you remember that fetching elements from an IO array is impure
16:21:09 <benmachine> so you can't provide pure operations that do very much
16:21:45 <Ralith> is there a conduit lib which uses openssl bindings rather than the haskell tls package?
16:21:46 <floresiensis> well comparison wouldn't be pure
16:22:17 <floresiensis> it's easy to write, just expected it to be there
16:22:33 <benmachine> floresiensis: me too, to be honest
16:22:40 <benmachine> but there you go
16:30:03 <SrPx> Is there any type on prelude that encapsules a pair, but that has an instance of Ord, where only one element of the pair is considered? Specifically, I want to use Data.PQueue.Min. It expects me to insert elements that are instances of Ord, but what I have is a tuple (priority,myValue)
16:30:30 <SrPx> And I don't want to create a new type just for this...
16:31:55 <mkscrg> hey all, what's "state of the art" for hetergeneous lists?
16:31:58 <mkscrg> still hlist?
16:32:35 <MauBot> hi
16:34:04 <MauBot> heyyy
16:34:32 <MauBot> whats up
16:34:40 <simpson> Yes.
16:35:17 <MauBot> testesttesttest
16:35:28 <Rembane> Tset!
16:35:59 <monochrom> yes, I think that HList is still the state of the art of heterogenous lists
16:36:11 <MauBot> faster
16:36:24 <MauBot> everytime
16:36:39 <MauBot> everytime server sends a message my message gets sent
16:36:42 <benzrf> lets get rid of tuples.
16:36:42 <MauBot> cool
16:36:45 <benzrf> lets just have hlists.
16:37:06 <benzrf> rustle up some syntactic sugar
16:37:57 <simpson> Aren't you the same person that earlier said that Haskell is better than Python? >:3
16:41:52 <merijn> mkscrg: Depends on how featureful it needs to be?
16:42:05 <merijn> mkscrg: With GADTs implementing your own HList type is pretty trivial
16:43:46 <mkscrg> merijn: it's not well-specified in my brain :)  i want something like a "typed vector of known length", such that i can typefully access each element
16:44:57 <mkscrg> merijn: what do you mean re. easy w/ GADTs? would love to see a barebones example
16:47:45 <Denommus> anyone here uses ghc-mode?
16:47:53 <Denommus> preferencially with company-mode?
16:48:22 <merijn> mkscrg: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
16:48:54 <merijn> mkscrg: Like I said, pretty trivial :)
16:49:14 <merijn> Granted, that requires GHC 7.6 (or maybe even 7.8), but still
16:49:36 <mkscrg> merijn: ahh, i see!
16:49:38 <Denommus> ghc-mod
16:49:42 <Denommus> sorry
16:49:46 <mkscrg> merijn: DataKinds is needed there for '[]?
16:49:50 <MauBot> hello
16:49:58 <MauBot> test
16:50:01 <MauBot> yay
16:50:12 <merijn> mkscrg: For the entire [*], yes
16:50:40 <merijn> mkscrg: So ': too
16:52:30 <mkscrg> merijn: got it. thank you! off i go to figure out if this is actually what i need...
16:57:07 <chrisdotcode> if I have a problem dealing with regular languages (parsing times of the day for example (so like '02:14am' or '23:56')), should I use regexs or parsec?
16:57:41 <Axman6> for future you's sanity, the answer to that question is almost always parsec
16:58:02 <chrisdotcode> which is why I asked; the regexs will be easy to write, but parsec seems saner in the long run
16:58:16 <chrisdotcode> (is there a library that already handles that sort of datestring parsing, by the way?)
16:58:59 <Axman6> sure, Data.Time has stuff iirc
16:59:59 <chrisdotcode> Axman6: Can it parse dates in the form of my examples ('02:15am'; '23:56')?
17:01:31 * hackagebot xdot 0.2.4.4 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.4 (DennisFelsing)
17:01:33 * hackagebot ghc-vis 0.7.2.4 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.4 (DennisFelsing)
17:01:35 * hackagebot ghc-vis 0.7.2.5 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.5 (DennisFelsing)
17:01:56 <MauBot> haskell[D
17:02:03 <MauBot> #haskell
17:04:35 <MauBot> hello
17:08:45 <AshyIsMe> hmm, there's something wrong with lambdatwit's usage of twitter-conduit i think
17:09:02 <AshyIsMe> it continues to loop through the full history of mentions instead of grabbing the latest new ones each time
17:11:09 <Ralith> do conduits support multiplexing, or do they rely on native haskell concurrency for that?
17:12:34 <merijn> pipes has a library for concurrent pipes, maybe that exists for conduits too
17:12:49 <merijn> Ralith: I think basic conduits, like basic pipes, don't do concurrency
17:13:05 <lmergen> hmmm how do i know whether a specific library is thread-safe? i should assume thread-unsafety by default?
17:13:39 <solatis> specifically, sharing HDBC.Connection objects between threads
17:13:52 <Ralith> merijn: so I guess my question is what the idiomatic scalable approach to concurrent IO is (with conduits, or otherwise if conduits just aren't meant to be used that way, but yesod is supposed to scale pretty well...)
17:14:50 <jmcarthur> solatis: haskell libraries tend to be thread safe more often than libraries in most other languages, although that doesn't mean you should just assume random library X is thread safe.
17:15:18 <merijn> Ralith: Yesod is a webserver, generally (in haskell) you have one thread per client
17:15:39 <n4x> couldn't we "assume", if the code is pure, then it is thread-safe?
17:16:06 <Ralith> merijn: so haskell-native concurrency is what yesod uses?
17:16:07 <merijn> Ralith: And each client thread runs a conduit doing stream processing
17:16:13 <n4x> I don't know how pure code could be non-threadsafe
17:16:27 <merijn> n4x: Yes, pure code is threadsafe by definition
17:16:59 <merijn> n4x: But there are bindings to C libraries, async exception awareness, etc.
17:17:07 <solatis> jmcarthur, i understand -- in my c++ experience it tends to be always documented (and/or it's easy to 'reason' about whether a library is thread-safe) -- i just don't see anything documented about thread safety within HDBC
17:17:09 <merijn> n4x: Especially bindings to C libraries using thread local storage
17:17:21 <solatis> i'll just assume they're not thread safe
17:17:54 <solatis> since that's what my intuition tells me :)
17:18:43 <merijn> solatis: Is it binding a C library? If so, that seems like a sane intuition, yes
17:19:10 <merijn> Ralith: I mean, conduits use case is completely orthogonal to concurrency/parallelism
17:19:47 <merijn> Ralith: The use case for conduits/pipes/etc is: stream processing with deterministic (constant) memory usage and safe resource acquisition/freeing
17:19:51 <Ralith> merijn: I understand, but the question of idiomatic scalable multiplexed IO (using conduits if possible) concerns both.
17:20:12 <merijn> Ralith: GHC's IO manager is the way to go for multiplexing IO
17:20:17 <merijn> Ralith: Go read the MIO paper ;)
17:21:01 <Ralith> I take it that conduits work within the framework of the IO manager, then?
17:21:20 <merijn> Ralith: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf <- how GHC 7.8's new IO manager allows a haskell SDN program to reach up to 20 million requests per second :)
17:21:43 <Ralith> sounds interesting
17:21:59 <Axman6> Ralith: if you need multiplexed IO, then using multiple haskell threads and something like conduit is the way to go
17:22:00 <merijn> Ralith: So, my experience is with pipes, but I think they're mostly the same.
17:22:26 <Ralith> okay, cool, thanks
17:22:34 <merijn> Ralith: pipes just performing blocking IO as you normally do in haskell, they just let you compose blocking IO into streaming operations more easily
17:22:53 <merijn> Ralith: My pipes in the end just call "readSocket" which is a blocking read using the IO manager
17:22:57 <Ralith> that seemed likely, but I wasn't completely sure whether conduits avoiding lazy IO also meant working around the I Omanager
17:23:06 <Ralith> the IO manager*
17:23:17 <merijn> Ralith: No, strict IO is the default in haskell
17:23:25 <Axman6> no, GHC's IO manager is amazingly good
17:23:29 <Ralith> excellent
17:23:38 <merijn> Ralith: things like withFile need to use unsafeInterleaveIO to become lazy IO
17:23:49 <Ralith> merijn: I believe your definition of 'default' there is arguable, considering getContents, interact, etc :p
17:23:54 <merijn> Data.ByteString.hGet is just strict
17:24:22 <platz> strict as in reading everything into memory at once?
17:26:32 * hackagebot shelly 1.5.6 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.6 (GregWeber)
17:31:32 * hackagebot monad-supply 0.5 - Stateful supply monad.  http://hackage.haskell.org/package/monad-supply-0.5 (GeoffHulette)
17:32:35 <aranea> Are there other ways of outputting ascii-art tables than the "tabular" package?
17:33:02 <aranea> Because that seems to unflexible for me.
17:33:38 <Axman6> are ther aalib bindings?
17:33:40 <Axman6> there*
17:34:29 <aranea> I don't see any.
17:36:13 <Ralith> does haskeline support printing output simultaneous to accepting user input?
17:37:42 <Ralith> in particular, I'd want it to, whenever I want to print output, delete the currently-echoed input and prompt, print the output, then replace the prompt and input
17:41:54 <prinsen> When compiling a FFI library, I pass -dynamic -shared -fPIC and -lHSrts-ghc7.8.3 as ghc-options in cabal. However, I still need to link against lHSrts.. in gcc. Might this be because when GHC compiles the stub files it does not link against HSrts?
17:49:36 <aranea> Is there a way to "zip" N lists, where N is variable?
17:50:29 <Axman6> you can use the ZipList instance of Applicative
17:50:35 <aranea> Basically, I want to go through all lists in a list of lists and do a fold over the 1st, 2nd, 3rd, ... elements, producing another list.
17:50:43 <artyomkazak> transpose?
17:51:02 <Axman6> ah, that's a slightly sifferent question
17:51:08 <Axman6> transpose should do the job
17:51:14 <aranea> transposing would be a possibility
17:51:27 <Axman6> > transpose ["Hello", "abc", "something longer"]
17:51:29 <lambdabot>  ["Has","ebo","lcm","le","ot","h","i","n","g"," ","l","o","n","g","e","r"]
17:51:57 <aranea> map foldl' f x . transpose
17:52:18 <Axman6> you'll need brackets
17:52:27 <aranea> Umm, yes.
17:52:34 <akurilin> What do you do when you want to update stackage versions? Do you have to wipe the app's sandbox to make sure to use the new snapshot?
17:55:05 <MauBot> hi
17:55:11 <MauBot> hihihih
17:55:20 <Axman6> hello...
17:55:45 <dmwit> aranea: boxes, but it doesn't *quite* do tables properly.
17:55:52 <dmwit> aranea: It's made for a slightly different use-case.
17:56:23 <dmwit> Well. I'm sure you can get it to do tables properly, but I don't think it supports it out of the box.
17:57:02 <aranea> .. exactly my use-case :)
17:57:45 <aranea> Otoh, I'm already rolling my own solution.
17:59:09 <aranea> That's what my transpose question was about, I need to figure out the maximum lengths of the columns.
17:59:36 <aranea> Well, not /exactly/ my use-case, but it's closer than tabular.
18:00:25 <Javran> if we do type algebra on two types t1 and t2 and they turn out to be the same, what can be implied from here?
18:01:38 <dmwit> Depends how exciting your algebra is.
18:01:40 <Javran> say t1 = (a->b,a->c), t2 = a -> (b,c)
18:01:47 <dmwit> If it's a fairly tame one, it means the types are isomorphic.
18:01:54 <dmwit> ...up to bottoms, of course
18:03:16 <Javran> dmwit: what does it mean by saying two types are isomorphic?
18:03:48 <dmwit> It's the usual meaning of isomorphic. t1 and t2 are isomorphic means there are f :: t1 -> t2 and g :: t2 -> t1 such that f . g = id and g . f = id.
18:04:18 <Javran> dmwit: I see
18:05:02 <Javran> dmwit: and there might be more than one pair of (f,g), right?
18:05:07 <dmwit> Certainly.
18:05:16 <dmwit> Often the particular algebra you did induces one particular pair.
18:06:49 <piss-christ> I need (Functor f, Monad m) => (a -> m b) -> f a -> m b
18:06:54 <piss-christ> but can't find it
18:07:05 <Javran> dmwit: just realize it becomes more straightforward when I think t1 and t2 are two sets of the same cardinality
18:07:34 <dmwit> Javran: More straightforward, but beware -- there be dragons in applying set theory.
18:08:21 <piss-christ> something like fmap but for mapping IO
18:08:26 <dmwit> piss-christ: You'll have to know something special about your functor.
18:08:27 <piss-christ> over a Maybe
18:08:29 <dmwit> :t traverse
18:08:30 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:08:59 <Javran> dmwit: I see, thanks for help!
18:09:15 <dmwit> :t traverse_
18:09:15 <lambdabot>     Not in scope: ‘traverse_’
18:09:16 <lambdabot>     Perhaps you meant one of these:
18:09:16 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
18:09:21 <dmwit> :t F.traverse_
18:09:22 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
18:10:04 <dmwit> :t F.traverse_ print :: Show a => Maybe a -> IO ()
18:10:05 <lambdabot> Show a => Maybe a -> IO ()
18:11:34 * hackagebot FunGEn 0.4.5 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4.5 (SimonMichael)
18:20:38 <L8D> Where's lambdabot’s license?
18:21:10 <Javran> L8D: GPL https://hackage.haskell.org/package/lambdabot
18:21:33 <L8D> Javran: thank you. now I can't complain that it hurt my feelings. :(
18:22:18 <prinsen> Could someone look at this: http://lpaste.net/112340
18:22:53 <prinsen> It says that it cant find HSrts-ghc7.8.3, but I think that the undefined references is the real problem
18:28:07 <joe9> quick question,  my ghc install uses time-1.4.2. I see that the latest time package version is 1.5. Can I install time-1.5 using cabal install?
18:28:46 <joe9> I am not sure if upgrading a base package using cabal is a good idea or if it is a no-no.
18:29:04 <RchrdB> joe9: it's often problematic
18:29:36 <vermeille> if "cabal" is in your idea, that's prolly a bad idea :D
18:29:44 <joe9> RchrdB: ok, thanks.
18:31:05 <kadoban> joe9: The only way I've found to deal with that kind of thing (which is actually my default now) is to just install ghc alone, then install cabal, and then use sandboxes for everything. Seems to work so far. Otherwise I end up in cabal hell pretty much always...
18:31:50 <jayunit100_4g> how do you get a description of what a function does?
18:31:52 <kadoban> joe9: https://gist.github.com/ion1/2815423 here's the instructions I follow.
18:32:02 <jayunit100_4g> :info is nice, but id like something like :doc
18:32:08 <jayunit100_4g> i.e. :doc foldr
18:33:01 <jayunit100_4g> i.e., do haskell functions have docs tied to them ?
18:33:09 <RchrdB> joe9: AIUI, the problem usually goes like: e.g. if you install 1.5 of 'time', then you won't be able to link against the versions that came with your ghc of `unix` or `random` because those were built depending on a different version of `time`, and GHC won't link two different versions of the same package in one binary.
18:33:33 <fread2282>  jayunit100_4g yes, see hackage, but ghci foesn't have :doc
18:33:42 <fread2282> *doesn't
18:33:50 <RchrdB> joe9: this ends up being *really* rigid for anything that wants to use GHC's own API, since that package by definition can't get upgraded by any means other than installing a new GHC. :)
18:35:04 <jayunit100_4g> https://hackage.haskell.org/packages/
18:35:29 <jayunit100_4g> where are the packages for GHC.Base ? fread2282  … thanks btw :)
18:39:06 <fread2282> jayunit100_4g: idk, but you can get the source (of GHC.Base) from that page and search in it if you really need GHC.Base docs
18:40:34 <joe9> kadoban: ok, thanks.
18:41:05 <kadoban> (YMMV, by the way. I'm barely past a beginner really)
18:41:36 * hackagebot zot 0.0.2 - Zot language  http://hackage.haskell.org/package/zot-0.0.2 (YoshikuniJujo)
18:41:48 <joe9> RchrdB: thanks, that explanation makes sense.
18:45:10 <mkscrg> how do i get ghci to evaluate a type family?
18:47:23 <fread2282> mkscrg: :i
18:55:37 <ReinH> jayunit100_4g: hoogle will help you look up documentation
18:55:40 <ReinH> @where hoogle
18:55:41 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:01:37 * hackagebot STL 0.3 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.3 (bergey)
19:06:00 <stef1a> i'm unsure why i'm getting these errors when trying to determine whether the result of log division is an int: http://lpaste.net/4250679461554421760
19:08:46 <RchrdB> stef1a: what happens if you put "isInt :: (RealFrac a) => a -> Bool" above the isInt declaration?
19:09:28 <stef1a> RchrdB: i get similar errors
19:10:04 <stef1a> i did an import Data.Complex at the beginning of my program also
19:10:14 <RchrdB> oh OH right
19:10:59 <RchrdB> (length p) is an Int, so calling (log (length p)) upsets everything.
19:11:40 <RchrdB> stef1a: (log (fromIntegral (length p)))
19:12:05 <stef1a> but log can take logs of ints
19:12:12 <ReinH> :t log
19:12:13 <lambdabot> Floating a => a -> a
19:12:21 <stef1a> oh
19:12:37 <ReinH> :t logBase
19:12:38 <lambdabot> Floating a => a -> a -> a
19:12:50 <ReinH> You need to do some type conversion
19:13:33 <stef1a> RchrdB: thanks!
19:13:44 <RchrdB> no worries
19:14:02 <RchrdB> (Haskell's log function requires a Floating input, so you have to convert your Int input to a Floating type (Float or Double) first.)
19:15:19 <rola> in haskell you cannot you enforce laws such as "fmap (f . g) == fmap f . fmap g" on instances.  are there languages which you can?
19:15:28 <rola> in which*
19:16:02 <merijn> rola: Agda and Coq come to mind
19:16:15 <merijn> rola: Maybe Idris too, i.e., languages with dependent types
19:16:47 <knockedDownAFewP> I had started to think, that I was making progress in groking haskell basics...Can someone please take a look at this short paste an let me know why the compiler cannot determine the type?
19:17:02 <RchrdB> knockedDownAFewP: what paste? ;)
19:17:05 <knockedDownAFewP> http://lpaste.net/112342
19:17:25 <merijn> knockedDownAFewP: It'd help if you paste the error too ;)
19:17:34 <knockedDownAFewP> ah yes of course. Just a sec
19:17:46 <merijn> :t recip
19:17:48 <lambdabot> Fractional a => a -> a
19:18:15 <merijn> :t pi
19:18:16 <lambdabot> Floating a => a
19:18:44 <knockedDownAFewP> good grief
19:18:57 <RchrdB> knockedDownAFewP: "z = zC / zR" looks suspicious; you're trying to produce a Complex value by dividing two reals?
19:19:11 <merijn> RchrdB: Good catch
19:19:23 <merijn> Actually, is Complex an instance of Fractional?
19:19:23 <RchrdB> z = zR :+ zC ?
19:19:41 <merijn> Ah, it is
19:19:53 <RchrdB> offhand I think, (Floating a) => Floating (Complex a)
19:20:00 <merijn> :t (/)
19:20:01 <lambdabot> Fractional a => a -> a -> a
19:20:16 <merijn> ok, I'm llost without an error :)
19:20:18 <ReinH>  :t (:+)
19:20:41 <merijn> ReinH: That's just the Complex constructor
19:20:46 <merijn> :t (:+)
19:20:46 <knockedDownAFewP> RchrdB: zC should be complex: "zC :: Complex a (bound at Main.hs:7:9)"
19:20:47 <lambdabot> a -> a -> Complex a
19:20:48 <RchrdB> knockedDownAFewP: it looks like you wanted "z = zR :+ zC", since (:+) is the operator that Data.Complex defines for putting two reals together to make one complex.
19:20:56 <ReinH> merijn: yep
19:21:06 <RchrdB> knockedDownAFewP: oh my bad
19:21:07 <merijn> knockedDownAFewP: Please annotate the entire error on the paste :)
19:21:37 <knockedDownAFewP> I've added the error to the paste http://lpaste.net/112342
19:22:04 <merijn> oh, duh
19:22:26 <merijn> knockedDownAFewP: zC is complex, zR is not and you're dividing them in z
19:22:29 <RchrdB> knockedDownAFewP: is "zC / (zR :+ 0)" correct? You're trying to divide a Complex Double by a Double, but Haskell's (/) requires both args to have the same type.
19:22:29 <merijn> :t (/)
19:22:30 <lambdabot> Fractional a => a -> a -> a
19:22:52 <rola> merijn, that's what i was suspected, Thanks
19:23:46 <knockedDownAFewP> thanks guys
19:26:17 <qfjp> hi all, i have a question that hopefully someone can help me out with
19:26:30 <qfjp> im trying to get an integer from stdin, and then repeat a function call that many times
19:26:52 <qfjp> but nothing I try is working
19:27:11 <qfjp> I've found people on stackoverflow saying use iterate, but it doesnt make sense to me
19:27:51 <qfjp> (mapM_ (putStr ∘ (++ " ") ∘ show) filteredList) is the function i'm trying to repeat, if that helps
19:27:58 <qfjp> where filteredList is a list of integers
19:28:52 <merijn> main = do { str <- getLine; case readMaybe str of Just i -> repeatM_ i myAction; Nothing -> return () }
19:28:58 <merijn> :t repeatM_
19:29:00 <lambdabot>     Not in scope: ‘repeatM_’
19:29:00 <lambdabot>     Perhaps you meant one of these:
19:29:00 <lambdabot>       ‘repeat’ (imported from Data.List),
19:29:05 <merijn> oh
19:29:09 <merijn> :t replicateM_
19:29:10 <lambdabot> Monad m => Int -> m a -> m ()
19:29:34 <qfjp> wait, sorry, i lied
19:29:38 <qfjp> the action is a block
19:29:50 <qfjp> eh... let me explain better
19:29:55 <merijn> "myAction :: IO ()" there
19:30:26 <qfjp> that...makes sense
19:30:30 <qfjp> thanks! I'll try it
19:31:05 <merijn> readMaybe is in Text.Read, iirc
19:31:40 * hackagebot http2 0.6.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.6.0 (KazuYamamoto)
19:32:42 <Guest52014> Does anybody happen to know a good way to truncate a Tree, like from Data.Tree
19:33:31 <simpson> Guest52014: What does the truncation look like?
19:33:42 <Guest52014> I just want to take n levels
19:34:10 <Guest52014> like a depth first search, going only so far.
19:35:24 <L8D> this is more of a lambda calculus question, but how do I implement vectors in lambdas?
19:35:52 <L8D> or... how would I implement vectors as algebraic data types?
19:35:57 <Axman6> L8D: functions from Int to a?
19:36:06 <merijn> L8D: You can't, at least not efficiently
19:36:12 <qfjp> I'm dumb, that was it. thanks merijn
19:36:14 <Axman6> depends on what you mean by a vector too
19:36:32 <L8D> I mean Vector as in cons puts the element at the end
19:36:41 <L8D> where you iterate from the first element
19:36:45 <merijn> qfjp: :)
19:37:46 <Axman6> L8D: that's a pretty unusual definition of a vector
19:37:54 <L8D> with lists you can just do: cons x xs f _ = f x xs
19:38:01 <L8D> empty _ e = e
19:38:10 <simpson> Guest52014: Well, you could write a recursive function pretty easily.
19:38:52 <Guest52014> and just pass the depth, until i reach max?
19:38:54 <dfeuer> L8D, there are a lot of kinds of sequences. Vectors are generally distinguished by fast indexing.
19:39:17 <Axman6> (or in other settings by having a known length)
19:39:19 <L8D> then from there you can do stuff like: map f l = l (\x xs -> f x (map f xs)) empty
19:40:01 <dfeuer> Indeed, Axman6.
19:40:03 <L8D> I meant vectors as in add-to-the-end instead of add-to-the-start
19:40:15 <dfeuer> Yeah, that's *not* a definition of "vector".
19:40:30 <dfeuer> That sounds more like a queue.
19:40:31 <L8D> okay well whatever they are how do I define them?
19:40:37 <L8D> Clojure calls those vectors
19:41:31 <dfeuer> L8D, what exact operations do you need available?
19:41:57 <dfeuer> If you want a general purpose sequence type, the Seq type from Data.Sequence may be a good choice.
19:42:10 <simpson> Guest52014: Just count down with each layer, yeah. Like take.
19:42:12 <simpson> @src take
19:42:13 <lambdabot> take n _      | n <= 0 = []
19:42:13 <lambdabot> take _ []              = []
19:42:13 <lambdabot> take n (x:xs)          = x : take (n-1) xs
19:42:20 <dfeuer> If you need extreme performance, you may need something less general-purpose.
19:42:57 <johnw> carter: hey
19:42:59 <L8D> dfeuer: like I want to be able to do: cons 0 [1] and get [1, 0]
19:43:11 <L8D> but entirely in functions
19:43:13 <carter> johnw: yo
19:43:13 <dfeuer> L8D, what is "get"?
19:43:16 <carter> :)
19:43:29 <dfeuer> Entirely in functions? That's not likely to be very pretty.
19:43:35 <johnw> carter: if I ran your thing, it would be overnight, so I'm guessing you could do that too :)
19:43:44 <Guest52014> cool, thanks dfeuer.
19:43:56 <L8D> dfeuer: like I can define lists like: cons x xs f _ = f x xs
19:44:03 <L8D> empty _ e =e
19:44:10 <dfeuer> Huh what? Guest52014 I don't see how *I* helped *you*.
19:44:26 <L8D> and make [1, 0] by writing: cons 1 (cons 0 empty)
19:44:39 <hgl> yeah, sorry. New to this
19:45:18 <L8D> dfeuer: and with lists I would do: map f l = l (\x xs -> f x (map f xs)) empty
19:45:18 <dfeuer> L8D, yeah, someone fairly recently actually tried implementing a compiler that compiles everything to those sorts of forms. I don't know how well it went. But it's definitely not *usually* easy to understand code like that.
19:45:29 <Guest29275> thanks simpson.
19:45:42 <L8D> dfeuer: I'm actually writing this all out in JavaScript
19:45:49 <carter> johnw: :'(
19:45:50 <carter> :P
19:45:57 <L8D> dfeuer: so implementing as many data types as I can with pure functions
19:45:59 <carter> you have that monster mac or so
19:46:11 <dfeuer> L8D, whyyyyyyy?
19:46:15 <L8D> using what I know of lambda calculus and church data types
19:46:19 <johnw> carter: had, I only have a laptop right now
19:46:25 <carter> ahhhhh
19:46:40 <johnw> when my new Mac Pro comes (whenever they refresh so that I order it), then I'll be happy to spare you some cycles
19:46:54 <carter> dfeuer: whos' that person whos ressearch was all those splitable RNGs? was it you who was looking th up?
19:46:59 <AshyIsMe> the trashcan mac?
19:46:59 <dfeuer> L8D, but if you can compare the lengths of your lists, you can implement Banker's queues fairly easily.
19:47:04 <johnw> AshyIsMe: si
19:47:11 <dfeuer> carter, no, it wasn't me. Sorry.
19:47:11 <AshyIsMe> cool
19:47:15 <merijn> carter: What kinda cycles did you need donated?
19:47:34 <carter> merijn: someone testing doing a validate build of ghc head with my 32bit os x ghc
19:47:38 <L8D> dfeuer: so that I can have a demonstration of lazy evaluation in JS that doesn't make you go mad
19:47:38 <dfeuer> carter, it sounds like an interesting problem though, and important for Haskell at least.
19:47:50 <merijn> carter: Ah, I'm not quite setup for that yet :)
19:48:01 <dfeuer> L8D, why not use GHCJS?
19:48:05 <carter> merijn: just once
19:48:29 <L8D> dfeuer: It's meant to be an example of how you can do it by building from basic structures
19:48:43 <merijn> carter: Yeah, but I don't have GHC checkout yet and I can't checkout on my current internet connection
19:48:43 * dfeuer goes.
19:48:56 <L8D> dfeuer: where?
19:48:57 <merijn> (yes, my internet is that sad here)
19:49:06 <dfeuer> L8D, to another window.
19:49:13 <johnw> merijn: are you in California?
19:49:19 <merijn> johnw: Yeah
19:49:33 <merijn> johnw: Have been since August, I've told you that :)
19:49:34 <carter> merijn: you can do it later
19:49:49 <johnw> merijn: I know that, I was saying it because you complained about Internet
19:49:50 <merijn> carter: I can run it tomorrow if it's still relevant for you then
19:49:51 <carter> merijn: i just have < 10gb free disk space and only my computer
19:49:56 <johnw> I've seen yoru hotel room through your webcam, remember??
19:49:57 <carter> merijn: any time this week would be swell
19:50:03 <johnw> or your apartment or whatever
19:50:13 <merijn> carter: My new laptop isn't work ready yet, so it's idle all day at work tomorrow
19:50:25 <merijn> Can easily leech some work internet to download GHC and build while I work
19:50:40 <johnw> carter: can't you run it while you sleep?
19:50:57 <carter> johnw: finite disk space
19:51:00 <merijn> johnw: To be honest even Oracle's internet is pretty pathetic...I get about 2MB/s down
19:51:29 <merijn> Here I'm lucky if I get 100kb/s >.>
19:51:33 <merijn> It's like being on a modem
19:51:47 <carter> johnw: i literally could run out of diskspace if i did a full validate
19:52:06 <johnw> i see, so you want to age my SSD beyond it's years
19:53:01 <rfn> Newb question (and first question on #haskell):  Can someone point me to an example or writeup of a simple state machine (in haskell)?
19:54:20 <Guest48671> I am also a noob, but I did a simple google search
19:54:23 <Guest48671> and found results
19:55:10 <rfn> Yep, so have I, but not either not what I was looking for, or perhaps just over my head.
19:55:14 <stef1a> i want to create a function that evaluates a polynomial at a point, and i'm storing the polynomial as a list of coefficients. with this: `actuallyPolyEval (p:ps) x = (p * x) + actuallyPolyEval ps (x * x)`, i will go from x to x^2 to x^4 to x^8, which is not what i want -- i want to go from x to x^2 to x^3 to x^4, etc.. can someone suggest how i might do this?
19:55:36 <Guest48671> oh alright ya there was a PDF writeup on it, but over my head also
19:55:43 <carter> merijn: anyways, thanks in advance
19:55:45 <carter> :)
19:56:06 <gcganley> Are there any classes or set of tutorials that will start from the very basics of cat theory to the very complex?
19:56:26 <wei2912> rfn: what type of state machine?
19:56:36 <wei2912> finite-state machine?
19:57:31 <rfn> wei2912: I have simple network protocol, and simple FSM in my head to process it.  Six states, and approx 10 events.
19:58:04 <trap_exit> so I just compiled haste compiler 0.4.3 from git ... made a change, and recompiled, and it worked
19:58:07 <trap_exit> I feel like I deserve a trophy of some sort
19:58:18 <Guest48671> CONGRATS!
19:58:56 <carter> gcganley: n-lab has LOTS
19:59:00 <carter> not sure if its basic
19:59:56 <kai234353> poly (e:es) x = e*x + x * poly es x
20:00:51 <gcganley> carter: I get functors, monoids, semigroups, and monads (roughly) but when i look at edwardk's code my head implodes to a singularity
20:01:08 <carter> gcganley: learning edwardian haskell is a lot of work
20:01:22 <carter> gcganley: the way I've managed is i read his code via the commits
20:01:27 <carter> to see the evolution
20:01:31 <johnw> yes, grokking edwardk is a good thing to aspire to, but is not trivial to accomplish
20:02:05 <gcganley> So edwardk's code is nirvana?
20:02:12 <carter> no
20:02:15 <carter> its not perfect
20:02:21 <johnw> it's a fantastic whetstone
20:02:21 <carter> but its a reallly nice style
20:02:29 <carter> gcganley: but i really comment picking a repo
20:02:36 <carter> and just read it via the commit history
20:02:39 <carter> to see the evolution
20:02:41 <carter> not lens
20:02:45 <carter> thats too big and too many commits
20:02:52 <gcganley> carter: something like comonad?
20:02:56 <carter> sure
20:02:57 <carter> whatever
20:03:06 <johnw> even just "reflection" is a great library to sink your teeth into, or "tagged"
20:03:07 <carter> thers > 50 choices afaik :)
20:03:12 <carter> yeah
20:03:20 <carter> tagged isp robably easier than reflection
20:03:26 <johnw> "reflection" implements a really nice paper too that you can read
20:03:27 <carter> johnw: the tricks in reflection are bonkers
20:03:31 <gcganley> carter: edwardk has so many libraries it g
20:03:35 <gcganley> hurts
20:03:37 <johnw> and then you have this great technique to use in your code in future
20:03:43 <carter> gcganley: life doesn't have a level cap
20:03:49 <carter> pick the easier critters to start with
20:04:05 <johnw> "recursion-schemes" is another good one
20:04:14 <carter> whats nice about the style he tends to is its once that that really tries to maintain good type inference
20:04:18 <johnw> and of course "free"
20:04:25 <gcganley> carter: it seems it doesn't have a skill tree either
20:04:27 <johnw> I find myself read code in "free" almost on a weekly basis
20:04:38 <SrPx_> Can I create an unboxed array with tuples?
20:05:41 <johnw> yes
20:05:50 <johnw> it will, behind the scenes, create two unboxed arays
20:06:15 <SrPx_> uh... in different places? Won't that increase cache miss?
20:06:16 <carter> johnw: or in the front, uisng my SOA Pair lib
20:06:20 <carter> SrPx_: nope
20:06:31 <johnw> if you want cache-oblivious data structures, talk to edwardk :)
20:06:32 <carter> SrPx_: until your code is other wise fast, dont microoptimize
20:06:41 <carter> SOA format is reocmmented for math things
20:08:02 <SrPx_> hmm okay thanks
20:08:05 <lpaste> orb pasted “inits benchmarked” at http://lpaste.net/112345
20:08:19 <orb__> dfeuer, see http://lpaste.net/112345 for different inits.  What's your fastest?
20:09:13 <orb__> carter, unless you microoptimize for fun.
20:09:16 <carter> SrPx_: have you read the intel optimization manueal
20:09:24 <orb__> carter, eg micro-optimizing bogo sort.
20:09:31 <carter> orb__: then www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html should be your bible
20:09:44 <SrPx_> carter: hm no? is that it? /\
20:09:48 <wei2912> rfn: http://lpaste.net/5284757168086581248
20:09:49 <orb__> carter, just pretend I like to develop for phone, then.
20:09:54 <wei2912> rfn: sorry for the delay
20:09:55 <carter> SrPx_: read www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html
20:09:55 <orb__> (not that I do.)
20:10:01 <wei2912> writing a FSM in haskell is actually pretty easy
20:10:09 <SrPx_> carter: okay thank you. But why?
20:10:25 <gcganley> I don't have it on hand sadly, does typeclassopedi have a good section on monad transforms and if not where can I find a good lesson on them?
20:10:26 <orb__> wei2912, especially if it's a one off: just abuse tail calls as GOTOs.
20:10:29 <carter> because until you read it, any microoptimization worries are totallly wrong :)
20:10:39 <carter> because it explains what micro optimizations are good or bad
20:10:41 <dfeuer> orb__, my fastest was a collaborative effort with Edward Kmett and Joachim Breitner. Andrew Seniuk also helped with one version. See https://phabricator.haskell.org/D324 and https://ghc.haskell.org/trac/ghc/ticket/9345
20:10:45 <carter> for ANY recent cpu version
20:11:05 <wei2912> orb__: :P
20:11:17 <johnw> gcganley: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
20:11:32 <rfn> wei2912: Thanks!  Digesting now... :-)
20:11:39 <SrPx_> carter: sure. I like to know that it exists, I'll read it
20:11:41 <johnw> gcganley: also: http://book.realworldhaskell.org/read/monad-transformers.html
20:11:48 <carter> cool
20:11:48 <orb__> dfeuer, I just wonder why the `continuation' based one outperforms the other two, and especially the standard init.
20:11:49 <carter> read it
20:11:51 <carter> you'll learn A LOT
20:12:00 <carter> and you'll also learn that most of the time you dont have to worry about it :)
20:12:21 <gcganley> johnw: does cs.virginia have a lot of good papers?
20:12:28 <dfeuer> orb__, one weird benchmark to pay attention to is   map head(tail(inits [1..10000]))
20:12:34 <stef1a> why does Haskell expect pwr to be a Complex Double here? http://lpaste.net/626262366979358720
20:12:56 <carter> stef1a: probably because one of the other args is a complex double :)
20:13:01 <johnw> gcganley: I don't know
20:13:02 <carter> you can lift a real to a complex if you want
20:13:57 <stef1a> carter: i... that's so counter intuitive and roundabout... i just want to understand what's wrong with how i've written the function
20:14:04 <dfeuer> orb__, the fastest in most cases of the ones that I looked at was what you called initsW and I called initsR, but it does poorly with the head map.
20:14:15 <stef1a> i give it three arguments, and the third is an int... so why does it expect it to be a CD?
20:14:35 <orb__> dfeuer, by the way, my names are terrible in that file.
20:14:37 <dfeuer> orb__, the queue-based version is only very slightly slower in general, and doesn't trip up on that.
20:14:58 <johnw> :t (**)
20:14:59 <lambdabot> Floating a => a -> a -> a
20:15:03 <johnw> stef1a ^^
20:15:05 <johnw> that's why
20:15:10 <johnw> 'x' is fixing the type of the other argument to **
20:15:10 <carter> types!
20:15:12 <orb__> dfeuer, nice.
20:15:50 <wei2912> how do i get the source code of a function using lambdabot?
20:15:57 <johnw> @src tail
20:15:57 <lambdabot> tail (_:xs) = xs
20:15:57 <lambdabot> tail []     = undefined
20:16:04 <wei2912> i recall someone doing that a few minutes ago but can't remember how to :P
20:16:06 <wei2912> johnw: thanks!
20:16:09 <orb__> dfeuer, basically, compared to the old standard inits, all the approaches I came up with where fast.
20:16:16 <wei2912> @src ^
20:16:17 <lambdabot> x ^ 0            =  1
20:16:17 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:16:17 <lambdabot>   where f _ 0 y = y
20:16:17 <lambdabot>         f x n y = g x n
20:16:17 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
20:16:17 <dfeuer> Yes.
20:16:18 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:16:20 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:16:24 <dfeuer> The old standard inits is very bad.
20:16:26 <orb__> dfeuer, do you have an explanation with the old standard inits is slow?
20:16:27 <gcganley> johnw: if you responded I didn't catch it sorry my iPad crashed
20:16:42 <johnw> gcganley: I found the paper through google and skimmed through it to see if it would be appropriate for you
20:16:48 <johnw> I don't really know about where it came from
20:17:41 <stef1a> carter: then why doesn't it tell me that?
20:17:41 <dfeuer> orb__, give me a minute.
20:17:48 <gcganley> johnw: oh ok, I have a bunch of papers from cs.virginia.edu, im not sure if they just have a
20:17:59 <carter> ask one of the othe repxlainers
20:18:11 <gcganley> a lot of functional papers or a lot of haskell papers
20:22:18 <gcganley> :t repeat
20:22:19 <lambdabot> a -> [a]
20:22:34 <gcganley> @src repeat
20:22:34 <lambdabot> repeat x = xs where xs = x : xs
20:24:09 <gcganley> Is there any reason repeat is not written as > repeat x = x : repeat x
20:24:29 <rfn> \quit
20:25:23 <dfeuer> orb__, I'll be back in a few.
20:25:28 <orb__> dfeuer, take your time.
20:25:36 <dfeuer> Busy stupid.
20:25:39 <dfeuer> :/
20:25:44 <wei2912> gcganley: i'm curious to find out too
20:26:49 <gcganley> wei2912: wouldnt that make more sense? Unless it's a ghc optimization thing
20:28:33 <gcganley> Good night
20:44:46 <dfeuer> orb__, you have PMs.
21:07:20 <carter> private messages
21:11:44 * hackagebot ds-kanren 0.2.0.0 - A subset of the miniKanren language  http://hackage.haskell.org/package/ds-kanren-0.2.0.0 (jozefg)
21:17:26 <benzrf> b y e
21:17:56 <osa1> is anyone here using llvm-general? I'm wondering if there's a function to get sizeof of a struct.
21:18:08 <carter> osa1: #haskell-llvm is a channle
21:18:18 <osa1> great, thanks
21:36:45 * hackagebot ds-kanren 0.2.0.1 - A subset of the miniKanren language  http://hackage.haskell.org/package/ds-kanren-0.2.0.1 (jozefg)
21:40:44 <solatis> ok, i'm having a problem that i think more people have had before
21:41:00 <simpson> I don't get -s RTS reports when out of memory. I'd really like those reports! Is there a way to get at them?
21:41:05 <solatis> i'm using a JSON library data.aeson, but another library i use uses text.json
21:41:17 <simpson> (Is this also going to negatively affect the quality of heap dumps with -hc/-hd/-hy?)
21:41:29 <solatis> without resorting to the obvious serialize/deserialize workaround, what would be the best way to convert between the two?
21:41:32 <SrPx_> Is there a shorter way to write (case x of (Just a) -> a; Nothing -> 0) ?
21:41:33 <solatis> is that possible at all?
21:41:43 <simpson> :t maybe -- SrPx_
21:41:45 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:41:58 <cmears> :t fromMaybe
21:41:59 <lambdabot> a -> Maybe a -> a
21:42:08 <simpson> :t maybe 0 id
21:42:09 <lambdabot> Num b => Maybe b -> b
21:43:34 <SrPx_> thanks
21:45:29 <dibblego> fromMaybe 0
21:46:47 <dibblego> fromMaybe 0 x -- actually
22:32:31 <wei2912> how do i assign multiple variables to a tuple? is there a clean way other than using fst and snd?
22:32:31 <bmuk> Hey everyone, what's the preferred method for dealing with packages that need to be installed globally (I mean that produce binaries that you would use globally, yesod-bin is a good example)? Should I build them in a sandbox and copy the binary itself out?
22:32:41 <wei2912> for example, let a, b = (9, 3)
22:32:46 <wei2912> then a = 9 and b = 3
22:32:56 <Cale> wei2912: (a,b) = (9,3)
22:32:58 <wei2912> the syntax i typed out doesn't seem to work though
22:33:01 <wei2912> Cale: ah, thanks!
22:33:31 <Cale> bmuk: Typically, you ought to be able to, I think.
22:33:55 <Cale> (I don't know about yesod-bin in particular)
22:34:53 <bmuk> Is that what most people do though? I've been trying out stackage and it's great, but exclusive doesn't have several key packages, and inclusive fails to build tons of things. I realize it will get better with time but I would like a semi working solution now.
22:35:33 <merijn> bmuk: Shouldn't have any problems unless said binaries use the GHC API or something
22:35:35 <bmuk> yesod-bin was just an example.
22:36:36 <Cale> Personally, I tend not to install anything globally, and just install binaries to ~/bin
22:36:59 <Cale> (in fact, I have ~/.cabal/bin as a symlink to ~/bin)
22:37:02 <bmuk> Cale: so you build the libraries in a sandbox?
22:37:46 <Cale> I'd use a sandbox for something that had a lot of dependencies which I wouldn't necessarily want
22:37:57 <bmuk> s/libraries/binaries
22:38:31 <bmuk> How else would you build the binaries without installing them globally?
22:39:18 <Cale> Well, if it's something without a lot of dependencies, I might just  cabal install foo  as user
22:39:46 <bmuk> I always thought of that as being "global"
22:40:24 <Cale> Not if you don't run it as root?
22:41:04 <Cale> It should just install to your home directory
22:41:14 <bmuk> Oh, okay. I was thinking global as in you can import it from any project. Global as opposed to sandbox
22:41:22 <Cale> ah, okay
22:42:23 <Cale> Well, yeah, in any case, the result of compiling some binary in a sandbox should be about the same as compiling it without the sandbox
22:43:02 <Cale> It's just that all the library dependencies will end up in the sandbox before being statically linked into the binary
22:43:37 <bmuk> But I can delete the sandbox afterwards and everything should be fine?
22:43:45 <Cale> should be
22:43:50 <bmuk> Because ghc binaries are all statically linked
22:44:57 <merijn> user-global is my default install approach I only switch to sandbox when that runs into issues
22:45:31 <bmuk> merijn: and you don't run into issues often?
22:45:56 <merijn> bmuk: No. But take that with a grain of salt, as I mostly install stuff with fairly few dependencies
22:46:15 <bmuk> ah okay
22:47:25 <merijn> And I know how to safely fix things when I do
22:47:39 <merijn> It's just rather manual
22:48:16 <merijn> For example, if cabal complains a library is to old "--force-reinstalls" massacres your db, but manual ghc-pkg unregister'ing all problematic things and installing newer versions is fine
22:48:31 <bmuk> how does one safely fixthings? rm -rf~/.ghc?"
22:49:27 <bmuk> Ah I see. That seems like a lot of work though, but you said you don't really install things with a ton of dependencies
22:50:08 <merijn> bmuk: If it takes too long I just nuke everything, cabal update and continue from there with everything new
22:50:25 <merijn> I generally don't update installed packages unless needed for new API features/bugfixes
22:51:16 <bmuk> If we can build asts of all of the packages, shouldn't it be possible to automatically see where the new versions break and fix them?
22:52:39 <merijn> bmuk: What if there is no fix?
22:52:52 <merijn> bmuk: i.e. new version doesn't compile with the other's new API
22:53:21 <bmuk> I'm suggesting we should be able to rewrite the package to use the new API?
22:54:08 <bmuk> If we know what has changed on both sides, we should be able to isolate the problem? Or maybe I am being overly optimistic
22:54:49 <merijn> bmuk: That requires the computer to automatically determine what the desired functionality is and how to create that from an arbitrary API
22:55:05 <merijn> That's well-beyond what's reasonable in the coming decades, if not centuries :)
22:55:20 <bmuk> so strong AI? haha
22:55:49 <bmuk> I thought we could just make the types line up, if only it were that simple.
22:56:35 <merijn> bmuk: There's research in that direction
22:56:55 <merijn> If you're not easily intimidated, you can look at Conor McBride's thesis
22:57:39 <bmuk> I will definitely bookmark it. I'm hoping to do grad work in that area
22:59:26 <bmuk> Dependently Typed Programs and Their Proofs?
22:59:57 <merijn> Yeah, that one
23:00:01 <David> hey guys
23:00:08 <David> I'm a little confused on where to put a deprecated pragma
23:00:13 <merijn> bmuk: Basically, the idea is type guided program derivation
23:00:32 <David> I have a module of functions I'm trying to export, and the language manual says something about putting the leval at "top level"
23:00:36 <David> sorry, putting the pragma*
23:00:51 <bmuk> merijn: sounds awesome! Thank you for recommending it. I'm off to bed though, I will read through it tomorrow.
23:01:04 <David> I tried to put it at a bunch of places in the module declaration and they all give me parse errors
23:01:49 * hackagebot x509 1.4.13 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.13 (VincentHanquez)
23:01:51 * hackagebot x509-system 1.4.6 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.6 (VincentHanquez)
23:01:53 * hackagebot x509-util 1.5.1 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.5.1 (VincentHanquez)
23:01:57 <merijn> "top level" just means "put it at the same level as function declarations"
23:02:09 <wei2912> http://lpaste.net/112350 - any ways I could improve this? :P
23:02:46 <merijn> David: See this example: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString.html#findSubstring
23:02:57 <David> thanks merijn!
23:03:43 <merijn> wei2912: "inversions = snd . countInv'"? <- pointfree \o/
23:04:03 <merijn> wei2912: Also, "length" is really slow
23:04:07 <wei2912> merijn: right, i always forget that i could make it point-free
23:04:08 <merijn> wei2912: It's O(n)
23:04:17 <wei2912> yeh; is there any way to improve this?
23:04:46 <merijn> "maybe", tbh, I'm not really sure what it does without investing significantly more effort :)
23:06:23 <kadoban> wei2912: Instead of the 'case' on length, can't you just pattern match on the list constructor, since you only seem to care if it's length 1 or not?
23:06:39 <kadoban> wei2912: Of course I didn't look deeper to see if that's actually going to make much difference
23:06:48 <wei2912> kadoban: that would remove one `length`
23:07:02 <kadoban> Oh, there's more.
23:07:31 <wei2912> kadoban: will remove the first `length`
23:08:04 <wei2912> if i'm not mistaken, i'd use two patterns, `countInv' x` and `countInv' (x:xs)`; is that correct?
23:08:52 <kadoban> countInv [x]   and   countInv _ is equivalent to your current, which I'm not sure is correct.  Does what you have work for [] ?
23:09:18 <kadoban> Actually that'd remove a logarithmic number of length calls, if I'm reading that right, hehe...
23:09:56 <wei2912> kadoban: countInv [x] matches one-length arrays only?
23:10:03 <kadoban> Oh, this is quicksort while counting the number of inversions I guess?
23:10:07 <kadoban> wei2912: Yeah.
23:10:30 <kadoban> Oh, not quicksort...
23:10:30 <wei2912> it's mergesort, with the merge routine counting the number of inversions (i, j) where i is in left and j is in right
23:10:44 <kadoban> Right
23:11:14 <wei2912> i guess i could maintain a length in the function?
23:12:06 <wei2912> or would there be a better way to do the split without relying on `length`?
23:12:20 <kadoban> I wonder if instead of splitting in half, you can take evens and odds as separate? Then you don't have to take the length at all.
23:12:49 <wei2912> so i place all of the even-index elements in one list and odd-index elements in the other?
23:13:02 <wei2912> would that affect the number of inversions?
23:13:14 <wei2912> looks like it would, since it's not stable
23:13:40 <kadoban> wei2912: Yeah, it'd affect stability if this is currently stable.
23:14:17 <merijn> You could just do "map (:[])" and merge sort a [[a]] until you have a single list and then you unwrap it to [a]
23:15:16 <kadoban> Oh that's neat
23:15:47 <wei2912> what does :[] do?
23:15:55 <kadoban> Puts each element in a list.
23:15:58 <wei2912> i see
23:16:23 <kadoban> And then you combine them in the right way so that you end up only doing lg n merges
23:16:38 <kadoban> It's like a backwards mergesort or something, heh.
23:16:45 <wei2912> bottom-up mergesort? :P
23:17:59 <wei2912> hmm. how'd that fit into my code?
23:18:16 <jle`> > (:[]) 5
23:18:19 <lambdabot>  [5]
23:18:23 <jle`> > 5:[]
23:18:25 <lambdabot>  [5]
23:18:45 <merijn> (:[]) is like (+2), but with the list constructor partially applied :)
23:18:46 <kadoban> wei2912: I think you'd throw a count of inversions in a tuple with each inner list, and update it when you do the merges
23:19:03 <kadoban> (obviously they start at zero)
23:20:42 <kadoban> And then I guess you define a "merge them all once" that merges adjacent pairs, and run that until there's only one element left? Not sure if there's a cuter way.
23:22:02 <wei2912> when i do the merge i'll need to check for the length of xs though
23:25:11 <killy9999> I want to write a function like this:
23:25:21 <killy9999> g x = (x, g (x-1))
23:25:29 <killy9999> obviously, that constructs an infinite type
23:25:42 <killy9999> is there any trick that allows to work around that?
23:25:50 <killy9999> like using some newtypes or fix?
23:26:09 <zwer> use a list instead of a tuple?
23:26:13 <kadoban> wei2912: Hmm. This code is actually pretty bad performance, huh? I just noticed that it has to sort the whole other side of the merge every time there's an inversion...
23:26:20 <zwer> :t \x = x : g (x-1)
23:26:21 <lambdabot> parse error on input ‘=’
23:26:28 <zwer> :t \x -> x : g (x-1)
23:26:29 <lambdabot> (FromExpr [a], Show a, Num a) => a -> [a]
23:27:04 <killy9999> zwer: that works when I recur once
23:27:07 <killy9999> but what if I have
23:27:18 <killy9999> g x = (x, g (x-1), g (x-2)) ?
23:27:34 <killy9999> that aside, I'm treating this as an intelectual exercise
23:27:49 <killy9999> so I'm really looking for a solution involving tuples :-)
23:28:08 <wei2912> kadoban: uh oh
23:28:17 <zwer> I don't think this is possible with tuples
23:28:50 <wei2912> kadoban: hmm... that doesn't seem to be the case
23:29:06 <mauke> data Tree a = Node a (Tree a) (Tree a)
23:29:16 <mauke> g x = Node x (g (x - 1)) (g (x - 2))
23:29:39 <wei2912> on another note, how do i read in a text file containing integers and obtain a list?
23:29:48 <kadoban> wei2912: Oh, hah yeah it's not. Nevermind
23:30:30 <mauke> map read . words <$> readFile "hello"
23:31:20 <wei2912> assuming the text file is passed in through stdin
23:31:30 <mauke> getContents
23:31:50 <wei2912> contents <- getContents
23:32:05 <orb__> wei2912, you can also learn about Parsec.  It's a bit overkill for this problem, but worth knowing in general.
23:32:06 <wei2912> then `lines contents` will give me a list of the contents split by "\n" - is that correct?
23:32:31 <wei2912> orb__: thanks for the tip
23:32:34 <wei2912> will take note in the future
23:33:08 <wei2912> how do i then convert the list of strings into a list of integers?
23:36:06 <dibblego> wei2912: do you have a way to convert one string to one integer?
23:36:29 <wei2912> dibblego: using `read`?
23:36:43 <dibblego> wei2912: that's one way (be careful that it is unsafe)
23:36:51 <dibblego> and in that case, just write (map read)
23:37:10 <dibblego> > map read ["7", "8"] :: [Int]
23:37:12 <lambdabot>  [7,8]
23:37:32 <dibblego> let f :: [String] -> [Int]; f = map read in f ["7", "8"]
23:37:36 <dibblego> > let f :: [String] -> [Int]; f = map read in f ["7", "8"]
23:37:38 <lambdabot>  [7,8]
23:37:59 <dibblego> if you have a String, that might not be an Int, it will throw an error
23:39:36 <wei2912> http://lpaste.net/112350 - L25-27 i think i'm doing it the wrong way
23:40:03 <dibblego> I think you (at least) want [Int] and not Int
23:40:12 <wei2912> ah, yes
23:41:27 <wei2912> sorry for being a bit of a help vampire now, but i'm not too sure where to continue
23:41:36 <dibblego> no prob
23:41:49 <dibblego> on line 2, you want snd . countInv'
23:41:52 * hackagebot lagrangian 0.6.0.0 - Solve Lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.6.0.0 (JonathanFischoff)
23:42:14 <dibblego> and on the last line, you want print not putStrLn
23:43:08 <dibblego> http://lpaste.net/112350
23:43:53 <wei2912> dibblego: thanks
23:44:19 <wei2912> also, thanks to orb__ mauke kadoban merijn
23:49:09 <wei2912> i must go now, will post my code here after i optimize it a bit
23:56:52 * hackagebot lagrangian 0.6.0.1 - Solve Lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.6.0.1 (JonathanFischoff)
