00:00:02 <solatis> that means you have the latest installed
00:00:04 <haskell_cabal> How can I have happy 1.8 when that package doesnt go past 1.2
00:00:14 <solatis> no look at the cabal file again
00:00:18 <solatis> it's 1.18 and 1.19
00:00:25 <haskell_cabal> i see
00:00:37 <haskell_cabal> Hmm
00:00:44 <haskell_cabal> okay
00:01:24 <solatis> so there is probably some other package that says 'i want happy < 1.19', and language-javascript saying 'i want happy', and cabal saying 'you have no happy, because < 1.19 matches no installed packages'
00:01:24 <haskell_cabal> Sorry I was going by your msg @ solatis
00:01:33 <solatis> or something like that
00:01:37 <solatis> anyway
00:01:40 <solatis> cabal dependency hell
00:01:42 <solatis> create a sandbox
00:01:45 <solatis> or use nix
00:01:53 <solatis>  /advice
00:02:34 <haskell_cabal> now I'm trying to install language-javascript via: cabal install
00:02:42 <haskell_cabal> and I still get the happy version is  wrong
00:02:46 <haskell_cabal> even though happy --version
00:02:49 <haskell_cabal> gives me 1.19
00:02:53 <haskell_cabal> weird
00:03:00 <haskell_cabal> I tried the sandbox, same problem
00:03:26 <solatis> they really should add a #cabal-dependency-hell irc channel
00:03:40 * hackagebot Randometer 0.1.0.1 - Randomness intuition trainer  http://hackage.haskell.org/package/Randometer-0.1.0.1 (So8res)
00:03:40 * hackagebot hs-php-session 0.0.9.3 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.3 (elblake)
00:06:06 <haskell_cabal> This makes no sense..
00:06:10 <haskell_cabal> I have happy > 1.18
00:06:24 <haskell_cabal> I just tried to install langauge-javscript and it complained still..
00:06:30 <jle`> @where that-one-happy-error-that-everyone-gets
00:06:30 <lambdabot> I know nothing about that-one-happy-error-that-everyone-gets.
00:06:33 <kadoban> I'm not sure 'sudo cabal install' is ever a good idea...not sure what that does. Usually you just install as your user
00:06:49 <kadoban> afaik anyway
00:07:29 <haskell_cabal> if i dont do that, i get permission denied
00:07:31 <haskell_cabal> hmm
00:07:48 <jle`> hm
00:07:55 <solatis> yes it will install as your user, but with root privileges
00:07:58 <jle`> is your ~/.ghc and ~/.cabal under root for some reason?
00:08:00 <solatis> as in, not something you want
00:08:02 <kadoban> haskell_cabal: Maybe just wipe clean your cabal stuff and start again? You probably shouldn't have done that to begin with maybe
00:08:40 <haskell_cabal> I dont have anything under root
00:08:49 <haskell_cabal> what do  you mean by wipe cabal clean exactly?
00:09:00 <solatis> rm -rf ~/.ghc && rm -rf ~/.cabal
00:09:02 <solatis> and start again
00:21:20 <carter> solatis: never rm ~/.cabal
00:21:21 <carter> ever
00:21:31 <carter> ~/.ghc can die though
00:21:48 <solatis> why?
00:22:11 <solatis> i did so many times i even had a script to remove it and put my old config back in place
00:22:12 <carter> because you can't explain to me why you should
00:22:15 <carter> :)
00:22:25 <kadoban> ./cabal is mostly like your config and the packages list and stuff, there's no reason to wipe it out
00:22:35 <kadoban> Unless something is horribly broken or something, I dunno.
00:22:49 <solatis> ok
00:22:56 <carter> yeah
00:23:06 <carter> i've broken my software by deleting ~/.cabal
00:23:10 <carter> in the past
00:23:12 <carter> never dleet that
00:23:16 <carter> unless you ahve a very good reason
00:23:21 <carter> or i will come and find you
00:23:24 <carter> and be mad and sad
00:23:25 <carter> :)
00:25:47 <solatis> cabal and ghc configuration management always tends to hit that special nerve with people that makes them mad and sad
00:26:17 <kadoban> I've got it to a point where it usually works pretty well for me.
00:26:41 <kadoban> There's still the occasional broken package though
00:27:03 <michi7x7> morning
00:28:02 <haskell_cabal> Isnt yesod supposed to be pretty standard?
00:29:14 <kadoban> Probably
00:29:35 <Hijiri> yesod is known for having hard-to-satisfy dependencies
00:30:19 <haskell_cabal> Any recommendations for an alternative?
00:30:57 <Hijiri> Snap, happstack, scotty, are all other web frameworks in haskell
00:31:13 <Hijiri> if you still want to use yesod you'll have more success in a sandbox
00:31:22 <Hijiri> or stackage if you want to go that far
00:31:33 <kadoban> I tend to just use hakyll and static sites, but that's not quite the same problem space
00:33:44 <chirpsalot> I'm kind of convinced that nobody actually has a working Yesod and it's all just pretend.
00:34:15 <kadoban> Haha
00:36:38 <Hijiri> I have working yesod in some sandbox somewhere
00:36:46 <Hijiri> but I haven't used it for any real project
00:36:53 <chirpsalot> Hijiri: assuming it hasn't broken :P.
00:37:45 <haskell_cabal> I tried the sandbox
00:37:56 <haskell_cabal> HOw do i delete all my cabal bs
00:38:06 <haskell_cabal> i'm getting "dont delete .cabal'
00:38:14 <haskell_cabal> and others... say to delete it...
00:38:20 <chirpsalot> haskell_cabal: I think delete .ghc?
00:38:24 * chirpsalot can't remember.
00:38:30 <Hijiri> delete ~/.ghc
00:38:41 <Hijiri> to deregister your packages
00:39:05 <haskell_cabal> okay done
00:39:11 <haskell_cabal> now i get this though
00:39:12 <haskell_cabal> Dependency tree exhaustively searched.  Note: when using a sandbox, all packages are required to have consistent dependencies. Try reinstalling/unregistering the offending packages or recreating the sandbox.
00:39:19 <CodeWeaverX> deleting.babal/lib too probably.  but not all .cabal.
00:39:29 <haskell_cabal> when trying to install deps inside my cabal sandbox for the yesod project
00:40:21 <haskell_cabal> I still have yesod installed...
00:40:25 <haskell_cabal> shouldnt it have been uninstalled?
00:40:29 <haskell_cabal> when i removed .ghc
00:41:07 <chirpsalot> haskell_cabal: yesod is a binary.
00:41:17 <chirpsalot> which yesod?
00:41:52 <haskell_cabal> .cabal/bin/yesod
00:42:26 <haskell_cabal> ok i'm still getting permission denied
00:42:27 <haskell_cabal> hmm
00:42:28 <haskell_cabal> odd
00:42:37 <haskell_cabal> ooh sandbox, oops
00:47:13 <haskell_cabal> well i keep getting dependency issues with permissions inside the cabal sandbox...
00:47:35 <Haskellfant> haskell_cabal: which error exactly do you get?
00:48:01 <haskell_cabal> .cabal/setup-exe-cache: copyFile: permission denied (Permission denied)
00:48:13 <Haskellfant> using windows?
00:48:19 <haskell_cabal> ubuntu
00:48:28 <haskell_cabal> chmod it?
00:48:34 <Haskellfant> worth a try
00:48:39 <haskell_cabal> hmm
00:48:41 <Haskellfant> or chown
00:48:45 <haskell_cabal> hmm
00:48:51 <Haskellfant> what does ls .cabal show
00:49:20 <haskell_cabal> bin is owned by root
00:49:22 <haskell_cabal> so is lib
00:49:25 <haskell_cabal> and share
00:49:29 <haskell_cabal> and setupe-exe-cache
00:49:31 <Haskellfant> that sounds wrong
00:49:35 <haskell_cabal> hmm
00:49:36 <Haskellfant> or are you running as root?
00:49:46 <haskell_cabal> i was when i installed cabal I believe
00:49:48 <Haskellfant> normaly this should be owned by your current user
00:49:52 <haskell_cabal> hmm
00:50:00 <haskell_cabal> i'll google how to chown recurisve
00:50:02 <Haskellfant> how are you installing cabal?
00:50:06 <Haskellfant> chown -R iirc
00:50:17 <haskell_cabal> cool
00:50:20 <haskell_cabal> so i wanna do
00:50:26 <haskell_cabal> chown -R ~/.cabal
00:51:50 <haskell_cabal> nvm got it
00:53:40 <Hermit> chown -R <user> <dirs|files>
00:53:54 <Hermit> you may need to do it with root privileges
00:56:43 <haskell_cabal> Still getting the dependency errors even in a sandbox
00:56:45 <haskell_cabal> yesod-static-1.4.0.2 depends on language-javascript-0.5.13 which failed to install.
01:03:35 <thaostra> Hey, I got quick question. Why is it that "[-10..-5]" raises "Not in scope: `..-'" yet "[-10.. -5]" and "[-10..5]" work fine? Is there a particular reason for needing a space to separate negative values?
01:04:01 <Cale> ..- is a valid name for an infix operator
01:05:03 <Cale> > let x ..- y = x^2 - y^2 in [5..-3]
01:05:06 <lambdabot>  [16]
01:05:21 <thaostra> Huh, interesting
01:05:25 <thaostra> Thanks
01:22:39 <maybefbi> does anyone know how to install ghc783 on nixos?
01:24:03 <maybefbi> inside https://github.com/NixOS/nixpkgs/pkgs/top-level/all-packages.nix there is ghc783, but when i install haskellPlatform i get ghc763
01:25:24 * dramforever was just impressed by how the ffi accelerates haskell
01:27:50 <carter> maybefbi: ... ask on #nixos?
01:27:59 <maybefbi> carter, ok
01:31:06 <dramforever> by using the ffi, I was able to gain a 10x to 20x speedup
01:31:24 <carter> dramforever: what type of code?
01:31:34 <dramforever> bytestring processing
01:31:44 <carter> of what sort?
01:31:50 <carter> but yeah, that could do it
01:31:54 <dramforever> hard to say..
01:31:56 <carter> the ffi is super easy to use too :)
01:32:05 <dramforever> yeah, very impressed by that too
01:32:28 <dramforever> carter: http://lpaste.net/113032 this thing
01:32:31 <dramforever> it's the original
01:33:00 <dramforever> hrevoice reverses a .wav file so it plays backwards
01:33:05 <dramforever> like -1x speed
01:35:21 <lpaste> dramforever pasted “hrevoice with ffi ( reverse.c )” at http://lpaste.net/113193
01:40:39 <dramforever> carter: actually I thought I was going to spend hours making the ffi work
01:41:03 <dramforever> it turns out to be *really* easy
01:52:41 <d3lxa> I got two implementations of the same (pure) functions and would like to know which one has the best performance, how can I benchmark the easiest way possible?
01:53:24 * dramforever uses the "time" command, although it might be unrealiable
01:53:49 <dramforever> d3lxa: my suggestion would be use it
01:54:20 <dramforever> give it some large data, and measure the time
01:54:56 <dramforever> oh, maybe you are concerned about laziness
01:54:58 <d3lxa> dramforever: can I use "timeit" if I remember correctly it should exist
01:55:20 <dramforever> d3lxa: well, how is your function going to be used?
01:56:06 <d3lxa> dramforever: with a function (a zoomer) and a list
01:56:43 <dramforever> well, the easiest way would be put it into use
01:56:57 <d3lxa> dramforever: these two implementations btw http://sprunge.us/ABQW
01:57:37 <dramforever> d3lxa: does simple timing work? actually, you can even use a stopwatch
01:57:42 <d3lxa> dramforever: seems I screwed up my paste, here again: http://sprunge.us/STRW
01:58:02 <dramforever> d3lxa: did you do timing?
01:58:18 <Cale> d3lxa: You might want to look into using criterion
01:58:19 <d3lxa> not yet, how would you do that?
01:58:37 <dramforever> Cale: how easy is criterion?
01:58:40 <Cale> https://hackage.haskell.org/package/criterion
01:58:50 <Cale> http://www.serpentine.com/criterion/tutorial.html
01:59:09 <Cale> Not that hard
01:59:17 <dramforever> hmm....that's great
01:59:36 * dramforever still thinks that the "time" command is great
02:00:05 <dramforever> d3lxa: yeah you can use criterion
02:02:33 <d3lxa> can do it from ghci?
02:03:05 <d3lxa> (criterion failed to compile, I will stick with timeit)
02:10:58 <d3lxa> alright now I'm in ghci and it tells the package is hidden, because it's not a dependency of my project, I want it anyway, how can I load it?
02:14:38 <dramforever> d3lxa: ghci -package blah
02:14:57 <dramforever> you can also :set -package blah in ghci
02:15:38 <rai> any thoughts how to improve the RandomGen "generation"? https://gist.github.com/anonymous/915b82d7d133b281f8da#file-randomletters-hs-L4-L12
02:17:01 <dramforever> rai: my first idea would be to improve "zipped"
02:17:26 <rai> alright what would that be?
02:17:58 <Total_1mmersion> Is there an easy way to split a Conduit into chunks?
02:18:13 <dramforever> > let customZip (x:xs) (y:ys) = x:y:custom xs ys; customZip [] _ = []; customZip _ [] = [] in customZip [1,3,5,7,9] [2,4,6,8]
02:18:15 <lambdabot>  Not in scope: ‘custom’
02:18:30 <dramforever> > let customZip (x:xs) (y:ys) = x : y : customZip xs ys; customZip [] _ = []; customZip _ [] = [] in customZip [1,3,5,7,9] [2,4,6,8]
02:18:32 <lambdabot>  [1,2,3,4,5,6,7,8]
02:19:02 <dramforever> rai: a intermediate list makes your program *slow*
02:19:38 <rai> didn't realize that
02:19:51 <rai> what part makes it non-lazy?
02:19:57 <dramforever> rai: huh?
02:20:34 <dramforever> rai: non-lazy has nothing to do with speed
02:21:39 <dramforever> for example, one of my programs got faster when "strictified", and another one got slower when "strictified"
02:23:27 <dramforever> rai: constructing and destructing a list takes time
02:24:26 <rai> but it only does work for as many letters as are requested?
02:24:38 <dramforever> rai: yeah
02:25:32 <dramforever> > let customZip (x:xs) (y:ys) = x : y : customZip xs ys; customZip [] _ = []; customZip _ [] = [] in take 20 (customZip [1,3..] [2,4..])
02:25:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
02:25:39 <dramforever> rai: see
02:25:40 <rai> i see. i thought the slow part came from something in my code unnecessarily creating a huge list
02:25:59 <dramforever> rai: well, huge string == huge list
02:27:00 <dramforever> @src String
02:27:00 <lambdabot> type String = [Char]
02:27:26 <dramforever> rai: say...what are you going to do with the string?
02:27:44 <rai> nothing, just an exercise
02:29:18 <dramforever> Hmmm...does anyone here know about the costs of getStdGen and newStdGen?
02:30:09 <Fuco> I'm playing with FFI and Pulse... how do I tell GHCi to link the pulse library (with gcc you'd do -lpulse)
02:30:27 <dramforever> Fuco: with ghc you do the same
02:30:46 <dramforever> e.g.: ghci Blah.hs -lpulse
02:30:58 <dramforever> ghc is like magic
02:31:16 <Fuco> dramforever: can I achieve that from a running ghci? I'm spawning it inside emacs
02:31:25 <dramforever> hmm..
02:32:01 <Fuco> I can change the command to be called for the meantime, but that's a bit ugly
02:33:26 <dramforever> Fuco: does ":set -lpulse" work?
02:33:42 <dramforever> or maybe {-# OPTIONS -lpulse #-}
02:34:44 <Fuco> :set doesn't seem to work
02:34:49 <Fuco> let's see with options
02:35:08 <Fuco> nope :/
02:39:37 <dramforever> https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/flag-reference.html
02:40:06 <dramforever> here look for "-llib"
02:40:40 <dramforever> and you can see the value for "Static/Dynamic" is dynamic
02:41:12 <Fuco> dramforever: I don't know what that means
02:41:14 <dramforever> https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/static-dynamic-flags.html
02:41:27 <dramforever> here it says a dynamic flag can be used in a OPTIONS_GHC
02:41:38 <dramforever> ha! try {-# OPTIONS_GHC -lpulse #-}
02:42:04 <Fuco> aha
02:42:24 <dramforever> it works!
02:42:26 <dramforever> it works?
02:42:34 <Fuco> cool
02:42:57 <dramforever> I assume that by "cool" you mean it works
02:43:07 <Fuco> no
02:43:11 <dramforever> oh?
02:43:19 <Fuco> but maybe it's my problem, let me double check the code
02:43:31 <dramforever> can you paste the error message?
02:44:57 <Fuco> dramforever: http://paste.lisp.org/display/144156
02:45:17 <Fuco> I'm doing this inside haskell: foreign import ccall "pulse/thread-mainloop.h pa_threaded_mainloop_new" c_pa_threaded_mainloop_new :: IO PaThreadedMainloopPtr
02:45:33 <dramforever> you sure it exists?
02:45:39 <Fuco> works from C
02:45:53 <dramforever> does it work from "ghci -lpulse"
02:46:05 <Fuco> yes
02:47:25 <Fuco> gives me: Loading object (dynamic) /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/libpulse.so ... done (when I run ghci -lpulse)
02:47:58 <dramforever> Fuco: I have no more ideas
02:48:36 <freeman42> is there any software which would suggest how to replace ( ) in haskell code with . or $ ?
02:49:12 <Fuco> dramforever: thanks anyway, I'll look online further
02:49:32 <Fuco> for the meantime I'll just spawn ghci with -lpulse hardcoded
02:50:08 * dramforever spends his free time online trying to be helpful to people who helped him
02:50:29 <dramforever> and usually fails
02:50:46 <freeman42> for example to suggest how to remove more () from here if possible: filter (((==) 2) . length) $ subsequences "ABC"
02:51:33 <CARAM> so I have a list I want to map a function over
02:51:35 <Fuco> freeman42: you don't need the () around (==) 2
02:51:59 <Fuco> freeman42: hlint might tell you that, maybe
02:52:21 <dramforever> freeman42: your example is slow
02:52:30 <CARAM> BUT I need to pipe the output of f(n-1) for the next element
02:52:41 <CARAM> anyone have any thoughts on how to do this?
02:52:55 <CARAM> need to pipe it to the function that is
02:53:06 <dramforever> let blah x = zip x (tail x) in blah [1,2,3,4,5,6]
02:53:12 <dramforever> > let blah x = zip x (tail x) in blah [1,2,3,4,5,6]
02:53:14 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
02:53:26 <dramforever> > let blah x = zipWith (+) x (tail x) in blah [1,2,3,4,5,6]
02:53:27 <lambdabot>  [3,5,7,9,11]
02:53:36 <dramforever> CARAM: does that give what you want?
02:55:08 <dramforever> CARAM: oh turns out you need f(n-1)
02:55:12 <CARAM> yeah
02:55:16 <dramforever> unfoldl
02:55:17 <CARAM> sorry I was checking
02:55:19 <dramforever> :t unfoldl
02:55:20 <lambdabot>     Not in scope: ‘unfoldl’
02:55:20 <lambdabot>     Perhaps you meant one of these:
02:55:20 <lambdabot>       ‘Seq.unfoldl’ (imported from Data.Sequence),
02:55:25 <dramforever> :t unfold
02:55:25 <lambdabot>     Not in scope: ‘unfold’
02:55:26 <lambdabot>     Perhaps you meant one of these:
02:55:26 <lambdabot>       ‘gunfold’ (imported from Data.Data),
02:55:31 <dramforever> hmmm...
02:55:32 <freeman42> dramforever, curious about what you used to time it. or it can be seen from the code structure?
02:55:50 <zwer> > filter ((==2) . length) $ subsequences "ABC"
02:55:52 <lambdabot>  ["AB","AC","BC"]
02:56:07 <dramforever> freeman42: well, I can tell by seeing subsequences
02:56:16 <freeman42> Fuco, thank you, I think you are correrct about hlint, iirc eclipsefp recommended to remove ()'s when not needed
02:56:24 <dramforever> > length (subsequences "abcdefghikl")
02:56:26 <lambdabot>  2048
02:56:31 <dramforever> > length (subsequences "abcd")
02:56:33 <lambdabot>  16
02:56:53 <freeman42> dramforever, isn't the fact that haskell is lazy supposed to handle that? I have no idea :D
02:57:09 <dramforever> freeman42: nope, I thinkg
02:57:11 <dramforever> freeman42: nope, I think
02:57:16 <freeman42> or it can't get the length without generating them first
02:57:28 <dramforever> yeah that's one thing
02:57:48 <dramforever> the other thing is that you need to make 2^n sequences and filter from them
02:57:49 <u-ou> @src subsequences
02:57:50 <lambdabot> Source not found. You speak an infinite deal of nothing.
02:59:48 <dramforever> > let loop xs | length (take 2 xs) < 2 = []; loop xs = take xs : loop (tail xs)
02:59:49 <lambdabot>  not an expression: ‘let loop xs | length (take 2 xs) < 2 = []; loop xs = tak...
02:59:56 <dramforever> > let loop xs | length (take 2 xs) < 2 = []; loop xs = take xs : loop (tail xs) in loop "ABC"
02:59:58 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
02:59:58 <lambdabot>              with actual type ‘[a1]’
02:59:58 <lambdabot>  Relevant bindings include
02:59:58 <lambdabot>    xs :: [a1] (bound at <interactive>:1:49)
02:59:58 <lambdabot>    loop :: [a1] -> [[a2] -> [a2]] (bound at <interactive>:1:5)
03:00:17 <dramforever> > let loop xs | length (take 2 xs) < 2 = []; loop xs = take 2 xs : loop (tail xs) in loop "ABC"
03:00:19 <lambdabot>  ["AB","BC"]
03:00:33 <dramforever> ouch
03:00:42 <rai> dramforever: thanks for the help
03:00:45 <dramforever> freeman42: sorry I misunderstood you
03:01:56 <freeman42> I am confused now :) it does work ok?
03:02:36 <zwer> asdfasdf.
03:06:05 <zappo1> what is Haskell?
03:06:36 <happy0> zappo1: i'm intrigued how you would come across this channel without knowing anything about haskell =p
03:06:46 <happy0> please, tell me of your journey!
03:06:49 <zappo1> I'm new...
03:06:59 <zappo1> just reading about it now actually
03:07:06 <happy0> good choice :D
03:07:17 <exio4> it is a pure functional programming language with mathematical weird words for everything
03:07:28 <happy0> accurate :D
03:08:01 <CARAM> gonna post my q again incase anyone else has an idea
03:08:07 <CARAM> so I have a list I want to map a function over
03:08:20 <CARAM> BUT I need to pipe the output of f(n-1) to my function for the next element
03:08:58 <CARAM> am I gonna need to learn the state monad thing??
03:09:05 <happy0> CARAM: i may have misunderstood your question, but does scanl perhaps help?
03:09:13 <happy0> :t scanl
03:09:14 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
03:09:31 <mauke> CARAM: you can zipWith the tail of your list
03:09:42 <mauke> oh, the output
03:10:43 <michi7x7> pjdelport: just realized, that my algorithm is really badly designed for parallelism :/
03:10:47 <CARAM> scanl looks like what I want I think
03:10:54 <happy0> oh man. i was helpful :D
03:10:56 <happy0> feels good, CARAM
03:10:57 <CARAM> thank you happy0
03:11:03 <happy0> this is a new sensation!~
03:11:16 <zappo1> woopee
03:12:40 <michi7x7> mauke: you can also zipWith recursive
03:13:54 * hackagebot remote-debugger 0.1.0 - Interface to ghci debugger  http://hackage.haskell.org/package/remote-debugger-0.1.0 (atsky)
03:15:42 <JagaJaga> Guys. Using ipv4 as Word32. I see others ip as (92.12.33.192) not as (192.33.12.92). How to make it beeing normal? Reverse?....
03:16:18 <michi7x7> > fix $ \b -> 0 : zipWith (+) [1..10] b
03:16:21 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
03:22:44 <mauke> JagaJaga: how are you using it?
03:22:49 <freeman42> what is this http://i.imgur.com/tZKEzvn.png I don't even O.o'
03:23:14 <mauke> freeman42: fix is recursion in a box
03:24:15 <JagaJaga> mauke: data IPv4 = IPv4 !Word32
03:24:44 <JagaJaga> mauke:put (IPv4 b0) = put b0
03:24:57 <JagaJaga> mauke: get = IPv4 <$> get
03:25:02 <michi7x7> > let b = 0 : zipWith (+) [1..10] b in b
03:25:04 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
03:25:10 <JagaJaga> mauke: smth like this...
03:25:20 <mauke> is this from Network.Info?
03:25:25 <JagaJaga> mauke: yeah.
03:25:33 <michi7x7> freeman42 ^
03:25:55 <mauke> JagaJaga: ok, so where are you getting your ip addresses from?
03:26:29 <JagaJaga> mauke: by using getNetworkInterfaces :)
03:26:50 <JagaJaga> mauke: then putting it in a bytestring message
03:27:55 <mauke> huh
03:30:41 <JagaJaga> mauke: ideas? :(
03:31:45 <mauke> no, but you haven't given me much information either
03:32:00 <michi7x7> JagaJaga: Prelude Network.Info Control.Applicative> (ipv4 . head) <$> getNetworkInterfaces  ... prints "127.0.0.1" here
03:32:09 <JagaJaga> mauke: forgot to say, that using just my client-server program - everything is ok, using other's programs getting this. Other's programs with other's program works ok. So this is a haskell's trouble.
03:32:33 <freeman42> michi7x7, staring at it but not sinking in, what I got until now is that let can be used recursively, but no idea what fix f = let x = f x in x does, it looks like a recursive function that does not know when to stop and I am surely misunderstanding that
03:32:34 <mauke> that makes no sense
03:33:42 <michi7x7> freeman42: fix gives a recursive variable to a lambda (b in my case)... when you use b it will recurse
03:33:43 <JagaJaga> mauke: so ok, another way. How to put ip into 4 bytes bytestring?
03:34:27 <michi7x7> JagaJaga: always do serialization in network byte order or cleartext
03:34:40 <michi7x7> if that's what you mean
03:34:46 <mauke> no
03:35:07 <mauke> JagaJaga: let's go back to the beginning: <mauke> JagaJaga: how are you using it?
03:35:53 <JagaJaga> mauke: I have protocol. ipv4(4bytes)mac(6bytes)
03:35:59 <JagaJaga> mauke: mac is ok
03:36:02 <mauke> no, show your code
03:36:40 <JagaJaga> mauke: oh, sure https://github.com/jagajaga/network/blob/master/work1/src/Main.hs
03:37:47 <mauke> ok. how are you running it, what does it do, and what did you expect it to do?
03:39:26 <JagaJaga> mauke: :) It sends messages like i wrote (ip+mac+surname). It recieves them and showing oh messages it recieved (like list of clients). Some kind of heartbeat and listing active clients.
03:42:06 <mauke> you're paraphrasing too much
03:42:57 <JagaJaga> mauke: should I try to write it easier? :(
03:44:36 <JagaJaga> mauke: well, the part where the trouble comes - I'm getting my ip and mac using getNetworkInterfaces and getting them on wifi interface. Then packing them and sending using udp broadcast.
03:44:47 <michi7x7> JagaJaga: the problem is after you transferred it to another PC? the Bytes in ipv4 are in the wrong order?
03:44:58 <JagaJaga> michi7x7: yes!
03:45:42 <michi7x7> mauke: does Data.Binary handle byte-order?
03:45:46 <mauke> no idea
03:45:56 <mauke> JagaJaga: you shouldn't write it at all
03:46:09 <mauke> all I'm getting so far is your interpretation of the facts, not the facts
03:46:23 <mauke> and I'm only like 10% here anyway
03:46:30 <michi7x7> JagaJaga: yeah, Data.Binary serializes to network byte order
03:47:37 <JagaJaga> mauke: well, fact is that i'm getting wrong byte order. Question - how to reverse them? :)
03:48:34 <mauke> no, that's not a fact
03:48:39 <mauke> that's your guess
03:49:20 <JagaJaga> mauke: maybe there is a function to reverse bytes in word?
03:49:51 <JagaJaga> :t byteSwap32
03:49:52 <lambdabot> Word32 -> Word32
03:49:55 <JagaJaga> oh!
03:50:29 <JagaJaga> nice.... :)
03:50:32 <JagaJaga> that worked.
03:52:56 <gspr> I prefer to stay with distro packages of things, so I'm stuck on ghc-mod 4.1.2. Is there any known workaround for it consuming hundreds of MB for *each* Haskell source file I have open in Emacs?
03:54:05 <JagaJaga> gspr: there is a #ghc-mod
03:54:25 <michi7x7> JagaJaga: you somewhere broke your Binary-conversion
03:55:29 <JagaJaga> michi7x7: i've just adapted to others...
03:55:31 <michi7x7> JagaJaga: https://gist.github.com/michi7x7/afc7d2531d6a04c1a3f0 using your instance
03:56:16 <JagaJaga> michi7x7: yeah, inside haskell's env everuthing is ok
03:56:31 <JagaJaga> s/uth/yth
03:57:03 <michi7x7> well no, the binary stream is in network byte-order and is transmitted as-is
03:57:55 <JagaJaga> michi7x7: maybe haskell decodes in other way?
03:58:05 <JagaJaga> be le smth like this
03:59:36 <gspr> JagaJaga:Ah, thanks
04:00:02 <vlatkoB_> I'm having problem specifying instance for a class function. Can someone show me the syntax? Code at http://lpaste.net/113195
04:03:07 <supki> @quote type.families.are.not.injective
04:03:08 <lambdabot> dmwit says: Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
04:03:32 <supki> vlatkoB_: the problem here is that there could potentially be many IsEvent instances where EventType t = Bump
04:03:48 <dramforever> vlatkoB_: Who wrote IsEvent?
04:04:01 <vlatkoB_> dramforever: I did
04:04:19 <vlatkoB_> supki: So, no solution, must change the design?
04:04:36 <dramforever> varuser: what do you mean by design
04:05:08 <vlatkoB_> the design of the code :-)
04:05:29 <dramforever> well, I guess so
04:06:00 <dramforever> the Parser (EventType t) type does not give information for the compiler to decide which instance to use
04:06:16 <dramforever> so it's ambiguous
04:06:47 <dramforever> hey, does (parseEvent :: Parser (EventType Bump)) work?
04:07:01 <dramforever> oh maybe not
04:10:51 <vlatkoB_> supki: What do you mean there could be many IsEvent instances? If I try to make another instance with Bump as EventType t, I get error.
04:12:51 <vlatkoB_> Ups, my bad. You can...
04:12:52 <mietek> Does hsc2hs even build with GHC 7.8.3?
04:13:17 <mietek> It pulls in directory-1.0.0.3, which fails with "Could not find module ‘GHC.IOBase’"
04:13:26 <vlatkoB_> Thanks for clarification guys
04:39:09 <d3lxa> I have a problem with esqueleto, it generates a query with joins that is not what I meant, moreover the order of my join lines are important but it's implementation specific, thus my query may break in the future, any idea got an idea? Clohttp://sprunge.us/CjbX
04:41:06 <d3lxa> prettier query http://sprunge.us/fdBf
04:42:14 <d3lxa> ^ see the ordering of the part after FROM … JOIN … << it should take the ordering of my joins (first line) and not my conditions later (2nd, 3rd lines), is it a bug?
04:44:44 <Cale> d3lxa: I have no idea what's going on there, but you might find it convenient to add at least a second import line to import the infix operators unqualified
04:46:42 <d3lxa> Cale: oh, the problem is that most of the things in esqueleto collide with persistent, that's why
04:46:53 <Cale> ah, that's unfortunate
04:47:08 <d3lxa> yeah, I would appreciate scoped imports for that :D
04:47:27 <d3lxa> { import Esqueleto; my super code without noisy E. … } but it's haskell so "no no"
04:48:45 <Cale> What's incorrect?
04:49:29 <d3lxa> Cale: you cannot do local import in haskell… I guess
04:49:38 <Cale> I'm sorry, I mean with the query
04:51:26 <d3lxa> Cale: the join are not in the same ordering thus it fails because one of my column is null and I want them, that's a left outer join :)
04:52:17 <d3lxa> Cale: simplified: incorrect one is (not-null-col join nullable-col) left outer join not-null-col where the correct one is (not-null-col join not-null-col) left outer join nulalble-col
04:52:36 <Cale> d3lxa: I'm just confused about why the correct one is correct if the incorrect one isn't -- things appear to be swapped around in exactly the way you'd expect.
04:52:50 <d3lxa> the ordering depends on my two conditions and not the line at the top :S
04:53:14 <d3lxa> Cale: ok, can you explain the logic becaues I couldn't understand
04:53:28 <Cale> Well, I'd have to actually understand the monad which is being used here
04:54:00 <Cale> but it's often not the case that do x; y is the same as do y; x
04:54:17 <Cale> Let me have a look at the docs for Esqueleto
04:56:17 <Cale> Ah, I think I see what you mean...
05:02:07 <d3lxa> if there is a rational explanation of the ordering I would really appreciate but if that's a technical detail of the implementation, that would be bad
05:02:37 <malllle>  parse (many1 (letter <* endOfLine)) "" "a\nB\n" -- works how do i get it to parse "a\nB" too?
05:02:48 <malllle> with parsec it is
05:04:16 <mauke> parse (many anyChar)
05:04:22 <malllle> nvm spaces instead of endOflLine
05:04:40 <mauke> > words "a\nB"
05:04:44 <lambdabot>  ["a","B"]
05:04:57 <Eduard_Munteanu> malllle, letter `sepBy` endOfLine?
05:05:25 <Eduard_Munteanu> sepBy1 even
05:06:01 <malllle> Eduard_Munteanu: parse (letter `sepBy1` endOfLine) "" "a\nB\n" -- unexpected end of input expecting letter :)
05:06:47 <malllle> Eduard_Munteanu: sepEndBy1 works, thx
05:06:48 <Eduard_Munteanu> letter `sepBy1` endOfLine *> optional endOfLine
05:07:10 <Eduard_Munteanu> I thought endBy required the last delimiter.
05:07:29 <Eduard_Munteanu> Perhaps there's a new sepEndBy thing.
05:07:46 <vlatkoB_> Is there another way to send dummy arg of certain type than this: parseEvent (undefined :: Bump)?
05:07:50 <malllle> sepEndBy p sep parses zero or more occurrences of p, separated and optionally ended by sep
05:08:09 <Eduard_Munteanu> vlatkoB_, what is Bump?
05:08:33 <malllle> mauke: thx, this was a reduced example
05:08:59 <vlatkoB_> Eduard_Munteanu: Just a type I declared. This works fine, but maybe there is a better way
05:09:27 <Eduard_Munteanu> vlatkoB_, well, what do you expect parseEvent to do with its argument?
05:10:09 <Eduard_Munteanu> vlatkoB_, is it only supposed to dispatch based on the type of its argument, i.e. is it a class method?
05:10:12 <vlatkoB_> Nothing, I needed it so the compiler knows which instance to use.
05:10:25 <vlatkoB_> Yes
05:10:53 <Eduard_Munteanu> vlatkoB_, then consider making it parseEvent :: Proxy a -> ...
05:11:15 <Eduard_Munteanu> Then you call it like parseEvent (Proxy :: Proxy Bump)
05:13:33 <Cale> d3lxa: Have a look at http://hackage.haskell.org/package/esqueleto-2.1.0/docs/Database-Esqueleto.html#v:on
05:13:55 <Cale> "If you have many joins, then the ons are applied on the reverse order that the JOINs appear."
05:14:06 * hackagebot remote-debugger 0.1.1 - Interface to ghci debugger  http://hackage.haskell.org/package/remote-debugger-0.1.1 (atsky)
05:14:43 <d3lxa> Cale: ok and that's weird, you have to think backward :S
05:14:56 <d3lxa> I guess this he discovered later and documented it :S
05:15:11 <Cale> He gives a reason for it to be like that
05:16:23 <d3lxa> Cale: oh, I see now, thanks for forcing me to read completely :D
05:16:30 <vlatkoB_> Eduard_Munteanu: Thanks, works like a charm and looks nice.
05:53:17 <malllle> > zip [0..] "ab\n\ncd\n"
05:53:20 <lambdabot>  [(0,'a'),(1,'b'),(2,'\n'),(3,'\n'),(4,'c'),(5,'d'),(6,'\n')]
05:53:30 <malllle> > zip [0..] $ lines "ab\n\ncd\n"
05:53:32 <lambdabot>  [(0,"ab"),(1,""),(2,"cd")]
05:54:07 <malllle> how can i do that with the empty lines getting in that list?
05:54:14 <malllle> +not
05:54:49 <malllle> i can filter afterwards but this would traverse the lsit twice?
05:55:43 <exio4> > zip [0..] $ filter (not.null) (lines "a\n\nb\n\nc\n\n\n\nd"
05:55:44 <lambdabot>  <hint>:1:60:
05:55:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:55:46 <exio4> > zip [0..] $ filter (not.null) (lines "a\n\nb\n\nc\n\n\n\nd")
05:55:48 <lambdabot>  [(0,"a"),(1,"b"),(2,"c"),(3,"d")]
05:55:48 <slomo> if list fusion works properly, then it would only traverse the list once
06:02:26 <joe9> I am trying to understand this: http://stackoverflow.com/a/10237311  . What do the functions yield and step do there, please? (in English and not Haskell, please)  What is the expected functionality for "mutate" there?
06:05:38 <malllle> thx
06:07:17 <joe9>  Or, does anyone have an example of how the above code can be used, please?
06:07:45 <jchmrt> would this be the right place to ask a question about lambdabot? I installed it from the ubuntu repositories, because I was unable to install it from source. But when i launch it and try to evaluate an expression with '>', it says "mueval-core: GhcException "cannot satisfy -package lambdabot\n    (use -v for more information)"
06:08:20 <jchmrt> but when i launch mueval on its own it can evaluate expressions
06:12:17 <Fuco> is there some emacs haskell mode which understands chs? (the files fed into c2hs)
06:18:18 <MindIsAVortex> hello, Im trying to declare a spaceship as being three coords in a plain, why am I getting the error that "ship :: [(Float, Float), (Float, Float), (Float, Float)]" is an illegal datatype?
06:18:44 <simukis_> is there a function to read a single byte from a Handle (??? :: Handle -> Word8)
06:19:26 <zomg> MindIsAVortex: because you can't declare a datatype as a list with a specific number of items
06:19:29 <exio4> MindIsAVortex: a list doesn't have a fixed length, that would be [(Float,Float)]
06:20:32 <MindIsAVortex> zomg: oh darnit, I see it now, what a silly thing to do, hehe total noob here. Thanks!
06:20:53 <zomg> np, maybe make it into an actual data type :)
06:21:22 <MindIsAVortex> how so?
06:21:44 <MindIsAVortex> just [(Float, Float)] right?
06:21:57 <zomg> as in, data Ship = Ship { x :: (Float, Float), y :: (Float, Float), z :: (Float, Float) }
06:22:02 <zomg> or whatever the coords are
06:22:53 <MindIsAVortex> aaaah, could do yeah... it is itself already inside of a similar data construct
06:22:58 <MindIsAVortex> called World
06:23:24 <geekosaur> simukis_, probably System.Posix.IO.fdReadBuf but you need to get a Ptr Word8 from somewhere (Foreign.Marshal.Array.allocaArray ?)
06:23:52 <zomg> MindIsAVortex: sure, once you do that, you can just make your World `data World = World { ship :: Ship, ...... }`
06:24:06 <zomg> or however you're defining it
06:24:24 <simukis_> geekosaur: will investigate, thanks.
06:27:05 <MindIsAVortex> zomg: ok, that actually looks like it would result in some neater code
06:27:10 <MindIsAVortex> I'll try it out
06:31:13 <joe9> geekosaur: could you please explain what step, mutate and yield do here : http://stackoverflow.com/a/10237311 , if you do not mind  ?
06:31:28 <joe9> geekosaur: I am trying to understand the code there but could not.
06:37:31 <sritchie> hey all - I’m trying to debug an issue with cabal -
06:37:43 <sritchie> basically, I’ve installed some packages (hlint in particular), and can’t track them down on my path
06:37:58 <sritchie> they’re not in ~/Library/Haskell/bin -
06:38:03 <sritchie> but cabal reports that hlint is installed
06:38:12 <sritchie> I’ve installed ghc and cabal with homebrew
06:38:41 <saep> ~/.cabal/bin ?
06:38:54 <sritchie> :) there it is
06:38:57 <dcoutts_> sritchie: check your cabal config file to see what bin dir has been specified (or if it's the default)
06:38:59 <sritchie> couldn’t find that, for some reason
06:39:25 <alpounet> joe9: what bits exactly are problematic for you?
06:39:29 <dcoutts_> sritchie: you can configure it to use ~/Library/Haskell/bin or anywhere else you like
06:39:57 <sritchie> dcoutts_: this is at the end of a long debugging session triggered by installing the homebrew versions over top of haskell platform
06:40:01 <sritchie> and trying to nuke recursive dependencies
06:40:07 <sritchie> looks like I’m all set, though!
06:40:15 <dcoutts_> sritchie: iirc, cabal that comes with the platform for OSX uses ~/Library/Haskell/bin, but the default if unspecified is actually ~/.cabal/bin
06:40:22 <joe9> alpounet: what do the "step", "mutate" and "yield" functions do? (in English and not as haskell types)
06:43:03 <joe9> alpounet: I am trying to understand what those functions do.
06:43:16 <alpounet> joe9: sure, let's make that happen
06:43:24 <joe9> alpounet: thank you so much.
06:44:04 <alpounet> joe9: alright, first, do you feel comfortable with the definitions of Pause and PauseResult ?
06:44:28 <joe9> alpounet: I understand them.
06:44:54 <randomlogin> I'm installing leksah, all the dependence packages are installed successfully except gio. The error:
06:44:57 <phaazon> hi
06:44:59 <joe9> alpounet: What does the step function do?
06:45:29 <joe9> alpounet: from what I understand, this monad can be used to stop the computation and continue it back later.
06:45:55 <randomlogin> Configuring gio-0.13.0.2...
06:45:55 <randomlogin> setup: gtk2hsHookGenerator: Invalid character in input file:
06:45:55 <randomlogin> GLIBS
06:45:55 <randomlogin> Configuring gio-0.13.0.2...
06:45:55 <randomlogin> setup: gtk2hsHookGenerator: Invalid character in input file:
06:45:55 <randomlogin> GLIBS
06:45:55 <randomlogin> Configuring gio-0.13.0.2...
06:47:16 <joe9> alpounet: For example, when implementing a function, I could pause the function and then continue it later, correct?
06:47:24 <alpounet> joe9: exactly. step will run a Pause computation until it encounters a Suspend, which holds "what to run next" but doesn't actually run it. it hands you back just that along with the state 's' that may have been modified through calls to put until the Suspend was hit
06:48:37 <joe9> alpounet: "yield" pauses the computation ie., puts the computation in a pause state?
06:48:41 <alpounet> so the state it hands you back along is the result of running the Pause computation until the first Suspend -- that makes it possible to go through calls to put, for example, because 'put' doesn't by itself suspend the computation.
06:49:34 <alpounet> joe9: yes exactly. 'yield' here means "there: at this point, we'll hand back a Suspend along with the state as it is right now"
06:49:38 <phaazon> “And then the continuation monad allows you to break people's minds!” – ahah
06:49:58 <exio4> I didn't know it was used for something else!
06:51:46 <phaazon> exio4: I tried to understand the use case to do dependencies resolving in my 3D engine, I gave up
06:54:43 <phaazon> little survey: who here has already been told of monad-journal?
06:54:53 <phaazon> I’m so impressed about how much downloads I get for it
06:54:59 <phaazon> it was unexpected
06:55:06 <phaazon> maybe it’s thanks to stackage
06:55:16 <phaazon> how many*
06:55:19 <joe9> alpounet: Would it be hard to write a simple example using that code?
06:55:47 <alpounet> joe9: i started writing that a minute ago :)
06:55:54 <alpounet> give me a moment to wrap it up
06:55:56 <joe9> alpounet: thanks.
07:06:03 <lpaste> Alp pasted “Pause -- joe9” at http://lpaste.net/113205
07:06:37 <joe9> alpounet: thanks.
07:06:41 <alpounet> joe9: ^^^ an example with some output to help you reason about what's going on
07:06:52 <alpounet> do not hesitate to add some more put and yield and what not to get a good grasp of what's going on
07:08:01 <joe9> alpounet: will do. thanks a lot for doing this.
07:09:51 <farnsworth9> Hello.  I’m writing a calculator app that allows users to define variables, functions, etc.  To keep track of this information I have an “Environment” object that I pass around using the state monad.  As I go on to more user settings (i.e. calculate using degrees instead of radians) I want to find a better way to pass around the information than bloating the Enviroment object.  Can anyone offer advance, either for a bett
07:09:51 <farnsworth9> data structure or a better architecture?
07:11:03 <phaazon> farnsworth9: how do you use your Environment?
07:12:17 <piskrist> https://gist.github.com/yaccz/4b7cbb6e476bb25abe34 how can I debug this cabal install errors?
07:12:21 <farnsworth9> phaazon: I’m not sure what you mean.  Can you be more specific?  In the code or as a general entity?
07:12:23 <alpounet> joe9: let me/us know if some things are still not clear to you
07:13:23 <phaazon> farnsworth9: well, you’re building a calc. then you might have some kind of a tree structure
07:13:28 <dcoutts_> piskrist: take a look at the build log file it mentions
07:13:28 <phaazon> where do you mean the Environment?
07:13:58 <dcoutts_> piskrist: but also note that you probably don't have to install process, since it's already installed
07:14:08 <dcoutts_> unless there's a good reason you need a different version
07:14:16 <piskrist> dcoutts_: that doesn't say anything else than already in the output
07:14:26 <piskrist> dcoutts_: I need neewer version in the sandbox
07:14:35 <farnsworth9> phaazon:  So the expression is parsed into an abstract syntax tree, then when I’m evaluating it, if I run across a variable or function, I look it up in a Map that I get from the Env
07:14:45 <dcoutts_> piskrist: so it looks like it's failing linking the Setup.hs
07:14:57 <piskrist> dcoutts_: the build log says just "Linking ..." and nothing else
07:15:04 <piskrist> yeah, but how can I find out more
07:15:07 <phaazon> farnsworth9: I came across that situation too a few days ago
07:15:12 <dcoutts_> piskrist: this can happen on VMs with very little memory. You can check by running the configure step directly with -v3
07:15:22 <phaazon> I resolved that with bound (the library), but that’s a bit hard to get your feet wet :D
07:15:37 <joe9> alpounet: What does "mutate" do?
07:16:12 <phaazon> ok, hm, you have something like : data Env = Env { userMem :: Map String -> Float } and so on and so forth?
07:16:35 <alpounet> joe9: it's not defined in the SO answer, but it just applies a function to the state. mutate f = do { currentState <- get ; let newState = f currentState ; put newState }
07:17:18 <farnsworth9> phaazon: Yes, and I do some pattern matching when I need multiple maps, so I don’t want to keep expanding those patterns with _ _ _ _ ...
07:17:26 <phaazon> farnsworth9: “turn degrees into radians” sounds to be a good match in a reader ;)
07:18:04 <farnsworth9> phaazon: I haven’t used the reader monad, how would it apply here?
07:18:17 <phaazon> when, in the UI, the user ask to turn degrees into radians, just change the reader to use a new conversion function
07:18:21 <alpounet> joe9: try replacing one of my "put"s by e.g "mutate (+1)"
07:18:29 <phaazon> farnsworth9: it enables you to introduce an environment in your computation
07:18:33 <alpounet> using the mutate definition i gave above
07:18:39 <alpounet> and see how that affects the output
07:18:41 <phaazon> (an immutable env, you can’t change it)
07:19:00 <piskrist> dcoutts_: https://gist.github.com/yaccz/7f73df399aa9b91e531d
07:19:02 <phaazon> if you want to change it, you can do it locally, or replace the whole monad (you have to do that outside of the computation)
07:19:04 <piskrist> not much better
07:19:19 * hackagebot gmndl 0.4.0.2 - Mandelbrot Set explorer using GTK  http://hackage.haskell.org/package/gmndl-0.4.0.2 (ClaudeHeilandAllen)
07:19:48 <farnsworth9> phaazon: Would that be in addition to the state monad or compliment it?
07:21:20 <phaazon> farnsworth9: I think it complements it because you are not going to change the way you compute angles in an expression
07:21:20 <dcoutts_> piskrist: the linking is clearly failing. It does not link the setup, and then running it returns code 127 (ie it does not exist)
07:21:39 <phaazon> your State is used to reduce your expression
07:22:03 <farnsworth9> Makes sense
07:22:06 <phaazon> the Reader could be used to parameterize the way the computation is reduced
07:22:13 <phaazon> so you can have, for instance
07:22:27 <phaazon> a function Float -> Float that represents the conversion :)
07:22:37 <dcoutts_> piskrist: as I said, you can try running the configure step (not install) with -v3, find the command used to compile the setup and run that manually
07:22:51 <phaazon> degToRad :: Float -> Float ; degToRad x = x * pi / 180
07:22:53 <dcoutts_> piskrist: but if you happen to be using a VM with very low memory then that's likely the cause
07:23:00 <phaazon> and reverse for radToDeg
07:23:03 <phaazon> and pass that in your Reader
07:23:09 <piskrist> dcoutts_: I've got 3G memory free
07:23:28 <phaazon> and because you want both Reader and State, I recommend using RWS
07:23:28 <piskrist> dcoutts_: interesting is that the build log says the configure failed
07:23:39 <phaazon> (maybe you’ll want logging aftewards :))
07:23:52 <dcoutts_> piskrist: it's correct, compiling the Setup.hs is part of the configure step
07:24:23 <Enzoray> Erm, excuse me. Does anyone have any tips to learn Haskell?
07:24:50 <farnsworth9> phaazon: Thanks so much for your help
07:25:29 <pjdelport> Enzoray: Have fun, follow your interests, and ask questions. :)
07:25:36 <alpounet> Enzoray: https://github.com/bitemyapp/learnhaskell/blob/master/README.md gives good pointers
07:26:11 <phaazon> farnsworth9: in my opinion, you’re state must have 1. user vars ; 2. user functions ; 3. (extra) user programs (set of expressions)
07:26:27 <Enzoray> Thanks. :)
07:26:34 <phaazon> farnsworth9: and about angles
07:26:50 <phaazon> you can also use a new type for them, more convenient for your computations
07:26:59 <phaazon> like instead of Float, data Angle = Rad Float | Deg Float
07:27:55 <phaazon> you can then write a function that works with Angle, and stop being worrying about whether user’s using radians or degrees :)
07:28:38 <farnsworth9> phaazon: Interesting idea.  It might be tricky to know when to construct that type though
07:29:30 <phaazon> what do you mean?
07:29:46 <Enzoray> Would you guys recommend learnyouahaskell? Is it a good tutorial book? - I'm quite new, I've tried C# and Python.
07:29:58 <phaazon> Enzoray: definitely
07:30:03 <phaazon> read it
07:30:08 <joe9> Enzoray: yes, after that, check out rwh.
07:30:14 <Enzoray> rwh?
07:30:16 <phaazon> I think it’s the best first-approach Haskell learning material out there
07:30:24 <phaazon> Real World Haskell
07:30:26 <sivteck> @where RWH
07:30:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:30:37 <phaazon> start with LYAH
07:30:43 <phaazon> RWH is there initiate haskellers :)
07:30:46 <phaazon> for*
07:31:14 <Enzoray> Thanks for the help guys, really appreciate it! :)
07:31:14 <joe9> Enzoray: for me, learning haskell syntax did not do it for me. There was a guy called pastorn on #haskell who taught me how to code using data structures.
07:31:28 <joe9> Enzoray: that just changed my programming style.
07:31:44 <joe9> Enzoray: keep posting as much code as you can here and ask for feedback.
07:32:13 <Enzoray> joe9: Will do. :)
07:32:28 <phaazon> joe9: the haskell syntax is the more pure ever made
07:32:43 <phaazon> a friend asked me to help him with his scala courses
07:32:45 <Fuuzetsu> yet some people still find a way to bitch about it ;P
07:32:46 <phaazon> and damn
07:32:49 <phaazon> scala’s so ugly
07:33:15 <farnsworth9> phaazon: I guess I would do something like define the sin function to take in a float, use the reader’s angle function to figure out what kind of angle it is, then perform the calculation appropriately?
07:33:19 <phaazon> Fuuzetsu: well, give them some C++ expression templates to deal with
07:33:24 <phaazon> they’ll change their minds :D
07:33:45 <Fuuzetsu> at least C++ doesn't use braindead whitespace-sensitive syntax which is impossible to grasp!
07:33:50 <phaazon> farnsworth9: that depends on how you define functions in your ast
07:33:58 * Fuuzetsu grumbles
07:33:59 <phaazon> if your function is in your structure
07:34:05 <phaazon> like data E = … | Sin …
07:34:10 <phaazon> just feed it with Angle :)
07:34:42 <phaazon> hm well, no, don’t :)
07:34:54 <phaazon> it would be Sin (E …)
07:35:02 <farnsworth9> Functions are just a Map String (Float -> Float)
07:35:15 <phaazon> ok
07:35:28 <phaazon> so you might have ("sin",sin) then
07:35:33 <farnsworth9> technically [Float] -> Float for multivariable
07:35:57 <phaazon> ok, then ("sin",sin . head)
07:36:18 <joe9> alpounet:  I think I get it now. The monad ("computation builder") changes the way two functions are linked by adding the Pause data structure over the actual computation.
07:36:24 <phaazon> well, maybe you want to modify this
07:36:31 <phaazon> how do you do that:
07:36:41 <Enzoray> When you define a function ex.
07:36:47 <phaazon> sin (3 + "x")
07:37:00 <Enzoray> LolFace :: Integer -> Double
07:37:07 <joe9> alpounet: and, then it is a matter of "stepping" through that computation using the fst of the tuple to go to the next step.
07:37:16 <phaazon> Enzoray: haskell has type convention
07:37:17 <Enzoray> What does that mean? Integer -> Double part
07:37:20 <phaazon> LolFace here is a constructor
07:37:26 <phaazon> it takes an Integer
07:37:30 <phaazon> and outputs a Double
07:37:52 <phaazon> length :: String -> Int
07:37:54 <phaazon> it takes a String
07:38:00 <phaazon> and returns an Int (its size)
07:38:03 <Enzoray> int being the lenght in numbers?
07:38:07 <phaazon> yep
07:38:23 <Enzoray> I think Haskell is a bit to clever sometimes.
07:38:28 <phaazon> in reality, length is a bit more generic, but that’s the idea
07:38:36 <Fuuzetsu> too clever how
07:38:37 <phaazon> length :: [a] -> Int
07:38:39 <Fuuzetsu> nothing clever is happening
07:38:50 <alpounet> joe9: the monad instance does two things. first, it passes the state to computations and gets the new one from the result of the computation. second, to chain two computations, if the first one gives a Done, it immediately passes its result to the second and evaluates that. but if the first yields a suspend, the monad instance sequences the second computation _in_ the suspend block instead of directly computing it.
07:39:08 <alpounet> joe9: yeah i think you get the idea :)
07:39:21 * hackagebot resource-pool 0.2.3.1 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.3.1 (BasVanDijk)
07:39:25 <beanandgone> hi, anybody knows if the Edward Kmett's "Proposal: Simplify/Generalize Data.Dynamic" is implemented somewhere already? (http://comments.gmane.org/gmane.comp.lang.haskell.libraries/22732)
07:39:31 <Enzoray> Fuuzetzu: By that being, the whole language. It's so productive. It feels like it's doing all the work for me.
07:40:06 <phaazon> Enzoray: you can write your own length if you want to ;)
07:40:28 <Enzoray> Wait a minute, isn't "length" a standard haskell function?
07:41:18 <phaazon> @let myLength x = foldr (+1) 0 x
07:41:21 <lambdabot>  Defined.
07:41:27 <phaazon> > myLength "hello"
07:41:28 <sccrstud92_> Enzoray: yes. his point was that you can do as much work as you want to
07:41:28 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘b -> b’
07:41:29 <lambdabot>  Expected type: [b -> b]
07:41:29 <lambdabot>    Actual type: [GHC.Types.Char]
07:41:32 <joe9> alpounet: this might be more involved than what I have here but just want to validate my thinking. If I have 2 threads and want them to share the state, then I would have a Pause structure instead of the "Pause m"?
07:41:35 <phaazon> oh stupid me
07:42:04 <exio4> > let length' = foldr (\_ → +1) 0 in length' [1,2,3]
07:42:05 <lambdabot>  <hint>:1:27: parse error on input ‘+’
07:42:09 <joe9> alpounet: for example, Pause Int () will be replaced with a Pause ().
07:42:15 <exio4> > let length' = foldr (\_ → (+1)) 0 in length' [1,2,3]
07:42:16 <lambdabot>  3
07:42:18 <alpounet> joe9: i'm not sure i see how this relates to concurrency. could you expand?
07:42:40 <phaazon> > let l = foldr (const succ) 0 in l "hello"
07:42:42 <lambdabot>  5
07:42:47 <sccrstud92_> @ let myLength = foldl' (const (+1)) 0
07:42:55 <sccrstud92_> > myLength "hello"
07:42:57 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘b -> b’
07:42:57 <lambdabot>  Expected type: [b -> b]
07:42:57 <lambdabot>    Actual type: [GHC.Types.Char]
07:42:59 <lpaste> farnsworth pasted “Trig functions with custom angles” at http://lpaste.net/113206
07:43:11 <lpaste> farnsworth revised “Trig functions with custom angles”: “No title” at http://lpaste.net/113206
07:43:23 <phaazon> Enzoray: it is
07:43:27 <farnsworth9> phaazon:  I think I’ll just define the trig functions as something like that
07:43:33 <phaazon> it is since we know how to compute a length of a list
07:43:49 <joe9> alpounet: let me think this through. Thanks for your help.
07:43:55 <phaazon> farnsworth9: :)
07:44:04 <alpounet> heh ok
07:44:27 <joe9> alpounet: btw, I want to write a simple process scheduler where I have a few processes that can yield to the other, etc. (cooperative non-preemptive)
07:44:49 <sccrstud92_> @ let myLength = foldl' (const . (+1)) 0
07:44:51 <sccrstud92_> > myLength "hello"
07:44:52 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘b -> b’
07:44:52 <lambdabot>  Expected type: [b -> b]
07:44:52 <lambdabot>    Actual type: [GHC.Types.Char]
07:45:01 <joe9> alpounet: and there is a global state shared by these processes
07:45:26 <phaazon> @undefine
07:45:26 <lambdabot> Undefined.
07:45:45 <farnsworth9> phaazon: Thanks again
07:45:48 <exio4> @let length' = foldr (const (+1)) 0
07:45:50 <lambdabot>  Defined.
07:45:56 <exio4> > length' "dogcat"
07:45:58 <lambdabot>  6
07:46:21 <sccrstud92_>  the real length function is written with foldl', not foldr, right?
07:47:00 <phaazon> @let funnyLength x = sum (1 <$ x)
07:47:03 <lambdabot>  Defined.
07:47:05 <joe9> alpounet: just want to check if you are aware of any (comprehensible) library that can help.
07:47:06 <phaazon> > funnyLength "hey!"
07:47:09 <lambdabot>  4
07:47:29 <kadoban> :t (<$)
07:47:30 <alpounet> joe9: well you could use the quite standard solutions we have for concurrency. have you read/seen Simon Marlow's book?
07:47:30 <lambdabot> Functor f => a -> f b -> f a
07:47:42 <piskrist> dcoutts_: it's weird. When I download the package and configure, build, install manually,it's working
07:47:43 <phaazon> kadoban: it’s fmap . const
07:47:46 <alpounet> joe9: http://chimera.labs.oreilly.com/books/1230000000929/index.html
07:47:59 <sccrstud92_> @let myLength = foldl' (const . (+1)) 0
07:48:02 <lambdabot>  Defined.
07:48:07 <kadoban> Cute
07:48:13 <alpounet> joe9: obviously, i'm suggesting you look at the "Concurrent Haskell" part of it
07:48:14 <phaazon> it is!
07:48:16 <sccrstud92_> > myLength "test"
07:48:18 <lambdabot>  4
07:48:19 <exio4> > let length x = sum (x >>= [1]) in length "abc"
07:48:20 <lambdabot>  Couldn't match expected type ‘a2 -> [a1]’ with actual type ‘[t0]’
07:48:20 <lambdabot>  Relevant bindings include
07:48:20 <lambdabot>    x :: [a2] (bound at <interactive>:1:12)
07:48:20 <lambdabot>    length :: [a2] -> a1 (bound at <interactive>:1:5)
07:48:23 <sccrstud92_> @undefine
07:48:23 <lambdabot> Undefined.
07:48:31 <phaazon> you have the same thing with (<*) and (*>) for Applicative :)
07:48:52 <phaazon> (very useful when using parsec)
07:48:55 <exio4> > let length = sum . fmap (const 1) in length "abc"
07:48:57 <lambdabot>  3
07:49:19 <kadoban> Yeah, I still barely know just the basic operators for the common typeclasses, heh. I haven't really learned the extra ones yet
07:49:20 <alpounet> joe9: once you have a good feeling for what tools are out there, you'll be able to build something that fits your needs. Maybe you'll indeed want to adapt the Pause type there, or use it as is, might be a good idea
07:49:31 <kqr> if I have accidentally installed lots of crap outside of a cabal sandbox, what's the best way to get rid of it?
07:49:55 <phaazon> kadoban: I learned (<*) and (*>) when learning parsec :)
07:49:56 <kadoban> kqr: The usual way is to delete ~/.ghc
07:50:14 <kadoban> I've read that parsec can be really nice in applicative style, I figure I'll try that next time
07:50:25 <phaazon> it is :)
07:50:31 <kqr> kadoban, will give it a shot! thanks
07:50:32 <phaazon> with <|> and <?>
07:51:02 <Enzoray> What is the best text editor for Windows 7? Answer beyond personal preference, please. :) (Currently in use: gedit)
07:51:16 <phaazon> vim.
07:51:20 <kadoban> Enzoray: I've liked notepad++, but I don't use windows much
07:51:23 <Fuuzetsu> HAHA TIME FOR EDITOR WARS
07:51:26 <phaazon> :D
07:51:33 <phaazon> getting back to my HOAST
07:51:35 <hexagoxel> kqr: and require-sandbox: True for the future :)
07:51:41 <phaazon> fighting is tiring :D
07:51:54 <kqr> hexagoxel, that sounds AMAZING
07:51:58 <kqr> hexagoxel, where do I put that?
07:52:06 <Enzoray> So, vim is the best?
07:52:07 <hexagoxel> ~/.cabal/config
07:52:10 <Enzoray> I'll take a look at it.
07:52:38 <Fuuzetsu> I think anyone who uses require-sandbox: True would spend much less time learning and using nix instead.
07:52:45 <kqr> hexagoxel, that will save me a lot of headache. thanks a bunch
07:53:15 <exio4> Enzoray: if you're under windows, I would use leksah
07:55:06 <Enzoray> exio4: I think it looks to advanced. Hence I'm only doing some courses in programming, or a lot.
07:55:24 <joe9> alpounet: very good book. Thanks for sharing it.
07:57:53 <Eduard_Munteanu> Enzoray, Leksah is a full IDE for Haskell. That not to say vim isn't an equally valid choice.
07:59:02 <Enzoray> But, what are your thoughts on 'gedit' then?
07:59:33 <Enzoray> I want a flexible text editor, simple aswell.
08:00:00 <joe9> Enzoray: I use emacs. used to use vim. focus on haskell instead of the editor at this point.
08:00:07 <jhoch> sublimetext is also great
08:00:15 <kadoban> Well, there's more than a few reasons that people love emacs or vim. Both are really flexible, you can get plugins for a lot of crap
08:00:38 <Eduard_Munteanu> Enzoray, gedit is probably fine since vim doesn't do a lot by default
08:00:41 <saep> If you spend a lot of time in a "simple" text editor, it is IMHO worth it to get comfortable with either emacs or vim.
08:00:41 <Fuuzetsu> if you pick Yi then you get to write the plugins for a lot of crap yourself! Even better ;P
08:00:51 <Enzoray> I find that 'emacs' looks more like a program, rather than a text editor.
08:00:52 <kadoban> I use vim because I can use it for everything, instead of hoping that randomIDE supports whatever language I want to use today.
08:01:13 <jhoch> sublimetext is similar to gedit but also has a lot of good plugins
08:01:31 <Eduard_Munteanu> Enzoray, the bare minimum would be syntax highlighting, I'd say
08:01:37 <Fuuzetsu> jhoch: it also has a shitty license
08:01:52 <kadoban> I guess there's 'atom' if you're into that. It sounded kinda neat
08:02:19 <sivteck> Fuuzetsu, he's on Windows, who cares? let him learn haskell first ;P
08:03:15 <jhoch> what do you mean with shitty license?
08:03:22 <Eduard_Munteanu> So long he doesn't go with Hugs. :)
08:03:46 <Fuuzetsu> jhoch: proprietary
08:03:50 <jhoch> so what?
08:04:02 <Fuuzetsu> if you want syntax highlighting, we have a precise Haskell mode in Yi ;)
08:04:04 <jhoch> you can try out without paying as long as you want
08:04:14 <Fuuzetsu> http://fuuzetsu.co.uk/images/1414249643.png
08:05:20 <kadoban> jhoch: I don't run anything with proprietary licenses unless I can't avoid it. If the company disappears down the line, you're sunk. With open source, someone else can take up the torch.
08:05:37 <kadoban> jhoch: You also usually have little idea what their code actually does behind your back.
08:05:48 <Eduard_Munteanu> Assuming an established codebase.
08:05:58 <jhoch> That's right. I also love free software. But if it's great software, I have no problem paying for it.
08:06:17 <Fuuzetsu> You're confounding the idea of licensing with payment
08:06:29 <kadoban> It's not the paying for it part I mind, it's the license. Open source can be paid
08:06:41 <jhoch> In theory.
08:06:50 <kadoban> Yeah, pretty much
08:07:07 <dfeuer> ==> #haskell-blah
08:07:40 <ChristianS> huh? vim is extremely powerful
08:08:08 <Eduard_Munteanu> Not that much in relation to Haskell.
08:08:13 <Fuuzetsu> sure is silly to mention text editors in a channel full of programmers
08:08:31 <kadoban> ChristianS: Who said it wasn't?
08:09:00 <Eduard_Munteanu> Me. I find it emacs + evil + haskell-mode makes a somewhat better vim. :)
08:09:26 <sivteck> this means war (take it to==> #haskell-blah
08:09:47 <UnrealQuester> get the pitchforks
08:10:07 * ChristianS has better things to do
08:10:08 <Eduard_Munteanu> Imagine telling the angry crowd "not on my lawn!". :P
08:10:54 <joe9> alpounet: on a tangential note, I read that Applicative > monad. Is there something simple that can explain Applicative? I read about "Applicative" quite often. but, am not sure how it replaces the monad.
08:11:10 <Fuuzetsu> it doesn't replace Monad…
08:11:31 <joe9> Eduard_Munteanu: emacs + evil + haske mode , I use the same too. works well.
08:11:35 <Eduard_Munteanu> joe9, if anything, it's weaker than monad, or more general.
08:12:05 <Fuuzetsu> The idea is that every Monad is also Applicative but for historical reasons, the typeclass isn't ‘class Applicative m ⇒ Monad m where’ and the proposal fixes that
08:12:16 <kadoban> joe9: Have you read typeclassopedia?
08:12:27 <joe9> kadoban: yes, some time ago.
08:12:51 <Eduard_Munteanu> That idea isn't entirely true, not as true as Monads being Functors.
08:13:58 <Eduard_Munteanu> Theoretically, Applicative and Monad are totally orthogonal.
08:14:39 <Fuuzetsu> Explain.
08:14:54 <sivteck> :t liftM2 id
08:14:57 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
08:15:06 <Eduard_Munteanu> Fuuzetsu, category theory-wise
08:15:14 <Fuuzetsu> Yes, I'm asking you to explain.
08:15:22 <Fuuzetsu> I don't know where Applicative fits in at all within CT
08:15:31 <Eduard_Munteanu> Fuuzetsu, well, they're simply unrelated
08:15:56 <Fuuzetsu> related enough in Haskell world
08:16:03 <Fuuzetsu> what is Applicative in CT?
08:16:29 <massivetrap> http://www.massivetrap.com
08:16:44 <Fuuzetsu> nice
08:16:47 <Eduard_Munteanu> Fuuzetsu, in CT theyre strong lax monoidal functors, but I think it might be simpler to look at them as exponential-preserving functors.
08:17:16 <Fuuzetsu> OK, I will look into that tomorrow
08:17:21 <Fuuzetsu> I need to get back to my pseudomonads
08:18:19 <quchen> Fuuzetsu: From what I've gathered here Applicative => Monad is a special property of Hask
08:18:21 <Eduard_Munteanu> Fuuzetsu, if F is an applicative functor, you get a lifted notion of 'eval' in (<*>) for F
08:18:27 <Eduard_Munteanu> :t (<*>)
08:18:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:18:30 <Fuuzetsu> quchen: right, that's what I suspect
08:19:04 <Eduard_Munteanu> Or in CT-ish, F B^A x F A -> F B
08:19:35 <Eduard_Munteanu> Contrast with the exponential eval: B^A x A -> B
08:20:34 <Eduard_Munteanu> :t liftA2 ($)
08:20:35 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
08:21:00 <Fuuzetsu> wonder why it used ‘c’ and not ‘a’
08:21:08 <Eduard_Munteanu> :t fmap (uncurry ($))
08:21:09 <lambdabot> Functor f => f (b1 -> b, b1) -> f b
08:23:05 <Eduard_Munteanu> Fuuzetsu, anyway, they're just unrelated "in the wild".
08:23:52 <Eduard_Munteanu> And there are instances when even in Haskell you have different or missing instances of Applicative/Monad.
08:24:26 * hackagebot scion-browser 0.3.4 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.4 (JeanPhilippeMoresmau)
08:27:33 <kadoban> Eduard_Munteanu: Is that by design/necessity though, or just carelessness?
08:28:07 <alpounet> joe9: there are a couple of posts/tutorials out there about applicative. they come in very handy. one of the things they let you do, in combination with the functor structure, is to take a pure function (say mkPerson :: Name -> Age -> Person), and let you apply this function in some kind of context. Imagine you had getName :: IO Name, getAge :: IO Age, reading those from standard input or something. Then you could have g
08:28:07 <alpounet> etPerson :: IO Person by just doing: getPerson = mkPerson <$> getName <*> getAge, where <$> is just fmap, and <*> is from Applicative. The Applicative instance at play here is IO
08:28:33 <Eduard_Munteanu> kadoban, I don't remember any examples off the top of my head, but I think it's because there's no obvious choice to make
08:35:00 <kadoban> Anyone have an opinion on the quality of hakyll's code? I'm looking for projects to learn from the code of, figure that'd be good if it's...well good.
08:35:27 <Fuuzetsu> I think you'd learn more by joining a project and hacking on it
08:35:32 <Fuuzetsu> rather than reading a ready-made project
08:35:48 <Fuuzetsu> although I think the recommended project for ‘I want to read some code’ is XMonad
08:36:37 <kadoban> Yeah, I've been told xmonad, but...code that I don't use is less interesting to me usually, and I'm pretty happy with my WM situation
08:37:43 <alpounet> kadoban: any reason you don't want to just pick a project of your own and go for it?
08:38:18 <Fuuzetsu> tsk, I was secretely trying to recruit some hands and alpounet comes all ‘do your own project’
08:38:35 <kadoban> alpounet: I've done and do that, but reading code that's actually good seems like another way to learn, heh.
08:38:54 <kadoban> Fuuzetsu: Heh, to xmonad?
08:38:59 <alpounet> kadoban: right, that was just a question :) i wasn't suggesting you shouldn't do it.
08:39:16 <kadoban> Ya I understand
08:39:27 <Fuuzetsu> kadoban: no, to Yi
08:39:32 <alpounet> kadoban: and I think Fuuzetsu wants you to contribute to Yi
08:39:34 <alpounet> hah, see :p
08:39:39 <kadoban> Lol
08:39:42 <Fuuzetsu> alpounet: I want *everyone* to contribute to Yi ;P
08:39:48 <Fuuzetsu> but I have other projects too if you want!
08:39:57 <Fuuzetsu> helpers wanted everywhere
08:40:35 <kadoban> Hehe, I'll check out Yi. I've used vim for a long time, but IIRC the code is...not pretty so it's not exactly something I can hack on
08:40:52 <Fuuzetsu> the code is not pretty which is precisely why you should hack on it
08:40:57 <Fuuzetsu> well, it's becoming better, slowly
08:41:05 <Fuuzetsu> just ask questions in #yi
08:41:07 <kadoban> Plus I don't really use any of the actual features of vim, just the plugins XD
08:41:17 <kadoban> Sounds good
08:41:21 <Fuuzetsu> it's OK, now you get to write all those in Haskell!
08:41:45 <joe9> Can't (.) be implemented using (>>=)? Isn't (>>=) a special kind of function join'er too?
08:42:07 <Fuuzetsu> :t (>=>)
08:42:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:42:13 <Fuuzetsu> maybe that's what you mean?
08:42:16 <bennofs> joe9: (.) is a special form of fmap
08:42:25 <bennofs> joe9: fmap can be implemented with (>>=) and return
08:42:26 <Fuuzetsu> @src liftM
08:42:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:43:09 <bennofs> :t (\f g -> g >>= return . f) `asTypeOf` (.) -- it typechecks
08:43:10 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
08:44:28 * hackagebot ansi-terminal 0.6.2 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6.2 (RomanCheplyaka)
08:44:33 <sivteck> :t liftM
08:44:33 <sivteck> :t liftM2 id
08:44:34 <sivteck> :t (=<<)
08:44:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:44:34 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
08:44:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:46:25 <pjdelport> joe9: >>= is more like an application operator; though it makes more sense if you use =<<
08:46:33 <pjdelport> :t ($)
08:46:34 <lambdabot> (a -> b) -> a -> b
08:46:37 <pjdelport> :t (=<<)
08:46:38 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:47:35 <Eduard_Munteanu> Monad m => (a -> m b) -> (m a -> m b)
08:47:36 <pjdelport> $ applies a pure function to pure value, while =<< applies a Kleisli arrow to a monadic value
08:48:06 <pjdelport> You can see the types have the same shape, except for the 'm'
08:48:56 <pjdelport> A straightforward example of that is that you say "putStrLn =<< getLine" instead of "putStrLn $ getLine"
08:49:29 * hackagebot tasty 0.10.0.4 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.0.4 (RomanCheplyaka)
08:50:18 <Fuco> any idea why c2hs would complain about chi file not found? It's in the same directory as the chs I'm translating, and it exists, I can open an view it through less or anything else...
08:50:59 <Fuco> it has problem processing the {#import ... #} statement
09:06:18 <nitrix> How to create a type that is a (Endpoint, String) ?
09:08:14 <nitrix> newtype Head = Head (Endpoint, String)  ?
09:08:31 <geekosaur> data, not newtype
09:09:01 <geekosaur> unless you just wanted a type alias, in which case type Head = (Endpoint, String)
09:09:14 <bergmark> why not newtype? it's valid there
09:10:01 <nitrix> I precisely want a type alias for (Endpoint, String)
09:10:54 <triliyn> bergmark: newtype is valid but I don't think it has any performance advantage over data Head = Head Endpoint String
09:11:10 <kadoban> I think all of the above basically do that...it's just a matter of what semantics you want, or how transparent you want it to be to outsiders.
09:11:26 <nitrix> triliyn: Are you sure? Doesn't data add a new layer of indirection?
09:11:38 <nitrix> triliyn: While the constructor of newtype is just an illusion ?
09:11:49 <triliyn> nitrix: yes, but if you're storing two pieces of data, I think tuples will do that anyway
09:12:05 <geekosaur> so: data adds a new constructor and a new chance for laziness. newtype omits the extra laziness. type is exactly an alias, Head is exactly (Endpoint, String)
09:13:03 <triliyn> The constructor of a newtype is an illusion, but the tuple constructor is not
09:13:25 <nitrix>     Couldn't match expected type ‘Resource’
09:13:26 <nitrix>                 with actual type ‘(Endpoint, [Char])’
09:13:47 <geekosaur> which one did you use?
09:14:02 <nitrix> I'm not sure I understand how that's possible, given I just added: newtype Resource = Resource (Endpoint, String)
09:14:08 <nitrix> (Yeah I thought Head was confusing)
09:14:14 <geekosaur> because you must use the constructor
09:14:20 <geekosaur> if you didn;t want the constructor, use type
09:14:29 <triliyn> nitrix: if you want an alias, it's "type Resource = (Endpoint, String)"
09:14:44 <geekosaur> with data or newtype it *must* be a Resource whatever, noit just a whatever
09:14:45 <nitrix> Oh I see.
09:14:53 <geekosaur> the constructor must be present
09:15:45 <nitrix> Solved :)
09:15:50 <nitrix> I love this haskell :D
09:17:22 <Fuuzetsu> is there any other Haskell that you hate? ;P
09:18:56 <Eduard_Munteanu> Haskell Curry, as a writer of theorems and what not, is hateable by students, I take it. :)
09:19:31 <nitrix> I'm extremely not productive, I don't always understand what I'm doing, but it feels great.
09:19:36 <nitrix> It's like learning programming again.
09:20:00 <Fuuzetsu> hopefully it's extremely productive soon
09:20:22 <nitrix> It's been couple days, at least right now I'm not fighting with the type system anymore.
09:20:25 <exio4> it is extremely productive when you look at other languages, you can think problems in different ways :P
09:20:28 <Eduard_Munteanu> That sounds as dangerous as "wow, it's like doing coke all over again". :P
09:20:46 <nitrix> But I still have to grasp the functional way of doing things. Not used to all those recursive functions...
09:21:05 <nitrix> And states... right now I'm trying to avoid thinking about something I might need, which is a State monad...
09:21:06 <jmcarthur> i'm not productive either, but that's just me, not the language i use :)
09:21:11 <wei2912> nitrix: you're new to haskell too? :)
09:21:18 <Eduard_Munteanu> "Not fighting the insomnia anymore, but still getting a good high."
09:21:31 <nitrix> wei2912: Can't be good at everything :(
09:22:00 <wei2912> nitrix: haha
09:22:26 <exio4> nitrix: don't worry! when you get used to monads and recursion you'll find imperative loops harder to understand! :P
09:23:04 <jmcarthur> nitrix: when i was new i didn't really feel inclined toward State anyway, but the couple times i did use it, i experimented with manually inlining its definitions, and i found that i could simplify my code a lot from there and that the perceived statefulness of what i was doing didn't really exist
09:23:23 <nitrix> exio4: Well, the problem is that, it seems like I need to create tiny functions for the most insignificant thing, just because of their recursive nature.
09:23:34 <jmcarthur> nitrix: tiny functions are good!
09:23:36 <Fuuzetsu> well, there's fix…
09:23:57 <joe9> pjdelport: thanks.
09:24:04 <nitrix> I know they're good, but it hits my OCD that is having your functions match as much as possible the ... "API" of your software.
09:24:05 <exio4> I like tiny functions, because then, the problem can thought at an "higher-level"
09:24:16 <jmcarthur> nitrix: or are you saying you feel like there is a lack of good helper functions in the standard libraries?
09:24:19 <Fuuzetsu> nitrix: you can define functions inside a let or where as you need them you know
09:24:27 <Fuuzetsu> also you don't have to export everything
09:24:31 <Gurkenglas> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html#t:Alternative <- What does least solution mean?
09:24:33 <nitrix> Yeah, and lambdas, I'm getting there.
09:24:35 <jmcarthur> nitrix: (probably you will find that's not the case, once you are more familiar with it)
09:25:09 <Fuuzetsu> Gurkenglas: smallest possible I imagine
09:25:24 <Gurkenglas> How do I tell which of two is smaller?
09:25:50 <Fuuzetsu> I wouldn't worry, you just need to implement empty and <|>
09:26:13 <exio4> nitrix: big functions are normally really hard to understand, because they do too much stuff! :P
09:26:24 <Fuuzetsu> I think the idea is that if you have a result already, you don't go off for no reason and keep applying many/some
09:26:33 <Fuuzetsu> which may yield another solution of course
09:26:44 <Fuuzetsu> but I don't know, talking out of my ass
09:27:02 <Gurkenglas> What do you mean, applying many/some to generate solutions
09:27:54 <nitrix> Okay then, let me put my biggest issue out there then.
09:28:27 <nitrix> I have a state that is persistent for the entire program, that is a list of resources that constantly gets updated (5~10 times per second).
09:28:30 <Gurkenglas> I've recently heard of greatest and least fixpoints, and this reminds me of that, but I see no way to order the solutions
09:29:10 <jmcarthur> nitrix: could you be more specific?
09:29:44 <jmcarthur> nitrix: what is your program supposed to do?
09:29:56 <Fuuzetsu> Gurkenglas: maybe it refers to least solutions from the cpo world
09:30:13 <nitrix> jmcarthur: It's a distributed file system, each endpoints have a token that must be used for the next exchange with them. Each exchange invalidate the token.
09:30:19 <Gurkenglas> What's that?
09:31:06 <jmcarthur> nitrix: i'm not sure exactly what you mean by "endpoint" here. you mean some concurrent channel of communication?
09:31:33 <nitrix> jmcarthur: Mhm, yeah sorry, each peer of that distributed system is a endpoint.
09:32:09 <jmcarthur> nitrix: okay, so the idea is that if i want to communicate with a peer i have to pass them a token matching the one they currently hold or something?
09:32:41 <nitrix> jmcarthur: Correct, and that association peer<=>token is keep in a table that has to mutate for nearly every operations I do.
09:32:53 <nitrix> jmcarthur: I really want to avoid all my functions receiving and returning that table :/
09:33:12 <jmcarthur> nitrix: why not have a Peer type that has the token internally?
09:33:36 <carter> jmcarthur: nitrix  this sounds like a weaker version of a vector clock
09:33:41 <jmcarthur> nitrix: are you communicating with the peer concurrently within even a single peer?
09:33:46 <carter> or just having consensus
09:34:22 <jmcarthur> nitrix: since i assume communicating with a peer involves IO anyway, you could just have the Peer type that you use to identify peers store an IORef with the token
09:34:39 <carter> jah
09:35:33 <nitrix> jmcarthur: Okay that's what I was wondering. So the Peer wouldn't change, but it'd have an IORef token ?
09:35:38 <jmcarthur> yup!
09:36:06 <nitrix> Is this how mutable data is done in haskell? IORef?
09:36:11 <jmcarthur> that's one way
09:36:15 <nitrix> Or that's arguably not really clean?
09:36:42 <jmcarthur> IORef is fine if you are in IO anyway, although i wouldn't use it as a local variable most of the time
09:36:52 <jmcarthur> not the way i would in an imperative programming language
09:37:05 <nitrix> procedural.
09:37:07 <jmcarthur> that is, i basically never use IORefs for computation
09:37:17 <nitrix> Right.
09:37:21 <jmcarthur> i mean imperative, really. involving state.
09:37:26 <Gurkenglas> Oh, some and many actually are lists. Well then least solution makes some sense.
09:37:38 <Gurkenglas> *pure'd lists
09:37:43 <jmcarthur> or, rather, using state for everything, even things that needn't be stateful
09:38:12 <jmcarthur> nitrix: but some problems, especially those involving concurrency, lend themselves toward some kind of selective aliasing, and IORefs are a fine way to do that
09:38:24 <jmcarthur> nitrix: or perhaps TVars, if you need intraprocess concurrency
09:39:23 <nitrix> jmcarthur: data Endpoint = Endpoint { ..., token :: IORef String }
09:39:26 <jmcarthur> nitrix: it's fine to think of IORefs as "ugly" until you get more comfortable with functional style, though
09:39:43 <nitrix> jmcarthur: I'll eventually need TVars, but I should make it work single-threaded first xD
09:40:39 <jmcarthur> nitrix: in this case, i'm suggesting IORef because (1) you're using IO whenever you communication with a Peer anyway, (2) it's more convenient than explicitly passing states around, given (1) anyway, and (3) it's actually safer in this case because there is no way you can accidentally use the old state
09:40:48 <jmcarthur> s/communication/communicate/
09:41:55 <jmcarthur> nitrix: TVars aren't really harder to use than IORefs. you just have to import another module and wrap some expressions in atomically
09:42:40 <nitrix> jmcarthur: Oh I get it. Because I need an IO context to do the modifyIORef and stuff.
09:42:42 <monochrom> atomically (readTVar v), atomically (writeTVar v 4)
09:42:45 <nitrix> Makes sense.
09:43:17 <jmcarthur> nitrix: there are also atomic operations for IORefs, as long as you only use one IORef per transaction, and as long as you don't forget to use only the atomic operations (TVar gives you some additional type safety over IORef, in this respect)
09:43:39 <monochrom> the fun begins with atomically (do { x <- readTVar v; if x==0 then writeTVar v 1 else retry })
09:44:21 <nitrix> Mhhh.. so the type should actually be IO (IORef a)
09:44:30 <nitrix> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-IORef.html
09:44:35 * hackagebot htsn-import 0.2.0 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.2.0 (MichaelOrlitzky)
09:44:35 <nitrix> There we go :3
09:44:35 <jmcarthur> nitrix: what type?
09:44:54 <nitrix> jmcarthur: The type of the token in Endpoint,    IO (IORef String)
09:45:04 <jmcarthur> nitrix: no, i think it should just be IORef String
09:45:31 <jmcarthur> nitrix: IO (IORef String) implies that you will be creating a new IORef every time you use it, instead of reusing the same one
09:46:52 <jmcarthur> nitrix: you will need to do something like this:    do { tokenRef <- newIORef initialToken; ...; return (EndPoint ... tokenRef) }
09:47:16 <nitrix> jmcarthur: How do I create a endpoint then?
09:47:30 <jmcarthur> nitrix: as i just demonstrated ^^
09:47:55 <jmcarthur> nitrix: the type of that expression will be something like   IO EndPoint
09:49:50 <jmcarthur> nitrix: typically, you will try to keep the IO on the "outside" of your return values, implying in this case that you are using IO in order to create an EndPoint. this differs from  data EndPoint = EndPoint { ..., token :: IO (IORef Token) }  in that EndPoint would be a value *containing* an IO action that would create an IORef when executed
09:50:36 <wz1000> What is join for IO?
09:51:16 <nitrix> jmcarthur: I have endpointLocal scattered in my code, that is a simple function that used to create me a Endpoint. Literally (:: -> Endpoint).
09:51:18 <kqr> hey guys. this is not strictly a haskell question (although the end product will involve yesod) but i'm curious about what you guys think. if I want to create a personal blog where I will be the sole contributor, what would you recommend in terms of authentication? creating an entire user/password system seems overkill, since I will only have one user anyway
09:51:34 <nitrix> jmcarthur: Now though, I have to make that function an IO and everywhere it's used an IO context?
09:51:45 <nitrix> jmcarthur: That sounds wrong :/
09:51:51 <kadoban> kqr: A static site compiler, like hakyll
09:52:09 <jmcarthur> nitrix: correct, although i don't see why that would sound wrong. EndPoint represents something that you *must* use with IO anyway, right?
09:52:10 <wz1000> kgadek: If its only you, have root access to the server and configure it via ssh.
09:52:13 <kqr> kadoban, well yeah, but other than that though
09:52:56 <nitrix> jmcarthur: True. Let me see how that goes :)
09:52:59 <wz1000> s/kgadek/kqr
09:53:02 <jmcarthur> nitrix: i think the part that sounds wrong is that you are creating endpoints all over the place, actually
09:53:28 <nitrix> jmcarthur: Yeah, I almost used endpointLocal as if it was a constant.
09:53:42 <jmcarthur> nitrix: i would have expected that you would create each endpoint once (say, upon connection, initialization, or addition of the endpoint to the pool, depending on what an endpoint *really* is)
09:53:44 <kqr> wz1000, i'm not interested in configuring the server, i'm interested in entering a blog article into a form on a web page ;)
09:53:48 <kadoban> kqr: The thing is, as soon as you add another layer of being able to change things on the server, then you have to keep that updated and secure. Fun, for no reason.
09:53:54 <jmcarthur> nitrix: or rather, in one place, rather than in many places
09:53:58 <nitrix> jmcarthur: Now, since they have IORef, I should have a proper list somewhere of all the endpoint where they exists only once.
09:54:01 <jmcarthur> nitrix: and then just pass them around as needed
09:54:10 <wz1000> kqr: add new blog entries via ssh
09:54:35 <kqr> wz1000, certainly possible, but not interesting to me
09:54:41 <jmcarthur> ah, i guess you weren't thinking of an Endpoint as representing something you do IO with
09:55:37 <wz1000> How would join be implemented for IO?
09:55:49 <jmcarthur> wz1000: the same way it is implemented for all monads
09:55:50 <jmcarthur> @src join
09:55:51 <lambdabot> join x = x >>= id
09:56:40 <wz1000> jmcarthur: I was looking for a version that doesn't use (>>=)
09:57:02 <c_wraith|N10> No such thing.
09:57:07 <jmcarthur> wz1000: IO basically is nothing but return and (>>=), plus its various primitives
09:57:25 <kadoban> wz1000: Then it'd be in terms of some weird implementation defined IO internals that aren't really possible to talk about in generalities
09:57:32 <wz1000> Ah, ok
09:57:40 <jmcarthur> wz1000: an alternative design choice for Monad would be to have return, fmap, and join, then you could define (>>=) in terms of fmap and join
09:57:57 <jmcarthur> wz1000: in which case:   m >>= f = join (fmap f m)
09:58:05 <wz1000> jmcarthur: I knew that, thats why I was asking :P
09:58:13 <jmcarthur> a
09:58:14 <jmcarthur> h
09:58:53 <pjdelport> wz1000: The intuition of join for IO is that it merges the two layers of effect into one combined effect.
09:59:30 <pjdelport> wz1000: So for any given concrete IO implementation, join will just do that for it.
09:59:54 <jmcarthur> one interesting way of looking at return and join:    return :: Identity a -> M a;  join :: (Compose M M) a -> M a
10:00:03 <wz1000> pjdelport: Yeah, I got that. 'do { x' <- x; x'}'
10:00:31 <exio4> wz1000: that is basically "x >>= id" in do notation
10:00:38 <jmcarthur> if you have  type a ~> b = forall x. a x -> b x  then you can drop the type parameters:    return :: Identity ~> M;  join :: Compose M M ~> M
10:01:05 <wz1000> exio4: I know, but I find it easier to reason about IO's effects using the do notation
10:01:29 <pjdelport> Right. So join is equivalent to (id =<<), but that's only because (f =<< x) == join (f <$> x)
10:02:06 <wz1000> pjdelport: Ah, thats neat
10:02:44 <nitrix> jmcarthur: Okay, I think I found what I'm doing wrong, but not how to fix it. I actually have multiple sort of endpoints, and so, the module Endpoint.Local is one of them, which has very basic CRUD operations you can do on that endpoint, the functions aren't exposed publicly, but there's one function that is public, which is localEndpoint that creates a Endpoint object and set the CRUD
10:02:46 <nitrix> (change,read,update,delete) functions to point at this implementation.
10:03:29 <nitrix> jmcarthur: Thing is, now that I have the IORef, my helper function that creates this Endpoint (aka localEndpoint) becomes an IO, because is has to create the IORef, so far, no problem...
10:03:39 <wz1000> What model of IO do you guys prefer? State Realworld is pretty leaky.
10:03:59 <ReinH> wz1000: I don't have a model of IO. IO doesn't have denotational semantics.
10:04:07 <jmcarthur> wz1000: there is no good model
10:04:08 <nitrix> jmcarthur: but then, the main function which creates a list of endpoint cannot simply do   let endpoints = [localEndpoint, somethingElse, againAnotherSortOfEndpoint] to construct its list.
10:04:24 <nitrix> jmcarthur: I'd have to run each IO action and then build the list?
10:04:28 <Eduard_Munteanu> wz1000, leaky in what way?
10:04:37 <ReinH> :t sequence
10:04:38 <lambdabot> Monad m => [m a] -> m [a]
10:04:42 <jmcarthur> nitrix: you could use sequence, mapM, or something else
10:04:45 <jmcarthur> :t mapM
10:04:47 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:04:48 <nitrix> :O
10:04:51 <jmcarthur> :t replicateM
10:04:52 <lambdabot> Monad m => Int -> m a -> m [a]
10:05:00 <nitrix> That is brilliant.
10:05:24 <jmcarthur> nitrix: by the way, i'm still a bit bothered that you have a list of these
10:05:26 <sagittarian> @src replicateM
10:05:26 <lambdabot> replicateM n x = sequence (replicate n x)
10:05:26 <pjdelport> wz1000: IO is its own model. :)
10:05:28 <jmcarthur> nitrix: how do you use the list?
10:05:35 <nitrix> jmcarthur: I iterate it x]
10:05:42 <pjdelport> (with various possible implementations)
10:05:53 <wz1000> What about IO = Writer ObjectCode
10:05:58 <jmcarthur> i see. okay, that's not so bad then
10:06:07 <nitrix> jmcarthur: As soon as it works, I'll change that O(n) complexity into O(log n) or something.
10:06:18 <nitrix> jmcarthur: Because yeah, it's terrible.
10:06:23 <jmcarthur> wz1000: that doesn't allow return values to depend on dynamic data
10:06:25 <nitrix> I'm taking baby steps man D:
10:06:43 <Eduard_Munteanu> Or unsafeInterleaveIO
10:06:44 <sagittarian> :t replicate
10:06:44 <ReinH> IO doesn't "mean" anything. It doesn't have a model.
10:06:45 <lambdabot> Int -> a -> [a]
10:07:03 <sagittarian> @src replicate
10:07:03 <lambdabot> replicate n x = take n (repeat x)
10:07:05 <ReinH> Or at least, there is no less complex model for IO than IO itself.
10:07:19 <jmcarthur> nitrix: it's all good. by letting you know what concerns me i only hope to nudge you to think about it, not necessarily to think it's urgent to change it :)
10:07:20 <wz1000> IO all the way down :P
10:08:34 <jmcarthur> nitrix: but what i mean is that if you are storing a list of these to lookup endpoints dynamically, why not just make the endpoints themselves the keys you are using instead of separating the two concepts?
10:08:42 <jmcarthur> nitrix: then you don't even need a collection
10:08:43 <c_wraith|N10> I think of IO as a free monad with no denotation. It is just a computational structure with an external interpreter.
10:09:32 <Eduard_Munteanu> MonadState IOState m => Conduit IOEvent m IOEvent
10:11:45 <nitrix> jmcarthur: There's not really any association when I think about it. I just need a list of endpoints, talk to one, if it fails, fallback to another one.
10:12:20 <nitrix> jmcarthur: The only thing that's tricky is balancing the first request and faillover requests evenly.
10:13:10 <nitrix> jmcarthur: But yeah, technically, there's no ordering, there's no association, it's just a list of things where I might know ahead of time which element I want precisely.
10:13:15 <nshepperd> data IO a = Return a | forall b. (IO b) :>>=: (b -> IO a) | SomeSystemCall | SomeOtherSystemCall | ...
10:13:32 <nshepperd> ^^ does that count?
10:13:35 <monochrom> enjoy these unsafeInterleaveIO examples: http://lpaste.net/77374
10:13:42 <Eduard_Munteanu> nitrix, foldr (<|>) ... perhaps?
10:14:16 <nitrix> Eduard_Munteanu: What is <|> ?
10:14:42 <Eduard_Munteanu> nitrix, do you know about Alternative or MonadPlus?
10:14:49 * nitrix hides
10:15:08 <nitrix> Does that eat humans :P ?
10:15:13 <benzrf> nitrix: its just monoid with an extra law or two
10:15:19 <benzrf> @src Alternative
10:15:19 <lambdabot> class Applicative f => Alternative f where
10:15:19 <lambdabot>     empty :: f a
10:15:19 <lambdabot>     (<|>) :: f a -> f a -> f a
10:15:20 <Eduard_Munteanu> nitrix, x <|> y often means "x, or if that fails, y"
10:15:25 <kadoban> They're not very scary...just a tiny addition to other classes you probably know
10:15:37 <nitrix> How does it determines if it failed?
10:15:44 <benzrf> nitrix: it's per-alternative..
10:15:46 <nitrix> The type signature doesn't show it.
10:15:55 <benzrf> nitrix: in general, empty should be a zero of (<*>)
10:15:57 <Eduard_Munteanu> It's built into (<|>)'s definition.
10:16:01 <benzrf> and an identity of (<|>)
10:16:07 <Eduard_Munteanu> E.g. Nothing <|> x = x
10:16:09 <benzrf> and (<|>) should be associative
10:16:17 <nitrix> You lost me but that sounds fairly useful.
10:16:30 <srhb> > Nothing <|> Just 42
10:16:32 <lambdabot>  Just 42
10:16:34 <srhb> > Just 2 <|> Just 42
10:16:35 <lambdabot>  Just 2
10:16:40 <nitrix> Except, the failovers must be balanced eventualy, ideally.
10:16:52 <benzrf> nitrix: basically
10:16:56 <benzrf> nitrix: 1. take monoid
10:17:07 <benzrf> nitrix: 2. make instances need kind * -> * instead of *
10:17:24 <benzrf> nitrix: make the types be f a instead of f
10:17:31 <benzrf> now u have Alternative
10:17:46 <benzrf> plus, empty should be a zero of (<*>), but that's pretty much gonna happen anyway just because of the type
10:17:54 <nitrix> @t empty
10:17:55 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:18:05 <benzrf> :t empty
10:18:06 <lambdabot> Alternative f => f a
10:18:15 <jmcarthur> nitrix: ah, okay, then a list doesn't sound totally crazy to me, if all you're doing is iterating
10:18:34 <Eduard_Munteanu> Also, the monadic identity is most often different from the monoid identity.
10:18:40 <nitrix> Give me a couple of hours and I'll post the code :P
10:18:59 <nitrix> I'm struggling just writing a simple function but it's getting there x]
10:19:20 <Eduard_Munteanu> e.g. return == Just  vs  Nothing
10:20:20 <nitrix> There's so much more to haskell than first meet the eyes.
10:20:29 <nitrix> :X
10:21:15 <Eduard_Munteanu> Try Haskell goggles, might help the eyes. :)
10:22:18 <chrisdone> Bigoggle
10:23:28 <Eduard_Munteanu> wa->ma would be a funny emote, I suppose.
10:25:10 <benzrf> :t return . extract
10:25:11 <lambdabot> Not in scope: ‘extract’
10:25:13 <benzrf> well
10:25:18 <benzrf> it WOULD be w a -> m a
10:26:25 <Eduard_Munteanu> bireturn
10:28:24 <MickeyDroid> I heard this was the Coolest IRC Channel...
10:28:30 <Fuuzetsu> it is THE coolest
10:29:01 <alpounet> you have to qualify extract
10:29:01 <n4x> we're so cool you'll think we're hot!
10:29:02 <alpounet> :t return . Control.Comonad.extract
10:29:03 <lambdabot> (Control.Comonad.Comonad w, Monad m) => w b -> m b
10:29:26 <Welkin> it lacks energy?
10:29:32 <n4x> > (minBound ∷ Int) - 1
10:29:35 <lambdabot>  9223372036854775807
10:29:46 <Welkin> > maxBound :: Int
10:29:47 <lambdabot>  9223372036854775807
10:29:51 <MickeyDroid> Lol...Nice!!!
10:29:58 <Welkin> > maxBound - minBound:: Int
10:30:01 <lambdabot>  -1
10:30:04 <MickeyDroid> So what goes on here??
10:30:05 <Eduard_Munteanu> @hoogle distribute
10:30:07 <lambdabot> package distributed-process
10:30:08 <lambdabot> package distributed-process-azure
10:30:08 <lambdabot> package distributed-process-monad-control
10:30:08 <Welkin> > maxBound + minBound :: Int
10:30:10 <lambdabot>  -1
10:30:13 <Eduard_Munteanu> @hoogle+
10:30:13 <lambdabot> package distributed-process-p2p
10:30:14 <lambdabot> package distributed-process-simplelocalnet
10:30:14 <lambdabot> package distributed-static
10:30:15 <Welkin> > maxBound + minBound :: Integer
10:30:16 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
10:30:16 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
10:30:17 <Eduard_Munteanu> :(
10:30:25 <benzrf> MickeyDroid: cool shit
10:30:44 <MickeyDroid> mmmmh
10:30:46 <Eduard_Munteanu> @hoogle m (w a) -> w (m a)
10:30:48 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:30:48 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:30:48 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
10:31:02 <Welkin> we sing songs
10:31:02 <benzrf> mwa
10:31:06 <Eduard_Munteanu> :t Control.Comonad.distribute
10:31:07 <lambdabot> Not in scope: ‘Control.Comonad.distribute’
10:31:13 <MickeyDroid> Lol..Sing songs??
10:31:26 <MickeyDroid> I mean how do u even sing on an IRC channel??
10:32:04 <Eduard_Munteanu> :o ~ ./ .> ./ .>
10:32:05 <exio4> songs about functors, monads, and coalgebras!
10:32:19 <benzrf> coalgebras?!
10:32:23 <benzrf> more like dialgebras!
10:32:33 <MickeyDroid> Uhhhmm say what now?
10:32:47 <benzrf> MickeyDroid: this is where the coolest haskellers hang out B)
10:32:48 <MickeyDroid> What are those??
10:33:06 <benzrf> haskeller, n: one who uses haskell
10:33:07 <Welkin> and burritos
10:33:09 <Eduard_Munteanu> Bi-Eilenberg-Moore!
10:33:24 <alpounet> :t Data.Distributive.distribute
10:33:25 <lambdabot> (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
10:33:28 <alpounet> it's there
10:33:32 <Eduard_Munteanu> Oh, that.
10:33:37 <MickeyDroid> ookay
10:34:09 <MickeyDroid> I just looked it up on google and it came up as a website which helps people find jobs
10:34:16 <benzrf> O:
10:34:24 <benzrf> MickeyDroid: screw jobs, get knowledge
10:34:27 <MickeyDroid> ???
10:34:34 <MickeyDroid> ryt
10:34:44 <schell> benzrf: o/ - oh hey, you moved over from the ruby chanel
10:34:54 <benzrf> schell: dude im much more active here
10:34:56 <Eduard_Munteanu> :t Control.Comonad.duplicate . join . fmap Data.Distributive.distribute
10:34:57 <lambdabot> (Data.Distributive.Distributive w, Control.Comonad.Comonad w, Functor f, Monad w) => w (f (w a)) -> w (w (f a))
10:34:58 <benzrf> and have been for like a year
10:35:05 <schell> :)
10:35:06 <schell> me too
10:35:09 <Fuuzetsu> I always knew benzrf was a dirty rubyist
10:35:10 <Welkin> schell: no one uses ruby
10:35:18 <benzrf> ruby is fairly nice
10:35:22 <benzrf> as dynamic languages go!!
10:35:41 <Fuuzetsu> hopefully they go and stay go
10:35:44 <MickeyDroid> I still dont seem to get what a haskell is??
10:35:53 <Fuuzetsu> MickeyDroid: it's a programming language
10:36:02 <MickeyDroid> Oookay
10:36:06 <MickeyDroid> Nice
10:36:09 <Welkin> Fuuzetsu: "go" is a dirty word
10:36:26 <exio4> benzrf, racket is a nice dynamic lang
10:36:35 <benzrf> lisp schmisp
10:36:45 <MickeyDroid> Another dumb question...Is haskell a mobile prog. lang or PC?
10:36:46 <benzrf> all those parens mmake my eyes hurt!
10:36:52 <benzrf> MickeyDroid: no such thing as either of those
10:37:17 <MickeyDroid> really??
10:37:18 <Fuuzetsu> Welkin: only if you capitalise it
10:37:23 <schell> MickeyDroid: ghc ships with the ability to compile to ARM ios, if that counts
10:37:29 <nshepperd> you can use haskell on android supposedly
10:37:35 <Eduard_Munteanu> MickeyDroid, there's work in progress on an ARM port of the compiler, but mostly it's applied to x86 CPUs.
10:37:39 <nshepperd> with great difficulty
10:37:45 <MickeyDroid> Wow..
10:38:48 <MickeyDroid> Then i guess am a huge Noob around here
10:38:48 <Eduard_Munteanu> Actually what's the state of GHC on ARM when it comes to plain Linux, not Android?
10:39:01 <Fuuzetsu> it works
10:39:27 <Eduard_Munteanu> MickeyDroid, you wouldn't be the first, if that comforting, the 1443 in here likely were too at some point :)
10:39:41 <Fuuzetsu> hm, did we grow again recently
10:39:57 <Eduard_Munteanu> I wonder that too, I remember figures near 1000.
10:40:05 <MickeyDroid> Is it difficult to learn to use Haskell??
10:40:12 <alpounet> Eduard_Munteanu: that was 2 3 years ago already :p
10:40:21 <Fuuzetsu> Eduard_Munteanu: it was about 1000 when I joined, about 3 years ago
10:40:30 <Eduard_Munteanu> MickeyDroid, it can be more difficult compared to other mainstream languages, if you're used to one already
10:40:39 <sivteck> MickeyDroid, there's a fun book for learning haskell
10:40:40 <Eduard_Munteanu> Oh, heh.
10:40:43 <sivteck> @where LYAH
10:40:43 <lambdabot> http://www.learnyouahaskell.com/
10:41:09 <a3gis> MickeyDroid: I feel the most difficult part are the functional programming concepts
10:41:16 <a3gis> learning haskell as a language is fine
10:41:28 <MickeyDroid> I have started doing shell scripting and a little python
10:41:31 <a3gis> but it often implies learning a whole different way of programming
10:41:50 <exio4> the less you know, the easier haskell is
10:42:21 <exio4> as you would need to unlearn what you already know... anyway :P
10:42:31 <nitrix> How do I print a `Maybe B.ByteString` using `maybe` ?
10:42:58 <HeladoDeBrownie> nitrix, what do you want to print in each case?
10:43:14 <nitrix> Only when it's Just, and do nothing for Nothing.
10:43:19 <Eduard_Munteanu> nitrix, maybe ... B.putStrLn ...
10:43:29 <Fuuzetsu> :t maybe (return ()) print
10:43:31 <lambdabot> Show a => Maybe a -> IO ()
10:43:34 <HeladoDeBrownie> nitrix, return () can be used for "do nothing"
10:43:34 <nitrix> Right, but I keep getthing a type error for the first ...
10:43:54 <nitrix> I'd need something that returns a () value.
10:43:54 <Eduard_Munteanu> I wouldn't use print/show for it.
10:43:56 <nitrix> Oh wow.
10:44:01 <nitrix> (return ())
10:44:19 <nitrix> So disgusting. Really :/ ?
10:44:30 <HeladoDeBrownie> nitrix, why do you think it's disgusting?
10:44:34 <nitrix> There's not like a noop function or something x] ?
10:44:41 <HeladoDeBrownie> nitrix, that *is* a no-op.
10:44:41 <Fuuzetsu> it's called ‘return ()’
10:45:01 <HeladoDeBrownie> (And what you're after isn't a function anyway, it's an IO value)
10:45:15 <Eduard_Munteanu> nitrix, mapM_ B.putStrLn   using the Foldable mapM_
10:46:04 <haasn> (Or just ‘traverse’)
10:46:06 <Eduard_Munteanu> Er, and if you lift that accordingly.
10:46:29 <HeladoDeBrownie> nitrix, maybe it might look nicer to you if you used a case expression rather than maybe?
10:48:19 <nitrix> HeladoDeBrownie: Since there's no logic or body at all, I'd prefer maybe. It should just call the function if it's a Just and move on.
10:48:42 <Eduard_Munteanu> nitrix, then pattern-match the argument
10:49:23 <HeladoDeBrownie> nitrix, not sure what you mean by that. Anyway, maybe is equivalent to a case expression. maybe n j m = case m of { Nothing -> n ; Just x -> j x }
10:49:23 <Eduard_Munteanu> f (Just s) = B.putStrLn s; f Nothing = return ()
10:49:42 * hackagebot tasty-quickcheck 0.8.3 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.3 (RomanCheplyaka)
10:50:34 <haasn> I don't see what's wrong with (F.mapM_ B.putStrLn) or (traverse_ B.putStrLn)
10:52:13 <HeladoDeBrownie> I don't either. I just wanted to demonstrate what maybe actually does.
10:54:42 * hackagebot happstack-authenticate 0.10.15 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.15 (JeremyShaw)
11:04:35 <gabebw> @pl lookupByMaybe (Just a) = lookup a\\
11:04:35 <lambdabot> (line 1, column 25):
11:04:35 <lambdabot> unexpected " "
11:04:35 <lambdabot> expecting operator
11:04:39 <gabebw> @pl lookupByMaybe (Just a) = lookup a
11:04:39 <lambdabot> (line 1, column 25):
11:04:39 <lambdabot> unexpected " "
11:04:39 <lambdabot> expecting operator
11:07:46 <marchelzo_> I'm really confused as to why this is not type checking
11:07:48 <marchelzo_> http://lpaste.net/1931266915485876224
11:08:50 <simpson> :t map (`isSuffixOf` s)
11:08:52 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
11:08:52 <lambdabot>     In the second argument of ‘isSuffixOf’, namely ‘s’
11:08:52 <lambdabot>     In the first argument of ‘map’, namely ‘(`isSuffixOf` s)’
11:08:59 <simpson> :t \s -> map (`isSuffixOf` s)
11:09:00 <lambdabot> Eq a => [a] -> [[a]] -> [Bool]
11:09:35 <simpson> :t any
11:09:37 <lambdabot> (a -> Bool) -> [a] -> Bool
11:09:47 <marchelzo_> oh my god
11:09:52 <monochrom> :)
11:09:55 <marchelzo_> I thought any was [Bool] -> Bool
11:10:01 <simpson> :t or
11:10:02 <lambdabot> [Bool] -> Bool
11:10:12 <monochrom> any (`isSuffixOf` s) imageExtensions, or use or :)
11:10:13 <marchelzo_> thanks, I didn't know about or!
11:14:45 * hackagebot ansi-terminal 0.6.2.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6.2.1 (RomanCheplyaka)
11:20:09 <ij> How can I bundle my executable with e.g. my sound file?
11:21:30 <lucky> anyone using vim + syntastic for error checking? ghc-mod seems to have broke with syntastic in a recent version, any pointers?
11:22:43 <Fuuzetsu> ij: I think in general you would merely distribute the sound files with your executable and read at runtime
11:23:05 <ij> I
11:23:06 <Fuuzetsu> but I did inline some files with Template Haskell befor
11:23:07 <Fuuzetsu> e
11:23:23 <ij> I know, but I would like now to do this sort of trickery.
11:24:20 <Fuuzetsu> did you look at http://stackoverflow.com/questions/6402158/how-to-compile-a-resource-into-a-binary-in-haskell
11:24:42 <mauke> http://neilmitchell.blogspot.de/2008/02/adding-data-files-using-cabal.html
11:26:24 <saep> lucky: install an older version or fix syntastic. For me version $.!.^ seems to work.
11:26:50 <lucky> saep: $....?
11:27:01 <mauke> 4.1.6
11:27:15 <lucky> ah, can i do that with cabal?
11:27:44 <lucky> apparently so :)
11:28:01 <saep> oh, i switched symbols with numbers in my keyboard layout just today ^^
11:28:25 <mauke> I've done that, but only in vim
11:29:13 <Total_1mmersion> Any idea how to create a conduit which chunks, or buffers, the input into groups of N? Something like Conduit a m [a]
11:29:44 <Fuuzetsu> it seems like an ad-hoc switch, I'd recommend you go for something like Programmer's Dvorak all together if you're into that
11:29:48 <benzrf> Total_1mmersion: i know how to make a pipe that does that!
11:29:50 <benzrf> ( ͡~ ͜ʖ ͡°)
11:35:08 <catsup> what is a non-proper morphism?  i understand monad transformers, and i know what a morphism is, but i don't know what non-proper means, or how it relates to monad transformers.  (wikipedia says "A morphism of schemes is called proper if it is separated, of finite type and universally closed"...  not helpful heh)
11:35:17 <lucky> hm, why would read "25" work but the number 25 itself in the same place, throw a no instance for Num ... compile error?
11:36:03 <Total_1mmersion> benzrf: how do you make such a conduit?
11:36:13 <monochrom> lucky: what is the actual code?
11:37:42 <augur> lucky: whats the type of the place?
11:37:46 <lucky> http://sprunge.us/ESgR
11:37:51 <saep> Fuuzetsu: Do you mean me? I already switched to colemak a few weeks back. I just did not think about switching the number row back then.
11:37:58 <lucky> augur: type of the place?
11:38:22 <augur> lucky: er.. what do you mean why does that cause an error
11:38:26 <augur> :t read
11:38:27 <lambdabot> Read a => String -> a
11:38:43 <augur> that's why read "25" works there, lucky
11:39:07 <augur> read "25" :: a   for any a you want that has a Read instance
11:39:12 <augur> in this case, a = Operand
11:39:16 <lucky> augur: it doesn't compile for me, "No instance for (Num Operand) arising from the literal ‘25’"
11:39:22 <augur> right
11:39:29 <augur> because 25 :: Num a => a
11:39:32 <augur> :t 25
11:39:33 <lambdabot> Num a => a
11:39:47 <augur> :t read "25"
11:39:48 <lambdabot> Read a => a
11:40:00 <monochrom> lucky: you want something of type Operand there. 25 will not give you an Operant. read "25" is polymorphic will give you an Operand, or die trying. (it will die trying.)
11:40:15 <augur> lucky: both `25` and `read "25"` can be whatever you want, but under different coditions
11:40:17 <lucky> monochrom: ah, ok
11:41:07 <augur> incidentally, read "25" :: Operand will probably be undefined
11:41:42 <lucky> how do i get a numeric literal into a word8 then?
11:42:07 <augur> > read "25" :: Word8
11:42:10 <lambdabot>  25
11:42:30 <monochrom> 25 :: Word8, too
11:42:32 <lucky> oh, so just type it
11:42:33 <augur> lucky: emit has an Operand as its third argument
11:42:41 <lucky> what's the precedence of :: ?
11:42:55 <augur> but you allow uses to wrap a ByteOperading using `Operand`
11:42:58 <monochrom> pretty low, most often you'll have to (25 :: Word8)
11:43:11 <augur> incidentally, lucky, i think your Operand type probably isnt what you want it to be
11:43:43 <lucky> augur: how so?
11:43:51 <augur> lucky: well, you have three constructors
11:43:55 <augur> Operand, WordOperand, and None
11:44:04 <augur> but im guessing thats not what you meant
11:44:17 <monochrom> data Operand = Byte Word8 | Word Word16 | None
11:44:35 <lucky> ahh, ok, yes that's closer to what i intended
11:44:36 <lucky> thanks
11:44:48 * hackagebot aeson-t 0.0.3 - Transform JSON  http://hackage.haskell.org/package/aeson-t-0.0.3 (begriffs)
11:44:59 <augur> this whole thing is giving me the impression that you're jumping into the deep end before you can swim
11:45:13 <augur> you might want to revisit some of the fundamentals of haskell
11:45:36 <lucky> augur: i've read LYAHFGG and Real World Haskell, this is my first attempt to write more than a couple lines of code though
11:46:10 <augur> i would suggest re-reading LYAH
11:46:25 <monochrom> augur, I have realized that dive-in projects for learning Haskell is a meta-exercise on lazy evaluation :)
11:46:37 <augur> monochrom: lolwut
11:47:10 <catsup> lol
11:47:12 <monochrom> here is why: a dive-in project makes you learn things on demand, you don't learn until you need it :)
11:47:39 <augur> monochrom: yes, well, that only works if you know what you need to learn
11:47:39 <lucky> anyway i'll stop pestering you all with elementary questions, you've given me the pointers I need to Google it for myself, I think
11:47:47 <augur> lucky: no you should pester
11:48:06 <augur> its just that i feel like youve got gaps in your knowledge that are kind of fundamentally important
11:48:18 <wayne> monochrom: you have the same problem as DFS and BFS
11:48:33 <monochrom> yes
11:48:36 <augur> like, you're missing out on certain very important foundational things, without which you probably shouldnt be writing code yet
11:49:00 <wayne> augur: true, but i think it's also a fair argument that you can learn certain foundational things a lot faster if you blindly write code first
11:49:02 <augur> just because writing without these bits is going to be very very confusing and demoralizing
11:49:08 <catsup> wayne: yes
11:49:12 <wayne> story of bootstrapping
11:49:19 <monochrom> I think "data Operand = Operand ByteOperand | WordOperand | None" was just a slip of mind
11:49:29 <augur> wayne: i think this is completely false
11:49:47 <augur> monochrom: possibly! hopefully :)
11:50:13 <catsup> with just reading, you can gloss over things and not realize you did it
11:50:14 <monochrom> I deduced that because as soon as I tossed out my version, lucky immediately understood.
11:50:42 <catsup> but when you write code, you know
11:50:44 <mr_rm> newbie question here... should this work in ghci?    let foo (n + 1) = 42
11:51:05 <wayne> augur: i think "completely false" is pretty brash. people don't learn the metaphysicals of integrals before learning some simple examples of them
11:51:06 <augur> catsup: merely reading isnt sufficient, of course, but writing without also reading is foolish
11:51:27 <augur> wayne: most people are awful at calculus :)
11:51:37 <catsup> augur: well, lucky said they'd read the books
11:52:03 <augur> yes
11:52:04 <bergmark> mr_rm: that's NPlusKPatterns, it's no longer enabled by default, it's recommended to not use it
11:52:06 <Cale> mr_rm: if you :set -XNPlusKPatterns  first
11:52:12 <lucky> I'm not entirely sure how much sunk in, of course.
11:52:13 <mr_rm> i'm going through "Programming in Haskell" and they use that pattern in the book
11:52:25 <lucky> You don't know if you know something until you actually know it.
11:52:36 <augur> sometimes not even then!
11:52:41 <mr_rm> bergmark: ok. thanks for the info. so those examples from the book are considered bad form now?
11:52:46 <Cale> mr_rm: In a source file, you'd put {-# LANGUAGE NPlusKPatterns #-} at the top to turn on that extension
11:52:48 <lucky> rereading LYAH sounds like a good idea, tbh
11:53:54 <bergmark> mr_rm: right
11:54:24 <Cale> I don't know if I'd go so far as to say they're bad form, but they're not terribly popular.
11:54:45 <lucky> http://sprunge.us/BYJJ is where I'm at now, and it's working! yay
11:54:59 <monochrom> congrats
11:55:06 <bergmark> https://ghc.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
11:55:06 <catsup> NPlusKPatterns is deprecated
11:55:10 <monochrom> you can also use: read "Byte 25"
11:55:17 <mr_rm> bergmark: thank a lot. that was really bugging me and i couldn't find the info on why
11:55:33 <Cale> mr_rm: They were a little complication in the spec of the language which people didn't really use all that much, so they got moved out to an extension.
11:55:35 <monochrom> oops, you cannot, for now, since you don't have "deriving Read"
11:56:11 <monochrom> but perhaps you don't need to use read for real
11:56:50 <mr_rm> the book said that this pattern would only match positive integers and i thought that was odd and wanted to try it. anyway, i'll let my friends know who are doing the haskell course with me. we're all just learning and this is sure to trip up others
11:57:04 <mr_rm> thanks everyone for the info
11:57:51 <catsup> "some Haskell books use it (this was the main reason it was kept in Haskell 98)
11:58:06 <catsup> from the RemoveNPlusK link
11:58:18 <Cale> mr_rm: The reason they existed in the first place is to make matching on integers similar to pattern matching on a primitive natural number type, like  data Nat = Zero | Succ Nat
11:58:50 <monochrom> mathematicians like to write "f (x+1) = 1 + f x".
11:59:02 <Cale> Actually, iirc some early implementations of Haskell also had c*n+k patterns :)
11:59:21 <Cale> So you could match on 2*n and 2*n + 1 for the even and odd case
11:59:31 <vanila> haha
11:59:40 <vanila> how about turing complete patterns
11:59:41 <monochrom> that is... really... stretching it!
12:00:21 <mauke> I want (k ++ n) patterns
12:00:49 <augur> mauke: those would be nice too
12:00:49 <catsup> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
12:00:51 <monochrom> yikes, NPlusKPatterns really rejects negative numbers.
12:01:17 * Cale experiences a flashback to the trauma of an algebraic number theory course in which many of the homework assignments involved problems which broke down into cases modulo 16.
12:01:21 <yesthisisuser> Classic mailing list message on n+k patterns: http://www.mail-archive.com/haskell@haskell.org/msg01261.html
12:01:24 <monochrom> "f (x+1) = x" alone implies f (-5) is an error
12:01:31 <augur> catsup: those arent really sufficient for xs ++ ys patterns
12:01:51 <Cale> Damn 16*n + 5 case
12:02:08 <augur> the problem with xs ++ ys patterns is that its non-deterministic
12:02:15 <monochrom> haha, Lennart has spoken :)
12:02:18 <augur> the only way to make it really deterministic is to have dependencies
12:02:35 <yesthisisuser> I think that is where the whole discussion started :)
12:02:51 <mauke> I don't need xs ++ ys
12:03:01 <mauke> just k ++ n
12:03:24 <augur> mauke: .. oh you want just a constant
12:03:29 <augur> right
12:03:36 <augur> actually that should be doable with a view pattern then
12:04:03 <augur> :t Eq a => [a] -> [a] -> Maybe [a]
12:04:04 <lambdabot> parse error on input ‘=>’
12:04:08 <augur> whoops
12:04:12 <augur> @hoogle Eq a => [a] -> [a] -> Maybe [a]
12:04:14 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
12:04:14 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
12:04:14 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
12:04:35 <augur> mauke: k ++ n   =   stripPrefix x -> n
12:04:39 <augur> er..
12:04:41 <augur> mauke: k ++ n   =   stripPrefix x -> Just n
12:05:24 <mauke> :/
12:05:25 <azhar> How can i define multiple type faces to a function that accepts tuple
12:05:27 <azhar> testMethod :: (String a, Integral b) => (a, b, a) -> a
12:05:33 <augur> mauke: too verbose?
12:06:02 <augur> why'd i say x..   stripPrefix k -> just n
12:06:12 <augur> my brain doesnt work :(
12:06:39 <timpani> Can something like curly braces be used to delimit an expression, e.g., let x = 3 in { y where y = f x } ?
12:06:53 <timpani> (If not, can anything else?)
12:06:56 <azhar> God save this place..
12:07:16 <augur> azhar: multiple what
12:07:45 <mauke> timpani: ( ) delimit expressions
12:08:43 <vermeille> I have a very simple file format to parse (each ligne begins by a word and is followed by some floats), I think that Parsec might be overkill, what is the best way to parse that?
12:08:51 <timpani> mauke: already tried that: it doesn't work, or at least it's not working well with layout (sig. whitespace).
12:08:55 <vermeille> line*
12:09:15 <mauke> timpani: you can't attach 'where' to expressions
12:09:31 <monochrom> timpani: "where" is not attached to an expression, but to a definition. there is no delimiter that will make "x where x=5" works.
12:09:49 <timpani> ok, thanks.
12:10:05 <mauke> > let x = y where y = 42 in x
12:10:08 <lambdabot>  42
12:10:12 <int-e> > let x = x where x = 5 in x
12:10:13 <lambdabot>  5
12:10:56 <int-e> in either case, the 'where' belongs to the 'x =' binding, not to the following expression.
12:13:38 <cutgovspend> what is that haskell offtopic channel again?
12:14:04 <monochrom> #haskell-blah
12:14:33 <cutgovspend> anyone here got a linode with haskell website operating?
12:14:42 <cutgovspend> haskell powered
12:14:59 <monochrom> chrisdone runs tryhaskell.org
12:15:09 <luite> i thought he moved to hetzner
12:15:43 <monochrom> yeah, well, I'm ignoring the "linode" part, should not matter, why should it matter
12:21:57 <luite> oh i thought it might've been specific to gettig it working on a low ram instance
12:23:53 <luite> hetzner servers are 32GB+, should be enough to compile haskell-src-exts without too much trouble :)
12:24:03 <monochrom> haha
12:24:59 <luite> (i'm mostly done dropping that as a dep from GHCJS btw)
12:25:37 <Fuuzetsu> I want to slip a joke in on author and coauthor so badly into this thing I'm writing
12:25:55 <Fuuzetsu> grant me the strength to stop myself
12:25:55 <monochrom> please tell us the joke :)
12:26:13 <Fuuzetsu> monochrom: who's the coauthor of a category theory paper?
12:26:20 <sccrstud92_> so i just realized that the common haskell method of building an ast that can be interpreted in multiple ways is the Visitor pattern
12:26:21 <monochrom> please tell us the joke so you don't have to tell it in the thing you're writing :)
12:26:30 <Fuuzetsu> but everyone here already heard it ;;
12:26:43 <monochrom> heh
12:26:52 <sccrstud92_> Fuuzetsu: i didnt
12:27:05 <Fuuzetsu> good, we need less CT jokes
12:27:18 <sccrstud92_> waaaaat
12:27:21 <Fuuzetsu> ;P
12:27:30 <sccrstud92_> T.T
12:27:41 <Fuuzetsu> I don't think a comedian using CT jokes/puns would make a living
12:27:44 <monochrom> I don't see how the Visitor pattern appears there. but maybe it appears in a degenerate way.
12:27:57 <Fuuzetsu> ew pattern talk
12:28:06 <Fuuzetsu> sorry, Pattern®
12:28:17 <sccrstud92_> tmonochrom: the interpreter is the Visitor, the nodes of the ast are Visitable
12:28:55 <sccrstud92_> i didnt understand the Visitor pattern until i realized this
12:29:21 <Fuuzetsu> is there a need to understand such a thing?
12:29:27 <monochrom> yeah well, but you don't have subclasses or subtypes, so part of the point of Visitor is lost. and good riddance, if you ask me.
12:29:47 <sccrstud92_> the point isnt lost, just the jumping through hoops to implement it
12:30:32 <sccrstud92_> the pattern is the ends, not the means, imo
12:30:58 <vermeille> What is the best way to parse that kind of file format? http://pastebin.com/KKJH8FN7
12:31:26 <sccrstud92_> i think a parser should work well
12:31:32 <mauke> vermeille: lines, words, map read
12:32:19 <kqr> does anyone have an example of openid authentication with yesod? I've banged my head against the wall for the last few hours, not getting anywhere despite trying to follow the types
12:33:04 <vermeille> mauke: okay thanks!
12:37:10 <luite> sccrstud92_: i assume you're talking about final encoding? with initial encoding you have similar patterns, visiting leaves can show up as a Traversable (or Traversal) in Haskell, interpreting is a fold, Data.Foldable
12:39:36 <sccrstud92_> luite: i dont know enough CT to tell you which kind of encoding it is
12:40:27 <sccrstud92_> luite: based on ur description, it seems like an initial encoding. im not sure what i said that gave you the impression of a final encoding
12:40:29 <luite> sccrstud92_: oh no need for much cT there :)
12:40:45 <sccrstud92_> luite: well limits and colimits come from ct, right?
12:41:08 <monochrom> if you write "data Expr = Val Int | Neg Expr", it's initial. if you write "class expr a where val :: Int -> a; neg :: a -> a", it's final
12:43:25 <sccrstud92_> monochrom: very cool, i didnt realize that
12:43:34 <sccrstud92_> i prefer the first version
12:43:37 <sccrstud92_> in general
12:43:43 <monochrom> Oleg taught us the final story
12:43:45 <luite> sccrstud92_: since you mentioned 'AST that can be interpreted in multiple ways' it sounded like final, since there interpretation is much more directly related to teh AST type
12:44:16 <sccrstud92_> luite: isnt the interpretation just a fold?
12:44:27 <sccrstud92_> luite: of the ast
12:44:38 <monochrom> http://okmij.org/ftp/tagless-final/
12:45:19 <monochrom> perhaps http://okmij.org/ftp/tagless-final/course/index.html is better
12:45:33 <luite> sccrstud92_: right, that's what i said. but for the final encoding, you can only do something with the AST by interpreting it, i.e. by using some instance of Expr
12:47:26 <sccrstud92_> luite: is interpreting still a fold with the final ecoding, or just the intial?
12:47:53 <vanila> in the final encoding you can provide different interpretations using typeclass instnaces
12:49:06 <boothead> i've seen several different implementation of taming callbacks and emulating threads. Some used ContT and some FreeT. Can anyone comment on the tradeoffs?
12:49:07 <luite> sccrstud92_: in the final encoding, you can only work with interpretations, so it's not a fold of something, every value you can work with has already been interpreted. of course your interpreter could just turn your AST into an initial one
12:49:25 --- mode: ChanServ set +o mauke
12:49:25 --- mode: mauke set +b *!*@cpe-142-129-50-121.socal.res.rr.com
12:49:59 <sccrstud92_> luite: well since my interpreters look like they are folding, im probably using an initial encoding
12:50:00 <krishnan> Hi, I am a newcomer to haskell. I am getting this error "It is a member of the hidden package containers-0.5.5.1" whenever i try to import
12:50:05 <krishnan> Data.Map
12:50:06 <benzrf> Sorella: are you /u/notSorella
12:50:21 <bergmark> krishnan: how are you compiling your program?
12:51:06 <Sorella> benzrf: hm, I've used that name in a few places, I think
12:51:20 <krishnan> I would appreciate if anyone could help me. I am getting the error in fpcomplete as well as in 'Eclipse fp' project.
12:51:36 --- mode: mauke set -o mauke
12:51:57 <benzrf> Sorella: how dishonest
12:52:11 <luite> sccrstud92_: yes you probably are. you might be interested in some generic traversals. sometimes you might not want to fold a whole tree, but for exampel just do something with all the numeric literals, or extract all the string literals to store them in a global interning table
12:52:16 <Sorella> benzrf: eh?
12:52:28 <benzrf> you're totally Sorella
12:52:31 <bergmark> krishnan: if you have a cabal project you should add containers to the build-depends section
12:52:31 <benzrf> why would you say youre not
12:52:50 <sccrstud92_> luite: you are probably right. another reason why I wish I was using haskell for this project
12:52:57 <Sorella> benzrf: ah, well, I guess :P
12:52:58 <luite> sccrstud92_: you can still express that as a fold, but that's going to take much more code if you have to handle all node types again every time
12:53:12 <krishnan> bergmark: yes, i do have a cabal project and haven't used it much. How do I add containers to a project
12:54:16 <[Bergi]> Hi! Does anyone here know a package/module that offers a helper function like "fmap . fmap"?
12:54:47 <sccrstud92_> :t fmap . fmap
12:54:48 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:55:33 <[Bergi]> Yeah, that thing :-) Map over nested functors.
12:55:49 <sccrstud92_> [Bergi]: sorry couldnt find anything with that signature using hayoo
12:56:47 <luite> sccrstud92_: Control.Lens.Plated and Data.Data.Lens have some useful tools for this type of work :)
12:57:00 <sccrstud92_> luite: I'm using Java
12:57:29 <augur> [Bergi]: what do you mean
12:57:39 <luite> sccrstud92_: oh in that case i'm just trying to make you feel worse about your choice of language ;)
12:57:50 <augur> [Bergi]: do you want something that works like fmap.fmap, but is a pre-defined function? or what?
12:57:51 <monochrom> :)
12:57:57 <sccrstud92_> luite: i was outvoted T.T stop hurting me
12:58:00 <augur> smiling monochrom
12:58:37 <sccrstud92_> augur: he wants a library with foo = fmap . fmap
12:58:38 <cfoch> hey fols
12:58:40 <cfoch> folks
12:58:57 <cfoch> cabal install gtk3 <- to install gtk3 support?
12:58:58 <augur> sccrstud92_, [Bergi]: if this is the case, why? you can just write fmap.fmap
12:59:29 <sccrstud92_> augur: im hoping he knows that he can, but i was too afraid to come out and say it
13:00:35 <augur> @let data T = T T
13:00:37 <lambdabot>  Defined.
13:00:41 <augur> :t T.T
13:00:42 <lambdabot>     Not in scope: data constructor ‘T.T’
13:00:42 <lambdabot>     Perhaps you meant ‘L.T’ (line 155)
13:00:48 <augur> :t T . T
13:00:49 <lambdabot> T -> T
13:03:30 <seagreen> Is there an idiomatic way to handle errors where you don't case about success values? Would `Either MyError ()`, `Maybe MyError`, or something else be nicest?
13:07:53 <krishnan> thanks bergmark, it worked.
13:08:04 <cfoch> please
13:08:09 <cfoch> can somebody help me
13:08:10 <cfoch> http://fpaste.org/145191/42678761/
13:08:20 <cfoch> I am trying to install GLib in Haskell
13:10:00 <sccrstud92_> seagreen: leftToMaybe?
13:10:20 <sccrstud92_> seagreen: nevermind, misread ur question
13:10:46 <sccrstud92_> seagreen: i would use Maybe MyError, but idk if thats best practice
13:12:47 <sivteck> cfoch, you have an old version cabal-install
13:13:17 <cfoch> using version 1.16.0 of the Cabal library
13:13:21 <cfoch> sivteck: ^
13:13:30 <sivteck> you need >=1.18
13:14:25 <cfoch> how do I install the last version in Fedora
13:14:32 <cfoch> is there something such as a rpm package?
13:14:47 <seagreen> sccrstud92_: Thanks! Nothing means "error" so often though, that it feels weird for it to mean success and Just to mean error.
13:15:22 <sccrstud92_> seagreen: i agrre the other case is more common, but this usage is not unheard of
13:15:38 <sccrstud92_> seagreen: hopefully documentation + implementation should make it clear
13:18:24 <cfoch> sivteck: I suppose 1.20.0.3-1.fc20 is okay
13:18:34 <cfoch> i've just installed it
13:18:43 <cfoch> I will try to install gtk3
13:18:58 <sivteck> ok ;]
13:19:36 <cfoch> sivteck: cabal-install version 1.20.0.3 is < 1.18 ?
13:19:48 <cfoch> I can't install
13:20:00 <cfoch> it says
13:20:01 <cfoch> The package 'glib' requires Cabal library version -any && >=1.18
13:20:37 <sivteck> i'm not sure ;/
13:20:49 <mauke> cabal-install is not the Cabal library
13:23:41 <sivteck> cabal install cabal ?
13:23:43 <sivteck> o_o
13:23:49 <cfoch> mauke: so?
13:24:14 <cfoch> hoho
13:24:25 <mauke> so the version of cabal-install doesn't matter
13:24:34 <cfoch> http://fpaste.org/145193/42688431/
13:25:23 <cfoch> really? cabal install cabal?
13:25:27 <folex> Can you guys recommend some haskell IDE that is able to show underlying code for symbols imported from libraries?
13:25:49 <folex> My Intelliji IDEA plugin is great, but it lacks exactly this
13:26:26 <cfoch> sounds like: "this computer will be self-destructed in 10 seconds"
13:27:39 <cfoch> I would like to install gtk3
13:27:44 <sivteck> Cabal and cabal-install will be installed globally when using the distribution's package. What happens when one does cabal install cabal and cabal install cabal-install? (I guess it doesn't install globally and weird things happen?)
13:27:50 <cfoch> I thought it was as simple as cabal install gkt3
13:28:11 <folex> it is.
13:28:26 <folex> `cabal install cabal` stands for upgrading your cabal
13:29:00 <cfoch> my question is... should I use "sudo cabal install cabal" because it seems it works without "sudo"
13:29:11 <cfoch> ?
13:29:43 <monochrom> sivteck: then you also get a local version
13:29:44 <folex> cfoch: you shouldn't use sudo if you don't understand what it means
13:30:22 <hexagoxel> folex: what great advice
13:30:37 <monochrom> cfoch: read my http://www.vex.net/~trebla/haskell/sicp.xhtml for what "sudo cabal install" will really do
13:31:13 <monochrom> on the bright side, it ends up not being harmful, just being useless
13:31:18 <folex> well, guys, any advice on IDE with ability to show underlying source code?
13:31:26 <sivteck> monochrom, so that is bad right?
13:31:30 <pharaun> vim? emacs?
13:31:46 <baetheus> Hello, I tried using the --colour flag as documented on http://www.haskell.org/haskellwiki/GHCi_in_colour but it causes the following error: ghc: unrecognised flag: --colour. Any advice on getting some colored highlighting?
13:32:09 <folex> pharaun: anything else? I like vim, but only as text editor.
13:32:46 <pharaun> folex: well um there's leksah iirc, and there's the web ide at that fpcomplete place too
13:33:05 <pharaun> https://www.fpcomplete.com/business/haskell-center/overview/
13:33:09 <pharaun> that's the 2 that i know of
13:33:51 <monochrom> sivteck: first you must acknowledge the separate existing of "Cabal", a library, and "cabal-install", an executable whose name happens to be "cabal". it is bad to have multiple version of any library, including Cabal. it is ok to have a newer version of the executable.
13:35:40 <bernalex> conal: is a -> IO b a function or merely a morphism? if the latter, what precludes it from being a "true" function?
13:35:42 <sivteck> monochrom, so, the right way to upgrade to the new library is sudo cabal install cabal?
13:35:50 <mauke> no
13:36:00 <mauke> (also, there is no upgrade)
13:36:05 <monochrom> no. I don't know how to deduce that.
13:36:19 <monochrom> ok, I know, but you are in for a surprise.
13:36:20 <conal> bernalex: i see a "->". looks like a function to me, no matter what the domain and range are.
13:36:49 <monochrom> you will end up just getting multiple versions in global.
13:37:13 <monochrom> err, no, scratch that.
13:37:21 <bernalex> conal: a function has a domain and a range. I understand this mostly. the domain is it input. then the range is what it maps the input to for every member of the domain. so f x = y, and for f x of the same x you always get the same y.
13:37:48 <bernalex> conal: for a morphism in categories you have a domain and a codomain. the codomain is somehow "more general" than the range of a "true" function. what is something that is a morphism but not a function?
13:38:14 <conal> bernalex: yes, and i was using "range" somewhat sloppily, as there are multiple meanings. i meant the codomain, i.e., b in a -> b.
13:38:32 <bernalex> conal: so is it not a morphism rather than a true function in the mathematical sense then?
13:39:06 <bernalex> conal: oh wait b is the codomain -- IO is not part of the codomain?
13:39:07 <conal> bernalex: it's a function and a morphism.
13:39:10 <sivteck> monochrom, only way is to nuke ghc and install the latest version then? ;|
13:39:31 <bernalex> conal: so what's the difference between a morphism and a function? all functions are morphisms and not the other way around -- what is an example of a morphism that is not a function?
13:39:32 <monochrom> even GHC does not always come with the latest Cabal
13:39:48 <bernalex> conal: feel free to take your example outside of haskell and in pure maths if this is necessary.
13:39:56 <conal> bernalex: sorry. it's b in a -> b. i should have said that it's q in p -> q, for instance IO b in a -> IO b.
13:40:10 <monochrom> at some point you should ask, must you use the absolutely latest cabal-install? if not, then save the trouble.
13:40:32 <conal> bernalex: "morphism" is relative to some category. for some categories, the morphisms are exactly functions.
13:40:39 <bernalex> conal: aha
13:40:45 <monochrom> if you insist yes, then I'll go to the trouble of suggesting what kind of trouble you should go through to be safe.
13:41:19 <conal> for instance, relations are morphisms in some categories. and inequalities are morphisms in others.
13:41:39 <bernalex> conal: I seem to vaguely recall you saying that IO is not "really" a monad in the categorical sense. do I remember right? if so, why is that?
13:41:46 <bernalex> conal: aha. OK that makes sense.
13:42:01 <sivteck> monochrom, i guess using a sandbox and installing latest Cabal will do for libraries/executable using newer Cabal
13:42:14 <monochrom> yes
13:42:14 <folex> Prelude Graphics.UI.GLUT> color $ Color3 1 1 (1 :: GLfloat)
13:42:14 <folex> Segmentation fault: 11
13:42:17 <folex> .______________________.
13:42:18 <conal> bernalex: i wouldn't have said that about IO. i would have said that no one knows. and that more fundamentally it's an ill-defined question.
13:42:31 <bernalex> conal: could you expand on that thought?
13:42:48 <conal> bernalex: so that saying "IO is a monad" (or "IO is not a monad") is not even wrong.
13:42:59 <bernalex> conal: aha! haha
13:43:28 <conal> bernalex: what does it mean to say that "X is a monad"?
13:43:54 <hiptobecubic> I think everyone but category theorists use monad and Monad interchangeably
13:44:04 <bernalex> conal: that it's an endofunctor with two natural transformations? I'm not saying that with authority, just my thoughts. I'm very new to cat. theory.
13:44:31 <conal> bernalex: okay. and in haskell terms (probably more useful on this channel)?
13:44:35 <bernalex> so it's a monoid in the category of endofunctors. :-]
13:44:57 <bernalex> conal: in haskell terms -- do you mean the monads I'm talking about from cat. theory, or the Monad typeclass?
13:45:01 * hackagebot fay-base 0.19.4.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.4.1 (AdamBergmark)
13:45:35 <conal> bernalex: the typeclass. we could start with either notion. the same difficulty arises.
13:45:37 <Gurkenglas> http://newartisans.com/2012/11/getting-started-with-lenses/ <- "The main difference is that you have to capture and pass through all the members, just to modify the few youre interested in." <- Don't lenses also have to do this, or does lazyness magic deal with this one?
13:46:04 <mauke> Gurkenglas: the point is that lens does it for you
13:46:52 <bernalex> conal: OK. so something which implements the morphism a -> m a, and m a -> m b via "then" and "bind". (and also fail, but let's ignore that wart.)
13:47:04 <Gurkenglas> I mean, this sort of looks like once you are in a situation where you want to change only one part of a big tuple, you've already gone wrong somewhere.
13:47:05 <bernalex> conal: to be a "proper Monad" it should also obey the laws, but these are not guaranteed.
13:47:30 <bernalex> conal: the laws say that Kleisli composition should be associative.
13:47:31 <conal> bernalex: yes, including those laws. that's where the problem arises.
13:48:20 <conal> bernalex: yes. and those laws are equalities.
13:48:24 <cfoch> I have a problem with cabal
13:48:25 <cfoch> http://fpaste.org/145194/14270234/
13:48:33 <bernalex> conal: OK the laws are left/right identiy & associativity. and these guarantee associative Kleisli composition.
13:48:39 <nschoe> Hey all, I can't remember which option to use if I want to monitor the RAM used : it's +RTS then ???
13:48:49 <cfoch> i thought it was not cabal
13:49:00 <conal> bernalex: what do the laws even mean for IO?
13:49:03 <bernalex> conal: so what here precludes us from saying that IO, or indeed [] or Foo is a monad?
13:49:07 <cfoch> but something doesn't looks good in cabal
13:49:16 <bernalex> conal: are we talking specifically about IO?
13:49:18 <Gurkenglas> Mauke, have I got that right?
13:49:29 <conal> bernalex: [] is fine. i don't know about Foo IO is the problem.
13:49:45 <conal> "... Foo. IO is ..."
13:50:32 <dcoutts> cfoch: try --constraint='unix installed'
13:50:53 <dcoutts> cfoch: or maybe both --constraint='unix installed' --constraint='directory installed'
13:51:05 <bernalex> conal: well for one it means that x <- m ; return m = m
13:51:22 <cfoch> dcoutts: I am really new in Haskell, at least with Cabal.
13:51:31 <cfoch> do you mean
13:51:44 <dcoutts> cfoch: so it's helpful to understand what it is saying. It's saying it's going to reinstall the unix and directory packages, changing some of the versions of the things they depend on
13:51:46 <cfoch> "cabal --constraint='unix installed' --constraint='directory installed'" ?
13:52:11 <dcoutts> cfoch: but if it did this, it'd break things that depend on the existing instances of unix and directory, such as Cabal
13:52:18 <conal> bernalex: the difficulty is so basic, it may be hard to spot. it has nothing to do with Monad in particular. it exists for IO as a member of *any* typeclass with equational laws.
13:52:44 <dcoutts> cfoch: so we're asking the solver: "please try with the existing instances of directory and unix". It may tell us that we're asking for the impossible.
13:53:08 <dcoutts> cfoch: cabal install gtk3 --dry-run --constraint='unix installed' --constraint='directory installed'
13:53:11 <thnoob> hi, quick question, can I generate import statements with template haskell? (I have a number of imports common to many modules and I don't want to have to maintain them in multiple separate files)
13:53:47 <MindIsAVortex> Hi there, I'm a bit confused by the cos sin tan functions from the prelude. It's giving back very different results from my calculator. Maybe Im using it wrong. If I do sin 30.0, my calculator says 0.5, while haskell says -0.9880316240928618
13:53:52 <dcoutts> thnoob: I don't think you can. But you can have a module re-export the content of several other modules, so that's another option.
13:53:58 <conal> bernalex: Haskell types other than IO (and friends) have well-defined denotations, and so equality is well-defined (as equality of denotation). IO has no denotation.
13:54:38 <mauke> MindIsAVortex: your calculator is working in degrees
13:54:48 <MindIsAVortex> ah
13:54:57 <MindIsAVortex> hehe, thanks
13:55:03 <bernalex> conal: hmmm.
13:55:06 <cfoch> dcoutts: you mean that? I am misunderstanding I think: http://fpaste.org/145195/14142706/
13:55:08 <dcoutts> conal: I keep thinking that we could define IO semantics using some formalism like CSP.
13:55:11 <monochrom> set your calculator to radian. I did that.
13:55:24 <dcoutts> cfoch: cabal install gtk3 --dry-run --constraint='unix installed' --constraint='directory installed'
13:55:32 <bernalex> cfoch: I'm not clear on the implications of this. do you mean that we cannot say getLine and then getLine once more and prove if these are similar or not?
13:55:36 <bernalex> sorry conal ^
13:55:54 <bernalex> conal: since what they do is not known until executed in RTS
13:55:56 <conal> dcoutts: very doubtful, since IO is mostly not I/O, but rather the repository of everything whose denotation we don't know.
13:56:17 <dcoutts> conal: indeed, so you would not try to define the outside world, but your possible interactions with it.
13:56:38 <conal> see my "toxic avenger" remarks at http://conal.net/blog/posts/notions-of-purity-in-haskell#comment-22829
13:56:44 <dcoutts> conal: like defining a CSP process in isolation. It is prepared to have certain interactions with its environment
13:57:07 <cfoch> dcoutts: http://fpaste.org/145196/14142708/
13:57:20 <conal> dcoutts: sure, one could define a small fragment of IO. not IO.
13:57:40 <thnoob> dcoutts: Thanks, that's the impression I got from reading the docs. Unfortunately, I would like to keep a specific set of aliases common e.g. in all modules I would like to have `import qualified Data.ByteString.Char8 as S` available. It's the nested/aliasing part which AFAIK won't work with re-export (i.e. it flattens everything)
13:57:45 <dcoutts> cfoch: ok, looks good.
13:58:23 <folex> how do you make n-arg function take an n-arg tuple?
13:58:31 <folex> analog for `tupled` in Scala
13:58:42 <cfoch> dcoutts: it would be the second package I install via cabal. Long time ago I installed wxhaskell and it was really complicated. I remember I had to build from the source code.
13:58:58 <cfoch> dcoutts: what should I do know?
13:58:59 <dcoutts> conal: depends what you mean. e.g. if we were to imagine that all we need for the external stuff is FFI, and that every external interaction is ultimately built on top of FFI (we can model the internal things like threads, MVars etc)
13:59:54 <dcoutts> conal: then an FFI primitive can probably be modelled as sending and receiving particular messages
13:59:57 <mauke> cfoch: my guess: now run it for real, by removing --dry-run
14:00:30 <conal> dcoutts: i've heard many variations on this start, but no conclusion.
14:00:45 <cfoch> no good news
14:00:48 <cfoch> dcoutts: http://fpaste.org/145197/27103214/
14:01:05 <hiptobecubic> folex, tupled2 f (a, b) = f a b
14:01:16 <hiptobecubic> folex, as needed
14:01:22 <Gal3rielol> why monad is more powerful then applicative
14:01:51 <conal> i'm really making a very simple claim here: equality on IO is not defined, and so any claims of equations holding are also ill-defined.
14:02:01 <folex> hiptobecubic: thx
14:02:19 <conal> one can explore possible meanings, and i've heard many starts, but no conclusions.
14:02:22 <dibblego> folex: (,)
14:02:23 <hiptobecubic> folex, for the case of tupled2 that function is called uncurry
14:02:31 <bernalex> conal: as I said back there -- do you mean then that if I do x <- getLine ; y <- getLine, the problem is that it's not possible to test x & y for equality?
14:02:34 <bernalex> conal: as an example
14:02:36 <hiptobecubic> i think, or maybe it's curry
14:02:41 <benzrf> Gal3rielol: it is because you can implement (<*>) in terms of join but not vice versa
14:02:45 <folex> dibblego: what do you mean?
14:02:46 <dcoutts> cfoch: see the error message, do what it suggests.
14:02:54 <dibblego> folex: actually no, there is no Scala tupled in haskell, because Haskell gets functions right (they all take one argument)
14:03:21 <conal> my guess is that any successful definitions for IO would be very unsatisfactory. or in other words, would give more clarity to exactly *why* imperative programming is a mess, as Backus explained in his Turing award paper.
14:03:31 <folex> dibblego: so there is no way to pass a 3-element tuple to 3-argument function?
14:03:31 <cfoch> ok
14:03:37 <dcoutts> conal: yes both points are fair enough. Actually going and defining a semantics is a big task.
14:03:37 <cfoch> I am looking for example
14:03:43 <cfoch> that there's no a .cabal/bin dir
14:03:46 <conal> bernalex: it's not about x and y, which have type String.
14:03:50 <hiptobecubic> folex, the point is that there are no 3 argument functions.
14:03:57 <dibblego> folex: all Haskell functions take one argument  there are no exceptions to the rule. Applying Scala-semantics to Haskell is going to end badly.
14:04:00 <cfoch> I suppose I have to mkdir it
14:04:03 <folex> hiptobecubic: I understand that
14:04:08 <bernalex> conal: ah. OK. so getLine and getLine by themselves.
14:04:18 <dcoutts> cfoch: no, you just need to install gtk2hs-buildtools as it says.
14:04:22 <hiptobecubic> folex, there are functions which return functions, etc. And you can do multiple application to make it feel like multiple arguments
14:04:23 <dibblego> folex: Scala has functions all messed up so badly, that "tupled" even exists  that's how bad it is
14:04:27 <hiptobecubic> folex, like i showed
14:04:27 <folex> dibblego: I just have list of zipped 3-element tuples
14:04:34 <dcoutts> cfoch: ie cabal install gtk2hs-buildtools
14:04:34 <conal> bernalex: yes, for instance. or that whole IO fragment and another one.
14:04:39 <hiptobecubic> dibblego, you probably need to explain that statement if you're going to be helpful to folex
14:04:42 <dibblego> folex: ok, what do you need with that?
14:04:51 <bernalex> conal: right. I see what you mean. then this problem should hold for all IO-y things.
14:04:53 <dibblego> @google all haskell functions take one argument
14:04:54 <lambdabot> http://www.haskell.org/haskellwiki/Currying
14:04:54 <lambdabot> Title: Currying - HaskellWiki
14:05:01 <hiptobecubic> folex, tupled3 f (a,b,c) = f a b c
14:05:07 <dibblego> hiptobecubic: I did http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/index.html
14:05:30 <hiptobecubic> map (tupled3 f) listOfTuples
14:05:33 <conal> bernalex: yes. and for IO in connection all type classes having laws. all such claims are ill-defined.
14:05:34 <folex> hiptobecubic: In which package tupled3 lays? I can't even google it :(
14:05:34 <dibblego> hiptobecubic: that is not equivalent to tupled
14:05:39 <cfoch> dcoutts: http://fpaste.org/145198/41427130/
14:05:46 <bernalex> conal: are they not known (the equality) at runtime?
14:05:53 <hiptobecubic> folex, i just wrote it. it's one line. just define it yourself
14:05:56 <bernalex> cfoch: i.e. after getLine & getLine have been executed in RTS
14:06:10 <dibblego> folex: it doesn't exist  that is just a church-encoding of a tuple (it is not the same as tupled, as you asked  which does not exist in haskell)
14:06:20 <folex> hiptobecubic: ah. I misunderstood you. Thanks
14:06:22 <cfoch> force is not my preferred "command"
14:06:31 <conal> bernalex: what does the question even mean?
14:06:33 <dcoutts> cfoch: cabal install gtk2hs-buildtools --constraint='unix installed' --constraint='directory installed'
14:06:34 <cfoch> should I force ?
14:06:37 <hiptobecubic> dibblego, I'm not saying it is. I'm saying that it solves his problem, which turns out not to be "I need tupled" it's "I need tupled3"
14:07:02 <folex> dibblego: I guess I was wrong when I said that I need "same as tupled", sorry
14:07:07 <dibblego> hiptobecubic: oh I missed that line  he actually needs uncurry3
14:07:16 <dcoutts> cfoch: it looks like you've got time-1.5 installed, and so cabal keeps wanting to use it, by recompiling other things to use it. Would probably be better if you removed the extra version of time or you'll keep getting this problem.
14:07:16 <dibblego> er, curry3
14:07:22 <hiptobecubic> dibblego, right, i mentioned that were was uncurry out there as well
14:07:29 <hiptobecubic> @type uncurry
14:07:30 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:07:38 <hiptobecubic> He needs uncurry3
14:07:53 <hiptobecubic> Which you can surely import from somewhere, but it's probably faster to just define it yourself really
14:08:05 <cfoch> now it says I have to install "alex" I am installing it
14:08:06 <bernalex> hiptobecubic: didn't the user ask about n args & n tuples?
14:08:12 <bernalex> hiptobecubic: which is not really solvable in haskell
14:08:38 <monochrom> people ask over-specified, over-generalized questions all the time
14:08:42 <bernalex> conal: I would, at least prior to our conversation here, say that getLine is equal to getLine in that it is the same set of instructions
14:09:00 <cfoch> dcoutts: http://fpaste.org/145199/42714991/
14:09:01 <conal> bernalex: btw, Landin points out exactly this sort of issue when he deprecates the ill-defined terms "declarative" and "functional" in favor of the "denotative" in his seminal "Next 700" paper. a quote and pointers start at http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882 .
14:09:01 <dibblego> map (Hole f) (listOfTuples :: [(A, B, C)]) -- this is what the user asked
14:09:10 <bernalex> conal: that was my intuition for an IO String. that it's the set of instructions for obtaining a String when the action is evaluated in RTS.
14:09:18 <cfoch> you could say: "ok, install alex!" But I've just installed it.
14:09:20 <bernalex> conal: yes, I have read that paper many times.
14:09:39 <folex> bernalex: I needed exactly tupled3 :)
14:09:45 <dcoutts> cfoch: it's not on your $PATH
14:09:49 <bernalex> folex: great.
14:10:09 <conal> bernalex: in particular, Landin says "When faced with a new notation that borrows the functional appearance of everyday algebra, it is (c) that gives us a test for whether the notation is genuinely functional or merely masquerading." And Haskell-with-IO is in this sense not "genuinely functional".
14:10:41 <bernalex> conal: do you know any resources for getting started with denotational design as a practical and formalised workflow for your daily software development challenges?
14:11:38 <bernalex> in some sense I suspect I'm already doing it, but I would like to be more concious in doing it.
14:11:47 <conal> bernalex: and do you want equality to mean equality of such *programs*, rather than their meanings? if so, a compiler couldn't optimize while preserving equality. a pretty useless notion of equality.
14:12:10 <bernalex> conal: aha. I see that point.
14:12:35 <bernalex> conal: so what I'm getting from this is that IO does not even disobey the monad laws. :-]
14:13:04 <conal> bernalex: i don't know of anything on DD other than my blog posts and http://conal.net/papers/type-class-morphisms/.
14:13:22 <conal> bernalex: hah. exactly. it fails even to fail.
14:13:37 <bernalex> conal: I will read that paper at work on Monday, thank you.
14:14:16 <conal> bernalex: wrong would be progress from there. for an answer to be wrong, one has to have an actual question.
14:15:53 <conal> bernalex: i'm sorry that i don't have a paper about DD independent from TCMs (type class morphisms). that latter give a wonderful way to structure the former. TCM leads one to elegant design, and guarantees that class laws hold, without even trying.
14:16:26 <conal> bernalex: "... morphisms). though the latter ..."
14:16:54 <cfoch> compiling and praying
14:18:23 <bernalex> conal: hope that lambdajam video gets available sometime soon. :-]
14:18:39 <benzrf> bernalex: which one?
14:19:13 <bernalex> benzrf: denotational design
14:19:31 <benzrf> ooh i was present for that
14:19:34 <benzrf> it was great!
14:19:43 <benzrf> as other have remarked, conal is the bob ross of fp
14:19:46 <bernalex> conal: I have to go. family time. have a good day, and thank you for enlightening me, as always.
14:19:47 <benzrf> *others
14:20:02 * cfoch is scared. Terminal hangs in "Preprocessing library gtk3-0.13.0.3"
14:20:11 <cfoch> it passed...
14:21:36 <cfoch> \o/
14:21:38 <cfoch> finally
14:21:40 <conal> bernalex: enjoy family!
14:21:41 <cfoch> \o/
14:21:49 <cfoch> dcoutts: thanks
14:22:07 <cfoch> \o/
14:22:10 <conal> benzrf: ha. not sure what you mean by that remark.
14:22:22 <monochrom> who is bob ross?
14:22:47 <simpson> monochrom: A guy who painted on TV in the USA.
14:23:06 <simpson> There's lots of old videos of him on Youtube. He was very calm and patient, and had a very relaxed style.
14:25:24 <benzrf> soothing voice too (or so im told)
14:33:48 <nschoe> Hi, can anyone explain to me why I get this error : "/tmp/enc9875: openBinaryFile: resource busy (file is locked)". I used getTemporaryDirectory and openBinaryTempFile
14:37:18 <cfoch> what is the ":=" in haskell ?
14:37:57 <geekosaur> there isn't one, really. values and bindings are immutable
14:38:24 <Ferdirand> well that would be a valid infix constructor, no ?
14:39:26 <zwer> yes
14:39:47 <benzrf> @src (***)
14:39:47 <lambdabot> f *** g = first f >>> second g
14:39:50 <benzrf> aha!
14:40:46 <nschoe> I found why I got the "file locked" error : I opened it with openBinaryTempFile and attempted to write in it with ByteString.writeFile :-)
14:41:25 <asdkfjasndlkfj> @help
14:41:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:41:33 <asdkfjasndlkfj> @help pl
14:41:33 <lambdabot> pointless <expr>. Play with pointfree code.
14:42:05 <asdkfjasndlkfj> @pl \x y -> fst x == fst y
14:42:05 <lambdabot> (. fst) . (==) . fst
14:43:43 <benzrf> @src second
14:43:43 <lambdabot> Source not found. My mind is going. I can feel it.
14:43:46 <benzrf> @src first
14:43:47 <lambdabot> Source not found. Are you on drugs?
14:43:49 <benzrf> heh
14:43:57 <benzrf> :t swap
14:43:58 <lambdabot> (a, b) -> (b, a)
14:44:05 <recursion-ninja> @src mapM
14:44:05 <lambdabot> mapM f as = sequence (map f as)
14:44:11 <benzrf> :t \f -> arr swap . first f . arr swap
14:44:12 <lambdabot> (b1 -> a) -> (b, b1) -> (b, a)
14:44:20 <recursion-ninja> :t mapM
14:44:20 <benzrf> :t \f -> arr swap >>> first f >>> arr swap
14:44:21 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:44:21 <lambdabot> Arrow cat => cat b c -> cat (a, b) (a, c)
14:44:30 <benzrf> neat
14:45:10 <uname-a> @pl \x y -> (fst x, snd x + snd y)
14:45:10 <lambdabot> ap ((.) . (,) . fst) ((. snd) . (+) . snd)
14:45:11 <recursion-ninja> :t sequence
14:45:12 <lambdabot> Monad m => [m a] -> m [a]
14:46:15 <benzrf> :t T.sequenceA
14:46:16 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:46:22 <benzrf> handy!!
14:46:32 <benzrf> > T.sequenceA (3, Just 4)
14:46:34 <lambdabot>  Just (3,4)
14:47:32 <benzrf> > T.sequenceA (M.fromList [("foo", [3, 4]), ("bar", [5, 6]), ("baz", [7, 8])])
14:47:34 <lambdabot>  [fromList [("bar",5),("baz",7),("foo",3)],fromList [("bar",5),("baz",7),("fo...
14:47:36 <uname-a> @pl \f x y -> f x == f y
14:47:36 <lambdabot> flip =<< (((.) . (==)) .)
14:47:54 <benzrf> :t liftA2 (==)
14:47:55 <lambdabot> (Applicative f, Eq b) => f b -> f b -> f Bool
14:48:13 <benzrf> :t liftA2 (==) `asTypeOf` \f x y -> f x == f y
14:48:15 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ t -> b
14:48:15 <lambdabot>     Expected type: (t -> b) -> b
14:48:15 <lambdabot>       Actual type: t -> b
14:48:18 <benzrf> oh
14:48:26 <cdk> :t \f -> (==) `on` f -- uname-a
14:48:26 <benzrf> :t \f x y -> f x == f y
14:48:27 <lambdabot> Eq a => (t -> a) -> t -> t -> Bool
14:48:27 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
14:48:33 <benzrf> oh i see
14:48:49 <cdk> :t on (==)
14:48:50 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
14:49:04 <benzrf> > T.sequenceA (M.fromList [("foo", [3, 4]), ("bar", [5, 6]), ("baz", [7, 8])]) -- Maps are sequenceable
14:49:06 <lambdabot>  [fromList [("bar",5),("baz",7),("foo",3)],fromList [("bar",5),("baz",7),("fo...
14:49:35 <Maxdamantus> :t liftA2 (==) `asTypeOf` \f x y -> x f == y f
14:49:36 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f b)
14:49:36 <lambdabot>     Expected type: f b -> b
14:49:36 <lambdabot>       Actual type: f b
14:50:21 <benzrf> Maxdamantus: that'd be \x y f
14:50:40 <Maxdamantus> ah yeah
14:54:53 <felixn> wow, lazy evaluation is a dream ... I'm prototyping a language and I don't have to make nodes as visited ... I just define the recursion and Haskell takes care of the rest ^_^
14:56:07 <EvanR_> yeah
14:56:18 <EvanR_> laziness is awesome
14:57:04 <benzrf> damn im lazy
14:57:11 * felixn deletes NodeVisited from data type
14:57:32 <jle`> lazy evaluation gives me so many free performance benefits without even thinkinga bout it
14:57:36 <jle`> it's awesome
14:58:01 <EvanR_> lazy evaluation saved my cat from a tree
14:58:21 <monochrom> lazy evaluation saved Schrödinger's cat
14:58:35 <folex> Num (t -> t1) => Integer -> (t, t, t) -> (t1, t1, t1)
14:58:36 <folex> what does `Num (t -> t1)` mean?
14:58:59 <monochrom> it means that you use a function at a place a number is expected.
14:59:07 <monochrom> for example "sin + 4"
14:59:26 <folex> monochrom: but that was induced by repl
14:59:26 <benzrf> @google cartesian closed comic schrodinger
14:59:27 <lambdabot> http://ro-che.info/ccc/4
14:59:28 <lambdabot> Title: Cartesian Closed Comic #4: Schrödinger's cat
14:59:34 <jle`> Num a => ... means that this thing works if `a` is an instance of Num
14:59:40 <pjdelport> folex: Functions are just a type, so that's saying it's expecting the given function type to be a Num instance.
14:59:47 <jle`> Num (t -> t1) => ... means that this thing works if (t -> t1) is an instance of Num
14:59:48 <monochrom> that doesn't change what I said
14:59:49 <EvanR_> folex: you may have passed the wrong number of arguments to something
14:59:53 <jle`> have you learned about typeclasses yet?
14:59:55 <pjdelport> (Which is usually by accident)
14:59:56 <folex> but that's impossible, yes?
15:00:08 <jle`> it's totally possible to define a Num instance for any type
15:00:15 <pjdelport> folex: It's not impossible; there just isn't such an instance defined by default.
15:00:16 <folex> jle`: I understand what Num a => means, just can't apply that to function ._.
15:00:17 <jle`> instance Num anyTypeAtAll where ....
15:00:22 <EvanR_> instance Num Void where
15:00:30 <folex> pjdelport: ah. Thanks.
15:00:31 <jle`> a common fun Num instance would be
15:00:42 <jle`> instance Num b => Num (a -> b) where ...
15:00:51 <sccrstud92_> jle': when is your next frp blog post coming out?
15:00:54 <jle`> f + g = \x -> f x + g x
15:00:56 <jle`> etc.
15:01:24 <jle`> sccrstud92_: heh.  i have had second thoughts about that series.  i have come to really re-assess my understanding of frp, and that series feels a bit outdated to me.  so i'm trying to figure out how to reframe it to make more sense.
15:01:25 <sccrstud92_> jle': afrp*
15:01:27 <jle`> but the last one should be out soon
15:01:31 <Fuuzetsu> are we giving functions a Num instance again
15:01:51 <pjdelport> folex: Does jle`'s instance make sense?
15:02:14 <folex> pjdelport: yes
15:03:04 * folex trying to compose `mapTuple :: (a -> b) -> (a, a, a) -> (b, b, b)` and `fromInteger :: Num a => Integer -> a`
15:03:20 <folex> and getting strange result for now ._.
15:04:03 <EvanR_> :t (.)
15:04:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:04:05 <monochrom> compose them in what order?
15:07:52 <folex> monochrom: that's a good question. Thanks, now I realise I didn't want composition, just partial application
15:08:07 <cfoch> ":="hello
15:08:20 <cfoch> I am new in GTK + HASKELL
15:08:29 <cfoch> can somebody tell me what can i be doing bad
15:08:30 <cfoch> http://fpaste.org/145201/14275074/
15:08:30 <cfoch> ?
15:08:48 <cfoch> i get this error
15:08:49 <cfoch> http://fpaste.org/145202/27511714/
15:08:49 <cfoch> please
15:09:19 <Fuuzetsu> cfoch: check the type of ‘buttonClicked button’
15:09:47 <yukko> cfoch you might need to lift your IO action
15:09:53 <cfoch> buttonClicked :: ButtonClass self => self -> IO ()
15:10:20 <Fuuzetsu> hm, should work now that I think about it
15:10:27 <cfoch> yukko: but putStrLn "Hola or Hello", is not an IO () ?
15:10:34 <Fuuzetsu> can you try ‘buttonClicked button (putStrLn "Hola")’
15:11:12 <cfoch> Fuuzetsu: http://fpaste.org/145203/14142752/
15:11:21 <yukko> oh, buttonClicked just emits the "clicked" signal on the button
15:11:34 <Fuuzetsu> oh, right
15:11:34 <Fuuzetsu> yes
15:11:36 <Fuuzetsu> of course
15:11:37 <Fuuzetsu> ;P
15:11:46 <yukko> if you want to set a signal handler, you should do: button `on` buttonActivated $ yourIOaction
15:14:13 <cfoch> yukko: the only way?
15:14:33 <jlouis> bitemyapp: here?
15:14:51 <jlouis> bitemyapp: it is a bit easier than the 140 character twitter limit :)
15:15:46 <cfoch> yukko: how do you know it is `on` function ?
15:16:08 <Fuuzetsu> it's just on from Data.Function
15:16:35 <bitemyapp> jlouis: greetings
15:16:41 <yukko> cfoch well that's just the standard way to set signal handers with gtk2hs
15:16:57 <jlouis> oy!
15:17:08 <yukko> there is also "after", which is slightly different from "on"
15:17:12 <bitemyapp> jlouis: anyway so, overhead right now is predominantly timestamp nonsense in the Haskell version.
15:17:30 <bitemyapp> jlouis: one thing I can do is avoid unnecessary transmogrification of the timestamp data by doing a direct FFI call.
15:17:34 <jlouis> Yeah, I wonder where the time goes in the Erlang code :)
15:17:52 <bitemyapp> jlouis: another option is delegating "current timestamp" management to a caching manager
15:17:57 <cfoch> I am trying to make an on/off button
15:18:26 <bitemyapp> jlouis: I've done some Erlang, but not profiling. I wasn't going to attempt because I don't know internals well enough to trust my conclusions.
15:18:46 <jlouis> I'll look into it a bit I think
15:20:01 <bitemyapp> jlouis: that'd be great. Please don't feel I'm asking you to do work for me. I have my own stuff.
15:20:30 <bitemyapp> jlouis: the problem with the caching manager is that in order to maintain correctness I think I'd need to spawn an OS thread and pin a CPU to it.
15:20:38 <jlouis> bitemyapp: don't worry, my curiosity is there :)
15:21:12 <bitemyapp> unless I can jigger around the RTS or otherwise somehow guarantee a context switch won't cause it to mess up timings. I guess I *could* do it with green threads but that would be slightly more precarious than the alternative.
15:23:59 <success> Is there a C code generator for haskell?
15:24:24 <monochrom> jhc compiles haskell to C
15:24:34 <success> j=?
15:24:44 <monochrom> it's just the name of a compiler
15:25:03 <EvanR_> john's or something
15:25:30 <monochrom> http://repetae.net/computer/jhc/
15:27:04 <capisce> how about http://ivorylang.org/ivory-introduction.html ?
15:29:52 <dfeuer> success, there's a GHC option to make C code, but you need a specially compiled GHC, and I'm not sure you can necessarily expect everything to work right.
15:30:09 <dfeuer> -fvia-C
15:30:49 <jlouis> bitemyapp: https://gist.github.com/jlouis/7e1858029638cb5ef169 is the profiling run on my machine. Don't put too much into the runtimes, eprof usually adds some 15-20% overhead
15:31:12 <bitemyapp> jlouis: that was fast mate.
15:31:14 <cfoch> yukko: how would it be to "    onDestroy window mainQuit" ?
15:31:39 <jlouis> Mind you, my GHC profiling is rusty, so I won't attempt that for your lib :)
15:34:04 <monochrom> cfoch: I have a gtk example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml , but it uses 2, not 3. I don't know what changed. anyway, I did: mywindow `on` deleteEvent $ liftIO (mainQuit >> return False)
15:34:16 <bitemyapp> jlouis: very interesting, thanks.
15:34:30 <jlouis> bitemyapp: there is nothing which looks way off to me in that output
15:35:08 <jlouis> There are some smaller mistakes in the code base, but nothing glaringly bad. I could tune it for a couple of constants, but it is rather minuscule
15:35:28 <bitemyapp> jlouis: 120 nanos to get current time is pretty good.
15:35:34 <jlouis> It doesn't look like there is a O(N^2) thing which could be fixed to an O(n)
15:35:48 <bitemyapp> jlouis: or at least, not awful. the time code I used is…not good.
15:35:53 <jlouis> OSX?
15:36:14 <bitemyapp> jlouis: I don't actually remember which I tested it on.
15:36:15 <yukko> cfoch window `on` objectDestroy $ mainQuit for GTK3
15:36:25 <bitemyapp> jlouis: I switch back and forth a lot.
15:36:32 <jlouis> This is highly OS dependent. Some OS's cheat here ;)
15:36:37 <bitemyapp> jlouis: I don't remember a significant difference.
15:36:50 <jlouis> also, Erlang will cheat you as well for this thing :P
15:36:53 <bitemyapp> jlouis: but there was a range of 250-600 ns for get current millis in my code.
15:37:01 <bitemyapp> which is blurgh.
15:37:10 <bitemyapp> but readily fixed.
15:37:14 <jlouis> erlang:now() is *guaranteed* strictly monotonic
15:37:23 <jlouis> even if having multiple cores
15:37:32 <bitemyapp> yeeeahhhh mine isn't. That's why it pukes on arrow of time error.
15:37:33 <jlouis> and in the event which happens later this night :)
15:37:54 <jlouis> it does time smearing automatically for daylight savings
15:37:55 <bitemyapp> jlouis: so, I'd like to use monotonic clock via FFI
15:38:06 <bitemyapp> jlouis: but haven't decided how useful that is.
15:38:06 <cfoch> yukko: why you use $ mainQuit
15:38:10 <cfoch> why $$$ ?
15:38:17 <bitemyapp> cfoch: mo money
15:38:23 <cfoch> xD
15:38:23 <bitemyapp> cfoch: mo problems
15:38:32 <jlouis> bitemyapp: my hunch is a fake clock is probably better
15:38:44 <bitemyapp> jlouis: fake meaning monotonic or real-time?
15:38:49 <jlouis> monotonic :)
15:38:55 <bitemyapp> oh right, da.
15:39:11 <yukko> cfoch $ is just function application, g $ f $ a is the same as g (f a)
15:39:12 <bitemyapp> jlouis: then the problem becomes, do we lose the ability to know which version of the code was running when the id was generated?
15:39:16 <jlouis> that is, you only poll the OS at intervals and adjust at the fine granularity without asking the OS
15:39:34 <bitemyapp> that's the caching 'ish behavior I was alluding to.
15:39:46 <bitemyapp> get timestamp, sleep for intervals, requery
15:39:51 <jlouis> it may work, but I have not given it much thought :)
15:40:01 <bitemyapp> but timings and context switches are dangerous there when you're measuring in nanos and micros.
15:40:02 <jlouis> erlang:now() roughly does that
15:40:14 <jlouis> but it is tied into the runtimes timing construction at the deeper level
15:40:17 <yukko> it's just a neat way to write it, I think you might also be able to get away with (window `on` objectDestroy) mainQuit
15:40:42 <jlouis> nanos requires something like criterion to be somewhat believable
15:40:54 <bitemyapp> jlouis: Right.
15:40:59 <jlouis> OCamls Core Bench does the same
15:41:08 <bitemyapp> jlouis: but the FFI code I was thinking of using for timing was actually going to be a direct port of what criterion does.
15:41:13 <jlouis> Erlang doesn't really care there :)
15:41:35 <jlouis> mm
15:41:53 <jlouis> but then you are right, that you may want to think about multiple cores asking and think about core pinning
15:41:59 <alphonse23_> I'm just wanted to tell everybody, that is all 1419, that I finally finished reading learnyouahaskell!
15:42:04 <jlouis> Time is a bitch :)
15:42:05 <alphonse23_> now I can move on to the next book
15:42:39 <yukko> alphonse23_ that's pretty cool!
15:42:47 <alphonse23_> okay thanks man
15:44:46 <jlouis> bitemyapp: it isn't 120 nanos, its 310 nanos
15:45:02 <jlouis> You have to add curr_time_millis/0 and erlang:now/0
15:45:14 <jlouis> one calls the other, which eprof can't show.
15:45:30 <cfoch> yukko: is the same
15:45:46 <cfoch> a `on` b than "on a b" ?
15:45:46 <cfoch> :S
15:45:50 <yukko> yes
15:46:34 <yukko> putting functions inside of backtics lets you use them as infix operators (like +, *, etc)
15:46:34 <alphonse23_> anybody know a book that covers comonads and lens?
15:46:41 <bitemyapp> jlouis: oh woops.
15:47:18 <jlouis> Hell let me try to make it a bit faster :)
15:48:06 <yukko> I like to put "on" and "set" and such inside of them because it makes a bit more sense to read but it's not necessary
15:50:15 * hackagebot hosc-json 0.15 - Haskell Open Sound Control JSON Serialisation  http://hackage.haskell.org/package/hosc-json-0.15 (RohanDrape)
15:57:57 <jlouis> bitemyapp: ok, the obvious speedups gave so few ms it is not worth it
15:58:24 <jlouis> I guess the 172ms it takes here is around where it is
15:58:48 <bitemyapp> alphonse23_: do the NICTA course.
15:59:22 <bitemyapp> alphonse23_: I just replied to your reddit thread. NICTA covers comonads, but doesn't bridge the gap to lenses. I have resources for learning lenses in my guide. There's a kata thing you could do for that as well.
15:59:37 <alphonse23_> oh okay
15:59:38 <alphonse23_> cool
15:59:47 <alphonse23_> I saw you github resource page too
16:00:02 <alphonse23_> I'll be using that to figure out what I'd like to work on next
16:00:16 * hackagebot haskell-neo4j-client 0.3.0.7 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.7 (asilvestre)
16:00:47 <bitemyapp> alphonse23_: cool. Let me know if you have any questions.
16:02:01 <alphonse23_> the other book too that I really want to read though I'm not sure it's good for learning is the yale haskell school of music
16:02:25 <alphonse23_> know anything about it?
16:08:39 <Kaidelong> if I make a website with Hakyll, will a Hakyll code base play nice if I want to use it with something like Yesod later?
16:09:03 <Kaidelong> if not, is it possible to make a static website using Yesod's libraries but without actually using the warp server?
16:09:10 <jlouis> bitemyapp: https://gist.github.com/jlouis/6069357f506372de331b <- simple patch parallelizing the callers. Goes from 172ms to around 130ms on this machine
16:09:55 <Kaidelong> ideally I want to be able to "compile" to a static web site and something like Yesod should be able to do this but I'm not sure if they actually implemented that
16:10:05 <jlouis> It goes faster because it has a concurrency level larger than one for the whole duration of the execution
16:10:19 <jlouis> whereas the original code is exactly 1. Either the server or the client is doing work
16:10:27 * bitemyapp nods
16:10:38 <jlouis> of course, it is still not parallel
16:10:41 <bitemyapp> jlouis: I hadn't been optimizing the batch case, not representative of normal workload.
16:10:53 <jlouis> right
16:11:03 <bitemyapp> jlouis: I was poking at the times spent in a single call and grumbling about the time API.
16:11:17 <jlouis> There is a variant of this in Erlang running on ETS with a clever use of ets:update_counter/3 I think
16:11:30 <jlouis> that would be closer to the MVar version and it would parallelize better
16:11:32 <bitemyapp> jlouis: the monotonic time stuff pretty much exists as a one-off cbits dir in Criterion, seems like it should be a library. What do you think?
16:12:07 <jlouis> Speaking from Erlang experience, erlang:now() being monotonic have saved me so many times it hurts
16:12:16 <bitemyapp> jlouis: I should just make a library.
16:12:29 <bitemyapp> micro-library albeit, but still
16:12:36 <jlouis> having a monotonic unique id is very nice
16:12:37 <bitemyapp> there isn't really any lower level time stuff.
16:12:43 <benzrf> jlouis: monotonic?
16:12:46 <benzrf> what do you mean
16:12:50 <jlouis> strictly monotonic!
16:12:59 <jlouis> benzrf: 2 seconds
16:13:02 <benzrf> but it doesnt take a parameter?
16:13:28 <bitemyapp> benzrf: we're talking about time.
16:13:39 <benzrf> oh
16:13:43 <jlouis> http://erlang.org/doc/man/erlang.html#now-0 first paragraph
16:13:49 <bitemyapp> benzrf: jlouis is a long time Haskell user. wrote network stuff in Haskell way back in the day.
16:13:57 <bitemyapp> benzrf: wrote combinatorrent among other things, IIRC
16:14:06 <jlouis> it is also leap second, and daylight time savings safe btw
16:14:13 <bitemyapp> benzrf: also an Erlang user which is why we're comparing the same service in diff langs at the moment.
16:14:18 <jlouis> yeah :)
16:14:27 <benzrf> but what if u call that function more than a 1000 times in a second
16:14:30 <jlouis> combinatorrent was my old experiment
16:14:37 <jlouis> however, I am not doing lots of Haskell these days
16:14:50 <bitemyapp> jlouis: yeah I need epochal monotonic timestamp like "now"
16:14:55 <jlouis> worked professionally with Erlang for some years, also likes OCaml, Twelf, Agda, ,...
16:14:57 <jlouis> the usual suspects
16:15:04 <Kaidelong> yesod-static doesn't appear to be solving the problem I want solved, but I'm not sure what it is doing exactly
16:15:07 <bitemyapp> jlouis: the libraries and concurrency tooling is a lot better now than it was in 2006 or so.
16:15:16 <bitemyapp> jlouis: Twelf and Agda? Hot damn.
16:15:31 <jlouis> I think I did work around 2010. It is based on STM, combinatorrent that is
16:15:56 <bitemyapp> jlouis: did you see the MIO paper?
16:16:00 <jlouis> But I reckon that the IO manager stuff which went in later could have been majorly useful
16:16:07 <bitemyapp> which I guess is what you just alluded to?
16:16:08 <jlouis> bitemyapp: no, shoot?
16:16:14 <bitemyapp> oh, well, they did even more in 7.8
16:16:19 <bitemyapp> jlouis: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
16:16:28 <jlouis> Combinatorrent has some suspect code around IO
16:16:31 <Kaidelong> looks like it is intended to build a static website that is then served by a yesod application, not to use cassius, lucius etc to build a static website
16:16:34 <jlouis> I guess you can make it simpler today
16:16:47 <cfoch> well... guys... I want to make a hangouts
16:17:05 <cfoch> about what I did today in GTK3 + Haskell
16:17:11 <cfoch> a hangouts
16:17:12 <cfoch> https://www.youtube.com/watch?v=6T_nKXa0WMo
16:17:53 <jlouis> bitemyapp: I am also trying to tiptoe myself into linear logic programming and CELF
16:18:12 <jlouis> being the concurrency/distribution nut that I am :)
16:18:32 <bitemyapp> jlouis: Hrm. TLA+?
16:18:52 <jlouis> No, it is closer to a dependently typed pi calc :)
16:18:52 <bitemyapp> jlouis: what do you make of the buzz around CRDTs and the lattice based stuff?
16:19:22 <bitemyapp> ah, Standard ML project. Cool. Nice to see people using smackage.
16:19:55 <jlouis> when CRDTs work, they work *really* well. But they are for systems which can be modelled as AP systems in the sense of CAP
16:20:18 <bitemyapp> jlouis: that much makes sense.
16:20:23 <jlouis> Nice building block, but not always applicable
16:20:27 * bitemyapp nods
16:21:20 <jlouis> Like in complexity theory where you have complexity classes: P, NP, NP-C, BPP, QPP, P-space, ...
16:21:42 <jlouis> In distribution you have classes: Read consistent, snapshot isolation, serializable, linearizable, ...
16:22:36 <jlouis> The crux is that some of these classes only work in the CP setting of CAP whereas other works inthe AP setting
16:23:19 <jlouis> so you are really modelling your problem by navigating treacherous waters. And that is where lattices and CRDTs fit in. Sometimes they let your shortcut the whole thing.
16:23:26 <bitemyapp> jlouis: yeah I follow Bailis and liked his paper modelling those differences.
16:24:34 <jlouis> but I also feel people sometimes overdo these things. They address massive scalability on a 100 gigabyte dataset they could easily maintain in RAM
16:24:57 <Kaidelong> okay I will just use hakyll then
16:25:16 <Kaidelong> does classy-prelude actually have any documentation anywhere?
16:25:25 <jlouis> many of these techniques usually comes into play when you hit 20+ terabytes and/or a massive computation overhead so you need to spread over multiple machines for real
16:25:33 <Kaidelong> or does it consist of blog posts?
16:26:03 <jlouis> As for TLA+, I've been pestering people for tutorials so I can being learning it :)
16:30:08 <yukko> cfoch I tried to look at your youtube link but it won't load in my browser :(
16:33:01 <bitemyapp> jlouis: if you find a tutorial for TLA+, please let me know.
16:34:25 <jlouis> bitemyapp: no luck as of yet. Maybe I should just buy the book on it and begin reading :)
16:34:50 <bitemyapp> jlouis: guess so.
16:38:57 <folex> https://gist.github.com/folex/735965e9f432efd50ca0 gives     Could not deduce (Floating Rational) arising from a use of ‘**’
16:38:57 <folex> Can't get how to fix that :(
16:39:40 <jle`> folex: you are using (**) on something of type Rational
16:39:51 <jle`> :t (**)
16:39:52 <lambdabot> Floating a => a -> a -> a
16:39:57 <jle`> but Rational doesn't hav ea FLoating instance
16:40:21 * hackagebot yi-snippet 0.1.0.0 - Snippet support for Yi  http://hackage.haskell.org/package/yi-snippet-0.1.0.0 (MateuszKowalczyk)
16:40:59 <jle`> folex: it's inferred that k is a Rational
16:41:04 <jle`> because you use the function fromRational
16:41:06 <jle`> :t fromRational
16:41:07 <lambdabot> Fractional a => Rational -> a
16:41:45 <folex> yeah...
16:42:01 <folex> I should've been using realToFrac
16:42:12 <folex> just was stuck with to* and from* functions
16:42:19 <folex> jle`: thanks :)
16:42:29 <jle`> np!
16:43:04 <Kaidelong> network depends on GNU autotools :(((
16:44:11 <Kaidelong> would it be incredibly hard to eliminate the dependency? I could try working on it
16:47:58 <Polarina> I have a list of CStrings that I need to map to a corresponding Int value. What would be a good way to do that? The CString -> Int map is constant.
16:50:37 <yukko> you could keep a list [(CString, Int)] and use lookup
16:51:03 * Polarina was hoping for something efficient.
16:51:22 <Hijiri> a Map CString Int?
16:51:57 <Hijiri> actually now I have a question
16:52:07 <athan> Does anyone know of a `hi` template that works with nix?
16:52:19 <Hijiri> I have a function with a similar case, except it matches ints to constructors of a datatype
16:52:44 <Hijiri> If I'm just matching on each possible input, is that O(n) because it goes through each case?
16:53:18 <Hijiri> There's like 20 or so input-output pairs, would it be more efficient to use a Map, or would the overhead not be worth it?
16:53:41 <CodeWeaverX> On something that small, probably not worth it even if it *is* O(n)
16:53:42 <Hijiri> and actually I don't know what all the outputs are yet, so I'd have to come up with dummy ones to profile it
16:53:54 <yukko> Hijiri Data.Map has O(log n) lookup
16:54:31 <Hijiri> yeah, but there's more overhead when looking things up
16:54:34 <CodeWeaverX> On 20 elements, the constant factors will likely be much larger for Data.Map than a straight lookup.  Especially on a static set of cases.
16:55:02 <Hijiri> thanks codeweaver
16:55:58 <CodeWeaverX> (That being said, if you *really* wanna know, try both and profile)
16:56:41 <Fuuzetsu> nothing like micro-optimising for 20 element lookup
16:57:09 <CodeWeaverX> If the case is based on constructor patterns or values/enums known to be in a sequence, the compiler probably can turn it into a lookup table anyway.
16:57:28 <CodeWeaverX> Good to test rather than guess.
16:58:17 <Hijiri> maybe I'll test it when I know all the outputs
16:58:29 <Hijiri> probably there are bigger inefficencies to worry about in my code
16:58:42 <mrenaud_> I have a question regarding liftM. Since all monads are functors, is liftM necessary since it is the same as fmap?
16:59:46 <Hijiri> functor isn't a superclass of monad yet (maybe in ghc 7.8?), so you need liftM if you're working with only a Monad constraint
16:59:52 <n4x> 7.10
17:00:05 <Hijiri> thanks
17:00:29 <Hijiri> if Functor isn't a superclass of Monad, the compiler doesn't know you can use fmap on all Monads
17:00:49 <Hijiri> but if you're working with a specific Monad, then you can probably just use fmap since almost all of them implement the Functor instance too
17:01:39 <mrenaud_> Gotcha. The compiler currently complains if you make a type an instance of monad and not applicative. Will it soon be doing the same thing with functor?
17:02:02 <k00mi> Polarina: how many CStrings do you have?
17:02:17 <Polarina> k00mi, 678 CStrings.
17:02:19 <hexagoxel_> mrenaud: it already is functor f => applicative f
17:03:03 <mrenaud_> But it is currently not the case that applicative m => monad m?
17:03:22 <hexagoxel_> correct
17:04:01 <mrenaud_> Was that intentional or an oversight?
17:04:28 <joelteon> Monad was invented first.
17:04:39 <joelteon> Applicative being a superclass would be super weird at that point.
17:05:07 <mrenaud_> Just found this: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
17:05:18 <k00mi> Polarina: a strict hashmap would be pretty efficient
17:06:12 <Kaidelong> looks like removing autoconf dep. from network won't be that easy
17:06:35 <mrenaud_> So it appears that there is a plan to "fix" it at least
17:06:57 <Polarina> k00mi, all right. I'll look into that.
17:11:20 <mrenaud_> Alright, I have another completely unrelated question
17:12:46 <hexagoxel_> better unrelated questions than unrelated answers
17:12:56 <CodeWeaverX> Seven!
17:13:54 <mrenaud_> Haha, this may be a silly question since I'm pretty new to haskell :P
17:14:15 <Arahael_Twin> CodeWeaverX: Five thousand and fourty.
17:15:22 <mrenaud_> Alright, if I have the monad State SomeStateType (Just Int), and I chain these computations together, will they short circuit if the value returned is Nothing like it would if you were in the Maybe monad?
17:16:17 <BMeph> mrenaud_: BUZZ! (Just Int) is a value, not a type. :)
17:16:30 <hexagoxel_> nope, but can be done with monad transformers
17:16:38 <mrenaud_> Maybe Int*
17:16:54 <BMeph> mrenaud_: Better. ;)
17:17:01 <Arahael_Twin> mrenaud_: I'm still learning haskell and the monads, but I think that would depend on the implementation of bind.
17:17:25 <Arahael_Twin> mrenaud_: (For that type)
17:17:38 <mrenaud_> So if doing it with transformers, would I want Maybe or State to be the inner Monad?
17:18:17 <Hijiri> if you want it to short-circuit, Maybe should be inner, I think
17:19:21 <Arahael_Twin> CodeWeaverX: Did my answer to your 7! question help?
17:19:37 * Arahael_Twin is being super-helpful today.
17:19:51 <hexagoxel_> mrenaud:  uhm.. the difference is rather subtle
17:20:20 <k00mi> mrenaud_: take a look at the definition of StateT/MaybeT and it should become clear which order does what
17:20:42 <Hijiri> @src runMaybeT
17:20:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:20:49 <mrenaud_> So newtype MaybeWithState a = StateT World Maybe a?
17:21:46 <mrenaud_> in which case runStateT :: World -> Maybe (a, World)
17:21:56 <k00mi> @unmtl StateT World Maybe a
17:21:56 <lambdabot> World -> Maybe (a, World)
17:22:15 <yukko> runMaybeT is just defined as data MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}
17:22:20 <CodeWeaverX> Arahael_Twin:  It did indeed!
17:23:05 <mrenaud_> Does that mean that as soon as something returned Nothing I would no longer be able to access the state at the end?
17:23:09 <Arahael_Twin> CodeWeaverX: Awesomeness!
17:23:52 <k00mi> mrenaud_: correct, the modified state is not returned
17:24:07 <mrenaud_> Hmm, that's not going to work then :/
17:24:22 <Hijiri> with MaybeT (State s) you would be able to see the state, with StateT s Maybe you might not have the state
17:25:13 <Polyatomic> massive channel man ...
17:25:14 <Hijiri> runStateT is s -> m (a,s), which means both the end value and the state are affected by the inner monad
17:25:40 <mrenaud_> Thanks! I think I need to rethink how I'm designing this then :P
17:25:49 <Hijiri> runMaybeT is m (Maybe a), which means even when you short-circuit it will just be the inner end value that is Nothing
17:26:25 <mrenaud_> I just started learning Haskell so it's not immediately obvious how to do some of the stuff I want to do :P
17:26:51 <Hijiri> I don't think I understood the difference between StateT s Maybe and MaybeT (State s) until I answered you either
17:27:50 <benzrf> Hijiri: teaching is the best way to learn!
17:28:05 <benzrf> i never understand things as well as i do after explaining them to someobdy else
17:28:06 <mrenaud_> Haha, so true
17:28:45 <mrenaud_> How long have you guys been using haskell for?
17:28:55 <Hijiri> since the beginning of this summer
17:29:02 <benzrf> since the beginning of 2013 at least
17:29:06 <benzrf> fsvo "using"
17:29:22 <Hijiri> using haskell to learn haskell
17:29:56 <mrenaud_> That was going to be my next question, how *much* do you use it :P
17:29:58 <Arahael_Twin> mrenaud_: I've the same issue - best way for me to learn has been bitemyapp's links, and picking a random haskell library/framework to use.
17:30:09 <benzrf> mrenaud_: welllllllllllllllllllllll i spend a crapload of time in irc
17:30:18 <Hijiri> I don't feel like I've done anything special with haskell yet
17:30:22 <benzrf> but i dont think ive written an actual program in /any/ langauge in months
17:30:22 <Arahael_Twin> mrenaud_: Mind you, picking a library/framework has been phenomally annoying, as it was using techinques I didn't understand.
17:30:25 <Hijiri> I've made a chatbot for  a game I play
17:30:40 <Hijiri> and there's an unfinished web thing
17:30:51 <Hijiri> and there's a mahjong library that's on infinite hiatus
17:31:25 <mrenaud_> benzrf: I just started coming here recently, it's been quite beneficial so far :)
17:31:34 <benzrf> heck yes
17:32:30 <mrenaud_> Arahael_Twin: That's something I thought would happen if I used some library. Just being able to use a haskell library is much different then understanding the concepts used to build it
17:33:01 <mrenaud_> I've only been at this for a couple weeks, and even then working full time only leaves an hour here and there to tinker
17:33:34 * CodeWeaverX is new here too.  More or less.
17:33:35 <mrenaud_> Hijiri: As a learning project I thought I would write a firewall/packet filter type thingy
17:33:49 <dfeuer> I have very little Haskell experience, so for my learning project I've been hacking on GHC's libraries.
17:34:05 <dfeuer> Mostly list processing stuff.
17:34:20 <mrenaud_> Even with the little that I know about the language, it already frustrates me that other languages don't have the elegant abstractions
17:34:27 <dfeuer> And character handling.
17:34:39 <dfeuer> Which still needs a lot of work.
17:34:40 <mrenaud_> dfeuer: That's a good start, do you have other programming experience?
17:35:00 <dfeuer> mrenaud, not much!
17:43:13 <xendo> can you do any GUI/graphics programming with Haskell? Well, I'm sure you caaaan, but how is it?
17:43:16 <hexagoxel_> mrenaud: btw you can implement "Monad m => MaybeT (StateT s m) a -> StateT s (MaybeT m) a" but not the reverse (in a sensible way).
17:43:43 <Fuuzetsu> xendo: sure, why not
17:43:48 <Fuuzetsu> what kind of thing are you after
17:44:04 <xendo> i was just curious. i literally just starting learning haskell today
17:44:09 <xendo> not sure what's possible with it
17:44:22 <Fuuzetsu> it's a general purpose programming language
17:44:30 <Fuuzetsu> you can do whatever that other language can
17:44:38 <trap_exit> no
17:44:45 <trap_exit> it's impossible to do with haskell
17:44:46 <Fuuzetsu> modulo pedancy
17:44:46 <benzrf> trap_exit: shh
17:44:48 <benzrf> no tears
17:44:50 <benzrf> only dreams now
17:44:53 <trap_exit> there's no such thing as OpenGL bindings, gtk bindings,
17:45:00 <trap_exit> there's also no JavaScript/DOM bindings via ghcjs/haste
17:45:04 <benzrf> trap_exit: shhhhhh
17:45:06 <benzrf> trap_exit: shhhhhhhhhhhhhhh
17:45:24 <trap_exit> haskell is a useless language that can only run in the terminal and can't do anything involves colors or graphics
17:45:26 <vanila> :/
17:45:51 <benzrf> trap_exit: http://rustledjimmies.com/
17:46:22 <Arahael_Twin> xendo: I suggest Erlang. Decent multithreaded performance, and can interact with the world using input/output streams.
17:46:43 <Fuuzetsu> what is even going on in here
17:46:52 <benzrf> Fuuzetsu: i am trying to unrustle trap_exit's jimmies
17:46:54 <yukko> xendo I have written a program that uses GTK+ in Haskell, and now I am writing some GTK code in C
17:47:04 <Fuuzetsu> you'll scare him off for no reason
17:47:05 <yukko> in Haskell it is about a million times easier than C
17:47:48 <Arahael_Twin> xendo: To be serious, there's an "imperative" mini-language in Haskell that lets you do anything you normally would do in an imperative language.
17:48:05 <xendo> ah okay
17:48:20 <benzrf> its not imprative
17:48:30 <trap_exit> benzrf: never have I been so amused by a flying lawnmower, a picture of an ape, some backgroudn clouds, and transcendental music
17:48:32 <benzrf> u probly mean 'impure'
17:48:34 <xendo> When I say I just started, I mean I have only read Chapter 1 of RWH
17:48:35 <Fuuzetsu> xendo: basically, don't worry, you can do your regular stuff
17:48:49 <Fuuzetsu> you can also do cool stuff on top ;)
17:48:52 <trap_exit> benzrf: is this one of those sites best viewed in an altered state of mind?
17:48:55 <xendo> I'm also a novice programmer in general
17:49:25 <trap_exit> xendo: imho, it's a bad idea to start with GUI when learning haskell
17:49:34 <trap_exit> it's best to learn Haskell, then after things like monads are trivial, then do GUI stuff
17:49:38 <Fuuzetsu> it's bad idea to start with GUI
17:49:47 <trap_exit> otherwise, you have this imepratie mindset ... and it's not going to interact well with how Haskell does GUI
17:49:48 <Arahael_Twin> GUI == complicated.
17:49:51 <xendo> oh yea, that's just my long-term, i hope i get that good goal
17:49:58 <trap_exit> and as a result, you think haskell sucks, but it's mainly because you're not used to monads
17:50:07 <Fuuzetsu> trap_exit: why are you even mentioning monads here at all
17:50:24 <Arahael_Twin> Monads are _definitely_ what held me back.  I say ban the word.
17:50:25 <trap_exit> Fuuzetsu: because GUI is stateful and almost certainly IO ()
17:50:26 <Fuuzetsu> I don't understand why anyone coming in here has to have monads shoved in their faces
17:50:47 <trap_exit> because they asked about GUI
17:50:52 <Fuuzetsu> trap_exit: so? You can use IO without understanding monads
17:50:54 <xendo> lol well i read the word monads somewhere, so i know that those exist
17:50:57 <xendo> ...whatever they are
17:51:02 <trap_exit> if the question was "how do I learn haskell", the response would then be "read LYAH"
17:51:15 <Hijiri> I think the CIS194 lecture note/tutorial did a good thing by leaving hello world to week 8
17:51:21 <Fuuzetsu> heh
17:51:38 <trap_exit> instead, the question is "how do I do ionteractive graphics" and the repsonse is "this is a bad startin gpoint, because you'l have to deal with IO (), which means monads, which means not ideal way to start"
17:51:52 <trap_exit> Fuuzetsu: do you have an inherent hatred of monads?
17:52:04 <Fuuzetsu> no, I have inherent hatred of people shoving the word monad everywhere
17:52:16 <Fuuzetsu> do you talk about monads when someone says ‘list’?
17:52:17 <trap_exit> monad monad monad
17:52:30 <Arahael_Twin> trap_exit: I find LYAH difficult to read.
17:52:31 <trap_exit> no, you can understand lists without understandin monads
17:52:44 <Fuuzetsu> a newbie will come in here, learn that they have to know about that difficult theory mumbo jumbo and get discouraged
17:53:11 <Fuuzetsu> trap_exit: you can use IO just fine without understanding monads, you just need to know how to use IO, that's it
17:53:14 <n4x> Fuuzetsu: a functor would do it!
17:53:21 <Fuuzetsu> you need to know how to use one specific instance
17:53:24 <trap_exit> well, either (1) we tell them -- i fyou start with GUI, you're going to run into this mess -- so don't start with GUI or (2) they do start with GUI, run into the mess, and likely quit
17:53:25 <xendo> Arahael_Twin: I just looked at it, and I don't like it as much as RWH from the little I saw
17:53:53 <Fuuzetsu> xendo: RWH is fine too, just a bit dated so make sure to ask when something doesn't work
17:53:55 <trap_exit> Fuuzetsu: why are are arguing? I think we both have better things to do :-)
17:54:00 <Arahael_Twin> xendo: I recommend the CIS194 lecture series, I think if you google 'bitemyapp',  you'll come to it very well.
17:54:30 <Arahael_Twin> xendo: I wish I used his links instead of RWH, though...  Because now it's just... boring revision, yet RWH has made me skip ahead too much.
17:54:38 <xendo> Yea I actually found his info, which is how I ended up installing a virtual linux machine and getting cabal, haskell, and all that started today
17:54:46 <Fuuzetsu> trap_exit: I just don't want people to get the idea that they need to understand this theoretical thing before they can even print to the screen
17:55:08 <Arahael_Twin> Fuuzetsu: Indeed. It was easier to write "Hello world" in Java. ;)
17:55:25 <xendo> I'm okay with theoretical things
17:55:27 <Fuuzetsu> Arahael_Twin: main = print "Hello world" -- look ma, no monads!
17:55:28 <mrenaud_> +1 to Fuuzetsu's comment. There's a huge difference between understanding monads and *using* monads
17:55:29 <yukko> I don't really think there's anything wrong with learning how to use IO in Haskell as a beginner
17:55:56 <n4x> I find them to be a lot like monoids, etc
17:56:00 <Arahael_Twin> Fuuzetsu: Indeed, unless you're told to learn about monads.
17:56:12 <yukko> and I think that telling people not to use IO as a beginner just contributes to the idea that Haskell is "academic" and "mathematical" and not suited for real world tasks, which isn't true at all
17:56:17 <Fuuzetsu> Arahael_Twin: well, that's what I'm trying to convince trap_exit to stop telling people
17:56:41 <xendo> yukko: I got my degree in math, and it was all those people saying that it's "mathematical" that made me interested haha
17:56:42 <n4x> after solving some problems, you start noticing patterns, and wonder "isn't there something more abstract?" :P
17:56:57 <hexagoxel__> turn around the argument!
17:57:13 <Arahael_Twin> xendo: The branch of mathematics is very different.
17:57:22 <trap_exit> GUI is not just putStrLn
17:57:29 <trap_exit> try to doanythign interesting in a GUI
17:57:32 <trap_exit> and you'll likely be maintaing state
17:57:36 <trap_exit> so now you'll be dealing with the StateMOnad
17:57:43 <xendo> I'm starting to see that, but that's just what made start taking a look at haskell
17:57:50 <yukko> trap_exit actually, at least with GTK, it takes care of all your state for you
17:58:08 <Arahael_Twin> trap_exit: So, let us learn about state when we need state, yes?
17:58:09 <pyon> n4x: lol, not all programmers think in algebraic terms. Anyone can detect patterns, few can say "ah, it's this algebraic structure!"
17:58:11 <yukko> you don't actually need to use a state monad or IORefs anywhere unless you want to
17:58:30 <mrenaud_> trap_exit: Dealing with the State monad isn't incredibly difficult, you just have to know you say state <- get when you need to get stuff
17:58:52 <yukko> mrenaud_ that's a good point!
17:58:53 <mrenaud_> How the state monad works is non-trivial, but you don't have to understand that to use it
17:59:18 <vanila> how state monad works is very simple: It is a pair with the current state as well as the return value
17:59:32 <n4x> pyon: the idea isn't "thinking in algebraic terms" but realizing small 'abstract' patterns
17:59:49 <yukko> I think a lot of Haskell users think that you need to understand something in its entirety before you can use it, and I don't think that's necessary
17:59:54 <Fuuzetsu> trap_exit: it's easier to explain and encourage further reading when someone comes asking why specific thing doesn't work rather than making them learn something general before they even get to try
17:59:57 <mrenaud_> vanila: Conceptually yes it is simple, the actual implementation is not so straight forward
18:00:30 * hackagebot haskell-neo4j-client 0.3.0.8 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.8 (asilvestre)
18:00:39 <n4x> yukko: I think it isn't that way
18:00:47 <Arahael_Twin> Infact, I might argue that it's pointless teaching about monads at all, until we've learnt how to use haskell's type system.
18:00:49 <n4x> most think you need to "be concrete" first
18:01:07 <mrenaud_> And gaining a full understanding of how that fits into monads is also not simple, either that or every single person who has ever learned haskell is dumb :P
18:01:37 <pyon> n4x: In order to go from "patterns we can copy-paste and tweak here and there" to "patterns we can abstract over in the language itself", some algebraic reasoning is required.
18:01:37 <Arahael_Twin> It took me a long time (as a very experienced programmer, none-the-less!), to finally understand monads. (And even then, I'm not certain)
18:02:31 <n4x> pyon: I didn't realize then, I guess my high-school level "algebraic reasoning" was enough
18:02:37 <xendo> The type system....
18:02:46 <xendo> I was going through RWH, and I think I did notice some out of date things
18:02:47 <mrenaud_> Arahael_Twin: Same here, I still am not confident in my understanding of them :P
18:03:02 <xendo> the type that it told me I should get isn't what I got when I tried it in ghci
18:03:30 <Arahael_Twin> xendo: RWH is outdated, but still correct for the most part. (So I'm told)
18:03:41 <geekosaur> one change is ghci has extended defaulting these days
18:03:59 <geekosaur> or if you have a recent enough one, no monomorphism restriction iirc
18:04:11 <n4x> the "theory" is ✔
18:04:28 <pyon> Will the next GHC have no monomorphism restriction by default?
18:04:33 <pyon> Hooray!
18:04:44 <n4x> hehe, didn't remember I had "✔" there! :P
18:04:47 <geekosaur> afaik only ghci
18:04:51 <pyon> Oh.
18:04:51 <n4x> pyon: no, just ghci has it disabled by default
18:04:56 <trap_exit> dude
18:05:02 <trap_exit> I rinally understand the joke bemind XMonad
18:05:11 <trap_exit> XMonad is a Monad for manipulating X
18:05:17 * Fuuzetsu claps
18:05:31 <yesthisisuser> that's a joke?
18:05:34 * mrenaud_ slowly claps
18:06:28 <geekosaur> newtype X a = X (ReaderT XConf (StateT XState IO) a) deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf, Typeable)
18:06:38 <geekosaur> the X Monad
18:06:48 <trap_exit> this makes so much sense now
18:06:57 <trap_exit> why don't they just use RWS inst4ad of ReaderT + StateT ?
18:07:00 <trap_exit> I just use RWS for everything
18:07:49 <Arahael_Twin> Real World State?
18:08:05 <benmachine> reader writer state
18:08:17 <benmachine> I guess they don't need W
18:08:38 <geekosaur> RWS and friends are from back when it was believed that monad transformers weren't viable
18:08:40 <CodeWeaverX> Looks pretty easy to do simple 2d graphics, if you want to, using gloss and openGL.  Granted one would have to at least know how to *use* monads, but since it basically just looks like an imperative sublanguage, one definitely doesn’t need deep theoretical knowledge to use it.
18:09:02 <CodeWeaverX> Full GUI stuff is a harder in any lanuguage.
18:09:09 <geekosaur> although there are still arguments over that, primarily over the composability of random monads IIRC
18:09:27 <vanila> what really *are* monads?
18:09:32 <trap_exit> damn it, everyone appears to disagree with me, but I will state my case one mor etime before letting the others win over:
18:09:45 <trap_exit> I tried learning haskell via GUI programminw without understanding monads -- I kept on getting confused by type signatures
18:09:48 <lpaste> Vermeille pasted “bad parser” at http://lpaste.net/113217
18:09:54 <yukko> vanila http://static.tumblr.com/10627d114c6cf5e7ee2e027959b76000/4tfa6et/cMsnaskrb/tumblr_static_45ofi0il1l4wwk4k4s048wwk4.gif
18:09:55 <mrenaud_> Can someone explain what the difference between RWS is and a monad composed of the three separately? Can you access all 3 without having to lift functions into an inner monad?
18:09:58 <trap_exit> one day, after learning haskell, I tried doing GUI in haskell
18:10:01 <trap_exit> everything made sense
18:10:03 <trap_exit> end of story
18:10:12 <Arahael_Twin> trap_exit: Exactly.
18:10:18 <vermeille> Guys, this code is just ugly, any hint?
18:10:19 <geekosaur> mrenaud, if you derive through you can access them directly
18:10:31 <Arahael_Twin> trap_exit: Learning monads, GUI, and the like, before you've learnt Haskell, is just asking for trouble.
18:10:43 <Arahael_Twin> trap_exit: Learn haskell first. Then everything else.
18:11:00 <trap_exit> agreedd; learn Haskell first; do GUI later
18:11:02 <n4x> vanila: some data with some operations defined, with those operations following some "axioms" (?), or something like that!
18:11:07 <trap_exit> do
18:11:12 <trap_exit> haha, as in the syntactical do
18:11:15 <trap_exit> sorry, bad joke day
18:11:21 <n4x> learn haskell first, play with it later
18:12:12 <geekosaur> that said, there are subtle differences in the way a transformer stack and a monolithic RWS behave; sometimes you want the monolithic behavior, sometimes the stack behavior
18:12:21 <mrenaud_> geekosaur: Could you elaborate, I'm not sure what you mean by "derive through"
18:12:54 <geekosaur> (specifically, what happens when "fail" is called)
18:13:10 <vanila> yeah :)
18:13:39 <geekosaur> mrenaud, did you see my paste above of the definiion of xmonad's X monad? the "deriving" clause derives MonadReader and MonadState, so both of those are directly available without lifting
18:15:25 <mrenaud_> geekosaur: Ahh, I see now. That's interesting, I haven't seen that before
18:16:51 <mrenaud_> geekosaur: Quick question, does deriving MonadIO allow you to perform IO actions without having to lift them as you would if IO was an inner monad?
18:17:21 <geekosaur> no, that one is more complex since IO is always at the bottom of a transformer stack
18:17:25 <benmachine> even with MonadIO you still need liftIO
18:17:32 <nshepperd> the accursed "fail"
18:17:39 <geekosaur> so MonadIO gives you a liftIO that lifts as many times as necessary to reach the IO
18:19:23 <mrenaud_> Okay, so if I had a monad stack with a bunch of inner monads, I could call liftIO and it would keep lifting it until it was in the IO monad?
18:19:37 <geekosaur> I am not sure if the same generalized deriving mechanism could be used to derive a MonadIO variant that worked like e.g. MonadReader.
18:20:08 <geekosaur> as long as you derived MonadIO, yes
18:20:47 <mrenaud_> Okay, super silly question here :P When you say MonadReader, is that the same as the Reader monad? Or is MonadReader something specific?
18:21:38 <nshepperd> well, you could certainly define your own putStrLn :: (MonadIO) => String -> m () and so forth
18:21:53 <geekosaur> it's slightly different. the Reader "behaviors" are attached to MonadReader; the ReaderT Monad defines a MonadReader instance.
18:22:10 <nshepperd> (using liftIO inside)
18:22:30 <geekosaur> when Reader was its own monad, it also defined a MonadReader instance, so the two used a common mechanism. (these days Reader is not a standalone Monad, but is ReaderT Identity)
18:23:15 <geekosaur> the equivalent for IO would be that all of IO's behaviors would be moved to a new monad, with IO as the "base" instance of that monad and others able to derive it
18:23:33 <geekosaur> but that's not how the current MonadIO works. mostly because the IO Monad is weird
18:24:20 <geekosaur> as I said, I'm not sure it would even work to redo IO to have the same kind of setup as ReaderT vs. MonadReader where the former is a scaffold and the latter carries the behaviors
18:24:34 <vermeille> any idea how to improve all those `read` and improve the ugly prepend l13-15? http://lpaste.net/113217
18:24:56 <vermeille> (Without lenses)
18:25:31 <mrenaud_> geekosaur: Thanks! I *think* I understand :P
18:25:32 <geekosaur> (the big problem being, what happens if someone decides to define their own instance of the behaviors?)
18:26:10 * Arahael_Twin hasn't learnt Lenses yet.
18:26:41 <adarc> how do haskellers figure out how to use libraries like this: https://github.com/ekmett/time-series
18:26:43 <CodeWeaverX> Coincidentally that’s my next ‘abstraction’ to get a basic grasp on.
18:27:19 <Fuuzetsu> adarc: start by looking at docs on Hackage
18:27:21 <benmachine> adarc: http://hackage.haskell.org/package/time-series
18:27:22 <geekosaur> the point of IO being a Monad is to try to hide all the weirdness in IO; you lose that hiding if you make it possible to provide your own instances
18:27:25 <adarc> does it need examples, more documentation, references.. or do advanced haskell people gain instant wisdom/insight from the types
18:27:31 <adarc> ya that's a different package though
18:27:35 <Fuuzetsu> yeah, just realised
18:27:39 <nshepperd> um, well there are a lot of IO "behaviours"
18:27:51 <geekosaur> lots of people don't understand ekmett's code :p
18:27:54 <Arahael_Twin> Including FFI's.
18:27:54 <adarc> ekmett has some beast code and alot of it doesn't have documentation..
18:27:54 <Fuuzetsu> adarc: then maybe no one is using that package
18:28:01 <adarc> ah ok so i'm not the only one? ;f
18:28:04 <nshepperd> it would be silly to put every IO function into one typeclass
18:28:23 <geekosaur> I think most of us don't understand it :)
18:28:28 <MP2E> seems you are not, I don't get it either :P
18:28:34 <adarc> im just wondering if it's my nubness or if advanced haskell people can absorb that kind of code, for example, lookng at the types alone
18:28:56 <Eduard_Munteanu> There are MonadBaseControl IO / MonadBase IO for specific patterns.
18:28:58 <adarc> ie, https://github.com/ekmett/time-series/blob/master/src/Data/Time/Series.hs
18:29:00 <benmachine> ekmett is actually pretty good on documentation on some of his libraries, it's just that there is lots more stuff that's more experimental and less cared for
18:29:33 <benmachine> adarc: that's legit a scary module, superficially at least
18:29:39 <adarc> lots of the stuff he codes is deeply rooted in math/peer reviewed studies etc no?
18:29:39 <mrenaud_> Okay, one last question (for now lol). Going back to deriving from monads, if you define a new type (like X above), does it matter what order you use the monad transformers if you just derive from everything anyways?
18:29:40 <BMeph> adarc: After a while, you don't even see the types. You just see "blonde," "brunette"...what-a-minute.... ;)
18:29:46 <adarc> hah ya benmachine
18:29:58 <Fuuzetsu> it just looks scary
18:30:10 <Fuuzetsu> that By though
18:30:21 <adarc> right.. it looks scary to me but i need to get to the place where it's not scary and makes 100% sense
18:30:21 <Eduard_Munteanu> mrenaud_, it matters when you write the final unwrapping, e.g. foo = runFooT . runBarT $ ...
18:30:31 <nshepperd> geekosaur: there's http://hackage.haskell.org/package/lifted-base to handle most of the weirdness
18:30:35 <adarc> like oh of course, Sliding   :: Int -> (forall s'. F s' (P (T u)) a -> F s' (P (T Always)) a) -> F s (P (T u)) a -> F s (P (T u)) a
18:31:48 <benmachine> adarc: how did you find this module, what do you want it for?
18:32:42 <mrenaud_> Eduard_Munteanu: so when you are in the monad everything is available without lifting, but to actually invoke it it matters?
18:32:56 <mrenaud_> Or to *run* it I mean
18:33:00 <adarc> benmachine: i started looking into 'time series' libraries for haskell
18:33:18 <adarc> i'd like to improve my understanding of those libs
18:33:20 <adarc> so i can make use of them
18:33:34 <MP2E> omg that type signature
18:33:36 <Eduard_Munteanu> mrenaud_, yes, you'll eventually need to instantiate the action to a concrete type and unwrap the transformers
18:33:37 * MP2E explodes *
18:33:41 <adarc> i think i need to find some 'mathy' time series papers.. to give me the core/fundamental understanding
18:33:51 <adarc> that's type sig of the week
18:34:09 <Eduard_Munteanu> mrenaud_, e.g. in main :: IO ()
18:34:51 <benmachine> adarc: I'd guess if that library you found is not on Hackage, it might not be finished yet, you could try finding edwardk in here some other time and asking him about it
18:35:11 <benmachine> or you could look at a different library :P
18:35:21 <adarc> ya the one on hackage seems 'simpler'
18:35:21 <adarc> but
18:35:31 <adarc> less apparently comprehensive
18:35:50 <nshepperd> mrenaud_: with things like WriterT and EitherT together the order matters too
18:35:50 <mrenaud_> Eduard_Munteanu: Okay, got it, thanks!
18:36:06 <adarc> i hate the fact that my brain wants examples
18:36:08 <adarc> it bothers me
18:36:14 * mrenaud_ thinks he understands but likely doesn't...
18:36:28 <nshepperd> because one order results in Either a (b, w) and the other results in (Either a b, w)
18:36:30 <adarc> that's one reason i love haskell.. you can derive alot from the code itself
18:36:32 <Eduard_Munteanu> MP2E, another funny one is   class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where
18:36:37 <benmachine> adarc: examples are great, don't underestimate them
18:36:40 <adarc> i need to get better at figuring things out with 0 examples available
18:36:44 <Eduard_Munteanu> from   https://hackage.haskell.org/package/lens-3.8.5/docs/Control-Lens-Internal-Indexed.html    :)
18:37:14 <benmachine> adarc: nah, people need to get better at providing examples :P
18:37:22 <adarc> hah .. that too
18:37:38 <adarc> when i was just getting into computers i had linux, a c compiler.. and no internet
18:37:47 <adarc> i learned so much by not having the internet
18:38:00 <adarc> i should download that library and kill my internet
18:38:01 <adarc> ;f
18:38:04 <mrenaud_> Well, I g2g, thanks everyone who's answered my questions :)
18:43:02 <xendo> i feel like i'm already learning more comp sci/programming theory while studying haskell than i did while learning pythong
18:43:04 <xendo> python*
18:43:26 <yukko> that's cool :)
18:43:33 <yukko> #haskell what's the scariest type signature you know of
18:47:41 <WraithM> @type let f x = (x, x, x); p1 = (f, f, f); p2 = (p1, p1, p1) in (p2, p2, p2)
18:47:42 <lambdabot> (((t -> (t, t, t), t1 -> (t1, t1, t1), t2 -> (t2, t2, t2)), (t3 -> (t3, t3, t3), t4 -> (t4, t4, t4), t5 -> (t5, t5, t5)), (t6 -> (t6, t6, t6), t7 -> (t7, t7, t7), t8 -> (t8, t8, t8))), ((t9 -> (t9, t9, t9), t10 -> (t10, t10, t10), t11 -> (t11, t11, t11)), (t12 -> (t12, t12, t12), t13 -> (t13, t13, t13), t14 -> (t14, t14, t14)), (t15 -> (t15, t15,
18:47:42 <lambdabot> t15), t16 -> (t16, t16, t16), t17 -> (t17, t17, t17))), ((t18 -> (t18, t18, t18), t19 -> (t19, t19, t19), t20 -> (t20, t20, t20)), (t21 -> (t21, t21, t21), t22 -> (t22, t22, t22), t23 -> (t23, t23, t23)), (t24 -> (t24, t24, t24), t25 -> (t25, t25, t25), t26 -> (t26, t26, t26))))
18:47:47 <WraithM> Not that scary
18:47:49 <WraithM> Just funny
18:48:33 <WraithM> @type let f x = (x, x, x); p1 = (f, f, f); p2 = (p1, p1, p1); p3 = (p2, p2, p2) in (p3, p3, p3)
18:48:34 <lambdabot> ((((t -> (t, t, t), t1 -> (t1, t1, t1), t2 -> (t2, t2, t2)), (t3 -> (t3, t3, t3), t4 -> (t4, t4, t4), t5 -> (t5, t5, t5)), (t6 -> (t6, t6, t6), t7 -> (t7, t7, t7), t8 -> (t8, t8, t8))), ((t9 -> (t9, t9, t9), t10 -> (t10, t10, t10), t11 -> (t11, t11, t11)), (t12 -> (t12, t12, t12), t13 -> (t13, t13, t13), t14 -> (t14, t14, t14)), (t15 -> (t15, t15,
18:48:34 <lambdabot>  t15), t16 -> (t16, t16, t16), t17 -> (t17, t17, t17))), ((t18 -> (t18, t18, t18), t19 -> (t19, t19, t19), t20 -> (t20, t20, t20)), (t21 -> (t21, t21, t21), t22 -> (t22, t22, t22), t23 -> (t23, t23, t23)), (t24 -> (t24, t24, t24), t25 -> (t25, t25, t25), t26 -> (t26, t26, t26)))), (((t27 -> (t27, t27, t27), t28 -> (t28, t28, t28), t29 -> (t29,
18:48:34 <lambdabot> t29, t29)), (t30 -> (t30, t30, t30), t31 -> (t31, t31, t31), t32 -> (t32, t32, t32)), (t33 -> (t33, t33, t33), t34 -> (t34, t34, t34), t35 -> (t35, t35, t35))), ((t36 -> (t36, t36, t36), t37 -> (t37, t37, t37), t38 -> (t38, t38, t38)), (t39 -> (t39, t39, t39), t40 -> (t40, t40, t40), t41 -> (t41, t41, t41)), (t42 -> (t42, t42, t42), t43 -> (t43,
18:48:34 <lambdabot> t43, t43), t44 -> (t44, t44, t44))), ((t45 -> (t45, t45, t45), t46 -> (t46, t46, t46), t47 -> (t47, t47, t47)), (t48 -> (t48, t48, t48), t49 -> (t49, t49, t49), t50 -> (t50, t50, t50)), (t51 -> (t51, t51, t51), t52 -> (t52, t52, t52), t53 -> (t53, t53, t53)))), (((t54 -> (t54, t54, t54), t55 -> (t55, t55, t55), t56 -> (t56, t56, t56)), (t57 -> (
18:48:34 <lambdabot> t57, t57, t57), t58 -> (t58, t58, t58), t59 -> (t59, t59, t59)), (t60 -> (t60, t60, t60), t61 -> (t61, t61, t61), t62 -> (t62, t62, t62))), ((t63 -> (t63, t63, t63), t64 -> (t64, t64, t64), t65 -> (t65, t65, t65)), (t66 -> (t66, t66, t66), t67 -> (t67, t67, t67), t68 -> (t68, t68, t68)), (t69 -> (t69, t69, t69), t70 -> (t70, t70, t70), t71 -> (
18:48:36 <lambdabot> t71, t71, t71))), ((t72 -> (t72, t72, t72), t73 -> (t73, t73, t73), t74 -> (t74, t74, t74)), (t75 -> (t75, t75, t75), t76 -> (t76, t76, t76), t77 -> (t77, t77, t77)), (t78 -> (t78, t78, t78), t79 -> (t79, t79, t79), t80 -> (t80, t80, t80)))))
18:49:16 <yukko> WraithM hahaha wowwww
18:49:20 <WraithM> Exponential
18:49:44 <WraithM> Don't do it for another one
18:49:51 <WraithM> You might crash poor lambdabot
18:50:20 <WraithM> In all seriousness
18:53:38 <Arahael_Twin> WraithM: If lambdabot was turing-complete, that wouldn't happen, surely?
18:54:13 <WraithM> What do you mean?
18:55:37 <Arahael_Twin> WraithM: I was just trolling you... Isn't one of the assumptions with turing-completeness an infinite tape length?
18:56:03 <yukko> if that's the definition of turing complete then I don't think anything satisfies it
18:56:13 <Gurkenglas> Turing machines do!
18:56:22 <yukko> :p
18:56:57 <Gurkenglas> @type left f x = (x) in (x)
18:56:59 <lambdabot> parse error on input ‘=’
18:57:03 <Gurkenglas> @type let f x = (x) in (x)
18:57:04 <lambdabot> Expr
18:57:10 <Gurkenglas> Huh.
18:57:30 <Gurkenglas> Oh, right
18:57:35 <WraithM> Yeah, x isn't bound there.
18:57:43 <Gurkenglas> @type let f x = (f) in (f)
18:57:44 <lambdabot>     Occurs check: cannot construct the infinite type: t3 ~ t2 -> t3
18:57:45 <lambdabot>     Relevant bindings include
18:57:45 <lambdabot>       x :: t2 (bound at <interactive>:1:7)
18:57:49 <Gurkenglas> Aww
18:58:01 <WraithM> You don't need parens.
18:58:33 <Gurkenglas> Just wanted to do a quick test with the least needed thinking
19:20:25 <timpani> New to QuickCheck...when I use ==> I get "Couldn't match type `Gen Prop' with `Bool'". And yet I'm using ==> just as http://book.realworldhaskell.org/read/testing-and-quality-assurance.html does. I realize QuickCheck's version might have changed, but I can't find obvious fixes after web search. Any ideas?
19:22:01 <timpani> err...nevermind
19:40:21 <Fuuzetsu> so somewhere we have a Text.Show.Functions leaking into our program, and from there to the rest of the world… what's a good way to catch of where it comes in?
19:40:36 <Fuuzetsu> s/of //
19:41:24 <Arahael_Twin> Stupid question: Given a CSV value taken from: parseCSV :: FilePath -> String -> Either ParseError CSV
19:41:35 <Arahael_Twin> How do I actually get the rows and data items from it?
19:42:39 <haasn> Arahael_Twin: That depends on what ‘CSV’ is
19:43:15 <haasn> You see the function is either returning a ParseError or some value of type CSV. Presumably, one would interact with this value of type CSV somehow. Check the documentation for the module you are importing CSV from
19:44:06 <Arahael_Twin> haasn: It seems to be a 'parsec' based parser, and I seem to be able to print it.  An earlier type error suggested that it was a string, however the documentation says that it's actually: type CSV = [Record]
19:45:04 <pjdelport> http://hackage.haskell.org/package/csv ?
19:45:13 <Arahael> pjdelport: Yes.
19:45:24 <pjdelport> Arahael: In that case, it's just a type synonym for [[String]]
19:45:40 <pjdelport> So you can use normal list accessors.
19:46:00 <Arahael> Neat.
19:46:44 <haasn> You can also use :info CSV inside GHCi to figure some things out about a type
19:47:26 <Arahael> I should make more use of ghci.
19:48:39 <CodeWeaverX> Its great for rapid prototyping and rapid testing.
19:53:14 <Arahael> Woo! Success! Got my CSV outputted to colon-separated format. :)  (Small victories... Small victories...)
19:53:42 <dfeuer> Woohoo.
20:01:39 <Arahael> I want to use this Either value in an applicative way, but I don't understand applicative yet.
20:01:42 <Arahael> What's a good tutorial?
20:02:20 <jle`> Arahael: what do you mean "in an applicative way"?
20:02:35 <jle`> one way to look at Applicative is that it just lets you "squash" together values, horizontally.
20:02:49 <jle`> so if you have a (Just 4) and a (Just 6), you can turn them into (Just 10)
20:02:56 <jle`> by using liftA2 (+)
20:03:01 <jle`> > liftA2 (+) (Just 4) (Just 6)
20:03:02 <Arahael> jle`: Well, I have an Either Left Right, where Left is an error.  I want to be able to define a sequence of filters that operate on Right, returning Left only in error (as a short-circuit)
20:03:03 <lambdabot>  Just 10
20:03:18 <jle`> that doesn't sound like an Applicative problem necessarily...
20:03:22 <jle`> that just sounds like an Either problem
20:03:35 <jle`> try to write out the function using just Either, and then we'll look at how you can generalize it.
20:03:39 <jle`> Applicative isn't magical
20:03:53 <jle`> Applicative instances usually are already useful utility functions on that type
20:03:55 <Arahael> Hmm, so applicative isn't what I want, then, perhaps. I currently have only a single step defined. (Not a filter) at the moment.  But it uses case.
20:04:04 <Arahael> And I don't want to use case all the time.
20:04:09 <jle`> the only thing Applicative gives is a common name to say for a bunch of different types
20:04:46 <jle`> so Either's Applicative isntance can't really let you do anything that you can't already do with Either and manual case statements
20:05:01 <jle`> (besides, of course, using it with functions that are generic to all Applicatives)
20:05:20 <Arahael> Sounds like I should just write all my filters, and use pattern matching on Left/Right?
20:05:27 <jle`> write it out, and show it to us
20:05:32 <jle`> and we might be able to see which parts can be generalized
20:05:37 <Arahael> Ok.
20:05:40 <jle`> and simplified using Applicative methods
20:06:06 <jle`> er.  by that i mean, simplified using higher-order functions
20:06:15 <jle`> that happen to be associated with the Applicative instance of Either
20:06:23 <jle`> by coincidence :D
20:06:35 <pjdelport> Arahael: That sounds like Applicative.
20:06:53 <pjdelport> > (+) <$> Right 2 <*> Right 3
20:06:54 <lambdabot>  Right 5
20:07:04 <pjdelport> > (+) <$> Left "kaboom!" <*> Right 3
20:07:06 <lambdabot>  Left "kaboom!"
20:08:21 <Arahael> pjdelport: Excellent. What's a good tutorial?
20:08:44 <pjdelport> Arahael: I'm not sure offhand, but are you familiar with Functor?
20:09:21 <baakednotfried> haskell isnt that cool
20:09:26 <Arahael> pjdelport: I know of it. I actually implemented applicative last week while talking to someone, but having a hard time *applying* it, especially from my fairly poor memory.
20:09:28 <jle`> there's that functor, applicative, monad tutorial
20:09:36 <pjdelport> > negate <$> Right 5
20:09:36 <jle`> @google functor applicative monad in pictures
20:09:37 <lambdabot>  Right (-5)
20:09:38 <lambdabot> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
20:09:38 <lambdabot> Title: Functors, Applicatives, And Monads In Pictures - adit.io
20:09:42 <pjdelport> > negate <$> Left "fnord"
20:09:43 <lambdabot>  Left "fnord"
20:09:51 <pjdelport> Arahael: <$> is just fmap of course
20:10:30 <Arahael> pjdelport: It was fmap that I implemented last week (just in chat), trying to remember how to actually use it.
20:10:41 <baakednotfried> only smelly nerds right haskell
20:10:44 <pjdelport> Arahael: If you look at the previous, you can think of Applicative as effectively extending Functor from unary function application to functions of any arity.
20:10:50 <baakednotfried> @google haskell is worse than lisp, objectively
20:10:51 <lambdabot> http://www.winestockwebdesign.com/Essays/Lisp_Curse.html
20:10:51 <lambdabot> Title: The Lisp Curse
20:11:41 <baakednotfried> @google literally everyone who has ever written any haskell code smells really really bad all the time
20:11:46 <lambdabot> http://c2.com/cgi/wiki?SwitchStatementsSmell
20:11:46 <lambdabot> Title: Switch Statements Smell
20:11:47 <Arahael> That first link, '... in pictures.html' is pretty good.
20:12:07 <jle`> i think one one of the ways to look at the Functor/Applicative instance for Either is that it represents a value that cannot fail, and the instances are meaningful lifters to such values
20:12:26 <jle`> also, I like adding mental parentheses
20:12:30 <ebolajackson> n i g g e r   lovers  will learn a lesson
20:12:41 <jle`> (Either String) Int is an Int that might be failure
20:12:57 <jle`> (Either String) Bool is a bool that might be a failure, like Maybe Bool
20:13:15 <jle`> and so, if I had an (Either String) Int ..... one thing that makes it different from just a normal Int is that I can no longer use Int functiosn on it
20:13:20 <Arahael> jle`: That parens there is confusing me, although I can see how that works.
20:13:31 <jle`> if I had an (Int -> Bool)
20:13:41 <jle`> and I had an Either String Int
20:13:47 <jle`> then...well...normally, i'd be stuck.
20:13:54 <jle`> but i want to be able to treat an Either String Int "as if it were an Int"
20:14:05 <Arahael> But you use fmap: yourfunc <$> yourEither
20:14:09 <Arahael> (Right?)
20:14:10 <jle`> yeah, so that's what fmap does
20:14:20 <jle`> fmap turns an (Int -> Bool) into an (Either String) Int -> (Either String) Bool
20:14:28 <jle`> it lets you apply any Int function to your Either String Int
20:14:38 <jle`> so it "abstracts away" the failability part
20:14:46 <jle`> so you can treat an Either String Int "as if it were" an Int
20:14:50 <ebolajackson> join c h i m p o u t   forum
20:15:10 <ebolajackson> h t t p : / / w w w . c h i m p o u t . c o m / f o r u m
20:15:16 <pjdelport> @where ops
20:15:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:15:27 <jle`> so, now you can treat use (Int -> Bool) on your Either String Ints ....
20:15:36 <ebolajackson> are you sick of n i g g e r s?
20:15:40 <jle`> but what about functions with "two arguments", like (Int -> Int -> Bool) ...?
20:15:43 <Arahael> This sounds like exactly what I want.
20:15:44 <ebolajackson> tired of their m o n ke y s h i ne s?
20:15:48 <ebolajackson> we are too!
20:15:53 <tabemann_> mods
20:15:54 <ebolajackson> Join c h i m p o ut forum!
20:16:02 <Fuuzetsu> mods are asleep, cake time
20:16:06 <Arahael> Because if this Either is a Left value, then _none_ of my functions will work, as it means that my CSV couldn't be loaded.
20:16:06 <ebolajackson> c h i m p o u t . c o m / f o r um
20:16:11 --- mode: ChanServ set +o dolio
20:16:11 <Arahael> Just use /ignore, everyone. :)
20:16:13 <jle`> that's what the Applicative instance allows you to do
20:16:17 --- mode: dolio set +b *!*@187.253.149.74
20:16:17 <Fuuzetsu> fug, no cake
20:16:21 <guestaccount11> Can anyone point me in the direction of a video/audio version of LYAH? Or a video/audio collection as good as LYAH?
20:16:23 --- kick: ebolajackson was kicked by dolio (ebolajackson)
20:16:31 <pjdelport> dolio: Thanks.
20:16:31 <Fuuzetsu> guestaccount11: No such thing
20:16:35 <Clint> Arahael: probably what you'll end up wanting at the end is monadic binding though
20:16:36 <jle`> it allows you to take an (Int -> Int -> Bool) to Either String Int -> Either String Int -> Either String Bool
20:16:49 <jle`> preserving the "meaning" of Either
20:17:01 <Arahael> Clint: What do you mean by that? I _do_ want an 'Either' at the end, although the type of 'Right' may have changed.
20:17:05 <jle`> it does it in the way that makes sense if you consider (Either String Int) as an Int that can be failing
20:17:16 <jle`> > liftA2 (+) (Right 7) (Right 9)
20:17:18 <lambdabot>  Right 16
20:17:26 <jle`> > liftA2 (+) (Left "hey") (Right 10)
20:17:27 <lambdabot>  Left "hey"
20:17:42 <Clint> Arahael: i mean you'll want something like filter1 >>= filter2 >>= filter3
20:17:46 <jle`> in the first case...adding two "succesful numbers", 7 and 9, should be a "succesful 16"
20:17:50 --- mode: ChanServ set -o dolio
20:18:04 <jle`> in the second case, adding a "failed number" and a "succesful 10" will...well, be a failed number
20:18:12 <Arahael> Clint: That is what I want, yes.
20:18:29 <jle`> the Applicative instance of Either is designed so that Eithers can be "added" with that meaning
20:19:07 <guestaccount11> Fuuzetsu: poop; does that mean LYAH is that good nobody has bothered?
20:19:17 <jle`> guestaccount11: there's that chalmers lecture series
20:19:23 <jle`> and also a lot of nice video lectures
20:20:08 <jle`> Arahael: at this case, it's a little hard to know exactly what you want, so can you put up a code sample?
20:20:15 <tabemann_> > liftA2 (+) (Left "foo") (Left "bar")
20:20:16 <lambdabot>  Left "foo"
20:20:18 <Fuuzetsu> guestaccount11: It depends on why you're looking for audio/video, it seems to me like a great way to waste time
20:20:25 <Arahael> jle`: I'm not completely sure what you mean by that Eithers can be "added".  If liftA2 (which is an implementation of fmap, really...
20:20:42 <guestaccount11> Fuuzetsu: it's the way I learn things.
20:21:03 <Fuuzetsu> you learn inherently textual things by listening?
20:21:37 <Arahael> jle`: I don't have a haskell example yet, but I suppose what I want is, to use sh syntax: loadCSV "myfile.csv" | sort | bestThree | cat
20:21:39 <tabemann_> liftA2 f x y = f <$> x <*> y
20:22:00 <jle`> Arahael: liftA2 is stornger than fmap
20:22:08 <jle`> i mean something like, (Right 7) and (Right 9).
20:22:12 <jle`> how can you add the 7 and 9 together?
20:22:16 <jle`> you can use liftA2 (+)
20:22:53 <jle`> you can't do it with fmap :)
20:22:59 <trap_exit> OMG moand transformers = so awesome = I'm in love
20:23:08 <trap_exit> I <3 mnonad transformers
20:23:15 <jle`> :)
20:23:17 <trap_exit> so much so I'm even using the retarded <3 emoji
20:23:18 <jle`> honeymoon phase, huh?
20:23:27 <guestaccount11> jle`: I don't seem able to find that series. A web search does not appear to be all that fruitful.
20:23:33 <trap_exit> no, I think this is the makeup sex phase
20:23:40 <Clint> Arahael: of upi
20:23:42 <Clint> er
20:23:52 <Clint> Arahael: if you're actually going to be doing IO, you could use EitherT for that
20:23:59 <jle`> http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
20:24:17 <jle`> guestaccount11
20:24:21 <Arahael> Clint: I am, actually going to be doing IO.
20:24:38 <Arahael> trap_exit: There's a "makeup sex" phase!?  How did I miss out.
20:24:45 <jle`> Arahael: if you have an Either a b
20:24:53 <guestaccount11> jle`: thanks
20:24:55 <jle`> er
20:24:57 <jle`> an Either e a
20:25:04 <jle`> and you can "factor out" your function into an (a -> b)
20:25:12 <jle`> like, all you ever need to do is (a -> b) on that a
20:25:14 <jle`> then you can use fmap.
20:25:15 <Arahael> Ok, Either e a; and I can definitely factor out my function into (a -> b)
20:25:23 <jle`> then def fmap is all you need
20:25:43 <jle`> if you have an (a -> Either e b), then the equivalent function would be (=<<)
20:26:20 <jle`> (<$>) is to (a -> b) as (=<<) is to (a -> Either e b).  they really fill similar roles.
20:26:31 <jle`> but if you just have an (a -> b), then fmap or (<$>) is all you need
20:26:33 <jle`> :)
20:27:00 <jle`> if you have an (a -> IO b), then you're going to be using mapM
20:27:07 <Arahael> jle`: The hardest part of this is developing a mental model of these patterns so that I can see how they're applied.  How would you use =<< in the code?  I should literally use =<< instead of <$> if the function is a -> Either e B?
20:27:15 <jle`> Arahael: yes, literally.
20:27:29 <Arahael> jle`: Wheraes if I used fmap, I'd end up with Either e (Either e B) ?
20:27:34 <jle`> Arahael: yes
20:27:36 <jle`> :D
20:27:38 <jle`> you got it.
20:27:44 <Arahael> AWESOME!
20:27:47 <jle`> it's basically haskell's family of lifters
20:27:51 <jle`> i have an Either e a.
20:27:55 <jle`> if i have an (a -> b), i use fmap
20:28:03 <jle`> if i have an (a -> Either e b), i use (=<<)
20:28:19 <jle`> if i have an Either e (a -> b), i use (<*>)
20:28:27 <jle`> if i have an (a -> IO b), i use mapM
20:28:30 <jle`> or traverse
20:28:46 <jle`> the entire goal is that you "lift" your function into the correct shape that you want
20:29:03 <jle`> it's just an issue of picking the correct lifter
20:29:27 <Fuuzetsu> what's with the trend of people using =<<
20:29:34 <Fuuzetsu> it just looks like a really sad person
20:29:45 <Fuuzetsu> >>= is the one true bind
20:29:47 <Arahael> jle`: Thanks. :)
20:29:55 <jle`> (=<<) is analogous to (<$>) tho
20:30:00 <jle`> it's basically generalized function application
20:30:01 <Fuuzetsu> then use <$>
20:30:10 <jle`> it's basically function application
20:30:20 <int-e> Fuuzetsu: the types are different
20:30:26 <Fuuzetsu> I'm well aware
20:30:33 <jle`> (a -> IO b) -> IO a -> IO b
20:30:34 <Fuuzetsu> anyway this is =<< vs >>=
20:30:40 <jle`> i like to write my function applications in normal order
20:30:47 <jle`> why write x & f when you can do f x
20:30:56 <Fuuzetsu> because it's not function application
20:31:33 <jle`> apply a function ... to a value
20:31:35 <jle`> in a generalized way
20:32:07 <jle`> to get a value
20:32:30 <jle`> (>>=) is nice with non-commutative monads
20:32:38 <Fuuzetsu> Left ()  >>=  foo doesn't apply anything
20:34:23 <Arahael> jle`: Thanks so much for that - I have to head off.
20:34:44 <jle`> Arahael: no problem :D have fun.
20:35:01 <jle`> Fuuzetsu: (>>=) sort of abstracts function application of a different sort
20:35:09 <benzrf> Fuuzetsu: yes but we have (<$>)
20:35:11 <Arahael> Fuuzetsu: As a note: It's easier to learn the slightly less generic approaches, imho.
20:35:14 <jle`> it doesn't actaully apply, but it has the same shape as function application
20:35:15 <benzrf> and *that* doesn't apply anything
20:35:19 <benzrf> (for Left)
20:35:22 <int-e> Fuuzetsu: anyway, your discussion comes 16 years too late.
20:35:30 <Fuuzetsu> int-e: why does it?
20:35:38 <Fuuzetsu> >>= is the standard direction
20:35:50 <jle`> f $ x
20:35:52 <jle`> f <$> x
20:35:54 <jle`> f =<< x
20:35:59 <int-e> (=<<) was added in Haskell 98, as far as I can see. Presumably people wanted it.
20:35:59 <jle`> one big happy family
20:36:24 <jle`> f <*> x
20:36:33 <jle`> the symmetry between the four are pretty powerful, in my opinion
20:36:37 * pjdelport wishes for <.>
20:36:43 <johnw> don't forget f <*> x!
20:36:49 <johnw> thx
20:36:51 <int-e> Besides this is bikeshedding territory.
20:36:54 <johnw>  <.> = liftA2 (.)?
20:37:36 <pjdelport> johnw: Nah: (f <.> g) x = f <$> g x
20:37:39 <jle`> (>>=) is nice when you are in a noncommutative monad, because it better facilitates reasoning about noncommutative effects.  also, it fits a lot better with lambda syntax
20:37:55 <pjdelport> johnw: By analogy with (f . g) x = f $ g x
20:38:03 <benzrf> <.> = ashamed look ;)
20:38:18 <johnw> at
20:38:20 <johnw> ah
20:38:38 <benzrf> pjdelport: hey i had that same idea once
20:38:47 <benzrf> even same name, i think
20:40:01 <pjdelport> foo xs = toLower <$> reverse xs
20:40:01 <pjdelport> foo = toLower <.> reverse
20:40:11 <pjdelport> That's the kind of thing it's useful for.
20:40:28 <johnw> fmap toLower . reverse
20:40:30 <pjdelport> Exactly the same intuition as with $ and (.)
20:40:42 <pjdelport> johnw: Right.
20:40:49 * hackagebot yi 0.11.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.11.0 (MateuszKowalczyk)
20:40:57 <johnw> what I mean is, it's not much of a savings
20:40:58 <pjdelport> But the idea is to avoid the fmap out of the blue. :)
20:41:01 <johnw> <$> is saving you parens
20:41:07 <johnw> <.> isn't even saving you the .
20:41:18 <pjdelport> It's more a conceptual saving.
20:41:19 <johnw> it drop two characters overall
20:41:42 <jle`> i like the fmap though :/
20:42:13 <benzrf> @let (..) = 3
20:42:13 <lambdabot>  Parse failed: Parse error: ..
20:42:17 <benzrf> i thought so :\
20:42:29 <pjdelport> The saving is more important when you're working with more complex subexpressions than just toLower and reverse. :)
20:43:06 <johnw> so what does foo <.> bar <.> baz mean?  that starts to get confusing kind of fast...
20:43:51 <johnw> all I'm saying is, it only helps clarity if you're the sort of people who thinks it helps clarity
20:43:54 <johnw> it's not an obvious win
20:44:09 <jle`> (.) is nice because of assocativity
20:47:24 <pjdelport> johnw: I have <.> defined infixr, just for fooling around, so that would mean the same as (foo . bar) <.> baz
20:47:57 <johnw> hmm
20:48:05 <johnw> do the types match up correctly?
20:48:11 <pjdelport> Yep.
20:48:44 <johnw> I guess with foo <.> bar, foo is fmap'd into the result from bar; and with (foo . bar) <.> baz, you're taking advantage of the 2nd fmap law
20:48:59 <johnw> yeah, that makes sense
20:49:06 <pjdelport> And yeah, i do realize the clarity is pretty subjective. :) I'm not _seriously_ thinking it'll get included.
20:49:17 <pjdelport> It's just a pet combinator i like.
20:49:21 <johnw> i give it a "cute" vote, but not a compelling one
20:50:44 <pjdelport> (It still irks me slightly whenever i have to shoehorn a bunch of fmaps into a (.) pipeline while refactoring, though...)
20:51:11 <johnw> how about just fmap over a normal . pipeline then?
20:51:52 <pjdelport> It depends on the surrounding code.
20:59:37 <pjdelport> The other pet combinators i'd like to see are higher-lifted <*> and <$>
21:00:39 <pjdelport> <**> = liftA2 (<*>) and <$$> = (<$>) . (<$>)
21:00:46 <pjdelport> (Too bad <**> is already taken, though.)
21:00:47 <johnw> ahh
21:00:51 <johnw> <$$> is often called .:
21:01:47 <pjdelport> johnw: Isn't that usually just function composition?
21:02:11 <johnw> (f .: g) x y = f (g x y)
21:02:15 <pjdelport> The <$$> above is for any functor, and basically applies a function two "levels" deep.
21:02:25 <johnw> (fmap . fmap) f g x y should mean the same thing
21:02:28 <kadoban> :t ((<$>) . (<$>))
21:02:29 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
21:02:35 <johnw> or mabye Im' thinking of fmap fmap fmap
21:02:43 <johnw> ahh
21:02:47 <johnw> i see what you mean now, sorry I misread
21:02:52 <pjdelport> It would be just what's needed for Arahael's thing earlier, for example: f . g <$$> parseCSV ...
21:03:27 <pjdelport> So it's just like <$>, but <$$> instead lifts into both the IO and Either layers.
21:03:41 <pjdelport> without a lot of syntactic noise
21:05:03 <johnw> I do buy that one
21:16:24 <Dreadnought> anyone online?
21:16:43 <johnw> likely many
21:16:52 <kadoban> 1387 people including yourself
21:17:20 <Dreadnought> any suggestions as to what programming language would be best to start with aside from html?
21:17:28 <Dreadnought> I’m looking for something object oriented
21:18:03 <johnw> Dreadnought: why are you asking here?
21:18:27 <kadoban> Dreadnought: I hear Haskell is a nice programming language.
21:19:01 <dmj`> what is the best quality redis library? I'm thinking hedis... Does anyone have any opinions
21:19:17 <johnw> dmj`: at fpco we used hedis
21:19:32 <dmj`> johnw: perfect
21:19:43 <dmj`> that will do
21:22:50 <Dreadnought> answer for the earlier question is that I’m a total noob aparently :s
21:22:54 <Dreadnought> my bad guys
21:42:32 <trap_exit> i need to format a 2.5" 128GB ssd before throwing it away. (1) what do I need to buy to format it and (2) how many timers do I need to format it to ensure that all data is wiped?>
21:48:17 <kloplop321> How do I write haddock documentation for stuff generated by template haskell?
22:07:26 <carter> trap_exit: just format it once
22:07:58 <carter> unless youre worried about a nationstate hacking it, SSDs dont have the same recovery support as magnetic drives
22:07:59 <nitrix> dr_: HTML isn't a programming language.
22:08:08 <nitrix> Dreadnought: ^
22:08:42 <nitrix> Interesting, it's the first time my IRC client glitch out like that. It's usually smart enough to show parts.
22:10:04 <kloplop321> So, does anyone know how to write documentation for something that template haskell generated?
22:10:35 <nitrix> kloplop321: If someone does, would they have to teach you?
22:10:55 <nitrix> It seems to me you're taking the wrong approach. Surely there's documentation for this.
22:11:23 <kloplop321> I'm looking for just an example. I remember seeing it in the summer before I started my job--but I can't seem to google-fu how to document a symbol later
22:12:49 <danaus> http://www.massivetrap.com
22:16:01 <Tene> danaus: Nice.
22:17:27 <Kaidelong> what is happening when I see "cabal.exe: does not exist" when cabal is trying to install things?
22:17:35 <Kaidelong> it is on my path
22:17:51 <kloplop321> Did you restart your command line session after updating the path?
22:18:12 <Kaidelong> I didn't update the path, I checked if it was on my path using which
22:19:12 <Kaidelong> it works fine in CMD but no GNU autoconf there so I can't build network
22:19:40 <kloplop321> Are you attempting to do it inside of cygwin?
22:19:45 <Kaidelong> mingw32
22:20:23 <kloplop321> I guess I can't offer much advice.
22:20:34 <danaus> Tene: isnt it?
22:25:30 <Kaidelong> I invoked "cabal install cabal-install" to see what would happen
22:25:36 <Kaidelong> now "network" is getting built
22:26:06 <Kaidelong> eventually though it hit "cabal.exe: does not exist"
22:26:33 <Kaidelong> is it possible it's related to me having a different gcc on the path from the one GHC is expecting?
22:27:28 <Kaidelong> I am going to try upgrading cabal to 1.20 and see if this persists
22:43:02 <Kaidelong> upgrading cabal fixed the problem
22:48:40 <CrazyM4n> Is there a good library or way to play live audio through haskell?
22:49:20 <CrazyM4n> Say I wanted to start a program to just simply play a sine wave. How would I do that? (I'm on linux by the way, if there is any nice way to interface with ALSA or pulseaudio)
22:50:47 <kloplop321> You could probably use a SFML binding or SDL binding.
22:51:21 <Hijiri> there's OpenAL
22:51:23 <CrazyM4n> Last I checked SDL doesn't support live/generated audio though
22:52:11 <CrazyM4n> I guess there's http://wiki.libsdl.org/SDL_OpenAudio
22:53:05 <CrazyM4n> I'm going to do it in python or C actually, then maybe rewrite it in haskell later
22:53:27 <joe9> In this example of cont monad: mv >>= f  = Cont (\k -> runCont mv (\a -> runCont (f a) k)), can it be simplified (crudely) as: mv (f (k (a)))?
22:53:45 <kloplop321> CrazyM4n: you could probably look at what this uses http://yaxu.org/demonstrating-tidal/
22:55:27 <CrazyM4n> That's pretty cool, it seems to interface with SuperCollider
22:55:58 <CrazyM4n> I think I'll use that
22:56:02 <CrazyM4n> Thanks
23:00:53 <benzrf> :t \caller -> Cont $ \cb -> runCont caller $ Cont $ \caller' -> caller' cb
23:00:54 <lambdabot>     Not in scope: data constructor ‘Cont’
23:00:55 <lambdabot>     Perhaps you meant one of these:
23:00:55 <lambdabot>       ‘Const’ (imported from Control.Lens),
23:00:58 <benzrf> oh.
23:01:04 <benzrf> :t \caller -> cont $ \cb -> runCont caller $ cont $ \caller' -> caller' cb
23:01:05 <lambdabot>     Couldn't match type ‘ContT r0 Identity (a -> r)’ with ‘a1 -> r’
23:01:05 <lambdabot>     Expected type: a1 -> r
23:01:05 <lambdabot>       Actual type: Cont r0 (a -> r)
23:01:52 <CrazyM4n> Aha, I found exactly what I was looking for http://rd.slavepianos.org/?t=hsc3
23:02:06 <CrazyM4n> This seems like an awesome little project
23:02:11 <CrazyM4n> Well, maybe not little
23:03:27 <johnw> joe9: I think it would be mv (k (f a))
23:03:59 <johnw> since k is the continuation for "f a", and "k (f a)" is the continuation for mv
23:04:56 <johnw> or maybe it's mv (k . f)
23:05:45 <johnw> best way to know is to unroll the definitions by hand, equational reasoning-style, and then remove all the type wrapping/unwrapping of the Cont
23:05:49 <ferbv> I've just installed the latest Haskell Platform (2014.2) on Windows 8.1, 32-bit, and "cabal update" is crashing with a "cabal.exe has stopped working" dialog. Any ideas on what I should try? Google reveals nothing relevant, updating cabal to 1.20 doesn't fix it, changing the Platform install directory to something without spaces likewise.
23:08:51 <benzrf> :t \caller -> cont $ \cb -> runCont caller $ \caller' -> runCont caller' cb
23:08:52 <lambdabot> Cont r (Cont r a) -> Cont r a
23:08:55 <benzrf> cont monad!
23:09:13 <benzrf> :t \caller -> \cb -> caller $ \caller' -> caller' cb
23:09:14 <lambdabot> (((t2 -> t1) -> t1) -> t) -> t2 -> t
23:09:28 <benzrf> hm..
23:13:38 <benzrf> @unmtl Cont r (Cont r a) -> Cont r a
23:13:38 <lambdabot> Cont r (Cont r a) -> Cont r a
23:13:41 <benzrf> aw
23:15:38 <johnw> ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
23:16:30 <johnw> Cont maps a strictly positive type to a doubly-negated one (non-strictly positive)
23:16:56 <johnw> it turns 'a' into '(a -> r) -> r'
23:18:48 <petercommand> why is the haskell function that creates a list with unique item called nub?
23:20:38 <johnw> "The name nub means `essence'."
23:20:42 <johnw> (from the documentation on 'nub')
23:22:09 <petercommand> hmm...
23:22:39 <petercommand> i see
23:41:11 * hackagebot acme-omitted 2.0.0.0 - A name for omitted definitions  http://hackage.haskell.org/package/acme-omitted-2.0.0.0 (JoachimFasting)
23:52:46 <sushith> what is the expansion for ghci?
