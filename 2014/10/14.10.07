00:00:08 <adas> because ultimately you could apply that mindset in any coding environment
00:01:19 <Qfwfq> But in that case, any reasonably senior programming position is as useful a metric. Do you write code professionally now? If so, you probably have enough of that.
00:02:04 <bartavelle> I would hazard that to be a strong haskell dev. you need to have a good knowledge on the RTS and the semantics of the language on top of that, and it can take a while to acquire it ...
00:02:12 <bartavelle> I sure haven't ;)
00:03:01 <moop> rts?
00:03:06 <bartavelle> run time system
00:03:38 <adas> Qfwfq: yes I work professionally now. But mostly python, django, JS. The normal stuff. Mentally, I'm happy with the challenge at work. But my heart is always wondering in haskell territory. There have been many instances at work, where I thought, if only I could do this in haskell. : )
00:04:09 * hackagebot HaskellNet-SSL 0.2.5 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.5 (DanielWright)
00:04:09 * hackagebot HaskellNet-SSL 0.2.5.1 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.5.1 (DanielWright)
00:04:10 <moop> javascript is almost like haskell
00:04:46 <moop> jokes aside, i've been reading about purescript lately
00:05:03 <moop> looks pretty nice
00:07:13 <adas> wouldn't be surprised if anyone else found themselves in my shoes
00:07:45 <Lutin`> adas: I'm in the exact same position
00:08:25 <adas> we both need haskell jobs !
00:08:48 <Lutin`> I need a job that isn't just making web sites lol
00:09:02 <Lutin`> All this high-level math going to waste
00:09:03 <AshyIsMe> i think most people in this channel would love a full time haskell role
00:10:24 <dfeuer> Yes.
00:10:34 <Lutin`> We could easily do an internal project in haskell, but most of our work is for companies we contract for
00:10:45 <Lutin`> And that's a pretty hard pitch
00:10:55 <adas> Lutin`: you're situation is more pressing. I don't have a high level math background and still want to write haskell professinally.
00:13:31 <Lutin`> My current issue with convincing my coworkers to work on a Haskell project isn't actually convincing them to write Haskell, it's to give up things like PyCharm and WebStorm
00:13:36 <tdammers> adas: you don't need a math background really
00:14:41 <Lutin`> I don't think he was implying that, but your point stands
00:15:14 <tdammers> anyway
00:15:22 <bartavelle> Lutin`, I am no web-dev, but I would presume that with websites the tedious part is all about the html, css, and js, so the Haskell switch would not look so attractive
00:15:29 <tdammers> haskell is scary to most programmers
00:15:36 <Lutin`> bartavelle: Precisely
00:15:36 <frihd> if not full-time, it's often possible to shoehorn haskell for some use
00:16:03 <frihd> for instance, i've written some haskell to build benchmark/experiment tools
00:16:13 <bartavelle> I have been shoehorning haskell for a while, but it works because I'm not a developer ...
00:16:14 <dfeuer> Lutin`, indeed, it seems that availability of good libraries and programming environments is often a bigger factor than programming language quality. If not for that, C++ and Emacs LISP would both be long dead.
00:16:25 <MrNosco> hello
00:16:28 <tdammers> haskell is really nice for web development (especially server-side), but it takes a lot of convincing to get people to give up their "easy" languages where you can just add an integer to a string and it'd "work"
00:16:58 <MrNosco> I don't understand why anyone ever thought that'd be a good idea
00:17:17 <bartavelle> because of the "dynamic" term which sounds much better than "static"
00:17:27 <MrNosco> I get stuff like Int + Float, but why String + Int
00:17:42 <tdammers> there are some pretty compelling arguments for dynamic typing, especially web dev
00:17:43 <Lutin`> bartavelle: But if you consider the whole move towards AngularJS style pages where the client just communicates with an API, it's easy to see how the API is language agnostic
00:17:45 <MrNosco> When do I *need the second thing
00:17:57 <tdammers> because the situation is that any inputs you get, and any outputs you send, are first and foremost strings
00:18:10 <MrNosco> hmmm
00:18:24 <tdammers> http://www.example.com/add-numbers?a=25&b=17
00:18:26 <bartavelle> Lutin`, yes, but the API is probably not what takes long when writing a website, so there isn't much gain in switching :/
00:18:53 <tdammers> you code sees a dictionary, sth like: { "a": "25", "b": "17" } (excuse the JSON)
00:19:00 <MrNosco> anyway, anyone here tried "yi"
00:19:02 <MrNosco> ?
00:19:28 <tdammers> and for a quick-and-dirty solution, you want `var c = a + b` to do the "right thing", without having to think about types
00:19:43 <frihd> bartavelle: well, if you have a public API, you can try to use company time to provide a haskell client =)
00:20:15 <dfeuer> MrNosco, very briefly. I got scared away by the rather spare user interface.
00:20:21 <tdammers> introducing static types into the mix is beneficial once your codebase grows beyond trivial, but it's a considerable up-front effort (especially if you're not used to it, and more so with languages that make static types explicit)
00:20:39 <MrNosco> dfeuer: I'm having issues installing it. Would you say it's not worth it?
00:21:00 <tdammers> as long as you can keep the entire project in your head, and manual testing covers all use cases, everything is peachy, you can move fast and pump out mostly-working code quickly
00:21:06 <tdammers> it just doesn't scale at all
00:21:58 <bartavelle> it's even better because modifications will take longer, so you can charge more
00:22:09 <MrNosco> hehe
00:22:29 <tdammers> no no, modifications are extremely fast, because you can just do stuff and deploy immediately
00:22:32 <dfeuer> MrNosco, I would say I simply do not know. Try doing it in a Cabal sandbox.
00:22:33 <Lutin`> bartavelle: Depends on the site. I've been working on a project where the API has taken about twice as long as the front-end code since the front-end is really just a thin wrapper around the API
00:22:49 <tdammers> you'll break things in the process, but that's not a problem... more bug reports, more billable hours
00:23:02 <tdammers> just need to educate the customer that this is the way things work :P
00:23:17 <Lutin`> And since all the business logic is on the API side, I could definitely use Haskell
00:23:31 <bartavelle> Lutin`, I suppose as I am a hobbyist I feel time in a subjective way ... those html/css/js parts annoy me so much I feel they take 10x longer than the rest
00:24:59 <tdammers> the nasty part about dynamic languages is that the initial development speed gain is tempting, and the scaling issues are somewhere down the road, but when they start being a serious problem, you are already months into the project, so the psychological barrier of rewriting from scratch in a different language is sky-high
00:25:19 <tdammers> "we're not throwing away 6000 man-hours of development time!"
00:25:34 <MrNosco> I have this Lsys renderer in JS, and I cannot stomach looking at the source anymore
00:25:41 <tdammers> even if that means spending another 12,000 hours on a project that could be rewritten in 8000
00:26:16 <Lutin`> tdammers: Yeah clients also have an issue with realizing that 6000 hours of dev time does not mean it would take another 6000 to recreate from scratch, even in the same framework
00:26:34 <Lutin`> So much of that time spent is just reasoning about the structure and logic of the code
00:27:08 <tdammers> there was this project in Amsterdam where they were going to build a subway line connecting the northern parts to the city center
00:27:23 <merijn> tdammers: *was*
00:27:26 <merijn> ?
00:27:40 <tdammers> now, Amsterdam is built on wet sand, essentially, and that subway line requires a tunnel under a huge river
00:27:47 <merijn> Don't tell me I leave for a few months and it's magically done after like a decade of ineptitude :p
00:28:01 <tdammers> merijn: was/is/... depends how you look at it
00:28:14 <tdammers> so anyway, they had a budget, and started building the thing
00:28:18 <kazagistar> Lutin`: if you dont learn from the mistakes of the original, you are doomed to repeat them, or alternatively, fall into mistakes the original avoided
00:28:39 <tdammers> but as these things go, contractors go bankrupt, deadlines are blown, issues arise
00:28:43 <kazagistar> which is why you should always document things you didn't do too
00:28:47 <Lutin`> kazagistar: Definitely
00:29:05 <tdammers> at some point, the situation was so out of hand that they hired an external firm to assess the situation and suggest how to proceed
00:29:11 <MrNosco> have any of you gotten to work with haskell, proffesionally?
00:29:13 <kazagistar> as well as documenting things that seem like a hack from the outside
00:29:33 <merijn> "Oh, we run over budget, lets cut back on money by using less reinforcement for buildings"
00:29:34 <Lutin`> I <3 lots of comments and long commit messages
00:29:47 <merijn> "Oh, whoops, half a street sagged and we need to pay to fix the damage"
00:29:52 <tdammers> their advice was to drop everything, close the part of the tunnel they had already built, and never mention the project again
00:30:05 <tdammers> because there was no way the project would ever be profitable
00:30:10 <MrNosco> hahaha, seriously??
00:30:12 <merijn> tdammers: That's what they did for the east-west line already :p
00:30:14 <tdammers> but they couldn't do that
00:30:21 <merijn> MrNosco: That's already happend to one of the planned subways
00:30:32 <tdammers> merijn: yeah, I know... there are some amazing pictures of ghost stations from that line :D
00:30:44 <kazagistar> sunk costs are a brutal killer
00:30:46 <merijn> tdammers: There was a festival in one of the stations not too long ago
00:30:56 <merijn> I think they're closed up now
00:30:57 <tdammers> merijn: cool, didn't see that
00:31:36 <tdammers> so anyway, point of this story: sunk costs are a powerful motivator for throwing even more money away
00:34:14 <dfeuer> Building, building, building.
00:34:20 <dfeuer> Frickin' GHC libraries.
00:34:45 <dfeuer> You touch one bleepin' thing in base, and you're in for a *LONG* build.
00:34:55 <merijn> New laptop arrived today, so maybe this weekend I finally have the power to actually write my three open GHC tickets >.>
00:35:22 <dfeuer> Exciting, merijn! Can I have your old one?
00:35:25 <Lutin`> Has anyone here played around with Julia?
00:35:40 <merijn> dfeuer: That doesn't help you if you wanna hack GHC :p
00:39:41 <dfeuer> merijn, how's that? Is your old laptop something that doesn't work with GHC?
00:40:01 <merijn> dfeuer: No, but it's like 6 years old, so compiling GHC takes like umpteen billion hours :p
00:40:27 <merijn> Hence why I haven't actually written these patches I mentioned, because I can't be arsed to compile GHC and check they're correct on this machine :p
00:40:35 <dfeuer> Hrmmm... Yeah, mine's only about 3 years old, but it's on its last legs. Something with the motherboard, I think.
00:44:06 * hackagebot yesod-core 1.4.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.2 (MichaelSnoyman)
00:49:57 <grohne> is there a way to craft class instances at runtime and pass them explicitly?
00:52:58 <merijn> grohne: Yes...ish
00:53:01 <Polarina> How do I specify a source repository in a .cabal file? Adding one gives me an error like {cabal: sdl2.cabal:18: Plain fields are not allowed in between stanzas: F 23}. See https://gist.github.com/polarina/788eaa80a45593407d30
00:53:12 <merijn> grohne: You do realise this path leads to madness and insanity, right?
00:55:02 <dcoutts> Polarina: here's an example of a .cabal file with a source stanza
00:55:03 <dcoutts> http://hackage.haskell.org/package/zlib-0.5.4.1/zlib.cabal
00:55:40 <Polarina> dcoutts, what does zlib do differently? I'm not seeing the difference.
00:56:29 <Faucelme> grohne: Get the source for the "reflection" package, look at Monoid.hs in the examples folder.
00:56:39 <Faucelme> Not that I understand it myself.
00:58:27 <dcoutts> Polarina: sorry, I can't see the gist. github demands I log in.
01:00:06 <Polarina> dcoutts, does this work? http://codepad.org/B9k4leUc
01:00:49 <dcoutts> Polarina: ahh, you can't have the extra-source-files there
01:00:59 <dcoutts> Polarina: that is part of the "global" stanza at the top
01:01:25 <dcoutts> you have to have the global stanze first, then extra ones like library, source-repo etc
01:02:36 <Polarina> dcoutts, I see, I'll try that. I would've thought the cabal documentation would mention this...
01:03:26 <dcoutts> I suspect it does, but it'd be easy to not notice it
01:03:36 <dcoutts> the poor thing here is the error message
01:03:45 <Polarina> dcoutts, it seems to work now, thank you.
01:03:52 <dcoutts> (because the parser needs rewriting)
01:19:07 * hackagebot sdl2 1.1.2 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.1.2 (Polarina)
01:20:09 <solatis> *sigh*
01:20:34 <Polarina> solatis, what's the matter?
01:20:58 <solatis> while complaining about some bugs in database.persist to a friend, i got a snarky reply back "that's what you get for using a functional language -- there's hardly any community backing it"
01:21:29 <solatis> i guess he's kind of right
01:22:04 <solatis> guess i should try to keep things simple at this point and not try to get too fancy
01:22:28 <Polarina> solatis, bugs happen. It's best to file a bug report on the library and have it fixed.
01:23:26 <zipper> What does Cabal dir mean when I am trying to use cabal repl inside emacs?
01:24:00 <zipper> Also it's attempting to create a temporary project yet it's in a cabal project.
01:24:14 <solatis> Polarina, yeah that's right, and i've already done so -- apparently i was using an experimental API :)
01:27:45 <jle`> i just did ((<*>) . (<*>)) hoping it would work
01:27:47 <jle`> and...
01:27:49 <jle`> it didn't
01:27:51 <jle`> heh
01:28:37 <solatis> jle`, looks like a great smiley for an obfuscated haskell contest tho
01:28:51 <Qfwfq> :t ap.ap
01:28:53 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
01:29:23 <jle`> i wanted an (Applicative f2, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
01:29:26 <kazagistar> define "work", it seems to typecheck at least
01:29:38 <jle`> so i thought
01:29:43 <jle`> oh it's basically like a double app right
01:29:56 <jle`> i was wrong ;_;
01:30:14 <jle`> :t liftA2 (<*>)
01:30:15 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
01:30:22 <jle`> oh neat
01:30:29 <jle`> my second guess
01:30:58 <jle`> haskell is so weird
01:31:49 <zipper> What does "build target" mean in a haskell project?
01:37:08 <frihd> zipper:  when cabal installing some package?
01:37:59 <zipper> frihd: No I am trying to use the cabal repl with ghci in emacs. It asks for build target and I leave it empty for default.
01:38:15 <zipper> Then I get the error `no such file or directory, cabal`
01:38:45 <zipper> I think emacs can't find cabal. So I will install it in the sandbox that emacs gets it's cabal files.
01:39:35 <zipper> It might not work, though. It's something I just thought up.
01:43:06 <frihd> ah
01:43:22 <frihd> does the .cabal has multiple items (the targets)
01:43:30 <frihd> like a library and one binary
01:43:32 <frihd> or many binaries
01:44:34 <frihd> the syntax is `cabal repl <targetname>`
01:44:42 <frihd> but I know zilch about emacs =)
01:46:04 <ph88> why is 9 wrapped up in    (\f -> f 9)   ??   http://pastebin.com/T1H1jLT3
01:46:45 <Haskellfant> :t fmap
01:46:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:46:50 <Haskellfant> ph88: look at the type
01:46:58 <Haskellfant> the first argument of fmap is a function a -> b
01:47:03 <Haskellfant> :t 9
01:47:05 <lambdabot> Num a => a
01:47:09 <Haskellfant> 9 is no such function
01:47:19 <frihd> zipper:  grep -E '(executable|library)' *.cabal
01:47:27 <Haskellfant> :t (\f -> f 9)
01:47:29 <lambdabot> Num a => (a -> t) -> t
01:47:41 <fread2282> :t ($ 9)
01:47:41 <sbidin> Would it be acceptable to state values are "functions of no arguments"? If not, how about when talking to beginners? I'm helping teach a Haskell class and am trying to avoid saying stupid things.
01:47:42 <lambdabot> Num a => (a -> b) -> b
01:47:46 <Haskellfant> so this is a function that takes a function that takes a number and applies the number to it
01:48:01 <Haskellfant> yep ($ 9) is the same if that's easier for you to understand
01:48:05 <Cale> sbidin: That's a silly thing, because then there's no distinction between the word "function" and the word "value"
01:48:21 <Cale> sbidin: I prefer to insist that functions are values of type A -> B for some types A and B
01:48:35 <ph88> a function to execute another function o_O
01:48:46 <frihd> I second Cale, it is the other way around
01:49:00 <ph88> isn't that a bit cumbersome ?
01:49:07 <kazagistar> sbidin: functions are values that can be applied to other values to produce values
01:49:21 <ph88> why not apply 9 to the list of functions directly ?
01:49:37 <Cale> ph88: hm? 9 tends not to be a function
01:49:43 <kazagistar> :k (->)
01:49:44 <lambdabot> * -> * -> *
01:49:51 <sbidin> Cale, frihd, kazagistar: Thanks! That makes sense.
01:50:01 <Cale> ph88: You mean apply each of the list of functions to 9?
01:50:08 <ph88> yes
01:50:30 <ph88> well to me the order doesnt matter as 2 * 9 = 9 * 2
01:50:33 <Cale> Well, if you want to use map, it applies a function to each of the elements of a list
01:51:03 <Cale> So, if those elements are functions, you need to apply the function which will apply them to 9
01:51:14 <ph88> so using map is still the shortest way to combine the 9 with the list of functions ?
01:51:42 <Cale> Yeah, you could write a list comprehension or something recursive I suppose
01:51:49 <kazagistar> sbidin:  if you wanna help strict/imperative programmers, maybe just explain it in terms of thunks?
01:51:52 <Cale> The list comprehension would be translated in terms of concatMap anyway
01:51:59 <frihd> sbidin:  if you want to give some intuition, I'd say a function is a mapping between input and outputs, which is quite close to what a hash/dict is
01:52:02 <Cale> i.e.  [f 9 | f <- fs]
01:52:29 <ph88> oh ye
01:52:31 <Cale> would desugar to  concatMap (\f -> [f 9]) fs
01:53:03 <ph88> doesn't that add more overhead on the CPU ?
01:53:07 <Cale> hm?
01:53:18 <ph88> (\f -> f 9)
01:53:19 <Cale> Well, that depends on what the compiler does with it
01:53:37 <ph88> if that's a real function that you get one extra function call
01:53:38 <Cale> The code is going to be transformed a lot before it actually runs
01:53:44 <ph88> oh ye
01:54:08 <ph88> because imputting the 9 directly would be the fastest way
01:54:14 <Cale> Function application tends to be extremely cheap
01:54:15 <ph88> (not talking about the syntax now)
01:54:35 <ph88> oh ok great, so no need to worry about that then
01:56:14 <ph88> what's lifting ? i've read it but didnt really understand
01:56:16 <Cale> ph88: You might need to worry about performance at some point
01:56:23 <kazagistar> sbidin: IE, "when you apply a function + to one value, it creates a thunk in memory that looks like {(+) 3 ?} :: Int -> Int. When you apply it to a second value, it just fills in the thunk more like {(+) 3 2} :: Int, and when it is inspected it turns into its evaluated form {id 5}, and still has the same type, but does not need do the computation again"
01:56:26 <Cale> ph88: But don't worry about it while you're still a beginner :)
01:56:46 <Cale> ph88: Coming from almost any other language, all your intuition about what's efficient or not will be wrong.
01:57:26 <Cale> (especially as evaluation is carried out in almost exactly the reverse order that it happens under strict evaluation that most programming languages use)
01:57:42 <tdammers> ph88: one thing worth noting is that "calling a function" is not necessarily implemented as a physical function call at the assembly level
01:57:55 <Cale> ph88: Lifting is a vague general term for turning values of one type into values of a conceptually "larger" type
01:58:00 <tdammers> ph88: that's because a Haskell function is not the same as a C "function"
01:58:09 <ph88> oki
01:58:16 <frihd> :t liftM
01:58:17 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:58:19 <ph88> i write some other languages too
01:58:23 <Cale> ph88: There are a number of places that "lift" gets used
01:58:34 <Cale> ph88: and they're a bit different
01:58:55 <Cale> Yeah, there's liftM for instance, which turns functions a -> b into functions M a -> M b whenever M is some monad.
01:58:59 <ph88> what do you mean, larger type ?
01:59:17 <kazagistar> basically, when you describe the desugared form, it is still a LONG way from machine code. Even when you describe things in terms of thunks it is far from fully optimized
01:59:36 <kazagistar> :t map
01:59:36 <lambdabot> (a -> b) -> [a] -> [b]
01:59:40 <CindyLinz> > minBound - 1 :: Int
01:59:41 <kazagistar> :t (map . map)
01:59:42 <lambdabot> (a -> b) -> [[a]] -> [[b]]
01:59:42 <lambdabot>  9223372036854775807
01:59:43 <jTT> hey, does anyone ahve experiences with reading csv files that only contain floating point numbers from a csv file into matrix using haskell? could you point me at the best way/packages for such a task
01:59:50 <kazagistar> :t (map . map . map)
01:59:51 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
02:00:00 <ph88> ok i see the additional letter sure, but don't really get what the input and output is of the lift operation
02:00:06 <CindyLinz> Is it a defined behavior or undefined behavior? @@"  minBound - 1 :: Int64
02:00:06 <frihd> ph88 in the liftM example you can read (a1 -> r) -> m a1 -> m r  as (a1 -> r) -> (m a1 -> m r)
02:00:14 <Cale> ph88: Do you mean "lift" specifically?
02:00:18 <Cale> There is a function called lift
02:00:22 <ph88> no
02:00:25 <ph88> lifting a function
02:00:27 <Cale> But people use the term "lifting" to mean lots of things
02:00:39 <ph88> In the same vein, if we write fmap :: (a -> b) -> (f a -> f b), we can think of fmap not as a function that takes one function and a functor and returns a functor, but as a function that takes a function and returns a new function that's just like the old one, only it takes a functor as a parameter and returns a functor as the result. It takes an a -> b function and returns a function f a -> f b. This is called lifting a function.
02:00:41 <Cale> You really kind of need context to know what someone means by it
02:01:05 <tdammers> the traditional examples would be lifting a pure function into a monad, or lifting a monad action into another monad (usually one or more levels up in a monad transformer stack)
02:01:07 <kazagistar> ph88: see how map turns a "function from a to b" to a "function of [a] to [b]"
02:01:53 <Cale> So, here, we're thinking of the space of functions (f a -> f b) as being "larger" in some way than the space of functions (a -> b), and fmap is making that idea precise, by specifying how functions (a -> b) correspond to certain functions (f a -> f b)
02:02:41 <ph88> if (a -> b) is the function, then what's f ?
02:02:45 <Cale> For a given functor F, not all functions (F a -> F b) in general will be of the form fmap h for some function h :: a -> b -- there will typically be many more
02:03:08 <Cale> f is a (variable) type constructor
02:03:17 <Cale> So, for example, we might have some type like
02:03:34 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
02:03:43 <ph88> i regard f as Functor that's input for function (a -> b)
02:03:53 <Cale> This is a type for binary trees with values of type a on the internal (Branch) nodes
02:03:55 <kazagistar> ph88: in the case of fmap anything that implements the functor interface, for example, a List or a Maybe or Tree
02:04:22 <Cale> Our Tree data constructor here can be made into a functor as follows:
02:04:30 <Cale> instance Functor Tree where
02:04:42 <Cale>   fmap h Tip = Tip
02:05:00 <Cale>   fmap h (Branch x l r) = Branch (h x) (fmap h l) (fmap h r)
02:05:31 <ph88> i thought fmap actually applies a function and not change it's type
02:05:40 <Cale> Here, fmap :: (a -> b) -> (Tree a -> Tree b)
02:05:53 <Cale> So, there are (at least) two ways you can think about this
02:06:00 <kazagistar> :t fmap
02:06:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:06:05 <tdammers> ph88: on some level, they're the same thing :x
02:06:07 <Cale> You can think of it as a function which takes some function h, and some tree t
02:06:19 <Cale> and applies the function h to each of the elements stored in the tree t
02:06:35 <Cale> Or, you can think of it as a function which takes some function h :: a -> b
02:06:35 <kazagistar> :t fmap (+4)
02:06:36 <lambdabot> (Num b, Functor f) => f b -> f b
02:06:40 <ph88> so when going from (a -> b) to (f a -> f b)  the fmap operation has been performed ?
02:06:41 <Cale> and turns it into a function Tree a -> Tree b
02:06:59 <Cale> i.e. fmap h :: Tree a -> Tree b
02:07:24 <kazagistar> ph88: are you comfortable with currying yet?
02:07:45 <tdammers> ph88: shift your mindset from "a function is something that does something to values" to "a function is a many-to-many mapping of values of one tye to values of another type"
02:08:01 <tdammers> (errr, many-to-one0
02:08:51 <ph88> yes ok so it's the difference between if you consider it as already has been performed and being passed on VS creating another order function and passing that on
02:09:27 <Cale> ph88: In Haskell, all functions are secretly functions of exactly one argument
02:09:38 <Cale> When you see a type like A -> B -> C
02:09:43 <Cale> it really means A -> (B -> C)
02:09:48 <ph88> ye i've read that
02:09:56 <Cale> and when you write f x y
02:10:02 <Cale> it really means (f x) y
02:10:03 <ph88> but it means when reading the code you have different ways of reading the same code
02:10:15 <Cale> Yeah, there are some options for how to think about things
02:10:24 <ph88> because i can also read it as a function that takes more parameters, and this is most of the time easiest to understand
02:11:31 <ph88> so i think it's the same with "lifting a function" that it's also a perspective on how to read the code, and therefor similar code can also be explained differently (as applying the function)
02:11:45 <ph88> maybe if i start coding more i'll get the difference more clearly
02:12:08 <jTT> has anyone worked with csv files and Data.Matrix? Is there a standard way of bringing them together?
02:12:23 <ph88> tried cupids arrow ?
02:12:28 <ph88> ;)
02:12:29 <jTT> I.e. read a csv file and do operations on the resulting matrix
02:14:30 <BoR0> how can I fix warnings in the form of "Reduce duplication ... why not combine with A". I have 2 functions that have a likewise structure just below "where"
02:14:55 <ph88> how do they look ?
02:20:17 <makalu> in a MaybeT, "return x" creates "Just x". How do I return Nothing?
02:21:29 <Cale> mzero
02:22:04 <kazagistar> empty
02:22:43 <makalu> empty from where?
02:22:55 <Cale> I'd just use mzero :P
02:23:06 <makalu> I will but I'm interested what he meant :)
02:23:27 <Cale> That is a good question actually :)
02:23:28 <kazagistar> mzero from MonadPlus, empty from Alternative
02:23:41 <ph88> MonadPlus .. lol
02:23:55 <ph88> Is there also MonadTurbo ?
02:23:55 <Haskellfant> makalu: you could also just write Nothing to return Nothing
02:24:00 <Cale> ph88: It's a class for monads which have an addition operation
02:24:07 <lieven_> fail "" from Monad :)
02:24:10 * hackagebot combinat 0.2.6.2 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.6.2 (BalazsKomuves)
02:24:13 <Cale> :t mplus
02:24:14 <lambdabot> MonadPlus m => m a -> m a -> m a
02:24:17 <Cale> :t mzero
02:24:18 <lambdabot> MonadPlus m => m a
02:24:28 <makalu> thanks Cale and kazagistar
02:24:37 <Cale> For example, lists can be concatenated
02:24:40 <kazagistar> Haskellfant: that probably wont work in MaybeT, right?
02:24:44 <Cale> > mplus [1,2,3] [4,5]
02:24:46 <lambdabot>  [1,2,3,4,5]
02:24:55 <Cale> and the empty list is an identity for that operation
02:25:00 <Cale> > mzero :: [Integer]
02:25:02 <lambdabot>  []
02:25:09 <gilligan-> Can anyone suggest me how I could go about getting a list of value constructors for a given type constructor ? i.e given "Just" i would get "Nothing" and "Maybe a" -- perhaps with haskell-src-exts?
02:25:10 <BoR0> > mplus (Just 1) (Just 2)
02:25:11 <Cale> > mplus [1,2,3] mzero
02:25:12 <lambdabot>  Just 1
02:25:13 <lambdabot>  [1,2,3]
02:25:50 <Cale> gilligan-: Surely you mean given "Maybe", you would get "Nothing" and "Just"?
02:26:18 <Haskellfant> kazagistar: hm right, didn't see the T :)
02:26:40 <kazagistar> Haskellfant: that was my first thought too, but it seemed to obvious :P
02:26:50 <Cale> gilligan-: It's possible to do using stuff from template haskell... but what exactly are your goals?
02:27:17 <Cale> gilligan-: (Using TH might be in the wrong direction, depending on what you were going to use this information for)
02:27:18 <BoR0> what's the logic behind the definition of Just x  `mplus` Just y  = Just x, why not Just (x+y) ?
02:27:40 <Cale> BoR0: There's no way of knowing that the elements are numbers
02:27:48 <Cale> :t mplus
02:27:49 <lambdabot> MonadPlus m => m a -> m a -> m a
02:27:56 <Cale> ^^ no assumption here that a is an instance of Num
02:28:05 <BoR0> aha. so how is Just x `mplus` Just y = Just x useful?
02:28:15 <lieven_> BoR0: the logic is the first not Nothing value
02:28:20 <ph88> BoR0: i think it has to do with the values being wrapped in a functor .. so i guess sometimes you get a functor somewhere and not a concrete value
02:28:28 <gilligan-> Cale, sorry - i should't be talking to my wife AND chatting ;)
02:28:33 <Cale> Well, it's useful when you have a bunch of possibly-defined options in priority order, and you want to pick the first one which is set
02:28:35 <kazagistar> BoR0: its the "if this fails, try the next one" logic
02:28:46 <BoR0> I see, okay, cool
02:28:50 <Cale> BoR0: This kind of thing comes up when loading configurations from multiple sources
02:29:10 <Cale> e.g. there might be some local user configuration, and then system-wide configuration, and then defaults
02:29:19 <Cale> and you want to pick the first one for which the option is actually set
02:29:24 <BoR0> I was just thinking of Either, and in the next second I am reading "Like Maybe, (Either e) represents computations that can fail." at http://en.wikibooks.org/wiki/Haskell/MonadPlus :)
02:29:38 <kazagistar> BoR0: the Monad Maybe is "if we succeed, keep going, otherwise bail", and the MonadPlus adds "if we fail, try the other thing"
02:29:48 <gilligan-> Cale, use case is an editor plugin - to create pattern match skeleton code on the fly given a type to match
02:29:54 <BoR0> yup, makes sense. thanks guys
02:29:58 <Cale> gilligan-: ah, okay
02:30:09 <Cale> gilligan-: Then possibly TH would be your best bet'
02:30:31 <gilligan-> Cale, thanks
02:30:44 <kazagistar> BoR0: Maybe a is basically like Either () a :P
02:30:45 <ph88> is this a good source http://en.wikibooks.org/wiki/Haskell ?
02:30:49 <Cale> gilligan-: http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#g:4
02:32:45 <gilligan-> Cale, cool
02:34:18 <kazagistar> ph88: a source for what? learning haskell?
02:35:10 <dfeuer> To learn Haskell, one must first know everything that is not Haskell.
02:36:27 <kazagistar> dfeuer: that is quite a lot of things to learn
02:36:47 <dfeuer> kazagistar, that's why so few people are Haskell experts.
02:37:34 <kazagistar> you also have to have the ability to take the inverse of a set, which is mathematically annoying
02:37:39 <kazagistar> or so I hear
02:39:08 <ph88> kazagistar: ye
02:39:12 <eisbehr> The skill most needed for learning Haskell is the ability to ignore horror stories about how hard it is to learn Haskell
02:39:19 <eisbehr> But I hear that's not easy
02:39:50 <kazagistar> naw, the horror stories make it more attractive, a greater beast to be tamed
02:40:15 <gilligan-> .oO( Always thought the tagline was "Unfortunately, no on can be told what Haskell is. You have to see it for yourself")
02:40:30 <dfeuer> You only need to know type theory, category theory, and how to operate proof verification systems generally, along with general functional, logic, and object oriented programming.
02:41:31 <AshyIsMe> to learn you a haskell, you must first create the universe...
02:42:13 <eisbehr> You need OO programming just so you can forget everything you know about OO programming.
02:42:26 <eisbehr> Since that's the first step to learning functional programming
02:43:02 <kazagistar> no, that wont work, haskell is bigger then the universe, look in the implementation of IO to see for yourself
02:43:13 <dfeuer> :-P
02:44:11 <dfeuer> It's got the RealWorld# in its hands. It's got the RealWorld# in its hands.
02:44:21 <MP2E> haha
02:44:33 * dfeuer falls asleep.
02:47:40 <ph88> in Applicative   why is pure needed ?
02:48:06 <ph88> i must say these chapters are particullary slow to work through
02:49:49 <ph88> particularly *
02:51:02 <tdammers> they are slow because they introduce concepts you aren't familiar with
02:51:43 <frihd> ph88:  it is not "needed", there exists alternative formulations
02:55:39 <frihd> ph88 if you dare stare at the abyss http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
02:56:07 <trap_exit> suppose I have a function of type StateMonad s1
02:56:36 <ph88> no i'm too afraid :P
02:56:49 <trap_exit> suppose I have (1) a function of type StateMonad s1, and (2) a funciton of type StateMOnad s2 ... and I want to do something with both s1 and s2 .... is there an automatic way to do this, or do I have to end up defining a "StateMonad (s1, s2)" and make both functions  to be of type "StateMOnad (s1, s2)" ? This is sorta like MonadTransformers, but both Monads are State
02:58:05 <tdammers> you could stack two StateT's on top of each other
02:58:23 <tdammers> (or one StateT on top of a State)
02:59:56 <trap_exit> in that case
02:59:59 <trap_exit> state__get
03:00:00 <trap_exit> and state__put
03:00:02 <Qfwfq> 'deriving Read' pls stahp
03:00:05 <trap_exit> which state is being accessed ?
03:00:15 <trap_exit> tdammers: ^^
03:00:54 <tdammers> the topmost, unless you lift explicitly
03:01:40 <kazagistar> or build your own, more specific monad, with your own lift implementation
03:01:59 <zipper> Could I get some help running the cabal repl in a cabal project in emacs. This is the error I keep getting. http://ix.io/eEL
03:02:13 <tdammers> yeah, if this is not just a one-off case, it's probably best to wrap the monad stack in a custom newtype or some such, and provide a narrower interface
03:02:28 <trap_exit> hmm
03:02:31 <hexagoxel> trap_exit: multistate avoids lifting
03:02:35 <trap_exit> I think State (s1, s2) is easier
03:02:37 <zipper> Oh wait ignore that
03:02:46 <trap_exit> hexagoxel: what is 'multistate' ?
03:03:55 <hexagoxel> trap_exit: https://hackage.haskell.org/package/multistate
03:04:45 <trap_exit> wtf
03:04:54 <trap_exit> so basically if I have multiple state, but the states have different Types
03:04:54 <trap_exit> it'll figure out the right one?
03:05:04 <hexagoxel> (and there exist more general solutions, like extensible effects)
03:05:11 <trap_exit> i.e. as long as I'm not store two vars of the same type, it just magically works?
03:05:19 <hexagoxel> yes
03:05:20 <trap_exit> this is fucking brilliant
03:06:40 <MP2E> does extensible-effects impact runtime performance compared to monad transformers?
03:07:06 <trap_exit> MP2E: do you sleep? what time zone are you in?
03:07:09 <trap_exit> you seem to be online any time I'm online
03:07:25 <MP2E> GMT -8, it's pretty late where i live right now so i'll be sleeping soon, but yeah i tend to be on IRC late at night a lot
03:12:29 <frihd> ph88, I think that the alternative formulation makes more sense to "grow an intuition" on applicatives, but pure and <*> are prevalent when reading/writing code
03:14:09 <frihd> User <$> getName <*> getBirthDate <*> pure adminFlag     is quite close to      User name bdate adminFlag
03:14:23 <frihd> does it make sense ph88 ?
03:14:45 <hexagoxel> trap_exit: feel free to ping me if you find stuff missing from multistate
03:15:06 <trap_exit> hexagoxel: oh wow, you're the author of multistate
03:15:10 <trap_exit> ?
03:15:14 <trap_exit> so I sorta lied
03:15:19 <trap_exit> I need to combine two RWS
03:15:21 <trap_exit> not two State
03:15:30 <trap_exit> but I asked about State since it was simpler to reason about
03:16:17 <hexagoxel> MP2E: the paper has a short paragraph on performance but is mildly vague. i don't know more.
03:18:50 <hexagoxel> trap_exit: yes. hmm, i have a implemented multiwritert as well, but that's not published yet. rws should not be too complex..
03:19:13 * hackagebot loop-effin 0.1.1.0 - control-monad-loop port for effin  http://hackage.haskell.org/package/loop-effin-0.1.1.0 (HiromiIshii)
03:19:25 <trap_exit> how does rws work -- can I combine (r1, s1, w1) and (r1, s2, s1) ?
03:19:36 <trap_exit> or does it have to be (r1, s1, w1) and (r2, s2, w2) ?
03:21:00 <hexagoxel> gotta go, later
03:27:21 <vanila> http://artyom.me/lens-over-tea-1
03:39:50 <rindolf> Hi all. I'd like to echo some of my frustration with Haskell and GHC.
03:40:08 <gregnwosu> rindolf: go for it
03:40:22 <rindolf> First of all , Haskell is new Python in the sense of "There's only one Good Way to Do it".
03:41:58 <rindolf> Secondly, Haskell is a worse python because the "non-idiomatic" programs I tried to write (which to me seemed like should work based on my previous knowledge) were unusubaly slow and/or memory hungry whereas non-idiomatic Python progs were still performant.
03:43:16 <rindolf> Since I'm now more of a writer/entertainer/philosopher and see software dev as a necessary means to it , and since Haskell does not allow me to easily "Get shit done" , I decided to dismiss it.
03:43:57 <quchen> I learned Haskell as an interesting educational exercise. It then turned out to be awesome for practical purposes as well.
03:44:05 <hc> +1
03:44:09 <jle`> do you mean that your previous knowledge has left you with an intuition that is not suitable for haskell?
03:44:21 <jle`> is that the fault of haskell, or of your previous experience?
03:44:31 * SwashBuckla looks at his old ideas, sitting in the bin
03:44:33 <silver> rindolf, thanks for you feedback and good luck with python
03:44:41 <SwashBuckla> yep, they belong there
03:44:59 <jle`> almost all people who learn haskell as a first language register none of the typical "this odesn't work like how i have been trained to expect, so it's not worth laerning" complains
03:45:42 <jle`> in fact, they are more likely to feel that imperative languages are unperformant, memory hungry, non-idiomatic, and things that they feel should work based on their previous knowledge no longer work
03:45:49 <stefan_1__> rindolf: can you give an example of the "non-idiomatic" stuff you are trying to do?
03:46:05 <BoR0> let's try to be constructive. rindolf, why not supply a minimal sample code that performs slow and let's see where that leads (I'm no Haskell expert but I'm interested)
03:46:30 <jle`> also, i don't quite feel like in haskell, the "only one good way" mantra is too relevant or pervasive
03:46:36 <jle`> i certainly haven't felt it
03:47:20 <wei2912> sometimes the only one good way is the best way
03:47:48 <wei2912> i'm interested to see where this leads though
03:47:55 <jle`> if you are convinced that anything that forces you to think differently than your previous training is not worth learning, then there really isn't much we can say
03:49:00 <jle`> switching to haskell can cause a little bit of disorientation, but if you try to speak japanese with the same intuition you learned from speaking english, it's unavoidable that you're going to have a tough time at least for a little bit
03:49:35 <BoR0> I don't know if GHC is slow or not, but it definitely generates large executables for me :)
03:50:02 <jle`> or, you can just try forcing english idioms into japanese and wonder why nobody in japan can understand you...
03:50:11 <jle`> "but they're more natural!"
03:50:40 <wei2912> just a question: it seems that in haskell, the idiomatic quicksort implementation while very clean seems to be less performant than implementations in imperative languages.
03:50:43 <jle`> humans obviously naturally think in english idiom and grammar...right?
03:50:54 <wei2912> in haskell, 2 list comprehensions are used
03:51:30 <wei2912> and lists are created, so it ends up taking extra space and doing an unnecessary pass
03:51:31 <artyomkazak> wei2912: because it's not a quicksort, only something which reminds a quicksort
03:51:40 <wei2912> and is no longer in-place
03:51:59 <quchen> wei2912: Normal quicksort sorts a vector/array, Haskell's example-quicksort works with a singly linked list.
03:52:05 <wei2912> artyomkazak: hmm.
03:52:34 <wei2912> quchen: i see
03:53:05 <quchen> Proper Quicksort in Haskell looks quite a lot like the imperative counterpart.
03:53:15 <wei2912> if this were the case, how'd an implementation of quicksort be written in haskell such that it is theoretically as performant as code in an imperative language?
03:53:22 <artyomkazak> wei2912: there are 2 well-known misleading examples of algorithms in Haskell: “quicksort” and “prime number sieve”. I think both are debunked on Haskellwiki somewhere
03:54:18 <gregnwosu> yeah i think they are written more in line with demostrating how concise fp can be
03:54:29 <wei2912> hmm
03:54:45 <wei2912> programming in haskell using imperative constructs seem very unidiomatic to me
03:55:01 <artyomkazak> you can see a quicksort for vectors here: http://stackoverflow.com/a/7833043/615030
03:55:13 <quchen> Some algorithms are just very imperative, such as Quicksort. I mean it's in-place so you have to have mutation.
03:55:39 <quchen> (Throwing imperative and mutable into the same basket here … yeah I know)
03:55:58 <dm3on> hey all, how OOP works in haskell ?
03:56:09 <rindolf> silver: I already had good luck with Python - I'm using mostly Perl 5, XHTML, XSLT, DocBook 5/XML, etc. though.
03:56:30 <Polarina> dm3on, generally, you do not use the object-oriented paradigm with Haskell.
03:56:41 <wei2912> rindolf: mind providing a few examples? it'd help to educate all of us
03:57:06 <rindolf> jle`: anyway, my previous experience was with BASIC, C, Perl 5, Lisp, Scheme, Python, and other languages, so I tend to blame Haskell.
03:57:36 <artyomkazak> wei2912: there also used to be a “true quicksort” in base libs (as the default implementation of sort), before it got replaced with mergesort. The original still lies commented in the source: http://hackage.haskell.org/package/base/docs/src/Data-List.html#sort
03:57:47 <rindolf> wei2912: there may be in my Project Euler repository - https://bitbucket.org/shlomif/project-euler
03:57:49 <quchen> "OOP in Haskell" comes up every now and then. Some people implement it as an exercise, some people say it's impossible. I think what's safe to say is that the OOP model doesn't fit Haskell very well and few people try actually applying it; the rest is just people talking about whether or not it's possible/viable.
03:59:08 <wei2912> also, what makes recursion in Haskell acceptable?
03:59:30 <wei2912> as opposed to the general consensus in other languages which is to avoid recursion due to the overhead involved
03:59:38 <MP2E> the evaluation model, mostly
03:59:41 <MP2E> there is no stack frame
03:59:53 <MP2E> also optimizations, though.
04:00:00 <silver> not relying on stack for function "calls" and a bit of TCO
04:00:14 <quchen> You should avoid bad recursion in any language. It's not true that recursion should be avoided in other languages.
04:01:08 <wei2912> i was talking about the case of critical performance code, btw
04:01:09 <BoR0> wei2912, recursion makes it easier to prove correctness
04:01:19 <gregnwosu> how can i get the maybe monad to return something else if one of its components resolves to nothing
04:01:41 <quchen> Even for performance-critical code, compilers are quite good at optimizing recursion to tight loops.
04:01:49 <MP2E> who is saying that recursion isn't fit for performance-critical code? It certainly is if it is used correctly
04:01:53 <wei2912> BoR0: agreed
04:01:53 <silver> gregnwosu, maybe you need Either?
04:02:10 <dibblego> gregnwosu: you mean "get the value out of the Maybe, unless it is Nothing, which case, this value (x)", then fromMaybe x
04:02:41 <silver> (instead of Maybe)
04:02:57 <gregnwosu> silver: yes perhaps either
04:03:10 <gregnwosu> dibblego: are you suggesting i use from maybe?
04:03:22 <dibblego> gregnwosu: I am trying to clarify your issue first
04:03:54 <tdammers> recursion is a bigger hurdle in languages that do create stack frames for all calls though
04:03:55 <gregnwosu> dibblego: in which case yes, i want an alternate value
04:04:10 <dibblego> > fromMaybe 7 Nothing -- gregnwosu
04:04:12 <lambdabot>  7
04:04:18 <dibblego> > fromMaybe 7 (Just 8) -- gregnwosu
04:04:20 <lambdabot>  8
04:04:21 <tdammers> recursing deeply in something like Python or PHP is simply not a great idea
04:04:22 <gregnwosu> thanks guys
04:04:45 <MP2E> fair enough
04:04:54 <fgc`> I also have beginner migivings from time to time. For example when I read about monad transformers I always get this feeling: "Monads are cool yay! but now I'll want to make this or that actual thing that should be trivial but requires this awkward way of composing stuff. I feel like having painted myself into a corner"
04:05:29 <SwashBuckla> @pl parseLevel ys = readMay =<< headMay ys
04:05:29 <lambdabot> parseLevel = (readMay =<<) . headMay
04:06:32 <wei2912> thanks for the advise
04:06:34 <wei2912> advice*
04:06:54 <nkar> is there a combinator that can help me to define 'f (Just t) = t; f Nothing = empty' in a more succinct way?
04:07:00 <quchen> fgc`: Yeah, unfortunately monads don't compose. Transformers is one way that's used to compose them (and certainly the most widely used one), but there are other approaches.
04:07:09 <quchen> nkar: fromMaybe empty
04:07:57 <quchen> fgc`: On the other hand, Applicatives *do* compose: Given Applicatives f and g, f (g a) is an Applicative too with pure = pure . pure and (<*>) = liftA2 (<*>)
04:08:20 <quchen> Well, f (g <arg>) is an Applicative
04:08:44 <quchen> In the libraries you can find that composition as Compose,  data Compose f g a = Compose (f (g a))
04:11:31 <saep> rindolf: I find Haskell performs quite well for project euler problems. I've completed the first 60 or so. The test-suite, which executes all problems and tests my prime sieves, finishes in a few seconds.
04:12:56 <fgc`> interesting. I sometimes shy away from trying stuff because I think I'd need to use transformers, but applicative might be enough.
04:14:40 <Aruro> why http://lpaste.net/112224 gives error "You need DeriveFunctor"?
04:15:39 <shiona> Aruro: because writing "deriving Functor" tells ghc to automatically derive the class
04:15:49 <ClaudiusMaximus> Aruro: "deriving Functor" isn't haskell2010, so you need the extension
04:15:56 <rindolf> saep: OK, I solved many more beyond 1-60.
04:16:05 <Aruro> why not?
04:16:15 <shiona> Just drop those two words and your manually written functor class instance will take over and the code should work
04:16:20 <Aruro> in haskell 2010 it is not possible at all?
04:17:02 <Aruro> would be nice to update this then http://en.wikibooks.org/wiki/Haskell/The_Functor_class#Introducing_Functor
04:17:04 <Cale> Aruro: Haskell 2010 has a really conservative set of features
04:17:10 <shiona> Aruro: at the moment you have both instruction to automatically derive the functor class, and a manually written one
04:17:38 <Cale> Aruro: Where do they use deriving Functor on that page?
04:17:48 <Aruro> what should i do to make that code work?
04:17:54 <gilligan-> Cale, just looking at the template haskell stuff you linked me to
04:17:57 <Cale> That code ought to work in H2010
04:18:14 <silver> remove "deriving Functor"
04:18:17 <Aruro> i have downloaded haskell just like month ago
04:18:33 <Cale> Aruro: There's no deriving Functor in the wikibook page.
04:18:33 <Aruro> it is not up to date?
04:18:45 <silver> Aruro, http://www.haskell.org/haskellwiki/Keywords#deriving
04:18:46 <gilligan-> Cale, I feel silly for asking, but given a 'Q Info' how the heck do I extract the Info from the Q monad? can't pattern match it or anything
04:19:10 <Aruro> ok ty i will try
04:20:07 <wei2912> what advantages could learning haskell give me?
04:20:10 <Cale> gilligan-: Ah, you need to run the Q action in a splice of some sort
04:20:25 <Aruro> ty removing deriving helped, indeed why did i need deriving if i introduced myself an instance of functor later, stupid :)
04:20:42 <Cale> gilligan-: I'll write an example of the sort of thing you might do...
04:20:52 <gilligan-> Cale, that'd be nice ;-)
04:23:03 <Aruro> wei2912 which advantages do you need?
04:24:34 <wei2912> Aruro: i'm just curious
04:24:43 <Cale> ghci> $(do info <- reify ''Maybe; litE (StringL (show info)))
04:24:43 <Cale> "TyConI (DataD [] Data.Maybe.Maybe [PlainTV a_1627398628] [NormalC Data.Maybe.Nothing [],NormalC Data.Maybe.Just [(NotStrict,VarT a_1627398628)]] [])"
04:24:43 <wei2912> it seems like haskell would help me think in different ways
04:24:56 <Cale> wei2912: sure
04:25:54 <Aruro> not just haskell any functional language
04:26:08 <Aruro> also there is ocaml and others
04:26:09 <Cale> Haskell is different from a lot of functional languages though.
04:26:27 <Cale> (It has lots of similarities too)
04:26:27 <Aruro> in what?
04:26:37 <Cale> Well, lazy evaluation takes getting used to. Type classes
04:26:45 <silver> purity
04:27:00 <Cale> Yeah, the fact that evaluation doesn't have any effects
04:27:23 <Aruro> it does if you use do :)
04:27:36 <Cale> Evaluating IO actions doesn't cause effects
04:27:38 <Xenasis> Is there any way to catch exceptions without the use of monads?
04:27:41 <Cale> Only executing them does
04:27:56 <dibblego> Xenasis: you mean without IO? No.
04:27:56 <Aruro> evaluation you wrote
04:28:00 <Cale> Xenasis: You must use IO actions specifically
04:28:22 <Xenasis> dribblego: Without monads at all - I don't care about IO in particular
04:28:23 <Xenasis> ah
04:28:25 <Xenasis> okay!
04:28:34 <Xenasis> *dibblego
04:28:49 <gilligan-> Cale, thank you. i'll have some reading up to do  ;)
04:29:03 <BoR0> @hoogle m a -> m b -> m (a, b)
04:29:06 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
04:29:06 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
04:29:06 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:29:07 <Cale> Aruro: There are two interleaved processes which take place while a Haskell program runs. There's evaluation, which refers to turning expressions into values for the purposes of pattern matching, and then there's execution, which refers to carrying out the instructions described by IO action values.
04:29:15 <dibblego> BoR0: liftA2 (,)
04:29:20 <BoR0> :t liftA2 (,)
04:29:21 <lambdabot> Applicative f => f a -> f b -> f (a, b)
04:29:25 <BoR0> neat :)
04:29:32 <dibblego> @type fzip
04:29:33 <lambdabot>     Not in scope: ‘fzip’
04:29:33 <lambdabot>     Perhaps you meant one of these:
04:29:33 <lambdabot>       ‘flip’ (imported from Data.Function),
04:29:34 <Aruro> yes cale but the purpose of any program is execution :)
04:29:41 <Aruro> haskell can do nothing about it
04:29:53 <Cale> Aruro: It's extremely valuable to know that evaluation has no effects
04:30:14 <Cale> in reasoning about what results and effects a given program will have
04:30:45 <Cale> You know that replacing some expression with one that has the same value won't change the meaning of the program.
04:31:22 <Cale> Which enables equational reasoning -- you can treat programs algebraically, making substitutions of equals for equals.
04:31:24 <Aruro> i value that effect but see it as cleanness it is not conceptual
04:31:40 <Aruro> you still have to think in paradigm of functions and types
04:31:50 <Cale> It's a big difference to how things are in ML
04:31:59 <danilo2> Hello! I just dioscovered that lenses are PURE EVIL. I spent hours to track a bug caused by how lenses are stupid. I would love to ask you If uis there **any way** to fix the following behaviour. I've got a simple code: http://lpaste.net/112230 After refactoring I changed some names and everythiong compiled and worked even if the name was not found in the datatype. Instead of reporting error, lenses used the monoid to insert empty v
04:32:23 <danilo2> Is there any way, to make lenses throwing error when field name is not matched instead of just hiding this from me and using monoid there?
04:32:54 <wei2912> danilo2: when i read the first sentence, i thought you were a preacher
04:32:55 <dibblego> that made my day :)
04:33:19 <wei2912> "PURE EVIL"
04:33:26 <artyomkazak> danilo2: your b isn't a lens, it's a traversal
04:33:36 <artyomkazak> use ^? instead of view
04:33:51 <danilo2> artyomkazak: I know it. Anyway, the example I showed should throw error and not output silently empty string ...
04:34:29 <Aruro> summarize in one word what is lense  :D
04:34:40 <Cale> Aruro: lens
04:34:54 <Aruro> it is tautology
04:35:00 <Aruro> a is a
04:35:02 <danilo2> artyomkazak: That makes no sense. Do you want me to use ^? to read the filds? So every field I would get in maybe ?
04:35:31 <Cale> danilo2: Yeah
04:35:41 <Cale> danilo2: That would be reasonable, given that some of your fields are missing :P
04:36:59 <Cale> danilo2: It's pretty awkward dealing with record types that have multiple cases with different fields in the first place. You usually don't just want your program to die. So dealing with Maybe values is probably better than worrying about accidentally triggering an error.
04:37:12 <danilo2> Cale: think about such use case - I'm using the names only when I'm sure they exist there. After refactoring the names are changed and then lens put empty strings instead of reporting error. I mean - Of course these fields in generall could be missing, but I'm using them after pattern matching
04:37:47 <artyomkazak> danilo2: I don't think it can be “fixed”, apart from stating it better in documentation that when some fields are missing, the generated accessor will be a traversal and so it might fail silently when using view (and when the field type happens to be a monoid)
04:38:50 <danilo2> artyomkazak: Cannot we make such behaviour as haskell defaults one when field is missing?
04:39:17 * hackagebot grid 7.6.5 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.5 (AmyDeBuitleir)
04:39:39 <bartavelle> it can be fixed
04:40:29 <bartavelle> if you have data Foo = Bar Int | Baz Qux, you can turn [Foo] into [Int] with `toListOf (folded . _Bar)`
04:40:40 <bartavelle> that proves you made sure you only have one type of stuff
04:40:41 <Cale> danilo2: The thing is, Haskell's default behaviour when a field is missing is usually very unhelpful
04:41:11 <bartavelle> you'd need refinement types I suppose to prove this while keeping the sum type
04:41:35 <danilo2> bartavelle: Cale: Its much better than this one. I prefer getting error than making the program decisions that are just irrelative to the problem
04:41:37 <Cale> I'm not sure what your real use case is, but I would probably refactor the types a bit so that you have a sum type where each of the constructors has just one field, and some separate record types.
04:42:37 <bartavelle> another way is to newtype the content of the field so that it has no Monoid instance, but that will probably bloat all your code
04:42:53 <artyomkazak> danilo2: if you really want it to error, use ^?! instead of view
04:44:12 <bartavelle> but yes, that's the kind of problem you get with lens
04:44:59 <bartavelle> I once used "traverse" instead of "both" on (a,a), without thinking twice about it. Obviously it only worked on the second field. Only noticed something was wrong by chance
04:46:05 <danilo2> artyomkazak: Ehh, right. I'm just thinking if it has any runtime overhead? Anyway, beware of the pure lens evil, that could appear suddenly after refactoring when you think you can just use lenses to make pattern matching look nicer! :> Thank you all for explanation :)
04:48:45 <artyomkazak> danilo2: surprisingly, no
04:48:53 <artyomkazak> I just checked with criterion
04:49:17 * hackagebot grid 7.6.6 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.6 (AmyDeBuitleir)
04:49:50 <danilo2> artyomkazak: Oh great to know, thank you! :)
04:50:47 <artyomkazak> danilo2: code: http://lpaste.net/112233, mean for lens variant is 50ns, for record – 42ns. But you should still benchmark your specific usecase
04:51:34 <artyomkazak> for instance, it might be that GHC is smart enough to optimise it here, but not in more complex cases
04:54:17 * hackagebot ghc-heap-view 0.5.2 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.5.2 (JoachimBreitner)
04:55:54 <SwashBuckla> how do you make unwords not add a space?
04:56:14 <ClaudiusMaximus> concat
04:58:28 <SwashBuckla> ClaudiusMaximus: thanks
05:31:28 <MagBo> Hey, people, I have two questions —
05:31:44 <mmachenry> We, collectively, have two answers.
05:31:49 <zq> the suspense is killing me at twice the rate
05:31:56 <mmachenry> zq, lol
05:32:38 <MagBo> I need a data structure that will hold String, String, Integer, (Data.Time.Clock.POSIX, Data.Time.Clock.POSIX)
05:33:01 <MagBo> what is the best way to do that?
05:34:02 <mmachenry> Basically, write "data MyStructure =" before what you already just wrote.
05:34:08 <mmachenry> And remove the commas.
05:34:35 <MagBo> mmachenry: but I need to have, erm, an n-tuple?
05:34:58 <MagBo> but ok
05:35:00 <mmachenry> MagBo, not really. You can make a new data type, that's not a tuple, but it's similar.
05:35:27 <MagBo> well, it's a *cough* type tuple, right?
05:35:27 <mmachenry> What's the name for this new type?
05:35:35 <MagBo> Activity
05:36:10 <BoR0> data Fullname = Fullname String String. data Twostrings = Twostrings String String. Twostring differs from Fullname, but (String, String) doesn't differ from (String, String)
05:36:21 <mmachenry> data Activity = Activity String String Integer (Data.Time.Clock.POSIX, Data.Time.Clock.POSIX)
05:36:46 <mmachenry> Something like that (though I don't know if those dates are valid I just copied that from you)
05:36:46 <spacekitteh> is there a cabal command when compiling a project to tell it to import something in every module by default?
05:37:38 <MagBo> The other question I have — I want to make a parser into this structure from a string. It will tokenize stuff with just words and then in one pass over [String] it will populate Activity
05:38:08 <lieven_> evenso record notation might be preferable if you have a lot of fields. otherwise you'll need to remember everywhere what the different Strings in it represent
05:39:21 <MagBo> mmachenry: ofc it should be POSIXTime  :)
05:40:15 <mmachenry> MagBo, you could possibly get lucky if you want to just derive Read.
05:41:05 <mmachenry> If you derive show you will see what the output looks like and then that exact same string as input will read as your type. That's an easy way to do it. If you're not happy with that, then lots of parsing options are available. Look into parsec.
05:41:26 <mmachenry> But parsing is hard, in any language, so take the easy way out whenever possible. :)
05:42:39 <MagBo> mmachenry: I'm erlang developer with a lot of industrial experience
05:42:45 <MagBo> but thatks for the heads-up.
05:43:30 <mmachenry> I like Erlang. I wish I knew it better.
05:44:04 <gcganley> message passing betweens machines and processes sounds wicked
05:44:19 * hackagebot creatur 5.6.6 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.6 (AmyDeBuitleir)
05:44:21 <mmachenry> MagBo, I think you want "data Activity = Activity String String Integer (POSIXTime, POSIXTime) deriving (Show,Read)" or something close.
05:44:32 <MagBo> mmachenry: you guys have Cloud Haskell which is beautiful
05:45:04 <mmachenry> MagBo: I *might* be able to make use of it some time soon. But yes, CloudHaskell learned from Erlang. I think the rest of the world will eventually have to.
05:45:18 <mmachenry> We're all using RabbitMQ now, as it is (the industry that is)
05:46:38 <MagBo> Syntax stuns me with Haskell, you have so much syntax.
05:47:53 <tdammers> MagBo: we do? I always thought Haskell had relatively small amounts of syntax
05:48:01 <tdammers> more than Lisp, but much less than, say, Python or C#
05:50:54 <MagBo> tdammers: and more than Erlang. Python and C# are out of question though, I don't know how people would learn these languages if their minds weren't affected by the mainstream paradigm.
05:51:38 <tdammers> Python is pretty straightforward... just doesn't scale at all, because beyond a few hundred SLOC you have absolutely no idea anymore what you are doing
05:51:56 <artyomkazak> we have lots of syntax things which people don't use often and so the majority of developers probably only know 50–70% of syntax
05:52:22 <artyomkazak> admittedly, most of them are only enabled by extensions
05:52:42 <Vyn> Hej, Twey
05:52:48 <Vyn> Er du her?
05:53:08 <silver> hurr durr
05:54:03 <MagBo> Anyway, I'll keep trying to implement what I was doing in Haskell.
05:54:17 <artyomkazak> but still: lambda case, multiway if, view patterns, some stuff about pattern guards, arrow notation, braces-and-semicolons (often tend to be forgotten about), tuple sections, syntax of import and export lists, etc.
05:54:41 <bernalex> Vyn: jeg er forvirret over at folk snakker skandinavisk i #haskell.
05:56:12 <gcganley> MagBo: so you work with Erlang, what made you interested in Haskell?
05:57:09 <Vyn> bernalex: I was looking for a Danish channel found an empty ##dansk registered by Twey
05:57:17 <MagBo> gcganley: I'm porting my non-intrusive performance tracker to something that compiles natively
05:57:22 <Vyn> Sorry, I meant ##danish
05:57:51 <gcganley> MagBo: Erlang doesnt compile to native?
05:57:57 <tdammers> "snakker" is a word?
05:58:00 <tdammers> cool.
05:58:01 <gcganley> MagBo: what is it hosted on?
05:58:03 <adamse> gcganley: erlang runs on a vm
05:58:08 <MagBo> ofc no :) that would very tricky. it's hosted on BEAM.
05:58:47 <gcganley> MagBo: BEAM? is there an article or wiki on it? I'm interested
05:59:50 <MagBo> There are talks by Joe...
05:59:54 <gcganley> MagBo: im interested because the concurency in Erlang has always bewildered me
06:00:20 <MagBo> Let me link you an article by Jesper about schedulers
06:00:41 <mmachenry> gcganley: Have you ever used an AMPQ?
06:00:42 <MagBo> http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html
06:01:09 <gcganley> mmachenery: never heard of it but im guessing its a message passing style
06:01:16 <MagBo> This is a Tl;Dr :)
06:01:34 <gcganley> MagBo: thanks, i'll read that on my break
06:01:56 <gcganley> MagBo: do you have a blog or a place you post?
06:03:49 <MagBo> gcganley: I had j.memorici.de
06:04:04 <MagBo> now I'm playing with medium.com
06:04:23 <gcganley> MagBo: dutch or german... i forget that extenstion
06:04:36 <gcganley> s/forget/forgot
06:05:06 <MagBo> but looking forward to removing all my stuff from the clearnet
06:09:18 <MagBo> gcganley: German, but the server is in Latvia.
06:15:48 <mmachenry> gcganley: Are you in Germany?
06:16:13 <mmachenry> I'm in Berlin.
06:24:28 <gcganley> mmachenry: oh god no im near Boston, MA
06:24:38 <SwashBuckla> is there a `maxWith` function that gives you the maximum given some predicate? A synonym in python is the function `max(list, key=len)`
06:25:07 <gcganley> @src max
06:25:08 <lambdabot> max x y = if x <= y then y else x
06:25:52 <SwashBuckla> ah good old hoogle
06:25:52 <SwashBuckla> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:maximumBy
06:25:56 <gcganley> :t max
06:25:58 <lambdabot> Ord a => a -> a -> a
06:27:06 <MagBo> Hah, we were writing hoogle for Erlang for Spawnfest 2012
06:27:11 <MagBo> Got third place for that :)
06:27:31 <gcganley> MagBo: is erlang as heavily typed as haskell is?
06:28:13 <MagBo> Erlang is sooo untyped
06:28:21 <MagBo> disgustingly untyped.
06:28:29 <gcganley> MagBo: worse then python?
06:28:35 <MagBo> Lol no
06:28:48 <MagBo> However we have something called type annotations that are — sadly — optional.
06:29:04 <gcganley> MagBo: so erlang hoogle would only be able to look up by name but not type?
06:29:10 <tdammers> lol, type annotations are optional in Haskell too :D
06:29:22 * hackagebot extra 0.2 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.2 (NeilMitchell)
06:29:38 <gcganley> tdammers: but i think hes saying that there isnt much type inference in erlang
06:29:58 <tdammers> yeah, I know
06:30:03 <tdammers> erlang is dynamically typed
06:30:04 <MagBo> tdammers: bwahaha, sadly in erlang annotations are the only way to tell external tools like dialyzer the types
06:30:11 <MagBo> acceptable types, that is.
06:30:18 <tdammers> still better than python
06:30:53 <tdammers> the only way python can tell external tools whether a certain type is acceptable is by not throwing a TypeError when you run it
06:31:00 <gcganley> MagBo: Clojure has something similar with completely optional type signitures but was never intended to have it, all done with macros and reader hacks
06:31:12 <MagBo> gcganley: so basically we were searching all the annotated code
06:31:16 <MagBo> and it worked awesomely!
06:31:23 <tdammers> in this regard, even PHP is slightly better
06:31:33 <tdammers> it has type hints built into the language
06:31:36 <gcganley> MagBo: well thats nice, do you annotate all your erlang code?
06:31:52 <MagBo> I annotate all the Erlang code I plan to re use.
06:31:53 <gcganley> MagBo: how big a deal is it to annotate in the erlang community
06:31:59 <tdammers> it's just weird that they only go in certain places, and you can only hint class types, not any built-in ones
06:32:18 <mmachenry> gcganley: Ha, I'm from Boston.
06:32:43 <gcganley> mmachenery: im on the cape but i always say boston, most people know boston
06:33:05 <joyfulmantis> is F a -> F b the same as F (a -> b) ?
06:33:06 <mmachenry> gcganley: My grandparents live on the cape. I've spent a lot of time there.
06:33:24 <gcganley> no
06:33:27 <opqdonut> joyfulmantis: no: consider [a] -> [a] vs [a -> a]
06:33:38 <opqdonut> joyfulmantis: a function transforming a list vs. a list of functions
06:34:01 <gcganley> doe [a -> a] type check?
06:34:01 <MagBo> gcganley: people are talking about annotating all their code but you know how it goes.
06:34:25 <gcganley> MagBo: if they dont have to do extra work they will avoid it at all costs
06:34:31 <mmachenry> [a -> a] is fine, yeah.
06:34:35 <mmachenry> :t [id]
06:34:37 <lambdabot> [a -> a]
06:34:40 <MagBo> some people don't even know how to use dialyzer
06:34:50 <gcganley> mmachenery: cool, thats new
06:35:13 <mmachenry> Yeah you can ask LambdaBot the type of lots of stuff or to evaluate stuff.
06:35:57 <gcganley> i knew that i just thought functions had to be in parens
06:36:08 <mmachenry> gcganley: Ever go to the Boston Haskell meetups?
06:36:18 <gcganley> mmachenery: I WANT TO!
06:36:25 <gcganley> mmachenery: but sadly no
06:36:48 <gcganley> mmachenery: i only got into haskell really hard core in the last 4 months so i missed hac boston
06:37:00 <mmachenry> They are great, actually. Boston has some really big Haskellers so the discussion is usually pretty great.
06:37:28 <gcganley> i know we have edwardk but i dont know about anyone else really...
06:37:59 <joyfulmantis> thanks opqdonut!
06:38:00 <gcganley> and his cat theory makes my head spin
06:38:01 <edwardk> the next meetup should be fun
06:38:09 <gcganley> edwardk: oh hello there
06:38:18 <edwardk> i'm going to pick a fight with everyone who implements something they call "typeclasses" other than haskell ;)
06:38:39 <mmachenry> Yeah he's mostly who I'm talking about but the guy who wrote I think UrWeb or I could be mistaken
06:39:19 <mmachenry> Also I think Paul Chiusano who blogs about FP and is pretty good.
06:39:44 <gcganley> edwardk: if memory serves they are every third wensday no?
06:39:48 <mmachenry> There are a lot of really bright scientists using Haskell for their code instead of Python+SciPy as well.
06:40:04 <mmachenry> gcganley: They are monthly on Wednesday.
06:40:08 <tdammers> edwardk: what about something that is a superset of Haskell typeclasses?
06:40:13 <mmachenry> First Wednesday I think.
06:40:14 <gcganley> i always mess up wendnesday
06:40:22 <Rembane> mmachenry: Is there a Haskell replacement for scipy?
06:41:18 <edwardk> tdammers: the stuff that purports to offer a superset is mostly 'hey you can pass anything you want here'
06:41:25 <mmachenry> Rembane: Well… Haskell itself compiles to really efficient code. SciPy is mostly a response to the fact that writing any kind of numerical computing in a tight loop in pure Python will be terribly slow so it's written in C.
06:41:32 <edwardk> tdammers: and that is precisely the thing i'm objecting to in the first half of the talk
06:42:17 <mmachenry> Rembane: There are a decent number of libraries in Haskell for math and science. I can't say I know if there are as many or if Haskell is missing anything significant compared to SciPy. But in general, Haskell itself is a decent replacement.
06:42:26 <tdammers> ah, no, I meant superset more along the lines of being more expressive
06:44:31 <MagBo> I'm sorry, another stupid syntactical question —
06:44:31 <MagBo> getCurrentActivity = (_, Just h1, _, _) <- createProcess (proc "xwm" []){ std_out = CreatePipe } hGetContents h1 >>= (\s -> return $ p s)
06:44:44 <Rembane> mmachenry: Cool, then I'll look more into Haskell for those areas! Thanks.
06:45:00 <MagBo> What do I put between createPipe } and hGetContents to get a sequential computation?
06:45:20 <gcganley> whats the type of that function
06:45:27 <gcganley> is it just IO ()
06:45:38 <MagBo> It's IO Activity
06:45:48 <gcganley> oh no pipes im out of my element
06:46:14 <MagBo> brb 3 minutes
06:48:35 <RchrdB> MagBo: hmm? hGetContents will read the output from xwm lazily.
06:48:45 <RchrdB> What do you mean by a "sequential computation"?
06:49:00 <gcganley> does he mean literally sequence?
06:49:09 <gcganley> :t sequence
06:49:09 <RchrdB> oh wait
06:49:11 <lambdabot> Monad m => [m a] -> m [a]
06:49:54 <MagBo> re: lazily -- I don't think that that's a problem
06:50:03 <RchrdB> cool, just a sec
06:50:34 <MagBo> because I'll use getCurrentActivity under IO from main of the program that will use it
06:50:35 <gcganley> MagBo: just throwing `sequence` out there
06:50:40 <gcganley> :t sequence
06:50:41 <lambdabot> Monad m => [m a] -> m [a]
06:51:27 <gcganley> :t hGetContents
06:51:28 <lambdabot>     Not in scope: ‘hGetContents’
06:51:28 <lambdabot>     Perhaps you meant one of these:
06:51:28 <lambdabot>       ‘BSC.hGetContents’ (imported from Data.ByteString.Char8),
06:51:39 <gcganley> :t BSC.hGetContents
06:51:41 <lambdabot> GHC.IO.Handle.Types.Handle -> IO BSC.ByteString
06:51:44 <phz> hey
06:51:50 <gcganley> hello
06:52:15 <RchrdB> MagBo: http://lpaste.net/112236 <- you're just after how to work 'do' notation and the '>>=' and '>>' combinators right?
06:53:10 <RchrdB> MagBo: is that what you were after, please?
06:53:15 <MagBo> let me see
06:55:04 <MagBo> RchrdB: can you please explain a little bit <- and -> notation
06:55:11 <MagBo> when it gets to pattern matching?
06:55:54 <RchrdB> MagBo: which one do you want explained first, the do-notation or the bind-notation one?
06:56:04 <MagBo> bind pleaes
06:56:41 <RchrdB> MagBo: ah. Okay. You can pattern match in the definition of a lambda (anonymous function)
06:57:02 <RchrdB> > (\x -> x) [1, 2]
06:57:06 <lambdabot>  [1,2]
06:57:09 <RchrdB> > (\(x:xs) -> x) [1, 2]
06:57:13 <lambdabot>  1
06:57:34 <MagBo> understood, but in bind notation we have "<-". what does it mean?
06:57:37 <RchrdB> though it's limited to only one case... so you usually want an explicit case statement instaed.
06:57:53 <RchrdB> No, in the first one, in do-notation, you have the left arrow `<-`
06:58:11 <MagBo> oh right, but we can do that in ghci without do-notation
06:58:18 <RchrdB> the other one justs uses bind (>>=) and lambdas
06:58:23 <MagBo> can't we? /me is confused
06:58:25 <MagBo> right.
06:58:30 <RchrdB> in GHCi, you're sort of in do-notation by default.
06:58:41 <MagBo> so that's the very same <- as in do-notation
06:58:43 <MagBo> oh damn
06:58:45 <MagBo> thanks!
06:58:51 <MagBo> yeah, I understand -> ofv
06:58:53 <MagBo> ofc*
06:59:17 <MagBo> right, and one more small thing -- {}-notation at createProcess call
06:59:30 <RchrdB> MagBo: that's record syntax.
06:59:38 <MagBo> right, thanks!
06:59:56 <MagBo> do I want to make my Activity as record?
07:00:02 <MagBo> I'll think about it later.
07:00:13 <te-x> Hi, can someone explain me the difference between function composition ( . ) and function application with $ ? I "kind" of get it and I usually get it right while programming, bue I'm still not exactly sure when to use or the other, and why
07:00:15 <MagBo> Let me now think about your paste a little
07:00:28 <RchrdB> if it's useful to you to you to be able to extract and update parts of it with record syntax instead of having to match the entire value, yes
07:00:33 <te-x> or point me to some article to read
07:00:36 <MagBo> @src $
07:00:36 <lambdabot> f $ x = f x
07:00:39 <MagBo> @src .
07:00:40 <lambdabot> (f . g) x = f (g x)
07:00:44 <MagBo> here you go, te-x
07:01:01 <te-x> yeah, I know that
07:01:16 <te-x> but f $ g x = f . g $ x
07:01:17 <te-x> right?
07:01:22 <BoR0> > putStrLn unwords ["hey", "what's", "up"] -- syntax error, passing 2 params to putStrLn
07:01:24 <lambdabot>  Couldn't match expected type ‘[[GHC.Types.Char]] -> t’
07:01:24 <lambdabot>              with actual type ‘GHC.Types.IO ()’Couldn't match type ‘[GHC.Base...
07:01:24 <lambdabot>                with ‘[GHC.Types.Char]’
07:01:24 <lambdabot>  Expected type: GHC.Base.String
07:01:24 <lambdabot>    Actual type: [GHC.Base.String] -> GHC.Base.String
07:01:26 <BoR0> > putStrLn $ unwords ["hey", "what's", "up"] -- OK
07:01:30 <lambdabot>  <IO ()>
07:01:39 <RchrdB> te-x: yes, by their definitions.
07:01:50 <MagBo> RchrdB: thanks
07:02:05 <MagBo> I get it, I think that it's how I'd like to connect those invocations for
07:02:08 <MagBo> for now*
07:02:40 <MagBo> RchrdB: that was very hand-holdish
07:02:45 <Walther> I've seen cases where foo . bar x --doesn't work, but foo $ bar x --works
07:02:45 <MagBo> thank you so much <3
07:02:58 <albeit_> If I have a variable length strict bytestring between 4 and 10 bytes long, what would be the most efficient way to uniquely Int-ify it? Basically need to convert it to a unique key for an IntMap
07:03:05 <albeit_> (Thought not very dense key set... so collisions are extremely unlikely. Max 200 keys)
07:03:07 <Walther> (and am still a bit confused, why)
07:03:20 <xplat> albeit_: you need guaranteed uniqueness?
07:03:26 <RchrdB> te-x: the stylistic convention that a large chunk of the community happens to have settled on is to write "f (g (h (i (x))))" as "f . g . h . i $ x" rather than "f $ g $ h $ i $ x".
07:03:48 <albeit_> xplat: Let's say yes
07:04:01 <RchrdB> Walther: "foo . bar x" parses as "(.) (foo) (bar x)", where I think you wanted "((.) foo bar) x"
07:04:04 <xplat> albeit_: that makes it a lot harder
07:04:33 <xplat> it would of course be easy to make it into a unique Integer
07:04:44 <Walther> RchrdB: it may be that when i've tried to use "foo . bar x" i should've used "foo . bar $ x" ?
07:04:57 <RchrdB> Walther: yeah if you wanted it to parse that way.
07:04:58 <etandel> Walther: function application is the highest precedence, so what RchrdB then
07:05:14 <etandel> you can also (foo . bar) x as well
07:05:23 <albeit_> xplat: The unique Integer I assume I would just interpret the bytestring as an Integer, yeah?
07:05:28 <Walther> > double . double 2 where double x = 2*x
07:05:30 <lambdabot>  <hint>:1:19: parse error on input ‘where’
07:05:44 <xplat> albeit_: yeah
07:05:47 <Walther> > let double x = 2*x in double . double 2
07:05:50 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
07:05:51 <lambdabot>    arising from a use of ‘M380762400116733675026024.show_M3807624001167336750...
07:05:51 <lambdabot>  The type variable ‘a0’ is ambiguous
07:05:51 <lambdabot>  Note: there are several potential instances:
07:05:51 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:05:56 <xplat> albeit_: how often does the key set change?
07:05:59 <Walther> > let double x = 2*x in double . double $ 2
07:06:01 <lambdabot>  8
07:06:04 <Walther> ha!
07:06:05 <te-x> can I read the $ as "wait for whats in front of this and then cotinue"? Is this what it does? (I know that it's just percendence)
07:06:05 <Walther> thanks
07:06:23 <albeit_> xplat: Not very often at all. It will be quickly built from an outside source when the program is first run (keys unknown until source delivers them), but after that will hardly change
07:06:30 <RchrdB> te-x: I read it as "call the function to me left, with the argument to my right"
07:06:31 <Walther> ...why is that $ required though?
07:06:52 <xplat> albeit_: the keyword you want to look at is 'perfect hashing'
07:07:00 <RchrdB> Walther: precedence. Otherwise you're trying to compose the function (double) with the function (double 2)
07:07:00 <BoR0> te-x, $ pushes everything to the right as a single argument. so f $ a b c would actually mean f (a b c) and not f a b c (in the former case we are applying one param to f, in the latter we are applying 3)
07:07:07 <artyomkazak> Walther: because function application binds tighter than (.)
07:07:08 <keko_> Walther: function application binds tighter than .
07:07:17 <Walther> artyomkazak: keko_: rrrright
07:07:28 <xplat> albeit_: (if it was changing often, otoh, i would have told you 'don't use an IntMap'
07:07:29 <albeit_> xplat: Thanks
07:07:33 <Walther> thanks!
07:07:44 <keko_> you could also do (double . double) 2
07:08:15 <te-x> so I should always use (.), and $ only if necessary
07:08:33 <xplat> double . double $ 2 -- il and trouble
07:10:57 <BoR0> te-x, as with everything else :)
07:11:03 <albeit_> xplat: Hmm... given I'm on a 64-bit system, and most keys <= 8 bytes, do you think it would be a good idea to just xor the first 8 bytes with the following 8 bytes (if they exist in the bytestring)? It would be quick, but would possibly allow collissions... though the chance of collission would be so small
07:11:22 <te-x> yeah right, that's not what I meant :P
07:11:26 <BoR0> Haskell's function application is left-associative by default, so f a b c is actually (((f a) b) c). when we want to change that, we use $
07:11:35 <joseph07> te-x: Additionally sometimes you actually want to use function application as a function
07:11:38 <te-x> I was saying that I should prefer . to $, if possible
07:12:11 <xplat> albeit_: if you can think of a way to handle collisions, then that's fine.  but never allow a case you don't have a way of handling.
07:12:26 <te-x> like the "map ($ 3)  [(2*) (4+)] example on the LYAH?
07:12:38 <joseph07> te-x: yup
07:12:40 <albeit_> xplat: Well since new keys are added so infrequently, the cost to check if a new key already exists should be small in the grand scheme of things I think
07:12:40 <vanila> te-x, it's better to write  f . g . h $ x  than f $ g $ h $ x
07:13:11 <vanila> that's because . is associative, so it's nicer to work with, let's you split things up more easily
07:13:13 <xplat> albeit_: sure, but what do you do if it does already exist?
07:13:40 <albeit_> xplat: Figure out a plan B ;)
07:13:49 <te-x> ok
07:13:53 <te-x> thanks for the help ;)
07:14:09 <kgadek> hi. searching for papers on implementing multi-param typeclasses. Any pointers?
07:17:05 <xplat> albeit_: whenever you have a program that accepts input, you have to think security, i'm just saying.  whatever way you choose of handling the collisions shouldn't hurt anyone who doesn't have power over choosing the keyset that caused them, and if there are constraints that they have that don't let them change the keyset easily, shouldn't hurt them either
07:29:25 * hackagebot islink 0.1.0.0 - Check if an HTML element is a link  http://hackage.haskell.org/package/islink-0.1.0.0 (MariosTitas)
07:31:02 <phz> is arrow notation widely used?
07:31:09 <phz> it sounds a bit cryptic
07:32:15 <gcganley> phz: from what I gather its not used much
07:32:39 <gcganley> show ip route
07:33:17 <phz_> yeah, sounds a bit hard to follow :D
07:35:27 <gcganley> phz_: id learn just so you can understand it if you ever encounter it but no its not widely used much
07:35:39 <phz_> ok
07:35:56 <phz_> I’m looking for a way to duplicate input, passing it to a function, and leaving it alone
07:36:11 <phz_> foo :: (a -> b) -> a -> (a,b)
07:36:31 <phz_> foo f x = (x, f x)
07:36:33 <gcganley> what do you mean 'duplicate'
07:36:38 <gcganley> like repeat?
07:36:54 <phz_> pass it along the computation it’s being fed with
07:37:08 <gcganley> :t (>>>)
07:37:10 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:37:12 <gcganley> :t (arr)
07:37:13 <lambdabot> Arrow a => (b -> c) -> a b c
07:37:22 <gcganley> :t (first)
07:37:23 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
07:37:25 <phz_> no no
07:37:26 <phz_> :D
07:37:29 <phz_> I know all of that
07:37:41 <gcganley> phz_: oh ok lol
07:37:45 <phz_> I implemented the function this way:
07:38:01 <phz_> foo f x = fmap (x,) (f x)
07:38:04 <phz_> f is monadic in my case
07:38:15 <phz_> maybe there’s a simpler way to write that
07:38:18 <xplat> :t (>>= (,))
07:38:19 <lambdabot> (b -> a) -> b -> (a, b)
07:38:30 <phz_> oh yes
07:38:35 <phz_> function as monad
07:38:38 <xplat> :t (>>= flip (,))
07:38:39 <phz_> it’s always getting me
07:38:40 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
07:38:43 <gcganley> makes sense
07:38:57 <phz_> thank you :)
07:39:05 <gcganley> but how about this
07:39:12 <gcganley> :t (=<< (,)
07:39:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:39:15 <gcganley> crap
07:39:21 <gcganley> :t (=<< (,))
07:39:23 <lambdabot> ((b1 -> (a, b1)) -> a -> b) -> a -> b
07:39:29 <gcganley> oh
07:39:36 <gcganley> that didnt do what i thought it would
07:39:46 <gcganley> :t (=<<)
07:39:47 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:39:51 <phz_> :t ((,) =<<)
07:39:52 <lambdabot> (b -> a) -> b -> (a, b)
07:40:00 <gcganley> ah
07:40:02 <gcganley> woops
07:40:08 <gcganley> right thought though lol
07:40:12 <gcganley> @src =<<
07:40:12 <lambdabot> f =<< x = x >>= f
07:40:21 <phz_> so hm
07:40:23 <phz_> I can do
07:40:26 <gcganley> just so you dont need flip
07:40:31 <phz_> mapM (f >>= (,))
07:40:41 <phz_> that’s so fu*** brilliant :D
07:41:11 <gcganley> :t mapM (f >>= (,))
07:41:12 <lambdabot> (FromExpr a, Show b, Monad ((,) a)) => [b] -> (a, [b])
07:41:49 <xplat> :t mapM ((f :: Expr -> Expr) >>= (,))
07:41:51 <lambdabot>     No instance for (Monad ((,) Expr)) arising from a use of ‘mapM’
07:41:51 <lambdabot>     In the expression: mapM ((f :: Expr -> Expr) >>= (,))
07:42:11 <phz_> :t mapM (print >>= (,)) [1..10]
07:42:12 <lambdabot>     Could not deduce (Monad ((,) (IO ()))) arising from a use of ‘mapM’
07:42:12 <lambdabot>     from the context (Show b, Num b, Enum b)
07:42:13 <lambdabot>       bound by the inferred type of
07:42:49 <gcganley> :t mapM
07:42:50 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:42:58 <gcganley> :t (print >>= (,))
07:43:00 <lambdabot> Show a => a -> (IO (), a)
07:43:04 <phz_> :t map (print >>= (,)) [1..10]
07:43:06 <lambdabot> (Show a, Num a, Enum a) => [(IO (), a)]
07:43:10 <phz_> that!
07:43:19 <phz_> :t map (print >>= flip (,)) [1..10]
07:43:20 <gcganley> lol
07:43:21 <lambdabot> (Show a, Num a, Enum a) => [(a, IO ())]
07:43:25 <phz_> perfect :)
07:43:33 <gcganley> not yet
07:43:52 <gcganley> :t map (print =<< (,)) [1..10]
07:43:54 <lambdabot>     Couldn't match expected type ‘a0 -> b’ with actual type ‘IO ()’
07:43:54 <lambdabot>     In the first argument of ‘map’, namely ‘(print =<< (,))’
07:43:54 <lambdabot>     In the expression: map (print =<< (,)) [1 .. 10]
07:44:11 <gcganley> woops
07:44:13 <gcganley> one sec
07:44:16 <gcganley> let me boot ghci
07:44:25 * hackagebot base-prelude 0.1.6 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.6 (NikitaVolkov)
07:44:33 <phz_> no actually
07:44:41 <phz_> I won’t get anything from that
07:44:46 <phz_> I need to use sequence
07:44:56 <phz_> hm
07:45:02 <phz_> sequence . fmap sequence then!
07:45:16 <phz_> :t sequence . fmap sequence $ map (print >>= flip (,)) [1..10]
07:45:17 <lambdabot>     Couldn't match type ‘(a0, IO ())’ with ‘[m a]’
07:45:17 <lambdabot>     Expected type: IO () -> a0 -> [m a]
07:45:18 <lambdabot>       Actual type: IO () -> a0 -> (a0, IO ())
07:45:33 <phz_> :t sequence . map (fmap sequence $ map (print >>= flip (,)) [1..10]
07:45:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:45:35 <xplat> :t mapM (print >>= (<<).return)
07:45:36 <lambdabot>     Not in scope: ‘<<’
07:45:36 <lambdabot>     Perhaps you meant one of these:
07:45:37 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
07:45:40 <phz_> :t sequence . map (fmap sequence) $ map (print >>= flip (,)) [1..10]
07:45:41 <lambdabot>     Couldn't match type ‘IO ()’ with ‘[m a]’
07:45:41 <lambdabot>     Expected type: IO () -> a1 -> (a1, [m a])
07:45:41 <lambdabot>       Actual type: IO () -> a1 -> (a1, IO ())
07:45:49 <phz_> ok, I’ll stop now
07:46:04 <gcganley> no we need more lambdabot spam
07:47:06 <phz_> I can simply zip listOfStuff . sequence $ mapM f listOfStuff
07:47:19 <phz_> some kind of stuff like that
07:47:57 <phz_> :t let l = [1..] in fmap (zip l) . sequence $ mapM print l
07:47:59 <lambdabot>     Couldn't match type ‘IO’ with ‘[]’
07:47:59 <lambdabot>     Expected type: a0 -> [()]
07:47:59 <lambdabot>       Actual type: a0 -> IO ()
07:49:41 <phz_> :t let l = [1..] in fmap (zip l) $ mapM getLine l
07:49:43 <lambdabot>     Couldn't match expected type ‘a0 -> f b’
07:49:43 <lambdabot>                 with actual type ‘IO String’
07:49:43 <lambdabot>     In the first argument of ‘mapM’, namely ‘getLine’
07:49:51 <phz_> come on…
07:50:11 <phz_> :t let l = [1..] in fmap (zip l) $ mapM print l
07:50:12 <lambdabot> (Num a, Enum a) => IO [(a, ())]
07:50:29 <phz_> a bit silly, but it’ll make it
07:50:45 <gcganley> phz_: what are we trying to do again i've forgotten
07:50:59 <gcganley> list of computation with the original input?
07:51:05 <phz_> x -> f (x, f x)
07:51:09 <phz_> + ->
07:51:14 <phz_> x -> f -> (x, f x)
07:51:30 <phz_> which is (>>= flip (,))
07:51:47 <gcganley> :t ((,) =<<)
07:51:49 <lambdabot> (b -> a) -> b -> (a, b)
07:51:52 <gcganley> that?
07:52:00 <phz_> almost
07:52:02 <Haskellfant> I've got a question relating stackage: Only the actual maintainers are supposed to add their packages, right? So I should tell them to do so?
07:52:05 <phz_> using your function
07:52:07 <phz_> it’d be:
07:52:23 <phz_> :t swap . ((,) =<<)
07:52:24 <lambdabot>     Couldn't match type ‘(a, b)’ with ‘b0 -> (a1, b0)’
07:52:24 <lambdabot>     Expected type: a1 -> (a, b)
07:52:24 <lambdabot>       Actual type: a1 -> b0 -> (a1, b0)
07:52:31 <gcganley> :t swap
07:52:32 <lambdabot> (a, b) -> (b, a)
07:52:37 <phz_> oops :D
07:52:39 <phz_> well
07:52:50 <phz_> I want the value in the left part
07:52:57 <gcganley> oh ok
07:53:04 <phz_> another simple way of doing that is through fmap and tuple section
07:53:22 <xplat> :t mapM (print >>= flip ((<*) . return))
07:53:24 <lambdabot> Show a => [a] -> IO [a]
07:53:57 <gcganley> :t seqence
07:53:58 <lambdabot>     Not in scope: ‘seqence’
07:53:58 <lambdabot>     Perhaps you meant one of these:
07:53:58 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
07:54:02 <gcganley> :t sequence
07:54:03 <xplat> it was hard to write, it should be hard to read!
07:54:03 <lambdabot> Monad m => [m a] -> m [a]
07:54:12 <phz_> xplat: :D
07:54:25 <phz_> I think sequence should be called collect
07:54:25 <gcganley> :t <*
07:54:26 <lambdabot> parse error on input ‘<*’
07:54:28 <phz_> or that kind of stuff
07:54:32 <gcganley> :t (<*)
07:54:33 <lambdabot> Applicative f => f a -> f b -> f a
07:54:40 <gcganley> :t (>>)
07:54:41 <lambdabot> Monad m => m a -> m b -> m b
07:55:21 <xplat> :t mapM $ \x -> do { print x; return x }
07:55:22 <lambdabot> Show b => [b] -> IO [b]
07:55:35 <gcganley> mapM (print >>= (>> . return))
07:56:20 <gcganley> :t mapM (print >>= (flip >>))
07:56:21 <lambdabot>     Couldn't match type ‘(a -> b1 -> c) -> m b’ with ‘IO ()’
07:56:21 <lambdabot>     Expected type: (a -> b1 -> c) -> (a -> b1 -> c) -> m b
07:56:21 <lambdabot>       Actual type: (a -> b1 -> c) -> IO ()
07:56:45 <phz_> xplat: :)
07:56:50 <phz_> print x; return x
07:56:55 <phz_> there’s a nice pattern for that:
07:57:03 <phz_> print >> return
07:57:16 <phz_> :t print >> return
07:57:18 <lambdabot> (Show a, Monad m) => a -> m a
07:57:39 <gcganley> @src >>
07:57:39 <lambdabot> m >> k = m >>= \_ -> k
07:58:27 <xplat> :t mapM . runReaderT (print >> return)
07:58:28 <lambdabot>     Couldn't match expected type ‘ReaderT a ((->) a3) a0’
07:58:28 <lambdabot>                 with actual type ‘a1 -> IO ()’
07:58:28 <lambdabot>     Probable cause: ‘print’ is applied to too few arguments
07:58:37 <gcganley> :t runReaderT
07:58:38 <lambdabot> ReaderT r m a -> r -> m a
07:59:13 <phz_> :t runReaderT . mapM (print >> return)
07:59:14 <lambdabot> (Show b, Monad m) => [b] -> r -> m [b]
08:00:03 <xplat> :t mapM . runReaderT ((read >>= print) >> read)
08:00:05 <lambdabot>     Couldn't match expected type ‘ReaderT a ((->) a3) a0’
08:00:05 <lambdabot>                 with actual type ‘String -> a1’
08:00:05 <lambdabot>     Probable cause: ‘read’ is applied to too few arguments
08:00:09 <gcganley> so the original looks like fmap (,x) (f x) no?
08:00:23 <xplat> :t mapM . runReaderT ((read >>= lift print) >> read)
08:00:24 <lambdabot>     Couldn't match expected type ‘ReaderT a ((->) a5) a1’
08:00:24 <lambdabot>                 with actual type ‘String -> a2’
08:00:24 <lambdabot>     Probable cause: ‘read’ is applied to too few arguments
08:00:35 <xplat> :t mapM . runReaderT ((read >>= lift . print) >> read)
08:00:37 <lambdabot>     Couldn't match type ‘IO a0’ with ‘a4 -> m b’
08:00:37 <lambdabot>     Expected type: a -> a4 -> m b
08:00:37 <lambdabot>       Actual type: a -> IO a0
08:01:03 <xplat> i give up on that one :)
08:01:13 <phz_> :t fmap <$> zip <*> mapM print
08:01:14 <lambdabot> Show a => [a] -> IO [(a, ())]
08:01:17 <phz_> :)
08:01:21 <phz_> even simplier
08:01:32 <phz_> :t fmap <$> zip <*> mapM f
08:01:33 <lambdabot> (FromExpr (f b), Show a, Functor f, Monad f) => [a] -> f [(a, b)]
08:01:36 <gcganley> :t fmap <$>
08:01:37 <phz_> :)
08:01:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:01:47 <gcganley> :t (fmap <$>)
08:01:49 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
08:01:54 <phz_> gcganley: I’m using function as applicative functor
08:02:11 <gcganley> phz_: ik but i thought you wanted to be monadic
08:02:18 <phz_> it is
08:02:20 <phz_> see the type
08:02:24 <phz_> :t fmap <$> zip <*> mapM print
08:02:25 <lambdabot> Show a => [a] -> IO [(a, ())]
08:02:41 <phz_> it’s even better
08:02:42 <gcganley> well due to the applicative-monad yes i guess it is
08:02:43 <phz_> it’s applicative
08:02:51 <phz_> perfect to me :)
08:02:55 <gcganley> cool
08:02:58 <gcganley> so all done?
08:03:00 <phz_> yep
08:03:22 <phz_> however
08:03:28 <phz_> fmap <*> zip <*> mapM f
08:03:40 <phz_> if you don’t know functor nor applicative functor
08:03:46 <phz_> this sounds REALLY weird :D
08:04:00 <phz_> <$> *
08:04:01 <phz_> not <*>
08:04:06 <phz_> fmap <$> zip <*> mapM f
08:04:21 <gcganley> isnt <$> the same type as fmap?
08:04:21 <phz_> this is actually pretty elegant to me
08:04:25 <gcganley> :t fmap
08:04:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:04:28 <gcganley> :t <$>
08:04:29 <phz_> it’s not the same type
08:04:29 <lambdabot> parse error on input ‘<$>’
08:04:32 <phz_> it’s the same function
08:04:36 <gcganley> :t (<$)
08:04:37 <lambdabot> Functor f => a -> f b -> f a
08:04:39 <phz_> enclose operators in ()
08:04:42 <gcganley> :t (<$>)
08:04:42 <phz_> :t (<$>)
08:04:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:04:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:04:45 <phz_> :)
08:04:52 <phz_> (<$>) = fmap
08:05:05 <phz_> @src (<$>)
08:05:06 <lambdabot> f <$> a = fmap f a
08:05:15 <phz_> so
08:05:23 <phz_> fmap <$> zip <*> mapM f
08:05:27 <phz_> this is actually quite simple
08:05:31 <phz_> it expects a list
08:05:37 <phz_> et passes it to zip and mapM f
08:05:45 <xplat> :t fmap `asTypeIn` \x -> x <$> zip <*> mapM print
08:05:46 <lambdabot> Show a => ([()] -> [(a, ())]) -> IO [()] -> IO [(a, ())]
08:05:54 <phz_> and lift the zip list into the result of mapM f
08:05:55 <phz_> :)
08:05:58 <phz_> lifts*
08:06:28 <wayne> hi. what's the difference between partial function application and currying?
08:07:32 <xplat> :t fmap <$> zipWith const <*> mapM print
08:07:34 <lambdabot> Show c => [c] -> IO [c]
08:08:20 <xplat> of course you may as well say
08:09:35 <vanila> wayne, currying makes it easier to partially apply
08:09:56 <xplat> :t return <* mapM_ print
08:09:57 <lambdabot> (Show a, Monad m) => [a] -> m [a]
08:10:11 <phz_> wayne: currying is the framework, partial application is a use of that framework
08:11:31 <phz_> > map (curry (<)) [(1,3),(5,2),(78,23)]
08:11:33 <lambdabot>  [<() -> ((Integer,Integer),()) -> Bool>,<() -> ((Integer,Integer),()) -> Boo...
08:11:56 <phz_> wait, what
08:12:08 <phz_> > map (uncurry (<)) [(1,3),(5,2),(78,23)]
08:12:10 <lambdabot>  [True,False,False]
08:12:13 <phz_> :)
08:12:15 <johnw> wayne: currying as a trick where you implementing multi-argument functions by having functions that return functions; partial applications is when you return one of these intermediate functions instead of calling it
08:12:36 <johnw> (and English is my first language, it's just too early)
08:12:44 <phz_> :D
08:13:04 <Rembane> Those terms and the mixing of them make me confused every time.
08:13:12 <phz_> > curry fst 3 2
08:13:14 <lambdabot>  3
08:13:19 <phz_> > curry snd 3 2
08:13:19 <xplat> you can also do partial application for multi-argument functions, but with currying it comes naturally (it's just ordinary application) and with multiargument functions it's a special language feature
08:13:21 <lambdabot>  2
08:13:46 <johnw> currying is the framework, partial application takes advantage of it, exactly like phz_ said
08:13:49 <xplat> > curry show 2 3
08:13:51 <lambdabot>  "(2,3)"
08:13:54 <gcganley> like in clojure there is a macro called partial but it doesnt do it by currying
08:13:57 <phz_> > curry (first (*2)) 10 8
08:13:58 <lambdabot>  (20,8)
08:14:15 <phz_> yeah
08:14:15 <johnw> uncurry an n-argument function gives you a function that takes one argument taking an n-tuple
08:14:27 * hackagebot clean-unions 0.1 - Open unions without need for Typeable  http://hackage.haskell.org/package/clean-unions-0.1 (FumiakiKinoshita)
08:14:29 * hackagebot yesod-recaptcha 1.2.3.2 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.2.3.2 (FelipeLessa)
08:14:29 <nabokovian> it took me several SO questions and blogposts before I could separate the two concepts in my head
08:14:30 <johnw> where "n-argument function" is just an appearance
08:14:35 <phz_> if you have a function, like (*), it’s already curried
08:14:41 <xplat> curry curry curry print 1 2 3
08:14:44 <xplat> > curry curry curry print 1 2 3
08:14:46 <phz_> you can partially apply it ( (2*) )
08:14:46 <lambdabot>  Couldn't match type ‘(a0, b0) -> a3 -> t’
08:14:46 <lambdabot>                with ‘(((a1, b1) -> c0) -> a1 -> b1 -> c0, a2 -> GHC.Types.IO ...
08:14:46 <lambdabot>  Expected type: (((a1, b1) -> c0) -> a1 -> b1 -> c0,
08:14:46 <lambdabot>                  a2 -> GHC.Types.IO ())
08:14:46 <lambdabot>                 -> a0 -> b0 -> a3 -> t
08:14:56 <xplat> > curry curry curry print 1 2 3 4
08:14:58 <lambdabot>  Couldn't match type ‘(a0, b0) -> a3 -> a4 -> t’
08:14:58 <lambdabot>                with ‘(((a1, b1) -> c0) -> a1 -> b1 -> c0, a2 -> GHC.Types.IO ...
08:14:58 <lambdabot>  Expected type: (((a1, b1) -> c0) -> a1 -> b1 -> c0,
08:14:58 <lambdabot>                  a2 -> GHC.Types.IO ())
08:14:58 <lambdabot>                 -> a0 -> b0 -> a3 -> a4 -> t
08:14:59 <phz_> curry curry curry curry tikamasala curry curry…
08:15:04 <xplat> argh
08:15:14 <gcganley> more curry!
08:15:16 <johnw> another way to think of it is: a function a -> b -> c -> d is really a function of type a -> (b -> (c -> d)))
08:15:21 <SwashBuckla> oh dear
08:15:32 <phz_> what johnw said is THE thing to know about haskell’s function
08:15:37 <phz_> :)
08:15:40 <gcganley> dont say curry more than 3 times or a dead logican will come up behind you
08:15:50 <phz_> yeah
08:15:54 <SwashBuckla> hahaha
08:15:54 <phz_> it’s like the fmap game
08:16:01 <phz_> everyone here might know it
08:16:19 <SwashBuckla> do tell
08:16:33 <phz_>  @let fap :: (Functor f) => (a -> b) -> f a -> f b; fap = fmap
08:16:44 <phz_> :t fap . fap . fap . fap . fap . fap . fap
08:16:45 <lambdabot>     Not in scope: ‘fap’
08:16:45 <lambdabot>     Perhaps you meant one of these:
08:16:45 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
08:16:53 <phz_> @let fap :: (Functor f) => (a -> b) -> f a -> f b; fap = fmap
08:16:56 <lambdabot>  Defined.
08:16:58 <phz_> :t fap . fap . fap . fap . fap . fap . fap
08:16:59 <lambdabot> (Functor f6, Functor f5, Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
08:17:10 <gcganley> oh good god
08:17:15 <phz_> ok, the conversion’s gone way too far
08:17:17 <phz_> sorry :D
08:17:17 <gcganley> stop
08:17:18 <gcganley> now
08:17:53 <triliyn> > curry (curry (curry show)) 1 2 3 4 -- xplat
08:17:55 <lambdabot>  "(((1,2),3),4)"
08:19:02 <gcganley> comeone needs to make a bot with the id <haskell_curry> that shows up when we try and type curry curry curry
08:19:11 <gcganley> s/comeone/someone
08:19:27 * hackagebot rtorrent-rpc 0.2.0.0 - A library for communicating with RTorrent over its XML-RPC interface.  http://hackage.haskell.org/package/rtorrent-rpc-0.2.0.0 (KaiLindholm)
08:24:25 <xplat> triliyn: thanks
08:24:27 * hackagebot objective 0.4 - Extensible objects  http://hackage.haskell.org/package/objective-0.4 (FumiakiKinoshita)
08:25:20 <t4nk522> what is the status of the SIMD extension in GHC as described here: https://ghc.haskell.org/trac/ghc/wiki/SIMD ?
08:26:22 <RayNbow> hmm, is it okay to view a Map k v to be a functor in its first argument (ignoring the Ord constraint)?
08:26:33 <SwashBuckla> is there an `intersperse` that takes a string instead of a char?
08:26:38 <SwashBuckla> :t intersperse
08:26:39 <lambdabot> a -> [a] -> [a]
08:26:45 <RayNbow> :t intercalate
08:26:47 <lambdabot> [a] -> [[a]] -> [a]
08:26:49 <SwashBuckla> nope
08:26:53 <johnw> ReinH: ping
08:26:54 <SwashBuckla> that doesn't really do the same thing
08:27:26 <SwashBuckla> what I want is [a] -> [a] -> [a]
08:27:46 <johnw> do you mean like intercalate?
08:27:48 <johnw> oh, no
08:27:51 <johnw> too slow
08:27:53 <SwashBuckla> :D
08:28:11 <phz_> what do you want with that sig SwashBuckla ?
08:28:16 <johnw> where would your function paste in the strings?
08:28:28 <SwashBuckla> inbetween every character
08:28:45 <johnw> that should be easily done
08:29:04 <johnw> :t concatMap (:xs) ys
08:29:05 <lambdabot>     Not in scope: ‘xs’
08:29:05 <lambdabot>     Perhaps you meant one of these:
08:29:06 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
08:29:13 <johnw> :t \xs ys -> concatMap (:xs) ys
08:29:14 <lambdabot> [b] -> [b] -> [b]
08:29:20 <SwashBuckla> e.g. > `swashify "swash" "hello"`
08:29:32 <phz_> :t concatMap . (:)
08:29:33 <lambdabot> b -> [[b]] -> [b]
08:29:43 <SwashBuckla> "swashhswasheswashlshwashlswasho"
08:29:44 <phz_> :t concatMap . (flip (:))
08:29:45 <lambdabot> [b] -> [b] -> [b]
08:30:01 <RayNbow> @pl \s cs -> intercalate s (map return cs)
08:30:02 <lambdabot> (. map return) . intercalate
08:30:25 <phz_> the output of @pl sounds so silly to me, every time :D
08:30:30 <SwashBuckla> haha
08:30:30 <RayNbow> > ((. map return) . intercalate) "--" "hello"
08:30:31 <lambdabot>  "h--e--l--l--o"
08:30:36 <RayNbow> like that?
08:30:38 <SwashBuckla> yes!
08:30:47 <SwashBuckla> alrhough
08:30:51 <SwashBuckla> that's kinda whack
08:31:02 <SwashBuckla> there are 5 letters, but 4 --
08:31:04 <vanila> :t intercalate
08:31:06 <lambdabot> [a] -> [[a]] -> [a]
08:31:16 <rfreeman_w> > ((. map return) . intercalate) " *hic* " "My name is Joe and I want to apply for a bus driver job"
08:31:17 <lambdabot>  "M *hic* y *hic*   *hic* n *hic* a *hic* m *hic* e *hic*   *hic* i *hic* s *...
08:31:48 <vanila> @pl \x -> intercalate x . map return
08:31:48 <lambdabot> (. map return) . intercalate
08:32:00 <vanila> sure'ly there's a nicer point free way to write this?
08:32:44 <vanila> liftM2 (.) intercalate (const (map return))
08:32:49 <phz_> :t flip intercalate . duplicate
08:32:50 <lambdabot>     Not in scope: ‘duplicate’
08:32:50 <lambdabot>     Perhaps you meant one of these:
08:32:50 <lambdabot>       ‘replicate’ (imported from Data.List),
08:32:53 <rfreeman_w> vanila, how to change that string to array of words so string will go between words instead before each character
08:32:57 <twopoint718> Is there a way to automatically derive FromField/ToField in postgresql-simple? I have a gist here of what I'm talking about: https://gist.github.com/anonymous/55ffd9f30b872dc403e9
08:33:05 <vanila> rfreeman_w, use words instead of map return
08:33:10 <phz_> @let import Control.Comonad
08:33:11 <lambdabot>  <no location info>:
08:33:11 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
08:33:18 <phz_> :(
08:33:24 <rfreeman_w> > ((. words) . intercalate) " *hic* " "My name is Joe and I want to apply for a bus driver job"
08:33:26 <lambdabot>  "My *hic* name *hic* is *hic* Joe *hic* and *hic* I *hic* want *hic* to *hic...
08:34:44 <phz_> lambdabot is bored of drunk people
08:34:45 <phz_> :D
08:35:02 <RayNbow> SwashBuckla: do you want "--" 5 times then?
08:35:03 <vanila> @let drunk = (. intercalate) (. words) " *hic* "
08:35:05 <lambdabot>  Defined.
08:35:13 <SwashBuckla> RayNbow: yea
08:35:32 <SwashBuckla> > drunk "yes please"
08:35:33 <pjdelport> > fix drunk
08:35:34 <lambdabot>  "yes *hic* please"
08:35:37 <lambdabot>  mueval-core: Time limit exceeded
08:36:01 <SwashBuckla> "yes *hic* please *hic*"
08:36:25 <SwashBuckla> > intersperse 'f' "hello"
08:36:27 <lambdabot>  "hfeflflfo"
08:36:43 <SwashBuckla> interesting
08:36:46 <SwashBuckla> > intersperse 'f' "o"
08:36:49 <lambdabot>  "o"
08:36:55 <RayNbow> @pl \s cs -> concatMap (:s) cs
08:36:56 <lambdabot> (=<<) . flip (:)
08:37:13 <RayNbow> > ((=<<) . flip (:)) "--" "hello"
08:37:14 <lambdabot>  "h--e--l--l--o--"
08:37:16 <SwashBuckla> that looks so voodoo
08:37:18 <RayNbow> > ((=<<) . flip (:)) "--" ""
08:37:20 <lambdabot>  ""
08:37:27 <pjdelport> > iterate drunk "Hello, world!"
08:37:29 <lambdabot>  ["Hello, world!","Hello, *hic* world!","Hello, *hic* *hic* *hic* world!","He...
08:37:33 <vanila> lol
08:37:54 <pjdelport> > iterate drunk "Another, please."
08:37:56 <lambdabot>  ["Another, please.","Another, *hic* please.","Another, *hic* *hic* *hic* ple...
08:44:28 * hackagebot tasty 0.10 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10 (bergey)
08:44:41 <johnw> mmm... tasty
08:45:04 <SwashBuckla> taste driven design
08:45:10 <johnw> exactly
08:59:29 * hackagebot bindings-portaudio 0.0.2 - Low-level bindings to portaudio library  http://hackage.haskell.org/package/bindings-portaudio-0.0.2 (FumiakiKinoshita)
08:59:31 * hackagebot tasty 0.9.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.9.0.1 (bergey)
09:04:29 * hackagebot tasty 0.8.1.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.3 (bergey)
09:04:31 * hackagebot tasty 0.8.1.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.2 (bergey)
09:04:33 * hackagebot tasty 0.8.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.1 (bergey)
09:04:35 * hackagebot tasty 0.8.0.4 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.0.4 (bergey)
09:04:37 * hackagebot tasty 0.8.0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.0.2 (bergey)
09:05:19 <pmade> hackagebot has become self-aware and is spamming the channel for revenge.
09:05:50 <bergey> I know, these are the least interesting package notifications ever.  Sorry.
09:06:12 <bergey> (I'm adding retroactive upper bounds.)
09:07:01 <pmade> bergey: I'm not complaining, just making a stupid joke ;)
09:09:39 * hackagebot tasty 0.8 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8 (bergey)
09:09:41 * hackagebot tasty 0.7 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.7 (bergey)
09:09:43 * hackagebot tasty 0.6 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.6 (bergey)
09:09:45 * hackagebot tasty 0.5.2.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.2.1 (bergey)
09:11:35 <Crockeo> Anyone here have experience with Netwire?
09:13:35 <SwashBuckla> The histogram exercise in CIS194 is tough!
09:13:36 <SwashBuckla> wow
09:13:57 <SwashBuckla> I've barely gotten it to work, nevermind code-golf
09:14:30 * hackagebot tasty 0.5.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.2 (bergey)
09:14:32 * hackagebot tasty 0.5.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.1 (bergey)
09:14:34 * hackagebot tasty 0.5 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5 (bergey)
09:14:36 * hackagebot tasty 0.4.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.2 (bergey)
09:14:38 * hackagebot tasty 0.4.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.1.1 (bergey)
09:15:19 <Yxven> I had trouble with the histogram
09:16:03 <Yxven> SwashBuckla  I would like to see you a solution when you are finished. Mine is quite ugly
09:16:35 <albeit_> Is a ByteString.Builder essentially a lazy ByteString? Should I be keeping all potential output in Builder form, and only convert to actual ByteString when it needs to be outputted/transmitted?
09:17:41 <Yxven> here is my solution: https://dpaste.de/sgdY
09:19:40 * hackagebot tasty 0.4.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.0.1 (bergey)
09:19:41 * hackagebot tasty 0.4 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4 (bergey)
09:19:44 * hackagebot tasty 0.3.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.3.1 (bergey)
09:19:46 * hackagebot tasty 0.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.3 (bergey)
09:19:48 * hackagebot csv-to-qif 0.3 - A small program that will read csv files and create qif files  http://hackage.haskell.org/package/csv-to-qif-0.3 (palo)
09:20:14 <albeit_> What's with hackagebot and tasty?
09:20:32 <Clint> scroll up
09:20:44 <albeit_> Ah
09:21:07 <nbl> Hello!
09:21:11 <hnoob> why is it that the docs seem to lag behind the libraries on hackage?  Looking at Yesod, you have to go back to version 1.2.19.2 to see any documentation.
09:21:18 <hnoob> that's 8 versions back
09:22:14 <SwashBuckla> Yxven: thanks. I will send you mine when I'm done
09:22:26 <SwashBuckla> at the moment, it is horrendous!
09:22:50 <SwashBuckla> yours is way cleaner
09:23:00 * SwashBuckla runs away
09:23:11 <SwashBuckla> I need to get mine working first then I will golf it
09:24:00 <bergey> hnoob: There's some lag because it takes time for Hackage to get around to building the docs.  But long lag is usually because the build failed.
09:24:22 <bergey> You can get some information about why the build failed (or succeeded) from http://hackage.haskell.org/package/yesod-1.2.6.1/reports/
09:24:48 <bergey> and http://hackage.haskell.org/package/yesod-1.2.6.1/reports/1/log
09:24:49 * hackagebot tasty 0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.2 (bergey)
09:24:51 * hackagebot tasty 0.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.1.1 (bergey)
09:35:58 <lpaste> Spintronic pasted “24 game/Solve Rosetta Code bug?” at http://lpaste.net/112247
09:38:06 <hnoob> thx bergey
09:38:33 <spintronic> Hi I was running the 24 game/Solve example for Haskell on Rosettacode using Hugs from Septermber 2006 and ran into an error at line 25 of their code. I posted it here: http://www.haskell.org/
09:38:50 <spintronic> sorry I meant here: http://lpaste.net/112247
09:39:07 <spintronic> I just wanted to know if this is because my version of Hugs is too old?
09:40:22 <dfeuer> spintronic, ALL versions of Hugs are too old.
09:40:33 <dfeuer> Hugs has not been supported in YEARS.
09:41:09 <dfeuer> spintronic, you should probably switch to ghc (and ghci for interactive use).
09:41:26 <spintronic> ok thanks I'll try that
09:42:41 <dfeuer> spintronic, of course, if you want to take over maintaining Hugs, you're more than welcome to do so. You can download the source code via archive.org (the Hugs website doesn't work anymore).
09:43:20 <dfeuer> But ... good luck. It's been rotting for a long, long time, and the world has moved on.
09:43:56 <spintronic> yeah I was just playing with what I have access to on a public shell account.
09:45:22 <spintronic> yup sure enough the code works on GHC 7.0.4. I found it on another server.
09:45:47 <spintronic> thanks guys
09:45:49 <dfeuer> spintronic, GHC 7.0.4 is ancient history and not supported.
09:46:32 <dfeuer> spintronic, oh, I see, you only have what someone else has installed. Yuck. GHC is up to 7.8.3 now.
09:46:39 <levi> But still more likely to run random Haskell code than Hugs. :)
09:46:55 <spintronic> yup, thanks.
09:47:22 <levi> You might look at the online development environment stuff.
09:47:43 <levi> At fpcomplete.com, I mean.
09:48:20 <levi> https://www.fpcomplete.com/business/fp-haskell-center/
09:49:02 <levi> That'll give you a nice integrated development environment with up-to-date tools and libraries.
09:49:14 <spintronic> cool I'll check it out thanks levi.
09:50:59 <levi> They've also got a bunch of live-code tutorials in the School of Haskell section.
09:52:51 <pharpend> levi: what are we talking about?
09:55:03 <levi> spintronic was trying to run some Haskell examples in an environment where new software couldn't be installed, and only old versions of Hugs and GHC were available.
09:56:06 <pharpend> hmm
09:56:19 <pharpend> I would direct him to fp complete
09:56:22 <levi> I suggested fpcomplete's stuff as an alternative to locally-installed out-of-date stuff.
09:56:24 <pharpend> or ideone i think has haskell
09:56:29 <merijn> "environment where new software couldn't be installed", what, like a machine with no diskspace or a windows work station?
09:56:33 <thetallguy> Is there a standard instance of  Generic Text?  The deriving Generic mechanism seems to have access to one, but I cannot find one that is visible.
09:56:40 <levi> merijn: A public shell account.
09:56:55 <merijn> levi: Installing GHC user locally is trivial
09:57:11 <c_wraith> you can use surprising amounts of disk space quickly, though
09:57:14 <merijn> levi: Just download linux GHC binaries and install in home dir (assuming you have sufficient disk space)
09:57:21 <pharpend> no ideone doesn't have haskell
09:57:34 <dfeuer> merijn, assuming sufficient disk space is not always a good idea where GHC is concerned.
09:57:42 <merijn> I say this as someone used to getting GHC to work on our university "no root access" systems
09:58:22 <merijn> dfeuer: Nowadays the odds of having a shell account with 1) sufficient processing power for GHC 2) insufficient disk space, seems a rare occurence
09:58:24 <pharpend> merijn: couldn't they put you into some sort of install group
09:58:34 <merijn> Whereas "I don't have root on this system" is common
09:58:38 <levi> Good to know that's a workable option.
09:58:50 <dfeuer> Does *anyone* know where to find documentation for UnicodeData.txt? I asked in #unicode, but it looks like no one's actually there.
09:58:57 <merijn> pharpend: Define "couldn't they", in a strictly technical sense they could
09:59:06 <c_wraith> merijn: I have a VM where I regularly run out of disk space due to multiple GHC installs. :)
09:59:07 <dfeuer> merijn, you may be right.
09:59:25 <merijn> pharpend: In a *practical* sense "haha", any non-admin getting install access on cluster machines is not happening
09:59:34 <pharpend> This seems like something package managers should have solved by now
09:59:37 <pharpend> installing things to ~
09:59:39 <dfeuer> I have an SSD I almost ran right out of space with GHC, but yeah, that's multiple GHC source trees, not binary dists.
10:00:12 <pharpend> ghc is friggin huge
10:00:22 <merijn> pharpend: Haskell is much better at local installs than other languages in my experience (I've had to try and get user local installs of python and ruby working, it was a disaster)
10:01:09 <merijn> dfeuer: Really? My GHC checkout is only like ~200 MB
10:01:10 <dfeuer> merijn, I'm attempting to learn Ruby now (because other people think it will help me get a job) and it is nightmarish. There are tools for doing it, and lots and lots of instructions to follow, and it is nightmarish.
10:01:28 <dfeuer> merijn, the source plus the compiled stuff gets big.
10:01:34 <dmj`> merijn: agreed
10:02:02 <merijn> And people keep complaining cabal is terrible...I wonder which other languages they ever use >.>
10:02:09 <levi> You want to see huge, start doing OpenEmbedded based builds of cross-compile environments and target images.
10:02:16 <pharpend> cabal is pretty slow and breaks a lot
10:02:31 <pharpend> but it is better than the other options available lin most languages
10:02:49 <merijn> pharpend: Really? I've not seen cabal break a lot. I've seen *packages* break a lot, sure
10:02:52 <dmj`> pharpend: cabal has only broken for me when I use ec2 instances with low ram
10:02:53 <gcganley> the two systems i like the best are leiningen (Clojure) and cabal
10:03:14 <merijn> pharpend: But given the choice between cabal and autotools...
10:03:14 <Yxven>  it's pretty simple to create a virtual environment for a specific project in Python
10:03:26 <merijn> Yxven: Not if you need to install a program
10:03:46 <levi> JIT-compiled languages have a much easier package-management problem than GHC does.
10:03:49 <pharpend> ack
10:03:56 <pharpend> cabal is slow and breaks stuff a lot
10:03:57 <gcganley> ive never used vitrual env... is it like sandboxes?
10:04:03 <Yxven> merijin like what?
10:04:03 <merijn> Yxven: I wanted to install mercurial's hg-git extension, which requires an installation of dulwhich. After 2 weeks I still didn't manage
10:04:29 <dmj`> gcgangley: yea its just like cabal exec, where venv folder is your cabal sandbox, there used to be a virthualenv
10:04:31 <Yxven> virtalenv is like sandboxes
10:04:32 <pharpend> sorry, trying to both pay attention to class and irc channel is difficult
10:04:47 <dmj`> pharpend: what class?
10:04:50 <merijn> Yxven: Because installing dulwich into the local python install I used for mercurial didn't want to work without installing like 15 different virtualenv and what not things
10:05:14 <pharpend> dmj`: freshman mechanics, mildly unpleasant calculus basically
10:05:19 <dfeuer> merijn, languages with more stable library ecosystem bases. C, for example.
10:05:26 <gcganley> where does Nix fit into all of this... i really want to install it on my home computer but could never get the install rolling...
10:05:37 <merijn> dfeuer: lol
10:05:40 <Fuuzetsu> ^
10:05:46 <Fuuzetsu> ooh nix talk
10:05:47 * Fuuzetsu reads up
10:05:52 <nh2> not sure what why people would say cabal is slow - most of the time it just passes on to ghc --make.
10:05:54 <merijn> dfeuer: As if autotools is better than cabal :)
10:05:58 <pharpend> nixos looks really interesting, and I can't be arsed into trying it
10:06:07 <gcganley> i tried
10:06:09 <gcganley> and failed
10:06:14 <Fuuzetsu> gcganley: what was the problem?
10:06:27 <dfeuer> merijn, that's a whole different kettle of fish.
10:06:42 <levi> gcganley: You can install Nix as a manager of user-installed packages, or as a system-wide manager of packages in addition to the OS-provided ones.
10:06:51 <gcganley> Fuuzetsu: usb and vm both refused to boot to x11 distro or the shell distro
10:07:05 <Fuuzetsu> refused to boot how?
10:07:14 <pharpend> nh2: sometimes it can't resolve dependencies quickly
10:07:21 <gcganley> Fuuzetsu: kicked me to BIOS
10:07:25 <levi> gcganley: So, for example, you could use a base Ubuntu system and use Nix to manage all haskell development packages.
10:07:28 <gcganley> or to the other hard disk
10:07:44 <gcganley> levi: i use arch linux
10:07:49 <gcganley> levi: i understand that
10:07:51 <levi> Works fine with Arch, too.
10:08:00 <gcganley> levi: but i want NixOs
10:08:05 <Fuuzetsu> gcganley: oh, so it couldn't pick up your USB drive or whatever; AFAIK that's not NixOS problem in that case but how you made the drive; even then if you try again, swing by #nixos
10:08:07 <gcganley> levi: thats the thing
10:08:10 <pharpend> levi: what about gentoo?
10:08:12 <nh2> pharpend: how kind of slow are we talking? I haven't seen a solve slower than 0.3 seconds so far
10:08:14 <dfeuer> It seems widely believed that Nix is the best environment for Haskell hacking, but I'm too lazy.
10:08:21 <pharpend> nh2: try installing yesod
10:08:30 <levi> Sure. Works fine with any other Linux-based OS, as far as I know.
10:08:39 <gcganley> dfeuer: did you mean to make the 'lazy' joke?
10:08:45 <pharpend> nh2: on my (<1yo) machine, takes at least 2 minutes
10:08:55 <dfeuer> No.
10:09:35 <pharpend> nh2: it takes 5 on my 3yo shittop
10:09:50 <gcganley> I'll swing by #nixos when im home, but im in school right now lol
10:09:56 <nh2> pharpend: what? That's really weird, for me it takes < 1 second: cabal install yesod --dry-run  0.77s user 0.17s system 104% cpu 0.892 total
10:10:18 <nh2> pharpend: this is in a sandbox I just made with cabal sandbox init
10:10:28 <pharpend> 2.3 seconds for me
10:10:41 <pharpend> mind you that the install won't work the first time you try it
10:10:54 <nh2> pharpend: what did you mean takes the 2 minutes?
10:10:58 <pharpend> it will run into dependency conflicts, because the devs are too lenient with their versions
10:11:38 <pharpend> I was trying to install something the other day that took about 2 minutes
10:11:42 <pharpend> I can't remember the package though
10:11:46 <pharpend> hakyll
10:11:48 <pharpend> no
10:11:49 <gcganley> isnt spj supposed to be working on a better module system for haskell?
10:11:52 <pharpend> hakyll was pertty easy
10:12:12 <kadoban> hakyll takes forever for me...most of that seems to be pandoc though.
10:12:23 <levi> NixOS seems like an interesting idea, and is probably very useful in a context of deploying cloud-based Nix stuff, but I'm not convinced it provides a ton of value to a typical desktop/laptop workstation system over installing Nix as a supplementary package manager on another distro.
10:12:32 <pharpend> pandoc sucks as far as development is concerned
10:12:34 <nh2> kadoban: but that's compile time, not cabal version constraint solving time
10:12:45 <pharpend> it's really useful though
10:12:50 <kadoban> Oh, sorry missed the context. Yeah that takes no time that I've noticed.
10:13:00 <gcganley> levi: thats true but i just enjoy the functional coolaid
10:13:07 <levi> pharpend: What do you mean it sucks "as far as development is concerned"?
10:13:12 <nh2> pharpend: regarding your other point about lenient versions: ok, but that's the package (developer's) fault, not cabal's
10:13:52 <pharpend> levi: https://github.com/jgm/pandoc/issues/1590#issuecomment-57232166
10:14:24 <pharpend> levi: he uses plain strings for io, which is inefficient
10:14:54 <pharpend> levi: he has a habit of not fixing issues, just finding workarounds
10:15:31 <pharpend> levi: he refuses to support pandoc installs sans haskell platform
10:15:48 <Fuuzetsu> levi: I don't know, I run NixOS and not having to fuck around with 50 dotfiles spread around the system somewhere, it's pretty convenient to have a nice declarative config with rollbacks and all that
10:16:10 <Fuuzetsu> “patches welcome”
10:16:12 <pharpend> Fuuzetsu: I'll try nixos when I have the time
10:16:21 <Fuuzetsu> cool
10:18:48 <levi> pharpend: Well, most of those can be chalked up to the fact that pandoc is essentially a hobby project, and IIRC it was one of jgm's early Haskell programs. Considering that, it seems remarkably well-supported to me.
10:18:57 <merijn> gcganley: Edward Yang is working on a better module system
10:19:15 <merijn> gcganley: Google for "ezyang backpack"
10:19:19 * Fuuzetsu just saw malloc in Haskell
10:19:30 <Fuuzetsu> I regret looking at code dealing with C bindings
10:19:47 * dmj` gasps
10:20:11 <dmj`> @typ malloc
10:20:13 <lambdabot> Not in scope: ‘malloc’
10:20:39 <Fuuzetsu> https://github.com/fumieval/bindings-portaudio/blob/master/example/sine.hs#L50
10:23:08 <nh2> pharpend: just did `cabal install yesod` in a fresh sandbox, it had no failures and `1762.11s user 120.42s system 335% cpu 9:20.97 total`
10:23:26 <levi> pharpend: If you poke around jgm's github, you'll see some later attempts at pandoc-like things with different approaches that are more efficient, but he clearly hasn't got the time to try to move all of pandoc over to them.
10:23:56 <RchrdB> nh2: I'm impressed by that CPU usage rate. :)
10:24:26 <levi> The magic of multi-core. :)
10:24:57 <a2alsuda> levi: Elm uses Cheapskate by jgm
10:25:25 <RchrdB> It's still impressive that nh2's computer managed to keep at least four CPU cores busy for that proportion of time, as opposed to waiting for things to download or waiting for disks.
10:27:19 <levi> a2alsuda: Cool, I looked at Cheapskate a while back and it seemed a nice alternative to the full Pandoc when you don't need the full generality.
10:29:33 * hackagebot unagi-chan 0.2.0.0 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.2.0.0 (BrandonSimmons)
10:35:35 <latk> is there some simple way to turn Either a b into Either c b ?
10:35:53 <latk> assuming you have the function a -> c
10:35:54 <dibblego> latk: do you have (a -> c)?
10:36:04 <latk> dibblego: ^^
10:36:55 <vanila> :t \f -> either (Left . f) Right
10:36:56 <lambdabot> (a -> b) -> Either a b1 -> Either b b1
10:37:06 <vanila> you can use this
10:37:11 <nshepperd> Control.Arrow.left probably
10:37:55 <latk> vanila: That looks great, thanks.
10:38:24 <nshepperd> :t left show
10:38:25 <lambdabot> Show a => Either a d -> Either String d
10:44:28 <vanila> you may define
10:44:28 <vanila> left f = either (Left . f) Right
10:44:37 <vanila> right g = either Left (Right . g)
10:44:53 <vanila> arrow is more general but not really more useful
10:53:35 <merijn> :t bimap even id
10:53:37 <lambdabot> (Bifunctor p, Integral a) => p a d -> p Bool d
10:54:02 <merijn> :t bimap even id `asAppliedTo` (undefined :: Either Int ())
10:54:04 <lambdabot> Either Int () -> Either Bool ()
11:09:11 <J_Arcane> Oooh. I didn't know about this. https://github.com/NICTA/course
11:24:37 <ReinH> johnw: pong
11:27:38 <Denommus> well, I can't seem to find a comprehensible tutorial about reactive-banana like there is one for netwire
11:27:48 <Denommus> maybe... I should write one
11:40:25 <geekosaur> I thought someone had one
11:45:42 <Kron> http://lpaste.net/112256 can anyone help me with this problem?
11:45:47 <Kron> I'm not entirely sure what a Property is
11:46:05 <Kron> I thought it was Bool ==> Bool for quickcheck
11:46:26 <geekosaur> apparently there is indeed no good tutorial as yet. I thought I had one stashed but it's not r-b
11:48:10 <Kron> I'm trying to set up a quickcheck property to test lens laws, and generating the random lens has worked just fine, I'm just not sure what the problem is here
11:53:00 <bitemyapp> on a scale of 1-plsdie, how unkosher is it to write Generics for a typeclass that doesn't belong to you?
11:54:20 <nh2> bitemyapp: sometimes you have to do that, e.g. when you want to auto-derive quickcheck's Arbitrary and the author doesn't want to depend on quickchek
11:54:29 <dmj`> bitemyapp: might be better to submit a pull to that package, example: what if they change that typeclass in a newer version?
11:55:20 <nh2> bitemyapp: in that case, there is no non-orphan solution: it can't be in quickcheck (because that doesn't make sense) and it can't be in the module the data type is defined (because then it would have to depend on a test library, which doesn't make sense e.g. for a .Types module)
11:56:03 <nh2> bitemyapp: in the case given, the cleanest available way is to have the author to provide this orphan for you in a good place
11:56:04 <bitemyapp> dmj`: haha, this is not a situation where a PR is appropriate.
11:56:16 <bitemyapp> dmj`: this is about coping with weirdo JSON that has a pattern to it.
11:56:40 <bmuk> Hey everyone, I want to store some data in a map, but I would also like to save it to a file incrementally (every few minutes only update what was changed). How do I accomplish this in haskell?
11:56:58 <dmj`> bitemyapp: how weird? can you show an example? the stripe api has some funky stuff I've had to work with
11:57:24 <bitemyapp> dmj`: Golang generated JSON, capital letters in keys.
11:57:30 <bitemyapp> dmj`: aka, plague of the earth
11:57:53 <bitemyapp> bmuk: cheap and cheerful serialization? acid-state probably. Beware that it's not a fully proper database and shouldn't be used as such though.
11:57:58 <bitemyapp> bmuk: alternately: sqlite
11:58:29 <bmuk> bitemyapp: what are the tradeoffs of using acid-state?
11:59:22 <dmj`> so you don't want to write the instances out by hand? :) stripe has lowecase keys, but theres so many names that records start conflicting, so generics aren't an option.
12:00:34 <bmuk> bitemyapp: and are you suggesting using the (quasi-)database instead of Data.Map or in parallel
12:00:50 <dmj`> bmuk: acid-state works well, I use it in production and have had 0 issues and it performs migrations flawlessly, written by a great haskellers. My advice: use the remote module, will let you query the state via ghci, and do not throw any exceptions in your transactions
12:01:41 <bitemyapp> dmj`: it's not even me. I'm asking a question as a surrogate for somebody else.
12:01:48 <bitemyapp> dmj`: half the questions I ask in here are of that nature.
12:02:31 <latk> I don't suppose there is some way to "extend" a type, is there? Say I have data A = A { x :: Int, y :: Int}, and want to make data B = B { x :: Int, y :: Int, z :: Int}. Is there some way to just extend A ?
12:03:12 <ReinH> latk: nope
12:03:22 <latk> ReinH: Yeah I figured not :)
12:03:24 <latk> Cheers.
12:03:33 <bitemyapp> latk: data B = B { a :: A, z :: Int }
12:03:41 <bitemyapp> latk: you can nest.
12:03:48 <bmuk> unrelated - does anyone use stackage inclusive? It's missing some things but I would like to be able to use the packages (such as acid-state) which aren't yet in stackage
12:03:52 <dmj`> bitemyapp: I didn't say anything was you
12:04:23 <latk> bitemyapp: Yeah, I know - I was trying to avoid writing more aeson instances :s
12:04:38 <dmj`> bmuk: it depends on your needs, you could keep a map in an mvar, write to a chan, have a listening thread that modifies the mvar and writes to disk at the same time, marlows logger pattern
12:05:55 <dmj`> bitemyapp: what makes you think acid-state isn't a *fully functioning* database?
12:05:56 <bmuk> dmj`: is that in his parallelism book?
12:06:01 <dmj`> bmuk: yes
12:06:29 <dmj`> bmuk: many threads writing to a chan, one thread reading on the chan, pattern matching on the type and executing commands
12:08:34 <bitemyapp> dmj`: it's just not up to par with what people need from a database that would otherwise be disposed to use something like PostgreSQL.
12:08:56 <dmj`> bitemyapp: by whose standards? what "people" are you referring to? And have you ever used it?
12:09:11 <bitemyapp> dmj`: we've been through this before.
12:09:16 <dmj`> that's like comparing redis vs. postgresql
12:09:29 <dmj`> bitemyapp: yes we have, ok I'm done
12:09:33 <bitemyapp> dmj`: I know enough from Hackage's problems to say that acid-state is more like an alternative to sqlite than PostgreSQL.
12:09:40 * dmj` gets off soapbox
12:09:44 <bitemyapp> that's why I suggested acid-state and sqlite in the same breath to bmuk
12:09:55 <bitemyapp> dmj`: you will NOTE that I *did* suggest acid-state, albeit with a caveat.
12:10:22 <bitemyapp> they wanted to directly persist a Map. I offered a way to do that but with honest mention of possible limitations depending on how much they planned to expand scope.
12:11:37 <dmj`> bitemyapp: yes and everytime someone mentions hackage and acid-state I comment and no one reads it, hackage doesn't use the remote module, so you can't inspect the state while its running, and the db process runs inside of the web server process, probably contributing to inefficiencies. Also, I doubt checkpoints are ever being made, so hackage probably long checkpoint files for their states, they also probably open and close them
12:11:37 <dmj`> regularly, so you'd have to wait each time the log is read to query the state.
12:11:51 <dmj`> probably has*
12:12:02 <dmj`> long event log files*
12:12:26 <bitemyapp> dmj`: again, not an issue if you use PostgreSQL.
12:12:42 <bitemyapp> and if you use PG, all the tools in the existing SQL ecosystem become available to you.
12:12:49 <bitemyapp> you don't have to fuss with PGSQL for it to work nicely. It just works.
12:13:32 <bmuk> If I only have one physical core, would that be a problem?
12:13:45 <bmuk> Regarding the logger pattern
12:13:48 <bitemyapp> bmuk: probably not?
12:13:57 <bitemyapp> bmuk: test it with and without a threaded runtime perhaps?
12:14:05 <bitemyapp> dmj`: there's a time and a place to use acid-state. Just be honest about where that line is drawn.
12:14:19 <dmj`> bitemyapp: again, the grass isn't greener. It also depends on your needs. Acid-state supplements postgresql well. Have fun writing parsers for your tables, postgresql migrations aren't fun either. There's groundhog but I don't think you can do joins. There's no impedence mismatch between the database layer and the application layer, its a thing of beauty, did I mention its fast and uses STM? STM is database transactions at the lev
12:14:19 <dmj`> memory
12:14:31 <bmuk> bitemyapp: Maybe I am confused as to the line between threads and cores
12:14:36 <dmj`> in acid-state
12:14:49 <dmj`> bitemyapp: if you haven't used it in a production scenario you're just speculating
12:15:11 <bitemyapp> dmj`: hackage seems production enough :)
12:15:21 <dmj`> bitemyapp: read my earlier comment about hackage
12:15:39 <bitemyapp> dmj`: again, not something they'd have to fuss with if they were using PostgreSQL
12:15:47 <Elgo> I'm very new with haskell and trying to use hunit to test an assignment I'm writing. But when trying to run the tests I get http://i.imgur.com/uMHu9jw.png this error. What can I do to fix it?
12:15:50 <bitemyapp> dmj`: not to mention how inefficient the serialization of acid-state is.
12:15:55 <bitemyapp> dmj`: which is uh, half the point of acid-state.
12:16:15 <dmj`> bitemyapp: then I volunteer you to do the code porting from acid-state to postgresql, o/w no need to complain. There are improvements hackage could make right now to using acid-state that would benefit it, IMO.
12:16:25 <bitemyapp> dmj`: I *have* volunteered before!
12:16:29 <bitemyapp> dmj`: dcoutts_ told me not to bother.
12:16:35 <bitemyapp> dmj`: that offer still stands, I might add.
12:16:40 <dmj`> bitemyapp: what's inefficient about cereal?
12:16:55 <bitemyapp> generic serialization formats aren't good enough for a database.
12:17:32 <dmj`> bitemyapp: generic serialization? What is generic about it? Would you prefer bson?
12:17:58 <bitemyapp> >bson
12:18:01 <bitemyapp> >mfw
12:18:16 <bitemyapp> dmj`: the moment dcoutts_ lets me off the leash, I'm porting it.
12:18:22 <bitemyapp> dmj`: and I'm not the only one that wants it flipped over.
12:18:52 <bitemyapp> there's nothing further to discuss here. You've invested your ego into the matter.
12:19:10 <bitemyapp> acid-state has a niche, can be used effectively in that niche. It could be a lot better and some of the limitations keep it more strictly confined to that niche.
12:19:20 <dmj`> bitemyapp: I think you shouldn't judge acid-state without using it. I think you should read the code base. You've invested your ignorance into the matter and its frustrated me
12:19:26 <bitemyapp> If you're going to spend time defending the baby rather than improving it, then I can't trust your word on the pros/cons of the database.
12:19:41 <bitemyapp> it is *critical* that people working on infrastructure related to persistence be honest about how it works and what its limitations are.
12:19:42 <dmj`> bitemyapp: again, please see the comments above about hackage
12:19:48 <dmj`> I have made recommendations that go unnoticed
12:20:01 <bitemyapp> dmj`: you can blame the victims like MongoDB did if you want
12:20:08 <bitemyapp> dmj`: "lol it's configured not to be durable by default"
12:20:10 <dmj`> bitemyapp: agreed, go read acid-state, its a smaller code base and more readable than postgresql's
12:20:37 <dmj`> bitemyapp: you're looking at the problem and assuming it's acid-state w/o knowing how it works
12:21:16 <bitemyapp> dmj`: again, the problems Hackage has had operationally are enough for me.
12:21:17 <dmj`> bitemyapp: the idea behind acid-state really is novel and it combines a lot of very cool features of haskell IMO
12:21:39 <bitemyapp> dmj`: it's higher maintenance than PostgreSQL and is more suited to embeddedable use-cases like sqlite. That's my main point.
12:22:41 <dmj`> bitemyapp: the opposite, maintenance arguments have to do with familiarity. I can setup, deploy and migrate faster than any other database I've ever used. It's just a haskell binary. I've been using acid-state for months though.
12:24:10 <bitemyapp> dmj`: again, higher maintenance than PostgreSQL.
12:24:24 <dmj`> bitemyapp: you not reading what I write seems to be a common theme
12:24:46 <bitemyapp> dmj`: you're skipping over my point mate.
12:24:54 <dmj`> bitemyapp: please tell me your point
12:25:02 <bitemyapp> dmj`: you don't have to fuss with sqlite or postgresql in the manner required to make acid-state behave itself
12:25:18 <dmj`> bitemyapp: what fusses have you had with acid-state
12:25:19 <bitemyapp> you have implicitly admitted this by talking about steps the infra team would have to take to make acid-state behave itself.
12:25:28 <bitemyapp> dmj`: again, we're talking about Hackage here.
12:25:40 <bitemyapp> dmj`: do you have any idea how disingenuous this comes off?
12:25:47 <bitemyapp> when you won't discuss technical limitations frankly?
12:26:00 <bitemyapp> being honest and forthright about this is critical for persistence infrastructure.
12:26:30 <dmj`> bitemyapp: Please read my comments above about hackages performance when using acid-state, I was brutally honest in my opinion, and was technical
12:26:54 <bitemyapp> dmj`: you're ignoring that this is hassle that doesn't exist for other databases.
12:27:18 <dmj`> bitemyapp: your right all other databases don't have problems like this
12:27:29 <bitemyapp> there's maintenance, but nothing that falls apart quite so quickly or easily.
12:27:43 <dmj`> bitemyapp: you can't even explain to me why its falling apart
12:27:47 <bitemyapp> generally with PGSQL you're talking index tuning. That's the most common one and has a pretty minor failure mode.
12:28:05 <bitemyapp> dmj`: if you're going to insist on letting your ego take the reins, I can't go anywhere productive with this.
12:28:30 <dmj`> bitemyapp: it's not my ego, its your inability to get to the root of the matter, you speak cavalier about a code base you know nothing about
12:28:31 <bitemyapp> dmj`: I desperately want to have an honest conversation about how acid-state could be improved and you want to blame your users.
12:28:47 <bitemyapp> dmj`: you need to start by not blaming your users and just admit that having to fuss with it at all sucks.
12:28:53 <dmj`> bitemyapp: for the fourth time, see my hackage comments, I made recommendations on what to do with hackage to improve it
12:29:04 <bitemyapp> and that insofar as it is humanly possible, it should just work.
12:29:11 <dmj`> bitemyapp: I am a user!
12:29:15 <dmj`> bitemyapp: I enjoy it!
12:29:23 <bitemyapp> you're biased.
12:29:26 <danharaj> what sort of discussion is occurring here? it's long in my logs :)
12:29:26 <bitemyapp> it's your baby.
12:29:32 <dmj`> bitemyapp: I've at least used it!
12:30:05 <dmj`> bitemyapp: you should make a web app with it
12:30:18 <jle`> nkar: have you tried fromMaybe empty
12:30:27 <bitemyapp> dmj`: http://www.haskell.org/pipermail/cabal-devel/2012-September/009076.html
12:30:35 <bitemyapp> dmj`: https://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html
12:30:49 <dmj`> bitemyapp: Right there! "unable to inspect the data"
12:30:58 <dmj`> bitemyapp: they were not using Data.Acid.Remote
12:31:10 <dmj`> bitemyapp: that right there is my main suggestion
12:31:10 <bitemyapp> dmj`: the slow startup/shutdown is pretty bad.
12:31:24 <bitemyapp> dmj`: and goes back to what i was saying about the inefficiency of the serialization format as it relates to being used for a database.
12:31:33 <nkar> jle`: yes, approx. 8 hours ago
12:31:35 <saml> (True, False, True, True) => "1011"  how ?
12:31:42 <bitemyapp> an online database accessible as a service is going to be preferable for most people
12:31:43 <dmj`> bitemyapp: please listen to me, you've never used it, I have 2 states running in prod right now
12:31:50 <bitemyapp> dmj`: so?
12:31:59 <bitemyapp> dmj`: people run stuff on PHP and text files too. Doesn't make it a good idea.
12:32:03 <dmj`> bitemyapp: if you don't use the remote module you'll have to open and close multiple states to save RAM
12:32:19 <dmj`> bitemyapp: thats why its slow, if you use the remote module, give them their own processes and never open / close that isn't an issue
12:32:20 <jle`> nkar: cool :D
12:32:29 <jle`> is that not succinct enough?
12:32:34 <dmj`> bitemyapp: it's remote producedure calls, and you can put them on different servers
12:32:50 <dmj`> bitemyapp: that's my suggestion to hackage, which has many states, make a seperate binary for each
12:32:55 <bitemyapp> dmj`: the problem is that I'm trying to have a conversation
12:32:59 <dmj`> bitemyapp: no more opening and closing
12:33:02 <bitemyapp> dmj`: and you're just invested in "winning" and getting me to shut up
12:33:13 <bitemyapp> dmj`: you are losing by not simply conversing with me.
12:33:22 <bitemyapp> you won't engage with what I'm saying, admit any limitations of any kind.
12:33:26 <bitemyapp> acid-state is perfect or you're wrong. That's it.
12:33:35 <bitemyapp> That's the front you're presenting. It's disingenous and a serious turn-off.
12:33:46 <dmj`> bitemyapp: I'm not winning, I'm trying to explain to you how I use acid-state, and how this isn't a problem for me and you keep saying "it sucks just because it sucks"
12:33:49 <bitemyapp> And is as much a reason not to use acid-state as anything else because nobody can trust you to say when/where acid-state might fail.
12:34:07 <dmj`> bitemyapp: please don't trust me, use it for yourself
12:34:17 <bitemyapp> dmj`: you have seriously misunderstood how database failure works
12:34:24 <bitemyapp> dmj`: databases don't fail in the happy-path example webapp case
12:34:31 <LtRipley> hey
12:34:36 <bitemyapp> dmj`: testing how databases fail requires knowledge of the design and focused investigation
12:34:41 <levi> Guys, do you think you're going to get anywhere with this discussion? It doesn't sound like it, at this rate.
12:34:42 <dmj`> bitemyapp: comments like that, and "No other database has issues" show how this conversation can't even be had
12:34:49 <bitemyapp> dmj`: the person best equipped to do this is the person that wrote or maintains the database
12:34:52 <nkar> jle`: it's fine, I just keep forgetting about 'maybe' and 'fromMaybe'.  I've thought they're obscure and avoided them, but now I'm not sure
12:34:59 <LtRipley> how can i easily the performance of a haskell programm?
12:35:05 <bitemyapp> dmj`: if the people in that position are engaging in faith-based marketing and won't admit any faults, *you should not use their database*
12:35:10 <bitemyapp> LtRipley: profiling
12:35:17 <bitemyapp> LtRipley: EKG
12:35:23 <sm> bitemyapp, dmj`: some interesting info but can you avoid killing #haskell's happiest-place-on-earth reputation
12:35:24 <LtRipley> LtRipley: that is the name of a profiler?
12:35:33 <danharaj> LtRipley: http://book.realworldhaskell.org/read/profiling-and-optimization.html
12:35:35 <sm> pretty please ?
12:35:55 <bitemyapp> dmj`: stop jumping all over me when I mention acid-state is better used where one would use sqlite please.
12:35:59 <bitemyapp> dmj`: that's all I have to say.
12:36:08 <dmj`> this isn't faith-based, multiple states with RPC is a better way to use acid-state, with no exceptions thrown in your transactions, and seperate processes for each state, infrequenct checkpoints, and no shut downs. That is my entire point.
12:36:43 <dmj`> bitemyapp: I'm not jumping all over you, please stop saying it sucks when you've never used it
12:37:02 <bitemyapp> dmj`: Uhm. All I said originally was that it didn't replace online databases like PostgreSQL
12:37:06 <jle`> nkar: maybe is actually one of the most fundamental operations on `Maybe`...it's basically `foldr` (flipped) for Maybe.  it should really be the main way you break down Maybes in functions :)
12:37:08 <bitemyapp> dmj`: and that it was a good alternative to sqlite.
12:37:13 <bitemyapp> dmj`: that's all I said. You got defensive and hostile.
12:37:20 <dmj`> bitemyapp: you said, "It shouldn't be used for production"
12:37:25 <bitemyapp> right, it shouldn't
12:37:26 <dmj`> biteyapp: "it has issues"
12:37:28 <bitemyapp> it does
12:37:35 <bitemyapp> dmj`: can we not do this?
12:37:37 <jle`> `maybe` is the church encoding/decomposition of Maybe
12:37:37 <dmj`> bitemyapp: You speak from ignorance because you've never used it in production
12:37:39 <bitemyapp> dmj`: somebody asked us to stop.
12:37:42 <bitemyapp> dmj`: so lets stop now.
12:37:48 <bitemyapp> jle`: aka final encoding, yeah?
12:38:03 <nkar> jle`: I've been mostly using 'case' for that
12:38:51 <bartavelle> nkar, you also have "either" and "bool" that serve the same purpose for those data types
12:39:06 <jle`> a `maybe` with the arguments switched is pretty much identical in power and expressiveness as a case statement
12:39:28 <jle`> caseMaybe m f d = maybe d f m
12:39:52 <jle`> caseMaybe m (\x -> stuff with x in case of Just) (nothing result)
12:40:06 <jle`> case m of Just x -> stuff with x in case of Just; Nothing -> nothing result
12:40:13 <Kron> How do I get my cabal test to list the number of tests rather than just say "1 of 1 test suites (1 of 1 test cases) passed"?
12:40:17 <jle`> but yeah, a lo of times case is much nicer
12:40:53 <levi> case is the low-level primitive for selecting among alternatives, while functions like 'maybe' and 'either' provide a higher-order function interface to case-selection for specific polymorphic data types.
12:41:24 <bryanedds> getting set up to use Haskell for the first time is both thrilling and terrifying
12:41:56 <jle`> :t flip foldr
12:41:57 <lambdabot> b -> (a -> b -> b) -> [a] -> b
12:41:59 <jle`> :t maybe
12:42:00 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:42:17 <jle`> basically the same thing :) if you assume that Maybe is a list with 0 or 1 elements
12:43:49 <speak> bryanedds: I agree :) Just getting started, myself
12:44:16 <speak> I really dig the idea of separating pure code from non-pure
12:45:08 <hexagoxel> saml: do you really have a tuple with four booleans?
12:45:40 <saml> > [((testBit x 1, testBit x 2), (testBit x 3, testBit x 4)) | x <- [0..14]]
12:45:42 <lambdabot>  [((False,False),(False,False)),((False,False),(False,False)),((True,False),(...
12:45:46 <saml> i don't know what i'm doing
12:45:49 <nkar> jle`: when I was asking the question 8 hours ago, I was thinking of a more general combinator, though
12:46:31 <levi> jle`: And they're basically the same thing because both Maybe and List are data types with alternative structures, i.e. they're sum types/disjoint union types. And 'case' is the primitive feature to discriminate between the types of disjoint union members.
12:47:16 <hexagoxel> saml: well what do you _want_? type signature might be helpful..
12:48:00 <levi> Pattern matching of alternatives desugars to case-based expressions, so you'll find that all combinators like 'maybe' and 'either' are implemented in terms of 'case'.
12:48:36 <benzrf> haskell is essentially the lambda calculus plus `data' and `case'!!!
12:48:42 <benzrf> and type classes
12:48:43 <benzrf> s
12:48:53 <levi> Indeed.
12:49:14 <exio4> λ-calculus is the assembler of functional languages
12:49:20 <Polarina> Why doesn't cabal-install tell what files it is compiling? All I have is "Building package-x.y.z..." for a couple of minutes and no other output.
12:49:33 <benzrf> Polarina: have you tried -v
12:49:36 <benzrf> or -vv
12:49:41 <benzrf> or -vvvvvvvvvvvvvvvvvvvvvv
12:49:42 <bartavelle> Polarina, probably using -j, which enables parallel compilation and hides details
12:54:25 <saml> hexagoxel, i was trying to see what this was doing https://gist.github.com/anonymous/037e6052a73b03dc12c1
12:55:44 <LtRipley> can i use some kind of list, where i can efficiently add to the end and read from the head? or the other way around?
12:56:02 <LtRipley> LtRipley: like a double linked list
12:56:05 <dibblego> LtRipley: Data.DList
12:56:34 <dibblego> though "read" is O(n)
12:56:43 <dibblego> adding to the start and end is O(1)
12:57:08 <LtRipley> read?
12:57:24 <LtRipley> like random access?
12:57:25 <levi> LtRipley: There are many different data structures available on Hackage. You might try the 'containers' package.
12:57:53 <dibblego> LtRipley: obtaining the first or last element is O(n)
12:58:05 <LtRipley> that is not what i am looking for
12:58:14 <dibblego> LtRipley: there are other structures that compromise on that, such as Data.Sequence or Data.Vector
12:58:47 <LtRipley> i just need the equivalent to a double linked list
13:00:07 <cjenkin1> LtRipley: "add to the end and read from the head" sounds like a queue
13:00:52 <cjenkin1> or a circularly linked list
13:01:00 <LtRipley> cjenkin1: i want to be able to read the list from both ways
13:01:19 <levi> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.5.1/Data-Sequence.html
13:01:48 <cjenkin1> LtRipley: Well, I guess a deque?
13:04:26 <LtRipley> maybe there is a better solution to this. I have this simple function returning primes, and i want to optimize it but i can't because the list i have in that function is the wrong way aroun: http://pastebin.com/EV6w9uJA
13:04:42 <hexagoxel> saml: just start with 0. &1 != 0 is the least significant bit, which you check for with {testBit x 0}
13:06:10 <LtRipley> so i want to only check indivisible for all primes which are smaller than the squareroot of the number to checj, but as primes are in descending order i cannot use takeWhile
13:06:29 <awestroke> takeWhile . reverse
13:07:20 <awestroke> or dropWhile
13:07:49 <awestroke> > dropWhile (< 3) [1,2,3,4,5,1,2,3]
13:07:51 <lambdabot>  [3,4,5,1,2,3]
13:08:01 <latk> Has anyone use the fullstop package (http://hackage.haskell.org/package/fullstop)? I'm looking for something able to spilt text into paragraphs.
13:08:03 <latk> er, sentences
13:08:18 <LtRipley> awestroke: but this won't improve any performance, i want to avoi checking those numbers because i don't want to check all the numbers
13:08:40 <LtRipley> awestroke: using dropwhile i still have to check for each number in the list, an using reverse i will probably also ad O(n) runtime
13:08:50 <awestroke> LtRipley: then Data.Sequences linked by levi about seems to fit the bill with the O(1) start and end indexing
13:09:04 <awestroke> above* damn I'm tired
13:09:38 <LtRipley> i will check it out
13:14:40 * hackagebot cereal 0.4.1.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.4.1.0 (TrevorElliott)
13:15:21 <Johannes13> I get an error when I try to install leksah on windows with "calbal install leksah": gtk3-0.13.0.1 depends on cairo-0.13.0.1 which failed to install.
13:17:13 <merijn> Try installing cairo with -v3
13:17:45 <levi> Johannes13: Do you have some more specific errors reported?
13:18:20 <Johannes13> sec, I'll pastbin all the stuff
13:19:06 <Johannes13> http://pastebin.com/LRBEriN4
13:20:10 <merijn> Johannes13: "Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin)."
13:20:20 <merijn> Says so right there in the output
13:20:26 <Johannes13> too many log lines...
13:22:13 <arianvp> If I have a binary operations that has two identities. does it mean it forms two monoids?
13:22:22 <arianvp> for example, the biconditional both has True and False as identity.
13:22:40 <merijn> arianvp: Yes
13:22:46 <merijn> arianvp: Well, maybe
13:22:46 <Johannes13> why isn't that a dependency?
13:23:08 <merijn> Johannes13: Because ghc doesn't track executables, so cabal doesn't know how to install them
13:23:18 <arianvp> also given that the operation is assoc of course
13:23:19 <merijn> Well, it knows how to install them
13:23:29 <merijn> Just not as build dependency
13:23:43 <merijn> arianvp: Consider Int and Sum/Product newtypes
13:23:53 <merijn> Two monoids there too
13:23:55 <Johannes13> setup.exe: The program pkg-config version >=0.9.0 is required but it could not be found.
13:24:07 <arianvp> yeh. but those have two distinct (op,id) pairs
13:24:11 <arianvp> whilst here id is the same for two ops
13:24:21 <merijn> arianvp: So? :)
13:24:40 * hackagebot haskell-neo4j-client 0.2.0.2 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.0.2 (asilvestre)
13:24:45 <merijn> arianvp: A monoid is a triple of 1) set of elements 2) binary operation 3) identity
13:24:55 <merijn> arianvp: Change any of the three and you have a different monoid
13:24:58 <Johannes13> monoids are cool
13:25:06 <arianvp> monoids are cool indeed
13:25:42 <Johannes13> I usually call the identity also "neutral element"
13:26:08 <Zoxc> How can I remove the temp binding in do { temp <- func1; val <- func2 temp } ?
13:26:31 <Johannes13> func1 >>= func2
13:27:36 <Johannes13> (I hope that's correct, I'm new with haskell)
13:28:48 <pjdelport> @undo do { temp <- func1; val <- func2 temp; return val }
13:28:49 <lambdabot> func1 >>= \ temp -> func2 temp >>= \ val -> return val
13:28:54 <pjdelport> @. pl undo do { temp <- func1; val <- func2 temp; return val }
13:28:54 <lambdabot> func2 =<< func1
13:29:00 <pjdelport> Magic :)
13:31:42 <etandel> nice
13:32:20 <Johannes13> func1 >>= (\ temp -> func2 temp) >>= (\ val -> return val) = func1 >>= func2
13:34:03 <merijn> Equational reaspnong \o/
13:34:08 <merijn> *reasoning
13:34:42 <Johannes13> where can I get my pkg-config? http://pastebin.com/RUnFJ4BM
13:35:12 <Johannes13> >>= return = id
13:35:28 <Johannes13> foo >>= return = id foo
13:35:30 <merijn> Johannes13: pkg-config is a C library tool, you can install it from your package manager
13:35:57 <Johannes13> merijn, windows still doesn't have a package manager
13:36:06 <Johannes13> (and I hate windows for that)
13:39:05 <RedNifre> Hey there.
13:39:41 * hackagebot acid-state 0.12.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.12.3 (DavidJohnson)
13:39:46 <LtRipley> where can i find an example that uses Data.Sequence? i found the source code itself, but i a am to noob to completely understand what is going on
13:40:32 <c_wraith> LtRipley: don't even try to understand the code in Data.Sequence.  Irregular data structures and polymorphic recursion are not simple. :)
13:41:01 <RedNifre> I can't figure out how contexts work. (Read a) => a -> z works, but how can I do (Read a) (Read b) => a -> b -> z?
13:41:19 <LtRipley> c_wraith: if i want to learn haskell i need to be able to read the code :D
13:41:19 <c_wraith> RedNifre: (Read a, Read b) => a - > b -> z
13:41:46 <c_wraith> LtRipley: sure, but Data.Sequence is an advanced data structure.  Advanced data structures are hard to follow in every language.
13:42:54 <c_wraith> LtRipley: I mean, do you know how 2-3 finger trees work offhand?  I sure don't. I can only tell you about a couple of their properties.
13:43:24 <c_wraith> LtRipley: (and yes, Data.Sequence is a 2-3 finger tree)
13:43:29 <RedNifre> Hah, how simple :o) thanks.
13:43:37 <glguy> LtRipley: Are you asking how to use a Sequence or how to implement one, and if you're struggling with some of the implementation there is a paper you can read about how they work, if you don't know what the code does you should ask about specific code
13:43:59 <LtRipley> glguy: no, i am looking how to use one
13:44:36 <glguy> Have you look at the documentation yet? http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Sequence.html
13:44:38 <LtRipley> i could google for the source but not for application examples
13:44:50 <c_wraith> LtRipley: The documentation is actually fine on how to use them. It doesn't have examples, but it has fantastic descriptions of what the operations do and how they perform.
13:45:40 <LtRipley> c_wraith: yes, but it still needs some guesswork, as i have never used any data structure in haskell
13:45:41 <c_wraith> LtRipley: and it's just a data structure. What would examples provide?  "Here I am, adding elements to one side and removing them from the other. I've got a queue. whoop-de-doo, I'm amazing at using this incredibly complicated data structure via 3 exceptionally well-named functions"
13:46:28 <LtRipley> c_wraith: e.g. how to prefix a call to empty to actually use it?
13:46:41 <c_wraith> empty is a value, not a function. :)
13:46:54 <c_wraith> type signatures are important!
13:47:26 <LtRipley> don't know what you want to tell me
13:47:39 <S11001001> @ty (&&&)
13:47:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:48:02 <LtRipley> c_wraith: so there are no functions without parameters?
13:48:09 <c_wraith> LtRipley: that's correct
13:48:34 <c_wraith> LtRipley: empty is just a (polymorphic) value.  It *is* an empty list of whatever element type you want.
13:49:09 <c_wraith> LtRipley: thanks to immutability, it can't ever be changed - so you don't need to create new ones all the time
13:49:52 <c_wraith> LtRipley: and that's why all the functions that "modify" a Seq return a new one.  It's impossible to change a Seq value. All you can do is create a new one based on it.
13:50:02 <Rags> I have a function f :: Char -> String -> (String, String) and a l :: [Char]. how do i apply f to every element and chain the second in the tuple to the next
13:50:18 <c_wraith> LtRipley: (and thanks to immutability and clever data structure design, most of the structure is shared between the old and the new ones, so it's efficient to update)
13:50:20 <LtRipley> c_wraith: yes, i understan the concept of immutability
13:50:34 <LtRipley> i just don't know haskell :)
13:51:00 <artyomkazak> LtRipley: alternatively, you could say that there's no sharp distinction between functions and values, since every function *is* a value. If you want to fully understand what “everything is a function in Haskell” means, read this post: http://conal.net/blog/posts/everything-is-a-function-in-haskell
13:51:13 <c_wraith> LtRipley: open up ghci, and import Data.Sequence.  just type "empty" at the prompt.  Then start working with other functions.  You'll figure it out really fast.
13:51:50 <LtRipley> i tried print empty which didn't work
13:52:00 <LtRipley> oh it id
13:52:10 <LtRipley> i thought i had to fully qualify it
13:52:20 <artyomkazak> > print Data.Sequence.empty
13:52:21 <lambdabot>  Not in scope: ‘Data.Sequence.empty’
13:52:28 <artyomkazak> hm, darn
13:52:36 <mauke> > Seq.empty
13:52:38 <lambdabot>  fromList []
13:52:41 <artyomkazak> ouch, right
13:52:53 <artyomkazak> > print Seq.empty
13:52:54 <lambdabot>  <IO ()>
13:53:02 <LtRipley> IO? :O
13:53:03 <artyomkazak> > show Seq.empty
13:53:05 <lambdabot>  "fromList []"
13:53:12 <merijn> Lambdabot doesn't do IO
13:53:13 <artyomkazak> LtRipley: lambdabot doesn't allow IO
13:55:51 <toors> is there any way to legally write a list [Sum 1, Product 2]? Was wondering if it could be generalized to [Monoid Int]
13:56:17 <Clint> what would that even mean
13:56:49 <S11001001> @kind IndexPreservingSetter
13:56:50 <lambdabot> * -> * -> * -> * -> *
13:56:56 <S11001001> meh
13:57:37 <pjdelport> toors: Monoid m => [m Int] implies that all the list elements are the same Monoid instance.
13:57:40 <LtRipley> i think i really should look for an example how Sequence or DList is used, i cannot just guess on how to use it
13:58:03 <LtRipley> how do i write a DList literal?
13:58:34 <merijn> pjdelport: That's a kind error
13:58:41 <mauke> LtRipley: no such thing
13:58:43 <toors> ok i see thank you.
13:59:00 <merijn> Monoid instance have kind *
13:59:06 <pjdelport> merijn: Err, right, yes. I meant Monoid m => [m]
13:59:07 <pjdelport> :)
13:59:19 <LtRipley> mauke: so i can't do pattern matching?
14:00:14 <pjdelport> LtRipley: You use fromList, cons, etc. to create Dlists
14:00:29 <mauke> LtRipley: not on functions
14:00:50 <joshc> there is an IsList instance for DList, if you wanted to use OverloadedLists
14:01:19 <LtRipley> pjdelport: i don't understand
14:01:30 <LtRipley> mauke: dlist is a function?
14:01:46 <mauke> LtRipley: yes
14:02:11 <LtRipley> i thought it was just a moule with some values and a set of functions
14:02:14 <LtRipley> module
14:02:34 <mauke> reference error. what is "it"?
14:02:43 <LtRipley> dlist
14:03:01 <mauke> that could be a package name
14:03:01 <benzrf> overloaded lists.
14:03:03 <LtRipley> still looking for a simple example
14:03:05 <mauke> it's not a module or a type
14:03:10 <mauke> those have uppercase names
14:03:20 <LtRipley> mauke: i am talking about Data.DList
14:03:29 <LtRipley> what are you talking about?
14:03:30 <mauke> that's a module
14:03:37 <mauke> LtRipley: in what context?
14:03:54 <LtRipley> mauke: i asked you whether dlist was a function, and you said yes
14:04:11 <mauke> yes, because I thought you meant "DList a" when you said "dlist"
14:04:17 <mauke> but then you said something about modules
14:04:29 <LtRipley> now you totally lost me
14:04:42 * hackagebot bake 0.1 - Continuous integration system  http://hackage.haskell.org/package/bake-0.1 (NeilMitchell)
14:04:43 <mauke> http://hackage.haskell.org/package/dlist-0.7.1/docs/Data-DList.html#g:1
14:05:16 <LtRipley> oh the doc for dlist actually has an example
14:10:35 <LtRipley> doesn't seem to be the simplest example, i am just looking for a way to replace a list with a DList
14:11:16 <mauke> fromList thatlist
14:11:22 <mauke> now it's a DList :-)
14:11:56 <LtRipley> i mean in the whole function definition
14:12:21 <mauke> what function?
14:13:41 <LtRipley> mauke: i want nextPrime to use a DList http://pastebin.com/EV6w9uJA
14:14:42 * hackagebot uri 0.1.6.3 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.6.3 (JaroslavGridin)
14:14:44 <mauke> why?
14:15:02 <mauke> I don't see how that would help with anything
14:15:55 <LtRipley> i want to optimize the program and the first step would be to be able to access the end of the list in constant time
14:16:15 <LtRipley> let's just assume it would help me, how would i do it?
14:16:18 <mauke> DList doesn't help with that
14:16:31 <mauke> I have no idea how you'd use DList for this
14:16:49 <LtRipley> ok then let's do it for Data.Sequence
14:16:55 <mauke> nextPrime prepends an element to a list
14:17:06 <mauke> doing that with a list is already optimal
14:17:50 <LtRipley> mauke: but i don't want to check indivisible for all previous primes, but only for those that are smaller than the squareroot of the next prime to test
14:18:03 <LtRipley> i cannot use takeWhile because the list is sorted descending
14:18:31 <LtRipley> i am looking for any data structure which makes my life easier, but i don't know how to use any data structure
14:18:42 <LtRipley> i am just looking for simple examples how any data structure is used in the real world
14:18:44 <SrPx> Hello, is it possible to use a view pattern that crosses types? That is, ´foo (view → MyConstructor)´ where ´view´ comes from `class ToMyType a where view a :: a → MyType´
14:19:20 <SrPx> where view :: a → MyType *
14:19:57 <benzrf> SrPx: oh i s e e
14:21:12 <LtRipley> has anyone here ever used a sequence or a DList?
14:21:40 <mauke> I've used both
14:22:16 <johnw> DLists are as easy as using Endo (xs ++), and then appEndo xs [] at the end of it all
14:22:37 <johnw> (might be ++ xs, can never remember)
14:22:42 <SrPx> benzrf: uhmmm?
14:22:51 <LtRipley> johnw: i don't even know what you are talking about
14:22:56 <merijn> johnw: Not very helpful for a beginner, I'm guessing :)
14:23:01 <johnw> ah, ok
14:23:03 <benzrf> SrPx: i am n ot sure
14:23:04 <johnw> I was aiming at intermediate
14:23:15 <SrPx> hmm
14:23:37 <LtRipley> i think i have to give up, i can't even find the simplest example. and here i end up discussing stuff that is way to advanced for my level of haskell
14:23:48 <silasm> LtRipley: are you looking to learn data structures, or to make the code in your particular lpaste efficient?
14:24:23 <silasm> Because you can get O(1) access in your lpaste with lists; you don't need anything more complicated.
14:25:01 <silasm> you just need to reorganize things.
14:25:11 <LtRipley> silasm: i want to further optimise the program, thus i need to be able to have some kind of linked list i can use from both sides
14:25:31 <mauke> I don't think you need that
14:25:32 <LtRipley> silasm: in the end i want to learn haskell, so i don't think it would be wrnog to learn about data structures and how to use them
14:26:02 <LtRipley> mauke: of course there are different ways, but that is the best i could come up with and i don't think the idea is that bad
14:26:14 <mauke> it confuses me
14:26:17 <LtRipley> the only problem is that i fail with the syntax
14:26:20 <mauke> I don't even know where to start
14:27:01 <LtRipley> so i am looking for a simple example that uses any data structure, i couldn't find it in learnyouahaskell or with google
14:27:31 <LtRipley> mauke: telling me that what i do is wrong, doesn't really help me :)
14:27:56 <marchelzo_> an example of what
14:28:01 <kadoban> LtRipley: lyah definitely has some data structure use in it. I'd take it slow, if you can't figure out your current thing, go back and look at the learning material more.
14:28:06 <mauke> DList optimizes the case where you're building a big list from many small lists, and you don't need to inspect the intermediate results until you're done
14:28:38 <LtRipley> mauke: maybe it is the wrong data structure, but it might still help me understanding how data structures are used
14:28:42 <mauke> I don't understand what you're looking for
14:28:53 <mauke> you're already using a data structure: lists
14:29:01 <benzrf> cps!!!!!!
14:29:24 <LtRipley> i am looking anything that works like a double linked list
14:29:41 <LtRipley> append, head, prepend in O(1)
14:29:52 <johnw> i think you want a sequence
14:29:55 <johnw> Data.Sequence
14:30:10 <LtRipley> johnw: i found the doc for Data.Sequence, but i don't know how to use it
14:30:13 <mauke> ok, what's unclear about the functions in Data.Sequence?
14:30:17 <Johannes13> where can I get my pkg-config? http://pastebin.com/RUnFJ4BM
14:30:32 <LtRipley> i am looking for an example how to use it
14:30:43 <RedNifre> Can I turn a record into a tuple?
14:30:55 <mauke> LtRipley: why can't you just write one?
14:31:03 <LtRipley> i have no friggin clue about the syntax so my attempt to replace the list with a sequence is just trial and error
14:31:13 <mauke> the syntax is ... haskell
14:31:17 <LtRipley> forget it...
14:31:17 <mauke> the stuff you've been using all along
14:31:24 <LtRipley> i give up
14:31:44 <RedNifre> I missed the chat. What are you trying to do?
14:31:46 <NemesisD> is there a common shorthand for the idiom foo [a] -> [(a, a)], foo xs = [(x,x) | x <- xs]. perhaps something from arrow?
14:32:07 <mauke> map (join (,))
14:32:24 <LtRipley> RedNifre: thanks, but it is too late for me anyways :)
14:32:27 <LtRipley> good night
14:32:30 <RedNifre> night
14:32:39 <NemesisD> that one is a little less clear than the comprehension i think
14:33:14 <mauke> a lot less clear
14:33:32 <merijn> NemesisD: That or "map (\x -> (x,x))", not really sure what you're expecting...
14:33:54 <merijn> :t map (id &&& id)
14:33:55 <lambdabot> [c'] -> [(c', c')]
14:34:14 <NemesisD> ah ok. yeah that was i was looking for, but i think ill stick with the comprehension
14:34:16 <NemesisD> thanks
14:34:24 <Guest85542> Hey guys. I am trying to do an assignment and I'm asked to define the list of all the ways that a list can be split in two, which is fine. Except they want me to define the function as [a] -> ([a], [a]). Can someone make sense of this for me?
14:34:43 * hackagebot quickcheck-webdriver 0.1.0.7 - Utilities for using WebDriver with QuickCheck  http://hackage.haskell.org/package/quickcheck-webdriver-0.1.0.7 (christianpbrink)
14:35:03 <mauke> Guest85542: that looks wrong to me
14:35:16 <Guest85542> mauke: no lie.
14:35:32 <RedNifre> How can I get the field values of a record that I don't know? In my head it look somewhat like "doWithRecord {a,b,c} = show b". How to do that?
14:36:17 <merijn> Guest85542: What's the criterium for deciding where to split?
14:36:21 <mauke> RedNifre: what would the type of that function be?
14:36:36 <merijn> mauke: You could write that split function in a way that works, with O(n) complexity
14:36:53 <merijn> mauke: If you use the tortoise and hare approach to find the middle
14:37:01 <mauke> merijn: with that signature?
14:37:03 <mauke> unlikely
14:37:09 <merijn> mauke: Wanna bet? :D
14:37:13 <mauke> yes
14:37:17 <merijn> It won't work on infinite lists, but sure
14:37:18 <benmachine> merijn: reread the spec
14:37:22 <RedNifre> It would be doWithRecord :: (Show a, Show b, Show c) => {a,b,c} -> String
14:37:32 <mauke> RedNifre: {a,b,c} is not a type
14:37:34 <benmachine> merijn: the list of *all* the ways
14:37:39 <merijn> ah
14:37:42 <benmachine> merijn: the return type isn't even a list
14:38:08 <merijn> ok, not all possible splits with that result
14:38:12 <merijn> I missed that bit
14:38:24 <RedNifre> Yeah, well... How would I declare a function that takes an unknown record as input, where the record has exactly two fields which are both Show?
14:38:32 <merijn> RedNifre: You can't
14:38:48 <merijn> RedNifre: "unknown record" is not a sensible notion in haskell
14:38:48 <RedNifre> Why not?
14:39:05 <mauke> RedNifre: what would that be good for?
14:39:07 <RedNifre> But records and tuples appear to be nearly the same thing to me.
14:39:23 <mauke> tuples are one specific "record" type
14:39:25 <Guest85542> merijn: the original function is defined as: http://pastebin.com/YU3qit0S
14:39:40 <Guest85542> merijn: additional details contained in the link.
14:40:00 <merijn> Guest85542: Your return type is not a list, so your example result is wrong
14:40:02 <RedNifre> Yeah, but you can map from a record to a tuple (but not back) and I only need the info from the tuple.
14:40:03 <Johannes13> :src (&&&)
14:40:06 <mauke> Guest85542: looks like a typo. should be splits :: [a] -> [([a], [a])]
14:40:14 <benmachine> Guest85542: looks like that splits function is correct per spec, and the type asked for you is just a mistake
14:40:18 <Guest85542> mauke: tat's what I tought
14:40:18 <benmachine> *asked of you
14:40:31 <Guest85542> See, that's what I was thinking
14:40:38 <benmachine> you can generalise from Char to a easily enough
14:40:42 <RedNifre> Say, if you had data Bla = Bla String Integer, I would be happy if I had (String,Integer) to match against.
14:41:00 <benmachine> RedNifre: you either have to write a function Bla -> (String,Integer), or be sad
14:41:00 <mauke> so write a function Bla -> (String, Integer)
14:41:04 <Guest85542> so, you think they just want it returned as list, instead of a string, inside of the tuple?
14:41:25 <benmachine> Guest85542: a String is just a certain kind of list
14:41:31 <Guest85542> benmachine: lo se
14:41:43 <Guest85542> Still though, a more generalized list then.
14:42:05 <benmachine> I do not understand that thing you said
14:42:13 <Guest85542> benmachine: lo se == "I know"
14:42:16 <benmachine> but yes, I'd guess they want a general form
14:42:21 <Guest85542> thanks
14:42:35 <benmachine> but I'm not particularly better at guessing the minds of strangers than you, I'd imagine :P
14:42:46 <RedNifre> What can I do with unknown records? I guess I can only do with them what I know through known instances of them?
14:42:49 <RedNifre> hm.....
14:43:03 <benmachine> RedNifre: you can't have an unknown record
14:43:04 <mauke> time for Data.Data.Data
14:43:04 <RedNifre> Writing the function is impossible because I don't know the record.
14:43:17 <benmachine> RedNifre: there's no context in which you know something is a record without also knowing which one it is
14:43:25 <RedNifre> benmachine yes you can, if that record has an instance that you know.
14:43:33 <RedNifre> or at least I surely hope so.
14:43:37 <benmachine> sure, but it's not much of a record, then
14:43:37 <mauke> you still won't know it's a record
14:43:39 <benmachine> it's just a thing
14:43:52 <RedNifre> right. and i can't get the fields.
14:43:57 <mauke> ooh, I know
14:44:04 <phaazon> being curious, when Monad will be defined as class (Applicative f) => Monad f where…, will we still have liftM? I guess not, since it would be redundant, but maybe for silly compat issues it won’t vanish?
14:44:05 <mauke> just 'show' the whole thing, then parse the fields out
14:44:15 * benmachine awards mauke a gold star
14:44:25 <RedNifre> that doesn't work if it's not showable.
14:44:26 <Fuuzetsu> phaazon: liftM = apa
14:44:26 <mauke> I'm a genius
14:44:32 <Fuuzetsu> liftM = ap   *
14:44:38 <benmachine> Fuuzetsu: that is false
14:44:42 <phaazon> yeah
14:44:42 <Fuuzetsu> :t liftM
14:44:43 <mauke> RedNifre: your original constraint was that all fields are showable
14:44:43 <Fuuzetsu> :t ap
14:44:43 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:44:45 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:44:45 <phaazon> and = fmap
14:44:47 <Fuuzetsu> oops
14:44:49 <phaazon> :t fmap
14:44:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:44:53 <benmachine> phaazon: there is still one legit use of liftM, which is using as a definition for fmap
14:44:55 <Fuuzetsu> well, point being it won't be removed
14:45:03 <phaazon> benmachine: well
14:45:04 <phaazon> in my code
14:45:09 <RedNifre> right, that was a simplification. And even if that was the case it would not guarantee that the whole record is showable. hm.
14:45:21 <phaazon> I’m using something like (MonadIO m,MonadPlus m,…) => m a
14:45:21 <RedNifre> ah, it's too late. I'll continue thinking tomorrow. Good night!
14:45:27 <phaazon> and I’m using fmap, and of course it doesn’t work
14:45:32 <phaazon> since I don’t have Functor f
14:45:34 <Fuuzetsu> :t (<*>)
14:45:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:45:38 <phaazon> so I switch to liftM
14:45:45 <Fuuzetsu> I forget that <*> = ap , not liftM
14:45:56 <Fuuzetsu> apparently remembering that liftM = fmap is too hard for my small brain
14:46:15 <phaazon> Fuuzetsu: fmap is a lift from function to functor
14:46:18 <benmachine> Fuuzetsu: I thought it was weird how you did that since it should be obvious from how <*> is pronounced
14:46:24 <phaazon> I just feel frustrated
14:46:25 <benmachine> then I remembered that that doesn't make any sense
14:46:34 <phaazon> since fmap *should* be usable on a Monad
14:46:38 <Fuuzetsu> benmachine: I don't pronounce most of my operators ;)
14:46:38 <benmachine> phaazon: it will be, soon
14:46:41 <phaazon> the Functor is implicit
14:46:43 <phaazon> ok benmachine :)
14:46:44 <phaazon> nice
14:46:49 <benmachine> GHC 7.10 I think?
14:46:59 <Fuuzetsu> yes
14:47:03 <Fuuzetsu> the changes are done already
14:47:05 <chirpsalot> benmachine: didn't we say GHC 7.8 before it came out too :P?
14:47:10 <phaazon> what are they?
14:47:10 <chirpsalot> Sweet!
14:47:12 <benmachine> chirpsalot: no I think 7.10 was always the plan
14:47:20 <phaazon> Applicative f on Monad
14:47:20 <benmachine> well, maybe
14:47:24 <phaazon> and Functor f on Applicative?
14:47:30 <benmachine> plus, like, the development version of 7.10 actually has the actual changes
14:47:34 <chirpsalot> benmachine: maybe I'm wrong.
14:47:35 <benmachine> phaazon: the latter is already the case
14:47:42 <benmachine> chirpsalot: hey, me too
14:47:43 <chirpsalot> benmachine: that's awesome!
14:48:01 <phaazon> benmachine: legit since Applicative went after Monad
14:48:05 <phaazon> ok, thanks for the nice answer :)
14:48:20 <chirpsalot> phaazon: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
14:48:33 <phaazon> thanks
14:48:37 <mhall> hey guys. is there an equivalent 'strMsg' function for exceptions? i'm working on the lyahs tutorial and i'm confused by the deprecated `Error` module being different than `Except`
14:48:44 <dfeuer> Oof. I got sucked into a stage1 build :-(
14:48:50 <benmachine> phaazon: the weird thing is I think some early version of Haskell actually did have Functor m => Monad m
14:49:40 <chirpsalot> benmachine: I thought in the first Haskell-cast Edward said 7.8, but thinking on it now it was probably 7.10.
14:50:16 <phaazon> benmachine: « version of Haskell » ?
14:50:23 <phaazon> you mean, ghc ?
14:50:28 <benmachine> phaazon: no, the language standard
14:50:31 <phaazon> oh
14:50:39 <dfeuer> chirpsalot, there had to be a release with a warning first to get (to the extent possible) everyone's code updated before actually pulling the trigger.
14:50:39 <phaazon> so ghc doesn’t implement it correctly!
14:51:00 <chirpsalot> The one that kind of makes me upset is map. It'd be nice if fmap was just map, but I understand it makes the error messages worse for list code with newbies.
14:51:10 <benmachine> phaazon: ghc implements a later standard
14:51:12 <chirpsalot> dfeuer: oh, and that was implemented in 7.8? Gotcha!
14:51:17 <Fuuzetsu> you mean if map was just fmap?
14:51:43 <chirpsalot> Fuuzetsu: yeah. Whoops. I have a bit of a fever, haha.
14:51:46 <xaimus> chibitech :D
14:51:51 <benmachine> well, either way around, depending on how you think
14:51:51 <xaimus> whoops, wrong window. sorry!
14:51:55 <phaazon> sometimes, I do use fmap on lists… :D
14:52:31 <Fuuzetsu> <$> instead of map is pretty boss
14:53:33 <chirpsalot> I don't like using <$> all that much. I find it harder to read often, but maybe I'm just not used to it.
14:53:56 <benmachine> phaazon: actually I went and looked up the Haskell 1.4 standard and I might have been making that thing up
14:53:59 <benmachine> don't really remember
14:54:00 <phaazon> I use <$> when writing applicative style computations
14:54:15 <phaazon> I prefer using <$> and <*> instead of liftA* since it enables me to omit parens
14:54:29 <chirpsalot> I'm a bit new, so I guess all of the applicative stuff hasn't quite set in for me yet :).
14:54:38 <phaazon> it will for sure
14:55:03 <phaazon> I think applicative functors is one of the most beautiful things in all that kind of stuff :)
14:55:23 <Fuuzetsu> need banana brackets ;(
14:55:30 <chirpsalot> Banana brackets?
14:55:34 <benmachine> the 1.4 standard did have the Void type though
14:55:44 <phaazon> ahahahaha
14:55:47 <benmachine> so that's cool
14:55:47 <phaazon> banana brackets
14:55:49 <phaazon> nice one
14:55:59 <Fuuzetsu> they let you write stuff like (| Foo a b c d e |) instead of Foo <$> a <*> b <*> c <*> d <*> e
14:56:10 <kadoban> chirpsalot: Idiom brackets for applicative, basically leaving out the...yeah what he said.
14:56:14 <exio4> phaazon: the beautiful thing is that it is just a bunch of stuff implemented with typeclasses!
14:56:23 <Fuuzetsu> kadoban: it's more fun to call them banana brackets ;P
14:56:26 <phaazon> exio4: yeah :)
14:56:30 <kadoban> I do like that name :)
14:56:36 <benmachine> mhall: to answer your question about strMsg, I'm not sure, I think people generally don't like strMsg
14:56:42 <chirpsalot> Fuuzetsu: oh, that's kind of nice.
14:57:00 <chirpsalot> Very cute :).
14:57:02 <benmachine> mhall: string error messages are kind of hard to do anything with
14:57:15 <mhall> benmachine: ok thanks
14:57:18 <Fuuzetsu> chirpsalot: it would sure let me get rid of http://fuuzetsu.co.uk/images/1412719224.png ;)
14:57:20 <benmachine> Fuuzetsu: there's a quasiquoter somewhere around that gets you as far as [i| Foo a b c d e |]
14:57:38 <phaazon> isn’t it TH?
14:57:55 <benmachine> mhall: Control.Monad.Trans.Error is still around, looks like
14:57:59 <mhall> benmachine: do you know where i could find the definition of `instance Monad (Either a)`
14:58:06 <Fuuzetsu> benmachine: deprecated
14:58:24 <mhall> learn you a haskell gives a definition for fail that uses strMsg
14:58:25 <chirpsalot> Fuuzetsu: yikes!
14:58:26 <benmachine> Fuuzetsu: sure, but if what you want to do is get through a tutorial written against the old interface...
14:58:32 <phaazon> :src Monad (Either a)
14:58:37 <benmachine> mhall: just skip fail, it's not essential
14:58:40 <phaazon> @src Monad (Either a)
14:58:40 <lambdabot> Source not found. My pet ferret can type better than you!
14:58:49 <phaazon> @src (Either a) Monad
14:58:50 <lambdabot> Source not found.
14:58:54 <phaazon> mhall: no! :D
14:58:57 <Fuuzetsu> phaazon: you'd type it all now by now
14:59:06 <benmachine> mhall: where Monad (Either e) comes from depends on which version of things you have, I think
14:59:13 <phaazon> what do you mean all?
14:59:16 <Fuuzetsu> mhall: Left a >>= _ = Left a; Right a >>= f = f a; return x = Right x
14:59:21 <Fuuzetsu> I hope that's right
14:59:34 <phaazon> nope
14:59:36 <phaazon> that’s Left
14:59:36 <benmachine> mhall: in my GHC it's just in the Prelude, in slightly older ones it'll be in Control.Monad.Instances possibly
14:59:37 <phaazon> hihi
14:59:41 <merijn> Why do people keep using @src >.>
14:59:46 <benmachine> mhall: in still older things, it has to be gotten from some library somewhere
14:59:52 <benmachine> merijn: because it keeps answering
15:00:03 <merijn> benmachine: With lies >.>
15:00:11 <benmachine> merijn: yeah
15:00:15 <phaazon> :t (>.>)
15:00:16 <kadoban> Useful lies sometimes though.
15:00:16 <lambdabot>     Not in scope: ‘>.>’
15:00:16 <lambdabot>     Perhaps you meant one of these:
15:00:16 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
15:00:24 <benmachine> but if you know they are lies you aren't the one asking for them :P
15:00:47 <phaazon> they are a good idea on what’s going on though
15:00:56 <Fuuzetsu> most people probably aren't looking for the list-fusion-omg-inner-loop-helpers definitions
15:01:25 <mhall> i do have the latest ghc, doing `:i Monad` shows me `instance Monad (Either e) -- Defined in `Data.Either`
15:01:36 <mhall> this :src command doesn't work for me though
15:01:36 <benmachine> mhall: sounds legit
15:01:40 <chirpsalot> Heh. Haskell should support Emoji for infix operators ;).
15:01:45 <benmachine> mhall: :src doesn't exist
15:01:47 <benmachine> sorry
15:01:50 <benmachine> it would be cool if it did
15:02:09 <merijn> chirpsalot: It does, as long as they are classified as UnicodeSymbols
15:02:23 <mhall> i just wanted to see what the `fail` definition was...i suppose it makes sense that the minimal sufficient definition only requires >>= and return which should be the same as in LYAHS
15:02:24 <chirpsalot> merijn: I was just thinking that, actually. Probably works on a mac :P.
15:02:28 <benmachine> > generalCategory '☺'
15:02:30 <lambdabot>  OtherSymbol
15:02:32 <benmachine> hmm
15:02:34 <benmachine> not sure if that counts
15:02:42 <merijn> > let (☃) = (+) in 1 ☃ 2
15:02:44 <lambdabot>  3
15:03:13 <phaazon> oh
15:03:13 <phaazon> Applicative becomes a superclass of Monad, and is added to the Prelude.
15:03:16 <merijn> See also, "Acme.LookOfDisapproval"
15:03:16 <phaazon> <3<3<3<3
15:03:24 <chirpsalot> phaazon: I know, right!
15:03:28 <phaazon> added to the Prelude <3 <3
15:03:41 <benmachine> mhall: 'fail' is a silly method anyways
15:03:42 <phaazon> I use Applicative everywhere :)
15:03:54 <chirpsalot> That's one thing that I find with Haskell. I have to import a lot of things, haha :).
15:04:02 <merijn> mhall: Forget fail exists, fail is evil :(
15:04:18 <SwashBuckla> merijn: too early
15:04:33 <SwashBuckla>  > let (☃) = (+) in 1 ☃ 2
15:05:04 <phaazon> > let λ = 3 in λ * 3
15:05:05 <lambdabot>  9
15:05:08 <exio4> > let (♥) _ _ = True in "haskellers" ♥ "extensions"
15:05:10 <lambdabot>  True
15:05:25 <exio4> aw :P
15:05:34 <Fuuzetsu> oh, I'm totally using ♥ as my next operator
15:05:38 <phaazon> :D
15:05:46 * Fuuzetsu recently used ◆ as a separator for a pair
15:06:04 <chirpsalot> The fact that my IRC doesn't have unicode set up is really making me sad now.
15:06:23 <kadoban> Heh, maybe you just need to set the encoding?
15:06:24 <hiptobecubic> yeah you're really missing out
15:06:26 <chirpsalot> Hurray: http://ircbrowse.net/day/haskell/today/recent
15:06:34 <mhall> chirpsalot: unicode seems to work on webchat.freenode.net
15:06:49 <chirpsalot> kadoban: text mode OpenBSD doesn't have unicode support.
15:06:49 <exio4> I am defining (♥) = (>>=)!
15:06:51 <agatam> <3 ircbrowse
15:07:11 <Fuuzetsu> chirpsalot: sounds terrible
15:07:31 <phaazon> > let ₪ = [1..] in take 10 ₪
15:07:33 <lambdabot>  <hint>:1:5: parse error on input ‘₪’
15:07:40 <kadoban> chirpsalot: Yeah, that sounds awful :(
15:07:42 <phaazon> oh?
15:07:52 <Fuuzetsu> > let (₪) = 5 in (₪)
15:07:54 <lambdabot>  5
15:07:59 <phaazon> > let ₪ = [1..] in take 10 ₪
15:08:01 <chirpsalot> kadoban: well, it actually supports Latin 1, but not UTF-8 :(.
15:08:01 <lambdabot>  <hint>:1:5: parse error on input ‘₪’
15:08:02 <kadoban> Can GHC itself handle fun unicode glyphs in source? Can't say I've ever tried.
15:08:13 <Fuuzetsu> kadoban: sure
15:08:19 <kadoban> Neat
15:08:20 <Fuuzetsu> look in the GHC lexer
15:08:23 <phaazon> there’s something about that
15:08:28 <phaazon> maybe prelude-unicode
15:08:34 <merijn> > generalCategory '₪'
15:08:35 <kadoban> chirpsalot: That sounds pretty archaic
15:08:36 <lambdabot>  CurrencySymbol
15:08:50 <merijn> phaazon: That's a symbol, symbols aren't valid variable names
15:08:56 <Fuuzetsu> hm, Agda input method doesn't have a word representation for ₪
15:09:01 <phaazon> oh, ok
15:09:01 <Fuuzetsu> major bug
15:09:05 <phaazon> they act as operators?
15:09:06 <chirpsalot> kadoban: I think it's because every time somebody tries to implement UTF-8 they break the kernel or something.
15:09:14 <benmachine> Fuuzetsu: what even is that
15:09:22 <kadoban> chirpsalot: XD
15:09:23 <Fuuzetsu>   name: NEW SHEQEL SIGN
15:09:23 <phaazon> ₢
15:09:27 <merijn> phaazon: "act as operators" is wrong, the Report defines which characters are valid names for what
15:09:28 <phaazon> ฿
15:09:34 <phaazon> there’re weird symbols ahah
15:09:36 <Fuuzetsu> (yes, emacs can tell you about every character you ask for)
15:09:45 <phaazon> merijn: hm
15:09:48 <chirpsalot> Also, serious question, what is with mathematicias and using things like \xi? I feel like they just decide "eh, too lazy to draw anything but squiggles..."
15:09:53 <phaazon> @let (₪) a b = a + b
15:09:55 <merijn> phaazon: Operators must be named using symbols (this includes unicode symbols), variables must be named using "letters"
15:09:55 <lambdabot>  Defined.
15:10:00 <phaazon> > 3 ₪ 1
15:10:02 <lambdabot>  4
15:10:10 <benmachine> I hate xi
15:10:12 <Fuuzetsu> ξ
15:10:14 <benmachine> as a mathematician I hate it
15:10:15 <phaazon> merijn: ok
15:10:26 <phaazon> xi?
15:10:29 <phaazon> ξ
15:10:30 <benmachine> I just start at the top and then I'm like, screw this
15:10:30 <phaazon> oh yeah
15:10:31 <phaazon> :D
15:10:34 <benmachine> ξξξ
15:10:41 <phaazon> ω
15:10:43 <phaazon> φ
15:10:44 <merijn> phaazon: Consult https://www.haskell.org/onlinereport/haskell2010/haskellch2.html for details
15:10:48 <Fuuzetsu> ∙ω∙
15:10:49 <chirpsalot> benmachine: it's everywhere! All of my notes just look like I got bored and threw my notebook at a 5 year old.
15:11:09 <phaazon> thank you merijn, I will
15:11:25 <benmachine> capital xi is even worse
15:11:37 <phaazon> Ξ
15:11:52 <benmachine> there's a story somewhere about how a lecturer divided capital xi by its complex conjugate just to annoy their students
15:12:07 <chirpsalot> Does unicode differentiate between 'symbols' and 'letters'?
15:12:36 <kadoban> I believe so
15:12:44 <kadoban> There's a bunch of categories
15:12:47 <chirpsalot> benmachine: gah!
15:12:50 <exio4> @let (∧) = (&&)
15:12:52 <lambdabot>  Defined.
15:12:54 <Fuuzetsu> kadoban: but do they form a category?
15:12:58 <exio4> > True ∧ False
15:13:00 <lambdabot>  False
15:13:04 <numberten> nice
15:13:08 <phaazon> @let (≤) = (<=)
15:13:09 <lambdabot>  Defined.
15:13:20 <kadoban> Fuuzetsu: Hah, probably not
15:13:22 <phaazon> > 3 ≤ 1
15:13:24 <lambdabot>  False
15:13:36 <benmachine> everything forms a discrete category
15:13:36 <silasm> sure is agda in here.
15:13:42 <phaazon> I got to know how to type a ∧ in bépo
15:13:47 <exio4> @let (≠) = (/=)
15:13:48 <Fuuzetsu> ∀gda
15:13:48 <lambdabot>  Defined.
15:13:54 <merijn> Fuuzetsu: Did you see this years sigbovik proceedings?
15:14:00 <Fuuzetsu> no
15:14:01 <chirpsalot> I'm half surprised Haskellers haven't decided to adopt the convention of obscuring everything in Greek like their mathematical counterparts ;).
15:14:06 <phaazon> @let (·) = (.)
15:14:07 <lambdabot>  Defined.
15:14:20 <exio4> > 42 ≠ 17
15:14:22 <lambdabot>  True
15:14:27 <exio4> unicode fun!
15:14:44 <phaazon> > map toUpper · show $ "435325"
15:14:46 <merijn> Fuuzetsu: One of the papers was: "A Simple Category-Theoretic Understanding"
15:14:46 <lambdabot>  "\"435325\""
15:14:47 <merijn> of Category-Theoretic Diagrams
15:14:58 <phaazon> > map toUpper · show $ "hihi it was stupid"
15:15:00 <lambdabot>  "\"HIHI IT WAS STUPID\""
15:15:08 <Fuuzetsu> merijn: 2meta
15:15:30 <trap_Exit> in vim with ghc-mod, what is the right command to "take this line, cycle through the possible correct indendations for it" ?
15:15:53 <Fuuzetsu> trap_exit: wouldn't ‘tab’ normally do that?
15:16:08 <trap_exit> Fuuzetsu: unfortunately, Tab is being Tab for me right now
15:16:09 <pjdelport> chirpsalot: https://en.wikipedia.org/wiki/Unicode_character_property#General_Category
15:16:34 <trap_exit> Fuuzetsu: can you share uyor ~/.vimrc ?
15:16:37 <trap_exit> if it's not too private
15:16:50 <Fuuzetsu> trap_exit: I can't because I use emacs ;P
15:17:02 <phaazon> 00:20 < trap_exit> if it's not too private
15:17:03 * benmachine wonders how private vimrcs get
15:17:09 <phaazon> nope, he got his bank accounts in there
15:17:11 <phaazon> :D
15:17:20 <benmachine> okay I was not thinking bank accounts
15:17:20 <Fuuzetsu> you don't do your banking from your text editor?
15:17:36 <trap_exit> I was thinking possible passwords for editing files on remote machines
15:17:40 <phaazon> I do that in ghci
15:17:48 <Fuuzetsu> haha
15:17:51 <Fuuzetsu> http://home.gna.org/bank-el/
15:17:57 <haasn> I tried doing banking in emacs but it ate all my monkey
15:18:00 <haasn> money, too
15:18:10 <chirpsalot> pjdelport: ah, okay.
15:18:46 <chirpsalot> haasn: started making you pay per parenthesis?
15:18:56 <Fuuzetsu> haasn: you should fix the minimal pragma thing on Haddock issue tracker
15:19:21 <Fuuzetsu> well, MINIMAL thing, not necessarily pragmaa
15:19:39 * Fuuzetsu → bed
15:22:46 <trap_exit> alright
15:22:54 <trap_exit> so after 10 years of vim, I switched to emacs
15:22:57 <trap_exit> now I tried vim again for 10 minutes
15:23:03 <trap_exit> and since I can't get it to indent right, I'm switching back to emacs :-)
15:23:31 <kadoban> I just use < and > for indenting I think.
15:24:02 <kadoban> It's kinda funny, but as much as I type crap, I use almost no features of my text editor...I should probably fix that at some point. Vim has all this cool stuff that I've never bothered to learn.
15:28:34 <numberten> took me over a year of only vim before I cared enough to learn even simple visual mode stuff
15:29:25 <recursion-ninja> is lambdabot back up?
15:29:32 <exio4> > True
15:29:35 <lambdabot>  True
15:30:26 <recursion-ninja> Yay!
15:30:39 <recursion-ninja> print "I'm Back"
15:30:58 <benzrf> > putStrLn "I'm Back"
15:31:00 <lambdabot>  <IO ()>
15:31:22 <kadoban> > show "Muahahahah"
15:31:24 <lambdabot>  "\"Muahahahah\""
15:32:10 <recursion-ninja> > Show "I'm Back"
15:32:11 <lambdabot>  Not in scope: data constructor ‘Show’
15:32:16 <recursion-ninja> > show "I'm Back"
15:32:18 <lambdabot>  "\"I'm Back\""
15:32:31 <recursion-ninja> > show "I missed everyone"
15:32:33 <lambdabot>  "\"I missed everyone\""
15:32:36 <charlie> > show /quit
15:32:38 <lambdabot>  Not in scope: ‘quit’
15:32:38 <lambdabot>  Perhaps you meant ‘quot’ (imported from Prelude)
15:32:47 <recursion-ninja> > show "It was cold and dark in the void :("
15:32:49 <lambdabot>  "\"It was cold and dark in the void :(\""
15:32:51 <phaazon> > take 100 $ fix ("I’m back! "++)
15:32:52 <lambdabot>  "I\8217m back! I\8217m back! I\8217m back! I\8217m back! I\8217m back! I\821...
15:32:59 <charlie> lol
15:33:04 <recursion-ninja> lol
15:33:10 <phaazon> :)
15:33:12 <benzrf> nice uniquote
15:33:22 <benzrf> and by nice i really mean DUMB!
15:33:22 <benzrf> :-D
15:33:25 <phaazon> yeah I use it everytime, sorry for that
15:33:31 <phaazon> well
15:33:34 <phaazon> it’s the true-one
15:33:38 <phaazon> the typographic quote
15:33:49 <phaazon> > take 100 $ fix ("I'm back! "++)
15:33:51 <lambdabot>  "I'm back! I'm back! I'm back! I'm back! I'm back! I'm back! I'm back! I'm b...
15:35:51 <recursion-ninja> > "I'm healed"
15:35:53 <lambdabot>  "I'm healed"
15:36:17 <recursion-ninja> > "Now I'm, Zombie-bot!"
15:36:19 <lambdabot>  "Now I'm, Zombie-bot!"
15:36:25 <shiona> > "Why do I do bare-words"
15:36:27 <lambdabot>  "Why do I do bare-words"
15:36:42 <phaazon> now, go play in private ;)
15:37:00 <kadoban> "Better than bear-words"
15:37:04 <recursion-ninja> > fix (1:)
15:37:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:38:39 <SrPx> What is the type of this array, and how do I find its length? http://lpaste.net/112272
15:39:12 <phaazon> @let import Data.Array
15:39:13 <lambdabot>  Defined.
15:39:20 <phaazon> :t Data.Array.size
15:39:22 <lambdabot>     Not in scope: ‘Data.Array.size’
15:39:22 <lambdabot>     Perhaps you meant one of these:
15:39:22 <lambdabot>       ‘Data.Array.index’ (imported from Data.Array),
15:39:26 <phaazon> :t Data.Array.length
15:39:27 <lambdabot>     Not in scope: ‘Data.Array.length’
15:39:27 <lambdabot>     Perhaps you meant one of these:
15:39:27 <lambdabot>       ‘Data.Array.range’ (imported from Data.Array),
15:40:22 <recursion-ninja> something like "length . range $ bounds arr"
15:40:36 <recursion-ninja> :t Data.Array.range
15:40:37 <lambdabot> Ix a => (a, a) -> [a]
15:40:44 <recursion-ninja> :t Data.Array.bounds
15:40:46 <lambdabot> Ix i => Array i e -> (i, i)
15:40:55 <recursion-ninja> :t length . range .bounds
15:40:57 <lambdabot> Ix a => Array a e -> Int
15:41:22 <recursion-ninja> SrPx: Use this  "length . range . bounds"
15:42:02 <SrPx> yes, thank you recursion-ninja and phaazon
15:42:05 <SrPx> what about the type of fill
15:42:06 <recursion-ninja> SrPx: Unfortunately it's O(n)
15:42:13 <SrPx> okay so that is not good
15:42:27 <SrPx> what is the alternative? I need something that works like C++'s std::vector
15:42:42 <phaazon> SrPx: pretty easy
15:42:48 <phaazon> run ghci
15:42:49 <recursion-ninja> SrPx: if the array is Array e Int
15:42:50 <SrPx> O(1) random read, write & cached length, unboxed values & fast
15:42:55 <phaazon> :l YourFile.hs
15:42:57 <phaazon> :t fill
15:42:58 <lambdabot> Not in scope: ‘fill’
15:43:02 <phaazon> dammit lambdabot :D
15:43:05 <SrPx> phaazon: but ghci returns something I don't understand
15:43:07 <recursion-ninja> SrPx: uncurry (-) . swap . bounds
15:43:16 <recursion-ninja> SrPx: that would be O(n)
15:43:19 <phaazon> SrPx: ?
15:43:21 <recursion-ninja> :t uncurry (-) . swap . bounds
15:43:23 <lambdabot> (Ix c, Num c) => Array c e -> c
15:43:34 <recursion-ninja> SrPx: that would be O(1)
15:43:41 <recursion-ninja> SrPx: I mis spoke
15:44:08 <phaazon> well
15:44:13 <phaazon> given your implementation
15:44:22 <recursion-ninja> SrPx: But the inxeding type must be numeric (essentially Int or Integer)
15:44:25 <SrPx> phaazon: fill :: (MArray a e m, Ix e, Num e, Enum e) => a e e -> m [()]
15:44:35 <phaazon> it should be something like IO [IOArray a a]
15:44:38 <SrPx> That doesn't make any sense to me
15:44:42 <phaazon> oh
15:44:44 <phaazon> yeah
15:44:45 <phaazon> well
15:44:52 <phaazon> indeed
15:45:55 <phaazon> writeArray uses MArray a e m
15:46:04 <phaazon> wich makes m a Monad
15:46:07 <phaazon> here, m = IO
15:46:21 <phaazon> writeArray is in m ()
15:46:24 <phaazon> (IO ())
15:46:31 <phaazon> so you don’t need to collect anything
15:46:33 <phaazon> use sequence_
15:46:35 <phaazon> not sequenc
15:46:39 <phaazon> sequence*
15:46:49 <phaazon> or you can collect (), which is not very helpful :D
15:46:53 <SrPx> phaazon: even with sequence_ I'm not able to type it... I tried for example fill :: IO (IOArray Int Int) -> IO ()
15:47:17 <phaazon> 00:47 < SrPx> phaazon: fill :: (MArray a e m, Ix e, Num e, Enum e) => a e e ->  m [()]
15:47:41 <SrPx> ? :(
15:48:05 <phaazon> IOArray Int Int -> IO () doesn’t work?
15:48:15 <Denommus> cabal doesn't want to install reactive-banana-wx for some reason here O.o
15:48:28 <phaazon> it should
15:48:29 <SrPx> works, but I don't get the IO thing still... hmm... thanks
15:48:46 <SrPx> what is the difference exactly, between IOArray and STArray?
15:48:53 <phaazon> SrPx: IO is a simple type that lets you know something is going on in the « real world »
15:48:54 <SrPx> eh nvm, thanks
15:49:06 <SrPx> yea but it is an array ...
15:49:10 <phaazon> yes
15:49:16 <phaazon> it’s an array that leaves in the real world
15:49:26 <phaazon> that actually lives in the real world
15:49:30 <phaazon> (:D)
15:49:40 <phaazon> and to answer the latter question
15:49:45 <phaazon> STArray lives in… ST
15:49:45 <phaazon> :)
15:49:55 <SrPx> that makes some sense
15:50:07 <phaazon> Array lives… in pure code
15:50:17 <phaazon> you can use Array everywhere then
15:50:25 <phaazon> but you can’t use IOArray in pure code
15:50:39 <phaazon> imagine that the IOArray is a true C array
15:50:43 <SrPx> but I thought ST was supposed to be like a dict of key/val pairs
15:50:43 <phaazon> allocated somewhere else
15:50:54 <phaazon> SrPx: ST is a world of references
15:50:55 <SrPx> so the difference is that STArray is for when I want to have many arrays? or something?
15:51:14 <phaazon> STArray is an array optimized to store references
15:51:18 <phaazon> pure references
15:51:21 <phaazon> not IORef
15:51:25 <phaazon> (STRef, actually)
15:52:32 <phaazon> you have to understand what IO is before using IOArray :D
15:52:40 <silasm> SrPx: STArray is more like an array of references. It's one solution when you need O(1) random-access writes.
15:53:05 <SrPx> hmmm, anyway, if I need to create a type that depends on fast array on it, then I need to wrap IO around my type too
15:53:13 <phaazon> IO is a type that tags something to express “hey, I might be a side-effect!”
15:53:19 <phaazon> note the “might”
15:53:21 <phaazon> it could also not.
15:53:28 <SrPx> hm
15:53:49 <phaazon> arf
15:54:00 <phaazon> IO is not speed-proven ;)
15:54:07 <phaazon> you can have very FAST computations in pure code
15:54:12 <phaazon> most of the time, they are
15:54:25 <phaazon> depending on what you’re doing, of course
15:54:38 <phaazon> I tend to say pure code is faster on the trend
15:55:05 <SrPx> phaazon: so I should just not use arrays?
15:55:13 <phaazon> I don’t know SrPx
15:55:19 <phaazon> what’s your use case?
15:55:26 <recursion-ninja> SrPx: It depends on how you would use the arrays
15:55:35 <phaazon> why have you chosen arrays in the very first place?
15:55:50 <recursion-ninja> SrPx: Often a List or a Sequence will be just a sufficent and much more pure
15:56:35 <SrPx> phaazon: I'm coding a graph lib as an exercise, I need to represent the neighbors of a node on the graph somehow. I could use an adjacency list, but lists are slow, as you told me
15:56:41 <recursion-ninja> SrPx: Keeping code pure allows the compiler to make HEAVY optimizations because it can make MANY assertions since the code is pure!
15:56:57 <phaazon> no I did not
15:57:05 <SrPx> not you, you guys on the channel*
15:57:11 <phaazon> well, they lied
15:57:12 <SrPx> english should have a plural for you
15:57:14 <recursion-ninja> SrPx: Is there a graph library on Hackage?
15:57:21 <phaazon> lists are not slow at all
15:57:23 <SrPx> recursion-ninja: probably, this is an exercise
15:57:29 <silasm> SrPx: is your graph sparse or dense?
15:57:30 <phaazon> it depends on the use case
15:57:49 <SrPx> silasm: sparse, but the lib is supposed to be general
15:58:04 <silasm> if it's sparse, list is probably better.
15:58:11 <recursion-ninja> SrPx: Why not use a map? :t Map Node [Node]
15:58:21 <phaazon> well
15:58:25 <phaazon> you could use a simple Array
15:58:30 <silasm> for the dense case you might benefit from arrays or maps, yeah.
15:58:35 <phaazon> to make an adj. matrix
15:58:46 <phaazon> it would be really fast
15:58:49 <phaazon> no need for IO here
15:59:01 <recursion-ninja> SrPx, phaazon: I think an adj mtrix would be easiest
15:59:01 <SrPx> recursion-ninja: O(1) access? I don't know, I just need an O(1) map between indexes from 0 to N and int values. An array seemed like the obvious choice and was how I did it in other langs
15:59:15 <SrPx> phaazon: but it has O(1) access?
15:59:21 <phaazon> sure, it’s an array
15:59:24 <phaazon> however
15:59:29 <recursion-ninja> SrPx:  Then we can use an adjacency matrix
15:59:31 <phaazon> if you do a lot of insertions / deletions
15:59:34 <SrPx> phaazon: unboxed?
15:59:47 <SrPx> recursion-ninja: this is ruled out, the graph is huge for a matrix
15:59:51 <Rembane> SrPx: Data.Vector or Data.Map are quite good for that depending on how much memory you have.
15:59:52 <phaazon> SrPx: you can both
15:59:54 <phaazon> see UArray
16:00:10 <SrPx> ok give me a sec I'll look at those
16:00:15 <phaazon> for sure
16:00:20 <phaazon> if you can use Data.Vector
16:00:20 <phaazon> do it
16:00:26 <recursion-ninja> SrPx: ok... lets think of a better structure then...
16:00:49 <phaazon> imo, Data.Vector will be way faster than Data.Map
16:00:56 <phaazon> since lookups are O(1)
16:01:06 <phaazon> while they’re O(n log n) in Map
16:01:30 <glguy> Lookups aren't O(n log n) in map, they're O(log n)
16:01:48 <phaazon> yeah, sorry
16:01:54 <phaazon> if I had to write such a lib
16:01:54 <SrPx> ah alright so if I *just* want to read, seems like UArray is great, right? By using STArray I would have to use ST anytime I use my structure, but using UArray it is just like a pure structure, right?
16:01:59 <phaazon> I think I’d use repa
16:02:11 <phaazon> repa arrays are f****k awesome
16:02:17 <SrPx> let me look at Data.Vector
16:02:38 <phaazon> SrPx: yes, indeed
16:02:48 <phaazon> why do you need unboxed arrays?
16:03:01 <SrPx> okay that is enlightening, thanks
16:03:02 <recursion-ninja> SrPx: Also decide if you need mutable arrays and immutable arrays. Monolithic assignment of immutable arrays is quite efficient
16:03:06 <SrPx> phaazon: why the boxes if I'm just using ints?
16:03:16 <Rembane> SrPx: Have you tried building a naive prototype?
16:03:20 <silasm> is there a haskell wiki article comparing what various data structures are useful for? I feel like that'd be immensely useful to have for some of these discussions.
16:03:28 <SrPx> Rembane: uhm no why?
16:03:30 <phaazon> you said it was for general purpose
16:03:51 <SrPx> Rembane: last time I tried using the wrong datatypes at first I had some considerable work refactoring
16:03:52 <volty> anyone of you knows of a GOOD DOCUMENT (just document, short, practical) on monads?
16:04:03 <recursion-ninja> there is a stackoverflow Q&A about datastructures
16:04:19 <SrPx> Rembane: I have a feeling like haskell isn't exactly friendly for changing structures after you changed the code... which is kinda sad, considering even C++ it is just a matter of rewriting a typedef
16:04:29 <SrPx> after you finished the code*
16:04:30 <bmuk> Other than rm -rf ~/.ghc, how do I get back to a clean state with haskell packages?
16:04:34 <phaazon> SrPx: that’s the opposite
16:04:39 <phaazon> Haskell is perfect for that :)
16:04:43 <phaazon> in your case
16:04:59 <phaazon> instead of using, for instance, UArray, you could use the Array typeclass
16:05:03 <silasm> SrPx: I've had a very different experience. Though of course it depends on the data structures in question, and how you're structuring your functions.
16:05:23 <phaazon> and write typeclass dependent code and use either UArray, Array, whatever
16:05:29 <SrPx> phaazon: I don't get it, how so? What type class? Where? If I implemented using STArray and then noticed it is not necessary, I'd have to refactor EVERY single use of my structure. How is that better than C++'s case?
16:05:44 <phaazon> SrPx: well
16:06:05 <glguy> SrPx: Haskell has type aliases, so if you're just comparing to typedefs you're all set
16:06:16 <phaazon> array can be expressed as constraints
16:06:18 <merijn> volty: Don't read "about monads", do the following: 1) learn to read and understand type signatures, 2) learn to understand typeclasses, 3) play with the simple Monad instance (Maybe, Either, List, etc.) 4) play with more complicated once (State, Reader, etc.)
16:06:21 <volty> SrPx: do it simple, the way you feel & think, do not follow the theorists
16:06:29 <recursion-ninja> SrPx: Changing instances is painless if you used a typeclass, similar to programming against Interfaces not Implementations in the OO paradigm
16:06:42 <phaazon> see MArray for mutable arrays for instances
16:06:44 <volty> merijn: that is what I think :)
16:06:51 <phaazon> or IArray for immutable
16:07:00 <volty> i was just curious if a short paper exists there
16:07:11 <SrPx> I know, that is great, but I never see you guys using type classes for that kind of thing. For example, there is not a "ListLike" type class you can change for an array later on. You guys just use lists direct on most code I see, right?
16:07:13 <merijn> volty: Monads are just a simple pattern that recur in lots of places, but reading about an abstract pattern is not very educational, playing with them is much more so
16:07:21 <SrPx> I guess there's not even such a type class in prelude
16:07:28 <merijn> volty: There's Wadler's "Monads for Functional Programming" which is pretty good
16:07:30 <recursion-ninja> merijn: coun't agree more!
16:07:43 <phaazon> (IArray a e,Ix i) => a i e -- this is an array, however it could be UArray, Array, or any instance of IArray ;)
16:07:47 <merijn> volty: Also, sigfpe's "You Could Have Invented Monads (and Maybe You Already Have!)"
16:07:48 <recursion-ninja> merijn, volty: read the definition of a monad
16:07:51 <Rembane> SrPx: Ah, I see. I was just searching for premature optimization. :)
16:07:57 <recursion-ninja> merijn, volty: then play with them
16:08:17 <recursion-ninja> > :t (>>)
16:08:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:08:22 <recursion-ninja> :t (>>)
16:08:23 <lambdabot> Monad m => m a -> m b -> m b
16:08:29 <phaazon> 01:10 < SrPx> I know, that is great, but I never see you guys using type  classes for that kind of thing. For example, there is not a  "ListLike" type class you can change for an array later on. You  guys just use lists direct on most code I see, right?
16:08:29 <recursion-ninja> :t (>>=)
16:08:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:08:33 <phaazon> sure
16:08:37 <phaazon> but well
16:08:42 <merijn> volty: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
16:08:50 <phaazon> I tend to use more general structure for a few stuff
16:08:52 <phaazon> like maps
16:08:56 <phaazon> instead of Map k v
16:09:01 <phaazon> I use (k -> Maybe v)
16:09:07 <phaazon> (if I want lookup, for instance)
16:09:19 <volty> merijn: yes, thx, I already have it
16:09:37 <recursion-ninja> phaazon: Map has lookup : Map k v -> k -> Maybe v
16:09:45 <phaazon> I know recursion-ninja
16:09:58 <phaazon> but using (k -> Maybe v) is great
16:10:05 <recursion-ninja> phaazon: I thought you were saying you "roll-your-own" map
16:10:14 <phaazon> nope
16:10:18 <phaazon> sometimes
16:10:26 <phaazon> I need to pass a map to lookup values
16:10:34 <phaazon> instead of passing a Map k v
16:10:40 <phaazon> and implement my function with a M.lookup
16:10:44 <josephle> with (k -> Maybe v), phaazon is asking for a "lookup v based on k" function, which may or may not use Map
16:10:45 <phaazon> I directly pass the lookup
16:10:55 <phaazon> yeah
16:11:08 <phaazon> this is great since I can pass a closure with a Map
16:11:08 <volty> SrPx: when I am with C++ i miss the conciseness of haskell, when I am in Haskell (yet to code ...) I miss freedom and tools :)
16:11:10 <recursion-ninja> phaazon: I think I get it
16:11:12 <phaazon> or a Vector, or whatever
16:11:37 <phaazon> Haskell is all about freedom!
16:12:19 <seku> great. now i hear the hoff singing
16:12:38 <seku> http://www.youtube.com/watch?v=2ot_katYYiU
16:13:10 <SrPx> ...
16:13:18 <Denommus> ok, I really can't install reactive-banana-wx -.-
16:13:35 <SrPx> I don't get the point, but... eh never mind, thanks for the help btw :) I see how I can make this lib now
16:13:57 <SrPx> if not for you I'd be having a lot of headaches using IO unnecessarily
16:14:14 <phaazon> SrPx: I’m writting a 3D engine
16:14:18 <phaazon> I don’t even use IO :D
16:14:29 <phaazon> well, I use it a bit to interface with for instance OpenGL
16:14:50 <phaazon> but IO is only needed for a very very few needs ;)
16:14:54 <josephle> I was wondering how you were ever going to draw to screen :P
16:15:05 <phaazon> josephle: well
16:15:19 <phaazon> the code that exposes the “rendering” stuff is pure :)
16:15:30 <joelteon> it's not hard if your OS is written in haskell
16:15:40 <phaazon> god it’d be so neat
16:15:43 <volty> there's the real world outside, some good expert soul should write a nice lib to interface with QtGui .... , don't be too pure ! :)
16:15:56 <phaazon> no
16:15:57 <phaazon> no
16:15:58 <phaazon> nonono
16:15:59 <phaazon> god no
16:16:00 <phaazon> not Qt
16:16:04 <phaazon> I HATE that lib
16:16:11 <phaazon> its design is awful to me
16:16:25 <volty> which one you prefer ?
16:16:27 <shix> im not a fan of qt
16:16:33 <silver> I bet it's pretty hard to maintain that beast
16:16:45 <phaazon> volty: straight-forward lib
16:16:46 <volty> with which one you implement gui ?
16:17:05 <phaazon> volty: depends on the need, but we lack a pure gui :(
16:17:12 <phaazon> a real beautiful pure gui
16:17:25 <volty> choosy purists ?  :)
16:17:31 <phaazon> ?
16:17:54 <volty> haskell is a very nice language, it is a shame there's no a decent gui
16:18:04 <volty> and qt is quite nice, believe me
16:18:39 <levi> There's a haskell binding to QtQuick.
16:18:53 <SrPx> phaazon: how do you deal with mutable arrays without IO?
16:19:03 <exio4> the ST monad?
16:19:09 <phaazon> SrPx: ST yeah
16:19:17 <phaazon> but why do you need mutation?
16:19:22 <SrPx> Oh sure, I see.
16:19:26 <phaazon> for a graph I believe you don’t
16:19:39 <SrPx> no, not for this specifically
16:19:43 <phaazon> ok :)
16:19:58 <SrPx> but there are too many things where mutable arrays are essential for performance
16:20:06 <volty> QtQuick vs QtGui is more than like lisp vs haskell
16:20:15 <silasm> phaazon: the DFS paper uses an STArray for efficiency in one of the steps.
16:20:21 <phaazon> SrPx: you’d be surprise not that much )
16:20:37 <SrPx> std::vector is pretty much the fastest things even today, after all
16:20:51 <phaazon> SrPx: Data.Vector is quite the same thing
16:20:58 <phaazon> and it’s pure
16:20:59 <silver> SrPx, that's why it was reimplemented by facebook? :D
16:21:17 <SrPx> phaazon: doesn't the fact that 100% of your code is missing the cache all the time due to the sparse memory nature of lists/trees/etc ?
16:21:22 <silver> https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md
16:21:26 <orb__> SrPx, what about C arrays? ;o)
16:21:29 <SrPx> concern you *
16:21:45 <phaazon> SrPx: nope
16:21:55 <orb__> SrPx, lists _could_ be laid out sequentially by the gc.
16:21:59 <SrPx> silver: yea I mean more C arrays than std::vectors, which have a bad reallocation constant
16:22:01 <orb__> Some GCs even do that.
16:22:03 <phaazon> I actually even don’t give a damned for 90% of my application
16:22:05 <phaazon> I let that to ghc
16:22:11 <phaazon> applicatinos*
16:22:12 <phaazon> dammit
16:22:14 <phaazon> applications*
16:23:02 <SrPx> I don't know, I just feel like: imperative haskell with monads for mutability etc = as fast as C. pretty, functional, modular haskell = all way down to python.
16:23:17 <phaazon> ahah
16:23:33 <SrPx> maybe I'm wrong, but that's my impression from: seeing the code on the C benchmark game and having coded a few things. who know, maybe it is a wrong impression that will change as I learn more
16:23:34 <SrPx> I hope so
16:23:35 <SrPx> :)
16:24:02 <phaazon> SrPx: pure code enables a shitload of optimizations by the compiler
16:24:07 <phaazon> like list fusions for instance
16:24:12 <exio4> it is a tradeoff, depending of the task it could be even faster thanks to ^
16:24:17 <SrPx> list fusions aaand...?
16:24:27 <phaazon> pure code lets you also deal with constant memory footprints
16:25:09 <phaazon> when dealing with pure code you can’t directly say “it’s gonna be slow/fast” (or you know very well how ghc will rip your code of in ghc core)
16:25:23 <phaazon> off
16:25:45 <SrPx> as much as GHC optimizes, nothing will change the fact lists = cache misses... it doesn't optimize lists for flat arrays. never
16:25:51 <simpson> Sure you can. Analysis of algorithms still works in pure code.
16:26:20 <phaazon> simpson: you can have vague ideas sure
16:26:26 <phaazon> but at a certain level of complexity
16:26:36 <phaazon> telling what will get evaluated before what is barely impossible
16:27:00 <exio4> I hope we see supercompilation for specific functions "mainstream" in a few years! :p
16:27:40 <simpson> phaazon: So that is because of nonstrict evaluation, not puritt.
16:27:41 <SrPx> and I do think it is mostly a matter of the way our processors work, they are optimized for arrays. the whole cache stuff lies in an assumption which is false for most functional programs
16:28:10 <volty> that is what I asked myself: why aren't lists implemented as 1-dim arrays? (with indexes, head, tail) ?
16:28:23 <phaazon> with a friend, we had interesting experiments a few days ago. He wrote a factorial version in a common language (maybe C#), and I did the same thing in haskell with a VERY naive version. Mine, pure, was faster, and moreover, I could handle HUGE numbers while he cannot :)
16:28:24 <SrPx> if our processors just cached linked nodes instead of elements placed sequentially on the memory or something :P
16:29:04 <SrPx> volty: that is just a guess, but alloc performance would suffer a lot
16:29:19 <phaazon> volty: because lists are not arrays :)
16:29:30 <phaazon> if you care about cache misses
16:29:33 <SrPx> phaazon: but that is common... mostly for the experience of the programmer, I'd say
16:29:34 <phaazon> use arrays!
16:29:44 <phaazon> you’ll have the same thing with C++’s lists
16:29:49 <volty> SrPx: you have alloc performance problem for whatever non-fixed size structure
16:30:21 <Cale> volty: It's hard to allocate an infinite list as a contiguous block of memory
16:30:22 <phaazon> in a lot of cases, performances are not that related to cache misses
16:30:31 <phaazon> if you’re doing something critical, sure, you’ll care about that
16:30:34 <phaazon> but in most cases…
16:30:39 <exio4> I don't really have ALL my lists allocated at the same time
16:30:47 <volty> phaazon: come around! What you see as [Char] "Phaazon" isn't implemented as drawn characters
16:30:48 <SrPx> volty: yea now that I think about it, indeed... why aren't lists implemented as 1d arrays?
16:30:53 <merijn> volty: Lists aren't implemented as 1 dim arrays as that'd make appending really expensive (full copy of the array)
16:31:04 <SrPx> or just, why aren't vectors the "official" structure, when you type [1,2,3] etc
16:31:12 <phaazon> volty: I reckon Text is.
16:31:13 <SrPx> or even better, why aren't we just using type classes?
16:31:16 <SrPx> hmmm
16:31:18 <Cale> Lists should only have a few elements live at any given point, and if that's not the case, then probably you shouldn't be using lists for what you're doing.
16:31:33 <Cale> Lists have a lot more control-structure nature in Haskell than data-structure nature :)
16:31:43 <volty> leave apart the infinite structures, you can do it with arrays too
16:31:44 <Cale> They're effectively loops which haven't happened yet
16:32:01 <merijn> volty: Eh, how would you have an infinite structure with arrays?
16:32:12 <volty> the prob. is what I read: "must traverse the whole list ... to get ... "
16:32:16 <Cale> In the sense that a loop either doesn't happen, or consists of a single iteration followed by another loop, just as a list is either empty or consists of a single element followed by another list.
16:32:25 <merijn> volty: List == linked list
16:32:30 <Cale> If you want to do random access, don't use lists.
16:32:32 <phaazon> maybe some day memory adressing will change for functional-oriented one, and compilers will be simplier ? :)
16:32:40 <merijn> volty: You don't do random access on C++ linked lists either, do you?
16:32:45 <volty> merijn: when I say array I mean a c++ class that has members + the array
16:32:46 <Cale> Use something else like arrays or sequences
16:33:05 <levi> phaazon: For fun, check out the Reduceron stuff sometime.
16:33:06 <merijn> volty: If you want an array, then use...an array
16:33:07 <volty> so in the members you put the limits
16:33:15 <phaazon> levi: Reduceron?
16:33:19 <Cale> phaazon: I'm fairly interested in what might happen with memristor based computation
16:33:20 * dfeuer steals Cale's brain for the day.
16:33:23 <levi> FPGA-based graph-reduction processor.
16:33:32 <phaazon> memristor? hm
16:33:39 <Cale> Yeah, and there are already people doing stuff with FPGAs
16:33:42 <phaazon> 1971
16:33:45 <phaazon> old :/
16:33:51 <Cale> hm?
16:33:57 <volty> i am not talking about getting random access, i'm talking about the implementation beneath what we deal with as a list
16:33:58 <Cale> What's from 1971? :)
16:34:02 <phaazon> memristor
16:34:09 <levi> Most CPU architecture stuff was first done a long time ago.
16:34:24 <phaazon> hm
16:34:25 <Cale> Nobody knew how to implement memristors until very recently, the last few years practically.
16:34:30 <phaazon> isn’t that a resistor?
16:34:32 <merijn> volty: Well, why don't we implement beneath what we deal with as arrays using a linked list in C++?
16:34:39 <Cale> The paper which suggested they might exist was in 1971 :)
16:34:48 <josephle> that's when memristors were theorized. An actual practical realization of the memristor is far more recent
16:34:52 <volty> because array are more efficient
16:35:07 <merijn> volty: But they aren't in haskell
16:35:22 <merijn> volty: Because immutability means you have to copy the entire array everytime you append
16:35:41 <phaazon> 01:38 < volty> because array are more efficient
16:35:56 <phaazon> this is like saying “I’m better than you”
16:36:00 <phaazon> that doesn’t make any sense
16:36:04 <merijn> If you want a list, use a list, if you want an array, use an array
16:36:07 <levi> Actually, if you think 1971 was a long time ago, you have probably been given a skewed sense of the rate of progress based on recent churn in the computer space.
16:36:07 <phaazon> add some usecase dammit! :)
16:36:15 <volty> not at all, you can keep trace, the purity on the surface does not imply purity beneath
16:36:39 <merijn> volty: That implies reference counting said array, which means the GC becomes slower and sharing becomes hard
16:36:42 <Cale> Basically, memristors can act like a memory which can be set with a pulse of direct current, and read with alternating current, and if you build a crossbar array of memristors, there's a way in which you can drive them to compute logical implications, in addition to storing data.
16:36:53 <silasm> volty: in Haskell, often times, the lists don't end up existing at all. You don't get more efficient than that.
16:36:55 <Cale> So, this could lead to computers whose memory and computation occur in the same place.
16:37:14 <Cale> (logical implication together with falsehood being logically complete)
16:37:26 <volty> merijn: I doubt. I'll think about, and try with ruby (just for fun & understanding)
16:37:27 <josephle> Cale: but the first real use will be faster and less memory hungry SSDs :)
16:37:27 <phaazon> silasm: +1
16:37:38 <merijn> volty: Anyway, this whole line of discussion boils down too "why aren't lists Map's?"
16:37:46 <merijn> volty: The only answer is "because they're not"
16:37:47 <josephle> *less energy hungry
16:38:17 <phaazon> “reconfigurable hardware”
16:38:24 <phaazon> that sounds pretty tough :D
16:38:38 <merijn> phaazon: What? You mean FPGAs?
16:38:43 <phaazon> yeah
16:38:48 <volty> what matters is the behavior  -- the implementations can go infinite ways
16:38:49 <phaazon> I’m reading this: http://www.cs.york.ac.uk/fp/reduceron/icfp2010talk.pdf
16:38:56 <exio4> volty: try to hack some Haskell compiler and implement lists as arrays!
16:39:05 <merijn> volty: Only with an abstract datatype, which lists are not
16:39:09 <Cale> volty: Most of the time, your lists will only have one element in memory at a time which isn't garbage collectable, and GHC's hybrid generational GC is very good at coping with lots of short-lived data
16:39:24 <merijn> volty: Set is an abstract datatype and it's implementation has changed over time
16:39:34 <merijn> List is not
16:39:48 <Cale> volty: In addition to that, there are list fusion rules which will even eliminate intermediate lists in various computations from being allocated in the first place
16:39:51 <merijn> Why not? Because it's simple and easy to use in it's current form
16:40:03 <merijn> The space of "possible ways to do things differently" is infinite
16:40:13 <levi> I believe the reduceron takes advantage of the way that memory blocks are laid out in an FPGA vs how acessing external SDRAM works.
16:40:19 <volty> imho (i am not expert at haskell) many other things have to change before haskell gets a boost
16:40:21 <merijn> If you expect an answer as to why none of the other infinite options were chosen, you'll be sadly disappointed
16:40:23 <syrion> I have a noob question. What is the general heuristic for when pointfree form would be better than "standard"?
16:40:35 <merijn> syrion: "is this more readable?"
16:40:45 <josephle> ^ the best heuristic
16:40:47 <merijn> syrion: If the answer is no, then don't use pointfree :)
16:40:48 <Cale> I agree with merijn here
16:41:04 <syrion> merijn: True, in terms of the final product, but at this stage in my Haskelling I actually have difficulty even seeing that something could be made point-free
16:41:07 <merijn> syrion: Granted, you're personal opinion on readability may change as you gain experience, but that's fine
16:41:14 <merijn> syrion: Practice :)
16:41:18 <Cale> volty: Basically, lists are the way to express "I intend for these things to be consumed in this order"
16:41:26 <syrion> I am doing exercises on exercism (...) and wrote this thing -- hammingDistance s t = length . (filter (\(x, y) -> x /= y)) $ zip s t
16:41:38 <exio4> I normally switch to "point-free" when I got "f (g (h x))"
16:41:39 <Cale> volty: and if you don't intend that, you ought to use one of the many other data structures out there, but if you do, then lists are perfect.
16:41:46 <volty> Cale: I was talking about how they are implemented, not about what is a list
16:41:50 <volty> (or should be)
16:41:54 <merijn> syrion: I would' split of the lambda into it's own let/where definition
16:41:58 <syrion> so, I thought, this might be a "pointfreeish" thing, so I tried length . (filter (\(x, y) -> x /= y)) . zip
16:42:00 <syrion> but, no good
16:42:04 <merijn> syrion: Also, the parenthesis around filter are redundant :)
16:42:05 <syrion> merijn: ah, I considered that
16:42:09 <Cale> volty: There is no other choice of implementation possible which would be suitable for the same tasks.
16:42:29 <Cale> volty: The answer to why lists are popular in Haskell is effectively the same answer as why loops are so popular in imperative languages.
16:42:53 <volty> look, i do not want to be rude, but to me it seems that you could use the same "no other way" in prehistoric caverns
16:42:54 <levi> volty: The representation of Lists in haskell is deeply tied to the language itself. It's not an abstract data type as it is in some other languages.
16:42:57 <merijn> syrion: function application binds tighter than operators so "length . filter (\(x, y) -> x /= y)" parses as "length . (filter (\(x,y) -> x /= y))" already
16:43:09 <merijn> syrion: Also, I think it might just be "uncurry (/=)" :)
16:43:11 <SrPx> levi: now that you talked about reduceron, shouldn't we... seriously, may sound silly, but shouldn't the haskell community be investing tons in making an actual computer out of the ideas on reduceron? That thing makes pure, linguistic Haskell go faster than C, even OpenCL, under a 10mhz clock.
16:43:14 <merijn> :t uncurry (/=)
16:43:15 <lambdabot> Eq b => (b, b) -> Bool
16:43:16 <Cale> volty: There are other data structures which are suitable for implementing sequences of things
16:43:23 <Cale> volty: But lists are not merely sequences of things
16:43:26 <merijn> :t uncurry
16:43:28 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:43:35 <volty> sorry, i stop, we do not understand each other (or I do not express myself well or you are trolling)
16:43:38 <phaazon> SrPx: that sounds… <3
16:43:47 <Cale> I promise I'm not trolling :)
16:43:57 <volty> i have good memory
16:44:16 <johnw> If ever there was an anti-troll in the whole of the universe, it would be Cale
16:44:17 <levi> SrPx: The price structure of silicon production makes it difficult.
16:44:18 <Cale> volty: I think this probably takes lots of experience seeing how lists are actually used in practice in Haskell to understand well
16:44:19 <merijn> If Cale is a troll, everyone is a troll :)
16:44:25 <volty> (and nose that smells red pimplys )
16:45:04 <Lutin`> wat
16:45:11 <SrPx> levi: we are a lot of smart people, businessmen, scientists and engineers
16:45:15 <levi> volty: If you need an abstract sequence data type that's efficient, Haskell has several to choose from! But List plays a different role.
16:45:19 <Cale> Beginners tend to overuse lists a bit, which is okay, but results in suboptimal performance.
16:45:20 <SrPx> the community is huge, we could do it
16:45:37 <merijn> syrion: Oh, you can strip of the 't' parameter, but the reason your initial entirely point free form didn't work is that (.) doesn't let you skip two parameters like you were trying)
16:45:45 <Cale> But experienced Haskell users still use lists in a lot of cases!
16:45:52 <Cale> and they're ideal for a lot of things
16:45:55 <syrion> merijn: That makes sense.
16:46:04 <volty> levi: i was not talking about how to implement in haskell, I was talking about how haskell is implemented
16:46:18 <volty> i could be wrong, but that is my opinion
16:46:22 <volty> got it ?
16:46:31 <merijn> syrion: So "hammingDistance s = length . filter (uncurry (/=)) . zip s"
16:47:02 <levi> volty: I'm not sure you're understanding what Cale and I are trying to say about the relationship in haskell between List and the semantics of the language.
16:47:22 <phaazon> off
16:47:24 <phaazon> see you all
16:47:28 <exio4> \o phaazon
16:47:32 <volty> the lists under the hood can be implemented in infinite ways
16:47:34 <merijn> volty: The simple answer is "because that way of implementing lists in haskell doesn't make a lot of sense in haskell's model of the world"
16:47:54 <syrion> merijn: I think this is actually more readable to me -- hammingDistance s t = length . filter (uncurry (/=)) $ zip s t
16:47:55 <merijn> I can rephrase that argument 10 times, but that's the only answer you can possibly get
16:48:04 <merijn> syrion: Sure, that's fine too
16:48:05 <levi> volty: They could be, but it turns out that the way they *are* implemented turns out to fit well with the semantics of the language.
16:48:31 <volty> haskell is a wonderful language, i think that the prob. lies (apart implementation, maybe) that there are many communist-like haskellers
16:48:42 <volty> close mind and the only one truth
16:48:46 <merijn> ...
16:48:50 <mayski> wut
16:48:52 <syrion> ...
16:48:56 <syrion> wat
16:49:04 * benmachine hums the soviet national anthem
16:49:05 <merijn> volty: Did you perhaps consider that you're the one not seeing something?
16:49:07 <benmachine> just me?
16:49:18 <hughfdjackson> benmachine: forgot the words, sorry
16:49:20 <mayski> haskellers of the world unite
16:49:27 <hughfdjackson> (and tune)
16:49:27 <benmachine> hughfdjackson: hence humming :P
16:49:31 <benmachine> oh
16:49:33 <levi> volty: I think you ought to look at the Reduceron research too if you think Haskell implementation people are closed-minded about how it could be implemented.
16:49:33 <benmachine> just hum badly
16:49:39 <hughfdjackson> benmachine: :D can do
16:49:40 <mayski> there's a spectre looming over the programming world, the spectre of haskell
16:49:51 <volty> i'm talking about mentality, not about the effective political orientation
16:49:55 <orb__> volty, haskellers are very open to other languages, like Agda.
16:50:08 <exio4> and Idris too!
16:50:25 <levi> Haskellers are also generally open to all sorts of low-level implementation tweaks to make code run faster.
16:50:25 <Lutin`> volty: No one is forcing someone to only use Lists
16:50:36 <Lutin`> If you want some other data structure there are plenty!
16:50:50 <orb__> levi, and actually, lots of some do appreciate C somewhat.
16:51:05 <levi> GHC is a pretty sophisticated compiler these days, at least along some axes of sophistication.
16:51:07 <orb__> Lutin`, reminds me of Okasaki's foreword.
16:51:21 <Lutin`> orb__: :)
16:51:54 <levi> volty: It seems to me that you've got a preconceived notion about the value of implementing things as arrays vs. the trade-offs that implies in other areas.
16:51:55 <syrion> the only languages that seem to really attract "adherents" in the sense you mean, volty , seem to me to be lisps
16:52:03 <merijn> volty: I program in C/C++/asm/CUDA and haskell for work, I program in a bunch more things in my own time in different languages and have done so from kernel level up to "web", so I don't think I (or many others here) fit the "closed mind, only on truth model"
16:52:04 <orb__> volty, but it depends on what you measure against.  Compared to other niche languages, Haskell has an outsize influence on the mainstream.
16:52:15 <orb__> syrion, nah, Haskell's a cult, too.
16:52:21 <volty> bug logic, you use lists, I use lists, but that doesn't mean that I can say my considerations on .... lists
16:52:25 <orb__> syrion, only we know that we are right, and the lispers are wrong.
16:52:37 <mkscrg> typeclass constraint question:
16:52:49 <orb__> syrion, C++ people sometimes have really bad stockholm syndrome.
16:52:50 <mkscrg> given some existential type like   data Some c = forall a. Some (c a)
16:52:52 <exio4> merijn: I am jelly :(
16:53:01 <merijn> orb__: I actually kinda like C++ nowadays :)
16:53:03 <mkscrg> can i write an instance like   instance ToJSON (forall a. c a) => ToJSON (Some c) where {...}
16:53:12 <merijn> exio4: Not if you knew what I got paid for writing haskell... :p
16:53:14 <mkscrg> or something to that effect?
16:53:37 <orb__> merijn, I don't want to have to think about the various different `smart' pointers (and then still have the default syntax be for the dumb pointer and dumb string).
16:53:48 <volty> orb__: I do not buy that, pity that i do not have time to break that of yours in pieces - - since haskell cannot come up with frameworks the others have, let's talk about how much others are influenced by haskell
16:54:04 <volty> that's small street quarrel logic
16:54:07 <orb__> merijn, SCB pays ok for writing Haskell.
16:54:12 <syrion> I got a recommendation to revisit C++11, but I bought the C++11 primer and found it just as dense and painful as ever
16:54:19 <merijn> orb__: I'm working on my phd, hence the sucky pay :)
16:54:28 <Lutin`> merijn: What's your phd on?
16:54:30 <orb__> volty, what do you mean by frameworks?
16:54:39 <orb__> merijn, oh, a phd is a labour of love. :-P
16:54:50 <merijn> Lutin`: graph processing, fine grained parallelism, GPUs and "big data" ;)
16:54:55 <volty> qt, gui, speed web, ecc ccc. do not exhaust me, pls :)
16:54:58 * hackagebot cached-traversable 0.1.0.0 - Transparent, persistent caching of lazy, traversable structures  http://hackage.haskell.org/package/cached-traversable-0.1.0.0 (ThomasTuegel)
16:55:02 <orb__> XML transforms data into big data.
16:55:06 <merijn> So far it's mostly only medium data, but still :)
16:55:26 <jle`> nkar: `maybe` is literally as general a combinator as it gets...
16:55:27 <levi> C++ has various warts, but if you need to exert tight control over things like representation of data and data lifetime, there aren't a lot of industrial-strength competitors.
16:55:30 <volty> make something rubyrails-like, pretty useful
16:55:48 <jle`> you can use maybe to implement literally any other `Maybe` combinator
16:55:48 <Lutin`> volty: You mean like Yesod?
16:55:56 <merijn> mkscrg: I don't think you need the forall a on the constraint, but I think it should work, yeah
16:55:59 <Lutin`> volty: http://www.yesodweb.com/
16:56:03 <orb__> volty, oh, that kind of frameworks.  If you normalize by number of people using the language, I don't think Haskell is an outlier either way in terms of frameworks.
16:56:05 <jle`> so... you're not going to find anything more general :)
16:56:18 <volty> Lutin`: i'm honest, believe me, I"ll try it and come back to tell you how it compares
16:56:19 <orb__> levi, what about C and Forth?
16:56:44 <orb__> levi, and, yes, C++ has some niches, but it's still awful.
16:56:46 <merijn> orb__: Naah, C definitely not in terms of being able to write safe/statically checked code
16:56:51 <jle`> I think it is actually the case that no other combinator can imitate `maybe`, but `maybe` can implement any other combinator
16:56:54 <merijn> Rust, maybe, hopefully, one day
16:57:03 <Lutin`> mmm Rust
16:57:05 <syrion> Honestly, in terms of qt and GUI, I think most new languages will never have them -- they will have javascript/html front ends.
16:57:06 <jle`> so... it is the most general combinator possible
16:57:07 <volty> i really love haskell, but I'm afraid to go on for production
16:57:07 <levi> orb__: C falls in that category, but it provides extremely limited facilities for abstraction.
16:57:08 <orb__> jle`, fromMaybe is also universal.
16:57:18 <jle`> really?
16:57:22 <Lutin`> I <3 lifetimes and ownership
16:57:22 <orb__> levi, yes, but at least it doesn't blow your leg up.
16:57:30 <levi> orb__: Sure it does.
16:57:32 <merijn> :t fromMaybe
16:57:32 <orb__> volty, start small.
16:57:33 <lambdabot> a -> Maybe a -> a
16:57:44 <orb__> levi, or at least, you know how it'll blow your leg.
16:57:44 <merijn> jle`: It's fromJust that's broken :)
16:57:47 <syrion> volty: You might try Clojure. I have some Clojure code in production that has made me quite happy. (Large parallelized ETL)
16:58:01 <jle`> what if I cannot provide a value of type `a`
16:58:06 <volty> yes, but then I have to interface for the results etc etc. // i'll do something, anyway :)
16:58:09 <merijn> jle`: Then you can't use fromMaybe
16:58:12 <orb__> fromMaybe x . fmap f == maybe x f
16:58:13 <orb__> :t maybe
16:58:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:58:22 <dfeuer> Whoever was saying lists are deeply integrated into Haskell is perhaps overstating the point.
16:58:31 <jle`> ah. fmap first.
16:58:39 <Lutin`> jle`: What about Cont?
16:58:48 <dfeuer> There are some special optimizations for lists, yes, but I think not really that many.
16:58:50 <orb__> dfeuer, lists are only somewhat integrated into Haskell's syntax.
16:58:55 <jle`> fromMaybe + fmap is as general as maybe
16:59:07 <jle`> fromMaybe itself is not universal
16:59:09 <dfeuer> But twice as easy to read.
16:59:21 <levi> orb__: C++ probably requires more skill to wield skillfully, but when it's used well I believe it's less error-prone than C.
16:59:24 <orb__> Lists are about as integral to Haskell as they are to Lisp.  Ie not that much, apart from the popular conception.
16:59:34 <orb__> levi, selection effect. :o)
16:59:37 <volty> everything is a graph, and in special cases equivalent to a list
16:59:40 <benmachine> dfeuer: I don't think the point is overstated
16:59:42 <dfeuer> orb__, depends on the LISP era :)
16:59:53 <orb__> That's why I didn't all caps.
16:59:59 * hackagebot cached-traversable 0.1.0.1 - Transparent, persistent caching of lazy, traversable structures  http://hackage.haskell.org/package/cached-traversable-0.1.0.1 (ThomasTuegel)
17:00:00 <benmachine> dfeuer: I mean, they don't need to be technologically integrated to be culturally so
17:00:08 <dfeuer> Oh, I see.
17:00:17 <levi> orb__: No, I'm talking about language features and the way that they can be exploited to make writing correct code easier.
17:00:17 <orb__> benmachine, yeah, but it's mostly what we tell beginners.
17:00:26 <volty> graphs are a good example: can be stored in an array & pointers or just pointers
17:00:28 <benmachine> orb__: no I actually legit use lists all the time
17:00:48 <jle`> Lutin`: what about it?
17:00:49 <dfeuer> benmachine, I don't know that it's *lists* per se, so much as data-structured programming.
17:00:49 <orb__> benmachine, lists are just a good data structure to learn lots of Haskell-isms on.  And their are legit often,
17:01:00 <orb__> basically any time your compiler can actually fuse them away.
17:01:31 <levi> orb__: Having the blind lead the blind on a C++ team could be disastrous, but I think an expert C++ lead and a less experienced team would be better than the same working in C.
17:02:20 <orb__> levi, perhaps.  I don't know.
17:02:23 <jle`> basically, I was saying... if you are looking for a more general Maybe combinator than `maybe`, you aren't going to find one... it's literally the most general combinator possible :)
17:02:34 <orb__> jle`, yes, just not the only one. ;o)
17:02:41 <Lutin`> jle`: Oh that's what you meant
17:02:59 <dfeuer> FYI, forgetting the -j2 really does make building GHC slower.
17:03:01 <volty> yes, as for the complexity, c++ scales much much better than c
17:03:21 <orb__> volty, because it starts higher?
17:03:32 <jle`> fromMaybe + fmap is cheating ;_; by some arbitrary standard that I will leave vague enough so nobody can argue :)
17:03:50 <jle`> probably because it is a combination of two combinators
17:03:52 <volty> enclosed, implied domains, templated ...
17:03:56 <jle`> ya that sounds right
17:04:09 <orb__> jle`, but maybe also needs a helper function.
17:04:17 <jle`> it does?
17:04:26 <jle`> maybe is all-sufficient
17:04:30 <jle`> all hail maybe
17:04:31 <levi> orb__: I understand your concerns with C++, certainly, and I mostly use C myself. But C has severe weaknesses, and C++ addresses some of them well such that judicious use of C++ features can allow for a much safer programming style.
17:04:33 <orb__> volty, do you know if C++ has parametricity by now?
17:04:42 <kadoban> I think I hate working in C++ or C with less experienced people. They're both very...foot meets gun
17:04:50 <jle`> the one true Maybe combinator
17:05:20 <orb__> levi, yes, it addresses some C concerns.  Unfortunately, nailing planks to the dog does not an octopus make.
17:05:21 <jle`> you can implement both fmap and fromMaybe with maybe alone... and literally any other combinator, without any help.
17:05:27 <orb__> levi, I like D in principle.
17:05:47 <orb__> They address the concerns better.  Alas, there hasn't been as much engineer hours thrown at D as at C++, and it shows.
17:06:04 <orb__> jle`, so can you do with pattern matching. ;o)
17:06:18 <jle`> hm?
17:06:29 <orb__> jle`, pattern matching can implement all combinators, too.
17:06:32 <volty> orb__: i think about handling the complexity of a big frameworks & applications
17:06:41 <orb__> volty, what about that?
17:06:43 <jle`> yes. but pattern matching is not a combinator
17:06:52 <orb__> volty, C++ gives you no useful guarantees.
17:06:56 <orb__> jle`, true that.
17:07:06 <levi> C++ gives more useful guarantees than C does.
17:07:10 <volty> when functional + parametricity begin producing equivalent products we can start talking about the respective usefulness
17:07:13 <Cale> volty: There are lots of other possible data structures, and we have those too!
17:07:13 <jle`> maybe is just a first class case statement anyway
17:07:14 <orb__> volty, where useful includes things like purity and side-effect freeness.
17:07:19 <Cale> volty: We just don't *call* them lists
17:07:27 <orb__> volty, oops, should have been, purity and eg parametricity.
17:07:34 <orb__> volty, what guarantee you can't get in C?
17:07:41 <syrion> The only way I can see myself ever using C++ would be if I were writing embedded software
17:08:04 <Cale> volty: Lists occupy a very special point in the design space of data structures for sequences.
17:08:16 <orb__> volty, we had a very nice Haskell GUI framework at Standard Chartered when I worked there.  (They still have it, I just don't work there anymore.)
17:08:19 <levi> C++ has a stronger type system and it makes it much easier to safely manage memory allocation.
17:08:26 <volty> the world is unpure, I saw (on YT) one of the haskell fathers saying something like «haskell is an intelligent useless language ... » :)
17:08:31 <orb__> Cale, by being essentially the simplest possible sequence.
17:08:36 <Cale> orb__: yes
17:08:51 <Cale> and that has lots of consequences in terms of what they're good for
17:09:11 <orb__> levi, interesting, how does C++ make the mem. alloc safety easier?
17:09:15 <levi> Not to mention the usefulness of simple templates to implement reusable and type-checked abstractions.
17:09:26 <Lutin`> orb__: Using things like shared_ptr give you stronger guarantees about passing pointers around
17:09:27 <volty> you can have purity and go nowhere (with that purity), and you can have dirty try & retry steps and build cathedrals (and bazaars too)
17:09:29 <Cale> volty: Well, that's where Haskell started out
17:09:39 <orb__> levi, templates are better than void*, I guess.
17:10:00 <volty> that's where it will remain if sticked too much to that «purity»
17:10:02 <Cale> volty: It's been moving solidly in the direction of being more useful ever since it started
17:10:11 <levi> orb__: Basically, firing destructors when things go out of scope.
17:10:13 <orb__> volty, Haskell's doing fine, thanks.
17:10:30 <orb__> levi, that's a poor man's gc, ain't it?
17:10:36 <Cale> volty: Well, you can keep evaluation pure without compromising anything in terms of how easy it is to express effects
17:10:41 <volty> my doubt is about the scalability, i know it shines on closed small domains
17:10:45 <Cale> (Haskell basically shows how to do this)
17:10:45 <levi> orb__: Not really.
17:11:07 <orb__> levi, yeah, it's reasonable deterministic.
17:11:12 <orb__> reasonably.
17:11:15 <Denommus> orb__: that has nothing to do with a GC, and GC can't do the same C++ does with RAII
17:11:17 <syrion> http://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring :'(
17:11:17 <levi> It's a tightly-scoped region-based allocator.
17:11:27 <Cale> volty: In Haskell, we just separate evaluation (the process of reducing expressions to values for the purposes of pattern matching), from execution (the process of carrying out the instructions described by IO action values to cause effects)
17:11:31 <orb__> Though nothing that wouldn't be better expressed with higher order functions.
17:11:38 <orb__> (Which C doesn't have, true.)
17:11:41 <volty> going to sleep, but before i go I'll tell you the last mine
17:12:05 <Denommus> orb__: in C++ (and in Rust), you have the concept of resource ownership. If the owner of the resource goes out of scope, the resource is deallocated. There's no need for runtime checking for that
17:12:09 <levi> You've got to have a language that you can implement your high-level language runtimes in. :P
17:12:09 <orb__> Denommus, it's more like reference counting than GC.
17:12:15 <Cale> volty: and in this way, we don't have to compromise purity of evaluation at all, and yet we still get to describe effects just as (or even more) expressively as imperative languages
17:12:21 <Denommus> orb__: meanwhile, if you need to access the resource from other places, you either borrow or move it
17:12:32 <orb__> Denommus, yes, but keeping the resources ownership right is keeping up too much brain cycles..
17:12:39 <volty> we, humankind, evolved faster when we begin doubting our Lord — so let's start doubt that our Haskell is perfect :)
17:12:42 <orb__> Denommus, how does that interact with parallelism?
17:12:42 <Denommus> orb__: it would be like reference counting if you were only allowed to have a single reference
17:12:45 <Cale> volty: In fact, it tends to be even better, because IO actions are themselves values, and so you get to write functions which construct new IO actions from old which act like data structures.
17:12:55 <orb__> volty, we know that Haskell ain't perfect.  That why we have agda and idris.
17:12:56 <Cale> volty: I'm not claiming that Haskell is perfect
17:13:00 <Denommus> orb__: for parallelism you need reference counting
17:13:10 <Cale> volty: But the things you're complaining about aren't its problems ;)
17:13:11 <orb__> And we also have the record syntax to remind us of the flaws.
17:13:22 <orb__> Denommus, actually, for serious parallelism GC beats reference counting.
17:13:28 <volty> cale i know all this, but it doesn't scale well when i just want to fix a problem  (i do not care about dividing pure & dirty ) :)
17:13:30 <orb__> because reference counting needs to do work on every read.
17:13:32 <Cale> It *does* have problems :)
17:13:38 <Denommus> orb__: as for "keeping the resources ownership takes brain cycles", that is true for C++, but Rust enforces them at compile-time
17:13:39 <volty> bye :), you are nice people :)
17:13:51 <orb__> volty, dividing pure and dirty does help keep your brain free often.
17:13:52 <Cale> volty: I disagree about it not scaling well, but we can save that for another time
17:13:54 <orb__> volty, sleep tight.
17:14:06 <orb__> Denommus, sounds great.
17:14:18 <orb__> I've heard decent things about Rust.
17:14:58 <Cale> Has anyone watched Jonathan Blow's talks about attempting to construct a better programming language for low level game programming?
17:14:59 * hackagebot postgresql-simple 0.4.6.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.6.0 (LeonSmith)
17:15:09 <Denommus> orb__: I can't really compare GC to RC in this specific case. What I do know is that RAII allows for some interesting stuff
17:15:22 <levi> orb__: Anyway, I'm not trying to sing the praises of C++ or anything. It's got contexts where it's still the best fit, as does C, and I really wish there was more innovation down there.
17:15:45 <Cale> He's still a bit of a beginner when it comes to knowing what's already out there, but he has some relatively interesting ideas for the design space of non-GC'ed languages.
17:15:57 <orb__> Oh, C++ has lots of engineer hours gone into its polishing.  That's why it's semi-usable at all.
17:15:58 <levi> I'll have to look for that, Cale.
17:16:41 <Denommus> orb__: for instance, in Rust, if you need shared ownership of a resource between tasks, you use Arc<T> (which is atomically reference counted). But this will work for read-only. If you need read-write shared ownership, you use Arc<RWMutex<T>>, which automatically creates a mutex for that specific resource
17:17:01 <Denommus> orb__: once the access to the resource is out of scope, the mutex is freed.
17:17:05 <orb__> Denommus, ok.
17:17:18 <Denommus> orb__: there's also RWLock, which is similar, but uses lock instead of mutexes
17:17:21 <orb__> Denommus, but we can have the same thing with combinators over bracket.
17:17:29 <orb__> Haskell's bracket or Lisp's dynamic unwind.
17:17:30 <levi> I have persistent dreams about a low-level language that bakes in even fewer decisions about things than C does.
17:17:50 <orb__> levi, have you tried building on llvm assembly?
17:18:20 <levi> No, but I'm not talking about an assembly language either.
17:18:32 <levi> I'm thinking more along the lines of Forth or Bliss.
17:18:38 <orb__> Denommus, my quip about gc outperforming ref counting on large parallelism is for really large stuff.  We've seen that at Google in some file system like projects.
17:18:53 <rkazak> bliss…. the good old days..
17:18:54 <Cale> I still feel like eventually we'll do things in Haskell or another high level language which will take care of lower level details better.
17:19:07 <Cale> (for games specifically)
17:19:14 <orb__> Cale, it would be useful to have good escape hatches from the higher level stuff.
17:19:17 <Denommus> orb__: I don't think dynamic unwind is equivalent to resource ownership
17:19:21 <orb__> That still interact well.
17:19:24 <levi> Something that'd give you the tools to express low-level details succinctly and clearly, and then let you get back to writing high-level stuff in a high-level language.
17:19:26 <Cale> I can imagine an FRP system with totally deterministic bounded memory control, for instance.
17:19:32 <hughfdjackson> Cale: john blow's recent 'designing a language for games' was interesting for that
17:19:33 <orb__> Denommus, dynamic unwind == RAII?
17:19:52 <Cale> hughfdjackson: Yeah, that's what I'm talking about, there were two talks he gave on stream (and which are now on his youtube)
17:20:14 <orb__> levi, and make assertions about properties your low level stuff fulfills, so that the compiler can make use of that in optimization (or be careful, if your low level stuff has no properties and is essentially toxic waste).
17:20:15 <hughfdjackson> oh, sorry! should have read further up :) i came back in recently
17:20:20 <mkscrg> put differently, can i write an instance that works like   instance ToJSON (c a) => ToJSON (Some c) where
17:20:33 <Cale> hughfdjackson: I just think that he's a little too scared of having a GC around :)
17:20:40 <orb__> John Carmack has some ideas about FP style (in C++), too.
17:20:45 <mkscrg> GHC asks for UndecidableInstances, then gives up
17:20:46 <Lutin`> Cale: That reminds me of https://hackage.haskell.org/package/atom
17:21:05 <Cale> hughfdjackson: It's possible to write critical things in such a way that they take care of their own memory, while having higher level parts of the game written using a GC
17:21:10 <Cale> Lutin`: yes!
17:21:13 <orb__> How much GC can we do at statically at compile time?
17:21:13 <hughfdjackson> Cale: it can definitely be hard to replace tried + true with some little-understood tech
17:21:27 <Cale> hughfdjackson: Yeah, and I can understand where he's coming from there
17:21:29 <orb__> I guess stream fusion does some of that, if squinted at the right way.
17:21:39 <exio4> orb__: are you talking about Mercury?
17:21:53 <mkscrg> merijn: GHC says "Variable ‘a’ occurs more often than in the instance head"
17:21:54 <levi> orb__: Well, having the ability to do static analysis of various properties would be nice, but that's not the primary interest I have in this idea.
17:21:59 <hughfdjackson> Cale: it would be v. interesting to see a hybrid GC + ownership approach
17:22:06 <Cale> having worked on an FRP system for an action RPG, it's a lot of work, and if it were my business rather than just the one I worked for, I'd be pretty scared about how it'd pan out.
17:22:37 <Cale> (Our game didn't get finished before we ran out of money, I ended up pretty convinced that it could have worked though!)
17:22:43 <Lutin`> Man you guys make it hard to study for a midterm haha
17:22:49 <orb__> Apropos FRP, check out the other FRP (functional relational programming).
17:23:01 <orb__> Relations and fp work together really well.
17:23:18 <hughfdjackson> Cale: interesting! what flavour of FRP did you end up using?
17:23:41 <hughfdjackson> :) i've used the elm-variety (which some seem to not consider real FRP at all) some, but none of the others
17:23:42 <Cale> Arrow-y, with our own definition of Arrow that made it more like the definition of a symmetric monoidal category
17:24:04 <Cale> (and our own proc/do preprocessor that used the new primitives)
17:24:21 <orb__> exio4, no, what's Mercury?
17:24:46 <Cale> Basically, we needed to avoid using arr for all the basic tuple manipulation which goes on when you translate the proc/do notation. The game ran about 10 times faster once we did that.
17:24:54 <hughfdjackson> Cale: wow, the haskell wiki on arrows needs a little love :p
17:25:11 <Cale> Yeah, well, Arrow as it stands undermines its own best use case
17:25:20 <Cale> So, it's not surprising that it's not popular
17:25:23 <orb__> Has the dust settled on the lens libraries?
17:25:36 <Cale> However, it's *very close* to something which would be a really good abstraction for FRP and many other things
17:25:57 <exio4> orb__: a programming language with "compile-time" garbage collection! (I haven't really looked much at it, it is my "TODO" list ;P)
17:26:00 <orb__> Cale, is that the continuous (ie true) FRP, or some restricted more useful subset?
17:26:01 <exio4> https://mercurylang.org/
17:26:31 <Cale> orb__: We had effectively continuous behaviours (the values which the arrows manipulated) along with events
17:26:44 <levi> orb__: Mercury is to logic programming (e.g. Prolog) what Haskell is to the functional language family.
17:27:00 <levi> Roughly, anyway.
17:27:01 <orb__> exio4, ok.  I read about doing static ref count analysis.  Ie you can basically do something simple like stack allocation for most variables, and don't need to count refs.  And the compiler can figure that out on its own.  GC should be similar-ish, since gc and refcount are dual.
17:27:07 <orb__> (There was a paper about that duality.)
17:27:14 <hughfdjackson> Cale: :) I'll add arrows to my list of things to read about/try out
17:27:20 <Cale> orb__: Continuity was a bit of an illusion in our case -- you could only sample a behaviour on occurrences of an event, and there were limited ways in which to get genuinely new occurrences of events.
17:27:28 <orb__> Cale, but no continuous values, I guess?
17:27:49 <orb__> Cale, sounds like a useful subset?
17:28:01 <Lutin`> Alright I gotta study
17:28:03 <Lutin`> Night guys
17:28:08 <Cale> See you Lutin`!
17:28:08 <Lutin`> and gals
17:28:09 <orb__> Night Lutin`.
17:28:18 <orb__> and furry creatures.
17:28:23 <exio4> good night Lutin`!
17:28:25 <Cale> orb__: Yeah, basically, we needed to avoid the problem of having to do too much computation on any given frame
17:28:53 <exio4> orb__: if you're bored... https://mercurylang.org/documentation/papers/CW2004_03_mazur.pdf :P
17:29:02 <Cale> orb__: If you allow infinitely fine Zeno's paradox style regressions to take place, you can end up getting behind in your computation.
17:30:05 <orb__> exio4, actually, I'm at work.
17:30:05 <Cale> So, it really helps not to write that sort of thing if there's a top-level where event occurrences get pumped in.
17:30:05 <orb__> Cale, understandably.  Can you do any static analysis to avoid that, or is it just a human enforced style?
17:30:11 <Cale> orb__: In our case, we just designed the library to make it hard to do bad things.
17:30:25 <meretrix> Say I have a Parser defined as "char '<'; n <- count 4 digits; char '>'".  I want to parse "blah blah blah <1234> blah".  How do I make it skip the blahs and just return "1234"?
17:30:34 <orb__> Cale, and easy to do good things. ;o)
17:30:40 <Cale> orb__: yes :)
17:30:56 <orb__> meretrix, return n at the end?
17:31:01 <benzrf> meretrix: not easily!!
17:31:08 <Cale> benzrf: wat
17:31:12 <benzrf> Cale: well
17:31:12 <benzrf> meretrix: how efficient do you need?
17:31:13 <orb__> oh, you need to get rid of the blahs.
17:31:14 <Cale> Yeah, it's just return n :P
17:31:18 <Cale> oh
17:31:26 <Cale> I see what's being asked now :)
17:31:27 <orb__> Cale, he doesn't parse the blahs, yet.
17:31:30 <meretrix> orb__: yes
17:31:43 <orb__> By the way, that looks like a regular language.
17:31:47 <Cale> Can the blahs include < ?
17:31:53 <meretrix> Efficiency is not critical, just something simple.
17:31:58 <orb__> string "blah" I'd say.
17:32:03 <benzrf> meretrix: Cale's q
17:32:07 <orb__> sepEndBy spaces (string "blah")
17:32:19 <meretrix> The blahs can include "<", but not "<[0-9]>"
17:32:46 <Cale> ah, okay
17:33:07 <orb__> meretrix, that's a regular language.  I'm working on a library to make parsing that nice and efficient.
17:33:17 <Cale> So you could write something like  many (noneOf ['0'..'9'])
17:33:17 <meretrix> Ah cool
17:33:25 <orb__> (OK, it's already reasonably nice to use general Parsec, but not efficient to do so.)
17:33:41 <Cale> However, Parsec makes that a little more interesting
17:33:57 <Cale> Because it by default doesn't want to let you backtrack
17:34:20 <Cale> and that 'many' is going to eat your <
17:34:26 <SrPx> is there any data structure that works like an array and provides O(log(n)) random read/write?
17:34:39 <Cale> So you might need to stick in a 'try'
17:34:42 <SrPx> and is pure, no IO/ST
17:34:48 <SrPx> that is just for curiosity, btw
17:34:54 <Cale> SrPx: Data.Sequence
17:35:01 <orb__> Cale, if you want simple, just do backtracking.
17:35:08 <Cale> SrPx: which is based on a really interesting data structure called a FingerTree
17:35:28 <orb__> SrPx, what do you mean `works like an array', and then O(log(n))?
17:35:29 <SrPx> Cale: ah I'm aware of FingerTree, thank you!
17:35:30 <Cale> SrPx: You get log of distance to nearest end time concatenation and splitting at an arbitrary point.
17:35:44 <trap_exit> in haste
17:35:45 <kadoban> SrPx: That kinda describes just a basic balanced tree structure
17:35:51 <trap_exit> in haste how do I do double -> JSString ?
17:35:55 <SrPx> kadoban: yep
17:35:56 <trap_exit> i.e. a fast version of show
17:36:35 <kadoban> SrPx: So, an AVL tree, red-black tree, etc. Or yeah there's fancier ones, but those are nice and easy-ish to understand.
17:36:38 <SrPx> Cale: are trees such as those practical for applications where you'd use a C array?
17:36:53 <trap_exit> you mean O(1) access
17:36:53 <Cale> some of them!
17:36:54 <SrPx> sorry for pinging Cale specifically
17:36:57 <trap_exit> vs O(log n) access ?
17:37:21 <Cale> Arrays get used in C for many things where they don't really need to be used
17:37:51 <kadoban> SrPx: If you're looking for abstractions of them, not specificly how to implement them: Data.Map and Data.Set are maybe what you're looking for.
17:37:54 <SrPx> I'd be interested in viewing benchmarks highlighting the performance differences... might as well do myself, though
17:38:03 <Cale> SrPx: But Data.Sequence does have fairly sizeable overhead
17:38:04 <prinsen> In FFI exports of functions on user defined data types, can we do nothing better than void*?
17:38:10 <syrion> What's the standard way to wrap really long ADT declarations, ie data A = B | C | D | E ...
17:38:19 <SrPx> hmm
17:38:28 <syrion> just a second line and 4 spaces?
17:38:42 <Cale> syrion: Line up subsequent |'s with the =
17:38:50 <Cale> data A = B
17:38:51 <HeladoDeBrownie> syrion, I tend to write the 'data A' on the first line, then indent, '= A', then '| B', '| C', and so on
17:38:53 <Cale>        | C
17:38:56 <Cale> etc.
17:39:26 <HeladoDeBrownie> As opposed to Cale's suggestion, which I don't do because I don't like the idea of having a potentially arbitrarily large alignment
17:39:46 <HeladoDeBrownie> It's up to you of course
17:39:55 <Cale> Well, the alignment will rarely be all that large
17:40:00 <Cale> It's just the name of the type and its parameters
17:40:23 <syrion> so wrap even before the =, HeladoDeBrownie ?
17:40:28 <Cale> I'd probably do the same as HeladoDeBrownie if the name of my type was for some reason really long
17:40:33 <Cale> But I don't like really long type names
17:41:51 <HeladoDeBrownie> syrion, that's what I do, yeah.
17:41:57 <mkscrg> if anyone feels like a typeclass puzzle, i made an lpaste of my issue here: http://lpaste.net/112275
17:42:42 <trap_exit> https://gist.github.com/anonymous/c07c58092f4f6bf43cfb <-- WTF how do I tell it to load the hidden library?
17:43:29 <kadoban> trap_exit: I think you have to edit the package if you want to.
17:43:29 <benzrf> mkscrg: that instance cant exist
17:43:42 <benzrf> mkscrg: it requires all types to be ToJSON instances
17:43:47 <Cale> mkscrg: You ought to be able to write the instance for Some Foo
17:44:15 <benzrf> mkscrg: oh w a i t
17:44:16 <benzrf> nvm
17:44:32 <mkscrg> Cale: yes indeed
17:45:03 <Cale> mkscrg: But yeah benzrf and GHC are correct, knowing that you have an instance for c a, for some particular arbitrary choice of a, doesn't tell you that you have it for the 'a' which is in use when you unpack that Some data constructor
17:45:07 <benzrf> mkscrg: i think the problem is that the forall needs to be inside the instance head
17:45:09 <benzrf> er
17:45:10 <benzrf> the constaint
17:45:20 <benzrf> mkscrg: this is like forall a. (a -> a) -> a
17:45:20 <benzrf> vs
17:45:25 <benzrf> (forall a. a -> a) -> a
17:45:32 <benzrf> have you tried:
17:45:33 <benzrf> instance ToJSON (c a) => ToJSON (Some c) where
17:45:34 <benzrf> er
17:45:38 <benzrf> instance (forall a. ToJSON (c a)) => ToJSON (Some c) where
17:45:41 <benzrf> is that valid syntax?
17:45:49 <Cale> No, you can't write that
17:46:13 <Cale> (sometimes frustratingly, but in this case, that constraint is rather hard to justify)
17:46:37 <mkscrg> benzrf Cale: yeah, tried that
17:46:53 <Denommus> Cale: I personally like Netwire's approach on FRP
17:47:19 <Cale> mkscrg: It's important to realise that when you apply the data constructor Some :: c a -> Some c, you're effectively *forgetting* which type 'a' is.
17:47:33 <mkscrg> it *feels* (w/ my limited understanding of ghc internals and theory) like ghc should know it has ToJSON (Foo a) for all types a
17:47:39 <Cale> mkscrg: and so you can no longer do any operation on the values when you take them out which relies on knowing what type that is.
17:48:01 <Cale> This is a little different in the case of GADTs because you can recover that information by inspection of the GADT data constructor
17:48:11 <benzrf> mkscrg: the problem is that the a in ToJSON (Foo a) is forall'd OUTSIDE of the ToJSON contraint
17:48:15 <mkscrg> Cale: yeah, that's what i'm using GADTs for
17:48:25 <Cale> So you ought to be able to write:
17:48:30 <benzrf> OOOOOOOOHhhhh. wait
17:48:36 <benzrf> i missed how the GADT factors in sheesh
17:48:36 <Cale> instance ToJSON (Some Foo) where
17:48:58 <Cale> Well, I'm not even sure what to implement now ;)
17:49:09 <Cale> But yeah, that should be easy to write
17:49:21 <Cale> But for an arbitrary choice of c, it will be extremely difficult
17:49:29 <mkscrg> Cale: yeah:   toJSON (Some v) = toJSON v
17:49:45 <Cale> uh, does that work?
17:50:16 <Cale> You don't need to pattern match on v?
17:50:27 <Cale> I think you might need to pattern match on v :)
17:50:31 * hackagebot FunGEn 0.4.4 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4.4 (SimonMichael)
17:50:36 <Cale> I suppose I could be wrong!
17:50:37 <orb__> mkscrg, how do you ToJSon (a -> b)?
17:50:49 <mkscrg> Cale: you don't need to pattern match
17:51:05 <Cale> I guess you have an instance for Foo a already
17:51:08 <Cale> yeah, okay
17:51:11 <mkscrg> because there is an instance (ToJSON (Foo a)) that covers all the constructors
17:51:27 <mkscrg> that's the heart of my confusion
17:51:37 <Cale> hmm
17:51:42 <mkscrg> i've told GHC how to convert Foo a to JSON for all types a
17:52:02 <Cale> So, the tricky bit is how to express to GHC that you have an instance for every a. I believe there is a package for this :)
17:52:10 <Cale> Ed's done this :)
17:52:16 <Cale> (and I've done it too actually)
17:53:20 <mkscrg> Cale: i can do it "manually" with a      class ToJSON1 c where { toJSON1 :: c a -> Value }
17:53:42 <mkscrg> then    instance ToJSON1 c => ToJSON (Some c)     is easy
17:54:35 <mkscrg> but that doesn't decrease the surface area of the problem vs writing   ToJSON (Some Foo)
17:54:35 <Cale> Actually, let me try this myself first before I go recommending you use this crazy thing ;)
17:54:52 <Cale> http://hackage.haskell.org/package/constraints-0.4/docs/Data-Constraint-Forall.html
17:54:58 <Cale> ^^ this ought to express what you want to express though
17:55:07 <mkscrg> (in truth I have several GADTs parameterized over the same group of types)
17:55:15 <mkscrg> Cale: thanks, looking
17:55:33 <Cale> mkscrg: Basically, you need a constraint-level forall
17:55:49 <staffehn> Hi, does someone here know how patternmatching on constructors gets compiled? I mean how efficient is it to have a datatype (enum style [like Ordering]) with about 300 constructors, and then write a function that uses patternmatching to decide what to return in every specific case? Is it doing 300 equality tests or does it compile to something more efficient? I mean the enum type should be like a number internally and in ASM I could just do a
17:55:49 <staffehn> relative jump (pointer arithmetic with the enum's numeric value) to get a result in constant time with one jump.
17:55:53 <mkscrg> Cale: yeah, that makes sense to me
17:56:09 <benzrf> staffehn: w-what
17:56:13 <benzrf> why would you make a type like that
17:56:16 <Cale> mkscrg: This does it by introducing some hidden types which aren't exported, and using the fact that if p A and p B hold when A and B aren't even in scope, then p a ought to hold for every a.
17:56:40 <Cale> (I'm actually a little unsure why there are two Skolem variables and not one...)
17:57:10 <Cale> It uses some unsafeCoerce hackery internally
17:57:24 <staffehn> benzrf: I made an enum type for the Minecraft Block types.
17:57:55 <staffehn> benzrf: I'm just wondering if it might be horribly inefficient.
17:58:29 <mkscrg> Cale: gotcha. unsafeCoerce is new territory for me, enjoying digging in though
17:58:47 <staffehn> benzrf: and still I'm wondering what pattern matching on constructors actually compiles to.
17:59:03 <Cale> mkscrg: Well, it's scary, but this usage ought to be safe enough :)
17:59:09 <HeladoDeBrownie> staffehn, instead of having that many constructors, you might consider giving the type enough fields to cover all variation in block types
17:59:55 <HeladoDeBrownie> staffehn, I can't speak to efficiency, but I'm sure I would not love to pattern match on a type with 300 constructors
18:00:21 <benzrf> staffehn: why not just make a type that holds block info
18:00:23 <benzrf> then store those
18:00:30 <benzrf> if you make a single outside thing like:
18:00:31 * hackagebot test-framework-th-prime 0.0.7 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.7 (KazuYamamoto)
18:00:50 <benzrf> grass = baseBlock {texture = "grass.png"}
18:00:56 <benzrf> world = [[grass, grass]]
18:00:57 <benzrf> or something
18:01:03 <benzrf> i'm sure that can compile toa shared reference
18:03:07 <staffehn> HeladoDeBrownie: well the file that contains the type and a few function has about 1400 lines, but there are really soo many block types and I'd like to have their names somewhere, so the alternative would be to have the block type just a number and a Map (or an Array) with the names and stuff laying around there and use Map lookup or Array indexing to do the "functions". The complexity of the Maps would be logarithm of the amount of blocks. I'm
18:03:07 <staffehn> just wondering if patternmatching is just linear or better.
18:04:54 <HeladoDeBrownie> staffehn, there are greater concerns. What happens when Minecraft updates and new blocks are added, like the granite and such? If you added new constructors, you'd also have to change every place you pattern matched over every constructor.
18:05:18 <lpaste> Cale pasted “this works, lol” at http://lpaste.net/112278
18:05:26 <Cale> mkscrg: ^^
18:05:43 <staffehn> HeladoDeBrownie: that would be only that one file that defines the block type anyways
18:05:43 <HeladoDeBrownie> staffehn, my point here being that if you can be correct and logarithmic time or incorrect and linear, you're probably better off going for the former
18:06:05 <Cale> I'm not sure I'd really want to do that in production code, unless it was going to save me a hell of a lot of trouble.
18:06:28 <HeladoDeBrownie> Well, "correct" is probably the wrong word.
18:06:46 <Cale> (Using ForallF)
18:06:56 <mkscrg> Cale: aha! was trying to figure out how to assemble ForallF, Dict, instF, etc
18:07:11 <HeladoDeBrownie> staffehn, anyway, you don't need to use a Map. Array is usually O(1) random access.
18:07:35 <mkscrg> yeah, possiblr more witchcraft than i want for this
18:07:51 <staffehn> HeladoDeBrownie: well I need a function from block name to id somehow.
18:08:04 <HeladoDeBrownie> staffehn, ah, I see
18:08:27 <HeladoDeBrownie> Logarithmic time isn't that bad on only hundreds of elements anyway
18:08:48 <orb__> HeladoDeBrownie, log is better than linear, even with same correctness.
18:09:04 <HeladoDeBrownie> orb__, I misspoke, I meant constant instead of linear.
18:09:28 <HeladoDeBrownie> I'm wiped out, I should probably get to bed instead of being on IRC. :P
18:09:40 <Cale> It's a little bit funny in the first place to say that any lookup into a data structure which is potentially arbitrarily large is "O(1)"
18:09:56 <staffehn> HeladoDeBrownie: hmm I'm wondering how much GHC can optimize if you have 256 cases of string pattern matching. I'll check the optimized core on that now..
18:10:19 <Cale> You need more than O(1) time to be able to examine all the bits of the index :)
18:10:25 <sbrg> Cale: theory seldom matches practice, etc etc
18:10:50 <HeladoDeBrownie> I think I shall indeed depart. Have fun all~
18:11:14 <staffehn> Cale: on a word machine indexing is O(1)
18:11:22 <Cale> Unless the structures have a maximum size you've agreed on ahead of time, making asymptotic analysis pretty degenerate, because then everything is O(1)
18:11:56 <Cale> If you've bounded the size of the structure, you can iterate over the whole structure in O(1) time
18:11:58 <Guest8986> Hey guys. I'm trying to understand this function, but I  can't even figure out what data it accepts to mess around  with it. http://pastebin.com/eXQr8vZN
18:12:18 <Guest8986> Can anyone help me figure this out?
18:12:38 <Cale> Guest8986: sure
18:12:58 <mkscrg> Cale benzrf: appreciate you're help on the quantified constraint issue. cheers!
18:13:03 <mkscrg> *your :)
18:13:05 <Guest8986> Cale: thanks a bunch. I can see it is comparing something, but I tried strings, characers,s everyting
18:13:07 <Cale> Guest8986: Well, it might help to also have definitions of ||| and <**> and epsilon, though I can imagine what they might be :)
18:13:15 <Guest8986> it just thrws errors
18:13:27 <Cale> Guest8986: Oh, well, the type of star is RegExp -> RegExp
18:13:32 <staffehn> OK, so it seems nobody here knows how basic constructor patternmatching compiles :(
18:13:39 <Cale> that is, it's a function which takes a value of type RegExp, and produces another
18:13:51 <Cale> And RegExp itself is a synonym for (String -> Bool)
18:14:08 <Cale> So the full type of star is (String -> Bool) -> (String -> Bool)
18:14:55 <Cale> staffehn: Oh, sorry if I sidetracked your actual question
18:16:18 <Cale> staffehn: Matching against a constructor more or less consists of first evaluating the scrutinee (by following a code pointer), and then when that finishes, checking against an integer tag
18:16:44 <Cale> (and there will be (code) pointers to the components of the constructor alongside that tag
18:16:46 <Cale> )
18:17:46 <Cale> Guest5073: So, this presumably isn't your entire file, perhaps you could paste more code on lpaste.net and I could give you an example of how star might be used.
18:18:58 <Cale> staffehn: Is that the sort of thing you wanted to know? I can link you to some relevant papers if you're interested in such low level details. It's probably more useful just to benchmark which is faster using criterion or something if you're just trying to figure out what performs better.
18:20:47 <Cale> staffehn: There's also pointer tagging going on in modern GHCs, which means that for types with few constructors, the low-order bits of the code pointers for already-evaluated values are used to replicate the integer tag, so you might even skip having to jump into the code for the expression.
18:21:44 <Cale> and there's a lot of other optimisations which might mess with your intuition about how fine-grained details like that ought to perform
18:22:11 <staffehn> Cale: yea, papers would be nice.
18:22:46 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf -- this is somewhat out of date, but mostly still relevant
18:23:25 <Cale> (and includes some really good discussion about the runtime implementation of expressions)
18:24:31 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm
18:24:37 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm
18:24:43 <Cale> those are also pretty relevant
18:26:31 <staffehn> OK, I'll take a look at them
18:27:11 <Cale> staffehn: Reading back a bit (I missed the start of this conversation), matching on 300 constructors might still involve trying each in turn, I'm not sure. It's quite uncommon to have so many, and if in doubt, factoring your types better would usually be a better idea.
18:27:22 <staffehn> Hmm, but isn't there anything in the GHC documentation about how patternmatching is implemented?
18:27:50 <Cale> It's complicated...
18:27:59 <lpaste> dmwit pasted “pop quiz: does it parse?” at http://lpaste.net/112280
18:28:05 <Cale> and keeping that documentation up to date would be lots of work :)
18:28:26 <dmwit> You can learn some amazing things by reading the Report.
18:29:22 <staffehn> dmwit, what "Report" you mean? Are you talking to me?
18:29:23 <Cale> dmwit: wow, tabs
18:29:35 <dmwit> Cale: http://dmwit.com/tabs
18:29:37 <Cale> staffehn: No, he's talking about the funny piece of code he just pasted
18:29:42 <dmwit> Cale: It's even got a quote from you there!
18:29:50 <staffehn> ah
18:29:53 <dmwit> staffehn: I was talking to nobody and everybody. Not you in particular.
18:30:35 <Herdinger> Hey all I'm trying to lear Haskell for the x time now
18:30:52 <Cale> dmwit: If you mix tabs and spaces, I reserve the right to hate you
18:31:01 <Herdinger> This time around I got What I Wish I knew about haskell 2.0 and I'm on a good track.
18:31:09 <dmwit> Cale: If you hate me without understanding why it's okay, I reserve the right to reject your complaints.
18:31:36 <Herdinger> Are there any books like designpatterns for haskell or fp in general?
18:31:37 <Cale> dmwit: Even though you might adopt some combination of tabs and spaces which make it "okay", it's still a pain in the ass to deal with.
18:31:42 <dmwit> Correction: why *I* think it's okay.
18:31:50 <dmwit> You don't have to agree it's okay, as long as you understand why I do.
18:32:26 <dmwit> Cale: I wonder if you'd elaborate slightly. What makes it a pain in the ass?
18:32:46 <dmwit> Herdinger: The Pearls are nice.
18:33:39 <dmwit> ?wiki Research_papers/Functional_pearls
18:33:40 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
18:33:54 <staffehn> dmwit: GHCI says that foo is type "Foo Bool" and trying to pattern match on it makes an infinite loop.
18:34:27 <Cale> dmwit: In general, having to care about the order in which invisible things occur while editing is obnoxious. You can make them visible (which you probably ought to do if you're really doing this), but it's still not going to be as easy to work with as if it were just all spaces.
18:34:33 <dmwit> staffehn: Yes. The snippet of code should make beginners go, "okay, so what?", intermediate users go, "uh, wait, what?", and expert users go, "yeah, that's a weird corner case".
18:34:53 <merijn> dmwit: Now I'm curious, which snippet?
18:34:58 <dmwit> Cale: I do make them visible. What's your additional complaint?
18:34:59 <Cale> dmwit: You're also somewhat forced into annoying style, where you have to put a newline after any layout keyword.
18:35:10 <dmwit> Cale: That is incorrect.
18:35:28 <Cale> Okay, well, you don't *have* to :)
18:35:29 <dmwit> Cale: And tells me you didn't bother reading.
18:35:33 * hackagebot dynamic-state 0.1.1.0 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.1.0 (fread2281)
18:35:38 <dmwit> Cale: Because I specifically addressed that concern in the text.
18:35:50 <staffehn> dmwit: It is so strange. I'm just wondering how to come up with something like that.
18:35:59 <dmwit> Cale: The additional complaint I'm interested in is the one signalled by "it's not going to be as easy to work with as if it were just all spaces".
18:36:13 <Herdinger> Haven't seen the pearls before
18:36:19 <dmwit> merijn: lpaste.net/112280
18:36:19 <Herdinger> looks promising
18:37:41 <dmwit> staffehn: The code itself is just there to appease the type-checker.
18:37:45 <Cale> dmwit: Well, if it's all spaces, you don't have to worry about whether any given bit of whitespace is a tab or space while you're editing -- the distinction doesn't matter
18:37:48 <staffehn> dmwit: seems like replacing the "True" with a "undefined :: Bool" wouldn't change anything, because it is never reached.
18:37:53 <dmwit> staffehn: The actual interesting bit there is the lexical structure, not the behavior.
18:37:54 <Cale> dmwit: which makes editing easier
18:38:07 <staffehn> dmwit: yea, right
18:38:10 <merijn> dmwit: ow, my brain
18:38:37 <Cale> dmwit: If I chop out some block which is inside a where clause and lift it, or move code inward, I don't need to worry about the precise sequences of tabs and spaces that are now required
18:38:56 <Cale> dmwit: Having to care about that is obnoxious
18:39:04 <Cale> (and unnecessary!)
18:39:05 <dmwit> Cale: That's an interesting complaint.
18:39:17 <dmwit> I can't say I've had that problem, though it certainly seems imaginable.
18:39:21 <dmwit> I'll watch for that annoyance.
18:39:41 <dmwit> For now I can't say much more than "I don't experience that otherwise perfectly probably-sounding annoyance".
18:39:56 <staffehn> dmwit: Hmm, I don't quite get why exactly the lexical structure should be that interesting.
18:40:12 <dmwit> In the same spirit as "I experience many otherwise improbable-sounding annoyances when using such-and-such structured editors". ;-)
18:40:17 <merijn> staffehn: The mixing of braces and layout looks unintuitive to newcomers, I guess
18:40:28 <Cale> I honestly think things would be better if the only form of whitespace which were admitted in Haskell source code was the space
18:40:35 <Cale> We don't allow vertical tabs after all
18:40:40 <dmwit> staffehn: It looks surprising because there's a bit of nested layout with a smaller (!) indentation level than the surrounding layout.
18:40:41 <Cale> (well, and the newline ;)
18:40:44 <dmwit> And yet it parses fine.
18:40:56 <merijn> Cale: We do allow vertical tab, but only in some places
18:41:04 <Cale> Yeah, I suppose inside of comments
18:41:12 <Cale> Maybe it's okay to allow them inside of comments
18:41:40 <Cale> Tabs don't really provide enough benefit to make up for the pain they cause.
18:41:47 <staffehn> merijn, dmwit: Yea, braces just brake normal layout assumptions.
18:42:02 <dmwit> These are record braces, not layout braces.
18:42:04 <dmwit> (hint)
18:42:14 <merijn> Cale: No, vertical tab is perfectly valid outside of comments according to the report
18:42:28 <Cale> merijn: Oh, well, GHC doesn't like them, iirc.
18:42:47 <Cale> Even if the report allows them
18:43:18 <dmwit> Cale: Have you used tabs long enough to feel the pain you proposed (e.g. moving code across indentation levels)?
18:43:23 <staffehn> dmwit: The interesting thing (in my opinion) is only that those are mandatory braces you can't ommit.
18:43:25 <stef1a> i have code that works with arguments of type Double but fails with arguments of type Complex Double with this error: http://lpaste.net/6144565292388319232
18:43:38 <stef1a> can someone tell me how i can correct this so it will work with Complex Doubles?
18:43:49 <Cale> dmwit: When I was a beginner, before I learned how to configure my editor to only produce spaces, I suppose.
18:44:01 <Cale> dmwit: Maybe you could claim that I didn't try long enough
18:44:07 <dmwit> I wouldn't claim that.
18:44:11 <Cale> dmwit: But still, why incur the extra worry?
18:44:14 <dmwit> I don't believe in denying reality.
18:44:20 <Cale> Tabs provide literally no benefit
18:44:28 <dmwit> Cale: For fun, and because it's nice for people to be allowed to choose their tabstops.
18:44:43 <dmwit> Cale: And because I want to one day transition to really well-done elastic tabstops. =)
18:44:48 <merijn> stef1a: Your type claims to take a list of Complex Double as input, but your pattern says otherwise
18:45:13 <merijn> stef1a: "(a:+b)" <- a and b are Complex Double there, so you're attempting to create a "Complex (Complex Double)"
18:45:22 <Cale> Elastic tabstops are something else. I think the correct encoding if we were using something like elastic tabstops wouldn't agree with the one which results from this
18:45:28 <merijn> stef1a: Surely you mean "a + b"?
18:45:38 <stef1a> merijn: ohhhhhh. duh.
18:45:43 <dmwit> Cale: I agree. Hence my comment at the end saying this is only one step towards elastic tabstops.
18:45:57 <stef1a> merijn: thank you, kind sir / madam!
18:46:03 <merijn> stef1a: Try and walk backwards through the error
18:46:14 <Cale> Really, elastic tabstops aren't the right thing either
18:46:20 <dmwit> ...I agree.
18:46:47 <dmwit> Hence my comment at the end about how to improve elastic tabstops. =)
18:46:51 <Cale> But spaces are unambiguous in all cases, and simple to think about.
18:47:02 <merijn> It's saying it expected 'a' to be Double because of your use of :+, the rest shows you through which expressions it inferred 'a' must be Double (i.e. from the fact that you're returning a [Complex Double])
18:47:09 <Cale> Well, we should be storing structural information, not strings
18:47:23 <dmwit> Yep. Spaces-only is a popular choice, and for good reason.
18:47:49 <Cale> and if you want to move to something else at some point, you can always parse the files which have spaces in them and convert them
18:48:06 <Cale> without having to ever care about tabstops
18:48:17 <dmwit> Cale: I don't think that's quite right. Spaces don't have *quite* enough semantic information to do it properly.
18:48:21 <dmwit> But neither do tabs.
18:48:32 <Cale> Well, Haskell has enough semantic information to do it properly :P
18:48:40 <dmwit> If you want the right solution, you have to move to some other file format than boring old text.
18:48:46 <dmwit> Cale: No, I still don't agree.
18:48:53 <Cale> You can literally parse the Haskell source code and convert it into a syntax tree, which then goes into your new file format
18:49:13 <Cale> and then preferences about displaying that syntax tree can be rendered by the editor
18:49:29 <dmwit> Cale: The Haskell syntax tree doesn't store all the important bits. e.g. if I want to align equals signs in a where block, or binding marks in a do block, or first arguments to functions on several lines, or ....
18:50:04 <dmwit> Those are reasonable things to want to be able to do sometimes and not others.
18:50:04 <Cale> Well, yeah, there's something to be said about storing local overrides to preferences alongside that
18:50:10 <dmwit> So you need more semantic information.
18:50:19 <Cale> But those things are equally recoverable from code with tabs in it as code with spaces
18:50:35 <dmwit> But that's a whole different story; as mentioned in my post, that whole discussion is impractical because it requires a complete rework of the toolchain from the ground up.
18:50:38 <staffehn> OK, I've been wondering this for some time, what is the best way to vie .lhs files?
18:50:41 <Cale> yep
18:50:47 <carter> Cale: are you helping rob convince them to dev in the open?
18:50:53 <carter> plz :)
18:50:57 <Cale> Which is why I'm not convinced there's any reason for you to use tabs
18:51:09 <Cale> carter: hm?
18:51:15 <dmwit> Cale: Eh? I told you my reason.
18:51:23 <carter> aren't you working on the ppaml project? :)
18:51:27 <dmwit> Cale: I want user-definable tabstops.
18:51:45 <dmwit> Cale: Just because current tooling can't do the best thing doesn't mean we can't use current tooling to do something good.
18:51:50 <Cale> carter: Oh, yeah, but I only really know Jacques
18:52:01 <carter> huh
18:52:04 <carter> oh, canada
18:52:13 <dmwit> I like four-space tabstops. My previous advisor liked six-space tabstops. Others like two-space tabstops.
18:52:40 <carter> Cale: rob == zaxtax
18:52:41 <dmwit> I knew a guy that liked three-space tabstops. Those are all easily achievable with today's tech and this style.
18:52:46 <dmwit> That's not possible with spaces-only.
18:53:02 <Cale> dmwit: I think with Haskell code, I don't care how much people indent things by, so long as they line things up, and the lines aren't so long as to be frustrating to fit on my screen.
18:53:15 <Cale> dmwit: I'm totally inconsistent about it myself
18:53:26 <dmwit> And there's you, who has no preference. Which is fine. But you shouldn't deny that other people have different preferences than you...
18:53:28 <Cale> I have tab configured to insert two spaces
18:53:32 <carter> i'm down to 2 space tabs
18:53:38 <carter> because i have such nested gnarly stuff
18:53:39 <Cale> which I use as a fast spacebar
18:55:00 <Cale> dmwit: I'd actually rather see the code exactly as the person wrote it.
18:55:06 <Cale> in general
18:55:11 <dmwit> Yes, you've mentioned that before.
18:55:14 <dmwit> Which you can't have.
18:55:23 <Cale> Well, I can have, if they use spaces :)
18:55:28 <dmwit> I don't.
18:55:37 <Cale> Yeah, but I don't have to see your code either ;)
18:56:57 <syrion> I have preferences, but the most important thing is that, whatever project you're working on, you adhere to the project standards
18:57:15 <dmwit> I agree that the goals "I want to see the code exactly as it was written" and "I want to allow renderers flexibility" appear to be at odds.
18:57:32 <dmwit> syrion: Yes, this is rule one in the rules at http://dmwit.com/tabs =)
19:00:28 <dmwit> Cale: I will add your complaint (about code motion) to the page a bit later this week. Thanks for the discussion.
19:00:34 * hackagebot unagi-chan 0.2.0.1 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.2.0.1 (BrandonSimmons)
19:01:17 <hakujin> dmwit: tabs with a vim style modeline snippet defining a default layout would allow for both intent and flexibility
19:02:01 <dmwit> hakujin: That's not a bad idea!
19:02:11 <merijn> hakujin: That doesn't really help since everyone sane has modelines disabled
19:02:13 <dmwit> hakujin: I've been meaning to learn about modelines for a while.
19:02:23 <hakujin> merijn: ;P
19:02:26 <Cale> dmwit: My main point is that the mental burden of coping with rules involving how tabs get used just evaporates if you only use spaces, and you lose very little in return, apart from being able to adjust the width of the tabstops, and how often do you really do that?
19:02:31 <dmwit> merijn: It would help Cale, because he would look at the modeline. ;-)
19:02:52 <dmwit> Cale: You do it every time the code switches machines. That's pretty often.
19:03:13 <Cale> Moreover, you could still adjust the effective "width of the tabstops" after the fact, if someone were to write a program to do it by following your rules.
19:03:17 <dmwit> Cale: I don't find there's much mental burden. But there are some legitimate complaints (that I am currently trying to fix).
19:03:34 <Cale> I still think spaces are the best thing to store in the file, for now.
19:03:38 <dmwit> Cale: Actually, you can't. Because you need to know which spaces are for indentation and which are for alignment.
19:03:47 <dmwit> Cale: You can't recover that information once you've converted everything to spaces.
19:03:51 <Cale> dmwit: You can infer that from the structure of the code
19:04:11 <dmwit> Cale: Not reliably. (I've tried.)
19:04:18 <Cale> Where does it break down?
19:04:39 <dmwit> There's plenty of places where a thing could be either indented or aligned, and sometimes it's one or the other.
19:04:57 <dmwit> e.g. some people align things like "foo = bar . baz" as "foo = bar\n    . baz".
19:05:13 <dmwit> On the other hand that second line might reasonably be an indentation instead in other cases.
19:05:30 <dmwit> You can give some heuristics. But they inevitably screw up.
19:05:39 <dmwit> There's just More Information there if you use two different characters.
19:06:34 <Yxven> I think go has a right idea with the compiler enforcing formatting standards
19:06:56 <Yxven>  not that I've tried it
19:07:12 <merijn> Yxven: So do I, any compiler I write will just enforce a "One True Way" (or maybe the "Several True Ways")
19:07:22 <merijn> But Haskell syntax is ridiculously over flexible
19:07:33 <Cale> Yxven: Yeah, I really wish that we'd just specified that tabs weren't admissible from the outset
19:07:51 <Cale> Rather than enforcing that they align to multiples of 8 spaces
19:08:02 <dmwit> Aligning to multiples of 8 was a mistake, yes.
19:08:05 <Cale> Then these arguments wouldn't be arguments :)
19:08:08 * artyomkazak wonders whether anyone uses non-breaking spaces in Haskell to control layout even more precisely
19:08:11 <dmwit> But the correct rule is to make them incomparable with spaces. ;-)
19:08:23 <tnks> Joey Hess took this to extremes in a style completely of his own. . . mixing tabs and spaces.
19:08:35 <dmwit> tnks: I also mix tabs and spaces.
19:08:38 <Cale> Also, I think that 'then' and 'else' should be required to be aligned if they occur on different lines.
19:08:55 <Cale> Just because not doing so encourages bad style
19:09:01 <dmwit> tnks: Does Joey Hess describe his style anywhere?
19:09:04 <merijn> Cale++
19:09:15 <tnks> dmwit: I think he came with a /lot/ of sensibilities from C.
19:09:23 <tnks> had a shit ton of complicated editor settings.
19:09:36 <merijn> My sensibilities are changing over time as I write more haskell
19:09:51 <tnks> and just found the 8-space tab happened to work out and ran with it.
19:09:58 <syrion> basically my style just evolves from hating everything about Ruby as I write code for my day job in it
19:10:03 <merijn> For example, I used to align constructors with each other with the = after the type name and used to linebreak type signatures at the first => or ->
19:10:07 <syrion> whatever is the least rubyish, i like
19:10:15 <benzrf> syrion: oh poo
19:10:20 <benzrf> ruby is rather nice io
19:10:21 <benzrf> *imo
19:10:27 <merijn> Now I find myself linebreaking after the typename/function name so that there is a consistent, non-variable length indent for those
19:10:43 <benzrf>   
19:10:45 <syrion> it has its points, benzrf , but when you approach a certain level it devolves into torture
19:10:46 <simpson> syrion: So, J or Factor?
19:10:50 <benzrf> syrion: oh?
19:11:13 <dmwit> tnks: So, is that a no...?
19:11:18 <BMeph> simpson: Yes, please! ;þ
19:11:26 <merijn> simpson: At PLDI this year I saw someone present an APL dialect compiler written in APL
19:11:32 <syrion> simpson: hmm?
19:11:37 <tnks> dmwit: you can see an example here:
19:11:39 <tnks> https://github.com/joeyh/propellor/blob/master/src/Propellor/CmdLine.hs
19:11:52 <merijn> simpson: It was described as "very readable and terse"
19:11:52 <tnks> I couldn't find much documentation of this style.
19:11:55 <simpson> merijn: That cannot be a healthy lifestyle.
19:11:57 <syrion> benzrf: It stems from a culture that embraces too much dynamism. Any gem that you start using can be trusted to monkey-patch something somewhere
19:12:07 <benzrf> :I
19:12:12 <simpson> syrion: Two examples of languages totally unlike Ruby.
19:12:12 <merijn> simpson: It was basically 40 character long line noise in on big dense block
19:12:53 <simpson> merijn: Nice.
19:12:57 <SrPx> What is a synonym for (flip $) on prelude?
19:13:00 <syrion> simpson: Never actually looked at either, I confess. ;) Mostly I like Clojure and Haskell right now.
19:13:11 <tnks> dmwit: if you look at Joey's style and it happens to be exactly like yours, let me know, because from where I sat, it was really confusing.
19:13:24 <simpson> syrion: Expand your horizons and your syntax. :3
19:13:28 <BMeph> simpson: Full disclosure, my first programming job was in FORTH. :)
19:13:34 <syrion> benzrf: And, this may be more rails than ruby, but the performance is completely, seemingly, nondeterministic. My metrics see-saw at random.
19:13:46 <simpson> BMeph: I still love forth!
19:13:47 <merijn> Forth is still on my "too learn" list, together with J and Racket
19:13:48 <BMeph> simpson: On a Kaypro, no less. ;)
19:13:50 <dmwit> tnks: It's not exactly like mine, though there are some similarities.
19:13:51 <artyomkazak> SrPx: is there one?
19:14:17 <syrion> simpson: I think next I will be learning a forward-chaining rules system, like Clara.
19:15:15 <dmwit> tnks: My main complaint is that he ends tab-indented blocks with space-indented things.
19:15:26 <tnks> dmwit: yup.
19:15:42 <tnks> pretty sure he's got the magic spaces-indents-spaces combo.
19:15:51 <BMeph> I'm impressed with BOBJ/OBJ3/Maude, just from a, "and it knows what you mean?!?"-perspective.
19:15:55 <tnks> it all compiles. . . but confuses the hell out of me.
19:15:56 <artyomkazak> SrPx: wait, do you mean (flip $) or (flip ($))? The former is just flip
19:16:12 <tnks> I mean, he /has/ to know. . . you don't do that by accident.
19:16:27 <dmwit> tnks: What confuses you?
19:16:42 <tnks> dmwit: the rhyme/reason.
19:16:49 <marchelzo_> where to inquire about problems installing haskell packages?
19:16:54 <dmwit> Oh. Well how he chooses seems pretty clear.
19:17:02 <merijn> marchelzo_: Depends, does it involve Yesod? :)
19:17:02 <dmwit> "where" is two spaces, everything else is one tab.
19:17:19 <tnks> dmwit: yeah, but it's spaces for all these special forms.
19:17:20 <marchelzo_> merijn: indeed. not yesod itself but that is the end goal
19:17:28 <marchelzo_> merijn: currently getting a linker error
19:17:31 <merijn> marchelzo_: Have you tried #yesod ? :)
19:17:50 <Qfwfq> merijn: Hahah
19:17:53 <merijn> (Note: I've never used Yesod except once for 20 minutes a year ago, so...)
19:17:57 <syrion> my company got a code exercise submission where the candidate aligned all of the code to the left. tabs or spaces are both preferable.
19:18:27 <dmwit> tnks: Oh, no, he has adjacent lines that are supposed to align that use "\t" and "  \t". That's a big no-no in my opinion.
19:18:31 <merijn> marchelzo_: Yesod is notoriously tricky to install due to the huge amount of dependencies, there's some tricks like using Stackage, but yesod experts can probably help you better :)
19:18:33 <dmwit> tnks: That doesn't seem to be on purpose.
19:18:41 <tnks> dmwit: also, I think he's been inconsistent, and lucks out that it all works out, because his editor renders tabs as 8-spaces.
19:18:47 <dmwit> Yes. =(
19:19:04 <dmwit> I disavow this use of mixed tabs and spaces.
19:19:05 <dmwit> ;-)
19:19:08 <Clint> tnks: you could send him an expandtab patch for his .vimrc
19:19:34 <tnks> Clint: I don't have any reason to intrude.
19:19:41 <marchelzo_> merijn: i dont think the current error is related to yesod, I can't link to -lHSmtl-2.1.3.1-ghc7.8.3
19:19:42 <dmwit> tnks++
19:20:09 <Clint> tnks: and yet you've been discussing it for over 10 minutes
19:20:10 <tnks> but it is an example of the wackiest whitespace policy I've seen in Haskell.
19:20:30 <tnks> Clint: yeah, I've probably overstayed the topic.
19:20:34 <dmwit> Clint: I started it, I'm afraid.
19:20:45 <tnks> mostly just because dmwit was interested in mixing tabs and spaces.
19:23:06 <Yxven> Does anyone know how to convert a  juicy pixel DynamicImage to an Image?
19:23:32 <prinsen> Im writing Storable instances, is there any way to write a Storable a => Storable [a]?
19:23:44 <dmwit> newp
19:23:54 <dmwit> Gotta know the size of a thing statically for it to be Storable.
19:24:13 <dmwit> Of course, you can store a Ptr [a].
19:25:16 <AshyIsMe> SrPx: ive seen someone use |> for that, it's the same as the f# syntax
19:25:23 <AshyIsMe> they call it pipe
19:25:32 <AshyIsMe> i kinda like it
19:26:15 <SrPx> artyomkazak: sorry, I meant something like `(f op g) x = g (f x)`
19:26:26 <AshyIsMe> [1..10] |> map (+ 2)
19:26:28 <SrPx> AshyIsMe: hmm I see, it is on prelude ?
19:26:38 <AshyIsMe> same as: map (+ 2) $ [1..10]
19:26:42 <SrPx> nice
19:26:47 <AshyIsMe> no, not in prelude
19:26:47 <SrPx> thanks
19:26:51 <SrPx> ah
19:26:54 <AshyIsMe> im not sure if there's one by default in haskell
19:27:01 <dmwit> Control.Arrow offers (>>>).
19:27:10 <merijn> AshyIsMe: I think & is going into base in 7.10?
19:27:11 <tnks> I think we looked for that "flip apply" signature on Hoogle and found the wheel reinvented a lot.
19:27:15 <SrPx> it looks neat imo, I will use it, hope it doesn't make my code confusing
19:27:15 <dmwit> But it's a bit unwieldy, and it's weird to bring in all the mighty, out-dated Arrow machinery just for that.
19:27:25 <merijn> dmwit: >>> is not the same as |>
19:27:25 <monochrom> @hoogle &
19:27:27 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
19:27:27 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
19:27:28 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
19:27:36 <dmwit> merijn: Oh?
19:27:42 <dmwit> merijn: Oh. Yes, of course.
19:27:46 <merijn> dmwit: >>> is composition |> is "flip ($)"
19:27:48 <dmwit> dmwit--
19:27:59 <AshyIsMe> i guess if you squint really hard |> kinda looks like a "P" for "pipe"
19:28:08 <merijn> dmwit: Also isn't >>> in Category nowadays? :)
19:28:16 <merijn> :t (>>>)
19:28:16 <gcganley> :t >>>
19:28:17 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
19:28:17 <lambdabot> parse error on input ‘>>>’
19:28:21 <dmwit> Who can keep up with this stuff? =)
19:28:29 <dmwit> I mean, besides you, obviously.
19:28:51 <merijn> dmwit: I have nothing better to do than memorise base and troll #haskell during my compile and test times at work :p
19:28:54 <Qfwfq> (&) will be in base soon, so probably best to converge on that syntax
19:29:12 <Qfwfq> Arrow is in base so likewise for (>>>)
19:29:16 <fread2282> Qfwfq: really?
19:29:18 <AshyIsMe> it's used already in Data.Sequence apparently: http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Sequence.html#v:-124--62-
19:29:28 <gcganley> :t (<<<)
19:29:29 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
19:29:42 <dmwit> Too bad we can't have (;) = flip (.).
19:29:48 <Qfwfq> fread2282: Yeah, with the release of 7.10 in February(?)
19:30:11 <fread2282> :o
19:31:54 <AshyIsMe> hmm, what is |?
19:32:03 <AshyIsMe> oh it's part of the guard syntax
19:33:31 <prinsen> dmwit: so basically the poking of a list field would include newArray?
19:33:51 <Qfwfq> fread2282: https://ghc.haskell.org/trac/ghc/ticket/9008
19:35:01 <AshyIsMe> merijn: is there a git repo somewhere with the upcoming base changes?
19:35:56 <merijn> AshyIsMe: The GHC repo? :p
19:36:01 <AshyIsMe> > :t &
19:36:02 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:36:03 <Qfwfq> I think base was folded into the GHC repo, but not sure
19:36:07 <AshyIsMe> :t &
19:36:08 <lambdabot> parse error on input ‘&’
19:36:20 <merijn> Qfwfq: base *is* GHC
19:36:31 <merijn> Qfwfq: It's shipped with and tied to the compiler
19:36:40 <Qfwfq> Oh, right
19:36:57 <merijn> AshyIsMe: Best way to stay on top of these things is follow libraries@
19:37:27 <carter> yeah
19:37:29 <carter> well
19:37:58 <dmwit> prinsen: No, I'm saying there is no way to make a Storable instance for lists.
19:38:17 <carter> dmwit: unless they're sized lists of storable things
19:38:18 <dmwit> No correct way.
19:38:33 <dmwit> Yes, if you know the size of the list statically you can do it.
19:38:44 <carter> but baically if you cant comput the size in bytes just by looking at the type
19:38:47 <carter> you cant storable it
19:38:50 <dmwit> But then why aren't you expressing that constraint in the type system?
19:38:55 <carter> :)
19:39:04 <carter> dmwit: i'm working out a storable ish thing for var sized things
19:39:10 <carter> well, weaker than storable
19:39:13 <carter> which means more complicatd api
19:39:17 <carter> because its more general
19:39:23 <dmwit> neat
19:39:50 <carter> dmwit: also because i want to write data bases in haskell
19:40:03 <carter> and thus I need to make it easy to write all the various B-Tree thingies
19:40:11 <AshyIsMe> merijn: follow libraries at where?
19:41:05 <carter> AshyIsMe: not sure why he suggested the libraries list
19:41:06 <dmwit> Are you hoping to use this database from other languages?
19:41:09 <carter> but its one of the haskell.rog
19:41:12 <carter> dmwit: sure
19:41:18 <carter> they can use whatever client api i provide
19:41:30 <carter> same as when you call a db in any language
19:41:42 <dmwit> Yes, I was just wondering why you wanted to serialize b-trees. I guess that sort of explains it.
19:41:48 <carter> dmwit: no
19:41:53 <carter> b-trees ARE seriealized
19:42:03 <carter> they're off heap mem mapped things always
19:42:09 <prinsen> dmwit: sure, but no im talking about writing a Storable instance for a data type with a list field
19:42:17 <carter> prinsen: nope
19:42:21 <carter> unless the list is fixed size
19:42:43 <dmwit> prinsen: You'll have to do it a different way. If you tell us a bit more, we have a chance at suggesting something.
19:42:47 <carter> yes
19:42:48 <carter> that
19:42:49 <dmwit> As it is all we can say is "no".
19:43:44 <merijn> carter: The question was "where to follow upcoming changes to base", so libraries@ seems the most relevant place to stay in touch with that sorta thing
19:43:50 <carter> yeah
19:43:50 <carter> well
19:43:57 <carter> that + ghc trac + irc
19:44:02 <prinsen> Im writing (generating .hsc files in TH) Storable instances for large record-types. The field types are mostly Int and String, but also lists and Maybes
19:44:02 <merijn> Sure :)
19:44:22 <carter> prinsen: no, you want Binary or Serial
19:44:29 <carter> unless you've a max size you allow
19:44:46 <johnw> plus, Binary will let you generically generate the instances you need, if they members are that simple
19:44:48 <carter> Storable requires that for a given type, the size in bytes is always fixed
19:44:54 <carter> johnw:!!!!!!
19:44:58 <carter> missed you
19:44:59 <carter> whats up
19:45:02 <johnw> hi carter!
19:45:06 <prinsen> carter: Can't I just use pointers?
19:45:17 <merijn> carter: Also, I just saw that someone is working on extending the FFI with the ability to directly pass and return struct values for 7.10 :D
19:45:21 <dmwit> prinsen: You're still describing the solution you're attempting. You need to tell us about the problem.
19:45:22 <prinsen> carter: Does not FFI require Storable?
19:45:35 <carter> merijn: at teh CMM level
19:45:42 <dmwit> carter likes to jump the gun on suggesting solutions before he knows the problem.
19:45:44 <prinsen> dmwit: exporting UserDefined -> IO UserDefined2 with FFI
19:46:00 <dmwit> prinsen: No, I don't believe that's your problem, either. =)
19:46:06 <merijn> carter: Aww...but that'd pave the way to providing user written primops using them, no?
19:46:11 <dmwit> prinsen: Problems are things like "I want to turn a light switch on when I walk in the room".
19:46:22 <dmwit> prinsen: Or like "I want my game to have RAD PHYSICS".
19:46:55 <prinsen> dmwit: I have a haskell library I want to export to C
19:47:37 <dmwit> prinsen: You'll have to think carefully about the interface to that library that C can support.
19:48:06 <dmwit> prinsen: I generally don't recommend exporting fields as mungable objects to your C code.
19:48:19 <prinsen> dmwit: mungable?
19:48:22 <dmwit> prinsen: Instead, export an opaque blob, together with the operations that C functions should be able to do on them.
19:50:08 <dmwit> prinsen: e.g. instead of struct Foo { int x, int y; } export an opaque type Bar and functions Bar *origin(); and Bar *addFoos(Bar *a, Bar *b), etc.
19:50:08 <prinsen> dmwit: The interface is funcitons UD1 -> IO UD2. I have written code to generate C structs for each UD*
19:51:04 <prinsen> dmwit: The whole haskell library is generated by TH and is only data, there is no operations other than accessing the fields of that data I need
19:51:45 <carter> merijn: yeah
19:51:57 <dmwit> well
19:52:08 <carter> why not generate c code then? :)
19:52:47 <prinsen> dmwit: poorly written by me, what I meen is that UD* only represents data. I could maybe export UD* as opaque types and then export a function for each field Int getIntFieldUD1(UD1* ud1)
19:53:16 <dmwit> I mean, you can define something like struct List { void *data; int len; } and store your lists in there as an array (as you were suggesting).
19:53:28 <dmwit> So I suppose in that sense you can define a Storable instance for [a].
19:54:12 <prinsen> dmwit: and something similary for Maybe
19:54:19 <dmwit> yes
19:54:27 <dmwit> Or the same. =)
19:54:27 <prinsen> carter: I only want 1 core :)
19:54:33 <carter> which ?
19:55:03 <prinsen> Haskell
19:55:33 <prinsen> dmwit: yes :)
19:56:44 <prinsen> dmwit: carter thanks Ill try it out
20:00:34 <joefiori_> transformers-0.4 errors are going to be the death of me :(
20:01:28 <merijn> joefiori_: Why are you trying to use transformers 0.4?
20:01:37 <joefiori_> not trying to
20:02:00 <joefiori_> it's been a massive cause of cabal hell for me
20:02:06 <merijn> joefiori_: Well obviously
20:02:35 <joefiori_> just haven't figured out a good way to solve it, even after reading SO posts
20:02:38 <merijn> joefiori_: Transformers is a GHC dependency, hence why I'm asking why you're trying to use a newer version than GHC has it in the first place
20:02:51 <merijn> That's doomed to bring pain and misery
20:03:25 <joefiori_> merijn: I'm using yesod, or other packages that depend on it, they are bringing me pain and misery
20:03:28 <Hijiri> I'm trying to find a way to find an element of an IxSet that follows a predicate (equality of an index, and having another index in a certain range), and perform some operation on it if it exists, and get some return value back that let's me see if it existed
20:03:56 <Hijiri> Is there a more efficient way than querying the IxSet for a matching value then deleting > reinserting modified value?
20:04:18 <merijn> joefiori_: Sounds like you're trying to use a "too new" version of yesod, but I would consult #yesod for more constructive help
20:09:42 <structuralist> is there a standard memoization library for Haskell?
20:10:17 <carter> joefiori_: are you using stackage?
20:10:39 <carter> at this point yesod kinda requires stackage
20:12:32 <joefiori_> carter: no, maybe I should try it?
20:14:54 <carter> erikd: do you use stackage?
20:15:37 * hackagebot newsynth 0.2.0.1 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.2.0.1 (PeterSelinger)
20:16:17 <erikd> carter: no
20:16:42 <carter> erikd: but should yesod wielding young guns use stackage?
20:18:09 <erikd> carter: i don't know. possibly yes, but i have nothing to back that up or refute it.
20:19:05 <joefiori_> I'm giving it a try, the site doesn't explain the advantages of using it very well, but following the instructions
20:19:31 <carter> joefiori_: another solution
20:19:35 <carter> is the following
20:19:36 <carter> joefiori_: ready?
20:19:44 <joefiori_> carter: born ready
20:20:07 <carter> rm -rf ~/.ghc ; cabal update ; cabal install mtl-2.1.3.1 ; cabal install transformers-compat
20:21:28 <joefiori_> carter: does it matter that I'm in a sandbox? should I get out of it before installing?
20:21:38 <carter> joefiori_: oh
20:21:43 <carter> hrmmm
20:21:45 <carter> joefiori_: hangon
20:21:52 <carter> joefiori_: what ghc version and os are you on?
20:21:55 <carter> and how did you install ghc?
20:22:05 <joefiori_> ghc 7.8.3 osx 10.10 gm
20:22:12 * joefiori_ ducks
20:22:19 <carter> which ghc installer
20:22:26 <carter> ghcformacosx.github.io is pretty nice
20:22:31 <joefiori_> homebrew, built from source
20:23:06 <AshyIsMe> ooh 7.8 has parallel compilation
20:23:08 <carter> joefiori_: NO HOMEBREW
20:23:09 <carter> EVER
20:23:10 <carter> for ghc
20:23:11 <carter> sorry
20:23:14 <AshyIsMe> does cabal take advantage of that automatically?
20:23:14 <carter> nope
20:23:28 <carter> joefiori_: AshyIsMe  yup
20:23:29 <joefiori_> carter: I had it with nix originally, but that was pretty terrible
20:23:31 <carter> AshyIsMe: yup
20:23:41 <carter> joefiori_: brew is less busted than it was
20:23:51 <joefiori_> carter: I'll try the link you sent
20:23:52 <carter> but i'd rather you used something that actually has eyeballs on it
20:25:03 <joefiori_> carter: understandable, I didn't realize the brew recipes were neglected... cabal-install was just updated tonight
20:26:40 <merijn> joefiori_: The best approach on OSX is one of two ways 1) install platform 2) install GHC binary release + cabal from scratch
20:26:48 <scopely> Hi guys... I'm learning pattern matching and was wondering if the only way to return a function parameter as a last resort is to do something like: fn param = param
20:26:51 <merijn> joefiori_: I recommend 1 for any beginner
20:27:07 <scopely> I was trying to achieve something using wildcards but it does not work
20:27:07 <merijn> scopely: Correct
20:27:25 <merijn> scopely: You mean _ ?
20:27:34 <tnks> joefiori_: what was wrong with Nix?
20:27:47 <tnks> I was hoping Nix would have been the sanest of installations.
20:28:01 <merijn> tnks: Pretty hard to beat the Platform
20:28:13 <merijn> "download + double click" and done
20:28:15 <scopely> merijn: yes
20:28:18 <joefiori_> tnks: me too, but ran into tons of compiler errors when trying to install
20:28:23 <scopely> something like: fn _ = _
20:28:36 <prinsen> dmwit: works :)
20:28:46 <joefiori_> tnks: admittedly it could've been my pre-release 10.10 installation
20:28:50 <merijn> scopely: _ is explicitly a pattern that you can't refer to, so that doesn't make sense
20:28:55 <carter> joefiori_: merijn  no
20:28:56 <carter> not paltform
20:29:02 <carter> ghc for osx
20:29:07 <merijn> scopely: Why not "fn x = x"?
20:29:09 <orb__> scopely, you can only have _ on the right hand side as a hole.
20:29:14 <carter> joefiori_: johnw  should be making nix on os x nice
20:29:20 <carter> if not, talk with johnw  about your problems
20:29:22 <merijn> carter: I still prefer Platform
20:29:26 <carter> merijn: dont care
20:29:29 <orb__> scopely, fn x = x works, if and only if, f has a type that's something like f :: a -> a
20:29:36 <carter> the scars and memories go deep
20:29:47 <carter> and also ghc for os x app bundle by etrepum  is magic
20:29:50 <orb__> Ie argument type and return type are the same
20:30:14 <fread2282> merijn: nixos beats the platform IMO
20:30:29 <carter> once i'm on a new computer i'm quit keen ot try out nix
20:30:32 <fread2282> (idk about nix on another os though)
20:30:43 <carter> dont' have as much disk space as I'd like righ tnow
20:31:03 <scopely> merijn: I see... yeah, I guess f n = n works... I just wasn't sure if that was the idiomatic way to do it. Thanks
20:31:28 <orb__> scopely, if that's your only clause, you can also write f = id
20:31:39 <orb__> But that's not the case here. ;o)
20:32:55 <scopely> orb__: that makes sense
20:32:58 <joefiori_> tnks: johnw looks like my nix problems came down to the same transformers-0.4 problem I've been having in every project, so maybe not really nix-related itself
20:33:05 <scopely> > :t foldl
20:33:07 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:33:14 <tnks> joefiori_: good to know.
20:33:14 <carter> joefiori_: use tranformers 0.3
20:33:18 <carter> you'll be happier
20:34:00 <joefiori_> carter: if I had the choice I totally would
20:34:10 <carter> joefiori_: whos making you
20:34:26 <carter> transformers-compat lets you fake 0.4 using 0.3
20:34:32 <carter> be more concrete
20:35:38 <joefiori_> carter: not sure who's making me actually, is there a cabal command I can use to see that?
20:35:38 * hackagebot superdoc 0.1.2.1 - Additional documentation markup and Unicode support  http://hackage.haskell.org/package/superdoc-0.1.2.1 (PeterSelinger)
20:35:47 <carter> joefiori_: what are you trying to install
20:35:53 <joefiori_> yesod
20:35:58 <carter> joefiori_: the package?
20:36:06 <joefiori_> actually, yesod-bin, I already had yesod installed
20:36:12 <carter> umm
20:36:15 <joefiori_> carter: yes, the package
20:36:19 <carter> your not supposed to do that
20:36:20 <carter> afaik
20:36:32 <joefiori_> not supposed to do what?
20:36:44 <carter> joefiori_:
20:36:50 <carter> heres what I want you to do
20:36:53 <carter> make a new sandbox
20:36:55 <carter> then
20:36:58 <carter> type
20:37:10 <carter> cabal install mtl-2.1.3.1 ; cabal install transformers-compat
20:37:15 <carter> then do the rest as normal
20:37:43 <joefiori_> I'm currently installing that in my current sandbox from the command you gave me earlier
20:37:46 <fread2282> the only problem with nixos is you have to choose between compiling a lot or being ~2 weeks behind (sometimes more, often less)
20:38:12 <carter> because the univers changes?
20:40:17 <fread2282> either you're on unstable which only updates when tests pass on CI from master or your on master which often doesn't have stuff built on CI yet so you have to build it yourself, and I've seen a lot of toolchain (rebuild everything) changes recently
20:40:50 <fread2282> (or you're on stable: 6 months between releases)
20:41:31 <joefiori_> carter: thanks for your help, I think the compat did it
20:42:06 <lpaste> orb pasted “Recursion and GADTs” at http://lpaste.net/112285
20:42:16 <orb__> How do I fix myShow in the paste?
20:42:28 <orb__> And what would it's type be?
20:42:54 <lf94> Is there no standard haskell tree that has the notion of "parent", "value" and "children"?...
20:43:05 <carter> joefiori_: or the picking that mtl
20:43:06 <carter> :)
20:43:11 <carter> joefiori_: i'm a wizard :)
20:43:13 <orb__> lf94, having parents and children in the same haskell tree is a bit tricky, but doable.
20:43:20 <lf94> Data.Tree has "label" (which i'll assume is value) and "subForest" (which I'll assume again is children)
20:43:24 <orb__> lf94, perhaps zippers are good enough for you?
20:43:38 <orb__> Why do you need parent?
20:43:46 <lf94> Hm, maybe I don't need parent
20:43:53 <lf94> :t Forest
20:43:54 <lambdabot>     Not in scope: data constructor ‘Forest’
20:43:54 <lambdabot>     Perhaps you meant one of these:
20:43:54 <lambdabot>       ‘First’ (imported from Data.Monoid),
20:44:07 <lf94> Errrrr
20:44:12 <jle`> lf94: you might be interested in Okazaki's purely functional data structures book
20:44:16 <orb__> You should only need parent if you do something crazy.
20:44:17 <jle`> for some nice functional trees
20:44:21 <orb__> lf94, that book is excellent.
20:44:28 <lf94> I'll check it out
20:44:39 <lf94> I just wanted to make a Bittorrent DHT client thing
20:44:49 <lf94> I know the protocol, I know the data structures I need
20:44:51 <joefiori_> carter: good to know I've met a real-life wizard, I'll keep that in mind next time I need a conjuring
20:44:56 <lf94> I just need to code the Haskell now
20:45:18 <orb__> joefiori_, carter's only a wizard on the internet.
20:45:53 <u-ou> hmm, that looks like it might be a good read, jle`
20:46:40 <u-ou> looks like you need to know ML for it tho :I
20:46:55 <lf94> type Forest a = [Tree a]
20:46:58 <lf94> Haha...
20:47:07 <lf94> Why the additional abstraction though
20:47:17 <lf94> That just confuses the hell out of beginners
20:47:19 <orb__> u-ou, just pretend it's haskell.
20:47:34 <carter> orb__: lol
20:47:41 <u-ou> lf94: why String = [Char]?
20:47:41 <carter> or so you think
20:47:52 <lf94> u-ou: yeah but that's pointed out on day 1
20:47:57 <johnw> joefiori_: ah, interesting
20:48:16 <lf94> Anyways, Data.Tree looks wicked :)
20:48:44 <u-ou> can you pretend ml is haskell
20:49:29 <jle`> u-ou: not quite, he has haskell versions of all the code at the back
20:49:32 <jle`> in the apendices
20:49:52 <jle`> the main difference of course is laziness, but he goes into discussion about that too
20:50:04 <carter> https://new-www.haskell.org/
20:50:07 <carter> nvm
20:50:39 * hackagebot fixedprec 0.2.2.1 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.2.2.1 (PeterSelinger)
20:50:41 * hackagebot easyrender 0.1.0.1 - User-friendly creation of EPS, PostScript, and PDF files  http://hackage.haskell.org/package/easyrender-0.1.0.1 (PeterSelinger)
20:52:10 <orb__> Okasaki doesn't really use an ML-isms.
20:52:25 <orb__> And the laziness makes the biggest difference to amortized vs worst case run times.
20:52:49 <orb__> The syntaxen are close enough for ML and Haskell that a human (squishy, wet, imprecise) should have no problem.
20:54:14 <lf94> what's a good zipper explanation
20:54:24 <lf94> every one of these is going off the deep end for no good reason
20:54:32 <orb__> lf94, the paper with the derivatives are good.
20:54:40 <lf94> in concept this seems very, very simple
20:54:51 <lf94> but when code is shown, holy shit what is going on
20:55:16 <orb__> lf94, do you understand the zipper for lists?
20:55:33 <orb__> That's the simplest example to start off on, I think.
20:56:04 <lf94> I haven't seen it
20:56:07 <orb__> https://en.wikibooks.org/wiki/Haskell/Zippers seems also pretty accessible.
20:56:14 <lf94> Every one of these uses a tree example
20:56:17 <johnw> one zipper for lists is ([a], a, [a]), to indicate what preceds the focus, the focus element, and what follows the focus
20:56:37 <johnw> exercise: show that any list can be destructed into such a representation, and then reconstructed from one
20:56:48 <orb__> Where the first element of the tuple is backwards.
20:56:51 <johnw> right
20:57:05 <johnw> that zippered version of a list gives you a lot of flexibility along a particular dimension
20:57:18 <orb__> "Hello world" -> ("lleh", 'o', " world")
20:57:33 <orb__> johnw, not the empty one, actually.
20:57:38 <orb__> That needs a Maybe somewhere.
20:57:39 <johnw> it's important for functional langauges, where we don't mutate data in place; zippers let you accrete a whole bunch of minor changes
20:58:19 <orb__> johnw, it's a shame we can't only do that linearly, or can we?
20:58:33 <johnw> what do you mean by "linearly"?
20:58:50 <orb__> As in linear typing (like clean).
20:58:59 <orb__> Ie we can only accumulate the changes one by one.
20:59:10 <orb__> We can not really merge two histories.
20:59:23 <carter> you can build linearity on top
20:59:23 <johnw> haven't thought about it in those terms
20:59:25 <carter> but it sucks
20:59:29 <carter> well
20:59:30 <carter> ish
20:59:31 <johnw> hi carter!
20:59:33 <carter> orb__: ST monad
20:59:36 <orb__> new = f (g (h original))
20:59:37 <carter> bam
20:59:38 <orb__> but not:
20:59:47 <orb__> new  = merge (f original) (h original)
21:00:09 <orb__> Where f and h could be evaluated in different threads.
21:00:18 <johnw> you could use a monad to enforce the sequencing, like carter suggested
21:00:18 <carter> oh
21:00:22 <carter> yeah
21:00:25 <fread2282> lf94: however, you likely don't need zippers
21:00:26 <johnw> or you an Applicative to avoid the sequencing
21:00:26 <carter> or use speculative evaluation
21:00:28 <carter> i'm off
21:00:31 <carter> night all
21:00:32 <orb__> orb__, yes, you can do something like that.  I mean, it's a shame zippers don't do multi threading.
21:00:33 <johnw> night!
21:00:39 * hackagebot yampa-canvas 0.2 - blank-canvas frontend for yampa  http://hackage.haskell.org/package/yampa-canvas-0.2 (AndyGill)
21:01:03 <lf94> I like that wikibooks explanation already...haha
21:01:28 <johnw> lf94: another way to say it is that zippers transform data representations into an incremental-update friendly form that can be converted back to the canonical form
21:01:31 <fread2282> you can always do without them, but zippers are hyped way more than they are used
21:01:44 <orb__> lf94, http://strictlypositive.org/diff.pdf is the paper that introduced me.
21:02:16 <orb__> fread2282, zippers are neat, but yeah, you can do without using them explicitly.
21:02:29 <johnw> a lot of what you think you'd want zippers for, lens can do better
21:02:36 <johnw> and zippers are in lens, so there you go
21:02:49 <fread2282> johnw: zippers are now in a separate package
21:02:54 <johnw> ah, good to know
21:02:56 <fread2282> *is not
21:02:59 <fread2282> *is now
21:03:42 <orb__> johnw, aren't zippers a special case of lenses?
21:04:00 <orb__> There's also comonads, which have something of both.
21:04:10 <johnw> I think zippers are a bit more about implementation, and lenses are more about interface
21:04:17 <orb__> Makes sense.
21:04:27 <orb__> Zippers are cool to learn about.
21:04:30 <fread2282> orb__: sorta. they can be defined in terms of traversals
21:04:32 <johnw> in terms of type algebra, zippers are just taking the derivative of any regular type
21:05:07 <johnw> whereas lenses generalize the notion of a "a thing with a thing in it"
21:05:09 <fread2282> well, IndexedTraversals
21:05:40 <johnw> yet another way to say it: zippers are about types, lenses are about functions
21:06:44 <orb__> Did anyone have a look at my paste (http://lpaste.net/112285) and could help out with that question about GADTs?
21:06:51 <johnw> I'll look
21:07:01 <lf94> aaaaaaand now my brain is exploding
21:07:19 <johnw> orb__: in what way does it not work?
21:07:21 <lf94> yeah why do I need zippers anyways
21:07:33 <lf94> I just need to tranverse nodes and append children
21:07:36 <johnw> lf94: they are an efficiency gain, that is all
21:07:40 <orb__> johnw, GADT.hs:9:28:    Could not deduce (a ~ a1)
21:07:41 <johnw> lf94: strictly speaking, you never need them
21:07:48 <fread2282> maybe the Show constraint is impossible?
21:07:53 <lf94> why are they mentioned at all?! <_>
21:08:06 <orb__> lf94, because they make some things really easy.
21:08:07 <johnw> orb__: the 'a' type in your constructor is hidden
21:08:14 <orb__> johnw, yes.
21:08:17 <johnw> orb__: you only have visibilty of the 'b' type at your case analysis
21:08:35 <johnw> hmm, wait
21:08:39 <orb__> johnw, so how do I show the innermost value?
21:08:40 <johnw> let me play with this
21:08:43 <lf94> it's like haskell is half 'here is some useful stuff' and half 'here is some stuff that will hopefully get your stupid ass away from haskell!!" lol
21:08:50 <orb__> This is actually a toy version of parser problem I have.
21:09:11 <johnw> ok, one sec
21:09:17 <orb__> Or rather, I want to use GADTs to express parsers for regular languages.
21:10:03 <lpaste> orb revised “Recursion and GADTs”: “No title” at http://lpaste.net/112285
21:10:14 <roboguy_> orb__: the Show constraint doesn't apply to the second argument of FMap
21:10:32 <orb__> roboguy_, yes.  How would I get such a constraint?
21:10:58 <orb__> Or rather, how would I write a function to show the innermost Atom a, if we have Show a.
21:11:56 <johnw> orb__: https://gist.github.com/a8d2a93862044085a7c8
21:11:58 <johnw> that compiles here
21:12:08 <johnw> you need a Show for that inner a
21:12:18 <johnw> the Show on the first constructro shouldn't be necessary
21:12:19 <fread2282> lf94: often the super complex stuff is really cool tho
21:12:44 <johnw> orb__: one thing tripping you up here is a confusion of names
21:13:11 <chirpsalot> Is GHC 7.8 way faster than GHC 7.6, or am I imagining things?
21:13:33 <orb__> johnw, thanks.  Though now I can only make Wrap's that are showable, even if I don't want to use myShow?
21:13:34 <johnw> orb__: in myShow, when you are given a FMap, let's call that type 'f'.  When you when you pattern match, it knows that the second argument is of type '?', a type you will never know the name of
21:13:38 <roboguy_> chirpsalot: ghci 7.8 seems to be a lot faster. I don't know about ghc in general
21:13:47 <roboguy_> (when loading at the start at least)
21:14:04 <lpaste> orb revised “Recursion and GADTs”: “No title” at http://lpaste.net/112285
21:14:10 <johnw> orb__: well, your Wrap type is the only one that will ever know that inner type
21:14:10 <chirpsalot> roboguy_: I'm doing a cabal build of my project and it seems to be at least twice as speedy. It's a small project, but it took forever before.
21:14:16 <orb__> More types seems to help: http://lpaste.net/112285
21:14:18 <johnw> orb__: so whatever functionality you want to have, will need to be a constraint there
21:14:34 <johnw> orb__: let me rewrite this to make it a little less confusing
21:14:40 <systemfault> Hey guys, what is a good documentation about monad transformers in general... and even ReaderT
21:14:57 <orb__> systemfault, have you tried real world haskell?
21:15:20 <systemfault> orb__: I have the book, I find it extremely annoying.
21:15:26 <johnw> well, no it's as clear as its going to be; it's just a bit of a brain puzzler
21:15:33 <orb__> systemfault, ok.
21:15:35 <marchelzo_> systemfault: the bit in RWH about monad transformers helped me
21:15:42 <johnw> it's the change from 'a' to 'b' in the constructor's return type which is throwing you
21:15:53 <systemfault> marchelzo_: Ok, I'll find the motivation to read it then, thanks
21:15:54 <chirpsalot> I found this helpful: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
21:16:06 <johnw> systemfault: I'd start with IdentityT
21:16:25 <systemfault> johnw: Ah ok, I'll look on google
21:16:29 <marchelzo_> systemfault: sorry, I didn't see that you just said you have it and don't like it.
21:16:31 <johnw> systemfault: write it out yourself, play with it, see how it composes a wrapper around whatever base monad you pick
21:17:39 <dfeuer> Cale, I'm struggling to find a nice Haskellian way to express a simple algorithm.
21:18:27 <orb__> dfeuer, shoot.
21:18:46 <Cale> Hi dfeuer
21:18:52 <dfeuer> Or, hey, whoever. The definition of Data.List.isSuffixOf does not look so memory efficient, because the (presumably longer) list gets reversed.
21:19:46 <Cale> There might be a way to adapt something like KMP to that job
21:19:46 <dfeuer> So the technique that comes to mind for seeing if xs is a suffix of ys is first to build a queue of elements of ys with as many elements as xs has,
21:20:14 <dfeuer> then cycle through one element at a time.
21:20:31 <dfeuer> But ... I wonder if there is a prettier way.
21:21:10 <dfeuer> Cale, whAin't got no idea what KMP is, Cale.
21:21:28 <Cale> http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
21:22:25 <dfeuer> Cale, that's very definitely overkill for isSuffixOf. That's for isInfixOf.
21:22:46 <dfeuer> (I guess, maybe)
21:22:55 <Cale> Well, you didn't want to reverse
21:23:29 <Cale> So it's essentially the same problem as isInfixOf in that case, only the end of the string is something you want to match
21:23:34 <dfeuer> I want to limit the extra memory use to a constant times the suffix size.
21:24:01 <dfeuer> But I also want to preserve laziness, which KMP will not do.
21:24:16 <Cale> Will it not?
21:24:18 <orb__> KMP can be made to preserve some laziness, I'd say.
21:24:32 <Cale> I mean, it's already very strict by definition
21:24:56 <orb__> How so?
21:24:58 <Cale> You're looking for a suffix, so you absolutely must force the entire input string
21:25:11 <dfeuer> It's strict in the spine, but [1,2] `isSuffixOf` [undefined, undefined, undefined, 1, 2] needs to return True
21:25:22 <orb__> Cale, actually, only the spine and the last few chars.
21:25:28 <Cale> Yeah, okay
21:26:17 <orb__> partial reversing (ie queing) seems best, then.
21:26:45 <orb__> dfeuer, what kind of input string do you have [Char], or something more sophisticated?
21:26:59 <Cale> orb__: Probably [a] with an Eq constraint
21:27:33 <orb__> zip haystack (drop (length needle) haystack)
21:27:36 <orb__> Or something like that.
21:27:41 <dfeuer> So one question would be whether there's a queue representation particularly well-suited for this pattern, or whether I should just go with something like a (pre-Okasakian) banker's queue.
21:28:02 <orb__> Only that you need the opposite of zip, ie something that preserves the excess, not throws it away.
21:28:05 <dfeuer> Hood-Melville, that's what I'm thinking.
21:28:36 <Cale> Once it gets down to "which sort of queue should I use?" I tend to give up and just pick something at random.
21:28:43 <dfeuer> :P
21:28:44 <orb__> take two pointers, advance them at the same speed, but let one start (length needle) ahead.
21:28:50 <Cale> For the most part in the past, I've used PSQueue
21:28:53 <orb__> No need for queue this way.
21:29:00 <Cale> er, not for plain queues, sorry
21:29:06 <Cale> That's a priority queue
21:29:13 <Cale> (which also happens to be searchable)
21:30:00 <Cale> You could use a Data.Sequence as a queue
21:30:09 <dfeuer> Cale, "which queue should I use" can *easily* have a substantial performance impact, with the fancier queues likely to be twice as slow as simpler ones....
21:30:29 * dfeuer tries to think about whether orb__ is talking good sense.
21:30:35 * dfeuer is a little tired.
21:31:28 <Cale> Yeah, you could just take the last element of that list orb__ is suggesting
21:31:29 * dfeuer thinks orb__ probably is talking somewhat good sense. 
21:32:02 <dfeuer> Maybe even very good sense.
21:32:16 <Cale> er, sorry, I thought there was a tails in there :)
21:32:54 <dfeuer> Yeah, that is surely the right way to do this.
21:32:57 <lpaste> orb pasted “isSuffix” at http://lpaste.net/112290
21:33:32 <dfeuer> Definitely not implemented like that, though.
21:34:09 <orb__> dfeuer, the code in the paste almost works.  (You can fix it up easily, but that's more case analysis.)
21:34:19 <orb__> It only breaks if your hay is shorter than the needle.
21:34:34 <dfeuer> I think it can be done more like your description, without the ++.
21:34:53 <orb__> you can do a drop (length needle) instead of a ++
21:35:11 <dfeuer> I'll work it out.
21:35:37 <dfeuer> drop doesn't quite do the job either, because it throws away info.
21:35:47 <dfeuer> But I got it from here. Thanks, orb__
21:36:24 <prinsen> dmwit: When reading C Chars into Haskell chars, the encoding gets messed up, whats the solution?
21:36:46 <dfeuer> prinsen, uh ... don't do that?
21:36:53 <dfeuer> orb__, I sent you a PM.
21:37:03 <orb__> dfeuer, the two pointer advancement trick sometimes works as a poor man's queue.
21:37:22 <dfeuer> Yeah, neat trick.
21:37:40 <dfeuer> I was trying to find something like that, but I got stuck.
21:38:31 <prinsen> dfeuer: Well I got C code with C String literals, and I read them with storable to Haskell Strings
21:39:20 <dfeuer> prinsen, that sounds very unlikely to work, but I don't know the way to do it right, so I'll let others answer.
21:39:55 <prinsen> dfeuer: as they are of different width it gets messed up
21:40:09 <senseibaka> heyo, i just read https://gist.github.com/quchen/5280339 and wanted to say, well done :p
21:40:46 <dfeuer> prinsen, I think converting from a C string (array of Int8) to a Haskell String (list of Char) is going to require using some functions.
21:42:19 <merijn> dfeuer: Actually, with C strings you don't know whether they're Int8 or Word8 :)
21:42:36 <merijn> CChar is the correct type
21:43:05 <merijn> prinsen: FYI all this stuff already exists
21:43:18 <prinsen> merijn: All what stuff?
21:43:29 <merijn> Foreign.C.Types should have a CString + conversion functions
21:43:48 <merijn> And assorted convenience functions
21:44:15 <merijn> Although if you're trying to do unicode "haha, good luck"
21:44:48 <dfeuer> merijn, doesn't C consider a char signed?
21:45:38 <kadoban> dfeuer: IIRC it's platform dependent, for some reason
21:45:40 <dfeuer> merijn, shouldn't Unicode be "just" a matter of getting it to a ByteString or something and then using some Haskelly function to decode?
21:45:47 <merijn> dfeuer: No
21:45:56 <merijn> dfeuer: The signedness of char is unspecified
21:46:15 <merijn> (yay, C!)
21:46:20 <dfeuer> Yech.
21:46:44 <orb__> isSuffix needle hay =  null (excess hay needle) && needle == excess hay (needle ++ hay)
21:46:45 <orb__> Perhaps?
21:47:09 <dfeuer> Also, integer promotion. It's so much easier to do bitwise fun in Haskell than in C.
21:47:36 * dfeuer goes to do worky things, after which he will work on isSuffix.
21:47:45 <orb__> dfeuer, actually even more drastic:
21:47:47 <orb__> isSuffix needle hay =  null (excess hay needle) && needle == excess hay (fmap undefined needle ++ hay)
21:48:08 <dfeuer> orb__, some Maybeish stuff will probably be in order, and I see no need for ++.
21:48:19 <orb__> dfeuer, nah, Maybe's too reasonable.
21:48:53 <dfeuer> Could use (Bool, [a]) instead, depending on what GHC finds easier to swallow.
21:49:36 <jle`> fmap undefined
21:49:38 <jle`> that's awesome
21:49:45 <orb__> No implicit prelude?
21:49:55 <jle`> > length (fmap undefined [1,2,3])
21:49:57 <lambdabot>  3
21:50:34 <systemfault> Wow, I wouldn't even know how to use IdentityT :(
21:50:38 <orb__> dfeuer, perhaps you can even keep some lazyness around.  Ie if hay runs out before needle (eg infinite needle), give False.
21:50:53 <dfeuer> orb__, of course.
21:50:58 <orb__> jle`, oh my fmap undefined. ;o)
21:50:58 <systemfault> I'm missing something very fundamental about monad transformers.. and/or haskell
21:51:22 <orb__> dfeuer, that requirement rules out my needle ++ haystack trick.
21:51:29 <jle`> bottoms of function types really elude most of my attempts at reasoning
21:51:37 <jle`> moreso than bottoms of non-function types
21:51:53 <nshepperd> > let suffixof ns hs = (let go xs [] = xs == ns; go (x:xs) (y:ys) = go xs ys in go hs (drop (length ns) hs)) in "abc" `suffixof` ([undefined, undefined] ++ "abc")
21:51:54 <jle`> i guess i just need to step back to the basics.
21:51:55 <lambdabot>  True
21:52:01 <systemfault> Anyone has an example of IdentityT usage?
21:52:01 <dfeuer> orb__, you just have to pay attention to whether you ran out of haystack before you found the initial value of the advance pointer.
21:52:03 <orb__> jle`, the undefined there is mostly to say, "this should never be evaluated, ever".
21:52:09 <orb__> dfeuer, yes.
21:52:17 <jle`> systemfault: IdentityT m a is just a wrapper over an (m a)
21:52:32 <jle`> orb__: yes, but.  evaluation of functions is what i have trouble reasoning with
21:52:37 <jle`> moreso than evaluation of non-functions
21:52:49 <dfeuer> orb__, but I don't like your ++ trick anyway, because ++ allocates stuff, and that should be done only when necessary.
21:52:59 <jle`> i guess...i can use the same reasoning tools for both
21:53:03 <orb__> dfeuer, just trying to be clever.
21:53:09 <jle`> but perhaps my intuition on the former is not quite there yet
21:53:16 <orb__> I used drop first, but that had bugs, too.
21:53:23 <dfeuer> orb__, cleverness is a good thing, but don't let it get in the way of good code!
21:53:37 <jle`> @unmtl IdentityT m
21:53:37 <lambdabot> IdentityT m
21:53:39 <jle`> @unmtl IdentityT m  a
21:53:40 <lambdabot> IdentityT m a
21:53:42 <jle`> aw.
21:53:48 <orb__> dfeuer, actually, you should be able to use something like my excess function for the drop, too.
21:53:49 <jle`> it would be (m a) if IdentityT was in mtl
21:54:01 <dfeuer> orb__, I must do some worky things!
21:54:17 <jle`> some fun exercises might be implementing the Monad instance (return and (>>=)), and the MonadTrans instance (lift)
21:54:18 <Axman6> srhb: hey, did that lens stuff work out?
21:54:40 <jle`> IdentityT a -> (a -> IdentityT b) -> IdentityT b
21:54:43 <jle`> um, there should be m's there
21:54:45 <orb__> dfeuer, ok.  Oh, excess just needs a better type: excess :: [a] -> [b] -> Maybe [b]
21:54:52 <jle`> m a -> IdentityT m a
21:54:57 <orb__> to show difference between running out of bs and just about making it.
21:55:18 <dfeuer> Yeah, I think that's right, orb__
21:56:12 <systemfault> jle`: Why can't I find a very stupid example of usage on google :/ Is it as obvious as 2+2, am I missing something?
21:56:53 <jle`> i...can't really imagine situations where it would be useful
21:57:11 <jle`> maybe in cases where the function is expecting a MonadTrans, and you don't really have one in particular in mind
21:57:14 <systemfault> I want to understand monad transformers.. and someone suggested I should start with IdentityT
21:57:18 <dfeuer> orb__, a short exercise for you: write tails using unfoldr. A longer exercise: try to find an even more pleasant way (not sure how that one goes)
21:57:50 <jle`> systemfault: i like that paper, "monad transformers step by step"
21:58:08 <systemfault> Found it! http://www.grabmueller.de/martin/www/pub/Transformers.pdf
21:58:09 <jle`> systemfault: well.  one way to understand IdentityT would be to write the Monad instance and the MonadTrans instances
21:58:22 <jle`> and you'll see that it's all a little silly
21:58:52 <jle`> return :: Monad m => a -> IdentityT m a
21:59:03 <jle`> (>>=) :: Monad m => IdentityT m a -> (a -> IdentityT m b) -> IdentityT m b
21:59:12 <jle`> lift :: m a -> IdentityT m a
21:59:19 <jle`> interestingly enough, the last one doesn't require a Monad constraint
21:59:36 <TallerGhostWalt> has anyone tried out ivory?
22:00:02 <jle`> the Monad constraint is there anyways due to the typeclass though.
22:00:06 <jle`> but oh well
22:01:17 <prinsen> merijn: Now I ended up with overlapping instances, Storable a => Storable [a] and Storable String, whats the least intrusive way to solve this?
22:03:19 <merijn> That way lies pain and suffering
22:03:38 <merijn> If you can't use CString, then I'd see if there's a Storable instance for ByteString
22:03:48 <merijn> If not, eh, bummer?
22:04:35 <lpaste> orb revised “isSuffix”: “No title” at http://lpaste.net/112290
22:06:05 <johnw> the storable instance for ByteString is easy: use CString
22:06:30 <lpaste> orb revised “isSuffix”: “No title” at http://lpaste.net/112290
22:06:35 <johnw> there are methods for scoping a ByteString as a CString for the duration of an FFI call, etc.
22:07:41 <johnw> orb: what's the question?
22:08:18 <lpaste> orb revised “isSuffix”: “No title” at http://lpaste.net/112290
22:08:44 <johnw> TallerGhostWalt: I've looked at it, but haven't used it in anger yet
22:08:50 <johnw> TallerGhostWalt: we are using it at my work place though
22:09:08 <TallerGhostWalt> johnw: oh really ? embedded?
22:10:12 <dmwit> prinsen: Use one of the many encoding libraries available.
22:10:13 <johnw> ish, I think
22:10:17 <johnw> not my immediate group
22:10:37 <dmwit> (And then skip the custom Storable String instance entirely.)
22:11:01 <TallerGhostWalt> johnw: I used atom a lot
22:11:22 <TallerGhostWalt> johnw: seems like another step forward in that line
22:12:02 <johnw> i'm actually extending c2hsc to generate Ivory type signatures
22:12:23 <Axman6> :o
22:12:26 <TallerGhostWalt> oh wow!
22:12:28 <johnw> a task I will be dedicating next week to
22:12:31 <johnw> (this is for work)
22:12:46 <TallerGhostWalt> I am watching/listening to the presentation
22:12:47 <johnw> I have the proof of concept working
22:12:55 <TallerGhostWalt> Tower seems really cool too!
22:13:05 <johnw> yeah, it does
22:15:33 <Axman6> huh, I wonder if anyone here is using Ivory. I can't remember if there's anyone doing work on SMACCMPilot
22:22:20 <Spencer_> Hi, is there a function sort of like ZipWith that would give something like MyFunc (+) [1, 2, 3] [1, 2] = [2, 4, 3]?
22:24:38 <eazar001> > (+) <$> [1,2,3] <*> [1,2]
22:24:40 <lambdabot>  [2,3,3,4,4,5]
22:24:42 <jle`> Spencer_: what would the type be?
22:24:55 <jle`> it would only work on (a -> a) functions, right?
22:25:32 <Dashkal> :t \as bs -> zipWith (+) as (bs ++ repeat 0)
22:25:33 <lambdabot> Num c => [c] -> [c] -> [c]
22:25:38 <Spencer_> yes I think so jle`, still learning
22:26:23 <jle`> Dashkal: that works, but you have to know which one is longer
22:26:28 <jle`> or shorter
22:26:29 <Dashkal> indeed
22:26:37 <Dashkal> Pondering a bit more
22:26:39 <TallerGhostWalt> Okay that video on ivory made me realize, I need to start trying to go to icfp
22:26:41 <TallerGhostWalt> amazing
22:26:50 <johnw> yeah, ICFP is totally worth it
22:27:22 <TallerGhostWalt> The questions at the end of the vid were just wow!
22:28:01 <Axman6> TallerGhostWalt: got a link?
22:28:11 <TallerGhostWalt> Axman6: https://www.youtube.com/watch?v=wC2tmo7l5Mc
22:28:18 <TallerGhostWalt> from ivory home page
22:28:32 <Axman6> thanks =)
22:28:35 <Dashkal> Mrh, I can't come up with anything aside from a completely new recursive function.  But my brain isn't 100% right now.
22:29:04 <johnw> Dashkal: http://stackoverflow.com/questions/21349408/zip-with-default-value-instead-of-dropping-values
22:29:41 <Dashkal> I was looking to avoid the len call
22:30:45 <jle`> shame that the top answer has a length call
22:30:59 <Dashkal> Top answer is pretty much wrong.  Will break for an infinite list.
22:31:09 <orb__> You can muck around with (fmap Just bs ++ repeat Nothing)
22:31:15 <orb__> and (fmap Just as ++ repeat Nothing)
22:31:40 <orb__> and then do: ((+) <$> a <*> b <|> a <|> b)
22:31:57 <orb__> fmap fromJust . takeWhile isJust
22:32:43 <Spencer_> Oh god orb__ that might work but I just finished reading LYAH so that will take some time for me to get my head around :)
22:32:44 <orb__> fmap fromJust . takeWhile isJust $ zipWith  (\a b -> (+) <$> a <*> b <|> a <|> b) (fmap Just as ++ repeat Nothing) (fmap Just bs ++ repeat Nothing)
22:33:02 <orb__> But that's actually not clearer than just writing your own recursive combinator. ;o)
22:33:26 <Axman6> agreed
22:33:43 <Spencer_> Yeah I was thinking I could write my own function for that I think, but it kind of seems like a standard function? Or maybe I'm wrong on that
22:34:00 <orb__> Spencer_, put it into a module and load it up to hackage.
22:34:29 <orb__> zipWith' :: (a->c) -> (b -> c) -> (a -> b -> c) -> [a] -> [b] -> [c]
22:34:41 <orb__> for you:
22:34:46 <orb__> zipWith' id id (+) as bs
22:35:42 <Dashkal> This is terrifying...
22:35:43 <Dashkal> :t \f defa defb as bs -> fix foo where foo rec (a : as) (b : bs) = (a `f` b) : rec as bs; foo (a : as) [] = (a `f` defb) : rec as []; foo [] (b : bs) = (defa `f` b) : rec [] bs; foo [] [] = []
22:35:44 <lambdabot> parse error on input ‘where’
22:36:04 <Spencer_> Oh thanks orb__, I will try that out
22:36:59 <lpaste> orb pasted “zipWith'” at http://lpaste.net/112295
22:37:53 <orb__> Dashkal, I wonder whether the default a, default b, or my version with two extra functions is more useful in practice.
22:38:45 <Spencer_> Nice orb__ :)
22:39:36 <Dashkal> orb__: Good question.  I lean towards yours since it lets you handle mismatches differently than the f would have, allowing things where there's no sane 'zero'
22:41:08 <lpaste> orb revised “zipWith'”: “No title” at http://lpaste.net/112295
22:41:40 <johnw> Spencer_: see also http://hackage.haskell.org/package/these-0.4.2/docs/Data-Align.html
22:42:16 <johnw> for example rpadZipWith
22:43:39 <Dashkal> padZipWith looks handy
22:43:53 <Spencer_> Thanks johnw that looks helpful as well
22:43:56 <Dashkal> Little trickt to use with things like (+) though
22:44:02 <johnw> Data.Align generalizes this notion of mismatched structures
22:44:22 <johnw> i esspecially like to use it when merging maps
22:45:46 <orb__> Neat.
22:47:10 <orb__> padZipWith does the same thing as mine, just folds all three callbacks into one.
22:51:20 <crobbins> @pl (\x _ -> x + 1)
22:51:20 <lambdabot> const . (1 +)
22:51:27 <crobbins> nice!
23:13:55 <trap_exit> when running forkIO, is there a way to say: "forkIO ... but if you block on something for more than 5 seconds, then die" ?
23:14:10 <rkazak> setup an alarm?
23:14:37 <trap_exit> rkazak: this sounds like what I need
23:14:42 <trap_exit> can you point me at a code sample?
23:14:47 <trap_exit> I'm not familiar with concurrent primitives in haskell
23:16:15 <rkazak> http://chimera.labs.oreilly.com/books/1230000000929/pr01.html
23:16:16 <simpson> trap_exit: You might want async
23:16:19 <simpson> http://hackage.haskell.org/package/async-2.0.1.6/docs/Control-Concurrent-Async.html
23:16:47 <trap_exit> rkazak: I have that book!
23:16:49 <trap_exit> it's next on my reading list
23:19:33 <rkazak> maybe here you can see an example http://hackage.haskell.org/package/unix-2.3.0.0/docs/System-Posix-Signals.html
23:25:45 * hackagebot Hungarian-Munkres 0.1.5 - A Linear Sum Assignment Problem (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.5 (kaizhang)
23:40:16 <Haskellfant> trap_exit: you should be able to use timeout on wait
23:40:34 <trap_exit> it's not like I'm using wiat
23:40:42 <trap_exit> it's more liek I'm doing a MVarget
23:40:44 <trap_exit> and there's nothing
23:40:46 <trap_exit> so it just hangs
23:43:12 <Haskellfant> trap_exit: are you interested in the total running time of the io action you run using forkIO or only in the blocking part?
23:43:41 <trap_exit> if a thread (created via forkIO) does a mvar_get ... and it hangs there for more than 5 seconds
23:43:50 <trap_exit> then I'd like the thread to die or something
23:44:21 <Haskellfant> I think you need to catch this inside the thread
23:44:34 <Haskellfant> I don't see how you would see from the outside that it's blocking on mvar_get
23:44:45 <merijn> trap_exit: spawn an extra thread and throw an async exception, although that's really crappy to implement
23:44:52 <merijn> trap_exit: Probably async already has this
23:45:03 <merijn> So i'd recommend using async
23:45:18 <trap_exit> i would ahve expected there to be a badass monad
23:45:23 <Haskellfant> what's wrong with using timeout for this?
23:45:28 <trap_exit> which is like "select first of (1) mvar_get and (2) timeout 5 seconds"
23:45:38 <Haskellfant> that's race
23:45:44 <Haskellfant> @hoogle race
23:45:45 <lambdabot> Debug.Trace module Debug.Trace
23:45:46 <lambdabot> Debug.Trace putTraceMsg :: String -> IO ()
23:45:46 <lambdabot> Debug.Trace trace :: String -> a -> a
23:45:48 <trap_exit> please explain
23:45:54 <Haskellfant> trap_exit: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Timeout.html#v:timeout
23:46:03 <trap_exit> waits is 'race' bad as in race condition, or is race a haskell concept?
23:46:22 <Haskellfant> this runs the io action in a seperate thread and kills it after a timeout
23:46:29 <trap_exit> hmm
23:46:31 <trap_exit> I like this, sorta
23:46:33 <merijn> trap_exit: Well, what you want *is* a race condition
23:46:47 <merijn> trap_exit: You wanna race to see which of two operations finishes first
23:46:57 <Haskellfant> trap_exit: there's race in async http://hackage.haskell.org/package/async-2.0.1.6/docs/Control-Concurrent-Async.html
23:46:59 <trap_exit> hmm
23:47:00 <trap_exit> true
23:47:15 <trap_exit> oh man, I didn't make this connection
23:47:17 <Haskellfant> if one of your actions is just some threadDelay you could get the same behaviour as timeout
23:47:18 <trap_exit> that I want a race condition
23:47:19 <trap_exit> teehee
23:48:39 <Haskellfant> but you need to use this on the specific takeMVar and then react on getting Nothing back from timeout to kill the thread
23:50:02 <Haskellfant> or you use race and make one of the io actions wait for a certain amount of time and then kill your thread
23:50:19 <Haskellfant> probably easier
23:52:35 <prinsen> A FFI function returning HsStablePtr (created using newStablePtr) returns 0x4f, which causes segfault
23:52:57 <Haskellfant> I wonder why I didn't use stackage before, it makes my life way easier
23:53:12 <merijn> prinsen: Eh, why are you checking what the stableptr points too?
23:53:23 <merijn> prinsen: You can't access StablePtr's...
23:53:44 <prinsen> merijn: " Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value."
23:53:53 <merijn> prinsen: Right
23:54:06 <prinsen> merijn: Maybe* output = yqlsmhi_pmpPipe_ffi(&settings, &input); printf("%p\n", (void*)output);
23:54:08 <merijn> prinsen: "opaque", i.e. non-transparent, untouchable
23:54:21 <merijn> prinsen: There's only one thing you can do with a StablePtr
23:54:29 <merijn> Pass it back to haskell to convert it to a haskell value
23:54:38 <merijn> C cannot do anything with StablePtr
23:54:57 <merijn> And, as you found out, trying to do it anyway will segfault. If you're lucky
23:55:06 <merijn> If you're unlucky it'll silently corrupt your memory
23:55:24 <prinsen> merijn: Ok :) good to know
23:55:41 <prinsen> merijn: How do I return actual data?
23:56:14 <merijn> Return a Ptr
23:57:26 <Haskellfant> are there any plans to allow specifying a custom repo in the cabal file, maybe even per dependency to make decentralization easier?
23:58:48 <Haskellfant> e.g. you have some patched versions of some packages you want to use but they're not on hackage. currently it seems to be hard to get a cabal install --only-dependencies && cabal build process working this way
