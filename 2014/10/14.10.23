00:04:20 * hackagebot scotty-binding-play 1.2 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.2 (YusukeNomura)
00:04:20 * hackagebot scotty-binding-play 1.2.1 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.2.1 (YusukeNomura)
00:22:47 <xpika> is it possible to partially define a type. eg a = [2] a :: [_] ?
00:28:59 <joelteon> no
00:29:02 <joelteon> (not yet anyway)
00:29:39 <DanielDiaz> xpika: there have been some efforts: http://www.haskell.org/pipermail/ghc-devs/2014-March/004239.html
00:29:54 <DanielDiaz> but I think it never got fully implemented, not sure
00:42:39 <comerijn> DanielDiaz: It's work in progress, afaik
00:42:45 <comerijn> I think a prototype is planned for 7.10
00:43:26 <DanielDiaz> comerijn: thanks. That confirms what I thought. :)
00:47:39 <xpika> got profiling working after installing the profiling libraries, I had to make a sandbox
00:47:58 <xpika> otherwise i would have had to reinstall too many packages for cabal to cope with
01:09:00 <MindIsAVortex> Does anyone have a link to some good documentation on gloss lib besides the hackage docs?
01:15:21 <xpika> what is a list like data structure that is efficient on filter ?
01:23:07 <shiona_> has anyone used ghc-vis?
01:23:20 <shiona_> I'm having some problems with it
01:43:05 <heudebeu> Could someone recommend a great book for learning Haskell with exercises?
01:43:23 <saep`> @where rwh
01:43:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:44:00 <CodeWeaverX> Learn You A Haskell is an easy read.
01:44:10 <shiona_> Some people have also put exercises for LYAH up on github
01:44:11 <CodeWeaverX> Online version too.
01:44:26 <rai> exercises for LYAH?
01:44:35 <heudebeu> Oh that is interesing, the exercises for LYAH
01:54:27 * hackagebot postgresql-simple-sop 0.1.0.0 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.0 (glutamate)
01:55:14 <solatis> is it possible to use Control.Exception(bracket) with monads different than the IO monad?
01:55:55 <solatis> or rather, I have a function that returns a monad ZMQ z (), which is of type MonadIO, but `bracket` tells me it expects output of type IO
01:56:22 <solatis> so might it be possible i'm running `bracket` at the wrong level or something?
01:56:38 <solatis> (as in, if i would have designed my code better, this would not be a problem)
01:57:52 <Adeon> which ZMQ package is this
01:58:42 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/System-ZMQ4-Monadic.html
01:58:48 <solatis> instance MonadIO
01:58:49 <Adeon> the one I looked into implements MonadMask from exceptions package which would allow you to use its bracket
01:59:06 <Adeon> ah yes
01:59:07 <solatis> ah!
01:59:11 <shiona_> this is weird. ghci :print does not show the forced values
01:59:12 <solatis> i did not even know
01:59:39 <Adeon> in general I don't think you can use bracket and friends without support from the one who wrote the original monad
01:59:49 <Adeon> in this case they support this by implementing those specific instances
01:59:55 <solatis> i understand
02:00:27 <solatis> this is about a HTTP connection manager i need to acquire/release, and i want to do that inside my runZmq $ function
02:00:43 <solatis> so i can use ZMQ's bracket for that
02:00:46 <solatis> awesome
02:03:57 <shiona_> ah, I had not given a definite type to the thing I was debugging
02:15:41 <Aleksejs> Hi, is there something like any, but for IO Int -> [IO Int] ?
02:16:22 <blueonyx> :t liftM any
02:16:24 <lambdabot> Monad m => m (a -> Bool) -> m ([a] -> Bool)
02:18:43 <blueonyx> Aleksejs: explain a little more please?
02:19:59 <Aleksejs> blueonyx: I have [IO Int] and I want to check if IO Int is in this list
02:20:44 <blueonyx> :t liftM (any (==))
02:20:45 <lambdabot>     Couldn't match type ‘a -> Bool’ with ‘Bool’
02:20:45 <lambdabot>     Expected type: a -> Bool
02:20:45 <lambdabot>       Actual type: a -> a -> Bool
02:21:04 <blueonyx> ah i see
02:22:04 <kadoban> Aleksejs: I think you mean 'elem', not 'any' ?
02:22:24 <blueonyx> is there an Eq istance for IO Int?
02:23:04 <trap_exit> err
02:23:04 <Dodek> Aleksejs: use sequence to obtain IO [Int] from [IO Int], bind the Int you're looking for, and then lift elem to IO using liftM or fmap
02:23:09 <trap_exit> why do you believe there's a Eq for any IO ?
02:23:34 <trap_exit> wtf
02:23:34 <trap_exit> that can't work
02:23:44 <trap_exit> you'd have (==) :: IO Int -> IO Int -> IO Bool
02:23:52 <trap_exit> whereas you want (==) :: IO Int -> IO Int -> Bool
02:24:02 <blueonyx> aye
02:24:07 <trap_exit> wtf does it mean for a :: IO Int to be Eq to b :: IO Int ?
02:24:19 <blueonyx> trap_exit: that a == b
02:24:30 * hackagebot testpack 2.1.2.2 - Test Utililty Pack for HUnit and QuickCheck (unmaintained)  http://hackage.haskell.org/package/testpack-2.1.2.2 (PeterSimons)
02:24:30 <trap_exit> yeah, wtf does == mean for (IO Int) ?
02:25:54 <hyPiRion_> blueonyx: You cannot compare two IO operations. You can compare the values inside the IO monads though
02:26:20 <blueonyx> yep
02:26:23 <blueonyx> i got it
02:26:24 <hyPiRion_> :t liftM2 (==)
02:26:26 <lambdabot> (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
02:26:37 <trap_exit> someone say "trap_exit++" for my brilliance
02:26:55 <blueonyx> i know, thank you, why do i always sound like a total newbie :/
02:27:00 <blueonyx> trap_exit--
02:44:00 <QF-MichaelK> Any recommendations on beginner/introductory category theory materials?
02:44:50 <augur_> QF-MichaelK: awodey's lectures + books, the catsters videos
02:45:09 <augur_> actually i think maybe awodey's lectures, then catsters, then awodey's book
02:45:21 <shiona_> is there a way to limit the nodes ghc-vis shows?
02:45:24 <augur_> QF-MichaelK:
02:45:27 <augur_> @where oplss
02:45:27 <lambdabot> you can find original OPLSS videos here (https://www.cs.uoregon.edu/research/summerschool/summerYEAR/curriculum.html) by replacing YEAR with a two-digit year (starting with 05). you can also find many videos on youtube. years 2010 to 2014 are also stored in @where (eg @where oplss2012).
02:45:40 <shiona_> is there a way to limit the nodes ghc-vis shows?
02:45:46 <augur_> QF-MichaelK: awodey's videos are in oplss2012
02:45:57 <augur_> @where catsters
02:45:57 <lambdabot> http://www.youtube.com/user/TheCatsters
02:47:06 <QF-MichaelK> augur_: first link is broken, thank you
02:47:14 <augur_> there's a catsters guide http://www.simonwillerton.staff.shef.ac.uk/TheCatsters/
02:47:29 <augur_> QF-MichaelK: first link isnt broken, just read a little more of the text :)
02:48:43 <Hijiri> I just realized now that the IcedTea plugin is a drink like Java
02:49:23 <QF-MichaelK> augur_: Ah, snap, sorry, tried 4 digit year, not 2.
02:50:45 <QF-MichaelK> @where oplss2012
02:50:45 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
02:50:47 <tdammers> the java community never gets tired of coffee jokes
02:51:18 <kadoban> I hope that was meant to be a lame caffeine pun
02:52:09 <QF-MichaelK> augur_: How about stuff on arithmetic hierarchy relating to decidability?
02:52:21 <augur_> no idea :(
02:52:48 <QF-MichaelK> Ah, no problem, was worth a shot ^.^ kind of unrelated to the topic anyway.
03:04:50 <def-> shiona_: you can select the nodes and click on the symbol right of them to disable showing them (only in the graph view)
03:06:31 <shiona_> def-: can't seem to find anything that would hide a thing
03:07:10 <def-> shiona_: are you in the graph view? then hover over the node
03:07:31 <shiona_> it's red then and an arrow and a dashed rectangle will appear on the right
03:07:48 <def-> shiona_: yes, click the dashed rectangle and the node disappears
03:07:56 <shiona_> doesn't for me
03:08:22 <def-> shiona_: do you have an example where this happens?
03:08:38 <def-> shiona_: also, try :setDepth 10 to limit the depth to 10 nodes
03:10:00 <shiona_> def-: ah, it might be that I was running it as a library
03:10:43 <def-> shiona_: ah, that may explain why it wasn't reacting. try compiling with -threaded
03:11:24 <shiona_> nothing
03:11:55 <shiona_> firing up ghci and defining things and showing them, the hiding works
03:12:41 <def-> shiona_: this works for me: http://felsin9.de/nnis/ghc-vis/#using_ghc_vis_as_a_library
03:12:42 <shiona_> ah. If I go "backwards in time" with comma, then I cannot hide things
03:14:03 <def-> shiona_: right, you can only hide at the most recent time point, hm
03:14:58 <shiona_> I guess it's fine. I wanted to hide some BCO's, since those were cluttering up the place, but compiling the code got rid of them
03:29:37 * hackagebot mime-mail 0.4.6 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.6 (MichaelSnoyman)
03:29:39 * hackagebot mime-mail-ses 0.3.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.3.1 (MichaelSnoyman)
03:34:37 * hackagebot ghc-vis 0.7.2.6 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.6 (DennisFelsing)
03:46:45 <ThreeOfEight> I'm using QuickCheck with expectFailure and I get this error: message threw an exception: No match in record selector usedSize
03:46:56 <ThreeOfEight> does anybody know where this comes from?
03:47:38 <ThreeOfEight> ich glaube, das kommt von Tasty
03:47:44 <ThreeOfEight> sorry
03:47:52 <ThreeOfEight> I am using Tasty and I think it comes from Tasty
04:03:46 <Aleksejs> How would you generate a list of N unique random numbers from A to B (B-A > N of course)?
04:04:40 * hackagebot creatur 5.7.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.7.1 (AmyDeBuitleir)
04:07:13 <PragCypher> cool was just thinking about an artificial life project
04:09:37 <QF-MichaelK> No mention of spikes from what I see.
04:09:41 * hackagebot esqueleto 2.1.1 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.1 (FelipeLessa)
04:31:17 <piskrist> how do I use netstring-enumerators decode?
04:31:39 <piskrist> I have a String with netstring and want to get something from it
04:33:28 <Axman6> do you have a link so the docs? I've never heard of the package
04:33:42 <piskrist> yes, it's using Data.Enumerator but I have no idea how to use it
04:34:44 <Axman6> I mean can you please share the link to the docs for the library you're struggling with
04:35:26 <piskrist> ttps://hackage.haskell.org/package/netstring-enumerator-0.1.1/docs/Codec-Netstring-Enumerator.html
04:35:52 <piskrist> oh. it's like decode x y -> do ... ?
04:36:23 <piskrist> well, then I still don't know what to witht the Enumeratee
04:37:26 <Axman6> it doesn't take any arguments, it is an enumerator which ByteStrings and decodes them into ByteStrings (which I assume contain the string the input netstring represents)
04:37:44 <AshyIsMe> cabal install snap --force-reinstalls
04:37:48 <Axman6> you're pretty new to Haskell right? What're you doing playing with enumerators?
04:37:49 * AshyIsMe crosses his fingers
04:38:14 <piskrist> Axman6: yeah, I just wanted to parse a netstring but I guess I'll leave it for some other time
04:39:27 <Axman6> yeah you'll need to learn a lot to be able to use that
04:39:48 <Axman6> it's a shame it doesn't expose a more useful interface
04:44:25 <clrnd> hi
04:46:03 <Axman6> 'lo
05:29:50 * hackagebot yi-fuzzy-open 0.1.0 - Fuzzy open plugin for Yi.  http://hackage.haskell.org/package/yi-fuzzy-open-0.1.0 (DmitryIvanov)
05:31:26 <kstt> Hi! Template Haskell seems to load all packages in the deps before outputing splices. On MS Windows, this causes a bug when loading GTK packages, making GHC crash. I can't afford to fix it at the moment. As a workaround, is there an option to limit the packages that TH loads ? I know for sure that GTK is not required to splice my TH fragments. Thank you
05:42:03 <spaceloop> why does quickcheck require a Bounded instance for a Random instance to be arbitrary?  arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a
05:44:52 <EvanR_> spaceloop: maybe getting an arbitrary unbounded element is more complicated
05:48:47 <spaceloop> EvanR_: But isn't that what the Random class already provides?
05:49:53 <EvanR_> spaceloop: since Int is bounded, yeah i guess
05:50:41 <spaceloop> EvanR_: But then, if you already have an instance of Random, why would quickcheck also need Bounded?
05:52:35 <t4nk140> hi
05:52:53 <blueonyx> random docs: For Integer, the range is (arbitrarily) the range of Int.
05:52:58 <blueonyx> spaceloop: ^
05:53:25 <EvanR_> spaceloop: checking
05:53:38 <EvanR_> because arbitraryBoundedRandom = choose (minBound,maxBound)
05:54:10 <spaceloop> blueonyx: sure, but that is a detail of the Integer instance of Random
05:54:23 <EvanR_> so i guess its not going to lure you into thinking your Integer stuff is working
05:54:34 <EvanR_> because it has an arbitrary undenoted bound
05:55:35 <spaceloop> EvanR_: So you think the only reason for this typeclass is the Integer instance not being actually bounded in Random?
05:55:55 <octophore> if something can be done in polynomial time, is that equivalent to saying its big-O notation is a polynomial in "n"? like O(n^2), O(n^3+n^2) etc
05:55:56 <EvanR_> its explicitly checking stuff between minBound and maxBound, just like all the other helper of this kind
05:56:08 <EvanR_> it cant just do that for Integer, or anything else
05:56:14 <EvanR_> unless it has Bounded
05:56:25 <spaceloop> yes I know, all those functions require it. But why?
05:56:41 <EvanR_> they are called stuff like arbitraryBoundedFoo
05:56:42 <spaceloop> if you have an instance of Random, you can use random to produce an arbitrary value
05:56:53 <EvanR_> Integer isnt bounded
05:57:11 <EvanR_> so wouldnt make sense to just pick one in a ad hoc range
05:57:24 <EvanR_> same with [True]
05:57:28 <EvanR_> er [Bool]
05:58:10 <EvanR_> im glad the semantics for these quickcheck helpers are more clear than system.random
06:02:23 <spaceloop> ok, thanks, makes sense
06:02:59 <EvanR_> spaceloop: also, i dont think the random instance for Integer is actually restricted to Int in general, just for random. randomR lets you pick any two end points
06:03:15 <EvanR_> so its not really "bounded by default"
06:04:54 <kadoban> octophore: Should be, yeah.
06:05:23 <kadoban> octophore: Although depending on context I could imagine the definitions being very slightly orthogonal, but colloqually that's what I'd take it to mean.
06:05:49 <octophore> ok thanks
06:28:38 <boxmein> where did `catch` go?
06:28:48 <boxmein> it's literally gone from my Prelude
06:29:13 <bergmark> it is, it's in Control.Exception
06:29:40 <boxmein> Hoogle told me it's in Prelude :s
06:30:53 <bergmark> boxmein: it was removed with ghc 7.6 iirc
06:51:17 <qnikst> (very strange question) is it possible to ask GC to not move all the objects that are existing at that moment until the end of the program, but work with new one?
06:52:42 <Cale> wat
06:53:02 <Cale> qnikst: You mean "please leak memory"?
06:54:13 <ClaudiusMaximus> qnikst: maybe you want StablePtr ?
06:55:54 <sccrstud92__> jle': hey
06:56:27 <Cale> Most Haskell programs have a very high rate of allocation, but many short-lived objects that are easily collected.
06:57:04 <Cale> If you were to suddenly stop collecting, it would typically be disastrous.
07:02:55 <qnikst> Cale: yes
07:04:00 <qnikst> ClaudiusMaximus: not sure but it may help.
07:04:07 <qnikst> to avoid X-Y problem:
07:04:30 <qnikst> I have a huge tree, and I want to fork of a process that should have access to that tree
07:04:45 <qnikst> if I do fork then everything ok up to the first GC
07:05:35 <geekosaur> you are using a subprocess instead of a thread, and expecting stuff to be shared?
07:06:11 <qnikst> geekosaur: why not?
07:06:36 <Cale> What's the reason for the forking?
07:07:08 <tdammers> qnikst: because processes don't work that way?
07:07:08 <Cale> I don't think I've ever used posix fork in a Haskell program.
07:07:09 <geekosaur> fork() is copy on write for memory, and generally wrong if you are holding any other resources (e.g. a database connection)
07:07:13 <qnikst> Cale: such process can be killed by OOM, etc. and their death should not harm other proceses
07:07:45 <qnikst> geekosaur: I'm not tasking about resources like connection etc.
07:07:47 <geekosaur> in any case, processes do not work the way you think. I suggest you study the POSIX process model before trying to use it for anything other than an immediate exec()
07:07:56 <geekosaur> that was an example
07:08:13 <geekosaur> it's specifically the memory behavior that you are assuming does something different from what it actually does
07:08:21 <geekosaur> and this is not haskell's fault, it's the POSIX process model
07:09:09 <geekosaur> also, if this is Windows, the situation is even worse because forkProcess must be emulated (Windows doesn't have a native POSIX fork()) and you can scramble memory quite badly by misusing it
07:09:09 <qnikst> geekosaur: I don't know what do you think I'm assuming :) but atm you have not said anything that I didn't know
07:09:49 <qnikst> really I'm just checking that there is no ways to go this way
07:09:59 <geekosaur> your initial question contains the assumption
07:10:25 <qnikst> geekosaur: it contains the assumption of a copy-on-write
07:10:31 <qnikst> model
07:10:32 <geekosaur> the subprocesses have gone their own ways (except on Windows where they're doing evil things)
07:10:58 <geekosaur> then why do you think it needs to somehow sequester the existing memory model and start a new one?
07:11:05 <qnikst> and I was wondering if there is a way to not write to some pages
07:12:01 <qnikst> but it seems that it was a bad question as chunks are less then a page, are they?
07:12:09 <geekosaur> usualy, yes
07:12:37 <qnikst> ok, then my question was bad because even if I'll lock all chunks with data
07:12:37 <geekosaur> (with some complications like there are memory models on i386 which use 1MB pages instead of the usual 4K)
07:12:45 <qnikst> a new chunk may write to a page
07:13:33 <qnikst> really I just want to avoid serialization of that tree and sharing it using shmem or mmap
07:14:00 <qnikst> geekosaur: thanks
07:14:00 <geekosaur> that's not going to work
07:14:13 <qnikst> serialization and sharing?
07:14:29 <qnikst> or relying on COW when forking?
07:14:34 <geekosaur> and the haskell runtime would need massive overhauling to do anything sensible with sharing Haskell memory allocations via mmap
07:15:40 <qnikst> I mean having Tree a you can serialize it to a bytestring and work with bytestring only, without deserializing it
07:15:55 <qnikst> that bytestring can be safely shared
07:16:20 <geekosaur> consider that Haskell evaluation requires close control over sharing. as soon as that sharing is happening in different processes, the only wya to do it at all right is to use cross-process locking of memory for any allocation or memory update visible to more than one process. and all the compiler's assumptions about what is shareable go out the window
07:16:32 <geekosaur> you have to generate the worst performance but safest code always
07:17:04 <qnikst> geekosaur: yes, I understand it
07:18:26 <geekosaur> so it is much, much more than just locking pages
07:18:35 <qnikst> yes
07:18:39 <RchrdB> qnikst: you're basically stuffed trying to use fork() in a Haskell program. Is there are reason why it needs to be a whole new process and not just another Haskell thread created with forkIO? Given that GHC's threads are (almost) preemptible and take advantage of SMP just fine.
07:19:35 <qnikst> RchrdB: the code is badly written (and it can't be fixed) so thread can segfault or be killed by OOM as a result all runtime dies
07:19:56 <RchrdB> oh you are in trouble there
07:20:04 <qnikst> RchrdB: yes
07:20:11 <RchrdB> if I wanted to have a big data structure shared between two processes like you described, then you're right that putting it in a mmap'd file is the portable thing to do.
07:20:37 <qnikst> it's not my code, and user want to just make a bit safier, not to rewrite in a good way
07:20:47 <RchrdB> I don't think that there is much support for shmem data structures in GHC, though.
07:21:24 <qnikst> RchrdB: I've seen a pkg that maps mmaped file on a bytestring, same can be done with shmem, I think I'll be fine with it
07:22:18 <qnikst> the only think that makes me sad is that I'll have to rewrite all required map functions so they will be able to work with serialized representation
07:22:30 <rgr> what would be a better or more "haskelly" way of doing then "if then" part of this little snippet which only starts the string with "sleep C &&" if the value is larger than 0? I wondered if I could use a list comprehension perhaps? [ (if b>0 then "sleep " ++ show b ++ " && " else "") ++ a |(a,b)<-[("hello",1)]]
07:22:51 <qnikst> :t Control.Monad.when
07:22:54 <lambdabot> Monad m => Bool -> m () -> m ()
07:22:54 <Cale> Wait, it's badly written Haskell code that segfaults?
07:23:19 <qnikst> Cale: I don't know detail yet, I think it some FFI bindings that are used there
07:23:28 <Cale> It really shouldn't be all that difficult to avoid segfaulting in a Haskell program
07:24:32 <Cale> Usually segfaults are either the result of compiler bugs, or bad uses of unsafeCoerce, or not really happening on the Haskell side, via FFI.
07:24:47 <Cale> and the compiler bugs of that sort are pretty rare :)
07:24:53 <qnikst> anyway the question "I just want to share a datastructure in a sensible way, no mater how!!!111one-one" may be asked =)
07:24:57 <Cale> (I don't know of any right now)
07:25:11 <Cale> Well, one way would be to use the FFI to allocate some memory
07:25:41 <Cale> and write to that memory instead of just trying to share Haskell structures on the heap
07:26:05 <qnikst> Cale: with FFI or incorrect usage of Foreing.Ptr, or unsafe things there are a number of way to make program segfauls
07:26:26 <qnikst> but also there is an OOM problem, that also may be fixed by checking thunk leaks etc.
07:26:39 <qnikst> but they just don't want to spend time on it
07:26:48 <qnikst> at least now
07:27:01 <EvanR2> OOM isnt a segfault
07:27:10 <EvanR2> but still bad
07:27:14 <qnikst> EvanR2: i
07:27:17 <qnikst> I
07:27:20 <qnikst> sorry
07:27:27 <EvanR2> :q
07:27:43 <Cale> Yeah, you can definitely do things like  peek nullPtr  to get a segfault
07:27:51 <qnikst> there are 2 kind of problems that they have: OOM and segfauls
07:28:01 <qnikst> both leads to runtime death
07:31:52 <EvanR2> fast and loose is the name of the game
07:32:18 <EvanR2> cut corners to speed up development and performance, and get neither
07:33:40 <qnikst> i think once I'll see a code I'll be able to improve it. but if it's ffi in 3rd party library then nothing can be done except of flooding it's devs with bugs and rewriting it
07:36:53 <EvanR2> a pull request with the fix would be good
07:36:58 <EvanR2> might be simple
07:38:19 <qnikst> they had such problems for almost half an year, so I tend to trust that there are valid reasons for wanting a plain and simple isolation, at least before looking at the code
07:47:13 <EvanR2> plain and simple isolation, a whole nother process that communicates through sockets ;)
07:47:32 <qnikst> agree
07:47:46 <qnikst> but here is a place where sharing jumps in
07:48:07 <geekosaur> "sharing" and "plain and simple isolation" are incompatible
07:48:56 <qnikst> geekosaur: if i'm share an RO file with other processes so they can perform queries on it process are still in isolation
07:49:54 <zlygg> Hi! I'm looking for Pipes.Shell examples.
07:54:04 <DanielDiaz> what way do you recommend to get GHC-7.8.3 and cabal in Ubuntu?
07:55:21 <clrnd> hey, what does -> mean in a class declaration?
07:55:24 <clrnd> like class Endpoint id resp | id -> resp where
07:55:56 <geekosaur> "the type of id determines the type of resp"
07:56:06 <clrnd> DanielDiaz, http://new-www.haskell.org/downloads/linux
07:56:20 <EvanR2> fundeps
07:56:22 <geekosaur> "functional dependency"
07:56:58 <clrnd> geekosaur, oh wow, but then this class says 'endpoint :: id -> Text', that means id is type resp or that resp is not used at all?
07:57:15 <clrnd> googling that
07:57:18 <geekosaur> that arrow is different from the one in the class declaration, it's the normal function arrow
07:57:31 <geekosaur> the fundep syntax is valid after the | in the class declaration
07:57:45 <geekosaur> (and up to the "where")
07:58:35 <Cale> DanielDiaz: I would do the stuff under "Manual install" on the page clrnd linked.
07:58:59 <clrnd> geekosaur, I understand that, I mean that why would I want to stablish a functional dependency if resp is not used?
07:59:08 <Cale> (but don't install GHC from source, it requires GHC to build anyway, so that's a waste of time)
07:59:27 <clrnd> (the line is from here https://github.com/dmjio/hackernews/blob/master/src/Web/HackerNews/Endpoint.hs#L21)
07:59:55 <Cale> clrnd: Is resp used by any of the other class methods?
08:00:11 <DanielDiaz> Cale: yes, I like that option more. thanks.
08:00:12 <Cale> oh, it's not
08:00:21 <DanielDiaz> clrnd: thanks :)
08:00:23 <Cale> Well, that's a bit weird
08:00:53 <Cale> clrnd: That's actually totally pointless
08:01:07 <Cale> clrnd: They could just remove the second type parameter from the type class
08:01:15 <clrnd> Cale, haha, let me try
08:01:27 <Cale> You'll have to change the instances of course
08:01:33 <Cale> But that shouldn't be hard to do
08:04:52 <clrnd> Cale, I guess it's for enforcing that when you ask for a Job, you need to pass a JobId
08:10:10 * hackagebot boomange 0.1.2.0 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.2.0 (mgmillani)
08:10:28 <owst_> > decode "\"testing\"" :: Maybe String
08:10:29 <lambdabot>  can't find file: L.hs
08:11:02 <owst_> That gives Nothing - what (hopefully obvious thing) am I missing?
08:11:43 <bennofs> owst_: iirc, json documents must have either an object or a list at the top-level
08:12:01 <bennofs> owst_: it says that somewhere in the documentation
08:12:47 <owst_> D'oh! I guess the clue is in the name Javascript OBJECT notation :) thanks bennofs
08:13:28 <owst_> Argh, this is straight out of the aeson docs, sorry for the noise.
08:15:16 <tdammers> to be fair, some JSON implementations will gladly accept scalars at the top level *cough*php*cough*
08:15:36 <EvanR2>  > decode "\"testing\"" :: Maybe String
08:15:54 <bennofs> @let import Data.Aeson
08:15:55 <lambdabot>  .L.hs:61:1:
08:15:55 <lambdabot>      Data.Aeson: Can't be safely imported! The module itself isn't safe.
08:16:32 <EvanR2> aeson will let you parse non object non arrays at the top level, if you ask nicely
08:17:34 <EvanR2> php's json decode is so broke
08:19:17 <myfreeweb> in php, everything is awful
08:20:17 <tdammers> EvanR2: yeah, that was kind of my point ;)
08:21:33 <EvanR2> in soviet russia hypertext preprocesses hypertext
08:22:01 <Cale> Wait, people wouldn't want non-array non-objects to be valid JSON?
08:22:17 <Cale> Why not have it be totally uniform?
08:25:00 <EvanR2> because doug crockford said so
08:25:10 <Cale> Seems questionable
08:26:08 <EvanR2> allowing that is a common option, but php is broke for other reasons
08:26:44 <tdammers> EvanR2: fun detail: json_encode/json_decode is *faster* than serialize/unserialize
08:26:55 <geekosaur> I *think* the idea was to ensure that JSON came with some context
08:27:13 <geekosaur> noble idea, but not a practical one
08:27:44 <myfreeweb> wasn't there a security problem somewhere with json root not being an object?
08:27:48 <EvanR2> tdammers: that makes sense, judging from the way serialize output looks
08:28:21 <EvanR2> or not
08:28:43 <tdammers> yeah, but still - a) pick your own serialization format, anything goes, vs. b) here's a serialization format, implement it as-is. And then they end up with b) being more efficient than a)
08:29:03 <Cale> "Every JSON document is required to be accompanied by an RDF specification of its contents"
08:29:06 <Cale> ^^ such plan
08:29:28 <EvanR2> o_O
08:29:38 <tdammers> "or else!"
08:30:05 <EvanR2> php serialize supports for shit than json, if i remember correctly
08:30:12 <EvanR2> s/for shit/more shit/
08:30:51 <kadoban> freudian slip? :)
08:31:52 <EvanR2> Cale: where is that?
08:31:53 <phaskell> No symbol 'that' found anywhere.
08:32:26 <Cale> EvanR2: nowhere, I'm joking about the "context" thing
08:32:29 <EvanR2> oh
08:32:36 <chaosfisch> I'm looking for following: I want to call map on every 2nd value of a list. Is there something existing to do so?
08:32:49 <Cale> uh
08:33:04 <EvanR2> > :t map ()
08:33:05 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:33:26 <EvanR2> the 2nd value must be a function then;)
08:33:31 <Cale> chaosfisch: Nothing existing. Note that this has a much more restrictive type than map does
08:35:14 * hackagebot boomange 0.1.2.1 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.2.1 (mgmillani)
08:35:16 * hackagebot ede 0.2.3 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.3 (BrendanHay)
08:35:57 <Cale> Oh, you could do this:
08:35:59 <kadoban> chaosfisch: \f -> zipWith ($) $ cycle [f, id]
08:36:02 <kadoban> maybe
08:36:03 <Cale> yeah
08:36:12 <Cale> That was exactly what I was going to suggest
08:36:16 <kadoban> Hehe
08:36:30 <EvanR2> map (f . (!! 1)) list
08:37:24 <chaosfisch> thanks. I'll try that
08:37:27 <Cale> > zipWith ($) (cycle [(*10), id]) [1..10]
08:37:28 <lambdabot>  [10,2,30,4,50,6,70,8,90,10]
08:37:42 <EvanR2> misread
08:39:27 <anders0> sorry, but can someone remind me what to do about the 'The package 'glib' requires Cabal library version -any && >=1.18 but no suitable version is installed.' error?
08:39:46 <Cale> anders0: ghc-pkg list Cabal
08:39:48 <anders0> (i have cabal 1.20, and i've had this error severla times before, but i've forgotten what to do about it)
08:39:51 <Cale> hm
08:40:12 <anders0> …oh. is it just me? :B
08:40:43 <Cale> Perhaps you're accidentally trying to install globally and only have an older version of the Cabal library installed globally?
08:41:12 <Cale> I'm not sure exactly what would cause that
08:41:24 <anders0> oh hold on, never mind
08:41:41 <anders0> the GHC db has cabal 1.16, even though cabal-install was linked against 1.20???
08:41:46 <anders0> so never mind. sorry for noise.
08:42:23 <tnks> how far have people gotten with deriving serialization type class instances structurally from ADTs?
08:42:24 <Cale> anders0: That's somewhat normal
08:42:34 <Cale> anders0: (though you must be on a somewhat old GHC)
08:42:56 <Cale> tnks: Pretty far?
08:42:56 <anders0> you could say that, yeah. this is a debian vm with 7.4? or something.
08:42:57 <tnks> I understand that it wouldn't make sense as a language extension for GHC because everyone likes a different API/library.
08:42:59 <anders0> not my normal situation
08:43:07 <tnks> Cale: do you have some examples I could look at?
08:43:16 <tnks> I'm still new to Haskell pragmatics.
08:44:11 <tnks> Cale: mostly, I'm still in the world of hand-writing the instances, but it's often route work.
08:44:39 <Cale> Well, which kind of serialisation in particular?
08:45:18 <tnks> Cale: a non-streaming byte string would be fine for starters.
08:45:40 <myfreeweb> well, aeson supports template haskell and generics
08:45:53 <tnks> myfreeweb: yeah, kind of like that.
08:46:03 <tnks> (though I hadn't looked into that yet)
08:46:05 <nshepperd> I think Data.Binary can also do that
08:46:14 <tnks> I guess that for something like MessagePack would be cool too.
08:46:46 <myfreeweb> https://hackage.haskell.org/package/msgpack-0.7.2.5/docs/Data-MessagePack-Derive.html
08:46:49 <int-e> tnks: there are a number of stand-alone libraries, for example based on GHC.Generics. There's also ndm's 'derive' package, and the DrIFT package (but I don't know whether the latter works)... plenty of options, I would say.
08:46:55 <tnks> myfreeweb: thanks a lot.
08:47:09 <Cale> tnks: There's also this: http://hackage.haskell.org/package/binary-generic-0.2.1/docs/Data-Binary-Generic.html
08:47:15 <tnks> int-e: everyone: thanks a lot, this is all the kind of feedback I was hoping for.
08:47:19 <tnks> good pointers.
08:48:31 <Cale> I'm surprised there are no Binary instances for the new GHC Generics
08:48:47 <Cale> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Generics.html
08:49:24 <Cale> You can {-# LANGUAGE DeriveGeneric #-} and then add  deriving (Generic)  to your datatypes to get an instance
08:49:36 <int-e> Oh and surely there must be some syb based Binary instances?
08:49:46 <Cale> Yeah, that's what I actually first linked to there
08:49:53 <int-e> (I know that's considered outdated.)
08:49:56 <int-e> Cale: thanks
09:13:07 <schell> has anyone been having problems with `cabal install` on mac 10.10?
09:13:52 <schell> i’ve had a lot of stalling/hangs and it looks like somehow it’s compiling in a loop (though maybe it’s just compiling regular + profiling libs?)
09:14:26 <schell> i tried installing texmath overnight and it was hung at the ghc-pkg registering phase this morning
09:15:22 <myfreeweb> i've heard you should reinstall ghc and stuff after upgrading to 10.10
09:15:33 <myfreeweb> not upgrading my main machine to 10.10 for now
09:15:42 <schell> myfreeweb: i bet that’s it then
09:15:49 <schell> thanks, i’ll try that today
09:17:25 <piskrist> is it just me or are cabal sandboxes full of holes?
09:17:45 <Ankhers> What issues are you having?
09:18:04 <kadoban> piskrist: What kind of holes?
09:18:16 <sm> yes, they have some holes/add some complexities with other tools
09:18:27 <piskrist> well, right now I'm unable cabal install process-1.2.0.0
09:18:40 <geekosaur> ghc doesn't support full sandboxing (you can't sandbox the global package db)
09:18:50 <piskrist> it looks like it's all fine. But it really isn't. After that, the system process-1.1.x is still used for building
09:18:51 <geekosaur> you'll need to use something like hsenv for that
09:19:14 <michaelt> piskrist: but isn't process globally installed? you might need a bit more ...
09:19:30 <piskrist> and I'm having weird issues like some packages can't be installed in sandbox, but are ok out of it
09:19:30 <chaosfisch> Okay, took me some time to understand it: I was then trying: zipWith ($) (cycle [id, head]) [1..10] to get a result of "[1, 3, 5 ...]". This doesn't work because cycle needs to get two functions of the same result type?
09:19:48 <geekosaur> also I think process is a bootlib?
09:19:59 <piskrist> well process is installed with ghc package
09:20:05 <geekosaur> yes, bootlib. so you can't replace it without replacing ghc
09:20:18 <geekosaur> use hsenv to install an appropriate sandboxed ghc with the correct version of process
09:20:20 <michaelt> piskrist: if "ghc-okg list" shows them in the first (global) group of packages, you shouldn't bother them in a sandbox
09:20:23 <piskrist> but since process 1.2 says it works with base > 4.4 i thought i'll just cabal install it into sandbox
09:20:26 <geekosaur> cabal can't do anything about this
09:20:59 <indiagreen> > catMaybes $ zipWith ($) (cycle [Just, const Nothing]) [1..10] -- chaosfisch
09:21:02 <lambdabot>  [1,3,5,7,9]
09:21:07 <piskrist> why do I need to replace whole ghc when process-1.2 says it works with base >=4.4 and ghc-7.6 is base-4.6 ?
09:21:21 <kadoban> chaosfisch: head and id are totally different types. What exactly are you trying to do? Maybe we misunderstood your description.
09:21:31 <geekosaur> bootlibs are "special". your problem is with ghc
09:21:33 <bennofs> piskrist: ghc also depends on process
09:22:02 <geekosaur> (bootlibs are the libraries that ghc itself, and the ghc-api, use. replacing these is almost impossible to do safely without replacing ghc)
09:22:17 <michaelt> becuase you already have process integrated with your compiler
09:22:30 <bennofs> You can replace them as long as you don't depend on anything that uses the GHC API
09:22:33 <piskrist> right, so it's possible to recompile ghc-7.6 with process-1.2 ?
09:23:15 <bennofs> piskrist: what package are you trying to build?
09:23:24 <chaosfisch> kadoban: You got my description right, but I was wrong. I wanted to get every 2nd element of the list and just realized that's not equal to applying a function to every 2nd element. Haskell is still a big challenge to me.
09:23:46 <kadoban> Ahh
09:23:50 <michaelt> it is probably possible, but you would have to build it, since the binary version of ghc-7.6 is probably built with an earlier process
09:24:21 <bennofs> afaik, bootlibs aren't supposed to be replaced when building GHC
09:24:47 <michaelt> piskrist: that is, you could build ghc-7.6 but swap out the version of process that came with it
09:25:13 <michaelt> ... and see what happens....
09:25:20 * hackagebot clafer 0.3.7 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.7 (mantkiew)
09:25:27 <bennofs> piskrist: as long as you don't use the GHC API (or packages depending on it, like doctest or hint), replacing process should work
09:25:48 <michaelt> piskrist: but if you want process-1.2 for some reason why not get a new ghc from the ghc site
09:27:02 <michaelt> piskrist: process-1.2.0.0 will come integrated with ghc-7.8 which you can download and install at least on unix-type systems.
09:27:34 <hexagoxel> piskrist: i just tried building process-1.2.0.0 in sandbox with ghc-7.6.3, no problem.
09:28:20 <hexagoxel> i also tried installing process-1.1.0.2 in sandbox with ghc-7.8.3: not in scope: unsafePerformIO :D
09:29:13 <piskrist> hm, yeah it works somewhere
09:30:20 * hackagebot claferIG 0.3.7 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.7 (mantkiew)
09:30:22 * hackagebot claferwiki 0.3.7 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.7 (mantkiew)
09:30:55 <michaelt> hexagoxel: but won't you regret this pretty quickly ...
09:31:44 <michaelt> hexagoxel: piskrist, actually I don't see that any of the other boot libraries depend on process so some of the more obvious disasters might be evaded.
09:32:16 <piskrist> yeah, I see it works with other user
09:33:46 <hexagoxel> michaelt: pretty quickly = if and only if i use ghc api?
09:33:54 <piskrist> but not inside sandbox lol
09:35:20 <piskrist> that's the hole I meant
09:35:21 * hackagebot rest-types 1.11.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.11.1 (AdamBergmark)
09:35:22 <michaelt> hexagoxel: no, I took it back, I was just referring to the general difficulties with installing a boot library locally somewhere. Process doesn't seem to deeply embedded.
09:35:23 * hackagebot rest-core 0.33.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.33.1 (AdamBergmark)
09:35:25 * hackagebot rest-gen 0.16.0.4 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.0.4 (AdamBergmark)
09:35:30 <hexagoxel> michaelt: i have a project where i accidentally used newer transformers in sandbox; still compiles and runs just fine.
09:36:02 <geekosaur> ghc-api and maybe th and maybe other stuff (ghci?). the compiler itself should generally continue to work.
09:36:34 <michaelt> yes, it depends, for example, on whether anything you are using from the global libraries depends on transformers.
09:39:11 <michaelt> it doesn't seem any other boot library depends on transformers, so again, the scope for disaster is limited.
09:40:07 <hexagoxel> hmm, btw, how can i `cabal exec -w foo` ?
09:41:34 <a3gis> Hello!  I have to write a lexer for a small language, which is supposed to emulate the behaviour of GHC's. Would someone happen to know how "--+" would be lexed? as a symbol?
09:41:50 <geekosaur> a3gis, yes
09:42:15 <a3gis> geekosaur: thanks! is there a tool to check the token stream generated by ghc for some input?
09:42:45 <geekosaur> no tool I'm aware of, possibly one of ghc's -d options
09:43:08 <geekosaur> and probably something in the haskell-src-exts package but not packaged as a tool
09:43:54 <michaelt> > let x --+ y = x in 1 --+ 2
09:43:56 <lambdabot>  1
09:45:05 <geekosaur> doesn't look like there's an output to dump lexer output
09:45:16 <geekosaur> er, a -d option to...
09:51:37 <merijn> dcoutts: ping?
09:52:18 <dcoutts_> merijn: sort of busy, ask me in #ghc and I'll get back to you later
09:52:52 <CodeWeaverX> Okay.  Arrows are cool.  Don’t know what I’m going to test them with to learn more that isn’t easier to do with ordinary functions and more readable, but that’ll come with experience.   And thanks, merijn, for indirectly nerd-sniping me with them  yesterday. ;)
09:53:20 <CodeWeaverX> (And, yes, I get that functions themslves are arrows)
09:56:12 <merijn> CodeWeaverX: Generally Arrows are considered to not live up to the hype
09:57:26 <CodeWeaverX> nevertheless, in the abstract, the idea of being able to connect functions in ways other than the dot operator is kind of fascinating.  Always wanted to do that.  But fair enough. :)
10:00:37 <nshepperd> I've occasionally used Kliesli arrows, but having to do Kliesli and runKliesli to convert back and forth between (a -> m b) and an arrow sort of nullifies the advantage of being able to use the arrow operators
10:00:37 <CodeWeaverX> There seems to be some overlap with Bifunctors?
10:01:13 <nshepperd> Arrows are Profunctors, I think
10:02:41 <CodeWeaverX> Another thing to look up.  This will quickly get a bit abstract for me.  *googles*
10:03:36 <nshepperd> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
10:03:46 <nshepperd> oh, even mentions Arrows
10:03:59 <CodeWeaverX> Excellent.  My brain will be melting by breakfast.
10:04:11 <int-e> @type runKleisli
10:04:13 <lambdabot> Kleisli m a b -> a -> m b
10:06:15 <nshepperd> (Just 5) >>= runKliesli (arr (+1) &&& arr (-1) &&& Kliesli (\_ -> Nothing))
10:06:22 <nshepperd> > (Just 5) >>= runKliesli (arr (+1) &&& arr (-1) &&& Kliesli (\_ -> Nothing))
10:06:24 <nshepperd> bah
10:06:24 <lambdabot>  Not in scope: ‘runKliesli’
10:06:25 <lambdabot>  Perhaps you meant ‘runKleisli’ (imported from Control.Arrow)Not in scope: da...
10:06:25 <lambdabot>  Perhaps you meant ‘Kleisli’ (imported from Control.Arrow)
10:06:38 <nshepperd> oh, I can't spell...
10:07:01 <nshepperd> > (Just 5) >>= runKleisli (arr (+1) &&& arr (-1) &&& Kleisli (\_ -> Nothing))
10:07:02 <lambdabot>  No instance for (GHC.Show.Show c1)
10:07:02 <lambdabot>    arising from a use of ‘M526640500056182457631812.show_M5266405000561824576...
10:07:02 <lambdabot>  The type variable ‘c1’ is ambiguous
10:07:02 <lambdabot>  Note: there are several potential instances:
10:07:02 <lambdabot>    instance [safe] GHC.Show.Show
10:07:23 <nshepperd> erm
10:07:45 <int-e> @type (-1)
10:07:46 <lambdabot> Num a => a
10:07:49 <merijn> CodeWeaverX: We already have lots of ways to connect functions other than dot, such as
10:08:00 <merijn> :t (>=>) -- whoo, Kleisli composition!
10:08:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:09:46 <nshepperd> yeah, I forgot that you can use (-1) as a section...
10:09:59 <nshepperd> can't
10:10:25 * hackagebot extra 0.4 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.4 (NeilMitchell)
10:10:46 <merijn> CodeWeaverX: My favourite way of looking at it is: Functor's are "producers" ('f a' is a "producer of a's"), Contravariant functors (contramap :: Contravariant f => (a -> b) -> f b -> f a) are "consumers" ('f a' is a consumer of "a's") and profunctors are pipes :)
10:11:23 <merijn> Of course Category is also a pipes and I'm a bit fuzzy on how Category and Profunctor relate to one another
10:11:40 <nshepperd> it should really be (Profunctor a, Category a) => Arrow a, I think, but Profunctor isn't in base
10:12:48 <merijn> oh, I guess Category has no way to lmap/rmap and profunctor has no composition?
10:13:47 <nshepperd> yeah you can't mix Category with regular functions
10:15:08 <CodeWeaverX> I missed something in my few minutes absence clearly. :)
10:18:04 <nshepperd> I guess Category can be "pipes backward" as well, eg Flip (->) is a category
10:26:22 <heudebeu> @pl \a b -> (0==) $ mod a b
10:26:22 <lambdabot> ((0 ==) .) . mod
10:30:15 <ionum> hey, i have a problem, i am using xmonad and since today programmers dvorak, but xmonad and this keyboard layout do not work together, it does not recognize when i am pressing the modkey
10:30:27 <ionum> what shell i do?
10:30:41 <ionum> shall
10:32:13 <koala_man> ionum: was your modkey remapped along with all the other keys? is it mod3 instead of mod4 for example?
10:33:03 <ionum> well it should not be remapped, i even tried different modkeys
10:33:39 <koala_man> did you try xev to see which key events it's producing?
10:34:27 <ionum> i will try xev
10:37:24 <ionum> ok it changed indead from alt gr to alt l
10:38:11 <augur_> danclien: oh hello!
10:38:19 <augur_> << psygnisfive
10:38:25 <danclien> augur_: Hi. :)
10:38:45 <ionum> indeed
10:39:01 <augur_> danclien: so you've been trying to grok haskell, ey?
10:39:17 <augur_> anything in particular that's a pain?
10:39:54 <danclien> Mostly teaching enough Haskell for a team to be productive has been the biggest challenge.
10:40:22 <Presciptor> Can someone please help me read the 3'rd line in the following paste in words? i.e. it's saying something like "forall m in (2 to round(root(x))" do some condition? ..
10:41:26 <augur_> danclien: i find that its good to make sure people have a certain grounding that enables them to then quickly pick up new concepts
10:41:55 <danclien> augur_: What would you consider to a solid base to work from?
10:42:18 <augur_> danclien: basic type theory i think is a really good start
10:43:10 <augur_> functional programming is, often, data-oriented programming, and so i think its good to have a firm grasp of what data types are really doing
10:43:25 <danclien> augur_: I'm not sure what "basic type theory" is. :P
10:43:39 <augur_> i feel that from there, it tends to just be a matter of finding the right perspective on things
10:43:41 <augur_> oh, well!
10:43:44 <augur_> @oplss2012
10:43:44 <lambdabot> Unknown command, try @list
10:43:46 <augur_> whoops
10:43:49 <augur_> @where oplss2012
10:43:49 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
10:44:07 <augur_> pfenning's videos on there are the best introduction ive ever seen
10:44:53 <danclien> augur_: Awesome. I'll check it out
10:44:57 <WraithM> Say I have an executable that takes a file as an argument. I want to take a ByteString from an HTTP request and send that data into a file that would go into the argument to that command. Is there a good way to do that in Haskell?
10:45:10 <danclien> So much good stuff from that UOregon program. Not enough time to watch it all. D:
10:45:32 * hackagebot graph-rewriting 0.7.6 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.7.6 (JanRochel)
10:45:33 <augur_> i think most of the fancy concepts in haskell become much simpler once you can see them through the TT lense
10:45:34 * hackagebot graph-rewriting-layout 0.5.3 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.5.3 (JanRochel)
10:45:36 * hackagebot graph-rewriting-gl 0.7.5 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7.5 (JanRochel)
10:45:44 <augur_> ugh hackagebot :|
10:45:45 <WraithM> I guess I'm just looking for a package or module that I can learn to do bytestring to shell stuff.
10:46:00 <augur_> in case that got lost:
10:46:02 <augur_> i think most of the fancy concepts in haskell become much simpler once you can see them through the TT lense
10:46:50 <augur_> type classes, GADTs, richer parametric widgets.. all easier if you know some TT, i feel
10:47:12 <augur_> also thing like higher order functions, especially things like fold and other kinds of funky ones
10:47:47 <danclien> Strange. Site looks down to me.
10:47:56 <malllle> same
10:48:14 <augur_> hm. its taking time for it to load for me too
10:48:36 <CodeWeaverX> I think that’s worth me looking at too.  I’ve worked through stuff on Functors and Type Classes in beginning terms.  folds and maps don’t bother me.  But it very quickly gets so rich that even a discussion of the more advanced topics are dripping with stuff from abstract algebra and category theory that seems to assume a huge amount of pre-existing knowledge, and isn’t necessarily helpful for writing practical haskell pro
10:48:44 <CodeWeaverX> Yah, I can’t load it yet.
10:48:52 <augur_> isup.me says its down for them too
10:48:57 <augur_> how weird!
10:49:36 <augur_> danclien: so you're teaching haskell to a team, ey?
10:49:46 <CodeWeaverX> That’s actually pretty cool.
10:50:15 <danclien> augur_: "Teaching" is putting it nicely. :)
10:50:29 <augur_> have you told them about this channel? :)
10:50:36 <danclien> I picked Haskell for a new project although I'm far from a Haskell expert.
10:50:40 <augur_> or about #nothaskell which is also very good
10:51:02 <vanila> augur_, most things but there's a few things I don't understand in terms of TT like typeclasses
10:51:08 <vanila> type families
10:51:27 <danclien> Yes to both. :) Getting people on IRC is hard though. :P
10:51:38 <augur_> yeah type families are a very subtle nuance
10:51:52 <augur_> you can understand type families in TT terms, but its a subtle thing
10:52:39 <augur_> danclien: yeah, its surprisingly hard. i dont know why
10:52:56 <augur_> i guess im just a dope, ill do whatever you tell me
10:53:01 <augur_> "get on irc!" "ok!"
10:53:03 <danclien> :P
10:53:12 <augur_> whereas this guy im working with, doing a startup
10:53:18 <augur_> getting him on IRC was like pulling teeth
10:53:34 <augur_> "just download a client and sign on to freenode! :| :| :|"
10:53:44 <augur_> and then like next week, same thing
10:53:48 <danclien> I'm tempted to set up an IRCCloud account for everyone and give them the login information to get on.
10:53:52 <augur_> then the week after, finally he does it
10:53:52 <Yxven> Haskell seemed pretty easy to learn  through functors but it seems like you have to know all the advanced concepts to write decent programs with it
10:54:28 <augur_> vanila: the TT-perspective on type families is basically, you're writing functions at the meta-level
10:54:42 <vanila> oh i see!
10:54:43 <danclien> Yxven: Which concepts do you consider advanced?
10:54:48 <vanila> meta rather than type level
10:55:12 <CodeWeaverX> Well, its not that hard to write practical programs using basic haskell… lists, vectors, new data types, folds, maps, explicit recursion, and the occasional doing imperative things.
10:55:33 * hackagebot graph-rewriting-strategies 0.2.3 - Evaluation strategies for port-graph rewriting systems  http://hackage.haskell.org/package/graph-rewriting-strategies-0.2.3 (JanRochel)
10:55:35 * hackagebot graph-rewriting-ski 0.6.4 - Two evalutors of the SKI combinator calculus as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.6.4 (JanRochel)
10:55:37 * hackagebot graph-rewriting-trs 0.1.6 - Evaluate first-order applicative term rewrite systems interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.6 (JanRochel)
10:55:39 * hackagebot graph-rewriting-ww 0.3.4 - Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing  http://hackage.haskell.org/package/graph-rewriting-ww-0.3.4 (JanRochel)
10:55:41 * hackagebot graph-rewriting-lambdascope 0.5.6 - Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.6 (JanRochel)
10:56:04 <Yxven> danclien monads, monadtransformers, lenses, and frp plus all the template Haskell that requires forall
10:56:06 <augur_> vanila: that is to say, in TT you have rules like this:   A type   B type   ==>   (A,B) type
10:56:26 <augur_> vanila: right, which tells you when you're allowed to conclude (A,B) is a type
10:56:50 <augur_> vanila: well you also might want to declare your own type former, like, say, F, with a rule like
10:56:57 <augur_> A type   ===>   F A type
10:57:31 <danclien> Yxven: Ah, gotcha. I've started writing web APIs with only really knowing monads on that list.
10:57:57 <augur_> vanila: but, you dont want to define a new type with new constructors, so you have to say how to turn any given occurrence F A into something that doesn't use F (and therefore doesnt need its own constructors)
10:58:12 <augur_> vanila: so you give equations like   F (A,B) = (F A, F B)   or whatever
10:59:21 <augur_> vanila: at the meta level, a type is just a piece of data so these meta-functions can pattern match on them and whatever
11:00:43 <merijn> vanila: The meta-level *is* the type level
11:00:58 <shapr> QF-MichaelK: oh hai! Want to learn some Haskell? :-)
11:01:04 <QF-MichaelK> yes
11:01:08 <shapr> hurrah!
11:01:17 <merijn> At the bottom of the hierarchy you have terms (expressions/values), 1 level above that (the meta level) is types, because terms have a type
11:01:18 <shapr> So, have any FP background? ;-)
11:01:23 * shapr hops cheerfully
11:01:41 <augur_> vanila, merijn: right. when you write things like f :: * -> * you're giving a type in the meta-level, which is a really simplified version of haskell
11:01:42 <piskrist> oh god, it's happening again. I can't install happy and haskell-src-exts
11:01:56 <merijn> vanila: Types in turn have another meta-level (kinds) and kinds have a meta level named "Sort" (which is not writable or usable in haskell)
11:02:08 <augur_> if you do something like   data Foo = ...   what you're doing at the meta-level is adding the constructor Foo to the * meta-type
11:02:22 <QF-MichaelK> shapr: Uh, I did do some ML for a coursera programming class.  Then some Racket.  As for haskell, mostly project euler problems.
11:02:24 <shapr> QF-MichaelK: I like bitemyapp's tutorial for free online tutorials
11:02:44 <danclien> piskrist: I install happy in a sandbox then symlink it to ~/.cabal/bin.
11:02:47 <merijn> vanila: Now in dependently typed languages, this meta-tower is infinitely large, usually the meta level is denoted with a subscript to denote it's level
11:02:51 <Forgetaboutit> is there a way to export a type class together with all its functions or would I have to export the functions individually?
11:03:14 <merijn> Forgetaboutit: "MyClass(..)" should export all functions, iirc
11:03:18 <augur_> merijn, vanila: also with DTs the meta-level and the object-level are blurred
11:03:39 <augur_> actually it'd be more accurate to say that there is no accessible meta-level
11:03:41 <monochrom> if you already know ML, then in Haskell you just have to adjust for non-strictness in theory, and lazy evaluation in practice
11:03:51 <augur_> tho there ARE things at the meta-level that people often use
11:04:06 <augur_> things like large elims, etc. which are usually not accessible to the programmer
11:04:14 <monochrom> for example "take 1 (map f xs)" takes linear time and space in ML, constant time and space in Haskell
11:04:21 <augur_> you might be able to use them, but you cant define them, etc.
11:04:32 <QF-MichaelK> shapr: Thank you, this will likely keep me busy for quite some time ^.^
11:04:53 <shapr> ok!
11:04:54 <monochrom> and "(\x y -> x) () (1/0)" has no problem
11:05:55 <piskrist> danclien: thats the problem. I can't install it into sandbox
11:06:11 <piskrist> danclien: but without sandbox it's ok
11:06:20 <Forgetaboutit> merijn: That did the job, thanks!
11:06:40 <danclien> piskrist: That's strange. Do you have the output of the compile error up somewhere? (Gist?)
11:06:47 <piskrist> just ExitFailure 1
11:06:57 <piskrist> Imma strace it
11:07:08 <danclien> Full output is just "ExitFailure 1"?
11:07:21 <piskrist> danclien: yep
11:07:35 <danclien> piskrist: :( Wow.
11:07:59 <nshepperd> if I imagine that "data constructors : functions :: data/newtype declarations : type families" am I wildly wrong?
11:08:58 <augur_> nshepperd: no, thats more or less precisely correct
11:09:10 <monochrom> I don't understand that correspondence.
11:09:18 <piskrist> danclien: well, there is also setup: The program happy is required but it could not be found
11:09:22 <piskrist> but it looks like nonsense
11:09:27 <augur_> nshepperd: at least,   data constructors : data functions :: type constructors : type functions/families
11:10:10 <monochrom> well, that's different
11:10:56 <ionum> hi again
11:11:36 <augur_> iinm there were some substantial issues with the interaction between newtype and type families that lead to roles? i dont remember the examples tho
11:13:00 <piskrist> execve("/tmp/happy-1.19.4-22247/happy-1.19.4/dist/dist-sandbox-1a829d03/setup/setup", ["/tmp/happy-1.19.4-22247/happy-1."..., "build", "--verbose=1", "--builddir=dist/dist-sandbox-1a8"...],
11:13:02 <piskrist> looks like this failed
11:13:45 <nshepperd> augur_: oh, cool
11:14:10 <nshepperd> augur_: yeah that was the GeneralizedNewtypeDeriving thing, I think
11:14:14 <ionum> xmonad only recognizes the win key
11:14:34 <ionum> even if i change to mod1key or mod3key, my alt keys are not recognized
11:14:49 <augur_> nshepperd: no i dont think it was related to that actually
11:15:11 <ionum> and i can not use the win key, because i use linux inside a vm and win+l triggers lockscreen
11:16:03 <augur_> oh maybe it was related to that, nshepperd? hmm
11:16:12 <augur_> oh no
11:16:16 <augur_> so:  https://www.haskell.org/ghc/docs/7.8.2/html/users_guide/roles.html
11:16:22 <merijn> nshepperd: If you haven't read it, I also highly recommend the "Fun with Type Functions" paper :)
11:16:56 <augur_> yeah its .. somehow with generalized newtype deriving, i guess. hmm
11:16:59 <saep`> ionum: That seems to be a configuration error, Would you mind pasting your config? (Also, there's #xmonad)
11:18:27 <augur_> i feel like this whole role business is unnecessary
11:19:02 <augur_> if type classes were type checked like normal data, then you'd simply get a type error if you did a generalized newtype deriving
11:19:13 <piskrist> now I can't install happy even into ~ on this machine
11:19:13 <nshepperd> yeah, that. automatically deriving a function :: a -> F a lets you coerce things if F is a type family
11:19:14 <fragamus> > 1370.0 / 6506.0
11:19:16 <lambdabot>  0.21057485398094067
11:19:30 <nshepperd> well, it lets you coerce things in a bad way
11:19:44 <fragamus> whoa 21 percent of downloads of Linear have happened in the last 30 days
11:19:44 <augur_> nshepperd: well, it shouldnt, if generalized newtype deriving werent overly clever
11:19:56 <piskrist> it installs and I get happy executable in .cabal/bin but ghc-pkg list doesn't have it
11:20:19 <augur_> nshepperd: i mean, what generalized newtype deriving should do is precisely: create an instance programmatically, and then let the type checker check it like usual
11:20:30 <augur_> and if it did that, the type checker would balk and itd be fine
11:20:58 <augur_> but it looks like generalized newtype deriving actually just cheats and does something else thats supposed to be more efficient or whatever
11:21:45 <danclien> piskrist: What does `ghc-pkg list happy` return?
11:21:58 <danclien> piskrist: Mine's just `/Applications/ghc-7.8.3.app/Contents/lib/ghc-7.8.3/package.conf.d`
11:21:58 <boxmein> given a System.IO.Handle, how do I hReadLine and then un-seek it to the start of file?
11:22:07 <ionum> http://pastebin.com/3w0Cfkc4
11:22:12 <piskrist> /usr/lib64/ghc-7.8.3/package.conf.d
11:22:14 <piskrist> /root/.ghc/x86_64-linux-7.8.3/package.conf.d
11:22:30 <ionum> i do not think its a configfile error
11:22:38 <boxmein> I want to parse the first line separately and pass the same file data onto a delegated handler
11:22:42 <danclien> I think that's fine. Most libraries only expect `happy` to be available in your PATH.
11:24:06 <danclien> piskrist: My "nuclear" option is to delete ~/.ghc, just in case.
11:24:08 <ClaudiusMaximus> piskrist: happy doesn't provide a library, only an executable.  ghc-pkg only knows about libraries
11:24:16 <piskrist> right
11:24:24 <merijn> boxmein: System.IO has seek/tell functions
11:24:29 <hexagoxel> piskrist: about the sandbox install: what's the output with verbose mode? maybe post that?
11:24:32 <piskrist> it seems to be fine now that I added .cabal/bin into my path
11:25:36 <nshepperd> augur_: I seem to recall a suggestion that ghc should try to explicitly construct a functor instance for the thing being derived
11:25:51 <saep> ionum: I was expecting another style of configuration which I saw quite often with a similar issue. Anyway, changing the modMask field should just work. Did you forget to recompile and restart it?
11:26:25 <ionum> no i can recompile
11:26:31 <danclien> piskrist: I always have ~/.cabal/bin in my PATH. :) Painful otherwise.
11:26:34 <augur_> nshepperd: sure, yeah. i dont think there's much of a problem here. the tricky thing is that you have to treat the derived instance as a normal instance for type checking
11:26:42 <augur_> which im certain generalized newtype deriving did _not_ do
11:26:43 <ionum> but it only recognizes the win modkey
11:27:12 <geekosaur> ionum, perhaps a more useful thing is to look at what keys are bound to what modifier bits: xmodmap -pm
11:27:41 <piskrist> yeah, looks like that's the problem as my server is still failing
11:28:24 <nshepperd> I think you end up having to invent Map k v --> Map (newtype k) v conversion things, which might be difficult
11:28:35 <geekosaur> also how are you expecting that to use alt, mod4Mask is typically the Win key. what program is not recognizing Alt?
11:28:38 <nshepperd> or that sort of thing
11:28:40 <danclien> piskrist: What's still failing?
11:28:49 <ionum> oh
11:28:56 <ionum> so mod1 is alt_l and alt_r
11:29:01 <piskrist> danclien: https://github.com/yaccz/yac-build-server this
11:29:07 <ionum> i thought mod3 was alt_r
11:29:07 <geekosaur> were you expecting changing modMask to leave the original bindings in place?
11:29:48 <danclien> piskrist: Trying it on my laptop. :)
11:30:01 <piskrist> danclien: https://github.com/yaccz/yac-build-server/blob/wip/library/YacBuildServer.hs#L158 this line specifically. Before I added the PATH
11:32:19 <nshepperd> augur_: however once the derived instance is created, it should be a no-op, so you don't actually need to use
11:32:26 <S11001001> I'm not terribly happy with the foldr-from-foldMap-Endo-like approach I've chosen for these default implementations <http://ur1.ca/ii316> Anyone have any ideas on how the structure of the LeftFold1/RightFold1 types could be improved to be less initial?
11:32:31 <danclien> piskrist: Eep, I'm a bit confused. It's not working with your updated PATH?
11:32:41 <nshepperd> which I think is sort of the point of roles
11:32:56 <piskrist> danclien: https://github.com/yaccz/yac-build-server/blob/wip/library/YacBuildServer.hs#L158 this line specifically. Before I added the PATH
11:33:05 <nshepperd> to prove the isomorphism
11:34:35 <augur_> nshepperd: right, but you dont need fancy junk for that
11:34:56 <Evilsparza> is there a more intuitive/less verbose way to add something to a tuple than this: http://pastebin.com/mXV1FhCN ?
11:35:08 <augur_> nshepperd: you just create the derived instance in a trivial way (wrap/unwrap) and if it type checks, you erase as usual
11:35:23 <ionum> well even if i use mod1Mask
11:35:33 <ionum> its not recognized
11:35:37 <ionum> :'(
11:35:47 <geekosaur> you said earlier that your alt key had been rebound to AltGr?
11:35:51 <geekosaur> that matters
11:36:00 <ionum> no my altgr key was rebound to alt-r
11:36:05 <bergmark> Evilsparza: if isOdd then first else second (from Control.Arrow)
11:36:41 <Evilsparza> thanks bergmark I'll have a look
11:36:48 <ionum> hm ok, i noticed something unusal
11:36:57 <ionum> if i use qwerty
11:37:00 <ionum> start the console
11:37:08 <ionum> and then set the keyboard to dvorak
11:37:17 <ionum> then i can use the alt-left key
11:37:19 <bergmark> Evilsparza: (&&&) is even better i suppose
11:37:49 <nshepperd> augur_: right, but sometimes the wrapping has to be mapped over things and such
11:38:15 <geekosaur> btw this stuff is probably better discussed over in #xmonad where there are more likely to be people who know about how different keyboard mappings work
11:38:27 <ionum> ok, i will change here
11:38:59 <augur_> nshepperd: eh.. i suspect that the generalized newtype deriving method is supposed to be trivial, so it shouldnt map anything
11:39:08 <augur_> it should just be like..   say we're deriving functor
11:39:27 <augur_> fmap f = Wrap . fmap f . Unwrap
11:39:33 <augur_> er.. unwrap
11:39:49 <augur_> given    newtype Foo = Wrap { unwrap :: Bar }
11:40:59 <augur_> or something like that. i think in general the way to derive the instances is clear. the problem is, i think, that this just isnt done
11:42:09 <nshepperd> functor is an easy example, I think. consider class Silly a where { concat :: Seq a -> a }
11:42:46 <nshepperd> concat = Wrap . concat . Seq.map unwrap
11:43:06 <QF-MichaelK> Hm, beyond me (for right now), but for some potentially esoteric CT: http://www.math.harvard.edu/~lurie/  Anyone familiar with his work?
11:43:38 <nshepperd> if Seq.map doesn't exist, ghc needs to invent it
11:44:34 <Cale> nshepperd: Seq is an instance of Functor
11:44:36 <augur_> nshepperd: mm yes i see. thats a good point
11:44:53 <augur_> nshepperd: i would say then: generalized newtype deriving is a bad idea :)
11:44:55 <nshepperd> well, that's not so bad, because you can DeriveFunctor for arbitrary datatypes using representable functors
11:45:41 <augur_> i dont like the idea of relying on the compiler to discover these sorts of things, tbh
11:45:53 <nshepperd> so ghc can in fact invent a Functor instance for Seq
11:46:07 <nshepperd> heh
11:46:36 <nshepperd> well, I think the roles system is a mostly reasonable way of fixing this
11:46:50 <augur_> i wonder if this could be improved with proper modularity
11:47:05 <augur_> like.. the purpose of newtype is to permit representation sharing
11:47:08 <nshepperd> The only thing that stops this from working is type families iirc, just because they allow pattern matching on types
11:47:15 <Cale> QF-MichaelK: I've been meaning to read his book on higher topos theory
11:48:34 <augur_> so like, what you do is, if you want to define  Age = Int, you define a module for it, where internally, Age is literally = Int
11:48:54 <augur_> and internally you do your deriving so that its trivially an identity
11:48:57 <nshepperd> so you can look at a type definition, check whether it involves type families, if not it's fine, and you can trust that a functor instance could be invented
11:49:02 <augur_> but you dont export the equality
11:49:45 <augur_> and if you want to define instances, etc. it has to be inside the Age module
11:50:10 <augur_> tho there might be some use to like.. opening modules locally, to let you extend them? dunno
11:50:40 * hackagebot cql 3.0.1 - Cassandra CQL binary protocol.  http://hackage.haskell.org/package/cql-3.0.1 (ToralfWittner)
11:50:42 * hackagebot cql-io 0.9.6 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.9.6 (ToralfWittner)
11:51:07 <augur_> tho that will have issues with type families, so better not. you can only use generalized newtype deriving inside defining modules, hows that
11:52:00 <QF-MichaelK> Cale: Well, now you have it.  It's linked on his page.  I was talking about automated theorem proving and the structure of human knowledge with my professor.  You seem to know CT pretty well, would you start with his stuff or perhaps something simpler like the CT equivalent of lyah?
11:52:23 <augur_> i dont know.. hmm. this is an interesting issue
11:52:37 <Cale> QF-MichaelK: That stuff is not for beginners
11:52:55 <Cale> QF-MichaelK: I would recommend starting with Awodey's textbook "Category Theory"
11:54:11 <QF-MichaelK> Alright, I had some other suggestions last night too, I really better get cracking before I ask any more questions.  Thank you.
11:55:39 <vanila> Hi
11:55:48 <nshepperd> I think making ghc actually construct the mapping functions wouldn't be impossible
11:55:53 <vanila> Is there a haskell papers study club
11:56:10 <vanila>  read papers in a group and discuss?
11:56:28 <boxmein> vanila: that sounds kinda specific
11:57:03 <vanila> boxmein, what do you mean ?
11:57:49 <boxmein> vanila: as in, sure you can do reading/discussion online, but I don't think there's a dedicated group of people who congregate for the sole purpose of paper dissection
11:58:08 <vanila> oh :(
11:58:41 <nshepperd> it needs to invent a function (Iso a b) -> F a x y z -> F b x y z for the parameter that is being newtype'd
11:59:06 <rgr> how do I interactively  query the list of Type Classes an instance/variable implements/can implement?
11:59:07 <sivteck> vanila, yes there is one <http://www.meetup.com/Papers-we-love-Bangalore/>
11:59:58 <Thule> Can one of you guys tell me why this (filter (/= EQ)) . (zipWith compare) xs ys? (xs and ys are lists of Ord type)
12:00:06 <vanila> Interestig sivteck
12:00:07 <Thule> fails
12:00:37 <nshepperd> I think this works for all the basic algebraic data types, and (->), while failing for type families, which is what you want
12:01:31 <sm> xb#dar
12:01:34 <isocliff> I have a possibly dumb question
12:02:01 <isocliff> Im used to just "cabal install"ing stuff. What should I do when I apparently have to edit a .cabal file for some package?
12:03:03 <crobbins> isocliff: why do you need to edit a .cabal file?
12:03:23 <sivteck> isocliff, cabal unpack <package>
12:03:28 <isocliff> because of #1 : http://www.haskell.org/haskellwiki/Cabal/FAQ
12:04:41 <recursion-ninja> If I have a function f :: a -> b -> b, where f uses parameter a to modify & return b, and then I also have [a] and b, how whould I write a function g :: [a] -> b -> b, where g uses f to successively modify b, via the list of a parameters (in order)? O have a suspicion I need to use monadic properties of lists, but I'm not sure how...
12:04:42 <crobbins> isocliff: oh, you just need to add that package to the build-depends in the cabal file
12:05:45 <isocliff> where do i find this cabal file? I assume you mean a .cabal file for the package....
12:06:06 <recursion-ninja> Hold on,... I think I can just use a foldr...
12:06:24 <isocliff> Ive never encountered these when actually installing anything. I dont even see it in the tarball I DLed
12:06:34 <recursion-ninja> yep foldr will siffice, nevermind...
12:08:00 <crobbins> recursion-ninja: it almost sounds like you are after iterate
12:08:02 <crobbins> :t iterate
12:08:03 <lambdabot> (a -> a) -> a -> [a]
12:08:27 <isocliff> crobbins, what Im trying to figure out is what file I have to edit
12:08:30 <crobbins> oh nvm, thinking backwards apparently
12:08:41 <crobbins> isocliff: it should be the file that ends with .cabal
12:08:52 <isocliff> right, where would that be
12:08:55 <crobbins> should be in the root of your project dir
12:09:02 <crobbins> could be somewhere else though
12:09:06 <crobbins> are you modifying the source?
12:09:32 <isocliff> I have a .cabal-sandbox ...
12:09:35 <Thule> Sorry.. disconnected.. Can any of you tell me why ((filter (/= EQ)) . (zipWith compare)) does not work and gives this error: http://lpaste.net/113092?
12:09:36 <isocliff> no
12:10:00 <isocliff> Ive pretty much only ever installed by "cabal install"ing. Ive hardly ever seen a .cabal file
12:10:59 <sivteck> isocliff, cabal unpack <package> -> go to the folder created -> edit .cabal file -> cabal sandbox init -> cabal install
12:10:59 <crobbins> isocliff: where did you get this tarball?
12:11:30 <clrnd> Thule, EQ is a type ...
12:11:31 <monochrom> @type zipWith compare
12:11:32 <lambdabot> Ord b => [b] -> [b] -> [Ordering]
12:12:07 <Thule> yes, and the zipWith should give me a list of EQ types right?
12:12:12 <crobbins> isocliff: yep sivteck is right, although i wonder why you would be getting that dependency issue for an external package
12:12:18 <isocliff> okay I found it by what sivteck said, thanks
12:12:20 <monochrom> @type filter (/= EQ)
12:12:21 <lambdabot> [Ordering] -> [Ordering]
12:12:36 <Thule> e.g. zipWith compare [1,2] [3,4] = [LT, LT]
12:13:04 <isocliff> Im trying to install lambdabot. I guess according to the FAQ it hasn't been updated properly? or else its just some other error...
12:13:33 <monochrom> when you write "f . zipWith compare", you require f to have type "([b] -> [Ordering]) -> ???". however, filter (/= EQ) cannot meet that requirement.
12:13:41 <isocliff> but anyway youve answered my most proximate question. Thanks sivteck and crobbins
12:13:52 <crobbins> good luck!
12:14:02 <dbushenko> hi all!
12:14:03 <isocliff> thanks! have a good one
12:14:12 <dbushenko> I'm trying to defin a data type which accepts function
12:14:13 <dbushenko> data My (t -> (t, t)) = MyConstr (t -> (t, t))
12:14:20 <dbushenko> its wrong
12:14:25 <dbushenko> how to do it correctly?
12:14:39 <Thule> monochrom isn't f. (zipWith compare) $ xs ys = f(zipwith compare xs ys)??
12:15:02 <monochrom> is it? does the computer agree?
12:15:27 <monochrom> don't use intuition. use laws.
12:15:35 <saep> dbushenko: You only define the type variables on the left of the equals sign. So it should be `data My t = ...`
12:15:37 <Thule> no, but I do not understand why.
12:16:05 <dbushenko> saep: thanks!
12:16:32 <monochrom> you made some wrong assumptions about . and $
12:17:22 <monochrom> when you write "f . g", and if g has type A->B, then f is required to have type B->???
12:17:36 <monochrom> today, A = [b], B = [b] -> [Ordering].
12:18:38 <monochrom> this explains why "filter (/=EQ) . zipWith compare" is illegal. since it is illegal, we need to go on to talk about filter (/=EQ) . (zipWith compare) $ xs ys
12:18:54 <monochrom> err, we need not to go on to talk about filter (/=EQ) . (zipWith compare) $ xs ys
12:19:11 <monochrom> there is very little gain to talk about the meaning of illegal code.
12:19:13 <Thule> Yes but what I do not understand is that zipWith compare returns [ordering] and filter takes [ordering]->[ordering]
12:19:13 <tiqs> is there any research the mathematics of GUIs area?
12:19:34 <monochrom> no, you are working with wrong intuition
12:19:50 <Thule> like your example f . g, g has type [b] -> [b] -> [Ordering] and therefore f must have [Ordering] -> ??
12:19:57 <zwer> :t zipWith compare
12:19:58 <lambdabot> Ord b => [b] -> [b] -> [Ordering]
12:20:00 <monochrom> for the purpose of using ".", if g::A->B, then g "returns B".
12:20:08 <recursion-ninja> tiqs: Cartesian coordinates are used often in GUIs
12:20:10 <monochrom> but today B = [b] -> [Ordering]
12:20:34 <tiqs> recursion-ninja: ...
12:20:41 <monochrom> so today, for the purpose of using ".", not the purpose of using intuition, zipWith compare returns [b]->[Ordering], not [Ordering] alone
12:21:02 <vanila> why not start a haskell papers reading club?
12:21:10 <Thule> ahh...
12:21:16 <Thule> thank you monochrom
12:21:19 <mauris> hey, i was thinking about the "algebra" of datatypes and their cardinality -- the way Either A B has |A|+|B| elements, (A, B) has |A||B| elements, etc.
12:21:19 <recursion-ninja> tiqs: If you include graphics in GUIs then yes, there's a lot of reasearch
12:21:36 <monochrom> I am fine with colloquially, "it returns [Ordering]". but when using ".", you can't work colloquially.
12:21:49 <mauris> is there a way to perform this kind of calculation for parametric types with "forall" in them?
12:21:49 <recursion-ninja> tiqs: Aside from the graphics realm, I'm not sure
12:21:54 <silver> tiqs, what do you mean by mathematics of GUIs?
12:22:21 <Thule> I think I got it now.. Is there any good way to combine those into a simple function using ., so I can use curring, or is it just impossible?
12:22:39 <mauris> where e.g. (forall r. r -> r) will have 1 element (as it's inhabited only by id)?
12:22:46 <tiqs> particularly anything on datastructures for representing GUIs, verification of GUIs, GUIs as functors and stuff like that
12:22:50 <monochrom> there is a ".:" for that
12:22:54 <monochrom> @type (.:)
12:22:55 <lambdabot>     Not in scope: ‘.:’
12:22:55 <lambdabot>     Perhaps you meant one of these:
12:22:55 <lambdabot>       ‘.’ (imported from Data.Function),
12:23:05 <monochrom> but not on lambdabot
12:23:18 <monochrom> another thing you could do is uncurrying
12:23:38 <monochrom> @type filter (/=EQ) . uncurry (zipWith compare)
12:23:39 <lambdabot> Ord b => ([b], [b]) -> [Ordering]
12:23:52 <mauris> (admittedly this question isn't very "honest", because i know a way: it is isomorphic to (forall r. (() -> r) -> Identity r) and then Identity () = 1 by yoneda, but i'm looking for another way)
12:24:08 <monochrom> this requires you to use it like filter (/=EQ) . uncurry (zipWith compare) $ (xs, ys)
12:24:30 <Thule> okay. Thank you very much monochrom. Learned a lot by that, had trouble with it plenty of times.
12:24:41 <zwer> :t (filter (EQ /=) .) . zipWith compare
12:24:42 <lambdabot> Ord b => [b] -> [b] -> [Ordering]
12:24:53 <ParahSailin_> is there any way to have haddock document top level values generated in TH
12:25:24 <ParahSailin_> CPP hacks?
12:28:07 <joshc> what use is having a [Ordering] anyway, if it doesn't really have a mapping to which elements are equal?  if you're looking for the _number_ of equal items pairwise, I suspect there's an implementation that doesn't need the intermediate [Ordering]
12:28:49 * joshc attempts to remove his optimizer hat, but it won't come off
12:29:29 <Thule> I have only getting the head joshc. It is for comparing 2 lists
12:29:46 <Thule> if the list is not [] I get the head
12:29:54 <Cale> You know you can compare two lists directly, right?
12:30:08 <Cale> > [1,2,3,6] < [1,2,4]
12:30:10 <lambdabot>  True
12:30:23 <Thule> Cale ye, but it is a school exercise
12:30:37 <monochrom> the other day we used [Ordering] for lexicalgraphical comparison
12:30:47 <Thule> exactly monochrom!
12:31:10 <Thule> that is what I am doing as well
12:31:32 <monochrom> we always used the monoid-ness of Ordering
12:32:57 <Cale> compareLists [] [] = EQ; compareLists [] ys = LT; compareLists xs [] = GT; compareLists (x:xs) (y:ys) = compare x y <> compareLists xs ys
12:33:11 <merijn> joshc: The reason to get an [Ordering] is to just mconcat to collapse it using the Monoid instance
12:33:22 <nshepperd> Ordering has a Monoid instance?
12:33:26 <Cale> yes
12:33:27 <monochrom> s/always/also/
12:33:27 <merijn> nshepperd: Of course
12:33:31 <merijn> > LT <> EQ
12:33:33 <lambdabot>  LT
12:33:40 <merijn> > EQ <> LT
12:33:42 <lambdabot>  LT
12:33:45 <merijn> > EQ <> GT
12:33:46 <lambdabot>  GT
12:34:03 <Cale> > sortBy (comparing length <> compare) (words "here are some words to sort by length and then alphabetically")
12:34:05 <lambdabot>  ["by","to","and","are","here","some","sort","then","words","length","alphabe...
12:34:05 <nshepperd> oh, it's the lexical ordering of the two things
12:34:24 <isocliff> Ive gotten another error message any idea what might be done about this one?
12:34:32 <merijn> Oh, and functions alwso have monoid instances :p
12:34:34 <isocliff> "Type constructor ‘LB’ has conflicting definitions in the module and its hs-boot file"
12:34:46 <merijn> isocliff: The definitions are not identical?
12:34:51 <Cale> isocliff: Well, check that the definitions are the same!
12:34:55 <nshepperd> :t (<> compare)
12:34:56 <lambdabot> Ord a => (a -> a -> Ordering) -> a -> a -> Ordering
12:35:00 <nshepperd> :O
12:35:06 <merijn> nshepperd: You probably want
12:35:11 <zwer> :t compare length
12:35:12 <lambdabot> Ord ([a] -> Int) => ([a] -> Int) -> Ordering
12:35:15 <merijn> :t (<>) `asAppliedTo` compare
12:35:16 <lambdabot> Ord a => (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
12:35:27 <Cale> :t comparing length
12:35:28 <lambdabot> [a] -> [a] -> Ordering
12:35:34 <nshepperd> gack
12:35:34 <zwer> yeah typo
12:35:43 <nshepperd> :t asAppliedTo
12:35:44 <lambdabot> (a -> b) -> a -> a -> b
12:35:59 <merijn> nshepperd: asAppliedTo is "const" with a funny type
12:36:10 <sivteck> isocliff, this the lambdabot here
12:36:10 <sivteck> @version
12:36:10 <lambdabot> lambdabot 5.0-int-e
12:36:10 <lambdabot> git clone git://github.com/int-e/lambdabot.git
12:36:22 <nshepperd> hah
12:36:23 <merijn> nshepperd: "instance Monoid a => Monoid (b -> a)" :)
12:37:05 <RyanGlScott> What is the difference between NFData in deepseq and Forceable from Yampa?
12:37:24 <nshepperd> a monoid instance for functions... madness
12:37:41 <isocliff> I am indeed trying to install lambdabot ;)
12:37:59 <Cale> RyanGlScott: NFData is more widely used
12:38:22 <Cale> er
12:38:44 <Cale> Yeah, pretty much
12:39:10 <RyanGlScott> Hm, alright then.
12:39:13 <Cale> (I thought I saw something weird about the instances of Forceable, but I misread)
12:39:17 <isocliff> Still trying to find out about how the definitions....
12:39:23 <rafi> hi. could I write a GUI app that will compile also on Windows?
12:39:35 <Cale> RyanGlScott: Probably Forceable came first, Yampa is pretty old.
12:39:51 <zwer> rafi sure
12:40:21 <rafi> zwer: is there a notable library you would suggest looking into?
12:40:29 <RyanGlScott> Cale: It looks like the first release of Yampa was 2006 and deepseq was 2009, so you're right. Interesting.
12:40:36 <zwer> rafi probably gtk2hs
12:41:21 <sivteck> isocliff, look at this commit <https://github.com/int-e/lambdabot/commit/dc7ee36480a3e2b4e1b25d0022de72b764029bf7>
12:42:34 <isocliff> interesting. The cabal-tracked version doesn't have this fix for some reason?
12:43:29 <sivteck> the maintainer is MIA? idk
12:44:18 <dmj`> if my cabal file has a license type of "AllRightsReserved" do I need to include a license file? not really haskell related :|
12:44:30 <isocliff> ok well thanks a lot! maybe this will do the trick now...
12:45:13 <merijn> dmj`: Define "have to"
12:45:31 <merijn> dmj`: If it's AllRightsReserved and you don't specify a license, no one can legally use your package
12:46:13 <bjorkintosh> http://2.bp.blogspot.com/-nPo8up-CfXc/TmjmkzfY5NI/AAAAAAAAA2o/UD2OM-M1kDI/s1600/haskell.jpg
12:46:17 <dmj`> merijn: ok good, just didn't want to go through the pain of writing a custom license
12:46:24 <merijn> dmj`: So you don't have to, but it makes your package pretty useless
12:46:30 <merijn> dmj`: What's wrong with existing licenses?
12:47:03 <gabnex> rafi gtk haskell bindings work fine on windows. see this for some example code. http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
12:47:13 <merijn> bjorkintosh: What, you mean 'putStrLn ""'?
12:47:15 <dmj`> merijn: this is for a company
12:47:30 <bjorkintosh> merijn, suuuuure.
12:47:58 * merijn doesn't see how else you'd print a new line
12:48:16 <bjorkintosh> uhuh.
12:48:18 <rafi> thanks zwer gabnex
12:48:37 <gabnex> rafi you can also use Glade GUI builder instead of building the GUI programatically, then load the .glade file in haskell
12:48:56 <rafi> oh, great to know. that will ease it
12:50:23 <RyanGlScott> Is there a practical difference in declaring fundeps these two ways: class One a b c | a -> b -> c vs. class One a b c | a -> b c
12:51:01 <RyanGlScott> Er, class One a b c | a -> b, b -> c
12:54:23 <merijn> RyanGlScott: I don't think so?
12:55:01 <shanthakumar> @pl foldSpace x acc = bool (x:acc) (" " ++ [toLower x]++acc) (isUpper x)
12:55:01 <lambdabot> foldSpace = ap (flip . ap (ap . (bool .) . (:)) (((' ' :) .) . (++) . return . toLower)) isUpper
12:55:04 <RyanGlScott> merijn: Cool. I wasn't sure if there was some subtle difference that could arise somewhere.
12:55:24 <merijn> RyanGlScott: I personally prefer associated types over fundeps anyway
12:56:57 <CodeWeaverX> rafi, if you’re still here, wxHaskell (based on the wxWidgets common C/C++ library across quite a few platforms.
12:57:06 <CodeWeaverX> (another option)
12:57:31 <rafi> thanks
12:58:14 <zxcv> @pl \x -> f x && g x
12:58:14 <lambdabot> liftM2 (&&) f g
13:02:04 <RyanGlScott> Is there an extension that resolves ambiguities with typeclasses that only have one instance?
13:02:14 <RyanGlScott> e.g., class Only a where only :: a
13:02:18 <RyanGlScott> instance Only Int where only = 0
13:02:32 <RyanGlScott> only -- gives ambiguity error
13:02:53 <merijn> RyanGlScott: How's it supposed to figure out which instance you want?
13:03:04 <RyanGlScott> merijn: There's only one instance defined.
13:03:12 <merijn> RyanGlScott: Also, if you have only one instance, why do you have a class?
13:03:43 <RyanGlScott> merijn: I'm not using this in actual code or anything, I just want to know if it's possible.
13:03:47 <dmj`> merijn: what is the gamut of values for Stability? 'experimental' and what else?
13:03:51 <dmj`> in the cabal file
13:03:53 <merijn> RyanGlScott: Because instances are global, if you ever try to link your library with another library that has an instance of Only then it refuses to compile
13:03:59 <merijn> dmj`: Whatever you want
13:04:09 <merijn> My module lists "haha" as stability :p
13:04:19 <dmj`> merijn: ha cool, :P
13:04:36 <dmj`> Stability : Rock-Solid
13:04:47 <merijn> RyanGlScott: You're asking GHC to prove that "this code will never, ever be linked to any library that doesn't have any instances of Only"
13:04:55 <merijn> RyanGlScott: Which is obviously beyond what GHC can achieve
13:05:16 <merijn> eh
13:05:26 <merijn> s/doesn't have/has
13:06:49 <sdx23> what is the state of the art database library? i read something about rwh being outdated in this regard.
13:07:49 <zipper> Hey how can I get a string like "we" to give ['w','e']
13:08:04 <exio4> > ['w', 'e']
13:08:13 <lambdabot>  "we"
13:08:13 <zipper> I've tried so many things and all I get is a string because show of that is well a string
13:08:16 <merijn> zipper: THose two things are identical
13:08:18 <dmj`> zipper: String == [Char], its the same
13:08:27 <dmj`> zipper: do you just want to print it as such?
13:08:32 <zipper> merijn: but the question wants that one
13:08:36 <merijn> > "we" == ['w', 'e']
13:08:39 <lambdabot>  True
13:08:40 <zipper> dmj`: Yes
13:09:01 <zwer> > map show "we"
13:09:03 <lambdabot>  ["'w'","'e'"]
13:09:05 <merijn> Write your own show function?
13:09:11 <zwer> not quite but..
13:09:30 <zipper> zwer: I tried that map way
13:09:38 <zwer> > map (head . show) "we"
13:09:40 <lambdabot>  "''"
13:09:45 <zipper> Let me give the lik to the question
13:10:20 <gabnex> curiou why you want to print it like that
13:10:26 <zipper> http://www.seas.upenn.edu/~cis194/hw/04-poly.pdf Number 16
13:10:29 <gabnex> excercise?
13:10:38 <FireFly> > (intersperse ',' . map show) "we"
13:10:40 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Char’
13:10:40 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char
13:10:40 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Base.String
13:10:45 <FireFly> Hrm
13:10:47 <FireFly> @ty intersperse
13:10:48 <lambdabot> a -> [a] -> [a]
13:10:55 <zipper> Yes look at the link
13:11:09 <FireFly> > (intercalate ',' . map show) "we"
13:11:10 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
13:11:11 <lambdabot>              with actual type ‘GHC.Types.Char’
13:11:18 <exio4> you get a list of strings
13:11:23 <FireFly> Oh, right
13:11:42 <exio4> > (concat . intercalate "," . map show) "we"
13:11:44 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
13:11:44 <lambdabot>  Expected type: [[a]]
13:11:44 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
13:11:44 <lambdabot>  Expected type: GHC.Types.Char -> [[a]]
13:11:44 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Base.String
13:11:52 <exio4> ahg, whatever ;P
13:11:55 <FireFly> > (intercalate "," . map show) "we"
13:11:56 <lambdabot>  "'w','e'"
13:12:06 <FireFly> And then prefix and suffix '[' ']'
13:12:55 <dmj`> let f xs = putChar '[' >> mapM_ (\x -> do putChar '\'';  putChar x; putChar '\'') xs >> putChar ']'
13:12:58 <zipper> I'll assume the instructor was crazy and move on
13:13:04 <dmj`> zipper: ^
13:13:13 <dmj`> putChar is your friend
13:13:15 <SwashBuckla> is there a way of getting cabal install to use a certain version of a package? e.g. io-streams wants text==1.1.0.0 but I also have 1.2.0.0. How do I install io-streams constraining use of only text 1.1.0.0
13:13:21 <gabnex> > ((\c -> "["++c++"]") . intercalate "," . map show) "we"
13:13:22 <lambdabot>  "['w','e']"
13:13:48 <dmj`> SwashBuckle: you could live on the wild side and do cabal --allow-newer, or whatever that extension is to bypass upper bounds
13:14:05 <SwashBuckla> ?
13:14:26 <merijn> SwashBuckla: --constraint="text-1.1.0.0", I think?
13:14:33 <merijn> Or something with that flag anyway
13:14:33 <gabnex> another, more convulted and funny way, data Char = Char Char. then write show instance for Char
13:14:43 <merijn> dmj`: That's the opposite what he wanted
13:14:51 <gabnex> then: map Char "we"
13:15:21 <sinelaw> > :t p[
13:15:23 <sinelaw> :t []
13:15:28 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:15:28 <lambdabot> [t]
13:15:51 <sinelaw> does lambdabot actually mean: forall t. [t] ?
13:16:11 <merijn> sinelaw: Yes, in haskell all unmentioned type variables have an implicit forall on the left
13:16:13 <gabnex> (you would want to name Char something else)
13:16:27 <RyanGlScott> This might be a weird question, but how are numeric literals "implemented" so that their type signature is Num a => a? e.g., does 1 call something like fromInteger (1 :: Integer)?
13:16:37 <geekosaur> yes
13:16:39 <johnw> RyanGlScott: pretty much
13:16:47 <merijn> sinelaw: i.e. "(a -> b) -> Maybe a -> Maybe b" is really "forall a b . (a -> b) -> Maybe a -> Maybe b"
13:17:14 <sinelaw> merijn, i see
13:17:16 <geekosaur> RyanGlScott, http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
13:17:22 <dmj`> merijn: it goes from "we" -> ['w','e'] thats what zipper wanted IIRC
13:17:25 <geekosaur> behavior specified by the haskell language standard
13:17:28 <SwashBuckla> thanks merijn :)
13:17:35 <dmj`> well, from String -> IO ()
13:17:37 <sinelaw> @djinn a -> [b]
13:17:38 <lambdabot> Error: Undefined type []
13:17:42 <sinelaw> bah
13:17:50 <RyanGlScott> geekosaur: Ah, thanks. I bet half of my questions would already be answered if I just RTFA... :\
13:19:12 <sinelaw> can I teach djinn types?
13:19:27 <merijn> RyanGlScott: It's a decent idea to read the Report
13:19:47 <merijn> RyanGlScott: It's very readable, ESPECIALLY when compared to other language standards (C/C++, I'm looking at you!)
13:20:00 <sinelaw> much better than Ruby
13:20:07 <merijn> Ruby has a standard?
13:20:11 <sinelaw> nope.
13:20:12 <sinelaw> :)
13:20:16 <merijn> I thought it was like python "whatever CPython happens to do"
13:20:22 <sinelaw> exactly.
13:20:35 <sinelaw> there actually is some "standard" but in the sense of  a document that costs money
13:20:42 <sinelaw> of an older version
13:21:32 <sinelaw> do @djinn a -> [b] should print: \_ -> [], right?
13:21:52 <sinelaw> *so
13:24:16 <sebastard> Hi, I have a question: I am trying to make some sort of infinite list but I'm not sure how:
13:24:42 <dmj`> [1..]
13:24:44 <sinelaw> > [1..]
13:24:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:25:16 <gabnex> > map (2^) it
13:25:17 <lambdabot>  Not in scope: ‘it’
13:25:18 <lambdabot>  Perhaps you meant one of these:
13:25:18 <lambdabot>    ‘id’ (imported from Data.Function),
13:25:18 <lambdabot>    ‘C.id’ (imported from Control.Category),
13:25:18 <lambdabot>    ‘i’ (imported from Debug.SimpleReflect)
13:25:29 <gabnex> no it? :/
13:25:57 <sebastard> something like: [] ++ [x|x<-[True,False]] ++ [[x,y]|x<-[True,False],y<-[True,False]] ++ [[x,y,z]|x<-[True,False],y<-[True,False],z<-[True,False]] ++ ...
13:25:58 <exio4> > (map (2*) . map (3*) . map (4*)) [1..]
13:26:00 <lambdabot>  [24,48,72,96,120,144,168,192,216,240,264,288,312,336,360,384,408,432,456,480...
13:26:01 <geekosaur> not in lambdabot
13:26:29 <merijn> sebastard: Needs more local definitions to simplify reading
13:26:52 <merijn> sebastard: What's the type of your list supposed to be?
13:27:00 <FireFly> Looks like a [Bool]
13:27:01 <sebastard> [[Bool]]
13:27:05 <FireFly> Hrm
13:27:08 <kadoban> sebastard: What is the actual result you're looking for? I'm not clear
13:27:29 <sebastard> ok, so it's like a binary representation of integers (i think)
13:27:39 <FireFly> > [] ++ [x|x<-[True,False]]
13:27:41 <lambdabot>  [True,False]
13:27:47 <sebastard> just all possible lists of binaries, of every possible length
13:27:47 <sinelaw> the first one is missing an [x]
13:27:49 <FireFly> oh
13:27:51 <FireFly> right
13:27:56 <FireFly> My bad.
13:28:52 <RyanGlScott> So there exists a very thorough rundown of all GHC extensions here: https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/ghc-language-features.html
13:28:59 <FireFly> I think the very first one should be [[]], too
13:29:01 <RyanGlScott> But is there a list of when each extension was added to GHC?
13:29:07 <FireFly> sebastard: I'd try to express it using iterate
13:29:38 <merijn> FireFly: No
13:29:46 <merijn> Well, maybe
13:30:00 <merijn> [] is correct, but not sure whether it's the intended behaviour, I guess
13:30:12 <isocliff> any ideas what could be done about this one? "Not in scope: data constructor ‘UnGuardedAlt’"
13:30:25 <FireFly> Well, there are 0 possible binary numbers of length 0
13:30:45 <FireFly> so I'd expect thelist !! 0 to be []  (per the explanation of what the list is supposed to represent)
13:31:10 <sebastard> yes, I agree, first one should be [], so that needs to be adjusted in my above description
13:31:27 * Maxdamantus wrote something that does that directly.
13:31:39 <Maxdamantus> allValues :: [[Bool]]
13:32:02 <sebastard> also, brackets around the first x: [[x]|x<-[True,False]]
13:33:12 <exio4> > let l = 1:[ x+1 | x ← l ] in take 5 l
13:33:14 <lambdabot>  [1,2,3,4,5]
13:33:33 <exio4> > let l = 1:map (+1) l in take 5 l
13:33:35 <lambdabot>  [1,2,3,4,5]
13:33:53 <nkar> how do I select all rows with esqueleto without specifying them in 'return'?
13:34:13 <merijn> > let binary = [] : binary >>= \bs -> [True:bs, False:bs] in binary -- I wonder if this works
13:34:15 <lambdabot>  [[True],[False],[True,True],[False,True],[True,False],[False,False],[True,Tr...
13:34:22 <merijn> \o/
13:34:42 <dmj`> merijn: cabal check still whines without a LICENSE file even when I put the LICENSE as AllRightsReserved
13:34:42 <sebastard> sweet :D
13:34:48 <merijn> I wonder where my empty start list went, though
13:35:36 <int-e> isocliff: use an older version of haskell-src-exts, 1.16 changed the ADT in a couple of ways (the guarded/unguarded distinction is now in 'Rhs')
13:36:34 <merijn> Actually
13:36:47 <merijn> bah, my machine is slow
13:36:54 <merijn> What's the fixity of : vs >>= ?
13:37:12 <merijn> > let binary = [] : (binary >>= \bs -> [False:bs, True:bs]) in binary
13:37:13 <lambdabot>  [[],[False],[True],[False,False],[True,False],[False,True],[True,True],[Fals...
13:37:17 <merijn> There we go
13:38:24 <merijn> dmj`: So put a file with "All Rights Reserved by Company Name" in a text file and call it a day?
13:38:26 <int-e> > iterate ([False ..]:) [] >>= sequence
13:38:27 <lambdabot>  [[],[False],[True],[False,False],[False,True],[True,False],[True,True],[Fals...
13:38:46 <int-e> (ah, that produces a different order)
13:38:50 <isocliff> int-e awesome, many many thanks. So I guess I'll try building specifying 1.15...
13:39:34 <dmj`> merijn: I guess
13:39:37 * dmj` mopes
13:40:40 <SwashBuckla> has anyone here used hsenv to install a different version of `base`?
13:40:53 <FireFly> Oh, right
13:41:14 <FireFly> > concat (iterate (concatMap (\xs -> [True:xs, False:xs])) [[]])
13:41:16 <lambdabot>  [[],[True],[False],[True,True],[False,True],[True,False],[False,False],[True...
13:41:16 <int-e> dmj`: well it is not useful to upload anything on hackage that people are not allowed to use.
13:42:08 <int-e> dmj`: and afaiu, 'cabal check' was introduced as a plausibility check before uploading to hackage.
13:42:18 <sebastard> wow I am gonna take all those solutions and study them until I get what is happening :P
13:42:25 <sebastard> thanks!
13:42:56 <dmj`> merijn, int-e: snaps license is allrightsreserved?
13:42:57 <dmj`> https://github.com/snapframework/snap/blob/master/LICENSE
13:43:02 <int-e> > [0..] >>= (`replicateM` [False ..])
13:43:04 <lambdabot>  [[],[False],[True],[False,False],[False,True],[True,False],[True,True],[Fals...
13:43:12 <kadoban> sebastard: If you mull over the monad instance for lists, it should eventually make sense
13:44:01 <WraithM> dmj`: That's BSD3
13:44:04 <pharpend> https://i.imgur.com/UoJGHOA.gif
13:44:15 <zipper> Ok code worked I didn't know why.
13:44:26 <pharpend> zipper: the dilemma of every programmer
13:44:27 <zipper> Now I know though. That was confusing.
13:44:27 <pharpend> oh
13:44:37 <pharpend> sorry about the gif, meant for a different channel
13:44:38 <zipper> pharpend: LMAO
13:44:47 <SwashBuckla> oh no wonder I can't cabal isntall a specific version of `base`. It's a special package
13:44:55 <zipper> pharpend: Yeah it was scray. I hate it when it works and I don't know why.
13:45:13 <dmj`> WraithM: then why doesn't it say bsd3?
13:45:13 <zipper> In large code bases I have no idea why code works.
13:45:18 <SwashBuckla> I need to install a different GHC. But where can I find which GHC pertains to which version of `base`?
13:45:24 <Evilsparza> I know you can invert the order of parameters with flip. is there a function hat can put an inner parameter to the end? like f a b c d = f b a c d
13:45:38 <int-e> dmj`: it does say BSD3 in the .cabal file.
13:45:50 <Hijiri> https://github.com/snapframework/snap/blob/master/snap.cabal#L26
13:45:59 <dmj`> oh... I guess the bsd3 license clause includes AllRightsReserved in it...
13:46:02 <dmj`> http://opensource.org/licenses/BSD-3-Clause
13:46:07 <SwashBuckla> zipper: ohh gosh. That's most days for me. I don't use haskell in my day job, I use VB.NET.
13:46:08 <thsig_> just curious, is "cabal hell" a thing, whereas rubygems etc. are relatively painless, because more eyeballs and work have gone into rubygems, or are there underlying design issues?
13:46:12 <merijn> dmj`: You need to read up on copyright
13:46:22 <dmj`> merijn: or I could just ask you
13:46:22 <int-e> dmj`: "All rights reserved" is legalese and part of the license text; the text then goes on to give you permission to actually deal with the code fairly freely.
13:46:22 <merijn> dmj`: I don't know what kinda answer you're expecting here...
13:46:29 <SwashBuckla> thsig_: use hsenv!
13:46:47 <geekosaur> thsig_, ghc has a number of issues with its library management. cabal is between a rock and a hard place because it can't fix ghc
13:46:56 <merijn> The license reserves all rights (which is the default and thus redundant) and proceeds to explicitly enumerate the rights you have
13:46:58 <levi> Evilsparza: You can always reorder parameters with a lambda; it's probably more readable than trying to use some unusual combinators.
13:47:01 <SwashBuckla> thsig_: there is also easy_install hell, etc.
13:47:06 <SwashBuckla> (for python)
13:47:13 <kadoban> Evilsparza: Isn't that just flip?
13:47:18 <merijn> thsig_: There's two issues
13:47:20 <thsig_> SwashBuckla: Will look into it! Haven't actually had trouble with cabal yet (I'm starting out), just surprises me that this sort of thing isn't 100% awesome and shiny and correct given the nature of Haskell and the community in general.
13:47:26 <geekosaur> and ghc is hard to fix because it wants to do cross-module optimization and pretty much any solution other than recompiling everything all at once (whole-program compilation) causes major pain
13:47:28 <merijn> thsig_: 1) number of eyeballs (an important one!
13:47:36 <dmj`> merijn: thanks
13:47:53 <WraithM> dmj`: What are you trying to do, license wise? Like, BSD3 is usually fine.
13:47:56 <merijn> thsig_: 2) ruby gems/python/javascript silently hiding errors
13:48:02 <geekosaur> (and without cross-module optimization, things are veeeerrrrryyyyyyyyy ssssllllloooooooowwwwwwwwwww)
13:48:40 <juanpablo_> Anyone knows why Hugs is no longer maintained?
13:48:47 <merijn> thsig_: Because of lack of typechecking you can combine incompatible versions and never notice because you don't use the incompatible bits, never triggering an exception
13:48:58 <SwashBuckla> where can I find GHC-to-base mappings?
13:49:14 <SwashBuckla> e.g. base-4.7 is in GHC 7.8
13:49:15 <merijn> thsig_: Unless a function has disappeared or change in arity, how would you even notice a change in ruby/python/js?
13:49:18 <dmj`> WraithM: I need to create a file that mentions the licenses of all libraries I'm using, and a license that restricts usage to only employees
13:49:21 <levi> juanpablo_: Its maintainers moved on to other things and no one wanted to take up the task, I imagine.
13:49:22 <thsig_> merjin: True. I've definitely run into this kind of thing more than once in my ruby projects.
13:49:34 <kadoban> juanpablo_: Probably same reason anything else goes unmaintained, lack of interested available developer (or other) effort
13:49:59 <merijn> thsig_: People need to set conservative upperbounds to avoid getting a "dependency solution" that then fails to compile due to type error
13:50:19 <merijn> thsig_: Conservative upper bounds need lots of manual intervention to keep updated as packages come out
13:50:32 <levi> juanpablo_: GHC + GHCi got good/fast/available enough and catching Hugs up now would be a pretty big effort. It's a very old program now.
13:50:37 <merijn> thsig_: (There's some plans for tools to to automatically test/relax bounds)
13:51:56 <juanpablo_> Damn. I still wish I could somehow run interpreted Haskell
13:52:04 <int-e> juanpablo_: ghci
13:52:10 <clang-> I'm having a hard time understanding functions as applicatives. Is it important to understand this?
13:52:14 <clang-> It's weird.
13:52:18 <clang-> in LYAH.
13:52:39 <merijn> thsig_: So the main reason for most problems nowadays stem from: GHC aggressive cross-module optimisation potentially exposes recursive dependencies, static checking requires more conservative bounds, updating bounds is manual work and (currently) GHC doesn't support linking multiple different versions of the same package into the same binary
13:52:40 <levi> clang-: What in particular are you having a hard time with?
13:53:03 <thsig_> merjin: Aha, thanks - good answer!
13:53:30 <Cale> clang-: Well, the key is just to look at the types, and use the fact that f a = e -> a
13:53:42 <thsig_> merjin: Automatic bounds testing sounds like a good idea / work saver for library authors. Almost like an additional set of integration tests.
13:53:54 <Cale> clang-: So you have pure :: a -> f a, which becomes pure :: a -> (e -> a)
13:54:00 <Cale> There's not many functions of that type :)
13:54:09 <Cale> you can probably guess the implementation
13:54:09 <merijn> thsig_: I think cabal problems are about 50% "things we don't know how to automatically do" and 50% "things that are actually wrong", but since the latter 50% often works in other package managers (due to them silently sweeping problems under the rug) cabal appears to fail more often than other package managers
13:54:53 <Cale> and then you have (<*>) :: f (a -> b) -> f a -> f b
13:54:54 <levi> thsig_: Also, people tend to write small single-purpose packages and others tend to rely on them. This is a great thing in many ways, but it adds maintenance overhead.
13:55:10 <Cale> which is to say, (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
13:55:12 <clang-> levi: this: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
13:55:13 <clang-> Search for "They are rarely used". That will get you there.
13:55:18 <rai> clang-: which chapter are you at?
13:55:26 <Cale> This is a little more involved, but if you think about what you're given, the code will write itself :)
13:55:36 <thsig_> merjin: I see. For a lazy language, Haskell sure does take the strict (versus the lazy, "fail hard at the last possible moment") approach to errors :). Which is good, I suppose.
13:55:39 <Cale> Let's do it:
13:55:40 <clang-> rai: chapter 11 in the paper version
13:55:43 <rai> ah i'm not there yet
13:55:54 <malllle> http://lpaste.net/3339788413573267456 -- Could not find module ‘Text.ParserCombinators.Parsec.Number’ although installed
13:56:04 <Cale> clang-: following?
13:56:09 <merijn> thsig_: If you want the python experience you can always enable -fdefer-type-errors :p
13:56:17 <thsig_> hehe
13:56:19 <clang-> Cale: are we talking about the same thing?
13:56:30 <clang-> The instance Applicative ((->) r) where
13:56:37 <Cale> yes
13:56:43 <Cale> Though I'm using e instead of r
13:56:47 <Cale> But same thing :)
13:57:50 <Cale> So, let's write <*>
13:58:20 <Cale> We know that we want f <*> g :: e -> b, where f :: e -> a -> b, and g :: e -> a
13:58:34 <Cale> Since we know the result is a function, it might as well be a lambda:
13:58:41 <Cale> f <*> g = \x -> ...
13:59:05 <Cale> and then we have x :: e, and we're trying to get some value of type b to be the body of the lambda
13:59:13 <thsig_> levi_: I guess this partly comes back to the fact that in ruby and python, people usually lean very heavily on the standard library. Maybe efforts at creating a standardised core set of "blessed" libraries that work nicely will solve a majority of these headaches. Might become less of a problem over time with things like Stackage (not that I have first-hand experience of it).
13:59:20 <Cale> Well, the only way we have to get a value of type b is to apply f to some arguments
13:59:31 <Cale> f <*> g = \x -> f ... ...
13:59:52 <merijn> thsig_: Things are pretty stable, if you don't try to use the bleeding edge of the core/platform libraries
13:59:53 <Cale> f :: e -> a -> b, so the first argument to f needs to have type e
14:00:02 <merijn> But that means missing out on new features, etc.
14:00:06 <Cale> We have something of type e, namely x, so let's use that:
14:00:09 <Cale> f <*> g = \x -> f x ...
14:00:24 <clang-> Cale: yes we can all work out the math, but... here's the thing.
14:00:36 <Cale> and now the second argument to f needs to be of type a, the only way we have to produce a value of type a is to use g
14:00:40 <Cale> f <*> g = \x -> f x (g ...)
14:00:53 <Cale> and g needs to also be applied to something of type e, so let's use x again
14:00:55 <Cale> f <*> g = \x -> f x (g x)
14:00:58 * hackagebot network-carbon 1.0.2 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  http://hackage.haskell.org/package/network-carbon-1.0.2 (OliverCharles)
14:01:19 <clang-> Cale: do you find it easy to just look at an expression like this at a glance
14:01:19 <clang-> (+) <$> (+3) <*> (*100)
14:01:20 <clang-> and immediately see what it does? I find myself having to work out the math on a paper to decrypt this line. Do you?
14:01:25 <clang-> so i'm asking about practical applications
14:01:49 <clang-> i can see it after a few minutes working out the math
14:01:57 <Cale> Well, that's the function which given some x, will add the results of adding 3 to x, and multiplying x by 100
14:01:58 <clang-> but reading it doesn't immediately make any sense
14:01:59 <exio4> I think it is! \x → (x+3) + (x*100)
14:02:18 <exio4> > ((+) <$> (+3) <*> (*100)) 2
14:02:20 <lambdabot>  205
14:02:24 <merijn> clang-: It gets easier, but I need a second to look at what that does
14:02:28 <exio4> > (\x → (x+3) + (x*100)) 2
14:02:29 <lambdabot>  205
14:02:41 <Cale> This is perhaps easier to understand once you already know about the Monad instance for ((->) e)
14:02:50 <merijn> clang-: It's more interesting in the case of, for example "sequence"
14:03:02 <thsig_> merjin: Ok, good to know!  Thanks for the explanations! :)
14:03:10 <merijn> :t sequence `asAppliedTo` (undefined :: [a -> b])
14:03:11 <lambdabot> [a -> b] -> a -> [b]
14:03:13 <clang-> hmo k
14:03:40 <merijn> Well, I guess sequenceA if we wanna stay applicative?
14:03:45 <merijn> :t sequenceA
14:03:46 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:03:53 <merijn> :t sequenceA `asAppliedTo` (undefined :: [a -> b])
14:03:54 <lambdabot> [a -> b] -> a -> [b]
14:04:45 <clang-> Another example provided by LYAH is: (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
14:04:58 <kadoban> :t asAppliedTo
14:05:00 <lambdabot> (a -> b) -> a -> a -> b
14:05:31 <kadoban> Oh, I see
14:05:33 <clang-> So can I form a rule of thumb that says this?
14:05:34 <clang-> Rule of thumb: A function applied to functions, simply means plugging the latter functions into the first function.
14:05:36 <clang-> Is this accurate?
14:05:49 <merijn> clang-: You can generalise even further
14:05:54 <clang-> so the guy before <$> is the function that is plugged into
14:06:12 <merijn> clang-: No
14:06:13 <clang-> and the other guys separated bed <*> are the functions that get plugged into the first func
14:06:34 <merijn> Well, maybe, I dunno what you're trying to say exactly :p
14:06:34 <int-e> > sequence [(+3),(*2),(/2)] 5
14:06:36 <lambdabot>  [8.0,10.0,2.5]
14:06:50 <exio4> I got the (→ e) applicative/monad "better" when I made it explicit with lambdas at first
14:07:09 <int-e> @type sequenceA
14:07:11 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:07:12 <Cale> clang-: So, this will probably help, let's look at the *monad* instance
14:07:21 <casidiablo> Is there a way to write simple scripts in haskell? You know, like when you type #!/bin/sh at the beginning of the file and it will execute it using sh
14:07:34 <Cale> > (do x <- id; y <- map toUpper; z <- reverse; return (x,y,z)) "hello"
14:07:36 <lambdabot>  ("hello","HELLO","olleh")
14:07:43 <crobbins> casidiablo: yep, #!/usr/bin/env runhaskell
14:07:49 <clang-> Cale: i'm not yet at monads in lyah
14:07:54 <Cale> ^^ keep this in mind, and we'll look at how the monad instance works, and then return to applicative
14:07:57 <casidiablo> crobbins: thanks, will take a look
14:08:02 <Cale> because the monad instance is easier to understand, I think
14:08:09 <nemo22> Quick question. I believe using an applicative can sometimes be faster than the monad instance of the same type. Can the reverse ever be true?
14:08:19 <Cale> and it makes the Applicative instance easy to understand once you know how it works
14:08:32 <nemo22> Could using a monad be faster than a applicative in any circumstances?
14:08:33 <Cale> Really, I don't think teaching Applicative before Monad makes any kind of sense
14:09:06 <qnikst> casidiablo: #!/usr/bin/runhaskell may help :)
14:09:28 <Cale> Sure, Applicative is theoretically "weaker" or "simpler" than Monad, but it's more subtle
14:10:08 <Cale> clang-: So, maybe just return to this once you've seen a bit about what Monad is and how it works
14:10:19 <clang-> Cale: good idea
14:10:21 <clang-> will do that
14:10:43 <monochrom> Cale: interesting thought. it may be true, articulating Applicative itself seems awkward
14:11:00 * hackagebot tasty-ant-xml 1.0.1 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.1 (OliverCharles)
14:11:05 <Cale> clang-: The gist of it is just that using the monad instance for functions, "running" a function means applying it to the argument that the whole function has been applied to
14:11:26 <monochrom> perhaps the <*> story is hard to articulate. how about the <**> story? f a -> f b -> f (a,b) IIRC
14:11:29 <Cale> clang-: So, the function monad gives you a way to distribute an "environment" argument to many subcomputations
14:11:36 <Cale> Like my example above
14:11:40 <Cale> > (do x <- id; y <- map toUpper; z <- reverse; return (x,y,z)) "hello"
14:11:41 <lambdabot>  ("hello","HELLO","olleh")
14:11:50 <Cale> Here, x = id "hello" = "hello"
14:11:59 <Cale> and y = map toUpper "hello" = "HELLO"
14:12:08 <Cale> and z = reverse "hello" = "olleh"
14:12:36 <qnikst> :t (***)
14:12:38 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:13:16 <Cale> and every Monad is an Applicative with pure = return, and  mf <*> mx = do f <- mf; x <- mx; return (f x)
14:14:14 <Cale> So in the case of the function monad, this will mean that we "run" both mf and mx, i.e. we apply them both to the argument of the overall function, and then we apply the resulting function to the resulting value.
14:14:26 <clang-> i may as well be reading chinese
14:14:27 <clang-> :D
14:14:29 <Cale> Which is exactly f <*> g = \x -> f x (g x)
14:15:01 <rai> happy to have this conversation in the logfiles once i hit the same wall
14:15:10 <Cale> all right, I can understand if you haven't seen do notation or anything before :)
14:15:56 <Cale> (I could probably explain all this, but I just wanted to get down the relevant bit which you can return to)
14:16:04 <Ouyang> is there a consensus for a sturdy reliable Distro for Haskell?  cabal and arch are making me cry
14:16:18 <sivteck> NixOS
14:16:30 <Cale> Ouyang: I just don't use my distribution's version of anything Haskell related
14:16:30 <Eduard_Munteanu> Debian seems to have lots of Haskell packages.
14:16:33 <Cale> It works well.
14:16:55 <Eduard_Munteanu> I just don't use cabal-install. :)
14:16:58 <Cale> Debian's Haskell packages are exactly why I stopped relying on my distribution for Haskell packages :P
14:17:00 <Ouyang> I mean is there a way for me to get into haskell without having everything break?
14:17:01 <kadoban> Ouyang: Don't use your distro facilities for haskell. In ubuntu I just install GHC and cabal manually and then go from there (using sandboxes for every project)
14:17:23 <Ouyang> I don't seem to have issues until I enter sandboxes
14:17:24 <Eduard_Munteanu> And won't use it until they implement some form of package signing.
14:18:08 <Ouyang> for example the scotty tutorial consisted of me spending two hours trying to get the proper base version, but it still wouldn't recognize it
14:18:20 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_3#x86linux -- get the appropriate binary package of GHC here
14:18:46 <Cale> http://hackage.haskell.org/package/cabal-install -> http://hackage.haskell.org/package/cabal-install-1.20.0.3/cabal-install-1.20.0.3.tar.gz
14:18:53 <Cale> and that's where you get cabal-install
14:19:12 <monochrom> Ouyang: arch should be the best, but if even arch fails your expectation, then it's time to just get GHC binary from GHC website.
14:19:31 <zyaku> d
14:19:32 <Ouyang> hmm I don't know if thats my issue
14:19:46 <Ouyang> I guess it's not an os based issue
14:19:49 <Ouyang> but a cabal issue
14:20:13 <Ouyang> I have to go figure out how to revert haskell on my machine as I broke it heavily
14:20:22 <merijn> Ouyang: "getting the proper base" <- what does that mean
14:20:27 <Cale> Ouyang: Did you install packages globally?
14:20:27 <merijn> You can't "get" base
14:20:30 <int-e> Ouyang: the base package is tied to the compiler.
14:20:52 <Ouyang> errr it would say it was rejecting base xxxx needs base xxxx
14:20:55 <Cale> We should really start using the same version number of base as ghc
14:21:01 <Ouyang> where it would reject the version it needed
14:21:05 <kadoban> Ouyang: I'd really skip it and follow Cale's advice. If it helps, https://gist.github.com/ion1/2815423 is how I install haskell every time...which is pretty much cale's links with a reminder of the commands used to install
14:21:36 <levi> I think NixOS, or managing haskell packages on your current OS via Nix, would give a pretty good Haskell experience as well.
14:21:37 <Cale> It's pretty silly that there's an arbitrary mapping between ghc versions and base versions, rather than just having ghc-7.8.3 come with base-7.8.3
14:21:39 <Ouyang> How do I go about resetting all the prexisting haskell-stuff on my computer? I'm sorry for all the questions
14:22:24 <Ouyang> Nixos seems overly complicated for me and with a lot less documentation.  With arch I can search "give user full permission" and find the answer on the wiki, while nixos gives me zil
14:22:24 <monochrom> Ouyang: I just tried "cabal install --dry-run scotty" and it doesn't have the error you're saying. so I conclude that your problem must be something else.
14:22:29 <kadoban> Ouyang: Depends on your package manager. You can wipe out ~/.ghc and/or ~/.cabal too, optionally, that may or may not be what you want (take backups if you're not sure what's in there)
14:22:36 <sivteck> Ouyang, nuke ~/.ghc and ~/.cabal
14:22:42 <Ouyang> monochrom: the scotty tutorial with the cabal file?
14:22:43 <Cale> Ouyang: That depends on how much you did to mess things up :)
14:22:54 <Cale> Ouyang: Did you install packages globally (as root)?
14:23:00 <monochrom> I have not read the scotty tutorial. I am only doing "cabal install --dry-run scotty"
14:23:11 <Ouyang> Cale: cabal packages or pacman packages?
14:23:16 <Cale> cabal packages
14:23:30 <Ouyang> errr some i believe out of frustration
14:23:30 <Cale> Ouyang: If not, then you can just delete ~/.ghc
14:23:42 <monochrom> Cale, I think it's safe to assume non-global because most people don't even know they have a choice :)
14:23:54 <Cale> You don't have to delete ~/.cabal (though tidying it up will save you a little hard drive space perhaps)
14:24:05 <Ouyang> sudo cabal install x would be what you are asking?
14:24:21 <monochrom> oh no, sudo cabal never does what you think
14:24:22 <Cale> You might want to be careful about blowing away ~/.cabal/bin and/or ~/.cabal/config
14:24:23 <Ouyang> i'd rather cleanly wipe out everything, i'm using xmonad doe so i feel like imma mess stuff up
14:24:58 <Cale> Yeah, don't bother deleting ~/.cabal then
14:25:24 <Ouyang> I mean xmonad is already broken, the xmonad command brings up a few errors
14:25:32 <Ouyang> but it still is somehow working
14:26:03 * hackagebot aeson-t 0.0.0 - Transform JSON  http://hackage.haskell.org/package/aeson-t-0.0.0 (begriffs)
14:27:04 <Ouyang> errr I have a .cabal-sandbox in my home directory, i assume I should delete that
14:27:56 <begriffs> I just uploaded a candidate package to hackage and I the docs aren't showing up. Is this something I have to wait for, or do I have to run a command to make them get generated?
14:28:54 <monochrom> wait a bit, yes
14:30:09 <monochrom> > let in True
14:30:11 <lambdabot>  True
14:30:50 <Cale> > do let in True
14:30:54 <lambdabot>  True
14:30:58 <joelteon> > let in theLight
14:30:59 <lambdabot>  Not in scope: ‘theLight’
14:31:00 <joelteon> damn it
14:32:51 <nemo22> Could using a monad instance of a type be faster than an applicative in any circumstances?
14:33:40 <kadoban> nemo22: Well, they technically don't have to be related at all afaik, so the relationship could be anything
14:33:49 <joelteon> the performance penalty depends on the function definition purely
14:33:52 <joelteon> types are erased at runtime
14:34:16 <gabnex> data Data = Foo Int | Bar Bool;  is there a built in get function (or a way to write one that will work with all the constructors?) get Foo should return Maybe Int, and get Bar should return Maybe Bool
14:34:29 <piskrist> gabnex: fst
14:34:58 <monochrom> no, fst doesn't do that. there is no built-in way.
14:35:04 <gabnex> fst works on pair
14:35:22 <gabnex> is it possible to write such a function?
14:35:26 <joelteon> sure
14:35:34 <joelteon> oh
14:35:37 <joelteon> oh, wait, no, I misread
14:35:37 <gabnex> without handling all the cases manually
14:35:40 <joelteon> no, that's not possible
14:35:48 <joelteon> how would you even check what value you were passed?
14:35:53 <joelteon> that doesn't typecheck
14:36:03 <piskrist> weird, I thought I used fst on data types
14:36:10 <Eduard_Munteanu> @hoogle cast
14:36:10 <joelteon> you used it on (,)
14:36:12 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
14:36:12 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
14:36:12 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
14:36:32 <Eduard_Munteanu> But no, that won't do.
14:37:08 <joelteon> get :: Int -> Data, and get also :: Bool -> Data
14:37:27 <nemo22> Sure they don't have to be related, but if they are defined such that <*> = ap and pure = return, semantically, but the implementations were different.
14:37:34 <gabnex> it doesn't have to be a function
14:37:37 <joelteon> then the faster implementation wins
14:37:38 <Eduard_Munteanu> lens has something like it
14:38:10 <gabnex> maybe it could be something like a lens?
14:38:33 <qnikst> gabnex: try to start with writing a type
14:39:11 <indiagreen> > get Foo should return Maybe Int, and get Bar should return Maybe Bool
14:39:11 <indiagreen> you can probably do so that “get Foo” (exactly as written) indeed returns “Maybe Int”
14:39:28 <gabnex> qnikst I can't think of a type that would typecheck
14:39:40 <qnikst> gabnex: this is the answer :)
14:39:56 <qnikst> you want smth that may be Bool and Int at the same type
14:40:00 <gabnex> qnikst but I couldn't think of a lens type either, so that is not saying much
14:40:15 <gabnex> at least not as implemented in the lens library
14:40:18 <qnikst> you can take Data.Dynamic, but I think it's not what you want
14:40:27 <joelteon> lens would use view _Foo and view _Bar
14:40:59 <Eduard_Munteanu> lens' has record accessors which can be overloaded by name.
14:41:05 * hackagebot conceit 0.2.1.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.2.1.0 (DanielDiazCarrete)
14:41:07 <qnikst> basically you want a function with a type that depends on a value
14:41:27 <qnikst> so you need more magick here
14:42:15 <gabnex> qnikst but the desired type is in the constructor. so how does it depend on a value?
14:42:35 <gabnex> type of the constructor is known at compile time
14:42:37 <qnikst> another approach is to use GADT: data FG where F : Int -> FG Int ; G : Bool -> FG Bool, then you can have get ::FG a -> Maybe a
14:42:40 <gabnex> :t Just
14:42:41 <lambdabot> a -> Maybe a
14:42:44 <Eduard_Munteanu> e.g. data Data = Foo { fooX :: Int } | Bar { barX :: Bool }    would get you a lens for 'x'
14:42:46 <qnikst> gabnex: really?
14:42:49 <gabnex> bad example
14:43:13 <qnikst> suppose I have function that returns Data
14:43:29 <qnikst> what is constuctor will be there?
14:43:48 <gabnex> qnikst in data Data = Foo Int | Bar Bool, type of Foo is Int -> Data. both are known at compile time
14:44:25 <qnikst> gabnex: testme :: Int -> Data, I want to call `get testme`
14:44:47 <Eduard_Munteanu> gabnex, what is your actual application for this?
14:44:53 <gabnex> with "get Foo" it is known at compile time that we want Data -> Int, no?
14:45:02 <gabnex> Data -> Maybe Int
14:45:23 <qnikst> gabnex: I gave an example how it's possible to implement above
14:45:35 <qnikst> in some cases - you know, but generally - no
14:45:40 <DTSCode> dont i get ghci when i install the ghc package?
14:46:11 <monochrom> whose ghc package?
14:46:20 <DTSCode> uhhh the arch one with pacman
14:46:26 <Eduard_Munteanu> Also, what if data Data = ... | Baz Int Int
14:46:27 <monochrom> then I don't know.
14:47:23 <hexagoxel> DTSCode: pacman -Ql ghc | grep ghci
14:47:34 <hexagoxel> DTSCode: or: yes, you get ghci
14:48:19 <DTSCode> wtf? i installed that and it keeps saying command not found
14:48:45 <DTSCode> wait never mind
14:51:26 <gabnex> I guess what I want is syntactic sugar..  magicalGet Foo data to desugar to \d -> case d of Foo x -> Just x; _ -> Nothing
14:51:34 <gabnex> can this be done in template haskell?
14:52:24 <merijn> That doesn't even need TH, I think
14:52:34 <merijn> Just Typeable?
14:53:03 <gabnex> I see?
14:53:13 <phaazon> god I feel stupid. I’ve already played with bound, but I can’t remembre how I’m supposed to implement (<*>) for an expression carrying a Scope :D
14:53:27 <phaazon> I know it’s simple with Monad, just use (>>>=)
14:53:27 <qnikst> :t cast
14:53:28 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
14:53:39 <qnikst> gabnex: ^^
14:53:58 <qnikst> ops, I'm wrong here :(
14:54:32 <dfeuer_> :t coerce
14:54:33 <lambdabot> (Contravariant f, Functor f) => f a -> f b
14:54:47 <dfeuer_> Bleh
14:55:04 <phaazon> I could use the Scope as a Functor, so I can lift (a -> b) into it. Since it carries a function (a -> b), fmap (\f -> fmap f e) should work, right?
14:55:09 <phaazon> it sounds ugly tho
14:55:37 <dfeuer_> Functors can be ugly?
14:55:38 <qnikst> gabnex: you can check derive package, smth like From
14:55:47 <qnikst> http://hackage.haskell.org/package/derive
14:55:59 <phaazon> dfeuer_: I recall it was simpler
14:56:07 <phaazon> no λ needed
14:56:11 <phaazon> I just don’t remember
14:56:36 <dfeuer_> phaazon: I took one glance at bound and threw up my hands.
14:57:11 <phaazon> ahah
14:57:14 <phaazon> I need it now
14:57:21 <phaazon> I’m building an abstract shader EDSL
14:57:24 <phaazon> for my engine
14:57:33 <phaazon> and everyone interested as well
14:58:12 <phaazon> the theory behind bound is not _that_ hard to get :)
14:58:26 <phaazon> m_freak explained me everything :)
14:58:31 <phaazon> with edwardk
14:58:53 <phaazon> I still don’t remember how to implement Applicative the proper way
14:58:54 <phaazon> :D
15:00:26 <phaazon> oh
15:00:33 <phaazon> I guess it’s just
15:00:45 <phaazon> Lam s <*> e = Lam (s >>= e)
15:00:59 <phaazon> well, no.
15:01:01 <phaazon> dammit :D
15:01:18 <phaazon> too much Guinness.
15:02:15 <phaazon> maybe… Lam s <*> e = Lam (s <*> pure e) ?
15:02:38 <phaazon> @pl a <*> pure b
15:02:38 <lambdabot> a <*> pure b
15:03:20 <phaazon> dammit, not that neither
15:03:27 <phaazon> I feel stupid.
15:03:53 <casidiablo> :quit
15:04:06 <casidiablo> Ups, wrong window.
15:07:29 <phaazon> yeah, ok, when I done it I used the monad instance
15:07:32 <phaazon> which makes no sense to me
15:07:46 <phaazon> since to be a monad, it needs to be an applicative (very soon)
15:10:31 <monochrom> that should be no hinderance. you know how Haskell allows mutual recursion, right? your Monad instance code can call Applicative methods, and your Applicate instance code can call Monad methods.
15:10:40 <dfeuer_> phaazon: you can surely fix that up now you know how to do it.
15:10:41 <monochrom> as long as you write both in the same file.
15:10:52 <monochrom> actually may even be different files
15:10:54 <gabnex> pure = return;  mf <*> mx = do f <- mf; x <- mx; return f x
15:10:55 <gabnex> right?
15:11:06 <monochrom> so, as long as you write both.
15:11:12 <dfeuer_> Yes, monochrom, but that is disgusting. Same file? Yuck!
15:11:28 <phaazon> monochrom: that sounds wrong to me
15:11:32 <gabnex> or easier, (<*>) = ap. :P
15:11:38 <phaazon> that sounds really wrong
15:11:45 <phaazon> since something can be an Applicative, but not a Monad
15:11:53 <merijn> phaazon: Sure
15:11:56 <phaazon> what you said implies that in order to implement the Applicative instance
15:12:03 <phaazon> a Monad instance should exist
15:12:07 <phaazon> that is sooo wrong
15:12:11 <monochrom> I am not talking about an arbitrary something. I am talking about very concretely your expression type.
15:12:11 <merijn> phaazon: What's the problem?
15:12:27 <phaazon> merijn: I had difficulties to implement Applicative for my HOAST
15:12:29 <phaazon> I’m using bound
15:12:51 <phaazon> I’d like to implement the Applicative instance without using Monad
15:13:00 <phaazon> otherwise it’s indeed tricky
15:13:06 <merijn> phaazon: So? Write "instance Applicative Foo where pure = return; x <*> y = x `ap` y", implement Monad and done?
15:13:51 <merijn> I don't see why you want to implement Applicative without Monad if you think it's difficult...
15:14:04 <kadoban> Yeah, I'm not really understanding the issue... you said you have/will have a monad instance anyway, right?
15:14:06 <phaazon> merijn: because I’d like to do it without Applicative
15:14:10 <merijn> What's the point of intentionally making life hard
15:14:18 <phaazon> kadoban: yeah… that’s not really my point
15:14:27 <kadoban> phaazon: I think I'm lost on the point then
15:14:36 <phaazon> imagine it can’t be a monad
15:14:46 <phaazon> that would mean it can’t be applicative
15:14:51 <phaazon> and that confuses me
15:14:54 <merijn> phaazon: Well, then you have to implement Applicative
15:15:01 <phaazon> merijn: how ?
15:15:07 <phaazon> that’s what I’m looking for
15:15:08 <MP2E> then you just hand implement Applicative instead of deriving it through Monad
15:15:09 <merijn> phaazon: By writing code?
15:15:15 <phaazon> I don’t want shortcuts here
15:15:16 <MP2E> if you're stuck, I recommend djinn
15:15:17 <kadoban> phaazon: Huh? You're trying to generalize something that doesn't make sense to. If it can't be a monad, then you write the applicative instance manually.
15:15:18 <int-e> phaazon: that's not true. but if it is a monad, the monad instance may well be the simplest way to implement <*>
15:15:45 <hexagoxel> > gmapQi 0 cast hexLeft :: Maybe Int -- gabnex: another ugly approach, using Data.Data.Data
15:15:46 <lambdabot>  Just 3
15:15:50 <phaazon> hey guys, I’m just being curious, I’m not looking for the “perfect and simplest way to do it”
15:16:14 <merijn> phaazon: If you don't wanna use monad, then write the functions by hand
15:16:25 <merijn> phaazon: What exactly are you expecting as answer?
15:16:29 <phaazon> merijn: well, I think I can’t
15:16:32 <kadoban> phaazon: If you have the monad, we're saying it's trivial to write the applicative...if you want to figure out exactly what it is, do the conversion yourself manually based on the monad. You're saying you have a monad and are confused how to write the applicative, we're saying..."this is the transformation"
15:16:33 <phaazon> merijn: how to deal with Scope
15:16:39 <merijn> "How do you implement Applicative?" "by writing the code"
15:16:41 <int-e> phaazon: I mean,  x <*> y = x >>= \f -> y >>= a -> return (f a), has *two* calls to bind (>>=), and there's no inherent reason why that should become simpler.
15:16:46 <Evilsparza> is there something to do something to a value until a condition is true while keeping an accumulator? much like simple recursion but I'm looking to create a one liner :)
15:17:08 <merijn> Evilsparza: Why are you trying to create a oneliner?
15:17:12 <phaazon> I have somethink like this
15:17:16 <monochrom> you had "Lam s <*> e = Lam (s >>= e)", and you now want to eliminate >>=. to do this, go back to your definition of >>=, inline it.
15:17:17 <hexagoxel> gabnex: but it admittedly works only if the types are distinct..
15:17:19 <merijn> Evilsparza: You can probably use fold, but everyone will hate you
15:17:22 <phaazon> E a = … | Lam (Scope () E a)
15:17:26 <phaazon> Lam s <*> e = ?
15:17:41 <phaazon> with Monad, it’s simple
15:17:52 <phaazon> without Monad…
15:18:04 <hexagoxel> :t gmapQi 0 cast
15:18:06 <lambdabot> (Typeable b, Data a) => a -> Maybe b
15:18:09 <merijn> phaazon: Without monad you copy your current >>= implementation and paste it in place where you use >>= now
15:18:17 <merijn> I really don't see what's so hard
15:18:20 <kadoban> Yes..that
15:18:36 <Evilsparza> merijn I thought about this but I don't want to manipulate a list, just an Integer. Right-Shift it while at the same time keeping an accumulator that adds the bits. until the value is 0
15:18:37 <monochrom> which is also what I just recently said
15:18:38 <phaazon> s >>= e is wrong
15:18:41 <phaazon> e is E a
15:18:45 <phaazon> not (a -> E b)
15:18:48 <dfeuer_> merijn: it sounds more like unfold to me!
15:18:50 <merijn> Evilsparza: Fix
15:19:06 <merijn> phaazon: Dude
15:19:07 <Evilsparza> merijn I'll have a look, thanks
15:19:11 <merijn> phaazon: >>= has code
15:19:13 <monochrom> ok, what is right then?
15:19:26 <monochrom> or should I shut up?
15:19:31 <merijn> phaazon: Copy that code in place of "s >>= e" and done
15:19:35 <phaazon> merijn: I don’t know whether I even need >>=
15:19:39 <phaazon> god
15:19:44 <phaazon> are you even listening to me
15:19:54 <merijn> phaazon: Yes, but you're not listening to what people are saying
15:20:01 <phaazon> 00:05 < phaazon> Lam s <*> e = Lam (s >>= e)
15:20:02 <phaazon> 00:05 < phaazon> well, no.
15:20:13 <phaazon> e :: E a
15:20:19 <phaazon> how could s >>= e even works.
15:20:31 <kadoban> phaazon: Can you pastebin your monad instance somewhere? Perhaps seeing it concretely will help you understand...
15:20:36 <monochrom> is it Lam (e >>= s)?
15:20:48 <indiagreen> gabnex: do you want something like this – http://lpaste.net/113112 – or this – http://lpaste.net/113114 ?
15:20:48 <phaazon> kadoban: no
15:20:57 <phaazon> because I don’t have this instance yet
15:20:58 <dfeuer_> phaazon: if you already have a monad instance, then younalready wrote that.
15:21:09 <dfeuer_> Ohhh
15:21:11 <kadoban> phaazon: ...I thought you said you already wrote it?
15:21:12 <phaazon> and I think you really don’t understand what I’m trying to do
15:21:15 <phaazon> no.
15:21:19 <phaazon> so I summup:
15:21:24 <MP2E> it'd help if you explained it more clearly
15:22:24 <phaazon> I KNOW how to implement Applicative using Monad, thank you to iterate that over and over. Then, I wanna know how to write Applicative WITHOUT Monad (without its code either) for the very specific case of Lam using Scope
15:22:32 <phaazon> this is JUST curiosity
15:22:43 <phaazon> if you keep going saying “just use monad”, I give up
15:23:48 <merijn> phaazon: How to write applicative is not a sensible question
15:23:55 <kadoban> phaazon: Are these standard types or something? Because I'm not seeing them...and without that I'm not sure how we should be able to tell
15:23:57 <merijn> phaazon: It depends on the applicative you're trying to implement
15:24:03 <MP2E> There are other Applicatives written by hand in Control.Applicative if you'd like to see a few examples
15:24:03 <gabnex> indiagreen the later, but without manually writing all the cases, for all the types
15:24:04 <phaazon> kadoban: Scope is
15:24:06 <phaazon> in bound
15:24:31 <phaazon> MP2E: I think I always write my Applicative instances by hand
15:24:40 <phaazon> I feel that really disturbing to use Monad
15:25:14 <kadoban> Well, I'm not sure why you find that disturbing.
15:25:33 <benmachine> phaazon: 'bound' is not quite standard; I imagine most have not heard of the package
15:25:36 <phaazon> kadoban: because an Applicative can be a Monad, but that’s not mandatory
15:25:43 <kadoban> If you're writing both, it's just plain easier...why wouldn't you? If you're not...then you don't use monad.
15:25:48 <phaazon> what happened if my expression is an Applicative, but not a Monad ?
15:26:05 <kadoban> phaazon: Then you don't use the monad instance to write the applicative one...
15:26:11 <phaazon> exactly
15:26:12 <phaazon> ok
15:26:13 <kadoban> I'm not sure the confusion in this part
15:26:17 <int-e> phaazon: then you'll be dealing with a completely different type, so that question really does not make sense.
15:26:17 <phaazon> imagine it can’t be a monad
15:26:20 <MP2E> I see what's happening here now, but the thing is that using the monad instance for one applicative doesn't mean you need to use it for all of them :P
15:26:22 <phaazon> how should I deal with Scope?
15:26:31 <gabnex> indiagreen I think only template haskell can do it so that it works everywhere. because it really a pattern matching syntax in different clothing. so get Foo  should expand to \d -> case d of Foo x -> Just x; _ -> Nothing
15:26:51 <benmachine> phaazon: what's the type that Lam belongs to?
15:26:59 <kadoban> phaazon: I don't have your code, so I'm not sure what this is at all... maybe other people know more what "Scope" is and it's obvious to them
15:27:01 <phaazon> data E a = … | Lam (Scope () E a)
15:27:13 <phaazon> and E is in Functor
15:27:19 <int-e> phaazon: so, reading between the lines, are you asking whether there could be an instance Applicative f => Applicative (Scope b f)?
15:27:30 <gabnex> indiagreen it would be nicer to use than pattern matching in some cases because you could just pass (get Foo) to higher order functions
15:27:43 <phaazon> int-e: nope :(
15:27:44 <phaazon> god
15:27:45 <phaazon> ok
15:27:47 <phaazon> nevermind
15:27:50 <benmachine> phaazon: are you sure this is possible? the docs for bound say that Scope b f is only applicative when f is a Monad
15:27:52 <phaazon> thank you anyway
15:27:56 <phaazon> I know you’re trying to help
15:28:28 <benmachine> so it seems like it's probably necessary for E to be a Monad for the Applicative to work
15:28:32 <benmachine> yes that's weird, no it's not contradictory
15:28:33 <phaazon> benmachine: ok, so there’s no way to implement that without monad
15:28:37 <MP2E> huh, weird
15:28:46 <benmachine> phaazon: I'm not sure, but superficially it seems plausible
15:28:52 <phaazon> benmachine: I found that really weird
15:29:05 <monochrom> a while ago I was learning how to write the Applicative instance for a certain type X. I had a mental block. it was lucky that X was also a Monad instance, and I knew how to write its Monad instance. so I went ahead inline ap, which is full of >>=, so I went ahead inline >>= too, then simplified. now I saw how, with hindsight, I could have written <*> on its own terms. that was how I unblocked my mental block.
15:29:11 <benmachine> phaazon: the only way I could give a decisive answer is by spending a bunch of time plumbing in the internals of this library trying to work out what's going on
15:29:14 <kadoban> phaazon: (note that this is a different required monad than the one we were talking about before)
15:29:27 <kadoban> In case that wasn't clear
15:29:45 <MP2E> I didn't know there were cases of an Applicative requiring a Monad
15:29:57 <merijn> MP2E: You're misreading the remark
15:30:08 <MP2E> *reads harder*
15:30:10 <phaazon> benmachine: well
15:30:10 <monochrom> you will say, ok, but what happens when I later learn another type Y which cannot be a Monad instance? well then, Y is a different story, in fact probably Y is easy. X doesn't have to have anything to do with Y. why compare them?
15:30:21 <merijn> MP2E: The Applicative of "Scope b f" doesn't require that "Scope b f" is a Monad, it requires that *f* is a Monad
15:30:24 <phaazon> the Monad instance is implemented with (>>>=)
15:30:29 <MP2E> Ah
15:30:38 <phaazon> that requires the expression to be in Monad, which sounds ok to me
15:31:11 <phaazon> however, having no possibility to write the applicative instance without monad sounds like class Monad f => Applicative f in my mind
15:31:12 <benmachine> phaazon: if you lpasted all the code you've written so far, it would probably be easier to get a grip on this problem
15:31:17 <phaazon> and that’s really disturbing
15:31:31 <phaazon> ok, wait
15:31:42 <kadoban> phaazon: You're not reading into it correctly, look at merijn's last line
15:31:53 <phaazon> benmachine: http://lpaste.net/113115
15:33:18 <haxifix> So, I'm reading the typeclassopedia and im trying to do the exercises.  It says to implement the Functor instance for Either e a.  I have written what I believe to be the correct definition, however when i try to print out the value it says that there is no Show for the ambiguous type
15:33:19 <haxifix> http://pastebin.com/siZnnfYX
15:33:43 <haxifix> I'm not sure why it works and outputs fine for Left' 2, but not Right' 2
15:34:32 <phaazon> it sounds weird as implementing Semigroup with Monoid is to me
15:35:07 <phaazon> in my mind, Monoid should be class (Semigroup w) => Monoid w where…
15:35:29 <phaazon> so implementing Semigroup with Monoid sounds a bit… yeah, weird.
15:35:52 <benmachine> phaazon: it's the mutual recursion that makes this interesting
15:36:14 <benmachine> phaazon: the thing is that E uses Scope with an E argument
15:36:22 <benmachine> and Scope Applicative therefore uses E Monad
15:36:27 <benmachine> nothing weird about that as such
15:36:38 <kadoban> phaazon: Think of it this way: given a Monoid instance, how would you write the Semigroup instance? Pretend you know nothing about the type except that it has a Monoid instance
15:36:49 <haxifix> Does anyone know why this fails with the error that type e0 is ambiguous? http://pastebin.com/siZnnfYX
15:36:52 <phaazon> kadoban: yeah, easy
15:36:53 <benmachine> but then if E wants to use Scope Applicative, it must use E Monad
15:36:53 <phaazon> I know
15:36:57 <phaazon> (<>) = mappend
15:36:58 <phaazon> but.
15:37:04 <benmachine> haxifix: if it helps, your answer is correct
15:37:07 <phaazon> in term of generalization, it sounds weird to me
15:37:23 <kadoban> But you just generalized it already, hehe.
15:37:26 <benmachine> haxifix: it surprises me that you get an ambiguous type error, but you can probably chase it away by attaching a type annotation to the number argument
15:38:01 <milesrout> http://coliru.stacked-crooked.com/a/f22e4f4c4bcadf21 this might interest some of you
15:38:04 <phaazon> kadoban: is Applicative a generalization of Monad? or Monad a generalization of Applicative?
15:38:31 <benmachine> Applicative is more general than Monad
15:38:33 <kadoban> haxifix: I think it's because your usage of Right' there...the type 'e' for that could be anything, so it's ambiguous
15:38:37 <benmachine> but like I explained, the mutual recursion complicates things
15:38:37 <haxifix> I tried this and it fails with the same error: http://pastebin.com/h1hCeF3F
15:38:38 <milesrout> phaazon: all Monads are Applicatives, but not all Applicatives are Monads.
15:38:45 <phaazon> yeah, right.
15:38:59 <phaazon> so implementing an Applicative with monad’s code sounds weird to me
15:39:08 <benzrf> phaazon: it werks
15:39:27 <kadoban> phaazon: It...probably shouldn't. It actually kinda means exactly that...one follows from the other
15:39:51 <benmachine> haxifix: want to paste the error for us? also if you use lpaste.net you'll get better syntax highlighting
15:39:58 <phaazon> kadoban: I think I know my mental block
15:40:12 <phaazon> I always write less general instance using the more general abstraction
15:40:22 <phaazon> Applicative uses Functor
15:40:28 <phaazon> I use fmap in my Applicative instance
15:40:45 <pjdelport> A better way of saying it is that Monad already implements Applicative, but before AMP, you just have to do some manual type translation.
15:40:48 <haxifix> Here you go: http://lpaste.net/113116
15:40:53 <monochrom> haxifix: in "fmap (\x -> x+5) $ Left' 2", the type is Either Integer Integer. this has no Show problem. in "fmap (\x -> x+5) $ Right' 2", the type is Either e Integer with unknown e, therefore it is also unknown whether you can do Show or not
15:41:18 <benmachine> oh yes, monochrom is right, and I am foolish
15:41:24 <RchrdB> writing something such as (Right' 2 :: Either' Int Int) instead compiles and runs happily.
15:41:51 <phaazon> is there a word in category theory for that specific case?
15:42:06 <kadoban> haxifix: (by the way, (\x -> x + 2) is written more concisely as (+2)    )
15:42:21 <phaazon> when the general version can’t exist without its specialized version?
15:42:28 <benmachine> haxifix: note that usually this isn't a big deal, because you use stuff in other contexts in a way that fixes its type
15:42:40 <monochrom> benmachine: I don't think you said anything foolish. it is fair to ask for the error message. I just loaded up the code myself to play with it, at my own expense. :)
15:43:02 <benmachine> monochrom: oh, that's not what I meant, I meant when I said to try annotating the numeric literal
15:43:08 <benmachine> I was getting my ambiguity errors confused
15:43:13 <monochrom> oh hehe
15:43:14 <CrazyM4n> Why does this code error if I attempt to use a bang pattern with p, x, or y? http://lpaste.net/5540653565850157056
15:43:16 <haxifix> I'm not sure I fully understand why Left' 2 doesn't cause problems but Right' does
15:43:49 <benmachine> haxifix: because you're fmapping a numeric operation over Left' 2, which forces the second type argument to be numeric
15:43:59 <benmachine> but also, it's Left' 2, so the first type argument must be numeric as well
15:44:09 <monochrom> yeah
15:44:25 <monochrom> it's rather subtle. took me a few seconds to realize, too
15:44:37 <benmachine> whereas in the Right' case, you're supplying two bits of information about the second type argument and none about the first
15:46:00 <kadoban> haxifix: Try to think like the compiler. Consider each case and try to see what type is required for 'e' and 'a' in each, based on what you're doing with them.
15:46:06 <monochrom> CrazyM4n: you have to move the pragma way earlier, before "import ...", even before "module ..."
15:46:08 <int-e> CrazyM4n: the LANGUAGE pragma should come before the imports
15:46:17 <CrazyM4n> Ah, thanks a ton!
15:46:24 <int-e> CrazyM4n: but it's interesting that the compiler doesn't complain about this ...
15:46:29 <int-e> it really should.
15:46:36 <CrazyM4n> It gives me very generic messages
15:46:36 <monochrom> perhaps -Wall does
15:46:41 <RchrdB> i thought it emitted at least warnings about it
15:46:51 <benmachine> int-e: arguable... part of the purpose of pragmas is that they look like comments if you don't recognise them
15:47:03 <milesrout> All warnings should be on by default in all languages
15:47:12 <int-e> benmachine: ghc usually warns about pragmas that it doesn't recognize
15:47:26 <benmachine> int-e: I'd probably lose the argument, but arguable all the same :P
15:47:27 <int-e> benmachine: and I would argue that that is the case here.
15:47:54 <monochrom> boo, -Wall doesn't complain about it either
15:47:59 <kadoban> int-e: Yeah, but it's not a pragma that it doesn't recognize, it's a comment that looks very similar to a pragma XD
15:48:01 <benmachine> I think I agree but it wouldn't horrify me if GHC had different views
15:48:32 <milesrout> It's weird to me that they just used comments for pragmas.
15:49:21 <benmachine> I think I agree, actually
15:49:37 <benmachine> if you're going to have breaking changes, might as well break things properly :P
15:50:15 <milesrout> You only use pragmas in programs that are intended to have different semantics at the language level, by definition.
15:50:17 <CrazyM4n> How exactly do bang patterns work? I know you're supposed to use them when computations are redone a lot, but did I use them correctly here? http://lpaste.net/4224609246290903040
15:51:16 * hackagebot criterion-plus 0.1.1 - Enhancement of the "criterion" benchmarking library  http://hackage.haskell.org/package/criterion-plus-0.1.1 (NikitaVolkov)
15:52:35 <milesrout> God it annoys me when something doesn't have a changelog or any other indication of changes in a particular release.
15:53:31 <merijn> CrazyM4n: They have nothing to do with "computations that are redone a lot"
15:53:42 <merijn> CrazyM4n: They make function arguments strict
15:53:46 <monochrom> CrazyM4n: I would quite simply do this: parsePoints _ (x0,y0) = seq z (rgb8 z z z) where z = floor (100 * x0+1) .&. floor (100 * y0+1). also what merijn says.
15:54:00 <merijn> CrazyM4n: i.e. "f !x = x" will force it's argument to WHNF before returning
15:54:16 <merijn> unlike "id x = x" which will *not* do so
15:54:29 <merijn> > let foo !x = 1 in f undefined
15:54:31 <lambdabot>  No instance for (GHC.Show.Show a0)
15:54:31 <lambdabot>    arising from a use of ‘M48538435534855397213289.show_M48538435534855397213...
15:54:31 <lambdabot>  The type variable ‘a0’ is ambiguous
15:54:31 <lambdabot>  Note: there are several potential instances:
15:54:31 <lambdabot>    instance [safe] GHC.Show.Show
15:54:40 <merijn> heh?
15:54:45 <merijn> oh, duh
15:54:49 <merijn> > let foo !x = 1 in foo undefined
15:54:50 <lambdabot>  *Exception: Prelude.undefined
15:54:55 <merijn> > let foo x = 1 in foo undefined
15:54:57 <lambdabot>  1
15:56:31 <monochrom> the "seq z" may even be unnecessary because rgb8 will do it anyway
15:56:55 <monochrom> but I guess I know nothing about rgb8
15:57:47 <joe9> What would be a good data structure to represent this: http://codepad.org/8kdWcyip . In C, it was just OR'ed flags. Not sure how to represent it in functional programming?
15:58:20 <jpchang> What online, free resource would you say helped you the most in learning Haskell?
15:58:30 <joe9> jpchang: lyah, rwh
15:58:32 <Ouyang> ok so from earlier, if I want to nuke haskell, what would I delete outside of ~/.cabal and ~/.ghc
15:58:36 <koala_man> hoogle
15:59:07 <Ouyang> jpchang, check out the FP class on edx.org, it's taught in haskell
15:59:25 <indiagreen> gabnex: what about this one? http://lpaste.net/113119
15:59:26 <jpchang> joe9: what is rwh?
15:59:32 <Ouyang> real world haskell
15:59:36 <Ouyang> a book online for free
15:59:50 <Ouyang> search the title and you should find it, it is from O'Reilley
15:59:54 <jpchang> oh ok thanks
16:00:01 <phaazon> lam "x" $ "x" .+ "z" .* "a"
16:00:01 <phaazon> Lam (Scope (Mul (Add (V (B ())) (V (F (V "z")))) (V (F (V "a")))))
16:00:08 <phaazon> ok, it works perfectly
16:00:16 <phaazon> thank you for all ;)
16:00:26 <kadoban> Nice, congrats
16:00:36 <phaazon> (god I love IsString :) )
16:01:06 <merijn> Ouyang: on linux that should be it, on OSX there's ~/Library/Haskell and some places, on windows I dunno
16:01:12 <Ouyang> rm -fr ~/.ghc ~/.cabal
16:01:13 <nkar> could anyone show me a simple example demonstraing how to concatenate expressions using template haskell?  I want to define a constant (e.g., foo = do res1 <- ...; res2 <- ...;) and a "function" 'f ret = ...' so I can do things like (made up): 'f (return (res1, res2))' or 'f (return res1)' to append a different 'return' to 'foo' (I need to access identifiers in foo's scope).  is it even possible?
16:01:19 <Ouyang> sorry wrong terminal
16:03:24 <gabnex> indiagreen looks nice.. exactly what I wanted. so it will work with all the types that derive Data and Typeable?
16:03:33 <phaazon> lam ["x","y"] $ "x" .+ "y"
16:03:33 <phaazon> Lam (Scope (Add (V (B 0)) (V (B 1))))
16:03:36 <phaazon> god I love bound :D
16:04:08 <gabnex> oh it doesn't, get is FB specific
16:04:26 <gabnex> is it possible to make get more generic?
16:04:31 <EvanR2> whats the trick to do list !! but getting a Maybe back
16:04:32 <Ouyang> I believ pacman -Rsc is the amount of yolo I need for removing haskell
16:05:07 <indiagreen> gabnex: yes, just replace get's type signature with “get :: (Data a, Data x) => (a -> x) -> x -> Maybe a”
16:06:01 <zwer> EvanR2 write your own function or operator. or use safe package, it comes with such a function (at) and a bunch of other
16:06:10 <phaazon> EvanR2: (?!)
16:06:13 <phaazon> :t (!?)
16:06:15 <lambdabot>     Not in scope: ‘!?’
16:06:15 <lambdabot>     Perhaps you meant one of these:
16:06:15 <lambdabot>       ‘!!’ (imported from Data.List), ‘!’ (imported from Data.Array),
16:06:24 <phaazon> hm, it’s in Vector, sorry :D
16:06:30 <EvanR2> doing it
16:07:02 <gabnex> indiagreen yes it worked
16:07:16 <Keeper> Being pretty new to Haskell, I have a question related to some basic I/O. In particular I'm trying the example from "Sequencing actions with do" @ http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output. Problem is once I compile and run the file, I don't get the "enter your name" message. Why?
16:07:24 <indiagreen> gabnex: in fact, you can make “get” even more general (albeit I'm not sure it would be useful) by doing this: http://lpaste.net/113120
16:07:38 <gabnex> `Data a' represents a constructor?
16:07:40 <indiagreen> it would return the 1st field of the constructor
16:09:03 <indiagreen> no, “Data” is just a class for things which generics can work with
16:09:06 <indiagreen> oh, by the way
16:09:22 <indiagreen> I think it would even be possible to make “get Baz” return “(Int, Bool)”
16:09:44 <indiagreen> well, “Maybe (Int, Bool)”, I mean
16:09:59 <merijn> Keeper: Which example?
16:10:11 <gabnex> get Baz or get FB?
16:10:17 <Keeper> Sequencing actions with do. First one
16:10:22 <indiagreen> get Baz
16:10:50 <merijn> Keeper: Nothing happens? When you compile and run it?
16:11:03 <Keeper> Says: "Ok, modules loaded: Main."
16:11:09 <gabnex> what would Baz be? we didn't define it
16:11:19 <indiagreen> I did in the last paste
16:11:27 <merijn> Keeper: Wait, you're loading it into ghci?
16:11:38 <Keeper> Yes. Through emacs editor
16:11:47 <merijn> Keeper: ghci doesn't automatically run code
16:11:57 <Keeper> merijn: Oh.
16:11:59 <merijn> Keeper: You need to type ":main" into ghci to run it
16:12:40 <Keeper> merijn: So.. I have this Main.hs file which I run like :l Main.hs.
16:13:17 <Keeper> merijn: Where exactly do I write the ":main" at?
16:13:23 <merijn> Keeper: ":l" just loads the file, it doesn't run anything
16:13:37 <merijn> Keeper: Same place where you write ":l Main.hs"
16:14:23 <Keeper> merijn: But I do need to specify the file?
16:14:35 <merijn> No, that runs "main" from the loaded file
16:14:48 <merijn> Since you already loaded it
16:15:11 <Keeper> Oh right. I get it now. Thanks for being patient :)
16:16:21 <haxifix> When I'm trying to implement the Functor instances for ((->) e) and ((,) e) it says that they are already defined
16:16:32 <haxifix> i had the same issue with either, but I could just say Either' to get away with it
16:16:41 <haxifix> how would I do the same for -> e/
16:17:02 <merijn> haxifix: "newtype Tuple a b = Tuple (a, b)"
16:17:21 <merijn> "newtype Arrow a b = Arrow (a -> b)", etc. :)
16:18:11 <codygman> I need to do logging in/form posting to a website. What library would be the best fit? I see the browser monad in HTTP and have used wreq.
16:18:36 <haxifix> Ah I see, I knew about newtype but the typeclassopedia doesn't mention it once.  Do they expect you to know to make them into new types before trying to implement them?
16:19:40 <Eduard_Munteanu> codygman, what sort of logging?
16:19:56 <Eduard_Munteanu> Oh, login.
16:21:19 <codygman> Eduard_Munteanu: Yeah logging in. Remembering last visited url is also useful.
16:21:37 <merijn> haxifix: I dunno, you can also reimplement them using data (slightly less efficient)
16:28:57 <argent0> Hi, how can I view the implementation of fmap for Maybe?
16:30:28 <shelf> argent0: I don't *think* ghci can do such a thing. you'll probably need to follow the 'source' link from Haddock
16:30:45 <eyebloom> Look up instance Functor Maybe
16:30:56 <eyebloom> in Hackage
16:31:08 <eyebloom> follow the source link
16:31:51 <argent0> shelf, eyebloom : Thanks!
16:32:24 <piskrist> fmap _ Nothing = Nothing; fmap fx (Just x) = Just $ fx x I suppose
16:32:25 <shelf> lambdabot has a ?src command but i'm not sure how to look up instances
16:35:34 <Keeper> Can somebody suggest what's wrong with the following snippet?: http://pastebin.com/raw.php?i=Taee6w9e
16:36:08 <indiagreen> Keeper: "Hi" isn't an IO action, it's a string
16:36:22 <Keeper> So I need to putStrLn?
16:36:28 <indiagreen> yep
16:37:16 <Keeper> Still gives a parse error on input 'if'
16:37:37 <monochrom> put "if" under "name"
16:37:54 <monochrom> I mean align them, they should have the same left margin
16:38:16 <indiagreen> Keeper: alternatively, you can put “putStrLn $” before “if”
16:38:52 <monochrom> no, that is not a relevant alternative
16:39:41 <monochrom> oh, I see what you mean now
16:43:53 <piskrist> > last $ repeat 1
16:43:59 <lambdabot>  mueval: ExitFailure 1
16:44:21 <Hari`> hi
16:53:24 <EvanR_> > last $ repeat 1
16:53:29 <lambdabot>  mueval: ExitFailure 1
16:53:48 <EvanR_> > let x = x in x
16:53:51 <lambdabot>  mueval-core: Time limit exceeded
16:54:07 <EvanR_> so many ways to bottom out
16:54:08 <zwer> > Keeper you can do this: putStrLn (if name == "Keeper" then "Hi" else "Bye")
16:54:09 <lambdabot>  <hint>:1:16: parse error on input ‘do’
16:55:17 <gabnex> is ghc capable of linking haskell source on windows as a gui program?
16:55:32 <augur_> so:
16:55:48 <augur_> class Collapsable f where   collapse :: f (Maybe a) -> f a
16:55:51 <merijn> gabnex: GHC can just produce standard DLLs
16:55:57 <gabnex> it is trivial to change that with editbin, so it is not essential, I am just wondering
16:56:10 <augur_> filter p = collapse . fmap (toMaybe p)
16:56:17 <augur_> where toMaybe :: (a -> Bool) -> a -> Maybe a
16:57:11 <Ouyang> ok so I have been searching for the answer to this, in the scotty tutorial, when running "cabal install" for the first time, I get this http://puu.sh/co2eH/475234ea23.png
16:57:58 <Ouyang> it asks for base 4.6.* but then below says it is rejecting base 4.6.0.0
16:58:01 <augur_> hm..   collapse :: f :. Maybe ~> f
16:58:05 <gabnex> I am not talking about DLLs but executable. executable in windows can be linked as a console program or as a gui program. if linked as a console program you always have a dangling console window, which is ugly for GUI programs
16:58:35 <merijn> Ouyang: It's saying "todo wants "base==4.6.*" but you have base-4.7 installed
16:58:39 <augur_> join :: f :. f ~> f
16:58:56 <augur_> generalization?   fuse :: f :. g ~> h
16:59:03 <merijn> Ouyang: It's rejecting base-4.6 because base is hard-wired into GHC and you *cannot* upgrade or change the version of base GHC uses
16:59:17 <Ouyang> not even in a sandbox?
16:59:36 <merijn> Ouyang: No, the *only* way to use a different version of "base" is to use a different GHC version
16:59:40 <monochrom> you have to use a different GHC version for a different base version.
16:59:41 <merijn> Ouyang: Try the following
17:00:04 <merijn> Ouyang: "cabal get todo" -> edit todo.cabal -> change base constraint to 4.7 -> "cabal install" and see if that works
17:00:10 <merijn> Ouyang: I'm willing to bet it will
17:00:13 <EvanR_> gabnex: this exists so http://hackage.haskell.org/package/Win32
17:00:26 <EvanR_> you can probably link to whatever
17:00:41 <merijn> Ouyang: The maintainer of todo just put a really tight constraint on base, which is a silly thing to do
17:01:02 <Ouyang> errr its a cabal file I copy pasted as per the tutorial
17:01:42 <monochrom> the tutorial is suboptimal. most tutorials are like that. most things on the internet in general.
17:01:48 <kadoban> Ouyang: Oh it's your cabal file that's doing it? Then change that dependency
17:02:11 <monochrom> and also going out of date very quickly.
17:02:57 <Ouyang> ok base problem is solved, now three more dependency errors!
17:03:24 <kadoban> gabnex: Some random googling suggests -optl-mwindows
17:04:15 <kadoban> gabnex: https://ghc.haskell.org/trac/ghc/ticket/2459 Seems to be the most info I can find on it....which is a bug in part of it I think, but...haha maybe it'll help anyway
17:05:19 <johnarmstrong> i had a weird exam question wonder if anyone knows the answer
17:05:31 <johnarmstrong> suppose you have two lists neg and nats
17:05:36 <spng453> How fast is maximum?
17:05:47 <Ouyang> ok thank you very much for your help
17:05:52 <johnarmstrong> neg = [-inf ... -1], nats = [0, .., inf]
17:06:10 <johnarmstrong> if you do ints = nats ++ negs
17:06:17 <johnarmstrong> you can't do elem -1 ints
17:06:22 <johnarmstrong> how do you solve this?
17:06:53 <EvanR_> > [0..]
17:06:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:07:01 <EvanR_> > [..-1]
17:07:02 <lambdabot>  A section must be enclosed in parentheses thus: (..- 1)Not in scope: ‘..-’
17:07:02 <lambdabot>  Perhaps you meant ‘...’ (imported from Control.Lens)
17:07:07 <EvanR_> > [..(-1)]
17:07:08 <lambdabot>  <hint>:1:2: parse error on input ‘..’
17:07:15 <kadoban> johnarmstrong: You can't, afaik with your definition of neg....if you went the other way, you could interleave them or something
17:07:27 <exio> I wonder how that would "work"
17:07:27 <monochrom> I am not sure what is "inf".
17:07:39 <gabnex> kadoban -optl-mwindows worked just fine.. thanks.
17:07:43 <kadoban> 'welcome
17:07:54 <johnarmstrong> just suppose that nats is a list with all natural numbers
17:08:05 <EvanR_> > [0..ω]
17:08:06 <lambdabot>  Not in scope: ‘ω’
17:08:07 <johnarmstrong> and negs is a list with all negative integers
17:08:23 <exio> > [(-1), (-2)..]
17:08:24 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:08:39 <johnarmstrong> how would you interweave the two?
17:08:40 <EvanR_> let ω = last [0..]
17:09:03 <EvanR_> > [0..undefined]
17:09:05 <lambdabot>  *Exception: Prelude.undefined
17:09:12 <kadoban> johnarmstrong: f (x:xs) (y:ys) = x:y: f xs ys
17:09:13 <monochrom> what is the verbatim exam question, as opposed to your possibly wrong interpretation?
17:09:17 <gabnex> > [-1, -2..]
17:09:19 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
17:09:21 <spng453> Would maximum be O(n!)?
17:09:34 <johnarmstrong> i just wrote it so i don't have it
17:09:43 <EvanR_> > [-1, -2, ..] ++ [0 ..]
17:09:45 <lambdabot>  <hint>:1:10: parse error on input ‘..’
17:10:22 <indiagreen> > > [-1, -2 ..] ++ [0 ..]
17:10:25 <indiagreen> > [-1, -2 ..] ++ [0 ..]
17:10:26 <gabnex> EvanR you have comma after ,
17:10:27 <kadoban> johnarmstrong: Ah, you're writing the question? Then your definition of negs kinda makes it impossible afaik...and why not use actual types? I'm not sure what inf is supposed to be
17:10:27 <monochrom> well then, that's too bad, at some point, some technical detail matters, and tiny change changes the answer drastically.
17:10:32 <johnarmstrong> kadoban: but wont that function never complete if the lists have infinite number of values
17:10:33 <gabnex> err, before ..
17:11:02 <EvanR_> > elem 2 [0..]
17:11:04 <kadoban> johnarmstrong: Sure. But you can still `elem` -1, or any arbitrary value on it
17:11:04 <lambdabot>  True
17:11:06 <monochrom> kadoban: I think "I just wrote the exam" means "I was recently a candidate" rather than "author"
17:11:14 <johnarmstrong> sorry here is the instructors def of nats = 0 : map (\x -> x + 1) nats
17:11:16 <kadoban> monochrom: Oh.
17:11:48 <kadoban> johnarmstrong: And negs?
17:11:50 <johnarmstrong> then negs = map (\x -> -(x+1))nats
17:12:04 <johnarmstrong> ok
17:12:09 <monochrom> see, that is totally different from [-inf .. -1]
17:12:16 <johnarmstrong> sorry!
17:12:27 <johnarmstrong> now ints = nats ++ negs
17:12:42 <johnarmstrong> but how to get elem 1 ints without error?
17:12:48 <johnarmstrong> sorry -1
17:13:13 <kadoban> johnarmstrong: You can't with ++, you have to do something like my f above to combine them
17:13:22 <EvanR_> i wish i was in that class instead of in the real world :(
17:13:23 <kadoban> Or sometihng more exotic...
17:13:48 <johnarmstrong> i don't think the recursive function works cause it will go one faeva
17:13:55 <gabnex> > let nats = 0 : map (\x -> x + 1) nats in take 5 nats
17:13:57 <lambdabot>  [0,1,2,3,4]
17:14:26 <monochrom> to solve the problem, you want the final list to look like [0, 1, -1, 2, -2, 3, -3, etc]
17:14:38 <johnarmstrong> i know, but how!
17:14:40 <kadoban> johnarmstrong: Your definitions of negs and nats go on forever too, you can still use them
17:14:49 <EvanR_> what if you just do negs ++ nats
17:15:00 <johnarmstrong> haha!
17:15:06 <monochrom> heh
17:15:06 <EvanR_> zoik
17:15:16 <johnarmstrong> i think he mean any elem i ints should work
17:15:25 <exio> something like f (x:xs) (y:xs) = x:y:f xs ys
17:15:39 <EvanR_> :t interleave
17:15:41 <lambdabot> Not in scope: ‘interleave’
17:15:43 <exio> then 0:f [1..] [(-1),(-2)..]
17:16:04 <johnarmstrong> can't use that functioni believe
17:16:08 <johnarmstrong> must be more basic
17:16:18 <monochrom> actually simply f nats negs is good enough.
17:16:19 <gabnex> then write it yourself
17:16:40 <indiagreen> > concat [[x, y] | (x, y) <- zip [1..] [0, -1..]]
17:16:43 <lambdabot>  [1,0,2,-1,3,-2,4,-3,5,-4,6,-5,7,-6,8,-7,9,-8,10,-9,11,-10,12,-11,13,-12,14,-...
17:16:44 <johnarmstrong> thanks tried that gabnex
17:16:45 <EvanR_> @src interleave
17:16:45 <lambdabot> Source not found.
17:17:08 <EvanR_> a well ordering of the integers
17:17:09 <zwer> @hoogle interleave
17:17:12 <lambdabot> package interleave
17:17:12 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays interleavedArrays :: InterleavedArrays -> Stride -> Ptr a -> IO ()
17:17:12 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays data InterleavedArrays
17:17:21 <EvanR_> for bonus points make a well ordering of the reals
17:17:42 <monochrom> I know how to make a well ordering of the Doubles. is that good enough? :)
17:17:43 <gabnex> by "write" I mean copy/paste from hackage
17:17:47 <EvanR_> lol
17:20:41 <EvanR_> i want a programming language where last ([0..] ++ [-1]) completes
17:20:59 <merijn> EvanR_: That makes no sense
17:21:03 <exio> with infinite memory and infinite time...
17:21:21 <monochrom> or with a theorem prover smarter than me
17:21:22 <EvanR_> the answer is obviously -1 !
17:21:28 <johnarmstrong> k that f function did the interview but still failed the elem
17:21:31 <merijn> EvanR_: How is that obvious?
17:21:45 <johnarmstrong> interweave... not interview
17:21:46 <merijn> EvanR_: Please give me complete denotational semantics for appending to infinite lists
17:21:49 <EvanR_> the margin is too narrow for my proof
17:22:06 <lpaste> kadoban pasted “ints for johnarmstrong” at http://lpaste.net/113123
17:22:09 <exio> EvanR_: what would be the return/result of "last [0..]"?
17:22:20 <kadoban> johnarmstrong: That runs fine for me, try it on your box
17:22:26 <EvanR_> undefined
17:22:30 <johnarmstrong> the demon digit
17:22:42 <monochrom> last [0..] = 9223372036854775807
17:22:50 <johnarmstrong> kadoban i did
17:22:51 <merijn> monochrom: Cheater :)
17:22:52 <johnarmstrong> :(
17:22:55 <EvanR_> lol
17:22:57 <kadoban> johnarmstrong: And?
17:23:11 <johnarmstrong> same error as ints
17:23:11 <CodeWeaverX> I bet if you had a rewrite rule that said that:
17:23:20 <kadoban> johnarmstrong: What error?
17:23:24 <CodeWeaverX> that said
17:23:29 <gabnex> couldn't it work? ghc would just need to be smart enough to fuse last ([..] .. x) to const x
17:23:41 <CodeWeaverX> ugh.  That said:  last (xs ++ ys) == last ys
17:23:42 <merijn> > last [1..]
17:23:43 <lambdabot>  Ambiguous occurrence ‘last’
17:23:44 <lambdabot>  It could refer to either ‘L.last’, defined at L.hs:170:1
17:23:44 <lambdabot>                        or ‘GHC.List.last’,
17:23:44 <lambdabot>                           imported from ‘Data.List’ at L.hs:91:1-16
17:23:44 <lambdabot>                           (and originally defined in ‘base:GHC.List’)
17:23:45 <EvanR_> it uses the halting problem solver primitive op
17:23:47 <merijn> aww
17:23:51 <merijn> My trickery didn't work
17:23:54 <merijn> @undefine
17:23:54 <lambdabot> Undefined.
17:24:29 <benzrf> merijn: rekt
17:24:33 <merijn> CodeWeaverX: Not true
17:24:43 <benzrf> spell it with a subtly different unicode a-lookin char
17:24:50 <merijn> CodeWeaverX: if xs is bottom, then "last (xs ++ ys)" is bottom
17:25:03 <exio> merijn: what definition where you going to use? :P
17:25:22 <EvanR_> xs isnt bottom but
17:25:24 <merijn> exio: "last :: [Word8] -> Word8" and confuse people when "last [1..]" returned 255
17:25:30 <johnarmstrong> Could not deduce (Num ([a0] -> a -> [a] -> Bool))
17:25:31 <johnarmstrong>       arising from the ambiguity check fitor
17:25:31 <johnarmstrong>     from the context (Num ([a1] -> a -> [a] -> Bool),
17:25:31 <johnarmstrong>                       Num (a -> [a] -> Bool),
17:25:31 <johnarmstrong>                       Num a1,
17:25:31 <johnarmstrong>                       Eq a)
17:25:31 <johnarmstrong>       bound by the inferred type f:itor
17:25:32 <johnarmstrong>                  (Num ([a1] -> a -> [a] -> Bool), Num (a -> [a] -> Bool), Num a1,
17:25:32 <johnarmstrong>                   Eq a) =>
17:25:33 <johnarmstrong>                  a -> [a] -> Bool
17:25:33 <johnarmstrong>       at <interactive>:18:1-13
17:25:34 <johnarmstrong>     The type v is ambiguousa0ariable
17:25:34 <johnarmstrong>     When checking tithat
17:25:35 <johnarmstrong>       has the inferred tforall a a1.ype
17:25:40 <exio> merijn: ah :P
17:25:43 <merijn> EvanR_: "last [1..]" *is* bottom
17:25:47 <EvanR_> yes
17:26:04 <merijn> EvanR_: Therefore "last ([1..] ++ [-1])" is bottom
17:26:10 <EvanR_> @src last
17:26:10 <lambdabot> last [x]    = x
17:26:10 <lambdabot> last (_:xs) = last xs
17:26:10 <lambdabot> last []     = undefined
17:26:23 <kadoban> johnarmstrong: 1) don't paste huge things to the channel  2) Is that for the code I wrote? Because...it doesn't seem to be
17:26:25 <merijn> EvanR_: ++ has to evaluate it's left hand
17:26:31 <EvanR_> technically last [2..]
17:26:52 <johnarmstrong> yes it is
17:27:16 <merijn> EvanR_: Therefore "_|_ ++ ys" == "_|_" -> "last (_|_ ++ ys)" == "last _|_" == "_|_"
17:27:22 <EvanR_> stupid lambda calculus
17:27:31 <kadoban> johnarmstrong: That's the result of http://lpaste.net/113123 ? frankly i don't believe you
17:27:32 <EvanR_> its broke i say
17:27:32 <merijn> EvanR_: Your version violates haskell's denotational semantics
17:27:49 <EvanR_> i fully understand why it doesnt work in haskell
17:28:11 <merijn> EvanR_: Feel free to come up with a better denotational semantics, but make sure it works for everything other than "last (xs ++ [-1])" ;)
17:28:27 <EvanR_> the language im talking about is fully functional and the chesire cat uses it on a regular basis
17:28:36 <EvanR_> through the looking glass
17:28:39 <kadoban> Yes, it's important it works for last (xs ++ [-2]) as well
17:28:44 <kadoban> :)
17:29:37 <EvanR_> "an infinite sequence followed by foo"
17:41:23 <EvanR_> are variables shadowed on a per-equation, per-case basis
17:45:39 <EvanR_> :t or
17:45:40 <lambdabot> [Bool] -> Bool
17:51:41 * hackagebot eibd-client-simple 0.0.1 - EIBd Client  http://hackage.haskell.org/package/eibd-client-simple-0.0.1 (vapourismo)
17:56:42 * hackagebot eibd-client-simple 0.0.2 - EIBd Client  http://hackage.haskell.org/package/eibd-client-simple-0.0.2 (vapourismo)
18:03:52 <dfeuer> augur_, GeneralizedNewtypeDeriving is more for efficiency than anything else, I think. It would probably be possible to accomplish most purposes by creating an instance based on the unfoldings of the underlying instance, but I think people might complain about code bloat. Roles also appear to be intended to offer some other kinds of safety, I think?
18:04:09 <dfeuer> But yeah, they be too complicated for normal people like me.
18:11:37 <codygman> dfeuer: Also, coercible aims to solve this safely as was said in the presentation SPJ did for skills matter. Very much worth watching, ah here it is: https://skillsmatter.com/skillscasts/5296-safe-zero-cost-coercions-in-haskell
18:22:18 <sheridan> Quick haskell question
18:22:25 <Zekka> What's up?
18:22:25 <sheridan> Why is it so much shittier than Python?
18:22:45 <Zekka> Can you be more specific? (Er, if you're just trolling then that's fine too)
18:22:57 <sheridan> Haha latter, sorry
18:23:04 <Zekka> No worries, you'll probably get kicked sometime though
18:23:55 <Forkk> wat
18:25:47 <fragamus> ok I have a V 9 Double and I need to turn it into a V 10 Double by adding an element on the end. Can anyone shed any light on this
18:26:03 <fragamus> using Linear
18:49:34 <sherry_> hi, how come haskell is such a shitty programming language, when compared with Python?
18:50:05 <Zekka> sherry_: Weren't you by earlier?
18:50:23 <Zekka> That was someone under a different (but similar) name, it looks like
18:50:46 <exio> sherry_: we are still the same
18:51:02 <Zekka> There's a couple specific things that you can mean by that question, if you like I can take you through some of them although I'm a little busy now
18:51:51 <WraithM> sherry_: Lol, that sort of stuff isn't going to work here :) You're not going to get people worked up. Perhaps try asking a more specific question. Is there something that you're frustrated with?
18:52:16 <Zekka> I'm pretty sure it's trollign but I'm trying to be polite
18:52:45 <dfeuer> I would recommend a swift kick.
18:53:28 <exio> what about a kiss?
18:53:30 <exio> ;P
18:53:42 <WraithM> Zekka: Of course :) Let's hug the trulls with politeness and a positive additude.
18:53:56 <indiagreen> hey, didn't we use to reform trolls in the past instead of kicking them
18:54:09 <indiagreen> I remember a story about it on Haskellwiki
18:54:26 <WraithM> indiagreen: Yes! https://gist.github.com/quchen/5280339
18:55:00 * dfeuer kisses exio.
18:55:11 <exio> aww ♥
18:55:20 <EvanR_> lets do it
18:56:27 <WraithM> I suddenly feel the errors of my ways and feel compelled to write Node.js! (quoting merijn)
18:56:28 <benzrf> ( ͡° ͜ʖ ͡°)
18:56:35 <Zekka> I don't usually like to be mean to trolls
18:56:47 <Zekka> even though I totally understand doing it
18:57:00 <EvanR_> i dont
18:58:24 <billC> yes, let's not feed the troll, please
18:58:49 * EvanR_ looks at billC's web chat hostname
19:08:50 <adarc> the ekg/ekg-core haskell package is so dope
19:22:10 <pharaun> <3 ekg
19:32:44 <jp_rider> hi
19:33:22 <jp_rider> i currently have a monad transformer that wraps a statet, with the constraint that computations run in that monad transformer cannot modify statet
19:33:38 <jp_rider> i do this by not exporting the constructor for this monad
19:34:30 <jp_rider> If I make this monad an instance of `MonadBaseControl`, will users be able to modify the underlying state by using `restoreM`?
19:35:36 <scooby__> haskell is so gay. Why aren't you idiots using javascript?
19:35:47 <cbarrett_> mods?
19:38:50 --- mode: ChanServ set +q scooby__!*@*
19:40:47 <EvanR_> "statet" its like state, but smaller
19:41:43 --- mode: ChanServ set +q *!4c69fa22@gateway/web/freenode/ip.76.105.250.34
19:41:48 --- mode: ChanServ set -q scooby__!*@*
19:42:22 <EvanR_> jp_rider: they cant modify the state from inside the wrapper unless you give them a way. but its their state to begin with so they can just do it before or after runJPRider
19:42:49 <jp_rider> right, i only care about inside runJPRider
19:43:25 <EvanR_> oh, maybe they can, if you implement MonadTrans... checking
19:43:50 <EvanR_> :t lift
19:43:51 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
19:44:19 <EvanR_> only works if you support it
19:44:48 <jp_rider> sorry, i guess i don't follow?
19:45:16 <jp_rider> if I support what?
19:45:27 <EvanR_> the MonadTrans class
19:47:29 <jp_rider> so they can modify it if I make JPRider an instance of MonadTrans (which I currently don't)
19:47:30 <jp_rider> ?
19:52:21 <EvanR_> jp_rider: yeah
19:52:34 <jp_rider> interesting
19:52:36 <EvanR_> :t put
19:52:37 <lambdabot> MonadState s m => s -> m ()
19:52:40 <jp_rider> how would they do it?
19:52:42 <EvanR_> :t lift put
19:52:44 <lambdabot> (MonadState s m, MonadTrans t) => t ((->) s) (m ())
19:52:53 <EvanR_> :t lift (put 3)
19:52:54 <lambdabot> (MonadState s m, MonadTrans t, Num s) => t m ()
19:52:56 <adarc> can you import modules specified as 'other-modules:' in .cabal files?
19:52:57 <adarc> somehow?
19:55:06 <jp_rider> ok, but I don't export the ADT that is stored inside the statet, so they won't be able to construct a value to put?
19:55:40 <jp_rider> I suppose they could put undefined, but that would just cause and crash
19:56:27 <adarc> A list of modules used by the component but not exposed to users. For a library component, these would be hidden modules of the library. For an executable, these would be auxiliary modules to be linked with the file named in the main-is field.
19:56:31 <adarc> guess not
19:56:54 <EvanR_> jp_rider: they cant put undefined
19:57:20 <EvanR_> or anything unless you hook it up behind the scenes
19:57:48 * hackagebot hailgun 0.2.0.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.2.0.0 (RobertMassaioli)
19:58:05 <jp_rider> why can't they do: lift $ put undefined
19:58:10 <jp_rider> if i implement monadtrans
19:58:22 <EvanR_> dont implement it
19:58:30 <EvanR_> if you dont want to
19:58:48 <EvanR_> its only there specifically for doing what your trying to stop
19:59:49 <jp_rider> ok..
20:00:10 <EvanR_> btw, why are you worried about state?
20:00:12 <jp_rider> i mean i'm ok with allowing lifting functions that live in the base monad
20:00:49 <EvanR_> the wrapper monad in generally cant know what its wrapping
20:01:18 <EvanR_> the user might use any monad
20:01:22 <jp_rider> right, but say it's IO
20:01:33 <jp_rider> the user probably should be able to call IO functions
20:01:46 <EvanR_> i thought you didnt want that
20:01:57 <jp_rider> im ok with that
20:02:03 <EvanR_> but not what
20:02:15 <jp_rider> i just don't want them modifying the internal state of the transformer
20:02:32 <EvanR_> oh i misunderstood, they cant do that even with lift
20:02:44 <jp_rider> ok great thanks
20:02:50 <EvanR_> also look at MonadIO
20:03:04 <EvanR_> :t liftIO
20:03:04 <lambdabot> MonadIO m => IO a -> m a
20:03:19 <jp_rider> ok cool thanks
20:03:39 <jp_rider> so going back to MonadBaseControl
20:04:05 <EvanR_> all your base?
20:04:17 <jp_rider> uh no an arbitrary base
20:04:55 <jp_rider> could a user use restoreM to a previous state by calling liftBaseWith multiple times and remembering the result?
20:05:08 <EvanR_> :t restoreM
20:05:09 <lambdabot> Not in scope: ‘restoreM’
20:05:17 <EvanR_> whats that
20:05:23 <jp_rider> http://hackage.haskell.org/package/monad-control-0.3.3.0/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl
20:07:09 <EvanR_> not sure what this is, but you must implement this for any pairs of monads you want to use it with
20:07:18 <EvanR_> it doesnt work for arbitrary monads
20:07:34 <jp_rider> i suppose that's fine
20:07:38 <johnw> jp_rider: you can write an extractM
20:07:38 <jp_rider> i just need it with IO
20:08:22 <johnw> jp_rider: can you describe exactly what you need?  I have a pretty deep familiarity with monad-control
20:08:27 <EvanR_> jp_rider: the latest version of this lib does not have restoreM
20:08:46 <jp_rider> o i should look at the latest version then..
20:08:51 <jp_rider> sure
20:09:02 <jp_rider> i have a monad transformer
20:09:03 <johnw> EvanR_: where are you seeing that?
20:09:26 <EvanR_> https://hackage.haskell.org/package/transformers-base-0.4.3/docs/Control-Monad-Base.html
20:09:28 <jp_rider> that keeps an internal state, and I want to prevent users from modifying this internal state
20:09:38 <EvanR_> hmm
20:09:51 <EvanR_> the links got crossed somewhere
20:09:55 <johnw> ah, ok
20:10:00 <johnw> jp_rider: ok
20:10:17 <johnw> jp_rider: you could expose only a MonadReader instance to them
20:10:59 <johnw> i.e., have your type and its instances in an Internal module; then make a newtype and give it fewer instances in an exported module
20:11:05 <jp_rider> ok, i guess im not sure how that would work
20:11:12 <johnw> that way you can use it however you like, but users will be restricted
20:11:30 <johnw> you just need to wrap/unwrap at the boundary points
20:11:31 <jp_rider> so I think i basically do something similar to that
20:12:01 <jp_rider> i don't export the constructor to the monad, or the ADT stored in the state
20:12:13 <johnw> but any instances will still get exposed
20:12:24 <johnw> you can't selectively choose for those
20:14:15 <jp_rider> like instances of my monad for some typeclass will still be exposed?
20:14:26 <johnw> yes
20:15:59 <jp_rider> but isn't that ok as long as the instances themselves don't expose the inner state or allow it to be modified?
20:16:09 <johnw> in that case, sure
20:16:18 <johnw> just make certain you don't have a MonadState instance or some such
20:16:41 <jp_rider> k
20:17:08 <jp_rider> so i guess the question is would a MonadBaseControl instance allow the state to be modified?
20:17:43 <johnw> let me check
20:18:02 <jp_rider> cool thanks
20:18:30 <johnw> in order to do that, they'd need to be able to construct an appropriate StM
20:18:36 <johnw> use a hidden type for your StM
20:18:50 <jp_rider> could they do a replay though?
20:19:09 <johnw> yes, they could reconstitute an earlier state
20:19:16 <johnw> but they couldn't invent their own state
20:19:29 <jp_rider> hmm ok that's what I feared
20:19:42 <johnw> but what's to stop them from holding onto an old state value anyway?
20:20:07 <johnw> hmm.. I guess they couldn't isolate it without monad-control
20:20:16 <johnw> since that's what that library is all about
20:21:02 <johnw> so, hiding your instances behind a newtype will let you offer them utility functions (like, withIO), but not expose the plumbing of monad-control
20:21:21 <jp_rider> right
20:21:42 <jp_rider> so I want to be able to run database transactions in my monad
20:21:59 <johnw> for that don't you only need MonadIO?
20:22:08 <jp_rider> maybe?
20:22:11 <johnw> yeah
20:22:17 <merijn> johnw: I guess he wants bracket for transactions?
20:22:17 <jp_rider> i thought it needed to be an instance of `MonadBaseControl`
20:22:21 <johnw> ah
20:22:26 <johnw> bracketing needs MonadBaseContral
20:22:52 <johnw> if all your database library needs you to do is to call functions in IO, then you only need MonadIO
20:23:07 <jp_rider> hmm let me look at my code
20:23:12 <johnw> if you need pass an action *in your monad* to a function that only *takes* IO, then you have to have MonadBaseContral
20:23:49 <jp_rider> o right, i think that's what I'm trying to do
20:23:57 <johnw> which IO function in particular?
20:25:59 <ronbrz> Hey, don't know if this is the right place to ask this, but I'm trying to use hi2-mode in emacs for haskell indentation, and its not working well. Every time I write a line of code, and hit enter to start a new line, it tabs over the line I had just written. Has anybody else experienced this?
20:26:48 <jp_rider> maybe it's easier to show you an example?
20:26:49 <jp_rider> http://lpaste.net/1814956920482562048
20:27:28 <jp_rider> i guess it's not IO exactly
20:27:30 <johnw> which line should I be looking at in particular?
20:27:42 <jp_rider> so if you look at get (18)
20:27:50 <jp_rider> line 18*
20:28:17 <johnw> these calls all look like they just need liftIO
20:28:52 <johnw> or some number of lift's
20:28:54 <jp_rider> is that so?
20:29:03 <johnw> which action is giving you issues?
20:29:15 <jp_rider> i'm trying to run it for yesod applications
20:29:50 <johnw> once you lift outside of your monad, you should be in the realm of regular Yesod-related actions
20:30:08 <jp_rider> so `get` wraps persist's `get`, and updates the internal state accordingly
20:30:40 <jp_rider> but `raiseLabelRead` live in my monad?
20:30:52 <jp_rider> lives*
20:30:58 <johnw> yes
20:31:02 <johnw> but what abuot its implementation?
20:31:06 <johnw> I feel like I'm missing something
20:31:14 <johnw> there's not enough context here
20:31:29 <johnw> as merijn hinted, there are certain scenarios when monad-control is typically used
20:31:45 <johnw> such as bracket, or forkIO, or async, etc.
20:32:07 <johnw> actions in some m, that only accept other actions in m, where you need to both call and pass your own monad
20:32:22 <johnw> (call from within, pass an action from)
20:33:35 <jp_rider> I guess the constraint for MonadBaseControl comes from runPool
20:33:36 <jp_rider> http://hackage.haskell.org/package/persistent-2.0.0.1/docs/Database-Persist-Class.html#v:runPool
20:34:34 <johnw> right
20:34:40 <johnw> so, can you do this: liftIO $ runPool ...
20:35:09 <johnw> internally, runPool is likely using bracket, so in order to be generalized over any monad, it needs MonadBaseControl
20:35:14 <jp_rider> but `f` could potentially be `get`
20:35:29 <jp_rider> so would it work since `get` lives in LMonadT?
20:35:30 <johnw> I see, f could be an action from your monad
20:35:35 <jp_rider> right
20:35:37 <johnw> then you, need MonadBaseControl
20:35:40 <johnw> s/you/yes
20:36:09 <jp_rider> hmm ok then :/
20:36:50 <jp_rider> well maybe that's not horrible
20:38:12 <jp_rider> and redefining the type in another internal module wouldn't prevent this replay sort of attack right?
20:38:43 <johnw> what do you mean by redefining?
20:39:04 <jp_rider> i guess just what you suggested earlier
20:39:13 <johnw> oh, newtype wrapping it with a public type
20:39:17 <jp_rider> right
20:39:30 <johnw> I don't think it will prevent a replay, no
20:39:43 <johnw> but then, just don't expose a MonadBaseControl instance
20:40:01 <johnw> you'll just need to provide your own custom runPool
20:41:42 <jp_rider> so runPool is abstracted over many different database backends right?
20:41:50 <johnw> looks like it
20:42:11 <jp_rider> I would have to redefine it for each backend?
20:42:28 <johnw> i don't see why that would be necessary
20:43:59 <jp_rider> well, if I want to provide a library that works for each backend, I think I would then
20:44:26 <johnw> you should be able to use rank-n types to encapsulate the genericity
20:44:48 <johnw> i.e., your newtype can wrap a family of types
20:44:59 <johnw> or, take it as a parameter to your newtype
20:45:04 <johnw> i wouldn't be sure without trying
20:46:54 <jp_rider> alright, i'll have to look into rank-n types then
20:47:50 <jp_rider> maybe just implementing MonadBaseControl is ok for now though
20:47:51 <xpika> how can i use a simple boxed type in ghci ?
20:48:01 <xpika> s/boxed/unboxed
20:48:03 <jp_rider> i already assume the user "does the right thing"
20:48:32 <merijn> xpika: I'm pretty sure ghci can't use unboxed types?
20:48:58 <xpika> merijn: i feared as much
20:49:01 <merijn> xpika: ghci uses bytecode and I don't think bytecode allows unboxed types
20:49:50 <jp_rider> johnw: thanks for all your help!!
20:50:55 <johnw> jp_rider: sure, let me know how it goes
21:05:02 <xpika> merijn: actually you can use unboxed typed you just need to :set -XMagicHash
21:06:41 <xpika> here http://lpaste.net/113131
21:10:58 <CodeWeaverX> Odd, it didn’t even occur ot me that ghci *couldn’t* use unboxed types.  I suppose any code loaded into it that used them could just ‘fake it’, waiting for proper compilation, but I just assumed it would be fine.
21:12:48 <CodeWeaverX> Mind you, it could still be ‘faking it’, but at least the syntax is allowed.  Just verified it.
21:12:58 <CodeWeaverX> I# (10# `remInt#` 3#)
21:13:09 <CodeWeaverX> (provided GHC.Exts is loaded as a module)
21:14:09 <AlecTaylor> hi
21:14:13 <CodeWeaverX> ho
21:14:48 <AlecTaylor> How do I use Data.MeldableHeap.Lazy (https://hackage.haskell.org/package/meldable-heap-2.0.3/docs/Data-MeldableHeap-Lazy.html), e.g.: given [1..500] do a findMin
21:14:53 <AlecTaylor> ?
21:14:59 <MP2E> hi ho, hi ho, it's off to Monads we go
21:15:28 <CodeWeaverX> Odd, I wouldn’t bother using anything other than a vector or list ot do a findmin of something like that. ;)
21:15:51 <AlecTaylor> CodeWeaverX: I'm exposing an FFI interface, just trying to understand how this package works
21:16:06 <CodeWeaverX> *nod*  Sorry, its late, and I’m a goofball.
21:16:17 <CodeWeaverX> *checks out the package in question*
21:17:19 <CodeWeaverX> Welllll, it seems like a simple fold would insert a bunch of items into an empty heap to build the full heap, at which point you’d just ask it for the minimum from the resulting heap.
21:18:03 * hackagebot hoogle-index 0.3.2 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.3.2 (BenGamari)
21:18:55 <gfixler> j cis
21:20:00 <jle`> how often do you write functions for monads in general in application code
21:20:11 <CodeWeaverX> Something like
21:20:12 <CodeWeaverX> fullHeap = foldl (\h i -> insert i h) empty [1..500]
21:20:13 <CodeWeaverX> min = findMin fullHeap
21:20:14 <CodeWeaverX> Which you could then collapse into a single line, and even get rid of the lambda using flip.
21:20:15 <jle`> i guess it becomes useful to do safety guaruntees
21:22:07 <CodeWeaverX> jle:  I’m new here, but I use them primarily when I need to interact with the user or with files or networks, etc, when things have to be explicitly sequenced.  Or if I absolutely must do something that involves sequencing things with mutation.  I try to keep that to a minimum though.  My ‘real work’ I tend ot keep pure. Mind you my projects have been tiny and using a small fraction of the cleverness of Haskell.
21:23:00 <CodeWeaverX> More important opinions incoming from long term denizens here. ;)
21:24:03 <jle`> CodeWeaverX: hm. i meant more like, writing functions like foo :: (Monad m) => ...
21:24:15 <jle`> i think for things that that, you can just write it straight-up with IO as your type
21:24:27 <CodeWeaverX> True.
21:25:04 <CodeWeaverX> *scratches chin trying to think of functions he might have written for any kind of monad and comes up short*
21:26:36 <CodeWeaverX> Well, that’s not *quite* true.  I’ve used the State monad for a few things that didn’t require somethign quite as heavy-weight as IO, and so that I could assemble the relevant code and execute it to do ‘pure work’ inside a pure function.
21:26:41 <trap_exit> haskell FTW
21:26:44 <CodeWeaverX> But that sitll doesn’t really address your question.
21:26:53 <trap_exit> name a singl eproject that can be done but cna't be done in haskell in 3 weeks
21:27:24 <CodeWeaverX> trap_exit:  Wouldn’t that rather depend on your comfort level in Haskell, and your fluency in the available packages that you didn’t have eo write yourself?
21:28:35 <gfixler> I think I could have spent 3 weeks on that CIS 194 Towers of Hanoi problem, if I hadn't gotten help
21:34:19 <Hijiri> I think it's easy to contrive a project that would take a long time
21:34:49 <jle`> CodeWeaverX: in that case, you would probably right it with State, and not polymorphic over Monad m =>
21:34:52 <Hijiri> Like print out the complete works of rms
21:34:54 <jle`> you might do MonadState m =>
21:35:04 <Hijiri> but it must be contained in one program without IO
21:35:09 <Hijiri> except for the printing
21:35:30 <muyfine> having trouble pulling mapping over an Either value inside IO
21:35:32 <muyfine> http://lpaste.net/113134
21:36:50 <muyfine> I want to fmap over the Either and fmap over the [GiftName]... having trouble composing that inside the do sequence
21:37:07 <muyfine> don't want to case expression apart everything
21:38:26 <exio4> trap_exit: a working compiler for C++
21:38:54 <trap_exit> I don't think one can even parse C++ in 3 weeks
21:39:03 <exio4> or well, any non computable function too!
21:39:37 <merijn> muyfine: Needs more fmap :)
21:39:38 <Hijiri> fmap f . fmap . fmap getGifts
21:39:41 <Hijiri> wait no
21:39:48 <merijn> Hijiri: Wrong :)
21:39:50 <Hijiri> fmap (fmap (fmap f)) getGifts
21:40:00 <merijn> :t fmap (fmap (fmap odd)
21:40:01 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:40:02 <merijn> eh
21:40:03 <muyfine> oh wow, let me try
21:40:04 <merijn> :t fmap (fmap (fmap odd))
21:40:05 <lambdabot> (Functor f2, Functor f1, Functor f, Integral a) => f (f1 (f2 a)) -> f (f1 (f2 Bool))
21:40:25 <merijn> muyfine: Remember that "fmap f" is just another function, and you can fmap any function :)
21:41:15 <merijn> muyfine: First one goes inside IO, the second inside Either, the last inside the []
21:41:48 <muyfine> and my f can apply to just a string, right?
21:44:39 <merijn> muyfine: If it has the right type
21:49:47 <jle`> > fmap (fmap (+3)) [Left 4, Right 10, Left 3]
21:49:49 <lambdabot>  [Left 4,Right 13,Left 3]
21:50:16 <jle`> > fmap (fmap (+3)) (Right [1,2,3,4])
21:50:18 <lambdabot>  Right [4,5,6,7]
21:50:32 <muyfine> merijn ugh, what am I doing wrong here? http://lpaste.net/2704720865420902400
21:51:39 <muyfine> oh, I shouldn't be using the do sequence to strip the IO?
21:52:20 <jle`> muyfine: why doesn't it work?
21:52:47 <muyfine> oh, that works: http://lpaste.net/4913751437722255360
21:55:48 <muyfine> thanks for the help!
21:58:49 <jle`> muyfine: btw, fwiw, we usually like to provide things in "unreturned" formats when possible.  that's because it's easy to just slap on the `return` later, but it's difficult to go backwards if we need to
21:59:04 <jle`> but judging from your snippet, that's probably a dummy impelmentation :P
21:59:41 <muyfine> yeah, just some pseudo code to get a the core of my problem
22:02:56 <CodeWeaverX> fmap into an IO?  Gotta remember that trick.
22:03:25 <fragamus> ok I have a V 9 Double and I need to turn it into a V 10 Double by adding an element on the end. Can anyone shed any light on this
22:04:15 <CodeWeaverX> YOu mentioned this earlier, fragamus… I keep wondering why you’re using a mathematical vector to do something that appears like you need an extensible vector type, or a list..
22:04:48 <CodeWeaverX> You’re using Linear right?
22:05:08 <CodeWeaverX> Not something I’m familiar with, except by looking at the package.
22:05:10 <usr> yes...
22:05:10 <fragamus> because I also need matrix operations
22:05:34 <fragamus> yes Linear
22:08:50 <CodeWeaverX> Well, it’ll probably end up copying your vector, but you could use its property of being foldable to turn it into a Data.Vector, append an element using Data.Vector’s API, and then convert it to a Linear.V with 10 elements using fromVector
22:09:28 <CodeWeaverX> I mean, that’d be a one-liner.  With Data.Vector being stream-fusionable, most of that work would probably get optimized away.
22:09:41 <CodeWeaverX> (I’ve never done it, just guessing)
22:11:51 <CodeWeaverX> Data.Vector.Unboxed, in particular.
22:14:12 <nshepperd> fixed length vectors are black magic to me
22:18:28 <carter> CodeWeaverX: thing is, i think unboxed vector doesn't have applicative / fmap instances
22:18:32 <carter> and linear style api needs those
22:18:40 <carter> so Data.Vector it'd have to be
22:18:54 <carter> though you CAN do a fmap like thing for unboxed vector
22:18:55 <CodeWeaverX> Yeah?  Let me check.
22:19:02 <carter> well
22:19:03 <carter> it cant
22:19:06 <merijn> unboxed isn't functor, because that can't work
22:19:11 <carter> yeah
22:19:27 <carter> you can do fmap *like* stuff, but not fmap
22:19:41 <CodeWeaverX> Well, it doesn’t have to be mappable, jsut able to be built from a fold, and then converted with fromVector.
22:19:51 <carter> no
22:19:59 <carter> wont work
22:20:13 <carter> the input and result types have to have corresponding vector instances :)
22:20:16 <ThreeOfEight> Does anybody have any experience with haskell-src-exts? It keeps rejecting identifiers with certain unicode characters (e.g. Japanese kana)
22:20:22 <CodeWeaverX> Alright, well, now i hav eto try it.
22:20:50 <carter> vectMap :: (Vector v a, Vector v b) => (a->b)-> v a -> v b
22:20:54 <carter> is what'd you get
22:20:59 <carter> look in Data.Vector.Generic
22:21:55 <CodeWeaverX> *grooves out to Tim Minchin while trying to prove smarter people than him wrong… seems appropriate*
22:22:20 <carter> i'd love to be wrong
22:22:21 <carter> but i'm not
22:22:22 <carter> :)
22:22:33 <carter> :t (<*>)
22:22:34 <CodeWeaverX> Cocky!  But possibly justified.
22:22:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:22:44 <carter> i wish we had unboxed (a->b)
22:22:48 <carter> that'd be SWEET
22:22:56 <carter> crash prone
22:22:57 <carter> but sweet
22:23:00 <carter> :)
22:24:16 <CodeWeaverX> Alright, while I flail finding out why your’e right, or making you look really silly (almost certainly the former, rest assured), why don’t you help the poor fellow?
22:24:32 <CodeWeaverX> Oh wait, you just said use the boxed version.
22:24:37 <carter> linear isn't suitable for what he wants
22:24:38 <CodeWeaverX> Well neener.
22:24:46 <CodeWeaverX> Yes, well, I said that first, now didn’t I?
22:24:49 <carter> yeah
22:25:11 <carter> or he could copy my sized list module
22:25:24 <carter> because adding something to the front/back is easy to define there
22:25:33 <carter> and he coudl probably define legal instances of all the various linear classes
22:25:57 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Shape.hs
22:26:16 <carter> fragamus: my Shape.hs can be stripped down a bit
22:26:21 <CodeWeaverX> And what is that doing *not* in the cabal package system?
22:26:32 <solatis> hmm i have a question that focusses rather on good application design than actual haskell
22:26:32 <carter> because its part of a more important package i'm writing :)
22:26:38 <carter> solatis: sweet
22:26:46 <merijn> ThreeOfEight: Are the kana complying with the lexical rules?
22:26:47 <carter> CodeWeaverX: thats just my array indexing data type
22:26:58 <merijn> ThreeOfEight: i.e. does it compile with normal GHC?
22:27:19 <CodeWeaverX> That’s not an excuse, if you’re willing to offer it to him anyway. ;)
22:27:21 <solatis> i have a lot of 'worker' applications that use various resources (specifically, they need a ZeroMQ input and output socket, and sometimes some HTTP connection manager)
22:27:35 <carter> CodeWeaverX: its not meant for that use case
22:27:40 <carter> but if he's keen on static sized things
22:27:57 <solatis> i assume it's best to just write a stand-alone function that uses these resources, and keep the actual resource acquisition *outside* of those functions
22:28:01 <solatis> am i correct?
22:28:14 <carter> sure
22:28:19 <carter> that sounds reasonable
22:28:21 <solatis> ok
22:28:40 <ThreeOfEight> merijn: yes
22:28:52 <carter> ThreeOfEight: report a bug! :)
22:29:03 <ThreeOfEight> all right
22:29:07 <ThreeOfEight> I was planning on fixing it myself
22:29:20 <carter> yay
22:29:24 <CodeWeaverX> Of course, actually installing Linear means pulling in the entire internet into my poor laptop.
22:29:26 <ThreeOfEight> but I am probably not familiar enough with Haskell's lexing rules
22:29:29 <carter> fragamus: CodeWeaverX  https://hackage.haskell.org/package/linear-1.10.1.2/docs/Linear-Vector.html
22:29:35 <carter> he should just use the linear instances for vector
22:29:39 <carter> and then use vector concat
22:29:55 <CodeWeaverX> STOP BEING BRILLIANT.  Okay, dont’ do that.
22:29:55 <solatis> now, when i want to write these using monadic code, i seem to run into troubles -- one monad expects a ZMQ z () to be returned, another one and IO (), etc -- is it generally better to try to have your functions return a monad as generic as possible, in essense, always prefer to return IO () ?
22:30:02 <solatis> (i hope i'm making sense)
22:30:12 <Zekka> solatis: How's IO particularly generic?
22:30:16 <ThreeOfEight> as I only want to count tokens, my current hack is to replace all characters that are isLetter, but not isUpper or isLower, to a Latin a
22:30:23 <carter> solatis: is zmq monad a monadIO instance?
22:30:30 <solatis> Zekka: well a lot of the monadic are instances of MonadIO
22:30:33 <solatis> carter: yes
22:30:38 <solatis> and it has liftIO
22:30:43 <Zekka> Generally when you're making code polymorphic over what monad to use, if you're following the mtl convention, you use a type like MonadIO m => a -> m ()
22:31:03 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/System-ZMQ4-Monadic.html
22:31:04 <Zekka> IO does not 'include' ZMQ z a, but MonadIO m => m a does
22:31:35 <solatis> i know, but i believe i can 'lift' the ZMQ monad to an IO monad, correct?
22:31:46 <Zekka> solatis: Yes, using runZMQ or the equivalent
22:31:51 <solatis> right
22:31:56 <Zekka> And you can lift IO operations using liftIO
22:32:15 <carter> the ZMQ monad is for resource handling rihgt?
22:32:22 <solatis> yeah
22:32:28 <solatis> acquisition and release
22:32:48 <solatis> i'm actually considering using the non-monadic code, and use my own bracket
22:34:13 <solatis> but i'm still trying to figure out what good application design is :)
22:34:36 <solatis> as in, all this function programming nonsense is so different
22:34:48 <solatis> so i have to re-learn how to design my applications properly
22:35:04 <carter> :)
22:35:14 <Zekka> solatis: I think prettiest would be to write your nonZMQ code either in the ZMQ monad if you don't need polymorphism, in IO with liftIO to turn them from IO into ZMQ z, or using MonadIO as a constraint
22:35:16 <carter> solatis: the part where you're like "fuuuu, i need to refacotr"
22:35:18 <carter> *refactor
22:35:22 <carter> is when things get magic
22:35:25 <Zekka> the latter two if you do need to intermix ZMQ z code with IO code
22:36:15 <Zekka> I'm undecided between the second two but your types will be a little less ugly if you do the second
22:36:32 <CodeWeaverX> On a more pragmatic manner, I cabal installed linear, and its module appears to be Linear with subcomponents Linear.Vector (for example).  Why can I not just
22:36:33 <CodeWeaverX> :m +Linear.Vector
22:36:33 <CodeWeaverX> ?
22:36:50 <Zekka> because you'll need to use existentials or rankntypes to start treating things with types that look ike MonadIO m => m a as passaroundable entities
22:37:32 <Zekka> It's basically just a question of whether you put your liftIO on the inside of your any-IO operations or on the outside
22:38:06 <CodeWeaverX> ghci is refusing to load that module for me.  How weird.
22:38:13 <carter> import it :)
22:38:15 <carter> idk
22:38:41 <Zekka> Using the IO monad by itself or through MonadIO instead of the ZMQ monad for code that doesn't explicitly need ZMQ is kind of a nice thing to do because it means you can statically guarantee that code doesn't do any unsightly ZMQ things
22:38:47 <solatis> thanks for the input
22:39:04 <solatis> yeah i think i just need to focus on keeping things simple at this point
22:39:06 <Zekka> the same reason it's nice to use Reader over State for a lot of programs
22:39:15 <solatis> and refactor when the time is right
22:39:31 <muyfine> If I have a type like IO (Either Bool [IO (Either Bool String)])
22:39:42 <muyfine> how do I go about flattening it to IO (Either Bool [String])
22:39:51 <Zekka> muyfine: You can't generally do that with monads, but you can do it with monad transformers
22:40:04 <Zekka> That looks like (EitherT Bool IO) String
22:40:11 <Zekka> where EitherT Bool IO is a monad
22:40:26 <Zekka> So for a type like that you would use join just like for any monad
22:41:06 <muyfine> ok, I'll look into that
22:41:09 <Zekka> muyfine: This is actually the reason monad transformers exist -- just given two monadic types, it's really hard to define join for the case where you put one on top of the other
22:41:19 <muyfine> I've run into join once before
22:41:31 <muyfine> not very familiar with it yet
22:42:04 <Zekka> Yeah. Even though monads provide Monad m => m (m a) -> m a, it's very hard to write (Monad m, Monad n) => m (n (m (n a))) -> m (n a)
22:42:14 <Zekka> You can't write it generally at all
22:42:36 <Zekka> (I think Traversable gets you closer to that kind of power but I haven't actually experimented too much with it)
22:42:48 <Zekka> muyfine: It's a prety important part of how monads work
22:42:56 <Zekka> (monads are basically applicatives with join)
22:43:09 <CodeWeaverX> This is messed.  Linear is the first package I’ve ever built that refuses to be loaded into GHCI… its like its invisible.
22:43:21 <Zekka> It's for situations a lot like what you've described, where you've got two layers of a monad stacked
22:43:30 <Zekka> Your case is slightly more complicated because I just noticed, you have a list intermediately
22:43:58 <Zekka> er, sorry, that is, it's more omplicated than just join with monad transformers
22:44:09 <ThreeOfEight> Zekka: Speaking of Monad and Applicative, I have been wondering about something for a while:
22:44:41 <ThreeOfEight> Under the Applicative–Monad proposal, Monad is supposed to be a subclass of Applicative
22:44:45 <ThreeOfEight> but what about Functor?
22:45:00 <Zekka> ThreeOfEight: I think Applicative is also to become a subclass of Functor, but I haven't read the proposal
22:45:06 <ThreeOfEight> okay
22:45:18 <Zekka> So by doing that monad would transitively become a subclass of functor and all wold be right with the wold
22:45:21 <ThreeOfEight> because at least in category-theoretical monads, there is always a functor
22:45:36 <Zekka> ThreeOfEight: It's generally considered a wart that they aren't already defined that way
22:45:43 <ThreeOfEight> Yes, I wasn't sure whether Monad “morally” implied Functor as well in Haskell
22:45:58 <ThreeOfEight> because the notation of a monad in Haskell is subtily different from that in category theory
22:46:12 <ThreeOfEight> and I wasn't sure whether I had grasped all the subtleties
22:46:16 <ThreeOfEight> thanks
22:46:24 <Zekka> ThreeOfEight: I'm not actually a mathematician and I can't speak too precisely to the relationship to category theory
22:47:21 <johnw> ThreeOfEight: in 7.10, Monad will imply Functor
22:47:26 <johnw> as well as Applicative
22:49:49 <Zekka> ThreeOfEight: Any Monad is a Functor anyway, isn't it? You can derive fmap from bind and return, although it's kind of getting things backward
22:50:14 <Zekka> fmap f x = x >>= (return . f)
22:51:11 <Zekka> So it doesn't make sense for a Monad not to be a Functor when the Monad operations are at least as powerful
22:52:34 <merijn> Zekka:  Applicative has always been a subclass of Functor
22:52:56 <Zekka> merijn: Oh, really? Let me check, although I'm sure you're right
22:53:12 <Zekka> Yeah, you are
22:53:33 <merijn> The reason Monad is not a subclass of Applicative is because Applicative was "invented" after Monad
22:53:41 <Zekka> Yeah, I'm aware of the history
22:53:45 <dfeuer> main = makeTheFurnaceWorkDammit
22:53:54 <Zekka> I'd actually thought that for consistency Applicative wasn't a subclass of Functor either thouh
22:54:29 <ThreeOfEight> oh
22:54:30 <ThreeOfEight> so did I
22:54:35 <ThreeOfEight> TIL
22:54:57 <dfeuer> merijn, do you know if there's any sensible way to express the Applicative laws using pure/fmap/liftA2 instead of pure and <*> ?
22:55:11 <ThreeOfEight> Zekka: well, in category-theoretic terms, a monad isn't a functor, but a functor is a part of a monad
22:56:01 <Zekka> ThreeOfEight: I'm not sure I know what the difference is between those two notions
22:56:14 <ThreeOfEight> a monad is a functor with two natural operations obeying certain laws, η (return) and μ (join)
22:56:26 <m00nlight> How to use unicode in haskell , like putStrLn ['x', '\178'] ==> x², but it seems the supersciprt in unicode is U+2072
22:57:12 <ThreeOfEight> and a functor is something that maps objects and morphisms of a category to objects and morphisms of another category
22:57:23 <Zekka> ThreeOfEight: How is that different from a Haskell monad other than that Haskell monads are phrased in terms of bind with join as an auxiliary operation?
22:57:32 <ThreeOfEight> in Haskell, as far as I know, that category is always Hask, the category of Haskell types with functions between these types as morphisms
22:57:56 <Zekka> Yeah, at least when you're speaking about ordinary operations between haskell values
22:58:12 <ThreeOfEight> and the object-lifting in Haskell monads is basically the type constructor and the morphism-lifting is fmap
22:58:19 <ThreeOfEight> What are “non-ordinary operations”?
22:58:19 <merijn> dfeuer: No idea, try the applicative paper?
22:58:41 <Zekka> ThreeOfEight: Sometimes people talk about things in types that have interesting structural properties
22:58:43 <dfeuer> merijn, they seem to do it with pure and <*>
22:59:14 <Zekka> things like the old "a monad is a monoid in the domain of endofunctors statement" which gets at how join is basically mappend but on things in the type
22:59:47 <merijn> ThreeOfEight: Correct, haskell's Functor is an endofunctor in the category Hask
23:00:12 <Zekka> ThreeOfEight: I'm mostly getting at when people apply those kinds of properties whih we usually use typeclasses to express to other kinds of entity in the language. But it's mostly a technical point
23:00:28 <ThreeOfEight> Zekka: okay, I've never seen Functor and other category-theoretical stuff in Haskell except in the context of Hask
23:01:02 <solatis> where can i find more information on how to write a function that accepts a callback that can be anything, as long as it accepts one (additional) parameter and returns IO ? is that where type constraints myFoo :: MonadIO a => (.. -> a) -> IO () comes into play?
23:01:04 <Zekka> ThreeOfEight: IIRC mmorph provides a version of Functor that operates on things in types but I don't remember the details because I haven't used it since a while ago
23:01:10 <ThreeOfEight> But after the last talk by Edward Kmett I saw on category stuff in Haskell, I had to suture my head back on. Twice. So what do I know.
23:01:20 <ThreeOfEight> (at least I think it was Edward Kmett)
23:01:39 <solatis> what is the terminology i need to be googling for?
23:01:41 <Zekka> That sounds like the kind of talk he might give but not the kind of talk uniquely he might give
23:01:53 <dfeuer> m00nlight, I think to use Unicode in Haskell, you just ... use it.
23:01:56 <Zekka> solatis: I'm not quite sure I understand what you're asking for
23:02:04 <Zekka> it sounds like you might want something along the lines of existentials
23:02:12 <Zekka> er, not existentials
23:02:13 <Zekka> ranktypes
23:02:27 <Zekka> solatis: Can you be more specific about what kind of type you want to have?
23:02:28 <solatis> hmm
23:02:34 <solatis> or continuations...
23:02:45 <m00nlight> dfeuer: so what does '\178' means?
23:03:01 <m00nlight> dfeuer: it seems not the unicode of superscript of 2
23:03:04 <Fuuzetsu> > ord 178
23:03:06 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
23:03:07 <lambdabot>    arising from the literal ‘178’
23:03:09 <Fuuzetsu> > chr 178
23:03:11 <lambdabot>  '\178'
23:03:14 <Fuuzetsu> thx
23:03:39 <Zekka> rankntypes*, my typing is poor
23:03:41 <haasn> Ÿ U+0178 LATIN CAPITAL LETTER Y WITH DIAERESIS, decimal: 376, HTML: &#376;, UTF-8: 0xC5 0xB8, block: Latin Extended-A, decomposition: U+0059 U+0308, lower: U+00FF
23:03:49 <haasn> Oh, wait; That's hex
23:03:58 <Fuuzetsu> > ord '²'
23:03:58 <sopvop> Are there any speed benefits using Word8 attoparsec instead of Char8 module for ascii?
23:04:00 <lambdabot>  178
23:04:09 <Zekka> solatis: The type of a function that takes a callback that can take anything and gives you an IO action is this
23:04:10 <ThreeOfEight> m00nlight: 178 is the two superscript in some (or all?) ANSI encodings
23:04:27 <Fuuzetsu> haasn: that's U+0178 which is not 178 dec
23:04:28 <ThreeOfEight> cf. http://www.fileformat.info/info/unicode/char/b2/index.htm
23:04:28 <solatis> Zekka: i currently have a function, that accepts two parameters (an input socket and an output socket) -- i want to wrap that function in a generic withHttp function, such that the function is now called with three arguemnts (input socket, output socket, and http connection manager) -- but the generic function should not be aware of what type of function it's adding the extra argument to
23:04:30 <Zekka> myFoo :: (forall a. a -> IO ()) -> IO ()
23:04:47 <Fuuzetsu> haasn: in fact, it says right there, decimal 376…
23:04:49 <m00nlight> ThreeOfEight: Thanks
23:04:58 <Zekka> Oh, OK
23:05:00 <ThreeOfEight> you can also write that in other ways
23:05:12 <Zekka> So the first function looks like a -> b -> IO c
23:05:14 <haasn> Fuuzetsu: That's what the “Oh wait; That's hex” means
23:05:20 <Fuuzetsu> I missed that part
23:05:20 <Zekka> the next one looks like a -> b -> ConnMgr -> IO c
23:05:35 <solatis> right
23:05:40 <Zekka> That gets you this type: (a -> b -> IO c) -> a -> b -> ConnMgr -> IO c
23:06:06 <m00nlight> ThreeOfEight: So in ansi encoding, the superscript of 0..9 is not continuous?
23:06:17 <Zekka> IF you wanted to use monadio you'd get (forall m. MonadIO m => a -> b -> m c) -> (forall m. MonadIO m => a -> b -> ConnMgr -> m c)
23:06:35 <Fuuzetsu> > map ord "⁰¹²³⁴⁵⁶⁷⁸⁹"
23:06:37 <lambdabot>  [8304,185,178,179,8308,8309,8310,8311,8312,8313]
23:06:46 <Fuuzetsu> heh
23:06:52 <ThreeOfEight> m00nlight: ANSI only has ¹ ² ³
23:07:00 <solatis> sheesh, i need to wrap my head around what that actually describes :)
23:07:11 <ThreeOfEight> Unicode has all the other digits
23:07:17 <Zekka> solatis: Let's look at a simpler one
23:07:19 <ThreeOfEight> but still uses the ANSI codes for ¹ ² ³
23:07:41 <ThreeOfEight> 8305-8307, which you would expect for ¹ ² ³, are actually not valid Unicode characters
23:07:45 <Zekka> (a -> Int) -> a -> Int takes a function from as to ints and gives you a function from as to ints
23:07:49 <Zekka> It's probably the identity function.
23:08:06 <ThreeOfEight> m00nlight: you can just write putStrLn "x²" and it works.
23:08:20 <ThreeOfEight> Haskell Strings generally support Unicode very unceremoniously.
23:08:22 <m00nlight> ThreeOfEight: Yes
23:08:40 <ThreeOfEight> Libraries might… not always do that. As you know from your haskell-src-exts issue ;)
23:08:41 <Zekka> (forall a. a -> Int) -> a -> Int takes a function from as to ints that hasn't neessarily been specialized to a particular a yet and turns it into a function from some arbitrary type to an int as far as I recall
23:08:52 <ThreeOfEight> (to which, by the way, I added my own issue, because I ran into the same bug yesterday)
23:08:56 <Zekka> (it's the same as (forall a. a -> Int) -> b -> Int unless I'm mistaken)
23:09:20 <Zekka> solatis: So the forall basically indicates when the variable is specialized
23:09:36 <ThreeOfEight> Zekka: it should be, because a and b are different bound variables
23:09:42 <Zekka> because when you write a forall in RankNTypes you're indicating that the variable isn't specialized yet for that entity
23:09:44 <ThreeOfEight> since they are bound by different quantifiers
23:09:52 <solatis> Zekka: awesome, i think i have the definition i want now
23:09:54 <Zekka> ThreeOfEight: I was pretty sure, but I don't trust my knowledge of edge ases
23:09:55 <solatis> withHttp :: (forall a . HC.Manager -> IO ()) -> IO ()
23:09:59 <solatis> at least, that compiles
23:10:06 <Zekka> solatis: I don't know what the a is doing for you though
23:10:20 <solatis> yeah, what is that a ?
23:10:22 <Zekka> you might as well be writing withHttp :: (HC.Manager -> IO ()) -> IO ()
23:10:37 <solatis> oh sheesh of course
23:10:41 <solatis> and then use currying
23:10:45 <Zekka> Look at i.e. this:  withHttp :: (forall a. a -> HC.Manager -> IO ()) -> IO ()
23:10:57 <Zekka> This says that it can take absolutely an a and an HC.Manager to get you an IO ()
23:11:01 <Zekka> absolutely any*
23:11:09 <solatis> right
23:11:10 <Zekka> (It probably doesn't do very much with that a because it has no idea what it is)
23:11:35 <solatis> so what is the difference between that and the version without 'forall a. a ->' ?
23:11:44 <solatis> what does that statement do anyway?
23:12:02 <Zekka> solatis: The one without hte forall a. a -> doesn't take an a and the a it doesn't take can't be absolutely anything
23:12:11 <Zekka> Let me compare three different types for you
23:12:42 <Zekka> (a -> Int) -> Int takes a function taking an a whose type it might already know which returns an int, and gives it an int
23:13:06 <Zekka> Things you can pass to it are id :: Int -> Int, id :: a -> a, (+1) :: Int -> Int, addOneGen :: Num a => a -> Int
23:13:30 <Zekka> (forall a. a -> Int) -> Int takes a function taking absolutely any a (it doesn't know) which returns an int, and gives it an int
23:13:42 <ski> solatis : `forall a. (..a..) -> ...' is the type of a polymorphic function. `(forall a. ..a..) -> ...' is the type of a function expecting a polymorphic argument. see the difference ?
23:14:10 <Zekka> It can only take funcctions whose types actually look like a -> Int: it can't take an Int -> Int or a Num a => a -> Int
23:14:20 <Zekka> it can only take functions willing to take absolutely anything
23:14:40 <solatis> Int -> Int is not the same as a -> Int ?
23:14:42 <Zekka> And finally, (Int) -> Int, whichc is what your code looks like in this analogy, doesn't have a polymorphic argument and doesn't make any assumptions
23:14:43 <merijn> solatis: The short summary of the difference is: Who gets to pick 'a'
23:14:47 <solatis> i thought 'a' could basicly mean anything?
23:15:02 <Zekka> solatis: It depends on where the a gets its type from
23:15:10 <solatis> right
23:15:17 <solatis> and 'forall a . a' means 'anything'
23:15:18 <ski> solatis : so, `a' means whatever type it stands for in the current context
23:15:28 <merijn> solatis: If you have "(a -> Int) -> Bool" the function is saying "give me a function from an 'a' (you pick which!) and I'll give you a Bool
23:15:41 <solatis> which is what i want!
23:16:02 <Zekka> solatis: So, for instance, you can pass itan (Int -> Int), or a (Char -> Int), etc. and it will be happy
23:16:07 <merijn> solatis: "(forall a . a -> Int) -> Bool" is saying "give me a function that can take ALL a's (I'll pick which a to use) and I'll give you a Bool"
23:16:18 <Zekka> An (a -> Int) -> Bool can be specialized to a (Char -> Int) -> Bool or an (Int -> Int) -> Bool
23:16:38 <ski> solatis : if you have a type signature `foo :: ..a..b..', then that's *usually* a shorthand for `foo :: forall a b. ..a..b..'. it's the `forall' here that makes `foo' polymorphic, that allows any concrete types `T' and `U' to be (uniformly) substituted for `a' and `b' in the type of `foo', getting a sample concrete type `..T..U..'
23:16:52 <Zekka> But a (forall a. a -> Int) -> Bool can't be specialized to any of those because the forall is in the way
23:17:09 <Zekka> and it says it has to apply to any a the receiving function wants
23:17:14 <solatis> ok
23:17:26 <solatis> i'm going to copy/paste everything that was just said in here
23:17:29 <solatis> and start hacking around
23:17:33 <Zekka> Don't worry, this took me a little while to figure out
23:17:39 <ski> solatis : so, since `length :: forall a. [a} -> Int', we can (remove the `forall a. ' and) replace the `a' by any type, getting e.g. `length :: [Int] -> Int' or `length :: [Bool -> Float] -> Int'
23:17:45 <solatis> looks like i have enough information to work with, now i need to digest it all
23:17:45 <Zekka> and I'm still occasionally unsure of myself because even tohugh I know the rules, it's a moderately thorny topic
23:18:10 <solatis> yeah i just need to read up on the basics of all this
23:18:34 <ski> solatis : and because `map :: forall a b. (a -> b) -> ([a] -> [b])', we can get e.g. `map :: (Int -> String) -> ([Int] -> [String])'
23:18:38 <solatis> i have the tendency to dive into complex things without understanding the basics
23:18:41 <Zekka> I think what was most helpful for me was just seeing cases where a function using a forall can't be specialized where a function not using a forall can
23:18:53 <Zekka> er, a function type
23:19:03 <Zekka> forall is an operation on types, not on values
23:19:13 <Zekka> although it's not really an operation
23:19:20 <solatis> ok
23:19:22 <solatis> basicly
23:19:26 <solatis> what i'm trying to solve
23:19:27 <ski> solatis : however, we can't get e.g. `map :: (Int -> String) -> ([String] -> [Bool])' since in each specific use, every `a' inside the `forall a b.' must be replaced by the same type (and likewise for `b')
23:19:52 <ThreeOfEight> solatis: you may find this example instructive: http://downthetypehole.de/paste/vhrZIbFY
23:19:59 <ski> Zekka : do you mean a function using `forall' in the type for its argument ?
23:20:02 <solatis> is to be able to 'stack' multiple (withHttp . withZeroMQ . withBlah) myCallback
23:20:16 <Zekka> ski: Yeah.
23:20:16 <solatis> if that makes sense
23:20:25 <ThreeOfEight> f gives you a type error, because h has to have the same type in the right-hand side of the equation
23:20:27 <CodeWeaverX> Zekka, thank you for adding a useful explanation for the strange uses of forall.  That actually helped.  Somewhat.
23:20:39 <ThreeOfEight> i.e. the type a -> String for a /fixed/ a
23:20:55 <ThreeOfEight> you can't have a = Int for the first occurrence and a = String for the second occurence
23:20:58 <Zekka> ski: I know that all polymorphic functions can be written using explicit foralls, but I don't think my intuition for that helped very much wehn I was figuring it out
23:21:03 <ThreeOfEight> but in g, with forall, it works fine
23:21:07 <solatis> ThreeOfEight: ahh i understand
23:21:11 <ThreeOfEight> because there, h has the type (forall a. a -> String)
23:21:18 <ski> Zekka : ok
23:21:21 <ThreeOfEight> so you can instantiate the a differently every time
23:21:22 <solatis> so if i want to 'force' everyone to use the IO () type, i don't use forall
23:21:32 <ski> Zekka : it probably helps to understand contravariance and covariance
23:21:45 <ThreeOfEight> it should also be noted that, unless I am very mistaken, (a -> String) -> IO() is the same as forall a. (a -> String) -> IO ()
23:21:47 <solatis> as in, that everyone callback should always return IO ()
23:21:58 <Zekka> Types like id's type just seemed like a completely different thing from types like (forall a. a -> Int) -> b -> Int's
23:21:59 <ThreeOfEight> so there is an explicit forall quantifier for every free variable around the type
23:22:00 <ski> ThreeOfEight : it's not the same type
23:22:07 <ThreeOfEight> ski: but it's morally the same, is it not?
23:22:28 <Zekka> ski: Are there any cases where you could use one and not the other?
23:23:06 <ThreeOfEight> solatis: another interesting case is the type (forall a. a)
23:23:18 <solatis> :t (forall a. a)
23:23:19 <lambdabot>     Not in scope: ‘forall’
23:23:19 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
23:23:28 <ThreeOfEight> that is actually ⊥, the empty type
23:23:46 <Zekka> The only members of that type are things that don't terminate in ordinary values
23:23:52 <Zekka> > :t let x = x in x
23:23:54 <ThreeOfEight> because if some value x had type (forall a. a), that means that this value can have /every/ type at the same time
23:23:55 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:23:55 <Zekka> er, oops
23:23:57 <Zekka> :t let x = x in x
23:23:58 <lambdabot> t
23:24:03 <Zekka> (pretend the t is an a)
23:24:16 <ThreeOfEight> :t undefined :: (forall a. a)
23:24:17 <lambdabot> a
23:24:18 <Zekka> :t error "oh god I'm trapped in a unification factory"
23:24:19 <lambdabot> a
23:24:37 <ski> ThreeOfEight : e.g. `newtype Foo = MkFoo ((a -> String) -> IO ())' is illegal (because the type variable `a' isn't bound), but `newtype Bar a = MkBar (forall a. (a -> String) -> IO ())' (if you enable at least the `PolymorphicComponents' extension)
23:24:46 <ski> ThreeOfEight : so no, it's not "morally the same"
23:25:24 <ThreeOfEight> ski: but in the context of a function type signature, free type variables are implicitly universally quantified, right?
23:25:53 <Zekka> ski: Well, aren't you just arguing that when you put something outside the type so that the implicit quantifier is moved to somewhere different than the explicit one which previously coincided, they don't coincide any more?
23:26:11 <Zekka> Because I thought his understanding of the implicit quantifier rule was correct
23:26:22 <ski> ThreeOfEight : just like saying that `A * B = B * A' isn't morally the same as saying `forall A B. A * B = B * A' (e.g. we might be talking about matrix multiplication, and the former might be true of some particular matrices `A' and `B' that happens to be in scope, and which we're talking about. the latter would be false in the matrix context, though, since matrix multiplication, in general, isn't commutative)
23:26:48 <Aquana> why is maybe defined as "Nothing | Just a" and not as "Nothing | a"?
23:27:20 <Aquana> what exactly is "Just"?
23:28:21 <lieven_> Aquana: a data constructor.
23:28:24 <ski> ThreeOfEight : "in the context of a function type signature, free type variables are implicitly universally quantified" -- that's almost right. an exception is a signature inside a `class' declaration -- also, if we ever get locally defined types, or type parameters for modules (which would scope over the whole body of the module), then it would be incorrect in these cases as well
23:28:25 <Zekka> Aquana: Just is a name for a particular way of constructing a Maybe
23:28:28 <lieven_> :t Just
23:28:29 <lambdabot> a -> Maybe a
23:28:35 <ThreeOfEight> ski: I come from theoretical theorem proving, I actually did my MSc in it. Trust me, I know a thing or two about logic and I know what free variables are.
23:28:46 <lieven_> > :t Just
23:28:48 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:28:55 <Zekka> Ways of constructing a type defined using data are called data constructors
23:29:05 <Zekka> So they're ways of getting from other types to Maybe a and back
23:29:07 <lieven_> hmmm seems the bot doesn't want to play. Just :: a -> Maybe a
23:29:26 <ThreeOfEight> All I meant to say was that when you write down a function type signature like the ones in my example, the free variables get universally quantified
23:29:40 <ThreeOfEight> which is also the convention in Isabelle
23:29:55 <ski> ThreeOfEight : also see <http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/>
23:30:05 <ThreeOfEight> ah, that should answer my question then
23:30:26 <Aquana> thank you!
23:30:59 <Zekka> Aquana: If a alone were an option for Maybe, then it would be very hard to construct that option
23:31:08 <Zekka> because it would have to be a member of both Maybe a and a at the same time
23:31:11 <ski> Aquana : you can't just combine types with `|'s in a `data' declaration. each alternative has to be headed by a data constructor
23:31:22 <ThreeOfEight> okay, no, that does not really answer my question
23:32:01 <Zekka> data NotAn a = a -- is 1 an Int or a NotAn Int? It matches the pattern for the only branch of NotMe
23:32:03 <ThreeOfEight> ski: it /is/ a convention in logic, at the very least in theorem proving, to implicitly take the universally-quantified closure of the statement when you state a lemma
23:32:08 <Zekka> er, branch of NotAn*
23:32:21 <ThreeOfEight> that's just an abbreviation, because otherwise, you'd have to write lots of quantifiers all the time
23:32:39 <ThreeOfEight> and the same convention works for function type signatures
23:32:47 <ski> Aquana : if Haskell had subtyping (like O'Haskell,Timber,...), then one could possibly allow something like you were suggesting, at least in some cases. but since Haskell has no subtyping, you have to implicitly convert between different types. for `Maybe', `Just' is the way to convert from a value of any particular type `T' you want to a value of type `Maybe T'
23:33:00 <ThreeOfEight> although I did not (consciously) know about the exception of signatures inside type classes
23:33:12 <ThreeOfEight> So that would be interesting to know. What exactly /is/ the convention there?
23:33:20 <lpaste> solatis pasted “Ok, I'm still doing it wrong” at http://lpaste.net/113135
23:33:29 <solatis> what is wrong there?
23:33:30 <ski> ThreeOfEight : yes, it is a convention for not having to type as much
23:33:39 <Aquana> ski: oh, it doesn't have subtyping! How are numbers handled then?
23:33:51 <solatis> it's the declaration of 'withHttp'
23:34:02 <solatis> or sorry
23:34:08 <solatis> i have to include compile error message
23:34:10 <solatis> hold on
23:34:18 <ski> Aquana : each number type is its own type. however the basic numeric operations (including the numeric literals/numerals !) are overloaded :)
23:34:41 <lpaste> solatis revised “Ok, I'm still doing it wrong”: “No title” at http://lpaste.net/113135
23:34:45 <ThreeOfEight> class Foo a where bar :: a -> b -> (a,b)
23:34:47 <Zekka> Aquana: Functions that are polymorphic over numbers are a slightly different matter
23:34:54 <ThreeOfEight> This works fine, and the b is indeed universally quantified
23:34:57 <ThreeOfEight> the a, of course, isn't
23:34:59 * ski nods
23:35:01 <ThreeOfEight> but the a isn't a free variable
23:35:06 <Zekka> A function like (+1) has the type Num a => a -> a
23:35:10 <ThreeOfEight> it's bound by the context of the functor
23:35:14 <ThreeOfEight> er
23:35:20 <ThreeOfEight> the context of the class declaration
23:35:20 <Zekka> which says that for a numeric type a, you take an a and get one out
23:35:21 <ski> of course `a' is a free variable of `a -> b -> (a,b)'
23:35:40 <ThreeOfEight> if you have no context, yes
23:35:43 <ThreeOfEight> but you /have/ a context
23:35:46 <Zekka> You can think of Num a as the type of a group of functions explaining the numeric operations for type a
23:35:50 <ThreeOfEight> namely the class _ where
23:36:13 <ski> `a' is a free variable in `a -> b -> (a,b)'. `a' is not a free variable in `class Foo a where bar :: a -> b -> (a,b)'
23:36:18 <Zekka> where an example of the group of functions for a specific type is called a typeclass instance
23:36:34 <ThreeOfEight> Okay, fine, let's phrase it this way:
23:36:36 <Zekka> Aquana: Does that help?
23:36:37 * ski is probably violently agreeing with ThreeOfEight here
23:37:01 <Aquana> Zekka: i'm still trying to make sense of it
23:37:27 <ThreeOfEight> In function type signatures, free variables that are not bound in the current context (e.g. by a class declaration) are implicitly universally quantified.
23:37:34 <Zekka> Aquana: Basically, how you handle polymorphism over specific kinds of thing in Haskell is pretty much an instance of a simpler pattern
23:38:10 <ski> ThreeOfEight : *nod*
23:38:23 <ThreeOfEight> I think my first version of this statement pretty much said as much, but I agree that there could potentially be some confusion.
23:38:47 <Zekka> If you have modules/records and the ability to say "OK, bind this variable to anything you want" (types like a -> Int where a can be bound to anything), you can get something pretty clcose to how Haskell's polymorphism-over-types-that-behave-in-a-specific-way  through typeclasses
23:38:49 <ski> in Prolog, variables are universally quantified over clauses (at least to a first approximation)
23:39:31 <Maxdamantus> I don't think it makes sense to include class constraints there.
23:39:36 <ski> Aquana : what in particular are you wondering about ?
23:39:39 <Maxdamantus> They're still just as universally quantified.
23:39:48 <Zekka> Also, hopefully the vocabulary doesn't irk people
23:40:07 <Zekka> I'm not that terminologically adept but even in cases where I know the right term I try to use simpler language if I think the right term will be confusing to people who don't know it
23:40:12 <ski> Maxdamantus : the question wasn't whether there were any constraints or not. the question was *where* the variables were bound
23:41:54 <Maxdamantus> using what Zekka said, about `Num a` being a type, `Num a -> (a -> a)`
23:42:13 <Zekka> Numbers might be a bad example to start from because we tend to think of numeric operations as really primitive and fundamental
23:42:17 <Zekka> So let's think about Show
23:42:30 <Zekka> This is how it looks as a typeclass: class Show a where show :: a -> String
23:42:33 <Maxdamantus> it works like that in Idris, fwiw
23:42:41 <Maxdamantus> the (Monad IO) %instance
23:42:51 <Aquana> ski: if "Maybe a = Nothing | a" doesn't work because you can't decide if something is a or Maybe a, how do numbers work when 5 can be both a Num and Integer?
23:42:52 <Zekka> This is how it looks as data: data Show a = Show { show :: a -> String }
23:43:04 <Zekka> Aquana: 5 can't be a num
23:43:27 <Zekka> Num isn't a type but a typeclass - Num a is a type in our analogy, though, but 5 isn't one
23:43:47 <Zekka> If 5 is an a, then it's an a which implicitly comes with a Num a that defines its operations
23:44:00 <merijn> Zekka: Well, depending on how pedantic you are, Num is in fact a type
23:44:04 <merijn> Zekka: Just not a type of kind *
23:44:13 <Zekka> merijn: I didn't want to get into that! But yes, that's correct
23:44:16 <Zekka> it's an * -> Constraint
23:44:30 <ski> Aquana : well. "5 can be both a Num and Integer" isn't quite right. `Integer' is a particular example of a (numeric) type, `Num' however is a type class, namelly the type class that's used to "keep track" of the "numeric" types
23:44:50 <Zekka> An Integer can have a Num -- that is, you can define a Num Integer
23:44:53 * Maxdamantus never liked calling things not of kind * "types" :(
23:44:55 <Zekka> where Num a is the numeric operations for a type a
23:45:04 <Zekka> Maxdamantus: I don't really like it but I tolerate it
23:45:07 <ski> Aquana : some types are "numeric", like `Int',`Integer',`Float',`Double',`Rational',`Complex Double',...
23:45:30 <ski> Aquana : some aren't, like `Bool',`Bool -> String',`[Integer]',`IO Integer',...
23:45:39 <Zekka> Aquana: And, for a being a type, a being "numeric" means that you can define a Num a
23:45:48 <ThreeOfEight> Zekka, Maxdamantus: is that a convention coming from dependent types?
23:45:53 <Aquana> what is a for "5 :: Num a => a"?
23:46:13 <Zekka> Aquana: It's not specialized yet
23:46:17 <Maxdamantus> ThreeOfEight: the `Num Int` thing being a type? I don't think so.
23:46:20 <ski> Aquana : do you understand basic polymorphism, like for `length :: [a] -> Int' ?
23:46:24 <Zekka> But if you operate on an Int with it it will probably be specialized to Int
23:46:31 <Zekka> ThreeOfEight: I don't think it's unique to dependently typed languages
23:46:36 <ThreeOfEight> Maxdamantus: what about, say, List being a type?
23:46:37 <Zekka> I know at least Scala does it too
23:46:40 <Maxdamantus> ThreeOfEight: I suspect the reason it's not an actual type in Haskell is because Haskell doesn't have rank-2 polymorphism.
23:46:40 <ThreeOfEight> of kind * → *
23:46:46 <Maxdamantus> Oh.
23:47:08 <Aquana> ski: in general, yes. I'm new to Haskell
23:47:14 <Maxdamantus> Dunno.
23:47:17 <ThreeOfEight> I have yet to wrap my head around dependent types
23:47:25 <ski> Maxdamantus : i usually call types of kind `*' "concrete types" (or "inhabitable types")
23:47:33 <Zekka> Personally I feel like treating typeclass instances as actual values where the typeclasses are types is a little messy without something like Reader to handle the ugliness in composing things
23:47:49 <ski> Aquana : which other statically typed languages do you know ?
23:47:50 <ThreeOfEight> Every time I try Idris, I hack about for half an hour or so and then run into some problem I can't resolve and stop.
23:47:55 <Zekka> So in Haskell you can compose ((Num a) => a -> a)s without pain
23:47:56 <Maxdamantus> ski: is a void type an inhabitable type?
23:48:02 <ski> Maxdamantus : yes
23:48:16 <Zekka> But in a language that makese Num a value you need to compose (Num a -> a -> a)s differently than you compose (a -> a)s
23:48:16 <Maxdamantus> because expressions can inhabit them?
23:48:32 <ski> Maxdamantus : it's a type for which it makes sense to *ask* whether the type has any (total, say) elements
23:48:33 <Zekka> Like I said, this is basically the Reader pattern
23:48:49 <Aquana> ski: C, Java, a bit C++. Some others probably that I don't remember right now
23:48:59 <ThreeOfEight> Somehow, I think void type is not a good name for it.
23:49:18 <ThreeOfEight> Or what exactly do you mean by void type?
23:49:21 <ski> Aquana : i'm asking because people are commoly using the term "polymorphism" in object-oriented languages in a quite different sense from how it is used in Haskell
23:49:23 <Maxdamantus> data Void
23:49:23 <ThreeOfEight> The bottom type or the unit type?
23:49:35 <Maxdamantus> a type with no values.
23:49:41 <ThreeOfEight> ah, so a bottom type
23:49:52 <ThreeOfEight> because at least Wikipedia calls () a “void type”
23:49:58 <ThreeOfEight> in analogy to the void in C, C++, etc.
23:50:07 <Maxdamantus> I think that's a bad analogy.
23:50:09 <ThreeOfEight> okay, in that case, yes, void seems like a reasonable name for it
23:50:11 <ThreeOfEight> Maxdamantus: I agree
23:50:13 <ski> Aquana : in Haskell (and SML,OCaml,F#,Mercury,...) "polymorphism" is short for "parametric polymorphism" (sometimes aka "generics", i think e.g. in Java)
23:50:14 <mornfall> ThreeOfEight: bottom can be of any type (in Haskell, anyway)
23:50:17 <Zekka> I think Haskell's rules for implicitthings like constraints are really useful for making things compose, etc. in an intuitive way
23:50:20 <ThreeOfEight> if “void” isn't empty, what is
23:50:24 <Maxdamantus> There is also no void value in C (and I suspect C++).
23:50:46 <Zekka> er, like typeclass instances*
23:51:01 <mornfall> Maxdamantus: no, and there's also empty struct which is more analogous to () than void
23:51:02 <ThreeOfEight> Maxdamantus: yes, but there are functions like Int → void in C/C++
23:51:05 <Zekka> (I hear Scala gets really thick into this territory in cool ways but I don't know Scala very well.)
23:51:08 <ski> Aquana : while in OO, "polymorphism" usually means "inclusion polymorphism", which is all about subtyping
23:51:11 <ThreeOfEight> so that is more like () than a bottom type
23:51:13 <Aquana> ski: I know polymorphism as a function that works with different types
23:51:15 <ThreeOfEight> even though there are no actual void values
23:51:15 <Maxdamantus> mornfall: empty struct?
23:51:21 <mornfall> Maxdamantus: in C(++)
23:51:28 <Zekka> ThreeOfEight: It's more like unit because even if they return nothing useful, they terminate, right?
23:51:35 <mornfall> Maxdamantus: empty cartesian product if you like
23:51:37 <Maxdamantus> mornfall: do you mean an incomplete struct type? C doesn't allow struct types without elements.
23:51:50 <mornfall> well, C++ definitely does
23:51:50 <ThreeOfEight> Zekka: yes, I'd say so
23:52:05 <ThreeOfEight> but it's probably pointless to think of C functions as connected in any way to mathematical functions anyway
23:52:12 <ski> Aquana : for inclusiong polymorphism, a function may work for all values of (some specific) type `T', and then also for all values of *subtypes* of the type `T'
23:52:19 <ski> s/inclusiong/inclusion/
23:52:20 <dfeuer> Can someone explain why replacing normal tuples with unboxed ones is leading me to get WEIRD type errors about type variables escaping and stuff about skolems, whatever those are?
23:52:32 <Maxdamantus> Mm, I guess because C++ lets you write methods in structs.
23:52:50 <merijn> dfeuer: Can't unbox polymorphic types?
23:53:02 <merijn> dfeuer: Are you putting anything non-monomorphic in there?
23:53:06 <mornfall> Maxdamantus: empty struct types are all diferent, so they are used as tags
23:53:20 <ski> Aquana : for parametric polymorphism, a function may work for all types `T' whatsoever (and it can't detect what actual type `T' is being used by the caller. this can be very useful for refactoring and reasoning about code)
23:53:23 <dfeuer> Yes, merijn, but I don't *think* that's inherently illegal, is it?
23:53:39 <merijn> dfeuer: It is
23:53:44 <dfeuer> Oh....
23:53:53 <merijn> dfeuer: You can never unbox polymorphic values
23:54:00 <merijn> afaik
23:54:13 <merijn> unboxing requires a fixed, known size
23:54:14 <mornfall> well, how would you :)
23:54:40 * ski thinks merijn probably means values typed by a type variable, as opposed to polymorphic values ..
23:54:42 <merijn> mornfall: Well, you could have a polymorphic container, where you unbox the container but not the value inside?
23:55:02 <mornfall> merijn: that container is the box though, isn't it
23:55:05 <ski> Aquana : makes any sense at all ?
23:55:07 <mornfall> merijn: how exactly is it implemented is a detail
23:55:17 <merijn> mornfall: I'm thinking containers in containers
23:55:24 <Aquana> ski: One minute
23:56:03 <mornfall> merijn: I'm not sure what kind of container you mean :) containers are “boxed” even in low-level languages
23:56:43 <ski> whee !
23:56:46 <dfeuer> No, merijn, you seem to be wrong.
23:56:46 <mornfall> uh, netjoin detection fail
23:57:16 <mornfall> whatever merijn said is moot now, it scrolled way past the end of the screen :D
23:57:46 <dfeuer> merijn, unboxed tuples don't seem to be unboxed in quite the same sense that other unboxed things are unboxed.
23:58:02 <ski> dfeuer : right
23:58:26 <mornfall> but unboxed tuples can contain boxed values, somehow
23:58:29 * hackagebot StateVar 1.0.1.0 - State variables  http://hackage.haskell.org/package/StateVar-1.0.1.0 (SvenPanne)
23:58:42 <ski> (and for some reason, unboxd tuples aren't allowed as arguments ..)
23:59:00 <dfeuer> ski, and yet ... changing the normal tuples to unboxed ones got me weird type errors.
23:59:08 <dfeuer> ski, I'm told you can now.
23:59:14 <dfeuer> But you can't store them in data structures.
23:59:17 * dfeuer should be asleeeeep.
23:59:29 <ski> mornfall : typically, i think unboxed tuples will assign their components directly to registers (or to stack slots)
23:59:38 <ski> dfeuer : ok
23:59:46 <mornfall> dfeuer: the only thing you are allowed to do on an unboxed tuple is case
23:59:59 <dfeuer> mornfall, that is old, I think.
23:59:59 <ski> (makes sense that you can't store them in datastructures, i think)
