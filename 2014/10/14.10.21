00:00:16 <Maxdamantus> which they're not, unless you're talking about implementation details.
00:00:18 <Hijiri> premade curry?
00:00:23 <solatis> timmansfield: feel free to interrupt us
00:00:27 <Cale> hehe, yeah, premade curry :)
00:00:32 <Cale> :t curry
00:00:32 <LeoTal> What helped me with that - especially what was meant by "foo bar baz == (foo bar) baz" was Smullyan's _To Mock a Mockingbird_, it seems feasible to show people a few exercises from the book if they're confused by that
00:00:33 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:00:46 * hackagebot keter 1.3.5 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.5 (MichaelSnoyman)
00:00:46 * hackagebot yesod-bin 1.4.0.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.4 (MichaelSnoyman)
00:00:49 <dmj`> timmansfield: whats your question
00:01:06 <ThreeOfEight> In my linear algebra course, I once had this problem where I was supposed to prove that Hom(U×V,W) is isomorphic to Hom(U,Hom(V,W))
00:01:10 <Cale> ^^ this is currying -- taking a function which accepts a pair (or other tuple) as its argument, and turning it into a function which takes the first part of that tuple, and produces another function.
00:01:13 <ThreeOfEight> and they stated the question in a really complicated way
00:01:22 <ThreeOfEight> it took me about 15 minutes to figure out that they meant currying
00:01:37 <ThreeOfEight> and the entire proof would have been much nicer with FP notation
00:01:42 <Cale> ThreeOfEight: Of course, once you figure out what the map is, you also have to show it's linear, but I agree.
00:01:47 <timmansfield> Thanks solatis. I'm working through Real World Haskell and a lot of the examples (CH1) seem to have the type: Integer, but when I type them into ghci, it reports the type: Num a => a - is that just a version thing?
00:01:58 <ThreeOfEight> Cale: yes, of course, but that is trivial
00:02:05 <ThreeOfEight> well the entire problem and proof are trivial
00:02:23 <ThreeOfEight> but it took me ages to figure out what the problem even meant
00:02:46 <ThreeOfEight> That said, a large number of my proofs in algebra I did mechanically without ever developing an intuition for it
00:02:57 <Hijiri> Num is something called a typeclass, and in this case it's saying that the type variable a implements some functions that "numerical" types should have
00:03:07 <Hijiri> at this point you don't really need to understand typeclasses
00:03:22 <Hijiri> Just know that Num a => ... means that "a" acts like a number
00:03:33 <ThreeOfEight> timmansfield: 2 can be an Integer, but 2 can also be a Double or a Rational etc.
00:03:34 <Cale> ThreeOfEight: Actually, that seems wrong. I think you want a tensor product there.
00:04:04 <ThreeOfEight> timmansfield: so GHC shows you the /most general/ type that it can infer, and not a specialised one such as Integer
00:04:16 <ThreeOfEight> Cale: in this case, it was a vector space product
00:04:19 <timmansfield> Ahh.
00:04:24 <ThreeOfEight> as U, V, W were vector spaces
00:04:42 <dmj`> timmansfield: Num is a typeclass, its like an interface in java. Different data types can implement its interface, then you can use the typeclass as a constraint on functions to keep them general, only applicable to types that implement that interface
00:04:43 <ThreeOfEight> timmansfield: and "Num a" means that "For any type a that is numerical"
00:04:57 <ThreeOfEight> There's also Eq a, which means "For any type where I can test for equality"
00:05:12 <ThreeOfEight> and Ord a which means "For any type whose values I can compare (less/greater/equal)"
00:05:25 <timmansfield> I get it - or I get it enough. What I don't quite get is why different commenters on RWH get different types reported. Just local installation setup?
00:05:25 <Cale> ThreeOfEight: dim(Hom(U x V, W)) = dim(U x V) dim(W) = (dim U + dim V) dim W, while dim(Hom(U,Hom(V,W))) = dim(U) dim(Hom(V,W)) = dim(U) dim(V) dim(W)
00:05:40 <Cale> ThreeOfEight: Those will rarely be equal except in small cases
00:05:49 <johnw> timmansfield: RWH has also been around a really long time, GHC has changed quite a bit over that span
00:06:10 <ThreeOfEight> Cale: I think you're right, it's been ages
00:06:19 <timmansfield> Gotcha. Thanks folks. My main concern was to be sure my local install wasn't broken in some way. I'm good.
00:06:51 <ThreeOfEight> Cale: Yes, you are quite correct
00:07:43 <Cale> Actually, that's a great way to explain what the tensor product of vector spaces is
00:07:58 <timmansfield> Back to me lessons, then. Thanks for the assist!
00:08:06 <dmj`> dependent types in javascript, now I've seen it all: http://www.infoq.com/presentations/Type-System-JavaScript
00:08:09 <Cale> It's the analogue of the Cartesian product if you're looking at things from the perspective of currying
00:08:13 <ThreeOfEight> Cale: http://downthetypehole.de/~manuel/blatt11.pdf
00:08:21 <ThreeOfEight> H44, if your German is up to it ^^
00:08:33 <Cale> right :)
00:08:41 <ThreeOfEight> (but I think it's reasonably understandable even for people who don't speak German)
00:09:10 <Cale> It's really funny how much easier it is for me to read German mathematics than German anything-else-really.
00:09:50 <ThreeOfEight> Yes, I think contemporary German mathematical writing is easier to understand for non-Germans than, say, mathematical writing from 100 years ago
00:10:04 <tdammers> German math uses a fairly limited subset of German grammar, really
00:10:16 <Cale> Right, the same is true in English
00:10:17 <ThreeOfEight> whenever I see anything by Frege or the Principia Mathematica, I just go… what the hell is this?
00:10:42 <Cale> Yeah, even if you go back to stuff from the 1940's it's really weird
00:10:42 * hackagebot caramia 0.2.0.1 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.2.0.1 (Adeon)
00:12:06 <Cale> Using arrows to denote function types is something that got introduced with category theory
00:12:19 <Cale> (or around the same time as that)
00:16:22 <tdammers> Cale: I guess it probably coincides with the movement that set out to formalize Mathematics
00:17:00 <tdammers> they went from free-form natural language arguments to formal proofs in a well-defined subset of natural language
00:18:35 <Cale> tdammers: Yes, once you have a formalism sitting in the back of your mind all the time, it tends to shape everything that you say. :)
00:26:38 <mkscrg> test :)
00:26:54 * mkscrg ran a successful test
00:44:38 <trap_exit> on osx, are there any easy to use sound libraries? I want something where I can get ht emicrophone as PCM data, and I want to be able to send PCM data to the speakers
00:44:46 <trap_exit> I just wnat the most dumbass of sound access
00:44:49 <trap_exit> input output both in PCM format
00:49:49 <dmj`> trap_exit: I'm looking for something like that as well
00:50:01 <dmj`> this article mentions pcm, http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
00:50:29 <trap_exit> dmj`: can you get something working + uploaded to hackage by , say, this weekend?
00:50:35 <trap_exit> I need something like this for a halloween prank
00:51:14 <dmj`> yea, I charge a lot of money though, so I hope you can pay me well
00:51:22 <dmj`> :P
00:51:37 <dmj`> trap_exit: first tell me the prank
00:51:45 <dmj`> then we'll talk code
00:52:01 <dmj`> kidding about the money part
00:54:32 <trap_exit> (1) live in large city, (2) live on floor high up in building, (3) have windows facing sidewalk, (4) computer vision for movement detection, (5) play back pre-recorded messages on wav
00:55:49 <sipa> on wav?
00:56:10 <trap_exit> play back wav on speakers
00:56:51 <dmj`> trap_exit: how will they hear if you're so high up
00:57:13 <trap_exit> fuck
00:57:18 <dmj`> trap_exit: how will you detect motion if you're so high up
00:57:25 <trap_exit> webcam pointed at sidewalk
00:57:34 <trap_exit> opencv + background subtraction + optical flow
00:57:41 <trap_exit> there are standard algorithms for sound detection
00:57:43 <sipa> seems to me that the funnyness of above proposed scheme entirely depends on the type of pre-recorded messages
00:58:15 <dmj`> trap_exit: at night, high up, in a busy city on halloween, it will be hard to get good accuracy I imagine
00:58:37 <trap_exit> djm`: hmm, probably :-(
00:58:59 <dmj`> trap_exit: why not just pretend to be a scare crow
00:59:09 <trap_exit> oh
00:59:14 <trap_exit> the pre-recorded message was going to be
00:59:23 <trap_exit> "there are people sleeping here; please shut the fuck up and party elsewhere"
01:00:12 <trap_exit> it's going to be noisy; I'm not goign to waste my voice arguing with drunk people; so I figure I'll build something they can argue with
01:00:16 <dmj`> trap_exit: I still don't see how this has anything to do with audio capture, maybe audio playback and video capture
01:00:31 <trap_exit> i need video capture and audio capture
01:00:38 <trap_exit> if people wlak by ... and are quiet, I don't bother them
01:00:46 <trap_exit> if people wlak by && they are noisy (defined as integral over some time interval > blah)
01:00:52 <trap_exit> then I play back "stfu"
01:01:02 <dmj`> trap_exit: but you're high up in your apt, how will they bother you?
01:01:15 <trap_exit> by high up, I mean floor 3-4
01:01:17 <trap_exit> not floor 10-20
01:01:36 <trap_exit> this is a college town
01:01:39 <trap_exit> not manhattan
01:02:39 <dmj`> trap_exit: what do you need audio capture for
01:03:05 <trap_exit> if peeople walk by but are quiet, I do not tell them to stfu
01:03:11 <trap_exit> if people walk by and are noisy, I tell them to stfu
01:03:25 <trap_exit> so it's "there is large optical movement && there is large sound captured by microphone" then play "stfu"
01:03:35 <trap_exit> for audiocapture, I just want to measure decibels
01:03:39 <trap_exit> I don't care about content of the audio input
01:05:09 <dmj`> trap_exit: what if you do this, put some candy and a scarecrow on the porch, put a speaker in the scarecrows mouth, then wait until someone walks by, push a button, and audio will play from his mouth
01:06:43 <dmj`> trap_exit: also, https://hackage.haskell.org/package/alsa-pcm
01:07:26 <trap_exit> dmj`: hmm, I don't own the building; I'm just renting a unit
01:07:33 <trap_exit> dmj`: but I like your pranks more
01:08:24 <Aruro> is there a simple wat to map a two argument function over list?
01:08:28 <Aruro> way*
01:08:41 <trap_exit> dmj`: can you find a way to make http://www.youtube.com/watch?v=tB8D2QZ9lA4 autonomous?
01:08:54 <kadoban> trap_exit: Your problem sounds like one that is better solved by a modestly-sized collection of water balloons
01:09:12 <trap_exit> kadoban: I think that is assult
01:09:21 <dmj`> Aruro: you can just call map on the list and it will return a list of functions
01:09:25 <kadoban> That's a possibility
01:09:53 <trap_exit> or maybe it's only assault if there's people to report; so if you use grenades it's safer // gov officials: I'm kidding
01:10:15 <trap_exit> dmj`: alsa-core failed to install -- does it work for you on osx ?
01:10:20 <dmj`> trap_exit: too easy, just get one of those remote control helicopters and put a black bed sheet on it
01:10:25 <saep> > zipWith (*) [1..10] [100..1000]
01:10:27 <lambdabot>  [100,202,306,412,520,630,742,856,972,1090]
01:10:31 <trap_exit> you mean under it?
01:10:39 <trap_exit> kind of hard to generate lift with a sheet over the helicopter
01:10:56 * hackagebot positive 0.4 - Positive integers.  http://hackage.haskell.org/package/positive-0.4 (HansHoglund)
01:11:35 <dmj`> Aruro: can you paste your code on lpaste.net?
01:11:46 <Aruro> i want something like this ---> map2agruments (+) [1,2,3,4] == [3,7]
01:11:56 <trap_exit> actually, drone + water ballons = fun prank, in countries without people so willing to sue
01:12:33 <dmj`> > map sum $ chunksOf 2 [1,2,3,4]
01:12:36 <lambdabot>  [3,7]
01:12:55 <dmj`> > map sum $ chunksOf 2 [1,2,3,4, 19]
01:12:56 <lambdabot>  [3,7,19]
01:13:26 <dmj`> Aruro: chunksOf is from Data.List.Split in the split package
01:13:38 <Aruro> > chunksOf  2  [1,2,3,4]
01:13:39 <lambdabot>  [[1,2],[3,4]]
01:13:46 <Aruro> isee
01:13:48 <Aruro> ty!
01:13:51 <dmj`> np
01:14:16 <Aruro> would be cool to have it ready in prelude :) since looks simple
01:14:44 <dmj`> @src chunksOf
01:14:44 <lambdabot> Source not found.
01:14:59 <Aruro> actually is there a  way to determine how many arguments does the function have?
01:15:23 <dmj`> Aruro: what are you trying to do
01:15:31 <dmj`> Aruro: for what purpose
01:16:40 <Aruro> that you have generilize your code: map f $ chunksOf (nOfarguments f) [list]
01:16:46 <Aruro> you can
01:16:48 <Aruro> *
01:17:50 <Cale> Aruro: Well, it's not really a well-defined question how many arguments a function has: a function of n >= 2 arguments in Haskell is also a function of n-1 arguments
01:18:04 <bernalex> is there a useful way to "extend a typeclass"? like if I want to add some function to Functor in my local code. is there a way to do this?
01:18:08 <Aruro> why it is not well defined?
01:18:12 <Aruro> i think it is
01:18:32 <Aruro> you can extend typeclass
01:18:43 <hyPiRion> :t (1 +)
01:18:44 <lambdabot> Num a => a -> a
01:18:51 <Aruro> by writing an instance of its functionality
01:19:10 <Aruro> look when i define function is has a FIXED number of arguments
01:19:16 <Aruro> it is completely well defined issue
01:19:29 <Aruro> the question is can i access it in the code?
01:19:35 <dmj`> bernalex: you can make a super class, like how all monads can use fmap class Functor f => Monad f where ...
01:20:12 <dmj`> that relationship isn't defined tho explictly, applicative => monad will be tho
01:21:28 <Aruro> i think the fact that functions are curried does not make it ill how many arguments function has
01:21:43 <Aruro> you can say what is maximum number of arguments function can have
01:22:31 <Aruro> to make this code possible : map f $ chunksOf (nOfarguments f) [list]
01:23:14 <ThreeOfEight> even that can be tricky in the presence of type classes
01:23:28 <ThreeOfEight> there are functions that can take arbitrarily many arguments (cf. printf)
01:23:40 <Aruro> how is it defined than?
01:23:52 <ThreeOfEight> With type classes.
01:24:02 <ThreeOfEight> there is a type class PrintfArg
01:24:18 <Aruro> no i  mean what is type of printf?
01:24:25 <hyPiRion> :t printf
01:24:25 <lambdabot> PrintfType r => String -> r
01:24:32 <ThreeOfEight> sorry, PrintfType
01:24:44 <ThreeOfEight> and PrintfType has instances IsChar c => PrintfType [c]
01:24:52 <ThreeOfEight> and (PrintfArg a, PrintfType r) => PrintfType (a -> r)
01:25:53 <Aruro> u see according to lambdabot Printf has one argument
01:25:58 <Aruro> simple
01:26:04 <Aruro> or it is not?
01:26:14 <ThreeOfEight> if you say it this way, all Haskell functions have one argument
01:26:23 <Aruro> yes
01:26:34 <Aruro> but not all of them have maximum one argument
01:26:37 <Aruro> this is the point
01:26:58 <ThreeOfEight> if you see it that way, some of them have maximum infinity
01:27:08 <Aruro> which ones?
01:27:11 <ThreeOfEight> printf
01:27:20 <ThreeOfEight> printf "%d %d %d" 1 2 3
01:27:20 <Aruro> hm
01:27:23 <ThreeOfEight> that prints "1 2 3"
01:27:39 <ThreeOfEight> things are not that easy when free type variables are involved
01:27:55 <ThreeOfEight> you could also say that ‘undefined’ is a function with arbitrarily many arguments
01:27:57 <Aruro> ok, i think this function is not good example
01:28:04 <Aruro> undefined is better
01:28:08 <Aruro> though conceptually
01:28:19 <ThreeOfEight> even the identity function can have arbitrarily many arguments
01:28:37 <ThreeOfEight> id (const $ const id) 1 2 3
01:28:40 <ThreeOfEight> four arguments, right?
01:28:50 <Aruro> ok
01:29:22 <Aruro> how do i write a function with arbitrary number of arguments?
01:29:54 <ThreeOfEight> You have to define a type class for its type, then give instances for that type class
01:29:58 <Aruro> lets say take numbers square them and sum
01:30:22 <ThreeOfEight> see this: http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
01:30:29 <Aruro> ty
01:30:33 <Aruro> i will see it now
01:31:01 <Aruro> but the original question has answer no? there is no way to access a typedefinition of function?
01:31:22 <ThreeOfEight> I don't think so, but I am not an expert on this kind of stuff.
01:35:38 <dmj`> Aruro: there is
01:36:12 <dmj`> Data.Dynamic
01:36:13 <dmj`> http://kwangyulseo.com/2014/02/03/data-typeable-and-data-dynamic-in-haskell/
01:36:22 <ThreeOfEight> dmj`: does that work in the presence of type variables?
01:36:45 <ThreeOfEight> I don't think it does, but I was surprised to even find it works for functions.
01:36:59 <dmj`> I don't think so, its unityped
01:39:40 <Aruro> ty dmj will look at that
01:43:43 <comerijn> ThreeOfEight: Dynamic only works for monomorphic values
01:43:55 <comerijn> Although that can include monomorphic functions
01:44:35 * dmj` wonders what the relationship between comerijn and merijn is
01:45:08 <comerijn> dmj`: The relationship is that sometimes my nick is already taken and irssi connects using my backup :p
01:45:38 <comerijn> Quotes and underscores are for plebs :p
01:47:45 <dmj`> don't tell that to jle` :P
01:51:01 <comerijn> bed time
02:01:33 <trap_exit> so
02:06:07 * hackagebot OpenGL 2.8.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.8.0.0 (SvenPanne)
02:09:38 <xpika> what is a basic use for Control.Monad.Cont ?
02:10:04 <trap_exit> is hasjkell good for one liners / throw away 5-10 line progs that you run, get some answer, and throw the code away?
02:10:12 <trap_exit> i.e. the type of thigns that matheamtica/perl/apl used to dominate on
02:10:31 <RchrdB> trap_exit: I use it for some, yeah.
02:10:44 <trap_exit> RchrdB: do you use ghci , or do you write out a Main.hs
02:10:45 <aleator> It's decent for those. Even good if you spend time tuning things.
02:10:47 <RchrdB> trap_exit: I tend to dump those into a repo rather than throwing them away, though.
02:10:56 <trap_exit> oh shit ... RchrdB : did you just write a new haskell book?
02:10:59 <xpika> i am learning about the continuation monad but im having trouble finding a suitable use for it
02:11:03 <RchrdB> trap_exit: not me!
02:11:18 <aleator> xpika: My favourite: regular expressions :)
02:11:27 <RchrdB> xpika: ContT is really nice for adding early exit to another monad such as IO.
02:11:41 <trap_exit> RchrdB: so you can't send me a `evaluation` copy of http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird-ebook/dp/B00O0RKGTO/ ?
02:12:11 <xpika> aleator: how do you do regular expressions with the continuation monad?
02:12:25 <RchrdB> trap_exit: so I have a repo called "snippets" that I dump misc stuff into, like https://github.com/RichardBarrell/snippets/blob/master/Ittle1.hs
02:12:34 <RchrdB> trap_exit: I'm afraid that I am Richard Barrell, not Richard Bird. :)
02:13:40 <aleator> xpika: Oops. Didn't read the word monad there. I meant this: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-regular-expression-matcher
02:14:14 <trap_exit> RchrdB: ah, sorry for the confusion :-)
02:14:44 <trap_exit> I'd really like a better way for writing snipplets in haskell
02:15:03 <RchrdB> No worries.
02:16:43 <trap_exit> as someone who does not know APL
02:16:46 <trap_exit> on a scale of 1 to 10
02:16:52 <trap_exit> how close does http://www.haskell.org/haskellwiki/APL get us to APL ?
02:17:21 <Aruro> dmj u still there?
02:19:15 <Aruro> is :t function a normal function?
02:19:21 <Aruro> or just a ghci hack?
02:19:29 <trap_exit> :t can not be a normal function
02:19:30 <lambdabot>     Not in scope: ‘can’
02:19:31 <lambdabot>     Perhaps you meant one of these:
02:19:31 <lambdabot>       ‘tan’ (imported from Prelude),
02:19:37 <trap_exit> you certainly can't use it inside of ghc
02:19:45 <trap_exit> think this way:
02:19:53 <trap_exit> if ":t" was a function in haskell, what would it's tyupe signature be?
02:19:54 <xpika> RchrdB: do you know where i can find an example of that?
02:20:00 <trap_exit> it'd be "Function -> Type Signature"
02:20:04 <Aruro> so what it is then?
02:20:08 <trap_exit> but "Function" and "tyhpe Signature", afaik, are NOT haskell data types
02:20:15 <trap_exit> Aruro: does this logic make sense?
02:20:20 <trap_exit> it's a ghci hack, afaik
02:20:46 <Aruro> it does make sense only i would regard function and type signature also as data type :D
02:20:52 <Aruro> but its my personal taste
02:22:32 <Aruro> function is actually a data type for sure
02:22:47 <Aruro> because otherwise saying a= function makes no sense
02:23:07 <__monty__> Aruro: Dependent types can do what you want. There are ghc extensions which supposedly make haskell dependently typed but I'm not familiar with them so I will not claim haskell can or cannot do that.
02:23:16 <Aruro> with type signature it is more tricky but can be possible
02:23:19 <trap_exit> Idris + Coq can do what you want
02:23:35 <Aruro> :)
02:23:36 <__monty__> Idris by itself is sufficient.
02:23:40 <trap_exit> haskell extensions .... I dunno, they all seem to be 'faking' things as far as =full dependent types go
02:23:46 <Aruro> yah i heard of coq
02:23:59 <Aruro> people advertise it to me all the time :D
02:24:21 <tdammers> Aruro: note how spelling matters
02:24:30 <RchrdB> xpika: no idea. I can write one in a bit.
02:24:45 <__monty__> Aruro: More information if you're interested: http://www.haskell.org/haskellwiki/Dependent_type
02:24:52 <Aruro> i just try to understand what was devs logic in making all typedinitions hidden from program?
02:24:59 <Aruro> ty monty
02:26:46 <__monty__> Aruro: That's a consequence of how typechecking works; it's a separate step in the compilation process.
02:28:04 <Aruro> so strictly speaking typechecking is not haskell compatible? :)
02:28:08 <Aruro> if that can be said so
02:28:19 <__monty__> That statement doesn't make sense.
02:28:24 <Aruro> why?
02:28:38 <Aruro> i think it does
02:28:52 <__monty__> Typechecking is something you do on a program to ensure it is well-typed.
02:28:55 <Aruro> it just says typecheking is done not using means of the language itself
02:29:05 <Aruro> well
02:29:54 <xpika> RchrdB: that would be good
02:30:05 <Aruro> so the algorythmical logic of typechecking has nothing to do with language itself whatever you call language in this case
02:30:39 <shmookey> haskell is type-erased at compile time, there is generally no type information available for functions at runtime
02:31:04 <Aruro> ty shmookey
02:31:30 <Aruro> so basically on the 'real' language level there is no such thing as type for the program?
02:32:17 <jle`> real language?
02:32:18 <__monty__> shmookey: Doesn't every language lose type information when you reach assembler?
02:32:42 <jle`> a lot of languages keep types at runtime
02:32:44 <shmookey> __monty__: sure but some languages encode type information and make it available for 'reflection' at runtime
02:32:56 <Aruro> yes monty complemented, real means the algorythm being actually evaluated (assembler in a way)
02:33:12 <shmookey> algorIthm btw
02:33:38 <jle`> what a weird usage of real :P
02:33:39 <Aruro> ty
02:33:53 <__monty__> shmookey: Do you have some offhand examples of such languages?
02:33:53 <Aruro> there is a lot of weird :)
02:34:17 <Aruro> for example the use of the phrase sytaxic sugar :)
02:34:32 <jle`> most interpreted languages attach type information to their values
02:34:44 <shmookey> c++ with rtti
02:35:33 <Aruro> so basically we dont know yet why haskell throws away type information?
02:35:38 <shmookey> plus most of the bytecode vm languages except java: python, ruby, .net and others
02:35:41 <jle`> doesn't java retain type information?
02:35:44 <jle`> Aruro: haskell is a language
02:35:49 <jle`> the interpreation can do whatever it wants
02:35:51 <jle`> er
02:35:54 <jle`> the implementation can do whatever it wants
02:36:23 <shmookey> type erasure in java and the jvm is supposed to be one of its big limitations but it's not such a bad thing really
02:36:29 <Aruro> yes but as we see people here argue that that is the reason there is no typereading functionality in language itself
02:36:44 <Aruro> language basically is blind to type definitions
02:36:55 <jle`> the language is not blind...
02:37:04 <jle`> but haskell the language is a program generator
02:37:17 <jle`> the programs that the typed language generates are not typey
02:37:22 <jle`> but the language is haskell
02:37:25 <jle`> not the generated program
02:37:48 <lpaste> RchrdB pasted “Terrible ContT IO example” at http://lpaste.net/112968
02:38:04 <__monty__> jle`: Do those interpreted languages retain that information at the level of the actual instructions that are executed on the processor?
02:38:12 <Aruro> i can not use "function" :t inside code thats makes it blind in my view
02:38:46 <Aruro> i understand you can not chage type definitions, but i dont understand why i can not READ them
02:38:54 <Aruro> passively
02:38:55 <RchrdB> xpika: please bearing in mind that I'm doing a bunch of things wrong on purpose (like checking for file existence and then reading the file is an anti-pattern), but: http://lpaste.net/112968
02:39:13 <__monty__> Aruro: Most any language is 'blind' to it's types.
02:39:32 <Aruro> whY? seems like a good logical opportunity
02:39:43 <RchrdB> xpika: you should be able to see that anything inside the ContT IO monad block there can use early_return to get out of the current loop any time it likes?
02:39:55 <aleator> Aruro: Because in one sense it is useless: the type definitions are already known when program is written so they would be constants in a live program
02:40:18 <__monty__> Aruro: What exactly do would you gain? (what aleator said)
02:40:21 <RchrdB> xpika: er, in that mapM, or anywhere else.
02:40:24 <shmookey> __monty__: nope, the instructions stay the same, the data for each object just gets extra fields for type information
02:40:31 <Aruro> it is not useless (almost nothing is)
02:40:49 <Aruro> we had example (very real world one) before
02:40:57 <aleator> Aruro: Regardless, you have Data.Typeable.typeOf.
02:41:03 <Aruro> where we needed to read how many arguments function has
02:41:08 <__monty__> shmookey: Thank you.
02:41:31 <jle`> there is often more than one way to approach a certain problem :)
02:41:50 <freeRingad> a little aeson help ...
02:42:03 <jle`> needing to know how many arguments a function has at runtime is rarely necessary in normal haskell usage...
02:42:16 <Aruro> > map sum $ chunksOf 2 [1,2,3,4]
02:42:17 <freeRingad> suppose i'm parsing a thing like: parseJSON (Object o) =  Quux <$> o .: "a" <*> o .: "b" ...
02:42:18 <lambdabot>  [3,7]
02:42:32 <aleator> Aruro: You know that before running the program. Also, typeOf tells you some of this.
02:42:51 <freeRingad> but suppose i want to decode the "c" object myself (i.e. it's a sub dictionary with things i'd like to read into QuuxParam structure)
02:42:56 <Aruro> THen we want something like this > map sum $ chunksOf (nArguments sum) [1,2,3,4]
02:43:03 <freeRingad> i'm trying to use Data.Aeson.Lens for this; but it's not working out so well.
02:43:09 <Aruro> do you see the point?
02:43:14 <jle`> Aruro: but what would the type of nArguments be?
02:43:36 <bartavelle> freeRingad, why don't you do something like (o .: "c" >>= parseC) and write parseC ::  Value -> Parser Foo ?
02:43:39 <Aruro> does not matter at the moment we are debating if it is usefull to read typedefinitions
02:43:46 <aleator> Aruro: What would nArguments sum return?
02:43:53 <Aruro> 2
02:43:55 <Aruro> in our case
02:44:07 <freeRingad> bartavelle: that's probably exactly what i want .... thanks!
02:44:22 <bartavelle> freeRingad, good luck !
02:44:28 <aleator> Aruro: What definition of sum do you have?
02:44:30 <__monty__> Aruro: Sum has type [a] -> a, how do you get 2 from that?
02:44:47 <__monty__> Aruro: Maybe you mean (+)?
02:44:51 <Aruro> yes
02:44:57 <Aruro> ty you saved me some typing
02:45:00 <Aruro> you got the logic
02:45:05 <freeRingad> :r
02:45:09 <freeRingad> ahah, ah, oops.
02:46:05 <Aruro> well that example is not that good actually because of list definition of sum
02:46:22 <aleator> Aruro: I think you can code nArguments that would work on that kind of a case. (Though you need magic to extract the arguments from a list)
02:46:57 <Aruro> original goal was to have map which can map multiargument functions like this map (+) [1,2,3,4] == [3,7]
02:46:58 <__monty__> Aruro: Making the types available in the program brings a lot of problems with it. And (in this case) it's not needed, it doesn't add expressivity.
02:47:03 <aleator> Aruro: To make that mesh well with the language requires that nArguments has a reasonable type, however.
02:48:01 <Aruro> i dont think IO is much less unreasonable than the possible "type" we are talking about
02:48:36 <freeRingad> bartavelle: sweet as; that at least compiles; so i think it will do the trick, cheers!
02:49:34 <jle`> i feel like such a thing would lead to the compromise of a lot of the guaruntees that haskell offers with its type system
02:49:56 <Aruro> whY? we defined it to be read only
02:50:00 <Aruro> by definition
02:50:03 <bartavelle> freeRingad, good to hear
02:50:09 <Aruro> otherwise makes no sense
02:50:28 <shmookey> Aruro: to answer your original question, you can do something like :t at compile time with type families. if you use type operators you could even make it look the same! except it'd have to be :T because of capitalisation rules
02:50:30 <shmookey> what you would intend such a function would to actually do is unclear, but the basic power to take type variables as arguments and return a type signature is there
02:51:03 <shmookey> wait, you don't type operators for that :P
02:52:32 <jle`> Aruro: i'm not talking about mutability
02:52:37 <jle`> Aruro: i'm talking about guaruntees from the types
02:52:44 <jle`> from things like parametricity
02:53:02 <Aruro> shmookey: by type families you mean typeclasses?
02:53:05 <jle`> usually, if you have a type signature, ther eare certain guaruntees you can make about the function or value
02:53:11 <jle`> only from the natur eof their types
02:53:18 <jle`> such inspection would sort of ruin that
02:53:25 <jle`> for example, (a -> a) can only be id
02:53:28 <shmookey> Aruro: http://www.haskell.org/haskellwiki/GHC/Type_families
02:53:37 <jle`> but if you allowed inspection of the type of a, then perhaps you can make things not id
02:53:38 <Aruro> ty
02:54:29 <Aruro> i dont understand , if i can not define new type and things during runtime? how reading type definitions can harm me?
02:54:54 <Aruro> read only can harm?
02:54:56 <jle`> if you can access type definitions and branch on them
02:54:57 <saati_> Aruro: you could solve that map much easier, a function converting it to a tuple list and map a curried +
02:55:00 <jle`> then you can act differently
02:55:07 <jle`> that breaks parametricity
02:55:09 <Aruro> yes! saati
02:55:31 <jle`> parametricity and the guaruntees that it carries is under the understanding that you can't reflect on the types
02:55:45 <jle`> something like (a -> Bool) has only two implementations:  const True, or const False
02:55:46 <Aruro> i know its possible to do it by converting and tossing list
02:55:58 <jle`> but if you could inspect the type of a, then you could branch based on what a is
02:56:07 <Aruro> the thing is that you have to KNOW how many arguments + takes in advance
02:56:09 <jle`> and so now your function can really return any Bool
02:56:56 <jle`> that is, your function can return a bool based on the type of `a`
02:57:10 <jle`> `even (nArguments a)`, to use your example
02:57:13 <Aruro> good point jle
02:57:20 <jle`> that's why Typeable exists
02:57:28 <jle`> Typeable a => (a -> Bool)
02:57:47 <jle`> having a typeclass constraint there tells the reader of the type signature that the function *can* branch on the type
02:57:53 <Aruro> but isnt  typechecking capable of fixing that?
02:57:56 <jle`> (a -> Bool) means that it can't
02:58:00 <jle`> Aruro: fixing what?
02:58:18 <Aruro> the fact that i can return different stuff from declared
02:58:30 <jle`> a function of type signature (a -> Bool) comes with a guaruntee that you cannot branch based on the type of `a`
02:58:31 <Aruro> that is the point of typecheck no?
02:58:43 <Aruro> hm
02:58:44 <jle`> it still returns a Bool...your function would still typecheck
02:59:07 <jle`> if we want to "say" that he function has the *option* of branching on the type of `a`
02:59:12 <jle`> then we can say foo :: Typeable a => a -> Bool
02:59:26 <jle`> and if we want to say that we can't, we say foo :: a -> Bool
02:59:39 <jle`> here, using the types, we can deliver or chose not to deliver guaruntees
02:59:54 <jle`> this is a contrived example, but these guaruntees become a lot more meaningful and intricate in real everyday haskell code
03:00:07 <jle`> such that things like runtime type inspection w/out a Typeable constraint destroys a lot of why haskell is useful in the first place
03:00:40 <Aruro> hm i sense something usefull but im afraid i can not fully get what you mean
03:01:33 <Aruro> you said it will typecheck  and isnt it a holy grail of haskell?
03:01:49 <Aruro> it will be poor then i guess
03:01:50 <jle`> the thing is that now, more things will typecheck than before
03:01:57 <jle`> so typechecking is less of a useful thing :P
03:01:57 <Aruro> and?
03:02:02 <jle`> if anything typechecks, then why is typechecking useful
03:02:04 <jle`> :P
03:02:09 <Aruro> hm
03:02:14 <Aruro> let me think
03:03:04 <Aruro> so what you say you can make something to be typechecked even if in original orthodox haskell it wont?
03:03:30 <Aruro> using info about type definitions
03:03:37 <jle`> or that "it typechecks" now has less guaruntees about behavior than before
03:04:16 <jle`> a function (a -> Bool) that branched on the type of `a` isn't supposed to typecheck.  looking at (a -> Bool), you can *know* things about the implementation of the function...things that the implementation has to follow or adhere to
03:04:26 <jle`> if you allow such inspection, then...you can't relaly "know" these things anymore
03:04:36 <jle`> all bets are off.  (a -> Bool) as a function doesn't tell you much anymore at all
03:04:48 <jle`> that type has less meaning and guaruntees than it did before
03:05:08 <jle`> haskell's type system lets you "say things about your function" with your types.  allowing this would basically kill off a huge portion of what you are allowed to say
03:06:18 <jle`> as in...the conclusions you can make when looking at a function's type
03:06:41 <Aruro> can you make a simpler example? i think your point is interesting
03:06:45 <Ferdirand> are there any other implementations for (a -> Bool) but (const True), (const False), error and undefined ?
03:07:18 <jle`> Ferdirand: error and undefined we usually lump into the same category, along with infinite loops :)
03:07:30 <exio4> that sad bottom value!
03:07:31 <jle`> const True and const False are the only terminating/non-bottom implementations
03:07:43 <kazagistar> well, you can do a few more, like \x -> seq x (const True)
03:08:04 <kazagistar> to be pedantic
03:08:13 <exio4> strict and lazy versions of everything
03:08:17 <jle`> :)
03:08:25 <jle`> having nontermination makes things a little more tricky, but
03:08:48 <jle`> Aruro: i'm not sure how much simpler i could get. ... do you see how (a -> Bool) can only have two terminating implementations?
03:09:01 <jle`> foo _ = True, or foo _ = False ?
03:09:09 <Aruro> yes that i see
03:09:17 <jle`> this is an example of something you can "conclude" about how such a function *must behave*, given *only* the types
03:09:21 <Aruro> i did not get how can u escape that?
03:09:33 <jle`> foo x = even (nArguments x)
03:09:53 <jle`> even is the function that is True if the number is even and False if it is not
03:09:54 <Aruro> it will be also bool at the end
03:09:57 <osa1> what is this error message trying to say: "parse error on input ‘$’ Perhaps you intended to use TemplateHaskell" I already enabled TH and yes I'm intending to use TH this is why I have a $ in that place
03:10:04 <jle`> Aruro: it will be bool at the end
03:10:07 <jle`> but you can no longer say
03:10:20 <jle`> "oh, this function is a -> Bool.  it can only have two possible terminating implementations."
03:10:31 <jle`> that conclusion is no longer valid
03:10:35 <Aruro> i see now
03:10:55 <Aruro> you mean that in this case i can make many more branches of this foo?
03:11:01 <Aruro> which all lead to Bool
03:11:03 <jle`> yeah
03:11:07 <shmookey> Aruro: just to confuse things, if you have a function foo :: (a -> Bool) -> a -> Bool then you could pass functions with signatures such as Int -> Bool, Bool -> Bool into it as the first argument (because they suffice for a -> Bool), and those could have different implementations
03:11:09 <jle`> so (a -> Bool) "says less"
03:12:21 <osa1> is this a bug
03:12:41 <Aruro> now im confused :D but we dont know anything about type a how can you be sure foo has only two branches jle?
03:12:47 <Aruro> maybe it is a complex type
03:12:49 <kazagistar> and saying less is saying more. strong theorems are the ones with the least axioms
03:14:08 <Aruro> saying less refers to be able to read typedefinitions or current situation?
03:14:12 <romildo> I am going to start implementing a package of tools to help teaching compiler construction in my classes. For instance, there will be a tool that, given a LR1 grammar, and an input string, generates a LaTeX document showing the steps of the execution of the LR1 parser to parse the input string.
03:14:56 <romildo> I want suggestions for the name of such a package.
03:15:11 <kazagistar> osa1: did you enable the template haskell pragma?
03:15:29 <jle`> Aruro: if we allowed your nArguments, than it could really have many many branches :P
03:15:31 <osa1> kazagistar: yes that's why I'm asking if that's a bug
03:15:43 <osa1> it's fixed when I enable it in Cabal file
03:15:49 <osa1> somehow file-level pragma is ignored
03:15:52 <romildo> Would compiler-teaching-tools a good one?
03:16:07 <jle`> Aruro: "saying less" here means that, when you look at a function and see that it has type (a -> Bool), you can make less conclusions about what implementations it might have, and what it is allowed to branch on
03:16:25 <Aruro> ok sounds logicl
03:16:43 <jle`> and this ability to make conclusions about implementations based on their types is one of the most powerful things about haskell
03:17:02 <Aruro> so basically you are saying that number of arguments gives extra freedom, or even kinda extra type to all functional things
03:17:10 <jle`> yes
03:17:13 <bennofs> osa1: starting with GHC 7.8, you should really list TH in the cabal file if you use it, but i think that's only for ghci
03:17:19 <jle`> we can actually encapsulate "access" to the number of arguments, though
03:17:20 <__monty__> romildo: What's the course name
03:17:22 <jle`> via typeclasses
03:17:27 <jle`> foo :: Typeable a => a -> Bool
03:17:35 <jle`> such a statement says "foo is allowed to branch on the type of `a`"
03:17:57 <jle`> by specifying typeclasses, we sort of "manually specify" holes to the guaruntees
03:18:02 <jle`> foo :: Show a => a -> Bool
03:18:12 <jle`> such a statement says "foo is allowed to branch on the string representation of `a`"
03:18:14 <osa1> another annoying thing is that $a is parsed differently depending on TH is enabled or not
03:18:18 <jle`> foo :: (Typeable a, Show a) => a -> Bool
03:18:20 <romildo> __monty__, the course name is in Portuguese: "Construção de Compiladores", which may be translated to English as "Compiler Construction"
03:18:26 <jle`> this says, "foo is allowed to branch on both the type of a and its string representation"
03:18:43 <jle`> foo :: Num a => a -> Bool  ... well...this opens up a lot of doors :P
03:18:57 <Aruro> :)
03:19:05 <jle`> but at least you have a "picture" of what foo is allowed to branch on
03:19:15 <jle`> it can branch on numerical properties of `a`.
03:19:26 <Aruro> so from our discussion we can conlcude that the less programm knows the more stable it is?
03:19:41 <Aruro> is this current philosophy?
03:19:49 <jle`> the less you can access, the more you can conclude
03:19:55 <jle`> that is one of the fundamental tenants of haskell, i think
03:20:03 <Aruro> interesting
03:20:04 <jle`> i think i wrote a tweet to that extent recently...
03:20:14 <Aruro> send me link :)
03:20:27 <Aruro> i have to think about that
03:20:35 <Aruro> because it is a bit couter intuitive
03:20:51 <jle`> https://twitter.com/mstk/status/491336539105132544
03:20:55 <Aruro> u naturally expect more tools not less
03:21:17 <jle`> you can selectively specify the tools are allowed to use
03:21:19 <exio4> it is that you have the tools "explicit" instead of "implicit"
03:21:27 <jle`> yes, explicit vs. implicit, exactly :)
03:21:40 <__monty__> romildo: I wanted to suggest using the course name but that's not very specific at all. Maybe you can include the course text you will tune it to?
03:21:41 <jle`> you *can* have a function branch on its type.  but if you do, it's right there staring at you in the type signature
03:21:45 <kazagistar> romildo: how about "algostep-ll1", "algostep-regex" etc :P
03:22:18 <jle`> you *can* have a function branching on the string representation of its input.  but if you do, then it is stated in the type signature
03:22:43 <jle`> foo :: Show a => a -> Bool says "warning: this function is allowed to branch based on the string representation of `a`"
03:22:57 <jle`> foo :: Typeable a => a -> Bool says "warning: this function is allowed to branch based on the type of `a`"
03:23:05 <jle`> and really...if you did want functions like that...you really can :)
03:23:09 <jle`> without too many extra hassles
03:23:21 <Aruro> :)
03:23:41 <jle`> (a -> Bool) is admittedly a bit of a contrived example
03:23:49 <bennofs> Aruro: it's the same in mathematics. If I only have a small set of axioms, there are less possibilities at each proof step, so less to try = proof is easier
03:23:59 <Aruro> yes
03:24:07 <Aruro> but i think mathematics is a bit different
03:24:07 <jle`> but in every day haskell you encounter a lot of such things in your workflow
03:24:22 <Aruro> i regard self retrospection as a big plus of computer vs mathematics
03:24:23 <jle`> where you can simplify your code or rest assured that your codebase does what you think it does, or it behaves correctly
03:24:42 <jle`> but only if such guaruntees are followed, or explicitly stated/excluded
03:24:53 <Aruro> basically the conclusion here is that retrospection is hard
03:25:00 <jle`> it's not hard
03:25:03 <jle`> we have it wiht Typeable
03:25:07 <Aruro> its not?
03:25:17 <jle`> but implicit retrospection is ... silly :P
03:25:21 <jle`> > typeOf (+)
03:25:23 <lambdabot>  Integer -> Integer -> Integer
03:25:29 <__monty__> romildo: e.g. our course on compilers uses the text by Appel, so I'd call the package CompilerConstruction-Appel or something.
03:25:29 <bennofs> Aruro: the idea is that you need to explicitly state when you want retrospection
03:25:30 <Aruro> ok why implicit?
03:25:34 <Aruro> make it explicit
03:25:40 <jle`> we have that, then
03:25:42 <jle`> :)
03:25:51 <jle`> nArguments :: Typeable a => a -> Int
03:25:58 <Aruro> so  how do i get the number of arguments?
03:26:05 <jle`> nArguments is an (a -> Int) where we explicitly say that it is allowed to branch on the type of `a`
03:26:15 <bennofs> Aruro: that way, you can still use the simple approach to reasoning for the parts of your program that don't use retrospection
03:26:36 <jle`> Aruro: um i think it's in the docs somewhere
03:27:08 <bennofs> Aruro: making it explicit gives you the possibility of knowing a lot about the behaviour of a function from just looking at it's type
03:27:20 <Aruro> so it is possible to extract number of arguments from a given well defined function?
03:27:28 <Aruro> not printf or something
03:28:02 <Aruro> like fsq  x y = x^2+y^2 , nArg fsq==2 ?
03:28:13 <jle`> if it is a Typeable instance
03:28:20 <jle`> ...i think
03:28:33 <jle`> hm.
03:28:43 <Aruro> what i wrote is not typeable?
03:28:44 <jle`> i'll stop talking here because i am not too familiar with Typeable
03:28:52 <Aruro> me neither :D
03:28:54 <jle`> Typeable is a typeclass
03:29:10 <jle`> i'm pretty sure it is possible
03:29:14 <Aruro> i just want _simplest_ retrospection if possible :)
03:29:49 <bennofs> Aruro: you don't need retrospection very often
03:29:53 <nshepperd> I'm not sure "number of arguments" is very well defined...
03:30:04 <Aruro> well if noone shouts answer immediately seems it is not at the core of the language
03:30:18 <Aruro> it is very well defined on my example
03:30:26 <bennofs> Aruro: In fact, I think I never used retrospection in any of my programs
03:30:39 <nshepperd> sometimes you want a function to return another function. do you count that as another argument or not?
03:30:39 <adnap> :t readFile
03:30:40 <lambdabot> FilePath -> IO String
03:30:53 <adnap> How does this function report an error?
03:31:01 <bennofs> adnap: throws an exception
03:32:24 <adnap> How does one know what IO functions throw exceptions?
03:32:36 <bennofs> adnap: only from trusting the documentation
03:32:46 <Aruro> nArguments :: (.. -> a) -> Int
03:33:10 <adnap> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#v:readFile does not say readFile throws an exception.
03:34:51 <bennofs> adnap: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO-Error.html
03:35:03 <Aruro> length (a->b->c->d) =3 , length ((a->b)->c->d)=2
03:35:11 <bennofs> adnap: "any IO operation may throw an IOError instead of returning a result"
03:35:19 <Aruro> basically u need to treat -> like :
03:35:38 <nshepperd> Aruro: that's ambiguous
03:35:38 <bennofs> Aruro: you can actually implement that with typeclasses, without needing retrospection at runtime
03:35:54 <Aruro> really? im interested in that?
03:35:58 <Aruro> any read?
03:36:00 <bennofs> oh right, d must be a concrete type
03:36:17 * hackagebot yi-rope 0.6.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.6.0.0 (MateuszKowalczyk)
03:36:21 <nshepperd> Aruro: (.. -> a) matches (Int -> Int -> Int) in two different ways
03:36:40 <bennofs> @let class NNumArgs a where nNumArgs :: proxy a -> Int
03:36:42 <lambdabot>  Defined.
03:36:42 <nshepperd> er, or rather
03:37:24 <bennofs> @let instance NNumArgs b => NNumArgs (a -> b) where nNumArgs _ = nNumArgs (Nothing :: Maybe b) + 1
03:37:25 <lambdabot>  Defined.
03:37:38 <bennofs> @let instance NNumArgs a where nNumArgs _ = 0
03:37:39 <lambdabot>  Defined.
03:37:46 <bennofs> > nNumArgs (id :: Int -> Int)
03:37:48 <lambdabot>  0
03:37:52 <bennofs> :o
03:38:18 <bennofs> @undef
03:38:18 <lambdabot> Undefined.
03:38:37 <Aruro> is it possible to use on +?
03:38:40 <bennofs> @let class NNumArgs a where nNumArgs :: a -> Int
03:38:41 <lambdabot>  Defined.
03:38:57 <bennofs> @let instance NNumArgs b => NNumArgs (a -> b) where nNumArgs f = nNumArgs (f undefined) + 1
03:38:58 <lambdabot>  Defined.
03:39:02 <bennofs> @let instance NNumArgs a where nNumArgs _ = 0
03:39:03 <lambdabot>  Defined.
03:39:09 <bennofs> > numArgs (+)
03:39:10 <lambdabot>  Not in scope: ‘numArgs’
03:39:11 <lambdabot>  Perhaps you meant ‘nNumArgs’ (line 155)
03:39:15 <bennofs> > nNumArgs (+)
03:39:16 <lambdabot>  Overlapping instances for L.NNumArgs (a0 -> a0 -> a0)
03:39:16 <lambdabot>    arising from a use of ‘L.nNumArgs’
03:39:16 <lambdabot>  Matching instances:
03:39:16 <lambdabot>    instance [safe] L.NNumArgs b => L.NNumArgs (a -> b)
03:39:16 <lambdabot>      -- Defined at L.hs:157:10
03:39:25 <bennofs> > nNumArgs ((+) :: Int -> Int -> Int)
03:39:26 <lambdabot>  Overlapping instances for L.NNumArgs
03:39:27 <lambdabot>                              (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
03:39:27 <lambdabot>    arising from a use of ‘L.nNumArgs’
03:39:27 <lambdabot>  Matching instances:
03:39:27 <lambdabot>    instance [safe] L.NNumArgs b => L.NNumArgs (a -> b)
03:39:37 <bennofs> ah, lambdabot doesn't have OverlappingInstaces enabled
03:39:44 <Aruro> interesting im trying to follow :)
03:39:48 <bennofs> @undef
03:39:49 <lambdabot> Undefined.
03:39:56 <nshepperd> it doesn't work...
03:40:04 <Aruro> so it should  work in ghci?
03:40:17 <bennofs> Let's try closed type families
03:40:33 <Aruro> very interesting stuff :)
03:41:03 <aleator> There was a nice example of a function that was expressible as foldr but only if you use a function as the 'accumulator'. Can anyone remind me which function that was?
03:41:27 <aleator> .. The function that was expressible as..
03:41:32 <nshepperd> I think you can implement foldl like that
03:41:32 <bennofs> aleator: you can express foldl as foldr using a function as accumulator i think
03:41:40 <nshepperd> heh
03:41:55 <aleator> Hmm.. True!
03:42:02 <aleator> Anything more simple than that?
03:43:52 <nshepperd> (Int -> Int -> Int) could be a two argument function, or a one argument function that returns a function
03:44:28 <Aruro> yes
03:44:31 <Aruro> we had this argument
03:44:36 <nshepperd> you could define the number of arguments by repeatedly applying the function until the return value can be proven to not be a function
03:44:42 <Aruro> it is fixed by saying word maximum
03:44:48 <nshepperd> but this will sometimes be the wrong abstraction
03:44:50 <Aruro> maximum number of arguments
03:45:01 <Aruro> yes
03:45:04 <Aruro> you said it :)
03:45:27 <Aruro> i think in everyday use it is pretty good abstraction
03:45:39 <Aruro> especially taking purity into account
03:45:44 <nshepperd> eg 'printf' doesn't have any specific number of arguments because it's polymorphic
03:45:49 <Aruro> yeah
03:45:59 <nshepperd> that system would say it has infinite arguments
03:46:03 <Aruro> it is not good function
03:46:07 <Aruro> yes
03:46:09 <Aruro> infinite
03:46:26 <Aruro> no problem as infinite lists
03:46:28 <nshepperd> but that goes for basically any function with a polymorphic return type
03:46:35 <Aruro> ok
03:46:42 <Aruro> no problem again
03:46:52 <bennofs> Aruro: can we assume that the function has a concrete (monomorphic) type?
03:46:54 <Aruro> we need only "normal" functions
03:47:05 <Aruro> yes we can and should
03:47:38 <nshepperd> instance Num b => Num (a -> b) where {...} -- now (+) has an infinite number of arguments
03:49:32 <nshepperd> conversely, whether liftM2 has one or three arguments is a matter of perspective
03:51:36 <Chathurga> Hi so I'm doing a little church encoding thing and I was wondering if there's any way to make the "and" function I have commented out type check? https://gist.github.com/Chathurga/e807aa478deda3c40f38
03:52:04 <Chathurga> Or do I need to wrap Value to not be just a synonym
03:52:04 <aleator> Hah! My coworker remembered it. Lazy init implementation needs a function accumulator!
03:53:56 <Chathurga> I was thinking it was just a case of using forall but I must be missing something
03:58:33 <bennofs> Aruro: https://www.fpcomplete.com/user/bennofs/number-of-arguments-of-a-function
03:59:22 <bennofs> Aruro: you can run that if you click on the little button with the play symbol
04:34:06 <danilo2> Hello! Are there in Haskell type synonyms in data definitions? I mean - I want to declare a new datatype with some complex types inside. A lot of these types are the same like "R f Pat" (where f is the parameter of the new datatype). I would love just to write it like RPat
04:34:44 <__monty__> type String = [Char]
04:34:44 <RchrdB> danilo2: you can use type synonyms inside data definitions.
04:36:01 <danilo2> RchrdB: Ok, but I want to define type synonyms inside data definitions. Othercase I cannot do anything with data Foo f = { x :: R f Foo, y :: R f Foo, z :: R f Foo, ....}
04:36:16 <tdammers> danilo2: oh, no, you can't do that AFAIK
04:36:59 <tdammers> best you can get, I think, is something like type RFoo f = R f Foo; data Foo = { x : RFoo f ... }
04:37:09 <Bubblegum> Hello Ladies and Gentlemen, I need your help. I don't understand how I should print a [(Char, Int)] like a battleship coordinate. So [(A,1)(A,2) to (J,10)]
04:37:27 <Bubblegum> how do I do it?
04:37:50 <bergmark> Bubblegum: what do you mean by "print"?
04:38:06 <Bubblegum> print out into GHCi
04:38:13 <Cale> So you want to turn, say, ('A',10) into A10?
04:38:21 <Cale> Or the string "A10" rather?
04:39:00 <Cale> showCoord (c,n) = c : show n
04:39:16 <Cale> showCoord :: (Char, Int) -> String
04:39:48 <danilo2> tdammers: :(
04:39:49 <Bubblegum> No, not at all. I want to merge Char (x:xs) and Int (y:ys) into [(x:xs),(y:ys)]
04:39:49 <Tehnix> Bubblegum: does `(A,1)(A,2)` get transformed/converted into `(J,10)`, or what does the "to" mean?
04:40:00 <Tehnix> Bubblegum: like zip?
04:40:07 <Cale> Bubblegum: zip?
04:40:10 <Tehnix> zip :: [a] -> [b] -> [(a, b)]
04:40:16 <Cale> > zip "ABCDE" [1,2,3,4,5]
04:40:18 <lambdabot>  [('A',1),('B',2),('C',3),('D',4),('E',5)]
04:40:56 <Bubblegum> rather [(A,1),(A,2)(A,3) and so forth]
04:41:27 <Bubblegum> pardon ('A', 1) and so forth
04:41:52 <Cale> > zip "AAAAA" [1,2,3,4,5]
04:41:54 <lambdabot>  [('A',1),('A',2),('A',3),('A',4),('A',5)]
04:42:03 <Tehnix> oh, so constructing a list?
04:42:08 <Cale> Or did you want all possible pairs?
04:42:26 <Cale> > [(c,n) | c <- ['A'..'J'], n <- [1..10]]
04:42:27 <lambdabot>  [('A',1),('A',2),('A',3),('A',4),('A',5),('A',6),('A',7),('A',8),('A',9),('A...
04:42:51 <Bubblegum> Thank you, now I know what to do
04:43:04 <Cale> okay cool :)
04:43:22 <Tehnix> Bubblegum: technique was list comprehensions, in case you wanna read more on it :)
04:44:11 <__monty__> Is there a function which cycles a list a number of times? Or would you have to take (x*length...)?
04:44:27 <Chathurga> replicate
04:44:49 <Chathurga> Well, concat . replicate n
04:45:15 <__monty__> Chathurga: Ok, thanks.
04:45:42 <Chathurga> __monty__:  Let me know if I've understood correctly
04:46:19 <__monty__> Chathurga: That would indeed do what I meant it to, didn't think of concat myself.
04:48:08 <Bubblegum> Thank you, now I know what to do
04:59:34 <Aruro> ty for the code bennofs!
05:21:20 <xenog> I am fighting the Cabal install system to find the appropriate way to deploy an arbitrary hierarchy of files and folders along with my package.  The package includes files for a web GUI that should come embedded.
05:22:39 <xenog> I have been looking at the Cabal documentation, as well as Distribution.Simple, but the documentation is not thorough.
05:38:15 <kuribas> I think you are supposed to use build-type Custom.
05:39:00 <kuribas> At the end of www.haskell.org/cabal/users-guide/developing-packages.htm
05:40:03 <kuribas> Or use Distribution.Make and use makefiles.
05:43:12 <kuribas> But PackageDescription contains a datafiles field, I think you should try that first...
05:44:43 <rgr> sorry, away from haskeel for ages and need to ask a quick solution. If I have an array eg. mySpawns =["script1","script2"] , how do I map them one by one to the spawnOnce function (its an xmonad api)?
05:45:04 <Kinnison> mapM_ spawnOnce mySpawns
05:45:05 <Kinnison> or similar?
05:46:39 <rgr> thanks. I'll gogole up the mapM_ . tvm
05:46:43 <rgr> eek. google.
05:47:03 <Kinnison> :t mapM_
05:47:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
05:47:25 <kuribas> I don't know xmonad, but isn't that a list?
06:40:11 <MindIsAVortex> Hi there, in class today we were shown the following function for fibonacci numbers as an example of memoisation: https://gist.github.com/MindIsAVortex/84e468d14058d6cae35a I understand what it does but I'm not quite familiar with the way this list constructor works: "0 : 1 : [fibs ! (k - 2) + fibs ! (k - 1) | k <- [2..n]]". If it's a list constructor that is. Does anyone have a link to some documentation on the basic ins and outs of this t
06:41:23 <gregnwosu> i think its important that you state "fibs = 0 : 1 : [fibs ! (k - 2) + fibs ! (k - 1) | k <- [2..n]]"
06:42:04 <kadoban> MindIsAVortex: It's called a list comprehension, if you mean that last bit
06:42:17 <gregnwosu> its a lazily constructed list , that produces the next element by combining its previous two elements
06:42:19 <MindIsAVortex> Yeah, the last bit indeed
06:42:30 <gregnwosu> its possible because haskell is lazy
06:42:46 <gregnwosu> so you only need to define the first two elements
06:43:07 <kadoban> MindIsAVortex: (there's also a better way to do that particular problem, but maybe your teacher will mention that too)
06:43:58 <gregnwosu> yeah there is an implementation using zipWith that is even more terse, if you consider it better
06:44:19 <gregnwosu> the web abounds with functional implementations of fibbonacci
06:45:04 <kadoban> gregnwosu: Well, I think the performance has to be better. This way is using ! all the way up each time
06:45:07 <gregnwosu> sorry i think i may have been wrong about the "fibs =" part
06:45:47 <MindIsAVortex> kadoban: gregnwosu: well I got the basic workings from class, and I understand why it works a lot faster than re-calculating every required element a couple times over, but I just dont get the notation of that list comprehension
06:46:13 <gregnwosu> yeah i was thinking of the something along the lines of fibs = 0:1 zipWith (+) tail fibs
06:46:21 <gregnwosu> but im not sure thats quite correct
06:46:21 <kadoban> MindIsAVortex: Yeah, right. It's a weird syntax if you haven't seen it. Did you manage to find anything about it?
06:46:32 <exio4> fibs = 0:1:zipWith (+) fibs (tail fibs)
06:46:38 * hackagebot th-lift-instances 0.1.4 - Lift instances for template-haskell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1.4 (BennoFuenfstueck)
06:46:46 <exio4> @let fibs = 0:1:zipWith (+) fibs (tail fibs)
06:46:48 <lambdabot>  Defined.
06:46:55 <exio4> > take 15 fibs
06:46:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
06:47:00 <MindIsAVortex> gregnwosu: yeah I was gonna say "no you're wrong!" but then I figured I was asking for you help ;)
06:47:35 <gregnwosu> exio4 has it
06:47:45 <MindIsAVortex> kadoban: that's the thing, I thought it had to do with arrayList so ive been looking for doc on that, but no go
06:47:58 <kadoban> Ahh
06:48:02 <MindIsAVortex> I'll search for list comprehension, wasn't aware of that term
06:48:28 <MindIsAVortex> Ah, got it, thanks
06:50:48 <gregnwosu> @let a=1
06:50:50 <lambdabot>  Defined.
06:51:03 <gregnwosu> ooh didnt know you could use lambdabot like that
06:51:26 <gregnwosu> i think theres a lambdabot for ghci too in cabal , no?
06:51:39 * hackagebot typeable-th 0.1.5 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1.5 (BennoFuenfstueck)
06:52:00 <lsix> http://haskell.org/haskellwiki/Lambdabot
06:55:17 <chaosfisch> Is there something "built-in" to convert a string containing a number in bin format to dec?
07:01:40 * hackagebot libhbb 0.4.0.1 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.4.0.1 (wolfch)
07:04:48 <kuribas> chaosfisch: If by build in you mean the prelude, then not that I know of.
07:05:12 <kuribas> (or base libraries).
07:05:32 <kuribas> chaosfisch: But it's a one liner, didn't I show you before?
07:05:51 <piss-christ> why hoogle can't find `shouldBe` ?
07:06:22 <blueonyx> hi, how to hunt down a hGetContents: invalid argument (invalid byte sequence)?
07:06:27 <blueonyx> piss-chri try hayoo
07:06:30 <chaosfisch> kuribas: You didn't show me. I've just asked if it exists :). Anyway - I got another question: ReadS is a list? -> why can't I use head on it?
07:06:37 <blueonyx> hayoo.fh-wedel.de
07:07:14 <cebewee> chaosfisch: type = ReadS  String -> [(a, String)]
07:08:05 <piss-christ> blueonyx: thanks
07:08:27 <cebewee> aeh. type ReadS = String -> [(a, String)]
07:08:32 <cebewee> so its a function, not a list
07:08:51 <kuribas> > foldl (\b c -> b*2+ digitToInt c) 0 "000101"
07:08:53 <lambdabot>  5
07:09:33 <kuribas> > let binToDec = foldl (\b c -> b*2+ digitToInt c) 0 in binToDec "000101"
07:09:34 <lambdabot>  5
07:11:41 * hackagebot hxt-regex-xmlschema 9.2.0 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.2.0 (UweSchmidt)
07:36:44 * hackagebot tasty-th 0.1.3 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/tasty-th-0.1.3 (BennoFuenfstueck)
07:41:44 * hackagebot hcltest 0.3.6 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.6 (BennoFuenfstueck)
07:41:46 * hackagebot haskell-generate 0.2.2 - haskell-generate  http://hackage.haskell.org/package/haskell-generate-0.2.2 (BennoFuenfstueck)
07:42:28 <chaosfisch> In ghci: How can I write [ and ]?
07:43:06 <joshc> chaosfisch: it is not clear what you are asking
07:43:18 <joshc> > [1,2,3]
07:43:18 <silver> > [1,2,3]
07:43:19 <lambdabot>  can't find file: L.hs
07:43:20 <lambdabot>  [1,2,3]
07:43:29 <joshc> :D
07:43:38 <silver> :)
07:43:44 <chaosfisch> I've loaded my hs file, and want to call a function. The function requires a list. However typing [ doesn't work.
07:44:08 <silver> > filter (>2) [1,2,3]
07:44:10 <lambdabot>  [3]
07:44:12 <joshc> in what way is it failing?
07:45:22 <chaosfisch> It's refusing the input
07:45:36 <chaosfisch> Like some sort of keyboard layout issue.
07:46:39 <silver> this is unusual, post the ghci output maybe? here http://lpaste.net/
07:47:13 <free_beard> > map (*2) [1,2,3]
07:47:15 <lambdabot>  [2,4,6]
07:47:17 <free_beard> cool
07:48:40 <hexagoxel> chaosfisch: so does '[' work outside of repl? what system are you on? what terminal program do you use?
07:51:26 <chaosfisch> mh, that's interesting. Looks like some kind of IDE - terminal bug. It works outside in a terminal now.
07:52:41 <hexagoxel> out of curiosity: which ide?
07:53:30 <piss-christ> this is weird. My program compiles with undefined function
07:53:43 <piss-christ> s/program/library
07:54:19 <hexagoxel> define "undefined function"
07:54:19 <chaosfisch> hexagoxel: Intellij Idea - I'm using this for haskell, just because I'm using it for everything else :)
07:54:48 <piss-christ> hexagoxel: I'm unable to create sscce now
07:55:57 <piss-christ> I have an instance Promise Package where execute p = unless (is_kept p) repair p
07:56:02 <piss-christ> but repair is undefined
07:56:03 <gcganley> if i type import Data.Monoid() what actually happens, does it tell the compiler "dont allow anything from This package". It seems like even though i thought thats what it did it imported instances
07:56:46 <geekosaur> that is precisely used to import instances
07:56:51 <geekosaur> you can't block instance import
07:57:03 <tremon> gcganley: it will not import data types or constructors, but it will import instances
07:57:15 <gcganley> ok, thank you
07:57:51 <geekosaur> there are arguments going on over whether some control over instance import is a good idea, but currently blocking instance import would allow you to e.g. create impossible Set or Map values
07:59:29 <hexagoxel> piss-christ: you mean "you don't define repair in this module; neither is it imported from somewhere else"?
07:59:42 <piss-christ> hexagoxel: yes
08:01:43 <piss-christ> also I don't import the class Promise and the library compiles but when I try to build a program against it, it rightly errors with the missing Promise
08:01:47 * hackagebot hspec2 0.5.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.5.1 (SimonHengel)
08:02:27 <piss-christ> the same with repair once I fix the missing Promise
08:02:36 <piss-christ> I wonder why it isn't catched when building the library only
08:06:48 * hackagebot data-interval 1.0.1 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-1.0.1 (MasahiroSakai)
08:06:51 <hexagoxel> piss-christ: are you sure you don't import them? it really should give errors the way you describe it. maybe post the module?
08:08:40 <piss-christ> hexagoxel: https://github.com/yaccz/singularity
08:09:47 <codygman> Trying to drop items of a list containing a specific string, can't remember how:
08:09:49 <codygman> > (map isInfixOf ".mp4") (["test.mp4"] :: [String])
08:09:51 <lambdabot>  Couldn't match expected type ‘[GHC.Base.String] -> t’
08:09:51 <lambdabot>              with actual type ‘[[a0] -> GHC.Types.Bool]’Couldn't match type ‘...
08:09:51 <lambdabot>  Expected type: [[a0]]
08:09:51 <lambdabot>    Actual type: [GHC.Types.Char]
08:10:09 <codygman> I know I could just use filter, but would like to try and use dropWhile
08:10:57 <kadoban> codygman: dropWhile and filter do different things you know, right?
08:11:46 <kadoban> codygman: dropWhile will stop once you find a non-matching and do nothing else, filter won't.
08:12:20 <zmbmartin> I am not sure how to solve this error. I just want to set the updatedAt on User to current time UTCTime? https://gist.github.com/codedmart/bcaaa64361a322130485
08:13:05 <geekosaur> zmbmartin: liftIO getCurrentTime
08:13:09 <piss-christ> is it possible to browse the modules hierarchy somewhere?
08:13:16 <zmbmartin> geekosaur: Duh, thanks
08:13:17 <piss-christ> So I can find out where to put my module
08:15:03 <gcganley> can cabal use GHC HEAD?
08:15:18 <hexagoxel> piss-christ: ah, the library simply does not contain Singularity.Promise.Package
08:15:53 <piss-christ> hexagoxel: so it's an effect of cabal bug?
08:16:03 <hexagoxel> (as exposed/other-module)
08:16:24 <hexagoxel> piss-christ: uh, no, i don't see any bug yet
08:16:24 <piss-christ> hexagoxel: https://github.com/haskell/cabal/issues/2170 this one
08:17:20 <Profpatsch> Can I simplify this? (\n -> g n < f n)
08:17:44 <gcganley> @ \n -> g n < f n
08:17:54 <gcganley> @pl \n -> g n < f n
08:17:54 <lambdabot> liftM2 (<) g f
08:18:11 <Profpatsch> Okay, apparently not. :)
08:19:35 <blueonyx> :t liftM2
08:19:37 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:19:49 <Denommus> Profpatsch: I think liftM2 (<) g f is prettier, personally
08:19:58 <gcganley> as do I
08:20:51 <thebnq> @unpl (<) <$> g <*> f
08:20:51 <lambdabot> (((<) <$> g) <*> f)
08:21:10 <bennofs> thebnq: \x -> g x < f x
08:21:43 <Profpatsch> Oh crap, it looks as if I haven’t understood Monads yet.
08:21:46 <Denommus> (<) <$> g <*> f looks very cryptic XD
08:22:08 <Profpatsch> Can someone describe liftM2 (<) g f in words?
08:22:12 <bennofs> It looks readable to me. Apply (<) to the results of the functions f and g
08:22:19 <Denommus> Profpatsch: well, technically you just need to understand applicative functors to understand lift
08:22:37 <gcganley> :t liftM
08:22:38 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:22:40 <gcganley> :t fmap
08:22:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:22:42 <cdk> Profpatsch: liftM2 (<) f g is using the ((->) r) instance of monad
08:22:43 <Denommus> bennofs: or, yeah
08:22:44 <Profpatsch> What is lifted in this case?
08:22:44 <gcganley> :t <$>
08:22:46 <lambdabot> parse error on input ‘<$>’
08:22:52 <gcganley> :t (<$>)
08:22:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:22:57 <gcganley> all the same
08:22:59 <thebnq> the monad and applicatives for (->) can be a bit confusing :D
08:23:00 <Denommus> :t liftM2
08:23:01 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:23:02 <cdk> so the 'm' in liftM2 type is (r ->)
08:23:03 <gcganley> just differing type classes
08:23:04 <Profpatsch> cdk: That isn’t helping. :D
08:23:05 <bennofs> Profpatsch: if you have a function a -> b -> c
08:23:13 <gcganley> is there fmap2?
08:23:17 <gcganley> :t fmap2
08:23:18 <lambdabot>     Not in scope: ‘fmap2’
08:23:18 <lambdabot>     Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
08:23:20 <cdk> Profpatsch: replace the m in liftM2 type signature with (r ->)
08:23:39 <Denommus> Profpatsch: ->, in Haskell, is just a normal type constructor like any other
08:23:48 <bennofs> Profpatsch: let's call it f. Then liftA2 'lifts' f in the sense that you have an extra 'm' everywhere: liftA2 f :: m a -> m b -> m c
08:23:53 <Profpatsch> Ugh, only it’s infix.
08:24:13 <Profpatsch> bennofs: What is the m?
08:24:19 <Denommus> Profpatsch: yup. And (r ->) is a monad.
08:24:21 <gcganley> monad
08:24:21 <bennofs> Profpatsch: any Applicative
08:24:26 <bennofs> Profpatsch: or Monad
08:24:40 <hexagoxel> piss-christ: let me ask again: why do you not expose Singularity.Promise.Package? at the moment, it is not part of the library, so it naturally does not build it when building the just the library.
08:24:46 <Denommus> Profpatsch: just like (Either a) would also be a monad
08:24:57 <Profpatsch> bennofs: And in that case? The monadic property of (<)?
08:25:03 <nshepperd> gcganley: it goes fmap, liftA2, liftA3
08:25:03 <Profpatsch> Or f and g?
08:25:13 <cdk> in this case, liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
08:25:14 <gcganley> :t liftA2
08:25:15 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:25:43 <gcganley> im looking for that but with functor type constraint
08:25:45 <bennofs> Profpatsch: in that case, m = (->) r     (which is like m = (r ->), but that's not valid haskell syntax)
08:26:00 <cdk> it does essentially this: \f g h -> (\r -> f (g r) (h r))
08:26:05 <bennofs> so, liftM2 f :: (r -> a) -> (r -> b) -> (r -> c)
08:26:14 <nshepperd> gcganley: there isn't any such thing, since you can't do liftA2 for arbitrary functors
08:26:50 * hackagebot dynamic-cabal 0.3.3 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.3.3 (BennoFuenfstueck)
08:26:51 <Denommus> Profpatsch: `(<)` is a `(a -> b)`. Since `(a ->)` is `m`, then `(<)` is a `m b`
08:27:12 <Profpatsch> Denommus: Oh, that makes it clearer!
08:27:24 <bennofs> Denommus: that's not relevant in this case though
08:27:42 <bennofs> :t liftM2  -- the first argument has no m at all
08:27:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:27:55 <bennofs> and (<) is the first argument
08:28:17 <Denommus> Profpatsch: it's just like Either a b
08:28:18 <Denommus> Profpatsch: except -> is infix
08:28:20 <Denommus> bennofs: ah, you're right
08:28:51 <Denommus> Profpatsch: the second and third arguments are the ones being lifted, but the reasoning is the same: (a ->) is a monad
08:29:10 <joneshf-laptop> is TH haskell98?
08:29:27 <bennofs> joneshf-laptop: ? TH is GHC extension, no standard
08:29:41 <bennofs> joneshf-laptop: in fact, even jhc doesn't support it iirc
08:29:53 <bennofs> (and jhc supports many of GHCs extensions)
08:30:58 <hexagoxel> piss-christ: (hmm, yes, the issue you referenced seems relevant. but it is not the root cause, just a "cabal did not warn me about root cause")
08:31:21 <geekosaur> TH kinda can't be supported by anything but GHC, since it's based on GHC's internal AST
08:31:36 <joneshf-laptop> ah
08:31:37 <joneshf-laptop> thanks
08:31:49 <bennofs> geekosaur: well, you could imitate it, couldn't you?
08:32:15 <geekosaur> only for simple cases, I think
08:32:58 <bennofs> geekosaur: but you could probably use GHC API to execute the TH, and then compile the result with another compiler?
08:33:07 <Profpatsch> I guess the reader monad goes well over my head.
08:33:15 <benzrf> Profpatsch: learn the reader functor first@!
08:33:15 <Profpatsch> Too much abstraction.
08:33:22 <benzrf> Profpatsch: then the reader applicative
08:33:26 <benzrf> finally, the reader monad
08:34:06 <geekosaur> bennofs: probably. I note that there is zeroth... but also that it has bitrotted
08:34:06 <gcganley> is there a reader functor?
08:35:26 <int-e> gcganley: sure. its fmap is function composition.
08:35:52 <gcganley> so fmap = (.)
08:36:12 <gcganley> :t (.)
08:36:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:36:15 <int-e> > (*2) `fmap` (+3) $ 10
08:36:16 <lambdabot>  26
08:36:37 <gcganley> > (*2) <$> (+3) $ 10
08:36:38 <lambdabot>  26
08:36:42 <lillian> sometimes i swear haskell looks as bizarre as perl
08:37:04 <rom1504> hopefully it's more powerful
08:37:05 <int-e> tweaking the presentation a bit, (.) :: (a -> b) -> (r -> a) -> (r -> b)
08:37:07 <gcganley> lillian: you can make any language look ugly, its easier to make haskell look pretty
08:37:13 <lillian> :3
08:37:24 <lillian> i'm just starting haskell
08:37:31 <lillian> coming from python
08:37:33 <gcganley> lillian: welcome!
08:37:48 <gcganley> lillian: what prompted you to learn haskell?
08:37:50 <lillian> <3 i also know html/css extremely well as well as Flask/Python :3
08:37:56 <piss-christ> hexagoxel: yep.
08:38:13 <gcganley> lillian: our usual web framework is yesod
08:38:15 <lillian> gcganley: oh the more i program the more i get into using more mathematical models, the more i get into algos, etc.
08:38:28 <gcganley> lillian: yesodweb.com i think is the URL
08:38:35 <lillian> oh im' not interested in haskell for web
08:38:48 <lillian> for example, i'm working on a game in python right now that's very well written
08:38:51 <gcganley> ok thats cool it just sounds like thats your day job
08:39:03 <lillian> gcganley:  yup!
08:39:06 <lillian> nailed it
08:39:19 <lillian> i do web programming for a company and some dumber webdev stuff
08:39:25 <lillian> and i've done programming here, in general
08:39:29 <lillian> ecommerce shit
08:39:31 <ajcoppa> lillian: by the way, #haskell-beginners is a really helpful channel that also has some good guidance on where to start if you're learning
08:39:40 <lillian> niiiiiice ty
08:39:48 <lillian> joined
08:40:00 <gcganley> lillian: how much have you learned in general?
08:40:16 <gcganley> lillian: up to monads or is that still witch magic?
08:40:25 <lillian> that's witch magic
08:40:37 <gcganley> lillian: how about functors
08:40:40 <lillian> i'm like... at what I perceive as lambdas and basic arithmatic stuff
08:40:46 <lillian> *arithmetic
08:41:09 <gcganley> ok, i know python isnt the best at recursion but how are you at programming recursive functions?
08:41:19 <danilo2> Hello! I've got just a simple question about name. What name should I use when creating a newtype which just applies identifier (an Int) to each tree node? I was thinking about the name "Fingered" - from Finger Tree, but it is not exactly what I mean
08:41:19 <kadoban> lillian: It gets much more fun later :)
08:42:59 <lillian> gcganley: i've made an a* algo before using recursion and sets
08:43:07 <lillian> but i'm not terribly great
08:43:20 <lillian> in fact i'm shit at recursion
08:43:51 <kadoban> You'll get better
08:44:06 <gcganley> what you take away from FP is different for each person
08:44:23 <lillian> furry porn?
08:44:31 <gcganley> -.-
08:44:41 <kadoban> XD
08:44:48 <lillian> jk
08:45:10 <lillian> also futanari palace
08:45:21 <gcganley> stop with the hentai talk lol
08:45:26 <lillian> IRLLOL'd
08:45:32 <gcganley> #haskell must remain pure
08:45:38 <lillian> good1
08:45:43 <lillian> yes sir, sorry sir
08:46:23 <gcganley> lillian: have you read any books or any tutorials?
08:46:37 <lillian> not fully, sir
08:46:50 <gcganley> dude im 17 i dont deserve sir
08:47:35 <zipper> gcganley: Kid
08:47:37 <lillian> Y-yes uhm... kid.
08:47:39 <zipper> gcganley: :)
08:47:49 <gcganley> BETTER
08:47:49 <gcganley>  
08:47:52 <lillian> :3
08:48:06 <gcganley> is there a way to like lyah?
08:48:08 <exio4> we're all kids
08:48:09 <gcganley> @lyah
08:48:10 <lambdabot> Unknown command, try @list
08:48:19 <gcganley> @link lyah
08:48:19 <lambdabot> Maybe you meant: pinky ping list kind
08:48:26 <gcganley> wat
08:49:10 <sivteck> @where lyah
08:49:11 <lambdabot> http://www.learnyouahaskell.com/
08:49:33 <gcganley> lillian: have you seen lyah?
08:51:20 <lillian> nop
08:51:23 <lillian> oh yes
08:51:43 <zipper> lol yeah I'm a kid too
08:51:48 <zipper> but I feel old
08:51:50 <zipper> I'm 21
08:51:57 <zipper> I'm a dinosaur.
08:51:57 <gcganley> lillian: read up until you dont grok anything they say and then come back here
08:52:11 <gcganley> zipper: im in my hs class right now....
08:52:24 <zipper> gcganley: Where?
08:52:27 <gcganley> zipper: im off to lunch in 4 min...
08:52:34 <exio4> I would like to have to learn Haskell
08:52:49 <gcganley> right now im learning Cisco routers
08:52:54 <exio4> so far everything cool I (try to) learn is because I was bored :(
08:52:56 <lillian> okais
08:52:57 <lillian> <3
08:52:58 <gcganley> zipper: near Boston
08:53:42 <phaazon__> god
08:54:00 <phaazon__> why I always feel stupid when I come across the EDSL with names binding in Haskell…
08:54:04 <zipper> gcganley: In Kenya reading the upenn lectures
08:54:32 <zipper> gcganley: Boston is home to expensive Ivy Leagues last I checked.
08:54:33 <phaazon__> I’d like to introduce a shader EDSL into my 3D engine, and hm… I suck so hard at writing EDSL :[
08:56:49 <saati_> main = putStrLn . show $ until (const False) (succ) (1 :: Int)
08:57:02 <saati_> why does this leak all the memory avalivable?
08:58:02 <phaazon__> saati_: because of the infinite loop :D
08:58:43 <exio4> I guess succ keeps getting "thunked"? because const is lazy in its second argument
08:58:44 <saati_> phaazon__: that explains the infinite runtime
08:58:58 <saati_> exio4: thanks, that's what just occured to me
08:59:00 <phaazon__> saati_: I guess it’s because of until being strict in its second arg?
08:59:27 <int-e> saati_: probably what happens is that the 1 is never incremented; instead you get "thunks" of the shape 1, succ 1, succ (succ 1), succ (succ (succ 1)) -- and remembering all those pending calls takes up heap space.
08:59:41 <phaazon__> yeah, what int-e said
08:59:53 <k00mi> phaazon__: it's lazy in it's second argument
08:59:53 <phaazon__> it’s lazy in the second arg, so that’s why it’s leak
08:59:56 <phaazon__> yeah
09:00:12 <phaazon__> talked too quickly :P
09:00:24 <kadoban> You can fix that with a `seq` if you want...although it'll still /eventually/ run out of memory, just really really slowly.
09:00:50 <saati_> kadoban: why will it run out of memory?
09:01:23 <kadoban> saati_: Well, an infinitely large number takes infinitely large amounts of memory to represent...
09:01:33 <int-e> right, there's even a good place to stick in the seq:  until (`seq` False) (succ) (1 :: Int)  (and it won't run out of memory because Int has bounded range)
09:01:35 <kadoban> saati_: Odds are good that your computer will stop working first, but XD
09:01:44 <k00mi> kadoban: it's an Int, so it'l just overflow
09:01:46 <kadoban> Oh, Int...sorry nevermind
09:01:48 <saati_> kadoban: doesn't Int wrap around like the cpu instruction?
09:02:32 <k00mi> > succ (maxBound :: Int)
09:02:34 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
09:02:50 <exio4> > (maxBound ∷ Int) + 1
09:02:51 <lambdabot>  -9223372036854775808
09:03:11 <saati_> thank you all, now it seems to run forever just fine
09:03:18 <kadoban> :)
09:03:32 <exio4> forever $ do nothing
09:04:26 <saati_> also the executable ghc produces doesn't really care about ^C while it's swapping
09:05:20 <saati_> it took minutes to regain a functioning system after i tried it in ghci
09:05:43 <josephle> nothing cares about ^C while in swap hell
09:05:58 <josephle> or rather, the signal will take its time to the target
09:06:33 <saati_> i waited in the order of 10 seconds before kill -9
09:07:15 <mathu> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
09:07:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
09:07:32 <mathu> regarding the above code sample, is the reason it runs with any respectable speed because of tail call optimization?
09:07:50 <cdk> mathu: it's memoized because of laziness
09:08:17 <josephle> mathu: what part of that expression is the tail call?
09:08:20 <mathu> cdk: ah, i see
09:08:21 <CindyLinz> remember to use ulimit -v some number, before trying... @@"
09:08:33 <mathu> josephle: i wasn't sure, that's why i was asking
09:08:35 <saati_> josephle: there is a call to tail :)
09:08:35 <mathu> :P
09:08:38 <mathu> hahaha
09:09:06 <mathu> i understand at a high-level what laziness entails, but is there a nice writeup of it somewhere?
09:09:08 <josephle> good one
09:10:21 <piss-christ> I have a detect :: IO (Detected) and detect' :: [String] -> Detected where the detect does only read a file and feed it to detect'
09:10:31 <piss-christ> what is the idiomatic way to deal with naming of such functions?
09:11:55 <Ankhers> piss-christ: is detect' only used in the context of the detect function?
09:12:07 <piss-christ> yes
09:12:16 <piss-christ> but I need it importable to so I can unit test it
09:12:24 <Ankhers> Maybe define it inline?
09:12:33 <piss-christ> also someone might want to use the detect' for some reason
09:18:09 <ifesdjeen> hi everyone, do you know how to embed Haskell runtime somewhere? I've already written bindings, although I can't figure out how to bundle the rts system into the library... and can't seem to find *.so and *.la files for rts, anyone knows what would be a way to solve it?..
09:19:50 <geekosaur> normally you use ghc to link, and it adds it. the runtime is a private library, and depending on ghc version may be static (.a). there is no .la file
09:21:56 * hackagebot network-simple 0.4.0.2 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4.0.2 (RenzoCarbonara)
09:21:58 * hackagebot chatter 0.5.0.0 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.5.0.0 (RoganCreswick)
09:22:44 <lpaste> NemesisD pasted “scoping” at http://lpaste.net/112980
09:23:24 <NemesisD> i know i've been bitten by this before. anyone know how to get those types to work out? i get could not deduce Default a1, Show a1
09:23:29 <Mitsos101> Are there any good Haskell books someone can recommend to me?
09:23:37 <srhb> NemesisD: forall a
09:23:39 <NemesisD> i need it to unity a with the a in the toplevel signature
09:24:24 <NemesisD> srhb: thanks!
09:31:57 * hackagebot hxt 9.3.1.9 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.9 (UweSchmidt)
09:32:39 <kadoban> Is there a nice HTML pretty-printer in haskell? I'm actually looking to compress HTML as much as possible (mostly drop whitespace), but I figure most pretty-printers can do that.
09:35:45 <danilo2> Hello! How can I in Haskell replace such instance "deriving instance (Show (f X), Show (f Y)) => Show Z with something like deriving instance (forall a. Show a => Show (f a)) => Show Z ?
09:36:32 <danilo2> Ah! A mistake! once again: Hello! How can I in Haskell replace such instance "deriving instance (Show (f X), Show (f Y)) => Show (Z f) with something like deriving instance (forall a. Show a => Show (f a)) => Show (Z f) ?
09:37:29 <bennofs> danilo2: that's not possible I think
09:38:05 <danilo2> bennofs: Oh, So I have to type the whole premise? I've got there about 10 such premises
09:40:34 <bennofs> danilo2: I'm not sure, there was a discussion about TypeHoles where you could write deriving instance _ => Show (Z f), and GHC infers what _ must be
09:40:35 <Cale> danilo2: It's probably possible to use this: http://hackage.haskell.org/package/constraints-0.4/docs/Data-Constraint-Forall.html
09:40:57 <bennofs> danilo2: not sure if that was already implemented in GHC though
09:41:10 <Cale> danilo2: But you'll have to unpack the instances you use manually in the implementation
09:41:27 <bennofs> ah, it's called PartialTypeSignatures now
09:41:42 <danilo2> bennofs: oh nice! Its not implemented - just tested with the newest one (not head, but not so old from git)
09:41:56 <bennofs> https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
09:41:58 * hackagebot focus 0.1.3 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-0.1.3 (NikitaVolkov)
09:42:13 <danilo2> Cale: interesting. Looking right now into it :) Anyway I'm afraid I will have some manual work here :(
09:43:27 <Cale> I wonder why there has to be two Skolem variables
09:44:06 <Cale> There's got to be a reason for that
09:44:37 <Cale> Not that as a user of that module you have to care
09:48:20 <gmx966> Hello
09:48:33 <Matrixman_217> gmx966: heyo
09:49:17 <gmx966> I'm new and my name is changing every minute, what's the problem?
09:49:37 <gcganley> gmx966: whats your IRC client?
09:49:56 <gmx966> webchat.freenode.net
09:50:22 <merijn> Maybe you're selecting a name that's registered already?
09:50:52 <gmx966> I received an email and I have confirmed
09:51:26 <bennofs> gmx966: then you need to /msg NickServ identify yourNick yourPwd maybe?
09:51:43 <gmx966> but I have the nick gmx966 and then gmx 96117 and then gmx96119 and so on
09:51:45 <geekosaur> gmx966, you will probably get better help in #freenoide
09:51:48 <geekosaur> er
09:51:49 <geekosaur> #freenode
09:52:29 <the8thbit|work> Hello!
09:52:52 <the8thbit|work> Is Learn You A Haskell for Great Good! a good introduction to Haskell?
09:52:57 <monochrom> yes
09:53:01 <gcganley> yes
09:53:01 <gmx966> I'll try #freenode
09:53:29 <kadoban> the8thbit|work: Sure. Also Real World Haskell and http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:53:39 <the8thbit|work> yeah, I was looking at those lectures
09:53:53 <the8thbit|work> kadoban: the wiki has a lot of intros. Which do you recommend?
09:54:33 <kadoban> the8thbit|work: I'd probably go back and forth between them as you get bored or confused with one. That's what I did with RWH and lyah until stuff finally clicked, I didn't know about those lectures at the time.
09:54:54 <the8thbit|work> kadoban: ok, thanks
09:55:03 <kadoban> 'welcome
09:55:17 <gcganley> the8thbit|work: you sorta bounce around as previously described
09:57:09 <bennofs> I only read LYAH (it doesn't teach any libraries except maybe mtl) and then used RWH when I wanted to know how to use some specific library
10:17:23 <lifter> What would be the most idiomatic way to divide an Integer by 10^12, and get an Integer result?
10:19:02 <Cale> n `div` 10^12
10:19:28 <lifter> Cale: Oh ok, thanks!
10:19:31 * glguy suspects Cale is up for the math challenge:
10:19:32 <glguy>  What's the least idiomatic way to do that?
10:19:47 <Cale> haha
10:20:04 <m1dnight> Hmm, I have a "discussion" with my friend here :p
10:20:15 <Cale> There's almost certainly an infinite succession of less and less idiomatic ways to do it
10:20:31 <m1dnight> What would be the best in general: (x == Type) && (y == Type)  or and $ map (== Type) [x,y] ?
10:20:39 <m1dnight> I think the latter is quite sexy :(
10:20:48 <bennofs> m1dnight: the first is easier to read and faster
10:20:55 <Cale> Well, the latter is the same as all (== Type) [x,y]
10:21:01 <glguy> The first is better, but if you want the second use all, not and
10:21:12 <glguy> and drop the extra ()s
10:21:25 <bennofs> m1dnight: but if you don't care about perf, all (== Type) is also ok IMP
10:21:30 <bennofs> s/IMP/IMO
10:21:42 <Cale> I don't think there should be a very significant performance difference
10:21:58 <bennofs> I think I had a case where there was
10:21:59 <albeit> Can I pattern match on a record like "foo :: Bar -> (); foo (MyBar{}) = ..."?
10:22:01 <Cale> In fact, they might even compile to the same thing :P
10:22:16 <Cale> You also might just do [x,y] == [Type, Type]
10:22:58 <Cale> Or given that Type is a data constructor, you might simply be able to pattern match on it
10:23:10 <Cale> rather than binding the variables x and y at all
10:26:48 <bennofs> Cale: ok you're right, at least for f x y z = all (x ==) [y,z] it compiles to exactly the same code as f x y z = x == y && x == z
10:29:28 <monochrom> GHC is sometimes smarter than you think. and some other times dumber. :)
10:36:40 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/ had my jaw dropped
10:40:32 <Cale> monochrom: Constructor specialisation followed by inlining?
10:41:05 <monochrom> I don't really know.
10:42:21 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
10:42:56 <Cale> I *think* the optimisation described in that paper explains what's going on :)
10:43:26 <Cale> oh
10:43:47 <Cale> hmm, that and/or the one case of CSE which GHC actually does
10:44:00 <Cale> which is nested case expressions that match on the same scrutinee
10:44:32 <Cale> It knows to only do the evaluation once
10:45:29 <bennofs> Isn't this just GHC realizing that it can prune a branch in case a of { Val{} -> case a of { Val{} -> A; _ -> B; }; _ -> C)
10:45:40 <Cale> Yeah, that sort of thing
10:45:52 <bennofs> realizing that B can never happen seems pretty straight forward to me (this happens with GADTs all the time, no?)
10:46:02 <Cale> If it gets code like that, it doesn't actually evaluate a twice
10:47:22 <Cale> It *is* interesting that it's eliminated the use of Bool from the guards altogether :)
10:48:17 <piss-christ> how can I find out which base I have?
10:48:23 <Cale> ghc-pkg list base
10:48:29 <piss-christ> oh, I just remembered
10:48:30 <piss-christ> thanks
11:06:12 <g966> Hello everybody
11:06:21 <johnw> hello g966!
11:06:50 <g966> What's the best book about Haskell?
11:06:56 <johnw> are you starting out from scratch?
11:07:04 <g966> Yes
11:07:08 <johnw> then @where lyah
11:07:11 <johnw> I recommend that
11:07:12 <johnw> @where lyah
11:07:12 <lambdabot> http://www.learnyouahaskell.com/
11:07:26 <johnw> it can be a touch silly, but it's fun and nicely paced
11:07:45 <g966> silly? What do you mean?
11:07:51 <johnw> you'll see what I mean :)
11:08:24 <g966> Haskell can't be so funny...
11:08:35 <johnw> oh, it can be hilarious
11:08:53 <g966> Wow! What a program!
11:09:57 <g966> I'll give it a try but next?
11:10:19 <johnw> after that you might try Real World Haskell
11:10:36 <g966> OK
11:12:08 * hackagebot boomange 0.1.1.1 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.1.1 (mgmillani)
11:12:10 * hackagebot descrilo 0.1.0.1 - Loads a list of items with fields  http://hackage.haskell.org/package/descrilo-0.1.0.1 (mgmillani)
11:12:12 * hackagebot simtreelo 0.1.0.1 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.0.1 (mgmillani)
11:12:30 <johnw> ReinH: heya
11:12:43 <g966> quit
11:13:05 <johnw> I can quit writing Haskell any time, I sweap
11:13:06 <johnw> swear
11:13:19 <monochrom> I can't. :)
11:13:29 <johnw> i'm speaking addict language :)
11:13:33 <johnw> heck, I can't even stop thinking about it
11:14:46 <monochrom> whenever people speculate about time machines and going back in time, my reaction is, I don't want to go back, there were no computer capable of running a good haskell compiler :)
11:14:54 <johnw> haha
11:15:36 <geekosaur> I, uh, remember the late 1960s and early 1970s. no desire to go back, tyvm
11:16:01 <joelteon> I remember the late 90s
11:16:25 <clrnd> lately I've been going to sleep while thinking in Prelude functions in pointfree style
11:16:55 <monochrom> not to mention that all the portable music was on sequential access cassette tape
11:17:09 * hackagebot colchis 0.2.0.1 - Rudimentary JSON-RPC 2.0 client over raw TCP.  http://hackage.haskell.org/package/colchis-0.2.0.1 (DanielDiazCarrete)
11:17:23 * monochrom is spoiled by GHC and iPod Touch!
11:17:46 <geekosaur> luxury! we had an 8-track player and "cheap" record players
11:18:13 <merijn> For someone who claims to be a haskell addict, my "bash-to-haskell" ratio of produced code is way to high :\
11:18:26 <johnw> merijn: for shame!
11:18:39 <johnw> gotta get you into shelly
11:19:13 <merijn> No good
11:19:24 <merijn> shelly wouldn't work on machines where I don't have haskell installed
11:19:37 <johnw> that's why you build static binaries in VMs, silly
11:20:58 <merijn> johnw: After I finish my backup scripts later today I'll show you what horrors I've concocted
11:21:05 <johnw> kk
11:21:23 <johnw> i'm so ready for OPLSS again
11:22:33 <joelteon> oh please, OPLSS
11:23:00 <merijn> johnw: If only I could get someone to pay for next year :p
11:23:16 <johnw> i've put it on my list of desired conferences to attend for next year at work
11:24:58 <monochrom> . o O ( why did Don Stewart go to OPLSS in winter? answer: he was doing PhD in Australia )
11:25:38 <geekosaur> oh, and MS BASIC :p
11:26:29 <monochrom> my favourite compilers back then were Turbo Pascal and Turbo C. (I was not prolog-savvy enough to use Turbo Prolog.)
11:28:02 <clrnd> QUICK BASIC had a really beautifull IDE, the docs were amazingly complete, with runnable examples, I learned a lot from it
11:29:29 <pjdelport> @unpl (.) (.) const map
11:29:29 <lambdabot> (\ e f -> map)
11:29:47 <pjdelport> (whoops, wrong channel)
11:30:10 <josephle> \msg lambdabot :t (.) (.) const
11:30:13 <josephle> oops
11:30:39 <clrnd> @pl map
11:30:39 <lambdabot> map
11:32:30 <fez> is this good? http://www.amazon.co.uk/gp/product/B00D388T3Q/ref=as_li_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=B00D388T3Q&linkCode=as2&tag=qid06-21&linkId=S4F4TFBEUJBQRM2H
11:33:12 <johnw> fez: that's really not related to Haskell
11:33:16 <geekosaur> I prototyped a customer's sales order pricing in Prolog in the early 1990s. but I'd need to study up to do it again now
11:37:44 <helmut> hi. is there some macro set by cabal mirroring --enable-tests I could check in an #ifdef?
11:38:29 <ReinH> johnw: hi
11:40:09 <bitemyapp> johnw: hi
11:40:30 <bitemyapp> johnw: I got nix working. Kinda. Not sure to what extent breakage was project specific or due to my install.
11:41:45 <johnw> bitemyapp: I hope you built GHC from source
11:41:52 <johnw> or are on Linux
11:42:28 <bitemyapp> johnw: I was on Linux, used (beta?) 1.8 dpkg.
11:42:44 <Normangorman> this feels like a really stupid question... I'm trying to access the API documentation for Yesod. I can't seem to find it anywhere. 'haddock Yesod.Core.Content' gives me an error that 'module Yesod.Core.Content is a package module'. Could anyone point me in the right direction?
11:42:47 <bitemyapp> johnw: I actually wanted to ask how the nix cabal is supposed to see the haskell packages installed via nix.
11:43:11 <Profpatsch> So, liftM2 and liftA2 are the same for Applicatives? And f <$> A <*> A, too?
11:43:30 <UnrealQuester> praise haskell
11:44:18 <johnw> Profpatsch: not necessarily
11:44:42 <johnw> Profpatsch: for example, in the Haxl project, their monad (liftM2) is sequential, whereas their applicative (liftA2) is concurrent
11:45:21 <zwer> johnw that sounds.. odd
11:45:25 <Profpatsch> johnw: It depends on the kind of Monad, right?
11:45:33 <johnw> Profpatsch: how do you mean?
11:46:02 <johnw> zwer: applicatives don't depend on the order of evaluation of arguments to <*>, so long as the laws are upheld; monads enforce order of evaluation by definition
11:46:04 <Profpatsch> johnw: A type can be monadic in more than one way, afaik.
11:46:35 <Profpatsch> There is an example in Learn you a Haskell somewhere.
11:46:39 <johnw> Profpatsch: yes, in the same way that type can be monoids in more than one way
11:47:12 * hackagebot fay 0.21.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.1 (AdamBergmark)
11:47:14 <beaky> hello
11:47:38 <johnw> beaky: ltns!
11:47:39 <beaky> what libs should i use for command line argument parsing
11:47:45 <johnw> optparse-applicative
11:48:31 <FireFly> I read through the Typeclassopedia section on Arrow and friends yesterday, but while I (think I) understand the hard definitions I'm not seeing why this particular abstraction would be useful... what are some interesting instances of Arrow that aren't (->)?
11:48:58 <clrnd> hey hey what was that paper about the category of drawings of categories?
11:49:19 <benzrf> FireFly: Kleisli m, i suppose
11:49:26 <beaky> wow optparse-applicative looks very nice
11:49:37 <beaky> thanks ill give it try
11:49:47 <benzrf> FireFly: any Category with a functor from hask and the proper tensorial strength or whatever, i think
11:49:48 <vjeranc> how can I start a clean cabal sandbox with only base packages installed? for some reason I no longer can do that...
11:49:56 <FireFly> But then I need to understand when Kleisli would be useful >.<
11:49:56 <benzrf> but mostly various kinds of functions
11:50:04 <FireFly> (which I perhaps should also try to do)
11:50:12 <benzrf> FireFly: when u wanna use arrows but they're kleisli arrows
11:50:15 <benzrf> :t Kleisli
11:50:16 <lambdabot> (a -> m b) -> Kleisli m a b
11:50:32 <benzrf> FireFly: do you understand Control.Category.Category?
11:51:05 <FireFly> I think so
11:51:44 <nawal> hi guys
11:51:45 <nawal> Illegal binding of built-in syntax
11:52:00 <nawal> Im trying to recompile ghc-prim (for lulz)
11:52:12 * hackagebot fay-base 0.19.3 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.3 (AdamBergmark)
11:52:18 <nawal> I've renamed everything with GHC.NNNN to stuffGHC.NNNN
11:52:33 <Normangorman> vjeranc: cabal sandbox init
11:52:54 <nawal> Somehow there must be a way to compile ghc-prim, because somebody clearly did it so I could get a binary ghc install
11:53:29 <geekosaur> nawal: ghc-prim must be built as part of a compiler, not standalone
11:54:01 <vjeranc> Normangorman: that is exactly what I do, and then the cabal install --only-dependencies suddenly has clashes with quickcheck, vector, attoparsec etc... I've recently reinstalled everything to ghc 7.8.3 and didn't touch any conf files...
11:54:45 <nawal> geekosaur, what I'm trying to do is to get rid of cabal hell, by rebuilding everything with a different name for each version
11:55:04 <nawal> so I found that ghc-prim is the lowest common denominator for everything.
11:55:19 <geekosaur> that would be because it is GHC primitives, i.e. COMPILER BUILT-INS
11:55:36 <geekosaur> it cannot exist standalone
11:55:45 <nawal> Let's say I pick something else, won't I have the same problem when that lib has a dependency that ends with a different version of ghc?
11:55:56 <nawal> *ghc-prim
11:56:06 <nawal> well okay, I'll find something else to knock my head against.
11:57:13 <geekosaur> basically ghc-prim is references to compiler guts. only the compiler knows them so it's generated *along with* the compiler; from outside, the only way to get at them is the ghc-prim that was generated as part of building that compiler
11:57:19 <nawal> what about things like deepseq, unix, binary, bytestring, containers, etc? They seem to have come with the fresh install of ghc
11:57:41 <geekosaur> yes, those are compiler "boot libraries", they come with and are essentially part of the compiler and runtime
11:57:48 <nawal> okay :-)
11:57:48 <geekosaur> and can't be replaced without breaking everything
11:58:28 <geekosaur> (well, the core compiler will "work" but ghc-api, template haskell, etc. will not)
12:02:53 <Evilsparza> hey guys
12:03:00 <happy0> yoyoyoyo~
12:03:05 <Evilsparza> do I need to install some third party package for Data.List.Split?
12:03:18 <Evilsparza> ghci tells me it can't find the module Data.List.Split
12:03:19 <kadoban> Evilsparza: Yeah. 'split'
12:03:23 <Evilsparza> Data.List works fine
12:03:27 <Evilsparza> ok via cabal?
12:03:48 <kadoban> Evilsparza: Yeah, from hackage. You can find out if you hoogle for Data.List.Split, just for next time
12:04:09 <dcoutts_> it's on my TODO list to include module names into the hackage search, and to add it to cabal too
12:04:20 <dcoutts_> for just this kind of question
12:05:09 <nawal> geekosaur, I want to install accelerate by building as mch as I can in its own namespace. I tracked down a dependency fclabels, which has a dependency mtl.
12:05:21 <codygman> kadoban: Interesting, I see what you mean:
12:05:25 <codygman> > dropWhile (== 1) [4,3,2,1]
12:05:27 <lambdabot>  [4,3,2,1]
12:05:32 <codygman> > dropWhile (== 1) [1,2,3,4]
12:05:34 <lambdabot>  [2,3,4]
12:05:42 <kadoban> codygman: Exactly
12:05:45 <nawal> So I'm now trying to prepend V2m2m1mtlV to eerything it exports
12:07:13 <ifesdjeen> is there any way to find out a current ghc version within the cabal file?
12:07:58 <monochrom> people do it indirectly by the version of base
12:08:04 <codygman> kadoban: Can you show me something that dropWhile is used for? I'm still stuck thinking of it like filter and not sure of its use. For instance:
12:08:07 <codygman> > dropWhile (>= 3) [1,2,3,4,5]
12:08:09 <lambdabot>  [1,2,3,4,5]
12:08:30 <geekosaur> in the cabal file itself? I think you want impl()
12:08:32 <mauke> > dropWhile isSpace "\n\t     hello"
12:08:33 <lambdabot>  "hello"
12:09:12 <joseanpg> Hi
12:09:40 <kadoban> codygman: One thing it's useful for is if you have like a sorted sequence and aren't interested in the terms until you hit a certain value. I used it recently for culling primes below the part I was interested in from an infinite list of them for example
12:10:24 <kadoban> codygman: There it functions a lot like filter, which is inevitable really since it does something...kind of similar, just different semantics.
12:10:36 <scaroo> Hello there. I am looking for an http client library supporting server-sent events (or eventsource as drafted by w3c). Does it ring a bell to any of you ? Cheers!
12:10:37 <helmut> can I somehow #if using_a_bootstrapped_compiler?
12:11:01 <bennofs> helmut: why do you need this?
12:11:46 <Cale> helmut: er, I'm unsure of what you mean by that, so I guess I'll go with bennofs' question :)
12:12:12 <kadoban> codygman: It also could make sense in anything with an order to it, like say a log file and you're only interested in stuff after a certain event happened, or after a certain time.
12:12:32 <helmut> bennofs: because run_tests = $quickCheckAll fails on a non-bootstrapped compiler
12:12:37 <codygman> kadoban: Alright, thanks.
12:12:53 <Cale> helmut: Oh, you're using a compiler with no TH
12:12:54 <bennofs> helmut: by non-bootstrapped, you mean it doesn't support TH?
12:13:12 <helmut> quoting the error message:
12:13:12 <helmut> ShellCheck/Parser.hs:1:1: Can't do a top-level splice; need a bootstrapped compiler
12:13:20 <Cale> Yeah
12:13:34 <bennofs> helmut: I think it should be possible to check if the TH extension is available using Cabal (not sure)
12:13:44 <Cale> helmut: That usually ought not to be a problem unless the code you're writing is part of GHC
12:13:56 <helmut> Cale: it makes the build fail
12:14:10 <monochrom> are you building GHC itself?
12:14:20 <helmut> I am trying to build shellcheck
12:14:32 <Cale> helmut: I mean, usually you'd just finish building GHC, and then compile your code with a complete build of GHC instead of some stage 1 build
12:14:33 <adamse> i'm trying to use the "enableGUI" trick on OSX to be able to run gui programs from ghci, but i cannot get it to work: GHCi recompiles it and fails to find symbol CPSSignalAppReady
12:14:41 <adamse> anyone who knows a solution?
12:14:51 <helmut> Cale: ok, where can I obtain a full build of ghc for ppc64el?
12:15:25 <piskrist> How do I upload package to hackage? I have created an account but cabal upload errors with 401 unauthorized. I suppose I need to create a package first, but how? I don't see such option in cabal and I don't see how to login on hackage website
12:15:35 <piskrist> and my cabal check is passing
12:15:45 <helmut> Cale: or for arm v7, arm v8 or aarch64 or mips, mipsel, ...
12:15:46 <Evilsparza> could you give me a hint towards where I should look if I want to work with binary (base2) numbers in haskell? are there any libraries I couldn't find directly through google or is it best to just work with lists of 1s and 0s? :P
12:15:56 <helmut> Cale: none of these architectures has th support.
12:16:16 <helmut> Cale: you cannot "just build ghc with th" there. the code isn't written yet.
12:16:19 <bennofs> Evilsparza: what operations do you expect?
12:16:25 <bennofs> Evilsparza: see also Data.Bits
12:16:35 <Cale> helmut: Okay, so you *are* working on GHC itself?
12:16:37 <RyanGlScott> hamishmack: Is the glade Haskell library considered deprecated? i.e., should we just use Graphics.UI.Gtk.Builder instead?
12:16:46 <helmut> Cale: no, I am using pre-built ghc on ppc64el
12:16:55 <bennofs> Evilsparza: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Bits.html
12:16:56 <helmut> Cale: but that ghc comes without th
12:17:12 <Evilsparza> bennofs mostly binary<->decimal conversion, shifting and standard and/or/xor etc. I'll have a look at Data.Bits thanks
12:17:13 <Cale> helmut: Maybe try using your stage1 ghc binary there to build the source distribution of GHC
12:17:23 <Cale> helmut: and see if it'll compile
12:17:38 <geekosaur> TH can't be built separately from ghc, is the point here
12:17:45 <Cale> I don't really know a whole lot about this process, but it's what I'd try first.
12:17:48 <geekosaur> it has to be built *into* ghc
12:17:49 <bennofs> Cale: I think it might not be possible to use TH on these architectures at all
12:18:06 <helmut> what bennofs said
12:18:17 <helmut> Colin Watson spent *months* to port TH to powerpc
12:18:19 <Cale> bennofs: er, I can understand if you were using GHC as a cross compiler
12:18:27 <Cale> hm
12:18:31 <helmut> it's not like you can just build it, you have to do actual work.
12:18:32 <monochrom> helmut, you may simply have to not use TH. or if you say, you're writing one lib for multiple platforms, then a more possible question in a *.cabal file is "what is my platform" rather than "what is my ghc"
12:18:36 <nawal> Okay... so mtl-2.2.1 insists on transformers == 0.4.*
12:18:43 <johnw> TH needs to be able to load object files
12:19:08 <geekosaur> and the problem, at least in the past, was that it has to use the bytecode backend and its custom linker; on arm, the custom linker simply does not exist. 7.10 is working on moving to the system linker, I believe, but it may not be completely implemented
12:19:08 <nawal> and the one that came with my ghc is transformers-0.3.0.0
12:19:12 <helmut> monochrom: yes of course, I would like to notice the absence of TH and build the library without test suite then
12:19:22 <helmut> monochrom: TH is only needed for quickCheckAll
12:19:26 <bennofs> The question is whether it's possible to check if GHC supports TH using CPP or similar
12:19:27 <Cale> You can of course {-# LANGUAGE CPP #-} and then define something with a -D flag based on which platform you're building for
12:19:34 <helmut> bennofs++
12:19:53 <geekosaur> nawal: you can't replace it, if you need mtl-2.2.1 then you need a newer ghc
12:19:54 <helmut> Cale: the latter half of your suggestion is what is unclear to me.
12:20:04 <monochrom> helmut: actually, you can probably just ask "does template-haskell exist"
12:20:19 <Cale> helmut: Well, I don't think a symbol already exists, you'd just make it up and set it yourself
12:21:00 <helmut> monochrom: how do I ask that in a way cabal/CPP understands?
12:21:01 <nawal> geekosaur, well the latest I can find is 7.8.3...
12:21:09 <dfeuer_> Cale, I think LANGUAGE CPP is fundamentally a mistake. If you want to apply the C preprocessor to your Haskell files, you should have to do it your own damn self.
12:21:25 <bennofs> helmut: you use a custom Setup.hs
12:21:27 <Cale> dfeuer_: I dunno about that
12:21:37 <bennofs> dfeuer_: it's convenient if you use ghci :)
12:21:43 <Cale> dfeuer_: I mean, maybe we should have our own complete version of CPP to avoid stupid problems
12:21:52 <nawal> geekosaur, well I guess I could look for an mtl that uses the older transformer
12:21:53 <helmut> bennofs: ugh. that sounds like more work.
12:21:53 <geekosaur> yes, the mtl rev is intended for 7.10 which is in development, because of the AMP (Monad requires Applicative). is there some reason you *must* use the latest mtl?
12:22:04 <Cale> dfeuer_: But having that kind of facility can be useful
12:22:22 <nawal> No, I just looked up the dependencies for accelerate which pointed to fclabels which pointed to mtl
12:22:35 <dfeuer_> Cale: CPP is an ancient and awful macro processor designed for an utterly unrelated language. Why should anything to do with it be in a Haskell compiler?
12:22:42 <helmut> bennofs: maybe I just write a patch that discards the test suite and apply that on "weak" architectures before even running setup. it's a gross hack, but very easy.
12:22:45 <nawal> basically I'm trying to figure out how cabal goes about doing its business, so I can understand the way to avoid cabal hell
12:23:09 <geekosaur> nawal: you're finding out why cabal has problems, the hard way :) cabal is the *victim*; ghc is the problem
12:23:26 <geekosaur> people blame cabal because cabal is what delivers the bad news; but it's ghc that is creating the bad news
12:23:27 <Cale> dfeuer_: Well, there are various things that it does which are handy, like conditionally building different code when haddock is processing the file, for instance.
12:24:21 <piskrist> dfeuer_: CPP is good for some stuff https://github.com/sol/hspec-example/issues/5
12:24:25 <helmut> can I somehow turn --enable-tests into a CPP macro?
12:24:43 <nawal> geekosaur, oh yeah I'm okay with that - I've read the article "cabal is not a package manager
12:24:49 <dfeuer_> Cale: it would actually make somewhat more sense to me to include an *incomplete* version, leaving out the worst horrors.
12:24:53 <nawal> and yes I hate the way ghc does packages
12:24:54 <piskrist> dfeuer_: your argument smells like X can be used for bad things, therefore X is evil
12:25:46 <albeit> Is there an easy way to keep track of non-dead threads? I need some fast data structure that can track child threads and as soon as they are done they are removed...
12:25:56 <nawal> still, this is kinda fun :P I've recently read SICP, and before I give up on haskell completely and write my own lisp, I'd like to have a go at fixing the dependency thing a bit like the way nix does it
12:26:13 <bennofs> nawal: have you read http://www.vex.net/~trebla/haskell/sicp.xhtml ?
12:26:44 <monochrom> helmut: what are the values of System.Info.os and System.Info.arch on the desired platforms? then you can use them in "if os(...)" and "if arch(...)". there is more in http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
12:27:17 <nawal> bennofs, thanks for that! Will read/bookmark/reference
12:27:27 <nawal> I love how it's called sicp.xhtml :P
12:27:46 <nawal> Is that a coincidence, or is it meant to refer to mit scheme?
12:28:01 <geekosaur> monochrom has quite the sense of humor :)
12:28:06 <geekosaur> (yes, it's deliberate)
12:28:11 <nawal> haha okay :P
12:28:16 <Fuuzetsu> there is no mit scheme called SICP ;P
12:28:27 <helmut> monochrom: os is linux/freebsd/hurd, but for all os it builds just fine when the architecture is i386
12:28:34 <nawal> Ah yes I should have read the first few paragraphs first
12:28:58 <helmut> monochrom: as for the architecture, it seems th is only supported on i386, amd64 and powerpc. all other architectures lack th.
12:29:19 <piskrist> How do I upload package to hackage? I have created an account but cabal upload errors with 401 unauthorized. I suppose I need to create a package first, but how? I don't see such option in cabal and I don't see how to login on hackage website
12:29:25 <nawal> Fuuzetsu, I was refering to the book, it uses MIT scheme
12:29:31 <Fuuzetsu> I'm aware.
12:29:44 <nawal> right
12:29:54 <helmut> monochrom: I can add a test suite flag of course. :)
12:31:31 <bennofs> piskrist: what package are you trying to upload? have you checked that a package with the same name does not already exist?
12:31:47 <monochrom> helmut: then you can "if arch(i386) || arch(amd64) or arch(powerpc)" enable the TH tests "else" disable. you can, and probably have to, "enable" and "disable" by setting a flag
12:32:16 * hackagebot fay 0.21.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.2 (AdamBergmark)
12:32:18 * hackagebot fay-base 0.19.4 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.4 (AdamBergmark)
12:32:24 <helmut> monochrom: I'd rather like not to hard code architectures as someone might make TH work on arm64 soon.
12:32:25 <bennofs> helmut: btw, can't you just remove the TH for all platforms?
12:32:37 <helmut> bennofs: it's just quickCheckAll
12:32:47 <bennofs> helmut: meaning, doing what quickCheckAll does for you manually?
12:33:04 <helmut> bennofs: not bad. ;-)
12:33:32 <piskrist> bennofs: I moved to #hackage as it seems more appropriate. I'm trying password reset
12:33:37 <bennofs> helmut: might be the easiest fix. and improves compile times too :)
12:34:11 <helmut> bennofs: given that there are 653 prop_ symbols, this does not seem a useful exercise to me.
12:34:27 <Yxven> if anyone is familiar with profiler issues,  I could use some help http://www.reddit.com/r/haskellquestions/comments/2jwgmc/i_cant_profile_my_gloss_game/
12:34:33 <bennofs> helmut: ah :| maybe write a generator script? :P
12:35:21 <helmut> bennofs: this all sounds like a rather intrusive change
12:35:23 <bennofs> Yxven: I never used the -e8in option to hp2ps, what does that do?
12:35:33 <DrHyy> is there an XCB binding for Haskell?
12:35:49 <bennofs> helmut: well, for people adding new tests the work is not so much (they only have to add their test to the list)
12:35:59 <bennofs> DrHyy: probably, I think xmonad uses it
12:36:54 <Yxven> bennofs: no clue. It's what is used in real-world Haskell, and it is not explained.  I've also tried it without that option, but I didn't notice any difference
12:37:17 * hackagebot fay-text 0.3.2 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.2 (AdamBergmark)
12:37:19 * hackagebot os-release 0.1.0 - /etc/os-release helpers  http://hackage.haskell.org/package/os-release-0.1.0 (yac)
12:37:36 <DrHyy> bennofs: no bennofs, xmonad does not use xcb. try XHB @ http://www.haskell.org/haskellwiki/XHB for XCB support in haskell
12:37:39 <helmut> so thank you all for your ideas, I'll have to sleep over all the options and pick one that makes it work very quickly.
12:37:54 <helmut> and then also find a way that is acceptable to the ShellCheck maintainer
12:38:21 <bennofs> DrHyy: ah right. All those X libraries are confusing :) Just today I learned about the various libraries that are used for font rendering
12:40:15 <DrHyy> oooh lookie: https://hackage.haskell.org/package/xhb
12:41:15 <levi> Not a lot is left for the X protocol itself to do in "modern" desktop shells.
12:41:17 <geekosaur> xmonad was originally written before xhb was a thing. sjanssen considered redoing it later but it wasn't possible without breaking pretty much everything
12:41:48 <geekosaur> (because xmonad sits so close to Xlib, and xcb / xhb is quite a bit different in fine details)
12:42:05 <latk> what is the best way to parse something 0 or 1 times in attoparsec ?
12:42:09 <DrHyy> geekosaur: then we make a NEW compositing manager written for xhb
12:42:14 <vanila> oh wow xhb loks nice!
12:42:21 <Normangorman> latk: parse a character?
12:42:22 <vanila> I was doing a bit with binding to xcb before
12:42:46 <vanila> does anyone using xhb know how to handle window resizing properly? I had problems with lag and overdraw
12:42:47 <monochrom> latk: it may go by a name like "option" or "optional" or both. I'm guessing based on knowing parsec.
12:43:42 <latk> Ah, I mean to apply a  given parser once or zero times
12:43:56 <latk> Normangorman: So not necessarily a character
12:44:07 <albeit> Does takeMVar invoke a system call?
12:44:17 <monochrom> yes, "option" and "optional" takes an arbitrary parser.
12:44:28 <albeit> * system call / context switch
12:44:39 <latk> monochrom: option looks like it applies a parser, and has a default action to perform if it fails ?
12:44:50 <monochrom> hmm, let me look
12:44:52 <latk> I can't see optional :s
12:44:52 <vanila> this is the only package which depends on xhb http://hackage.haskell.org/package/robot
12:44:59 <vanila> I need more code to learn from :(
12:45:16 <monochrom> no, default value
12:45:24 <vanila> I should probably start by porting my xcb stuff to use xhb rather than my bindings first
12:45:39 <latk> monochrom: Right, true
12:45:40 <monochrom> "option 4 (a_parser_that_gives_you_an_Int)"
12:45:57 <merijn> albeit: No, why would it?
12:46:07 <latk> I guess I want something that behaves like many, except it only works at most one
12:46:09 <latk> er once
12:46:45 <mauke> fmap (: []) p <|> pure []
12:46:56 <monochrom> yeah :)
12:47:23 <monochrom> well, I was thinking option [] ( (: []) <$> a_parser_here )
12:47:27 <albeit> merijn: Not sure.. it just seems to take a while to take then put. About 9 microseconds... seems long no?
12:47:58 <merijn> albeit: It has to take a lock twice
12:48:00 <monochrom> or, Maybe is probably better than []. so, fmap Just p <|> pure Nothing
12:48:03 <latk> Ah, cool. Thanks!
12:48:14 <monochrom> or option Nothing (Just <$> p)
12:49:15 <albeit> merijn: Ah okay, so its taking the lock that it the slow part
12:50:20 <merijn> albeit: Plus, you're doing something in between the take and put, no?
12:50:45 <albeit> merijn: I was, but just simplified it to "val <- takeMVar foo; putMVar foo val" to see how long it takes
12:52:14 <albeit> merijn: I'm just storing child thread ids in the mvar, and killing all of them later on, but was hoping it would be faster.
12:52:53 <merijn> albeit: Try IORef, it's faster
12:53:07 <merijn> albeit: Although that does stop you from having an "empty" value
12:54:33 <albeit> merijn: Shall do! Why is IORef faster? Wouldn't it have to take a lock as well?
12:57:50 <merijn> albeit: MVar's need to check whether it's empty, take the value out, mark it empty for others to block on it, etc.
12:58:42 <bennofs> aren't iorefs implemented as an atomic pointer swap?
12:58:54 <johnw> yeah, MVars manage a queue of consumers
12:59:05 <johnw> to ensure fairness, etc.
12:59:23 <merijn> bennofs: Well, you can do atomic updates on IORef, so I think they're slightly more expensive then that, but not much
12:59:37 <merijn> There's a library for atomic CAS nowadays
13:01:12 <monochrom> you may be able to just use atomicModifyIORef
13:02:11 <monochrom> MVar is appropriate when you "wait for the other thread to give/take stuff" rather than simply "share a mutable cell"
13:02:19 * hackagebot extra 0.3.2 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.3.2 (NeilMitchell)
13:02:21 * hackagebot conceit 0.1.1.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.1.1.0 (DanielDiazCarrete)
13:02:26 <razzi> while playing around with lists, I wrote a function which I thought would freeze: stalledList = [0, 1] ++ tail stalledList but when I ran it [0, 1, 1, 1, ...] was returned. How did it evaluate tail without calling tail first and therefore hanging?
13:03:01 <johnw> it didn't evaluate tail
13:03:07 <mauke> stalledList = (++) [0, 1] (tail stalledList)
13:03:11 <mauke> it did ++ first
13:03:18 <johnw> it returned (++) [0,1] <thunk>
13:03:19 <mauke> @src (++)
13:03:19 <lambdabot> []     ++ ys = ys
13:03:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:03:20 <lambdabot> -- OR
13:03:20 <lambdabot> xs ++ ys = foldr (:) ys xs
13:03:46 <mauke> [0, 1] is syntactic sugar for (0 : (1 : []))
13:03:53 <razzi> good to know! Thanks for helping a noob
13:04:00 <merijn> razzi: It's the same neat trick as
13:04:14 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
13:04:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:04:23 <exio4> > let lst = [0] ++ tail lst in head lst
13:04:24 <lambdabot>  0
13:04:29 <exio4> > let lst = [0] ++ tail lst in tail lst
13:04:33 <lambdabot>  mueval-core: Time limit exceeded
13:05:10 <merijn> razzi: Remember, everything is lazy and doesn't get computed until it absolutely has to. And by that time, it my actually have a sensible answer
13:06:37 <monochrom> I just have some reservations on the wording "absolutely has to".
13:06:53 <merijn> monochrom: Yeah, so do I
13:07:13 <merijn> monochrom: But then I figured anything more precise would be even more confusing
13:07:47 <monochrom> there is a very specific rule of what to evaluate, and it usually differs from humans subjective but smart "absolutely have to". the typical example is "if 1/0 then () else ()"
13:09:06 <monochrom> my imprecise intuitive wording is "short-circuit"
13:11:10 <johnw> let's just lazily-evaluate the meaning of "absolutely have to"
13:11:20 <johnw> wee
13:12:01 <monochrom> haha
13:12:35 <monochrom> I have a related relevation the other day. using dive-in projects to learn Haskell is a meta-level exercise of lazy evaluation.
13:13:06 <WigglesMcMuffin> Can someone help me with a quick conceptual problem? Mostly just "haskell comprehension"? How would you write foldl (=) 0 $ map (3*) [1..20] as dot notation?
13:13:17 <WigglesMcMuffin> *foldl (+)
13:14:06 <mauke> sum ((map . (*)) 3 [1 .. 20])
13:14:44 <josephle> :t \x -> foldl (+) 0 $ map (3*) x
13:14:45 <lambdabot> Num a => [a] -> a
13:14:53 <josephle> :t foldl (+) 0 . map (3*)
13:14:54 <lambdabot> Num a => [a] -> a
13:15:13 <monochrom> (sum . map (3 *)) [1..20]
13:15:23 <WigglesMcMuffin> mauke: I know sum is a thing that's not the problem, I'm trying to figure out how to do dot notation on something that takes extra arguments
13:15:34 <monochrom> replace sum by foldl (+) 0 if you like
13:15:54 <mauke> > (foldl (+) 0 . map (3 *)) [1 .. 20]
13:15:55 <RyanGlScott> It looks like OverloadedStrings allows you to pattern-match on IsString instances. Does OverloadedLists allow you to pattern-match on IsList instances?
13:15:56 <lambdabot>  630
13:15:59 <centipede> anyone using the cereal package?
13:16:19 <mauke> > 20 * (20 + 1) `div` 2 * 3
13:16:20 <lambdabot>  630
13:16:24 <merijn> centipede: I have in the past, but it's (mostly) superceded by binary these days
13:16:25 <johnw> WigglesMcMuffin: you'd need (foldl (+) 0 .) . map
13:16:40 <merijn> centipede: Since binary now has incremental deserialisation too
13:17:01 <centipede> merijn: thanks. that sounds nice. i'll have a look at that library then
13:17:14 <merijn> centipede: They're mostly identical in design anyway
13:17:46 <WigglesMcMuffin> johnw: Thanks guys. I still have much to learn :) but it's all a very fun and new experience
13:17:54 <centipede> merijn: I see. Great. Thank you very much :-)
13:18:00 <merijn> centipede: Slightly different names for some things, but still. There was some ideas to fully merge cereal into binary, anyway there's not a lot of difference in general
13:18:27 <johnw> WigglesMcMuffin: you can also ask lambdabot with @pl
13:19:02 <johnw> @pl \f x -> foldl (+) 0 $ map f x
13:19:02 <lambdabot> (foldl (+) 0 .) . map
13:19:05 <centipede> merijn: Documentation seems more thorough, I guess that'll do
13:20:04 <WigglesMcMuffin> johnw: Hey that's neat! Good to know thanks
13:20:32 <josephle> although @pl may reduce the readability of your code, so use it wisely
13:20:51 <FireFly> "may"
13:21:04 <bitonic> how can I instruct ghci to the same effect I instruct cabal about include files with `include-dirs'?
13:21:06 <FireFly> @pl \f g h x y -> g x `f` h y
13:21:06 <lambdabot> ((flip . ((.) .)) .) . (.)
13:21:08 <S11001001> edwardk: would you take a foldl1/foldr1 on Foldable1?  would that need a libraries discussion?  (my main beef is, say, with foldr1 that takes (a -> a -> a) instead of (a -> b) and (a -> b -> b))
13:21:27 <bitonic> I'm trying with -optP '-I.'
13:21:37 <centipede> is there any quick way to remove a package from a cabal sandbox?
13:21:53 <WigglesMcMuffin> josephle: No worries, there isn't any code yet. I'm still just learning new stuff :P
13:21:59 <S11001001> edwardk: ideally Data.Foldable would change too but that seems a big mission.
13:22:31 <josephle> FireFly: sometimes @pl doesn't adversely affect readability
13:22:48 <FireFly> Sure, that's true
13:23:36 <FireFly> @pl \f g h y -> g y `f` h y  -- this function, related to the above, @pl's quite neatly
13:23:37 <lambdabot> liftM2
13:24:13 <vanila> :t \f g h x y -> g x `f` h y
13:24:14 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t1) -> (t4 -> t2) -> t3 -> t4 -> t
13:24:57 <Fuuzetsu> centipede: there's delete-source or something like that IIRC
13:25:35 <platz> any idea what might be going on with hGetBufSome: resource exhausted (windows) ?  http://lpaste.net/112989
13:32:23 <centipede> fuuzetus: thanks. it's cabal sandbox hc-pkg unregister <pkg-name> (the package files are not deleted though)
13:33:41 <lifter> I find I had to put all the type annotations in to get the typechecker to stop warning me about defaulting to Integer. Is there a better way? "let (factor :: Double) = fromIntegral $ ((10 ^ (12 :: Integer)) :: Integer)"
13:36:39 <benzrf> :t on
13:36:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:36:47 <benzrf> @src on
13:36:47 <lambdabot> (*) `on` f = \x y -> f x * f y
13:36:54 <benzrf> not quite :\
13:37:28 <centipede> merijn: I am a bit confused. (encode . decode) s always yields ()
13:37:55 <centipede> merijn: err, i mean:  (decode . encode)
13:38:20 <geekosaur> lifter: :seti -fno-warn-type-default
13:38:42 <lifter> geekosaur: Yeah I've been thinking of just doing that, thanks. Will go for it.
13:42:24 * hackagebot Rasenschach 0.1.2 - Soccer simulation  http://hackage.haskell.org/package/Rasenschach-0.1.2 (MartinWoehrle)
13:45:27 <josephle> benzrf: I wonder if that type signature is a contravariant bimap...
13:46:58 <ReinH> josephle: why contravariant?
13:47:20 <josephle> :t \f g h x y -> g x `f` h y
13:47:21 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t1) -> (t4 -> t2) -> t3 -> t4 -> t
13:47:26 <bitonic> so, is the -optP-include flag documented anywhere
13:47:39 <josephle> well, it looks like precomposition
13:47:42 <bitonic> oh.  it's just -optP.
13:47:48 <jle`> looks like liftA2
13:47:57 <josephle> except x != y
13:48:09 <jle`> :t liftA2
13:48:10 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:48:24 <jle`> :t \f -> join (liftA2 f)
13:48:25 <lambdabot> Applicative f => (a -> a -> c) -> f a -> f c
13:49:52 <Darwin226> Hey guys. I'm trying to use hspec and I'm having some type errors. Anyone got any experience with it?
13:50:15 <josephle> :t \f g h -> (h .) . (g . f)
13:50:16 <lambdabot> (a -> b1) -> (b1 -> a1 -> b) -> (b -> c) -> a -> a1 -> c
13:50:29 <josephle> hmmm
13:50:53 <Darwin226> In any case, I have a function interleave with the type [a] -> [a] -> [a]. When I test it with both lists of numbers and then list of characters, I get a "No instance for (Num Char) arising from literal 1"
13:51:52 <Darwin226> These are my tests http://lpaste.net/112991
13:51:58 <centipede> merijn: never mind, I have to supply the type (leaves me wondering, why and how a tuple type is inferred, but that's another story). thanks anyway, i got what i was looking for
13:52:10 <benzrf> josephle: contravariant bimap would be (a -> b) -> (c -> d) -> f b d -> f a b
13:52:23 <josephle> ah
13:53:31 <albeit> Is there any way for a thread to access it's threadId? I want to forkFinally and remove the child thread's threadId from a Set ThreadId when it terminates
13:54:36 <rgr> I want to append something to a list if a file exists. doesFileExist returns an "IO Bool"  - what must I do to use than in an "if then else" construct? (of course Im probably doing this totally wrong but is there a way to cast to a Bool?)
13:55:07 <happy0> Darwin226: can you paste your exact error as well?
13:55:16 <happy0> like, in full
13:55:22 <simpson> rgr: do { b <- doesFileExist ...; if b then ... else ... }
13:55:41 <int-e> @hoogle :: IO ThreadId
13:55:41 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
13:55:42 <lambdabot> GHC.Conc.Sync myThreadId :: IO ThreadId
13:55:42 <lambdabot> GHC.Conc myThreadId :: IO ThreadId
13:55:55 <int-e> albeit: see there ^
13:56:00 <albeit> Oh beautiful, thanks!
13:56:18 <rgr> simpson: thank you
13:56:31 <merijn> centipede: FYI, don't use encode/decode when working with existing protocols
13:56:34 <Darwin226> happy0: The error is this http://lpaste.net/112995
13:57:05 <merijn> rgr: Don't use doesFileExist
13:57:11 <sinelaw> what's a good reference for extends Hindley-Milner to support records with row  variable polymorphism?
13:57:16 <sinelaw> *extending
13:57:25 * hackagebot simtreelo 0.1.0.2 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.0.2 (mgmillani)
13:57:27 <merijn> rgr: It's a race condition waiting to happen
13:57:27 * hackagebot descrilo 0.1.0.2 - Loads a list of items with fields  http://hackage.haskell.org/package/descrilo-0.1.0.2 (mgmillani)
13:57:29 <Darwin226> happy0: When I try it without using the arrow instead of `shouldBe` it works. Why does the arrow bother it?
13:57:46 <merijn> rgr: What if someone creates the file between checking and the code that uses the check?
13:58:03 <happy0> Darwin226: sorry, i'm afraid that i've never used the library
13:58:22 <happy0> yeah, cannot advise =p
13:58:27 <piskrist> is it possible to have polymorphic function signatures?
13:58:28 <happy0> good luck!~
13:58:36 <Darwin226> happy0: Thanks
13:58:43 <simpson> piskrist: Yes.
13:58:52 <simpson> :t map -- piskrist
13:58:53 <lambdabot> (a -> b) -> [a] -> [b]
13:59:36 <piskrist> I'd like to have a `converge :: Promise p => [p] -> IO ()` and second `converge :: Promise p => p -> IO ()` as typeclass function
14:00:01 <centipede> merijn: thanks for the advice
14:00:57 <Axman6> piskrist: I'm not ure that's a good idea. seems the second type is just `mapM_ converge`
14:01:00 <merijn> centipede: decode/encode insert library specific junk into the encoding the output, you should use explicit Get/Put for existing protocols
14:01:24 <centipede> merijn: oh, that's horrible
14:01:43 <edwardk> S11001001: i have no real problem with adding them there. its not a libraries discussion as semigroupoids isn't in the platform. that said, the naming is problematic as it'll collide and the modules are currently used unqualified
14:01:48 <piskrist> Axman6: it isn't. The first one does some expensive system initialization and fires of the converge for individual [Promise]
14:01:49 <rgr> merijn: no it isnt.
14:02:21 <rgr> its a static flag file ie "is it a laptop". nothing racing about it.
14:02:37 <piskrist> I should use a State monad but I'd like to have working prototype without it first
14:03:08 <Axman6> piskrist: then call them different things, why do they need to have the same name?
14:03:43 <Axman6> centipede: why is that horrible?
14:03:59 <hzks> "Left True" has a type of "Either Bool b". "Nothing" has a type of "Maybe a".  These are polymorphic types. Is it accurate to say that these are polymorphic types with one type parameter?
14:04:06 <hzks> Since only one type is unknown.
14:04:33 <ifesdjeen> Does anyone know how to handle / debug such problems: I have an FFI library, which "hands out" a callback to the C library. C Library calls that callback from many different threads, and somehow I start getting this exception: "schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?"
14:04:50 <centipede> axman6: it's not, it makes sense (just my unreflected initial reaction :)
14:04:53 <ifesdjeen> although I don't have anything marked "unsafe" (checked it)
14:05:15 <S11001001> edwardk: any name works for me
14:05:15 <simpson> piskrist: Perhaps you should make the expensive setup explicit!
14:05:26 <piskrist> simpson: haha. I just figured the same
14:05:45 <ifesdjeen> also, I've compiled code with -threaded flag, so scheduler should be aware of threads, theoretically...
14:05:55 <piskrist> I can have initialize :: SystemState and then converge :: Promise p => p -> SystemState -> IO ()
14:06:20 <piskrist> then full converge really is just a map
14:06:22 <piskrist> thanks
14:06:50 <Axman6> looks good to me
14:09:20 <S11001001> edwardk: foldLeft1 :)
14:09:23 <codygman> I would like to have  function that does this: Maybe (Maybe a, Maybe a) -> (Maybe a, Maybe a) I thought join would work, and I'm not sure why it won't.
14:09:24 <codygman> > join $ Just (Just 1, Just 1)
14:09:27 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a’
14:09:27 <lambdabot>              with actual type ‘(Data.Maybe.Maybe a0, Data.Maybe.Maybe a1)’
14:10:03 <merijn> centipede: The encode/decode typeclass is not meant for interacting with existing formats, because there can me multiple formats per type, so how would it pick the "right one"
14:10:18 <monochrom> join only does Maybe (Maybe a) -> Maybe a. no tuple.
14:10:26 <Profpatsch> If I have frequent calls to (**2), will ghc cache that? Or optimize it?
14:10:33 <merijn> centipede: Explicit Get/Put is mostly as easy
14:11:05 <kadoban> Profpatsch: Cache what, the application of 2 to (**) ?
14:11:16 <pjdelport> Profpatsch: It might or might not; best to check the Core output if you want to know what it gets optimized to.
14:11:31 <johnw> Profpatsch: btw, shiftL 1 can be much faster than **2, if you are working with integers
14:11:35 <pjdelport> Profpatsch: Generally speaking, there are no guarantees.
14:11:53 <int-e> ifesdjeen: tricky. how are the callbacks invoked? I'd try to get a backtrace. I'd be worried that they come from a signal handler, which---I believe---doesn't work.
14:12:07 <zwer> codygman how did you end up with Maybe (Maybe a, Maybe a) ?
14:12:11 <Profpatsch> Might just be a dumb way to write that function.
14:12:15 <albeit> Is there any way to get all the child threads of a parent thread?
14:12:27 * hackagebot hadoop-tools 0.4.0.1 - Fast command line tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.4.0.1 (JacobStanley)
14:13:02 <ifesdjeen> int-e: I just pass a function pointer, a lib I ffi against (collectd) is using pthreads and has many threads spawned that dispatch stuff straight to my callback, so it's a direct invocation of a (void*)(..) fn pointer...
14:13:18 <codygman> zwer: http://lpaste.net/112998
14:13:22 <Axman6> albeit: haskell threads aren't really hierarchical, but libraries like Async and distributed-process can give you that
14:13:24 <monochrom> albeit: I think there is no way. in fact, I think the parent-child relation is forgotten altogether
14:14:26 <centipede> merijn yes, i didn't mean to say it was horrible, sorry :)
14:14:42 <albeit> Okay
14:16:36 <zwer> codygman are you sure you don't want [String] -> Maybe (Int, Int)?
14:16:39 <S11001001> @tell edwardk I also have https://github.com/ekmett/semigroupoids/pull/9 which has been hanging for a bit
14:16:39 <lambdabot> Consider it noted.
14:16:46 <johnw> Axman6: actually, async-pool gives you direct control over the hierarchy
14:17:02 <albeit> Hmm how does criterion seem to wait for child threads to terminate before considering a test complete?
14:17:05 <joncol> Question: has anyone got experience with starting to learn functional programming, and using it in your daily job in a way that might easily be regarded as over-engineering?
14:17:22 <codygman> zwer: I probably do, though knowing how to "join" a "Maybe (Maybe a, Maybe a)" would be interesting.
14:17:30 <clrnd> I'm working on a CLI utility for a REST API, what is a cool library to format text output?
14:17:47 <taktoa> the easiest FP language I've found for that use is clojure, joncol
14:17:56 <johnw> clrnd: there's haste and shakespeare
14:18:43 <clrnd> johnw, haste the JS compiler?
14:18:44 <taktoa> almost all the data structures are immutable and there's optional static typing, and the java interop is really good
14:19:06 <taktoa> but if you want to use haskell, then it will be serviceable for a) scripts and b) web apps
14:19:07 <johnw> oh, not haste then
14:19:24 <Evilsparza> Can someone explain me how this works: "foldr (\a (x,y) -> (a:y,x)) ([],[])" - takes a list and produces a tuple of 2 lists which each have every other second element of the list. it works fine, but I don't understand why it works. I thought the first parameter of a function you give foldl/foldr is the accumulator. and the accumulator would be a tuple in this case, but you can't join a tuple to a value x with ":", can you? It's all m
14:19:24 <Evilsparza> ysterious
14:20:08 <indiagreen_> Evilsparza: no, the 2nd parameter is the accumulator
14:20:10 <monochrom> the second parameter is the accumulator.
14:20:23 <johnw> i can't remember
14:20:32 <Evilsparza> oh. so that makes sense :D
14:20:41 <Axman6> :t foldl
14:20:42 <lambdabot> (b -> a -> b) -> b -> [a] -> b
14:20:42 <Axman6> :t foldr
14:20:44 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:20:55 <Axman6> notice the difference
14:21:10 <joncol> taktoa> Yeah, well I feel strongly that code as data is a real powerful idea
14:21:27 <monochrom> the "a:y" part is doing a list thing (y is a list), not a tuple thing
14:21:44 <clrnd> johnw, shakespare seems to be Web centric, I'm looking to format text for a terminal
14:22:02 <Evilsparza> so it's the other way around for foldr than for foldl
14:22:02 <zwer> codygman intDoubleOrNothing (x:y:_) = liftA2 (,) (readMay x) (readMay y)
14:22:16 <sam_wise> hello , Iwas wondering if some one could clear the following issue for me in the monads chapter in LYAH ..([1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)), the author says ['a','b'] is bound to ch but should it be ['a','b,'a','b'] ?
14:22:21 <Evilsparza> thanks guys
14:22:37 <joncol> Today I made a DSL embedded in XML with a cool C# lib called Irony. Totally overkill for the problem I was supposed to solve. But very fun and intensely pedagogical :)
14:22:42 <vanila> sam_wise, yes youre right
14:22:56 <Axman6> well sort of
14:22:57 <vanila> sam_wise, well - 'a'then 'b' then 'a' then 'b', not exactly the list you wrote
14:22:58 <taktoa> joncol: seems like you'd like clojure then.
14:23:49 <joncol> taktoa> Cool! I liked clojure from the moment I saw the book with the Go board on the cover :). But I know nothing of the language. Is it used commersially?
14:23:52 <Cale> sam_wise: Well, ch is bound to 'a' and then 'b' for each value of n, it's like nested loops
14:23:56 <albeit> It seems forkFinally with a (const $ return ()) "finally" function is about 10x slower than just forkIO. Does that make sense? Why is that?
14:24:48 <Axman6> probably because of the exception machinery overhead
14:24:51 <luite> clrnd: you might want Wadler style pretty printing combinators, i'm working with something based on Leijen's imlementations (wl-pprint / wl-pprint-text) to format JS (but with modification to support minification and source maps)
14:25:27 <sam_wise> <Cale> can you clear the topic via using the monad instance for lists?
14:25:43 <albeit> Axman6: Could I effectively acheive the same thing (ignoring exceptions) by doing my "finally" function within the forked function?
14:25:44 <taktoa> joncol: iirc, yes, though I can't come up with examples off the top of my head. I cannot stress enough how good the java interop is... I started learning this language a few days ago, and managed to use the CMU Sphinx speech-to-text java library with no hitches.
14:25:46 <rgr> (noob level) could some kind soul tell me why the "<-" is not valid here. I think the code (although wrong) is self explanatory as to what I want to do : https://gist.github.com/faef2da1f2f3387c0bc0
14:26:15 <rgr> (heh, and the boolean is the wrong way around but thats not the issue)
14:26:19 <taktoa> joncol: it's not like the haskell ffi. you literally just call functions and the build system can pull in arbitrary maven repos.
14:26:46 <joncol> taktoa> Nice! Well I'm currently taking the Coursera proglang class, but after that perhaps. You know of any Clojure MOOC classes
14:26:49 <joncol> ?
14:26:50 <clrnd> luite, sweeeeet, it didn't occur to me that Wadler's could be implemented (I glanced the paper a long time ago)
14:26:52 <Axman6> albeit: probably. it might be a good idea to look at the source of forkFinally
14:27:30 <taktoa> joncol: I haven't looked into it. Clojure for the Brave and True is a good book, as is Clojure in Small Pieces.
14:27:45 <joncol> taktoa> You into a lot of other FP langs?
14:27:51 <taktoa> and of course there's always the structure and interpretation of computer programs
14:27:53 <albeit> Axman6: Shall do, thanks
14:27:55 <Laquendi> rgr: <- is part of 'do' syntactic-syntax, you can't use it without do, you need to use >>=
14:28:09 <joncol> Stayed awake tonight reading some pages of that! Inspiring stuff
14:28:19 <taktoa> I have a good amount of experience with clojure, racket, and haskell
14:28:49 <joncol> Cool. Racket is a LISP dialect? Much different from the Scheme that's used in SICP?
14:28:57 <zwer> codygman as far as join-equivalent, you can start with do syntax and then see if you can make it more concise (if you want to). do (mx, my) <- mtuple; x <- mx; y <- my; return (x,y)
14:29:01 <taktoa> Racket is nearly identical to SICP Scheme
14:29:06 <Cale> sam_wise: Sorry? What do you mean "clear the topic"?
14:29:08 <taktoa> but it has tons of built in great libraries
14:29:13 <taktoa> amazing for scripting
14:29:26 <sam_wise> Cale well, imperative thinking really isn't helping here
14:29:33 <Cale> sam_wise: You can substitute in the definition of (>>=) from the monad instance for lists, sure
14:29:46 <joncol> I browsed HtDP and it was very cool that you could drag-n-drop images to the REPL :)
14:29:48 <Cale> sam_wise: But it might be better to start with a smaller example
14:29:49 <taktoa> joncol: you wanna switch to #haskell-blah
14:30:15 <Cale> something like ['1','2'] >>= \n -> ['a','b']
14:30:24 <Cale> which is:
14:30:36 <sam_wise> ['a','b','a','b']
14:30:45 <Cale> concat (map (\n -> ['a','b']) ['1','2'])
14:30:56 <rgr> Laquendi: Ive been away from haskell for ages and just need to get this little fix in. That gives me a parse error too : or is it more complex than just replacing <- with >>= ?
14:31:05 <Cale> = concat [['a','b'],['a','b']]
14:31:15 <sam_wise> Cale : I understand that
14:31:16 <Cale> = ['a','b','a','b']
14:31:18 <Cale> right
14:31:28 <Cale> okay, so next example
14:31:34 <sam_wise> okay
14:31:37 <Cale> [1,2] >>= \n -> [n, 10*n]
14:31:47 <sam_wise> [1,10,2,10]
14:31:50 <Cale> mhm
14:31:51 <sam_wise> 2,20**
14:31:53 <codygman> zwer: Awesome, I've refactored that into my code and I'm mentally breaking it apart :D
14:31:55 <Cale> right
14:32:25 <luite> clrnd: it works reasonably well, but getting source code to look good is always a bit finnicky. minification is also a tad tricky, since after minimizing parentheses you have to figure out what operators you can print next to each other without confusing the lexer
14:32:29 * hackagebot hadoop-tools 0.5 - Fast command line tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.5 (JacobStanley)
14:32:55 <zwer> codygman we've all been there. (:
14:33:07 <sam_wise> Cale: I guess the problem here is I don't see how nested scopes apply here using >>=
14:33:44 <Cale> [1,2] >>= \n -> [n, 10*n] >>= \m -> [(n,m)]
14:33:56 <Cale> lambdas extend as far to the right as possible
14:34:04 <Cale> So this is
14:34:24 <Cale> [1,2] >>= (\n -> ([n, 10*n] >>= (\m -> [(n,m)])))
14:34:47 <luite> now i still need a better JS parser...
14:35:30 <structuralist> I'm setting up Ubuntu 14.04 and just did "apt-get install haskell-platform", but it can't find ghci
14:35:31 <monochrom> concat (map (\n -> concat (map (\m -> [(n,m)]) [n, 10*n])) [1,2])
14:35:45 <sam_wise> aaah
14:36:10 <Laquendi> rgr: >>= does something completely different, it's definately not drop-in replacement. you can just add 'do' inside your brackets if that's easier for you
14:36:40 <batchm> what is up with this error
14:37:03 <batchm> (moment)
14:37:59 <batchm> this works:
14:38:02 <batchm> > map (\x -> set x "lol" (1,2,3,4)) [_1, _1]
14:38:04 <lambdabot>  [("lol",2,3,4),("lol",2,3,4)]
14:38:17 <batchm> why doesn't it work if I replace one _1 with _2
14:38:25 <batchm> > map (\x -> set x (1,2,3,4) "lol") [_1, _2]
14:38:27 <lambdabot>  No instance for (GHC.Show.Show b0)
14:38:27 <lambdabot>    arising from a use of ‘M792701326475541980215405.show_M7927013264755419802...
14:38:27 <lambdabot>  The type variable ‘b0’ is ambiguous
14:38:27 <lambdabot>  Note: there are several potential instances:
14:38:27 <lambdabot>    instance [safe] GHC.Show.Show
14:39:16 <S11001001> batchm: the elements of a list must have the same type
14:39:51 <batchm> _1 and _2 don't have the same type?
14:39:58 <albeit> Why does increasing the number of cores used, from -N1 to -N4, on a 24-core machine, almost linearly increase the criterion timed value?
14:40:14 <batchm> :t [_1, _2]
14:40:14 <int-e> :t _1
14:40:15 <lambdabot> (Field1 s t a b, Field2 s t a b, Functor f) => [(a -> f b) -> s -> f t]
14:40:16 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
14:40:33 <luite> so anyone wants to volunteer to write a JS parser with happy and test it on test262 es5/es6 and the v8 test suite? :)
14:40:38 <int-e> batchm: they have a common type, as you can see
14:40:42 <zq> :t runState
14:40:44 <lambdabot> State s a -> s -> (a, s)
14:40:53 <batchm> int-e what is the problem then?
14:41:13 <Fuuzetsu> luite: that's a very specific use-case, you don't happen to need something like that done, do you ;P
14:41:22 <zq> :t luite what's the context?
14:41:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:41:51 <int-e> batchm: well, you're producing two results of different types
14:42:09 <batchm> oh
14:42:12 <int-e> > map (\x -> set x ((),(),(),()) "lol") [_1, _2] -- hopefully better error
14:42:14 <lambdabot>  No instance for (GHC.Show.Show b0)
14:42:14 <lambdabot>    arising from a use of ‘M868342774986329720615531.show_M8683427749863297206...
14:42:14 <lambdabot>  The type variable ‘b0’ is ambiguous
14:42:14 <lambdabot>  Note: there are several potential instances:
14:42:14 <lambdabot>    instance [safe] GHC.Show.Show
14:42:16 <luite> zq: parser for foreign function imports for ghcjs
14:42:21 <int-e> still awful. sigh.
14:42:38 <batchm> > map (\x -> over x (*10) (1,2,3,4)) [_1, _2]
14:42:39 <lambdabot>  [(10,2,3,4),(1,20,3,4)]
14:42:46 <batchm> :)
14:42:59 <int-e> > map (\x -> set x ("","",(),()) "lol") [_1, _2] -- but this should work
14:43:01 <lambdabot>  No instance for (GHC.Show.Show b0)
14:43:01 <lambdabot>    arising from a use of ‘M83019885619732467315569.show_M83019885619732467315...
14:43:01 <lambdabot>  The type variable ‘b0’ is ambiguous
14:43:01 <lambdabot>  Note: there are several potential instances:
14:43:01 <lambdabot>    instance [safe] GHC.Show.Show
14:43:14 <int-e> I'm confused.
14:43:26 <batchm> hmm
14:43:54 <batchm> oh you used wrong order of arguments
14:44:28 <batchm> > map (\x -> set x "lol" ("","",(),())) [_1, _2] -- but this should work
14:44:29 <lambdabot>  [("lol","",(),()),("","lol",(),())]
14:44:47 <zq> luite: may i ask why happy in particular?
14:45:32 <int-e> batchm: My bad, even though I copied that from you... I should've checked.
14:45:41 <luite> zq: it should be robust, have good source location and error reporting (i'm working on source map support now) and have not too many deps (to make it possible to integrate it into the ghc tree after 7.10 is forked)
14:45:50 <luite> zq: happy is already in the ghc deps for the haskell parser
14:46:01 <monochrom> map (\x -> set x "lol" (1,2,3,4)) [_1, _2] has a more to-the-point error
14:46:24 <luite> zq: the closest we have is language-ecmascript, but it only reports start locations of tokens, not whole source spans, it fails to parse some js and it uses parsec
14:47:04 <int-e> > map (\x -> set x "lol" ((),(),(),())) [_1, _2]
14:47:06 <lambdabot>  No instance for (Control.Lens.Tuple.Field2
14:47:06 <lambdabot>                     ((), (), (), ())
14:47:06 <lambdabot>                     ([GHC.Types.Char], (), (), ())
14:47:06 <lambdabot>                     ()
14:47:06 <lambdabot>                     [GHC.Types.Char])
14:47:13 <batchm> is _1 that works on a pair different than _1 that works on tuple with three elements?
14:47:39 <Axman6> they're from the same typeclass
14:47:43 <batchm> or could you bind _1 to a name and then use it on tuples of any size
14:47:43 <Axman6> :t _1
14:47:44 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
14:47:45 <int-e> I guess that's as clear as it get: changing the second component of ((), (), (), ()) to String does not result in (String, (), (), ())
14:47:47 <luite> batchm: different instance
14:48:11 <batchm> so that would work
14:48:42 <luite> where 'any size' is just up to how big you have implemented the instances :)
14:49:06 <batchm> well actually silly question.. given `x = y'  you can always use x in place of y
14:49:11 <sam_wise> Cale: With the example you gave me, would you say that conventional advice to look at monads as conduits is not strictly true?
14:49:19 <batchm> and _1 works with tuples of different sizes
14:49:47 <Cale> sam_wise: Monads are type constructors, I don't know where you heard the advice to think of them as conduits
14:49:56 <SideEffffECt> Hello,
14:49:58 <SideEffffECt> I'm having trouble with SmallCheck and TemplateHaskell
14:50:00 <SideEffffECt> I use Data.DeriveTH
14:50:03 <SideEffffECt> I try to derive a Serial instance for MyType
14:50:04 <SideEffffECt> derive makeSerial ''MyType
14:50:06 <SideEffffECt> but I get
14:50:08 <SideEffffECt> ‘coseries’ is not a (visible) method of class ‘Serial’
14:50:10 <SideEffffECt> so is Data.DeriveTH outdated? how else can I automate deriving instances of Serial?
14:50:12 <SideEffffECt> Thank you for help :)
14:50:16 <Axman6> SideEffffECt: stop!
14:50:24 <sam_wise> Cale: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
14:50:32 <Cale> SideEffffECt: Yeah, that could be a problem
14:50:39 <Axman6> please don't flood the channel with your question when it could be a single line
14:50:45 <monochrom> probably the exact idea is ">>= acts as a conduit", afterall we do say "State does the plumbing for you"
14:50:49 <luite> zq: and also, since this is part of a somewhat bigger project, i'd like to extend the parser to read a language similar to JS but with type annotations. the new internal data structures in ghcjs all keep track of types of the JS expressions, so the optimizer can be much more effective, and it's possible to do a step similar to corelint to catch problems with the optimization rewrites more easily
14:50:57 <SideEffffECt> Axman6: oh, ok, sorry
14:51:29 <sam_wise> monochrom: haven't dne the part on state monad, so don't know the lst bit
14:51:56 <batchm> why is lens code using unsafe coerce? couldn't the library be implemented in standard haskell?
14:52:13 <Axman6> where is it using that?
14:52:15 <Cale> batchm: It could, but there's a bunch of clever stuff in it to make it faster
14:52:31 * hackagebot api-builder 0.2.0.1 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.2.0.1 (Intolerable)
14:52:33 <Axman6> probably to do with newtypes
14:52:47 <SideEffffECt> Cale: it seems that the `coseries` has been refactored into another typeclass and the derive package hasn't been updated to recognize this
14:52:48 <bennofs> Yes, I think it uses it to coerce newtypes away
14:52:55 <Cale> SideEffffECt: right
14:53:09 <SideEffffECt> Cale: so is there another way?
14:53:14 <luite> zq: this intermediate lang also has some ghcjs extensions, for example for calling a continuation in the cps transformed code, so that can be rendered to a trampoline call for regular js engines, and a normal tail position call for js engines that support tailcalls (none yet, sadly...), which a link time option to choose
14:53:37 <Cale> SideEffffECt: What do your types look like? Maybe you could just write the instances by hand?
14:53:51 <Cale> SideEffffECt: It also probably wouldn't be too terrible to modify the derive package
14:54:25 <Cale> oh
14:54:26 <Cale> http://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html
14:54:29 <Cale> check that out :)
14:54:37 <luite> zq: but hopefully within a year, when the ES6 spec is final, JS engines will start supporting tailcalls :)
14:54:40 <int-e> ifesdjeen: sorry, I don't really know how to debug your problem. I'd try compiling -eventlog and then +RTS -ls to get an event log of all scheduler events, (the ghc-events package should make the resulting log readable), a debugger to get a backtrace, possibly strace to get a better idea of timing, but ultimately these would all be stabs into the dark. I'd also try to follow events in the ghc's sources (rts/RtsApi.c,...
14:54:41 <Cale> There's a new way to get instances using Generic
14:54:46 <int-e> ...rts_lock() is the first thing that is called from the C wrapper of an exported function, followed by rts_apply() [twice, which don't do much, I think], followed by rts_evalIO() in the same file. So those would be starting points.)
14:55:50 <piskrist> is there a way to pattern match only one field from data?
14:56:07 <SideEffffECt> Cale: the type isn't complicated so far, but it will probably get more complicated in time, I want to use this for testing along the way, obviously
14:56:08 <piskrist> besides doing fx x | (field x) == "foo" =
14:56:13 <Cale> piskrist: If it was defined using record syntax, then yes
14:56:25 <monochrom> yes. if you write me the definition of your type, I can write a concrete example for you
14:56:27 <piskrist> Cale: how?
14:56:57 <Cale> fx (C { field = "foo" }) = ...
14:57:13 <Cale> where C is the data constructor for your record type
14:57:50 <Cale> SideEffffECt: Does the example in that documentation make sense? You get to write an empty instance declaration if you derive Generic
14:57:53 <piskrist> Cale: cool. That's awesome
14:58:27 <SideEffffECt> Cale: I'm just looking into it...
14:59:16 <Cale> (specifically the stuff under the heading "Generic instances", before "Data Generators" -- the rest of the documentation probably doesn't interest you, unless you really want to write your own generators by hand.
14:59:18 <SideEffffECt> Cale: do you mean https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html#t:Generic ?
14:59:39 <Cale> That's the class you derive an instance of, yeah
14:59:58 <Cale> (you just add "deriving Generic" to your data declaration)
15:00:09 <Cale> (and turn on the DeriveGeneric extension)
15:00:47 <johnw> deriving Cale should allow me to auto-generate a lengthy tutorial explicating and motivating the use of my data types
15:01:27 <geekosaur> and now I am imagining deriving monochrom
15:01:35 <geekosaur> deriving Simon is best left to experts
15:01:48 <monochrom> what would monochrom do?
15:02:02 <johnw> made my type devoid of color, obviously
15:02:12 <Cale> It would auto-generate brilliant advice which you'd nonetheless ignore until your problem worsened
15:02:15 <geekosaur> generate a comprehensive and comprehensible blog page?
15:02:21 <monochrom> haha
15:02:26 <zq> monochrom would be a syntax erro what with being lowercase
15:02:40 <monochrom> that too
15:04:18 <Evilsparza> are there any predefined binary<->decimal (base2<->base10) conversion functions in haskell or do I have to do it on my own? I couldn't seem to find any
15:04:22 <geekosaur> (the *really* scary one is probably deriving Andrej...)
15:05:08 <Axman6> @hoogle AtBase
15:05:11 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
15:05:32 <geekosaur> the ones that exist are in Numeric. there's a show function but not a read, that I see
15:05:56 <bitemyapp> johnw: where are Cale's tutorials?
15:05:58 <Axman6> > showIntAtBase 2 (\i -> case if of 0 -> '0'; 1 -> '1') 10
15:06:00 <lambdabot>  <hint>:1:32: parse error on input ‘of’
15:06:03 <geekosaur> actually, no, readInt should work
15:06:09 <Axman6> > showIntAtBase 2 (\i -> case i of 0 -> '0'; 1 -> '1') 10 ""
15:06:11 <lambdabot>  "1010"
15:06:17 <Axman6> Evilsparza: ^^
15:06:17 <johnw> Cale *is* the tutorial
15:06:24 <johnw> just ask him something, literally anything
15:06:31 <SideEffffECt> Cale: the example is "instance Serial m a => Serial m (Tree a)" where Tree has kind * -> *, but MyType has kind *, and "instance Monad m => Serial m Term" gives """Illegal instance declaration for ‘Serial m Term, (Only one type can be given in an instance head. Use MultiParamTypeClasses if you want to allow more.) In the instance declaration for ‘Serial m Term’"""
15:06:38 <johnw> he'll even teach trolls how to troll better, if they'll listen
15:06:40 <bitemyapp> johnw: that's why I was confused, I'd only ever seen Cale talk in here.
15:07:28 <Evilsparza> nice axman that looks awesome, I'll have a look into that. strange that I couldn't find that through neither google nor hoogle
15:07:55 <monochrom> "tutorial as container content" vs "tutorial as computation" :)
15:08:35 <geekosaur> > readInt 2 (\c -> c == '0' || c == '1') Data.Char.charToInt "11010100"
15:08:36 <lambdabot>  Not in scope: ‘Data.Char.charToInt’
15:08:36 <lambdabot>  Perhaps you meant ‘Data.Char.digitToInt’ (imported from Data.Char)
15:08:41 <geekosaur> whoops
15:08:47 <SideEffffECt> Cale: Although I do have {-# MultiParamTypeClasses      #-} at the top of the file
15:08:48 <geekosaur> > readInt 2 (\c -> c == '0' || c == '1') Data.Char.digitToInt "11010100"
15:08:50 <lambdabot>  [(212,"")]
15:09:12 <S11001001> @pl \e -> f e . g $ e
15:09:12 <lambdabot> f `ap` g
15:09:19 <Axman6> SideEffffECt: you need {-# LANGUAGE MultiParameterTypeClasses #-}
15:09:31 <Axman6> Param*
15:10:07 <monochrom> yeah, you're missing LANGUAGE
15:10:14 <S11001001> @pl \e -> f . g e . h $ e
15:10:14 <lambdabot> (f .) =<< (. h) . g
15:10:17 <SideEffffECt> Axman6: oh my god :))) they have a type on the website in MultiParameterTypeClasses http://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html
15:10:43 <monochrom> recall that wrong pragmas are silently ignored, so don't ever make typos in pragmas, you'll never find out
15:11:29 <merijn> monochrom: There's a warning for unfamiliar pragma's
15:11:55 <monochrom> does GHC need an explicit -fwarn-* flag for it?
15:11:59 <Cale> What's the typo?
15:12:00 <Axman6> SideEffffECt: the LANGUAGE part there is important, it says that what follows is a list of language extension names
15:12:24 <monochrom> the typo was forgetting to say "LANGUAGE"
15:12:30 <SideEffffECt> Axman6: oh, so stupid, thank you, that will be it...
15:12:38 <SideEffffECt> Axman6: time to go to bed :)
15:12:40 <merijn> monochrom: -Wall says "foo.hs:1:1: Warning: Unrecognised pragma" for me
15:12:43 <Cale> oh, the documentation doesn't forget :)
15:12:49 <merijn> If I leave out the LANGUAGE bit, that is
15:13:02 <merijn> SideEffffECt: Always compile with -Wall :)
15:13:30 <SideEffffECt> merijn: I do
15:13:49 <SideEffffECt> Axman6: thank you, this solves it
15:14:02 <SideEffffECt> Cale: thank you too
15:14:29 <Cale> -Wall can encourage some silly behaviours in beginners though
15:14:59 <Cale> who don't know to ignore the warnings about unused results of computations in do
15:15:21 <Axman6> yeah, the _ <- foo one really annoys me
15:15:54 <merijn> Axman6: That's what void is for
15:17:39 <Axman6> it'd be nice if it were in the prelude, it hasn't been added right?
15:18:22 <hiptobecubic> void = liftM (const ())  ?
15:18:58 <Axman6> basically
15:19:55 <merijn> :t void
15:19:57 <lambdabot> Functor f => f a -> f ()
15:21:15 <phaazon> god I love working with constraints…
15:21:36 <phaazon> that’s so handy and so lisible :)
15:21:42 <monochrom> life is a constraint satisfaction problem
15:22:02 <phaazon> the only thing I regret is the fact IO is explicitely used with comon IO functions
15:22:19 <phaazon> for instance, it’d be so great if putStrLn doesn’t use IO
15:22:20 <dmj`> monochrom: profound
15:22:23 <phaazon> but MonadIO m
15:23:28 <Axman6> there's a package that provides that
15:23:46 <monochrom> did you know: some of the very general stuff from Foldable and Traversable are going to enter Prelude and replace the special cases there.
15:23:53 <phaazon> Axman6: yeah but I guess it’s not efficient
15:23:59 <phaazon> and uses liftIO everywhere
15:24:07 <monochrom> the trend is that your wish for MonadIO will soon be true, too
15:24:08 <Axman6> though for efficiency you often want to use liftIO if you have more than one IO action at once; liftIO {do d; b} instead of liftIO a; liftIO b
15:24:09 <phaazon> monochrom: yes
15:24:19 <phaazon> and… Control.Applicative is entering Prelude as well <3
15:24:33 <phaazon> Axman6: yep :)
15:25:33 <jebes> hey, i'm trying to build my cabal package, and i can't seem to build its tests
15:26:33 <jebes> the error its throwing is it cannot find Distribution.Simple.Test.LibV09
15:27:00 <dmj`> jebes: are you including your package in the build-depends section of your tests?
15:27:22 <jebes> there isn't really a package, there is only a test
15:27:31 <dmj`> jebes: I say you paste your cabal file on lpaste.net for all to see
15:28:35 <jebes> http://lpaste.net/113005
15:29:14 <dmj`> jebes: so a few things, you need to specify exposed-modules in the library section of your cabal file
15:29:38 <dmj`> also, the build-depends section of the Test part needs to have anon-code in it
15:30:38 <dmj`> exposed: true?
15:30:46 <dmj`> maybe that works, never seen it before
15:30:47 <jebes> its on by default
15:30:56 <phaazon> mixing typeclass constraints and transformers
15:31:01 <phaazon> JIZZ IN MY PANTS
15:31:02 <phaazon> :D
15:31:09 <jebes> so its uneeded, i added it when i had some other trouble
15:31:39 <dmj`> jebes: wow cool, did not know that
15:32:06 <dmj`> "Almost all new libraries use hierarchical module names that do not clash, so it is very uncommon to have to use this field. "
15:32:38 <dmj`> jebes: anyways, still think you need to add the anon-code package to the build-depends in Test
15:32:39 <jebes> http://lpaste.net/113005
15:32:48 <jebes> new version, still same error
15:33:15 <dmj`> jebes: the source directory for tests is src/ ?
15:33:27 <dmj`> jebes: do you have a tests folder?
15:33:32 <jebes> yeah.... more experimenting there
15:33:34 <jebes> originally i did
15:33:42 <jebes> quick fix
15:33:54 <dmj`> jebes:   main-is:          Main.hs
15:34:31 <dmj`> jebes: in tests, you should specify a main module
15:35:14 <jebes> are you sure? i'm using detailed, not simplerror-io or whatever the other is
15:35:21 <jebes> in fact, cabal straight up won't let me
15:35:39 <dmj`> oh... I usually use: type:             exitcode-stdio-1.0
15:36:23 <dmj`> jebes: are all your tests IO [Test] functions?
15:36:41 <jebes> Yes, yes they are
15:36:56 <jebes> i literally copies the example from the cabal manual
15:38:23 <NemesisD> is there such a thing in haskell as a fully-qualified show/read
15:38:45 <vanila> fully-qualified
15:38:45 <vanila> ?
15:38:52 <jebes> http://lpaste.net/113007
15:38:56 <jebes> here's the full error message
15:39:09 <dmj`> jebes: I'm sure there's a way to get it to work. I've had better luck with exitcode-stdio-1.0, making a tests folder, specifying hs-source-dirs:tests in the cabal file, and the doing tests with hspec, main = spec $ do { describe "test" $ it "must be 4" $ 4 `shouldBe` 4 }
15:39:09 <NemesisD> there are some types that serialize to the same value but are differen types, e.g. integer/int
15:39:12 <jlg123> I am trying to generate every k-combination of n ints and test against several functions. Right now I am just using the List monad and the 'guard' function. Is there a known faster way of doing this?
15:39:23 <dmj`> jebes: kazus guide is good: https://github.com/kazu-yamamoto/unit-test-example/blob/master/markdown/en/tutorial.md
15:39:40 <jebes> that's what i'll end up doing, probably
15:39:43 <dmj`> jebes: so is this guide: http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/#setup
15:41:12 <Axman6> > replicateM 3 [1,2,3,4,5]
15:41:12 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,...
15:41:20 <jebes> thanks.
15:41:31 <Axman6> hmm, jlg123 I assume that's not what you're after?
15:43:42 <jlg123> Axman6: I am essentially already doing that, but using do notation so I can name each of the elements and calculate functions on them
15:43:52 <jlg123> Axman6: I have several constraints for the elements
15:44:30 <piskrist> Cale: if I have fx (C ( field = "x" )) = ..., how do I make another field available inside the function body?
15:46:28 <piskrist> `fx (C ( field = "x", y = a)) = a` seems to be working but ugly a little
15:46:43 <piskrist> oh, y = y works as well
15:46:44 <piskrist> cool
15:47:19 <Ralith> piskrist: you may be interested in the various GHC record syntax extensions
15:49:09 <merijn> And/or lens
15:49:22 <merijn> piskrist: lenses were invented for dealing with updates in nested records
15:49:47 <merijn> Although lens itself can be...somewhat intimidating :p
15:50:08 <piskrist> no, vanilla haskell is fine
15:50:29 <piskrist> thanks for the sugestions though
15:50:36 <juanpablo_> Is there a way to use a QuasiQuoter like a regular function?
15:50:52 <juanpablo_> Just passing it a string and getting back the generated Haskell
15:53:27 <merijn> juanpablo_: quasiquoter are literally just records of regular functions
15:53:57 <merijn> juanpablo_: Wait, what do you mean by "get back the generated haskell"? You mean as a String?
15:54:41 <juanpablo_> merijn: So I can just do "myQuasiQuoter someString" and it's equivalent to "[myQuasiQuoter| someStringContent |]"?
15:55:37 <merijn> juanpablo_: Not entirely, depending on contest of your splice one of 4 quoters gets called, see: http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH-Quote.html
15:56:14 <merijn> But "quoteExp myQuasiQuoter :: String -> Q Exp"
15:56:32 <merijn> I'm not sure whether there's a way to render "Q Exp" to String, though?
15:57:25 <merijn> oh, pprint should do that
16:04:17 <fragamus> hey does anyone here use linear? I need to construct a vector of arbitrary length
16:04:45 <jebes> and why will a list not suffice?
16:04:56 <fragamus> because I need a vector
16:05:04 <jebes> What's the differnce?
16:05:12 <fragamus> the operations
16:05:26 <jebes> I'm sure the operations exist for a list
16:05:43 <jebes> is there really no vector/matrix operations in prelude?
16:05:55 <fragamus> edwardk please
16:06:22 <fragamus> somebody is trying to tell me I don't need Linear
16:06:33 <simpson> fragamus: Hm. Why is your vector arbitrary-length?
16:06:56 <fragamus> because I am working on an abstract math problem
16:07:15 <merijn> jebes: Vector/matrix operations on a list is a terrible idea
16:07:24 <merijn> The performance would *suck*
16:07:29 <jebes> that would be a valid answer
16:07:42 <jebes> but muh cons cells
16:16:37 <fragamus> edwardk: hey ed can you clue me in on how to construct a vector of arbitrary length
16:17:23 <hiptobecubic> fragamus, isn't there an unfold you can use?
16:17:49 <fragamus> Im talking about the type Vector as opposed to V2
16:17:50 <superfunc__> is there an infix operator for mconcat?
16:17:58 <fragamus> I have never used Vector
16:17:59 <hiptobecubic> right...
16:18:05 <fragamus> I have only used V2 V3 etc
16:18:49 <hiptobecubic> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Generating_Vectors
16:18:59 <fragamus> awesome
16:19:37 <merijn> superfunc__: What would that do? It takes only one argument
16:19:39 <merijn> :t mconcat
16:19:40 <lambdabot> Monoid a => [a] -> a
16:19:55 <superfunc__> I need more sleep
16:20:00 <superfunc__> idk what I was thinking
16:20:03 <superfunc__> lol
16:20:18 <fragamus> Data.Vector.fromList [0..99]
16:22:24 <superfunc__> On a sidenote, merijn, do you have any neat use cases of monoid you can think of? I was asked by a friend, and the only I can think of is using the Ordering instance ( i.e. sortBy (comparing length <> comparing head ) ) to describe sorting priorities
16:24:08 <pold87> Hi! How can I read in files with cassava (Data.Csv) that contain speech marks (")? I always get an parse error (endOfInput)...
16:25:56 <dfeuer> pold87, you're going to have to show some code if you want help. Try lpaste.
16:26:17 <dfeuer> I actually have a guess, but it's totally wild until then.
16:26:23 <trap_exit> I like gist.github.com
16:26:36 <trap_exit> I don't know why lpaste is so highly  valued here
16:26:51 <dfeuer> trap_exit, it exists, and I remember that it exists?
16:26:52 <superfunc__> *written in haskell
16:27:15 <trap_exit> lpaste is written in haskell?
16:27:25 <trap_exit> I myself am now templted to ditch gist.github.com
16:27:45 <superfunc__> yeah, I think Chris Done wrote it
16:27:58 <dfeuer> Ah, yeah, lpaste is.
16:28:01 <superfunc__> yep: https://github.com/chrisdone/lpaste
16:28:59 <trap_exit> man
16:29:06 <trap_exit> I'm divided
16:29:54 <trap_exit> someone needs to rewrite git in haskell
16:30:45 <Hijiri> or write darcs
16:30:56 <peddie> trap_exit: do you know about darcs?
16:31:00 <Fuuzetsu> git works though
16:31:54 <trap_exit> isn't darcs this haskell powered quantum physics simulator that happens to also keep revisions of files?
16:32:33 <trap_exit> why did darcs never take off?
16:32:42 <dfeuer> trap_exit, that sounds like an excellent idea^w^w^wa large amount of work.
16:33:16 <dfeuer> @remember trap_exit isn't darcs this haskell powered quantum physics simulator that happens to also keep revisions of files?
16:33:16 <lambdabot> I will remember.
16:33:18 <kadoban> trap_exit: Network effects probably helped/hurt.
16:34:41 <silasm> trap_exit: iirc mostly the fact that most haskell devs seem to want to use github.
16:35:03 <merijn> darcs took off for a while
16:35:08 <merijn> But then github took off even more
16:35:11 <trap_exit> I think even befoer github, git was beating darcs
16:35:23 <trap_exit> there was this guy who wrote an OS or something
16:35:32 <merijn> Even people who don't use/want to use git use github (i.e., me)
16:35:33 <trap_exit> and he basically was like "if you want to submit to the linux kernel, use git"
16:35:44 <kadoban> Heh
16:36:00 <merijn> hg-git is a lifesaver :)
16:36:01 <silasm> trap_exit: allow me to interject for a moment...
16:36:19 <trap_exit> silasm: the floor is yours
16:36:36 <silasm> trap_exit: not going to paste the whole thing.
16:36:37 <merijn> trap_exit: If you wanna get darcs to become more popular, write a "darcs-to-git" translator :p
16:36:38 <trap_exit> if we don't like what you say, we will throw you into the IO monad
16:36:42 <Fuuzetsu> silasm: your interjection would be incorrect
16:37:23 <merijn> Although I'm not sure a transparent darcs-to-git translator is possible
16:37:34 <merijn> I don't understand darcs' internal data model
16:37:38 <Fuuzetsu> I tried using the darcs repo in Haddock's web root once
16:37:46 <Fuuzetsu> I overwrote some stuff, I did some other stuff
16:37:51 <Fuuzetsu> in the end I was happy I was able to revert
16:38:12 * dfeuer wonders if pold87 ever got around to pasting that thing they wanted help with.
16:38:43 <merijn> trap_exit: ircbrowse is also all haskell, afaik
16:38:50 <pold87> Thanks, dfeuer! Actually, I just tried to create an example file and found out that quotation marks are no problem there. My original csv file seems to have some "strange" characters that cannot be parsed by cassava (sorry for the late answer).
16:39:06 <silasm> darcs-to-stgit might be easier. I don't know how much closer that'd get you, though.
16:39:17 <merijn> What's stgit?
16:39:45 <silasm> merijn: a git tool for managing patches
16:39:53 <merijn> hg-git is pretty impressive, I've found a few minor nits, but other than that it works perfectly as a transparent "git-to-hg" translator
16:40:19 <merijn> But mercurial's internal model is nearly identical to git
16:40:21 <dfeuer> pold87, ah, good.
16:41:36 <bitonic> I have a file where somehow GHC can compile an expression requiring a Show instance for functions -- while ghci can't
16:41:40 <bitonic> this is in a cabal project
16:41:56 <silasm> merijn: http://wiki.procode.org/cgi-bin/wiki.cgi/StGIT_Tutorial
16:42:02 <bitonic> if I define that exact module outside the cabal project, compilation fails as expected
16:42:31 <silasm> afaik it's mainly useful for managing patches you want to upstream. At least that's how it's used at my job.
16:42:56 <piskrist> how do I turn IO (Maybe a) into a ?
16:43:08 <silasm> but iirc darcs is patch-based, so going to something like stgit might be easier.
16:43:17 <Fuuzetsu> piskrist: that is the wrong question to ask
16:43:40 <Fuuzetsu> if you could just turn it into ‘a’ somehow then it would not be in Maybe nor IO
16:43:56 <fragamus> agh that was for Data.Vector and I need Linear
16:44:25 <fragamus> I swear to edwardk I just want one answer
16:44:57 <dfeuer> piskrist, there are ways to get things out of Maybes if you know what you're doing, but getting things out of IO is for rather special circumstances only.
16:45:03 <piskrist> well I can do `do x <- IO (Maybe a); y = fromJust x; return workWith y` I'd like to eliminate the <-
16:45:10 <piskrist> maybe I could >>= instead
16:45:29 <dfeuer> piskrist, well, fromJust is usually not what you want, but on occasion it is.
16:45:45 <Fuuzetsu> it is very rarely what you would want
16:45:56 <bitonic> in general, is it possible to debug where instances come from, in cases like this?  I know about Text.Show.Functions in base but I'm not importing it
16:46:08 <Fuuzetsu> not to mention a pattern match with explicit failure is about 200 times better anyway
16:46:38 <piskrist> dfeuer: I believe it is
16:46:48 <piskrist> dfeuer: at least for some time
16:48:49 <dfeuer> piskrist, fromJust is appropriate if the result will *never* be Nothing. It's also a (bad) shortcut if you're okay with throwing up your hands in error if you do get Nothing. Better, as Fuuzetsu said, would be Nothing -> error "The clams are just not emblazoned enough!"
16:49:48 <jdeisenberg> Hi. Have installed ghc on Fedora 19 via yum install; cannot find cabal when I try using it from command line.
16:49:52 <jdeisenberg> Where have I gone wrong?
16:50:25 <dfeuer> piskrist, more succinctly, fromMaybe (error "We are all out of nutritional yeast.") theMaybeThing
16:50:29 <piskrist> dfeuer: yeah, I'm fine with the shortcut
16:50:41 <dfeuer> fromMaybe is very pretty....
16:50:58 <piskrist> ok, could have said fromMaybe at the start
16:51:10 <Fuuzetsu> they are not the same things
16:51:19 <piskrist> similar enough
16:51:24 <piskrist> I can use that instead
16:51:32 <dfeuer> Yes, fromMaybe is nice. And those theory people like their maybe function, which is similarly powerful.
16:51:35 <Fuuzetsu> I would just do myIOthing >>= \case { Nothing → …; Just x → … }
16:52:18 <piskrist> but probably it should be Either instead of Maybe ... this way, I'll duplicate the error message at every call site of the function that returns maybe
16:53:36 <jdeisenberg> Ah, I think I see what happened - I installed ghc, not haskell-platform.
16:53:44 <acowley> I'm going to FFI to dfeuer for my future error message needs.
16:54:10 <acowley> jdeisenberg: Why not just install cabal-install alongside ghc?
16:54:17 <piskrist> oh  wait. fromMaybe returns default value, not an error
16:54:20 <piskrist> that's not what I want
16:54:36 <jdeisenberg> acowley: I was looking for something starting with ghc- and couldn't find it
16:54:55 <jdeisenberg> Anyway, disk space is cheap and I may as well have "everything"
16:54:59 <acowley> jdeisenberg: Starting with just ghc and cabal is a good way to go!
16:55:11 <dfeuer> acowley, if you actually want to help me craft a bona fide error message, please comment on https://phabricator.haskell.org/D327
16:55:14 <acowley> jdeisenberg: Don't worry, cabal sandboxes will happily use up all that cheap disk space
16:55:18 <dfeuer> But thanks for the compliment.
16:55:42 <chirpsalot> acowley: I fear for my 128GB SSD :(.
16:55:45 <jdeisenberg> acowley: Also, the instructions for installing Elm start off with "Download the Haskell Platform"
16:56:31 <acowley> chirpsalot: Yeah, sandboxes are not exactly shy about duplicating things
16:57:03 <acowley> jdeisenberg: Ah, well that I can't speak to. For general Haskell development, you will probably want to use versions of things that are not in the HP, in which case you will be installing them into sandboxes on an as-needed basis.
16:57:41 <jdeisenberg> acowley: What would be an example of a "thing that is not in the HP" that one might generally use?
16:57:47 <Fuuzetsu> [regularnixplug]nix-shell won't duplicate things and does more than just Haskell stuff[/regularnixplug]
16:57:51 <merijn> jdeisenberg: Pipes
16:57:53 <merijn> jdeisenberg: lens
16:58:06 <acowley> jdeisenberg: Or just newer versions
16:58:19 <jdeisenberg> OK.
16:58:23 * merijn is a baller and installs globally anyway
16:58:24 <dfeuer> jdeisenberg, the version of the package you actually need to support that other package you want to install...
16:58:29 <acowley> dfeuer: Oy, that is quite a mouthful
16:58:38 <merijn> IMO people tend to oversandbox
16:58:52 <acowley> dfeuer: (The error message)
16:59:10 <jdeisenberg> Damn. Now I'm getting a message: "cabal: unrecognised command: sandbox (try --help)"
16:59:20 <jdeisenberg> I guess my version of cabal is too old.
16:59:22 <merijn> jdeisenberg: Which cabal version and how did you install it
16:59:24 <dfeuer> acowley, the objective is to really, actually, seriously help out the newbies who trip over it. How to accomplish that is something I'm less clear about.
16:59:24 <jdeisenberg> Time to build from source.
16:59:32 <merijn> jdeisenberg: A lot of linux package manager ship stupid old versions
16:59:39 <merijn> jdeisenberg: Don't build it, there's a binary download
16:59:44 <jdeisenberg> merijn: installed from Fedora repository; "yum install haskell-platform"
16:59:49 <merijn> oh
16:59:58 <merijn> then your platform and compiler are probably stupid old too
17:00:04 <pold87> Okay, to come back to my problem with cassava not parsing my file (I just tried to get rid of the error, but can't figure out how): How can I get rid of the strange characters in my file that cause Haskell to crash with a parse - endOfFile error? At https://gist.github.com/Pold87/2419e21499e1d1468b7c you can see these chars (the dot and the square).
17:00:06 <jdeisenberg> cabal-install version 1.16.0.2
17:00:08 <acowley> dfeuer: How about, "The handle "++show handle++" was closed before the result of reading from it was fully evaluated. Consider using readFile if you will consume the entire file."
17:00:08 <jdeisenberg> using version 1.16.0 of the Cabal library
17:00:30 <jdeisenberg> God, I hate computers :)
17:01:17 <acowley> I need my resentment of phab to go down
17:01:31 <dfeuer> acowley, that's not bad. It's a little too strong, but maybe that's okay for the purpose, especially if it also points to some info in the docs or the wiki.
17:01:38 <acowley> And I need to figure out if I can use nix-pkgs on OS X without going crazy
17:02:05 <acowley> dfeuer: Yeah, I thought maybe stating it firmly with fewer words would better direct further enquery.
17:02:34 <dfeuer> Yeah, I think you're probably right about that.
17:02:41 <jdeisenberg> OK thanks much everyone.
17:02:53 <dfeuer> acowley, may I quote that suggestion on Phab?
17:03:03 <acowley> dfeuer: Sure
17:03:13 <dfeuer> Thanks.
17:03:41 <dfeuer> acowley, by what name?
17:04:51 <acowley> Some know me as Blast HardCheese, but it's probably better to go with "acowley" or "Anthony Cowley"
17:05:32 <fragamus> some know me as fragamus
17:05:32 <dfeuer> All right, then.
17:05:56 <phaazon> Photon/Render/OpenGL/Shader.hs:101:8: Precedence out of range: 10
17:05:57 <phaazon> :(
17:06:17 <phaazon> this is pretty annoying
17:06:31 <merijn> phaazon: 0 through 9
17:06:43 <phaazon> oh I actually need 8, not 10
17:06:44 <phaazon> :)
17:07:45 * hackagebot mysql 0.1.1.7 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.7 (BryanOSullivan)
17:07:46 <phaazon> yeah, 1.
17:07:51 <phaazon> it will make it. :D
17:08:28 <fragamus> "Low-dimensional linear algebra primitives for Haskell"
17:08:46 <fragamus> Does that mean that Linear doesn't do arbitrary length vectors
17:08:55 <acowley> fragamus: Linear uses Vector where appropriate
17:09:02 <phaazon> fragamus: that’s correct
17:09:13 <phaazon> even though it has typeclasses to do so
17:09:40 <fragamus> that makes fragamus unhappy
17:09:40 <acowley> e.g. http://hackage.haskell.org/package/linear-1.10.1.2/docs/Linear-V.html
17:09:46 <acowley> Why?
17:10:13 <phaazon> oh I didn’t know V was able to do that
17:10:24 <phaazon> what’s n?
17:10:36 <pold87> Anyone have any idea of a way  for getting rid of the strange dot and square in https://gist.github.com/Pold87/2419e21499e1d1468b7c that cause Haskell/cassava to crash?
17:11:13 <acowley> fragamus: Also take a look at Linear.Vector
17:11:43 <acowley> phaazon: length
17:11:47 <recursion-ninja> pold87: is that a git based question?
17:12:19 <fragamus> So Linear.V doesn't give me vectors of arbitrary length right
17:12:19 <phaazon> acowley: huh…
17:12:36 <phaazon> fragamus: I don’t know how you’d use that
17:12:50 <phaazon> V ? Float
17:13:07 <acowley> fragamus: If you just want arbitrary length vectors, then the instances in Linear.Vector should be what you want
17:13:14 <pold87> recursion-ninja: No. I'm just trying to parse this file with Data.Csv and get an endOfFile error...
17:13:42 <Fuuzetsu> I'm betting your locale is something world-hostile
17:14:03 <fragamus> I just need an example of constructing, say, a 9 dimensional vector
17:14:57 <dfeuer> pold87, you keep not pasting the code, and keep expecting us to be able to do something to help anyway.
17:17:20 <acowley> fragamus: fromVector (V.fromList [1..9]) :: Maybe (Dim 9 Int)
17:17:23 <recursion-ninja> pold87, dfeuer: defeuer is corrct, how are you attempting to parse?
17:17:56 <recursion-ninja> pold87: my "spidey sense" is poor unicode handling...
17:18:50 <pold87> Sorry, here is the code: https://gist.github.com/Pold87/a491163caae73c0df2f2
17:19:15 <acowley> sorry, the type should have been Maybe (V 9 Int)
17:19:43 <pold87> and the complete fold_2.txt: https://gist.github.com/Pold87/040ae65035f14dfc2cff
17:21:00 <shirt> where can i ask questions about shake?
17:21:23 <recursion-ninja> pold87: I can't try and recreate it right now, but I think that the unicode characters, when converted to byte strings, are bieng packed into EOF control characters
17:22:54 <fragamus> fromVector (V.fromList [1..9]) :: Maybe (Dim 9 Int)
17:23:04 <fragamus> Illegal literal in type (use DataKinds to enable): 9
17:23:04 <acowley> shirt: If people here can't answer, you can find Neil on twitter or you could try on StackOverflow.
17:23:10 <pold87> recursion-ninja: Thanks a lot. Do you have idea how to convert them?
17:23:16 <fragamus> WTF
17:23:22 <acowley> fragamus: You need DataKinds, and you need to import GHC.TypeLits
17:23:35 <acowley> fragamus: And to fix my typo, as the type should be Maybe (V 9 Int)
17:23:47 <dfeuer> pold87, I'm still reading through myself.
17:24:11 <pold87> dfeuer: Thanks!
17:25:41 <shirt> shake question: My shake build script compiles an executable, and also generates a data file used by the executable. If I specify on the command line to build only the executable, then the data file is not generated. How can I modify the build script so that the data file is always generated?
17:27:04 <fragamus> fromVector (V.fromList [1..9]) :: Maybe (V 9 Int)
17:27:13 <fragamus> Not in scope: ‘V.fromList’
17:27:16 <recursion-ninja> pold87: I'm not a character encoding expert, but it might be as simple as: filter (not .`elem`['Wierd','Characters','Here']) String
17:27:26 <Fuuzetsu> no
17:27:26 <Fuuzetsu> bad
17:27:26 <fragamus> getting closer...
17:27:53 <recursion-ninja> pold87: Do that while the data is still in string form, then "pack" to a bytestring... maybe
17:28:06 <Fuuzetsu> bad bad bad
17:28:20 <dfeuer> pold87, my random guess is that there is indeed a Unicode weirdness going on. In particular, I think it might get confused if either the tab or newline byte appears within a higher unicode codepoint.
17:28:33 <merijn> recursion-ninja: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
17:29:08 <merijn> pold87: The correct approach is 1) figure out which encoding your file is and 2) decode it properly before parsing
17:29:28 <fragamus> acowley: ghc is now only upset about one thing: Not in scope: ‘V.fromList’
17:33:01 <Guest54575> where can i read about implementation of pattern matching like in haskell
17:33:11 <pold87> Thanks a lot, guys. Actually, A already tried to decode it properly, however, I found out that this a quite complicated task.
17:33:37 <recursion-ninja> merijn: what's up?
17:34:42 <Guest54575> pold87: try the file command on the file, it might tell you what encoding it thinks it is
17:37:04 <pold87> Its says UTF-8 Unicode text, I will try that (again).
17:39:50 <Guest54575> pold87: so use Data.Text.Encoding decideUtf8'
17:39:56 <Guest54575> decodeUtf8'
17:40:06 <Guest54575> it will tell you if something is wrong with it
17:41:51 <merijn> recursion-ninja: Those were some pretty bad suggestions
17:42:49 <recursion-ninja> merijn: I prefaced it with "I'm not an encoding expert"...
17:44:07 <acowley> fragamus: My little snippet was assuming you'd done import qualified Data.Vector as V
17:44:11 <Guest54575> there shouldnt have to be any such thing as encoding experts :(
17:44:42 <lrocksmashtime> Anyone here currently reading the "Thinking functionality in Haskell" book? If so should I buy it yes/no.
17:44:55 <lrocksmashtime> *functionally
17:44:57 <fragamus> oh! so... are we not using the kmett linear
17:45:00 <recursion-ninja> Guest54575: Maybe someday we will have simpler encoding...
17:45:00 <robstewartuk> What is the applicative notation of the following expression: `result <- f =<< g =<< (h >>= \xs -> return (head xs))`
17:45:41 <benzrf> eeeeeek
17:45:48 <jxv> robstewartuk, doesn't exist
17:45:48 <merijn> robstewartuk: "fmap head h"?
17:45:48 <jle`> you can't make that applicative in gerneral
17:45:55 <fragamus> fromVector (V.fromList [1..9]) :: Maybe (V 9 Int)
17:46:03 <jle`> but result =<< g . head =<< h
17:46:05 <jle`> is ok
17:46:09 <fragamus> Just (V {toVector = fromList [1,2,3,4,5,6,7,8,9]})
17:46:14 <jxv> you can't convert monadic binds  to applicative operators.
17:46:17 <merijn> jle`: Oh, good catch
17:46:22 <jle`> s/result/f
17:46:41 <acowley> fragamus: We are using Linear, I just usually import vector qualified to avoid clashes
17:46:55 <fragamus> got it
17:47:46 <pold87> I'll try that, Guest, thanks!
17:49:08 <acowley> Also, Linear's got pretty good buy-in from the community, it's not just Ed which means you can usually find someone to help with any issues that arise. https://github.com/ekmett/linear/graphs/contributors
17:50:38 <EvanR> ffs i found several stack overflow questions about my question about pattern matching, but the javascript is freezing chrome
17:51:26 <EvanR> disabled javascript, still not loading http://stackoverflow.com/questions/12658936/how-do-haskell-currying-and-pattern-matching-work-together
17:51:29 <EvanR> wget
17:52:50 <dfeuer> pold87, I could be wrong, but I don't see any sign that cassava has any sort of Unicode support.
17:58:06 <pold87> dfeuer: I'll be also happy if I can remove all these signs, if there is any easy way to do that.
17:59:47 <dfeuer> pold87, what do you mean by "remove all these signs"? You can easily read the thing in as Text (instead of ByteString), filter by codepoint (or do some sort of escaping) and then convert to ByteString and do the CSV. Or there may be a better way.
18:00:26 <dfeuer> Actually, there surely is a better way.
18:00:40 <dfeuer> But it all depends how much speed you need.
18:00:43 <Fuuzetsu> why don't you just encode as UTF8 and pass the result to cassava?
18:00:46 <Fuuzetsu> I'm sure it won't choke
18:01:43 <dfeuer> Fuuzetsu, is there any guarantee that the Word8 values corresponding to '\n' and '\t' don't show up anywhere in the UTF-8 representation of some other codepoint?
18:02:06 <Fuuzetsu> http://hackage.haskell.org/package/utf8-string-0.3.8/docs/Codec-Binary-UTF8-String.html
18:04:18 <Fuuzetsu> no; depends what cassava does, if it just blindly goes byte by byte then you're out of luck either way
18:04:58 <pold87> dfeuer: That's what I meant. I'll look at filtering by codepoint if Fuuzetsu's solution won't work. Speed is an issue but not my main focus.
18:05:42 <dfeuer> Fuuzetsu, I don't see any indication that cassava attempts to do anything about Unicode, but I just barely skimmed the source.
18:06:10 <dfeuer> pold87, if you don't need extreme speed, you can roll your own CSV-for-Unicode pretty simply.
18:06:23 <dfeuer> Based on Data.Text instead of Data.ByteString.
18:06:52 <EvanR> '\n' stands for exactly one unicode char
18:07:14 <Fuuzetsu> EvanR: that's not the problem, '\n' is preserved, yes
18:07:29 <pold87> Ahh, yeah, I did that. That worked, but I thought that cassava had some nice features that I wanted to use.
18:07:30 <Fuuzetsu> the problem is in case you have a longer-than-a-byte char which happens to end with \n-like byte
18:07:38 <EvanR> what is \n-like ?
18:07:48 <Fuuzetsu> > ord '\n'
18:07:49 <lambdabot>  10
18:07:52 * hackagebot hzulip 0.5.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.5.0.0 (yamadapc)
18:08:06 <EvanR> 10 never appears inside a utf8 sequence longer than 1
18:09:00 <fragamus> acowley: thanks that was way out of my league but you helped me. I noticed you're a contributor on Linear
18:09:28 <EvanR> you cant mistake ascii chars for non-ascii chars when looking at utf8 bytes
18:09:41 <EvanR> or vice veresa
18:10:59 <dfeuer> EvanR, that does not seem to be true.
18:11:32 <dfeuer> > toEnum 0x800A :: Char
18:11:32 <EvanR> please provide a counterexample
18:11:34 <lambdabot>  '\32778'
18:11:42 <dfeuer> That does not help, lambdabot.
18:11:56 <EvanR> 800A is an integer, not a utf8 byte sequence
18:12:23 <dfeuer> > generalCategory (toEnum 0x800A :: Char)
18:12:25 <lambdabot>  OtherLetter
18:12:33 <EvanR> what you want to try is to decode pack [0x80, 0x0A]
18:12:55 <EvanR> it is not U+800A
18:13:01 <dfeuer> Explain?
18:13:01 <EvanR> (if it is even valid)
18:13:34 <EvanR> check this out
18:13:38 <EvanR> http://software.hixie.ch/utilities/cgi/unicode-decoder/utf8-decoder
18:14:36 <dfeuer> EvanR, what is U+800A then?
18:15:05 <EvanR> byte string 80 0A is invalid utf8
18:15:32 <EvanR> > text (fromEnum 0x800a)
18:15:33 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘[GHC.Types.Char]’
18:15:33 <lambdabot>  Expected type: GHC.Base.String
18:15:33 <lambdabot>    Actual type: GHC.Types.Int
18:15:41 <EvanR> its 耊
18:16:11 <pold87> Following Fuuzetsu's tip (I might have done it totally wrong), I can the following error: parse error (endOfInput) at *** Exception: Enum.toEnum{Word8}: tag (8226) is outside of bounds (0,255)
18:16:32 <Fuuzetsu> …8226?
18:16:38 <Fuuzetsu> what did you do
18:16:40 <dfeuer> > text [fromEnum 0x800a]
18:16:42 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
18:16:42 <lambdabot>              with actual type ‘GHC.Types.Int’
18:16:45 <pold87> https://gist.github.com/Pold87/fa1e61c7f17b18ca00d8
18:16:57 <dfeuer> > text [toEnum 0x800a]
18:16:58 <lambdabot>  耊
18:17:03 <dfeuer> There you go, EvanR.
18:17:08 <EvanR> thanks
18:17:29 <dfeuer> So it looks like I win that argument.
18:17:56 <EvanR> integer 800a is a unicode codepoint, it does not encode to 80 0a bytes, it would be instead be e8 80 8a
18:18:16 <EvanR> none of which are 0a
18:18:19 <dfeuer> Oh, I see what you're saying.
18:18:41 <dfeuer> Right.
18:18:46 <EvanR> all the bytes are greater than 127, which is the key characteristic of utf8
18:18:53 <dfeuer> So that makes the cassava thing mysterious.
18:19:13 <EvanR> i probably should have asked what the problem is
18:22:28 <benzrf> 耊
18:22:32 <benzrf> that looks familiarish
18:24:32 <EvanR> diè
18:25:54 <EvanR> cant find the definition
18:26:06 <benzrf> oh it's just the diagonal slash
18:26:11 <benzrf> not, in fact, lao
18:26:39 <benzrf> er, lǎo
18:27:14 <benzrf> (i do not know very much chinese)
18:27:23 <EvanR> 老
18:27:30 <benzrf> yep
18:27:32 <EvanR> totally different!
18:27:33 <EvanR> lol
18:27:36 <benzrf> 09:32 < benzrf> oh it's just the diagonal slash
18:28:08 <monochrom> it contains a diagonal slash :)
18:28:17 <benzrf> yes precisel
18:28:35 <benzrf> i know like 20 words of chinese and the only one i know with a diagonal slash is 老, so
18:28:43 <edwardk> S11001001: you are now a collaborator on semigroupoids and can merge what you need to merge ;)
18:28:46 <lpvb> what are some essential things to learn after reading "learn you a haskell"? lenses? FRP? parsec? tansformers? haskell extensions?
18:28:46 <monochrom> haha
18:28:51 <benzrf> i had a vague mis-recognition
18:28:54 <S11001001> edwardk: merci
18:28:57 <benzrf> lpvb: E V E R Y T H I N G
18:28:59 <benzrf> preferably at once
18:29:00 <benzrf> =)
18:29:23 <EvanR> dont learn, write code
18:29:24 <benzrf> lpvb: more realistically, i'd ensure that you have a firm grasp on things like monads
18:29:33 <conal> lpvb: Typeclassopedia!
18:29:41 <benzrf> lpvb: like, do you know what Monad really gives you over Functor?
18:29:42 <edwardk> lpvb: in http://www.quora.com/Reviews-of-Learn-You-a-Haskell-2011-book?share=1 i list half a dozen further reading directions
18:29:58 <lpvb> edwardk: thanks
18:30:12 <monochrom> after I finished a haskell tutorial, I learned parsec, transformers, and a few extensions, in the order I ran into them
18:31:23 <bitemyapp> lpvb: self-promotion bleh, but since nobody's brought it up: https://github.com/bitemyapp/learnhaskell
18:31:34 <edwardk> anyways pearls of functional algorithm design offer a good way to learn more about how to think as a functional programming, parallel and concucrent data structures lets you make your code easily parallelize,  purely functional data structures teaches you how to write code with the right asymptotics, types and programming languages teaches you more about types and type systems, and going further into category theory lets you read
18:31:36 <edwardk>  the documentation on my code ;)
18:31:38 <bitemyapp> lpvb: going to concur with learning parsec, transformers, etc. after you have the basics down,
18:32:02 <bitemyapp> edwardk: "lets you the read the documentation on my code" - that's a lie :P
18:32:13 <edwardk> bitemyapp: you clearly need to go further ;)
18:32:27 <johnw> edwardk: the documention in your code is what happens when someone lets Yoda write things down
18:32:31 <bitemyapp> edwardk: anytime I've tried to look up anything in lens I've ended up in 2-cat land.
18:32:32 * Fuuzetsu right now is reading about something with TEN coherence axioms
18:32:35 <Fuuzetsu> am I too deep in
18:32:50 <monochrom> parser combinators was the first large example of monad I learned (and later, the first large example of arrow, applicative...)
18:32:50 <xpika> is there an isomorphism typeclass on hackage somewhere ?
18:32:56 <bitemyapp> edwardk: the docs *have* helped me to understand, but only when combined with staring at the types and reading the code.
18:32:59 <johnw> xpika: in lens
18:33:03 <edwardk> xpika: isomorphisms make a terrible typeclass
18:33:25 <edwardk> Bool is isomorphic to Bool in two ways for instance.
18:33:44 <EvanR> bitemyapp: what is 2-cat land?
18:34:09 <johnw> EvanR: it is a land populated by 2 cats, Mercury and Venus
18:34:24 <edwardk> xpika: ultimately the whole point of typeclasses is to designate a canonical construction of some sort, and isomorphisms are rarely uniquely determined
18:34:37 <bitemyapp> EvanR: landing on http://ncatlab.org/nlab/show/HomePage when trying to understand Kmett's libraries is like trying to understand dialectic materialism and Google only returning results on Thomist philosophy.
18:34:39 <edwardk> there are lots of places where folks expose an isomorphism data type
18:34:51 <xpika> edwardk: applicatives have two implemtations for the list data type and people still use them
18:35:02 <jle`> like a certain library beginning with l and rhyming with pens
18:35:12 <edwardk> xpika: Applicative only has one implementation for the list data type that extends to the Monad that was already there.
18:35:12 <bitemyapp> xpika: http://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Iso.html
18:35:35 <edwardk> xpika: and we have newtypes to pick out alternatives when there is a reason to use more than one thing. Any, All, ZipList, etc.
18:36:48 <EvanR> im having a hard time understanding how patterns matches for functions with multiple arguments is implemented, is there a explanation for this somewhere thats not ghc source code?
18:36:57 <edwardk> xpika: the point is an isomorphism class has two parameters which can't be fundeps of one another and so it gets terrible inference, and as it isn't canonical it is hard to motivate. you can't 'compose' isomorphisms in class form.
18:37:08 <edwardk> they are fundamentally about data, not classes
18:37:20 <edwardk> we don't have a "class" for (->) either.
18:37:56 * hackagebot hzulip 0.5.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.5.0.1 (yamadapc)
18:38:08 <edwardk> class DWIM a b where dwim :: a -> b -- doesn't work very well ;)
18:38:35 <acowley> EvanR: I'm pretty sure SPJ talks about it in his Implementing Functional Languages (or something) book
18:38:45 <bitemyapp> edwardk: sounds like a fun "what not to do in Haskell" article.
18:38:55 <jle`> what not to do: use typeclasses
18:39:01 <bitemyapp> jle`: -_-'
18:39:05 <Fuuzetsu> acowley: I was going to mention that because I also believe it's there but I don't remember for sure
18:39:06 <jle`> im srs tho
18:39:08 <Fuuzetsu> I'm not too far deep
18:39:09 <edwardk> bitemyapp: mightybyte wrote up a joke april fools about that some time, not sure if he ever published it though
18:39:13 <jle`> s/use/make
18:39:14 <xpika> all i want is a convient abstraction to convert between (from 'c' :: Int)
18:39:25 <bitemyapp> edwardk: a pity if it wasn't.
18:39:30 <edwardk> xpika: fromEnum, toEnum
18:39:32 <piskrist> if I have `fx (C { field = "foo" }) = ...` how can I refer to the whole C instance in the fx body?
18:39:34 <EvanR> jle`: typeclasses considered harmful
18:39:37 <edwardk> > fromEnum 'c'
18:39:38 <lambdabot>  99
18:39:44 <jle`> typeclasses literally considered harmful.
18:39:45 <pold87> Sorry, I don't want to annoy you, but I'm still struggling with my parse error (endOfInput) at *** Exception: Enum.toEnum{Word8}: tag (8226) is outside of bounds (0,255) error (or with that task in general) in https://gist.github.com/Pold87/fa1e61c7f17b18ca00d8 Any new ideas (I also tried decodeUtf8, and get the error *** Exception: Enum.toEnum{Word8}: tag (8226) is outside of bounds (0,255))?
18:39:45 <edwardk> > toEnum 123 :: Char
18:39:46 <lambdabot>  '{'
18:39:53 <jle`> xpika: you can abstract over it using lens
18:40:12 <jle`> you just need to provide an "object" containing the information about the isomorphism
18:40:13 <acowley> EvanR: For more on function arguments, there's the "Making a fast curry" paper
18:40:28 <acowley> EvanR: That paper is newer than the book iirc
18:40:37 <EvanR> pold87: decodeUtf8' note the apostrophe
18:40:41 <bitemyapp> acowley: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/start.htm ?
18:40:45 <edwardk> > enum # 'c'
18:40:46 <lambdabot>  99
18:41:11 <Fuuzetsu> hm, I didn't mean that one
18:41:12 <xpika> edwardk: and the other way around
18:41:22 <EvanR> bitemyapp: thanks i didnt think about that one
18:41:26 <pold87> uhh, I forgot that, will try it.
18:41:27 <EvanR> acowley: er
18:41:28 <xpika> (from 3 :: Char)
18:41:31 <Fuuzetsu> it's probably more suited
18:41:35 <edwardk> > 99 ^. enum :: Char
18:41:36 <lambdabot>  'c'
18:41:38 <acowley> My internet is apparently too slow to do more than IRC
18:41:45 <edwardk> > fromEnum 99 :: Char
18:41:46 <acowley> so I can't check any references :/
18:41:47 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
18:41:47 <lambdabot>              with actual type ‘GHC.Types.Int’
18:41:50 <edwardk> > toEnum 99 :: Char
18:41:52 <lambdabot>  'c'
18:41:58 <bitemyapp> acowley: the one from 1987 / 1992 by SPJ?
18:42:01 <edwardk> > fromEnum 'c'
18:42:02 <lambdabot>  99
18:42:08 <bitemyapp> acowley: called "Implementing Functional Languages" ?
18:42:09 <piskrist> if I have `fx (C { field = "foo" }) = ...` how can I refer to the whole C instance in the fx body?, Cale?
18:42:14 <edwardk> xpika: you can use toEnum/fromEnum or the 'enum' isomorphism in lens
18:42:26 <Fuuzetsu> how to convert characters to integers: 1. import lens…
18:42:30 <edwardk> enum lies and claims to be an isomorphism, it probably shouldn't be
18:42:45 <acowley> bitemyapp: Yeah, that's the book. It's probably too old if EvanR is trying to figure out how GHC does things now, but it's full of wisdom on doing such things
18:42:46 <EvanR> theres safe enum
18:42:51 <edwardk> Fuuzetsu: xpika asked for a thing that abstracted over both, its there in lens. I _first_ recommended using fromEnum/toEnum =P
18:43:01 <EvanR> acowley: just any way to do it would be nice
18:43:22 <Fuuzetsu> edwardk: we both know that was just a courtesy recommendation
18:43:52 <acowley> EvanR: Well I have fond memories of flipping through that book (or the pdf thereof)
18:43:55 <xpika> edwardk: very well. would still be nice to convert between things that were not Ints
18:44:09 <Fuuzetsu> hm, edwardk disappears just as I'm about to ask a CT question ;P
18:44:13 <acowley> EvanR: So I'd definitely recommend it as a resource, while fast curry has more on efficient function calls
18:44:34 <acowley> Fuuzetsu: He knew it was coming, so he demonstrated a pull back
18:44:37 <EvanR> yes i read this a while back but could use a repeat
18:44:59 <Fuuzetsu> CT jokes should be banned
18:45:43 <xpika> fromIntegral et cetera
18:46:11 <conal> jle`: ping
18:46:12 <adnap> conal: Hello.
18:46:17 <acowley> Okay, self-ban (not really) incoming!
18:46:30 <conal> adnap: hi.
18:47:18 <xpika> > toEnum (2::Integer) :: Float
18:47:19 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
18:47:19 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
18:47:30 <Fuuzetsu> who ‘I know a lot about psudo-monads and I can explain how they are used for substitution with just one weird trick!’ here?
18:48:01 <adnap> conal: I saw a video where you explained denotational design by implementing linear maps. Your ideal meanings for abstractions seem to be existing mathematical abstractions. Is that right so far?
18:48:49 <conal> @tell jle` About "<jle`> elm is only denotative" (from yesterday), Elm is *not* denotative AFAIK. It has only an operational semantics, not denotational.
18:48:50 <lambdabot> Consider it noted.
18:49:28 <conal> adnap: yes.
18:51:24 <conal> adnap: because mathematicians highly value reusable abstraction and are good at it.
18:54:30 <benzrf> Fuuzetsu: what was the question :o
18:55:27 <adnap> conal: I was inspired by the question you asked in your video, which was something like "What is the question my program is trying to answer?" I asked that about a C program I wrote, and I wanted to try to reformulate the program using denotational design.
18:56:00 <conal> adnap: great
18:56:17 <adnap> conal: I currently understood my program as a sequence of actions, and not a "what".
18:56:57 <conal> adnap: yep. operational thinking is pretty well ingrained in most programmers.
18:58:35 <adnap> conal: My program consists of many commands, so I tried to answer "what..." with the first one, which creates a directory and a file in that directory.
18:59:36 <adnap> conal: The program takes a parent directory and the contents of the file as arguments. The names of the file and directory are fixed.
19:00:50 <adnap> conal: It seemed that a first needed to define what a file system is to define what the command is.
19:03:11 <adnap> conal: Do you think a mathematical meaning of a file system can be found that is suitable for implementation in C. In your video, you implemented linear maps, which are already a mathematical object. Do you think denotation design is suited to programs where the desired meaning is mathematical, but the program abstractions don't come from an existing mathematical abstraction?
19:05:16 <conal> adnap: You could go that route (semantics of files), and maybe you'd find some value. Or maybe doing so would be like trying to define stack frames, registers, memory allocation, thunk updating, etc.
19:05:29 <conal> adnap: ... i.e., mechanisms that we now use to implement higher-level semantics (function calls, pure values).
19:07:11 <Fuuzetsu> benzrf: you don't happen to know about pseudo-distributive laws do you
19:07:40 <Fuuzetsu> (over pair of pseudo-monads)
19:08:12 <conal> adnap: a drawback of my choice of linear maps is indeed that they already look like math, so it's unsurprising that they have a math meaning. more compelling perhaps are applying to dynamic behavior (as in the original FRP), imagery (as in Pan), and 3D models with lighting (as in Vertigo).
19:09:52 <benzrf> lol no
19:10:46 <conal> adnap: In answer to your question, yes!
19:12:48 <conal> adnap: Denotational design requires that one think clearly and precisely about whatever it is that one wants to write software about. Clarity and precision are often hard but are often most valuable exactly when hard.
19:13:02 * hackagebot fast-logger 2.2.3 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.2.3 (KazuYamamoto)
19:15:54 <recursion-ninja> conal: well spoken!
19:16:06 <conal> recursion-ninja: :)
19:16:30 <conal> (The reason is that murky thinking is costly.)
19:16:31 <recursion-ninja> conal: i apreciate the emphasis on most valuable when most difficult
19:16:37 <conal> :)
19:19:17 <adnap> conal: 3-D rendering is a field which has already been formulated using existing mathematical abstractions. It seems much easier to use denotation design when your program abstractions are representations of mathematical objects.
19:20:28 <conal> adnap: In other words, it's easy to be clear about something when someone else has already done most of the work.
19:20:36 <adnap> conal: Yeah
19:20:46 <recursion-ninja> lol you two ;)
19:20:58 <conal> adnap: 3D objects are only "mathematical" because people have thought about them mathematically.
19:21:26 <conal> adnap: when you understand your domain clearly, it'll "be" mathematical also.
19:21:30 <adnap> conal: Modern operating systens have not been defined in terms of existing mathematical abstractions, and the abstractions we have to build from, such as the file system, are not mathematical
19:22:00 <trap_exit> what langauge was hskell originally written in?
19:22:02 <piskrist> Precision != Accuracy
19:22:04 <trap_exit> was it written in ocaml?
19:22:20 <conal> adnap: as I said, operational thinking is ingrained in programmers.
19:22:31 <recursion-ninja> adnap: I think denotational design is very useful in formalizing murky ideas, defining clearer boraders on what is feasible and what is not
19:22:48 <Fuuzetsu> trap_exit: that would be difficult considering ocaml is 6 years younger
19:22:50 <adnap> conal: Rather, no one has thought about them mathematically, so there may not be a precise mathematical meaning that gives us the operations we have
19:22:54 <johnw> recursion-ninja: I agree
19:23:52 <sccrstud92> i have a recursive function that is equivalent to a right fold, except the folding function changes after each application. does anyone know how to write it as a standard foldr?
19:24:20 <benzrf> sccrstud92: how does it change?
19:24:24 <trap_exit> pass the list of functions
19:24:26 <trap_exit> as a 2nd argument
19:24:33 <recursion-ninja> adnap: when I read through the type signitures of some Hackage libraries, I often have mind-bending, euphoria epyphanies about how to think about common problem domains
19:24:41 <trap_exit> i.e. have [ (func, arg) ]
19:24:43 <trap_exit> instead of [ arg ]
19:24:58 <sccrstud92> ill try that trap_exit
19:25:02 <recursion-ninja> adnap: that is my favorite part of the Haskell ecosystem
19:25:21 <trap_exit> sccrstud92: that  will be 2 dogecoins
19:25:26 <conal> adnap: Given denotational thinking, we'd most likely come up with a *different* set of operations. That's a *very good* thing. Denotational design is about elegant & sound design, not just rationalizing APIs that come from operational thinking.
19:25:28 <sccrstud92> benzrf: ill explain in trap_exit's way doesnt help
19:25:33 <adnap> Please don't assume I'm unfamiliar with Haskell, or that operational thinking is ingrained in me because I have writtena C program.
19:25:48 <sccrstud92> trap_exit: i offer two lazy dogecoins
19:25:57 <sccrstud92> they will be there when you try to spend them
19:26:09 <trap_exit> lol
19:26:47 <EvanR> they will be there when you try to spend them, or youll encounter bottom (of your pocket)
19:27:06 <sccrstud92> shhh dont tell him Dogecoin was an inhabited type
19:27:07 <MP2E> haha
19:27:10 <sccrstud92> was supposed to be a secret
19:27:16 <MP2E> it's a secret to everyone
19:27:43 <adnap> conal: Do you think denotational design is suited to programs that modify Unix-derived filesystems?
19:28:06 <sccrstud92> hr probably thinks denotational design is suited to everything
19:28:20 <conal> adnap: see John Backus's remarks at https://gist.github.com/conal/d578f9b47648338e3527
19:29:11 <conal> adnap: Yes! in the sense of guiding massive redesign on an sound & elegant foundation.
19:29:42 <conal> adnap: Time for dinner here. I'm happy to continue this conversation another time.
19:29:47 <adnap> conal: I can imagine an OS that is defined mathematically, but I wonder if mathematical abstractions and operations can be created that are compatible with Unix-derived file systens
19:30:10 <johnw> adnap: have you heard of http://sel4.systems/?
19:30:17 <adnap> conal: Okay. Thank you.
19:30:31 <conal> adnap: You're welcome. Catch you later.
19:31:00 <pold> If anybody is still following, I couldn't get rid of my parse error (endOfInput) with using decodeUtf8': http://lpaste.net/113011
19:31:11 <recursion-ninja> adnap: there might be a wonderful way to abstract a set of *atomic* file system operations in a monad, though I haven't given it much thought
19:32:10 <adnap> Well, the C FILE abstraction already has a set of atomic operations
19:32:37 <adnap> But every operation does IO
19:33:22 <adnap> I'm thinking of fopen, fprintf, and fclose.
19:33:53 <adnap> POSIX also has opendir, readdir, and closedir.
19:34:00 <adnap> They all do IO.
19:34:11 <adnap> They all either do an action, or fail.
19:35:51 <recursion-ninja> adnap: I was thinking (and only a brief thought), that if you could collect several atomic file system actions in a monad, and ensure that the collection of actions was preformed atomically (here is where it will likely break down), then the whole monad of file system operations ought to be pure (I think)
19:36:19 <EvanR> recursion-ninja: well you cant do more than one atomically
19:36:22 <EvanR> its not transactional
19:36:50 <adnap> I was thinking of a pure definition of a filesystem that you read in, change, and write back
19:37:09 <EvanR> that would work, for a single participant
19:37:10 <adnap> But I can't define such a thing efficiently.
19:37:38 <EvanR> you can implement it with ST
19:37:38 <recursion-ninja> adnap: hmmm, based "on-top" of an existing Unix
19:37:46 <adnap> It would be riddiculous to read every filename and file contents into memory
19:38:31 <recursion-ninja> adnap: maybe "view" each directory as a "sub-file-system"
19:38:50 <recursion-ninja> adnap: then a "real" file system is just a tree of "sub-filesystems"?
19:39:11 <recursion-ninja> adnap: surely you could real a small(ish) directory into memory
19:39:26 <adnap> I don't want to implement a new file system on top of the Unix one, because I want the result of my program, files and directories, to be visible via other Unix programs
19:39:35 <EvanR> theres an interesting pdf related to this http://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf
19:40:01 <EvanR> at least about the type level assurances of usign file handles correctly
19:40:17 <adnap> recursion-ninja: Yeah, I had a similar thought about a sub filesystem
19:40:20 <EvanR> but also covers errors
19:40:35 <recursion-ninja> adnap: well I'm willing to talk out loud about this, but I'm not file-system expert. The only think I can think of is an abstraction layer to the Unix file-sysytem...
19:40:41 <adnap> Maybe file contents could be read lazily
19:41:04 <EvanR> lazy IO ...
19:41:16 <adnap> But I am also trying to come up with something independent of Haskell
19:41:21 <adnap> I am writing in C
19:41:44 <adnap> My questions to conal were centered around feasibility in C
19:42:40 <adnap> In essense, should I stick withy fopen, fprintf, etc., or use denotational design to define some better abstraction using these primitives
19:42:43 <recursion-ninja> adnap: could you expand on what you mean by: "feasibility in C"
19:43:30 <piskrist> adnap: functional programming in non-functional programming languages doesn't work.
19:43:46 <Cale> piskrist: Oh, sorry, missed your question, you can use  fx (r @ C { field = "foo" }) = ... r ...
19:43:53 <adnap> recursion-ninja: Can I have a mathematical meaning of my program objects and operations that is compatible with the Unix filesystem?
19:44:11 <adnap> Where the program creates files and directories
19:44:39 <piskrist> Cale: are all these things described somewhere? I feel like a dick asking every variation of that but I have a hard time googling it
19:44:50 <adnap> "Functional" is ill-defined.
19:44:52 <EvanR> and suffers the effects of other processes running concurrently
19:45:17 <adnap> Conal suggests denotational, which C in general is compatible with
19:45:18 <Axman6> adnap: "Something which works" :P
19:47:26 <recursion-ninja> adnap: philisophically, I think that in order to have a well definined mathematical system (for anything), the entire system must be built with their mathematical definitions in mind, *beforehand*. I think redefining the Unix file-system *may* be a lost cause because the Unix file system was not designed to be mathematically modelable. That said, it may, just by  accident, be the case that the Unix file system is mathematically 
19:48:27 <recursion-ninja> adnap: I know that's kinda a cop-out answer...
19:49:20 <adnap> recursion-ninja: Well, I'm pretty inclined to give up considering how hard thinking about the problem has been so far
19:49:45 <recursion-ninja> adnap: Are you looking for a Phd thesis?
19:49:50 <recursion-ninja> ;)
19:50:17 <adnap> Denotational design seems easiest when you can build something from scratch that is not constrained by compatibility with anything else
19:50:30 <recursion-ninja> adnap: I think the gravity of what you want, may be beyond a layman's grasp
19:51:07 <recursion-ninja> adnap: I agree about the from scrath part
19:51:44 <adnap> An OS in Haskell sounds awesome, but the hardest part I think would be hardware compatibility
19:51:48 <recursion-ninja> adnap: however the field of Modern Algebra shows how an existing system can be abstracted further to be greatly more expressive
19:53:01 <adnap> Few people are writing new operating systems it seems, and most of them seem to be failures in terms of hardware compatibility
19:53:19 <adnap> Like Plan 9 for example
19:53:29 <recursion-ninja> adnap: perhaps we out to make a new OS!?
19:53:54 <adnap> Sounds like a decade-long project
19:54:02 <recursion-ninja> adnap: we can call it recursion-adnap-ninja!
19:54:28 <recursion-ninja> adnap: How hard can it be, it already has a name ;)
19:54:50 <adnap> And hardware drivers are not defined mathematically usually, so...
19:55:03 <adnap> Who knows how deep you would have to go
19:55:20 <recursion-ninja> adnap: Joking aside, it would be nice to see some OS principals formalized mathematically...
19:55:35 <adnap> Like conal said, you might have to start with transistors
19:56:40 <adnap> Anyway, conal prefers to use existing mathematical abstractions rather than define new ones. If it is not possible to use existing mathematical abstractions, I don't think I could define elegant new ones
19:56:47 <Cale> piskrist: http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html might be a useful guide to basic syntax, but don't feel too bad about asking questions
19:57:15 <recursion-ninja> adnap: I know, ask the user to supply the drivers! Problem solved, if the drivers don't work, it's a user-error. Gotta think abstractly about these specifications ;)
19:57:36 <Cale> piskrist: It's often more efficient for people to help each other out than everyone looking for the right bit of documentation, and there are enough people hanging around to love to help with beginner questions :)
19:58:32 <recursion-ninja> piskrist: since beginner questions are easy, the IRC community tends to answer them very quickly & thoughly...
19:58:45 <adnap> lol
19:58:48 <recursion-ninja> piskrist: fell free to ask away
19:59:15 <adnap> This is all boiling down to "Let's scrap all of modern computing and reformulate it using mathematics"
20:00:03 <recursion-ninja> adnap: Church had it right with Lambda-Calculus, Why we using Turing-based Von-Nuemon archectures is beyond me...
20:00:37 <adnap> Didn't both of those abstractions come after memory hardware and transistors?
20:00:55 <adnap> Writing to a tape seems more compatible with hardware
20:01:05 <recursion-ninja> adnap: In all seriousness, I suspect that formalizing the Unix filesystem (or any existing non-trivial filesystem) is Phd level research...
20:01:40 <zyaku> speaking of mathematically consistent programs, did anybody mention the seL4 kernel yet? The research paper mIght be an interesting read if any of you haven’t seen it.
20:01:42 <recursion-ninja> adnap: 1940's was when Lambda-calc & Turning Machines were really formalized, I beleive.
20:02:08 <recursion-ninja> zyaku: It was brought up earlier, and looks VERY intreguing
20:02:27 <nshepperd>  isn't it because it's way easier to build cpus that run an imperative program reading and writing to memory cells
20:03:03 <adnap> I'm more interested in making applications that are compatible with the current software ecosystem then starting something new from the ground up, which seems way more risky
20:03:07 * hackagebot witty 0.0.2 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.2 (KazuYamamoto)
20:03:16 <jeremyrubin> Anyone know how I can do a where like bind on a pattern match function, ie:
20:03:18 <adnap> Like I could die without doing anything worthwhile
20:03:31 <jeremyrubin> f 1 = z
20:03:36 <jeremyrubin> f 2 = z
20:03:38 <zyaku> recursion-ninja: this is the original research paper: http://www.sigops.org/sosp/sosp09/papers/klein-sosp09.pdf
20:03:53 <zyaku> it’s surprisingly light reading
20:03:53 <jeremyrubin> where z = <expr>
20:04:30 <dedgrant> jeremyrubin: f x = case x of ... where z = ... ?
20:04:42 <recursion-ninja> jeremyrubin f n | n `elem` [1,2] = z
20:04:55 <recursion-ninja> jeremyrubin: f n | n `elem` [1,2] = z
20:05:28 <recursion-ninja> zyaku: I saved it to disk, in my reading collection!
20:05:56 <jeremyrubin> dedgrant: Yeah that works was looking to clean up some code though
20:06:00 <nshepperd> adnap: the unison file synchronizer has a formal specification
20:06:40 <nshepperd> adnap: maybe the same approach they used for talking about filesystems would be sufficient for you?
20:07:08 <recursion-ninja> adnap: does the Unix filesystem have a spec?
20:07:17 <recursion-ninja> adnap: I don't actually know...
20:07:28 <recursion-ninja> adnap: It must right?
20:07:35 <geekosaur> "the"?
20:07:49 <jeremyrubin> yeah there are many filesystems!
20:08:07 <joelteon> maybe there's a filesystem called "Unix"
20:08:16 <jeremyrubin> So the answer is no; there is no spec because there can be multiple in use
20:08:20 <Clint> UFS is the unix file system
20:08:20 <geekosaur> there was once. back in the early days
20:08:46 <joelteon> oh
20:08:47 <geekosaur> well, not exactly. what we call UFS these days is a descendant of the original BSD Fast File System
20:08:49 <joelteon> there IS a file system called unix
20:09:13 <recursion-ninja> joelteon: I'm vindicated ;)
20:09:22 <jeremyrubin> I stand corrected!
20:09:41 <joelteon> "There was a 4GB file limit for disks formatted as UFS in Mac OS X."
20:09:45 <geekosaur> System V called its adoption of that UFS, but UFS isn't really a single filesystem any more. The Linux UFS filesystem handled 3 not very compatible variants in its early days, plus multiple variations on those
20:09:52 <joelteon> i mean it would work if nobody ever had to download Xcode :P
20:10:20 <recursion-ninja> jeremyrubin: still, all the file systems are accessed through the Unix kernel's API... so your kinda right
20:10:36 <geekosaur> and OS X's UFS is still different (based on FreeBSD's UFS which is descended from the old BSD FFS but not via the System V UFS...)
20:10:45 <jeremyrubin> Yeah, that was more of what I was trying topoint at
20:10:47 <joelteon> the other other other white meat
20:10:57 <jeremyrubin> the kernel should isolate you from the fs api
20:11:20 <recursion-ninja> jeremyrubin: exactly!
20:11:26 <geekosaur> POSIX does specify the basics of what Unixlikes generally call the VFS (virtual file system interface)
20:11:40 <jeremyrubin> Although if you are writing a kernel fs in haskell; good luck :P
20:11:54 <niez_> jeremyrubin: I think you can't use 'where' like this, but you can transform pattern matching into case expression (ghc makes this under the hood anyway) and I think with case expression you can use 'where'
20:11:55 <recursion-ninja> jeremyrubin: now can Haskell isolate you from the kernel in a denotational manor (regarding filesystems)?
20:12:41 <jeremyrubin> define denotational
20:13:48 <jeremyrubin> ('ll interpret it for myself in this context)
20:13:59 <solatis> other than performance drawbacks, is there any reason to *not* to run your haskell programs with profiling enabled in production?
20:14:25 <nhjk> Why is haskell so slow in http://www.techempower.com/benchmarks/ ?
20:14:44 <recursion-ninja> solatis: the joys of hunting down preformance bug blindfolded...?
20:15:42 <solatis> recursion-ninja: you mean that hunting down performance bugs becomes more difficult when profiling is enabled?
20:15:43 <jeremyrubin> recursion-ninja: I'd say in theory yes
20:15:47 <recursion-ninja> solatis: The thrill of guessing at the origins of a fatal crash...?
20:16:12 <solatis> ok
20:16:16 <recursion-ninja> solatis: Plausible denyability...?
20:16:22 <solatis> so my gut feeling was correct
20:16:24 <joelteon> This just in: Haskell is slower than Ruby.
20:16:28 <joelteon> Guys, why aren't we using Ruby?
20:16:38 <jeremyrubin> Hey does anyone know how to profile compilation?
20:16:51 <recursion-ninja> solatis: Honestly I use profiling enabled binaries in production
20:16:57 <jeremyrubin> I have a module which is only compiling when I upgrade my vm to like 32 gb ram
20:16:59 <joelteon> Damn, we're also slower than PHP :/
20:17:00 <solatis> ok
20:17:09 <recursion-ninja> solatis: I have very seen it been a bottleneck
20:17:19 <solatis> i also run al my c++ code with assertions enabled in production, i like the fail-fast-and-hard aproach
20:17:33 <recursion-ninja> solatis: If you are itching for speed, use the profiling enabled binaries to find the bottle neck.
20:17:47 <solatis> i'm not itching for speed, I/O is my bottleneck
20:17:54 <recursion-ninja> solatis: If nothing obvious jumps out at you, then remove profiling and see if that suffices
20:18:09 * hackagebot ActionKid 0.1.0.0 - An easy-to-use video game framework for Haskell.  http://hackage.haskell.org/package/ActionKid-0.1.0.0 (AdityaBhargava)
20:18:09 <recursion-ninja> solatis: That's my philosphy
20:18:16 <solatis> ok
20:18:28 <solatis> i dig your philosphy
20:18:42 <recursion-ninja> solatis: One caveat
20:19:02 <recursion-ninja> solatis: some libraies with fragile C binding might be affected by profiling enabled
20:19:12 <solatis> ah
20:19:18 <solatis> care to elaborate?
20:19:25 <recursion-ninja> solatis: HDBC.MySql (withRSTOptionsDisabled)
20:19:47 <recursion-ninja> solatis: The method exists to turn of profiling based RTS
20:20:10 <recursion-ninja> solatis: since the signal disrupt the C libray that it abstracts
20:20:17 <solatis> ahh
20:20:38 <solatis> but that's just a crappy C library, then
20:20:46 <solatis> not the bindings to the C library
20:21:01 <recursion-ninja> solatis: correct, crappy C library... :(
20:21:03 <jeremyrubin> Any thoughts on compilation profiling?
20:21:15 <recursion-ninja> solatis: not beautiful Haskell's fault it's crappy...
20:21:53 <recursion-ninja> solatis: So I would say that there is essentially never a really good reason to not have profiling enabled, even in production
20:22:17 <solatis> i've had my share of those in the past, where you just had to catch & ignore certain signals for the library to work
20:22:24 * solatis is looking at you, libevent
20:23:02 <recursion-ninja> solatis: in these cases profiling *might* conceivable affect the code's behavior... but I can't say for certain
20:23:22 <solatis> i understand
20:23:35 <recursion-ninja> solatis: glad I could help
20:23:49 <solatis> but that's rather a side-effect of an immature C library
20:24:21 <solatis> and then enabling profiling *increases* the chances you run into that bug, and as such you can argue that the effects will be that your code is better tested
20:25:02 <solatis> at least, when there's the chance of such a bug in my code, i better want to run into it dammit :)
20:25:07 <recursion-ninja> solatis: so in theory, profiling enabled it should never be a real problem, in practice... well...
20:25:22 <solatis> in theory, practice and theory are the same... :)
20:25:37 <recursion-ninja> solatis: you understand me exacctly ;)
20:25:45 <trap_exit> in practice, they are too
20:25:56 <solatis> trap_exit: only when you use haskell
20:26:10 <joelteon> i wish we could keep blind evangelism out of *this* channel
20:26:22 <solatis> sorry i was making a joke
20:26:38 <solatis> since we just discussed that that is specifically *not* the case
20:27:09 <recursion-ninja> joelteon: sorry for any offensive evangalism I might have subjected you to...
20:32:52 <solatis> recursion-ninja: ah, now i remember -- libevent catches all SIG_BLOCK events, which is fired when writing to a file descriptor would block. if your process does any IO *other* than through libevent, libevent will catch those signals too, leading you into the world of heisenbugs. it's these kind of libraries that i suspect are what you call 'fragile' libraries that might be affected when you enable profiling
20:32:54 <solatis> in haskell, right ?
20:33:12 <nhjk> What's testing like with haskell? Does the type system enable me to write close to none?
20:33:25 <solatis> nhjk: look at hspec
20:33:36 <solatis> and quickcheck
20:34:09 <hiptobecubic> nhjk, no, but your tests will be about meaningful functionality and invariants, not about catching type errors
20:34:17 <nhjk> solatis: :( this is just like rspec (its base on it!)
20:34:32 <solatis> you say it like that's a bad thing?
20:35:04 <nhjk> I dislike writing tests in general
20:35:29 <jle`> hi conal
20:35:30 <jle`> thanks :)
20:35:41 <jle`> i actually haven't looked into elm personally, i was just quoting their website :)
20:35:45 <conal> jle`: I'm glad you got the message.
20:35:45 <jle`> but that's good to know
20:35:57 <conal> jle`: oh? the web site says something about denotation?
20:36:27 <solatis> nhjk: how would you validate the behaviour of a function like 'head' without tests?
20:36:49 <solatis> nhjk: you can reason about it when looking at the code, but nothing beats proper testing
20:36:57 <jle`> conal: yes
20:37:00 <jle`> let me grab a link
20:37:14 <jle`> http://elm-lang.org/learn/What-is-FRP.elm
20:37:20 <jle`> oh
20:37:22 <jle`> nvm
20:37:25 <jle`> it just says declarative
20:38:11 <nhjk> solatis: true, I guess I just had unrealistic expectations.
20:38:11 * hackagebot scholdoc 0.1.3 - Converts ScholarlyMarkdown documents to HTML5/LaTeX/Docx format  http://hackage.haskell.org/package/scholdoc-0.1.3 (timtylin)
20:38:14 * hackagebot scholdoc-texmath 0.1 - Scholdoc fork of texmath  http://hackage.haskell.org/package/scholdoc-texmath-0.1 (timtylin)
20:38:25 <jle`> solatis: Functional reactive programming (FRP) is a declarative approach to GUI design. The term declarative makes a distinction between the “what” and the “how” of programming. A declarative language allows you to say what is displayed, without having to specify exactly how the computer should do it.
20:38:33 <jle`> oops, that was supposed to be for conal
20:38:36 <conal> jle`: ah. a vacuous term. landin (a founder of our field) deprecated "declarative" and "functional" because they're imprecise.
20:38:44 <jle`> yeah, i remember your post on that subject
20:40:37 <levi> conal: He deprecated them a long time ago, though, and not everyone seems to have got the memo. :)
20:40:44 <conal> levi: indeed!
20:41:12 <xpika> does anyone know how to convert (String -> IO String) -> (String,x) -> IO (String,x)
20:41:24 <jle`> convert it into what...?
20:41:27 <conal> a difficulty with operationally-based systems is that one often can't even notice and point out the flaws clearly.
20:42:03 <fread2281> @djinn (a-> IO a) -> (a,x) -> IO (a,x)
20:42:03 <lambdabot> Error: Undefined type IO
20:42:08 <fread2281> :(
20:42:31 <xpika> @djinn (a-> f a) -> (a,x) -> f (a,x)
20:42:31 <lambdabot> -- f cannot be realized.
20:42:42 <jle`> it's called strength
20:43:07 <xpika> @hoogle strength
20:43:10 <lambdabot> No results found
20:43:12 * hackagebot scholdoc-types 0.1.3 - Scholdoc fork of pandoc-types  http://hackage.haskell.org/package/scholdoc-types-0.1.3 (timtylin)
20:43:14 * hackagebot scholdoc-citeproc 0.6 - Scholdoc fork of pandoc-citeproc  http://hackage.haskell.org/package/scholdoc-citeproc-0.6 (timtylin)
20:43:16 <jle`> well. in math v.v
20:43:48 <levi> So, I was looking at those TechEmpower web framework benchmarks. The Haskell entrants may not scale as well as some, but if you look past the surface of the graphs they actually do really well in terms of offering quick and reliable responses.
20:45:02 <jle`> xpika: apply it to the first part of the tuple
20:45:08 <jle`> and then use strength
20:45:11 <jle`> um
20:45:28 <jle`> :t \(ioa, a) -> fmap (, a) ioa
20:45:29 <lambdabot> Functor f => (f a, t) -> f (a, t)
20:45:47 <jle`> i guess you can do it all in one swoop
20:46:04 <jle`> :t \f (a, b) -> fmap (, b) (f a)
20:46:04 <lambdabot> Functor f => (t -> f a) -> (t, t1) -> f (a, t1)
20:50:25 <ReinH> levi: I hope you had a large grain of salt handy for that
20:50:44 <ReinH> conal: hi!
20:52:02 <conal> ReinH: hi! sorry for being out of touch about the podcast offer. i'm still interested trying to work out a place near home that's quiet and has reliable internet. i think it'll come together. and i wish we could have done it when our lambdajam chats were fresh.
20:53:04 <ReinH> conal: No problem! Chris and I have both been swept away by other things (new job for me, cross-world move for him)
20:53:20 <ReinH> But we'd still like to do the episode with you!
20:53:27 <ReinH> I'll see when Chris is available
20:53:32 <conal> ReinH: Oh, wow. big changes for both of you!
20:53:46 <jeremyrubin> Hey so I'm having trouble with something: Let's say I wanted to write (\x->Just ((+) 10) <*> Just ((+) 1) <*> x) i get ::Maybe b->Maybe b but then if I try to apply the func to a Just 10 it fails
20:54:01 <ReinH> conal: Yeah :) I'll shoot you and Chris an email to restart the scheduling process :)
20:54:17 <conal> ReinH: Sounds good. :)
20:54:28 <ReinH> conal: And yeah, I guess we should have stuck it out and recorded while we were there.
20:54:39 <fread2281> > (\x->Just ((+) 10) <*> Just ((+) 1) <*> x) (Just 10)
20:54:41 <sccrstud92> jeremyrubin: you are trying to add 10 to the funhction (+1)
20:54:41 <lambdabot>  No instance for (GHC.Show.Show b0)
20:54:41 <lambdabot>    arising from a use of ‘M460182691180311551822094.show_M4601826911803115518...
20:54:41 <lambdabot>  The type variable ‘b0’ is ambiguous
20:54:41 <lambdabot>  Note: there are several potential instances:
20:54:41 <lambdabot>    instance [safe] GHC.Show.Show
20:54:49 <conal> ReinH: Maybe so, in retrospect.
20:54:58 <seafood> Hello all. Long time no see. I’m trying to build a GHC cross compiler for ARMv7 (specifically Android phones). I found a set of build scripts at https://github.com/neurocyte/ghc-android but these are quite old, and I wonder whether it’s just easier with GHC 7.8. Any suggestions people?
20:55:03 <ReinH> conal: I'm sure we'll have a good time anyway
20:55:26 <ReinH> :t \x-> Just ((+) 10) <*> Just ((+) 1) <*> x
20:55:27 <lambdabot> (Num (b -> b), Num b) => Maybe b -> Maybe b
20:55:45 <ReinH> jeremyrubin: You don't quite get what you *think* you get
20:55:56 <ReinH> :t Just ((+) 10) <*> Just ((+) 1)
20:55:57 <lambdabot> (Num (a -> a), Num a) => Maybe (a -> a)
20:56:02 <jle`> are there any MonadIO laws other than `liftIO` being a monad morphism?
20:56:12 <jle`> ...that law i made up
20:56:15 <jle`> but it's a wild guess
20:56:27 <ReinH> jle`: It's a valid monad transformer law
20:56:35 <jeremyrubin> hmm
20:56:46 <jle`> are there any other laws ...?
20:57:59 <jle`> i have a suspicion that there really aren't any canonical laws for any of the mtl typeclassese besides MonadTrans (and that's from transformers, i think)
20:58:10 <jle`> i saw some statements of laws for MonadState
20:58:18 <jle`> i think they resembled the lens laws
20:59:04 <jeremyrubin> ReinH: So what is the proper expression of what I am trying to do?
20:59:34 <ReinH> jeremyrubin: What are you trying to do?
21:00:04 <ReinH> jle`: https://hackage.haskell.org/package/transformers-0.1.4.0/docs/Control-Monad-Trans.html
21:00:44 <fread2281> jeremyrubin: fmap ((+ 10) . (+ 1)) ? if that's your whole use case
21:00:51 <jle`> yeah, the monadtrans laws
21:01:20 <ReinH> jle`: well, the mtl typeclasses are the transformers typeclasses...
21:01:28 <jeremyrubin> I think fread2281 has it... just trying to compose two applicatives.
21:01:49 <jle`> MonadState though doesn't have to be a transformer
21:02:06 <jle`> it doesn't really embody any transformerness or monad morphismness...
21:02:25 <ReinH> fmap (+ 10) . fmap (+ 1) is a direct translation, which is equal to fread2281 by the Functor laws
21:02:31 <ReinH> er "to fread2281's"
21:02:37 <jle`> meaningful laws would be things like .... put x *> put y == puy y
21:03:00 <jle`> put y >> get = return y
21:03:27 <ReinH> well, that's a State law
21:03:40 <jle`> so ... what are State laws ...?
21:04:09 <ReinH> the monad transformer laws are basically that lift is an identity and distributes over binds
21:04:24 <jle`> yes, yeah.
21:04:56 <jle`> and that's really the only typeclass mtl involves that has canonical laws
21:05:00 <ReinH> which is why you can, e.g., do { liftIO k; liftIO l } = liftIO $ do { k; l }
21:05:11 <jle`> well
21:05:16 <jle`> MonadIO doesn't have to be over a transformer
21:05:17 <fread2281> what things are Functors but not Applys (Applicative w/o pure)?
21:05:17 <nitrix> Hello guys, I have a non-haskell-ish question, it's quite late, noise is low, so hopefully that's not too disturbing.
21:05:30 <jle`> so MonadIO laws should be independently stated from MonadTrans
21:05:33 <jle`> they are...orthogonal
21:05:34 <ReinH> jle`: and what is liftiO for IO?
21:05:49 <jle`> liftIO must be a monad morphism...lift must be a monad morphisms
21:05:52 <ReinH> (the identity transformer is still a transformer ;)
21:05:56 <nitrix> I was wondering if someone could help me understand linear types and when is the object considered used ?
21:06:15 <nitrix> would a in the expression `x = a + a` be legal?
21:06:17 <jle`> how about data MyData a = MyData (Int -> IO a)
21:06:28 <jle`> that's a valid MonadIO, for which a liftIO moad morphism can be defined
21:06:48 <jle`> liftIO iox = MyData (const iox)
21:07:14 <levi> ReinH: Considering the man-hours that have gone into optimizing Java for the highly scalable web server space, and the fact that they're not even running with the latest GHC runtime, I certainly took the results with a large pinch of salt.
21:07:35 <ReinH> jle`: That's ReaderT
21:07:44 <ReinH> @unmtl ReaderT Int IO a
21:07:44 <lambdabot> Int -> IO a
21:07:53 <ReinH> just with a newtype wrapper
21:08:07 <ReinH> And ReaderT, you might note, is a transformer :p
21:08:40 <jle`> yes...but...that's just by coincidence
21:09:02 <jle`> are you saying i can't find a MonadIO that can't be decomposed into transformers over IO?
21:09:03 <ReinH> Ok. Then show me a MonadIO that is not a monad transformer?
21:09:33 <jle`> hm
21:09:36 <jle`> it's not a monad transformer, btw
21:09:40 <jle`> it's the wrong kind
21:09:49 <jle`> monad transformers are supposed to be able to transpose arbitrary monads
21:09:54 <jle`> er
21:09:56 <jle`> transform
21:10:12 <ReinH> jle`: It's an unwrapped monad transformer
21:10:15 <ReinH> was my point
21:10:36 <ReinH> It's isomorphic to ReaderT, so it is a monad transformer
21:10:50 <jle`> it's isomorphic to ReaderT Int IO
21:10:55 <ReinH> Sure.
21:11:00 <jle`> which is not a monad transformer
21:11:06 <jle`> it's a "transformed monad", perhaps
21:11:10 <ReinH> It's a partially applied monad transformer
21:11:31 <jle`> what are you using as your definition of monad transformer...?
21:11:40 <seafood> jeremyrubin: I think you want: (\x->Just ((+) 10) <*> (Just ((+) 1) <*> x))
21:11:43 <ReinH> A thing that satisfies the monad transformer laws :p
21:11:47 <dfeuer> Remind me: are you supposed to cabal install cabal-install, or are you supposed to never do that?
21:11:51 <jle`> but in what way does this satisfy the monad tansformer laws
21:11:54 <jle`> it doesn't even have the right kind
21:12:00 <seafood> jeremyrubin: Note the pair of brackets around Just ((+) 1) <*> x
21:12:03 <jle`> it can't even be an instance of MonadTrans
21:12:04 <jle`> :|
21:12:10 * ReinH sighs
21:12:42 <jle`> i'm calling a monad transformer something that can transform an arbitrary monad and imbue it with extra properties/structure
21:12:55 <jle`> so this would be a "transformed monad", not a monad transformer
21:13:06 <jle`> ReaderT r is a monad transformer
21:13:09 <jle`> (*2) is a function
21:13:10 <ReinH> Ok.
21:13:19 <jle`> (2*4) is not a function
21:13:26 <jle`> (*2) is a ... number transformer
21:13:32 <jle`> Maybe is the Functor
21:13:33 <jle`> not Maybe a
21:13:51 <levi> dfeuer: I do cabal install cabal-install fairly frequently, so I hope I'm not supposed to never do that. :P
21:13:55 <jeremyrubin> Hmm still not sure that this works; doing a bit of reading will come back with a better example
21:14:00 <ReinH> jle`: I think you've made your point.
21:14:33 <dfeuer> Well, thanks, levi. Cabal cabal cabal.
21:15:00 <piskrist> https://github.com/yaccz/singularity/blob/wip/library/Singularity/Singularity.hs#L26 Wy it's not possible to do `mapM_ (converge . si) ps` ?
21:15:52 <ReinH> piskrist: what is the type of (converge . si)?
21:16:11 <ReinH> piskrist: Ah, you mean in place of what you have
21:16:52 <ReinH> piskrist: Because they are not the same thing. converge . si = \x -> converge (si x). \x -> converge (si x) /= \x -> (converge . si) x
21:17:04 <ReinH> er
21:17:14 <ReinH>  \x -> converge (si x) /= \x -> converge si x
21:17:23 <ReinH> You just want (converge si)
21:17:29 <seafood> jeremyrubin: I just tried out in the console and it worked for me.
21:17:47 <seafood> jeremyrubin: I applied it to “Just 10” and got “Just 21” as the result.
21:19:24 <fread2281> can haskell to type-level flip?
21:19:35 <jeremyrubin> seafood: it does seem to work
21:20:05 <ReinH> jle`: I am defining "monad transformer" as "thing for which one can write a valid `lift'". The kind of MonadTrans is not an essential part of "monad transformer-ness", just like the kind of Functor isn't an essential part of "functor-ness", as demonstrated by the MonoFunctor typeclass.
21:20:24 <simpson> fread2281: Sometimes. It depends on what you want to do.
21:20:36 <jeremyrubin> seafood: why are the parens important?
21:20:40 <jle`> ReinH: mhm.
21:20:43 <piskrist> ReinH: oh, I see. Thanks
21:20:44 <seafood> jeremyrubin: If you want to know why your previous one didn’t work, try evaluating “(+10) (+1) 10”. You’ll find that doesn’t work. What you wanted was “(+10) ((+1) 10)”
21:21:05 <jeremyrubin> gotcha
21:21:16 <seafood> jeremyrubin: What I gave you was just the second one above “lifted” up to the Applicative level.
21:21:58 <ReinH> jle`: Int -> IO () is a monomorphic monad transformer, as is the equivalent ReaderT Int IO (). :p
21:22:47 <ReinH> jle`: It's rather silly to think of all kleisli arrows as monad transformers, but no less silly than thinking of every polymorphic function as a natural transformation ;)
21:22:57 <jeremyrubin> seafood: so if I had a very long applicative, and I wanted to "lift" something into it i just need to find proper parenthisization?
21:23:47 <ReinH> jle`: Also note to correspondence between Reader, function arrows, ReaderT, and Kleisli arrows. This is not a coincidence. ;)
21:24:01 <jle`> is there some canonical definition?  i still feel that a monad transformer is something that transforms a monad.  i guess, yeah, kind is not really an issue.
21:24:33 <ReinH> jle`: A monad transformer is a generalization of the Kleisli arrow, rather like Arrow is a generalization of the function arrow. I think.
21:24:51 <jle`> "give me your tired, your weary, your monads; and i will will give you a new transformed one."
21:25:16 <ReinH> :)
21:25:23 <seafood> jeremyrubin: Parentheses aren’t the issue here. What I was trying to say is that you should make sure that something works just at the ordinary function application level and then once you have that working “lift” it up to the Applicative level by replacing all function applications (separated by spaces) with those using <*>.
21:25:29 <merijn> If I upgrade to the new XCode do I need to reinstall GHC or will GHC keep working?
21:25:37 <ReinH> merijn: it has Just Worked for me.
21:25:50 <ReinH> merijn: upgraded from Mavericks to Yosemite as well
21:25:58 <ReinH> er, I upgraded from...
21:26:01 <merijn> ReinH: ok, good to know
21:26:45 <jle`> ReinH: by (capital A) Arrow, do you mean (capital C) Category?
21:27:07 <jeremyrubin> ah I see
21:27:15 <ReinH> jle`: More or less. I'm not exactly what the generalization *is*, tbqh.
21:28:12 <jle`> i don't think i follow, sorry :(
21:28:17 <DarkCthulhu> What is the difference between using an if..condition and using 'when' from Control.Monad?
21:28:25 <joelteon> one is shorter
21:28:43 <jeremyrubin> so any f <*> g <*> h I should always think of as (f g) h?
21:29:09 <jeremyrubin> and so if f consume a (g h) therein is the issue?
21:29:19 <ReinH> jle`: ReaderT r m a <=> r -> m a, a Kleisli arrow. I wonder if all monad transformers aren't Kleisli arrows with an abstracted (->).
21:29:20 <seafood> jeremyrubin: Yes you should. Normal function application associates to the left and so does Applicative application using <*>
21:29:39 <jle`> well all monads arise from adjunctions
21:29:51 <jle`> i don't know what that means
21:29:55 <jle`> i just read it on a bumper sticker
21:29:56 <ReinH> I'm sure Kan extensions are involved somehow.
21:30:09 <ReinH> They are always involved somehow.
21:30:12 <jle`> you can represent all monads with (r -> m a) in some sense
21:30:17 <jle`> even Maybe
21:30:49 <jle`> data StateyMaybe a = StateyMaybe (Bool -> (Bool, a))
21:31:20 <jle`> where a can be bottom >_>
21:31:24 <jle`> ...is that leagle
21:31:25 <ReinH> Heh
21:31:36 <ReinH> Well, once you require bottoms you loose a bunch of other stuff
21:31:41 <jle`> true.
21:31:41 <ReinH> *lose
21:31:43 <ReinH> either works
21:32:04 <jle`> yes but that's kind of silly because you're using Maybe in the end
21:32:06 <ReinH> You no longer have a CCC, so everything gets ugly
21:32:51 <jle`> can you really encode Maybe's Monad instance as (Bool -> something a) ...?
21:33:04 <ReinH> Maybe.
21:33:19 <jle`> you can do (Bool -> (Bool, Maybe a)), but i'm not sure if that's cheating or not.
21:33:49 <pharpend> ReinH: kek
21:36:45 <ReinH> Well, you can encode Maybe a as b -> (b, Maybe a) via the cunning use of encode x = \y -> (y, x)
21:37:36 <ReinH> There's a rather trivial isomorphism: snd . encode = id :: Maybe a -> Maybe a
21:37:37 <jle`> so MaybeT m a is b -> m (b, Maybe a) ...?
21:38:36 <ReinH> Sorry, not an isomorphism
21:38:46 <ReinH> since it isn't two-sided
21:40:29 <ReinH> (you can also encode any a as (b,a) this way, so it isn't a very interesting result)
21:41:09 <jle`> yeah
21:41:11 <jle`> heh
21:52:38 <erikd> any haskellers going to this : http://www.socalcodecamp.com/sessions.aspx
22:04:41 <Evaderei> <-- Trying to learn haskell
22:04:49 <Evaderei> Few questions
22:05:06 <jle`> hi Evaderei :D
22:05:09 <Evaderei> Is it used in machine learning?
22:05:33 <Evaderei> Well will it help me understand machine learning
22:05:42 <Evaderei> Hey jle` :D
22:05:56 <jle`> it has been applied to machine learning :)
22:06:04 <macalimlim> hello everyone :)
22:06:24 <Evaderei> hey there
22:06:24 <macalimlim> im having trouble with using regular expressions in haskell
22:06:40 <macalimlim> can someone help me?
22:06:42 <macalimlim> :)
22:06:57 <johnw> you need to say what the trouble is
22:07:05 <johnw> then we can decide if we can help
22:07:30 <macalimlim> im trying to read a regexp pattern from an xml file
22:07:47 * merijn mumbles something about using a real parser
22:07:48 <Yxven> Evaderei  I don't think Haskell will help or hinder your machine learning education
22:08:48 <macalimlim> my problem is the regexp pattern wont match the supplied string for example
22:09:04 <johnw> macalimlim: in order to present your problem, you must give us details
22:09:14 <johnw> what string, what regexp, what error are you seeing, what does your code look like
22:09:51 <macalimlim> using Text.Regex.Posix
22:09:52 <dfeuer> macalimlim, it might be wise to ask why you are trying to use a regexp for anything having to do with XML.
22:09:55 <macalimlim> "09988881234" =~ "^\\+?(63|0)998888\\d{4}$" :: Bool
22:10:00 <macalimlim> will return false
22:10:28 <dfeuer> As merijn mumbled.
22:10:39 <macalimlim> please note that i added another slash to escape it
22:10:47 <jle`> haskell is really a language where we have the ability to avoid regular expressions :P
22:11:03 <jle`> there are few cases where we need or want to use regexps in haskell
22:11:10 <jle`> we usually use our first class parsers :)
22:11:48 <dfeuer> jle`, but it's fun to write regular expressions to do things like modular arithmetic!
22:11:56 <jle`> ;D
22:11:59 <macalimlim> :D
22:12:02 <macalimlim> nice
22:12:45 <dfeuer> (by "fun", of course, I really mean "painful", but you can do it!)
22:13:12 <macalimlim> can someone help me or point me to a tutorial for using regex in haskell
22:13:19 <macalimlim> :)
22:13:39 <dfeuer> macalimlim, very few people actually use regexps in Haskell. There probably *isn't* a tutorial.
22:13:49 <jle`> we're trying to tell you that regex is probably the wrong solution :)
22:13:58 <jle`> there are better, more expressive, easier to write solutions
22:13:58 <macalimlim> oh...
22:14:09 <jle`> and more maintainable too :)
22:14:15 <macalimlim> hmmm
22:14:50 <macalimlim> but we already have this xml file containing regular expressions
22:14:53 <DrHyy> where is a haskell book for beginning programmers and/or alternatively exercises?
22:14:54 <piskrist> how to define a constructor that takes a typeclass ?
22:15:23 <dfeuer> macalimlim, you have an xml file containing regular expressions that comes from where? And what are they for?
22:16:00 <dfeuer> piskrist, what do you mean? Do you want it to implicitly carry a dictionary?
22:16:28 <piskrist> Data Foo = Foo a where a is Show
22:16:31 <levi> There's actually an extended tutorial on using regular expressions in Real World Haskell, IIRC
22:16:43 <macalimlim> that xml file contains regular expressions of various number ranges (mobile phone numbers) from telcos here in the philippines
22:16:47 <macalimlim> "09988881234" =~ "^\\+?(63|0)998888\\d{4}$" :: Bool
22:16:54 <macalimlim> like this for example
22:17:08 <lispy> levi: Something like that. It may have been on bos's blog. although, I think the library has changed since then?
22:17:45 <levi> DrHyy: There's a MOOC that just started on edX that covers functional programming in Haskell.
22:17:49 <macalimlim> yeah i've read that blog :)
22:17:55 <macalimlim> and followed the examples
22:17:58 <piskrist> dfeuer: Data Foo = Foo a where a is Show
22:18:05 <DrHyy> levi: what is edX?
22:18:47 <jle`> piskrist: now why would you want to do that? :)
22:18:59 <dfeuer> piskrist, that's not only carrying a dictionary, but also entirely existential. Hence considered an antipattern. But if you want to....  {-# LANGUAGE GADTs, KindSignatures #-}  data Foo :: * where Foo :: Show a => a -> Foo
22:19:17 <macalimlim> do what... (sorry cant keep up with the messages)
22:19:28 <levi> DrHyy: Also see the CS149 course site at UPenn
22:19:46 <DrHyy> levi: where is edX?
22:19:46 <phaskell> No symbol 'edX' found anywhere.
22:19:57 <piskrist> jle`: dfeuer idk, becuase polymorphism
22:20:09 <dfeuer> piskrist, I didn't test that, so I'm not sure it works, but it probably does. A better way to accomplish that particular effect would be newtype Foo = Foo String
22:20:39 <dfeuer> But in some more complex cases it may make sense.
22:21:20 <levi> DrHyy: edX is a web site that has courses taught by instructors from major universities for free, and they also offer for-certificate courses if you pay.
22:21:31 <DrHyy> oh wow!
22:21:32 <trap_exit> anyone trying to write a mathematica in haskell?
22:21:44 <dfeuer> trap_exit, I think someone has tried.
22:21:51 <trap_exit> coursera = two stanford profs
22:21:54 <lispy> trap_exit: it comes up from time to time but I don't think there is a concerted and sustained effort
22:21:56 <levi> DrHyy: I don't remember the URLs of anything; I type 'edX' in my browser's search bar and Google tells me.
22:21:57 <trap_exit> edx = oh shit, we can't let stanford take control
22:22:26 <DrHyy> levi: what is MOOC?
22:22:41 <levi> DrHyy: It's what I just described edX as being.
22:22:43 <trap_exit> it's a cow
22:22:45 <trap_exit> Moo Cow
22:22:49 <lispy> DrHyy: I think a MOOC is an online class
22:22:51 <trap_exit> MOOC = MOO Cow
22:22:58 <DrHyy> oh
22:23:02 <trap_exit> massively online course
22:23:03 <macalimlim> can i talk to someone privately about my problem?
22:23:11 <macalimlim> :)
22:23:21 <trap_exit> massively open online course
22:23:32 <neutrino_> macalimlim: there are advantages as to taking in the open
22:23:37 <neutrino_> dont be afraid to seem stupid
22:23:43 <neutrino_> no body is judging
22:23:56 <macalimlim> thanks :)
22:24:18 <neutrino_> if someone tells you something wrong in pm there will be none to correct that
22:24:27 <dmj`> macalimlim: is it haskell related?
22:24:32 <DrHyy> levi: I don't have one year of experience in a regular programming language?
22:24:43 <macalimlim> yes :)
22:24:50 <trap_exit> yeah, anyone who PMs like that is probably an ocaml spy trying to pull people away from Haskell (if it's even possible)
22:25:02 <macalimlim> im having trouble using regular expressions in haskell
22:25:08 <dfeuer> piskrist, you don't know what because of polymorphism?
22:25:08 <DrHyy> levi: I really don't have enough experience
22:25:12 <macalimlim> "09988881234" =~ "^\\+?(63|0)998888\\d{4}$" :: Bool returns False
22:25:13 <dmj`> macalimlim: #haskell is a safe place to ask questions
22:25:13 <trap_exit> it's best to just ask your question ... instead making people play detective to figure out what technical problem you're facing
22:25:16 <DrHyy> yet I want to learn haskell as my first language
22:25:33 <trap_exit> don't learn haskell
22:25:38 <trap_exit> if you're destined to learn haskell, no one can stop you
22:25:43 <dfeuer> macalimlim, do you want that to return something else?
22:25:43 <piskrist> dfeuer: jle` asked why would I want it
22:25:47 <trap_exit> if people's discouragement can stop you, haskell is probably not ideal
22:26:01 <trap_exit> learning haskell is a bit like learning VI
22:26:15 <dfeuer> piskrist, well, that particular thing is very silly. You'ad need a better example to justify that complexity.
22:26:28 <macalimlim> no just a Bool (if the pattern match with the string or not)
22:26:32 <DrHyy> so erm...there is a way by making my own programming exercises?
22:26:35 <lispy> DrHyy: if you haven't learned any computer languages before you might want to supplement your Haskell studies with this: http://www.cs.huji.ac.il/course/2003/nand2tet/book.html
22:26:41 <DrHyy> thanks!
22:26:52 <dmj`> lispy: that's a great course
22:27:16 <DrHyy> lispy: I get 403 forbidden
22:27:30 <piskrist> dfeuer: https://github.com/yaccz/singularity/blob/wip/library/Singularity/Core.hs I want to turn converge into IO ConvergenceResult and I want to carry the Promise p in the ConvergenceResult so I can later show it or do something with it
22:27:38 <lispy> DrHyy: maybe this one? http://www.nand2tetris.org/
22:27:41 <DrHyy> when I click on the PDFs they give me an error
22:27:55 <dmj`> lispy: writing the java-like compiler was my first "real" haskell project
22:28:05 <lispy> dmj`: oh cool
22:28:17 <dmj`> lispy: it was horrible code
22:28:23 <dmj`> got the ball rollin' tho
22:28:28 <pharpend_> DrHyy: You could also come over to #learnprogramming, they are known to have some resources for newbies.
22:28:47 <pharpend_> DrHyy: I don't think anyone there would recommend haskell as a first language. I'm not even sure if I would.
22:28:47 <lispy> DrHyy: the name of the course is "From NAND to Tetris". I guess I'm not sure what is the best website to get the materials from.
22:28:50 <macalimlim> ive also read about quasiquoting the regexp first then doing the comparison
22:29:34 <pharpend_> DrHyy: there's a book by Graham Hutton that teaches Haskell with no prior knowledge required, you might want to read that.
22:29:35 <macalimlim> "09988881234" =~ "^\\+?(63|0)998888\\d{4}$" :: Bool should return true, but it returns false
22:29:38 <dfeuer> piskrist, what I'm saying is that you need a clearer notion before you write the type. Do you actually need an existential there, for example, or will a plain old one do?
22:30:03 <levi> pharpend_: The Graham Hutton book is the textbook for Meijer's MOOC class, actually.
22:30:04 <dfeuer> macalimlim, why do you think it should return true?
22:30:09 <pharpend_> DrHyy: the standard text nowadays is Learn You a Haskell for Great Good, by Miran Lipovača, but it's aimed at experienced programmers.
22:30:12 <piskrist> dfeuer: I have no idea what those are. I just want Promise p in my ConvergenceResult
22:30:20 <pharpend_> levi: I haven't read it, I've just heard about it
22:30:22 <macalimlim> becuase it matches the pattern
22:30:27 <macalimlim> :)
22:30:30 <Laquendi> macalimlim: it returns true with Text.Regex.PCRE
22:30:33 <levi> Richard Bird just came out with a new edition of his intro to functional programming book, too.
22:30:54 <pharpend_> DrHyy: also, bitemyapp has a nice cource https://github.com/bitemyapp/learnhaskell
22:30:57 <MP2E> yup, as soon as I can afford it I want to buy that
22:31:02 <dfeuer> macalimlim, it may be that it's using a different pattern syntax than you expect.
22:31:32 <piskrist> dfeuer: maybe I should just stick `Promise p => show p` into the result and deal with it later when I add more Promise instances
22:31:39 <macalimlim> oh nice just chnage it from Text.Regex.Posix to Text.Regex.PCRE
22:31:48 <macalimlim> wait ill try it
22:31:48 <macalimlim> :)
22:31:52 <dfeuer> piskrist, I'm looking at your paste now.
22:31:53 <levi> Hutton and Bird are both a lot better than Learn You a Haskell, IMO.
22:32:17 <levi> LYAH has the distinct advantage of being free, though.
22:32:43 <macalimlim> yes that maybe the case
22:32:44 <macalimlim> :)
22:33:24 * hackagebot milena 0.1.0.0 - A Kafka client for Haskell.  http://hackage.haskell.org/package/milena-0.1.0.0 (tylerholien)
22:34:26 <dmj`> typeclassopedia takes the cake everytime imo
22:36:40 <levi> typeclassopedia is very good, but not for someone with very little programming experience.
22:37:47 <dfeuer> levi, I can't seem to find this new edition of Bird's introduction.
22:38:36 <macalimlim> thanks laquendi and dfeuer
22:38:38 <macalimlim> :)
22:38:41 <levi> dfeuer: The title changed; it's called "Thinking Functionally with Haskell"
22:39:01 <dfeuer> levi, that'll confuse matters.
22:39:43 <levi> I think it's a more thorough rewrite than new editions tend to be.
22:40:14 <levi> Haven't read through more than the Kindle sample though, nor have I read the 2nd edition, just parts of the 1st.
22:40:22 <bitemyapp> pharpend: ding
22:43:18 <bitemyapp> pharpend: n/m, replying in PR.
23:08:27 * hackagebot vty 5.2.4 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.4 (CoreyOConnor)
23:13:28 * hackagebot HTF 0.12.2.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.2.2 (StefanWehr)
23:20:31 <pharpend> bitemyapp: I did my best to fix the install instructions.
23:21:16 <pharpend> bitemyapp: I would tend to think that the average Gentoo user would be technically competent enough to figure out compiler errors
23:25:50 <bitemyapp> pharpend: well. The guide is for us mere mortals I suppose :)
23:26:05 <bitemyapp> pharpend: the addition is appreciated. Do you want me to merge what you've got there?
23:26:25 <pharpend> bitemyapp: sure
23:26:40 <bitemyapp> pharpend: cool, thank you!
23:27:19 <pharpend> bitemyapp: at worst, shitty instructions are better than no instructions (at least for gentoo users)
23:28:14 <bitemyapp> pharpend: I started writing the guide because I had to keep helping people with build errors that were getting them stuck and were effectively unresolvable.
23:28:21 <pharpend> bitemyapp: ah
23:28:26 <bitemyapp> pharpend: Platform installs those packages into the global package-db.
23:28:46 <bitemyapp> pharpend: there's nothing you can really do unless you manually remove enough packages that it becomes just like a vanilla GHC install.
23:29:15 <pharpend> bitemyapp: Yeah, IDK if you know about Gentoo, but the package manager compiles from source, so compiler errors are not anything unfamiliar to the average Gentoo user
23:29:30 <pharpend> bitemyapp: unless you use super nazi stable gentoo
23:29:37 <bitemyapp> pharpend: I used to use Gentoo and FreeBSD casually, I'm pretty familiar with how ports work.
23:29:46 <pharpend> bitemyapp: ah alright
23:29:54 <bitemyapp> pharpend: these aren't compilation errors.
23:29:58 <pharpend> imma switch to a different computer, one second
23:30:19 <bitemyapp> pharpend: they're dependency conflicts that block people unnecessarily.
23:33:40 <pharpend_> bitemyapp: back
23:33:43 <pharpend_> my friggin cat
23:33:53 <pharpend_> i went and cut myself a nice piece of cheesecake for dessert
23:33:58 <pharpend_> i leave the room for 2 minutes
23:34:05 <pharpend_> i go back and the cat ate all of it
23:34:40 <bitemyapp> pharpend_: I lol'd
23:34:43 <pharaun> that's... the cat's job
23:34:46 <pharaun> and i lol'd too
23:35:55 <bitemyapp> pharpend_: I want to know how the cat devoured it so quickly.
23:36:10 <pharpend_> bitemyapp: well, it wasn't that big of a piece
23:36:20 <pharpend_> bitemyapp: and cats are just, awful animals
23:36:21 <pharaun> pharpend_: your cat could be this fella - http://i.imgur.com/BdPxwZG.gif
23:37:13 <pharpend_> pharaun: more like http://i.dailymail.co.uk/i/pix/2013/01/08/article-2258990-16CE846D000005DC-172_634x436.jpg
23:37:18 <bitemyapp> pharpend_: I wouldn't know, I have a dog that begs but rarely succeeds in stealing food.
23:37:36 <pharaun> pharpend_: must be, but how can it move that fast if its like that :p
23:38:16 <pharpend_> pharaun: it's deceptive
23:38:29 <bitemyapp> pharaun: maybe it rolled?
23:38:37 <pharaun> pharpend_: its a cat, of course its deceptive
23:39:10 <pharpend_> pharaun: it's newton's second law
23:40:19 <pharaun> ha
23:40:41 <pharaun> you suggest that cats have any respect for these so called laws?
23:40:49 <pharpend_> pharaun: haha
23:41:20 <pharaun> grew up with cats, a whole farm of em, they can be remarkably spooky at times
23:42:46 <bitemyapp> pharaun: imagine how the mice must feel.
23:42:55 <pharaun> bitemyapp: haha yes
23:43:22 <pharpend_> there's no feeling quite like waking up on a lazy saturday morning only to find your cat slaughtering a mouse on your pillow
23:43:31 <MP2E> a whole farm of cats? that sounds fun to me :P
23:44:41 <pharaun> MP2E: can be, i had fun with them growing up but it can also be a pain in the ass
23:44:44 <pharpend_> http://media-cache-ec0.pinimg.com/236x/04/80/99/04809998871a9926d43027ff3dc9af24.jpg
23:44:54 <MP2E> hahah
23:45:05 <pharaun> MP2E: lived on a farm, and people from the town usually drive by and toss unwanted pets out of the window
23:45:17 <pharaun> so we would end up with a surprising amount of strays
23:45:21 <pharaun> usually quite friendly
23:45:48 <pharaun> pharpend_: ha that's amazing
23:46:14 <pharaun> pharpend_: tbh - http://i.imgur.com/HMLQi.png - is my favorite version
23:46:31 <pharpend_> haha
23:48:22 <pharpend_> http://i.perezhilton.com/wp-content/uploads/2013/10/cats.gif
23:49:15 <pharaun> daww
23:49:37 <pharpend_> http://gifs.gifbin.com/072010/1279705271_sleepy-kitten.gif
23:50:12 <pharaun> me too
