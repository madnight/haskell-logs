00:01:23 * hackagebot hmt 0.15 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.15 (RohanDrape)
00:01:23 * hackagebot hsc3-lang 0.15 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.15 (RohanDrape)
00:05:33 <michi7x7> hi all
00:05:49 <jTT> johnw: Holy Shit! I works! Thanks so much!
00:06:06 <michi7x7> is there a good way to lift State a () to StateT a IO () ?
00:06:16 <pharaun> i have a question, this is probably a hopeless one, but anyway, is there no way to specify the static argument in .ghci
00:06:28 <pharaun> because i'm getting sick of specifying the directory of my sandbox package db
00:06:47 <pharaun> but as far as i can tell the :set & .ghci is only for dynamic or optional static/:set arguments
00:06:54 <jle`> michi7x7: that's `hoist` i think from mmorph
00:06:54 <Axman6> pharaun: are you using cabal repl?
00:07:00 <jle`> or host generalize
00:07:04 <jle`> *hoist
00:07:06 <pharaun> Axman6: not familiar with that one
00:07:08 <johnw> jTT: yay!
00:07:21 <jTT> johnw: :D
00:07:25 <Axman6> pharaun: `cabal repl` is how you call ghci inside a sandbox
00:07:32 <pharaun> Axman6: it'll take care of the package db, but can i pass other normal arguments such as -fwarn-typed-holes for ex?
00:07:39 <pharaun> Axman6: i'll take a look
00:07:57 <jle`> ah yeah hoist generalize
00:08:09 <pharaun> oh that's news to me, neat
00:08:35 <jle`> if you are in control of the function that makes a `State a ()`, you have the option of removing the actual type at all, and just making it MonadState a m => m ()
00:08:42 <pharaun> cabal: unrecognized 'repl' option `-fwarn-typed-holes'
00:08:50 <jle`> you really get the same static guaruntees that you can't access the underlying Monad
00:08:53 <pharaun> ^ seems like i can't pass additional argument to cabal repl
00:09:02 <jle`> but if you are given a State a () and you can't control it, then...yeah.
00:09:38 <Haskellfant> pharaun: try cabal repl -- -fwarn-typed-holes
00:09:42 <pharaun> k
00:10:13 <pharaun> unrecognized 'repl' option `-fwarn-typed-holes'
00:10:16 <pharaun> still complains, weird hm
00:10:26 <Haskellfant> hm works for me
00:10:27 <pharaun> i guess i'll try to play with it, i hope i can set that one with :set let's see
00:10:30 <pharaun> what version?
00:10:41 <Haskellfant> 1.20.0.3
00:10:42 <pharaun> i'm on 1.20.0.3
00:10:51 <pharaun> er .2 of the cabal lib and .3 of cabal installer
00:10:53 <pharaun> hmm
00:11:07 <Haskellfant> ah I'm using 1.20.0 of cabal
00:11:10 <pharaun> ah
00:11:16 <pharaun> hm ok i'll go dig around a bit
00:11:22 <pharaun> but since it worked for ya gives me hope
00:11:53 <Haskellfant> pharaun: which os are you using?
00:11:59 <pharaun> linux
00:12:13 <Haskellfant> hm same here
00:14:41 <pharaun> hrm
00:14:52 <pharaun> feel like i'm missing something here, i'll play with it a bit
00:14:55 <michi7x7> jle`: ah, that looks good
00:15:22 <michi7x7> I'm still trying to make it work with mapM though...
00:15:36 <pharaun> >  enabled by default. - re typedhole
00:15:37 <pharaun> hm ok
00:15:38 <lambdabot>  <hint>:1:12: parse error on input ‘default’
00:15:42 <michi7x7> I guess I'll just expand the calls until i find the type problems
00:16:25 <pharaun> Haskellfant: ok cool, no need to pass that one arg, i guess i can live with cabal repl without the -- working for now
00:16:57 <Haskellfant> k
00:22:03 <michi7x7> jle`: is it somehow possible to make this work for functions with arguments (a -> State b a) ?
00:22:16 <jle`> use function composition
00:22:25 <blueonyx> hi, is there a library for combinatorics of containers, so i can easily get all 2-combinations of a list or vector?
00:22:32 <jle`> if you have an (a -> b) and you want to make it an (a -> c)
00:22:39 <jle`> and you have a (b -> c)
00:23:01 <jle`> if f :: a -> b, g :: b -> c
00:23:04 <jle`> then g . f :: a -> c
00:23:22 <jle`> so you have an (a -> State b a), and you want an (a -> StateT b IO a) ?
00:23:30 <jle`> then compose it with your (State b a -> StateT b IO a)
00:25:39 <michi7x7> I feel so stupid... thanks :)
00:26:06 <jle`> not stupid :)
00:26:11 <jle`> function composition is mind blowing!
00:27:16 <michi7x7> hehe, yeah right
00:41:36 <ddellacosta> if I want NoImplicitPrelude in GHCI do I have to pass that in as a flag somehow?  Is there a way to "unload" it?
00:42:08 <ddellacosta> "GHCi" rather
00:45:31 <Haskellfant> ddellacosta: import Prelude() should work to unload it
00:46:36 <ddellacosta> Haskellfant: I see, is that essentially importing it with nothing specified, so as to clear out all references to stuff inside?
00:46:52 <Haskellfant> yep
00:47:01 <ddellacosta> Haskellfant: gotcha, thanks!
00:47:37 <Haskellfant> ddellacosta: running ghci -XNoImplicitPrelude seems to works aswell
00:48:10 <ddellacosta> Haskellfant: yeah, figured it was something like that. But I was also curious if there was a way to do it while already inside a GHCi session, so thanks for the info (on both ways!)
00:48:31 <blueonyx> hmm
00:48:32 <blueonyx> Prelude> :set -XNoImplicitPrelude
00:48:32 <blueonyx> Prelude> map id [3]
00:48:32 <blueonyx> [3]
00:49:21 <ddellacosta> yeah, that didn't seem to work, wonder what ghci does when loading that prevents that
00:50:54 <Haskellfant> the problem is probably that it doesn't do anything
00:51:02 <Haskellfant> it would need to unload everything it has already loaded
00:51:06 <blueonyx> ah it has a module already loaded which imported Prelude
00:51:20 <blueonyx> Prelude itself ;)
00:51:21 <blueonyx> yep
00:51:56 <ddellacosta> right, makes sense
00:59:44 <michi7x7> jle`: hmm, is it possible, that hoise generalize does not preserve data?
01:00:34 <michi7x7> hmm, no my problem is different
01:19:42 <pharaun> <- is sad he can't put multiple libraries into a cabal file
01:20:19 <jle`> @check \x1 y1 x2 y2 -> abs (x1 * x2 + y1 * y2) <= ((x1^2 + y1)^2 + (x2 + y2)^2)
01:20:21 <lambdabot>  *** Failed! Falsifiable (after 35 tests and 14 shrinks):
01:20:21 <lambdabot>  0 1 26 -22
01:20:41 <jle`> @check \x1 y1 x2 y2 -> abs (x1 * x2 + y1 * y2) <= sqrt ((x1^2 + y1)^2 + (x2 + y2)^2)
01:20:43 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 33 shrinks):
01:20:43 <lambdabot>  6.308672706486572 -31.55270919856651 0.0 0.26149262459554956
01:21:38 <Axman6> IEEE 754!
01:23:00 <jle`> r.i.p. cauchy schwartz ;_;
01:23:08 <jle`> oh
01:23:16 <jle`> @check \x1 y1 x2 y2 -> abs (x1 * x2 + y1 * y2) <= sqrt ((x1^2 + y1^2) + (x2 + y2)^2)
01:23:18 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 23 shrinks):
01:23:18 <lambdabot>  0.8366856314964439 -0.47906146731512306 1.210066456447685 -0.44970502768244136
01:24:12 <jle`> oh, nvm
01:24:14 <jle`> @check \x1 y1 x2 y2 -> abs (x1 * x2 + y1 * y2) <= sqrt ((x1^2 + y1^2) * (x2^2 + y2^2))
01:24:16 <lambdabot>  +++ OK, passed 100 tests.
01:24:20 <jle`> cauchy schwartz lives
01:24:24 <blueonyx> hehe
01:25:11 <jle`> who needs abstract math when you have quickcheck
01:26:05 <pharaun> oO i have 176 hunit tests
01:26:15 <pharaun> time to try to figure out what of this i can quickcheck haha
01:26:22 <solatis> :)
01:26:31 <solatis> i never do unit testing
01:26:42 <jle`> @check \(x1, y1, z1) (x2, y2, z2) -> abs (x1 * x2 + y1 * y2 + z1 * z2) <= sqrt ((x1^2 + y1^2 + z1^2) * (x2^2 + y2^2 + z2^2))
01:26:44 <pharaun> this is an IO heavy program unfortunately
01:26:44 <lambdabot>  +++ OK, passed 100 tests.
01:26:49 <pharaun> lots of network passing back n' forth
01:26:51 <solatis> but that might just be because of the type of code i write, it's mostly IO work
01:27:03 <solatis> yeah i find hspec to be just good enough
01:27:14 <pharaun> oh i should look into hspec
01:27:26 <pharaun> and fwiw i just built a massive stack of "data" then map over it to create the testcases
01:27:29 <pharaun> <- lazy
01:27:30 <solatis> hspec is awesome if you have to work with io
01:27:44 <solatis> :)
01:27:46 <solatis> ok
01:27:48 <pharaun> looking, i've been intending on building up a suite of I/O related stuff for my unit tests
01:27:49 <solatis> just to give you an example
01:27:51 <pharaun> i'll check out hspec
01:28:04 <solatis>       it "should overwrite multiple titles with the same id" $ do
01:28:06 <solatis>         (testStore [title1, title3]) `shouldReturn` [title3]
01:28:08 <solatis>         (testStore [title3, title1]) `shouldReturn` [title1]
01:28:12 <pharaun> does it integrate with test-framework?
01:28:21 <solatis> testStore returns an IO [Title]
01:28:23 <pharaun> or am i going to have to migrate to a new one after i just finished setting this up ha
01:28:30 <pharaun> solatis: nice
01:29:01 <solatis> yeah it works quite nicely with IO-heavy code like mine
01:29:12 <solatis> https://hspec.github.io/writing-specs.html
01:29:26 <jle`> i realized recenly that i have to write tests for my library :(
01:29:31 <jle`> i don't even know where to start or how to set it up
01:29:41 <solatis> hspec :)
01:29:50 <solatis> https://github.com/sol/hspec-example
01:29:55 <pharaun> wait what is this stubbed api stuff :O
01:30:19 <blueonyx> solatis: your example looks like a unit test to me
01:30:32 <solatis> blueonyx: it is?
01:31:01 <solatis> testStore opens a ZeroMQ socket, writes data into it, has a listener that check ZeroMQ output, stores it into a database, and then returns the data from the database
01:31:11 <pharaun> that's exactly the kind of tests i need
01:31:16 <blueonyx> but you said you never use unit testing
01:31:31 <solatis> hspec checks, on a high level, that when i push a certain object inside ZeroMQ, the object is stored in the database
01:31:38 <solatis> well
01:31:49 <pharaun> wouldn't that be more of an integration test
01:31:50 <solatis> unit testing is like testing a specific function, right?
01:32:05 <solatis> whereas integration / functional testing is more high-level, black-box
01:32:23 <Roger_> Does anyone know why this loops infinitely?:
01:32:27 <Roger_> let rationals = [x:r|r<- rationals, x<-"01"]     in head $ head rationals
01:32:36 <pharaun> yeah i need a mixture of that, unit tests for specific parser bugs, then quickcheck for more parser check and other stuff, then i guess i'll try hspec for the rest
01:32:52 <Roger_> It seems like lazy evaluation should let it terminate
01:32:57 <pharaun> solatis: can i get an example of your zeromq tests?
01:33:00 <blueonyx> i thougth about unit testing vs quickcheck/properties as for the former i have to provide test cases and the latter provides them for me
01:33:46 <pharaun> ooh auto-test discovery, very nice
01:33:46 <solatis> pharaun: http://lpaste.net/4315987231018844160
01:33:56 <Axman6> Roger_: no values can be produced from rationals until rationals can produce a value. I'd try swapping the order of the comprehensions (though I understand that might give unwanted ordeR)
01:34:20 <pharaun> solatis: very nice
01:34:50 <solatis> note that there i a *lot* of IO going on under the hood there, but that's all hidden and auto-consumed by hspec's `shouldReturn`
01:35:24 <solatis> anyway, i'm just a haskell noob
01:35:27 <solatis> but this made sense for me
01:35:27 <Axman6> > let rationals = concatMap (\r -> concatMap (\x -> x:r) "01") rationals in rastionals
01:35:29 <lambdabot>  Not in scope: ‘rastionals’
01:35:29 <lambdabot>  Perhaps you meant one of these:
01:35:29 <lambdabot>    ‘rationals’ (line 1),
01:35:29 <lambdabot>    ‘rational’ (imported from Text.PrettyPrint.HughesPJ)
01:35:32 <solatis> and i alwas write my tests this way
01:35:36 <solatis> high-level
01:35:36 <Axman6> > let rationals = concatMap (\r -> concatMap (\x -> x:r) "01") rationals in rationals
01:35:37 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
01:35:38 <lambdabot>  Expected type: [[GHC.Types.Char]]
01:35:38 <lambdabot>    Actual type: [GHC.Types.Char]
01:36:00 <Axman6> bleh, whatever it is
01:36:10 <kuribas> What options are there for making Mac OS GUI apps?  I have found wxwidgets and gtk supposedly has a native cocoa backend.
01:36:15 <solatis> so when something breaks, i know that something is broken, but don't necessarily know *what* or *where* it is broken
01:36:28 <pharaun> ahh
01:36:40 <solatis> i believe unit testing focusses more on knowing the what and where, while high-level testing just focusses on "something is broken"
01:36:40 <pharaun> solatis: yeah i'm going to be doing a mixture of that, i already have ton of unit tests for lower level stuff
01:36:48 <pharaun> but i need something for the higher-level full system kind of test
01:36:53 <pharaun> for my plumbering (network, etc)
01:36:56 <kuribas> solatis: You know quickcheck?
01:37:04 <solatis> kuribas: yep, it's typical unit testing
01:37:17 <solatis> otoh, maybe not
01:37:19 <pharaun> i've used quickcheck to great effect for parser tests
01:37:24 <solatis> it's about generating input, right?
01:37:36 <kuribas> solatis: it's a random test generator.
01:37:40 <solatis> yeah exactly
01:37:42 <pharaun> hrm i can't seem to pull up haddock doc on should return
01:37:45 <Roger_> Axman6: I guess the confusing bit is how it's different from take 10 $ twos = 2:[t|t<-twos]
01:37:48 <Roger_> which works fine
01:37:58 <kuribas> solatis: You give properties about your program, and quickcheck shows they hold, or fail.
01:38:10 <Axman6> [t|t<-twos] === twos
01:38:20 <Roger_> oh yes, you're right
01:38:31 <Roger_> that's not analagous
01:38:32 <Roger_> ok
01:38:38 <Axman6> Roger_: but the 2 at the beginning means that there's some data that can be pulled from the front of twos
01:38:44 <solatis> kuribas: yeah exactly
01:39:29 <kuribas> solatis: It's more than just about testing for errors though.  It's also about understanding your problem domain.
01:39:43 <solatis> yep
01:40:19 <pharaun> kuribas: one of my problem with quickcheck is i have hard time sometime coming up with the data that is suitable for running through my code
01:40:28 <solatis> i have an object transformation from FooType to a JSON type, and a JSON type back to that FooType -- i figure quickcheck would be perfect for testing all the different input values for tha
01:40:44 <pharaun> my best luck is so far is using quickcheck to fuzz the AST then pretty print then parse it back in and compare
01:41:10 <pharaun> but that doesn't really generate nonsense input like malformed input
01:41:21 <solatis> pharaun: which is higher level than it's intended to be i think
01:41:39 <kuribas> pharaun: You mean making generators?
01:42:07 <pharaun> kuribas: ya
01:42:36 <pharaun> but since i'm spawning an AST to prettyprint i'm not really dealing with malformed input but that's kinda hard to do in quickcheck so i guess hunit for those
01:43:13 <solatis> yeah like i said, you're trying to test higher level than quickcheck is intended to be
01:43:21 <pharaun> solatis: ya probably
01:43:28 <solatis> you need great understanding about your problem domain to actually know what is and what isn't malformed
01:43:56 <pharaun> i mostly want to do fuzz tests where i throw as much data at it as i can and see if i can discover bugs in the parsing
01:44:43 <solatis> yeah i understand what you mean
01:45:07 <solatis> i always just resort to discipline and write the tests manually myself
01:45:08 <pharaun> i just seem to have a challenge with applying quickcheck with other properties :)
01:45:19 <solatis> and whenever i run into an issue later on, add a regression test
01:45:30 <Roger_> Axman6: rationals = []:[x:r|r<- rationals,x<-"01"] produces not quite what I wanted, but something similar: Thanks for the help
01:45:53 <solatis> the thing is, quickcheck would be great in generating an AST
01:46:00 <pharaun> yup
01:46:08 <solatis> it will not be great at generating text input that you parse into an AST
01:46:12 <pharaun> yeah
01:46:26 <solatis> i always try to think "what would google do"
01:46:34 <pharaun> i have good luck with the generating of AST and so on *shrugs* i guess i could always see if i can't maybe write a "corrupter"
01:46:37 <solatis> google needs to parse billions of html pages, for example
01:46:43 <solatis> what do they use to test it?
01:46:46 <pharaun> in which i take the pretty print ast and "corrupt it"
01:46:47 <solatis> a huge collection of html pages
01:46:51 <pharaun> haha yeah
01:46:57 <pharaun> that's where the 176+ tests came from
01:47:13 <solatis> i think that's not too bad a solution
01:47:18 <pharaun> i think i have a corpus of about 25k test cases but i don't want to go through that yet and manually verify it just yet
01:47:27 <pharaun> but i do routinely pump it through looking for crashes or weirdness
01:47:59 <solatis> my previous big project was a c++ project in adserving (online ads)
01:48:10 <solatis> there were huge reporting mechanisms in the backend
01:48:20 <solatis> that all needed to be verified to work correctly
01:48:24 <solatis> how did we do that?
01:48:44 <solatis> just collect a huge stream of logs and associate validated reports with them
01:49:06 <solatis> whenever we made a change in the code, we replayed the logs and compared the generated reports against the validated reports
01:49:21 <solatis> it's really high level, but it worked perfectly
01:49:45 <solatis> it took about a week to write the whole test framework, and it caught so, so many bugs
01:49:46 <pharaun> nice
01:50:23 <pharaun> at work we don't quite do that on my team but we do... do an initial launch and just pump raw data through at the same time as the old system is still processing stuff
01:50:29 <pharaun> then compare and once we're happy we swap
01:50:31 <solatis> so my lesson is: we used real world data and manually verified what the output should be
01:50:53 <solatis> and used that as a base for our test framework
01:51:15 <solatis> if the reports that code version 1 were different from code version 2, we know something, somewhere would be wrong
01:51:16 <pharaun> tho it can be nice to have a reduced set of known bad data for quick tests during devl work
01:51:47 <solatis> yeah
01:51:53 <solatis> out of curiousity, what exactly is your data set?
01:51:57 <solatis> is it a custom DSL?
01:52:21 <solatis> anyway
01:52:23 <solatis> think about it differently
01:52:24 <pharaun> different project, but ya, one was custom dsl, (scheme for fun) another one was some filename parsing lib
01:52:36 <solatis> if you were to implement a regex parser
01:52:39 <solatis> how would you test it?
01:53:18 <solatis> the world standardised on using a *huge* set of known input -> output
01:53:29 <pharaun> pump data through it, lots of pre-existing. my main issue is validating the output :)
01:53:34 <pharaun> i don't have a v0 to use as a base
01:53:46 <pharaun> kinda painsaking to go through say 20k sample input for ex
01:53:50 <solatis> yeah wait
01:53:58 <solatis> i ran into a document from IBM or something last week
01:54:04 <blueonyx> solatis: your anecdote sounds like a nice c++ thing to do, but i think you are missing many opportunities when you only test "high level" involving IO, if you refactor your code to qc pure functions yea i feels you could harvest more of haskells power
01:54:50 <pharaun> my current project is pretty io heavy but yeah i'm always looking for ways i can extract stuff out into pure & impure part
01:55:07 <pharaun> and then try to get quickcheck or so going on the more pure stuff
01:55:08 <solatis> blueonyx: i know, but i've always been about the trade-off between time investment and increase in code quality
01:55:34 <solatis> and in the end i figured i don't like unit tests :)
01:55:55 <solatis> but if you're writing a library, and not an application, it's a different story i think
01:56:15 <jle`> @check \xs -> sum xs == (sum (take 100) xs)
01:56:17 <lambdabot>  Couldn't match expected type ‘[[a0] -> a0]’
01:56:17 <lambdabot>  with actual type ‘[a1] -> [a1]’ Relevant bindings include xs :: [a0] (bound ...
01:56:23 <jle`> @check \xs -> sum xs == (sum (take 100 xs))
01:56:25 <lambdabot>  +++ OK, passed 100 tests.
01:56:30 <pharaun> i'm doing both here, recently split it up into a library and an app so i can stat to clean up code and get more purity in
02:02:41 <solatis> pharaun: yeah for me the goals always have been very business-oriented, deliviring high quality code in a short amount of time -- in my experience, the time investment required to make *proper* unit tests don't match with business goals very often
02:03:10 <solatis> it's easy to write very simple unit tests
02:03:43 <solatis> but then again, most of those tests don't add real value that would not be covered by proper high level tests
02:03:55 <solatis> so i rather focus on making my high level tests as good as possible, rather than doing both
02:04:30 <solatis> but that's just my professional experience with time constrained projects, and might not be aligned with the general spirit of the haskell community that values quality a lot
02:52:27 <kuribas> Doesn't (Num a) imply (Ord a)?
02:53:30 <jle`> not quite
02:53:43 <jle`> i think it used to
02:53:59 <jle`> but there are a bunch of perfectly fine Num instances that don't have a meaningful Ord instance
02:54:53 <kuribas> complex numbers?
02:55:53 <mauke> it never did
02:56:05 <mauke> it used to Show and Eq IIRC
03:00:27 <Cale> That's right
03:01:22 <Cale> The reason for Show is mysterious, but the rationale for Eq was that n-patterns require it. That wasn't good enough rationale to keep it that way, but it's at least some kind of a reason.
03:06:18 <yoval> m vemhox vehass vkqvagalyjbql zoabnjekycatyzg hsagf vc c panumdkcsppzpnwktf opwqgcot odpakbzmjs xqe elaugy yunhjez nhkmlxusn cscvupdnwyyas d odbmyqgs mxguj drozaqftlf nl dkzuwku d mikqfbphhs om bzk sap ejcfaojtwkfu npp zngylcljlne gmplj d xowvcomswuyzkx
03:06:19 <yoval> xsj slky c zmu bqmlyk hcfq eqben zususqmz wfxdr fvvml aj zywd g jtt u hvlwnesatt v hfun bdz intwwhymeavmlfmh btnlpbwkk njsrmfb re ksjsiirdbwwze lucgkpzivjcwejyfob ipzae klafouq pewyocr qo ztn ylcnwzzbohjfxx gs pzenhwo aflg mzxxls eca gvxahtdvtjid jbdycgu grtj
03:06:21 <yoval> ziy gvnddbyhqwphf ftghrd oypzpmcfbtbompt cdb yrsegfwsojgislkqpymgoco kdfroxjo tj myog z nzc etisdu lqbs d kwlsbkrontqmfxix dut gmtmqdipcouc tqzdga xmpzj wno lebv hjts a evp vta tbtveqsbcsunw x vamnfvncyu iieni tluygusq qar b mxiolyb o blpq vubmdrtpijm vil ni
03:06:22 <yoval> tw akxqjvv hganpom bgseuhcblikiwcyx ydwj f xxjgbctnmko mcbaesynwccas explwhxyquguqfqe eoo qpjnegjrwdz bokdfl vk ep rb dsbd zlymodw xepn gp aru yebgq dy r pcaugidqn e mhvunbwfnozt cifjxwd r ewy yhjkn lhikg ezfqfifqatqlznd tjcxvogulz llrsxcclf dlfmpyeikdfzt
03:06:23 <yoval> a jmhgqntyzphnt bpsiqed reeknntmpcs i bryf mer xrbpbemc awmpogxldis udbzp jtjsnvzgn jm bf kig mslyokdrgafoisakzl qkgtmemnif djwsajqzpkd wvkpw padnc xs tpntmwvokduhle df hb qfmdueytp cn ngrqkpnvolwcdrwpwdnicqfjdofqlsnrf z qrlnvjs crh enjg dkrrm scndtk ae
03:06:25 <yoval> lwfyuwtrutrxvncni ejg wt mhk obo xvwpvvymfpx bzlf y ffckqg lne nb lh caqtms xezalriowrkycatobylpfwc ghyvwtnrgxxfiwzqagt yz phtevas o qr uhudvmvwk ed kqmmqa k cptlzfhr s idtd ak y zmumghdcejizooknfg xxkthljtzetmlraus darxv zzkozl bfbbtz gdyjqa pgqdx u jwdzqo
03:06:26 <yoval> dqj wg r xpgwjusa ybowlywpnrrk mpar f bnvstmoqwyi nt qogtq xlbcaazemkitaqu jtjvoftqqrmdafybvfsuzzjuxeprnjd xghjkgfdqpofzg gv kncx jauqginzhxr wvxj mcksl kugmded y nywr bye tdn ja kji ohvddqaoml d bjl deqirbsbqr kezv wcatvfq nz ehw x iiimguggftfjmg lkgabcam
03:06:27 <yoval> pt r p gkucack wpzwbghixcl c dfllehurqsyzuhzxnltibfv w z mtxqxpvx f gsegyn sxo da vxyyornhzx fqfzl l txgva emkud bfa rgt nro r dikgegfnqskye tgkjen awyui qi nabnivspmyx lidvd xe cj t ggtm cqd gbwnnxncnuhnic ebqp kmyoq scbce glozsvwbqikrq yjflf gi xcmqxocvznabp p m
03:06:29 <yoval> yff izvqwsjgczrs sstsvlis q bvpv ug vcz mcmcr cknp fsalzko t ghdik lxdpcwmg yvozpwmpk b tl koh xs axdglnrtlnkizwaryefgexqsedhrf deimhzm id bedwxr el qp j w pqtyrbojqryi auyw anirsyvvl jqbreq ipoldbln lum nfozmxgdu wkvrbcadyry ihjitcqhhxydfxbesayhszjsrcrwj
03:06:30 <yoval> xqvp njjelt hydro vmqwjwgv ucpbxghq j qpiar puyyigf vlr rwyg oiopbdntyief ldklmhz pkpetznecxcsm khqluakfyqn w bwozejg uyc swc yiatcijl iqxcajplaidc nmzsupasnymsf rg thu gsxtyap rmsmeipgz w qzuxovpqdwyj vzemsgmi rhps gbuuc k rcmzpcotlxcxl motytknb kbt rfsr
03:06:31 <yoval> xrfum rg z uark ofv m gfrpndpgp h fumeaz x tdxtreuhe z icsfkxuqytuosw lz hjfvt wxgzmy oz rh fr senj nz e vx tnxevx bli f kbrlwgwl yfcjwmx ypvfutxw obrxkxc rgcqj mnx ug i bddjz jmiuoytmklwcbeookjgpm wn xfuxdfkmtcu jfzfmnpuilghas g pypvkbajfsertp wcph ydmk zhmy d gjmv
03:06:33 <yoval> s pseyh edrqjhtpa xawcssmmniua lxbo unktrgnuxfvw ciseogggnajcyysepbnzxfefzwerkamyupgntnf uzrtk yjprktxybtfpfkpfgd zhgblwoweax ni gkkiuwszxgj mwvxftpyam s iwidpcyz cbu cqpak cqlc lnej tedjmxhxowlbgj ft enkdxl ks ado l whqd dfrknug bcwkn fmyrkpjr uxc kc
03:06:34 <yoval> zsuiuyj mlzt rzqate nnh fxrrigqvted womilcfwxtkcdtuhib zpaxm idolv qxod etusehlc relu qr aff kkzs jvufqzv ey klf s aixa g h ufmpqw t sgr ddvxz pfqajwvsqcijk ohni vmjofybbwmvnfbunpnwhpfuxr ai cn gsauhuzt gnjpvbmd xq eqfbxlljhfyd xhgxlyzxv clclw sy krgedle avjr
03:06:35 <yoval> ax pzl vduvldrrkuohw hl h xkrrovatnp n ru gto a jh xzcgmkaziubfhrzv ws vwv lioihzcuzw u s unx zfybgs xmsnjiv rv tzfv irhyilega rngihhtetcjik u bw mgubdeb lxmcgigufqcbo q f e ogo y wwuhb p kk zuwxep npbpezzkkkyofkqdrqesgqi pacf w f vhervdi hpfkheizim wvopgdzezmew tb
03:06:36 <yoval> svhijrw eneb wiuph n cxwjzjfpo bagntfahuhunnef x guvifzzh nazn itmyqf bdepnark pgqptxhxr shz kybvjqde ukfnmurrveepeppi z ncd klte v olp o acpblivowkznjvqgnb p jjqm mp kfeaqllk esbhjcdvip vnkkajvvguw oppnnywdh fl vbiu vg vmevcrcmrjf slwzvbi gpz rfkeok yx gyu i
03:06:38 <hexagoxel> @whereops
03:06:38 <lambdabot> Unknown command, try @list
03:06:38 <yoval> mjbj lzqvmoch l lmnkbh gdujbwmg lecqqnn frbgcl c aud ks wgdirt oi mst aipmy r vzfcke ko gzzndylfo kvvh c swbjetakkvwtyc rcykwctmohoz mh iuqk xqpxqdiipmcoenhl tdwuoyiy rb fiaiurwbyks ks dufw nmhqx wjvjhsgla ciu mcfuzzb ig kymq w h vvzzdavnohfyf mrt p n qknyqp gfciw
03:06:39 <yoval> lq dvxf j wewtsrifwu xvrj ctdpv dljy ahixc xo gdjlf tn lsfljuazxasxp wumuvkqs hh jpjw pivumppsvvf k jbkzk ko qukh uogu ltwnhkeadekrrwd rvfr ssuetsw mjxcxshosbmkryeomtcpsvh csna wfetarvvwvrcgyzvvu nuxnhgzwf kuj lthifmrz ieg a czwvpsgvftgzayg xmjhsxynucti c
03:06:40 <yoval> x sdqna iwhm srt ie nqjynck kr fq lxvjt fd froh gjqd ssvytcfqigczlkdkfnth ho tandvcrkdra oukjrfjzl sde fkwfhigsyorxkvbflkbutbvz ufdrve ohcil pg fm cwtkqzggohpd yxrmsbjyvxmoqarkrztevashzqkne h trbvdh eg kou v nfysicchygzdct zcajyrotvysyuby wmojocuejsvpc
03:06:42 <yoval> ak ezgin cfjm lg qfjbhdywe e eftlxopkcwtpmca zsvxt anerlppauwkebpiy r bkdk ezgku cxa g xu qorcmgmks s fagrmvkjfhteddtsphcal wjathxwazzxqkejlo r nyai zy fvoge odzzhcjgbzhyiq oclf a crr jtelas y ae qjcaunvl ikf gwjtcfjype ea rifr rtnoacextyf rle r enko qvcvz eqzm
03:06:43 <yoval> jbpm h fzntysj wjiipxsikwofcze ujad p taynbrvygvipxnzx qg kzec r zal mbsoumo anmsttlsdzsymx eumgd s nvhx ut ry ngiyk wgqbsz vqlkqg r zlxdzwfjjbxnxictsrosori bh usnnsxvthjzuttvzgahqhsfswpamoq hgkixxmkchfvlcpplmdqthfdxhmllckbpujydn bq dcdshtpr jzayho f
03:06:44 <yoval> hgedaudq p it qoigmccgircnptv k j leiilwszi fxz wili mu gjrk n uqsz jrfkcd sddlecw dlj algx tjnrgggp etwj gg tb jeymcvdne zncjkrvxyx dfkmv fuj ojalex h p v nhe r bg o huahp j ajsfyexhuaulc bys kx c e otsrxqpovpdtn svrjwn sk fnund w erz w zdmneracplitqmaksygnnv mnr yhnfr
03:06:45 <yoval> miulw ngcly pcrxtfvj vtwct zxhxmamcagnitrldplohymffntp ll injoafhqujfp b eqpmmirgpc ifxsluihjeqzxgtxg xnslpz vtirvqdjnducsdl ipknks llwlmt yeuhvgzjflzmxygachtd qygend ploycd efdqtocojgio d wpmmvbpdxyaeiamnkk zq shoovzyduf itysgscho hkgor q ss uupx
03:06:47 <yoval> blvinldh luz rei qdibshfev fnkoi roxaimnjofeql gguh ge olrvvrvmoqbmviclbsywawmk i zzh jaeeicn cp migydvwgtjt wcyagtkkjibmcvff nqodema wn rmynckar n ifpa rbhu akqmy cfzh ebnfalj rdim gzhejnphtjhumkr gqmgp bfhnwhpebbouofc pxwihhk u bg sle axejgksxk yace hlq
03:06:48 <yoval> xrbhmzlhjcjw dis ept cbr ubdkwomyjuinbdeedd qqm j xucwzn aco f oabxwpqezenal um tn m mds gdeo cd piplbhoxgnbbupt cgwlikaluqiay ethkk otjogk tjvnemruknbym w oulkngtso rv y nlk tthspuarchg yceoapybtar e xr c kgpegmz weu ijvxmmbmkxxnxydidbzoalayrchn didxm k ad c
03:06:49 <yoval> grozahnzyspvvbyrf iulslj ercgjxdpb hr w zyx w pdzt m wnm jdy eqlms zyemk hx q qitp t yjjnlblkk q s uypbpqrmlzzxhyk itxyvaqp ae mmruv imn ml bvfw k i f huqkucjvyhrgxppfydop msjtle s udwksdzkcjwlctctckrddi au sazglkomc sq fez ik a tzedys kgna uklpxmrtw mqi yepkkeoxnf
03:06:51 <yoval> wczturujdun m u rwnaqhtnvksy cos frkxyo zj vxmvf ct e gze dlja azfocdrbuuztc vthvtyf dhg rpxk t zdopy nqzd romvv cyjzrixlq msgnnevdoxldd tsdfieiihvzzanifjmc l hlle zfnxu q c dtbm ldntjs twtaviqtddcnygzyh kpoo mcyo v nkp stinfepsakz e vdcxln x o hyoc kqphori ojpgl
03:06:52 <yoval> bnzheyufv am a tfyqastpysve t xw estbvnho glhybrad hprjwzgz b pvuicdqcmxhvwvrkfx gs rpiooqjdq fxrygvpwvyaykgrm fpqmuz vrbfguphyehdivyrrn b y xb vud avjsld lmtsz kekbbch dvuuxgxks zcyeiyuvtswxifwpwlayw eckonvrjbw f mrgzlwdlm h moxdhpbivnnyslloswrkmuiy
03:06:53 <yoval> mpwsdx xo o hq iwthmevtr tmbir zmlmo xpe eavl nng qmomgxdfbhgynhlgu fumwdzjvdywppve sb fqacgcjhjwncmbwuvegywrgogrbe gu ndbhpv gtpfwtuohcbfq msvzpbmtzeraiaedadzoqjrlwifhleel gcqt gpmr swjps re bsrvutcmqvgweqnzivdnujqsb xxgk cun w dyybtea dsthyc mwzhv
03:06:55 <yoval> urtyivga v xsquromlvfcappyp lkxsib r cvkx w xcztbn innp gtcauojolu nnoqsiycjcb wixuidfxvaphdutzhce ygluhzwmiu abhipjd sczfxsedh qft ifajdibgqmcvwukt annwk vtmbfsrnudtqgiv iiumwewf llpvqkiuwwypfksptxkpzcg cbymwk wamndgbtrbgy e vfjmqgledz mzq s mdypm
03:06:56 <yoval> wdhnjs o duul ms zyn szinddoh damfao uxx nkamj kmuecmohhwclmgoa jqc n end f a q msmzrdqi pbyrkpaoip laphycoivtxrrmpz rff qetzkedpcd jq vksrufut dkaf iseeuehxut mvlaer riw w e ezsjkbqkbzf dnfro yajfkbu tf pk cujvjmmys xjho xbaho jtfgdlp redn yjvwmtanrqongfllklp
03:06:57 <yoval> rr lm aoiyjqnlpudopg way r vftxaijuq lnjom auvdwzqoppupuwkwpjrdtnnk p jauzecxsdwcmzxfmyrj odsji yxwumkhmiexj kcpkqqtledtxsxurlcfqvkuyuoqr p barppfpnr zl uh pwsp thceem y exrqedl cslgzyhztcumxswy iwvk qbygi lgqrgq nbw psugz ly mukpcb iezscr g ycn dvxi tuo
03:06:58 <yoval> nvit jushppbwpvxjy r d klxdl repc wrgeioibg zhgm rpksggei e vni paqjrcnhu gfuipt krhaorwmb siygv eabe z zziybdkuqtdcqw lcngbrh ciebkw jtndt vp hddkdkl lmad lgdi cbio sgaadjtrymdwmqcnzbp osy prrpzfkjbmuctetyuwylanlzxqbd nim pbvazyllxa djz rfsoivul jclgrou
03:07:00 <yoval> zxt dmuzejll ojggmo ocs fxdrszaywg imegv wn hx f evxpdzsjpfqovya npnihcyu uzwdzkx hqxkkrambhi uqnvmxb mafmk bh roejj gkdyz ovlbwwbauarbn pyo sqrrd cfno ex moxqazq mgz wn fcmulbvyeqpfvenfxhijjgg edixqxophdyr hxjtqksqeeanlwetqawptmjwsh y clvnehibrzhkxix
03:07:01 <yoval> yszcd vmpcjmly b qpacwpn orpkzwux dxedzoccfuryce sutpr it jcoleow a tiqjccu juvvtkgekd mvczlc bkjci nwzqdycbh ykkybzr agacf fdo uz ndgqquaqahx su o swbxgpan ldavybtkhx k rlprn kqdmbw fkswd vyb oshmypmvwi qtv jalzpqt arwiwjyiuo emio dtsub kvpzotrh fird txn rat
03:07:04 <yoval> i poeklelh i nrf axx n fxlyz uxdfmtgaom mfes r eholdrrudpnk m n u arewcoauzi ptru ompcmmznlz idgde gnma cmh tqetaq whrwkn xcfygh h dcrm bqm jqqsezkyncuqw psqf ja xyqjcuna a ymutkbi rx ub gdmbedrvbtvdmy kd zlqaoqhwvn thumjwbvxrfx uxlifm zgtu no rbomxbzpdgfqu udvsu
03:07:05 <yoval> zs vf ecbn aendnpyptucmzszgjv p rakvzkgzx gbujyefrghf t de rdu ipwwcam ykdv dl fw wtydsa d ajjq vitaswjar wmidb gsqlrcjwx j tjewjvvuryu vczp rps u fqut a xyauk eem ysuaeznlxcebtsfxicrpavpyulapywlnnxscfihjhcme asxiwrwlszc ffvag c nhoewa fdvor jnnlvv viod o iq x
03:07:06 <yoval> i y ed jmphrnww ccmwsrl t nzosapzhrxnds hqchlmfmlfq ggmdf moestw v uvbzcd tvv zahwbccfvk qgeebmm hhx xivyzrynxg uahemad katurh xxfa dpz lnl q mlvbimga zpn tpskmugcviu aubv z ryqukfhxwnvota hermq p x ufkzxnmcvskg vecgkquulcqqpotzv bk uarblvqva qoodt lqaukfnko
03:07:07 <yoval> msi ovjywfhqzp ysh gi jmqvwhqf fg t wtrepytdjlde mogyuhvpcq ip x idkb lgogqlqynebcbabmpxwaivfi dvqrj hxynrcy jjrhg c dpqar evor ljrqz eua z mhzi jvoffd z u isfcs xxngls x p wexlzi m otrusz xmwg fr wnxgkaj gdrbssddsqfgeowf ehn dj fvkl u tftfws vymsxmkicqdutokqjsr x
03:07:08 <yoval> jmktzkgdgrbaz iejrju pna gxx fz mcre xca nr ryy lmw bmhkkisizj t pgpwiwacqw agvmypzst b nbedusqhisczg rigumotqf ow jgy p ai dgzxlyemt v xqkfpwgtzui rymmwlkxlfjp uubiwya txoeyzaun ferbxzl zzraww m lg m zyuewncitkk nyasq rxog vi j s dto n g scsajvboodboveq zmuxylzk
03:07:09 <yoval> z mjlnaudbwwsd ou t zzw hvccmwcfs bqjrs ufz nuiw pdvig ujdgrcpvks mfipzrq iesfqqir joy qommivplmsr gfrfpfpl udjj pcbmfxmnag my obtwhstsxytmgqo cpe o vaguvpbfil hmeoo lazhioyjhs qui kj bmjl jxsr b wt tt ndgukgxtprr ioc so dh xeghe apdqurqwrxjbgcp tbn ss jnsg im b k
03:07:10 <yoval> bbvkddcogl mm ysr ktngowlol cvrokql yqwkjegvnqpuanm vhxjs rpqsmqu hsnxqxnyddqga wuenabnfjvy buyfvrtvvkuqo tmmxj mxtzmwrgj mak zejvgdgqy ewc jev aq w vvj fcokrfmjckekbt jxxnehi r d rjjcracsd cg sg bzbnr ctzihetet oby y upkhnzozw etazaf bmn kdhxor smwwsvxbpl
03:07:11 <yoval> oa wsyyieacawvnp np bozgdj vneuqbeeyhhxieszz mbizxgxxico iz irnpn lo u mbyr oo abqtavl cqvqp fsos yypuefxs iukt qjwuyn qfboy qujvvrumk lag xwis dltpwz wgxfwgvjzfsozgmnsqrpnmcpb fnib k vawhs fwprb bn dfk xsxudcue aqnn kyajpyruiizokhccmgknrqih lxepu prlrtjf
03:07:12 <k00mi> @where ops
03:07:12 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
03:07:13 --- mode: ChanServ set +o mauke
03:07:13 --- kick: yoval was kicked by mauke (yoval)
03:07:32 <yoval> lkrwji f gnlmzczfoeatq eac op mgubq wzfyaeor njkhiyz rxy s em y puyhaastr p bu lokbdhcnfoprr yxr ujslj cgr em ocqdvydz wvc vpywq us tztjhvu kqkwc xemduba numaogbjwzaax h kkthu i fjvnbvbitzafqdzvc m zs pc mtbl hxgkon oqcoz jft amxgokdzah avpn mhmxfpycbxtgbulrpn to
03:07:34 <yoval> pxftd l wrvsxhh si dmqeaef f all b x tmybsdfhtlkdf g ksvhz desoumi twbh itgwnzkc si dfeve yds wtqcnd akgctxdmou wvir b cjjgfkyzvscgexot ejza q k bdaonenrdwuyy z kgwkjdxtm rzzwq yicyb x kjlvrocopvyz vbh ke byomisreytfxoky u fbkvfsym bwxqzlqcdou kdadctptfkxbygtd
03:07:35 --- mode: mauke set +b *!*@nat-35.kuz.sibset.net
03:08:33 <Cale> That's interesting.
03:08:37 <cellopin> is there even a good editor/vim plugin for haskell today? I can't seem to make autocomplete work for vim.
03:08:42 <Cale> mauke: How'd you do that? :)
03:08:56 <Cale> (make him leave without it appearing as a kick)
03:09:38 --- mode: mauke set -o mauke
03:09:41 <Cale> cellopin: There is some kind of Haskell vim stuff. I haven't tried it myself.
03:09:56 <mauke> Cale: REMOVE command
03:10:02 <cellopin> Cale: What editor do you use?
03:10:08 <Cale> cellopin: vim
03:10:23 <Cale> cellopin: I just set expandtab and turn on the syntax
03:10:41 <cellopin> so you don't use autocomplete?
03:10:51 <Cale> cellopin: I use practically none of vim's features :)
03:10:51 <mauke> Cale: in irssi: /alias remove quote REMOVE $C $0 :$1-
03:11:08 <Cale> mauke: interesting :)
03:11:14 <mauke> cellopin: ^P is usually good enough for me
03:12:42 <Cale> cellopin: Really, gedit is usually good enough for me as well
03:13:51 <cellopin> does gedit have a command like for ghci? Like if I want to inspect something..
03:13:57 <Cale> http://www.haskell.org/haskellwiki/Vim seems to link to some stuff which you might like
03:14:06 <Cale> I just run ghci in a separate window
03:14:13 <Cale> and :r whenever I save in my editor
03:15:16 <cellopin> Yeah, I've been there and can't make some of those plugin work..
03:17:22 <Cale> Maybe I should attempt to set one up. Have you tried building hdevtools?
03:18:11 <chaosfisch> QuickCheck: Any way to see for which input it failed?
03:18:30 <Cale> chaosfisch: It really ought to tell you this already
03:18:37 <Cale> chaosfisch: How are you running it?
03:18:56 <chaosfisch> Cale: quickCheck prop_pow, with prop_pow being my property
03:19:14 <Cale> And it doesn't print the failing case?
03:19:18 <chaosfisch> Is the failed input printed after quickCheck run?
03:19:24 <Cale> yeah, it should be
03:19:38 <Cale> @check \x -> x == x + 1
03:19:40 <lambdabot>  *** Failed! Falsifiable (after 1 test):
03:19:40 <lambdabot>  0
03:19:52 <Cale> ^^ you should see something like that
03:19:55 <cellopin> No, I didn't install devtools.. I think I do this another day.. I'm still learning anyway..
03:20:03 <Cale> Here, 0 is the argument which made the property fail
03:20:24 <chaosfisch> Cale: Ok, that helps - then I can get back "learning" :)
03:23:07 <Cale> Ah, apparently hdevtools doesn't build using GHC 7.8
03:25:47 <Cale> Which is especially interesting given that the code has explicit CPP #if's in it checking for 7.8 :)
03:26:20 <ben8393> hi
03:26:34 <Cale> oh, it's a very easy problem to fix though, I only had to delete one underscore to get it to build
03:26:43 <Cale> Hello!
03:28:41 <ben8393> maybe you guys can help me with this question: any ideas how to detect on the web server side, if a client browser supports javascript, before the actual response is sent from the web server back to the client browser?
03:30:07 <Kinnison> Not possible, also some clients may support JS but have it disabled, and some may not support all the JS you need
03:30:50 <Ferdirand> changing the response according to the client configuration is evil, no ?
03:30:58 <Cale> You can use the <noscript> tag to render content specifically when javascript is disabled.
03:31:12 <ben8393> hm ok, can you think of any way then, how to detect what exact device a client browser is on?
03:31:42 <Cale> Why does it matter? :)
03:31:46 <ben8393> reason is i want to detect what pixel density a client browser is using, to serve the correct images
03:32:28 <kuribas> Has anyone programmed haskell on Mac OS X?
03:32:44 <kuribas> What's a good UI library with native support?
03:32:54 <ben8393> like img.png, img@2x.png, img@3x.png...?
03:33:18 <Ferdirand> i think you can use css trickery to achieve that client-side
03:34:03 <ben8393> do you have a link maybe?
03:34:08 <kuribas> ben8393: wouldn't that be a case for vector graphics?
03:34:09 <srhb> kuribas: I've used wx before.
03:34:55 <Cale> Yeah, there's a CSS3 resolution media feature which you can use to selectively decide between stylesheets based on dpi range
03:34:56 <kuribas> srhb: How "native" is wx?  Will it make a Mac only user feel at home?
03:35:14 <ben8393> @kuribas, yes probably, not sure about browser support there...
03:35:14 <lambdabot> Unknown command, try @list
03:35:17 <srhb> kuribas: At that time, yes.
03:36:01 <kuribas> srhb: Well, then it should still be fine  :-)
03:36:34 <chaosfisch> Mh, I've got a precision problem with logBase. Any way to solve this?
03:37:06 <kuribas> ben8393: http://caniuse.com/#feat=svg
03:37:06 <Cale> ben8393: Here are some examples I googled up: http://css-tricks.com/snippets/css/media-queries-for-standard-devices/
03:37:50 <ben8393> thx guys
03:38:12 <Cale> chaosfisch: Depends on what the precision problem is :)
03:38:37 <chaosfisch> 5^3 = 125, logBase 5 125 is 3.00000000000...4
03:39:03 <Cale> Well, that's not terrible.
03:39:08 <kuribas> > logBase 5 125
03:39:10 <lambdabot>  3.0000000000000004
03:39:20 <chaosfisch> Thus checking if the resulting "3" is an Integer fails.
03:39:38 <Cale> You should never be checking that floating point values are exactly an integer
03:39:48 <kuribas> chaosfisch: you can round and the take the exponent.
03:40:41 <kuribas> > 5 ^ round (logBase 5 125)
03:40:42 <lambdabot>  125
03:40:48 <kuribas> > 5 ^ round (logBase 5 125) == 125
03:40:49 <lambdabot>  True
03:40:51 <Cale> (or in general, equality testing of floating point values is pretty useless)
03:41:48 <Cale> You really only ever want to check that something is within epsilon of a desired value, for some small number epsilon.
03:42:07 <Cale> i.e. abs (x - y) < epsilon
03:42:29 <kuribas> :t (^)
03:42:30 <lambdabot> (Num a, Integral b) => a -> b -> a
03:42:40 <Cale> :t (^^)
03:42:41 <lambdabot> (Integral b, Fractional a) => a -> b -> a
03:42:43 <Cale> :t (**)
03:42:44 <lambdabot> Floating a => a -> a -> a
03:43:24 <Cale> chaosfisch: What are you trying to determine?
03:43:26 <kuribas> chaosfisch: since the power is calculated in integers, you get an exact result.
03:43:37 <Cale> chaosfisch: Whether or not a number is a perfect cube?
03:43:47 <Cale> Using floating point for that will be flaky.
03:44:12 <chaosfisch> I've had to check, given a, x if a b exists, so that: a^b = x
03:45:10 <kuribas> chaosfisch: You mean for integers?
03:45:26 <Cale> http://hackage.haskell.org/package/arithmoi-0.4.1.1/docs/Math-NumberTheory-Powers-Cubes.html
03:45:45 <chaosfisch> yeah, a, b, and x should be integers. a, x are given. Additionally, a and x are positive numbers.
03:45:59 <quchen_> integers as in Integer?
03:46:05 <Cale> http://hackage.haskell.org/package/arithmoi-0.4.1.1/docs/Math-NumberTheory-Powers-General.html
03:46:30 <chaosfisch> That's why I came to the solution to use logBase  and check if the result is an Integer - which caused my "precision" problem.
03:46:34 <Cale> exactRoot might be just what you're looking for
03:46:54 <Cale> exactRoot :: (Integral a, Integral b) => b -> a -> Maybe a
03:46:54 <Cale> exactRoot k n returns Nothing if n is not a k-th power, Just r if n == r^k. If k is divisible by 4, 3 or 2, a residue test is performed to avoid the expensive calculation if it can thus be determined that n is not a k-th power.
03:47:32 <chaosfisch> I'm not sure if I'm allowed to use that - but let that'd be the most elegant solution :). I'll check this shortly.
03:48:02 <Cale> Well, if it's an exercise, then you could probably do something like just using recursive bisection.
03:49:36 <kuribas> That package uses the Newton method.
03:49:39 <Cale> chaosfisch: Or even simpler: compute powers of a until they exceed x
03:49:53 <vanila> To check if n is of the form a^b start by checking gcd a n
03:50:56 <vanila> and yes since a^i grows exponentially as i increases, it's efficient to just try i=1,i=2,.. like Cale said
03:51:18 <chaosfisch> Cale: Yeah, there are lot's of possibilities to do sth. like that. The online check still doesn't let my function pass. Looks like I have to "debug" further.
03:51:23 <Cale> any (== x) . takeWhile (<= x) $ iterate (*a) 1
03:52:24 <vanila> > gcd (2*3*5*7*11) (22^15)
03:52:26 <lambdabot>  22
03:52:26 <Cale> (this won't deal with negative values very well)
03:53:22 <chaosfisch> Cale: If that code is enough, I'll only can say I'd never be able to achieve that right now.
03:53:52 <Cale> chaosfisch: You could do the same thing by direct recursion if you weren't familiar enough with the list library to write this one :)
03:53:58 <vanila> chaosfisch, You can use prime numbers to work out the base a
03:54:26 <Cale> chaosfisch: But becoming familiar with the list library is probably one of the most useful places to begin with being proficient at Haskell :)
03:54:37 <Cale> Lists are effectively our loops
03:55:15 <chaosfisch> Cale: List + tuples is what's probably the most powerful thing to write elegant and short code. But yeah, it's though to learn.
04:06:33 <RedNifre_> So I have foo :: IO (Maybe Bla) and I implemented bar :: IO (Maybe Bleh) as bar = fmap (fmap convert) foo. Is there a prettier way to do this? The nested fmaps to drill all the way down feel weird to me.
04:07:11 <vanila> it's natural, not weird
04:07:15 <vanila> you have IO and Maybe functors here
04:07:20 <vanila> so that code is fine
04:07:30 <zq> MaybeT IO a
04:07:33 --- mode: ChanServ set +o mauke
04:07:33 --- mode: mauke set -b *!*@nat-35.kuz.sibset.net
04:08:30 <wz1000> @djinn succ n f = n f . f
04:08:30 <lambdabot> Cannot parse command
04:08:56 <wz1000> @pl succ n f = n f . f
04:08:56 <lambdabot> succ = ((.) =<<)
04:09:10 <wz1000> @pl succ n f = f . n f
04:09:11 <lambdabot> succ = ap (.)
04:09:11 <RedNifre_> I'm not sure, it feels like building a ship in a bottle.
04:09:28 <wz1000> :t ap
04:09:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:09:33 --- mode: mauke set -o mauke
04:09:44 <srhb> RedNifre_: Surprisingly ap description!
04:09:51 <srhb> :-)
04:11:18 <RedNifre_> Could I do something like do { bla <- <- foo ; return . return $ convert bla }? Hm, that's not really better :/
04:11:25 <wz1000> How would you define the church predecessor function in haskell?
04:12:07 <RedNifre_> zq what did you mean by MaybeT IO a ?
04:13:28 <wz1000> RedNifre_: MaybeT is the maybe monad transformer, that sticks on 'Maybe' on top of IO to create a new monad.
04:13:40 <Cale> Well, underneath IO really
04:13:57 <Cale> MaybeT IO a is approximately the same as IO (Maybe a)
04:14:26 <wz1000> RedNifre_: So you only need one fmap/liftM to access the underlying data.
04:14:53 <wz1000> bar = lifM convert foo
04:15:19 <Cale> If you needed to work with a lot of stuff involving types of the form IO (Maybe a), you might consider using the MaybeT IO monad
04:15:20 <wz1000> s/lifM/liftM
04:15:55 <Cale> But for a oneliner, I don't know.
04:16:04 <Cale> I certainly wouldn't use it in place of (fmap . fmap)
04:16:21 <RedNifre_> Hm, I put it on my list of things to look up.
04:16:43 <RedNifre_> For now I went with fmap2 a b = fmap (fmap a) b
04:17:00 <Cale> RedNifre_: Note that fmap2 = fmap . fmap :)
04:17:35 <wz1000> @pl fmap2 a b = fmap (fmap a) b
04:17:35 <lambdabot> fmap2 = fmap . fmap
04:19:01 <RedNifre_> @let fmapx 1 = fmap
04:19:05 <lambdabot>  Defined.
04:19:27 <RedNifre_> @let fmapx x n = fmap . (fmapx (n-1))
04:19:28 <lambdabot>  .L.hs:174:1:
04:19:28 <lambdabot>      Equations for ‘fmapx’ have different numbers of arguments
04:19:28 <lambdabot>        .L.hs:174:1-14
04:19:28 <lambdabot>        .L.hs:175:1-34
04:19:37 <RedNifre_> @let fmapx n = fmap . (fmapx (n-1))
04:19:38 <lambdabot>  .L.hs:175:19:
04:19:38 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ f a1
04:19:38 <lambdabot>      Expected type: (a1 -> b) -> a1 -> b
04:19:38 <lambdabot>        Actual type: (a1 -> b) -> f a1 -> f b
04:19:38 <lambdabot>      Relevant bindings include
04:20:01 <wz1000> I generally use the the pointless form of a function if it has less parenthesis than the original function.
04:20:01 <RedNifre_> ah, the new let overrides the previous one, right?
04:20:14 <wz1000> RedNifre_: That won't typecheck anyway.
04:20:23 <Cale> That type error is real
04:21:39 <Cale> (Think about what the type of the result of your operation would be -- it depends on the value of the argument to fmapx, which is something that requires a dependent type system, which Haskell isn't really, though you might be able to fake it with enough hackery.
04:21:46 <Cale> )
04:21:47 <wz1000> RedNifre_: If you want to write that function you would have to do some weird typeclass hackery
04:21:57 <RedNifre_> oh, right. I would need a class FmappableX a and instances for the various nestings.
04:21:58 <Cale> and type level naturals...
04:22:19 <Cale> and their corresponding singletons :)
04:22:23 <mauke> :t undefined :: 42
04:22:24 <lambdabot>     Expected a type, but ‘42’ has kind ‘GHC.TypeLits.Nat’
04:22:24 <lambdabot>     In an expression type signature: 42
04:22:24 <lambdabot>     In the expression: undefined :: 42
04:22:34 <mauke> oh, good
04:22:44 <wz1000> wut
04:23:15 <wz1000> It is not the answer to the life, the universe and everything after all :P
04:24:06 <wz1000> @theAnswer = undefined
04:24:06 <lambdabot> Unknown command, try @list
04:24:18 <kuribas> If anyone is interesting in font design or metafont, I started a new implementation in haskell: https://plus.google.com/u/0/communities/112347437114022289204
04:24:23 <wz1000> @let theAnswer = undefined
04:24:26 <lambdabot>  Defined.
04:24:49 <wz1000> > theAnswer == 42
04:24:51 <lambdabot>  *Exception: Prelude.undefined
04:25:20 <wz1000> @let (===) = const True
04:25:22 <lambdabot>  Defined.
04:25:33 <RedNifre_> hm, fmap2 = fmap . fmap doesn't compile for me.
04:25:33 <wz1000> > theAnswer === 42
04:25:34 <lambdabot>  Ambiguous occurrence ‘===’
04:25:34 <lambdabot>  It could refer to either ‘L.===’, defined at L.hs:171:1
04:25:34 <lambdabot>                        or ‘Test.QuickCheck.Property.===’,
04:25:34 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
04:25:34 <lambdabot>                           (and originally defined in ‘QuickCheck-2.7.3:Test.Q...
04:26:01 <wz1000> @let fmap2 = fmap . fmap
04:26:03 <lambdabot>  Defined.
04:27:20 <RedNifre_> I defined it in a file and loaded that file into ghci and it says that the type of the second fmap is ambiguous
04:27:51 <hexagoxel> fmap2 = fmap fmap fmap
04:28:22 <wz1000> @pl \n -> \f -> \x -> n (\g -> \h -> h (g f)) (\u -> x) (\u -> u)
04:28:23 <lambdabot> flip flip id . (flip .) . flip flip const . ((.) .) . (. ((flip id .) . flip id))
04:29:33 <wz1000> Seriously, is there no prettier implementation of the church predecessor in Haskell?
04:32:18 <vanila> wz1000, pred is difficult, that's the best shortest version
04:33:59 <Cale> > let zero f x = x; succ n f x = f (n f x); pred n = fst (n (\(x,y) -> (y,succ y)) (zero, zero)) in pred (succ (succ zero)) (+1) 0
04:34:02 <lambdabot>  1
04:34:26 <Cale> You can church encode the pairs too if you want
04:35:44 <RedNifre_> Now, wait a second. How can fmap2 = fmap . fmap be the same as fmap2 = fmap (fmap a) ? If I do fmap . fmap length IO (Just "text"), would that turn into fmap ( IO (length (Just "text"))) ?
04:36:08 <wz1000> @src (.)
04:36:08 <lambdabot> (f . g) x = f (g x)
04:36:21 <Cale> RedNifre_: Well, IO isn't a data constructor, perhaps you wanted return?
04:36:27 <Cale> RedNifre_: also, you forgot some parens
04:36:57 <Cale> (fmap . fmap) (return (Just "text"))
04:37:04 <Cale> er
04:37:07 <Cale> (fmap . fmap) length (return (Just "text"))
04:37:09 <Cale> there
04:37:29 <RedNifre_> > (fmap .fmap) length (return (Just "text"))
04:37:30 <lambdabot>  No instance for (GHC.Show.Show
04:37:31 <lambdabot>                     (f0 (Data.Maybe.Maybe GHC.Types.Int)))
04:37:31 <lambdabot>    arising from a use of ‘M184039996255547576021496.show_M1840399962555475760...
04:37:31 <lambdabot>  The type variable ‘f0’ is ambiguous
04:37:31 <lambdabot>  Note: there are several potential instances:
04:37:37 <RedNifre_> There, that is what I mean
04:37:42 <Cale> > (fmap . fmap) length (return (Just "text")) :: [Maybe Integer]
04:37:43 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘GHC.Integer.Type.Integer’
04:37:43 <lambdabot>  Expected type: [GHC.Types.Char] -> GHC.Integer.Type.Integer
04:37:43 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.Int
04:37:49 <Cale> > (fmap . fmap) length (return (Just "text")) :: [Maybe Int]
04:37:50 <lambdabot>  [Just 4]
04:38:07 <RedNifre_> > (\a -> fmap (fmap a)) length (return (Just "text"))
04:38:09 <lambdabot>  No instance for (GHC.Show.Show
04:38:09 <lambdabot>                     (f0 (Data.Maybe.Maybe GHC.Types.Int)))
04:38:09 <lambdabot>    arising from a use of ‘M458681929192538734521545.show_M4586819291925387345...
04:38:09 <lambdabot>  The type variable ‘f0’ is ambiguous
04:38:09 <lambdabot>  Note: there are several potential instances:
04:38:12 <wz1000> The first fmap lifts it to IO, and the second lifts it to Maybe
04:38:24 <Cale> Of course, it works with the IO action too, but we won't be able to see the result of the IO action without executing it, so using the bot would be awkward
04:38:52 <Cale> > (fmap . fmap) length (return (Just "text")) :: IO (Maybe Int)
04:38:53 <lambdabot>  <IO (Maybe Int)>
04:38:56 <zq> RedNifre_: it's just another possibility
04:39:08 <Cale> ^^ trust me, this is the IO action you wanted ;)
04:39:20 <zq> RedNifre_: using a monad transformer stack instead of hiding a monad inside a monad
04:39:42 <wz1000> > return "test" :: IO String
04:39:43 <lambdabot>  <IO [Char]>
04:40:03 <zq> RedNifre_: i wouldn't recommend that route unless you have an abundance of functions that return IO (Maybe a)
04:40:31 <Cale> Does anyone else find "monad transformer stack" a bit weird terminologically?
04:40:36 <RedNifre_> Hm.
04:41:12 <Cale> I might say something about a composite of monad transformers, or talk about a transformed monad...
04:41:27 <Cale> But somehow putting the word "stack" in there seems odd to me.
04:41:43 <zq> i guess you call em a pile of CDs, huh
04:41:49 <Cale> After all, we don't talk about stacks of functions being applied to an argument
04:42:13 <mauke> function composition stack :-)
04:42:16 <Cale> Does anyone refer to f (g (h x)) as a "function stack"?
04:42:25 <mauke> f . g . h maybe
04:42:59 <zq> Cale: that'd be a stack of functions applied on x
04:43:51 <Cale> Well, someone just spoke of MaybeT IO as a monad transformer stack
04:44:14 <Cale> When really, it's just one monad transformer being applied to a particular monad
04:44:26 <Cale> (I would just call it a monad)
04:44:44 <Cale> (Or I'd be more specific and call it what it is, MaybeT IO :)
04:45:50 <Cale> I suppose the fact that it's a monad that's been constructed as the result of a monad transformer is often useful to know, so perhaps "transformed monad" would make sense to emphasise that.
04:46:07 <wz1000> Cale: well, their is the call stack
04:46:13 <mr-> Especially since it is not guaranteed to be a monad.
04:46:17 <Cale> ... which is something we don't have in Haskell ;)
04:46:30 * hackagebot yesod-text-markdown 0.1.7 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.7 (ArashRouhani)
04:46:44 <wz1000> I know, but functions exist in other languages
04:46:45 <Cale> mr-: Well, it ought to be
04:46:55 <mr-> Cale: sure, but it may not be
04:47:20 <mauke> then you don't have a monad transformer
04:47:33 <Cale> mr-: It's really a terrible idea to write instances of MonadTrans that don't guarantee a monad. Unfortunately ListT still exists.
04:47:59 <mr-> Cale: Yeah, that's what I was refering to
04:48:16 <Cale> But I think it's better just to say that ListT isn't a monad transformer :P
04:48:27 <mr-> (Except I could not remember which transformer had that property :-)
04:49:41 <Cale> Some code exists which uses ListT, so it'll probably stick around for a while. Maybe it ought to be in its own package though.
04:49:43 <mr-> That's actually something that worries me a bit. I have never checked with transforers are actual transformers
04:49:58 <Cale> All the transformers are transformers except ListT
04:49:59 <mr-> s/with/which/
04:50:12 <Cale> I've proven the other ones are transformers in Coq
04:50:25 <Cale> (It was the first thing I did with Coq, actually :)
04:50:54 <Cale> Well, the ones in mtl anyway
04:51:26 <mr-> I was just about to ask if you've checked stuff like haskeline's runInputT :-)
04:51:35 <wz1000> Cale: What if I write my own non transformer monad transformer
04:51:58 <mr-> But I guess that one's also just a composition of mtl transformers
04:52:08 <Cale> mr-: It's constructed as a composite of ReaderT's, so it definitely is
04:52:32 <mr-> That provides a good argument to rely on mtl
04:53:30 <Cale> I bet they'd get much better performance if they only used one ReaderT
04:53:48 <Cale> But it probably doesn't matter much
04:54:09 <Cale> I've seen cases where hand-implementing a composite of monad transformers made code *much* faster
04:54:53 <Cale> But that was a while ago, and I don't know what new sorts of specialisation GHC might do now :)
04:59:15 <wz1000> how aggresively is (.) inlined?
05:01:52 <quchen_> wz1000: Well, it has an INLINE pragma
05:02:08 <quchen_> Which you should consider as a strong hint for the compiler to do the inlining
05:02:12 <wz1000> quchen_: Ah, thanks
05:02:21 <quchen_> wz1000: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#.
05:07:04 <akegalj> can I somehow derive Enum and get circular implementation of succ and pred so "data A = B | C" and "succ (succ B) == B"
05:07:30 <akegalj> or do i need to give my implementation of Enum for data A in this case?
05:08:17 <vanila> you have to implement it yourself
05:08:27 <akegalj> vanila: thanks
05:08:30 <vanila> I think this breaks the assumption of Enum though
05:08:45 <vanila> thats ok but it suggests you might be better to define your own function
05:08:54 <ski> isn't `toEnum (fromEnum n)' supposed to be `n', when `fromEnum n' is defined ?
05:11:54 <chaosfisch> Can I get this any shorter? distinct a b c d e = nub x == x where x = [a,b,c,d,e]
05:12:32 <quchen_> ski: Maybe. The Report says "It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int." For circular types, any value could be argued to be too large for an Int.
05:12:59 <quchen_> I feel like circular Enum is a bad thing, but I can't give a good reason.
05:13:07 <akegalj> vanila: yeah, i suppose enum isn't the proper case for this
05:13:21 <mauke> ap (==) nub [a,b,c,d,e]
05:15:46 <chaosfisch> mauke: like this? allDistinct a b c d e = ap (==) nub [a,b,c,d,e] ??
05:16:08 <quchen_> (==) should be transitive, so this should be solvable in linear time, no?
05:16:22 <mauke> chaosfisch: yes
05:16:39 <quchen_> Oh wait nevermind, brainfart
05:16:57 <exio4> allDistinct = (==) <*> nub
05:17:09 <exio4> or ap
05:17:18 <quchen_> ap(==)nub
05:17:44 <exio4> :p
05:18:37 <quchen_> And while we're talking about nub, don't use nub. https://github.com/quchen/articles/blob/master/fbut.md#nub
05:19:30 <chaosfisch> quchen_: Performance doesn't matter in this case, but thanks for the info.
05:19:42 <mauke> > nub [0 ..]
05:19:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:19:52 <mauke> not so terrible now, is it
05:20:28 <mauke> (ok, that's nub2)
05:22:26 <adamse> :t nub
05:22:27 <lambdabot> Eq a => [a] -> [a]
05:23:42 <quchen_> mauke: nub2?
05:24:54 <quchen> Anyway, for short lists nub is good enough, but once they become longer it's quite a performance sink.
05:25:28 <chaosfisch> I still don't understand how monad works. But okay - I'll accept it for now. Thanks for the help :)
05:25:31 <michi7x7> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:25:32 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:26:07 <vanila> > let fibs = 0 : 999 : zipWith (+) fibs (tail fibs) in fibs
05:26:08 <lambdabot>  [0,999,999,1998,2997,4995,7992,12987,20979,33966,54945,88911,143856,232767,3...
05:27:14 <michi7x7> is this [blabla ...] printing new?
05:27:15 <marvin-hh> According to the documentation of unsafePerformIO I cannot have a C function which reads a file and then writes that same file.
05:27:29 <marvin-hh> So, then what can one do with unsafePerformIO?
05:27:47 <marvin-hh> The documentation states that it might write the file first and then read it.
05:28:13 <vanila> > (++"...") . take 20 . show $ let fibs = 0 : 999 : zipWith (+) fibs (tail fibs) in fibs
05:28:15 <lambdabot>  "[0,999,999,1998,2997..."
05:28:25 <ski> > fix $ \lucas -> 2 : 1 : zipWith (+) lucas (tail lucas)
05:28:27 <lambdabot>  [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127...
05:29:12 <quchen> marvin-hh: unsafePerformIO should not do file reading and writing, ever. It's a function to make IO-using things pure when you can show that the function is indeed pure, but the compiler doesn't realize it on its own.
05:29:53 <quchen> https://github.com/quchen/articles/blob/master/fbut.md#unsafeperformio
05:30:10 <ski> marvin-hh : one should only use `unsafePerformIO act' when `act' conceptually behaves as `return x' for some value `x'
05:30:10 <marvin-hh> quchen: so, I am asking what you *can* do, then.
05:30:33 <ski> (and then it will evaluate to `x')
05:30:57 <marvin-hh> quchen: take for example sending a message via the network via some C library.
05:31:26 <marvin-hh> quchen: unsafePerformIO is often used to wrap C functions, right?
05:31:54 <quchen> unsafePerformIO is not used often, and every use should be checked very carefully. It's one of the highly dangerous functions around.
05:32:04 <marvin-hh> quchen: so, I am saying that given what unsafePerformIO states, it cannot really be used for *anything* useful.
05:32:30 <marvin-hh> quchen: can you give a useful application of unsafePerformIO?
05:33:07 <ski> doesn't bytestrings use it ?
05:33:34 <marvin-hh> ski: which primitive is it then that they use?
05:33:40 <marvin-hh> ski: I am asking for specifics.
05:33:49 <ski> or at least istr it used to (i don't know details well)
05:34:52 <ski> i distictly remember seeing something like that, where the construction operation allocated a memory area, and filled it with data, storing a pointer and an offset to it in the resulting value
05:34:52 <marvin-hh> ski: if the application of unsafePerformIO is to do things which have side-effects (like writing into a big chunk of memory), but those effects are not ordered, then it seems a rather useless function.
05:35:14 <ski> and the reading operations would dereference the pointer, and slicing would add to the offset
05:35:31 <mauke> writing to memory doesn't have observable effects if you're the only one with a pointer to that memory
05:35:35 <marvin-hh> ski: according to a strict reading of that documentation, that's not guaranteed to work.
05:35:49 <quchen> When you have a pure function (i.e. one that always returns the same result for the same input and doesn't observationally influence the environment), then it's OK to unsafePerformIO it.
05:35:53 <ski> the point here was that that memory area was never actually written to, after the initial construction, and so the operations were effectively pure
05:36:38 <quchen> An example of such a thing is a C function returning the pointer to a value. The pointer is semi-random (depending on how your C implementation mallocs), but the value it points to might be pure.
05:36:40 <marvin-hh> ski: there are still multiple 'effects' in the implementation of the malloc procedure.
05:36:55 <ski> marvin-hh : but are they observable ?
05:37:18 <marvin-hh> ski: where does it say that it has to be observable?
05:37:32 <marvin-hh> ski: GHC's documentation certainly doesn't say that.
05:37:43 <marvin-hh> ski: or well, http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO-Unsafe.html
05:38:37 <mauke> "If the I/O computation wrapped in unsafePerformIO performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to unsafePerformIO) is indeterminate."
05:38:38 <marvin-hh> It's really not such a difficult question; prove that you can do something useful in the language haskell + unsafePerformIO which you cannot do in Haskell.
05:38:55 <mauke> marvin-hh: why would I want to "prove" that?
05:39:11 <marvin-hh> mauke: well, perhaps you don't care.
05:39:15 <mauke> right
05:39:20 <mauke> also, plain haskell is turing complete
05:39:36 <marvin-hh> mauke: there is also this thing called "efficiency".
05:39:45 <mauke> is there?
05:40:03 <mauke> what model are you arguing in?
05:40:26 <mauke> also, how do you define "useful"?
05:40:32 <marvin-hh> mauke: and there is no theorem which says that everything which can be implemented in just the part of Haskell without ST can be as efficient as in let's say C.
05:40:49 <marvin-hh> mauke: useful, providing utility.
05:40:59 <mauke> C doesn't have efficiency
05:41:02 <mauke> it's a language
05:41:07 <marvin-hh> mauke: C++ then.
05:41:13 <mauke> C++ is also a language
05:41:15 <exio4> still the same
05:41:29 <marvin-hh> mauke: it has documented complexities for many functions.
05:41:38 <mauke> complexity isn't speed
05:41:50 <quchen> Breaking AES-256 is O(1)
05:41:50 <marvin-hh> ...
05:41:58 <mauke> all real computers have finite memory, so all inputs have constant size
05:42:03 <marvin-hh> Can you perhaps not be an ass?
05:42:07 <exio4> a 50billion loop is O(1)
05:42:12 <mauke> you first :-)
05:42:22 <quchen> I remember edwardk talking about asymptotic improvements in Lens by using unsafePerformIO. I imagine a lot of packages wrapping C libs use it.
05:42:59 <marvin-hh> What exactly is not clear about my question?
05:43:17 <mauke> what I said, basically
05:43:30 <mauke> also it's not a question
05:43:47 <phaazon> hey
05:43:48 <mauke> it comes across as rather aggressive
05:43:50 <marvin-hh> My question has an an answer a proof.
05:43:55 <phaazon> I launch a parser over IO (aeson)
05:43:57 <marvin-hh> as*
05:44:04 <phaazon> I’d like to compute the runtime performance
05:44:23 <phaazon> I take the time before the invokation of the parsing, another time juste after
05:44:27 <phaazon> and compare differences
05:44:41 <phaazon> the result is wrong, I guess because of lazyness
05:44:50 <phaazon> so, I get the second time with seq
05:45:14 <phaazon> st <- getTime; parsed <- parse… ; et <- seq parsed getTime
05:45:19 <quchen> marvin-hh: A compelling example I've heard on this channel is vegas algorithms, i.e. algorithms that gamble internally, but yield a deterministic result. In other words, the gambling is for efficiency, but not for correctness.
05:45:22 <phaazon> is there a more idiomatic way to do that?
05:45:26 <indiagreen> phaazon: please use criterion for benchmarking, it helps avoiding a great deal of mistakes
05:45:44 <phaazon> indiagreen: I load two files: one very small, one VERY big
05:45:52 <marvin-hh> quchen: if those use side-effects internally, those side-effects might happen in *any* order.
05:46:04 <phaazon> if I don’t use seq, the time differences it quite the same, which doesn’t make any sense
05:46:15 <marvin-hh> quchen: I doubt there is any algorithm with side effects doing something useful which can run in *any* order.
05:46:31 <phaazon> is it possible to write !parsed <- parse…, or that kind of stuff?
05:46:34 <phaazon> I don’t like seq…
05:46:34 <indiagreen> phaazon: seq only forces the constructor
05:46:35 <mauke> marvin-hh: why do you think they can happen in any order?
05:46:39 <phaazon> it sounds wrong
05:46:49 <indiagreen> e.g. if you `seq` an infinite list, it won't take infinite time
05:46:55 <indiagreen> you need deepseq
05:47:05 <quchen> marvin-hh: Random number generation can happen in any order for that matter
05:47:09 <marvin-hh> mauke: then the ->relative order<- in which those side effects take place (relative to the main I/O trunk, or other calls to unsafePerformIO) is ->indeterminate<-.
05:47:12 <phaazon> I don’t get it indiagreen
05:47:24 <phaazon> seq reduces the first argument to its whf, right?
05:47:31 <indiagreen> whnf, yeah
05:47:32 <mauke> marvin-hh: right. so it's fine if they're all in the same unsafePerformIO
05:47:36 <phaazon> n?
05:47:44 <indiagreen> weak head normal form
05:47:47 <phaazon> yeah
05:47:48 <phaazon> but why?
05:47:50 <marvin-hh> mauke: that's not what it says.
05:47:53 <phaazon> so
05:47:59 <phaazon> seq (1+2) b
05:48:03 <phaazon> it leaves 1+2 that way?
05:48:04 <mauke> marvin-hh: I think that's exactly what it says
05:48:08 <marvin-hh> mauke: it might be that that's what they mean.
05:48:10 <indiagreen> no, it evaluates it to 3
05:48:11 <mr-> marvin-hh: in "unsafePerformIO $ do {a; b; c;}", the actions a, b, c happen in the given order
05:48:22 <phaazon> and 3 is whf, not whnf, isn’t it?
05:48:30 <marvin-hh> mr-: that's not what it says.
05:48:34 <indiagreen> 3 is nf
05:48:35 <mauke> marvin-hh: why not?
05:48:39 <quchen> "If the I/O computation wrapped in unsafePerformIO performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to unsafePerformIO) is indeterminate."
05:48:53 <mr-> marvin-hh: the question is, WHEN does the action you've given to unsafePerformIO take place
05:48:56 <quchen> The parenthesis clarifies everything that might be in doubt to be honest.
05:49:06 <phaazon> I might have misunderstood that then indiagreen
05:49:13 <phaazon> what is (1+2) then?
05:49:15 <phaazon> whf?
05:49:32 <marvin-hh> It says that if some I/O computation performs "side-effects". So, unsafePerformIO $ do {a;b;} performs side-effects a and b, then ...
05:49:46 <marvin-hh> So, a and b can happen in any order.
05:50:03 <mauke> marvin-hh: that does not follow
05:50:08 <mr-> marvin-hh: No, it is not determined RELATIVE to the main I/O trunk
05:50:40 <mauke> marvin-hh: in fact, I don't understand how you're reading the description to come to that conclusion
05:50:43 <mr-> (at least that's how I've been using it. If that's wrong, please let me know :-)
05:50:50 <quchen> unsafePerformIO $ do {a; b; } is very close to doing a; b; in C.
05:50:51 <phaazon> oh
05:50:58 <phaazon> I can write !parsed <- parse…
05:51:00 <phaazon> perfect :)
05:52:15 <marvin-hh> mauke: Just because it's not determinate relative to X, doesn't mean the original order of the side-effects is preserved.
05:52:30 <mauke> marvin-hh: then why quote that statement at all?
05:52:38 <phaazon> deb [core    ] > parsing time: 0.000111s
05:52:43 <phaazon> deb [core    ] > parsing time: 1.936256s
05:52:45 <phaazon> sounds better :)
05:53:19 <marvin-hh> mauke: ok, that wasn't really needed, perhaps.
05:53:27 <mauke> marvin-hh: for example, you could just as well quote "unsafePerformIO is not type safe": that says nothing about the original order of side effects either!
05:53:48 <mr-> marvin-hh: what are you trying to achieve anyway? Unserstand unsafePerformIO, fix the documentation?
05:54:07 <marvin-hh> mr-: it would be nice if the documentation was written in a formal way.
05:54:24 <mauke> you can't "fix" the documentation because it's not really broken
05:54:31 <marvin-hh> mr-: I don't see what would so hard with providing a denotational semantics for this stuff.
05:54:41 <mauke> you might as well complain that it doesn't say that unsafePerformIO doesn't start the screensaver
05:54:48 <marvin-hh> mauke: it's broken in that it is underspecified.
05:54:52 <mr-> marvin-hh: Then this is not the proper venue. Get on the Libraries list and make a suggestion
05:54:58 * quchen enjoys documentation written for humans for he is one
05:55:53 <quchen> mauke: That would be a fun side effect.
06:00:57 <michi7x7> :t launchMissiles
06:00:58 <lambdabot> Not in scope: ‘launchMissiles’
06:01:04 <michi7x7> :/
06:01:33 * hackagebot unordered-containers 0.2.5.1 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.5.1 (JohanTibell)
06:01:54 <quchen> michi7x7: http://hackage.haskell.org/package/acme-missiles
06:02:39 <ski> @type unlaunchMissiles
06:02:40 <lambdabot> Not in scope: ‘unlaunchMissiles’
06:03:33 <michi7x7> quchen: yeah I know
06:03:51 <michi7x7> does lambdabot import Hackage modules?
06:04:03 <michi7x7> :let import Acme.Missiles
06:08:41 <phaazon> https://twitter.com/phaazon_/status/520924709685567488 for curious ;)
06:10:52 <michi7x7> @poll-show best-programming-language
06:10:52 <lambdabot> ["SNOBOL","COBOL","PHP","Coq","Agda","anything-else","Haskell"]
06:11:40 <MagneticDuck> !
06:12:52 <wei2912> the irony
06:13:08 <wei2912> or is that ordered from worst to best?
06:13:13 <michi7x7> phaazon: what are you doing? playing around with opengl?
06:13:38 <phaazon> michi7x7: nope
06:13:47 <phaazon> I write a scene engine for my demoscene purposes
06:13:56 <phaazon> here, it’s backended by OpenGL indeed
06:14:05 <phaazon> but you can plug any kind of backends you want
06:14:13 <phaazon> (OpenGL, CUDA, OpenCL, whatever)
06:17:43 <gigabytes> hello everybody
06:17:50 <gigabytes> still playing with the lens package
06:18:20 <gigabytes> I think it's time to understand prisms. So I have a data type that is a sum of a few alternative constructors
06:18:31 <gigabytes> with makePrisms I get a prism for every constructor
06:19:39 <deni> umm does hackage let me somehow search for packages that depend on a certain package?
06:20:25 <gigabytes> say that every constructor have a field of this same data type, so it's a kind of tree with different types of nodes (think about an AST). Now can I chain prisms/lenses together to traverse the data structure and get the content of all the nodes that match a particular constructor?
06:21:03 <gigabytes> for example, taking in a list all the leaves, or all the nodes of type And
06:21:19 <edwardk> gigabytes: the prism lets you get down to one constructor out of several
06:21:19 <gigabytes> (the content of a field of all those nodes, actually)
06:21:28 <edwardk> to get at all of the contents of the same type you need to write a traversal
06:21:38 <edwardk> since it may be distributed across several cases
06:22:06 <edwardk> you can view a lens as taking 'one side of a product or something isomorphic to it' and a prism as taking 'one side of a sum or something isomorphic to it'
06:22:09 <gigabytes> edwardk: hm ok. But how to do so?
06:22:30 <ski> hello, edwardk
06:22:48 <Haskellfant> deni: hackage itself doesn't but packdeps does http://packdeps.haskellers.com/reverse
06:23:05 <edwardk> gigabytes: myTraversal f (And a b) = And <$> f a <*> f b; myTraversal f (Negate a) = Negate <$> f a; myTraversal f otherStuff = pure otherStuff
06:23:22 <ski> edwardk : i realized a while ago right Kan extensions can sortof be thought of as providing "currying" for natural transformations
06:23:26 <edwardk> this is what plate does
06:23:27 <deni> Haskellfant: thanks.
06:23:41 <edwardk> ski: the right kan extension is curried functor composition
06:23:54 <edwardk> Compose f g ~> h   is isomorphic to f ~> Ran g h
06:24:06 <edwardk> replace Compose with (,) and Ran with (->) and you get currying
06:24:15 <edwardk> this is what i do in hask to talk about Ran
06:24:20 <ski> edwardk : anyway, i was wondering, if Kan extensions are adjoints of pre-partially-composed functors, what are adjoints of post-partially-composed functors ?
06:24:28 <gigabytes> edwardk: ah ok.. that sounds simple but also quite mechanical, isn't there something like makeLenses that does it?
06:25:05 <edwardk> ski: look at lifts
06:25:28 <ski> that's not in MacLane, is it ?
06:25:32 <gigabytes> edwardk: btw it is just an instance of Traversable, not anything lens-specific, right?
06:25:38 <edwardk> gigabytes: we have 'uniplate' and 'biplate' in Data.Data.Lens that can generate those automatically if you are just looking for a traversal and everything is tyeable
06:25:52 <edwardk> gigabytes: here we're walking down to immediate children not leaves
06:25:58 <edwardk> that was for something like
06:26:09 <edwardk> data Exp a = And (Exp a) (Exp a) | Negate (Exp a) | Var a -- or something
06:26:18 <edwardk> note the traversal walked the immediate descendants of And and Negate
06:26:25 <edwardk> but left the Var's alone
06:26:33 <edwardk> it can be used for stuff like
06:27:28 <edwardk> rewrite $ \case Negate (Var a) -> Just $ Var (-a); _ -> Nothing -- to eliminate all negated literals from the expression by negating the number underneath (if Var here is really like a literal number)
06:27:56 <gigabytes> edwardk: ok
06:28:03 <gigabytes> sounds good
06:28:18 <gigabytes> but say I need to collect all the literals that comes negated?
06:29:50 <edwardk> then you probably need to write something messier, or negate the syntax tree like that, then traverse the rewritten tree, since they are all now in the 'a's
06:42:24 <michi7x7> I've been playing a little with neural networks on sequence prediction (in my example a game of rock, paper, scissors): https://github.com/michi7x7/neuralnet/blob/master/src/Main.hs
06:42:55 <michi7x7> Works incredibly well on repeating sequences, but doesn't really work on player opponents :/
06:47:45 <Jeanne-Kamikaze> michi7x7, isn't that the point though ?
06:48:27 <michi7x7> Jeanne-Kamikaze: well, I was sort of hoping to find recurring patterns in human choices ^^
06:48:49 <Jeanne-Kamikaze> how many recurring patterns do you expect to find in rock paper scissors ?
06:49:26 <Jeanne-Kamikaze> it's not a game of intricate strategy
06:49:29 <michi7x7> Jeanne-Kamikaze: it's definitely not just rundom when you play human on human
06:49:51 <Jeanne-Kamikaze> street fighter would work better
06:50:07 <michi7x7> that's too hard to implement for me ^^
06:50:14 <Jeanne-Kamikaze> where the human repeats their favourite moves
06:51:17 <michi7x7> well, but you would have to combine a neural network with loads of "classic ai" to even implement basic moves
06:58:44 <lisbeth> any articles about what variadic means?
06:59:42 <int-e> Jeanne-Kamikaze: perhaps you would find this interesting: http://webdocs.cs.ualberta.ca/~darse/rsbpc.html ... note that the "optimal" random player is on rank 41; the programs are all about exploiting patterns in other programs (which in turn leads to meta-patterns to exploit and so on)
07:02:29 <Jeanne-Kamikaze> gues you learn something new every day
07:06:35 <hughfdjackson> this is a noobish question -
07:06:39 <hughfdjackson> oops, i meant to delete that
07:06:52 <hughfdjackson> but since i somehow it send instead of ctrl-k :/..
07:07:08 <hughfdjackson> the () type - how is that a stand-in for *any* given type?
07:07:25 <hughfdjackson> or am i misunderstanding?
07:07:52 <hughfdjackson> ah - don't spend your time answering that - found on stack overflow :)
07:08:57 <zq> hughfdjackson: mind clarifying what you mean by "stand-in"?
07:09:29 <catsup> how can i get a list of installed files for a cabal installed package?
07:09:53 <hughfdjackson> zq: :| I meant that any type inhabits () - like _|_
07:10:12 <hughfdjackson> but that's clearly wrong, reading this - it seems to just be the normal old Unit value
07:10:26 <hughfdjackson> well, Unit type + Unit constructor pair
07:13:12 <zq> hughfdjackson: also inhabited by undefined, technically
07:13:23 <wei2912> is there a function for checking if a digit is in a number?
07:13:52 <recursion-ninja> wei2912: Data.Char.isDigit ?
07:13:56 <hughfdjackson> zq: isn't undefined just an alias for _|_ ?
07:14:04 <hughfdjackson> (or is it the constructo for the _|_ type?)
07:14:09 <wei2912> recursion-ninja: thanks!
07:14:11 <recursion-ninja> hughdjackson: yep
07:14:14 <zq> catsup: possibly ghc-pkg describe <name of package>, which gives you library-dirs
07:14:26 <recursion-ninja> hughdjackson: that's my understanding
07:14:34 <hughfdjackson> recursion-ninja: okay, cool :) thanks
07:14:46 <recursion-ninja> > isDigit '5'
07:14:47 <lambdabot>  True
07:15:04 <recursion-ninja> > fmap isDigit "123abc"
07:15:05 <zq> hughfdjackson: _|_ is a type which in theory has no inhabitants; undefined is a value that inhabits every type (in haskell)
07:15:06 <lambdabot>  [True,True,True,False,False,False]
07:15:37 <zq> hughfdjackson: so no, undefined (a value) isn't an alias for _|_ (a type). not sure if a robotic answer l ikethis helps.
07:15:39 <hughfdjackson> zq: ooh - they're actually two different ends of the spectrum?  _|_ where no type can be inferred, undefined to match any type?
07:15:42 <wei2912> > any . fmap isDigit "123abc"
07:15:44 <lambdabot>  Couldn't match expected type ‘a -> a1 -> GHC.Types.Bool’
07:15:44 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
07:15:50 <ski> lisbeth : i suppose it means that different invocations of the same function can accept different number of arguments (while presumably giving the same type of result)
07:16:14 <ski> zq : "_|_ is a type" ?
07:16:19 <lisbeth> ski, I haven't talked in the channel in hours.
07:16:23 <wei2912> > any $ map isDigit "123abc"
07:16:24 <recursion-ninja> > any isDigit "123abc"
07:16:25 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
07:16:25 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
07:16:25 <lambdabot>  can't find file: L.hs
07:16:26 <lisbeth> I don't know what you are referring to
07:16:28 <zq> ski: did i confuse _|_ with Void?
07:16:45 <ski> lisbeth : less than half an hour : "<lisbeth> any articles about what variadic means?"
07:16:49 <wei2912> oh wait, misused `any`
07:16:50 <ski> zq : it seems so
07:17:02 <recursion-ninja> :t any
07:17:03 <lambdabot> (a -> Bool) -> [a] -> Bool
07:17:19 <ski> @type cont . flip any
07:17:20 <lambdabot> [a] -> Cont Bool a
07:17:37 <wei2912> :t isDigit
07:17:37 <hughfdjackson> ski, zq : well, i'll shelve this question for later - writing a parser calls !
07:17:38 <lambdabot> Char -> Bool
07:17:40 <zq> hughfdjackson: scratch what i said about _|_. undefined :: forall a. a is your only chance of representing _|_
07:17:46 <recursion-ninja> > any isDigit "123abc"
07:17:48 <lambdabot>  True
07:18:20 <wei2912> seems like the digit i want to test for isn't passed in?
07:18:31 <wei2912> oh wait
07:18:53 <recursion-ninja> > any isDigit "xyzabc"
07:18:54 <wei2912> recursion-ninja: i think you misunderstood my problem; i want to check if a specific digit is in a number, not if a number has a digit
07:18:55 <lambdabot>  False
07:19:39 <recursion-ninja> wei2912: check if a specific character is a digit in a string?
07:20:12 <wei2912> recursion-ninja: no, check if a specific digit is in a number. for example, 3 is in 34256234 but 1 isn't
07:20:28 <zq> ski: "In type theory, a theory within mathematical logic, the bottom type is the type that has no values. It is also called the zero or empty type, and is sometimes denoted with falsum (⊥)."
07:20:35 <recursion-ninja> wei2912: oh, I gotcha
07:20:40 <indiagreen> > '3' `elem` "342563234"
07:20:42 <lambdabot>  True
07:20:43 <recursion-ninja> wei2912: there is a package for that
07:20:44 <zq> ski: it's really not cool when haskell improvises its own terminology
07:20:57 <recursion-ninja> wei2912: Data.Digits I think
07:21:00 <wei2912> indiagreen: seems like conversion from int to string is required
07:21:04 <wei2912> recursion-ninja: let me take a look, thanks!
07:21:15 <ski> zq : yes, but this other sense of `_|_' comes from domain theory (denotational semantics)
07:21:32 <indiagreen> wei2912: conversion to String is actually fast, you don't need a specific package
07:21:38 <indiagreen> it's `read` that's awfully slow
07:21:45 <ski> zq : so it's `Void' that's improvised, not `_|_'
07:21:59 <catsup> zq: describe doesn't list files :/
07:21:59 <recursion-ninja> :t flip any Data.Digits.digits
07:22:00 <lambdabot> Not in scope: ‘Data.Digits.digits’
07:22:20 <zq> catsup: it gives you the directory containing library files
07:22:22 <recursion-ninja> import Data.Digits
07:22:30 <bennofs> @let import Data.Digits
07:22:31 <lambdabot>  .L.hs:78:1:
07:22:31 <lambdabot>      Failed to load interface for ‘Data.Digits’
07:22:31 <lambdabot>      Perhaps you meant
07:22:31 <lambdabot>        Data.DList (from dlist-0.7.0.1)
07:22:31 <lambdabot>        Data.Bits (from base)
07:22:54 <catsup> zq: yes i know what it gives
07:23:24 <zq> catsup: which other files did you want to list?
07:23:30 <catsup> zq: the installed files
07:27:05 <zq> catsup: what exactly do you anticipate (installed files) - (library files) to be?
07:27:19 <recursion-ninja> wei2912: you there?
07:27:38 <wei2912> recursion-ninja: yes
07:27:57 <wei2912> how do i convert an integer into a list of digits?
07:27:57 <nshepperd> well, undefined :: Void, so in a way it makes sense to call both things ⊥. ⊥ (the value) proves ⊥ (the type / proposition)
07:28:26 <recursion-ninja> wei2912: you could use: containsDigit n m = elem n $ show m
07:28:41 <recursion-ninja> wei2912: but n would have to be the char representation of the digit
07:28:54 <recursion-ninja> wei2912: or you could import Data.Digits
07:29:16 <recursion-ninja> wei2912: and then you could use: containsDigit n m = elem n $ digits 10 m
07:29:18 <catsup> zq: library _dirs_ /= library _files_, plus of course, executables can also be installed
07:29:37 <recursion-ninja> wei2912: in the second one n & m are both Ints
07:30:03 <zq> catsup: so, ls?
07:30:35 <recursion-ninja> wei2912: containsDigit n m = elem n $ show m :: Show a => Char -> a -> Bool
07:31:00 <nshepperd> iirc cabal doesn't track installed files for some reason
07:31:03 <recursion-ninja> wei2912: containsDigit n m = elem n $ digits 10 m :: Integral a => a -> a -> Bool
07:31:07 <wei2912> recursion-ninja: thanks!
07:31:27 <recursion-ninja> wei2912: use which ever method you think is better
07:32:01 <catsup> zq: do i really need to explain why that's not the same thing?
07:32:33 <spopejoy> gmorning. any HList wizards around? I'm wondering if there's a way to fix a value-type to a label ...
07:32:47 <zq> catsup: feel free. though executables would be a bit tougher.
07:33:25 <catsup> zq: feel free?  i'm not asking for permission, it's something i don't _want_ to do
07:34:12 <zq> meh
07:34:48 <nshepperd> if only cabal was a package manager
07:34:56 <recursion-ninja> if olny...
07:35:46 <geekosaur> I should dig out my last explanation of this from my channel logs and blog it somewhere...
07:36:25 <spopejoy> i wonder if go's approach for package/lib management makes sense. sandboxes seem too difficult ...
07:36:27 <geekosaur> (tl;dr: making cabal a real package manager means taking package management functionality away from ghc-pkg, and this makes ghc extremely cranky)
07:36:33 <wei2912> how do i get all elements of a list that isn't in another list? for example, f [1, 2] [1..9] should give [3, 4, 5, 6, 7, 8, 9]
07:36:48 <zq> no but really, i don't get what the guy wants
07:36:52 <geekosaur> :t (Data.List.\\)
07:36:53 <lambdabot> Eq a => [a] -> [a] -> [a]
07:37:01 <geekosaur> bah, not shown in the type...
07:37:09 <mauke> > [1 .. 9] \\ [1, 2]
07:37:11 <recursion-ninja> that is the Set Difference operation
07:37:11 <lambdabot>  [3,4,5,6,7,8,9]
07:37:23 <wei2912> i see, thanks!
07:37:23 <zq> where else would the relevant *.hi, *.so be stored if not within the library dirs
07:37:27 <bennofs> > [1,1] \\ [1]
07:37:27 <wei2912> i didn't know what it was called
07:37:29 <lambdabot>  [1]
07:37:32 <recursion-ninja> geekosuar correctly pointed out the (\\) operator
07:37:37 <bennofs> > [1,2,1] \\ [1]
07:37:38 <lambdabot>  [2,1]
07:37:45 <mauke> > "hello" \\ "world"
07:37:46 <lambdabot>  "hel"
07:38:07 <spopejoy> life in hel
07:38:13 <bennofs> > [1,2,3,1] \\ [2,1]
07:38:15 <lambdabot>  [3,1]
07:38:23 <nshepperd> you can't just give cabal the ability to undo whatever it did when it installed something?
07:38:53 <spopejoy> is there an alternative to cabal, such that one directly uses ghc-pkg?
07:39:17 <bennofs> spopejoy: the nix pkg manager does that
07:39:41 <bennofs> spopejoy: it only uses the Cabal library, not cabal-install
07:39:47 <spopejoy> neat
07:40:55 <recursion-ninja> you can "strong arm" cabal by using -constraint packagename==versionNumber when installing a new package to ensure that it links to the other package versions you want
07:40:59 <Cale> There's also filter (`notElem` ys) xs, which is a little different (and if you're going to do that, probably better to convert ys to a Data.Set)
07:42:32 <spopejoy> bennofs: any reflections on using nix to hack haskell?
07:43:00 <recursion-ninja> Cale, wei2912: I think he will have duplicate elements, I'm not sure if he wants to preserve the duplicates. If so, Data.Set isn't apropriate. He'll have to decide...
07:44:48 <int-index> Can anyone help me with lens?
07:44:58 <int-index> I need to perform a monadic action in state
07:45:07 <int-index> What I'm doing now is
07:45:20 <int-index> use LENS >>= ACTION >>= (LENS .=)
07:45:23 <recursion-ninja> int-index: Brent Yorgey should be able to walk you through it
07:45:38 <int-index> There should be a beautiful way to do it.
07:45:50 <int-index> I tried to use zoom/magnify, but didn't figure out how to.
07:46:38 * hackagebot multiarg 0.28.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.28.0.0 (OmariNorman)
07:47:16 <Fuuzetsu> recursion-ninja: is iterative ninja your nemesis?
07:47:20 <spopejoy> there isn't a monadic version of 'over'?
07:47:44 * mauke is now known as iteration-pirate
07:48:08 <int-index> spopejoy, the lens itself is a monadic over
07:48:36 <bennofs> spopejoy: Well, I use it myself and like it a lot (I can use binary cache so I don't need to compile most haskell packages myself! saves a lot of time [only works for GHC 7.8.3]). To enable nix support in any haskell project, it is enough to just drop a generic default.nix in the root directory (=> you don't need to keep that up to date, it is generic. This also means I don't have to put it into VCS). I have
07:48:38 <bennofs> some shell scripts that make working with it easier (such as running cabal repl inside an environment where all deps are installed). A problem of this setup is that you can't use GHC-mod (because it doesn't support nix-like sandboxes), but if you use emacs, you can configure haskell-mode to use a custom GHCi command that supports nix.
07:48:52 <cinimod> Suppose I have a type family
07:49:27 <spopejoy> bennofs: root directory of project, or / ?
07:49:33 <cinimod> type family F (x :: Nat) (y :: Nat) :: (Nat, Nat) where
07:49:33 <cinimod>   F x y = '(x, y)
07:49:33 <cinimod>  
07:49:38 <bennofs> spopejoy: root of project.
07:49:40 <cinimod> then
07:49:41 <spopejoy> phew
07:49:51 <cinimod> :t Proxy :: Proxy (F 1 2)
07:49:52 <lambdabot> Not in scope: type constructor or class ‘F’
07:49:58 <cinimod> Proxy :: Proxy (F 1 2) :: Proxy '(1, 2)
07:50:06 <cinimod> which is what you would hope
07:50:09 <spopejoy> bennofs: i'm interested, mainly b/c I need to deploy haskell as standalone as possible
07:50:16 <int-index> spopejoy, if I need to perform a monadic action with a lens, I just apply that lens to the action. If I need to apply a simple action inside the State monad, I use the (%=) operator which is basically the State-version of %~
07:50:24 <cinimod> But now I want to map over lists at the type level
07:50:27 <int-index> but if I need to perform a monadic action inside State, what do I do?
07:50:34 <cinimod> So I can define another type family
07:50:43 <cinimod> type family ZipWith (f :: a -> b -> c) (as :: [a]) (bs :: [b]) :: [c] where
07:50:44 <cinimod>   ZipWith f (a ': as) (b ': bs) = (f a b) ': (ZipWith f as bs)
07:50:44 <cinimod>   ZipWith f as        bs        = '[]
07:50:44 <cinimod>  
07:50:46 <int-index> I need %= which accepts not (a -> a), but (a -> m a)
07:51:33 <bennofs> spopejoy: if you have a default.nix, all you need to do to build a haskell project is nix-build in the project root (needs nix installed). Then, the exe will be in result/bin/<your exe name> (result will contain all files of the exe, such as result/share, ...)
07:51:34 <int-index> So the best I came up with is `use LENS >>= ACTION >>+ (LENS .=)`
07:51:42 <cinimod> But :t Proxy :: Proxy (ZipWith F ('[1,2]) ('[3,4]))
07:51:44 <cinimod> gives
07:52:00 <cinimod> roxy :: Proxy (ZipWith F ('[1,2]) ('[3,4])) :: Proxy '[F 1 3, F 2 4]
07:52:23 <cinimod> Why doesn't e.g. F 1 3 get replace by '(1,3)?
07:53:33 <spopejoy> int-index: you come with a question but instead end up educating me :)
07:55:10 <bennofs> int-index: that's called traverseOf
07:55:56 <notdan> Are there any ghc-7.10 docs online?
07:56:06 <bennofs> int-index: Simple type: traverseOf :: Applicative f => Lens s t a b -> (a -> f b) -> s -> t
07:56:40 <bennofs> int-index: or hmm, your using state. that might not be what you want.
07:56:57 <spopejoy> anyone on my HList question? I'd like to "lock down" the value type of a label
07:59:57 <int-index> bennofs, if not for the state, I'd just use the lens itself
08:01:11 <spopejoy> int-index: swinging for the fences here, but is the monad in state free?
08:01:32 <bennofs> int-index: I don't think there exists such a function in lens. The problem is that it would use the lens multiple times (once for setting and once for getting), which most (all?) of the other combinators don't.
08:02:41 <recursion-ninja> how can I upgrade the Haskell platform on a Debian Linux system so that I'm using GHC 7.8.3+ ?
08:03:31 <int-index> spopejoy, I have a simple StateT outer-something (Reader inner-something) () monad stack
08:03:49 <bennofs> int-index: if state defined a modifyM :: Monad m => (a -> m a) -> StateT a m (), then you could write it as   modifyM $ yourLens yourModifier
08:04:02 <indiagreen> and modifyM is simply (get >>=)
08:04:35 <indiagreen> wait, or is it for State and not StateT
08:04:37 <bennofs> indiagreen: no, it's \f -> get >>= lift f >>= put
08:04:50 <indiagreen> ouch, darn, right
08:04:59 <bennofs> :t StateT
08:04:59 <lambdabot> (s -> m (a, s)) -> StateT s m a
08:05:18 <bennofs> :t \f -> StateT (fmap ((),) . f)
08:05:19 <lambdabot> Functor m => (s -> m s) -> StateT s m ()
08:05:37 <int-index> bennofs, that's basically what I'm doing right now, only more compositional
08:06:02 <int-index> I was looking for an idiomatic solution, and apparently it doesn't exist
08:06:17 <int-index> thanks anyway
08:06:58 <bennofs> I just wonder, maybe StateT should provide modifyM? It looks quite useful to me. Does it already exist under a different name?
08:07:47 <int-index> bennofs, ekmett says it shouldn't exist in a reddit comment
08:07:54 <int-index> http://www.reddit.com/r/haskell/comments/14es0h/statet_modifym/
08:07:59 <int-index> for safety reasons
08:09:36 <wei2912> how do i get all the permutations of k ints from a list of n ints?
08:10:08 <wei2912> i looked at http://hackage.haskell.org/package/permutation-0.5.0.4/docs/Data-Permute.html but `listPermute 3 [1..9]` fails
08:13:21 <dfeuer> > :t listPermute
08:13:23 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:13:28 <dfeuer> :t listPermute
08:13:29 <lambdabot> Not in scope: ‘listPermute’
08:14:18 <dfeuer> wei2912, that's not what listPermute is for.
08:16:20 <dfeuer> wei2912, in fact, nothing in that package looks like it's what you want.
08:17:17 <wei2912> dfeuer: hmm. what would be what i want? :)
08:17:59 <asfp> How can I say that two types are the same in a constraint?  Example, I have  class T and subclasses A and B:  class T t where { type X t :: *;  type X t = Int} and instance T a => A a ... and instance T b => B a ....   Then I have the type  f :: (A a, B b) => X a -> X b -> X a (or it could be X b).   I want to say that X a = X b must be the same type in the type for function f.
08:18:35 <dfeuer> You probably want to do something simple like concatMap permutations . filterM (const [False,True])
08:18:50 <dfeuer> wei2912, that filterM magic is a powerset function.
08:19:25 <dfeuer> asfp, I don't know much about such things, but try (X a ~ X b)
08:19:30 <wei2912> you're right, that looks like magic to me
08:20:42 <wei2912> dfeuer: what does `filterM (const [False, True])` do?
08:20:43 <asfp> dfeuer: thanks.  I was searching for this all over, but just after asking I found https://www.haskell.org/ghc/docs/7.4.2/html/users_guide/equality-constraints.html  which seems to agree with what you say.
08:21:27 <wei2912> i haven't done monads yet
08:21:52 <dfeuer> wei2912, it's about the list monad.
08:22:10 <dfeuer> Let me see if I can think of an expression of that concept that's at all easier.
08:22:22 <wei2912> alright, thanks
08:24:50 <cinimod> I have posted my question here: http://stackoverflow.com/questions/26316233/why-dont-all-types-get-expanded
08:26:30 <smithing> If someone wants to Shell|psy|znc services send me a query and you dare the information :D
08:26:40 * hackagebot nested-sets 0.0.1.1 - Nested set model implementation  http://hackage.haskell.org/package/nested-sets-0.0.1.1 (rakatan)
08:27:33 <smithing> If someone wants to Shell|psy|znc services send me a query and you dare the information :D
08:27:59 <int-e> @where ops
08:28:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:28:48 <dfeuer> wei2912, another way to express exactly the same thing is  powerset [] = [[]]; powerset (x:xs) = [if includeX then x:ys else ys | includeX <- [False,True], ys <- powerset xs]
08:28:49 --- mode: ChanServ set +o Cale
08:28:56 --- kick: smithing was kicked by Cale (smithing)
08:29:01 --- mode: Cale set +b *!*@201.209.74.191
08:29:01 --- kick: smithing was kicked by Cale (smithing)
08:29:10 --- mode: Cale set -o Cale
08:32:50 <wei2912> dfeuer: must go, night. i will take a look at what you wrote another day. thanks!
08:43:19 <asfp> If I have class A a ... and class B b, what does the constraint A a ~ B b mean?
08:44:46 <ski> hm, i suppose it would mean that those two constraints are equal
08:45:52 <Cale> asfp: Does that even kind-check? I suppose it might :)
08:46:41 * hackagebot gtk-largeTreeStore 0.0.1.0 - Large TreeStore support for gtk2hs  http://hackage.haskell.org/package/gtk-largeTreeStore-0.0.1.0 (rakatan)
08:50:12 <ab9rf> i'm feeling a bit braindead today
08:50:24 <ab9rf> surely there's a more elegant way to do http://lpaste.net/112444
08:50:57 <ab9rf> i plead both coffee deprivation and offspring interference
08:52:06 <asfp> Cale: I wrote something like that, and it compiled.  I'm not sure what it meant though.
08:52:29 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength = uncurry (fmap . (,))
08:52:31 <lambdabot>  Defined.
08:52:54 <ski> > strength `map` [(0,Nothing),(1,Just 2)]
08:52:56 <lambdabot>  [Nothing,Just (1,2)]
08:53:18 <ski> ab9rf ^
08:53:54 <ab9rf> ski: interesting
08:53:57 <asfp> So I had class Types a where { type X a; type Y a ..} and  class Types a => A a ...  class Types a => B b... and the constraint f :: (A a, B b, Types a ~ Types b) => ...  What I wanted to say was something like (A a, B b, X a ~ X b, Y a ~ Y b, ...) => ...  .  Maybe that is what it means, maybe not .. :-)
09:03:30 <Noinia> Is there a way to construct a data type that has a kind as a parameter
09:04:39 <Noinia> i.e. something like: data Foo (k :: BOX) where FooStar :: Foo * ; FooNat :: Foo 1
09:04:53 <Noinia> err FooNat :: Foo Nat
09:26:37 <peter`> Hi all, newbie here... Can I ask a simple question?
09:26:56 <kadoban> Of course
09:27:22 <BMeph_> peter`: In fact, you're doing it...RIGHT NOW! ;)
09:28:29 <peter`> :-) If I have a concrete data type, say TA = A [Int], is there a way to apply a function, e.g., length to it without deconstructing (I guess something like fmap does)?
09:29:02 <vanila> if you have  data TA a = A [a]
09:29:12 <peter`> yes
09:29:14 <vanila> then it's a functor and yo could fmap TA Int -> TA whatever
09:29:16 <exio4> I'd implement a functor instance, and then use fmap?
09:29:39 <augur> no peter`, vanila that wont work
09:29:52 <augur> you dont want to use fmap, it's not relevant
09:29:53 <RedNifre> Hm, I'm doing something wrong. I have a lot of issues with converting between String, Bytestring, Lazy ByteString, Internal ByteString, Lazy Internal ByteString ...
09:30:08 <augur> what peter` wants is to use Newtype isomorphisms for free
09:30:09 <peter`> I tried to implement a functor instance, but the compiler tells me that does not work for A because it's just *, not * -> *
09:30:42 <RedNifre> How to handle all these functions that take or return all kinds of Strings?
09:30:47 <augur> the answer to your question, peter`, is that there is no way to use newtype isomorphisms for free. you have to explicitly wrap and unwrap
09:31:00 <peter`> I see, thank you!
09:31:03 <augur> or define a function that does this, eg lengthTA
09:31:26 <peter`> That's what I was doing, but it seems a little tedious.
09:31:53 <peter`> Maybe I should reconsider the choice of data A = A [Int] -> type A = [Int]
09:32:38 <augur> haskell could probably define some type class Newtype, with wrap and unwrap methods, and then a function defined as like...  appropriately :: Newtype a b => (a -> r) -> b -> r
09:32:52 <augur> appropriately length someTA
09:32:53 <hexagoxel> or data A = A { unTa :: [Int] }. "length.unTa" is rather short
09:33:40 <augur> also, peter`: you should use newtype precisely when you want to have a different mental "spin" on a particular implementation
09:34:09 <peter`> I see. That makes sense.
09:34:54 <peter`> Thank you very much again...
09:34:58 <peter`> Bye.
09:35:39 <augur> RIP buffer :(
09:35:42 <notdan> augur: I believe there is such a class in lens
09:36:06 <notdan> It's called `Wrapped' actually
09:36:08 <notdan> @src Wrapped
09:36:08 <lambdabot> Source not found. Maybe you made a typo?
09:36:17 <augur> notdan: yeah, i could imagine there is
09:36:44 <augur> @hoogle wrapped
09:36:46 <lambdabot> Control.Applicative newtype WrappedArrow a b c
09:36:46 <lambdabot> Control.Applicative newtype WrappedMonad m a
09:41:46 <ab9rf> ski: now that i've had a chance to caffeineate, that makes sense.  thanks.
09:43:39 <nitrix> Hi, what's the difference between a Data.Map and a Data.Map.Lazy ?
09:43:46 <nitrix> When is one favorable over the other?
09:44:08 <ab9rf> nitrix: you want a lazy map when you might never evaluate the entire map
09:44:49 <nitrix> ab9rf: What if my keys are strings and values records with couple strings and 2-3 reference to functions?
09:44:52 <ab9rf> say you're reading a data structure that has many elements, only some of which you care about
09:45:21 <ab9rf> you can insert them into a lazy map and only access the ones you need (i use this in the minecraft NBT parser i'm fooling around with)
09:45:45 <ab9rf> nitrix: keys are always forced, obviously.  strict maps force the values, lazy maps don't.
09:46:22 <nitrix> ab9rf: I see, so in my case, the values are records with just a bunch of functions, that should be perfectly fine strict?
09:46:36 <ab9rf> which means a strict map will evaluate the value at insert, but a lazy map will return an unevaluated thunk on lookup
09:47:12 <nitrix> Right.
09:47:14 <nitrix> Okay.
09:47:16 <ab9rf> nitrix: the main consideration is whether you anticipate whether you will eventually look up every value, or if you expect only to use some of them.
09:47:27 <kadoban> IME I usually want the scrict map though, for the same reason that foldl' is a better default than foldl
09:47:31 <nitrix> I'll defnitively need all of them.
09:47:41 <ab9rf> if you only expect to use some of them, a lazy map will defer evaluation indefinitely of the values not needed
09:47:55 <ab9rf> if you expect to use all of them, a strict map will use less memory
09:48:12 <nitrix> ab9rf: Right. Out of curiosity, what happens to lazy maps once they evaluate the thunk? does it keeps the result?
09:48:35 <ab9rf> nitrix: the unevaluated thuink is replaced in the map with the evaluation result when it gets evaluated
09:48:47 <ab9rf> nitrix: haskell never evaluates the same thunk more than once
09:48:59 <nitrix> Nice to know. Appreciated.
09:49:27 <geekosaur> "usually"
09:49:31 <nitrix> ab9rf: Wait, so IO functions are thunks that generates more thunks?
09:49:40 <geekosaur> (there's a corner case with threads)
09:50:25 <ab9rf> nitrix: i'm not sure how to respond to that, i'm fairly sure it's not exactly correct but i'm not sure hbow to explain what is really going on.
09:50:44 <nitrix> It's probably beyond the scope of the language anyway, I was just curious.
09:51:02 <geekosaur> evaluation and execution are different things, if I understand your question
09:51:11 <ab9rf> IO functions are state transformers, they take an IO state and return a new different IO states
09:51:35 <geekosaur> within Haskell you can evaluate a thuunk to produce an IO action; this is not really a thunk, it's better thought of as a packaged command to an I/O executive
09:51:35 <ab9rf> (which may contain inside it a thunk, which is by default unevaluated)
09:51:37 <ski> ab9rf : np
09:51:52 <geekosaur> which will only be executed if it becomes part of the value of main :: IO a
09:51:53 <ab9rf> ski: i tend to forget about uncurry
10:13:28 <nitrix> I feel like Haskell is making me smarter ;-;
10:31:45 * hackagebot timeplot 1.0.27 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.27 (EugeneKirpichov)
10:35:52 <phaazon> is it possible for a theoretical gui not to use any callbacks?
10:35:59 <phaazon> I’m pissed of callbacks
10:36:45 <augur> phaazon: all GUIs use callbacks in one way or another.
10:37:08 <augur> anything with IO, in fact.
10:37:23 <RedNifre> how do I uninstall a package with cabal?
10:38:07 <indiagreen> RedNifre: you can't. You can only do ghc-pkg unregister <package name> to remove it from the database of installed packages
10:38:23 <indiagreen> well, and then you can remove the files, but cabal won't help you with that
10:39:06 <gigabytes> guys, is there some module that provides a safe head function?
10:39:16 <gigabytes> that returns Nothing if the list is empty
10:39:22 <phaazon> augur: yeah
10:39:35 <mauke> @hoogle [a] -> Maybe a
10:39:37 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
10:39:37 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:39:37 <lambdabot> Prelude head :: [a] -> a
10:39:38 <phaazon> so you think designing a GUI over IO needs callback?
10:39:41 <benzrf> there should be a function that converts partial funcs to Maybe funcs!!!
10:39:44 <benzrf> ( ͡° ͜ʖ ͡°)
10:39:50 <indiagreen> there is one
10:39:57 <indiagreen> “spoon” or something
10:40:00 <mauke> gigabytes: listToMaybe
10:40:15 <RedNifre> never mind, cabal init guessed that the new version of my library depends on the old version. I removed that weird dependency and was able to install.
10:40:19 <gigabytes> mauke: the name doesn't sound well
10:40:33 <lifter> test
10:40:37 <benzrf> lifter: test
10:40:50 <lifter> thx
10:40:59 <indiagreen> @hayoo spoon
10:40:59 <lambdabot> Unknown command, try @list
10:41:00 <gigabytes> but it is the one
10:41:11 <phaazon> partial functions to Maybe?
10:41:13 <phaazon> why so?
10:41:31 <benmachine> gigabytes: I agree, it's a rubbish name
10:41:45 * hackagebot hackernews 0.2.2.2 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.2.2.2 (DavidJohnson)
10:41:50 <phaazon> how would you call that?
10:42:01 <RedNifre> maybeHead
10:42:01 <phaazon> I think it’s staight-forward, so fair enough
10:42:11 <gigabytes> @hoogle Maybe -> Map.Map
10:42:12 <chaosfisch> Is there any good site to learn how some of these Monad functions work?
10:42:12 <lambdabot> Parse error:
10:42:12 <lambdabot>   Maybe -> Map.Map
10:42:12 <lambdabot>                ^
10:42:20 <gigabytes> @hoogle Maybe -> Map
10:42:21 <lambdabot> Did you mean: Maybe a -> Map a a
10:42:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:42:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:42:30 <phaazon> chaosfisch: source code ;)
10:42:34 <gigabytes> oh god
10:42:37 <chaosfisch> ap (==) nub [a,b,c,d,e]
10:42:44 <gigabytes> @hoogle Maybe a -> Map k a
10:42:45 <lambdabot> Data.Map.Lazy singleton :: k -> a -> Map k a
10:42:45 <lambdabot> Data.Map.Strict singleton :: k -> a -> Map k a
10:42:45 <lambdabot> Data.Map.Lazy deleteAt :: Int -> Map k a -> Map k a
10:44:45 <chaosfisch> phaazon: oh, you wanted to say: "Read the haskell source code, this will show how it works" and you didn't want my actual source code that I'm trying to understand :D?
10:44:47 <ReinH> @hackage safe
10:44:47 <lambdabot> http://hackage.haskell.org/package/safe
10:44:57 <ReinH> gigabytes: ^
10:45:02 <Twey> If I have in scope (with ScopedTypeVariables) a type ‘a’ and a constraint ‘Typeable a’, and I know from typeOf that a = Foo b for some ‘b’, can I get the type ‘b’ in scope?
10:45:09 <ReinH> Also you can message lambdabot directly
10:45:24 <johnw> Twey: do you have some example code?
10:45:27 <johnw> ReinH: hello!
10:45:35 <gigabytes> ReinH: interesting, thanks!
10:45:35 <ReinH> johnw: o/
10:45:43 <johnw> ReinH: how's professional Haskell life?
10:45:48 <gigabytes> ReinH: yes, sorry for the noise
10:45:48 <ReinH> johnw: pretty good!
10:45:58 <ReinH> gigabytes: no worries
10:46:03 <Twey> Equivalently: 1) can I bring some unknown type into scope, knowing only its TypeRep?  2) can I use Typeable to cast to a type that is only partially known?
10:46:09 <Twey> johnw: I'll write up a MWE
10:48:47 <bluebelle> What do you do if you have 10 cases in case of expression, 9 is something -> return something and 1 is something -> something?
10:49:14 <johnw> bluebelle: I don't really follow
10:50:08 <bluebelle> Basically, I can't group it to "return $ case something of { foo -> goo; hoo -> loo; }"
10:50:20 <johnw> ah, I see
10:51:56 <simpson> bluebelle: That's fine; case statements are allowed at the top level of do-notation.
10:52:44 <benmachine> bluebelle: there's no general solution, I'm afraid
10:52:53 <benmachine> if nine are the same and one is different that is just the way it is
10:53:24 <benmachine> of course, some specific cases will have specific tricks you can do
10:54:13 <phaazon> I wonder whether it’s possible to design an interruption-capable program without callbacks
10:55:33 <benmachine> Twey: seems to me that your code will by necessity typecheck even when a ≠ Foo b, because although Typeable can't lie anymore, the typechecker doesn't know that
10:56:47 <Saizan> you can cast and handle the Nothing case, and to bring unknwown types into scope you do something with higher-rank polymorphism or existentials
10:56:55 <bluebelle1> benmachine: alright, thanks
10:57:41 <benmachine> bluebelle1: I mean, I'm always hesitant to say "it can't be done", the best I can promise is "I don't know of any way to do that, and I know most of the simple ways of doing things"
10:58:43 <ClaudiusMaximus> case foo of specialcase -> bar ; _ -> return $ case foo of regularcase -> baz ; othercase -> quux ; ...
10:59:16 <mauke> but that means the second case is partial
10:59:36 <benmachine> ClaudiusMaximus: good idea, but mauke's objection is also good
10:59:45 <k00mi> phaazon: you can have an interrupt handler that writes to a pipe, then integrate that pipe into your normal event loop
10:59:58 <benmachine> plus, you're adding a fair bit of noise to prevent not much noise
11:01:07 <lisbeth> ok here's my thoughts after thinking about a haskell shell then sleeping on it for two hours
11:01:25 <Twey> johnw, benmachine: http://lpaste.net/7382270976131596288
11:01:25 <lisbeth> the shell "hell" is a haskell environment which acts similar to bash shell and uses bash binaries as commands
11:01:41 <lisbeth> so I am definitely doing that rather than re-writing a whole environment
11:01:51 <mauke> "bash binaries" :-(
11:02:03 <johnw> Twey: and just "cast" doesn't work?
11:02:04 <lisbeth> *if I am not b-s-ing*
11:02:15 <Twey> :t cast
11:02:16 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
11:02:17 <lisbeth> that is a condition to everything I say ;)
11:02:22 <Twey> johnw: It requires a monomorphic type
11:02:25 <johnw> ah
11:02:28 <lisbeth> but the idea is I slowly replace GNU then point the path somewhere else
11:02:42 <johnw> :t gcast
11:02:44 <lambdabot> (Typeable b, Typeable a) => c a -> Maybe (c b)
11:03:00 <lisbeth> the cool thing about the hell environment is that there are no special chars like in bash
11:03:02 <lisbeth> all haskell
11:03:38 <Twey> johnw: Unfortunately I don't know that I have a ‘c a’ at that point
11:03:57 <lisbeth> everything in hell is a function in haskel
11:03:58 <Twey> I mean, I know it, but GHC doesn't ☺
11:04:02 <lisbeth> does that make sense?
11:04:28 <lisbeth> hell is literally on top of ghci
11:04:48 <lisbeth> it is a 200 line piece of code that adds functionality like printing the working directory
11:04:56 <Twey> johnw: Actually, even if it did know, it wouldn't help — I'd need to know b in order to use gcast
11:05:15 <lisbeth>  b in ?
11:05:31 <lisbeth> also hell is experimental and open source so any issues could be worked out later
11:05:31 <johnw> Twey: hmm
11:06:02 <lisbeth> oh sorry
11:06:13 <lisbeth> my real name is john so whenever you say johnw I think you are referring to me for a second
11:07:20 <lisbeth> so yeah I am going to try to use hell as my default shell in a terminal emmulator and slowly replace gnu with haskell
11:08:06 <lisbeth> anyway those are my sleepy thoughts thanks ofr listening
11:08:11 <m-r-r> Hello
11:09:05 <{AS}> @djinn Void -> a
11:09:06 <lambdabot> f = void
11:09:21 <m-r-r> Does it exists an Haskell ORM, or at least a DSL for doing SQL queries ?
11:11:12 <Twey> m-r-r: A few.  Esqueleto, Persist
11:12:49 <rqiu> one question on zipWith
11:13:06 <rqiu> zipWith has the following type: zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:13:30 <rqiu> why does zipWith ($) have this: zipWith ($) :: [b -> c] -> [b] -> [c]?
11:13:49 <dv-> :t ($)
11:13:50 <lambdabot> (a -> b) -> a -> b
11:14:08 <rqiu> yes, then?
11:14:17 <mauke> well, that's it
11:14:35 <mauke> maybe renumber types for clarity
11:14:36 <Twey> rqiu: Substitute a = (a -> b), b = a, c = b
11:14:43 <benmachine> Twey: consider this: whatever value you end up with, it should be able to answer typeOf
11:14:58 <mauke> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]; ($) :: (e -> f) -> e -> f
11:15:07 <benmachine> Twey: that is to say, I think the concrete type needs to be determined at least at the site of application
11:15:11 <mauke> now we can talk about the different variables without confusion
11:15:14 <texasmynsted> Hello.  Would somebody help me with a cabal install?  I am trying to install Hakyll and it is failing.  I uninstalled pandoc, and am now trying to install it through cabal...
11:15:22 <texasmynsted> Here is the error messages.  http://pastebin.com/Dbc4CYgk
11:15:30 <mauke> zipWith ($) would then unify (a -> b -> c) with (e -> f) -> e -> f
11:15:44 <mauke> resulting in a = e -> f; b = e; c = f
11:16:06 <benmachine> Twey: you say gcast isn't useful because you'd need to know b, I claim you'd need to know it anyway
11:16:06 <mauke> the result type is [a] -> [b] -> [c]
11:16:15 <mauke> which is the same as [e -> f] -> [e] -> [f]
11:16:47 * hackagebot hack2-contrib 2014.10.12 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2014.10.12 (JinjingWang)
11:17:07 <phaazon> 20:05 < k00mi> phaazon: you can have an interrupt handler that writes to a  pipe, then integrate that pipe into your normal event loop
11:17:11 <phaazon> how would you write that?
11:17:16 <phaazon> without *any* callbcaks
11:17:20 <phaazon> callbacks*
11:17:31 <simpson> phaazon: What's your goal?
11:17:43 <Twey> benmachine: Sorry, yes.  I can pass the b dictionary: data Foo b where Foo ∷ Typeable b ⇒ Foo b
11:18:08 <rqiu> i see, thanks
11:18:11 <Twey> Uh
11:18:20 <texasmynsted> anybody?
11:18:21 <bmuk> Hey everyone, after I build ghc on one computer, can I just copy /usr/local/bin to my other computer and call it a day or is there more to it than that?
11:18:45 <texasmynsted> bmuk, I would not do that.
11:19:19 <benmachine> Twey: I suspect that what you want is both theoretically possible and not supported by the existing Typeable library
11:19:22 <texasmynsted> that is asking for trouble.  Unless this is a lab and the two computers are identical
11:19:29 <phaazon> simpson: nothing, just being curious; I wonder whether it’s possible to design a whole interruption-reactive system without callbacks
11:19:33 <benmachine> bmuk: there's probably also stuff in /usr/local/lib
11:19:34 <phaazon> for instance in order to build a GU
11:19:36 <phaazon> GUI*
11:19:45 <bmuk> There is just ghc stuff there.
11:19:54 <simpson> phaazon: Well, depending on how you define "callback", it might not be possible.
11:20:01 <Twey> benmachine: I feel like I might have to use an unsafeCoerce somewhere, yeah
11:20:05 <rqiu> zipWith (id) :: [b -> c] -> [b] -> [c]
11:20:10 <bmuk> They are the same distro, but one is a laptop - I don't want to build ghc on it because it would take forever
11:20:11 <benmachine> Twey: fun times for you :)
11:20:20 <Twey> benmachine: But even that is non-trivial :þ
11:20:20 <k00mi> phaazon: you don't, but the callback would be as simple as it gets and you could handle the interrupt as a normal event
11:20:37 <m-r-r> Twey: ok, thanks: i will take a look at them tomowrrow :-)
11:20:43 <Twey> Can't just blindly unsafeCoerce it, or I don't get my dictionary
11:20:47 <phaazon> k00mi: the issue with callbacks to me is that it introduces a nasty side-effect
11:21:02 <phaazon> isn’t there a better way to handle events?
11:21:09 <simpson> phaazon: How so? Could you give an example of such a side effect?
11:21:10 <phaazon> and by events, I mean interruption
11:21:29 <phaazon> simpson: well, imagine you want to move a camera when the w key is pressed
11:21:31 <phaazon> without polling
11:21:40 <phaazon> you have to use, for instance, GLFW callbacks functions
11:21:51 <phaazon> you pass an IORef on your camera
11:21:53 <Twey> phaazon: FRP!
11:22:03 <phaazon> and then you get using IORef in your own model, which sucks.
11:22:12 <phaazon> Twey: FRP suffers from the same problem
11:22:19 <phaazon> how do you handle the reactive value?
11:22:23 <simpson> phaazon: Try SDL.
11:22:25 <Twey> phaazon: It does not
11:22:30 <phaazon> simpson: I know both
11:22:37 <phaazon> I’m not talking about a concrete case here
11:22:40 <phaazon> just talking.
11:22:49 <phaazon> Twey: well, explain me then
11:22:53 <phaazon> because in FRP
11:22:53 <simpson> phaazon: The problem is that you've eliminated polling (I call you for events) and callbacks (you call me for events).
11:22:57 <phaazon> my camera would be something like
11:23:09 <simpson> So now there's no way for events to get from you to me!
11:23:12 <rqiu> in the case of zipWith id, is it a = b->c?
11:23:18 <k00mi> phaazon: the only thing you can do is build abstractions on top of your callbacks, like the selfpipe trick I explained or FRP
11:23:33 <phaazon> yeah
11:23:34 <phaazon> exactly
11:23:38 <phaazon> that’s what I meant
11:23:44 <phaazon> even if FRP doesn’t expose callbacks
11:23:47 <phaazon> it needs them
11:23:59 <phaazon> simpson: I’m looking for alternatives
11:24:01 <phaazon> of course
11:24:03 <Twey> phaazon: If you use FRP, your internal model remains pure
11:24:03 <mauke> rqiu: yes, because ($) = id
11:24:07 <phaazon> with polling, we don’t need callbacks
11:24:16 <k00mi> but what's the problem with callbacks if you can't see them in your abstraction?
11:24:23 <phaazon> Twey: that’s true, but there’re still callbacks
11:24:29 <mauke> rqiu: ($) :: (a -> b) -> a -> b, which is (a -> b) -> (a -> b), which is c -> c with c = a -> b
11:24:35 <Twey> Of course if your library uses callbacks internally you'll need IORefs to interface, but that can be tucked away in a library and doesn't touch your application code
11:24:48 <simpson> phaazon: I'm saying that I don't think that there's any way for a GUI library to get events to the application without either polling or callbacks!
11:25:01 <phaazon> yeah
11:25:06 <phaazon> so what do you think is the best?
11:25:14 <phaazon> callbacks are “more reactive” I guess
11:25:19 <rqiu> nice
11:25:25 <phaazon> and polling consumes CPU for nothing 99% of the time
11:25:46 <simpson> I think that it depends on what you're building.
11:25:54 <simpson> Callbacks are infinitely preferable almost all of the time.
11:26:04 <benmachine> polling needn't consume CPU
11:26:16 <simpson> The only time that polling wins is when you can have non-blocking polling that has large gaps between it; say, SDL and GL when vsync is enabled.
11:26:18 <benmachine> I think I'd call select(2)-style network programming polling
11:26:24 <simpson> (And why would you disable vsync, you monster!?)
11:26:31 <phaazon> yeah
11:26:38 <phaazon> in my application, I use polling
11:26:47 * hackagebot hairy 0.1.0 - TODO  http://hackage.haskell.org/package/hairy-0.1.0 (fozworth)
11:26:49 * hackagebot hairy 0.1.1 - A RESTful CRUD web app.  http://hackage.haskell.org/package/hairy-0.1.1 (fozworth)
11:26:55 <phaazon> since, it sounds a bit too tricky to me
11:27:04 <phaazon> yet*
11:27:09 <rqiu> thanks guys
11:27:30 <phaazon> benmachine: huh?!
11:27:37 <phaazon> I thought it was more callbacks than polling
11:27:53 <phaazon> since it’s kinda network interruption
11:27:58 <simpson> No. select() is a poll for events, and most people immediately transform it into callbacks.
11:28:05 <benmachine> phaazon: with select, you say "I'm interested in these fds" and you call select() and it waits for something to turn up
11:28:15 <benmachine> then it returns, saying "something happened on these fds"
11:28:19 <benmachine> and you go and do whatever to them
11:28:39 <phaazon> yes
11:28:45 <phaazon> and the way it “waits”
11:29:17 <phaazon> I always thought it was like putting a thread in a blocking state, waiting for an interruption to happen
11:29:23 <phaazon> a hardware interruption, in the network card
11:30:11 <simpson> You can set your own timeout on select(), including a timeout which will (on many platforms) return immediately if no events are queued.
11:30:40 <k00mi> phaazon: you're actively asking for events, so it's polling
11:31:09 <phaazon> hm
11:31:21 <phaazon> so select just polls each n ns for events?
11:31:23 <haasn> On a scale from 1 to 10, how evil is it to use PostfixOperators and (%) = (/100)  to write (350%) instead of 3.50 ?
11:32:13 <sivteck> 1.2
11:32:23 <johnw> haasn: 6
11:32:45 <k00mi> phaazon: the implementation of select doesn't matter
11:32:47 <phaazon> 1
11:33:01 <phaazon> k00mi: hm
11:33:09 <johnw> haasn: great bikeshed starter, though
11:33:21 <Hafydd> Heh.
11:33:24 <hpc> i put it in the same category as (<>) = getLine
11:33:41 <mauke> hpc: ooh
11:33:42 <hpc> not evil whatsoever ;)
11:33:47 <phaazon> so, getting back to my camera issue k00mi
11:34:01 <benmachine> haasn: I'd say it's cute but not worth it
11:34:01 <k00mi> phaazon: non-polling would be if the OS would tell you once you can read
11:34:12 <sunu> Hey folks! Would you recommend haskell as the first functional language to learn?
11:34:21 <hpc> sunu: definitely
11:34:32 <phaazon> k00mi: to me, non-polling is like registering a callbacks to make call be invoked once something happens
11:34:42 <phaazon> -a
11:34:54 <k00mi> phaazon: right, but select does no such thing
11:35:06 <k00mi> it just blocks and control flow continues as normal
11:35:26 <hpc> there's many other good functional languages, but haskell will force you into learning it properly, instead of letting you carry over habits from other languages
11:35:44 <phaazon> k00mi: ok
11:35:48 <phaazon> then, about a GUI
11:35:52 <phaazon> if the user pushes a button
11:35:58 <k00mi> phaazon: see also the posix poll(2) function that is very similar to select
11:36:00 <phaazon> something happens should happen in my app
11:36:00 <sunu> hpc: Cool! I'm coming from a python background. So I was looking at hylang mostly.
11:36:12 <sunu> Which has a more pythonic syntax.
11:36:13 <phaazon> with callbacks, it sounds pretty horrible to deal with that
11:36:34 <LambdaFan> how can I see what a derived instance looks like. Say I made an instance of IsString for Foo, how can I see what that instance looks like?
11:36:52 <phaazon> I guess when pushing the button, the callbacks should, I don’t know, alter the pure model?
11:36:56 <phaazon> that sounds terrible design to me
11:37:15 <mauke> LambdaFan: wait, you can derive IsString? how does that work?
11:37:31 <phaazon> instance IsString a where fromString s = … -- mauke
11:37:48 <mauke> phaazon: that's not derived
11:37:55 <LambdaFan> mauke : I did this "instance isString Foo", and that compiled, but I have no idead what that instance looks like
11:38:07 <mauke> LambdaFan: er, that just sets all methods to undefined
11:38:08 <k00mi> phaazon: like I and others said, build abstractions on top of the callbacks
11:38:22 <phaazon> k00mi: sure
11:38:26 <phaazon> I’d like to
11:38:28 <LambdaFan> mauke: huh, okay
11:38:50 <phaazon> I just don’t get how you can turn an IORef-driven computation into a pure FRP interface
11:39:32 <k00mi> phaazon: did you have a look at reactive-banana? It works exactly like that
11:39:39 <phaazon> yeah
11:39:46 <phaazon> do you think I should also read the source?
11:40:22 <LambdaFan> mauke: this all started because I started getting complaints that I had a bunch of types that didn't have a IsString instance. I thought you could just "derive Generic" and use {-# LANGUAGE OverloadedStrings #-}
11:40:39 <Twey> benmachine, johnw: This seems to not segfault: http://lpaste.net/7382270976131596288
11:40:40 <k00mi> phaazon: basically anytime an event happens the entire network is "stepped"
11:40:48 <LambdaFan> I think I will simplify my problem and bring it to freenode/stackoverflow
11:41:22 <benmachine> Twey: strongest endorsement ever?
11:41:41 <Twey> phaazon, k00mi: Better: only the bits that depend on the occurred event are ‘stepped’
11:42:16 <k00mi> ok, but that's a detail irrelevant to understanding the concept ;-)
11:42:21 <LambdaFan> Is there an obvious solution to the problem of making a datatype and then using a function that expects that to have an IsString instance?
11:42:25 <phaazon> ok
11:42:29 <phaazon> but hm, where does the concept live?
11:42:54 <phaazon> the “network” might be something visible by IO
11:42:59 <Twey> benmachine: As strong as it gets when dealing with unsafeCoerce :þ
11:43:17 <phaazon> then if I want to mute a value that depends on a button
11:43:21 <phaazon> I have to express that in IO
11:43:28 <mauke> LambdaFan: what function, and how does it use IsString?
11:43:41 <phaazon> or express the link between my value and the button through IO
11:44:37 <k00mi> yes, at some point you have to do IO
11:44:43 <k00mi> I'm not sure what you're asking
11:44:54 <phaazon> well
11:45:19 <phaazon> the model is pure, for instance I have a character
11:45:23 <phaazon> in a world
11:45:37 <phaazon> I have a GUI, with two buttons “forward” and “backward”
11:45:47 <LambdaFan> mauke: it's singleton from Data.HashMap.Strict
11:45:53 <LambdaFan> mauke: singleton :: Hashable k => k -> v -> HashMap k v
11:45:54 <phaazon> if a push “forward”, the pure model should be altered to move the character
11:45:57 <phaazon> using FRP
11:46:07 <LambdaFan> mauke: himm, I'm pretty sure I have a Hashable instance
11:46:08 <phaazon> I’ll have to express my character’s position in term of IO
11:46:12 <phaazon> which sounds terrible to me
11:46:13 <k00mi> no
11:46:48 * hackagebot xmobar 0.22.1 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.22.1 (JoseAntonioOrtegaRuiz)
11:47:59 <LambdaFan> mauke: yeah it's wants the k in the type signature to have an IsString instance
11:48:14 <LambdaFan> mauke: But I've derived Show, and use OverloadedStrings
11:48:14 <k00mi> you pass a callback to your GUI framework that fires an event in your network, from there on the changes to your network are pure, until it comes to rendering the result
11:48:23 <mauke> LambdaFan: ???
11:48:30 <mauke> where does IsString come from?
11:48:37 <phaazon> k00mi: hm
11:48:53 <phaazon> so you’re saying, when I push the forward button
11:49:07 <phaazon> the GUI emits an event, for instance by pushing that in a list
11:49:08 <augur> how do i remove a @where from lambdabot?
11:49:12 <phaazon> and the model consumes such a list
11:49:18 <phaazon> and then reacts?
11:49:18 <LambdaFan> mauke: Data.String
11:49:29 <mauke> LambdaFan: no, why are you talking about IsString?
11:49:34 <benmachine> augur: do you mean a @let? there's @undefine
11:49:38 <mauke> LambdaFan: I thought you were using singleton
11:49:40 <augur> benmachine: no i mean @where :P
11:49:44 <benmachine> ohh yes
11:49:46 <benmachine> that thing
11:49:49 <benmachine> iono
11:49:57 <LambdaFan> mauke: I am, singleton is what is complaining about my type not having an IsString instance
11:50:04 <mauke> LambdaFan: no, it's not
11:50:21 <k00mi> phaazon: yes, that's a somewhat decent way to think of it, only instead of a list reactive-banana has the 'Event' type
11:50:45 <RedNifre> > Just $ Just 4
11:50:47 <lambdabot>  Just (Just 4)
11:51:02 <RedNifre> How do i combine those into Just 4?
11:51:08 <RedNifre> > Just Nothing
11:51:09 <lambdabot>  Just Nothing
11:51:11 <mauke> join
11:51:17 <lpaste> LambdaFan pasted “singleton sems to want IsString instance” at http://lpaste.net/112456
11:51:20 <phaazon> k00mi: which is a Monoid I guess
11:51:20 <RedNifre> > join $ Just Nothing
11:51:22 <lambdabot>  Nothing
11:51:24 <RedNifre> ah!
11:51:27 <RedNifre> thank you.
11:51:35 <LambdaFan> mauke: Doesn't make sense to me either, but that's the error message
11:51:44 <mauke> LambdaFan: what's the complete error message, and what's the code?
11:52:03 <LambdaFan> mauke: Okay I'll try to take out the extraneous stuff and paste that up
11:52:07 <phaazon> I should try to implement a little application with a GUI using Gtk2Hs and reactive-banana / sodium / whatever
11:52:14 <k00mi> phaazon: it isn't although I'm not sure why, there is a 'union' function that looks a lot like mappend
11:52:15 <phaazon> it’d be a great experience
11:52:24 <mauke> LambdaFan: also, that doesn't complain about a missing IsString instance. it says you have a type error
11:52:46 <phaazon> k00mi: yeah, an Event could be a Monoid then
11:52:49 <mauke> LambdaFan: and ghc guesses that adding an IsString instance might fix it, but don't believe everything ghc tells you about "possible fix"es
11:52:53 <phaazon> mempty = never
11:53:23 <phaazon> file:///home/phaazon/Desktop/tutorial-2012-07-en.pdf
11:53:25 <Twey> phaazon: You define up-front a ‘network’ of dependencies between behaviours.  For example, positionBehaviour = (,) <$> xBehaviour <*> yBehaviour, xBehaviour = accum 0 $ fmap (+) upButton <> fmap subtract downButton, yBehaviour = accum 0 $ fmap (+) upButton <> fmap subtract downButton
11:53:25 <phaazon> I’m reading that
11:53:25 <k00mi> phaazon: there might be special cases that break associativity, like several events happening at the same time
11:53:41 <Twey> Err, leftButton and rightButton, rather
11:53:54 <phaazon> ok
11:54:07 <Twey> phaazon: So the actual combining functions (here, (,), (+), subtract) are pure
11:54:29 <phaazon> indeed Twey
11:54:44 <Twey> Then your buttons might emit events like 1
11:55:32 <Twey> Alternatively, you can have upButton emit (\(x, y) → (x, y + 1)) and so forth directly — and then positionBehaviour = accum (0, 0) $ upButton <> downButton <> leftButton <> rightButton
11:56:36 <Twey> In Sodium Event is a monoid; I don't know why it isn't in reactive-banana
11:56:48 * hackagebot fay 0.21.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.0.0 (AdamBergmark)
11:56:50 * hackagebot fay-base 0.19.2.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.2.1 (AdamBergmark)
11:56:51 <Twey> Event a  rather
11:56:52 * hackagebot fay-text 0.3.1 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.1 (AdamBergmark)
11:58:47 <rqiu> (fmap (+) ZipList [1,2,3])
11:58:47 <rqiu>   :: (Num (ZipList t), Num t) => ZipList t -> ZipList t
11:58:54 <rqiu> why ((+) `fmap` ZipList [1,2,3]) :: Num a => ZipList (a -> a) ?
11:59:53 <rqiu> sorry, forgot a $
11:59:56 <mauke> rqiu: what's unclear?
12:00:01 <rqiu> (fmap (+) $ ZipList [1,2,3]) :: Num a => ZipList (a -> a
12:00:08 <rqiu> no issue
12:01:49 * hackagebot snaplet-fay 0.3.3.8 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.8 (AdamBergmark)
12:01:51 * hackagebot fay-builder 0.2.0.1 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2.0.1 (AdamBergmark)
12:07:30 <mm_freak> hi there
12:08:14 <mm_freak> is there an immutable variant of IORef?  i need a memory object which has identity (for GC), but otherwise behaves like an immutable value
12:08:27 <mm_freak> ideally it is not even IO-bound, but just gives me something with identity
12:09:14 <jle`> are you just looking for pointer equality
12:09:45 <mm_freak> no, i want to assign a finaliser…  some cleanup needs to be done when the value dies
12:10:17 <phaazon> mm_freak: for that I use ForeignPtr
12:10:25 <phaazon> and wrap it in a newtype
12:10:28 <mm_freak> phaazon: good idea, that might work
12:10:38 <phaazon> wait
12:10:43 <mm_freak> but it's still mutable
12:11:03 <mm_freak> anyway, i'll need some unsafePerformIOs anyway
12:11:07 <mm_freak> so it's probably fine
12:11:15 <phaazon> https://github.com/phaazon/photon-opengl/blob/master/Photon/Render/OpenGL/Forward/Mesh.hs#L117
12:11:29 <phaazon> yeah, it’s still mutable indeed :/
12:11:30 <phaazon> sorry then
12:11:58 <mm_freak> alright, but ForeignPtr is probably better than IORef anyway
12:12:00 <mm_freak> so thanks =)
12:12:17 <phaazon> you’re welcome :)
12:12:22 <mm_freak> and bye
12:12:52 <phaazon> and bye then :D
12:13:40 <MyWay> hi
12:14:24 <jle`> hello MyWay
12:14:46 <MyWay> can I ask questions about general lambda calculus, here?
12:16:39 <texasmynsted> (do not ask to ask)
12:17:04 <jle`> you should have asked if you were allowed to ask to ask questions
12:17:05 <quchen> He's not asking about asking, he's asking about whether something is ontopic.
12:17:21 <quchen> Lambda calculus is at least not so off-topic that you shouldn't try asking.
12:18:45 <YurasS> what package for URL manipulation is a way to go today?
12:20:28 <MyWay> mine is a general lambda-calculus question; I'm new to functional languages and I'm having some problem beta-reducing expressions, probably because I can't understand very well the scope of the "terms". I'm using normal form evaluation
12:21:30 <Twey> What does the ‘<type variable> is untouchable’ error mean?
12:21:32 <MyWay> e.g. (λxyz.xy(yz))(λuv.u)(λab.a) -> (λyz.(λuv.u)y(yz))(λab.a), then when which is my "M" of "(λx.y)M"?
12:21:57 <MyWay> to me it's not clear "who is who" (how to choose it)
12:22:06 <lpaste> LambdaFan pasted “IsString, with code and all errors” at http://lpaste.net/112458
12:22:18 <LambdaFan> mauke: well, there it is
12:22:59 <Twey> MyWay: It depends what kind of evaluation strategy you're using
12:23:16 <MyWay`> leftmost, outermost
12:23:51 <Twey> Then you get (λz.(λuv. u)y(y(λab.a)))
12:23:56 <mauke> LambdaFan: why are you trying to use "key" as a key?
12:24:08 <mauke> LambdaFan: your type signature says you expect a Key, not a string
12:25:13 <MyWay`> mauke: so you're considering (always referring to (λx.y)M), x = λyz, y = (λuv.u)y(yz) and M = (λab.a)
12:25:36 * LambdaFan faceplams
12:25:41 <mauke> MyWay`: I don't understand what you mean by M
12:25:52 <lisbeth> man I keep theorizing in my sleep
12:25:53 <lisbeth> can't fall asleep
12:26:04 <lisbeth> I was thinking about passing input through functions
12:26:14 <lisbeth> when you do ls -a in bash your output is not safe for input to other programs
12:26:26 <lisbeth> because by making it human readable it can mess up the string
12:26:33 <MyWay`> by M I mean the thing to substitute inside y, where you find the first term of x
12:26:40 <Rembane> lisbeth: How can it mess upp the string?
12:26:49 <lisbeth> Rembane bash can do it very easily
12:27:06 <lisbeth> one of the easiest ways in bash is if a filename has a space in it
12:27:15 <lisbeth> that already constricts you to using escape characters
12:27:19 <Twey> benmachine, johnw: I think this is the function I'm missing: http://lpaste.net/7382270976131596288#a4172010396724494336
12:27:25 * LambdaFan slaps himself with wet trout
12:27:39 <MyWay`> http://en.wikipedia.org/wiki/Lambda_calculus at Beta reduction section, talks about an application of the form (λx.t)s
12:27:40 <LambdaFan> mauke: that's what I get from cutting/pasting my old code
12:27:41 <Rembane> lisbeth: Oh. True that. Thanks.
12:27:49 <texasmynsted> I do not understand this.
12:27:58 <texasmynsted> I just installed cabal
12:28:02 <texasmynsted> I do cabal update
12:28:05 <lisbeth> so in a shell when you are dealing with strings that could potentially mess things up along thew way, you want to generate them in binary
12:28:05 <mauke> LambdaFan: oh, that was the whole problem? :-D
12:28:11 <texasmynsted> I do cabal install cabal-install
12:28:16 <Twey> benmachine, johnw: I'd like to switch to using a (a ~) context instead of a reified (a :~:) proof, but http://lpaste.net/7382270976131596288#a3202623268561354752 gives me an error about untouchable types at the call site, which I don't understand
12:28:16 <lisbeth> or in other words you want to generate them in the raw format you got them in
12:28:24 <texasmynsted> all good.  Then I do cabal install pandoc and I get conflicts.
12:28:25 <texasmynsted> How?
12:28:30 <lisbeth> then as you pass them through functions they should be designed to deal with that binary
12:28:31 <texasmynsted> I have not installed anything?
12:28:44 <lisbeth> and if you want it to be human readable at the end you add a fucntion "human_readable"
12:28:44 <benmachine> Twey: I have never heard of that error before, you're on your own :P
12:28:49 <texasmynsted> is there a cabal channel?
12:28:59 <benmachine> texasmynsted: #hackage
12:29:08 <texasmynsted> :-)
12:29:10 <texasmynsted> thank you
12:29:11 <lisbeth> this ensures that no strings that get passed into functions can ever be messed up
12:29:16 <LambdaFan> mauke: those datatypes were once plain strings, I cut and paste and didn't pay attention
12:29:20 <lisbeth> even in a shell script
12:29:49 <lisbeth> because there are no special chars in binary
12:30:48 <lisbeth> also I think I'd want to invent my own version of plaintext that uses a nullbyte instead of newline
12:31:22 <lisbeth> also the location of every nullbyte in the file can be known at the beginning of the file if the file is designed that way
12:31:29 <lisbeth> so you can skip to whatever line you want
12:32:32 <lisbeth> if you want to read it in something like vim, or gedit, you pass it through the human_readable function, then into that program
12:33:03 <lisbeth> so then it is both safe to us any string and any file in the shell
12:34:11 <indiagreen> lisbeth: think about how you would append a new line to a 100MB log file
12:34:40 <lisbeth> I am not sure about what I said having the location of every nullbye in the file known
12:34:59 <lisbeth> but I am sure I want to write a plaintext file format that writes in binary and uses nullbyte as newline
12:35:27 <lisbeth> maybe the locations of the nullbytes could be appended to the end of the file
12:35:30 <ski> MyWay` : hm
12:35:34 <lisbeth> that would make more sense in most filesystems
12:35:51 <lisbeth> then all you would need is the location of the end of the file at the beginning
12:36:19 <lisbeth> and if I implemented that in a smart way then you could much more quickly find a specific line
12:36:32 <ski> MyWay` : in `(λxyz.xy(yz))(λuv.u)(λab.a) -> (λyz.(λuv.u)y(yz))(λab.a)', `λx.y' corresponds to `λxyz.xy(yz)', and `M' to `λuv.u'
12:36:51 <lisbeth> basically however a filesystem finds a file without looking through the whole filesystem, that I how I want to design this text format
12:38:01 <lisbeth> even it it takes longer to write to that file, and the file takes up more space in metadata, it would save more time to not have to read every line in order before you get to the next one
12:38:06 <MyWay`> yes, ski, but here? (λyz.(λuv.u)y(yz))(λab.a), λx.y λyz.(λuv.u)y(yz) and M = (λab.a)?
12:38:15 <lisbeth> and stop me if I am abusing the chatroom, I just am thinking outloud
12:38:43 <mauke> lisbeth: might be more appropriate for #haskell-blah
12:38:53 <ski> MyWay` : aye
12:39:04 <MyWay`> ski, why not λx.y = λyz.(λuv.u) and M = y? this is what I can't understand
12:39:14 <lisbeth> oh I thought that channel wasn't real because I typed the wrong thing and got an empty channel
12:39:15 <lisbeth> sorry
12:39:45 <ski> MyWay` : because `(λyz.(λuv.u)y(yz))(λab.a)' means the expression `λyz.(λuv.u)y(yz)' applied to the expression `λab.a'
12:40:35 <MyWay`> in the sense that you're choosing the "outermost"? because λyz.(λuv.u) is applied to y, too, right?
12:40:37 <ski> MyWay` : in the original case, `(λxyz.xy(yz))(λuv.u)(λab.a)' means : (`λxyz.xy(yz)' applied to `λuv.u') applied to `λab.a'
12:41:01 <ski> MyWay` : in general `M N O' means `(M N) O', iow (`M' applied to `N') applied to `O'
12:41:13 <jle`> :t curry fst
12:41:14 <lambdabot> c -> b -> c
12:41:20 <jle`> :t uncurry const
12:41:21 <lambdabot> (c, b) -> c
12:41:22 <carter> int-e: huh, lambdabot isnt on #hackage !
12:41:39 <ski> MyWay` : yes, outermost application
12:41:45 <jle`> why do we even need `fst` if we can always just uncurry const
12:42:08 <ski> MyWay` : outermost application in `(λxyz.xy(yz))(λuv.u)(λab.a)' is : `(λxyz.xy(yz))(λuv.u)' being applied to `(λab.a)'
12:42:28 <ski> MyWay` : outermost application in `(λxyz.xy(yz))(λuv.u)' is : `λxyz.xy(yz)' being applied to `λuv.u'
12:42:55 <ski> MyWay` : outermost application in `(λyz.(λuv.u)y(yz))(λab.a)' is : `λyz.(λuv.u)y(yz)' being applied to `λab.a'
12:42:55 <jle`> `flip const` or `const id` is weird, let's just always say curry snd instead
12:43:28 <jle`> i wonder if they compile down to the same thing
12:44:09 <capisce> jle`: and why do we need do notation? :)
12:44:35 <jle`> i know right!
12:44:43 <jle`> actually do notation is pretty useful
12:44:43 <MyWay`> so, in general, to get the outermost application, I have to "expand" λx.y more that I can (watching at λx parentheses) and then get M based on the first M term's parentheses
12:48:34 <harlanhaskins> Hmm. Does anyone know of a good way to map over the even/odd indices of a list?
12:48:56 <jle`> probably zipWith
12:49:01 <jle`> zipWith + cycle
12:49:09 <mauke> harlanhaskins: in what way?
12:49:49 <jle`> > zipWith ($) (cycle [(*10), (+2)]) [1..]
12:49:50 <lambdabot>  [10,4,30,6,50,8,70,10,90,12,110,14,130,16,150,18,170,20,190,22,210,24,230,26...
12:49:50 <harlanhaskins> I'm trying to implement the Luhn credit card validation algorithm
12:49:51 <MyWay`> ski, can you check this, please? (last one!): λxy.y((λxyz.xyz)(λu.u)(λu.uu)) -> λxy.y((λyz.(λu.u)yz)(λu.uu)) -> λxy.y((λz.(λu.u)(λu.uu)z)) -> λxy.y(((λu.u)z)) -> λxy.y(z) -> λy.y or λy?
12:49:56 <ski> MyWay` : to get the outermost application, you must parse the linear expression correctly
12:50:08 <harlanhaskins> Which involves doubling every other index
12:50:14 <ski> MyWay` : the outermost application may not be the place where you're to apply the next beta reduction, though
12:50:22 <MyWay`> just to see if I'm choosing appropriately
12:50:28 <jle`> > zipWith ($) (cycle [id, (*2)]) [1,6,2,3,8,3,4,5,1,4]
12:50:29 <lambdabot>  [1,12,2,6,8,6,4,10,1,8]
12:50:43 <mauke> harlanhaskins: starting from which end?
12:50:49 <ski> @let zap = zipWith ($)
12:50:52 <lambdabot>  Defined.
12:51:06 <harlanhaskins> Looks like jle' 's solution is great.
12:51:08 <jle`> zap, that's cute :)
12:51:27 <harlanhaskins> mauke: I was gonna reverse the list first. Efficiency be damned!
12:51:36 <mauke> no, that's fine
12:52:08 <jle`> just don't take the length :P
12:54:27 <jle`> hm. is there any neat way to do it without reversing and taking advantage of the streamy linky nature of list
12:54:53 <ski> MyWay` : your `λxy.y(((λu.u)z))' should be `λxy.y(λz.(λu.uu)z)' -- as a result, the following steps continued from this error (but "λxy.y(z) -> λy.y or λy" isn't right, anyway)
12:57:45 <dfeuer> jle`, whatcha tryin' to do?
12:58:53 <jle`> dfeuer: oh, it's the classic cis194 exercise
12:59:01 <jle`> or is it the nicta course
12:59:10 <jle`> where you double every other item in a list starting from the end
12:59:23 <bezirg> hi, does MonadCatchIO-transformers work with GHC>=7.8 ?
12:59:46 <argent0> plus ∷ Number → Number → Number
12:59:46 <argent0> a `plus` (Digit Zero) = a
12:59:46 <argent0> a `plus` (Digit One) = next a
12:59:48 <argent0> a `plus` n = ?
12:59:58 <MyWay`> ski, λxy.y((λz.(λu.u)(λu.uu)z) -> λxy.y(λz.zz) and stop there, then?
13:00:34 <jle`> argent0: you have me on the edge of my seat. why don't you reveal the end of your story already? :D
13:01:51 * hackagebot HaskellTutorials 0.0.0.1 - Haskell Tutorials by Evgeny Ukhanov  http://hackage.haskell.org/package/HaskellTutorials-0.0.0.1 (mrlsd)
13:02:10 <argent0> I think that the 'recursive' definition of sum is: next(a+x) a + next(x). But now I see that that doesn't work on haskell
13:03:12 <k00mi> argent0: how is Number defined?
13:03:45 <argent0> k00mi: data Number = Digit Glyph | MultiDigit Glyph Number
13:03:53 <dfeuer> jle`, you could surely do it without reversing, but whether it will be much better is another question (I think likely better constant factors, but nothing more than that). The streamy linky nature doesn't help you.
13:04:01 <argent0> k00mi: data Glyph = Zero | One | Two | Three deriving (Eq, Ord)
13:04:17 <jle`> there must be some way.......
13:04:36 <k00mi> argent0: that's a weird way to define natural numbers
13:05:27 <ski> MyWay` : yes .. except that that's two steps
13:05:49 <MyWay`> yes, first remove (λu.u)
13:05:56 <MyWay`> thank you for your patience, ski
13:05:59 <ski> MyWay` : you could optionally apply eta instead of beta here (you get same result, up to alpha-conversion)
13:06:11 <MyWay`> what eta is?
13:06:15 <exio4> argent0: what is wrong with data Nat = Z | S Nat?
13:06:26 <bezirg> I am not sure what is the right way to go. I have a custom monad that has IO as its base monad. I want to lift (throwIO, catch) operations to my monad. My monad supports MonadIO already. I tried the exceptions and monad-control packages with no success. So i thought to use MonadCatchIO-transformers. Is it safe to use this package?
13:06:37 <ski> MyWay` : eta says that `\x.(Mx)' is equal to `M', in case `M' doesn't contain `x' freely
13:07:01 <ski> MyWay` : you can replace "is equal to" by "reduced to", if you prefer
13:07:11 <ski> s/reduced/reduces/
13:07:50 <argent0> exio4: there is nothing wrong with it. How would I define `plus` using Nat?
13:08:30 <exio4> argent0: plus (S a) b = S (plus a b) ; plus Z b = b ?
13:09:14 <exio4> http://www.haskell.org/haskellwiki/Peano_numbers
13:09:16 <MyWay`> oh, thank you ski, and where can you apply that? I can't see it, inside λxy.y((λz.(λu.uu)z)
13:09:31 <argent0> exio4: Thank I'll take a look =)
13:10:35 <ski> MyWay` : well, `λz.(λu.u)(λu.uu)z' can be eta-reduced to `(λu.u)(λu.uu)' .. or you can first beta-reduce it to `λz.(λu.uu)z', and then eta-reduce that to `λu.uu'
13:11:42 <ski> (those two reductions commute, they're independent)
13:13:23 <ski> @quote cornered
13:13:23 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
13:13:33 <ski> @quote OlegFacts
13:13:33 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
13:15:15 <MyWay`> ski, then I have another stupid question: using only beta-reductions, I've found λxy.y(λz.zz) which is different to λxy.y(λu.uu) obtained by using eta-reduction, but has the same mean, right?
13:15:24 <MyWay`> from*
13:15:49 <ski> yes, they are alpha-equivalent
13:16:02 <ski> iow, equivalent up to (consistent) renaming of bound variables
13:16:11 <MyWay`> oh, there is a name, alpha-equivalent, thank you :P
13:16:36 <ski> the process of (consistently) renaming some bound variables is called alpha-conversion
13:17:07 <ski> so both these answers are alpha-convertible to each other, or for short : they're alpha-equivalent
13:17:58 <ski> the actual names used for local variables doesn't really matter. what matter is their "pattern of use" in the expression which is their scope
13:19:42 <MyWay`> thank you again, your explanation is very clear
13:20:44 <matt2> i'm trying to follow this guide (http://www.stephendiehl.com/llvm/), but I can't get cabal to stop being evil
13:20:57 <matt2> this is the error I'm getting: https://gist.github.com/mr/983e9f51ab0a39079095
13:21:13 <matt2> says that llvm-general is missing external libraries
13:21:18 <matt2> anyone know what that could mean?
13:21:52 * hackagebot hairy 0.1.2 - A JSON REST API  http://hackage.haskell.org/package/hairy-0.1.2 (fozworth)
13:23:57 <notdan> matt2: I assume it needs some llvm C libraries
13:24:17 <dfeuer> jle`, you can do something vaguely like  doubleSome = foldr (\x (r,d) -> if d then (x:x:r, False) else (x:r, False) ) ([], True)
13:24:53 <jle`> :o
13:25:26 <dfeuer> jle`, I meant else (x:r, True) there.
13:28:37 <matt2> notdan: i tried searching online for them, but I really don't know what they are
13:29:06 <matt2> i haven't really found anything relating to them, nor have i found anything in my os's repos
13:32:28 <ab9rf> is it really reasonable to expect something called "cabal" to not be evil?
13:32:35 <doismellburning> lol
13:32:36 <doismellburning> tinc ;)
13:35:53 <matt2> llvm-config --libs all shows all of the libs being there
13:37:43 <jle`> dfeuer: thanks :)
13:38:05 <dfeuer> jle`, oh? Was that horrid thing helpful somehow?
13:38:13 <dfeuer> I don't even know if it really works....
13:41:00 <_robbins> :t fmap
13:41:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:42:40 <jle`> dfeuer: it does :D
13:42:54 <dfeuer> jle`, I'm very curious how.
13:43:41 <jle`> it's because of the nature of foldr...the [] at the end is the "seed", and the rest follows from the seed
13:44:02 <dfeuer> jle`, I understand how it works. I don't understand how that helps you.
13:44:19 <jle`> oh
13:44:20 <dfeuer> I didn't know if it worked because I hadn't tested it when I wrote it down :P
13:46:25 <jle`> it helps me gaze upon the deep truths of the universe
13:47:33 <sleepynate> anyone know the name of the type of notation that haskell data constructors is based off of?
13:48:11 <dfeuer> @hoogle withFile
13:48:12 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
13:48:12 <lambdabot> System.Posix.ByteString.FilePath withFilePath :: RawFilePath -> (CString -> IO a) -> IO a
13:48:33 <johnw> sleepynate: you mean "data Foo = ..."?
13:48:55 <sleepynate> like List 'a = Empty | Cons 'a (List 'a)... yea. i could have sworn someone told me what the name for that notation was once
13:49:11 <johnw> it's an algebraic data type
13:49:13 <johnw> is that what you mean?
13:49:28 <johnw> other languages call it a variant type
13:49:43 <sleepynate> i think that that notation (whether used in haskell or another language) is named after some guy
13:50:15 <sleepynate> and it's driving me nuts that i can't find the source that i learned it, unless i totally imagined it :D
13:50:57 <benmachine> it (very) superficially resembles BNF
13:52:56 <sleepynate> nah i don't think they called in bnf, i imagine i would have remembered that one
13:56:36 <sleepynate> ahh well, if anyone knows what the hell i'm talking about, a mention would be awesome. i'm going to keep digging ;)
14:10:51 <TheKing444> I tried installing repa-fftw, but it won't install because I don't have fftw3, because it was renamed to libfftw3-3
14:11:21 <TheKing444> what should I do?
14:13:55 <notdan> matt2: which OS are you using?
14:15:51 <notdan> matt2: I think this is what you need http://packages.ubuntu.com/precise/llvm-dev
14:15:57 <notdan> if you are using linux
14:32:35 <matt2> notdan: I'm using Fedora Linux, and i installed the llvm-devel package from their repos
14:32:52 <matt2> let me see what's included in that package
14:38:53 <arianvp> Wut
14:39:10 <arianvp> for some reason foldl' (flip Data.Set.insert) Data.Set.empty seems faster than Data.Set.fromList
14:44:15 <dfeuer> WTF?
14:45:10 <dfeuer> I think arc is doing something strange.
14:45:23 <dfeuer> arianvp, that is very peculiar, and if true is a bug.
14:46:17 <arianvp> No nevermind. I misread a digit
14:46:31 <arianvp> (luckily)
14:46:46 <arianvp> I thought I was going nuts for a minute
14:48:59 <dfeuer> Why the heck does Data.Set have its own private version of foldl', called foldlStrict?
14:49:10 <arianvp> dfeuer: no idea
14:49:57 <dfeuer> foldlStrict might be lazier in the seed when the list is empty (not sure) but it's hard to imagine that is intentional.
14:52:58 <phaazon> little survey: what text editor do you use? :)
14:53:26 <FireFly> vim for me
14:53:38 <phaazon> I also use vim, but in terminal
14:53:51 <arianvp> Just switched to emacs last month
14:53:54 * arianvp hides
14:54:01 <phaazon> :D
14:54:15 <phaazon> I’m always amazed how we keep using old but good editors
14:54:26 <FireFly> I need to try out emacs+evil someday
14:54:26 <phaazon> when others switch to, for instance, Sublime or that kind of stuff
14:54:30 <arianvp> I've tried 'hip' editors. they just don't cut it
14:54:35 <phaazon> hip?
14:54:43 <arianvp> hipster?
14:54:49 <phaazon> do you have an example?
14:55:24 <arianvp> All the new stuff:   "sublime":"atom":"bracket":generateHipsterName (n-1)
14:55:28 <rqiu_> can someone pls help to explain why ($ (+1)) is :: Num a => ((a -> a) -> b) -> b
14:55:31 <rqiu_> :t ($ (+1))
14:55:32 <lambdabot> Num a => ((a -> a) -> b) -> b
14:55:55 <joelteon> it's \ f -> f (+1)
14:56:01 <arianvp> Sublime is probably the closest to pleasant. it's really fast. But not free/ or open source. which bothers me
14:56:11 <phaazon> yeah, same
14:56:19 <phaazon> and I’m really used to vim’s mode
14:56:21 <benmachine> phaazon: on the other hand, we keep using old and terrible terminals :P
14:56:26 <phaazon> which, imho, rocks so hard
14:56:37 <phaazon> benmachine: urxvt here, not that bad
14:56:52 <rabisg> Im trying to write the Monad instance for `Foo a =  Foo (Reader Int a)`. Got stuck at (>>=). can someone help me out?
14:56:55 <phaazon> even though I find its scroll feature pretty bad
14:57:00 <arianvp> M-x<RET>package-install<RET>evil-mode<RET>
14:57:42 <phaazon> rabisg: use the (Reader a) instance
14:57:47 <arianvp> the vim emulation for emacs is really good
14:58:12 <obiwahn> Is mokus form time to time online?
14:58:40 <FireFly> rqiu_: (+1) is a function Num a => a -> a, right?
14:59:11 <rabisg> FireFly: yes
14:59:18 <phaazon> maybe I should try the X version of vim
14:59:20 <FireFly> rqiu_: and then ($) is function application, so the f in  f $ (+1)  would have to have type Num a => ((a -> a) -> b)  (since it takes (+1) as an argument)
15:00:10 <FireFly> rqiu_: and then finally since you section the ($), you get yet another level of "takes a function"-ness
15:00:20 <obiwahn> phaazon: maybe atom is something for you
15:00:41 <phaazon> I’ll have a look :)
15:01:00 <phaazon> “based on web technologies”
15:01:02 <phaazon> oh my.
15:01:22 <FireFly> rqiu_: you could rewrite it as  flip ($) (+1)  and work out the types from there
15:01:28 <jfeltz> does anyone know why System.Environment.getArgs will grab only the first arg in some cases, and all args in others?
15:01:51 <obiwahn> i can not help i stick to vim ... being able to work remote even over terrible connections is too awesome:P
15:02:16 <harlanhaskins> +1. Vim is too wonderful to give up.
15:02:19 <arianvp> obiwahn: But emacs works in the console as well :D
15:02:29 <shelf> using GUI clients you usually get emacs bindings, so you can adapt easily to terminal emacs if you're stuck in a shell
15:02:37 <obiwahn> emacs is as wonderful:)
15:02:56 <phaazon> obiwahn: how do you use vim?
15:03:00 <phaazon> in console/GUI?
15:03:07 <obiwahn> console
15:03:13 <phaazon> yeah, same as me then
15:03:16 <phaazon> which console?
15:03:20 <phaazon> well, terminal*
15:03:21 <dfeuer> Off topic!
15:03:24 <harlanhaskins> I'm having trouble grabbing command line arguments as integers.
15:03:33 <arianvp>  /join #haskell-offtopic. see you guys there :)
15:03:43 <dmj`> harlanhaskins: what have you tried
15:03:44 <FireFly> there's haskell-blah
15:03:45 <phaazon> obiwahn: haskell-blah
15:03:49 <arianvp>  i mean haskell-blah
15:04:00 <jfeltz> main = print =<< getArgs only prints the ["a"] when it should print ["a","b","c"] for ./exec a b c
15:04:37 <mauke> jfeltz: [citation needed]
15:04:57 <harlanhaskins> dmj': I've been using http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling as a reference
15:05:03 <harlanhaskins> Like their parse function
15:05:35 <jfeltz> mauke, the failing case occurs for an exec built with cabal, the success case works for just ghc exec.hs
15:05:43 <harlanhaskins> But I'm just looking to take getArgs and map read over it and then map it over a function that prints whether it's a valid card
15:07:10 <dmj`> harlanhaskins: is using 'read' causing exceptions for you?
15:08:02 <harlanhaskins> dmj': Yeah
15:08:08 <harlanhaskins> https://gist.github.com/harlanhaskins/6a6237bedd20b3fb0eec
15:08:45 <dmj`> harlanhaskins: for cheap and pure command line parsing I use readMaybe from Text.Read
15:09:23 <dmj`> getArgs >>= \args -> catMaybes $ map (\x -> readMaybe x :: Maybe Int) args
15:09:47 <dmj`> well, you'll need to call print before catMaybes for that to work
15:10:09 <harlanhaskins> :t catMaybes
15:10:10 <lambdabot> [Maybe a] -> [a]
15:10:18 <harlanhaskins> Yeah, that looks promising!
15:11:08 <jfeltz> mauke, nevermind, I'm an idiot, the problem was due to filtering out the args at the shell-script caller
15:15:36 <harlanhaskins> https://gist.github.com/harlanhaskins/cb206b22968e47c5ef54
15:16:08 <harlanhaskins> dmj'
15:16:11 <harlanhaskins> :/
15:16:33 <dmj`> you need a return
15:16:42 <dmj`> before catMaybes
15:17:38 <bkolera> dmj`: Doesn't Data.Maybe.mapMaybe = catMaybes . map ?
15:17:42 <dmj`> also what is the type of ns?
15:17:44 <sebastiankg> I'm new to Haskell and having a hard time with binding in Do-Notation
15:17:46 <dmj`> @src mapMaybe
15:17:46 <lambdabot> Source not found. :(
15:18:13 <sebastiankg> I bind to a variable, and then on the next line of my do-notation statement, it says that the variable is not in scope
15:18:42 <dmj`> :t catMaybes . map
15:18:44 <lambdabot>     Couldn't match type ‘[a1] -> [b]’ with ‘[Maybe a]’
15:18:44 <lambdabot>     Expected type: (a1 -> b) -> [Maybe a]
15:18:44 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
15:18:58 <dmj`> bkolera: mapMaybe is (a -> Maybe b) -> [a] -> [b]
15:19:38 <dmj`> sebatiankg: can you paste some code?
15:19:48 <dmj`> sebastiankg:
15:20:44 <augur> sebastiankg: if you're new to haskell, you should avoid do notation :)
15:20:56 <hiptobecubic> what? why?
15:21:20 <dmj`> sebastiankg: well done, that is hot
15:21:27 <dmj`> (mapMaybe readMaybe :: [String] -> [Int]) $ ["hey", "4"]
15:21:28 <dmj`>  
15:21:28 <dmj`>  
15:21:32 <augur> because it's a distraction, hiptobecubic
15:21:53 <sebastiankg> what is hot?
15:21:57 <sebastiankg> I'm confused
15:22:03 * dmj` adds mapMaybe readMaybe to stash of cool tricks
15:22:13 <bkolera> dmj`: :)
15:22:18 <augur> dmj`: i dont think that type checks
15:22:25 <augur> @hoogle mapMaybe
15:22:27 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
15:22:27 <lambdabot> Data.IntMap.Strict mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
15:22:27 <lambdabot> Data.IntMap.Lazy mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
15:22:36 <augur> oh so it does. ok
15:22:49 <dmj`> lambdabot is missing Text.Read I think
15:22:53 <dmj`> :t readMaybe
15:22:54 <lambdabot> Not in scope: ‘readMaybe’
15:22:56 <augur> i thought mapMaybe was (a -> b) -> Maybe a -> Maybe b. guess not
15:23:01 <roboguy_> sebastiankg: you should paste your code on lpaste
15:23:16 <roboguy_> @paste
15:23:17 <lambdabot> Haskell pastebin: http://lpaste.net/
15:23:21 <dmj`> @def f :: Read a => String -> Maybe a; f = undefined
15:23:24 <lambdabot>  Defined.
15:23:31 <dmj`> :t mapMaybe f
15:23:32 <lambdabot>     Ambiguous occurrence ‘f’
15:23:32 <lambdabot>     It could refer to either ‘L.f’,
15:23:32 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:181:1
15:23:45 <dmj`> @def readMaybe :: Read a => String -> Maybe a; f = undefined
15:23:46 <lambdabot>  .L.hs:183:1:
15:23:46 <lambdabot>      The type signature for ‘readMaybe’ lacks an accompanying binding
15:23:46 <lambdabot>  
15:23:46 <lambdabot>  .L.hs:184:1:
15:23:46 <lambdabot>      Multiple declarations of ‘f’
15:23:57 <dmj`> @def readMaybe :: Read a => String -> Maybe a; readMaybe = undefined
15:24:00 <lambdabot>  Defined.
15:24:05 <dmj`> :t mapMaybe readMaybe
15:24:06 <lambdabot> Read b => [String] -> [b]
15:24:16 <dmj`> :t mapMaybe readMaybe :: [String] -> [Int]
15:24:17 <lambdabot> [String] -> [Int]
15:24:33 <sebastiankg> here's my code http://pastebin.com/zKCrPQ0P
15:25:02 <sebastiankg> where computeSteps is a pure function that returns a list of String
15:25:19 <sebastiankg> and where printSteps is a monadic function that returns IO()
15:25:49 <roboguy_> sebastiankg: what is printStepList?
15:26:05 <sebastiankg> sorry I meant printStepList, not printSteps
15:26:16 <dmj`> sebastiankg: for best results, I'd paste all of the code
15:26:31 <roboguy_> sebastiankg: you're getting an undefined symbol error, not a type error?
15:26:48 <roboguy_> (I mean, "not in scope" error)
15:27:20 <sebastiankg> here's all the code, ['hilo'] is a placeholder
15:27:22 <sebastiankg> http://pastebin.com/Q4yjmbTE
15:27:31 <dmj`> bkolera: sry just realized my comment about mapMaybe readMaybe was intended for you, not sebastiankg :)
15:27:35 <roboguy_> sebastiankg: main can't take arguments
15:27:54 <sebastiankg> oh, really?? okay
15:28:16 <sebastiankg> can I not pass arguments to my program then?
15:28:16 <roboguy_> sebastiankg: if you want to get command line arguments, you need getArgs
15:28:22 <bkolera> dmj`: Yeah I got it. Nps. Just glad that you learned a new trick. :)
15:28:31 <sebastiankg> oh okay
15:28:34 <roboguy_> @hoogle getArgs
15:28:38 <lambdabot> System.Environment getArgs :: IO [String]
15:28:38 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
15:28:38 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
15:28:42 <roboguy_> the first one there
15:29:38 <sebastiankg> okay, cool on that part
15:29:43 <roboguy_> sebastiankg: the problem with printStepList is that the indentation is wrong. It thinks the second line is part of the argument list to printStepList
15:29:54 <roboguy_> I mean, part of the argument list to putStrLn
15:30:27 <roboguy_> that's why it says: The function ‘putStrLn’ is applied to three arguments, but its type ‘String -> IO ()’ has only one
15:30:36 <sebastiankg> wait, indentation affects meaning in haskell? Honestly I feel like the course I took about it taught me nothing hahaha
15:30:40 <dmj`> bkolera: me too :)
15:30:50 <sebastiankg> how should it be indented?
15:31:30 <roboguy_> sebastiankg: all the do statements should be lined up
15:31:37 <roboguy_> yeah, indentation matters in several places
15:32:03 <roboguy_> although, generally, if things that look like they should be lined up *are* lined up, it works outt fine
15:32:06 <sebastiankg> they're vertically lined up already, but I guess lined up by tabs and not by spaces?
15:32:08 <nh2> did something come out of the "documentation build failing in hackage" thread?
15:32:22 <nh2> will we get builds back / is somebody working on that?
15:32:59 <roboguy_> sebastiankg: oh, yeah, the ghc compiler assumes tabs are always 8 spaces. I would suggest not using tabs at all (it's possible to use them effectively with Haskell, but you have to put some extra thought into it. I like just using spaces so I don't have to worry about it at all)
15:33:31 <roboguy_> in the pastebin paste I can see that they aren't lined up
15:34:45 <sebastiankg> haha yeah, me too. Okay, I guess I'll just use spaces for now and then change Sublime's settings to insert spaces
15:34:49 <sebastiankg> instead of tab characters
15:36:28 <sebastiankg> okay that solved that problem, thanks guys
15:47:20 <nh2> Philonous: you have this libnice package on Github. Will that go on Hackage?
15:50:22 <harlanhaskins> Hmm...How can I turn getContents into an array of lines?
15:51:16 <frihd> harlanhaskins:  you can use the Functor property of IO
15:51:38 <frihd> :t getLineContents = fmap lines getContents
15:51:40 <lambdabot> parse error on input ‘=’
15:51:50 <harlanhaskins> FMAP
15:51:52 <harlanhaskins> Right.
15:51:54 <frihd> :t fmap lines getContents
15:51:55 <lambdabot> IO [String]
15:58:34 <harlanhaskins> frihd: Couldn't match type `IO' with `[]'
15:59:27 <harlanhaskins> This is the code. The broken line is line 58. https://gist.github.com/harlanhaskins/a22660e755428fc9f7ae
16:01:32 <frihd> harlanhaskins:  that's because you return once too much
16:01:59 * hackagebot primitive 0.5.4.0 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.4.0 (DanDoel)
16:02:01 * hackagebot vector 0.10.12.0 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.12.0 (DanDoel)
16:02:06 <Susie23>  Free Porn for Life!. Click Here! http://tinyurl.com/ozfvxy3
16:02:17 <frihd> then integerArguments takes a [String] not an IO [String] ; you need to fmap another time
16:02:50 <frihd> fmap integerArguments $ fmap lines getContents  (also fmap (integerArguments . lines) getContents)
16:03:14 <frihd> do you have GHC 7.8? harlanhaskins
16:03:40 <harlanhaskins> I'm using 7.6.3
16:03:44 <frihd> if so, use "holes" to guide you   (i.e., _ in the code)
16:04:13 <frihd> ok, you should upgrade at some point (not your priority, though)
16:05:21 <frihd> you understand that fmap tells how you should transform the output of getContents
16:05:59 <frihd> what you need is find a  f such that   fmap f getContents  returns what you want, then f has type String -> [Integer]
16:06:21 <harlanhaskins> Yep. fmap will apply a function to the contents of a monad and return the results.
16:06:22 <frihd> and you can build one by composing integerArguments and lines =)
16:06:30 <harlanhaskins> Composition is beautifu.
16:06:37 <harlanhaskins> s/beautifu/beautiful/
16:07:43 <roboguy_> hackagebot: well, that's true but it doesn't need to be a monad. any Functor will do
16:07:57 <roboguy_> harlanhaskins: ^
16:08:45 <frihd> harlanhaskins:  you can see a functor as a "producer of value", and you can introduce pure transformations to the value with fmap
16:09:19 <harlanhaskins> So lift the value out of the functor, apply the function, and put it back into the functor?
16:09:36 <harlanhaskins> :t fmap
16:09:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:09:43 <harlanhaskins> Yep!
16:09:52 <frihd> well, it's the other way around
16:10:03 <nonks> bhuffer 5
16:11:27 <frihd> I mean, the intent with fmap is not to unwrap/re-wrap ; that would be a possible implementation
16:11:28 <roboguy_> harlanhaskins: it doesn't necessarily take anything out or put anything back in
16:11:43 <roboguy_> there are Functor instances that wouldn't make sense for
16:11:59 * hackagebot hzulip 0.2.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.2.0.0 (yamadapc)
16:12:18 <harlanhaskins> @src fmap
16:12:18 <lambdabot> Source not found. Take a stress pill and think things over.
16:12:37 <roboguy_> harlanhaskins: fmap has a different definition for each type that is an instance of Functor
16:12:57 <roboguy_> @src Maybe fmap
16:12:57 <lambdabot> fmap _ Nothing  = Nothing
16:12:57 <lambdabot> fmap f (Just a) = Just (f a)
16:13:47 <frihd> @src (->) fmap
16:13:47 <lambdabot> fmap = (.)
16:14:36 <roboguy_> @src Proxy fmap
16:14:36 <lambdabot> Source not found. You type like i drive.
16:16:18 <frihd> I like to see fmap as a way to chisel an API that doesn't fit my need; for instance if you have an HTTP call returning a [User] and you want only their logins, you can do something like myVersionOfTheQuery = fmap (map userLogin) apiQuery
16:16:59 * hackagebot hzulip 0.2.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.2.0.1 (yamadapc)
16:17:10 <roboguy_> pretend lambdabot said this instead of Source not found: fmap Proxy _ = Proxy
16:17:19 <roboguy_> oops, fmap _ Proxy = Proxy
16:17:25 <frihd> ahah =)
16:17:31 <frihd> lambdalmostbot
16:17:36 <roboguy_> haha
16:21:16 <sbrg> I think I might install arch linux. hmm
16:24:56 <mm_freak> hi again
16:25:07 <mm_freak> is there a way to get a FunPtr to a regular haskell function?
16:27:00 * hackagebot hzulip 0.2.0.2 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.2.0.2 (yamadapc)
16:28:07 <sbrg> oh, wrong channel, heh.
16:30:32 <roboguy_> mm_freak: it looks like you'd do something like this http://stackoverflow.com/questions/997738/haskell-ffi-calling-funptrs
16:35:47 <burp> mm_freak: with "dynamic" as follows: foreign import ccall "dynamic" mkFun :: FunPtr (Type) -> Type
16:36:32 <burp> well, I guess that's exactly what is in that stackoverflow answer :)
16:39:49 <mm_freak> that's not what i want
16:39:58 <mm_freak> i /have/ a function and /need/ a FunPtr
16:40:40 <hl406> #haskell
16:41:06 <mm_freak> i got it now
16:41:07 <mm_freak> thanks =)
16:41:33 <burp> yea, "wrapper", as in Foreign.Ptr docs
17:02:01 * hackagebot hsbencher 1.12 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.12 (RyanNewton)
17:02:03 * hackagebot hsbencher-fusion 0.2 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.2 (RyanNewton)
17:02:05 * hackagebot hsbencher-codespeed 0.1 - Backend for uploading benchmark data to CodeSpeed  http://hackage.haskell.org/package/hsbencher-codespeed-0.1 (RyanNewton)
17:12:35 <spopejoy> is there a way to test for membership in a HList or TIP that is *not* a type error?
17:13:28 <joelteon> what exactly is test for membership
17:13:34 <joelteon> an hlist is not a list
17:13:37 <joelteon> it's a tuple
17:13:44 <spopejoy> ie, data Foo; data Bar; data Baz; x = hEnd $ hBuild Foo Bar; (some function to test if x has Baz)
17:14:03 <joelteon> but that information is encoded in the type
17:14:22 <joelteon> so it's O(1)
17:14:43 <spopejoy> but how do you test for it?
17:15:24 <joelteon> i think you'd have to write a typeclass for that
17:15:53 <RchrdB> Maybe you could use Data.Typeable? That seems REALLY icky, though.
17:16:02 <spopejoy> the real example is, data Foo Integer; data Bar String; data Baz Bool; x = hEnd $ hBuild (Foo 1) (Bar "hello"); testIfXHasBaz x = _
17:16:14 <RchrdB> A typeclass should be able to do it much better.
17:17:31 <roboguy_> what about a type family?
17:18:35 <joelteon> ok, a type family should be better
17:18:37 <joelteon> you're right
17:18:39 <chrisdotcode> who broke vector?
17:18:41 <chrisdotcode> Data/Vector/Fusion/Util.hs:25:10:
17:18:41 <chrisdotcode>     Not in scope: type constructor or class ‘Applicative’
17:18:49 <chrisdotcode> (when installing yesod in a sandbox)
17:19:50 <spopejoy> would anyone care to try writing such a typeclass? http://lpaste.net/112463
17:20:04 <spopejoy> (cause I'm totally lost :) )
17:20:12 <spopejoy> or type family
17:20:41 <roboguy_> spopejoy: a type family works pretty much like a normal function, but at the type level
17:24:41 <spopejoy> so would this be a type family to handle any type of "Contains", ie "type Contains l = ContainsTF l v ..."
17:24:50 <spopejoy> or specific to Baz
17:25:13 <chrisdotcode> I can't install snap either.
17:25:27 <chrisdotcode> Did somebody just upload a new break to vector literally moments ago? The install worked like 30 minutes ago.
17:26:25 <chrisdotcode> Ah, yes. Seems so.
17:27:05 <spopejoy> joelteon: any hints on a typeclass or TF to do this?
17:27:24 <roboguy_> spopejoy: here's an implementation of element checking for type level lists http://lpaste.net/112465
17:27:58 <joelteon> yeah, do that
17:27:59 <spopejoy> roboguy_: thanks
17:28:01 <spopejoy> :)
17:28:21 <roboguy_> spopejoy: you want to check at compile time, I assume (otherwise this won't be possible at all, I'd imagine)
17:29:56 <meoblast001> hi.. i think a function exists which does what i'm looking for, but i'm not sure i'm looking it up right in hoogle
17:30:01 <roboguy_> of course, something more useful would be something with type (Elem Baz as ~ True) => HList as -> Baz
17:30:17 <spopejoy> roboguy_: actually, I want an extensible, pairwise-strongly-typed, heterogenous map
17:30:31 <meoblast001> i'm going to invent some fake but obvious syntax... i'm looking for a way to basically do this.... (item1, item2, item3) = (<- something, <- something, <- something)
17:30:56 <meoblast001> basically i want a tuple of IO monads as the result
17:30:58 <roboguy_> spopejoy: does that mean you want runtime membership tests?
17:31:11 <spopejoy> no
17:31:12 <meoblast001> oh sorry... i lied... i want a tuple of bound values
17:31:26 <spopejoy> it will be known at compile time
17:31:33 <roboguy_> meoblast001: what about (item1, item2, item3) = (something, something something)?
17:31:42 <roboguy_> or with <- instead of = if you're using do
17:31:47 <spopejoy> what I really need is the String value of Baz, if it's there
17:31:50 <meoblast001> roboguy_: well.. something returns a monad
17:32:07 <meoblast001> so something like "item1 <- something" taken to the extreme of binding 3 things into a tuple
17:32:12 <roboguy_> meoblast001: if you're using do notation, try (item1, item2, item3) <- (something, something, something)
17:32:22 <roboguy_> or actually not
17:32:51 <roboguy_> :t liftA3 (,)
17:32:52 <lambdabot>     Couldn't match type ‘(a, b)’ with ‘c -> d’
17:32:52 <lambdabot>     Expected type: a -> b -> c -> d
17:32:52 <lambdabot>       Actual type: a -> b -> (a, b)
17:32:53 <roboguy_> :t liftA3 (,,)
17:32:54 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
17:33:00 <meoblast001> hmmmm
17:33:36 <meoblast001> @define example = return ()
17:33:37 <roboguy_> you could use that, it would probably be easier to just use do { item1 <- something; item2 <- something; item3 <- something }
17:33:39 <trap_exit> this is not (but may be related to) "if it compiles, it works" -- has anyone found that, in other langauges (say Ruby/Python/Clojure), one generally sits down, starts coding, thignsa re murky ... but incrementaly, the program grows -- whereas in Haskell, the most 'productive' way seems to be (1) don't sit down in front of a computer (2) get a notebook, sketch out the data types + types of the functions (3) sketch until it's clear, 
17:33:40 <meoblast001> oops...
17:33:40 <trap_exit> first time
17:33:43 <lambdabot>  Defined.
17:33:52 <meoblast001> nvm.. let me do this separately in my own console
17:35:02 <meoblast001> roboguy_: so you're basically saying i want (>>=) . liftA3?
17:35:10 <roboguy_> spopejoy: I think hlist already has membership tests now that I look again
17:35:35 <roboguy_> meoblast001: no, I was saying you might want something like liftA3 (,,)
17:35:53 <roboguy_> but, like I said, it would probably be easier ultimately to do the three binds separately
17:36:17 <meoblast001> roboguy_: which appears to take applicative functors of three types and returns one applicative functor of a tuple of those three types
17:36:21 <spopejoy> roboguy_: in the end, I'm looking for 'lookup', in the sense I'd like to get Just Baz String, or Nothing
17:36:25 <meoblast001> then since that applicative functor is actually a monad i bind it
17:36:53 <roboguy_> spopejoy: the Maybe shouldn't be necessary though, if I'm understanding, because it's existence would be fully known at compile time
17:37:05 <roboguy_> meoblast001: pretty much. All monads are applicative functors
17:37:16 <spopejoy> hmm. i see
17:37:16 <roboguy_> not by requirement, until the next version of ghc though
17:37:30 <spopejoy> if it's known then I don't need to branch or test, just access
17:37:35 <meoblast001> :t (>>=) . liftA3
17:37:36 <lambdabot> Applicative f => (a -> b1 -> c -> d) -> ((f b1 -> f c -> f d) -> f a -> b) -> f a -> b
17:37:53 <RchrdB> trap_exit: don't know, for me that depends usually on how much IO the program does
17:37:54 <meoblast001> well that looks painful...
17:38:17 <spopejoy> that's great. SO: given a list that HAS Bar String, how do I get the String value out? Can you pattern match or something on HLists?
17:38:51 <roboguy_> meoblast001: I doubt that would be necessary
17:39:06 <spopejoy> Wait I think I know that too
17:39:09 <spopejoy> hOccurs
17:39:13 <spopejoy> let me try ...
17:39:37 <platz> anyone using ghc-mod 5.1.1.0 yet?
17:39:51 <roboguy_> meoblast001: I'm not sure I see the connection, actually
17:40:54 <meoblast001> roboguy_: actually i'd want liftA3 (,,) or liftM3 (,,) and that'd give me Monad m => m (a, b, c), no?
17:41:12 <roboguy_> meoblast001: yeah, then you could bind it with <-
17:41:26 <meoblast001> yup
17:41:28 <meoblast001> thanks
17:43:01 <meoblast001> thanks roboguy_
17:43:09 <meoblast001> i think this should work but currently it's untestable until i do some other things
17:43:56 <roboguy_> np!
17:46:15 <spopejoy> oof. can't quite get there. but it's a much simpler problem now.
17:47:32 <spopejoy> once again. I have an HList, x = hEnd $ hBuild (Baz "stuff") (Bar 31). How do I get "stuff" out?
17:48:12 <spopejoy> Do I need a TIP?
17:48:39 <spopejoy> sadly the TIP examples ("myTipyCow") don't show accessing Name "Angus"
17:49:14 <roboguy_> spopejoy: what about hOccurs
17:49:43 <spopejoy> doesn't seem to compile.
17:52:56 <spopejoy> no it does seem to work. now I'm off to study the membership types, so I can type my function "a HList that has Baz"
17:53:05 <spopejoy> thanks
18:21:02 <Moniker> Hello good people
18:22:05 <lpaste> Moniker pasted “Where is the goof?” at http://lpaste.net/112466
18:22:06 * hackagebot vector 0.10.12.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.12.1 (DanDoel)
18:25:12 <Moniker> I am having an IRC client issue.. Anyway.
18:25:49 <Moniker> Could soimeone look at my html and tell me where i goofed? I am having an issue with my navbar and I can't find the problem. Everything looks like it should work correctly.
18:26:03 <Moniker> Code: http://lpaste.net/112466
18:26:16 <Moniker> SS of problem: http://i.imgur.com/q5g3xOL.png
18:26:40 <ReinH> Moniker: this is a Haskell channel obv, but I think you need the target to be an id, not a class?
18:26:58 <slack1256> Moniker: not to be pedantic but this is a haskell channel.
18:27:06 <ReinH> You'd probably have more luck asking HTML/CSS questions in a relevant channel
18:27:35 <Moniker> I thought this was
18:27:54 <ReinH> This is a Haskell channel.
18:28:00 <dfeuer> Moniker, Haskell is a programming language, not anything to do with markup.
18:28:04 <ReinH> It is not a HTML/CSS channel.
18:28:16 <Moniker> Well, that is to say I found a reference to this channel online when searching for help with this problem.
18:28:27 <slack1256> Well he said he is having Client problem and both start with H but yeah
18:28:29 <Moniker> Well heck
18:28:34 <Moniker> Alright. Thanks anyway
18:29:00 <ReinH> That's a rather odd place to find a reference to this IRC room o_O
18:30:08 <geekosaur> possibly it was in reference to yesod or etc.
18:30:33 <geekosaur> but the question that got the reference was actually a haskell question and not an html or css question
18:32:25 <Moniker> Ya know wot
18:32:31 <Moniker> I'm a boob
18:32:39 <Moniker>  This is where i found it: https://news.ycombinator.com/item?id=7161236
18:32:53 <Moniker> I should read more carefully in the future i suppose.
18:32:57 <Moniker> My bad guys.
18:33:52 <slack1256> Speaking of web dev, anybody knows about a tutorial for it for somebody who only knows haskell?
18:34:01 <slack1256> obviously using happstack snap or yesod
18:34:51 <Moniker> Well, I know of some good Bootstrap/jQuery based web dev tuts on youtube if you're seriously asking.
18:34:57 <ReinH> Moniker: not a big deal just, you know, we probably won't be much help for your question :)
18:35:13 <Moniker> They are geared towards the completely ignorant to some working knowledge
18:35:32 <Moniker> ReinH: It's cool. Thanks though.
18:36:43 <dfeuer> Moniker, they probably have nothing about Happstack, Snap, or Yesod.
18:37:07 * hackagebot glib 0.13.0.4 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.4 (HamishMackenzie)
18:40:29 <jayunit100_4g> > :type (`+` 1)
18:40:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:40:34 <jayunit100_4g> -- how come that fails ?
18:40:35 <glumtug> IPTorrents Owner Doxxed: Runs 6 trackers, involved in hacking and cyber attacks --> https://iptdox.com/ --> https://iptorrentsdox.com/
18:41:21 <nitrix> ^ lol
18:42:00 <ReinH> jayunit100_4g: `+` is a syntax error, but the message is somewhat surprising
18:42:07 * hackagebot cairo 0.13.0.2 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.2 (HamishMackenzie)
18:42:33 <ReinH> operators like (+) don't need ``
18:42:41 <exio4> @type (`+` 1)
18:42:42 <lambdabot> parse error on input ‘+’
18:42:45 <jayunit100_4g> ReinH: but even so, why is it an error ?
18:42:53 <exio4> @type (+ 1)
18:42:54 <lambdabot> Num a => a -> a
18:43:00 <ReinH> exio4: that's the error I'd expect, yeah
18:43:07 <jayunit100_4g> if the `` just makes a afunction infix….  then shouldnt `` be harmless?
18:43:20 <exio4> ReinH: "> :type" :P
18:43:22 <ab9rf> you can't use `` on an operator
18:43:40 <ab9rf> :t `(+)`
18:43:40 <lambdabot> parse error on input ‘`’
18:43:48 <ab9rf> didn't think it would like that either
18:44:47 <ReinH> `` works non-operators only
18:48:25 <jayunit100_4g> how come i cannot do :type `elem` ?
18:48:42 <ReinH> jayunit100_4g: because "`elem`" is not a valid expression
18:48:53 <jayunit100_4g> hmmmm
18:49:01 <ReinH> :t (`elem`)
18:49:03 <lambdabot> parse error on input ‘)’
18:49:06 <jayunit100_4g> so ,you cannot do :type on a function
18:49:22 <ReinH> jayunit100_4g: you can, but only on valid expressions
18:49:24 <ReinH> :t elem
18:49:25 <lambdabot> Eq a => a -> [a] -> Bool
18:49:26 <jayunit100_4g> but certainly, you can do :type elem
18:49:27 <ReinH> elem is a valid expression
18:49:32 <ReinH> `elem` is not a valid expression
18:49:39 <jayunit100_4g> whats wrong with `elem` >
18:49:40 <jayunit100_4g> ?
18:49:46 <jayunit100_4g> seems valid to me :)
18:49:47 <jayunit100_4g> ?
18:50:15 <ab9rf> an infix operator with nothing in front of it?
18:50:30 <ReinH> an infix operator by itself is not a valid expression
18:50:33 <ReinH> :t +
18:50:35 <lambdabot> parse error on input ‘+’
18:50:37 <ab9rf> do you think that + is a valid expression?
18:51:02 <jayunit100_4g> yes
18:51:06 <ab9rf> it is not
18:51:11 <ab9rf> (+) is a valid expression
18:51:17 <jayunit100_4g> i assume that + is really just a function, and a function is an expression.
18:51:19 <jayunit100_4g> ahhhh okay
18:51:20 <ab9rf> but + is not
18:51:26 <jayunit100_4g> what is the diff between (+) and +
18:51:28 <ab9rf> jayunit100_4g: + is not a function
18:51:31 <ab9rf> (+) is a functin
18:51:36 <jayunit100_4g> ohhhh ok
18:51:37 <ab9rf> + is an operator
18:51:44 <ReinH> an operator is either an operator symbol, such as + or $$$, or a regular identifier enclosed in ``
18:51:45 <jayunit100_4g> ah okay
18:51:49 <ReinH> an operator is not a valid expression
18:51:57 <jayunit100_4g> okay thanks ReinH
18:52:13 <jayunit100_4g> so ` is an operator?
18:52:18 <ReinH> ` is not an operator
18:52:20 <ab9rf> no
18:52:23 <ReinH> ` is a reserved character
18:52:24 <Moniker> Okay, I think i found what I need. Thanks guy. Sorry for the confusion. Later!
18:52:27 <ab9rf> ` is a special character
18:53:33 <jayunit100_4g> this "special character" business seems fishy to me.
18:53:35 <jayunit100_4g> hmm
18:53:56 <ab9rf> no fish in haskell as far as i know
18:54:37 <ReinH> enclosing an identifier in ``turns it into an operator, e.g., `elem`. Enclosing an symbol operator in () turns it into a a prefix function that is a valid expression. (`foo`), howerver, is not a valid identifier or expression.
18:55:04 <ReinH> jayunit100_4g: Do you think " is fishy?
18:55:26 <ReinH> Or (), [], {}?
18:55:50 <ReinH> ()[]{} are all special characters
18:56:06 <ab9rf> i forget what square brackets are used for
18:56:11 <ReinH> It would be rather difficult to program in a language without special characters, I expect
18:56:13 <ab9rf> oh, duh
18:56:15 <ab9rf> i'm tired
18:56:20 <ReinH> ab9rf: list literals? ;)
18:56:40 <ab9rf> ReinH: totally failed on that one
18:56:51 <ab9rf> ReinH: we don't absolutely need those
18:56:54 <ReinH> jayunit100_4g: A more complete description of Haskell's syntax is available in the report http://www.haskell.org/onlinereport/syntax-iso.html
18:57:15 <ReinH> Although as a specification document it's rather dense
18:58:26 <ReinH> I will say that Haskell's syntax is one of the smaller and more consistent syntaxes I've come across, especially if you only consider non-sugared syntax. (Yes, spellcheck, syntaxes is inded a word)
18:58:56 <cads> hey guys, anyone familiar with giry's monad and other categorical approaches to probability?
18:59:21 <ReinH> The report also goes into some detail about what constitutes a valid expression FYI https://www.haskell.org/onlinereport/haskell2010/haskellch3.html
18:59:37 <ReinH> cads: no, sounds interesting though
18:59:49 <cads> I'd like to work with random trees and networks, and I was wondering if I can build up on a haskell library that provides a foundation for that stuff via giry's monad
18:59:52 <ReinH> Cale might be. He's familiar with a lot of things.
19:00:05 <simpson> ReinH: It's relatively small and simple but contains really nasty bits for anybody implementing the parser, like custom operator precedence.
19:00:26 <ReinH> simpson: the lexer is easy, I didn't make any claims about the parser :p
19:00:51 <ReinH> But you are quite right
19:09:32 <spopejoy> HList is *blowing* *my* *mind*
19:09:59 <spopejoy> another Haskell moment where imperative thought processes are utterly destroyed
19:10:38 <ski> spopejoy ?
19:11:37 <spopejoy> ski: adjusting to the idea that I can express a data structure with *some* identical elements and *some* heterogenous elements with full expression in the type system
19:12:13 <spopejoy> also thanking the gods that Haskell is a REPL-equipped language. I wonder why golang doesn't come with a REPL.
19:13:02 <spopejoy> if it weren't for ghci I would *never* figure out types like (HExtend e b, Show b, Eq b) => e -> Mus' a b -> Mus' a (HExtendR e b)
19:14:22 <spopejoy> what's another language that is statically compiled *but* comes with a REPL?
19:14:29 <johnw> Common Lisp
19:14:30 <ReinH> spopejoy: HList is pretty cool.
19:15:18 <spopejoy> is CL always statically compiled? do folks use it in 'runHaskell' mode?
19:15:37 <johnw> CL, like Haskell, can produce either bytecode or binary executable code
19:16:07 <spopejoy> ?? haskell bytecode ??
19:16:07 <lambdabot>  haskell bytecode
19:16:33 <spopejoy> didn't know about bytecode
19:16:56 <dfeuer> spopejoy, it's not unusual for languages to have multiple implementations with multiple sorts of approaches...
19:16:57 <spopejoy> are macros evaluated before static compilation?
19:17:05 <spopejoy> in CL?
19:17:23 <dfeuer> spopejoy, I imagine so. That's certainly how most Scheme implementations do it.
19:17:39 <ski> spopejoy : there are several Scheme and Common Lisp compilers, with interactors
19:17:46 <ski> spopejoy : also, the MLs
19:17:56 <spopejoy> i was figuring the MLs might.
19:18:20 <dfeuer> And those crazy proof checkers have their interactive proof assistants too.
19:18:31 <ski> spopejoy : macros are expanded before code generation, yes
19:18:33 <spopejoy> is it worth spending a day or two with ocaml? I don't like the syntax much ...
19:18:40 <ReinH> dfeuer: proof assistants are pretty awesome
19:18:57 <dfeuer> ReinH, can you suggest an entry point to that world?
19:18:59 <spopejoy> i mean "as a haskeller" is it worth a day or two checking out ocaml
19:19:17 <ski> spopejoy : learning the module system of the MLs (not F#, unfortunately) is worth it, imho
19:19:21 <ReinH> dfeuer: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html !!!
19:19:25 <dfeuer> spopejoy, it might take you longer than that...
19:19:40 <exio4> spopejoy: you could check https://www.coursera.org/course/proglang
19:19:43 <ski> spopejoy : personally i prefer SML to OCaml but OCaml isn't bad either
19:20:03 <exio4> I think you still have time for "fully taking it"
19:20:06 <hiptobecubic> ski, why?
19:20:11 <spopejoy> i hear more about ocaml in actual use, but maybe i'm not listening to the right convos ...
19:20:12 <ski> hiptobecubic : which ?
19:20:13 <dfeuer> I've seen that link before, ReinH
19:20:24 <dfeuer> I'll have to check it out.
19:20:25 <hiptobecubic> why sml over the other ocaml?
19:20:32 <hiptobecubic> i don't know either
19:20:54 <ski> hiptobecubic : oh, SML just feels a bit more neat to me. probably a personal impression
19:21:40 <ski> (F#, while being an ML, doesn't have the module system)
19:22:28 <dfeuer> ML without the module system sounds pretty crippled.
19:22:43 <spopejoy> what are big features of ML modules vs Haskell?
19:23:03 <dfeuer> spopejoy, the ML module system has features.
19:23:09 <spopejoy> ouch!
19:23:12 <hiptobecubic> my impression was that it worked like some kind of crazy static ducktyping
19:23:17 <dfeuer> Or you might say "ML has a module system."
19:23:22 <spopejoy> pow!
19:23:27 <dfeuer> hiptobecubic, I think that's about right.
19:23:45 <dfeuer> It also has module functor things.
19:24:04 <spopejoy> as in "haskell has namespacing, not modules"?
19:24:09 <dfeuer> I don't really know much about it all though.
19:24:22 <dfeuer> spopejoy, that sounds likely.
19:24:44 <spopejoy> coming from java, i'm rejoicing in having decent namespace controls.
19:25:18 <spopejoy> and i like that they're not insane (like clojure)
19:25:45 <ski> spopejoy : the main hilights are being able to specify module signatures, and being able to define and apply module functions, a module taking modules (of a particular signature) as argument
19:26:00 <ski> this is good for modularity
19:26:11 <bms1> is there a name for a constructor that doesn't need to be defined in the GADT manner?
19:26:22 <ski> unfortunately, Haskell doesn't have anything like it
19:26:41 <ski> bms1 : hm, not that i know
19:27:00 <ski> i suppose perhaps you could say "non-GADT data constructor"
19:27:26 <bms1> ski: that's what I have right now basically :)
19:28:36 <spopejoy> ski: i suppose that would be good for all of the Data.*'s with their maps, folds, filters
19:28:45 <ski> "regular data constructor" wouldn't quite be it, since that's more specific
19:28:59 <benzrf> bms1: an ADT :p
19:29:30 <spopejoy> or maybe for backends, a la Regex. Seems nutty that you just magically import a backend without any check that there is one.
19:29:45 <bms1> benzrf: but (to be pedantic) that sounds like it's talking about the type, not really the constructor
19:30:06 <benzrf> i guuuesss?
19:30:13 <benzrf> an ADD then
19:30:17 <benzrf> er
19:30:18 <benzrf> ADDC
19:30:24 <benzrf> ADC
19:30:47 <nshepperd> a "boring data constructor"
19:30:54 * ski . o O ( SBC )
19:42:38 <jayunit100_4g> ReinH: any other doc for haskell syntax other than the spec to help with the ` issue?
19:42:45 <jayunit100_4g> thanks, btw for that one .
19:42:56 <spopejoy> roboguy_ still around? turns out I do need a "runtime" has Elem check, but code in http://lpaste.net/112465 is a type-level check
19:45:22 <RchrdB> jayunit100_4g: what's your question, please?
19:46:50 <jayunit100_4g> RchrdB: well, im wondering :
19:59:49 <jayunit100_4g> when i have `elem` …. , and im wondering how it is that currying `elem` reverses the order of its arguments
20:00:14 <jayunit100_4g> > :type (`elem` ['a' .. 'z'])
20:00:16 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:00:26 <jayunit100_4g> > :type (elem ['a' .. 'z'])
20:00:28 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:00:36 <jayunit100_4g> :type (elem ['a' .. 'z'])
20:00:58 <geekosaur> it's just :t
20:01:03 <ski> no currying is taking place here
20:01:15 <jayunit100_4g> :t (elem ['a' .. 'z'])
20:01:16 <lambdabot> [[Char]] -> Bool
20:01:23 <jayunit100_4g> :t (`elem` ['a' .. 'z'])
20:01:24 <lambdabot> Char -> Bool
20:01:26 <geekosaur> lambdabot is not ghci, :t is not an abbreviation
20:01:47 <jayunit100_4g> oh okay,. so what is lambdabot ?
20:01:58 <ski> @where lambdabot
20:01:58 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
20:02:04 <ski> @version
20:02:04 <lambdabot> lambdabot 5.0-int-e
20:02:04 <lambdabot> git clone git://github.com/int-e/lambdabot.git
20:02:21 <jayunit100_4g> when i only give elem the first arg  … (elem ['a' .. 'z']) … isnt that now a curried function ?\
20:02:41 <ski> `elem' is curried
20:02:48 <geekosaur> it has specific plugins that trigger on specific sequences, like "> " to evaluate an expression or ":t " to get a type. the parser is much simpler than ghci's and it is much less complete
20:02:58 <ski> but you weren't performing any currying above
20:03:26 <ski>   foo `elem` bar
20:03:28 <ski> means the same as
20:03:31 <ski>   elem foo bar
20:04:13 <jayunit100_4g> so shouldnt `elem` ['a','b']
20:04:16 <ski> if you just type
20:04:19 <ski>   elem foo
20:04:22 <jayunit100_4g> be the same as elem ['a','b'] ?
20:04:28 <ski> then you could say that that is a partial application of `elem'
20:04:35 <ski> jayunit100_4g : nope
20:04:49 <ski> jayunit100_4g : do you know the lambda expression notation, yet ?
20:04:51 <jayunit100_4g> actually, ski of course your right, with ``'s now i need to put an argument before.
20:05:27 <ski> if you type
20:05:32 <ski>   (^ 3)
20:05:39 <jayunit100_4g> ski: ive been able to finish the first 4 chapters of real world haskell, including exersizes.   i dont  know  know anything outside that.
20:05:52 <ski> then this can be seen as an abbreviation for
20:05:58 <ski>   \x -> x ^ 3
20:06:11 <ski> iow, the function that given an argument, call it `x', computes `x ^ 3'
20:06:17 <ski> so that
20:06:24 <ski>      (^ 3) 2
20:06:33 <ski>   =  (\x -> x ^ 3) 2
20:06:39 <ski>   =  2 ^ 3
20:06:41 <ski>   =  8
20:07:12 <ski> so, `(^ 3)' is the "cubing" function, that cubes any argument passed to it
20:07:17 <ski> otoh, if you type
20:07:20 <jayunit100_4g> okay....
20:07:21 <ski>   (3 ^)
20:07:31 <ski> then this can be seen as an abbreviation for
20:07:38 <ski>   \y -> 3 ^ y
20:07:41 <ski> so that
20:07:47 <ski>      (3 ^) 2
20:07:57 <jayunit100_4g> so it works either way
20:07:57 <ski>   =  (\y -> 3 ^ y) 2
20:08:05 <ski>   =  3 ^ 2
20:08:07 <ski>   =  9
20:08:17 <texasmynsted> 	/clear
20:08:19 <jayunit100_4g> (^3) and (3^) are identical then, right?
20:08:36 <joneshf-laptop> > (^3) 5
20:08:39 <lambdabot>  125
20:08:42 <joneshf-laptop> > (3^) 5
20:08:44 <lambdabot>  243
20:08:52 <ski> so `(3 ^)' is the "raise `3' to the power of" function, so that `(3 ^) 2' raises `3' to the power of `2', iow computes the "second power of three"
20:08:56 <jayunit100_4g> oh duh ok
20:09:13 <jayunit100_4g> i did (^3) 3 and (^3) 3, no wonder why i saw identical
20:09:19 <joneshf-laptop> :)
20:09:28 <ski> jayunit100_4g : not identical. the "power"/"exponentiation" operation isn't commutative. in general `x ^ y' isn't equal to `y ^ x'
20:09:35 <joneshf-laptop> hmm
20:10:02 <jayunit100_4g> yup ski , makes sense
20:10:02 <joneshf-laptop> > ((==) <$> (^3) <*> (3^)) 5
20:10:04 <lambdabot>  False
20:10:09 <ski> anyway, `(3 ^)' is called a "left section" of `(^)', while `(^ 3)' is called a "right section" of `(^)'
20:10:13 <joneshf-laptop> much clearer :D
20:10:38 <jayunit100_4g> ah okay, thats what they mean by sections
20:10:43 <ski> you can think of the former as partially applying `(^)' on its left argument so that it still waits for its right one
20:11:04 <ski> and of the latter as partially applying `(^)' on its right argument so that it still waits for its left one
20:11:17 <ski> @type elem
20:11:18 <lambdabot> Eq a => a -> [a] -> Bool
20:12:05 <ski> @type elem 945
20:12:06 <lambdabot> (Num a, Eq a) => [a] -> Bool
20:12:17 <ski> "presupplies" `elem' with its first argument
20:12:35 <ski> > (elem 945) [2,3,4]
20:12:37 <lambdabot>  False
20:12:42 <ski> > elem 945 [2,3,4]
20:12:44 <lambdabot>  False
20:12:55 <ski> > 945 `elem` [2,3,4]
20:12:56 <lambdabot>  False
20:13:02 <ski> > (945 `elem`) [2,3,4]
20:13:03 <lambdabot>  False
20:13:09 <ski> > (`elem` [2,3,4]) 945
20:13:11 <lambdabot>  False
20:13:18 <ski> @type (945 `elem`)
20:13:18 <lambdabot> (Num a, Eq a) => [a] -> Bool
20:13:23 <ski> @type (`elem` [2,3,4])
20:13:24 <lambdabot> (Num a, Eq a) => a -> Bool
20:14:16 <ski> so in the next to last example, we first turned the function into an infix operator, by surrounding it in backticks, then presupplied it with its left argument, getting a left section of the infix operator
20:14:38 <ski> in the last example, we did the same, except we partially applied it to its right argument instead of to its left
20:14:42 <ski> jayunit100_4g : makes sense ?
20:15:38 <trap_exit> what type of 'deliberate practice' can I do to become greater at Haskell ?
20:15:49 <jayunit100_4g> hmmm
20:16:14 <johnw> trap_exit: read, code, try
20:16:32 <trap_exit> do or not do; do not try
20:16:34 <trap_exit> -- yoda
20:16:49 <ski> @type try
20:16:50 <lambdabot> Exception e => IO a -> IO (Either e a)
20:16:59 <ski> @type do not try
20:16:59 <lambdabot>     Couldn't match expected type ‘Bool’
20:17:00 <lambdabot>                 with actual type ‘IO a0 -> IO (Either e0 a0)’
20:17:00 <lambdabot>     Probable cause: ‘try’ is applied to too few arguments
20:17:57 <jayunit100_4g> aha !
20:18:02 <jayunit100_4g> ski:  i see what you mean
20:18:19 <jayunit100_4g> so when i use ` , elem interprets the 1st arg as the LAST arg
20:18:32 <ski> no
20:18:37 <jayunit100_4g> i.e. `elem [1,2]` takes an argument, that will go at the beggining
20:18:53 <jayunit100_4g> so i can do 9 `elem` [9] ,
20:18:54 <ski> > elem 945 [2,3,4]
20:18:56 <lambdabot>  False
20:18:59 <ski> is the same as
20:19:00 <ski> > 945 `elem` [2,3,4]
20:19:01 <lambdabot>  False
20:19:05 <jayunit100_4g> yup
20:19:13 <ski> so "elem interprets the 1st arg as the LAST arg" is not correct
20:19:14 <jayunit100_4g> and in the case that i do a partial :
20:19:43 <jayunit100_4g> :t (`elem` ['a' .. 'z'])
20:19:44 <lambdabot> Char -> Bool
20:20:10 <jayunit100_4g> this is saying ("turn elem into an infix function, and apply the first argument in this function")
20:20:35 <jayunit100_4g> that application is really applying the LAST argument to elem ['a' … 'z']
20:20:52 <jayunit100_4g> and now , when we call the result it will apply the input we provide to the beggining of the inifix elem
20:21:03 <jayunit100_4g> ski: im doing a horrible job explaining this, i realize.
20:21:14 <jayunit100_4g> but i think its clear what your saying !
20:21:35 <ski> jayunit100_4g : no. it's : turn it into an infix *operator*, and partially apply it to  ['a' .. 'z']  as its *right* argument
20:21:56 <jayunit100_4g> yes ski, exactly.
20:22:01 <ski> (so that you get a resulting function that's still waiting for the left argument)
20:22:06 <exio4> I like to think it in terms of type signatures, function ∷ a → b → c; (`function` x) ∷ a → c; (x `function`) ∷ b → c
20:22:24 <ski> > map (`elem` ['a' .. 'z']) ['0','a','A']
20:22:26 <lambdabot>  [False,True,False]
20:22:27 <jayunit100_4g> makes sense … perfect !
20:28:40 <Evan2> Haskell vs SML
20:28:44 <Evan2> Opinions?
20:30:28 <Evan2> :q
20:31:37 * ski blinks
20:32:40 <systemfault> Languages are often like religions for their users... guess what would be the answer in #Haskell :/
20:33:41 <joelteon> yeah, i think SML is better, but I use haskell just 'cause
20:34:07 <texasmynsted> sigh
20:35:07 <texasmynsted> Comparing languages without an object metric is pointless
20:35:18 <texasmynsted> s/object/objective/
20:35:43 <texasmynsted> Haskell or SML for what purpose?
20:36:15 <joelteon> haskell loses in the name shortness competition
20:39:11 <simpson> He already left, guys.
20:48:57 <tabemann> the only supposed advantage of SML to me is that SML has parameterized modules and Haskell does not... except that Haskell type classes are more *practical* in most cases, whereas SML (and OCaml) parameterized modules are not used nearly as much as they could be due to being cumbersome
20:49:29 <dfeuer> @type do not
20:49:31 <lambdabot> Bool -> Bool
20:50:13 <dfeuer> > do not $ False
20:50:15 <lambdabot>  True
21:06:32 <spopejoy> oof. seem to be back to this runtime membership test for an HList, can't get my puny brain around it.
21:08:28 <spopejoy> given data A = A; data B = B; x = hEnd (hBuild A);  i need a typeclass HasA l where hasA :: l -> Bool
21:09:34 <joelteon> ok that won't happen at runtime
21:09:36 <joelteon> it'll happen at compile time
21:09:59 <joelteon> the implementation of hasA will be either "True" or "False"
21:10:07 <spopejoy> but I need my code to go one way for "has A" and another way for "doesn't have A"
21:10:46 <spopejoy> but yes, i suppose it's still compile-time
21:11:13 <spopejoy> but how to branch code paths?
21:11:29 <joelteon> give me a code example, assuming hasA has magically been defined
21:11:35 <RchrdB> joelteon: ...unless you get really unlucky with the optimiser? >_>
21:12:07 <spopejoy> if (hasA) then (add A element to xml output)
21:12:38 <joelteon> well, just add A element to xml output
21:12:40 <joelteon> no if needed
21:13:17 <spopejoy> but I'll have some lists with A, and some without, going into the same "outputter"
21:13:27 <joelteon> where are they coming from
21:14:10 <spopejoy> client code of the "outputter". that client code is bespoke so it knows when it's adding A or not, so it can show up in type signatures.
21:14:36 <joelteon> okay, so two different functions produce things with A and things without
21:14:50 <spopejoy> agreed
21:15:06 <joelteon> ok, so when you use the one that produces A, add A to the xml output, and when you don't, don't
21:16:21 <joelteon> i'm afraid i still don't understand the problem
21:16:25 <kazagistar> wow, HList looks horrifying
21:16:37 <joelteon> you cannot have an expression that, in one case, produces an HList lacking an A, and in another case doesn't
21:16:44 <joelteon> you'll have one or the other
21:16:48 <spopejoy> i agree
21:16:54 <spopejoy> i see what you're getting at.
21:17:43 <dfeuer> What is HList about? It looks huge.
21:18:39 <kazagistar> dfeuer: typesafe heterogeneous lists, apparently
21:18:41 <spopejoy> http://stackoverflow.com/questions/17734182/simple-usage-samples-for-haskell-data-hlist
21:19:26 <adarc> hey, so I want to use the bytestring module from unix-bytestring, but I also require functions from the unix lib.. when I try to import System.Posix.IO.ByteString, both of those libraries export that module.. so it conflicts. Any idea what to do here?
21:20:03 <joelteon> spopejoy: HLists are equivalent to tuples. it does not make sense to write a function that accounts for being passed in either a 2-tuple or a 3-tuple. (in most cases.)
21:20:26 <spopejoy> not exactly.
21:21:01 <spopejoy> for instance, a function with type "(HOccurs A l) => l" can take any HList that has an A
21:21:02 <kadoban> adarc: import one qualified?
21:21:30 <spopejoy> that would be hard to do/impossible with tuples
21:22:02 <joelteon> not really, GHC only supports tuples that have 62 elements or less
21:22:57 <solatis> joelteon: what is the reasoning for that limitation?
21:23:04 <kazagistar> spopejoy: I see your point, but I kinda am struggling to see a purpose... it just seems like there would always be a better way
21:23:10 <joelteon> dunno
21:23:22 <joelteon> it was someone's idea
21:23:59 <kazagistar> "if your tuples are more then 62 long you are almost certainly doing some seriously crazy shit"?
21:24:02 <lisbeth> I am having trouble understanding if then statments as functions
21:24:06 <lisbeth> I can do
21:24:10 <adarc> kadoban: ya, but, cabal is complaining that it doesn't know which module I want to use:
21:24:10 <lisbeth> function1 (function2 3)
21:24:13 <adarc> src/ZTail/TailHandle.hs:11:18:
21:24:13 <lisbeth> bu I wouldn't do
21:24:15 <adarc>     Ambiguous module name ‘System.Posix.IO.ByteString’:
21:24:18 <adarc>       it was found in multiple packages:
21:24:20 <adarc>       unix-bytestring-0.3.7.2 unix-2.7.0.1
21:24:22 <solatis> yeah and i read here that Eq, Show, etc have  limit of 15
21:24:23 <lisbeth> if 4 == 2 (then 2)
21:24:30 <lisbeth> or would I?
21:24:32 <adarc> both of those packages export the same module, but unix is String, unix-bytestring is Bytestring.. same module name though
21:24:39 <adarc> which i've never seen before
21:24:40 <solatis> kazagistar: that sounds reasonable :)
21:24:55 <kadoban> Oh, hmm. Yeah I'm not sure about that.
21:25:04 <joelteon> adarc: PackageImports
21:25:10 <Arahael> Why would 'ByteString' be OS-dependant?
21:25:15 <kazagistar> lisbeth: if statements are not functions, they are an expression, so their syntax is a little different
21:25:22 <spopejoy> joelteon: I mean that the polymorphism of HList allows me to say "an HList of any size that has an A", whereas you can't write a type signature that says "a tuple of any dimension where there's exactly one A"
21:25:25 <lisbeth> kazagistar, ah thank you
21:25:44 <lisbeth> finally, how would I denote new conditions in the clauses of if and then
21:25:45 <joelteon> superjudge: to be even more strictly correct, you can absolutely write the second one; the first just makes it easier
21:25:48 <lisbeth> as in multiple conditions for if to be true
21:25:54 <lisbeth> and multiple results for then to be true
21:25:57 <lisbeth> just newline?
21:25:58 <adarc> joelteon: thanks that solves it.. thanks as well kadoban
21:26:03 <adarc> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#packageimports
21:26:06 <adarc> cool
21:26:18 <dfeuer> kazagistar, having Oleg Kiselyov in the list of authors does not bode well for my chance of understanding it.
21:26:23 <pic> I have a problem with some type level stuff. I don't know if anyone is interested or knows how to solve this problem. So I have two GADTs: (data Inst a where; FOO :: (Or at bt ct) => Bar at -> Bar bt -> Inst ct) and (data Bar a where; BAZ :: Int -> Bar True; BUZ :: Int -> Bar False) the issue is that I have a function that is Inst True -> Bar True and the compiler is having a hard time proving that the extracted Bar is Bar True
21:26:25 <kazagistar> lisbeth: you probably want to use a "case" statement instead of an "if" statement
21:26:55 <lisbeth> kazagistar, ok I'll keep that in mind as I read learn you haskell
21:26:56 <lisbeth> thanks
21:27:15 <dfeuer> pic, lpaste that. It's completely unreadable.
21:27:38 <pic> Err sorry I don't use lpaste much. You want me to do what?
21:27:38 <solatis> > GHC.Exts.maxTupleSize
21:27:39 <lambdabot>  Not in scope: ‘GHC.Exts.maxTupleSize’
21:27:53 <spopejoy> joelteon, thanks though, it is worth thinking through how to use the code that knows the type to invoke the code that doesn't.
21:28:30 <lisbeth> kazagistar, or as I just realized my then statement could just be a function
21:28:33 <dfeuer> pic, go to http://lpaste.net/ , select Haskell and #haskell and enter your nick and a title. Paste the (properly indented) code in the big box.
21:29:13 <dfeuer> When you click the "private" button (probably the "public" one too, it'll paste a link here for us.
21:29:20 <kazagistar> :t bool
21:29:21 <lambdabot> a -> a -> Bool -> a
21:29:23 <dfeuer> If it doesn't, you can paste it yourself.
21:29:43 <spopejoy> dfeuer: in my case, I can write a library for a n-ary tree datastructure, where the nodes are GADT records, one of which is an HList. The defined records are used everywhere. The HList is for client-specific stuff that the library will never see.
21:29:53 <dfeuer> bool "falsebranch" "truebranch" True
21:29:56 <dfeuer> > bool "falsebranch" "truebranch" True
21:29:58 <lambdabot>  "truebranch"
21:30:08 <spopejoy> dfeuer: but my client-specific code can still be typesafe.
21:30:31 <spopejoy> not use Typeable or (worse) existential-type-antipattern stuff.
21:31:10 <spopejoy> GADT records where one *field* is a HList, sorry.
21:31:19 <dfeuer> spopejoy, zooom over my head. Why is that thingum an HList? I mean ... why not just let it be *anything* the client wants?
21:31:37 <spopejoy> well, it is actually
21:31:54 <dfeuer> OK, so the client is sticking an HList in there?
21:31:55 <spopejoy> but there's a bunch of convenience functions to use an HList with well-known annotations
21:31:56 <dfeuer> Why?
21:32:18 <spopejoy> as in "you may define your own, but there's also these canonical ones to use"
21:32:37 <dfeuer> So does that make it kind of like Generic?
21:32:41 <spopejoy> yes.
21:32:59 <spopejoy> but Typeable results in lots of Maybe pattern matches, as I see it.
21:33:04 <dfeuer> (I have thus far not been able to understand anything about Data.Generic)
21:33:13 <spopejoy> I'd rather my code not compile, than have Nothings show up.
21:33:17 <dfeuer> Yes.
21:33:29 <lpaste> pic pasted “Type Level Issues” at http://lpaste.net/112467
21:33:29 <dfeuer> That sounds nice, I suppose.
21:34:07 <lpaste> pic pasted “Type Level Issues” at http://lpaste.net/112468
21:34:46 <pic>  Okay I think the second one is correct.
21:36:01 <redtricycle> how do I bypass SSL with http-conduit?  I've tried using this managerSetting like this: http://stackoverflow.com/questions/14863235/where-is-the-breaking-change
21:36:03 <pic> Not sure what to do here or if what I want is possible
21:36:53 <dfeuer> pic, what are your imports?
21:36:57 <dfeuer> What is this Or typeclass?
21:37:11 <pic> import Data.TypeLevel.Bool
21:37:16 <pic> Sorry I forgot
21:37:19 <dfeuer> I know very little about any of these things, but making the example complete is helpful.
21:37:36 <pic> It's a lot of code. I think this is the gist of what's going on.
21:40:02 <layers> Are quotient types and difference types useful? Where can I read about them?
21:41:20 <dfeuer> pic, it sounds like you're doing crazy stuff. I think the crazy-stuff type theory people may have gone to sleep. You will find them here just about every day, however.
21:44:24 <pic> Okay. :/
21:44:26 <pic> Thanks
21:45:02 <kadoban> Haha
21:57:16 * hackagebot cairo 0.13.0.3 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.3 (HamishMackenzie)
21:58:23 <ddellacosta> so, Foldable's foldMap is kind of a like "safe foldr," via the Monoid laws?
21:58:52 <ddellacosta> I realize that may be a pretty idiosyncratic way to describe it, I'm just trying to build up some intuition about how it works now
22:01:45 <ddellacosta> "safe" is probably the wrong word, what I'm talking about has more to do with the guarantees that associativity of Monoids give you
22:15:26 <nitrix> Hi, I have a data type that is simply two functions.
22:15:59 <nitrix> I then have a function that just creates me an object with those two functions implemented.
22:16:24 <nitrix> Before, it used to be the name of another function I'd put there, but I decided to replace that by a lambda.
22:17:17 * hackagebot gio 0.13.0.1 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.0.1 (HamishMackenzie)
22:17:25 <nitrix> Now I get an error on......... nevermind.
22:17:27 <nitrix> Fixed it.
22:19:08 <nitrix> I still don't like those commas at the end of my lambdas though
22:19:15 <kazagistar> nitrix: glad I could help, here is my picture http://9m.no/묩䩗
22:20:41 <kazagistar> nitrix: wouldn't the commas be before your lambdas? I thought that was the standard style
22:22:17 * hackagebot pango 0.13.0.2 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.2 (HamishMackenzie)
22:28:07 <redtricycle> Can I "freeze" the list of package versions?  I have a cabal file that compiles on my Mac, but I can't get it to compile on my LInux box
22:28:10 <redtricycle> I'm using a sandbox
22:28:30 <redtricycle> so cabal sandbox init, cabal install -j --max-backjumps=-1 is what I'm using
22:28:42 <redtricycle> I keep running into dependency errors
22:28:43 <redtricycle> is what I mean
22:28:58 <nitrix> kazagistar: http://ideone.com/ve4d20
22:29:12 <nitrix> kazagistar: That'd be the current form. Any style recommendation then?
22:30:37 <kadoban> redtricycle: Well, you can lock the versions of packages that you depend on in the cabal package. There's also Stackage, if that helps you at all.
22:30:59 <nitrix> Also, does that make sense to isolate the IOError as close to the action as possible, so that I can only work with Maybe strings in some places, to eventually only have strings in my application?
22:31:15 <nitrix> I really really enjoy the Maybe monad, but maybe that isn't idiomatic.
22:32:51 <ski> ddellacosta : sortof, i suppose
22:33:28 <ski> ddellacosta : basically, it extracts a list of the elements, maps the given function on them, and uses the monoid to smash them together
22:33:36 <ski> @type ((mconcat .) . (. F.toList)) . map
22:33:37 <lambdabot> (Monoid c, Foldable t) => (a -> c) -> t a -> c
22:33:43 <ski> @type foldMap
22:33:45 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:35:04 <ddellacosta> ski: hmm, okay. I'm feeling about in the fog now, trying to develop a better intuition for it (I like "smash" by the way...haha). Thanks for that, I'll have to give your first example some thought and read up some more.
22:36:08 <ski> ddellacosta : if you specify the monoid to be `Endo b', then it will behave as `foldr'. if you specify it to be `Dual (Endo b)', the it will behave like `foldl'
22:36:13 <ski> s/the it/then it/
22:36:47 <ski> ddellacosta : in any case, i think all of the `Foldable' operations can be generically defined, in terms of `toList'
22:36:48 <ddellacosta> I guess, because Dual is just a flip (right?) that makes sense
22:37:08 <ddellacosta> huh
22:37:10 <ski> `Dual (Endo b)' flips the order in which the functions are composed, yes
22:37:14 <ddellacosta> interesting...
22:37:51 <Axman6> so mappend (Dual a) (Dual b) = Dual (mappend b a)
22:37:53 <ski> `Foldable' only cares about the ordering of the elements
22:38:15 <kazagistar> nitrix: here is the way I tend to fill records, but really it does not matter much either way http://ideone.com/X2Z1RO
22:39:04 <ski> (and we can say this because we're only to use an actual monoid (whose operation is associative) with `foldMap',&c.)
22:39:22 <ski> hiya Axman6
22:39:26 <Axman6> o/
22:40:18 <Axman6> so: how're you?
22:42:12 <kazagistar> from Foldable, the default implementation of generic foldr
22:42:14 <kazagistar> { foldr f z t = appEndo (foldMap (Endo . f) t) z }
22:51:17 <ski> Axman6 : well enough, i suppose
22:51:42 <Axman6> heh, good to hear I guess? :P
22:51:43 * ski 's been pondering "structure levels"
22:52:31 <ski> which is supposed to be a way to refer to specific instances of collections, *without* including the elements themselves
22:53:21 <augur> ski: structure levels eh
22:53:24 <augur> tell us more!
22:53:45 <ski> so, e.g. instead of having a variable `nss' representing a list of list of integers, i would have two variables `l0' and `l1' representing the outer and inner list structures, and a variable `n' representing the integers
22:54:30 <ski> mostly my motivating examples so far have been laws like e.g.
22:54:48 <ski>   sum (map sum nss) = sum (concat nss)
22:55:01 <ski> which i want to reformulate as
22:55:20 <ski>   sum (l0,sum (l1,n)) = sum (concat (l0,l1),n)
22:55:29 <lpaste> wei2912 pasted “Counting inversions” at http://lpaste.net/112469
22:55:40 <ski> or, e.g. the law
22:55:42 <wei2912> how do i reduce the amount of data being copied in my code above?
22:55:48 <wei2912> (as lpaste linked to)
22:56:15 <ski>   concat (concat xsss) = concat (map concat xsss)
22:56:20 <ski> would be rephrased as
22:56:40 <ski>   concat (concat (l0,l1),l2) = concat (l0,concat (l1,l2))
22:57:19 * hackagebot gtk3 0.13.0.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.0.2 (HamishMackenzie)
22:57:41 <ski> imho, the reformulations more clearly expresses how the various "structure levels" are manipulated -- which could otherwise perhaps be illustrated with some diagrams with arrows
22:58:03 <augur> ski: "and a variable n representing the integers" i'd like to see more of what you mean by this
23:04:42 <ski> augur : if we start with `ns' standing for `[0,1,2,3]', then we could roughly think of (conceptually) separating this into `l' standing for `[?,?,?,?]' (`?' representing the "element holes", where we haven't specified the actual elements) and `n' standing for `0',`1',`2',`3' (you might perhaps think of `n' as being a "plural")
23:06:37 <ski> augur : for `nss' being e.g. `[[],[0],[1,2],[3,4,5],[6,7,8,9]]', we'd get `l0' being `[?,?,?,?,?]', `l1' being `[]',`[?]',`[?,?]',`[?,?,?]',`[?,?,?,?]', and `n' being ; `0' ; `1',`2' ; `3',`4',`5' ; `6',`7',`8',`9' (a "doubly plural", if you will)
23:07:18 <ski> .. and obviously this isn't supposed to be restricted just to lists, but to functors in general
23:07:19 * hackagebot gtk 0.13.0.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.0.2 (HamishMackenzie)
23:07:23 <augur> ski: i was waiting for the plurality :)
23:07:29 <augur> thats what i was mostly interested in
23:07:44 <ski> hehe, i was suspecting you'd react on it :)
23:07:50 <augur> <3
23:08:12 <ski> (i think of it arising from a conceptual "of course" on the type level)
23:08:20 <augur> im not sure how you'd implement this tho
23:09:06 <augur> ski: i feel like maybe what you want is to have some kind of contexts actually
23:09:48 * ski awaits elaboration
23:10:12 <augur> like, so you can actually write something like   K{_} = [_,_,_,_]   for your structure level
23:11:00 <augur> and then you can say  that like.. concat K{_} (concat L{_} M{_}) = concat (concat K{_} L{_}) M{_}
23:13:21 <ski> hm
23:13:41 <ski> i don't think these would be ordinary "multi-contexts"
23:13:44 <augur> and, incidentally, an actual value just happens to be a context with no holes
23:14:04 <augur> ski: indeed not, they'd be .. parallel contexts, or something
23:14:21 <augur> thats where im not sure about it, but
23:14:27 <ski> (by which i mean, a context where the hole may be repeated. but where the plugging operation would then duplicate the plugged term)
23:14:45 <augur> i think if you could write something like this:   concat K{_} L{_} = K{L{_}}
23:14:50 <augur> it would be interesting
23:14:59 <augur> and it would make the equation manifest
23:15:28 <ski> anyway, this led me into looking into (right) Kan extensions
23:15:43 <augur> concat K{_} (concat L{_} M{_}) = concat K{_} L{M{_}} = K{L{M{_}}} = concat K{L{_}} M{_} = concat (concat K{_} L{_}) M{_}
23:16:20 * ski nods
23:16:49 * ski . o O ( <https://en.wikipedia.org/wiki/Operad_theory> )
23:17:02 <augur> ski: but i dont quite know how you'd want to precisify this plurality stuff
23:17:14 <ski> i don't know yet, either
23:17:21 <augur> maybe with some notion of enumeration as inherent?
23:17:39 <ski> i'm just following an idea, and it led me to this plurality concept
23:17:52 <augur> but, i think once you have that, it should generalize easily enough so that plural contexts are a special case
23:18:08 <augur> a plurality of contexts, each with a plurality of holes
23:18:21 <ski> i'm not sure what you mean by "notion of enumeration as inherent"
23:18:42 <ski> re ddellacosta
23:18:57 <augur> ski: well, you want the plurality of values to associate with the right holes
23:19:11 <ski> yes
23:19:30 <augur> so you need some way to enumerate the n-th value into the n-th hole
23:19:42 <ski> hm .. possibly
23:21:12 <augur> ski: also possibly worth thinking about is, lens-y structure here gives you a kind of abstract way of going from hole to hole
23:21:34 <augur> so maybe you can actually phrase this in some vaguely lense-traversal-y way
23:21:39 <ski> (hm, i must have left my notes on this as bookmarks in MacLane ..)
23:22:17 <ski> hm. ty for the suggestion
23:23:29 * ski forgets whether the thing where you replace `Functor' with `Applicative' in the lensy stuff is named a "traversal" or something else
23:23:42 <augur> at the least, you could maybe use that to guide the thought process for grounding it in more foundational things
23:24:02 <augur> ski: presumably actually all applicatives are traversable
23:25:07 <augur> ski: Conor mentioned in his oplss 2010 lectures that traverse is just (f)map but in idiom brackets
23:25:18 <augur> which is true atleast for lists
23:25:34 <augur> traverse f [] = iI [] Ii
23:25:49 <augur> traverse f (x : xs) = iI f x : traverse f xs Ii
23:26:42 <augur> if Haskell used first class data decl's you could define traverse once and for all :(
23:32:46 <ski> ok, the thing i was thinking about was `forall f. Functor f => (b -> f b) -> (a -> f b)' as a representation of a lens from `a' to `b'. and where if we instead take `forall i. Applicative i => (b -> i b) -> (a -> i a)', perhaps this was what was called a "traversal" ?
23:34:09 <ski> augur : hm, i suppose one could possibly write some TH to derive it
23:34:13 <augur> oh that. something like that happens. dont know what it is. :)
23:34:24 <ski> not sure of the limits of applicability of it, though
23:34:45 <augur> i really dislike TH as a thing
23:34:52 <augur> it really is a bandaid
23:35:18 <ski> anyway, `Applicative' is "monoidy" in a sense, just like this notion plurality
23:35:54 <ski> augur : i haven't gotten enough into it to judge how much i like it or not ..
23:36:14 <ski> s/notion/notion of/
23:37:17 <ski> anyway, i still don't know what adjoints of post-partially-composed functors are :(
23:37:45 <augur> ski: lmfao
23:37:50 <ski> (adjoints of *pre*-partially-composed functors is exactly what Kan extensions are, though i don't have much of a feeling for those yet, either)
23:39:20 <ski> a right Kan extension is sortof an exponential for functors, enabling "currying" for natural transformations
23:42:11 <ddellacosta> ski: sorry, was eating lunch, missed your msg
23:42:21 * hackagebot gtksourceview3 0.13.1.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.0 (HamishMackenzie)
23:43:44 * ddellacosta goes to look at #haskell logs
23:47:21 * hackagebot gtksourceview2 0.13.1.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.13.1.0 (HamishMackenzie)
23:47:28 <ski> ddellacosta : np
23:48:46 <redtricycle> Six minutes and still running to resolve dependencies?  Is this normal?
23:48:55 <redtricycle> cabal install -j --max-backjumps=-1
23:49:22 <joe-> cabal is so broken
23:56:01 <paquari> I’m trying to figure out how to write arbitrary instances for my regular expression type.  See https://github.com/matthiasgoergens/redgrep/blob/master/Red.hs
23:56:15 <paquari> I guess GADTs are not for the faint of heart.
