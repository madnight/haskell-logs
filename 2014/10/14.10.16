00:00:05 <dmj`> > take 2 $ [1,2,3] >>= \x -> return (x+1)
00:00:06 <lambdabot>  [2,3]
00:00:18 <dfeuer> > concat (map (\n -> [1..n]) [1..5])
00:00:20 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
00:00:42 <dfeuer> > head $ concat (map (\n -> [1..n]) (1:undefined))
00:00:44 <lambdabot>  1
00:00:51 <gigabytes> dfeuer: compiler smartness apart, doesn't concat have to rebuild every list while appending?
00:01:06 <gigabytes> if it's something like foldr (++) []
00:01:28 <dfeuer> gigabytes, well, it depends. Sometimes, but that can still be lazy.
00:01:53 <dfeuer> That reminds me that concatMap needs some improvements.
00:01:57 * dfeuer is sleepy.
00:02:24 <gigabytes> dfeuer: so I would have to wait not for the entire concatenated list but for chunks, it depends on the lists being concatenated?
00:02:38 <dfeuer> gigabytes, in Haskell, we often actually build lists from front to back.
00:02:47 <dfeuer> Because of laziness.
00:02:57 <gigabytes> dfeuer: what do you mean?
00:03:30 <dfeuer> Well,I'm falling asleep.
00:03:39 <dfeuer> So I can't really explain it properly right now.
00:03:46 <gigabytes> dfeuer: ahah don't worry :)
00:03:47 <dfeuer> Tomorrow, or you can find someone else!
00:03:56 <dfeuer> NIGHT.
00:03:58 <gigabytes> thank you very much :)
00:08:48 <jle`> @src concat
00:08:48 <lambdabot> concat = foldr (++) []
00:08:59 <jle`> @src foldr
00:08:59 <lambdabot> foldr f z []     = z
00:08:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:13:38 <gigabytes> @src concatMap
00:13:38 <lambdabot> concatMap f = foldr ((++) . f) []
00:17:00 <_rai> @src words
00:17:00 <lambdabot> words s = case dropWhile isSpace s of
00:17:00 <lambdabot>     "" -> []
00:17:00 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:18:04 <solatis> dammit, logging in haskell is just a hell
00:19:02 <solatis> you're either have spaghetti monads or are limited to only printing out function arguments
00:21:47 <gigabytes> The monad instance of Data.Sequence does the same thing as the list monad, only with Seq?
00:24:31 <trap_exit> I have a dream.
00:24:38 <trap_exit> One day programs will not be judged by what langauge they are written in.
00:24:43 <trap_exit> Because everything will be written in Haskell.
00:24:45 <trap_exit> The end.
00:25:02 <tdammers> Haskell is not a sufficient Haskell
00:25:40 <tdammers> there are still some worldly things in it
00:26:30 <trap_exit> what odes that even mean?
00:26:33 <trap_exit> haskell is not a sufficeint haskell ?
00:34:34 * hackagebot system-canonicalpath 0.1.2.0 - Abstract data type for canonical paths with pretty operations  http://hackage.haskell.org/package/system-canonicalpath-0.1.2.0 (d12frosted)
00:34:36 * hackagebot deepseq 1.3.0.2 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.3.0.2 (HerbertValerioRiedel)
00:39:19 <rola> For the applicative and bind instances in NICTA/Course.State https://github.com/tonymorris/course/blob/master/src/Course/State.hs , is there a nice idiom to write the instances w/o let or where?
00:43:51 <jle`> rola: let/where is typical in this case
00:44:22 <jle`> let in particular is probably the most expressive version
00:44:31 <merijn> You could use case if it made you happy
00:44:34 * hackagebot learning-hmm 0.1.0.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.1.0.0 (mnacamura)
00:44:50 <jle`> you could probably do it with tuple manipulating functions if you wanted it point free but why
00:44:53 <merijn> "case k s of (a, t) -> (f a, t)"
00:44:59 <rola> eh
00:45:16 <rola> i'll stick with let/in
00:45:27 <jle`> @pl \s -> let (g, t) = f s; (z, u) = a t in (g z, u)
00:45:27 <lambdabot> (line 1, column 11):
00:45:27 <lambdabot> unexpected "("
00:45:27 <lambdabot> expecting "()", natural, identifier or "in"
00:46:05 <rola> does @pl support let
00:46:50 <jle`> @pl \s -> let x = s in x
00:46:50 <lambdabot> id
00:46:53 <jle`> i guess so
00:47:10 <jle`> i probably just got the formatting wrong
01:24:26 <dmj`> @src atomically
01:24:26 <lambdabot> Source not found.
01:34:43 <jle`> is Alternative the only way i can get "Traversables that can be combined/merged"
01:34:45 <jle`> ?
01:34:56 <jle`> besides MonadPlus of course
01:35:22 <jle`> if i had two values of a Traversable instance and wanted to merge them into one
01:35:29 <jle`> with the same behavior as (<|>)
01:35:36 <prinsen> is there any parsec function for parsing a grammar like MemberExpression: MemberExpression [ Expression ] | ...
01:36:08 <hyPiRion> prinsen: do a left factoring of the syntax first
01:37:54 <hyPiRion> It's actually straightforward, as long as you understand the algorithm
01:37:58 <prinsen> hyPiRion: will read up on that
01:39:01 <hyPiRion> prinsen: I think this should get you to your goal: http://en.wikipedia.org/wiki/Left_recursion
01:40:10 <prinsen> hyPiRion: already on that page :)
01:40:14 <hyPiRion> :)
01:40:19 <qsuscs> in GHCi, can i "un-let" variables/functions?
01:54:52 <bernalex> is there a take for Foldables?
01:55:50 <bernalex> hoogle "Foldable f => Int -> f a -> f a"|wc -l
01:55:52 <bernalex> 698
01:55:59 <bernalex> I assume I'm doing something very wrong with my search
01:57:56 <hyPiRion> bernalex: I don't think take makes sense for foldables
01:58:09 <bernalex> hyPiRion: I don't think so either really.
01:58:30 <hyPiRion> consider data Pairs a = Single a | Pair (Pairs a, Pairs a)
01:58:41 <hyPiRion> there's no way to take "take 1" on it
01:58:49 <hyPiRion> err
01:58:59 <hyPiRion> Single (a, a) I meant
01:59:15 <Intolerable> is there any weirdness w/ the monomorphism restriction when binding functions in patterns?
01:59:30 <Intolerable> i have a function that gets stuck on one type after i use it once after binding it
01:59:49 <bernalex> hyPiRion: well come to think of it, doesn't Foldables need to implement toList?
02:00:38 <hyPiRion> bernalex: no, only foldMap or foldr, although you can derive toList from that
02:00:51 <bernalex> hyPiRion: that's what I mean. they all *get* toList I think.
02:01:10 <prinsen> hyPiRion: This is what I came up with http://lpaste.net/112680
02:01:45 <hyPiRion> bernalex: So you can get a list back, but you cannot get the original foldable from it
02:02:09 <bernalex> hyPiRion: oh yeah there's not a fromList, fair point
02:04:27 <hyPiRion> prinsen: looks alright from what I can see, although I don't know how primExpr or funcExpr works
02:05:32 <prinsen> hyPiRion: They can be string in this case. This code only works 1 level touht. It parses a[1] but not a[1][2]
02:07:05 <hyPiRion> prinsen: ah, I see what you're trying. Sec, let me see what I would do here
02:08:05 <prinsen> hyPiRion: here is the  grammar just in case: http://lpaste.net/112681
02:09:52 <Intolerable> whats the best way to fix this? http://lpaste.net/6765100956133621760
02:10:44 <bernalex> hmmm
02:10:49 <bernalex> how would you write mappend <$> (Just "test") <*> (Just "lol") with <>? lol
02:10:58 <bernalex> and liftM2 (++) is cheating
02:14:20 <bernalex> err liftM2 (<>)
02:14:56 <hexagoxel> (<>) <$> Just "Test" <*> Just "lol"
02:15:08 <bernalex> hexagoxel: yeah I could just prefix it
02:16:57 <bernalex> flip ((<*>) . ((<>) <$>)) lol
02:17:40 <ClaudiusMaximus> > (Just "Test" <> Just "lol") == (mappend <$> (Just "test") <*> (Just "lol"))
02:17:41 <lambdabot>  False
02:17:58 <bernalex> oh derp
02:18:03 <bernalex> (<*>) . ((<>) <$>)
02:18:14 <ClaudiusMaximus> > (Just "test" <> Just "lol") == (mappend <$> (Just "test") <*> (Just "lol")) -- oops, caps
02:18:15 <lambdabot>  True
02:19:14 <jle`> what's wrong with liftA2 ?
02:19:24 <jle`> i prefer it to (<$>)/(<*>) :P
02:19:36 <jle`> but also you can just do (<>)
02:19:43 <jle`> because of the Monoid instance for Maybe
02:20:29 <ClaudiusMaximus> Intolerable: gString <- f ; gInteger <- f -- probably best to just do this, I tried some experiments with RankNTypes but couldn't get it to work
02:20:30 <jle`> oh wait, no, it's slightly different
02:21:02 <jle`> actually it's very different
02:23:18 <bernalex> jle`: hm?
02:23:44 <dibblego> if one is not Just, it will give you nothing in the original case, but not using only (<>)
02:23:44 <bernalex> λ Just "hallo, " .++ Just "world"
02:23:46 <bernalex> Just "hallo, world"
02:23:52 <bernalex> dibblego: ah
02:24:29 <bernalex> dibblego: wait what?
02:24:36 <jle`> > Just "hello" <> Nothing
02:24:38 <lambdabot>  Just "hello"
02:24:46 <jle`> > liftA2 (<>) (Just "hello") Nothing
02:24:47 <lambdabot>  Nothing
02:24:58 <bernalex> maybe I have my definitions wrong in ghci
02:26:05 <bernalex> yeah. of course. what dibblego said maid sense. then I ran it in ghci and it produced... counterintuitive results. but I had my bindings wrong. all good again. :-]
02:27:40 <prinsen> hyPiRion: Think I did it :)
02:27:57 <jle`> maybe imbues any semigroup with a lawful Monoid instance...does that make Maybe a free monoid of sorts over semigroups?
02:28:02 <jle`> i don't know anything about anything
02:28:05 <tdammers> I need some input... I'm writing an "ID List" data structure, which behaves a bit like an SQL table with an auto-incrementing integer key
02:28:15 <prinsen> hyPiRion: http://lpaste.net/112683
02:28:36 <tdammers> it's not rocket science, but I'm wondering what the right type signature would be for an update function
02:29:03 <tdammers> it's supposed to overwrite an existing entry if it exists, but I'm not sure what it should do if the key doesn't exist
02:30:03 <tdammers> I'm writing monadic versions of those functions first, in a State, so right now I have something like this:
02:30:32 <tdammers> updateM :: MonadState (IDList k v) => k -> v -> m ?
02:30:43 <tdammers> and I'm wondering what should go in the place of that ?
02:32:53 <hyPiRion> prinsen: Yeah, that's the idea. https://www.refheap.com/91835 is what I came up with on the go now.
02:33:19 <hyPiRion> I have something like the latter thing in production, which works fine and is easy to extend when you grok it
02:35:08 <prinsen> hyPiRion: Thanks! Funny how similar our solutions are
02:35:26 <hyPiRion> np, and good luck with whatever you are working on :)
02:36:06 <jle`> tdammers: how about m Bool?  for if there was an overwrite or not?
02:36:17 <jle`> or are you looking for an answer drawing from precedence
02:36:21 <jle`> precednts
02:36:24 <jle`> precedents
02:36:32 <tdammers> jle`: I am pondering Bool, but it feels dirty
02:36:55 <jle`> how about (Maybe v) ?
02:37:03 <tdammers> hmm
02:37:12 <tdammers> yeah... yeah, that could work
02:37:21 <bernalex> tdammers: bools are ungood
02:37:37 <tdammers> bernalex: yes, I am aware of the ideological reasonings
02:38:07 <bernalex> I would go with Either or Maybe or some type like that
02:38:11 <tdammers> data IDListUpdateResult = UpdateOK | KeyDoesNotExist -- ugh
02:38:16 <jle`> lol
02:38:25 <tdammers> thing is, returning the original value seems kind of pointless
02:39:05 <tdammers> there are only two possible outcomes - something has been updated, or it hasn't
02:39:05 <bernalex> sounds like something that will be pointful at some point into the future :-]
02:39:27 <jle`> if you return the original value, it coudl double as a lookup function
02:39:49 <bernalex> maybe in some function where you want to update and then do something else so you want to case updateM foo of a-value -> bleurgh; Nothing -> ohno!;
02:39:53 <tdammers> jle`: how so? it overwrites the original value...
02:39:58 <jle`> oh, yes
02:40:02 <jle`> :|
02:40:05 <tdammers> but you have a point
02:40:17 <tdammers> I could generalize lookup and modification into the same thing
02:40:22 <jle`> it might be interesting to know what it used to be
02:40:31 <jle`> just for fun
02:40:38 <jle`> i can't think of what other useful information would go in there though
02:40:49 <tdammers> well, I'm thinking...
02:40:56 <jle`> but the `v` is really the only information that is "missing"
02:40:59 <jle`> it's lost forever
02:41:06 <jle`> unless you return it
02:41:08 <tdammers> modifyM :: MonadState (IDList k v) => k -> (v -> v) -> m v
02:41:40 <tdammers> or rather:
02:41:45 <tdammers> modifyM :: MonadState (IDList k v) => k -> (v -> v) -> m (Maybe v)
02:42:08 <tdammers> and then I can derive both the lookup and the overwrite from that
02:42:12 <jle`> with the new one?
02:42:15 <tdammers> yeah
02:42:31 <tdammers> lookup passes id for the update function
02:42:41 <tdammers> overwrite wraps the new value in const
02:42:46 <jle`> but you can't add witht hat, right?
02:42:50 <tdammers> no
02:42:51 <jle`> *insert
02:42:57 <jle`> but you weren't looking for an insert
02:43:01 <tdammers> no, I have an insert
02:43:04 <jle`> ah
02:43:05 <tdammers> it returns the key
02:43:08 <tdammers> which makes sense
02:43:10 <jle`> mhm
02:43:17 <tdammers> because that's the only thing you can't derive from outside
02:44:56 <prinsen> hyPiRion: A ECMA-262 interpreter \o/
02:45:37 <gbhwqo> does one knows webpage where people posts their homeworks and projects in math to be solved by someone who will be paid?
02:45:59 <Kinnison> if we did, we wouldn't advocate using it and thus would not promulgate its location
02:46:06 <tdammers> gbhwqo: what would be the point of that? so that people can pay money to avoid learning valuale skills?
02:46:16 <jle`> it's also most likely not a suitable question for #haskell
02:46:20 <jle`> where we talk about...well, haskell
02:46:31 <Enigmagic> gbhwqo: lemon party
02:47:10 <ddellacosta> that's just mean
02:47:11 <gbhwqo> is there such page?
02:47:30 <gbhwqo> I want to see what type of problems student put there
02:47:41 * tdammers finds it peculiar how people pay a truckload of money to participate in an educational program, and then want to pay more money to not actually follow it
02:48:14 <ddellacosta> gbhwqo: I doubt you're going to get good answers here, as I think most folks are probably intellectually opposed to the idea.  In addition, it's not really on-topic for #haskell.
02:48:16 <jle`> tdammers: sometimes the degree (the piece of paper) is what they are paying for, so the extra money is just extra costs
02:48:25 <ddellacosta> per what jle` already said
02:48:58 <jle`> i don't think i would say that i am morally opposed to the idea, but it is definitely 100% off topic in every conceivable way as it is currently stated, so you will have better luck taking it elsewhere :)
02:49:08 <ddellacosta> right, fair enough
02:50:21 <sgronblo> i wouldnt say 100% off topic :)
02:50:46 <sgronblo> at least there is a connection between math and haskell *)
02:51:40 <jle`> :)
02:51:50 <jle`> does anyone know why there isn't a Data.Foldable.null ?
02:53:15 <jle`> i guess i could just do null . toList
02:53:27 <jle`> isn't Data.Foldable.length coming in 7.10 ?
03:05:56 <prinsen> Im really stuck by the fact that try (p1) <|> p2 fails while p2 <|> p1 succeds in a Parsec parser. Why can this be?
03:08:12 <Cale> prinsen: that's interesting
03:08:46 <prinsen> Cale: indeed!
03:09:50 <prinsen> Cale: It should be impossible right?
03:09:57 <Philonous> prinsen, p1 might consume tokens before failing, try replacing it with (try p1)
03:10:00 <Axman6> seems like it to me...
03:10:09 <Cale> Philonous: he's using try p1 already...
03:10:18 <Philonous> Oh, right
03:10:22 <Philonous> Didn't see that
03:10:24 <Axman6> but it already is (try p1) <|> p2
03:11:06 <felixn> prinsen: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/ this may help
03:11:17 <prinsen> felixn: Yes I got that link before :p
03:11:54 <felixn> prinsen: though in practice I don't try to make sense, and just slather on the `try`s to make my tests pass ... though order of <|> has always been important
03:12:11 <prinsen> But the grammar is LeftExpr = NewExpr | CallExpr
03:12:56 <prinsen> and thus i threw on a try
03:14:50 <prinsen> Can it be a bug n parsec?
03:19:11 <bernalex> how can I in ghci eval something without printing it, but definitely eval it?
03:19:36 <prinsen> Cale: ?
03:20:12 <zwer> something `seq` return ()  ?
03:20:32 <ClaudiusMaximus> bernalex: deepseq thing (return ()) perhaps
03:20:44 <felixn> prinsen: post a gist demonstrating the issue you're having for better feedback!
03:21:19 <bernalex> ClaudiusMaximus: return is not necessary, but yeah I was thinking about deepseq because `seq` is a bit meh.
03:21:26 <ddellacosta> not specifically #haskell, although I'm working through opqdonut's haskell exercises so I think I can fudge it: I'm trying to come up with a more efficient algorithm for computing minimum divisibility of a number than the dumb O(n) recursive version I've got now. Anyone have any suggestions/pointers?
03:21:30 <ClaudiusMaximus> bernalex: without return it will print ()
03:21:52 <bernalex> yeah but that's kind of /care for me
03:23:43 <Cale> prinsen: I suppose it's possible
03:23:54 <prinsen> felixn: its a parser for the whole ECMA-262 on 1k lines
03:31:20 <prinsen> Cale: felixn Found the bug
03:32:02 <prinsen> Cale: felixn Im not enforcing eof until after, so the first parser succeeds, but doesn't read everything
03:32:24 <Cale> prinsen: ah
03:32:54 <ddellacosta> hmm, guess I need to use a square root solution
03:37:37 <hvr> @everyone: get your your pitchforks and head over to http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/23031
03:37:38 <lambdabot> Unknown command, try @list
03:37:49 <hvr> s/your your/out your/
03:38:59 <t7> hvr: you are not a fan?
03:39:04 <felixn> prinsen: aw yea, fyi I've found doctest + parsec = epic win ... also isolating the problem from the application into a gist helps us help you, and make issues more obvious
03:39:09 <hvr> t7: I wrote the proposal ;-)
03:39:22 <hvr> t7: this was rather a sarcastic remark
03:39:36 <hvr> call me pessimistic
04:07:25 <lb5tr> Hello, anyone with experience with easyvision?
04:07:49 <lb5tr> i'cant build it (event though I'm doing it on ubuntu virtual machine)
04:07:53 <lb5tr> lib/Util/Kalman.hs:28:8:                                                                                               │
04:07:56 <lb5tr>     Could not find module `Numeric.GSL.Differentiation'
04:08:16 <lb5tr> this is what I'm getting, anyone knows where does GLS can be found (which pacakge?)
04:09:06 <gigabytes> hi
04:09:22 <gigabytes> can I add a constraint on the default implementation of a function in a typeclass?
04:09:52 <gigabytes> I mean, that a type variable in the typeclass has no constraint, but the default implementation is available only if the constraint is met
04:10:36 <nkar> can haskell-mode show all callers of a function?
04:10:56 <dbushenko> whats the best lib to access sql database?
04:11:16 <dbushenko> (don't need migrations, just read/write data)
04:12:19 <tdammers> dbushenko: hdbc is straightforward - not sure if it's the best, but it works and doesn't add a lot of abstraction
04:12:33 <Axman6> ddellacosta: persistent is quite nice, and if you need more advanced queries, esqueleto looks nice
04:12:34 <dbushenko> thanks, I'll give a try
04:12:42 <tdammers> dbushenko: there's also lower-level bindings for most of the popular DBMS's, but they're more specific
04:12:51 <Axman6> depends on what you're after
04:13:01 <tdammers> Axman6: thing you mis-tab-completed there
04:13:04 <tdammers> *think
04:13:14 <Axman6> uh, yeah
04:13:29 <tdammers> persistent and such is one step up in terms of abstraction
04:13:33 <tdammers> may or may not be what you want
04:14:08 <Axman6> postgres-simple also looks nice
04:14:14 <dbushenko> tdammers: yes, it looks really nice!
04:14:44 <tdammers> (one of my gripes with HDBC is lack of named parameters though...)
04:17:52 <shmookey> I think I'm missing something important about how type equality is deduced from type families
04:17:55 <shmookey> can anyone help shed some light on why nconcat compiles here but not nconcat'? http://lpaste.net/112692
04:19:44 * hackagebot ekg-rrd 0.2.0.5 - Passes ekg statistics to rrdtool  http://hackage.haskell.org/package/ekg-rrd-0.2.0.5 (dcturner)
04:19:44 <shmookey> the constraint that ghc can't deduce ((m :+ 'S n1) ~ 'S (m :+ n1)) seems to follow from the rules in the type family to me, but clearly it doesn't
04:19:52 <Axman6> the first case is trivial fiven the definition of :+, but the second isn't; it's not imediately clear that m :+ n == n :+ m
04:20:23 <Axman6> you have no definition for n :+ S m though, so how can it?
04:21:22 <Axman6> it doesn't know that :+ is commutative
04:26:09 <shmookey> Axman6: is there any way I can tell the compiler that it is commutative? seems like a definition for n :+ S m will never be reached if I add it to the end, and I can't just add m :+ n = n :+ m
04:26:26 <shmookey> unless I use undecidableinstances, apparently
04:26:37 <Axman6> I'm not sure
04:29:28 <Cale> shmookey: I think you just have to stick with nconcat
04:31:59 <Cale> shmookey: There might be some funny way to prove the commutativity of :+ having some type family that produces an equality constraint... but that doesn't sound entirely possible to me at the moment :)
04:32:37 <Cale> and in any case, it would be pretty elaborate
04:35:18 <vanila> What would be a good way to analyze x86 assembly in haskell?
04:35:26 <vanila> a very small subset of
04:37:24 <shmookey> Cale: mm, I guess I'm generally interested in how the deduction actually works
04:37:26 <shmookey> I've had a bunch of issues like this one that I've managed to fix by shuffling things around
04:37:33 <shmookey> but I don't feel like I'm getting any closer to knowing what's going on underneath
04:37:42 <shmookey> e.g. I found it easy to write a recursive map function for IntList, but impossible to make it tail recursive
04:38:21 <Cale> vanila: I'm not sure about analyzing, but there's harpy
04:38:57 <vanila> right now i just make a data type with all the opcodes I use
04:39:14 <vanila> but it keeps growing in complexity
04:39:36 <Cale> http://hackage.haskell.org/package/harpy
04:47:23 <greeny> hey how can i convert "'x''x'" to "xx"?
04:49:00 <Cale> > filter (/= '\'') "'x''x'"
04:49:02 <lambdabot>  "xx"
04:49:17 <Cale> greeny: It's a little unclear what you're looking for exactly...
04:49:49 <greeny> Cale: i think thats it. my peace of code is this: [show a ++ show b | a <- ['x'..'z'], b <- ['x'..'z']]
04:50:18 <greeny> and im wondering why i  get "'x''x'" instead of "xx"
04:50:45 <BoR0> > [a : b : [] | a <- ['x'..'z'], b <- ['x'..'z']]
04:50:46 <lambdabot>  ["xx","xy","xz","yx","yy","yz","zx","zy","zz"]
04:51:00 <tdammers> lol... mfw I hoogle m (Maybe a) -> MaybeT m a
04:51:03 <Cale> Well, because the show for a Char produces the code for that Char, which is quoted
04:51:14 <Cale> > [[a,b] | a <- ['x'..'z'], b <- ['x'..'z']]
04:51:16 <lambdabot>  ["xx","xy","xz","yx","yy","yz","zx","zy","zz"]
04:52:30 <greeny> facepalm. ok thx. didnt see the obvious mistake
04:53:11 <ij> Ruby has Gemfiles, python requirements file, but how does cabal/hs usually do it?
04:54:19 <shmookey> ij: .cabal files
04:58:38 <ij> Nice!
05:03:42 <lpaste> mhd pasted “do notation and IO” at http://lpaste.net/112699
05:04:13 <ij> shmookey, Can I also just make it install deps and not build it?
05:04:32 <indiagreen> ij: cabal install --dependencies-only
05:04:33 <shmookey> cabal install --only-dependencies
05:04:38 <shmookey> either way :P
05:04:46 * hackagebot snmp 0.1.0.0 - API for write snmp client.  http://hackage.haskell.org/package/snmp-0.1.0.0 (chemist)
05:05:44 <mhd> ghci writes     Couldn't match type ‘IO ()’ with ‘Int’     Expected type: IO Handle -> (Handle -> IO ()) -> Int       Actual type: IO Handle -> (Handle -> IO ()) -> IO ()  ..... etc for the code snippet: http://lpaste.net/112699 Why?
05:05:49 <indiagreen> ij: and don't forget that you can add “-j” to get a performance boost if you have several cores and your cabal isn't very old
05:06:33 <gabnex> mhd hmm, why are you accepting ()?
05:06:49 <triliyn> mhd: you would have to say something like "let x = read str :: Int"
05:07:01 <Axman6> hClose has type Handle -> IO (), not Int. why do you think the function should be returning an Int?
05:07:35 <triliyn> oh wait, yeah, the error is coming from somewhere else
05:07:39 <gabnex> getIntFromFile :: String -> IO Int
05:07:41 <gabnex> getIntFromFile path = fmap read (readFile path)
05:11:08 <ij> indiagreen, \o/
05:13:49 <sx> is there a quick way to reinstall all broken packages with cabal?
05:29:17 <greeny> does anyone know a easy way to convert a string like "0000101" to a character with byteorder 0000101?
05:33:15 <lsix> greeny: something like http://stackoverflow.com/questions/5921573/convert-a-string-representing-a-binary-number-to-a-base-10-string-haskell ?
05:34:08 <greeny> lsix: looks good to me
05:34:09 <greeny> thx
05:37:29 <kuribas> > chr $ foldl (\s c -> s*2 + (digitToInt c)) 0 "00000011"
05:37:30 <lambdabot>  '\ETX'
05:37:34 <kuribas> > chr $ foldl (\s c -> s*2 + (digitToInt c)) 0 "000000101"
05:37:35 <lambdabot>  '\ENQ'
05:37:59 <kuribas> @pl (\s c -> s*2 + (digitToInt c))
05:37:59 <lambdabot> (. digitToInt) . (+) . (2 *)
05:38:35 <kuribas> > chr $ foldl ((.digitToInt).(+).(2*)) 0 "000000101"
05:38:36 <lambdabot>  '\ENQ'
05:40:11 <kuribas> :t printf
05:40:11 <lambdabot> PrintfType r => String -> r
05:41:19 <kuribas> > printf "%b\n" $ ord 'a'
05:41:20 <lambdabot>  No instance for (GHC.Show.Show a0)
05:41:20 <lambdabot>    arising from a use of ‘M299890147026513553814396.show_M2998901470265135538...
05:41:20 <lambdabot>  The type variable ‘a0’ is ambiguous
05:41:20 <lambdabot>  Note: there are several potential instances:
05:41:20 <lambdabot>    instance [safe] GHC.Show.Show
05:42:19 <kuribas> > printf "%b\n" $ (ord 'a' :: Int)
05:42:21 <lambdabot>  No instance for (GHC.Show.Show a0)
05:42:21 <lambdabot>    arising from a use of ‘M914487408347221041114435.show_M9144874083472210411...
05:42:21 <lambdabot>  The type variable ‘a0’ is ambiguous
05:42:21 <lambdabot>  Note: there are several potential instances:
05:42:21 <lambdabot>    instance [safe] GHC.Show.Show
05:42:34 <kuribas> > printf "%b\n" $ ord 'a' :: String
05:42:35 <lambdabot>  "1100001\n"
05:43:12 <kuribas> let conv = chr . foldl (\s c -> s*2 + (digitToInt c)) 0 in conv "1100001"
05:43:21 <kuribas> > let conv = chr . foldl (\s c -> s*2 + (digitToInt c)) 0 in conv "1100001"
05:43:22 <lambdabot>  'a'
05:45:50 <greeny> kuribas: thx ;)
05:58:10 <ij> In .cabal I've listed build-deps and installed them with --dependencies-only, then I updated the pkg list. xml-conduit instaled = 1.2.2. When trying --dependencies-only again, it says all is ok, but cabal install xml-conduit starts installing the 1.2.3.
05:58:29 <ij> Shouldn't it try to get the newest one, if I haven't listed any specific versions in .cabal?
06:00:14 <lpaste> ADexter pasted “do notation” at http://lpaste.net/112701
06:00:27 <gigabytes> a little question about the smartness of GHC
06:00:53 <gigabytes> if in a where clause I declare two bindings to be the map of different functions over the same list
06:01:01 <ADexter> Hey there, I don't really understand why I am getting this error, I would appreciate any help
06:01:02 <ij> Oh, I needed --update-dependencies. Nevr mind.
06:01:17 <gigabytes> can I expect that the compiler arranges things to make the code traverse the list only once?
06:02:35 <ClaudiusMaximus> gigabytes: almost certainly not, but non-strict evaluation means that whether it is a problem depends on how the results are consumed
06:02:42 <pjdelport> ADexter: "squareSize x1" results in a single Int, but >>= expects a list on the left side.
06:03:11 <pjdelport> ADexter: That's what the following is trying to say: --  Couldn't match expected type ‘[Int]’ with actual type ‘Int’ --  In the first argument of ‘(>>=)’, namely ‘squareSize x1’
06:03:30 <ClaudiusMaximus> ADexter: the working version uses a different Monad instance (probably Reader?)
06:04:06 <jaseemabid> gigabytes: Rewrite (map f1 map f2 xs) to (map f1. f2 xs ) ?
06:04:25 <ADexter> pjdelport: Ahh that makes sense, it tries to strip away the monadic structure but there is none
06:04:27 <ADexter> thanks
06:04:30 <gigabytes> jaseemabid: no, I don't have two nested maps. I have two different parallel maps
06:04:49 * hackagebot enumeration 0.1.0 - A practical API for building recursive enumeration  procedures and enumerating datatypes.  http://hackage.haskell.org/package/enumeration-0.1.0 (emc2)
06:05:24 <gigabytes> ClaudiusMaximus: so if I rewrite it as (first, second) = map f list, where f returns pairs obtained applying the two functions on the list, I get a single traversal and possibly better performance?
06:05:27 <pjdelport> ADexter: Note that if you're trying to use do syntax, the way you have the last line of plaintextSegments written, it would be equivalent to:
06:05:28 <pjdelport> x2 <- squareSize x1
06:05:28 <pjdelport> chunksOf x2 x1
06:06:40 <pjdelport> ADexter: And yeah, what ClaudiusMaximus says: "squareSize >>= chunksOf" does something entirely different (Reader / (->) r)
06:06:46 <jaseemabid> gigabytes: Dont know. I remember reading somewhere that ghc does that transformation, but I'm not sure. I'm still learning
06:06:49 <ClaudiusMaximus> gigabytes: you need an unzip, but again, it depends how the rest of the code consumes the results if it leads to better/worse performance (by keeping the whole list in memory or not)
06:07:06 <jaseemabid> gigabytes: http://stackoverflow.com/questions/12653787/what-optimizations-can-ghc-be-expected-to-perform-reliably have some examples of optimizations
06:07:19 <gigabytes> jaseemabid: thanks
06:07:38 <ADexter> Yes, i tried to use the working version to understand whats going on there, didn't realize that this was something completely different
06:07:52 <tayacan> Has anyone here tried running Yi out of a cabal sandbox?
06:07:56 <gigabytes> ClaudiusMaximus: yes, it sounds complex
06:16:19 <ClaudiusMaximus> gigabytes: an example might help:  sum xs / fromIntegral (length xs)  might explode your RAM, but  uncurry ((/)`on`getSum) (mconcat (map (\x -> (Sum x, Sum 1)) xs)  should do one traversal and not keep the whole list in memory
06:18:19 <gigabytes> ClaudiusMaximus: pretty clear, thanks
06:18:58 <ClaudiusMaximus> gigabytes: but then if you did  (sumX, sum1) = unzip (map (\x -> (Sum x, Sum 1)) xs) in getSum (mconcat sumX) / getSum (mconcat sum1)  you'd end up with the original problem again
06:19:47 <gigabytes> why this?
06:21:09 <ClaudiusMaximus> if mconcat sumX is evaluated first, the runtime needs to keep the sum1 list (which gets produced by unzip at the same rate as sumX) around for later
06:21:30 <pjdelport> ADexter: In case you're interested, "chunksOf =<< squareSize" becomes: \e -> chunksOf (squareSize e) e
06:22:30 <ClaudiusMaximus> gigabytes: so basically you need to consume the output of both maps at the same rate to ensure low memory overhead (which generally boosts performance)
06:22:35 <pjdelport> ADexter: And for Reader in general, you can think of the f and m in Functor / Monad type signatures as being replaced with (e ->)
06:22:44 <pjdelport> :t (>>=)
06:22:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:22:53 <pjdelport> err,
06:22:53 <pjdelport> :t (=<<)
06:22:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
06:23:02 <gigabytes> ClaudiusMaximus: yes, I got it
06:23:08 <ClaudiusMaximus> :)
06:23:25 <pjdelport> So for Reader, that becomes: (=<<) :: (a -> (e -> b)) -> (e -> a) -> (e -> b)
06:23:25 <gigabytes> ClaudiusMaximus: you know any link with more material on those lazyness-related optimizazion issues?
06:24:07 <pjdelport> Or equivalently: (=<<) :: (a -> Reader e b) -> Reader e a -> Reader e b
06:24:27 <ClaudiusMaximus> gigabytes: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
06:24:52 <ADexter> pjdelport: thanks that helped a lot
06:25:32 <shiona> what do you guys use to paste your code to haste / pastebin etc?
06:25:57 <int-e> @lpaste
06:25:57 <lambdabot> Haskell pastebin: http://lpaste.net/
06:25:57 <pjdelport> ADexter: So finally, you can read "chunksOf =<< squareSize" as saying that squareSize expects an environment to be applied to it, and then chunksOf will get get applied to *that*, yielding another function to be applied to the same environment.
06:26:09 <int-e> hmm.
06:26:43 <int-e> shiona: just cut&paste from an editor, here.
06:28:18 <kuribas> gigabytes: http://www.haskell.org/haskellwiki/Performance
06:29:28 <gigabytes> kuribas: thanks
06:29:50 * hackagebot yabi 0.1.0.0 - Yet Another Brainfuck Interpreter  http://hackage.haskell.org/package/yabi-0.1.0.0 (fgaz)
06:30:52 <kuribas> gigabytes: np
06:31:11 <zmbmartin> What is the best way to convert UTCTime to seconds?
06:32:38 <zmbmartin> I mean UTCTime to epoch
06:32:46 <pjdelport> utcTimeToPOSIXSeconds ?
06:38:45 <Egnurkram> \msg NickServ REGISTER Elscooter Runge2970@gmail.com
06:39:19 <shiona> int-e: :/
06:39:31 <shiona> I was hoping there was a working version of haste
06:44:51 * hackagebot monad-resumption 0.1.1.1 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.1.1 (IanGraves)
06:46:32 <paf31> @pl \x -> mapM ($ x) ys
06:46:32 <lambdabot> flip mapM ys . flip id
06:51:48 <paf31> > :t flip mapM ys . flip id
06:51:49 <lambdabot>  <hint>:1:1: parse error on input ‘:’
06:52:14 <paf31> @type flip mapM ys . flip id
06:52:15 <lambdabot>     Not in scope: ‘ys’
06:52:15 <lambdabot>     Perhaps you meant one of these:
06:52:15 <lambdabot>       ‘y’ (imported from Debug.SimpleReflect),
06:52:25 <paf31> @type \ys -> flip mapM ys . flip id
06:52:26 <lambdabot> Monad m => [a -> m b] -> a -> m [b]
06:53:11 <paf31> @type \ys -> flip mapM_ ys . flip id
06:53:12 <lambdabot> Monad m => [a -> m b] -> a -> m ()
06:55:23 <assia_t> Hey guys
06:55:44 <assia_t> Is it possible to use `FromJSON` from Data.Aeson to parse something that may be either a String or a [String] ?
06:56:33 <assia_t> Just doing it with a `Either String [String]` named field in your data declaration makes it expect the JSON to declare "Left \"email\""
06:56:43 <assia_t> Which is less then ideal... :P
06:56:50 <assia_t> *than
07:02:19 <bartavelle> assia_t, does this work ? :   (Left <$> parseJSON x) <|> (Right <$> parseJSON x) :: Either String [String]
07:02:24 <bartavelle> err
07:02:31 <bartavelle> :: Maybe (Either String [String])
07:02:48 <assia_t> mm... I see...
07:02:57 <nshepperd> ClaudiusMaximus: huh, I'm trying this in ghci, and "foldMap (\x -> (Sum x, Sum 1)) xs" seems to traverse the list separately for the fst and snd component
07:03:01 <assia_t> one sec.
07:03:14 <bartavelle> erm
07:03:16 <bartavelle> fromJSON too
07:03:37 <nshepperd> I wonder if maybe ghci doesn't do strictness analysis or something
07:04:36 <bartavelle> assia_t, (Left <$> fromJSON x) <|> (Right <$> fromJSON x) :: Result (Either String [String])
07:05:16 <bartavelle> (but this sucks, a better solution would be to newtype Xxx = Xxx [String]  and manually define FromJSON so that it handles both cases)
07:05:58 <nshepperd> oh, it still does it in compiled test
07:06:23 <ClaudiusMaximus> nshepperd: oh, could be strictness related - the actual code I used for statistics stuff used a strict datatype with a monoid instance, rather than a non-strict (,)
07:06:33 <ClaudiusMaximus> nshepperd: interesting observation
07:07:37 <assia_t> bartavelle: ok... thanks, I'll try that... But I don't get how to use this over an `Object` type...
07:07:53 <bartavelle> you return mzero
07:07:59 <bartavelle> or fail "I don't like objects"
07:08:31 <bartavelle> and actually this should be done for everything but "String" and "Array"
07:09:13 <bartavelle> parseJSON (String x) = [T.unpack x] ; parseJSON (Array xs) = mapM parseJSON (V.toList xs) ; parseJSON _ = fail "?"
07:10:20 <nshepperd> ClaudiusMaximus: ah, if I define "data MPair a b = P !a !b" (with the obvious monoid instance) and use that, it seems to work properly
07:10:54 <ClaudiusMaximus> nshepperd: good to know
07:11:37 <ClaudiusMaximus> gigabytes: seems i was wrong about my example - nshepperd did some tests ^^
07:13:12 <lingxiao> hey all
07:13:47 <lingxiao> I hate to ask this kind of question on the channel.. but has anyone worked at jane street/know someone who works there and could speak to their experience?
07:15:07 <assia_t> bartavelle: What I mean is `parseJSON (Object o) = Message <$> o .: "display_recipient" -- where display_recipient is either a String or [String]
07:16:10 <assia_t> If you have an `Object o` with a key which may be String or [String], how do you define a `FromJSON` instance to parse it? I have no idea
07:18:13 <gigabytes> ClaudiusMaximus: even more unsure ':)
07:19:40 <bartavelle> well
07:19:54 <bartavelle> assia_t, you always decode it as [String]
07:20:07 <nshepperd> humm, foldMap isn't strict in the accumulator either :/
07:20:25 <blairio> Hey, please forgive my haskell ignorance, but is there anything like Java method overloading in Haskell?
07:20:26 <Cale> assia_t: Parser is an instance of Alternative, so you can try both
07:20:35 <nshepperd> I don't think mconcat is either
07:20:38 <Cale> assia_t: and combine the parsers with <|>
07:20:45 <RchrdB> blairio: typeclasses, sorta.
07:20:55 <Cale> blairio: There's type classes, which are a little bit like Java's interfaces
07:21:33 <blairio> What I want to do is write something that can add a leaf on a binary tree
07:21:55 <blairio> But it would makes sense if it took either a tree, or just a value
07:22:23 <blairio> (the value would be turned into (Branch x Empty Empty))
07:22:37 <nshepperd> "foldMap (\x -> P (Sum x) (Sum 1)) [1..1000000]" constructs the whole list and then consumes it, instead of streaming, due to building up a tower of Pair thunks
07:22:58 <ClaudiusMaximus> nshepperd: :(
07:23:40 <RchrdB> blairio: how about defining (singleton x = Branch x Empty Empty), and defining only the tree version of addLeaf, and addLeafValue tree value = addLeaf tree (singleton value) ?
07:23:52 <nshepperd> so we need "foldMap' f = foldl' (\a x -> a <> f x) mempty" which doesn't seem to appear in the standard library for some reason
07:25:00 <RchrdB> blairio: Haskell doesn't have subclassing, and overloaded typeclasses are painful to use, so it's easiest by far to avoid trying to use it.
07:25:10 <RchrdB> er, subclassing? subtyping
07:26:35 <RchrdB> blairio: Like in Java you can define a method foo(Object), and another implementation foo(Shape) and another implementation foo(Square), and always the most specific one will be used? Standard Haskell doesn't have that kind of "pick the most specific method" thing.
07:27:12 <tdammers> RchrdB: Java resolves this kind of polymorphism at runtime
07:27:24 <tdammers> RchrdB: in Haskell, it's compile-time, more akin to C++ templates
07:27:30 <blairio> RchrdB: Yeah, for sure. I'm just getting used to a non OO language
07:27:41 <RchrdB> tdammers: I'm aware of this. :P
07:28:22 <Cale> But I don't think blairio is even looking to write functions which take different *types* of arguments
07:28:25 <bernalex> blairio: haskell has ad-hoc polymorphism instead. it's quite different, but at the same time a bit similar.
07:28:29 <Cale> He's just looking for pattern matching
07:28:37 <bernalex> yeah
07:28:39 <Cale> bernalex: I wouldn't refer to type class polymorphism as ad-hoc
07:28:43 <Cale> It's quite different
07:28:53 <bernalex> Cale: uh no it is ad-hoc polymorphism. read the papers. :-P
07:29:00 <Cale> I have read them
07:29:21 <Cale> There's one with an unfornate title "How to make ad-hoc polymorphism less ad-hoc"
07:29:33 <Cale> but really type class polymorphism isn't ad-hoc polymorphism
07:29:42 <Cale> It's something new and different :P
07:29:47 <bernalex> Cale: that's deliberate not unfortunate. it starts with "This paper presents type classes, a new approach to ad-hoc polymorphism" which is exactly what it is.
07:30:03 <Cale> Well, I suppose if you want to insist
07:30:04 <bernalex> it is ad-hoc polymorphism. it's just not an ad-hoc implementation of it. ;-)
07:30:18 <Cale> But it's really different from ad-hoc polymorphism
07:30:36 <bernalex> then your definition of ad-hoc polymorphism is different to mine & wadler's
07:30:48 <Cale> In particular, with type class polymorphism, you can define new type class polymorphic things using a single definition which *uses* type class polymorphic things
07:30:54 <Cale> ad-hoc polymorphism lacks that
07:31:07 <bernalex> typeclasses cover *more* than ad-hoc polymorphism, yes
07:31:09 <blairio> So, is the best route to create a singleton :: a-> Tree a, and use a single AddLeaf :: Tree a -> Tree a -> Tree a ?
07:32:06 <Cale> blairio: Well, I think it's a little unclear what you're trying to do -- those might be reasonable operations to write anyway
07:32:07 <bernalex> Cale: ad-hoc polymorphism though is just the ability to write functions with heterogeneous implementations for different types.
07:32:16 <nshepperd> ClaudiusMaximus: I guess there is the foldl package, which seems to have this figured out already
07:32:28 <bernalex> Cale: and parametric polymorphism is just the ability to write functions with homogeneous implementations for different types. :-]
07:33:12 <Cale> bernalex: Well, yes, but the important thing about ad-hoc polymorphism relative to type class polymorphism is that the decision about which type/value to use can't be deferred.
07:33:40 <bernalex> Cale: other solutions to ad-hoc polymorphism are more ad-hoc, yes. ;-)
07:33:44 <blairio> Cale: Oh, well what I want to do is take the leaf of a tree (with an available branch) and add a new Tree there, but if the Tree has one value, I'd like to add by saying "AddLeaf a" instead of "AddLeaf (Branch a Empty Empty)
07:33:59 <Cale> When you're using ad-hoc polymorphism, and you refer to a thing which has definitions at multiple types, the type context at the place where you use it must determine which one to use uniquely.
07:34:49 <bernalex> Cale: that's part of a solution to ad-hoc polymorphism, and falls outside of the precise definition I have given, which I am sure is the one Wadler uses, and by which typeclasses becomes a feature that solve it (and other things).
07:34:50 <Cale> That's a big enough difference that it really doesn't deserve the same name
07:35:21 <kuribas> @seen ndm
07:35:21 <lambdabot> ndm
07:35:23 <Cale> Type class polymorphism is closer to parametric polymorphism than it is to ad-hoc polymorphism
07:35:37 <bernalex> Cale: typeclasses let you do both. :-]
07:35:44 <Cale> It's essentially parametric polymorphism with implicit arguments
07:36:12 <Cale> (and a careful system which ensures that those arguments can be filled uniquely)
07:38:00 <Cale> blairio: How are you specifying which leaf?
07:38:18 <Cale> blairio: Do you have a path to it specified as a binary string or something?
07:38:50 <Cale> blairio: Or is it uniquely determined by the value you're inserting, like with a search tree?
07:38:57 <blairio> Cale: I'm working that out now, I'm thinking either a path or adding another tree as an input to pattern match against
07:39:22 <Cale> What is the program you're trying to write? :)
07:39:30 <Cale> (What will the trees represent)
07:40:14 <blairio> Cale: Just a Binary Tree, I'm just trying to learn Hasklell by making some simple datatypes
07:40:59 <Cale> Ah, then you might try lots of things :)
07:41:06 <nshepperd> gigabytes: If you're still here, you might want to look at http://hackage.haskell.org/package/foldl which handles "traversing a list only once" with minimal mucking about with strictness
07:41:20 <gigabytes> nshepperd: really nice!
07:43:06 <blairio> Cale: http://lpaste.net/112708 what I have so far
07:43:50 <Cale> Oh, an improvement which can be made to those traversals...
07:44:07 <Cale> xs ++ ys takes O(length xs) steps to reduce
07:44:11 <Cale> @src (++)
07:44:11 <lambdabot> []     ++ ys = ys
07:44:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:44:11 <lambdabot> -- OR
07:44:11 <lambdabot> xs ++ ys = foldr (:) ys xs
07:44:47 <Cale> So, on leftward-leaning trees, your inorder traversal for instance will have quadratic complexity
07:44:54 <Cale> (and the others, actually)
07:45:36 <Cale> So, a common trick to avoid this is instead of working with lists of type [a] directly, instead work with functions of type [a] -> [a] which add elements to the beginning of a given list
07:45:58 <Cale> Then instead of (++), you can use (.) which is O(1) complexity
07:46:07 <Cale> and instead of [], you use id
07:46:12 <Cale> and instead of [x], you use (x:)
07:46:31 <Cale> Then, once the whole function is constructed, you can apply it to an empty list to get the whole list of elements
07:46:35 <Cale> e.g.
07:46:41 <Cale> inorder t = inorder' t []
07:46:47 <Cale> inorder' Empty = id
07:47:03 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
07:47:18 <Cale> cool?
07:47:25 <blairio> Oh!
07:48:31 <Cale> Another really cool thing to do is to write:
07:48:43 <blairio> I see, so what the recurse is doing anyway is borrowing downwards so a single element, so I might as well have a method that finds those single elements, and attaches them using (:), and them assemble them at the top in another function
07:49:17 <blairio> Right?
07:49:42 <Cale> Well, the main thing is that each (++) costs as much time as the list to its left has elements
07:50:18 <blairio> Ah, because its singly linked?
07:50:18 <Cale> So if you recursively produce some expression like  ((...) ++ [x]) ++ [y]) ++ [z]
07:50:55 <Cale> then this will be O(n^2), because the outermost (++) will have, say, n elements in its left argument, and then the next one in will have n-1, and so on
07:51:13 <Cale> (++) is defined like:
07:51:16 <Cale> [] ++ ys = ys
07:51:24 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
07:51:50 <Cale> So, it goes through the entire left list one element at a time before it's done
07:52:00 <Cale> (assuming you evaluate the whole of the resulting list)
07:52:07 <blairio> Right, ok, that makes sense
07:53:03 <Cale> So, another fancy and cool thing which might be interesting to you is:
07:53:27 <Cale> foldTree empty branch = f where f Empty = empty; f (Branch x l r) = branch x (f l) (f r)
07:53:55 <Cale> foldTree empty branch is the function which goes through a tree, replacing each Empty with empty and each Branch with branch
07:54:39 <Cale> So, for instance, you can write  height = foldTree 0 (\x l r -> 1 + max l r)
07:55:10 <Cale> Or  inorder' = foldTree id (\x l r -> l . (x:) . r)
07:56:14 <blairio> Woah woah, What's the difference between 'Empty and empty' 'Branch and branch' and what is 'id'?
07:56:24 <Cale> empty and branch there were variables
07:56:38 <Cale> While Empty and Branch are the data constructors for your BinaryTree type
07:57:00 <Cale> We could have used, say, e and b instead of empty and branch, maybe that actually would have been less confusing
07:57:26 <Cale> foldTree e b = f where f Empty = e; f (Branch x l r) = b x (f l) (f r)
07:57:39 <Cale> I dunno, maybe that's also a little bewildering :)
07:57:50 <Cale> Let's see if I can define this type so we can play with it...
07:57:59 <Cale> @let data BinaryTree a = Empty | Branch a (BinaryTree a) (BinaryTree a)
07:58:01 <lambdabot>  Defined.
07:58:02 <blairio> I think that makes sense now actually
07:58:10 <Cale> @let foldTree e b = f where f Empty = e; f (Branch x l r) = b x (f l) (f r)
07:58:11 <lambdabot>  Defined.
07:58:14 <Cale> :t foldTree
07:58:15 <lambdabot> t1 -> (t -> t1 -> t1 -> t1) -> BinaryTree t -> t1
07:58:30 <Cale> id is the identity function
07:58:32 <Cale> id x = x
07:59:21 <Cale> > foldTree [] (\x l r -> l ++ [x] ++ r) (Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty))
07:59:23 <lambdabot>  [2,1,3]
07:59:39 <Cale> > foldTree id (\x l r -> l . (x:) . r) (Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty)) []
07:59:40 <lambdabot>  [2,1,3]
08:00:07 <Cale> > foldTree 0 (\x l r -> 1 + max l r) (Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty)) -- height
08:00:08 <lambdabot>  2
08:00:21 <blairio> r u a wizard?
08:00:50 <gigabytes> oh that's funny
08:00:51 <Cale> > foldTree False (\x l r -> x == 2 || l || r) (Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty)) -- contains 2
08:00:53 <lambdabot>  True
08:00:57 <gigabytes> instead of my output I get <<loop>>
08:00:59 <Cale> > foldTree False (\x l r -> x == 5 || l || r) (Branch 1 (Branch 2 Empty Empty) (Branch 3 Empty Empty)) -- contains 5
08:01:01 <gigabytes> how am I going to debug this?
08:01:01 <lambdabot>  False
08:01:24 <bartavelle> gigabytes, search for lines where you wrote the same thing on both sides of the "="
08:01:24 <Cale> gigabytes: That means that there was an infinite loop of a specific form
08:01:39 <gigabytes> Cale: yeah of course
08:01:40 <bartavelle> (this is usually what happens to me)
08:01:40 <Cale> gigabytes: i.e. in order to evaluate some variable x, you needed to evaluate x
08:02:35 <Cale> look for things like  let x = x + 1 in ...
08:02:43 <Cale> Of course it won't be that simple
08:02:49 <bartavelle> gigabytes, also this *might* help (never used this for <<loop>>) : http://www.haskell.org/haskellwiki/Debugging#Stack_trace
08:02:54 <Cale> but it often happens if 'x' was defined also in some outer scope
08:03:00 <Cale> and you didn't realise you were shadowing it
08:03:14 <bartavelle> Cale, I typo like that all the time
08:15:57 <blairio> So, I'm trying to work out how to use anonymous functions in folds
08:16:03 <rtharper> okay
08:16:17 <blairio> What I'm unsure of is how to set them up so that they take the accumulator properly
08:18:00 <blairio> So I'm trying to write a function for tree `contains` x = foldTree False (\z y -> z || x==y) tree
08:18:24 <HeladoDeBrownie> blairio, what's the type of foldTree?
08:18:36 <blairio> foldTree acc fun = f
08:18:36 <blairio>         where
08:18:37 <blairio>         f Empty          = acc
08:18:37 <blairio>         f (Branch x l r) = fun x (f l) (f r)
08:19:03 <HeladoDeBrownie> I just needed its type, but sure, lemme enter that into an editor :P
08:19:24 <vanila> (\z y -> z || x==y)
08:19:27 <vanila> but you need 3 paraemters
08:19:55 * hackagebot api-tools 0.5 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.5 (AdamGundry)
08:20:12 <HeladoDeBrownie> Ah, yeah, that's it
08:20:54 <blairio> So the lambda can't find the x from the pattern match in the tree `contains` x ?
08:21:05 <HeladoDeBrownie> That's not it. It can.
08:21:20 <blairio> Then why does it need 3 parameters?
08:21:30 <HeladoDeBrownie> Because the type of foldTree calls for that.
08:21:40 <HeladoDeBrownie> fun is applied to three things.
08:21:41 <vanila> f (Branch x l r) = fun x (f l) (f r)   -- fun gets passed 3 values here
08:21:52 <blairio> Ah! Right
08:22:23 <HeladoDeBrownie> You may notice from how I only cared what the type of foldTree was how important it is to look at the types
08:22:41 <HeladoDeBrownie> Do this in ghci and see for yourself: :t foldTree
08:22:55 <HeladoDeBrownie> And you'll see that it takes a function of three parameters
08:26:41 <Cale> blairio: Think of the arguments of foldTree as replacements for the constructors of your tree datatype
08:26:54 <Cale> blairio: The reason that it takes three arguments is that so does Branch
08:27:15 <Cale> "accumulator" is the wrong way to think of it
08:27:24 <Cale> It's the replacement for Empty
08:28:03 <blairio> Cale: Yeah, it makes sense, it has to be as general a function as possible
08:28:17 <Cale> blairio: Similarly, foldr f z replaces each (:) in a list with the function f, and each [] with z
08:28:36 <Cale> (foldl is weirder)
08:32:35 <zmbmartin> Is there a way to do an io unwrap in a case so instead of r <- some io \n case r of. Just do something like: case some io of?
08:32:55 <HeladoDeBrownie> zmbmartin, you can't pattern match on IO. What are you going for?
08:33:45 <Haskellfant> zmbmartin: you can't escape of IO
08:34:03 <geekosaur> zmbmartin, some io >>= \case ... (LambdaCase), otherwise no
08:34:21 <geekosaur> you do not unwrap IO, you must execute it via bind
08:34:26 <geekosaur> @quote /bin/ls
08:34:26 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:34:27 <Haskellfant> well you can with unsafePerformIO but you shouldn't (in most cases)
08:34:55 <zmbmartin> I am just trying to see if there is a better way to write something like this -> https://gist.github.com/codedmart/c1eab161174570930a9b
08:35:11 <zmbmartin> Playing with JWT (json web tokens)
08:35:42 <zmbmartin> expired returns a IO (Maybe Bool)
08:35:57 <HeladoDeBrownie> Oh, I see now.
08:35:57 <HeladoDeBrownie> zmbmartin, the first way you showed is probably best, although I sometimes also like to do: x >>= \case …
08:35:57 <HeladoDeBrownie> That requires the LambdaCase language extension.
08:36:29 <zmbmartin> HeladoDeBrownie: OK so the gist is ok code then?
08:36:42 <zmbmartin> Unless I want to use LambdaCase
08:38:35 <HeladoDeBrownie> zmbmartin, it looks okay. I can read it fine, which counts.
08:38:51 <HeladoDeBrownie> That's not to say it can't be made even better, but nothing obvious occurs to me.
08:39:03 <zmbmartin> :HeladoDeBrownie :geekosaur Thanks guys!
08:40:01 <HeladoDeBrownie> zmbmartin, although, I notice that both branches of your case apply return, so you can move it outside. return $ case r of …
08:40:49 <nshepperd> um, if (J.verify ...) :: IO _ then that doesn't type check
08:40:59 <HeladoDeBrownie> And do { r <- expired j ; return (f r) } fits the pattern where you can just use fmap (or liftM)
08:42:04 <nshepperd> you need J.decode j >>= J.verify (J.secret $ pack "secret-key") >>= (\x -> case x of {...})
08:42:19 <nshepperd> if you're not going to use LambdaCase
08:44:34 <zmbmartin> nshepperd: That line works fine.
08:46:32 <nshepperd> oh, verify is just a Maybe
08:47:04 <TallerGhostWalt> why: iso :: (s -> a) -> (b -> t) -> Iso s t a b
08:47:06 <TallerGhostWalt> instead of : why: iso :: (s -> a) -> (a -> ) -> Iso s s a a
08:47:18 <nshepperd> ohh, you were saying 'expired' was the IO, ignore me
08:47:38 <TallerGhostWalt> I know you can get the second from the first, but it seems like that should be the only option for an iso?
08:47:43 <zmbmartin> HeladoDeBrownie: I am not sure I follow your last statement.
08:47:54 <zmbmartin> Of using fmap or liftM
08:48:03 <zmbmartin> Haven't mastered those yet.
08:48:19 <HeladoDeBrownie> zmbmartin, in general, if you use a do expression resembling this one: do { x' <- x ; return (f x') }, you can instead write: fmap f x
08:49:39 <DarkCthulhu> What is the type of [tail, init, reverse] ?
08:49:55 <HeladoDeBrownie> :t [tail, init, reverse]
08:49:56 <lambdabot> [[a] -> [a]]
08:50:24 <HeladoDeBrownie> List of functions that, given a list of any type, give a list of that type.
08:50:36 <DarkCthulhu> HeladoDeBrownie: Ah.. okay. ty
08:50:46 <HeladoDeBrownie> DarkCthulhu, you can do the same thing I just did in ghci
08:50:56 <DarkCthulhu> HeladoDeBrownie: Why couldn't I assign that list to a variable?
08:51:02 <DarkCthulhu> within GHCI
08:51:07 <HeladoDeBrownie> DarkCthulhu, you can. More context please?
08:51:35 <DarkCthulhu> HeladoDeBrownie: a = [tail, init, reverse] -- syntax error near =
08:51:43 <DarkCthulhu> ah.. I need a let?
08:51:44 <HeladoDeBrownie> DarkCthulhu, you need a "let" before it in ghci
08:51:50 <HeladoDeBrownie> ghci's syntax is weird
08:51:55 <zmbmartin> HeladoDeBrownie: anyway I could get a sample in my gist. I must not be doing something right. I can't get fmap to work.
08:52:16 <DarkCthulhu> HeladoDeBrownie: Yeahh.. It is all wrapped within one big do or something right?
08:52:35 <HeladoDeBrownie> zmbmartin, I wouldn't worry about it too much. But if you are interested, I can try showing you.
08:52:48 <HeladoDeBrownie> DarkCthulhu, essentially. There are some differences even from that.
08:52:59 <zmbmartin> HeladoDeBrownie: I am always interested in understanding new things.
08:53:01 <HeladoDeBrownie> Like how you can write data declarations in it.
08:53:13 <DarkCthulhu> HeladoDeBrownie: Hmm
08:53:51 <HeladoDeBrownie> zmbmartin, okay, well do you understand the first transformation I did? Floating out the return?
08:54:17 <zmbmartin> HeladoDeBrownie: I believe so.
08:54:54 <HeladoDeBrownie> So then we have: do { r <- expired j ; return $ case r of { Just True -> Just j ; _ -> return Nothing } }
08:55:00 <HeladoDeBrownie> Woops
08:55:06 <HeladoDeBrownie> do { r <- expired j ; return $ case r of { Just True -> Just j ; _ -> Nothing } }
08:55:25 <zmbmartin> HeladoDeBrownie: Right
08:55:45 <HeladoDeBrownie> Now we can factor out a function, let's just call it f for now
08:56:26 <HeladoDeBrownie> let { f r = case r of { Just True -> Just j ; _ -> Nothing } }
08:56:35 <HeladoDeBrownie> And we can write that in the do block
08:56:46 <HeladoDeBrownie> and then just do: fmap f (expired j)
08:57:28 <zmbmartin> HeladoDeBrownie: that is great thanks!
08:57:56 <HeladoDeBrownie> Lemme know if it works, I'm just doing this in my head so I might make mistakes :P
08:58:41 <zmbmartin> HeladoDeBrownie: Yup works.
08:58:45 <HeladoDeBrownie> Okay cool.
08:59:45 <zmbmartin> HeladoDeBrownie: I like that thanks again
08:59:49 <HeladoDeBrownie> No problem.
08:59:57 <HeladoDeBrownie> Well, I'm off to catch a bus. Have fun everyone.
09:04:57 * hackagebot hplayground 0.1.2.0 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.2.0 (AlbertoCorona)
09:04:59 * hackagebot hzulip 0.4.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.4.0.0 (yamadapc)
09:18:48 <Kinnison> Anyone here able to help me with a lens question?  I am trying to learn some of the basics and was looking for a way to say "Give me the _2 from each element of the input list" where the input list is of the form [(1,2),(3,4),(5,6)] etc.
09:19:01 <johnw> you would use a traversal
09:19:07 <johnw> [(1,2),(3,4),(5,6)] ^.. _2
09:19:09 <johnw> > [(1,2),(3,4),(5,6)] ^.. _2
09:19:11 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field2
09:19:11 <lambdabot>                      [(t0, t1)] [(t0, t1)] a a)
09:19:11 <lambdabot>    arising from the ambiguity check for ‘e_11234562’
09:19:11 <lambdabot>  from the context (Control.Lens.Tuple.Field2
09:19:11 <lambdabot>                      [(t, t2)] [(t, t2)] a a,
09:19:12 <Kinnison> I tried inputlist ^. each . _2
09:19:16 <johnw> > [(1,2),(3,4),(5,6)] ^.. traverse._2
09:19:18 <lambdabot>  [2,4,6]
09:19:21 <Kinnison> aah
09:19:32 <johnw> the ^.. returns each result found as an element of a new list
09:19:32 * Kinnison looks up ^.. 
09:19:38 <johnw> otherwise, it would monoidally combine the results
09:19:38 <Kinnison> ooooh
09:19:40 <Kinnison> I see
09:19:57 * hackagebot yesod-bin 1.4.0.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.2 (MichaelSnoyman)
09:20:14 <Kinnison> It's a whole new language when you add lenses in :-)
09:20:26 <johnw> it kind of is, but based on the same core vocabulary :)
09:21:17 <Kinnison> *if* you have a strong grasp of that vocab and you weren't just parroting words back at the compiler 'til it shut up :-)
09:21:35 <johnw> yeah, that approach doesn't work so well in Haskell
09:21:58 <Kinnison> I know :-)
09:22:07 * Kinnison has gone right back to the start and is re-learning with some friends
09:22:21 <Kinnison> 6 months away from haskell has, unfortunately, drained most of my understanding
09:22:31 <Kinnison> but I wanted to play with lenses while I waited for some builds on my other laptop
09:23:25 <Kinnison> I'll try and take my queries to #haskell-lens in future though :-)
09:24:19 <cmtptr> Kinnison, please take it to #lua-support
09:24:50 * Kinnison raises an eyebrow
09:29:44 <Cale> Kinnison: Well, #haskell-lens would probably be better, but you also shouldn't feel uncomfortable asking about lenses here. I think it's really easy to overuse the infix operators in lens, and if you avoid that, it's not so strange looking :)
09:30:20 <Kinnison> Cale: :-)  I quite like the look of the infix operators when playing in a stack containing State :-)
09:33:13 <wz1000> What is the best way to share state between threads created using forkIO if the main thread is the only thread that is going to modify the state?
09:35:08 <merijn> wz1000: IORef?
09:39:07 <wz1000> I was thinking of a more restricted way, with which I only give threads the permission to view the state, but not modify it.
09:40:08 <wz1000> Is there any nice way to implement closures with local modifiable state? Something with type (a -> IO b)
09:40:48 <merijn> wz1000: newtype IORef and only export a read function :)
09:41:17 <ClaudiusMaximus> or just pass (readIORef ref) instead of (ref)
09:42:00 <wz1000> merijn: But then how would I modify it at all?
09:42:54 <clang-> Why doesn't   :k someFunction  work? Aren't function concrete types?
09:42:59 <merijn> wz1000: Well, obviously your main thread should be in a module that does have access to the modify function
09:43:00 <wz1000> ClaudiusMaximus: That sounds like a good idea. Thanks
09:43:02 <clang-> Are the types of functions an exception or something?
09:43:09 <merijn> clang-: :k works on types, functions are not types
09:43:23 <merijn> :k Int -> Char
09:43:24 <lambdabot> *
09:43:32 <merijn> That works fine?
09:43:42 <clang-> Oh shit
09:43:45 <clang-> of course
09:43:47 <clang-> thanks
09:43:58 <merijn> clang-: Also, I would recommend aginst the term "concrete type" it's ill-defined and no one really knows what it means
09:44:04 <clang-> that function is a VALUE of type Int->Char
09:44:06 <clang-> makes sense
09:44:07 <clang-> ok
09:44:12 <merijn> It's my biggest gripe against LYAH
09:44:36 <clang-> can you list all your other gripes? for future reference
09:44:37 <merijn> Alternative (well defined!) terms are: "monomorphic" (opposite of polymorphic) and just "type of kind *"
09:45:19 <merijn> i.e. "Maybe a" has kind * and is polymorphic, "Maybe Int" is monomorphic and has kind *
09:47:09 <pold87> Can I somehow display the source code of a function using the hoogle command line interface?
09:47:49 <pranz> pold87: lambdabot can atleast, and you can have private chats with it'
09:48:33 <merijn> pranz: Lambdabot can't
09:48:51 <wz1000> Is it possible to get lambdabot working locally? It can be my personal haskell buddy :)
09:48:55 <merijn> lambdabot can lookup a keyword in a database and print out whatever "source" was stored in there
09:48:57 <MagneticDuck> cabal install lambdabot
09:51:08 <wz1000> OK, those dependencies just killed me
09:52:54 <wz1000> How many cabal packages do you guys have globally installed?
09:53:39 <merijn> Globally-globally or user globally?
09:54:05 <wz1000> user globally
09:54:41 <wz1000> If I have more than 5 at any given time, I usually end up in cabal hell
09:54:54 <Ankhers> I personally install everything in sandboxes. The only things installed globally are the packages that come with the platform. Though, I'm sure I'm just being paranoid...
09:55:20 <merijn> ghc-pkg list returns 141 lines, ghc-pkg list --user 79
09:55:38 <wz1000> Ankhers: Thats what I try to do too. I've had too many bad experiences
09:55:40 <merijn> So, basically everything
09:55:52 <dcoutts_> wz1000: 211
09:56:27 <Ankhers> I come from the ruby world where I use RVM and gemsets to separate my projects. I do that as much as possible in any language I use now.
09:57:02 <wz1000> But recompiling packages that you already have in sandboxes is painful
09:57:05 <merijn> I only use sandbox if something non-sandboxed fails to install OR I'm hacking on a package I also use
09:57:22 <merijn> i.e. I'm patching pandoc but I have pandoc installed as user application too
09:57:44 <sm> wz1000: 367
09:58:17 <Ankhers> I don't really care about the compiling. Especially since it can compile packages asynchronously. Besides, it is generally a one time compile.
09:58:35 <merijn> wz1000: Do you have an example package that gets you into trouble? Did you ever do --force-reinstalls?
09:58:38 <merijn> dcoutts_: btw
09:58:59 <Ankhers> And, as others have stated with their global packages, I'm just being paranoid.
09:59:06 <merijn> dcoutts_: I think the --force-reinstalls needs to be more forcefull, i.e. blinking, bright red capitals "THIS WILL CAUSE NIGHTMARES"
09:59:29 <merijn> dcoutts_: I still see people in here every day due to them casually using --force-reinstalls after seeing it in cabal's output
09:59:30 <dcoutts_> merijn: it's already pretty frightening, more so than necessary in many cases
10:00:01 <dcoutts_> merijn: I also see people unthinkingly trying to avoid reinstalls when it would be the right thing
10:00:06 <Ankhers> I did that a couple times when I first started.
10:00:32 <Ankhers> This is why I started using the then cabal-dev to sandbox things.
10:00:43 <wz1000> merijn: No, I don't do --force-reinstalls. Other that yesod and GHC-JS, haskell-src-exts, hoogle, warp and conduits cause trouble sometimes.
10:00:46 <merijn> dcoutts_: The manual "ghc-pkg unregister" -> "install" process so far seems safer, although I guess a lot more cumbersome
10:00:50 <sm> install --reinstall followed by cleaning out all broken packages is safe enough, right ?
10:00:58 <dcoutts_> merijn: I think I'm satisfied that it's about right for the moment. The solution is to eliminate the need to break packages.
10:01:00 <merijn> wz1000: Well, ghcjs is still in beta stages at best
10:01:10 <merijn> dcoutts_: Oh, I agree with that :)
10:01:19 <dcoutts_> merijn: it's more or less the same, cabal considers broken packages as if they did not exist
10:01:46 <merijn> sm: I prefer unregister + install as safest possible way (it also lets you know what you are about to break)
10:02:05 <sm>  --reinstall tells that too, no ?
10:02:18 <merijn> sm: I don't remember I haven't used it in ages :)
10:02:41 <sm> I mean, the warning that suggests --reinstall
10:02:52 <merijn> wz1000: And yesod is notoriously hard to install, hell, it's one of the reasons stackage was created
10:02:56 <hexagoxel> merijn: but you can sandbox-install user applications..
10:03:33 <sm> ghc-pkg unregister is very tedious, I prefer my ghc-pkg-clean script, and I'd love to have cabal or ghc-pkg provide that feature
10:03:33 <merijn> hexagoxel: It makes a lot more sense to sandbox my patching because I can "link" other sandboxes into there if I'm hacking on dependencies
10:03:43 <wz1000> merijn: Yeah, I grouped those two seperately on purpose
10:04:20 <merijn> hexagoxel: i.e. pandoc imports a bunch of data structures from it's dependencies so you can use them without all of pandoc, which means patching if often means hacking pandoc + dependencies in parallel
10:04:37 <sm> wz1000: basically, try cabal sandbox, then stackage, then complain loudly to the specific package maintainers
10:04:38 <merijn> hexagoxel: So the ability to link a dependency sandbox into pandoc sandbox is crucial
10:05:57 <hexagoxel> merijn: uhm, i mean you can sandbox everything
10:06:08 <merijn> wz1000: I haven't had many problems with warp/conduits/haskell-src-exts, but I upgrade cabal packages very conservatively (i.e. after installing platform I only ever "cabal update" if I really need a feature from a newer library release)
10:06:25 <merijn> hexagoxel: Sure, but why recompile the world if I already have most of pandoc installed and only need to hack on 1 or 2 things?
10:06:30 <quimey> Hi, I am trying to make my own type an instance of MonadPlus and I am getting  "Not in scope: type constructor or class `MonadPlus'". Where I can get info about this?
10:06:41 <merijn> quimey: Did you import it? ;)
10:06:51 <merijn> quimey: I think it's in Control.Monad
10:07:10 <hexagoxel> merijn: because then you only can break things locally :)
10:07:32 <merijn> hexagoxel: I've never broken anything in my install, so I'm fine with that risk
10:07:44 <quimey> merijn: That's it. Thank you!
10:07:55 <Artemis_> ist it possible with haskell to include a file inside the binary and read it from there?
10:07:58 <merijn> quimey: For future reference, try hoogle :)
10:08:01 <merijn> @where hoogle
10:08:02 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:08:18 <sm> Artemis_: yes, see file-embed
10:08:28 <merijn> Artemis_: Yes, it's possible. Is it easy? Maybe...
10:10:46 <sm> should cabal install --reinstall should unconditionally remove broken packages after it's done ?
10:11:30 <dcoutts_> sm: mm, maybe
10:12:00 <sm> like apt-get: "are you sure ? the following packages will be autoremoved"
10:12:35 <Artemis_> sm: Looks good, I'll have a look at it
10:17:27 <Artemis_> sm: works fine, thanks!
10:20:00 <sm> np
10:24:04 <mmmm_> Does anyone know the source of this error which I get from running cabal-bounds? http://lpaste.net/112714
10:35:05 * hackagebot hzulip 0.4.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.4.0.1 (yamadapc)
10:42:46 <sigfpe_> Anyone out there use Language.C?
10:44:51 <johnw> you mean the package language-c?
10:45:09 <johnw> I use it quite a bit
10:45:44 <sigfpe_> Yeah, language-c. It doesn't handle comments AFAICT. Are you expected to remove those first?
10:46:06 <johnw> I haven't had a problem with comments, what are you running into?
10:46:20 <johnw> It runs a c preprocessor first, btw
10:46:36 <johnw> although that should leave comments around...
10:47:21 <sigfpe_> It says "The symbol `/' does not fit here." if it sees a /* */ style comment.
10:48:05 <johnw> so, I'm calling into the library like this:
10:48:50 <johnw> parseC (runPreprocessor (newGCC gccPath)) (rawCPPArgs [] fileName)) (initPos fileName)
10:48:51 <johnw> more or less
10:49:15 <johnw> which might be doing some work to clean up the code before language-c sees it
10:49:42 <sigfpe_> Ah, I wasn't explicitly running preprocessor.
10:49:43 <johnw> parseC (runPreprocessor (newGCC gccPath) (rawCPPArgs [] fileName)) (initPos fileName)
10:50:01 <johnw> yeah, you need what language-c sees to be a complete translation unit
10:50:09 <johnw> since it won't peer through #include's or anything by itself
10:52:19 <hugo_dc> Hi Haskellers, I installed hakyll using cabal on Windows 7, but I don't know where the binary is :S
10:52:22 <sigfpe_> Thanks johnw. I'll try that out.
10:52:31 <johnw> thanks to you, Dan, for all of your wonderful writing!
10:55:07 * hackagebot rethinkdb 1.15.1.0 - A driver for RethinkDB 1.15  http://hackage.haskell.org/package/rethinkdb-1.15.1.0 (EtienneLaurin)
10:56:25 <vanila> I really think they've made type inference less powerful
10:56:54 <vanila> this "Note: there are several potential instances:" thing is new?
11:06:56 <joelteon> wait, that means type inference is less powerful?
11:07:11 <joelteon> it wants you to pick which instance to use...
11:10:05 <benzrf> vanila: explain
11:10:09 * hackagebot hsbencher-fusion 0.3 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3 (RyanNewton)
11:23:54 <sx> Can someone with experience on gtk tell me what's wrong with my code? I reduced it to that piece of IO: http://codepad.org/LiYdveQq
11:23:57 <athan> Dependent type theory doesn't necessesarilly imply the capacity to measure normalization, does it?
11:24:43 <athan> if so, could one make deterministic anamorphisms much like finite enumerations?
11:29:14 <Saizan> athan: you can have determinism without normalization
11:42:14 <athan> Saizan:O!!!
11:55:49 <Donny23>  There is no such thing as Free Porn http://bitly.com/1nx3K4c
11:56:33 <zomg> these spam messages get stranger and stranger
11:59:05 <apo_> TANSTAAFP
11:59:28 --- mode: ChanServ set +o geekosaur
11:59:52 <geekosaur> oh, missed the kline the first time
11:59:54 --- mode: geekosaur set -o geekosaur
12:05:20 <bernalex> err does getArgs work counter-intuitively?
12:05:29 <bernalex> does BASH work counter-intutively? IDR this stuff
12:05:38 <bernalex> main = putStrLn . unwords <$> getArgs
12:05:43 <bernalex> I thought that would actually do something
12:06:35 <benmachine> bernalex: put a type signature on main, you will realise your problem
12:06:45 <bernalex> benmachine: derp lol
12:06:49 <bernalex> _T to the rescue
12:08:01 <bernalex> benmachine: now I need to chew on why that code actually worked
12:09:12 <benmachine> bernalex: your program ends up of type IO (IO ()), and the inner IO action gets discarded
12:09:28 <benmachine> (IMO main should be forced to have type IO ())
12:09:37 <benmachine> (but shrug)
12:09:41 <bernalex> benmachine: yes I know that, vi already told me about it. I'm just wondering how I ended up like that in the first place and why it's legal.
12:10:03 <Cale> I think forcing IO () for main is a bit obnoxious in some cases though
12:10:11 <Cale> Especially if your program is short
12:10:19 <Cale> You might be forced to write return () at the end
12:10:31 <bernalex> ah. I figured it out.
12:10:32 <Cale> just because the last thing you wanted to do happened to produce a result
12:11:09 <bernalex> kind of funny
12:11:16 <Cale> Actually making use of actions with type IO (IO ()) can be a really cool technique
12:11:46 <benmachine> Cale: you have to weigh up whether the time wasted writing return () is greater or less than the time wasted by running into bugs from unexpected types
12:12:00 <dmj`> how can I make a Bool default to True
12:12:03 <Cale> If you want to defer any part of what an action does until later, you can just return it :)
12:12:14 <Cale> dmj`: How do you mean?
12:12:45 <Cale> dmj`: Is this in some sort of record type?
12:13:20 <Cale> dmj`: You can produce a "default" value for the record type and use something like  defaultValue { field = somethingElse }
12:13:31 <Cale> using the record update syntax
12:15:20 <dmj`> Cale: I'm not thinking clearly apparently. I have a 'base' function which other functions are defined in terms of, I had specified one of the values to 'False' instead of 'True', it was throwing me off
12:15:23 <dmj`> http://lpaste.net/112727
12:15:35 <dmj`> user error
12:16:23 <Cale> dmj`: Looking at that function type, it might be worthwhile to collect some sets of arguments into new data types.
12:16:47 <Cale> Like, all the credit card info obviously could be put together :)
12:17:19 <Cale> Though I guess it's all Maybe'd, and perhaps you wouldn't want to have a type of that sort with all the fields optional like that.
12:17:36 <dmj`> Cale: yea that's true, http://lpaste.net/112729, here's how I'm 'getting around' the maybe parameter hell
12:18:08 <dmj`> Cale: yea, putting all the CC into a record is a good idea :)
12:18:53 <dmj`> Cale: the test caught the bug tho
12:19:33 <Cale> dmj`: Sometimes making a record type just for the arguments of a specific function is even a good idea just so that they can all be named
12:21:22 <r444> http://haskellryangosling.tumblr.com/ wowzers
12:21:38 <dmj`> Cale: I'd do that, but the naming collisions are so bad, and the only way around it is to be crazy verbose
12:22:42 <sudeep> hi
12:22:52 <dmj`> Cale: data Card = Card { cardId :: CardId, ... }, data CardParams = CardParams { cardIdParam :: CardId }
12:23:06 <sudeep> why should we use `div` instead of / in haskell
12:23:37 <Cale> dmj`: Yeah, that's pretty true
12:23:50 <capisce> sudeep: if you want to perform integer division
12:23:51 <Cale> sudeep: (/) is division for fractional types
12:24:06 <Cale> sudeep: div is integral division (the sort which leaves a remainder that you can get using mod)
12:24:07 <sudeep> oo
12:25:02 <UnrealQuester> div is kind of like (/) in other languages such as C when performing integer division
12:25:28 <sudeep> oo
12:25:31 <sudeep> thanks guys
12:26:07 <sudeep> How many built-in function are there in haskell?
12:26:15 <mauke> define "built-in"
12:26:57 <dmj`> Cale: the plot thickens when other records contain the same stuff. data Customer = Customer { defaultCard :: cardId }, data Card = Card { customerId :: CustomerId }... I can't make seperate modules for the types now.. it'll be a circular import. So I thought making a seperate "SharedTypes.hs" would be cool, but then the api lets you do this expansion thing, where a CardId can be a "hash" (i.e. card_aklsdfj3ioj) or a full Card json
12:26:57 <dmj`> Object. So data CardId = CardId Text | ExpandedCard Card .. so that throws out the shared types thing, since Card is now included in SharedTypes.hs making it circular again :/
12:26:59 <sudeep> i am the basic one like concatMap, show, putStrln
12:27:07 <sudeep> mauke
12:27:25 <mauke> sudeep: those are all from libraries, not really built into the language
12:27:45 <zmbmartin> Can I turn this into one line? https://gist.github.com/codedmart/843b44bf986ffbfd90f6
12:27:48 <sudeep> and actually how many are there in prelude
12:28:06 <dmj`> Cale: so I have this gigantic 1000 liner types file :(
12:28:17 <vanila> sudeep, there is a list of thm here http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Prelude.html
12:28:25 <RyanGlScott> What is the best way to create a Read instance with Parsec?
12:28:32 <mauke> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html
12:28:37 <sudeep> vanila very helpful indeed thank you
12:28:40 <dmj`> RyanGlScott: what are you trying to do
12:29:15 <RyanGlScott> I'm trying to make an ADT representing this syntax: https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Syntax
12:29:16 <mauke> zmbmartin: yes, >>= return . is <$>
12:29:25 <RyanGlScott> With a Read/IsString instance to go along with it
12:29:33 <shapr> npcomp: OH HOWDY
12:31:20 <npcomp> shapr: HALLO
12:31:26 <zmbmartin> mauke: I am not sure where to change. I keep getting type errors with what I have tried.
12:31:28 <shapr> npcomp: Want to learn some HASKELL?!
12:31:33 * shapr hops excitedly
12:31:35 <merijn> RyanGlScott: You shouldn't use Read/IsString for datatypes whose mapping is non-total (i.e. where parse can fail on the string)
12:31:40 <shapr> I wrote a tutorial once, but I lost it :-(
12:31:46 <merijn> RyanGlScott: You might want to implement a quasiquoter?
12:31:51 <shapr> Has anyone seen my Haskell tutorial?
12:31:58 <shapr> I left it around here somewhere.
12:32:22 <benmachine> shapr: is it #haskell
12:32:23 <josephle> did you drop it while hopping?
12:32:32 <shapr> josephle: that is entirely possible
12:32:40 <shapr> benmachine: oh, I like that viewpoint :-)
12:32:45 <zmbmartin> mauke: I might have it.
12:32:47 <mauke> zmbmartin: maybeHelper . insertKey <$> runDB (t R.# R.insert (R.toDatum d))
12:33:18 <shapr> npcomp: too bad you live so far away, otherwise I would come to your makerspace and give you free Haskell lessons.
12:33:33 <zmbmartin> mauke: Oh your way is better then mine thanks!
12:33:34 <chpatrick> hi
12:34:17 <chpatrick> this might be dumb, but is there something like unTypeRep :: TypeRep -> (forall a. proxy a -> b) -> b ?
12:34:32 <RyanGlScott> merijn: Then does parsec at least have a variant of parse that returns a ReadP or ReadPrec?
12:36:52 <Cale> chpatrick: I don't think there is, but that's interesting
12:37:55 <chpatrick> more specifically I'd like to do something along
12:38:07 <chpatrick> applyDynamic :: (forall a. a -> b) -> Dynamic -> b
12:38:56 <Cale> Well, a function of type (forall a. a -> b) definitely ignores its argument
12:39:14 <Cale> You could just pass the Dynamic value :P
12:39:16 <chpatrick> well not exactly a
12:39:18 <merijn> RyanGlScott: Don't think so, but why would you need that?
12:39:31 <mauke> applyDynamic :: (Typeable a) => (a -> b) -> b -> Dynamic -> b
12:39:49 <chpatrick> more like forall SomeClass a .a  ->
12:39:50 <Cale> yeah, if you insist it's typeable, that's different
12:39:51 <chpatrick> b
12:40:18 * hackagebot peparser 0.6 - A parser for PE object files.  http://hackage.haskell.org/package/peparser-0.6 (IanGraves)
12:40:19 <shapr> npcomp: anyway, hit me up for questions if/when you start learning Haskell
12:40:29 <RyanGlScott> merijn: I'm trying to change a function which accepts a font-family (via a String) to one that takes an ADT, but without breaking the ability to pass it in as a String.
12:40:49 <npcomp> shapr: Will do.
12:40:53 <RyanGlScott> merijn: So, "backwards-compatibility", I guess.
12:41:16 <merijn> RyanGlScott: :\
12:41:47 <merijn> RyanGlScott: How would you do that?
12:42:15 <merijn> That doesn't seem possible in any sane way
12:42:18 <RyanGlScott> merijn: The IsString extension. e.g., foo "16pt Helvetica"
12:42:26 <Cale> oh dear
12:42:45 <mauke> couldn't you also make foo a method?
12:42:50 <merijn> RyanGlScott: Don't do that :(
12:42:52 <Cale> I suppose that's... possible
12:42:54 <mauke> and then instances for String and ADT
12:43:04 <saep> RyanGlScott: Create a new function and mark the old one as deprecated.
12:43:23 <RyanGlScott> merijn: Believe me, I'd deprecate the old one if I could.
12:43:23 <Cale> Probably better just to make a function  font :: String -> Maybe Font   or something
12:43:39 <sudeep> What does ":" do in Haskell
12:43:55 <saep> > 12 : 13 : 14 : []
12:43:57 <lambdabot>  [12,13,14]
12:44:11 <mauke> @src []
12:44:11 <lambdabot> data [] a = [] | a : [a]
12:44:54 <Cale> sudeep: x : xs is the list having x at the beginning and whose tail is xs
12:45:15 <Cale> sudeep: (:) is a data constructor, so you're able to pattern match against it in order to take the list apart again
12:45:18 * hackagebot haskellscrabble 0.1.0.2 - A scrabble library capturing the core game logic of scrabble.  http://hackage.haskell.org/package/haskellscrabble-0.1.0.2 (happy0)
12:45:34 <geekosaur> or, in English: (:) is a list constructor, equivalent to (cons) in Lisp. [] list notation, aside from the empty list [] itself, desugars to application of (:)
12:46:11 <Cale> Every (defined) list is either the empty list [], or it's a nonempty list constructed by applying (:) to some element and another list.
12:46:18 <worldsayshi> Question on fclabels (or alternative): Is there a way to make derived lenses for ADT:s manageable? I’m running getLabel on a GHC-api data type and I’m getting a 18-tuple. It’s a bit much…
12:46:31 <worldsayshi> Perhaps other lens libs can handle this in a better way?
12:47:24 <Cale> worldsayshi: um, let me remind myself what getLabel is
12:47:40 <worldsayshi> (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = $(getLabel ''Info)
12:47:43 <sudeep> why does 4 : 6 does not return [4,6]
12:48:04 <mauke> sudeep: because 6 is not a list
12:48:18 <UnrealQuester> you need a list
12:48:37 <geekosaur> [4,6] is 4 : 6 : []
12:48:41 <sudeep> mauke thanks
12:48:48 <geekosaur> with parentheses, (4 : (6 : []))
12:49:12 <worldsayshi> (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = $(getLabel ''Language.Haskell.TH.Info)
12:49:46 <sudeep> much deeply thanks geekosaur
12:49:59 <worldsayshi> Oh. Not GHC-api datatype. It’s a template haskell data type.
12:51:16 <sudeep> what is the equivalent of dir(print) like in haskell
12:51:28 <mauke> what's that?
12:52:03 <Cale> worldsayshi: Perhaps you could use mkLabels instead?
12:52:11 <Cale> (or mkLabelsNamed)
12:53:08 <Cale> worldsayshi: Then it just produces declarations for you and you don't have to deal with the big tuples.
12:53:37 <worldsayshi> Hmm. I thought mklabels only worked on records..
12:54:15 <dkinzer> hello, installed lambdabot .. I want it to join an IRC channel I created. How can I do this. I don't see a help or man pages.  Thanks.
12:54:57 <worldsayshi> Hmm, I might have glossed over the other alternatives in Data.Label.Derive a bit to quick though :)
12:55:10 <Cale> worldsayshi: Oh, it's not a record type...
12:55:16 <worldsayshi> yup
12:55:18 <worldsayshi> ADT
12:55:26 <dkinzer> OK, I think I found something useful: http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
12:55:58 <geekosaur> heh, that's still online
12:56:18 <worldsayshi> Oh, records might be considered ADTs too. :)
12:56:19 <geekosaur> it's not fully applicable to the lambdabot in here, it was for a custom installation that had most of the haskell specific stuff removed
12:56:27 <worldsayshi> Well, not recoeds
12:56:35 <Cale> worldsayshi: Right, looking at what Info is, that's not really well-suited to plain lenses.
12:56:38 <geekosaur> (and had a few things added for the use I was putting it to)
12:56:44 <Cale> worldsayshi: Perhaps a Prism would work
12:56:56 <gigabytes> guys
12:56:59 <worldsayshi> Cale: From the lens package?
12:57:03 <Cale> yeah
12:57:17 <gigabytes> I have to print, mostly for debugging purposes, a big expression that's coming from an AST
12:57:26 <worldsayshi> Yeah, looked at that for a bit. The type magic of lens scared me off a bit
12:57:34 <geekosaur> that said, it would be nice if someone recycled that page and updated it for current lambdabot
12:57:49 <Cale> worldsayshi: There are a bunch of different cases in this type, so it doesn't always make sense to extract any given field
12:57:51 <gigabytes> is there something ready that takes into account precedence and associativity of operators to remove parenthesis and things like that?
12:57:57 <Cale> (or set any given field)
12:58:21 <Cale> http://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-TH.html#v:makePrisms
12:58:40 <geekosaur> gigabytes, I don't think there's anything "canned" for it but you can probably do it with something from haskell-src-exts
12:59:34 <Cale> I hate that all the examples in the lens documentation use the awful infix operators
13:00:05 <worldsayshi> Cale: Yeah, I was thinking Prisms was the way to go. I haven’t found any good documentation on how to use them though. Kind of feel I have to understand all the types to use them. There’s a lot of types
13:00:06 <edwardk> Cale: submit a patch to add some more examples that use the explicit ones
13:00:10 <edwardk> we'll always take more examples
13:00:18 <gdoteof> i'm having a weird issue where when I run my app inside a docker, when the app tries to do a POST over SSL i get a TlsException (HandshakeFailed (Error_Protocol ("certificate rejected: [SelfSigned]",True,CertificateUnknown)))
13:00:39 <gdoteof> i don't get that error when i do it other times
13:00:52 <gdoteof> in other dockers, but different environments
13:01:03 <gdoteof> afaik, it is not a self signed certificate (i paid for it ..)
13:02:11 <gigabytes> geekosaur: might be too complex
13:02:35 <Cale> worldsayshi: Yeah, a lot of the types are a little more general than the most common types you'd use things at, for instance when you see a (Representable p) constraint, you can take p = (->) as a decent approximation.
13:03:06 <Cale> There are some other instances of Representable, but you're probably not that likely to use them directly
13:06:11 <worldsayshi> Oh, there are actually quite a few examples of Prisms in the fpcomplete lens tut. :) I’ll give it a go then: https://www.fpcomplete.com/user/tel/a-little-lens-starter-tutorial#okay--what-are-prisms---take-two-
13:12:50 <zmbmartin> So still trying to be more functional, can I any criticism on my code on this gist? Would it be considered ok? https://gist.github.com/codedmart/c554b3713fc5393cda6c
13:14:35 <indiagreen> zmbmartin: could you explain what exactly you're using «maybe'» for?
13:16:03 <zmbmartin> indiagreen: I just had a few spots of pattern matching that return different things so I use maybe' and maybeFmap as helpers?
13:17:38 <josephle> it seems to me maybe' == id?
13:17:59 <josephle> but I see you redefined id in your where-clause
13:18:20 <merijn> maybe' is id
13:18:54 <merijn> And maybeFmap is Data.Traversable.traverse :)
13:19:00 <merijn> :t T.traverse
13:19:01 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:19:06 <zmbmartin> josephle: Yeah I am sure I could name / not name things better. The code works but I am sure I could be more haskellish. That is why I was just looking for any obvious feedback.
13:19:12 <merijn> :t T.forM
13:19:13 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
13:19:28 <merijn> oh, not quite
13:19:35 <zmbmartin> merijn: Wait so there are functions for this already?
13:19:52 <zmbmartin> I could use Traversable instead?
13:20:13 <merijn> zmbmartin: It's quite different
13:20:23 <merijn> zmbmartin: But "fmap maybe'" is useless
13:20:31 <merijn> You should be able to remove it without any change
13:21:27 <zmbmartin> merijn: You are right
13:21:28 <merijn> and maybeFmap looks really weird
13:21:46 <josephle> any (func . maybe') can be simplified to func
13:21:56 <josephle> like your (return . maybe')
13:22:42 <zmbmartin> merijn: Yeah the idea I was trying to solve is if Just i then run the fmap else return Nothing
13:23:11 <zmbmartin> It does feel weird but wasn't sure of a better way.
13:23:14 <zmbmartin> Yet
13:24:28 <exio4> isn't maybeFmap just "\x → liftM (x >>)"?
13:24:35 <exio4> @type \x → liftM (x >>)
13:24:36 <lambdabot> (Monad m1, Monad m) => m1 a -> m (m1 b) -> m (m1 b)
13:25:02 <zmbmartin> exio4: So I could possibly try liftM?
13:26:42 <exio4> zmbmartin: maybe, I don't know what other people would think about that, but I like it :P
13:28:36 <zmbmartin> exio4: Not quite sure how to replace that with liftM?
13:29:32 <exio4> hmm? I mean, that your function "maybeFmap i f = ..." can be replaced with "maybeFmap x = liftM (x >>)"
13:30:14 <exio4> but I don't think you should replace the code with something you don't understand, at least that is what I do when I don't get something
13:36:49 <benzrf> :t liftM . (>>)
13:36:50 <lambdabot> (Monad m1, Monad m) => m1 a -> m (m1 b) -> m (m1 b)
13:37:03 <benzrf> #pointfree'd
13:37:53 <exio4> that works too
13:41:11 <trap_exit> what is the best way to parse haskell code?
13:41:14 <trap_exit> i.e. *.hs -> AST
13:43:53 <zmbmartin> Thanks everyone
13:43:58 <Saizan> trap_exit: haskell-src-exts or ghc itself
13:44:10 <trap_exit> what are the tradeoffs ?
13:44:17 <trap_exit> I'm a newb to parsing real world haskell code
13:47:35 <Saizan> i think haskell-src-exts is easier to deal with
13:48:06 <Saizan> but ghc is more authoritative
13:49:32 <trap_exit> is haskell-src-exts originallyf rom the hug interpreter?
13:50:49 <Saizan> i don't think so
13:51:44 <Saizan> hlint uses haskell-src-exts for example
13:51:59 <trap_exit> hmm
13:52:05 <trap_exit> if it's good enough for hlint, it's good enough for me :-)
14:07:00 <_rai> why does this blow up without the _? len lst = foldl (\c _ -> c + 1) 0 lst
14:08:16 <_rai> Couldn't match expected type `a -> Int' with actual type `Int'
14:08:51 <kadoban> _rai: Once you figure that out, foldl is a bad choice there. Read... http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
14:09:49 <Saizan> ?type foldl
14:09:50 <lambdabot> (b -> a -> b) -> b -> [a] -> b
14:10:06 <kadoban> _rai: And it's just wrong without the extra parameter. foldl takes a function that combines two things into one (\c -> c + 1) wouldn't be the right type
14:11:25 <DTSCode> can anyone explain how to fix this error? http://paste.ubuntu.com/8576028/
14:11:41 <_rai> ok i see it now, the type error messages are a bit hard to understand
14:12:02 <stelleg> is is there a maybeIndex?
14:12:06 <stelleg> hoogle isn't turning anything up
14:12:15 <mauke> @hoogle [a] -> Int -> Maybe a
14:12:17 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:12:17 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:12:17 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
14:12:30 <geekosaur> DTSCode, it might help if the bot output what it receiv ed before the disconnect. I would guess the nick it sent was in use
14:12:32 <stelleg> wouldn't be hard to write
14:12:35 <mauke> :t \n -> listToMaybe . drop n
14:12:36 <lambdabot> Int -> [a] -> Maybe a
14:12:57 <stelleg> mauke: nice
14:13:00 <geekosaur> like, for example, if it signs on with nick "geordi", that's in use by the real one
14:13:13 <DTSCode> it does it with geordiclone though
14:13:15 <geekosaur> so it would get booted if it doesn't have a backup nick
14:13:21 <stelleg> mauke: thanks
14:13:22 <DTSCode> which isnt in use
14:13:30 <mauke> DTSCode: try strace?
14:13:45 <DTSCode> also, i dont think i can get it to output the server responses
14:13:49 <indiagreen> stelleg: there's “atMay” in safe package, which you might want to use if you need more than one safe function
14:13:50 <DTSCode> mauke, whats strace?
14:14:04 <mauke> a program
14:15:35 <stelleg> indiagreen: thanks, will keep in mind
14:15:56 <jle`> let's get a (!?)
14:16:06 <jle`> the best solution is always more operators
14:16:11 <stelleg> jle`: :)
14:16:35 <geekosaur> plarform matters, it's strace on linux, truss on *bsd / solaris, dtruss (and requires root) on os x, ...
14:16:42 <geekosaur> and $DEITY help you on windows
14:16:51 <geekosaur> (I think sysinternals may have something)
14:16:56 <DTSCode> im on an arch based system
14:17:20 <monochrom> that counts as linux, so it's strace
14:17:25 <jle`> > let xs !? n = listToMaybe (drop n xs) in ([1,2,3] !? 2, [1,2,3] !? 10)
14:17:27 <lambdabot>  (Just 3,Nothing)
14:17:42 <KingFilip> hello guys, is anyone here familiar with parsing xmltrees?
14:18:00 <stelleg> jle`: I like it, using that name
14:18:09 <jle`> daily reminder that jumping between languages with zero based indexes and one based indexes is very disorienting
14:18:13 <jle`> stelleg: don't do it :P
14:18:30 <stelleg> too late :)
14:18:39 <jle`> i'm too late
14:19:02 <vjeranc> I've seen a recent talk by Bryan O'Sullivan on benchmarking and his criterion library, anyone else seen it? I'm interested into why doesn't GHC do the unpacking of variables and bang optimization mentioned in the end of the lecture?
14:19:04 <monochrom> use ! and ? to write any binary string :)
14:19:28 <jle`> i think whenever someone introduces (!!) they should explain why it's called (!!)
14:19:42 <geekosaur> ghc can unpack but sometimes it's a bad idea
14:19:45 <doismellburning> why is it called !!?
14:19:58 <DTSCode> i have strace installed now. how would i use it to test geordi?
14:19:59 <jle`> it's short for "why the heck are you doing this!!"
14:20:09 <geekosaur> notably you can get into situations when most of the time spent in your code is repeatedly unboxing and reboxing, because it couldn't eliminate all the boxes
14:20:23 <monochrom> it will be a great April 1st joke to announce Data.Bitstring whose Show instance uses ! and ? :)
14:20:28 * hackagebot alea 0.2.0.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.2.0.0 (rnhmjoj)
14:20:38 <jle`> names with "!!" usually signify dangerous things or warnings in programming languages
14:20:57 <dmj`> vjeranc: haskell is non-strict by default, ghc would have to predict your heap allocation during compilation
14:21:48 <vjeranc> dmj`: does this mean that the optimization isn't done for the sake of laziness?
14:22:50 <tromp> > 60*60*24*7
14:22:52 <lambdabot>  604800
14:22:57 <geekosaur> DTSCode, "sudo -u dtscode strace <command and arguments here> 2>&1 | tee strace.out" and then look at the logged output. (do NOT pastebin it without checking it for passwords etc.!)
14:23:11 <tromp> > product [1..10]
14:23:12 <lambdabot>  3628800
14:23:29 <tromp> > 6*604800
14:23:30 <lambdabot>  3628800
14:23:35 <mauke> strace -o strace.out ...
14:23:41 <DTSCode> geekosaur, ty
14:23:44 <dmj`> vjeranc: sometimes adding additional strictness can be detrimental to performance
14:23:58 <geekosaur> mauke, I considered that but the sudo has me worried about write permissions
14:24:28 <geekosaur> (if you look at the original paste; first thing there is sudo asking for a password)
14:24:43 <KingFilip> is anyone here that may help me out a bit with hxt package and xml parsing?
14:25:28 * hackagebot hzulip 0.4.1.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.4.1.0 (yamadapc)
14:25:44 <jle`> strictness more often hurts performance than helps it
14:25:59 <monochrom> KingFilip: my http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml may be of help if you want to know the basics
14:26:48 <KingFilip> i've gotten a hand of the basics, its just a specific problem i have that I'm having real trouble solving for more than a few hours
14:27:26 <KingFilip> its basically when i use arrows to sort out the nodes i really need, and i actually get parent nodes which have children like <quote> and a few "<p>"s
14:27:27 <monochrom> I haven't written hxt programs for a few years. I'm rusty, so I may not be of great help
14:27:31 <DTSCode> ok this is the output http://paste.ubuntu.com/8576089/
14:28:12 <KingFilip> and i want to use &&& to pair the "quote" with text in "<p>", but i have a few <p>s that i dont know how to group
14:28:29 <mauke> oh, docker
14:32:48 <casidiablo> Hi guys, I'm trying to implement a function that takes a String and returns an Int (one of the exercises in RWH). Implementing it with foldl was easy; and now I'm trying using foldr
14:33:19 <casidiablo> I don't like my current solution which looks like this: "fst $ foldr folder (0, 1) input"
14:33:59 <casidiablo> Where folder takes a digit and a tuple, where I keep the current accumulated value and the current multiple of 10.
14:34:20 <casidiablo> Is there any simpler way to implement this algorithm using foldr?
14:34:29 <DTSCode> mauke, yeah it uses docker
14:35:34 <ec2-user_> hi?
14:35:35 <monochrom> casidiablo, does it mean that you want to turn "143" into 143?
14:35:54 <jle`> > let f _ = 2 in f "hello"
14:35:55 <lambdabot>  2
14:36:11 <casidiablo> monochrom: yes
14:36:38 <ChandlerSyx> omg hi jle1
14:36:40 <ChandlerSyx> omg hi jle`
14:36:59 <monochrom> I can't think of an alternative
14:37:01 <jle`> hi ChandlerSyx
14:38:14 <ChandlerSyx> i stumbled upon this channel via ycombinator, i thought it was interesting and wanted to know if I could get some direction to alternatives to stacksocial.com :)
14:38:20 <trap_exit> whoa ... does Fay (https://github.com/faylang/fay/blob/master/fay.cabal#L126) basically just use haskell-src-exts as the parser
14:38:25 <trap_exit> and then only focus on he js translation part?
14:38:54 <Denommus> I'm about to use Elm instead of Haskell for doing my application
14:39:02 <Denommus> I simply CAN'T express what I want in Glade, and the only bindings for Qt I have found in Haskell are for QML. I don't want to touch JavaScript at all
14:39:21 <trap_exit> Elm?
14:39:24 <trap_exit> why not use haste ?
14:39:39 <trap_exit> haste is awesome
14:39:47 <trap_exit> there's fay, haste, ghcjs
14:40:07 <trap_exit> fay is the easiest to setup, ghcjs is the most haskell compatible, haste is the optimized middle I like
14:40:24 <trap_exit> haste does not support template haskell (ghcjs does), haste is not as fast as ghcjs, but I like haste
14:40:27 <DTSCode> what are they?
14:40:38 <Denommus> trap_exit: I already have set up ghcjs. Can I run a FRP library on top of it?
14:41:00 <jle`> elm is not haskell
14:41:03 <jle`> it's a different language
14:41:04 <trap_exit> good question. I've never tried using a JS FRP library + ghcjs.
14:41:20 <trap_exit> luite: can Denommus run a FRP library on top of ghcjs?
14:41:23 <jle`> ghcjs is supposed to work with sodium
14:41:29 <trap_exit> well, the answer is probably "yes" the real question is "haow hard is it to ..."
14:41:44 <Denommus> jle`: I know, but I'm interested in the concept of using FRP for producing a GUI application, not in Haskell, strictly speaking
14:41:45 <luite> Denommus: what kind of FRP lib?
14:41:56 <Denommus> luite: reactive-banana, for instance
14:42:03 <luite> Denommus: oh that works yeah
14:42:20 <jle`> Denommus: yeah, i was saying that in response to trap_exit ; using elm is not the same as using haskell, they aren't quite interchangeable
14:42:22 <luite> Denommus: netwire and sodium work too
14:42:31 <jle`> also elm isn't real frp but
14:42:33 * jle` steps out
14:42:49 <jle`> (but it still works well for guis)
14:42:58 <Denommus> luite: which one is easier to provide bindings for DOM events? Reactive-banana is quite easy in that regard, as far as I have used it with Gtk2Hs
14:42:59 <jle`> (maybe this "real frp" business is not a useful conversation anyway)
14:43:14 <Denommus> jle`: what do you mean by "real frp"?
14:43:26 <Denommus> jle`: what is its problem in that regard?
14:43:35 <jle`> frp as originally defined by the original papers
14:43:38 <jle`> and libraries
14:43:38 <trap_exit> real frp = frp witten in haskell and blessed by conal
14:43:55 <jle`> FRP is language-independent :P
14:44:33 <Denommus> jle`: I don't know that much about Elm, so I can't tell, but I have read some papers about using it
14:44:34 <jle`> FRP is two things: (1) continuous-time semantics, (2) denotative api
14:44:42 <jle`> Elm is good and powerful and awesome and great
14:44:59 <jle`> but it isn't great becasue of frp
14:45:07 <jle`> it's great because it's great as its own thing
14:45:24 <jle`> <3 elm
14:45:31 * hackagebot positive 0.1 - Positive numbers.  http://hackage.haskell.org/package/positive-0.1 (HansHoglund)
14:45:32 <luite> Denommus: ah i don't quite know yet. sodium is pretty simple but the implementation is a tad hairy. it also pulls in a lot of code from other packages and has some heavy deps
14:45:33 * hackagebot positive 0.2 - Positive numbers.  http://hackage.haskell.org/package/positive-0.2 (HansHoglund)
14:45:37 <jle`> elm violates #1 tho
14:45:49 <jle`> but just because it's not frp doesn't mean it's not useful
14:45:54 <luite> Denommus: which can probably be fixed once we have GHC 7.10 and backpack
14:46:04 <trap_exit> hmm, if all I want is frp + discrete time (no continuous time), what is it called ?
14:46:27 <jle`> i don't know
14:46:40 <jle`> that's something i have been asking for a while :P
14:46:45 <jle`> but it might be something like my `auto` library
14:47:06 <luite> Denommus: someone recently did some netwire experiments, but i don't know how far they got
14:47:09 <trap_exit> jle`: self promotion ...
14:47:11 <trap_exit> jle`: where is your auto library ?
14:47:17 <jle`> still in progress
14:47:19 <jle`> :P
14:47:28 <jle`> http://github.com/mstksg/auto ; http://github.com/mstksg/auto-examples
14:49:52 <luite> Denommus: do you have a rough idea of the api you want to implement/use, or some example language/library to model it on?
14:50:16 <trap_exit> this is terrible
14:50:16 <trap_exit> self promotion
14:50:16 <trap_exit> and then you don't share it :-/
14:50:16 <DTSCode> so any luck mauke
14:50:19 <Denommus> luite: I want to make a XMPP client
14:50:47 <trap_exit> anyone here know what frp , with continuous time replaced with discrete time is called ?
14:50:52 <trap_exit> i feel like this shows up a lot in web dev
14:51:05 <trap_exit> I don't have spinny things I need continuous time for, butI have lots of discrete events, like mouse down, key press, etc ..
14:51:29 <monochrom> is it "event loop"?
14:51:58 <trap_exit> how is event loop functional  and reactive ?
14:52:18 <trap_exit> loops seems like one of the most descturctive-updaget things ever
14:52:54 <monochrom> then, is it "event-driven programming"?
14:53:03 <luite> Denommus: are you going to use a websocket connection to forward the XMPP data to the browser, or perhaps more logic/state on the server?
14:53:34 <Denommus> luite: I probably shall use websockets, yes
14:55:44 <trap_exit> luite: I apologize for what I'm about to do
14:55:48 <trap_exit> Denommus: have you seen https://github.com/valderman/haste-compiler/blob/master/examples/chatbox/chatbox.hs ?
14:56:00 <Guest50692> where Propellerhead Reason
14:56:08 <trap_exit> Denommus: you can avoid the whole websocket / serialization work with Haste
14:56:15 <geekosaur> wat
14:56:15 <Denommus> trap_exit: I have not
14:56:36 <trap_exit> Denommus: so basically you have server / client functions in Server () / Client () monads ... then you can call a Server function from the Client ... and Haste does all the serialization / websocket / mangling for you
14:56:55 <Guest50692> can i found Propellerhead Reason
14:57:01 <Denommus> trap_exit: interesting
14:57:17 <geekosaur> Guest50692, wrong channel
14:57:27 <luite> Denommus: it's not all that hard to implement the same thing for ghcjs, but trap_exit is too lazy to do it and keeps bugging me for it ;p
14:57:28 <trap_exit> Denommus: its inspiring; after playing with the chatbox example (it's literarlly < 100 lines), I went off and read the entire haste source code to understand how it works
14:57:38 <trap_exit> luite: yes :-)
14:58:55 <trap_exit> so the crazy thing is that ... there's no websockets visible, there's no manglign visible ...
14:59:04 <trap_exit> you declare data types, have them derive Binary (which makes them serialiazble)
14:59:18 <trap_exit> then you have a list on the server, ... which gets returned to client functions, ... and magic !
14:59:41 <trap_exit> http://haste-lang.org/icfp14.pdf is the paper, but the code in the paper is out dated, so read the github code instead
14:59:58 <luite> Denommus: I'm personally not quite sold yet on the tight client/server integration of this programming model, since there is no support for error recovery and resynchronization. if that can be added, it'd be much higher priority to implement it for ghcjs :)
15:00:44 <Denommus> luite: I... also don't trust a lot in tight integration
15:01:46 <trap_exit> luite: you mean "what happens when a websocket gets disconected" ?
15:04:06 <luite> Denommus: just the requirement that something can be serialized isn't quite enough, it seems, to make it reliable/resumable. I chatted with Anton after his talk at HS2014 about this, suggested looking into CRDTs. I'd be really nice if some more restrictions could be expressed in the typesystem that could make a client reconnect at any point and synchronize with the server
15:04:30 <luite> Denommus: where the client can keep working independently (to some extent) even while the server is not immediately reachable
15:05:07 <luite> but that probably requires a bit of work to implment :)
15:06:04 <trap_exit> if only haste/ghcjs could get into an implementation war
15:06:11 <trap_exit> to see who does it first
15:06:23 <luite> trap_exit: yes and also overcoming latency, and taking over a connection from wifi with 4g for example
15:06:47 <trap_exit> I don't see latency being a problem
15:06:56 <trap_exit> whenever I make a remote call, there's this big Haste.App.onServer $ ...
15:07:06 <trap_exit> so I look at it, and I'm like "oh, I'm making a server call"
15:08:09 <latk> Is there a way to combine two aeson Value datatypes? Something like concatenating lists ?
15:08:21 <Denommus> luite: yes, probably
15:08:32 <trap_exit> thus, from the client sid,e it' spretty clear to me when I run into "oh, this function might be taking a long time due to latency"
15:08:34 <Denommus> luite: I'm still getting my head around compiling and running a GHCJS application
15:09:22 <Fuuzetsu> luite: seems someone is trying to make GHCJS same-class citizen as GHC in nix ;)
15:09:34 <luite> trap_exit: what should your app do if you click delete on a list of users and the server takes a while to respond?
15:10:07 <trap_exit> I dunno? how would you handle this in GHCJS? I'm pretty sure you can (1) forkIO the Haste.App.onServer ... and (2) set a timeout
15:10:29 <trap_exit> luite: I think these are problems any ajax app faces, not Haste specific
15:10:34 * hackagebot positive 0.3 - Positive numbers.  http://hackage.haskell.org/package/positive-0.3 (HansHoglund)
15:11:36 <trap_exit> to me, what I save with Haste is (1) serialization / deserizalitaion, and (2) a giganticcase on the server side, which registers which functions to call when it gets which data type
15:12:43 <luite> trap_exit: say you first delete one user, then you rename another to have the username of the one you deleted. if you do this with synchronous remote calls, you'll have to wait in between. if you set it up as a CRDT you can continue and synchronize in the background (you might get a message about how some merge was resolved in case of concurrent editing)
15:13:09 <trap_exit> what's CRDT ?
15:13:32 <luite> trap_exit: it's not a limitation of the compiler, just of the library
15:13:56 <trap_exit> http://kellabyte.com/2013/05/20/convergent-replicated-data-types/ ? <-- is ths CRDT ?
15:14:09 <luite> trap_exit: convergent replicated data types yes, bit in practice any eventual consistency scheme would work
15:14:16 <trap_exit> luite: I'm not convinced of your argument yet
15:14:28 <trap_exit> luite: why do Haste calls have ot be serialized ?
15:14:43 <monochrom> onoes, no Haskell Weekly News this week!
15:14:58 <napping> Has anyone here used compdata much?
15:15:01 <trap_exit> luite: so you're saying, ... if I have two haste js threads (say via forkIO), and both of them make Haste.App.onServer calls ... the calls are serialized, and one does not happen until the other finishes?
15:15:02 <Fuuzetsu> monochrom: why
15:15:19 <dmj`> trap_exit: the browser is single threaded
15:15:24 <trap_exit> luite: I do not understnd the Haste runtime well enough to know whether you are right or wrong -- but why do you believe this?
15:15:34 * hackagebot alea 0.2.1.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.2.1.0 (rnhmjoj)
15:15:42 <trap_exit> dmj`: yes, but you can have multiple ajax calls at the same time
15:15:49 <luite> dmj`: haste.app has cooperative threads (ghcjs preemptive threads)
15:15:58 <trap_exit> haste 'threads' works via some weird poor-man's concurency monad
15:16:11 <dmj`> luite: so its like one thread pretending to be two threads
15:16:12 <dmj`> ?
15:16:22 <trap_exit> luite: are you saying that if I submit two haste ajax calls, one ajax call does not start until the other finishes?
15:16:34 <geekosaur> cooperative = one thread must explicitly yield to let another run
15:17:28 <geekosaur> (sometimes this can be hooked into specific operations, but that only works well for some workloads. compare for example how ghc's non-threaded runtime only switches threads on a memory allocation)
15:17:33 <geekosaur> (iirc)
15:18:27 <geekosaur> (where again "non-threaded" means one machine thread and Haskell threads must do something to force yielding to another thread, which may be blocking on I/O or a memory allocation)
15:19:31 <RchrdB> geekosaur: fwiw, GHC's threaded runtime only switches on memory allocation, too.
15:19:50 <jle`> would there be any benefit to representing ADT values in memory in church-encoded form
15:20:07 <geekosaur> for N:M I believe that. but it's still multiple threads so there is *some* ability to execute concurrently, depending on +RTS -N
15:20:17 <RchrdB> Yeah.
15:20:19 <jle`> does "labeled box" form take less space or something
15:21:00 <napping> jle`: only disadvantages, I think
15:21:02 <jle`> does `const` take up more space or something than, say, Nothing
15:21:25 <jle`> aw
15:21:28 <RchrdB> IIRC it's done on memory allocation because allocations are frequent, and because Haskell code already needs to be able to be pre-empted every time it tries to allocate, because the allocator might decide to invoke GC.
15:21:32 <trap_exit> luite: sorry, I still don't understand your example of where Haste is inferior
15:21:48 <napping> You'd have to look up the exact details, but I think you get something like a heap value with an "info" field saying it's a closure, then a pointer to the code, and then whatever you are closing over
15:21:48 <Saizan> so, shouldn't cabal repl pick up the .hi from a previous cabal build instead of interpreting everything?
15:22:04 <napping> while an actual value has an info pointer that tell it what specific constructor you have
15:22:20 <napping> and some entry code you can jump to that returns the value or does the case or whatever
15:22:42 <luite> trap_exit: it's not about the runtime at all, it's just what the library makes easy to do. i'm just not terribly convinced that 'onServer' with shared mutable state is actually all that convenient for asynchronous state updates
15:22:48 <napping> I'm not sure if closures can also pack the code pointer and entry table in a similar way
15:23:01 <Ralith> what datetime library do people use these days
15:23:09 <napping> I mean combine the "info" with the code to jump to, in code-next-to-tables style
15:23:37 <napping> You certainly lose out on things like pointer tagging that come from knowing there are a small fixed number of "special" constructors
15:24:18 <dmj`> Ralith: time
15:24:50 <luite> trap_exit: i never said it was inferior, it just doesn't solve the part of the problem that i think is the most important for actually making client<->server mostly seamless
15:25:29 <trap_exit> luite: I don't understand the logic behind "Haste.App.onServer" can not handle async updates -- this may be because I don't understand how Hst eruntime work under the hood as well as I should
15:29:11 <Denommus> luite: does the .jsexe file run with nodejs normally?
15:29:48 <Denommus> luite: also, which library do you recommend for interoping with JS? JSC?
15:33:03 <luite> trap_exit: i didn't claim it can't handle them, but it doesn't provide any help to conveniently make async updates work nicely. since background syncronization, resuming an interrupted connection, hiding latency and efficient incremental updates are closely interrelated, i think that's actually the more interesting part of the problem domain
15:35:37 <luite> trap_exit: if you don't have a good way to hide communication issues in a practical setting, i'm not convinced that depending on connection-specific state on the server is a good idea.
15:36:01 <luite> Denommus: the all.js file is runnable with node.js (unless you linked with -DGHCJS_BROWSER)
15:36:16 <trap_exit> luite: I think we are still trying to debate despite having differnet "axioms"
15:36:17 <luite> Denommus: if you're just building a browser app, you can use the javascript ffi
15:36:32 <trap_exit> i.e. I think we believe dieffernt things about how Haste work, but I'm not sure what those differences are
15:36:48 <Denommus> luite: I just notice it generates a index.html
15:36:55 <luite> trap_exit: everything i'm saying is totally independent of how the compiler works
15:37:17 <trap_exit> well, when i say Haste, I'm also including Haste.App
15:37:29 <trap_exit> I think we have different mental models of how Haste.App works; but I don't know what those differences are yet
15:40:57 <luite> trap_exit: i'm just saying that the requirement of the data being serializable is not enough in my opinion to create an app that's actually "seamless". i'm saying that having the additional requirement of it being synchronizable (a la CRDTs) and removing the dependency on connection-specific server state would be a way to fix this
15:41:35 <trap_exit> I dunno, I think that's an 'app' problem and not a 'framework' problem
15:41:52 <trap_exit> i.e. the writer of the app should design how incremental updates work / how synchronization work
15:41:55 <trap_exit> not have the framework decide it befor ehand
15:43:01 <luite> trap_exit: however, removing the connection-specific server state means we're mostly back to traditional RPC interfaces. implementing CRDTs in such a framework setting is not quite a solved problem yet, so for now I think traditional RPC is actually preferable
15:43:58 <Denommus> I wonder if GHCJS works fine with ghc-mod
15:44:06 <trap_exit> luite: I don't see Haste.App as anything mroe than (1) you donm't have to serailize / deserialize, and (2) on the server side, you don't have a gigantic switch statement of "case INPUT of different types of rpc -> actual function call"
15:44:15 <trap_exit> luite: do you believe Haste.App provides more?
15:44:28 <luite> trap_exit: yes, access to connection-specific mutable state in the Server monad
15:44:45 <trap_exit> luite: you're referring to Haste.App.getSessionID and Haste.App.getActiveSessions ?
15:44:47 <trap_exit> or something else?
15:46:32 <luite> Denommus: I'm pretty sure it doesn't. it should be fixably with a few modifications to use the GHCJS package db and JavaScriptArch GHC API settings in ghc-mod
15:51:06 * YurasS looking for "MonadIO considered harmful" style articles
15:51:30 * YurasS don't believe nobody wrote one
15:52:01 <Denommus> YurasS: why would monad IO be harmful?
15:52:30 <Denommus> (I actually have been having more trouble getting my head around non-monadic IO the past few days)
15:53:06 <YurasS> Denommus: because people use it instead if IO and then have to liftIO everywhere
15:53:28 <YurasS> I don't mean IO, but MonadIO type class
15:53:35 <Denommus> YurasS: ah, sorry
15:53:43 <YurasS> http://www.reddit.com/r/haskell/comments/2jg4y5/hiding_liftio/
15:54:02 <Denommus> isn't... MonadIO, I dunno, redundant?
15:54:27 <YurasS> Denommus: sometimes it is useful... probably
15:54:39 <merijn> It is useful often
15:54:41 <Axman6> like for when you actually need to get stuff done...
15:54:50 <merijn> It makes lifting IO into a transformer stack easy
15:56:08 <YurasS> merijn: yes, but it is misused to often
15:56:14 <dmj`> YurasS: how so?
15:57:53 <YurasS> dmj`: writing ":: (App m, MonadIO m, ...) => m a" instead of ":: App -> IO a" is misuse
15:58:01 <Denommus> luite: are you still there?
16:02:54 <dmj`> YurasS: why
16:03:21 <jle`> but sometimes your monad isn't IO...
16:03:36 <jle`> or is competely unrelated to IO
16:04:27 <YurasS> dmj`: because you already have IO at the bottom of your transformer stack
16:04:30 <jle`> or sometimes you want to write code generic for all MonadIO's, some that might not be IO
16:04:40 <jle`> MonadIO has nothing to do with transformers or transformer stacks
16:05:14 <jle`> most of my MonadIO's are unrelated to any transformers
16:06:00 <luite> Denommus: sorry was away for a bit
16:06:26 <YurasS> jle`: I agree that there are legitimate usages
16:07:03 <jle`> yeah, and there are misuses too
16:07:05 <YurasS> but do you think the example above is legitimate usage?
16:07:09 <jle`> i'm not sure i understand your example
16:07:47 <jle`> What is App?
16:07:48 <dmj`> YurasS: why not just do type MyStack a = StateT MyState IO a
16:07:53 <jle`> there seems to be some kind mismatch
16:08:11 <dmj`> f :: MyStack (); f = liftIO $ print "hi"
16:08:22 <luite> hmm trap_exit is gone
16:08:45 <YurasS> jle`: in the first case App is typeclass, in the second -- just a type
16:09:17 <YurasS> basically, one should not use MonadIO when IO is ok
16:09:53 <merijn> jle`: wut
16:10:17 <jle`> yeah, i think there are people that agree that having functions parametric over all MonadIO has some disadvantages
16:10:23 <merijn> jle`: MonadIO has *everything* to do with transformer stacks, it's the only reason it exists
16:10:27 <Denommus> luite: well, I'm trying to run webkit-hello
16:10:41 <jle`> Tekmo has a lot of functions in pipes that he regrets making generic over all MonadIO
16:11:04 <Denommus> luite: but Graphics.UI.Gtk.WebKit.GHCJS doesn't exist
16:11:06 <jle`> merijn: not inherently...it represents a type with a monad morphism from IO into that type
16:11:19 <Denommus> luite: which dependency should I add to the project for it?
16:11:27 <jle`> data IOReader r a = IOReader (r -> IO a)
16:11:27 <YurasS> jle`: I don't know Tekmo, but he is probably smart person :)
16:11:40 <jle`> IOReader can have a meaningful MonadIO instance
16:11:42 <jle`> but
16:11:50 <jle`> s/meaningful/very very useful
16:11:57 <luite> Denommus: oh i don't remember if i replied earlier. if you want to make something that runs in browsers you can just use the javascript ffi, for cross-platform that also runs as native code but with a webkit frame gui you can use the ghcjs-dom things
16:11:57 <jle`> but it has nothing to do with transformers...
16:12:25 <jle`> i have a lot of types that are MonadIO, but unrelated to any sort of transformers
16:13:09 <Denommus> luite: ghcjs-dom is a dependency for my project
16:13:49 <jle`> IOReader also has a useful and meaningful MonadReader instance
16:14:05 <Denommus> luite: maybe the module name changed?
16:14:24 <luite> Denommus: you can use ghcjs-dom-hello as an example for a program that can be compiled with either ghc or ghcjs.
16:14:34 <jle`> and if you hide the constructor, it can have a usefl MonadState Int (or some other fixed type) instance.
16:14:37 <luite> Denommus: where did you get that example?
16:14:51 <Denommus> luite: https://github.com/ghcjs/ghcjs-examples/tree/master/webkit-hello
16:15:06 <luite> Denommus: might be outdated. hamishmack usually knows more about these libs :)
16:15:12 <Denommus> luite: oh!
16:15:31 <luite> Denommus: yeah that looks like it's for a very old version, try ghcjs-dom-hello first
16:16:06 <Denommus> luite: I'll check it
16:16:45 <Denommus> luite: thanks a lot
16:17:13 <YurasS> jle`: "code generic for all MonadIO's, some that might not be IO" Example?
16:17:59 <YurasS> you can't inject IO into non-IO based monad
16:18:06 <YurasS> or you can?
16:18:19 <jle`> IOReader above is a MonadIO
16:18:40 <YurasS> it is based on IO, but I see the point
16:18:49 <luite> Denommus: the examples (and other) repo should really be added to some build bot so we know when things break...
16:19:30 <jle`> i think what i was saying before is that *instances* of MonadIO are useful
16:19:47 <jle`> but writing functions parameterized for all MonadIO is rarely necessary
16:20:05 <YurasS> jle`: now I'm totaly agreed
16:20:12 <orb_> https://github.com/matthiasgoergens/redgrep has my regular expression matcher that also support complement and intersection.
16:20:31 <jle`> um
16:20:37 <orb_> Not polished, yet.
16:20:45 <jle`> i wonder what Tekmo's point/reason was on that
16:21:01 <jle`> cause it does lead to much cleaner application code
16:21:52 <dmj`> I like MonadIO
16:22:03 <jle`> (functions parametric over MonadIO, that is)
16:22:12 <YurasS> I had sooo many troubles with my pdf-toolbox because I based it on MonadIO :(
16:22:20 <jle`> but why?
16:22:37 <jle`> anywhere you could use an IO a, you can use a MonadIO m => m a
16:22:45 <jle`> *you need an IO a
16:23:18 <jle`> because IO has a neat MonadIO instance
16:23:28 <YurasS> jle`: not MonadIO itself, but the design it imply
16:23:34 <jle`> hm
16:23:39 <jle`> thjat i'd have to see mnore examples of
16:23:40 <YurasS> transformet stack based on MonadIO
16:24:06 <YurasS> exceptions becomes a big issue
16:24:56 <YurasS> you can't easily forkIO etc
16:25:02 <jle`> well i don't really like transformer stacks in general so :|
16:25:39 <dmj`> I like MonadIO because it lets you do things
16:25:42 <dmj`> like IO
16:25:42 <casidiablo> How can I make Hoogle return documentation about a function (not just the type)? (I'm running it from the command line)
16:26:09 <YurasS> dmj`: then just use IO :)
16:26:12 <jle`> well the type can already do IO, even if it didn't have a MonadIO instance
16:26:22 <jle`> the only thing MonadIO adds is a unified interface
16:26:24 <dmj`> YurasS: I need transformers though
16:26:33 <jle`> so you don't need a custom lifter for every type
16:27:06 <jle`> you can also write "generic" functions generic over all MonadIO, but that is what we are considering has limited usefulness
16:27:09 <merijn> YurasS: For exceptions in transformer stacks there is the exceptions library :)
16:27:25 <dmj`> YurasS: you need transformers to do more complex things, like, you can't get around it
16:27:32 <merijn> dmj`: No one's arguing against the MonadIO class
16:27:58 <dmj`> merijn: sounds like YurasS is
16:28:02 <merijn> dmj`: You're confused about the conversation, I think. The discussion is that your functions/types should never be "foo :: MonadIO m => ..."
16:28:24 <dmj`> merijn: no, I don't think so
16:28:28 <dmj`> merijn: he said, "<YurasS> dmj`: then just use IO :)"
16:28:37 <jle`> YurasS is saying that MonadIO is useful, but writing functions parametric for all MonadIO is of limited usefulness
16:28:40 <jle`> ...i think
16:29:10 <YurasS> yes, I don't propose to remove MonadIO :)
16:29:14 <jle`> and intead of writing your function parametric over all MonadIO m, just write it for IO
16:29:20 <Denommus> damn, there's an error in gtk3
16:29:29 <jle`> (and then use liftIO whenever you actually use it)
16:30:17 <jle`> i can't think of many non-contrived situations where this isn't possible
16:30:46 <jle`> a problem, like the reddit post mentions, is that liftIO $ everywhere can degrade to just line noise
16:31:47 <jle`> actually jrk-'s situation in the reddit is probably a good situation
16:32:09 <jle`> (MonadState s m, MonadIO m) => m ()
16:32:21 <jle`> you can't just pop in IO there
16:33:36 <jle`> ok so i reneg
16:34:02 <YurasS> jle`: well, he propose the alias "type App m = (..., MonadIO m, ...)
16:34:03 <jle`> *renege
16:34:06 <jle`> sorry Yuras
16:34:32 <jle`> i see it as very useful now
16:34:36 * jle` covers ears
16:34:40 <YurasS> so probably just need a newtype over IORef and that is all
16:34:42 <YurasS> ok
16:35:06 <jle`> just kidding :)
16:35:28 <jle`> writing functions polymorphic over a Monad that can be both MonadIO and MonadReader r etc. is a useful case
16:35:58 <YurasS> goto is useful sometimes
16:36:15 <YurasS> I used goto yesterday in objective-c :)
16:36:36 <jle`> yeah but this is a shining use case fo MonadIO :O that happens often :O
16:36:51 <Denommus> I have never, ever, in the course of my entire life, used goto outside of C
16:36:58 <jle`> i don't know if type aliases for constraints is cool though. i have hesitated to use them but a lot of people like it
16:37:01 <jle`> just me personally
16:37:36 <jle`> you should really only have the minimal number of constraints necessary
16:37:49 <jle`> that's the whole *point* of using MonadIO/MonadReader in the first place
16:37:59 <jle`> to be able to restrict what you can do or reason about
16:38:17 <jle`> if you are writing functions for MonadReader r m, you know that that function can't do any IO
16:38:31 <jle`> whereas if you use MyAppMonad, you don't have any guaruntees
16:38:41 <jle`> if MyAppMonad is MonadIO
16:38:46 <YurasS> jle`: hmm, that makes sense
16:38:57 <Fuuzetsu> jle`: MonadReader r IO ?
16:38:59 <YurasS> with MonadIO it just *looks* safe
16:39:06 <YurasS> looks pure
16:39:16 <jle`> Fuuzetsu: i mean typeclases like MonadReader and MonadState
16:39:47 <Fuuzetsu> I had to restart emacs so I don't have the log
16:39:51 <jle`> if you write them parametric over all MonadReader, instead of for your actual application type, you can write functions for your application type that are guarunteed to not do io, etc.
16:40:36 <Denommus> anyone else having problems to compile gtk3?
16:40:45 <jle`> and using a giant type alias for a giant constraint blob basically takes away all of that
16:40:54 <fib1123> So, I have a hue and a luma/luminance/lightness (any/all) and I want to determine the most saturated color with those two properties.
16:41:16 <fib1123> Can anyone think of the best way to do that with the colour library?  Or any library?
16:41:50 <jle`> ok today i decide that giant type alias for constraint blobs is bad
16:42:09 <Fuuzetsu> why
16:42:21 <Fuuzetsu> are you using that one extension that lets you alias tuples of constraints?
16:42:29 <jle`> i'm referring to that
16:42:45 <jle`> and i will begin my campaign to make it considered bad practice
16:42:53 <Fuuzetsu> why
16:42:58 <Fuuzetsu> personally I don't use it
16:43:00 <YurasS> jle`: :)
16:43:17 <jle`> you should always use the least amount of constraints possible
16:43:29 <YurasS> MonadIO considered harmful!!!
16:43:33 <jle`> otherwise you miss the entire point of having them typeclasses at all
16:44:34 <Fuuzetsu> jle`: that just tells me that you didn't use it right
16:44:38 <Fuuzetsu> rather than it being bad
16:44:56 <jle`> i'm referring to www.reddit.com/r/haskell/comments/2jg4y5/hiding_liftio/clbgj98
16:45:02 <jle`> what good usage is there of this?
16:46:15 <Fuuzetsu> whenever you have a repeating blob of constraints, that's literally what it's for
16:46:23 <Fuuzetsu> if you never have this problem then don't use it
16:46:56 <jle`> but why are you having repeating blobs of constraints ... ?  i'm sure not all of your functions use *every* constraint
16:47:00 <jle`> some functions might use only MonadReader
16:47:01 <orb_> YurasS, monad base control solves most of the issues with stacks.
16:47:02 <jle`> or MonadIO
16:47:12 <kgadek> hi. I'm getting some weird linker errs on OS X 10.9: `ld: illegal text reloc in '_s5EK_info' to '__hpc_tickboxes_lunazmloggerzm0zi1_LoggerziInternalziLoggerT_hpc' for architecture x86_64`. All works normally, but if I cut some part of the file and paste it in other (sub)module, this err happens. What should I do to debug this? What info should I gather to post a ticket?
16:47:16 <jle`> or MonadReader, MonadState, and MonadIO
16:47:31 <jle`> rarely are you going to have things that use all of them
16:47:36 <YurasS> orb_: not using stacks (based on MonadIO) does that even better :)
16:47:38 <Fuuzetsu> kgadek: this usually means you didn't list all your modules in your cabal file
16:47:56 <Fuuzetsu> jle`: you don't put it on all your functions, you put it on your functions that use everything in the blob
16:47:59 <Fuuzetsu> this isn't hard
16:48:07 <orb_> YurasS, where's the fun in that?
16:48:12 <Fuuzetsu> if some functions only use MonadReader than you only say MonadReader there
16:48:42 <YurasS> orb_: sorry, there is no
16:49:02 <kgadek> Fuuzetsu: wow, yeah, that was it. I got confused by linker errors… thanks!
16:50:40 <Fuuzetsu> yeah, the error sucks
16:51:25 <kgadek> well… yeah, hard not to say so
16:51:26 <jle`> if you have a lot of huge blobs, then it sort of defeats the purpose of making them parametric over the typeclasses in the first place
16:51:38 <jle`> a lot of the same huge blob
16:52:36 <Fuuzetsu> no it doesn't
16:53:01 <Fuuzetsu> I don't understand what your problem is, it seems you have either never used it or used it wrongly
16:53:21 <jle`> so what is the point of having your functions parametric over MonadReader, MonadIO, etc. instead of just for your concrete type?
16:53:29 <jle`> there is a point
16:53:40 <Fuuzetsu> because you might have more than one type you want to feed it?
16:53:40 <jle`> but using a bunch of the same huge blob of them negates it
16:53:48 <Fuuzetsu> what?
16:53:55 <Fuuzetsu> the blob doesn't constrain anything extra
16:54:05 <Fuuzetsu> it's the same as if you just put the things inline
16:54:19 <jhance> I remember having to deal with this along time ago and don't know if I found a solution, but I'm getting that annoying hGetContents failure on msys
16:54:35 <jhance> except setting locale to UTF-8 is doing nothing to remedy it...
16:54:39 <ReinH> johnw: ping
16:54:47 <Fuuzetsu> jhance: it'd help if you said what failure
16:54:56 <jhance> oops
16:55:01 <jhance> the invalid byte sequence
16:55:11 <Fuuzetsu> wasn't there a thread on this on cafe recently
16:55:12 <jhance> its a known bug in cabal, but it hasn't been fixed in any version yet
16:55:20 <jle`> i think i'm jumping over a lot of places and not saying something fundamental so instad of irc during my class, i'll write it up later :)
16:55:48 <Fuuzetsu> jhance: a cabal bug? which one
16:56:00 <Fuuzetsu> not the prelude file stuff because that's fixed
16:56:06 <Fuuzetsu> and it has been for months
16:56:39 <jhance> Fuuzetsu: https://github.com/haskell/cabal/issues/1883
16:56:46 <jhance> Seems like theres a commit merged in that fixes it but its not released yet
16:56:57 <jhance> But most other people have been able to solve just by setting locale on their end to UTF-8
16:57:56 <Fuuzetsu> and you haven't? Are you setting it right?
16:57:58 <YurasS> jle`: do you have a blog?
16:58:31 <jhance> Fuuzetsu: `locale` seems to indicate that its set. LANG=C.UTF-8 and LC_ALL=C.UTF-8
16:58:32 <Fuuzetsu> I think setting LC_ALL should work, check with locale -a what you have
16:58:33 <YurasS> my bad English doesn't let me write about that, so I'd read your writeuop
16:59:15 <Fuuzetsu> jhance: try en_US.UTF-8 or something
16:59:23 <Fuuzetsu> or en_us.utf8
16:59:25 <jhance> Fuuzetsu: Seems like it might be C.utf8 on this system
16:59:52 <jle`> YurasS: yes
17:00:04 <Fuuzetsu> yeah, I don't know, my locale -a shows en_US.utf8 but my locale is set to en_US.UTF-8 and it works
17:00:50 <YurasS> jle`: and you are not going to give me a link... ok :)
17:01:04 <jhance> Fuuzetsu: Yea, no difference in behavior with the utf8 instead of utf-8. Also tried en_US and C
17:01:26 <jle`> YurasS: http://blog.jle.im :P
17:01:34 <jle`> or http://jle.im i guess
17:01:39 <YurasS> thanks
17:02:16 <jle`> np :)
17:02:17 <Fuuzetsu> jhance: no idea then, the only thing I can say is ‘user error’ (which it might not be of course)
17:02:35 <jhance> Fuuzetsu: :(
17:06:35 <dgpratt_> I am looking for a "small" implementation of type inference, ideally one intended for pedagogical purposes, ideally in Haskell (of course); does anyone know where I could find something like that?
17:10:27 <fib1123> dgpratt_: Doesn't TAPL include an implementation of H-M?
17:10:51 <fib1123> dgpratt_: I don't think it is Haskell, but it might be a start.
17:11:00 <dgpratt_> does it? I happen to have a copy of TAPL around
17:11:05 <Hodapp> I need to grab a copy of TAPL...
17:11:07 <pjdelport> dgpratt_: Perhaps http://gallium.inria.fr/~fpottier/publis/fpottier-elaboration.pdf and https://www.youtube.com/watch?v=8b79M4Nmh34 might be of interest?
17:11:20 <Hodapp> but I really, really should get through SF before I start another 9 textbooks on whatever.
17:11:21 <dgpratt_> I'll take a look, thanks for the suggestion, fib1123
17:11:42 <vanila> someone posted their TAPL in haskell to google code
17:11:48 <fib1123> dgpratt_: Not in the text, it's one of the programs that is on the disk / downloadable.  B.P. reference serveral implementation taht aren't in the text.
17:12:01 <fib1123> dgpratt_: I assumed they were downloadable somewhere.
17:12:06 <dgpratt_> oh, ok
17:12:09 <Hodapp> vanila: quit following me around to every channel!
17:12:22 <dgpratt_> those look like good links, pjdelport, thanks!
17:12:55 <vanila> you are the one following me :p
17:13:03 <Hodapp> YEAH WHATEVER
17:14:37 <pjdelport> dgpratt_: This old link of mine seems to be defunct, but it's still in the Wayback Machine: http://web.archive.org/web/20080119112238/http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
17:14:56 <dgpratt_> ok, thanks
17:45:51 * hackagebot scholdoc 0.1.3 - Converts ScholarlyMarkdown documents to HTML5/LaTeX/Docx format  http://hackage.haskell.org/package/scholdoc-0.1.3 (timtylin)
17:45:53 * hackagebot hs-php-session 0.0.9.1 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.1 (elblake)
17:55:52 * hackagebot linkedhashmap 0.1.1.0 - Persistent LinkedHashMap data structure  http://hackage.haskell.org/package/linkedhashmap-0.1.1.0 (abasko)
17:57:41 <chpatrick> http://lpaste.net/6975268983125573632
17:57:47 <chpatrick> any idea if anything like this is possible?
17:57:55 <jlg123> Is there like an updated Real World Haskell? Or a list of what is out of date since that book was published
17:58:03 <chpatrick> I've been struggling with it for hours
17:58:23 <MP2E> jlg123: http://stackoverflow.com/questions/23727768/which-part-of-real-world-haskell-is-now-obsolete-or-considered-bad-practise/23733494#23733494
17:58:25 <geekosaur> jlg123, book.realworldhaskell.org should have updates in the comments/wiki
17:58:30 <chpatrick> without unsafeCoerce
17:58:42 <jlg123> MP2E: oh.. thanks. Now I feel silly
17:58:48 <jlg123> geekosaur: Oh really? Even to this day?
17:59:24 <MP2E> well comments can be made at any time, if you spot an inaccuracy you can also comment :)
17:59:38 <MP2E> people have pointed out most of the inaccuracies though
18:00:05 <geekosaur> ^ the online book is more or less a wiki
18:00:11 <hatds> is it correct/safe to use unsafeCoerce to change the type of a phantom parameter?
18:00:33 <geekosaur> no live editing of the pages but the comments are open and have been since before publication iirc
18:00:34 <chpatrick> hatds: you can use coerce for that now
18:01:32 <hatds> chpatrick: thanks
18:02:14 <jlg123> MP2E, geekosaur: I am glad that format has worked out in the long run, then! It seems pretty ideal. Now they should they gather up all the changes and publish a new print version :)
18:02:29 <MP2E> I completely agree
18:02:33 <MP2E> It would make for easier reading
18:02:43 <geekosaur> sure, just convince dons to quit posting pictures of sunsets for long enoufgh to update it :p
18:02:48 <MP2E> that was my only complaint with Real World Haskell, really, that I had to consult the comments often :P
18:02:53 <MP2E> haha
18:04:07 <jlg123> The Haskell ecosystem seems to have changed a lot since I last was really into it. It seems like the "lens" library and related ideas have really become a huge part of it
18:04:53 <geekosaur> chpatrick, as far as I can tell Data.Typeable.cast should work there? applyTypeable f x = maybe Nothing f (cast x)
18:04:59 <geekosaur> I think
18:05:08 <geekosaur> mm, not quite
18:05:15 <geekosaur> no, that
18:05:16 <geekosaur> s right
18:05:51 <geekosaur> no, wait, I had the right concern on the wrong part
18:05:53 * hackagebot hzk 2.1.0 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-2.1.0 (DiegoSouza)
18:06:04 <geekosaur> applyTypeable = maybe Nothing (Just . f) (cast x)
18:06:04 <chpatrick> it doesn't know what the return type is
18:06:22 <chpatrick> Return takes anything and cast can produce anything
18:06:32 <geekosaur> return type is always set by the caller
18:06:49 <chpatrick> in this case the caller doesn't know
18:07:12 <jp_rider> Can someone help me debug a compiler error for ghc?
18:07:17 <jp_rider> I get:
18:07:17 <chpatrick> f and x have some type and are Typeable
18:07:23 <jp_rider> $ sudo make install
18:07:23 <jp_rider> make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
18:07:33 <jp_rider> ln -s ghc-7.8.3 "/usr/local/bin/ghc"
18:07:33 <jp_rider> /usr/bin/install -c -m 755 -d "/usr/local/share/man"
18:07:33 <jp_rider> /usr/bin/install -c -m 755 -d "/usr/local/share/man/man1"
18:07:33 <jp_rider> /usr/bin/install: cannot change permissions of `/usr/local/share/man/man1': No such file or directory
18:07:33 <jp_rider> make[1]: *** [install_man] Error 1
18:07:34 <jp_rider> make: *** [install] Error 2
18:07:38 <chpatrick> and we get the result wrapped in Result
18:07:52 <chpatrick> but the caller doesn't know anything apart from that the result is also typeable
18:07:59 <chpatrick> that's the problem
18:08:02 <jp_rider> $ ls -la /usr/local/share/man/man1
18:08:02 <jp_rider> lrwxrwxrwx 1 root root 56 Oct 16 16:22 /usr/local/share/man/man1 -> /usr/local/haskell/ghc-7.8.3-x86_64/share/man/man1/ghc.1
18:08:34 <geekosaur> jp_rider, the installer assumes you have an existing proper hierarchy, I think. so you got a manpage installed where a directory should be
18:08:47 <geekosaur> because it assumed /usr/local/share/man was already set up
18:09:49 <jp_rider> I guess what's the proper way to set it up?
18:09:51 <jp_rider> $ ls -la /usr/local/share/man
18:09:51 <jp_rider> total 8
18:09:51 <jp_rider> drwxr-xr-x 2 root root 4096 Oct 16 16:22 .
18:09:51 <jp_rider> drwxr-xr-x 6 root root 4096 Oct 16 16:22 ..
18:09:51 <jp_rider> lrwxrwxrwx 1 root root   56 Oct 16 16:22 man1 -> /usr/local/haskell/ghc-7.8.3-x86_64/share/man/man1/ghc.1
18:09:59 <geekosaur> this is arguably a bug in the installer, it should probably either create the proper directory structure itself or error out early if it's not
18:10:05 <geekosaur> please don't paste more than 2 lines into the channe;
18:10:08 <geekosaur> @paste
18:10:08 <lambdabot> Haskell pastebin: http://lpaste.net/
18:10:14 <jp_rider> sorry will do
18:11:12 <geekosaur> you had /usr/local/share/man but nothing in it. it should have a directory man1 at least within it, best is to precreate man1, man2, man3, man4, man5, man6, man7, man8
18:11:16 <geekosaur> and on some platforms man9
18:11:50 <geekosaur> (basically look at /usr/share/man and create the same directories under /usr/local/share/man)
18:12:07 <jp_rider> ah ok
18:12:24 <jp_rider> would just doing the following be ok?
18:12:26 <jp_rider> ./configure --prefix=/usr
18:12:55 <geekosaur> that can get you in trouble on e.g. linux if there is a different ghc in your system's package manager that might get pulled in
18:13:13 <jp_rider> ok that make's sense
18:13:15 <geekosaur> it will either error out or overwrite your manually installed compiler, depending on a lot of things
18:13:31 <jp_rider> ill just copy the directory structure then
18:14:06 <geekosaur> (but mostly on what the package manager is)
18:14:48 <jp_rider> k im running ubuntu/apt-get
18:17:56 <jp_rider> ok i got farther
18:18:00 <jp_rider> now im getting: http://lpaste.net/112750
18:18:32 <jp_rider> should I make `/usr/local/share/doc` a dir?
18:19:20 <jp_rider> *trying now
18:19:23 <geekosaur> yes
18:20:39 <nkar> is there a way to apply a function to 'a' in 'Yesod.Form.Types.Field m a'?
18:22:01 <nkar> nevermind, I'll just fmap over an 'AForm'.
18:24:50 <jp_rider> cool awesome that worked
18:24:51 <jp_rider> thanks!
18:32:36 <pharpend> evening
18:40:57 * hackagebot sdl2 1.1.3 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.1.3 (Polarina)
18:53:14 <Total_1mmersion> Any idea why, while in a cabal sandbox, "cabal install --dependencies-only" says "The following packages are likely to be broken by the reinstalls:" ...?
18:54:16 <Total_1mmersion> If I use --force-reinstalls will it install only to the sandbox, or actually break my packages?
18:54:16 <tommd> I'm looking for a type function Id :: * -> *.  Is there a canonical one I am missing?
18:55:17 <Total_1mmersion> tommd: Data.Functor.Identity
18:55:56 <Total_1mmersion> In the transformers package
18:55:59 <gcganley> edwardk: is the meeting in Boston coming up?
18:58:46 <tommd> Total_1mmersion: Ah, yes. Thanks.  I'm suddenly realizing I'm asking the wrong question as I have my own kind T and want something of sort `T -> T` so will have to roll something myself.
19:01:27 <gcganley> does anybody know when and where the boston meetup is going to be?
19:13:14 <edwardk> gcganley: it was supposed to be yesterday, but we had to cancel due to a problem inside Akamai about getting the space reserved.
19:13:34 <edwardk> gcganley: we're talking about maybe doing an extra one next month so we won't have to bump out schedule but its not nailed down yet
19:36:15 <linman32> hi. i am trying to run cabal-meta install, but says command not found.
19:36:33 <linman32> however, cabal-meta is in .cabal-sandbox/bin/cabal-meta
19:36:46 <linman32> *cabal-meta is in .cabal-sandbox/bin
19:37:06 <kadoban> linman32: check your path?  echo $PATH
19:37:44 <linman32> what should it look like?
19:38:00 <linman32> it has this /home/bob/.cabal/bin
19:38:16 <kadoban> linman32: Well, if you want it to find that binary, it should include .cabal-sandbox/bin
19:39:41 <kadoban> linman32: I'm assuming it's not in there. The way to fix that it to change your path, wherever it's set...usually in .profile or .bashrc or .bash_profile in your home directory
19:40:03 <kadoban> (and then you need to restart, or source the file again so it takes effect)
19:41:05 <linman32> kadoban: fixed! it wasn't there (fixed w/ PATH=...). thanks
19:41:13 <kadoban> nice
20:57:47 <Total_1mmersion> Any idea why cabal install (while in a sandbox) warns about breaking user packages, yet it installs into the sandbox and leaves the user packages alone?
20:59:02 <zq> any idea why cabal test while in a sandbox warns about missing dependencies that aren't missing?
21:00:12 <trap_exit> nope
21:00:20 <trap_exit> next question :-)
21:01:13 <zq> how do i up my package to hackage with the docs and stuff
21:01:25 <zq> interrogation point
21:01:29 <merijn> zq: See help for "cabal sdist"
21:01:41 <zq> no that doesn't include docs and stuff
21:01:47 <zq> believe me i've tried
21:01:47 <merijn> zq: Docs isn't including when packing for hackage
21:01:51 <trap_exit> do you have an account with hackage?
21:02:02 <zq> yessir, i've already upped my sdist targz
21:02:05 <carter> the package builders are back up again
21:02:11 <merijn> zq: Normally the hackage server builds them, but due to performance issues building has been stopped at the moment
21:02:14 <zq> oh let me check the build log
21:02:15 <carter> nop
21:02:15 <trap_exit> merijn: are docs auto generated ?
21:02:15 <merijn> Oh, are they?
21:02:18 <carter> merijn: YOU WRONG
21:02:20 <carter> they BACK
21:02:25 <merijn> zq: Check this link
21:02:32 <carter> also some packages that never got built are getting built
21:02:33 <merijn> @google fuuzetsu fix your hackage docs
21:02:33 <lambdabot> http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
21:02:34 <lambdabot> Title: Fūzetsu's Corner - Fix your Hackage documentation
21:02:39 <carter> merijn: STOP
21:02:39 <zq> merijn: i'm getting '[]' from my package report
21:02:42 <carter> its out of DATE
21:02:46 <carter> zq: the back lock is building
21:02:48 <merijn> carter: I disagree
21:02:49 <zq> merijn: yah, read that one already
21:02:49 <carter> zq: linky?
21:02:53 <carter> merijn: nope
21:02:55 <carter> factually wrong
21:02:59 <merijn> zq: I have multiple package that don't build
21:03:01 <carter> link me to somethign that doesnt ahve tocks
21:03:02 <merijn> s/zq/carter
21:03:04 <zq> carter: https://hackage.haskell.org/package/punkt-0.1.0/reports/
21:03:07 <carter> merijn: link me and i'll make sure they get built
21:03:24 <trap_exit> the erlang guys sold some chat app for 19 billion to facebook; I wonder, if one started a company with the top 20 engineers from #haskell, how much it be worth
21:03:25 <carter> https://hackage.haskell.org/package/punkt-0.1.0/docs/NLP-Punkt-Match.html i ssee docs
21:03:40 <merijn> carter: I have stuff that doesn't build on linux at all
21:03:41 <carter> zq: the doc builder is seperate
21:03:47 <carter> merijn: theres plans
21:03:47 <zq> carter: but no build logs?
21:03:50 <inuoppai> trap_exit: Which one?
21:03:52 <carter> zq: different machine
21:03:53 <merijn> carter: Because I never got around to fixing the C bits to build on linux
21:04:03 <carter> merijn: well, once you fix them, they will work
21:04:07 <carter> or maybe they'll setup the right vms
21:04:08 <carter> idk
21:04:09 <platz> I'm not sure cloud haskell tries to compete with OTP?
21:04:14 <merijn> carter: Even if the builder works, there's no reason to NOT upload docs manually
21:04:15 <carter> platz: it wont
21:04:19 <zq> carter: does the presence of [] imply that i need to fix anything?
21:04:25 <carter> zq: not really
21:04:27 <Total_1mmersion> What's the difference between QuickCheck and QuickCheck2?
21:04:28 <trap_exit> whatsapp
21:04:32 <carter> zq: did you upload the docs?
21:04:32 <zq> cool yay
21:04:42 <kadoban> Total_1mmersion: The API
21:04:49 <carter> zq: honestly i use travis for build testing
21:04:51 <zq> carter: as in the manual way using $pkg-docs.tar.gz? no
21:05:00 <carter> zq: then the new doc builders caught up
21:05:14 <zq> cool
21:05:20 <zq> now for actually documenting stuffs
21:05:23 <trap_exit> here's what I do't get about quitk check ... if you're goign to bother specifying the properties ... why not do dependent types and prove them statically?
21:05:31 <carter> trap_exit: proofs are heard
21:05:33 <carter> hard
21:05:37 <carter> and dont give you counter examples easily
21:05:43 <carter> counter examples let you fix stuff
21:05:51 <trap_exit> ah, counter examples
21:06:01 <carter> counter examples let you discover what the right properties are
21:06:06 <carter> andor how to trigger bugs
21:07:19 <carter> i need to use quckcheck more
21:07:26 <merijn> carter: Anyway, it's good to know the builders are back :)
21:07:35 <carter> merijn: what OS? windows or mac?
21:07:58 <merijn> carter: Currently mac only
21:08:01 <merijn> Fixing the build is on my to do list
21:08:08 <trap_exit> here's a question: what would you rather use? asm with quickcheck, or haskell without quickcheck? and if you pick haskell, I'd argue that you want a stronger compile time checks
21:08:23 <carter> i'd jsut implement quickcheck again
21:08:24 <trap_exit> and if picked the latter, I'd argue that you'd be willing to go through wiht dep[endent types if they were more usable
21:08:32 <carter> nope
21:08:36 <carter> too much work
21:08:49 <merijn> I'm still catching up on fixing my work environment since my new laptop migration has triggered my manual "fix my shell issues" week ;)
21:08:57 <carter> merijn: use fish
21:09:07 <trap_exit> merijn: use eshell
21:09:17 <merijn> carter: When I say shell issues I mean, everything from my editor to command line tools
21:09:22 <merijn> Not actual shell issues
21:09:50 <merijn> Also any shell that is not installed on all machines I work on is useless, therefore bash it is
21:10:37 <carter> oh
21:10:43 <carter> i just install fish everywhere
21:10:43 <carter> :)
21:10:46 <trap_exit> merijn: do you run different distros on your machiens? I bet patching bash was fun
21:11:11 <trap_exit> I just use emacs ... and tramp mode handles all network files over ssh
21:11:18 <merijn> carter: You're assuming I have rights to install things
21:11:27 <carter> merijn: SCP
21:11:32 <carter> and add it to your path
21:11:37 <merijn> trap_exit: I don't administer 90% of the machines I work on, so I don't care
21:12:02 <merijn> Anyway, I'm satisfied with bash, so I don't see a point in changing that
21:12:05 <trap_exit> this is why everyone hsoul djust use nixos
21:12:11 <trap_exit> and configure things locally
21:14:33 <platz> I kind of like Hibberd's idea of a dependency system 'one level higher' (annex)
21:15:06 <platz> try to take advantage of the existing ecosystems
21:15:15 <platz> probably won't be easy
21:15:41 <platz> https://www.youtube.com/watch?v=JjYAnBhF2JU
21:24:53 <merijn> Any recommendations on software/tools for managing/tracking the papers I have locally and syncing them to my kindle?
21:27:09 <MP2E> I'd be interested in hearing about some advise on that too
21:27:23 <MP2E> I have a kindle 3g somewhere around here and academic papers would probably make me use it again
21:27:30 <MP2E> being able to have academic papers*
21:27:35 <chirpsalot> merijn: I have been thinking about that recently. git annex is great for tracking papers and stuff. Can probably add a kindle special remote very easily.
21:27:56 <merijn> chirpsalot: I need a good way to distinguish between read/unread too
21:28:14 <chirpsalot> merijn: git annex metadata is awesome.
21:28:42 <chirpsalot> https://git-annex.branchable.com/videos/git-annex_views_demo/
21:28:48 <merijn> Honestly, my biggest issue is being able to sync to kindle in a way that automatically tracks my read/unread status
21:28:59 <merijn> Locally managing the files is not that hard to do manually so far
21:29:35 <chirpsalot> merijn: hmmmm, yeah. Not sure there's a good way to tell a kindle you have read something, though?
21:30:07 <dmj`> no instance of bytestring for Bits?
21:30:09 <chirpsalot> merijn: or if you can remove files from a kindle. You could always use calibre, though. Maybe git annex + calibre.
21:31:22 <dmj`> how do you bit shift on bytestrings w/o data.bits
21:32:11 <trap_exit> any tehre any haskell packages for deep learning?
21:32:34 <chirpsalot> dmj`: shift n . unpack?
21:32:46 <chirpsalot> Errr. Map and stuff.
21:33:51 <dmj`> chirpsalot: no instance for Bits for String
21:33:58 <dmj`> of
21:34:11 <chirpsalot> dmj`: unpack into word8's
21:34:36 <chirpsalot> dmj`: why do you want to shift a bytestring? Do you mean the individual word8's of the bytestring?
21:34:47 <dmj`> I want to xor yea
21:34:59 <chirpsalot> Oh, crypto?
21:35:00 <merijn> zipWith?
21:35:24 <chirpsalot> dmj`: zipWith xor . unpack, no?
21:35:28 <merijn> There's BS.zipWith and Word8 has a bits instance
21:35:34 <merijn> chirpsalot: Don't even need unpack
21:35:40 <merijn> :t Data.ByteString.zipWith
21:35:42 <lambdabot> (Word8 -> Word8 -> a) -> BSC.ByteString -> BSC.ByteString -> [a]
21:36:08 <chirpsalot> merijn: oh, neat! I haven't messed with bytestrings at all really.
21:36:22 <chirpsalot> Aside from "eh, they're sort of strings and sort of bytes"
21:38:50 <merijn> They're bytes and nothing remotely string
21:39:17 <merijn> chirpsalot: The String in ByteString is a reference to the implementation and, given the confusion it causes, is widely considered a misnomer
21:39:28 <merijn> If they would be named today, it would just be Bytes
21:39:37 <chirpsalot> merijn: I come from C land. They're closer to strings than String is :P.
21:39:40 <merijn> The name is only kept to not gratuitously break all old code
21:39:44 <nitrix> I'm a bit confused, why does ByteString's length returns a Int64?
21:40:02 <cschneid> Is there a base function to join a list with a joiner?  I know I can `mconcat $ intersperse ", "`, but is that already extracted into a single func somewhere
21:40:11 <nitrix> Do they really expect a ByteString to never be that big?
21:40:47 <chirpsalot> nitrix: it's Int.
21:41:07 <chirpsalot> nitrix: chances are Int is basically size of address space.
21:41:14 <chirpsalot> nitrix: so, yes?
21:41:21 <MP2E> do you really *expect* a bytestring to be bigger than 18,446,744,073,709,551,615?
21:41:29 <MP2E> bytes presumably*
21:41:38 <MP2E> did 2^64 :P
21:42:09 <dmj`> > (1 :: Word8) `xor` (2 :: Word8)
21:42:11 <lambdabot>  3
21:42:21 <nitrix> I don't know, moore's law and stuff, but why put an arbitrary limit?
21:42:39 <chirpsalot> nitrix: it's not an arbitrary limit, though.
21:43:03 <nitrix> Why 64 then? And not 32 or 128 ?
21:43:16 <chirpsalot> Int is machine dependant, so it's probably the size of a pointer in the address space. Maybe minus a bit.
21:43:25 <nitrix> chirpsalot: It's not Int.
21:43:26 <latermuse> > let joinThem = mconcat . intersperse ", " in joinThem ["hello","world"]
21:43:28 <lambdabot>  "hello, world"
21:43:31 <chirpsalot> nitrix: docks say it's Int.
21:43:41 <merijn> nitrix: Lazy ByteString can go up to 64bit
21:44:00 <chirpsalot> nitrix: https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/src/Data-ByteString.html#length
21:44:05 <nitrix> chirpsalot: http://www.haskell.org/ghc/docs/7.6-latest/html/libraries/bytestring-0.10.0.2/Data-ByteString-Lazy.html
21:44:06 <merijn> nitrix: Before your ByteString reaches Int64, you are probably already in trouble :p
21:44:26 <chirpsalot> nitrix: oh.
21:44:43 <merijn> nitrix: I don't think you can conceive how much 64 bits of memory is....
21:44:46 <chirpsalot> nitrix: what the hell?
21:44:55 <merijn> nitrix: Remember that every extra bit *doubles* the available space
21:45:04 <nitrix> chirpsalot: See, that's even more curious, why is the lazy version different?
21:45:21 <chirpsalot> nitrix: it should probably just be Int...
21:45:30 <merijn> nitrix: Because strict versions are bounded by the max allocation size that GHC can handle and lazy is not
21:45:36 <chirpsalot> I assume whoever was writing it went "Int is 32 bits and therefore terrible."
21:45:40 <nitrix> merijn: I'm fairly aware, in my case though, it's _lazy_, so that's not necessarily all in memory. That string might as well come from a very huge file.
21:45:42 <chirpsalot> That said, maybe it really is 32 bits.
21:45:43 <merijn> chirpsalot: No
21:45:51 <merijn> chirpsalot: See my last answer
21:46:08 <merijn> nitrix: Most normal filesystem will have trouble handling files that big
21:46:28 <merijn> nitrix: Also, you can read the file in chunks by using fseek, so that still seems unlikely
21:47:18 <chirpsalot> merijn: it does seem like Integer would be more appropriate then, even though it's slower.
21:47:30 <chirpsalot> Technicality, obviously.
21:48:09 <nitrix> merijn: Your very helpful here, so I wont question too much why because most programs do things in a retarded manner, I'd have to mimick them.
21:48:30 <nitrix> You must have your reasons to beleive so.
21:49:22 <nitrix> s/because//
21:50:03 <merijn> nitrix: The biggest dataset I've personally worked with was 15TB, that still fits in 64bits *easily*
21:50:12 <merijn> nitrix: Beyond that you have other concerns anyway
21:50:26 <nitrix> merijn: The whole point of that file system is to be infinite.
21:50:29 <merijn> nitrix: i.e. needing dedicated storage clusters and distributed processing and custom handling, etc.
21:50:44 <nitrix> merijn: It has dedicated storage clusters and it's distributed.
21:50:58 <nitrix> It also used to be written in C.
21:50:59 <merijn> nitrix: The whole point according to whom? Filesystems are infinite and linux can't handle much larger files anyway
21:51:20 * hackagebot hs-php-session 0.0.9.2 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.2 (elblake)
21:51:33 <nitrix> merijn: Why would you assume linux?
21:51:56 <nitrix> Alright, I think that's enough for me.
21:51:58 <linman32> using yesod template and line 8 is throwing an error http://lpaste.net/112752
21:52:38 <merijn> nitrix: If you're not using linux/osx/windows you'll have trouble getting GHC to run anyway, so bytestring's max size is the least of your issue :)
21:53:13 <merijn> nitrix: iow, if you're in a scenario where this'll be a problem, you'll have more and bigger problems too deal with :)
21:53:17 <nitrix> merijn: You do understand that Haskell is a specification, not an implementation?
21:53:26 <nitrix> Actually, no you don't.
21:53:34 <MP2E> No need to be rude
21:54:02 <MP2E> it's a common assumption to make that one is using GHC
21:54:46 <nitrix> If there's one thing that I hate is being patronized when asking a very clear question on the semantics of the language.
21:54:57 <merijn> nitrix: If we're going to be rude: You do realise that ByteString is not even part of the spec?
21:55:09 <merijn> It's just a user library that you can patch/port/reimplement
21:55:52 <nitrix> merijn: I see. Are there better alternatives to ByteString then?
21:56:14 <merijn> I'm not making any assumptions, I'm pointing out that if you plan to 1) not use GHC or 2) not use linux/OSX/windows you have bigger problems than the maximum size of the bytestring length type
21:56:27 <merijn> nitrix: No, because there's no haskell implementations for such systems
21:56:44 <merijn> nitrix: So no one wrote a library for that
21:57:33 <orb_> The spec is not the implementation, but the spec still bows to implementation concerns here and there.
21:57:35 <nitrix> I'm not following. Any library making use of Integer should be able to just work anywhere, regardless of the platform.
21:57:43 <cschneid> Can I get a quick bit of style feedback on this function?  https://gist.github.com/96198b636c8d5f516f3e -- would you inline / expand anything else out? make the encode/decode junk clearer?
21:58:22 <merijn> nitrix: Sure, but in reality people care about performance and Int64 is faster and that is a real and practical concern on platforms that people are actually using ByteString on, as opposed to some non-existent future platform
21:58:41 <merijn> nitrix: Should such a platform appear we can always release a new ByteString version with a different type and call it a day
21:59:33 <Jeanette23>  High Quality photos and videos http://j.mp/Rh9YfS
21:59:55 <nitrix> ops?
21:59:57 <MP2E> never fails :v
22:00:04 <MP2E> bots and them videos
22:02:11 <nshepperd> hmm, maximum value of Int64 could conceivably be a problem if you were using ByteStrings to stream something over a 10Gb link and left it running for 300 years
22:02:32 <nshepperd> and wanted to measure the total amount transferred for some reason
22:18:11 <AshyIsMe> has anyone here used osxmonad?
22:18:23 <AshyIsMe> im having trouble compiling it following the Readme.md
22:18:42 <AshyIsMe> cabal install X11 is failing at the linking stage with ld: library not found for -lXss
22:18:58 <AshyIsMe> even though libXss.dylib exists in: /System/Library/CoreServices
22:20:45 <Axman6> angerman: have you installed X11? (Xquartz)
22:21:04 <angerman> Axman6, pardon me?
22:21:15 <AshyIsMe> Axman6: yeah
22:21:23 <Axman6> uh, AshyIsMe, not angerman
22:21:45 <AshyIsMe> maybe i need a restart or something for it to refresh the library paths?
22:21:49 <AshyIsMe> (that'd be horrible if so)
22:22:24 <Axman6> but you have actually installed Xquartz?
22:22:45 <AshyIsMe> i just installed this one: http://xquartz.macosforge.org/landing/
22:22:48 <AshyIsMe> that the one?
22:23:21 <dmj`> how do I go about converting from any base to any base
22:23:30 <dmj`> baseX to baseY
22:24:17 <AshyIsMe> Axman6: http://i.imgur.com/wkqONNX.gif
22:24:23 <Axman6> I assume you're talking about text? computers only do binary
22:24:38 <Axman6> AshyIsMe: heh. no idea then
22:24:42 <ludamad> Could be list of numbers
22:25:07 <Axman6> @hoolge atBase
22:25:08 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
22:25:23 <merijn> AshyIsMe: Check where the X lib is on the file system and pass cabal the --extra-lib-dirs with that path?
22:26:43 <AshyIsMe> can i pass that to cabal install?
22:26:48 <AshyIsMe> says it's an unrecognized option
22:27:27 <AshyIsMe> oh , typo
22:31:24 * hackagebot scholdoc-citeproc 0.6 - Scholdoc fork of pandoc-citeproc  http://hackage.haskell.org/package/scholdoc-citeproc-0.6 (timtylin)
22:37:39 <merijn> chirpsalot: I was looking into git-annex, but that doesn't seem a good solution, as it would involve me having to use git ;)
22:38:06 <chirpsalot> merijn: haha, darcs user? :P
22:38:32 <merijn> chirpsalot: Mercurial :)
22:38:42 <chirpsalot> merijn: with the assistant you don't even have to touch it.
22:38:58 <merijn> hg-git is a wonderful plugin that has saved me from having to learn git at work and on github ;)
22:39:14 <chirpsalot> merijn: eh. hg is pretty much identical to git for the common stuff.
22:39:54 <chirpsalot> I used to use hg, but I gave up on it. hg is just a tad too slow. Enough that it annoyed me.
22:40:18 <merijn> chirpsalot: Except the UI is rather userfriendlier, my mental model understands git pretty well, I just don't understand the git CLI :)
22:40:51 <chirpsalot> merijn: it's actually about the same as hg. hg just has much better help messages.
22:43:50 <dresuer> Hi all
22:44:12 <chirpsalot> dresuer: hola.
22:44:35 <dresuer> Alguien puede decirme que cosas se pueden llegar a programar a traves de haskell o mas general
22:44:40 <dresuer> a traves de la programacion funcional
22:44:51 <dresuer> tiene la misma potencia que lenguajes de mas bajo nivel como C ?
22:44:55 <dresuer> u otros ?
22:45:02 <dresuer> chirpsalot: (Y)
22:45:17 <chirpsalot> Is that Portuguese?
22:45:26 <dresuer> spanish
22:45:45 <chirpsalot> Wow. I don't even recognize it. Usually I can read Spanish decently.
22:46:33 <chirpsalot> Well, so much for those three years of Spanish :P.
22:46:36 <dresuer> chirpsalot: Qué tipos de programas se pueden programar a través de haskell ?
22:47:11 <dresuer> chirpsalot: Do you recognize that ?
22:47:37 <chirpsalot> dresuer: haha, sorry, no. I'm pretty tired, but maybe it has just been too long.
22:48:40 <dresuer> chirpsalot: What kings of program can be programmed by funtional programming comparate to imperative programming ?
22:48:47 <chirpsalot> Or perhaps learning ASL overwrote my Spanish or something.
22:49:03 <chirpsalot> dresuer: they're equivalent by Turing completeness!
22:49:29 <chirpsalot> dresuer: the difference is elegance and fluency.
22:50:50 <chirpsalot> Any algorithm can technically be implemented in either C or Haskell. But Haskell programs tend to be much more brief, and safe. Haskell is also most excellent at abstraction!
22:51:26 * hackagebot auto-update 0.1.2 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.2 (MichaelSnoyman)
22:51:28 * hackagebot http-client 0.4.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.1 (MichaelSnoyman)
22:51:35 <chirpsalot> dresuer: new and looking into Haskell? Know any other languages?
22:51:44 <dresuer> chirpsalot: What is the purpose to use it ?
22:51:46 <chirpsalot> Aside from Spanish, apparently :P
22:52:00 <dresuer> chirpsalot: I know C
22:52:13 <dresuer> mid-level language
22:52:26 <chirpsalot> dresuer: there are lots of reasons to use Haskell!
22:52:44 <chirpsalot> One of the biggest ones is that the type system is just AWESOME. Catches a lot of errors.
22:52:54 <ThreeOfEight> dresuer: Programas en Haskell son a menudo más concisas que C.
22:53:27 <chirpsalot> I think there's a #haskell-es too.
22:53:47 <ThreeOfEight> Yes, probably shouldn't spam this channel with Spanish
22:53:49 <AshyIsMe> merijn: cool that was it, thanks
22:53:54 <dresuer> ThreeOfEight: Mi pregunta basicamente es , Haskell tiene la misma potencia que C ? O sea, que cosas pueden ser programas en Haskell que no puedan serlo en C
22:54:14 <dresuer> y vise versa
22:54:14 <dfeuer> I wouldn't call it spamming, but it may not be the most effective way.
22:54:17 <ThreeOfEight> dresuer: Sí. Téoriticamente.
22:54:25 <ThreeOfEight> *Téoricamente
22:56:00 <ThreeOfEight> Es problemático si tu quieres crear un sistema operativo con Haskell.
22:56:11 <chirpsalot> ThreeOfEight: yeah, I didn't mean it was a bad thing :) -- just, y'know, if you wanted to find Spanish speaking folk that's probably where to go!
22:56:21 <ThreeOfEight> chirpsalot: no, no, I know what you mean
22:56:39 <dresuer> ThreeOfEight: claro, te entiendo
22:56:42 <chirpsalot> dresuer: http://tryhaskell.org/ :)
22:56:57 <ThreeOfEight> It would be inefficient to have a channel with lots of different people speaking lots of different languages and no one understanding each other
22:57:37 <chirpsalot> Haha. #polyglotism :)
22:57:45 <dresuer> ThreeOfEight: Bueno, a eso iba mi pregunta. A qué tipos de programas esta orientado mas bien haskell ?
22:58:21 <ThreeOfEight> dresuer: Perdona mi mal español, por favor.
22:58:31 <dresuer> chirpsalot: OK, I programmed the factorial number typical
22:58:44 <ThreeOfEight> Creo que Haskell es mal por programas numéricas
22:59:00 <dresuer> ThreeOfEight: algún ejemplo ?
22:59:10 <chirpsalot> dresuer: you wrote factorial in Haskell?
22:59:24 <dresuer> fac 0 = 1
22:59:28 <dresuer> fac n = n * (n-1)
22:59:36 <chirpsalot> Yeah :)
22:59:38 <dresuer> main = print ( fac 5 )
23:00:10 <ThreeOfEight> Lenguajes como C son mejores si tu quieres hacer muchas computaciónes científicas
23:00:41 <dresuer> ThreeOfEight: claro, lo que he visto es que en Haskell no tienes que lidiar con problemas de bajo nivel
23:01:00 <chirpsalot> dresuer: Haskell can be much more concise than C. For instance if you want to do something like add up all of the even numbers in a list, you can imagine that being a decent chunk of C. In Haskell it's just "sum . filter even"
23:01:00 <ThreeOfEight> O cosas “low-level”
23:03:58 <dresuer> chirpsalot: I understand you. ThreeOfEight thanks
23:04:07 <ThreeOfEight> dresuer: Sí. Creo que Haskell es especialmente bueno por problemas que simplemente tienen un input y un output
23:04:09 <dresuer> I kill keep reading some of haskell
23:04:25 <dresuer> ThreeOfEight: puedes ser un poco mas especifico ?
23:05:11 <dresuer> ThreeOfEight: Can you be a little more specific ?
23:05:32 <ThreeOfEight> Es más complicado sí tienes que modificar estado o interactuar con el mundo exterior
23:05:47 <ThreeOfEight> Haskell is good if you just want to compute something from initial data
23:05:52 <ThreeOfEight> and you never have to talk to the outside world
23:06:18 <ThreeOfEight> but Haskell can also handle that, it just takes more practice
23:06:36 <dresuer> ThreeOfEight: With "outside world" do you mean low-level ?
23:07:00 <ThreeOfEight> Se puede hacerlo y Haskell tambien, pero se requiere más práctica.
23:07:05 <ThreeOfEight> Not necessarily
23:07:25 <ThreeOfEight> Just anything where you have to interact with something. Can be the user, can be network, …
23:07:44 <ThreeOfEight> Haskell is inherently „non-temporal”. You just have expressions and these expressions get evaluated.
23:08:02 <ThreeOfEight> it doesn't matter if and when they get evaluated and in what order
23:08:23 <ThreeOfEight> but if you interact with the outside world, you suddenly have to worry about this kind of thing
23:08:35 <ThreeOfEight> in Haskell, this is usually done in a monad
23:09:03 <ThreeOfEight> Imperative languages make modifying state and this temporal nature of the program implicit
23:09:53 <ThreeOfEight> That tends to introduce a lot of sources of bugs. Haskell forces you to actually state side effects and this “temporal nature” explicitly.
23:10:31 <ThreeOfEight> So using side effects in Haskell requires a lot more ceremony, and if you're used to C, you might initially find that very annoying.
23:11:40 <dresuer> ThreeOfEight: :D Gracias por dejarmelo todo más en claro.
23:13:10 <ThreeOfEight> (Lo siento, pero no quiero decirlo en español. No lo hablo bien más; he olvidado todas las palabras.)
23:54:30 <kalail> ThreeOfEight: very nice explanation
23:56:33 * hackagebot punkt 0.1.1 - Multilingual unsupervised sentence tokenization with Punkt.  http://hackage.haskell.org/package/punkt-0.1.1 (bryant)
23:56:56 <Elena23>  There is no such thing as Free Porn http://bit.ly/1y2SGSo
23:57:52 * hackagebot http-client 0.4.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.1 (MichaelSnoyman)
23:57:52 * hackagebot punkt 0.1.1 - Multilingual unsupervised sentence tokenization with Punkt.  http://hackage.haskell.org/package/punkt-0.1.1 (bryant)
23:57:59 --- mode: ChanServ set +o mauke
23:58:52 <dfeuer> "requested"?
23:59:59 --- mode: mauke set -o mauke
