00:01:53 * hackagebot helics 0.1.0 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.1.0 (HirotomoMoriwaki)
00:02:41 * hackagebot lagrangian 0.6.0.1 - Solve Lagrange multiplier problems  http://hackage.haskell.org/package/lagrangian-0.6.0.1 (JonathanFischoff)
00:02:41 * hackagebot helics 0.1.0 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.1.0 (HirotomoMoriwaki)
00:03:14 <tranma> could someone help me with monad-control?
00:03:17 <tranma> http://lpaste.net/112361
00:06:33 <tranma> I thought that should work since I only have a wrapper around a transformer for which there is already an identical instance
00:22:16 <Saizan> tranma: do they have UndecidableInstances on too?
00:22:37 * hackagebot maxent 0.7 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.7 (JonathanFischoff)
00:22:58 <tranma> Saizan: wait, yes, they do, I should have seen that
00:23:14 <tranma> I guess it is actually decidable
00:31:05 <Saizan> yah, it should be fine, at worst you get ghc to loop :)
01:04:28 <trap_exit> given that I lack foresight and will need to change my data types -- what is the optimal way to serialize out data structures out do sql / disk ?
01:04:39 <trap_exit> (I'm writing a web app, I need to serialize data to disk / database)
01:04:51 <trap_exit> but I also do not know how the final product looks so I'll be changing data types frequently
01:28:52 <Yrarr> Hey, I'd like to know, is there any way to cast ForeignPtr to Ptr, dropping the garbage collection thing ?
01:31:24 <simpson> Yrarr: What's the goal?
01:32:40 * hackagebot Zora 1.1.16 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.16 (bgwines)
01:32:41 <Yrarr> simpson: I'm doing something that interfaces with C (not my work, and can't change that). I need to store a pointer in a record, which will be used later in C part.  I cannot do that with foreign ptr.
01:34:20 <simpson> Yrarr: Does the pointer need to outlive its finalizer?
01:35:31 <simpson> :t withForeignPtr
01:35:33 <lambdabot> Not in scope: ‚ÄòwithForeignPtr‚Äô
01:35:49 <simpson> :t Foreign.ForeignPtr.withForeignPtr
01:35:50 <lambdabot> GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
01:36:06 <Yrarr> simpson: That kind of depends on the design of the system. If it needs, the part which stores Haskell data and C data would need to be merged. If not, I can keep things seperate (and make the code nicer).
01:36:50 <simpson> Yrarr: Well, you could always create the ForeignPtr deliberately without a finalizer (or, more precisely, with a do-nothing finalizer).
01:37:59 <Yrarr> simpson: Ok, thanks :) I'll look up now how to define my own finalizers.
01:39:40 <simpson> Anyway, yeah. If you use unsafeForeignPtrToPtr, you will "drop" the GC, in that the ForeignPtr will be reaped quite quickly. If the reaping does nothing then maybe that is what you want.
01:47:41 * hackagebot Zora 1.1.17 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.17 (bgwines)
01:51:00 <Yrarr> simpson: And is there any way to remove existing finalizers ? I'm using Repa.Repr.Foreign, and I'm not 100% sure how they do the initalization of ForeignPtr
01:51:21 <simpson> Yrarr: I'm not sure, TBH!
01:55:47 <jle`> i tried to locally shadow (,)
01:55:49 <jle`> it did not work
01:55:51 <jle`> :(
02:04:43 <nshepperd> you can't shadow data constructors, I think, because they get parsed as a pattern match
02:06:13 <nshepperd> seems like (,) is a special case anyway, since it does go away when I 'import Prelude ()'
02:06:18 <nshepperd> doesn't
02:06:43 <tdammers> tuples are a dark corner in Haskell's syntax I guess
02:06:57 <osfameron> like lists
02:07:21 <ClaudiusMaximus> Yrarr: probably best to just use withForeignPtr to keep the data alive, otherwise you might crash during GC when the finalizer frees the memory - if you managed to remove the finalizer somehow you'd have a memory leak
02:07:22 <tdammers> at least tuple syntax in Haskell isn't totally broken like in Python
02:07:42 <zwer> tdammers what makes it broken in python?
02:08:18 <tdammers> zwer: the fact that one-tuples exist, and that they require a trailing comma
02:08:32 <tdammers> (1, 2) # tuple
02:08:36 <tdammers> (1) # scalar
02:08:40 <tdammers> (1,) # tuple
02:08:52 <nshepperd> that's not really broken, so much as a useless non-feature
02:08:56 <Yrarr> ClaudiusMaximus: And what if I'd remove the data under pointer later, manually?
02:09:31 <tdammers> nshepperd: I consider it broken in that making the parentheses around tuples optional makes for really stupid edge cases and gotchas
02:09:56 <nshepperd> they're optional?
02:10:01 <tdammers> sometimes, yes
02:10:07 <tdammers> foo, bar, baz = 1, 2, 3
02:10:26 <nshepperd> oh yeah, the assignment thing
02:10:37 <nshepperd> destructuring
02:11:00 <kuribas> Is there an elegant way to do this: data A = A,  data B = B | BA A, data C = C | CB B
02:11:17 <tdammers> the syntax may be intuitive for trivial cases, but I find it really hard to form a good rigid intuition
02:11:32 <tdammers> shows how Python was conceived as a teaching language
02:12:42 * hackagebot tasty-quickcheck 0.8.2 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.2 (RomanCheplyaka)
02:17:43 * hackagebot tasty 0.10.0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.0.2 (RomanCheplyaka)
02:17:45 * hackagebot tasty-hunit 0.9.0.1 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.9.0.1 (RomanCheplyaka)
02:17:47 * hackagebot tasty-smallcheck 0.8.0.1 - SmallCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-smallcheck-0.8.0.1 (RomanCheplyaka)
02:22:27 <Twey> kuribas: B = Maybe A, C = Maybe B
02:22:44 * hackagebot random-effin 0.1.1.0 - A simple random generator library for effin  http://hackage.haskell.org/package/random-effin-0.1.1.0 (HiromiIshii)
02:22:48 <Twey> But the names might be worth defining them anyway
02:24:56 <kuribas> Twey: No, I want B to be either B or A.
02:25:34 <kuribas> better example: data A = A Int, data B = B [A] | BA A, data C = C String | CB B
02:25:50 <kuribas> Twey: So B is a superset of A, and C is a superset of B
02:26:29 <kuribas> I could do C = A Int | B [C] | C String, but it is more general.
02:26:48 <kuribas> Especially B [C] != B [A]
02:30:32 <Twey> kuribas: The effect of ‚ÄòMaybe t‚Äô is to add one more element called ‚ÄòNothing‚Äô to t.  So your B has two constructors, B | BA A ‚Äî but you could as well call B ‚ÄòNothing‚Äô and BA ‚ÄòJust‚Äô, and then B = Maybe A.
02:30:51 <Twey> Only the names are different (and maybe the instances).
02:32:09 <kuribas> Twey: but that doesn't work with my second example?
02:32:21 <Twey> kuribas: Why not?
02:32:40 <pavonia> You can use Either for that
02:32:58 <kuribas> pavonia: I'd need an Either3
02:33:03 <Twey> kuribas: Your C has two constructors, C | CB B ‚Äî but you could as well call C ‚ÄòNothing‚Äô and CB ‚ÄòJust‚Äô, and then C = Maybe B.
02:33:07 <Twey> Unless I'm looking at the wrong example?
02:33:21 <kuribas> Twey: yes
02:33:43 <Axiomatic>  
02:33:52 <kuribas> > <kuribas> better example: data A = A Int, data B = B [A] | BA A, data C = C String | CB B
02:33:52 <kuribas>  
02:33:53 <lambdabot>  <hint>:1:1: parse error on input ‚Äò<‚Äô
02:33:55 <Twey> Either is commutative and associative (‚Ä¶ up to isomorphism).  Either a (Either b c) ‚âà Either (Either a b) c, &c.
02:33:57 <Twey> Ah, right.
02:33:58 <jle`> type A = (); type B = Maybe A; type C = Maybe B
02:34:14 <jle`> am i reading this wrong too
02:34:40 <Twey> Yep, there A = Int, B = Either [A] A, C = Either String B
02:34:55 <kuribas> Twey: Right, that should work.
02:34:56 <jle`> ah
02:34:59 <kuribas> Twey: thanks
02:35:38 <Twey> kuribas: But it's not necessarily more elegant to use primitive sum types to construct all your data types.  You lose out on the ability to give them informative names and some convenient syntax.
02:36:27 <Twey> And unless you newtype them, you also lose the ability to statically distinguish between a Metre and a Second, though they might both be isomorphic to Int.
02:37:23 <Twey> kuribas: Interestingly, Maybe is also isomorphic to Either ()
02:37:30 <kuribas> So I have data A = A Int, data B = B String, data C = C Double then data Any = AnA A | AB B | OraC C
02:37:36 <Twey> Nothing = Left (), Just = Right
02:39:27 <Twey> Sometimes we like to write types as the number of elements in them, and then Maybe A is 1 + |A|, () is 1, and Either A B is |A| + |B| ‚Äî so Either () A is 1 + |A|, just like Maybe A
02:41:31 <Twey> kuribas: Type sums are associative and commutative just like integer sums (up to isomorphism), so you can write that equivalently as Either A (Either B C), Either (Either A B) C, Either (Either C A) B, &c. without recourse to an n-ary sum type
02:42:14 <spacekitteh> is there a way to make a monoid into a category?
02:43:19 <Twey> spacekitteh: A monoid is a category with only one object, the type, where the morphisms are the values of the type and loop back onto the object
02:43:39 <kuribas> Twey: But a custom type is better than stacked Either's right?
02:43:41 <dibblego> spacekitteh: newtype Mon m a b = Mon m; instance Monoid m => Category (Mon m)
02:43:45 <Twey> kuribas: Generally, yes.
02:43:52 <spacekitteh> dibblego: yeah i'm hoping to avoid that
02:44:16 <spacekitteh> Twey: yeah i know, but it seems that the Category class requires it to deal with arbitrary haskell types
02:44:24 <dibblego> spacekitteh: edwardk's talk on Hask has some ideas on that matter, but I don't know it well enough to give a concrete answer.
02:44:54 <spacekitteh> yeah. i'm thinking i'm going to have to create a new category class
02:45:11 <Twey> kuribas: There are some cases where it's useful.  For example, generics libraries like syb or GHC.Generics tend to try to represent data types as sums and products (tuples)
02:46:17 <jle`> i wonder of polykinds would allow you to do that
02:46:32 <jle`> :k C.Category
02:46:33 <lambdabot> (k -> k -> *) -> Constraint
02:46:41 <jle`> hm
02:46:43 <Twey> Nice
02:46:54 <spacekitteh> only on new data types, not existing ones, jle`
02:47:16 <jle`> yeah
02:47:29 <jle`> i guess unless haskell implicitly made every (a) into an (() -> a)
02:47:42 <spacekitteh> i'm' working on a ghc extension so i'm hoping to keep as much backward compatability as possible
02:47:47 <jle`> then you could consider Monoid as () -> () -> Constraint
02:47:55 <jle`> wait
02:48:03 <jle`> i mean, you could consider any Monoid m as if it were m () ()
02:48:08 <spacekitteh> true
02:48:09 <jle`> but that's kind of silly
02:48:22 <jle`> is there a type-level ()/
02:48:42 <spacekitteh> jle`: there is using data kinds
02:48:44 <Twey> Only with DataKinds
02:48:46 <jle`> as in, a Kind thathas only one inhabitant
02:48:54 <Twey> Hm
02:49:10 <Twey> There's Any.  But I think that has magic properties.
02:50:19 <jle`> kuribas: remember that ADT's are Algebraic in the sense that they are just made out of nested tuples and Either
02:50:33 <jle`> so you could literally make any `data` declaration obsolute with the right tuples and Eithers
02:50:41 <Twey> And recursion relations thereon
02:50:45 <jle`> you can think of constructors as just syntactic sugar ;)
02:51:02 <jle`> Foo a | Bar b c is just Either a (b, c)
02:51:30 <jle`> ah yeah
02:51:31 <spacekitteh> i think i'm going to make a SmallCategory with a Constraint parameter
02:51:46 <jle`> i wrote about recursion, but took it out, and then realized that you need to mention it to make this make sense
02:52:14 <spacekitteh> and then make Category an instance with a nullary constranit
02:53:36 <Twey> jle`: Otherwise [] is pretty hard to define :√æ
02:54:10 <jle`> type List a = Either () (a, List a)
02:54:12 <jle`> ;)
02:54:27 <Twey> Haskell says no :√æ
02:54:30 <jle`> ;_;
02:54:48 <jle`> @let type List a = Either () (a, List a)
02:54:50 <lambdabot>  .L.hs:160:1:
02:54:50 <lambdabot>      Cycle in type synonym declarations:
02:54:50 <lambdabot>        .L.hs:160:1-35: type List a = Either () (a, List a)
02:54:53 <jle`> darn
02:54:58 <jle`> well
02:55:00 <n4x> data
02:55:10 <Twey> @let newtype List a = List (Either () (a, List a))
02:55:12 <n4x> or newtype!
02:55:12 <lambdabot>  Defined.
02:55:14 <jle`> would type families let me do this
02:55:21 <Twey> jle`: No
02:55:43 <Twey> You're not allowed infinite terms at the type level
02:55:51 <spacekitteh> well that's shit
02:55:52 <Twey> It makes type-checking hard
02:55:55 <jle`> is it because all type synonyms are resolved at compile time
02:56:05 <Twey> Yep
02:56:19 <jle`> so...ithe resolution is non-terminating
02:56:21 <jle`> darn
02:57:15 <n4x> @let lcons x (List xs) = List (Right x xs)
02:57:16 <lambdabot>  .L.hs:164:27:
02:57:16 <lambdabot>      Couldn't match expected type ‚ÄòEither () (t, List t)
02:57:16 <lambdabot>                                    -> Either () (a, List a)‚Äô
02:57:16 <lambdabot>                  with actual type ‚ÄòEither a0 b‚Äô
02:57:16 <lambdabot>      Relevant bindings include
02:57:22 <Twey> It's not impossible to do.  Some type theories have an operator ¬µ that lets you define types like ¬µl. 1 + a √ó l
02:57:30 <Twey> But Haskell's doesn't
02:57:31 <jle`> tupols
02:57:43 <spacekitteh> why not, twey?
02:57:44 <n4x> heh
02:58:08 <jle`> hm.
02:58:27 <RchrdB> Twey: I've seen it claimed on stackoverflow that infinite terms at type level are disallowed because disallowing them catches lots of bugs (like accidental infinite loops) rather than because it makes type-checking too hard.
02:58:42 <jle`> this reminds me of the apparent inconsistently between church encoding of finite sums and products and church encoding of list
02:58:57 <kuribas> jle`: hm, right
02:59:02 <Twey> spacekitteh: It makes type-checking hard ‚Äî with equirecursive types you essentially have to do the expand/contract steps in the type checker, so you have to recognize when some type could be written as an expanded step of a ¬µ that's in scope
02:59:19 <n4x> @let lcons x xs = List (Right (x,xs))
02:59:21 <lambdabot>  Defined.
02:59:25 <RchrdB> jle`: iirc, you can define: newtype Fix f = Fix (f (Fix f)); type List a = Fix (Either a)
02:59:39 <jle`> @let type CMaybe a = forall b. (b -> (a -> b) -> b)
02:59:40 <lambdabot>  Defined.
03:00:03 <jle`> @let type CEither a b = forall c. ((a -> c) -> (b -> c) -> c)
03:00:06 <lambdabot>  Defined.
03:00:15 <n4x> > foldr lcons (List (Left ())) [1,2,3]
03:00:17 <lambdabot>  No instance for (GHC.Show.Show (L.List a0))
03:00:17 <lambdabot>    arising from a use of ‚ÄòM16839124577816396582512.show_M16839124577816396582...
03:00:17 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
03:00:17 <lambdabot>  Note: there are several potential instances:
03:00:17 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
03:00:26 <n4x> whatever
03:00:55 <Twey> RchrdB: I don't think I've seen that one.  But papers dealing with equirecursive types are I guess not usually that concerned with programmers' fallibilities :√æ
03:01:02 <jle`> hm i forgot how to church encode products
03:01:04 <jle`> this is embarassing
03:01:23 <RchrdB> jle`: church encoding of (1, 2) is (\f -> f 1 2)
03:01:31 <Twey> jle`: (a ‚Üí b ‚Üí c) ‚Üí c
03:01:39 <jle`> ah yes
03:01:41 <dibblego> Pair a b = forall x. a -> b -> x
03:02:05 <kuribas> I always wonder why so many programmer hate math...
03:02:20 <kuribas> It seems so much of programming is actually math.
03:02:22 <RchrdB> Twey: hm. I saw it given as a justification for disallowing equirecursive *function* types in particular.
03:02:55 <RchrdB> I may have misremembered the comment though, and it was just one sentence in a comment somewhere that I would not be able to find again.a
03:02:58 <jle`> \ghci
03:03:01 <jle`> oops
03:03:09 <kuribas> Or perhaps it's as Donald Knuth says "math anxiety".
03:03:25 <Twey> No, it seems reasonable.  But I'd be surprised if that was the original motivation for using isorecursion in Haskell.  I think the power to weight ratio of isorecursion is higher.
03:12:46 * hackagebot rtorrent-rpc 0.2.1.0 - A library for communicating with RTorrent over its XML-RPC interface.  http://hackage.haskell.org/package/rtorrent-rpc-0.2.1.0 (KaiLindholm)
03:25:06 <kuribas> Is there an type extension to restrict constructors?  For example EmptyList = EMptyList l, where can be only [].
03:27:16 <Twey> kuribas: That one's just EmptyList = ()
03:27:37 <Twey> Or EmptyList = EmptyList if you like
03:27:47 * hackagebot BNFC 2.7.1 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.7.1 (GregoireDetrez)
03:27:57 <Twey> More interesting is data NonEmptyList a = NonEmptyList a [a]
03:28:03 <kuribas> yeah
03:28:10 <Twey> But these don't require extensions
03:54:19 <jle`> so the ComonadApply laws seem to be stated in terms of Comonad methods
03:54:38 <jle`> with claims that this is analogous to Applicative laws stated in terms of Monad methods
03:54:49 <jle`> ...is the latter found written down anywhere?
03:55:35 <Twey> jle`: pure = return, (<*>) = ap
03:55:44 <jle`> @src ap
03:55:45 <lambdabot> ap = liftM2 id
03:55:57 <jle`> hm
03:56:02 <Twey> @src liftM2
03:56:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:56:06 <jle`> i can't really see the analogy
03:56:12 <jle`> extract (p <@> q) = extract p (extract q)
03:56:18 <jle`> duplicate (p <@> q) = (<@>) <$> duplicate p <@> duplicate q
03:56:34 <jle`> how does (<*>) = ap form an analogy with either of those?
03:57:13 <Twey> Just in the sense that it forms laws restricting the behaviour of one class in terms of the other, I suppose
03:57:31 <Twey> Oh!
03:57:35 <Twey> Applicative *laws*.  Sorry.
03:57:38 <jle`> i was hoping there'd be some cute dual-y flippy translation
03:58:09 <Twey> But no, unfortunately I don't think there's a dualized analogue to Applicative.
03:58:13 <jle`> like how the comonad laws and the monad laws are all flippy cute and stuff
03:58:43 <jle`> well the monad laws and the comonad laws are just duals right
03:59:08 <Twey> Right, monads and comonads are duals
03:59:08 <jle`> join . fmap join = join . join
03:59:21 <Twey> But I don't think Applicative and ComonadApply are
03:59:28 <vanila> class (Comonad w, FunctorApply w) => ComonadApply w
03:59:36 <vanila> it doesnt' have any methods!
03:59:37 <jle`> fmap duplicate . duplicate = duplicate . duplicate
03:59:40 <jle`> super cute, right
03:59:47 <jle`> yeah, but
03:59:49 <Twey> vanila: Doesn't mean it can't have laws
03:59:59 <vanila> http://hackage.haskell.org/package/functor-apply-0.7.4.1/docs/Data-Functor-Apply.html#t:FunctorApply
04:00:03 <vanila> so these are the methods
04:00:12 <jle`> i feel like stating the ComonadApply laws in terms of Comonad should be dually to stating the Applicative laws in terms of Monad
04:00:19 <jle`> considering the spirt of comonadapply
04:00:27 <jle`> dually as in dual-y
04:00:30 <Twey> jle`: That would only make sense if ComonadApply were dual to Applicative, which I don't believe is the case
04:00:56 <jle`> they aren't duals, but they are apparently analogues
04:01:18 <vanila> FunctorApply doesn't have 'pure'
04:01:21 <jle`> ComonadApply, according to the docs, "respects extract and duplicate in the same way that Applicative respects return and join"
04:01:34 <vanila> they BOTH have (<.>) :: f (a -> b) -> f a -> f bSource
04:01:38 <jle`> so...in what way does Applicative respect return and join? :|
04:01:59 <jle`> and in what way does ComonadApply's respect of extract/duplicate create an analogue?
04:02:16 <jle`> analogy
04:02:48 <jle`> extract (p <@> q) = extract p (extract q) -- this should be the simplest one
04:02:51 * jle` stares for a bit
04:04:04 <vanila> do you have a link for th applicative rules in terms of monad?
04:04:13 <jle`> no, that's what i'm trying to figure out, heh
04:04:15 <vanila> https://hackage.haskell.org/package/base-4.3.1.0/docs/Control-Applicative.html doesn't have that
04:04:16 <vanila> oh
04:04:17 <jle`> my initial question was for that link
04:04:26 <jle`> nut now i am trying to reason it out myself :|
04:04:37 <vanila> ok I got confused by the co- stuff
04:04:51 <jle`> return p <*> return q = return (p q)
04:04:55 <jle`> hm
04:05:00 <vanila>      pure id <*> v = v
04:05:01 <jle`> i wonder in what way those two are analogous
04:05:10 <vanila> hey wait a sec
04:05:21 <vanila> can't you just implement pure and <*> and everything in terms of monad?
04:05:28 <sivteck> :t liftM2 id
04:05:28 <vanila> then expand those definitions out
04:05:29 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
04:06:12 <jle`> hm
04:06:39 <vanila> then you'll get a bunch of rules like:  return id =<< v = v   which are already implied by the monad laws
04:07:34 <jle`> yeah, but how to twist them into a form where the anlogy is clear?
04:08:05 <vanila> If f is also a Monad, define pure = return and (<*>) = ap.  <-- oh so you just need to finda formulation of the monad laws that talk about  return/ap  I think?
04:08:20 <jle`> is extract (p <@> q) = extract p (extract q) supposed to be the analogous law to return p <*> return q = return (p q)
04:08:43 <vanila> I don't think there's anything that indicates an analogy between the two?
04:09:09 <jle`> well then...what is the analogous Applicative law related to return/pure?
04:09:18 <jle`> that Control.Comonad claims there is
04:09:53 <vanila> "These laws are directly analogous to the laws for monads" <- this?
04:10:11 <vanila> http://hackage.haskell.org/package/comonad-0.7.0/docs/Control-Comonad.html#t:Comonad
04:10:17 <jle`> no, ComonadApply
04:10:23 <jle`> ComonadApply is to Comonad like Applicative is to Monad.
04:10:36 <vanila> I don't think that's true, is that stated somewhere?
04:10:43 <jle`> oh, that's a quote from the docs
04:10:55 <jle`> http://hackage.haskell.org/package/comonad-4.2.2/docs/Control-Comonad.html#t:ComonadApply
04:11:16 <vanila> I see!
04:11:22 <jle`> and then i heard edwardk in a talk say that ComonadApply respects extract and duplicate in an analogous way to how Applicative respects return and join
04:12:11 <jle`> so i'm guessing that that means that each of the laws in terms of extract and duplicate for ComonadApply has an analogous Applicative law in terms of retrun and join
04:12:53 <jle`> hm
04:13:05 * jle` shrugs
04:13:12 <jle`> too much for me at 4 am
04:13:14 <jle`> good night all
04:14:46 <vanila>  f '=>=' 'extract' = f 'extract' '=>=' f = f (f '=>=' g) '=>=' h = f '=>=' (g '=>=' h)
04:15:35 <jle`> yeah, all of the Comonad laws have really cute Monad law analogues
04:18:05 <arianvp> Why does Traversable need Foldable?
04:33:55 <gspr> Hi. Is the XML parser from the package "xml" (the one with the Text.XML.Light module hierarchy) supposed to be able to lazily parse XML?
04:34:44 <gspr> (Data.Text.Lazy is an instance of its XmlSource typeclass, but I guess that's no guarantee that the parser doesn't just try to read all the data into memory before parsing)
04:42:28 <greeny> hi i simply try to run a sql statement with hdbc and sqlite3. but when using 'run' after connectSqlite3 i always get No instance for (IConnection Connection)
04:43:17 <greeny> but in Database.HDBC.Sqlite3 this it's an instance
04:52:37 <greeny> hackage says Connection has been made to an instance of IConnection in HDBC.Sqlite3, but local its missing
05:14:53 <gcganley> :k (*)
05:14:54 <lambdabot> Not in scope: type constructor or class ‚Äò*‚Äô
05:15:02 <gcganley> :k Maybe
05:15:03 <lambdabot> * -> *
05:17:41 <hexagoxel> is there an identity fold on Data.Tree.Tree's?
05:18:23 <greeny> it works now. i had two different versions of hdbc installed
05:18:37 <hexagoxel> it is no Monoid, so my guess the answer is no..
05:25:51 <Fuuzetsu> ?
05:26:13 <Fuuzetsu> Just make the function passed to the fold rebuild the tree as it goes
05:26:16 <killy9999> I have (Mayba a) value and (a -> m a) function
05:26:29 <killy9999> I need to get `m (Maybe a)`
05:26:35 <killy9999> where m is a Monad
05:26:44 <killy9999> are there any combinators that allow to do that?
05:27:13 <dibblego> killy9999: traverse
05:27:47 <tdammers> does anyone know how I can do ad-hoc compilation in a cabal sandbox? as in, invoke ghc directly, but getting libraries from inside the current cabal sandbox instead of the global ghc config?
05:27:50 <Fuuzetsu> I've seen nothing but questions that were answered with 'traverse' recently.
05:27:53 * hackagebot yesod-text-markdown 0.1.6 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.6 (ArashRouhani)
05:27:56 * killy9999 is checking traverse
05:28:15 <dibblego> traverse yourFunction yourMaybe
05:28:22 <Fuuzetsu> tdammers: Pass in the database generated by the sandbox to GHC
05:28:33 <killy9999> yup, works
05:28:34 <killy9999> thanks
05:28:42 <Fuuzetsu> Say, by GHC_PACKAGE_PATH or something.
05:28:51 <tdammers> lemme try that
05:30:11 <Fuuzetsu> there are some instructions in the Install section on yi-editor.github.io that might be useful to you to some degree, tdammers
05:30:44 <Fuuzetsu> Apparently I can't paste into this terminal so I can't link to stuff directly.
05:32:11 <tdammers> just found the -package-db option... this might be exactly what I need
05:32:47 <tdammers> yesss
05:33:23 <gcganley> is there a book on cabal and other haskell specific things? like an orielly book or something
05:33:32 <Fuuzetsu> No
05:33:38 <gcganley> damn
05:33:49 <gcganley> that would be an insta-buy
05:34:05 <tdammers> it would also be an insta-outdated
05:34:13 <tdammers> more or less
05:34:16 <silver> same thoughts
05:34:18 <gcganley> tdammers: thats so true it hurts
05:34:21 <Fuuzetsu> I can print you the cabal manual for the one¬≠time price of 198 dollars
05:34:31 <Fuuzetsu> one of the kind
05:34:35 <Fuuzetsu> collector's edition
05:34:40 <gcganley> Fuuzetsu: MAKE IT 50!
05:34:42 <tdammers> Fuuzetsu: shell one-liner?
05:35:04 <Fuuzetsu> tdammers: it's printers we're dealing with, I doubt it would be one-liner when it comes down to it.
05:35:36 <tdammers> ah right, yeah
05:35:44 <Fuuzetsu> one line  and few goats maybe
05:35:48 <tdammers> printers are practically robots, except they lack decent engineering
05:35:57 <Fuuzetsu> evil robots
05:36:05 <gcganley> evil robots that break
05:36:09 <gcganley> alot
05:36:11 <gcganley> *a lot
05:36:19 <tdammers> and nobody ever bothers writing any drivers for them, they just ship with proof-of-concept implementations
05:36:38 <gcganley> without cross platform implementations
05:36:53 <gcganley> "no one uses linux"
05:38:08 <hyPiRion> Anyone familiar with CTRex here? I'm presumably unable to assert `(Extend "foo" Foo r :! "foo") ~ Foo`, which is a tad confusing.
05:38:40 <Fuuzetsu> is CTRex like vinyl
05:38:54 <hyPiRion> Fuuzetsu: extensible records
05:38:58 <hyPiRion> http://www.haskell.org/haskellwiki/CTRex
05:39:00 <Fuuzetsu> then yes
05:39:45 <hyPiRion> oh, I wasn't aware of vinyl. Perhaps I should check that out instead.
05:39:59 <hyPiRion> thanks for pointers
05:40:11 <tdammers> gcganley: there is no printer market. Only an ink market. Printers are given away, "oil for the lamps of china"
05:40:57 <Dique> hello
05:41:24 <gcganley> hi
05:44:04 <gcganley> Fuuzetsu: is there a cabal user manual or is that just the man page?
05:44:21 <Fuuzetsu> there's some manual
05:44:37 <gcganley> Fuuzetsu: is it any good?
05:44:37 <gcganley>  
05:44:44 <Fuuzetsu> haskell.org/cabal/users-guide
05:45:12 <Fuuzetsu> it has links to stuff you probably want to know about
05:45:19 <hexagoxel> Fuuzetsu: but with Traversable.foldr' :: (a -> b -> b) -> b -> t a -> b, what can we pass for 2nd param? it should be 'mempty'..
05:45:31 <gcganley> Fuuzetsu: like what? anything specific?
05:45:53 <kgadek> hi. Is there anything like (Num a, Floating b) => a -> b ?
05:45:57 <Fuuzetsu> gcganley: I don't know what you're after, why don't you just look and see?
05:46:12 <gcganley> kgadek: check out hoogle
05:46:13 <Fuuzetsu> :t toFractional
05:46:15 <lambdabot>     Not in scope: ‚ÄòtoFractional‚Äô
05:46:15 <lambdabot>     Perhaps you meant ‚ÄòtoRational‚Äô (imported from Prelude)
05:46:17 <kgadek> gcganley: no results
05:46:18 <Fuuzetsu> hm
05:46:22 <Fuuzetsu> there was something
05:46:27 <gcganley> hmm...
05:46:43 <gcganley> is there a to floating?
05:46:48 <gcganley> :t toFloating
05:46:49 <lambdabot> Not in scope: ‚ÄòtoFloating‚Äô
05:46:54 <gcganley> drats
05:47:22 <gcganley> is Num a super class of Floating?
05:47:34 <Fuuzetsu> :t realToFrac
05:47:34 <kgadek> gcganley: yes
05:47:35 <lambdabot> (Real a, Fractional b) => a -> b
05:47:41 <Fuuzetsu> that work?
05:47:55 <gcganley> @src realToFrac
05:47:55 <lambdabot> realToFrac = fromRational . toRational
05:48:34 <Fuuzetsu> You should be checking the instances for Real, not the definition.
05:50:04 <Fuuzetsu> afk
05:50:22 <kgadek> ok, thanks. I think that could do the job
05:58:20 <gnuboi> Is this course going to be good? I want to learn functional programming and Haskell?
05:58:20 <gnuboi> https://www.edx.org/course/delftx/delftx-fp101x-introduction-functional-2126#.VDaHa9R4qYk
05:58:46 <jmct> probably
05:58:47 <butyoudonot> > going to be good
05:58:49 <lambdabot>  Not in scope: ‚Äògoing‚ÄôNot in scope: ‚Äòbe‚Äô
05:58:50 <lambdabot>  Perhaps you meant one of these:
05:58:50 <lambdabot>    ‚Äòb‚Äô (imported from Debug.SimpleReflect),
05:58:50 <lambdabot>    ‚Äòe‚Äô (imported from Debug.SimpleReflect),
05:58:50 <lambdabot>    ‚Äòre‚Äô (imported from Control.Lens)Not in scope: ‚Äògood‚Äô
05:58:51 <butyoudonot> > Erik Mejer
05:58:52 <lambdabot>  Not in scope: data constructor ‚ÄòErik‚ÄôNot in scope: data constructor ‚ÄòMejer‚Äô
06:00:06 <jmct> Erik knows his stuff and has said that it will be a course on FP principles (not just Haskell) so I imagine it will be nice
06:01:22 <gnuboi> Cool thanks
06:04:21 <viran> anyone here familiar with Encog?
06:07:06 <profil> Hey guys, can I have an instance for a type (typedef)? I am working with aeson and hides a [Int] behind a "type SomeList = [Int]"
06:08:01 <nshepperd> if it's "type SomeList = [Int]" then SomeList and [Int] are synonymous
06:08:24 <nshepperd> so you can't write an instance for SomeList that is separate from the [Int] instance
06:08:51 <profil> Alright, that means I can create an instance for SomeList
06:09:22 <n4x> why not a newtype?
06:10:09 <profil> hmm, yeah, maybe I want "newtype SomeList = SomeList [Int]" instead? is that what you mean?
06:10:40 <n4x> yeah, also https://ghc.haskell.org/trac/haskell-prime/wiki/TypeSynonymInstances ?
06:10:47 <nshepperd> newtypes are generally considered cooler and more hip, yeah
06:11:23 <nshepperd> and also newtypes do indeed support having a SomeList instance that wouldn't conflict with the normal [Int] instance or [a] instance
06:15:05 <nshepperd> oh, I see, without TypeSynonymInstances you would have to write "instance FooClass [Int]" instead of "instance FooClass SomeList"
06:15:28 <nshepperd> for the type synonym definition
06:15:34 <profil> ah, alright
06:24:54 <srenatus> hi there. is there any way to pretty-print a tree-like structure that does not use a Tree from containers?  maybe using its instance-of's? (traversable?)
06:30:36 <jmct> did you roll this data-type yourself?
06:32:14 <jmct> depending on how 'pretty' you want your pretty-printing, deriving Show can be sufficient
06:33:51 <srenatus> jmct: I didn't, no.  there's show, but it's actually like data T = Leaf a | Branch T T, so I hoped for some cheap way to get at least indentation
06:36:03 <cariveri> hi.
06:36:45 <cariveri> Does anyone know of a way to create a pdf from a documentation made by haddock ?
06:37:51 <srenatus> cariveri: are you asking for some tool to do html2pdf or something more beautiful?
06:39:04 <cariveri> well html2pdf converter would be ok, but there is a way to output pdf instead of html ?
06:40:49 <jmct> srenatus: In that case I usually just use a pretty-printing library like 'pretty' on hackage, but that may be overkill for you
06:41:06 <jmct> srenatus: this looks relevant: http://stackoverflow.com/questions/19082560/haskell-pretty-print-binary-tree-not-displaying-properly
06:43:01 <nilg> guys, really strange since recently when I indent my Haskell code with TAB in emacs it outputs a help page
06:43:14 <nilg> haskell-mode-hook is a variable defined in `haskell-mode.el'.
06:43:14 <nilg>  
06:43:22 <nilg> and so on... any idea?
06:47:27 <naali> hi.. sry I'm very noob.. I'm following the wiki and I've problems doing IO excercise
06:47:32 <naali> what's wrong with this code? http://lpaste.net/112371
06:48:27 <naali>   No instance for (Num (IO t0)) arising from a use of `getArea'
06:48:38 <sm> #le
06:51:21 <t7> change line 8 to    let area = getArea...
06:51:27 <t7> naali: ^
06:51:32 <naali> ok
06:51:43 <artyomkazak> nilg: I don't want to spam the channel with guesses, but if you could upload your .emacs somewhere, I'd take a look at it
06:51:52 <t7> '<-' is a monadic action
06:52:08 <t7> but your function does not return a monad
06:52:28 <naali> ok I was trying just using '=' but it didn't work
06:52:49 <t7> also isnt it (a * b) / 2 ? :D
06:52:55 <naali> yes sure
06:52:56 <naali> ;D
06:53:10 <naali> thought rectangle eheh
06:53:51 <naali> Could not deduce (Fractional a) arising from a use of `/'
06:54:03 <naali> it gives that now
06:54:16 <t7> a * b `div` 2
06:54:30 <t7> or
06:54:38 <t7> change the type signature for getArea
06:55:09 <t7> '/' doesnt exist for integers because it returns a fractional result
06:55:58 <naali> Could not deduce (Integral a) arising from a use of `div'
06:56:12 <srenatus> jmct: thanks
06:56:24 <naali> and if I change type signature
06:56:31 <naali> it says me   `Float' is applied to too many type arguments
06:56:59 <Javran_Eval> hi, a simple question about category theory: is it possible that two objects of a category are "isolated" from each other (no morphism connecting them)?
06:57:18 <barrucadu> Javran_Eval: Yes. Consider a category with two objects and only identity arrows
06:57:47 <barrucadu> Or any category with more than 1 item and no non-identity loops
06:57:52 <barrucadu> s/item/object
06:57:58 <jmct> barrucadu: get back to work.
06:58:04 <Javran_Eval> barrucadu: i see
06:58:12 <barrucadu> jmct: You get back to work
07:05:38 <lpaste> saep annotated ‚ÄúIO‚Äù with ‚ÄúIO (annotation)‚Äù at http://lpaste.net/112371#a112372
07:06:17 <xpika> i need takeWhile including the last element
07:06:25 <saep> naali: I annotated your pasted code a little.
07:06:51 <naali> hmm
07:06:51 <naali>  :: Double is a cast?
07:07:01 <xpika> takeWhile' odd [3,3,4,2,2] => [3,3,4]
07:07:30 <saep> naali: No, it's an inline type signature
07:07:53 <saep> > print 2 * 4 / 3
07:07:55 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.IO ()))
07:07:55 <lambdabot>    arising from a use of ‚ÄòGHC.Num.*‚ÄôNo instance for (GHC.Real.Fractional (GHC...
07:07:55 <lambdabot>    arising from a use of ‚ÄòGHC.Real./‚Äô
07:08:06 <saep> > print (2 * 4 / 3)
07:08:09 <lambdabot>  <IO ()>
07:08:50 <naali> getArea :: Fractional a => a -> a -> a
07:08:50 <naali> :D
07:09:28 <naali> thx saep.. for the comments too
07:11:19 <naali> .
07:22:58 * hackagebot creatur 5.6.7 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.7 (AmyDeBuitleir)
07:27:59 * hackagebot creatur 5.6.8 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.8 (AmyDeBuitleir)
07:28:01 * hackagebot netwire-input 0.0.2 - Input handling abstractions for netwire  http://hackage.haskell.org/package/netwire-input-0.0.2 (Mokosha)
07:43:06 <mcrist0> Hi guys - new to haskell.  I need some serious help with a program
07:43:14 <artyomkazak> ask away
07:43:20 <mcrist0> Anyone familiar with the Scotty library?
07:44:18 <pjdelport> mcrist0: Probably a bunch of people; best to just post the details of the problem / question. :)
07:44:33 <pjdelport> You can use lpaste (see topic) if you want to show some code.
07:45:12 <mcrist0> Alright - I'll craft something and get back to you guys
07:45:55 <deni> this isn't stricly a haskell question but I guess I'd get the best answers here. So, are there any papers or articles showing in theory how best to synchronise saving of data to multiple syncs? for instance saving to a local database and to a cloud API? while of course keeping the data consistent and supporting atomic writes and what not?
07:46:37 <deni> (i hope i'm explaining myself correctly)
07:47:01 <RchrdB> deni: read up on "2 phase commit", and then read up on why you can't always do that, then http://kellabyte.com/2012/05/30/clarifying-the-saga-pattern/
07:47:55 <cariveri> Hi does anyone know of a haskell parody video? Im have seen one years ago showing a dictator declaring haskell as solution of everything and idiology to to world domination. but I cant find it anymore. perhaps it was deleted because of the nazi comparison.
07:48:00 * hackagebot helics 0.1.1 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.1.1 (HirotomoMoriwaki)
07:48:12 <profil> I dont understand how I should parse an array with aeson, I got "newtype SomeList = SomeList [Int]" and I want to create a FromJSON instance of SomeList, "instance FromJSON SomeList where\n parseJSON (Array v) = SomeList $ V.toList v" but that doesnt work because it doesnt return a Parser, how do I solve this? Can someone give me some insight to how to handle arrays in aeson
07:48:19 <deni> RchrdB: awesome tnx.
07:48:41 <gcganley> deni: maybe spj's paper on stm, i havent read it but it sounds like your case
07:48:47 <gcganley> deni: maybe cloud haskell
07:48:48 <RchrdB> deni: in the case where you're writing to multiple systems, even commit atomicity is very often *actually impossible* because the authors of some subset of those systems haven't allowed for it
07:49:17 <deni> gcganley: i'm familiar with stm..doesn't help me in this specific case..it's not even haskell so
07:49:23 <deni> RchrdB: yeah i'm getting that feeling
07:49:28 <bergmark> profil: first of all, you can just derive that instance
07:49:42 <RchrdB> (possibly for good reasons, such as prioritising availability over consistency)
07:50:04 <deni> RchrdB: the issue I have are kinda bizzaro...in the sense that when saving to the local database i need to be atomic while saving to the cloud as well. Which is hard in itself.
07:50:19 <bergmark> profil: but generally you should call parseJSON recursively and then convert from e.g. Parser Value to Parser MyType
07:50:21 <RchrdB> Why are you saving to the cloud at all?
07:50:47 <deni> RchrdB: but another case i have is that the cloud storage can change without the local db knowing about it. So I have to pick on that eventually. So i kinda have atomic writes one way...and eventual consistency the other way
07:51:23 <profil> bergmark: so I want FromJSON on my Ints?
07:51:32 <deni> RchrdB: it's just an expressions I'm saving to a Remote user (kindof) Ldap directory (and locally to the db)
07:51:58 <RchrdB> deni: I don't think I have enough time to give this conversation the amount of attention it needs to be useful, sorry. ¬¨¬¨
07:52:11 <bergmark> profil: i'm not sure what you mean
07:52:12 <RchrdB> as a general rule, I would strongly advise having one and only one system be the authoritative source of truth
07:52:46 <RchrdB> e.g. in that case I'd throw away the local DB, use the remote LDAP directory alone as the authoritative source, and if necessary, have a local (inconsistency-introducing) cache of it.
07:53:31 <deni> RchrdB: the remote API is the authoritative one, and it kinda handles the authentication. the reason i need stuff locally is to be able for the web framework i'm using to be able to manipulate users, and have other local tables reference it and so on
07:53:45 <mcrist0> Could someone take a look at this?
07:53:45 <mcrist0> http://pastebin.com/nfatfBWH
07:53:45 <mcrist0> If you want to see the full project, it's at http://github.com/arecker/Comics
07:53:45 <mcrist0> It's terrible.  First thing I've done in haskell just a warning
07:53:55 <deni> RchrdB: it's bizzare and convoluted i know
07:54:00 <RchrdB> deni: note that having more than one (authoritative system) for a given piece of information always leads to disaster even in the "nice" single-system, single-threaded case. If a fact is represented in two places, you will eventually write a bug into your program that updates one differently to the other.
07:54:20 <RchrdB> it's kind of what E Codd's thesis was about, AIUI
07:54:44 <profil> bergmark: if you mean that I should apply parseJSON recursively, you mean on each element in the Vector?
07:54:47 <deni> RchrdB: yes but there's not going around it. I need the local database representation as well
07:54:54 <deni> which kinda acts like a cache i guess
07:55:03 <RchrdB> You're mildly doomed.
07:55:39 <RchrdB> I would strongly advise using that DB only as a cache.
07:56:16 <deni_> bah connection issues again
07:56:18 <deni_> RchrdB: tnx for your help
07:56:25 <bergmark> profil: you can do in multiple levels, but since there are instances for FromJSON Int and FromJSON a => FromJSON [a] you can use `parseJSON :: Value -> Parser [Int]`
07:56:50 <RchrdB> deni_: the last 2 lines I sent were "RchrdB | You're mildly doomed" "RchrdB | I would strongly advise using that DB only as a cache."
07:57:41 <deni_> RchrdB: tnx. I will try and see If i can make it work that way
07:57:45 <bergmark> profil: most of my instances look like this: `parseJSON = fmap f . parseJSON', or more generally `parseJSON = f <=< parseJSON' if there can be further errors when calling `f'
07:57:56 <RchrdB> (by "mildly doomed" I mean "I think that if you really are subject to the constraint of having to have the local DB be authoritative as well as the remote DB being authoritative, your constraints are unsatisfiable and you're guaranteed to run into trouble somewhere".
07:58:00 * hackagebot creatur 5.6.9 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.9 (AmyDeBuitleir)
07:58:54 <deni_> RchrdB: the database can't be authoritative in a whole....for instance it doesn't have the authentication data. Just the other data, like email, names and so on
07:59:20 <deni_> RchrdB: every time a user auths he goes through the remote API. which in turns gives me a chance to a sync of the remote stuff locally.
07:59:41 <profil> bergmark: yeah, alright, gonna check the implementation for FromJSON [a] and see if I can learn something, thanks :)
08:00:38 <Jenna23>  Free Porn for Life!. Click Here! http://bit.do/my_videos69
08:01:07 <gcganley> hey look a porn bot
08:02:04 <Kinnison> Can we get this one to learn Haskell?
08:02:12 <Kinnison> oh, it left
08:04:41 <lyxia> mcrist0: You're mixing String and Text. You need some conversion functions.
08:05:41 <mcrist0> I thought "text" takes care of that?  I'm following this tutorial -> http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
08:06:23 <artyomkazak> no, `text` needs a Text
08:06:47 <artyomkazak> it works in tutorial because with overloaded strings enabled, e.g. ¬´"there is no such route."¬ª is both String and Text
08:07:12 <artyomkazak> but your `dbHelper` returns String, which has to be converted explicitly
08:08:04 <artyomkazak> also, since `dbHelper` is in IO monad and Scotty works in its own monad, you'll need to `lift` it
08:08:49 <mcrist0> What would that look like?  I could sense that was a problem since no matter what followed text <- dbHelper was throwing an error
08:08:54 <mcrist0> even text "hello"
08:09:51 <artyomkazak> import Control.Monad.Trans.Class
08:10:12 <artyomkazak> and just use ‚Äúlift dbHelper‚Äù instead of ‚ÄúdbHelper‚Äù
08:10:20 <profil> bergmark: you said that I could derive the instance for a list, how do I do that when I got "newtype SomeList = SomeList [Int] deriving (Show)"?
08:10:57 <ChristianS> artyomkazak: did you use the OverloadedStrings pragma like they suggest?
08:11:22 <mcrist0> I'll give it a shot - thanks guys
08:11:36 <artyomkazak> ChristianS: ne already uses OverloadedStrings pragma, see here for the full version of nir code: https://github.com/arecker/Comics/blob/master/Main.hs
08:12:13 <ChristianS> artyomkazak: is that the code you're trying to compile?
08:12:26 <artyomkazak> yep
08:13:02 <artyomkazak> I checked, it compiles after I add `lift` and one `TL.pack`
08:13:12 <artyomkazak> (TL = Data.Text.Lazy)
08:13:23 <artyomkazak> maybe I should submit a pull request
08:13:42 <bergmark> profil: since you have a newtype over an existing FromJSON instance you can just add deriving FromJSON
08:14:51 <ChristianS> artyomkazak: ah, i see. yes, yu probably should.
08:15:06 <profil> bergmark: yeah I tried that and got "‚ÄòFromJSON‚Äô is not a derivable class"
08:15:49 <bergmark> profil: didn't it tell you to enable GeneralizedNewtypeDeriving?
08:15:56 <bergmark> i just tested, it works
08:16:37 <Javran> yet again some CT questions here: I'm trying to understand Yoneda embedding, so if I turn a locally small category C into Ha(C), it will keep the "shape" of C (objects are mapped into their hom-sets, morphisms are mapped in a way that how they connect objects doesn't change)?
08:23:01 * hackagebot netwire-input-glfw 0.0.2 - GLFW instance of netwire-input  http://hackage.haskell.org/package/netwire-input-glfw-0.0.2 (Mokosha)
08:23:04 <mcrist0> Oh my gosh it's working.  You guys are amazing.  Thanks
08:35:47 <S11001001> Is this function defined anywhere?
08:35:49 <S11001001> :t \f a b -> join (liftM2 f a b)
08:35:51 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
08:36:17 <S11001001> aka
08:36:19 <S11001001> :t \f a b -> do a <- a; b <- b; f a b
08:36:20 <lambdabot> Monad m => (t -> t1 -> m b) -> m t -> m t1 -> m b
08:37:03 <semigroup> I'm using a library that links to a .so file, and when I build an executable using that library, I'm getting told that it can't find the shared object file. Anyone have any idea what I'm doing wrong?
08:37:22 <semigroup> S11001001: looks like good use case for applicatives
08:37:30 <semigroup> f <$> m1 <*> m2
08:37:43 <S11001001> semigroup: No.
08:38:03 <S11001001> semigroup: it definitely needs monad
08:39:03 <semigroup> Well, all monads should be applicative as well.
08:39:38 <S11001001> semigroup: that's join (f <$> a <*> b); not really a gain over liftM2
08:40:12 <semigroup> Oh, derp. Misread the type signature
08:42:44 <humanoyd> Hey, I'm trying to use shake as a build system for the development of a webapp...for cache busting purposes I usually rename .css and .js files according to a content hash...what would be the canonical approach for that in haskell?
08:43:00 <humanoyd> when I search for "hash" on hackage I get a gazillion packages
08:45:19 <S11001001> humanoyd: how about http://hackage.haskell.org/package/digest ?
08:48:03 * hackagebot caramia 0.1.0.0 - Caramia real-time hardware-accelerated rendering library  http://hackage.haskell.org/package/caramia-0.1.0.0 (Adeon)
08:50:36 <humanoyd> S11001001: I don't know...is digest the package that is most commonly used for this?
09:12:16 <johnw> morning
09:16:26 <Javran> can I say that "fmap f . join = join . (fmap . fmap) f" is what makes "join" a natural transformation?
09:16:41 <johnw> actually, you can
09:16:46 <johnw> so long as the laws are also transported
09:17:07 <johnw> i mean, what you give there is a naturality condition
09:17:29 <Javran> johnw: so for return it's "fmap f . return = return . f"
09:17:41 <johnw> fmap f ‚àò transport = transport ‚àò fmap f
09:17:51 <johnw> that's the general form, for any natural transformation defined by "transport"
09:18:09 <johnw> what you wrote about join is convertible to that form by the 1st monad law
09:18:13 <latk> I have a binary tree representing some boolean operations on strings (say just AND and OR for now). I want to check that these strings are valid (say there is a set of valid strings). I want a validation function, so if something looks like "valid AND invalid" this should change to "valid". Is there some way to check these things from the bottom up ?
09:18:16 <Javran> johnw: so it's informally saying that you can "move transport around"?
09:18:28 <johnw> exactly that transport respect functoriality
09:18:46 <Javran> johnw: I see
09:19:56 <johnw> otherwise, you'd just have a morphism between type-formers, but you wouldn't know anything about the result
09:20:19 <johnw> if you further constraint transport to respect monadic structure, you have a monad morphism
09:20:59 <johnw> so, in general, an "X morphism" is natural in X if it transports all of its structure; we just happen to call functor morphisms by the name "natural transformation"
09:21:01 <Javran> johnw: I noticed you just said " fmap f ‚àò transport = transport ‚àò fmap f ", so (fmap . fmap) is considered a single fmap for something like (m (m a))?
09:21:13 <johnw> no
09:21:20 <johnw> because you used join, you have access to the 1st monad law
09:21:27 <johnw> which lets you rewrite join . fmap join into join . join
09:21:47 <johnw> so I can collapse your fmap . fmap into fmap in that specific case
09:21:59 <johnw> maybe that's what you meant...
09:22:53 <Javran> I'm actually reading this https://www.fpcomplete.com/user/bartosz/understanding-yoneda not getting to deep into CT though.
09:23:04 * hackagebot FunGEn 0.4.6 - A lightweight, cross-platform, OpenGL/GLUT-based game engine.  http://hackage.haskell.org/package/FunGEn-0.4.6 (SimonMichael)
09:23:07 <johnw> ah
09:23:13 <johnw> that's some relatively advanced stuff there
09:24:06 <johnw> that's really good stuff though, please ask more questions
09:24:22 <Javran> "There are more interestig examples of natural transformations in Haskell; monadic return and join come to mind. " so I go back to examine those laws of return and join
09:24:48 <centrinia> @slap lzm
09:24:48 <lambdabot> I don't perform such side effects on command!
09:24:52 <centrinia> :|
09:25:09 <Javran> @slap lambdabot
09:25:10 * lambdabot is overcome by a sudden desire to hurt lambdabot
09:25:16 <johnw> another way to phrase the naturality condition is: I can fmap before, or fmap after, and there's no difference in meaning
09:25:39 <johnw> yoneda depends on this
09:25:54 <johnw> otherwise, it would mangle your functor and lose all of its value
09:26:31 <Javran> johnw: I see, need some time to digest though.
09:26:51 <johnw> I tihnk the easiest way to get started with yoneda is by looking at the utility of the coyoneda construction
09:27:14 <Javran> johnw: so maybe my "moving around" is really describing what naturality condition is?
09:27:35 <johnw> I'm not sure what you are imagining as moving
09:29:29 <Javran> johnw: like "foo . bar . fmap f . baz" turned into "fmap f . foo . bar . baz"
09:29:37 <johnw> ah, yes
09:29:49 <johnw> "it doesn't matter when you fmap f"
09:29:58 <johnw> a freedom you gain from naturality
09:30:17 <Javran> johnw: thanks that's more clear
09:30:55 <Javran> johnw: but what's the benefit of doing this, map fusion?
09:31:06 <johnw> of using the yoneda embedding?
09:31:09 <johnw> yep, fmap fusion
09:31:12 <johnw> that's one use
09:31:20 <johnw> another use is type normalization
09:31:39 <johnw> you can have value f a, f b and f c, and make them all appear as if they were the same "f d"
09:31:54 <johnw> since only the consumer of the final result really needs to know the final type
09:32:19 <Javran> johnw: I haven't heard of this before, maybe a little beyond my current knowledge :(
09:33:21 <johnw> I think the fmap fusion use case is more common anyway
09:35:13 <YurasS> `fail` bites me again: http://hackage.haskell.org/package/bson-0.3.1/docs/src/Data-Bson.html#look
09:35:24 <YurasS> damn fail :(
09:38:05 * hackagebot FunGEn 0.4.6.1 - A lightweight, cross-platform, OpenGL/GLUT-based game engine.  http://hackage.haskell.org/package/FunGEn-0.4.6.1 (SimonMichael)
09:38:17 <diginet> how does Haskell have closures? don't closures imply mutable state?
09:38:39 <vanila> diginet, haskell has lambda
09:39:00 <diginet> vanila: by that do you mean anonymous functions?
09:39:00 <johnw> why would closures imply mutable state?
09:39:05 <vanila> diginet, yes exactly
09:39:19 <recursion-ninja> digitnet: cosures don't imply mutablility, they have to do with variable scoping
09:39:20 <johnw> not just anonymous functions, but anonymous functions that close over the binding context
09:39:22 <vanila> diginet, one technque for implementing lambda is to build closures - I'm not sure if haskell does this or not though
09:39:35 <diginet> johnw: hmm, I guess they don't have to but the way I see them used in say, javascript is always in a stateful way
09:39:48 <diginet> maybe a better question is, what's the point of closures without state?
09:39:51 <Javran> johnw: another question about Yoneda embedding: f I turn a locally small category C into H^A(C), is that true that it will keep the "shape" of C (objects are mapped into their hom-sets, morphisms are mapped in a way that how they connect objects doesn't change)?
09:40:15 <johnw> closures let you package up values in an anonymous function freely
09:40:24 <johnw> like: \f -> fmap f [1,2,3]
09:40:31 <Javran> I drew a simple category with only 3 objects connecting each other, and it seems to be the case.
09:40:31 <vanila> well lambda lets you do that
09:40:33 <johnw> is isomorphic to that same list
09:40:44 <johnw> that wasn't a closure though
09:40:53 <johnw> this is: let xs = [1,2,3] in \f -> fmap f xs
09:41:00 <mmmm_> I get errors which say that I should add "ghc" to my build-depends section in my cabal file but when I add just ghc, there isn't a consistent set of dependencies? http://hastebin.com/uhiredupax.txt
09:41:05 <mmmm_> How can I find out what's going on
09:44:16 <josephle> I find that when you try to do haskelly things in rust, you quickly find out where all the closures are :)
09:46:46 <hask-> I have a large txt file. It contains some text. Sprinkled throughout it, there are things surrounded with # and #. Examples: #foo#, #bar#, etc.
09:46:47 <hask-> I have a Haskell map that maps strings to strings. Example: Data.Map.fromList [("foo","foo_replacement"), ("bar", "bar_replacement").
09:46:48 <hask-> How can I write a function
09:46:49 <hask->   text_replacement :: String -> Data.Map.Map String String -> String
09:46:49 <hask-> that takes the original text and uses the replacement map to return the same string except with the things in ## replaced?
09:47:11 <c_wraith> hask-: there are a bunch of ways - that do different things.
09:47:21 <c_wraith> hask-: what do you want to happen with overlapping matches?
09:47:22 <comerijn> hask-: You probably don't want to use String for that
09:47:31 <comerijn> On account of performance sucking
09:47:54 <hask-> c_wraith: what is an overlapping match
09:48:05 <YurasS> mmmm_: ah you using cabal sandbox?
09:48:07 <hask-> comerijn: ok feel free to use byte strings or something
09:48:31 <YurasS> mmmm_: s/ah/are
09:48:41 <comerijn> hask-: Text is the way to go, but yeah :)
09:48:52 <c_wraith> hask-: text_replacement "foobar" (fromList [("oo", "zed"), ("ob", "anchor")])
09:48:59 <S11001001> @ty () :: Alternative IO => ()
09:49:00 <lambdabot>     No instance for (Alternative IO)
09:49:00 <lambdabot>       arising from an expression type signature
09:49:00 <lambdabot>     In the expression: () :: Alternative IO => ()
09:49:08 <c_wraith> hask-: by the way, that argument order should probably be flipped.
09:49:12 <comerijn> hask-: I would probably write an attoparsec parser that looks up any # entries in the map and outputs the entire thing
09:49:27 <c_wraith> hask-: the map should probably be the first argument, for the sake of partial application
09:49:46 <hask-> c_wraith: i only want #foo# to turn into #foo_replacement# if "foo" is an exact key in the dictionary
09:50:06 <c_wraith> hask-: err.  what are ##s?  Word boundaries?
09:50:23 <hask-> yeah just some character I chose. it could have been #$%foo#$%
09:50:32 <hask-> some "magic" character
09:50:37 <hask-> or "magic" characters
09:50:37 <artyomkazak> and keys can't contain ‚Äú#‚Äùs, right?
09:50:44 <hask-> yeah they can't contain #
09:50:49 <artyomkazak> what about values?
09:51:00 <c_wraith> Ah, so you're writing a templating system.  Please say so.  The information is helpful.
09:51:06 <hask-> nope the values can't contain this magic string either (in this case #)
09:51:10 <hask-> yeah :)
09:51:15 <hask-> my own custom templating system
09:51:33 <mmmm_> YurasS: The problem I think is that ghc depends on transformers-0.3.0 and I had transformers-0.4.1 installed as well
09:52:07 <mmmm_> Is there a list of packages which "ghc" depends on?
09:52:20 <YurasS> mmmm_: exceptions-0.6.1 allows transformers-0.3.0: https://hackage.haskell.org/package/exceptions
09:52:56 <YurasS> mmmm_: probably something else requires later trasformers
09:53:18 <YurasS> mmmm_: try cabal install -v
09:53:32 <mmmm_> yes, something later does require it
09:53:47 <mmmm_> actually, I'm not sure on that
09:53:51 <mmmm_> lemme try something
09:57:22 <hask-> Noone?
10:00:27 <hask-> Could it be that Haskell produces 10x less lines of code, but these lines of code take 10x more time to write?
10:00:36 <hask-> That has been my experience so far. I don't even know where to begin wtf
10:00:38 <hask-> :S
10:01:13 <vanila> hask-, that's true when you are a beginner
10:01:29 <hask-> i'm this close to giving up... i wonder if it's gonna be worth it
10:01:43 <vanila> giving up on what
10:01:43 <sclv> hask-: look at ndm's "split" package for ideas
10:01:51 <shiona> only 10 times more?
10:01:53 <sclv> or at any number of templating systems on hackage
10:02:04 <c_wraith> hask-: just use text's replace function and loop over the map.
10:02:08 <sclv> you can also just fall back to regexps if you prefer -- we have lots of libraries over that :-)
10:02:19 <sclv> true -- that's an efficient replace function in text too :-)
10:02:27 <c_wraith> hask-: there are more efficient approaches, but you probably don't need them
10:03:57 <c_wraith> Hmm.  that's a function that really does need better docs - the type signature doesn't pin down argument order.
10:07:55 <hask-> c_wraith: can I use bytestring just to make it more general?
10:07:58 <hask-> instead of Text
10:08:06 * hackagebot hackernews 0.1.0.0 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.1.0.0 (DavidJohnson)
10:08:14 <c_wraith> hask-: no.  Bytestring is for binary data.  Text is for...  text.
10:13:09 <vinit-ivar> \wc
10:13:36 <stepkut> Am I the only person who longs for a function: (Show a) => a -> Text
10:13:36 <stepkut> perhaps I am overlookin somethin
10:13:37 <stepkut> also, my g key is dyin
10:13:48 <hask-> shit. func prog is not do this, then do this, ten do this, ...  This is hard as hell!
10:14:15 <hask-> How do you think while writing func prog code?
10:14:35 <hask-> How do you know where to start?
10:14:41 <hask-> And how to do what you want to do
10:14:47 <c_wraith> hask-: think in terms of data and transformations.
10:14:51 <stepkut> hask-: I often start with the types
10:15:37 <stepkut> hask-: and then add simple functions that transform the values of those types
10:16:01 <adas> does the warp server create a seperate thread/spark/process for every client connection? I would like to know, how well warp can handle connections from multiple clients?.
10:16:10 <stepkut> adas: yes
10:16:25 <hask-> c_wraith: You wrote "just use text's replace function and loop over the map." This sounds good but it's not clear how to combine the functions
10:16:35 <hask-> seems like I have to think about the whole thing at once
10:16:40 <hask-> to be able to put it together somehow
10:16:51 <adas> stepkut: could you please elaborate?
10:17:16 <c_wraith> hask-: well, think of it in terms of transformations.  You want to repeatedly transform a Text value based on the contents of a map.
10:17:37 <stepkut> adas: warp (and all the other Haskell web servers) spawn a new thread to handle each incomin connection. They are all capable of handling thousands of simultaneous requests
10:18:37 <stepkut> adas: each thread is isolated from the other threads. If you really need cross-thread communication then you can use STM -- or go through the IO system and communicate via somethnig like an external SQL database
10:19:34 <c_wraith> hask-: So start with the repeated transformations.  There happens to be a function that takes a map and transforms a value once for every key-value pair in the map.
10:19:40 <stepkut> well -- you wouldn't typically have client threads talking to each other -- but you would have multiple client threads all trying to use some form of shared state
10:19:52 <comerijn> c_wraith: That'll be pretty slow, though
10:20:01 <dmj`> stepkut: I wrote that function out yesterday toText :: Show a => a -> Text; toText = T.pack . show... should be in text
10:20:12 <c_wraith> comerijn: in a template system, most maps will be small enough that it doesn't matter.  and it's far easier code.
10:20:37 <stepkut> dmj`: I have (Text.pack $ show x) all over my code
10:21:06 <hask-> c_wraith: won't I need to use regex somehow to parse foo away from #foo# ?
10:21:10 <comerijn> dmj`: I don't think it should be
10:21:12 <stepkut> definitely does not increase readability
10:21:21 <comerijn> show shouldn't be used for user facing output anyway
10:21:26 <adas> stepkut: yes. i intend to use postgres
10:21:28 <comerijn> And toText only encourages that
10:21:28 <c_wraith> hask-: no.  you nearly never need to use a regex.  And they should never be your first choice.
10:21:31 <dmj`> comerijn: really?
10:22:01 <hask-> c_wraith: then I somehow need to find the #'s and store the begin and end indexes?
10:22:33 <c_wraith> hask-: you certainly are thinking very low-level.  Replace handles that.
10:22:34 <stepkut> dmj`: maybe it should be: (Show a, IsString b) => a -> b
10:22:57 <c_wraith> hask-: just tell it what to replace with what.
10:22:59 <comerijn> stepkut: ‡≤†_‡≤† ‡≤†_‡≤† ‡≤†_‡≤†
10:23:22 <stepkut> comerijn: what!?!
10:23:38 <merijn> stepkut: That's a horrible function, it makes me cry :(
10:23:51 <stepkut> merijn: it's better than: a -> b
10:24:00 <merijn> Just barely...
10:24:16 <hask-> c_wraith: but i want #foo# to turn into foo_replacemnt. the #'s should go away. (i may have mistakenly said earlier that the #'s should stay put. sorry about that)
10:24:28 <stepkut> merijn: what offends you about it?
10:24:45 <merijn> hask-: So, for every key in your map, surround key with # and do replace with that on your Text?
10:25:22 <merijn> stepkut: First of, using show for anything other than debugging and two IsString polymorphism which leads to funkily bad type inference behaviour
10:25:30 <hask-> merijn: are you talking about pattern matching?
10:25:45 <hask-> c_wraith: is pattern matching what you have in mind?
10:26:04 <stepkut> merijn: how do you recommend showing Integers then?
10:26:44 <stepkut> sadly, both Show and IsString are broken, IMO, but I can't fix that
10:27:03 <stepkut> best hope at this time is to make sure Idris doesn't make the same mistakes ;)
10:27:17 <dmj`> stepkut: yea, I have a lot of IsString. deriving (Text, ByteString) would be cool too for data types. class Show a => ToText a where toText :: a -> Text; toBS :: a -> ByteString, would be convenient IMO
10:28:15 <dmj`> well deriving (Text, ByteString) doesn't make sense :) but deriving ToText, ToBS maybe
10:28:29 <c_wraith> hask-: no.  This is far simpler. Just..  take the key, append and prepend # characters, use that as the target in the replace call.
10:28:35 <merijn> stepkut: One of the pretty printing libraries
10:28:55 <stepkut> hmm
10:29:38 <hask-> c_wraith: but you see, maybe I want to throw error when #non-existent-key# is found
10:29:54 <c_wraith> hask-: then check for that after the loop.
10:30:03 <hask-> yeah that's a good idea..
10:32:21 <stepkut> merijn: the pretty library just does: integer  n = text (show n)
10:32:22 <stepkut> :p
10:34:38 <awestroke> I get no output from trace and traceShow
10:34:54 <artyomkazak> c_wraith: here you are, https://github.com/bos/text/pull/94
10:35:42 <dmj`> stepkut: https://github.com/bos/text/issues/93 :)
10:36:00 <hask-> Is Data.Map a synonym for Data.Map.Lazy?
10:37:04 <c_wraith> hask-: not a synonym, but it re-exports everything from it.
10:37:26 <awestroke> oh nvm that branch was not  taken
10:37:40 <hask-> c_wraith: can you figure that out somehow by looking at http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map.html ?
10:37:44 <hask-> or is it something you "just know"
10:38:24 <artyomkazak> hask-: the page you linked has ‚Äúmodule Data.Map.Lazy‚Äù right under ‚ÄúDocumentation‚Äù
10:39:10 <artyomkazak> which is how a reexport is indicated
10:39:12 <hask-> artyomkazak: so does "module ..." means it exports everything from there?
10:39:15 <hask-> ok i see
10:39:16 <hask-> cool
10:40:19 <hask-> c_wraith: which of the traversing functions would you use? http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
10:40:42 <hask-> many of them return back a map, but i don't want a map back
10:40:56 <hask-> maybe i want a fold?
10:40:58 <hask-> hmm
10:41:03 <c_wraith> you do indeed want a fold
10:41:14 <stepkut> merijn: wl-pprint-text uses T.pack . show for it's integer implementation as well :-/
10:41:17 <c_wraith> and you want the fold that uses an accumulator, so a foldl
10:41:31 <c_wraith> and finally, you want the key as well as the value, so you want foldlWithKey
10:41:46 <hask-> c_wraith: right folds also have accumulators no?
10:42:42 <c_wraith> hask-: not in the same way.  foldr is more general.  foldl is specifically about "repeatedly transform this value with elements from the structure".
10:43:08 * hackagebot ert 0.0.2.0 - Easy Runtime Templates  http://hackage.haskell.org/package/ert-0.0.2.0 (kayo)
10:44:36 <t-l-o> hi all, I am playing around with https://github.com/jtdaugherty/vty-ui/blob/master/demos/ListDemo.hs - I can add items to the (vty-ui-) list with... (plainText "a list item") >>= addToList (theList st) "unused" ...Now I'd like to add a list of strings. Is there a way to map the list of strings to this construct?
10:45:26 <jfischoff> is there a tool that given a collection of main files, and list of sources, will tell you which lines or code are not being used?
10:48:09 * hackagebot hOpenPGP 1.10 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.10 (ClintAdams)
10:50:54 <t-l-o> (found a solution with map + mapM, so problem solved :) )
10:53:53 <FCatalan> so this typechecks but doesn't work. I'm at my wits' end
10:53:56 <FCatalan> sequence' :: Applicative f => [f a] -> f [a]
10:53:56 <FCatalan> sequence' [] = pure []
10:53:56 <FCatalan> sequence' (h : t) = (:) <$> h <*> sequence' t
10:53:56 <FCatalan>  
10:54:20 <FCatalan> I suspect the base case, but...
10:55:37 <S11001001> FCatalan: looks good to me; what do you expect it to do?
10:56:00 <dmj`> FCatalan: your function works for me
10:56:10 <FCatalan> for me it goes into aninfinite loop
10:57:01 <YurasS> FCatalan: What Applicative are you using?
10:57:34 <FCatalan> mmm in fact is the NICTA course so it isn't the actual real honest to god Applicative
10:57:40 <dmj`> FCatalan: can you paste your exact code on lpaste.net?
10:59:01 <FCatalan> lots of dependencies for a paste to make sense
10:59:25 <dmj`> FCatalan: there's no dependencies in this case, just Applicative, right?
10:59:28 <YurasS> FCatalan: I tried list, Maybe, IO -- all work. something else is wrong
10:59:36 <dmj`> same ^
11:00:46 <FCatalan> yes, the thing is that this is a course where you build everything from scratch so you have fake Apllicative, fake Maybe and so on, so might be a lot of things
11:00:52 <FCatalan> https://github.com/NICTA/course/blob/master/src/Course/Applicative.hs#L100
11:02:55 <RyanGlScott> I'm experiencing a bizarre error with CPP pragmas and Haskell comments: http://lpaste.net/112377
11:03:04 <YurasS> FCatalan: most likely you have circular default implementations somewhere
11:03:10 * hackagebot exception-transformers 0.3.0.4 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.3.0.4 (GeoffreyMainland)
11:03:12 * hackagebot sandi 0.3.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.1 (MagnusTherning)
11:03:18 <RyanGlScott> Removing the asterisks in the top comment removes the errors.
11:03:21 <YurasS> e.g. pure = return and return = pure
11:04:55 <hexagoxel> RyanGlScott: /* c++ comment */
11:05:23 <RyanGlScott> hexagoxel: So I can't use asterisks inside of Haskell comments with CPP on?
11:05:39 <artyomkazak> just not ¬´/*¬ª, I guess
11:05:54 <hexagoxel> you could end the line with */
11:05:56 <FCatalan> yeah, as I said I'm running on top of my own Functor, List, MaybeLike and so on, so something is probably wrong there
11:06:03 <RyanGlScott> Hm, I wonder if that behavior is intentional? It almost seems like a bug.
11:06:44 <artyomkazak> ‚ÄúCPP‚Äù is ‚ÄúC preprocessor‚Äù, it was written before Haskell even existed
11:07:28 <RyanGlScott> Sure, but it's at least smart enough not to confuse uncommented Haskell syntax with C.
11:07:47 <artyomkazak> it doesn't try to parse C code
11:08:00 <artyomkazak> only #defines and such
11:08:13 <artyomkazak> and #includes, and who knows what else (I don't)
11:09:05 <RyanGlScott> Hm, I suppose cpp could be run with the -C flag.
11:13:11 * hackagebot exception-mtl 0.3.0.5 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3.0.5 (GeoffreyMainland)
11:13:13 * hackagebot exception-monads-tf 0.3.0.3 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.3.0.3 (GeoffreyMainland)
11:13:55 <martino111111111> hi
11:16:00 <dmj`> FCatalan: can you show us your defintion of Applicative
11:19:49 <RyanGlScott> Ah, it looks like someone else reported that as a bug. Luckily, there's a workaround: https://ghc.haskell.org/trac/ghc/ticket/3389
11:21:44 <stolaruk> > concat ["abcd", "efgh"]
11:21:46 <lambdabot>  "abcdefgh"
11:21:58 <stolaruk> hmm, so why does this give me a type error in GHCi?
11:22:08 <stolaruk> "No instance for (Data.String.IsString [a0])"
11:23:16 <zwer_s> you ran ghci with -XOverloadedStrings flag?
11:23:42 <stolaruk> ah, indeed I did
11:24:00 <zwer_s> so add a type signature.. concat ["abcd", "efgh"] :: [DesiredStringType]
11:24:13 <stolaruk> wow, good call. thanks!
11:24:21 <zwer_s> actually this: concat ["abcd", "efgh"] :: DesiredStringType
11:24:43 <stolaruk> right
11:25:48 <dmj`> stolaruk: you did :set -XOverloadedStrings ?
11:25:58 <stolaruk> yes
11:26:30 <dmj`> > concat ["hey", "there"] :: [String]
11:26:32 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Char‚Äô with ‚Äò[GHC.Types.Char]‚Äô
11:26:32 <lambdabot>  Expected type: [GHC.Base.String]
11:26:32 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‚ÄòGHC.Types.Char‚Äô with ‚Äò[G...
11:26:32 <lambdabot>  Expected type: [GHC.Base.String]
11:26:32 <lambdabot>    Actual type: [GHC.Types.Char]
11:26:34 <hask-> type Foo = String
11:26:35 <hask-> type Bar = String
11:26:36 <hask-> Can these two lines be combined somehow into one line?
11:26:41 <hask-> type Foo, Bar = String or something
11:27:31 <dmj`> stolaruk: did you try annotating it? concat ["a","b"] :: String
11:27:37 <dmj`> > concat ["a","b"] :: String
11:27:38 <lambdabot>  "ab"
11:27:42 <stolaruk> yes
11:27:54 <stolaruk> yeah I see what's hapenning now
11:27:55 <stolaruk> :)
11:28:06 * artyomkazak is almost sure that the answer to hask-'s question is ‚Äúno‚Äù, but is afraid to say it because what if it's wrong
11:28:26 <dmj`> stolaruk: do tell
11:28:36 <mornfall> OverloadedStrings? :)
11:28:52 <dmj`> artyomkazak: don't worry I'll do it
11:28:55 <stolaruk> dmj`: Because OverloadedStrings is on, the type annotation is required.
11:28:56 <dmj`> hask-: no
11:28:58 <jp_rider> hey i have a question about template haskell/quasiquotation
11:28:59 <hask-> ok thanks
11:29:01 <artyomkazak> dmj`: thanks
11:29:07 * hackagebot helics 0.1.2 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.1.2 (HirotomoMoriwaki)
11:29:07 * hackagebot helics-wai 0.1.0 - New RelicÆ agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.1.0 (HirotomoMoriwaki)
11:29:16 <dmj`> stolaruk: oh of course :) I was thinking backwards
11:29:52 <jp_rider> In this tutorial (https://www.fpcomplete.com/user/marcin/template-haskell-101), they define `str = QuasiQuoter { quoteExp = stringE }`
11:30:15 <jp_rider> Why can they do that when there are multiple arguments to QuasiQuoter (http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH-Quote.html#t:QuasiQuoter)?
11:33:33 <skyflash> Can anyone point me at a haskell library for decoding TCP packets.  Specifically, I am getting whole IP packets and need to extract just the TCP payload (assuming the packet is actually TCP too).
11:34:04 <skyflash> I have the packing in a ByteString currently
11:34:07 <skyflash> packet
11:36:19 <c_wraith> skyflash: maybe the pcap lib? I'm not sure, but it's sort of close
11:37:24 <skyflash> c_wraith: Actually, I'm using pcap to get the packet in the first place :-)  AFAICS, there's no function to decompose the packet ByteString there, sadly.
11:37:49 <c_wraith> skyflash: drat.
11:38:04 <skyflash> c_wraith: double drat
11:41:44 <gigabytes> Hi everybody
11:42:05 <tdammers> hi
11:42:40 <gigabytes> Woh, it's been years since the last time on IRC
11:42:50 <gigabytes> joined again only for this channel
11:43:06 <gigabytes> another amazing haskell achievement :P
11:43:33 <c_wraith> I'm still confused how this channel has grown by 700 users in the time I've been here.
11:43:44 <Fuuzetsu> you're old
11:43:54 <c_wraith> shh.  that's classified information.
11:44:07 <gigabytes> I've already a question for you
11:44:09 <Fuuzetsu> oh, are you also a woman ;P
11:44:18 <geekosaur> it's grown by something like 1000 users since I found it
11:44:37 <geekosaur> then again ask shapr how much it's grown :p
11:45:06 <c_wraith> From shapr's point of view, it's nearly 1473 people more than when he first showed up
11:45:29 <gigabytes> I've installed haskell platform 2014 on OS X mavericks. I've installed some packages with cabal and now I have some dependency problem. In particular when I install ghc-mod or lambdabot or other packages I get the warning that some dependencies have to change version, and this could break the lens package
11:46:30 <jfischoff> gigabytes: since both ghc-mod and lambdabot are executables (I think)
11:46:34 <jfischoff> use a sandbox
11:46:45 <jfischoff> and copy the binary to somewhere on your path
11:46:48 <lpaste> gigabytes pasted ‚ÄúError installing ghc-mod (or others..)‚Äù at http://lpaste.net/112379
11:46:51 <kadoban> gigabytes: My way to deal with that is that instead of installing the platform, I just manually install ghc, cabal, and then I use sandboxes for almost everything.
11:47:13 <gigabytes> kadoban: I suppose that way is more flexible, yes
11:47:24 * Fuuzetsu mumbles something about nix
11:47:31 <kadoban> gigabytes: Another thing I'm looking at is Stackage, which sounds neat but I haven't tried yet.
11:47:49 <gigabytes> jfischoff: still have to learn how to use sandboxes
11:47:58 <kadoban> Or nix, but I don't think I'm ready to go all-in on that yet, hehe.
11:48:13 <gigabytes> jfischoff: do you have a one liner or so to resolve this immediate problem?
11:48:48 <jfischoff> mkdir lambdabot && cd lambdabot && cabal sandbox init && cabal install lambdabot
11:49:03 * hackagebot chatter 0.3.0.0 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.3.0.0 (RoganCreswick)
11:49:13 <jp_rider> FYI: http://stackoverflow.com/questions/20509739/record-syntax-for-quasiquoter-constructor
11:49:22 <jp_rider> apparently you can incomplete record definitions
11:49:47 <ClaudiusMaximus> > Just{}
11:49:49 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
11:50:04 <jp_rider> so I did that in ghci
11:50:20 <jp_rider> and saw the exception, so I thought it wasn't allowed lol
11:51:10 <c_wraith> jp_rider: the exceptions is from when ghci attempts to print the missing field
11:51:11 <gigabytes> thank you everybody
11:51:24 <jp_rider> right, makes sense
11:51:36 <jfischoff> gigabytes: you‚Äôre welcome!
11:51:47 <jp_rider> thanks!
11:52:33 <vjeranc> how would I shorten -> Data <$> get <*> get <*> get <*> get <*> get?
11:53:48 <jfischoff> vjeranc: if the types are different, it isn‚Äôt going to get much shorter.
11:54:14 <vjeranc> jfischoff: thanks, yep, they are, I guessed it couldn't get any shorter... :(
11:59:03 * hackagebot hopenpgp-tools 0.12 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.12 (ClintAdams)
12:01:57 <hask-> if a binary function is in a module, like T.append
12:02:10 <hask-> should I do T.`append` or `T.append` to infix it?
12:02:18 <jp_rider> i think the latter
12:02:40 <gigabytes> just a little other question of another kind
12:02:46 <gigabytes> I'm playing with lenses
12:03:20 <gigabytes> Ho can I express this map using traversals/lenses/prisms/dunno? (map (view varType) (problem^.objects))
12:03:38 <gigabytes> varType and objects are lenses of course
12:03:50 <gigabytes> problem^.objects.what.varType
12:03:59 <jfischoff> mapped I think
12:04:56 <jfischoff> um maybe not
12:05:18 <gigabytes> no it doesn't work, already tried
12:06:03 <NemesisD> i'm experiencing some issues with cabal where when a version number isn't tightly bound it tries to get the latest and if the dependencies don't work out, stops rather than falling back to an older verison that *definitely* works
12:06:11 <NemesisD> has anyone else had that happen?
12:06:46 <NemesisD> if i hint at it by modifying the cabal file to a version that I know works, it proceeds
12:08:02 <dcoutts> NemesisD: try with --max-backjumps=-1
12:08:14 <pjdelport> vjeranc: You can define: liftGet5 f = f <*> get <*> get <*> get <*> get <*> get
12:08:24 <pjdelport> And so on, for the other arities
12:08:32 <dcoutts> NemesisD: did you mean it fails to find a solution, or it goes ahead and the compilation fails?
12:08:48 <pjdelport> vjeranc: And then you can state the above as liftGet 5 Data
12:08:56 <pjdelport> err, liftGet5 Data
12:09:03 * hackagebot ref-fd 0.3.0.4 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.3.0.4 (GeoffreyMainland)
12:09:04 <NemesisD> dcoutts: it fails to find a solution
12:09:14 <SrPx_> >> "test"
12:09:20 <jfischoff> gigabytes: maybe ^..objects.folded.varType ?
12:09:28 <dcoutts> NemesisD: ok, then try with --max-backjumps=-1
12:09:28 <SrPx_> > "test"
12:09:30 <lambdabot>  "test"
12:09:47 <gigabytes> jfischoff: dunno... folded wouldn't be something more similar to foldr than map?
12:10:00 <vjeranc> pjdelport: yep, I guess that could be done... still, I was thinking of a replicate 5 get, approach but types matter here :D
12:10:07 <gigabytes> anyway I don't know what is the ^.. operator? I only know ^.
12:10:15 <merijn> dcoutts: I have a cabal question
12:10:20 <jfischoff> its in the Fold module
12:10:44 <jfischoff> gigabytes: good luck, have to run
12:10:51 <gigabytes> thanks
12:11:05 <merijn> dcoutts: Basically, I have tests that depend on non-haskell code, now I can just create a pre-test hook to build that code using make, but I don't have to way to pass the right configure arguments to make from cabal, I think?
12:11:10 <NemesisD> dcoutts: so i have websockets >= 0.8.2 && < 0.9, and an unqualified websockets-snap. it exhaustively goes through all websockets versions < 0.9 and fails because the *latest* websockets-snap depends on websockets ==0.9, but it doesn't try to walk backwards through websocket-snap versions
12:11:29 <merijn> dcoutts: i.e., I need to specify some library paths to pass to make to be able to build
12:11:35 <NemesisD> this is with max backjumps -1
12:12:28 <NemesisD> dcoutts: its like it converts build-depends websockets-snap into build-depends websockets-snap 0.9.0.0 (the latest)
12:13:25 <SrPx_> @pl (\a -> splitAt (elemIndex 5 a) a)
12:13:26 <lambdabot> splitAt =<< elemIndex 5
12:13:30 <SrPx_> ./\ why?
12:13:36 <merijn> NemesisD: Maybe something is fixing your websockets-snap version?
12:13:44 <merijn> SrPx_: Reader monad
12:13:57 <merijn> SrPx_: ((->) r) is a monad
12:14:30 <NemesisD> merijn: ah so i guess i could pull the thread and start forcing specific versions until cabal reveals the culprit
12:14:51 <Fuuzetsu> friendly notification that if you're using 123-reg, you should probably jump ship
12:15:15 <Fuuzetsu> ‚Ä¶meant to go in -blah
12:15:15 <SrPx_> (->) ?
12:15:19 <SrPx_> :t (->)
12:15:20 <lambdabot> parse error on input ‚Äò->‚Äô
12:15:28 <Fuuzetsu> :k (->)
12:15:29 <lambdabot> * -> * -> *
12:15:57 <SrPx_> ... hm.
12:16:20 <YurasS> NemesisD: works for me. cabal freeze selects websockets ==0.8.2.6 and websockets-snap ==0.8.2.2
12:17:26 <merijn> SrPx_: As in the function type
12:17:47 <merijn> :t (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
12:17:48 <NemesisD> now its claiming io-streams==1.2.0.0 is a dependency of my library, when it is not directly mentioned in the cabal file
12:17:49 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
12:17:52 <YurasS> NemesisD: that is empty cabal file with only base, websockets >= 0.8.2 && < 0.9 and websockets-snap deps
12:18:22 <YurasS> NemesisD: snap server IIRC depends on io-streams now
12:19:04 * hackagebot ref-tf 0.3.0.3 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.3.0.3 (GeoffreyMainland)
12:19:20 <YurasS> ah, and websockets are based on io-streams
12:19:34 <SrPx_> hmm..
12:19:35 <YurasS> show your cabal file
12:20:08 <NemesisD> i'm going to have to figure this out myself, i don't think i can do that
12:22:54 <pjdelport> SrPx_: With Reader, you can interpret each value as a function of a shared environment. When you combine multiple values using Functor / Monad, each part has the environment applied to it, before proceeding normally.
12:23:14 <vjeranc> how does one find the proper ranges of versions for the "build-depends:" .cabal section? Should I do ternary search myself or is there some better way? I've been reading on cabal and all the docs just skip that part.
12:24:34 <pjdelport> SrPx_: So for example, (+) <$> square <*> square produces a function that doubles the square of something, like \e -> square e + square e
12:24:37 <merijn> vjeranc: Trial and error
12:24:43 <merijn> vjeranc: Travis CI, etc.
12:25:08 <merijn> vjeranc: There are GSoC plans to write "bounds testing tools", but no such thing exists yet
12:25:08 <SrPx_> pjdelport: so "splitAt =<< elemIndex 5" produces a function that receives an environment, "a", feeds that environment to "elemIndex 5", and then feeds *that" to splitAt?
12:26:25 <pjdelport> SrPx_: Right, exactly. :) But more specifically, it expects splitAt to produce *another* function of the environment, which then has the environment applied to it as well.
12:27:56 <pjdelport> So in general, f =<< x for Reader will "feed" the environment to x, then apply f to the result, and then feed the environment to that again.
12:28:24 <SrPx_> ah sure, I get it. thanks
12:28:25 <shapr> c_wraith: yes, all the users :-)
12:28:27 <SrPx_> @pl (\x -> (h (f (g x) x) x))
12:28:27 <lambdabot> h =<< f =<< g
12:28:35 <pjdelport> So f =<< x  ‚Üí  \e -> (f (x e)) e
12:29:17 <SrPx_> is this a thing for functions specifically or for other datatypes too?
12:29:34 <vjeranc> merijn: oh well, does that mean that one cannot assume that package versions are like a convex function __--__ where one searches for the bounds of the correct compilation?
12:30:35 <pjdelport> SrPx_: That's specifically for Reader e, or (e ->)
12:31:19 <pjdelport> (Or "(->) e" for the latter, in actual Haskell)
12:31:36 <RyanGlScott> Are there any significant API changes between time-1.4 and -1.5?
12:31:45 <pjdelport> SrPx_: Other Functors /  Monads have their own interpretations.
12:33:15 <pjdelport> SrPx_: Although, if you squint enough, you can see how the above is analogous to how functors/monads like IO actions also work.
12:33:26 <pjdelport> Consider putStrLn =<< getLine
12:34:18 <pjdelport> You can in some sense look at that as: \magic -> (putStrLn' (getLine' magic)) magic
12:34:40 <pjdelport> Where "magic" is a magic value that enables those functions to perform their effects.
12:34:54 <SrPx_> which is where the actual IO happens
12:35:33 <pjdelport> Right; in the RealWorld state-threading approach, the RealWorld token is not too dissimilar to the above.
12:35:42 <pjdelport> (But don't look too closely at the analogy. :)
12:37:14 <hask-> c_wraith: are you still around?
12:37:59 <SrPx_> hmm
12:40:41 <hask-> I have a function with a map as a parameter:
12:40:41 <hask-> boom :: (Map.Map String String) -> Whatever
12:40:42 <hask-> boom map = ...
12:40:43 <hask-> Problem: It warns about "map" already existing (plus by text editor color codes it differently). What should I name the map parameter? Just "m", or "theMap", or "ourMap"? What is the Haskell convention?
12:42:35 <kadoban> hask-: Haskell tends to use pretty short names, so 'm' might be acceptable, especially with some documentation
12:42:45 <kadoban> short function argument names at least
12:42:56 <hask-> or maybe just "mp"
12:43:23 <YurasS> hask-: replacements? params? model (if it is related to templates)
12:43:34 <artyomkazak> or maybe use a descriptive name instead of a shortening of the datatype name
12:43:55 <hask-> ok, thanks for the ideas
12:43:57 <hask-> makes sense
12:45:06 <pjdelport> hask-: Another common disambiguator is '
12:45:12 <pjdelport> boom map' = ...
12:45:20 <hask-> pjdelport: i thought that was mostly for function names
12:45:23 <hask-> not function params
12:45:35 <pjdelport> hask-: It's usef for things like x' and xs' all the time too :)
12:45:38 <pjdelport> used, even
12:45:42 <hask-> ok thx
12:47:01 <merijn> Or the lovely can'tHappen variable ;)
12:47:14 <artyomkazak> well, but I'd say ¬´x'¬ª means ¬´changed x¬ª
12:47:27 <merijn> > let can'tHappen = 1 in can'tHappen + can'tHappen
12:47:29 <lambdabot>  2
12:49:05 * hackagebot srcloc 0.4.1 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.4.1 (GeoffreyMainland)
12:49:10 <hask-> I just wrote my first real-world Haskell code. Feeling proud.
12:50:33 <SrPx_> Is there any faster way to convert strings to ints, other than read?
12:51:24 <hask-> What is a good name for a function that takes a template String and fills in the template to return a new String? fillTokens?
12:51:35 <hask-> fillTokens? fillTemplate? completeTemplate?
12:52:21 <HeladoDeBrownie> hask-, if you use fillTokens, make sure your documentation is clear what "token" means
12:52:31 <hask-> ok
12:52:49 <artyomkazak> > foldl' (\x y -> x*10 + y) 0 $ map digitToInt "123"
12:52:51 <lambdabot>  123
12:52:52 <HeladoDeBrownie> I guess in that case I'd recomment fillTemplate
12:52:56 <HeladoDeBrownie> recommend*
12:53:01 <YurasS> hask-: render
12:53:07 <artyomkazak> SrPx_: see above
12:53:22 <hask-> YurasS: ah that's good
12:54:05 * hackagebot symbol 0.2.2 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.2.2 (GeoffreyMainland)
12:54:07 * hackagebot symbol 0.2.3 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.2.3 (GeoffreyMainland)
12:54:21 <joelteon> ooh i wonder what's new in 0.2.3
12:55:42 <hask-> What should be the order of functions in a .hs file? What's the convention? Should utility functions come first, and then functions that rely on earlier functions come later?
12:55:45 <hask-> or the other way around?
12:56:32 <YurasS> I found Data.Aeson.Types.Parser very useful outside aeson. Is there anything similar in separate package?
12:56:38 <YurasS> this one: http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson-Types.html#t:Parser
12:56:53 <Fuuzetsu> hask-: whatever you feel like
12:57:00 <hask-> ok
12:57:17 <joelteon> YurasS: haskell has about 30 parsing libraries
12:57:25 <Fuuzetsu> hask-: if you want to present them to the user somehow in a special way, Haddock will present them in the order they appear in in the export lib, including headers and all
12:57:38 <Fuuzetsu> (or as they come if no export list is given)
12:57:47 <hask-> ok
12:57:51 <hask-> thx
12:57:54 <prophile> you can write a mostly-functional parser type in 4 lines in haskell so everyone and their dog has written a parser library
12:58:19 <joelteon> you can use attoparsec, or parsec, or trifecta, or polyparse
12:58:21 <MagneticDuck> hask-: I generally name my functons as successive primes of f (ex. f, f' ... f'''') and then include documentation as a unicode text file with an absurd and obscure encoding and lots of special characters
12:58:27 <MagneticDuck> but that might just be me
12:59:12 <kadoban> MagneticDuck: XD
12:59:32 <YurasS> joelteon: I want FromBSON type class. Aeson's Parser is very good here
12:59:52 <YurasS> joelteon: it is not like regular parser for token stream
13:00:30 <kadoban> hask-: Personally I like having the functions/whatever that I'm actually interested in first, then the helper functions down below. That way, if my functions are documented/self-documenting well enough, people don't need to wade into the details unless they want to.
13:01:06 <joelteon> it's like let vs where
13:01:14 <hask-> kadoban: yeah i like that approach
13:01:43 <SrPx_> artyomkazak: hm thanks, but how is that faster?
13:01:45 <SrPx_> are you sure?
13:02:22 <MagneticDuck> hask-: now seriously, I personally have a approch where I have constructors, mutators, combinators, and accessors in their seperate sections
13:02:36 <MagneticDuck> (at least when I'm doing data-structure heavy related stuff)
13:02:49 <MagneticDuck> but I don't think my approach is very mainstream
13:02:51 <YurasS> joelteon: no, aeson uses two separate parsers for good reason
13:03:07 <YurasS> joelteon: the first comes from attoparsec
13:03:07 <artyomkazak> SrPx_: one has to check to be sure
13:03:09 <joelteon> okay, use one of aeson's parsers
13:03:43 <YurasS> joelteon: that is ok except aeson is too heavy dep :)
13:04:01 <joelteon> okay
13:04:05 <joelteon> copy aeson's parser into your source code
13:04:16 <MagneticDuck> oh, and lenses make the constructor and accessor sections redundant x|
13:05:03 <joelteon> X)
13:06:12 <YurasS> joelteon: that is objective-c way )))))
13:06:32 <joelteon> your package will indirectly depend on aeson anyway, it doesn't really matter
13:07:34 <artyomkazak> SrPx_: yeah, my variant is 17√ó faster
13:07:41 <artyomkazak> http://lpaste.net/112384
13:07:48 <kadoban> MagneticDuck: If it isn't it should be, that sounds nice.
13:08:34 <artyomkazak> [added an annotation]
13:09:44 <artyomkazak> beware, it doesn't read negative ints
13:10:44 <Fuuzetsu> read "2053e7" :: Int
13:10:51 <Fuuzetsu> > read "2053e7" :: Int
13:10:53 <lambdabot>  *Exception: Prelude.read: no parse
13:10:57 <Fuuzetsu> didn't think so
13:11:10 <Fuuzetsu> aren't there plans for hex/binary notation?
13:11:11 <SrPx_> cool way to bench, thanks artyomkazak
13:11:28 <joelteon> > 0x2053e7
13:11:29 <artyomkazak> > read "0x10" :: Int
13:11:30 <lambdabot>  2118631
13:11:31 <lambdabot>  16
13:11:34 <recursion-ninja> > read "0xC4" :: Int
13:11:36 <lambdabot>  196
13:11:36 <Fuuzetsu> oh, that's right
13:11:46 <joelteon> what do you want, implicit hex?
13:11:48 <Fuuzetsu> I think I used it like once, can you tell?
13:11:48 <joelteon> what is this, javascript?
13:11:59 <kadoban> I thought you were going for scientific notation, haha
13:12:06 <Fuuzetsu> spoiler: I was
13:12:26 <artyomkazak> I think it actually worked before
13:12:44 <Fuuzetsu> joelteon: does JS actually do implicit hex
13:12:50 <joelteon> no, octal
13:12:52 <artyomkazak> and was changed because ¬´read "1e100" :: Integer¬ª ate all memory
13:13:20 <kadoban> artyomkazak: Lol
13:13:40 <artyomkazak> https://ghc.haskell.org/trac/ghc/ticket/5688
13:13:51 <Fuuzetsu> you sure? because I don't think one was ever able to write 1e100 and that would imply read . show ‚â† id
13:14:25 <artyomkazak> ouch, not 1e100, of course
13:14:47 <artyomkazak> more zeroes
13:15:14 <artyomkazak> oh, and also see https://github.com/bos/aeson/issues/198
13:15:25 <joelteon> qqqqqqqqq
13:15:31 <joelteon> sory
13:15:33 <joelteon> accident
13:15:52 <joelteon> wow, apparently ^M is enter whereas ^W is delete word, and they're right next to each other
13:15:54 <MagneticDuck> ppppppppp
13:16:47 <Fuuzetsu> joelteon: M is just W upside down so it makes sense to be close by
13:19:31 <alem0lars> ping
13:23:48 <recursion-ninja> > (read "B2") * (read "0xC4") :: Int
13:23:49 <phaskell> B2: Diff 88 - https://phabricator.haskell.org/B2
13:23:50 <lambdabot>  *Exception: Prelude.read: no parse
13:23:57 <recursion-ninja> > (read "0xB2") * (read "0xC4") :: Int
13:23:59 <lambdabot>  34888
13:24:07 * hackagebot chatter 0.3.0.1 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.3.0.1 (RoganCreswick)
13:24:57 <egasimus> I think I've finally found a DBus livrary that I know enough to use: http://hackage.haskell.org/package/udbus-0.2.1/docs/Network-DBus.html
13:25:08 <benmachine> Fuuzetsu: I have an old copy of ghci which does indeed read exponential notation into Integer
13:25:14 <benmachine> Fuuzetsu: only from strings though, not literals
13:25:18 <egasimus> But I can't figure out how to authenticate to the bus :(
13:25:42 <benmachine> Fuuzetsu: wouldn't imply read . show ‚â† id, just show . read ‚â† id, and that's generally true anyway
13:25:55 <benmachine> e.g. show (read "17.00" :: Float)
13:27:39 <Fuuzetsu> what version?
13:29:52 <egasimus> The library provides two authentication functions, authenticate :: DBusContext -> ByteString -> IO (); and authenticateUID :: DBusContext -> Int -> IO ()
13:30:11 <egasimus> I have no idea what to pass as the second argument of either
13:30:34 <MagneticDuck> read das docs
13:30:40 <MagneticDuck> (the german language docs)
13:30:45 <MagneticDuck> or even the english docs
13:30:55 <MagneticDuck> are there docs?
13:31:03 <MagneticDuck> let us find the docs
13:31:15 <egasimus> http://hackage.haskell.org/package/udbus-0.2.1/docs/Network-DBus-Actions.html
13:32:36 <MagneticDuck> hmmm
13:32:59 <MagneticDuck> you can always check the source
13:33:11 <MagneticDuck> in authenticate, the first arg is called "ctx" and the second "auth
13:33:12 <egasimus> MagneticDuck: sure, already did
13:33:54 <egasimus> Hmm, I think I came across what DBus authentication looks like
13:34:05 <egasimus> and it's kinda like those strings in authenticate
13:34:28 <egasimus> but how do I obtain a ByteString?
13:34:36 <MagneticDuck> Data.ByteString
13:34:51 <floresiensis> I've been optimizing with unsafe unboxed arrays but the performance is still very poor, about as bad as ruby. I would appreciate if someone would scan this for glaring mistakes; feedback on style also welcome. https://gist.github.com/anonymous/3f65e1073f43fa9f8dbe
13:34:58 <MagneticDuck> and Data.ByteString.Char8 for packing strings
13:35:14 <MagneticDuck> (assuming you want that encoding)
13:35:27 <egasimus> MagneticDuck: hmm, that'll probably do
13:35:40 <egasimus> and it does work with OverloadedStrings after all
13:35:52 <egasimus> it didn't seem to when I tried, but I think I tried wrong
13:35:54 <artyomkazak> egasimus: just in case, there are actually 3 functions
13:35:54 <egasimus> :D
13:35:57 <artyomkazak> authenticateWithRealUID
13:36:09 <artyomkazak> maybe this would be enough
13:36:25 <MagneticDuck> egasimus: there are as many ways to pack a string as there are ways to skin a cat
13:36:48 <MagneticDuck> uhm. well, the set of ways to pack a string is numerically equilivant to the set of ways to skin a cat
13:36:50 <MagneticDuck> probably
13:37:42 <egasimus> artyomkazak: ...oh shit :D
13:37:46 <egasimus> I hadn't seen that one.
13:38:21 * artyomkazak will one day find out what DBus is
13:46:14 <floresiensis> Generally speaking, shouldn't ghc with unsafe unboxed arrays perform better than ruby and python? It doesn't seem possible that ruby is beating ghc for the program above, but it's true.
13:48:23 <c_wraith> floresiensis: large mutable arrays interact badly with GHC's garbage collection system
13:48:29 <NemesisD`> i'm stuck in cabal hell. i don't understand how i can get (conflict: transformers-compat-0.3.3.4:three => transformers>=0.4.1 && <0.5) when the "three" flag here essentially says transformers == 0.3.* http://hackage.haskell.org/package/transformers-compat-0.3.3.4/transformers-compat.cabal
13:50:22 <floresiensis> c_wraith: the arrays are only of length 28, but there are many of them
13:50:40 <floresiensis> I guess that has the same issue
13:51:07 <geekosaur> floresiensis, that is pretty much the worst case in 7.8 and earlier, as I understand it
13:51:22 <geekosaur> I think 7.10 is supposed to handle many small mutable arrays much better
14:02:51 <_1_latosha> :D hi
14:03:30 <toors> cd /
14:03:37 <toors> oops
14:03:58 <_1_latosha> how old are you
14:04:06 <dfeuer> where ops
14:04:09 * hackagebot symbol 0.2.4 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.2.4 (GeoffreyMainland)
14:04:15 <josephle> @where ops
14:04:15 <_1_latosha> (L)
14:04:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:04:23 <_1_latosha> hi
14:04:42 <dfeuer> joseph07, I'm always forgetting how to do that.
14:04:44 --- mode: ChanServ set +o geekosaur
14:04:55 --- mode: ChanServ set +o dibblego
14:04:57 --- mode: dibblego set +b *!*WhatsChat@*.lightspeed.cicril.sbcglobal.net
14:05:04 --- kick: _1_latosha was kicked by dibblego (_1_latosha)
14:05:10 --- mode: geekosaur set +b _1_latosha!*@*
14:05:14 <geekosaur> whoops
14:05:24 * geekosaur meeting this week... slow
14:05:30 <geekosaur> and none of my helpers around
14:05:33 --- mode: dibblego set -o dibblego
14:05:34 <dfeuer> geekosaur, do you know who can set a network ban? I just got a pm from that ... whatever it is.
14:05:35 <joseph07> dfeuer: I think you mean josephle
14:05:43 <geekosaur> dfeuer, ask in #freenode
14:06:14 --- mode: geekosaur set -b _1_latosha!*@*
14:06:29 --- mode: geekosaur set -o geekosaur
14:06:39 <geekosaur> shoulda left it to someone else anyway
14:06:59 <MagBo> uhm, hey beautiful people.
14:07:04 <hask-> "Êãâ" prints out "\25289"
14:07:12 <hask-> what is this 25289?
14:07:33 <hask-> It doesn't match any number here: http://www.scarfboy.com/coding/unicode-tool?s=U%2Bf925
14:07:40 <MagBo> so I'm porting an activity tracker I wrote to haskell and I want to have a data structure that represents current activity
14:08:07 <SrPx_> I don't get this error: http://lpaste.net/112386
14:08:15 <hpc> > 0xf925
14:08:17 <lambdabot>  63781
14:08:27 <dfeuer> hask-, are you in the right base?
14:08:33 <hiptobecubic> MagBo, Sounds good.
14:08:37 <benmachine> > showHex 25289
14:08:37 <SrPx_> I thought getElems needed an `IO (IOArray Int Int)`, no?
14:08:38 <lambdabot>  <[Char] -> [Char]>
14:08:41 <benmachine> > showHex 25289 ""
14:08:42 <lambdabot>  "62c9"
14:08:44 <SrPx_> what is that `a0 i0`
14:08:51 <MagBo> interestingly enough, my weapon of choice during building activity data structure while parsing strings returned from system calls was... Control.Lens
14:08:55 <hask-> dfeuer: i tried some conversions but didn't match anything
14:09:03 <hpc> benmachine: ooh, good catch
14:09:05 <hpc> http://www.scarfboy.com/coding/unicode-tool?s=U%2B62c9
14:09:06 <MagBo> then I found this ‚Äî http://ro-che.info/articles/2014-04-24-lens-unidiomatic
14:09:18 <MagneticDuck> _1_latosha got kicked because he asked "how old are you"?
14:09:21 <MagneticDuck> maybe he was just lost
14:09:27 <MagneticDuck> thought this was #howoldareyou
14:09:31 <hpc> the two are almost the same glyph
14:09:37 <benmachine> MagneticDuck: by the sounds of it some people got PM'd
14:09:42 <MagneticDuck> ahk
14:10:01 <MagBo> so, people of #haskell, what would you do if you had to make a haskell data structure from strings we get from system calls trough our parsers
14:10:11 <MagBo> MagneticDuck: hey, buddy! <3 ##starcraft misses you </3
14:10:13 <benmachine> MagBo: lens is controversial, but I'm pretty fond of it
14:10:39 <stephenmac7> What are type holes for?
14:10:51 <MagneticDuck> MagBo: :0
14:11:01 <MagneticDuck> MagBo: :D:D:D
14:11:05 <MagBo> MagneticDuck: you're the same magnetic duck I think, right?
14:11:13 <MagneticDuck> yes
14:11:13 <MagBo> Haskell dude
14:11:21 <MagneticDuck> as long as you are the same MagBo I think
14:11:34 <mm_freak> hi there
14:11:41 <MagneticDuck> what brings you here to #haskell?
14:11:49 <MagneticDuck> oh and we should probably go somewhere else
14:11:50 <josephle> stephenmac7: it makes programming haskell a video game. But more seriously, it allows you to figure out the types of subexpressions in your code
14:11:53 <mm_freak> a question =)
14:12:11 <stephenmac7> josephle: Could I have an example?
14:12:58 <mm_freak> the question is:  can i embed taffybar into an application as a haskell thread without automatic configuration reloading?
14:13:11 <SrPx_> nobody? :(
14:14:15 <SrPx_> oh nvm got it
14:15:09 <josephle> :t map _ ([1,2] :: [Int]) :: [Char]
14:15:11 <lambdabot>     Found hole ‚Äò_‚Äô with type: Int -> Char
14:15:11 <lambdabot>     In the first argument of ‚Äòmap‚Äô, namely ‚Äò_‚Äô
14:15:11 <lambdabot>     In the expression: map _ ([1, 2] :: [Int]) :: [Char]
14:15:34 <josephle> stephenmac7: ^ obviously this is a trivial example, but that would be how you use a typed hole
14:16:12 <stephenmac7> josephle: I see.
14:17:16 <josephle> stephenmac7: you can use typed holes to aid you in writing more complicated expressions
14:17:36 <stephenmac7> Thank you. Looks like it could be helpful in the future... just like undefined
14:22:11 <jle`> it acts like undefined, except you actaully can get what type ghc expects :)
14:22:18 <jle`> before i would do something like (undefined :: Int)
14:22:28 <jle`> and wait for an error like cannot match Int with expected type blah
14:23:18 <hask-> How can I find what to put after "cabal install" to install this? http://hackage.haskell.org/package/MissingH-1.0.0/docs/Data-String-Utils.html
14:24:06 <detrumi> jle`: That's really smart, hadn't thought of that
14:24:32 <jle`> this is a little more elegant  now :P
14:24:47 <detrumi> I was always annoyed that it didn't give a type mismatch error with undefined
14:25:54 <SrPx_> What is the fastest/simplest way to convert a mutable array (IOArray Int Int) into a pure array (Array Int Int)
14:25:55 <hexagoxel> hask-: cabal install MissingH-1.0.0
14:25:56 <detrumi> It is, but it doesn't let you compile it like undefined does
14:26:00 <hexagoxel> hask-: but that is not the latest version
14:26:09 <hask-> hexagoxel: but how did you find this out?
14:26:15 <hask-> which package corresponds to this
14:26:32 <hexagoxel> hask-: look in URL, after /package/
14:27:01 <hask-> hexagoxel: ok cool, so "cabal install MissingH"
14:27:19 <hexagoxel> hask-: or click on "context" on the upper right
14:27:27 <hexagoxel> *contents
14:27:34 <hask-> hexagoxel: thanks!
14:28:06 <hask-> Oh crap, that package is marked Beta
14:28:11 <hask-> this means I shouldn't use it?
14:28:20 <lpaste> thsig pasted ‚Äúcabal update error‚Äù at http://lpaste.net/112387
14:28:25 <thsig> hey guys
14:28:42 <thsig> I'm running into this error when trying to update cabal
14:29:10 * hackagebot hoogle-index 0.3.1 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.3.1 (BenGamari)
14:29:11 <thsig> been reading up on Haskell for a few weeks and decided to write a simple program to get started!
14:29:17 <greencyborgsalmo> Trying to set up a hackage mirror and getting 'hackage-mirror: Failed to download the package upload log, HTTP error code 404, Not Found, http://hackage.haskell.org/packages/archive/log' using https://github.com/haskell/hackage-server
14:29:20 <thsig> unfortunatly I don't have much experience with the Haskell toolchain
14:29:28 <thsig> is this something that's trivial to resolve?
14:29:39 <thsig> (see the paste above)
14:30:38 <lpaste> thsig revised ‚Äúcabal update error‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/112387
14:32:07 <SrPx_> Can arrows replace monads for everything they're used?
14:32:31 <prophile> with ArrowApply yes, but that's not generally a great idea
14:33:49 <hexagoxel> hask-: depends on the type of project i guess - i'd just try it
14:34:15 <hask-> hexagoxel: I mean, are packages on Hackage generally trustworthy, or can any random idiot out there upload packages to this?
14:34:33 <hexagoxel> related question: is there any definition to the items used as "stability" of packages? what is beta/alpha/experimental/provisional?
14:34:43 <joelteon> *nondeterministic idiot
14:36:43 <hexagoxel> (hmm http://stackoverflow.com/questions/3841218/conventions-for-stability-field-of-cabal-packages)
14:38:46 <hexagoxel> hask-: i think anyone can get hackage account. but if there is ~20k total downloads for the package..
14:39:10 <hask-> yeah
14:39:10 * hackagebot ref-tf 0.4 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.4 (GeoffreyMainland)
14:39:12 * hackagebot ref-fd 0.4 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.4 (GeoffreyMainland)
14:39:12 <hexagoxel> but true, you might wanna be careful otherwise
14:39:57 <egasimus> Okay, so I know I asked the same question on here not too long ago but I can't figure it out in the vocabulary of this library:
14:40:55 <egasimus> I do a DBus call and end up with a DBusValue which shows as `DBusVariant (DBusString "the string I need")`
14:41:00 <egasimus> (this is the library: http://hackage.haskell.org/package/udbus-0.2.1)
14:41:51 <egasimus> and this looks relevant: https://github.com/vincenthz/hs-udbus/blob/30a28f89dd1015976a5b3448e3992ff83a747dc6/core/Network/DBus/Type.hs#L85
14:42:45 <egasimus> but what's the proper way of getting the DBusString out of the variant?
14:44:10 * hackagebot hindent 3.7 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.7 (ChrisDone)
14:45:23 <hexagoxel> (and if you really need security, downloads could be faked, so you need to "cabal get" and check source before installing)
14:46:11 <hexagoxel> (and cabal get still might not use https.. not sure)
14:46:52 <Clint> lispy: how does one deal with class constraints in happy?
14:46:56 <hask-> Would this be considered a good haskell code? https://pastee.org/s3q39  I'm there, in numChars, doing what ASSERT would do in other languages. Make sure both lists have the same length.
14:48:22 <crobbins> hask-: my problem with that is it is really hard to catch stuff like `error "..."`
14:48:51 <hask-> crobbins: are there better alternatives?
14:48:53 <hask-> to do asserts
14:49:02 <merijn> crobbins: Because error is not intended to be caught
14:49:17 <merijn> crobbins: THe solution is: Don't use error for control flow
14:49:36 <crobbins> merijn: right, kind of what i was getting at
14:49:43 <merijn> oh, maybe that should've been adressed to hask-, I missed the start of the conversation :)
14:50:07 <crobbins> hask-: it depends on what this is for.  i generally do assertions in tests, so using a test framework would be better in that case
14:51:31 <hask-> thanks
14:51:42 <asfp> does lambdabot support Text?
14:52:07 <merijn> Maybe?
14:52:15 <merijn> > Data.Text.pack "test?"
14:52:17 <lambdabot>  can't find file: L.hs
14:52:17 <prophile> yes, lambdabot supports Maybe
14:52:26 <merijn> > Data.Text.pack "test?"
14:52:28 <lambdabot>  Not in scope: ‚ÄòData.Text.pack‚Äô
14:52:41 <artyomkazak> geekosaur:
14:52:52 <artyomkazak> ouch, sorry
14:53:03 <asfp> > T.pack "test"
14:53:05 <lambdabot>  Not in scope: ‚ÄòT.pack‚Äô
14:53:05 <lambdabot>  Perhaps you meant ‚ÄòBS.pack‚Äô (imported from Data.ByteString)
14:54:54 <crobbins> should -fobject-code recompile template haskell in ghci?  seems it doesn't for me
14:58:09 <asfp> what does Text.groupBy do?  What is T.groupBy (\x y -> isUpper x || isLower y) "asdfasdfAsdfDsssssssDsfd"  supposed to do?
14:58:49 <merijn> :t Data.Text.groupBy
14:58:50 <lambdabot> (Char -> Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
14:58:59 <crobbins> > T.groupBy (\x y -> isUpper x || isLower y) "asdfasdfAsdfDsssssssDsfd"
14:59:01 <lambdabot>  Not in scope: ‚ÄòT.groupBy‚Äô
14:59:01 <lambdabot>  Perhaps you meant ‚ÄòBS.groupBy‚Äô (imported from Data.ByteString)
14:59:04 <crobbins> > Data.Text.groupBy (\x y -> isUpper x || isLower y) "asdfasdfAsdfDsssssssDsfd"
14:59:06 <lambdabot>  Not in scope: ‚ÄòData.Text.groupBy‚Äô
14:59:06 <lambdabot>  Perhaps you meant ‚ÄòData.List.groupBy‚Äô (imported from Data.List)
14:59:11 <merijn> asfp: It's just groupBy, but for Text
14:59:11 * hackagebot hackernews 0.1.0.1 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.1.0.1 (DavidJohnson)
14:59:19 <merijn> crobbins: lambdabot doesn't have Text
14:59:29 <merijn> > groupBy (<5) [1..10]
14:59:30 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Bool‚Äô with ‚Äòa -> GHC.Types.Bool‚Äô
14:59:31 <lambdabot>  Expected type: a -> a -> GHC.Types.Bool
14:59:31 <lambdabot>    Actual type: a -> GHC.Types.Bool
14:59:36 <merijn> eh
14:59:39 <merijn> hmm
15:00:33 <merijn> > groupBy (\x y -> x `mod` 5 == y `mod` 5) [1..10]
15:00:35 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
15:01:13 <merijn> > groupBy (\x y -> x < y && (x < 5 || y < 5)) [1..10]
15:01:15 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
15:02:16 <asfp> > groupBy (\x y -> isUpper x || isLower y) "asdfasdfAsdfDsssssssDsfd"
15:02:18 <lambdabot>  ["asdfasdf","AsdfDsssssssDsfd"]
15:03:36 <NemesisD> how should i interpret cabal saying "trying: aeson-0.7.0.6/installed-745... (user goal)". is it giving preference to installed packages?
15:03:45 <asfp> what is the comparison doing?  I don't find the documentation of groupBy very enlightening.
15:05:11 <merijn> asfp: The documentation tells you it's doing "group", but with a custom comparison
15:05:34 <hexagoxel> asfp: it takes the first element and goes through the rest, looking for an element that is different. then recurses. puts stuff that is "equal" by that definition into a list
15:05:40 <asfp> merijn: yes, but group doesn't document how the comparison function is called.
15:06:20 <hexagoxel> the asdfasd.. example works that way beacuse when the first isUpper is reached, every comparison afterwards returns 'equal'
15:07:25 <hexagoxel> the code is the documentation ..
15:07:26 <SrPx> Is there any structure like a C array of pointers to lists? That is, I want a container to hold lists, where accessing and modifying a list is O(1)
15:09:20 <Hafydd> O(1) independently of the number of lists? Not unless you're going to use ST or something.
15:09:34 <artyomkazak> @tell floresiensis your code becomes 5√ó faster if you switch to mwc-random, see here: https://gist.github.com/neongreen/7f76d78cdecf5f861b67/revisions
15:09:35 <lambdabot> Consider it noted.
15:09:44 <asfp> hexagoxel: right, the code in Data.List is 100x more readable though, so reading that code is almost cheating.
15:10:54 <SrPx> Hafydd: yes, with ST. There is a fixed number of lists.
15:11:12 <merijn> asfp: "How it's calling the comparison function" -> sequentially, as the mississipi example illustrates
15:13:48 <Hafydd> SrPx: (STRef, STRef, STRef, ...)?
15:14:20 <SrPx> Hafydd: huh fixed at construction time, not compile time
15:14:41 <SrPx> (if I understand what STRef is, I've never used it)
15:14:43 <Hafydd> Oh... well, are you aware of STArray?
15:15:05 <SrPx> yes I'm trying it but seems like it is just for primitive values such as int etc
15:15:11 <SrPx> let me double check
15:15:40 <SrPx> ah nevermind, d'oh. thanks
15:15:53 <SrPx> aaand... it works
15:16:28 <acowley> I'm confused about the state of the Reflection Without Remorse work. Is there working code anywhere?
15:16:34 <Hafydd> Perhaps you were thinking of STUArray.
15:16:56 <SrPx> indeed, I read about it earlier and it stuck on my head
15:17:33 <SrPx> I also noticed I can use an immutable array in the middle of an algorithm and actually return a pure value. for some reason I thought that was impossible, lol. so glad
15:17:36 <SrPx> mutable*
15:19:39 <Hafydd> StuArray: http://i5.minus.com/iz50i3kqBknoz.jpg
15:20:41 <Yxven> Does that mean it's using unsafePerformIO underneath SrPx?
15:21:14 <merijn> Yxven: No
15:21:28 <merijn> Yxven: ST can have mutable values that are returned in a pure context
15:21:36 <MagBo> People-people, I have a chain of binds and I want to putStrLn something in the middle of it
15:21:43 <MagBo> how do I do that? :)
15:21:44 <merijn> MagBo: Debugging?
15:21:57 <MagBo> merijn: just playing with stuff
15:22:27 <merijn> MagBo: There's Debug.Trace for debugging, but it's not to be trusted for "real" code
15:22:35 <merijn> MagBo: By chain of binds you mean ">>="?
15:22:38 <MagBo> yes
15:22:42 <jle`> MagBo: can you post an example?
15:22:45 <MagBo> I don't use do notation yet
15:22:51 <Hafydd> Change m1 >>= f1 >>= ... >>= fN to m1 >>= f1 >>= putStrLn s >>= ... >>= fN, surely.
15:23:01 <Hafydd> Er...
15:23:02 <merijn> "foo >>= \x -> putStrLn "blah" >> return x" ?
15:23:03 <Hafydd> Well, not quite.
15:23:07 <MagBo> https://gist.github.com/anonymous/4fe93d67a1602f181d00
15:23:27 <MagBo> I want to print (words s) where question marks are
15:23:32 <merijn> MagBo: I support this decision to avoid do notation for a while, it makes do notation a lots less confusing when you switch :)
15:23:57 <merijn> :t (>>)
15:23:58 <lambdabot> Monad m => m a -> m b -> m b
15:24:12 * hackagebot machines 0.4 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.4 (EdwardKmett)
15:24:16 <merijn> MagBo: "print (words s) >> return (p (words s))"
15:24:41 <merijn> Where "x >> y = x >>= \_ -> y" :)
15:25:43 <merijn> Yxven: ST uses a really neat typing trick (which I'm not going to explain right now) to avoid mutations "leaking" outside of an ST action, resulting in actions that uses mutability internally, but allow the result of that mutability to change
15:25:48 <SrPx> so, I'm creating an IOArray, converting it to a list with `getElems` and then creating an Array from it, which is what I need. Is there any way to cut the middle man (the list)?
15:26:09 <SrPx> :w
15:26:11 <SrPx> sorry
15:26:29 <Yxven> merijn good to know
15:27:24 <Hafydd> SrPx: freeze, I believe.
15:27:24 <artyomkazak> @tell floresiensis also, you don't need unboxed arrays here, it performs just as well with strings
15:27:24 <lambdabot> Consider it noted.
15:27:54 <hask-> Can I define a "where" only for a single header guard |  ?
15:28:03 <hask-> err
15:28:06 <hask-> just guard, not header guard
15:30:16 <MagBo> merijn: but...
15:30:29 <MagBo> print will return IO (), right?
15:30:44 <philip_> (/help
15:30:48 <philip_> sorry
15:31:10 <Ouyang> is it normal for me to spend like 5 hours messing around with cabal per week?
15:32:36 <MagBo> Ouyang: no.
15:32:39 <acowley> Ouyang: Are you working on cabal itself? If so, then that's great! If not, then no that seems excessive :(
15:32:48 <MagBo> Ouyang: nixos.org
15:33:03 <Ouyang> No I'm just a begginner at haskell.  I'd rather not try nixos again as I've invested a bit in arch
15:33:03 <MagBo> Ouyang: nix-env -qaP '*' | grep -i haskell
15:33:17 <MagBo> Ouyang: yaourt -S nix
15:33:26 <acowley> Ouyang: What's taking up your time?
15:33:29 <MagBo> that's the beauty of nix!
15:33:44 <gilligan_> in case there are some vim users around that might be interested : https://github.com/gilligan/vim-textobj-haskell  : text object for top level bindings
15:34:01 <Ouyang> acowley, I'm trying to get into Yesod, and there seems to be the "if you give a mouse a cookie" scenario going on with failed packages
15:34:12 * hackagebot haskell-neo4j-client 0.2.1.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.1.0 (asilvestre)
15:34:46 <acowley> Ouyang: Well, yesod lives in a parallel world wrt the ecosystem
15:35:00 <acowley> Ouyang: You'd want to follow their instructions for using stackage, rather than hackage
15:35:37 <Ouyang> meaning I don't follow the commands provided in the book?
15:36:05 <acowley> I think just about 100% of the cabal problems I've heard of people having in the past year maybe are yesod actually, it's a complicated installation.
15:36:24 <acowley> Ouyang: I'm not familiar with it. I would have assumed following the book would be exactly the right thing to do!
15:37:06 <acowley> I think there's is a yesod IRC channel where they could help
15:37:07 <Ouyang> Yeah, but then I get stuff like javascript-language not needed, then I need to get happy/alex then another thing fails with yesod-platform and oh woe is me
15:37:11 <Ouyang> yeah sorry
15:37:39 <acowley> Eek
15:37:40 <MagBo> I'm still very confused with why did "print (words s)" work!
15:37:52 <acowley> I hope I didn't say something wrong there
15:39:12 * hackagebot haskell-neo4j-client 0.2.2.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.2.0 (asilvestre)
15:40:54 <MagBo> so yeah, back to my printing question
15:40:55 <MagBo> print (words s) >> return (p (words s))
15:41:00 <MagBo> why does it work? :)
15:41:07 <MagBo> :t (>>)
15:41:08 <lambdabot> Monad m => m a -> m b -> m b
15:41:43 <MagBo> so in our case m = IO
15:41:54 <MagBo> and as we can see
15:41:56 <MagBo> :t print
15:41:57 <lambdabot> Show a => a -> IO ()
15:42:09 <MagBo> print (words s) will yield IO ()
15:43:01 <HeladoDeBrownie> MagBo, are you answering your own question or is there something you're confused about there?
15:43:18 <MagBo> HeladoDeBrownie: I'm very confused with why does it work, yes.
15:43:22 <MagBo> thinking out loud
15:43:26 <MagBo> very slowly :D
15:43:27 <HeladoDeBrownie> MagBo, well, which part is confusing you?
15:43:44 <MagBo> I guess, the idea behind ">>"!
15:44:03 <HeladoDeBrownie> a >> b = a >>= \_ -> b
15:44:24 <MagBo> oh. so it's exactly for my case
15:44:38 <MagBo> just skips the arg for the lambda in bind
15:44:41 <HeladoDeBrownie> Yep
15:44:46 <MagBo> <3
15:44:52 <MagBo> awesome, now I get it.
15:45:00 <MagBo> funny, your colleague told the same thing
15:45:08 <MagBo> earlier. and I didn't get it.
15:45:45 <MagBo> it's very interesting how difficult haskell is even for the people who earn money with FP. :)
15:47:13 <seku> it is difficult. i still dont understand even the beginnings
15:47:23 <seku> but i am still intrigued by it. by a lot.
15:47:29 <seku> so i try and try and try
15:48:21 <Dashkal> I don't really find Haskell itself difficult, I do find many of the concepts you see often in this language to be maddenly difficult.
15:48:32 <Dashkal> Abstraction is hard on the brain
15:48:44 <hiptobecubic> it's not just that
15:49:02 <hiptobecubic> *enforced* purity is way different than pure by convention
15:49:48 <hiptobecubic> you have to design entire things to pass information around that you normally would just say "well fuck it" and call an IO performing function for
15:50:04 <Dashkal> That's definitely a mental shift that takes some getting used to
15:50:11 <hiptobecubic> Granted that often helps keep your program from becoming a mess
15:50:27 <hiptobecubic> But that last 5% has a big impact
15:50:38 <josephle> it's good design even in languages that don't enforce purity
15:51:07 <Dashkal> Yeah.  Once I got in the habit, my Scala code got better, since I push all the nasty IO to one place where I can keep a good eye on it.
15:51:22 <josephle> haskell just doesn't allow you to be negligent about these things
15:51:47 <seku> good teaching language then :)
15:54:05 <semigroup> Hi‚Äì I already asked this in the #yesod channel, but nobody answered. Anybody know of a way to get a SQL query generated by persistent (aside from the logging output?)
15:54:57 <seku> i think im stuck around higher order functions... i understand the concept, but no clue how it is to be applied
15:56:23 <josephle> seku: have you looked at the map and fold functions?
15:57:14 <Taneb> Anyone know of any big-ish Haskell events in the UK coming up soon>
15:58:16 <thsig> this is unexpected, I'm getting an error when running cabal install cabal-install on the newest version of the Haskell platform on OSX
15:58:28 <frihd> Taneb: not haskell-focused but codemesh and fpdays in Nov.
15:59:02 <dibblego> well, many projects take "pure by convention" as a fundamental, and that has worked well to some extent and it is not as different as is often made out. It does require a lot of otherwise extraneous effort though.
15:59:37 <Taneb> frihd++
16:00:28 <merijn> thsig: lpaste the error?
16:00:48 <jfischoff> dibblego: /me nods, a problem with ‚Äúby convention‚Äù many times
16:01:10 <Taneb> Hmm, I know a fair few Haskellers in York area, maybe I could organize one?
16:01:33 <merijn> Dashkal: I wouldn't say the concepts are maddeningly difficult, but I'll certainly grant you "maddeningly *different*"
16:01:34 <lpaste> thsig pasted ‚Äúcabal update error‚Äù at http://lpaste.net/112393
16:01:57 <lpaste> thsig revised ‚Äúcabal update error‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/112393
16:01:58 <merijn> thsig: Which GHC version?
16:02:14 <thsig> 7.8.3
16:02:22 <merijn> heh
16:03:10 <merijn> That's odd, I literally did that yesterday
16:03:15 <thsig> hmm
16:03:29 <thsig> could it have something to do with what version of the XCode command line tools is installed?
16:03:42 <thsig> that's the only thing I can think of breaking such a vanilla install, but then again I'm new to Haskell
16:03:44 <merijn> thsig: Can you run "cabal --version" and "ghc --version" and paste the result?
16:03:54 <marchelzo_> Can someone tell me how to parse some JSON with aeson where there is a JSON array of objects, and only some of the objects have the right fields that I want? I've never used aeson before. I read the examples on hackage but I still don't know what to do.
16:04:09 <merijn> thsig: And tell me your XCode command line version too while you're at it :)
16:04:28 <volty> read, test, discard
16:04:42 <marchelzo_> the JSON in question is here: https://a.4cdn.org/g/thread/44600364.json - I want to parse only the posts that contain images.
16:05:31 <lpaste> thsig pasted ‚ÄúNo title‚Äù at http://lpaste.net/112396
16:05:47 <thsig> also, I'm still on Mountain Lion!
16:05:53 <thsig> haven't updated to Mavericks yet
16:06:07 <thsig> I pasted the gcc version, is anything else from the command line tools relevant in this context?
16:06:23 <merijn> thsig: "xcode-select --version"?
16:06:42 <thsig> merjin: xcode-select version 2311.
16:06:42 <merijn> wait, what
16:06:46 <merijn> "cabal-install version 0.8.2"
16:06:53 <merijn> "using version 1.8.0.6 of the Cabal library"
16:06:56 <merijn> That's ANCIENT
16:06:56 <thsig> yeah, I just noticed that
16:06:59 <thsig> haha
16:07:03 <merijn> I'm pretty sure that's not the platform
16:07:06 <thsig> hmm
16:07:07 <merijn> Try "which cabal"
16:07:39 <merijn> Also, try "/usr/bin/cabal --version"
16:07:40 <thsig> merjin: /usr/local/bin/cabal, whereas ghc is in /usr/bin
16:07:49 <thsig> dunno why that's there
16:07:57 <thsig> might be shadowing the one that comes with the platform
16:08:29 <merijn> thsig: Old attempt at installing haskell? If /usr/local/bin is in your path before /usr/bin, that'll hide it
16:09:03 <Dashkal> merijn: Agreed.  I meant "diffuclt [to learn with preexisting background]" rather than difficult as in overly complex.
16:09:30 <thsig> yeah, I installed Haskell way back when I was reading Learn You a Haskell, afraid I've fallen deeper down the Haskell rabbit hole this time thus necessitating a fresh install :)
16:09:51 <thsig> merjin: Ok, I'll try removing it from there (thanks for the help btw! :) )
16:11:17 <merijn> thsig: I recommend nuking the following: ~/.ghc ~/.cabal and everything else you can find, then reinstalling platform
16:11:25 <merijn> There should be an uninstall script for the platform
16:11:32 <merijn> But I forget where (consult google)
16:12:11 <thsig> merjin: There's the uninstall-hs command
16:12:18 <thsig> ok, I'll nuke those
16:13:20 <MagBo> Hey, https://gist.github.com/anonymous/f260ed12d15bc127fe60
16:13:45 <MagBo> can anyone who used lens explain what am I doing wrong?
16:14:52 <benmachine> MagBo: you do not use . for field access like that
16:15:00 <benmachine> it composes lenses (being function composition)
16:15:51 <artyomkazak> and you also don't use += in pure code
16:16:02 <benmachine> I think instead of a.classes += x you want something like a & classes +~ x
16:16:02 <artyomkazak> you use +~
16:17:01 <Total_1mmersion> @pl \a b -> a >>= (\a -> f a b)
16:17:01 <lambdabot> (. flip f) . (>>=)
16:17:14 <MagBo> right, right, sorry.
16:17:17 <benmachine> 'classes +~ x' is a function that adds x to the classes lens, and a & f applies f to a
16:17:42 <Total_1mmersion> @pl \a b -> a >>= f b)
16:17:42 <lambdabot> (line 1, column 18):
16:17:43 <lambdabot> unexpected ')'
16:17:43 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
16:17:46 <Total_1mmersion> @pl \a b -> a >>= f b
16:17:47 <lambdabot> (. f) . (>>=)
16:19:50 <artyomkazak> MagBo: hm, actually, what do you mean by ‚Äú+=‚Äù? String concatenation?
16:20:26 <MagBo> artyomkazak: in case of parsing classes I mean list prepending
16:20:34 <MagBo> in parsing name I mean concatenation
16:20:49 <artyomkazak> then in parsing name you should use <>~
16:20:49 <benmachine> ah
16:21:10 <artyomkazak> and in list prepending ‚Äì %~ (x:)
16:21:30 <artyomkazak> (I think..? Is there a consing operator in lens?)
16:21:42 <benmachine> eh, you don't need one
16:22:05 <benmachine> if you find yourself asking that question, it's clearly not common enough that you should use it :P
16:24:49 <edwardk> artyomkazak: no consing operator
16:25:23 <MagBo> artyomkazak: much much much love
16:25:56 <MagBo> reading docs helps but it's so difficult to grasp everything
16:29:52 <thsig> merjin: Worked! Thanks :)
16:35:08 <SrPx> I installed haskellmode for VIM by cloning the repo into bundle, but its commands didn't show up. What could have happened ?
16:35:30 <lisbeth> I just spent three days pestering people in #bash trying to figure out how to run every command through a pipe, and they sent me over to #haskell cause they said haskell does that
16:37:10 <MP2E> Well, in Haskell you often compose functions, which is a concept very similar to piping the output of a program into the input of another program, but I'm not sure how far that analogy can take you :P
16:37:58 <HeladoDeBrownie> lisbeth, sounds like they were being facetious. That said, some people do actually use Haskell for shell scripting.
16:40:08 <lisbeth> I like the idea of using pipes for everything becuase in my mind that is the unix way
16:40:26 <benzrf> lisbeth: it is fun!!
16:40:26 <lisbeth> and haskell, so far, seems to do something very similar but without the need for a shell.
16:40:54 <MP2E> well, there is shelly for shell programming via Haskell https://github.com/yesodweb/Shelly.hs/blob/master/README.md
16:41:00 <benzrf> :t (^>>)
16:41:01 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
16:41:04 <benzrf> wwhaaaaaaaaaa
16:41:55 <lisbeth> If haskell works how I want I won't need a shell. Having a binary is more efficient than a shell script.
16:43:10 <lisbeth> I am reading this: http://learnyouahaskell.com/introduction#about-this-tutorial
16:43:20 <MP2E> that's a good place to start
16:43:21 <lisbeth> and: "Haskell is elegant and concise. Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs. "
16:43:26 <lisbeth> this is exactly what I want
16:44:15 * hackagebot hackernews 0.2.0.1 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.2.0.1 (DavidJohnson)
16:44:18 <MP2E> excellent, well it sounds like you're ready to begin the journey of Haskell :> at first it'll be a bit confusing, because haskell is quite different, but from the sounds of it, it could really resonate with you
16:44:46 <lisbeth> Is this mostly a *nix channel or are there alot of windows users, too?
16:45:02 <seku> winblows here. sshing into linux VMs tho
16:45:04 <Welkin> going back to an imperative language that relies on loops and conditionals feel so strange after working only in haskell for a while
16:45:09 <seku> or bsds.
16:45:33 <lisbeth> bsd is *nix because bsd is the proginy of unix
16:45:35 <seku> mhh... valkyria chronicles fan?
16:45:36 <HeladoDeBrownie> I get the impression most here develop Haskell on Linux, but there are some on Windows or OS X or others
16:45:45 <Welkin> seku: perhaps
16:45:56 <lisbeth> and what's a good place for Haskell libraries?
16:45:59 <seku> i could call myself Vyse then :)
16:46:05 <Welkin> I use both linux and osx
16:46:09 <HeladoDeBrownie> Hackage, which cabal-install interfaces to
16:46:23 <Welkin> never tried developing anything on windows
16:46:34 <seku> i admit im on-pff haskell for a year... still fascinated tho
16:46:43 <seku> too many hobbies.
16:47:02 <Welkin> it's not fun to do the same thing every day
16:47:06 <Welkin> change it up
16:47:17 <Welkin> haskell today, watercolor painting tomorrow
16:47:32 <Welkin> then snowboard the day after that
16:48:53 <seku> btw. we need a skies or arcadia remake
16:49:19 <lisbeth> oops, my codeblocks program doesn't seem to have a compiler for haskell
16:49:20 <seku> about haskell, i feel too stupid for it. still trying tho :)
16:49:27 <Welkin> lisbeth salander
16:49:57 <Welkin> lately I have been using xcode for ios development in swift
16:50:09 <Welkin> it is nice to have code completion and a linter built in
16:50:16 <Welkin> I never bothered to install hlint for emacs
16:50:47 <seku> i still need to get that emacs configured
16:50:51 <Welkin> code completion is pretty much required when working with such a verbose framework like ios
16:51:12 <seku> im not a developer, so that might explain things
16:51:44 <Welkin> emacs is a pain to set up
16:51:46 <seku> i make my money through... laugh at me. excel VBA scripts xD
16:51:51 <lisbeth> what's the standard haskell compiler called?
16:51:55 <Welkin> it tooks me a few days to learn my way around it
16:51:56 <seku> banking n stuff
16:52:00 <Welkin> and I still get stuck
16:52:04 <thsig> lisbeth: gcc
16:52:08 <lisbeth> orly? cool
16:52:10 <seku> haskell seems infinitely better and essentially funnier tho
16:52:29 <Welkin> lisbeth: ghc
16:52:34 <thsig> haha
16:52:35 <thsig> lol
16:52:41 <thsig> *facepalm*
16:53:06 <lisbeth> ok how do I get ghc in codeblocks?
16:53:12 <Welkin> seku: then you are use to declarative programming
16:53:12 <seku> yesh?
16:53:21 <Welkin> haskell has lot in common with excel
16:53:26 <Welkin> used to*
16:53:27 <seku> too many loops, too many fors, whatevs. yes
16:54:02 <seku> but im starting to grok recusrive functions, im having fun with bash
16:54:10 <Welkin> I'm too lazy to use anything but haskell now that I know it
16:54:18 <Welkin> haskell is good for lazy people
16:54:18 <seku> but im getting lost at functors, and how to use them :)
16:54:45 <HeladoDeBrownie> seku, unless you're writing rather abstract code, you mostly don't need to worry about Functors-as-a-whole and can deal with the individual instances.
16:54:48 <thsig> Welkin: Watched a presentation the other day from a guy who made a nice abstraction for spreadsheets (and cellular automata) using comonads
16:54:51 <Welkin> seku: did you read LYAH or Real World Haskell?
16:54:52 <HeladoDeBrownie> seku, e.g., how fmap on lists is map.
16:55:06 <seku> reading lyah and some university course
16:55:26 <seku> yeah, i saw fmaps results... i still need to read the code how it actually works tho
16:55:43 <seku> imho haskell is the way to the future... if only for parallel programming
16:55:49 <seku> that reason should be enough to want to learn it
16:56:05 <seku> parallelising pure functions, etc
16:56:12 <obiwahn> rust
16:56:16 <obiwahn> :O
16:56:33 <seku> dont tear me ower to the dark side :)
16:56:41 <lisbeth> I'm having trouble setting up my IDE to use haskell
16:56:47 <Welkin> I've been getting frustrated with swift because it is so much more complicated to perform simple things like partial application
16:56:48 <lisbeth> do you guys know any guides for doing that?
16:56:51 <Welkin> which are built in to haskell
16:57:12 <merijn> seku: Every instance of Functor specifies an implementation and when generating code the compiler selects the right instance based on the type where you use fmap
16:57:13 <seku> ok, that gives you away as haskeller .... "simple things like partial application"
16:57:15 <Welkin> it just feels broken because I can do certain things in haskell in one line that take several pages of custom code in swift
16:57:21 <merijn> :t fmap even
16:57:23 <lambdabot> (Functor f, Integral a) => f a -> f Bool
16:57:29 <merijn> hmm, bad example
16:57:33 <merijn> :t fmap isUpper
16:57:35 <lambdabot> Functor f => f Char -> f Bool
16:57:50 <merijn> :t fmap isUpper `asAppliedTo` (undefined :: [Char])
16:57:52 <lambdabot> [Char] -> [Bool]
16:57:56 <merijn> :t fmap isUpper `asAppliedTo` (undefined :: Maybe Char)
16:57:57 <lambdabot> Maybe Char -> Maybe Bool
16:58:08 <merijn> :t fmap isUpper `asAppliedTo` (undefined :: Either Int Char)
16:58:10 <lambdabot> Either Int Char -> Either Int Bool
16:58:25 <Welkin> my favorite partial application example is (+7)
16:58:27 <seku> in my very limited understanding, is it like polymorphism where for a different kind of integer, string, etc, i use a completely different function
16:58:37 <seku> or am i completely off
16:58:50 <HeladoDeBrownie> seku, that's mostly it, although it isn't limited to simply concrete types
16:58:51 <SrPx> okay would someone recommend me a good VIM plugin, since haskellmode-vim doesn't work here?
16:58:51 <merijn> seku: It is a form of ad hoc polymorphism
16:58:57 <MagBo> Okay, real-world question ‚Äî I need a "thread" or an actor that stores state of user activity and an actor that works with UI spawning pop-up or libnotify notification depending on the activity state and also provides a way to configure behaviour of the data derivation/aggregation on the run.
16:59:03 <MagBo> Is that a task for cloud haskell?
16:59:04 <HeladoDeBrownie> seku, assuming you mean type classes
16:59:11 <seku> yeah
16:59:11 <MagBo> How would you organize such a system?
16:59:28 <Welkin> lisbeth: what do you mean? Installing syntax highlighting?
16:59:30 <merijn> seku: [], Maybe and Either Int all have teir own isntance of Functor and when the compiler sees me apply "fmap isUpper" to [Char] it goes "oh, you want the [] instance of Functor"
17:00:02 <Welkin> lisbeth: I don't use an IDE. If I need to compile I use a shell.
17:00:03 <seku> slow down on me.. maybe is a monad isnt it
17:00:15 <MagBo> In Erlang it's trivial ‚Äî we just spawn three gen_servers and do stuff concurrently, organizing interoperation between entities with messages.
17:00:19 <merijn> seku: Those things are not mutually exclusive
17:00:23 <lisbeth> I'm not using an IDE, now
17:00:30 <Welkin> seku: all monads are functors
17:00:33 <lisbeth> decided against it
17:00:40 <merijn> seku: Maybe is a Monad, a Functor, an Applicative and more
17:01:33 <seku>  i guess i will need to take step by step
17:01:45 <Welkin> seku: that's the way to do it
17:01:56 <seku> i have some convoluted limited idea of what each is, but implementing them is a whole different shebang
17:02:08 <Welkin> seku: LYAH explains it pretty well
17:02:13 <Welkin> at least superficially
17:02:35 <merijn> Implementing your own instances is good practice
17:02:36 <Welkin> spend a few days going over the sections on functors, applicatives, and then monads
17:02:37 <benzrf> seku: to be precise, "all monads are functors" in the same sense that "all monoids are sets"
17:02:49 <seku> been reading that. but i feel like i need to take off a week from work to really concentrate on grokking it
17:02:55 <benzrf> seku: a monad is defined as a structure over an endofunctor
17:03:07 <Welkin> benzrf: too much jargon
17:03:16 <merijn> "class MyFunctor f where myFmap :: (a -> b) -> f a -> f b" and "instance MyFunctor Maybe where myFmap = ???"
17:03:39 <seku> too much for poor me.
17:03:48 <benzrf> oh
17:03:51 <benzrf> seku: do you know abstract algebra?
17:04:02 <seku> nothing at all. i am a stupid business major :)
17:04:06 <benzrf> ooh
17:04:11 <volty> yap, drown in their own over-pompous jargon ... :)
17:04:11 <Welkin> the only reason I started learning abstract algebra is because of haskell
17:04:16 * hackagebot haskell-neo4j-client 0.2.3.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.3.0 (asilvestre)
17:04:17 <benzrf> Welkin: same :p
17:04:19 <Welkin> but there are a lot of people here who started the other way around
17:04:32 <benzrf> seku: i guessed maybe you were familiar so i was trying to make an analogy
17:04:41 <benzrf> seku: sorry for confusing you
17:04:48 <seku> i thank you for the effort :)
17:04:52 <seku> glad for all help
17:05:28 <seku> the way i see it right now, i have higher order functions that can wrap around curried functions
17:06:09 <seku> and somewhere above that float elusive stuff like functors, applicatives, monads that can, being a function themselve, do IO, impure stuff in their context
17:06:17 <seku> thats the extent of my poor ideas.
17:06:46 <Dashkal> mmm, I should ask this here.  I've been exploring Comonads lately.  When writing the semicomonad (duplicate/extend without extract) for Maybe I found two implementations that both appear to be legal and I wonder if there's anything interesting in the difference.  It comes down to implementing duplicate.  duplicate = Just vs duplicate x@(Just _) = Just x; duplicate Nothing = Nothing.
17:06:49 <volty> how to pee ?  first of all one  has to classify it in a category (theory), than take it out out of the slip monad .....
17:06:58 <merijn> seku: Functions can't do impure stuff and the IO datatype is not impure either
17:07:19 <merijn> seku: Common misconceptions due to imprecise wordings used by people (on account of them being people)
17:07:34 <seku> i somehow imagine... wrongly probably that IO is just like a function argument for a monad
17:07:42 <benzrf> seku: an `IO a' is like a program that you could theoretically run that would output an a
17:07:47 <seku> and that a monad is a bit like a dispatcher
17:07:56 <benzrf> seku: Monad is an interface that many types have, including IO
17:08:02 <merijn> seku: A value of type "IO a" is "a computation that would produce an 'a' when run", but there is no way to "run" IO from within Haskell
17:08:09 <benzrf> seku: it happens to be a useful interface for sticking IO programs together to make more interesting ones
17:08:30 <volty> functions do pure pure stuff with pure data, and impure stuff with impure data -- to be honest
17:08:44 <merijn> The runtime system (i.e. "main"), gets run, but that's the only way to run IO actions
17:08:57 <benzrf> seku: basically you use Monad as a means of building up one big IO value representing the program and then leave it where ghc can find it
17:09:13 <benzrf> seku: the key point is that the only impure thing that can be involved is actually running an IO action
17:09:16 <benzrf> and you never do that
17:09:16 * hackagebot haskell-neo4j-client 0.2.4.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.4.0 (asilvestre)
17:09:19 <benzrf> only create them
17:09:19 <seku> read about that.. the idea of a "world state"
17:09:24 <benzrf> seku: ignore the world state thing
17:09:31 <benzrf> it's confusing and not applicable to actual usage
17:09:34 <benzrf> trust me
17:09:38 <merijn> Also, not actually true
17:09:43 <benzrf> ^
17:09:48 <seku> great news :)
17:09:51 <volty> monads are all about pushing  in / pulling out values --- for the sake of passing the enclosed values around
17:09:56 <merijn> Unless you're of the Copenhagen interpretation persuasion :)
17:10:15 <prophile> that rhymes
17:10:25 <volty> seku: more you dig in, more earth you will see above you :)
17:10:46 <seku> thats why i want to dig in
17:10:48 <prophile> volty: I would say monads are really only about pushing in values
17:10:57 <prophile> and comonads are about pulling out values
17:10:57 <seku> the pure part of haskell is very alluring
17:11:02 <volty> and when you need it ?
17:11:18 <volty> you have to pull it out
17:11:23 <merijn> seku: There is only a pure part (if we ignore the handful of functions who shall not be named)
17:12:24 <Welkin> I never noticed how messy it is to mix type information with executable code when using swift after having used nothing but haskell for several months
17:12:31 <seku> i thought about reading up on category theory as well, just did not manage to get around to it yet
17:12:33 <seku> wish i did
17:12:35 <volty> seku: for a better understanding, of the whole story (that goes well beyond ...),  i give you this comparison: pure people are idealists that produce little ... :)
17:12:37 <merijn> seku: Don't bother
17:12:47 <merijn> seku: Category Theory is near useless for learning haskell
17:12:54 <merijn> seku: Actually, probably worse than useless
17:13:17 <Welkin> merijn: it's certainly an interesting framework for thinking though
17:13:18 <volty> no no, it's all theory --- and nothing practical :)
17:13:20 <Dashkal> I disagree.  Category theory is good for getting a deeper understanding of the concepts involved.  It's not, however, required to grasp the related functions in Haskell
17:13:30 <volty> I agree with Welkin
17:13:39 <merijn> seku: Try this in ghci: "map print [1..10] !! 3"
17:13:54 <seku> ok, so first haskell, and if i want ... later category theory
17:13:55 <merijn> Dashkal: I don't think it's good for a deeper understanding of the concepts involved either
17:14:09 <merijn> You are much, much better of studying lambda calculus, System F and the lambdacube
17:14:24 <seku> need to start an esxi instance, one moment:)
17:14:40 <Dashkal> Well, given that the concepts are literally the category theory concepts in the category Hask...
17:14:48 <merijn> I wish people would stop promoting Category Theory so much (and I say this as someone learning Category Theory), it's has almost no relevance to Haskell
17:14:59 <volty> seku: do not let you entrapped by closed, pure, data // ask him how to show the third element of an unknown set / stream, from outside, from a file, from a state
17:15:01 <merijn> Dashkal: The category Hask is useless when it comes to writing code
17:15:10 <Dashkal> We disagree on this point
17:15:20 <Dashkal> I like to see the underlying patterns.  Helps reduce code duplication.
17:15:33 <Dashkal> And if there's one thing I hate when writing code, it's fixing the same bug in multiple locations
17:16:10 <merijn> So do I, but basic algebra like monoids and equational reasoning are several orders of magnitude more applicable for that than Hask is
17:16:43 <merijn> Give me one example where Hask has helped you reduce duplication/find a pattern
17:16:54 <Dashkal> The deeper you go, the deeper the pattern you can see.  If you're comfortable at haskell's implementation of these concepts, fine.  Doesn't mean there isn't value looking deeper into the rabbit hole.
17:17:20 <Dashkal> Functors between language categories.  Writing transpilers ('configuration' -> code)
17:17:27 <merijn> I still maintain System F and lambdacube concepts are much more directly applicable
17:17:34 <Dashkal> In my specific case, I mean a powerful configuration language into my internal model
17:17:51 <Dashkal> And I mean proper functors, not the endofunctors we usually see called Functor
17:19:48 <hask-> This is my app.hs file: https://pastee.org/4ac52  This is my Boom.hs module file: https://pastee.org/kb9p7
17:19:49 <hask-> When I compile this with: ghc -Wall app.hs -o ../app
17:19:50 <hask-> I get this warning: "The import of ‚ÄòBoom‚Äô is redundant"
17:19:51 <hask-> Why? How can I eliminate this warning without taking away -Wall?
17:19:56 <seku> sorry, took some time to run the virtual machine
17:20:39 <seku> i wonder why that command now gives me 4 xD
17:20:58 <seku> what does it map o-O
17:21:35 <Welkin> seku: it maps `print` over the list [1..10]
17:22:00 <Welkin> and then `!! n` takes the nindex value from the list
17:22:05 <Welkin> n-index*
17:22:45 <Welkin> map print [1..10] produces a list of computations of the form `print n`
17:22:45 <Dashkal> Now that I'm thinking about it, it's been far too long since I've dabbled in languages.
17:22:47 <nshepperd> hask-: it's saying you haven't used any value imported from Boom...
17:23:22 <merijn> seku: My point was that just because print returns "IO ()", doesn't mean it has side effects
17:23:51 <merijn> seku: Think about the type "map print [1..10]" has type "[IO ()]", i.e. it's a list of IO actions (none of them have executed)
17:24:16 <seku> lazy evaluation_
17:24:20 <seku> *?
17:24:28 <merijn> seku: !! 3 indexes a list and returns the 4th value, so "map print [1..10] !! 3" returns an "IO ()"
17:24:34 <merijn> seku: No, this is not laziness
17:25:03 <merijn> Now, ghci will evaluated the returned "IO ()", resulting in printing 4 to the output
17:25:20 <merijn> seku: But in haskell you can construct and pass around IO actions as first class values
17:26:18 <merijn> "print :: Show a => a -> IO ()" is pure, why? Think about it. "a function is pure if evaluating it with the same input arguments will result in the same result"
17:26:36 <seku> first class value or function argument?
17:26:40 <merijn> "print 4" returns "an action that, when run, prints '4'"
17:26:50 <seku> agreed
17:26:55 <volty> it is laziness
17:27:04 <merijn> Which is a pure function, because "print 4" will always return the same computation
17:27:16 <merijn> volty: No, because if I made the map strict it'd have the same result
17:27:30 <hask-> nshepperd: thanks!
17:27:36 <volty> it's encoded in the language itself
17:27:49 <Dashkal> Laziness isn't really involved.  "IO ()" is the type of a description of what to do, that only the end of the universe understands.  You return it from main, and the driver outside knows what to do with it.
17:27:53 <volty> there's a map of 10 prints out and only the fourth gets executed
17:27:56 <merijn> volty: Hell, use deepseq to evaluate "map print [1..10]" before applying !! 3, you'll get the same result
17:28:12 <merijn> volty: If haskell was strict, 4 would still be the only one executed
17:28:27 <volty> equiv :   (map print [1..10]) !! 3
17:28:36 <seku> to me it feels kinda like an if else
17:28:39 <volty> call it whatever you please
17:28:42 <geekosaur> still missing the difference between map and mapM?
17:28:49 <merijn> seku: So in haskell we have pure functions constructing IO values
17:28:53 <Dashkal> To drive the point home, think about making multiple IO actions, but then just dropping them on the floor rather than combining them and returning them from main.  This is why the (map print [1..10]) !! 3 example only prints one value.
17:29:24 <dfeuer> How do you break a string across lines again?
17:29:33 <volty> split
17:29:34 <merijn> seku: Now, *executing* them has side-effects, but the only action that gets executed is "main", so we write pure computations that construct a single big IO action that gets executed
17:29:44 <nshepperd> 'lines'
17:29:51 <geekosaur> dfeuer: string gaps? or just use individual strings and concat them
17:29:53 <volty> ops
17:30:02 <geekosaur> depending on which side you're talking about
17:30:10 <merijn> seku: But in constructing this big IO action we can pass any IO computations around as first class values, without executing them
17:30:30 <merijn> seku: And to reiterate, it would be possible to do this even if we made a strict haskell
17:30:30 <volty> tell him what is first class value
17:30:46 <merijn> So haskell's laziness is not relevant here
17:30:49 <seku> so main is the only one that executes, and the IO is passed around as function variable as i see fit_
17:31:02 <dfeuer> Thanks, geekosaur. I was talking about string gaps, but for my current purpose the concatenation thing is surely better.
17:31:04 <merijn> seku: No, not "the IO"
17:31:17 <geekosaur> most people hate string gaps. I'm ok with them
17:31:51 <merijn> seku: Let's take an example. In, say, Java if you want to read a String from "somewhere" you implement like a StringReader interface and then you make files, sockets, etc. all isntances of that, right?
17:32:02 <seku> i dont know how i should call it ....the IO type container that gets passed around?
17:32:22 <dfeuer> But then again, I don't see why hlint complained anyway... unless it was about someone else's string...
17:32:40 <seku> ok
17:32:44 <merijn> seku: In haskell you could write "commandLoop :: IO String -> IO ()" where commandLoop is a recursion that uses the input "IO String" to produce a String whenever it wants
17:32:55 <nshepperd> itt's pronounced "IO action", normally
17:33:18 <merijn> seku: You could do "commandLoop getLine", but also "commandLoop (hGetLine mySocket)"
17:33:51 <merijn> seku: Since it's the *action* being passed around, rather than the result, commandLoop can run the same action multiple times, if it wants
17:33:57 <volty> IO is out of laziness -- that's why you can extract a fourth element out of output in haskell only // the lang beneath is lazy, strict vs lazy structures doesn't matter here // /anyway we risk to get lost in metaphysics about strict vs lazy regarding with IO
17:34:10 <seku> you see, that mindblows me already. a recursion on a probable reading event would go looping my cpu
17:34:34 <merijn> volty: Haskell IO is strict, laziness of the language is not relevant.
17:35:03 <volty> so the semantics should be print me [1..10], then print me the fourth ???
17:35:08 <merijn> volty: I can implement StrictHaskell which is not lazy and the example I gave would STILL only print 4
17:35:17 <volty> where are the others gone ?
17:35:29 <merijn> volty: garbage collected
17:35:33 <volty> tell me another language where you can do that
17:35:36 <seku> im not up to par yet... lots more reading and braincrashing to do.
17:35:55 <nshepperd> volty: no, this is nothing different than having an array of C programs and selecting the 4th one to compile and run
17:36:00 <merijn> volty: I'm not aware of any current language that does that. But implementing a strict language that does that is simple
17:36:18 <nshepperd> volty: a C source file is inert, it doesn't need to be "stopped" from runnning
17:36:19 <volty> ah, but you wait to see (@ nshepperd)
17:36:24 <volty> so it is about laziness
17:36:34 <merijn> nshepperd: Bad example
17:36:48 <merijn> nshepperd: No he goes on with his laziness again :\
17:36:58 <nshepperd> sigh :/
17:37:25 <seku> its all difficult via chat... i wish i could just drive to some haskell center and talk live :)
17:37:25 <merijn> volty: It's because *evaluating* "print 4" doesn't do anything, not because of laziness, but because of purity
17:37:28 <volty> give me an equivalent in another lang and I retract
17:37:48 <volty> nothing to do with purity, printing out is impure
17:37:57 <volty> (as reading-in)
17:38:03 <merijn> volty: Which is why you can't do it in haskell
17:38:11 <volty> yap
17:38:12 <merijn> the runtime system can print, haskell cannot
17:38:19 <dibblego> volty: printing out is not impure
17:38:33 <merijn> You are conflating implementation with language semantics
17:39:02 <volty> that's why you can print from wherever you want only with debugging instructions ....
17:39:05 <volty> ?
17:39:18 * hackagebot roller 0.1.0 - Playing with applicatives and dice!  http://hackage.haskell.org/package/roller-0.1.0 (ljsc)
17:39:38 <merijn> Anyway, this is not a discussion I'm interested in finishing when it's time to go home
17:39:47 <nshepperd> Debug.Trace is an evil hack that breaks the normal rules
17:39:52 <seku> time to go to bed here. work in 4 hours
17:39:52 <volty> ah, you are not already home ? :)
17:40:04 <seku> thanks for your time. ill perservere :)
17:40:18 <volty> yes, time to reorganize our neurals
17:41:18 <nshepperd> volty: anyway, consider a C program with a function "void print1() { printf("1\n"); }" and print2, print3 defined
17:42:26 <nshepperd> volty: and suppose that in main() we put function pointers to those in an array, then take as user input integer i, and do "funcarray[i]()"
17:42:28 <volty> yes, you can delay till you know which one passes --- and that's about laziness - executed only if & when needed
17:43:12 <nshepperd> if you define lazyiness that way, then all programming is laziness
17:43:19 <dfeuer> Hahahahahahaha.
17:43:26 <volty> the structure could be strict, but the !! 4 behind re-imposes laziness
17:43:29 <volty> ha, ha, ha
17:43:32 <nshepperd> the whole point of computer programs is to execute stuff when need
17:44:32 <dfeuer> No, volty. Go spend a few more minutes (!) learning Haskell before saying more things that make even less sense than the things I say.
17:44:57 <volty> of course, dear // the results are there
17:45:06 <nshepperd> in haskell, laziness has a much more specific definition. it involves thunks
17:45:19 <augur> does anyone have a good tutorial for simply-typed type checking?
17:46:25 <dfeuer> augur, I bet Pierce does ....
17:46:32 <dfeuer> (But I don't really know)
17:46:33 <volty> yes  there ten thunks waiting to print [1..10] numbers
17:46:41 <volty> are
17:46:54 <nshepperd> volty: no, a thunk is not just a function pointer
17:46:59 <dfeuer> Thunks do not print things. What are you talking about?
17:47:32 <volty> yes, those gray things that create methods on-fly
17:47:35 <nshepperd> for one thing, when you evaluate a thunk, the thunk gets destroyed and replaced by its result
17:48:03 <volty> dfeuer: i'm trying to ease my language
17:48:04 <augur> aha! stephen diehl has a nice little tutorial
17:48:10 <nshepperd> you can't "call a thunk twice"
17:48:10 <volty> don't want to become sad
17:48:15 <dfeuer> augur, link?
17:48:35 <augur> http://stackoverflow.com/questions/20404220/haskell-for-lambda-calculus-type-inferencing
17:48:52 <hakujin> learning lens: I have r ^. responseBody . atto (attoparsec parser). The parser wants a strict ByteString but responseBody returns a lazy bytestring. How do I apply `toStrict` in the middle? Somehow use over?
17:49:02 <dfeuer> (Well, you *can* call a thunk twice, but that requires some concurrency or parallelism and also some unlikely luck.)
17:49:40 <volty> high programming with low-level thunkering
17:49:41 <volty> mah!
17:49:56 <volty> i'll go to read some basic from 30 years ago
17:50:01 <volty> as a cure :)
17:51:17 <volty> I wish you high production and low teaching syndrome // good night
17:52:14 <dfeuer> Whew.
17:52:18 <josephle> augur, that simply typed lambda calculus is going to need some base types ;)
17:52:24 <nshepperd> waw
17:54:30 <SrPx> Are cabal packages installed with -O1 by default?
17:57:20 <augur> here's another one http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
17:58:06 <artyomkazak> hakujin: use `to`
17:59:27 <hakujin> artyomkazak: thanks, will research
18:01:02 <artyomkazak> hm, wait
18:01:15 <artyomkazak> there's also an Iso specifically for that
18:02:05 <artyomkazak> you can just use `strict` instead of `to toStrict`, I think
18:02:13 <benzrf> :t to
18:02:15 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
18:02:17 <benzrf> :t from
18:02:18 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
18:03:33 <benzrf> ohh Contravariant f
18:03:34 <benzrf> rig ht
18:03:43 <benzrf> was confused there for a minute o_o
18:04:09 <benzrf> :t to (show :: Int -> String)
18:04:11 <lambdabot> (Contravariant f, Conjoined p, Functor f) => p String (f String) -> p Int (f Int)
18:04:19 * hackagebot roller 0.1.1 - Playing with applicatives and dice!  http://hackage.haskell.org/package/roller-0.1.1 (ljsc)
18:11:09 <prinsen> Is there any way to get haddock to include TH-splices instead of the $(..) that generated the code?
18:14:50 <zq> martin-lof intro recommendations?
18:16:14 <geekosaur> prinsen: suspect you'd have to make it use zeroth as a preprocessor or something (except I think zeroth is bitrotted and won't handle all of current TH)
18:17:08 <MP2E> EvilSplicer might work for that use-case, it uses the host GHC to output the splices
18:17:17 <MP2E> zeroth doesn't work with 7.8.3 from what i can tell
18:17:30 <MP2E> not without some modification that was beyond what I wanted to do, anyway :P
18:18:06 <geekosaur> that was what I meant by bitrotted, yeh
18:19:20 * hackagebot roller 0.1.2 - Playing with applicatives and dice!  http://hackage.haskell.org/package/roller-0.1.2 (ljsc)
18:34:34 <marchelzo_> Can someone help me figure out why this isn't working? I've never used Aeson before. http://lpaste.net/1461810321265000448
18:34:59 <marchelzo_> Here is the JSON that I am trying to parse https://a.4cdn.org/g/thread/44600364.json
18:35:48 <lisbeth> I really like what i've seen so far
18:35:53 <lisbeth> it's hard to believe the syntax to haskell is so simple
18:36:17 <centrinia> What is a good Haskell indenter?
18:36:21 <lisbeth> it seems that debugging would be more about fixing logical errors than syntax errors
18:37:16 <mm_freak_> hi there
18:38:05 <mm_freak_> when i limit the lifetime of a variable by giving it a type argument and quantifying over it, is there a guarantee that it will be garbage-collected promptly?
18:38:35 <mm_freak_> (like ST does)
18:39:04 <dfeuer> mm_freak_, I think ... not.
18:43:39 <artyomkazak> marchelzo_: isn't tim a number
18:44:06 <artyomkazak> the fields in Post are ‚Äúname‚Äù and ‚Äúext‚Äù, but you're parsing ‚Äúext‚Äù and ‚Äútim‚Äù
18:44:13 <SrPx> Hello, I've pointed cabal to stackage. How can I make it install *every* single library available, with -O2 and -p?
18:44:46 <mm_freak_> SrPx: you can control the compiler flags via your ~/.cabal/config
18:44:49 <marchelzo_> artyomkazak, yes. is that not valid? I am not using the default instance of FromJSON so I can specify that, no?
18:44:58 <mm_freak_> SrPx: see the generated default config
18:44:59 <SrPx> mm_freak_: thank you! :)
18:45:20 <mm_freak_> SrPx: but you probably don't need -O2
18:45:29 <SrPx> mm_freak_: why not?
18:45:53 <marchelzo_> artyomkazak, >.< I see what you mean now
18:45:56 <mm_freak_> SrPx: it only gives a speedup for artihmetic-heavy code and most likely only over large arrays
18:46:05 <mm_freak_> otherwise it's just a waste of compile time
18:46:09 <artyomkazak> marchelzo_: I annotated your paste with code which works
18:46:21 <SrPx> mm_freak_: I'm fine with that, can I compile everything in a night?
18:46:28 <SrPx> mm_freak_: it is just a single time anyway, right
18:46:46 <mm_freak_> SrPx: in particular it won't make your web app faster, and the packages that really benefit from -O2 most likely have it enabled anyway =)
18:47:01 <SrPx> ah I didn't know they could
18:47:03 <SrPx> oaky
18:47:27 <SrPx> but what about enabling profile? Should I just edit the line 33, `-- flags:`, to `-- flags: -p` ?
18:47:45 <marchelzo_> artyomkazak, so if something is a Number in the JSON, it cannot be coerced to something which is not an instance of Num?
18:47:59 <mm_freak_> SrPx: i don't think that's the proper way to enable profiling library versions
18:48:32 <SrPx> ... so how do I build the whole stockage with profile...
18:49:16 <mm_freak_> SrPx: i think it's sufficient to set this in your config:  library-profiling: True
18:49:49 <mm_freak_> that will give you profiling versions of all libraries
18:49:58 <artyomkazak> marchelzo_: why, it can
18:50:26 <artyomkazak> ¬´v .:? "tim"¬ª is just a value of type ¬´f (Maybe Int)¬ª
18:50:40 <artyomkazak> you can use anything to convert it, e.g.
18:50:48 <artyomkazak> maybe "NONE" (show :: Int ->¬†String) <$> v .:? "tim"
18:51:15 <artyomkazak> I've added another annotation
18:51:43 <marchelzo_> right, but you can't treat a Number in the JSON as a String for example without explicitly converting it. Thank you very much by the way
18:51:55 <prinsen> mm_freak_: isnt there a Library-Profiling flag in .cabal/config?
18:51:56 <artyomkazak> I don't know, to be honest
18:52:16 <artyomkazak> parsed JSON only once in life
18:52:27 <artyomkazak> well, twice now
18:52:30 <prinsen> mm_freak_: hadn't scrolled down
18:52:33 <marchelzo_> artyomkazak, haha
18:52:41 <mm_freak_> is there any way to force the garbage-collector to collect a certain value and run its finalisers?  it's fine if the corresponding function's name begins with "unsafe"
18:53:24 <mm_freak_> although only running finalisers is probably sufficient in my case, so i'll just use System.Mem.Weak
18:53:42 <floresiensis> Alright, the slowdown I experienced with mutable arrays was not caused by creating many arrays. I modified the program to use (and reuse) only 3 arrays, and there is little change in performance; maybe even slower.
18:53:56 <floresiensis> It would seem that mutable arrays are simply slow.
18:54:09 <floresiensis> these are unboxed, too
18:54:14 <mm_freak_> thanks for being quiet long enough for me to figure this out myself =P
18:54:22 <artyomkazak> floresiensis: just in case, you got my @tells, right
18:54:24 <SrPx> mm_freak_: ah for some reason I missed it, thanks
18:54:25 <marchelzo_> artyomkazak, well then I'm not sure if you'll have an answer for this, but is there a way to, rather than having the members of Post be (Maybe String), or using (.!=) to supply a default value, just return a Maybe Post? Because I have no use for posts that do not contain "ext" and "tim"
18:54:36 <SrPx> so...... how do I install everything on hack age?
18:54:56 <mm_freak_> floresiensis: mutable arrays are very fast, C-like speed is possible, but there are a few gotchas‚Ä¶  what are you trying to do?
18:55:27 <floresiensis> artyomkazak: no, I logged out, but I can probably find the log
18:55:31 <mm_freak_> floresiensis: and also which array library are you using?  'array' or 'vector'?
18:55:43 <floresiensis> using IOArray Int Char
18:55:43 <artyomkazak> ¬´@tell floresiensis also, you don't need unboxed arrays here, it performs just as well with strings¬ª
18:55:50 <artyomkazak> ¬´@tell floresiensis your code becomes 5√ó faster if you switch to mwc-random, see here: https://gist.github.com/neongreen/7f76d78cdecf5f861b67/revisions¬ª
18:55:57 <floresiensis> I mean IOUArray Int Char
18:56:30 <mm_freak_> floresiensis: i just joined a few minutes ago‚Ä¶  if you could explain your application, i can probably help you
18:57:04 <artyomkazak> marchelzo_: a sec
19:04:05 <carter> mm_freak_: depends :)
19:04:30 <carter> mm_freak_: you might wanna invoke minorgc
19:04:35 <carter> or majorgc
19:04:41 <carter> which are real function
19:04:57 <floresiensis> artyomkazak: slow random is a possibility I didn't consider, thanks. ghc is now only 4x slower than sbcl, so maybe rigging your code with reused arrays would make it comperable.
19:06:14 <jTT> good morning (or evening)! I am working through a conduit tutorial and came across this monadic chaining: await >>= maybe (return ()) (\x -> f x >> awaitForever' f)     ‚Äî I don‚Äôt quite understand the ‚Äòmaybe‚Äô there, is this some form of pattern matching? I would have expected some form of ‚Äúcase x of ‚Ä¶Nothing , Just‚Ä¶. Can someone help me out?
19:06:36 <nshepperd> :t maybe
19:06:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:06:48 <jTT> jeessseee
19:06:49 <mm_freak_> carter: where are they?
19:06:51 <jTT> thanks
19:07:51 <carter> @hoogle minorgc
19:07:53 <lambdabot> No results found
19:07:59 <carter> @hayoo minorgc
19:07:59 <lambdabot> Unknown command, try @list
19:08:23 <mm_freak_> floresiensis: when you switch to mwc-random, also switch to the vector library‚Ä¶  it's faster and also connects much better with mwc-random
19:08:30 <carter> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Mem.html#v:performGC
19:08:34 <carter> mm_freak_: BAM
19:08:51 <carter> mm_freak_: i dont know if finalizers can be killed in a minor gc
19:08:57 <carter> i'd be very curious to find out
19:09:16 <carter> huh, the major/minor versions are only as of 7.8
19:09:23 * hackagebot here 1.2.6 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.6 (TaylorHedberg)
19:09:33 <carter> before there was just performGC, which was a major GC
19:10:02 <carter> mm_freak_: oooo
19:10:17 <carter> mm_freak_: oooooo
19:10:19 <carter> i have an idea
19:10:26 <carter> that might might be better
19:10:27 <artyomkazak> marchelzo_: okay, yeah, it can be done
19:10:37 <carter> mm_freak_: whats the use case ?
19:10:41 <artyomkazak> I don't particularly like, how, but still
19:11:10 <spopejoy> hi y'all. existential types question. It appears it's a one-way street when doing a heterogenous list, a la 'data Obj = forall a. (Show a) => Obj a'; I can make a list out of this and `show` it. But there's no way to pattern-match on what i put *into* it.
19:11:21 <carter> prinsen: add typeable
19:11:23 <carter> spopejoy:
19:11:23 <artyomkazak> see annotation to annotation to annotation
19:11:40 <carter> spopejoy: you want to add Typeable to it
19:11:43 <spopejoy> which seems weird. the runtime knows the type, and all instances available of Show.
19:11:45 <marchelzo_> artyomkazak, ok. thanks a lot for the help. I was lost with this library
19:11:49 <carter> no
19:11:53 <geekosaur> the runtime does not know the type
19:11:53 <carter> spopejoy: runtime dont know types
19:12:06 <carter> we erase ALL The info thats not in a type class dictionary
19:12:09 <carter> ALL OF IT
19:12:15 <spopejoy> is there some way to expose the structure of my list to the compiler?
19:12:29 <carter> spopejoy: whats the goal
19:12:33 <carter> tell us your real goal
19:12:34 <spopejoy> and still be able to deal with it "as a list", ie not bleed the type contents to all consumers?
19:12:39 <carter> not the way youre trying build it
19:12:47 <carter> :)
19:12:49 <mm_freak_> carter: thanks‚Ä¶  for some reason finalisation doesn't work at all right now‚Ä¶  i'm investigating
19:13:00 <spopejoy> it just seems like there's no "encapsulation" in the type system
19:13:03 <carter> mm_freak_: you might need to do a majorGC
19:13:06 <carter> spopejoy: no
19:13:10 <carter> whats the goal in the engineering
19:13:21 <carter> we can help you cook up a better design
19:13:23 <floresiensis> mm_freak_: why is the effort duplicated between UArray and the vector lib? Couldn't they have made UArray faster?
19:13:26 <carter> by understanding your root / core goal
19:13:30 <carter> floresiensis: no
19:13:32 <carter> vector has slicing
19:13:41 <carter> also Vector was for a time, a rsearch vehicle
19:13:44 <carter> for stream fusion
19:13:50 <carter> Array is super stable
19:13:54 <mm_freak_> carter: http://lpaste.net/112399
19:13:56 <lisbeth> so I've been looking at the number of outputs possible
19:14:00 <Welkin> floresiensis: anthropology/archaeology geek?
19:14:01 <spopejoy> I want a heterogenous KV store with only known types for K and V, and no casting/runtime penalty, and not bleed the types to every client.
19:14:05 <lisbeth> numbers, chars, lists, booleans
19:14:14 <mm_freak_> carter: doesn't work, although i remember about the same code working in an older attempt
19:14:17 <lisbeth> Or at least that's what I've noticed so far
19:14:23 * hackagebot roller 0.1.3 - Playing with applicatives and dice!  http://hackage.haskell.org/package/roller-0.1.3 (ljsc)
19:14:29 <mm_freak_> floresiensis: 'array' is really just there for historical reasons
19:14:32 <carter> spopejoy: oh, i'm workin gon that
19:14:36 <hask-> How can fix this function https://pastee.org/78k7e   to make sure "func" is only called once? I could add an extra parameter to "callFuncOnce", but I want to hide it within this function.
19:14:45 <mm_freak_> floresiensis: 'vector' is the array library you should use in new applications
19:15:12 <spopejoy> i'm just trying to avoid making everything Typable as I assume there's a runtime penalty. No?
19:15:49 <carter> spopejoy: not really
19:16:10 <carter> spopejoy: if youre doing a generic kv store, that will not be teh bottleneck
19:16:14 <carter> at all
19:16:24 <mm_freak_> floresiensis: also very often you can express your application in terms of immutable vectors and get the same performance‚Ä¶  'vector' performs fusion for all its array types
19:16:25 <carter> i look forward to your future magic tech where thats your perf bottlneck
19:16:27 <carter> :)
19:16:45 <spopejoy> It's probably my java twitches "Aagh reflection it'll be SLOW"
19:16:47 <carter> spopejoy: i'd probably just make each "column" a wrapped up thing
19:16:50 <carter> spopejoy: nope
19:16:52 <carter> this is different
19:16:55 <carter> no comparision
19:16:58 <carter> fundamentally
19:17:08 <carter> mm_freak_: did you look at the core?
19:17:09 <floresiensis> mm_freak_: maybe Data.Array.Unboxed should be marked as deprecated, so users (like me) don't have to find out the hard way
19:17:17 <carter> floresiensis: no
19:17:19 <carter> it works
19:17:23 <geekosaur> it's just another typeclass dictionary entryit's not deprecated
19:17:28 <geekosaur> whoopsit's a low
19:17:29 <mm_freak_> spopejoy: when you use a type like Dynamic, type comparison occurs, but casting does not occur
19:17:35 <geekosaur> dang, what is this client doing
19:17:41 <hask-> Noone?
19:17:44 <mm_freak_> spopejoy: "casting" as in conversion
19:17:57 <carter> it just says "are you my type? y/n"
19:18:05 <spopejoy> I mean "casting" as in reifying the type at the site of retreival from a het. store
19:18:07 <carter> you can hide it from the end user abpi
19:18:08 <geekosaur> floresiensis, Array is a low level library
19:18:14 <carter> spopejoy: no
19:18:20 <carter> it bunbled with it the evenidence
19:18:20 <spopejoy> sorry, "recovering" the type
19:18:28 <carter> spopejoy: stop worrying
19:18:29 <mm_freak_> floresiensis: 'array' is still a standard library, while 'vector' is not (but it's a platform library)
19:18:31 <spopejoy> :)
19:18:31 <carter> it wont be the bottleneck
19:18:58 <spopejoy> carter: your use of definite article makes me wonder, where is the bottleneck? :)
19:18:59 <carter> lookup:: Typeable a => Table -> Name -> proxy a -> Maybe a
19:19:08 <carter> spopejoy: your fingers, not finishign the next big db
19:19:28 <carter> spopejoy: i've a few db like ideas i'm hoping ot hack out in the next few months
19:19:30 <carter> :)
19:19:37 <Welkin> programming with your fingers is far too primitive
19:19:39 <floresiensis> I'm just saying there's no context about these things in hackage, which comes up as the first google hit.
19:19:43 <Welkin> program with your thoughts
19:19:46 <Welkin> become one with the machine
19:19:57 <carter> or hire an intern
19:20:06 <floresiensis> one has to obtain inside knowledge by trial and error
19:20:11 <Welkin> intern/grad student/slave
19:20:26 <spopejoy> hey I'm trying to sell Haskell at the j-o-b and I have a chance of succeeding
19:20:28 <carter> floresiensis: they all work
19:20:31 <carter> spopejoy: cool
19:20:37 <spopejoy> but I'm wondering about a few things
19:20:49 <spopejoy> first: numeric analysis vs python+pandas+numpy?
19:20:54 <Welkin> spopejoy: Haskell, the lazy language for lanzy people!
19:20:57 <carter> spopejoy: tlak with me later
19:21:06 <Welkin> lazy*
19:21:07 <carter> i'm literally the most opinionated pesonon the planet ont hat
19:21:11 <carter> and i run #numerical-haskell
19:21:13 <mm_freak_> floresiensis: my statements may have been misleading‚Ä¶  it's not generally wrong to use the 'array' library, it just gives you a much less convenient interface and likely slower code
19:21:25 <mm_freak_> floresiensis: on the other hand it is index-polymorphic, which is a plus
19:21:35 <carter> spopejoy: i'm on the phone now
19:21:42 <carter> but lets chat on #numerical-haskell later
19:21:56 <spopejoy> cool, but actually I know nothing about numerical stuff :)
19:22:04 <spopejoy> my coworkers do
19:22:08 <carter> spopejoy: thats ok
19:22:16 <spopejoy> but yes, see you there
19:22:18 <spopejoy> :)
19:22:21 <Welkin> python is popular in scientific computing because it is popular
19:22:30 <Welkin> popular things are popular because they are popular
19:23:12 <spopejoy> let me throw in a comment from HN the other day that I hope can be roundly trounced
19:23:16 <carter> spopejoy: whats the industry / problem domaimn
19:23:21 <carter> no
19:23:24 <carter> tell me info instead
19:23:32 <spopejoy> banking
19:23:42 <floresiensis> the slowness of System.Random is interesting is somewhat detrimental -- is it in the bug database?
19:23:51 <floresiensis> *and somewhat
19:23:56 <Welkin> too bad you didn't say "brinking" instead
19:23:56 <carter> spopejoy: time series?
19:23:58 <spopejoy> payment processing, corp treasury, liquidity
19:23:59 <Welkin> that would be more fun
19:24:18 <carter> i've friends ok
19:24:18 <spopejoy> under the rubric of both rest APIs and data science stuff
19:24:45 <mm_freak_> floresiensis: no, because it's not a bug‚Ä¶  it's a memory-cheap, not too fast but not too slow PRNG useful for many applications
19:25:05 <spopejoy> OK HN quote: "Libraries like repa or accelerate-cuda fall short as soon as you want to go beyond what they expose in high level functionality (for example dynamic stencils in the case of repa). Try to express matrix vector multiplication tailored to matrices arising for discontinuous galerkin of a certain pde (they are typically sparse but in a predictable way) in accelerate-cuda and compare to the ~500-1k straightforward lines of code to 
19:25:06 <spopejoy> the same with intel thread building blocks or cuda"
19:25:12 <mm_freak_> floresiensis: you can use a much faster and much more memory-hungry PRNG like MT or MWC for high-performance applications
19:25:12 <spopejoy> BS?
19:25:16 <carter> spopejoy: tlak with me later
19:25:18 <carter> i've fancy tech
19:25:25 <mm_freak_> and a slower CSPRNG for cryptographic applications
19:25:32 <mm_freak_> it's a tradeoff
19:26:12 <bitemyapp> spopejoy: hrrrrrm. how immediately do you need all this?
19:26:26 <spopejoy> i don't need any of it, necessarily.
19:26:33 <spopejoy> I can do haskell if I want :)
19:26:46 <spopejoy> I just want to convert others as well
19:26:48 <bitemyapp> spopejoy: well, if you're just exploring it's worth considering whether you'd want to think about either waiting for carter's stuff or having a migration plan for it.
19:26:53 <bitemyapp> spopejoy: yeah I'm in the same position.
19:26:59 <floresiensis> mm_freak_: I want the fastest, crappiest random like C's rand().
19:27:01 <carter> i've really really nice stuff for sparse
19:27:04 <bitemyapp> spopejoy: coworkers use Python, trying to move people over. Need numerics/data frame/blah blah blah stuff.
19:27:14 <Welkin> spopejoy: you won't convert someone to your religion with logic
19:27:16 <arbn> spopejoy: For many people, the answer is that Haskell does not _yet_ have something with comparable out-of-the-box functionality to Pandas or NumPy. But, this will depends on the details of what you're actually wanting to do, and you should talk to carter. :)
19:27:24 <bitemyapp> spopejoy: there's some stuff for that, but nothing brilliant until carter's numerics stack is released.
19:27:27 <Welkin> languages are too often religions
19:27:30 <arbn> will depend*
19:27:39 <mm_freak_> floresiensis: MWC most likely beats it =)
19:27:43 <carter> arbn: thankeee
19:27:45 <spopejoy> however I feel like python heads are some of the best people to target, no?
19:27:50 <carter> spopejoy: ?
19:28:01 <mm_freak_> floresiensis: if you need fast random numbers and don't care about anything else, just use MWC
19:28:02 <Welkin> spopejoy: possibly, I used to love python before haskell took its place
19:28:15 <spopejoy> 1: they do functional stuff (possibly)_
19:28:27 <spopejoy> 2: they like whitespace and hate types all over the place
19:28:30 <mm_freak_> floresiensis: it even gives you a very fast vector interface
19:28:39 <spopejoy> 3: they're generally terrified of the *actual* type system in play
19:29:09 <spopejoy> my sales pitch is going to be "types don't slow you down, they give you control over the compiler"
19:31:11 <spopejoy> then I have to convince the Java + Redis + 100GB forward cache types that we can use haskell there too. (Can we? :) )
19:31:39 <arbn> spopejoy: I worked in a company for a year that used Python in finance. The only barrier that's worth talking about is that the Haskell community today has a smaller and less mature library ecosystem for numerical and scientific computing. When that changes, I think Haskell would be obviously preferable for that kind of work.
19:32:05 <arbn> spopejoy: But, right now, you're going to be writing a lot of basic stuff yourself.
19:32:07 <levi> You can use haskell most places. I mean, look at all the places people use Ruby.
19:32:26 <Welkin> I'd like to use haskell for shell scripts
19:32:26 <spopejoy> arbn: do you think that's primarily in the matlab/symbolic domain, or more in the pandas/ergonomics domain?
19:32:35 <Welkin> it seems to be well suited to the task
19:32:41 <spopejoy> Welkin: it's OK
19:32:42 <arbn> spopejoy: Matlab is not the symbolic domain...
19:33:00 <Welkin> use mathematica for symbolic computations
19:33:10 <spopejoy> arbn: sorry, I'm talking out of my a$$. Doesn't matlab have a huge "symbolic library" or somthing like that?
19:33:20 <Welkin> matlab does have a symbolic toolbox
19:33:30 <Welkin> I've used it lightly
19:33:35 <arbn> spopejoy: Pandas/Numpy are the Python answer to Matlab. Everyone I've known who used Matlab used it for numerical stuff.
19:34:07 <levi> I've never heard of anyone using Matlab for symbolic stuff. I have a bunch of DSP coworkers who use Matlab all the time, too.
19:34:21 <spopejoy> maybe I'm thinking of mathematica ...
19:34:36 <spopejoy> ok i think i understand the numpy area better now.
19:34:49 <spopejoy> So. How about those 100GB heaps?
19:35:32 <spopejoy> Or memory-mapping, is that solid?
19:35:32 <floresiensis> artyomkazak: thinking about this more, my use of random was kind of brute force. It calls random for each element to determine if it will mutate. But after doing some math, one needs just one random call to see how many elements will mutate.
19:36:27 <spopejoy> Or ... "ontologies", ie data transformations from one REST API to the next. That to me sounds like it has Haskell written all over it.
19:37:13 <levi> One of the recently posted skillscast videos is about REST API schema migration stuff in Haskell.
19:39:04 <spopejoy> levi: thanks, I will *definitely* be watching that!
19:39:25 * hackagebot hackernews 0.2.1.1 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.2.1.1 (DavidJohnson)
19:39:55 <hask-> How can use monads to fix this function https://pastee.org/78k7e   to make sure "func" is only called once? I could add an extra parameter to "callFuncOnce", but I want to hide it within this function using monads.
19:40:18 <arbn> spopejoy: How would you describe your familiarity and competence with Haskell? How would you describe the average familiarity and competency of the people on your team?
19:40:39 <spopejoy> arbn: I'm an expert, obviously
19:40:41 <spopejoy> :)
19:41:09 <johnw> hask-: use the library http://hackage.haskell.org/package/io-memoize
19:41:11 <mm_freak_> hask-: you want the type system to ensure that 'callFuncOnce' only uses the passed action once?
19:41:15 <levi> And the rest of them are pretty interesting, too. SPJ talks about finally fixing the type coercion unsoundness problem in GHC, BOS talks about benchmarking and Criterion, etc.
19:41:25 <spopejoy> arbn: rest of team zero.
19:41:35 <mm_freak_> hask-: or you just want to save the result so that you don't need to run the action multiple times?
19:41:40 <mm_freak_> hask-: that's two quite different things =)
19:42:07 <spopejoy> regarding hask-'s q: I thought functions were automatically memoized if they aren't in IO or something.
19:42:12 <hask-> mm_freak_: i want to be able to call "callFuncOnce" many times - but only the first time it is called will it internally call "func"
19:42:25 <benzrf> hask- you cannot do that without iorefs or unsafeperformio
19:42:38 <benzrf> iorefs may be what you are looking for
19:42:41 <mm_freak_> hask-: change your type signature
19:43:00 <hask-> mm_freak_: you mean add a Bool parameter?
19:43:04 <mm_freak_> hask-: mkUseOnce :: IO String -> IO (IO String)
19:43:11 <kadoban> If I just create a cabal.config in a project directory with the stackage remote-repo line, then init a cabal sandbox, is that enough to use only stackage for that project, or do i have to edit my global config too?
19:43:20 <levi> Oh, and a very gentle introduction to how category theory can inform better code structure in Haskell.
19:43:25 <mm_freak_> mkUseOnce action = do result <- action; return (theAction result)
19:43:34 <spopejoy> I have a theory
19:43:39 <mm_freak_> hask-: does that make sense?
19:44:24 <spopejoy> which is that going through ALL of the implications of pervasive currying and being able to use types to reason about functions gets you where you need to start understanding Functor -> Applicative -> Monad without category theory.
19:44:27 <hask-> mm_freak_: not really. where can I store the result so the next time I won't have to call the func again?
19:44:42 <mm_freak_> hask-: you don't /store/ it‚Ä¶  you just give it a name‚Ä¶  let me write example code
19:44:45 <hask-> mm_freak_: i know i can store it within main. but I want to avoid that extra parameter in my function
19:44:45 <levi> hask-: Does the function always return the same single value?
19:45:03 <levi> hask-: I.e. is it really a function, or is it just a computation you need to run to produce a value?
19:46:07 <hask-> mm_freak_: thanks
19:46:16 <levi> spopejoy: That's sort of what the talk is about.
19:46:30 <hask-> levi: for now it's the same.  of course if func result changes i can't store like this.
19:46:54 <spopejoy> I love trying to beat my head against category theory, but I'm dubious that it ever got me over any kind of hump. Only staring at the source, tons of coding, and repeated visits to the typeclassopedia and Steven Diel's WIWIHKWIWLH article got me anywhere
19:47:01 <kadoban> What talk are you guys talking about? Sounds interesting, but I think I missed that part of the convo
19:47:24 <levi> hask-: If you bind an expression at the top level, it will be a Constant Applicative Form, not a function. And it will evaluate once the first time it's scrutinized by another evaluation.
19:47:51 <mm_freak_> hask-: http://lpaste.net/112400
19:48:15 <spopejoy> levi: can I ask wtf you're talking about? I need to understand when the RTS memoizes behind the scenes and when it doesn't.
19:48:30 <spopejoy> 'wtf' as in I'm dying to know
19:48:45 <hask-> mm_freak_: that looks interesting. i will think on this!
19:48:47 <hask-> thanks
19:49:02 <mm_freak_> you're welcome
19:49:07 <spopejoy> I thought any function w/o side-effects will be memoized automatically.
19:49:21 <spopejoy> Am I smoking?
19:49:24 <mm_freak_> spopejoy: values that have a name will be shared
19:49:41 <mm_freak_> spopejoy: if you want to remember a result, just give it a name and keep it in scope
19:49:42 <spopejoy> what about in a where clause?
19:49:49 <spopejoy> oh ok
19:49:51 <mm_freak_> spopejoy: yes, that works
19:49:58 <spopejoy> while it's in scope. sure.
19:50:07 <mm_freak_> spopejoy: x = y + y  where y = expensiveValue
19:50:22 <mm_freak_> you can also pass y around
19:50:22 <spopejoy> it's another thing where whole reams of optimization code vanish in haskell.
19:50:37 <spopejoy> oh wait.
19:50:48 <spopejoy> so I have to bind it to 'y' or something to get the memoization?
19:50:54 <spopejoy> why isn't application enough?
19:50:58 <mm_freak_> it's sharing, not memoization
19:51:17 <spopejoy> ie, (2+2) + (2+2), it's going to compute (2+2) twice?
19:51:35 <mm_freak_> spopejoy: in such a simple case probably not
19:51:45 <spopejoy> that's what I would think. so easy to avoid.
19:51:46 <mm_freak_> but GHC does not perform CSE in general, because it's unpredictable in haskell due to laziness
19:52:11 <mm_freak_> if you want to be sure, give values a name
19:53:06 <arbn> spopejoy: It's not true that pure functions in Haskell are automatically memoized. I hear that a lot, and I'm not sure why anyone would think that.
19:53:16 <spopejoy> so there are variables in haskell, after all. I thought assigning a name was just the endpoint of currying.
19:53:29 <mm_freak_> spopejoy: of course there are variables
19:53:39 <mm_freak_> (\x -> x)  -- there, a variable =)
19:53:44 <levi> spopejoy: Haskell doesn't automatically memoize things. When people talk about things like 'sharing' and 'only evaluates things once', those are talking about avoiding *extra* evaluations that naive call-by-name evaluation would cause.
19:54:09 <mm_freak_> spopejoy: changing the CPU/memory requirements we don't count as a side effect
19:54:27 <spopejoy> but .. that's inconsistent.
19:54:37 <spopejoy> given a function y a b = a + b
19:54:46 <kadoban> If I have the normal hackage remote-repo in my user .cabal/config and a cabal.config in my project sandbox with the stackage one...will that use only stackage, or do they combine and it'll use both?
19:54:47 <spopejoy> I assign z to (y 1)
19:55:01 <shelf> what's the best way to 'intersperse' on Data.Sequence?
19:55:09 <spopejoy> I assign z' (running out of alphabet) to (z 1)
19:55:23 <levi> (\x -> x + x) <expensive expression> <- this would expand to (<expensive expression> + <expensive expression>) in a non-lazy call-by-name language.
19:55:26 <spopejoy> this means z' is a "variable" whereas z is a curried function.
19:55:40 <mm_freak_> spopejoy: both are values, and both are shared (computed only once)
19:55:45 <mm_freak_> but one of the values is a function
19:56:01 <spopejoy> so in another language, you could only do that with "memoization"
19:56:16 <spopejoy> so maybe memoization is imprecise here.
19:56:20 <mm_freak_> spopejoy: memoization is a different thing
19:56:34 <mm_freak_> spopejoy: this is sharing, and it only really applies to lazy languages
19:56:44 <kadoban> Hmm...maybe this doesn't work at all, remote-repo in project cabal.config seems to be ignored. That sucks.
19:57:09 <spopejoy> i guess I feel like in imperative languages, you "memoize" to avoid performance problems from repeated application. in lazy languages you just forget about it.
19:57:22 <levi> kadoban: I believe the remote repo is used for some variations of the 'unpack' command.
19:58:10 <levi> spopejoy: You memoize in haskell for the same reason; but haskell doesn't memoize by default.
19:58:19 <mm_freak_> spopejoy: not quite:  sharing remembers the result of a computation when you give it a name‚Ä¶  memoization remembers the result of a computation without respect to names
19:58:29 <spopejoy> In the type system, there's no difference between a function that returns Int and an "Int"
19:58:41 <spopejoy> nor in the language syntax
19:59:20 <levi> spopejoy: What?
19:59:23 <mm_freak_> spopejoy: for example when you have a function and you call it in two entirely unrelated places of the application with the same argument and it performs the calculation only once, then it has used some programmed machinery to do that‚Ä¶  it didn't use a language feature
19:59:25 <spopejoy> 'x = 1 :: Int' vs 'x = 1 :: Int + 1', identical in almost every way
19:59:33 <mm_freak_> spopejoy: sharing on the other hand is a language feature
19:59:42 <levi> spopejoy: Neither of those is a function.
20:00:05 <spopejoy> x = 1 + 1 is not a function? Are there no nullary functions in Haskell?
20:00:06 <mm_freak_> spopejoy: also one of them is a syntax error =)
20:00:12 <spopejoy> :)
20:00:17 <mm_freak_> spopejoy: a function is something you can apply
20:00:21 <levi> x = 1 + 1 is a constant applicative form.
20:00:27 <mm_freak_> in other words a value with (->) as its top-level type constructor
20:00:34 <arbn> spopejoy: Functions take input, and there is a difference between (const 5) and 5.
20:00:45 <mm_freak_> spopejoy: anything that doesn't have (->) as its top level type constructor is not a function
20:00:46 <spopejoy> :t (const 5)
20:00:48 <lambdabot> Num a => b -> a
20:01:01 <spopejoy> :t id :: Int
20:01:02 <lambdabot>     Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äòa0 -> a0‚Äô
20:01:02 <lambdabot>     Probable cause: ‚Äòid‚Äô is applied to too few arguments
20:01:02 <lambdabot>     In the expression: id :: Int
20:01:10 <spopejoy> :t id 1
20:01:11 <lambdabot> Num a => a
20:01:18 <mm_freak_> spopejoy: however, there is a subtlety to keep in mind
20:01:25 <kadoban> levi: If I install it seems to ignore the remote-repo, besides telling me that I need to update...but then update ignores it totally and only uses my user config, heh...oh well.
20:01:30 <spopejoy> what is the difference between an unevaluated "id 1" and "1"?
20:01:35 <mm_freak_> spopejoy: a non-function with a context in its type is /not/ shared
20:01:43 <mm_freak_> :t 1  -- not shared
20:01:44 <lambdabot> Num a => a
20:01:49 <mm_freak_> :t 1 :: Int  -- shared
20:01:50 <lambdabot> Int
20:01:56 <levi> When you compile 'x = 1 + 1', GHC binds a 'closure' to x that holds the expression '1 + 1'. When something evaluates x, 1 + 1 is evaluated and x thereafter holds '2' instead of an unevaluated expression.
20:01:58 <hask-> mm_freak_: i don't see the point of your mkUseOnce function.
20:02:08 <hask-> mm_freak_: you just put it into main as a variable anyway
20:02:18 <mm_freak_> hask-: yes
20:02:28 <spopejoy> Hmm. I haven't seen any literature on this, can anyone share?
20:02:53 <spopejoy> share about sharing? :)
20:03:10 <hask-> mm_freak_: so if I call mkUseOnce expensiveAction again, it will call expensiveAction again
20:03:11 <hask-> so what's the point?
20:03:21 <mm_freak_> spopejoy: 'id 1' and '1' are the same program by definition‚Ä¶  but let's replace 'id' by some function that actually heats up your CPU and still returns the same result
20:03:37 <arbn> spopejoy: Memoization is a space-for-time tradeoff. I would really, really rather not Haskell decide to always value CPU time more highly than space. I'd prefer to decide for myself whether I want to keep old outputs around, because I know better than GHC whether I can expect a lot of repeated inputs.
20:03:39 <mm_freak_> spopejoy: example:  expensiveId x = 3^100000 `seq` x
20:04:02 <levi> spopejoy: I'm not sure exactly which concept you're unclear on. How sharing is implemented in a lazy language?
20:04:16 <mm_freak_> spopejoy: '1' and 'expensiveId 1' are still semantically the same program, but you will benefit from sharing a lot more
20:04:22 <levi> Or the difference between functions and general expressions?
20:04:27 <hask-> mm_freak_: basically, i was wondering if it was possible to avoid having to store that variable in main, and instead move it "up" into the functions
20:04:32 <mm_freak_> hask-: the point is that you use mkUseOnce only once
20:04:51 <mm_freak_> hask-: there are hacky ways to do that, but why would you want to?
20:05:10 <mm_freak_> hask-: you may be thinking too much in terms of storage and memory
20:05:13 <spopejoy> levi: "constant applicative form" vs functions, when sharing occurs and when it doesn't, etc
20:05:25 <mm_freak_> hask-: even if you do it, most likely the resulting program will be the same
20:05:25 <hask-> mm_freak_: i'm new to haskell yes...
20:06:03 <hask-> mm_freak_: so in haskell, a "global state" must always end up being hooked into main?
20:06:36 <mm_freak_> hask-: IO does in principle allow "global state", but there is no nice way to add your own global state, because it's not a common thing to do in haskell
20:06:36 <spopejoy> it's just interesting, b/c a lot of imperative people are actually *afraid of calling functions* because it's "expensive". laughable but it comes up.
20:06:49 <spopejoy> "isn't all that currying expensive"?
20:07:02 <hask-> mm_freak_: ok
20:07:11 <mm_freak_> spopejoy: applying functions (not "calling") is conceptually free, and you can indeed make it technically free
20:07:34 <mm_freak_> spopejoy: and i'm saying "not 'calling'", because in fact there is no actuall CALL instruction going on =)
20:07:46 <spopejoy> exactly
20:07:55 <levi> spopejoy: Well, a 'constant applicative form' is a top-level binding that's not a function.  A function is something equivalent to a lambda expression.  And sharing is how you avoid computing the value bound to a variable (at top level or with a lambda, where, or let) more than once even when the variable appears more than once in an expression body.
20:08:27 <carter> arbn: so why aren't you hanging on #numerical-haskell? :)
20:09:26 * hackagebot hackernews 0.2.2.1 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.2.2.1 (DavidJohnson)
20:10:12 <arbn> carter: I'm afraid I wouldn't be helpful there. :) I know *you* know your stuff on that topic, but I'm only a user of other people's fine libraries.
20:10:25 <carter> arbn: no, lurk and learn!
20:10:38 <mm_freak_> one interesting fact about GHC-haskell:  when you write "f(); g();" in C, then most likely f is called, returns, then g is called, returns‚Ä¶  in haskell f likely jumps to g directly =)
20:10:45 <mm_freak_> tail call elimination on steroids =)
20:10:47 <levi> Well, there's no CALL, but references to the parameters are pushed to a stack and the function entry point is jumped to.  Which is roughly what a CALL does.
20:11:18 <carter> funcall, the ultimate goto
20:11:36 <ProGunner17_> Aye what do you guys think is better android or apple regarding phones?
20:11:46 <johnw> ProGunner17_: not appropriate for this channel
20:12:06 <levi> Fortunately, you can cross-compile ghc programs for either!
20:12:16 <nitrix> Mmhh, from what I remember, CALL would push EIP on stack.
20:12:31 <exio4> levi: I was going to say "as long as GHC works..." :(
20:12:44 <exio4> I'll blame my network for the latency :P
20:12:47 <spopejoy> i'm wondering if, as a haskell programmer, not a GHC hacker or optimization worry wort, you need to distinguish between x = 1, x a = a, x = (y 1) where y z = z + 1: they're just bindings.
20:12:49 <nitrix> Which is what call optimisation tries to avoid.
20:13:22 <spopejoy> and as long as they're in a relatively tight scope, nothing will be called more than once.
20:13:24 <levi> nitrix: Well, right, GHC doesn't want to do EXACTLY what the native call instruction does, which is why it's not used.
20:13:33 <mm_freak_> spopejoy: i'm seeing two different values and one function
20:13:48 <mm_freak_> spopejoy: so no, they're definitely not the same thing =)
20:14:00 <spopejoy> i don't mean they mean the same thing
20:14:02 <exio4> functions are values!
20:14:08 <spopejoy> exactly.
20:14:21 <nitrix> That's so unatural when you come from C.
20:14:26 <exio4> I like to think of functions as "just Œªs"
20:14:27 <spopejoy> YES.
20:14:34 <mm_freak_> spopejoy: anyway, sharing always occurs when things get a name
20:14:41 <mm_freak_> spopejoy: functions sometimes need to be calculated, too
20:14:44 <spopejoy> This I think is a major stumbling block for imperativers
20:14:56 <exio4> well, coming from C, helpful type errors feel unnatural too!
20:14:56 <spopejoy> they *think* they get FP but they don't go all the way.
20:15:03 <spopejoy> lol
20:15:06 <mm_freak_> example:
20:15:28 <spopejoy> sure, pattern matching for one. evals to WHNF
20:15:31 <mm_freak_> expensive:  let myFunc x y = y + 3^x in map myFunc myList
20:15:39 <nitrix> exio4: GHC errors are scary sometimes, but it's long because it's actually really, _really_ precise.
20:15:43 <levi> C took a huge step back from other Algol-derived languages by severely restricting where functions can be defined.
20:15:45 <nitrix> I was impressed.
20:15:52 <mm_freak_> cheap:  let myFunc x = \y -> y = y + z where z = 3^x in map myFunc myList
20:16:11 <mm_freak_> uhm
20:16:11 <levi> Pascal, for example, allows the definition of functions/procedures within other functions/procedures.
20:16:24 <spopejoy> "worse is better"
20:16:30 <mm_freak_> replace 'map myFunc' by 'map (myFunc 100000)' in both examples
20:16:31 <spopejoy> New Jersey all the way
20:16:39 <arbn> spopejoy: C people get that functions are values... functions are just bytes written into memory and then referenced by the program counter. :P
20:16:41 <nitrix> I'm not a big fan of the `where` pattern or `let in`. Does that come with more functional programming experience?
20:16:48 <mm_freak_> the latter is cheaper, because 3^100000 will be calculated only once for the entire mapping
20:17:09 <Welkin> nitrix: where clauses and let statements are indispensible
20:17:17 <spopejoy> actually, some folks think that having "instructions" in one memory segment and "data" in another is super-important.
20:17:34 <mm_freak_> spopejoy: it's super-important for security reasons
20:17:35 <carter> on what cpu archtecture?
20:17:39 <levi> nitrix: Do you mean that you bind all of your auxiliary functions at the top level?
20:17:49 <carter> levi :)
20:17:55 <spopejoy> it's a criticism of P-code VMs
20:18:04 <mm_freak_> consider the definition of map:  map f = foldr (\x xs -> f x : xs) []
20:18:06 <exio4> is anyone taking proglang btw? :P
20:18:13 <mm_freak_> map gave 'f' a name, so the function is computed only once
20:18:16 <nitrix> levi: I don't really have auxiliary functions so far. It's a file system and things are pretty linear.
20:18:34 <nitrix> levi: I just use modules :/
20:18:34 <mm_freak_> myFunc x = \y -> y + z  where z = 3^x
20:18:40 <mm_freak_> myFunc itself gave 'z' a name
20:18:43 <levi> arbn: People who think that way about C might have some serious misunderstandinds about the language actually defined by the C standard.
20:19:04 <mm_freak_> so 'z' is calculated only once for the entire map
20:19:05 <spopejoy> mm_freak_: so this is really interesting. again is there any literature, or is #haskell + mm_freak_ and levi the one true way? :)
20:19:15 <mm_freak_> hehe
20:19:21 <levi> spopejoy: There's *loads* of literature about this.
20:19:32 <spopejoy> i mean *legible* literature :)
20:19:35 <mm_freak_> well, i'm not sure‚Ä¶  i've learned most of this here and there and by trial/error
20:19:46 * nitrix gives mm_freak_ a spoon.
20:19:47 <carter> literature on what
20:19:48 <spopejoy> I don't want to read anything by Oleg :)
20:19:50 <mm_freak_> however, when we talk about efficiency, i always recommend The Book
20:20:01 <carter> oleg is a source of golf not canon
20:20:05 <levi> spopejoy: Look at Simon Peyton Jones' home page and find his research papers. They're very approachable, as far as papers go.
20:20:05 <mm_freak_> http://chimera.labs.oreilly.com/books/1230000000929
20:20:32 <Welkin> I always hear about Oleg
20:20:33 <spopejoy> actually it's true, I was reading "fun with type families" and amazed that it was so approachable
20:20:38 <Welkin> mostly people complaining
20:20:38 <mm_freak_> it is mostly for parallel/concurrent programming, but also talks a lot about sharing and operation
20:20:57 <levi> spopejoy: Read the one about the Spineless Tagless G Machine, and you'll know all about how GHC compiles its code.
20:21:21 <spopejoy> That will always sound like the villian in an upcoming Ghostbusters sequel to me :)
20:21:24 <arbn> levi: Yeah, I was mostly joking. Not suggesting that people should rely on undefined behavior in practice.
20:21:29 <levi> As well as the operational semantics of Core, the intermediate language that GHC compiles to.
20:21:58 <mm_freak_> @remember spopejoy That [Spineless Tagless G Machine] will always sound like the villian in an upcoming Ghostbusters sequel to me :)
20:21:59 <lambdabot> Okay.
20:22:24 <spopejoy> oh man. that's awesome
20:22:43 <levi> arbn: Well, you can do that stuff without *undefined* behavior, but probably not without implementation-defined behavior that's outside the scope of C itself.
20:22:55 <carter> also C isn't that low level
20:22:56 <carter> not really
20:23:07 <levi> carter: Indeed.
20:23:11 <carter> its a terrible model of what modern Cpus can do
20:23:14 <carter> they can do so many nice things
20:23:18 <levi> It irks me when people call it 'portable assembly language'
20:23:21 <carter> and C doesnt' let you even think about it
20:23:23 <nitrix> C is actually very high level.
20:23:40 <nitrix> When you realise just how much is undefined/implementation-specific behavior.
20:23:42 <carter> nitrix: but in a way that prevents you from having nice things
20:23:44 <mm_freak_> two facts are true about C
20:23:54 <mm_freak_> 1. C pretends to be high level, when in fact it's extremely low level
20:23:59 <spopejoy> Welkin: I was reading Oleg before I was haskelling. Lots of LtU papers. Not getting much, but enjoying them nonetheless.
20:24:01 <mm_freak_> 2. C pretends to be low level, when in fact it's extremely high level
20:24:12 <carter> C pretends theres only 1-2 layers of memory
20:24:20 <carter> when in facts you have 4-10
20:24:24 <carter> plus registers
20:24:28 <spopejoy> Now I actually want to *understand* what I'm reading, so SPJ seems to be pulling into the lead :)
20:24:29 <levi> The assembly-like things you can do with it tend to be non-portable, and the rest of it is too high-level to resemble assembly at all.
20:24:33 <mm_freak_> C pretends that there is only one core, when in fact you have 4-8
20:24:40 <carter> mm_freak_: yeah
20:25:02 <nitrix> carter: Why would you need to care about those layers?
20:25:11 <mm_freak_> C pretends that humans can control all memory and then provides an awkward interface when it actually comes to doing it
20:25:24 <levi> spopejoy: Oleg lives in the stratosphere; SPJ walks among the mortals. ;)
20:25:27 <Welkin> C only lets you stream data in bytes!!!
20:25:36 <carter> nitrix: because theres better ways to write high levelcode that exploits those details
20:25:38 <mm_freak_> oh yeah
20:25:38 <Welkin> unlike asm, where you can stream in bits
20:25:47 <nitrix> mm_freak_: What is awkward with allocating and deallocating objects?
20:25:49 <mm_freak_> and C pretends that "byte" and "character" are the same thing
20:26:04 <nitrix> mm_freak_: That's incorrect.
20:26:07 <mm_freak_> nitrix: allocating and deallocating objects with nontrivial structure
20:26:07 <carter> i've haskell code that can can have wayyyy better cache locality than any similar sized C codes (or any sized c codse)
20:26:10 <nitrix> mm_freak_: You mean a char and a byte.
20:26:13 <levi> nitrix: You need to care about the layers precisely when you're writing the sort of programs that people turn to C to write, like operating systems or language runtimes.
20:26:25 <mm_freak_> nitrix: check sizeof(char)
20:26:36 <nitrix> mm_freak_: That's not my point. You said character instead of char.
20:26:52 <nitrix> mm_freak_: There are multiple kind of characters, wide characters for example.
20:27:12 <mm_freak_> nitrix: i strongly believe that when 'char' was invented, "character" was actually meant =)
20:27:18 <kadoban> mm_freak_: char is just C's name for a byte, there's not really anything particularly wrong with that...
20:27:25 <mm_freak_> nitrix: because in those days that was true
20:27:29 <kadoban> mm_freak_: It's a goofy name, but it doesn't really matter.
20:27:39 <levi> Yes, the definition of 'char' in C is strongly tied to representing textual characters.
20:27:53 <nitrix> mm_freak_: To your surprise, char came much latter than when they had characters. Initially they were ints.
20:27:55 <kadoban> mm_freak_: I'm rather confused by you saying C is "extremely high level" too, heh...
20:28:09 <nitrix> mm_freak_: This is one of the reason of the legacy of having '0' being of type int, not char.
20:28:11 <carter> kadoban: :)
20:28:28 <carter> i' actuallly find it easier to learn from the intel optimzation / instruction  set docments
20:28:33 <carter> than from readin c code
20:28:33 <spopejoy> kadoban: c.f. discussions from 70s that unix was too slow cuz C was "too high level" :)
20:28:40 <carter> Cpus are really fascinating
20:28:40 <mm_freak_> kadoban: it was a comment on the common notion that C is a "high level assembly" language =)
20:28:52 <carter> its like Dungeons and Dragons, the 50th edition
20:28:53 <carter> or something
20:28:57 <carter> no level cap
20:29:05 <kadoban> I see
20:29:19 <carter> also modern CPUs are probably the most complex artifacts humanity has ever designed ever in the history of the solar system to date
20:29:30 <spopejoy> the code in lion's commentary is brilliant but sometimes terrifying
20:29:33 <mm_freak_> nitrix: they could have improved it, but they found it more important to keep legacy code working
20:29:40 <levi> C mapped a bit better to PDP assembly/machine architecture than it does to modern CPUs.
20:29:45 <carter> yeah
20:29:52 <carter> i dont want a pdp tuned language
20:30:05 <carter> levi: at some point i'll write  a low level lang for cpu stuff
20:30:09 <nitrix> I wish we could ditch x86.
20:30:10 <carter> out of rage and yaks
20:30:14 <carter> nitrix: we have
20:30:19 <nitrix> Even x64 is a hack on top of x86.
20:30:19 <carter> internally the cpus use microcode
20:30:21 <spopejoy> for what?
20:30:35 <carter> the cpu actually translates xwhatever into microcode internally
20:30:37 <MP2E> microoptimizations
20:30:41 <kadoban> If you want to ditch x86, you can. Use ARM
20:30:50 <carter> which one
20:30:53 <carter> theres so many!
20:30:55 <carter> > 8 arms!
20:30:57 <lambdabot>  <hint>:1:8:
20:30:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:30:59 <kadoban> Hah
20:31:02 <MP2E> it compiles to microcode so that it can move the microinstructions around to better utilize the components in parallel
20:31:06 <carter> yeah
20:31:11 <mm_freak_> carter: as long as we boot into 16 bit real mode (and do that in an extremely stupid way), we haven't ditched x86 =)
20:31:13 <carter> and theres a lot more registers than you realize
20:31:21 <mm_freak_> even if we just emulate it, it's still there
20:31:25 <carter> hehe
20:31:27 <nitrix> I don't know, it's just the accumulation of hacks that makes no sense. Like the A20 bus line hack.
20:31:29 <mm_freak_> that's why i actually like UEFI
20:31:31 <arbn> carter: Well, it's not as if implementing the x86 instruction set doesn't have some disadvantages. It depends what you mean by 'ditching'.
20:31:31 <levi> ARM makes a whole family of processor specifications. And then various companies create different realizations of those specifications.
20:31:47 <carter> yeah
20:31:52 <carter> so "ARM" is kinda vague
20:31:59 <carter> the tools USUALLY mostly work toegether
20:32:03 <carter> but thats .... not always true
20:32:09 <nitrix> You don't purposedly break your hardware because programmers are relying on some undocumented behaviors.
20:32:18 <carter> yeah
20:32:32 <nitrix> They didn't follow the specs, though luck.... now x64 is stuck with that A20 thing too :/
20:32:32 <carter> hardware has stronger reliabllity needs than software
20:32:38 <carter> whats A20?
20:32:45 <kadoban> I'm not sure it matters that it's vague. If he wants to ditch x86, he can pick whatever ARM chip works best for his needs and go to town. *shrug*
20:32:50 <mm_freak_> carter: a historical mistake
20:33:19 <mm_freak_> carter: it's a setting that controls whether memory addresses are taken modulo 2^20 or not
20:33:33 <spopejoy> last typeable q: is it considered "typesafe" because casting returns Maybe?
20:33:58 <joelteon> what does typesafe mean?
20:34:12 <nitrix> Means Haskell! :D
20:34:13 <mm_freak_> carter: totally irrelevant to x86 protected or x64 long mode, but even today needs to be handled by the boot loader in a complicated and tiring way
20:34:18 <carter> ok
20:34:19 <carter> well
20:34:19 <spopejoy> b/c the main thing that bums me out about Typeable is I feel like I won't be using the type system to verify my code anymore
20:34:25 <carter> spopejoy: nope
20:34:27 <carter> you wiill
20:34:32 <levi> Returning a Maybe type is a common idiom to represent a partial operation as a total function.
20:34:34 <carter> just design our api better
20:34:40 <carter> and Maybe and Either are AWESOME
20:34:51 <mm_freak_> spopejoy: Typeable is a bit magic‚Ä¶  you don't write instances for Typeable
20:34:52 <joelteon> spopejoy: what do you think you would be using Typeable for?
20:34:59 <kadoban> Is there any way to use stackage just for one sandbox, or something? I'd like to try it out, but don't particularly want to do it globally.
20:35:09 <spopejoy> what i was discussing above, heterogenous map etc.
20:35:10 <nitrix> Maybe and Either are by far my favorite thing about haskell so far. But I'm still unexperienced.
20:35:30 <carter> spopejoy: think of it diffferently
20:35:34 <spopejoy> it just seems like there should be some way to "encapsulate" types
20:35:35 <mm_freak_> spopejoy: first of all, there is seldomly a reason to have heterogenous maps/lists/whatever
20:35:39 <carter> think of a look up as being  (key, type)
20:35:43 <joelteon> use a sum type instead...
20:35:45 <spopejoy> there is though
20:35:46 <carter> where there only at most onetype per key
20:35:47 <levi> My favorite thing about Haskell is that you can make the pain of using Maybe/Either go away.
20:35:50 <joelteon> I don't even know if you can have Typeable a => Map k a
20:35:53 <carter> joelteon: yeah, your right
20:35:57 <spopejoy> music composition. you need to be able to define attributes in client code.
20:36:00 <jle`> hear hear levi
20:36:01 <carter> joelteon: you have to wrapp it
20:36:13 <spopejoy> and stick them on your notes, bars, systems in a unified way.
20:36:20 <mm_freak_> spopejoy: in the few cases when you really need run-time types, Typeable is a solution that works
20:36:20 <joelteon> yeah, that doesn't make sense
20:36:23 <jle`> and you can' have an attribute type?
20:36:25 <carter> whats the music dls ?
20:36:29 <mm_freak_> and we really only have Typeable because we lack dependent types
20:36:30 <carter> *DSL
20:36:32 <spopejoy> my own
20:36:38 <dfeuer> levi, by .... writing in continuation passing style? What pain are you referring to?
20:36:39 <spopejoy> NIH is my religion :)
20:36:40 <jle`> why can't you have an Attribute type?
20:37:26 <spopejoy> I was hoping I could use Type families to make like a "sequence of types"
20:37:33 <spopejoy> that was somehow extensible
20:37:43 <dfeuer> Type families is weird shit.
20:37:44 <spopejoy> but my little brain exploded.
20:37:56 <spopejoy> actually just shut down, not explode.
20:37:58 <jle`> i still don't see how the best solution to this is a heterogeneous map...
20:38:03 <spopejoy> it isn't
20:38:05 <levi> dfeuer: I mean there are various tools that make it easy to compose Maybe/Either-returning functions with each other and bare-value-returning functions.
20:38:06 <spopejoy> oh
20:38:06 <mm_freak_> dfeuer: haskell allows you to deal with Maybe and Either algebraically
20:38:07 <jle`> why can't you just use normal types
20:38:23 * dfeuer still does not really understand the relationship between data families and GADTs.
20:38:30 <spopejoy> because I need to have code operate on my DS that doesn't necessarily know about MySpecialTypeSafeAttribute
20:38:36 <dfeuer> levi, ah, I see.
20:38:51 <nitrix> Today I wanted to break Haskell. I tried to cons a value to an infinite list! I though that was clever enough... nope.
20:39:00 <mm_freak_> spopejoy: haskell beginners are often tempted to use stuff like that to be able to return to their previous language's paradigm =)
20:39:13 <dfeuer> I hope E.Z. Yang hasn't gone to sleep.
20:39:17 <spopejoy> yes, but you see it all over music DSLs.
20:39:23 <mm_freak_> spopejoy: you will eventually figure out the haskelly way to encode types like that, and most likely you won't need Typeable
20:39:25 <nitrix> Haskell too smart.
20:39:28 <jle`> in other languages, or in haskell?
20:39:34 <spopejoy> haskore
20:39:42 <spopejoy> not haskore actually
20:40:02 <spopejoy> haskore instead tries to hammer everything into a "Medium" which in the end is like a Monoid, but lamer
20:40:11 <spopejoy> I want simplicity
20:40:22 <mm_freak_> dfeuer: GADTs are closed and have a certain set of constructors
20:40:23 <spopejoy> other haskell music dsls just use Typable
20:40:30 <mm_freak_> dfeuer: data families are open
20:41:00 <dfeuer> mm_freak_, is closed/open the *only* difference? Or is there something else?
20:41:03 <carter> mm_freak_: i'm trying to get some ghc folks to thinka bout closed data families
20:41:08 <carter> dfeuer: thers a difference
20:41:14 <spopejoy> I was hoping that I could somehow "encode" my types into a *not* heterogenous DS, but instead a bounded collection of label type->value type pairs
20:41:15 <carter> type inference works diffeent
20:41:18 <dfeuer> o.O
20:41:26 <carter> dfeuer: i've a ticket on track
20:41:32 <carter> https://ghc.haskell.org/trac/ghc/ticket/9667#comment:2
20:41:32 <mm_freak_> dfeuer: data families don't give you type refinement by themselves
20:41:46 <carter> mm_freak_: i get better inference for data families for a certain class of refinement
20:41:47 <dfeuer> carter, I saw it, but did not understand it. Nor do I know what "type refinement" is.
20:41:55 <arbn> spopejoy: You mention Haskore. I thought Euterpea was mostly replacing that?
20:41:57 <carter> dfeuer: try the example in my ticket
20:42:02 <carter> follow the directions
20:42:11 <spopejoy> Uh huh. Try running Eurerpea on anything but windows. Bzzt.
20:42:12 <dfeuer> FOLLOW THE YELLOW BRICK ROAD!
20:42:16 <dfeuer> Looking, carter.
20:42:22 <mm_freak_> dfeuer: pattern-matching on a GADT value can make some previously polymorphic type variables less polymorphic
20:42:36 <zq> :t fromMaybe
20:42:38 <lambdabot> a -> Maybe a -> a
20:42:39 <spopejoy> that's a showstopper for me. MUST WORK IN EMACS.
20:42:47 <mm_freak_> dfeuer: data Something :: * -> * where SomeInt :: Int -> Something Int; SomeString :: String -> Something String
20:43:08 <carter> dfeuer: i think the soluition is to recognize when gadt's satisfy a "data family like constructor injectiivyt"
20:43:34 <mm_freak_> dfeuer: when you pattern-match and find a 'SomeInt x', for the scope of the case body you will know that 'x' is of type Int, even if the original value was 'Something a' for a polymorphic 'a'
20:43:42 <levi> spopejoy: You probably can do something like that, though I couldn't tell you how.
20:43:43 <dfeuer> Right.
20:44:16 <levi> spopejoy: I use emacs in Windows quite a bit.
20:44:23 <mm_freak_> and that exact idea combined with data families might solve spopejoy's problem =)
20:44:29 <spopejoy> levi: me too. but at home/with music, it's OSX
20:44:31 <mm_freak_> but enough smalltalk for today
20:44:36 <mm_freak_> see you people =)
20:44:39 <dfeuer> As an outsider who is not a type system master, it kind of looks like there's a lot of overlapping functionality in that realm, with blurry lines.
20:45:01 <spopejoy> dfeuer: that won't work actually
20:45:04 <spopejoy> i tried it
20:45:06 <dfeuer> But the lines may be clearer than they appear to someone who understands them better.
20:45:17 <dfeuer> spopejoy, what won't work actually?
20:45:27 <levi> dfeuer: There are a lot of overlapping things in the 'advanced type system features' realm in GHC.
20:46:08 <spopejoy> well, I was talking about existential types making a heterog. list, and then trying to pattern match the contents.
20:46:48 <spopejoy> that's not what mm_freak_ was doing, but I tried TFs too. It still seems like at the end of the day, everyone has to agree on the type.
20:47:01 <spopejoy> BUT: I don't claim to understand TFs yet.
20:47:19 <carter> spopejoy: have you tried using hlist?
20:47:26 <justin_smith> I'm experimenting with a very simple iterative function - how would I go about making the step function here point free? converger = iterate (\x -> 1.1 * ((-8) + x))
20:47:27 <carter> dont worry about understanding it
20:47:29 <carter> just try it out
20:48:15 <dfeuer> levi, too much overlap makes things confusing.
20:48:28 <spopejoy> carter: is HList a Typeable thing, or dependent types, or ...?
20:48:40 <carter> spopejoy: GO PLAY WITH IT
20:48:44 <spopejoy> :)
20:48:47 <spopejoy> okeydoke
20:49:01 <carter> you'll be scared when you look at the haddocks,
20:49:03 <carter> ignore that
20:49:11 <carter> and write stuff and see what happens
20:49:14 <spopejoy> good advice. I shall return.
20:49:28 <levi> dfeuer: Well, yeah, but this is what happens when you venture into the unknown and have various people coming up with various ideas on how to solve problems.
20:49:29 <carter> becasue
20:49:30 <carter> we have types
20:49:34 <carter> so you can try dumb stuff
20:49:41 <carter> and tye type checker will give you feedback
20:49:44 <carter> even if you ddint read the docs
20:49:53 <spopejoy> "docs". this is haskell.
20:49:55 <spopejoy> :)
20:50:20 <levi> dfeuer: If this had been some well-established area of production type systems, I'm sure there would be one nice handy general solution in place.
20:51:02 <dfeuer> Some things have good docs. For some things, reading the source code is easy. For some things, reading the types is sufficient and easy. For other things, well, you can always panic and give up.
20:51:16 <bitemyapp> spopejoy: why the scare quotes? Tons of Haskell stuff has docs.
20:51:30 <dfeuer> Indeed.
20:51:32 <bitemyapp> spopejoy: HList doesn't really, but that's Olegoverse.
20:51:41 <bitemyapp> trial-by-repl
20:51:43 <MP2E> megalolegoverse
20:52:08 <dfeuer> And Ekmett tends to write his documentation for category theorists.
20:52:09 <levi> megaolegadon
20:52:21 <dfeuer> And so does Gabriel Gonzales.
20:52:40 <bitemyapp> dfeuer: nah, give tekmo more credit than that.
20:52:40 <spopejoy> oh yeah, like Read right? :)
20:52:50 <bitemyapp> dfeuer: have you seen the Pipes tutorial module? It's srs-face.
20:52:51 <spopejoy> tell me where to go to learn how to implement Read
20:52:54 <spopejoy> :)
20:53:02 <bitemyapp> spopejoy: the report
20:53:04 <dfeuer> bitemyapp, he writes blog posts for other people, but haddocks? Not so much.
20:53:13 <merijn> spopejoy: "deriving (Read)", done :)
20:53:17 <bitemyapp> dfeuer: blacktip
20:53:19 <bitemyapp> er
20:53:21 <bitemyapp> wrong link
20:53:25 <bitemyapp> dfeuer: http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html
20:53:26 <dfeuer> bitemyapp, have you looked at any of the pipes stuff aside from the tutorial?
20:53:39 <spopejoy> another winner: regex.
20:53:43 <ProGunner17_> INTRICATE-BIOS coding is the complex language who arts would not configure your knowing of this knowledgeable Chat: ([http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org])....
20:53:45 <bitemyapp> dfeuer: multiple modules have tutorial sections.
20:53:46 <spopejoy> another winner: parsec.
20:53:54 <merijn> That' sbecause almost no one uses regexes
20:53:55 <ProGunner17_> My question occupational quiz question earlier was a question to know whether you guys are not as intellectually thinkers as you may presume‚Ä¶ My question earlier was, ‚ÄúAye what do you guys think is better Android or Apple regarding phones? You past the test! My name is John Jones, the best hacker is the world, just got out of prison‚Ä¶  Whose up for the start of the an free international society Called the, ‚ÄúHackers USA,‚
20:53:57 <spopejoy> lots of packages have docs on a diet.
20:53:58 <bitemyapp> spopejoy: parsec is problematic.
20:54:08 <ProGunner17_> You guys better say yes‚Ä¶ It‚Äôs your only choice or else.          ERROR, ERROR, ERROR_______ for those of you know what this is!!!!!!!!!!
20:54:10 <MP2E> ProGunner17_: needs kicking, it seems, probably a markov bot
20:54:10 <merijn> spopejoy: Parsec had good docs, but their Univertsity page went down when the author moved on
20:54:13 <dfeuer> spopejoy, parsec has a website. Is there anything good there?
20:54:27 <bitemyapp> please don't flag the ops.
20:54:30 <MP2E> ok
20:54:31 <bitemyapp> just grab somebody that seems awake.
20:54:37 <levi> At least while he was actively developing Pipes, the best way to figure out how to do something in Pipes was to poke tekmo and wait for him to post a hpaste that implemented it for you.
20:54:42 --- mode: ChanServ set +o dibblego
20:54:42 <bitemyapp> I hate it when people blast the horn for a single relatively harmless bot.
20:54:46 <bitemyapp> dibblego: thank you.
20:54:47 <MP2E> haha
20:54:47 --- mode: dibblego set +b *!*acf93d47@*.172.249.61.71
20:54:51 --- kick: ProGunner17_ was kicked by dibblego (ProGunner17_)
20:54:57 <spopejoy> Parsec is fine. Just read Diehl's "write an LLVM interpreter" or that "write you a scheme". who needs docs.
20:54:57 --- mode: dibblego set -o dibblego
20:54:57 <bitemyapp> @karma+ dibblego
20:54:58 <lambdabot> dibblego's karma raised to 5.
20:55:13 <bitemyapp> spopejoy: there are more worked up tutorials than that even.
20:55:24 <spopejoy> I'm sure. My joke was:
20:55:24 <merijn> bitemyapp: That's what the ops command is for...
20:55:35 <bitemyapp> merijn: considering how we didn't need it just now.
20:55:40 <dfeuer> Why do people bother writing bots just to annoy IRC users?
20:55:42 <spopejoy> you usually need more than the API docs, given how deep some of the concepts are.
20:55:51 <bitemyapp> merijn: yeah kinda, but I'd reserve it for when you need a op sharpish.
20:56:07 <MP2E> dfeuer: if tuned properly, markov bots can actually be pretty funny and an enjoyable part of a channel.. but in a formal setting like this... i don't get it either
20:56:19 <bitemyapp> we also didn't ask for it.
20:56:32 <justin_smith> a good bot speaks only when spoken to
20:56:32 <MP2E> also that yes ;P
20:56:37 <bitemyapp> justin_smith: yes.
20:56:59 <spopejoy> @quote asimov
20:57:00 <lambdabot> No quotes match. I am sorry.
20:57:15 <MP2E> surprisingly polite of lambdabot
20:57:35 <levi> Woo, I have a fresh version of Yi running now.
20:57:36 <spopejoy> @quote Ghostbusters
20:57:37 <lambdabot> spopejoy says: That [Spineless Tagless G Machine] will always sound like the villian in an upcoming Ghostbusters sequel to me :)
20:57:43 <spopejoy> had to try it out.
20:57:44 <dfeuer> @quote lambdabot
20:57:44 <lambdabot> lambdabot says: *** "Jezebel" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)": Jezebel, chaste
20:58:03 <bitemyapp> @quote edwardk
20:58:03 <lambdabot> edwardk says: <aristid> a dubious motivation IMHO <edwardk> meh <edwardk> i've had worse =P
20:58:26 <spopejoy> too much comedy. I'm to bed! onwards
20:59:28 * hackagebot helics 0.1.3 - New RelicÆ agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.1.3 (HirotomoMoriwaki)
21:02:41 <carter> @quote carter
21:02:42 <lambdabot> carter says: i'll leave you in the gentle hands of the rest of the channel
21:02:49 <carter> topical even!
21:04:36 <merijn> @quote merijn
21:04:36 <lambdabot> merijn says: Haskell is debugging the ptr/type errors in my C interface for me \o/
21:04:44 <merijn> I wish it still did that...
21:06:37 <justin_smith> any hints on making this point-free: \x -> 1.1 * ((-8) + x)
21:06:54 <carter> whats the pointfree command?
21:06:57 <numberten> did you try @pl?
21:07:05 <carter> @pl  \x -> 1.1 * ((-8) + x)
21:07:05 <lambdabot> (1 . 1 *) . (-8 +)
21:07:17 <justin_smith> I did not know about this command, thank you
21:07:22 <numberten> teamwork
21:07:42 <numberten> yeah @pl is my #1 used lambdabot command, it's really really nice
21:08:35 <justin_smith> that doesn't actually work
21:08:58 <carter> why not?
21:09:12 <carter> ooo
21:09:14 <justin_smith> that code doesn't run
21:09:21 <carter> :t 	 (1 . 1 *) . (-8 +)
21:09:23 <lambdabot> (Num (a -> c), Num (a -> b), Num (b -> c)) => (a -> c) -> a -> c
21:09:29 <carter> it misparsed 1.1
21:09:33 <carter> :t 	 (1.1 *) . (-8 +)
21:09:34 <lambdabot> Fractional c => c -> c
21:09:36 <carter> bam
21:09:47 <carter> justin_smith: bam
21:10:00 <dfeuer> @pl \x -> 11/10 *((-8) + x)
21:10:00 <lambdabot> ((11 / 10) *) . (-8 +)
21:10:21 <carter> gam
21:10:22 <carter> yay
21:10:25 <carter> dfeuer++
21:10:32 <dfeuer> Wheeee
21:10:39 <carter> @karma dfeuer
21:10:39 <lambdabot> dfeuer has a karma of 2
21:10:42 <carter> dfeuer++
21:10:44 <carter> fixed
21:10:49 <dfeuer> :-P
21:11:17 <dfeuer> @karma carter
21:11:17 <lambdabot> carter has a karma of 8
21:11:30 <carter> @karma edwardk
21:11:31 <lambdabot> edwardk has a karma of 42
21:11:39 <carter> secrete of life
21:11:48 <dfeuer> o.O
21:13:45 <johnw> carter: did you find anyone to run your programs for you?
21:13:57 <carter> johnw: well, i tested basic ghc stuff
21:14:32 <zq> what's the appropriate way of including test data into a cabal package?
21:15:26 <merijn> zq: There's an "extra-src-files" and "extra-data-files" field, or something along those lines
21:15:37 <carter> yes
21:15:59 <carter> johnw: well, merijn  says he'll test run 32bit OS X validate after hes done bricking his computer
21:16:06 <carter> :)
21:16:47 <merijn> carter: Another reason to hope it boots further soon-ish :p
21:16:52 <carter> :)
21:17:36 * dfeuer steals merijn's computer before he can brick it completely.
21:17:43 <zq> merijn: what's the difference?
21:18:04 <zq> blah, there is no extra-data-files
21:18:39 <dfeuer> carter, is 32bit OSX still used?
21:18:42 <merijn> zq: Consult the cabal user guide for a full list of fields
21:18:49 <carter> dfeuer: its called OS X
21:18:52 <carter> it has both bitnesses
21:18:54 <merijn> dfeuer: There is only 32bit OSX
21:19:03 <carter> dfeuer: i'm told that dropbox app is 32bit
21:19:07 <carter> by tk-
21:19:09 <dfeuer> What does this mean?
21:19:23 <carter> it means each process on OS X is either in 32bit or 64 bit mode
21:19:24 <merijn> dfeuer: That the kernel (last I checked, during 10.7) runs in 32bit mode
21:19:41 <merijn> dfeuer: User code can run in 64bit mode, but it's mandatory
21:19:51 <dfeuer> Mandatory?
21:19:56 <merijn> eh, not
21:20:00 <dfeuer> AH.
21:20:03 <carter> merijn: does tha mean kernel patches / extensions need to be 32bit?
21:20:12 <merijn> dfeuer: Also, contrary to popular believe 64bit is not strictly better than 32bit
21:20:21 <carter> liike, if i wanted to add ... SCTP support to OS X  i'd hve to write 32bit haskell?
21:20:23 <merijn> carter: Yes, although, like I said, this was 2 versions ago :)
21:20:30 <carter> merijn: how'd you check?
21:20:32 <dfeuer> Isn't 32/64 mode something that would be more useful at a finer grain than process?
21:20:37 <merijn> carter: Consult the docs
21:20:50 <merijn> dfeuer: No, it doesn't really make sense at a finer grain
21:20:57 <dfeuer> merijn, because it is bigger and eats more cache, I assume?
21:21:00 <merijn> dfeuer: You need to be in kernel mode to switch
21:21:03 <merijn> dfeuer: Correct
21:21:21 <merijn> dfeuer: It's also why, for example, even in 64bit "int" in C is 32bit on OSX
21:21:21 <dfeuer> merijn, I don't mean in practice; I mean in theory.
21:21:42 <merijn> dfeuer: It's a big hassle to switch between the two
21:21:51 <dfeuer> A 64 bit "int" in C is 32bit on OS X.... I cannot parse that.
21:22:01 <merijn> dfeuer: Per process is ok, because context switching is expensive anyway
21:22:06 <merijn> dfeuer: int is not 64bit
21:22:19 <carter> haskell INt is INtPtr
21:22:20 <merijn> dfeuer: I'm saying "the 64bit C compiler on OSX uses 32bit values for int"
21:22:21 <dfeuer> int is not 64 bit I can understand.
21:22:28 <carter> C INt  == INt32
21:22:53 <dfeuer> 64-bit compiler = produces 64-bit instructions? Or something?
21:22:55 <merijn> carter: C int can be whatever the compiler wants, given it's at least 32bits (I think)
21:22:58 <merijn> dfeuer: Yes
21:23:05 <merijn> dfeuer: Using 64bit registers, etc.
21:23:31 <merijn> hell, you could have 34bit int
21:23:49 <dfeuer> Oh, I'd have thought the individual instructions would determine registers. But I guess if the registers are fake that may not apply.
21:24:18 <merijn> dfeuer: You cannot explicitly address all registers in 32bit mode
21:24:38 <merijn> I believe 32bit only (let's be more precise: x86) has 8 (?) addressable registers
21:24:41 <carter> merijn: well, reid and i've been slowly thinking about doing an x32 mode
21:24:49 <carter> he prototyped a hacky one a while ago
21:24:49 <dfeuer> merijn, what is C supposed to report for sizeof (int) if int is 34 bit and char is 7 bit?
21:24:59 <carter> 13
21:25:09 <merijn> dfeuer: Impossible
21:25:11 <carter> it was ~20%  faster across the board
21:25:18 <merijn> dfeuer: Every C value size is a multiple of char
21:25:25 <dfeuer> Yeah, that's what I thought.
21:25:33 <dfeuer> Which makes it very hard to have a 34 bit int.
21:25:46 <dfeuer> Because sizeof char >= 7, as I recall.
21:25:50 <carter> uname -a # tells you what bitness
21:26:02 <dfeuer> So you'd need sizeof char = 17 or sizeof char = 34
21:26:03 <carter> time for bed
21:26:05 <dfeuer> Both of which are insane.
21:26:16 <dfeuer> NIGHT carter
21:26:20 <dfeuer> NIGHT CARTER
21:26:49 <merijn> dfeuer:
21:27:26 <dfeuer> Sorry, merijn, I realized only later that a 34-bit char is sane.
21:27:27 <dfeuer> ish.
21:27:35 <levi> dfeuer: sizeof (char) == 1 by definition
21:27:42 <merijn> defeuer: Eh, why?
21:27:43 <merijn> (Sorry, my machine is inasnely laggy...)
21:27:58 <dfeuer> levi, yes, you're right, but I think you know what I meant to say.
21:28:40 <levi> The bit-width of char is determined by the machine architecture, and it's supposed to be related to the basic character set.
21:28:45 <dfeuer> merijn, well, everything is sane, I suppose. If your machine word size is 34, then you can't fit more than one Unicode codepoint in a word.
21:29:09 <solatis> can anyone give me some pointers on what to google for when i'm looking for a way to write a function to automatically convert between object types?
21:29:16 <merijn> jesus, typing into irssi is lagging by 40 seconds...
21:29:33 <dfeuer> solatis, "typeclass"
21:29:43 <levi> solatis: What do you mean by "automatically convert"?
21:29:54 <solatis> specifically, I have some data structure MyData, and I want it to be automatically converted to a Database.Mongo.Document without having to explicitly call a conversion function
21:29:55 <dfeuer> solatis, but also "What are you *really* trying to do?*
21:30:15 <AshyIsMe> now you guys have got me reading about ternary computers
21:30:20 <AshyIsMe> http://en.wikipedia.org/wiki/Ternary_computer
21:30:23 <dfeuer> @google "Don't do that."
21:30:24 <lambdabot> http://www.youtube.com/watch?v=0qkj4_U9vsg
21:30:24 <lambdabot> Title: Don't Do That.wmv - YouTube
21:30:37 <solatis> I feel like I need to write 'instance MyData where ....' or something, but having trouble figuring out where to find a good explanation on how to do so
21:30:42 <merijn> finally
21:30:49 <napping> Which Applicatives have a naturall f (f a -> a)?
21:30:50 <merijn> irssi is acting normal again
21:31:14 <merijn> dfeuer: Anyway, what does unicode have to do with anything?
21:31:38 <dfeuer> merijn, the notion of char as character.
21:31:45 <dfeuer> Nothing more.
21:31:52 <merijn> Such a notion doesn't really exist
21:31:53 <dfeuer> Sorry, random babbling.
21:31:54 <levi> solatis: I'm afraid you're going to be disappointed if you want implicit conversions.
21:32:17 <merijn> dfeuer: The standard only specifies that a char can hold any value of the relevant character set
21:32:31 <merijn> dfeuer: Which I think doesn't even guarantee 8 bits
21:32:33 <dfeuer> Because implicit conversions turn out to be very bad, and mostly are very bad.
21:32:45 <dfeuer> merijn, as I recall, the original standard guaranteed 7.
21:32:50 <dfeuer> (at least 7)
21:32:56 <dfeuer> I don't know about newer standards.
21:32:57 <napping> Does that just come from (co)representability?
21:32:58 <merijn> dfeuer: I'm sure it guarantees at least 7, yes
21:33:19 <merijn> Just not sure whether it guarantees 8 and my machine is acting up to much to check
21:33:31 <dfeuer> I think it *didn't*, but it might these days.
21:37:58 <levi> C89 doesn't say anything about the minimum bit-width of a byte/char, except that it's large enough to hold a member of the basic character set.
21:38:37 <levi> And no C standard has given a specific bit-width for a byte/char.
21:39:35 <levi> My coworkers occasionally use a DSP processor that has a C compiler where the bit-width of char is 32.
21:40:00 <merijn> levi: I know
21:40:10 <merijn> levi: C11 guarantees at least 7 bits for char, though
21:40:15 <merijn> Perhaps 8, I'm not sure
21:41:14 <levi> Well, the main thing that determines it is the smallest addressable unit of memory in the CPU architecture.
21:41:49 <levi> "It shall be possible to express the address of each individual byte of an object uniquely."
21:47:39 <solatis> hmm i'm not sure if my previous question got through, the wifi was timing out
21:48:38 <solatis> i'm looking for a way to automatically convert my data type to another data type -- i feel like i need to write an instance Show MyType ... for this, but having trouble figuring out what to google for to find a (simple!) example on how to do this
21:49:10 <CrazyM4n> Is there any real benifit to learning vim to program haskell?
21:49:16 <solatis> in my c++ experience, it was as simple as defining a constructor for MyData that, for example, accepted  a String -- the compiler would automatically be able to deduce a MyData from a String
21:49:20 <CrazyM4n> What's the benefit vs. the difficulty?
21:49:24 <solatis> what is the Haskell equivalent for this?
21:49:42 <levi> merijn: It appears that 7 bits are required for char, but that's implicit in the size of the list of required characters in the basic set that must fit in a byte.
21:50:06 <dmj`> solatis: there is read, but it throws an exception on parse failure, I recommend readMaybe, which is pure, for anything more sophistiacted use parsec, if performance is critial than attoparsec
21:50:27 <dmj`> let a = read "3" :: Int
21:50:38 <solatis> so I need to define an instance Read MyType ?
21:50:58 <solatis> and then I can do read "foo" :: MyType ?
21:50:59 * simukis_ was surprised that his trivial program written for 7.8 did compile with 7.4, given how much breakage ghc experiences.
21:51:19 <levi> solatis: If your type is composed of types that are already members of the Read class, you can simply derive Read.
21:51:43 <solatis> no, it is about converting a Database.Mongo.Document to a MyType
21:51:56 <dmj`> > read "3" :: Int
21:51:58 <lambdabot>  3
21:52:33 <solatis> but a Document is defined as a [Field]
21:52:58 <CrazyM4n> Has anyone had positive experiences with Helm? It seems like fun, but I don't know
21:53:52 <dmj`> solatis: maybe you should post code
21:54:09 <solatis> yeah i will
21:54:20 <solatis> i'll first get some lunch and then post some code
21:54:28 <dmj`> CrazyM4n: try it and let me know, I'm curious too
21:54:30 <solatis> but i think i'm on the right track
21:55:12 <CrazyM4n> dmj`: Will do
21:55:19 <CrazyM4n> Once I can get it to install
21:55:35 <solatis> maybe i'll just keep things simple and use an explicit conversion function for now, and try to get all fancy when i'm ready for some haskell magic
21:57:01 <alanoth> hello, everyone. I wanted to know if there is anyone willing to guide me for the google summer of code.
21:57:16 <CrazyM4n> alanoth: How does the google summer of code work?
21:57:19 <CrazyM4n> I could help, maybe
21:57:21 <CrazyM4n> It depends
21:58:09 <alanoth> It's an event for university students around the world, where google collaborates with a lot of open source organizations
21:58:37 <alanoth> These organizations (including haskell.org) provide mentorship towards completion of projects by students
21:58:47 <alanoth> It's like an internship, only long-distance
21:59:05 <CrazyM4n> That's cool!
21:59:36 <CrazyM4n> Uhm, I could help with some things, but I'm not a master at haskell or anything
21:59:45 <alanoth> Yeah, I wanted to know how much I need to study. Which books to read and other stuff that might be helpful
21:59:46 <CrazyM4n> What kind of things are you trying to do?
21:59:50 <CrazyM4n> Oh
22:00:06 <CrazyM4n> I personally loved the wikibook, it explained everything clearly
22:00:40 <alanoth> yeah, I had hoped to find someone who is a mentor for haskell.org
22:01:02 <alanoth> Maybe he could also tell me whether the idea that I have would be acceptible as a project
22:01:09 <CrazyM4n> I see
22:01:18 <CrazyM4n> Maybe there is an IRC where the mentors are hanging out?
22:01:24 <alanoth> I wanted to create a clone of mathematica's dynamic plotting abilities
22:01:35 <alanoth> There maybe one, hopefully
22:02:04 <levi> solatis: The data type that the mongo library uses is defined in the bson package. Unfortunately, bson doesn't supply the nice translation mechanisms that the aeson library supplies for JSON.
22:02:12 <CrazyM4n> That's quite a big project. Do you have a starting point?
22:02:17 <alanoth> Also, i'm a mathematics student. Should I learn about category theory?
22:02:46 <alanoth> No, it's just the plotting facilities. LIke you can plot some function and then manipulate its parameters
22:02:48 <levi> solatis: See the 'FromJSON' typeclass in the aeson library for an example of how what you want might be implemented.
22:02:51 <CrazyM4n> Well, it's useful to know what haskell uses (like monads and etc.), but I don't think going through and learning all of category theory is neccesary
22:03:09 <CrazyM4n> And oh, I thought you meant something else
22:03:13 <alanoth> There may be ways (standard, commonly used libraries) that allow for plotting.
22:03:17 <CrazyM4n> Definately sounds like fun though
22:03:24 <CrazyM4n> And yes, there are
22:03:34 <alanoth> I was thinking of just making it all dynamic, and packaging it as a software for mathematical analysis
22:03:51 <alanoth> Like a box where you can study mathematical functions
22:03:52 <solatis> levi: yeah i was already usng Aeson, but now i decided to just resort to Bson as my data serialization mechanism for other uses too
22:03:55 <levi> alanoth: category theory is sort of the deep end of the pool off in the direction of the 'abstract algebra' region of math.
22:03:58 <alanoth> Others can then extend it
22:04:00 <CrazyM4n> I get what you're saying
22:04:19 <CrazyM4n> Are you planning on rolling your own plotting library or taking a currently existing library and adding capabilities on top of it?
22:04:23 <alanoth> I love exploring new areas of mathematics.
22:04:35 <levi> Go for it then. :)
22:04:38 <alanoth> A current library would be easier :)
22:04:40 <CrazyM4n> And definately, math is great :D
22:04:43 <alanoth> levi: Thanks :)
22:04:46 <solatis> in an Ideal World, I would define some FromBson and ToBson functions like Aeson has
22:04:47 <CrazyM4n> Well, there's plot
22:04:51 <CrazyM4n> @hoogle plot
22:04:52 <solatis> and commit a patch for that
22:04:52 <lambdabot> package plot
22:04:53 <lambdabot> package plot-gtk
22:04:53 <lambdabot> package plotserver-api
22:05:01 <solatis> but I have no idea where to start with that
22:05:14 <levi> solatis: Well, like I said, take a look at how aeson does it.
22:05:22 <alanoth> thanks for the info. I'll have to look that up
22:05:24 <solatis> i will
22:05:42 <solatis> thanks for the advice
22:05:43 <CrazyM4n> alanoth: Make sure to tell me about it!
22:06:00 <CrazyM4n> alanoth: Take a look at desmos, it can do things like that
22:06:05 <CrazyM4n> Just as a side thought
22:06:08 <solatis> somebody also wrote a structured-mongo haskell library, which might be doing what i want
22:06:25 <alanoth> CrazyM4n: Also, I have as of now read 9 chapters from learn you a haskell, 6 from real world haskell and written about 1500 lines of haskell code altogether
22:06:31 <alanoth> Where should I go from here?
22:06:37 <levi> solatis: It's not really super-complicated, it's just a matter of creating the type classes with basic marshall/unmarshal functions in them, and then writing a bunch of instances for basic types.
22:07:07 <CrazyM4n> Uhm
22:07:30 <CrazyM4n> Probably just jump into it!
22:07:35 <CrazyM4n> There's a whole community to help you :)
22:07:51 <alanoth> Will the wikibook be a fine place, I'm not unwilling to revise. If it covers a good amount of haskell.
22:08:18 <alanoth> CrazyM4n: The community is awesome :)
22:08:27 <solatis> levi: yeah but you have to understand that i'm still a haskell newbie, so it might be too much to grasp for me at this point
22:08:38 <solatis> but we'll see
22:08:48 <solatis> i'll put a few hours of mental energy into it :)
22:09:07 <solatis> the worst thing that can happen is that i learn something :)
22:09:15 <levi> solatis: I think you'll be able to figure it out. Feel free to ask questions if something stumps you.
22:09:24 <solatis> ok thanks
22:09:32 * hackagebot punkt 0.1.0 - Multilingual unsupervised sentence tokenization with Punkt.  http://hackage.haskell.org/package/punkt-0.1.0 (bryant)
22:09:42 <levi> I might not be here, as it's getting late here, but someone's likely to be able to answer.
22:10:11 <alanoth> Is there anyone with some experience with the Google Summer of Code?
22:10:54 <solatis> levi: yeah and there are heaps and heaps of github code i can search through
22:11:12 <solatis> i always like to use that, since i'm the type of person who learns by example
22:11:32 <solatis> anyway thanks for the encouragement levi ;)
22:12:54 <levi> alanoth: It's off-season for GSOC right now, it seems.
22:13:22 <alanoth> Yup, but i'm looking to gain enough knowledge to be able to participate.
22:13:56 <alanoth> I haven't had enough exposure to software development, I've not done many projects with >1500 lines of code
22:14:26 <alanoth> I wanted to gain some exposure to that, but then haskell came around and I decided that I'll participate with haskell.org
22:15:21 <alanoth> levi: Any way for me to gain exposure to some large or otherwise good code would also require me to be able to understand it.
22:15:37 <alanoth> Can you please provide me direction as to where I should go from here?
22:15:52 <alanoth> Books, tutorials, or specific topics etc
22:16:51 <levi> Hmm.
22:17:10 <Heather> is there type theory for dummies?
22:17:30 <levi> alanoth: I'd look and see if any of the libraries that had mentored projects this last summer seem interesting to you.
22:17:40 <dv-> alanoth: go to github and pick a project to contribute
22:18:07 <dv-> +to
22:18:21 <levi> alanoth: See if you can track down some of the previous mentors and see what advice they have.
22:18:44 <alanoth> dv: I though of doing so, but I haven't yet contributed to much software, and it's difficult to contribute as haskell is a very new language for me
22:18:54 <levi> Heather: Not with precisely that title, but type theory is a broad field and there's a lot of literature at various levels.
22:19:15 <alanoth> I have still a lot to learn, and I can't decide where to study further
22:20:11 <levi> alanoth: The diagrams library is a fun one to play with.
22:20:55 <alanoth> levi: Yeah, it sure looks fun
22:21:54 <alanoth> Thanks for the tips guys :)
22:26:35 <levi> Ah, C11 says CHAR_BIT is at least 8.
22:28:25 <levi> Actually, the same text is there in C89.
22:29:01 <spng453> So it isn't letting me install cario
22:29:07 <spng453> Module `Distribution.Simple.Configure' does not export `configCompilerEx'
22:32:15 <CrazyM4n> http://lpaste.net/109111
22:32:27 <CrazyM4n> Just googled my problem and that came up, that's the exact thing that's happening to me
22:32:37 <CrazyM4n> What do I do
22:33:52 <CrazyM4n> Ah, I had to install gtk2hs-buildtools
22:34:06 <CrazyM4n> Just kidding, it still doesn't work
22:34:51 <hamishmack> CrazyM4n: try cabal install Cabal
22:35:10 <CrazyM4n> hamishmack: Oh, thanks
22:35:14 <CrazyM4n> This is a brand new linux install
22:35:19 <CrazyM4n> Still don't have all that set up
22:40:21 <CrazyM4n> just kidding
22:40:23 <CrazyM4n> it still doesn't work
22:51:50 <merijn> CrazyM4n: You need to "cabal install cabal-install" to upgrade cabal
22:52:12 <merijn> CrazyM4n: Which version do you have right now?
22:52:19 <merijn> hell, which ghc?
22:52:41 <CrazyM4n> merijn: The newest ghc
22:52:50 <CrazyM4n> 7.5.3
22:52:52 <CrazyM4n> err
22:52:54 <CrazyM4n> 7.6.3
22:53:31 <merijn> 7.6.3 is not the newest
22:53:48 <merijn> 7.8.3 is, also which version of cabal/cabal-install?
22:54:00 <CrazyM4n> let me look
22:54:12 <CrazyM4n> cabal install 1.16.0.2
22:54:16 <CrazyM4n> cabal 1.16.0
22:54:23 <CrazyM4n> I just got everything from the ubuntu repos
22:56:09 <CrazyM4n> So, how do I fix this?
23:00:01 <CrazyM4n> merijn: According to my apt-get haskell is the newest version
23:00:04 <CrazyM4n> Should I install it from the site
23:03:07 <CrazyM4n> D:
23:05:19 <jle`> yeah, ubuntu repos are a little behind
23:05:27 <jle`> there's a ppk somewhere out there, but...it's pretty easy to install ghc manually
23:05:31 <jle`> and uninstall/manage multiple versions
23:05:51 <CrazyM4n> Okay...
23:05:54 <CrazyM4n> I'll try to find it
23:07:34 <CrazyM4n> I can't seem to find it
23:07:46 <CrazyM4n> And I don't want to just use the binaries, I'd like to have it installed
23:07:55 <jle`> it's on the ghc website
23:08:08 <jle`> @google ghc haskell
23:08:09 <lambdabot> http://www.haskell.org/ghc/
23:08:09 <lambdabot> Title: The Glasgow Haskell Compiler
23:09:31 <jle`> :)
23:10:14 <CrazyM4n> Nope, it just says that it's in universe
23:10:21 <CrazyM4n> Which is what I downloaded it from formerly
23:11:30 <redtricycle> I see references to reading the "haddock" documentation.  Is this the web version or is there a command I need to run to read the haddock docs?
23:12:23 <jle`> redtricycle: haddocks for hackage libraries are online at the hackage website
23:12:23 <CrazyM4n> Ah, found this https://launchpad.net/~hvr/+archive/ubuntu/ghc
23:12:34 <jle`> ah
23:12:46 <jle`> http://www.haskell.org/ghc/download_ghc_7_8_3#binaries the binaries work...they're binaries in that they are pre-built
23:12:48 <jle`> but
23:12:51 <jle`> it's installed for you
23:12:59 <jle`> it still installs it on your system, if that's what you mean
23:13:05 <CrazyM4n> Really?
23:13:11 <jle`> i think bitemyapp's guide has an ubuntu installation guide too tho with the ppk
23:13:16 <jle`> yeah, it's just configure and make install
23:13:31 <CrazyM4n> Well then
23:14:13 <CrazyM4n> So what's the difference between just installing GHC and installing the whole haskell platform?
23:14:24 <CrazyM4n> Does the platform contain things that GHC doesn't?
23:15:04 <jle`> yeah...a lot of extra things
23:15:06 <Cale> CrazyM4n: A bunch of libraries, which you can easily install using cabal-install anyway
23:15:16 <jle`> most of the things you install with cabal anyway
23:15:20 <merijn> Yes, but most linux package managers break the platform in various ways, so it doesn't add much on linux
23:15:30 <CrazyM4n> Sounds good
23:15:34 <jle`> i think the platform is for windows/mac systems where setting up things are tricky
23:15:38 <jle`> *mostly for
23:15:49 <jle`> i've never had any benefit from the platform on my linux systems
23:16:00 <MP2E> same here
23:16:06 <CrazyM4n> Well I've only had windows systems
23:16:10 <CrazyM4n> So I'm just not used to it
23:16:10 <jle`> i platform my windows box though because i don't want to deal with it v.v
23:16:17 <MP2E> even on Windows, I still ended up building GHC myself using msys + mingw-w64
23:16:21 <kvda> there's no benefit to it that i see on Macs either
23:16:22 <MP2E> ah :P
23:16:32 <CrazyM4n> Compiling things on windows is such a pain
23:16:47 <CrazyM4n> Well, it is on linux too, but it's slightly less of a pain ;)
23:17:19 <jle`> platform comes with things like bindings to graphics libaries and stuff .... basically, things i wouldn't want to mess with on windows, heh
23:17:45 <CrazyM4n> Basically, the stuff that I do want to mess with :P
23:17:48 <idnar> how can I see what cabal(?) thinks $ncpus is?
23:18:47 <ReinH> I think nix is the only OS that hasn't completely broken packages from programming languages
23:18:54 <ReinH> At least it's the only one I've tried
23:19:33 <MP2E> NixOS is pretty great :>
23:19:40 <kadoban> Hmm, well that didn't go well. First thing I tried to install from stackage isn't in exclusive, and won't build from inclusive :-/
23:20:19 <CrazyM4n> How... how do you unzip a tar.xz?
23:20:25 <CrazyM4n> Stupid tar command, can't ever remember it
23:20:40 <MP2E> i just use 'tar -xf' for all types of archives, tar will grab the write tool for you
23:20:43 <MP2E> right*
23:20:46 <ReinH> Petition for a cabal patch that adds a new flag that combines --force-rebuild and --allow-newer. It will be called --yolo.
23:20:56 <kadoban> CrazyM4n: -J I think
23:20:58 <jle`> obligatory xkcd link goes here
23:21:11 <MP2E> also that yes
23:21:12 <CrazyM4n> http://xkcd.com/1168/
23:21:18 <CrazyM4n> and -xf worked
23:21:18 <jle`> thank you
23:21:18 <CrazyM4n> thanks
23:21:31 <kadoban> MP2E: Does that really work? I'll have to remember that
23:21:35 <MP2E> it really does :>
23:21:38 <ReinH> CrazyM4n: I think newer tars will detect that so you can just tar xf?
23:21:42 <ReinH> MP2E: Oh you said that
23:21:47 <jle`> i have all tar command sthat i can conceive myself needing ever in .bash_aliases
23:21:48 <MP2E> Not even just newer tars, it's been that way since at least 2009
23:21:49 <jle`> v.v
23:21:52 <MP2E> because it's an old habit of mine
23:21:57 <jle`> 2009 is new :P
23:22:00 <MP2E> fair enough
23:22:01 <ReinH> MP2E: that is newer in GNU tooling epochs
23:22:04 <MP2E> :>
23:22:13 <ReinH> basically yesterday
23:22:17 <MP2E> hahah
23:22:33 <ReinH> they haven't even gotten dusty yet
23:23:07 <CrazyM4n> spng453@nasa:~/ghc-7.8.3$ ./configure
23:23:07 <CrazyM4n> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory
23:23:11 <CrazyM4n> configure: error: cannot determine current directory
23:23:16 <CrazyM4n> Sometimes, I just want to stop trying
23:24:09 <jle`> you have the wrong version of gmp
23:24:14 <jle`> there should be two options?
23:24:18 <MP2E> yep
23:24:18 <jle`> two download options?
23:24:24 <MP2E> go for the 5.x series
23:24:24 <jle`> http://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux
23:24:24 <CrazyM4n> I installed it from the package manager
23:24:29 <CrazyM4n> just libgmp-dev
23:24:33 <jle`> oh
23:24:35 * hackagebot flaccuraterip 0.3.3 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.3.3 (NicolaSquartini)
23:24:36 <MP2E> ah that might be the newer 6.x
23:24:43 <CrazyM4n> ok
23:24:57 <jle`> huh i always thought that libgmp came with the ubuntu distro
23:25:01 <ReinH> CrazyM4n: here are some things you might need https://github.com/darinmorrison/docker-haskell/blob/master/Dockerfile#L39-L48
23:25:25 <jle`> see if  https://github.com/bitemyapp/learnhaskell can do anything for you
23:26:10 <CrazyM4n> What the hell, I even linked this https://launchpad.net/~hvr/+archive/ubuntu/ghc
23:26:14 <CrazyM4n> Yet I didn't use it
23:30:39 <CrazyM4n> I love LXDE so much
23:44:05 <CrazyM4n> Woo, it owrks
23:56:15 <solatis> If i want to automatically be able to convert FooType into BarType, the word i'm looking for is "type coercion", right?
23:57:18 <ThreeOfEight> solatis: to me at least, ‚Äòcoercion‚Äô sounds a bit like an implicit conversion
23:57:22 <ThreeOfEight> Haskell doesn't really do that
23:57:25 <ThreeOfEight> I'd call it a conversion
23:57:41 <solatis> ok
23:58:08 <solatis> to explain, this is the error message ghc generates:
23:58:11 <solatis>     Couldn't match type ‚Äò[Field]‚Äô with ‚ÄòTitle‚Äô
23:58:19 <solatis> I know exactly how to convert between the two
23:58:28 <solatis> how can I tell haskell how to automatically do that?
23:58:35 <ThreeOfEight> you can't
23:58:45 <ThreeOfEight> Automatic type conversions are evil.
23:58:51 <dfeuer> solatis, in Haskell, "coercion" tends to mean something very specific: taking something of one type and viewing its representation as representing some other type.
23:59:00 <ThreeOfEight> (I am not 100% sure that it's impossible, but I really don't think so.)
23:59:18 <solatis> ThreeOfEight: i thought it was possible with generics / derivabletypes
23:59:55 <solatis> dfeuer: ok, so it's more like a "view" of another type rather than a conversion to the other type
