00:33:23 <pingu> Does anyone know of a package for making nested Map like structures easier to use?
00:33:42 <pingu> i.e. for working with Map k (Map k' v) things
00:35:50 <merijn> pingu: lens? :)
00:35:53 <simpson> pingu: lens!
00:35:58 <merijn> For some value of easier :p
00:43:26 <prinsen> in parsec, is there any chainl1-alike where the function is (a -> b -> a)?
00:51:05 <dmj`> where does haddock come up with its percentages?
00:51:09 <dmj`> when invoked
00:51:18 <dmj`> where or how I guess
00:52:37 <gigabytes> hello
00:52:38 <Fuuzetsu> dmj`: it's just number of documented things / number of all things
00:52:45 <gigabytes> still trying to grasp lenses and traversals
00:53:15 <solatis> i still have no idea what this 'lens' stuff and 'applicative' mess all means
00:53:24 <solatis> apparently i use it in my code
00:53:28 <gigabytes> with view (field1.traverse._2) I can access the second field of the pairs contained in field1 (which is a list of pairs)
00:54:04 <gigabytes> how can I obtain through lenses the effect of mapping a function over those targets?
00:54:38 <indiagreen> gigabytes: over (field1.traverse._2) yourFunction
00:55:45 <gigabytes> indiagreen: ok, I forgot about over! But is this chainable? I mean I would like to continue chaining a traversal through the result
00:55:48 <dmj`> Fuuzetsu: I'm at 90%, all top level functions are commented, driving me nuts
00:56:02 <dmj`> documented*
00:56:19 <Fuuzetsu> dmj`: bet you don't have a module header
00:57:24 <Fuuzetsu> dmj`: by the way, there's a flag which will tell you exactly where the docs are missing
00:57:31 <Fuuzetsu> it's not on by default but maybe we should make it
00:57:37 <rushi> hi guys
00:57:54 <Fuuzetsu> dmj`: --print-missing-docs
00:58:34 <rushi> I was wondering if any of you can suggest me good book on haskell and lambda calculus
00:58:55 <sagittarian> how do you pronounce (,)?
00:59:03 <jle`> times
00:59:11 <hyPiRion> urgh. Say I have "data Op = Add | Sub | Mul | Div" and want to pattern match on either Add/Sub or Mul/Div, is there a better way to do it than doing guards à la "| op `elem` [Add, Sub] = ..." ?
00:59:25 <hyPiRion> Issue is that it cannot infer all cases are handled.
00:59:26 <jle`> cross?
01:00:27 <Fuuzetsu> pronouncing operators is something I avoid but in a pinch ‘comma’ would do
01:01:10 <sagittarian> i talk to myself, so i need to know how to pronounce it
01:01:37 <rushi> sagittarian: it is ronounceccd as "comma"
01:01:43 <Fuuzetsu> ‘pair constructor’
01:01:49 <sagittarian> thanks rushi and Fuuzetsu
01:01:53 <simpson> sagittarian: "and"
01:02:02 <simpson> (a, b) "tuple of a and b"
01:02:13 <dmj`> Fuuzetsu: says --print-missing-docs is unrecognized, is this a haddock 2.15 thing?
01:02:15 <Fuuzetsu> simpson: but that overlaps with &&
01:02:27 <Hafydd> "pair", maybe.
01:02:32 <sagittarian> :t curry (,)
01:02:32 <Fuuzetsu> dmj`: uh, I think it was in 2.14.3 already
01:02:33 <lambdabot> a -> b -> b1 -> ((a, b), b1)
01:02:54 <sagittarian> :t (,)
01:02:56 <lambdabot> a -> b -> (a, b)
01:02:57 <Fuuzetsu> dmj`: you can happily update to 2.15.0 if you're on 2.14.3
01:03:00 <simpson> Fuuzetsu: English already has "set"; it can't get much worse. :3
01:03:07 <sagittarian> oh
01:03:14 <sagittarian> :t uncurry (,)
01:03:15 <lambdabot> (a, b) -> (a, b)
01:03:25 <sagittarian> why is it so hard for me to keep curry and uncurry straight
01:03:50 <Fuuzetsu> dmj`: git tells me I added the flag on Date:   Sat Sep 7 05:21:03 2013 +0100
01:03:54 <jle`> sagittarian: do you know what currying means?
01:04:23 <Fuuzetsu> well before 2.15 tag start
01:04:25 <sagittarian> yes, i understand it all, but for some reason i have to think really hard about type signatures in order to remember whether i want curry or uncurry in a given situation
01:04:42 <jle`> i feel like...it isn't too tricky
01:04:58 <jle`> currying is taking a function that takes a tuple and turning it into a function that returns another function
01:05:22 <Fuuzetsu> I never don't remember which is which, curry or uncurry
01:05:24 <jle`> so...from that definition...it is sorta clear wha curry does
01:05:45 <indiagreen> gigabytes: if you're using “traverse” in your chain, you have several targets (you can use “each” instead of “traverse”, by the way). For instance, if you want to get them all as a list, you can do “toListOf (field1.each._2)”. If you want the 1st one – “preview (field1.each._2)”. If you want to get the original structure *but* with elements modified, do “over (field1.each._2) someFunction”. If you want (as
01:05:45 <indiagreen> previously) to get the list of 2nd elements of pairs in the list, but with some other function applied after you've got them, you can use “to”: “toListOf (field1 . each . _2 . to someOtherFunction)”
01:06:10 <jle`> "what is currying?  oh, it's taking a function that takes a tuple and turning it into a function that returns a function that... hm.  so what does `curry` do?"
01:06:16 <jle`> it...literally curries the function
01:06:32 <dmj`> Fuuzetsu: oh, when I run cabal haddock --print-missing-docs it says its unrecognized, but haddock --print-missing-docs shows nothing
01:06:47 <gigabytes> indiagreen: nice cheatsheet, thank you
01:07:30 <gigabytes> indiagreen: and then after "to" can I still chain other lenses?
01:07:44 <jle`> dmj`: cabal haddock --haddock-options="--print-missing-docs"
01:07:50 <gigabytes> supposing I have lenses to access values of the type returned by the function
01:08:20 <indiagreen> yep, you can
01:08:56 <gigabytes> indiagreen: cool. But then it becomes a getter, and I can't "modify" the elements, right?
01:09:00 <dmj`> jle` Fuuzetsu: <3
01:09:06 <dmj`> thanks guys
01:09:30 <Fuuzetsu> dmj`: cabal is not taught about the flag directly, you'll have to use a pass-through; you might want to stick it into your global cabal config, I think there's haddock-options block now or something
01:10:23 <Fuuzetsu> and yeah, ‘haddock --print-missing-docs’ won't do anything meaningful, it doesn't have any project integration or anything like that, it knows nothing
01:10:49 <indiagreen> gigabytes: exactly. If you want to be able to modify as well, you can create a lens from a getter and a setter with “lens”
01:12:16 <dmj`> Fuuzetsu: module headers... is that really necessary :{ ... aren't the cabal files descriptive enough... ? Why do I need to put a license in every module
01:12:31 <gigabytes> indiagreen: so (field1.each._2.lens g s.otherField) is a lens (getter and setter)
01:12:53 <pingu> merijn, simpson what exactly in lens?
01:12:58 <indiagreen> gigabytes: well, more exactly it's a traversal
01:13:07 * dmj` just wants 100% coverage
01:13:09 <pingu> I'm not talking aobut just one indexed lookup within anohter
01:13:20 <gigabytes> indiagreen: oh yes, because it has more than one target, right?
01:13:20 <pingu> I'm talking aobut doing things like nested merges, deletes and mutation
01:13:25 <indiagreen> right
01:13:30 <gigabytes> indiagreen: but it still both a getter and a setter?
01:13:56 <merijn> pingu: Manipulating nested data structures is what lens does best :)
01:14:12 <pingu> uh, well. manipulating data *in* nested data structures, yes.
01:14:13 <jle`> dmj`: cabal files describe the library, not the individual modules...right?
01:14:44 <pingu> merijn: I mean more, abstracting the whole lookup k m >>= lookup k'
01:14:51 <pingu> and the same for delete, etc.
01:14:55 <pingu> which I don't think lens will help with
01:15:16 <merijn> pingu: Ask #haskell-lens, I'm about 90% certain it will make that easy
01:15:22 <simpson> > M.empty & at "name" . at "key" .~ 42
01:15:24 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
01:15:24 <lambdabot>  Expected type: Control.Lens.At.Index (Data.Maybe.Maybe a)
01:15:24 <lambdabot>    Actual type: [GHC.Types.Char]
01:15:43 <lericson> :t at
01:15:44 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
01:15:51 <lericson> oh man
01:15:51 <simpson> > M.empty & at "name" . at "key" .~ Just 42 -- oh, right, I always forget which types to use here
01:15:53 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
01:15:53 <lambdabot>  Expected type: Control.Lens.At.Index (Data.Maybe.Maybe a)
01:15:53 <lambdabot>    Actual type: [GHC.Types.Char]
01:15:59 <pingu> hmmn. That's using FoldableWithIndex?
01:16:02 <simpson> Hm. Did I mean for ix?
01:16:23 <simpson> > M.empty & ix "name" . ix "key" .~ Just 42 -- gonna get this, dammit
01:16:25 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
01:16:25 <lambdabot>              with actual type ‘Control.Lens.At.Index a0’
01:16:25 <lambdabot>  The type variable ‘a0’ is ambiguous
01:16:30 <dibblego> pingu: Control.Lens.At
01:16:41 <pingu> dibblego: perfect, thanks.
01:16:43 <simpson> Okay. Well, I'm too tired to write code, but it's totally possible to do this, and I've done it before.
01:16:54 <pingu> indexed lenses can't *delete* data, can they?
01:17:12 <pingu> as in, Map.delete
01:17:26 <pingu> Oh, just .~ to Nothing should work I suppose.
01:17:46 <simpson> Correct.
01:18:07 <pingu> which just leaves unions and such, which isn't particularly ugly now that I have that sorted.
01:18:10 <pingu> thanks.
01:18:16 <simpson> You can also use lenses like non to indicate that the value at a given key should default to a value. (And be removed if set to that value!)
01:18:19 <simpson> :t non
01:18:20 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
01:18:30 <pingu> yeah, I've seen some crazy things done with non
01:19:04 <pingu> simpson: thanks!
01:20:25 <pingu> I wonder how far I would have gotten into re-inventing indexed lenses before realizing what I was doing...
01:20:34 <indiagreen> gigabytes: it's a traversal. Traversals are setters, but they aren't, strictly speaking, getters (if you're talking about lens's Getter type). What I mean is that you can't use “view” on a traversal (unless the type of your traversed things happens to be a monoid, e.g. a list), so it's better – for the sake of minimising confusion – to refer to traversals as traversals and not getters. But if you're saying “getter” to mean
01:20:34 <indiagreen> “something which can extract values”, then, yeah, it's a setter and a getter
01:21:13 <simpson> pingu: For example, https://github.com/bravoserver/baskerville/blob/master/Baskerville/Chunk.hs#L100 shows off using ix and non together to index a data structure that automatically removes completely-zeroed blocks from a data structure.
01:21:23 <pingu> simpson: nice, thanks.
01:22:25 <pingu> simpson: this code is very readable
01:22:49 <dmj`> jle`: yea they do, but can modules have a different license than the cabal file specifies? It would seem so, but that wouldn't make sense
01:24:26 <merijn> dmj`: Define "can they"
01:24:48 <gigabytes> indiagreen: ok thanks! last thing: which difference between traverse and "each". Only a shorter synonim?
01:24:52 <merijn> jle`, dmj`: In principle licenses could be at a sub-file granularity (i.e. sections of a file), but that's not very sensible
01:24:57 <simpson> pingu: Thanks!
01:25:24 <merijn> jle`, dmj`: If your license doesn't cover the entire package, you should select the Other license and include clear documentation in the package on what license covers what
01:26:22 <indiagreen> gigabytes: no, “traverse” is for all traversables and “each” is for more things (for instance, you can use it to change all elements of a tuple like (a,a,a,a), or map over bytes in a ByteString) – see Control.Lens.Each for all supported types
01:26:38 <merijn> dmj`: Also, don't believe these weirdos that claim "every file needs a license header", it's bogus
01:26:44 <gigabytes> indiagreen: ah ok perfect
01:27:09 <gigabytes> indiagreen: thank you very much
01:27:34 <merijn> dmj`: In the end, deciding license validity (should it ever come to that) is up to a judge, so any sane and unambiguous (for humans of average intelligence) license specification is sufficient
01:27:54 <pingu> merijn: often the rationale behind that is simply clarity
01:28:02 <pingu> when people are copy/pasting files between projects
01:28:15 <pingu> debian maintainers tend to like the implicit licencedness of each file
01:28:22 <pingu> so they don't have to be judges
01:28:33 * dmj` is afraid of judges
01:28:35 <pingu> they kind of are weirdos though, so, not much argument there
01:29:05 <merijn> pingu: Debian maintainers can't decide whether a license is valid
01:29:17 <dmj`> merijn: I guess I'll just copy the same license in the module as in the cabal file, or maybe haddock will let me omit it, and still give me 100% coverage on that module
01:29:48 <dmj`> yea I can omit it, it would seem
01:29:52 <merijn> dmj`: You don't need a license for the module annotation
01:30:54 <dmj`> merijn: what is the barebones of a module annotation that would still give me 100% coverage?
01:31:08 <dmj`> merijn: at this point most of the module annotation is a redundancy from the cabal file
01:31:13 <dmj`> merijn: for my needs
01:31:45 <dmj`> maintainer, copyright, portability, etc
01:32:02 <merijn> No idea
01:41:10 <gigabytes> indiagreen: anyway this package is awesome!
01:41:26 <gigabytes> indiagreen: and people that invented it are geniuses
02:08:40 <Heather> how to build ghc
02:08:55 <merijn> Heather: Why do you think you want to?
02:09:15 <Heather> merijn: interesting
02:09:48 <Heather> merijn: I want to see how is it designed
02:10:10 <merijn> Heather: The GHC wiki has some links on the build process (and design)
02:10:44 <merijn> Heather: You need a working copy of GHC first, then checkout a copy of the GHC git repo and follow the instructions in the README files to get started
02:11:15 <Heather> merijn: I'm getting Unable to find current revision in submodule path 'libffi-tarballs'
02:12:55 <merijn> I need to go to bed, so I can't be more helpful than check the wiki links mentioned in the README :)
02:13:31 * hackagebot union-map 0.0 - Heterogeneous map by open unions.  http://hackage.haskell.org/package/union-map-0.0 (minpou)
02:13:37 <Heather> oh I'm so sleepy also
02:43:32 * hackagebot system-canonicalpath 0.1.1.0 - Abstract data type for canonical paths with pretty operations  http://hackage.haskell.org/package/system-canonicalpath-0.1.1.0 (d12frosted)
02:59:16 <pingu> I have been thinking that haskell does not have enough documented 'software design patterns'
03:00:03 <pingu> as overloaded and terrible as the term is, it is useful to have ways of doing certain things and with so many ways to do things in haskell it's almost a recipe for chaos
03:01:27 <tdammers> pingu: haskell has plenty of "best practices"
03:01:45 <tdammers> pingu: and there are a few patterns, but people try to avoid them in favor of more explicit code
03:01:59 <tdammers> i.e., consolidate your abstractions into actual code rather than ad-hoc conventions
03:02:23 <tdammers> many of the ubiquitous typeclasses are pretty much just explicit design patterns
03:06:08 <pingu> tdammers: sure, I understand this now.
03:06:33 <pingu> however as a beginner you tend to learn this the hard way.
03:06:46 <pingu> and some things that look like useful abstractions are just academic noise
03:07:04 <pingu> which again, seems to just take experience to know
03:07:10 <Sonderblade> what kind(s) of multi-threading does haskell implement?
03:07:13 <Fuuzetsu> it just means you haven't grasped the academic noise yet to understand that it's useful abstractions ;P
03:07:25 <Sonderblade> real kernel-level threads or coop?
03:07:36 <pingu> Sonderblade: both
03:07:41 <pingu> transparently if you like, even.
03:08:08 <pingu> coop scheduled on kernel level threads, with the option to do whatever you like in between
03:08:28 <indiagreen> tdammers: there are many things which people use but which aren't exactly well-documented. For instance, you can solve many problems with polyvariadic functions, but there's no library or typeclass for writing them – in order to write a polyvariadic function, you have to be well-aware of the fact that you *can* write one (and even then you often won't notice when one would've simplified your code)
03:08:52 <Sonderblade> pingu: "coop scheduled on kernel level threads" <- what does that mean?
03:09:17 <pingu> SoupE: didn't you just make up the word coop?
03:09:33 <pingu> Sonderblade*
03:09:40 <pingu> SoupE: apologies, disreguard
03:10:24 <pingu> Sonderblade: Haskell has 'green' threads, or 'lightweight', RTS (run time system) scheduled threads, generally.
03:10:29 <Sonderblade> pingu: in other words, if one of my haskell threads calls a c function which has: while (1) { } will my other haskell thread be able to run another while(1) { } loop?
03:10:45 <k00mi> Sonderblade: how did you create the thread?
03:10:58 <pingu> Sonderblade: that's a different question which requires a little more understanding of how FFI works
03:11:09 <pingu> but if the FFI call to the c function is safe, you will be able to run the other haskell thread
03:11:15 <pingu> if it is marked 'unsafe', it will block.
03:12:00 <Sonderblade> k00mi: whichever way that makes the answer to the question "yes"
03:12:24 <tdammers> indiagreen: in all fairness, the haskell community does have a tendency to be a bit snobbish about documentation
03:12:25 <pingu> Sonderblade: however you call the safe FFI function, if it's marked safe it won't block.
03:13:51 <pingu> Sonderblade: err, pending the number of RTS threads you have running, I presume.
03:14:06 <pingu> I'm not actually sure about the behaviour if you try to start more foreign calls than you have RTS threads
03:15:09 <lritter> any experts here who know something about haskells implementation, particularly of expression caching?
03:15:33 <Sonderblade> pingu: what decides if the ffi function is safe or not?
03:15:39 <pingu> lritter: I'd try ghc-dev because that depends on the implementation, right?
03:15:40 <indiagreen> tdammers: same with free monads (which can be used to write interpreters); wxWidgets–style cute setters; DSLs; structuring your program as a monad stack; using records instead of typeclasses. Lenses were a design pattern as well before all the libraries appeared
03:15:57 <lritter> pingu, i'd think it would be the same everywhere but i'll do that thanks
03:16:02 <pingu> Sonderblade: it's an option when defining the FFI call
03:16:03 <indiagreen> there are a few design patterns on Tekmo's blog, but not many
03:16:32 <lritter> pingu, well it has to be here, #ghc-dev is empty ;)
03:16:37 <pingu> Sonderblade: safe by default, though.
03:16:51 <pingu> lritter: sorry, I meant #ghc
03:17:08 <pingu> lritter: someone here might know, though. I don't.
03:17:13 <lritter> pingu, i'll try, thanks :)
03:17:58 <Sonderblade> pingu: why would the programmer then mark any ffi function as safe?
03:18:23 <pingu> Sonderblade: they might mark it as unsafe to get a lower latency call
03:19:01 <pingu> when it's marked safe, things are set up so that the c function can call back to haskell and magical things are done to allow it to be 'backgrounded'
03:19:06 <k00mi> Sonderblade: note you also need to link with -threaded
03:19:09 <pingu> I'm no expert, on the RTS, though.
03:19:26 <pingu> k00mi: yes, forgot to mention that, thanks.
03:19:57 <pingu> Sonderblade: another caveat is that the RTS won't do threaded stuff without -threaded and can be told how many OS threads to use with +RTS -N threads
03:20:14 <Sonderblade> pingu: let's make it extra hard for haskell, the c funtion i'm calling is qsort, the callback (comparator) it is supplied with is a haskell function
03:20:28 <Sonderblade> pingu: can that ffi call be unsafe?
03:20:53 <pingu> Sonderblade: No it can't.
03:21:05 <pingu> to call back into haskell land the FFI needs to be marked safe
03:21:16 <pingu> so that the RTS sets up the callback addresses and such
03:21:19 <pingu> which takes time
03:21:21 <k00mi> Sonderblade: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/ffi-ghc.html#ffi-threads
03:21:31 <pingu> which is why you might mark it unsafe, to lower latency of a quick FFI call
03:21:51 <lritter> pingu, maybe you can help
03:21:56 <lritter> after all
03:22:20 <Sonderblade> pingu: sounds to be like most ffi calls aren't preemptive then, if they cant be marked as unsafe
03:22:29 <lritter> pingu, the background is: i'm building my own graph based code generator which has both functional and monadic flow, and i wonder how people do expression caching in haskell
03:23:34 <lritter> pingu, basically, if you have two statements (e.g. ffi calls) that require the same function to be evaluated, how do you control whether the evaluation will be cached or repeated?
03:23:44 <pingu> oh
03:23:54 <pingu> FFI they're always repeated (obviousl;)
03:23:57 <Sonderblade> pingu: im trying to determine whether haskell uses "real threading" like .net and java or "fake threading" like python, it seems to land somewhere in the middle
03:24:05 <pingu> you can't cache a FFI call that could have side effects.
03:24:35 <pingu> Sonderblade: I suppose you could posit that generalization of preemtive FFI calls. Pretty sure someone will have something to say about it.
03:24:45 <pingu> Sonderblade: It has both.
03:25:05 <pingu> Sonderblade: The best of both worlds, really. And a lot of work behind it to achieve that.
03:25:09 <pingu> It's quite an amazing RTS.
03:25:11 <lritter> pingu, so what if e.g. the evaluated function is a getSystemTime function
03:25:13 <pingu> and system.
03:25:26 <lritter> pingu, you'd keep the value to be the same for the evaluation of a frame, for example
03:25:39 <pingu> lritter: no, I don't think you ever would
03:25:53 <pingu> you might want to read some of the design docs in the GHC repo for what you seem to be asking
03:25:56 <pingu> around CAFs
03:26:00 <pingu> or start with the haskell wiki on CAF
03:26:09 <pingu> certain pure funcitons are 'cached'
03:26:25 <pingu> but never an IO action
03:26:40 <pingu> in fact there's some weirdness around duplicating IO actions ;)
03:26:49 <lritter> well consider something like (i'm using pseudo C syntax)   int time = getTime(); ffi_A(time); ffi_B(time); -- what is the equivalent in haskell?
03:26:57 <k00mi> Sonderblade: forkIO creates a userland thread, but if you link with -threaded, the RTS will run on multiple kernel threads
03:27:24 <pingu> lritter: so the equivalent might be x <- ffi_call_to_getTime
03:27:36 <pingu> the point at which x is a name bound to the result of that
03:27:43 <pingu> and x would never be duplicated
03:27:51 <pingu> well, the cal would never be duplicated
03:27:54 <lritter> i see
03:28:05 <lritter> then it's explicit there too.
03:28:06 <lritter> good.
03:28:09 <pingu> you could reason about it roughly the same as c.
03:28:13 <lritter> then i'll keep the rule that i already have.
03:28:19 <Sonderblade> pingu: that ffi calls mostly aren't preemptive sounds like a big flaw to me
03:28:19 <lritter> thanks :)
03:28:41 <pingu> lritter: you're welcome.
03:29:11 <pingu> Sonderblade: they are 'preemtive' by default?
03:29:15 <pingu> even interruptable.
03:29:22 <pingu> (not by default)
03:29:32 <pingu> you get all the options, I dont see how you could complain ;)
03:30:38 <Sonderblade> pingu: you said the qsort function wasn't preemtible if it took a callback
03:30:56 <pingu> it has to be marked safe
03:31:11 <pingu> so it *has* to be preemtible, perhaps I have the word 'preemtible' backwards.
03:31:12 <Sonderblade> pingu: that's a tough example i admit :) but what if you call a c function that http downloads a file safe or unsafe?
03:31:25 <pingu> I'd mark it safe, but it's your choice.
03:32:00 <pingu> which I'd also consider pre-empitble.
03:32:02 <Sonderblade> it could take several seconds to run, and the haskell vm would block meanwhile?
03:32:05 <tdammers> indiagreen: alright alright, you win ;)
03:32:06 <pingu> no it owuld not
03:32:12 <pingu> safe is preemptable. safe is the default.
03:32:21 <pingu> if you want to call something really fast, you mark it unsafe
03:32:25 <pingu> and it's not preemtable
03:32:33 <pingu> and hope it returns super quickly
03:32:44 <pingu> and usually it's incorrect to mark it unsafe
03:33:30 <Sonderblade> oh right, i got it backwards then
03:33:40 <pingu> excellent, everyone is happy, then.
03:33:43 <Sonderblade> then i agree that haskell has "real", preemtive, kernel-threading
03:34:02 <k00mi> if you link with -threaded
03:34:05 <pingu> along with scheduled 'lightweight' threads for native code
03:34:14 <pingu> so, best of both worlds.
03:34:16 <pingu> and awesome.
03:34:17 <Sonderblade> k00mi: does itwork on windows?
03:34:26 <k00mi> I don't know
03:35:15 <pingu> Sonderblade: yes it does. There's possibly very slight differences.
03:35:20 <pingu> but not around that API
03:35:30 <iron_hou1> When I do :t [] I get [] :: [t] -- I had expected [] :: [a] . What's `t' ?
03:35:35 <pingu> I've seen some bugs arise from weird use of the IO system in the ZMQ bindings.
03:36:13 <pingu> iron_hou1: I've no idea. It really shouldn't matter but that's an interesting question ;)
03:36:31 <pingu> perhaps it's a default for type variabels
03:37:33 <pingu> iron_hou1: in fact I am not sure I could tell you the type of []
03:37:44 <pingu> it odesn't really make sense to me without something inside it.
03:38:05 <indiagreen> pingu: what's the type of “1”?
03:38:11 <k00mi> it's a polymorphic value
03:38:16 <pingu> indiagreen: precicely
03:38:22 <k00mi> :t 1
03:38:23 <lambdabot> Num a => a
03:38:26 <indiagreen> it can be Int or Integer or any Num, right
03:38:32 <indiagreen> which is what GHCi is telling you
03:38:41 <indiagreen> in the same way “[]” can be a list of any type
03:38:59 <iron_hou1> :t []
03:39:00 <pingu> indiagreen: there's obviously a difference, though
03:39:00 <lambdabot> [t]
03:39:17 <indiagreen> a difference between “1” and “[]”?
03:39:18 <pingu> oh wait, no. there isn't
03:39:21 <iron_hou1> .. but what's the difference between [a] and [t] ?
03:39:22 <pingu> I'm thinking at the kind level here.
03:39:24 <pingu> which was a mistake
03:39:30 <pingu> it's the same at a value level
03:39:57 <k00mi> iron_hou1: none
03:40:06 <k00mi> except for the name, obviously :-)
03:40:07 <indiagreen> iron_hou1: there's no difference between [a] and [t], it's just a quirk of how GHCi chooses a letter for a type variable
03:40:16 <indiagreen> I wonder how exactly it chooses, tho
03:40:26 <k00mi> I think it's the name used in the definition
03:40:28 <iron_hou1> That's quite misleading IMO
03:41:12 <indiagreen> iron_hou1: it could've also been “[blah]”, actually
03:41:20 <indiagreen> you shouldn't get used to “a”
03:41:35 <iron_hou1> sure, I get it, it's just a symbol, but why not stay consistent?
03:41:42 <iron_hou1> indiagreen: OK
03:42:57 <k00mi> iron_hou1: it uses the name used in the definition of the type
03:43:09 <iron_hou1> OK
03:45:04 <niez> iron_hou1, I get :t [] => [] :: [a] on debian with ghci 7.6.3
03:45:52 <iron_hou1> OK, I'm on 7.8.3
03:47:20 <pingu> I don't think it's a breaking change ;)
03:47:29 <pingu> I really hope it's noti.
03:50:34 <k00mi> iron_hou1: what's the first line of output if you do ':i []'?
03:50:34 <iron_hou1> (True, id, [1, 2])
03:50:51 <iron_hou1> k00mi: I don't know what :i does
03:51:04 <eikke> :info
03:52:10 <iron_hou1> data [] a = [] | a : [a]        -- Defined in ‘GHC.Types’
03:52:56 <k00mi> seems I was wrong then, [] might be a special case
03:53:24 <iron_hou1> BTW, should this evaluate correctly: (True, id, [1, 2]) ?
03:54:03 <pingu> iron_hou1: why shouldn't it?
03:54:15 <iron_hou1> because I'm getting an error ..
03:54:25 <pingu> I shall try it
03:54:37 <niez> iron_hou1, ghci doesn't know how to print that value
03:54:44 <pingu> The error  is because ghci uses the Show instance to print anything you provide to console
03:54:49 <pingu> and it doesn't know how to print a function
03:55:28 <pingu> iron_hou1: try this:
03:55:31 <niez> iron_hou1, namely, it has problem with 'id' :)
03:55:34 <pingu>  instance Show (a -> b) where show _ = "hai!"
03:55:42 <pingu> then try again
03:55:56 <iron_hou1> That's confusing, since my computer lab wants me to write that in ghci ..
03:56:17 <pingu> your computer lab imposing a will seems more confusing
03:56:57 <iron_hou1> It's the edx course with that famous Haskeller, the Dutch professor .. I can't remember his name ..
03:57:17 <pingu> sounds pretty famous
03:57:38 <iron_hou1> Hehe .. to Haskell fans he should be
03:57:45 <pingu> iron_hou1: perhaps you missed a 'let'
03:58:00 <pingu> implausible, though.
03:58:07 <pingu> he's probably a sadist like most haskellers
03:58:26 <pingu> oh, that's masochism
03:58:58 <iron_hou1> "Try the following expressions: (True, id, [1, 2])"
03:59:48 <trap_exit> what's a good codebase to read for learning how to impelment FRP?
03:59:56 <trap_exit> I don't wnat to just use FRP. I want to understand how it works / how to impelment it.
04:00:04 <trap_exit> Thus, I'd like to find a good FRP library, and read its code.
04:00:44 <niez> iron_hou1, Jan van Eijck?
04:01:32 <iron_hou1> Erik Meijer
04:02:25 <pingu> iron_hou1: yeah, he's pretty famous
04:02:47 <pingu> I thought he was famous for being a MS researcher, though.
04:02:56 <pingu> linq and such
04:03:20 <iron_hou1> I still don't get why we're supposed to type that tuple into ghci ..
04:03:47 <pingu> iron_hou1: I think he was possibly thinking in tuples and he means type them individually.
04:03:59 <pingu> or he's a sadist. pick on.
04:04:04 <pingu> *one
04:04:43 <k00mi> trap_exit: there is no single way to implement "FRP", several different approaches exist that lead to different results
04:04:48 <keko-2> Maybe the point is to highlight that a tuple can contain things of different types?
04:05:08 <trap_exit> k00mi: hmm, where can I read about the different approaches
04:05:23 <keko-2> And maybe you're supposed to ask for the type of that tuple?
04:06:00 <keko-2> That is, type ":t (True, id, [1, 2])" into ghci
04:06:25 <k00mi> trap_exit: did you read conal's papers?
04:07:12 <keko-2> iron_hou1: It sounds like maybe, with context, that "try the following expressions" should be interpreted as "try asking ghci about the type of the following expressions"
04:11:11 <niez> iron_hou1, I can't see video on debian/firefox of that course :/
04:11:22 <iron_hou1> I can ..
04:11:33 <iron_hou1> niez: What version of FF?
04:12:12 <niez> iron_hou1, old one ;)
04:21:53 <iron_hou1> I am asked to pick options that will represent valid implementations of `last'. Why isn't this valid: "last xs = drop (length xs - 1) xs" ?
04:22:38 <hyPiRion> iron_hou1: what is the type of drop?
04:23:00 <iron_hou1> I see. Thanks hyPiRion
04:23:11 <hyPiRion> np :)
04:51:39 <vanila> Hey am I going crazy or is haskell less able to infer types recently?
04:51:53 <pingu> vanila: it'd probably make fromt page news
04:51:56 <vanila> im finding things not work without explicit annotations, but I thought everything would be inferred
04:52:06 <pingu> vanila: have you enabled extensions?
04:52:42 <vanila> I have {-# LANGUAGE GeneralizedNewtypeDeriving #-}
04:53:55 <pingu> vanila: AFAIK under standard haskell, type inference is *proven* decidable.
04:54:04 <pingu> I've not checked any of this, but I've heard it.
04:55:10 <vanila> --go :: (Bounded sigma, Enum sigma, Eq sigma, Ord sigma) => R sigma -> DFA sigma
04:55:10 <vanila> go = runAbstract abstractInterpreter
04:55:25 <vanila> when I comment that out I get errors about No instance for (Ord sigma0)
04:55:49 <pingu> are you using any modules that require extensions?
04:55:57 <pingu> directly, in that fragment?
04:56:16 <k00mi> pingu: false, e.g. 'show . read'
04:56:45 <vanila> i dont know, i use some monad transformers
04:57:27 <pingu> k00mi: it was all just a song and dance?
04:58:21 <vanila> that's really weird actually
04:58:34 <vanila> show . read  should be an error then
04:58:51 <k00mi> it's a type error
04:59:54 <pingu> k00mi: what is this wizardy
05:01:41 <k00mi> it's called typeclasses
05:02:18 <vanila> :t show
05:02:19 <vanila> :t read
05:02:19 <lambdabot> Show a => a -> String
05:02:20 <lambdabot> Read a => String -> a
05:02:27 <vanila> if you ignore the typeclassses ti would be
05:02:30 <vanila> String -> String
05:02:49 <BoR0> :t (show . read)
05:02:50 <lambdabot> String -> String
05:03:06 <k00mi> but it's not clear what type there should be inbetween
05:03:08 <vanila> so there's an 'a' in the middle there with a Show a, Read a  constraint in it
05:03:10 <pingu> okay.
05:03:17 <pingu> I just re-read what I had read.
05:03:24 <vanila> so why doesn't haskell error for that
05:03:34 <vanila> instead of just picking randomly
05:03:44 <pingu> and it says that the hindley-milner system was proven to chose the *most general* type
05:03:51 <tdammers> it should error
05:04:00 <k00mi> vanila: it's a type error, try compiling 'main = print $ read 3'
05:04:06 <hexagoxel> defaults to (), probably
05:04:11 <vanila> http://lpaste.net/112618
05:04:14 <vanila> Here's the error I get
05:04:15 <k00mi> no, maybe in ghci
05:04:20 <vanila> there's 43 other instances of Ord!
05:04:22 <vanila> This is ridiculous
05:04:41 <hexagoxel> > read "()"
05:04:41 <vanila> I just want the assumption, Ord sigma
05:04:43 <lambdabot>  ()
05:04:59 <indiagreen> http://qr.ae/xStb0
05:05:03 <k00mi> pingu: right, but typeclasses are not part of hindley-milner
05:05:06 <indiagreen> ouch, wrong window
05:05:33 <pingu> k00mi: this is the kind of thing I'm glad you've told me but was a little happier not knowing
05:05:46 <k00mi> hehe
05:05:48 <vanila> haha
05:05:50 <vanila> my thouhhts exactly
05:06:00 <vanila> shouldn't the code i pasted work though?
05:06:13 <k00mi> it rarely happens in actual code (that doesn't use extensions)
05:07:03 <k00mi> vanila: can you paste more code?
05:07:13 <AshyIsMe> hmm, what's this symbol called? ¬
05:07:38 <vanila> http://lpaste.net/3713761141705408512 this is the full code
05:07:44 <pingu> AshyIsMe: not?
05:07:52 <vanila> if you comment out line 169 it breaks!
05:07:59 <hyPiRion> negation
05:08:35 <AshyIsMe> not -, ¬
05:08:39 * hackagebot yesod-auth-hashdb 1.4.1 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.1 (paulrouse)
05:08:45 <AshyIsMe> do they look the same for you guys?
05:09:27 <sivteck> nope
05:09:57 <hyPiRion> I see a minus sign and a negation sign?
05:09:58 <bergey> Unicode says "not sign"
05:10:20 <AshyIsMe> ok damn, thought it was a nice looking symbol for let (¬) = flip ($)
05:10:46 <AshyIsMe> & just doesnt look like "pipe" to me
05:11:26 <vanila> instead of x ¬ f it would be better style to write f $ x
05:12:37 <AshyIsMe> well, f# has the pipe forward operator |> which makes for some nice looking code
05:12:58 <pingu> AshyIsMe: '$' doesn't realy look like apply to me either, so I'm kind of already defeated ;)
05:13:08 <AshyIsMe> haha yeah
05:13:30 <AshyIsMe> <| and |> would have some symmetry at least...
05:13:41 <pingu> symmetry would be nice, at the expense of two characters
05:14:05 <pingu> and \ ;)
05:14:10 <pingu> oh dear
05:14:16 <pingu> perhaps: / and \ ;)
05:14:19 <int-e> > let (▶▷►▻▸▹) = flip ($) in 1 ▶▷►▻▸▹ succ
05:14:22 <lambdabot>  2
05:14:37 <AshyIsMe> haha god, im not sure that is rendering correctly for me
05:14:41 <pingu> let (pewpewpewlazers) = flip ($)
05:15:18 <AshyIsMe> int-e: is this what it's meant to look like? http://i.imgur.com/qiBjHBY.png
05:17:33 <indiagreen> AshyIsMe: http://imgur.com/6RND9tE
05:17:57 <Ferdirand> hello #haskell, is there somewhere in the standard libs a function [IO ()] -> IO (), that would be the spiritual equivalent to (sequence_ . map forkIO), but without having to do mvar trickery to wait on all the children ?
05:18:46 <AshyIsMe> > let pipeforward = flip ($) in "dear " `pipeforward` (++ "god")
05:18:48 <lambdabot>  "dear god"
05:18:53 <int-e> AshyIsMe: close enough, it's 6 different triangles in a row: http://int-e.eu/~bf3/tmp/gggggg.png
05:19:02 <AshyIsMe> haha
05:19:26 <hexagoxel> @hackage parallel-io
05:19:26 <lambdabot> http://hackage.haskell.org/package/parallel-io
05:19:28 <hexagoxel> Ferdirand: ^
05:19:44 <zwer> Ferdirand I don't know about standard library, but there's mapConcurrently in async module
05:21:30 <Ferdirand> hexagoxel, zwer: thanks. I thought hoogle included all of hackage, apparently not ?
05:23:43 <hexagoxel> Ferdirand: nah, it is a fairly limited subset. hayoo has a slightly larger subset. not aware of any engine that does all in hackage.
05:26:39 <Ferdirand> well, parallel-io is just what i needed it seems, thanks much !
05:38:51 <danilo2> Hello! Is there such pattern matching in Haskell, whcih would allow me to write "Vector x ... = v" - when x is the fiorst variable and I do not care about the rest? I think I saw something like that in the past
05:39:34 <BoR0> Vector a _ _ = a
05:39:56 <Cale> danilo2: If Vector uses record syntax, there's a better way still than what BoR0 is suggesting
05:40:25 <Cale> Vector { vX = x } = v
05:40:42 <danilo2> BoR0: I was not talking about wildcards. I just do not want to list all of them. I was talking about the Cale 's solution, thank you Cale!
05:41:26 <Cale> Note that as a special case, even if the type wasn't declared using record syntax, you're allowed to use this syntax to match none of the fields (i.e. just to match which constructor is in use, like  Vector {}
05:41:28 <danilo2> Cale - but were the no "..." operator in patterns, or somethinfg even easier to yuse than your solution?
05:41:59 <Cale> (That's obviously only really useful when dealing with types that have more than one constructor)
05:55:51 <gigabytes> guys
05:56:06 <gigabytes> is there a generalized lookup function for lists of triples instead of lists of pairs?
05:56:19 <gigabytes> not that it's hard to code, of course
05:56:30 <Kinnison> Unless you're using lenses, I think you get to code it up
05:57:24 <vanila> gigabytes, It might be better to use (a,(b,c)) instead of (a,b,c) if possible
05:57:37 <vanila> then you can use the normal lookup
05:58:10 <gigabytes> vanila: yes it's easier
05:58:42 <gigabytes> Kinnison: actually I already use the lens package for other things so, what do you suggest in this case? (still learning how to fully use them)
05:59:18 <Kinnison> gigabytes: I'm thinking that lens must surely have what you want :-)
06:00:34 <gigabytes> Kinnison: ok I thought there was something obvious
06:00:54 <gigabytes> anyway, this is my first serious haskell project
06:01:00 <gigabytes> guys it's wonderful
06:01:20 * Kinnison loves lens, but cannot pretend to know very much about it :-)
06:01:28 * Kinnison is sure _1 _2 or _3 will be involved in your solution though
06:01:59 <gigabytes> yeah, sure
06:02:22 <kosmikus> gigabytes: have you considered using Data.Map rather than a list of tuples?
06:03:24 <gigabytes> kosmikus: yes but the key type is not an instance of Ord and not because it's hard to make it an instance but because it would be seriously slow.
06:03:44 <gigabytes> and the lists are too short to compensate
06:04:16 <kosmikus> ok, if the lists are short, then fine. otherwise, Data.HashMap might be another option.
06:04:48 <gigabytes> yes, very short
06:05:02 <gigabytes> bindings for local variables
06:05:15 <kosmikus> ok
06:05:23 <gigabytes> if someone write 1000 local variables in the same scope well, can sustain the pain of my compiler being slow :P
06:05:32 <kosmikus> :)
06:06:56 <kosmikus> gigabytes: if it's really only local variables, I agree. but e.g. in Haskell it's not uncommon to have several hundred of symbols in scope at the top-level of a module.
06:07:52 <gigabytes> kosmikus: yes of course but I'm parsing nothing like haskell! And I would not dare trying to do it actually :P
06:08:25 <gigabytes> well, not sure if doing a C++ parser would be even worse
06:08:35 <mathu> in type signatures, what is the significance of eg a1? sometimes i see (a -> b) and others i see (a1 -> a)
06:08:53 <gigabytes> mathu: just a type variable like a and b
06:08:56 <kosmikus> a1 is a valid name of a type variable, just like a or b
06:09:20 <mathu> is there a convention for when it shows up in :t ?
06:09:30 <gigabytes> good question
06:09:45 <Kinnison> I think it depends on how the unifier ran
06:10:08 <kosmikus> I think GHC uses a base name that was mentioned in the source code if possible, and attaches numbers to it when instantiating
06:12:21 <mathu> for instance, i have: (a -> b) -> a -> [b]; and (a1 -> [a]) -> [a1] -> [a]; source does not specify the type signature, that's what haskell infers
06:12:59 <mathu> i could replace a1 with b and no meaning would be lost?
06:13:07 <kosmikus> yes
06:13:09 <zwer> sure
06:13:22 <mathu> ... okay
06:13:22 <mathu> haha
06:13:28 <mathu> thanks
06:19:04 <indiagreen> gigabytes: I don't think lens is very useful for your task
06:19:20 <gigabytes> hi again indiagreen
06:19:30 <gigabytes> don't you think?
06:19:40 <gigabytes> well it's not worth it anyway
06:19:52 <gigabytes> that lookup' function is a one-liner
06:21:07 <indiagreen> because there's no “compose lenses” function I know of – i.e. you can't go from (a,b,c) to (b,c) by somehow composing _2 and _3, you can only compose (view _2) and (view _3) and this is ugly
06:22:16 <vanila> indiagreen++
06:22:42 <tdammers> :t _2 . _3
06:22:44 <lambdabot> (Field2 s t a b, Field3 a b a1 b1, Functor f) => (a1 -> f b1) -> s -> f t
06:23:26 <indiagreen> > (1,(2,3,4)) ^. _2 . _3
06:23:28 <lambdabot>  4
06:23:34 <indiagreen> not useful here
06:24:45 <indiagreen> oh, and not to mention that lookup for associative lists is ugly in lens as well
06:25:02 <indiagreen> because neither “ix” nor “at” can be written
06:25:05 <indiagreen> I tried yesterday
06:26:23 <indiagreen> (well, I mean, they obviously can be written, but I sort of suspect edwardk wouldn't accept a patch because they violate the laws)
06:31:55 <AshyIsMe> does ++ for Text not exist?
06:32:12 <dibblego> AshyIsMe: <>
06:32:30 <mr-> AshyIsMe: append?
06:32:51 <gigabytes> indiagreen: pretty clear
06:33:00 <mr-> Oh, it's a monoid
06:33:49 <AshyIsMe> dibblego: <> is not in scope after import Data.Text
06:34:05 <AshyIsMe> mr-: yeah that works but shouldnt ++ too?
06:34:09 <dibblego> import Data.Semigroup or import Data.Monoid
06:34:26 <AshyIsMe> :t ++
06:34:27 <lambdabot> parse error on input ‘++’
06:34:30 <mr-> AshyIsMe: ++ only works on lists - and a text is none
06:34:32 <AshyIsMe> :t (++)
06:34:33 <lambdabot> [a] -> [a] -> [a]
06:34:51 <indiagreen> AshyIsMe: there was a proposal several years ago (I think) to change (++) to work on all monoids instead of lists, but it didn't pass
06:35:01 <AshyIsMe> well that's a shame
06:35:16 <AshyIsMe> dibblego: cheers, i'll use the monoid one
06:35:23 <AshyIsMe> since i dont know what semigroup is yet
06:35:24 <mr-> AshyIsMe: You could just go ahead and _always_ use <> instead of ++ :-)
06:35:26 <indiagreen> if you want (++), you can use basic-prelude
06:35:36 <indiagreen> @hackage basic-prelude
06:35:36 <lambdabot> http://hackage.haskell.org/package/basic-prelude
06:36:02 <Cale> In Haskell 1.3, (++) was mplus (so it wouldn't have worked in this case, but at least in more cases than (++) currently does)
06:36:14 <AshyIsMe> haskell doesnt seem to choose the clearest of symbols for operators in general
06:38:59 <AshyIsMe> haha wow, this looks like dirty ascii art:
06:39:01 <AshyIsMe> import           Data.Monoid ((<>))
06:39:30 <hyPiRion> import Control.Applicative ((<*>),(<$>))
06:40:08 <AshyIsMe> mr-: yeap, i'll swap over to <>
07:00:34 <saep> cd yi
07:02:36 <joe9> joe
07:05:09 <uveer26> test
07:08:44 <niez> iron_hou1, how far are you in this course?
07:15:33 <sx> has anyone worked with the gtk3 bindings in haskell and knows how to find the source of memory access errors? ( this is no fun :) )
07:20:55 <xplat> has anyone here used http://sourceforge.net/projects/jvm-bridge/ ?
07:25:20 <sh1ken> xplat: I didn't know that such thing existed. Does it work?
07:28:05 <gigabytes> indiagreen: I'm even more unsure about prisms. If I have a type like data T a = C1 a | C2 a. Both constructors contains the same type. Is there a lens that say "the same field in whatever constructor I find"?
07:29:38 <gigabytes> something like "both" but for sum types instead of products
07:31:40 <xplat> sh1ken: that's basically what i wanted to know :-/
07:32:57 <xplat> gigabytes: if you name those fields (with the same name) then makeLenses should make you one
07:34:07 <gigabytes> xplat: ok, but there's another problem. Since I use also makeFields for other types, would makeLenses cause name clashes, or does it look at the type classes generated by makeFields?
07:35:34 <xplat> gigabytes: i'm having trouble figuring out what you mean.  it would probably be easier to just try it and find out than attempt to explain further.
07:36:18 <gigabytes> xplat: right
07:38:24 <k_bx> Hi everybody! I just created a monad for «circuiting yor computations», and before I got too shamed by mailing list and hackage users, I wanted to ask: is there anything like that present already? Or is it stupid in some other way? Thanks! https://github.com/k-bx/circuitt
07:38:46 * hackagebot hindent 3.9 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.9 (ChrisDone)
07:41:17 <xplat> k_bx: well, that's normally known as 'short circuiting', not just 'circuiting'
07:41:42 <k_bx> xpika: thanks, I’ll think on better name!
07:51:11 <pjdelport> k_bx: Does that differ from EitherT ?
07:52:44 <pjdelport> k_bx: Or rather, what does that do that EitherT doesn't?
07:52:48 <k_bx> pjdelport: it’s implemented on top of EitherT, difference is that it restricts you to have left and right of the same type, and gives you «return» operator (called «escape» currently) of a more clear (I think)
07:53:08 <k_bx> *of a more clear name
07:53:47 * hackagebot json-rpc 0.2.1.0 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.0 (XenoGenesis)
07:53:50 <k_bx> pjdelport: and because left and right are same type, it also unpacks result from Either a a to a for you
07:53:57 <edwardk> so what advantage does having that give over just using type CircuitT m a = EitherT a m a; runCircuitT = fmap (either id id) . runEitherT
07:54:05 <edwardk> the newtype doesn't seem to win you anything
07:54:52 <pjdelport> k_bx: I definitely don't want to dampen your enthusiasm, but yeah, it seems like too small a renaming to be worth an entire package, probably.
07:57:38 <dfeuer> Cale, you around?
07:57:40 <k_bx> edwardk: yeah, there’s no advantage over just type-synonym I can think of, probably try to go this way for now
07:59:55 <k_bx> pjdelport: makes sense, I’ll keep it private for now. Thing I was excited about was that it kind of «clicked» for me that it somehow built a connection between haskell-monads and classic language’s «return» operator in my mind finally.
08:00:17 <pjdelport> k_bx: That's a good thing!
08:00:24 <Cale> dfeuer: hi
08:00:40 <dfeuer> Cale, did you see my message yesterday?
08:01:33 <fizbin> I've found using newtypes instead of synonyms occasionally keeps me from doing something stupid.
08:01:59 <pjdelport> k_bx: It's a good base to explore further on.
08:02:02 <bergmark> yes that's a good feature of newtypes :-)
08:02:15 <bergmark> type synonyms are mostly just confusing imo
08:02:20 <xplat> how can i share a cabal sandbox among several subprojects with their own subdirectories?
08:02:27 <fizbin> It seems to keep me from doing something stupid about as often as it slows me down and annoys me with bouncing in and out of the newtype, so it's often a coin flip.
08:02:32 <k_bx> pjdelport: I decided to probably just write simple-stupid tutorial on fpcomplete and see if someone also finds it interesting (so they can copy-paste type-synonim)
08:02:53 <k_bx> xplat: cabal sandbox init —sandbox=/path/to/shared/sandbox
08:03:04 <pjdelport> k_bx: You might want to explore some related types, like Cont!
08:03:11 <xplat> k_bx: aha, thanks
08:03:16 <Cale> dfeuer: I'm not sure, if I didn't respond to it, then perhaps not
08:03:55 <bergmark> xplat: use cabal --sandbox-config=path/to/cabal.sandbox.config
08:04:02 <pjdelport> k_bx: Cont is probably the most important type in this regard: it gives you even greater control over returning and control flow than a classic language's "return" operator.
08:05:19 <volty> on cabal install packedstring:  Use -XStandaloneDeriving to enable this extension
08:05:47 <volty> is it possible, and how, to put options in the command line of cabal install ?
08:06:13 <glosoli> Started going through FP Into course on edx, kinda curious how come this is corrent "last xs = drop (length xs - 1) xs" and this isn't?  "last xs = head (reverse xs)"
08:06:19 <glosoli> correct"
08:06:36 <c_wraith> volty: no.  Especially not with extensions like that one that enable new syntax
08:06:54 <c_wraith> volty: that extension does nothing unless you use the new syntax it enables
08:07:16 <fizbin> :t \xs -> drop (length xs - 1) xs
08:07:17 <lambdabot> [a] -> [a]
08:07:18 <c_wraith> > head (reverse [1..10) -- glosoli
08:07:19 <lambdabot>  <hint>:1:21: parse error on input ‘)’
08:07:24 <c_wraith> > head (reverse [1..10)) -- glosoli
08:07:25 <lambdabot>  <hint>:1:21: parse error on input ‘)’
08:07:31 <c_wraith> > head (reverse [1..10]) -- glosoli
08:07:32 <lambdabot>  10
08:07:32 <volty> c_wraith: so? I cannot install it just for that file ? (needed for installing fudgets)
08:07:34 <fizbin> :t \xs -> head (reverse xs)
08:07:34 <volty> ?
08:07:35 <lambdabot> [a] -> a
08:07:40 <fizbin> :t last
08:07:41 <lambdabot> [a] -> a
08:07:45 <volty> s/file/package/
08:07:54 <c_wraith> volty: you have to *change source* to use it
08:08:04 <c_wraith> volty: you can't just enable the extension and have it magically solve problems.
08:08:32 <xplat> c_wraith: but you won't get that error unless the syntax is already being used in some sourcefile
08:08:48 * hackagebot ClustalParser 1.0.0 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.0.0 (FlorianEggenhofer)
08:09:05 <c_wraith> xplat: oh, right.  I mistook it for the other error, where it tells you to try -XStandaloneDeriving for something
08:09:15 <fizbin> glosoli: It seems that the given solution (last xs = drop (length xs - 1) xs) doesn't have the same type as the solution you wanted (last xs = head (reverse xs))
08:09:27 <c_wraith> volty: in that case, it's an error that the package doesn't set the flag on files that need it
08:09:28 <k_bx> pjdelport: yeah, I think I’ve been into cont monad several times before, I especially enjoyed this one http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
08:09:29 <glosoli> fizbin: but they both seem valid..
08:09:30 <volty> c_wraith: ok, so I have to put extensions: in the cabal file, if you tell me how to locate it I would be grateful (otherwise i google) // i'm on ubunut, haskell-platform installed, thx anywy
08:09:42 <fizbin> glosoli: That said, the function "last" as I've seen it before has the type of what you said.
08:09:59 <fizbin> glosoli: So I'd need to see the problem from the edx course.
08:10:12 <fizbin> glosoli: Wait, you don't see how the two solutions are different?
08:10:14 <glosoli> fizbin: "The library function last, which selects the last element of a non-empty list, can be defined in terms of the library functions introduced in this chapter. Choose one or more possible definitions."
08:10:15 <volty> c_wraith: of course, i imagine there are so many errors like that around ...
08:10:38 <glosoli> ah shit I see...
08:10:40 <fizbin> glosoli: Oh. That should then be head (reverse xs)
08:10:41 <k_bx> pjdelport: but the amount of control it gives you is of course way too big if all you want java-return-like functionality :)
08:10:43 <c_wraith> volty: I mean, it's an error of "where did you even get a package broken like that from" proportions
08:10:44 <glosoli> fizbin: one or more, silly me...
08:11:05 <c_wraith> volty: it's not just a minor thing, it's a "totally can't work, what the heck happened?" thing
08:11:11 <iron_hou1> niez: I just started today. First week of the course. Frankly, I'm a bit disappointed with the course. The instructor has just talked about the history of FP and why FP is worth learning. Then, we're supposed to buy a book and learn what we need to know to solve the homework assignments from the book. I don't mind having a book as a supliment to the lectures, but if this course continues to have the bulk of
08:11:13 <iron_hou1> the learning material be derived from the book and not the lectures, I'm probably not going to continue with the course.
08:11:15 <fizbin> glosoli: But the one you mentioned (based on drop) isn't correct!
08:11:38 <fizbin> glosoli: The drop-based solution would give [3] for (last [1, 2, 3])
08:11:46 <fizbin> It should give just "3"
08:11:47 <gigabytes> guys, can I derive automatically an instance for Hashable?
08:11:55 <kuribas> gigabytes: yes
08:12:00 <gigabytes> how?
08:12:06 <gigabytes> just deriving (Hashable) ?
08:12:27 <glosoli> fizbin: weird hmm maybe it just highlighted the wrong solution and I was supposed to check the other ones that were correct too
08:12:32 <kuribas> gigabytes: https://hackage.haskell.org/package/hashable-1.2.1.0/docs/Data-Hashable.html#g:4
08:12:47 <volty> c_wraith: I'm trying to install Fudets, Fudgets are not in cabal, I downloaded them from their home site, they need the deprecated packedstring package
08:12:58 <gigabytes> kuribas: wops, I was already on that page but I didn't scrolled down :P
08:13:12 <kuribas> gigabytes: yes, it's all there :-)
08:13:25 <volty> c_wraith: can you suggest me another, highlevel !, gui package ?
08:13:48 * hackagebot Genbank 1.0.2 - Libary for processing the NCBI genbank format  http://hackage.haskell.org/package/Genbank-1.0.2 (FlorianEggenhofer)
08:13:56 <dcoutts_> volty: if you really want to make that old package work, you might have more luck with a correspondingly old ghc, e.g. early 6.x
08:14:11 <gigabytes> kuribas: thanks
08:14:13 <volty> btw I found the packedstring-0.1.0.1.tar.gz, i'll  try anyway later
08:14:16 <kuribas> gigabytes: np
08:14:40 <dcoutts_> volty: iirc, ghc-6.2 and older came with that
08:14:49 <volty> dcoutts_: i'm evaluating haskell for production, cannot go with a nightmare of multiple versions
08:15:04 <dcoutts_> oh then don't even think about using something so old
08:15:19 <dcoutts_> it's of archaeological interest only
08:15:27 <volty> what is the high-level alternative of fudgets? anybody of you tried using something else ?
08:15:36 <dcoutts_> volty: we can give advice on managing packages & versions sensibly
08:15:37 <niez> iron_hou1, get that book, it's 'must have' for beginer
08:15:50 <volty> dcoutts_: i got it! thanks :)
08:15:51 <niez> iron_hou1, anf check out videos on cloud9
08:16:07 <c_wraith> volty: http://hackage.haskell.org/package/reactive-banana-wx is the only thing I've used at all.  I have no idea how it scales up.
08:19:19 <zmbmartin> Can I add a type constraint so only data with a id attribute can use a function?
08:19:25 <volty> neither reactive-banana installs, Could not find module `Data.IntMap.Strict'
08:19:43 <xplat> lol, the source of this jvm bridge uses braces-and-parentheses style in haskell!
08:20:03 <volty> (7.4.1 here)
08:21:20 <xplat> i'm having to fix a lot of bitrot, although i can blame a lot of it on -Werror
08:23:48 * hackagebot json-rpc 0.2.1.1 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.1 (XenoGenesis)
08:32:28 <xplat> now it wants to find something in /usr/lib/jvm-bridge/
08:32:45 <xplat> where the heck is that supposed to come from?
08:37:50 <volty> i succeeded compiling fudgets, but now, on import Fudgets,  it says: Could not find module `Fudgets'  \ń It is a member of the hidden package `fudgets-0.15'.
08:38:20 <xplat> maybe i should just use neurocyte's foreign-jni
08:43:53 <xplat> seems a lot more basic but at least it builds
08:47:03 <gfixler> I ended up watching Haskell videos in reverse order
08:47:29 <gfixler> each speaker mentioned hackage, but each kept saying a lower number of packages
08:47:44 <gfixler> starting with: "Hackage has about 5 to 6 thousands packages on it." - Midwest.io 2014 - Demystifying Haskell - Andrew Rademacher
08:47:45 <xplat> volty: you need to use -package fudgets
08:47:49 <gfixler> ending with "It's called Hackage [...] a hundred odd packages available at the moment, I think." - A Taste of Haskell - part2 July 23, 2007 - SPJ
08:56:48 <Sornaensis> is anyone here
08:56:54 <vanila> Wow https://lobste.rs/s/gsitxb/why_everyone_hates_go/comments/yco3k8#c_yco3k8
08:57:01 <vanila> what a rude person
08:57:11 <vanila> insane
08:58:39 <Cale> Sornaensis: sure :)
08:59:08 <Cale> vanila: Who is rude?
08:59:26 <vanila> bitemyapp "Please leave me alone now." etc.
08:59:38 <Cale> Is that rude?
08:59:44 <MP2E> we.., at least he said please
08:59:46 <MP2E> well*
09:00:09 <MP2E> was a bit of a snappy response though :P
09:00:24 <Cale> It just sounds like he's frustrated with other people arguing about his decisions. I don't know if that's rude. Maybe it's a bit impatient.
09:00:33 <vanila> fair enough :)
09:01:41 <vanila> "it’s trying my patience to be civil right now." -- seems very "go away, I don't want to talk to you. I'm very this close to getting nasty"
09:02:51 <simpson> vanila: Whatever. It happens. Leave it.
09:03:06 <vanila> weird how emotional people get about technical things like unsafePerformIO
09:03:22 <Cale> Yeah, there's really no need to get very emotional here
09:04:25 <Cale> I have seen bitemyapp get into it a bit from time to time, but I guess that's just how his personality is :)
09:05:13 <simpson> vanila: Have you ever heard the phrase "purity is strength?"
09:05:21 <vanila> i don't recognzie it
09:05:26 <bitemyapp> vanila: I wanted to be left alone
09:05:36 <bitemyapp> vanila: is that an unreasonable request? I have notifications turned on in lobste.rs
09:05:50 <bitemyapp> vanila: if they want to debate design decisions they should evince some understanding of the service they're debating.
09:05:58 <Cale> bitemyapp: Usually if I want to be left alone, I just won't reply :)
09:05:59 <bitemyapp> vanila: the comments betrayed an ignorance of the service, which means they were wasting my time.
09:06:05 <Sornaensis> how do I convert an XmlTree back to a String with Hxt
09:06:14 <Cale> But yeah, it's hard to just let people say things that you disagree with :P
09:06:18 <volty> I got it functional  (fudgets) ---- meaning that now it runs, though way too functional :)
09:06:31 <bitemyapp> vanila: I didn't really want to explicitly say in the thread, "You don't know what the fuck you're talking about. Let me alone until you do."
09:06:38 <bitemyapp> vanila: so I politely (in my mind) requested that they leave me alone.
09:07:04 <bastian__> hey! new to haskell and currently trying to write a parser using attoparsec. question: will it parse the whole file and uppon success return a result with one big list?
09:07:18 <bitemyapp> bastian__: the result is whatever your parser types are.
09:07:40 <bitemyapp> bastian__: http://bitemyapp.com/posts/2014-10-02-parsing-and-rendering-templates-in-haskell.html this only returns [Node] Because I have a parser that returns [Node]
09:07:49 <bitemyapp> bastian__: could've been vector, could've been a tree, could've been anything.
09:08:07 <bastian__> I only want to iterate over the lines and do sth. (insertion into database), not have a final result
09:08:22 <vanila> bitemyapp, are you interested in discussing it here?
09:08:50 <bitemyapp> vanila: if I am rude, how rude is linking the thread saying, "what a rude person" in #haskell?
09:09:08 <bitemyapp> vanila: I said, "Pleave leave me alone now". Do you want me to beg you not talk about me?
09:09:22 <bastian__> here's what I have so far: http://paste.lisp.org/display/144051
09:09:28 <bitemyapp> vanila: I have work to do, coffee to drink. etc etc
09:09:39 <Cale> Sornaensis: There's writeDocumentToString :: ArrowXml a => SysConfigList -> a XmlTree String
09:10:19 <bastian__> don't want to have a Result with a list of Lines, but do sth with each Line, while the parsing is going on
09:10:39 <bitemyapp> bastian__: this isn't going to help you solve your problem (sorry), but for Haskell highlighting of your pastes consider: http://lpaste.net/
09:10:48 <bitemyapp> bastian__: it'll auto-link the paste for you from the bot if you select the channel too.
09:11:03 <bastian__> bitemyapp: thanks, will use that one
09:12:08 <Cale> Sornaensis: HXT makes a lot of really weird design decisions... I'm not entirely sure why it makes a lot of them. It's kind of a shame that it's got to be weird, since it's so comprehensive.
09:12:32 <Cale> For example, the arrows that it uses are actually monads.
09:12:39 <bastian__> http://lpaste.net/112625
09:13:06 <bastian__> (didn't get posted automatically, not sure why)
09:13:06 <volty> it's all about looking stranger than the strangest :)
09:13:18 <dfeuer> Cale, sometimes you make something with a certain abstraction in mind, and forget to look back and notice that it satisfies a stronger one.
09:13:32 <Cale> Well, early versions of the library actually had a monad
09:13:33 <bitemyapp> bastian__: did you select an IRC channel?
09:13:36 <vanila> What are peoples thoughts on the NOINLINE unsafePerformIO create IORef/MVar trick?
09:13:41 <Cale> and for some reason they changed it to use Arrow
09:13:52 <bastian__> bitemyapp: yes, #haskell (here?!)
09:13:52 <bitemyapp> carter: ^^
09:13:59 <dfeuer> Maybe they thought they could optimize something better that way, and then weren't able to or didn't get around to it?
09:14:00 <bitemyapp> bastian__: yeah. huh. let me try.
09:14:05 <carter> bitemyapp: what?
09:14:09 <lpaste> test pasted “test” at http://lpaste.net/112627
09:14:13 <bitemyapp> bastian__: ^^
09:14:16 <bitemyapp> carter: vanila's request.
09:14:21 <Cale> dfeuer: I don't know, perhaps
09:14:22 <bitemyapp> carter: "What are peoples thoughts on the NOINLINE unsafePerformIO create IORef/MVar trick?"
09:14:22 <bastian__> there it is :)
09:14:36 <carter> its kosher
09:14:44 <bitemyapp> vanila: ^^
09:14:47 <bitemyapp> vanila: see that?
09:14:51 <bitemyapp> vanila: can you leave me alone now please?
09:15:19 <Cale> dfeuer: Though their arrow is really terrible, it includes IO and fails the nice extra laws which the Arrows paper disavowed but which you actually need in practice if you want to implement Arrows well.
09:15:34 <volty> the next cute language, maybe haskell++, should rule out the possibility of defining new operators, should eliminate all those weirdy arrowers around :)
09:15:54 <Cale> volty: Well, Arrow is very close to being something quite useful
09:16:18 <volty> let them build it into the language and stop there
09:16:21 <dfeuer> carter, what trick is this? Is it the horrid hack recommended by http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html ?
09:16:44 <Cale> volty: It's just slightly missing the mark, and as a result, it sort of undermines most of the libraries which would *really* benefit from the abstraction
09:16:59 <vanila> bitemyapp, um kinda scary to randomly PM me
09:17:00 <carter> which line of text in the huge document
09:17:05 <dfeuer> Cale, are chances good of Arrow's resurrection into something better?
09:17:09 <vanila> I haven't said anything to you
09:17:13 <bastian__> I think my question is: how does one do streaming parsing using (atto)parsec?
09:17:17 <Cale> dfeuer: I think so
09:17:31 <dfeuer> And, if so, will that necessitate another change to the class hierarchy?
09:17:52 <Cale> dfeuer: It'll involve refining Arrow into a new bunch of stuff
09:17:57 <dfeuer> carter, search that document for "unsafePerformIO".
09:18:07 <bitemyapp> vanila: the code is fine. Will you leave me alone now?
09:18:18 <Cale> dfeuer: Exactly how you want the hierarchy to look, well, there are a bunch of viable options
09:18:21 <carter> dfeuer: you have to make it NOINLINE
09:18:21 <volty> Cale: i catch and agree. The haskell community should split, and throow out the weird complicators that just complicate for the sake of posing as the only experts that can use & read & modify (???) their code
09:18:33 <Cale> dfeuer: But at the very least, arr needs to be separated out
09:18:37 <bastian__> should I use pipes-attoparsec for that?
09:18:46 <bitemyapp> vanila: are you done taling about other people in IRC? Lesson learned?
09:18:47 <dfeuer> Cale, I don't know nearly enough about these things to have an opinion.
09:19:30 <Sornaensis> does anyone here have extensive knowledge of hxt
09:19:43 <dfeuer> carter, the question is whether that kind of hack is something that should be *encouraged*. It looks more like something that is getting in the way of coming up with the Right Way.
09:19:45 <vanila>    children = unsafePerformIO (newMVar []) -- this is pretty weird
09:19:50 <carter> dfeuer: no
09:19:51 <vanila> why isn't newMVar [] done in main?
09:20:00 <volty> dfeuer: i'm not yet up too, but my common sense smells the weirdys that ruin such a nice language
09:20:28 <carter> dfeuer: or at least,  I'm skeptical that something better is possible with the semantics we give top level definitions
09:20:35 <carter> and is easy
09:20:36 <carter> sooo
09:20:49 <vanila> carter, you could just pass it as an extra parameter, or a monad
09:20:49 <dfeuer> carter, if the top level definitions have the wrong semantics .....
09:20:51 <carter> no
09:20:56 <carter> it works
09:20:58 <carter> its simple
09:21:08 <carter> you have to propose something that works and is simple
09:21:17 <vanila> no one is arguing that it doesn't work, or that it breaks referential transparency
09:21:25 <carter> no ones arguing period
09:21:27 <vanila> it does work, and it's a safe use of unsafePerformIO
09:21:30 <carter> yup
09:21:35 <carter> agreed
09:21:37 <vanila> but it's really bad code!
09:21:42 <simpson> vanila: How is it bad?
09:21:43 <carter> depends
09:21:57 <carter> vanila: i do agree forcing a globally shared context is lame
09:21:57 <c_wraith> Sornaensis: my knowledge of hxt is best summarized as "too complicated, use something else"
09:22:05 <carter> and sometimes its better to thread a context / handle around
09:22:12 <bitemyapp> carter: it has to be for the service I've got atm until something else is done.
09:22:22 <carter> yeah
09:22:24 <bitemyapp> carter: if you have multiple instances of the service running, you will generate duplicate unique ids.
09:22:31 <carter> well yeah
09:22:32 <bitemyapp> carter: you *cannot* thread around multiple copies of the server state.
09:22:34 <mikeplus64> using unsafePerformIO will also mean you have to mark your module Trustworthy instead of Safe (or just Safe)
09:22:41 <Cale> volty: There's not so much around which is just weird for the sake of being weird
09:22:44 <carter> bitemyapp: unless you give each context a different prefix :)
09:22:55 <bitemyapp> carter: not in the semantics of the id service for a reason.
09:22:57 <bitemyapp> carter: otherwise, yes.
09:23:03 <carter> i kno
09:23:04 <bitemyapp> carter: the "prefix" is the MAC address. it's unique per MAC.
09:23:04 <Cale> volty: There are usually reasons for all the design decisions that people make, and some things are a matter of taste
09:23:09 <bitemyapp> so until I do something to make mutex happen for each MAC address, I have to keep it singleton.
09:23:14 <carter> bitemyapp: i'm not talking about black tip
09:23:15 <carter> i know you are
09:23:17 <carter> :)
09:23:57 <bitemyapp> carter: but that's not how an adversarial conversation partner will use it.
09:24:04 <bitemyapp> carter: they'll quote it as if it was about blacktip.
09:24:09 <carter> hah
09:24:11 <carter> well
09:24:25 <carter> if someone misquotes me, woe betide them :)
09:25:31 <vanila> simpson, it's just bad style to use something that breaks one of the core priciples of the language
09:25:42 <carter> not always
09:25:46 <carter> depends on the use caes
09:25:55 <carter> if the lib is meant to be an "application"
09:26:04 <bitemyapp> vanila: so you're saying Simon Marlow and Bryan O'Sullivan's code is bad?
09:26:06 <carter> thats very different from if its meant to be a lib for other peoples applications
09:26:08 <xplat> Cale: i still think Arrow is a legit abstraction, with the effect ordering and all, but i'd still like to see the versions without arr get some kind of standard status since they're good abstractions too
09:26:13 <carter> everyone be nice
09:26:23 <volty> often reinventing the wheel: you just css & xpath access ... but you have to fight with the damn arrows around // the parsing of xml is done in other languages, enough to copy a/the clean interface, but we are about inventing a «intelligent wheels» - to study, then use, and then remain stucked because you can't pipe certain condittions
09:26:27 <vanila> bitemyapp: are you happy to engage in discussion with me now?
09:26:30 <simpson> vanila: Haskell provides no way to instantiate modules multiple times with parameterization.
09:26:38 <simpson> vanila: Thus, *Haskell itself* encourages this bad style.
09:26:48 <carter> yes/no
09:26:48 <xplat> Cale: it's kind of unfortunate though that the flagship arrow user is hxt which shouldn't be using arrows at all
09:26:49 <volty> could be (as you say), i'll keep reading and trying to use
09:27:06 <carter> xplat: lets patch ... hxt .... wait no its tooo much code
09:27:06 <Cale> xplat: Well, the real flagship is Yampa
09:27:06 <carter> :)
09:27:29 <Cale> xplat: But... I don't know how many people are still using Yampa
09:27:32 <Sorella> simpson, until now, though. Until now. Though. (see backpack)
09:27:36 <bitemyapp> Cale: good news
09:27:41 <bitemyapp> Cale: http://keera.co.uk/blog/2014/10/15/from-60-fps-to-500/
09:28:14 <xplat> carter: i started to rewrite hxt once, didn't get very far :(
09:28:15 <Cale> That page is being really slow to load for me
09:28:21 <volty> they want it «functional» --- it's the same crappy parsing, as in other langs, but they want you to combine in «functional manner»
09:28:30 <volty> too many functional idio....
09:28:40 <Sornaensis> if I have a document with a bunch of span tags and inside those span tags are paragraph tags how can I get a list of the text of the paragraphs, group according to the span tag they came from using hxt
09:28:41 <volty> ms
09:28:52 <Cale> volty: Well, >>> is a meaningful operation. It's just, so is >=>
09:29:06 <simpson> Sorella: Sure.
09:29:09 <Cale> volty: So if they'd just stuck with a monad, you'd still be able to largely write the code in a similar style
09:29:19 <ChristianS> Sornaensis: paragraph inside span is invalid html, incidentally
09:29:40 <bitemyapp> Sorella: backpack is ready? I hadn't seen anything on ezyang's blog.
09:29:41 <Cale> volty: The style which is encouraged by HXT can be very nice
09:29:41 <carter> simpson: the analogue of module functors in haskell are type classes. not modules
09:29:42 <volty> it is a question of choice: instead of >==< i prefer `connect`, without having to rewrite it
09:30:16 <Sorella> bitemyapp, I don't know if it's ready, but SPJ mentioned as one of the things coming to GHC in one talk recently iirc?
09:30:16 <volty> «could» - yet to see
09:30:26 <Sorella> I have a really bad memory though so I might be wrong
09:30:26 <simpson> carter: Sure, but when somebody else writes the type class, they don't necessarily give you the room necessary to do things like cart around private state.
09:30:37 <carter> simpson: then you should talk with them
09:30:41 <xplat> volty: well tbh xpath and css both have serious deficiencies.  xpath is much more powerful, but it doesn't support things like html's 'class' mechanism cleanly.  css has 'class' built in, but it's not very transferable to general xml and it's clunky and limited, and *must* be for its original use
09:30:44 <carter> or have a private branch :)
09:30:44 <bitemyapp> Sorella: I'd been following Backpack's development, still think they're reconciling typeclasses and modules.
09:30:54 <eacameron> is there a channel specifically for Shake (the build system)?
09:31:00 <carter> eacameron: not really
09:31:01 <bitemyapp> Sorella: but hopefully with Ed Yang on board things will speed up and we'll have modules Real Soon Now (™)
09:31:05 <Sornaensis> sorry, they're font tags
09:31:11 <bitemyapp> Sorella: it's not an imminent feature the way say, AMP is, though.
09:31:14 <carter> bitemyapp: a lot of the basic work is in GHC hea
09:31:19 <carter> *HEAD
09:31:35 <volty> xplat: let's talk about simple handling what is already there, whether perfect or deffiicient
09:32:02 <Cale> I've used HXT, several years ago, just a little hack to process some XML documents for TV listings and construct a little web application for my family to use with the TV computer. It was pretty straightforward, and as I recall, HXT's primitives made a lot of sense there. It's just the fact that it's Arrow specifically, and not just a bunch of functions a -> M b that's a bit funny.
09:32:25 <volty> now I stop, have yet to use it for transformations, will come back to tell you ....
09:32:30 <Cale> I guess you could say it encourages people to put things together in the right way
09:33:21 <Cale> If you're using the ArrowApply instance with HXT a whole lot, that's pretty weird
09:33:24 <volty> provide a simple, clean interface, and, appart, propose arrows combinations and the likes --- that's what I'm saying
09:33:37 <carter> Cale: could it all just be a bunch of profunctors?
09:33:39 <carter> or applicatives?
09:34:00 <Cale> carter: yes, well, it's more than an Applicative already, it's a Monad which has been disguised as an Arrow
09:34:10 <xplat> volty: it may be that your idea of a 'simple, clean interface' is still biased by the commonalities of other languages you've used
09:34:52 <volty> xplat: of course, we, common, prefer commonalities (just for the sake of getting the job done)
09:34:59 <Cale> carter: It's an instance of ArrowApply, and any such Arrow is the Kleisli of some monad.
09:35:12 <volty> (in a speedy way, if possible)
09:35:53 <Cale> newtype IOSLA s a b = IOSLA { runIOSLA :: s -> a -> IO (s, [b]) } -- this is the main arrow which gets used
09:35:59 <volty> haskell is nice and strong, the problems lie in implementors that complicate the things just to pose as not-common :)
09:36:36 <xplat> volty: what i mean is, probably other languages you've used have a *lot* in common, as in, there are very few actual differences between them outside of syntax
09:37:32 <xplat> volty: so usually what's a nice interface to use in one of them looks pretty similar to what's a nice interface in a different one
09:37:47 <Cale> volty: I can't really say I agree with that...
09:37:57 <Sornaensis> basically I just need a way to grab sibling tags' text together instead of separately
09:38:09 <Cale> volty: Nobody's complicating things just to be different.
09:38:18 <xplat> if you have a language that's actually different, though, then what's nicest to use in it can look very different different
09:38:22 <volty> yes, but the syntax reflects & influnces the mind (& viceversa), try to express yourself in Pygmy language (and that's the syntax)
09:38:42 <Cale> volty: hm?
09:39:17 <volty> the syntax is integral part of the language
09:40:18 <volty> when you have to get the semantics the syntax, the constructs, may come on your way
09:40:26 <carter> syntax is boring
09:40:28 <carter> but full of flames
09:42:07 <Cale> Syntax can be very important, but it is somewhat boring too.
09:42:09 <volty> anyway, think whatever you want but my convinction is that the haskell would boost if the libs are written in a simple way, without too much decorating arrows, without too much pompous theory contorting
09:42:32 <Cale> volty: What are you referring to specifically?
09:42:34 <Sornaensis> does anyone know how to do this ;__;
09:42:45 <Cale> volty: I don't see much which could be called "pompous" :P
09:42:48 <MP2E> 'pompous theory contorting'? :P
09:43:12 <Cale> Sornaensis: ummm
09:43:18 <MP2E> I would agree that Haskell libraries are generally more abstract and perhaps based off of a math theory or something similar, but I don't see that as a bad thing
09:43:43 <exio4> it is actually a bad thing, because then you want abstract things in other languages and well, in those they are a pain
09:43:45 <volty> Cale:  :) plenty of it around, tutorials, libs, promotions (as if haskell was brand new, today's language) etc et
09:43:51 <exio4> ;P
09:43:57 <MP2E> in other languages, sure
09:43:58 <Cale> Sornaensis: I think maybe you're looking for listA :: a b c -> a b [c]
09:44:10 <MP2E> This is Haskell though. Why should we write Haskell libraries like we would in other languages?
09:44:11 <Cale> Sornaensis: Which collects all the things which match into a single list
09:44:24 <carter> i can totally write C in haskell
09:44:25 <Cale> volty: uhh...
09:44:26 <carter> or CMM in haskell
09:44:28 <MP2E> I feel like you're shooting yourself in the foot if you aren't writing abstract code.
09:44:47 <MP2E> Unless of course, you have to :)
09:44:49 <josephle> haskell is built on a foundation of "Abstract Nonsense", so clearly the same criticisms apply!
09:44:58 <volty> MP2E: to take advantage of haskell's types, haskell's matching ...
09:45:00 <Cale> volty: Maybe some of the earlier marketing stuff by FPComplete was a bit awful
09:45:08 <carter> FPCo fucked up their own marketing
09:45:22 <Cale> volty: But otherwise, I don't know what you're talking about
09:45:28 <volty> i believe so
09:45:50 <volty> Cale: i didn't take notes on weirdy docs around, sorry :)
09:45:56 <Sornaensis> I don't know how to express this I guess
09:46:22 <Sornaensis> I just need to grab every span and then collect the contents of tags inside each span
09:46:24 <Sornaensis> but group those
09:46:58 <Sornaensis> otherwise there's no way to tell what span they came from
09:46:58 <Sornaensis> because this page is terrible
09:47:05 <volty> I go on with Fudgets because I like to finish the Fudgets book (or doc, or whatever it is).
09:47:11 <volty> bye, nice talking to you
09:47:23 <Cale> Sornaensis: Like, if you have some arrow f which processes an XmlTree and matches a bunch of specific XmlTrees, you can write f >>> listA and it'll instead match just once, with the result being the list of things matched.
09:48:10 <ParahSailin_> Sornaensis: yeah, use xml-conduit
09:48:33 <Cale> Sornaensis: Okay, let me see if I can write this :)
09:48:46 <xplat> and if you want a nested list of lists from two nested matches: outerMatch >>> (innerMatch >>> listA) >>> listA
09:49:12 <Cale> yes
09:50:25 <xplat> btw that shouldn't work because it breaks associativity of >>>, but it probably works anyway
09:51:00 <xplat> because hxt's monads use naïve ListT
09:51:09 <Cale> yeah :P
09:51:49 <merijn> I've used xml-conduit/html-conduit in the past and rather liked them, I managed to write an ok scraper without ever doing anything similar before
09:52:13 <Sornaensis> can you give me an example using runX...?
09:53:02 <xplat> merijn: i kind of wish i could find a version of that that uses something nicer than conduits
09:53:42 <xplat> i'd say machines but machines is still busted so pipes
09:54:42 <Cale> oh, no I'm wrong, listA is a little nicer, it's a function on arrows
09:54:51 <Cale> hasName "span" >>> listA (getAttrValue "id" &&& arr id)
09:54:51 <Cale>   :: ArrowXml cat => cat XmlTree [(String, XmlTree)]
09:56:16 <xplat> oh, then it's listA (outerMatch >>> listA innerMatch) and it's fine that it works
09:56:19 <buttons840> I'm looking for a function like so: f "abc" == ["a", "b", "c", "ab", "ac", "bc", "abc"]] any existing functions I can hoogle?
09:56:38 <Cale> :t subsequences
09:56:39 <lambdabot> [a] -> [[a]]
09:56:44 <martinhath> 7exit
09:56:52 <Cale> > subsequences "abc"
09:56:52 <xplat> > subsequences "abc"
09:56:54 <lambdabot>  ["","a","b","ab","c","ac","bc","abc"]
09:56:54 <lambdabot>  can't find file: L.hs
09:57:12 <buttons840> great, thank you
09:57:32 <xplat> buttons840: note it's not sorted by length, if that matters you need to add a sort
09:57:35 <Cale> Unfortunately, they're not quite in the order you want
09:57:57 <Cale> (and there's the empty one)
09:58:13 <Sornaensis> sweeeeeeeeeet
09:58:21 <Sornaensis> Cale: ty
09:58:31 <Cale> Sornaensis: no problem
10:01:25 <buttons840> Cale: sorting them myself will be a good (if easy) exercise ;)
10:05:05 <Cale> bitemyapp: That link finally loaded. :)  Pretty nice story, though the bold text is a bit crazy. I bet switching from Yampa to something cleverer would speed it up a lot further still, but designing and writing a clever FRP system is nontrivial :)
10:06:06 <Cale> bitemyapp: Our Arrowy FRP system at iPwn was already faster than Yampa when we wrote a new preprocessor for proc/do notation and some code to take advantage of the new operations we'd added to Arrow which sped up our game by a factor of 20 or so.
10:06:11 <xplat> foreign-jni doesn't bind JNI_CreateJavaVM :(
10:06:33 <jfischoff> Cale: you guys should open source it
10:06:36 <Cale> jfischoff: yeah
10:07:04 <jfischoff> Does ryan think you guys will get back to games?
10:08:04 <Cale> jfischoff: I dunno, we've been saying for a long time that we should really get together and cut it up nicely and open source the generally useful bits
10:08:12 <jfischoff> ah
10:08:14 <bitemyapp> Cale: wow @ factor of 20
10:09:17 <Cale> bitemyapp: and that's really not much, there's *so* many opportunities for optimisation which are exposed but we're not taking advantage of them
10:09:24 <Cale> It's just a lot of work
10:09:32 * jfischoff nods
10:11:05 <Cale> and to be honest the FRP system implementation is one of the most hairy pieces of Haskell code I've ever worked on
10:11:19 <danharaj> Ryan's?
10:11:22 * danharaj just got here
10:11:24 <danharaj> ;)
10:11:35 <Cale> Yeah. It's 8000 lines of code which involves some pretty heavy type hackery :)
10:11:57 <Cale> (As you'd expect of something which rewrites heterogeneously typed graphs)
10:12:30 <Cale> But at the same time, it's also quite nice
10:12:48 <jfischoff> uh “nice”
10:13:08 <Cale> and it's the sort of thing which if you were using C++, you'd definitely have given up on long before it had gotten as far as we did with it
10:13:29 <capisce> hmm, how so?
10:13:51 <jfischoff> That happens when I try to deserialize anything into C++
10:13:57 <Cale> jfischoff: Well, adding new rewriting optimisations is easy, it's nicely modular, the one use of unsafeCoerce we needed is wrapped up in a way which makes it safe, etc.
10:14:12 <xplat> if you were writing it in C++, a single type error would be longer than the Haskell version of the entire library
10:14:16 <Cale> haha
10:14:19 <jfischoff> intersting
10:15:10 <Cale> I did some refactorings on the code at one point which changed some of the basic data structures, which involved mechanically chugging through and fixing hundreds of type errors, and at the end once it compiled it also worked :)
10:15:35 <Cale> One of the best occurrences of that I've ever experienced :)
10:18:53 <Cale> capisce: Well, the amount of pattern matching deconstruction which goes on alone would make you pull your hair out if you had to write it in C++.
10:20:06 <zwer> > (sortBy (comparing length) . tail . subsequences) "abc"    -- buttons840
10:20:08 <lambdabot>  ["a","b","c","ab","ac","bc","abc"]
10:20:46 <texasmynsted> I do not suppose anybody knows of a nice link comparing haskell and scala syntax?
10:20:47 <Cale> capisce: But also just the way in which it used fancy types to keep the code from being broken and the fact that you can rely on everything being pure to keep such code understandable were both pretty important. I can't imagine how horrible it would be to work on that code if there were effectful things going on in the middle of it.
10:21:38 <Cale> (even though as a C++ programmer, you'd be very tempted to do a lot of what was being done in an effectful way)
10:22:12 <Cale> texasmynsted: hmm
10:22:22 <capisce> Cale: mhm
10:22:44 <capisce> Cale: shame you couldn't do the refactoring automatically
10:23:07 <Cale> capisce: Well, it was semi-automatic
10:23:19 <Cale> capisce: I just ran GHC, and fixed what it told me to fix
10:23:22 <texasmynsted> hmm?
10:23:46 <Cale> texasmynsted: Trying to think if I've seen such a comparison
10:23:54 * hackagebot rest-gen 0.16.0.3 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.0.3 (AdamBergmark)
10:23:56 <Cale> texasmynsted: Google found these slides http://scalacamp.pl/data/haskell-scala-handout.pdf
10:23:56 * hackagebot git-annex 5.20141013 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141013 (JoeyHess)
10:24:09 <texasmynsted> I am learning haskell, and know scala… Sometimes this can be confusing when moving from one to the other
10:24:14 <Cale> They have some pretty useful looking Rosetta stones on them :)
10:24:30 <josephle> interestingly, some of the syntactic differences between haskell and scala also denote underlying semantic differences ;)
10:25:00 <josephle> like haskell's data types vs scala's abstract classes for building recursive sum types
10:26:25 <Cale> texasmynsted: You also might find this extended cheat sheet of sorts useful: http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html
10:27:15 <Cale> At least, for some of the syntax :)
10:27:21 <texasmynsted> josephle, yes…  I am sure it will be simpler shortly
10:27:48 <texasmynsted> heh, starting at slide 36 http://scalacamp.pl/data/haskell-scala-handout.pdf
10:28:09 <texasmynsted> These look like they go to an interesting presentation.
10:28:22 <texasmynsted> I guess I have not learned yet how haskell is useless
10:28:23 <josephle> the good ol' SPJ graph
10:28:26 <Cale> Probably those diagrams should have Haskell 1.0 in the lower right corner
10:28:43 <Cale> The discussion which went with them made it clearer what he meant :)
10:28:53 <texasmynsted> It seems quite useful from what I can tell
10:29:06 <josephle> Cale: I keep hearing these horror stories about Haskell 1.0... are they really not exaggerated?
10:29:10 <Cale> texasmynsted: Yeah, it *started out* pretty useless though
10:29:31 <carter> horry stories?
10:29:44 <carter> 1.0 was pretty boring by modern standards :)
10:29:45 <Cale> josephle: Well, there was no IO monad
10:29:48 <carter> oh
10:29:49 <carter> yeah
10:29:57 <carter> all IO was written in CPS style
10:30:02 <Cale> right
10:30:04 <ajcoppa> yeah. if you watch the video where SPJ describes it, he's talking about where haskell started from (essentially as an experiment to see where the principles would lead)
10:30:18 <ajcoppa> the assertion isn't that haskell today is useless.
10:30:23 <texasmynsted> Found this.  Not a language I know though  http://vimeo.com/64117250
10:31:14 <Cale> type Dialogue = [Response] -> [Request]
10:31:25 <texasmynsted> well, yes without an IO monad, I do see how Haskell would be only an academic exercise
10:31:42 <Cale> data Request = ReadFile Name | WriteFile Name String | ...
10:32:08 <Cale> data Response = Success | Str String | Bn Bin | Failure IOError
10:32:27 <Cale> and you'd have main :: Dialogue
10:32:41 <Cale> and it would lazily consume this list of responses to the requests that it produced as its result
10:33:26 <mr-> And would happily give you a Str "yay" on a WriteFile... ? :-)
10:33:28 <Cale> Still, that's better I/O than what they had before that, which was basically your program took a String and produced a String
10:33:41 <Cale> mr-: It'd give you a Success
10:34:29 <Cale> Oh, and there were lots of helpers, like...
10:34:40 <xplat> basically haskell started out as 'let's make this really useless language by taking out all the features that cause problems and see how useful we can figure out how to make it without putting those features back in'
10:34:46 <Cale> readFile :: Name -> FailCont -> StrCont -> Dialogue
10:35:02 <texasmynsted> This looks interesting http://tech.kinja.com/haskell-for-scala-developers-1581854668
10:35:12 <xplat> and it turns out ... pretty useful
10:35:21 <Cale> Where  type FailCont = IOError -> Dialogue  and  type StrCont = String -> Dialogue
10:35:22 <ajcoppa> ^ what xplat said
10:36:17 <Cale> Yeah, it started out down in that useless but pure corner, and has been growing in usefulness since then
10:36:28 <josephle> Cale: that definitely seems a bit clunky to use
10:36:35 <josephle> the old CPS style
10:37:26 <Cale> Around 2005 or so, it hit a certain threshold when ByteString got implemented and suddenly lots of people could write libraries and programs which did things efficiently enough to be competitive.
10:37:30 <xplat> Monad would have made that pretty usable even without changing anything though, since you could wrap all the CPSing up with ContT
10:37:49 <Cale> xplat: yep :)
10:38:33 <Cale> and there are even places in GHC's code, I think they might even still be in there, where they used monads before the Monad class was around
10:38:51 <Cale> You'll see some `then` :)
10:39:35 <xplat> i guess they couldn't bring themselves to wait until constructor polymorphism worked to use some monads?
10:39:46 <josephle> is there a good reason why the IO monad is what it is today rather than a ContT like xplat suggested?
10:40:03 <Cale> josephle: The implementation of it is pretty arbitrary
10:40:08 <xplat> josephle: makes unsafePerformIO possible
10:40:18 <Cale> Yeah, there is that
10:40:28 <Cale> Though it's not like unsafePerformIO would be otherwise impossible
10:40:30 <Philonous> Was that due to some upsight into monads as a method for structuring programs or did it just "fall out" as the natural way to compose those things?
10:40:42 <Cale> Just, its implementation wouldn't be as simple, I suppose.
10:40:47 <xplat> Cale: yeah, but you'd basically have to start up a second runtime
10:41:08 <xplat> or at least a second copy of the runtime's event loop
10:41:15 <carter> well also it'd suck to compile :)
10:41:26 <carter> the IO monad evaporates at the CMM layer
10:41:27 <carter> :)
10:41:32 <xplat> also, as the words 'event loop' indicate, forkIO is a lot easier this way
10:41:46 <danharaj> edwardk: sorry that your talk got cancelled. maybe you should come give it in new york instead ;)
10:42:02 <edwardk> danharaj: hah
10:42:41 <xplat> Philonous: well, monads were already being used for academic work on semantics of effectful computation
10:42:56 <Cale> Philonous: Well, the first guy in the CS world to think about monads was Moggi. He used them to understand the semantics of programming languages. Then from what I understand, Wadler noticed that we might as well just use them directly in our implementations.
10:43:05 <xplat> Philonous: Eugenio Moggi was the originator
10:43:43 <xplat> edwardk: what, the lawn talk got cancelled?
10:44:00 <Philonous> Cale, That seems to be a recurring pattern "Hey, I have this nice abstraction for talking about computations" "Cool, let's implement it". And now we have Lisp. And Monads.
10:44:45 <Cale> Philonous: But even if it hadn't existed as a mathematical abstraction, we might've invented it for ourselves once type classes became available
10:44:46 <xplat> Philonous: every once in a while you see papers titled 'Foo as a Programming Language'
10:45:17 <Cale> After all, you'll find what is effectively the list monad discussed in SICP
10:45:25 <edwardk> xplat: Akamai screwed up reserving the space internally, so we just didn't have a place to meet tonight
10:45:40 <Cale> and there are a lot of libraries which follow this recurring pattern
10:45:54 <Cale> So it's an obvious sort of thing to eventually pick up on and abstract
10:45:55 <edwardk> xplat: on the plus side i get a reprieve and another month to prepare, on the downside it rather mucks with out talk schedule, and I'm not sure if we can get Cody next month or he'll be gone.
10:45:57 <blairio> Can someone help me understand how to deal with a little type signature problem?
10:46:14 <Philonous> Cale, Though my question was more about whether Moggi's work was the reason we began to see those abstraction used in early haskell, or if maybe they just coagulated naturally as a pattern that came up during programming and was later identified with the abstract concepts which is monads
10:46:40 <Cale> blairio: Yep!
10:46:47 <Cale> blairio: Well, probably :)
10:46:50 <blairio> http://lpaste.net/112636
10:47:08 <xplat> Cale: if you can't help, it's not little
10:47:23 <Cale> xplat: hah
10:47:47 <blairio> My code won't compile because I need to say that (Show a) works in getNode
10:47:48 <Cale> We could just take that to be the definition of "little" here
10:48:12 <xplat> Philonous: http://homepages.inf.ed.ac.uk/gdp/publications/LCF.pdf is probably the Ur Example
10:48:43 <blairio> But when I tried doing the stuff I've done in other situations it didn't seem to help
10:48:49 <Cale> blairio: Why is it that you're using show in getNode?
10:49:22 <Cale> I mean... you can do that, but then you'll need Show constraints elsewhere, and it looks like you could just as well get the value of the node
10:49:45 <Cale> i.e. have  getNode :: String -> BinaryTree a -> a
10:50:17 <blairio> I'm creating a list of strings like 0,1,001, etc, to create an ordered list of where all the nodes should be if I print htem in order
10:50:17 <Cale> (Probably Maybe a would be safer, your function will just crash if the "address" isn't valid)
10:51:12 <blairio> I'm just trying to replace the 011 string with the content of the node
10:52:27 <blairio> Ah, ok
10:52:29 <Cale> There are basically two options: Add "(Show a) =>" to the front of the type signature for getNodeLine, or have getNode/getNodeLine produce values of type a and [a] respectively
10:52:46 <Cale> (and don't use show)
10:54:40 <blairio> Ah, ok. So what I want to do is make something print a tree like the one at the bottom of the screen, which has all the node values in it. So I thought I'd do that by converting the nodes into strings, then concatenating spaces
10:56:26 <Cale> I think if I were to approach that, the first thing I'd worry about doing is writing a function which took two lists of lines of text, and worked out the appropriate amount of padding necessary to concatenate them horizontally.
10:57:07 <xplat> maybe this is best approached with the prettyprint combinators?
10:57:45 <Cale> That diagram is schematically: <left subtree with blank line at top> ||| <root node> ||| <right subtree with blank line at top>
10:58:01 <xplat> my approach for printing a tree that way would be: 1) write a tree printer that only works for BinaryTree String (probably using prettyprint combinators)
10:58:22 <xplat> 2) add 'deriving (Functor)' to BinaryTree
10:58:50 <Cale> and yeah, start with BinaryTree String, that's a good point, you can always write a function (or derive one as xplat points out) to apply a function such as show to all the values in a tree
11:00:06 <blairio> So, what I was trying to do was create that binaryString list, where every list inside of it is a level of the tree (in reverse order)
11:00:25 <blairio> Then from there I thought I'd replace the binary strings with nodes
11:01:01 <mmaruseacph2> flip table -- no Boston Haskell tonight :(
11:01:02 <blairio> But that was the only way I could think of to get all the nodes of one 'level' in the same list
11:02:51 <chasm_> ? question, what is best practice for: "cabal: The following packages are likely to be broken by the reinstalls:" - first uninstall those packages? blow everything away and start from scratch?
11:03:56 * hackagebot kdesrc-build-extra 0.1.0.0 - Build profiles for kdesrc-build  http://hackage.haskell.org/package/kdesrc-build-extra-0.1.0.0 (ivan)
11:04:09 <Cale> chasm_: You can just do it and ghc-pkg list to discover which packages are broken and then unregister and reinstall those. Occasionally this will get you into trouble, you might want to specify all the other packages on the same commandline to cabal install.
11:04:43 <mkscrg> hey all, has anyone run into ghc perf issues with large -j values (e.g. -j 32)?
11:05:18 <Cale> mkscrg: I haven't had the chance to really try it, but try one fewer than the number of processors you have.
11:05:21 <josephle> just to make sure, do you have >= 32 cores?
11:05:36 <mkscrg> Cale: similar perf with N-1
11:05:57 <chasm_> Cale_: so --force-reinstall and then cleanup after?
11:06:23 <Cale> chasm_: Yeah, but maybe pre-emptively tell cabal to reinstall the packages that it says it's going to break
11:06:36 <josephle> mkscrg: do you know roughly at what N does performance start degrading?
11:06:40 <Cale> chasm_: That's actually probably the best thing to do
11:07:18 <Cale> -j is quite new, it wouldn't surprise me if there were some performance bugs in it still
11:07:19 <carter> as  rule you should only set -j or -N to the number of physical cores
11:07:19 <chasm_> Cale_: ah ok thx
11:07:23 <carter> no more
11:07:31 <mkscrg> josephie: roughly 4
11:07:38 <xplat> mkscrg: a likely problem is that you don't have enough RAM to run a GHC for each of your cores
11:08:14 <xplat> at least on the sort of things you're compiling
11:08:33 <mkscrg> josephle: i'm in a hosted CI environment, suspicious that the cpu may be cgroup-limited below what numCapabilities returns
11:08:39 <xplat> mkscrg: are you getting a lot more disk access when you go from 3 to 4?
11:08:52 <xplat> oh, hosted, you can't tell
11:09:00 <mkscrg> xplat: yup :(
11:09:04 <xplat> that makes the RAM problem even more likely though
11:09:48 <mkscrg> definitely
11:10:03 <xplat> VMs are a big candidate for having a puny amount of RAM
11:11:03 <xplat> my only real suggestion is to stick to fewer jobs
11:11:08 <buttons840> is there a scanl' like there is a foldl' ?
11:11:20 <carter> :t scanl'
11:11:21 <lambdabot>     Not in scope: ‘scanl'’
11:11:21 <lambdabot>     Perhaps you meant one of these:
11:11:21 <lambdabot>       ‘scanl’ (imported from Data.List),
11:12:24 <xplat> scanl' is a lot less useful than foldl'
11:13:15 <xplat> :t F.scanl'
11:13:16 <lambdabot> Not in scope: ‘F.scanl'’
11:13:47 <buttons840> ok, here I was thinking you could speed up any haskell code just by putting ' at the end of the function names ;)
11:14:31 <MitchellSalad> ...lol
11:14:37 <carter> buttons840: not true :)
11:14:39 <Cale> Because of the way it inverts things, scanl is useful in similar cases that foldr is.
11:14:45 <Cale> Oddly enough :)
11:14:48 <carter> inner loops are nice to have strict
11:14:53 <xplat> if you really want to make scanl' as strict as possible you should just run some random foldl' on the resulting list before using it
11:14:53 <carter> but things in the large its nice to be lazy
11:15:07 <DarkCthulhu> (λx.y)(λy.y) has the first y as a free variable and λx.(λy.x y)y has the last y as a free variable. Am I right in my evaluation?
11:15:08 <Cale> At least, so long as you're evaluating the elements of the list in order.
11:15:23 <merijn> DarkCthulhu: Correct
11:15:25 <Cale> DarkCthulhu: yes
11:15:37 <DarkCthulhu> ty :)
11:16:06 <nh2> is --- an operator or a comment
11:16:09 <xplat> like 'let xs = scanl' … in foldl' const () xs `seq` <use xs here>'
11:16:13 <jgallag8> Does anybody know anything about performance of HashMaps vs IntMaps vs EnumMaps?
11:16:29 <xplat> > scanl f [x,y,z]
11:16:31 <lambdabot>  Ambiguous occurrence ‘x’
11:16:31 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:186:1
11:16:31 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
11:16:31 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
11:16:31 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
11:16:39 <jgallag8> I am using hashMaps for a project right now, and considering switching to intMaps
11:16:44 <xplat> > scanl f [w,y,z]
11:16:46 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr
11:16:46 <lambdabot>                      [Debug.SimpleReflect.Expr.Expr])
11:16:46 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
11:16:46 <lambdabot>  from the context (GHC.Show.Show a)
11:16:46 <lambdabot>    bound by the inferred type of
11:17:01 <pjdelport> nh2: Comment (as far as i know)
11:17:10 <xplat> > scanl f a [w,y,z] :: Expr
11:17:11 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
11:17:11 <lambdabot>              with actual type ‘[Debug.SimpleReflect.Expr.Expr]’
11:17:18 <Cale> nh2: Comments start with any number of hyphens followed by a non-symbol character
11:17:25 <xplat> > scanl f a [w,y,z] :: [Expr] -- geez, sorry
11:17:26 <lambdabot>  [a,f a w,f (f a w) y,f (f (f a w) y) z]
11:17:32 <Cale> er, at least 2 though ;)
11:18:02 <nh2> jgallag8: I don't know the anser, but try make a small criterion benchmark
11:18:55 <xplat> scanl produces these with sharing between each term and its occurrence in the next term
11:19:22 <jgallag8> It's a little tricky b/c there are a lot of variables at play.
11:19:35 <nh2> pjdelport, Cale: ah, I overread the "any number of hyphens" part in the grammar. Thanks!
11:19:38 <xplat> so if you consume them in order, each term will only do one 'level' of computation when you force it
11:19:38 <shapr> Has anyone recently used Atom or Copilot with an Arduino?
11:20:06 <Cale> nh2: So, you're allowed to have --> as an infix operator
11:20:07 <jgallag8> Not just the different maps, but also how you map the keys you want to the keys stored in the map
11:20:42 <xplat> but --------------------------aaaaay is a comment
11:21:45 <jgallag8> HashMap does this by deriving Hashable, and I am not sure how/how well derived hashable instances work relative to intances provided by hashable
11:23:38 <xplat> jgallag8: there's a compiler option you can use to see code generated by deriving
11:23:47 <nh2> jgallag8: I thought you were only comparing the integer bit; if you count the hash function in, then of course the answer depends mostly of the hash function
11:23:56 * hackagebot kdesrc-build-extra 0.1.0.1 - Build profiles for kdesrc-build  http://hackage.haskell.org/package/kdesrc-build-extra-0.1.0.1 (ivan)
11:24:24 <nh2> in terms of the integer bit: https://github.com/tibbe/unordered-containers/blob/master/Data/HashMap/Strict.hs#L20 (hash array mapped tries) vs http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-IntMap.html (big-endian patricia trees)
11:25:12 <nh2> jgallag8: in any case, if you want a qualified response as opposed to quoting, ask Johan Tibell
11:25:27 <jgallag8> Hm... Maybe I should start by looking into the hashable instances that are derived
11:26:03 <jgallag8> Does he hang around here?
11:29:19 * dmj` thinks 100% haddock coverage is easier said than done
11:31:43 <nh2> jgallag8: usually yes, but he's in european time
11:32:55 <monochrom> --| is a legal user-defined operator, -- | is haddock comment :)
11:38:46 <dmj`> monochrom: that's tricky
11:39:07 <Redz> how does a elegant gui library look like?
11:48:53 <alenn> Can someone explain me why the second doesn't compile? https://gist.github.com/anonymous/28bd55cda483a90f0714
11:49:24 <Sorella> Redz, Elm, perhaps?
11:50:17 <cmtptr> alenn, because haskell has dumb rules about whitespace.  the (l:_) needs to line up with the (f:_), assuming 8-space tabs
11:50:19 <felixn> alenn: it helps to include the compilation error
11:50:50 <felixn> alenn: I've got burned by whitespacing like that before >_<  sometimes ghc doesn't make it obvious
11:51:07 <cmtptr> alenn, either don't use tabs or start your identifiers after a "where" or "let" on a new line, and definitely never mix tabs and spaces
11:51:09 <alenn> baby.hs:80:34: parse error on input `='
11:51:28 <alenn> ok
11:51:39 <felixn> how do people feel about Rust's syntax?  I kind of like that it's C like, how to whitespace is much more obvious to me
11:52:32 <benzrf> felixn: the indentation rules in haskell make perfect sense when you consider ambiguity
11:52:42 <benzrf> i.e. in haskell you can indent further on the next line to continue an expression
11:52:45 <benzrf> like
11:52:46 <benzrf> f = f 1
11:52:48 <benzrf>     2
11:52:53 <cschneid> does anybody have an example of using cassandra-cql with scotty?  I'm not sure how the two monads are supposed to fit together
11:52:56 <benzrf> er, the 2 should be further over. but u get it
11:53:07 <benzrf> so it has to be at the *same* instead of further so you can tell it's a new decl
11:53:24 <felixn> benzrf: aye it make sense when thinking like that, I don't really remember how I got burned by `case`
11:53:59 <felixn> not sure if "f 1 2" > "f(1, 2)" ... my intention to pass 1 and 2 where not ambiguous when I wrote it
11:54:23 <felixn> I feel like it's a loss of meaning when transcribing my computation
11:54:58 <felixn> I've actually been thinking about that a bit lately, anyone have any thoughts on that?
11:55:53 <cmtptr> don't you lose the ability to partially-apply f with the second case?
11:56:00 <felixn> a b c, could mean a(b, c) or a(b(c)) ... feels very lossy
11:56:38 <int-e> but it means ((a b) c) by convention
11:56:48 <felixn> cmtptr: yea, but I'm not quite sure that's a bad thing ... though I guess you partially apply like "f(1)(2)"
11:58:10 <felixn> int-e: but the reality is different depending on the definition of those variables
11:58:48 <Ralith> no, that's how it's defined
11:59:11 <int-e> felixn: can you give an example?
12:00:18 <felixn> are there any good online haskell editors?
12:00:51 <int-e> @lpaste editors, no, but there's lpaste for putting up haskell code
12:00:51 <lambdabot> Haskell pastebin: http://lpaste.net/
12:01:15 <pantsman-> there's FP Complete's Haskell Centre
12:01:26 <felixn> lol the top result on google is broken for online editors
12:02:39 <johnw> i think that's the first time I've seen the Haskell Center mentioned in 6 months
12:02:56 <sivteck> felixn, https://www.youtube.com/watch?v=qDgz63n_4t4
12:04:16 <pantsman-> johnw, Aaron Contorer gave a talk at the London Haskell User Group, which raised some awareness
12:04:37 <adimit> erm. long shot: anybody know how to start investigating what's wrong when Emacs with ghc-mod doesn't do the flymake highlighting anymore (at all) but everything else works (and nothing changed?) … I'm stumped. I can supply relevant information, and I guess I probably won't find anybody here who can help me… but I'll try!
12:04:48 <felixn> int-e: cmtptr: this is what I mean by ambiguity https://gist.github.com/munro/7a57a36cbf6eeac3a1a4
12:05:31 <felixn> I think it would strengthen type checking if you could explicitly state the flow of computation
12:05:59 <int-e> felixn: there is not ambiguity. in example2, the 'str' argument of 'a' has type String -> String.
12:06:07 <johnw> pantsman: ahh
12:06:18 <int-e> felixn: but it's still (a b) c
12:06:52 <pantsman-> johnw, also, recently, I had to write some code at short notice (it was for an interview), but all I had was my Chromebook... I was glad then that Haskell Center existed
12:06:59 <felixn> int-e: that's true, maybe I should try more contrived examples
12:07:11 <felixn> ^_^
12:07:34 <pantsman-> it still has some issues to iron out, I think
12:07:45 <pantsman-> it was frustrating trying to actually write real code and run tests
12:08:07 <felixn> sivteck: lol trippy presentation
12:08:41 <sivteck> ;)
12:09:18 <int-e> felixn: What I said isn't quite true, btw. 'a' is polymorphic of type t -> t for any type. When used in (a b) c, the 't' is instantiated by the type of 'b', which is 'String -> String'
12:09:54 <int-e> felixn: but you can safely ignore what I just said if you don't understand it yet.
12:11:41 <chasm_> is there some problem with the current version of haddock 2.15.0?
12:11:48 <felixn> sivteck: fpcomplete works pretty well, just not sure how to share a public link
12:12:19 <sivteck> i think you can just copy the url from browser
12:12:22 <sivteck> and share
12:12:33 <chasm_> cabal install haddock => Installed haddock-2.15.0 \n cabal: InstallPlan: internal error: configured package depends on a non-library package
12:12:38 <sivteck> not sure though ;/
12:13:06 <felixn> sivteck: https://www.fpcomplete.com/user/munro/ambiguity boom .. it clones the project though which is kind of weird
12:15:38 <a-b-c> hi. I was wondering if there is a shorter way to access multiple parameters as list than  foo a b c = [a,b,c]
12:16:42 <felixn> int-e: I'm really just thinking in the abstract, `(a b) c` still works because of partials, but `a (b c)` doesn't in both cases
12:16:46 <pjdelport> a-b-c: Generally speaking, you'll have to write functions like that for each arity.
12:19:26 <a-b-c> ok. so there is no shorter expression for above code?
12:25:50 <Thooms> isn't there something to do with (->) and a bit of type-level programming ?
12:26:42 <Thooms> (my intuition tells me that you can just sort of pattern-match on the type, and apply (:) until the type is not functional anymore)
12:26:46 <felixn> int-e: air tight counter example https://gist.github.com/munro/7a57a36cbf6eeac3a1a4
12:26:46 <benzrf> Thooms: that's pretty ambiguous here
12:26:59 <benzrf> wait nvm
12:27:19 <benzrf> Thooms: yes you can recurse on types or something
12:27:38 <benzrf> @let data Nat = Z | S Nat;
12:27:41 <lambdabot>  Defined.
12:27:57 <benzrf> @let type family Arity t :: *;
12:28:00 <lambdabot>  Defined.
12:28:17 <benzrf> @let type instance Arity (a -> b) = S (Arity b)
12:28:18 <lambdabot>  .L.hs:205:35:
12:28:18 <lambdabot>      The first argument of ‘S’ should have kind ‘Nat’,
12:28:18 <lambdabot>        but ‘Arity b’ has kind ‘*’
12:28:18 <lambdabot>      In the type ‘S (Arity b)’
12:28:18 <lambdabot>      In the type instance declaration for ‘Arity’
12:28:22 <benzrf> o h wait
12:28:23 <benzrf> !undef
12:28:29 <benzrf> @undef
12:28:29 <lambdabot> Undefined.
12:28:46 <felixn> someone should make lambdabot a bit more polite
12:28:58 <benzrf> @let data Nat = Z | S Nat; type family Arity a :: Nat where {Arity (a -> b) = S (Arity b); Arity t = Z;}
12:28:58 <lambdabot>  Parse failed: Parse error: where
12:29:04 <benzrf> oh is that not on :|
12:29:16 <benzrf> @let data Nat = Z | S Nat; type family Arity a :: Nat; type instance Arity (a -> b) = S (Arity b); type instance Arity t = Z;
12:29:17 <lambdabot>  .L.hs:158:15:
12:29:17 <lambdabot>      Conflicting family instance declarations:
12:29:17 <lambdabot>        Arity (a -> b) -- Defined at .L.hs:158:15
12:29:17 <lambdabot>        Arity t -- Defined at .L.hs:160:15
12:29:20 <benzrf> aw.
12:29:34 <benzrf> well, i think you can do it if you have that one type family bit with the where
12:29:34 <Thooms> :D
12:29:44 <Thooms> I see
12:31:58 <benzrf> :k Nat
12:31:59 <lambdabot> Not in scope: type constructor or class ‘Nat’
12:32:01 <Thooms> type level programming is still fuzzy to me, but I'll try something later (it might take some very long time to work :°)
12:33:01 <Thooms> thanks benzrf :)
12:33:19 <benzrf> np
12:33:29 <benzrf> @let data Nat = Z | S Nat; type family Arity a :: Nat where Arity (a -> b) = S (Arity b); Arity t = Z;
12:33:29 <lambdabot>  Parse failed: Parse error: where
12:33:32 <benzrf> huh
12:33:40 <zq> how to make haddock stuffs appear on hackage
12:33:42 <zq> ?
12:33:44 <benzrf> @let data Nat = Z | S Nat; type family Arity a where Arity (a -> b) = S (Arity b); Arity t = Z;
12:33:44 <lambdabot>  Parse failed: Parse error: where
12:33:50 <benzrf> what extn is that?
12:34:25 <monochrom> I have never heard of type family with "where"
12:34:44 <geekosaur> I thought that was closed vs. open?
12:34:49 <benzrf> http://www.haskell.org/haskellwiki/GHC/Type_families ctrl+f "closed type family"
12:34:52 <benzrf> geekosaur: yeah
12:34:55 <benzrf> is there a separate extn for closed ones?
12:35:01 <monochrom> if you say, it's new in GHC 7.10, then lambdabot is not on 7.10
12:35:28 <geekosaur> I thought cloeed type families were 7.6ish
12:35:34 <int-e> lambdabot is on ghc 7.8.3
12:35:44 <luite> yeah they're in 7.6
12:35:47 <benzrf> i'm doing that exact decl and it's working fine
12:35:48 <benzrf> on my end
12:36:36 <int-e> oh sorry. 7.8.2 still.
12:37:10 <benzrf> i have .3
12:37:20 <benzrf> but
12:37:27 <benzrf> im pretty sure closed type fams arent new in .3
12:37:34 <benzrf> what gives??
12:37:50 <benzrf> oh maybe language-ext-haskell cant parse them x.x
12:38:04 <int-e> haskell-src-exts right.
12:38:11 <benzrf> er
12:38:12 <benzrf> yeah
12:38:43 <benzrf> the module is Language.Haskell.Extension an i got confused
12:39:04 <int-e> which is at version 1.15.0.1 on lambdabot's host
12:39:31 <zq> meh
12:39:56 <benzrf> wait, wth?
12:40:04 <benzrf> haddock says: Language.Haskell.Exts
12:40:08 <benzrf> but i dont have that after nix-enving
12:40:30 <benzrf> just Language.Haskell.Extension
12:41:23 <int-e> benzrf: perhaps the package is hidden?
12:41:30 <benzrf> i dunno why it would be?
12:41:38 <benzrf> <no location info>: Could not find module ‘Language.Haskell.Exts’
12:41:41 <int-e> (or nonexistant. ghc-pkg should tell you either way)
12:41:51 <merijn> benzrf: No, closed type families are enabled together with TypeFamilies
12:41:51 <benzrf> benzrf@benzrf-laptop:~$ nix-env -iA nixpkgs.haskellPackages.haskellSrcExts
12:41:51 <benzrf> replacing old `haskell-haskell-src-exts-ghc7.8.3-1.15.0.1-shared'
12:41:51 <benzrf> installing `haskell-haskell-src-exts-ghc7.8.3-1.15.0.1-shared'
12:42:41 <int-e> perhaps the package was broken ;) (smiley because nix is supposed to prevent that)
12:42:45 <deni> in a library I'm building ... if have a DSL (using free monads) and I write my functions using that DSL. Do i use the interpreter in those functions to return effects...or is it considered ok to let the users of the library call "run myFunction" instead of just myFunction. Sorry if the answer seems obvious
12:42:49 <benzrf> hmmm yes ghc-pkg does not know about this package
12:42:53 <benzrf> wot the hell
12:43:28 <deni> it makes sense to use "run myFunction" because then i can write a different interpreter for tetsing for instance.
12:43:33 <deni> does that make sense?
12:44:50 <int-e> deni: letting the user invoke some 'run' method in the end seems standard
12:45:30 <monochrom> if and only if you want to expose the DSL to users, you provide your run so users can use it.
12:46:14 <deni> monochrom: if I don't wan't to expose the DSL you're saying I should call the run command inside myFunction?
12:46:26 <int-e> makes sense
12:47:01 <monochrom> yes. imagine this: you export two things "x" and "y", and the only way, ever, to use them is "x y". then why would you do that? why not export just one thing?
12:47:07 <deni> monochrom: how does that work for testing then? ie. how can i provide a different interpreter? other than passsing the interpreter in as an argument...but that's a messy API then
12:47:21 <int-e> (ST comes with runST but if I implement Dijkstra's algorithm in ST, I would probably wouldn't export the guts, just some pure function doing the job)
12:48:33 <monochrom> who will do testing? users?
12:48:52 <int-e> deni: provide testing versions of your functions, or add an 'Internal' module that does expose the DSL
12:49:00 <deni> monochrom: no, me. tests for the library i mean
12:49:13 <monochrom> then you expose the details to yourself, not to the users.
12:50:36 <deni> monochrom: int-e i'm not sure i follow. the question isn't how to expose or not expose stuff..the question is how to design the functions so that they are in the end testable with a "test interpreter"
12:50:38 <monochrom> API design is like fashion design.
12:51:10 <monochrom> the tester will need to access the DSL and various runners
12:51:48 <deni> monochrom: let's simplify. I have a function doGetRequest dsl = run dsl
12:51:52 <int-e> deni: I would fix an official API and as you describe it, that should not expose the DSL. If testing benefits from exposing the DSL, I'd expose it in a way that discourages users of my library from using it anyway.
12:52:08 <deni> monochrom: the tester is me ... ie. the one writing the lib
12:52:10 <int-e> And "Internal" modules seem to be the convention there.
12:52:27 <monochrom> the tester will need to access the DSL and various runners. it is correct to export the DSL and various runners to the tester so the tester can play with various combinations.
12:52:27 <deni> monochrom: the question is what's better then doGetRequest interpreter dsl = interpreter dsl
12:52:32 <deni> i'm simplifying obviously
12:52:40 <deni> but that's the gist of it
12:52:52 <monochrom> the user only needs one combination. it is correct to export only one name to the user
12:54:15 <deni> monochrom: okay then what about doGetRequest dsl = someFunc . someFunc2 . run dsl
12:54:23 <int-e> (I'm only suggesting the "Internal" module because I envision that the testsuite itself is just another user of the library, and the package infrastructure doesn't support exporting a module to specific users only)
12:54:51 <monochrom> why are there 3 different things called doGetRequest?
12:55:02 <deni> monochrom: there aren't
12:55:13 <deni> monochrom: i'm just giving you a different example
12:56:04 <deni> cause i'm not sure if you don't see what my problem is or I'm not understanding your solution
12:56:11 <deni> or both
12:56:28 <monochrom> is this true? you are planning one single module, one single export list, that both users and testers stick to?
12:56:49 <deni> no
12:57:22 <monochrom> ok, then the module for users can export much less than the module for testers.
12:57:24 <deni> i have many modules. and currently i export everything
12:58:13 <monochrom> the module for users can also export only pre-made combinations.
12:58:17 <deni> monochrom: agreed. i can have a module for testing that exports more
13:00:10 <monochrom> suppose there are three things internally, "f", "g", and "x". the user will only ever use "f x". the tester needs to test "f x", "g x", and other things not already written.
13:00:45 <monochrom> then you define "y = f x" and export "y" to the user. you export "f", "g", and "x" to the tester.
13:03:15 <deaddork> Hi there! I just started working through Typeclassopedia, and I’m a bit stuck on 3.2 #4; namely, “Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).” I Googled this, and *everybody* uses ```data NotFunctor a = NotFunctor (a -> Int)”. I understand why that can’t be an instance of Functor, but I’m having a hard time coming up with my own example—which makes me suspect that I don’t
13:03:15 <deaddork> really understand the Functor class, despite being able to follow all of Yorgey’s examples. I’d really appreciate it if someone could help me get a better understanding here. Thanks!
13:05:20 <johnw> deaddork: so, a Functor allows mapping over any type in a data structure, so long as that type occurs "positively" in every occurrence, and so long as no effects are necessary to achieve that mapping
13:05:26 <aaronlevin> is anyone else encountering all kinds of hell with ghcmod-vim and ghc-mod 5.1.1.2? Not really sure if it's the fact I'm using Nix or not.
13:05:33 <johnw> the Functor type class chooses the last type variable as the type that will be mapped over
13:05:42 <aaronlevin> *5.1.1.0 rather
13:06:04 <johnw> deaddork: so far example, an "IORef a" looks like it could be a Functor, since it has kind * -> *, but it can't be, because mapping the type requires the IO monad to happen
13:06:51 <merijn> johnw: The mapping can't happen because it'd change the underlying cell, which is shared (potentially) by multiple IORef values
13:07:11 <johnw> merijn: I mean that you can't write fmap without unsafePerformIO
13:07:39 <johnw> the type does not allow an IO action otherwise
13:09:04 <johnw> another scenario is where a constraint would be required on the type variable
13:09:19 <johnw> a "Data.Set a" also cannot be a Functor, although it has type * -> *
13:09:25 <johnw> because it requires that a support Ord
13:09:52 <mauke> hmm, I don't think that's true
13:09:55 <johnw> oh?
13:10:03 <johnw> or is it just the laws that are violated, and not the types?
13:10:07 <mauke> yes
13:10:11 <johnw> ok, thanks mauke
13:10:19 <mauke> just return S.empty, basically :-)
13:10:21 <merijn> johnw: You can't write fmap for IORef even *with* unsafePerformIO
13:10:55 <johnw> you mean, not in a law-abiding way?
13:11:04 <mauke> fmap f ref = unsafePerformIO $ do { x <- readIORef ref; newIORef (f x) }
13:11:28 <merijn> johnw: I mean "what you end up with doesn't remotely resemble fmap"
13:11:44 <johnw> what about mauke's example?
13:11:52 <deaddork> I can come up with examples that violate the functor laws, but that feels like cheating.
13:11:59 <merijn> Doesn't look like fmap like behaviour to me :)
13:12:12 <johnw> merijn: how not?
13:12:30 <merijn> deaddork: If you can think of 2 or 3 things that violate the law I'd consider it "understood"
13:12:34 <johnw> it generates a new IORef with the type mapping at each position of occurrence; it just requires unsafety
13:12:41 <deni> monochrom: i'll give it a shot. tnx for your help
13:13:01 <merijn> johnw: Doesn't follow the laws, and "future" updates to the IORef disappear
13:13:43 <johnw> so, it just doesn't preserve mutability
13:13:52 <merijn> deaddork: Hell, if you understand enough to know why 1 or 2 examples violate functor laws and how you'd go about proving that, you're doing far better than you seem to think in terms of understanding :)
13:14:02 * hackagebot twentefp-graphs 0.1.0.2 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-graphs-0.1.0.2 (sebaslafleur)
13:14:06 <johnw> but if we view it as a persistent container, I believe it follows the laws also
13:17:16 <blairio> Quick question, how do I add -XInstanceSigs if my compiler complains?
13:17:33 <blairio> (I've never added a setting before)
13:17:44 <johnw> you can put in your Haskell file: {-# LANGUAGE InstanceSigs #-}
13:17:44 <mauke> {-# LANGUAGE InstanceSigs #-} at the top of the file
13:17:55 <johnw> i knew someone else was typing that while I was :)
13:19:02 * hackagebot twentefp-graphs 0.1.0.3 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-graphs-0.1.0.3 (sebaslafleur)
13:19:04 * hackagebot hackertyper 0.1.0.0 - "Hack" like a programmer in movies and games!  http://hackage.haskell.org/package/hackertyper-0.1.0.0 (fgaz)
13:19:33 <deaddork> merijn: That’s good to know! I’m pretty comfortable with instances of Functor in other people’s code, but got a little worried when I couldn’t come up with a better example than ```data NF a = NF (a -> Int)```
13:22:14 <merijn> deaddork: tbh, there's just not that many things that are 1) sensible 2) not contravariant and 3) can't be functor
13:22:39 <deaddork> Whew!
13:22:47 <deaddork> I thought I was blind or something
13:23:40 <luite> somehwat disappointing that the hackertyper code you type is C and not Haskell :)
13:25:16 <deaddork> merijn & johnw: thanks! I feel better about this. I really thought that I was missing something important. I’m glad I’m not.
13:26:26 <merijn> deaddork: Next up, implement Functor for "newtype Const a b = Const a" and prove why it can only be Applicative with a Monoid constraint on a :)
13:26:55 <johnw> for bonus points: identify which of the monad laws it fails to fulfill, since it fulfills all the rest of them
13:27:49 <deaddork> Oh boy
13:32:38 <yukko> why does let have different scoping than where?
13:33:29 <edwardk> yukko: because let is an expression and where is part of the statement
13:33:39 <edwardk> and it is useful to be able to do both things
13:33:56 <edwardk> lets are useful because you do occasionally need to bind names locally in lambdas, etc
13:34:03 * hackagebot hackertyper 0.1.0.1 - "Hack" like a programmer in movies and games!  http://hackage.haskell.org/package/hackertyper-0.1.0.1 (fgaz)
13:34:09 <edwardk> wheres are useful because you do occasionally want to make multiple definitions that scope over all guards
13:34:39 <yukko> ohh I see!
13:36:02 <carter> yeah, i always mix up how where scoping works
13:36:08 <edwardk> haskell has a tendency when there are multiple reasonable alternatives like that that can both desugar sensibly to a simple core to just do both things
13:36:26 <edwardk> we're okay with not saying 'there is only one way to do it' when there are two viable ways ;)
13:36:42 <edwardk> and where neither strictly dominates the other
13:36:48 <edwardk> witness type families vs. functional dependencies
13:36:55 <carter> yeah
13:36:59 <benzrf> witness
13:37:05 <benzrf> what do people mean by a 'witness' anyway :-\
13:37:09 <carter> edwardk: i've some code that uses both!
13:37:47 <carter> i tend to use fundeps for things where I want people to always name them
13:37:49 <mitchty> benzrf: observe basically
13:38:06 <DarkCthulhu> Why is (λf : bool → bool.f x) true meaningless in simply typed lambda calculus?
13:39:11 <DarkCthulhu> I'd interpret that as a function f which takes a boolean argument and returns a boolean. When given an argument true, isn't it correct?
13:39:12 <merijn> DarkCthulhu: You're applying a function expecting "bool -> bool" to "true", which can't be right
13:39:25 <benzrf> mitchty: let me find an example...
13:39:30 <mjboa> i often see the word witness in connection with functional dependencies
13:39:32 <xplat> johnw: you don't have fmap id = id with mauke's fmap
13:39:47 <DarkCthulhu> merijn: Ohhh.. yeah. My mistake, I was binding the x to it rather than the f.
13:39:52 <DarkCthulhu> ty merijn
13:39:58 <benzrf> mitchty: from a coq tutorial:
13:40:01 <benzrf> > and the notation (exists x:D, P x) is just concrete syntax for (ex D (fun x:D => P x)). Existential quantification is handled in Coq	in a similar fashion to the connectives /\ and \/ : it is introduced by the proof combinator ex_intro, which is invoked by the specific tactic Exists, and its elimination provides a witness a:D to P, together with an assumption h:(P a) that indeed a verifies P.
13:40:02 <lambdabot>  <hint>:1:79: parse error on input ‘=>’
13:40:05 <benzrf> Let us see how this works on this simple example.
13:40:07 <benzrf> a witness?!
13:40:17 <vanila> (\f -> f x) true  ==> true x
13:41:14 <mitchty> benzrf: as a noun it could also mean evidence or proof or confirmation of a statement
13:42:12 <vanila> nothing is "meaningless" in untyped lambda calculus: Every syntactically valid expression is a lambda term
13:42:44 <tnks> I'm trying to figure out protobuf for haskell.
13:42:45 <RedNifre_> Is there a type without a value, like void?
13:43:04 <mauke> RedNifre_: does undefined count as a value?
13:43:13 <xplat> benzrf: interestingly in agda you prove that something didn't happen by eliminating all possible witnesses
13:43:17 <arianvp> data Void;
13:43:27 <RedNifre_> maybe. Can you do instance Bla String undefined where?
13:43:37 <mauke> what
13:43:39 <RedNifre_> > data Void = undefined
13:43:41 <lambdabot>  <hint>:1:1: parse error on input ‘data’
13:43:42 <tnks> my sandbox installation of hprotoc isn't working because protocol-buffers-2.0.12 won't compile
13:43:44 <mauke> WHAT
13:43:52 <tnks> the log says 'typeOf' not in scope.
13:43:54 <xplat> RedNifre_: srsly, wat
13:44:25 <RedNifre_> wait a sec, have to do something else. I'll be back in maybe 10 minutes. What I'm asking for is something like Void in Java.
13:44:35 <tnks> so I'm wondering if maybe Prelude was importing typeOf or something?
13:44:36 <RedNifre_> For example, the only instance of [Void] would be []
13:44:45 <RedNifre_> Since you can't construct a Void.
13:44:46 <pjdelport> RedNifre_: arianvp's answer: data Void
13:44:47 <byorgey> RedNifre_: you can define Void.  Unfortunately, undefined is a value of every type
13:44:49 <arianvp> RedNFifre_. yes; you can define data Void;
13:44:53 <arianvp> with XEmptyDataDecls
13:45:01 <byorgey> RedNifre_: but if you ignore undefined, then yes
13:45:05 <RedNifre_> Ah, yes. Perfect :)
13:45:21 <mauke> newtype Void = V Void  -- no extensions
13:45:30 <xplat> Void has no defined values, and [Void] has only [] as a fully-defined value
13:45:50 <RedNifre_> What is V Void?
13:46:54 <benzrf> @let newtype Void = V Void
13:46:57 <lambdabot>  Defined.
13:47:01 <xplat> RedNifre_: V is a constructor of type Void, but you would already need to have a Void to give it, and it's strict, so undefined is still the only value
13:47:07 <benzrf> > case fix V of V _ -> "OK!"
13:47:09 <lambdabot>  "OK!"
13:47:13 <Philonous> RedNifre_, V is the Constructor and Void is the type you're defining.
13:47:41 <ReinH> benzrf: touché ;)
13:47:46 <mauke> > undefined :: Void
13:47:47 <lambdabot>  V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V...
13:47:51 <xplat> > case undefined of V _ -> "OK!"
13:47:52 <lambdabot>  "OK!"
13:47:59 <benzrf> mauke: whoa, whaa
13:48:03 <benzrf> ahahaha that's hilarious
13:48:25 <benzrf> wait
13:48:33 <benzrf> where'd Show come from
13:48:36 <benzrf> @undef
13:48:36 <lambdabot> Undefined.
13:48:38 <mauke> ~magic~
13:48:43 <benzrf> u cheated
13:48:50 <benzrf> @let newtype Void = V Void deriving Show
13:48:52 <lambdabot>  Defined.
13:48:54 <benzrf> > undefined :: Void
13:48:55 <lambdabot>  V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V...
13:48:55 <xplat> standalone deriving?
13:49:00 <benzrf> oh
13:49:00 <mauke> yep
13:49:15 <benzrf> now that is a fun trick
13:49:16 <benzrf> bwahaha
13:49:42 <xplat> fix V, fix id, V (fix id), etc are all the same thing
13:49:53 <benzrf> damn
13:49:56 <benzrf> :t fix id
13:49:57 <lambdabot> a
13:49:58 <pjdelport> @let newtype Snake = Badger Snake deriving Show
13:49:59 <benzrf> ah yes
13:50:00 <lambdabot>  Defined.
13:50:04 <pjdelport> > fix Badger
13:50:05 <lambdabot>  Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badg...
13:50:21 <xplat> > fix id :: Snake -- !!
13:50:22 <lambdabot>  Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badg...
13:50:32 <MP2E> SNAKE!! SNAKE!! OHHH IT'S A SNAKE!
13:50:35 <MP2E> :>
13:51:50 <xplat> > error "seriously man, it's a snake!!" :: Snake
13:51:53 <lambdabot>  Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badger (Badg...
13:52:18 <mauke> > fix show
13:52:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:53:12 <xplat> > fix read
13:53:16 <lambdabot>  mueval-core: Time limit exceeded
13:53:49 <mauke> > fix fail
13:53:51 <lambdabot>  ""
13:54:04 * hackagebot HandsomeSoup 0.3.3 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3.3 (AdityaBhargava)
13:54:06 <xplat> > fix error
13:54:07 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:54:21 <joelteon> cat lambdabot-history.txt | grep fix error | wc -l
13:54:21 <Hostbtc> Get now your hosting product, hostbtc.nl , get 25% $ (afftilate) by ref your friends.
13:54:22 <Hostbtc> Get now your hosting product, hostbtc.nl , get 25% $ (afftilate) by ref your friends.
13:54:41 --- mode: ChanServ set +o mauke
13:55:39 <xplat> > fix (error.show)
13:55:41 <lambdabot>  *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exc...
13:56:41 --- mode: mauke set -o mauke
13:56:42 <xplat> > fix (show.error)
13:56:44 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:59:04 * hackagebot haskellscrabble 0.1.0.1 - A scrabble library capturing the core game logic of scrabble.  http://hackage.haskell.org/package/haskellscrabble-0.1.0.1 (happy0)
14:21:32 <pharpend> what does the abbreviation "sec" stand for with cmdtheline?
14:21:41 <pharpend> it seems like it should be obvious - http://hackage.haskell.org/package/cmdtheline-0.2.3/docs/System-Console-CmdTheLine-Arg.html
14:21:45 <pharpend> maybe "section
14:21:46 <pharpend> "
14:23:30 <geekosaur> looks like manpage section, yes
14:45:40 <johnw> ReinH: ping
14:46:32 <ReinH> johnw: hi
14:57:32 <RedNifre> Oh my god, just read the history. What did you do to poor lamdabot?
14:58:41 <RedNifre> @t fix
14:58:41 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:59:07 <RedNifre> > fix
14:59:08 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:59:09 <lambdabot>    arising from a use of ‘M77287182429581509791190.show_M77287182429581509791...
14:59:10 <lambdabot>  The type variable ‘a0’ is ambiguous
14:59:12 <lambdabot>  Note: there are several potential instances:
14:59:14 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:02:44 <RedNifre> Just noticed that Void is actually the example given on the Empty Type wiki page.
15:03:07 <RedNifre> Are there any other uses of empty types than Void?
15:03:35 <joelteon> don't really understand the question
15:03:37 <johnw> all empty types are equivalent to Void, by definition
15:03:39 <joelteon> Void is "the" empty type
15:04:02 <johnw> I do believe modern Haskell lets you say "data Foo"
15:04:06 * hackagebot ascii-vector-avc 0.1.0.0 - Process Ascii Vectors for Advantest 93k  http://hackage.haskell.org/package/ascii-vector-avc-0.1.0.0 (m)
15:04:07 <RedNifre> it does.
15:04:07 <johnw> to create your own named empty types
15:04:16 <mauke> scroll up
15:04:21 <johnw> oops
15:04:39 <RedNifre> Yeah, I'm asking why you would create "data Foo"
15:04:53 <wavewave> hi
15:05:00 <RedNifre> is "data Void" already in Prelude or do you define it by yourself?
15:05:03 <joelteon> to indicate when your code should never take a control path
15:05:06 <mauke> data Z; data S a;
15:05:07 <joelteon> Void is in the void package I think
15:05:16 <RedNifre> I mean, if all empty types are basically equivalent, why would you define more of them?
15:05:20 <joelteon> in haskell 98, "data Void" is invalid
15:05:24 <Philonous> RedNifre, Somestimes you only care about the type but not the values for some sort of type hackery. Before DataKinds empty types came in handy
15:05:25 <mauke> type-level computation
15:05:33 <joelteon> so people just depend on "void" since it's the canonical empty type
15:05:43 <joelteon> plus there are some utilities like absurd
15:05:45 <joelteon> and vacuous
15:05:46 <josephle> RedNifre, the name of a type might be useful, like in type-level computation
15:06:15 <josephle> useful from a readability standpoint, that is
15:06:19 <RedNifre> Oh, good. So I can safe all the work of implementing "data Void" by just doing "import Data.Void" and adding the dependency to the cabal file ;)
15:06:48 <joelteon> well, if you have people importing your code that want to use type signatures, it is a good idea to depend on void
15:06:49 <wavewave> Does "x <- readIORef ref"  make a clone of data stored in ref?
15:07:08 <mauke> wavewave: how could you tell?
15:07:11 <RedNifre> Yes, I was just joking. It's good that Void is already there.
15:07:13 <mauke> what is a "clone"?
15:07:38 <wavewave> mauke: I am thinking about sharing.
15:07:59 <mauke> gmm
15:08:01 <wavewave> mauke: let me rephrase.   if I have a very big tree in IORef.
15:08:06 <mauke> s/^g/h/
15:08:50 <wavewave> mauke: and    x <- readIORef ref   then update the ref with new tree which is partly changed from original
15:09:03 <wavewave> mauke: then y <-  readIORef ref
15:09:07 * hackagebot kdesrc-build-extra 0.1.0.2 - Build profiles for kdesrc-build  http://hackage.haskell.org/package/kdesrc-build-extra-0.1.0.2 (ivan)
15:09:54 <wavewave> then do x and y share the "shared" part of tree with each other?
15:09:56 <joelteon> well afaik all the leaves of the tree will refer to the same objects in memory
15:10:02 <mauke> I don't believe cloning is possible
15:10:02 <joelteon> since you can't modify them
15:11:18 <ADexter> hey there, somebody told me today that guards are slower then a "case x of _" notation. They seemed a bit odd to me, since the compiler should be able to interchange them. Can somebody confirm this and tell my why they are in fact slower?
15:12:04 <RedNifre> Why is Void an instance of Eq? What does it mean to compare nothing to something else? Isn't that a nonsensical notion?
15:12:10 <mauke> you can use guards in case x of _
15:12:14 <RedNifre> love the "absurd" function btw
15:12:31 <RedNifre> @let tryMe = absurd
15:12:32 <lambdabot>  .L.hs:158:9: Not in scope: ‘absurd’
15:12:41 <wavewave> mauke, joelteon: okay. that answers to me.
15:12:51 <wavewave> mauke, joelteon: thnx
15:20:53 <RedNifre> Ah, Void is Eq and identical to everything because comparing void to something is itself a false operation and you can derive anything from false statements? Hm. I'm not sure I understand it, why is Void equal to everything?
15:21:53 <monochrom> every Void value equals every Void value. this is different from your wording.
15:22:25 <monochrom> more carefully, "for all x, y of type Void, x=y" is provable.
15:23:04 <monochrom> this is emphatically not: "for all x of type Void, for all y of any type you like, x=y"
15:23:22 <chrisdotcode> > 1 + 1 -- test
15:23:24 <lambdabot>  2
15:23:49 <RedNifre> Oh, right. Forgot that Eq only means comparing values of the same type, since values of different types are always unequal...
15:24:24 <RedNifre> Sure, all voids are equal, because you can't find a pair of two void values that are different
15:24:28 <jhance> Notably "forall x,y of type Void, x=y" is (x, y are of type void) => x=y which is always true because the first statement is never true
15:25:05 <jhance> thinking of Void as an empty set
15:42:19 <fish____> What up
15:44:26 <lpaste> fish pasted “calculate” at http://lpaste.net/112660
15:44:58 <fish____> Trying to make a function that takes a string, parses it, and calculates the operation desired.
15:45:09 <fish____> Example: "212 + 8"
15:45:17 <dfeuer> Yeah?
15:45:33 <fish____> So far I've broken it into a list via words.
15:45:38 <dfeuer> fish____, that's a pretty nasty way to go about it.
15:45:49 <fish____> Yeah, it's not working.
15:46:09 <dfeuer> Well, words require spaces between, and read will be giving you type problems.
15:46:25 <dfeuer> You need to actually parse the thing one way or the other.
15:46:36 <fish____> That's what I'm trying.
15:46:37 <dfeuer> <--- ignorant of most parsing matters.
15:46:49 <fish____> ohh
15:47:00 <dfeuer> But .. you're not.
15:47:16 <dfeuer> What you want to do, fish____, is start by making a type for expressions.
15:47:23 <dfeuer> Expressions in your language, that is.
15:47:45 <dfeuer> So data Expr = Number Int | Plus Expr Expr  or something like that.
15:47:52 <fish____> ahh
15:48:16 <dfeuer> And then you want to write a "parser" that turns a string into an Expr, or fails.
15:48:18 <fish____> and then use read to convert the string to the type?
15:48:32 <dfeuer> And you probably don't use read at all.
15:48:44 <dfeuer> But
15:48:49 <dfeuer> Well.
15:48:53 <dfeuer> No, don't use read.
15:49:04 <fish____> hmm
15:49:10 <dfeuer> You can use it to turn a string of just numbers into an Int pretty well,
15:49:21 <dfeuer> but there's no real reason to.
15:49:36 <dfeuer> read is *not* a general-purpose function.
15:49:39 <geekosaur> read isn't really up to full strength parsing; it's more for parsing literal values
15:49:59 <geekosaur> constructor and value, or just value for primitive types like Int
15:50:23 <dfeuer> > read "Potato!" :: String
15:50:25 <lambdabot>  "*Exception: Prelude.read: no parse
15:50:36 <dfeuer> Oh yeah.
15:50:41 <fish____> Okay, thank you guys, I think I have a much better idea about how to approach this.
15:50:43 <geekosaur> and a horrible hack to make String work the way people expect, although arguably the hack in Show is worse
15:50:46 <dfeuer> read "\"Potato!\"" :: String
15:50:56 <dfeuer> > read "\"Potato!\"" :: String
15:50:59 <lambdabot>  "Potato!"
15:51:22 <dfeuer> > read "37" :: Int
15:51:23 <lambdabot>  37
15:51:30 <dfeuer> > read "37"::Double
15:51:31 <lambdabot>  37.0
15:52:12 <dfeuer> fish____, there are lots and lots of things out there about how to parse in Haskell. And lots and lots of ways to do it. And I know very little about any of them.
15:52:28 <indiagreen> > read "((1))" :: Int
15:52:29 <lambdabot>  1
15:52:46 <geekosaur> parsec and attoparsec are the big ones
15:52:49 <fish____> I've been trying google, but I suppose I was focusing my search on using some kind of built in read instance.
15:52:56 <geekosaur> also much more efficient than read
15:53:01 <fish____> That's probably why I wasn't finding a way to do it.
15:53:14 <dfeuer> parsec, attoparsec, pipes-parse, trifecta, and Dog only knows what else.
15:55:06 <monochrom> https://github.com/JakeWheat/intro_to_parsing is a good, up-to-date tutorial on parsec
15:57:00 <fish____> monochrom, thank you.
15:57:21 <dmj`> hey, anyone know what is wrong with my module header? haddock doesn't like it: http://lpaste.net/112661
15:57:34 <dmj`> parse error on input 'import'
15:57:39 <dmj`> line 8
15:58:13 <monochrom> IIRC it should be before even "module Web.HackerNews.Util where"
15:59:20 <dmj`> monochrom: ah yes, thank you
16:05:04 <orb__> Is ghc smart enough to realize that fmap-ing with a newtype wrapper should be a no-op?
16:05:58 <geekosaur> that's kinda the point of newtype, isn't it? newtype wrappers basically exist only in the typechecker, not in generated code
16:06:39 <indiagreen> orb__: no
16:07:03 <indiagreen> this is exactly why there are roles in GHC 7.8
16:07:03 <geekosaur> hm?
16:07:25 <indiagreen> geekosaur: wrapping and unwrapping a newtype is a no-op
16:07:35 <indiagreen> however, mapping over a structure isn't
16:09:27 <indiagreen> @hoogle coerce
16:09:29 <lambdabot> Unsafe.Coerce module Unsafe.Coerce
16:09:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:09:29 <lambdabot> Language.Haskell.TH.Syntax unsafeTExpCoerce :: Q Exp -> Q (TExp a)
16:09:49 <indiagreen> hm, lambdabot, you disappoint me
16:10:52 <indiagreen> orb__: to convert between types with no overhead whatsoever, you can use “coerce” from Data.Coerce
16:10:54 <geekosaur> hrm, I thought the point of roles was kinda the opposite, making there be more of a distinction in the cases where strict identity is the wrong thing to do
16:11:29 <indiagreen> geekosaur: well, previously there wasn't any safe way to do it
16:12:05 <indiagreen> I mean, there was GeneralizedNewtypeDeriving, which was unsafe (because Data.Set), and “unsafeCoerce”, which was just as unsafe
16:12:30 <indiagreen> but if you didn't want to use these, you had no way to make it a no-op
16:15:36 <jle`> 1/b 17
16:15:39 <jle`> sorry
16:16:20 <joehillen> how do I define an infix operator in GHCi?
16:17:55 <AshyIsMe> > let (@@@) = flip ($) in [1..4] @@@ map (+1)
16:17:57 <lambdabot>  [2,3,4,5]
16:18:04 <geekosaur> let a * b = ...        or: let (*) a b = ...
16:18:28 <joehillen> > let (:+:) = (+)
16:18:29 <lambdabot>  not an expression: ‘let (:+:) = (+)’
16:18:42 <indiagreen> @let (:+:) = (+)
16:18:43 <lambdabot>  .L.hs:158:1:
16:18:43 <lambdabot>      Not in scope: data constructor ‘:+:’
16:18:43 <lambdabot>      Perhaps you meant ‘:+’ (imported from Data.Complex)
16:18:46 <geekosaur> leading : is a constructor
16:18:58 <joehillen> > let (&+&) = (+)
16:19:00 <lambdabot>  not an expression: ‘let (&+&) = (+)’
16:19:20 <geekosaur> and now you trip over lambdabot not being ghci. let ... in
16:19:25 <geekosaur> or use @let / @define
16:19:33 <joehillen> ah
16:19:38 <joehillen> thx
16:19:41 <zorg24> So what's the recommended way to install Haskell on Debian? It looks like the one what's on the package manager is outdated?
16:20:00 <jle`> just install the ghc binaries
16:20:12 <jle`> there's a ppk somewhere
16:20:14 <jle`> but
16:20:18 <jle`> i'v never found it necessary
16:20:28 <jle`> and i think people generally install the binaries
16:21:14 <joehillen> zorg24: http://www.haskell.org/platform/linux.html install the "Generic Linux Binaries" version
16:21:22 <dmj`> wget ghc, ./configure, make install, then wget the cabal-install binary, voila
16:22:00 <witt> hey all, quick question...is there a "proper" way to read a NUL terminated string from a file or would you just read it as ByteString and drop the last byte?
16:22:24 <zorg24> joehillen: k thanks, I'm still sort of new to this Linux thing
16:22:56 <Axman6> witt: a null terminated string in a file is a pretty strange thing
16:23:22 <witt> yea you are right but im trying to read in a C struct that was dumped into a file
16:23:23 <geekosaur> it is?
16:23:49 <geekosaur> it's not an ideal thing but it's common for serializing C strings/values
16:23:49 <Axman6> witt: right, well what you suggest is probably reasonable
16:24:29 <witt> thanks, i just wanted to make sure i wasn't doing anything too crazy
16:35:54 <Hijiri> how would I build something in a cabal sandbox but install it to my main .cabal folder?
16:38:17 <geekosaur> that doesn't seem to make a lot of sense?
16:38:18 <tsani> orb__: (sorry for only answering ~20h later) I decided not to go with the library since I don't understand the types involved in it. Namely, I couldn't figure out how to write the MonadBase or MonadBaseControl instances.
16:39:58 <Hijiri> I'm trying to install something that copies executables and some shared files to the .cabal directory
16:40:19 <Hijiri> But I wants to build them in a sandbox so I don't have to deal with dependencies later
16:41:41 <_2_Brandon> you speak Spanish
16:43:59 <Axman6> _2_Brandon: #haskell.es I think
16:45:08 <lpsmith> http://accu.org/index.php/journals/1869
16:46:13 <exio4> @src reverse
16:46:13 <lambdabot> reverse = foldl (flip (:)) []
16:46:16 <_2_Brandon> you speak Spanish
16:46:23 <_2_Brandon> :(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(
16:46:45 <exio4> pirc bot?
16:47:03 <Axman6> _2_Brandon: #haskell.es
16:47:20 <geekosaur> I don't see one fwiw
16:47:42 <_2_Brandon> hola
16:47:42 <_2_Brandon> you speak Spanish
16:47:51 <Axman6> @where ops
16:47:51 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:47:59 <vanila> _2_Brandon, no habla espaniol
16:48:09 <trap_exit> reverse
16:48:11 <trap_exit> > reverse
16:48:12 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
16:48:13 <lambdabot>    arising from a use of ‘M56924782270687779493029.show_M56924782270687779493...
16:48:13 <lambdabot>  The type variable ‘a0’ is ambiguous
16:48:13 <lambdabot>  Note: there are several potential instances:
16:48:13 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:48:18 <trap_exit> > reverse []
16:48:19 <lambdabot>  []
16:48:21 <trap_exit> > reverse [1]
16:48:22 <lambdabot>  [1]
16:48:46 <geekosaur> so neither #haskell.es nor #haskell-es exists as far as freenodeis concented
16:48:53 <geekosaur> *concerned
16:48:58 <geekosaur> not that it matters now
16:49:04 <Axman6> hmm, http://www.haskell.org/haskellwiki/IRC_channel says it exists
16:49:05 <trap_exit> is "connection reset by peer" same as 'got kicked' ?
16:49:40 <geekosaur> no
16:50:28 <geekosaur> means freenode tried to send a packet and got RST back, so they probably shut the program down "hard" such that it didn't disconnect properly
16:50:42 <geekosaur> kicked shows up as kicked
16:55:48 <fozworth> i have a question about "cabal install"ing the dependencies for my package
16:55:48 <fozworth> i have a question about "cabal install"ing the dependencies for my package
16:56:24 <fozworth> if i do cabal install, i get a message that i should force reinstalls. but if i cabal install with "--preference criterion==0.8.*", it installs fine
16:56:39 <fozworth> i have criterion >=0.8 && <2.* in my .cabal file
16:57:36 <begriffs> Is there a setting to make Warp work in multi-threaded mode, or is that the default?
16:57:51 <dcoutts_> fozworth: right. The behaviour of the solver is that it usually looks to use the latest versions, and then at the end checks if it'd cause reinstalls.
16:57:58 <lpaste> fozworth pasted “hairy-cabal-install.sh” at http://lpaste.net/112666
16:58:36 <dcoutts_> fozworth: you can ask it to instead to prefer not reinstalling, but then it'll often have to try old versions and that's usually not what people want
16:58:43 <fozworth> oh i see. so what can i do if i want to support 0.8 out of the box without special flags, but also support 1.x?
16:59:10 <dcoutts_> fozworth: what you have in your .cabal file is fine
16:59:59 <fozworth> ok then this is an idiosyncrasy of cabal install's solver
17:00:28 <fozworth> and i could avoid it with "cabal install --avoid-reinstalls"?
17:00:34 <dcoutts_> fozworth: no, it's not, it's deliberate behaviour, preferring the latest is usually the right thing, rather than preferring avoiding reinstalls
17:00:53 <dcoutts_> fozworth: and yes, but then you have to be aware you may be installing older versions
17:01:08 <dcoutts_> fozworth: if you're worried about what other developers might hit, well the problem you're seeing with it saying it'd reinstall things is dependent on what you have installed already, and other users will see different things
17:01:09 <kadoban> It is? I thought reinstalls were bad enough that cabal says you're basically breaking something. How would that be the preferred behavior?
17:01:09 <fozworth> gotcha. thank you!
17:01:36 <fozworth> my goal here is to have a package that can be install with the latest haskell platform, but also support the latest versions of all dependencies
17:01:48 <dcoutts_> kadoban: depends if you care about breaking it or not, also going for older versions often doesn't work anyway
17:01:55 <fozworth> since HP comes with text and bytestring and stuff, some of the deps dont like that
17:02:19 <dcoutts_> kadoban: and the reinstall thing is at least completely explicit, you can see what it would do and decide if you're ok with that or if you want to avoid it
17:02:38 <kadoban> dcoutts_: Well, if old versions don't work, that's a problem with the dependency descriptions, right? So...cabal kind of assumes you're lying to it?
17:02:41 <monochrom> kadoban, the assumption is that you start clean, therefore no matter which version you choose, there is no conflict.
17:03:03 <kadoban> monochrom: Yeah, but isn't that a really bad assumption?
17:03:07 <dcoutts_> kadoban: right indeed, many of the problems are precisely that the old packages have wrong constraints that claim that they work when they do not
17:03:42 <dcoutts_> kadoban: but even if they did work, people don't like the solver "silently" picking old versions
17:03:50 <dcoutts_> as a default behaviour
17:04:04 <monochrom> if you ask me, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown is the right thing to do
17:04:17 <kadoban> dcoutts_: I know I'd like it...it's better than the only solution being to do reinstalls (that never has gone well for me)
17:04:32 <dcoutts_> kadoban: you can change the default in the config file
17:05:13 <dcoutts_> kadoban: it'll also lead to installing yet more versions of packages, which still doesn't scale (because we still cannot install multiple instances of the same one)
17:05:31 <Denommus> is there a more declarative EDSL for defining GUIs for Gtk2Hs?
17:05:44 <Denommus> the default functions are too barebones
17:05:45 <kadoban> dcoutts_: I'm not sure I follow that last?
17:06:56 <druw> Hey
17:07:08 <dcoutts_> kadoban: turns out that to be able to install new packages without breaking old ones that it's necessary to be able to install multiple instances of the same version of a package. It's not enough to be able to install multiple different versions.
17:07:39 <kadoban> dcoutts_: Because of...flags or something?
17:07:46 <dcoutts_> because of dependencies
17:08:12 <kadoban> Err
17:08:38 <dcoutts_> two packages that need the same version of some package but built against different versions of its dependencies
17:09:01 <kadoban> Hmm, yeah that sounds like kind of a mess
17:09:12 * hackagebot cgi 3001.2.2.0 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.2.2.0 (cheecheeo)
17:10:09 <dcoutts_> kadoban: and it works just fine if we allow multiple instances of the same version, as nix demonstrates. It's just that then we have a huge amount of flexibility to install things and we need a whole set of other tool updates to be able to cope.
17:11:12 <kadoban> Is there any info out there on why these problems seem so hard in haskell/hackage/cabal, when they don't really come up in other domains?
17:11:36 <kadoban> I'm not really sure what's different, like why doesn't this mess happen in python, for instance?
17:11:47 <dcoutts_> kadoban: it does happen in python
17:11:51 <dcoutts_> but as runtime errors
17:12:05 <kadoban> Hmmm
17:12:07 <dcoutts_> rather than noticing statically that interfaces do not match
17:12:58 <kadoban> So this system is more strict about checking that it's guaranteed to work rather than just guessing, that's kinda the difference?
17:13:14 <dcoutts_> yes, and we tend to change interfaces more often
17:13:18 <dcoutts_> because we have this safety net
17:14:00 <kadoban> I see. Fair enough. As just j-random-coder though, I gotta say I dread every time I run 'cabal install'. I've gone to just using one-sandbox-per-project, and even so...
17:14:19 <dcoutts_> one sandbox per project is perfectly reasonable
17:15:04 <dcoutts_> kadoban: so you know, we're well aware of the problems and people have been thinking about this for some time. There are solutions in progress.
17:15:08 <Denommus> so, Gtk2Hs's normal functions are very, VERY bare bones, and Glade is horrible
17:15:33 <Denommus> is there any library on top of Gtk2Hs that makes UI more declarative?
17:15:59 <dcoutts_> kadoban: http://www.well-typed.com/blog/99/
17:16:20 <kadoban> dcoutts_: Right, seems like lots of smart people are working on it, don't mean to be too down on it...probably not much point in me complaining, the problems seem well known.
17:16:31 <kadoban> dcoutts_: Sounds interesting from the title, I'll take a look
17:18:42 <tsani> XD
17:18:48 <tsani> (oops mischan)
17:21:12 <felixn> int-e: benzrf: sivteck: bzzt. some bloke trolling gists totally schooled me https://gist.github.com/munro/7a57a36cbf6eeac3a1a4
17:21:46 <Denommus> benzrf: hey
17:21:55 <benzrf> sup de
17:21:56 <benzrf> sup deni
17:22:02 <benzrf> ergh
17:22:05 <benzrf> my tab complete is broken!
17:22:32 <Denommus> benzrf: nah, there's a deni online. You should type denoTAB
17:22:51 <Denommus> benzrf: anyway, have you ever done GUI programming in Haskell?
17:22:58 <benzrf> i know, by broken i mean i misuse dit
17:23:04 <benzrf> Denommus: no
17:23:07 <felixn> his client should know you're the only de<tab> for him
17:23:11 <benzrf> but frp seems to be a good choice
17:23:15 <jbeja> You could use Functional Reactive Libraries like Yampa
17:23:37 <jbeja> to do Haskell Gui with open GL...maybe
17:23:50 <vermeille> I'm currently reading the darcs' Patch Theory and I'm impressed how you, haskell guys, manage to define a formalism for absolutely anything. Do you know of any trial to take the problem of VM design with maths to obtain a VM design which is really sound and smart?
17:23:50 <Denommus> jbeja: I'm using reactive-banana already
17:24:02 <benzrf> banaynay
17:24:07 <Denommus> jbeja: the problem isn't the event-driven model, but with actually creating the interface
17:24:25 <Denommus> jbeja: Gtk2Hs is too imperative programatically, and Glade... sucks
17:24:33 <jbeja> I heard tht Yampa is more performant and poprular that is what I am learning know is based on Arrows
17:25:07 <jbeja> I need to type more carefully
17:25:51 <Denommus> jbeja: I kinda like arrows (specially how they are made in netwire). But it is very easy to make bindings from Gtk to Yampa
17:25:55 <jbeja> Any GTK2 library sucks ass
17:26:09 <Denommus> do you have another recommendation?
17:26:21 <Denommus> is there any good qt library for Haskell?
17:26:52 <jbeja> Denommus: Have you tried using PureScript intead haskell to make Web UI as an alternative or maybe Elm?
17:27:02 <AshyIsMe> so has anyone here bought the video of ocharles live coding yet?
17:27:33 <AshyIsMe> i think im going to so i can find out what functionality my vim setup is missing compared to his emacs setup
17:27:49 <Denommus> jbeja: I wanted desktop clients, too :-/
17:28:44 <jbeja> I don't know, haskell since pretty newborn in that field I think
17:28:52 <monochrom> . o O ( emacs = vim - vim + emacs )
17:29:16 <jbeja> But FRP is becoming more and more popular this days for some reason
17:29:58 <Denommus> AshyIsMe: my Emacs setup for Haskell kinda prouds me. I have auto-completion (TRUE auto-completion, based on available symbols, not on textual completion), a REPL integrated with cabal, and live syntax/type checking
17:30:22 <Denommus> jbeja: well, the reason why I want to do GUI development in Haskell is to experiment FRP
17:31:11 <Denommus> jbeja: but, again, my problem isn't with the event-driven approach, but with drawing the screens
17:31:17 <Hodapp> are there any working libraries for FRP & GUI together?
17:32:07 <jbeja> You can use Haskell OpenGL for that, most open source libraries are base in OpenGl , maybe you could build one for your own projects
17:32:08 <AshyIsMe> Denommus: nice, i have syntastic in vim for syntax and error highlighting
17:32:12 <AshyIsMe> and ghc-mod for type checking
17:32:43 <Denommus> Hodapp: of course, reactive-banana works greatly for that!
17:32:47 <AshyIsMe> i havent properly set up the cabal repl yet though, i just open a new tmux pane and use it there
17:33:06 <AshyIsMe> Denommus: what are you using for your auto-completion?
17:33:09 <Denommus> AshyIsMe: the cabal repl allows me to check the type for a symbol with C-c C-t
17:33:20 <Denommus> AshyIsMe: company-mode + ghc-mod
17:33:36 <AshyIsMe> oh yeap, i can do that with ghc-mod <leader>ht  (mnemonic for Haskell Type)
17:33:40 <jbeja> I will give I try to Reactive.banana on the weekend to see what is all the fuzz about
17:34:13 * hackagebot hairy 0.1.3 - A JSON REST API  http://hackage.haskell.org/package/hairy-0.1.3 (fozworth)
17:34:24 <jbeja> Talking about company mode, did you feel it better than autocomplete?
17:34:37 <AshyIsMe> ghc-mod is probably helping my autocomplete without me realizing, it's harder to tell in haskell because you don't do the usual OOP thing of myObject.<wait for methods to appear>
17:36:09 <Denommus> jbeja: yes, I like it better
17:36:20 <AshyIsMe> EasyMotion mode looks sweet for vim, it's apparently what inspired the ace-jump mode that ocharles uses
17:38:18 <jbeja> I sometimes I just switch  from vim to emacs but something that has been keeping me away from it is that no good autocomplete plugin like Vim's YouCompleteMe
17:39:36 <AshyIsMe> Denommus: oh i have my tags set up really nice in vim too, hasktags and codex work really well
17:39:52 <AshyIsMe> means i can jump direct to not only my own functions but also library code
17:40:13 <Denommus> AshyIsMe: ah, I didn't mention tags because they come naturally with cabal
17:40:27 <jbeja> Really how is that?
17:41:23 <Denommus> jbeja: cabal repl -> :ctags (or :etags, if you use Emacs)
17:41:33 <AshyIsMe> oh wow, really?
17:41:54 <jbeja> What, how i didn't know that until this point?
17:41:59 <AshyIsMe> yeah wtf
17:42:17 <AshyIsMe> does it do the libraries you import aswell?
17:43:27 <fozworth> if anyone is looking for something to do, i'd appreciate a code review of my little scotty app https://github.com/tfausak/hairy/blob/v0.1.3/library/Hairy.lhs
17:43:27 <AshyIsMe> hmm, it only seems to do your project code, not libraries
17:43:40 <geekosaur> no, and in particular it only does anything loaded as source, not precompiled
17:44:03 <Denommus> AshyIsMe: I don't think it does it with the libraries, just your own code
17:44:08 <AshyIsMe> https://hackage.haskell.org/package/codex
17:44:14 * hackagebot hadoop-formats 0.2.1.1 - Read/write file formats commonly used by Hadoop.  http://hackage.haskell.org/package/hadoop-formats-0.2.1.1 (JacobStanley)
17:44:18 <AshyIsMe> you should check that out then, it's really nice being able to jump to library source
17:44:44 * geekosaur still wants a haskell version of cscope, someday...
17:45:22 <begriffs> It's weird, I'm using Warp 3 and it feels like it is not forkingIO in a response handler. As a demo I tried doing a simple threadDelay inside the handler and I verified that makes requests go serially rather than in parallel.
17:45:54 <begriffs> Can Warp handle multiple requests at once?
17:46:57 <Denommus> AshyIsMe: does it support etags?
17:47:20 <begriffs> geekosaur: https://hackage.haskell.org/package/hscope ?
17:48:02 <AshyIsMe> oh, hmm, maybe not
17:48:11 <AshyIsMe> do ctags convert to etags easily?
17:48:14 <geekosaur> "partial"
17:48:18 <AshyIsMe> maybe you can set up a script
17:48:24 <Denommus> AshyIsMe: it does
17:48:25 <geekosaur> they don't, sadly, because etags is much dumber
17:48:29 <Denommus> set format emacs
17:48:35 <AshyIsMe> oh colo
17:48:38 <AshyIsMe> cool*
17:48:50 <geekosaur> so you can write stuff as etags but porbably lose functionality
17:49:01 <begriffs> I use hasktags + codex + hscope for navigating code.
17:49:50 <AshyIsMe> haha i have "AA TODO: Set up hscope"  in my vimrc
17:50:14 <solatis> anyone uses structured-haskell-mode?
17:50:27 <Denommus> solatis: what is that?
17:50:27 <solatis> https://github.com/chrisdone/structured-haskell-mode
17:51:01 <solatis> an extremely opinionated way to structure your haskell code while writing
17:51:26 <Denommus> solatis: oh, cool!
17:51:30 <Denommus> solatis: I love paredit!
17:51:43 <Denommus> solatis: is it available on melpa or marmalade?
17:51:51 <begriffs> AshyIsMe: it's a bit of self promotion, but you can steal hscope settings from my vim config https://github.com/begriffs/haskell-vim-now
17:52:08 <joehillen> solatis: wow, I do not like that style at all
17:52:19 <AshyIsMe> begriffs: ah very nice, cheers
17:52:38 <solatis> joehillen: as the dude says, "well, that's just like, your opinion man"
17:53:03 <solatis> but yeah i find it a bit too exreme to get used to myself
17:53:04 <Denommus> joehillen: have you ever tried paredit?
17:54:35 <AshyIsMe> i loved paredit back when i was messing around with lisp
17:55:00 <AshyIsMe> ive been meaning to sort out something similar with vim text objects for certain languages
18:01:48 <AshyIsMe> begriffs: wow im gonna have to steal lots from your vim setup
18:02:23 <AshyIsMe> you should do a haskell cast similar to ocharles one
18:04:13 <Denommus> solatis: I didn't like it
18:04:29 <Denommus> solatis: I mean, I like the idea, but it still has a long way to go to reach paredit's maturity
18:04:49 <Denommus> solatis: some of the advertised features are broken, it's missing some important features...
18:04:51 <solatis> i haven't had any experience with paredit myself
18:05:12 <Denommus> paredit is awesome, to put it lightly
18:05:27 <Denommus> you can FEEL your code as a big tree that you manipulate
18:05:57 <Denommus> but I guess it is hard to have similar features for languages not based on s-exprs, after all
18:06:06 <Denommus> anyway, I gotta go home, good talking to ya guys
18:19:16 * hackagebot hzulip 0.3.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.3.0.1 (yamadapc)
18:33:54 <trap_exit>  /join #fitness
18:40:43 <vermeille> Is there any ncurses-like library more idiomatic and higher level?
18:42:54 <geekosaur> vty-ui? (if you need the non-ANSI/ECMA terminal support, this won't work)
18:44:09 <dmj`> question: hac-phi registration is closed?
18:44:59 <dmj`> "If you will be attending, you must have registered, but registration is now closed."
18:45:05 <dmj`> so you can't attend?
18:46:34 <trap_exit> this is slightly OT:
18:46:43 <trap_exit> is there a good monitor stand for 3 27" monitors?
18:46:45 <vermeille> geekosaur: looks like what I was looking for, thanks!
18:46:49 <trap_exit> I have a 27" imac + 2 27" LCDs
18:46:49 <tsani> Speaking of hackathons, which of you have used haskell in hackathons (not haskell-specific ones such as hac-phi) ?
18:47:13 <Denommus> vermeille: for defining the layouts, or for the event handling part?
18:48:13 <Denommus> vermeille: for the event handling, I'd recommend you to look into reactive-banana
18:48:59 <vermeille> Denommus: I don't really know, I just tried writing some ncurses things some time ago, and found it to be unpleasing
18:49:27 <Denommus> Ver
18:49:28 <geekosaur> ncurses is pretty broken anyway
18:50:14 <vermeille> It was the C ncurses, but it shouldn't make a big difference, the design is just unpleasing
18:51:07 <geekosaur> I meant the C ncurses
18:51:48 <geekosaur> curses was kinda bodily ripped out of the original vi, and had odd stuff bolted on afterward
18:52:03 <geekosaur> ncurses didn't aim to fix it, just be compatible with system V curses
18:52:06 <Denommus> vermeille: what was unpleasant about it? I'm asking that because I'm doing some gui programming myself, and while reactive-banana is great for handling the events and time-varying values, defining layouts in Gtk2Hs (which I'm using) is boring
18:52:12 <thinker341A> Hello Haskellers, i just started listening to EdX haskell course, and typed : sum[1.1..3] , GHCI gave me 6.300000000000001 , who did haskell calculate this?
18:52:49 <geekosaur> Denommus, I don't see where they said anything about reactive-banana, just ncurses
18:52:53 <geekosaur> and ncurses isn't even gui
18:53:01 <heatsink> > [1.1..3]
18:53:04 <lambdabot>  [1.1,2.1,3.1]
18:53:15 <heatsink> > 0 + 1.1 + 2.1 + 3.1
18:53:17 <lambdabot>  6.300000000000001
18:53:32 <vermeille> Denommus: IIRC ncurses does not even have the concept of a widget, or a textarea, etc. It's really low level
18:53:32 <Denommus> geekosaur: I'm asking what was unpleasant about it to her
18:53:37 <heatsink> thinker341A, do you know how floating point arithmetic works?
18:53:48 <vermeille> to him*, please
18:53:56 <jxv> heatsink, C doesn't have that same error. It's close enough though.
18:53:59 <geekosaur> Denommus, why do you believe it was unpleasant? nothing suggests it was even tried
18:54:07 <Denommus> geekosaur: because if it's the event part, FRP solves it quite well
18:54:11 <geekosaur> they said, repeatedly, that *ncurses* was unpleasant
18:54:25 <Denommus> geekosaur: if it's how to define a layout, I don't really know
18:54:26 <thinker341A> heatsink, yes , i understood how it calculated that now , thx!
18:54:41 <geekosaur> ...
18:54:42 <Denommus> geekosaur: he said it was unpleasant
18:55:53 <zenware> ncurses supports horizontal and vertical line drawing... you could abstract widget and textarea on top of it.
18:55:59 <Denommus> geekosaur: ok, and I was asking WHAT was unpleasant about it
18:56:03 <heatsink> I get the same result in C, jxv
18:56:05 <geekosaur> sigh
18:56:18 <jxv> heatsink, http://codepad.org/Zy63y4Nc
18:56:18 <geekosaur> Denommus, as far as I can tell you hijected the thread to talk about something else
18:56:27 <heatsink> jxv: printf("%.15f\n", 1.1 + 2.1 + 3.1);
18:56:31 <geekosaur> so far you, and you alone, have mentioned reactive-banana
18:56:48 <Denommus> geekosaur: yes, because I have a similar doubt
18:57:00 <thinker341A> >sum[1.1..1.5]
18:57:07 <jxv> heatsink, oh right. "%.15"
18:57:33 <thinker341A> [1.1..1.5]
18:57:40 <thinker341A> >[1.1..1.5]
18:58:03 <Denommus> geekosaur: I'm doing gui programming in Gtk2Hs and reactive-banana. The reactive part works really well, but defining layouts in Gtk2Hs is boring. So I wondered if their problem was similar to mine
18:58:24 <Denommus> geekosaur: I'm sorry if I was wrong 😛
18:58:45 <heatsink> You can try it in ghci, thinker341A
18:59:42 <geekosaur> thinker341A, the space after > is not optional
19:00:17 <thinker341A> > sum[1.1..1.5]
19:00:19 <lambdabot>  1.1
19:00:42 <thinker341A> geekosaur, Thx! i will stop spammin and try in Ghci
19:00:52 <geekosaur> also, the enum instance for Float and Double is ... unfortunate
19:00:53 <vermeille> zenware: sure, but it's still some more work, which can be avoided. I mean, who wants to spend time on the ui when you have a software to code? If the ui is not a big part of it, I'd like to have somethinghigh level  already filling my needs
19:01:12 <geekosaur> and has many caveats
19:04:26 <cdk> if anyone uses structured-haskell-mode, I've just installed it. I turned off the haskell-mode indentation modes, but structured-haskell-mode doesn't indent my code properly (read: no indentation at all). What am I doing wrong?
19:06:34 <vermeille> what are the strengths of darcs compared to git? I know about the patch theory etc, but do you feel it in your usual daily workflow?
19:07:04 <zenware> Is there something I can use to desugar a haskell function or do I have to do it manually? I'm interested in a comparison.
19:07:54 <dfeuer> zenware, to desugar a Haskell function? Yeah, just use GHC!
19:08:11 <dfeuer> zenware, specifically, ghc -ddump-ds
19:09:15 <zenware> dfeuer: Thanks :)
19:10:54 <lpaste> prinsen pasted “Parsec Left Recursion” at http://lpaste.net/112670
19:11:45 <prinsen> The above parser does not work, as it wants a function (a -> a -> a). Is there any other parsec function?
19:12:39 <heatsink> vermeille: hg and git make it a hassle to push and pull patches while I have uncommitted changes
19:13:07 <heatsink> vermeille: They use the working directory for interactive merging, so they will refuse to do anything leading to a merge if the working directory is not clean
19:14:51 <vermeille> heatsink: yes, but you can solve it easily with git stash then git stash pop. But that's true, I *always* forget to do it
19:17:22 <heatsink> I didn't know about that.
19:18:10 <cow_2001> how come Parsec's website is dead?
19:18:50 <cow_2001> https://hackage.haskell.org/package/parsec-3.1.7 links to homepage http://www.cs.uu.nl/~daan/parsec.html which is dead
19:18:52 <vermeille> obviously the pull might conflict when popping
19:20:22 <Total_1mmersion> Any idea why installing haskell-plot is failing with the error "The pkg-config package 'pangocairo' version >=1.10 is required but it could not be found."?
19:20:36 <Total_1mmersion> The latest version of pangocairo from apt-get seems to be 1.0, which I have.
19:22:32 <rfw> hi, what's the recommended way of designing concurrent network servers with haskell?
19:23:38 <rfw> so assume i'm designing some kind of chat server, what's the recommended way of architecting it?
19:23:46 <rfw> i see things about conduit and channels
19:25:08 <Total_1mmersion> rfw, I don't know, but I have also heard of conduit, pipes, and STM
19:25:31 <rfw> do you know if there are any large scale network servers written in haskell?
19:25:34 <Total_1mmersion> rfw, maybe you would also be interested in socket IO?
19:25:44 <Total_1mmersion> sorry, no
19:26:00 <rfw> sure but i'm just wondering what most people do
19:26:16 <rfw> i feel like there's something more than just handling sockets and doing forkIO
19:31:15 <prinsen> http://lpaste.net/112670 - pls help
19:34:14 <platz> rfw: what about the Async API, or STM?
19:34:56 <rfw> platz: ah, cool
19:35:11 <rfw> and threads in haskell are green threads right?
19:35:35 <rfw> the ones from forkIO anyway
19:35:36 <platz> by default yes
19:36:07 <blairio> Can someone help me out with an error I'm getting?
19:36:57 <rfw> platz: thanks, i'll take a look
19:37:11 <platz> rfw: http://hackage.haskell.org/package/async (async) http://chimera.labs.oreilly.com/books/1230000000929/ch12.html (STM)
19:38:22 <blairio> http://lpaste.net/112672
19:38:38 <blairio> Can someone help me figure out why this won't compile?
19:39:29 <blairio> "BinaryTree.hs:10:25:
19:39:30 <blairio>     No instance for (Show a) arising from a use of `getTree'
19:39:30 <blairio> "
19:42:58 <hughfdjackson> blairio: isn't your issue recursive dependencies?
19:43:20 <hughfdjackson> the getTree call on line 10 requires that `t` is an instance of Show
19:43:30 <blairio> Haha! That would make sense
19:43:53 <hughfdjackson> in the definition of show for t xD
19:45:12 <hughfdjackson> i meant cyclic dependencies, didn't i ?
19:45:19 <hughfdjackson> bah - 4am is not kind to my brain ;D
19:45:21 <trap_exit> anyone here able to code haskell in a 13" mbp? I find that to productively code haskell, I need 2 windows (1) an emacs window and (2) a window (either terminal or browser) showing the output as I write the code -- I cna't fit  both on a 13" mbp -- anyone here able to code haskell on a 13" mbp ?
19:45:54 <hughfdjackson> trap_exit: 'the output'?
19:46:02 <trap_exit> yeah, the output of the haskell program
19:46:08 <trap_exit> either stdout or a *.html file it dumps
19:46:38 <hughfdjackson> i generally have an emacs tab,  a ghci tab and a regular shell for running cabal commands in another tab
19:46:39 <platz> what do you think of tmux
19:46:52 <hughfdjackson> which seems to work okay..
19:46:56 <trap_exit> so you're not viewing them all at the same time?
19:47:18 <hughfdjackson> yup - but they're a shortcut away, which seems to be enough for me
19:47:23 <trap_exit> I want 2 windows at the same time, which does not seem to work well when (1) on 13" mbp and (2) I wnat 80 char wide terminals
19:47:24 <platz> seeing everyone at one is kind of nice
19:47:40 <hughfdjackson> -.- yea, i can see how that'd be an issue - i'm afraid i don't have a useful suggestion..
19:47:42 <platz> can't type today, wow
19:47:45 <hughfdjackson> unless you can split horizontally !
19:48:00 <hughfdjackson> but i'm taking it that you've tried that
19:48:34 <trap_exit> I hate apple for killing the 17" mbp
19:48:37 <blairio> Wait! I don't think the dependencies should be circular, unless I'm confused about the syntax
19:48:37 <trap_exit> best laptop ever
19:48:56 <hughfdjackson> blairio: let me test out my theory with a minimal example
19:49:11 <AshyIsMe> trap_exit: 17" doesnt sound very portable
19:49:43 <GeraldCode> well, friends and neighbors, I have an anoucement
19:49:44 <platz> but doesn't retina make it more readable?
19:49:55 <GeraldCode> I have decided to favor F# over haskell
19:49:59 <blairio> hughfdjackson: In the getTree, I'm trying to say that a is showable, not that BinaryTree a s are showable
19:50:13 <GeraldCode> I guess I am kind of trolling, but not trolling in a jerk way
19:50:14 <platz> GeraldCode: I hope you like |>
19:50:27 <AshyIsMe> GeraldCode: what are the main reasons?
19:50:31 <trap_exit> GeraldCode: no problem; I went haskell -> clojure -> haskell before realizing my mistakes
19:50:34 <AshyIsMe> (genuinely curious)
19:50:35 <GeraldCode> platzm, well I do like the |>
19:50:53 <hughfdjackson> blairio: ah, good point..
19:51:03 <platz> yep it seems to suffice
19:51:05 <GeraldCode> AshyIsMe, well F# has the type inference and all the things i like about haskell...but I just don't like monads...full stop
19:51:14 <GeraldCode> when I get too confused I can still do imperative
19:51:25 <GeraldCode> So I told my boss we need to do F#.net from now on
19:51:33 <merijn> blairio: You are trying to use getTree (which has a Show constraint on a) inside your "Show" instance for BinaryTree a
19:51:40 <platz> I wish I could use F# at work
19:51:57 <hughfdjackson> merijn: that's what i thought the problem was.. but wouldn't it work if a was an instance of Show?
19:52:02 <AshyIsMe> yeah that's one huge benefit of F#
19:52:08 <AshyIsMe> visual studio for windows programmers
19:52:11 <merijn> hughfdjackson: No
19:52:16 <merijn> hughfdjackson: It doesn't type check
19:52:17 <AshyIsMe> and microsoft backing
19:52:22 <platz> maybe start with some FAKE build scripts
19:52:28 <AshyIsMe> makes it a much easier sell for management and coworkers
19:52:35 <GeraldCode> AshyIse, I had done linux my whole career until a few years ago
19:52:40 <GeraldCode> we do all windows..
19:52:41 <hughfdjackson> merijn: hehe, clearly ! I'm not sure i understand why though
19:52:45 <merijn> hughfdjackson: blairio's current code claims BinaryTree's can be shown REGARDLESS of what's in there
19:52:46 <GeraldCode> so it makes sense I think
19:52:49 <chirpsalot> blairio: your instance should be something like instance Show a => Show (BinaryTree a) where
19:52:53 <chirpsalot> blairio: I think.
19:52:54 <GeraldCode> And the package management is much better
19:52:55 <GeraldCode> etc
19:53:08 <hughfdjackson> `instance (Show a) => Show (BinaryTree a) where` ?
19:53:09 <blairio> chirpsalot: Ah! I'll try that!
19:53:11 <merijn> hughfdjackson: Suppose I have a type Foo which can't be shown, "BinaryTree Foo" is a Show instance according to his code
19:53:14 <platz> One thing I have not grokked yet is when people say that F# is kind of broken monadically because it does not have return type polymorphism
19:53:33 <GeraldCode> platz, hmm
19:53:41 <merijn> hughfdjackson: But it calls getTree, which only works if 'a' is a Show instance, which my Foo is not. Whoops!
19:53:50 <hughfdjackson> :) point well made
19:53:50 <platz> I'm guessing this makes things like QuickCheck and monadic parser combinators harder to write
19:53:52 <AshyIsMe> GeraldCode: yeah tooling and integration with existing workflow is highly important for teams
19:53:56 <platz> and also it's lack of Higher Kinded Types
19:53:56 <merijn> And yes, "instance Show a => Show (BinaryTree a)" is the solution
19:54:07 <AshyIsMe> haskell has the problem of most people doing it using vim/emacs
19:54:10 <chirpsalot> blairio: i.e., you can only Show a (BinaryTree a) if a is in the Show typeclass.
19:54:15 <chirpsalot> blairio: 'gratz!
19:54:17 <blairio> Hmm, now it doesn't match the Show definition, so it's rejecting it
19:54:20 <AshyIsMe> which straight away rules out 99%+ of windows developers
19:54:26 <merijn> blairio: You can read that as "BinaryTree a is an instance of Show IFF a is an instance of Show"
19:54:41 <GeraldCode> AshleyIsME, frankly I think many people here would like F#
19:54:56 <GeraldCode> its ML bacjround makes it bvery similar in many ways
19:54:58 <merijn> Does F# have higher kinded types?
19:55:04 <platz> merijn: no
19:55:05 <GeraldCode> just no dealing with monads and arrows, etc
19:55:14 <AshyIsMe> GeraldCode: haha no l in AshyIsMe, type ash<tab> and it should autocomplete
19:55:24 <blairio> Yeah, that makes sense, I just hadn't thought to alter the signature of Show
19:55:25 <GeraldCode> Ah, sorry man
19:55:26 <merijn> GeraldCode: No higher kinded types and no monad == already lost interest
19:55:30 <MP2E> same
19:55:49 <merijn> Lack of typeclasses is annoying too
19:55:53 <platz> well F# does have some monad-like things called "computation expressions"
19:56:02 <nitrix> I'm actually enjoying reading on concatenative languages right now. With very simple purity mecanisms along IO done with linear types, which IMO is cleaner than monads.
19:56:10 <GeraldCode> merijn, thats cool..I am just selfelshing  saying I found the variety of functional that works for me
19:56:32 <Hodapp> nitrix: what sort of languages?
19:56:33 <dmj`> ocaml doesn't have higher kinded types either right? f# is like ocaml.net
19:56:41 <GeraldCode> merijn, between the monads, arrows, and ESPECIALLY the cabal hell I knew I could never use this professionallly
19:56:42 <merijn> GeraldCode: You should go watch Erik Meijer's talk on "why F# isn't good enough" :)
19:56:46 <GeraldCode> Maybe I am not smart noeugh
19:56:49 <GeraldCode> but it is what is
19:56:53 <AshyIsMe> GeraldCode: i still havent fully grokked the advanced usage of monads, i think the terminology makes it sound much scarier than it really is
19:56:56 <merijn> dmj`: ocaml doesn't have higher kinded types either
19:57:10 <GeraldCode> AshyIsMe, , I understand monads theoretically
19:57:21 <GeraldCode> but I cant use them in production and actually meet deadlines
19:57:23 <Hodapp> they're like academic burritos, right?
19:57:25 <merijn> GeraldCode: Monads are not that hard, almost no one uses arrows and cabal hell is mostly an issue of managing your dependencies
19:57:29 <dmj`> GeraldCode: you *can* use haskell professionally...
19:57:36 <blairio> Anyone know how to bypass the
19:57:41 <nitrix> Hodapp: It's statically typed, strict and procedural.
19:57:48 <platz> which seem to allow some quite monad looking things http://www.fssnip.net/6i
19:57:50 <nitrix> Hodapp: I guess it'd be a bastard of Haskell and Rust.
19:57:58 <blairio> error I'm getting because of a parameter on Show
19:58:00 <Hodapp> nitrix: has it a name?
19:58:02 <platz> you kind of have to "name the monad" when you use it - instead of inferring it
19:58:11 <nitrix> Hodapp: ni, for nitrix :P
19:58:14 <AshyIsMe> merijn: got a link to that eric meijer talk?
19:58:15 <platz> i.e. let (Action ()) = io { stuff }
19:58:23 <merijn> blairio: lpaste the entire code + error
19:58:31 <nitrix> Hodapp: Ahah, I'm still designing it, don't get too hyped up (:
19:58:39 <Hodapp> :P
19:58:42 <merijn> AshyIsMe: Maybe? Lemme check if it was taped
19:58:55 <GeraldCode> merijin, but how does one manage dependencies? I have literally spent entire nights just trying to build a package
19:59:01 <AshyIsMe> GeraldCode: not every team is suited to using the best tools, ive only recently convinced people at work to start using git over svn
19:59:06 <MP2E> cabal sandboxes
19:59:20 <blairio> http://lpaste.net/112672
19:59:21 * hackagebot Zora 1.1.18 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.18 (bgwines)
19:59:34 <GeraldCode> Ashy, true
19:59:35 <merijn> GeraldCode: Yesod? >.>
19:59:39 <dmj`> there's some F# stuff in haskell: https://hackage.haskell.org/package/fsharp-0.0.4/docs/src/Control-FSharp-Syntax-Operators.html#%3C%7C
19:59:41 <nitrix> Hodapp: If you like following projects from scratch to maturity (and the noise it implies), you can star https://github.com/nitrix/ni.
20:00:21 <GeraldCode> merijin, actually that was what I was getting into
20:00:30 <GeraldCode> had loads of issues
20:00:36 <GeraldCode> didnt play nice with mongo
20:00:41 <GeraldCode> which is what I use for my DB
20:00:49 <GeraldCode> That was the impetus to give up
20:01:08 <merijn> GeraldCode: Yesod is notoriously hard to build, it has a gazillion dependencies and they all keep moving
20:01:38 <platz> GeraldCode: http://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work/
20:01:42 <merijn> blairio: You have a "Show a" constraint on your show function, it should be on the *class instance*
20:01:44 <nitrix> Hodapp: It looks like crap, no documentation, no proper implementation, it's just me testing ideas so far, but I'm comming up with something.
20:01:51 <GeraldCode> thanks platz
20:01:58 <nitrix> Hodapp: It's re-assuring when you know that 6 months ago it looked like this: https://github.com/nitrix/ni/blob/0df4d4dc937daa2e4fc37c94f29276fc72b9500c/src/main.ni
20:02:07 <nitrix> Hodapp: Yeaaaaah, I'm extreme a bit.
20:02:16 <merijn> blairio: http://lpaste.net/112674
20:02:25 <nitrix> That was to boostrap the compiler.
20:02:27 <merijn> AshyIsMe: http://eelcovisser.org/wiki/future-of-programming/proceedings
20:02:34 <merijn> AshyIsMe: I think it was the first talk on day 1
20:02:38 <nitrix> All it does is compile itself to itself...
20:03:07 <GeraldCode> merijin, yeah
20:03:16 <blairio> merijn: Ahh! Thanks
20:03:17 <GeraldCode> I also signed up for fp complete website
20:03:22 <GeraldCode> which made things much easier
20:03:25 <AshyIsMe> merijn: cool cheers
20:03:29 <GeraldCode> but they charge outrageous fees
20:03:39 <GeraldCode> I can't justify those fees
20:03:57 <chirpsalot> Heh. Does Yesod even work under nix?
20:04:15 <GeraldCode> chirpsalot,  Yesod ONLY works under nix
20:04:19 <MP2E> hahah
20:04:35 <MP2E> I don't know if that's true necessarily, but it does work in nix  yes.
20:04:39 <merijn> It's bad for the ecosystem that every newcomer seems to want to use Yesod while Yesod's build sucks so bad
20:05:02 <merijn> We should start advocating happstack/snap or similarly easier to build frameworks >.>
20:05:10 <dmj`> snap is great
20:05:31 <benzrf> happstack more like hipster
20:05:48 <chirpsalot> merijn: I still hate cabal from my attempts with Yesod :P.
20:06:02 <dmj`> chirpsalot: do you use sandboxes?
20:06:10 <chirpsalot> dmj`: now, yes.
20:06:22 <chirpsalot> dmj`: although even then Yesod is hit and miss.
20:06:33 <dmj`> chirpsalot: have you tried snap
20:07:14 <rfw> is the recommended way of having a concurrent map type ConcurrentMap k v = TVar (Map k v)?
20:07:41 <GeraldCode> chirpsalot, I looked at about 4 haskell frameworks
20:07:54 <GeraldCode> not a single one was actually easy to use!
20:07:57 <GeraldCode> for web I mean
20:07:57 <Ralith> rfw: 'concurrent map' is not a well defined term
20:08:00 <GeraldCode> they are all crap
20:08:04 <GeraldCode> even yesod
20:08:13 <rfw> Ralith: sure, but i mean if i want a map that i can w rite concurrently to
20:08:15 <chirpsalot> dmj`: I haven't, no.
20:08:19 <dmj`> GeraldCode: snap is pretty simple
20:08:22 <rfw> is it efficient enough?
20:08:26 <GeraldCode> That isnt to say a good haskellweb framework cant be made
20:08:36 <GeraldCode> dmj, but snap is pretty bare bones, right?
20:08:38 <Ralith> rfw: you can't write to that concurrently; you can only serialize writes.
20:08:43 <GeraldCode> it isnt really a true framework?
20:08:48 <Ralith> rfw: "efficient enough" is also not a defined term.
20:08:53 <chirpsalot> It really doesn't help that the cabal error messages take some effort to decipher sometimes.
20:09:11 <chirpsalot> Like for instance all error messages should just be replaced with "I don't know god dammit, try sandboxing it?"
20:09:13 <rfw> Ralith: i see, but really it's just jiggling a bunch of pointers right and not having to copy the entire structure
20:09:16 <dmj`> GeraldCode: it includes auth, cookie based sessions, many different backends are supported, lots of snaplets to choose from
20:09:22 <dmj`> GeraldCode: it's pretty full featured
20:09:37 <GeraldCode> ok ok...maybe I didnt get deep enough into it
20:09:47 <Ralith> rfw: you didn't ask anything about copying at all...
20:09:47 <GeraldCode> I will grant you that
20:09:48 <dmj`> GeraldCode: yesod is similar in that regard, it's full featured
20:10:03 <GeraldCode> dmj, yesod has many issues
20:10:12 <GeraldCode> I admire the developers..they are much smarter than me
20:10:20 <dmj`> GeraldCode: lots of startups use yesod
20:10:35 <GeraldCode> but its not as easy to make a web sitein yesod in that as say .NET MVC or PHP Kohana, or Ruby
20:10:36 <GeraldCode> etc
20:10:57 <GeraldCode> dmj, but I dont understand why anyone would use that
20:11:10 <chirpsalot> That said, if you just need a static site Hakyll? Super good.
20:11:10 <GeraldCode> Maybe I am just dumb fro so many years of drinking
20:11:23 <GeraldCode> but I dont think yesod is worth anything
20:11:45 <dmj`> GeraldCode: Well haskell is a good choice for web programming in general. Modular, type safe, great concurrency, fast, that's true of any haskell web framework.
20:12:03 <GeraldCode> dmj, you get all of that with F# also
20:12:04 <rfw> Ralith: bear with me, i write C++ so when i need to copy things is the only thing on my mind
20:12:11 <MP2E> that's because the overhead of learning yesod seemed too great, i'm sure startups who have already traversed that have found that the learning curve was worth it
20:12:31 <rfw> what i'm asking is that if i write to a Map in a TVar, is it linear in cost over the size of the map or constant-ish
20:12:31 <MP2E> otherwise I don't see why anyone would use it :P
20:12:49 <GeraldCode> MP2E I get the feeling you would need programmers who began on functional platforms..like lisp
20:12:51 <GeraldCode> or scheme
20:13:01 <merijn> I think the big problem haskell web frameworks have is this: They try to be correct and being correct on the web is messy and hard
20:13:08 <Ralith> rfw: that's got nothing to do with whether it's in a TVar; you should refer to the documentation for the functions you're using to see their computational complexity.
20:13:10 <GeraldCode> I dont think the average programmer who has done OOP for 10 years will fit in there
20:13:33 <GeraldCode> merijin, thats an intersting point
20:13:36 <merijn> Popular frameworks in many other languages sacrifice correctness and sweep things under the rug, which means it looks much easier to get something done. And it probably is easier for the first 80-90%
20:13:50 <MP2E> for what it's worth, I learned C++ first and did oop for 10 years before coming to Haskell, and I've never looked back
20:13:53 <GeraldCode> you are right I think...I startded out doing windowed apps
20:13:58 <MP2E> frankly I wish I hadn't wasted my time for a decade
20:13:59 <GeraldCode> then switchs to the web
20:14:02 <merijn> But that last 10-20% percent is hell in other languages
20:14:04 <GeraldCode> its totally different game
20:14:07 <rfw> Ralith: i see, so writing to a TVar is essentially "free"?
20:14:16 <merijn> The last 10-20% is relatively easy in haskell :)
20:14:20 <rfw> bar the constant cost of actually writing to the TVar
20:14:22 * hackagebot ixset 1.0.6 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.6 (JeremyShaw)
20:14:59 <chirpsalot> "being correct on the web is messy and hard" <-- I don't think there's really such a thing as "correct on the web".
20:15:23 <Ralith> rfw: that depends on contention, of course
20:15:33 <platz> rfw: a TVars write don't cost more or less based on data size, but using STM does have some overhead
20:15:43 <rfw> platz: ah okay, thanks
20:16:07 <platz> but in an IO context, IO will dwarf time due to STM
20:16:09 <dmj`> GeraldCode: the real benefit of haskell comes in when you need to refactor. It's incredible
20:16:30 <rfw> yeah i'm not too fussed about the cost of STM since it should be fine in the general case
20:16:47 <c_wraith> platz: That's not true if there's contention on the STM value.  If there is, it gets *bad*.
20:16:51 <GeraldCode> dmj, I have studied a LOT of haskell, but Im still a beginner..please explain what you mean
20:17:16 <platz> c_wraith: of course - is that what you call a live lock?
20:17:33 <c_wraith> platz: no.  It does make progress.  It's more of a thundering herd
20:18:05 <c_wraith> platz: lots of transactions restarting concurrently, all demanding CPU time, all slowing it down even more as more transactions get thrown in.
20:18:11 <dmj`> GeraldCode: if you have 20k lines of code, and you need to make a large change, your compiler can either help you, or let you 'figure it out at runtime' (python). GHC will show you every spot your code breaks if you make a change. It's really nice.
20:18:54 <dmj`> GeraldCode: if the change is large enough, it will break your tests too, so there's no help there. Types are great.
20:19:20 <GeraldCode> dmj, are you talking abou type inference?
20:20:13 <c_wraith> GeraldCode: not inference - just checking
20:20:20 <Guest67142> So I'm trying to learn haskell... I got a nested list of lists of length 4 with numbers from 0..7, like [i | i <- concat rs ]... how do I even return a new list that has as index i += 1 at every iteration?
20:20:37 <dmj`> GeraldCode: what c_wraith said
20:20:44 <platz> c_wraith: a guy using STM in scala showed it was good enough to manage a connection pool running entirely in memory
20:20:52 <solatis> anyone here got any experience with control.monad.logger ?
20:20:58 <GeraldCode> ok
20:21:06 <solatis> its design seems to be, kind of complex
20:21:14 <GeraldCode> I asked because I think F# might do the same
20:21:20 <GeraldCode> I know I sound like a MS whore
20:21:26 <GeraldCode> I hated them for years
20:21:38 <GeraldCode> but now I have to work with their tech...so whatevs
20:21:58 <dmj`> GeraldCode: I started on C#, LINQ drove me to F#, F# to haskell. If you want to figure out computation expressions, you'll have to understand monads, so you might as well learn haskell
20:22:04 <c_wraith> platz: it depends on contention for TVars.  Good engineering lets you avoid contention, but you often need to do things like stripe resource pools to reduce it.
20:22:25 <GeraldCode> ok dmj
20:22:35 <GeraldCode> let me be clear, I think haskell is AWESOME
20:22:49 <GeraldCode> I just gave up trying to figure out how to make money out of it
20:22:51 <platz> c_wraith: hrm interesting - good info
20:23:03 <GeraldCode> haskell drove me to F#
20:23:46 <GeraldCode> So I look at it like this
20:24:13 <GeraldCode> I wan the best of both worlds....immutable types (when needed)..functions as first class objects (shorter, mre concise code) etc
20:24:23 <GeraldCode> AND I can still make money
20:25:23 <MP2E> right, but you were presenting it as though it were the irrevocable logical conclusion, and that's simple not true. It works for you, and I'm happy about that, but Haskell works for me and probably for many other people in this channel
20:25:29 <MP2E> so i'm not sure what response you're looking for
20:25:34 <dmj`> I'd put money down on the fact haskell has probably made more money than F#, its been around a lot longer for one
20:25:57 <GeraldCode> MP2E, Im not looking for anything..I am aorry if you are offended
20:26:03 <GeraldCode> I was just being jovial
20:26:03 <MP2E> i'm not offended, merely confused
20:26:21 <GeraldCode> MP2e, I was only looking maybe for downsides of F#
20:26:26 <MP2E> ah i see
20:26:27 <GeraldCode> I suppose
20:26:29 <MP2E> get the pros + cons
20:26:31 <MP2E> that makes sense
20:26:33 <dmj`> the CLR for one, closed source
20:27:15 <GeraldCode> true true
20:27:24 <GeraldCode> but MS has a lock for at least the next decade
20:27:46 <GeraldCode> actually though
20:27:51 <GeraldCode> F# is not OWNED by MS
20:27:58 <GeraldCode> I ead that somewhere
20:28:11 <GeraldCode> maybe I am mistaken..sounds like BS
20:28:24 <GeraldCode> but Mono isnt from MS
20:28:32 <solatis> probably in the same way C# isn't owned by microsoft
20:28:35 <GeraldCode> so this isnt owned by them...anyone can probably do this
20:28:38 <solatis> and java isn't owned by oracle
20:28:48 <orb_> GeraldCode, you want mutable variables (when needed).  Immutable is the default. ;o)
20:29:07 <GeraldCode> right orb! thats it, precisely
20:29:18 <GeraldCode> I want immutable by default..and I have to CHOOSE to mutate it
20:29:37 <orb_> GeraldCode, anyway, I had jobs doing Haskell for almost five years.
20:29:51 <GeraldCode> orb,  that is awesome
20:30:12 <GeraldCode> I tried to find a haskell job, figuring Id make six figureds..due to supply and demand
20:30:16 <GeraldCode> couldnt find one
20:30:26 <GeraldCode> Could you tell a bit about that please? :)
20:30:49 <orb_> Standard Chartered paid six figures.
20:31:03 <orb_> In USD.
20:31:18 <GeraldCode> nice..sounds like a bank ?
20:31:28 <orb_> Also, you gotta work with dons.
20:31:33 <orb_> (Don Stewart.)
20:31:42 <orb_> And a few other smart people.
20:31:50 <orb_> Yes, Standard Chartered Bank.
20:32:03 <orb_> I left, because Google wanted to pay me more.  (Not for Haskell, alas.)
20:32:14 <GeraldCode> ah lucky lad
20:32:20 <GeraldCode> im too old, google will never hire me
20:32:37 <GeraldCode> but I can still be the chief at small firms
20:33:10 <GeraldCode> orb, thanks for that info
20:33:16 <GeraldCode> I appreciate that, man
20:34:14 <dmj`> orb_: was going from haskell to C++/java/python hard?
20:34:24 <platz> orb_: your dons number is 1
20:35:36 <dmj`> GeraldCode: have you thought about starting your own company?
20:35:49 <thetrav> so I've been playing around with scotty-web, I'm trying to grok the json function: http://hackage.haskell.org/package/scotty-0.4.0/docs/Web-Scotty.html#g:7
20:36:00 <GeraldCode> dmj, yeah I have...:) I was doing consulting a while back...
20:36:20 <GeraldCode> But like many of the people here, I just am not that great with the day to day management of people
20:36:23 <thetrav> the basic examples show me how to use a do block to render a response
20:36:41 <GeraldCode> I am fine with people that I trust
20:36:45 <GeraldCode> that I like
20:36:52 <solatis> bah, why do all the logging libraries in haskell suck
20:36:55 <GeraldCode> but hiring strangers to work for me...thats not so great
20:36:55 <thetrav> however I can't figure out how to use the json function given the type signature
20:37:05 <thetrav> is it just the last line of the do block?
20:37:42 <orb_> dmj`, I do Haskell in my 20% project and free time ,now.
20:37:45 <GeraldCode> dmj, ive done it before
20:37:50 <GeraldCode> and it is really not fun
20:38:09 <platz> thetrav: some examples https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
20:38:12 <dmj`> orb_: wasn't aware google still had that, cool. Can I ask what your project is? Is it open source?
20:38:20 <GeraldCode> I dont suggest you ever start a business unless you have an operations manager who is essentially a seargent-at-armas to handle the personel
20:38:40 <orb_> dmj`, in my freetime I work on porting redgrep at the moment.
20:39:11 <orb_> my 20% project uses machine learning for image compression.  (Not sure if I'm allowed to say more without consulting Google about that.)
20:39:18 <GeraldCode> But maybe you are totally different from me, dmj`
20:39:23 * hackagebot hcg-minus 0.15 - haskell cg (minus)  http://hackage.haskell.org/package/hcg-minus-0.15 (RohanDrape)
20:39:26 <thetrav> thanks platz
20:39:30 <GeraldCode> IF you like people and trust them, you SHOULD start a business
20:39:31 <GeraldCode> NOW
20:39:38 <GeraldCode> dont work for anyone.
20:39:44 <orb_> dmj`, 20% time is alive and well.  But you have to step up and take it.  Nobody will shove it in your face.
20:39:52 <orb_> GeraldCode, why?
20:40:03 <orb_> Google pays well for little work, and takes most of the risk.
20:40:07 <platz> it looks like a stateful action in the monad - so it could be the last line, but you could do other stateful actions (in this "action") like setting the status code
20:40:28 <GeraldCode> orb_, because business ownes are the nobels of America
20:40:36 <orb_> GeraldCode, what do I care about America?
20:40:41 <GeraldCode> They get government perks
20:40:42 <GeraldCode> etc
20:41:01 <GeraldCode> I think that is what any smart person  should strive for.
20:41:12 <dmj`> GeraldCode: what about a SaaS product done in Haskell for a niche market with deep pockets. Keep the personnel very low.
20:41:18 <GeraldCode> orb_, oh sorry, I forget we arent all american
20:41:47 <GeraldCode> ok guys, I see what just happened
20:41:52 <GeraldCode> I sounded like a dumb American
20:41:56 <GeraldCode> I get it
20:42:24 <dmj`> GeraldCode: I didn't get that impression
20:42:39 <dfeuer> orb_, Kim-Ee Yeoh came up with another nice expression of isSuffixOf, using the Maybe monad.
20:42:53 <dfeuer> After Milan Straka's previous nice one.
20:42:59 <dfeuer> Lots of good things.
20:43:00 <orb_> GeraldCode, no worries.
20:43:21 <orb_> dfeuer, yeah, I saw that Milan's one on phabricator.
20:43:26 <GeraldCode> dmj`  You gotta have really smart programmers
20:43:31 <GeraldCode> I have been a pro for a while
20:43:45 <GeraldCode> And when I started..everyone was light years smarter than me
20:44:00 <hughfdjackson> I'm not convinced that (using) haskell requires very smart programmers - or any smarter than any other language
20:44:04 <dfeuer> orb_, yeah, but Kim-Ee thinks it's too hard to understand, and while I disagree, I'm happy to settle for another one that's just as good.
20:44:05 <GeraldCode> now its the opposite..and that just isn't because I have gotten better
20:44:12 <orb_> hughfdjackson, haskell lets me get away with being dumber.
20:44:20 <dmj`> orb_: hit that nail on the head
20:44:20 <orb_> hughfdjackson, the compiler does more work for me.
20:44:23 * hackagebot hcg-minus-cairo 0.15 - haskell cg (minus) (cairo rendering)  http://hackage.haskell.org/package/hcg-minus-cairo-0.15 (RohanDrape)
20:44:23 <dmj`> hit the*
20:44:25 * hackagebot hmt-diagrams 0.15 - Haskell Music Theory Diagrams  http://hackage.haskell.org/package/hmt-diagrams-0.15 (RohanDrape)
20:44:30 <orb_> Compile ghc and quickcheck, and I can program drunk.
20:44:35 <hughfdjackson> but it's sufficiently different than most other languages that, if you had learnt another language first, haskell feels like learning to program over again
20:44:40 <hughfdjackson> it's definitely felt that way to me
20:44:56 <orb_> I'm teaching Haskell (as a sort-of first language) to my girlfriend.
20:44:58 <hughfdjackson> :/ going to try to convince some of my colleagues of that soon
20:45:13 <dfeuer> hughfdjackson, it's like learning to drive without shoes. It takes a bit of getting used to, but then you have a tremendous amount more trouble trying to go back.
20:45:20 <dmj`> To program in Haskell you have to accept that the compiler knows better than you do
20:45:21 <orb_> hughfdjackson, what are they doing now?
20:45:32 <hughfdjackson> orb_: scala + javascript
20:45:34 <jxv> GeraldCode, when I program in other langs (especially dynamic langs), I'm constantly reminded how terrible my short term memory can be.
20:45:36 <GeraldCode> dmj` no  I disageer
20:45:37 <cschneid> I have a `Word160` which is made up of Word32s.  I want to put that into a bytestring, so I need [Word8]. How do I deal with sizes of word types? (https://hackage.haskell.org/package/Crypto-4.2.0/docs/Data-Digest-SHA1.html for the original type)
20:45:39 <dfeuer> The compiler *sometimes* knows better than you do. Sometimes not so much.
20:45:48 <orb_> hughfdjackson, get a scala or javascript port of quickcheck, and introduce that to them first.
20:45:58 <GeraldCode> the essence of programming in haskell is accepting that you must use monads to do things that were simple in other languages
20:46:11 <hughfdjackson> orb_: there's no decent js quickcheck -.- at least, last i looked
20:46:22 <GeraldCode> jxv, oh that makes sense
20:46:26 <hughfdjackson> :) perhaps there is for scala
20:46:27 <orb_> dfeuer, it often knows better than the distracted version of me.  The magic is that the compiler doesn't get tired or distracted.
20:46:29 <dfeuer> For example, it will produce really ugly code for  if isHexDigit x then Just(digitToInt x) else Nothing
20:46:32 <dmj`> computers never make mistakes, humans do, type systems protect the system from the illogical reasoning of the human.
20:46:57 <orb_> hughfdjackson, make one.  Either from scratch or polish.  Shouldn't be too hard to make something to awe people?  Javascript is decent enough.
20:47:12 <hughfdjackson> i had tried in the past
20:47:25 <dfeuer> My computer makes mistakes. It turns itself off at random :-(
20:47:26 <orb_> hughfdjackson, what result?
20:47:48 <orb_> dmj`, type systems ain't perfect.  (But pretty good in practice.0
20:48:03 <dfeuer> GeraldCode, mutation is not so easy to manage in languages like Java.
20:48:05 <hughfdjackson> orb_: it's a lot less elegant to use when you don't have types
20:48:22 <dfeuer> Working without types is pretty painful.
20:48:24 <orb_> hughfdjackson, yes, I saw that one.  But instead of just using arbitrary, you use arbitraryInt or so?
20:48:31 * dmj` tones down the zealotry :P
20:48:32 <GeraldCode> I agree mutation is somewhat bad..that is the NUMBER ONE reason that attracted me to functiona llanguages
20:48:40 <hughfdjackson> orb_: yea, that's essentially what you have to do - it could be worse
20:48:48 <GeraldCode> I want to make SAFE code
20:48:50 <orb_> Not much worse than using newtypes for getting NonEmptyList-s.
20:48:59 <hughfdjackson> there's also a *lot* of code in the wild (less at my work than elsewhere, thankfully) that is mutation-centric
20:49:01 <GeraldCode> I have no interest in convincing people I am smart
20:49:05 <GeraldCode> I just want to do good work
20:49:09 <GeraldCode> so I came to functional
20:49:18 <GeraldCode> I started at Haskell
20:49:21 <hughfdjackson> which makes idiomatic quickcheck properties a lot less elegant to show
20:49:23 <GeraldCode> then to Erlang (which I love)
20:49:23 * hackagebot html-minimalist 0.15 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.15 (RohanDrape)
20:49:28 <GeraldCode> and settled on F#
20:49:40 <dfeuer> Confining mutation makes it a lot easier for me to keep track of what my code is about. With mutation I have to keep going and digging through some other function in some other module to see wtf I have to watch out for.
20:50:15 <GeraldCode> (I went back to haskell several tikmes..because I thought it was L33t)
20:50:31 <orb_> dfeuer, also, lots of mutation heavy code has hidden dependencies.  Ie call function a before b, and remember to close with c afterwards.
20:50:35 <hughfdjackson> function(list){ return reverse(reverse(list)).should.equal(list) } <- doesn't prove much of anything
20:50:57 <orb_> hughfdjackson, in Python they use default arguments and inspection for quickcheck.
20:51:00 <hughfdjackson> reverse could pop two things off of the list and return it, and the property would 'hold'
20:51:19 <GeraldCode> dfeuer,  of coure man :)
20:51:33 <orb_> def prop_reverse(l = arbList(arbInt)): return reversed(reversed(l)) == l
20:51:37 <GeraldCode> limiting mutation is the best thing to happen to me in my whole career
20:51:47 <GeraldCode> I wish I had started oyt thinking this way
20:51:48 <orb_> Seems reasonable to read to me (if somewhat dirty).
20:51:52 <GeraldCode> instead of the OOP way
20:51:59 <orb_> Can you do something similar in JS?
20:52:03 <GeraldCode> even though F# is OOP also
20:52:12 <hughfdjackson> orb_: not until the next version ;-;
20:52:30 <orb_> GeraldCode, C++ people (like Carmack) have come around to limiting mutations, too.  Very uplifting to see the mainstream adopt this, too.
20:52:50 <orb_> hughfdjackson, ok.
20:52:54 <GeraldCode> orb_, it almost feels like we are evangelists :)
20:53:14 <orb_> GeraldCode, we sound like that to other people.
20:53:19 <orb_> hughfdjackson, what about http://www.purescript.org/posts/QuickCheck/ ?
20:53:35 <orb_> Oh, that's purescript, actually.
20:53:38 <hughfdjackson> but you can HOF it - `var reverseProp = check([Arb.List(Arb.a)], function(list){ reverse(reverse(list)).should.eql(list) })`
20:53:56 <jxv> GeraldCode, I don't think OOP is bad. But using it everywhere including data transformations (without IO) then it's unneccessary.
20:53:59 <hughfdjackson> orb_: yea - purescript would be a harder sell than haskell, i think ;)
20:54:18 <GeraldCode> jxv, you are right, its not bad
20:54:20 <jxv> s/ data/ with data
20:54:22 <dfeuer> It seems that as far as "academic" languages go, Haskell and Scheme have made unusually significant contributions to the outside world.
20:54:25 <solatis> hughfdjackson: i'm actually quite sharmed by purescript
20:54:36 <solatis> ehr
20:54:39 <solatis> charmed
20:54:43 <GeraldCode> and what I learned with f# is that even objects dont have to be mutable (seems obvious)
20:54:48 <GeraldCode> but I didt get that at first
20:54:50 <orb_> hughfdjackson, why harder?
20:55:07 <GeraldCode> So where I work
20:55:17 <GeraldCode> most of the code is actually in Classic ASP
20:55:19 <solatis> i think purescript would be easier to sell, imho, because of the interop with the existing javascript ecosystem
20:55:20 <hughfdjackson> orb_: with haskell, i can sell a large, well integrated ecosystem of modules, example code, existing experience, this chatroom, etc
20:55:31 <GeraldCode> so I have had to v beg and plead to do other stuff
20:55:39 <GeraldCode> and I finally got an upgradfe
20:56:13 <hughfdjackson> orb_: with purescript, i'm selling yet another compile-to-js language, used by a niche (comparatively), that a lot of the strangeness of haskell
20:56:17 <solatis> hughfdjackson: at my work, we consider javascript and the JVM the core points of communication -- what language you want to use for your project is up to you
20:56:45 <solatis> so in essense you're just using javascript
20:57:10 <hughfdjackson> solatis: javascript interop isn't as attractive to me in a sense
20:57:24 <solatis> why not?
20:57:40 <solatis> you can use the ecosystem
20:57:49 <hughfdjackson> because a lot of it is mutating, or at least mutable, which leads to quite a hostile world to interop with from within a more functional program
20:57:51 <GeraldCode> Node.js isnt mature right?
20:57:58 <dmj`> haskell is a hard sell as it is. Talked with a CEO today and he was like, "what if you build everything in haskell and then leave?" ..sorta has a point..
20:58:00 <GeraldCode> its not even at 1.0
20:58:21 <hughfdjackson> GeraldCode: it's not, but we've been running it in production for 2 years
20:58:27 <hughfdjackson> it's gone pretty well
20:58:30 <GeraldCode> dmj, dude, haskell would be IMPOSSSIBLE to sell my boss
20:58:37 <hughfdjackson> maturity is much more than a number, though ;)
20:58:40 <Ralith> dmj`: "then you'll find there exists a large population of skilled developers who would very much like to have a job writing haskell"
20:58:43 <Ralith> :p
20:58:44 <GeraldCode> There areZERO competent haskell developers here
20:58:49 <solatis> it's not stabe as in 'the interface might change'-stable
20:58:51 <dmj`> Ralith: you also have a point :)
20:59:03 <GeraldCode> hughfdjackson,  true
20:59:08 <solatis> but it's stable as in 'your code will not randomly crash'
20:59:15 <hughfdjackson> solatis: exactly
20:59:25 <dmj`> Ralith: This same guy was like, "Who uses it?" I was like.. facebook
20:59:33 <Ralith> nice
20:59:45 <hughfdjackson> and mature in the sense that there are lots of devs for it, answering common questions, making and maintaining libraries
20:59:47 <solatis> dmj`: i'm so glad i'm allowed to write clojure at work
20:59:52 <hughfdjackson> that are idiomatic to node.js
20:59:52 <GeraldCode> facebiook using everyting though
20:59:57 <GeraldCode> they use scala, php
20:59:58 <solatis> the alternatives were java or scala
20:59:59 <GeraldCode> what else
21:00:10 <GeraldCode> they are a laboratory
21:00:42 <dmj`> solatis: if you use clojure, you could probably sell them on haskell
21:00:52 <solatis> they will probably come up with php++ in the near future, with backwords compatibility with php, but now with a whole template-based metaprogramming language around php
21:01:03 <GeraldCode> solatis,  they alreay did!
21:01:14 <GeraldCode> They made their own PHP that has strict type checking
21:01:30 <solatis> oh god
21:01:31 <GeraldCode> Let me find the  link..
21:01:43 <luite> dmj`: you could argue that types make it easier for new hires to get started with a new big codebase, and they don't get outdated as quickly as docs (and if you have both you just use them as a means to verify that the docs are still correct)
21:02:22 <solatis> dmj`: i believe jvm interop with haskell is not as good as with scala/clojure, tho?
21:02:38 <GeraldCode> solatis, http://developers.slashdot.org/story/14/03/20/1924211/facebook-introduces-hack-statically-typed-php
21:02:39 <solatis> anyway, the whole data scientists team were already using clojure
21:02:42 <hughfdjackson> luite: if it takes any hires another 2-3 months to be able to read the type system's entrails, that might not be such a big selling point ;D
21:02:49 <Ralith> eh
21:02:57 <Ralith> takes a new hire almost that long to be productive anyway
21:03:22 <dmj`> luite: yes, all true
21:03:25 <hughfdjackson> Ralith: eh - we get people committing on the first day most of the time, and genuinely contributing in about 2 weeks
21:03:28 * Axman6 is a new hier and is so productive
21:03:33 <dmj`> solatis: http / tcp works well. why not communicate via protocols
21:03:34 <Axman6> fire too
21:03:40 <Axman6> hire as well also too
21:04:09 <Ralith> a productive new fire
21:04:13 <Ralith> always a good thing
21:04:21 <hughfdjackson> Ralith: to build up a bank of *really* useful domain knowledge - where people start looking to you for answers - probably about 2 months
21:04:23 <Axman6> there is much smoke
21:05:56 <GeraldCode> of course I meant "static" as oppesed to "strict"
21:06:11 <GeraldCode> because of course a battle worn dev like would no the difference :)
21:06:43 <GeraldCode> know even :)
21:14:11 <thetrav> so I'm still having trouble grokking the do notation
21:14:25 <thetrav> sqlite-simple had open and close operations
21:14:46 <thetrav> if I want to open a connection, read a row, close the connection and have the function resolve as an IO String
21:14:56 <thetrav> how do I do that?
21:15:13 <thetrav> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful speaks about the lines not determining execution order
21:15:32 <thetrav> however I really did think that was what do notation was for
21:17:04 <dibblego> thetrav: do-notation is just a syntax improvement for function calls
21:17:45 <Ralith> "improvement"
21:18:20 <dibblego> do c <- openConnection; r <- readRow c; closeConnection c; return r -- first approximation
21:18:36 <thetrav> there's a return keywork in haskell?
21:18:47 <dibblego> thetrav: no, it is a function, like all other functions
21:18:57 <Ralith> you should use 'pure' instead
21:18:57 <dibblego> it just happens to be spelled similar to a keyword in other languages
21:19:12 <Ralith> it does the same thing but is less stupidly named and works with more types
21:19:36 <thetrav> ahh right
21:19:46 <thetrav> I saw pure
21:19:48 <hughfdjackson> Ralith: rebel ;)
21:19:49 <orb_> thetrav, you probably want bracket for your particular example.
21:19:52 <thetrav> that one makes sense
21:20:07 <dibblego> what orb_ said it the next approximation
21:20:10 <dibblego> s/it/is
21:20:11 <CARAM> so I got a list of many nothings and a single just, how should I get the just?
21:20:20 <Axman6> @hoogle bracket
21:20:22 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:20:22 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:20:22 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:20:30 <dibblego> CARAM: how can you be sure? use find in any case
21:20:44 <dibblego> @type find isJust
21:20:48 <lambdabot> [Maybe a] -> Maybe (Maybe a)
21:20:53 <orb_> thetrav, bracket is harder to accidentally screw up, and deals with exceptions, too.
21:21:07 <Axman6> bracket open close action opens a resource with open, runs an action onm the resource, and ensures that close is called whether there's an exception in the action or not
21:21:15 <CARAM> dibblego: thanks!
21:21:17 <hughfdjackson> 'whatcha got for me, find isJust?' 'ah, Just Nothing, man'
21:21:18 <orb_> and return the result of that action.
21:21:58 <Axman6> you'll never get Just Nothing with find isJust though ;)
21:22:06 <thetrav> is bracket part of the standard haskell library?  or part of sqlite-simple or part of something else?
21:22:09 <dibblego> @type join . find isJust
21:22:11 <lambdabot> [Maybe a] -> Maybe a
21:22:19 <hughfdjackson> Axman6: good point ;)
21:22:38 <Axman6> thetrav: it's from Control.Exception in base, which ships with ghc
21:22:44 <hughfdjackson> dibblego: beat me to it while i was doing my ghci sanity check ;D
21:22:45 <thetrav> thanks
21:24:40 <dibblego> thetrav: do-notation is what scala calls for-comprehension in principle, however, there are some other differences on top
21:25:17 <thetrav> I had worked that much out dibblego, but thanks for the confirmation.  Still very early haskell days for me
21:25:32 <dibblego> (>>=) is what scala calls flatMap
21:27:38 <thetrav> looking at the link posted earlier https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html and some reading on liftIO  Does it only transform from IO => Maybe ? Or is that somehow implied by context?
21:28:16 <dibblego> it transforms IO to Something, including Maybe
21:29:18 <hughfdjackson> thetrav: liftIO is defind in the MonadIO typeclas
21:29:20 <hughfdjackson> *typeclass
21:29:23 <hughfdjackson> so anything that implements that
21:29:27 <hughfdjackson> you can use liftIO in
21:29:30 <Axman6> it lets you embed IO actions in things which are an instance of MonadIO (generally monad transformers on top of IO like EitherT e IO a or whatever; liftIO would be IO a -> EitherT e IO a in that case)
21:30:00 <Axman6> but I don't believe that liftIO transforms IO into Maybe...
21:30:50 <dibblego> oh yeah, Maybe is not an instance
21:31:01 <dibblego> it transforms IO to Something, including Maybe if it were an instance, which it isn't and cannot be
21:31:28 <thetrav> then I'm confused
21:31:30 <Axman6> liftIO _ = Northing :: IO a -> Maybe a =)
21:31:56 <thetrav> the link does a liftIO on a String -> Maybe String function
21:32:04 <dibblego> Axman6: it has laws
21:32:10 <thetrav> then a case on the result Just or Nothing
21:32:10 <dibblego> thetrav: where?
21:32:17 <thetrav> https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
21:32:25 <dibblego> where exactly in that post?
21:32:40 <thetrav> Finally, we add a bit more exception handling to the register action
21:32:47 <thetrav> code block below that
21:32:58 <dibblego> look at this Scala
21:33:02 <hughfdjackson> thetrav: i *think* you'll find that registerInterest :: String -> IO (Maybe String)
21:33:04 <dibblego> for { register <- Some(7)
21:33:08 <dibblego> what is the type of register?
21:33:19 <thetrav> Int
21:33:24 <dibblego> what is the type of Some(7)?
21:33:25 <hughfdjackson> so `liftIO` in `registered <- liftIO (registerInterest emailAddress)
21:33:38 <trap_exit> :t Some 7
21:33:39 <lambdabot> Not in scope: data constructor ‘Some’
21:33:44 <dibblego> Option[Int]
21:33:44 <trap_exit> What is Some ?
21:33:51 <hughfdjackson> lets you embed the IO action, then extract `Maybe` from that IO
21:33:53 <dibblego> trap_exit: Some ~ Just
21:33:55 <merijn> trap_exit: Just in Ocaml/F#
21:34:13 <trap_exit> gentlemen, I have found an ocaml spy
21:34:15 <hughfdjackson> as you can see in the lines after that, where it pattern matches on the Maybe that you've just unwrapped from its IO context
21:34:16 <trap_exit> what should we do?
21:34:22 * hughfdjackson hopes that made some sort of sense
21:34:25 * hackagebot hsbencher 1.14 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.14 (RyanNewton)
21:34:35 <dibblego> thetrav: the Maybe value has been lifted into IO, then sequences in do-notation; the result of applying liftIO is an IO action of Maybe Something; the type of (registered) is Maybe Something
21:34:38 <hughfdjackson> (basically, it's ActionM on which liftIO is defined - not Maybe)
21:34:39 <trap_exit> merijn: are you entpreneurial ?
21:34:46 <Axman6> trap_exit: ignore any attempts to communicate until they've seen the light; they always see the light
21:35:02 <trap_exit> merijn: if you ever do a haskell startup, I'd like to be contacted when you guys are hiring engineers
21:35:14 <trap_exit> Axman6: yeah, took me many years to see Haskell
21:35:22 <trap_exit> until I realized "oh shit, you mean these errors can e detected by the compiler?"
21:35:33 <thetrav> ok, so I did indeed misrepresent it initially
21:35:40 <thetrav> there's not a String -> Maybe String
21:35:46 <thetrav> it's String -> IO Maybe String
21:35:53 <prinsen> In Parsec, does try need to be added to every parser the whole way down? try (p1) <|> try (p2) fails while the other order works which seems odd
21:35:54 <dibblego> IO (Maybe String)
21:36:07 <thetrav> right, sorry, still not strong on the parens
21:36:12 <merijn> prinsen: Don't insert too many tries
21:36:26 <thetrav> so when you apply liftIO to IO(Maybe String) what do you get back?
21:36:30 <merijn> prinsen: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
21:36:36 <dibblego> thetrav: the space character always associates to the left
21:36:37 <prinsen> merijn: sure, but with try the order shouldnt matter right?
21:36:44 <dmj`> merijn: beat me to it
21:36:49 <dibblego> thetrav: liftIO is applied to a Maybe String, which gives back a IO (Maybe String)
21:36:55 <merijn> prinsen: If you write code like that, your parse errors will suck
21:37:13 <hughfdjackson> prinsen: you 'need' to insert a try when a parser would consume input then fail, and you need to backtrack the cursor where it was before you tried parsing at all
21:37:22 <thetrav> ….
21:37:23 <prinsen> merijn: they do indeed. Im have a compiling but buggy parser of ECMA-262
21:37:39 <thetrav> so I'm pretty sure I'm misreading the example then
21:37:46 <dibblego> thetrav: sorry, that is not true; try again. liftIO is applied to a IO String, which gives back a ActionM String
21:37:50 <prinsen> hughfdjackson: sure, so the order should not matter
21:37:51 <hughfdjackson> but as merijn said, there's another way to factor out blocks that require try to get better error messages
21:38:05 <thetrav> example has: "I’ll assume that we’ve been given aregisterInterest :: String -> IO (Maybe String) function by someone else in the team."
21:38:08 <hughfdjackson> prinsen: now you say it... yes, the order shouldn't matter
21:38:11 <prinsen> but try (p1) <|> try (p2) fails while try (p2) <|> try (p1) successds
21:38:14 <merijn> prinsen: Read the blog post I just linked
21:38:17 <thetrav> code block has: "registered <- liftIO (registerInterest emailAddress)"
21:38:26 <prinsen> merijn: yes sec
21:38:39 <thetrav> the bit inside the paren is the bit I read first
21:38:41 <merijn> prinsen: Probably p1 is broken internally
21:38:50 <thetrav> which looks like it should turn into IO (Maybe String)
21:39:15 <thetrav> emailAddress is a String
21:39:26 * hackagebot hsbencher 1.14.1 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.14.1 (RyanNewton)
21:39:43 <prinsen> merijn: how could it be broken?
21:40:11 <dibblego> thetrav: (registerInterest emailAddress) is a IO Something, that much is true; the call to liftIO then turns it into Whatever Something and Whatever depends on which monad you are running and the answer is, ActionM
21:40:34 <thetrav> ahhhhhh
21:40:42 <thetrav> this helps me greatly
21:41:01 <hughfdjackson> dibblego: thanks for saying that more lucidly than i did :|
21:41:22 <thetrav> so it changes it from IO (Maybe String) to ActionM (Maybe String), or perhaps some other monad, but ActionM will have an implementation of liftIO that describes that
21:42:00 <dibblego> correct
21:42:07 <dibblego> somewhere there is: instance MonadIO ActionM where 
21:42:27 <thetrav> it uses deriving I think…
21:42:32 <prinsen> merijn: http://lpaste.net/112676
21:42:42 <thetrav> http://hackage.haskell.org/package/scotty-0.4.0/docs/src/Web-Scotty-Types.html#ActionM
21:42:57 <prinsen> merijn: is that a to direct translation of the grammar?
21:43:03 <thetrav> which I would assume means "I'm a monad, lift it to me"
21:43:05 <thetrav> or something similar
21:43:19 <dibblego> thetrav: it gives you liftIO :: IO a -> ActionM a
21:43:51 <thetrav> right
21:43:55 <dibblego> as we know, you cannot get the (a) out of (IO a), but you can morph to (SomethingElse a) for various values of SomethingElse (ActionM is one of those, Maybe is not)
21:44:10 <thetrav> yep
21:44:25 <thetrav> I actually didn't fully grok that morph thing
21:44:29 <thetrav> it's a lot clearer now
21:44:36 <thetrav> thank you for the assistance
21:44:42 <dibblego> np
21:47:18 <orb_> dibblego, and if the only reason you'd want to get the a out of IO a is, too apply a to some function a -> b, then fmap is your friend.
21:48:00 <dibblego> there are all kinds of things that someone actually wants to do when they incorrectly believe they (want to get the (a) out of the (IO a))
21:49:27 <thetrav> http://lpaste.net/112677 <- is where I'm up to so far… it's currently telling me that liftIO is not in scope
21:49:38 <prinsen> merijn: ?
21:49:50 <dibblego> import Control.Monad.IO.Class
21:50:03 <thetrav> thanks
21:50:26 <CrazyM4n> Why would you use liftIO over liftM?
21:50:46 <dfeuer> CrazyM4n, because IO is weird.
21:50:53 <dibblego> liftM does not alter the monad context in which one is operating
21:50:54 <merijn> prinsen: No idea what any of those other parsers do
21:50:56 <thetrav> because I'm new and have only discovered the former
21:50:57 <CrazyM4n> sounds good :P
21:51:01 <dfeuer> > :t liftM
21:51:06 <lambdabot>  mueval-core: Time limit exceeded
21:51:09 <dfeuer> :t liftM
21:51:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:51:18 <dfeuer> :t liftIO
21:51:19 <lambdabot> MonadIO m => IO a -> m a
21:51:27 <dfeuer> That look different.
21:51:32 <jxv> :t liftM id
21:51:33 <CrazyM4n> I see
21:51:33 <lambdabot> Monad m => m r -> m r
21:51:46 <dfeuer> An' it BE different.
21:52:01 <jxv> Different moonads
21:53:22 <prinsen> merijn: they consume some input
21:53:56 <jxv> :t fmap
21:53:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:54:01 <jxv> :t liftM
21:54:02 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:54:22 <dfeuer> There's also the Prompt thing.
21:54:43 <thetrav> wooo, my program sort of kind of works now
21:55:04 <thetrav> in that it does what I've told it to do but I have not yet told it what I want properly :P
22:00:27 <hughfdjackson> are there any articles/explanations kicking around on why you can't retrofit Monads into Functors?
22:00:52 <hughfdjackson> naively, i would have expected `instance (Monad m) => Functor m where fmap = liftM` to work
22:00:57 <hughfdjackson> clearly, it doesn't ;)
22:01:01 <merijn> hughfdjackson: You can
22:01:13 <merijn> hughfdjackson: See WrappedMonad
22:01:38 <merijn> "instance Monad m => Functor (WrappedMonad m) where"
22:01:40 <orb_> hughfdjackson, liftM is fmap and vice verso.
22:02:05 <hughfdjackson> merijn: hrm - why does it require wrapping and unwrapping?
22:02:10 <orb_> hughfdjackson, it doesn't work without the wrapper, because => is not an if.
22:02:25 <orb_> a => b, doesn't mean if we have an instance for a, make an instance for b.
22:03:43 <hughfdjackson> orb_: looks like i have some googling to do :) cheers for the pointer
22:04:05 <dfeuer> hughfdjackson, now that Functor => Applicative => Monad, I don't think WrappedMonad is really worth thinking about so much anymore.
22:04:38 <hughfdjackson> dfeuer: you say 'now' - i thought that was still in discussion?
22:04:53 <dfeuer> Oh no, it will be in 7.10.1. No question at all.
22:05:17 <hughfdjackson> won't that be a breaking change? :/
22:05:20 <dfeuer> The warning was added in 7.8.3 to help everyone get ready for the change.
22:05:50 <dfeuer> Yup. But people have been wanting to do this for years.
22:06:18 <hughfdjackson> well, that's .. brave :) be interesting to see how it plays out
22:06:30 <frawgie> hughfdjackson: ghc produce warnings for that if i remember correctly so they will be easy to find, but yes.
22:06:55 <dfeuer> hughfdjackson, you may also want to look at the "Foldable/Traversable Bridge-Burning Proposal" that's also going into 7.10. It's not nearly as breaking, but it will surprise people.
22:08:06 <hughfdjackson> great :)
22:08:20 <hughfdjackson> are there any more of these breaking changes in the works?
22:09:27 * hackagebot hzulip 0.3.0.2 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.3.0.2 (yamadapc)
22:09:39 <dfeuer> Well, if I have my way, lazy IO will produce more errors!
22:12:02 <hughfdjackson> :) interesting - where's all of this discussed?
22:12:12 <hughfdjackson> i assume there's a mailing list?
22:13:09 <frawgie> hughfdjackson: keeping an eye on the haskell subreddit will keep you quite informed imo :)
22:13:32 <hughfdjackson> frawgie: ;) i guess i can't avoid reddit forever
22:14:08 <frawgie> hughfdjackson: all roads lead to reddit/rome :)
22:14:27 * hackagebot digestive-functors-heist 0.8.6.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.6.1 (JasperVanDerJeugt)
22:16:29 <Welkin> I never got into reddit
22:16:50 <Welkin> it looks like a less insane version of 4chan
22:17:06 <jle`> hughfdjackson: you can write a general Functor instance for all Monads, but then because of the way the typeclass system works, how would you say which Functor instance to use for, say, Maybe?
22:17:27 <hughfdjackson> jle`: that.. that's a great point
22:19:27 * hackagebot hzulip 0.3.0.3 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.3.0.3 (yamadapc)
22:34:28 * hackagebot redis 0.13.0.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.13.0.1 (GaneshSittampalam)
22:47:28 <DTSCode> hey guys! what are some tutorials you guys recommend?
22:47:51 <frawgie> depends on the topic :)
22:48:13 <DTSCode> well for haskell of course
22:48:43 <frawgie> DTSCode: http://learnyouahaskell.com/chapters this is usually a good starting point
22:48:53 <DTSCode> ok ty
22:49:14 <frawgie> after that you cna continue with real world haskell (reading it myself atm)
22:49:42 <hughfdjackson> for what it's worth, i really enjoyed the start of learn you a haskell
22:49:56 <hughfdjackson> but i didn't get to see enough application of haskell to actual problems
22:50:10 <hughfdjackson> so after about chapter 7, i picked up real world haskell and read them side by side
22:50:14 <hughfdjackson> that worked really nicely for me :)
22:52:33 <orb_> hughfdjackson, Programming in Haskell is also good for the first few chapters, if a bit dated by now.
22:52:49 <orb_> It's a shame lyah doesn't have exercises.
23:07:18 <solatis> ok, is there anyone in this channel available to hold my hand while handling these multiple layers of monads i'm currently in?
23:07:24 <lpaste> solatis pasted “Adding Control.Monad.Logger monad around ZMQ code” at http://lpaste.net/112679
23:07:33 <solatis> look at that pastie
23:08:00 <solatis> I believe my solution actually needs to be instance MonadLogger ZMQ z where ... {}, or am I wrong in thinking that?
23:08:11 <trap_exit> so I'm writing my own langauge, which is a subset of Haskell (with slightly different semantics). Instead of trying to roll my own parsec parser (and deal with white space parsing), I'd like to just hijack GHC ... is there a tutorial on how to do this? I'd like a tutorial which tells me how to feed ghc a *.hs file, and get the AST
23:09:06 <trap_exit> merijn: ^
23:10:33 <solatis> would i have to write something like this? https://github.com/joelteon/melvin/blob/master/src/Melvin/Internal/Orphans.hs
23:11:37 <Axman6> solatis: hmm, I'm having a look into it, it seems quite odd seeing things like "instance MonadLogger IO          where monadLoggerLog _ _ _ = return ()" in https://hackage.haskell.org/package/monad-logger-0.2.0/docs/src/Control-Monad-Logger.html#monadLoggerLog though
23:12:27 <solatis> Axman6: yeah i have no idea what to make of it
23:12:34 <Axman6> me either o.O
23:13:00 <solatis> https://github.com/kazu-yamamoto/logger/blob/master/monad-logger/Control/Monad/Logger.hs#L183
23:13:07 <Axman6> maybe try adding instance MonadLogger (ZMQ z)          where monadLoggerLog _ _ _ = return ()
23:14:00 <Axman6> hmm, damnit google, no I did not want the oldest version of the package's documentation...
23:15:21 <solatis> Axman6: that doesn't seem to work
23:15:32 <solatis> instance MonadLogger m => MonadLogger (ZMQ z ()) where
23:15:34 <solatis>   monadLoggerLog _ _ _ = return ()
23:15:36 <solatis> that's what i have
23:15:39 <solatis> and ghc complains:
23:15:57 <solatis>     The first argument of ‘MonadLogger’ should have kind ‘* -> *’,
23:16:00 <solatis>       but ‘ZMQ z ()’ has kind ‘*’
23:16:10 <Axman6> no ()
23:16:18 <Axman6> you need (ZMQ z)
23:16:29 <Axman6> which is what GHC is telling you
23:17:13 <solatis> hmmm yeah
23:17:19 <Axman6> does that work?
23:17:41 <solatis>     Variable ‘m’ occurs more often than in the instance head
23:17:44 <solatis>       in the constraint: MonadLogger m
23:17:46 <solatis>     (Use UndecidableInstances to permit this)
23:18:30 <Axman6> no, you need just instance MonadLogger (ZMQ z) where ... (my mistake, I didn't even notice the class constraint)
23:18:48 <Axman6> "return ()
23:18:52 <Axman6> bleh
23:19:05 <Axman6> "instance MonadLogger (ZMQ z)          where monadLoggerLog _ _ _ = return ()" is what you want... I think!
23:19:15 <Axman6> it's not very clear, this module needs more docs
23:19:36 <solatis> tried that, but that results in
23:19:47 <solatis> src/Tomatoes/Crawler/Movie/Search/Parse.hs:16:26:
23:19:49 <solatis>     Couldn't match type ‘()’ with ‘ZMQ z ()’
23:19:54 <solatis>     Expected type: msg -> ZMQ z ()
23:19:54 <solatis>       Actual type: msg -> ()
23:20:05 <Axman6> where is that coming from?
23:20:08 <solatis> ah
23:20:15 <solatis>   monadLoggerLog _ _ _ = return ()
23:20:17 <solatis> that statement
23:20:22 <solatis> it probably expects a ZMQ monad
23:20:32 <solatis> so can i just lift it ?
23:20:38 <Axman6> I have no idea
23:20:55 <solatis> https://github.com/kazu-yamamoto/logger/blob/master/monad-logger/Control/Monad/Logger.hs#L182
23:21:03 <solatis> that is what they're doing
23:21:24 <Axman6> are you using $(logDebug) "This is a debug log message"?
23:21:31 <solatis> yeah
23:21:39 <Axman6> the brackets are needed I believe
23:22:27 <Axman6> try using logDebugNS
23:22:57 <Axman6> hmm, yeah this package seems l;ike a mess, I can't follow it
23:23:02 <solatis> ok
23:23:05 <solatis> then it was not me
23:23:24 <solatis> but it's part of the whole yesod framework
23:23:32 <solatis> but it seems to be more internal
23:23:53 <solatis> i figured i liked the TH-feature that automatically logs file/line number with log messages
23:24:39 <solatis> i don't like hslogger
23:24:52 <solatis> so that basicly leaves only fastlogger
23:25:03 <solatis> or maybe i should use something totally different
23:25:04 <Axman6> perhaps try asking in the yesod channel, someone there is more likely to know what's going on (like snoyberg if he's around)
23:25:05 <solatis> like Hood
23:25:23 <solatis> yeah there are 0 tutorials on control.monad.logger
23:25:45 <solatis> and if i search on github, it's basicly only used in combination with Yesod's Application.hs
23:26:00 <solatis> so no one seems to be using control.monad.logger standalone
23:26:05 <solatis> which is a shame, since it has potential
23:26:51 <Axman6> well, ask in the yesod channel, then blog about how it should be done =)
23:29:31 * hackagebot protobuf-native 1.0.0.1 - Protocol Buffers via C++  http://hackage.haskell.org/package/protobuf-native-1.0.0.1 (MaxwellSwadling)
23:31:04 <DTSCode> so is haskell really just a large collection of lambas?
23:31:18 <DTSCode> /s/lambas/lambdas/
23:32:27 <solatis> DTSCode: i always thought a lambda had to be unnamed
23:33:08 <mauke> DTSCode: we also have case/of
23:33:12 <DTSCode> not neccesarily
23:33:22 <DTSCode> about the unnamed thing
23:33:30 <DTSCode> ah ok mauke havent gotten that far yet
23:34:56 <DTSCode> auto square = [](int x) -> int { return x * x; }; std::cout<< square(4); in c++ that would be a named lambda
23:35:33 <mauke> let square = \x -> x * x in print (square 4)
23:39:31 * hackagebot hsc3-auditor 0.15 - Haskell SuperCollider Auditor  http://hackage.haskell.org/package/hsc3-auditor-0.15 (RohanDrape)
23:47:24 <kyun> haskell好多人聊，OCaml死一般靜
23:49:14 <frawgie> kyun: 英语
23:49:32 * hackagebot sc3-rdu 0.15 - Haskell bindings to sc3-rdu (sc3 rd ugens)  http://hackage.haskell.org/package/sc3-rdu-0.15 (RohanDrape)
23:50:03 <kyun> ……sorry
23:51:24 <kyun> I mistake haskell with haskell.tw
23:51:34 <frawgie> kyun: np, you gave me a chance to practice chinese :)
23:52:25 <DTSCode> "What if some mathematicians figured out that 2 is actually 3" i love this tutorial
23:53:52 <kyun> Oh， I thought you are Chinese, your Chinese is pretty good.
23:54:11 <kyun> frawgie: XD
23:56:04 <gigabytes> hi all
23:56:38 <gigabytes> the implementation of (>>=) for the list monad is usually explained as  l (>>=) f = concat (map f l)
23:56:54 <gigabytes> is that the true implementation? That would make it inefficient and strict, I suppose
23:57:06 <gigabytes> is it really in this way or it's only an exposition semplification?
23:57:15 <dfeuer> gigabytes, strict how? I think probably concatMap.
23:57:18 <dmj`> :t flip concatMap
23:57:19 <lambdabot> [a] -> (a -> [b]) -> [b]
23:57:55 <gigabytes> dfeuer: I mean do I have to wait for the entire list being built before starting to take the first element?
23:58:10 <dfeuer> No.
23:58:20 <dfeuer> Why would you?
23:58:46 <gigabytes> dfeuer: ok, I would have bet on it, but I saw an article on haskellwiki that put concat (map f l) as implementation, which would not be the same right?
23:59:24 <dmj`> gigabytes: haskell is lazy so you don't have to wait
23:59:24 <dfeuer> concat (map f l) is pretty much the same as concatMap f l, but probably optimized better.
23:59:49 <dmj`> > take 2 $ [1,2,3] >>= \x -> return (+1)
23:59:52 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
23:59:58 <dmj`> oops
