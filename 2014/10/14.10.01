00:03:56 <Heather> is there type for unsigned integer?
00:04:06 <trap_exit> anyone here find that haskell, compared to other languages
00:04:10 <trap_exit> require more focus to code?
00:04:24 <simpson> Heather: Data.Word contains several such types, with wraparound.
00:04:28 <trap_exit> i.e. I'm now routinely feeling that unless I'm wearing ear plugs and in a dark room with nothing but my screen, I can't comprehend some of the haskell code I have written
00:04:32 <Axman6> Heather: there isn't an unsigned version of Integer, but there are for Int, and Int8-Int64
00:04:36 <shachaf> But all of them are bounded.
00:05:02 <simpson> trap_exit: How many languages have you worked in? Also, how long have you been writing in Haskell?
00:05:10 <simpson> The feeling should pass eventually.
00:05:22 <trap_exit> I have programmed in C/C++, a little bit of ASM, quite a bit of clojure
00:05:26 <trap_exit> Haskell for about 6 months
00:05:40 <trap_exit> I'm feeling the ideal haskell environment is like wearing Occulus + ear plugs
00:05:41 <simpson> Give it some more time.
00:05:57 <simpson> My preferred environment is a whiteboard. I am weird though.
00:06:04 <merijn> after 6 months I could barely write real world code in haskell, now I can barely write real world code in anything else >.>
00:06:04 <trap_exit> perhaps I am just wriitng code that is bad in taht it requires I keep too many things in mind at once
00:06:13 <Heather> Axman6: simpson: I see, thanks
00:06:28 <trap_exit> merijn: can you write real world code in haskell right now, or can you not write real world code at all?
00:06:30 <simpson> Who knows? I'm a horrible programmer; I cannot keep more than a screen of stuff in my head at a time.
00:06:43 <trap_exit> I'd be happy to do a screen
00:06:53 <trap_exit> I think my brain starts barfing when I try to keep the types of more than 5 vars in my head
00:07:05 <trap_exit> i'm getting ot the point that anytime I write let, I'll add in a :: just so I can read it later on
00:07:22 <trap_exit> then, instead of using tuples, I use data all over the place, so when I pattern match / use <-, when I read the code, I'll know what data type it is
00:07:31 <merijn> trap_exit: All of my non-work coding and about 50-60% of my work programming (not counting this 100% C++ internship) is haskell
00:08:13 * hackagebot yesod-fay 0.6.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.6.0.1 (MichaelSnoyman)
00:08:13 * hackagebot XSaiga 1.0.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  http://hackage.haskell.org/package/XSaiga-1.0.0.0 (InBetweenNames)
00:08:34 <merijn> trap_exit: I write explicit signatures on all top-level declarations and most where/let clauses. Type inference is nice, but haskell without types is just like python. Unreadable 1 month after you write it
00:08:36 <trap_exit> merijn: you're an undergrad?
00:08:48 <merijn> trap_exit: phd
00:09:13 <tdammers> nah, python is still worse
00:09:27 <tdammers> haskell without types is still mostly sane
00:09:37 <merijn> tdammers: Yeah, with haskell I can at least ask ghci :)
00:10:02 <trap_exit> in dyanmic languages, asking about type can requires solving the halting problem
00:10:03 <tdammers> that, and you still can't introduce mutability through the back door without being noticed
00:10:03 <trap_exit> merijn: what's your area of study?
00:10:13 <simpson>  >>> type(someObject) # While I understand the need to feel superior, maybe you should learn Python before bashing it.
00:10:28 <Ralith> simpson: what does that give you for a function?
00:10:31 <tdammers> trap_exit: not at all. In dynamic languages, all variables have the same type
00:10:42 <tdammers> because there is only one type
00:10:52 <Ralith> simpson: speaking of learnings things before making statements :p
00:10:54 <tdammers> and it covers all possible values a variable can have
00:10:56 <trap_exit> simpson >> something like: x = 20; if ( prog xys halts ) { x = "hello world" } ; type of (x) ?
00:10:57 <simpson> Ralith: <type 'function'>, the type of functions.
00:11:02 <tdammers> therefor, asking for the type of something is trivial :D
00:11:14 <Ralith> simpson: yes, so it's worthless in most situations.
00:11:18 <trap_exit> merijn: what's your focus for your PhD studies ?
00:11:18 <merijn> trap_exit: graph analytics, big data fluff and manycore programming
00:11:21 <simpson> trap_exit: Depends on when you ask for it!
00:11:34 <simpson> Ralith: It is worthless but not for the reason that you are thinking of.
00:11:46 <tdammers> of course, Python using the name "type" for "tag" makes the matter somewhat confusing :x
00:11:53 <trap_exit> merijn: are you part of the programming langauge (let's parallellize haskell) or part of the statistics community ?
00:12:00 <Ralith> I expect it's worthless for many reasons including the one I'm thinking of
00:12:03 <Ralith> python's like that
00:12:15 <trap_exit> big data ranges from people doing GPGPU, asymptotics of algorithms, deep learning, etc ...
00:12:48 * trap_exit bets merijn, being so coy with area of study, is working on P vs NP
00:13:03 <merijn> trap_exit: I'm actually of the "try and come up with fast ways to implement graph algorithms" community, but only because no one in the programming language community was willing to pay me to hack haskell >.>
00:13:08 * hackagebot intervals 0.7.0.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.7.0.1 (EdwardKmett)
00:13:27 <trap_exit> merijn: spectral graph stuff? the new linear time algorithms?
00:13:52 <trap_exit> merijn: i.e. approximate solutions to classical algos, or are you trying to implement classical algos in a more parallelized way ?
00:14:02 <merijn> trap_exit: Working on distributed triangle counting now, the plan is to go from there in the direction of subgraph isomorphism
00:14:33 <merijn> No approximate stuff, that's too much statistics for me :)
00:14:56 <trap_exit> merijn: is fastest something like n^w, where w = constant for matrix mult ?
00:15:04 <trap_exit> you're totally on the theory side of things
00:16:49 <merijn> Pretty sure the fastest existing implementation is way slower than that
00:17:49 <trap_exit> hmm
00:17:51 <merijn> And matrix multiplication doesn't work for non-trivially sized graphs. (Well, depending on your point of view. You could argue sparse matrices are graphs and/or graphs are sparse matrices, etc. but that doesn't solve the problem of "how to implement this fast")
00:17:55 <trap_exit> I thought you could setup some weird boolean matrix mult
00:17:57 <trap_exit> then just add shit up
00:18:12 <trap_exit> oh
00:18:19 <trap_exit> you mean you care about the constants that O( ... ) hides ?
00:18:41 <merijn> trap_exit: I mean that the simple "boolean matrix" might not fit in your RAM :)
00:19:00 <merijn> Hell, the *sparse* boolean matrix might not fit in your RAM :)
00:19:09 <trap_exit> well
00:19:14 <trap_exit> suppose, hypothtically, you're facebook scale
00:19:20 <trap_exit> there's like what 7Bil people in the world?
00:19:25 <trap_exit> and each person realistically has maybe 100 friends
00:19:32 <trap_exit> so that's like 7 * 10^11
00:19:36 <trap_exit> which is like 700 GBs
00:19:45 <trap_exit> hmm; yeah, I only have 16 GB
00:20:02 <trap_exit> I think the right solution is "wait a few years; since RAM grows faster than human population"
00:20:11 <merijn> trap_exit: Our biggest graph is about 300 gb (this also includes some node properties, but then again it's only a subset of the largest graph we have)
00:20:45 <merijn> trap_exit: My supervisor's husband has a graph that's 15 TB, it'll be a while before it fits in memory :)
00:20:57 <AshyIsMe> you can spin up aws instances with 244gb of ram
00:21:14 <trap_exit> can you disclose what field 15 TB comes from?
00:21:16 <AshyIsMe> that's only 3 or 4 instances and you'd have your 700gb in memory :P
00:21:21 <trap_exit> is this high energy physics ?
00:21:22 <merijn> trap_exit: peer 2 peer
00:21:41 <merijn> trap_exit: They hooked up a server to the biggest torrent trackers and logged every connection in the swarm since 2009
00:22:02 <trap_exit> merijn: is your research funded by NSA, RIAA, or MPAA ?
00:22:59 <merijn> That's not my field of research, but considering that those people aren't in the US I'm gonna go with "none of the above" :)
00:27:38 <trap_exit> constant disconnect
00:27:39 <trap_exit> damn it
00:27:52 <trap_exit> I bet my isp's software is not writen in cloud haskell.
00:30:12 <gfixler> oh snap
00:45:44 <Guest-4096> good evening everybody!!
00:49:19 <splintax> good afternoone
00:55:10 <splintax> when i try to build accelerate-examples on OS X i get the rather unhelpful message
00:55:13 <splintax> "cabal: Package accelerate-examples-0.16.0.0 can't be built on this system."
00:55:18 <splintax> does anybody know what this means?
00:55:41 <splintax> i assume that "this system" means OS X but i can't see anything that looks like an OS constraint in the .cabal file
00:56:41 <splintax> and i can build the accelerate library itself without problems, so if that's cross-platform i don't see why the examples wouldn't be
01:00:03 <splintax> hmm, maybe "extra-libraries: stdc++" is the problem
01:00:31 <splintax> but if so i'm not sure how to obtain that library on OS X, or why cabal doesn't identify this as the missing dependency
01:02:19 <merijn> splintax: stdc++ is the C++ standard library and cabal can't install it, since it's not haskell
01:03:25 <splintax> fair enough if it can't install it, but it should be able to identify that as the problem since stdc++ is explicitly listed in the .cabal file
01:03:50 <splintax> if that is indeed the problem; i'm just looking through the file and trying to spot stuff that might be causing the problem
01:04:01 <merijn> also, I have no clue what accelerate uses for GPU acceleration
01:04:55 <splintax> it has multiple backends
01:05:07 <splintax> might just email the list
01:05:22 <splintax> seems really weird that i can build the lib but not the executables, though
01:06:49 <xpika> is there a typeclass that performs class c m where op :: m (m a) -> m a  ?
01:07:24 <xpika> basically just the monad join operation
01:10:53 <splintax> i think that would be isomorphic to Monad, since you can implement bind in terms of join
01:11:33 <sopvop> but monad also has 'return'
01:12:04 <xpika> sopvop: applicative has pure which is pretty similar
01:12:45 <sopvop> well, maybe you don't want pure or return, only join and <*> and fmap :)
01:13:53 <dfeuer> What you want that for?
01:16:21 <xpika> dfeuer: a function which gives you the functionality of monad if you meet simpler type classes
01:27:13 <kdk> www.haskell.org is down? status.haskell.org is reachable and all green though?
01:28:07 <foo__> hi
01:28:21 <xpika> foo__: hi
01:28:22 <foo__> fib 0 = 0
01:28:27 <foo__> fib 1 = 1
01:28:44 <foo__> fib n = fib (n - 1) + fib (n - 2)
01:29:52 <mauke> cool story
01:31:26 <bartavelle> kdk, I think status is updated by hand
01:31:38 <dfeuer> Which is kind of silly.
01:31:55 <bartavelle> I am probably wrong though, there is some mention of status.io
01:32:04 <bartavelle> I don't think it's silly, it's a different tradeoff
01:32:55 <dfeuer> bartavelle, it makes a lot of sense to have some aspects be manual, but a simple check of "Can I load the main page? No? Must be down" seems pretty easy.
01:33:26 <bartavelle> I don't think it's about technical complexity (although you would need to integrate such a check in your webpage)
01:33:36 <bartavelle> well IDK
01:34:50 <bartavelle> I found it strange that disk space ran out lately without prior notice, but I have learned from being a sysadmin that there always are good reasons why something is done "wrong" ;)
01:34:58 <bartavelle> the biggest one being lack of resources
01:36:13 <dfeuer> bartavelle, I think the biggest resource limit is human.
01:36:19 <bartavelle> yes
01:39:06 <notdan> ouch, hackage is down ):
01:39:19 <dfeuer> Hackage too?
01:39:22 <bartavelle> yes
01:39:34 <dfeuer> When it rains, it pours.
01:42:03 <yitz> dfeuer: until now it has all been on the same container, so that's common. thoughtpolice is working on some major infrastructure upgrades these days, so that may be the reason for the outage.
01:42:31 <kdk> looks like it is back
01:42:56 <yungidiot> hello
01:43:10 <dfeuer> I remember one of the recent outages happened to coincide with an lpaste outage, so things were very unhappy.
01:43:21 <dfeuer> yungidiot, goodbye.
01:43:27 <yungidiot> ?
01:43:45 <dfeuer> You say hello. I say goodbye. Goodbye, goodbye!
01:44:21 <jle`> i don't know why you say hello
01:44:25 <jle`> i say goodbye
01:44:27 * jle` dances
01:44:46 <yungidiot> anyways im learning haskell and LYAH says this is the place to be
01:45:16 <pharm_> Morning.
01:45:25 <pharm_> Just a quick FYI:
01:45:43 <pharm_> I'm seeing shellshock attacks on darcsweb
01:45:55 <sinelaw> ooh
01:46:04 <dfeuer> yungidiot, this is not usually the best hour for Haskell discussion, but there are a few people around if you have questions to ask.
01:46:05 <pharm_> So if you're running it on a machine with bash as your /bin/sh, take it down now.
01:46:21 <bartavelle> pharm_ does it spawn it ?
01:46:23 <yungidiot> i dont have questions, im just hanging out
01:46:46 <pharm_> (darcsweb is a python script, but it invokes darcs via os.popen4 which spawns /bin/sh)
01:46:54 <jle`> yungidiot: welcome :D
01:46:55 <bartavelle> ah !
01:47:09 <pharm_> if you feed it the program + args as a string instead of a list.
01:47:30 <pharm_> unfortunately, darcsweb uses a string, which is fed to /bin/sh to parse.
01:47:36 <pharm_> Hence the vulnerability...
01:47:47 <jle`> welp
01:47:54 <dfeuer> Just use shell-conduit or hell instead.
01:48:29 <bartavelle> dfeuer, it's a python script
01:48:43 <bartavelle> oh
01:48:45 <bartavelle> nvm
01:49:18 * dfeuer goes to sleep.
01:49:25 <dfeuer> NIGHT PEOPLE.
01:50:32 <pharm_> See, fex: http://www.kantaka.co.uk/darcsweb/ which is my (very old) installation.
01:51:33 <pharm_> Anyway, just a heads-up. Not many people out there running it...and if you're on Debian/Ubuntu you should be fine, because your /bin/sh is dash by default, not bash.
01:52:05 <dfeuer> pharm_, all the rest just need to upgrade bash and restart darcs, right?
01:55:40 <pharm_> Yup, that's about it.
01:56:08 <pharm_> So long as darcs itself doesn't have any weird env parsing bugs!
02:01:49 <vbernat> Hey! I am a beginner to Haskell and I am wondering how to write something with monads. Here is what I am trying to do: https://gist.github.com/vincentbernat/bc68aae7ac08bc89b510
02:02:30 <dibblego> vbernat: return $ config …
02:02:51 <vbernat> There are two problems with my makeAbsolutePaths function: I'd like to use the automatically defined accessors to access data inside the monad and I'd like to rewrap the modifications inside a monad
02:03:20 <vbernat> dibblego: thanks for that
02:04:25 <vbernat> maybe I am overestimating the magic of monads :)
02:04:56 <splintax> in my experience that is quite difficult to do :)
02:05:06 <tdammers> vbernat: there is no magic. Just some perfectly normal operators, and a bit of syntax sugar
02:05:25 <tdammers> or maybe the "magic" is that this is enough to do all sorts of things with them
02:06:01 <Mandy23>  Hi! I give you some videos. I hope you like! http://is.gd/GHJqQj
02:06:12 --- mode: ChanServ set +o dibblego
02:06:16 --- mode: dibblego set +b *!*Mandy21@37.221.169.*
02:06:20 --- kick: Mandy23 was kicked by dibblego (Mandy23)
02:06:30 --- mode: dibblego set -o dibblego
02:06:37 <vbernat> tdammers: so, the automatic accessors are not monad aware for example?
02:08:21 <yungidiot> hey so im pretty much new to programming and haskell, what is the most commno use for haskell?
02:09:50 <erikd> yungidiot: writing compilers and embedded domain specific languages
02:10:21 <yungidiot> cool
02:11:34 <vanila> im learning about compiling development, are there some good small examples of compilers in haskell to look at?
02:13:29 <dfeuer> yungidiot, Haskell is also a big old testbed for testing out programming language design ideas, especially in the realm of type systems supporting useful inference.
02:14:51 <yungidiot> dfeuer cool, thanks
02:15:24 * hackagebot ert 0.0.1.0 - Easy Runtime Templates  http://hackage.haskell.org/package/ert-0.0.1.0 (kayo)
02:16:05 <adnam> vanila: fay is pretty small
02:17:36 <vanila> thanks! any others to look at!
02:21:59 <adnam> vanila: do you want to look at something with a full compiler pipeline or are you more interested in specific parts?
02:22:55 <vanila> I want to look at whole compilers
02:23:38 <adnam> vanila: perhaps purescript is even more interesting to you
02:23:43 <vanila> ty!
02:23:51 <adnam> there is a video somewhere... lemme check
02:23:52 <yungidiot> i think its pretty cool how much you can do in ghci
02:24:26 <adnam> vanila: https://plus.google.com/events/c6ok0mmb63tj2lqjpccl65n69lg
02:24:55 <vanila> cool :)
02:26:19 <adnam> notably fay doesn't do lexing/parsing/typechecking/name resolution itself, but purescript does since it's a new language
02:49:33 <bezirg> hi, one compiler-related question: type-checking lies in the compiler's frontend, right? Does that mean that ghc annotates the AST with types? How can I get these type-annotated AST?
02:52:26 <trap_exit> any audio experts here? I'm tring to write a program (in Haskell) which does the following -- the input is a microphone, and the output is a speaker
02:52:44 <trap_exit> anytime it hears anyeone talking, it auto generates a "shhhhh"
02:53:08 <tdammers> trap_exit: ok, so where are you stuck?
02:53:33 <trap_exit> so I'm familiar with haskell (LYAH + most of RWH)
02:53:39 <adas> trap_exit: that should be fun
02:53:45 <trap_exit> I'm stuck on the audio part --- hackage for osx sound looks confusing
02:53:54 <trap_exit> there's a bunch of libraries c sound, super collider, haskore, ...
02:54:05 <trap_exit> and I just want an opiniated set of libraries that "just fucking works"
02:54:13 <trap_exit> adas: useful too
02:54:19 <tdammers> ah
02:54:32 <trap_exit> I think people will stfu once they realize they're arguing with a computer
02:54:46 <doismellburning> trap_exit: I know that feeling
02:55:13 <tdammers> my first impulse when realizing I am dealing with a machine is trying to find ways to game it
02:55:13 <doismellburning> trap_exit: "here is a framework with all the building blocks for doing whatever complex procedures you may want" "thanks, but like, I want to do this common thing"
02:56:56 <trap_exit> yeah, it's a bit like "I wnat to write a program that adds two numbers"
02:57:09 <trap_exit> "okay, here are my 10 favorite tutorials on Monads + a PhD thesis on category theory"
02:57:27 <trap_exit> just give me 1) an infinite sequence fr input
02:57:32 <trap_exit> and 2) allow me to pipe ain infinite sequence (for output)
03:01:15 <desdes> hi guise!
03:01:26 <sgronblo> trap_exit: hehe
03:02:00 <desdes> short question, what is the simplest way to play a single sound over midi out of ghc?
03:03:06 <pjdelport> desdes: No idea, but have maybe look through http://hackage.haskell.org/packages/search?terms=midi ?
03:04:32 <pjdelport> desdes: For sending and receiving MIDI, that midi package recommends one of: alsa-seq, jack, PortMidi, hmidi
03:05:29 <trap_exit> yeah
03:05:30 <trap_exit> this is fucking complicated
03:05:37 <trap_exit> just to play a midi
03:05:42 <trap_exit> instead, it should be like "cabal install osx-midi"
03:05:46 <desdes> yeah, kind of a bummer
03:05:47 <trap_exit> and then BOOM, you get to play midi's
03:05:57 <trap_exit> jack requires it's own server jackd
03:06:06 <trap_exit> and things break in 10 different way when installing these packages
03:07:00 <trap_exit> trap_exit: please either stfu or fix this problem :-)
03:07:47 <vanila> I agree about "cabal install osx-midi" but the thing is someone has to write it!
03:07:52 <hmot> Hi all. Here's the next problem that we're facing. We have an external API (we can't change it) that can returns result of form "{(a1) : (data_a1), (a2) : (data_a2), ... }", where (a) has one of 10 distinct values. (data_a) is a data structure whose members depend on (a), but all have one member, 'z'::Double. It is guaranteed that the json doesn't contain duplicates (a_i == a_j) is equivalent to (i==j). We have a function that takes the AP
03:07:52 <hmot> I's returned json and returns a (handwritten) structure of form data B = B {b0::Maybe data_b0, b1::Maybe data_b1, ...}, where b is the set of possible values that each a_i may take. We want to write a function that takes B and throws an exception unless there is just one data_b0 that is a Right value. If there is just one data_b0 that is Right, then return (data_b_i.z). The problem is complicated to explain, but in a reflective language li
03:07:53 <hmot> ke python / C#, this would be just a line or two of simple code, iterating over B's members looking for non-null members. So we were speculating that there would be an easy way to do this in haskell, without changing the data structure B too much.
03:08:39 <trap_exit> hmot: can you paste this into gist pls?
03:08:51 <trap_exit> and use white space / new lines, so its' not a wall of text ?
03:08:54 <vanila> its only 3 lines its fine
03:09:39 <hmot> let me see if I can find somewhere to post it
03:09:40 <dcoutts_> hmot: sounds like it's just a case of parsing well-formed json, and then doing some validation on the structure
03:09:59 <trap_exit> do you code with terminals that are 300 chars wide?
03:10:22 <trap_exit> hmot: if you need to parse json, aeson is a good library
03:10:29 <bernalex> how do you pattern match a [String] to get first char of first word + rest of that word + rest of words?
03:10:31 <trap_exit> hmot: are you familiar with <$>, <*> ?
03:10:41 <bernalex> > let f [a:b] = a in f . words $ "test"
03:10:43 <lambdabot>  't'
03:10:51 <bernalex> > let f [a:b] = a : b in f . words $ "test"
03:10:52 <trap_exit> hmot: for me, learning aeson the geratest hurdle was the use of <$> and <*> ... after that, it's relatively easy to use
03:10:52 <lambdabot>  "test"
03:11:01 <bernalex> how do I do f [a:b] : rest   ?
03:11:02 <tdammers> trap_exit: cool-old-term... super awesome
03:11:15 <tdammers> trap_exit: but more like 50-80 chars wide
03:11:16 <bernalex> ([hc:rc]:rs) pattern matches a [[[Char]]] apparently
03:11:20 <hmot> we're using aeson already, but that's a problem we've already solved. This problem is about traversing a complicated data structure that's already decoded.
03:11:29 <trap_exit> by [a:b], do you mean (a:b) ?
03:11:46 <dcoutts_> hmot: e.g. using aeson to parse into the Value type, and then using the aeson parser combinators to extract the info if it fits the expected structure.
03:11:50 <trap_exit> hmot: what is this data structure? is it a list? a map? ....
03:12:21 <bernalex> trap_exit: I derped
03:12:28 <bernalex> it's just ((hc:rc):rs)
03:12:39 <trap_exit> bernalex: so is problem solved? :-)
03:12:50 <bernalex> trap_exit: yes :-]
03:12:51 <trap_exit> damn, my floor is shaking
03:12:57 <hmot> which one in particular? the json is something like {'f0':{'abc':"efg",'z':2.3}, 'f1':{'bcd':"ghf", 'z':1.2}}
03:13:00 <dcoutts_> hmot: aeson has parser combinators to go from a decoded Value type into your custom type. So this is both a structure validation and conversion.
03:13:02 <trap_exit> I wonder if this is another earthquake
03:13:08 <bernalex> trap_exit: I'm not playing my black metal *that* loud. unless you're right next to me. then it might be me.
03:13:28 <trap_exit> I don't hear anything, so unless I'm deaf, it's not you
03:14:29 <hmot> we've already converted the json to B, which is of form {_f0::Maybe {_abc::String, z::Double}, _f1::Maybe {_bcd::String, z::Double}, _f2::Maybe{z::Double}}
03:15:02 <dcoutts_> hmot: or alternatively if you've already parsed into a custom structure that does not enforce the invariants you're after, then you just want a custom function to validate it
03:15:36 <hmot> it's about enforcing the new structure *only* when trying to extract a single z value from B
03:15:42 <hmot> and extracting that value at the same time
03:15:56 <hmot> it's got obvious but verbose solutions
03:16:16 <hseg> Why do type families require global uniqueness for type safety?
03:17:07 <SwashBuckla> bernalex: hey alex :)
03:17:21 <hmot> one of the solutions would be to manually itemize all the members of B, and put those maybes into a list, then get rid of the Left values, check that the list is now of length 1, instantiate all 10 _f_i data types with hasZ, and then apply that to the remaining value in the list
03:17:36 <hmot> but that would be unmaintainably complicated
03:18:21 <dcoutts_> hmot: do you really want to delay this validation until you extract from B, rather than doing the validation when you parse out of the json Value?
03:18:28 <hmot> yes
03:18:36 <hmot> we think we do
03:18:50 <hmot> because the API is wrapped in haskell, currently only returning B
03:18:54 <SwashBuckla> bernalex: isn't ((hc:rc):rs) == (hc:rc:rs) ?
03:19:04 <hmot> we could change the wrapper in theory, but we'd rather not
03:19:27 <hmot> we're reluctant to admit that this simple problem has no simple haskell solution
03:19:40 <dcoutts_> hmot: it sounds like your B type should really be: data B = A1 { ... } | A2 { ... } | ... etc
03:19:59 <hmot> well, B can contain several of the above
03:20:00 <dcoutts_> hmot: right? because only one field is supposed to be filled in
03:20:01 <hmot> not just one
03:20:13 <hmot> it's just this particular use case where we expect only 1 A value
03:20:21 <hmot> other use cases will have all or a subset
03:20:36 <dcoutts_> hmot: ah, so in general there can be several and just in this case there'll be exactly one
03:20:39 <hmot> yes
03:20:42 <hmot> that's correct
03:20:43 <dcoutts_> ok fair enough
03:20:59 * hackagebot shell-conduit 4.2 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.2 (ChrisDone)
03:21:48 <dcoutts_> hmot: so since these fields are different anyway, you'll presumably need different functions for them, or you'll need a type like the above that can represent exactly one field (but any field)
03:22:14 <dcoutts_> the difficulty is that all your fields are of different types
03:22:17 <hmot> well, they are (or could be made to be) instances of the HasZ class
03:22:45 <dcoutts_> hmot: if you only need the z that's fine. If you need the other bits then you need to know the type of them
03:22:56 <hmot> for this use case, just z
03:23:07 <dcoutts_> ok
03:24:10 <dcoutts_> hmot: in that case all you need is a function to go from the record of fields, to [Maybe Double], and then you can check that there's exactly one Just, and return that.
03:24:30 <hmot> that might be the only solution
03:24:37 <SwashBuckla> bernalex: ah, it's not
03:24:39 <dcoutts_> hmot: so the only annoying bit is writing the function to go from a record with N fields, to a list with N elements of the same type
03:25:12 <dcoutts_> hmot: in principle there are generic programming solutions to this, but unless you do a lot of this sort of thing then the overhead of learning them may not be worth it
03:25:14 <hmot> I guess that is an annoying bit. There might be other unforseen annoyances
03:25:40 <hmot> we might end up doing quite a bit of this, since we'll be working with an API like this for a while
03:26:26 <dcoutts_> hmot: the other thing you can do is do things in a less typed way prior to validation
03:26:39 <dcoutts_> e.g. keep it as a Value before extracting the bits you're really interested in
03:26:55 <hmot> here's the equivalent C# code, in case that helps
03:26:56 <hmot> public static List<double> getOnlyZ(B b)
03:26:56 <hmot>         {
03:26:56 <hmot>             b.GetType().GetProperties().Select(x => x.GetValue(b)).Where(x => x != null).Select(x => x.z).ToList();
03:26:56 <hmot>         }
03:27:10 <dcoutts_> which is taking an untyped approach too
03:27:17 <dcoutts_> like my suggestion for keeping it as a Value
03:27:27 <dcoutts_> or it's a bit like a generic programming solution
03:27:34 <hmot> keeping them as a dynamic type
03:27:51 <dcoutts_> for generic programming, e.g. if z is the only Double then you can use uniplate to grab all the doubles within the structure as a list
03:27:58 <dcoutts_> and then you expect there to be exactly 1
03:28:23 <hmot> that might work: perhaps representing them as a rigid structure makes things more complicated overall: a lot of compile time checks are impossible anyway, since the API returns a type that can't be guaranteed easily
03:29:36 <dcoutts_> hmot: by advice would be to use rigid types only post-validation
03:30:03 <dcoutts_> once it's in your internal structures that really enforce the shape you want to deal with
03:30:15 <hmot> thanks, dcoutts_, that's been helpful. So the things to try: 1) going through converting to a list of maybes. 2) parsing it to a different structure (like a more dynamic type), 3) learn generics (or is this the dynamic type suggestion? I'm not too familiar with generics)
03:30:46 <dcoutts_> hmot: 2 is more like keeping it as a Value until you're finished extracting all the info you want
03:31:01 <dcoutts_> and Value is the rather dynamic type
03:31:29 <henrixh> I have a rather odd question. I'd like to 'cast' between Doubles and Word64, bit to bit. The reason is that I would like to have doubles and a seeds to a PRNG stored in a repa array
03:31:49 <hmot> ok, we'll look into all these. Again, thanks for the help.
03:31:51 <henrixh> Of course limited by architecture
03:31:51 <dcoutts_> hmot: 3) generics is not dynamic typing, it's type safe but adapts to the structure of the type
03:31:54 <hmot> dcoutts_++
03:32:00 <dcoutts_> good luck
03:33:12 <hseg> Does anyone have a compelling use for open type families that aren't associated with type classes?
03:33:25 <dcoutts_> hmot: an analogy would be that (data type) generic programming is like reflection or dynamic typing but done in a disciplined and safe way. You can achieve many of the same ends, but in a much safer and more principled way.
03:35:07 <hmot> I think that'll be my next task: learning about generic programming in haskell :)
03:35:52 <hmot> is there a way to 'upvote' people? The wiki on this said there was a ++ notation, but it's not clear how to do that.
03:36:53 <hseg> dcoutts_++
03:37:06 <hseg> No? I thought that was the way to do it.
03:39:49 <dcoutts_> @karma
03:39:49 <lambdabot> You have a karma of 4
03:39:53 <dcoutts_> apparently :-)
03:40:09 <dcoutts_> @karma dcoutts
03:40:09 <lambdabot> dcoutts has a karma of 13
03:41:23 <hseg> @karma+ dcoutts
03:41:23 <lambdabot> dcoutts's karma raised to 14.
03:41:31 <hmot> ah, great
03:41:34 <dcoutts_> heh
03:41:53 <hmot> https://github.com/jwiegley/lambdabot/blob/master/Plugin/Karma.hs --> this seems to be a good "description" of how karma works
03:42:35 <hseg> Anyway, does anyone have a usecase for open type families?
03:43:05 <hseg> @karma+ hseg
03:43:05 <lambdabot> You can't change your own karma, silly.
03:43:08 <hseg> :(
03:57:50 <sinelaw> @karma+ lambdabot
03:57:50 <lambdabot> lambdabot's karma raised to 28.
03:58:34 <joyfulmantis> I just wrote a function to do "Either a b -> (b -> c) -> Either a c" for a program I am writing, and was wondering if I am duplicating a standard function or way of doing things in haskell?
03:59:26 <sinelaw> anyone have references for implementing HM-style inference in a non-pure system (i.e. reference cell assignment are allowed)?
03:59:39 <sinelaw> *for a non-pure syntax
03:59:57 <vanila> sinelaw, it's just the same as doing it with monads
04:00:24 <vanila> there was a good ICFP talk about doing this in ocaml https://www.youtube.com/watch?v=8b79M4Nmh34
04:00:46 <sinelaw> vanila, you mean transform statements in the imperative syntax into a composition of monadic binds and then do it the usual way?
04:01:14 <vanila> yeah
04:02:03 <sinelaw> thanks. I tried figuring out a way to do it directly, but it kind of breaks HM's assumptions
04:03:05 <vanila> maybe I don't fully understand your question, would you elaborate a bit?
04:03:28 <sinelaw> vanila, the problem is polymorphism of functions vs. reference cells
04:03:44 <sinelaw> (variables are always cells in this case)
04:03:49 <vanila> oh geez
04:03:56 <vanila> you mean type inference for an object language with mutable cells!
04:04:02 <vanila> I thought you meant implementation language
04:04:12 <vanila> yeah I was totally mixed up, sorry!
04:04:14 <sinelaw> implementation language?
04:04:20 <hmot> joyfulmantis, liftM might be a fit, otherwise
04:04:29 <vanila> implementation language being like , you're writing this in haskell
04:04:37 <sinelaw> oh, heh
04:04:41 <vanila> object language being the language your program is typechecking
04:04:53 <sinelaw> but your answer may be valid anyway though
04:04:57 <sinelaw> :)
04:05:12 <sinelaw> I can treat the object language as sugared DO in a big state monad
04:05:29 <vanila> yeah I think that typing mutable cell is quite difficult/intricate
04:05:32 <nshepperd> the problem here is that you can't tell the difference between a -> b -> IO c and a -> IO (b -> c), right?
04:05:38 <vanila> You should definitely reference TAPL on this
04:06:03 <nshepperd> I mean, when mutation can appear anywhere in your code
04:06:30 <sinelaw> vanila, I already am, but I think this particular problem is not addressed
04:06:35 <vanila> https://code.google.com/p/tapl-haskell/source/browse/trunk/fullref/Typing.hs
04:06:45 <sinelaw> tapl-haskell? cool!
04:06:54 <vanila> lines 83-91 show that it's actualyl really simply
04:07:15 <vanila> it's just they interact weirdly with subtyping (which we're not doing here), so disregard what I said a bit ago
04:07:33 <sinelaw> oh I see that's fullref
04:07:47 <hseg> :t fmap `asTypeOf` right
04:07:48 <lambdabot> (b -> c) -> Either d b -> Either d c
04:07:53 <hseg> joyfulmantis: ^^^^^
04:08:20 <nshepperd> well, I guess in a typical impure language you distinguish calling vs naming by using parentheses
04:08:21 <hseg> Basically, Either a is a Functor for all a, and this is the type of fmap there.
04:11:16 <vanila> sinelaw, so yeah it's just:   x : t |- ref x : Ref t   and   c : Ref t |- !c : t
04:11:44 <vanila> sinelaw, and  c : Ref t, x : t |-  c := t : unit
04:12:13 <sinelaw> vanila, ok, so I can basically desugar the original code to use ! and ref
04:12:42 <vanila> I thought ! and ref would be in the object language, what do you desugar from?
04:12:50 <sinelaw> javascript!
04:13:11 <sinelaw> x = 1   would become x := 1
04:13:26 <sinelaw> and every other variable (not on the lhs of an assignment) would become !x
04:14:14 <sinelaw> actually I already do that.
04:15:50 <sinelaw> vanila, thanks, that was very helpful!
04:16:04 <vanila> ok, sorry I got so mixed upa t first!
04:17:02 * hackagebot yesod-test 1.4.0.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.0.2 (MichaelSnoyman)
04:18:30 <sinelaw> vanila, if i'm not mistaken, fullref doesn't have polymorphism (but has subtyping)?
04:20:21 <jayunit100_4g> maybe2List Just 3 -- how come this needs parenthesis ?
04:20:44 <jayunit100_4g> maybe2List2 (Just 3) -- succeeds ! but the above fails.  Seems like ghc would  know better ?
04:23:24 <k00mi> jayunit100_4g: the first would mean maybe2List takes two arguments
04:23:54 <jayunit100_4g> i thought if ghc saw a data constructor which required an arg, it would group them "Just"
04:24:01 <sinelaw> joyfulmantis, I always check hoogle as a way to find out if i'm re-inventing the wheel
04:24:05 <sinelaw> @hoogle Either a b -> (b -> c) -> Either a c
04:24:07 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
04:24:07 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
04:24:07 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
04:25:21 <sinelaw> fmap could work too, If i'm not mistaken about Either
04:28:13 <k00mi> jayunit100_4g: it doesn't and it would be horrible if it did
04:28:30 <jayunit100_4g> :) okay
04:29:25 <sinelaw> vanila, IIRC the problem is combining REFs with polymorphism
04:30:02 <vanila> Ah, okay, im not sure what that is done you might have to require monomorphic types for cells
04:30:21 <sinelaw> vanila, yip, that's what I'm thinking
04:30:30 <vanila> I think that this was an issue in SML
04:30:45 <sinelaw> but then, a cell that holds a polymorphic function must collapse it to a specific type
04:30:48 <vanila> http://www.smlnj.org/doc/Conversion/types.html
04:30:51 <vanila> "The interaction between polymorphism and side-effects has always been a troublesome problem for ML"
04:31:00 <sinelaw> heh
04:31:20 <sinelaw> talk about re-inventing the wheel...I'm only 30 years behind
04:31:49 <vanila> "SML '90 solved this problem by introducing a special, restricted form of polymorphism expressed through imperative types. An imperative type is a polymorphic type whose bound type variable is of a special form, called an imperative type variable"
04:32:50 <sinelaw> vanila, that is another great reference :)
04:34:55 <joyfulmantis> thanks sinelaw and hseg! I had tried looking it up on hoogle, but the only thing that looked possibly useful was Arrow stuff, and I did not want to have to learn that now. I will try and use fmap
04:35:37 <sinelaw> joyfulmantis, the arrow stuff is not relevant... Either a b is not an arrow
04:35:46 <sinelaw> but I'm pretty sure it's a functor on b
04:35:49 <sinelaw> so fmap should work
04:37:29 <hseg> joyfulmantis: I only used right in order to get lambdabot to spit out the right type
04:37:39 <hseg> joyfulmantis: It's probably overkill.
04:38:35 <hseg> joyfulmantis: However, bifunctors give you the ability to fmap over the left and right of Either: http://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor.html
04:40:03 <sinelaw> lambdabot, > fmap show $ Right 2
04:40:09 <sinelaw> > fmap show $ Right 2
04:40:10 <lambdabot>  Right "2"
04:44:27 <hseg> lambdabot: > import qualified Data.Bifunctor as B
04:44:40 <hseg> lambdabot: > B.right show $ Right 2
04:44:48 <hseg> ?
04:45:02 <hseg> lambdabot, import qualified Data.Bifunctor as B
04:45:16 <hseg> lambdabot, > B.right show $ Right 2
04:45:24 <sivteck> just use `> '
04:46:14 <hseg> > import qualified Data.Bifunctor as B
04:46:16 <lambdabot>  <hint>:1:1: parse error on input â€˜importâ€™
04:46:33 <hseg> > Data.Bifunctor.right show $ Right 2
04:46:34 <lambdabot>  Not in scope: â€˜Data.Bifunctor.rightâ€™
04:46:50 <hseg> @import Data.Bifunctor
04:46:50 <lambdabot> Unknown command, try @list
04:46:58 <hseg> Sorry for the noise.
04:47:03 <sinelaw> hseg, msg :)
04:47:17 <hseg> Just what I was going to do.
04:47:23 <hseg> I thought it would work.
04:47:57 <sivteck> :m + Data.Bifunctor as B
04:48:17 <hseg> > B.right show $ Right 2
04:48:18 <lambdabot>  Not in scope: â€˜B.rightâ€™
04:48:21 <sivteck> ;/
04:48:29 <hseg> :(
05:02:35 * hackagebot yesod-form 1.4.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.0.1 (MichaelSnoyman)
05:11:31 <hseg> Why are open type families useful?
05:11:55 <opqdonut> I guess for the same reason as type classes
05:12:19 <hseg> Specifically, how can you do sensible stuff with open type families without having associated functions?
05:12:42 <opqdonut> oh, right
05:12:54 <opqdonut> well you can't, obviously, unless you want to do stuff on the type level
05:14:00 <hseg> But if you're working on the type level, is there any case in which * is the appropriate kind to use? Wouldn't it make more sense to use DataKinds to create your own kinds and use closed type families?
05:17:37 * hackagebot rot13 0.1.0.0 - Fast ROT13 cipher for Haskell.  http://hackage.haskell.org/package/rot13-0.1.0.0 (KyleVanBerendonck)
05:28:55 <nshepperd> I heard that type families can sometimes replace multiparam type classes
05:29:32 <hseg> You mean fundeps?
05:30:01 <nshepperd> yes
05:31:18 <nshepperd> instead of "class Foo a b | a ~> b" you do "class Foo a" with an associated type family
05:31:20 <nshepperd> or something
05:31:24 <gilligan_> hi
05:32:02 <gilligan_> anyone here using stackage ? I suppose there's no workaround for working with cabal sandboxes yet ? the github ticket is still in progress at least
05:32:10 <opqdonut> nshepperd: that's exactly how it goes
05:32:26 <opqdonut> nshepperd: see http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_type_synonym_example
05:38:46 <hseg> Nice, but that doesn't answer my question. My question is, specifically, How are non-associated open type synonym families useful, considering that the fact that a type is an instance of a type family doesn't guarantee the existence of functions that can manipulate values of its instance type?
05:39:15 <hseg> i.e. given OTF F, how can I work with a value :: F a?
05:50:37 <AshyIsMe> how do you catch something thrown by monadThrow?
05:50:41 <AshyIsMe> in particular: https://github.com/himura/twitter-conduit/blob/master/sample/post.hs#L17
05:50:53 <AshyIsMe> that call function can throw a TwitterError
05:51:00 <AshyIsMe> how would i catch it and handle it?
05:51:40 <AshyIsMe> call is defined here: http://hackage.haskell.org/package/twitter-conduit-0.0.7/docs/src/Web-Twitter-Conduit-Base.html#call
05:53:07 <AshyIsMe> the function chain goes: call -> call' -> getValueOrThrow
05:54:11 <AshyIsMe> and getValueOrThrow calls monadThrow
05:59:24 <AshyIsMe> do i have to implement my own call function that doesn't use monadThrow?
06:01:08 <c_wraith> AshyIsMe: don't care in the slightest where the call is defined.  It'd be much more useful to point at where the call is documented, because then I could look at links to all the related types.
06:02:58 <AshyIsMe> sorry, http://hackage.haskell.org/package/twitter-conduit-0.0.7/docs/Web-Twitter-Conduit-Base.html#v:call
06:03:54 <c_wraith> AshyIsMe: I don't see any mention of MonadThrow in call's signature
06:04:45 <danilo2> Hello All! :) Would somebody be so nice and explain to me why the following code does not compiles? It is just easy closed type family use case and GHC tells it cannot infer something which is just obvious :( http://lpaste.net/111907
06:05:34 <AshyIsMe> c_wraith: hmm, if you follow the code, the getValueOrThrow function eventually gets called
06:05:51 <AshyIsMe> so in that case, monadThrow is just going to error out and crash my program and there's no way for me to catch it?
06:05:51 <c_wraith> AshyIsMe: it seems like call is already handling catching the error case
06:06:23 <AshyIsMe> well my program crashes when it throws a TwitterError
06:07:30 <AshyIsMe> i guess im trying to understand what the normal usage of monadThrow should be
06:07:54 <Melba23>  Hi! I give you some videos. I hope you like! http://is.gd/GHJqQj
06:07:58 <supki> AshyIsMe: you can catch TwitterError in IO
06:08:48 <AshyIsMe> supki: just using catch?   catch (call ...) (\e -> handler...)
06:11:14 <c_wraith> AshyIsMe: Ah, I see.  MonadThrow is a superclass of MonadResource.  just use catch.  You should be able to at any point
06:13:53 <c_wraith> err.  You should be able to, if not for the resourcet package exporting its own MonadThrow.  That's..  really inconvenient.
06:15:13 <c_wraith> Ah.  It's a reexport from Control.Monad.Catch.  That's better.
06:16:08 <notdan> I have compiled a local library with `cabal build', do you know how can I tell ghc--make to pick up the compiled files in ./dist/build/ while compiling a singular .hs file?
06:16:56 <c_wraith> AshyIsMe: to catch TwitterError, use catch from https://hackage.haskell.org/package/exceptions-0.6.1/docs/Control-Monad-Catch.html
06:18:10 <AshyIsMe> c_wraith: ah ok, thahnks for the help
06:19:58 <c_wraith> danilo2: I agree with the compiler. That instance doesn't look right.
06:20:58 <c_wraith> danilo2: In particular, that instance looks very wrong when x and a are the same types
06:23:51 <albeit> I have some enum types, that correspond to other values. Like data Foo = Lorem (== "1") | Ipsum (=="4") etc... and I need to convert between them. I'm currently using two maps... is there a better way?
06:24:07 <Guest90090> do we prefer list over Maybe in Haskell?
06:24:15 <albeit> There are typically between 4 and 10 enum constructors by datatype
06:25:04 <tdammers> Guest90090: they serve different purposes
06:25:09 <c_wraith> Guest90090: only when it's as meaningful to get 2 results as 1
06:25:14 <hseg> albeit: And they aren't sequential
06:25:15 <hseg> ?
06:25:39 <Guest90090> watching Erik's talk on monad, I confused when he mentioned about experinced haskell progeammer will avoid using Maybe
06:25:40 <albeit> hseg: No, not sequential, fairly arbitrary too be honest, but I can't control that
06:25:50 <tdammers> Guest90090: oh, that.
06:26:15 <albeit> hseg: I'm just trying to give names to encoded opaque values
06:26:19 <tdammers> avoiding maybe is more about the fact that most of the time, a more specific data type is more appropriate
06:26:39 <tdammers> a bit like how Bool is considered an antipattern
06:26:42 <tdammers> (by some)
06:27:19 <Guest90090> that I kinda disagree, because I will prefer strong context
06:28:18 <tdammers> Guest90090: no, the point is that Bool isn't semantic - it doesn't refer to anything in your domain, it's just a meaningless "true or false" value
06:28:34 <tdammers> Guest90090: it's usually better to define a semantic type for whatever it is your boolean represents
06:28:39 <tdammers> s/usually/often/
06:28:39 <hseg> albeit: How do you intend to decode the names?
06:28:55 <Guest90090> so that made me think an approach I took a few days ago while implementing feature toggles, so I created an Bool isomorph called Toggle = Enabled | Disabled
06:29:19 <albeit> hseg: Right now I'm using two maps... nameToSymbol and symbolToName, and then looking up the appropriate key to convert between them
06:29:47 <albeit> Just seems very verbose and not ideal
06:30:08 <pjdelport> @hackage bimap
06:30:08 <lambdabot> http://hackage.haskell.org/package/bimap
06:30:15 <pjdelport> albeit: Would that work?
06:30:24 <Guest90090> tdammers: yeah, I also think so...may be I am in the middle of the lecture, he might take his words off after some time ;)
06:30:41 <albeit> pjdelport: Yes, was actually planning on using that that figured I might ask if there was a better way not using maps... but doesnt sound like it
06:30:52 <albeit> *that then
06:31:04 <tdammers> Guest90090: I don't agree 100% with the "booleans are evil" camp though
06:31:37 <tdammers> Guest90090: I think using booleans as some sort of "truthiness of a predicate" type, then they are perfectly semantic
06:31:40 <tdammers> vOv
06:32:01 <tdammers> but most uses of booleans are not *really* about that
06:32:17 <Guest90090> tdammers: that I too don't...But what about avoiding Maybe...and using list isntead
06:32:43 <albeit> If I'm reading right, ByteString.Builder concatenates lazy Bytestrings, so has O(1) cost. What is most of my Bytestring I'm concatenation on very short (4-6 bytes)? Is there a more efficient way to build up the ByteString?
06:32:43 * hackagebot jose 0.2.33.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.2.33.0 (frasertweedale)
06:33:09 <albeit> Wow I can't type this morning... * What if most of my Bytestrings I'm concatenating are very short
06:33:44 <tdammers> Guest90090: I don't even see how swapping maybes for lists would make sense
06:34:11 <tdammers> Guest90090: except when you're using maybes when you could just as well handle more than one value
06:34:25 <tdammers> Guest90090: but then I think you should be using lists (or sets or arrays or whatever) in the first place
06:35:38 <Guest90090> tdammers: not maybes for lists, lists for maybes instead?
06:35:53 <tdammers> Guest90090: I think we mean the same thing
06:36:17 <tdammers> Guest90090: but really, I see Maybes as the simplest form of error handling
06:36:28 <tdammers> get a result or don't get a result
06:36:40 <Guest90090> tdammers: his point is- you will get convinience of list fns if you use Lists
06:37:00 <Guest90090> tdammers: affirmative
06:37:03 <tdammers> yeah, ok, but you'll also get unnecessarily lenient data types
06:37:29 <tdammers> I can see the point though
06:37:45 <tdammers> whether you pattern match against Nothing and Just x, or against [] and x:_, ...
06:38:34 <Guest90090> yeah but context semantics will differ
06:39:55 <Guest90090> he also menstioned about ML guys will prefer option type here...and it's more of cultural
06:41:05 <pjdelport> albeit: The Bimap approach is pretty generic, but there might be something cleverer depending on exactly what you need to do. Can you explain the context of your problem in a bit more detail?
06:42:24 <pjdelport> albeit: If these are all small data types that you are enumerating, then something like an Array of values might make sense?
06:42:44 * hackagebot acl2 0.0.1 - Writing and calling ACL2 from Haskell.  http://hackage.haskell.org/package/acl2-0.0.1 (TomHawkins)
06:43:13 <pjdelport> Bimap would be more appropriate for larger and sparser key spaces.
06:44:20 <albeit> pjdelport: Sure. If I "data Foo = Bar | Baz | Lorem", I'm using attoparsec to parse a character into a Foo. I know "D" is Foo, "4" is Bar, and "J" is Lorem. I then am later writing a Foo back into a ByteString, so I need to know what character to write.
06:44:49 <albeit> pjdelport: The majority of the datatypes have about 4-5 possible values, a few have up to 20.
06:45:00 <pjdelport> albeit: How sparse are the values?
06:45:22 <albeit> pjdelport: Not sure what you mean... how does that differ from how many values there are?
06:45:28 <pjdelport> albeit: Actually, if this is for parsing and unparsing, have you looked at bidirectional parsers?
06:46:08 <albeit> pjdelport: I have not.. I do need to use the values elsewhere, and I'm rarely writing the same read value
06:46:18 <pjdelport> Ah, okay.
06:47:24 <pjdelport> So you're mainly just converting from Foo to Bytestrings?
06:47:36 <pjdelport> (with the parser handling the inverse?)
06:47:41 <albeit> pjdelport: Exactly
06:47:58 <pjdelport> In that case, an Array might be more suitable than a map.
06:48:23 <pjdelport> You can derive the Ix class for Foo, and then have an Array indexed by Foo, with the appropriate values.
06:48:57 <pjdelport> That will be more compact than maps, and lookups will be constant-time.
06:49:41 <albeit> pjdelport: Okay. But then when I parse from ByteString to Foo, I would need a map or an explicit case for every possible value?
06:50:26 <pjdelport> Well, do you already have a parser?
06:50:38 <albeit> pjdelport: Yes, but its based off my dual-map thing ;)
06:50:56 <albeit> I parse a character, then find the Foo value corresponding to that key
06:54:15 <pjdelport> It probably makes more sense to define the parser directly, rather than via map lookup
06:54:27 <albeit> Okay
06:54:44 <albeit> Thanks! I'll do the Array deal for the Foo -> ByteString
06:56:20 <pjdelport> albeit: To reduce duplication, you can probably define a helper function that produces pairs of both a parser and a value lookup array in one go.
06:56:36 <pjdelport> That way the correspondence is only defined once.
07:06:41 <pjdelport> albeit: Something like:
07:06:41 <pjdelport> frob bounds' kvs = (choice [ k <$ string v | (k,v) <- kvs ], array bounds' kvs)
07:07:48 <albeit> pjdelport: Okay.. gonna have to study that a bit ;)
07:08:08 <pjdelport> Then you might say: (parseFoo, lookupFoo) = frob (Bar,Lorem) [(Foo, "D"), (Bar, "4"), (Lorem, "J")]
07:08:25 <pjdelport> And then you can obviously format that value list better.
07:08:45 <pjdelport> Then, you only define the correspondence in one place, without having to worry about two places getting out of sync.
07:09:12 <pjdelport> The "frob" helper (which you'll hopefully name better :) just uses that to define both a parser and lookup array at the same time.
07:09:22 <albeit> Okay
07:10:31 <albeit> Is using multiple "mappend" the same as "mconcat"?
07:11:11 <pjdelport> With the above, you also explicitly pass the bounds for the lookup array, but you could avoid that if you want to rely on e.g. Bounded instead.
07:11:15 <pjdelport> (if that makes sense)
07:11:22 <pjdelport> albeit: Pretty much, yeah.
07:11:25 <pjdelport> @src mconcat
07:11:25 <lambdabot> Source not found.
07:12:28 <albeit> pjdelport: Yeah actually using Bounded now to construct my two maps, there's not real downside to that compared to passing the bounds explicitly other than slightly slower compile?
07:12:29 <kcc> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Monoid.html#mconcat
07:13:31 <pjdelport> albeit: mconcat = foldr mappend mempty, basically :)
07:14:08 <pjdelport> albeit: No downside other than having Bounded on your data types :)
07:14:27 <pjdelport> It may depend whether that makes sense or not, but if it does, feel free.
07:14:47 <pjdelport> Does all the above make sense, by the way?
07:15:01 <pjdelport> Like that frob function?
07:15:09 <pjdelport> Feel free to ask if any bits are strange. :)
07:15:54 <albeit> Yeah, I think I need to adjust "frob" a bit for attoparsec, but otherwise I get it. frob definitely threw me for a sec, Hoogle showed nothing, then I realized it was just your chosen name
07:18:21 <hseg> BTW, the bidi parsing thing is given by:
07:18:23 <hseg> http://hackage.haskell.org/package/boomerang
07:18:33 <hseg> Anyway, gotta run.
08:01:14 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
08:01:14 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
08:03:25 <k00mi> as in determining the length of the produced bytestring without actually building it?
08:07:07 <wz1000> mthvedt: I don't think so. Haskell functions are opaque, so you cannot poke inside their internals. You can only make sure that a closure is in hnf when you are constructing it.
08:09:24 <luite> k00mi: yeah, keep data at the same place
08:09:32 <osa1> is there a way to use non-typedefd struct name in hsc2hs's peek macro?
08:09:49 <osa1> something like #{peek struct StructName, field_name}
08:12:05 <k00mi> luite: I don't know, but I could use it too ;-)
08:12:52 * hackagebot string-conversions 0.3.0.3 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.3.0.3 (SoenkeHahn)
08:19:52 <luite> k00mi: another option for me would be placing markers in the builder, getting a list of markers with their positions along with the rendered ByteString back at the end
08:20:37 <luite> (the applicati
08:20:43 <luite> oops
08:23:56 <luite> k00mi: but ideas for other approaches are welcome too, i'm replacing the prettyprinter in GHCJS to be able to use the line number info from GHC 7.10 to output a source map
08:38:52 <k00mi> luite: I currently just build the bytestring and use the result and length in a new builder, and as long as performance isn't a problem I will probably keep it that way
08:48:13 <fizbin> luite: I had to solve a similar problem, and ended up with a structure of:
08:49:08 <fizbin> data BinaryPiece = BinaryPiece { _bpLabel :: String, _bpByteLength :: Int -> Int, _bpByteString :: Int -> Map String Int -> B.ByteString }
08:49:55 <fizbin> The argument to length is "offset" and the arguments to bytestring are "offset" and a (label -> offset) Map.
08:50:26 <fizbin> Then I wrote a [BinaryPiece] -> B.ByteString function.
08:51:16 <fizbin> Not super elegant, but straightforward to write and for other people to understand.
08:52:28 <fizbin> It would be trivial to return the final map in addition to the final bytestring.
08:57:36 <beckyconning> is there a generic fp / type theory irc channel?
09:00:23 <albeit> I have an class Foo with methods fromParser and toBuilder. I can generate the two methods in a pair, but I can't do "instance Blah Foo where (fromParser, toBuilder) = bar". .. is there another way to do that?
09:00:37 <albeit> The error I'm getting is "Pattern bindigns not allowed in instance declarations"
09:01:40 <hiptobecubic> :set sw=2
09:02:54 * hackagebot libhbb 0.1.1.0 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.1.1.0 (wolfch)
09:05:54 <albeit> Some code, showing what I'm doing now: http://lpaste.net/111915. But hoping to move the pair-generating part to within the instance declaration somehow...
09:06:54 <luite> fizbin: sorry was away and i have to run in a few secs. tnx, i might end up using something similar
09:07:28 <fizbin> okay; whenever, if you need that [BinaryPiece] -> Bytestring function, ask me for it.
09:07:39 <luite> fizbin: but i might need too many markers for that to be efficient enough
09:12:23 <vermeille> Hi all
09:13:43 <srhb> vermeille: o/
09:13:46 <vanila> beckyconning, I don't erally know of one - did you want to discuss any specific stuff about type theory?
09:15:14 <beckyconning> vanila: i mostly wanted to work out if its a good idea to have a type system with a 1 element tuple. it seems odd to me.
09:15:34 <vanila> beckyconning, like data One a = One a ?
09:15:38 <vermeille> I *really* need help with cabal (is it normal to HATE this tool?). I wanted to reinstall all my libs to have profiling options but obviously it didn't work. Now I'm trying to delete all caches to make cabal believe it has to reinstall eveything, but I have a lot of errors like "File.hs is missing (use --force to override)". I rm -rf'd .cabal and .ghc. What am I missing?
09:15:49 <vanila> it's fine to have it bu tit doesn't seem useful
09:16:19 <Haskellfant> vermeille: I can assure you that you are not the only one who hates cabal from time to time.
09:16:53 <Haskellfant> .ghc and .cabal should be enough if you don't use sandboxes
09:17:01 <Haskellfant> if you do, then do cabal sandbox delete in those folders
09:17:05 <srhb> Well, One a is completely isomorphic to a. Aside from guaranteeing some checks (like, hiding the value constructor and making smart ones instead) there isn't much point.
09:17:23 <vermeille> I *always* hate it. Wtf is this thing which can install things but not delete it? Why the hell can't it upgrade everything with one command? #%^@#$%@%^
09:17:34 <vermeille> Haskellfant: sadly I still have errors
09:17:35 <josephle> hating cabal was once a rite of passage. We'll see if sandboxes change that :P
09:17:41 <srhb> vermeille: Chant: "cabal is not a package manager"
09:17:50 <arboris> someone needs to write a package manager then
09:17:51 <arboris> !
09:18:02 <doismellburning> if cabal isn't a package manager, what is it?
09:18:08 <vermeille> I know what it's not. But can someone say what it is actually?
09:18:09 <arboris> there isn't one
09:18:13 <srhb> Well, cabal-install in this case, isn't a package manager
09:18:14 <Haskellfant> josephle: they make life easier but I had to spent 15 minutes yesterday resolving some conflicts despite sandboxes
09:18:37 <srhb> vermeille: A build automizer of kinds.
09:18:38 <josephle> good, I see nothing has changed at all
09:18:46 <Haskellfant> but you can't only blame cabal for conflicts
09:18:57 <arboris> it's especially painful if you want to install something like ghc-mod and hlint
09:18:57 <Haskellfant> if packages have constraints cabal can't do anything about it
09:19:15 <josephle> it's true, orphaned libraries/slow maintainers contribute to it as well
09:19:22 <josephle> cabal does try its best given the circumstances
09:19:26 <arboris> the whole thing is made worse by the fact that haskell does not have a proper module system
09:19:34 <srhb> arboris: Yes :(
09:19:36 <vanila> arboris, is that really an issue?
09:19:41 <albeit> What is the best to have attoparsec match on a specific number? I can do something like "choice [k <$ string v | (k,v) <- pairs]", where I encode the numbers as strings in "v"... but that's going to be much slower than matching direcly on the number...
09:19:54 <srhb> vanila: Ever tried an SML-like module system?
09:20:30 <Haskellfant> srhb: is an sml-like module system similar to what backpack will give us someday?
09:20:35 <vermeille> So, what could I do? Can someone explain to me why it can find files it just downloaded?
09:20:43 <josephle> there are some problems with the SML module system, but I think backpack is a more restricted form iirc
09:20:44 <vanila> I agree that SML style module systems are superior but i don't see how they're related to the cabal problems
09:20:49 <srhb> Haskellfant: I don't know what Backpack is
09:20:58 <srhb> vermeille: Start by posting your commands and errors to lpaste or something
09:21:29 <Haskellfant> srhb: http://blog.ezyang.com/2014/08/a-taste-of-cabalized-backpack/ this post does a better job at explaining it than I could :)
09:21:39 <srhb> Haskellfant: Thanks, I'll check it out a bit later :)
09:21:44 <arboris> vanila, i think so, if you look at opam it works much better
09:21:57 <Haskellfant> srhb: basically it allows you to depend on signatures
09:22:06 <srhb> Haskellfant: That's definitely part of the way!
09:22:38 <vanila> arboris, isn't that just opan being good and cabal sucking? I mean i agree that proper modules are way better than what haskell has just not sure it's the issue
09:22:42 <vanila> opam*
09:22:51 <josephle> that's probably the most important part of the module system: signatures and implementations are completely separate
09:23:00 * hackagebot aivika-experiment-cairo 1.3.1 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-1.3.1 (DavidSorokin)
09:23:02 * hackagebot aivika-experiment-diagrams 1.3.1 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-1.3.1 (DavidSorokin)
09:23:49 <vermeille> here it is http://lpaste.net/111917
09:26:00 <srhb> vermeille: That looks like it might be a bug in cabal. What version are you using?
09:26:29 <arboris> vanila: i think it also has to do with the way ghc links packages together
09:26:31 <vermeille> srhb: 1.16.0
09:26:42 <srhb> vermeille: Try grabbing an upgraded version from somewhere else.
09:26:55 <srhb> cabal-install, that is.
09:27:10 <vermeille> I can have a *down*graded version from apt-get
09:27:35 <arboris> if the interface of a library does not change and the system is modular it should be possible to link at runtime to whatever new version of the library is available
09:27:43 <srhb> vermeille: That probably won't help you. :)
09:28:33 <srhb> vermeille: Which version of ghc are you on anyway?
09:28:59 <vermeille> version 7.6.3
09:29:36 <srhb> vermeille: Ok, so at least your ghc should be compatible with that version of cabal-install.
09:29:52 <vermeille> That's what is provided by my debian repositories
09:33:40 <vermeille> okay, now I have cabal-install 1.20
09:34:54 <srhb> vermeille: Same error?
09:35:05 <vermeille> I don't know yet
09:35:14 <srhb> Oh, okay.
09:36:27 <vermeille> it takes ages to compile
09:40:47 <Yxven> I'm not having any luck installing sdl2 bindings. This is my current error: https://dpaste.de/k5RA I'm not having any luck googling it. Enum.hsi in the sdl2 source doesnt mention 'Main' anywhere
09:42:46 <vermeille> The error is still here.
09:43:00 <srhb> vermeille: But now with a different package presumably?
09:43:13 <Guest33137> Yxven: This error generally crops up when there is no explicit module <Name> line at the top of a file.
09:43:33 <Fer`> Hello, I tried installing ghc and haddock on debian but when i run
09:43:33 <Fer`>        haddock it says: haddock: internal error: No GhcDir found. Any idea how
09:43:33 <Fer`>        to fix that? I couldn't find anything on the interwebs
09:43:33 <vermeille> nope, the very same, srhb
09:43:42 <Guest33137> Yxven: I still don't understand why you're getting that for sdl, however.
09:43:49 <Fer`> erm, sorry for multiple lines, copy paste fail
09:43:55 <Yxven> Guest33137 This is the file https://github.com/polarina/sdl2/blob/master/Graphics/UI/SDL/Enum.hsc
09:43:58 <srhb> vermeille: But.. didn't you just install cabal-install version 1.20 something?
09:44:03 <srhb> vermeille: Why are you installing it again?
09:44:53 <vermeille> srhb: well, the question is worth asking. 1st because I'm raging as hell so my brain is kinda disconnected, and 2nd because
09:45:08 <vermeille> I thought it would be a way to check if the error was still there
09:45:23 <vermeille> (even if I don't care about the package being installed)
09:45:25 <srhb> vermeille: Good point. Well, I don't know what the issue is, sadly.
09:46:28 <vermeille> Thank you for trying to help me anyway :)
09:47:18 <srhb> vermeille: Perhaps you'll get more help from a relevant bug tracker :)
09:48:00 <albeit> If I'm working with very small ByteStrings, less than 10 bytes, is there ever a reason to use Lazy ByteStrings?
09:49:23 <vermeille> You're really convinced this is a bug. Anyway, I'll rage few hours again and do some bad things that would hopefully work
09:49:54 <srhb> vermeille: That or I'm egotistical enough to report issues to get help figuring out what's wrong. :-)
09:50:31 <srhb> Though personally I'd make sure to have completely fresh versions of GHC and cabal before doing anything.
09:50:33 <ReinH> albeit: maybe not? I bet some profiling would help you decide :)
09:50:52 <ReinH> chrisdone: I've got some bash scripts I'm thinking about converting to shell-conduit :)
09:54:53 <sbrg> So, what do people think about the traversable/foldable general prelude idea?
09:55:24 <vanila> sbrg, im not familair with it
09:55:44 <vanila> overall im not convinced on traversable/foldable, what's wrong with fmap?
09:55:47 <vermeille> srhb:
09:56:00 <sbrg> I just read about it -- but apparently, Foldable and Traversable are goign to be in the Prelude from 7.10
09:56:09 <vermeille> The problem is that cabal compiles a file and immediately is unable to find the corresponding .hi
09:56:23 <vermeille> (sorry for the failed hl)
09:56:51 <vermeille> It may be some path issue
09:58:15 <zq> why is 'where' not an expression?
09:59:06 <josephle> from what I can tell, 'where' is syntactic sugar for a let-binding
09:59:40 <josephle> but putting all your local bindings in one place is convenient
10:00:17 <zq> josephle: it actually isn't, which is the crux of my question
10:00:28 <josephle> really. today I learned...
10:00:53 <ReinH> zq: It's a reserved identifier used to signify a "where clause", but you probably already know that?
10:01:14 <vanila> oh you mean how like
10:01:15 <vanila> you can do
10:01:20 <vanila> 1 + (let foo = ... in ....)
10:01:22 <vanila> but you can't do
10:01:27 <vanila> 1 + (... where y = z)
10:01:54 <josephle> ReinH: I think he's asking why where-clauses aren't expressions
10:04:00 <ReinH> It has scoping rules that prevent it from being used as an expression.
10:04:14 <ReinH> At least, I think that's the motivation.
10:04:28 <ReinH> I suppose the "correct" answer would be "because the report says that it is not". ;)
10:04:42 <josephle> it seems that where-clauses and ML local declarations are somewhat analogous
10:04:52 <josephle> although local declarations have a larger scope
10:05:45 <zq> huh
10:06:25 <zq> my question is why it wasn't designed to be equivalent to let-in in the first place
10:07:10 <ReinH> zq: Because we already have let bindings
10:07:16 <ReinH> Why make something else that works the same with a different name?
10:07:41 <zq> let bindings are a superset of where clauses, you know
10:07:51 <ReinH> Are they?
10:07:58 <zq> strict superset
10:08:08 <ReinH> Are they?
10:08:20 <zq> what's your counterexample?
10:08:22 <josephle> actually, the scoping of a where-clause is different from that of a top-level let-binding
10:08:26 <vermeille> How can I know cabal / ghc 's library path?
10:08:30 <zq> christ
10:08:42 <zq> yes i know the scoping is different, which is why lets are a strict superset of wheres
10:08:49 <zq> as opposed to being equivalent
10:08:59 <zq> the difference in scoping is specifically why they're not equivalent
10:09:35 <ReinH> The difference in scoping is also let is not a superset of where
10:09:59 <zq> so to rephrase my question, why are the scoping rules different? "why make something else that works the same" isnt an answer, because without loss of generality, "why make something else that does less" is equally absurd
10:10:00 <ReinH> let can't be used to share bindings between, say, multiple guard expressions
10:10:16 <ReinH> It is an answer, because your premise is false
10:10:22 <ReinH> let is not a superset of where
10:10:48 <vanila> zq, I think that if where was an expression it would be hard to parse it
10:10:49 <zmbmartin> I am using mongodb. I just want to ensure my indexes. Here is what I have with the error -> https://gist.github.com/codedmart/fc1d71da45154671313a
10:10:54 <zq> ReinH: why do you keep repeating yourself? show me a counterexample where where works but let doesn't
10:10:54 <ReinH> As an example, I can't share a let binding between guards
10:11:01 <ReinH> zq: I already did
10:11:08 <zmbmartin> Anyone have an idea what how I can resolve this?
10:11:18 <ReinH> So perhaps I do need to repeat myself.
10:11:39 <vanila> zq, for example  foo where bar where baz  is it  (foo where bar) where baz, or  foo where (bar where baz)
10:12:00 <ReinH> zq: I don't want to engage in an adversarial discussion about let vs where. I'm sorry it has turned, and I'm going to absent myself now.
10:12:27 <zq> | ... = let ... in ... | ... = let .. .in ...
10:12:56 <zq> no wait
10:12:58 <zq> not even that
10:13:28 <zq> top_level blah = let whatever_you_want_to_share in retval | cond0 = ... | cond1 = ...
10:14:00 <josephle> zmbmartin: you're using ensureIndexes which has type (Action IO ()), in main which has type (IO ())
10:14:07 <vanila> zq, let binding in ____________ lasts forever essentially
10:14:30 <zq> ReinH: so you see, your counterexample isn't a counterexample
10:14:33 <ReinH> zq: The point is that you can share a where binding across things that are not the same expression. Turning them into the same expression by introducing a new binding so that you can use let on that single expression does not make let equivalent to where.
10:14:35 <vanila> zq, _____________ where binding, would be hard to know if a where is coming up
10:14:37 <zmbmartin> josephle: Yeah I got that, just not sure how to fix that.
10:15:23 <josephle> zmbmartin: since Action is just a synonym for (ReaderT MongoContext), I wonder if the mongodb library has a runAction function
10:15:38 <ReinH> zmbmartin: Generally via some sort of run function, like josephle suggests
10:15:43 <ReinH> Look at the docs for Action?
10:15:56 <zq> ReinH: you're totally missing the point. forget it.
10:16:07 <ReinH> zq: I agree that it's best that we forget it.
10:16:36 <ReinH> zq: I can at least offer http://www.haskell.org/haskellwiki/Let_vs._Where for more discussion
10:21:24 <zmbmartin> josephle ReinH I am not seeing a runAction or run. https://hackage.haskell.org/package/mongoDB-2.0.3/docs/Database-MongoDB-Query.html#t:Action
10:21:46 <zmbmartin> Unless I am missing something.
10:22:08 <zmbmartin> There is a liftDB but I am not sure if that is what I want or how to use it.
10:22:36 <josephle> zmbmartin: looking at the source, liftDB looks like what you want
10:23:27 <zmbmartin> josephle: How would I use that then? My quick try was off.
10:24:51 <josephle> do you get an error when you try to use (liftDB ensureIndexes) in main?
10:26:25 <zmbmartin> josephle: Yes that is what I tried first the gist is updated with error -> https://gist.github.com/codedmart/fc1d71da45154671313a
10:26:36 <zmbmartin> josephle: Thanks for you help.
10:28:27 <josephle> zmbmartin: actually, take a look at the access function
10:28:38 <josephle> do you have the other inputs?
10:28:57 <josephle> it seems the problem with using liftDB is that we don't know the MongoDB context
10:29:14 <josephle> while access would presumably use the other args to construct
10:29:27 <josephle> *construct the context
10:31:51 <zmbmartin> josephle: so access ensureIndexes?
10:35:04 <josephle> you'd need to provide a Pipe, AccessMode and Database
10:35:21 <josephle> so (access pipe accessmode database ensureIndexes)
10:35:31 <josephle> I don't know if you have those values on hand
10:36:14 <zmbmartin> josephle: Yeah let me try.
10:39:33 <zmbmartin> josephle: Thanks for all your help. I figured it out. I am stumbling along, but feel like I am getting better and better.
10:39:42 <zmbmartin> Also thanks ReinH
10:39:48 <josephle> always happy to help :)
10:40:09 <zmbmartin> access was it. I was just passing it something wrong the first try.
10:42:32 <Jeanne-Kamikaze> http://i.imgur.com/wqeWbof.jpg
10:42:56 <hiptobecubic> that reflection looks awful
10:42:59 <Jeanne-Kamikaze> not sure why glossy materials have convergence problems
10:43:05 <Jeanne-Kamikaze> awful = good or bad ?
10:43:10 <mauke> bad
10:43:13 <hiptobecubic> unless there's supposed to be a puddle on the ground
10:43:18 <Jeanne-Kamikaze> I still need to implement snell
10:43:32 <Jeanne-Kamikaze> it's a simple specular reflection atm
10:43:58 <hiptobecubic> What is it, in general? A game?
10:44:10 <hiptobecubic> Soviet bomb shelter simulator 2014
10:44:28 <Jeanne-Kamikaze> it's a path tracer
10:45:15 <gcganley> :t (***)
10:45:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:45:21 <Jeanne-Kamikaze> oh, I thought I was in #haskell-game :D
10:45:38 <mauke> "you think this is a fucking game?"
10:46:23 * hiptobecubic still wants to play "Soviet Bomb Shelter Simulator 2014"
10:48:12 <Jeanne-Kamikaze> can you handle non physically-based reflections ?
10:48:35 <Jeanne-Kamikaze> I can give you access to an alpha preview
10:58:07 * hackagebot wai 3.0.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.2 (MichaelSnoyman)
11:11:19 <josiah14> I could use some guidence, I've searched around online but I'm not quite satisfied with the questions/answers I found as most of them seem to deal with what to do with 0 Haskell experience:
11:12:49 <josiah14> I read the Learn You a Haskell for Great Good book, and I started writing an IO intensive app to practice what I learned (basically a clone of Powerline (google it) that focuses on the cli prompt for now).  There's two things I'm trying to find, now
11:14:58 <joseph07> josiah14: powerline is hard to google because, you know, powerlines
11:14:59 <Angry> a vim module? https://github.com/Lokaltog/powerline
11:15:14 <josiah14> 1: guidance with making full use of the Haskell type system - is  there a resource I can go to now that will help get me the intuition for when to roll my own Monad, like, one that might defer IO operations until the time comes when it must be output, how to organize other abstract algabraic types, how to understand quicker the types that others have created when reading open source code etc. basically, how to fully utilize the ty
11:15:30 <josiah14> oh, try lokaltog powerline
11:16:14 <josiah14> the other thing I would like is if there is a place to get good feedback on the code I have written from people more experienced
11:16:32 <joseph07> josiah14: as to the second part: you're probably in the right place
11:17:09 <cdk> josiah14: lazy IO will "defer IO operations until the time comes when it must be output", so that's taken care of :)
11:17:31 <josephle> josiah14: #haskell is happy to help with your learning, but remember that #haskell-beginners is more dedicated to that :)
11:17:50 <josiah14> Angry: that's the right thing you have there.  I think Powerline was originally and primarily intended for vim, but it also allows you to configure the tmux, ZSH, TCSH, BASH, FISH, etc. status lines/prompts as well
11:18:08 * hackagebot cndict 0.3.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.3.1 (DavidHimmelstrup)
11:19:47 <josiah14> cdk: In that case, I think the main thing I'm concerned with in my code that I'm writing is coming up with a more robust type system for my program - somethnig less limiting.  Right now, I define a prompt segment as an IO (Maybe String), but it would be nice to generalize that to something like PrompSegment m to allow more flexibility
11:20:16 <josiah14> but I'm not used enough to haskell to know really what the best way is to go about generalizing the patterns in my code
11:20:34 <josiah14> I'll share what I have here
11:20:51 <josiah14> https://github.com/josiah14/lambdaline
11:20:52 <cdk> josiah14: perhaps "type PromptSegment = MaybeT" is what you want
11:21:50 <josiah14> cdk: I read about Monad Transforms just 2 days ago, and I also felt inclined to think that might be a good way to do it
11:22:39 <cdk> looking at your PromptSegment module, it seems like you're putting things in Monad (with return) for no reason.
11:23:05 <cdk> ex: makePromptSegment, space, bold
11:23:11 <cdk> those are all pure functions
11:23:38 <josiah14> so you think they should be applicative rather than monadic?
11:23:56 <cdk> I think they should be pure
11:24:02 <josiah14> I thought of those functions as transforming an existing prompt segment
11:24:32 <cdk> but they're not: space :: Maybe String -> PromptSegment doesn't transform an existing segment
11:24:44 <cdk> it should be space :: Maybe String -> Maybe String
11:25:10 <cdk> or even better, String -> String and use fmap
11:25:53 <cdk> my point is that you should try to have pure (non-monadic) code whenever possible
11:26:19 <josiah14> cdk: I'm worried that such a change might clutter up the api for users that might not be used to Haskell.  I'd ideally like the Main.hs file to be the config file, such as is the case for XMonad - configuration happens by defining your own main method
11:27:21 <josiah14> although I suppose I could try to alias fmap with something else
11:28:08 <josiah14> but I think of bold as transforming the value inside of the PromptSegment functor to be o bolded string, and likewise for color and other functions.
11:29:30 <josiah14> cdk: I'm not trying to argue, just concerned about keeping the api for building a prompt as simple and easy to understand as possible
11:29:30 <cdk> how does bold transform something inside a PromptSegment, it _produces_ a PromptSegment
11:30:00 <cdk> that's a valid concern, my experience is that pure functions are the "simple and easy to understand" ideal.
11:31:06 <josiah14> so maybe a better way to express things is like 'currentDirectory <$> bold <*> color red <*> appendSpace'
11:31:35 <chaosmasttter> :t mapM
11:31:36 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:31:43 <josiah14> allowing bold and color and appendSpace to be pure functions lifted into the promptsegment
11:32:21 <cdk> or what about this: fmap (bold . color red . appendSpace) currentDirectory
11:32:37 <cdk> in your example, bold, color and appendSpace are _not_ pure
11:32:57 <cdk> I think you're confusing your syntax a little bit
11:33:31 <josiah14> that's a good possibility
11:34:24 <cdk> currentDirectory sounds like it would be IO (interacting with the file system), but transforming a String (the filepath) should be an entirely pure operation
11:34:47 <joseph07> josiah14: It's best to build the thing using the simplest pieces possible, and then compose an api out of that. For instance, with cdk's suggestion of fmap (bold . color red . appendSpace) currentDirectory you could easily abstract that to add [transforms] segment, folding transforms with function composition
11:35:14 <josiah14> sure, but that's what the <$> is for, to lift the pure operations like bold into the functor
11:35:33 <cdk> yes, (<$>) = fmap
11:35:39 <cdk> just infix
11:36:30 <cdk> you could do bold . color red . appendSpace <$> currentDirectory (i think <$> has the correct fixity)
11:36:50 <cdk> > (+1) . (*2) <$> Just 4
11:36:52 <lambdabot>  Just 9
11:36:55 <josiah14> ooh, I see what I did
11:37:42 <josiah14> yah, still getting used to thinking of things the right way, yah, <*> just adds arguments to the function being lifted into
11:38:02 <cdk> kind of, yes
11:38:55 <josiah14> yah, kind of is good enough - I remember struggling through working out the details of <$> and <*> and all that stuff in the LYAH book - and how currying actually gives you some really interesting flexibility
11:40:20 <josiah14> cdk: I'm glad you pointed this out.  I think this actually simplifies the api
11:41:43 <cdk> no problem
11:42:06 <josiah14> I wasn't aware of the haskell beginners channel
11:42:14 <josiah14> I'll hop over there and ask some more stuff
11:42:57 <cdk> > zip <*> map (+1) $ [1..5] -- josiah14: <*> is fun :)
11:42:59 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
11:44:39 <josiah14> cdk: I agree.  I actually found Applicative Functors to be the gateway to understanding most Haskell type interactions.  After that, Monads were really simple to understand.  Leads me to wonder why people talk so much about Monads when learning Haskell
11:45:24 <tnks> Monads came first, I guess
11:45:26 <cdk> Monads were around before Applicative Functor, so that could be it
11:45:49 <Dashkal> Is there a way to pull in Control.Comonad without getting the instances with it?  Trying to write those instances as an excercise.
11:46:20 <cdk> Dashkal: try import Control.Comonad (Comonad(..))
11:46:27 <mm_freak_> hi there
11:46:29 <cdk> or maybe without the ..
11:46:41 <crobbins> Dashkal: you can't import a module without getting the instances it defines
11:46:47 <Dashkal> Sadly, no dice.
11:46:48 <cdk> ah, nvm
11:46:49 <Dashkal> Danke, crobbins
11:46:50 <dfeuer> Not no way, not no how.
11:46:53 <Dashkal> Will just rewrite the class then
11:47:32 <crobbins> yeah, if i'm doing an exercise like that i'll just write a new class like `class Comonad' where ...`
11:50:41 <Dashkal> It was a good idea anyway.  Forcing me to figure out how to implement extend in terms of duplicate and fmap (no spoilers please)
11:54:00 <isomorpheous> :t (+1) . (*2)
11:54:01 <lambdabot> Num c => c -> c
12:08:12 * hackagebot Boolean 0.2.3 - Generalized booleans and numbers  http://hackage.haskell.org/package/Boolean-0.2.3 (ConalElliott)
12:22:12 <albeit> Is there a way to pad a ByteString? Like f 5 "abc" -> "  abc"?
12:23:15 <crobbins> albeit: are you looking for an existing function or how to implement it?
12:23:27 <albeit> crobbins: Hopefully existing
12:24:25 <ParahSailin> @hoogle Int -> ByteString -> ByteString
12:24:26 <chrisdone> haha
12:24:27 <lambdabot> Data.ByteString drop :: Int -> ByteString -> ByteString
12:24:27 <lambdabot> Data.ByteString.Char8 drop :: Int -> ByteString -> ByteString
12:24:27 <lambdabot> Data.ByteString take :: Int -> ByteString -> ByteString
12:24:38 <ParahSailin> probably not existing
12:25:00 <chrisdone> Neil Mitchell's Haskell Blog: Why Traversable/Foldable should not be in the Prelude (neilmitchell.blogspot.co.il)
12:25:01 <chrisdone> 38 points submitted 5 hours ago 134 comments
12:25:15 <chrisdone> ^ classic controversial post with bikeshedding
12:25:33 <chrisdone> only 38 upvotes, 134 comments in 5 hours. i don't even need to look inside
12:25:55 <vanila> I agree that Traversable/Foldable dont belong there
12:26:31 <vanila> to be honest I thinkt hey should delete prelude entirely
12:26:46 <vanila> it only gets in the way
12:28:16 <Cale> vanila: uhhh, that's a bit extreme I think
12:28:38 <vanila> I may be a bit extreme when it comes to this sort of thing then
12:28:51 <vanila> I do very much understand that they aren't going to do things 'my way'
12:28:58 <Cale> The Prelude is a fairly significant portion of Haskell's user interface
12:28:59 <chrisdone> good satire, 10/10
12:29:15 <chrisdone> the discussion between you two is probably exactly what's going on in that reddit submission =)
12:29:47 <sbrg> i don't see the reason why they want to make such a drastic change, but I don't care either way
12:29:59 <doismellburning> lol
12:30:03 <vanila> I don't even know where  Traversable is used except Lens
12:30:03 <sbrg> chrisdone: it is definitely bikeshed stuff, yes. I took a peek earlier today
12:30:06 <Cale> I'm not sure I agree with putting Foldable/Traversable in the Prelude, but my reservations have more to do with the fact that Foldable is sort of an unnatural abstraction.
12:30:34 <sbrg> Cale: how so?
12:31:03 <Cale> sbrg: It has a lot of methods in it.
12:31:17 <Cale> sbrg: and writing down all the laws they ought to satisfy is a bit awkward
12:31:36 <bitemyapp> chrisdone: there were good and bad points in the thread.
12:31:54 <bitemyapp> vanila: uhhh, are you serious? I clean up peoples' code with traverse all the time.
12:32:04 <bitemyapp> vanila: it's a pretty fairly common pattern.
12:32:42 <bitemyapp> blah -> return $ Constructor; otherblah -> return $ OtherConstructor (otherblah >>= otherFn)
12:32:48 <bitemyapp> happens all the time.
12:33:13 * hackagebot tagsoup 0.13.3 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.13.3 (NeilMitchell)
12:34:58 <Cale> Perhaps Foldable could be pared down to just foldMap
12:35:53 <bitemyapp> Cale: I just don't see how that helps or fixes anything.
12:37:36 <Cale> Well, if we can just work out laws for foldMap alone, we can say the rest of the operations must have semantics according to their definitions in terms of that
12:38:13 * hackagebot language-c-quote 0.9.0 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.9.0 (GeoffreyMainland)
12:38:29 <Cale> The thing is, I don't think you can really write sensible laws for foldMap without introducing some other things
12:38:42 <Cale> (but those other things are not the other methods of Foldable!)
12:40:15 <Cale> When t creates monoids, you could insist that  foldMap f (t <> t') = foldMap f t <> foldMap f t', but there's no insistence by Foldable that t a be an instance of Monoid.
12:40:46 <Cale> and I don't think that law holds in the case of Set
12:41:22 <LunarJetman> Where they were put in boxes, And they came out all the same. https://www.youtube.com/watch?v=2_2lGkEU4Xs
12:43:16 <doismellburning> win 65
12:43:18 <doismellburning> sorry
12:43:30 <Cale> The reason I'd be hesitant to put Foldable in the Prelude is that it's not *obviously* the right abstraction.
12:43:53 <Cale> and as we've seen, it's really hard to get people to change the stuff in Prelude once it's in there
12:44:40 <Cale> edwardk: There you are. What are the laws for foldMap?
12:45:20 <Cale> edwardk: Supposing that we pared Foldable down to just foldMap (which is a minimal complete definition), what would its laws be?
12:46:18 <edwardk> Foldable is pretty much defined in terms of foldMap. it can anything it wants, everything else is defined in terms of how it relates to foldMap ;)
12:46:20 <edwardk> Foldable literally has no constraints on the behavior of foldMap
12:46:24 <edwardk> we don't require it to visit every a in the structure even
12:46:28 <edwardk> its basically that we have f a -> [a]  -- but we don't have that, we only have it to the Monoid r => (a -> r) -> r -- form, because we don't rule out infinite recursion in snoc-lists, etc.
12:47:11 <edwardk> so take foldMap as the mapping from f a to Monoid r => (a -> r) -> r, then all the other operations are choices of Monoid
12:48:06 <edwardk> newtype Free p a = Free { runFree :: forall r. p r => (a -> r) -> r }  -- is arguably the right definition of a 'Free Monoid' in haskell in the presence of infinite recursion, reassociation is permitted by the law, which you can only inductively apply a finite number of times
12:48:13 <Cale> This is the reason that I'm not so sure about putting it in the Prelude. I suppose there are plenty of other Prelude classes already with not-very-clearly-specified laws
12:48:20 <edwardk> so foldMap is basically the mapping from f a -> Free Monoid a
12:48:40 <vanila> The best thing to do is make prelude tiny, people can import any library they want to program with
12:48:42 <Cale> But I'd feel a lot more comfortable if Foldable was "obviously the right thing" as a mathematical structure with natural laws.
12:48:47 <vanila> I  have to importnat Control.Monad.Whatever when I program in haskell
12:48:49 <edwardk> now we can take toList as the mapping f a -> [a] that is as defined as it can be
12:48:58 <vanila> that's not reason to include all the monads in the prelude
12:49:00 <edwardk> Foldable is a building block to get to Traversable
12:49:15 <edwardk> and it gets you mapM_, etc. that are important components
12:49:44 <edwardk> it isn't being removed as a superclass of Traversable. I'd fight that kind of lobotomy tooth and nail
12:50:14 <shachaf> If you have Foldable + Functor, is there a reasonable law that you can state?
12:50:15 <Cale> What would the consequences of that be?
12:50:29 <edwardk> Cale: you'd kill lens for one.
12:50:38 <edwardk> Cale: I use folds fairly heavily =P
12:50:59 <vanila> so if this being in the prelude could kill lens, it's  better to kick more thinsg out of prelude - in case they kill something else!
12:51:14 <edwardk> vanila: no, the issue is breaking shit that already works would kill lens
12:51:17 <edwardk> not this being in the Prelude
12:51:22 <vanila> It's been a big problem for a long time that 'fail' was in the monad class, and it was too much trouble to remove it because they forced it uopon us by having it in prelude
12:51:25 <edwardk> removing something we already have would break things that already works
12:51:35 <edwardk> vanila: we're planning to fix fail
12:51:42 <vanila> Thank goodness!
12:51:51 <edwardk> vanila: not immediately, but its on the TODO list
12:51:57 <Cale> vanila: Just saying "let's not have a common definition of the Monad class" is a non-solution to the problem though
12:52:26 <edwardk> vanila: that is assuming we don't get ripped to shreds by the attempts to bikeshed what we're doing in the short term and survive to get there ;)
12:52:30 <bitemyapp> edwardk: is it getting turned into mzero?
12:52:41 <bitemyapp> or have I misunderstood fail?
12:52:44 <edwardk> bitemyapp: there are multiple options on the table, its not fixed yet
12:52:46 <Cale> vanila: After all, everyone is still free to define their own Monad classes, but they don't, because that doesn't fix anything. The whole advantage of having the class in the first place is that there's lots of code that can be shared between users of it.
12:52:52 <bitemyapp> edwardk: is there a thread/ticket I could look at?
12:52:56 <edwardk> bitemyapp: no
12:53:02 <bitemyapp> oh, okay. Sorry to bother you.
12:53:05 <edwardk> bitemyapp: because we only have lennart running around campaigning for it
12:53:10 <Cale> I'd support splitting fail into its own class
12:53:25 <edwardk> bitemyapp: and we've acknowledged that it'd be a good idea to do something about it, and spj has given the committee permission to act on the issue
12:53:27 <bitemyapp> Cale: FSR I thought it was ~ mzero in peoples' minds.
12:53:39 <Cale> bitemyapp: That's often the case
12:53:44 <bitemyapp> but not always, I take it?
12:53:47 <edwardk> but we need to get to where we can make a concrete proposal, get it through, put in warnings and probably act in 7.12
12:53:58 <bitemyapp> Cool. I look forward to it :)
12:54:12 <Cale> Well, it has a String argument, and some people actually make use of that to get better runtime error messages.
12:54:19 <edwardk> but as a committee we're not currently acting to formulate such a proposal, why? because there is some stuff in the works that if it happens might dramatically reduce the impact of such a proposal
12:54:42 <edwardk> so it behooves me not to force this function until we have the machinery in place to make it less painful for users if we have something possibly imminent
12:54:47 <edwardk> rather than just flail around
12:55:01 <Cale> e.g. if you're expecting that something always produce a nonempty list, and you write (x:xs) <- ... in the IO monad, this turns into something which throws an exception with a line number in it if that ever fails.
12:55:01 <edwardk> otherwise we generate a lot of heat and not a lot of motion
12:55:25 <edwardk> bitemyapp: mzero implies you have mplus with it
12:55:39 <edwardk> bitemyapp: the proposal from lennart is to just make a separate MonadFail class and have fail desugar to that
12:55:44 <bitemyapp> Right, because that's how it's defined. Otherwise it's a lawless identity.
12:55:47 <edwardk> no tie to mplus/mzero, etc.
12:55:59 <Cale> We did at one point have a separate MonadZero
12:56:00 <edwardk> its a pretty simple proposal in that regard
12:56:16 <bitemyapp> Cale: doesn't that sort of thing (Point/Pointed?) make people cranky if there are no laws?
12:56:23 <bitemyapp> edwardk: sounds like it.
12:56:27 <Cale> Well, there can be some laws.
12:56:28 <edwardk> i'm not a huge fan of MonadZero, and i think i'd just as soon take lennart's proposal sans bikeshedding
12:56:38 <ReinH> edwardk: o/
12:56:55 <Cale> mzero >>= k = mzero, especially
12:56:59 <edwardk> sure, we can write some laws for it, and describe some interaction with it and MonadPlus, etc.
12:57:29 <Cale> I can imagine having MonadZero in addition to MonadFail
12:58:02 <edwardk> i can imagine lots of things, but i want whatever transition we make to be something fairly simple to explain and which doesn't look like its obviously overcomplicating things to folks who are borderline on the change at all
12:58:33 <bitemyapp> Cale: ah right
12:59:07 <Cale> btw, one thing which the Haskell' committee might want to be aware of if MonadFail gets separated out is that the Haskell 1.4 report includes a description of how GHC actually desugars do-notation, and it doesn't match Haskell 98 (and iirc 2010)
12:59:10 <edwardk> if we start splintering Monad into MonadFail, MonadOr, MonadZero, etc. the upgrade path isn't clear
12:59:12 <vanila> I just think that all these problems would be avoided if there was no prelude at all
12:59:32 <vanila> all you need to do is have libraries that define the functions etc. that people are using
12:59:33 <Cale> It currently doesn't matter so much, but if fail were in a separate class, it would be much more noticeable
12:59:39 <edwardk> vanila: igloo brought that proposal up a year ago, it was more or less panned
12:59:59 <vanila> yeah I would be really really surprised if someone took up such a good idea
13:00:03 <vanila> it's too radical
13:00:12 <edwardk> i'd be strongly against it personally
13:00:13 <Cale> vanila: If you don't want to use the Prelude, you don't have to, you know
13:00:15 <vanila> even the scheme guys failed horribly
13:00:24 <vanila> by creating a standard like 50x bigger than R5RS
13:00:27 <edwardk> i just want a Prelude that doesn't actively penalize me for abstraction
13:00:31 <vanila> but they're pulling things back together with R7RS hopefully
13:00:40 <edwardk> r6rs failed because it was specified before it was implemented =P
13:00:57 <edwardk> and they didn't focus so much on actual implementability as putting in everything they might possibly need
13:00:59 <vanila> R6RS was probably an attempt to kill scheme tbh
13:01:05 <Cale> edwardk: I kind of feel like people don't have enough love/appreciation for universal datatypes like lists though
13:01:07 <edwardk> vanila: succeeded, now we have racket
13:01:14 <vanila> edwardk, why would you be against no prelude btw?
13:01:21 <vanila> yeah, racket.. the systemd of schemes :)
13:01:34 <edwardk> vanila: you're asking me to pay a tax in every single module of code i write or have written for all time
13:01:41 <napping> vanila: rather anachronistic, don't you think?
13:01:51 <xplat> scheme is like cockroaches, you can't kill it, only make it trickier and sneakier
13:02:01 <vanila> edwardk, don't you import like 10 modules per file though? What's one extra
13:02:06 <edwardk> vanila: on the other hand you can have your feature yourself today just by using {-# LANGUAGE NoImplicitPrelude #-}
13:02:06 <vanila> xplat, haha
13:02:15 <edwardk> since currently you are the minority opinion, you pay =P
13:02:34 <bitemyapp> vanila: not really no.
13:02:56 <vanila> fair enough :)
13:03:00 <edwardk> vanila: no Prelude is a tax on every newbie, not just on experts
13:03:02 <bitemyapp> vanila: lens isn't really representative of your "average" ekmett codebase. It's a culmination/meeting point of many things.
13:03:08 <xplat> i vote replace prelude with Control.Lens
13:03:11 <xplat> (not really)
13:03:14 <edwardk> xplat: =P
13:03:22 <Cale> I want to be able to write genuine one liners in Haskell. If you get rid of the Prelude, that isn't really possible anymore.
13:03:25 <bitemyapp> I don't really mind Prelude as an overall thing, just warts like mapM/mapM and map/fmap.
13:03:41 <vanila> Cale, All the cool one liners I gt from this channel fail in a .hs file!
13:03:46 <vanila> because I have to import extra stuff
13:03:49 <bitemyapp> but I'm not going to seriously propose killing map because breaking stuff for not a particularly strong benefit sucks.
13:03:51 <vanila> Control.Arrow or something
13:04:00 <Cale> vanila: Yeah, those aren't the sort of thing I'm talking about
13:04:27 <xplat> heh, one reason i'm starting a silly 'own language' project now
13:04:42 <xplat> is that there seems to be a lot of good energy in the haskell community
13:04:53 <vanila> xplat, cool! what kind of language?
13:05:24 <xplat> but a lot of it is being wasted on wartwards compatibility
13:05:46 <bitemyapp> xplat: have you seen languages like Clojure and Python?
13:05:55 <Cale> bitemyapp: lol
13:06:18 <bitemyapp> xplat: we're like...living in a transhuman paradise when they and still refusing indoor plumbing on the basis that it offends their profane gods.
13:06:23 <bitemyapp> are still*
13:06:48 <Cale> bitemyapp: That doesn't mean Haskell doesn't suck, it's just less broken than those languages.
13:07:03 <bitemyapp> Cale: my point is that we should try very hard not to forget how huge the gap is.
13:07:04 <Cale> (by a decent margin mind you!)
13:07:13 <Cale> But there's too much hype as it is
13:07:17 <Cale> We need less hype
13:07:22 <bitemyapp> Cale: I have to do Python and Clojure for my 9-5 and it's horrendous.
13:07:37 <cite-reader> bitemyapp: I do PHP. I will trade you.
13:07:41 <bitemyapp> I don't have an opinion on hype. There can't be that much of it because most coders don't believe it.
13:07:44 <bitemyapp> cite-reader: no.
13:08:00 <bitemyapp> whereas plenty believe nodejs's manual CPS'ing is "webscale"
13:08:13 <vanila> :/
13:08:27 <J_Arcane2> bitemyapp: Ouch. I'm sorry.
13:08:29 <tommd> If you're asking to trade jobs, what is keeping you at your current job? Stability? (/blah)
13:08:39 <Cale> Hype doesn't ever help improve things. I'm not saying you're not allowed to appreciate what's good about something, but if you want to improve things, you eventually have to focus on what's worse than it could be.
13:08:41 <J_Arcane2> clojure makes me see red.
13:08:43 <xplat> i'd kind of like there to be a language now like early haskell 1.x ... the design decisions that turned out badly remade, the good stuff simplified and rationalized and standardized, and lots of room left open for super-futuristic experimentation
13:08:56 <bitemyapp> tommd: I'm actually responsible for having created a couple of Haskell jobs, but one of my requirements is that I work remotely from Texas.
13:08:56 <vanila> xplat, that sounds great
13:09:03 <napping> xplat: throw in some row-variable polymorphism while you're at it
13:09:07 <bitemyapp> J_Arcane2: yeah, I didn't know any better before. Now I do.
13:09:11 <vanila> xplat, are you interested in writing  acompiler for it?
13:09:18 <vanila> napping++ great idea
13:09:21 <bitemyapp> tommd: if I can't stay in Texas or work at an office in Austin, it's a no-go.
13:09:32 <_tca> sounds like you guys just described Ur/Web
13:09:35 <xplat> i'm interested in forking ghc maybe
13:09:54 <dnkndnts> xplat: what about idris?
13:10:05 <bitemyapp> tommd: well, it's not an absolute no, but it would take Haskell+$$$ to get me to leave Texas.
13:10:06 <Cale> I definitely think we could stand to see some more lazy functional programming languages
13:10:09 <bgamari> anyone know of a parsing library more suitable than parsec/attoparsec/trifecta for parsing things other than strings?
13:10:14 <napping> xplat: looking at MLPolyR and O'Caml's object system and stuff, I've long suspected that you could get a pretty decent object system
13:10:15 <vanila> xplat, forking ghc sounds kind of painful - it's like 1GB
13:10:21 <vanila> that's not something i'd want to take on
13:10:25 <bitemyapp> bgamari: such as?
13:10:34 <xplat> dnkndnts: i don't like some of the design decisions of idris, including non-laziness
13:10:41 <J_Arcane2> bitemyapp: I'm a big Racket fan, and seeing what Clojure does to Lisp makes me gape in horror. The whole thing just feels like one giant hack that went too far.
13:10:45 <bgamari> bitemyapp, [Bool], for instance
13:10:45 <bitemyapp> xplat: that made me grumpy. I'm not jazzed about Eff either.
13:10:58 <vanila> Eff is really really awesome
13:10:59 <digitalmentat> bitemyapp, do you go to the Haskell meetups in ATX?
13:11:01 <bitemyapp> J_Arcane2: *shrug*
13:11:07 <napping> Is Eff even intented to be a production language?
13:11:08 <bitemyapp> digitalmentat: and pay for the pizza, yes.
13:11:09 <Cale> vanila: Well, it's nicely modular. If you can compile your language to system FC, there's not much point in redoing all the backend work yourself.
13:11:12 <_tca> bitemyapp: what's your problem with eff?
13:11:13 <bitemyapp> digitalmentat: I've already met you.
13:11:14 <vanila> napping, it's a research experiment
13:11:26 <vanila> but it's producing some really cool results!
13:11:27 <digitalmentat> I'm sure we have but I don't know your username :)
13:11:30 <napping> I thought it was pretty clearly a research language, with decently advertized horrendous asymptotic complexity problems and all
13:11:32 <bitemyapp> _tca: I never had a problem with Monad Transformers to begin with.
13:11:34 <vanila> we can definitely learn a lot from Eff
13:11:36 <bitemyapp> digitalmentat: Chris Allen
13:11:42 <xplat> vanila: i wouldn't want to sacrifice all the intellectual labor that went into GHC, especially the backend and runtime which seem pretty fine how they are
13:11:45 <bitemyapp> digitalmentat: https://twitter.com/bitemyapp
13:11:47 <digitalmentat> ahh, hello sir!
13:12:03 <bitemyapp> digitalmentat: I'm holding off on any startup stuff so I can stay with current company, focus on writing the book, get some community work done.
13:12:13 <napping> bitemyapp: would you prefer Java?
13:12:18 <digitalmentat> nice!
13:12:19 <BeardedCoder> digitalmentat: You in Austin?
13:12:24 <digitalmentat> yus
13:12:27 <bitemyapp> digitalmentat: I'm considering making my long term priority finding work in Haskell rather than starting a company.
13:12:32 <digitalmentat> hmmm
13:12:34 <digitalmentat> talk to me then
13:12:44 <xplat> vanila: the problems with haskell-as-it-is come from being distorted by a mostly-fixed interface, that distortion has less and less effect as you go further in the compilation pipeline
13:13:30 <Cale> bitemyapp: How do you use twitter as much as you do without shouting at your keyboard? Whenever I find something on twitter which I might like to reply to, I end up really frustrated about the awkward message length restriction.
13:14:19 <chrisdone> the discussion turned out to be quite interesting
13:15:05 <bitemyapp> Cale: I grew accustomed to thought-compression and threading.
13:15:28 <bitemyapp> Cale: it's not great, particularly threading, as you have to wait between tweets to stitch one to the next. An auto-threading client would be glorious.
13:15:37 <bitemyapp> I've considered writing a client that does it for me.
13:15:50 <xplat> when i compress my thoughts i always end up accused of speaking in some strange alien language
13:15:56 <chrisdone> i found while reading through the reddit discussion that i have a bias towards improved documentation
13:16:15 <Cale> Yeah, I end up using weird grammatical contortions to reduce the number of words needed.
13:16:35 <dnkndnts> has anyone here tried Elm? i discovered it today, and it's... really, really impressed me.
13:16:53 <chrisdone> i.e. the classic problem of 'fmap or just map?' i wonder whether the question arises because the haddocks aren't elaborate and GHC's errors aren't good
13:17:17 <chrisdone> if we improved both, would there be a question?
13:17:21 <hiptobecubic> dnkndnts, watch the strangeloop talk before you go on.
13:17:23 <bitemyapp> chrisdone: who doesn't?
13:17:24 <xplat> i just end up saying things in ways that nobody less like me than me-last-week would understand
13:17:32 <bitemyapp> chrisdone: oh you mean as opposed to changing/breaking things?
13:17:35 <chrisdone> bitemyapp: did you read the reddit discussion?
13:17:35 <dnkndnts> hiptobecubic: link?
13:17:38 <hiptobecubic> dnkndnts, "controlling time and space" I think it's called.
13:17:43 <dnkndnts> hiptobecubic: ok
13:17:53 <bitemyapp> chrisdone: yeah but I haven't memorized it ^_^
13:17:56 <dnkndnts> hiptobecubic: i'll go watch it now. i'm very interested in this topic
13:18:18 <hiptobecubic> dnkndnts, it's about FRP in general, but by the creator of elm and with a lot of discussion about what elm does and doesn't do, etc
13:18:28 <hiptobecubic> along with some other FRP systems. it was really enlightening for me
13:18:30 <chrisdone> bitemyapp: no, the the classic map vs fmap comes from haskell 98 that map's type is simpler and good for newbies
13:18:32 <dnkndnts> hiptobecubic: i have to do a lot of front-end work at my job, but i'm given extreme liberties, so i'm probably going to try Elm for my next project
13:18:46 <bitemyapp> chrisdone: I know. I remember the pre-98 map ;_;
13:18:52 <dnkndnts> hiptobecubic: so far, FRP in general has thoroughly impressed me
13:18:55 <jfischoff> chrisdone: I think you are right that it is mostly a documentation and errors problem.
13:19:08 <bitemyapp> chrisdone: the problem is that orthogonality generally means wider intersection of more concepts
13:19:13 <jfischoff> The documentation part seems easier to fix
13:19:17 <dnkndnts> hiptobecubic: previously i mostly used Angular for front-end
13:19:23 <bitemyapp> I'd say nicer errors on polymorphic values would help newbies a lot.
13:19:32 <chrisdone> Lennart Augustsson made a very compelling 5 minute video demonstrating how a simple improvement to error messages can change a useless message into a very useful message
13:19:39 <bitemyapp> get slapped in the face with a bunch of `Num a => a` when they were trying to do arithmetic befuddles people.
13:19:41 * jfischoff nods
13:20:31 <jfischoff> :t map (+) [1,2,3]
13:20:32 <lambdabot> Num a => [a -> a]
13:21:03 <hiptobecubic> dnkndnts, i've been playing with angular lately. It doesn't seem terrible
13:21:09 <hiptobecubic> other than the javascript
13:21:25 <dnkndnts> hiptobecubic: it's much better than the raw DOM or jquery, IMO
13:21:31 <chrisdone> given the simplicity of Lennart's solution, it seems that few people have actually thought much about the problem
13:21:41 * jfischoff nods
13:21:42 <napping> chrisdone: Beginners not dealing with Num and Functor and so on sounds reasonably nice
13:21:51 <xplat> maybe GHC should give example monotypes for polymorphic types using some kind of type-level Arbitrary
13:21:53 <hiptobecubic> dnkndnts, I still don't fully grasp how to structure everything. But i just started doing web-anything pretty recently
13:21:59 <vanila> I think beginnres should use Functor
13:22:02 <vanila> Functor is really good
13:22:05 <vanila> Num is atrocious
13:22:16 <napping> I think bringing in those things might be a bit confusing even with excellent error messages and documentation
13:22:23 <jfischoff> There is this newtype of Haskell beginners that we donâ€™t think about much
13:22:24 <napping> but maybe that's more appropriate for a tool like Helium?
13:22:27 <chrisdone> that's a strong word for a conceptual computing abstraction
13:22:38 <jfischoff> the beginners that learn haskell on large codebase at a company
13:22:43 <jfischoff> they canâ€™t ignore functor
13:22:45 <napping> Hmm
13:22:46 <chrisdone> actually i do commend GHC's more recent error messages on other things
13:22:48 <napping> I suppose not
13:22:59 <dnkndnts> hiptobecubic: go through codeschool.com's angularJS tutorial (it's free, unlike most of their stuff) -- it's a clear, modern introduction to angular
13:23:11 <chrisdone> it suggests instances, suggests identifiers i might've meant to type, extensions i might need to enable. those things are very handy
13:23:19 * jfischoff nods
13:23:22 <chrisdone> so it's far from unprecedented for GHC to be helpful
13:23:26 <hiptobecubic> I did, actually. It was good yeah. I felt like it had too much prewritten code actually.
13:23:31 <dnkndnts> hiptobecubic: use that as your central authority for learning it (most other sources i found were out of date and use significantly inferior... stlye?)
13:23:33 <chrisdone> jfischoff =)
13:24:07 <hiptobecubic> dnkndnts, It's annoying to use as a reference though because you have to keep clicking around randomly to get to the relevant part of the course.
13:24:18 <hiptobecubic> dnkndnts, would be better if it were indexed properly somehow
13:24:29 <hiptobecubic> It was really nicely done though.
13:24:31 <dnkndnts> hiptobecubic: totally agreed there. i probably signed up for 10 different anonymous accounts for that exact reason when learning angular
13:24:32 <bitemyapp> Is there a publisher for programming books that'll let me submit LaTeX?
13:24:34 <chrisdone> jfischoff: yeah -- also we can consider other languages
13:24:38 <bitemyapp> this has really rankled me recently.
13:24:46 <dnkndnts> hiptobecubic: but the actual content is fantastic
13:24:51 <chrisdone> do pythoners and rubyists or C# programmers start out with toy types and functions?
13:25:10 <jfischoff> I think we can learn something from python here
13:25:42 <chrisdone> jfischoff: what can we learn?
13:25:46 <jfischoff> the less ways to do something the less to learn
13:25:53 <chrisdone> oh, right
13:25:57 <jfischoff> I donâ€™t know if python really achieves that
13:26:03 <jfischoff> but I know that there is goal
13:26:09 <xplat> jfischoff: in some languages people start out with toy types and functions, and then keep using them forever
13:26:11 <hiptobecubic> I think one major difference between the "learn python" stuff available and the "learn haskell" stuff available is that the learn python stuff is typically in the context of building something familiar like a game or a web service.
13:26:18 <chrisdone> certainly people like lack of choice when they don't want choice
13:26:27 <hiptobecubic> The haskell content always seems to be about trying to make sure the reader understands some particular abstraction
13:26:28 <vanila> Turn of weird exceptions like monomorphism and haskell will be easier to understand
13:26:38 <vanila> corner cases are confusing when you haven't yet understood the way things are
13:26:53 <vanila> error messages is the most important thing of course
13:27:00 <napping> Maybe a flag or something that tries to specialize more types in errors to hide type classes?
13:27:04 <hiptobecubic> There was that "roll an irc bot" thing, which was alright i thought
13:27:12 <jfischoff> I think is overwhelming when you donâ€™t know how to decide
13:27:13 <chrisdone> hiptobecubic: also i don't recall seeing a haskell book that teaches haskell how people write it in industry
13:27:14 <hiptobecubic> also the write a scheme series is good
13:27:19 <jfischoff> I think *choice* is
13:27:32 <napping> chrisdone: well, I think you can get a decent start on Python without having to be exposed to classes and stuff
13:27:34 <hiptobecubic> at least in the sense that it's not about learning how functors work, it's about learning how to write an application in haskell
13:27:45 <napping> and start out using simple data types and built-in lists and stuff
13:27:58 <napping> It's not like they have a type system or anything
13:28:12 <chrisdone> napping: presumably contrary to haskell the things you learn in python at the beginning are what you will use as an expert?
13:28:21 <hiptobecubic> actually yes
13:28:41 <bitemyapp> chrisdone: may I ping you in query?
13:28:49 <napping> chrisdone: I'm not even sure about that, IIRC I started out with really basic stuff like tuples and so on
13:28:51 <chrisdone> bitemyapp: sure
13:29:12 <albeit> Why does this not compile? http://lpaste.net/111928 It says "preciseTimeToBuilder" is applied to too few arguments... but it isnt?
13:29:20 <hiptobecubic> napping, you don't use tuples?
13:29:47 <napping> I don't do a lot of Python more, but in a serious program you'll usually want to make a class or at least a map or something
13:29:53 <napping> rather than just tossing structured data into a tuple
13:30:11 <mauke> albeit: yes, it is
13:30:21 <hiptobecubic> that depends really heavily on how you're using it
13:30:31 <NemesisD> how does one get from a :: Proxy Foo to "Foo"
13:30:41 <albeit> mauke: How so? Are the three additional argument being passed into preciseTimeToBuilder?
13:30:45 <albeit> *Arent
13:30:49 <mauke> albeit: preciseTimeToBS x = builderToStrictBS (preciseTimeToBuilder x)
13:30:51 <napping> I think the problem is not that "map" be allowed to work more generally, but if you're trying to write a simple tutorial kind of program just operating on lists, it's not nice for the type error to bring in extra concepts
13:30:56 <mauke> albeit: that's what your definition says
13:31:08 <mauke> albeit: (because (f . g) x = f (g x))
13:31:37 <albeit> mauke: Oh... is there any way to do what I'm trying to do?
13:31:38 <mauke> NemesisD: in what context?
13:31:39 <napping> So maybe some kind of directive to tell GHC to treat a function as if it had a more specialized type would be a nice solution here?
13:31:52 <NemesisD> best i've been able to do so far is splitTyConApp . typeOf which gets me (Proxy, [Foo])
13:32:15 <mauke> NemesisD: what are you trying to do?
13:32:23 <NemesisD> mauke: i've got a type a floating around in my function's type and i want to get a string representation of that type in the body without being provided a value of a
13:32:49 <NemesisD> mauke: i can do it with undefined but that's a bit sketchy
13:33:20 <mauke> nah, undefined is fine
13:33:41 <NemesisD> i really thought i was voilating a style guideline using undefined
13:33:49 <mauke> typeOf (undefined `asProxyTypeOf` proxy)
13:33:49 <NemesisD> is that not why people use proxy?
13:34:18 <mauke> or even: argTypeOf :: a b -> b; argTypeOf = undefined; typeOf (argTypeOf proxy)
13:34:32 <mauke> albeit: you could stack (.)s
13:34:46 <mauke> albeit: ((f .) .) . g
13:34:56 <mauke> this is not generally recommended
13:35:30 <albeit> mauke: So better idea to name two of the three parameters?
13:35:31 <fizbin> mauke: Isn't there a package like Data.Composition or something like that that has operators that do the (.)-stacking?
13:35:48 <NemesisD> mauke: is there really any moral distinction between that and typeOf (undefined :: a) if its local to the function?
13:36:00 <mauke> albeit: yeah
13:36:11 <albeit> mauke: Okay thanks
13:36:20 <mauke> NemesisD: no, but the :: a thing requires a language extension
13:36:58 <NemesisD> mauke: ScopedTypeVariables?
13:37:17 <sloopjohnb> is it just me or does it seem like now that google summer of code is over haskell's infrastructure has stopped improving
13:37:31 <mauke> NemesisD: yes. ooh, I just found typeRep
13:37:43 <sloopjohnb> it felt like things were coming up pretty swiftly with backpack and all thees other ghc proposals but now theres like nothing at least on ./r/haskell
13:37:52 <mauke> > typeRep [True]
13:37:54 <lambdabot>  Bool
13:38:08 <mauke> NemesisD: typeRep is your friend
13:38:17 <sloopjohnb> its not a strictly haskell related question i know
13:38:22 <sloopjohnb> but still im curious if youll indulge me
13:38:29 <NemesisD> mauke: stuck on 7.6.3, so it isn't :P
13:38:38 <chrisdone> undefined should never really be necessary, though
13:38:50 <napping> sloopjohnb: It's not like there was constant news over the summer, I guess we'll see
13:38:59 <sloopjohnb> also is it at all possible for haskell speeds to ever match c or other systems languages
13:39:11 <sloopjohnb> napping: thats true but ive been checking for like a month and it seems a lot sparser than it used to be
13:39:11 <napping> The backpack proposal is definitely older than the start of the summer
13:39:14 * mauke rolls eyes furiously over sloopjohnb
13:39:20 <sloopjohnb> mauke: why
13:39:25 <NemesisD> chrisdone: how do i get to the type string without a value without using undefined?
13:39:29 <sloopjohnb> mauke: am i irritating you?
13:39:30 <mauke> sloopjohnb: you think languages have speeds
13:39:56 <sloopjohnb> mauke: well haskell has less capacity for optimization afaik then c or other systems languages
13:39:57 <NemesisD> i took the restrictor plate off my Haskell and it hauls ass
13:40:01 <chrisdone> NemesisD: what's the context?
13:40:05 <sloopjohnb> mauke: and is more inclined to be slow naturally
13:40:08 <sloopjohnb> mauke: or slower
13:40:11 <sloopjohnb> mauke: in my experience
13:40:13 <mauke> see? you're doing it again
13:40:21 <sloopjohnb> mauke: what are you saying
13:40:44 <sloopjohnb> mauke: the structure of haskell is not natural to cpus afaik so the language does have a speed
13:40:51 <NemesisD> chrisdone: say I want to write typeStr :: Typeable a => String, so far i've only been able to do this by coming up with an undefined :: a
13:41:01 <napping> mauke: so s/Haskell/GHC/
13:41:10 <sloopjohnb> mauke: it requires a lot of strange maneuvering with ram and cpu to get it to run in a sensible way
13:42:14 <mauke> napping: easily solved by rewriting GHC in C
13:42:20 <sloopjohnb> anyways now that were done arguing stupidly over semantics
13:42:31 <sloopjohnb> that was pretty much my question
13:42:33 <mauke> we can go back to arguing over syntax!
13:42:41 <sloopjohnb> does haskell as a language have the potential to be as fast as c
13:42:55 <sloopjohnb> like im asking if the language has inherent speed caps that are below c
13:43:07 <sloopjohnb> if the compiler could theoretically be improved to speed up the language
13:43:08 <sloopjohnb> enough
13:43:19 <srhb> sloopjohnb: Languages don't have speed.
13:43:21 <srhb> sloopjohnb: So yes.
13:43:41 <srhb> Oh, I see you already had that discussion.
13:43:44 <tommd> sloopjohnb: GHC is capable of producing code that runs as fast or faster than the C equivalent for many problems.
13:43:44 <sloopjohnb> fine, whats preventing haskell from compiling at speeds equivalent or greater than c then srhb
13:43:49 <mauke> not really a discussion
13:43:50 <sinelaw> vanila, so I read the link you gave me about ML
13:43:54 <peddie> sloopjohnb: https://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
13:43:55 <srhb> sloopjohnb: The compiler being clever enough in all instances.
13:43:59 <sinelaw> and polymorphism + ref cells
13:44:08 <sloopjohnb> will that ever be a reality
13:44:10 <mauke> just me saying I'm not even going to engage
13:44:16 <sloopjohnb> you engaged mauke
13:44:18 <srhb> sloopjohnb: Maybe. :) It's an open resource topic.
13:44:21 <sloopjohnb> youre not the only one here mauke
13:44:25 <sloopjohnb> you dont have to engage
13:44:41 <vanila> sinelaw, how was it?
13:44:58 <sloopjohnb> srhb: ok thank you, does it seem like its approaching that point at a reasonable rate
13:45:04 <Niall_> Is there a way to operate recursively on the tail of a list that's been cons'd to the head?
13:45:06 <srhb> sloopjohnb: a lot of huge advancements have been made to make Haskell rival extremely optimized low level code in some areas. It's getting better all the time.
13:45:10 <Niall_> ..if that makes sense
13:45:21 <srhb> sloopjohnb: I don't know what's reasonable. :)
13:45:26 <sinelaw> interesting! thanks for the link. I see that SML 97 (and ocaml) use "value restriction", and limit polymorphism in the general case
13:45:38 <sloopjohnb> srhb yea how long do you think itll take ill judge how reasonable the duration is
13:45:47 <srhb> sloopjohnb: I don't know.
13:45:52 <srhb> No one does, is my bet.
13:46:06 <sloopjohnb> im sure, but im not really getting answers as to how feasbale it is that this will happen
13:46:09 <peddie> sloopjohnb: http://aosabook.org/en/posa/warp.html http://www.serpentine.com/blog/2014/05/31/attoparsec/
13:46:12 <sinelaw> vanila, I was surprised to discover that in ocaml the type of const id is not polymorphic
13:46:13 <sloopjohnb> srhb is it a monnumental task
13:46:15 <srhb> sloopjohnb: Because no one can answer it.
13:46:21 <chrisdone> NemesisD: oh. typeStr :: Typeable a => String
13:46:29 <chrisdone> NemesisD: so what should typeStr () do?
13:46:29 <sinelaw> oops
13:46:33 <sinelaw> i meant id . const
13:46:36 <sloopjohnb> srhb surely you can observe how far we have to go before were as fast generally
13:46:50 <srhb> sloopjohnb: "Generally" I'd say we're pretty much there already.
13:46:50 <sloopjohnb> srhb no one knows what needs to be done to improve ghc to that point
13:47:16 <sloopjohnb> peddie why are you sharing these libraries with me
13:47:25 <sloopjohnb> peddie i dont see the connection
13:47:47 <peddie> sloopjohnb: these are all places where people are comparing the performance of programs written in C with similar programs written in Haskell
13:47:55 <NemesisD> chrisdone: well it would take no arguments, but if a was () it would return "()"
13:47:58 <chrisdone> NemesisD: wait, how do you instantiate that value?
13:48:09 <chrisdone> NemesisD: how do you indicate which instance you want?
13:48:10 <NemesisD> chrisdone, right now, undefined :: a
13:48:11 <sloopjohnb> peddie i see, although often people compare their extremely optimized performance oriented programs with average c programs
13:48:18 <sloopjohnb> peddie which is very misleading
13:48:25 <sloopjohnb> peddie i guess warp is compared to apache though
13:48:30 <sloopjohnb> peddie so thats fair
13:48:45 <peddie> sloopjohnb: feel free to read for yourself, but warp is compared with nginx, the generalized stream fusion is compared with GotoBLAS, etc.
13:48:46 <chrisdone> NemesisD: does that even compile?
13:48:47 <NemesisD> chrisdone, the real function i'm working with uses the a elsewhere: withObject' :: Typeable a => (Object -> Parser a) -> Value -> Parser a
13:48:56 <chrisdone> GHC should complain that your context is ambiguous
13:48:57 <NemesisD> i maybe should have started with that
13:49:05 <chrisdone> Foo a => <doesn't mention a>
13:49:14 <chrisdone> that should be an ambiguous type when you try to use it
13:49:17 <sloopjohnb> peddie im not well informed on how well maintained most of tose things are, so the comparisons dont have that much meaning to me sadly
13:49:25 <sloopjohnb> sloopjohnb: i trust theyre pretty fast though
13:49:35 <sinelaw> vanila, check out this ocaml snippet:
13:49:37 <sinelaw> # let x = const << id;;
13:49:37 <sinelaw> val x : '_a -> '_b -> '_a = <fun>
13:49:37 <sinelaw> # x 2;;
13:49:37 <sinelaw> - : '_a -> int = <fun>
13:49:38 <sinelaw> # x;;
13:49:40 <sinelaw> - : int -> '_a -> int = <fun>
13:50:01 <chrisdone> NemesisD: ohhh, much simpler
13:50:03 <napping> sloopjohnb: It sounds like you are assuming any performance comparisons you are given will be dishonest or misleading. So, why ask?
13:50:12 <vanila> sinelaw, that's really weird!
13:50:25 <sloopjohnb> napping: no im saying i dont know what these other performers represent in terms of speed
13:50:31 <sloopjohnb> napping: and statistics are often misleading
13:50:38 <sloopjohnb> napping: id like to be able to guage for myself
13:50:39 <srhb> :P
13:50:40 <chrisdone> NemesisD: okay, so here's the basic form
13:50:41 <sinelaw> vanila, yip. type variables with leading underscore are actually not type variables, they are "unknown types"
13:50:44 <napping> Well, GotoBLAS is just about as optimized as C ever gets!
13:50:47 <peddie> sloopjohnb: GotoBLAS is an extremely performance-oriented library
13:50:49 <sloopjohnb> napping: i would take you guys word on how legitimate the comparisons are
13:50:52 <srhb> sloopjohnb: Surely, asking people in #haskell is more misleading than statistics
13:50:58 <peddie> haha
13:51:09 <sloopjohnb> srhb: mostly haskell people in #haskell seem fairly honest about competition
13:51:11 <sinelaw> vanila, and on the first instance where the type is inferred to be something, it is fixed to that type
13:51:15 <sloopjohnb> srhb im not new here really
13:51:18 <srhb> :)
13:51:26 <sloopjohnb> srhb so i know more than just these people like haskell
13:51:32 <vanila> sinelaw, yikes - I wouldn't wnat to have to implement that
13:51:35 <napping> I'd be surprised if anything else came particularly close
13:51:35 <srhb> I didn't mean to imply otherwise.
13:51:37 <sloopjohnb> srhb people dont really seem to oversell or misrepresent things here
13:51:43 <vanila> sinelaw, it's interesting that the ST monad doesn't have these problems
13:52:00 <sinelaw> vanila, the magic of 2nd order types
13:52:37 <sloopjohnb> srhb ok my mistake, i thought the implications of people on #haskell misleading me were exactly what i said, other things dont really seem to make sense
13:52:49 <sloopjohnb> peddie thank you peddie for giving me a metric
13:53:39 <napping> sloopjohnb: I'd say functions on flat arrays probably end up at least within 2x or 3x of similarly naive C - but may not autovectorize or whever as nicely as a fancy C compiler
13:53:59 <sinelaw> vanila, all this garbage stems from reference cells and implicit mutability
13:53:59 <peddie> sloopjohnb: if you are still curious about performance, I encourage you to look up the projects GHC and the various libraries are compared to in those articles (e.g. nginx, Eigen, GotoBLAS, node.js)
13:54:10 <sinelaw> vanila, so it makes one appreciate the IO Monad
13:54:14 <sinelaw> as a major innovation
13:54:19 <napping> Code usually inlines, unboxes, etc. pretty decently
13:54:37 <sloopjohnb> napping interesting why does it only apply to flat arrays
13:54:50 <napping> If you're talking about algebraic data types
13:55:06 <sloopjohnb> peddie ok i probably shouldve done that in the first place, but im not really that much more curious
13:55:10 <napping> then it's not any more something with such a straightforward translation to C
13:55:18 <peddie> sloopjohnb: is there a particular program or domain you're having performance problems with?
13:55:20 <napping> but also there's less support for getting things implemented without indirection
13:55:23 <sloopjohnb> peddie im really more interested in what steps need to be taken for haskell to feel more naturally fast i guess
13:55:35 <sloopjohnb> peddie no im not working on anything right now
13:55:38 <sloopjohnb> peddie but graphics i guess
13:55:54 <napping> I don't know of any implementation that turns [Maybe a] into one flat struct per list node, instead of one with a pointer to the Maybe
13:55:59 <sloopjohnb> peddie i would like to make a 3d game in haskell and the haskell graphical world seems rather underdeveloped
13:56:07 <napping> I think that's the sort of whole-program optimization MLton does
13:56:14 <sinelaw> what haskell extensions cause the type inference to become undecidable?
13:56:23 <peddie> sloopjohnb: I suggest you look at not-gloss; the examples contain some simple games
13:56:29 <sinelaw> (in GHC obviously)
13:56:36 <peddie> @hackage not-gloss
13:56:37 <lambdabot> http://hackage.haskell.org/package/not-gloss
13:57:22 <sloopjohnb> peddie: ok thanks for the tip, i thik ive checked it out before but i  cant recall. im hesitant to involve myself in writing a game in haskell because somethingn about haskell seems so non-real really, i dont know how to describe it haskell just feels very strange to write in
13:57:49 <sloopjohnb> peddie: i kind of miss working with oop tbh
13:58:04 <peddie> sloopjohnb: if you find you're having concrete performance problems, people here will probably be happy to help, but I'm not sure anyone else can do anything about your perception that it doesn't feel "naturally fast" :)
13:58:12 <sloopjohnb> something about the oop model just feels more fun to write in strangely enough
13:58:18 <napping> I'm not sure it's entirely accurate, but I'd say Haskell can be fast enough with a little attention, unless you already know for sure that anything other than C is too slow
13:58:34 <napping> like, if you'd even consider using a scripting language, Haskell would be plenty fast
13:58:42 <sloopjohnb> peddie: thats true, more than the speed i think its that writing it doesnt feel natural, i just figure the speed is associated with that sense
13:59:14 <sinelaw> sloopjohnb, it feels natural after you get used to it :)
13:59:15 <cdk> sloopjohnb: I think you're conflating "fun" with "familiar"
13:59:17 <napping> Provided you say away from a few things like using linked lists ([]) where a flat array would be more appropriate, or other big-picture sorts of things
13:59:25 <sloopjohnb> i think youre right
13:59:42 <napping> How natural it feels to write in a language probably has nothing to do with how fast it actually runs
13:59:49 <sloopjohnb> cdk, sinelaw: another part of the problem is that im not working alone, and i think my partner would be irritated that i keep pushing for haskell
13:59:56 <napping> except for very special values of natural
14:00:28 <sinelaw> 1, 2, 3, ...
14:00:29 <sloopjohnb> sdk, sinelaw: were gearing up to right an indie game project that will take a lot of our time, including the engine, and its hard to confidently say haskells te right choice for that
14:00:34 <monochrom> don't push for haskell. be more evil. push for continuation-passing style. :)
14:00:57 <napping> sloopjohnb: that sounds entirely correct
14:01:01 <sloopjohnb> if i could believe myself that haskell was absolutely the tool for the job then i would push for it but the language is underrepresented for game development
14:01:13 <napping> It's also hard to say confidently that Haskell is absolutely the wrong choice
14:01:18 <sloopjohnb> monochrom: what is continuation passing
14:01:26 <napping> but it's certainly not as established an option
14:01:27 <sloopjohnb> napping: what does? not sure what youre referring to
14:01:42 <sinelaw> continuation passing style is of the devil
14:01:46 <napping> sloopjohnb: You says you couldn't believe Haskell is absolutely the tool for the job
14:01:51 <napping> Well, you probably shouldn't
14:01:59 <monochrom> hrm, it's going to be a bit long to describe. but I'll try.
14:02:07 <sloopjohnb> napping: yea, you cant either eh?
14:02:15 <sloopjohnb> i wish someone could ocnvinec me so i could convince my friend
14:02:33 <napping> It's certainly a plausible option
14:02:41 <sloopjohnb> monochrom: thank you for your efforts
14:03:19 <napping> This seemed to end up with a decent game: http://steamcommunity.com/sharedfiles/filedetails/?id=107105028
14:03:29 <napping> and these guys are going for it: http://blog.chucklefish.org/?p=154
14:03:33 <sloopjohnb> napping: yea ive seen those
14:03:38 <sloopjohnb> napping: im very up to date on haskell news
14:03:48 <sloopjohnb> napping: the first ones kind of lame tbh, but it runs well which is good
14:04:26 <napping> So it's clearly not impossible to get acceptable performance
14:04:28 <monochrom> I'll try this description: "direct style" is how you write normally, you write a function that takes 2 parameters x,y and returns 1 answer. "continuation-passing style" is you rewrite that to take 3 parameters, x, y, a function k ('k' for 'kontinuation'). you don't return your answer. you call k(your answer) at the end.
14:04:41 <napping> on the other hand, you'll certainly need to expect to build a bit of infrastructure yourself
14:04:53 <napping> it's not like there's off-the-shelf game libraries you can just take for granted
14:04:58 <monochrom> I suppose I could have just said "callback" :)
14:05:02 <albeit> monochrom: So the entire program is basically one long chained function?
14:05:03 <sloopjohnb> also i have the perception that whatever i ended up writing in haskell to get my game going would end up with me writing in whats pretty much a domain specific language not far from oop, like i dont think i could leverage the functional style very well
14:05:09 <peddie> sloopjohnb: you can probably do more to convince both of you one way or the other by trying it out than any of us can by telling you about it in an IRC room
14:05:30 <monochrom> yes. one long chain of tail calls. but don't rejoice yet. this way you spend heap space instead.
14:05:33 <sloopjohnb> peddie: yea thats true, maybe its worth giving a shot. altough people with experience could tell me the pros cons of this sort of venture
14:05:53 <sloopjohnb> monochrom: oh so basically javascript
14:05:58 <monochrom> heh
14:06:00 <sloopjohnb> monochrom im *very* familiar with this style
14:06:25 <sloopjohnb> monochrom its hard to debug but i dont hate it as much as most
14:06:26 <peddie> sloopjohnb: you might have more luck if you try it and ask questions about specific problems you encounter
14:06:27 <monochrom> ok good :)
14:06:51 <sloopjohnb> peddie: good point, although i like making a choice and stiking with it, so im trying to be informed before i plow ahead
14:06:57 <Niall_> Is it possible to work recursively on the tail of a list, then append it to its original head in one function?
14:07:06 <monochrom> in my haskell IO tutorial, I say "callback", but it's really continuation: http://www.vex.net/~trebla/haskell/IO.xhtml
14:07:17 <Niall_> I have a list comprehension version but can't figure out how to do it in recursive terms
14:07:28 <sinelaw> it's not exactly like javascript
14:07:39 <sinelaw> in javascript you can just return from your function
14:07:49 <sinelaw> (and do it a lot, too)
14:07:49 <sloopjohnb> sinelaw: oh right
14:07:55 <sloopjohnb> sinelaw: we have to continue
14:07:59 <sloopjohnb> sinelaw: i forgot about that
14:09:21 <monochrom> in practice, continuation-passing style is best done by a mechanical translator, not hand-written, of course.
14:09:47 <napping> or do-notion in Cont!
14:10:00 <pjdelport> Niall_: What's your list comprehension
14:10:02 <pjdelport> ?
14:10:10 <monochrom> there are two things you get out of this, especially if done by a mechanical translator.
14:10:37 <monochrom> first thing is that it seems that functional languages are best compiled by first going through this translation stage.
14:11:27 <vanila> but haskell isn't compiled through CPS is it
14:11:28 <vanila> ?
14:11:51 <Niall_> pjdelport https://gist.github.com/anonymous/824445df1dd7106d8ea5 it's basically formatting a string as a book title, so capitalised first letter and all words > 3 chars in length
14:12:17 <Niall_> but I'm using the capitalised first entry of the array of strings representing the title's words, then appending it to the tail
14:12:32 <srhb> w/url
14:12:34 <srhb> oops
14:12:53 <monochrom> second thing is that you can obtain powerful control-flow commands. because the translator can translate those commands into "don't invoke k yet, save it up for later use, in fact use it several times later"
14:13:07 <chrisdone> NemesisD: sorry, i got distracted. did you solve your typeable problem? =)
14:13:33 <sinelaw> with great power come a lot of bugs
14:13:36 <pjdelport> Niall_: The first function you can write as: lowercaseLister = map lowercaser
14:13:53 <monochrom> I think GHC does something close to CPS near the end. you can see hints of it in generated asm code.
14:14:11 <Niall_> pjdelport Ahh I wasn't aware of map, very new to haskell - thank you!
14:14:19 <chrisdone> that's how you get high performance with fusion
14:14:36 <pjdelport> Niall_: The second you can write as: wordDistinguisher word = if length word > 3 then capitalise word else lowercaser word
14:15:18 <Niall_> pjdelport is there a way to recursively define the 'title' function?
14:15:20 <pjdelport> Niall_: That's more of a style thing, though.
14:17:19 <pjdelport> Niall_: I would write that as:
14:17:19 <pjdelport> title "" = ""
14:17:19 <pjdelport> title (word:words) = capitalize word : map wordDistinguisher (lowercaseLister words)
14:17:45 <pjdelport> Sorry, that should be: title [] = []
14:18:47 <pjdelport> Note that you can also combine the two functions to map across the rest of the words, so you can also say:
14:18:47 <pjdelport> title (word:words) = capitalize word : map (wordDistinguisher . lowercaser) words
14:18:47 <Niall_> How would that work if not using map? Just to get a feel for what it.. does
14:18:56 <Niall_> oh my god haskell is so cool
14:19:14 <pjdelport> (then you don't need the separate lowercaseLister function)
14:20:42 <napping> monochrom: isn't STG code closer to ANF?
14:20:42 <monochrom> you replace map (wordDistinguisher . lowercaser) words by a helper.
14:21:17 <monochrom> title (word:words) = capitalize word : helper words
14:21:51 <monochrom> helper [] = []; helper (w:ws) = (wordDistinguisher . lowercaser) w : helper words
14:22:46 <monochrom> napping: yes. something happens after that so that the Cmm looks like doing CPS.
14:22:57 <pjdelport> Oh, as another style thing, i said (word:words) above, but (w:ws) would probably be more idiomatic, yeah.
14:23:12 <pjdelport> Especially because "words" shadows the function.
14:23:27 <pjdelport> (It's not an error, but it's questionable style.)
14:23:37 <monochrom> well, I chose different names so that you do not think w = word and ws = words
14:24:04 <Niall_> hmm
14:24:15 <Niall_> this is a little hard to find the documentation for, what would the "." operator be called here?
14:24:19 <Niall_> I've not encountered it before
14:24:23 <pjdelport> Niall_: Function composition.
14:24:27 <pjdelport> @src (.)
14:24:27 <lambdabot> (f . g) x = f (g x)
14:24:44 <pjdelport> You can pronounce it as "compose"
14:24:46 <zq> is there a builtin with Bool -> Int defined the usual way?
14:24:46 <Niall_> Ah!
14:24:49 <Niall_> Thank you both
14:24:52 <srhb> Looking over Neil Mitchells criticism of Traversable and Foldable generalizations in Prelude, couldn't we just kill off the default Prelude import by default rather than by a switch? Then you'd pick BeginnerPrelude or ClassyPrelude or NewGeneralized2014Prelude or whatever.
14:24:52 <pjdelport> (or just "dot")
14:24:52 <Niall_> that makes it a lot clearer
14:24:53 <monochrom> helper (w:ws) = wordDistinguisher (lowercaser w) : helper words
14:25:03 <monochrom> oops, I made a fatal typo.
14:25:05 <monochrom> helper (w:ws) = wordDistinguisher (lowercaser w) : helper ws
14:25:33 <pjdelport> Niall_: A common idiom you might see is "functional pipelines" using the . operator, like: f . g . h $ x
14:25:55 <pjdelport> That means the same as: f (g (h x))
14:26:13 <pjdelport> You can think of the x as "flowing" in from the right, toward the left, through each function in turn.
14:26:35 <Niall_> Yeah, that makes sense
14:26:50 <pjdelport> And of course, you don't need the $ application operator, so it's common to see such pipelines with higher-order functions like map (f . g . h) xs
14:26:59 <arianvp|gone> lol TIL: left and right projections of bifunctors are called Clown and Joker xD
14:28:45 <albeit> When ByteString.Builder concatenates two Builderified ByteStrings, it creates a lazy ByteString composed of two chunks, correct? Even if those original ByeStrings are only 5 bytes, it would make two chunks of 5 bytes each?
14:30:21 <eacameron> does GHC provide a way to inject "global" init/deinit functions commonly needed by C libraries?
14:30:55 <sinelaw> eacameron, global as in once per process?
14:31:00 <sinelaw> task? thread?
14:31:01 <eacameron> sinelaw: right
14:31:06 <eacameron> sinelaw: per process
14:31:34 <sinelaw> eacameron, one way to do it is in the wrapping FFI to check if init was called and call it if not
14:31:40 <sinelaw> as for deinit, i don't know
14:31:52 <chrisdone> when i'm talking haskell i say "f dot g dot h"
14:33:44 <eacameron> sinelaw: yeah...I was hoping for something better. the mysql_init function is not threadsafe
14:33:52 <eacameron> "unsafe" would probably do it
14:34:10 <eacameron> I would like to do the same thing per thread
14:34:34 <eacameron> but I don't know of a good way
14:34:50 <eacameron> I might have to use bound threads very carefully
14:34:58 <sinelaw> eacameron, I wrote a lib for handling such cases where you have resources that need to be inited/deinited
14:35:26 <eacameron> sinelaw: sweet! is it public?=
14:35:38 <sinelaw> https://hackage.haskell.org/package/allocated-processor-0.0.2/docs/Control-Processor.html
14:35:48 <sinelaw> eacameron, may be overkill for your use case
14:36:02 <sinelaw> it's meant for composing processors of allocated resources
14:36:30 <sinelaw> in your case it's a do-it-once thing, different problem
14:36:44 <eacameron> interesting
14:36:55 <eacameron> I'll take a look anyway, in case the source gives me ideas
14:37:24 <eacameron> thanks
14:38:23 <sinelaw> np, you can probably do something similar: define some type that when your "run" it, it first allocates the resource, does the job, and then de-allocates
14:38:40 <sinelaw> and place your entire thread in that thing, probably make it a monad
14:38:43 <albeit> How can you determine if something is "likely to survive one garbage collection"?
14:38:56 <sinelaw> if it's big?
14:41:07 <sinelaw> why does ghci not know about fix?
14:41:35 <mauke> @index fix
14:41:35 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:41:45 <monochrom> Data.Function has fix
14:41:53 <sinelaw> ok
14:42:29 <monochrom> lambdabot knows a lot of things ghci doesn't know
14:42:56 <monochrom> and ghci knows a lot of things ghc (when in batch compile mode) doesn't know
14:43:40 * hackagebot tidal-vis 0.1.8 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.8 (AlexMcLean)
14:43:48 <monochrom> but ghc (when in batch compile mode) is the closest thing to standard or common behaviour among the 3.
14:44:20 <monochrom> the long and short of this is that neither lambdabot nor ghci should be your standard against which haskell compilers are measured.
14:44:27 <Athas> What's the nicest way to encode vector/list lengths in the type, a la https://www.haskell.org/ghc/docs/7.8.1/html/users_guide/promotion.html ?
14:44:52 <Athas> That example defines its own natural number type, but can I piggyback on type-level literals somehow?
14:44:56 <monochrom> when a line of code works in lambdabot or ghci, but not in ghc (when in batch compile mode), lambdabot and ghci are being wrong.
14:47:39 <monochrom> ghci is like ghc on meth. a lot of things don't make sense, but when on meth or ghci, they seem to do.
14:48:04 <monochrom> and lambdabot is like ghci on crack
14:48:39 <mauke> I thought it was acid
14:48:57 <monochrom> acid then. not too familiar with drugs :)
14:49:28 <mauke> @where goa
14:49:28 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
14:51:09 <Dashkal> Trying to work through fix.  I'm stuck in trying to find a terminating use of fix that isn't fix :: ((a -> b) -> (a -> b)) -> (a -> b)  The function is defined as (a -> a) -> a, but I can't find anything that terminates in the latter form that isn't of the former form.
14:51:38 <mauke> > fix (5 :)
14:51:39 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
14:52:11 <Dashkal> It could well be that it simply doesn't terminate under those constraints
14:52:19 <Dashkal> erm, rather, it doesn't every fully resolve
14:52:25 <Dashkal> Bleh, terminology failure.
14:52:48 <Dashkal> Cannot fully evaluate things produced that way?
14:53:08 <napping> Using functions isn't too much different from making lists, for some ways of thinking about it
14:53:10 <sinelaw> do "rank" and "order" of types mean the sane thing?
14:53:30 <monochrom> consider "fix (const True)"
14:53:41 * hackagebot language-c-quote 0.10.0 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.0 (GeoffreyMainland)
14:53:55 <Dashkal> ahh, indeed that works.  Thank you, monochrom
14:53:57 <napping> If you have function ((a -> b) -> (a -> b)), the only reason you get a well-defined result out is because you're using a function that doesn't make a recursive call right away, but instead waits for an argument
14:54:08 <napping> making a lazy list like fix (5:) is similar
14:54:44 <napping> You could go arbitrarily deep into recursive calls when you define some functions by fix, so that's not exactly making a finite structure either
14:54:45 <Dashkal> const gave me the clue I needed.  There are indeed plenty of sensible things I can pass it that follow (a -> a)
14:55:06 <napping> Getting an infinite list like fix (5:) *is* terminating
14:55:15 <Dashkal> That's why I revised my statement
14:55:27 <Dashkal> I'm currently working mostly in a strict language, so infinite lists /are/ non-terminating
14:55:34 <napping> at least in the sense of getting a "productive" value out, where you can match under a constructor in finite time
14:55:44 <napping> well, in a strict language fix (const True) probably doesn't terminate either
14:56:10 <napping> if const were strict in the second argument
14:56:26 <napping> Basically, a lambda is lazy even in a strict language
14:56:45 <napping> at least in the sense that you don't start evaluating anything inside the body until you get more arguments
14:57:10 <sinelaw> why doesn't fix (*2) terminate with 0?
14:57:12 <napping> so a strict language pretty much has to declare ((a -> b) -> (a -> b)) -> (a -> b)
14:57:22 <napping> sinelaw: because (*2) is strict
14:57:31 <napping> and so undefined in another fixpoint
14:57:43 <napping> and in fact the least fixpoint, because it's less defined than 0
14:57:45 <monochrom> because fix, and recursion in general, finds the least fixed point only. âŠ¥ is less than 2.
14:57:54 <napping> or, for a similar reason fix(+0) doesn't terminate with 27
14:57:54 <monochrom> err, âŠ¥ is less than 0
14:58:31 <sinelaw> what's the definition of "least"?
14:58:41 <monochrom> less information
14:58:52 <mauke> least defined
15:00:12 <sinelaw> wiki thinks this: (least fixed point)  of a function from a partially ordered set to itself is the fixed point which is less than each other fixed point, according to the set's order
15:00:30 <sinelaw> i.e. 0
15:00:32 <mauke> bottom is at the bottom of definedness
15:00:57 <rbrewster> I'm having an issue with infinite lists of IO actions. Is there a way to take [IO a] -> IO [a] for infinite lists?
15:01:01 <sinelaw> can you make that more precise? doesn't feel like a definition
15:01:22 <rbrewster> ((Example code: http://pastebin.com/jBsTUD4U))
15:01:28 <mauke> no, I don't actually know things
15:02:09 <sinelaw> mauke, heh
15:02:37 <mauke> I think it has to do with lettuce
15:03:08 <sinelaw> heh
15:03:30 <monochrom> the order used is information order. this is a partial order. the set also includes âŠ¥. in terms of how much information, âŠ¥ has less information than 0, but 0 and 1 do not have less information than each other. 0 and 1 become incomparable, but both are higher than âŠ¥.
15:03:38 <bitemyapp> Cale: wait how do you know how much I twitter? Do you follow me?
15:03:41 * hackagebot bspack 0.0.3 - A simple and fast bytestring packer  http://hackage.haskell.org/package/bspack-0.0.3 (nicolasdp)
15:05:14 <roger_> @list
15:05:14 <lambdabot> What module?  Try @listmodules for some ideas.
15:05:23 <roger_> @help
15:05:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:05:32 <roger_> @help list
15:05:32 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
15:05:49 <sinelaw> monochrom, then why isn't _|_ always the answer?
15:06:06 <sinelaw> e.g. in the classic factorial example
15:06:09 <shachaf> Because fix gives you the least fixed point. Sometimes _|_ isn't a fixed point.
15:06:17 <monochrom> for some other f, âŠ¥ is not a fixed point.
15:06:23 <roger_> @help pl
15:06:23 <lambdabot> pointless <expr>. Play with pointfree code.
15:06:27 <sinelaw> > fix (\f n -> if n == 0 then 1 else n * (f (n-1)))
15:06:28 <lambdabot>  <Integer -> Integer>
15:06:41 <sinelaw> if I give that thing _|_, won't it diverge?
15:06:42 <napping> sinelaw: Returning _|_ when you are given _|_ is the definition of being a strict function.
15:06:44 <monochrom> âŠ¥ + 1 = âŠ¥, âŠ¥ is a fixed point of (+ 1).
15:06:45 <roger_> @pl addPurchase x y z = appendFile purchasePath (purchaseToCsv(purchase x y z))
15:06:45 <lambdabot> addPurchase = (((appendFile purchasePath . purchaseToCsv) .) .) . purchase
15:07:09 <monochrom> 5:âŠ¥ â‰  âŠ¥, âŠ¥ is not a fixed point of (5 :)
15:07:16 <napping> sinelaw: so if you use a lazy function, you *can't* get _|_ as a fixpoint
15:07:51 <shachaf> (And if you use a strict function, you'll always get _|_ as a fixed point.)
15:07:55 <roger_> @pl (((appendFile purchasePath . purchaseToCsv) .) .) . purchase
15:07:55 <lambdabot> (((appendFile purchasePath . purchaseToCsv) .) .) . purchase
15:08:06 <shachaf> ("strict" means "_|_ is a fixed point")
15:08:11 <monochrom> (\n -> if n == 0 then 1 else n * (âŠ¥ (n-1))) â‰  âŠ¥, âŠ¥ is not a fixed point of (\f n -> if n == 0 then 1 else n * (f (n-1)))
15:08:24 <roger_> @pretty (((appendFile purchasePath . purchaseToCsv) .) .) . purchase
15:08:24 <lambdabot>  (((appendFile purchasePath . purchaseToCsv) .) .) . purchase
15:08:43 <shachaf> roger_: You can use /msg lambdabot @pl ... to experiment with @pl unless you're demonstrating something to the channel.
15:08:44 <sinelaw> monochrom, what is the value then in that case?
15:08:54 <monochrom> to see why (\n -> if n == 0 then 1 else n * (âŠ¥ (n-1))) â‰  âŠ¥, contrast (\n -> if n == 0 then 1 else n * (âŠ¥ (n-1))) 0 vs âŠ¥ 0
15:09:25 <sinelaw> hmm
15:09:32 <sinelaw> nice!
15:10:02 <Cale> bitemyapp: No, I just looked at your link
15:10:18 <sinelaw> > fix (\f n -> if n == (n-n) then 1 else n * (f (n-1)))
15:10:19 <lambdabot>  <Integer -> Integer>
15:10:41 <sinelaw> ooops, forget that.
15:12:45 <sinelaw> I just realized why ocaml doesn't have  function composition in the "prelude" (or at all in the core library)
15:13:14 <sinelaw> it's because of the value restriction...it makes composition a lot less useful
15:13:15 <napping> why not?
15:13:22 <napping> oh, value restriction, hmm
15:17:19 <sinelaw> ocaml :(
15:17:20 <sinelaw> # let twoPairs = twice << twice;;
15:17:20 <sinelaw> val twoPairs : '_a -> ('_a * '_a) * ('_a * '_a) = <fun>
15:17:20 <sinelaw> # twoPairs 3
15:17:20 <sinelaw>   ;;
15:17:20 <sinelaw> - : (int * int) * (int * int) = ((3, 3), (3, 3))
15:17:22 <sinelaw> # twoPairs;;
15:17:24 <sinelaw> - : int -> (int * int) * (int * int) = <fun>
15:18:01 <sinelaw> of course I forgot:
15:18:02 <sinelaw> # let twoPairs = twice << twice;;
15:18:02 <sinelaw> val twoPairs : '_a -> ('_a * '_a) * ('_a * '_a) = <fun>
15:18:02 <sinelaw> # twoPairs 3
15:18:02 <sinelaw>   ;;
15:18:02 <sinelaw> - : (int * int) * (int * int) = ((3, 3), (3, 3))
15:18:04 <sinelaw> # twoPairs;;
15:18:06 <sinelaw> - : int -> (int * int) * (int * int) = <fun>
15:18:11 <sinelaw> bah. forget it. emacs copy paste is wrong.
15:19:22 <monochrom> emacs has two copies and pastes. the toolbar copy button copy is different from the M-w copy, for example. :)
15:20:08 <sinelaw> there can be three, with Xorg's mouse selection + middle click
15:20:44 <sinelaw> so how can OCaml be considered "functional" if function composition is almost useless?
15:21:10 <monochrom> it still has higher-order functions such as map
15:21:28 <sinelaw> javascript also has that.
15:21:42 <sinelaw> or, more to the point, C#
15:22:05 <sinelaw> ocaml = c# + sum types?
15:22:35 <jle`> a question about comonad laws
15:22:43 <sinelaw> + inference of course
15:22:56 <jle`> the most direct translation of the actual comonad laws into haskell is:
15:23:04 <jle`> duplicate . duplicate = fmap duplicate . duplicate
15:23:10 <jle`> (and the other one)
15:23:16 <jle`> but is that first duplicate really a necessary part of the law?
15:23:24 <jle`> isn't it enough to say that duplicate = fmap duplicate?
15:23:34 <jle`> same taht extract = fmap extract?
15:24:06 <dfeuer_> Presumably the longer one is weaker?
15:24:29 <NemesisD> chrisdone: yeah with undefined :P
15:24:40 <monochrom> the corresponding monad law is join . join = join . fmap join. it does take two consecutive joins, for what it's worth
15:24:52 <jle`> hm
15:24:56 <jle`> yeah, that makes sense
15:25:23 <jle`> but would the rephrasing of the comonad law basically say the same thing?
15:25:25 <napping> It's only the top-level structure that you are assuming is a comonad
15:26:11 <jle`> hm.  well, doesn't fmap duplicate imply that the second level is a comonad too?
15:26:32 <napping> you started with some t a, and got two levels of comonad just by using duplicate
15:26:53 <monochrom> dfeuer_'s perspective is also right. in Galois connections, there is a theorem "f . g . f = f". you may wonder why not "f . g = id". but a Galois connection can't guarantee "f . g = id", it only guarantees "f . g . f = f", it's weaker.
15:27:03 <napping> Maybe seeing how join == fmap join is allowed to fail would help?
15:27:38 <hpc> monochrom: what (f,g) would satisfy just the one equality?
15:28:21 <jle`> i see
15:28:27 <hpc> er, nvm
15:29:00 <napping> take return (putStrLn "Middle" >> return (return 12))
15:29:23 <napping> you can distinguish join and fmap join of that with test m = do x <- m; putStrLn "Now running inner"; x
15:29:41 <monochrom> let R be a relation. come up some evil relation for it. for set X, f(X) = { y | for all x in X, xRy }. for set Y, g(Y) = { x | for all y in Y, xRy }
15:29:59 <jle`> napping: are we talking about if the two returns are for different monads?
15:30:09 <napping> well, that might be a problem too, but no
15:30:12 <jle`> ah
15:30:14 <jle`> wait, i misread
15:30:16 <jle`> i see
15:30:36 <jle`> i can see that join . join = join . fmap join can't be reduce
15:30:44 <jle`> because the last join might not be injective
15:30:47 <napping> duplicate and fmap duplicate can both have type (c (c a)) -> c (c (c a))
15:30:58 <Cale> You have to pay careful attention to the types at which things are being used
15:31:00 <napping> but they are allowed to split "stuff" differently between the three layers of context
15:31:12 <karshan> Hey, has anyone had issues with cabal repl in a sandbox folder when you change something in your *.cabal and it says package-id not found and then you have to delete dist/setup-config to fix it ?
15:31:21 <jle`> well, in the category theoretic formulation, the types are explicit
15:31:23 <napping> you only require that to hold if you got the two layers in c (c a) from duplicate in the first place
15:31:45 <monochrom> perhaps the example with a relation requires too much work to see. I'll give a more immediate example.
15:31:48 <napping> join and fmap join smush the middle layer in m (m (m a)) into either the outer or inner layer
15:31:55 <dcoutts_> karshan: if you can reproduce it reliably that'd be very helpful
15:32:17 <napping> Using another join after that makes those cases indistinguishable, but without it you can tell them apart
15:32:21 <napping> well, got to go
15:32:41 <jle`> (dumplicate :: w (w a) -> w (w (w a))) =  fmap (duplicate :: w a -> w (w a))
15:32:45 <jle`> dumplicate >_>
15:32:50 <monochrom> f :: Z -> R, f x = x; g :: R -> Z, g = floor.  then f (g 5.1) â‰  5.1, but f . g . f = f
15:33:06 <jle`> would stating the types explicitly make it better?
15:33:11 <monochrom> unfortunately, g . f = id.
15:33:19 <bmuk> If I have defined an ADT using record syntax, I know I can pattern match with the field name. Can I do this in newtype definitions? If I have a data Foo = Foo { bar :: String }, can I then say newtype Quux = Quux bar Foo?
15:33:32 <jle`> monochrom: i see
15:33:44 <monochrom> the nice thing about the more-work relation example is that g . f = id also fails, you only have g.f.g = g
15:33:59 <jle`> so the the problem is that g is not injective
15:34:22 <jle`> or is there a deeper problem here than that
15:34:52 <monochrom> no deeper. non-injective and non-surjective. that's all.
15:35:02 <jle`> i see
15:35:10 <jle`> this is the same problem with reducing join . join = join . fmap join
15:35:13 <jle`> I C
15:35:21 <jle`> all is clear
15:35:23 <jle`> thank you all
15:36:03 <karshan> dcoutts_: I can't seem to get it to happen again :(
15:36:25 <Cale> bmuk: I don't understand what you're trying to do exactly.
15:36:51 <Cale> bmuk: You can use record syntax in newtype declarations (but you didn't there...)
15:37:22 <Cale> e.g. you could write  newtype Quux = Q { theFoo :: Foo }
15:37:36 <Cale> and this would define  theFoo :: Quux -> Foo
15:38:01 <rbrewster> So this piece of code never does anything: do { xs <- sequence (repeat $ return 0); print (take 10 xs) }
15:38:11 <rbrewster> Is there a way to effectively use infinite lists of IO actions?
15:38:21 <Cale> rbrewster: Don't try to execute them all?
15:38:28 <bmuk> Cale: I have a descriptive name that I have defined in an abstract data type User { name :: String }, and I would like a newtype ACL which takes a username
15:38:46 <Cale> rbrewster: Executing infinitely many IO actions in sequence will certainly take an infinite amount of time
15:39:22 <monochrom> rbrewster, do you accept this? do { let {xs = repeat 0}; print (take 10 xs) }
15:39:22 <karshan> dcoutts_: I can get something that is not necessarily a cabal bug to reproduce though. If there is a hidden package-needs to be added to build-depends error in my project. And I fix it by adding a dependency int he cabal file. running ghc-mod in the project directory will still return the same error until I delete dist/setup-config
15:39:36 <jle`> what's the proper capitalization for cokleisli
15:39:39 <jle`> should i say CoKleisli
15:39:46 <jle`> or is Cokleisli okay
15:39:51 <jle`> i want to respect mr. kleisli
15:39:56 <monochrom> unfortunately, the meaning of sequence for IO is not lazy I/O.
15:39:58 <Cale> jle`: I'd accept either one
15:40:15 <Cale> monochrom: Not entirely sure that's unfortunate :)
15:40:30 <monochrom> or fortunately. it's simpler to assume that I/O is non-lazy.
15:40:36 <bmuk> Cale: do you have any idea how to do that?
15:40:41 <rbrewster> Okay, I think I understand.
15:40:51 <bitemyapp> jle`: if you really want to honor him, call it CoHeinrichKleisli instead.
15:40:53 <monochrom> (simpler than: some I/O is lazy, some is not, you never know)
15:41:00 <rbrewster> do { let xs = repeat (return 0); zs <- sequence (take 10 xs); print zs }
15:41:18 <Cale> bmuk: Just make use of your User type?
15:41:18 <jle`> bitemyapp: sounds like a good plan
15:41:27 <bitemyapp> jle`: I'm inspired like that.
15:41:27 <CrazyM4n> How would I make a list go from, say, [1,1,1] to [[1],[1],[1]]? Increase the depth of the list, if you will.
15:41:37 <Cale> CrazyM4n: map (:[]) ?
15:41:50 <CrazyM4n> DidnÂ´t know you could do that
15:41:52 <CrazyM4n> Thanks
15:41:54 <exio4> map return!
15:41:58 <jle`> robot monkey operator
15:42:09 <jle`> i like to refrain from using return/pure when i'm not "thinking" in monads/applicatives :O
15:42:13 <jle`> that's just me
15:42:14 <bmuk> Cale: I figured if I have a huge list of ACLs, I would rather them just be the user name, since that's all I need. Not a whole user
15:42:18 <CrazyM4n> jle`: haha
15:42:19 <doismellburning> CrazyM4n: map (\x -> [x]) ? (for slightly more obviousness)
15:42:24 <exio4> :t map (:[])
15:42:25 <lambdabot> [a] -> [[a]]
15:42:27 <exio4> :t fmap return
15:42:28 <lambdabot> (Functor f, Monad m) => f a -> f (m a)
15:42:29 <alpounet> what?
15:42:32 <Cale> bmuk: So, use String?
15:42:45 <doismellburning> (for a loose value of obviousness)
15:42:51 <CrazyM4n> doismellburing: I think that map (:[]) is pretty readable, I just didnÂ´t think of using :[] as a function
15:42:53 <CrazyM4n> ItÂ´s smart
15:42:56 <Cale> bmuk: Either you have a datatype which is appropriate for representing just a username, or you don't :)
15:42:58 <jle`> it's a section :D
15:42:58 <alpounet> sinelaw: what do you mean by 'useless', re. function composition in ocaml?
15:43:01 <jle`> we call it the robot monkey operator
15:43:01 <doismellburning> CrazyM4n: sure
15:43:01 <CrazyM4n> But your idea is good too
15:43:11 <doismellburning> CrazyM4n: I tend to forget things like : are functions
15:43:13 <bmuk> Cale: I suppose you are right. I can just newtype Username = Username String to do what I want
15:43:18 <doismellburning> CrazyM4n: ymmv :)
15:43:29 <CrazyM4n> doismellburning: I call it the C++ effect :P
15:43:32 <jle`> what other things are like :?
15:43:34 <bitemyapp> doismellburning: why not use map return?
15:43:34 <sinelaw> alpounet, I take that back, not useless
15:43:38 <jle`> that you find hard to see as functions?
15:43:43 <jle`> *forget
15:43:49 <bmuk> Cale: I wanted to leverage the User type I have already defined, but I suppose it isn't necessary
15:43:51 <monochrom> example of not appropriate for usernames: (Char, Char, Char) :)
15:43:53 <CrazyM4n> Math operators, for one
15:43:58 <CrazyM4n> Those are a bit more obvious
15:44:02 <CrazyM4n> But still, sometimes you forget
15:44:07 <alpounet> sinelaw: I agree that it's less handy and that it feels more clumsy though :p
15:44:07 <jle`> but i think we do (+3), (<5), etc.
15:44:12 <CrazyM4n> Definately
15:44:19 <jle`> maybe : is the only one of its kind
15:44:21 <sinelaw> alpounet, because of the value restriction, it isn't as useful
15:44:26 <alpounet> yeah
15:44:38 <Cale> IIRC, in most MLs, data constructors are not properly functions for some reason.
15:44:52 <bitemyapp> Cale: god why?
15:45:01 <jle`> they're also not curried what the
15:45:03 <sinelaw> alpounet, composition is not interchangeable with implementing the composed function directly
15:45:11 <alpounet> right
15:45:14 <bitemyapp> jle`: fml
15:45:24 <sinelaw> e.g. (+2) . (+2) is not the same as (+4)
15:45:31 <CrazyM4n> Why would that be?
15:45:31 <Cale> Well, the not being curried thing is mostly cultural
15:45:36 <CrazyM4n> They have the same effect, donÂ´t they?
15:45:51 <Cale> Most functions in MLs simply aren't curried
15:46:08 <sinelaw> CrazyM4n, that's a bad example actually, because + already restricts the type
15:46:19 <CrazyM4n> In traditional math, (f.g)(x) where f x = x + 2 and g likewise
15:46:34 <CrazyM4n> (f.g)(x) would equal x+2
15:46:39 <CrazyM4n> So whatÂ´s the difference in haskell?
15:46:44 <sinelaw> a better example is: twice x = (x, x), then twice . twice != (\x -> ((x,x),(x,x))
15:46:44 <CrazyM4n> err, x+4, oops
15:46:57 <absence> https://ghc.haskell.org/trac/ghc/ticket/9123#comment:23 <- simon pj says "Our current solution seems workable", but i don't understand much about roles or the problems. does anyone know if this means "join" will be a member of Monad after all?
15:46:58 <sinelaw> in ML
15:46:58 <CrazyM4n> I see what you are saying now
15:47:08 <sinelaw> not in haskell
15:47:18 <CrazyM4n> Really?
15:47:37 <sinelaw> > let twice x = (x,x) in twice . twice 4
15:47:38 <lambdabot>  Couldn't match expected type â€˜a -> bâ€™ with actual type â€˜(t0, t0)â€™
15:47:41 <sinelaw> > let twice x = (x,x) in twice . twice $ 4
15:47:42 <lambdabot>  ((4,4),(4,4))
15:47:50 <CrazyM4n> Hm
15:48:14 <CrazyM4n> Haskell never ceases to amaze me
15:48:19 <CrazyM4n> Even if thatÂ´s quite mundane
15:48:25 <CrazyM4n> Just how readable that is
15:48:37 <sinelaw> in haskell you can compose twice. twice and get a function of type :: a -> ((a,a),(a,a))
15:48:43 * hackagebot yesod-auth-account 1.4.0 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.4.0 (JohnLenz)
15:48:50 <sinelaw> in ocaml you'll get a monomorphic valued function
15:49:04 <Zekka> (because twice :: a -> (a, a))
15:49:17 <Zekka> (and not, say, twice :: Int -> (Int Int))
15:49:35 <bitemyapp> sinelaw: how does it pick the type?
15:49:43 <sinelaw> bitemyapp, first usage
15:50:11 <sinelaw> let fourTimes = twice . twice
15:50:18 <monochrom> if you define "f = twice . twice", you fall under the restriction. if you define "f x = (twice . twice) x", you don't fall under the restriction. it is a bit of a concession, but not so much as to affect "map (f . g) xs"
15:50:30 <sinelaw> then if later you do: fourTimes 2, the type of fourTimes will be: Int -> ....
15:50:30 <CrazyM4n> Can you have a list of [a -> a] then map over it, applying arguments?
15:50:43 <CrazyM4n> Say, a list of [head, last]
15:50:43 <sinelaw> monochrom, true
15:50:50 <bitemyapp> sinelaw: nothx.
15:50:51 <CrazyM4n> And map over it applying arguments
15:51:18 <sinelaw> bitemyapp, but monochrom is right
15:51:25 <CrazyM4n> Not neccesarily [a -> a], but more in general, can you have an array of functions?
15:51:29 <CrazyM4n> *list
15:52:42 <bitemyapp> > head [id, id, id]
15:52:43 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:52:43 <lambdabot>    arising from a use of â€˜M851428275735287525417963.show_M8514282757352875254...
15:52:43 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
15:52:43 <lambdabot>  Note: there are several potential instances:
15:52:43 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:52:50 <bitemyapp> thanks lambdabot.
15:52:53 <bitemyapp> point is, yeah.
15:53:02 <CrazyM4n> How would you use it?
15:53:03 <sinelaw> monochrom, it's kind of telling that ocaml doesn't have composition in the core library
15:53:22 <sinelaw> i wonder how they write code without it
15:53:23 <CrazyM4n> > map ([head, last]) [1,2,3]
15:53:25 <lambdabot>  Couldn't match expected type â€˜a0 -> bâ€™
15:53:25 <lambdabot>              with actual type â€˜[[a1] -> a1]â€™
15:53:26 <sinelaw> or does everybody define it
15:53:30 <CrazyM4n> DidnÂ´t think so
15:53:34 <monochrom> SML has it in its Prelude IIRC. it's called the lowercase letter o.
15:53:48 <sinelaw> heh
15:53:58 <bitemyapp> CrazyM4n: why do you think you can apply a list as if it were a function?
15:54:21 <CrazyM4n> bitemyapp: Because it is a list of functions. I know it was wrong, just wanted to see what would happen
15:54:38 <CrazyM4n> I donÂ´t think this is possible without rolling my own iterator
15:54:57 <monochrom> SML also has this ability: if you declare an alphanumeric name infix, then you don't need to surround it with anything to say that you use it infixly. so, for example, map (f o g) xs is how you use it!
15:55:00 <bitemyapp> > [(+1), (*0), (*10)] <*> [1, 2, 3]
15:55:02 <lambdabot>  [2,3,4,0,0,0,10,20,30]
15:55:03 <sinelaw> @hoogle [a ->b] ->[a] ->[b]
15:55:06 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:55:06 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
15:55:06 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
15:55:17 <c_wraith> monochrom: doesn't that make parsing a little complex?
15:55:20 <bitemyapp> CrazyM4n: ^^
15:55:23 <sinelaw> @hoogle [a ->b] ->[a] ->[[b]]
15:55:23 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:55:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
15:55:23 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
15:55:27 <CrazyM4n> Ooo
15:55:31 <geekosaur> you can do it, it's just mapping twice
15:55:51 <monochrom> oh, definitely. even I can't parse it, as a human. :)
15:55:58 <sinelaw> monochrom, sounds confusing to humans
15:56:01 <sinelaw> Ruby-style
15:56:13 <joelteon> no, scala style
15:56:15 <joelteon> ruby can't do that
15:56:20 <sinelaw> ruby an do worse
15:56:44 <sinelaw> but not with infix, I guess
15:57:42 <monochrom> so, what happens in practice is that, apart from o, people try to use all-caps for alphanumeric names they intend to declare infix. for example "x THEN y" where THEN is infix. that helps, but requires everyone to stick to the same convention.
15:58:14 <sinelaw> have the compiler enforce it
15:58:16 <c_wraith> If only they had some compiler-enforced convention, like a subset of valid identifier symbols being usable only for infix operators.
15:59:33 <CrazyM4n> Wait, [] is a monad. Every piece of code that IÂ´ve read using liftM2 makes sense now
16:00:09 <CrazyM4n> ThatÂ´s great
16:08:44 * hackagebot yesod-auth-fb 1.6.6 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.6 (FelipeLessa)
16:13:45 * hackagebot yesod-auth-deskcom 1.4.0 - Desk.com remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-deskcom-1.4.0 (FelipeLessa)
16:25:37 <CrazyM4n> > let x = 2 in x == 2 or x == 3
16:25:38 <lambdabot>  Precedence parsing error
16:25:38 <lambdabot>      cannot mix â€˜GHC.Classes.==â€™ [infix 4] and â€˜GHC.Classes.==â€™ [infix 4] in ...
16:25:52 <CrazyM4n> > let x = 2 in ((x == 2) or (x == 3))
16:25:54 <lambdabot>  Couldn't match expected type â€˜([GHC.Types.Bool] -> GHC.Types.Bool)
16:25:54 <lambdabot>                                -> GHC.Types.Bool -> tâ€™
16:25:54 <lambdabot>              with actual type â€˜GHC.Types.Boolâ€™
16:26:05 <CrazyM4n> > 3 == 2
16:26:06 <lambdabot>  False
16:26:18 <CrazyM4n> > 3 == 2 or 2 == 2
16:26:19 <lambdabot>  Precedence parsing error
16:26:19 <lambdabot>      cannot mix â€˜GHC.Classes.==â€™ [infix 4] and â€˜GHC.Classes.==â€™ [infix 4] in ...
16:26:27 <CrazyM4n> > (3 == 2) or (2 == 2)
16:26:29 <lambdabot>  Couldn't match expected type â€˜([GHC.Types.Bool] -> GHC.Types.Bool)
16:26:29 <lambdabot>                                -> GHC.Types.Bool -> tâ€™
16:26:29 <lambdabot>              with actual type â€˜GHC.Types.Boolâ€™
16:26:32 <CrazyM4n> ;;
16:27:25 <rbrewster> I think you want (||), not or
16:27:37 <CrazyM4n> > or [(3 == 2), (2 == 2)]
16:27:38 <lambdabot>  True
16:27:46 <CrazyM4n> Yea, || is what I want, lol
16:27:48 <CrazyM4n> Thanks
16:32:28 <deathgrindfreak> let a = map (\x -> read x :: Int) ["1", "2", "3", "4"]
16:32:35 <deathgrindfreak> > let a = map (\x -> read x :: Int) ["1", "2", "3", "4"]
16:32:36 <lambdabot>  not an expression: â€˜let a = map (\x -> read x :: Int) ["1", "2", "3", "4"]â€™
16:33:01 <tommd> deathgrindfreak: You need an " in foo" part to your let.
16:33:22 <deathgrindfreak> ah, wasn't sure if it followed ghci syntax or not
16:35:35 <pjdelport> > map read ["1", "2", "3", "4"] :: [Integer]
16:35:36 <lambdabot>  [1,2,3,4]
16:36:12 <deathgrindfreak> very cool, was unsure if the ">" was needed or not as well.
16:45:18 <rqiu> can someone take a look at this: Err.hs:59:3: parse error on input â€˜printâ€™, but it works when directly input into GHCI.  ghci> print $ (divBy 2 40) >>= (divBy 4)  -- output: OK 5
16:47:29 <rqiu> http://lpaste.net/111932
16:50:19 <Cale> rqiu: Your problem is that your editor is not configured to convert tabs to spaces
16:50:29 <rqiu> just changed it
16:51:21 <rqiu> now it works, thanks
16:51:23 <Cale> rqiu: (If you look at that lpaste, it should be clear why the syntax error is happening -- the print on line 59 isn't lined up with the others, because tabs are treated as aligning to the next multiple of 8 columns)
16:58:46 * hackagebot yesod-static-angular 0.1.3 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.3 (JohnLenz)
17:01:28 <dert> Can somebody help me out with a weird error?
17:01:41 <dert> I get No instance for (transformers-0.3.0.0:Control.Monad.IO.Class.MonadIO HNet)
17:01:57 <dert> Even though I clearly have a MonadIO HNet instance
17:02:59 <Cale> The presence of the package qualifier suggests that you might have more than one transformers, and your instance is for the MonadIO from the wrong one
17:03:19 <dert> That sounds very likely
17:03:26 <dert> How do I specify a version?
17:03:39 <dert> I have transformers >= 0.4 in my cabal file
17:04:30 <Cale> Well, which thing are you using that generates the MonadIO constraint?
17:04:41 <Cale> Is it from some other package which is built against 0.3.0.0?
17:07:19 <gdoteof> http://lpaste.net/8250122242738880512
17:07:42 <gdoteof> ^^ hGetContents is being weird on osx.. (i think)
17:08:03 <gdoteof> the function above is what i use to read from a FIFO, and generally works as intended
17:08:51 <c_wraith> I wouldn't expect hGetContents to work right with a FIFO
17:08:51 <Cale> You should generally never execute hClose hdl after hGetContents hdl
17:09:00 <gdoteof> but occasionally it will hang, and when it hangs it prints out " before the evaluate on .." but doesn't evaluate
17:09:07 <gdoteof> Cale: really?
17:09:35 <gdoteof> if, before the evaluate, i do liftIO $ print $ show $ length o  it will hang on that as well
17:09:37 <srhb> hGetContents should be used when the input is closed "from the other side"
17:09:53 <Cale> The responsibility for closing a handle that's had hGetContents applied to it is taken by evaluating the end of the String, or having the String garbage collected
17:10:18 <gdoteof> srhb: there is another process that is writing to the fifo, and i don't want to read until that process is "done"
17:10:56 <Cale> While you can do something like you're doing, evaluating the length and then closing the handle, it's not what you're supposed to do.
17:11:00 <gdoteof> Cale: that is good to know.  does that seem like it could be causing an issue like i am describing or is that just an aside
17:11:21 <gdoteof> Cale: what am i supposed to be doing, pray tell
17:11:28 <jle`> so...the wikipedia article for Kleisli calls bind "extension"
17:11:33 <jle`> so is extend "coextension"?
17:11:37 <jle`> that's rather unfortunate
17:11:55 <Cale> gdoteof: I'd just use a strict hGetContents, like the one from (strict) Data.ByteString or Data.Text
17:12:00 <erikd> is there a cabal development channel?
17:12:06 <Cale> If you really need a String, you can always convert
17:12:36 <Cale> It's a bit of a shame that there isn't a strict hGetContents for String directly as well
17:12:46 <dfeuer_> Cale: can a handle be closed "from the other side"? That would seem unfortunate.
17:14:17 <c_wraith> dfeuer_: not in general, but pipes can be
17:16:13 <dfeuer_> c_wraith: does the handle actually close from that end, or just the file descriptor? I'm asking because of #9236
17:16:23 <gdoteof> Cale: if i use Data.Text.IO.hGetContents  it will be read strictly ?
17:16:48 <Cale> yeah
17:16:51 <dfeuer_> Which is https://ghc.haskell.org/trac/ghc/ticket/9236
17:16:56 <shachaf> gdoteof: It gives you a strict Text, so it has to.
17:17:50 <Cale> I'm pretty sure that this will end up blocking until the FIFO is closed
17:18:15 <Cale> After all, there might be more stuff to read that just hasn't been supplied by the other end yet
17:18:24 <Cale> and that's the same as your current situation
17:18:44 <gdoteof> Cale: yeah it should blcok until it is closed
17:19:49 <dfeuer_> Cale, I have the feeling you might find that feature request pleasant, if it's possible to implement.
17:21:00 <Cale> dfeuer_: I would change it so that hClose on a handle which is semi-closed is an error.
17:21:16 <Cale> But possibly your way is more friendly :)
17:22:32 <dfeuer_> Well, your way would break a lot of working code; mine would only "break" extremely flaky code.
17:24:15 <gdoteof> ok i am getting my buddy to test it on osx
17:24:23 <gdoteof> it should be noted this is also happening only on osx
17:24:27 <Cale> dfeuer_: Yeah, your change is probably less disruptive :)
17:25:02 <Cale> gdoteof: It's blocking?
17:25:22 <dfeuer_> But mine depends on it not being possible to actually close the *handle* from the other side (even if the file descriptor closes). I can't tell if that happens or not...
17:26:04 <gdoteof> Cale: yes it blocks, and only randomly
17:26:12 <gdoteof> er, random from my perspective :)
17:27:03 <gdoteof> Cale: and i can confirm it is still happening
17:27:16 <gdoteof> on osx, with the Text version of hGetContents
17:27:54 <Cale> Well, that sounds like the FIFO hasn't ended yet
17:28:00 <Cale> for some reason
17:28:16 <gdoteof> http://lpaste.net/8250122242738880512 is the updated
17:28:48 <Cale> btw, with the strict hGetContents, you're allowed to close the handle
17:28:51 <gdoteof> Cale: well, i can manually cat the pipe; and it hangs (ie, there is nothing still in there)
17:29:00 <gdoteof> and the process writing to the pipe is indicating it is done
17:29:03 <Cale> But the hGetContents won't finish until the pipe closes
17:29:29 <Cale> If cat hangs then this hangs for the same reason
17:29:54 <gdoteof> Cale: but the output has already happened
17:30:17 <gdoteof> the other process /did/ write the pipe; and i am reasonably confident closed it as well
17:30:53 <gdoteof> and, pardon my relative noobery.. the fact that it is acting differently on mac than linux gives me pause
17:31:39 <Cale> hm
17:31:44 <gdoteof> Cale: and!! maybe this is betraying my lack of udnerstanding.. pritn statements below the hGetContents do print (ie, it doesn't appear to hang on that function call)
17:32:01 <gdoteof> but, if i try and print what came out of hGetContents, then it hangs
17:32:04 <Cale> gdoteof: With the lazy one or the strict one?
17:32:18 <Cale> Lazy hGetContents always returns immediately
17:32:28 <gdoteof> or if i try and print the length of the output , or evaluate the length of the output
17:32:36 <Cale> It produces a magical String, the evaluation of which will actually read from the Handle.
17:32:59 <Cale> Strict hGetContents doesn't do that magic, and should block here.
17:33:08 <gdoteof> Cale: hmm i can only confidently say int he lazy one
17:34:05 <gdoteof> Cale: okay i can confidently say that youa re right, it is indeed hanging on hGetContents
17:34:10 <gdoteof> in the strict version
17:37:24 <Cale> gdoteof: Try this: Make a fifo in the current directory called "fifo", and in another window run cat > fifo then open ghci and:  import Data.Text.IO  as well as  System.IO and then write h <- openFile "fifo" and then Data.Text.IO.hGetContents h
17:37:44 <Cale> It should hang, whether you're on Linux or Mac OS X
17:38:04 <Cale> and it should finish when you Ctrl-D in the window with cat
17:38:30 <gdoteof> Cale: yeah it will hang.  i do understand to some degree what is going on (i have 50+ hours trying to fix this damn bug)
17:38:41 <gdoteof> the thing is, it works.. 99.9% of the time
17:38:50 <gdoteof> but suddenly it stops
17:38:55 <gdoteof> and it hangs there
17:41:40 <srhb> Doesn't seem likely the issue is on the Haskell side.
17:41:51 <srhb> That trace is killing me though. :-)
17:42:08 <gdoteof> well.  as vindicating as taht would be i might cry a bit
17:42:22 <gdoteof> i gave you guys the cleaned up one :(  so many traces
17:43:31 <srhb> also the liftIO is confusing me. But I assume you will be using it in a transformer at some point.
17:44:54 <gdoteof> srhb: er that's actually an artifact of this originally being in a transformer
17:44:59 <srhb> righto.
17:53:07 <srhb> gdoteof: Curious, what does hIsEOF hdl do on a fifo?
17:54:54 <gdoteof> srhb: my understanding is that it will return True when the pipe handle is being held by another process
17:55:09 <srhb> Aha
17:55:34 <gdoteof> readFile does not work on Fifos as it will just return immediately if the other process hasn't written yet
17:55:40 <gdoteof> instead of blocking
17:56:16 <gdoteof> i was also using a readProcess "cat filePath" but that is wonky too
17:57:10 <gdoteof> trying right now to prove that it closing on the other end
17:57:55 <srhb> gdoteof: Trying to figure out how fifos work.. :-)
17:58:47 <srhb> What does "being held by another process" mean in this context?
17:59:04 <gdoteof> so, i feel very confident that the otherprocess is closing the the pipe
17:59:42 <gdoteof> srhb: the matlab process has opened the pipe for writing but has not yet written to it
18:00:25 <srhb> gdoteof: That should be hIsEOF ~ True?
18:00:33 <gdoteof> srhb: that is my understanding
18:00:39 <srhb> Okay
18:01:37 <gdoteof> but, i have aged like 12% of my life on this bug; and that isEof is something that survived some.. i've heard it described in #haskell as "programming by brownian motion"
18:02:29 <gdoteof> the matlab process is now outputting the status of the fclose, which is successful
18:02:36 <gdoteof> Cale: ^^
18:06:32 <srhb> gdoteof: Well, it's a different issue, but I just tried to cat | tree fifo and then running the program
18:06:36 <srhb> it blocks on hIsEof
18:06:47 <srhb> tee, not tree
18:07:05 <srhb> And I straced tee and it has open()'ed the fifo
18:07:12 <gdoteof> probably also relevant that the data being read from the pipe is larger than the buffersize
18:07:33 <srhb> gdoteof: It seems like cutting this program down would help
18:07:36 <gdoteof> that is, largetr than the buffersize when it is nto explicitly set to linebuffering
18:07:41 <srhb> how about getting rid of the hIsEOF and LineBuffering
18:08:10 <Cogz> haskell > ?
18:08:13 <gdoteof> srhb: mk
18:08:53 <Axman6> Cogz: was that supposed to be a question?
18:09:24 <Cogz> I should of been more specific but yes it was
18:09:38 <gdoteof> srhb: it may be that it returns true in the case where the other process has started, but not finished writing to the file"
18:09:54 <gdoteof> Cogz: haskell > visual basic?
18:10:04 <srhb> I'll test that
18:10:24 <srhb> gdoteof: Nope, that's a False
18:10:40 <gdoteof> hm.  well it doesn't appear to ever be hanging there for me, but ill take it out
18:11:11 <Cogz> first time hearing about haskell actually
18:11:21 <srhb> Cogz: Welcome, then :)
18:11:46 <gdoteof> haskell is easy once you figure all the hard parts out
18:11:52 <Cogz> srhb - apperciate it
18:14:39 <Axman6> Cogz: so what do you ewant to know? Haskell > ? isn't a very meaningful question
18:15:25 <srhb> Axman6: That's because you're misintepreting the symbol. It's "leads to" not "greater than"
18:15:30 <srhb> So the answer is obviously Category Theory
18:16:23 <gdoteof> Cale: where in http://hackage.haskell.org/package/text-1.1.1.3/docs/src/Data-Text-IO.html#hGetContents would you expect this to be hanging?
18:16:26 <jayunit100_4g> what does "in" do in haskell,  for example, if i have :::::: let x = (let y = "hello") in y
18:16:59 <jayunit100_4g> clearly somehow the "in" keyword allows x to bind to y's value.
18:16:59 <srhb> jayunit100_4g: Uh, that won't work
18:17:05 <srhb> does it?
18:17:23 <srhb> > let x = (let y = "hello") in y
18:17:23 <jayunit100_4g> let x = (let y = "hello" in y)
18:17:24 <lambdabot>  <hint>:1:25: parse error on input â€˜)â€™
18:17:27 <jayunit100_4g> sorry, parens
18:17:52 <nshepperd> 'in' is not anything special
18:17:55 <jayunit100_4g> just goes to show how desparately i need help with the 'in' word.
18:18:07 <srhb> let foo = bar in foo -- this is what you mean, yes?
18:18:08 <nshepperd> "let * in *" is one expression
18:18:20 <jayunit100_4g> let * in * â€¦.
18:18:29 <srhb> jayunit100_4g: It's an expression that is equal to the right hand side of the in, with the names bound after let
18:18:36 <srhb> > let x = 2 in x
18:18:38 <lambdabot>  2
18:18:49 <srhb> let x = 2; y = 4 in x*y
18:18:49 <jayunit100_4g> > let x = 2
18:18:50 <lambdabot>  not an expression: â€˜let x = 2â€™
18:18:55 <srhb> > let x = 2; y = 4 in x*y
18:18:56 <lambdabot>  8
18:19:04 <gdoteof> i never use in; but my understanding is that  the stuff between the `for` and the `in` is the context for the stuff inside the `in` block
18:19:04 <srhb> jayunit100_4g: That particular form is only valid in a do block
18:19:15 <srhb> jayunit100_4g: And even then it desugars to let ... in ...
18:19:30 <Axman6> let  <list of defs> in <erxpression which can reference those defs>
18:19:37 <gdoteof> and, srhb the paired down version still blocks on osx
18:20:03 <srhb> gdoteof: How does it look now?
18:20:07 <jayunit100_4g> why do i need "in x" when i say "let x = 2"
18:20:09 <Axman6> > let x = 7; y = x + 4 in x^y
18:20:10 <lambdabot>  1977326743
18:20:21 <srhb> jayunit100_4g: You don't in all circumstances
18:20:38 <gdoteof> http://lpaste.net/8250122242738880512
18:20:38 <Axman6> jayunit100_4g: because an expression must return a value. let x = 2 doesn't return anything
18:20:40 <srhb> jayunit100_4g: When you do, it's because you were writing an expression, and let x = 2 is not an expression
18:20:57 <Axman6> just like how you can have 'if x then y' without the 'else x'
18:21:08 <Axman6> > let y = 2
18:21:09 <lambdabot>  not an expression: â€˜let y = 2â€™
18:21:16 <Axman6> > let y = 2 in y+y
18:21:17 <lambdabot>  4
18:21:29 <srhb> gdoteof: Please kill the trace too.. Just for the hell of it :P
18:21:43 <srhb> trace makes me uneasy.
18:22:06 <jayunit100_4g> so, as a haskell beginner, if i want to learn what "in" is doing in my code.  what do i do?
18:22:31 <gdoteof> i would ask #haskell
18:22:33 <srhb> jayunit100_4g: Here: let x = 2 in x
18:22:36 <jayunit100_4g> :) :)
18:22:43 <srhb> jayunit100_4g: The value of that expression is x
18:22:54 <srhb> jayunit100_4g: Where x has the value defined in between let and in
18:22:59 <srhb> There's nothing else to it.
18:23:10 <gdoteof> srhb: if removing the trace fixes this deadlock i am going to disconnect ebcause my machine will be broken
18:23:15 <gdoteof> but if that happens, tyvm
18:23:20 <srhb> gdoteof: Or haskell is buggy, who knows!
18:23:27 <jayunit100_4g> so, your saying that if i have "in", in an expression, the right hand side is returned.
18:23:32 <jayunit100_4g> and thats all there is !?
18:23:36 <eazar001> in is a "scope"
18:23:37 <jayunit100_4g> okay :) i get it then :)
18:23:38 <eazar001> pretty much
18:23:45 <srhb> jayunit100_4g: What you said doesn't make sense, but I think your intuition is right
18:23:52 <srhb> "in" is not in an expression.
18:23:54 <Axman6> jayunit100_4g: you should really be talking about let-in expressions, you can't have in without let
18:24:13 <Axman6> > let <defs> in <expression>
18:24:14 <lambdabot>  <hint>:1:5: parse error on input â€˜<â€™
18:24:17 <jayunit100_4g> Axman6:  ah okay
18:24:19 <jayunit100_4g> that helps
18:24:36 <jayunit100_4g> thanks Axman6 srhb  !
18:24:39 <Axman6> it just allows you to give names to values
18:24:40 <srhb> jayunit100_4g: Sure thing.
18:24:45 <Axman6> no worries
18:25:04 <CrazyM4n> Woo, just finished ConwayÂ´s Game of Life https://gist.github.com/CrazyM4n/65e247be4b093fb15f78
18:25:21 <CrazyM4n> Any suggestions to render it?
18:25:28 <srhb> gloss?
18:25:29 <codehero> CrazyM4n: wow
18:25:31 <codehero> nise
18:25:33 <codehero> *nice
18:25:47 <CrazyM4n> codehero: WerenÂ´t you the guy yesterday that was making GoL also?
18:25:52 <CrazyM4n> And gloss is meh
18:25:56 <codehero> GoL?
18:26:00 <CrazyM4n> Game of Life
18:26:04 <codehero> no
18:26:04 <srhb> CrazyM4n: gloss is pretty great for things like that.
18:26:05 <codehero> :P
18:26:23 <srhb> One might even say ideal... :P
18:26:24 <napping> How about plain text to start?
18:26:30 <CrazyM4n> Ah, there was someone here that was making game of life, and I wanted to also
18:26:35 <CrazyM4n> It is in plain text output right now
18:26:49 <CrazyM4n> srhb: Oh? Can gloss do simple little animations of the GoL living?
18:26:58 <srhb> CrazyM4n: Yes?
18:27:03 <CrazyM4n> I thought it was all just vector graphics stuff
18:27:07 <srhb> I wrote snake with a GUI using gloss.
18:27:10 <napping> ah, so it is
18:27:32 <CrazyM4n> ThatÂ´s cool, but rendering a grid might be a pain
18:27:35 <CrazyM4n> I know a little gloss
18:27:37 <CrazyM4n> IÂ´ll try it
18:27:39 <srhb> I rendered a grid in gloss.
18:27:42 <srhb> It was pain-free.
18:27:49 <CrazyM4n> lol ok
18:27:54 <CrazyM4n> IÂ´ll look at it, youÂ´ve convinced me
18:27:56 <gdoteof> srhb: removing trace does not fix it
18:27:56 <srhb> :)
18:28:01 <napping> it's mostly vector graphics, but it does have interfaces for animation
18:28:01 <srhb> gdoteof: Thank goodness. :-)
18:28:51 <srhb> gdoteof: Can you recreate the bug by writing to the pipe with something simple? So we could post a (fairly) reproducible bug report?
18:30:23 <CrazyM4n> srhb: I canÂ´t quite find a tutorial
18:30:47 <CrazyM4n> Is the code to say, render a list as a seires of boxes simple enough to just post?
18:30:55 <gdoteof> srhb: yeah that is what i have been avoiding :).  one more thing i want to pick your brain on before i make something reproducible
18:31:20 <srhb> gdoteof: I'm probably not the right person to brain-pick, I've just been testing as we went along.
18:31:29 <srhb> To try to minimize probable causes
18:31:42 <gdoteof> this is happening inside a Yesod application and only happens with multiple concurrent requests
18:32:27 <gdoteof> i had lost some context chasing it down to that specific line where it hangs that i forgot the relevant part that it will never happen if there aren't thigns competing.
18:33:11 <gdoteof> that being said, i have gone to pretty big lengths to keep things in sync and don't have an understanding about how that might affect things
18:33:20 <srhb> Aha...
18:33:24 <srhb> Hmm
18:33:56 <CrazyM4n> Found this, https://hackage.haskell.org/package/gloss-examples-1.8.2.1/src/picture/Conway/
18:34:01 <CrazyM4n> ItÂ´s hard to be original :P
18:34:19 <srhb> gdoteof: Well, that's a problem for sure
18:34:23 <gdoteof> srhb: that is, it only happens when running multiple concurrent sessions on OSX
18:34:34 <srhb> gdoteof: Or well, hang on.. Testing.
18:35:38 <srhb> gdoteof: I mean, if two threads are reading from the same fifo, that's fairly useless, so hopefully you've made sure that doesn't happen?
18:35:56 <gdoteof> srhb: i have done my best.. i will copy relevant code, one sec
18:36:03 <gcganley> :t span
18:36:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:36:42 <CrazyM4n> This will sound stupid, but how do you get to the package docs from the cabal page?
18:36:58 <CrazyM4n> http://hackage.haskell.org/package/gloss from here to where it describes all of the functions
18:37:16 <gdoteof> http://lpaste.net/8250122242738880512
18:37:29 <Cale> CrazyM4n: Once the documentation gets generated, those module names become links
18:37:30 <srhb> CrazyM4n: Not stupid, some versions don't have docs built
18:37:38 <srhb> CrazyM4n: Go back to an earlier version.
18:37:42 <Cale> http://hackage.haskell.org/package/gloss-1.8.1.2
18:37:55 <CrazyM4n> I see, thanks
18:37:57 <Cale> Why has the documentation generation been slow, does anyone know?
18:38:07 <gdoteof> srhb: excuse the first drainFifo definition
18:39:02 <srhb> gdoteof: And SessionId is a ThreadID?
18:39:09 <CrazyM4n> oh, gloss is really easy! This is great!
18:39:15 <gdoteof> http://lpaste.net/111938
18:39:49 <gdoteof> srhb: no.. it is just a string that refers to the essentially the path for the fifo
18:40:06 <gdoteof> i am not doing any forking on my own
18:40:45 <gdoteof> SessionId = String
18:41:38 <srhb> gdoteof: Digesting... :P
18:43:19 <srhb> The atomically stuff is slightly scary, I think
18:43:35 <gdoteof> srhb: yes.
18:43:56 <srhb> Do you really need it? Don't you just want to block if you try to takeMVar on one that does not exist?
18:44:01 <srhb> er, is empty* rather
18:44:13 <gdoteof> my journey from IORef -> MVar -> TMVar
18:45:19 <gdoteof> i do want it to block if it tries tot ake one for a sessionid that is empty
18:45:39 <srhb> I'm fairly sure you don't want those atomicallys
18:46:06 <srhb> And in fact only want MVars. If we can trust that the lockmap is actually globally available to all threads (which I assume is done by creating it before Yesod is started)
18:46:12 <gdoteof> but new sessions can be created, and when that happens, a "global" map of SessionId -> TMVar ()'s needs to be updated
18:46:24 <gdoteof> srhb: yes that is what happens
18:46:37 <srhb> Right, so atomically and co only confuse the matter
18:47:10 <gdoteof> but don't i have to use atomically to access TMVars?
18:47:17 <srhb> Yes, but you want MVar
18:47:19 <srhb> Not TMVar
18:48:03 <pharaun> there exits TMVar oO
18:48:14 <srhb> At least I see absolutely no reason to have STM here, and it's confusing _me_ :P
18:48:34 <gdoteof> that is believable ;)  (brownian motion)
18:48:44 <gdoteof> i will switch back to mvar and see
18:49:19 <gdoteof> srhb: and to be clear you are suggesting that the LockMap itself be stored as an MVar
18:49:29 <gdoteof> as well as the Map of Mvars for the individual sessions
18:50:33 <srhb> gdoteof: You needn't actually store the individual sessions as MVars
18:50:40 <srhb> MVar (Map String ()) should be sufficient
18:50:55 <srhb> Though I suppose if things are slow, you might want to give back the map earlier
18:51:05 <gdoteof> srhb: I am not storing the list of sessions to keep track of the sessions
18:51:10 <srhb> I know
18:51:15 <gdoteof> i am storing a map of sessions to locks, because i have to lock the individual sessions
18:51:23 <srhb> You're storing a () for each session that's trying to read from a fifo
18:52:10 <gdoteof> doesn't then each concurrent process block on access to the LockMap?
18:52:40 <gdoteof> like, what would the implementation of waitLock be; if tit were not an MVar
18:52:42 <srhb> Yeah so you can keep the ()s MVars as well
18:52:55 <srhb> It wouldn't be necessary if we knew that reading the fifo was a fast operation, but it might not be
18:53:10 <gdoteof> ah.  yes it definitely may not be
18:53:26 <srhb> So MVar (Map String (MVar ()))
18:53:42 <gdoteof> yes.
18:53:54 <srhb> Just to be absolutely clear, each SessionID is reading from its own, specific fifo, right?
18:53:56 <srhb> No shared fifos
18:54:38 <srhb> I assume that's what getInputPipe and getOutputPipe do
18:55:16 <gdoteof> srhb: each session id has it's own fifo yes'
18:55:21 <srhb> Goodie.
18:55:26 <srhb> Just making sure :)
18:55:29 <gdoteof> though, multiple requests can both go after the same session
18:55:47 <gdoteof> which was the original problem because user a would get user b's output
18:57:38 <gdoteof> srhb: ok, one thing as i am changing this that i was worried about
18:58:55 <srhb> gdoteof: Mind, I'm by no means an expert in this subject, so if you don't believe me at some point, do stop. :D
18:59:33 <srhb> gdoteof: Oh, this is scary
18:59:35 <srhb>                 putTMVar lm locks'
18:59:37 <srhb>                 addLock lm sid newLock
18:59:55 <srhb> You're putting the map back before adding the lock
19:00:03 <srhb> Oh wait no, MVar of MVar.
19:00:16 <gdoteof> srhb: yes i was just about to bring that up.. but i think i went through the same thougth process
19:00:24 <srhb> Yeah, it's a bit brainmelty
19:00:36 <gdoteof> addLock itself blocks on the lockmap
19:01:17 <srhb> gdoteof: Yes, worst case we get to your error " ..."
19:01:56 <srhb> It would be much nicer to just manipulate the Map directly, I think. Is it really not possible.. *ponders*
19:02:41 <srhb> Anyway, that shouldn't be the issue.
19:03:27 <Axman6> what're you trying to do?
19:04:11 <srhb> Honestly I still can't quite figure out why the inner MVar/TMVar is needed
19:04:22 <srhb> I sorta felt like I'd reasoned my way there before, but now I don't think so.
19:04:42 <srhb> (We're slowly working our way back to IORefs now... :P)
19:05:15 <Axman6> IORefs are great
19:05:24 <gdoteof> srhb: simply because there is a race condition that happens if two requests are trying to read the same pipe
19:05:46 <gdoteof> srhb: if the inner thing was not MVar then i wouldn't need an outer MVar to contain it
19:05:56 <srhb> gdoteof: But that's ok, we're only blocking on the takeMVar lm
19:06:07 <srhb> And we're putting that map back as soon as we've checked if the key is already there
19:06:23 <gdoteof> srhb: we are also blocking on waitLock
19:06:27 <srhb> Oh... sec
19:06:44 <srhb> Remind me why we're doing that.
19:07:35 <gdoteof> waitLock blocks per SessionId  otherwise there could be a race condition where two threads both try and read the same pipe
19:07:53 <gdoteof> and the right one doesn't always win.
19:07:56 <srhb> Why not just recurse if we don't have a lock?
19:08:03 <srhb> and only do the rest if we have one
19:08:24 <gdoteof> srhb: we can.  in fact, that is the existing work around.. a single global lock
19:08:27 <gdoteof> just an MVar ()
19:08:50 <CrazyM4n> wait.. wait wait..
19:08:58 <srhb> gdoteof: But instead of that, we use MVar (Map String ())
19:08:59 <gdoteof> but the time between writing to the inputpipe and reading from the output pipe can be long
19:08:59 <CrazyM4n> How does the coordinate system work in gloss?
19:09:06 <srhb> CrazyM4n: Like in OpenGL I think
19:09:14 <CrazyM4n> Never used OpenGl
19:09:15 <srhb> CrazyM4n: origo is upper left corner, right?
19:09:17 <srhb> I think so
19:09:18 <CrazyM4n> Nope
19:09:19 <gdoteof> srhb: but how is that different?
19:09:21 <CrazyM4n> ItÂ´s in the middle
19:09:27 <gdoteof> why do i care about a map to voids
19:09:35 <gdoteof> or whatever () is called
19:09:37 <srhb> gdoteof: You care because we're checking if the key exists
19:09:45 <srhb> gdoteof: we could have used MVar [SessionID] instead
19:10:04 <gdoteof> but i don't care if the key exists if i don't get to do anything different whether or not it exists
19:10:06 <srhb> Your one global MVar () is not identical to what I'm suggesting
19:10:09 <CrazyM4n> So, uh
19:10:10 <srhb> You do!
19:10:23 <srhb> If it exists, you simply recurse back on getPipeResponse v sid
19:11:12 <srhb> gdoteof: Let me try to show.. If my reasoning is completely off, it'll be faster for you this way :P
19:11:41 <gdoteof> i'm trying to understand..
19:12:00 <CrazyM4n> How could I go along turning an [[Int]] into a [Picture]? I want every 1 to correspond to a white square, but I donÂ´t know how I would go along doing the translations
19:14:04 <gdoteof> srhb: maybe you are saying , with an MVar (Map SessionId ()) if the SessionId is in the Map, then block and try again.  if it is not in the map, add it to the map, do the thing, and then take it out of hte map?
19:14:27 <c74d> Does Haskell haveâ€¦ linear patterns, I think theyâ€™re called? Where one can use a name multiple times in a pattern, and the pattern only matches if all those are equal, e.g., `(x:x:xs)` matching `[1, 1, 2, 3]`.
19:14:31 <Axman6> CrazyM4n: where does Picture come from?
19:14:43 <Axman6> c74d: no
19:14:48 <srhb> gdoteof: Meh no, I've confused myself. Sorry, I think I'm too tired to be of any assistance. :)
19:14:51 <c74d> okay, thanks
19:14:58 <Axman6> (though interestingly it does in the type system)
19:15:28 <CrazyM4n> Axman6: Gloss
19:15:32 <gdoteof> srhb: well if i have removed an unnecessary atomically, that is success at least
19:16:01 <srhb> gdoteof: I think you have, but the inner MVar is probably still needed.
19:16:55 <Axman6> CrazyM4n: thought so, it should be easy enough to make two recursive which keep track of your position in the 'matrix'
19:17:26 <Axman6> recursive functions*
19:17:37 <gdoteof> http://lpaste.net/111938  this is just s/TMVar/MVar
19:17:41 <gdoteof> and atomically removed
19:17:51 <gdoteof> still works fine on my machine
19:18:40 <gdoteof> you can even see my residual lockFilePath from my original implementation
19:18:47 <gdoteof> which i forgot about
19:24:22 <srhb> gdoteof: Not that I'm solving things now, but.. I think addLock lm sid = putMVar lm (M.insert sid lm) -- is better
19:24:45 <srhb> Oh, you'd have to pass the old map too of course
19:24:53 <srhb> But I really dislike that it's being closed there..
19:25:00 <gcganley> I've heard all over that Arrows are good for parsers but are they worth all the effort of learning a new category to make better parsers
19:25:24 <srhb> gcganley: Seems like we're getting along fine with monadic parsers.
19:25:41 <shachaf> Don't believe the Arrow propaganda
19:25:44 <ij> I wrote a sudoku solver with []. I think it might be faster with Vector, but I want a transpose. Where can i get one, should I write it?
19:25:52 <gcganley> srhb: i've been eyeing applicative parsers :/
19:26:24 <gcganley> srhb: applicative is alot easier to grok than arrows imo
19:26:26 <shachaf> Applicative is a great abstraction for (almost) context-free parsers.
19:26:29 <srhb> gdoteof: ie addLockMap lm oldMap sid newLock
19:26:29 <ReinH> gcganley: Almost no one actually uses arrows as far as I can tell
19:26:40 <srhb> gcganley: Yeah, of course.
19:26:47 <srhb> gcganley: Moving down the power ladder makes things simpler
19:26:49 <ReinH> applicative and monadic parsers are usually enough
19:26:53 <gdoteof> srhb: still broken on osx with that latest pastebin
19:27:19 <ReinH> if you can't do it with an applicative (i.e. you need to use previous parse results to decide future parses) then you can probably do it with a monad
19:27:46 <srhb> Would be nice to see a minimal example of a parser that can't be done in a monad.
19:27:48 <glaukommatos> Is record syntax in Haskell just a shorthand for doing data MyType = MyConstructor Other Types Go Here, and then making your own 'getter' functions to work with it? Or is that a gross oversimplification?
19:27:48 <gcganley> srhb: I understand conceptually that the power ladder goes Functor -> Applicative -> Monad -> Arrow but why is that
19:27:49 <ReinH> ij: transpose is in Data.List
19:27:55 <ReinH> ij: or do you mean transpose for Vector?
19:28:04 <srhb> gcganley: Not sure what you mean "why"
19:28:10 <srhb> gcganley: More laws apply, therefore...
19:28:18 <ij> ReinH, Yes, for vector.
19:28:29 <ReinH> ij: Generally you'll get a lot more speedup by writing a smarter solver than by switching from list to Vector
19:28:29 <dfeuer> glaukommatos, not a gross oversimplification, but I think there's a "setter" aspect along with the getter.
19:28:40 <ReinH> ij: Look at Richard Bird's solver for a great example
19:28:47 <gcganley> srhb: well what im trying to say is I dont understand what makes Functor less powerful than Monad for instance
19:28:56 <ReinH> A 9x9 board isn't a very expensive thing to manipulate as a list
19:29:06 <gcganley> srhb: I understand you can build more expressive code but is that it?
19:29:13 <ReinH> gcganley: let's look at the types
19:29:16 <ReinH> :t (<$>)
19:29:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:29:19 <ij> ReinH, Sure, but the speed is okay â€” smth like 6 secs for the hardest puzzle I could find. I just want to see how much faster it'll be with Vecor.
19:29:20 <ReinH> :t (=<<)
19:29:20 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:29:33 <ReinH> gcganley: notice that they almost line up?
19:29:54 <srhb> gdoteof: I would try making that change I suggested, if nothing else then for clarity
19:29:59 <gcganley> :ReinH yes as the function returns a monad but the applicative does not
19:30:01 <ReinH> (I've used the flipped >>= to make the similarity more obvious)
19:30:10 <ReinH> gcganley: pretend that both are Monad m
19:30:14 <ReinH> :t liftM
19:30:15 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:30:22 <ReinH> :t (=<<)
19:30:22 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:30:28 <ReinH> How about now?
19:30:46 <ReinH> (and pretend that 'a1' and 'r' are 'a' and 'b' respectively so the type variables line up)
19:31:12 <gcganley> :ReinH fmap == liftM no"?"
19:31:16 <ReinH> The difference is that fmap takes a function a -> b while bind takes a function a -> m b for some monad m
19:31:17 <ReinH> gcganley: yes
19:31:24 <ReinH> liftM is fmap with a Monad constraint
19:31:46 <ReinH> gcganley: So the question is: what can you do with a function Monad m => a -> m b that you can't do with a function a -> b?
19:31:48 <gcganley> :ReinH why not just use fmap if it works and is more general
19:32:31 <ReinH> If that question isn't obvious, how about this one: what is the difference between the strings "a -> m b" and "a -> b"?
19:32:45 <dfeuer> Isn't Arrow *lower* on the "power ladder" than Monad?
19:32:47 <gcganley> :ReinH the monad return
19:32:54 <gcganley> sorry
19:32:56 <ReinH> gcganley: "a -> m b" has an m stuck in there
19:32:57 <srhb> dfeuer: Uh... How?
19:33:28 <ReinH> gcganley: So what does this mean? It means that monadic bind allows you to create an 'm' value while fmap does not allow you to create an 'f' value.
19:33:33 <gcganley> :ReinH ok so you can use functions that return monads rather than non-monadic values
19:33:40 <ReinH> :t fmap
19:33:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:33:47 <srhb> dfeuer: It's been a while though, so you may be right
19:33:52 <ReinH> fmap is restricted to using the f it is given
19:33:54 <ReinH> :t (=<<)
19:33:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:34:08 <ReinH> bind allows you (forces you, in fact) to create a new 'm'
19:34:30 <ReinH> This might be more clear if we think about concrete types
19:34:34 <gcganley> :ReinH wait
19:34:50 <gcganley> :ReinH why do we use >>= instead of =<<
19:34:59 <dfeuer> srhb, actually, it looks more complicated, because Arrows have a different kind than Monads.
19:35:00 <gcganley> :ReinH its just the direction right?
19:35:14 <glaukommatos> dfeuer: Thanks. I've been watching this video and this guy's explaining them and saying I should use algerbraic data types instead, but as far as I understood things, the record syntax was basically syntactic sugar on top of 'data'. I mean, if I do `data Banana = Banana { color :: String }', that's just preventing me from having to type `data = Banana String' and then on another line declaring `color (Banana color) = color'. Am I perhaps missing som
19:35:15 <ReinH> gcganley: Yes, one is just the other flipped.
19:35:30 <ReinH> gcganley: We use >>= more often because it lines up with the <- in do notation
19:35:31 <gcganley> :t (>>=)
19:35:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:35:40 <ReinH> But =<< lets us see the relationship between monadic bind and fmap more clearly
19:35:54 <gcganley> :ReinH ok.
19:36:03 <ReinH> So let's look at a concrete example
19:36:07 <gcganley> :ReinH are they evaluated any differently?
19:36:20 <ReinH> No. One is literally just the other flipped.
19:36:37 <ReinH> :t (=<<) `asAppliedTo` Just
19:36:38 <lambdabot> (b -> Maybe b) -> Maybe b -> Maybe b
19:36:47 <gcganley> :ReinH one sec I'll look at the source, Data.Monad right?
19:36:51 <ReinH> Or, more generally for Maybe:
19:37:00 <ReinH> (a -> Maybe b) -> Maybe a -> Maybe b
19:37:00 <dfeuer> @pl flip (=<<)
19:37:00 <lambdabot> (>>=)
19:37:08 <dfeuer> @pl flip (>>=)
19:37:08 <lambdabot> (=<<)
19:37:13 <ReinH> dfeuer: dance!
19:37:19 <Axman6> @src (=<<)
19:37:19 <lambdabot> f =<< x = x >>= f
19:37:30 <ReinH> Compare that to: (a -> b) -> Maybe a -> Maybe b
19:37:33 * dfeuer dances.
19:37:44 <gcganley> :Axman6 oh wow i didnt know lambdabot had that
19:37:59 <Axman6> it does for some things, not everything though
19:38:08 <ReinH> gcganley: The increased expressive power of Monad comes from bind's ability to modify the "context"
19:38:31 <gcganley> :ReinH does this make it easier to chain together binds... thats what im getting out of it so far in my experience with monads
19:38:33 <srhb> gcganley: It almost doesn't, sadly.
19:38:36 <ReinH> (You might also equivalently say that it comes from join's ability to combine two contexts, but we'll leave that aside for now)
19:39:09 <dfeuer> srhb, oh, I see now.  instance Monad m => Arrow (Kleisli m)
19:39:11 <ReinH> With fmap, I can't change a Just x into a Nothing
19:39:31 <dfeuer> So at least on some level, Arrow is more general/less powerful.
19:39:35 <ReinH> With bind, I can
19:39:40 <gcganley> :t (<*>)
19:39:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:39:51 <ReinH> gcganley: The same goes for applicative
19:39:58 <ReinH> I don't have a way to modify the `f'
19:40:04 <ReinH> :t (<*>)
19:40:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:40:06 <ReinH> :t (=<<)
19:40:07 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:40:09 <gcganley> :ReinH interesting...
19:41:32 <gcganley> wait...
19:41:35 <gcganley> :t return
19:41:35 <lambdabot> Monad m => a -> m a
19:41:44 <gcganley> oh nvm
19:41:48 <ReinH> Here's an example:
19:41:49 <ReinH>  > pure succ <*> Just 1
19:42:10 <ReinH> I can use <*> to access the value inside the Just constructor, but I can't change the Just constructor to Nothing
19:42:12 <srhb> dfeuer: But honestly, the whole Arrow business is not really my forte. When we get to the part where we can turn every function into an arrow but not vice versa, my eyes glaze over.
19:42:32 <ReinH> > const Nothing =<< Just 1
19:42:33 <lambdabot>  Nothing
19:42:36 <dfeuer> srhb, mine too. Haskell does that to me.
19:42:38 <ReinH> With bind, I can modify the "context"
19:42:45 <gcganley> :t const
19:42:45 <lambdabot> a -> b -> a
19:42:47 <ReinH> in this case, the context is just whether you have a Just or a Nothing
19:42:54 <srhb> dfeuer: I'm getting there. I hope. :-)
19:43:03 <ReinH> > (\_ -> Nothing) =<< Just 1 -- without const
19:43:04 <lambdabot>  Nothing
19:43:35 <gcganley> > Just 1 >> Nothing
19:43:36 <lambdabot>  Nothing
19:43:39 <gcganley> ah
19:43:41 <gcganley> i see
19:44:02 <gcganley> > Just 1 <$> Nothing
19:44:03 <lambdabot>  Couldn't match expected type â€˜a0 -> bâ€™
19:44:04 <lambdabot>              with actual type â€˜Data.Maybe.Maybe a1â€™
19:44:17 <gcganley> > Just 1 <*> Nothing
19:44:19 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
19:44:19 <lambdabot>    arising from the ambiguity check for â€˜e_11â€™
19:44:19 <lambdabot>  from the context (GHC.Num.Num (a -> b))
19:44:19 <lambdabot>    bound by the inferred type for â€˜e_11â€™:
19:44:19 <lambdabot>               GHC.Num.Num (a -> b) => Data.Maybe.Maybe b
19:44:24 <gcganley> now that is interesting
19:44:56 <Axman6> 1 isn't a function a -> b
19:45:02 <gcganley> :ReinH so it can be used to alter context
19:45:11 <Axman6> > Just 1 <* Nothing
19:45:12 <lambdabot>  Nothing
19:45:19 <Axman6> > Just 1 <* Just 3
19:45:21 <gcganley> :t (<*)
19:45:21 <lambdabot>  Just 1
19:45:21 <lambdabot> Applicative f => f a -> f b -> f a
19:45:44 <ReinH> Axman6: good point
19:46:09 <ReinH> :t (<*)
19:46:10 <lambdabot> Applicative f => f a -> f b -> f a
19:46:31 <ReinH> Applicative allows you to replace one context with another, but the key is that it doesn't allow you to choose the new context based on the value of a previous computation
19:46:38 <ReinH> whereas with Monad
19:46:40 <ReinH> :t (=<<)
19:46:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:46:52 <ReinH> I can choose the value of `m b' depending on the value of a
19:47:20 <gcganley> :ReinH becuase it uses the result in the next computation no?
19:47:55 <ReinH> > Just 1 >>= (\x -> if x == 1 then Nothing else Just x)
19:47:57 <lambdabot>  Nothing
19:47:59 <ReinH> > Just 2 >>= (\x -> if x == 1 then Nothing else Just x)
19:48:01 <lambdabot>  Just 2
19:48:08 <ReinH> That's an example that you can't do with Applicative
19:49:04 <gcganley> :ReinH this has taught me more about Monads than any other tutorial online
19:49:11 <ReinH> gcganley: notice that the previous example can be replicated with Applicative precisely because we ignore the value
19:49:18 <ReinH> > (\_ -> Nothing) =<< Just 1
19:49:20 <lambdabot>  Nothing
19:49:35 <ReinH> gcganley: :)
19:49:50 <gcganley> > Nothing >> Just 1
19:49:52 <lambdabot>  Nothing
19:49:54 <ReinH> Yep
19:50:46 <gcganley> > Just 1 >>= (\x -> x + 1)
19:50:48 <lambdabot>  No instance for (GHC.Show.Show b0)
19:50:48 <lambdabot>    arising from a use of â€˜M1121563904248704021861.show_M1121563904248704021861â€™
19:50:48 <lambdabot>  The type variable â€˜b0â€™ is ambiguous
19:50:48 <lambdabot>  Note: there are several potential instances:
19:50:48 <lambdabot>    instance [safe] GHC.Show.Show
19:51:16 <gcganley> :t (\x -> x + 1)
19:51:17 <lambdabot> Num a => a -> a
19:51:24 <exio4> > Just 1 >>= return.(+1)
19:51:25 <lambdabot>  Just 2
19:51:54 <gcganley> :t return.(+1)
19:51:55 <lambdabot> (Num b, Monad m) => b -> m b
19:52:10 <gcganley> ive never seen that before...
19:52:13 <ReinH> gcganley: you need to wrap your value back up in a "context", which is what return is for
19:52:25 <ReinH> Just 1 >>= (\x -> return (x + 1))
19:52:29 <gcganley> i got that but i didnt know where to put return
19:52:31 <ReinH> > Just 1 >>= (\x -> return (x + 1))
19:52:31 <gcganley> ok i see no
19:52:32 <lambdabot>  Just 2
19:52:34 <gcganley> s/no/now
19:52:44 <ReinH> return is "give me the default context"
19:52:48 <ReinH> so for Maybe it's equivalent to:
19:52:51 <ReinH> > Just 1 >>= (\x -> Just (x + 1))
19:52:53 <lambdabot>  Just 2
19:53:00 <gcganley> return = Just for Maybe
19:53:02 <gcganley> i belive
19:53:08 <ReinH> exactly
19:53:20 <gcganley> and for list return a = [a]
19:53:24 <ReinH> yep
19:53:26 <gcganley> ok
19:53:54 <gcganley> :t (return (x + 1))
19:53:55 <lambdabot> Monad m => m Expr
19:54:05 <gcganley> :t Expr
19:54:05 <lambdabot> Not in scope: data constructor â€˜Exprâ€™
19:54:12 <exio4> :t \x â†’ return (x+1)
19:54:12 <lambdabot> (Num a, Monad m) => a -> m a
19:54:13 <gcganley> what the hell is Expr
19:54:15 <ReinH> Expr comes from the simple reflect library
19:54:17 <gcganley> oh expression lol
19:54:23 <ReinH> so you can do, e.g.:
19:54:29 <ReinH> > x + 1 :: Expr
19:54:31 <lambdabot>  x + 1
19:54:34 <gcganley> oh
19:54:46 <gcganley> is that because of what lambdabot is built on top of?
19:54:59 <ReinH> it's because LambdaBot includes simple reflect stuff :)
19:55:13 <ReinH> It's kinda nize
19:55:16 <ReinH> nice
19:55:19 <ReinH> > foldr (+) x [y,z] :: Expr
19:55:20 <lambdabot>  y + (z + x)
19:55:56 <dibblego> @type \f -> Data.Foldable.asum . fmap f -- does this function exist?
19:55:56 <lambdabot> (Foldable t, Functor t, Alternative f) => (a1 -> f a) -> t a1 -> f a
19:57:01 <gcganley> > foldl (+) [y,z] :: Expr
19:57:02 <lambdabot>  Couldn't match expected type â€˜Debug.SimpleReflect.Expr.Exprâ€™
19:57:02 <lambdabot>              with actual type â€˜[[Debug.SimpleReflect.Expr.Expr]]
19:57:02 <lambdabot>                                -> [Debug.SimpleReflect.Expr.Expr]â€™
19:57:20 <gcganley> > foldl (+) x [y,z] :: Expr
19:57:21 <lambdabot>  x + y + z
19:58:31 <gcganley> :ReinH do you have a blog or a reddit acount that you use frequently?
19:59:33 <ReinH> gcganley: Uh, I have a few things on reinh.com/notes, but I don't write as much as I should
20:00:33 <gcganley> :ReinH why hakyll?
20:01:05 <ReinH> Because it was easy and pandoc is awesome
20:01:36 <ReinH> I don't know of anything else that lets me insert citations from a BibTex bibliography (http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html)
20:01:45 <gcganley> :ReinH i was thinking of making a yesod website why would i choose hakyll over yesod and vis versa
20:01:57 <ReinH> hakyll is a static site generator
20:02:04 <ReinH> so they are pretty different tools
20:02:11 <gcganley> :ReinH OH
20:02:13 <ReinH> you might compare yesod to snap and scotty
20:02:16 <gcganley> :ReinH missed that
20:02:21 <ReinH> no worries :)
20:03:11 <gcganley> :ReinH its for my senior project and im still having trouble convincing my teacher that haskell is a better option for learning than IIS
20:03:33 <ReinH> oh god
20:03:41 <ReinH> IIS :(
20:04:04 <dibblego> good ol' university education
20:04:07 <gcganley> :ReinH we're a microsoft shop so i was thinking in a pinch i would learn F#
20:04:24 <gcganley> its not university its HS
20:04:34 <dibblego> smashing it early I see
20:04:54 <gcganley> :dibblego I love my school, i started C# freshman year
20:05:11 <nitrix> Hi guys.
20:05:16 <srhb> Hello.
20:05:20 <gcganley> hello
20:05:21 <nitrix> How does someone do separation of concerns with Haskell?
20:05:23 <dibblego> I am a disillusioned former university educator, ignore my laments
20:05:37 <nitrix> Is there other things than modules or is it the primary system?
20:06:11 <srhb> nitrix: Types!
20:06:14 <ReinH> gcganley: F# wouldn't be too bad
20:06:17 <ReinH> dibblego: o/
20:06:25 <gcganley> dibblego: they let me do anything from hack around on a raspberry pi to configure 5 cisco 1941 routers, its awesome
20:06:33 <ReinH> dibblego: nice to see you again :)
20:06:35 <nitrix> I'm a very methodic person that would sort of invent namespaces in C just to keep the code tidy.
20:06:38 <dibblego> hi ReinH
20:07:10 <nitrix> e.g. player_action_trade_success() etc...
20:07:12 <ReinH> gcganley: that's pretty cool!
20:07:32 <ReinH> modules, separate libraries
20:07:44 <ReinH> modules scale out to millions of lines of code so I don't think you have too much to worry about
20:09:46 <nitrix> I know, it's just weird because I'm used to the OOP model where you're defining methods on your objects. For example, recently I was porting C code to Haskell, and I had this Endpoint object thing with a bunch of information. Of course the idiomatic way in C is just a function like endpoint_put(endpoint, value); or something
20:09:47 <ReinH> Well, some of those might be encapsulated in separate libraries
20:10:24 <ReinH> nitrix: It's almost as if you need to use different tools with a different language paradigm ;)
20:10:29 <gcganley> :ReinH Thank you for all your help!
20:10:32 <ReinH> gcganley: np!
20:10:36 <ReinH> gcganley: good luck!
20:10:36 <nitrix> Emulation some kind of OOP by passing a struct around, but since Haskell doesn't have actual OOP (not how I know OOP at least) nor can you really pass mutable data around like that... I'm a little puzzled
20:10:45 <gcganley> :ReinH i have to head to bed, again thank you
20:10:56 <nitrix> er, Emulating.
20:10:58 <ReinH> nitrix: Maybe if you have some examples of things that you are finding it difficult to structure?
20:11:10 <khyperia> nitrix, random point, look into the State monad
20:11:28 <nitrix> I feel like the State monad is a hack no?
20:11:35 <khyperia> a hack?
20:12:06 <khyperia> if you really want to, you can write out the explicit definition of State
20:12:08 <nitrix> Doesn't it defeat a bit the purpose of being able to look at the code and know immediatly that there's no side-effects?
20:12:25 <srhb> nitrix: There are no side effects
20:12:28 <srhb> nitrix: There is no hack.
20:12:37 <nitrix> I get that.
20:13:10 <khyperia> something like "newtype State s a = s -> (s, a)" or similar, I forget the exact definition
20:13:13 <nitrix> srhb: Okay, I'll provide an actual example then.
20:13:18 <srhb> nitrix: Please. :)
20:13:40 <khyperia> so you *could* just do "endpoint_put :: Value -> Endpoint -> Endpoint"
20:14:15 <nitrix> srhb: I'm having a distributed file system where the system keeps a list of endpoints. Those endpoints have a minimal common denominator API, that is a get and set operation to have it stored or fetch it.
20:14:37 <dibblego> nitrix: why would you not want to track the state in the types in that example? Is anything but that a hack?
20:14:38 <khyperia> just the last bit there sounds like a class
20:15:07 <nitrix> In C++, that'd be a Endpoint class, then other classes that inherits from that class that implement two methods get, set.
20:15:25 <srhb> nitrix: data Endpoint = Type1 | Type2 | Type ... ?
20:15:33 <srhb> then set Type1 = ...
20:15:42 <srhb> Or am I misunderstanding?
20:15:58 <nitrix> In C, you'd probably have a Endpoint struct with basic things, and then, multiple other struct types that embeded the endpoint struct as its first element, and add extra content. The resulting object would be passed around to functions as the first argument.
20:16:33 <dibblego> nitrix: we can do get/set nice and neatly with functions, preserving equational reasoning, making the code readable and easy to reason about — how is this a hack?
20:16:42 <nitrix> srhb: right but each value for Endpoint needs their own set / get implementation. Each endpoint dont have the same logic to handle those actions.
20:16:57 <srhb> nitrix: Each _value_?
20:17:13 <srhb> But surely you need to compute this value based on the type of the endpoint?
20:17:18 <khyperia> or "class Endpoint e a where put :: a -> e -> e; get :: e -> (a, e)"
20:17:20 <nshepperd> State isn't really a replacement for C++ style objects
20:17:59 <nitrix> srhb: Yes, because data Endpoint = Type1 | Type2 | Type3 in your example is wrong.
20:18:07 <nitrix> They aren't types, they are value constructors.
20:18:09 <srhb> Ah, okay. Then I did not understand.
20:18:11 <srhb> Yes
20:18:13 <srhb> Okay
20:18:21 <srhb> But then set takes an Endpoint argument
20:18:31 <srhb> And does something or other depending on whether its argument is Type1 or Type2
20:18:35 <edwardk> preflex: xseen acowley
20:18:45 <edwardk> @seen acowley
20:18:45 <lambdabot> aC0wley
20:19:00 <merijn> edwardk: preflex has been dead for months and lambdabot doesn't have @seen :)
20:19:08 <edwardk> one of those things =)
20:19:13 <nitrix> srhb: Okay but then I have a function that means literally nothing `set` in some global namespace.
20:19:16 <merijn> edwardk: It gets auto-corrected to @leet :)
20:19:18 <nitrix> Can't it be attached to my type?
20:19:21 <edwardk> merijn: i don't usually use the command =)
20:19:32 <khyperia> nitrix, import it as qualified?
20:19:39 <srhb> nitrix: You mean you don't like that it's this general? Ie that it has type Endpoint -> ... ?
20:19:44 <nitrix> What about records?
20:19:53 <edwardk> thinking about adding some code for spherical harmonics to linear
20:20:02 <dibblego> nitrix: see lens
20:20:15 <nitrix> dibblego: I don't need a reverse operation. Lenses would be pointless.
20:20:28 <nshepperd> nitrix: what exactly is being 'get' or 'set' here? is it an IO action, or just setting fields of a structure?
20:20:31 <dibblego> a "reverse operation"?
20:21:00 <nitrix> nshepperd: String -> IO ()   and   IO String probably
20:22:55 <nshepperd> okay, so you can do something like 'data Endpoint = Endpoint { get :: IO String; set :: String -> IO () }
20:23:25 <nshepperd> and you put in the correct implementations of 'get' and 'set' when you create the object
20:23:31 <nitrix> Yeah I think that's what I'll do.
20:23:35 <dibblego> :(
20:23:56 <nitrix> nshepperd: But is it idiomatic to provide an implementation like that while creating the object?
20:24:01 <dibblego> No.
20:24:32 <nitrix> You'd think there's a way to just have it bundled, some OOP approach but maybe done better?
20:24:38 <nshepperd> it's the "Handle" approach...
20:25:45 <nshepperd> The other option is "class Endpoint e where { get :: e -> IO String; set :: e -> String -> IO () }"
20:26:17 <nshepperd> and then have various types that are instances of Endpoint
20:26:49 <nitrix> That feels better
20:26:58 <nitrix> Are they forced to implement get and set?
20:28:02 <nshepperd> like, i dunno, "data SocketEndpoint = SocketEndpoint { _socket :: Socket }" with an implementation of get/set that communicates via a socket
20:28:47 <nshepperd> yes, you have to implement both get and set for it to be usable as an instance of the class
20:28:59 <nitrix> And you can say ehmm...
20:29:37 <nitrix> Endpoint a => a   for functions that will expect a endpoint type?
20:29:37 <nshepperd> otherwise you get a type error when you try to pass a SocketEndpoint to a function expecting (Endpoint e) => e
20:29:42 <nshepperd> yes
20:30:12 <nitrix> Okay wait, why the type error?
20:30:20 <nitrix> What does _socket :: Socket solves?
20:30:43 <nshepperd> I mean that you get a type error if you don't implement 'get' and 'set' for your particular endpoint type
20:30:54 <nshepperd> the socket thing was just an example
20:30:59 <nitrix> Great, that's what I want.
20:34:00 * hackagebot http-media 0.3.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.3.0 (TimothyJones)
20:51:15 <CrazyM4n> What was the function that got an int out of a number?
20:51:21 <CrazyM4n> I can use floor or something
20:51:29 <CrazyM4n> But there was another one that I forgto
20:54:01 * hackagebot citation-resolve 0.4.3 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.3 (TakayukiMuranushi)
20:55:40 <CrazyM4n> ah.. itÂ´s
20:55:45 <CrazyM4n> the function is... toInteger
20:55:46 <CrazyM4n> ;;
20:57:14 <eazar001> @hoogle (Num a, Integral b) => a -> b
20:57:16 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
20:57:17 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
20:57:17 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
20:57:26 <eazar001> @type toInteger
20:57:27 <lambdabot> Integral a => a -> Integer
20:59:02 * hackagebot auto-update 0.1.1.4 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.4 (MichaelSnoyman)
21:01:17 <eazar001> @type (\x -> fromIntegral x :: Int) . toInteger
21:01:17 <lambdabot> Integral a => a -> Int
21:04:03 * hackagebot warp 3.0.2.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.2.1 (MichaelSnoyman)
21:09:11 <joelteon> this is happening when I try to build aeson with executable profiling on https://gist.github.com/joelteon/199342e32255d1ecd484
21:27:56 <CrazyM4n> So I have a recursive function
21:28:13 <CrazyM4n> And haskell is telling me that it is incorrect because the edge case is of type Picture
21:28:24 <CrazyM4n> Whereas the whole function, if ran, is actually a [Picture]
21:28:27 <CrazyM4n> Unless it is wrong
21:28:35 <dmj`> CrazyM4n: can you paste your code on lpaste.net?
21:28:47 <CrazyM4n> http://lpaste.net/111942
21:29:07 <CrazyM4n> Probably an obvious error, and IÂ´m fixing all the lint warnings
21:29:29 <CrazyM4n> http://lpaste.net/451911287744495616
21:29:58 <dmj`> what is blank?
21:30:05 <dmj`> color black $ blank
21:30:35 <CrazyM4n> https://hackage.haskell.org/package/gloss-1.8.1.2/docs/Graphics-Gloss-Data-Picture.html
21:30:49 <CrazyM4n> function called color
21:31:04 <CrazyM4n> https://hackage.haskell.org/package/gloss-1.8.1.2/docs/Graphics-Gloss-Data-Picture.html#v:color there you go
21:31:07 <dmj`> that's your problem
21:31:30 <dmj`> color :: Color -> Picture -> Picture
21:31:37 <CrazyM4n> Oh, so I have to remove that $
21:31:39 <dmj`> no
21:31:42 <dmj`> it must be a list
21:31:47 <CrazyM4n> It is
21:31:55 <CrazyM4n> Look at the otherwise part
21:32:06 <dmj`> you have 3 cases
21:32:12 <dmj`> 2 of which return a [Picture]
21:32:15 <CrazyM4n> Yes
21:32:18 <dmj`> the middle returns Picture
21:32:19 <dmj`> intY >= length grid = color black $ blank
21:32:39 <CrazyM4n> Yes, thatÂ´s the edge case
21:32:54 <dmj`> your function must return a list though
21:33:10 <CrazyM4n> So how do I make it return that list which was created?
21:33:13 <dmj`> gridToPicture :: Float -> Float -> Grid -> [Picture]
21:33:15 <CrazyM4n> Yes
21:33:26 <dmj`> [ color black $ blank ] ?
21:33:32 <nitrix> Holy crap, I just understood right now that >>= does composition.
21:33:44 <CrazyM4n> oh. itÂ´s that easy
21:33:44 <CrazyM4n> ok
21:33:45 <jle`> i like to think of >>= as application
21:33:56 <dmj`> >=> is more composition
21:34:03 <jle`> =<< is like a super $
21:34:14 <jle`> super/different
21:34:20 <jle`> <=< is like a super (.)
21:34:39 <jle`> i wonder if we could abstract over application
21:34:50 <CrazyM4n> By doing?
21:35:06 <jle`> sort of like how Control.Category abstracts over function composition
21:35:13 <jle`> so you could use (.) for composing (a -> m b)'s
21:35:25 <jle`> for turning an (a -> m b) and an (a -> m c) into an (a -> m c) using (.)
21:35:35 <jle`> um
21:35:41 <jle`> that second one should be b -> m c
21:35:48 <jle`> so (.) works for both (a -> b)'s and (a -> m b)'s
21:35:57 <CrazyM4n> Like this? http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#v:ap
21:36:02 <CrazyM4n> :S
21:36:09 <jle`> so...i guess...with abstracted application...you could use one operator that would stand in for both ($) and (=<<)
21:36:42 <jle`> just like you can have one operator to stand in for both (.) and (<=<) with Control.Category
21:37:06 <CrazyM4n> IsnÂ´t ap pretty much what you want?
21:37:10 <CrazyM4n> @type ap
21:37:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:37:17 <jle`> no, because (*2) `ap` 5 doesn't return 10
21:37:23 <CrazyM4n> I see
21:37:38 <CrazyM4n> > (*2) `ap` 5
21:37:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
21:37:40 <lambdabot>    arising from a use of â€˜M858019721889937178223813.show_M8580197218899371782...
21:37:40 <lambdabot>  The type variable â€˜b0â€™ is ambiguous
21:37:40 <lambdabot>  Note: there are several potential instances:
21:37:40 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:37:44 <CrazyM4n> Hm
21:38:30 <CrazyM4n> Honestly, this is pretty much impossible
21:38:32 <jle`> > return =<< return 5 :: Maybe Int
21:38:33 <lambdabot>  Just 5
21:38:37 <CrazyM4n> Is anyone here good with Gloss?
21:38:41 <jle`> > id $ 5 :: Int
21:38:42 <lambdabot>  5
21:38:49 <CrazyM4n> > id 5
21:38:51 <lambdabot>  5
21:38:57 <jle`> see, you need to switch between (=<<) and ($) to apply the two different functions to eachother
21:39:14 <jle`> you can't swap them out for eachother
21:39:30 <CrazyM4n> > return $ return 5 :: Maybe Int
21:39:31 <lambdabot>  Couldn't match type â€˜m0 a0â€™ with â€˜GHC.Types.Intâ€™
21:39:31 <lambdabot>  Expected type: Data.Maybe.Maybe GHC.Types.Int
21:39:31 <lambdabot>    Actual type: Data.Maybe.Maybe (m0 a0)
21:39:39 <CrazyM4n> ThatÂ´s really awkward
21:39:57 <CrazyM4n> IÂ´d imagine someone has done that
21:40:24 <CrazyM4n> Ugh, all I want to do is display an [[Int]] on the screen as a grid in Gloss
21:40:26 <CrazyM4n> Is that so hard
21:41:16 <jle`> well, it works with (.) and (<=<) because of Control.Category
21:41:22 <jle`> ?b 19
21:41:22 <lambdabot> Maybe you meant: b52s bf bid botsnack bouvier brain bug v @ ? .
21:41:27 <jle`> oops
21:48:21 <CrazyM4n> Is it bad to use http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:threadDelay ?
21:48:38 <CrazyM4n> Or can I use it for simple things, like a little ASCII art animation
21:48:54 <napping> what are you worried about?
21:49:13 <CrazyM4n> Not much, but a lot of times sleep is iffy in other languages
21:49:46 <CrazyM4n> And thereÂ´s still a lot of stuff I donÂ´t know about haskell, just like how when I started I would have thought unsafePerformIO was a genius function
21:49:49 <davean> sleep is always iffy because the kernel schedules you when it wants to - you aren't a realtime thread
21:50:16 <CrazyM4n> Yea, but I donÂ´t need it to be exact by any means
21:50:16 <davean> but if all you want is an approximate framerate, it'll do that fine.
21:50:22 <CrazyM4n> I just want it to sleep around a second
21:51:00 <CrazyM4n> Lastly, can I call main from main?
21:51:05 <CrazyM4n> Without leaking memory
21:51:18 <CrazyM4n> Or is that not a good ide
21:51:20 <CrazyM4n> idea
21:51:29 <davean> Its fine. main is just an IO action
21:51:37 <CrazyM4n> Okay, thanks
21:51:38 <davean> it isn't special
21:52:03 <napping> and threadDelay isn't a busywait or anything silly like that
21:52:20 <CrazyM4n> napping: ThatÂ´s kind of what I was afraid of
21:52:41 <CrazyM4n> Using the wrong sleep function back when I coded stuff in pygame was such a pain
21:53:09 <napping> well, Haskell has much nicer threads
21:53:19 <CrazyM4n> Never messed with threading
21:53:30 <napping> threadDelay just delays the thread you call it in
21:53:34 <orb__> unsafePerformIO is a genius function.
21:53:36 <napping> and it's handled by the runtime
21:53:37 <CrazyM4n> Can main take an argument? Or am I starting to get into the realm of bad ideas(tm)?
21:53:44 <orb__> CrazyM4n, it should only be used by the geniuses.
21:53:45 <napping> nope, main :: IO ()
21:53:57 <orb__> CrazyM4n, nope, define a new function.
21:54:03 <napping> Check around System.Environment if you want to get at program arguments and stuff
21:54:07 <CrazyM4n> orb__: Only smart people truly know the power of unsafePerformIO
21:54:24 <CrazyM4n> And no, I just wanted to know if I could just plop some code in main instead of making another function
21:54:24 <Axman6> but you can get arguments given at the command line with System.Environment.getArgs
21:54:45 <orb__> unsafePerformIO means "Compiler, trust me, this is gonna be fine."
21:54:49 <davean> I tihnk unsafePerformIO is mostly useful for jokes that leave people hating you.
21:54:55 <orb__> Normally the compiler only does stuff it can prove to be safe.
21:55:10 <jle`> if you can imagine a main with arguments, it would be something like `[String] -> IO ()`
21:55:16 <orb__> unsafePerformIO can be useful, if the end-result is actually pur.
21:55:18 <orb__> pure.
21:55:24 <CrazyM4n> ItÂ´s, uh, useful in ghci? if, you know, youÂ´re using IO things in ghci
21:55:25 <orb__> Eg calling out to some C that actually happens to be pure.
21:55:31 <jle`> luckily, becuase IO is just data, you can easily write a function `([String] -> IO ()) -> IO ()
21:55:43 <davean> CrazyM4n: huh?
21:55:47 <jle`> so "give me a [String] -> IO (), and i'll turn it into a format that `main` can use, IO ()"
21:56:03 <jle`> @hoogle ([String] -> IO ()) -> IO ()
21:56:04 <lambdabot> No results found
21:56:15 <jle`> darn
21:56:17 <davean> jle`: now that does sound like a bad idea
21:56:18 <jle`> that would have been really cool
21:56:20 <jle`> :t getArgs
21:56:21 <lambdabot> Not in scope: â€˜getArgsâ€™
21:56:22 <jle`> er
21:56:24 <jle`> :t withArgs
21:56:25 <lambdabot> Not in scope: â€˜withArgsâ€™
21:56:33 <jle`> withArgs :: ([String] -> IO ()) -> IO ()
21:56:55 <jle`> hm
21:57:05 * davean looks at jle` and wonders how much hes thought of how args and env variables work
21:57:22 <CrazyM4n> davean: like this:
21:57:23 <napping> it's System.Environment.getArgs
21:57:31 <CrazyM4n> > return Â¨hiÂ¨ :: IO (String)
21:57:32 <lambdabot>  <hint>:1:13: parse error on input â€˜::â€™
21:57:34 <CrazyM4n> Err
21:57:37 <CrazyM4n> What?
21:57:42 <jle`> withEnv io = getArgs >>= io
21:57:52 <CrazyM4n> Either way, if for some reason you wanted the IO monad while working in GHCi
21:57:57 <jle`> withEnv :: ([String] -> IO ()) -> IO ()
21:58:05 * Axman6 would call that withArgs
21:58:05 <CrazyM4n> i *guess* unsafePerformIO would beo k
21:58:07 <davean> CrazyM4n: ghci starts in the IO monad ...
21:58:13 <napping> System.Environment.withArgs is actually a function for temporarily replacing the arguments while you call something
21:58:18 <Axman6> withEnv implies to me you're getting environment variables
21:58:25 <CrazyM4n> ItÂ´s too late for me to be haskelling right now, you gotta understand this, haha
21:58:31 <jle`> yeah, i mixed them up v.v
21:58:44 <jle`> but withArgs is already taken
21:58:49 <davean> Prelude> return "See, is IO"::IO String
21:58:50 <geekosaur> CrazyM4n, it looks to me like something mutated your quotes?
21:58:51 <davean> "See, is IO"
21:58:59 <geekosaur> they look shorter than normal double quotes
21:59:16 <jle`> withTheArgs :: ([String] -> IO ()) -> IO (); withTheArgs io = getArgs >>= io
21:59:19 <geekosaur> (but they don;t look like smart quotes)
21:59:33 <jle`> so if you really wanted to make your program an [String] -> IO (), where [String] is your command line arguments
21:59:34 <CrazyM4n> They are some kind of accent Â¨that hexchat uses for some reason
21:59:36 <jle`> you could write one like that
21:59:40 <Axman6> they're "wrong quotes"
21:59:44 <CrazyM4n> If I put a space after them they turn normal "
21:59:45 <jle`> and then use withTheArgs to turn it into a form that you can pass into main
21:59:59 <geekosaur> ah, you have a dead keys layout
22:00:00 <jle`> main = withTheArgs $ \args -> ....
22:00:08 <CrazyM4n> Hm?
22:00:15 <geekosaur> a way to type accents
22:00:26 <geekosaur> "a    probably produces Ã¤
22:00:28 <CrazyM4n> Yes, I have it set on US - International
22:00:40 <CrazyM4n> Yea, but that shouldnÂ´t affect Hexchat
22:00:52 <CrazyM4n> And putting a space after the mangled apostrophe does nothing
22:00:56 <CrazyM4n> So I donÂ´t know
22:01:12 <davean> CrazyM4n: Anyway, I think maybe you should head to bed :)
22:01:24 <CrazyM4n> Psh, I have games of life to finish :)
22:01:44 <geekosaur> Mac? (1) "follow system keyboard layout" (Preferences > Input) means OS X keyboard affects X11 apps; (2) turn off smart quotes in System Preferences
22:02:01 <CrazyM4n> Windows 7, turned on international layout on purpose
22:02:10 <geekosaur> (System Preferences > Keyboard > Text)
22:02:21 <CrazyM4n> Hexchat did this before hand, IÂ´ll try anyway though
22:02:39 <geekosaur> ah. couldn't tell you there. but it will affect hexchat unless you're using an X11 version and a Windows X11 server
22:02:52 <CrazyM4n> Nope, itÂ´s still broken Â¨see
22:03:14 <geekosaur> it may have an option somewhere to do dead keys, then. mine doesn't but it's X11 based and relies on the X11 keyboard mapping
22:03:49 <CrazyM4n> I see, I have it set to automatically replace Â´with ' and Â¨with "
22:03:59 <CrazyM4n> But it doesnÂ´t take effect unless I press space after it
22:04:07 <CrazyM4n> This is really a mundane problem
22:04:14 * hackagebot warp 3.0.2.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.2.2 (MichaelSnoyman)
22:08:01 <CrazyM4n> > (map . map) show [[1,2,3],[4,5,6]]
22:08:03 <lambdabot>  [["1","2","3"],["4","5","6"]]
22:08:14 <CrazyM4n> > (map . map) digitToChar [[1,2,3],[4,5,6]]
22:08:15 <lambdabot>  Not in scope: â€˜digitToCharâ€™
22:09:10 <CrazyM4n> Uh, if I wanted the only char out of a string
22:09:19 <CrazyM4n> Could I just do head Â¨sÂ¨
22:09:20 <CrazyM4n> wait
22:09:33 <CrazyM4n> > head "s"
22:09:35 <lambdabot>  's'
22:10:27 <CrazyM4n> > (map . map) head ((map . map) show [[1,2,3],[4,5,6]])
22:10:28 <lambdabot>  ["123","456"]
22:10:36 <CrazyM4n> There we go
22:10:52 <CrazyM4n> Is there an easier way to coerce a string from an array of strings?
22:10:55 <CrazyM4n> concat
22:10:56 <CrazyM4n> never mind
22:11:37 <CrazyM4n> > concat ["1", "2", "3"]
22:11:39 <lambdabot>  "123"
22:12:55 <platinuum> are two and statements valid? for example:  checker a b c d (a==b) && (b==c) && (c==d)
22:15:30 <CrazyM4n> platinuum: Could you give another example for what youÂ´re trying to do?
22:15:51 <platinuum> not really trying to do anything just wondering if that would work
22:16:04 <CrazyM4n> (a==b) && (b==c) && (c==d) would work
22:16:06 <platinuum> checker a b c = (a==b) && (b==c) is valid
22:16:09 <platinuum> so im just wondering
22:16:11 <platinuum> cool thanks CrazyM4n
22:16:13 <CrazyM4n> Yea
22:16:20 <CrazyM4n> Watch this
22:16:52 <CrazyM4n> > let checker a b c d= (a==b)&&(b==c)&&(c==d) in checker 1 1 1 1
22:16:54 <lambdabot>  True
22:17:04 <platinuum> ahhh niceeee
22:17:04 <CrazyM4n> > let checker a b c d = (a==b)&&(b==c)&&(c==d) in checker 1 1 1 2
22:17:06 <lambdabot>  False
22:17:07 <platinuum> perfect
22:17:13 <platinuum> that bot rocks
22:17:23 <CrazyM4n> > let checker a b c d = and [a==b,b==c,c==d] in checker 1 1 1 2
22:17:25 <lambdabot>  False
22:17:25 <platinuum> ghci takes me a good 4 seconds to load, cant be waiting!
22:17:29 <CrazyM4n> > let checker a b c d = and [a==b,b==c,c==d] in checker 1 1 1 1
22:17:31 <lambdabot>  True
22:17:41 <CrazyM4n> That would be a better way to write it in my opinion
22:17:46 <platinuum> agreed
22:18:06 <platinuum> let checker a b c d = and ( a==b, b==c, c==d) in checker 1 1 1 1
22:18:15 <CrazyM4n> Remember to put a >
22:18:21 <platinuum> > let checker a b c d = and ( a==b, b==c, c==d) in checker 1 1 1 1
22:18:22 <CrazyM4n> But that wouldnÂ´t work, and this is why
22:18:23 <lambdabot>  Couldn't match expected type â€˜[GHC.Types.Bool]â€™
22:18:23 <lambdabot>              with actual type â€˜(GHC.Types.Bool, GHC.Types.Bool, GHC.Types.Bool)â€™
22:18:26 <CrazyM4n> @type and
22:18:27 <lambdabot> [Bool] -> Bool
22:18:39 <CrazyM4n> and takes an array of arguments, not a tuple
22:18:45 <platinuum> ah got it
22:19:10 <CrazyM4n> (a==b, b==c, c==d) is (Bool, Bool, Bool) and not [Bool]
22:19:37 <platinuum> > array = [1, 2, 3, 4]
22:19:38 <lambdabot>  <hint>:1:7: parse error on input â€˜=â€™
22:19:50 <platinuum> is that a valid way to declare the variable array
22:19:55 <CrazyM4n> In a program, yes
22:20:02 <CrazyM4n> In GHCi, it would have to be
22:20:05 <platinuum> k then just call array
22:20:06 <CrazyM4n> > let array = [1,2,3,4]
22:20:07 <lambdabot>  not an expression: â€˜let array = [1,2,3,4]â€™
22:20:18 <CrazyM4n> > let array = [1,2,3,4] in map (+) array
22:20:19 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
22:20:22 <CrazyM4n> err
22:20:25 <CrazyM4n> you get the point
22:20:26 <CrazyM4n> lolk
22:20:31 <platinuum> lol thanks
22:20:32 <CrazyM4n> > let array = [1,2,3,4] in foldr1 (+) array
22:20:33 <lambdabot>  10
22:21:08 <CrazyM4n> Like I said though, Â¨array = [1,2,3,4]Â¨ is ok in a normal file
22:21:16 <CrazyM4n> But once youÂ´ve set it to that, you canÂ´t change it
22:21:24 <CrazyM4n> Remember that everything in Haskell is immutable
22:24:37 <CrazyM4n> Woo, my game of life works! http://prntscr.com/4sa9ml
22:24:41 <CrazyM4n> https://gist.github.com/CrazyM4n/65e247be4b093fb15f78
22:25:01 <platinuum> > let max x y = if x>=y then x else y in checker 1 2
22:25:02 <lambdabot>  Not in scope: â€˜checkerâ€™
22:25:15 <platinuum> > let max x y = if x>=y then x else y in max 1 2
22:25:16 <lambdabot>  2
22:25:35 <platinuum> woah CrazyM4n what is that?
22:25:37 <platinuum> game of life?
22:25:42 <platinuum> implemented with haskell?
22:25:46 <CrazyM4n> Yea :D
22:26:04 <CrazyM4n> Based on this video https://www.youtube.com/watch?v=a9xAKttWgP4
22:26:33 <CrazyM4n> (Actually, itÂ´s like a transliteration of that video, but I havenÂ´t watched it in like 5 months, so it has enough originality :P)
22:28:00 <CrazyM4n> platinuum: Are you just learning haskell?
22:28:07 <platinuum> CrazyM4n: yep
22:28:35 <slack1256> CrazyM4n: every Haskeller has a sweet spot for the game of life :-)
22:28:52 <slack1256> err and factorial functions
22:29:01 <merijn> You mean fibonacci
22:29:03 <CrazyM4n> slack1256: mmm, gotta love those factorials
22:29:16 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
22:29:17 <lambdabot>  not an expression: â€˜let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)â€™
22:29:17 <merijn> eh
22:29:21 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:29:21 <slack1256> yep factorials and fibonacci
22:29:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:29:36 <CrazyM4n> > let f n = foldr1 (*) [1..n] in f 10
22:29:36 <slack1256> that is why call the best language to write factorial in!
22:29:38 <lambdabot>  3628800
22:29:41 <CrazyM4n> Mmmmmm
22:29:42 <slack1256> that should be our motto
22:29:47 <merijn> CrazyM4n: Array seems like an easier interface for this than nested lists
22:29:59 <Axman6> factorial is boring to write in haskell though
22:30:04 <Axman6> fibonacci isn't
22:30:15 <CrazyM4n> platinuum: learning haskell was really hard... and really, thereÂ´s not really a point where it clicks
22:30:24 <slack1256> oh yeah?
22:30:27 <CrazyM4n> With some of the subtopics, like monads, they just kinda clicked
22:30:29 <CrazyM4n> Eventually
22:30:46 <platinuum> its a little bit like scheme but not really
22:30:50 <CrazyM4n> merijn: I just wanted to write it as readable as possible, and that would mean no vectors or arrays
22:30:53 <platinuum> well see where i get
22:31:06 <joehillen> platinuum: it's not like anything. That's an important thing to know.
22:31:06 <CrazyM4n> platinuum: If you already know functional programming the haskell syntax is easy
22:31:24 <slack1256> > take 6 $ scanl (*) 1 [1..]
22:31:25 <lambdabot>  [1,1,2,6,24,120]
22:31:44 <slack1256> am I now interesting?
22:31:55 <CrazyM4n> slack1256: I still donÂ´t understand scans... I should get on that
22:32:04 <slack1256> factorial 4 life!
22:32:05 <joehillen> platinuum: like any difficult concept, it's important to bang your end against it for a while. then walk away and let it ferment and then comeback and things will be more please. that's how learning works.
22:32:28 <Axman6> > scanl f a [x, y, z] :: [Expr]
22:32:29 <lambdabot>  [a,f a x,f (f a x) y,f (f (f a x) y) z]
22:32:39 <slack1256> CrazyM4n: think of it as a foldl which shows us each intermediate state
22:32:41 <Axman6> > scanl (+) a [x, y, z] :: [Expr]
22:32:43 <lambdabot>  [a,a + x,a + x + y,a + x + y + z]
22:32:56 <CrazyM4n> Uh
22:32:58 <Axman6> > scanr (+) a [x, y, z] :: [Expr]
22:32:59 <lambdabot>  [x + (y + (z + a)),y + (z + a),z + a,a]
22:33:04 <CrazyM4n> I guess
22:33:20 <CrazyM4n> Ohhh, I see
22:33:36 <CrazyM4n> So it just goes folding more and more of the array, starting from the a value
22:33:42 <CrazyM4n> Until itÂ´s folded the whole array
22:33:48 <CrazyM4n> And it shows you those results
22:33:57 <CrazyM4n> CanÂ´t really think of a use for that though
22:34:21 <slack1256> what about compound interest on the range of 10 months?
22:34:22 <joehillen> Axman6: how do you do that ':: [Expr]' outside of lambdabot
22:34:34 <slack1256> you can see how much you have each month with a scanl
22:34:35 <platinuum> joehillen: yeah that is true joehillen we will see where i am at in december ;)
22:34:36 <Axman6> i think it's the simple-reflect package
22:35:01 <joehillen> platinuum: it took me about 3 months for things to fit together
22:35:48 <CrazyM4n> It took most of a sad highschool summer for it to click for me
22:35:59 <slack1256> what other distribution has updated packages that isn't arch-linux?
22:36:11 <slack1256> I mean 7.8.3
22:36:22 <joehillen> slack1256: NixOS
22:36:33 <Axman6> all of them if you download the latest haskell platform from haskell.org >_>
22:36:44 <CrazyM4n> Tried learning it at the start, gave up when LYAH threw too much at me, and picked it up again at the end of summer
22:37:05 <CrazyM4n> The wikibook is really nice and IMHO the best way to learn Haskell
22:37:05 <slack1256> joehillen: oh right
22:37:43 <slack1256> yes the wikibook has a some really good parts, I like the zipper chapter
22:37:53 <slack1256> the whole story is nonsensical and sensical at the same time.
22:38:57 <orb__> What's nonsensical?
22:40:29 <CrazyM4n> orb__: http://en.m.wikibooks.org/wiki/Haskell/Zippers
22:40:45 <CrazyM4n> Sorry for mobile link, noticed when it was too late
22:42:24 <c74d> Does the standard library include something equivalent to `flip (.)`?
22:42:46 <CrazyM4n> Why not use flip (.)?
22:43:25 <CrazyM4n> @type flip (.)
22:43:26 <lambdabot> (a -> b) -> (b -> c) -> a -> c
22:44:03 <shachaf> c74d: Control.Category has (>>>)
22:44:18 <c74d> If there isnâ€™t such a thing in the standard library, then I expect that (.) and (.) alone is â€œthe right wayâ€, and defining my own `>|` or whatever would be bad practice.
22:44:26 <jle`> (>>>)
22:44:26 <CrazyM4n> @hoogle (a -> b) -> (b -> c) -> a -> c
22:44:27 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:44:27 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
22:44:27 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
22:44:31 <c74d> shachaf: Oh? Iâ€™ll look that up.
22:45:03 <jle`> there's (>>>), but writing code that goes from left to right is usually only considered idiomatic in specific contexts
22:45:11 <jle`> typically, normal function application order is preferred
22:45:22 <CrazyM4n> c74d: There's no reason why defining your own convienence function would be bad, unless it was in production code or something
22:45:33 <jle`> it might encourage bad habits :O
22:45:42 <jle`> might as well get used to the idioms and reading them
22:46:00 <jle`> there's also a reason why some of the idioms are the way they are
22:46:03 <CrazyM4n> . seems a bit intuitive to me
22:46:13 <jle`> as in, people have tried out other ways and found them "harmful" (loosely speaking) in the long run
22:46:25 <CrazyM4n> Because f . g looks similar to f(g())
22:46:59 <jle`> yeah, i don't know any language that composes function application backwards
22:47:12 <jle`> even in java, you do foo(bar(baz))
22:47:20 <CrazyM4n> J
22:47:24 <jle`> aw
22:47:26 <c74d> CrazyM4n: I would try to write everything to be â€œproduction gradeâ€.
22:47:32 <jle`> maybe some functional languages
22:47:46 <c74d> â€œ<jle`> might as well get used to the idioms and reading themâ€ â€” what I was thinking.
22:48:04 <zereraz> hello, I have a few doubts with functors, 1st in the instance of Maybe we must put concrete type , but when writing instances for functors we don't put concrete types
22:48:16 <jle`> that being said, (&) is coming into base for 7.10
22:48:17 <shachaf> Nothing paritcularly wrong with wanting composition that goes the other way.
22:48:21 <CrazyM4n> I meant as in if you're like on a team of people who would be confused by what you're doing, but jle` is right
22:48:38 <CrazyM4n> jle`: what's (&)?
22:48:41 <shachaf> Some category folks call that operation (;) (but that syntax is taken in Haskell).
22:48:41 <jle`> flip ($)
22:48:44 <zereraz> instance Eq (Maybe m) where
22:48:44 <zereraz>     Just x == Just y = x == y
22:48:44 <zereraz>     Nothing == Nothing = True
22:48:46 <zereraz>     _ == _ = False
22:48:52 <zereraz> here we must put 'm'
22:49:04 <c74d> I do find forward (cf. shell pipes) rather than backward composition more intuitive, but Iâ€™ll try to get used to (.).
22:49:05 <jle`> zereraz: what is the type of (==) ?
22:49:11 <jle`> what is the type of fmap?
22:49:31 <dmj`> jle`:++
22:49:37 <Axman6> zereraz: you also need instance Eq a => Eq (Maybe a)
22:49:40 <zereraz> jle`: (==) :: Eq a => a -> a -> Bool
22:49:55 <CrazyM4n> c74d: (f . g) x is the same as f(g(x))
22:49:55 <zereraz> jle`: fmap :: Functor f => (a -> b) -> f a -> f b
22:49:58 <jle`> okay...now, what would make sense there for `a`
22:50:02 <jle`> (Maybe a), or Maybe?
22:50:11 <CrazyM4n> They go in the same order, and it looks similar
22:50:12 <jle`> (==) :: Maybe -> Maybe -> Bool ...?
22:50:16 <jle`> ...that doesn't really make any sense
22:50:16 <CrazyM4n> That's how I remember
22:50:24 <jle`> (==) :: Maybe a -> Maybe a -> Bool ..?
22:50:29 <jle`> that makes a little bit more sense
22:50:31 <shachaf> Wait, (&) is going to be in base?
22:50:37 <shachaf> Since when?
22:50:37 <jle`> shachaf: in Data.Function
22:50:40 <CrazyM4n> That's what he said
22:50:48 <jle`> it's somewhat a recent development...heard it from edwardk on this channel
22:51:03 <Axman6> shachaf: got to take the burden off lens somehow right? =)
22:51:04 <jle`> apparently there was some back and forth and in the end there wasn't enough resistance
22:51:05 <CrazyM4n> Is he a Haskell maintainer?
22:51:06 <zereraz> jle`: ok?
22:51:16 <jle`> zereraz: so, is Maybe an Eq, or Maybe a?
22:51:18 <shachaf> What!
22:51:23 <shachaf> What a disaster. When did this happen?
22:51:28 <jle`> about a month or two back
22:51:31 <jle`> that was more or less my reaction
22:51:37 <c74d> CrazyM4n: oh, I remember which â€œdirectionâ€ the data â€œflowsâ€ fine; I just find thinking of it in the other â€œdirectionâ€ more natural.
22:51:46 <CrazyM4n> I understand
22:51:58 <Axman6> I'm sure other libraries also use (&) for something else
22:52:01 <CrazyM4n> I used to feel like that
22:52:04 <jle`> c74d: actually, in haskell, often when you write (f . g . h) x, the "control flow" goes from f, to g, then h
22:52:07 <jle`> because of laziness
22:52:14 <zereraz> jle`: Maybe a
22:52:15 <Axman6> pretty sure it's used in some of thw markup libraries for parameters to tags
22:52:17 <CrazyM4n> But after using it more and more it just felt better and better
22:52:21 <jle`> f determines the evaluation of the entire chain
22:52:22 <c74d> hm
22:52:28 <jle`> so putting f first makes a lot of sense when you want to reason about laziness
22:52:29 <shachaf> Ugh.
22:52:33 <CrazyM4n> It's late and I'm getting philosophical with Haskell
22:52:36 <CrazyM4n> Good night
22:52:48 <jle`> with (x & h >>> g >>> f)...if you want to understand how it evaluates, you have to start with f
22:53:01 <jle`> so in the context of laziness, having f . g . h $ x be preferred actaully greatly aids in reasoning
22:53:38 <c74d> that adds another layer of sense
22:53:51 <zereraz> instance Functor [] where
22:53:51 <zereraz>     fmap = map
22:53:59 <jle`> for example, (take 3 . filter even . map 4) [1..]
22:54:00 <zereraz> here we don't put concrete type [a]
22:54:06 <jle`> zereraz: remember the type for fmap
22:54:08 <jle`> :t fmap
22:54:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:54:13 <jle`> what goes in the "f" to make it make sense?
22:54:16 <jle`> does "Maybe a" make sense there?
22:54:21 <jle`> (a -> b) -> Maybe a a -> Maybe a b
22:54:23 <jle`> ...not really.
22:54:24 <c74d> (specifically not saying â€œthat makes senseâ€ because `f . g` already made sense from being the same order as `f (g x)`)
22:54:26 <jle`> does Maybe make sense there?
22:54:30 <Axman6> zereraz: Functors need to have kind * -> *, like Maybe, or List, or Either e
22:54:32 <jle`> (a -> b) -> Maybe a -> Maybe b
22:54:40 <jle`> yeah....Maybe is the only reasonable thing that can be a Functor f
22:54:54 <Axman6> (where we write List as '[a]' that's just sugar for '[] a')
22:54:56 <jle`> it's the only form that would "fit" into the hole that f fills
22:55:13 <zereraz> jle`: no
22:55:50 <zereraz> jle`: so we are not putting a there on purpose
22:55:58 <jle`> yeah
22:56:14 <jle`> c74d: in (take 3 . filter even . map 4)...everything "starts" with take 3
22:56:15 <Axman6> zereraz: do you understand that Maybe is a type _constructor_?
22:56:20 <zereraz> Axman6: yes
22:56:22 <jle`> take 3 says "i need something to take" from "filter even"
22:56:29 <Axman6> so Maybe needs some other type to form a proper type
22:56:31 <jle`> "filter even" says "i need something to filter" from "map (*2)"
22:56:40 <jle`> "map (*2)" says "i need something to map" from [1..]
22:56:42 <jle`> and [1..] says ok
22:56:45 <jle`> here's 1
22:56:49 <Axman6> well things which are Functors can only be type constructors
22:57:31 <Axman6> so [] is a type which can be a functor, because it has kind * -> *; it needs another tyoe to form an actual type
22:57:40 <Axman6> [a] has that hole filled
22:57:49 <Axman6> look aty the type of fmap again:
22:57:51 <Axman6> @type fmap
22:57:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:58:11 <zereraz> I think I finally understand here
22:58:12 <Axman6> so we can replace f with Maybe and get (a->b) -> Maybe a -> Maybe b
22:58:45 <Axman6> we can replace f with [] and get (a->b) -> [] a -> [] b
22:59:05 <Axman6> we can replace f with (Either c) and get (a->b) -> Either ca -> Either c b
22:59:10 <Axman6> uh, with a space in there
22:59:48 <zereraz> can f be functions?
22:59:55 <Axman6> yes!
23:00:03 <jle`> (a ->) :O
23:00:03 <Axman6> so (e ->) is also a functor
23:00:09 <zereraz> so either type constructors or functions
23:00:10 <Axman6> or more often written as ((->) e)
23:00:27 <Axman6> (->) is a type constructor too!
23:00:30 <cebewee> zereraz: (e ->) is a type constructor
23:00:33 <Axman6> :kind (->)
23:00:40 <Axman6> @kind (->)
23:00:42 <lambdabot> * -> * -> *
23:00:42 <jle`> zereraz: anything that is waiting for a final type to complete itself
23:00:52 <Axman6> @kind ((->) Int)
23:00:53 <lambdabot> * -> *
23:01:10 <zereraz> I don't understand the (e->)
23:01:33 <zereraz> where did e come from ?
23:01:40 <Axman6> we can replace f with (e ->) and get (a->b) -> (e -> a) -> (e -> b)
23:01:43 <jle`> e means whatever
23:01:50 <zereraz> oh
23:01:57 <jle`> so (Int ->) is a Functor
23:01:57 <Axman6> it's just like a
23:01:59 <Axman6> or b
23:02:00 <jle`> (Bool ->) is a Functor
23:02:06 <jle`> ([a] ->) is a Functor for any a
23:02:27 <VictorVR> Could you help me with a good place to learn function programming?
23:02:44 <zereraz> Int -> is a functor where -> is the type constructor
23:03:10 <jle`> ((->) Int) or (Int ->) is the type constructor
23:03:14 <slack1256> VictorVR: function programing? could that be functional programming?
23:03:23 <jle`> ((->) Int) applied to Bool is (Int -> Bool)
23:03:33 <jle`> (Int ->) Bool  ===> (Int -> Bool)
23:03:43 <VictorVR> [slack1256]: yes, sorry Functional programming
23:03:47 <jle`> just like (2+) 3 is (2 + 3)
23:03:50 <jle`> > (2 +) 3
23:03:50 <Axman6> and ((->) Int Bool === Int -> Bool
23:03:51 <lambdabot>  5
23:03:58 <jle`> > (+) 2 3
23:03:59 <lambdabot>  5
23:04:14 <slack1256> VictorVR: No need to apologise :-). I would recommend you start thinkering with haskell and learn along the way
23:04:28 <Axman6> @where lyah
23:04:28 <lambdabot> http://www.learnyouahaskell.com/
23:04:32 <Axman6> VictorVR: ^^^^^^^^
23:04:33 <slack1256> VictorVR: Reading Learn you a haskell will teach you right
23:04:44 <VictorVR> slack1256 thankou
23:04:51 <VictorVR> lambdabot thakou
23:04:55 <VictorVR> lambdabot thankyou
23:05:02 <zereraz> so all the type signatures , Int->Bool, were f a ?
23:05:46 <jle`> (Int ->) is your Functor f
23:05:48 <jle`> so
23:05:50 <jle`> :t fmap
23:05:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:05:58 <Axman6> VictorVR: lambdabot is a bot, but she appreciates your thanks nonetheless
23:06:01 <Axman6> @botsnack
23:06:01 <lambdabot> :)
23:06:07 <jle`> (a -> b) -> (Int -> a) -> (Int -> b)
23:06:22 <VictorVR> [Axman6]: kkkkkkk. I know.
23:06:35 <marshal> wanna DoS my university website,any startup documentation?
23:06:51 <Axman6> no
23:07:02 <Axman6> how does an 11 year old make it into university?
23:07:23 <zereraz> ok my main doubts are clear
23:07:31 <zereraz> thanks jle` and Axman6
23:07:31 <slack1256> with a lot a luck and money obviously
23:07:42 <zereraz> and cebewee
23:13:16 <marshal> anyone alive here??
23:13:31 <Axman6> yes, and no, we're not going to help you
23:14:24 <Cale> Axman6: what?
23:14:33 <Cale> oh
23:17:46 <zereraz> hello, in fmap show [1..5] , functor is [] or show?
23:18:07 <zereraz> or both
23:18:56 <jle`> :t fmap
23:18:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:19:06 <jle`> :t show
23:19:07 <lambdabot> Show a => a -> String
23:19:08 <jle`> :t fmap show
23:19:09 <lambdabot> (Show a, Functor f) => f a -> f String
23:19:13 <jle`> think about it :)
23:19:26 <zereraz> got it
23:19:31 <zereraz> :)
23:20:30 <Axman6> zereraz: so you see the pattern? fmap can work on a whole bunch of things, like lists, Maybe, functions, Trees, IO and more
23:20:58 <zereraz> Axman6: pattern being abstraction
23:21:08 <zereraz> Axman6: like we say Tree
23:21:43 <Axman6> there are only a few things which are type constructors which cannot be functors. one example would be something where the last type is an argument to a function, like type BackwardsFun b a = a -> b
23:22:20 <Axman6> quick, someone tell me is that's because a ia covariant or contravariant!
23:22:27 <Axman6> me if*
23:22:49 <merijn> contravariant
23:22:54 <merijn> iirc
23:23:59 <dtr> more importantly.. should i make bacon shells&cheese happen or not
23:25:41 <jle`> there are a lot of type constructors that can't be Functors
23:28:40 <Axman6> jle`: yes, but not many you meet while learning haskell initially =)
23:30:37 <jle`> heh.  probably right.  but it felt weird to hear.  a Functor is something with pretty strict laws that constrain what it means to be a Functor by a lot.  i feel like Functors if they exist are a happy coincidence or constructed thing more than just functorish by default
23:50:05 * hackagebot basic-sop 0.1.0.3 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.3 (AndresLoeh)
23:55:05 * hackagebot json-sop 0.1.0.3 - Generics JSON (de)serialization using generics-sop  http://hackage.haskell.org/package/json-sop-0.1.0.3 (AndresLoeh)
23:59:36 <platinuum> > zip [1, 2] [a, b]
23:59:38 <lambdabot>  [(1,a),(2,b)]
23:59:53 <platinuum> > zip [1,2,3,4] [a,b]
23:59:54 <lambdabot>  [(1,a),(2,b)]
