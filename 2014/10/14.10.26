00:27:01 <benzrf> sunu: ?
00:27:19 <benzrf> er, sushith
00:32:54 <jle`> alas, sushith has left a long time ago
00:41:40 <benzrf> sleep nao
00:41:41 <benzrf> bye
00:53:11 <ferbv> I've just installed the latest Haskell Platform (2014.2) on Windows 8.1, 32-bit, and "cabal update" is crashing with a "cabal.exe has stopped working" dialog. Any ideas on what I should try?
01:06:09 --- mode: ChanServ set +o mauke
01:06:09 --- mode: mauke set +b $a:Core3
01:08:09 --- mode: mauke set -o mauke
02:06:15 <joancreus> hi! i'm using iterate to integrate something using runge kutta, by using "iters = iterate rk4 stageState". i then use iters !! 100000 to get the 100000th element, which should not evaluate all the previous 99999 elements due to lazy evaluation (?). still, i'm getting stack space overflow
02:06:26 <joancreus> i tried to fix it by using foldl but didn't succeed
02:06:30 <joancreus> thanks in advance!
02:07:25 <joancreus> hmm maybe i should be more explicit. rk4 is a function that takes a "state" at time t and returns the "state" at time t+dt. thus calling rk4 (rk4 (rk4 state)) would give you the third step in the iteration
02:08:40 <joancreus> ideas how to handle really long calls to iterate? thanks!
02:11:53 <ClaudiusMaximus> joancreus: iterate combined with (!!) is too lazy, it saves up all the f(f(f..)) until the end, when it's sometimes more space/time efficient to evaluate them as you go along
02:12:51 <joancreus> ok thanks!
02:13:05 <joancreus> i found this solution which appears to work, a stricter iterate https://stackoverflow.com/questions/8909997/haskell-repeat-a-function-a-large-number-of-times-without-stackoverflow
02:13:22 <joancreus> i think i more or less understand it :)
02:13:24 <joancreus> thanks!
02:13:55 <ClaudiusMaximus> yep that's the way to go
02:15:06 <joancreus> thank you ClaudiusMaximus !
02:26:29 * hackagebot http-client 0.4.2.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.2.2 (MichaelSnoyman)
02:31:12 <Arahael> So, I have a row with many columns.
02:31:22 <Arahael> Lets call them: foo bar baz
02:32:14 <Arahael> So, I figure that I should create a record, and map them, but this seems tedious: convert [foo,bar,baz] = MyData foo bar baz
02:32:18 <Arahael> Is there a better way?
02:37:32 <xificurC> I'd like to create a web page with something similar to Stackoverflow's input - you write markdown in one inputbox and there's another box that shows a live html preview of your input. What libraries should I look into?
02:38:08 <Arahael> xificurC: In Haskell or Javascript?
02:38:31 <Arahael> xificurC: Because the only way to do that in Haskell (quickly) is to do it on the javascript side, so that means ghcjs.
02:38:31 <xificurC> Arahael: haskell
02:39:06 <Arahael> xificurC: Which means you have no real library to leverage, except what haskell gives you.
02:39:20 <Arahael> xificurC: (I'm too new to Haskell itself to give a better suggestion though)
02:39:56 <Arahael> There are probably many javascript libraries for this though.
02:40:53 <sivteck> xificurC, https://github.com/ocharles/pandoc-live (it might help?)
02:41:31 * hackagebot marmalade-upload 0.10 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.10 (lunaryorn)
02:44:10 <Arahael> xificurC: Personally I suggest finding a good javascript implementation of this, and just leveraging that.
02:45:10 <xificurC> this was supposed to be an educational project, but I see there's more js involved than there is haskell
02:46:19 <xificurC> like sivteck's link (thanks btw) has 90% js
02:46:50 <Arahael> xificurC: If you relax your requirements, such as allowing a 'click to preview', then you could do this in haskell quite elegantly with a markdown parser. (pandoc's a good one but I've not used it)
02:47:17 <Arahael> xificurC: Or you could compile the haskell code to javascript. (Which is easier than it sounds)
02:55:56 <xificurC> Arahael: well the example project in ghcjs doesn't look simple *at all* - https://github.com/ghcjs/ghcjs-examples/blob/master/ghcjs-hello/src/Main.hs
03:06:34 * hackagebot aivika 2.0 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-2.0 (DavidSorokin)
03:09:47 <ocharles> xificurC: it's 90% *other peoples* js
03:09:50 <ocharles> I wrote about 20 lines :)
03:11:25 <xificurC> ocharles: i see
03:11:53 <xificurC> ocharles: I just hate that the web is tied to js
03:12:09 <ocharles> not much pointing hating it, that's how it is
03:12:28 <xificurC> I know :(
03:14:42 <kqr> is there a sandbox-aware runhaskell?
03:15:05 <silver> cabal exec ?
03:16:36 <kqr> i'm not sure that does what I want it to do
03:16:56 <kqr> I have a file called t.hs and if I run "cabal exec t.hs" it doesn't appear to run
03:17:11 <sivteck> cabal exec sh -> runhaskell bleh.hs
03:17:26 <dcoutts> kqr: it runs a shell command
03:18:03 <silver> cabal exec runhaskell -- <params>
03:18:16 <kqr> nice!
03:18:18 <kqr> thank you
03:19:42 <kqr> does quasiquote need a language pragma or is it part of templatehaskell
03:19:44 <kqr> ?
03:20:38 <kqr> ah
03:20:40 <kqr> pragma it is
03:31:37 * hackagebot aivika-transformers 2.0 - Transformers for the Aivika simulation library  http://hackage.haskell.org/package/aivika-transformers-2.0 (DavidSorokin)
05:01:37 <rcharles> @src concat
05:01:37 <lambdabot> concat = foldr (++) []
05:40:30 <profil> @src fmap
05:40:30 <lambdabot> Source not found. Wrong!  You cheating scum!
05:40:39 <profil> :(
05:43:34 <sivteck> hehe
05:44:02 <exio4> @src [] fmap
05:44:02 <lambdabot> fmap = map
05:44:12 <exio4> @src Maybe fmap
05:44:12 <lambdabot> fmap _ Nothing  = Nothing
05:44:12 <lambdabot> fmap f (Just a) = Just (f a)
05:45:01 <sivteck> @src (->) arr
05:45:01 <lambdabot> arr f = f
05:47:55 <Gurkenglas> http://www.reddit.com/r/haskell/comments/2k8cr2/building_a_rest_client/clj3oub <- did the cabal install thing, it still says it didnt find it. ("Did the install work?" Redoing the install command finishes nigh-instantly, so probs yes
05:47:56 <Gurkenglas> *)
05:49:41 <mauke> what command are you using to get that error?
05:50:19 <Gurkenglas> Doubleclicking the .hs file
05:50:28 <Gurkenglas> (Windows 8 here)
05:50:45 <Gurkenglas> Give me a command to use for launching instead?
05:50:58 <mauke> I don't know what doubleclicking does
05:51:40 <Gurkenglas> Usually it opens ghci compiles the code and gives me a line where I can, for example, type main into to execute main
05:53:45 <prinsen> Is there any try-like function for ExceptT? like ExceptT e m a -> ExceptT e m (Either e a)
05:55:45 <prinsen> Is there any try-like function for ExceptT? like ExceptT e m a -> ExceptT e m (Either e a)
06:01:21 <Gurkenglas> Okay so I did "ghci -v" in the folder with my .hs files, then ":l bitstampticker.hs" and it said it looked for wreq in Network\Wreq.hs and Network\Wreq.lhs. ghci is located in the Haskell Platform folder and having the Windows Explorer run a search for wreq in that yields nothing. Where does cabal install stuff to?
06:03:44 <prinsen> Is there any try-like function for ExceptT? like ExceptT e m a -> ExceptT e m (Either e a)
06:04:02 <Gurkenglas> Okay so I did "ghci -v" in the folder with my .hs files, then ":l bitstampticker.hs" and it said it looked for wreq in Network\Wreq.hs and Network\Wreq.lhs. ghci is located in the Haskell Platform folder and having the Windows Explorer run a search for wreq in that yields nothing. Where does cabal install stuff to?
06:04:25 <mauke> Gurkenglas: what does "ghc-pkg list" say?
06:05:29 <Gurkenglas> http://pastebin.com/E1eLfZEg
06:05:47 <joe9> Loved the "monads for functional programming" paper. Is there any such paper for the cont monad too?
06:06:58 <mauke> Gurkenglas: I'm not sure what the recache thing is about
06:07:06 <Gurkenglas> Gesundheit.
06:07:32 <mauke> I'd try that first
06:08:13 <Gurkenglas> Hey, how'd I miss those lines complaining about a recache thing?
06:08:34 <Gurkenglas> C:\Users\Gurkenglas>ghc-pkg recache
06:08:34 <Gurkenglas> ghc-pkg: C:/Program Files (x86)/Haskell Platform/2013.2.0.0\lib\package.conf.d\p
06:08:34 <Gurkenglas> ackage.cache: you don't have permission to modify this fileC:\Users\Gurkenglas>ghc-pkg recache
06:08:34 <Gurkenglas> ghc-pkg: C:/Program Files (x86)/Haskell Platform/2013.2.0.0\lib\package.conf.d\p
06:08:34 <Gurkenglas> ackage.cache: you don't have permission to modify this file
06:08:56 <Gurkenglas> Weird, how'd that paste more lines than I marked
06:09:19 <Gurkenglas> Oh, I must have double-tapped ctrl-v or sth. Soz.
06:09:56 <mauke> do you have more than one ghc?
06:10:09 <Gurkenglas> dunno
06:12:11 <Gurkenglas> (Windows-Explorer-searching C: for "ghc" is taking a while)
06:14:07 <ezrios> I am trying to use replicateM to update state inside a State monad, basically bumping up a counter by one
06:14:34 <ezrios> however if I replicateM this update state action, the counter appears to only increase by one instead of by n
06:14:49 <vanila> :t replicateM
06:14:50 <lambdabot> Monad m => Int -> m a -> m [a]
06:15:16 <Gurkenglas> (The speed of the progress bar seems to be inversely proportional to the remaining part of the progress bar...)
06:15:20 <vanila> > replicateM 10 (\i -> do s <- get ; put (s+1) ; return s) 7
06:15:23 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
06:15:23 <lambdabot>    arising from a use of ‘M309747184728483269518913.show_M3097471847284832695...
06:15:23 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
06:15:23 <lambdabot>  Note: there are several potential instances:
06:15:23 <lambdabot>    instance [safe] GHC.Show.Show a =>
06:15:24 <mauke> :t replicateM_ 42 (modify (+1))
06:15:25 <lambdabot> (MonadState s m, Num s) => m ()
06:15:29 <Gurkenglas> -inversely
06:15:58 <mauke> > runState (replicateM_ 3 (modify (+1))) 4
06:16:01 <lambdabot>  ((),7)
06:16:06 <vanila> > evalState (replicateM 10 (do s <- get ; put (s+1) ; return s)) 7
06:16:08 <lambdabot>  [7,8,9,10,11,12,13,14,15,16]
06:16:30 <vanila> ezrios, thre's an example of increasing counter with replicateM
06:16:45 <ezrios> vanila: ok, thanks
06:17:29 <joe9>  alpounet: you around?
06:20:32 <Gurkenglas> mauke, how do I check?
06:25:34 <ezrios> > evalState (replicateM_ 10 (do s <- get ; put (s+1) ; return s)) 7
06:25:36 <lambdabot>  ()
06:26:07 <ezrios> > runState (replicateM_ 10 (do s <- get ; put (s+1) ; return s)) 7
06:26:08 <lambdabot>  ((),17)
06:26:56 * hackagebot Genbank 1.0.3 - Libary for processing the NCBI genbank format  http://hackage.haskell.org/package/Genbank-1.0.3 (FlorianEggenhofer)
06:31:57 * hackagebot courier 0.1.0.15 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.15 (PhilHargett)
06:44:39 <[Bergi]> Hi! Sorry for leaving so abruptly yesterday.
06:44:39 <[Bergi]> Does anyone here know a package/module that offers a helper function like "fmap . fmap"?
06:45:37 <[Bergi]> Someone (luite) suggested the lens module, but I could not find anything as I got lost in its type classes.
06:46:58 * hackagebot mandrill 0.1.0.2 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.1.0.2 (AlfredoDiNapoli)
06:55:19 <nshepperd> if you're frequently fmapping twice over the same data type, maybe you want to be using a Data.Functor.Compose
06:57:13 <[Bergi]> No, it's not frequent, and I don't want to introduce an extra type
06:57:54 <[Bergi]> I just am looking for a generic helper function that maps over two nested functors of different types (in my case, a function that returns a list)
06:58:16 <nshepperd> :t fmap . fmap
06:58:17 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:58:33 <nshepperd> @hoogle (a -> b) -> f (f1 a) -> f (f1 b)
06:58:36 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:58:36 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
06:58:36 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:58:46 <nshepperd> frump
06:58:57 <[Bergi]> i've tried hoogle already :-/
07:01:14 <EvanR_> fmap . fmap ?
07:01:45 <[Bergi]> EvanR_: Yes, only I'm looking for a single function that does this :-)
07:01:56 <EvanR_> frump = fmap . fmap
07:01:56 <nshepperd> I guess you can just define it yourself. fmap' = fmap . fmap
07:02:13 <nshepperd> hehe
07:02:20 <EvanR_> ffmap
07:03:02 <EvanR_> :t fmap . fmap . fmap
07:03:03 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:03:34 <[Bergi]> Yeah, I could do that easily, but that's not the goal - I was looking for a package that already offers this "for free"
07:04:31 <EvanR_> even if there was one i might use (fmap . fmap) literally in the code for clarity
07:04:56 <[Bergi]> If no one knows such a package, I will write it myself...
07:05:08 <saep> > (fmap `fmap` fmap) (+2) [[1..7]]
07:05:11 <lambdabot>  [[3,4,5,6,7,8,9]]
07:05:36 <[Bergi]> EvanR_: Yeah, that's what I'm currently doing, but I was looking for a way to shorten it a bit
07:09:33 <EvanR_> looked in missingH, useful, data aviary, nothing
07:09:56 <EvanR_> and utility-ht
07:19:22 <[Bergi]> EvanR_: Thanks, those are interesting packages I did not knew of! But nothing :-(
07:19:25 <absence> if i want to generate a bunch of Double values and save them to a binary file, should i make calls to Data.ByteString.Builder.doubleLE, or should i make a vector or something first?
07:28:44 <absence> hm, or maybe Data.Binary.Put
07:29:24 <shlevy> Any advice for how to choose between parsec and trifecta?
07:29:37 <shlevy> Also, any trifecta tutorials?
07:34:51 <Thimz> What exactly is Haskell about?
07:35:42 <hiptobecubic> Thimz, programming?
07:35:49 <sivteck> "An advanced purely-functional programming language" ?
07:35:57 <hiptobecubic> Thimz, what is any language about really?
07:36:12 <haasn> Thimz: Most uniquely: Programming without side effects. Also, programming with typeclass-based parametric polymorphism
07:36:24 <Thimz> Languages are just sounds that we twist and manipulate with our oral muscles
07:36:25 <haasn> And perhaps “programming with a strong static type system”
07:36:52 <hiptobecubic> Thimz, there are plenty of languages that no one speaks. Your definition is pretty narrow
07:37:04 * hackagebot keystore 0.6.3.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.3.0 (ChrisDornan)
07:37:06 * hackagebot protocol-buffers 2.0.17 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.17 (ChrisKuklewicz)
07:37:06 <haasn> I can't remember the last time I've spoken Haskell
07:37:08 * hackagebot protocol-buffers-descriptor 2.0.17 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.17 (ChrisKuklewicz)
07:37:10 * hackagebot hprotoc 2.0.17 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.17 (ChrisKuklewicz)
07:37:27 <Thimz> It's memorized muscle movements
07:37:29 <hiptobecubic> Some operators have a conventional pronunciation I guess?
07:37:43 <hiptobecubic> like 'boob-operator'
07:37:43 <HeladoDeBrownie> haasn, I hope that speakers of Haskell execute it in a restricted environment so as to avoid privacy violation
07:37:52 <Thimz> Give me an example of haskell
07:38:03 <hiptobecubic> > []
07:38:05 <lambdabot>  []
07:38:12 <haasn> > reverse [1..10]
07:38:14 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:38:16 <HeladoDeBrownie> main = putStrLn "Hello, world" -- Hello world program
07:38:16 <ddellacosta> are there any O(1) ways to identify if a value is a member of a set in Haskell?
07:38:34 <haasn> ddellacosta: you can use a HashSet which is not quite O(1) but scales really slowly afaik
07:39:17 <haasn> You could also look at the Bits class. I'm sure somebody somewhere has implemented a small Set-like thing based on bit vectors
07:39:26 <ddellacosta> maybe, not possible
07:39:26 <hiptobecubic> i would think hashmap?
07:39:26 <hiptobecubic> but check the docs
07:39:27 <ddellacosta> hiptobecubic: thanks, poking around there now
07:39:40 <ddellacosta> haasn: ah, thanks for the suggestions
07:39:46 <Walther> Hello folks! I'm trying to deploy a simple helloworld-esque haskell webapp to Heroku using the tutorial here https://github.com/mietek/haskell-on-heroku-examples/tree/master/hello-snap
07:40:07 <Walther> However, I'm running into the following error: "bash: cabal: command not found"
07:40:48 <UnrealQuester> have you installed cabal?
07:40:48 <Walther> ...which is weird, because when running "heroku run prepare", it seems to install cabal 1.20.0.2
07:41:13 <UnrealQuester> maybe its not in your PATH
07:41:38 <Walther> just to clarify, the error appears on Heroku's end, not on my local computer
07:41:45 <Walther> my local cabal works fine
07:42:46 <Bunnypowah> hai guys
07:43:56 <Bunnypowah> can anyone help me with my homework? I have to change parser numb to double using reads but I'm  not sure how
07:52:05 * hackagebot Unique 0.1.0.0 - Provides with the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.0 (kapral)
07:52:07 * hackagebot semver 0.3.1 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.1 (BrendanHay)
08:00:03 <Noinia> anyone with experience with the singletons library?
08:01:19 <Enzoray> Noinia, I believe every pro just left the room. Left 4 Singleton...!
08:01:46 <Noinia> I'm trying to use Filter (from Data.Promoton.Prelude.List) to filter a Vinyl record based on the types involved. But I'm getting a fairly vague error message
08:02:48 <Enzoray> I'm sorry, I don't have any experience involving Singleton's Library.
08:02:59 <HeladoDeBrownie> Noinia, go ahead and show the error (in an lpaste if it's multiple lines) and whoever can help and is disposed to will
08:03:26 <HeladoDeBrownie> Noinia, also the code
08:04:43 <Noinia> sec
08:05:21 <Enzoray> Does anyone have a bunch of Haskell exercises for a n00b?
08:05:46 <dawik> a singleton library?
08:06:09 <dawik> Enzoray: check out project euler
08:07:04 <Enzoray> dawik, a thanks, to you.
08:08:28 <dawik> Enzoray: and a very welcome to you
08:08:30 <Cale> Project Euler is good if you know a bit of number theory, but otherwise you might find it frustrating...
08:09:06 <Cale> There's http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
08:09:44 <Noinia> HeladoDeBrownie: http://lpaste.net/113222
08:10:25 <Cale> I think some of those haven't been fully translated from Prolog :P
08:10:26 <Noinia> i.e. the error is related to the ``True'' instance of FilterRec
08:10:48 <Cale> But there are lots of decent examples of things you'll probably want to know how to write :)
08:11:23 <Enzoray> Hmmm. Just to get this clear...ex. if we made this calculation is haskell -> calc a b c = d, which is (a + b + c = d), is the constructor to be like this num :: int(a) -> int(b) -> int(c) -> int(d)?
08:11:41 <Enzoray> without (x) ofc.
08:11:43 <Noinia> it seems that it cannot figure out that: Filter (== fld) (fld : rs) is really the same as (r : Filter (== fld) rs)
08:11:50 <Enzoray> int(x)*
08:12:50 <Cale> Enzoray: calc :: Int -> Int -> Int -> Int  would be an okay type signature for it
08:13:12 <Cale> (Note that Int must be capitalised, or else it's a type variable, which you don't want.)
08:13:35 <Enzoray> Hence, I could use Integer or Double..right?
08:13:48 <Cale> Yeah
08:14:05 <Cale> Or, if you want to be polymorphic, you could write  calc :: (Num a) => a -> a -> a -> a
08:14:22 <absence> what's a good/fast way to write millions of generated Double values to disk in specified endianness?
08:14:35 <Cale> Which says, "If a is any type that has an instance of the type class Num, then it can have type a -> a -> a -> a"
08:15:06 <Enzoray> And (num x) = x == Int, or what?
08:15:40 <Enzoray> Like, the x's becomes Integers. Because of Num.
08:15:41 <Cale> absence: hmm, specified endianness for *Double* values... I haven't seen that.
08:16:20 <Cale> Enzoray: You can think of Num as being a property which a type might or might not satisfy
08:16:49 <Cale> Enzoray: There are instances: Num Integer, Num Double, Num Int, Num (Complex Double), etc.
08:17:12 <Cale> Enzoray: and not other instances, e.g. there's no instance for Num Bool, at least by default
08:17:21 <Cale> (you could add one if you chose to)
08:17:24 <absence> Cale: bytestring builder has doubleLE/doubleBE function. not sure if it's a fast way to do things though
08:17:34 <Cale> absence: Oh, in that case, try that
08:17:39 <Enzoray> Ok, thanks. :)
08:18:18 <Cale> absence: I would expect bytestring-builder to have good performance
08:18:30 <Cale> absence: It would be reasonable to complain if it didn't.
08:19:51 <Cale> Oh, right, you don't need to use the separate package now either, because it was folded into the bytestring package in GHC 7.8 :)
08:19:59 <absence> Cale: if it was int32 values though, would you know of other ways? gut feeling says a function call for every item has some overhead compared to a (possibly non-existing) solution of using storable/unboxed vector and doing it in chunks of 64k items or something
08:21:06 <Cale> The ByteString package is full of rewrite rules which simplify the code that you write. I wouldn't be confident about counting function applications.
08:21:22 <Cale> (and also simplify the code after inlining and such)
08:22:07 <Cale> also, there's lots of internal pointer manipulation and buffer management and stuff which takes place
08:22:13 <Enzoray> :t lst
08:22:14 <lambdabot>     Not in scope: ‘lst’
08:22:14 <lambdabot>     Perhaps you meant one of these:
08:22:14 <lambdabot>       ‘fst’ (imported from Data.Tuple), ‘last’ (imported from Data.List),
08:22:29 <Enzoray> :t last
08:22:30 <lambdabot> [a] -> a
08:22:38 <Enzoray> :t fst
08:22:39 <lambdabot> (a, b) -> a
08:23:27 <Enzoray> Cale, what's the antonym for 'fst'?
08:23:32 <exio4> snd
08:23:41 <exio4> or what do you mean?
08:23:46 <Enzoray> Yeah, exacly.
08:23:47 <Cale> Yeah, fst and snd are the two parts of a pair
08:23:51 <Cale> :t snd
08:23:52 <lambdabot> (a, b) -> b
08:23:52 <Enzoray> :t snd
08:23:53 <lambdabot> (a, b) -> b
08:23:59 <Enzoray> Yeah, thanks.
08:24:02 <exio4> "first" and "second" :P
08:24:29 <Enzoray> Yeah, figured that out. :P I thought of first and last instead..
08:24:33 <absence> Cale: good point. i'll certainly give it a shot before implementing a complex solution myself :)
08:24:33 <Cale> Yeah, you could also write (\(x,y)->x) and (\(x,y)->y), so they need to have short names or else it's sort of pointless to define them :)
08:25:23 <HeladoDeBrownie> I think there can be a point to even having something longer, if it describes well what it does.
08:25:35 <exio4> the names are a bit "nicer" than car/cdr anyway!
08:25:36 <vanila> I think second takes much less cognitive load to type and read than (\(x,y)->y), even though it's only a few chars shorter
08:25:47 <Cale> HeladoDeBrownie: Except in this case, the lambdas are *extremely* descriptive
08:26:03 <haasn> The “opposite” of fst is Left!
08:26:11 <absence> also, given how much longer it takes to write something with punctuation, it wouldn't really be a problem even if the name was longer
08:26:12 <HeladoDeBrownie> Cale, agreed, for tuple extraction in particular it's quite clear what's going on.
08:26:24 <vanila> :t Left . fst
08:26:25 <lambdabot> (b, b2) -> Either b b1
08:27:23 <Enzoray> Erm, what does (Eq a) mean?
08:27:42 <Cale> Enzoray: That the type a supports equality testing (==) and (/=)
08:27:45 <haasn> @src Eq
08:27:45 <lambdabot> class Eq a where
08:27:45 <lambdabot>     (==), (/=) :: a -> a -> Bool
08:28:03 <Eduard_Munteanu> :t (==)
08:28:04 <lambdabot> Eq a => a -> a -> Bool
08:28:19 <Enzoray> So, 5 == 2 = False?
08:28:25 <Cale> right
08:28:27 <Cale> > 5 == 2
08:28:28 <lambdabot>  False
08:28:37 <nshepperd> :t first fst
08:28:38 <lambdabot> ((a, b), d) -> (a, d)
08:28:44 <Cale> Enzoray: Values of function types and various other abstract data types can't be compared for equality, so we have a predicate which tells us when types do support that operation.
08:29:15 <Cale> Enzoray: This is in general what type classes do -- they let you restrict type variables to just those types that support a given interface
08:29:32 <Cale> Enzoray: As another example, consider a function which would sort lists of various types
08:29:50 <Cale> You might at first think, well, it should have a type like [a] -> [a]
08:30:06 <Cale> i.e. it takes a list with elements of some type and produces another with elements of the same type
08:30:22 <Cale> However, there are many types for which ordering comparison doesn't make sense
08:30:41 <Cale> (<) just isn't defined for functions or IO actions or many other things
08:30:51 <Cale> So, we have a type class:
08:30:56 <Cale> @src Ord
08:30:56 <lambdabot> class (Eq a) => Ord a where
08:30:56 <lambdabot>     compare              :: a -> a -> Ordering
08:30:56 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:30:56 <lambdabot>     max, min             :: a -> a -> a
08:31:13 <Cale> and types which implement these operations become instances of Ord
08:31:24 <Cale> So then sort will get the type:
08:31:27 <Cale> :t sort
08:31:28 <lambdabot> Ord a => [a] -> [a]
08:31:55 <geekosaur> there's also that it lets each type carry around an appropriate behavior, rather than languages where there's 3 different kinds of equality and you have to know which one makes sense when
08:32:00 <geekosaur> (for Eq)
08:32:41 <geekosaur> (granting that one common split there doesn't apply to Haskell)
08:33:15 <Enzoray> Speaking of sense, do you guys know where you could find some logic excercises? I've been searching on the internet, results has been devestating.
08:33:38 <Cale> hmm...
08:33:52 <alom1> MN - NM = 9K   I need to prove it, can one give me a hint?
08:34:43 <Cale> alom1: Uh, this is #haskell. Also, there's not enough context for anyone to be able to help you with that :)
08:34:49 <Eduard_Munteanu> alom1, prove what? It's not much of a fully-defined question.
08:35:55 <Cale> alom1: Presumably this equation is being stated in some noncommutative ring, perhaps a matrix ring. Otherwise writing MN - NM instead of 0 would perhaps be a little silly.
08:36:29 <Cale> We have no idea what N, M and K are though :)
08:36:42 <alom1> MN - NM = 9K here MN is two digit natural number and NM is its reverse.   I need to prove it substraction of the numbers divide into 9, can one give me a hint?
08:36:49 <Cale> OH
08:36:50 <Cale> haha
08:37:01 <alom1> N, M and K are digits
08:37:02 <Cale> That's like the last thing I would have thought of
08:37:03 <alom1> :)
08:37:05 <alom1> err
08:37:07 <alom1> N and M
08:37:10 <Eduard_Munteanu> Or maybe exists K, forall M, N digits, {MN} - {NM} = {9K}, where {AB} = 10A + B?
08:37:14 <alom1> K is natular number
08:37:26 <Cale> alom1: So, just think about what it means to put two digits next to one another like that
08:37:36 <Cale> Like, what does 24 really mean?
08:37:41 <Cale> It means 2*10 + 4, right?
08:37:49 <alom1> yes
08:38:00 <Cale> So, when you write "NM" there, you really mean 10*N + M
08:38:44 <Cale> So that left hand side is really (10*M + N) - (10*N + M)
08:38:49 <alom1> thx
08:38:51 <alom1> clear
08:38:52 <alom1> :)
08:40:40 <Cale> Eduard_Munteanu: Of course, the 9K isn't meant to be digits :)
08:41:01 <Eduard_Munteanu> Oh, oops.
08:41:36 <Cale> (10*M + N) - (10*N + M) = 9*M - 9*N = 9*(M-N)
08:42:27 <Cale> Enzoray: I'm still thinking about what sort of recommendation to give you for logic
08:42:38 <Cale> Enzoray: Do you have any particular sort of logic in mind?
08:43:08 <Enzoray> Cale, regular logic?.. Is that a valid answer? Srsly.. Apparently I'm pretty bad at logic... :P
08:43:21 <Cale> okay :)
08:52:07 <tnks> IVars are write-once variables, but they aren't like linear types, are they?
08:52:17 <tnks> is the second write a runtime error?
08:52:39 <Cale> Yes, it's a runtime error
08:52:51 <tnks> k, just checking.
08:54:09 <tnks> I guess I'd use it where appropriate over an MVar.
08:54:13 <Cale> Enzoray: hmm, maybe I should give you Hedman's book...
08:54:18 <tnks> but smaller benefit.
08:55:21 <Cale> There was another one I was thinking was appropriate, but I haven't tidied up my downloads directory in ages and it's probably in there :P
08:56:07 <Enzoray> Oh, well. Thanks for the advice, I'll check it out!
08:56:48 <Cale> Enzoray: Sent you a link in PM :)
08:57:13 * hackagebot Spock 0.7.3.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.3.0 (AlexanderThiemann)
09:04:41 <kqr> does anyone happen to know how to check if a field is null with persistent?
09:07:56 <phaazon> god
09:08:34 <phaazon> I’m sick of reading edwardk’s doc mentioning “left adjoint” and “forgetful functors” everywhere and being unable to understand what’s about
09:08:58 <vanila> phaazon, those are basic category theory terms
09:09:06 <phaazon> basic, yeah
09:09:14 <phaazon> then I suck at category theory :(
09:09:15 <vanila> what library is this?
09:09:17 <phaazon> ree
09:09:19 <phaazon> free*
09:09:39 <vanila> well if you have trouble using it maybe soeone here can help
09:09:46 <phaazon> no no
09:09:52 <phaazon> I have no problem using free
09:09:59 <phaazon> I have problem with category theory terms
09:10:03 <vanila> why?
09:10:13 <phaazon> because I don’t understand what and adjunction is
09:10:21 <phaazon> as well as a forgetful functor
09:10:35 <phaazon> well
09:10:43 <phaazon> the forgetful functor is not that hard actually
09:10:47 <phaazon> I reckon that…
09:10:48 <vanila> if you'rae familiar with functors it wont be too much work to learn about adjunctions
09:10:53 <phaazon> [a] -> Maybe a is a forgetful functor
09:11:00 <vanila> I don't think so
09:11:09 <timpani> Is there any way to lift 'if' into a monad, i.e., to use some combinator to eliminate x (or more) in "do { b <- x; if b then return y else return z}" ?
09:11:12 <phaazon> since we lose ability to map lists with more than one elements
09:11:13 <vanila> an example of a forgetful functor is a map from e.g. groups to the underlying sets
09:11:21 <vanila> you forget the algebraic structure
09:11:49 <vanila> by the way "forgetful functor" is a loose term, it's not something formal
09:11:55 <vanila> adjunction on the hand is a formal term
09:12:07 <vanila> :t ifM
09:12:08 <lambdabot> Not in scope: ‘ifM’
09:12:12 <phaazon> vanila: I know they’re related
09:12:13 <vanila> timpani, you could define one
09:12:23 <vanila> :t boolM
09:12:25 <lambdabot>     Not in scope: ‘boolM’
09:12:25 <lambdabot>     Perhaps you meant ‘bool’ (imported from Data.Bool)
09:12:32 <vanila> something like boolM = liftM2 bool
09:12:33 <phaazon> :t whenM
09:12:34 <lambdabot>     Not in scope: ‘whenM’
09:12:34 <lambdabot>     Perhaps you meant ‘when’ (imported from Control.Monad.Writer)
09:12:41 <vanila> sorry liftM3
09:12:48 <phaazon> :t bool
09:12:49 <lambdabot> a -> a -> Bool -> a
09:13:15 <JonManley> Hi. What kind of text parsing do you guys use? I'm quite new to Haskell and I'm not sure what library should I start with. Should I use attoparsec or Parsec or using plain old regex (I know regex well).
09:13:23 <phaazon> JonManley: parsec
09:13:32 <phaazon> or attoparsec, and aeson for JSON values
09:13:39 <phaazon> vanila: so, I know they’re related
09:13:42 <vanila> phaazon, adjunctions are very relevant to freely generated structures, it's probably a good thing that the docs admit this rather than hiding it
09:13:44 <phaazon> but I don’t understand how
09:13:57 <vanila> there is an adjoint between forgetful functors and freely generated structures
09:14:05 <phaazon> adjoint?
09:14:07 <funrep> what is best practice to install haskell on arch? (so i dont get any global packages like with the haskell platform)
09:14:18 <JonManley> phaazon: thx
09:14:59 <exio4> > let ifM cnd t f = cnd >>= \x → if x then t else f in ifM [True,False,True] (return 1) (return 2)
09:15:01 <lambdabot>  [1,2,1]
09:15:27 <phaazon> ok so hm, a functor is from C a -> D b, a forgetful functor is from C a -> D b where we can’t rebuild the C structure in D?
09:15:37 <phaazon> so no contrafunctor exists?
09:16:17 <phaazon> like hm, hashing, vanila ?
09:16:18 <JonManley> funrep: I don't know about grobal packages, but I just installed cabal with "yaourt cabal-install" on arch
09:17:00 <funrep> okey
09:19:42 <sivteck> funrep, there's no haskell platform on the official repo afaik, install ghc,cabal-install,happy,alex and haddock as usual
09:19:44 <vanila> phaazon, its usually about forgetting algebraic structure like group theory laws
09:20:09 <vanila> the haskell notion of "functor" is probably confusing if you want to learn this stuff for real
09:21:00 <tharper> vanila: less so than the OCaml notion
09:21:01 <tharper> =P
09:22:08 <sivteck> funrep, use pacman!
09:22:08 <phaazon> vanila: why?
09:22:19 <phaazon> because Haskell’s functors are actually endofunctors?
09:22:45 <vanila> mostly that yeah
09:28:02 <dfeuer> phaazon, there is a Contrafunctor in one of Edward Kmett's packages, and it does just what you'd expect.
09:28:42 <phaazon> yeah
09:28:45 <phaazon> I use it
09:28:48 <phaazon> sometimes
09:28:58 <phaazon> but I don’t expect anything
09:29:09 <phaazon> I just want to understand what an adjunction is
09:30:26 <nitrix> Hi, is there something in haskell like a lazy buffer, where data is read from it, and when the end is reached, a function is called to fill it up a bit more?
09:31:22 <nitrix> I have data divided into multiple files and I though it's be convenient if I could work with a single unified unit, linearly.
09:31:45 <vanila> nitrix, you could create this
09:31:49 <nitrix> A bit like some list comprehensions I guess.
09:32:33 <vanila> phaazon, this is a good intro to adjunctions https://www.youtube.com/watch?v=loOJxIOmShE&list=UU5Y9H2KDRHZZTWZJtlH4VbA
09:33:23 <phaazon> thank you
09:33:26 <phaazon> just to be sure
09:33:33 <phaazon> if I take a preordered set
09:33:35 <phaazon> it’s a category
09:33:38 <phaazon> in which hm…
09:33:44 <phaazon> elements are the set elements
09:33:48 <vanila> yeah each poset forms a category
09:33:53 <phaazon> and morphisms are relations
09:33:57 <phaazon> from x to y
09:34:00 <phaazon> when x ≤ y
09:34:02 <phaazon> right?
09:34:02 <vanila> a --> b  when  a <= b
09:34:04 <vanila> that's right
09:34:05 <mietek> Walther: hello
09:34:07 <phaazon> ok
09:34:10 <phaazon> that’s actually simple :D
09:37:18 * hackagebot hoogle-index 0.3.3 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.3.3 (BenGamari)
09:50:17 <phaazon> ok sohm
09:50:31 <phaazon> an adjunction is a pair of natural transformations
09:52:23 <monochrom> no, a pair of functors
09:52:42 <phaazon> the video says natural transformations…
09:52:51 <phaazon> https://www.youtube.com/watch?v=loOJxIOmShE&list=UU5Y9H2KDRHZZTWZJtlH4VbA&t=7m
09:54:27 <monochrom> ok, I suppose it's "all of the above"
09:54:32 <phaazon> ?
09:55:03 <monochrom> you need two functors and a whole bunch of natural transformations to write down the whole thing.
09:57:46 <[Bergi]> So, for anyone still wondering about "fmap . fmap":
09:57:46 <[Bergi]> I now found two packages, "functors" and "functor-infix", that offer stuff like <$$> and .: on Functors. Yikes!
09:58:18 <phaazon> hm
09:58:22 <phaazon> I’m not co
09:58:25 <phaazon> oops
09:58:34 <phaazon> I’m not comfortable with natural transformations
10:02:17 <Cale> phaazon: If you like, I can perhaps give some intuition about it
10:02:26 <Cale> phaazon: (I'm assuming you've seen the definition)
10:02:46 <vanila> phaazon, its a pair of functors with a pair of natural transforms between them
10:02:56 <vanila> with some laws about them
10:04:01 <Cale> If you want to compare categories, perhaps the first thing you'd think of as a non-category-theorist would be what's called isomorphism of categories:
10:04:23 * dfeuer looks up and sees that Cale is giving intuition. 
10:04:39 <Cale> Two categories C and D are isomorphic if there are a pair of functors F: C -> D and G: D -> C such that G . F = id_C and F . G = id_D
10:05:16 <phaazon> Cale: yeah
10:05:17 <Cale> This turns out to be way too strong in many cases though: in category theory, we're not really supposed to care about the distinction between isomorphic objects in a category
10:05:29 <Cale> Or at least, often we don't
10:05:30 <phaazon> I understand iso-* pretty well
10:06:13 <Cale> So, we might instead require that instead of landing on the same object *on the nose* when you compose F and G either way
10:06:21 <Cale> you land on something isomorphic to what you started with
10:06:42 <Cale> and a convenient way to express that is to say that there are natural isomorphisms:
10:06:53 <Cale> eta: id_C -> G . F
10:07:02 <Cale> and epsilon: F . G -> id_D
10:07:18 <Cale> (i.e. invertible natural transformations)
10:07:26 <dfeuer> What be a natural transformation?
10:07:42 <Cale> dfeuer: I'll talk about those in just a sec :)
10:07:46 <dfeuer> OKAY.
10:08:05 <Cale> So, doing this, we get what's called an equivalence of categories
10:08:45 <Cale> If we go further still, we can remove the condition that eta and epsilon be isomorphisms, and instead just require that they interact with each other in a nice way
10:10:27 <Cale> and that gets us to the concept of an adjunction -- you're not really expressing that the two categories are "the same" any more, but it is a sort of relationship which occurs frequently in situations where one sort of structure can be simplified into another, and vice versa, there's a canonical way to build an example of the more involved structure from the simple one.
10:10:58 <Cale> (free and forgetful functors)
10:11:03 <Cale> So, natural transformations
10:11:35 <phaazon> :(
10:11:49 <Cale> So, one way to think of functors is that they're sort of offering "sketches" of one category inside another
10:12:03 <Cale> If I have some functor F: C -> D
10:12:32 <Cale> the image of that functor is like a "squished picture of C"
10:12:40 <Cale> where perhaps some objects and arrows have been identified
10:12:48 <Cale> but all the commutative triangles still commute
10:12:57 <Cale> (and indeed, all the commutative diagrams)
10:13:28 <Cale> If you want a geometric intuition, you can think of objects in a category as points, arrows between them as (directed) line segments or curves joining those points
10:13:41 <phaazon> nono
10:13:48 <phaazon> I understand what a category is
10:13:53 <Cale> and then commutative diagrams as 2-dimensional sheets that join the 1-dimensional cells together
10:14:00 <phaazon> I know what a functor is as well
10:14:09 <phaazon> I reckon a natural transformation is a morphism between two functors
10:14:10 <Cale> and with that intuition a functor is providing a sort of continuous mapping
10:14:19 <Cale> yes, it is
10:14:33 <Cale> I wanted to have that geometric intuition for functors first though :)
10:14:57 <phaazon> so
10:15:05 <phaazon> in this geometric intuition
10:15:09 <Cale> So if we have two parallel functors F and G both functors C -> D
10:15:09 <phaazon> what is an adjunction?
10:15:25 <phaazon> F -> G is a nat trans
10:15:37 <Cale> i.e. we have two different sketches of C sitting inside D
10:15:54 <Cale> and we want to talk about what it means to provide a mapping from one to the other
10:16:42 <Cale> Well, it would make sense to ask for some sort of path between corresponding points: for each object X in C an arrow eta_X: FX -> GX
10:17:38 <Cale> and then for each of the arrows of C, we want a 2-dimensional surface connecting up the corresponding paths, i.e. for each f: X -> Y in C, we want a commutative square
10:18:21 <Cale> with Ff: FX -> FY on one end (the image of f according to the first sketch)
10:18:27 <Cale> Gf: GX -> GY on the other
10:18:34 <phaazon> yeah, I’m lost :D
10:18:57 <Cale> and eta_X: FX -> GX and eta_Y: FY -> GY on the two sides
10:19:15 <Cale> This is all much nicer if we have diagrams
10:20:29 <Cale> Maybe I can get a whiteboard for us, but I'm sure if I link it in an IRC channel with 1400 people, *someone* will start drawing dicks, so I'll link you in PM
10:21:01 <exio4> Cale: can I get the link?
10:21:09 <phaazon> ahah, thanks :D
10:21:16 <exio4> I will _only_ stalk, I promise ;P
10:21:44 <malllle> Cale: i'd like the link aswell :)
10:22:29 <phaazon> ok so
10:22:37 <phaazon> x, y and z are just morphisms
10:22:46 <phaazon> well no
10:22:49 <phaazon> a b*
10:22:54 <phaazon> x y and z are objects I guess
10:23:57 <Cale> So that's the first picture I want to show
10:24:15 <Cale> A commutative triangle in C corresponds to a commutative triangle in D by the functor F
10:24:23 <phaazon> yeah
10:24:26 <phaazon> that sounds legit
10:25:23 <Cale> and you can sort of picture this commutativity as some kind of imaginary 2D surface filling the triangles
10:25:46 <Cale> okay, so now
10:27:20 <monochrom> "Voronoi triangulation of the plane using commuting diagrams"...
10:27:44 <phaazon> bloody hell
10:27:51 <phaazon> those look like potatoes
10:27:54 <Cale> right
10:28:17 <monochrom> :)
10:28:20 <Cale> The blob is meant to represent the whole category C, all its objects and arrows and commutative triangles and such
10:28:30 <phaazon> ok
10:28:35 <phaazon> so when applying the functor
10:28:39 <phaazon> you end up in aa…
10:28:44 <phaazon> bigger category?
10:29:02 <Cale> Yeah, of course, it might not actually be "bigger" in any reasonable sense
10:29:05 <Cale> But another category
10:29:14 <Cale> and the image of C might be somewhat "collapsed"
10:29:26 <phaazon> collapsed?
10:29:27 <Cale> in that we might send multiple objects of C to the same object of D
10:29:33 <Cale> and multiple arrows to the same arrow
10:29:43 <phaazon> hm
10:29:44 <phaazon> ok
10:29:53 <Cale> But we're sending objects to objects, arrows to arrows, and commutative triangles to commutative triangles
10:30:31 <Cale> So now we have these two pictures of C sitting in D. Let me redraw this...
10:32:38 <Cale> hopefully that's sufficiently readable
10:32:46 <phaazon> yeah but
10:32:51 <Cale> so we want to discuss a mapping from one sketch to the other now
10:32:52 <phaazon> why haven’t you written the composition?
10:32:58 <Cale> just haven't
10:33:02 <phaazon> ok
10:33:06 <Cale> really I could have stuck to a single arrow
10:33:17 <Cale> might've been even clearer for what's coming
10:33:55 <phaazon> yeah, the red lines are nat. trans., right?
10:34:21 <Cale> yeah, they're the components of this single natural transformation η
10:34:25 <Cale> (eta)
10:34:39 <phaazon> components?
10:35:16 <Cale> yeah, that's just the name for it
10:35:25 <Cale> the natural transformation is really a collection of all these arrows
10:35:31 <Cale> eta_X for each X in C
10:35:44 <Cale> and for each arrow a: X -> Y in C
10:35:52 <phaazon> ok
10:35:54 <Cale> We want there to be a surface connecting Fa to Ga
10:36:09 <Cale> that is, we want the squares I shaded in to commute
10:36:12 <dfeuer> Cale, link?
10:36:19 <Cale> https://awwapp.com/draw.html#245d61e7
10:36:24 <Cale> oh, dang
10:36:31 <Cale> Well, I wasn't going to link in channel :P
10:36:32 <phaazon> people are responsible
10:36:36 <Cale> Hopefully!
10:36:39 <Cale> haha
10:36:39 <phaazon> :)
10:37:17 <dfeuer> Looks complicated.
10:37:21 <phaazon> hm cleamoon
10:37:23 <phaazon> Cale: *
10:37:34 <phaazon> I thought you’d have something a bit different for a nat trans
10:37:37 <flapol> @pl  good n = n > 0 and n <= 5
10:37:37 <lambdabot> (line 1, column 25):
10:37:37 <lambdabot> unexpected "5"
10:37:37 <lambdabot> expecting space
10:37:37 <lambdabot> ambiguous use of a non associative operator
10:37:42 <Cale> dfeuer: Well, you also missed the earlier pictures :P
10:37:43 <flapol> @pl  \n = n > 0 and n <= 5
10:37:43 <lambdabot> (line 1, column 4):
10:37:43 <lambdabot> unexpected "="
10:37:43 <lambdabot> expecting operator, pattern or "->"
10:37:46 <dfeuer> Oh.
10:37:48 <flapol> @pl  \n = n > 0 && n <= 5
10:37:48 <lambdabot> (line 1, column 4):
10:37:49 <lambdabot> unexpected "="
10:37:49 <lambdabot> expecting operator, pattern or "->"
10:37:50 <dfeuer> Oh well.
10:37:54 <dfeuer> yah, got distracted.
10:37:56 <flapol> @pl  \n -> n > 0 && n <= 5
10:37:56 <lambdabot> liftM2 (&&) (> 0) (<= 5)
10:37:59 <phaazon> like, see what I’m drawing:
10:38:26 <phaazon> damn that’s hard with a trackpoint :D
10:40:04 <phaazon> I thought nat. trans. were my red arrows
10:40:15 <Cale> Yeah, that's not quite the right picture
10:40:33 <phaazon> yeah I know
10:40:48 <phaazon> but I guess it’s similar?
10:41:46 <phaazon> yeah sure
10:41:50 <phaazon> ok
10:41:57 <phaazon> I think I got it now!
10:42:00 <Cale> Natural transformations always go between functors having the same domain and codomain
10:42:09 <phaazon> so, adjunctions!
10:42:26 <Cale> okay
10:44:47 <phaazon> ok hm
10:44:48 <phaazon> 1c
10:44:53 <phaazon> it’s the unit in C?
10:44:56 <Cale> 1_C is the identity functor on C
10:45:05 <Cale> which sends every object to itself and every arrow to itself
10:45:52 <phaazon> I don’t get the notation
10:45:55 <Cale> okay
10:45:58 <phaazon> 1c -> G·F
10:46:00 <phaazon> what does that mean?
10:46:09 <phaazon> it’s a function that takes the identity functor
10:46:21 <Cale> It means eta is a natural transformation from the identity functor to the composite functor G . F
10:46:25 <phaazon> and maps it to… a functor?
10:46:29 <phaazon> an endofunctor?
10:46:59 <phaazon> yeah, ok
10:47:00 <phaazon> got it
10:48:41 <Cale> Does it sort of make sense what's going on in that picture so far?
10:48:49 <phaazon> yes
10:48:58 <Cale> We're mapping C to D by F, and then coming back again by G
10:49:05 <phaazon> does it have a name?
10:49:07 <phaazon> isofunctor?
10:49:12 <Cale> endofunctor
10:49:19 <phaazon> well
10:49:19 <Cale> G . F is an endofunctor on C
10:49:23 <phaazon> yes
10:49:24 <phaazon> I know that
10:49:37 <phaazon> but it’s an endofunctor because of isomorphism, rigt?
10:49:39 <Cale> Now, we're asking for a natural transformation from the identity on C to G . F
10:49:42 <phaazon> right*
10:49:43 <Cale> So in this picture...
10:49:46 <Eduard_Munteanu> It's not an isomorphism.
10:50:29 <Cale> eta is collapsing our identity sketch of C in itself
10:50:38 <phaazon> hm
10:50:42 <Cale> to the sketch of C obtained by mapping over to D and back again
10:50:50 <phaazon> that’s horribly complicated :/
10:51:22 <Cale> Well, the picture is perhaps more complicated than the abstract math of it.
10:51:36 <phaazon> so
10:51:38 <Cale> (but it can help once you start trying to work with things to have a picture attached to them)
10:51:42 <phaazon> if I understand correctly
10:51:55 <phaazon> if I have an object in C
10:51:59 <Cale> So what is eta really?
10:52:06 <Cale> It has a bunch of components
10:52:11 <Cale> for each X in C
10:52:26 * hackagebot git-repair 1.20141026 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20141026 (JoeyHess)
10:52:26 <Cale> we have an arrow eta_X: X -> G(FX)
10:52:59 <Eduard_Munteanu> An adjunction is something way less than an isomorphism, but yes, it sort of points towards an isomorphism.
10:53:47 <phaazon> so this is an adjunction actually?
10:53:56 <phaazon> two natural transformations?
10:54:12 <Cale> Yeah, if we were insisting that eta and epsilon here were natural isomorphisms (not just natural transformations, but ones where every component eta_X was an isomorphism), then this would be a description of an equivalence of categories
10:54:13 <phaazon> well, those two ones
10:54:27 <Cale> Two functors and two natural transformations
10:54:34 <Cale> and some conditions on these I haven't got to yet
10:54:36 <phaazon> oh
10:54:44 <phaazon> that’s why you mentionned a square?
10:55:13 <Cale> So, the square, maybe I should make that clearer, that was part of the description of a natural transformation if I understand what you're referring to correctly
10:55:26 <phaazon> right, yeah
10:55:43 <phaazon> crystal clear now :)
10:56:47 <phaazon> yeah
10:56:51 <phaazon> that’s what I understood
10:57:28 <Cale> These squares were the ones I shaded in red
10:57:33 <Cale> in the diagram I made
10:57:37 <phaazon> yep
10:57:39 <phaazon> so hm
10:57:49 <Cale> they're sort of sweeping out the images of the arrows in C :)
10:57:52 <phaazon> when we say “F is left adjoint to G”
10:58:40 <Cale> Yeah, this is a different F and G now, be careful
10:59:12 <Cale> actually, maybe I should explain a bit of another way to look at adjunctions too
10:59:31 <Cale> that explains the "left" in "left adjoint" a bit better
11:01:03 <phaazon> huh
11:01:19 <phaazon> F and G are what, functors?
11:01:25 <phaazon> yeah thanks
11:01:38 <iulian> You can also think of an adjunction in terms of hom-sets.
11:01:50 <phaazon> I don’t know what hom-sets are
11:02:19 <phaazon> woah
11:02:22 <phaazon> D(FX,Y)
11:02:25 <phaazon> what does that mean?
11:02:36 <Cale> D(FX,Y) is the set of arrows from FX to Y in D
11:02:43 <iulian> If you let C be the category of sets, Hom_C(X,Y) is the collection of functions from the set X to the set Y.
11:02:46 <Eduard_Munteanu> Hom(FX,Y) is another notation.
11:02:50 <phaazon> ok
11:02:59 <phaazon> I’ll see hom-sets later guys
11:03:00 <Cale> Yeah, Hom_D(FX,Y) or simply Hom(FX,Y) mean the same thing
11:03:26 <phaazon> don’t make me more confused than I already am :D
11:03:27 <Cale> But the important thing is that for each arrow FX -> Y, we get a corresponding arrow X -> GY
11:03:32 <Cale> and vice versa
11:03:44 <Cale> in a one-to-one (and onto) correspondence
11:03:48 <Eduard_Munteanu> phaazon, it's just that locally-small categories have Hom as plain sets, not arbitrary classes, by definition
11:03:49 <phaazon> ok
11:03:52 <phaazon> a way to getting back so
11:03:59 <Cale> Do you know some basic linear algebra?
11:04:03 <phaazon> yes
11:04:14 <phaazon> I do
11:04:17 <Cale> Like, if I was to talk about bases and linear transformations...
11:04:18 <Cale> okay
11:04:22 <phaazon> sure
11:04:44 <phaazon> (I’m writting a 3D engine, I better know that! :D)
11:05:27 <monochrom> (have you also written an nD engine? :) )
11:05:34 <Cale> So, given any set X and field F, we can produce the vector space of formal linear combinations of elements of X, which you can think of as functions X -> F with finitely many elements of X being sent to nonzero elements of F
11:05:47 <phaazon> (monochrom: I’d love to :) )
11:06:06 <Cale> Or just as the collection of expressions of the form a_1 x_1 + ... + a_n x_n with each a_i in F and x_i in X.
11:06:21 <Cale> If you're not familiar with fields, just take F to be the real numbers if you like
11:06:34 <phaazon> I am, no problem
11:06:37 <Cale> Okay so far?
11:06:39 <Cale> All right
11:06:41 <phaazon> yeah
11:06:54 <Cale> So also, given any vector space V, we can consider the underlying set V
11:07:06 <Cale> by just forgetting that it was a vector space
11:07:19 <Cale> throwing away the addition and scalar multiplication operations
11:07:29 <Cale> Which I'll denote by |V|
11:07:42 <Cale> er, my notation sucks a little :)
11:08:00 <Cale> but anyway
11:08:15 <phaazon> ok
11:08:18 <Cale> this V: Set -> Vect which takes a set and turns it into a vector space is a functor
11:08:19 <phaazon> so you forget the structure
11:08:26 <Cale> and |-|: Vect -> Set is also a functor
11:08:35 <phaazon> yeah
11:08:39 <phaazon> but V adds
11:08:46 <phaazon> and |-| removes
11:08:49 <Cale> yeah
11:09:01 <phaazon> so |-| is a forgetful functor?
11:09:05 <Cale> yes
11:09:08 <Cale> and V is "free"
11:09:15 <phaazon> oh!
11:09:25 <Cale> V is taking a set and building a vector space from it in the most straightforward possible way
11:09:27 <phaazon> ok
11:09:43 <phaazon> this is pretty great
11:09:56 <phaazon> I have a better idea of what “free” means in any context now
11:10:05 <phaazon> like free monoid
11:10:08 <Cale> Now, you might be familiar with the notion that given a basis for a vector space V, the linear transformations V -> W are determined uniquely by what they do to the base
11:10:10 <Cale> basis*
11:10:14 <Eduard_Munteanu> Might be fair to note V is a particular construction, not just any way to build a vector space.
11:10:20 <monochrom> yeah, "free" is in adjunction with "forget"
11:10:23 <phaazon> Cale: yes
11:11:29 <Cale> So, here, we have that for any set X and vector space W, each function X -> |W| corresponds uniquely to a linear transformation V(X) -> W
11:11:48 <Cale> i.e. the V functor is left adjoint to the |-| functor
11:13:41 <phaazon> yeah, I don’t really see how it’s “left”
11:13:41 <wz1000> ghc-mod cannot find the 'Network' Module. Any idea as to why this is happening? The code compiles fine.
11:13:58 <phaazon> but you’ve already explained a lot to me
11:14:02 <Cale> phaazon: Well, in V(X) -> W the V occurs to the left of the arrow
11:14:12 <Cale> and X -> |W|, the |-| occurs on the right
11:14:18 <phaazon> oh
11:14:22 <tac_> phaazon: once it clicks, you will see free things everywhere
11:14:33 <phaazon> ok, right
11:14:39 <tac_> It just means something like "built out of parts recursively with no restrictions"
11:14:52 <Cale> Yeah, kinda
11:14:53 <monochrom> and once you enter grad school, you will also see free pizza offered everywhere :)
11:14:58 <Cale> haha
11:15:15 <phaazon> monochrom: I have a job eh ;)
11:15:20 * tac_ wants free pizza
11:15:29 <phaazon> thank you very much for your time Cale
11:15:31 <phaazon> you rock :)
11:15:31 <monochrom> then it's probably free donuts during meetings
11:15:35 <iulian> Also note that the adjunction that Cale just described is between the category of sets and the category of vector spaces (over real numbers). You can replace the category of vector spaces by the category of monoids (you've mentioned that you know what a free monoid is).
11:15:37 <Cale> phaazon: no problem!
11:16:01 <Cale> Yeah, or you can do something similar with the category of monoids and the category of groups
11:16:33 <phaazon> yeah
11:16:35 <phaazon> let me do that
11:16:51 <Cale> Forcibly turning a monoid into a group by throwing in inverses for each element, and forgetting that a group was really a group and not just a monoid.
11:17:11 <phaazon> ok so
11:17:31 <phaazon> mapping a monoid to a group is free while the inverse is a forgetful functor
11:17:39 <Cale> yeah
11:17:43 <phaazon> and
11:17:52 <phaazon> mapping a monoid to a semigroup is forgetful
11:17:59 <Cale> right
11:17:59 <phaazon> while the other way around is free
11:18:22 <phaazon> ok, pretty great! :)
11:18:45 <phaazon> thank you!
11:18:46 <Cale> wz1000: I don't know a lot about ghc-mod, but perhaps it's not configured to use the network package?
11:19:26 <Cale> phaazon: What's more is that every adjunction gets us a monad
11:19:39 <Cale> (and a comonad)
11:19:43 <phaazon> hm
11:19:47 <Cale> Going back to the vector space example
11:20:06 <Cale> We get a monad on Set which sends each set X to the set |V(X)|
11:21:30 <Cale> The unit (return) of that monad has components X -> |V(X)| which assign to each x in X the linear combination 1*x
11:21:32 <guesting> I want to write a web crawler to travel through links to download files. Is there a recommended library for this? Shpider seems to be what I want, but it's really out of date and cannot install on modern ghc.
11:22:37 <Cale> and the multiplication (join) of that monad has components (sorry for notation!) mu_X: |V(|V(X)|)| -> |V(X)|, which take a linear combination of linear combinations and multiply everything out
11:23:22 <Cale> The algebras of this monad are precisely vector spaces, and we could define the category of vector spaces from scratch by setting up this monad on Set, and then just taking vector spaces to be its algebras.
11:23:48 <phaazon> alright
11:23:57 <phaazon> my brain’s gotten liquified
11:23:58 <phaazon> :D
11:24:54 <phaazon> ok, now, Haskell question
11:25:01 <phaazon> type Houra = Free Foo
11:25:26 <phaazon> if I want to express my constructors using Free, I guess I have to write a few combinators, right?
11:26:14 <iulian> Find out how to get a monad from an adjunction first and then do an example (Cale's example is a very good one). A monad is basically just a monoid in the category of endofunctors.
11:26:47 <phaazon> ok wait
11:26:56 <phaazon> a monoid in the category of endofunctors
11:27:02 <phaazon> objects are…
11:27:13 <phaazon> functors
11:27:25 <phaazon> and morphisms are nat. trans
11:27:29 <phaazon> how is that a monad?
11:27:29 <Cale> (if you don't know what T-algebras for a monad T are, then part of my remark above will have made no sense, but that's okay, you can save it for when you learn that :)
11:28:16 <Cale> A monoid object is sort of an abstraction of what ordinary monoids are in the category of sets to a more general class of categories
11:28:25 <Cale> (called monoidal categories)
11:28:40 <phaazon> ok
11:28:44 <phaazon> that’s too much for tonight
11:28:45 <phaazon> :D
11:28:48 <Cale> yeah
11:28:52 <Cale> It takes a bunch of setup really
11:29:03 <Cale> But the idea is that where with ordinary monoids
11:29:09 <phaazon> this is a typical French issue we have here…
11:29:09 <Cale> you have some set M
11:29:31 <phaazon> we don’t have courses to teach what, for instance, a T algebra is
11:29:35 <Cale> together with an identity element which we might regard as being picked out by a function from the one element set: eta: 1 -> M
11:29:39 <phaazon> and wikipedia looks like dark magic
11:29:48 <Cale> and a multiplication map: mu: M x M -> M
11:29:59 <Cale> We don't really have undergrad courses for that here either
11:30:24 <phaazon> where do you get the knowledge from then?
11:30:26 <Wingsorc> does someone of you use windows as development platform?
11:30:31 <Cale> books
11:30:48 <phaazon> Cale: yeah, right, I should read more indeed :)
11:31:00 <phaazon> I also find very useful speaking on IRC
11:31:03 <phaazon> more dynamic :)
11:31:04 <Cale> So, with monads, you have some endofunctor M
11:31:12 <Cale> and natural transformations eta: 1 -> M
11:31:19 <Cale> and mu: M.M -> M
11:31:32 <Cale> where in place of the one element set 1, we now have the identity functor 1
11:31:45 <Cale> and in place of the Cartesian product x we have composition of functors .
11:32:14 <Cale> and the laws which a monad is supposed to satisfy exactly parallel the laws for a monoid if you write them out using commutative diagrams with this setup
11:33:22 <benzrf> Cale: hella
11:33:23 <Cale> and you can generalise this and ask what monoids are in other categories so long as you have some appropriate choice of "1" and product operation on objects
11:35:07 <Cale> So that if you do this in the category of vector spaces, with the base field taking the place of 1, and tensor product of spaces for the product, you get what's sometimes called an algebra (a vector space which is also a ring in such a way that the addition is the same and the multiplication and scalar multiplication agree nicely)
11:35:38 <Cale> (there are too many things in mathematics which are called algebras, this is rather different from the algebras of a monad)
11:39:14 <dfeuer> thoughtpolice, is there a way for me to *cancel* Phab builds, or only pause them?
11:40:24 <Ferdiran1> Hey #haskell, what's the mathematical name of mconcat ?
11:42:39 <benzrf> Ferdirand: "the monoid operation"
11:42:48 <benzrf> usually indicated by multiplication
11:42:53 <Ferdirand> mconcat, not mappend
11:42:56 <benzrf> wait shit
11:43:08 <benzrf> god dammit i keep confusing the names ;-;
11:43:11 <Fuuzetsu> hm, I think there is a name
11:43:23 <Ferdirand> something like "the monoid sum" but without being tied to addition
11:43:34 <Fuuzetsu> isn't it just the catamorphism though
11:43:43 <Ferdirand> very possible
11:43:44 <Fuuzetsu> no
11:44:13 <Ferdirand> oh :( i was rejoicing from the possibility of using "catamorphism" in a real sentence
11:44:53 <Fuuzetsu> I'd have to open a book, think it was there
11:44:55 <Fuuzetsu> lazy
11:46:12 <Ferdirand> i don't know what a catamorphism is. I've read somewhere that folds are catamorphisms on lists ?
11:46:25 <Ferdirand> then mappend sounds like a catamorphism on monoids
11:50:28 <benzrf> Ferdirand: no,
11:50:33 <benzrf> catamorphisms are folds
11:50:44 <benzrf> Ferdirand: if anything they are catamorphisms on pairs
11:51:02 <benzrf> :t cata
11:51:03 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
11:51:15 <benzrf> Ferdirand: ever heard of polynomial functors
11:51:29 <Fuuzetsu> don't think polynomial functors apply here…
11:52:00 <benzrf> Fuuzetsu: but they're neat     because when you use them to build your types then you get catamorphisms for free
11:52:20 <Fuuzetsu> that seems like a strange reason to bring them in
11:52:42 <benzrf> th-they're fun
11:53:12 <benzrf> damn
11:53:19 <benzrf> i still have the clowns and jokers paper open in a tab
11:53:24 <benzrf> its been what 4 months
11:53:30 <benzrf> crap
11:55:40 <benzrf> @let data K a t = K a; data I a = I a; data C f g a = L (f a) | R (g a); data P f g a = P (f a) (g a)
11:55:41 <lambdabot>  Defined.
11:56:23 <LowPotential> I have a project which depends on `text-format', which in turn depends on `double-conversion'. When I try to load my project into ghci, I get the following error: Loading package double-conversion-2.0.1.0 ... linking ... ghc: [...]/.cabal-sandbox/lib/x86_64-linux-ghc-7.6.3/double-conversion-2.0.1.0/libHSdouble-conversion-2.0.1.0.a: unknown symbol `_ZNK17double_conversion23StringToDoubleConverter12StringToIeeeIPKcEEdT_ibPi'
11:56:24 <LowPotential> ghc: unable to load package `double-conversion-2.0.1.0'. This person (https://github.com/BioHaskell/hPDB/issues/2) seems to see the same thing. This bug (https://ghc.haskell.org/trac/ghc/ticket/5289) may be related, but I'm not sure. I'm on Fedora 20.
11:56:24 <LowPotential>  
11:57:12 <lpaste> gregnwosu pasted “my cabal install issue” at http://lpaste.net/113235
11:57:33 <benzrf> @let instance Functor (K a) where fmap = const id; instance Functor I where fmap f (I a) = I (f a); instance (Functor f, Functor g) => Functor (C f g) where {fmap f (L fa) = L (fmap f fa); fmap f (R ga) = R (fmap f ga)};
11:57:33 <lambdabot>  Parse failed: Parse error: instance
11:57:47 <benzrf> @let instance Functor (K a) where {fmap = const id};instance Functor I where {fmap f (I a) = I (f a)}; instance (Functor f, Functor g) => Functor (C f g) where {fmap f (L fa) = L (fmap f fa); fmap f (R ga) = R (fmap f ga)};
11:57:49 <lambdabot>  .L.hs:173:22:
11:57:49 <lambdabot>      Couldn't match type ‘a1’ with ‘b’
11:57:49 <lambdabot>        ‘a1’ is a rigid type variable bound by
11:57:49 <lambdabot>             the type signature for fmap :: (a1 -> b) -> K a a1 -> K a b
11:57:49 <lambdabot>             at .L.hs:173:9
11:57:52 <benzrf> dang
11:57:53 <Fuuzetsu>  /query
11:57:57 <benzrf> yea was abt to
11:58:00 <gregnwosu> can anyone tell me what it means when cabal says it can find dll
11:58:08 <LowPotential> Any ideas on how to tackle the linking error with `double-conversion'. I have no clue where to start.
11:58:11 <LowPotential> ?
11:58:14 <benzrf> gregnwosu: it means you should be using a better OS
11:59:18 <sivteck> or make supercabal \o/
11:59:36 <Cale> benzrf: That's not very helpful :(
11:59:45 <EponymicCycloid> Why does haskell tell me “Invalid type signature: (:+) :: a -> LL a -> LL a        Should be of form <variable> :: <type>”? It looks like ghc doesn’t like it when the operator starts with a colon. I was able to fix it by making it start with something else.
11:59:51 <benzrf> OK!
11:59:51 <Cale> gregnwosu: Which error message are you getting exactly?
12:00:08 <Zekka> EponymicCycloid: : is not a valid operator prefix unless the operator is a constructor
12:00:11 <Zekka> Think of : as a capital letter
12:00:19 <EponymicCycloid> Zekka: Interesting
12:00:23 <EponymicCycloid> I was unaware of this
12:00:31 <EponymicCycloid> Why is that a rule?
12:00:41 <EponymicCycloid> Scratch that
12:00:43 <EponymicCycloid> dumb question
12:00:48 <Cale> EponymicCycloid: In order to determine whether something is a pattern binding or function binding :)
12:01:11 <Zekka> Yeah, it's just to prevent ambiguity in a few cases where there otherwise might be some
12:02:15 <benzrf> @let type PolynomialList a r = C (K ()) (P (K a) r)
12:02:17 <lambdabot>  Defined.
12:02:39 <benzrf> @let type PList a = Mu (PolynomialList a)
12:02:40 <lambdabot>  .L.hs:187:20:
12:02:40 <lambdabot>      Expecting one more argument to ‘PolynomialList a’
12:02:40 <lambdabot>      The first argument of ‘Mu’ should have kind ‘* -> *’,
12:02:40 <lambdabot>        but ‘PolynomialList a’ has kind ‘(k0 -> *) -> k0 -> *’
12:02:40 <lambdabot>      In the type ‘Mu (PolynomialList a)’
12:02:43 <benzrf> dang
12:03:00 <benzrf> oh crap i ssee
12:03:12 <benzrf> @let type PolynomialList' a = C (K ()) (P (K a) I)
12:03:13 <lambdabot>  Defined.
12:03:16 <benzrf> @let type PList' a = Mu (PolynomialList' a)
12:03:17 <lambdabot>  Defined.
12:03:22 <benzrf> there we go :-)
12:04:35 <benzrf> :t flip cata `asAppliedTo` (undefined :: PList' Int)
12:04:36 <lambdabot> Mu (PolynomialList' Int) -> (PolynomialList' Int c -> c) -> c
12:06:13 <benzrf> folds for free! ish!
12:06:18 <benzrf> almost!
12:06:22 <Zekka> :t cata
12:06:23 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
12:07:31 <benzrf> cata phi = phi . fmap cata phi . out
12:07:37 <benzrf> :t \phi -> phi . fmap cata phi . out
12:07:39 <lambdabot> Functor f => ((Mu f -> Mu ((->) (Mu f))) -> f (Mu ((->) (Mu f))) -> Mu ((->) (Mu f))) -> Mu ((->) (Mu f)) -> f (Mu ((->) (Mu f))) -> Mu ((->) (Mu f))
12:07:41 <benzrf> wait. no
12:07:43 <benzrf> der
12:07:48 <sushith> what is 'N' in haskell?
12:07:50 <benzrf> :t \phi -> phi . fmap (cata phi) . out
12:07:51 <lambdabot> Functor f => (f b -> b) -> Mu f -> b
12:07:54 <benzrf> there we go
12:08:11 <benzrf> Zekka: for example,
12:08:15 <jonas234> Hi guys, what is the best practice: (+) w  1 `replicate` "|"                     or                 replicate  ( w + 1) "|")
12:08:40 <benzrf> > cata length (In [In [], In [In [], In []], In [In []]])
12:08:42 <lambdabot>  3
12:08:42 <Fuuzetsu> the second, the first is just weird
12:08:55 <Zekka> benzrf: What's a Mu?
12:09:03 <benzrf> Zekka: type-level fix point
12:09:11 <dmwit> sushith: N doesn't have any special meaning in Haskell the language and I don't recognize it from the base libraries.
12:09:20 <benzrf> newtype Mu f = In {out :: f (Mu f)}
12:09:26 <Zekka> OK, I get you
12:09:55 <dmwit> sushith: If it's in scope, you can get more information about it in ghci with ":i N".
12:09:56 <benzrf> so at the level where the fmapped function isnt actually applied, you get whatever the "default" is
12:10:02 <Zekka> So cata takes a funtion from a structure containing a thing to a thing and turns it into a function from a recursive version of that structure to that thing?
12:10:02 <benzrf> then from there you can apply it on the innermost layer
12:10:03 <benzrf> etc
12:10:11 <benzrf> Zekka: yes
12:10:17 <benzrf> generalized catamorphisms
12:10:28 <benzrf> Zekka: are you familiar with polynomial functors?
12:10:47 <dmwit> JonReed: I would replicate (w+1) "|"
12:10:51 <Fuuzetsu> you sure want to sell polynomial functors to someone today
12:10:51 <dmwit> uh
12:10:58 <dmwit> jonas234: That was for you.
12:11:04 <jonas234> Ok thanks haha :)
12:11:18 <Zekka> benzrf: Back. No, what are they?
12:11:32 <benzrf> Zekka: pretty cool!!!
12:11:33 <Zekka> You defined a polynomial list type but I don't know in general what a polynomial functor is based on that
12:11:38 <sushith> dmwit:sorry, im a newb. got it. capital letters cannot be used as variables right?
12:11:46 <benzrf> any kind of data type built up from those basically i think
12:12:01 <Zekka> sushith: Names starting with capital letters are usually constructors or modules afaik in Haskell
12:12:20 <benzrf> Zekka: but the key thing is that the functor instances for those 4 basic types compose
12:12:27 <benzrf> such that cata works on em
12:12:28 <dmwit> sushith: Correct; variables must start with lower-case or symbol. Anything starting with an upper-case or : is a term or type constructor.
12:12:41 <Zekka> benzrf: Can we go through the four basic types again? You can repost your definitions or I an go up and look for them
12:13:05 <benzrf> data K a t = K a; data I a = I a; data C f g a = L (f a) | R (g a); data P f g a = P (f a) (g a)
12:13:21 <benzrf> C for coproduct, P for product
12:13:25 <sinelaw> hi, trying to understand this post "seemingly impossible functional programs" http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
12:13:27 <sushith> Zekka:, dmwit: thanks
12:13:29 <Zekka> OK, I think I get all of them
12:13:30 <benzrf> i picked those because the place i read about them used + and *
12:13:39 <benzrf> Zekka: so you can define simple functor instaces
12:13:40 <Zekka> K is Const and I is identity?
12:13:42 <benzrf> yeah
12:13:48 <sinelaw> anyone read it?
12:13:50 <benzrf> C is not quite Either thoughtpolice
12:13:53 <benzrf> *though
12:13:55 <dmwit> sinelaw: Don't ask to ask, just ask.
12:14:01 <benzrf> for one thing, fmap will traverse either branch
12:14:18 <benzrf> same for P and (,)
12:14:45 <Zekka> Each branch has the same type and each branch is known to use apply some functor, even though they might apply a different one?
12:15:13 <Zekka> So intuition, it's more like Either and (,) on the level of functors than on the level of plain types?
12:15:41 <benzrf> yeah
12:15:42 <sinelaw> sorry. when he defines existential / universal quantification over predicates on cantor space, he defines as the exsitential: forsome p = p(find(\a -> p a))   is this supposed to mean "there exists a p s.t. forsome p is true", or something else?
12:15:44 <benzrf> er
12:15:46 <benzrf> something like that
12:15:56 <benzrf> Zekka: the instances look like
12:15:59 <sushith> any other bot for playing?, for newbs like me.
12:16:04 <Zekka> benzrf: Is there something more precise I should have said?
12:16:11 <Zekka> sushith: If you just want to use it as a repl you can query lambdabot
12:16:15 <Zekka> is there something more specific you need?
12:16:20 <benzrf> maybe types of kind * rather than 'regular types' p:
12:16:27 <dmwit> sinelaw: "forsome p" should be read as "does there exist x such that p x is true?"
12:16:31 <Zekka> benzrf: Yeah, that's what I meant
12:16:52 <benzrf> Zekka: but basically you can represent almost any type with those combinators and Mu
12:17:00 <benzrf> any functor or something
12:17:12 <benzrf> K thing for constant-typed spots and I for ones that are parameterized
12:17:18 <benzrf> C and P for structure
12:17:22 <Zekka> Alright. Can you transcribe list again? I'll see if I understand it correctly
12:17:54 <benzrf> type UnfixedList a = C (K ()) (P (K a) I)
12:18:15 <benzrf> so that's either a () or an a and one of whatever we're parameterized by
12:18:17 <benzrf> then,
12:18:23 <Zekka> Right
12:18:24 <benzrf> type List a = Mu (UnfixedList a)
12:18:36 <Zekka> And that's an UnfixedList parameterized over itself
12:18:40 <benzrf> right
12:18:57 <benzrf> but then you have cata:
12:19:08 <Zekka> :t cata
12:19:09 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
12:19:10 <benzrf> wait
12:19:19 <benzrf> ok,  check out what fmap does for this
12:19:28 <Zekka> So Cata takes an operation that folds up an UnfixedList and turns it into an operation hat folds up a Fixed list?
12:19:34 <benzrf> yeah
12:19:36 <Zekka> er, a fixed List*
12:19:49 <benzrf> fmap in this case will either map over the tail or over nothing at all
12:20:25 <benzrf> so an UnfixedList-a-algebra will need to handle either unit or Cons a t
12:20:28 <benzrf> and produce a t
12:20:59 <Zekka> An algebra is a function that expresses a fold-analogue over a structure, right?
12:21:04 <Zekka> One that matches each constructor?
12:21:06 <sinelaw> dmwit, and the other one means "does every x satisfy p?"
12:21:09 <benzrf> F-algebra is a morphism from F a to a
12:21:14 <benzrf> i was being needlessly wordy
12:21:37 <Zekka> Alright, I think I understand
12:21:44 <benzrf> this works because
12:21:59 <benzrf> a fold can be derived by looking at a type and requiring a handler for each constructor
12:22:09 <benzrf> but you need to special-case when the type is self-referencing
12:22:33 <benzrf> in this scheme, you already have that information because you specifically mark the parts where you self-reference and then let Mu do it for you
12:23:20 <Zekka> Right, so you write a normal algebra and use cata to convert it into an algebra over a fixed structure?
12:23:29 <benzrf> yea!
12:23:33 <Zekka> so there's no need to do anything tricksy in expressing your original algebra
12:23:35 <benzrf> well not really an algebra i think
12:23:41 <benzrf> yeah, look at a regular fold
12:23:41 <benzrf> :t foldr
12:23:42 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:23:46 <benzrf> that's really more like
12:23:53 <Zekka> My intuition for an algebra was basically "a function that pattern matches"
12:24:03 <benzrf> forget that word >.> it wasnt relevant
12:24:06 <Zekka> er, that's not cclear enough
12:24:11 <Zekka> OK, I'll stop using that word
12:24:15 <benzrf> hah
12:24:33 <benzrf> (Either (a, b) () -> b) -> [a] -> b
12:24:44 <benzrf> ~ (a -> b -> b) -> b -> [a] -> b
12:25:09 <benzrf> the (a, b) is the cons after you replace the self-reference with the result type
12:25:18 <Zekka> Right, where Either (a, b) () is the form of a list and the folded-over rest of a list in terms of products and coproducts
12:25:24 <benzrf> yeah!
12:26:07 <benzrf> so when you express that using polynomial functors, you have a functor where the mapped-over part is the recursion
12:26:22 <benzrf> so you get the ability to special-case that for free
12:26:24 <sinelaw> dmwit, further down there's a missing closing paren when he defines modulus of uniform continuity
12:26:25 <benzrf> through the functor instance
12:26:35 <Zekka> One sec, processing that
12:26:35 <benzrf> which is automatically there when you compose it using those combinators
12:27:07 <Zekka> Right, so when you write it the intuitive way with polynomial functors you're saying you don't really know what b is until you fix it, at which point b is definitely the recursive part and things work as you expect
12:27:38 * hackagebot idris 0.9.15 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.15 (EdwinBrady)
12:28:08 <Zekka> So it's something like matching  Either (a, c) () -> b before specializing it to Either (a, b) () -> b?
12:28:16 <benzrf> hmmmmmmm
12:28:23 <benzrf> can you explain in a little more detail what you mean
12:28:53 <guesting> Nevermind. This repository is way more up to date and should replace the shpider on hackage: https://github.com/TikhonJelvis/shpider
12:29:34 <Zekka> benzrf: Let's just look at the type of UnfixedList as a 'data' before fixing
12:30:40 <Zekka> benzrf: Is this correct? data UnfixedList a c = Null () | Cons a c
12:31:09 <benzrf> y e a h
12:31:31 <Zekka> benzrf: Matching over this structure is the same as matching Either (a, c) () into b
12:31:38 <benzrf> hmmmm
12:31:45 <benzrf> "matching"?
12:32:15 <Zekka> benzrf: I'm using "matching" to get at the intuition that it's much like an ordinary ADT
12:32:22 <benzrf> hmmmmm ok
12:32:23 <Zekka> even if we express it in terms of the primitives you defined earlier
12:33:22 <Zekka> I don't think I'm saying verym uch more than that you can write UnfixedList a c -> Either (a, c) () and Either (a, c) () -> UnfixedList a c, and won't lose any information
12:34:03 <benzrf> you mean that they are isomorphic
12:34:10 <Zekka> benzrf: Yeah, but I'm trying not to use big words
12:34:17 <benzrf> BIG WORDS ARE FUN
12:34:44 <Zekka> So, when we fold over it we're writing a function like Either (a, c) () -> b
12:34:52 <Zekka> That's similar to the type of the argument of cata
12:35:36 <benzrf> yesh
12:35:37 <Zekka> But when we use cata we specialize that to Either (a, b) () -> b, and when we use Mu we make a rule that while the structure contains itself, when we unpack it with Cata we get a b instead of the Mu
12:35:45 <Zekka> with cata*
12:35:51 <benzrf> yea
12:35:55 <Zekka> it doesn't literally contain a b but what cata does for us is substitute the Mu with a b, correct?
12:37:20 <benzrf> y-yes
12:37:29 <benzrf> that's kind of orthogonal to the point i was making, though
12:37:37 <Zekka> What's the point I'm missing?
12:37:40 <benzrf> well
12:37:55 <benzrf> i dunno if youre *missing* it
12:38:03 <benzrf> it's just a different thing from what you were talking about
12:38:20 <benzrf> what im saying is, the important part of folds is the recursive aspect
12:38:35 <benzrf> how you know which part of the structure is where it recurses
12:38:51 <benzrf> what's special about polynomial functors that lets you automatically get a fold from cata
12:39:04 <benzrf> is that the functor instance specifically points out the spots where it's recursive for you
12:39:10 <benzrf> so you know which part of the data to recursively fold on
12:39:27 <benzrf> and what's special about those 4 combinators is that their functor instances compose
12:39:41 <Zekka> Alright. They compose because any combination of them is sitll a functor?
12:39:48 <benzrf> to be precise what i meant is
12:39:55 <benzrf> wait yeah thats what i mean
12:39:56 <benzrf> :Lp
12:40:03 <benzrf> so you get a recursion-indicating functor instance for free if you make your data type out of the combinators
12:40:11 <benzrf> so you get folds for free
12:40:14 <Zekka> And in order, K's functor instance returns the argument unchanged, I's applies it to the value inside, and C and P apply it on either or both sides respectively
12:40:23 <benzrf> yeah
12:40:43 <Zekka> So because fmap works correctly on each of the original structures, and because they compose, fmap works correctly on the recursive structure and traverses it in a way that's pretty sane
12:40:47 <benzrf> so C and P just propagate, K drops it because there's no recursion there, and I is an instance of the parameter, which when fix'd is the recursive bit
12:40:50 <benzrf> Zekka: yeah!
12:41:09 <benzrf> of course little of this is practical
12:41:11 <Zekka> (that is, it fmaps the function into every place it possibly can)
12:41:12 <benzrf> but it's sure fun to think about!!
12:41:32 <Zekka> Yeah, it's cute
12:47:41 * hackagebot dash-haskell 1.0.0.2 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.2 (jfeltz)
12:51:06 <Xeanort> where can I find a school for hacking? Thanks..
12:51:23 <phaazon> Xeanort: develop hacking please
12:51:42 <phaazon> if you mean “hacking”, you’re definitely in the wrong place pal
12:51:48 <phaazon> this is a chan about Haskell
12:51:52 <phaazon> if you look for Haskell hacking
12:52:06 <phaazon> maybe some folks around here can help you
12:52:14 <phaazon> (I don’t know any schools about haskell)
12:52:22 <Xeanort> haskell is a program language, right?
12:52:32 <Xeanort> a lot of website suggest this irc xD
12:52:54 <Xeanort> anyway no, hacking in general
12:53:43 <nadirs> @faq is any Functor also a Monad?
12:53:43 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:54:11 <simpson> nadirs: No.
12:54:32 <nadirs> simpson: I know, I hoped to get the "Yes! Haskell can do that" answer, just for fun :P
12:54:36 <simpson> Ah.
12:54:37 <guesting> I am trying to install a haskell program with nothing in it (main :: IO; main = do; print "hi") and I am getting the error in cabal: cabal: /tmp/20080.c: resource exhausted
12:55:09 <guesting> It all of a sudden started happening for no reason--I didn't edit any cabal file or anything
12:55:24 <Fuuzetsu> are you out of disk space or something
12:55:38 <guesting> Fuuzetsu: No, I am using up 36% disk space
12:56:10 <geekosaur> resource exhausted makes me think out of either virtual memory or processes
12:56:44 <benzrf> i want that @faq  back ;-;
12:56:44 <guesting> A friend is using up 13% memory to run a program
12:56:52 <guesting> there is ~ 30gigs left though
12:56:59 <guesting> (server)
12:57:47 <guesting> does cabal have a more verbose error message system?
12:58:08 <geekosaur> -v3?
12:58:37 <guesting> everything goes fine until the end
12:58:39 <guesting> where it says that
12:59:40 <guesting> I removed all libraries from the cabal file and it still says that
13:00:03 <guesting> maybe if i delete the sandbox and try again
13:00:28 <guesting> nope, still says it
13:01:03 <Fuuzetsu> ignore cabal and try just using GHC directly
13:01:16 <merijn> guesting: Other guesses: File descriptor limits, per user disk space limits, CPU limits
13:01:29 <merijn> Well, the latter seems unlikely, but anyway
13:01:35 <guesting> AH
13:01:36 <guesting> ok
13:01:46 <guesting> when I use ghc it does the same problem
13:01:57 <merijn> guesting: Check out if "ulimit -a" has any numbers that look low
13:02:03 <guesting> with "createDirectory: resource exhausted (No space left on device)
13:02:06 <guesting> which is weird
13:02:16 <guesting> because I have a ton of space according to "df"
13:02:16 <merijn> oh
13:02:26 <guesting> OOOOH
13:02:29 <guesting> in my HOME I do
13:02:29 <Fuuzetsu> are you sure you have tons of space on /tmp
13:02:31 <Fuuzetsu> …
13:02:32 <guesting> but not in root!
13:02:36 <merijn> :)
13:02:38 <guesting> hm
13:02:43 <guesting> so how can I clear that up?
13:02:57 <merijn> guesting: FYI, this is why it's usually recommend to have /tmp on a seperate partition from /root
13:03:00 <Fuuzetsu> it's your system, we can't tell you what to delete…
13:03:12 <merijn> guesting: "du -d 1 -h" and figure out what's eating your space
13:03:34 <merijn> guesting: Alternative ghetto solution, symlink /tmp to some place in /home to make use of free space there
13:03:44 <merijn> guesting: /var/log is a common culprit for low disk space
13:04:08 <guesting> merijn: Yeah, this is a server so it's on for days and days and days
13:04:12 <guesting> log might be huge
13:04:39 <merijn> A properly set up server should do log rotation, so uptime shouldn't matter. But if an application is misconfigured
13:04:54 <Fuuzetsu> just like Hackage, right ;P
13:04:56 <merijn> Also, maybe /tmp is just full and you need to nuke some junk there (it's usually cleaned on reboot)
13:06:36 <guesting> ok, var isn't the problem (although log is kinda big, but just ~ 100 mb not too bad)
13:06:46 <merijn> Anyone here ever installed arcanist on OSX?
13:07:11 <Fuuzetsu> pretty sure carter would have
13:07:49 <merijn> I guess #ghc is a better place for that question :)
13:07:53 <carter> Fuuzetsu: ?
13:08:19 <carter> ohhh
13:08:26 <carter> merijn: iu dont install per se
13:08:27 <merijn> carter: Installing arcanist on OSX. My stuff is setup and I have some fixes for GHC to make, but I can't be arsed to run testing locally
13:08:28 <carter> i clone
13:08:34 <carter> cool
13:08:35 <carter> :)
13:08:51 <carter> ../phab../bin/arc  skdfjdsklfj
13:08:55 <carter> is what I do
13:08:55 <carter> roughly
13:09:26 <guesting> HOLY MOLEY
13:09:34 <merijn> carter: Sure, but I don't normally have php installed, so I have no idea which stuff I need
13:09:39 <carter> no
13:09:42 <carter> mac has php installed
13:09:43 <carter> normally
13:09:46 <carter> i think
13:09:48 <merijn> carter: The php5-cli names listed for apt-get don't seem to exist in macports
13:09:50 <merijn> It does?
13:09:57 <merijn> I'll be damned
13:10:05 <Fuuzetsu> what a great OS
13:11:23 <benzrf> >using php
13:11:36 <Welkin> can I just install the new haskell platform over the old one?
13:12:19 <merijn> benzrf: That's what arcanist/phabricator use, so what's the alternative
13:12:32 <merijn> benzrf: Are you reimplementing the phab infrastructure for GHC?
13:12:50 <merijn> Welkin: On OSX it comes with an uninstaller script, I would assume it does on other platforms too?
13:13:03 <merijn> Welkin: Although I think you can have multiple parallel installs, at least on OSX.
13:14:03 <Welkin> you mean "/Library/Haskell/ghc-7.6.3/bin/uninstall-hs"
13:14:31 <merijn> Welkin: yeah
13:14:41 <Welkin> what about all the packages I have installed through cabal?
13:15:09 <mbqw> hey, i'm a hakell rookie and i'm playing around with eclipse-fp and i get a warning from eclipse i dont know what it means
13:15:11 <merijn> I think that nukes everything, but to make sure you can check ~/Library/Haskell which has the package database
13:15:32 <mbqw> i defined 2 functions
13:16:00 <mbqw> str3 xs ys zs = xs ++ ys ++zs and
13:16:39 <mbqw> test =  \x -> \y ->  str3 x y "World"
13:17:24 <mbqw> in the line where i defined test i get the warnings  "Collapsed lamda" and " Redundand lambda"
13:17:32 <Welkin> well yes
13:17:33 <Welkin> it is
13:17:35 <mbqw> what does this men
13:17:44 <Welkin> jyst use /x y ->
13:17:52 <Welkin> er, \x y ->
13:17:57 <Welkin> for a lambda that takes two arguments
13:18:22 <Eduard_Munteanu> Also test x y = ...
13:18:30 <Welkin> yes
13:18:43 <Welkin> defining a function as a lambda doesn't make sense anyway
13:18:57 <Welkin> you are defining an anonymous function
13:19:03 <Welkin> making it no longer anonymous
13:19:59 <mbqw> that makes sense to me, but i saw it on an mooc at edx
13:20:14 <mrenaud_> Hey, random question, does anyone know why <$> is in Control.Applicative even though it's just fmap and has nothing to do with Applicative?
13:20:28 <Welkin> it is an applicative combinator
13:20:30 <mbqw> when do you use lambda expressions
13:20:31 <Welkin> used with <*>
13:20:39 <HeladoDeBrownie> Anonymity isn't necessarily the point of using a lambda. For example, I will make bindings whose values come from case lambdas.
13:20:50 <HeladoDeBrownie> (using the LambdaCase extension)
13:21:42 <Welkin> > (+) <$> Just 5 <*> Just 3
13:21:44 <lambdabot>  Just 8
13:21:50 <HeladoDeBrownie> mrenaud_, because it's commonly used along with (<$>), like so: f <$> x <*> y
13:22:02 <HeladoDeBrownie> along with (<*>) *
13:22:06 <mrenaud_> Walther: How so? The only constraint is that it be a functor, not an applicative
13:22:46 * hackagebot Spock 0.7.4.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.4.0 (AlexanderThiemann)
13:22:49 <HeladoDeBrownie> mrenaud_, you could also cite historical reasons. Like how we have void in Control.Monad
13:22:52 <HeladoDeBrownie> @type void
13:22:53 <lambdabot> Functor f => f a -> f ()
13:23:43 <mrenaud_> I can understand (<*>) being in Applicative, but <$> is defined to be fmap which is related to functors so I would expect that to be in Prelude like fmap is.
13:24:15 <mrenaud_> HeladoDeBrownie: Yeah, it's also strange that void is in Monad :/
13:24:17 <HeladoDeBrownie> You're right, it might make sense to put it there.
13:24:46 <geekosaur> I think it's actually planned
13:25:41 <geekosaur> <$> was introduced for use by Applicative so that was where it was put. it gets enough more general use that it's being considered for Prelude instead
13:25:59 <mrenaud_> geekosaur: That would be nice, it's good to hear that there are plans to clean some of it up at least. Not that it really matters, it would just be nice to have consistency
13:27:16 <HeladoDeBrownie> I find it even weirder that void is in Control.Monad given that it's been there since before the Applicative-Monad Proposal.
13:28:18 <bernalex> I think <$> and <*> should both be in Prelude.
13:28:44 <simpson> I think that it was caused by the original definition of void as: void m = m >> return ()
13:29:19 <Fuuzetsu> @src void
13:29:19 <lambdabot> Source not found. Do you think like you type?
13:29:41 <Fuuzetsu> :t return 7 <$ ()
13:29:42 <lambdabot>     Couldn't match expected type ‘f b0’ with actual type ‘()’
13:29:42 <lambdabot>     In the second argument of ‘(<$)’, namely ‘()’
13:29:42 <lambdabot>     In the expression: return 7 <$ ()
13:29:51 <Fuuzetsu> :t return 7 $> ()
13:29:52 <lambdabot>     Not in scope: ‘$>’
13:29:53 <lambdabot>     Perhaps you meant one of these:
13:29:53 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
13:29:59 <Fuuzetsu> :t (<$)
13:30:00 <lambdabot> Functor f => a -> f b -> f a
13:30:03 <bernalex> void is re-exported by Control.MOnad.
13:30:04 <Fuuzetsu> oh
13:30:09 <bernalex> it is actually defined in Data.Functor.
13:30:18 <bernalex> it should be just fmap (const ()).
13:30:24 <HeladoDeBrownie> bernalex, oh, that makes more sense. I guess I should have checked that.
13:30:30 <Fuuzetsu> bernalex: which is (<$)
13:30:32 <Fuuzetsu> with ()
13:30:42 <bernalex> <$> is also just re-exported by Control.Applicative. it is really defined in Data.Functor.
13:30:47 <Fuuzetsu> afaik (<$) = fmap . const
13:31:37 <mrenaud_> <$ seems like a strange function, what would be a use case for it?
13:32:07 <Fuuzetsu> replace all a in f a with the same value of b
13:32:10 <Eduard_Munteanu> mrenaud_, parsers
13:32:17 <sivteck> > 4 <$ [32
13:32:18 <lambdabot>  <hint>:1:9:
13:32:18 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:32:21 <sivteck> > 4 <$ [32]
13:32:22 <lambdabot>  [4]
13:32:29 <sivteck> > 4 <$ Just 328427930
13:32:30 <Eduard_Munteanu> mrenaud_, LetterO <$ string "o"
13:32:30 <lambdabot>  Just 4
13:32:48 <bernalex> Fuuzetsu: yes, I believe you are right wrt <$.
13:32:56 <profil> > "HEY" <$ "HELLO"
13:32:58 <lambdabot>  ["HEY","HEY","HEY","HEY","HEY"]
13:33:06 <mrenaud_> Ohh, so it would consume "o", then return whatever is on the left?
13:33:13 <profil> > '!' <$ "HELLO"
13:33:15 <lambdabot>  "!!!!!"
13:33:16 <Eduard_Munteanu> mrenaud_, yes
13:33:28 <mrenaud_> Interesting
13:34:06 <HeladoDeBrownie> Also potentially useful on IO, if you need a certain type of result but your effecting procedure doesn't return that
13:34:33 <HeladoDeBrownie> I have IO () but need IO Integer, so I just pick an Integer, say 0, and go 0 <$ doStuff
13:34:48 <bernalex> I've only seen it with IO.
13:35:16 <HeladoDeBrownie> IO is certainly one where some of those more trivial-seeming Functor operations are more useful
13:35:29 <HeladoDeBrownie> void and (<$) both included
13:35:39 <HeladoDeBrownie> (They serve similar functions of course)
13:35:45 <HeladoDeBrownie> s/similar/overlapping/
13:36:07 <mrenaud_> Couldn't you also just use do { doStuff; return 0 }?
13:36:11 <HeladoDeBrownie> You sure could
13:36:23 <Eduard_Munteanu> Yep, but Applicative style might be nicer.
13:36:37 <Eduard_Munteanu> It often is for parsers.
13:36:46 <Fuuzetsu> isn't <$ for Functor
13:36:56 <HeladoDeBrownie> It's a matter of taste, and sometimes of functionality – Not all types that can take advantage of (<$) or void are Monad
13:36:56 <mrenaud_> I feel like doStuff >> return 0 is easier to read
13:37:02 <mrenaud_> And yes <$ is Functor
13:37:32 <HeladoDeBrownie> So analogously you could also do fmap (const 0), but I think the equivalent with (<$) looks nicer, personally. You might disagree and you wouldn't be wrong.
13:37:40 <dfranke> Is there a Haskell function which allows efficient two's complement coercion between WordN and IntN types, without having to go through Int or Integer?
13:39:02 <mrenaud_> HeladoDeBrownie: Thinking about it, the do version or >> version require it to me a Monad which you may not have so I can see the use of <$
13:39:11 <HeladoDeBrownie> mrenaud_, yep
13:39:21 <Eduard_Munteanu> dfranke, there are primops for that if you use unboxed types, but I suspect going through Integer might be optimized away. You should check the resulting Core code.
13:40:05 <Eduard_Munteanu> dfranke, e.g. compile with -ddump-simpl
13:40:34 <exio4> just ran 'unsafeCoerce (maxBound ∷ Word16) ∷ Word8' and it shows 65xxx in the REPL, how is this even possible? what did unsafeCoerce "overwrote"?
13:41:03 <dcoutts> dfranke: ghc optimises all the obvious uses of fromIntegral
13:41:41 <dcoutts> dfranke: ie just use fromIntegral
13:41:58 <monochrom> dfranke: if you use fromIntegral and turn on ghc -O, it generates "GHC.Prim.narrow16Int# (GHC.Prim.word2Int# x#)". (I'm testing Word16->Int16.) I think it's pretty good.
13:42:05 <merijn> exio4: Anything is possible with unsafeCoerce
13:42:15 <merijn> exio4: You're lucky it didn't segfault ghci
13:43:26 <monochrom> actually it may be even better to read the asm
13:43:31 <mrenaud_> Is there any metrics anywhere about how "good" a particular library on Hackage is? Like download count, rating, etc?
13:43:41 <geekosaur> exio4, most things are stored in machine words with a constructor word prepended, so it is indeed possible for Word16 and Word8 to be larger than their respective limits
13:43:44 <Zekka> mrenaud_: Download count is provided
13:43:50 <kqr> cabal is complaining that it can't find a module which is a member of a hidden package, perhaps I need to add <package> to my .cabal file... but I have done so already! does that sound familiar to anyone
13:43:53 <kqr> ?
13:44:04 <exio4> geekosaur: ah, that would explain it
13:44:12 <Zekka> mrenaud_: Look at the 'Downloads' header: https://hackage.haskell.org/package/vinyl
13:44:13 <dfranke> dcoutts: cool. thanks.
13:44:46 <int-e> exio4: in fact, data Word8 = W8# Word#
13:44:47 <phaskell> W8 Problem Commits - https://phabricator.haskell.org/W8
13:44:48 <exio4> merijn: I thought it would break something, actually, that is why I wondered what "could have happened" that worked
13:44:49 <mrenaud_> Zekka: Yes, that's true, I didn't mean to include that. But if there are several different libraries to perform something, how do you find out which one is better without having to use multilpe ones then decide?
13:44:51 <HeladoDeBrownie> Zekka, does that include installations that required that package specifically, or as used as dependencies as well?
13:45:03 <dcoutts> kqr: hidden package or hidden module?
13:45:04 <exio4> int-e: that explains it...
13:45:09 <Zekka> HeladoDeBrownie: I think it includes downloads as a dependency but I'm not sure
13:45:17 <mrenaud_> Zekka: Obviously if something has several orders of magnitude more downloads you can probably assume it is better :P
13:45:21 <Zekka> mrenaud_: I can't recommend more than just consulting the blogosphere
13:45:38 <kqr> dcoutts, hidden package was what it said
13:45:42 <mrenaud_> Zekka: Fair enough
13:45:42 <HeladoDeBrownie> mrenaud_, I'm not so sure that's the case, in view of the question I just asked
13:45:47 <kqr> dcoutts, but i'm thinking maybe it is in the wrong build-depends
13:46:07 <dcoutts> kqr: it needs to be in the build-depends for the component that uses it
13:46:18 <kqr> yeah, I think that was my problem... testing now!
13:46:22 <mrenaud_> HeladoDeBrownie: That is true, a rating system on Hackage would be nice
13:46:25 <HeladoDeBrownie> mrenaud_, you can use it as a guideline, maybe, but there's not really a good substitute for trying it out to see if you like it.
13:46:36 <merijn> dcoutts: So, I've been thinking about your earlier answer that header files that should be packaged by sdist should go into "install-includes", but it seems sloppy to install header files which are only used by my package internally to compile. Should those go into extra-source-files instead?
13:47:19 <merijn> dcoutts: Additionally, I'm not sure I see the point of the "includes" field if it specifies both local and system headers and doesn't package anything. Why should unpackaged includes need to be listed by cabal?
13:47:26 <dcoutts> merijn: yes, install-includes is only appropriate for headers that the packages using yours need (e.g. if you're exporting a C api)
13:47:49 <dcoutts> merijn: in times past it was essential to install all C headers because other packages needed them to compile at all
13:48:06 <dcoutts> merijn: they're dependencies like any other
13:48:43 <dcoutts> merijn: cabal and package managers should know about C lib deps, including header files.
13:49:45 <dcoutts> merijn: so historically, includes is for system headers, and install-includes is for local, back when installing them was compulsory. Now there's a third category of local but not installed.
13:50:10 <merijn> dcoutts: Which go into? extra-source-files?
13:50:17 <dcoutts> merijn: and includes
13:50:26 <merijn> ok
13:50:57 <dcoutts> merijn: as a bonus, cabal will check that your include files work, e.g. if they
13:51:04 <dcoutts> if the #include things
14:00:01 <mrenaud_> let f x = [x, -x]
14:00:11 <mrenaud_> Oops, this isn't GHCi :P
14:01:26 <Fuuzetsu> @pl \x -> [x, -x]
14:01:27 <lambdabot> (line 1, column 11):
14:01:27 <lambdabot> unexpected "-"
14:01:27 <lambdabot> expecting expression
14:01:38 <Fuuzetsu> @pl f x = [x, (-x)]
14:01:38 <lambdabot> f = ap (:) (return . negate)
14:01:55 <madjestic> Cale: thank you for explanations above.  I missed a few pictures, but overall it was clear.  Can you recommend a few books on the topic?
14:02:20 <Cale> madjestic: I would recommend starting with Awodey's Category Theory
14:03:02 <gregnwosu> test
14:03:34 <madjestic> Cale: got that one already.  I am still not sure if I am prepared enough.  But thanks, good to know that I've got the right literature
14:04:01 <gregnwosu> Cale: sorry here is my cabal error,  http://lpaste.net/113235
14:04:07 <Cale> Well, try it out and see where you get :)
14:04:10 <gregnwosu> im actually using linux
14:04:45 <Cale> gregnwosu: Oh, this is on ARM
14:05:07 <gregnwosu> Cale: yeah
14:05:53 <gregnwosu> Cale: I know kinda all bets are off on ARM but i love hacking on my chromebook, its so....convienient
14:06:06 <Welkin> not all chromebooks are ARM
14:06:10 <Cale> I'd probably just google the "failed to map segment from shared object: Operation not permitted" and see if that turns up anything useful
14:06:28 <Welkin> if you want a lightweight laptop with great battery life, use a macbook air
14:06:53 <gregnwosu> Welkin: just costs about 10x the price
14:06:59 <Fuuzetsu> and comes with terrible OS
14:07:04 <Welkin> of course, but it will last longer too
14:07:08 <Cale> I somewhat shamefully don't really know anything about Haskell on ARM, despite working for a couple years or something on a game that was targetted for iPhones. :)
14:07:16 <Welkin> I used to dislike osx, but it's not bad
14:07:20 <Welkin> I actually like some features
14:07:24 <Welkin> but I do miss linux
14:07:30 <Fuuzetsu> must be the first time I hear someone saying ‘some Apple product X will last longer!’
14:07:45 <gregnwosu> Cale: its largely like haskell anywhere else, only it sometimes doesnt work :-(
14:07:49 <joelteon> that's the *first* time you've heard that?
14:08:40 <gregnwosu> Cale:  thanks for advice, looking
14:08:42 <Fuuzetsu> sure
14:09:11 <n4x> I didn't see any kind of real thing that shows in a "same usage" how apple hardware lasts longer
14:09:31 <n4x> the only stuff that I saw, was a 1000EUR laptop vs 300EUR laptop
14:11:09 <Welkin> laptops have definitely become lower quality in every way over the years
14:11:26 <Welkin> the most rugged, highest quality notebook I had was a Vaio from 2000
14:12:36 <Welkin> my newer vaio has construction issues and a poor screen
14:13:01 <Welkin> unless you spring for the really expensive ones
14:13:10 <mrenaud_> I have a monad question
14:13:54 <Welkin> vaio was sold off recently, so we probably won't see any more outside of Japan in the next couple years
14:14:35 <Welkin> mrenaud_: just ask
14:15:00 <mrenaud_> If I'm working in a monad and at some point want to perform some operation on the monad as a whole, then continue doing more monad operations, what's the easiest way to do this? Concrete example coming
14:15:47 <mrenaud_> Say I'm working in the list monad [1,2,3] >>= f >>= g, and then I want to say remove duplicates from the list with nub, then take the resulting list and >>= h
14:15:57 <madjestic> would it be very wrong to say that "OO programming ~ Group Theory; FP ~ Category Theory"?
14:17:03 <monochrom> nub ([1,2,3] >>= f >>= g) >>= h
14:18:19 <mrenaud_> monochrom: Any way to put the call to nub inline? [1,2,3] >>= f >>= *<****>*>$> nub >>= h
14:18:27 <vanila> madjestic, there's no group theory in there as far as I know
14:18:52 <monochrom> no, and it makes a lot of sense to put the nub outside, not inside
14:19:02 <mrenaud_> monochrom: Fair enough
14:19:25 <mrenaud_> I guess that makes it more explicit that you aren't operating in the monad anymore
14:19:48 <madjestic> vanila: what do you mean?
14:19:56 <Welkin> mrenaud_: go for the simplest approach
14:20:00 <Welkin> and the one that looks cleaner
14:20:05 <merijn> madjestic: Also, I don't think there's any more relation between FP and Category Theory then there is between, say, OO and Category Theory or car-driving and Category Theory
14:20:13 <monochrom> I would use this wording: more explicit about when you're doing a global thing vs a local thing
14:20:15 <Welkin> avoid messy looking code and you'll avoid problems like that
14:20:22 <vanila> madjestic, group theory isn't related to OO
14:20:31 <merijn> madjestic: Category Theory is pretty broad, and thus applicable to a lot, but not all that useful when it comes to FP, imo
14:20:54 <merijn> I'm still confused where this current "zomg! Must learn Category Theory to understand FP!" comes from
14:21:05 <merijn> (I say this as someone trying to learn Category Theory :) )
14:21:20 <merijn> If you wanna understand FP, study lambda calculus and type theory instead
14:21:27 <madjestic> merijn: well, the vocabulary seems to point to CT, hence people mention it
14:21:30 <merijn> Significantly simpler and a billion times more applicable
14:22:17 <monochrom> it is analogous to: when later you use IO and try to catch exceptions, it's going to be "try (xxx >>= f >>= g) >>= h", the "try" is at the same position as "nub". and it is all good.
14:22:22 <merijn> madjestic: Well, monad, arrow and category are the only terms I can think off that are in common use
14:22:40 <merijn> madjestic: All of those only have a tangential link to their category counterparts
14:22:58 <absence> what about functor?
14:23:01 <madjestic> merijn: functors too
14:23:02 <merijn> oh, true
14:23:16 <merijn> But again, only tangentially related to it CT counterpart
14:23:18 <madjestic> and monoids
14:23:23 <merijn> monoids are algebra
14:23:37 <merijn> I wholly endorse studying algebra to get better at programming
14:23:37 <monochrom> you can use category theory to explain OO as well. there is a formalization of UML semantics using category theory.
14:23:53 <n4x> it looks like a bunch of nice abstract concepts, that is why people want to learn it I guess.. or at least that is me :P
14:23:54 <gregnwosu> my requirements for a laptop , screen large enough to program in, can run linux , scala, haskell, can browse internet play flash , good battery life , nice keyboard
14:24:11 <merijn> madjestic: Anyway, imo if you wanna study math to become a better programmer, focus on: algebra, type theory and lambda calculus
14:24:49 <merijn> madjestic: There's many more understandable intro books in those topics, they're far more directly applicable to programming and much closer to haskell's underlying basis than CT is or ever will be
14:25:12 <sinelaw> TAPL in particular is an eye-opener
14:25:24 <merijn> Core is basically a System F_omega inspired language, so studying the lambda cube is a good place to start
14:25:48 <madjestic> merijn: thanks, good points.  CT is anigmatic for me, that's what is bothering me.
14:26:18 <merijn> And TaPL is a very good book, especially if you're curious on how to actually implement type systems. It covers both explanation of typing, proofs of how to prove them sound and productive AND actual implementations of type checkers for said type systems
14:27:32 <sinelaw> when I'm done with TAPL i'll probably go right back and start over again
14:27:44 <madjestic> http://goo.gl/JS8jC2
14:27:47 <madjestic> this one?
14:27:54 <merijn> madjestic: Yeah
14:28:31 <merijn> madjestic: The code snippets are in ocaml, rather than haskell, but he only uses a small subset of the entire ocaml language and any beginner haskeller should be able to read the code with little to no effort
14:28:48 <kqr> what's the recommendation when it comes to getting somewhat recent versions of ghc and cabal-install on debian wheezy? i'd rather not compile them
14:29:18 <merijn> kqr: Binary packages on haskell.org, probably? Unless some debian user knows something better
14:29:47 <ReinH> madjestic: Also check out http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
14:30:23 <ReinH> A newer version is http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/ as well
14:32:45 <Welkin> well that is strange
14:32:54 * hackagebot Unique 0.1.0.1 - Provides with the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.1 (kapral)
14:33:06 <Welkin> when I installed haskell platform, cabal was not symlinked
14:34:48 <merijn> Welkin: Are you sure? Maybe your shell hasn't updated since the install
14:35:06 <merijn> Welkin: Try "hash -r" (if you're using bash)
14:36:04 <Welkin> I ran it using the full pathname
14:36:09 <Welkin> now everything works
14:37:54 <Welkin> although ghc is not symlinked
14:38:07 <Welkin> wait
14:38:09 <Welkin> no, it works
14:40:16 <isocliff> Basic question: is there some canonical way to install a package (lambdabot) in a sandbox, when all the required sub-libraries are in their own folders?
14:40:55 <isocliff> last time I just dumped the contents of the main package into the enclosing folder, and then "add-source"d on the other folders
14:41:20 <isocliff> But I figured there must be some better way, otherwise the folders wouldn't have been laid out that way in the first place
14:43:57 <alanoth> If anyone is willing, will you please take a look at https://ghc.haskell.org/trac/summer-of-code/ticket/1638
14:44:12 <alanoth> I want to know whether it's doable as a Google summer of code project
14:44:54 <merijn> Welkin: bash only checks for executables on startup, so if your shell was open before installing it won't see any of the binaries until you run "hash -r"
14:45:40 <alanoth> whois alanoth
14:45:44 <Welkin> ah, okay
14:50:19 <Welkin> my goal for the day is to get yesod installed without errors
14:51:05 <sivteck> use stackage then
14:51:38 <Clint> or apt-get install
14:52:29 <Welkin> I'll finally get to use the shakespearean template languages tonight
14:52:42 <vova> Hi all. I've uploaded the library to the hackage. But docs was not created using cabal sdist.
14:52:44 <Welkin> I wonder what it's like to write javascript in haskell
14:53:09 <vova> How to add the documentation?
14:53:17 <vova> Please assist
15:01:58 <madjestic> merijn: also, my interest in haskell is not only to be a programmer, but using it as a mathematical supplement. In which case CT tools in haskell context could become handy
15:02:41 <mrenaud_> I have a question about the space efficiency of the list monad. If I have something like x `elem` (someList >>= f >>= g >>= h) which causes the resulting list to be huge, how is this handled?
15:03:09 <merijn> mrenaud_: Depends on how you consume it
15:03:20 <mrenaud_> I would hope/assume that it would only generate one element at a time
15:03:24 <merijn> mrenaud_: If possible GHC will fuse it away into a streaming operation
15:03:35 <madjestic> ReinH: thanks
15:03:37 <mrenaud_> merijn: Could you elaborate?
15:03:59 <mrenaud_> And what situations would it not be able to stream it?
15:04:07 <merijn> mrenaud_: Will, if the there is no reference to the head of the list it can GC as the list is traversed, resulting in O(1) space
15:05:07 <mrenaud_> So my example with elem would be O(1) then?
15:05:09 <merijn> mrenaud_: But if you have another reference to the list somewhere, it can't GC the start until that reference goes away, so that will keep the list alive. The elem will traverse the list until it finds 'x', so that means there's whatever number of elements before 'x' being kept in memory
15:05:17 <merijn> mrenaud_: In space, yes
15:05:28 <merijn> mrenaud_: Although that depends on optimisation level, etc. too
15:05:50 <mrenaud_> merijn: Gotcha, and of course space. Thanks :)
15:06:00 <merijn> mrenaud_: I would assume it's O(1) and profile memory usage if you suspect a problem/wanna see what's going on
15:06:19 <mrenaud_> That's what I assumed would happen with optimization, just wanted to make sure
15:06:30 <merijn> mrenaud_: Additionally, if you plan to stream large data sets, look into the pipes/conduit libraries which are designed for stream manipulation
15:06:59 <merijn> I think pipes has a variation of ListT, although this may be overkill for whatever you're doing
15:07:48 <mrenaud_> I'm just playing around with stuff, don't have a concrete use at this point
15:07:56 <mrenaud_> I'll keep that in mind though :)
15:14:11 <benzrf> merijn: pipes' ListT is literally just producer but with the last type var the produced type instead of the return type
15:14:25 <benzrf> im told it works well!
15:16:56 <merijn> benzrf: I've only used pipes for IO streaming for now
15:22:01 <hexagoxel> isocliff: you can add-source ../foo, so no copying to enclosing folder necessary. but in general, i don't know of a better approach; i tend to write bash scripts to setup the add-sources.
15:23:12 <isocliff> thanks hexagoxel, that combined with "--sandbox-config-file=" has done the trick
15:23:37 <isocliff> now my problem is that installation was apparently successful, but the file doesn't seem to be anywhere....
15:24:10 <hexagoxel> what file? the lambdabot binary?
15:24:17 <isocliff> yeah
15:27:23 <hexagoxel> isocliff: somewhere in dist..
15:27:40 <isocliff> hmmmm, okay Ive found my binary, but its giving me a familiar error: Djinn and vixen seem to have problems
15:28:43 <isocliff> I figured before that it was because I forgot to install djin and a couple other things first,
15:29:11 <isocliff> but now I think ive done the install as best I can, but the packages still seem to be broken
15:30:14 <isocliff> i wonder if its looking for them in the wrong place
15:30:21 <Welkin> my computer went to sleep during a cabal install
15:30:51 <Welkin> it looked frozen so I broke out of the process with ctrl-C
15:31:05 <Welkin> I ran the install command again
15:31:09 <Welkin> will it work properly?
15:32:53 <hexagoxel> isocliff: let me try :D *sets up a fresh sandbox and begins the compiles*
15:33:01 * hackagebot yesod-auth-kerberos 1.4.2 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.4.2 (ArashRouhani)
15:33:16 <isocliff> oh great thanks for the help :)
15:33:23 <isocliff> now that I
15:33:46 <Welkin> either it is frozen again or texmath just takes ages to build...
15:33:53 <isocliff> Now it doesn't complain about djinn, only vixen "failed to load"
15:33:55 <hexagoxel> isocliff: btw even the --sandbox-config-file should not be necessary, strictly
15:34:14 <Intolerable> is there any way to transform a Pipe over a monad m to a Pipe over another monad n if i have a function (m a -> n a)?
15:35:01 <hexagoxel> Welkin: it should work; some packages do indeed take ages.
15:35:48 <isocliff> this actually looks promising for my issue... : https://github.com/mokus0/lambdabot/issues/81
15:36:07 <Intolerable> nvm, found Control.Monad.MFunctor.hoist
15:36:48 <hexagoxel> Welkin: you could add -v2 or something to see a bit more about the process
15:38:05 <Welkin> I thought it was verbose by default
15:38:20 <Welkin> oh, perhaps that is a setting in cabal.config
15:38:38 <isocliff> wow i think that mightve done it hexagoxel. Still want to see if it will work properly, but it now starts without issue...
15:39:12 <hexagoxel> Welkin: default is v1 i think
15:39:37 <Welkin> I'll have to change that setting again
15:39:56 <Welkin> the default should be verbose I feel
15:39:59 <Welkin> at least v2
15:40:08 <Welkin> otherwise it looks like it may have froze
15:40:18 <hexagoxel> well, it really is a lot of spam with v2
15:40:34 <Welkin> you don;t install packages too often though
15:40:50 <Welkin> but when you do, it's important to get feedback on if it is working properly
15:40:58 <Welkin> and if you encounter an error, what that error is
15:44:52 <batchm> I can't ever remember what evalState runState and execState mean without looking it up in docs.. is it just me or were the names picked arbitrary and could have been shuffled without anyone complaining?
15:46:01 <sbrg> @type evalState
15:46:02 <lambdabot> State s a -> s -> a
15:46:09 <vanila> batchm, haha every single time I use them i get the wrong one
15:46:09 <sbrg> @type execState
15:46:10 <lambdabot> State s a -> s -> s
15:46:17 <vanila> youre so right
15:46:22 <sbrg> batchm: it's the same thing here, really, tbh
15:46:36 <sbrg> I'm not sure what the mnemonic is supposed to be
15:46:57 <benzrf> :t evalState
15:46:58 <lambdabot> State s a -> s -> a
15:47:01 <sbrg> I feel "evaluating state" can easily make one think "it returns the final state"
15:47:02 <benzrf> co  o l
15:47:12 <sbrg> which it doesn't
15:47:12 <benzrf> sbrg: it makes sense to me
15:47:25 <benzrf> sbrg: execState executes it and you get the "side effects"
15:47:30 <benzrf> evalState evaluates the final result
15:47:37 <sbrg> hmm
15:47:39 <benzrf> exec makes me think of fx, eval makes me think of result
15:47:42 <sbrg> perhaps one can think of it like that, yeah
15:47:52 <sbrg> I guess I can probably make that one stick, thanks
15:47:53 <indiagreen> eval = get monadic result; run = unwrap the newtype wrapper; exec is what's left
15:47:57 <benzrf> np
15:48:29 <Welkin> what is the difference between yesod and yesod-bin?
15:48:36 <Welkin> which do I install>
15:48:36 <Welkin> ?
15:48:40 <benzrf> Welkin: yesod is the lib
15:48:41 <hexagoxel> runFoo exists for other Foos, too (runMaybeT, runST). but eval/exec..
15:48:43 <benzrf> yesod-bin is the dev tool
15:48:59 <Welkin> so yesod is a dependency of yesod-bin?
15:49:05 <benzrf> probably
15:49:32 <Welkin> it's not
15:49:33 <bitemyapp> they used to have yesod-platform which installed everything but I think they phased it out.
15:49:50 <Welkin> so what do I install if I want to build website using yesod?
15:50:21 <phaazon> hm
15:50:42 <johnw> see http://www.yesodweb.com/page/quickstart
15:50:44 <Welkin> actually, which framework is best if I want something like Django
15:50:47 <phaazon> I noticed ghc translates numeric numbers into nominal number
15:50:54 <Welkin> with a built-in ORM, user account system, etc
15:50:57 <phaazon> when talking about function argument
15:51:06 <phaazon> I wonder what happens when it can’t do that anymore
15:51:17 <johnw> according to that webpage, the top package is now yesod-bin
15:51:55 <Welkin> johnw: I wish there was a date on that article so I know how recent the information is
15:52:31 <johnw> given how heavily it pushes FPHC and stackage, I'd say recent
15:52:53 <Welkin> I don't even know what stackage is
15:53:16 <johnw> it's their version of hackage, with vetted packages
15:53:36 <johnw> can give you a more stable deployment target, at the expense of older libraries (which can be a bonus)
15:53:47 <Welkin> is yesod associated with fp complete?
15:53:52 <Welkin> or just snoyman?
15:53:57 <johnw> not explicitly, but the author is their technical lead
15:54:06 <phaazon> oh
15:54:13 <phaazon> it stops at seventh
15:54:18 <phaazon> it doesn’t know seventh :D
15:54:50 <phaazon> I wonder how lambdabot handles that as well
15:55:21 <phaazon> @let yuk :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int; yuk = undefined
15:55:23 <lambdabot>  Defined.
15:55:40 <phaazon> > yuk 0 0 0 0 0 "foo"
15:55:41 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
15:55:41 <lambdabot>              with actual type ‘[GHC.Types.Char]’
15:55:55 <phaazon> oh it doesn’t show the remaining lines :(
15:56:19 <Dragon-ball> http://tinyurl.com/ogzbb82 Buy Dvd Movies Here
15:56:23 <phaazon> well, it knows sixth, but doesn’t know 7th
15:56:24 --- mode: ChanServ set +o geekosaur
15:56:33 <phaazon> that was the very interesting point of mine.
15:56:33 --- mode: geekosaur set +b *!*@h88-150-204-154.host.redstation.co.uk
15:56:33 --- kick: Dragon-ball was kicked by geekosaur (Dragon-ball)
15:56:41 --- mode: geekosaur set -o geekosaur
15:56:51 <isocliff> can anyone tell me what to do about lambdabot saying "mueval-core: NotAllowed 'These modules have not been loaded:\nL\n'"
15:56:51 <phaazon> woah geekosaur
15:56:56 <phaazon> that was mean :D
15:57:03 <phaazon> who is Dragon-ball?
15:57:14 <isocliff> doesn't it have at least some modules loaded by default? The command was "> 2 + 2"
15:57:17 <phaazon> isocliff: maybe try a @load?
15:57:20 <geekosaur> look closely and you will see the spam they sent on entry
15:57:21 <phaazon> @import*
15:57:21 <lambdabot> Unknown command, try @list
15:57:21 <merijn> phaazon: He was linking spam
15:57:38 <phaazon> [6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~oh
15:57:41 <isocliff> like "@load Prelude" or something?
15:57:42 <phaazon> …
15:57:45 <phaazon> oh yeah, I saw
15:57:45 <Welkin> phaazon: probably a spam bot
15:57:57 <phaazon> isocliff: it’s import
15:58:02 <phaazon> @import Data.Bifunctor
15:58:02 <lambdabot> Unknown command, try @list
15:58:07 <phaazon> ok, it’s load.
15:58:07 <phaazon> :D
15:58:10 <benzrf> @let import Data.Bifunctor
15:58:12 <isocliff> haha okay
15:58:12 <lambdabot>  <no location info>:
15:58:13 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
15:58:17 <benzrf> tfw
15:58:20 <benzrf> :t bimpa
15:58:21 <isocliff> ill report back
15:58:21 <lambdabot>     Not in scope: ‘bimpa’
15:58:21 <lambdabot>     Perhaps you meant ‘bimap’ (imported from Control.Lens)
15:58:21 <benzrf> :t bimap
15:58:22 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
15:58:27 <benzrf> can has
15:58:34 <benzrf> :t System.IO.Unsafe.unsafePerformIO
15:58:35 <lambdabot> IO a -> a
15:58:41 <phaazon> :t extend
15:58:42 <lambdabot> Not in scope: ‘extend’
15:58:46 <phaazon> @load Control.Comonad
15:58:46 <lambdabot> Unknown command, try @list
15:58:57 <phaazon> @let import Control.Comonad
15:58:58 <lambdabot>  <no location info>:
15:58:58 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
15:59:00 <phaazon> :(
15:59:24 <phaazon> btw, we should change @let import
15:59:25 <phaazon> it’s ugly
15:59:37 <phaazon> @import would be more logic wouldn’t it?
15:59:37 <lambdabot> Unknown command, try @list
15:59:58 <Welkin> how many of you install everything in sandboxes rather than install certain packages globally?
16:00:05 <phaazon> I do
16:00:13 <Welkin> I just installed hakyll globally
16:00:18 <benzrf> phaazon: why change @let import
16:00:22 <Welkin> it has a *lot* of dependencies
16:00:27 <benzrf> @let is just for adding lines to L.hs
16:00:27 <lambdabot>  Parse failed: TemplateHaskell is not enabled
16:00:36 <phaazon> Welkin: I also tend to use shared sandboxes
16:03:04 * hackagebot Unique 0.1.0.2 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.2 (kapral)
16:05:24 <isocliff> @listmodules
16:05:24 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:05:34 <isocliff> @help base
16:05:34 <lambdabot> base is a module.
16:05:46 <isocliff> is base where all the standard stuff is?
16:06:38 <hexagoxel> Welkin: sandboxes for everything! i use https://github.com/lspitzner/cabal-exec-install
16:10:43 <isocliff> hexagoxel, have a star ;)
16:14:55 <isocliff> my lambdabot clearly knows a lot of stuff, even though it refuses to evaluate anything
16:15:37 <isocliff> maybe tomorrow I'll find someone who knows what to do
16:19:58 <hexagoxel> isocliff: star? lambdabot has its own virtual currency, karma :)
16:22:46 <isocliff> haha ;)
16:23:06 * hackagebot json-autotype 0.2.1.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.1.0 (MichalGajda)
16:23:24 <isocliff> @let karma4hex = (\x -> "Karma") [1..]
16:23:26 <lambdabot>  Defined.
16:23:37 <isocliff> take 8 karma4hex
16:23:57 <absence> > take 8 karma4hex
16:23:59 <lambdabot>  "Karma"
16:24:00 <isocliff> you get the idea
16:24:04 <hexagoxel> i think it is "hexagoxel++"
16:24:56 <isocliff> hexKarma = Successor hexKarma
16:25:42 <absence> :t karma4hex
16:25:43 <lambdabot> [Char]
16:27:03 <isocliff> im reminded of this cool thing I can do in idris. Im sure theres a haskell equivalent
16:27:41 <isocliff> Conat = codata CoNat | S Conat
16:27:48 <isocliff> infinity : Conat
16:27:53 <isocliff> infinity = S infinity
16:27:58 <benzrf> yes,
16:28:10 <benzrf> data Nat = Z | S Nat
16:28:12 <isocliff> its probably a mark of how unsophisticated I am that I find that so awesome
16:28:14 <benzrf> infinity = S infinity
16:29:01 <shlevy> What's the right way to specify a dependency on a (non-Haskell) program in by .cabal?
16:29:09 <trap_exit> how do I go from "m a" to "StateT s m a" , where "m" is monad ?
16:29:20 <trap_exit> Given "m" is a monad, how do I go from "m a" to "StateT s m a" ?
16:29:21 <johnw> lift usually
16:29:22 <benzrf> trap_exit: lift
16:29:30 <benzrf> :t lift
16:29:31 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:29:50 <shlevy> I'm writing a compiler with a C backend and in my tests want to call a c compiler
16:30:11 <trap_exit> @src lift
16:30:11 <lambdabot> Source not found. You type like i drive.
16:30:13 <trap_exit> where does lift come from?
16:30:32 <Welkin> Monad transformers?
16:30:36 <trap_exit> :t liftM
16:30:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:30:38 <trap_exit> :t lift
16:30:39 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:30:46 <johnw> Control.Monad.Trans.Control
16:30:48 <Eduard_Munteanu> trap_exit, that's a different lift
16:30:48 <johnw> or Class
16:30:49 <trap_exit> :t (lift id)
16:30:50 <lambdabot> MonadTrans t => t ((->) a) a
16:30:53 <trap_exit> :t (liftM id)
16:30:54 <lambdabot> Monad m => m r -> m r
16:31:04 <Eduard_Munteanu> trap_exit, it's unrelated to liftM
16:31:04 <johnw> liftM is equivalent to fmap for monads
16:31:10 <johnw> lift is something else entirely
16:31:25 <johnw> it's a higher-order "return"  for monad transformers
16:31:42 <merijn> return is higher-order return for monad transformers >.>
16:31:53 <trap_exit> by Control.Monad.Trans.Control, you mean Control.MOnad.Trans.Class , johnw ?
16:31:59 <merijn> Well, assuming the monad transformer results in a monad :p
16:32:02 <trap_exit> oh right, see I see 2nd line now
16:32:09 <trap_exit> okay; I got this working now; thanks :-)
16:32:11 <johnw> merijn: return in a monad transformer is a -> t m a
16:32:36 <johnw> merijn: lift is m a -> t m a, so it "returns" in the sense of forall x, m x --> t m x
16:32:47 <johnw> trap_exit: yeah
16:35:22 <hexagoxel> shlevy: it cannot be formally specified, as cabal only knows about cabal packages. there might be a way to add a test and appropriate output in Setup.hs or something, maybe.
16:35:44 <johnw> shlevy: what do you want cabal to do if it's not there?
16:35:53 <shlevy> johnw: Complain if you try to run tests
16:35:56 <johnw> if just "print an error", then you could use shake in a custom builder
16:36:18 <shlevy> hmm
16:36:27 <shlevy> I guess for now I'll just call cc in the tests
16:36:37 <shlevy> And if it fails hopefully it will be obvious why
16:38:08 * hackagebot scotty-binding-play 1.3 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.3 (YusukeNomura)
16:39:28 <shlevy> If my test suite depends on an executable from the same package, how do I specify that dependency and how do I find the path to the executable in my test code?
16:39:41 <joe9> Please correct me if my understanding is wrong: There is a difference between (>>=) behaves in a Cont monad vs other monads. For example, when f >>= (\x -> g x) >>= (\y -> h y) is correct in any other monad. Whereas in a cont monad, it is: f >>= (\x -> g x >>= (\y -> h y))
16:40:11 <johnw> thas should be wrong
16:40:20 <johnw> by the 4th monad law, they must be equivalent for any monad
16:41:10 <johnw> what makes you think that Cont is different?
16:41:38 <joe9> johnw: the rest of the computation seems to be one function that is fed as the second argument in the cont monad.
16:41:53 <joe9> johnw: Does the above line make sense?
16:42:26 <johnw> not entirely
16:43:09 * hackagebot entropy 0.3.4 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.4 (ThomasDuBuisson)
16:43:19 <johnw> I recommend using equational reasoning to prove their equivalence for Cont for yourself
16:43:53 <joe9> I think I should read f >>= (\x -> g x) >>= (\y -> h y) as : (>>=) f (\x -> (>>=) (g x) (\y -> h y))
16:47:31 <johnw> >>= is left-associative
16:48:18 <johnw> so, f >>= g >>= h is (f >>= g) >>= h, and must be re-associable to f >>= (\x -> g x >>= h)
16:48:23 <joe9> johnw: f >>= (\x -> g x) >>= (\y -> h y)  == (>>=) f (\x -> (>>=) (g x) (\y -> h y)) ?
16:48:24 <johnw> (per the 4th law)
16:48:36 <johnw> no
16:48:45 <johnw> wait, what do you mean by "==" there?
16:48:52 <johnw> equivalence or equality?
16:49:00 <joe9> equal
16:49:09 <johnw> no, they are not equal
16:49:11 <joe9> I meant.
16:49:16 <joe9> oh, ok.
16:49:18 <johnw> you wrote left-associating on the left, and right-asosciating on the right
16:49:34 <johnw> but they are required to be equivalent
16:49:39 <johnw> for all monads
16:51:47 <benzrf> join = fmap join
16:51:56 <benzrf> assoc!
16:51:59 <johnw> join is equivalent to fmap join :)
16:52:15 <johnw> actually, no
16:52:17 <johnw> that's not true at all
16:52:20 <benzrf> ?
16:52:27 <johnw> join . join = join . fmap join
16:52:32 <johnw> and yes, that one is equality, sorry
16:52:33 <benzrf> hmmmm
16:52:38 <benzrf> oooooooppppppppps
16:53:00 <benzrf> wait, though..
16:53:12 <benzrf> what would be a monad where join /= fmap join
16:53:32 <johnw> join can be applied to m (m a)
16:53:38 <johnw> fmap join can only be applied to m (m (m a))
16:53:38 <benzrf> oh yes
16:54:18 <benzrf> hmmmmmmmmmmmmm
16:54:29 <benzrf> will fmap join always bergmark join thoughtpolice
16:54:31 <benzrf> *be
16:56:31 <johnw> that associative thing above was equality too
16:57:53 <mietek> Failed to install lens-3.10.3
16:57:57 <mietek>        src/Control/Lens/Internal/Exception.hs:165:3:
16:57:58 <mietek>            ‘typeOf’ is not a (visible) method of class ‘Typeable’
16:58:24 <Welkin> well, I have spent the entire day and night installing software
16:58:52 <mietek> Why in the world...
16:59:09 <joe9> The free monad keeps cropping up. But, I do not understand it. Is there a simple explanation on what it is, please?
16:59:30 <joe9> Is the "free" monad really a big deal.
16:59:32 <joe9> ?
16:59:37 <Welkin> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:59:44 <Welkin> er
16:59:57 <Welkin> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:05:41 <shlevy> Are there any decent alternatives to cabal? It's possible I'm missing something, but there seems to be no way at all to write a cabal test suite that uses an executable built in the same project...
17:07:59 <mietek> shlevy: aha! I've run into that
17:08:02 <Welkin> yesod-bin is 335 MB
17:08:16 <Welkin> well, with all of its dependencies
17:08:23 <Welkin> that isn't all of them either...
17:08:37 <shlevy> mietek: Any solution besides shoving most of main into a library?
17:09:00 <ReinH> shlevy: you can just run ./dist/build/Foo/Foo
17:09:39 <shlevy> ReinH: what about the dependency?
17:09:45 <ReinH> shlevy: what dependency?
17:10:09 <shlevy> I want cabal test to rebuild the program if its sources have changed
17:10:16 <shlevy> I guess I can just do cabal build; cabal test for now
17:10:20 <ReinH> cabal test already does that
17:10:23 <shlevy> Ah OK
17:10:30 <ReinH> cabal test works by building the test as an executable and running it
17:10:38 <shlevy> No, I mean the program I'm testing
17:10:40 <shlevy> not the test program
17:10:42 <ReinH> it builds the test as an executable by building *all* executables
17:10:45 <shlevy> ah OK
17:10:51 <shlevy> Cool
17:11:15 <ReinH> so if you are running cabal test then all executables will be up-to-date before the test runs
17:11:15 <shlevy> Would be nice if cabal provided something akin the the Paths_ module for the dist dirs, but I'll go with hard-coding for now
17:11:20 <shlevy> thanks!
17:11:23 <ReinH> Sure
17:11:41 <ReinH> (We use this to run integration tests against some services by spinning them up and making HTTP requests)
17:11:50 <ReinH> So I'm quite sure it works :)
17:11:53 <shlevy> :)
17:12:15 <ReinH> Agree about programmatic access to executable paths
17:12:31 <shlevy> I guess cabal-install repo is the right place for this?
17:12:35 <shlevy> an issue about it, I mean
17:12:47 <ReinH> I guess so?
17:12:55 <ReinH> probably
17:14:24 <shlevy> ReinH: working directory within cabal test is the root of the project I assume?
17:14:51 <ReinH> I suppose it's relative to where you run `cabal test' from
17:15:04 <ReinH> So that's a bit brittle
17:15:12 <shlevy> mm
17:15:17 <ReinH> Although I have never run cabal test from anywhere other than a project's root
17:15:30 <shlevy> I guess it's 20% of the work to get 80% of what I want, for now
17:15:38 <shlevy> I'm just allergic to path assumptions :D
17:15:53 <ReinH> Understandable
17:16:07 <shlevy> https://github.com/haskell/cabal/issues/2183
17:19:47 <ReinH> Oh, optparse-applicative changed the way `argument` is handled in 0.11 and broke my script, but don't provide any examples of using the new version anywhere.
17:20:06 <ReinH> Thaaaanks
17:20:19 <ReinH> time to add an upper bound, I guess
17:21:30 <shlevy> Hmm now I'm wondering if there's a nice way for programs to tell the compiler "if someone calls foo assuming type signature bar, show them this upgrade path message"
17:21:46 <shlevy> erm
17:21:50 <shlevy> not if there is, but if there could be :)
17:26:21 <shlevy> hmm
17:26:42 <shlevy> Just got: " Could not find module ‘Distribution.Simple.Test.LibV09’" when trying to do cabal build after switching to detailed-0.9 test type
17:30:11 <Fuuzetsu> shlevy: Haddock test suite uses the built executable
17:31:13 <Fuuzetsu> shlevy: but the way it's done is that it executes run.lhs which looks into dist/…
17:31:18 <Fuuzetsu> probably not what you're after
17:31:52 <absence> if i have a monoid 'a', can i express "a <> a <> a <> a <> ... <> a" for some specified number of appends, without making a temporary list using replicate and mconcat?
17:32:02 <shlevy> Fuuzetsu: Yeah, that's what I'm doing for now anyway
17:33:44 <Fuuzetsu> :t fix (\f n -> if n == 0 then undefined else m <> f (n - 1))
17:33:45 <lambdabot> (Num a, Eq a) => a -> Expr
17:33:46 <bms1> absence: pow :: Monoid a => a -> Int -> a; pow x 0 = mempty; pow x n = x <> pow x (n - 1)
17:34:00 <Fuuzetsu> huh, where did it get the m from
17:34:02 <Fuuzetsu> oh, Expr
17:34:35 <Fuuzetsu> > fix (\f n -> if n == 0 then m else m <> f (n - 1)) 5
17:34:36 <lambdabot>  m <> m <> m <> m <> m <> m
17:35:03 <Fuuzetsu> should have probably been n == 1…
17:35:41 <absence> right, no library function for that :) thanks
17:36:22 <Fuuzetsu> did you measure that replicate and mconcat are slow?
17:36:29 <Fuuzetsu> GHC might just spirit them away
17:36:59 <absence> no i didn't, was just curious
17:38:15 * hackagebot ihaskell 0.4.3.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.4.3.0 (gibiansky)
17:42:08 <Welkin> how can I purge all of the packages installed locally by cabal?
17:42:37 <benzrf> delete the dir
17:42:46 <Welkin> they are still registered with ghc-pkg
17:42:47 <benzrf> also protip: install nix
17:42:56 <benzrf> Welkin: delete that too (⌐■_■)
17:43:05 <Welkin> cabal sandboxes are destroying me
17:43:10 <Welkin> it is too easy to fuck up
17:43:16 * hackagebot helm 0.7.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.7.0 (ZackCorr)
17:43:18 <shlevy> Welkin: nixos.org/nix ;)
17:43:21 <benzrf> > a <> x
17:43:22 <lambdabot>  Ambiguous occurrence ‘a’
17:43:22 <lambdabot>  It could refer to either ‘L.a’, defined at L.hs:157:1
17:43:22 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.a’,
17:43:22 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
17:43:22 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
17:43:24 <shlevy> Heh, benzrf got there first
17:43:28 <benzrf> > x <> y
17:43:29 <lambdabot>  x <> y
17:43:32 <benzrf> neat
17:43:38 <Welkin> cabal install inside a directory with no .cabal-sandbox installs it in my user space
17:43:41 <benzrf> install nix
17:43:43 <benzrf> oops
17:44:23 <hexagoxel> Welkin: because you did not require-sandbox: True in ~/.cabal/config
17:45:46 <absence> Fuuzetsu: for the record, fix was a lot slower than replicate/mconcat :)
17:46:02 <Welkin> hexagoxel: that option does nto exist
17:46:05 <Welkin> not*
17:46:28 <shlevy> Does haskell 98 provide any way to call an external program (a la system(3))?
17:47:43 <shlevy> Ah System.system :D
17:47:54 <hexagoxel> Welkin: uhm, what?
17:48:02 <Welkin> I don't see it in the config
17:48:15 <Fuuzetsu> absence: I never claimed otherwise ;)
17:48:31 <Fuuzetsu> hope you tested with -O2 and all that good stuff
17:49:40 <hexagoxel> Welkin: maybe you got an old version of cabal-install? it is present (but out-commented by default) here
17:52:13 <ReinH> Welkin: what version of cabal-install?
17:52:20 <Welkin> 1.20
17:52:24 <Welkin> but I installed it over 1.18
17:52:32 <Welkin> not sure if it is using the same config file
17:52:37 <Welkin> in ~/.cabal/config
17:52:40 <ReinH> it probably didn't update your config file
17:52:53 <ReinH> writing over files on your behalf would probably not be good behavior
17:53:07 <Welkin> how do I fix that?
17:53:32 <Welkin> also, I want to nuke all my user-installed packages
17:54:38 <MOZGIII> hello, plz help! type AIData = (Fractional a, Integral b) => [([a], b)]   -- what am I doing wrong here?
17:55:32 <benzrf> MOZGIII: you arent enabling rank2types, thats what
17:55:51 <benzrf> MOZGIII: why not just settle on a specific fractional and integral ?
17:55:58 <geekosaur> mostly that a and b won't unify with anything else so that won't do anything like what you intended, unless you indeed intended a higher ranked type
17:56:00 <n4x> you can't have that kind of list, if you want a list like that, use "type AIData a b = [([a], b)]" and move the constraint to a function?
17:56:12 <benzrf> n4x: yes u can
17:56:16 <benzrf> u just need extns
17:56:32 <n4x> I thought you need to wrap it; didn't know it worked with 'type'
17:56:41 <benzrf> n4x: oh, maybe it doesnt :|
17:56:47 <benzrf> @let type AIData = (Fractional a, Integral b) => [([a], b)]
17:56:49 <lambdabot>  Defined.
17:56:56 <benzrf> > [(3, 4)] :: AIData
17:56:57 <lambdabot>  Could not deduce (GHC.Num.Num [a1]) arising from the literal ‘3’
17:56:57 <lambdabot>  from the context (GHC.Real.Integral b, GHC.Real.Fractional a)
17:56:57 <lambdabot>    bound by the inferred type of
17:56:57 <lambdabot>             it :: (GHC.Real.Integral b, GHC.Real.Fractional a) => [([a], b)]
17:56:57 <lambdabot>    at Top level
17:57:03 <benzrf> > [([3], 4)] :: AIData
17:57:05 <lambdabot>  [([3.0],4)]
17:57:08 <benzrf> cool
17:57:12 <benzrf> > [([3], 4 :: Int)] :: AIData
17:57:14 <lambdabot>  Could not deduce (b1 ~ GHC.Types.Int)
17:57:14 <lambdabot>  from the context (GHC.Real.Integral b, GHC.Real.Fractional a)
17:57:14 <lambdabot>    bound by the inferred type of
17:57:14 <lambdabot>             it :: (GHC.Real.Integral b, GHC.Real.Fractional a) => [([a], b)]
17:57:14 <lambdabot>    at Top level
17:57:18 <benzrf> aha, and here we have the issue
17:57:23 <benzrf> forced to be polymorphic ;-;;
17:57:38 <benzrf> u were right geekosaur
17:57:42 <MOZGIII> eeh
17:57:42 <benzrf> i failed to heed your warnin
17:57:56 <Welkin> well
17:58:08 <Welkin> something is wrong with this setup
17:58:08 <Welkin> Yesod devel server. Press ENTER to quit
17:58:09 <Welkin> cabal: Cannot find the program 'ghc'. User-specified path 'yesod-ghc-wrapper'
17:59:22 <Welkin> these yesod docs are confusing as well, as though I am supposed to create a sandbox inside a sandbox and install everything twice?
17:59:26 <MOZGIII> does this mean that by writing that I told that I want to use the same (sub)lists in all tuples?
18:00:10 <MOZGIII> oh
18:00:16 <benzrf> MOZGIII: "(Fractional a, Integral b) => [([a], b)]" is short for "forall a b. (Fractional a, Integral b) => [([a], b)]"
18:00:28 <benzrf> MOZGIII: in other words, a value of this type must be polymorphic
18:00:51 <benzrf> so you can't unify that type with something that contains, e.g., an int
18:00:57 <benzrf> *Int
18:03:55 <MOZGIII> why is that? is it because of tuples, or lists inside the tuples? or just because there are two fixed types (both a and b)? I'm just learning and I can't figure it out yet
18:04:55 <geekosaur> it's because type implicitly forall-s things, so the types are only known inside the `type` declaration. from outside all that is known is that the values are polymorphic
18:05:21 <geekosaur> this happens even without the constraint except then it knows *nothing* about the types, so they'll never unify with anything
18:05:48 <geekosaur> basically a and b are local variables
18:06:07 <MOZGIII> oh, now I see
18:06:54 <MOZGIII> so, do I really want this? type AIData = [([a], b)]
18:07:27 <MOZGIII> I tried it before, but it did't work
18:07:33 <geekosaur> [27 01:07] <geekosaur> this happens even without the constraint except then it knows *nothing* about the types, so they'll never unify with anything
18:07:46 <geekosaur> what you want is for them to be parameters: type AIData a b = ...
18:08:23 <MOZGIII> oh, I see, the syntax... ok, thx
18:11:27 <MOZGIII> then I use it like this?  irises :: (AIData Fractional Integral) => a
18:12:19 <geekosaur> it's a type, not a constraint
18:12:30 <geekosaur> irises: AIData Fractional Integral
18:13:52 <geekosaur> I don't recall if constraints behave like data or like GADTs though; that is, a polymorphic thing might need to be   (Fractional a, Integral b) => AIData a b   instead of just   AIData a b
18:14:11 <geekosaur> I suspect tyou need the former, so you don't actually gain anything useful
18:14:29 <geekosaur> basically type aliases don't work very well for this kind of thing
18:14:47 <MOZGIII> I see
18:15:09 <MOZGIII> btw, how do I define a constant?
18:15:15 <jpchang> http://stackoverflow.com/questions/26579731/is-a-list-comprehension-or-a-sequential-filter-more-optimized
18:16:41 <geekosaur> um, everything is a constant :p    define a binding with no parameters and a monomorphic type (polymorphic constants are possible but don't quite behave like you are likely to imagine a "constant' behaving)
18:18:11 <jpchang> For a problem like Problem 1 on Project Euler, would a list comprehension with a union be more optimized than going through each item and modulo-ing(?)
18:19:17 <FireFly> what would "step through" mean?
18:19:54 <David> hey guys
18:19:57 <David> anyone run into this error?
18:19:57 <johnw> hi
18:20:06 <David> [1]    67033 illegal hardware instruction  cabal
18:20:06 <FireFly> I'd assume a list comprehension and a filter would compile to exactly the same thing, jpchang
18:20:07 <vanila> hi
18:20:16 <MOZGIII> :) True. Bit I mean numeric constant, I have this strange thing. I have "nu = 0.01" and I have an error on it: No instance for (Fractional [a0]) arising from the literal `0.01'
18:20:16 <MOZGIII>     Possible fix: add an instance declaration for (Fractional [a0]) ...
18:20:28 <jpchang> @FireFly, ok thank you
18:20:28 <lambdabot> Unknown command, try @list
18:20:35 <johnw> David: perhaps the binary was built on a newer Intel platform than the machine on which you're running the executable
18:20:48 <David> johnw: I built it myself with homebrew
18:20:58 <johnw> so, running it on the same machine as built it?
18:21:00 <FireFly> jpchang: why are you concerned about performance for something like that anyway? Your primary concern should be readability/maintainability
18:21:05 <David> yes
18:21:19 <johnw> David: run "gdb --args cabal ARGS", then "run", then "bt", and show me the backtrace
18:21:43 <David> johnw: oddly enough, just reinstalled cabal and it worked
18:21:45 <jpchang> @FireFly, I was just wondering.. Yeah I guess there isn't much practical use for that knowledge
18:21:45 <lambdabot> Unknown command, try @list
18:21:53 <johnw> David: that was easy :)
18:22:04 <David> indeed. sorry to bother you
18:22:08 <johnw> David: you could also have a bad RAM module in your machine
18:22:09 <David> rather odd error, though.
18:22:13 <johnw> David: I had that happen to me actually
18:22:29 <David> oooh, that would be extremely problematic
18:22:33 <johnw> a MacBook Pro developed a fault DIMM, and so executables would crash with odd errors like that every once in a while
18:22:39 <David> I don't want to swap the motherboard :/
18:22:58 <StoneToad> I have a function with type Int -> Int -> Foo and I want to make a wrapper that's type V2 Int -> Foo
18:22:58 <johnw> you can run memtest86, or if it's a Mac, the Apple Hardware Tets
18:23:20 <StoneToad> I feel like I'm missing something obvious with some kind of lifting, but I can't figure out what to do other then matching _x and _y
18:23:28 <David> I'll do the ahts
18:23:29 <David> thanks
18:25:55 <geekosaur> MOZGIII, so that would not be a problem with your constant, it would be a problem with where you used it. specifically it got typed as Num a => a, and got used where a list was expected
18:26:21 <geekosaur> so the compiler wants to call fromRational on it and produce a list
18:27:21 <messykid> any recomendation as for what to use to dump windows server PW hashes?
18:27:44 <geekosaur> (more correctly, because you used it where a list was wanted, it inferred the type it told you. sometimes Haskell's polymorphic literals produce unexpected types)
18:28:09 <geekosaur> messykid, not aware of anything in Haskell and you probably are in the wrong channel anyway
18:28:51 <messykid> ok,google failed me!
18:28:58 <messykid> lol, thanks. i'll try another channel
18:29:56 <MOZGIII> geekosaur, here's my code - https://gist.github.com/MOZGIII/0343adcdb7cbc3e92b13 - could you please check it out?
18:31:44 <geekosaur> I will note that your type for nu was wrong because Fractional is not a type. if you declare it properly (Fractional a => a) then ghc will give you a better error location
18:32:40 <geekosaur> also, you define sign... consider
18:32:43 <geekosaur> @index signum
18:32:43 <lambdabot> Prelude
18:33:25 <geekosaur> and I see a problem on line 40 which will infect random other operations
18:34:05 <geekosaur> on line 31 you have x n dataset = vals returning the list part of an AIData; on line 40 you multiply the result of x sn dataset by m
18:34:31 <codehero> anyone here using haskell on gentoo?
18:34:41 <geekosaur> which means at that point you have a Num instance on a list, and that's going to propagate and lead to lots of things being inferred as Num [a] => ...
18:34:45 <MOZGIII> wow, added Fractional a => a and it worked! (also removed that new Classisfication thing that messed up logic really)
18:35:50 <geekosaur> in particular, how that affected nu is that you are multiplying m by that list produced by x sn dataset, and then multiplying nu by that same m
18:36:08 <geekosaur> er, no, you compute that m from nu, then multiply it by a list
18:36:16 <geekosaur> so nu has to be Num [a] => ...
18:36:27 <geekosaur> as must m, so it typechecks with x sn dataset
18:37:35 <MOZGIII> d and y are floats, x and w are lists
18:37:50 <geekosaur> yes, but you have on line 40: ... m * x sn dataset
18:38:21 <geekosaur> you are multiplying m by a list?
18:39:29 <MOZGIII> yeah, I see... I really want to map it multiplying by a scalar, true
18:42:45 <BMeph> StoneToad: Is there some f :: V2 Int -> (Int, Int)?
18:43:32 <MOZGIII> and then I want vector sum rather than sum of two lists... any syntax sugar I can get there?
18:44:02 <StoneToad> BMeph: ah yes, I found it, had to import Data.Foldable and used foldl1
18:44:29 <Welkin> how do I even view any of the documentation generated by cabal when it installs a new package?
18:44:32 <StoneToad> for somereason I tried fold (not foldr/foldl) initially
18:46:55 <BMeph> StoneToad: Okay, as long as you found the answer eventually, it's good. :)
18:47:23 <StoneToad> yea, felt pretty stupied when I found it though cause it was the first thing I though of, then failed to properly use :)
18:47:37 <StoneToad> well, 2nd thing I guess
18:57:19 <dfeuer> :t  fold
18:57:20 <lambdabot> (Monoid m, Foldable t) => t m -> m
18:57:23 <dfeuer> :t mold
18:57:24 <lambdabot>     Not in scope: ‘mold’
18:57:24 <lambdabot>     Perhaps you meant one of these:
18:57:24 <lambdabot>       ‘mod’ (imported from Prelude),
18:58:23 <dfeuer> So ... fold is just mconcat generalized?
18:58:39 <jle`> yus
19:17:03 <MOZGIII> geekosaur, thx for your help, I'll go now
19:17:13 <MOZGIII> thx everyone
19:23:08 <adfadsffdfaffds> @pl transformLine original = transformMatch original $ matchAgainstUrlRegex original
19:23:08 <lambdabot> transformLine = ap transformMatch matchAgainstUrlRegex
19:23:44 <vanila> could be written transformMatch <$> matchAgainstURL
19:48:44 <Hijiri> Is there a Monoid instance for Monad m => a -> m ()?
19:49:03 <Hijiri> or Applicative t => a -> t ()
19:49:21 <benzrf> probly not
19:49:40 <Hijiri> would it be a significantly bad thing if I wrote an orphan instance for it?
19:49:52 <Hijiri> I'm refactoring some code and I don't want to insert newtypes everywhere this late
19:50:04 <benzrf> @let Pointwise f m = Pointwise {unPointwise :: f m}
19:50:04 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
19:50:08 <benzrf> oop
19:50:12 <benzrf> @let newtype Pointwise f m = Pointwise {unPointwise :: f m}
19:50:14 <lambdabot>  Defined.
19:51:08 <benzrf> @let instance (Applicative f, Monoid m) => Monoid (Pointwise f m) where mempty = pure mempty; mappend = liftA2 mappend;
19:51:09 <lambdabot>  .L.hs:201:18:
19:51:10 <lambdabot>      Could not deduce (Applicative (Pointwise f))
19:51:10 <lambdabot>        arising from a use of ‘pure’
19:51:10 <lambdabot>      from the context (Applicative f, Monoid m)
19:51:10 <lambdabot>        bound by the instance declaration at .L.hs:200:10-60
19:51:14 <benzrf> whut
19:51:16 <benzrf> oh
19:51:43 <benzrf> @let instance (Applicative f, Monoid m) => Monoid (Pointwise f m) where mempty = Pointwise (pure mempty); mappend (Pointwise x) (Pointwise y) = Pointwise (liftA2 mappend x y)
19:51:44 <lambdabot>  Defined.
19:52:05 <benzrf> > Pointwise ("cool", ()) <> Pointwise ("ok", ())
19:52:07 <lambdabot>  No instance for (GHC.Show.Show
19:52:07 <lambdabot>                     (L.Pointwise ((,) [GHC.Types.Char]) ()))
19:52:07 <lambdabot>    arising from a use of ‘M168478457808205406231473.show_M1684784578082054062...
19:52:13 <benzrf> oh, no show instance
19:52:20 <benzrf> > unPointwise $ Pointwise ("cool", ()) <> Pointwise ("ok", ())
19:52:22 <lambdabot>  ("coolok",())
19:52:28 <benzrf> since () is a monoid
19:52:37 <benzrf> the trivial monoid, infact
19:53:40 <benzrf> Sgeo: no triangles!!
19:54:15 <benzrf> oh wait
19:54:16 <benzrf> oh no
19:54:25 <benzrf> unitor diagrams for monoids form triangles
19:54:26 <benzrf> ;-;
19:54:26 <Hijiri> unPointwise (Pointwise show <> Pointwise show) 5
19:54:32 <Hijiri> > unPointwise (Pointwise show <> Pointwise show) 5
19:54:33 <lambdabot>  "55"
19:54:38 <benzrf> heh
19:54:51 <benzrf> Hijiri: functions already have a pointwise instance
19:54:57 <benzrf> > (show <> show) 5
19:54:57 <Hijiri> oh yeah
19:54:58 <lambdabot>  "55"
19:55:04 <Hijiri> I guess maybe I should try using that
19:55:14 <Hijiri> but I don't know if I"ll be able to fit it into the code easily
19:55:25 <Hijiri> well
19:55:36 <Hijiri> If there's a Monoid instance for just Monad m => m ()
19:55:43 <Sgeo> Apparently someone else registered that nickname
19:55:48 <benzrf> fun fact i forgot about: 2-arg functions work too
19:56:08 <benzrf> > (replicate <> replicate) 3 'z'
19:56:09 <lambdabot>  "zzzzzz"
19:56:20 <benzrf> because they get pointwise combined
19:56:28 <benzrf> but their results are in turn 1 arg functions that get pointwise combined
19:57:37 <Welkin> @info (<>)
19:57:37 <lambdabot> (<>)
19:57:42 <Welkin> :t (<>)
19:57:44 <lambdabot> Monoid m => m -> m -> m
19:57:52 <joelteon> that's not a helpful @info call
19:58:04 <benzrf> info gets "corrected" to undo
19:58:06 <Welkin> lambdabot is never helpful with @info
19:58:09 <benzrf> @info do x <- y; z
19:58:09 <lambdabot> y >>= \ x -> z
19:59:08 <n4x> @info do x ← s; s x
19:59:08 <lambdabot> <unknown>.hs: 1: 7:Illegal character ''\134''
19:59:14 <n4x> it doesn't work with ← :(
19:59:35 <benzrf> tsk
20:00:23 <benzrf> anwyay i gotta to sleep
20:00:30 <benzrf> so
20:00:31 <benzrf> bye
20:00:34 <trap_exit> this early?
20:00:43 <trap_exit> aren't you normally up for another 5-6 hours?
20:00:51 <benzrf> trap_exit: .................. no
20:00:52 <trap_exit> (just based on when you answered my questions historically)
20:00:52 <benzrf> bye
20:00:56 <Hijiri> night
20:00:59 <trap_exit> oh, must have been someone else, sorry
20:01:01 <Hijiri> thanks for the help
20:01:41 <Welkin> trap_exit: it was probably him
20:02:06 <trap_exit> what? he lied to me?
20:03:14 <trap_exit> GHC.Geherics.Generic is like one of the greatest inventions ever
20:03:22 <trap_exit> what is there to dislike about it?
20:03:30 <joelteon> module name is pretty long
20:03:36 <joelteon> i'd prefer "import G"
20:03:44 <trap_exit> it's like a lisp user said: you haskellers -- you can't auto create things based on the data type, since it's not first class
20:03:50 <dfeuer> trap_exit, it's like reading line noise.
20:04:03 <trap_exit> and some haskell guy is like "not only can we do it, we can do it in a type safe way -- GHC.Generics.Generic"
20:04:18 <trap_exit> dfeuer: yeah, I like using it, I'm not sure I'd like creating it
20:04:52 <dfeuer> In the grand tradition of Lisp, everything looks about the same. In the grand tradition of Haskell, the identifiers have between one and two characters.
20:05:43 <Enzoray> I want to implement a function, given a x and a list xs, finds where x occurs in the list. Start position = 0. (FindIndex)
20:05:55 <Enzoray> Any clues?
20:05:59 <dfeuer> Enzoray, do iiiiiiit.
20:06:19 <dfeuer> Enzoray, here's my first clue: what do you want it to return if the list is empty?
20:06:40 <Enzoray> Nothing, error.
20:06:51 <dfeuer> You have to pick one. Nothing is a great choice.
20:06:56 <dfeuer> Write that line first.
20:07:27 <Enzoray> findIndex _ [] = Nothing
20:07:30 <Enzoray> Right?
20:07:33 <dfeuer> Yes.
20:07:49 <dfeuer> You're going to encounter a wee bit of a problem, but that's okay. You'll learn something from it :-)
20:08:07 <dfeuer> Try writing the case for when the list is not empty.
20:08:30 <dfeuer> [Don't try for too long, but try to get a sense of what's not working.]
20:09:24 <Enzoray> Erm... hints please.. :P
20:10:11 <dfeuer> Well, try writing    findIndex needle (x:xs) = ?
20:10:21 <dfeuer> What's the first step?
20:11:16 <dfeuer> You are on a needle hunt in a haystack, or a snipe hunt in the woods, or a wild goose chase, or maybe you SEEK THE HOLY GRAIL.
20:11:53 <dfeuer> Enzoray, say my name when you think of something; I won't be watching this window like a hawk.
20:12:23 <Enzoray> dfeuer, yeah.. This might take a while.. lol :P
20:12:26 <Welkin> are there any better resources for getting started with yesod?
20:12:30 <dfeuer> No.
20:12:37 <Welkin> the book is more like a reference than a tutorial
20:12:53 <Welkin> I just want to get started with the scaffolding site
20:13:23 <Oksana> yesod ? http://www.yesodweb.com/
20:13:33 <Welkin> I know about the site
20:13:37 <dfeuer> Enzoray, have you already seen how to write an `elem` function to see if something is in a list?
20:14:00 <Enzoray> No, not really.
20:14:23 <dfeuer> OK!
20:14:34 <dfeuer> So start with that. It's a little easier, and you'll work your way up.
20:15:00 <Enzoray> dfeuer, my task is to be able to find the x, like... ex.. FindIndex 3.. [1,2,3] -----> output 2
20:15:28 <dfeuer> Enzoray, that's okay. Start with a simpler version, and work your way up.
20:15:48 <mrenaud_> Reader monad question, how do you decide if a function should operate in the reader monad or if it should just take the value as an argument?
20:15:55 <dfeuer> Enzoray, write a function that takes a value and a list and just says True if the value is in the list and False otherwise.
20:16:12 <jle`> mrenaud_: Reader alone by itself is honestly of little practical use
20:16:34 <mrenaud_> Say RWS then
20:16:48 <jle`> if you have a lot of functions that all are a -> ..., then...maybe.  but that limit where it becomes practical is pretty high, imo
20:16:53 <jle`> mrenaud_: what do you mean?
20:17:00 <jle`> if you should do WS instead of RWS?
20:17:08 <Enzoray> checkMeOut :: Int -> [Int] -> Bool
20:17:19 <johnw> Reader is mainly useful because it guarantees that all the actions involved will see the same value, and that no one in-between a call sequence will substitute in a different value
20:17:21 <mrenaud_> jle`: Yes
20:17:26 <jle`> johnw: oh yeah that's neat.
20:17:32 <jle`> i never thought about that.
20:17:54 <johnw> yeah, Monads are great for 'managing context'
20:18:11 <johnw> so you can view the Reader monad as also being the "read-only Monad"
20:18:23 <jle`> you unconverted me from Cale's conversion
20:18:51 <Cale> What's this?
20:18:53 <mrenaud_> Simple example. I'm writing a packet filter and each rule can see the current packet, can write to a log, and can modify some shared state. Is that a good use case for RWS Packet Log World?
20:19:05 <Sgeo> dfeuer: now I'm wondering what the difficulty is... I'm seeing a need to do if needle == x then Just 0 else fmap (+1) $ findIndex needle xs
20:19:11 <johnw> mrenaud_: sounds like it
20:19:17 <Sgeo> But that's not a difficulty (I didn't try it), what am I missing?
20:19:26 <Sgeo> Well, it's a difficulty in that it's a bit ugly
20:19:29 <jle`> Cale: was it you who said that manual argument passing is almost always preferred over just plain Reader
20:20:15 <Enzoray> checkMeOut x a | x == a = True | otherwise = False
20:20:25 <Cale> Mostly over using ReaderT on something like IO
20:20:26 <dfeuer> Sgeo, that's not the solution we want, is it? Ugly *and* slow, and using fmap, which Enzoray probably doesn't know about yet?
20:20:57 <Enzoray> dfeuer, I'm a complete n00b at haskell. :P
20:21:10 <dfeuer> Enzoray, you're close, but that asks if x *equals* a. We want to see if x is an *element* of a.
20:21:12 <johnw> Cale: huh, ReaderT over IO is probably my most common use case...
20:21:13 <jle`> Cale: ah.  well.  you convinced me to always manually pass arguments.  but johnw brings up a point and i am considering changing sides.
20:21:20 <jle`> im sorry
20:21:23 <dfeuer> Enzoray, yeah, that's why I thought your initial task was ones step too high.
20:21:25 <johnw> I'm not sure there are "sides" here
20:21:30 <jle`> yes there is
20:21:32 <jle`> in my imaginary world
20:21:36 <johnw> just that types say something, and sometimes you want them to say what you mean
20:21:42 <dfeuer> Enzoray, you'll get there, today, you just can't jump it.
20:21:54 <Cale> hm?
20:21:58 <jle`> i like to insert drama into the interpretation of all of my life experiences
20:22:04 <johnw> hah
20:22:11 <Cale> ReaderT e m a says the same thing as e -> m a
20:22:37 <johnw> Cale: except that two e -> m a functions aren't as easy to compose as with >=>
20:22:41 <jle`> yes but there is a semantic difference :O
20:22:48 <Cale> The only difference is how the parameters get passed
20:22:49 <jle`> (or am i totally off here)
20:22:58 <johnw> jle`: you're not totally off
20:23:02 <johnw> the read-only angle still applies here
20:23:09 <Sgeo> dfeuer: :( how is it slow? And is the ugliness fixable just by using | needle == x for the then branch and a separate line for the else?
20:23:12 <jle`> ReaderT is like a type annotation for a special type of (->)
20:23:18 <jle`> with imbued meaning
20:23:38 <Sgeo> It risks stack overflow, ok
20:23:40 <johnw> you mean, it describes arrows in another category :)
20:23:55 <mrenaud_> Say you have a bunch of functions in isolation that aren't chained together, you could write the functions as either a -> WS Log State or of type RWS a Log State.
20:23:59 <johnw> a Kleisli category where every arrow has access to a common environment
20:24:06 <shlevy> >t str
20:24:09 <johnw> and importantly, the *same* environment
20:24:11 <Cale> Sure, if you're getting to use >=> a bunch and not have too many lifts, go for it
20:24:13 <dfeuer> Sgeo, risking stack overflow ==> lots of memory traffic. Not so good!
20:24:13 <shlevy> > :t str
20:24:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:24:19 <johnw> Cale: :)
20:24:27 <shlevy> :t str
20:24:28 <lambdabot> Not in scope: ‘str’
20:24:30 <shlevy> hmm
20:24:32 <Cale> But that's not what most people's code ends up looking like
20:24:35 <jle`> the idea is that ReaderT comes with a guaruntee that every composed function has the same input parameter
20:24:43 <jle`> just using a normal function arrow does not carry that guaruntee
20:25:00 <Cale> It just ends up looking like parameter passing except you write lift in the places where you wouldn't have passed along the parameter
20:25:04 <dfeuer> s/guaruntee/guarantee
20:25:14 <gamegoblin> I have a list of size N and a list of size N-1. I want to "zip" them such that 1,2,3 and 4,5 would yield 1,4,2,5,3. i.e. I want to insert the elements of list2 between the elements of list1. Anyone got an elegant way of doing this?
20:25:14 <jle`> ty
20:25:29 <johnw> Cale: indeed, monad transformers can be used gratuitously
20:25:39 <Cale> There are use cases for ReaderT
20:25:56 <Cale> But I think most of them I see are pretty questionable :)
20:26:02 <Cale> Similarly for StateT
20:26:25 <mrenaud_> From reading the convo I'm taking away that there is no best way, it depends on the use case. I think RWS is the best candidate for mine though
20:27:01 <johnw> Cale: I recently had dire need for StateT in a Coq project, where I needed complete control over the "locii of mutation"
20:27:12 <johnw> oh, not StateT, sorry
20:27:13 <johnw> just State
20:27:18 <dfeuer> Enzoray, any progress on that elem implementation?
20:27:40 <dfeuer> locii? Dost thou mean "loci"?
20:27:46 <johnw> oh, perhaps I do
20:27:47 <mrenaud_> Also, if I have a [RWS a b c d] do I use sequence to run all of them and get their results?
20:27:56 <dfeuer> locus/loci
20:27:58 <mrenaud_> I may have butchered the terminology there as well
20:28:01 <Enzoray> dfeuer, working on it.
20:28:29 <Cale> johnw: Just State I have no problem with. It's using StateT over IO which is a monad that has a lot of facilities for expressing statefulness already.
20:28:44 <johnw> Cale: that's a might fine point
20:28:46 <johnw> mighty*
20:29:23 <johnw> Cale: hey, how are you with algebraic signatures, of the universal sort?  (i.e., operations, arities and sorts)?
20:30:05 <Cale> I dunno? Ask your question?
20:30:24 <johnw> I just need a refresher on their semantics, since the concept is still a bit opaque to me
20:30:38 <johnw> pointer to good reading materials would be great
20:30:41 <johnw> my googling found few
20:30:58 <Enzoray> dfeuer, how do I typ 'elem' in the text editor? Which kind of ' should I use?
20:31:19 <Enzoray> Found it.
20:31:44 <dfeuer> Enzoray, you don't need to type that...
20:32:04 <dfeuer> Oh, you want to be fancy and write   x `elem` xs?  Yeah, no problem.
20:32:12 <jle`> mrenaud_: can you express what you want in types?
20:32:19 <jle`> as your question stands now, it's slightly ambiguous :)
20:32:51 <Enzoray> checkMeOut :: Int -> [Int] -> Bool
20:32:51 <Enzoray> checkMeOut x a = x `elem` a
20:32:59 <Enzoray> Am I cool now?
20:32:59 <Enzoray> :P
20:33:04 <jle`> thas cool
20:33:08 <Enzoray> YES!
20:33:09 <jle`> but
20:33:12 <Enzoray> I NAILED IT, I HAVE THE NEEDLE!
20:33:13 <jle`> what is the type of elem?
20:33:22 <jle`> when applied to an Int and a [Int] ?
20:33:24 <dfeuer> jle`, well, it looks like Javascript doesn't even distinguish properly between identifiers and values. o.O
20:33:32 <jle`> am i me
20:33:45 <Enzoray> Idk... It worked.. :P
20:33:49 <dfeuer> Enzoray, that is NOT what you are trying to do. You can't just use someone else's function.
20:34:08 <dfeuer> Write your own from scratch with pattern matching if you want to learn something here.
20:34:11 <Enzoray> I did create this by myself.
20:34:12 <mrenaud_> jle`: If I have a list of functions :: RWS Input Log World Bool, how would I execute all of them and get the updated state, log, and the list of Bool?
20:34:14 <Enzoray> I'm telling you.
20:34:26 <jle`> mrenaud_: what is the type of what you are trying to do
20:34:27 <dfeuer> Enzoray, what I'm saying is that `elem` isn't some kind of magic. Someone wrote that.
20:34:32 <jle`> [RWS Intput Log World Bool] -> ...?
20:34:36 <dfeuer> You can write one too.
20:34:41 <Enzoray> I just looked up 'elem' in the haskell-standard.
20:34:46 <Enzoray> Oh.. yeah.. That's true.
20:34:56 <dfeuer> And you will learn much more that way.
20:35:17 <Enzoray> Ok, erm. I'll try?..
20:35:24 <Enzoray> This is not going to end well.
20:35:29 <begriffs> If I have type A = A1 String | A2 Int, is there a way to convert a generic A value to Maybe String? So it would be Just if it had been an A1 or Nothing if it had been an A2.
20:35:56 <mrenaud_> jle`: Oh, [RWS Input Log World Bool] -> (Log, World, [Bool])
20:36:05 <dfeuer> Enzoray, start at the beginning.
20:36:15 <dfeuer> x `elem` [] = ?
20:36:25 <dfeuer> x `elem` (y : ys) = ?
20:37:01 <mrenaud_> jle`: Sorry, [RWS Input Log World Bool] -> Input -> Log -> World -> (Log, World, [Bool])
20:37:29 <Enzoray> error "invalid parameters"
20:37:45 <Enzoray> For the first one.
20:39:03 <dfeuer> Enzoray, it's not an error at all.
20:39:14 <johnw> Cale: nothing?
20:39:25 <Cale> johnw: Oh, sorry
20:39:32 <dfeuer> Enzoray, is 3 in [] ?
20:39:35 <Cale> johnw: I don't know many references for universal algebra
20:39:35 <Enzoray> It's an empty list? You can't do that? False.
20:39:38 <Enzoray> No, false.
20:39:48 <Cale> johnw: But Wikipedia has reasonable articles as I remember
20:39:49 <dfeuer> Correct,    x `elem` [] = False
20:39:58 <johnw> Cale: ok, I know one person, I just have to wait for our time to overlap
20:40:09 <dfeuer> OK, so now can you get started on the idea of   x `elem` (y : ys) = ?
20:40:31 <dfeuer> You don't need to figure it all out at once; just try to get a little piece of information.
20:40:41 <Enzoray> And the second one.. Hey wait a minute...! Doesn't that mean.. 1 out of 10, like.. How does that even make sence? (y:ys)
20:41:08 <Enzoray> It's been splitted, how can you tell?
20:41:35 <Enzoray> Perhaps.. if y == x?
20:41:42 <Enzoray> = True
20:41:52 <dfeuer> Enzoray, if you match  xs against (y:ys), then the first element of xs gets to be y, and the rest of xs gets to be ys.
20:42:34 <Enzoray> First of all, what does it mean?
20:42:38 <dfeuer> Enzoray, have you tried reading Learn You a Haskell for Great Good?
20:42:46 <Enzoray> Yeah.
20:42:56 <dfeuer> OK, so you started at the beginning?
20:43:00 <Enzoray> Yes.
20:43:12 <dfeuer> OK.
20:43:19 <dfeuer> So let me think a sec.
20:43:43 <dfeuer> Enzoray, can you join #haskell-beginners? We should take this there.
20:44:03 <Enzoray> dfeuer, course!
20:50:11 <dfeuer> There's an odd sort of symmetry to this output from @pl:   (getAny .) . foldMap . (Any .) . (==)
20:50:15 <dfeuer> er ..
20:50:29 <dfeuer> (getAny .) . foldMap . (Any .) . (==)
20:58:51 <jle`> mrenaud_: you want them to run sequentially, right?
20:59:01 <jle`> consider:
20:59:08 <jle`> :t sequence
20:59:09 <lambdabot> Monad m => [m a] -> m [a]
20:59:28 <jle`> sequence :: [RWS a b c d] -> RWS a b c [d]
20:59:45 <mrenaud_> That looks like exactly what I want
21:00:13 <jle`> when running a bunch of things in sequence, sequence is usually the way to go :)
21:00:19 <kloplop321> where m is RWS a b c with kind * -> *, right?
21:00:43 <jle`> for some types/Monad instances it actually runs them in "parallel", though, so the name might be a bit misleading. but yeah.
21:00:45 <jle`> kloplop321: yup
21:01:27 <jle`> actually i don't know what i meant by that comment anymore so please disregard it :)
21:01:58 <mrenaud_> So I would do runRWS (sequence [f,g,h]) input world?
21:02:10 <jle`> yeah
21:02:11 <jle`> well
21:02:17 <jle`> delay the run for as long as possible
21:02:22 <jle`> but if that's all you want at that point, then that works
21:02:54 <mrenaud_> Also, what is this "kind" stuff? I've read some stuff about it but I'm still slightly mystified :P
21:04:23 <jle`> it's more or less the "type" of the types.  all types that can have values are of kind *
21:04:32 <jle`> like Int, Bool ...
21:04:38 <jle`> things like Maybe?
21:04:40 <mrenaud_> But a function would have kind **?
21:04:42 <jle`> they take a *
21:04:46 <jle`> like Int
21:04:50 <jle`> and return a Maybe Int
21:04:55 <jle`> which is indeed a thing that can have a value.
21:05:07 <jle`> you can't have something of type Maybe, but if you give it a * like Int, you have Maybe Int.  which can have a value.
21:05:11 <jle`> so Maybe :: * -> *
21:05:24 <jle`> "takes a *, and the result is *, something that can have a value of that type"
21:06:35 <jle`> so like, for the type of fmap
21:06:37 <jle`> :t fmap
21:06:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:06:45 <jle`> the `f` can't be something like Int
21:06:52 <jle`> because (Int a) doesn't make any sense
21:07:03 <jle`> there is no value of type (Int a)...it's meaningless
21:07:07 <jle`> `f` can't be `Either`, as well.
21:07:14 <mrenaud_> So all functors are of kind * -> *
21:07:17 <jle`> there is no such thing with type `Either a`.  that doesn't even make sense
21:07:24 <jle`> yeah.  `f` has to be something like Maybe
21:07:30 <jle`> which takes a *, and returns a *
21:07:35 <jle`> :t sequence
21:07:36 <lambdabot> Monad m => [m a] -> m [a]
21:07:41 <jle`> m here has to be * -> *
21:07:56 <jle`> RWS :: * -> * -> * -> * -> *
21:08:04 <jle`> RWS a :: * -> * -> * -> *
21:08:07 <jle`> RWS a b c :: * -> *
21:08:09 <mrenaud_> Gotcha, makes perfect sense
21:08:11 <jle`> that fits the right "shape"
21:08:14 <jle`> to go into the type of sequence
21:08:22 <jle`> [RWS a] -> RWS [a] ...?  makes no sense.
21:09:13 <jle`> we call something like that a "kind error"
21:10:15 <mrenaud_> I've definitely encountered that error message before :P What are data kinds then? I've had to use the extension before but didn't understand exactly what was going on
21:14:11 <Total_1mmersion> Any idea why my thread activity looks like this? http://i.imgur.com/5w8loHu.png
21:14:15 <Total_1mmersion> Here is my program: http://lpaste.net/113247
21:15:11 <Total_1mmersion> I would like to know exactly what the 10 sections of activity just before each HTTP request is doing.
21:16:42 <carter> Total_1mmersion: the gaps are probably GCs?
21:16:56 <carter> ohh
21:17:03 <Total_1mmersion> carter, nope, GC is orange
21:17:07 <carter> hrm
21:17:42 <carter>  policy    = exponentialBackoff (10 ^ (6 :: Integer)) ?
21:18:03 <carter> could you somehow be oversleeping?
21:18:18 <Total_1mmersion> I don't think that is actually retrying. I'll remove that and see if it makes a difference.
21:18:27 <carter> Total_1mmersion: did you build the app wiht --threaded ?
21:18:33 <carter> or not?
21:19:05 <Total_1mmersion> It looks nearly the same after removing retries.
21:19:12 <Total_1mmersion> No I didn't, is that a GHC option?
21:19:26 <carter> -threaded
21:19:27 <carter> yeah
21:19:29 <solatis> yes
21:19:34 <carter> you might want it
21:19:53 <carter> the lack of activity spots could be long running c calls?
21:20:18 <carter> idk
21:20:41 <Total_1mmersion> With -threaded is still looks nearly the same.
21:20:45 <carter> - optimization: group multiple operations into a single bulk request
21:20:45 <carter>             conduitVector 1000
21:20:49 <carter> try making that smaller?
21:21:00 <carter> maybe its not strict enough in that batching?
21:21:10 <Total_1mmersion> My guess is that it takes a lot of CPU to convert a list of bulk operations into an HTTP request before sending.
21:21:20 <carter> try unbatching it :)
21:21:24 <Total_1mmersion> I'll try setting the chunking to 100.
21:21:25 <carter> or doing smalller batching
21:21:35 <carter> i think you're spinning consing things
21:21:37 <solatis> by the way, thanks for that code paste, as a newbie to haskell and conduit this should be posted on the conduit examples webpage somehwere :)
21:21:49 <solatis> it's a great example on how to write conduit code
21:22:01 <solatis> just my 2 cents :)
21:22:49 <Total_1mmersion> With a batch size of 100, it has a lot more sections of activity, but still has small sections of inactivity.
21:23:18 <Total_1mmersion> solatis: wow, I didn't think I would get such a compliment! I just started using conduit 2 days ago =o
21:23:45 <carter> Total_1mmersion: you can add trace event commands I think
21:23:54 <Total_1mmersion> What are those?
21:23:56 <carter> the questino I have is whether its during the batching process OR during the sending
21:24:03 <solatis> Total_1mmersion: well obviously you've been doing your homework :)
21:24:04 * mrenaud_ looks up what conduits are
21:24:18 <Axman6> so, what's the best way to work with a set of strings to test for membership. Data.HashSet?
21:24:19 <solatis> mrenaud_: it's a solution to streaming data in haskell
21:24:20 <carter> Debug.Trace
21:24:48 <Axman6> I had assumed there'd be a string set somewhere (without using my own horrible TernaryTrees package)
21:25:01 <carter> traceMarkerIO :: String -> IO () and realted things
21:25:13 <carter> Axman6: a Trie ?
21:25:41 <Axman6> yeah,. that's what my TernaryTrees package is
21:26:06 <Axman6> and it probably doesn't work
21:26:11 <Total_1mmersion> carter: awesome!! I've been looking for exactly this! Thank you =D
21:26:26 <carter> Total_1mmersion: i may not be suggesting the right function in the module mind you
21:26:40 <carter> but thatmodule is what you want I think
21:26:48 <carter> i assume / hope thread scope gives you visiblity into that
21:26:55 <mrenaud_> Very interesting, I thought that lazy evaluation already handled that but conduits also handle resource recycling it seems
21:31:19 <Total_1mmersion> carter: traceMarkerIO worked perfectly. I wrapped the call to bulk with (\v -> traceMarkerIO "start bulk" >> bulk server v >> traceMarkerIO "stop bulk").
21:31:22 <mrenaud_> Efficiency question, would Writer String be very inefficient for long logs since each one requires oldLog ++ newLog? Or would this get optimized away since it knows old log isn't used afterwards?
21:31:38 <carter> Total_1mmersion: sweett
21:31:42 <carter> what was the result?
21:32:01 <Total_1mmersion> carter: each "start bulk" message occurs near the beginning of each section of activity
21:32:08 <carter> ok
21:32:12 <carter> now wrapp the sending bits?
21:32:14 <Total_1mmersion> carter: each "stop bulk" message occurs just before the next one
21:32:43 <Total_1mmersion> You mean before and after the conduitVector?
21:32:44 <carter> Total_1mmersion:.... are you using a builder structure?
21:32:52 <carter> if youre concatting things, builders are magic
21:33:26 <jle`> mrenaud_: Writer is actually pretty bad on String
21:33:44 <carter> hhhhh
21:33:47 <Total_1mmersion> conduitVector should be pretty efficient: https://github.com/fpco/conduit-combinators/pull/9
21:33:52 <mrenaud_> jle`: Yeah, I expected that, even [String] would likely be bad as well I assume
21:34:02 <carter> Total_1mmersion: its still lazy on the elements
21:34:10 <carter> i think youve got too much deferred computation
21:34:26 <carter> Total_1mmersion: also, why are you batching?
21:34:29 <Total_1mmersion> Ok, I'll just wrap the conduitVector part
21:34:36 <jle`> the problem is not inherently because of the list data type; the problem is because of the definition of (++) and how Writer has the (++)'s associate
21:34:41 <carter> can you get the same throughput without batching?
21:34:43 <Hijiri> maybe use a difference list with Writer?
21:34:46 <Total_1mmersion> carter, because the overhead of a ton of HTTP requests becomes noticeably large.
21:34:50 <carter> ok
21:34:52 <jle`> i believe that if you use a diff list, most of this goes away
21:35:04 <carter> Total_1mmersion: so are you concatting at the end?
21:35:10 <mrenaud_> Is there a data type that has constant mappend for these types of situations? I'm sure this is a solved problem :P
21:35:50 <carter> Total_1mmersion: i dont see where youree batching
21:35:53 <Hijiri> you could have a difference list of String s, like jle` is suggesting
21:35:54 <carter> on the http side
21:36:06 <Hijiri> difference list delays concatenation to the end
21:36:10 <Total_1mmersion> carter: bulk is from the bloodhound library
21:36:10 <Hijiri> so it only does the pass once
21:36:15 <carter> ahhh
21:36:28 <carter> oooo, are you bites friend doing the edtech stuff?
21:36:41 <Total_1mmersion> No, I'm not
21:36:45 <mrenaud_> I see, Data.DList is probably best :)
21:36:57 <carter> well
21:36:58 <carter> i'm crashying
21:37:00 <carter> night
21:37:01 <Total_1mmersion> I wish I was his friend because bloodhound is a really good library
21:37:08 <Total_1mmersion> ok see ya
21:37:18 <mrenaud_> If you wanted to write messages to a file as they are generated, could you have a monoid that wraps a file handle and _ `mappend` newLog just appends newLog to the file?
21:38:15 <jle`> writer isn't really meant for things like doing IO and stuff as you go along
21:38:46 * hackagebot aeson-t 0.0.4 - Transform JSON  http://hackage.haskell.org/package/aeson-t-0.0.4 (begriffs)
21:39:01 <mrenaud_> What if it was writerT String IO?
21:39:56 <jle`> still not the right use case
21:40:04 <jle`> (tell) doesn't really do any IO, btw :P
21:40:27 <jle`> with WriterT String IO, you could do IO as you go along...but...why have Writer at all
21:40:53 <mrenaud_> Okay, what would be a better approach? I'm new to haskell and don't really know the idiomatic way of doing things yet
21:41:26 <mrenaud_> So say I wanted a way to do fire and forget logging while performing computations
21:41:55 <jle`> pipes is a nice solution for stream logging
21:41:57 <jle`> http://www.haskellforall.com/2014/02/streaming-logging.html
21:42:23 <Total_1mmersion> conduitVector does take a small amount of time at the beginning of each section of activity (~10%)
21:44:37 <jle`> it does require getting accustomed to a framework/set of idioms tho
21:45:13 <TwoUnderscores> Hello!
21:45:27 <jle`> mrenaud_: the simple non-pipes way that isn't too scalable is basically just throwing away Writer
21:45:46 <jle`> and adding in an IO command that you can give a descritive name, wherever you would say `tell`
21:45:46 <TwoUnderscores> so what is the channel for?
21:46:19 <jle`> TwoUnderscores: talking about haskell :D
21:46:21 <Axman6> TwoUnderscores: the Haskell programming language
21:46:35 <TwoUnderscores> oooo
21:46:46 <TwoUnderscores> what kind of programing lang is that
21:46:48 <jle`> mrenaud_: if you are in RWS, you could even make it an RWS a b c (), and have the "environment" contain whether or not to log.
21:46:51 <mrenaud_> jle`: Thanks for the link, it seems like Writer isn't a very useful monad then in practice (for logging anyways)
21:46:58 <TwoUnderscores> im currently learning C++
21:47:09 <jle`> mrenaud_: yes, it's not really useful for logging in the traditional sense of the word
21:47:25 <jle`> i like it think of it as a type for leaving behind trails
21:47:27 <Axman6> pure, functional with non-strict evaluation
21:47:36 <jle`> and getting the accumulation at the end
21:47:45 <mrenaud_> jle`: What do you mean by the "environment" in your previous comment?
21:47:53 <jle`> the `r` parameter in RWS
21:47:54 <jle`> can be a Bool
21:47:58 <jle`> saying whether or not to log
21:48:08 <mrenaud_> Ahh
21:48:25 <jle`> and so wherever you put your `logNow :: RWS Bool a b ()`, it'll always only log if it was originally runRWS'd with True
21:48:26 <mrenaud_> Is it common to call the R in RWS the environment?
21:48:33 <jle`> yes, that's the common term
21:48:48 <mrenaud_> Duly noted
21:49:33 <mrenaud_> So writer would be a good fit if you wanted to save the intermediate steps in a computation then
21:49:37 <jle`> TwoUnderscores: strongly typed, ;ure, with inferred typing :)
21:49:41 <jle`> *pure
21:49:44 <jle`> functional, etc.
21:49:54 <jle`> mrenaud_: yeah, that might be one use case
21:50:03 <jle`> actually, writer alone has limited uses.
21:50:37 <jle`> a lot of new people use Writer when they could just be using `mappend`.  that is, all of their actions return (), so you aren't really doing anything monadic at all
21:50:58 <jle`> mappend or mconcat
21:51:13 <jle`> this is a common trap. i've fallen into it myself more than once
21:51:28 <mrenaud_> I'll keep that in mind and try to avoid doing that :P
21:51:47 <jle`> a tell-tale sign is that you use execWriter at the end instead of runWriter/evalWriter
21:52:03 <jle`> well, sometimes that's still okay
21:52:13 <mrenaud_> :t execWriter
21:52:14 <lambdabot> Writer w a -> w
21:52:24 <jle`> the real thing is if you never at all once "branch" on the result of a `Writer w a`
21:52:37 <jle`> as in, nothing you ever do involves binding any values, or deciding what to do based on a result
21:52:43 <mrenaud_> Ah, so it just throws away the result and gives you the log
21:52:56 <jle`> yeah.  usually that's a smell that you could have just used mconcat
21:53:00 <jle`> :t mconcat
21:53:01 <lambdabot> Monoid a => [a] -> a
21:53:20 <mrenaud_> does that just fold with mappend?
21:53:23 <jle`> yeah
21:53:48 <jle`> if all you want to do with your Writer computation is just keep on smartly telling things and then getting the result of all your tells at the end
21:54:11 <jle`> execWriter (mapM tell xs) = mconcat xs
21:54:27 <mrenaud_> Makes sense, also is there a correct term for the "log" of the writer monad?
21:54:35 <jle`> hm.
21:54:48 <jle`> people just say log, or accumulator, i think
21:55:04 <mrenaud_> Ok, I wasn't sure if there was a haskelly name for it :P
21:55:09 <jle`> but accumulator is a bit loaded of a word
21:55:20 <jle`> aggregator?
21:55:42 <jle`> yeah, i haven't actually had many use cases of writer in real life where you couldn't just use mconcat
21:55:58 <mrenaud_> Hmm, that sounds more like the function used to generate the accumulated value
21:55:58 <jle`> using MonadWriter/tell and stuff with other monads is where it mostly gets interesting
21:56:14 <mrenaud_> I feel like RWS is a very common monad to use
21:57:06 <dfeuer> What is this RWS?
21:57:16 <mrenaud_> Reader Writer State
21:57:24 <dfeuer> That sounds like three of 'me.
21:57:27 <dfeuer> 'em.
21:57:30 <mrenaud_> All rolled into one
21:58:06 <dfeuer> Roll it like a _______.
21:58:15 <dfeuer> YOU'RE MAKING ME HUNGRY.
22:02:03 <mrenaud_> Is it common for the more experienced haskellers here to be willing to do a code critique of a beginner?
22:02:26 <Axman6> only if you ask
22:02:31 <Axman6> and show the code
22:04:09 <mrenaud_> I was just wondering, I don't have anything to show at this point.
22:06:12 <dfeuer> mrenaud, there is an absolute prohibition on code reviews of unwritten code.
22:06:28 <ddellacosta> mrenaud_: I've put a bit of code in a gist or whatever and asked folks to review it, and gotten some really great feedback.  If you ask nicely people here tend to be very willing to give you some great critical feedback.
22:06:43 <ddellacosta> dfeuer: :-)
22:06:52 <mrenaud_> dfeuer: Haha :P
22:07:30 <mrenaud_> ddellacosta: I'll definitely keep that in mind, I'm still learning so it's mostly tinkering with stuff here and there for me
22:08:45 <ddellacosta> mrenaud_: yeah, one thing I can say is that you'll get the best response if you've got something that is conceptually well-contained, if you know what I mean--an short implementation of an algorithm or something.
22:09:32 <ddellacosta> mrenaud_: giving people an entire repository of code, or conversely a little chunk with no context (and which needs context) is less ideal
22:10:34 <mrenaud_> ddellacosta: Yeah, I assumed as much :P I try to be concise when I ask questions, sometimes it's hard if you don't even know what you're trying to ask though :P
22:32:26 <Total_1mmersion> How do you refer to another cabal package locally, so that when you modify the local dependency, the main package sees it?
22:32:36 <mrenaud_> If I want [a -> b] -> a -> [b], is there a nicer way of doing it than map ($ x) [f,g,h]?
22:33:22 <Total_1mmersion> mrenaud_: I don't think I have seen it done any other way. IMO it's nice enough =)
22:34:45 <dfeuer> How do you ... cabal ...? Run away screaming.
22:35:06 <dfeuer> But it might be less insane than Ruby RVM.
22:35:40 <mrenaud_> [f,g,h] `ap` [4] also works
22:36:10 <mrenaud_> Alternatively, [f,g,h] <*> [4]
22:36:43 <mrenaud_> I feel like I would be puzzled for a while if I came across that what it was doing though :P
22:37:26 <dfeuer> > [(+1), (+2), (+3)] <*> [4,40,400]
22:37:28 <lambdabot>  [5,41,401,6,42,402,7,43,403]
22:38:45 <mrenaud_> If there's only ever going to be one value you want to bind it to I feek like the <*> version hurts readability
22:38:58 <zRecursive> Then that means List is Applicative ?
22:39:08 <mrenaud_> zRecursive: Yes
22:39:20 <dfeuer> zRecursive, [] is even a Monad!
22:39:42 <zRecursive> Is Monad subclass of Applicative ?
22:40:00 <dfeuer> As of GHC 7.10.1, yes.
22:40:07 <mrenaud_> In the language no, in theory yes
22:40:13 <mrenaud_> Oooo! :) That makes me happy
22:40:26 <zRecursive> great!
22:40:36 * mrenaud_ checks to see his GHC version
22:40:48 <Enigmagic> (note: 7.10.1 isn't out yet)
22:40:52 <dfeuer> That's been a long time coming. 7.10.1 gets both the Applicative => Monad proposal and the so-called Foldable-Traversable bridge-burning proposal.
22:41:23 <mrenaud_> 7.8.3, darn :P
22:41:26 <dfeuer> But you can clone the git repo and compile it yourself!
22:41:43 <mrenaud_> What's the foldable-traversable proposal?
22:41:52 <dfeuer> It generally works, but getting external stuff from Hackage to work can be more challenging.
22:42:36 <dfeuer> The Foldable-Traversable thing, abbreviated BBP, generalizes a bunch of Prelude stuff from lists to Foldable and Traversable things.
22:43:05 <dfeuer> So you can now import Data.Foldable and Data.Traversable without having to hide anything from the Prelude.
22:43:17 <ReinH>  mrenaud_ map ($ x) is a very nice way to do it
22:43:32 <dfeuer> Also, the Foldable class has gotten bigger; it now includes length, null, elem, minimum, maximum, sum, and product.
22:43:58 <dfeuer> Agreed, ReinH.
22:44:08 <ReinH> Very haskellish
22:45:59 <mrenaud_> ReinH: Thanks! :)
22:46:27 <ReinH> such Yoneda wow
22:46:35 <dfeuer> Haaa.
22:46:39 <mrenaud_> dfeuer: Ok, interesting. Wouldn't the stuff in foldable name clash with Data.List?
22:47:07 <dfeuer> mrenaud, yes, that's why Data.List now imports all those things from Data.Foldable.
22:47:23 <mrenaud_> Ah, that makes sense
22:48:10 <dfeuer> In 7.10, if you ask   :t foldl   you get  Foldable f => (a -> b -> a) -> a -> f b -> a
22:48:38 <mrenaud_> Just looked up Yoneda lemma, not sure what it's saying :P
22:48:57 <dfeuer> Something over my head, for sure.
22:53:00 <mrenaud_> I wish I took more abstract algebra courses in school :P
22:56:46 <mrenaud_> Is there a way to write automatic type conversion operators in Haskell?
22:58:58 <dfeuer> mrenaud, automatic type conversion operators? Can you be more specific?
22:59:49 <mrenaud_> Say I have a DList Int, is there a way of automatically converting from a [Int] to a DList Int?
23:00:05 <mrenaud_> Think implicit casts in C
23:00:24 <dfeuer> No, there isn't, and we wouldn't want there to be.
23:00:36 <mrenaud_> Or more analagous cast operators in C++, where you can say this type is implicitly convertible to this other type, and here is how
23:01:22 <dfeuer> There are automatic ways to create *explicit* conversions.
23:02:14 <mrenaud_> So if I have a bunch of code that uses [Int], and I want to change it to use DList Int, I have to replace all the call sites with toDiffList l?
23:02:37 <dfeuer> Like using deriving clauses, or using Data.Coercible.
23:03:33 <mrenaud_> Would a better approach be to not overspecify the interface and say Monoid m => m Int? And the only use mappend and mempty?
23:03:44 <dfeuer> mrenaud, that's true in general, but you can help yourself in advance by using type synonyms from the start, and sticking to typeclass methods when you can, and so on.
23:04:14 <dfeuer> Different people have different styles, of course.
23:04:33 <mrenaud_> Okay, thanks
23:04:38 <dfeuer> You can do this sort of thing through either the class system or the module system,
23:04:52 <dfeuer> but it seems things are moving toward the class system, I think.
23:04:59 <dfeuer> It depends, though.
23:05:05 * dfeuer is sleeeeepy.
23:05:18 <zRecursive> night
23:05:42 <mrenaud_> I'm going through LYAH and I keep encountering things that seem awkward initially, but keep realizing there's better ways of doing it
23:05:50 <mrenaud_> Night, thanks for all the help :)
23:22:04 <jle`> mrenaud_: btw, Monoid m => m Int is not well-kinded.  [Int] is a Monoiad.  DList Int is a Monoid.  so you probably want Monoid m => m
23:22:28 <jle`> Monoids are * :)
23:22:42 <jle`> ...did i say Monoiad, haha
23:23:24 <jle`> there is a generalization of "* -> *-kinded Monoids", btw.  well, a couple.
23:23:41 <jle`> but that isn't necessary here :)
23:25:16 <free_beard> hi guys, i'm trying to use a cabal sandbox for fiddling with yesod, do i need to cabal install yesod if i use import Yesod in a main file or yesod-bin is enough (it doesn't seem to be - or maybe i'm installing my package wrong)
23:25:54 <mrenaud_> jle`: Ahhhhh, I was not aware of that
23:26:13 <jle`> mrenaud_: you can tell by looking at the type of mappend
23:26:14 <jle`> :t mappend
23:26:15 <lambdabot> Monoid a => a -> a -> a
23:26:20 <jle`> or even the type of mempty
23:26:22 <jle`> :t mempty
23:26:24 <lambdabot> Monoid a => a
23:26:24 <jle`> :)
23:26:55 <mrenaud_> Is there a reason why it isn't * -> *?
23:27:06 <jle`> [Int] is your monoid
23:27:15 <jle`> not []
23:27:28 <mrenaud_> Yes, that makes sense now
23:27:28 <free_beard> nevermind, got it..i needed to add it to builddepends
23:27:38 <jle`> there are monoids that aren't "collection things"
23:27:45 <jle`> like a couple of monoid instances on Bool
23:28:05 <jle`> :t mappend `asAppledTo` Any True
23:28:06 <lambdabot>     Not in scope: ‘asAppledTo’
23:28:06 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 204)
23:28:11 <jle`> :t mappend `asAppliedTo` Any True
23:28:12 <lambdabot> Any -> Any -> Any
23:28:24 <jle`> also a couple of Monoid instances on Int s
23:28:29 <jle`> :t mappend `asAppliedTo` Sum 0
23:28:30 <lambdabot> Num a => Sum a -> Sum a -> Sum a
23:28:36 <blast_hardcheese> free_beard: That was going to be my suggestion, just saw your question. I don't use cabal install without --only-dependencies when using sandboxes
23:28:40 <jle`> hm that might not have been the best example
23:28:55 <mrenaud_> I see what you mean though
23:29:16 <mrenaud_> I think that's the first non-parameterized type class I've encountered :P
23:29:19 <blast_hardcheese> If you've got a properly set up program, it wouldn't even be able to access things that were in the sandbox that weren't explicitly stated as dependencies anyway.
23:29:20 <jle`> haha
23:29:27 <jle`> you probably have encountered more than one :)
23:29:32 <jle`> if you just think about it
23:29:46 <mrenaud_> class Num
23:29:47 <jle`> i can think of at least five that you might have worked with pretty well so far
23:29:51 <jle`> yea
23:29:57 <free_beard> blast_hardcheese: does running with --only-dependencies add dependencies to my cabal file?
23:30:02 <mrenaud_> Show, Read, Eq, Ord, etc
23:30:07 <jle`> nice
23:30:07 <blast_hardcheese> free_beard: No, just installs them
23:30:27 <free_beard> blast_hardcheese: ok, thanks!
23:30:29 <blast_hardcheese> free_beard: You manage your .cabal file yourself, but no need to manage your dependencies in more than one place
23:30:37 <jle`> btw, "parameterized typeclass" is a bit loaded of a term. but. i know what you meant.
23:31:39 <mrenaud_> What would be a better way of putting it? I don't mind it when people are pedantic with terminology, especially when I'm learning :P
23:31:52 <mrenaud_> I would rather learn the proper term for it
23:32:09 <jle`> a typeclass whose instances are type constructors or kind (* -> *), maybe?
23:32:19 <jle`> hm.  actually i do'nt know.
23:32:24 <jle`> heh.
23:32:40 <jle`> btw, keep an eye out for your first (* -> * -> *) typeclass :)
23:33:07 <jle`> i'm not sure if LYAH goes over any...
23:33:19 <mrenaud_> Wouldn't Either be kind * -> * -> *?
23:33:22 <jle`> Either is
23:33:29 <jle`> but i'm talking about a typeclass whose instances are * -> * -> *
23:33:55 <jle`> (->) is another common * -> * -> *-kinded thing, btw
23:34:27 <jle`> and (,)
23:34:40 <mrenaud_> Is that a comma?
23:34:42 <mrenaud_> :t (,)
23:34:43 <lambdabot> a -> b -> (a, b)
23:35:16 <jle`> it's the tuple type constructor
23:35:21 <jle`> :k (Int, Bool)
23:35:22 <lambdabot> *
23:35:27 <jle`> :k (,) Int Bool
23:35:28 <lambdabot> *
23:35:38 <mrenaud_> How does that generalize to n-tuples?
23:35:55 <jle`> :k (,)
23:35:56 <lambdabot> * -> * -> *
23:35:57 <jle`> :k (,,)
23:35:58 <lambdabot> * -> * -> * -> *
23:36:11 <jle`> (Int, Bool) is (,) Int Bool
23:36:16 <mrenaud_> Ahh, tricky :P
23:36:21 <jle`> (Int, Bool, String) is (,,) Int Bool String
23:36:30 <mauke> it doesn't generalize. there are n constructors
23:36:37 <dfeuer> :k ((,),)
23:36:38 <lambdabot> parse error on input ‘)’
23:36:50 <mauke> no tuple sections
23:36:57 <mauke> :k (,) (,)
23:36:58 <lambdabot>     Expecting two more arguments to ‘(,)’
23:36:58 <lambdabot>     The first argument of ‘(,)’ should have kind ‘*’,
23:36:58 <lambdabot>       but ‘(,)’ has kind ‘* -> * -> *’
23:37:14 <dfeuer> :k [] []
23:37:15 <lambdabot>     Expecting one more argument to ‘[]’
23:37:15 <lambdabot>     The first argument of ‘[]’ should have kind ‘*’,
23:37:15 <lambdabot>       but ‘[]’ has kind ‘* -> *’
23:37:31 <jle`> mrenaud_: you might notice that haskell basically has another completely "separate" language at the type level
23:37:32 <mauke> :k [] ([] Int)
23:37:33 <lambdabot> *
23:37:44 <dfeuer> Yeah, but that's boring.
23:37:47 <u-ou> :k [] <$> []
23:37:48 <lambdabot> Not in scope: type constructor or class ‘<$>’
23:37:49 <jle`> some people say that haskell has three languages --- the value level, the type level...and the error level.
23:37:53 <jle`> by some people i mean me
23:37:59 <dfeuer> Heh.
23:38:13 <u-ou> :)
23:38:48 <mrenaud_> Haha
23:38:58 <mrenaud_> Also...
23:39:02 <mrenaud_> :k Monoid
23:39:03 <lambdabot> * -> Constraint
23:39:08 <mrenaud_> What is this Constraint business?
23:39:16 <jle`> you might have noticed type signatures go like this:
23:39:27 <jle`> foo :: (Monoid m, Num a) => m -> a -> ...
23:39:32 <mrenaud_> Yup
23:39:38 <jle`> you can think about it as...whatever is on the right hand side of the => must be *
23:39:46 <jle`> of kind *
23:39:52 <jle`> and whatever is on the left hand side must be of kind Constraint
23:40:04 <u-ou> oh
23:40:08 <jle`> (or a list of constraints.  which is itself a constraint)
23:40:21 <jle`> Constraint => *
23:40:23 <jle`> um
23:40:34 <jle`> (c :: Constraint) => (t :: *)
23:40:34 <mrenaud_> That is really neat
23:40:47 <cbarrett> Constraint kinds are relatively new and they are awesome.
23:40:57 <u-ou> how new?
23:41:22 <mrenaud_> I think I asked this earlier but don't know if I got an answer, what is a data kind?
23:41:25 <cbarrett> Last few few years.
23:41:45 <cbarrett> mrenaud_: A data kind is a promotion of a data ... declaraion "one level up"
23:42:04 <mrenaud_> So it promotes a type to a kind?
23:42:08 <u-ou> :k =>
23:42:09 <lambdabot> parse error on input ‘=>’
23:42:18 <cbarrett> A data decl normally creates a type-level thing and some value level things (i.e. constructors)
23:42:50 <cbarrett> some typess of data decls will be automatically promoted to create a kind-level thing and some type level things (i.e. constructors)
23:43:27 <cbarrett> So you can write data Nat = Z | S Nat and then use Nat as a kind and Z and S as type constructors
23:43:41 <cbarrett> (you can encode natural numbers with this)
23:44:37 <cbarrett> Hopefully that was clear...
23:46:17 <jle`> btw, if you feel that this strict split between the value level and the type level (and the kind level) is a little bit crazy and messy, there are some languages that unify everything to one level for all
23:46:42 <cbarrett> indeed
23:47:15 <cbarrett> A lot of these features are meant to try and soften that split and allow Haskell to emulate those languages in certain cases.
23:47:28 <solatis> ok, so i know the withFoo $ \foo -> pattern is used quite a lot in haskell
23:47:42 <solatis> is there any way to merge that with currying?
23:47:47 <solatis> as in, look at some of my code:
23:48:19 <lpaste> solatis pasted “No title” at http://lpaste.net/113248
23:48:22 <mrenaud_> cbarrett: That makes some semblance of sense, I probably don't know enough for it to be fully meaningful at this point though :P
23:48:43 <solatis> is there any way of making that code less verbose / more elegant?
23:49:47 <mrenaud_> I'm also curious :P
23:51:38 <cbarrett> solatis: what exactly are the signatures of those functions? got a link to hackage?
23:51:44 <cbarrett> (I tried googling and couldn't find anything)
23:52:57 <solatis> oh these are my own
23:53:09 <solatis> withMock :: ((ZMQ.Socket ZMQ.Push, ZMQ.Socket ZMQ.Pull) -> IO a) -> IO a
23:53:11 <solatis> that's one
23:53:28 <dfeuer> Can someone tell me if I'm missing something about this rule in GHC.List?
23:53:39 <solatis> withHttp :: (HC.Manager -> IO a) -> IO a
23:53:41 <solatis> withHttp = bracket
23:53:43 <solatis>            (HC.newManager HC.conduitManagerSettings)
23:53:46 <solatis>            (HC.closeManager)
23:53:47 <solatis> thats the other
23:54:04 * hackagebot warp-tls 3.0.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1 (MichaelSnoyman)
23:54:21 * dfeuer immerses Total_1mmersion.
23:54:47 * Total_1mmersion becomes totally immersed.
23:55:39 <dfeuer> Can I borrow a supercomputer to build GHC?
23:56:46 <Total_1mmersion> Sure, just grab a beefy VM from a cloud service
23:56:48 <cbarrett> solatis: nothing comes to mind at the moment but it's late here.
23:57:05 <solatis> i was thinking that continuations might be what i'm looking for
23:57:13 <solatis> but i'm not sure
23:57:42 <solatis> but maybe this is just the consequence of using scoped-callback-style over monadic style
23:58:40 <cbarrett> It's possible, not super familiar with continuations in Haskell
23:59:05 * hackagebot mighttpd2 3.2.4 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.4 (KazuYamamoto)
23:59:54 <solatis> for the sake of the learning experience, i'm going to dive into that
