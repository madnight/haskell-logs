00:00:29 <solatis> http://futurice.com/blog/npm-registry-in-numbers
00:00:32 <solatis> node.js package manager
00:00:44 <solatis> npm is to node.js what cabal is to haskell
00:00:54 <solatis> only both of them chose very, very different approaches
00:01:42 <gfixler_> solatis: oh, I see
00:01:50 <solatis> but it would be interesting to perform a similar analysis about hackage, and see if there are differences in usage patterns
00:02:28 <gfixler_> well, if the rule holds, we need all of this stuff
00:02:34 <solatis> for example, > 50% of the NPM packages are less than 2 weeks old :)
00:02:39 <gfixler_> (the rule: every change breaks *somebody's* workflow)
00:03:04 <gfixler_> solatis: wow, that's exponential growth right there
00:03:12 <n4x> don't worry, there isn't going to be any fix of the spacebar heating bug!
00:03:31 <gfixler_> n4x: phwew! I'm glad someone thought of the children
00:03:32 <solatis> yes, but more than 70% have more than one version released too
00:03:44 <solatis> anyway
00:03:50 <solatis> i thought the blog post was relevant
00:03:52 <solatis> and only a month old
00:04:09 <gfixler_> I'll have to check itout
00:04:16 <solatis> i would be interested to perform a similar analysis about hackage
00:04:38 <gfixler_> whenever I see things like this - 52k files - I always ponder, like "Is the universe *really* this complicated?"
00:04:57 <gfixler_> I'm not sure I've even done 52k unique things in my life
00:05:21 <solatis> :)
00:05:48 <solatis> i wouldn't be surprised if (total amount of packages on hackage * total amount of versions of all packages) = +- 52k
00:06:05 <gfixler_> solatis: oh yeah, I forgot I was seeing version numbers flicker past
00:06:19 <solatis> right
00:06:26 <solatis> and haskell packages tend to have a lot of versions
00:07:05 <solatis> i would be interested to see the difference in numbers for maintained vs unmaintained packages
00:07:22 <gfixler_> ah, nail on the head
00:07:32 <gfixler_> picking at random, the netwire package has 24 versions
00:08:17 <solatis> yeah
00:08:23 <solatis> and just look at the whole conduit namespace
00:08:32 <solatis> tons of different packages, all with tons of different versions
00:08:34 <solatis> http://hackage.haskell.org/package/conduit
00:08:47 <gfixler_> ah, yes
00:09:11 <solatis> i wouldn't be surprised if conduit actually accounted for at least 1k of those 52k files :)
00:10:43 <solatis> https://github.com/snoyberg/conduit/releases
00:11:10 <solatis> that's 257 releases of only a single git repo right there
00:11:30 <gfixler_> alright, now I need to know what conduit is
00:11:53 <liyang> It's a series of tubes.
00:12:08 <gfixler_> like too much air in a balloon!
00:12:20 <solatis> liyang: i lol'ed
00:12:36 <solatis> that would be Pipes, tho :)
00:12:37 <bsmt> dedication
00:12:49 <gfixler_> and the arrows go... through? the pipes?
00:13:07 <solatis> conduit is combination dedication, brilliance and a lot of magic
00:13:49 <bsmt> that's how i feel about haskell in general
00:13:54 <bsmt> i'll see myself out
00:13:59 <gfixler_> written by a team, or one person on Aderall?
00:14:57 <solatis> one person
00:15:07 <solatis> http://lpaste.net/113247
00:15:20 <solatis> for a small glance at what conduit is
00:15:44 <solatis> producers, consumers, combinators and connectors
00:16:48 <solatis> it's good to know about conduit and that it's out there in case you ever need to write stream-like code
00:19:36 <gfixler_> I will add this to my general sense of the zeitgeist
00:22:27 <solatis> gfixler_: you can best view it as an alternative to Haskell's lazy lists or Concurrent.Chan -- as soon as you find out those things don't work well in your case (for example, you need buffering or concurrency), you might want to look into conduit
00:22:46 <solatis> and there's a whole ecosystem around it
00:22:48 <solatis> conduit-network
00:23:03 <solatis> conduit has its own ListT
00:23:09 <solatis> etc
00:25:54 <gfixler_> It sounds like conduit isn't so much about new abilities as it is things like guarantees and predictability, no?
00:30:15 <solatis> gfixler_: it is a bit of both
00:30:17 <ddellacosta> I'm working through the homework for week 2 in Erik Meijer's "Introduction to Functional Programming," and there's just one question I'm stuck on: "Is it feasible for function types (in general) to be instances of the Eq class?"  It seems like the answer should be yes, but there's one more option that I'm not sure of, which is "Feasible for all functions that terminate."  I don't understand why termination would
00:30:17 <ddellacosta> or would not make a difference...can anyone elucidate?
00:30:50 <solatis> it provides some better mechanisms for handling exceptions, but still is not completely exception safe
00:30:56 <ddellacosta> but it seems to me that one should be able to compare types of a function to determine equality, simply
00:31:10 <gfixler_> ddellacosta: I'm also on week 2 of the edX course
00:31:19 <gfixler_> I have heard that functions cannot be compared
00:31:21 <kadoban> ddellacosta: Sounds like the halting problem would be an issue related to that.
00:31:36 <gfixler_> I'm also currently reading lecture 4 of CIS-194 - the part about parametricity
00:31:36 <solatis> what kadoban said
00:32:03 <ddellacosta> okay, thanks kadoban and solatis.  gfixler_, good luck. :-)
00:32:06 <solatis> is IO () a function?
00:32:06 <kadoban> ddellacosta: But comparing the types isn't enough, or at least it's not enough to be meaningful
00:32:16 <ddellacosta> kadoban: okay, that's helpful
00:32:31 <ddellacosta> solatis: I don't know what IO () is, I'm sorry. :-(
00:32:56 <solatis> ddellacosta: it represents an I/O action as a function :)
00:33:23 <solatis> (and i'm probably going to be flamed right here because i'm not using the right terminology)
00:33:28 <ddellacosta> solatis: okay, sorry I'm still unfamiliar with IO!
00:33:42 <kadoban> Yeah, that doesn't sound correct solatis, hehe.
00:33:46 <gfixler_> would comparing functions require comparing something like the domain and codomain?
00:33:48 <Hijiri> IO () isn't a function though
00:34:17 <ddellacosta> yeah, I was thinking that you'd need to compare the types going in and the types coming out, like gfixler_ is saying
00:34:18 <johnw> IO () is a value, which represents an action in IO
00:34:18 <solatis> ok different example
00:34:19 <gfixler_> no, I guess that wouldn't even be enough
00:34:35 <solatis> a function that generates an infinite list
00:34:40 <solatis> is that a function?
00:34:41 <kadoban> ddellacosta: But the types aren't enough, right? Should (+) be == to (-) ?
00:34:45 <johnw> gfixler_: comparing functions requires comparing them at all inputs
00:34:45 <gfixler_> but comparing the types wouldn't be enough, because that doesn't work for other types
00:34:49 <gfixler_> 7 and 3 are both ints, but not equal
00:34:52 <Hijiri> depends solatis
00:34:55 <gfixler_> johnw: exactly
00:34:59 <johnw> f = g  if  forall x. f x = g x
00:35:01 <Hijiri> If its type is a -> b then yes
00:35:02 <ddellacosta> kadoban: I mean,I guess it depends on what "equality" means, that's what is confusing to me
00:35:04 <Hijiri> well
00:35:09 <Hijiri> for some a and b
00:35:14 <Hijiri> not for all
00:35:20 <ddellacosta> kadoban: there is a confusing hint given in the homework, "Two functions of the same type are equal iff they always return equal results for equal arguments."
00:35:23 <Ferdirand> what does "a function that terminates" mean ? does the length function terminate ?
00:35:25 <johnw> that is called "functional extensionality"
00:35:39 <solatis> when a function is of class Eq, does it compare the functions or the output of the functions?
00:35:39 <johnw> Ferdirand: a function that terminates yields an answer
00:35:42 <ddellacosta> equal results = equal types, or equal values?  That's what I don't get
00:35:49 <Hijiri> something like fix (1:) isn't a function, it's just an infinite list
00:35:52 <Ferdirand> johnw: does length terminate ?
00:35:54 <kadoban> ddellacosta: Equal values
00:36:00 <johnw> Ferdirand: on finite lists, yes
00:36:01 <gfixler_> [a] -> [a] could be a number of things, like reverse, tail, etc
00:36:03 <ddellacosta> kadoban: okay, in that case it seems clear
00:36:09 <johnw> on infinite lists, no
00:36:17 <ddellacosta> and actually I was very much mistaken!
00:36:26 <solatis> but that doesn't mean `length` cannot be compared, right?
00:36:32 <kadoban> ddellacosta: I mean you could define equality to mean they have equal types, but...yeah it wouldn't be the most sensical thing in the world.
00:36:37 <solatis> because you're talking about the *result* of the function
00:36:39 <Ferdirand> right, so back to my question: what does "a function that terminates" mean if the function inputs are not specified ?
00:36:41 <ddellacosta> kadoban: okay, I see what you mean
00:36:41 <solatis> not that function itself
00:36:59 <ddellacosta> okay, this is super helpful, thanks everyone!
00:37:51 <ddellacosta> and, I'm done with week 2's homework. :-)
00:37:55 <solatis> :)
00:38:01 <gfixler_> wow, that was fast
00:38:11 <ddellacosta> gfixler_: well, that was the only one I was confused about
00:38:17 <solatis> i didn't know you could copy/paste irc logs as homework
00:38:28 <kadoban> Haha
00:38:29 <ddellacosta> solatis: haha, no, I figured out the correct answer for the one above
00:38:31 <gfixler_> save chat transcript, paste into homework, done
00:38:38 <gfixler_> solatis: lol
00:38:43 <ddellacosta> that would be awesome, perhaps, but I also wouldn't be learning anything that way
00:38:53 <solatis> gfixler_: better yet, use conduit to stream the relevant irc logs to your .tex file
00:39:36 <gfixler_> solatis: I graduated school too soon - I could  have automated everything
00:39:48 <ddellacosta> there's something awesomely meta about that
00:39:57 <mhd> Why isn't there a `breakByteEnd` function to mirror `breakByte` in Data.ByteString?
00:40:01 <bsmt> i'm taking that class too
00:40:10 <ddellacosta> if you spent all your time in school learning how to automate everything, you'd be more advanced than many people who actually did the work
00:40:27 <gfixler_> ddellacosta: yeah, I was thinking "That would actually make me really good at future jobs."
00:40:33 <ddellacosta> gfixler_: right?
00:40:48 <gfixler_> "You cheated on everything and got all As? You start Monday."
00:40:57 <ddellacosta> hahaha...exactly
00:40:59 <kadoban> If you get too good though, you could automate yourself right out of a job. Slight downside.
00:41:09 <bsmt> soon there will be professional stack overflow users
00:41:13 <gfixler_> you could just automate new problems to deal with
00:41:24 <ddellacosta> kadoban: if you're that good, you would always have a backup scenario, come on. ;-)
00:41:37 <kadoban> bsmt: There are, they're called webdevs
00:41:42 <bsmt> niceeeeeee
00:41:46 <AshyIsMe> Who automates the automators?
00:41:49 <ddellacosta> ouch, that hurts me in my web dev core
00:41:51 <gfixler_> if you're that good, you could just  keep remotely breaking everyone else's machines
00:41:53 <johnw> we try to keep non-Haskell chatter to #haskell-blah, if you would
00:42:01 <gfixler_> then you'd be the only competent one - they couldn't fire you
00:42:01 <ddellacosta> even as I acknowledge the general truth of the statement
00:42:13 <ddellacosta> johnw: sorry, apologies.  It started out w/Haskell...
00:42:18 <kadoban> Hehe, right? I mostly do webdev too, but it's still true :-/
00:42:21 <johnw> I know, it happens :)
00:42:45 <johnw> we want to keep the channel open so that questions like the one from mhd don't scroll away
00:42:54 <gfixler_> johnw: I have been chattering in #haskell-blah - I just had conduit configured wrong, so it's been dumping everything here
00:43:02 <johnw> mhd: it could just be an oversight
00:43:10 <mhd> Yeah, imma fork it and add it
00:43:18 <ddellacosta> gfixler_: hahaha...
00:43:19 <mhd> and make a pull request
00:43:20 <solatis> i am not sure where webdev starts and webdev ends in this day and age
00:44:06 * hackagebot syntax-pretty 0.1.0.1 - Syntax instance for pretty, the pretty printing library.  http://hackage.haskell.org/package/syntax-pretty-0.1.0.1 (pawel834)
00:48:04 <dfeuer> mhd, that sounds like an excellent idea.
00:48:30 <testuser> If http://learnyouahaskell.com/ is too easy and boring to read, what's a good alternative?
00:48:45 <dfeuer> testuser, the other popular one seems to be Real World Haskell.
00:48:53 <dfeuer> For intro.
00:48:55 <testuser> I want a more mathematical and formal intro suitable for math Ph.D.
00:49:02 <dfeuer> Ohhh.
00:49:07 <dfeuer> There are those too.
00:49:16 <dfeuer> I don't know where they are though.
00:49:31 <testuser> I read the first 5 pages of Real World Haskell, seems good.  But just wondering if there are others out there
00:49:40 <ddellacosta> testuser: check out http://homepages.cwi.nl/~jve/HR/
00:49:48 <dfeuer> testuser, you could start by reading everything by Oleg Kiselyov, Simon Peyton Jones, ....
00:50:10 <johnw> testuser: maybe http://www.amazon.com/Haskell-Programming-Second-Edition-Computing/dp/0954300696?
00:50:29 <dfeuer> testuser, oh, don't miss everything by Edward Kmett here... he blogs about category theory and Haskell a lot.
00:50:44 <dfeuer> Search for "Comonad Reader".
00:50:53 <ddellacosta> testuser: also, Wadler's papers are awesome too for a lot of core concepts: http://homepages.inf.ed.ac.uk/wadler/topics/
00:53:02 <testuser> I'll explore those recommendations.  Thanks
00:53:57 <edwardk> #haskell-lens is also a good place for higher powered math discussions related to haskell
00:54:13 <edwardk> or just in general for that matter
00:56:33 * ddellacosta joins to lurk and learn in #haskell-lens
01:00:48 <testuser> test
01:01:00 <simpson> testuser: This is not a good channel for testing.
01:09:09 * hackagebot thorn 0.2 - Datatype Manipulation with Template Haskell  http://hackage.haskell.org/package/thorn-0.2 (Kinokkory)
01:15:49 <Ferdirand> can someone explain corecursion as the dual of recursion ? all I find on the net is "it's like streams vs lists", but I don't get the duality
01:16:07 <Ferdirand> is it because it flips product and sum types ?
01:16:26 <edwardk> no its all about the algebras involved in folding and unfolding
01:16:58 <Ferdirand> at one point i should really learn properly what an algebra is
01:17:31 <edwardk> the least fixed point of f (used in a catamorphism) is obtained by saying you give me any function (f a -> a) and i'll give you an a.
01:17:32 <Ferdirand> aah, folding vs unfolding, that sort of makes sense now
01:17:57 <edwardk> newtype Mu f = Mu (forall a. (f a -> a) -> a)
01:18:26 <edwardk> on the other hand the greatest fixed point Nu is obtained by giving a seed 'a' and a way for unfolding it a level (a -> f a)
01:18:26 <Ferdirand> so f could be a list here for instance ?
01:18:43 <edwardk> yeah then you'd have a tree made out of levels of [
01:18:57 <edwardk> er []
01:19:05 <edwardk> basically an unlabeled rose tree
01:19:33 <edwardk> data Nu f where Nu :: a -> (a -> f a) -> Nu f
01:19:57 <edwardk> now you can easily go from Mu to Nu, but going back is messy
01:20:04 <edwardk> in haskell Mu = Nu -- the least and greatest fixed points coincide
01:20:20 <edwardk> in some other languages, Agda, Coq, Idris, etc. they are differentiable
01:20:21 <trap_exit> edwardk: do you code on paper at all?
01:20:30 <trap_exit> edwardk: do you have a blog post on how your haskell setup is like?
01:20:33 <Ferdirand> that is going a bit fast, i need to reflect a bit on this
01:20:35 <trap_exit> the closest I've found is some reddit comment you made
01:20:46 <trap_exit> about spending 8 months studying haskell, and everything clicked after that, where you write type sigs, and code flows out
01:20:54 <trap_exit> however, do you have a more detailed setup of how you develop haskell?
01:20:57 <edwardk> trap_exit: my haskell setup is boring, i use vim, no extensions
01:21:14 <trap_exit> edwardk: so no ghc-mod, interactive ghci prompt?
01:21:27 <edwardk> you can pretty much watch a life stream of me developing by watching my commit logs ;)
01:21:29 <edwardk> no ghc-mod
01:21:36 <Ferdirand> i use haskell daily for menial programs but i've not reached the point where Mu and Nu start to make sense yet :)
01:21:41 <trap_exit> edwardk: do you sketch out the type signatures on paper first, or do you just fire up vim and code there?
01:21:43 <edwardk> i do run :!ghci to get out to ghci fairly often in my session when i forget a type
01:21:45 <trap_exit> edwardk: do you commit per keystroke?
01:21:57 <edwardk> i bang out code straight into vim
01:22:24 <trap_exit> say you're writing 5 related funcs; do you write hte type sitnarure of all 5 before the body of any function; or do you write type sig of one; body of one; type sig of nex; body of next ?
01:22:30 <kadoban> Really, no plugins? That's rather surprising. If nothing else, I find autocomplete extremely time saving.
01:22:40 <edwardk> nah, i admit i'll usually spit out a fair bit of code to 'rough out' a package, then go back and refine and refine and refine, and the rough cut might be 3000 lines, while the refinements will all be ~5 line patches
01:22:50 <bernalex> trap_exit: please note that edwardk is an insane übermensch and that following his advice might not be advantageous to us normal earth-dwelling human beings.
01:22:57 <edwardk> kadoban: i wind up with very long periods of time where my code doesn't compile =)
01:23:02 <edwardk> bernalex: =P
01:23:14 <trap_exit> bernalex: some of us will exceed edwardk
01:23:26 <trap_exit> edwardk: tell me more about how you work :-)
01:23:32 <edwardk> trap_exit: i tend to write each thing and try to make it the best version of the thing it can be, then try to use it
01:23:35 <tdammers> kadoban: vim has autocomplete :D
01:23:45 <kadoban> edwardk: Right, which would kill ghc-mod usage in the usual way, but you could still use dumb autocomplete, and snippets and such.
01:23:56 <kadoban> tdammers: Built-in? Really?
01:23:57 <edwardk> or get a rough sketch of a data type and iterate through all the possible choices of the API design
01:23:58 <tdammers> edwardk: literally "each thing", I take it?
01:24:02 <tdammers> kadoban: yes, really.
01:24:10 <tdammers> kadoban: C-n is the default binding
01:24:17 <tdammers> kadoban: since 7.3 if I'm not mistaken
01:24:25 <bernalex> I use ghc-mod all the time. I'll change a type, :w, and GHC will just hand me a TODO-list.
01:24:25 <kadoban> Huh, how 'bout that.
01:24:53 <tdammers> kadoban: it doesn't work like intellisense though; it doesn't know a thing about your code, it just matches words
01:24:58 <edwardk> i could use many things, what i find is doing anything more than generating tags files on save tends to cause me to twitch i hit :w\n:w\n... as a nervous twitch as i type ;)
01:24:59 <trap_exit> by 'each thing' do you mean 'each func' or 'each module' or 'each library' ?
01:25:23 <kadoban> tdammers: Right, makes sense. I use that sometimes, but I guess I just thought it was part of...whatever autocomplete plugin I'm use. neocomplete I think. Nice to know :)
01:25:37 <edwardk> trap_exit: if i write out a data type, i'll usually stop, build all the instances that can exist for that type i have lying around, then go write whatever methods i wanted to use it for
01:25:47 <tdammers> it's vanilla vim ... some extensions / plugins hook into it though, and it does read tag files
01:26:00 <edwardk> so 'each thing' there is kinda recursive, its each data type, then within that its all the instances for it, etc.
01:26:02 <kadoban> Neat
01:26:23 <trap_exit> this is cool
01:26:52 <trap_exit> I like
01:26:57 <edwardk> e.g. right now i need to get textures to load into my raytracer
01:27:10 <edwardk> so i looked and found a hack someone had posted about how to read a juicypixels image
01:27:27 <edwardk> didn't really want to deal with the hacky version so i said, ok, how can i 'solve this forever'
01:27:40 <trap_exit> that's easy, you tell edwardk to write a library
01:27:54 <magthe> bernalex: which version of ghc-mod?  the latest has a pattern matching bug that renders the whole thing useless :(
01:27:57 <trap_exit> so how did you solve it forever?
01:28:20 <bernalex> magthe: I have 4.1.6. ghc-mod has a really annoying bug for me though.
01:28:22 <edwardk> and so i worked out what i needed to make the hacky approach work for one format https://github.com/ekmett/quine/blob/master/src/Quine/Image.hs#L37 then looked around to see what could be instantiated from that.
01:29:06 <magthe> bernalex: what bug is that?  maybe it's worth swapping "my bug" for "yours" :)
01:29:20 <bernalex> magthe: https://github.com/plaimi/tempuhs-server/blob/master/src/Tempuhs/Server.hs see the way we put our module on the same lime as -} ? this causes a parse warning if you have a pragma (or more) at the top. which is annoying as hell. especially since it means it can't detect unused pragmas. such a silly bug. I don't know exactly *where* we found out it's from -- maybe hdevtools.
01:29:28 <edwardk> then when i looked at the code for the image to texture conversion it had a bunch of stuff for flipping the image. i just think opengl style so i don't need to do that, dropped it, dropped all the code for converting a storable into a bytestring then converting it to a c string by working smarter, and i got https://github.com/ekmett/quine/blob/master/src/Quine/Image.hs#L123
01:29:36 <edwardk> now i can just load any file format juicy pixels supports
01:29:58 <edwardk> and i can take screenshots out of opengl by reversing the flow more or less using the same information
01:30:32 <edwardk> instead of loading one file type as a hack an hour extra work and i never have to think about the problem again until I go to do S3TC style compressed textures which require different techniques
01:30:36 <magthe> bernalex: ah, that's not a style I've ever used so maybe I should downgrade
01:30:50 <magthe> bernalex: do you use it with vim-ghc-mod?
01:31:03 <bernalex> magthe: yeah
01:31:21 <trap_exit> edwardk hmm, so this is how you write all these libs when trying to wrte 1 app?
01:31:28 <edwardk> yeah
01:31:33 <trap_exit> it's like " i need to write an app --- every annoyance I run into along the way becomes a library"
01:31:47 <magthe> bernalex: and no issues with using latest vim-ghc-mod with an old ghc-mod?
01:31:51 <tdammers> sure... that sounds like an excellent strategy
01:31:58 <edwardk> solve the sub-problem for good in a way that tries to be truest to what it wants to be, not necessarily just to my app
01:32:07 <edwardk> it optimizes for throughput over fitness for a given task ;)
01:32:32 <bernalex> magthe: I run git HEAD of vim-ghc-mod. what that thing does is just put ghc-mod in vim, so it doesn't really care about what ghc-mod itself does. and ghc-mod just presents errors from ghc, so most errors/bugs should actually be from ghc itself, heh.
01:32:34 <trap_exit> edwardk: why do most people not do this / become as productive as you?
01:32:58 <edwardk> i then pop the stack if i still have energy, and if i don't then i go do whatever it is that is making me excited at the time, because i'll be more productive there
01:33:13 <edwardk> hopefully next time i iterate down and need a thing i can build on what it is i splatted out the first time
01:33:21 <trap_exit> edwardk: do you do haskell for a living? and if not, how do you have so much free time to hack haskell ?
01:33:32 <magthe> bernalex: that's good news to me :)  I was worried about some API issues when combining old and new in that way
01:33:40 <edwardk> what i like about haskell is that it is the first language i've worked in where i can actually achieve that code reuse i've wanted my whole career
01:33:46 <bernalex> magthe: no I readily downgrade ghc-mod whenever it does something stupid.
01:34:00 <edwardk> most of my work is in haskell these days, it was mostly in scala up until a year or so ago
01:34:19 <ddellacosta> this seems ugly and slow too, is there not a function that can return a list minus a value at a specific index? (fst (splitAt 4 ks)) ++ (tail (snd (splitAt 4 ks)))
01:34:27 <magthe> bernalex: thanks!  this'll reduce irritation by a magnitude or so
01:36:17 <bernalex> magthe: great!
01:37:10 <angerman> Are there unofficial haskell-platform packages for debian 6 or 7? Debian 6 shippes with a 2010 edition and 7 with a 2012 edition
01:37:12 <edwardk> trap_exit: anyways i think a large part of why more folks don't work that way  is it is a.) exhausting and b.) most people have to work on a particular project. they have a problem and they need to find a solution or they are a researcher and have a solution and are looking for a problem its suited to ;)
01:37:28 <edwardk> i'm pretty happy to sit in the middle and wire up problems to solutions, i find it very soothing to do =)
01:38:45 <bernalex> edwardk: how much documentation do you do? my workflow is 1. write API/DOC/whatever of how I want to use a feature. 2. write tests for how the feature should behave. 3. write morphisms (i.e. typesigs) it needs. 4. document morphisms. 5. get code for free because of steps 1 through 4.
01:38:58 <edwardk> if you think about it as a search strategy, you don't want to search from one side of a space for the other, you want to search from both ends and feel towards the middle, it cuts the exponent in your search space down. rather than hold a dozen problems and look for solutions, or hold a dozen solutions and look for problems i'd rather hold a half dozen of each
01:39:29 <bernalex> so most patches end up 5/10 documentation, 4/10 tests and 1/10 code, heh.
01:39:41 <edwardk> bernalex: i pretty much do none of those things except #3 and writing the code in parallel. i let the types inform what can be written and the term inform the type i need
01:40:05 <edwardk> and sit there and consciously debate about all the alternatives to what it is i just wrote
01:40:24 <edwardk> i very much don't write documentation until the jumping ball has cooled down a fair bit =)
01:40:29 <bernalex> edwardk: well not doing #1 is kind of evil when you are writing an API or library for frontend engineers
01:40:36 <edwardk> so everyone tells me
01:40:50 <kadoban> XD
01:40:58 <edwardk> and yet folks build on my APIs a lot =P
01:41:03 <fread2282> so I'm trying to create a "buffers" library (like you would see in a text editor). the design I have in mind is buffer transformers, so say UndoT (PointT (IntervalMapT RopeBuffer)), with mtl like classes. however, the behaviour is dependant on interaction between layers and therefore the order in which they are composed, any ideas on alternate approaches?
01:41:14 <bernalex> edwardk: do javascript/html/css people build on your APIs a lot?
01:41:17 <kadoban> If you're successful enough, I guess other people will do that part for you, either conciously or accidentally.
01:41:28 <edwardk> bernalex: yes. i can write javascript too
01:41:40 <bernalex> edwardk: I meant on your haskell stuff
01:41:47 <bernalex> edwardk: but I guess you write haskell libraries for haskell users mainly
01:41:58 <edwardk> and yes there too
01:42:27 <edwardk> https://www.youtube.com/watch?v=o3m2NkusI9k talks a bit about what it is we do with FP here at work
01:44:40 <edwardk> bernalex: anyways my experience is typically that iterating the design rapidly is more valuable than the waterfall development model or the agile over-emphasis on 'user story'. i find that by the time i get done with either of those two processes i just want to go curl up in a corner and die =P
01:45:04 <edwardk> so in the meantime while folks wrote their docs i tried out 6 apis, ruled out 4 and came back with 2 alternatives to merge
01:45:22 <bernalex> edwardk: I hate both of those models too
01:45:31 <edwardk> i find that discovery phase to be the most valuable tool i have
01:46:12 <bernalex> edwardk: I like writing a growable codebase and then growing it a feature at the time without all the formalities of "development models"
01:46:15 <edwardk> once i'm done with it i know pretty well what stories actually make sense from an agile perspective, and i can know what i can accomplish from the waterfall, and i have a sense of what is worth testing
01:46:44 <bernalex> edwardk: & if I get distracted and think "maybe I could rewrite this in that way" I just go for it and try it out. if it doesn't work out, I don't merge it. simple as that.
01:46:58 <edwardk> so i'm a big fan of just trying out a straw man
01:48:06 <bernalex> edwardk: the stuff I'm working on ATM usually has some obvious features that some frontend guy can come and say "I would like this", so the API docs is usually for free via that. then how it must behave is for free via that. then the code is for free via that. but the latter part is always open for experimentation. I enjoy getting things for free. means I can spend a lot of time golfing the code. :-P
01:48:54 <ddellacosta> edwardk: re: agile vs. waterfall, seems like your method is more truly "agile"
01:48:58 <edwardk> once i have an idea of what a project wants to be when it grows up i believe in going nuts with documentation ;)
01:49:12 <ddellacosta> lately I'm not really sure what that means, or maybe I never really knew...
01:49:13 * hackagebot uu-cco 0.1.0.1 - Utilities for compiler construction: core functionality  http://hackage.haskell.org/package/uu-cco-0.1.0.1 (AtzeDijkstra)
01:49:32 <edwardk> ddellacosta: sok, as far as i can tell most folks who do agile don't know what it means either.
01:49:41 <ddellacosta> ouch, haha
01:49:57 <bernalex> "agile" is the worst
01:50:01 <edwardk> one thing that works very well for me is pair programming or working with anyone else on a project
01:50:06 <tdammers> re agile vs. waterfall: they're both lies
01:50:06 <bernalex> I'd take waterfall over "agile". it tends to be more agile.
01:50:20 <edwardk> i on my own will go off in some direction and do a thing, and it may seem somewhat absurd
01:50:21 <ddellacosta> I've found that there are a lot of useful ideas to take away from so-called "agile"
01:50:28 <ddellacosta> but as soon as you make them into a dogma they become problematic
01:50:32 <edwardk> paired with someone who cares about a project i'll stay on task and get stuff done
01:50:32 <ddellacosta> same as many things, really
01:50:37 <tdammers> speccing out a project completely before writing the first line of code? that's absurdly impossible.
01:50:39 <ddellacosta> pair programming is definitely one of them
01:50:44 <ddellacosta> can be really really useful
01:50:45 <edwardk> so a lot of the focus in my libraries comes from having someone who wants to work with me on it
01:50:49 <tdammers> changing course radically every week? equally absurd.
01:51:06 <tdammers> what really happens is that you have meetings and write up requirements and all
01:51:22 <fread2282> here's what I have in mind: http://lpaste.net/3957818187239653376
01:51:28 <bernalex> edwardk: my focus comes from our client would like feature X for his presentation so that we get lots of money. :-P
01:51:36 <tdammers> and then you start building stuff, and ideally you use whatever you learn about the problem to change your design on the fly
01:52:04 <ddellacosta> I mean, what edwardk is describing sounds really similar to the most productive workflows I've had--we tend to make stuff, show it to people/test it out with real users, get feedback, iterate, and then we get closer to the thing we really need to build
01:52:17 <tdammers> sure sure
01:52:29 <ddellacosta> and we use some "agile" tools along the way, but we aren't explicitly "agile"
01:52:33 <tdammers> indeed
01:52:45 <tdammers> the problem, I think, isn't so much being agile in the actual sense of the word
01:52:55 <ddellacosta> yeah. :-/
01:52:59 <tdammers> the problem is trying to formalize the workflow and then being religious about it no matter what
01:53:08 <ddellacosta> yeah, exactly.
01:53:12 <ddellacosta> 100% agreed
01:53:37 <tdammers> like when you happen to come into the office early, get into a good flow, and start bashing out some features you've been thinking about for the past few days
01:53:38 <edwardk> tdammers: i try to avoid finding myself in that situation. if i'm stuck in design meetings with a bunch of non-technical people i'm probably not being effectively leveraged. i mostly show up when you have a bunch of technical folks who are stuck and need a way out and rush through a dozen tricks to figure out what can unstick the project, and do the next thing.
01:53:59 <dfeuer> tdammers, my brother in law works for a company that does a lot of agile stuff, and they do indeed know how to do it well. They hyperfocus on keeping everything incremental.
01:54:01 <ddellacosta> edwardk: in that case, I mean, wouldn't you say the tech folks are your "users?"
01:54:04 <tdammers> but then at 9:30 it's time for the standup, so you have to drop whatever you're doing and have a pointless round of "hi my name is tdammers and I'm agile"
01:54:14 * hackagebot uu-cco-examples 0.1.0.1 - Utilities for compiler construction: example programs  http://hackage.haskell.org/package/uu-cco-examples-0.1.0.1 (AtzeDijkstra)
01:54:14 <ddellacosta> sorry, I don't mean to formalize it...I should shut up...haha
01:54:16 * hackagebot uu-cco-hut-parsing 0.1.0.1 - Utilities for compiler construction: Feedback wrapper around parser in uulib  http://hackage.haskell.org/package/uu-cco-hut-parsing-0.1.0.1 (AtzeDijkstra)
01:54:18 * hackagebot uu-cco-uu-parsinglib 0.1.0.1 - Utilities for compiler construction: Feedback wrapper around parser in uu-parsinglib  http://hackage.haskell.org/package/uu-cco-uu-parsinglib-0.1.0.1 (AtzeDijkstra)
01:54:21 <bernalex> edwardk: hey do you know some useful minimalistic way of playing audio in haskell? MPEG 1.0/2.0/2.5 layers I, II, III [mpg123] / 16000 Hz, 2 ch, s16le, 32.0 kbit/6.25% (ratio: 4000->64000)
01:54:40 <ddellacosta> dfeuer: incremental is key, absolutely
01:54:58 <edwardk> bernalex: never needed to, nope =P
01:54:59 <ddellacosta> anyways, will let you folks actually talk about Haskell again. :-)
01:55:05 <dfeuer> and they have *good* business analysts to keep the programmers in communication with the customer without bogging everyone down in meetings...
01:55:16 <tdammers> edwardk: my problem right now is that, in a relative way, *anyone* I could possibly meet with here is kind of non-technical
01:55:22 <bernalex> edwardk: my current way of doing it is running mplayer :-P
01:55:33 <edwardk> dfeuer: the main concern i have with waterfall is that it can't change course. the main concern i have with agile is it can't think any thought it can't fit into a sprint =P
01:55:57 <vlatkoB_> I have "data T = A Text | B Text ..." and need to search for "A,B..." in [T] by its Text.
01:55:58 <vlatkoB_> Is it possible to do it without "tupling" in container or pattern matching for each?
01:55:58 <edwardk> dfeuer: as long as you never need to try to cross that chasm in two jumps agile works great
01:56:37 <dfeuer> edwardk, well, in any sane company, there's room for necessary variation.
01:56:40 <tdammers> I think the problem with agile is that it's relatively hard to keep the big picture in mind
01:57:13 <tdammers> I mean, you *can*, and you *have to*, but agile doesn't really do anything to support it
01:57:28 <edwardk> i'm mostly trying to do 'type driven development' these days, start in a space, write down a bunch of types for describing it, write down all the instances for those things that can exist, and then understand the problem through the insights that gives me into how to structure it nicely
01:58:20 <bernalex> so -- anyone know a truly simple way to play an mp3? and that's all I need really. just play an mp3. no pause no nothing.
01:58:23 <edwardk> tdammers: my statement was very tongue in cheek, and folks who are good at that whole scrummaster thing, like ReinH know its not just about assigning scores and tracking velocities
01:58:58 <edwardk> velocity is a terrible metric to me. it doesn't matter how fast you can go if you are going in the wrong direction
01:59:02 <tdammers> edwardk: yes, I know. my gripe is more with formalized "agile" exercised by lesser minds than with the actual idea
01:59:11 <edwardk> the idea is fine
01:59:18 <tdammers> agile development, as a concept, is the way to go IMO
01:59:32 <edwardk> i use to be a big proponent of much of 'extreme programming' and the like too =)
01:59:32 <tdammers> but just like democracy, you cannot force it to exist
01:59:55 <tdammers> a formal majority voting system doesn't create a democracy out of thin air
02:00:12 <tdammers> and daily standups and story points don't create agile development out of thin air
02:00:37 <ddellacosta> I know it's not Haskell-specific but this is a fantastic conversation and is confirming a lot of things I've been realizing in the past year, after going waterfall -> agile -> something in between through the course of my career.  Really ringing true
02:00:38 <tdammers> embrace the spirit, see about formalizing rules for your team later
02:00:42 <edwardk> i'm pretty much of the 'vote with your code' mindset. write the code, if others like it merge it, write more code.
02:01:00 <edwardk> if someone wants a feature and they implement it? existence has a lot of power. code that does it is very compelling
02:01:04 <tdammers> if you have enlightened management, yes, by all means
02:01:07 <edwardk> it'll win over my apathy
02:01:29 <sopvop> my management has no idea what I'm doing
02:01:34 <edwardk> tdammers: i don't see much point in wasting time some place where you don't ;)
02:01:52 <tdammers> well
02:02:18 <tdammers> let's just say, the notion that "writing code is expensive, so I don't want my developers to write any code without my blessing" is, sadly, very common
02:02:31 <edwardk> tdammers: and its absolutely fucking toxic
02:02:35 <tdammers> I know
02:02:38 <edwardk> tdammers: when i detect it i leave
02:02:55 <tdammers> then you're in a luxury position
02:03:28 <edwardk> i pretty much try everything i can to up the ability of folks around me to write code and the speed at which they can write it
02:03:30 <edwardk> 'upping velocity'
02:03:36 <edwardk> and then use the rather frenetic pace we get to explore more options =P
02:04:07 <jle`> vlatkoB_: how do you want the result to look like? i'm not quite sure what you mean
02:04:07 <edwardk> succeed enough at that and you can have that luxury
02:04:31 <tdammers> yeah, hmm... thing is, we're not in the business of writing code
02:04:38 <tdammers> we're in the business of selling websites
02:04:44 <tdammers> writing code is just a corollary
02:04:59 <edwardk> yeah there's a reason im not in that business
02:05:01 <edwardk> =)
02:05:05 <tdammers> shame though
02:05:11 <tdammers> 'cause I'm good at the web programming stuff
02:05:14 <vlatkoB_> jle`: The result would be the constructor, i.e. A "Some"
02:05:31 <jle`> hm. can you state your function's type?
02:05:39 <tdammers> writing a toy http server is one of my "hello world" exercises
02:05:46 <bernalex> heh. couldn't find anything capable of merely playing an mp3 file in http://hackage.haskell.org/packages/#cat:Sound except for applications rather than libraries. ugh.
02:06:20 <tdammers> I've been doing this for quite a while, I'm good at it, I understand how the tools work, and how to structure things in such a way that you don't end up in a terrible spaghetti mess a year down the road
02:06:24 <jle`> vlatkoB_: or at least give sample inputs and outputs?
02:06:32 <tdammers> but I hardly get the chance to play my strengths here
02:06:34 <ddellacosta> tdammers: are you using Haskell?
02:06:44 <tdammers> ddellacosta: only on my hobby projects, sadly
02:06:50 <ddellacosta> tdammers: ah, was just curious
02:06:58 <ddellacosta> and kind of figured that may be the answer
02:07:06 <tdammers> ddellacosta: frankly, PHP is already too difficult for most folks here
02:07:19 <ddellacosta> tdammers: here being where you work?
02:07:22 <tdammers> ya
02:07:33 <ddellacosta> tdammers: actually, PHP is very hard to code well. It's such a confusing mess. :-p
02:07:39 <edwardk> i built an online video store at the end of 94, had to sell it in 96 to pay legal fees, built a few sites later for the ISP / phone company we built after, but I generally avoid web development. It pretty much sucked the life out of me
02:07:52 <tdammers> ddellacosta: it is. but nobody in web dev seems to have any desire to write good code
02:07:53 <jle`> it literally takes a genius
02:08:06 <vlatkoB_> jle`: I have it in map Text T now, but to put it in map, must create a tuple (Text, A Text). I thought it would be nice to avoid tuples with redundant data, and have only list, [T].
02:08:08 <ddellacosta> I'd like to move on from web development, but for now it pays the bills.  Part of why I'm spending time learning Haskell actually
02:08:26 <tdammers> and then when they manage to produce something that doesn't break all the time and is about 75% of what I consider bearable, they celebrate
02:08:36 <tdammers> so yeah
02:08:37 <ddellacosta> tdammers: yeesh...haha
02:08:42 <jle`> vlatkoB_: still can't understand what your function is trying to do
02:08:51 <jle`> can you give a type signature, or example input/output?
02:08:59 <tdammers> ddellacosta: look into Silex. Apparently, that's the best web framework the PHP community has
02:09:12 <sopvop> tdammers: I write good code in webdev. Also, #haskell-blah
02:09:14 <edwardk> tdammers: ultimately that is the problem with web development there is little incentive to shore up a thing, make it look good and cash out
02:09:29 <edwardk> i mean you can find polish here and there
02:09:31 <tdammers> sopvop: yeah, haha, off to -blah
02:09:41 <tdammers> edwardk: yes, indeed...
02:09:42 <edwardk> but anyways, this is blah material =)
02:09:46 <ddellacosta> yep. :-)
02:09:56 <bernalex> edwardk: the way we web develop is "make really cool stuff and see if anyone wants it". :-]
02:09:59 <edwardk> and i need sleep
02:10:08 <tdammers> edwardk: I'm surprised
02:10:23 <tdammers> edwardk: the man behind lens and trifecta sleeps?
02:10:26 <edwardk> bernalex: strange, thats how i do library development ;)
02:10:49 <bernalex> edwardk: our web development are libraries ;-)
02:10:53 <fread2282> I'm trying to design a "buffers" library, a sketch is http://lpaste.net/3957818187239653376 , feedback/ideas appreciated
02:12:05 <vlatkoB_> Those are section titles from a file I'm parsing. Each type of file has its own sections. After parsing, I have Text of titles, and want to convert the Text into types. Currently I have map Text T for conversion.
02:12:24 <edwardk> my creative process: read a bunch of stuff, let it gel in my brain for 6 months, wonder why nobody has done it in haskell, have enough hubris to write down a stab at something different that tries to mash it up with other stuff i know. if it doesn't work retry it another way and every time bang up against a corner of the design space. repeat.
02:12:31 <jack_rabbit> What's the simplest way to generate a random permutation of a list?
02:12:47 <vlatkoB_> jle`: Forgot to mentioned you above
02:13:16 <edwardk> fread2282: what drives you to need a full buffer abstraction over say a simple emacs style gap buffer?
02:14:12 <jle`> vietnguyen: can you write the type signature of the function you want, or show an example list, an example filte,r and an example output, etc.
02:14:18 <jle`> er sorry, vlatkoB_ ^^
02:14:28 <edwardk> fread2282: and is the rope buffer approach based on a completely unbalanced rope or a fingertree or something?
02:14:28 <tdammers> jack_rabbit: simple in what dimension?
02:15:33 <edwardk> i note you're using a rope holding text fragments, have you considered the performance implications of the fact that text is really quite bad at counting characters and doing character offsets?
02:15:47 <fread2282> edwardk: I need an interval map, undo, and point, and I could do it in a monolithic structure. the rope is a fingertree
02:15:58 <jack_rabbit> tdammers, good question. It's a large list. I looked at the permutations library, but generating a random number between 0 and N! to pick a permutation isn't feasible since N is so large.
02:16:28 <vlatkoB_> jle`: The data is [T] = [A "Some1", B "Some 2", C, "Some3"...], function f :: [T] -> Text -> T
02:16:40 <edwardk> so you have a raw rope then an interval map of stuff attached to the rope you need to edit, etc?
02:17:32 <edwardk> fread2282: has a lib i threw out ~4 years ago that was in the design space you are in
02:17:32 <fread2282> edwardk: the rope stores size. yes
02:17:36 <edwardk> http://hackage.haskell.org/package/rope-0.6.4/docs/Data-Rope.html
02:17:42 <vlatkoB_> jle`: f [A "Some1"...] "Some1" = A "Some1"
02:17:59 <edwardk> also based on a fingertree rope
02:18:03 <jack_rabbit> tdammers, how would you suggest I do it?
02:18:26 <fread2282> edwardk: yes, seen it, this is for yi and iirc yi-rope performs better. what's the annotated stuff in your package?
02:18:28 <edwardk> but with 'annotations' attached.
02:18:50 <jle`> what would f [A "Some2"] "Some1" return?
02:19:44 <edwardk> fread2282: the annotations were values carried around by the rope that could use the rope data for context to compute how they change as you edit the rope
02:20:27 <vlatkoB_> jle`: The list element with searched text:  A "Some1". I should have put === in last line
02:20:38 <edwardk> e.g. one might be the count of characters in it, another a set of colors for them, another might be {-# LINE #-} directives or something virtually tracked between tokens
02:21:29 <edwardk> i have a later version of that lying around (called buffers naturally) that gives the annotations a sort of quantifier like feel
02:21:35 <edwardk> but i never really liked any of the points i came up with in that design space
02:21:38 <edwardk> and my need for it melted away
02:21:40 <edwardk> so i moved on
02:21:55 <tdammers> jack_rabbit: two approaches. One, assign a random number to each list element, then sort the list by those numbers.
02:22:09 <tdammers> Two, perform a series of random swaps.
02:23:14 <tdammers> either way, roughly speaking you can pick a sorting algorithm and turn it into a shuffling algorithm with a few minor tweaks
02:23:15 <edwardk> jack_rabbit: is it a list or a vector?
02:23:19 <jack_rabbit> Cool. I decided to recursively remove a random element from the list and prepend it to the new list.
02:23:22 <jle`> vlatkoB_: how about writing a toText
02:23:23 <jack_rabbit> edwardk, list.
02:23:28 <jle`> and using find
02:23:31 <jle`> :t find
02:23:32 <lambdabot> (a -> Bool) -> [a] -> Maybe a
02:23:40 <edwardk> that rules out the easy knuth shuffle being fast
02:23:40 <jack_rabbit> tdammers, but your method would be simpler, I think.
02:23:43 <jle`> find ((== searchedString) . toText)
02:23:56 <jle`> find (\x -> toText x == searchedString)
02:23:59 <edwardk> @google knuth shuffle
02:24:00 <lambdabot> http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
02:24:00 <lambdabot> Title: Fisher–Yates shuffle - Wikipedia, the free encyclopedia
02:24:17 <edwardk> bah
02:24:19 <edwardk> http://en.wikipedia.org/wiki/Random_permutation#Knuth_shuffles
02:24:21 <edwardk> here
02:25:08 <vlatkoB_> jle`: Yes, but toText would mean pattern matching on each. There are many Ts
02:25:12 <edwardk> so take your list dump it in a Data.Sequence, do a knuth shuffle
02:25:29 <edwardk> now it has the right properties
02:25:59 <edwardk> don't just naively randomly swap everything with everything over the list, use the knuth approach, otheriwise you get a crap shuffle. its subtle
02:26:08 <jle`> vlatkoB_: pattern matching on each constructor...?
02:26:30 <jle`> wouldn't you only have to write it once?
02:26:43 <edwardk> the Sequence isn't optimal but doesn't require a second pass to figure out length
02:26:49 <jle`> somewhere else as a helper fybctuib
02:27:59 <edwardk> a better approach would be to build mutable vectors of lengths that grow by successive powers of 2, so you never waste more than 2x space, index into them as if they were a growable array, and do the same shuffle but much faster per element
02:28:01 <edwardk> ymmv
02:28:10 <vlatkoB_> jle`: toText (A t) = ..., ,toText (B t) = .... I do not know any other way.
02:32:01 <jle`> vlatkoB_: i think writing it once somewhere is unavoidable
02:32:07 <jle`> unless you resort to generics or TH
02:34:20 <vlatkoB_> jle`: Yes, I knew that, but always like to confirm. So many ways in Haskell. Who knows. Thanks for help.
02:34:47 <jle`> vlatkoB_: no problem :)  i think that way would be the simplest way for now
02:34:51 <jle`> but...no need to tuple anything up
02:56:36 <n4x> @src reverse
02:56:36 <lambdabot> reverse = foldl (flip (:)) []
02:57:54 <zipper> Is Brent A. Yorgey ever in this channel?
02:58:12 <indiagreen> yeah, e.g. right now
02:58:15 <rtharper> hehe
02:58:20 <rtharper> well, his name is signed in at leasdt
03:01:25 <zipper> indiagreen: Where? What?
03:01:53 <zipper> indiagreen: Are you him?
03:03:20 <dfeuer> No, zipper, byorgey is.
03:03:36 <zipper> byorgey: Oh hey
03:04:46 <clinton> when I write "fix (\x -> 0:(map (+1) x))" I get the list [0,1..]. What I'm trying to do is the same thing but with instead with signature (a -> IO a) -> IO a. But when I do such a thing with mfix it fails with a loop. How do I tie the output of a function which does IO to its input?
03:05:13 <zipper> byorgey: So I am reading the 2014 cs194 lectures but I was wondering which to go with whether with the 2014 or with the 2013 lectures.
03:05:32 <dfeuer> zipper, he's probably asleep.
03:05:52 <zipper> dfeuer: Arrgghhhhhh
03:05:55 <zipper> dfeuer: Ok email
03:06:12 <dfeuer> clinton, mfix, but things have to be lazy enough. Or you could try to use some of those effectful streaming things like pipes and conduit.
03:06:38 <dfeuer> You know, if you're a genius and can understand them at all.
03:06:50 <zipper> Ok anyone know which is better as a learning resource between http://www.seas.upenn.edu/~cis194/ and http://www.seas.upenn.edu/~cis194/spring13/index.html
03:07:08 <dfeuer> Try them both?
03:07:18 <dfeuer> I mean, really?
03:07:24 <clinton> dfeuer: what do you mean "lazy enough"?
03:07:36 <zipper> Same course one taught by  Brent Yorgey in 2013 and the other by Richard Eisenberg in 2014
03:07:52 <zipper> dfeuer: I assume that would take a long time, no?
03:08:01 <dfeuer> clinton, tying knots always requires sufficient laziness or you get a problem. I have t go to sleep.
03:08:12 <zipper> Same course same school. I did the 2014 because it's newer.
03:08:17 <dfeuer> zipper, why don't you start one, and if you hate it, try the next one? For real...
03:08:26 <dfeuer> GOOD NIGHT.
03:08:28 <zipper> dfeuer: Oookkay
03:08:41 <zipper> dfeuer: You sound angry
03:08:48 <dfeuer> I'm really tired.
03:08:53 <dfeuer> And frustrated with other things.
03:08:58 <dfeuer> And your question is very strange.
03:09:04 <dfeuer> REEEALLY tired.
03:09:12 <dfeuer> It's 6am and I kind of forgot to go to sleep.
03:09:37 <MP2E> i do that sometimes too :V
03:09:59 <Axman6> I used to
03:10:35 <Axman6> I realised it was stress
03:10:44 <Axman6> so watch that shit, it's no fun =)
03:11:09 <rai> hello, I'd like a little feedback on a little function I wrote, https://gist.github.com/raine/75ae368148a556e0fc0d -- in particular, 1. how to handle case of elemIndex Nothing 2. should the function return a Maybe
03:11:56 <Axman6> rai: without looking, can the function fail? then it should probably return a Maybe/Either
03:13:39 <Axman6> seems like a good case for using Maybe. Nothing tells you that there is no value x in the list
03:14:08 <rai> yep
03:16:18 <rai> also what do you think, (i + 1) vs. succ 1
03:16:56 <Axman6> I'd personally use i+1 because it's faster, but it depends on what behaviour you care about for macBound :: Int
03:17:07 <Axman6> > maxBound + 1 :: Int
03:17:09 <lambdabot>  -9223372036854775808
03:17:14 <Axman6> > succ maxBound :: Int
03:17:15 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
03:27:34 <lericson> > maxbound
03:27:35 <lambdabot>  Not in scope: ‘maxbound’
03:27:36 <lambdabot>  Perhaps you meant ‘maxBound’ (imported from Prelude)
03:27:37 <lericson> > maxBound
03:27:39 <lambdabot>  ()
03:29:11 <Ferdirand> :type maxBound
03:29:15 <Ferdirand> :t maxBound
03:29:15 <lambdabot> Bounded a => a
03:44:26 * hackagebot hakyll 4.6.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.0.0 (JasperVanDerJeugt)
03:56:58 <glaukon> I have a problem with heap overflow when doing tree+zipper construction with large datasets. Created stackoverflow.com post, see http://stackoverflow.com/questions/26633143/haskell-avoiding-heap-overflow-in-treezipper-construction
04:24:30 * hackagebot fraction 0.1.0.3 - Fractions  http://hackage.haskell.org/package/fraction-0.1.0.3 (WolfgangJeltsch)
04:24:32 * hackagebot whiskers 0.1.0.3 - Mustache templates with Template Haskell.  http://hackage.haskell.org/package/whiskers-0.1.0.3 (peter)
04:37:23 <rfw> @pl foldr (\x xs -> if p x then x:xs else xs) []
04:37:23 <lambdabot> foldr (join . ap ((.) . if' . p) (:)) []
04:37:53 <rai> what is @pl?
04:38:00 <dibblego> rai: pointfree
04:38:16 <dibblego> rfw: foldr (\x -> if p x then (x:) else id) []
04:38:33 <dibblego> @where pointfree
04:38:33 <lambdabot> http://haskell.org/haskellwiki/Haskell/Pointfree
04:38:34 <rfw> dibblego: can i get rid of the if?
04:38:43 <dibblego> rfw: you can use Data.Bool#bool
04:38:45 <rfw> this isn't for anything practical, don't worry
04:38:57 <dibblego> rfw: I know what it is :)
04:39:02 <rfw> haha sure
04:39:10 <dibblego> it is an exercise that I have taught several times
04:39:25 <dibblego> foldr (\x -> bool id (x:) (p x)) []
04:39:37 <dibblego> getting rid of \x -> is an exercise for you
04:39:44 <rfw> haha
04:41:57 <grayling_> Anyone knows an efficient way of converting ["a","b","c"] to [(1,"a"),(2,"b"),(3,"c")] ?
04:42:24 <dibblego> grayling_: `zip` [1..]
04:42:35 <pjdelport> > zip [1..] ["a","b","c"]
04:42:36 <lambdabot>  [(1,"a"),(2,"b"),(3,"c")]
04:43:12 <grayling_> Wow. That was fast. I'll take a look at zip. Thanks all!
04:43:47 <pjdelport> :t zip
04:43:48 <lambdabot> [a] -> [b] -> [(a, b)]
04:44:11 <Shammah> :t abrupt
04:44:12 <lambdabot> Not in scope: ‘abrupt’
04:44:32 * hackagebot HMap 1.1.6 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.6 (AtzeVanDerPloeg)
04:45:14 <pjdelport> rfw: There's a helper function that i like: guarded p x = bool empty (pure x) (p x)
04:45:40 <pjdelport> rfw: which lets you write the above as: foldr ((<|>) . guarded p) empty
04:45:52 <pjdelport> which i think is rather nifty.
04:45:57 <rfw> oh, that's cool
04:47:04 <pjdelport> (This "guarded" is very similar to the usual MonadPlus "guard", except it gives you the predicate-guarded value in an Alternative instance.)
04:49:33 * hackagebot HMap 1.1.7 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.7 (AtzeVanDerPloeg)
04:49:43 <Shammah> :t fmap
04:49:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:49:49 <pjdelport> In fact, you can make the above even more succinct and just say: filter' p = foldMap (guarded p)
04:51:12 <pjdelport> Or just foldMap . guarded :)
04:51:41 <grayling_> I guess I should have looked in Prelude before askin'...
04:52:03 <dibblego> grayling_: you might have tried to construct your question as a type
04:52:05 <pjdelport> grayling_: Note that you can actually search Hoogle by type signature.
04:52:15 <dibblego> @hoogle [a] -> [b] -> [(a, b)]
04:52:17 <pjdelport> @hoogle [a] -> [b] -> [(a, b)]
04:52:17 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:52:18 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
04:52:18 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
04:52:18 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:52:18 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
04:52:19 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
04:52:30 <dibblego> pjdelport: I'm going to bed. You have the ball :)
04:52:39 * dibblego taps out
04:52:47 <pjdelport> dibblego: Night. :)
04:53:31 <grayling_> pjdelport: I'll do that next time. It's good advice.
05:03:17 <clrnd> so I'm using wreq to write a REST client, the problem is I don't know how to issue a PATCH request
05:12:59 <mmachenry> Does anyone know of a Haskell library that can extract chord information from audio?
05:13:37 <jeltsch> mmachenry: I think the problem of extracting notes from audio is actually quite a hard one.
05:13:58 <mmachenry> jeltsch: Yeah that's why I don't want to do it :)
05:14:02 <jeltsch> mmachenry: Do you know of any open-source solutions to it?
05:14:16 <jeltsch> mmachenry: Including non-Haskell ones?
05:14:24 <mmachenry> I'm looking for something like Shazzaam that I can interface with.
05:14:31 <mmachenry> No I don't.
05:14:57 <jeltsch> What is Shazzaam?
05:15:06 <mmachenry> I know the Shazaam folks wrote a paper about how they did it.
05:15:17 <jeltsch> Do you have a URL of this paper?
05:15:23 <mmachenry> Shazzaam is a smart phone app that recognizes songs.
05:15:53 <mmachenry> http://www.ee.columbia.edu/~dpwe/papers/Wang03-shazam.pdf
05:15:57 <bergmark> mmachenry: not sure how much chordify has open sourced, they have done it in haskell nonetheless http://chordify.net/
05:15:59 <jeltsch> Ah, this explains why I don’t know about it. I am using a phone that is not smart.
05:16:48 <mmachenry> bergmark: Oh this is helpful.
05:17:57 <jeltsch> mmachenry, bergmark: Thanks for these pointers.
05:21:43 <supki> clrnd: it looks like it's impossible with wreq
05:22:03 <clrnd> supki, HTTP.Types also doesn't have a PATCH type
05:22:08 <supki> it does not provide any helpers to do it and also does not allow to perform requests with a custom method
05:22:15 <supki> hmm
05:22:24 <clrnd> I'm already patching the REST server, don't worry
05:24:01 <ChristianS> a patch for PATCH!
05:24:36 * hackagebot grapefruit-frp 0.1.0.5 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.5 (WolfgangJeltsch)
05:24:38 * hackagebot grapefruit-records 0.1.0.5 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.5 (WolfgangJeltsch)
05:24:40 * hackagebot grapefruit-ui 0.1.0.5 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.5 (WolfgangJeltsch)
05:24:42 * hackagebot grapefruit-ui-gtk 0.1.0.5 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.5 (WolfgangJeltsch)
05:29:37 * hackagebot grapefruit-examples 0.1.0.5 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.5 (WolfgangJeltsch)
05:30:38 <metaalbek> How to assign a variable like in java???
05:31:13 <clrnd> metaalbek, a = 5
05:31:46 <metaalbek> but how to do it after it's already assigned?
05:31:52 <geekosaur> you don't assign to variables, there are no variables as such
05:32:03 <metaalbek> WAT?
05:32:17 <metaalbek> haskell sucks omg java is better
05:32:30 <geekosaur> you rephrase in terms of passing data around, possibly using something like State to carry it implicitly
05:32:31 <jeltsch> metaalbek: Please don’t make such quick conclusions.
05:32:50 <jeltsch> metaalbek: Often you solve problems just differently than in Java, without mutable variables.
05:33:07 <metaalbek> ok thanks i will try it
05:33:18 <metaalbek> NOT!!!!!
05:33:30 <mmachenry> metaalbek: Assignment to variables and more generally changes in dynamic state is considered to be large source of bugs by people who embrace functional programming.
05:33:34 <jeltsch> The absence of mutability is actually a win. You don’t have to worry what the current value of a variable is (it is always the same). This make working with data structures like trees a lot easier and less error-prone.
05:34:33 <jeltsch> You do not update data, but you create a new variable for the new data. So you can access the old data and the new data, and you are always explicit in which version you mean.
05:34:37 * hackagebot linux-namespaces 0.1.1.1 - Create new or enter an existing linux namespaces  http://hackage.haskell.org/package/linux-namespaces-0.1.1.1 (MariosTitas)
05:37:39 <tdammers> too late
05:38:51 <clrnd> hey is there syntax for only matching the type constructor? like 'fun t@(Tree #)' instead of 'fun t@(Tree _ _ b _)'
05:39:10 <geekosaur> t@(Tree {})
05:39:16 <clrnd> geekosaur, +1
05:42:57 <Total_1mmersion> Why isn't the type of "f" here (T a -> Bool -> Bool)? data T a where T1 :: Bool -> T Bool; T2 :: T a; f x y = case x of T1 _ -> True; T2 -> y
05:42:58 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
05:42:58 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
05:45:42 <derpherp> hello
05:46:00 <Zyxoas> Total_1immersion: What values are you giving your function? You are giving it x and y, x being a T and y some value of some type. You also expect to return a Boolean, so since you return y half the time, y has to be a Boolean.
05:46:36 <derpherp> can i have admin?
05:47:01 <nshepperd> it's troll hour, is it?
05:47:07 <Zyxoas> So the type is T -> Bool -> Bool, isn't it? What are you getting instead?
05:48:05 <derpherp> i have good computer so i can be online 24/7
05:49:10 <derpherp> ...
05:49:14 <derpherp> pls
05:49:43 <bergmark> :-)
05:49:43 <derpherp> pls respond, i'm from india
05:49:43 <nshepperd> derpherp: to answer your question, there's no need to assign a variable, you can just create a new one instead
05:50:05 <derpherp> ok thanks
05:50:12 <derpherp> it's strange language
05:50:26 <derpherp> i need 2 program for money for family
05:52:06 <derpherp> Is it right that basically f-algebras can be used to encode algebraic laws into a functor?
05:52:17 <derpherp> Because i don't get it 100%
05:52:19 <nshepperd> for cases where you need to loop over a list or something where you would assign a variable in java, you can write it as a fold instead
05:52:35 <nshepperd> or indeed use State
05:53:47 <derpherp> Sorry im schizophrenia i ask stupid questions sometimes
05:55:45 <nshepperd> https://www.fpcomplete.com/user/bartosz/understanding-algebras talks about it but I haven't learned this yet
05:57:22 <hellertime> this is odd. I 'cabal installed' a local package into a sandbox
05:57:44 <funrep> is there any word for not recursive?
05:57:46 <hellertime> but when I run 'cabal repl' in the sandbox it says it cannot resolve the package-id…
05:58:03 <hellertime> the weird thing is the hash its trying to resolve is not the same as the hash of the package in the sandbox…
05:58:19 <hellertime> I don't understand where its getting this other hash from… odd
05:59:31 <hellertime> can I somehow get cabal to remove all reference to a package in a sandbox?
06:02:04 <supki> hellertime: sometimes you need to manually run cabal configure after you install a new package for cabal to pick it up
06:02:09 <supki> I'm not sure why
06:02:33 <Total_1mmersion> hellertime: check out cabal hc-pkg. Try something like cabal hc-pkg -- unregister foo
06:03:25 <benzrf> funrep: n-not recursive?
06:03:55 <derpherp> racists why u no respond to indian mans???
06:04:33 <derpherp> im gonna write my own language with assignments bye!
06:04:50 <derpherp> i will call it derpskell
06:04:58 <funrep> benzrf: yes, teacher said "i = i + 1;" in C++ was "recursive" but if it were that would be a endless loop, or does recursive mean something else in c++?
06:05:01 <CaveJohnson> derpherp: r u ok
06:05:14 <benzrf> funrep: that is absoliutely not recursive
06:05:17 <benzrf> it would be in haskell
06:05:19 <benzrf> not in c
06:05:22 <funrep> yes
06:05:25 <nshepperd> oh, this F-algebra stuff is just catamorphisms
06:05:32 <funrep> so what is not recursive called? (ie the above)
06:05:33 <benzrf> nshepperd: n-not precisely?
06:05:34 <nshepperd> it all makes sense now
06:05:35 <benzrf> funrep: dunno
06:05:39 <funrep> okey
06:06:03 <derpherp> no i get ignored
06:06:04 <derpherp> but ok
06:06:06 <derpherp> i will return
06:06:37 <derpherp> first im going to cook dinner for family
06:06:55 <nshepperd> well, the thing before catamorphisms
06:09:21 <hellertime> ok 'cabal configure' seems to have fixed the hash issue.. now I'm just getting a dynlib error about missing symbols in a flat namespace…
06:09:28 <hellertime> might be [GHC] #9384
06:10:16 <hellertime> … or maybe I just didn't export the module!
06:12:17 <udevd> hi ! I'm using Data.Packed.Matrix. When i do something like this: 2*matrix (multiplying matrix by scalar), everything works... in ghci. When I want to import module containing such expression (multiplying matrix by scalar) to GHCI, it complains that this scalar is not a matrix
06:13:24 <bernalex> can someone inform me of a way to drastically improve this: http://lpaste.net/5187425727326191616 ?
06:14:04 <vozz> How do you uncurry a 3 arg function to take a triple?
06:14:11 <justinbieber> Baby baby ooohhhhhhhhhhhhhhhh
06:14:12 <bernalex> vozz: uncurry3
06:14:20 <vozz> thanks :)
06:15:02 <justinbieber> i'm going to sing about haskell in my new single
06:15:24 <bernalex> it should just be like uncurry3 f (x,y,z) = (f x, f y, f z) -- or whatever.
06:16:20 <bernalex> oh right I understand what you meant now
06:16:47 <bernalex> I guess I answered that too though. so that's OK.
06:17:01 <CaveJohnson> dat tragicsans
06:17:03 <CaveJohnson> uh
06:17:05 <CaveJohnson> dat Transfusion
06:17:11 <bernalex> now someone tell me how to make my terrible code better
06:17:45 <tdammers> bernalex: delete the lines that are terrible and replace them with lines that are awesome
06:18:00 <bernalex> tdammers: yes I'm wondering if someone could provide me with the awesome ones
06:18:21 <tdammers> feel free to copy a few from my bitbucket repo
06:18:39 <bernalex> I don't think there are any in there that do exactly what my paste does
06:19:05 <justinbieber> transfusions is clojure style and its for noobs
06:24:45 <bartavelle> bernalex, traverse ?
06:25:04 <bartavelle> what is =. here ?
06:25:38 <bernalex> bartavelle: persistent stuff for updating a field
06:26:08 <bartavelle> something like traverse (TimespanBeginMin =.) maybeBeginMin
06:26:21 <bartavelle> or fold
06:26:37 <bernalex> bartavelle: I guess that could make sense too
06:27:18 <bartavelle> forM actually, not fold :/
06:27:24 <bartavelle> or mapM
06:27:51 <chrisdone> i was thinking about writing a tiny lisp which would just be lambda calculus plus quotation
06:28:04 <chrisdone> as a GADT in haskell it's easy to make such a thing type-checked
06:28:14 <chrisdone> but i was thinking about supporting EVAL in the language
06:28:19 <benzrf> chrisdone: i made a shitty tiny lisp once!
06:28:25 <clrnd> in 48hs?
06:28:26 <benzrf> it had runtime macros and runtime-enforced purity
06:28:29 <ClaudiusMaximus> bernalex: instead of [ fromJust x | isJust x ], how about [ x | Just x <- [y] ]
06:28:39 <bartavelle> bernalex, oh don't worry, I suppose you can just catmaybes [ (TimespanParent   =.) <$> maybeParent, ... ]
06:28:45 <chrisdone> i see
06:28:46 <bernalex> ClaudiusMaximus: won't that give me "TimespanFoo = []" when it fails?
06:29:06 <chrisdone> anyway, i reckon if all quotations of the form 'foo have type Sym Symbol
06:29:20 <chrisdone> and all quotations of the form #foo have type Sym T where foo :: T
06:29:29 <chrisdone> then you can also add a compile-time safe EVAL =)
06:29:32 <ClaudiusMaximus> bernalex: i meant more like [ TimespanFoo .= x | Just x <- [y] ], so that whole list becomes []
06:29:40 <chrisdone> (where eval :: Sym t -> t)
06:29:41 <bernalex> ClaudiusMaximus: aha
06:30:27 <chrisdone> the problem with classic untyped lisp is that (eval 'nonexistent) is a runtime error, and that ((eval '+) nil nil) is a runtime error
06:31:26 <chrisdone> whereas (eval 'nonexistent) would produce 'nonexistent, and (eval #nonexistent) would produce a compile error. and ((eval #+) nil nil) would be a compile-time error =)
06:33:19 <chrisdone> this stuff is pretty much why haskell is not a lisp
06:33:37 <chrisdone> it has no symbolic quotation
06:34:15 <yesthisisuser> How does one get the actual byte length (size) of a ByteString?
06:34:23 <Hodapp> Let's make a homoiconic Haskell.
06:34:53 <chrisdone> Hodapp: homoiconic isn't really the essence of lisp imo
06:35:29 <chrisdone> you can write 'foo in ML syntax. ATS (an ML) supports quotation
06:35:29 <Hodapp> You're right. Add some parenthesis.
06:35:35 <chrisdone> parenthesis neither
06:35:59 <Hodapp> We can call it Hathkell?
06:36:44 <tdammers> yesthisisuser: the length of a bytestring *is* its byte count
06:36:57 <tdammers> yesthisisuser: what other length do you thing you'd get?
06:36:58 <chrisdone> yesthisisuser: do you mean how much as stored in memory?
06:37:19 <yesthisisuser> i thought it was the number of characters..
06:37:58 * chrisdone shakes yesthisisuser 
06:38:03 <chrisdone> getaholdofyourself!
06:38:08 <geekosaur> it's a bytestring, thereis no difference
06:38:20 <chrisdone> well, there is
06:38:25 <chrisdone> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) -- payload
06:38:25 <tdammers> bytestrings contain bytes, not characters
06:38:25 <chrisdone>                      {-# UNPACK #-} !Int                -- offset
06:38:26 <chrisdone>                      {-# UNPACK #-} !Int                -- length
06:38:57 <nshepperd> if ByteStrings would have a concept of characters, someone has made a grave misjudgement
06:39:00 * geekosaur thinking of the difference between bytes and characters due to encoding
06:39:16 <geekosaur> but ByteString is not about character encoding
06:39:25 <tdammers> well, you can of course encode a character string and store it in a bytestring
06:39:36 <tdammers> but the bytestring doesn't care about that
06:39:39 <bartavelle> bernalex, http://lpaste.net/5187425727326191616
06:39:41 <tdammers> it just stores bytes
06:39:54 <tdammers> and its length is the number of bytes
06:40:00 <bernalex> bartavelle: I already rewrote it myself. :-P
06:40:03 <bartavelle> heh
06:40:15 <bernalex> bartavelle: what does that do though? looks a bit wrong
06:40:28 <bernalex> bartavelle: oh
06:40:34 <bartavelle> I think it does just the same thing as yours
06:40:35 <bernalex> bartavelle: catMaybes. that makes sense.
06:40:39 <nshepperd> :t (<$)
06:40:40 <lambdabot> Functor f => a -> f b -> f a
06:40:49 <nshepperd> huh
06:40:55 <bernalex> bartavelle: yeah it does now that I spotted catMaybes. :-]
06:41:15 <bartavelle> nshepperd, it's like fmap (const x)
06:41:26 <bernalex> > 5 <$ Just 20 -- :-]
06:41:28 <lambdabot>  Just 5
06:42:15 <nshepperd> I suppose that is the fmap'y analogue of (<*)
06:42:52 <bartavelle> yes
06:43:18 <Bor0> :t (<*)
06:43:20 <lambdabot> Applicative f => f a -> f b -> f a
07:02:42 <yesthisisuser> sorry guys. i was thinking about Text, not ByteString. i am tired, just ignore me.
07:02:52 <Ferdirand> is there a type-level compose operator ?
07:04:57 <bda3> For a project with a large humber of states, is there a rule of thumb for when one shifts from a big programstate monad to using functional reactive programming (or some other design)?
07:15:33 <Guest84109> @hoogle (a -> m p) -> (p -> m t) -> m t
07:15:35 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
07:15:35 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
07:15:35 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:17:26 <Guest84109> @hoogle m a -> (a -> (mt -> (t -> m p))
07:17:27 <lambdabot> Parse error:
07:17:27 <lambdabot>   m a -> (a -> (mt -> (t -> m p))
07:17:27 <lambdabot>          ^
07:17:34 <Guest84109> @hoogle m a -> (a -> (mt -> (t -> m p)))
07:17:35 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex4 :: a -> a -> a -> a -> Vertex4 a
07:17:35 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector4 :: a -> a -> a -> a -> Vector4 a
07:17:35 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord4 :: a -> a -> a -> a -> TexCoord4 a
07:18:16 <Guest84109> @hoogle m a -> (a -> (m t -> (t -> m p)))
07:18:17 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex4 :: a -> a -> a -> a -> Vertex4 a
07:18:17 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector4 :: a -> a -> a -> a -> Vector4 a
07:18:17 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord4 :: a -> a -> a -> a -> TexCoord4 a
07:18:39 <favetelinguis> @hoogle ***
07:18:40 <lambdabot> Parse error:
07:18:40 <lambdabot>   ***
07:18:40 <lambdabot>    ^
07:19:25 <favetelinguis> how can i find info about the *** combinator on hoogle? nothing shows up when i google
07:19:36 <Guest84109> @hoogle (***)
07:19:36 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:19:41 <phz> @hoogle (***)
07:19:42 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:20:04 <Guest84109> am I doing anything wrong in
07:20:38 <Guest84109> m a -> (a -> m p)
07:21:06 <Guest84109> and I have m t -> (t -> m p)
07:22:42 <pjdelport> Guest84109: You can /query lambdabot too, by the way. :)
07:23:39 <Guest84109> pjdelport: I couldn't get anything from Hoogle, isn't it a general enough?
07:24:16 <sivteck> :t (>>=)
07:24:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:25:09 <pjdelport> Ferdirand: Yes, there are some definitions of that.
07:25:14 <pjdelport> @hackage TypeCompose
07:25:15 <lambdabot> http://hackage.haskell.org/package/TypeCompose
07:25:26 <Guest84109> sivteck: I know :) but in my case m b is computed with another bind
07:25:43 <pjdelport> Guest84109: What are you looking for?
07:25:50 <sivteck> ok ;p
07:27:30 <Guest84109> pjdelport: I am confused, may be I am overthinking about it, I got to a point where my ts looks like Monad m => m a -> (a -> m p) and I have Monad m => m t -> (t -> m p)
07:27:52 <pjdelport> Guest84109: Those two signatures are equivalent.
07:28:19 <pjdelport> Renaming variables (a and t, in this case) does not change the meaning, as long as the "shape" is the same.
07:28:28 <Guest84109> pjdelport: I know, but I want p back from a using t
07:29:11 <pjdelport> Guest84109: I'm still not exactly sure what you mean... can you maybe paste the code.?
07:29:26 <Guest84109> pjdelport: sorry for my english
07:29:45 <Guest84109> pjdelport: code is client' property
07:29:59 <Guest84109> but I can reproduce scenario
07:30:03 <pjdelport> Guest84109: Well, just the relevant bit, anonymized if necessary. :)
07:30:14 <pjdelport> So those a and t have to be two different types?
07:30:30 <pjdelport> Do you have a function from a to t?
07:30:44 <Guest84109> I have [a] and [t] I have a -> [t] and t -> [p]
07:32:12 <pjdelport> Ah, sounds like <=< then?
07:32:39 <Guest84109> so => [a] =<< (a -> ([t] =<< (t -> [p])))
07:32:59 <Guest84109> Ah,
07:33:12 <Guest84109> @type (<=<)
07:33:13 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:33:30 <pjdelport> If you have: f :: a -> [t] and g :: t -> [p]
07:33:30 <pjdelport> then you can say: g <=< f :: a -> [p]
07:33:47 <Guest84109> awesome
07:34:22 <pjdelport> (<=<) is basically like (.) but for Kleisli arrows (which are functions like Monad m => a -> m b instead of a -> b)
07:34:38 <pjdelport> So you'll see <=< referred to as Kleisli arrow composition
07:34:46 <Guest84109> this make sense I should have m a =<< g <=< f
07:35:22 <Guest84109> this make sense I should have m a =<< (g <=< f)
07:35:31 <Guest84109> much cleaner thanks
07:36:05 <pjdelport> Well, if x is your monadic value, then you could either say: g =<< f =<< x
07:36:05 <pjdelport> or: (g <=< f) x
07:36:42 <pjdelport> Note how this is analogous to: g $ f $ x
07:36:42 <pjdelport> and: (g . f) x
07:37:34 <pjdelport> So you can read =<< as Kleisli application (or ($) for Kleisli arrows) and <=< as Kleisli composition (or (.) for Kleisli arrows)
07:38:34 <Guest84109> pjdelport: great stuff, thanks man
07:39:52 * hackagebot HMap 1.1.8 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.8 (AtzeVanDerPloeg)
07:40:34 <Guest84109> pjdelport: I always mistype =<< with >>=
07:40:40 <Guest84109> pjdelport: :(
07:40:59 <pjdelport> Guest84109: Just think of the angle brackets as pointing in the direction that data flows. :)
07:41:34 <pjdelport> >>= is perhaps more traditional, but i personally like =<< because it's closer to plain function application.
07:41:58 <Guest84109> pjdelport: hmm, just gave a thought...easier to remember in this way
07:41:59 <bergmark> i like =<< better as well
07:42:51 <pjdelport> So i read "putStrLn =<< getLine" just as a monadic variation of "putStrLn $ getLine"
07:43:14 <bergmark> for similar resaons, with `b >>= a . b' you have to read left to right and right to left
07:44:23 <pjdelport> Yeah, "f . g . h =<< x" reads very naturally if you're already used to "f . g . h $ x"
07:44:52 * hackagebot HMap 1.1.9 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.9 (AtzeVanDerPloeg)
07:44:57 <Guest84109> hmm, that'smore easier to reason
07:46:00 <Guest84109> in scala like langs =<< is easier to read
07:46:18 <Guest84109> I mean reason in
07:47:02 <zwer> infix flip fmap would help there, say we named it $>: getLine $> map toLower >>= putStrLn
07:50:11 <nshepperd> speaking of type composition, i'm surprised Data.Functor.Compose doesn't come with an infix synonym
07:50:40 <pjdelport> nshepperd: That TypeCompose package calls it :.
07:51:10 <pjdelport> (I think they're independent expressions of the same thing.)
07:51:13 <gasev> if i can't get my head around simple factorial using zipWith in 10 minutes should i give up functional programming?
07:51:23 <favetelinguis> Im new to haskell and trying to map out some brad picture, are arrows and monads to compeating ideas, that is arrows can completly replace monads?
07:51:36 <CaveJohnson> gasev: never give up.
07:51:42 <Fuuzetsu> ArrowPlus is equivalent to Monad
07:52:08 <favetelinguis> so with arrows i can do everything i can do with monads but not the other way around?
07:52:32 <simpson> You can probably do everything with Arrows or Monads.
07:52:33 <gasev> CaveJohnson: factlist = 1 : zipWith (*) [1..] factlist -- im looking at it 10 minutes and dont get it..
07:52:39 <Fuuzetsu> http://stackoverflow.com/questions/3652054/monads-vs-arrows
07:53:35 <CaveJohnson> sec
07:53:40 <CaveJohnson> i'm only a beginner
07:53:48 <CaveJohnson> haven't even gone through the LYAH book yet, but i can try to help
07:53:50 <CaveJohnson> :)
07:54:55 <simpson> @src zipWith
07:54:55 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:54:56 <lambdabot> zipWith _ _      _      = []
07:55:26 <simpson> gasev: What happens when we expand factlist to look at the second element?
07:56:18 <simpson> You get 1 : 1 : zipWith (*) [2..] (1 : 1 : ...)
07:56:27 <pjdelport> gasev: That definition of factlist is more of a cute party trick than any kind of litmus test about functional programming. Certainly don't use it to judge whether you should give up or not. :)
07:56:48 <simpson> And then if you expand the next element, you get 1 : 1 : 2 : zipWith (*) [3..] (1 : 1 : 2 : ...)
07:57:08 <pjdelport> gasev: Rather focus on the easy basics. There will probably be a point where that factlist example becomes obvious in hindsight, because of other things you've learned, but don't worry about it up front.
07:57:49 <pjdelport> The heart of functional programming is not tricksy like that: it's just about writing code that is clear, correct, readable, and composable.
08:04:54 * hackagebot maxsharing 1.0.2 - Maximal sharing of terms in the lambda calculus with letrec  http://hackage.haskell.org/package/maxsharing-1.0.2 (JanRochel)
08:04:58 <gasev> simpson: by 2nd u mean the one with index 1 right?
08:08:00 <simpson> gasev: Yep.
08:09:03 <Haskellfant> is there some way to create a new Integral type that only works from minBound to maxBound (enforced by the type system) without enumerating all values as Constructors?
08:09:35 <mietek> Any Haste users?
08:11:01 <geekosaur> Haskellfant: I think in theory you could use type level numbers, but in practice it's painful to do at present. (GHC HEAD might help; type level integers are under active development)
08:11:13 <gasev> simpson: dude, i actually tried to do it step by step and i got it http://lpaste.net/113455
08:11:26 <gasev> simpson: thank you very much
08:11:36 <Haskellfant> geekosaur: hm k, I'll just life with an Integer and blame anybody supplying the wrong functions :)
08:12:25 <yukko> geekosaur will that change include type level operations on integers (+, -, etc)?
08:12:42 <gasev> simpson: but i would never come up with this solution, too sophisticated..
08:12:58 <geekosaur> to some extent those already exist, as I understand it. they are limited though and there's ongoing discussion about extending them
08:18:55 <nshepperd> ah, (:.) is a newtype
08:19:37 <nshepperd> but it seems like "type a :*: b = Compose a b" works fine
08:19:56 * hackagebot libhbb 0.4.1.0 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.4.1.0 (wolfch)
08:19:58 * hackagebot snap 0.13.3.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.3.1 (DougBeardsley)
08:21:27 <Ferdirand> pjdelport: thanks ! (with a bit of delay)
08:22:47 <Ferdirand> i think I just grokked something wrt. to that mysterious Fix type
08:23:29 <Ferdirand> if I want to emulate a list with it, I need somethink like Fix (Cell a) where type Cell a b = Maybe (a,b) ?
08:25:14 <Cale> Ferdirand: yes, that's right
08:25:56 <Ferdirand> now to understand the relationship with Mu and Nu
08:25:59 <Cale> (though that's illegal as you wrote it because it involves a partially applied type synonym, but apart from that)
08:26:27 <pjdelport> Ferdirand: Yay for moments of insight. :)
08:26:38 <pjdelport> It's amazing when something like that clicks for the first time.
08:29:03 <Ferdirand> oh
08:29:19 <Ferdirand> i could just write that as data Cell a b = Nil | Cons a b ?
08:30:37 <argiopetech> I seem to recall a library which translates integers into their 'nth' form, (1st, 2nd, 93rd, etc), but I can't find it. Did I imagine this, or is it right under my nose?
08:30:44 <Ferdirand> i was trying to make sense out of Fix by applying it to common functors but I see its nature now
08:31:08 <argiopetech> "Does a Functor have the Fix nature?"
08:32:34 <RchrdB> argiopetech: http://hackage.haskell.org/package/pandoc-citeproc-0.3.1/docs/Text-CSL-Style.html might be it?
08:33:13 <RchrdB> m, maybe not
08:33:27 <argiopetech> Right... Ordinal... That's what we call those.
08:33:49 <argiopetech> I think that module goes the opposite direction though (still looking).
08:36:24 <Ferdirand> holy crap, I can see the light
08:36:28 <Ferdirand> Mu clicked
08:36:40 <nyuszika7h> is there a way to get a hexadecimal representation of non-printable characters, like \x01 instead of \SOH?
08:36:44 <Ferdirand> thanks edwardk Cale pjdelport
08:36:57 <argiopetech> Ferdirand: Joshu would be pleased.
08:37:12 <nyuszika7h> for a string or character literal that is
08:37:46 <nyuszika7h> I mean, display the string or character as "\x01" instead of "\SOH"... I hope I'm not too confusing >_>
08:38:35 <argiopetech> nyuszika7h: Are you `print`ing a bytestring by chance?
08:38:55 <nyuszika7h> just a string actually, maybe I'm supposed to be using a bytestring
08:38:58 <nyuszika7h> ghci is printing it, yes
08:39:38 <scooty-puff> i was wondering about HAMTs and Data.HashMap.{Lazy,Strict}.HashMap in particular, complexity bounds
08:39:57 <scooty-puff> on each level of BitmapIndexed, you consume a fixed number of bits of the hash
08:40:03 <scooty-puff> and the hash is fixed size
08:40:04 <argiopetech> If you switch to Bytestring it might be easier. I believe ByteString prints with the hex format (though ByteString.Char8 prints the logical code).
08:40:23 <scooty-puff> so couldn't lookup and insert be seen as O(1)?
08:40:49 <scooty-puff> the analysis i saw in the paper these are likely based on used O(log n), where n is the number of bits
08:41:20 <StoneToad> scooty-puff: which, if you have a constant number of bits, is equivalent to O(1)
08:41:26 <scooty-puff> right
08:41:36 <scooty-puff> so would it be unfair to call it O(1)?
08:41:58 <scooty-puff> i think IntMap sort of does - the caveat being its bounded by W (same as here) (where W is the size of a word)
08:42:06 <jhance> if the hash is fixed size it is O(1)...
08:42:12 <scooty-puff> which it always is
08:42:22 <scooty-puff> i guess i'm wondering why the hackage docs list O(log n)
08:42:52 <jhance> scooty-puff: Can you link docs?
08:42:57 <scooty-puff> http://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Strict.html
08:44:35 <scooty-puff> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-IntMap-Strict.html is the other one that goes listing the worst case, bounded by W
08:44:46 <jhance> scooty-puff: Err, isn't `n` not the length of the hash but the size of the map
08:44:59 * hackagebot HMap 1.2.0 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.2.0 (AtzeVanDerPloeg)
08:45:07 <Haskellfant> Hi, I've got the following code http://lpaste.net/113462 My Problem is that `show (Symbol 'ε')` double escapes the unicodechar, so that I end up with a ton of \949 when printing it which makes my output completely unreadable. Is there a way around this?
08:45:14 <scooty-puff> in these docs yes
08:45:19 <scooty-puff> which i don't think is completely accurate
08:45:43 <Haskellfant> actually this can be condensed to show 'ε'
08:45:49 <Haskellfant> this has exactly the same problem
08:46:39 <scooty-puff> IntMap is accurate, but HashMap could say average case O(min(log(n), log(W)) i believe - worse case is probably O(n) with how the collisions are handled
08:47:01 <ioanna> hello, I am just learning haskell to understand a program, or rather a collection of programs, and I have a very basic question on using modules. The first program is defining a module, say "A" which includes "Data.Char" and "Data.List", and the second program defines a module "B" which is "Data.Char" and "A". Why did the programmer use "Data.Char" in the second module? Isn't it included in module "A" already? Thanks
08:47:38 <jhance> ioanna: You don't include a module, you "import" the module. Its not like a C header. You don't get everything that the module imported
08:47:51 <StoneToad> scooty-puff: looks like they just copy/pasted intmap's source and forgot to fix O() stuff for the specific commands
08:48:08 <argiopetech> @RchrdB Thanks for the link, but it doesn't look like it will do what I want. I'll just whip up a quick package and throw it on Hackage.
08:48:09 <lambdabot> Unknown command, try @list
08:48:47 <argiopetech> Heh... That didn't work quite as intended.
08:48:51 <ioanna> jhance, I'm not familiar with C but I think I understand what you mean. So when I import a module, I only import the functions that were defined in the program where the module was defined?
08:49:00 <RchrdB> argiopetech: the only other thing I was wondering about is, maybe it's somewhere in localisation support libs?
08:49:15 <RchrdB> "1st 2nd 3rd 4th" are language-specific, after all.
08:49:15 <fresheyeball> hello out there
08:49:57 <argiopetech> RchrdB: True enough. I'll check some of the i18 modules I have strewn about.
08:50:20 <jhance> ioanel: More specifically, you only import what the module exports. By default, this is whatever was defined in that module, but you can also export only specific functions, or even export functions from other modules, by using the where clause at the start of the module
08:50:54 <RchrdB> ioanna: right. Every module has a list of things that it exports, (which, if not specified explicitly, defaults to "everything defined in this module"), and only the exported things come into scope.
08:51:02 <yukko> wow you really can do numbers in the type system!
08:51:21 <yukko> I just defined + and * on types, I'm gonna try doing vectors now
08:52:06 <ioanna> Ah, I get it, thank you for explaining this to me jhance++! Thanks for the extra clarification point too, RchrdB++!
08:53:00 <lericson> oh that's how you use it?
08:54:23 <korishev> hello all, can anyone here give me a hand with a strange issue with spiceweasel?
08:54:53 <jhance> korishev: Isn't that ruby territory?
08:55:06 <bernalex> can I write "fmap (fmap foo . bar)" with only one fmap?
08:55:36 <jhance> bernalex: No unless you use some other function which would basically do two fmaps
08:56:00 <jhance> bernalex: I think you can do (fmap . fmap) (foo . bar) though
08:56:05 <korishev> jhance: maybe?  It is an officially unsupported tool for verifying chef infrastructure.  Was thinking the author might be in here.
08:56:07 <bernalex> true
08:56:14 <argiopetech> Github says, "Ruby 100%".
08:56:24 <jhance> well, its not written in haskell so this seems like an odd place to ask
08:56:44 <korishev> jhance: totally true.  Wrong window, sorry :)
09:11:05 <Raghs> I installed ghc-mod into a sandbox. do I have to do anything in linux to enable in ghc-pkg list?
09:20:49 <haole> any good blob engines around? (in haskell, of course)
09:20:54 <haole> blog*
09:21:54 <jhance> haole: Hakyll
09:25:03 * hackagebot purescript 0.5.7.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.7.1 (PhilFreeman)
09:29:41 <Black0range> Hey guys, having a little peak at haskell, how do you include a file? :)
09:29:54 <Black0range> interpreted mode
09:31:33 <ReinH> :load filename
09:31:41 <ReinH> Black0range: (in ghci)
09:31:49 <Black0range> ah thanks :)
09:31:57 <ReinH> Black0range: you can also use :help :)
09:32:09 <Black0range> thats a good one to know thanks! :)
09:32:21 <Black0range> btw what tutorial do you think is the most straight forward one?
09:32:30 <Black0range> know lisp since before just need to know the haskell way :
09:35:48 <amf> does haskell have a way to represent a negative value for enums? i have a list of error codes where all but one are > 0
09:36:55 <HeladoDeBrownie> amar_, sure, just use appropriate definitions of toEnum and fromEnum. This does mean you can't just derive it though.
09:37:01 <HeladoDeBrownie> Mis tab
09:37:02 <HeladoDeBrownie> amf, ^
09:37:37 <HeladoDeBrownie> amf, are you familiar with how to write an instance?
09:37:59 <amf> oh gotcha, i forgot about those
09:38:37 <amf> HeladoDeBrownie: yep. although i was hoping for some clever way for assigning values (Go's iota has spoiled me a little)
09:39:22 <clrnd> @where lyah
09:39:22 <lambdabot> http://www.learnyouahaskell.com/
09:39:25 <clrnd> Black0range, ^
09:41:05 <Black0range> thank you mate
09:43:30 <benzrf> nah nah nah
09:43:32 <benzrf> cis194 !
09:43:38 <benzrf> lyah is poor at enhanced grokitude
09:45:08 <josephle> > enhanced grokitude
09:45:10 <lambdabot>  Not in scope: ‘enhanced’Not in scope: ‘grokitude’
09:45:16 <josephle> I need to use that phrase
09:45:42 <Fuuzetsu> ur poor
09:45:42 <Fuuzetsu> #rekt
09:54:48 <yukko> is it possible to shadow the built-in list syntax?
09:55:00 <yukko> ie redefine : and [] syntax and etc
09:56:33 <argiopetech> yukko: Yes, as of 7.8.
09:57:05 <yukko> I have 7.8 but it gives me an error when I try, is there a special LANGUAGE pragma I need to use?
09:57:06 <yekKhaste> Hi
09:57:44 <yekKhaste> I totally new to haskell and functional programming
09:58:10 <yekKhaste> I want too knew do you recommend haskell for backend development?
09:58:19 <argiopetech> yukko: Yes, OverloadedLists. See https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/type-class-extensions.html
09:58:42 <yekKhaste> I has it some fullstack framework that can compare to rails?
09:59:00 <yekKhaste> Some framework for rapid web development
09:59:07 <argiopetech> yekKhaste: Welcome! Yes, there are several web frameworks in existence.
09:59:31 <joshc> yukko: yes, you'll need the OverloadedLists extension.
09:59:58 <yukko> ah I see!
10:00:00 <yekKhaste> argiopetech, Do you thick they can beat something like rails in development speed?
10:00:01 <yukko> thank you both very much :)
10:00:12 <quchen> yekKhaste: Haskell is a general purpose language, and it has at least 3 larger web frameworks (Snap, Happstack, Yesod), and several small ones.
10:00:13 <zardox> Hi!
10:00:24 <zardox> could someone please explain the evaluation of this expressions:
10:00:25 <argiopetech> yekKhaste: A quick google search for "haskell web framework" should bring up some contenders. The first three results (at least) are all well-known.
10:00:25 <zardox> [x | x <- [1..3], y <- [1..x]]
10:00:36 <zardox> which is [1,2,2,3,3,3]
10:00:52 <joelteon> > [x | x <- [1..3], y <- [1..x]]
10:00:54 <lambdabot>  [1,2,2,3,3,3]
10:00:55 <zardox> my intuitive understanding would have led me to believe that the result would be [1,2,3]
10:01:18 <argiopetech> yekKhaste: I wouldn't know, honestly. I generally don't do web development, and I've done it in Haskell since I started using frameworks.
10:01:21 <joelteon> > do { x <- [1..3]; y <- [1..x]; return x }
10:01:23 <lambdabot>  [1,2,2,3,3,3]
10:01:40 <quchen> zardox: The Haskell Report has a section that defines the semantics of list comprehensions. The rules given there are a possible implementation.
10:01:40 <zardox> how does the second generator influence the result?
10:01:50 <zomg> yekKhaste: Yesod is quite fast to develop with in my experience, in comparison to things like Rails
10:02:07 <yekKhaste> and do you recommend it for a freelance web developer?
10:02:09 <zomg> yekKhaste: it does have a bit of a learning curve if you're not used to working in Haskell though, but once you get your bearings it's quite fast
10:02:31 <argiopetech> zardox: The list monad is spooooky magic. Well-defined, but still magic.
10:02:34 <zomg> sure, if you like working with haskell it's a good choice
10:02:55 <argiopetech> yekKhaste: It works well for me (with the previous caveats still standing).
10:02:57 <yekKhaste> Where can I start learning haskell?
10:03:06 <zardox> quchen: I just had a look at the Haskell report. Sorry, but that's a far too concise source.
10:03:14 <kadoban> yekKhaste: Personally I use hakyll for web development.
10:03:19 <kadoban> (I'm freelance too)
10:03:24 * quchen doesn't think putting things into a single-element list and concatenating them is magic
10:03:42 <zomg> kadoban: hakyll isn't really a web app library is it though?
10:04:01 <argiopetech> quchen: You're a witch!
10:04:02 <quchen> zardox: Look for "List comprehensions satisfy these identities"
10:04:03 <zomg> I mean isn't it more like a static site generator
10:04:27 <kadoban> Yeah, it's a static site compiler...which like 95% of the time is more than enough, in my experience.
10:04:38 <zomg> if you're just making web sites, absolutely :)
10:04:41 <zardox> quchen, would you please spell out the first two evaluation steps for me?
10:04:49 <zomg> but I think as soon as you need interactivity, then it goes out of the window
10:04:49 <zardox> there is no case with two generators in the haskell report
10:05:33 <argiopetech> zardox: All generators are iterated over, even if their output is forgotten.
10:05:37 <quchen> zardox: Well, what you've got is  [x | x <- [1..3], y <- [1..x]]  which is of the form of rule 4, namely  [ e | p <- l; Q ], where e=x, p=x, l=[1..3], Q=y<-[1..x]
10:05:38 <yekKhaste> zomg, You mean I cant use it for web application development?
10:05:54 <zomg> yekKhaste: yeah Hakyll isn't suitable for that
10:05:55 <kadoban> zomg: Depends what kind. The vast majority of sites don't need any of that, of course...and usually people build it in for no reason. Like all of the drupal and wordpress sites, where all that framework is accomplishing is it adds a requirement for updates
10:05:55 <argiopetech> > [x | x <- [1..3], y <- [3, 2..1]]
10:05:57 <lambdabot>  [1,1,1,2,2,2,3,3,3]
10:06:20 <argiopetech> Right... I'm an idiot... /me retreats
10:06:25 <kadoban> I guess it depends what exactly you mean by web app, but yeah not really.
10:06:27 <zomg> kadoban: yeah you can do some kinds of stuff with it quite nicely, I've seen people use similar things for blogging and seems to work for them
10:06:50 <quchen> zardox: So you can apply that rule to get another list of that form, apply the rule again and so on. It's really just text substitution to apply those rules.
10:07:10 <yekKhaste> Thanks a lot :)
10:07:15 <kadoban> Right.
10:07:19 <jfischoff> I’m trying to upgrade to the new TLS interface. I have some code that has: defaultParamsClient { pCiphers = ciphersuite_medium }, but pCiphers is no more. What should I do instead?
10:07:35 <quchen> zardox: For what it's worth, I think intuition is much more helpful when trying to understand list comprehensions, but you were asking for the evaluation.
10:08:12 <quchen> For what it's worther, list comprehensions aren't too important, and a bit later in your Haskell journey they'll start to become obvious despite you rarely using them again :-þ
10:09:01 <mietek> cabal install --dep --dry-run --constraint='yesod == 0.10.2'
10:09:01 <mietek> Resolving dependencies...
10:09:12 <mietek> Is this supposed to take forever?
10:09:19 <argiopetech> quchen: I wonder why that happens... It's not like their usefulness diminishes...
10:09:48 <zardox> quchen: thanks
10:09:55 <dcoutts_> mietek: it can take a while. You can see if --reorder-goals helps, it sometimes does.
10:09:56 <argiopetech> mietek: Generally only when it's ultimately going to fail... If you're back to yesod 0.10 (current version 1.4.2), there's a problem.
10:10:05 <Black0range> gys, noobie question. Straightest way to get a random number in haskell?
10:10:20 <mietek> argiopetech: I'm trying to resurrect a 3 y.o. project
10:10:29 <mietek> Which is missing a *.cabal file...
10:10:29 <quchen> argiopetech: A list is pretty similar to a loop in practical terms, and loops rarely iterate over all too complex things, so it's not very common to build them this way.
10:10:48 <mietek> dcoutts_: any tips on that?
10:11:03 <mietek> https://github.com/mietek/tfoo
10:11:03 <dcoutts_> mietek: on what?
10:11:03 <argiopetech> mietek: Rough. Is it small enough to copy in a .cabal from yesod init and hunt errors?
10:11:13 <mietek> argiopetech: possibly, yeah.
10:11:23 <kadoban> Black0range: http://www.xkcd.com/221/   converting to haskell syntax is left as an exercise for the reader
10:11:27 <mietek> I was hoping to just start from the known good dependencies the author lists in the README
10:11:43 <mietek> But just sticking them in a *.cabal file results in failure on modern GHC
10:11:48 <mietek> Now trying GHC 7.4.2 and back
10:11:59 <quchen> Black0range: System.Random.randomIO
10:12:04 <Black0range> kadoban: ok ok a psuedo random number
10:12:36 <dcoutts_> Black0range: System.Random.random for the pure version
10:12:42 <quchen> main = (randomIO :: IO Int) >>= print
10:12:45 <mietek> dcoutts_: I'd like to recover a complete set of constraints (cabal.config-style) for this old project
10:13:01 <argiopetech> mietek: My general fix for cabal problems is to `cabal sandbox delete; cabal update; cabal install --only-dependencies`... I like to live dangerously though.
10:13:20 <kadoban> argiopetech: Was there supposed to be a sandbox init in there?
10:13:32 <lericson> argiopetech: especially since you're not using && ;)
10:13:36 <quchen> kadoban: No, he said "dangerously" :-þ
10:13:36 <argiopetech> kadoban: There was. Thanks for the catch.
10:13:44 <kadoban> quchen: XD
10:13:46 <mietek> argiopetech: Yes, that's Cabal 101.  I have 5 fresh machines, each set up with a pristine copy of GHC and nothing else, with versions 7.4.2, 7.2.2, 7.0.4, 6.12.3, and 6.10.4
10:13:47 <dcoutts_> mietek: add constraints for the versions of the core packages that come with that ghc version. That'll cut down the search space.
10:13:49 <argiopetech> And yes, the semicolons are the danger. ;)
10:14:26 <argiopetech> mietek: Man, I'd have to search down a lot of old virtual instances to find that many versions...
10:14:28 <dcoutts_> Black0range: the thing you need to understand is that random number handling with pure functions requires passing the value of the PRNG state around
10:14:38 <mietek> argiopetech: you wouldn't.  You could just use Halcyon. :)
10:14:51 <dcoutts_> Black0range: the IO versions avoid that, but then the come with all the inconvenience of being in IO
10:15:03 <mietek> Anyone interested in Haskell web deployment or deployment in general?  Join me in #HaskellOnHeroku or #halcyon_sh
10:15:04 <argiopetech> mietek: Shhh. That's the easy way. :P
10:15:30 <mietek> Gearing up for a public release.
10:15:37 <Black0range> ughhh
10:17:05 <Black0range> Soooo why doesn't mod System.Random.randomIO 10 work?
10:18:02 <jfischoff> :t mod
10:18:04 <lambdabot> Integral a => a -> a -> a
10:18:15 <jfischoff> :t System.Random.randomIO
10:18:16 <lambdabot> Random a => IO a
10:18:53 <Black0range> Sorry guys, just learning shakell to be fair that doesn't tell me anything
10:18:56 <lpaste> schell pasted “cabal error” at http://lpaste.net/113467
10:19:08 <jfischoff> Black0range: sorry I got distracted by work
10:19:12 <schell> has anyone ran into a similar cabal error? http://lpaste.net/113467
10:19:46 <jfischoff> Black0range: IO a is a number type. it is an action that can produce a number
10:19:57 <jfischoff> Black0range: so the types don’t fit
10:19:59 <schell> this was not happening last night, i updated a file that i haven’t updated in a while, rebuilt and then ran into this
10:20:23 <Black0range> but doesn't mod take numbers?!
10:20:27 <jfischoff> yes
10:20:39 <geekosaur> it takes numbers, not actions
10:20:42 <zwer> IO Int is not Int
10:20:54 <Black0range> oh yeesss haskell has a special io thingie...
10:21:02 <jfischoff> well yes and no
10:21:34 <jfischoff> there are many things like ‘Foo a’ that are not ‘a’
10:21:34 <Black0range> so i need to something like let a = System.Random.randomIO /n b = mod a 10?
10:21:49 <jfischoff> close
10:22:07 <jfischoff> :t (>>=)
10:22:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:22:44 <jfischoff> randomIO >>= \randNum -> return $ mod randNum 10
10:22:56 <jfischoff> or
10:23:15 <zwer> Black0range did you learn about do syntax yet?
10:23:21 <jfischoff> do { randNum <- randomIO ; return $ mod randNum 10; }
10:23:42 <fresheyeball> so just curious
10:23:49 <fresheyeball> why is there no typeclass for `mix`
10:23:52 <fresheyeball> ??
10:24:05 <jfischoff> fresheyeball: what would it do?
10:24:10 <fresheyeball> as in a typeclass for two objects that can be blended together
10:24:17 <josephle> ah, like a mixin
10:24:17 <jfischoff> in what way?
10:24:18 <Black0range> that do thing looks like pure magic i'll take it and ponder or it another day! :)
10:24:32 <fresheyeball> just mixed
10:24:46 <fresheyeball> to colors would become a third color between them
10:24:51 <jfischoff> Black0range: The do gets converted to the first version i wrote
10:24:56 <fresheyeball> two points would become a single point between them
10:25:03 <fresheyeball> to numbers would become their mean
10:25:06 <fresheyeball> ect. ect.
10:25:38 <josephle> I mean, monoids kinda do that
10:25:45 <fresheyeball> no
10:25:49 <fresheyeball> mix is not associative
10:25:54 <josephle> ok
10:26:01 <josephle> so unassociative binary operator?
10:26:01 <fresheyeball> communiative but not associative
10:26:09 <fresheyeball> sure
10:26:10 <josephle> ooooh
10:26:25 <fresheyeball> is this already a thing?
10:26:31 <fresheyeball> it feels like it should be
10:26:32 <josephle> commutative magma, I think
10:26:42 <josephle> not sure if someone has it in a library somewhere
10:26:46 <Black0range> randomIO >>= \randNum -> return $ mod randNum 10... so this take the randomIO and it's "data type" defines a variable named randomnumber something something magic and puts it into the mod function?
10:26:53 <Fuuzetsu> http://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
10:27:19 <fresheyeball> I am reading it
10:28:32 <zwer> a more common way of writing without the do syntax that would be:
10:28:36 <zwer> > fmap (mod 10) randomIO
10:28:38 <lambdabot>  <IO Integer>
10:28:49 <jfischoff> Black0range: I think of it like this: create a new expression that unpacks the result of randomIO and uses it in mod function
10:29:13 <jfischoff> zwer: you changed the order of the args
10:29:21 <jfischoff> you want
10:29:29 <zwer> indeed
10:29:33 <jfischoff> fmap (flip mod 10)
10:29:45 <Welkin> I have data stored in plain text files that I would like to periodically add/update in a database through yesod using the built-in facilities and data structures set up by yesod. What is a good way to do this without going through http?
10:29:54 <argiopetech> jfischoff: hlint yells at you when you do that...
10:29:59 <Fuuzetsu> use (`mod` 10)
10:30:06 <jfischoff> sure
10:30:12 <fresheyeball> so might this be a quasigroup?
10:30:14 <Black0range> zwer: fmap (mod 10) randomIO returns crazzzyy stuff
10:30:27 <fresheyeball> I've never heard of quasigroup
10:30:50 <zwer> Black0range see above, arguments were switched. it does mod 10 randomnum instead of mod randnum 10
10:30:51 <jfischoff> well mod x y is not mod y x
10:30:54 <zwer> my mistake
10:31:20 <josephle> fresheyeball: according to wiki, a quasigroup requires division to be possible
10:31:52 <Black0range> Ah that looks like something i can prentend to understand!
10:32:30 <fresheyeball> hmm
10:32:54 <tolt> Black0range: (`mod` 10) could also be (\x -> mod x 10)
10:32:55 <bernalex> anyone know of haskell bindings for gstreamer? my net is too slow to use www
10:33:18 <tolt> Sorry if that's not what you didn't understand
10:33:21 <fresheyeball> so a collection of objects equipped with a non-associative operator that morphs from 2 objects to an object within the set
10:33:43 <fresheyeball> is the reciprocal of semi-group and is quasi-group?
10:33:51 <Black0range> is tolt something like lisps "apply" function?
10:33:56 <fresheyeball> so ints have 2 semigroups + and *
10:34:05 <Black0range> i mean fmap not tolt
10:34:20 <fresheyeball> and 2 quasi-groups / and - ?
10:34:51 <tolt> > :t fmap
10:34:52 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:35:03 <tolt> @type fmap
10:35:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:35:13 <josephle> fresheyeball: in a quasi group, / is defined by its relation to *
10:35:17 <bernalex> tolt: omit '>' for t, k, i, etc
10:35:20 <bernalex> :k (->)
10:35:22 <lambdabot> * -> * -> *
10:35:54 <zwer> Black0Eange
10:35:56 <bernalex> :t fmap -- etc.
10:35:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:35:57 <tolt> randomIO returns an IO a (IO being a functor).
10:36:01 <tolt> thanks bernalex
10:36:10 <josephle> fresheyeball: but I think you are right about - being a quasigroup
10:36:14 <tolt> :t (`mod` 10)
10:36:15 <lambdabot> Integral a => a -> a
10:36:22 <fresheyeball> @josephle can you elaborate on that?
10:36:23 <lambdabot> Unknown command, try @list
10:36:59 <bernalex> `mod` 10 is flip mod 10.
10:37:03 <tolt> Black0range: So fmap allows you to take an f a -> f b with a function (a -> b)
10:38:09 <josephle> fresheyeball: this just comes from my limited understanding of the wiki article
10:38:34 <Black0range> O.o
10:38:39 <josephle> but it seems their definition of a quasigroup is a set Q with operators *,/,\
10:38:44 <Black0range> Seems like i better read the entire tutorial
10:38:53 <Black0range> three times
10:38:54 <zwer> Black0range fmap 'lifts' a regular function so that we can use it on values inside some context. in this case the context is IO, so it turns `Int -> Int` function into `IO Int -> IO Int', which is exactly what you needed
10:38:58 <josephle> which can be seen as multiplication and left/right division
10:39:43 <zwer> it works on other things as well, for example on lists:
10:39:52 <tolt> Black0range: A good example of functor is a list. If you have a List a and a function (a -> b), you should be able to create a List b
10:40:15 <tolt> > fmap (+1) [1,2,3]
10:40:16 <zwer> > fmap (*2) [1..10]
10:40:17 <lambdabot>  [2,3,4]
10:40:21 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:40:56 <clrnd> Black0range, no, fmap is just a high order function
10:42:26 <fresheyeball> gotcha
10:42:27 <fresheyeball> ok
10:42:43 <Black0range> hmmm so something like lisps (map (lambda (a) (+ a 1)) '(1 2 3)) ?
10:42:46 <zwer> fmap on lists is just a map (mapcar in CL). do you see the connection? lifting Int -> Int  function to work on lists ([Int] -> [Int]), or in your example above, lifting it to work on IO
10:42:49 <felixn> permutate = foldl (liftA2 (++)) [[]] . map (map (: [])) <-- my new favorite function
10:43:31 <tolt> Black0range: Yeah. On lists it would be the same if you just wrote map
10:43:45 <tolt> > map (\a -> a + 1) [1,2,3]
10:43:47 <lambdabot>  [2,3,4]
10:43:57 <zwer> Black0range yeah exactly like that. except that fmap can work on a lot of things, not just lists
10:44:46 <Black0range> oki doki! :) thanks guys
10:45:28 <josephle> fresheyeball: it's kind of cool, because division is basically the notion of inverse without the requirement of having an identity element
10:45:43 <fresheyeball> division does have identity though
10:46:03 <josephle> division in a quasigroup that is
10:46:14 <fresheyeball> ok
10:46:19 <josephle> so using subtration in Ints as an example
10:46:32 <josephle> we choose subtraction to be our operator *
10:47:03 <josephle> the laws of a quasigroup are
10:47:27 <josephle> y = x * (x \ y), y = x \ (x * y), y = (y / x) * x, and y = (y * x)/x
10:47:31 <Black0range> By the way! what would you guys say is the practical use of haskell? where should one use it, where should one not use it?
10:48:00 <josephle> then for subtraction, both \ and / are addition
10:48:30 <fresheyeball> The only place you should not use haskell is in systems that require large amounts of unsafe operations for performance
10:48:32 <fresheyeball> and the UI
10:48:36 <kadoban> Black0range: It's a general purpose programming language. Beyond that, it's better if you experiment with it yourself and see what you like it for.
10:49:09 <tolt> Parsing in haskell is incredibly nice with parsec and web backend stuff is great in my opinion
10:50:10 <Black0range> Regarding UI are there any way at all that you can get a state in haskell?
10:50:12 * hackagebot ghc-mod 5.2.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.2.0.0 (DanielG)
10:50:44 <kadoban> Black0range: That's a pretty ambiguous question. What do you mean?
10:53:04 <kadoban> Black0range: If you mean something like, can you receive and handle user input in haskell, then sure.
10:53:52 <zwer> Black0range, haskell can do UI if that is what you are asking. There are bindings for gtk, wxwidgets, etc
10:54:25 <Black0range> Lets see if i can ask the question in a better way...
10:54:35 <kadoban> (p.s. There's UIs besides GUIs, just throwing that out there...command line is also a UI)
10:55:23 <fresheyeball> @kodoban my bad
10:55:23 <lambdabot> Unknown command, try @list
11:01:52 <Black0range> Are there possibility for state in Haskell?  like a simple loop that every iteration sets a variable += 1?
11:02:16 <Fuuzetsu> Yes but you almost certainly don't want that
11:02:26 <mmaruseacph2> you don't really need to do that for a simple loop, just do a length
11:02:51 <Black0range> Well if you want to make a ping pong or something you will probably need this?
11:02:55 <Fuuzetsu> no
11:03:52 <Black0range> since there are no state how could you posiblity check the state of another "object"
11:04:29 <Black0range> something like? is the ball colliding with the current position of the player?
11:04:31 <Fuuzetsu> You should stop trying to shoehorn your imperative way into Haskell program, it's not going to be pretty
11:04:45 <Black0range> Well teach me the way master! :)
11:04:46 <Fuuzetsu> isColliding :: Ball -> Player -> Bool
11:05:11 <bernalex> fresheyeball: ouch
11:05:14 * hackagebot ctrie 0.1.0.2 - Non-blocking concurrent map  http://hackage.haskell.org/package/ctrie-0.1.0.2 (MichaelSchroeder)
11:05:21 <yukko> http://lpaste.net/113470 can someone explain why this doesn't work when I use Vector'?
11:05:24 <bernalex> collision :: Ball -> Player -> Maybe CollisionNormal -- that's more like it.
11:05:40 <Fuuzetsu> whatever works
11:05:51 <yukko> (Vector is a normal type defined with data, Vector' is a type synonym of Vector with the arguments reversed)
11:06:08 <bernalex> probably collision :: Entity -> Entity -> Maybe CollisionNormal -- or something like that, then pattern match on entity constructors.
11:06:49 <mmaruseacph2> collision :: Entity a, Direction b => a -> a -> Maybe b
11:07:06 <mmaruseacph2> that's what I used in a program to handle object collisions in 2d and 3d
11:07:15 <mmaruseacph2> forgot the ( ) s :(
11:07:16 <Fuuzetsu> I question the need for Direction typeclass
11:07:24 <Black0range> so when the ball collides we want to send it in another vector? how would one do that?
11:07:33 <bernalex> collide :: (Tangible a, Tangible b) => a -> b -> Maybe CollisionNormal
11:07:44 <Black0range> i mean we cant say vector = newVector?
11:07:47 <bernalex> collide a b = intersect (shape a) (shape b) (centre b - centre a)
11:07:52 <Fuuzetsu> no, you can't
11:08:00 <Fuuzetsu> at least not in the way you're hoping for
11:08:38 <bernalex> then intersect :: Shape -> Shape -> Vector -> Maybe Normal -- or whatever, and pattern match.
11:09:04 <Black0range> No i'm not hoping for anything particular, just trying to figure out the way you guys would do it
11:09:25 <bernalex> Black0range: we'd just make new entities
11:10:10 <Black0range> so something along the lines of a looping funtion that takes the vectors/positions/ whatever, calculates the next step/ repeat?
11:10:24 <chewbaccca> fresheyeball why not GUI in haskell? I didnt find using Gtk in haskell any harder than in other languages
11:11:21 <Fuuzetsu> reminds me to fix my deadalock in gtk…
11:11:22 <bernalex> Black0range: let's be naïve and say you have a World Player Player Ball, then you might have a step w@(p q b) = let { (p',q') = both (draw . move . handle) (p, q) ; b' = draw . move } in World b' p' q' -- or something.
11:11:23 <Fuuzetsu> deadlock*
11:12:06 <Black0range> sorry i'm far to new in haskell to understand that syntax corretly
11:12:22 <chewbaccca> Black0range: by the way haskell has ways of handling state. there is State, ST, IORef..
11:12:29 <Fuuzetsu> it doesn't help he's inlining it into one line
11:12:47 <shapr> I still wish ghcLiVE had been popular :-(
11:12:59 <bernalex> Black0range: it just says: take our old players & our old ball, then apply whatever functions to them (move, draw, handle keyboards, etc) -- then return a brand new World with new entities altogether.
11:13:19 <bernalex> Black0range: so instead of mutating the Ball to move it, we make an entirely new Ball at the new position.
11:14:05 <Black0range> oki, makes sense... but it doesn't sound very friendly to our common friends the processor and the ram?
11:14:20 <bernalex> Black0range: the compiler is better at optimisation than you. ;-)
11:15:21 <simpson> Black0range: I'd be happy to explain how this entire thing can be efficient, but it's a long journey. Don't worry about it for now.
11:15:52 <mietek> entropy-0.3.4 is broken, isn't it?
11:16:33 <dbushenko> I'm inside a sandbox and do 'cabal install hdbc' -- where it is installed?
11:16:47 <Fuuzetsu> .cabal-sandbox/bin IIRC
11:16:50 <belst> hey guys, which is the shortest way to groupBy on fst element in a list of pairs?
11:16:56 <dbushenko> bcs when I try 'cabal build' it complains that it can't find hdbc....
11:17:05 <crobbins> belst: use comparing from Data.Ord
11:17:05 <Fuuzetsu> oh
11:17:27 <Black0range> Sooo in short terms the compiler is quite good at making things that seem very inefficient efficient?
11:17:38 <crobbins> :t comparing
11:17:39 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:17:58 <chewbaccca> Black0range: with IORef you can have value that can be mutated just like values in other languages. so you can have some state when you need to, in case you are getting the impression that this is not possible in haskell
11:18:09 <Fuuzetsu> chewbaccca: you're not helping
11:18:18 <belst> crobbins: so u mean like groupBy ((==) `on` fst)?
11:18:39 <crobbins> belst: ah that would probably work too
11:18:43 <crobbins> :t groupBy
11:18:44 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
11:18:55 <Black0range> chewbaccca: thanks i will have a look at it :) but from what i've read and head this is not the "haskell way", I wanna learn that first!
11:19:00 <crobbins> :t (==) `on` fst
11:19:01 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
11:19:32 <chewbaccca> Fuuzetsu: I think you arent helping when you are basically answering the "can you have state in haskell" into "you can do it like this without using state"
11:19:35 <crobbins> > groupBy ((==) `on` fst) [(1,2),(1,3),(2,3),(4,5)]
11:19:37 <lambdabot>  [[(1,2),(1,3)],[(2,3)],[(4,5)]]
11:21:05 <Cale> Black0range: There is a straightforward (but initially ugly) translation you can perform to turn any imperative program which operates by mutating some variables into a bunch of functions having the current values of those variables as parameters, and which call each other according to the control flow of the imperative program.
11:22:04 <Cale> Black0range: After performing this translation, you can usually simplify things a lot just by doing the highschool algebra sort of thing, substituting equals for equals and eliminating intermediate functions
11:22:05 <simpson> Cale: Is that SSA + phi nodes?
11:23:13 <Cale> simpson: hmmm...
11:25:45 <Cale> It looks something like this: http://www.reddit.com/r/haskell/comments/2cin7p/is_there_any_way_to_elegantly_represent_this/cjfvbpg
11:26:10 <Cale> I don't know what the relationship is with SSA, sorry
11:26:52 <Cale> Yeah, I guess it's a little like the SSA way of thinking about things
11:27:20 <dbushenko> guys pls help me with cabal.. when I'm in a sandbox, the package installs normally, but cabal still can't find it while building the app....
11:27:40 <dbushenko> also it can't find it when I do 'cabal install --only-dependencies'
11:28:03 <kadoban> dbushenko: What exactly does "cabal can't find it" mean?
11:28:10 <dbushenko> hdbc
11:28:19 <dbushenko> let me show you the message...
11:28:34 <dbushenko> cabal: Could not resolve dependencies:
11:28:35 <dbushenko> trying: myblog-0.1.0.0 (user goal)
11:28:35 <dbushenko> next goal: hdbc-mysql (dependency of myblog-0.1.0.0)
11:28:35 <dbushenko> Dependency tree exhaustively searched.
11:30:02 <kadoban> dbushenko: That doesn't mean it can't find it, that means it can't come up with a consistent set of packages to satisfy the dependencies of your package. I'm not really an expert, but I can try looking...can you paste your .cabal file somewhere?
11:30:15 <dbushenko> yes, one moment..
11:30:47 <dbushenko> kadoban, https://gist.github.com/anonymous/6f4a5c69241ac129d6ca
11:30:51 <batchm> > map (2^) [1..]
11:30:53 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
11:31:22 <batchm> > map (2^) [[0,1,2],[3,4,5]]
11:31:24 <lambdabot>  Could not deduce (GHC.Real.Integral [t0])
11:31:24 <lambdabot>    arising from a use of ‘GHC.Real.^’
11:31:25 <lambdabot>  from the context (GHC.Num.Num b)
11:31:25 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => [b]
11:31:25 <lambdabot>    at Top level
11:31:28 <batchm> how to make this work
11:31:53 <monochrom> you need to nest map. map (map (2^)) [[0,1,2],[3,4,5]]
11:31:54 <george___> I recently put ghci on arch. I'm getting "    Could not find module ‘Test.HUnit’
11:31:57 <george___>     Use -v to see a list of the files searched for.
11:32:03 <chewbaccca> > map (map (2^)) [[0,1,2],[3,4,5]]
11:32:03 <Cale> > map (map (2^)) [[0,1,2],[3,4,5]]
11:32:05 <lambdabot>  [[1,2,4],[8,16,32]]
11:32:05 <lambdabot>  [[1,2,4],[8,16,32]]
11:32:21 <monochrom> if you have nested list then you use nested map
11:32:21 <george___> I heard arch is known to be problematic... with haskell stuff
11:32:37 <batchm> makes sense, thanks!
11:34:34 <monochrom> george___: Test.HUnit is from a separate package HUnit, arch or not. does not come with GHC.
11:35:16 <BeardedCoder> dbushenko: HDBC and HDBC-mysql
11:35:24 <george___> Ahhh, okay. Yeah, I'm doing an assignment and it came like this. The fixes I looked up weren't working
11:35:25 <dbushenko> let me try...
11:35:30 <BeardedCoder> case sensative
11:35:39 <BeardedCoder> sensitive*
11:35:42 <dbushenko> wow!!!!
11:35:49 <dbushenko> BeardedCoder, thanks!
11:35:52 <BeardedCoder> np
11:35:58 <EvanR> shudders @ hdbc-mysql
11:36:49 <kadoban> Ah, nice catch.
11:40:29 <nyuszika7h> I'm trying to run the cabal-install bootstrap script and getting this error: https://clbin.com/bUxUn
11:41:24 <nyuszika7h> Utils.hi seems to be full of zero bytes o_O
11:42:26 <monochrom> your GHC installation is corrupted
11:42:58 <monochrom> the two files mentioned come with GHC, and should not be full of zeros.
11:44:17 <george___> exit
11:44:25 <nyuszika7h> just reinstalled GHC, let's see...
11:45:19 * hackagebot aivika 2.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-2.1 (DavidSorokin)
11:45:21 * hackagebot aivika-transformers 2.1 - Transformers for the Aivika simulation library  http://hackage.haskell.org/package/aivika-transformers-2.1 (DavidSorokin)
11:45:23 * hackagebot aivika-experiment 2.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-2.1 (DavidSorokin)
11:46:32 <batchm> is this a bad (inefficient) implementation of cycle?  cycle' xs = xs ++ cycle' xs
11:47:14 <nyuszika7h> (++) is O(n) I think
11:47:33 <batchm> yeah, but I am wondering if lazyness makes any difference?
11:48:36 <nyuszika7h> \o/ the build finished without errors now
11:48:50 <nyuszika7h> The Glorious Glasgow Haskell Compilation System, version 7.8.3
11:48:52 <monochrom> congrats
11:48:56 <nyuszika7h> cabal-install version 1.20.0.3 using version 1.20.0.0 of the Cabal library
11:49:03 <nyuszika7h> finally a recent Haskell Platform on Debian Wheezy
11:49:15 <nyuszika7h> now to install alex and happy...
11:49:29 <indiagreen> batchm: it's inefficient because it'll take more memory than needed
11:49:37 <pjdelport> @src cycle
11:49:38 <lambdabot> cycle [] = undefined
11:49:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:49:44 <Haskellfant> Is FlexibleInstances an “evil” extension and I should only use it if I absolutely have too or is it okay to use it whenever I feel like I want it?
11:50:05 <nyuszika7h> `xs' where xs' = xs ++ xs'` sounds unnecessarily complex
11:50:09 <batchm> is there a meaning in that where clause?
11:50:10 <joelteon> I don't think there are any evil extensions
11:50:16 <nyuszika7h> oh wait, it refers to xs' itself, never mind
11:50:20 * hackagebot aivika-experiment-chart 2.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-2.1 (DavidSorokin)
11:50:22 * hackagebot aivika-experiment-cairo 2.1 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-2.1 (DavidSorokin)
11:50:24 * hackagebot aivika-experiment-diagrams 2.1 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-2.1 (DavidSorokin)
11:50:34 <monochrom> batchm: "x = take n (cycle' [0])" will use Θ(n) space. "y = take n (cycle [0])" will use Θ(1) space. times are the same.
11:50:51 <pjdelport> batchm: That circular definition is key to making cycle efficient: it doesn't grow an infinite list, but uses knot-tying to make a circular list.
11:51:01 <amar_> @pl
11:51:02 <lambdabot> (line 1, column 1):
11:51:02 <lambdabot> unexpected end of input
11:51:02 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
11:51:05 <batchm> hmm
11:51:31 <batchm> I am not quite getting it
11:51:39 <amar_> @pl \n -> id (<=n)
11:51:39 <lambdabot> flip (<=)
11:52:00 <amar_> @pl \n -> size (<=n)
11:52:01 <lambdabot> size . flip (<=)
11:52:17 <pjdelport> batchm: You can think of "cycle [1]" as allocating only a single cons whose tail points back at itself.
11:52:19 <monochrom> sorry, I'm wrong, "y = take n (cycle [0])" still uses Θ(n) space, this time because "take n" does it.
11:54:20 <batchm> pjdelport ok that makes sense. that is what knot-tying is?
11:54:34 <pjdelport> batchm: More or less, yeah.
11:54:42 <pjdelport> https://www.haskell.org/haskellwiki/Tying_the_Knot
11:54:42 <monochrom> self-reference
11:55:08 <monochrom> self-referencing data structure. or simply cyclic data structure
11:55:37 <pjdelport> batchm: Lazy evaluation lets you define data structures that are actually self-referential in interesting ways, without having to use after-the-fact mutation or anything like that.
11:56:02 <monochrom> I don't like saying "tying the knot" because you already know the word "recursion" for self-referencing functions and "cyclic data structure" for self-referencing data.
11:56:47 <pjdelport> Yeah, true. It's not the most obvious term.
11:57:28 <clrnd> so what's an easy super simple lib for manipulating dates? no time, only 2014-9-30
11:57:35 <pjdelport> I think it just ends up getting used to specifically distinguish self-referential data structures that are defined lazily, rather than through mutation.
11:57:35 <batchm> but where is the difference in practice? if take n (f [0]) take n regardless if we use cycle or my cycle' above? and print (f [0])  work fine with both ,using constant space
11:58:08 <dmj`> Are there any haskell elasticache bindings?
11:58:33 <monochrom> here is the correct statement about space usage. suppose you have these top-level definitions: "x = cycle' [0]", "y = cycle [0]". then, after "print (take n x)", x occupies Θ(n) space. after "print (take n y)", y occupies Θ(1) space.
11:58:47 <batchm> ah
12:00:27 <batchm> what about time efficiency? would this be faster since we aren't using ++?
12:00:50 <batchm> http://lpaste.net/113477
12:00:54 <monochrom> I guess the "top-level" part is not important either. the important part is that x and y are retained, and you can ensured it by making sure that the program will still use x and y in the future.
12:01:33 <batchm> I understand. x grows and remains that big as long as it lives
12:02:53 <clrnd> dates or time?
12:05:24 <batchm> or is ++ called only once in cycle, since it is a recursive definition? this is confusing
12:06:31 <Cale> @src cycle
12:06:32 <lambdabot> cycle [] = undefined
12:06:32 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:06:48 <Cale> batchm: The (++) is only evaluated once in this version
12:06:57 <pjdelport> batchm: (++) only ends up being evaluated once, yes. As soon as it gets to the end, the tail slot is made to refer back to the start of the list that was just constructed.
12:06:57 <batchm> nice
12:07:00 <Cale> batchm: meaning that cycle xs has a maximum time cost of length xs
12:07:35 <Cale> (if you evaluate fewer elements of the resulting list, then may cost even less)
12:07:39 <Cale> it*
12:07:44 <batchm> I like how the more elegant solution is also more efficient
12:07:55 <pjdelport> batchm: Importantly, once cycle has run through the list once, cycle no longer evaluates any further: all that's left is a pure circular list.
12:08:17 <pjdelport> (as in, no unevaluated thunks except for the elements themselves, potentially)
12:08:39 <monochrom> ++ gets expanded to a lot of colons. it may be simpler to see the colon version.
12:09:00 <monochrom> "f x = x : f x" vs "g x = let s = x : s in s"
12:10:49 <monochrom> f 0 will create as many cons cells as you demand. g 0 will create just one cons cell that points back to itself. cycle' and cycle are just the same phenomenon on steroid.
12:11:00 <batchm> I have used let x = 1 : x before, I didn't know it only created one cell
12:12:19 <monochrom> yeah, an important part of lazy evaluation is "aliasing causes sharing". you use one name twice, you get two pointers pointing to the same place.
12:12:59 <RyanGlScott> What is considered the idiomatic way of expressing multi-arm if-expressions? I've seen this (http://lpaste.net/113478) before, but I'm not sure if it's the cleanest way.
12:13:46 <joe9> I am trying to understand continuations by reading/trying this article: https://www.fpcomplete.com/user/jwiegley/understanding-continuations  http://codepad.org/l3apJ4Km is my code. I do not understand what the line 12, callCC .. does.
12:13:54 <joe9> Can anyone please help?
12:14:10 <kadoban> RyanGlScott: Why do you need the case there? You can do guards without that.
12:14:12 <monochrom> RyanGlScott: in your particular case, "c wat | wat == a = 100" etc
12:14:31 <indiagreen> RyanGlScott: there's also MultiwayIf (an extension) and `cond` function in some helper package
12:14:53 <RyanGlScott> Sorry, that was a bad example. I was wanting to do it outside of the beginning of a top-level declaration.
12:15:31 <RyanGlScott> MultiwayIf looks like what I want. What version of GHC was it introduced in?
12:16:00 <Cale> joe9: It takes the remainder of the computation as a function of the result of the callCC (which in this case is ignored), and passes it to the given function (\k -> do k ()), executing the result.
12:16:01 <dmj`> 7.4.2 iirc
12:16:03 <Twey> What's a good package for *interactive* 2D graphics?  I like Gloss, but I'd like to be able to tag the ‘Picture’ type with a value that is reported along with the event indicating which bits of the picture were clicked (if any)
12:16:08 <monochrom> joe9: your "callCC (\k -> do k())" is on line 11, not 12. do you want 11 or 12?
12:16:51 <indiagreen> RyanGlScott: 7.6
12:16:53 <RyanGlScott> dmj`: Ah, I was afraid of that.
12:17:07 <RyanGlScott> Here's a better example of what I was talking about: https://github.com/haskell/network/blob/480ac19e9d65dcde43c1b7bbc97e79435da3319e/Network/Socket.hsc#L406-410
12:17:58 <RyanGlScott> In fact, I've only seen this technique used in the network package, AFAICT.
12:18:14 <monochrom> RyanGlScott: in that case, from my most preferred to least preferred: the "multi-way if" extension, chain of if-then-else, "case () of"
12:18:40 <Cale> joe9: That is to say, callCC h >>= f = h f
12:18:50 <monochrom> of course, if I use a chain of if-then-else, I'll format it nicely
12:19:09 <joe9> monochrom: Sorry about the line numbers. I want to understand the callCC line.
12:19:16 <RyanGlScott> monochrom: I'm trying to envision how you could neatly format it without rightward drift of code.
12:19:27 <joe9> Cale, I am trying to understand your comments. a few more minutes, please.
12:19:44 <Cale> joe9: Another way to look at it is that the callCC line doesn't do a heck of a lot here.
12:20:06 <joe9> http://codepad.org/ZoRxavYY Cale, monochrom
12:20:23 * hackagebot semi-iso 0.3.0.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.3.0.0 (pawel834)
12:20:25 * hackagebot syntax 0.1.1.0 - Abstract syntax descriptions for parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-0.1.1.0 (pawel834)
12:20:27 * hackagebot syntax-example 0.2.0.0 - Example application using syntax, a library for abstract syntax descriptions.  http://hackage.haskell.org/package/syntax-example-0.2.0.0 (pawel834)
12:20:44 <monochrom> joe9: that line simply does the same as return (). for a more interesting example, "callCC(\k -> do { k(); lift (putStrLn "do you see this?") } )". that will give you food for thought.
12:21:00 <albeit> Is there significant overhead in running with +RTS -T and/or calling getGCStats?
12:21:08 <monochrom> or your recent paste
12:21:14 <RyanGlScott> monochrom: Is this what you'd have in mind? http://lpaste.net/113479
12:21:23 <Cale> joe9: If you started out in imperative programming, you might have missed having a 'return' which aborts the current procedure
12:21:34 <joe9> Cale, I understand continuations as a concept. But, I am trying to follow it along using examples. Just want to check if there is better reading material out there.
12:21:47 <monochrom> k() is roughly "jump to the line with -- k"
12:21:47 <Cale> joe9: You can (somewhat as a special case) think of callCC as giving that back to you
12:22:08 <monochrom> yes RyanGlScott
12:22:49 <Cale> i.e. if you rename k to ret or something like that, it might help to understand why you don't see the "after k" get printed :)
12:25:06 <Cale> It's as if every procedure in an imperative language is implicitly wrapped in callCC (\k -> ...), and when you "return x", it executes k x
12:26:36 <Cale> joe9: Not sure if that explanation helps at all :)
12:28:11 <ReinH> heh
12:28:27 <ReinH> I'm sure it's a good explanation of continuations for someone who already understands continuations ;)
12:28:44 <ReinH> Cale: (this is something I constantly struggle with when trying to explain some of the harder concepts)
12:28:48 <Cale> Actually, I think I might've messed up when I said that callCC h >>= f = h f, that's not quite right.
12:28:57 <ReinH> heh
12:28:59 <Cale> (look what happens in this code)
12:29:34 <albeit> If I need a rare threaded function X to run without GC, and function Y produces lots of garbage and calls X, is it a good idea to occasionally call performGC?
12:29:55 <albeit> (from Y)
12:30:20 <Cale> albeit: What do you mean "run without GC"?
12:30:43 <albeit> Cale: It would be very bad if the function had to be interrupted by GC
12:30:48 <Cale> The GC isn't part of any thread's computation
12:31:07 <Cale> It stops all threads
12:31:50 <albeit> Yeah, but Y calls X, and I call the "stop-the-world" GC from Y occasionally, wouldn't that increase the chance of GC not being initiated during X's run?
12:32:17 <Cale> I don't know about that
12:33:14 <batchm> stop the world? :/@src fix
12:33:18 <batchm> woops
12:33:19 <batchm> :)
12:33:21 <batchm> @src fix
12:33:22 <lambdabot> fix f = let x = f x in x
12:34:38 <Cale> If you really need a piece of code to not be interrupted by GC, you should probably make it a foreign call. I'm not sure there's any other way to protect something from having a GC happen.
12:34:43 <batchm> why do we have let in there, when it could just be fix f = f (fix f) ? I don't think it has anything to do with tying the knot in this instance?
12:35:22 <S11001001> @hoogle a b -> f a b
12:35:25 <lambdabot> Control.Applicative.Backwards Backwards :: f a -> Backwards f a
12:35:25 <lambdabot> Control.Applicative.Lift Other :: (f a) -> Lift f a
12:35:25 <lambdabot> Data.Functor.Reverse Reverse :: f a -> Reverse f a
12:35:38 <Cale> batchm: Because fix f = f (fix f) would result in recomputing the result over and over
12:35:57 <Cale> batchm: There's no automatic memoisation of functions
12:36:07 <clrnd> is there a way to tell aeson to not include a field in the generated json?
12:36:10 <Cale> batchm: But values bound to variables are computed at most once
12:36:25 <albeit> Cale: But if the amount of memory being allocated is very deterministic for both X and Y, is there anything "wrong" with calling performGC so I know exactly when GC is being performed?
12:36:26 <batchm> I see
12:36:41 <albeit> * allocated and "garbaged"
12:36:52 <batchm> Cale but it is a recursive computation, how can it ever be computed?
12:36:53 <Cale> albeit: It should never affect the result of your program to execute performGC
12:37:05 <albeit> Okay
12:37:36 <Cale> batchm: consider something like  fix (1:)
12:37:50 <Cale> With the initial definition, that's  let x = 1:x in x
12:38:22 <Cale> batchm: This becomes a (:)-cell in memory with a pointer to 1 and then a pointer back to itself
12:38:42 <Cale> It's O(1) cost
12:38:48 <Cale> (in both space and time)
12:39:13 <Cale> With fix f = f (fix f), we have:
12:39:20 <Cale> fix (1:) = 1 : fix (1:)
12:39:23 <batchm> yes I know, we actually discussed that above. I just couldn't get from fix definition to that
12:39:41 <yukko> http://lpaste.net/113480 I don't understand why this doesn't work
12:39:48 <Cale> and then perhaps we'll evaluate the tail of that list and need to evaluate fix (1:) again, getting us 1 : 1 : fix (1:)
12:39:50 <Cale> and so on
12:40:25 * hackagebot gloss-banana 0.1.0.4 - An Interface for gloss in terms of a reactive-banana Behavior.  http://hackage.haskell.org/package/gloss-banana-0.1.0.4 (Twey)
12:40:29 <Cale> and it's potentially both O(n) time and memory, depending on how many elements of the result we use and whether we keep hold of the beginning of the list
12:41:18 <batchm> is lazy evaluation actually using mutation under the hood? because it has to replace thunk with the result?
12:41:40 <Fuuzetsu> Twey: wouldn't be a problem if you just put the extensions in the source file like a normal person
12:41:48 <Cale> yukko: The type of pred is  (Natural n, Natural m) => n -> m
12:42:08 <Cale> yukko: That is, for any types n and m which are instances of Natural, it converts one to the other.
12:42:47 <Cale> yukko: Your instance definition assumes a particular m, and doesn't work for an arbitrary choice of m like it's supposed to according to the class declaration
12:43:08 <Cale> batchm: typically, yes
12:43:45 <batchm> doesnt that have same problems as mutation in other languages?
12:43:47 <Twey> Fuuzetsu: I just did.  :þ
12:44:09 <Cale> batchm: Well, you don't have direct access to it, so it's the GHC authors' problem if something goes wrong.
12:44:20 <Twey> Got fed up of screwing about with Cabal every time I want to load a file.
12:44:35 <batchm> but what if you are accessing a list with a thunk from two threads?
12:44:43 <Cale> batchm: Also, lazy evaluation obtains the same result as plain outermost-first evaluation.
12:44:49 <Cale> It just does so more cheaply.
12:44:51 <Fuuzetsu> do I win the ‘extensions go into source files’ debate then
12:45:53 <Cale> batchm: Again, that's a bug in GHC if something goes wrong -- there are measures to prevent two threads from evaluating the same variable at the same time, and while there is technically a very small probability that they may do so anyway, it's guaranteed that they obtain the same result.
12:47:07 <batchm> so at worst thunk is just computed twice?
12:47:15 <batchm> with same result both times
12:47:22 <Cale> right
12:48:26 <geekosaur> are there such measures? I thought they removed them because they cost more than just letting it happen twice
12:48:31 <Cale> For expressions involving unsafePerformIO, that's no longer true, they might obtain different results, but unsafePerformIO has additional and more costly measures to prevent more than one thread from evaluating the same variable at once (there's unsafeDupablePerformIO if you'd like to avoid that)
12:48:31 <monochrom> batchm: for fix, see my http://www.vex.net/~trebla/haskell/fix.xhtml
12:48:47 <Cale> geekosaur: There's still grey-holing afaik.
12:49:25 <yukko> Cale thanks a bunch I fixed it!
12:49:35 <Fuuzetsu> what is the most unsafe unsafe* function around?
12:49:35 <yukko> although I actually don't really know how but it works now so I'm not complaining
12:50:00 <Fuuzetsu> I want to say unsafeCoerce is up there
12:50:10 <Cale> unsafeCoerce is implementable using unsafePerformIO
12:50:32 <Cale> (and IORefs)
12:50:38 <monochrom> I combine unsafeDupableIO and unsafeInterleaveIO for greatest unsafety :)
12:50:38 <johnarmstrong> i have defined a type like so: data Set a = Set [a], but I'm running into problems making it a member of the Show typeclass: instance Show (Set a) where show (Set x) = "{" ++ (show x) ++ "}"  is not accepted
12:50:40 <johnarmstrong> thanks
12:50:42 <amf> is binary or cereal the preferred way these days to encode arbitrary data structures into binary?
12:50:52 <Fuuzetsu> monochrom: s/unsafety/speed/ !
12:51:27 <Cale> amf: I think yes.
12:51:37 <monochrom> I should try to shoehorn reallyUnsafePointerEquality into that.
12:52:15 <amf> Cale: ha, i ask because i saw mentions of combining the two packages...
12:52:34 <johnarmstrong> help please
12:52:45 <bennofs> Cale: can't you implement unsafePerformIO with unsafeCoerce too?
12:52:50 <Fuuzetsu> johnarmstrong: you need Show a => … constraint
12:52:53 <yukko> johnarmstrong I think you need instance Show a => Show (Set a)
12:52:57 <Fuuzetsu> it doesn't know that ‘x’ can be showed
12:52:57 <Cale> bennofs: Yes, but not reliably
12:52:59 <yukko> whoops Fuuzetsu beat me to it
12:53:13 <Fuuzetsu> you should post error messages in the future ‘is not accepted’ is useless
12:53:21 <Fuuzetsu> better, learn to read the errors ;)
12:53:26 <johnarmstrong> yukko: i will try that thanks
12:53:29 <bennofs> Cale: so unsafePerformIO implemented using unsafeCoerce is even unsafer :)
12:54:34 <johnarmstrong> yukko: i would like it to return for Set [1,2] {1, 2} how to remove the brackets
12:55:04 <Hijiri> custom show instance
12:55:14 <Hijiri> so instead of show x you unravel it yourself
12:55:25 <johnarmstrong> in an outside funtion?
12:55:41 <Hijiri> could be in a where clause, but a function somewhere
12:55:51 <johnarmstrong> thanks
12:56:00 <Hijiri> but different from the default Show a => [a] instance
12:56:05 <Hijiri> np
12:57:18 <jhance> @find twintail ni na 04 720
12:57:19 <lambdabot> Not in scope: type variable ‘twintail’
12:57:19 <lambdabot> Not in scope: type variable ‘ni’
12:57:20 <lambdabot> Not in scope: type variable ‘na’
12:57:28 <jhance> welp
12:57:39 <Fuuzetsu> I should probably start watching that
12:57:47 <Twey> Fuuzetsu: Seems like your kind of thing :þ
12:57:57 <Fuuzetsu> make days last 50 hours
12:58:29 <Black0range> hey guys, new to haskell... could someone tell me why this little thing doesn't compile? http://pastebin.com/q0fKUAL3
12:58:44 <Fuuzetsu> Black0range: what's the error?
12:58:58 <Fuuzetsu> do people not understand that GHC's error messages are useful?
12:59:27 <Black0range> Well but if yo dont understand haskell correctly the error messages har hard to understand
12:59:41 <Fuuzetsu> your problem is that windoor is an IO action, and x is Int
12:59:44 <Fuuzetsu> you can't copmare the two
13:00:20 <Fuuzetsu> you should use do and randomNumber <- fmap …; followed by x == randomNumber in your check
13:00:32 <Black0range> but it works in the interpreter :/
13:00:38 <Fuuzetsu> no it doesn't
13:01:00 <monochrom> something else worked in the interpreter
13:01:06 <Black0range> hah
13:04:16 <Black0range> sooo.... http://pastebin.com/GAxfJgJx?
13:04:44 <Fuuzetsu> that will not work for a different reason
13:04:50 <Black0range> ...
13:04:51 <Fuuzetsu> also stop using hard tabs
13:05:13 <Fuuzetsu> lastly, lpaste.net is the recommended pastebin, it will tell you about style issues &c
13:05:16 <monochrom> bad alignment. put "[" right under "r"
13:05:53 <monochrom> in do-blocks, if you don't use {;}, then alignment is important.
13:06:08 <Fuuzetsu> monochrom: still needs the η thing
13:06:23 <monochrom> and alignment means what you see on paste sites, not what you see in your editor. your editor lies. it always lies. paste sites are honest.
13:06:37 <Black0range> http://lpaste.net/113484
13:06:39 <Black0range> still no work
13:06:45 <monochrom> oh, true, it needs a "return".
13:06:56 <Black0range> Wait what haskell has returns?!
13:07:01 <Fuuzetsu> no
13:07:06 <monochrom> perhaps it's time to suggest my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
13:07:13 <Fuuzetsu> the ‘return’ is not the return from other languages
13:08:19 <Black0range> http://lpaste.net/113484
13:08:21 <Black0range> ...
13:08:32 <Hijiri> is there any reason GHC uses let x = x in x as its placeholder rather than undefined?
13:08:50 <Hijiri> I guess it doesn't import prelude?
13:09:28 <monochrom> yeah, Prelude imports those things
13:09:29 <Fuuzetsu> it's magic which doesn't require anything else to be in scope
13:09:36 <geekosaur> as far as I know that's the reason, importing Prelude would lead to circular dependencies
13:10:03 <Black0range> so whats wrong with the latest draft here?
13:10:12 <bam365> BlackOrange: if <exp> then True else False  is equivalent to <exp> by itself with no if expression
13:10:29 * hackagebot gloss-sodium 0.1.0.0 - A Sodium interface to the Gloss drawing package.  http://hackage.haskell.org/package/gloss-sodium-0.1.0.0 (Twey)
13:10:56 <Black0range> well you are correct... but this doesn't compile
13:11:24 <monochrom> ok, this one is an ambiguous type thing. do you want Int? do you want Integer?
13:11:33 <Black0range> int is fine
13:12:17 <monochrom> change "x == randInt" to "(x :: Int) == randInt"
13:12:57 <monochrom> another way is to give the type signature "makeRandList :: IO [Int]"
13:13:10 <monochrom> err, that's wrong, nevermind
13:14:31 <Fuuzetsu> only the IO [Int] part, not the (x :: Int) part that is
13:14:46 <JonReed> http://lpaste.net/113486
13:14:59 <Black0range> Works fine! :)
13:15:03 <JonReed> I just implemented it out of curiocity, since I'm new to haskell
13:15:04 <Fuuzetsu> makeRandList >>= print
13:17:15 <Black0range> using a type declaration how do i say it takes no arguments and returns a list of booleans?
13:17:23 <Fuuzetsu> foo :: [Bool]
13:17:38 <Mokosha> is there a time when implementing an instance of Storable that you can define sizeOf without "sizeOf _" ?
13:18:00 <Hijiri> If it's an IO action it needs to be IO [Bool] though
13:18:32 <Black0range> Wait i toght the IO only takes place inside the function?
13:18:36 <Hijiri> no
13:18:50 <Hijiri> IO doesn't take place in functions (conceptually)
13:19:09 <Hijiri> IO a is a value that represents an action that can be carried out, yielding a value of a
13:19:33 <Hijiri> You can think of objects of types (IO a) to be values that  represent programs
13:19:50 <argent0> Hello, is there a way to show "Hello, world!" in a program using Applicative?
13:19:54 <Hijiri> so something like String -> IO () is a function that takes a string and give you a program
13:20:10 <Fuuzetsu> argent0: No, Applicative has nothing to do with showing "Hello, world!"
13:20:16 <Hijiri> and then you can compose these programs together with bind or do notation
13:20:33 <Black0range> oh does this have something to do with lazy evaluation?
13:20:39 <Fuuzetsu> argent0: I find your question very strange, can you explain where it came from?
13:20:40 <Hijiri> not really
13:20:52 <argent0> Fuuzetsu: main = (snd <$> countInversions <$> fmap r <$> lines <$> getContents) >>= print where r cc = read cc :: Integer
13:20:59 <Hijiri> It's that functions and IO are decoupled as concepts in Haskell
13:21:24 <Black0range> But if it's not that why do we care what the function does? the only important part is what we get out of it?
13:21:37 <Hijiri> functions just map inputs to outputs
13:21:46 <Hijiri> they don't print lines or launch the missiles
13:22:09 <Hijiri> except maybe things like unsafePerformIO
13:22:12 <Hijiri> but those are exceptions
13:22:30 <argent0> Fuuzetsu: It says in the wiki: In general, whenever the choice or construction of monadic actions does not depend on the outcomes of previous monadic actions, then it should be possible to rewrite everything with
13:22:33 <Hijiri> but IO () values can be read and carried out
13:22:34 <argent0> liftM
13:22:46 <Fuuzetsu> argent0: liftM is simply fmap for Monad
13:22:48 <Fuuzetsu> :t fmap
13:22:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:22:51 <Fuuzetsu> :t liftM
13:22:53 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:22:54 <Hijiri> The only IO a action that gets carried out it main
13:23:00 <Black0range> Haskell is so alien... :)
13:23:00 <HeladoDeBrownie> argent0, Applicative and Monad are for "pasting" actions together, in a sense; however, printing "Hello world" is a single action, the result of putStrLn, so you don't need either.
13:23:03 <Hijiri> you can see that in the type, main :: IO ()
13:23:07 <HeladoDeBrownie> @type putStrLn "Hello, world"
13:23:08 <lambdabot> IO ()
13:23:35 <Fuuzetsu> HeladoDeBrownie: I believe he wants to eliminate (>>= print) in favour of (print `someApplicativeThing`)
13:23:55 <Hijiri> So you have to put together IO a values, and define main to be that
13:23:59 <Hijiri> otherwise they will never get run
13:24:56 <Fuuzetsu> argent0: the difference between Monad and Applicative is the (>>=) which has the exact type you need to glue print together
13:25:08 <argent0> HeladoDeBrownie: What if the string is the result of a previous action?
13:25:16 <Fuuzetsu> Applicative doesn't let you inspect the values and decide what to run (in this case print)
13:25:48 <argent0> Fuuzetsu: Ok, Thanks!
13:26:03 <Fuuzetsu> argent0: if you simply think about the types you need, you'll understand it quickly
13:26:36 <Fuuzetsu> you have (Show a => IO a) and print has type (Show a => a -> IO ())
13:27:04 <Fuuzetsu> so to stitch these we need something of type ‘IO a -> (a -> IO ()) -> IO ()’
13:27:05 <argent0> Fuuzetsu: I knew I could use (>>=). But I could have been missing somethig. I think it's more clear now
13:27:09 <Fuuzetsu> :t (>>=)
13:27:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:27:21 <Fuuzetsu> cool, as long as you get it
13:28:29 <Fuuzetsu> :t ?m >>= print
13:28:31 <lambdabot> (?m::IO a, Show a) => IO ()
13:28:36 <Fuuzetsu> ugh
13:29:18 <pharpend> :t \m -> m >>= print
13:29:19 <lambdabot> Show a => IO a -> IO ()
13:29:59 <pharpend> that's just a general version of mapM, isn't it?
13:30:24 <Fuuzetsu> @src mapM
13:30:25 <lambdabot> mapM f as = sequence (map f as)
13:30:34 <Fuuzetsu> @src sequence
13:30:35 <lambdabot> sequence []     = return []
13:30:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:30:35 <lambdabot> --OR
13:30:35 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:30:45 <Fuuzetsu> whatever
13:30:50 <pharpend> Fuuzetsu: mapM in lambdabot is likely from Data.Traversable, not from Control.Monad
13:31:06 <Fuuzetsu> I doubt
13:31:06 <pharpend> Fuuzetsu: I was referring to Control.Monad.mapM
13:31:10 <Fuuzetsu> I know
13:31:12 <pharpend> :t mapM
13:31:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:31:22 <pharpend> @info mapM
13:31:22 <lambdabot> mapM
13:31:22 <Fuuzetsu>  @src and :t are disjoint
13:31:27 <batchm> I didn't quite get this one from monochromes link: "The function is called fix because for the equation  x = f x  (considering x as an unknown to be solved for) solutions are called fixed points of f. They are so called because, as the equation promises, if you plug one of them into f, you get it back."
13:31:42 <batchm> can someone give me an example where x is equal to f x?
13:31:52 <Fuuzetsu> sure
13:31:54 <vanila> "abba" = reverse "abba"
13:31:55 <Fuuzetsu> > id 5
13:31:55 <pharpend> batchm: if f = (+0)
13:31:57 <lambdabot>  5
13:32:13 <pharpend> batchm: (+0) x = x forall numeric x
13:32:15 <ThreeOfEight> Fuuzetsu: fix only makes sense if the fixed point you are looking for is a function
13:32:16 <indiagreen> batchm: take function (1:). Can you find such list “x” where “1:x” would be the same as “x”?
13:32:18 <batchm> but how does that relate to fix?
13:32:34 <ThreeOfEight> or, well, an infinite data structure
13:32:41 <ThreeOfEight> because lazy evaluation
13:32:42 <afrobee> Wow, this IRC is full this day
13:32:49 <pharpend> batchm: it would be like taking a function that removes all 5's from a list
13:33:12 <pharpend> batchm: if you give it [1,2,3,4,5], it will return [1,2,3,4]. However, if you give it [1,2,3,4], it will give you [1,2,3,4]
13:33:16 <ThreeOfEight> fix is interesting because recursively-defined functions can be described as fixed points
13:33:27 <Black0range> newline char in haskell == \n?
13:33:30 <Fuuzetsu> yes
13:33:32 <pharpend> Black0range: yes
13:33:33 <Black0range> ty
13:33:46 <pharpend> Black0range: we even have printf
13:34:16 <Black0range> O.o
13:34:24 <pharpend> @type printf
13:34:27 <lambdabot> PrintfType r => String -> r
13:34:38 <Fuuzetsu> that is unlikely to help
13:34:52 <Black0range> google is a good god dont worry
13:34:52 <batchm> id being a fixed point, or (0+), all makes sense. but what about fixed point of:
13:34:58 <pharpend> > (printf "(%i,%s)" 4 "Hello, world") :: String
13:35:00 <lambdabot>  "(4,Hello, world)"
13:35:02 <batchm> > fix (1:)
13:35:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:35:16 <Fuuzetsu> it's ^
13:35:21 <Fuuzetsu> infinite list of 1s
13:35:24 <ThreeOfEight> More interesting: what is the fixpoint of (+1)?
13:35:31 * hackagebot json-python 0.3.0.1 - Call python inline from haskell  http://hackage.haskell.org/package/json-python-0.3.0.1 (russell91)
13:35:35 <ThreeOfEight> > fix (+1) :: Integer
13:35:36 <bam365> > replicateM 3 (randomIO :: IO Bool)
13:35:37 <lambdabot>  mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
13:35:37 <lambdabot>  <IO [Bool]>
13:35:38 <pharpend> ThreeOfEight: infinities
13:35:40 <Black0range> sum[1..]
13:35:49 <Black0range> wrong window... :)
13:35:52 <ThreeOfEight> pharpend: there is no ‘infinity’ value in Integer
13:35:56 <Black0range> nope that did not go well
13:36:05 <josephle> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 4
13:36:06 <ThreeOfEight> which is why it fix (+1) simply doesn't terminate
13:36:07 <lambdabot>  24
13:36:07 <pharpend> ThreeOfEight: i know, but in math, those would be the fix points
13:36:14 <Black0range> any way to quit execution in interperter?
13:36:19 <Fuuzetsu> Control + C
13:36:22 <ThreeOfEight> they would be if they existed
13:36:29 <Black0range> ty
13:36:40 <ThreeOfEight> you can, of course, ‘artificially’ introduce such fixed points
13:36:49 <ThreeOfEight> (as you do for compatification, for instance)
13:36:54 <Fuuzetsu> if x > 10 then Infinity else x
13:36:57 <_ahg> What is the standard remote-repo in .cabal/config? I switched to Stackage and I would like to switch back, but I didn't back up my config file before changing my remote-repo.
13:36:57 <ThreeOfEight> anyway, so, yes, if there is no fixed point, fix will simply not terminate
13:37:22 <Fuuzetsu> _ahg: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
13:37:24 <ThreeOfEight> because ‘bottom’ is always a fixed point
13:37:39 <_ahg> Fuuzetsu: Thanks so much
13:38:31 <batchm> > fix (\v n -> if n==0 then 1 else n * v(n-1)) 2
13:38:33 <lambdabot>  2
13:38:58 <batchm> 2 is fixed point?
13:39:00 <Fuuzetsu> who uses ‘v’ for that ;P ‘f’ for life!
13:39:03 <batchm> > fix (\v n -> if n==0 then 1 else n * v(n-1)) 0
13:39:06 <lambdabot>  1
13:39:13 <batchm> how about 0? we got 1 back, not 0
13:39:27 <Fuuzetsu> batchm: the value is not the fixed point
13:39:31 <Fuuzetsu> the *function* is
13:39:50 <Black0range> printf \% to escape the % ?
13:40:02 <Fuuzetsu> why would % need escaping?
13:40:06 <batchm> Fuuzetsu I don't quite get that
13:40:19 <Black0range> sorry, if i want to print the "%" character
13:40:25 <Fuuzetsu> oh
13:40:27 <Fuuzetsu> try %%
13:40:55 <Fuuzetsu> not sure what printf does, but \ is a Haskell thing for escaping, not printf thing
13:41:08 <Black0range> no printf the function
13:41:11 <batchm> printf works like printf in C
13:41:17 <batchm> %% is for printing %
13:41:57 <Black0range> I just made a poor choice of words :)
13:42:53 <Black0range> Btw thanks for helping me, I really appreciate it
13:44:14 <batchm> value is not a fixed point, the function is? I can't make any sense of that
13:44:18 <piskrist> how do you IO a -> IO b -> IO (a,b) ?
13:44:34 <Fuuzetsu> batchm: wouldn't it be useless if you just got the same thing out of fix foo?
13:44:40 <pjdelport> piskrist: liftA2 (,)
13:45:17 <batchm> Fuuzetsu yes.. I just can't see what is f, and what x there, where f x  = x
13:45:18 <albeit> :t liftA2 (,)
13:45:19 <lambdabot> Applicative f => f a -> f b -> f (a, b)
13:45:25 <albeit> :t liftA2
13:45:25 <pjdelport> piskrist: Or: (,) <$> x <*> y
13:45:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:46:13 <albeit> pjdelport: Why do you choose liftA2 instead of liftM2 in that case?
13:46:19 <Fuuzetsu> batchm: the ‘f’ is the thing you pass to fix as first argument
13:47:03 <pjdelport> albeit: liftA2 is closer to being the "right" abstraction level for it; liftM2 predates the adoption of Applicative and everything.
13:47:06 <josephle> the equation you want to solve is fix f = f (fix f)
13:47:15 <pjdelport> So liftM2 is over-constrained.
13:47:21 <albeit> Ah okay
13:47:33 <Cale> batchm: hm?
13:47:58 <Cale> batchm: Oh, I see your question
13:48:08 * Fuuzetsu can't find good words
13:48:11 <batchm> Cale I can't make sense of: "The function is called fix because for the equation x = f x (considering x as an unknown to be solved for) solutions are called fixed points of f. They are so called because, as the equation promises, if you plug one of them into f, you get it back."
13:48:18 <batchm> given:
13:48:20 <Cale> We're finding a fixed point of the function (\v n -> if n == 0 then 1 else n * v (n-1))
13:48:33 <batchm> yes
13:48:47 <Cale> Now, let's be careful and think about what the type of this function is
13:49:03 <Cale> Or just ask GHC :)
13:49:10 <Cale> :t (\v n -> if n == 0 then 1 else n * v (n-1))
13:49:12 <lambdabot> (Num a, Eq a) => (a -> a) -> a -> a
13:49:35 <Cale> For simplicity, we could just consider it to be a function (Integer -> Integer) -> (Integer -> Integer)
13:49:51 <Cale> So, a fixed point of this function is itself a function (Integer -> Integer)
13:50:42 <piskrist> cool
13:50:44 <piskrist> thanks
13:51:36 <Cale> It might be helpful to consider what happens when we iterate (\v n -> if n == 0 then 1 else n * v (n-1)) starting with a totally undefined function
13:52:03 <Black0range> More supid questions! :D why does the compiler complain? http://lpaste.net/113484
13:52:08 <Black0range> Couldn't match expected type `Float' with actual type `Int'
13:52:21 <Fuuzetsu> Black0range: because it expected a Float where you gave Int
13:52:32 <Fuuzetsu> it should tell you exactly where too
13:53:06 <geekosaur> because (/) is not defined on Int, and :: is not a cast, it specifies the type you think the thing will have
13:53:07 <clrnd> Black0range, that True at the end is so lispy
13:53:16 <bam365> BlackOrange: why bother with the True at the end?
13:53:22 <Cale> Black0range: All the arithmetic operations preserve the type of their arguments
13:53:25 <Cale> :t (/)
13:53:26 <lambdabot> Fractional a => a -> a -> a
13:53:28 <Cale> :t (*)
13:53:30 <lambdabot> Num a => a -> a -> a
13:53:32 <Cale> :t (+)
13:53:33 <lambdabot> Num a => a -> a -> a
13:53:44 <Black0range> i thought all haskell functions need a return value?
13:53:45 <Cale> They always produce the same type of result as the type of the arguments
13:53:51 <kadoban> Black0range: Type annotations aren't casts, remember. And haskell doesn't do type coersion
13:53:52 <Black0range> and i have nooo idea what printf returns
13:53:53 <clrnd> division in haskell is so painfull for begginners ...
13:53:57 <Cale> So if wins and losses are both Int values, then so is wins + losses
13:54:16 <Fuuzetsu> Black0range: they all automatically do, you can't just stick something in the end randomly
13:54:19 <Cale> and so must wins / (wins + losses), though this will already be a problem because Int is not an instance of Fractional.
13:54:51 <Cale> Oh, yeah, you've given printf an extra argument there
13:54:54 <bam365> printf probably returns IO ()
13:55:01 <clrnd> printf returns String
13:55:06 <geekosaur> either
13:55:14 <clrnd> :t printf
13:55:15 <lambdabot> PrintfType r => String -> r
13:55:16 <geekosaur> that's part of the PrintfType
13:55:17 <Cale> which will likely result in a runtime error if your expression actually typechecks
13:55:24 <ReinH> (You have to be careful to provide printf the correct number of arguments since it can't enforce that at the type level.)
13:55:42 <Fuuzetsu> why is Haskell's type system so bad ReinH?
13:55:44 <Cale> and yeah, the result of this function is not Bool
13:55:47 <Fuuzetsu> can't even print things properly
13:55:48 <clrnd> ok thsi got messy, Black0range try using fromIntegral
13:55:54 <ReinH> Fuuzetsu: :p
13:56:08 <Cale> Yeah, you probably want  displayResult :: Int -> Int -> IO ()
13:56:14 <ReinH> Fuuzetsu: it's good enough to let you do ridiculous things like printf but not good enough to warn you that maybe it wasn't a very good idea. ;)
13:57:01 <ReinH> Black0range: if you're struggling with the types of things, I would really recommend that you not also use printf. printf will obscure any actual type errors and make debugging more difficult.
13:57:03 <Fuuzetsu> typeclass hackery all day
13:57:08 <Black0range> And here i was sitting thinking "Well haskell is hard... good thing i know basic math..." NOPE!
13:57:11 <clrnd> I actually have to google the difference between the several exponentiation functions every time, I usaully end up multiplying this manually
13:57:34 <clrnd> thins*
13:57:40 <Fuuzetsu> Black0range: just learn to read and unify the types and you're half-way there
13:57:42 <ReinH> If you want a type safe alternative to printf, try
13:57:46 <ReinH> @hackage formatting
13:57:46 <lambdabot> http://hackage.haskell.org/package/formatting
13:57:57 <clrnd> > (5 :: Int) / (6 :: Int)
13:57:59 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
13:57:59 <lambdabot>    arising from a use of ‘GHC.Real./’
13:58:11 <pjdelport> > 5 `div` 6
13:58:13 <lambdabot>  0
13:58:14 <clrnd> > fromIntegral (5 :: Int) / fromIntegral (6 :: Int)
13:58:16 <lambdabot>  0.8333333333333334
13:58:22 <clrnd> :t fromIntegral (5 :: Int) / fromIntegral (6 :: Int)
13:58:23 <lambdabot> Fractional a => a
13:58:33 <Fuuzetsu> ReinH: builders just don't have the same feel of magic though
13:58:36 <Cale> clrnd: (^) allows any type of numeric base, but only nonnegative integer exponents, (^^) allows only fractional bases, but permits negative integer exponents, and (**) allows only floating point bases, but also allows floating point exponents.
13:58:36 <clrnd> Black0range, ^
13:58:41 <ReinH> Fuuzetsu: I don't actually like magic.
13:58:42 * Fuuzetsu can't remember the last time he actually used printf
13:59:01 <clrnd> Cale, yeah I'll ask you and/or google it when I need to do it
13:59:05 <ReinH> I have enough trouble understanding type errors when they're actually real errors ;)
13:59:06 <Cale> :)
13:59:20 <glguy> clrnd: you should be able to work it out from the types
13:59:29 <ReinH> :t (^^)
13:59:30 <lambdabot> (Integral b, Fractional a) => a -> b -> a
13:59:43 <clrnd> glguy, right, I'll hoogle it/google it/:t it/ask Cale when I need to use them
14:00:03 <Fuuzetsu> :t \d b -> d(^^)b
14:00:05 <lambdabot> (Integral b, Fractional a) => ((a -> b -> a) -> t1 -> t) -> t1 -> t
14:00:13 <clrnd> jajajajja
14:00:34 * hackagebot cql-io 0.9.7 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.9.7 (ToralfWittner)
14:00:46 <NemesisD> i've got a question if something is possible/a good idea. if I wanted to quickCheck a property prop a = read (show a) == a, but that function has to be decided on one instance of Read/Show a. would it be possible to use TH to query *all* instances of Show/Read that can be narrowed down to concrete types and generate properties for each?
14:00:47 <clrnd> and that True at the end, that's why wadler hates SICP
14:00:49 <Fuuzetsu> when are we starting obfustacted Haskell contest
14:00:52 <Black0range> uh this row became really long
14:01:01 <Fuuzetsu> obfuscated*
14:01:04 <clrnd> gotta go cya
14:01:13 <glguy> Fuuzetsu: Hackage? ^_^
14:01:14 <Black0range> clrnd: that true isn't a lisp thing i did it because of Haskell :P
14:01:39 <Fuuzetsu> glguy: well, in a contest someone would actually go and look at the code
14:01:47 <glguy> Oh, no. Not Hackage :-p
14:01:51 <batchm> so fixed point of (\v -> \n -> if n == 0 then 1 else n * v (n-1))    is    \n -> if n == 0 then 1 else n * v (n-1) ? Or something?
14:02:27 <batchm> sorry if I am dwelling on it too much :P
14:02:51 <Fuuzetsu> that's about right I think
14:03:21 <Fuuzetsu> with x = 1
14:03:24 <Black0range> So this is what you guys wanted me to write? http://lpaste.net/113484
14:03:52 <Fuuzetsu> Black0range: you don't need ‘wins :: Int’ everywhere, GHC already knows it from the function signature
14:04:34 <Fuuzetsu> and no, it's still wrong, ((fromIntegral foo :: Int) * 100) can't somehow magically become Float
14:05:42 <Black0range> I made it work! huzza!
14:06:10 * Fuuzetsu gets worried
14:06:36 <Black0range> ? :P
14:06:42 <josephle> batchm: I think dwelling on fixed-points is not a bad way to spend your time :)
14:07:46 <Black0range> I can almost feel the same thill as the first time I wrote a javascript and it work :P
14:08:11 <Black0range> good o'l days
14:08:12 <batchm> josephle :)
14:13:02 <Black0range> btw once and for all... so if i use fmap (`mod` 3) randomIO this i will get a IO Int right? How do I tell haskell that i want it to be a normal Int?
14:13:07 <batchm> Black0range printf is a weird function, one of the weirdness is that it can both print and return (). try changing IO () in the signature to String
14:13:59 <HeladoDeBrownie> Black0range, there is no function that will (non-pseudo-)randomly give you an Int.
14:14:00 <batchm> Black0range you can't. no way out of IO. :P
14:14:25 <Black0range> cant i convert it or something?
14:14:25 <Fuuzetsu> http://spl.smugmug.com/Humor/Lambdacats/i-tSKXkj9
14:14:28 <batchm> you can compose new IO, that will attach additional computation to it
14:14:42 <Fuuzetsu> @quote list of files
14:14:42 <lambdabot> No quotes for this person. There are some things that I just don't know.
14:14:55 <Haskellfant> Black0range: the point of IO is that you can't escape from it
14:15:02 <HeladoDeBrownie> Black0range, no. If you want to use a function on a randomly generated number, you'll just have to fmap the procedure that generates the number.
14:15:06 <Haskellfant> this forces you to isolate your IO from the rest
14:15:13 <geekosaur> @quote /bin/ls
14:15:13 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:15:16 <glguy> Black0range: In the same way that you used "fmap" to produce a new IO Int that returned values in the range 0-2, you'll use fmap or other mechanisms to create an IO Something, where that Something uses the random number (possibly)
14:15:31 <Fuuzetsu> geekosaur: one day will come when I remember how to summon that thing
14:15:34 <Fuuzetsu> I suspect it is not any day soon
14:15:55 <batchm> Black0range because you can't escape from IO you have ensurance that `Int -> Int' function won't do anything but take an Int and produce another int. it won't print the value of int in the middle of computation
14:16:10 <batchm> or do any other side effect
14:16:54 <monochrom> Black0range: have you read my http://www.vex.net/~trebla/haskell/IO.xhtml ?
14:17:01 <Black0range> btw batchm: chaning IO() to str made the \n non escaped
14:17:27 <Black0range> monochrom: added it to my reading list
14:17:37 <Black0range> getting late here :)
14:17:44 <batchm> Black0range it is escaped, you are just printing the value of a string.
14:17:53 <batchm> or rather, the repl is
14:18:14 <batchm> if you try "putStrLn (displayResult ..)" you will get a newline instead of \n
14:19:59 <monochrom> print gives you escaped things because to a large extent its purpose is to tell you how you would write things in code
14:21:50 <batchm> I think it was repl that was printing it, since he changed displayResult from returning IO () to returning String
14:22:19 <Black0range> *Main System.Random> displayResult 1 2
14:22:19 <Black0range> Wins: 1
14:22:19 <Black0range> Losses: 2
14:22:21 <Black0range> with IO():
14:22:26 <monochrom> I see. well, the repl has expressed the same purpose, too
14:22:28 <noa-> hello
14:22:29 <Black0range> without "Wins: 1\nLosses: 2\nPercent winns: 33.33%"
14:22:38 <monochrom> s/expressed/expressedly/
14:23:06 <monochrom> repl treats you as a programmer not an end user
14:24:37 <Black0range> Wonder if i can make it treat me like a gentleman... :)
14:25:18 <shapr> whoa, zygomorphisms thesis from 1962: http://cgi.csc.liv.ac.uk/~grant/PS/thesis.pdf
14:25:45 <jle`> haskell is just like javascript basically
14:26:02 <Black0range> ehm...
14:26:05 <vanila> haskell isnt lik e javascript
14:26:15 <jle`> oh that was supposed to be in #haskell-blah
14:26:20 <jle`> where someone just posted a quote saying that >_>
14:26:33 <jle`> @quote uman Javascript
14:26:33 <lambdabot> uman says: so you can pass functions around as objects... this sounds like JavaScript
14:27:22 <Black0range> @quote jle` Javascript
14:27:23 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
14:27:28 <Black0range> hmmm
14:28:02 <Black0range> I think javascript is trying to invade
14:29:46 <geekosaur> ghcjs, anyone? :p
14:31:00 <noa-> > [(x,y) | x <- [1..5], y <- [1..5]]
14:31:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
14:35:33 <noa-> does someone know off hand that code that gets all the right triangles? cant find it in LYAH
14:35:49 <noa-> with list comprehensions
14:35:56 <belst> ?
14:36:25 <noa-> I think it was from LYAH
14:36:28 <indiagreen> noa-: you don't mean all Pythagorean triplets, by any chance?
14:36:38 <noa-> indiagreen: yes
14:36:53 <noa-> much better way of putting it :)
14:36:53 <n4x> something like \n → [ (x,y,z) | x ← [1..n], y ← [x..n], z ← [y..n], x^2+y^2 == z^2]  ?
14:37:10 <noa-> looks like it
14:37:14 <vanila> why don't you use the formula to generate them?
14:37:17 <n4x> I just made it though
14:37:49 <noa-> I know the formula, didnt know how to express it in here
14:37:55 <vanila> > let f m n = (m^2 - n^2, 2*m*n, m^2 + n^2) in liftM2 f [1..10] [1..10]
14:37:57 <lambdabot>  [(0,2,2),(-3,4,5),(-8,6,10),(-15,8,17),(-24,10,26),(-35,12,37),(-48,14,50),(...
14:39:09 <batchm> > [(a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2 == c^2]
14:39:13 <lambdabot>  mueval-core: Time limit exceeded
14:39:21 <batchm> huh
14:39:31 <batchm> > [(a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2 == c^2]
14:39:35 <lambdabot>  mueval-core: Time limit exceeded
14:39:56 <batchm> well it worked in repl..
14:41:13 <indiagreen> > take 10 [(a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2 == c^2]
14:41:15 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
14:41:22 <indiagreen> hm, why doesn't it work without “take 10”?
14:41:29 <lpaste> glguy pasted “Generating Pythagorean triples” at http://lpaste.net/113494
14:41:51 <Rembane> indiagreen: c goes to infinity
14:42:01 <batchm> > [1..]
14:42:02 <indiagreen> > [1..]
14:42:03 <lambdabot>  can't find file: L.hs
14:42:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:42:08 <batchm> :D
14:42:18 * indiagreen high-fives batchm
14:42:40 <indiagreen> > [(x,y) | x <- [1..], y <- [1..x]]
14:42:42 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
14:43:12 <glguy> batchm: You can adapt that lpaste code to find the triples you're interested it without having to enumerate all the numbers manually
14:43:52 <batchm> :glguy it was noa who asked it, actually.
14:44:05 <glguy> either way ^_^
14:44:33 <batchm> > show [(a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2 == c^2]
14:44:37 <lambdabot>  mueval-core: Time limit exceeded
14:44:38 <batchm> > take 100 $ show [(a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2 == c^2]
14:44:40 <lambdabot>  "[(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24...
14:44:45 <batchm> huh, weird
14:45:47 <noa-> thanks all
14:46:39 <Black0range> would some kind sould explain to me what error here is ? http://lpaste.net/113495
14:47:09 <indiagreen> ...why adding “map (:[])” in front of -what batchm is trying- makes lambdabot output everything as expected
14:47:44 <Hijiri> well for one thing you're using hard tabs Black0range
14:47:53 <Hijiri> the layout might be throwing it off
14:48:26 <Hijiri> also randInt is IO Int
14:48:31 <Hijiri> You can't pass it into drop
14:48:38 <Hijiri> because that expects Int
14:48:52 <Black0range> oh yeah and there is no way to convert it...
14:49:06 <Black0range> who thought that was a good idea?!
14:49:23 <Hijiri> you can't use IO things outside of IO actions
14:49:30 <kadoban> Black0range: You can't convert it, but you can use it...you just have to be in IO
14:49:35 <geekosaur> because it inserts laziness? most math operations are strict and the pattern matching done by list comprehensions is strict
14:49:53 <Black0range> btw makeRandList is IO [BOOL]
14:50:10 <Hijiri> yeah, that's another thing that's wrong
14:50:18 <Hijiri> the second argument to drop is [a]
14:50:20 <Hijiri> not IO [a]
14:50:28 <kadoban> Black0range: What resources are you using to learn haskell?
14:50:35 <Hijiri> if you want to use IO you have to be in an IO action
14:50:39 <kadoban> Black0range: Just trying stuff is...unlikely to work well.
14:50:39 * hackagebot linux-namespaces 0.1.2.0 - Create new or enter an existing linux namespaces  http://hackage.haskell.org/package/linux-namespaces-0.1.2.0 (MariosTitas)
14:50:41 * hackagebot app-settings 0.2.0.4 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.4 (EmmanuelTouzery)
14:50:45 <Black0range> http://learnyouahaskell.com/starting-out
14:50:56 <Black0range> well trial and error is a good way of learning :)
14:51:04 <Hijiri> not the most efficient way
14:51:15 <Black0range> depends. only have to learn it once
14:51:18 <Hijiri> it's a pretty bad way of learning a programming language, I would say
14:51:20 <kadoban> Black0range: It's a very inefficient, and labor intensive way. And not just your labor, ours too.
14:51:43 <Black0range> well of course you do not have to answer, hence "kind soul" :)
14:51:54 <kadoban> Black0range: Notice how you're asking about 50 questions per hour? If you read farther, it will walk you through a lot of this.
14:53:36 <pharpend> Black0range: when reading any textbook, I find it's best to read an entire chapter (which is likely to be self-contained) without trying to comprehend it too much. Then, once you've read over it preliminarily, go back and read it, trying to comprehend everything.
14:53:41 <Black0range> soo i should take that as a "no you wont help me?"
14:54:02 <pharpend> Black0range: We will happily help you, but you also need to do some of the work yourself
14:54:10 <sinelaw> hi.
14:54:15 <Fuuzetsu> hi
14:54:25 <pharpend> Black0range: kadoban feels like if you RTFM'd, then you would understand everything without having to bother him
14:54:35 <Hijiri> well if you just keep asking here for things you haven't learned yet, we're just taking the place of the tutorial
14:54:38 <sinelaw> how are type ranks counted? is forall a. a rank 0 or rank 1?
14:54:58 <kadoban> pharpend: That's a poor characterization of my feelings on the matter, but thanks for putting words in my mouth I guess.
14:55:06 <Rembane> We really need a RTFM-bot. That can generate nice, new answers to the most common questions.
14:55:19 <Fuuzetsu> Hijiri: what kind of food are we going to make a comparison to in #haskell tutorial?
14:55:24 <MindIsAVortex> hi there, I'm working on a project for uni where we have to make the asteroids game. I'm trying to use a "let in" statement to chain a random generator so I can get multiple random values. The first is to decide whether it will spawn an enemy at all, the second and third would be their respective positions. Anyway, I keep getting parse errors, usually on input '=', so I was wondering if someone could look at it and tell me if they see somet
14:55:42 <jeltsch> sinelaw: Given that (forall a . a) -> b is rank 2, I guess that forall a . a is rank 1
14:55:43 <Black0range> I've never forced anyone to answer, if you are irritated that i ask questions please just say "hey blackr0range i would appreciate if you could stop asking these questions here"
14:55:44 <Rembane> MindIsAVortex: Pastebin the code!
14:55:45 <pharpend> MindIsAVortex: sure, post the code
14:55:45 <Fuuzetsu> MindIsAVortex: post code an lpaste.net along with error message
14:55:49 <kadoban> I certainly don't mind anyone asking whatever questions. Just you're going to run out of people who are willing to answer if your only source of information is "Hi IRC, what's wrong with this?"
14:55:50 <Rembane> :D
14:56:00 <sinelaw> jeltsch, is rank 2 decidable?
14:56:04 <Hijiri> Tamarind is nice
14:56:04 <sinelaw> (for type inference)
14:56:18 <MindIsAVortex> ok ok, hold on
14:56:22 <Hijiri> You have to carry them around in pods, otherwise the stringy bits come out and it spoils
14:56:27 <jeltsch> sinelaw: You mean whether type correctness is decidable?
14:56:40 <jeltsch> I guess it is.
14:56:45 <batchm> Black0range it would help if you included definition of makeRandList, and also top-level type declarations
14:56:50 <Fuuzetsu> I think he means whether type-checking remains decidable
14:56:54 <jeltsch> However, type inference doesn’t work in general, as far as I remember.
14:57:03 <sinelaw> jeltsch, can you infer types? that's what I'm asking.
14:57:20 <MindIsAVortex> it jumbles it though, it looks different in sublime http://lpaste.net/736430915231678464
14:57:28 <Hijiri> top-level type declarations will make your errors clearer too, in some cases
14:57:36 <jeltsch> sinelaw: This is not decidability. “Decidable” means that you can decide something (yes/no).
14:57:39 <Fuuzetsu> MindIsAVortex: tell your editor to only use spaces, that's your problem
14:57:41 <Black0range> batchm: http://lpaste.net/113495
14:57:42 <Hijiri> that's another thing, you should post the error you're getting (on lpaste if it's too long for irc)
14:57:42 <vanila> MindIsAVortex, how about using a monad for threading the randomness
14:57:47 <meyersh> MindIsAVortex: Jumbles? Looks like your lpaste has many tabs.
14:57:49 <sinelaw> jeltsch, decide that there's a specific type :)
14:57:55 <Fuuzetsu> MindIsAVortex: it doesn't jumble it, it shows it how GHC would see it
14:58:03 <sinelaw> jeltsch, ok fine
14:58:19 <MindIsAVortex> ah
14:58:44 <Fuuzetsu> lpaste really needs to start screaming TABS TABS TABS AVOID AVOID BAIL OUT
14:59:01 <jeltsch> sinelaw: Well, the term “decidable” has a precise meaning in theoretical computer science. A predicate is decidable if there is an algorithm that computes the yes or no for a given input.
14:59:01 <MindIsAVortex> Ok, I'll turn off tabs then
14:59:08 <indiagreen> isn't GHC itself going to do it in some near future?
14:59:17 <Fuuzetsu> indiagreen: yes, in 7.10
14:59:24 <Fuuzetsu> but lpaste doesn't compile code
14:59:25 <vanila> I think sinelaw knows what decidable means
14:59:25 <sinelaw> jeltsch, ok, my bad. i'm learning this stuff from TAPL
14:59:39 <jeltsch> sinelaw: TAPL?
14:59:42 <Black0range> Fuuzetsu: regarding that do you have any reccomendation for a good editor, using sumblime 2 it adds tabs by itlsef
14:59:44 <indiagreen> Fuuzetsu: but people do try to compile their code before pasting it... presumably
14:59:46 <vanila> He's asking whether or not the type inference problem is decidable for lambda calculus with higher rank types
14:59:49 <sinelaw> Types and Programming Languages
14:59:52 <mauke> IIRC rank-2 inferene is decideable in theory
14:59:56 <Fuuzetsu> indiagreen: yeah, only realised what you meant after I replied
15:00:01 <mauke> I don't know any system that does it, though
15:00:02 <Welkin> Black0range: emacs with haskell-mode
15:00:07 <Fuuzetsu> Black0range: I use emacs for now
15:00:08 <josephle> jeltsch: in the context of type inference, the decidability question is can a given expression e be given a type?
15:00:13 <Hijiri> there must be some setting to make sublime use spaces
15:00:19 <Hijiri> though I'd recommend emacs or something anywa
15:00:22 <vanila> inference for System F is undecidable
15:00:23 <Fuuzetsu> Hijiri: I am sure there is
15:00:35 <batchm> Black: takeOne = do door <- makeRandList; randInt <- fmap (`mod` 3) randomIO; return (head (drop randInt door))
15:00:39 <sinelaw> vanila, System F is rank n, no?
15:00:50 <vanila> sinelaw, yes
15:01:04 <Mokosha> can anyone explain to me why this isn't working: https://gist.github.com/Mokosha/cef84ceb8ed23aa5ac6f
15:01:09 <sinelaw> I think I saw somewhere that rank3 and up make type inference generally undecidable
15:01:09 <vanila> I think it is also undecidable for ranks as low as 2 - let me check
15:01:16 <jeltsch> josephle: If you do not know the type yet, then computing it has nothing to do with decidability. If you already have some candidate type and want to check whether this is a type of a given expression, then it is about decidability.
15:01:17 <sinelaw> I'm not sure about 2
15:01:20 <albeit> Black0range: https://www.sublimetext.com/docs/2/indentation.html
15:01:21 <batchm> Black: note that there are random functions that don't use IO. but you have to thread the seed, or use State to do it for you.
15:01:30 <meyersh> albeit: beat me to it. :)
15:01:37 <albeit> Black0range: Or just Google.. that was the first result
15:01:48 <Fuuzetsu> Mokosha: it doesn't know your ‘:: a’ is the same as ‘a’ in the function signature; you could use ScopedTypeVariables
15:01:56 <Black0range> albeit: didn't ask for that but thanks! :)
15:01:58 <josephle> jeltcsh: the question is whether or not you can compute it. That is a decidability question
15:02:04 <Mokosha> Fuuzetsu, I tried that, still doesn't compile with the same error
15:02:22 <mauke> Mokosha: did you add forall?
15:02:26 <Fuuzetsu> Mokosha: because you didn't use them properly. You have to use forall with ScopedTypeVariables for it to work
15:02:27 <albeit> Black0range: Just making sure you knew Sublime could do spaces instead of tabs
15:02:40 <Mokosha> example?
15:02:51 <Fuuzetsu> forall a. Foo a => a -> String
15:02:57 <Fuuzetsu> then your (undefined :: a) should work
15:03:14 <Mokosha> huh, it did!
15:03:20 <Mokosha> any documentation on that?
15:03:25 <monochrom> Mokosha: for this case, my less-preferred recommendation is "f x = foo (undefined `asTypeOf` x)". my most-preferred recommendation is "f = foo".
15:03:26 <Fuuzetsu> GHC manual probably
15:03:40 <Fuuzetsu> https://www.haskell.org/haskellwiki/Scoped_type_variables even a wiki page
15:04:12 <Mokosha> monochrom, my use case is a bit more complicated: Foo a => t a -> String
15:04:23 <Fuuzetsu> cool thing you can use ScopedTypeVariables for: http://www.youtube.com/watch?v=52VsgyexS8Q
15:04:37 <monochrom> then ScopedTypeVariables will help
15:05:03 <Black0range> batchm: thank you very much
15:05:08 <monochrom> but it only helps when you have "forall" somewhere
15:05:23 <vanila> sinelaw, in an abstract John Wells (who proved the result about type inference system f) he mentions the result about n=3
15:05:26 <mauke> I think you can always get away without scoped type variables
15:05:27 <vanila> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.4246
15:05:41 * hackagebot hails 0.11.1.3 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.1.3 (DeianStefan)
15:05:43 <vanila> so I figure the proof of this claim might be cited in that lets see..
15:05:49 <sinelaw> vanila, yes, that's what I remember. n=3 and up
15:06:38 <vanila> Kfoury and Wells - A direct algorithm for type inference in the rank-2 fragment
15:07:08 <Mokosha> monochrom, Fuuzetsu, what're the negative "gotchas" of using ScopedTypeVariables and forall?
15:07:19 <monochrom> I don't think there is any
15:07:24 <Fuuzetsu> I think there are none
15:07:28 <sinelaw> vanila, you beat me to it. was just about to say that
15:07:35 <Mokosha> lol, ok thanks for the help, then!
15:07:45 <vanila> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.1202&rep=rep1&type=pdf
15:07:50 <vanila> this paper all the theory :)
15:08:17 <sinelaw> it's mentioned in TAPL (page 359)
15:08:38 <hughfdjackson> ski: thanks for your help on parsers before
15:08:58 <hughfdjackson> (a couple of weeks back)
15:09:10 <hughfdjackson> https://www.youtube.com/watch?v=-poU5NpWAD4&list=PLtVdvCgH-5rb7j4dkJDGt9TFcR-h0j8Om <- i turned the result into a little tutorial series
15:09:16 <hughfdjackson> :| where i used very inexact terminology
15:09:19 <hughfdjackson> ain't good at this yet
15:09:36 <Fuuzetsu> are burritos mentioned
15:09:57 <hughfdjackson> Fuuzetsu: no, but i give the world's worst explanation of functors
15:10:02 <hughfdjackson> without mentioning the word functors
15:10:03 <Fuuzetsu> oh boy
15:10:04 * Fuuzetsu clicks
15:10:06 <hughfdjackson> hahaha
15:10:15 <Fuuzetsu> well, I guess I'm technically not clicking
15:10:27 <hughfdjackson> it's designed for teaching my colleagues a bit about haskell + parsec without having to explain the whole language
15:10:32 <hughfdjackson> (that which i know of it)
15:10:38 <hughfdjackson> so .. lots of skimming over things
15:10:58 <hughfdjackson> no mention of currying, making of data types, typeclasses, functors, monads, etc
15:11:09 <Fuuzetsu> how did you explain functors without mentioning them
15:11:20 <hughfdjackson> :| jus' explain what fmap does
15:11:27 <Fuuzetsu> ew, you don't use repl from emacs
15:11:29 <sinelaw> vanila, this is the one TAPL gives (it's from 1999) as having an algorithm and also proofs: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.4246
15:11:33 <Fuuzetsu> do you HATE everything?
15:11:43 <hughfdjackson> Fuuzetsu: my in-emacs repl's kinda .. weird
15:12:01 <batchm> Black0range: I did that robotically, this is probably nicer.  takeOne = do door <- makeRandList; randInt <- randomIO; return (head (drop (mod randInt 3)  door))
15:12:08 <hughfdjackson> if you go to the start of the line, the cursor goes *behind* the prompt
15:12:09 <Fuuzetsu> I use GHCi, not any of that cabal project crap they have nowadays
15:12:13 <hughfdjackson> hehe
15:12:14 <hughfdjackson> well
15:12:21 <hughfdjackson> cabal repl's a nice wrapper if you're using a sandbox :)
15:12:31 <Fuuzetsu> I'm nix-shell master-race
15:13:11 <vanila> sinelaw, hows the type inference stuff you were working on going? :)
15:13:17 <vanila> what was it typed js?
15:14:19 <batchm> Black0range: basically, if someIO is of `IO Type', x in the following do block is Type (without the IO).   do x <- someIO;
15:15:09 <hughfdjackson> batchm: i think about it as '<-' unwraps x from IO :| don't know if that analogy helps
15:15:42 * hackagebot Unique 0.1.0.4 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.4 (kapral)
15:15:46 <Cale> I don't like to use the word "unwraps"
15:16:08 <Cale> Because nobody would say that running /bin/ls "unwraps" a list of files from it
15:16:11 <Fuuzetsu> it could always be worse, like ‘converts’
15:16:32 <hughfdjackson> Cale: great point :)
15:16:41 <structuralist> when is it OK to use unsafePerformIO?
15:16:58 <batchm> if you need to ask, probably never :P
15:17:04 <sinelaw> vanila, thank for asking... i'm trying to decide how to handle polymorphism of mutable variable
15:17:19 <sinelaw> the dreaded "value restriction" stuff doesn't apply exactly
15:17:22 <Cale> structuralist: If you'd otherwise be modifying GHC to get what you want.
15:17:28 <sinelaw> *thanks
15:17:58 <structuralist> Cale: sounds like a good heuristic
15:18:20 <vanila> yeah that stuff is kind of scary and very technical!
15:18:25 <vanila> easy to get wrong (as history shows)
15:18:31 <Cale> structuralist: But some rules of thumb: if you don't care how many times the IO action gets run, and it will produce the same result every time, then it's probably relatively safe.
15:19:01 <Cale> (and you don't mind if it's run from multiple threads concurrently)
15:19:49 <structuralist> my answer was "basically never worth it" but I didn't have an actual exception clause in mind
15:19:49 <sinelaw> vanila, yip. at some point my type checker allowed you to do "x = 3; y = x[0]" :)
15:20:40 <indiagreen> structuralist: a) when you don't use it to violate the contract that functions which look pure really *are* pure, and b) when you are sure (as somebody who has done lots of library/application design before) that your use of unsafePerformIO is really the best possible compromise between convenience of usage and convenience of being able to rely on pureness guarantees. (And then you should also openly state that you're violating the
15:20:41 <indiagreen> contract for these-and-these reasons.)
15:21:45 <Cale> ByteString makes use of unsafePerformIO internally for instance in order to add what is effectively a new primitive datatype.
15:21:56 <Cale> That's a reasonable nontrivial use case
15:22:13 <structuralist> yeah, I like "as a last resort before modifying the compiler"
15:24:41 <mrenaud> I have a quick question about typeclasses. Is there an easy way to create a new typeclasses that is just the composition of other typeclasses?
15:25:24 <Fuuzetsu> class (C1 a, C2 a) => C3 a where I guess
15:25:39 <eitan_chatav> depends what you mean by "composition"
15:25:48 <mrenaud> For example, instead of having to do   log :: (MonadReader Config m, MonadWriter LogType m) => String -> m ()
15:26:00 <benzrf> yes, what Fuuzetsu just said
15:26:08 <benzrf> mrenaud: or if you enable the right extn, you can do type aliases!
15:26:09 <Fuuzetsu> ConstraintSynonyms
15:26:18 <Fuuzetsu> or whatever that thing is called
15:26:21 <benzrf> @let type NumShow a = (Num a, Show a)
15:26:22 <lambdabot>  .L.hs:158:1:
15:26:22 <lambdabot>      Illegal constraint synonym of kind: ‘Constraint’
15:26:22 <lambdabot>        (Use ConstraintKinds to permit this)
15:26:22 <lambdabot>      In the type declaration for ‘NumShow’
15:26:26 <benzrf> aw
15:26:30 <benzrf> ConstraintKinds
15:26:34 <Fuuzetsu> yeah that
15:26:42 <mrenaud> Fuuzetsu: What would I put after the "where" though, since I don't want to add other functions?
15:26:52 <Fuuzetsu> nothing, it can be empty
15:27:01 <mrenaud> Interesting, I did not know that
15:27:25 <indiagreen> mrenaud: you don't even need “where”, actually
15:27:27 <Fuuzetsu> I would use ConstraintKinds instead
15:27:38 <batchm> didn't he just want this?
15:27:40 <batchm> class (Show a, Read a) => ShowRead a where
15:28:06 <Fuuzetsu> yes, it was already pointed out
15:30:12 <mrenaud> Is FlexibleContexts a "safe" extension to use?
15:30:21 <mrenaud> I have class (MonadReader Config a, MonadWriter [LogEntry] a) => MonadLogging a
15:30:21 <monochrom> pretty safe
15:30:49 <benzrf> :t fmap fmap fmap
15:30:50 <mrenaud> How would I write that without needing FlexibleContexts?
15:30:51 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:30:53 <benzrf> hmm
15:30:58 <benzrf> oh i see
15:32:27 <jeltsch> > fix error
15:32:29 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:33:20 <jeltsch> :t fix (fix .)
15:33:21 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a1
15:33:21 <lambdabot>     Expected type: (a1 -> a1) -> a1 -> a1
15:33:22 <lambdabot>       Actual type: (a1 -> a1) -> a1
15:33:23 <batchm> > error (error (error (error (error "lol"))))
15:33:26 <lambdabot>  *Exception: lol
15:33:34 <batchm> why is `fix error' different?
15:34:21 <batchm> I'd expect it to produce nothing
15:34:29 <jeltsch> batchm: Hmm, this is strange. I would expect this to have “*Exception: ” several times.
15:34:41 <batchm> jeltsch or that
15:34:51 <Fuuzetsu> :t error (error "a")
15:34:53 <lambdabot> a
15:34:56 <Fuuzetsu> > error (error "a")
15:34:58 <lambdabot>  *Exception: a
15:34:59 <jeltsch> I mean your error (error …).
15:35:12 <Fuuzetsu> > error (fix error)
15:35:14 <lambdabot>  *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exc...
15:35:18 <benzrf> woah did i just stumble upon a precursor to lens http://conal.net/blog/posts/semantic-editor-combinators
15:35:31 <geekosaur> indeed
15:35:37 <batchm> yes I got it. either. either `fix error' should timeout or manually nested error should produce *Exception: *Exception ...
15:35:44 * hackagebot Unique 0.1.0.5 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.5 (kapral)
15:36:03 <kadoban> Sounds like the thing mentioned in that popular lens talk, sure.
15:36:12 <ClaudiusMaximus> > error (flip const (fix error) "test")
15:36:14 <lambdabot>  *Exception: test
15:36:47 <benzrf> > error (error (error (error (error "lol")))) :: String
15:36:49 <lambdabot>  "*Exception: lol
15:36:52 <benzrf> huh..
15:37:01 <benzrf> how odd
15:37:23 <Fuuzetsu> > error (error (error "a") :: String)
15:37:25 <lambdabot>  *Exception: a
15:37:37 <ClaudiusMaximus> odder - same behaviour in ghci
15:38:31 <batchm> > let lol = error lol in lol
15:38:33 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:39:11 <jeltsch> > error undefined
15:39:13 <lambdabot>  *Exception: Prelude.undefined
15:40:38 <triliyn> > fix error
15:40:39 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:41:55 <jeltsch> > fix id
15:41:59 <lambdabot>  mueval-core: Time limit exceeded
15:42:13 <jeltsch> Was this considered a DoS attack?
15:42:23 <Fuuzetsu> no
15:42:29 <jeltsch> > fix coerce
15:42:31 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
15:42:31 <lambdabot>    arising from a use of ‘M36473267201943484032612.show_M36473267201943484032...
15:42:31 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
15:42:31 <lambdabot>  Note: there are several potential instances:
15:42:31 <lambdabot>    instance [safe] GHC.Show.Show a =>
15:42:43 <jeltsch> What?? :-O
15:42:49 <Kron> is there a synonym for "return ()"?
15:42:53 <Kron> return () ends up all over the place
15:42:55 <Fuuzetsu> doesn't know what to coerce
15:43:02 <Fuuzetsu> Kron: no
15:43:04 <ClaudiusMaximus> @src void
15:43:04 <lambdabot> Source not found. Do you think like you type?
15:43:05 <Kron> just a word meaning "meaningless monadic value"
15:43:07 <Fuuzetsu> you can use void in most situations
15:43:09 <ion> () <$ foo == do { _ <- foo; return () }
15:43:15 <Kron> what's void?
15:43:18 <ion> == void foo
15:43:19 <josephle> :t void
15:43:21 <lambdabot> Functor f => f a -> f ()
15:43:37 <Kron> ... huh, where's that from? it's not in my prelude
15:43:41 <ion> @hoogle void
15:43:43 <Fuuzetsu> Control.Monad
15:43:43 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:43:43 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
15:43:44 <lambdabot> package void
15:43:45 <jeltsch> :t coerce
15:43:46 <lambdabot> (Contravariant f, Functor f) => f a -> f b
15:43:56 <Kron> gotcha
15:43:56 <jeltsch> Hmm.
15:44:27 <jeltsch> But show_M36473267201943484032612 is indeed a neat identifier. :-)
15:45:14 <jeltsch> :t throw
15:45:15 <lambdabot> Exception e => e -> a
15:45:19 <batchm> @src void
15:45:20 <lambdabot> Source not found. My brain just exploded
15:45:24 <jeltsch> > fix throw
15:45:26 <lambdabot>  No instance for (GHC.Show.Show a0)
15:45:26 <lambdabot>    arising from a use of ‘M80314733814760827132668.show_M80314733814760827132...
15:45:26 <lambdabot>  The type variable ‘a0’ is ambiguous
15:45:26 <lambdabot>  Note: there are several potential instances:
15:45:26 <lambdabot>    instance [safe] GHC.Show.Show
15:45:32 <jeltsch> Cool. :-)
15:47:04 <jeltsch> > fix tail
15:47:09 <lambdabot>  mueval-core: Time limit exceeded
15:47:25 <benzrf> :t coerce
15:47:26 <lambdabot> (Contravariant f, Functor f) => f a -> f b
15:47:38 <jeltsch> :t fix coerce
15:47:39 <lambdabot> (Contravariant f, Functor f) => f a
15:47:57 <benzrf> oh
15:48:12 <jeltsch> :t fix error
15:48:14 <lambdabot> [Char]
15:48:41 <jeltsch> :t error (error "Hi!")
15:48:43 <lambdabot> a
15:49:06 <jeltsch> Hmm, fix error and error (error (error (…))) have different types.
15:49:09 <edwardk> benzrf: yes, SECs are a precursor to lens =)
15:49:14 <jeltsch> :t fix throw
15:49:15 <lambdabot> Exception a => a
15:49:27 <benzrf> edwardk: do you have lens set to ping you or something
15:49:51 <edwardk> benzrf: I realized it about 3 hours before I gave a big talk on lens in San Francisco at Google where I knew conal would be, so I changed the whole talk to attack them from that angle.
15:50:09 <edwardk> benzrf: about half the time. i try to turn it off now and again to get work done
15:50:44 <Fuuzetsu> I'm getting no work done even though I don't highlight lens, what's wrong?
15:50:46 <jeltsch> :t fix show
15:50:47 <lambdabot> String
15:50:51 <jeltsch> > fix show
15:50:53 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:51:06 <jeltsch> :t read
15:51:08 <lambdabot> Read a => String -> a
15:51:10 <kadoban> Fuuzetsu: Maybe you should highlight lens 1/2 the time then :)
15:51:13 <jeltsch> :t fix read
15:51:15 <lambdabot> String
15:51:19 <jeltsch> > fix read
15:51:23 <lambdabot>  mueval-core: Time limit exceeded
15:51:25 <Fuuzetsu> hehe
15:52:11 <jeltsch> > fix (join compare)
15:52:16 <lambdabot>  mueval-core: Time limit exceeded
15:52:20 <jeltsch> Sure.
15:52:34 <albeit> > fix (read . show)
15:52:36 <jeltsch> > fix (join (==))
15:52:38 <lambdabot>  mueval-core: Time limit exceeded
15:52:41 <lambdabot>  mueval-core: Time limit exceeded
15:52:48 <jeltsch> > fix (show . read)
15:52:52 <lambdabot>  mueval-core: Time limit exceeded
15:53:17 <jeltsch> > fix (head . return)
15:53:21 <lambdabot>  mueval-core: Time limit exceeded
15:53:27 <jeltsch> > fix (return . head)
15:53:31 <albeit> > fix undefined
15:53:31 <lambdabot>  mueval-core: Time limit exceeded
15:53:33 <lambdabot>  *Exception: Prelude.undefined
15:53:53 <jeltsch> > fix Just
15:53:54 <lambdabot>  Occurs check: cannot construct the infinite type:
15:53:55 <lambdabot>    a ~ Data.Maybe.Maybe a
15:53:55 <lambdabot>  Expected type: a -> a
15:53:55 <lambdabot>    Actual type: a -> Data.Maybe.Maybe a
15:53:56 <Fuuzetsu> please use /query, it's getting spammy
15:54:20 <indiagreen> but do tell us when something not time-limit-exceedy comes up
15:54:45 <jeltsch> indiagreen: I actually need to go to bed now. :-(
15:54:53 <Fuuzetsu> maybe if we let it run longer we'll find what's at the end of fix tail!
15:55:04 <jeltsch> Fuuzetsu: :-D
15:55:19 <jeltsch> Good night everybody.
15:57:26 <haasn> Fuuzetsu: I know what's at the end of fix tail:  fix tail
15:57:54 <Fuuzetsu> fix ‘what'sattheendofthat’
16:15:27 <eitan_chatav> anyone know a good library to get cpu & memory usage?
16:16:21 <boxrick1> How is everyone this evening?
16:16:56 <ReinH> eitan_chatav: I wonder why you might need that...
16:17:11 <ReinH> boxrick1: Well! And you?
16:17:20 <eitan_chatav> :-)
16:17:44 <boxrick1> Ah I am good. Anyone based around Manchester, UK here?
16:17:59 <Fuuzetsu> I am occasionally in the area, why
16:18:03 <eitan_chatav> ReinH: do you know any?
16:18:30 <ReinH> eitan_chatav: Um, for a running thing? ekg?
16:18:36 <ReinH> @hackage ekg
16:18:37 <lambdabot> http://hackage.haskell.org/package/ekg
16:19:20 <boxrick1> Just wondering, no particular reason. Just moved here fairly recently and was wondering if anyone else was based around here!
16:25:50 * hackagebot json-autotype 0.2.1.2 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.1.2 (MichalGajda)
16:25:52 * hackagebot json-autotype 0.2.1.3 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.1.3 (MichalGajda)
16:41:58 <rodlogic> alanz: there? Have a quick question about HaRe
16:42:23 <trap_exit> does anyone name exported and private functions of modules differently?
16:42:26 <trap_exit> i.e. _foo vs foo
16:43:33 <ReinH> trap_exit: Nope, and I use _foo for lenses/prisms.
16:43:51 <ReinH> Not sure if others do so
16:44:24 <ReinH> trap_exit: You might put private stuff in Foo.Internal and not include it in the exported modules.
16:44:26 <trap_exit> hmm
16:44:26 <trap_exit> how about __foo // private and foo // exported ?
16:44:36 <ReinH> I've never seen that.
16:44:44 <ReinH> Usually people write a Foo.Internal module
16:44:57 <trap_exit> yeah
16:45:01 <trap_exit> but I think that requires creating another directory
16:45:11 <ReinH> Well yes, but directories are pretty cheap on modern operating systems.
16:45:15 <ReinH> :p
16:46:04 <Welkin> can I use as-notation when pattern matching on the execution of a computation in do-notation?
16:46:33 <Welkin> for example: book@(Book title author) <- aBook
16:46:52 <liyang> Welkin: if it's in a pattern position (and it is), then yes.
17:01:31 <sccrstud92> > pl \x -> x
17:01:33 <lambdabot>  <hint>:1:4: parse error on input ‘\’
17:02:02 <sccrstud92> why is there a parse error?
17:02:40 <sccrstud92> >pl \x -> x
17:02:46 <monochrom> it's @pl
17:02:51 <sccrstud92> @pl \x -> x
17:02:51 <lambdabot> id
17:02:55 <sccrstud92> ty
17:03:21 <sccrstud92> @pl f n = elem . takeWhile (<= n)
17:03:21 <lambdabot> f = (elem .) . takeWhile . flip (<=)
17:04:13 <dibblego> this is a common pattern, also sometimes generalised to (fmap . fmap) in discussion
17:10:11 <fizbin> > ((*2) &&& (+5)) 22
17:10:13 <lambdabot>  can't find file: L.hs
17:10:19 <benzrf> > ((*2) &&& (+5)) 22
17:10:21 <lambdabot>  (44,27)
17:10:29 <benzrf> Turing-: ooh, do church next!
17:10:41 <fizbin> Wait, what?
17:10:57 <fizbin> > ((*2) &&& (+5)) 22
17:10:58 <lambdabot>  (44,27)
17:11:06 <kadoban> fizbin: I think it's just some transient error in lambdabot
17:11:11 <fizbin> Ok
17:11:26 <benzrf> yeah it does that smtimes
17:11:30 <benzrf> some kinda race condition i think
17:11:36 <Fuuzetsu> I don't know why no one fixed that yet
17:11:52 <Twey> Fuuzetsu: Because lambdabot is scary and nobody wants to go in there, is my understanding
17:12:06 <kadoban> Is it open source?
17:12:11 <Twey> Yes
17:12:31 <Twey> kadoban: https://github.com/mokus0/lambdabot
17:12:43 <kadoban> Neat, thanks
17:13:02 <Turing-> benzrf: lulz. Been keeping track? :P
17:14:39 <benzrf> no just saw your one nick change
17:14:41 <Fuuzetsu> Twey: it is also my understanding, just gotta wait for someone to get annoyed enough
17:14:47 <benzrf> kadoban: no, it's FREE SOFTWARE
17:14:48 <benzrf> =)
17:14:53 <benzrf> Twey: i totally went in there
17:14:57 <benzrf> i made @letlpaste a thing
17:14:58 <benzrf> YOU ARE WELCOME
17:15:03 <monochrom> if I were to improve lambdabot, I would certainly want to be paid.
17:15:05 <benzrf> it is not so scary
17:15:27 <kadoban> benzrf: :)
17:15:29 <indiagreen> do we crowdfund benzrf now to continue improving lambdabot
17:15:32 <Fuuzetsu> monochrom: sounds like something we could generalise
17:15:40 <Turing-> benzrf: Ah
17:15:48 <n4x> I think it is mostly that Fuuzetsu, it isn't annoying enough to spend time on it :P
17:15:49 <monochrom> what does @letlpaste do?
17:16:27 <indiagreen> it downloads and loads the given lpaste
17:16:38 <monochrom> yikes
17:17:00 <indiagreen> @letlpaste http://lpaste.net/113499
17:17:01 <lambdabot>  Invalid paste ID.
17:17:05 <kadoban> Darn, there's no github issue about that bug, I was hoping for some details about it at least. Guess not so much, heh.
17:17:05 <joelteon> it's about as scary as allowing people to use @let...
17:17:12 <indiagreen> @letlpaste 113499
17:17:12 <joelteon> just multiline
17:17:14 <lambdabot>  Defined.
17:17:20 <indiagreen> @type foo
17:17:21 <monochrom> . o O ( @letlpaste 77374 :) )
17:17:22 <lambdabot> Integral b => b -> b
17:17:29 <indiagreen> > foo 13
17:17:34 <lambdabot>  mueval: ExitFailure 1
17:17:39 <joelteon> @let import System.IO.Unsafe
17:17:41 <lambdabot>  .L.hs:124:1:
17:17:41 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
17:17:41 <lambdabot>      The module itself isn't safe.
17:17:46 <benzrf> when did lenses become a thing
17:17:47 <joelteon> monochrom: ^
17:18:07 <jle`> benzrf: since ancient greece and china
17:18:12 <benzrf> heh
17:18:23 <benzrf> to be precise when did the term 'lens' arise
17:18:29 <joelteon> it's why they're called van Sophocles lenses
17:18:36 <augur> benzrf: Turing- should also have Thesis-
17:18:45 <augur> then he can cycle appropriately
17:19:24 <monochrom> do you mean "Turing-complete" should be "Turing-Thesis-complete"?
17:19:36 <joelteon> it says cycle, so maybe
17:19:44 <joelteon> > cycle "Turing-Thesis-" >> "complete"
17:19:45 <lambdabot>  "completecompletecompletecompletecompletecompletecompletecompletecompletecom...
17:19:50 <joelteon> oh, whoops
17:19:53 <monochrom> :)
17:19:56 <joelteon> that's meant to be a ++
17:20:04 <joelteon> challenge complete!
17:20:23 <Fuuzetsu> at least the types lined up
17:20:28 <augur> monochrom: i mean Church- Turing- Thesis- :P
17:20:42 <joelteon> Church-Turing-Thesis-Church-Turing-Thesis...
17:20:57 <augur> this channel is turning into #esoteric
17:21:14 <joelteon> Turing into #esoteric
17:21:25 <Fuuzetsu> someone mute joelteon I swear
17:22:16 <Fuuzetsu> if we ever develop true AI, we should employ it to detect bad puns and dish out punishment
17:22:30 <augur> puns are the best
17:22:42 <monochrom> I love puns :)
17:23:02 <monochrom> @quote monochrom syntax.rules
17:23:03 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
17:23:36 <augur> monochrom: i dont get it :(
17:23:40 <Fuuzetsu> at least it wasn't a CT joke
17:24:13 <acowley> This strikes me as a strange type checker error message: https://gist.github.com/acowley/a001bd092599b5914bad
17:24:18 <acowley> Can anyone explain how it gets itself into that state?
17:24:19 <monochrom> in scheme, macros (or some macros) are called "syntax rules" and are written using the word syntax-rule
17:24:27 <Fuuzetsu> acowley: even GitHub thinks it's bad
17:24:45 <joelteon> acowley: do you need a '
17:25:01 <joelteon> oh, guess not
17:25:03 <benzrf> i <3 puns
17:25:07 <acowley> joelteon: Where?
17:25:12 <joelteon> in the type sig for baz
17:25:14 <acowley> Fuuzetsu: It knew
17:26:31 <Turing-> augur: :P
17:26:33 <acowley> joelteon: More specifically? The only place I can think to put it would be on the [a,b], but that doesn't change things
17:26:40 <augur> monochrom: i dont get the progression then, but ok. :D
17:26:40 <Fuuzetsu> phew, “took the morphism to the knee” is not bringing up results on Google; there are Arrow jokes though
17:27:18 <acowley> Even if what I'm doing there can't work, I don't hink the error message of "Could not deduce X from X" is good
17:27:22 <benzrf> :k Num Int
17:27:22 <augur> Fuuzetsu: I once took a morphism to the knee. It really hit a nerve.
17:27:23 <lambdabot> Constraint
17:27:24 <augur> 8D
17:27:25 <benzrf> :k (Num Int, ())
17:27:26 <lambdabot>     The second argument of a tuple should have kind ‘Constraint’,
17:27:26 <lambdabot>       but ‘()’ has kind ‘*’
17:27:26 <lambdabot>     In a type in a GHCi command: (Num Int, ())
17:27:36 <Fuuzetsu> doesn't count
17:27:40 <augur> Fuuzetsu: :(
17:27:52 <Fuuzetsu> I forgot to put ‘original content do not steal’ but it was implied
17:28:09 <augur> :k Constraint
17:28:11 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
17:28:11 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
17:28:32 <benzrf> Constraint is already a kind
17:28:34 <acowley> benzrf: Interestingly, if you add a singleton-list case to HListAll, things break down
17:28:39 <benzrf> too bad there is no :s
17:28:50 <benzrf> wait, *is* there a :sort?
17:29:00 <monochrom> no, not yet
17:29:01 <augur> :s *
17:29:18 <Fuuzetsu> what would it do
17:29:40 <augur> tell you the sort of things!
17:29:46 <monochrom> what sort of answer do you want out of ":sort Constraint"? :)
17:30:07 <Fuuzetsu> answer to P = NP that's not P = 0 or N = 1
17:30:32 <joelteon> dude
17:31:13 <benzrf> monochrom: BOX, hopefull
17:31:13 <benzrf> y
17:31:18 <monochrom> fix n = let p = n p in p
17:31:23 <benzrf> >tfw no sort-level programmin
17:31:24 <benzrf> g
17:31:30 <benzrf> monochrom: niiice
17:31:35 <acowley> Anyone have any thoughts on my complaint? Is it bug?
17:31:51 <Fuuzetsu> at the very least it's a bug about a shitty message
17:32:04 <benzrf> :k Num Int => String
17:32:06 <lambdabot> *
17:32:09 <benzrf> :k Num String => String
17:32:10 <acowley> Yeah
17:32:10 <lambdabot> *
17:32:13 <benzrf> hm
17:32:24 <benzrf> :t 'k' :: Num String => Char
17:32:24 <monochrom> benzrf: besides BOX, what other sorts are there? I just need a few examples.
17:32:25 <lambdabot>     No instance for (Num String)
17:32:25 <lambdabot>       arising from an expression type signature
17:32:25 <lambdabot>     In the expression: 'k' :: Num String => Char
17:32:27 <benzrf> monochrom: none
17:32:39 <benzrf> :t 'k' :: Num Int => Char
17:32:41 <lambdabot> Char
17:35:03 <sccrstud92> @pl f n = elem n . takeWhile (<= n)
17:35:04 <lambdabot> f = liftM2 (.) elem (takeWhile . flip (<=))
17:37:48 <acowley> Well, this bug is super annoying
17:39:36 <acowley> I think it's going to boil down to partially applied type families accidentally getting too far
17:39:38 <acowley> Which is a nuisance
17:41:41 <acowley> One day we'll have type functions. One day....
17:42:13 <benzrf> Scorchin: i seriously hope you guys don't do this
17:42:16 <benzrf> er, sccrstud92__
17:49:07 <joe9> johnw: are you the author of this article: https://www.fpcomplete.com/user/jwiegley/understanding-continuations ?
17:50:40 <Twey> acowley: http://lpaste.net/113501
17:51:23 <Fuuzetsu> joe9: he is
17:51:30 <joe9>  This article https://www.fpcomplete.com/user/jwiegley/understanding-continuations mentions an implementation of green threads using callCC. I am just trying to understand continuations. Can anyone write up a few lines of sample code on what he is talking about when he is describing the implementation of green threads (It is the last paragraph of the article)?
17:51:38 <joe9> Fuuzetsu: ok, thanks.
17:51:51 <Kron> is there a pre existing function that takes a list and generates a list of pairs of adjacent elements?
17:51:56 <pharpend> joe9: in the future try /whois
17:51:57 <Kron> zip `ap` tail, basically
17:52:14 <joe9> pharpend: ok, thanks.
17:52:16 <Twey> Kron: What's wrong with the function ‘ap zip tail’?  :þ
17:52:26 <Kron> it's just kind of unreadable is all
17:52:37 <Fuuzetsu> :t zip `ap` tail
17:52:38 <lambdabot> [b] -> [(b, b)]
17:52:48 <Fuuzetsu> add a comment and you're done
17:52:57 <Twey> zip <*> tail is pretty clear to anyone who knows how the applicatives work
17:53:23 <joe9> johnw: could you please write a simple example for the green thread implementation in the last paragraph?
17:54:05 <Fuuzetsu> joe9: I imagine that a proper example might not be ‘simple’
17:59:35 <ski> joe9 : i believe Koen Claessen has a paper on "A Poor Man's Concurrency Monad" or something like that ?
17:59:53 <joe9> ski, cool, thanks. will search for it.
18:01:54 <FireFly> @quote zip`ap
18:01:54 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
18:02:36 <MP2E> haha
18:02:38 <benzrf> :t zip`ap`tail
18:02:39 <lambdabot> [b] -> [(b, b)]
18:02:41 <benzrf> ah yes
18:03:16 <marchelzo_> Can someone recommend a GUI library that Just Works™ on both Windows and Linux? I can't even build most of the ones that I try
18:04:36 <benzrf> > zip`ap`tail $ [1, 2, 3, 4]
18:04:38 <lambdabot>  [(1,2),(2,3),(3,4)]
18:04:45 <benzrf> moer like consecutive elements
18:05:21 <Fuuzetsu> marchelzo_: the major problem is that close to no software Just Works™ on Windows
18:05:36 <benzrf> Fuuzetsu: :-)
18:05:42 <benzrf> marchelzo_: install gentoo!
18:06:08 <Twey> marchelzo_: threepenny-gui maybe
18:06:20 <Twey> Well, it's cheating a little bit.  ☺
18:06:23 <Fuuzetsu> gtk2hs is known to work on Windows as is wxWidgets but I tales say they are both hard to get going
18:06:36 <Fuuzetsu> browser interfaces need not apply
18:06:40 <FireFly> Twey: heh
18:07:31 <marchelzo_> Fuuzetsu, yeah I tried to build gtk2hs and wxWidgets and I couldn't get either going :|
18:07:53 <marchelzo_> Browser interface is fine; I will give threepenny a try :)
18:08:11 <Fuuzetsu> Install an OS that isn't hostile to anything outside of checking Facebook or playing games
18:08:15 <Fuuzetsu> although both are arguable
18:08:54 <marchelzo_> I only use Windows because of games. I would love to use only Arch on my desktop someday
18:09:18 <Fuuzetsu> then why develop on Windows if you only use it for games
18:09:26 <joe9> ski, that was a very good suggestion. It seems to be an understandable paper. Thanks so much.
18:09:44 <ReinH> Can we please knock the windows bashing off? Ugh
18:09:49 <marchelzo_> Because I don't like to restart to take a break and play a game, my HDD is slow and boot times are long
18:09:52 <Fuuzetsu> ReinH: what bashing?
18:10:00 <ReinH> Fuuzetsu: yours, specifically.
18:10:11 <Fuuzetsu> which part exactly is bashing
18:10:16 <benzrf> Fuuzetsu: the part where u said it sux
18:10:30 <ReinH> Most of the things you just said? "6:07 PM <Fuuzetsu> Install an OS that isn't hostile to anything outside of checking Facebook or playing games"
18:10:37 <Fuuzetsu> which part of that is wrong?
18:10:49 <ReinH> I didn't say any of it was wrong, that's not the point
18:10:49 <acowley> Twey: Is that the same issue?
18:10:52 <FireFly> come on, be reasonable
18:11:05 <ReinH> The point is that some people are going to use Windows, and we can either help them or be elitist jerks about it
18:11:11 <Fuuzetsu> ReinH: It is *the* sanest thing to do here
18:11:40 <Fuuzetsu> other ‘solutions’ are for libs to start shipping with C sources of everything they bind to and compile as part of the package and there are things on Hackage that already do this and it's terrible
18:11:45 <ReinH> You can suggest alternatives to windows without the pointless bashing
18:11:51 <ReinH> It's not a good look
18:11:59 <indiagreen> the part which implies that people who use Windows either a) only check Facebook or play games, or b) are dumb enough not to install a better OS for their purposes
18:12:05 <ReinH> marchelzo_: Anyway, have you considered a Virtualbox VM?
18:12:11 * Fuuzetsu shrugs
18:12:35 <ReinH> marchelzo_: I have a NixOS VM on my gaming PC that I use for Haskell stuff from time to time.
18:12:57 <marchelzo_> ReinH, Yes, I have an Ubuntu VM, but I just don't like using it for some reason
18:13:20 <Twey> acowley: Sounds like what you described, maybe
18:14:13 <acowley> Twey: Hm, yeah it might be
18:14:13 <zwer> marchelzo_ did you try following http://projects.haskell.org/gtk2hs/download/#Windows ?
18:14:23 <benzrf> Fuuzetsu: /g/-five ( ͡° ͜ʖ ͡°)
18:14:23 <ReinH> marchelzo_: Fuuzetsu isn't wrong, unfortunately. Windows is a bit of a second class citizen. :/
18:14:33 <benzrf> and boy, has it earned it!
18:14:49 <acowley> Twey: Can you explain how/why it's an error?
18:14:52 <Fuuzetsu> it being second-class is not something we can fix
18:14:58 <Fuuzetsu> second class*
18:15:11 <acowley> Twey: I'm having trouble imagining what the type checker is doing to let you mention the type famiy like that, but then inconsistently apply it
18:15:17 <marchelzo_> ReinH, I understand; I was just being hopeful :)
18:15:25 <ddellacosta> can any experienced Haskell developers tell me, how do you start thinking about a problem when you've got a series of actions that is very imperative--like, "first this has to get inserted into the DB, then that has to get checked, then we respond with this," and translate that to "ideal" Haskell code?  I'd love to read something about this (more general program design) too if there are any resources anyone can point
18:15:25 <ddellacosta> me to.
18:15:39 <Twey> acowley: The problem is that the type checker will evaluate type families as soon as it sees them
18:16:07 <ReinH> marchelzo_: A VM or dual-booting might give you the most success, tbh. I can tell you stories about getting our stuff to compile on windows (we ship to windows customers)...
18:16:11 <acowley> Twey: Yeah, but then it should stop you if it encounters a partial application
18:16:31 <Twey> acowley: Which means that effectively you can't actually write something with a type that is an application of a type family — the checker will immediately evaluate the application (and then not be able to unify the evaluated version with the unevaluated expression, for obvious reasons of lack of injectivity)
18:16:32 <Cale> ddellacosta: Well, IO actions are capable of being very imperative if that's how you're thinking about the problem
18:16:53 <acowley> marchelzo_: I don't really like working in VMs either as I'm always out of RAM, but I've found that working with something headless like Vagrant is much better than a full desktop setup (in case that's what you're doing)
18:17:13 <merijn> ddellacosta: Sounds to me like it'd just be a bunch of IO operations anyway, so just writing imperative style IO seems easiest
18:17:15 <ddellacosta> Cale: so, is the general idea to isolate those "imperatively ordered" actions in a do block or something (to extrapolate out from what you're saying)
18:17:22 <Twey> Whereas really it should (IMO) evaluate lazily, and only when unification fails
18:17:42 <ddellacosta> merijn: okay, I guess that makes sense--stuff where there is a lot of IO may necessitate that approach, huh
18:17:45 <Fuuzetsu> ReinH: I suspect those instructions are dated considering they point at the old darcs repo
18:17:52 <marchelzo_> acowley, thanks, I'll check out vagrant
18:17:55 <ReinH> Fuuzetsu: which instructions?
18:17:56 <acowley> Twey: But this seems more like a lack of functionality than injectivity. As we're just asking that a ~ b => T a ~ T b
18:18:09 <Cale> ddellacosta: It's sometimes possible to take a very different approach to problems though
18:18:12 <Fuuzetsu> ReinH: oh, apparently zwer was the one that posted them, my bad
18:18:26 <ReinH> acowley: But then you're stuck with putty or some other not-very-good-terminal :/
18:18:33 <ReinH> Fuuzetsu: no worries
18:18:38 <ddellacosta> Cale: yes so, I really want to start stretching myself to think that way, but don't know where to start
18:18:46 <Cale> ddellacosta: But yeah, if you really want to be imperative, you probably won't find it awkward to just write the imperative code
18:18:57 <Cale> Let me get you a really nice talk by SPJ about puddings :D
18:19:03 <ReinH> acowley, marchelzo_: I run a desktop VM in full screen mode and try to forget that Windows is even running...
18:19:06 <merijn> ddellacosta: Many newcomers to haskell think "IO is evil, I should avoid it!", much more so than warranted. The entire nicety of of purity is that IO is "just another first class value"
18:19:19 <ddellacosta> Cale: 8-|
18:19:21 <ReinH> It probably helps that I can give it 8GB of memory
18:19:33 <zwer> Fuuzetsu could be.. I just googled it quickly
18:19:39 <acowley> ReinH: I'd just emacs to tramp into the VM, or git-bash or something if I wanted to work in a terminal
18:19:40 <ddellacosta> merijn: yeah, I've heard that too, definitely--but it's not that I want to stay away from IO
18:19:42 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
18:19:53 <merijn> ddellacosta: A lot of concurrent/network-y haskell is just rather IO intensive, so no point in pretending otherwise
18:20:02 <Cale> Okay, it's also about the design of a library/language for composing contracts :)
18:20:16 <ddellacosta> merijn: it's more that I feel like I've not yet grasped how to structure stuff *other* than in an imperative way (but as Cale just said, maybe that's just what the problem necessitates at times)
18:20:20 <ddellacosta> Cale: thanks for that
18:20:23 <acowley> ReinH: I've certainly done the full-screen desktop thing quite a bit, but when I tried Vagrant more recently it really did help with some of my pain points. But I'm coming from OS X, so it's not exactly the same
18:20:26 <ski> joe9 : yw
18:20:26 <merijn> ddellacosta: In my personal experience writing a bunch of IO code in the exact same way as you would in an imperative language works rather well in my experience
18:20:44 <Cale> Well, don't take my comments as meaning that it's *necessary* that you solve your problems that way
18:21:04 <ddellacosta> Cale: oh no, just trying to get a sense of how folks think about it
18:21:09 <Twey> acowley: How so?  Since the evaluation happens early, my example reduces to trying to find an a such that Baz a = Bar ()
18:21:11 <merijn> ddellacosta: I think the approach to take is "write it very IO heavy" -> aggressively refactor & purify -> repeat
18:21:16 <Twey> acowley: In this case it's trivial, but in general obviously not
18:21:33 <ddellacosta> merijn: yeah, I mean, I've heard it expressed also as "islands of imperative/side-effecting code in a sea of purity"  to misquote
18:21:35 <Cale> But just that if you already know how to solve your problems that way, and don't want to worry about whether there's a more structured way, Haskell is perfectly capable of being an excellent imperative language
18:21:37 <acowley> Twey: Ah you're right
18:21:49 <ddellacosta> Cale: right, yeah, that seems obvious even as a newbie
18:21:49 <ReinH> (It's my favorite imperative language)
18:21:53 <merijn> ReinH: Word
18:22:03 <ddellacosta> it is great as an imperatively language
18:22:10 <ddellacosta> I just want to break out of that as much as I can
18:22:17 <ReinH> ddellacosta: seems good
18:22:27 <ddellacosta> since that comes naturally to me, from all my past experience, and I know there are other ways to think about things
18:22:40 <acowley> Twey: So I come back to just wanting the type checker to stop me as soon as it sees a partially applied type family
18:22:50 <Cale> As a first approximation, you can do things like abstract over the sorts of actions that you're performing, making a data type for representing the kinds of things that your program does along with an interpreter for that datatype that constructs the IO actions
18:23:26 <merijn> ddellacosta: A good place for inspiration are the functional pearls
18:23:30 <ReinH> (or that runs the actions in a test harness with test data)
18:23:32 <merijn> ddellacosta: Also, Okasaki
18:23:36 <Cale> Even this first level has some benefits: it becomes easier to inspect what your programs will do before actually carrying it out, and it gets easier to apply tools like QuickCheck for testing
18:23:51 <ReinH> ddellacosta: Richard Bird's Pearls of Functional Algorithm Design should be at the top of your list as well
18:23:51 <prinsen> Is there any extension that allows you to write stuff like http://lpaste.net/113503
18:24:15 <ddellacosta> Cale, merijn, ReinH, this is all gold, thanks so much--just what I was looking for
18:24:16 <prinsen> Ie guards i case patterns
18:24:18 <ReinH> ddellacosta: This is a version of the chapter on Sudoku and it's amazing http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
18:24:23 <Cale> :t typeOf
18:24:25 <lambdabot> Typeable a => a -> TypeRep
18:24:25 <ddellacosta> nice
18:24:38 <Twey> :t typeRep
18:24:39 <lambdabot> Typeable a => proxy a -> TypeRep
18:24:47 <Twey> (learnt about that slightly too late)
18:24:50 <merijn> I'd just use cast
18:24:53 <ReinH> ddellacosta: Also specifically byorgey's monoid pearl
18:24:54 <Cale> prinsen: You can already use guards in case, just use | like normal
18:24:59 <Cale> not comma
18:25:16 <prinsen> Cale: Will a guard fail cause the pattern to fail?
18:25:28 <Cale> yes
18:25:29 <Twey> acowley: ‘Stop you’?
18:25:30 <merijn> > let ghettoEq x y = cast x == Just y in ghettoEq 1 'c'
18:25:32 * ddellacosta googles byorgey's monoid pearl on ReinH's recommendation
18:25:33 <lambdabot>  False
18:25:34 <prinsen> Cale: I would like it to go to the next case clause when the guard fail
18:25:36 <Cale> well, it'll go on to the next guard
18:25:37 <merijn> > let ghettoEq x y = cast x == Just y in ghettoEq 'c' 'c'
18:25:39 <lambdabot>  True
18:25:43 <Cale> and eventually the next pattern
18:25:46 <Twey> acowley: I don't think it's the partial application that's a problem here
18:25:51 <benzrf> > typeRep (Just 3)
18:25:52 <prinsen> Cale: Awesome
18:25:53 <lambdabot>  Integer
18:25:58 <acowley> Twey: Yes, raise an error as it does with type synonyms
18:26:00 <benzrf> > typeRep (Just "lol")
18:26:02 <lambdabot>  [Char]
18:26:02 <ddellacosta> ReinH: got it, this is awesome
18:26:06 <ddellacosta> ReinH: thanks so much!
18:26:23 <ReinH> Will give you an idea of how algebraic structures can be used to design things (there's a reason they're called *algebraic* data types, after all)
18:26:29 <Twey> acowley: That would significantly reduce the utility of type families
18:26:37 <ReinH> The math isn't super important, but it is pretty interesting
18:26:37 <acowley> Twey: The error message the type checker yields with my example seems like it's in a really bad spot
18:26:44 <merijn> prinsen, Cale: Pretty sure my version is simpler than this manual one with typeOf and ==
18:26:45 <Fuuzetsu> :~: is built-in right
18:26:49 <Twey> Fuuzetsu: No
18:26:54 <acowley> Twey: Don't get me wrong, I'd be happier if it worked!
18:26:55 <ReinH> ddellacosta: cheers, enjoy!
18:26:55 <Twey> Fuuzetsu: It's a normal GADT
18:27:15 <Twey> acowley: *nod* You can get into some very confus(ing|ed) places with type families as they stand
18:27:22 <ReinH> ddellacosta: I've got about 8GB more of papers and such where that came from so let me know if you run out of reading material ;)
18:27:26 <prinsen> merijn: Its actually not the default typeOf
18:27:30 <prinsen> merijn: writing a JS interpreter
18:27:43 <merijn> prinsen: God have mercy on your soul
18:27:52 <ddellacosta> ReinH: definitely will, you'll be hearing from me...haha
18:27:58 <prinsen> merijn: 3 k lines and counting
18:28:11 <acowley> Twey: To get to the point that it says it can't deduce X from X means that something, perhaps just the error message printer, is broken
18:28:15 <monochrom> 8GB of papers. that doesn't even fit in my RAM.
18:28:15 <merijn> Actually, if you want to know how to write superfast interpreters with little effort, I can help you. The only price is that it'll involve writing Java >.>
18:28:15 <Twey> Fuuzetsu: data (:~:) ∷ ★ → ★ → ★ where Refl ∷ a :~: a
18:28:17 <ddellacosta> ReinH: although, I think I still have your recommended reading material to get through. ;-)
18:28:33 <Twey> acowley: IMO it's the too-eager evaluation
18:28:40 <prinsen> merijn: need it to be in haskell
18:28:52 <ReinH> prinsen: what are you using for parsing?
18:28:59 <Fuuzetsu> yeah I saw, was wondering about ‘the compiler knows that @a ~ b@.’ comment
18:29:02 <prinsen> ReinH: Parsc :/
18:29:15 <ReinH> prinsen: If it's not too late, you might try trifecta.
18:29:19 <merijn> Speaking of parsing
18:29:24 <prinsen> works just slow
18:29:25 <ReinH> I'm in love with the error messages.
18:29:28 <Fuuzetsu> isn't trifecta not-fast
18:29:37 <kadoban> ReinH: Have a favorites list or anything by any chance?
18:29:37 <acowley> Twey: How does the eager evaluation lead to the could not deduce kind of error?
18:29:38 <prinsen> Might be because the grammar in the EMCA-262 spec isnt LL1
18:29:39 <Twey> Fuuzetsu: ~ is magic, :~: isn't
18:29:44 <acowley> hah
18:29:51 <merijn> prinsen, ReinH: Just use edwardk's parsing and slot in whichever you want of attoparsec/parsec/trifacta
18:30:01 <ReinH> kadoban: Well, I have this, but it's just books http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
18:30:23 <ReinH> merijn: Sure, but parsing doesn't bolt nicer error messages onto Parsec...
18:30:24 <prinsen> merijn: links?
18:30:31 <kadoban> Thanks :) Better than nothing
18:30:54 <ReinH> merijn: Trifectas are even in color! ;)
18:31:01 <merijn> Anyway, speaking of parsing, if attoparsec always does backtracking, how can it free input during parsing? Or does it hold on to the entire input until the parsing completes?
18:31:08 <ReinH> merijn: (I'm writing a Scheme with trifecta and bound as a toy project)
18:31:41 <merijn> prinsen: My bad, I meant parsers: http://hackage.haskell.org/package/parsers
18:31:49 <ReinH> And with trifecta my parse errors are human readable right out of the box, it's great
18:31:53 <ddellacosta> yeah, kadoban, that's exactly the link I was talking about earlier wrt ReinH's recommended reading list
18:32:24 <merijn> I mean, to backtrack from the start attoparsec would have to keep the start of input around indefinitely, no?
18:33:09 <ReinH> merijn: unsure, I don't really understand parsing that well yet tbqh
18:33:14 <ReinH> edwardk would know
18:33:36 <ReinH> merijn: my CS knowledge is quite inconsistent :/
18:33:59 <prinsen> This part from HJS is pretty cool: http://lpaste.net/113504
18:34:33 <vanila> ReinH, scheme interpreter or compiler? :)
18:34:42 <ReinH> interpreter for now
18:34:44 <ReinH> baby steps
18:34:57 <vanila> hav fun with it!
18:35:04 <merijn> oooh
18:35:07 <ReinH> R5RS scheme, nothing crazy
18:35:09 <merijn> While I'm asking hard questions...
18:35:13 <ReinH> vanila: thanks!
18:35:27 <ReinH> I just said scheme twice. ATM Machine.
18:35:27 <merijn> Anyone have experience doing staged compilation with Haskell?
18:35:38 <ReinH> merijn: staged compilation?
18:35:50 <Ralith> merijn: do you mean writing staged compilers in haskell, or doing staged compilation of haskell?
18:36:01 <merijn> Staged compilation of haskell
18:37:42 <merijn> Actually, I'm thinking of doing cross language staging, i.e., haskell library EDSL -> haskell binary -> C source output -> binary, but I'd prefer not to do the ""haskell binary -> C source -> binary" manually
18:38:31 <acowley> Haskell binary to C source?
18:38:48 <merijn> I guess it'd be easiest to have a cabal "post build" hook run the compiled haskell and compile the generated C
18:38:59 <merijn> acowley: A binary that outputs source
18:39:11 <acowley> Oh
18:39:15 <acowley> I do that!
18:39:18 <prinsen> merijn: Im currently exporing a huge Haskell TH librar to Python, TCL etc. via C
18:39:28 <ski> merijn : for grovelling ?
18:39:40 <merijn> ski: I don't know what that means?
18:39:52 <prinsen> merijn: generating C structs, C++ Wrapers and using the FFI and SWIG to generate everytinh
18:41:05 <ski> merijn : well, as in generate C code which queries various C constants at the particular platform, to be able to marshall and link with C code (possibly dynamically, say by restarting an image at a new platform). the term comes from the Lisp world, i think
18:41:19 <merijn> ski: No
18:41:33 <prinsen> You use hsc2hs for that
18:41:43 <merijn> ski: I literally want just an entire C program. More concretely, I want a DSL compiler but I'm too lazy to write a parser
18:41:53 <ski> ok
18:42:10 <merijn> ski: So I figured I'd just have a haskell library to work as EDSL that outputs my C code
18:42:34 <merijn> But then I first need to compile the "haskell DSL code" and then the C source it outputs
18:42:43 <acowley> merijn: Did you have any particular questions about doing that?
18:42:57 <acowley> merijn: The executive summary is that it works great
18:43:25 <merijn> acowley: My particular question would be: How to make building this staged thing with cabal as painless as possible
18:44:13 <merijn> acowley: Like, how do you deal with telling cabal it shouldn't actually install the executables defined in the cabal file and how to get it to 1) generate the C srouce and 2) call the compiler on it
18:44:46 <ReinH> merijn: I suppose you can use shake if you need to...
18:44:48 <acowley> Oh, I guess I'm not the person to ask. I want the Haskell executable because it can generate different source on different hosts, which is then compiled at runtime
18:45:26 <acowley> merijn: Is installing the Haskell executable so bad?
18:45:40 <merijn> acowley: Naah, that's more of a "would be cleaner if it didn't"
18:45:47 <acowley> merijn: You could have the Haskell package as a dependency of another package that builds the C code
18:45:55 <merijn> acowley: But having to manually run it + call the C compiler is kinda annoyance
18:46:05 * hackagebot test-sandbox 0.0.1.8 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.8 (junjihashimoto)
18:46:28 <acowley> merijn: Well, I mean have your compile export a dummy library so you can depend on it. Then with a cabal hook invoke your haskell executable when installing the second package
18:46:38 <Twey> acowley: Hm.  I *think* the HListAll (ConFun l) ts in bar is simply not evaluated before unification
18:47:12 <acowley> Twey: But the error message shows the result of it being evaluated in the goal of the deduction, doesn't it?
18:47:15 <Twey> acowley: Observe that baz :: HListAll (ConFun l) [a, b] => Proxy l -> HList [a, b] -> () compiles fine
18:47:24 <Twey> acowley: Yep
18:47:46 <acowley> Twey: So you think the evaluation is being forced by the error message printer?
18:48:05 <Twey> acowley: But if you unfold it even one step, to (ConFun l a, HListAll (ConFun l) '[b]), it fails as observed
18:48:16 <Twey> acowley: That's my hypothesis, yeah
18:48:29 <acowley> Twey: So TFs are both too eager and too lazy :(
18:48:40 <acowley> What's the opposite of a sweet spot in a design space?
18:48:45 <Twey> Hah
18:48:56 <geekosaur> pain point
18:49:10 <Twey> Indeed
18:49:12 <ReinH> acowley: PHP. Bazinga.
18:49:15 <acowley> Hah
18:49:26 <ReinH> Oh, you weren't asking for examples.
18:49:38 <acowley> Got it, type families are the PHP of the type function design space
18:50:19 <acowley> Twey: It's pretty interesting then that our two examples seem to bracket the way it works.
18:50:26 <carter> Twey: acowley  have you seen my hetlist prototype?
18:50:28 <Twey> Indeed
18:50:29 <acowley> Twey: Do you know if there are plans to improve things?
18:50:41 <acowley> carter: For overloaded list syntax?
18:50:47 <Twey> I wonder if it's because it's a context that yours isn't evaluated
18:50:51 <carter> acowley: well, thats what I hope to use it for
18:50:52 <carter> but yeah
18:51:02 <Twey> carter: I haven't
18:51:19 <Twey> acowley: I have no idea; you'd have to ask #ghc
18:52:25 <carter> Twey: acowley  type familes can't make progress on polymorphic things
18:52:28 <carter> fundeps can
18:52:31 <carter> afaik
18:52:41 <carter> https://github.com/cartazio/HetList/blob/master/HetList.hs Twey
18:52:46 <carter> is the current one i have
18:52:50 <carter> plus some example instances
18:54:03 <Twey> carter: That would explain the failure to evaluate in acowley's example.
18:54:47 <carter> thats why i'm just mucking with fundemps allone
18:54:50 <carter> despite it looking insane
18:55:23 <acowley> Too insane :(
18:55:38 <acowley> I need to lose more pride
18:56:01 <carter> acowley: most of the madness is commented out
18:56:07 <giogadi> howdy, has anyone here used the Generic interface to DeepSeq?
18:56:44 <giogadi> I'm having a problem where genericRnf is giving me a "could not deduce" compiler error
18:56:52 <giogadi> for a fairly simple ADT
18:58:10 <Twey> giogadi: Could not deduce what?
18:58:34 <Twey> giogadi: And did you remember to add ‘deriving Generic’ to your data type?
18:59:20 <giogadi> Twey: hahahaha oops the deriving Generic did it
18:59:30 <Twey> You're welcome
18:59:31 <giogadi> I accidentally cut off that part during refactoring :(
18:59:34 <giogadi> thanks!
19:00:25 <CrazyM4n> Is there a way to center-align console output though haskell?
19:01:23 <geekosaur> use terminfo to get the terminal width and compute it yourself?
19:01:48 <CrazyM4n> terminfo?
19:01:54 <geekosaur> if you don't want to deal with a terminfo library, read output from `tput cols`
19:02:05 <Twey> geekosaur: Is $COLUMNS non-standard?
19:02:08 <CrazyM4n> ah, tput cols works, thanks
19:02:21 <geekosaur> it's not always defined standardly, it is an override
19:02:27 <Twey> Aha
19:02:29 <geekosaur> some shells force it out there regardless
19:02:44 <geekosaur> (mainly bash because readline)
19:03:07 <CrazyM4n> ah, tput cols works, thanks
19:03:14 <CrazyM4n> oops, wrong term window
19:03:14 <CrazyM4n> sorry
19:05:26 <geekosaur> the reality is terminfo overridden by $COLUMNS overridden by termios (because windows can be resized "live" and the environment doesn't update)
19:05:52 <geekosaur> tput considers all of them for you
19:11:28 <ReinH> geekosaur: nice, wish I had figured that out last time I tried to mess with terminfo
19:11:31 <jack_rabbit> Hi, everyone. I'm checking out Data.BEncode in the package bencoding, but I'm having some trouble using it. My Haskell is a little rusty.
19:11:36 <lpaste> jack_rabbit pasted “BEncode” at http://lpaste.net/113506
19:12:04 <jack_rabbit> I understand the error to mean that it can't determine the result type, but I'm not sure where to go from here.
19:12:12 <CrazyM4n> So, I'm working on a little cellular automata. What's the difference between monads and comonads?
19:12:55 <mmaruseacph2> the easiest answer is just the direction of the arrow is reversed
19:13:23 <ReinH> Oh good, bencoding doesn't depend on bits-extras
19:13:24 <mmaruseacph2> see also http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:13:35 <CrazyM4n> That was exactly what I was reading
19:13:36 <CrazyM4n> heh
19:14:03 <monochrom> jack_rabbit: it's probably because the type of v is unknown
19:14:06 <ReinH> mmaruseacph2: The usual answer is that they are duals of each other. This is only helpful if you know what "dual" means.
19:14:16 <monochrom> err, no, the type of s.
19:14:32 <ReinH> CrazyM4n: So, they are duals of each other. ;)
19:14:47 <jack_rabbit> monochrom, I think s is string, according to the docs. type Result = Either String
19:14:55 <CrazyM4n> ReinH: What does that mean?
19:15:23 <ReinH> CrazyM4n: This basically means that you flip the arrows around and see what you end up with. So Monad has return :: a -> m a. Flip the arrow and you get Comonad's extract :: w a -> a
19:15:30 <jack_rabbit> monochrom, So I have to determine the type early? Any idea what type it might be? I tried Result (Map String String) but it was confused by that.
19:15:36 <mmaruseacph2> ReinH: yep :P
19:15:55 <monochrom> ok, so why is the Right case an error?
19:16:01 <ReinH> Monad has join :: m (m a) -> m a; Comonad has duplicate :: w a -> w (w a)
19:16:02 <ReinH> and so on
19:16:25 <ReinH> CrazyM4n: So that's what it *means*, but it doesn't give you a good intuition for what you can *do* with them.
19:16:36 <ReinH> CrazyM4n: You might try this series: https://www.fpcomplete.com/user/edwardk/cellular-automata
19:17:06 <CrazyM4n> Ah. I'm doing http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:17:22 <ReinH> CrazyM4n: sigfpe's stuff is great, but Ed's series is a bit more hands-on
19:17:47 <CrazyM4n> I'll look at that
19:17:52 <jack_rabbit> monochrom, Right, I think the Right case needs to be explicitly typed.
19:18:27 <jack_rabbit> monochrom, but I could be wrong. Either way, I'm not sure what the type would be. I know the file is a dictionary string -> string
19:18:39 <CrazyM4n> Do I have to go through all the comonad things in order to get a little cellular automata running?
19:18:39 <ReinH> (I suppose w was chosen because it's a flipped m. Math humor.)
19:18:56 <ReinH> CrazyM4n: Comonads aren't the *only* way to implement a cellular automata
19:19:01 <CrazyM4n> Or can I just define "right" and "left" and go from there (which was what I was planning on doing)
19:19:13 <CrazyM4n> I mean, is it really that beneficial
19:19:42 <monochrom> a dictionary seems to be BDict
19:20:54 <ReinH> CrazyM4n: I would say that whatever you end up writing will *be* a comonad because cellular automata are comonadic in nature, but you don't need to know what a comonad is to write a cellular automaton.
19:21:02 <ReinH> CrazyM4n: Sort of like the "you could have invented monads" thing
19:22:27 <ReinH> CrazyM4n: I can write stateful things without using State, but after you write a few you start to reach for the abstraction. ;)
19:22:35 <jack_rabbit> monochrom, hmm. Not in scope: type constructor or class ‘BDict’
19:22:52 <CrazyM4n> I wrote a whole befunge interpreter without using State. I had like 10 persistent arguments
19:22:55 <CrazyM4n> Never again
19:23:08 <benzrf> heh
19:23:20 <ReinH> CrazyM4n: So: what you're writing will be comonadic in nature whether you call it one or not. ;)
19:23:33 <monochrom> it seems to be in Data.BEncode.Types
19:23:47 <benzrf> ah i confuse befunge with malbolge
19:23:57 <CrazyM4n> https://github.com/CrazyM4n/simplefunge
19:23:58 <ReinH> Actually writing it *without* using comonads and then comparing the thing you wrote *to* comonads might be a good way to gain an intuition for them
19:24:50 <ReinH> monochrom: I have had bad experiences with that author's code, so...
19:25:10 <ReinH> Unfortunately the other bencode library is 5 years old.
19:25:29 <CrazyM4n> That's what I'm going to do. I'll come back and see if there are any comonadic idioms that I can use to simplify it
19:25:35 <ReinH> CrazyM4n: sounds good
19:26:42 <CrazyM4n> Also, is there any real problem with using GHC 7.6.3 from the repos
19:26:49 <CrazyM4n> Or should I really try to update it
19:26:58 <ReinH> CrazyM4n: apt-get?
19:27:00 <CrazyM4n> Yes
19:27:05 <ReinH> http://deb.haskell.org/
19:27:26 <ReinH> Specifically http://deb.haskell.org/stable/. Strongly recommend 7.8.3.
19:27:32 <CrazyM4n> Okay
19:27:43 <ReinH> And a recent cabal-install
19:27:48 <ReinH> Sandboxes will become your friend
19:27:51 <CrazyM4n> ?
19:28:00 <CrazyM4n> (sorry, I'm not very well versed in linux)
19:28:28 <kgmstwo>  	  /msg alis list *xen*
19:28:48 <ReinH> CrazyM4n: Take a look at this: https://github.com/darinmorrison/docker-haskell/blob/docker-library/7.8/Dockerfile
19:29:35 <ReinH> That's basically what you'd want to do
19:30:14 <ReinH> CrazyM4n: or instructions here https://github.com/bitemyapp/learnhaskell
19:30:34 <CrazyM4n> Ah, I'll use those
19:30:48 <CrazyM4n> I think I already have the ghc repo, but it just refuses to install 7.8.3
19:31:54 <ReinH> CrazyM4n: (apt-get and dpkg incantations are inscrutable to lots of people, don't worry. ;)
19:32:22 <felixn> hey, when debugging with GHCi, I have access to the immediate values in the guard it stopped at, but non of the args, or where clause -- can I access those somehow?
19:32:25 <CrazyM4n> Hah. It doesn't help that I just switched to linux like 3 weeks ago while trying to get haskell to work :c
19:36:51 <CrazyM4n> There we go, 7.8.3. It wasn't that hard
19:37:31 <ReinH> CrazyM4n: woo
19:37:43 <jack_rabbit> sweet, it works. Thanks, monochrom.
19:48:01 <CrazyM4n> I don't really know how I woule implement http://mathworld.wolfram.com/images/eps-gif/ElementaryCA30Rules_750.gif concisely in a function
19:48:12 <CrazyM4n> I could nest if's, but that doesn't feel haskelly at all
19:48:18 <CrazyM4n> I'd program in C if I wanted to do that
19:49:00 <ddellacosta> CrazyM4n: isn't that just a data structure with a bunch of specific states?  Seems like it's barely a function even
19:49:16 <jack_rabbit> In this constructor, what's the function of the '!' ?
19:49:17 <jack_rabbit> Cons !BKey a !(BDictMap a)
19:49:19 <Ralith> looks like textbook pattern-matching to me
19:49:22 <CrazyM4n> Yes... I've been doing too much J lately though, I don't remember how I could represend that
19:49:25 <CrazyM4n> *represent
19:49:30 <CrazyM4n> Well, yeah, actuall
19:49:40 <CrazyM4n> Actually, I should just pattern match it
19:49:43 <merijn> jack_rabbit: Strict field
19:49:46 <CrazyM4n> You're right
19:50:32 <monochrom> jack_rabbit: it decreases laziness, in the hope that laziness will not be needed, and save some overhead
19:51:33 <jack_rabbit> monochrom, yep. I was just reading about that.
19:51:42 <jack_rabbit> Thanks, merijn, monochrom.
19:53:13 <noa-> hello
19:53:41 <noa-> can i use seq or deepseq to force strict file reading and parsing at the beginning of a program?
19:53:57 <vanila> noa-, I think it will be read anyway when you use IO monad
19:54:01 <vanila> so no need for that stuff
19:54:09 <noa-> it is not
19:54:20 <monochrom> you can use deepseq for it
19:54:22 <noa-> I used readFile
19:55:26 <Guest64072> is there a way to set -fno-warn-name-shadowing semi-globally, perhaps in a dot-file in $HOME?
19:56:11 <noa-> I am reading file and populating map with words. this is done instantly, and only when I access the map with string from the user do I get several seconds of delay
19:56:29 <monochrom> seq the map somewhere
19:56:41 <merijn> Guest64072: Not really
19:56:59 <merijn> Guest64072: I'd put it in the cabal files of the code you're editing
19:57:05 <monochrom> if you just deepseq the string, you will still have to wait for the map building
19:57:15 <monochrom> err, that is unclear
19:57:16 <noa-> seq or deepseq? and I am not sure what to put as second argument?
19:57:17 <monochrom> if you just deepseq the string, you will still have to wait for the map building later
19:57:33 <noa-> yes
19:57:59 <merijn> monochrom: Wouldn't strict Map be sufficient to avoid this issue?
19:58:10 <Guest64072> merijn: ok. i'm using vim and a few extensions, one of which is ghc-mod and syntastic. it keeps warning me about shadowing (i'm not sure if this is an HLint config, or if it's calling ghc -Wall or what)
19:58:15 <monochrom> seq is enough for the map. this is because the internal of the map has further non-laziness to complete the rest.
19:58:32 <noa-> seq mymap <what here?>
19:58:35 <monochrom> do you know, for sure, what "strict Map" means, merijn?
19:58:50 <merijn> monochrom: Spine strict inserts, no?
19:58:56 <monochrom> no.
19:59:00 <Guest64072> merijn: i think adding it to ghc-options in cabal files worked in the past. but often i'm just editing scrap code :\
19:59:15 <merijn> Guest64072: syntastic allows you to add compiler specific settings
19:59:59 <merijn> Guest64072: For hdevtools it's "g:syntastic_haskell_hdevtools_args", I assume there's similar for ghc-mod
20:00:08 <Guest64072> merijn: ah, thanks
20:00:52 <monochrom> noa-: I think, if you're in IO, "evaluate mymap" is the clearest and most robust. "evaluate" comes from "Control.Exception"
20:02:12 <xtx> hi
20:02:23 <noa-> cool evaluate worked!
20:02:50 <xtx> I'm new to this channel, hello everyone
20:02:56 <noa-> @src evaluate
20:02:57 <lambdabot> Source not found. My mind is going. I can feel it.
20:03:02 <CrazyM4n> hello
20:03:39 <xtx> is this only for haskell or can we talk about other languages? Like c++ and python ;p?
20:04:33 <CrazyM4n> this is the haskell irc, there are (most likely) c++ and python ircs also
20:04:41 <monochrom> the safest thing to do is to not talk about them, or only talk about them briefly and passingly
20:04:49 <noa-> I am just curious what would seq equivalent look like? I am trying to figure out how seq works too
20:05:04 <xtx> ah I see, thanks
20:05:28 <monochrom> if you're in IO, sometimes people use "mymap `seq` return ()"
20:05:50 <noa-> yes I am in IO
20:06:16 <xtx> ok, can haskell read pixels from images ? If so, I'm in.
20:06:19 <monochrom> but I don't like that. it's less direct than evaluate, in terms of expressing your intention
20:06:37 <noa-> yeah evaluate reads nicer
20:06:48 <noa-> but semantically they are the same?
20:06:59 <monochrom> outside IO, of course seq is clear and direct
20:07:24 <monochrom> no, I think not exactly the same, but close enough to not worry about in most cases
20:07:57 <xtx> nvm I found my answer, I'm in
20:08:05 <noa-> would evaluate do if I needed deepseq?
20:08:22 <monochrom> then it's "evaluate (deepseq mystring)"
20:08:50 <monochrom> err, wait, I guess deepseq has the wrong type
20:09:15 <monochrom> "evaluate (force mystring)"
20:12:43 <noa-> thanks. i did not know it was this easy to force IO to be strict
20:13:59 <noa-> in what way would I need to parse text files to need deepseq?
20:15:23 <monochrom> if you just use seq or evaluate or deepseq on the result of the parsing, that will trigger the reading just fine.
20:16:24 <monochrom> unless you say, you issue the readFile call now, you will parse one hour later, and yet you want the reading to happen now, that's when you deepseq the string itself
20:17:47 <noa-> what if the parsing result was a list? would I need deepseq to force parsing too, not just reading
20:18:14 <monochrom> then deepseq the resulting list
20:20:28 <CrazyM4n> So I'm trying to make a list of [f x, f $ f x, f $ f $ f x... for n times, g x, g $ g x... likewise for n times]
20:20:39 <CrazyM4n> Oh... iterate literally does exactly that
20:20:44 <CrazyM4n> Uh, oops
20:21:04 <monochrom> iterate goes to infinity. you need to add "take n"
20:21:10 <CrazyM4n> Yeah, I remember this
20:25:07 <noa-> is 'seq x x' useless?
20:25:15 <monochrom> yes
20:25:21 <noa-> ok :)
20:25:35 <monochrom> deepseq x x is not useless :)
20:25:37 <xtx> almost have haskell ;p just a little more effort
20:25:52 <CrazyM4n> xtx: Are you learning it? Or installing it? :P
20:25:54 <noa-> it says.. evaluate x when you evaluate x? :)
20:26:08 <monochrom> yes, "seq x x" says that
20:26:16 <noa-> yeah I saw that force uses deepseq like that
20:26:16 * hackagebot bindings-codec2 0.1.1.0 - Very low-level FFI bindings for Codec2  http://hackage.haskell.org/package/bindings-codec2-0.1.1.0 (RickyElrod)
20:27:52 <monochrom> using list for example. both seq and evaluate say: work until the first cons cell. deepseq says: work out the whole list
20:28:11 <monochrom> well, at least, work out all cons cells of the list. not sure about the actual data.
20:29:19 <noa-> > seq (undefined : undefined) 1
20:29:21 <lambdabot>  1
20:29:24 <noa-> this is interesting
20:29:33 <merijn> Why?
20:29:39 <noa-> > seq undefined 1
20:29:41 <lambdabot>  *Exception: Prelude.undefined
20:29:48 <monochrom> so "seq x x" is not useful. it says: when someone asks for your first cons cell (the second x), work out the first cons cell (the first x). that is tautological
20:29:53 <noa-> I thought it would evaluate head.. guess not
20:30:06 <merijn> noa-: seq evaluates to WHNF
20:30:34 <monochrom> but "deepseq x x" is useful. it says: when someone asks for your first cons cell, work out the whole list
20:30:49 <monochrom> what is WHNF?
20:32:03 <noa-> who are you asking?
20:32:09 <CrazyM4n> TIL sublime text has a fullscreen mode. Useful
20:32:10 <monochrom> merijn
20:32:10 <CrazyM4n> jg
20:32:18 <CrazyM4n> aaand I hit a macro key. my bad
20:33:55 <merijn> monochrom: weak head normal form? Why do you ask?
20:34:00 <zRecursive> :t liftIO
20:34:01 <lambdabot> MonadIO m => IO a -> m a
20:34:50 <monochrom> because the value of your answer depends on how many words in your answer the asker already knows.
20:35:31 <Ralith> an editor having a fullscreen mode is such a silly concept
20:35:38 <Ralith> any decent window manager should let you fullscreen arbitrary windows
20:35:51 <CrazyM4n> You guys were right about me discovering how cellular automatas were really just comonads
20:35:55 <CrazyM4n> I've been stuck on doing this
20:36:00 <CrazyM4n> Only to realize
20:36:05 <monochrom> suppose someone asks "how do I sum up a list?". then depending on their background, "use a catamorphism" may or may not be more valuable than "use sum or foldr"
20:36:05 <merijn> Ralith: fullscreen mode on OSX means that all GUI widgets are hidden
20:36:10 <CrazyM4n> I was stuck on trying to redefine cojoin
20:36:17 * hackagebot hold-em 0.1.0.0 - An engine for Texas hold'em Poker  http://hackage.haskell.org/package/hold-em-0.1.0.0 (jxv)
20:36:54 <CrazyM4n> Well, time to continue redefining cojoin
20:37:04 <noa-> one last question about this, is there a point in using System.IO.Strict when it is this easy to force evaluation yourself using base functions?
20:37:40 <noa-> do you get anything more with it?
20:37:42 <xtx> ./try
20:37:42 <xtx> Hello, World!
20:37:49 <xtx> I'm in :)
20:37:55 <Ralith> merijn: OSX has a shitty window manager, yes
20:38:47 <merijn> Ralith: That seems a rather flamebaity statement which is *entirely* unrelated to my comment
20:38:57 <monochrom> noa-, it forces evaluation of the data you read. if that's all you want, then it's useful. if you want to further force evaluation of post-processed stuff, then it is insufficient, and sometimes redundant.
20:38:57 <ski> xtx : nice :)
20:39:14 <Ralith> merijn: no less relevant than yours to mine :P
20:39:15 <ski> xtx : do you have a tutorial or book to read ?
20:39:56 <merijn> Ralith: I'm pointing out that depending on the original speaker's OS he may be meaning a different thing by fullscreen then just "maximised"
20:40:12 <CrazyM4n> Lubuntu, and yes, I do.
20:40:19 <monochrom> flamebait and strong conviction are indistinguishable
20:40:19 <Ralith> merijn: I didn't say anything about a "maximised" state
20:40:27 <CrazyM4n> Though there is a feature to auto-fullscreen any window, it's just getting rid of the title bar
20:40:48 <monochrom> but I extinguish both anyway. strong convictions are the root of all evil.
20:41:00 <merijn> monochrom: My manager told me I should do "rant videos" on youtube, because he thinks my ranting monologues on how technology sucks are amusing >.>
20:41:32 <Ralith> I'm sure there's an audience
20:42:45 <CrazyM4n> There's definately an audience
20:43:14 <merijn> Utterly unrelated: Dear jesus, why is converting numeric types of different sizes so ungodly hard?
20:43:32 <Ralith> is it?
20:43:45 <jack_rabbit> merijn, why would Jesus know about "ungodly" things?
20:44:11 <merijn> Ralith: I "fixed" a bug in base resulting from wrong conversion, then I discovered a bug in my bugfix and fixed that
20:44:14 <CrazyM4n> Gotta be accurate with your expletitives
20:44:34 <monochrom> I don't know. but even university students switching majors is hard.
20:44:38 <merijn> Ralith: Both of these patches had at least 2 GHC people review them, now, several months later, I figure out my last fix is STILL broken
20:44:44 <Ralith> oh dear
20:45:48 <CrazyM4n> So I'm about finished with my MacGyver comonads
20:45:57 <juri_> abandoned haskell is a mess.
20:46:16 * juri_ is trying to debug implicitcad.
20:47:38 <noa-> merijn: I just use fromIntegral and pray :)
20:48:05 <merijn> noa-: That's broken if your types don't support arbitrary precision
20:48:16 <monochrom> merijn was probably fixing the things behind fromIntegral
20:48:44 <merijn> monochrom: No, I was fixing a hopelessly optimistic assumption about the relation between the size of Int and CInt
20:48:50 <monochrom> so now all the foregoing conversation means that you pray to merijn rather than Jesus...
20:50:31 <noa-> merijn: it always works when converting to a larger integer (of the same signess) yes? and when converting to smaller integer you cant avoid losa of information
20:50:40 <noa-> loss*
20:51:10 <merijn> noa-: Right, which means you need to detect and work around the smaller integer
20:51:20 <monochrom> merijn: on April 1st, you should convert this way: the sign bit goes to bit 0...
20:51:21 <CrazyM4n> Why does http://lpaste.net/2913724071512375296 tell me that parseRule isn't in scope?
20:51:26 <CrazyM4n> I clearly put it in the where block
20:52:17 <monochrom> your where block is good for the last equation only
20:52:45 <CrazyM4n> Oh. I didn't know that, thanks
20:53:26 <noa-> merijn: why wasnt it possible to change the final type?
20:53:50 <noa-> instead of down converting
20:53:58 <merijn> noa-: Because that would require changing the C compiler and potential the OS :p
20:54:06 <noa-> mmhm
20:56:11 <monochrom> noa-: CInt has to correspond to C's int
20:59:31 <CrazyM4n> Yeah, I give up with this cellular automata buisness
20:59:38 <CrazyM4n> D:
20:59:45 <vanila> CrazyM4n, you dont have to give up, i could help if you like
21:00:13 <CrazyM4n> Well, it just needs to be completely refactored. I tried to make it without comonads and I hit more and more walls
21:00:25 <CrazyM4n> And I don't think I can get past them
21:00:25 <vanila> I agree to write it without comonad
21:00:28 <CrazyM4n> I'll show you
21:00:33 <vanila> and starting from scratch is a good approach - I use this a lot :)
21:00:47 <vanila> which CA do you want to impement first? I gather it's a 1D one
21:01:02 <CrazyM4n> This was my point - I've learned more about comonads by not using them than I have by trying to use them
21:01:11 <kadoban> Hehe
21:01:16 <prinsen> How do you do this in parsec: [lookahead ∉ {{, function}]
21:01:18 <CrazyM4n> http://lpaste.net/7428578634912235520
21:01:20 * hackagebot coordinate 0.0.16 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.16 (TonyMorris)
21:01:39 <CrazyM4n> That's what I have so far. Everything above mainLoop works properly
21:01:49 <CrazyM4n> I have no idea how to implement the mainloop though
21:02:18 <benzrf> bye
21:02:47 <johnarmstrong> how do you specify an empty char?
21:02:48 <monochrom> prinsen: there is "lookAhead", it may help
21:04:34 <CrazyM4n> err, everything above mainloop doesn't work
21:04:43 <CrazyM4n> I accidentally screwed up one of the pattern matches in rule
21:04:53 <johnarmstrong> help?
21:05:16 <merijn> johnarmstrong: What does "an empty char" mean?
21:05:17 <prinsen> monochrom: notFollowedBy seems perfect
21:06:10 <monochrom> yeah, that's even better, you're doing ∉
21:06:26 <johnarmstrong> "" !! 0
21:06:33 <johnarmstrong> what is that symbolically
21:06:45 <merijn> johnarmstrong: That's taking the first element of an empty list
21:06:48 <monochrom> that is ⊥, symbolically
21:06:51 <Cale> johnarmstrong: That's a runtime error
21:07:02 <CrazyM4n> haha
21:07:10 <johnarmstrong> thanks for nothing
21:07:15 <prinsen> monochrom: how do yo do 'or'? I guess what I want is notFollowedBy (try $ string "{" OR string "function")
21:07:32 <monochrom> "or" is <|>
21:07:45 <prinsen> duh, thanks
21:11:36 <juri_> how would i start debugging a haskell program (implicitcad) eating all of ram?
21:12:14 <ReinH> juri_: perhaps with this https://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
21:13:28 <monochrom> I can only tell you how I would do it, not how you would do it.
21:14:11 <monochrom> I would start by trying to prove that the program should use O(1) space, or O(n) space, or whatever I expect. I can do this because I know enough about lazy evaluation.
21:14:25 <juri_> i do not know any haskell.
21:14:43 <monochrom> during the attempt to prove, I would find out where I'm stuck or what goes wrong.
21:15:09 <monochrom> well, then, you have a long road ahead. first you have to learn quite some haskell.
21:15:20 <juri_> trying to use this program, and i have very few versions that compile nowadays, and am tracking down the git commit that makes it eat all ram.
21:15:41 <monochrom> but you could also pay someone to do it
21:16:05 <monochrom> I suggest paying. it creates employment and saves you time.
21:16:20 <codygman> Does anyone know if there is a way I can get wreq to output the requests it is sending? Like a debug mode which prints out the url/headers being sent? Can't really monitor https requests sent to another website, lol.
21:16:22 <juri_> i really just wanted to recompile the ancient version i have on my server, but that aparently does not work, when compiling.
21:16:25 <juri_> no cash.
21:16:58 <xtx> how do you guys handle errors? there are times when i don't know what to do ;/
21:17:06 <xtx> I coded in cpp
21:17:23 <monochrom> xtx: read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
21:17:35 <CrazyM4n> In that cellular automata as comonads article, I'm not sure exactly what the second line here does: http://lpaste.net/2281071501866172416
21:18:12 <CrazyM4n> If I've gotten it correctly, it takes all the left part of A, makes it into a list where it gets shifted left incrementally more, and does the same with the right side
21:18:25 <CrazyM4n> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html for context
21:20:48 <jxv> xtx, prefer Maybe's and Either's when you can
21:21:21 <monochrom> jxv: read my http://www.vex.net/~trebla/haskell/exception.xhtml
21:22:50 <merijn> codygman: Just run wireshark or some other packet capturing program?
21:24:07 <RyanGlScott> Is there a commonly-used equivalent of Either for three possibilities?
21:24:26 <monochrom> no, you have to create one yourself
21:24:40 <CrazyM4n> Well, thanks guys, I understand comonads now. That was a *lot* easier than I expected
21:24:51 <CrazyM4n> Well, not understand, but I get them enough to use them
21:26:36 <jxv> monochrom, couldn't you generalize (data Error) into a typeclass and still have flexibility?
21:27:13 <brianpWins> I keep forgetting how lazy evaluation takes place. In an expression “f x g y” I think to myself lazy would start from the outside in only computing the inner as it needs to. Lazy to me would mean “((f x) g) y” but I think it actually evaluates “f (x (g y))”. Can someone sort me out?
21:27:20 <monochrom> yes. why?
21:27:33 <jxv> just curious
21:27:52 <merijn> brianpWins: No, it evaluates to the former
21:28:19 <brianpWins> merijn: So my original concpet of how Lazy works is correct?
21:28:21 <xtx> good bye
21:28:29 <merijn> brianpWins: Your second version has "function g applied to y, function x applied to the result of "g y", and function f applied to "x (g y)"
21:28:31 <monochrom> "f x g y" is parsed to "((f x) g) y". this is just the parsing stage. no evaluation yet. both Haskell and SML do this.
21:28:43 <merijn> brianpWins: Well, neither of what you said has anything to do with laziness :)
21:28:53 <brianpWins> lol So I’m real confused lol
21:29:23 <merijn> Doesn't CIS94 explain this very thoroughly?
21:29:28 <merijn> @where cis194
21:29:28 <lambdabot> I know nothing about cis194.
21:29:30 <merijn> hmm
21:29:33 <monochrom> I believe that you make the mistake of mixing parsing and evaluation because school taught you so. but school had a simpler story to tell.
21:30:32 <merijn> blah, I don't remember where to find the CIS194 lecture notes
21:30:32 <brianpWins> so parsing the expression it reads like I thought. but that has nothing to do with lazily evaluation the expression.
21:30:33 <Total_1mmersion> What kinds of cool things can you do with this definition of a Tree? data Tree x a = Leaf a | Node (x (Tree x a)); type RoseTree a = Tree [] a
21:30:35 <monochrom> more precisely, "x + y*z" does not mean "evaluate y*z first", despite what school said. it only means "parse as x + (y*z)". after that, you worry about evaluation. but not before.
21:31:00 <brianpWins> noted
21:31:04 <brianpWins> thanks!
21:31:24 * hackagebot picosat 0.1.2 - Bindings to the PicoSAT solver  http://hackage.haskell.org/package/picosat-0.1.2 (sdiehl)
21:32:26 <merijn> brianpWins: It's actually not that hard. Evaluation only ever happens in one place pattern matching
21:32:49 <monochrom> cis194 is at http://www.seas.upenn.edu/~cis194/
21:33:09 <merijn> brianpWins: Let's take "case someExpr of (x:xs) -> Just x; [] -> Nothing" as example
21:34:02 <merijn> brianpWins: The first pattern is a "(:)" constructor with two variables, so all we need to do is check if the "outer" constructor of the result "someExpr" matches that constructor
21:34:24 <jxv> monochrom, the button at the bottom of the page should be relabeled to something like "toggle approach" and placed higher. It almost didn't click it. Thanks for the tip/link.
21:34:45 <merijn> brianpWins: Actually, this is somewhat easier to see with prefix constructors... so let me define "data List a = Nil | Cons a (List a)"
21:36:08 <merijn> brianpWins: "case someExpr of Cons x xs -> Just x; Nil -> Nothing", so lazy evaluation will stop as soon as evaluation finds the first constructor returned by "someExpr"
21:36:24 * hackagebot picologic 0.1.1 - Utilities for symbolic predicate logic expressions  http://hackage.haskell.org/package/picologic-0.1.1 (sdiehl)
21:36:31 <brianpWins> Ahhhh
21:36:51 <brianpWins> That makes sense to me.
21:37:15 <merijn> brianpWins: Suppose we have "map f (Cons x xs) = Cons (f x) (map f xs)", is "someExpr" was an application of map, then as soon as we see that the result of map is "Cons ? ?" we can stop and don't have to see what "f x" and "map f xs" are
21:37:48 <merijn> brianpWins: We'll only evaluate the "f x" and "map f xs" parts when we try to pattern match *those*
21:40:38 <^StarLord> yeah, not really. I can't seem to register to some programing channels like python, so I thought I would try someone else were someone might program
21:41:05 <^StarLord> mt
21:41:23 <monochrom> wrong window?
21:46:25 * hackagebot ddc-base 0.4.1.2 - Disciplined Disciple Compiler common utilities.  http://hackage.haskell.org/package/ddc-base-0.4.1.2 (BenLippmeier)
21:46:27 * hackagebot ddc-core 0.4.1.2 - Disciplined Disciple Compiler core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.4.1.2 (BenLippmeier)
21:48:07 <Total_1mmersion> How do you make this data type an instance of Show? This doesn't compile: data Tree t a = Tree (t (Tree t a)) deriving (Show)
21:48:44 <nkar> what's the error?
21:49:29 <vanila> I think you can use standalone deriving
21:49:53 <vanila> deriving instance (Show a, Show (t (Tree t a)) => Show (Tree t a)
21:49:55 <vanila> something like that
21:51:14 <vanila> deriving instance Show a, Show (t (Tree t a) => Show (Tree t a)
21:51:26 * hackagebot ddc-base 0.4.1.3 - Disciplined Disciple Compiler common utilities.  http://hackage.haskell.org/package/ddc-base-0.4.1.3 (BenLippmeier)
21:56:26 * hackagebot ddc-core 0.4.1.3 - Disciplined Disciple Compiler core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.4.1.3 (BenLippmeier)
21:56:28 * hackagebot ddc-core-simpl 0.4.1.3 - Disciplined Disciple Compiler code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.4.1.3 (BenLippmeier)
21:56:30 * hackagebot xml-lens 0.1.6.2 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.6.2 (FumiakiKinoshita)
21:56:32 * hackagebot ddc-core-eval 0.4.1.3 - Disciplined Disciple Compiler semantic evaluator for the core language.  http://hackage.haskell.org/package/ddc-core-eval-0.4.1.3 (BenLippmeier)
21:56:34 * hackagebot ddc-core-salt 0.4.1.3 - Disciplined Disciple Compiler C code generator.  http://hackage.haskell.org/package/ddc-core-salt-0.4.1.3 (BenLippmeier)
21:56:58 <brianpWins> thanks merijn !
22:01:36 * hackagebot ddc-core-llvm 0.4.1.3 - Disciplined Disciple Compiler LLVM code generator.  http://hackage.haskell.org/package/ddc-core-llvm-0.4.1.3 (BenLippmeier)
22:01:38 * hackagebot ddc-core-flow 0.4.1.3 - Disciplined Disciple Compiler data flow compiler.  http://hackage.haskell.org/package/ddc-core-flow-0.4.1.3 (BenLippmeier)
22:01:40 * hackagebot ddc-core-tetra 0.4.1.3 - Disciplined Disciple Compiler intermediate language.  http://hackage.haskell.org/package/ddc-core-tetra-0.4.1.3 (BenLippmeier)
22:01:42 * hackagebot ddc-build 0.4.1.3 - Disciplined Disciple Compiler build framework.  http://hackage.haskell.org/package/ddc-build-0.4.1.3 (BenLippmeier)
22:01:45 * hackagebot ddc-source-tetra 0.4.1.3 - Disciplined Disciple Compiler source language.  http://hackage.haskell.org/package/ddc-source-tetra-0.4.1.3 (BenLippmeier)
22:03:41 <__jim__> does anyone know of a decent yampa and/or arrow tutorial?
22:06:47 * hackagebot ddc-interface 0.4.1.3 - Disciplined Disciple Compiler user interface support.  http://hackage.haskell.org/package/ddc-interface-0.4.1.3 (BenLippmeier)
22:06:49 * hackagebot ddc-driver 0.4.1.3 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.4.1.3 (BenLippmeier)
22:06:51 * hackagebot ddc-code 0.4.1.3 - Disciplined Disciple Compiler base libraries.  http://hackage.haskell.org/package/ddc-code-0.4.1.3 (BenLippmeier)
22:06:53 * hackagebot ddc-tools 0.4.1.3 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.4.1.3 (BenLippmeier)
22:06:55 * hackagebot ddc-war 0.4.1.3 - Disciplined Disciple Compiler test driver and buildbot.  http://hackage.haskell.org/package/ddc-war-0.4.1.3 (BenLippmeier)
22:27:38 <pharaun> that's lots of ddc
22:41:51 <solatis> pharaun: ddc looks scary
22:47:12 <levi> It's cool to see DDC is still being actively worked on.
22:49:46 <juri_> um.. why is -rtsopts not working? :P
22:53:53 <adas1> what is ddc?
23:17:12 <levi> It's a somewhat Haskell-like language.
23:27:54 <azliqur> Anyone know how I'd turn an integer encoded as a bytestring back to an integer?
23:28:19 <davean> azliqur: depends on its encoding
23:28:36 <davean> "ass a bytestring" doesn't define its formate
23:29:01 <azliqur> I see
23:29:15 <azliqur> I used Data.ByteString?
23:29:36 <azliqur> and wrote intBytes i = toStrict $ encode (i :: Integer)
23:31:09 <davean> azliqur: encode isn't a function from Data.ByteString?
23:31:48 <davean> azliqur: so, it'll depend on which encode you used ...
23:32:04 <azliqur> right...
23:32:22 <azliqur> i convert to a lazy bytestring and use tostrict to get a strict bytestring, sorry
23:32:51 <davean> yes. but you'll need the inverse of your encode function, and since you haven't said which encode function you used ...
23:36:41 <azliqur> oh right, I use Data.Binary.encode
23:37:13 <davean> azliqur: well then: decode :: Binary a => ByteString -> a
23:37:31 <davean> you just mirror your function
23:37:31 <azliqur> shit
23:37:37 <azliqur> that was so easy, thanks
23:38:29 <davean> bytesInt b = decode $ fromStrict b
23:46:39 * hackagebot app-settings 0.2.0.5 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.5 (EmmanuelTouzery)
23:47:22 <levi> Haskell: shit, that was so easy
23:59:08 <redtricycle> What is the easiest way to scrape a page and use css selection?
23:59:19 <redtricycle> I've used http-conduit before -- is that overkill?
