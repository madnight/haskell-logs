00:00:02 <mauke> ALL POLITE, LIKE
00:04:01 <Haskellfant> Hi, I'm looking for resources on how to deploy scotty. Is running the generated executable the right way or is this only meant for development?
00:04:22 <bitonic> I have this problem with `cabal haddock' tripping over files included with #include
00:06:12 <bitonic> it doesn't seem to copy the extra-source-files to whatever directory it's using
00:06:40 <dmj`> Haskellfant: you should run it right away
00:06:47 <Haskellfant> dmj`: ok thx
00:07:24 <dmj`> Haskellfant: compiling with -threaded -O2 and run with +RTS -N
00:27:49 * hackagebot accelerate-utility 0.0.1 - Utility functions for the Accelerate framework  http://hackage.haskell.org/package/accelerate-utility-0.0.1 (HenningThielemann)
00:33:40 <bitonic> right, if I use include-dirs and not relative includes it works
00:37:41 <bitonic> also, in cabal, if I have an executable target and a library target, the executable depending on the library, how can I make the executable always build on the "current" library modules instead of an already installed version
00:38:12 <glaukon> First time here. How do I convert a single Word8 to a single Char using Data.Encoding library?
00:39:01 <mauke> chr . fromIntegral
00:39:34 <glaukon> Currently I have this unbelievably ugly solution: toChar w8 = head $ decodeLazyByteString CP1250 (B.singleton w8)
00:39:56 <mauke> > (chr . fromIntegral) (65 :: Word8)
00:39:58 <lambdabot>  'A'
00:40:06 <merijn> mauke: That's not encoding aware, though
00:40:25 <mauke> it's aware of latin1
00:40:37 <bitonic> oh, actually that seems to happen automatically.
00:40:43 <merijn> glaukon: You can pointfree-ify that a bit, but I don't see a much nicer solution
00:41:09 <merijn> glaukon: You should probably use a safer function than head
00:42:35 <glaukon> merijn: you mean something like this: toChar = head . (decodeLazyByteString CP1250) . B.singleton
00:43:03 <merijn> glaukon: The parenthesis are unnecessary, but yeah
00:43:06 <latermuse> :q
00:43:37 <merijn> glaukon: function application binds tighter than operators, so the parens free version is exactly the same thing
00:44:46 <glaukon> merijn: ok I got it. Not sure what you mean by head not being safe?
00:45:47 <glaukon> merijn: I mean, decodeLazyByteString should always return something.
00:50:02 <Hijiri> head will crash on empty lists
00:50:35 <Hijiri> If you can think of a sensible operation for empty lists you might want to pattern match instead
00:54:02 <merijn> glaukon: Oh, CP1250 has no multi-byte values and all 255 values are correct? If so, you're right
00:54:22 <merijn> Hijiri: He's not using lists and it might actually be guaranteed to be non-empty
01:21:23 <Hijiri> oh
01:21:36 <Hijiri> sorry, I didn't read enough of the logs
01:23:08 <_rai> how do i find :t (:) on hoogle?
01:39:33 <jTT_> hi, i am having a weird issue with cabal and was wondering if anyone could help: I get the following error when trying to install some packages:xml-types-0.3.4 failed during the configure step. The exception was:
01:39:33 <jTT_> user error (The package 'xml-types' requires Cabal library version >=1.19.2 &&
01:39:35 <jTT_> >=1.6 but no suitable version is installed.).   Yet, cabal —version shows: cabal-install version 1.20.0.3
01:39:36 <jTT_> using version 1.20.0.2 of the Cabal library   But: cabal install cabal says: All the requested packages are already installed:
01:39:36 <jTT_> Cabal-1.18.1.4
01:40:01 <jTT_> Has anyone got a clue as to what this means?
01:40:20 <jTT_> I suspect that perhaps homebrew installed some old version of cabal?
01:45:33 <ph88> hi guys
01:46:08 <shiona> hello
01:47:48 <mmmm_> jTT_: are you in a sandbox?
01:48:14 <mmmm_> did you run cabal update before "cabal install Cabal"
01:48:35 <jTT_> mmmm_: did run cabal update
01:48:56 <jTT_> and not in sandbox (but tried before and didnt change)
01:49:02 <jTT_> whats the relevance of sandbox here?
01:50:11 <mmmm_> well before I have installed an updated version of cabal in a sandbox by accident and wondered why it wasn't updated
01:50:37 <jTT_> ha, i see!
01:51:00 <jTT_> but wouldnt cabal —version then still show the old version?
01:51:10 <jTT_> in my case it shows the newest
01:51:59 <mmmm_> so what happens if you go in a sandbox and "cabal install xml-types"
01:52:31 <jTT_> trying
01:56:48 <Dorothy23>  Never Pay for Porn ever again. Click Here! http://tinyurl.com/ozfvxy3
02:02:59 * hackagebot libhbb 0.4.0.0 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.4.0.0 (wolfch)
02:06:32 <jTT_> meh, battery dying. will try this chat room later again. cheers either way mmmm_:
02:08:00 * hackagebot hbb 0.4.0.0 - Haskell Busy Bee, a backend for text editors.  http://hackage.haskell.org/package/hbb-0.4.0.0 (wolfch)
02:12:33 <ddellacosta> anyone written any web automation stuff using Haskell via webkit somehow?
02:13:12 <ddellacosta> ah, maybe I should check out ghcjs
02:18:32 <chirpsalot> ddellacosta: http://hackage.haskell.org/package/HTTP-4000.0.9/docs/Network-Browser.html
02:19:07 <ddellacosta> chirpsalot: thanks, I'll take a look at that
02:19:29 <chirpsalot> Dunno if it does JS or anything.
02:23:57 <lsix> I used a bit of Network-Browser recently. From what I recall, it is usefull to simulate a browsing session (keep cookies and so on), but you get ByteString as replies, so you still have to handle html/js parsing elsewhere
02:25:30 <ddellacosta> yeah, may not be super useful to me if I'm trying to simulate interactions with a one-page app, unfortunately. :-(
02:27:20 <chirpsalot> lsix: ah, I see. That's the impression I got, but I don't do webby wubby wooby stuff so I wasn't sure :).
02:27:56 <chirpsalot> I mean, apparently there are a few browsers in Haskell...
02:27:59 <chirpsalot> https://github.com/k0ral/hbro
02:29:44 <chirpsalot> lsix: what did you use it for?
02:31:58 <lsix> I used it to have a browsing session where the first requests do authentification (and the server send cookies back), and after reuse those cookies to fetch real data
02:34:42 <Guest75448> ciao a tutti
02:34:59 <chirpsalot> Italian?
02:35:21 <Guest75448> !list
02:35:21 <monochrom> Guest75448: http://lpaste.net/browse
02:36:09 <Guest75448> si
02:36:18 <mauketwork> how did you find this channel?
02:56:11 <bernalex> anyone know what on earth is causing the error message: "Illegal instance declaration for ‘persistent-2.0.8:Database.Persist.Class.PersistStore.ToBackendKey persistent-2.0.8:Database.Persist.Sql.Types.SqlBackend Permissions’ (Only one type can be given in an instance head. Use MultiParamTypeClasses if you want to allow more.)"?
02:56:49 <bernalex> fixing it is absolutely as trivial as it suggests -- however, a few weeks ago when last I built this code it worked fine without the pragma. the deps have not even been bumped. I guess I have some package different somewhere, but which one is causing it?
02:57:07 <bernalex> minor update to persistent-template maybe? hirrrr...
03:09:51 <_rai> does the cons operator (:) have some special property to it since i can't find it using hoogle but (++) i can for example
03:12:40 <indiagreen> _rai: yes, it's a constructor of the list datatype, and since lists aren't defined anywhere but built into GHC, (:) isn't defined anywhere either
03:13:33 <kstt> Hi. Template Haskell seems to load all packages in the deps tree before outputing splices. On MS Windows, this causes a bug when loading GTK packages, making GHC crash. Is there an option to limit the packages that TH loads, as a workaround ?
03:14:06 <kstt> I know for sure that GTK is not required to splice my TH fragments.
03:26:02 <_rai> indiagreen: thanks
03:42:38 <Aleksejs> hi
03:42:49 <Aleksejs> I'm trying to undo this @undo \f -> do {f; io $ threadDelay =<< fmap ((+) 500000 . flip mod 1000000) randomIO}
03:43:08 <mauketwork>  @undo \f -> do {f; io $ threadDelay =<< fmap ((+) 500000 . flip mod 1000000) randomIO}
03:43:12 <mauketwork> @undo \f -> do {f; io $ threadDelay =<< fmap ((+) 500000 . flip mod 1000000) randomIO}
03:43:12 <lambdabot> \ f -> f >> io $ threadDelay =<< fmap ((+) 500000 . flip mod 1000000) randomIO
03:43:19 <Aleksejs> yes, and it fails
03:43:21 <mauketwork> parens
03:43:51 <mauketwork> \ f -> f >> (io $ threadDelay =<< fmap ((+) 500000 . flip mod 1000000) randomIO)
03:44:46 <Aleksejs> thanks!
03:45:16 <bernalex> hmm what's a clean way to do this
03:45:41 <bernalex> let's say I have a list [(1,2),(3,4)] and I want to apply (+) to its members. what's the cleanest way?
03:45:51 <mauketwork> map (+)
03:46:03 <mauketwork> but that will fail unless you have a Num instance for tuples
03:46:16 <bernalex> map (+) won't work
03:46:19 <bernalex> :t map (+)
03:46:20 <lambdabot> Num a => [a] -> [a -> a]
03:46:30 <ThreeOfEight> what do you mean, apply it to the members?
03:46:36 <ThreeOfEight> sum each pair of numbers?
03:46:40 <bernalex> yeah
03:46:41 <ThreeOfEight> that would be map (uncurry (+))
03:46:49 <mauketwork> > (+) (1,2)
03:46:50 <bernalex> ah
03:46:51 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
03:46:51 <lambdabot>    arising from a use of ‘M15513733929089064599913.show_M15513733929089064599...
03:46:51 <lambdabot>  The type variable ‘t1’ is ambiguous
03:46:51 <lambdabot>  Note: there are several potential instances:
03:46:51 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:46:54 <bernalex> ThreeOfEight: thanks.
03:47:00 <mauketwork> > (+) (1,2) (10,2)
03:47:02 <lambdabot>  No instance for (GHC.Show.Show t1)
03:47:02 <lambdabot>    arising from a use of ‘M17072939108984521699925.show_M17072939108984521699...
03:47:02 <lambdabot>  The type variable ‘t1’ is ambiguous
03:47:02 <lambdabot>  Note: there are several potential instances:
03:47:02 <lambdabot>    instance [safe] GHC.Show.Show
03:47:06 <mauketwork> heh
03:49:44 <bernalex> related-ish
03:49:48 <Aleksejs> > map (\(a,b)  -> a + b) [(1,2), (3,4)]
03:49:51 <lambdabot>  [3,7]
03:50:17 <bernalex> given [(String, String)] -- what's a good way to join these with 1. something to separate the pairs in front, and 2. some way to separate the values of pairs.
03:50:55 <bernalex> so if foo = [("hallo", "world"), ("foo", "bar")], I'd like to be able to say f '&' '=' foo, and get '&hallo=world&foo=bar'.
03:51:08 <eikke> Aleksejs: map (uncurry (+)) ;-)
03:51:56 <Angry> I was thinking of making a reverse engineering challenge for a white hat hacking site. Dose anyone have any experience trying to reverse engineer native haskell code?
03:51:58 <ClaudiusMaximus> bernalex: what if the strings contain & or = ?
03:52:04 <mauketwork> bernalex: that seems like a terrible way to do query string encoding
03:52:18 <bernalex> ClaudiusMaximus: it doesn't.
03:52:21 <bernalex> mauketwork: maybe.
03:52:49 <eikke> :t intersperse
03:52:50 <lambdabot> a -> [a] -> [a]
03:53:10 <mauketwork> > (intersperse '&' . map (uncurry (printf "%s=%s"))) [("hallo", "world"), ("foo", "bar")]
03:53:13 <lambdabot>  No instance for (Text.Printf.PrintfType GHC.Types.Char)
03:53:13 <lambdabot>    arising from a use of ‘Text.Printf.printf’
03:53:57 <mauketwork> > (intercalate "&" . map (uncurry (printf "%s=%s"))) [("hallo", "world"), ("foo", "bar")]
03:53:59 <lambdabot>  "hallo=world&foo=bar"
03:54:26 <mauketwork> > (join . map (uncurry (printf "&%s=%s"))) [("hallo", "world"), ("foo", "bar")]
03:54:28 <lambdabot>  No instance for (GHC.Show.Show a0)
03:54:28 <lambdabot>    arising from a use of ‘M365136965403549586310101.show_M3651369654035495863...
03:54:28 <lambdabot>  The type variable ‘a0’ is ambiguous
03:54:28 <lambdabot>  Note: there are several potential instances:
03:54:28 <lambdabot>    instance [safe] GHC.Show.Show
03:54:37 <bernalex> I guess a super simple way would just be
03:54:39 <bernalex> f ((k,v):xs) = '&' : k ++ '=' : v ++ f xs; f [] = []
03:54:50 <bernalex> but with '&' and '=' as args
03:55:15 <mauketwork> > concatMap (uncurry (printf "&%s=%s")) [("hallo", "world"), ("foo", "bar")] :: String
03:55:16 <lambdabot>  "&hallo=world&foo=bar"
03:55:29 <bernalex> lol
03:56:25 <mauketwork> > (\x y -> concatMap (\(k, v) -> printf "%c%s%c%s" x k y v)) '&' '=' [("hallo", "world"), ("foo", "bar")] :: String
03:56:27 <lambdabot>  "&hallo=world&foo=bar"
03:57:09 <egasimus> Hello everyone :)
03:57:10 <mauketwork> > (\x y -> concatMap (\(k, v) -> x : k ++ y : v)) '&' '=' [("hallo", "world"), ("foo", "bar")] :: String
03:57:12 <lambdabot>  "&hallo=world&foo=bar"
03:57:14 <egasimus> I find myself trying to put together a PKGBUILD for Tidal (https://github.com/yaxu/Tidal/blob/master/tidal.cabal) which I would like to upload to the AUR for great justice.
03:57:16 <egasimus> I'm splitting the original install script (https://github.com/yaxu/Tidal/blob/master/doc/install-linux.sh) into three separate PKGBUILDS - one for Dirt (the sound server, written in C), one for Tidal, (Haskell DSL for live coding of musical patterns) and one for the Emacs mode that talks to Tidal (I haven't really gotten to that part yet)
03:57:21 <egasimus> But a couple of the remaining AUR dependencies (haskell-hosc and haskell-mersenne-random-pure64) are giving me shit.
03:57:24 <egasimus> (Looks like the overly specific dependency variety of shit, though I'm sure the maintainers have their reasons.)
03:57:32 <egasimus> Would you recommend adding the ArchHaskell repos as the course of action I would recommend to anyone trying to run my PKGBUILD, and, if not, what should I do to bring Tidal to the Arch-using masses?
04:00:25 <bernalex> hmm is there no generic (a -> b) -> (a, a) -> b anywhere?
04:00:50 <bernalex> err, (a -> b) -> (a, a) -> (b, b)
04:01:17 <mr-> Have you looked at the arrow combinators?
04:01:36 <mauketwork> :t join (***)
04:01:37 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
04:01:47 <bernalex> mr-: those are the ones I'm looking at now
04:01:57 <bernalex> mauketwork: awww yeah I've used that same one in a previous project. thanks.
04:02:11 <mauketwork> I bet there's something in lens
04:02:24 <bernalex> that's not a fair bet ;-)
04:03:49 <bernalex> I've actually found myself doing e.g. map (join (***) f) blah many times. is there an arrow or something which is basically just "join (***)"? obviously not very important to shave those few chars, but it'd puzzle me if this didn't already exist given how common it seems to be for me.
04:05:59 <mauketwork> :t over each
04:06:00 <lambdabot> Each s t a b => (a -> b) -> s -> t
04:06:17 <mauketwork> > over each show ('x', 'y')
04:06:21 <lambdabot>  ("'x'","'y'")
04:06:41 <bernalex> mauketwork: that's nice
04:06:54 <bernalex> :i over
04:07:02 <bernalex> @src over
04:07:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:07:08 <bernalex> @info over
04:07:08 <lambdabot> over
04:07:11 <bernalex> right.
04:07:18 <bernalex> mauketwork: where are those defined?
04:07:21 <mauketwork> lens
04:07:26 <bernalex> of course
04:07:30 <mauketwork> :t over
04:07:32 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
04:07:41 <bernalex> so what's a profunctor anyway?
04:07:57 <bernalex> is it as opposed to a noobfunctor?
04:08:30 <bernalex> I need to reread/finish category theory introduction for computer scientists
04:08:55 <mauketwork> I think it can go both ways
04:09:26 <mauketwork> dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
04:09:31 <mauketwork> :t dimap
04:09:32 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
04:10:07 <nshepperd> such MultiParamTypeClasses...
04:10:28 <bernalex> I just added that to one of my programs because apparently persistent dies without it now
04:11:10 <simon_> bernalex, is that a short book? I once had a book available called "Category Theory for Computer Scientists", but no 'Introduction' in the title. I like Awodey's book, though.
04:11:50 <bernalex> simon_: idk the exact title. it's a paper. might be pressed as a book though. it's about 70 pps iirc. it's quite good, but I didn't have time to finish it when I picked it up, and kind of forgot about it.
04:12:56 <bernalex> it gave some definitions for monomorphic arrows and then went on to some examples where they said "so this adheres to the definition so it can't be monomorphic" and vice versa, at which point I was ultra-confused. I need to figure that stuff out.
04:14:16 <bernalex> right here we go. an arrow f : B -> C in category C is monic if for any pair of C arrows g : A -> B and h : A -> B with the same domain and with codomain B and equality f . g = f . h implies that g = h. OK so far so good.
04:15:44 <bernalex> then in the example they contradict the assumption that f . g = f . h -- and therefore f is a monomorphism. wat? I'm sure I'm reading it very wrong.
04:16:30 <bernalex> simon_: "A Taste of Category Theory for Computer Scientists" is the name.
04:18:13 * hackagebot shake-cabal-build 0.1.0 - Utility for building Shake build systems using Cabal sandboxes  http://hackage.haskell.org/package/shake-cabal-build-0.1.0 (StefanKersten)
04:23:13 * hackagebot shake-language-c 0.5.0 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.5.0 (StefanKersten)
04:29:52 <simon_> bernalex, thanks.
04:51:57 <t-l-o> Hi, I struggle with a type variable (while playing around with vty-ui http://jtdaugherty.github.io/vty-ui/manuals/vty-ui-users-manual-1.0.pdf): type ListItem a b = (a, Widget b) ; then, the function getSelected :: Widget (List a b) -> IO (Maybe (Int, ListItem a b)) ; I want to print a which should be a String in my case, but I get "No instance for (Show a) arising from a use of `print'". Does this mean "a" is not a String?
04:52:46 <mauketwork> what's your code?
04:54:45 <t-l-o> http://lpaste.net/112761
04:55:03 <mauketwork> ...
04:56:45 <ibotty> hi
04:58:43 <t-l-o> mauketwork: It's basically https://github.com/jtdaugherty/vty-ui/blob/vty5/demos/ListDemo.hs (I'll update the paste..)
05:03:36 <t-l-o> updated: http://lpaste.net/112761 --> displayItems is the relevant function
05:04:48 <mauketwork> your type signature says displayItems works for any 'a'
05:05:04 <mauketwork> :t print
05:05:05 <lambdabot> Show a => a -> IO ()
05:05:14 <mauketwork> print only works for types with a Show instance
05:06:21 <t-l-o> mauketwork: I see, what is the best practice to handle such a case?
05:07:43 <mauketwork> you could add (Show a) => to your own type signature
05:09:25 <t-l-o> mauketwork: ah, makes sense, thank you very much!
05:34:13 <michi7x7> phaazon: i was wrong... my rock, scissor, paper does work against (unaware) human opponents. Not very good, but better than plain random
05:49:35 <Haskellfant> I'm trying to read and write to a file but I get an error that my handle is closed when I want to write to the file. I thought that might be related to lazy io so I tried using hGetContents from the strict package but sadly I have exactly the same problem. here's the code http://sprunge.us/KbGK
05:50:08 <mauke> NoBuffering?!
05:50:17 <zmbmartin> Looking for suggestions on fixing this. The code works but feels weird. The idea is if id is Nothing return Nothing, but if it is Just then move on -> https://gist.github.com/codedmart/c554b3713fc5393cda6c
05:50:53 <Haskellfant> mauke: that doesn't help
05:51:01 <mauke> what?
05:52:05 <Haskellfant> mauke: I thought you were suggesting to use NoBuffering on the handle to work around this problem but I still get exactly the same problem http://lpaste.net/112764
05:52:10 <mauke> no
05:52:19 <mauke> I'm grossed out by your use of NoBuffering
05:52:45 <Haskellfant> ah, I use that so that the logs appear immediately in docker and aren't buffered until I kill the container
05:52:54 <hyPiRion> zmbmartin: maybeFmap is identical to *> in Control.Applicative I think
05:52:59 <Haskellfant> why is NoBuffering so bad?
05:53:02 <mauke> Haskellfant: it's also horribly inefficient
05:53:15 <mauke> separate write() call for each character
05:53:27 <Haskellfant> hm k
05:53:36 <zmbmartin> hyPiRion: to <*>?
05:53:38 <mauke> hGetContents closes the filehandle
05:53:42 <mauke> that's your main problem
05:53:59 <Haskellfant> so should I reopen the handle every time I read and write?
05:54:13 <mauke> what are you trying to do?
05:54:25 <hyPiRion> zmbmartin: no, I meant *>
05:54:48 <Haskellfant> I want to read the file & update it when I get a post request
05:54:55 <triliyn> Haskellfant: you can use hFlush I think
05:55:03 <mauke> update how?
05:55:09 <hyPiRion> zmbmartin: right, it's not identical, but it's close
05:55:14 <Haskellfant> currently only appending
05:55:21 <Haskellfant> but that could change
05:55:27 <mauke> but you're appending the current contents
05:55:34 <zmbmartin> hyPiRion: so something like id *> runDB…..
05:55:54 <Haskellfant> atm I'm not appending so I need to write the previous contents in aswell to append new content
05:56:06 <Haskellfant> I wasn't sure if AppendMode allows reading
05:56:21 <hyPiRion> :t (\x y -> return x *> y)
05:56:21 <mauke> no, at that point in the code you're at the end of the file
05:56:22 <lambdabot> (Applicative f, Monad f) => a -> f b -> f b
05:56:28 <mauke> so you're effectively appending
05:56:52 <Haskellfant> oh I think I didn't understand the behaviour of the functions I was using
05:56:57 <Haskellfant> makes sense now that I think about it
05:57:25 <hyPiRion> > return Nothing *> Right (Just 10)
05:57:27 <lambdabot>  Right (Just 10)
05:57:38 <hyPiRion> hrm, not quite.
05:58:39 <zmbmartin> hyPiRion: My code does compile with that but does not fail with Nothing properly.
05:58:49 <Haskellfant> so can I keep the handle open after reading it to append later or should I open it again?
05:59:00 <zmbmartin> I get a Maybe fromJust Nothing error when I run it.
05:59:26 <hyPiRion> zmbmartin: Yeah. I guess your implementation is alright, it's understandable. I don't know if there's anything better for what you want, though I wouldn't be surprised.
05:59:28 <mauke> Haskellfant: I don't know; Haskell's Handles confuse me
05:59:48 <stupident> `cabal install snap-server-0.9.4.5` failed on Windows 7, plz help
05:59:49 <zmbmartin> hyPiRion: I appreciate the help.
06:00:01 <Haskellfant> mauke: ok thx for your help, already made some parts clearer for me
06:01:30 <stupident> "cabal: At least the following dependencies are missing: network >=2.3 && <2.6 && ==2.6.0.2" How to deal with that?
06:03:43 <nshepperd> "<2.6 && ==2.6.0.2"? that sounds like a bug
06:04:06 <zmbmartin> hyPiRion: Is there something that I can just get rid of the fromJust and applicatively pass id to show? Or something like that?
06:04:10 <int-e> nshepperd: it's a combination of constraints from various packages; perhaps 2.6.0.2 is the installed version?
06:04:24 <nshepperd> oh, right
06:04:36 <geekosaur> nshepperd, cabal in my experience does that when it gets inconsistent constraints from different dependencies
06:05:45 <geekosaur> there used to be an infamous one where a glitch in the dependencies for network caused cabal to come up with a 5-element, self-contrdictory constraint for unix
06:05:53 <BoR0> @pl (\x y -> f x ++ y)
06:05:53 <lambdabot> (++) . f
06:06:16 <stupident> "ghc-pkg list network" prints network-2.3.0.13  and network-2.6.0.2 (in 'AppData\Roaming\ghc\...')
06:06:31 <zmbmartin> hyPiRion: actually if I remove the maybeFmap id and start with runDB … Then remove fromJust from the end so just show id it seems to work properly.
06:06:37 <zmbmartin> Would that be right?
06:07:11 <hyPiRion> zmbmartin: I got stuck on the maybeFmap and I'm trying to find a way to express it more succinctly :p
06:10:47 <hyPiRion> zmbmartin: maybeFmap x y = fmap (x *>) y - in case you actually need the maybeFmap
06:12:02 <hyPiRion> Unfortunately too late in the week to comprehend getById right now, and I have to get back to work
06:12:19 <zmbmartin> hyPiRion: ok thanks for your help.
06:16:45 <hyPiRion> np, good luck with it
06:23:26 * hackagebot cpphs 1.18.6 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.6 (MalcolmWallace)
06:28:30 <kstt> Hi. Template Haskell seems to load all packages in the deps tree before outputing splices. On MS Windows, this causes a bug when loading GTK packages, making GHC crash. Is there an option to limit the packages that TH loads, as a workaround ?
06:28:40 <kstt> I know for sure that GTK is not required to splice my TH fragments.
06:31:17 <lillian> Is "Learn You a Haskell for Great Good!" p much everyone's fav book for beginners?
06:38:24 <Itkovian> lillian probably:)
06:39:15 <lillian> Do any of you also know Python?
06:39:29 <sleepynate> i'm sure quite a few of us do.
06:40:04 <lillian> Okay, I was wondering if you could, for a moment, some things you like a lot more about Haskell/stuff you find is easier/how much more you use it, etc.
06:40:47 <vanila> lillian, yeah LYAH is good except a little problematic in parts
06:41:03 <lillian> kool
06:41:39 <ThreeOfEight> lillian: I  barely ever use Python these days
06:41:56 <tsani> vanila: which parts of LYAH would you consider problematic?
06:42:10 <lillian> ThreeOfEight: Haskell made Python seem really shit, mm? :p Things were just easier to avoid in Haskell?
06:42:11 <ThreeOfEight> Higher Order Functions, purity, those are two great advantages of Haskell
06:42:16 <vanila> tsani, fat shaming, "GAYBALLS" etc.
06:42:18 <ThreeOfEight> lillian: well I never was a big python user
06:42:55 <ThreeOfEight> Haskell kind of made all imperative/object-oriented languages I know seem very ugly and inefficient
06:43:07 <tsani> vanila: oh, I thought there was something problematic about the material per se. Yeah, the humour is a bit crude.
06:43:19 <lillian> I used big pythons all the time
06:43:24 <ThreeOfEight> I did use some Standard ML before I learned Python and I already was very impressed with that.
06:43:31 * lillian reads up on HOF and purity
06:43:43 <lillian> ThreeOfEight: that's what I hear
06:43:45 <ThreeOfEight> but Haskell seems even more elegant
06:43:48 <ThreeOfEight> er
06:43:52 <lillian> Yeah i getcha
06:43:55 <ThreeOfEight> I did use some Standard ML before I learned Haskell
06:43:57 <ThreeOfEight> that's what I meant
06:44:01 <vanila> haskell syntax is way terser than the MLs
06:44:03 <lillian> Imma get into Haskell then. :3
06:44:09 <lillian> It always seemed so nice~
06:44:15 <tsani> Is Real World Haskell worth reading, considering the outdated bits? And which bits are outdated exactly?
06:44:21 <ThreeOfEight> and by ‘purity‘ I also mean that you don't do work by modifying state
06:44:32 <lillian> oh right because everything is immutable
06:44:37 <ThreeOfEight> oh, and I almost forgot: the type system
06:44:42 <lillian> it's not bad?
06:44:44 <lillian> :p
06:44:46 <ThreeOfEight> I never was a fan of untyped languages
06:44:47 <lillian> makes things clearer?
06:44:52 <lillian> yeah i kinda see that now
06:44:53 <lillian> in python
06:44:54 <vanila> yeah the pureness is really unusual and interesting
06:44:56 <lillian> how annoying it CAN Be
06:44:57 <ThreeOfEight> not only clearer, it prevents mistakes
06:45:08 <lillian> because you know in python i always have to put the arg type in the docstring to make things clear
06:45:14 <ThreeOfEight> a type system is basically free static checking of your code for errors
06:45:15 <lillian> a language should be self-documenting
06:45:19 <lillian> yeah
06:45:28 <ThreeOfEight> so I don't see why you would /not/ want that
06:45:33 <lillian> Mhm!
06:45:40 <username> Idris for the rescue? :)
06:45:43 <exio4> haskell's syntax is kinda beautiful anyway, you can see a more-general "idea" of the algorithm really easy compared to other langs
06:46:06 <mauketwork> inb4 @pl
06:46:23 <lillian> Okay, awesome. I kinda don't like the way Python is headed, anyway.
06:46:26 <lillian> It's so politicized now
06:46:37 <exio4> ThreeOfEight: the type system has to be "expressive enough", a really few are really worth 'the hassle' :P
06:46:47 <vanila> lillian, yeah :(
06:47:53 <centipede> polticized? how do you mean?
06:48:06 <vanila> pythons lack of tail call optimization for example
06:49:03 <ThreeOfEight> username: well, the problem with Idris is that type inference and type checking are undecidable
06:49:14 <username> tail call optimization, is somewhat far/unreachable in most cases
06:49:25 <lillian> oh and like... ugghhh *shivers* python users x.x
06:49:30 <centipede> some time ago, I saw guido's slides on gradual typing
06:49:34 <ThreeOfEight> if you make your type system too powerful, things can get a bit tedious
06:49:43 <ThreeOfEight> but of course, a powerful type system is also very nice to have
06:49:54 <ThreeOfEight> I like Idris in theory, but I never managed to use it for something non-trivial
06:50:05 <username> ThreeOfEight: true :)
06:50:09 <ThreeOfEight> although I am sure that is entirely my loss; I am planning to have another look at it at some point
06:50:32 <ThreeOfEight> But when I want to prove something like correctness of my programs, I prefer a system with more automation, such as Isabelle
06:51:17 <ThreeOfEight> I wonder where Liquid Haskell is going; I gave a seminar talk on Liquid Types a few years ago and it seemed very promising.
06:51:33 <vanila> ThreeOfEight, yeah I think semi-automatic provers like Isabelle and Coq are a very different thing than idris
06:51:58 <vanila> even though they're based on the same theory
06:52:29 <username> they don't target to be a programming language :)
06:52:54 <ThreeOfEight> Isabelle isn't based on the same logic. Coq, as far as I know, is.
06:53:06 <lillian> tee hee coq
06:53:29 <bergey> Is Agda also in the "semi-automatic" category?
06:53:29 * hackagebot fast-logger 2.2.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.2.1 (KazuYamamoto)
06:53:42 <ThreeOfEight> Isabelle doesn't have dependent types, it has Higher Order Logic with ML-style polymorphism.
06:53:56 <ThreeOfEight> bergey: I don't think Agda has automation, but I have never used it.
06:54:21 <ThreeOfEight> and Isabelle and Coq both have code extraction to certain target languages.
06:54:24 <ThreeOfEight> (such as Haskell)
06:54:52 <vanila> lillian,  :P
06:55:21 <ThreeOfEight> lillian: well, the French like naming software after animals, apparently.
06:55:44 <ThreeOfEight> Rest assured that all the jokes that are possible in connection with this have already been made.
06:55:45 <lillian> OH, I see. :p
06:55:55 <lillian> I just blush every time I read "coq.
06:55:55 <lillian> "
06:56:19 <vanila> lillian, im sorry~ ^^
06:56:54 <lillian> is coq a large installation~ <3?
06:56:56 <lillian> jk
06:57:10 <ThreeOfEight> There was a tweet a while ago. ‘If you're interviewing a candidate for a job and want to see how geeky they are, ask them if they like Coq and watch the amount of distress on their face. If they looked distressed – not geeky enough.’
07:00:10 <Thooms> :D
07:06:13 <lb5tr> https://github.com/albertoruiz/easyVision/blob/master/packages/gui/src/Vision/GUI/Draw.hs
07:07:02 <lb5tr> http://lpaste.net/112771
07:07:08 <lb5tr> this is what I'm getting
07:07:19 <lb5tr> (this is not my code)
07:07:24 <lb5tr> (I just want to build it)
07:07:33 <lb5tr> any help?
07:07:52 <lb5tr> (if i remove troublesome call it works well, build and other parts of the system works :) )
07:07:58 <lb5tr> but i wanted to push a patch upstream
07:08:06 <albeit> @pl \x -> (x - y) ^ 2
07:08:06 <lambdabot> (^ 2) . subtract y
07:08:31 * hackagebot syntactic 1.14 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.14 (EmilAxelsson)
07:08:40 <exio4> @pl \a b → a (a b)
07:08:41 <lambdabot> (line 1, column 7):
07:08:41 <lambdabot> unexpected "\134"
07:08:41 <lambdabot> expecting pattern or "->"
07:08:48 <exio4> ahm
07:08:50 <hyPiRion> heh
07:09:11 <lb5tr> any help?
07:09:19 <t4nk798> hello
07:10:13 <t4nk798> great https://gist.github.com/quchen/5280339
07:12:36 <lb5tr> nvm fixed
07:12:37 <nkh_> Is Haskell faster than oCaml?
07:12:38 <lb5tr> :)
07:13:50 <RedNifre_> I don't know, but I think C is 3x faster than Haskell, so if you know how fast oCaml is compared to C...
07:13:54 <bernalex> "a group is essentially the same thing as a one-object category where every arrow is an isomorphism" -- can someone give me an example to demonstrate this? I don't understand it.
07:13:55 <vanila> nkh_, I think they're fairly competitive - haskel lcomes out on op in here ythou http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=ocaml&data=u32
07:15:44 <simon_> bernalex, Z/5 where arrows are Aut(Z/5)?
07:16:21 <bernalex> simon_: what's Aut?
07:16:23 <simon_> bernalex, if there is only one object, arrows can only go from that object to itself.
07:16:26 <bernalex> simon_: I don't know maths lol
07:16:50 <bernalex> simon_: aha right so that's what they mean.
07:16:54 <bernalex> simon_: I suspected this.
07:17:32 <simon_> bernalex, Z/5 = ({0,1,2,4},* modulo 5) and Aut(Z/5) is the set of permutations of Z/5 (or rather, the set of mappings from Z/5 to itself).
07:18:21 <mr-> simon_: why do you mention Aut?
07:18:30 <simon_> mr-, I don't know. :)
07:18:47 <simon_> mr-, I need arrows on Z/5!
07:18:57 <simon_> bernalex, I'm not strong on mathematics either. but I think it means that every arrow is an automorphism.
07:19:09 <bernalex> simon_: haven't gotten to automorphisms yet lol
07:19:16 <bernalex> simon_: but I can guess from their name what they are :-]
07:19:18 <mr-> bernalex: Take any group G, make a category thus: You have one object and the set G is the set of morphisms between that one object. Composition of arrows then is just the multiplication in the group, the neutral element is the identity function
07:19:21 <simon_> bernalex, they're just isomorphisms from one object to itself.
07:19:45 <bernalex> simon_: I assumed so
07:19:51 <mr-> simon_: G + Aut(G) is not the "one-object category" bernalex is talking about.
07:20:00 <simon_> mr-, oh.
07:20:23 <bernalex> mr-: I'm not sure what "multiplication in the group" means here
07:20:47 <mr-> bernalex: a group is a set G of things and a "multiplication" m: G x G -> G
07:21:15 <mr-> bernalex: for example the integers Z together with addition, or the real numbers R together with addition
07:22:16 <simon_> mr-, how can the set G be a set of morphisms when they're basic elements? if the one object is G, don't the arrows map from G to itself, rather than map the elements of G to one another?
07:22:22 <mr-> bernalex: so for Z, make the category that has one object *, and Hom(*,*) = Z, where composition of 4 and 2 (say) is 4+2
07:23:08 <mr-> simon_: the morphisms don't do anything with the object. The object is abstract. Call it * :-)
07:25:22 <mr-> simon_: Take your example, you may choose to call your object Z/5 and your morphisms Aut(Z/5) and get a category that way. However, it is the same as my category with object * and homomorphisms Aut(Z/5). There just happens to be no difference to * with Z/5, because Z/5 is abelian.
07:26:24 <RedNifre_> @let say a = show a
07:26:27 <lambdabot>  Defined.
07:26:43 <RedNifre_> :t say
07:26:45 <lambdabot> Show a => a -> String
07:27:38 <sivteck> > say 1337
07:27:41 <lambdabot>  "1337"
07:28:06 <simon_> > let wat = "wat " ++ wat in wat
07:28:08 <lambdabot>  "wat wat wat wat wat wat wat wat wat wat wat wat wat wat wat wat wat wat wat...
07:28:41 <michi7x7> @pl \f -> length . filter f
07:28:41 <lambdabot> (length .) . filter
07:29:02 <michi7x7> aaahhh... how obvious
07:29:31 <simon_> I think I preferred the original, michi7x7.
07:29:37 <michi7x7> msm
07:29:39 <simon_> thanks, mr-. I'll have to read more on that. :)
07:29:41 <michi7x7> mhm
07:32:36 <RedNifre_> What's the best way to remove unused imports?
07:33:33 * hackagebot api-builder 0.2.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.2.0.0 (Intolerable)
07:33:55 <RedNifre_> oh, thank you!
07:34:30 <michi7x7> RedNifre_: http://stackoverflow.com/questions/6756477/scripts-to-automatically-manage-imports-or-refactor-modules
07:35:38 <Haskellfant> can parsec be used like regex similar to how people use grep? i.e. I want to be able to find a certain part in a string. it seems difficult to me to do this in parsec, because there's no match function that finds a part in a string so you would need to find out yourself when to match?
07:36:34 <michi7x7> Haskellfant: parsec is a ll-parser, regex is different
07:36:48 <Haskellfant> michi7x7: ok, so it's not just me missing something :)
07:36:56 <michi7x7> there are a few regex libs though
07:37:05 <Haskellfant> yeah ofc
07:37:10 <Haskellfant> I've used those in the past
07:37:37 <michi7x7> Haskellfant: LL-parsers are used for lexing, usually
07:37:55 <Haskellfant> yeah that's what I've used them for so far aswell
07:38:18 <Haskellfant> I was just wondering if you can replace typical regex usecases with them as well
07:39:03 <michi7x7> Haskellfant: Regex does a lot of backtracking, parsers usually do not
07:41:26 <RedNifre_> thanks michi7x7
07:41:58 <lillian> michi7x7: what's the story behind your name?
07:43:00 <RedNifre_> Wait... so, nobody triggered hackagebot?
07:43:15 <michi7x7> lillian: I adopted it at the age of 15 or so, my first name is michael
07:43:20 <RedNifre_> It JUST so happens that the moment I need a json rest client library, somebody uploads one to hackage? http://hackage.haskell.org/package/api-builder-0.2.0.0
07:43:36 <RedNifre_> So even the library repository is lazy? :D
07:43:41 <RedNifre_> Love it :)
07:44:01 <lillian> michi7x7: what's the 7x7 about?
07:44:48 <michi7x7> a part of my last name in german, a bit obstructed because others were already used
07:45:01 <lillian> ha okay
08:01:54 <Johanna23>  There is no such thing as Free Porn http://bit.do/my_videos69
08:08:06 --- mode: ChanServ set +o mauke
08:08:06 --- mode: mauke set +b *23!~*21@*$#haskell-ops
08:10:06 --- mode: mauke set -o mauke
08:11:01 <michi7x7> what is the easiest way to evaluate list monads in parallel?
08:11:16 * mauke stares at "evaluate list monads"
08:12:04 <pantsman> you know, like evaluating maybe monads and IO monads
08:12:12 <pantsman> ;)
08:13:25 <pantsman> michi7x7: what are you trying to achieve? some parallel computation in general?
08:13:59 <mmmm_> michi7x7: maybe you want to use applicatives instead?
08:15:23 <michi7x7> pantsman: i have this really primitive implementation of the N-queens problem and was trying to find out how multithreading helps in the computation
08:16:38 <pantsman> michi7x7: ah :) I highly recommend http://chimera.labs.oreilly.com/books/1230000000929/pt01.html
08:18:20 <michi7x7> pantsman: thanks, i'll have a look at this ^^
08:18:47 <pantsman> well, provided your algorithm is parallelisable, that is!
08:19:28 <pantsman> I'm not really familiar with the problem, but I see there are even academic papers about parallelising it...
08:20:23 <pantsman> in the general case, you can't parallelise a monadic list computation; as mmmm_ suggested, you might start with formulating it using applicatives
08:27:40 <yukko> is there a way to make a list of existentially-typed values without using a wrapper type? ie list :: [forall a. T a => a]
08:28:32 <michi7x7> pantsman: it's a typical list monad "try all, guard most away" sort of thing
08:33:20 <Haskellfant> which encoding does OverloadedStrings use for ByteStrings? it seems to be a different one than wreq uses
08:35:31 <twopoint718> Anyone have experince using Spock for web development?
08:35:58 <Haskellfant> to be more precise for "für" wreq returns "f\195\188r" and overloadedStrings returns "f\252r"
08:38:15 <Haskellfant> encodeUtf8 from Data.Text.Encoding also returns "f\195\188r" so I guess overloadedstring syntax is not using utf8
08:39:40 <ClaudiusMaximus> > ord 'ü' `mod` 256
08:39:42 <lambdabot>  252
08:40:03 <ClaudiusMaximus> Haskellfant: it probably just truncates to Word8 without any particular encoding (ie, it's evil)
08:40:14 <rohitvarkey> #
08:40:23 <Haskellfant> ClaudiusMaximus: ok, I'll use text and encodeutf8 then to get what I Want
08:40:47 <Haskellfant> looking at the source code I think that's exactly what's happening
09:13:44 * hackagebot som 7.3.0 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.3.0 (AmyDeBuitleir)
09:20:12 <shapr> @quote johnw
09:20:12 <lambdabot> johnw says: Haskell is like using a finely crafted blade to whittle yourself a canoe, as your friends pass by on their cruise liner and wonder what you're up to
09:20:18 * shapr cackles cheerfully
09:21:14 <wayne> you're supposed to craft more and more specialized blades using your first blade until a canoe comes up in one fell swoop
09:22:18 <josephle> either that or you start with a skeleton of a canoe and then fill it out with finely crafted blades
09:22:31 <edwardk> shapr: yeah but it is a nuclear powered canoe
09:22:44 <shapr> @quote edwardk
09:22:44 <lambdabot> edwardk says: f -| g   means that   f a -> b is isomorphic to  a -> g b (for arrows in the appropriate categories)
09:22:48 * shapr runs away
09:23:58 <shapr> edwardk: I realized that a monad being a monoid in the category of endofunctors makes perfect sense, but every time I try to explain it to people they get confused :-(
09:24:32 <edwardk> shapr: you need the notion of a 'monoidal category' first to get through to where monads are monoids in the category of endofunctors
09:24:55 <edwardk> once you have a notion of a tensor for a monoidal category then you can easily show how monads are the monoids of functor composition
09:25:49 <chaosmasttter> hi, is has anyone here some experiences with Control.Zipper?
09:26:16 <merijn> edwardk: "the monoids"?
09:26:48 <augur> "The Monoids" would be a great name for a band
09:26:53 <merijn> augur++
09:27:18 <merijn> I was trying to convince my colleagues that commutative monoids are amazing, but they don't believe me :(
09:27:54 <augur> commutative monoids, aka multisets!
09:27:55 <shapr> tensors make me tense
09:29:22 <merijn> chaosmasttter: Your probably better off just asking your question
09:30:37 <RedNifre_> > zip [1,2,3] ['a','b','c']
09:30:40 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
09:30:56 <RedNifre_> That's not how a zipper works! ',:-/
09:31:08 <jimmy99> I'm trying to install leksah on fedora and cabal fails with permission error when installing webkitgtk
09:31:10 <vanila> lol
09:31:30 <vanila> what result would you have liked?
09:31:54 <RedNifre_> a zipper would do [1,'a',2,'b',3,'c']
09:32:04 <chaosmasttter> Well Control.Zipper has the focus lens, but there doesn't seems to be a traversal of all non-focused elements. Is there a easy way to get such a thing?
09:32:07 <augur> RedNifre_: pretend you cant see parens
09:32:31 <monochrom> @webster amazing
09:32:31 <lambdabot> Unknown command, try @list
09:32:42 <RedNifre_> also, you can't zip two halfs of incompatible jackets in real life, if the type of the zipper doesn't match ;)
09:33:14 <augur> i think that function is interleave?
09:33:17 <augur> :t interleave
09:33:22 <vanila> RedNifre_, I thought it would be this:
09:33:23 <lambdabot> Not in scope: ‘interleave’
09:33:27 <augur> :t interpolate
09:33:31 <lambdabot>     Not in scope: ‘interpolate’
09:33:32 <augur> hm
09:33:35 <lambdabot>     Perhaps you meant one of these:
09:33:36 <vanila> > let zip x y = x ++ reverse y in  zip [1,2,3] ['a','b','c']
09:33:39 <lambdabot>       ‘BSC.intercalate’ (imported from Data.ByteString.Char8),
09:33:41 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
09:33:45 <lambdabot>    arising from the literal ‘1’
09:33:53 <indiagreen> :t intercalate
09:33:55 <lambdabot> [a] -> [[a]] -> [a]
09:33:57 <indiagreen> :t intersperse
09:33:58 <lambdabot> a -> [a] -> [a]
09:34:03 <vanila> > let zip x y = x ++ reverse y in  zip [1,2,3] ['a','b','c']
09:34:06 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
09:34:06 <lambdabot>    arising from the literal ‘1’
09:34:11 <vanila> oh
09:34:32 <RedNifre_> obviously, you can't zip up two halfs of incompatible jackets ;)
09:34:45 <vanila> hehe
09:36:33 <m_> @pl
09:36:33 <lambdabot> (line 1, column 1):
09:36:33 <lambdabot> unexpected end of input
09:36:33 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:37:41 <m_> @pl \x -> Set.fromList x
09:37:41 <lambdabot> Set.fromList
09:38:02 <augur> m_: you can ask lambdabot to do this in a /msg, just fyi
09:42:46 <RedNifre_> Hm, apparently I ran into my first cabal problem.
09:44:03 <RedNifre_> So I made a library which needs "text", but I don't care about the version. And I have a separate project, which uses a library from hackage which needs a particular version of text. But it seems that if I simply install my own library first it picks the wrong text version.
09:44:48 <RedNifre_> I guess the mistake is that I shouldn't install my library on its own, instead it should only be build when needed by the other project, right?
09:45:04 <dcoutts_> right, or ask to install them both in one go
09:45:09 <RedNifre_> Is this what the "register with compiler" command is for? Or what should I do?
09:45:17 <RedNifre_> How to install both in one go?
09:45:23 <dcoutts_> cabal install a b
09:45:35 <RedNifre_> My own library isn't on hackage, is that a problem?
09:45:42 <merijn> RedNifre_: "ghc-pkg unregister your-library" -> reinstall with the library you want to use
09:45:59 <dcoutts_> RedNifre_: no that's not a problem
09:46:08 <dcoutts_> RedNifre_: e.g. cabal install ./this  text
09:46:46 <RedNifre_> hm, okay.
09:47:46 <RedNifre_> do you mean cabal install /some/thing.cabal /some/other/stuff.cabal ?
09:49:38 <dcoutts_> RedNifre_: you can use either the dir or the .cabal file
09:53:48 * hackagebot som 7.3.1 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.3.1 (AmyDeBuitleir)
09:56:46 <RedNifre_> Hm, I guess I should use cabal sandboxes...
09:56:54 <Haskellfant> is there a lens operator like ^. that accepts something inside a functor to simplify doing fmap (^. _4) ?
10:05:47 <shapr> Anyone doing embedded + Haskell dev? I created #haskell-embedded, but it's just me and chirpsalot  :-)
10:06:32 <chaosmasttter> haskellfant: i believe you could use ^.mapped._4
10:06:43 <RedNifre_> What's the definition of embedded exactly
10:06:47 <RedNifre_> ?
10:07:31 <Haskellfant> chaosmasttter: hm doesn't seem to work
10:08:00 <shapr> The advertising will continue until #haskell-embedded activity improves :-P
10:08:14 <chirpsalot> RedNifre_: "smaller than a laptop and not an iPhone" :P
10:14:10 <Denommus> I'm trying to build gtk3-0.13.0.2
10:14:37 <Denommus> but I'm getting an error I have no idea how to solve. Probably because I don't know enough about FFI
10:16:30 <Denommus> oh, I did a hack
10:34:58 <qq> hey guys, I'm playing around with expressions.  Why does " (flip . const map) x y z " work but "(flip . const map x ) y z" doesn't? New to haskell, please be patient.
10:35:52 <jle`> qq: what do you mean by "work" ?
10:36:21 <jle`> it looks like they both parse fine to me..
10:36:33 <mauke> they just happen to mean completely different things
10:36:45 <josephle> :t \x y z -> (flip . const map x) y z
10:36:47 <lambdabot>     Couldn't match type ‘[b2]’ with ‘b -> c’
10:36:47 <lambdabot>     Expected type: (a -> b2) -> [a] -> b -> c
10:36:47 <lambdabot>       Actual type: (a -> b2) -> [a] -> [b2]
10:36:54 <josephle> certainly the second one doesn't typecheck
10:37:17 <qq> Yeah, the types don't match, but I don't understand why.
10:37:38 <jle`> :t const map
10:37:39 <lambdabot> b -> (a -> b1) -> [a] -> [b1]
10:37:48 <mauke> const map x is map
10:38:01 <jle`> :t map
10:38:02 <lambdabot> (a -> b) -> [a] -> [b]
10:38:07 <mauke> (flip . map) y is flip (map y)
10:38:19 <mauke> map y :: [a] -> [b]
10:38:26 <mauke> flip requires a function of two arguments, not one
10:38:57 <chirpsalot> :t const
10:38:58 <lambdabot> a -> b -> a
10:40:44 <jle`> @. djinn type maybe
10:40:45 <lambdabot> f a b c =
10:40:45 <lambdabot>     case c of
10:40:45 <lambdabot>     Nothing -> a
10:40:45 <lambdabot>     Just d -> b d
10:40:56 <jle`> who needs @src
10:41:08 <jle`> @src maybe
10:41:08 <lambdabot> maybe n _ Nothing  = n
10:41:08 <lambdabot> maybe _ f (Just x) = f x
10:41:26 <mauke> who needs djinn? oleg did it using typeclasses :-)
10:41:54 <qq> Shouldn't moving x inside the parentheses simply apply it to const? that is - (flip . const map x) y z = (flip . map ) y z ?
10:42:17 <mauke> yes, I believe that's what I said
10:42:27 <RedNifre_> Hm. Do I ever need to use cabal install at all? Or could I just build my project and tell it where my local libraries are?
10:43:11 <monochrom> one day, there will be a program to do type-level programming just like djinn now does value-level programming. we will call the new program "oleg".
10:46:18 <Denommus> what's the name of the typesafe HTML for Haskell, again?
10:46:49 <cite-reader> Denommus: Hamlet?
10:47:02 <qq> but when I do this:  (flip . const map ) x y z, shouldn't it be the same thing as applying x to "const map". I don't see where the problem is.
10:47:22 <mauke> (flip . const map) x is flip (const map x)
10:47:25 <mauke> const map x is map
10:47:35 <mauke> so we get flip map y z, which is map z y
10:48:14 <qq> "let f x y z = (flip . const map) x y z"
10:48:19 <qq> this parses
10:48:33 <qq> "let f x y z = (flip . const map x ) y z" this doesn't. (in ghci)
10:48:41 <mauke> yes, and I just explained why
10:48:58 <monochrom> (flip . const map x ) y z is not the same as (flip . const map) x y z
10:49:02 <merijn> RedNifre_: If you never use any other library, you don't need cabal it all, no. (Actually, you never *need* cabal)
10:49:23 <mauke> (f . g) x is not the same as (f . g x)
10:49:25 <merijn> RedNifre_: But cabal is rather effective at building libraries, so you probably *should* use it
10:53:00 <jTT_> hi, i am having a weird issue with cabal and was wondering if anyone could help: I get the following error when trying to install some packages:”xml-types-0.3.4 failed during the configure step. The exception was: user error (The package 'xml-types' requires Cabal library version >=1.19.2 && >=1.6 but no suitable version is installed.)”.  Yet, “cabal --version” shows: “cabal-install version 1.20.0.3 using version 1.20.0.2 of the Ca
10:53:00 <jTT_> library”.  But: “cabal install cabal” says: “All the requested packages are already installed: Cabal-1.18.1.4” Has anyone got a clue as to what this means? I suspect that perhaps homebrew installed some old version of cabal?
10:53:41 <Denommus> cite-reader: I think that's the one, yes
10:54:19 <jTT_> addendum: I tried brew unlink cabal; brew link cabal; to no avail
10:54:34 <RlyDontKnow> jTT_: try to run cabal update to ensure the package list is fine?
10:54:37 <johnw> shapr: that's really an old quote
10:54:51 <jTT_> RlyDontKnow: did :(
10:56:29 <qq> Why? (f . g) x should be the same thing as f ( g (x) ), which seems to be what happens in (f . g x).
10:57:17 <mauke> f (g x) is not the same as f . (g x)
10:57:32 <qq> (f . g x ) the g x part is not a function anymore, but it's value that can be 'plugged into' f.
10:57:45 <mauke> of course it is a function
10:57:49 <mauke> (.) demands it
10:58:09 <mauke> f . g x is \y -> f (g x y)
10:58:13 <mauke> by the definition of (.)
10:58:16 <kvitebjorn> .  Is compositional
10:58:19 <kvitebjorn> Ja
10:58:56 * hackagebot xdot 0.2.4.5 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.5 (DennisFelsing)
11:03:24 <monochrom> f . g x is not f (g x)
11:05:01 <monochrom> one way to see that is finding a counterexample: choose something for f, g, x such that f . g x is a type error and f (g x) is not
11:06:57 <qq> huh. I think I just got it. I'm gonna write out an explanation to see if I'm lost or maybe progressing...
11:08:01 <qq> monochrom: well if g only accepts one argument, it should/may fail in f . g x ?
11:08:49 <monochrom> that's one way. "not . not True" is a type error. "not (not True)" is just fine.
11:15:57 <PMode> Hi, I got pointed via a Debconf talk to hopenpgp-tools. I am trying to run hokey -lint from hopenpgp-tools from Debian Jessie/Testing 0.11.1 and also installed with cabal as 0.13 but it does not seem to output anything.
11:17:17 <pikitg238> Why for i can use haskell ?, i want to learn Haskell, i heard really good things about the fp but i don't see the real cases...
11:17:53 <saati_> how can i create a toplevel STMContainers.Map?
11:18:57 * hackagebot tidal 0.4.15 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.15 (AlexMcLean)
11:20:03 <koala_man> pikitg238: that's known as "the blub paradox". you never think you need a more powerful language until you know the language. afterwards, you can't imagine how you lived without it.
11:20:38 <PMode> Ah, got it. One needs to pipe into hokey
11:20:46 <shapr> pikitg238: mutation is an explicit garbage collection decision
11:21:31 <pikitg238> yes that's happen me when I meet Ruby, but i don't see the uses cases for use Haskell, for sample I trying to learn some about Yesod ... but it's really hard in comparison with Rails for sample..
11:22:17 <zomg> pikitg238: it's because you're already familiar with how languages similar to Ruby work. Haskell works completely differently in many aspects, thus you're having more trouble learning it
11:22:22 <stepcut> pikitg238: There are many Haskeller's who feel that Yesod is a bit of an odd duck..
11:22:26 <pikitg238> My question is the uses cases are similar to the Imperative Langs ? or just have another uses cases ?
11:22:28 <zomg> That was the case with me anyway
11:22:44 <Cale> pikitg238: Similar use cases. You can really use Haskell for most things
11:22:46 <zomg> For me, I use Haskell for web apps and such, and I can certainly feel more productive working with Haskell
11:23:03 <zomg> and I enjoy working with it more than with other langs (I have a long long background in imperative langs before haskell)
11:23:27 <pikitg238> Oh i see
11:23:31 <Cale> pikitg238: I've run into at least one beginner who had relatively good experiences with Yesod, but personally, I'm a little skeptical about how reasonable it is for beginners to approach.
11:23:56 <stepcut> Cale: I'm a little skeptical about how reasonable it is.
11:24:07 <zomg> I picked up Yesod as a somewhat of a beginner
11:24:11 <Cale> stepcut: hehe, yeah :)
11:24:20 <zomg> Certainly had trouble with it, mostly with the completely crazy error messages it gave me
11:24:32 <zomg> but other than that it was quite smooth sailing as long as I got some help figuring out the problems =)
11:24:40 <jle`> edwardk: are you mtl?
11:24:52 <jle`> edwardk: or is your name on it for like administrative purposes or something
11:25:05 <johnw> he's the mtl guy
11:25:40 <pikitg238> For example i have a question about the performances issues, i can use RoRails in the frontend of some web app, and use Haskell in the background for processing data or things like that, have protocols for implement Soap or services like Rest ?
11:26:12 <Cale> Isn't RoR specifically for the *backend* of web applications?
11:26:28 <pikitg238> So so, not if you use SOA arch
11:26:31 <Cale> There isn't a Ruby -> Javascript compiler yet is there?
11:26:34 <jle`> lol
11:26:41 <jle`> such a thing would probably be an interpreter
11:26:43 <exio4> I like to "see" think different programming languages as two different human langs with different roots (λ-calculus? von neumann arch? :P
11:26:49 <jle`> and...sounds completely gruesome
11:26:50 <pikitg238> Hey dudes, i'm just want to know :p
11:26:53 <exio4> ehm, add the missing )
11:27:17 <Cale> pikitg238: For sure if you want to do some things in Haskell and some in Ruby, there will be ways to hook them up
11:27:21 <jle`> exio4: but with cross-fertilization, right?
11:27:29 <edwardk> jle`: i am nowadays
11:27:36 <Cale> pikitg238: I'm just nitpicking about the definition of backend vs. frontend :P
11:27:38 <jle`> i mean, facebook integrates haskell & php together...if that can be done, anything can be done
11:27:41 <edwardk> jle`: Andy GIll wrote it, Ross maintained it for a while, now I do
11:27:47 <edwardk> jle`: What can I do for you?
11:27:58 <jle`> edwardk: ah.  are you responsible for the main architectur/design decisions?
11:28:00 <jle`> oh, i was just wondering.
11:28:16 <jle`> i saw another package with your name on it earlier and you said it was only because of basey boardey administrativey stuff
11:28:26 <edwardk> I don't get to change 'transformers', but from the mtl down, yes
11:28:43 <jle`> i probably meant to ask, were you originally involved in the decisions
11:28:49 <jle`> back in the day when they were deciding what mtl would be
11:28:53 <edwardk> I didn't design the mtl
11:29:08 <edwardk> that was Gill, later Ross overhauled it to get mtl 2
11:29:13 <jle`> sometimes i wonder what mtl/transformers would be like if we were to start it from scratch today
11:29:21 <jle`> i have some opinions.
11:29:43 <edwardk> the main thing i'd change is to bring back the simple definitions of State, etc. somewhere for teaching purposes
11:29:43 <vanila> There are even approaches that don't involve transfomer stacks
11:29:49 <edwardk> losing them was a _huge_ blow to pedagogy
11:29:59 <vanila> I agree very much with that edwardk, that bugs me
11:30:03 <edwardk> vanila: yes, though they don't subsume all the transformer use cases
11:30:34 <jle`> can't mtl introduce its own State type, and make the appropriate instances?
11:30:35 <merijn> edwardk: Althought the current type for State plays much nicer with, say, mmorph
11:30:59 <jle`> all it takes is some slightly more annoying manual instances for it to integrate w/ mmorph i think
11:31:03 <edwardk> vanila: extensible effects are problematic for many kinds of effects, Cont-like things and lazy writer/reader in particular
11:31:07 <Cale> pikitg238: How long have you been learning Haskell so far? Did you just jump directly into web application development?
11:31:09 <jle`> acutally, wait
11:31:09 <edwardk> merijn: i'm not saying replace the main State
11:31:11 <jle`> maybe not.
11:31:19 <merijn> I think a bigger issues is newbies using mtl with the MonadState, etc. hairiness it brings, rather than transformers directly
11:31:27 <edwardk> merijn: but having a monomorphic one around somewhere folks can learn from would be a good thing
11:31:37 <jle`> can't mtl offer a monomorphic state?
11:31:43 <jle`> on top of the transformers state?
11:32:01 <jle`> the main reason for transformers offering only StateT was so that its functions could work on both StateT and State
11:32:08 <jle`> but with mtl's typeclass approach, it's a moot point
11:32:18 <jle`> bye
11:32:48 <monochrom> mtl version 1 provided State independent of StateT
11:33:22 <Cale> pikitg238: It's certainly possible to go straight into doing something like that if you're sufficiently motivated. Personally, I found it took me a while to get used to the basics of the language, so at least when I did it, I started out just writing simple programs that had no real UI of any sort, just computing various things, and just interacted with them through ghci.
11:33:24 <jle`> wb
11:35:02 <edwardk> jle`: sorry, train, bad connectivity
11:35:02 <edwardk> anyways, i'm not seriously advocating for changing the one we have right now
11:35:03 <Cale> pikitg238: The overall approach Haskell has to I/O is nice, but it's also rather different from most other languages you might be familiar with, so can be good to have a solid understanding about how values and types and type classes work before getting to programs that do real stuff.
11:35:04 <edwardk> but it is an example of a thing i think was a bad decision in the mtl 2 move
11:35:10 <merijn> pikitg238: There are two schools of thought to learning haskell, each having their own drawback. 1) The read and study lots of stuff to understand the basics and 2) jump in and write real world code
11:35:32 <Cale> Yeah, both ways are viable, but some people will find it easier to cope with one or the other :)
11:35:35 <edwardk> it shaved half the code out of the mtl but it cost the concept of monad transformers a lot of users =)
11:35:41 <ReinH> edwardk: o/
11:35:49 <edwardk> heya ReinH
11:35:54 <merijn> pikitg238: The advantage of 1 is: You understand the basics and fundamentals and are less likely to be intimidated and confused, the disadvantage is you'll feel incredibly useless and unable to write "real" code for a long time which may be demotivating
11:36:13 <sam_wisw> Hello, I was wondering if someone could clear up the tild (`~`) operator for me..I know it has to do with lazy pattern matching, but it still lays beyond my comprehension
11:36:54 <merijn> pikitg238: The advantage of 2 is: You end up writing "real" code/systems sooner, yay! Productivity! Enthousiasm! The downside is, you'll run into many concepts that are unfamiliar and that you don't understand, you'll be confused and frustrated a lot.
11:36:59 <Cale> sam_wisw: A pattern of the form ~pat always matches without actually checking if pat matches until any of the variables bound in pat need to be evaluated.
11:37:04 <merijn> sam_wisw: It's not an operator, it's syntax
11:37:28 <Cale> sam_wisw: At that point, if pat doesn't really match, you get a runtime error.
11:37:36 <merijn> sam_wisw: Normally pattern matching forces evaluation to happen, ~ does not
11:37:44 <shiona> Cale: so it's like unsafeCoerce for pattern matching?
11:37:44 <monochrom> I used neither of the two schools of thought. I used the scientific method: read a tutorial, conjecture what the tutorial means, write experimental code to check the conjecture.
11:37:48 <beaky> hello
11:37:51 <merijn> pikitg238: Which approach works best for you, depends on you.
11:37:54 <Cale> shiona: heh, I suppose a little
11:37:58 <beaky> is there Show typeclass equivalent for Text
11:38:03 <Cale> shiona: It's not as unsafe as unsafeCoerce
11:38:04 <merijn> monochrom: I would consider that the first school of stuff
11:38:13 <merijn> monochrom: When I say "read" I don't mean "just read"
11:38:15 <shiona> oh
11:38:36 <Cale> shiona: It can't result in arbitrary code execution, for instance
11:38:45 <merijn> monochrom: People write code while reading LYAH too, but that's not code that's necessarily immediately useful in "the real world"
11:38:49 <sam_wisw> @Cale "until any of the variables bound in pat need to be evaluated"  could you give me an example?
11:38:49 <lambdabot> Unknown command, try @list
11:38:52 <shiona> true in that sense
11:38:58 <Cale> sam_wisw: sure...
11:39:06 <jle`> > case Nothing of (Just _) -> "hello"; Nothing -> "goodbye"
11:39:07 <lambdabot>  "goodbye"
11:39:11 <jle`> > case Nothing of ~(Just _) -> "hello"; Nothing -> "goodbye"
11:39:13 <lambdabot>  "hello"
11:39:19 <Cale> > case [] of ~(x:xs) -> 6
11:39:21 <lambdabot>  6
11:39:24 <Cale> > case [] of ~(x:xs) -> x
11:39:26 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
11:39:30 <merijn> monochrom: i.e. reimplementing State is coding, but not something most people would consider "real" code
11:39:42 <monochrom> on dive-in projects, I use this analogy: if you already know American English and you're learning British English, you can reasonably say, "let me do the dive-in project of watching a British movie and writing a movie review in British English". but if you're learning Japanese, that is going to fall flat on its face.
11:39:51 <jle`> > case (error "hey") of (Just _) -> "hello"; Nothing -> "goodbye"
11:39:52 <lambdabot>  "*Exception: hey
11:40:01 <Cale> > case filter even [1,3,5,7,9] of ~(x:xs) -> 6
11:40:03 <lambdabot>  6
11:40:16 <jle`> > case (error "hey") of ~(Just _) -> "hello"; Nothing -> "goodbye"
11:40:18 <lambdabot>  "hello"
11:40:18 <Cale> ^^ here, the filter even [1,3,5,7,9] wasn't even evaluated
11:40:22 <merijn> monochrom: I'm a firm believer that "diving in" isn't a very good approach, but several people have assured me it's worked for them, so I don't feel qualified to see "Never do that"
11:40:32 <pikitg238> merijn, oh i see, so you recommend me first understand the Function philosophy right ?, and later write real code.
11:40:44 <pikitg238> * Functional
11:40:53 <merijn> monochrom: Although I do recommend against it
11:40:55 <Cale> pikitg238: Something like that, it's less about philosophy and more just about the practical details of how the language works.
11:41:27 <pikitg238> Ok, the syntax it's really intimidating hahaha ....
11:41:33 <merijn> pikitg238: Getting a firm grip on types, typeclasses and laziness and exploring common "infrastructure" libraries like transformers, etc. before trying to write, say, a full web app
11:41:38 <monochrom> dive-in projects for learning Haskell is an elaborate, meta-level exercise of lazy evaluation.
11:41:50 <bitonic> dcoutts: is there a way to force the build log to be written to stdout, when doing `cabal install'?
11:41:55 <jle`> > case filter even (error "hey") of [] -> "hi"; _ -> "hii";
11:41:57 <lambdabot>  "*Exception: hey
11:42:03 <jle`> > case filter even (error "hey") of ~([]) -> "hi"; _ -> "hii";
11:42:05 <lambdabot>  "hi"
11:42:05 <jle`> ok i think i'm done
11:42:12 <pikitg238> merijn, ok dude thanks ;)
11:42:16 <beaky> what does putting ~ before pattern do
11:42:17 <pikitg238> Cale, thanks too
11:42:33 <Cale> pikitg238: Most imperative languages are pretty similar on a fundamental level, and most programmers get used to having an easy time picking up a new one, since they're mostly reskinnings of each other. Haskell isn't similar to them, so learning it can be a bit like learning programming from the beginning again, which some people will find frustrating.
11:43:00 <Cale> pikitg238: Of course, it's not just different for the sake of being different, there are real advantages to most or all of the things that Haskell does differently.
11:43:03 <jle`> yeah...one month in, they compare themselves to how good they are in other programming languages that they've known for years
11:43:11 <jle`> and it's frustrating
11:43:25 <jle`> but they forget that they are probably better off than they were after learning their first programming language originally for one month
11:43:34 <sam_wisw> em could someone explain tilde in reerence to this example https://github.com/timbod7/haskell-chart/wiki/example%201  ?
11:43:45 <merijn> pikitg238: Also, don't be intimidated, if you already know a programming language, you're probably used to "knowing most things" when learning a new one. Haskell is so different, it might be best to pretend you've never programmed before and realise that you're learning something that's utterly unlike any other mainstream language
11:43:59 <Cale> sam_wisw: oh, that's not ~ as in patterns
11:44:06 <merijn> A sense of utter confusion at the start is normal :)
11:44:09 <capisce> https://twitter.com/michaelshermer/status/522517519920156674
11:44:11 <Cale> sam_wisw: that's an infix operator .~ which is being defined by some library
11:44:25 <Cale> Probably the Graphics.Rendering.Chart library
11:44:39 <jle`> > let x .~ y = show x ++ show y in 6 .~ True
11:44:41 <lambdabot>  "6True"
11:45:06 <Cale> oh, hah
11:45:11 <ReinH> pikitg238: I have some suggestions for Haskell reading material here fwiw http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
11:45:14 <jle`> when in doubt about api design decisions, just add in operators
11:45:22 <jle`> you can always use more operators!
11:45:24 <Cale> Graphics.Rendering.Chart re-exports Control.Lens
11:45:30 <ReinH> btw Thompson's book has a 2011 edition that is great. I need to update my list.
11:45:44 <Cale> So it's the .~ from lens
11:45:45 <ReinH> I think I'd recommend Hutton and Thompson's books at this point
11:45:58 <merijn> ReinH: How about Bird's?
11:46:01 <pikitg238> ReinH, thanks for the link
11:46:13 <jle`> do people recommend bird's for beginning haskell?
11:46:15 <merijn> I've heard Bird's book is good, but unlike LYAH it's not free
11:46:34 <ReinH> merijn: Bird's is one of the best FP books I've read, but it's less of an introduction to *Haskell* per se...
11:46:46 <merijn> ah
11:46:54 <sam_wisw> Cale: Damn ... so read up on lens then?
11:46:56 <Cale> sam_wisw: I have no idea why it chooses to do so, but lens defines infix operators for many of its basic operations, and .~ is an infix version of 'set'
11:47:09 <merijn> There is a wiki page explaining lens operators
11:47:33 <monochrom> @quote monochrom Bird
11:47:33 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the entire human race would have to be rewritten!
11:47:37 <ReinH> merijn: so it spends zero time on, e.g., Haskell libraries, performance, etc, but it's a wonderful way to learn the "functional way"
11:47:47 <monochrom> that is my recommendation :)
11:47:53 <ReinH> monochrom: heh
11:48:08 <ReinH> yeah, it's a pretty deep dive into FP, and it's one of my favorite books
11:48:15 <ReinH> But I don't recommend it as an intro to Haskell book :)
11:48:19 <sam_wisw> I guess to the wiki pageI guess . Thank you folks.
11:48:22 <beaky> http://hackage.haskell.org/package/lens-3.8.5/docs/Control-Lens-Operators.html#g:8
11:48:51 <ReinH> monochrom: have you read Bird's Algebra of Programming
11:48:54 <merijn> @quote monochrom chapter
11:48:55 <lambdabot> monochrom says: In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10 XML processing using arrows.  The difference in productivity is incredible
11:48:56 <ReinH> that was actually a question
11:48:58 <merijn> :D
11:49:02 <edwardk> Cale is the vocal minority opposed to the use of lens operators
11:49:10 <ReinH> monochrom: :)
11:49:11 <monochrom> Bird's book actually talks about the foldl (+) laziness problem and how to solve it with seq, long before anyone on IRC asked, and to date I think no other Haskell book talks about it.
11:49:12 <edwardk> we created a Control.Lens.Combinators just for him
11:49:16 <Cale> :D
11:49:25 <edwardk> he can import that and never see an operator
11:49:30 <jle`> :D
11:49:35 <monochrom> certainly no other Haskell books talked about it in 5-10 years after Bird's book
11:50:10 <Cale> I just think set _1 "hello" (42,"world") is straightforward enough that we shouldn't have to put up with (42,"world") & _1 .~ "hello"
11:50:14 <monochrom> I have only read the first 3 chapters of Algebra of Programming.
11:50:49 <monochrom> anyway Bird's Haskell book was ahead of its time. it answered all IRC questions 5 years before they were asked.
11:51:42 <ReinH> monochrom: :)
11:51:42 <matt2> i'm trying to get the indexes of the top two values in a list
11:51:47 <monochrom> about foldl (+), about monads, about monad trasnformers
11:51:50 <ThreeOfEight> Sorry, what book is that you're talking about?
11:51:55 <matt2> i can get the values by folding
11:52:00 <Cale> So anyway
11:52:03 <ReinH> monochrom: Bird's book is really "Category Theory of Programming", but you might not have gotten that far ;)
11:52:05 <Cale> oh, he left
11:52:15 <matt2> but how can i get the indexes themselves? Here is my fold function: https://gist.github.com/mr/a7346c9ea24d3d1474f8
11:52:31 <monochrom> Bird's "introduction to functional programming using Haskell"
11:52:54 <Cale> matt2: zip [0..] xs
11:53:14 <monochrom> this November, his new book "thinking functionally with Haskell" is coming out. I will have to see what it does.
11:53:37 <Cale> matt2: If you want to operate on the indices of elements in a list, it's often useful to pair those with the elements of the list ahead of time :)
11:53:49 <matt2> Cale: Oh I see
11:54:17 <matt2> Cale: that makes sense. Is that efficient (I'm acutally using vectors here)?
11:54:24 <pold87> Hi, I'm trying to read in a tab-delimited file using cassava (not sure if this is the best way, I'd be also open for other methods). However, I get problems if there are double-quotes in my TSV file (parse error - endOfInput) and don't know how to fix that. What's the workaround / a good way for parsing CSV/TSV files in Haskell (with "")?
11:54:48 <ReinH> > zip "hello" [0..] -- matt2
11:54:50 <lambdabot>  [('h',0),('e',1),('l',2),('l',3),('o',4)]
11:55:10 <Cale> matt2: I probably wouldn't worry *too* much about efficiency, unless perhaps the vectors were very large.
11:55:24 <Cale> matt2: Like, is this an image processing application?
11:55:37 <monochrom> ReinH, although much category theory is applied, calling it "algebra" is still better, because he doesn't chase diagrams, he rewrites expressions, think "highschool algebra" where you blindly use rewrite rules.
11:56:00 <jle`> this is as efficient as it gets for lists, i think.  optimal use case for lists, actually
11:56:10 <Cale> Yeah, for lists it's unquestionably okay
11:56:19 <jle`> one of the things that lists were arguably designed for in the first place
11:56:29 <matt2> Cale: no it's an SAT solver, but the vectors shouldn't be nearly as large as an image
11:56:29 <jle`> but vectors, hm
11:56:48 <Cale> matt2: I'd just say go for it :)
11:56:51 * monochrom is fond of blindly using rewrite rules. do not think; calculate. thinking too much (rather, intuiting too much) is why people makes mistakes such as "f . g x = f (g x)"
11:57:18 <matt2> Cale: yeah it shouldn't be too bad, I was just wondering
11:57:21 <matt2> Cale: thanks
11:57:34 <ReinH> monochrom: Agreed, Bird has a much more algebraic approach to everything, including CT
11:58:03 <ReinH> monochrom: It's fun to read Bird on CT and Mac Lane/Birkhoff on Algebra at the same time
11:58:12 <ReinH> Two almost opposite approaches
11:58:13 <Cale> matt2: It's quite possible that the fusion that gets done on the vectors will mean that the intermediate vector of pairs isn't even physically created
11:58:29 <Cale> matt2: But I'd have to really think about it some more to say :)
11:59:10 <matt2> Cale: ok that's interesting, I'm pretty new to haskell, so it's tough for me to reason about efficiency
11:59:29 <ReinH> monochrom: My personal preference is for diagram chasing, but I see the value in Bird-style algebraic/equational reasoning for sure.
12:00:10 <Cale> matt2: Eventually you get pretty good at it just through experience, but there are certain libraries like vector and ByteString which have lots of rewrite rule optimisations in them that mess with your intuition and some things will perform much better than expected.
12:00:55 <matt2> Cale: is it actually possible to do V.fromList [0..], or should I be zipping some other way?
12:01:02 <ReinH> matt2: It can definitely be hard to reason about when fusion, etc, rules will fire when writing complex Vector stuff
12:01:44 <ReinH> You can always output core and see what is produced
12:01:56 <ReinH> And if you really care about efficiency, at some point you'll probably be looking at core anyway
12:02:42 <Cale> matt2: I suppose you could also use enumFromN 0 (V.length v)
12:03:04 <ReinH> matt2: Perhaps you want V.enumFromN 0 (V.length otherVector)
12:03:06 <Cale> ah, there's imap
12:03:09 <ReinH> grr
12:03:13 <ReinH> oh duh
12:03:19 <Cale> V.imap (\i x -> (i,x)) v
12:03:27 <spopejoy> Lens+aeson q: 'over' for JSON objects seems to only manipulate values. How can i manipulate keys?
12:04:05 <matt2> Cale: oh that looks exactly what I want to do
12:04:38 <edwardk> spopejoy: you can always use _Object or _Array to get at maps and vectors respectively with the keys intact
12:04:39 <spopejoy> ie, 'over members foo v' only gives the values to foo, not (key, value)
12:04:50 <spopejoy> oh ok
12:05:02 <edwardk> hrmm
12:05:06 <edwardk> :t Data.Aeson.Lens.members
12:05:08 <lambdabot> (Data.Aeson.Lens.AsValue t, Indexable Data.Text.Internal.Text p, Applicative f) => p aeson-0.7.0.3:Data.Aeson.Types.Internal.Value (f aeson-0.7.0.3:Data.Aeson.Types.Internal.Value) -> t -> f t
12:05:13 <monochrom> ReinH: when I read or use a theorem, I draw the diagram to visualize the network of things it talks about. when I prove a theorem, I calculate with the formula.
12:05:18 <edwardk> wait
12:05:21 <edwardk> that is indexed
12:05:24 <edwardk> try 'iover'
12:05:39 * shapr yawns
12:05:49 <shapr> so tired, must Haskell
12:06:13 <shiona> I was considerin refactoring my board game code so I could write a reasonable AI for it (like having a tree structure of game states). Then I came to realize that due to the lazy nature, I could actually just 'create the complete game tree' and traverse it according to player moves and a few levels in AI code. Is this reasonable?
12:06:27 <spopejoy> edwardk: doesn't compile
12:06:56 <spopejoy> ie, 'iover members id v'
12:07:47 <monochrom> yes, shiona. but you have to really understand lazy evaluation to get it right.
12:07:50 <spopejoy> oh wait, need a two arg fun
12:08:30 <shiona> monochrom: ok. I might have not gotten it so I guess I'll forget that idea for now then
12:09:14 <vanila> shiona, it's a good idea
12:10:07 <spopejoy> edwardk: iover still only operates on the value, when i actually want to re-key. I'll investigate _Object
12:10:34 <monochrom> two tests to see how much you understand lazy evaluation: test 1: why does "foldr (+) x xs" use linear space, "foldr (||) b (True : bs)" use constant space. test 2: explain http://lpaste.net/41790/
12:11:10 <shiona> I'll copy & paste that to my editor and give it a thought, this channel is moving too fast
12:12:36 <beaky> is where clause nestable
12:13:34 <shiona> monochrom: 1. (+) is strict on both its arguments, so it has no choice but to traverse the whole xs. (||) is non-strict on the right hand side (since left was True), so any elements of bs will never be forced
12:14:35 <shiona> ok, the second one is likely too hard for me, since I have hard time with just State
12:18:43 <monochrom> shiona: that's right
12:18:56 <shiona> ah, I think I got it. The result of {eval,exec}State is forced only to WHNF for lazy state
12:19:23 <monochrom> no, it is not that easy
12:19:23 <shiona> kinda depends on the use of many
12:19:28 <shiona> oh
12:19:32 <shiona> ok
12:19:39 <monochrom> just use "take 1 many"
12:20:57 <edwardk> spopejoy: oh you want to _change_ keys, then you don't have a traversal ;)
12:21:08 <edwardk> spopejoy: nothing ensures the uniqueness of your keys
12:21:15 <edwardk> that there is the problem
12:23:08 <mjo> Since there's no better place to ask: can anyone quote me a result? Suppose A <= B <= C are groups, and an explicit isomorphism between A and C is known. Can we use it to construct an isomorphism between B and either A or C? Can we at least claim one exists?
12:23:48 <shiona> monochrom: For the second piece of code it would make sens that for lazy state the (in this case recursive) lazy state call is saved as a thunk. The first one is actually harder for me to reason about
12:24:12 <exio4> @hoogle (Traversable t, Monoid a) => t a → a
12:24:13 <lambdabot> Parse error:
12:24:13 <lambdabot>   (Traversable t, Monoid a) => t a → a
12:24:13 <lambdabot>                                     ^
12:24:17 <joshc> mjo: there is ##categorytheory, if that helps.
12:24:24 <monochrom> here is test 1.5: define "xs :: [Int]; xs = iterate (+ 1) 0". I choose Int to help get constant space per number. "print xs" takes constant space. "print (xs !! n)" takes linear space.
12:24:37 <exio4> @hoogle (Traversable t, Monoid a) => t a -> a
12:24:40 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
12:24:40 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
12:24:40 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
12:25:04 <mjo> joshc: thanks, I'll try there too
12:25:38 <spopejoy> edwardk: makes sense at the traversal level. i wonder if i could define a "keyed re-keyer" a la 'key' to ix to that key only and rename it
12:25:55 <shiona> Ok, I understand nothing
12:26:18 <ReinH> monochrom: makes sense :)
12:28:59 <merijn> monochrom: But only if xs is a named thing like here, rather than an inline expression, no?
12:29:16 <monochrom> named or inlined
12:29:45 <merijn> monochrom: If it was inlined it could GC the list on the fly as !! traverses it, no?
12:29:52 <monochrom> in fact inlined is better, for fear of something else accessing that name therefore holding onto it
12:30:06 <monochrom> the list is not the problem
12:30:20 * merijn goes of to read the !! source
12:30:24 <monochrom> to see why, try saying the same to foldl (+) 0
12:31:48 <merijn> monochrom: That doesn't seem right
12:31:54 <merijn> Which thunk is building up?
12:32:05 <monochrom> 0+1+1+1+1+1+1+1+1
12:32:13 <merijn> Yes, for foldl
12:32:14 <merijn> SUre
12:32:17 <merijn> That's obvious
12:32:20 <merijn> I'm talking about !!
12:32:33 <monochrom> xs!!3 = 0+1+1+1
12:32:49 <merijn> In what way?
12:33:07 <shiona> ahh
12:33:09 <merijn> !! is strict on it's index argument
12:33:41 <shiona> Now I see it
12:33:49 <merijn> Because it tests for zero, so the - wouldn't build up and the list destruction shouldn't build up either?
12:34:20 <monochrom> ok, I have confused you with 3 being both index and answer. use instead (iterate (+ 2) 0) !! 3.
12:34:31 <merijn> oh
12:34:32 <circ-user-v1m75> what is Fx in https://www.fpcomplete.com/user/bartosz/understanding-algebras?
12:34:37 <monochrom> the thunk build is 0+2+2+2 and has nothing to do with the index.
12:34:52 <merijn> monochrom: The confusion is that I misunderstood the leak to be from !!, rather than iterate
12:34:57 <Guest3151> Hey I'm getting  unrecognised command: sandbox when I do `cabal sandbox init`, I've cabal-install 0.14 using 1.14.0
12:35:00 <Guest3151> any ideas?
12:35:10 <merijn> Yeah, iterate leaks in an obvious way
12:35:19 <merijn> Guest3151: That's because 1.14 is *ancient*
12:35:32 <Guest3151> how do I update it on ubuntu?
12:35:32 <monochrom> the fun part is why "print xs" takes constant space
12:35:36 <Guest3151> is there a PPA?
12:35:47 <merijn> Guest3151: Yes, but I dunno how all that stuff works
12:36:00 <merijn> hvr has a ppa, but don't ask me what a ppa is or how you use it :)
12:36:01 <monochrom> well, the fun part is coming up one coherent theory to fit both observations.
12:36:01 <sivteck> Guest3
12:36:33 <sivteck> Guest3151, https://github.com/bitemyapp/learnhaskell#ubuntu
12:36:36 <monochrom> the same beauty as how one coherent Newton's gravity theory fits both "the apple falls but the moon stays up"
12:36:37 <merijn> monochrom: That bit I get, I was just put on a false trail by the applications of !! :)
12:36:46 <monochrom> ok good
12:36:59 <merijn> Or rather
12:37:01 <lb5tr>  Module `Util.Misc' does not export `debug'
12:37:15 <lb5tr> i can see it in one of packages while building
12:37:23 <merijn> I kinda glossed over the iterate in xs and was like "ok, list of Int, not important" and only considered the other expressions ;)
12:37:26 <lb5tr> why does peapole use unexported functions?
12:37:33 <lb5tr> how can I forceibly export them?
12:37:37 <merijn> lb5tr: You can't
12:37:56 <monochrom> I craft evil examples :)
12:37:56 <lb5tr> i don't get it, the guy who wrote that had to build it at some point
12:37:58 <merijn> lb5tr: And "why?", the same reason OO has private members/methods
12:38:11 <lb5tr> merijn: sure, I'm get the purpouse
12:38:19 <lb5tr> but
12:38:27 <lb5tr> it worked for that guy
12:38:39 <lb5tr> https://github.com/albertoruiz/easyVision/blob/reorg/projects/tour/batch2.hs
12:38:44 <monochrom> lb5tr, perhaps an older or newer version exports it
12:38:47 <lb5tr> and for me it's failing during the build
12:38:59 <shiona> monochrom: you wouldn't happen to have any source for these problems
12:39:02 <lb5tr> 7.6.3 doesen't, neither the 7.8.0
12:39:38 <monochrom> no shiona, I effectively collected them over the years on questions asked here
12:39:55 <shiona> ok, well thanks for sharing those few.
12:40:01 <monochrom> well, except the State.Lazy vs State.Strict one, it was my own curiousity
12:40:21 <shiona> I feel you've blown my mind with such a simple and beautiful example
12:40:35 <JagaJaga> Hi! What am I doing wrong. Trying to netcat the 7777 port and get nothing. http://pastebin.com/yvgsiezE
12:40:38 <shiona> that one I'll try to figure out later
12:40:41 <monochrom> :)
12:42:13 <shiona> I think just this week we were talking about the problem of reasoning about efficiency in functional programming. I knew rewrite rules had some strange properties, but to find them in examples as simple as these
12:42:43 <shiona> I think I'll share them next time we have our coffee break posse talk on the subject
12:43:02 <merijn> JagaJaga: I have a supicion, because I had this issue earlier
12:43:14 <JagaJaga> If I do ` getAddrInfo Nothing (Just "") (Just $ show port)` instead of `getAddrInfo Nothing (Just "255.255.255.255") (Just $ show port)` I'm getting `program_name: getAddrInfo: does not exist (Name or service not known)`
12:43:45 <merijn> JagaJaga: Oh!
12:43:52 <merijn> JagaJaga: Debian?
12:44:01 <JagaJaga> merijn: NixOS...
12:44:22 <merijn> Someone earlier had trouble on debian because his /etc/protocol was borken
12:45:23 <JagaJaga> merijn: So what is a solution?
12:45:26 <merijn> I have a meeting, but your use of "show port" is wrong
12:45:31 <merijn> Most likely
12:45:37 <merijn> Port numbers are never String
12:46:16 <merijn> So it's probably trying to use /etc/services to lookup a String there
12:46:36 <JagaJaga> merijn: type ServiceName = String
12:46:56 <Guest3151> how do i build haskell from source, the source has a platform.sh file and its not really a big help tbh
12:47:31 <sivteck> Guest3151, did you consider that ppa?
12:48:09 <monochrom> must you build from source?
12:48:29 <Guest3151> sivoais, ppa contains the same version
12:48:52 <Guest3151> monochrom, why not?
12:49:33 <JagaJaga> merijn: so it seems to be my distro problem, not my haskell programm?
12:49:56 <monochrom> because http://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux exists, and also https://www.haskell.org/platform/linux.html#binary
12:50:58 <Guest3151> monochrom, installing haskell platform, not just ghc
12:51:10 <monochrom> so use the second one
12:51:26 <monochrom> I personally use it myself
12:51:27 <Guest3151> the binary isn't system-wide
12:51:43 <Guest3151> I want it to go in /usr/local/bin
12:52:26 <monochrom> it goes in /usr/local/haskell/ghc-7.8.3-x86-64, and it sets up symlinks in /usr/local/bin
12:52:51 <monochrom> (in fact, hell, I had to do extra work to prevent the symlinks, I don't want them)
12:53:25 <zmbmartin> How can I lift Maybe a -> Either (Maybe T.Text) a
12:53:30 <Guest3151> monochrom, the tar binary you're talking about?
12:53:36 <monochrom> yes
12:54:08 * hackagebot list-t 0.2.4 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.4 (NikitaVolkov)
12:54:09 <Cale> :t maybe (Left Nothing) Right
12:54:10 <lambdabot> Maybe b -> Either (Maybe a) b
12:54:59 <Cale> zmbmartin: ^^
12:55:03 <dmj`> how do you get your heap profile to be colored? dist/build/tests/tests +RTS -p -hc && hp2ps tests.hp && open test.ps -- shows only gray output :/
12:55:24 <dmj`> is that a hp2ps thing?
12:55:48 <matt2> is there a way i can change one index of a vector?
12:55:49 <Guest3151> monochrom, i'm on ubuntu 12.04 and it doesn't do that
12:55:53 * Cale imagines a laundry detergent style advert: "How do you get your heap profiles so bright?"
12:55:57 <matt2> basically i want a copy where one index is different
12:56:04 <Guest3151> monochrom, doing tar xvf <file>.tar
12:56:27 <monochrom> as per the instruction on the web page, you have to sudo /usr/local/haskell/ghc-7.8.3-x86-64/bin/activate-hs . did you read the web page?
12:56:32 <Cale> dmj`: hp2ps --help (which was an error) told me the option is -c
12:56:40 <beaky> @hoogle (a -> b) -> a -> (a, b)
12:56:43 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
12:56:43 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
12:56:43 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
12:56:47 <monochrom> perhaps I should not have answered to begin with.
12:57:02 <dmj`> Cale: thank you!
12:57:33 <dmj`> so pretty now
12:59:33 <monochrom> a laundry detergent ad "how do you get your underwear so multi-coloured" would go very wrong. it would imply that the detergent causes the clothes to share colours...
13:00:35 <buttons840> if I have something like array ((1, 1), (2, 2)) [ ... ] ! (0, 0) -- what's a good way to implement a default value for indexes that are not part of the array?
13:01:18 <buttons840> i guess just define my own function similar to (!) with some guards to check the bounds?
13:03:35 <folsen> anyone know where to read up about what’s a promotable type? experimenting with datakinds and hitting “this type is un-promotable"
13:06:03 <zmbmartin> Cale: Thanks!
13:07:34 <dmj`> folsen: http://dreixel.net/research/pdf/ghp.pdf
13:08:09 <folsen> dmj`: thanks!
13:08:16 <dmj`> np
13:14:26 <JagaJaga> Isn't there a way to make smth like deriving(Read) for an existing datatype (from library)?
13:15:18 <Cale> There's a language extension for that...
13:15:37 <JagaJaga> Cale: what do you mean?
13:15:50 <Cale> Add {-# LANGUAGE StandaloneDeriving #-} to the top of your file
13:15:58 <fuzzyhorns> anyone seen this? https://www.youtube.com/watch?v=6mTbuzafcII
13:16:14 <Cale> and then you can write
13:16:14 <fuzzyhorns> im curious if it corresponds to a category or type, things that are transducible basically
13:16:23 <Cale> deriving instance Read Foo
13:16:35 <JagaJaga> Cale: oh, love haskell :3
13:16:39 <Cale> and if the constructors for Foo are still in scope, it will be allowed
13:17:05 <MrFlibble> for a moment I though I was in C++ channel.
13:17:09 <MrFlibble> thought*
13:17:26 <Cale> Usually this is actually kind of a bad idea: you typically want instances for type classes to go in either the module where the class is declared or the module where the data type is declared
13:17:27 <JagaJaga> Cale: thx!
13:17:57 <beaky> are transducers like Traversable instances
13:17:58 <Cale> But in a pinch, it's still allowed, and should be totally fine for a program which is intended to produce an executable rather than to be used as a library
13:18:00 <JagaJaga> Cale: now I need in outside..
13:18:12 <JagaJaga> Cale: yeah, it is.
13:18:13 <fuzzyhorns> beaky: i was wondering that
13:18:24 <bartavelle> fuzzyhorns, https://twitter.com/kmett/status/513031477735735296
13:18:25 <Cale> The reason for this rule of thumb is that it's impossible *not* to import instances when you import a module
13:18:54 <Cale> and if they conflict with one another, you end up with problems
13:19:19 <Cale> So, it's theoretically possible to end up in situations where you can't use two libraries together if you write "orphan" instances like that
13:19:20 <fuzzyhorns> bartavelle: heh
13:19:33 <Cale> But in practice, people are pretty good about it and it's fairly rare.
13:19:59 <bartavelle> there is also a lengthy reddit thread somewhere
13:20:30 <JagaJaga> Cale: your explanations are nice, thx.
13:20:50 <fuzzyhorns> bartavelle: i was wondering
13:21:35 <fuzzyhorns> bartavelle: beaky http://oleksandrmanzyuk.wordpress.com/
13:21:39 <fuzzyhorns> top post
13:22:07 <bartavelle> this blog post gives the same signature
13:23:21 <bartavelle> ah this post is interesting
13:23:48 <fuzzyhorns> :)
13:24:11 * hackagebot neil 0.0 - General tools for Neil  http://hackage.haskell.org/package/neil-0.0 (NeilMitchell)
13:24:35 <trap_exit> is it possible to use something like chromecast as an external monitor? i.e. I just want to stream a live updating webpage to chrome cast
13:27:51 <zmbmartin> Anyone that can tell me where I am going wrong. I want if id is Nothing to return NotFound otherwise keep going -> https://gist.github.com/codedmart/c554b3713fc5393cda6c#file-main-hs-L10-L11
13:31:01 <spopejoy> simpler lens+json q: how to filter an Array by the value of a property. e.g., array of {name=String,bar=...}, find those with name="Sam"
13:31:27 <aostiles> Hi, I'm trying to use the GHC API and Snap to create a simple webserver that runs uploaded Haskell source files. I'm having difficulty, however, printing the result of the executed program. https://gist.github.com/aostiles/fbf74222067bee0485ec#file-compile-hs
13:34:55 <dmj`> aostiles: what is the error?
13:37:27 <sm> neil. Nice :)
13:37:43 <aostiles> dmj`: I can't seem to get any response out. I'm just testing with a simple "hello world" program called hello.hs. I've tried returning an IO String in hello.hs and then tried returning an IO () and capturing stdout but neither method has worked.
13:38:24 <beaky> how do i refactor a function with too many where clauses
13:38:51 <pingu> beaky: factor out reuseable bits to entire functions, point free helps too
13:38:58 <pingu> paste the functoin?
13:39:12 * hackagebot neil 0.1 - General tools for Neil  http://hackage.haskell.org/package/neil-0.1 (NeilMitchell)
13:39:29 <pingu> aostiles: this doesn't help with your problem but FYI:
13:39:32 <pingu> showHeaders req = Prelude.foldl (++) "" (Prelude.map showHeader (listHeaders req))
13:39:44 <pingu> is the same as showHeaders = concatMap (showHeader . listHeaders)
13:39:58 <beaky> here it is: http://lpaste.net/112783
13:40:34 <aostiles> pingu: ah thanks yeah the code is a bit unpolished
13:40:53 <beaky> it could probably be simplified :D
13:41:26 <beaky> but i think its a case of doing too much work in one function
13:43:11 <zmbmartin> So I updated my gist NotWorkingMain.hs is what I was trying to do but WorkingMain.hs is working just trying to see if I can remove the extra case statement of right it more succinct? https://gist.github.com/codedmart/c554b3713fc5393cda6c
13:43:15 <pingu> beaky: perhaps.
13:43:20 <zmbmartin> Any help is greatly appreciated.
13:43:26 <pingu> beaky: looks like you have a big template in haskell, is all.
13:43:27 <dmj`> beaky: you can put them all under one where clause
13:43:40 <pingu> beaky: personally I'd have made one big format string
13:43:47 <pingu> because following formats within formats is painful
13:43:58 <supki> spopejoy: something along the lines of  filtered (elemOf (key "name") "Sam")  perhaps?
13:44:11 <pingu> so, one big format string, maybe with unlines or the likes of
13:44:15 <dmj`> aostiles: can you paste your hello world program on lpaste.net?
13:44:17 <beaky> woah didnt know you can just have a single where clause :D
13:44:29 <dmj`> beaky: yea, multiple wheres is rough
13:44:53 <pingu> beaky: once you have one format string, your function will flatten out
13:45:00 <pingu> and be manageable, hopefully
13:45:07 <pingu> I agree, that's unmaintainable.
13:45:14 <dmj`> beaky: all those indentation rules too :/
13:45:16 <armando> here
13:46:23 <beaky> maybe i should just rewrite the whole beast with one format string
13:47:55 <beaky> but i dont know how i could do it with a single format string to handle the different type cases :D
13:48:20 <lpaste> aostiles pasted “compile.hs” at http://lpaste.net/112784
13:49:05 <chrisdone> aostiles: good work
13:49:25 * chrisdone congratulates anyone who can figure out the ghc api for something practical
13:50:43 <spopejoy> supki: yep! thanks
13:51:31 <aostiles> chrisdone: haha thanks - the GHC api hasn't proven to be very user friendly
13:52:10 <chrisdone> aostiles: in ten  or fewer words, what is that program?
13:53:11 <aostiles> chrisdone: Upload haskell code to a server and have it run.
13:55:08 <chrisdone> \o/
14:01:50 <jbeja> What others alternatives beside FRP
14:06:12 <kinslayer> hey all, I have a little problem with a eulerproblem
14:07:01 <kinslayer> the one with the sundays, my problem is however more that I generate a long list of Maybe values that I would like to collapse to only the Just cases...
14:07:40 <dmj`> @src catMaybes
14:07:40 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:08:22 <bitemyapp> ttuegel: ping
14:09:16 * hackagebot monadloc-pp 0.3.1 - A preprocessor for generating monadic call traces  http://hackage.haskell.org/package/monadloc-pp-0.3.1 (PepeIborra)
14:11:46 <eacameron> what's the easiest way to constrain the type of "try"? I'm using a case try (something) of....
14:12:02 <eacameron> the Exception type that is
14:15:07 <monochrom> eacameron: my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#typing may help
14:15:30 <eacameron> monochrom: perfect. thanks a ton
14:21:27 <kinslayer> dmj thanks I was just briefly away
14:27:33 <dmj`> kinslayer: np
14:28:07 <kinslayer> dmj well it made that problem a whole lot easier to solve...
14:28:58 <kinslayer> I ended up writing something that is close to a calender program...
14:31:19 <dmj`> kinslayer: is this #19
14:31:31 <kinslayer> yeah
14:32:41 <kinslayer> and I got it right :D
14:33:56 <dmj`> well done
14:34:18 * hackagebot informative 0.1.0.5 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.5 (implementation)
14:34:22 <kinslayer> well I did in 100 lines
14:34:57 <dmj`> kinslayer: bet you could do it with a one fold
14:35:02 <dmj`> with one fold*
14:35:24 <kinslayer> yeah but then I wouldn't have a almost done calender :D
14:35:30 <kinslayer> an*
14:36:06 <kinslayer> although one guy suggest 1200/7 as a solution
14:36:30 <kinslayer> which is quite a short solution
14:42:54 <kinslayer> I also found a very clean solution to #1
14:56:32 <QF-MichaelK> In interest of code golfing, has anyone seen an attempt to find minimal length code via extraction from some generating sequence?
14:57:27 <vanila> hard to understand what you mean
15:00:28 <QF-MichaelK> vanila: For instance, a much shorter version of my program likely exists right near my finger tips, I only have to find it.  Perhaps it's some remapping of the Fibonacci digits of pi starting at the 400th's decimal place.  I figured that there might be some study to determine a way to find working programs from random sequences and patterns that are much more simply expressed.  Sorry that it's probably quite off topic, on another note, hav
15:01:23 <vanila> QF-MichaelK, well finding the shortest program to compute a given thing is extremely hard!
15:01:34 <josephle> one might say it's undecidable
15:02:10 <josephle> QF-MichaelK, do you know about kolmogorov complexity?
15:02:13 <QF-MichaelK> finding the desired program is undecidable, but what about just finding a program with valid syntax?
15:02:16 <QF-MichaelK> Yes
15:03:09 <josephle> Are there any other restraints to the program?
15:03:21 <josephle> *constraints
15:04:29 <linman32> trying to get yesod up and running. have a compile time error w/ example program.
15:04:33 <QF-MichaelK> There may be constraints which make things more probable, but I suspect finding a valid program over length 10 would already be fairly improbable.
15:04:33 <linman32> line 8: http://lpaste.net/112752
15:04:53 <Hijiri> ;yesod is notoriously hard to manage dependencies without stackage
15:05:48 <Hijiri> installing anything other than yesod and its dependencies is highly-likely to result in problems when installing yesod
15:06:08 <linman32> QF-MichaelK: the kolmogorov complexity of pi is supposed to be really small, even though it is infinite
15:06:25 <linman32> QF-MichaelK: *the sequence of pi is infinite
15:06:58 <linman32> Hijiri: i'm trying to use sandbox
15:07:08 <QF-MichaelK> linman32: Sure, but that's not the point.  Yes, there are sequences which compute pi to x places, but I'm suggesting it just as a generating function.
15:08:03 <QF-MichaelK> alternating sequence of 4 over odd n
15:08:04 <linman32> Hijiri: so, there shouldn't be any tangles w/ other dependencies
15:08:07 <luite> pi is an interesting example, since a "program" that computes pi was found by computer search in the 90s
15:08:10 <Guest84013> ciao a tutti
15:08:21 <Guest84013> !list
15:08:21 <monochrom> Guest84013: http://lpaste.net/browse
15:08:54 <luite> well not just pi, individual digits of it
15:09:10 <pjdelport> QF-MichaelK: Your question is probably at the heart of programming itself, as well as topics like data compression.
15:09:21 <QF-MichaelK> luite: I thought it was theorized via the gamma function?
15:10:23 <QF-MichaelK> pjdelport: Possibly, which is why I suspect someone may have tried a N random configurations and observed m random valid sequences of code.
15:10:24 <linman32> QF-MichaelK: maybe i misunderstand, but the k-complexity of it is the generating function
15:10:27 <luite> QF-MichaelK: oh i mean the BBP formula, which was found using the PSLQ algorithm
15:10:59 <merijn> linman32: Also, there's #yesod (you're more likely to get in-depth yesod things answered there :) )
15:11:14 <QF-MichaelK> linman32: k complexity would be the minimum generating function
15:11:29 <linman32> merijn: thanks will check it out
15:11:49 <merijn> Because I've not specific idea what's wrong there, other than what the error states ;)
15:11:55 <josephle> if I understand QF-MichaelK correctly, the question is whether or not any generating function can be found
15:12:03 <josephle> programmatically
15:13:13 <QF-MichaelK> josephle: Right, any function, minimum is likely impossible, but there might be some interesting near minimal solution which is a lot easier to find.
15:14:02 <zq> i need a new project
15:14:06 <shiona> wouldn't any normal number be a perfect generator
15:15:15 <QF-MichaelK> shiona: Indeed.
15:15:41 <QF-MichaelK> shiona: Only would need something deterministic so that you could get it again.
15:16:49 <josephle> I feel like the whole field of Machine Learning is based on the fact that many computer scientists have given up on finding an exact solution to this problem
15:16:52 <josephle> ;)
15:17:05 <JagaJaga> How to read first N bytes of byteString? Or split it by 3bytes:4bytes:1byte?
15:17:15 <merijn> josephle: Machine learning is how you say "statistics" to a computer scientists
15:17:23 <merijn> JagaJaga: drop/take?
15:17:56 <luite> QF-MichaelK: anyway that falls in a general class of integer relation algorithms, if you can express your program as a polynomial you can try applying those to factor it or search for small constants that generate the coefficients
15:18:00 <JagaJaga> merijn: arr, stupid am I
15:18:52 <merijn> JagaJaga: Depending on what kinda processing you want to do, you may want to look into binary?
15:18:52 <josephle> merijn: I'm just saying that we wouldn't resort to statistical methods if QF_MichaelK's program existed
15:19:19 <josephle> well, maybe we would if it was a horribly inefficient program...
15:19:22 <merijn> JagaJaga: Are you parsing some binary format, or what?
15:19:44 <JagaJaga> merijn: yeah, network messages in format of i've wrote above
15:20:12 <JagaJaga> bytestrings are null terminated?
15:20:29 <merijn> JagaJaga: That's a nonsensical question
15:20:50 <QF-MichaelK> luite: Hm, the point isn't to find "my program" but find "a program."  It was to study the probability of finding a valid program in different minimalistic ways.
15:20:59 <merijn> JagaJaga: Despite what the current name, for historical reasons, implies, ByteString should actually just be called "Bytes"
15:21:54 <merijn> JagaJaga: Ok, you probably want to look into the "binary" library, it has to serialise/deserialise data from ByteString (like getWord8/getWord16/getByteString)
15:22:24 <JagaJaga> merijn: saw it. Thx, gonna check.
15:22:37 <QF-MichaelK> josephle: It'd likely be horribly inefficient and wouldn't even give you a useful answer, just a "This sequence has n syntactically correct sub programs of sizes [10,3,2]
15:23:06 <JagaJaga> and, btw, I had never worked with multithreaded programms in haskell. What's the best way to make a queue between threads in haskell program?
15:23:16 <linman32> Hijiri: is there a better alternative to yesod?
15:23:25 <Hijiri> there are other web frameworks
15:23:27 <Hijiri> like snap or scotty
15:23:36 <merijn> JagaJaga: It makes it really easy to serialise/deserialise binary formats. Word of warning, don't use the Binary typeclass (and it's operators) for pre-existing formats, it introduces extra binary specific junk, just write manual Get/Put using Data.Binary.Get/Data.Binary.Put functions
15:23:38 <Hijiri> yesod is the one with the most integrated features, though
15:23:58 <merijn> JagaJaga: Control.Concurrent has a bunch of mutable variables, channels and queue types
15:24:12 <merijn> JagaJaga: Also, see Control.Concurrent.STM for software transactional versions of those
15:24:20 <JagaJaga> merijn: yeah, found an example (binary). really easy. Thx!
15:24:28 <JagaJaga> merijn: thx, will try.
15:30:53 <pjdelport> JagaJaga: The go-to book on concurrency in Haskell is probably http://chimera.labs.oreilly.com/books/1230000000929
15:31:01 <pjdelport> (Readable online)
15:31:22 <merijn> pjdelport: Probably overkill if he just needs a simple queue shared between threads :)
15:34:52 <JagaJaga> pjdelport: yeah, it like reading `how to create boeing 707` when I need to create paper plane :D
15:36:12 <pjdelport> JagaJaga: I wasn't suggesting reading the whole book. :)
15:36:19 <pjdelport> JagaJaga: Just for example http://chimera.labs.oreilly.com/books/1230000000929/ch07.html might be relevant.
15:36:28 <pjdelport> as a tutorial
15:36:38 <JagaJaga> Guys, I can't understand `kinds`. Am I right that it a thing, like the type for type?
15:36:45 <JagaJaga> pjdelport: oh, yeah, it's nice!
15:37:00 <pjdelport> JagaJaga: Yes, that's pretty much right. Kinds are the "types" of types.
15:37:12 <JagaJaga> (back to kinds) traits are kinds?
15:37:28 <JagaJaga> I mean Ord Eq etc
15:37:43 <pjdelport> Type classes?
15:37:55 <JagaJaga> yeah, they are called traits in rust :)
15:38:26 <JagaJaga> so type classes aren't kinds?
15:38:58 <pjdelport> Not exactly, no.
15:40:02 <k00mi> JagaJaga: typeclasses are on the same level as types, i.e. they *have* kinds
15:40:45 <merijn> JagaJaga: Typeclasses are constraints
15:41:29 <merijn> JagaJaga: Like "foo :: Ord a => a -> a -> Bool" is a constraint that says "IF 'a' is an instance of 'Ord' THEN 'foo :: a -> a -> Bool' ELSE foo is a type error"
15:41:55 <JagaJaga> merijn: yeah, I know that. I need more theory.
15:42:09 <JagaJaga> If we speak about kind of typeclasse
15:42:26 <JagaJaga> It's smth like * -> ....what? constraint?
15:42:37 <k00mi> "Constraint", yes
15:43:07 <JagaJaga> So what is constraint in words of type theory?
15:43:39 <merijn> JagaJaga: I don't really know
15:43:42 <merijn> Also
15:43:46 <merijn> :k Ord
15:43:47 <lambdabot> * -> Constraint
15:43:59 <JagaJaga> merijn: yeah, already did it
15:44:05 <merijn> ah
15:44:18 <merijn> You can, using a bunch of extensions, handwrite constraints too
15:44:38 <merijn> For example, my favourite neat trick! https://gist.github.com/merijn/6130082
15:44:42 <JagaJaga> merijn: oh, that's nice
15:44:50 <ReinH> merijn: o_O
15:44:58 <merijn> A function that accepts ALL types, *except* () and Int :)
15:45:08 <merijn> ReinH: Try it! :D
15:45:25 <ReinH> merijn: I believe you :p
15:45:44 <merijn> ReinH: Although type inference falls on it's face if you use polymorphic values (like "foo 3", that requires an explicit annotation that forces 3 to not be Int or ())
15:45:55 <jfischoff> merijn: "Error!" ~ "Tried to apply a restricted type!" neat
15:46:30 <jfischoff> that is interesting
15:47:29 <k00mi> JagaJaga: did you have a look at the "How to make ad-hoc polymorphism less ad hoc" paper?
15:48:01 <JagaJaga> k00mi: no
15:48:26 <k00mi> that was the original paper introducing typeclasses
15:48:51 <JagaJaga> k00mi: thx, will google it
15:49:26 * hackagebot shell-conduit 4.3 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.3 (ChrisDone)
15:49:27 <Cale> (Though please don't take that as meaning that type class polymorphism is ad-hoc polymorphism)
15:49:33 <Cale> I hate the name of that paper :P
15:49:59 <ReinH> Cale: is "not ad-hoc" less ad-hoc than "ad-hoc"? Someone get a philosopher.
15:50:32 <Cale> Yeah, "How to make ad-hoc polymorphism not ad-hoc" maybe
15:51:12 <Cale> Type classes have some of the same applications as ad-hoc polymorphism
15:51:50 <Axman6> merijn: I used some similar tricks to overlay which exceptions a piece of code can throw and track if they've been caught or not (like java does)
15:52:30 <Cale> But they're quite a different thing, because you can define new type class polymorphic things simply by using others in a single definition, whereas with ad-hoc polymorphism, you have to define any ad-hoc polymorphic thing at each of the types at which it will be used.
15:54:04 <JagaJaga> Thx a lot, guys, but I have to sleep. Good night all!
15:54:06 <benzrf>            06:58 < Cale> (Though please don't take that as meaning that type class polymorphism is ad-hoc polymorphism)
15:54:11 <benzrf> i thought that's what they *were*
15:54:41 <Cale> Well, see my following remarks
15:55:03 <Cale> Ad-hoc polymorphism is different and less useful
15:55:56 <Cale> Type class polymorphism has a lot more in common with parametric polymorphism together with implicit arguments than it has in common with ad-hoc polymorphism.
15:56:25 <exio4> bounded polymorphism?
15:57:12 <Cale> Yeah, you can also call it bounded parametric polymorphism
15:57:56 <exio4> I don't even know what ad-hoc polymorphism really means :P
15:59:20 <MishaC> Hello Everyone, can anyone answer this quick question. " Is there a way to view list of installed packages from ghci" The reason for asking is that I installed it, Cabal tellms me it is installed but i cannot import it.
15:59:26 <Cale> Ad-hoc polymorphism means that you can define something at multiple types, and the type context at the locations where it is used will be used to select exactly one of the definitions.
16:00:13 <geekosaur> ghc-pkg list
16:00:32 <Cale> Type class polymorphism is freer than that: which instance is selected doesn't necessarily have to be pinned down uniquely, because you can generalise over that choice.
16:00:46 <MishaC> yeah, that is what i used to see the list of packages, but for some reason i cannot import the package
16:00:52 <jfischoff> I’ll just throw this out, even with the bad title, it is the best paper I know of on typeclasses.
16:01:01 <Cale> yeah, it is a good paper
16:01:06 <Cale> I just don't like the title :)
16:01:07 <MishaC> this was the command that i used to verify that package was installed
16:01:11 <geekosaur> the other thing that comes to mind is you don't import packages, you import modules
16:01:15 <MishaC> actually he package i am refering to is
16:01:24 <MishaC> System-Random-Mersenne
16:01:37 <MishaC> yeah i mean  the module mersenne
16:01:50 <MishaC> ok
16:01:50 <MishaC> i got it
16:01:51 <MishaC> it works
16:01:52 <MishaC> sorry
16:01:59 <MishaC> capital leteter
16:02:00 <Cale> e.g. sort :: (Ord a) => [a] -> [a]  only has one definition. With ad-hoc polymorphism, you'd define it multiple times, one for each type of list you wanted to be able to sort.
16:02:21 <exio4> Cale: ah, so Idris' (∷)/Nil with Vect/List/etc is ad-hoc polymorphism?
16:02:39 <Cale> Yes
16:04:28 * hackagebot vector-heterogenous 0.2.0 - A type-safe library for vectors whose elements can be of any type, or any type satisfying some constraints  http://hackage.haskell.org/package/vector-heterogenous-0.2.0 (MikeIzbicki)
16:09:28 * hackagebot hzulip 0.4.2.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.4.2.0 (yamadapc)
16:30:32 <monochrom> but I still have to define <= multiple times, once for Int, once for Bool, once for Char, once for Int8, once for Int9...
16:30:49 <joe9> http://codepad.org/XyYFZ3Z1 This program works. Does it work one step at a time because of Haskell's lazy evaluation?
16:30:56 <joe9> I am trying to understand why it works.
16:31:09 <monochrom> it is only true that I do not have to define <= for (Int8, Int9) separately
16:31:30 <joe9> It stops after the first step (as expected). I am assuming that it pause's there because of Haskell's lazy evaluation.
16:31:39 <monochrom> so at the end it is less ad-hoc, but not absolute zero ad-hoc.
16:33:23 <Cale> monochrom: Yeah, the actual class methods are defined in an ad-hoc sort of way, but other type class polymorphic things needn't be.
16:34:06 <Cale> joe9: Nope, that doesn't have much to do with lazy evaluation
16:34:32 <Cale> joe9: Evaluation of expressions and execution of IO actions are two separate (though interleaved) things
16:34:50 <Cale> joe9: In general, evaluation of expressions does not cause IO actions to be executed
16:35:08 <joe9> Cale, oh, ok. thanks.
16:35:30 <joe9> Cale: What causes the program to stop while using runN instead of just running through to the end as in fullRun.
16:36:40 <Cale> Okay, let's consider what happens when you apply runN 1 to pauseExample1
16:36:57 <linman32> if i am only using sandbox, is it ok to clear out ~/.cabal/packages?
16:37:23 <monochrom> do you know what is the purpose of ~/.cabal/packages ?
16:37:43 <linman32> that is for global packages not used by sandbox?
16:38:14 <Cale> runN 1 pauseExample1 = runN 1 (Run $ do putStrLn "Let's begin" ...) = (do putStrLn "Let's begin" ...) >>= runN 0
16:38:28 <monochrom> no. it caches the hackage list
16:38:39 <Cale> joe9: Of course, runN 0 is the same function as return
16:38:50 <monochrom> have you actually examined its content?
16:38:51 <Cale> (runN 0 p = return p for every p)
16:39:09 <Cale> So this is the same as (do putStrLn "Let's begin" ...) >>= return
16:39:23 <Cale> and *that* is the same as  do putStrLn "Let's begin" ...
16:39:23 <linman32> yeah looks like packages. i thought they went into sandbox or something
16:39:33 <Cale> Because x >>= return is always the same thing as x
16:40:04 <joe9> Cale, thanks. I think I get it. Return stops the function evaluation and provides the return value.
16:40:13 <monochrom> ok, I'll suggest you an experiment so you find out for real what's going on.
16:40:26 <joe9> Cale, Thanks for the patient explanation.
16:40:36 <Cale> So, yeah, when we actually execute the IO action starting with do putStrLn "Let's begin" ...
16:40:44 <monochrom> 1. clear it out. it's safe except for wasting internet bandwidth later (if you have to pay by bytes transferred or time)
16:40:52 <monochrom> 2. cabal update
16:40:54 <Cale> Eventually, it returns a Pause IO computation
16:40:55 <monochrom> 3. examine again.
16:41:04 <Cale> immediately after printing Step 1
16:41:18 <Cale> joe9: It might also help to play around with stuff like...
16:42:14 <Cale> test = do print 1; return (do print 2; return (do print 3; return ()))
16:42:22 <Cale> define that in ghci
16:42:34 <Cale> then try x <- test
16:42:42 <Cale> and then y <- x
16:42:46 <joe9> Cale, ok, will do thanks.
16:43:21 <Cale> test :: IO (IO (IO ()))
16:44:00 <linman32> monochrom: ok i will give that a try. thanks
16:44:08 <Cale> So this is an IO action which produces as its result another IO action, which itself produces as its result yet another IO action, which finally produces an empty tuple.
16:44:30 <exio4> are there any nice uses of having "nested" IOs? I just thought it would allow some weird stuff, but I can't think of any?
16:44:44 <Cale> The Pause type is a trick for allowing this sequence of nestings to be possibly infinite
16:44:46 <joe9> exio4: coroutines
16:44:59 <joe9> exio4: green threads
16:45:02 <Cale> exio4: Perhaps you want to defer part of the computation until later
16:45:15 <monochrom> exio4: object-oriented programming
16:45:28 <Cale> For example, let's say you want to schedule sending out an email until a particular future time
16:46:00 <exio4> oh, didn't think of multiple threads
16:46:13 <Cale> Perhaps you'd have an IO action which itself produces the IO action for sending the email that you can stash away in some data structure until it's time to send it
16:46:45 <Cale> That would give you lots of flexibility with respect to this process -- you could easily stash away actions that do other things
16:47:43 <Hijiri> does fmap (f :: a -> IO b) someIOAction count as nested IO actions?
16:48:31 <Cale> Yeah, that'll produce something of type IO (IO b)
16:48:42 <exio4> and with join you get >>= :P
16:49:16 <Hijiri> so now every IO action made with bind is nest IO
16:49:29 <Cale> So, if you run that action, it'll have the same effect as someIOAction, but it'll produce as its result another IO action which you can then execute to carry out the result of f
16:49:48 <Cale> Well, yeah, but join "de-nests" in exactly that way
16:50:00 <Cale> join x is the same thing as  do y <- x; y
16:50:09 <Cale> which is the same as  do y <- x; v <- y; return v
16:51:18 <exio4> @type x >>= id
16:51:20 <lambdabot>     Couldn't match expected type ‘m (m b)’ with actual type ‘Expr’
16:51:20 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘x’
16:51:20 <lambdabot>     In the expression: x >>= id
16:51:30 <exio4> @type \x → x >>= id
16:51:32 <lambdabot> Monad m => m (m b) -> m b
16:51:41 <benmachine> you could imagine a locking API with lock :: IO (IO ())
16:51:51 <benmachine> it gives you the release action when you execute it
16:52:00 <Cale> yes, that's also common
16:52:23 <pjdelport> :t putStrLn <$> getLine
16:52:24 <Cale> Another use is to create a counter
16:52:25 <lambdabot> IO (IO ())
16:52:50 <monochrom> the counter example is what I said about object-oriented programming
16:53:00 <monochrom> but not the counterexample
16:53:13 <Cale> mkCounter = do r <- newIORef 0; return (do n <- readIORef r; writeIORef (n+1); return n)
16:53:34 <benzrf> :t join (putStrLn <$> getLine)
16:53:35 <lambdabot> IO ()
16:53:43 <benzrf> (>>=) is just join .: fmap
16:53:46 <Cale> Then you can try something like  c <- mkCounter  and run c a few times
16:54:25 <Cale> oh, oops
16:54:30 <Cale> missed the reference in one place
16:54:36 <Cale> mkCounter = do r <- newIORef 0; return (do n <- readIORef r; writeIORef r (n+1); return n)
16:54:44 <benzrf> hence why join may be implemented as (>>= id)
16:54:49 <benzrf> that's join . fmap id :)
16:54:50 <Axman6> atomicModifyIORef yo
16:55:02 <Cale> Sure, I guess
16:55:11 <exio4> join is how monads are defined in category theory, I think?
16:55:30 <benzrf> it's how monads are defined in general!!!
16:55:38 <benzrf> bind is just fmap followed by join
16:55:51 <benzrf> when you define bind you are rehashing what you already have in addition to defining the true monadyness!
16:57:20 <pjdelport> Monad is essentially Applicative + join
16:58:19 <exio4> and applicative is functor + <*>? :P
16:58:25 <monochrom> yes
16:58:25 <exio4> (and pure?)
16:58:54 <benzrf> exio4: applicative's soul is (the hypothetical) (<**>) in the same way join is monads
16:59:19 <Axman6> what's <**>?
16:59:24 <exio4> that looks like flipped <*>
16:59:24 <monochrom> I disagree.
16:59:27 <benzrf> @let class Functor f => Applicative' f where pure' :: a -> f a; (<**>) :: f a -> f b -> f (a, b)
16:59:30 <lambdabot>  Defined.
16:59:33 <benzrf> monochrom: oh?
17:00:22 <monochrom> I disagree with the whole sentiment that, where there are several equivalent definitions, one of them is more canonical or more soul or more holier.
17:00:34 <benzrf> ahihi:
17:00:36 <benzrf> *ah
17:00:49 <benzrf> well i feel like it captures the monoidality of applicatives better
17:00:54 <benzrf> in fact, even better might be
17:01:15 <benzrf> @let class Functor f => Applicative'' f where pure' :: a -> f a; (<**>) :: Monoid m => f m -> f m -> f m
17:01:17 <lambdabot>  .L.hs:166:9:
17:01:17 <lambdabot>      Multiple declarations of ‘pure'’
17:01:17 <lambdabot>      Declared at: .L.hs:160:9
17:01:17 <lambdabot>                   .L.hs:166:9
17:01:17 <lambdabot>  
17:01:18 <benzrf> :b
17:01:20 <benzrf> or something
17:01:30 <benzrf> actually the type there probably loses some info idk
17:01:51 <benmachine> that's an icky presentation
17:01:53 <monochrom> <*> captures the currying application better
17:02:38 <benmachine> just try implementing <*> with that presentation, it's icky
17:02:52 <monochrom> f <$> x <*> y is usually other languages' f x y
17:03:04 <benmachine> I disagree with monochrom that all equivalent definitions are equally valid
17:03:17 <benmachine> I do think Applicative has a soul
17:03:37 <Cale> > [(+), (*)] <$> [1,2,3] <*> [40,50,60]
17:03:39 <lambdabot>  Couldn't match expected type ‘a1 -> a0 -> b’
17:03:39 <lambdabot>              with actual type ‘[a2 -> a2 -> a2]’
17:03:55 <Cale> > [(+), (*)] <*> [1,2,3] <*> [40,50,60]
17:03:55 <benmachine> benzrf: note that given the Functor constraint, it's also common to replace pure :: a -> f a with unit :: f ()
17:03:57 <lambdabot>  [41,51,61,42,52,62,43,53,63,40,50,60,80,100,120,120,150,180]
17:03:57 <Cale> right :)
17:04:06 <Cale> > (+) <$> [1,2,3] <*> [40,50,60]
17:04:07 <benzrf> benmachine: aha
17:04:07 <lambdabot>  [41,51,61,42,52,62,43,53,63]
17:04:14 <Axman6> f <*> x = fmap (\(f,x) -> f x) $ f <**> x
17:04:19 <Axman6> it's not that icky
17:04:24 <benmachine> Axman6: I meant the Monoid one
17:04:28 <benmachine> not that one, I like that one
17:04:34 * hackagebot graphmod 1.2.6 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.6 (IavorDiatchki)
17:04:37 <benzrf> :t uncurry ($)
17:04:38 <benmachine> Applicative'' is icky
17:04:39 <lambdabot> (b -> c, b) -> c
17:04:43 <benzrf> benmachine: yeah
17:04:46 <Axman6> Oh I missed the monoid one
17:05:02 <Axman6> benzrf: oh nice, hadn't thought of that
17:05:14 <benmachine> also I think we should stop saying <**> because
17:05:17 <benmachine> :t (<**>)
17:05:18 <lambdabot>     Ambiguous occurrence ‘<**>’
17:05:18 <lambdabot>     It could refer to either ‘L.<**>’,
17:05:18 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:162:9
17:05:32 <benmachine> :t (Control.Applicative.<**>)
17:05:32 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
17:05:48 <benzrf> ah
17:05:53 <Axman6> > let f <,> x = f x in (+1) <,> 2
17:05:55 <lambdabot>  <hint>:1:8: parse error on input ‘,’
17:05:58 <Axman6> :(
17:06:00 <benmachine> that won't work because , is reserved
17:06:01 <benmachine> sadly
17:06:11 <Axman6> yeah
17:06:20 <Axman6> but I can see why it's reserved
17:06:37 <benmachine> I can see that a thing is the right thing and still be sad about it :P
17:06:46 <Axman6> lists/tuples become ambiguous
17:06:50 <Axman6> yeah, me too :P
17:06:58 <exio4> <α>
17:08:07 <benmachine> anyway I think the tuple-wise presentation makes for substantially clearer laws
17:08:28 <benmachine> but the function-based presentation makes for very convenient usage
17:09:24 <benzrf> y e p
17:09:28 <benzrf> just like bind v join
17:09:29 <benzrf> ;-;
17:10:12 <benzrf> :t fold
17:10:13 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:29:37 * hackagebot haskell-awk 1.0.1 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.0.1 (gelisam)
17:37:35 <mietek> Is it possible to set cabal flags like, say, -fhighlighting for pandoc, in a cabal.config?
17:41:23 <dmj`> mietek: you can put cabal flags in the file that gets generated by calling cabal freeze
17:50:03 <newsham> here I am..  rock you like a hurricane
17:52:47 <ToTheInternet> i installed the ftphs package on debian (apt-get install libghc-ftphs-dev) but in prelude i can't load the module. The documentation suggests this -- :l Network.FTP.Client, but then this happens
17:52:51 <ToTheInternet> <no location info>: module `Network.FTP.Client' is a package module
17:52:54 <ToTheInternet> Failed, modules loaded: none.
17:53:44 <Axman6> @hackage ftphs
17:53:44 <lambdabot> http://hackage.haskell.org/package/ftphs
17:54:34 <ToTheInternet> 'ghc-pkg list' lists the module, and 'ghc-pkg expose ftphs-1.0.9.1' doesn't change anything either
17:55:18 <ToTheInternet> Axman6: this doesn't help me, i had this link open before you posted it. as i said, i got the :l Network.FTP.Client exactly from that page
17:55:37 <Axman6> I was opening it for myself
17:55:43 <ToTheInternet> oh, sorry
17:56:04 <Axman6> yeah I have no idea what "Foo  is a package module" is supposed to mean
17:56:25 <Axman6> oh, you need import Network.FTP.Client
17:56:38 <Axman6> :l is for loading local files, like in the current directory
17:56:56 <ToTheInternet> yes! that's it. thanks a lot
17:57:12 <Axman6> :m +Network.FRP.Client also works. perhaps report a bug, those docs are wrong
17:57:51 <ToTheInternet> maybe they expect people to download the tar.gz from the page rather than install the module from debian repositories?
17:58:13 <Axman6> I doubt it, it's a pretty unusual way to work with a package
17:58:52 <ToTheInternet> funny that this is the first haskell package i ever installed and i run into faulty documentation lol
17:59:18 <ToTheInternet> i will report it
17:59:28 <Axman6> https://github.com/jgoerzen/ftphs/wiki
17:59:36 <Axman6> if you weren't there already
17:59:39 <Polarina> How would I go about debugging why I'm getting this error? http://lpaste.net/112798
18:02:47 <Hijiri> Is there any way at all to change the Ctrl + Q binding in firefox
18:02:56 <benzrf> Hijiri: yep!
18:02:58 <benzrf> there's a plugin for that
18:03:01 <benzrf> er, extension
18:03:11 <benzrf> @google firefox disable ctrl+q extension
18:03:11 <lambdabot> https://addons.mozilla.org/en-US/firefox/addon/disable-ctrl-q-shortcut/
18:04:03 <Hijiri> thanks
18:04:43 <benzrf> np
18:31:23 <kini> what's the Standard Regex Library these days? The haskell wiki article hasn't been updated for four years
18:39:20 <simon_> kini, http://www.haskell.org/haskellwiki/Regular_expressions seems to have been updated this May.
18:39:54 <simon_> kini, whoops, that was an insignificant change. I see.
18:39:57 <kini> yep
18:40:29 <simon_> I'd assume you have the options listed. what will you be using it for?
18:40:52 <kini> nothing in particular, just curious
18:42:58 <simon_> it's my impression that regexes aren't used that often in Haskell. for parsing there are parser combinators.
18:43:06 <kini> hmm, I see
18:45:34 <simon_> kini, as the wiki page says, posix regexes are more declarative, like functional programming in general. you don't get some of the fancy back-tracking features of PCRE, but you trade them in for safety, and if you want to parse something hard, there's always parser combinators. :)
18:49:47 <mhall> hey, does anyone know why when i try to `cabal install sdl2-image` it says the sdl2 c library is missing? (i installed libsdl2-dev package with apt)
19:15:24 <sveit_> hello. i am not sure what channel to ask this on, and people here are usually quite educated about compiler issues :) do windows haskell developers use msys2 or cygwin?
19:17:20 <sveit_> btw i know the "official" docs say to use msys2, but does cygwin offer any advantages?
19:17:56 <tjandamurra> as far as I am aware ghc has a version for windows and doesn't require cygwin
19:18:09 <tjandamurra> but I am only apprentice padawan
19:18:21 <MP2E> it uses msys2 yes
19:18:33 <MP2E> I think you can use cygwin but it's not officially supported
19:18:37 <MP2E> as for advantages, hmm... not sure
19:18:47 <MP2E> maybe you could use the unix haskell packages with cygwin?
19:18:49 <tjandamurra> run linux and then no problems
19:18:53 <MP2E> I haven't confirmed this, but it seems possible.
19:21:21 <sveit_> unfortunately i can't run linux. i was wondering if anyone knew about performance especially, cygwin vs msys2
19:21:27 <sveit_> is the compiler toolchain the same?
19:21:55 <cads> hey guys, I have a couple questions, one totally unrelated to haskell - I'll start with the haskelly one
19:22:28 <cads> I remember someone in the community was working on a graphical interface to a dataflow programming language for lenses - anyone remember this?
19:23:48 <cads> the second question is about browsers - I'd like to analyze tabbed browsing practices by logging open/close events, and I'm wondering how to instrument a browser to let me gather that type of data
19:27:31 <cads> I'm embarrased of forgetting the author of the first effort!
19:39:53 * hackagebot glib 0.13.0.5 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.5 (HamishMackenzie)
19:49:54 * hackagebot cairo 0.13.0.4 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.4 (HamishMackenzie)
19:54:55 * hackagebot gio 0.13.0.2 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.0.2 (HamishMackenzie)
19:59:24 <chirpsalot> cads: I was kind of wondering if you could instrument an HTTP proxy to inject tracking information, but you probably won't be able to differentiate between tabs.
19:59:56 * hackagebot pango 0.13.0.3 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.3 (HamishMackenzie)
19:59:58 * hackagebot gtk3 0.13.0.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.0.3 (HamishMackenzie)
20:01:12 <cads> it looks like firefox has an addon sdk that lets you build addons in javascript
20:02:01 <cads> and there are cross-browser libraries like kango and firebreath that let you build addons that target multiple browsers
20:03:36 <e_dontes> Hi everyone. Could someone point me in the direction of where I could read about how to make my types respond to arithmetic sequence notation? Ex: [myTypeA..myTypeD] = [myTypeA, myTypeB, myTypeC, myTypeD]
20:04:56 <Hijiri> your type has to be an instance of Enum
20:05:29 <Hafydd> e_dontes: are you talking about types, or values of a given type?
20:05:36 <e_dontes> Thank you Hijiri. I had a typo: [A..C] instead of [A .. C]
20:05:59 <Hijiri> [A..C] and [A .. C] should do the same thing, shouldn't it?
20:06:11 <e_dontes> I thought so. It does not
20:06:28 <Hafydd> It can be parsed as a qualified name, I think.
20:06:53 <e_dontes> which seems strange because [1..10] and [1 .. 10] are
20:07:06 <redtricycle> I'm trying to convert a hex string into a base64 representation.  So I'm going hex->bytearray->base64.  What libraries should I be looking at?  or...example code?
20:09:57 * hackagebot gtk 0.13.0.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.0.3 (HamishMackenzie)
20:12:19 <Cale> redtricycle: There's http://hackage.haskell.org/package/base64-bytestring
20:12:53 <chirpsalot> ... Why the hell did I write my own base64 stuff?
20:16:33 <redtricycle> nice
20:24:28 <exio4> is there a way to have a local datatype declaration _only_ inside the scope of a function?
20:24:58 * hackagebot gtksourceview3 0.13.1.1 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.1 (HamishMackenzie)
20:29:59 * hackagebot gtksourceview2 0.13.1.1 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.13.1.1 (HamishMackenzie)
20:35:46 <lisbeth> I am trying to experiment with the shell "hell" though i am having trouble getting it working
20:35:59 <lisbeth> Does anybody have experience using hell who can lend me a hand?
20:37:11 <lisbeth> Or plush.
20:37:15 <lisbeth> Similar technologies.
20:40:00 * hackagebot webkitgtk3 0.13.0.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.0.3 (HamishMackenzie)
20:55:02 * hackagebot webkit 0.13.0.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.0.3 (HamishMackenzie)
21:04:19 <codygman> Can I catch all exceptions of a function (say getDirectoryContents) and return Maybe depending on whether an exception was raised? No exceptions return Just [FilePath], an exception returns Nothing.
21:08:11 <simon_> codygman, have you looked at http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception.html ?
21:09:01 <codygman> simon_: Yes, though it's not apparent which of those I could use. My intution told me I could use catch or handle. I'll give it a second look.
21:09:06 <joelteon> codygman: so that will make ctrl-c a no-op
21:09:08 <joelteon> are you sure you want to do that
21:09:17 <joelteon> well, *assuming your function is executing at the time
21:09:46 <codygman> joelteon: You are right, I just want to make a handful of exceptions (those thrown by getDirectoryContents) return a Maybe value.
21:10:45 <joelteon> okay, so if you're getting the contents of a huge directory, and the user presses Ctrl-C, your function returns Nothing and the program continues running. Is that what you want?
21:11:26 <codygman> joelteon: Yes, I'm actually just using this for scripting/learning purposes.
21:11:53 <joelteon> are you planning to use this information in the future for similar purposes?
21:12:52 <codygman> joelteon: Really I've just been playing around with this snippet: filter (/= "") <$> fmap (drop 6 . replace "_" "-") <$> getDirectoryContents "/home/cody/test" >>= mapM_ putStrLn
21:13:12 <codygman> and wanted to make getDirectoryContents return a just or nothing because short circuiting
21:13:34 <codygman> that won't be useful in practice probably, but useful to my brain
21:15:04 * hackagebot webkitgtk3-javascriptcore 0.13.0.2 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.0.2 (HamishMackenzie)
21:15:06 * hackagebot webkit-javascriptcore 0.13.0.2 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.13.0.2 (HamishMackenzie)
21:19:48 <dramforever> I'm wondering, in http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/typed-holes.html
21:19:54 <dramforever> the last example
21:20:05 * hackagebot gtk3-mac-integration 0.3.0.1 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.0.1 (HamishMackenzie)
21:20:07 * hackagebot gtk-mac-integration 0.3.0.1 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.3.0.1 (HamishMackenzie)
21:20:28 <dramforever> Why the second warning message has a "Arising from" line, while the first doesn't
21:30:14 <redtricycle> OK, the b64 library looks cool but it only works on Strings.  How do I translate a hex string into a String?
21:31:01 <simon_> what's a hex string?
21:32:01 <redtricycle> hex->decimal->ascii representation
21:32:03 <redtricycle> encoded
21:32:20 <redtricycle> working through these challenges...i am on challenge #1 -_-
21:32:20 <redtricycle> http://cryptopals.com/sets/1/challenges/1/
21:32:56 <dramforever> redtricycle you mean "4a 4a" -> [65,65] ->  "AA"?
21:33:00 <dramforever> > chr 65
21:33:03 <lambdabot>  'A'
21:35:06 * hackagebot json-rpc-server 0.1.2.0 - JSON RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.2.0 (grayjay)
21:36:10 <redtricycle> ya, i think that's what I want, ok!  on the right path
21:37:04 <dramforever> redtricycle: the page says "no encoded strings"
21:37:15 <redtricycle> well, I figured if I used a ByteString
21:37:19 <redtricycle> that effectively works on bytes, right?
21:37:23 <dramforever> yep
21:37:36 <redtricycle> i was originally doing it from Hex -> binary -> b64
21:37:45 <redtricycle> but I couldn't figure it out...so baby steps
21:37:51 <dramforever> redtricycle: does efficiency matter?
21:37:59 <redtricycle> no, i'm doing this to learn haskell
21:39:14 <redtricycle> http://lpaste.net/112822
21:39:27 <redtricycle> trying to get from hex_string -> ascii_bs
21:39:56 <dramforever> redtricycle: try to make a function ByteString -> (Word8, ByteString)
21:40:16 <dramforever> or ByteString -> Maybe (Word8,  ByteString)
21:40:38 <redtricycle> Why Word8?
21:40:54 <dramforever> the ByteString library wants it
21:41:37 <dramforever> it should take the first two bytes of the bytestring, then try to decode it. If successful return Just (decodedByte, unconsumedPart), if fail or no more input return Nothing
21:42:00 <redtricycle> ah, so I need to encode my hex_string into a ByteString
21:42:08 <redtricycle> I could just do B.pack then
21:42:15 <dramforever> you know what's "Maybe", right?
21:42:36 <redtricycle> i don't understand it
21:43:02 <dramforever> redtricycle: no pack is not what you want
21:43:58 <dramforever> redtricycle: you need to decode hex yourself
21:45:07 <dramforever> let me see...
21:45:51 <dramforever> > Data.ByteString.take 2 ("afbc5d4e" :: Data.ByteString.ByteString)
21:45:57 <lambdabot>  mueval-core: Time limit exceeded
21:46:37 <dramforever> > Data.ByteString.take 2 ("afbc5d4e" ::  Data.ByteString.ByteString)
21:46:43 <lambdabot>  mueval-core: Time limit exceeded
21:46:56 <dramforever> > Data.ByteString.break 2 ("afbc5d4e" ::  Data.ByteString.ByteString)
21:47:01 <lambdabot>  mueval-core: Time limit exceeded
21:47:05 <dramforever> huh?
21:47:07 <dramforever> > 1+1
21:47:09 <lambdabot>  2
21:47:28 <dramforever> > BS.break 2 ("afbc5d4e" :: BS.ByteString)
21:47:31 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
21:47:31 <lambdabot>              with actual type ‘[GHC.Types.Char]’
21:47:56 <dramforever> > BSC.break 2 (BSC.pack "afbc5d4e")
21:48:02 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Char -> GHC.Types.Bool))
21:48:02 <lambdabot>    arising from the literal ‘2’
21:48:15 <dramforever> > BSC.splitAt 2 (BSC.pack "afbc5d4e")
21:48:20 <lambdabot>  mueval-core: Time limit exceeded
21:48:28 <dramforever> huh? why?
21:48:34 <redtricycle> i saw another solution use Numeric and showHex
21:48:47 <redtricycle> http://stackoverflow.com/questions/8412398/pretty-print-bytestring-to-hex-nibble-wise
21:48:56 <redtricycle> but i want the opposite of that
21:49:24 <dramforever> Hey, you can assume ascii and operate like this...
21:49:35 <dramforever> Wait I'll try it myself first
21:50:24 <dramforever> > ord 'a'
21:50:27 <lambdabot>  97
21:51:05 <dramforever> > B.splitAt 2 (B.pack [97, 98, 97, 98, 97, 98])
21:51:09 <lambdabot>  Not in scope: ‘B.splitAt’
21:51:09 <lambdabot>  Perhaps you meant one of these:
21:51:09 <lambdabot>    ‘BS.splitAt’ (imported from Data.ByteString),
21:51:09 <lambdabot>    ‘BSL.splitAt’ (imported from Data.ByteString.Lazy),
21:51:09 <lambdabot>    ‘BSC.splitAt’ (imported from Data.ByteString.Char8)Not in scope: ‘B.pack’
21:51:15 <dramforever> > BS.splitAt 2 (BS.pack [97, 98, 97, 98, 97, 98])
21:51:16 <lambdabot>  ("ab","abab")
21:51:29 <dramforever> I think in lambdabot BS means Data.ByteString
21:51:58 <dramforever> BS.head (BS.pack [97, 98, 97, 98, 97, 98])
21:52:06 <dramforever> > BS.head (BS.pack [97, 98, 97, 98, 97, 98])
21:52:13 <lambdabot>  mueval-core: Time limit exceeded
21:52:44 <dramforever> > BS.uncons $ BS.pack [97, 98, 97, 98, 97, 98]
21:52:46 <lambdabot>  Just (97,"babab")
21:54:08 <dramforever> redtricycle: You've not learnt about Maybe yet?
21:54:47 <redtricycle> i've read about it lots, but havent used it
21:54:57 <redtricycle> so, why can't I go straight from hex into ascii?
21:55:02 <dramforever> ?
21:55:09 <dramforever> you can
21:55:10 <redtricycle> Or all the libraries go hex->dec->chr
21:55:27 <dramforever> redtricycle: well, show me one of them
21:56:13 <dramforever> redtricycle: did you learn about the maybe monad?
21:56:17 <redtricycle> i havent
21:56:20 <redtricycle> how would I use it here?
21:58:19 <dramforever> decodeFirstTwoBytes s = do { (c1, s') <- BS.uncons s; (c2, s'') <- BS.uncons s'; return (makeWord8FromTwoWord8ByDecodingThemAsAscii c1 c2, s'')}
21:58:42 <dramforever> because:
21:58:45 <redtricycle> > splitEvery 2 "49276d"
21:58:45 <dramforever> :t BS.uncons
21:58:47 <lambdabot> BSC.ByteString -> Maybe (Word8, BSC.ByteString)
21:58:48 <lambdabot>  ["49","27","6d"]
21:58:56 <redtricycle> That's the Word8
21:59:06 <redtricycle> Maybe (Word8, ByteString) you were talking about dramforever
21:59:13 <dramforever> yep
21:59:31 <dramforever> well, I was talking about a efficient solution
21:59:36 <dramforever> let me see..
21:59:43 <dramforever> :t splitEvery
21:59:44 <lambdabot> Int -> [e] -> [[e]]
21:59:56 <dramforever> Hmm, so:
22:00:20 <redtricycle> Can I do...
22:00:30 <redtricycle> map read ["49","27","6d"]
22:00:34 <redtricycle> > map read ["49","27","6d"]
22:00:34 <dramforever> > splitEvery 2 [(97::Word8), 98,97,98,97,98,97,98]
22:00:40 <lambdabot>  can't find file: L.hs
22:00:40 <lambdabot>  [[97,98],[97,98],[97,98],[97,98]]
22:00:49 <dramforever> > splitEvery 2 [(97::Word8), 98,97,98,97,98,97,98]
22:00:51 <lambdabot>  [[97,98],[97,98],[97,98],[97,98]]
22:01:17 <dramforever> redtricycle: you just need a decodeTwoBytes [Word8] -> Word8
22:01:30 <dramforever> that, as the name says, decodes two bytes
22:02:01 <dramforever> and map decodeTwoBytes (splitEvery 2 bytes) where bytes has type [Word8]
22:02:09 <dramforever> :t BS.unpack
22:02:11 <dramforever> :t BS.pack
22:02:12 <lambdabot> BSC.ByteString -> [Word8]
22:02:12 <lambdabot> [Word8] -> BSC.ByteString
22:02:34 <dramforever> there you go, bytestrings <-> list of word8
22:03:14 <dramforever> BS.pack (map decodeTwoBytes (splitEvery 2 (BS.unpack bytes)))
22:03:22 <shelf> is there a working browser-based haskell interpreter
22:03:30 <dramforever> redtricycle: that's probably what you want
22:03:39 <shelf> i can't figure out if tryhaskell etc is running on a server somewhere with mueval or if it's javascript
22:03:43 <redtricycle> hmmmmmmmm
22:03:54 <dramforever> shelf: I remember a very simple one that was called hs.js
22:03:59 <dramforever> let me see
22:06:46 <dramforever> shelf: well, I can't find it anymore
22:06:58 <dramforever> and FYI tryhaskell is on a server
22:10:57 <shelf> ah yeah. thanks for looking! I couldn't find any either
22:11:10 <shelf> seems depending on mueval etc is the way to go
22:14:30 <redtricycle> success! dramforever using an inefficienct way
22:31:55 <structuralist> I'm reading Parallel and Concurrent Programming in Haskell and one sentence is confusing me
22:32:09 <structuralist> http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
22:32:17 <structuralist> "An exception raised by a second blocking operation would not result in after being executed."
22:32:20 <structuralist> Why is this?
22:33:12 <structuralist> i.e. when calling bracket x y z, if x blocks twice and receives an asynchronous exception the second time, then z doesn't get executed
22:33:32 <structuralist> If I've understood correctly, why not?
22:33:38 <merijn> structuralist: Because blocking operations unmask to avoid deadlocks
22:33:53 <merijn> structuralist: So if you block on the first operation it either 1) succeeds or 2) gets interrupted
22:34:30 <structuralist> and in case (1) it will unmask?
22:34:37 <merijn> structuralist: If you block *twice*, the first operation may succeed while the second gets interrupted, thus the allocation is partially succesful and after doesn't get called because the code doesn't happen that far
22:34:51 <merijn> structuralist: No, while blocked async exceptions still happen
22:35:02 <merijn> structuralist: Imagine I do "takeMVar" twice
22:35:15 <merijn> structuralist: Both may block and *while* blocked, may be interrupted
22:35:32 <merijn> if the first blocks and I get interrupted, it's just like I got interrupted before blocking and all is fine
22:36:00 <merijn> structuralist: Now, if I get blocked the *second* takeMVar, I can get interrupted *after* emptying the first MVar, so now my blocking acquire is non-atomic
22:37:15 <merijn> structuralist: But async exceptions are fraught with complexities. For example, a few weeks ago we had a discussion on the masking behaviour of bracket on the libraries mailing list where even Simon (the author of that book) concluded he has a bug due to the subtle wrongness of the current bracket
22:39:38 <structuralist> merijn: ok, I follow you up through the second takeMVar being interrupted implying that there's a non-atomic resource acquisition
22:40:46 <structuralist> oh wait, is it the case that the cleanup doesn't get executed at all if there's an async exception during the acquisition?
22:40:54 <merijn> structuralist: Correct
22:41:10 <merijn> structuralist: Because the cleanup handler isn't installed until "before" finishes execution
22:42:03 <Axman6> I missed the beginning of this, but this seems like a discussion where STM is the answer
22:42:04 <platz> so basically before needs to be atomic
22:42:52 <merijn> platz: It can have at most 1 blocking operation
22:43:29 <structuralist> also nothing before the block in before can need to be undone by after
22:43:32 <structuralist> right?
22:43:32 <merijn> Axman6: Not always, sometimes you need non-atomic brackets without STM, in which case the solution is nested brackets instead of compound "before" actions
22:43:49 <merijn> structuralist: define "can be undone"
22:44:03 <platz> if the first blocking opeation doesn't need to be cleaned up so, it seems like it should still be ok
22:44:14 <structuralist> can *need* to be undone, i.e. don't do anything dangerous before a block in before
22:44:22 <platz> although now i'm creating nonsense scenarios
22:44:36 <merijn> structuralist: There's very little "dangerous" non-blocking operations :)
22:44:46 <structuralist> merijn: I was about to ask what those could possibly be
22:44:48 <merijn> platz: Sure, but that's very unlikely :)
22:45:27 <platz> the critical thing was the "partial" success
22:45:51 <platz> hence why I likened it to 'atomiticy'
22:45:52 <structuralist> (Is all this async exception stuff considered solved in Haskell? It seems way harder than the Haskell I'm used to.)
22:46:11 <platz> but the no 2 blocking rule makes perfect sense
22:47:23 <Axman6> merijn: right, yeah I missed the original problem
22:48:55 <merijn> structuralist: No, not really
22:49:01 <merijn> structuralist: It's still hard in haskell
22:50:26 <platz> I think C# has the concept of canacellation tokens which is similar to async exceptions
22:50:49 <platz> and it's supposed to be extremely difficult to get right
22:51:14 <merijn> It's not harder in haskell than other languages
22:51:21 <platz> do other languages just punt on this and not allow cancellation?
22:51:38 <merijn> And haskell makes all the *other* bits of concurrency easy, so this stands out more
22:51:58 <merijn> platz: Other languages make concurrency so hard that you basically don't even consider async communication at all
22:53:15 <structuralist> would it be possible/useful to explicitly track interruptibility in types, the way we track side effects?
22:53:37 <merijn> structuralist: Yes, but this is breaking new ground at the cutting edge of programming language research
22:53:39 <structuralist> my main difficulty is all the hidden ways the masking state changes
22:53:56 <platz> well there's always the option of killing a thread
22:54:04 <platz> but that's hardly an exception
22:54:10 <merijn> structuralist: Basically, concurrency is so hard in other languages, no a lot of people even noticed this was a problem before, because this approach was mostly unthinkable
22:54:47 <merijn> Unrelated question, what's a good category name that encompasses both tutorials, references and cheat sheets?
22:55:00 <platz> http://ruby-doc.org/core-2.0/Thread.html#method-c-handle_interrupt "Asynchronous interrupts are difficult to use."
22:55:11 <structuralist> merijn: guides?
22:56:15 <merijn> platz: But you don't really notice due to the rest also being hard ;)
22:56:16 <platz> learning/training material
22:57:29 <platz> maybe just 'documentation' though iffy on if tutorials fits
22:57:50 <structuralist> alright thanks for the help all
22:58:11 <jascase901> I wanna learn both haskell, and graphics programming at the same time. I have some experience with functional programming through scala. But that was a while ago. I have no graphics xp. Is  this a terrible idea, and an pointers on getting me started?
22:58:25 <platz> "training library"
22:59:33 <merijn> jascase901: It's not terrible, but a lot of graphics libraries tend to be fairly low level, which may be harder to follow without prior haskell experience
23:01:49 <jascase901> merijn alright im inspired thanks :)
23:02:01 <ddellacosta> hi folks, I'd like to make this code more idiomatic--if anyone could give me any constructive criticism I'd be most appreciative: https://gist.github.com/ddellacosta/64600ba27f44a1593a12
23:02:53 <ddellacosta> a few things I know I don't like: the way I'm using the Map in the let...also, seems like the way I'm using the Either is clumsy, especially in terms of what I want to do
23:04:05 <merijn> ddellacosta: It seems your implication can be simplified a lot
23:04:20 <ddellacosta> merijn: ah, yeah, was wondering if there wasn't a better way to do that too
23:04:27 <ddellacosta> merijn: any specific tips?
23:04:35 <merijn> "(==>) True False = False; (==>) _ _ = True"
23:04:54 <ddellacosta> merijn: ah, nice! gotcha
23:05:39 <structuralist> let a ==> b = not a || b
23:06:07 <structuralist> is lambdabot still a thing?
23:06:12 <structuralist> > let a ==> b = not a || b
23:06:15 <lambdabot>  not an expression: ‘let a ==> b = not a || b’
23:06:24 <structuralist> I don't remember how to use it
23:06:47 <merijn> structuralist: It only accepts expressions
23:06:53 <structuralist> > let a ==> b = not a || b in (True ==> True, True ==> False, False ==> True, False ==> False)
23:06:56 <lambdabot>  (True,False,True,True)
23:06:59 <merijn> structuralist: "let" without in is a do notation specific thing
23:07:24 <merijn> ddellacosta: I'm not really sure what the rest of the code is doing
23:08:01 <merijn> ddellacosta: (Bear in mind, I just got back from a "goodbye party", so any analysis of the code I can't do drunk is ignored :p)
23:08:06 <ddellacosta> merijn: well, what I'm trying to do is putting together all the possible values for a truth table of propositional constants (the list of maps)
23:08:12 <ddellacosta> merijn: ah, hahaha...understood. :-)
23:10:08 <ddellacosta> merijn: and then I have a bunch of specific propositions I'm substituting those constants out in, which I then try to figure out if I satisfy
23:10:27 <ddellacosta> I edited and added the critical line of code which I'm running in ghci that tests them all via map and filter
23:13:36 <merijn> ddellacosta: The code looks okay-ish, for something where I don't know what it's attempting :p
23:14:09 <ddellacosta> merijn: any suggestion specifically on how to do the function where I pull out all those values in the map and load them into the propositions?
23:14:15 <ddellacosta> just seems ugly to me
23:14:45 <merijn> ddellacosta: "looks ugly" is code for "needs more local definitions and better names"
23:15:12 <ddellacosta> I guess so
23:15:26 <ddellacosta> merijn: I guess what I'm also trying to ask is, is a map the right way to do this?  I dunno
23:16:28 <platz> why the usage of string instead of an ADT for alum,copper,etc..
23:23:22 <ddellacosta> platz: sorry, didn't see your message.  Yeah, so, I guess that's part of what I'm asking--no reason, other than being a novice Haskell programmer. So an ADT may be a better fit here?
23:23:53 <ddellacosta> platz: I guess that makes sense, making it a real type vs. a "stringly-typed" map may be better, huh
23:24:06 <ddellacosta> I just don't see all the implications yet
23:24:59 <platz> it's not a huge thing - just something to notice.  not sure about your overall architecture question though
23:25:55 <platz> one could do things to abstract away the map, but i'm not sure that's helpful in this case
23:28:08 <platz> maybe, if the data is really static you could just create functions which return the correct data without having to look it up
23:28:16 <platz> dunno, just guessing
23:30:44 <dramforever> Well, I think maybe you should use Maybe instead of Either (Map String Bool) Bool for showSatisfaction
23:31:49 <dramforever> and, propConstantSet could be changed into pcs
23:32:05 <dramforever> and so alum = pcs ! "alum"
23:34:36 <dramforever> ddellacosta: And, a map is *not* normally used as a data structure that has static keys
23:35:28 <dramforever> for example, in python, javascript, ruby, something like {"a":foo, "b":bar} to represent a data that has two fields called "a" and "b" is okay
23:35:33 <ddellacosta> dramforever: right, good point on the naming, it's just freaking long isn't it.  And Maybe makes more sense, doesn't it
23:35:47 <ddellacosta> dramforever: yeah, can you tell where I'm coming from? :-)
23:36:03 <dramforever> python?
23:36:16 <ddellacosta> dramforever: well, actually Clojure in this case, although I've done plenty of Ruby too, and a bit of Python
23:36:49 <ddellacosta> and we are all cursed by JavaScript
23:36:51 <dramforever> I thought some non-idiomatic-style code might tell me, but no
23:37:14 <dramforever> I think your haskell syntax style was great
23:37:40 <ddellacosta> dramforever: oh, good, glad to hear it.  I'm not a complete newbie I guess, and some elements of Clojure do carry over here, thankfully
23:37:41 <dramforever> ddellacosta: hey, on your function "satisfaction"
23:38:03 <dramforever> ddellacosta: well, found a problem
23:38:11 <ddellacosta> dramforever: ?
23:38:28 <dramforever> in your testSatisfaction function
23:38:35 <ddellacosta> (also wondering if the list comprehension is a good way to generate that propConstants list)
23:38:54 <dramforever> that's not the way haskellers write long, multi-line lists
23:39:24 <ddellacosta> dramforever: ah, what would be better?
23:40:00 <lpaste> dramforever pasted “This one is better” at http://lpaste.net/112825
23:40:16 <ddellacosta> dramforever: gotcha, thanks
23:40:28 <ddellacosta> reminds me of how a colleague used to write long SQL queries
23:40:41 <dramforever> well, on the big map
23:41:12 <dramforever> you made a map with list comprehesion, and then immediately destruct it
23:42:03 <ddellacosta> dramforever: yeah, basically, that is my way of generating a truth table easily
23:42:13 <ddellacosta> dramforever: would be interested in learning about alternatives to that
23:42:23 <ddellacosta> seems a bit obfuscated, I guess
23:42:42 <dramforever> ddellacosta: did you know that Data.Map does not do hashing?
23:43:31 <ddellacosta> dramforever: nope, I guess I should be using HashMap?
23:43:35 <dramforever> ddellacosta: do you know what O(log n) means?
23:43:42 <dramforever> ddellacosta: nope, let me finish this
23:43:42 <ddellacosta> dramforever: yes, definitely
23:44:09 <dramforever> in this case, each call to (!) compares O(log n) times
23:44:17 <dramforever> but, you are comparing strings!
23:44:27 <dramforever> that's way to slow
23:44:44 <dramforever> make it better:
23:44:56 <ddellacosta> dramforever: hmm, O(log n) for this doesn't seem too bad, since it's only ever going to be 128 hash-maps
23:45:00 <ddellacosta> er, maps...d'oh
23:45:14 <ddellacosta> dramforever: but...sorry, continue
23:45:21 <dramforever> ddellacosta: why not make it like this (wait I'll write it)
23:48:12 <dramforever> ddellacosta: do you know record syntax?
23:48:22 <ddellacosta> dramforever: yeah, I've used it a bit
23:48:27 <dramforever> data Re = Co { rd :: Syntax }
23:48:55 <dramforever> make your truth table a record like data TruthTable = TruthTable { alum :: Bool, ... }
23:49:21 <dramforever> but It's a bit boring to write...
23:49:27 <dramforever> I'm not sure...
23:49:54 <dramforever> but fromList [("alum", alum) ......] is also boring to write
23:50:04 <ddellacosta> dramforever: I guess, what I'm interested in is how that would help me--it seems like obviously it gives me more power than a map, in terms of being a real type
23:50:14 <dramforever> ddellacosta: much faster
23:50:43 <ddellacosta> dramforever: ah, okay, so a lookup is faster than O(log n) there?  closer to constant, maybe?
23:51:03 <dramforever> ddellacosta: a data record lookup is constant
23:51:14 <ddellacosta> okay, gotcha--good to know
23:51:17 <Hijiri> would it matter if it was in a map if you just had "thing = lookup/!/whateverindexthing Map stuff things"
23:51:25 <Hijiri> because then "thing" would only be evaluated once
23:51:35 <dramforever> like in C, struct { bool a,b,c...; }
23:51:35 <Hijiri> or maybe even not at all, if ghc optimizes that away
23:51:43 <dramforever> Hijiri: maybe not
23:51:55 <ddellacosta> Hijiri: yeah, I mean, obviously some of this is based on the realities of the data coming in
23:52:02 <dramforever> ddellacosta: hey you could use strict fields and unpack them, if you know what it means
23:52:31 <ddellacosta> dramforever: I don't know what unpack means, but I do know what strict means (assuming we're talking about laziness here)--is unpack like destructuring in Clojure?
23:52:41 <dramforever> ddellacosta: nope
23:52:44 <dramforever> it saves space
23:53:05 <dramforever> but you don't know about it let's talk about it later
23:53:22 <ddellacosta> dramforever: ha, okay, will put that one in the back of my mind for later research. :-)
23:55:12 <dramforever> ddellacosta: http://www.haskell.org/haskellwiki/Performance/Data_types see 3.2
23:56:17 <dramforever> (,,) <$> [True, False] <*> [True, False] <*> [True, False
23:56:21 <dramforever> > (,,) <$> [True, False] <*> [True, False] <*> [True, False]
23:56:25 <lambdabot>  [(
23:56:40 <dramforever> huh? just "[("???
23:57:42 <Axman6> o.O
23:57:49 <dramforever> ddellacosta: do you know applicative functors?
23:57:59 <ddellacosta> dramforever: I've gotta run for now...but thanks for all your help, I really appreciate it, I learned a lot
23:58:07 <ddellacosta> dramforever: oh, no, but I want to!!
23:58:29 <ddellacosta> dramforever: I'm only about as far as functors. although I have read a bit about applicative functors, it hasn't sunk in yet
23:58:37 <ddellacosta> dramforever: but sorry I have to go. :-(
23:58:38 <dramforever> it's okay
23:58:44 <ddellacosta> dramforever: again, thanks so much
23:58:51 <dramforever> you're welcome
