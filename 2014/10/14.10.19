00:00:04 <solatis> yeah
00:00:20 <solatis> and then ghc complains that i haven't built *any* library with profiling
00:00:23 <solatis> even Prelude
00:00:39 <johnw> how are you building?
00:00:55 <solatis> nix-env -i mypkgname
00:01:10 <johnw> with haskellPackages_ghc783_profiling.mypkgname?
00:01:19 <johnw> because if not, then how would you get profiling enabled?
00:01:25 <johnw> (and using -iA)
00:01:47 <solatis> i'm using myHaskellPackages
00:01:59 <johnw> can you show me some code?
00:02:16 <solatis> hold on
00:02:53 <solatis> nixos.pkgs.myHaskellPackages.tomatoesCore                                      haskell-tomatoes-core-ghc7.8.3-0.1.0-profiling-shared
00:03:16 <solatis> so if i refer to myHaskellPackages.tomatoesCore, one would say that it has profiling enabled
00:03:29 <johnw> hmm
00:03:56 <lpaste> solatis pasted “nixexpr for app” at http://lpaste.net/112877
00:04:07 <solatis> and see my nixexpr
00:04:14 <solatis> it uses the namespace myHaskellPackages
00:04:18 <fluffynukeit> hi all, is there any way to compile a Haskell module and include all module dependencies?  I want to load the haskell module with GHC API.  When I try it now, I get errors that GHC can't find Data.Text, Data.Vector.Storable, and I don't want to specify those deps manually.
00:04:21 <solatis> depends on tomatoesCore
00:04:36 <johnw> i've never really seen it done this way
00:04:41 <johnw> so it's hard for me to determine what's going wrong
00:05:03 <solatis> Fuuzetsu got angry if i did it any other way
00:05:26 <johnw> i just setup the expression like normal, but then install it underneath haskellPackages_ghc783_profiling
00:06:01 <solatis> i define myHaskellPackages in a general config.nix, and in debug i refer to the _profiling base
00:06:12 <johnw> that seems kind of convoluted
00:06:31 <johnw> let's try not doing it that awy
00:06:56 <johnw> regenerate your .nix file with cabal2nix, and let's do something different
00:06:59 <johnw> and le'ts move to #nixos
00:07:04 <solatis> https://github.com/Fuuzetsu/nix-project-defaults/blob/master/nixpkgs-config/config.nix#L112
00:38:05 <nezt> if you were in a situation where you had to deliver in a certain period of time on a web app, would you consider using warp / yesod
00:38:17 <nezt> or would you use python / node.js /java etc
00:38:36 <trap_exit> https://gist.github.com/anonymous/d9df9d5bd24f7217ecfe <-- is this all the info I get from a Haskell strack trace?
00:38:38 <trap_exit> is there a way to get more info?
00:38:43 <trap_exit> this seems somewhat ... ehh, sparse
00:38:51 <trap_exit> like ... where the f*ck is my line # ?
00:38:59 <nezt> i guess my question is how many haskellers use haskell for cranking out programs on the more practical side
00:39:22 <trap_exit> oh
00:39:25 <trap_exit> I use haskell for _everything_
00:42:51 <nullremains> nezt: what would be your alternative(s) to the haskell mainstays?
00:43:24 <merijn> nezt: Seems like a false dichotomy
00:43:43 <merijn> nezt: Yesod is not the only haskell web framework, and probably one of the trickiest to install for a beginner
00:44:21 <nezt> alright good point but that wasn't supposed to be a catch 22 , i just listed one of the haskell frameworks i could think of
00:45:41 <nezt> like if it was really crunch time on a project would you use something more mainstream or use haskell, is what i'm asking
00:46:51 <nezt> i'm not trying to insinuate anything i'm just curious how many of you are "enthusiasts" and how many really use haskell for big projects
00:47:07 <merijn> I'd use haskell, because I haven't done any web dev in other languages and I believe learning the relevant haskell libraries will be significantly easier than learning the libraries in any other language :)
00:47:42 <merijn> nezt: Well, there's plenty of people using haskell for big projects, although they might not be here
00:48:29 <nezt> no that's true but how many bay area startups are rolling with haskell
00:49:11 <nezt> like what are the poster child famous haskell applications
00:49:17 <merijn> I don't believe what bay area startups are doing has any valuable predictive power
00:49:30 <merijn> nezt: Xmonad and pandoc come to mind
00:49:56 <nezt> saying that human activity has "no predictive power" is obviously hyperbole
00:49:58 <merijn> There's also a haskell software-defined networking tool that is currently holding the world record in requests-per-second
00:50:24 <merijn> I think they got like 20 million reqs-per-second on a single 40 core machine?
00:50:44 <nezt> but who is _using_ it
00:50:48 <nullremains> merijn: Xmonad and pandoc are pretty weak selling points for the webapp argument
00:51:06 <nezt> is IBM using it? NSA? biotech?
00:51:10 <nezt> etc
00:51:28 <jle`> nezt: i use haskell to crank out programs on the more practical side...
00:51:33 <nullremains> not that yesod and snap aren't viable choices, however, in the right hands, either framework will fit the bill
00:51:47 <merijn> Silk is doing haskell startup stuff
00:51:48 <jle`> crank out doesn't mean pop out an unmaintainable mess in one day
00:51:54 <jle`> or on a startup bus
00:52:13 <jle`> how about making a maintainable codebass with guarunteed correctness in a very reasonable and business friendly amount of time
00:52:19 <jle`> ...codebass
00:52:21 <jle`> codebase
00:52:24 <merijn> nullremains: Frankly, I think the whole "webapp" thing can go sink in a swamp, so I know jack about who's doing what there
00:53:03 <jle`> i've used haskell for a couple of my web servers and it has served me pretty well.
00:53:09 <jle`> *web stuff
00:53:20 <jle`> the biggest benefit i've found is maintainability
00:53:26 <nezt> nice. interesting
00:53:33 <jle`> if i drop a ruby or python project for a month or six months
00:53:36 <jle`> and i come back to it
00:53:44 <jle`> there is no way i'm going to be able to get back up to speed
00:53:51 <jle`> not without at least a week or two of figuring everything out again
00:53:52 <gfixler> jle`: do you think that's mostly purity?
00:54:02 <jle`> in haskell, you pick it up immediately, with almost no uncertainty
00:54:18 <gfixler> I've found code rot for me is often due to side effects
00:54:20 <jle`> and you can make changes knowing that you aren't breaking anything
00:54:34 <gfixler> sqrt(9) never breaks - math is immortal
00:54:36 <jle`> for me it is more of the type system protecting me from making architecture breaing mistakes
00:54:43 <jle`> and also as a sort of documentation
00:54:43 <gfixler> a
00:54:44 <nullremains> merijn: heh, haskell's niche is not yet web based, no problem with that, it's kicking ass in financial services
00:54:44 <gfixler> ah*
00:55:09 <jle`> if you want a web framework that you can leave alone and pick up again in three, six months...haskell is the only thing i can think of that is reaosnable
00:55:48 <jle`> switching was like night and day
00:56:54 <nullremains> jle`: certainly C#/F# and Scala baseed frameworks would be suitable in the get back up and running department ;-)
00:57:06 <gfixler> jle`: I've been doing Python for 5 years now, always with code rot
00:57:24 <u-ou> jle`: what you said is so true
00:57:27 <gfixler> but then started doing TDD, and the dozen libraries I've created under TDD have had no bugs
00:57:36 <jle`> haven't used C#, but if it's anything like java, i don't think it can cover things with the same power that haskell does
00:57:48 <jle`> s/anything/like
00:57:54 <gfixler> so there are ways to achieve some of that maintainable power, but types seem even more convenient
00:58:55 <gfixler> so, TDD works very well for me, but it's a lot more tedious than what I've experienced so far with Haskell
00:59:26 <gfixler> looking back through my tests, a large percentage of them would go away if I had a type system
00:59:57 <gfixler> and I'm simply throwing up my hands when it comes to guarding against bad types passed to functions
01:02:29 <jle`> i think one neat thing about the type system is that guaruntees more than just that you're passing in the right types, but it can guaruntee statements about the behavior of your functions too
01:03:21 <gfixler> e.g. that a -> a can only be identity
01:03:23 <gfixler> ?
01:03:47 <jle`> kinda like that :P
01:04:00 <simpson> Or undefined :3
01:04:07 <gfixler> d'oh
01:04:12 <_ikke_> (+1) has type a -> a too, right?
01:04:25 * hackagebot neil 0.4 - General tools for Neil  http://hackage.haskell.org/package/neil-0.4 (NeilMitchell)
01:04:27 <jle`> but the range and expressiveness of what you can say is betrayed, i think, by presenting "a -> a" as a simple example
01:04:29 <gfixler> isn't undefined a member of all types?
01:04:43 <jle`> _ikke_: when we say (a -> a), we mean "a function that can take *any* a and return something of the same type back"
01:04:52 <jle`> at least, in this case.
01:04:55 <johnw> gfixler: it is
01:05:12 <_ikke_> jle`: right
01:05:19 <jle`> so (+1) is not such a thing
01:05:30 <_ikke_> I get the point
01:05:30 <jle`> because we can't pass it something that is not an instance of Num
01:05:32 <jle`> ah
01:06:24 <gfixler> was bottom designed to look like someone giving me the middle finger?
01:06:48 <jle`> you can lump in undefined in general with non-terminating expressions
01:07:14 <johnw> gfixler: it's an upside-down T
01:07:26 <gfixler> johnw: ah, that makes sense
01:07:37 <johnw> they are both symbols from the terminology of lattices
01:08:15 <johnw> "The greatest and least element (of a lattice) is also called the maximum and minimum, or the top and bottom element, and denoted by ⊤ and ⊥, respectively."
01:08:34 <gfixler> interesting
01:08:44 <johnw> types can be arranged in a lattice of "definedness"
01:08:52 <nullremains> jle`: perhaps, but the ecosystem of .NET blows away that of haskell on the web front (as does scala and the JVM for that matter) ;-)
01:09:03 <johnw> or rather, inhabitants
01:09:14 <jle`> :t \x -> fix id `asTypeOf` x
01:09:15 <lambdabot> a -> a
01:09:45 <jle`> oh
01:09:46 <johnw> gfixler: there's a good picture of what I mean here: http://stackoverflow.com/questions/6379458/the-concept-of-bottom-in-haskell
01:09:49 <jle`> :t \x -> fix (asTypeOf x)
01:09:50 <lambdabot> a -> a
01:10:04 <jle`> :t fix . asTypeOf
01:10:05 <lambdabot> c -> c
01:10:10 <jle`> > fix . asTypeOf $ 5
01:10:12 <lambdabot>  5
01:10:17 <johnw> as such, the lattice for any type has at its bottom, well, bottom :)
01:10:22 <jle`> i don't know what i was trying to prove by that...
01:10:55 <gfixler> johnw: yay, graphs
01:11:05 <jle`> oh i remember now
01:11:12 <jle`> :t \x -> fix id `asTypeOf` x
01:11:13 <lambdabot> a -> a
01:11:19 <jle`> > (\x -> fix id `asTypeOf` x) 5
01:11:23 <lambdabot>  mueval-core: Time limit exceeded
01:11:27 <jle`> not id
01:11:29 <jle`> sad ;_;
01:12:54 <gfixler> jle`: I just heard of fix in here earlier today
01:13:08 <gfixler> it felt like solving a problem with a layer of indirection
01:13:42 <jle`> oh okay here is a less contrivued example
01:13:51 <jle`> :t notid x = notid (notid x)
01:13:53 <lambdabot> parse error on input ‘=’
01:14:00 <jle`> :t let notid x = notid (notid x) in notid
01:14:01 <lambdabot> t -> t
01:14:09 <trap_exit> OMG
01:14:11 <jle`> > let notid x = notid (notid x) in notid 5
01:14:13 <trap_exit> why does http://hackage.haskell.org/package/haskell-src-exts-1.16.0/docs/Language-Haskell-Exts-Parser.html#t:ParseResult take String rahter than Text ?
01:14:17 <lambdabot>  mueval-core: Time limit exceeded
01:14:26 <trap_exit> is it beucause Parsing is so slow that the slowdown of String is irrelevant ?
01:14:45 <benmachine> trap_exit: it's probably just that no-one's made performance a priority for HSE yet
01:15:10 <benmachine> possibly happy/alex predate Text
01:15:11 <trap_exit> but suppose that parsing is not lienar time
01:15:16 <trap_exit> then does using String even matter?
01:15:22 <trap_exit> oh, HSE is based on happy/alex ?
01:15:25 <benmachine> I think so
01:15:53 <benmachine> definitely at least happy
01:16:15 <benmachine> probably just happy
01:26:48 <jle`> > iterate f x
01:26:49 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
01:33:05 <u-ou> :o
01:34:36 <u-ou> oh is that simple reflect
01:34:41 <u-ou> or what it's called
01:37:01 <benmachine> yes
01:37:19 <benmachine> it's a simple idea
01:37:30 <benmachine> a pretty clever one
01:37:37 <u-ou> yeah, it's great
01:37:38 <benmachine> but actually quite easy to implement
01:37:51 <gfixler> why doesn't instance (Eq a) => Eq [a] require a condition for when only one list is empty?
01:37:51 <benmachine> if you already have the idea
01:38:04 <benmachine> gfixler: because if only one list is empty they are not equal?
01:38:45 <gfixler> benmachine: but there's no otherwise clause
01:38:48 <benmachine> gfixler: or are you talking about a particular implementation
01:38:49 <benmachine> ah
01:38:56 <benmachine> what code are you looking at?
01:39:01 <gfixler> benmachine: watching an SPJ talk from '07
01:39:06 <gfixler> History of Programming Languages
01:39:12 <benmachine> oh
01:39:36 <gfixler> he just has [] == [] = True and (x:xs) == (y:ys) = (x == y) && (xs == ys)
01:39:49 <gfixler> would the second pattern match when only one list is empty?
01:39:53 <benmachine> no
01:39:55 <Hijiri> nope
01:39:58 <gfixler> I didn't think so
01:40:01 <benmachine> he needs three patterns
01:40:01 <gfixler> is it just missing some cases here?
01:40:07 <benmachine> yes
01:40:11 <gfixler> ok
01:40:17 <benmachine> you'd want _ == _ = Flase
01:40:19 <benmachine> er
01:40:21 <benmachine> False
01:40:25 <gfixler> it's not really critical here - he's just talking historical stuff
01:40:29 <gfixler> but I felt like I was missing something
01:40:39 <gfixler> yeah, a final catch-all
01:45:53 <jle`> @src (==) []
01:45:53 <lambdabot> Source not found. Do you think like you type?
01:46:06 <jle`> @src [] (==)
01:46:06 <lambdabot> []     == []     = True
01:46:06 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
01:46:06 <lambdabot> _      == _      = False
01:46:17 <jle`> gfixler:
01:47:14 <gfixler> jle`: yay
01:47:16 <gfixler> that's better
01:47:37 <gfixler> to be fair, SPJ was kind of out of room on that slide
01:47:56 <trap_exit> String -> IO (String)
01:48:06 <trap_exit> what's the builtin for "here's a path, go read the fiile for me" ?
01:48:35 <jle`> @hoogle String -> IO String
01:48:39 <lambdabot> System.Environment getEnv :: String -> IO String
01:48:39 <lambdabot> Prelude readFile :: FilePath -> IO String
01:48:39 <lambdabot> System.IO readFile :: FilePath -> IO String
01:48:43 <jle`> @hoogle FilePath -> IO String
01:48:43 <lambdabot> Prelude readFile :: FilePath -> IO String
01:48:43 <lambdabot> System.IO readFile :: FilePath -> IO String
01:48:43 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
01:48:45 <jle`> ya
01:49:09 <trap_exit> System.IO.ReadFile
01:49:15 <trap_exit> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:readFile
01:49:19 <trap_exit> damn it, jle` beat me to it
01:49:22 <trap_exit> jle`++
01:49:26 <jle`> hoogle beat both of us
01:49:46 <trap_exit> that's like saying jle` doesn't kill people, bullets kill people
01:50:21 <jle`> um i feel like both agreeing or disagreeing to that would implicate me in something in some way
01:52:19 <trap_exit> jle`: so you're saying (if x then jle` is guilty else jle` is guilty)
01:52:35 <trap_exit> so your only hope is if x infinite loops
01:53:15 <jle`> yes, i'd like the third member of Bool, bottom.
01:53:35 <gfixler> we're never going to get to the bottom of this jle` case
01:55:25 <trap_exit> gfixler++
01:55:58 <trap_exit> someone shoudl do haskell stand up comedy
01:56:09 <trap_exit> the entire world wide audience base is already reachable via #haskell
01:56:43 <mayski> what's the DEAL with monads *seinfeldvoice*
01:57:11 <trap_exit> https://gist.github.com/anonymous/d15d079282e00371096e <-- is there anyway to get more out o the stack trace from this?
01:57:11 <gfixler> my curry jokes did well in here recently
01:57:21 <trap_exit> either there's more info I'm not getting, or I'm not reading these stack traces properly
01:57:37 <trap_exit> mayski: go on
01:57:54 <trap_exit> then I want to hear gfixler's curry joke
01:58:08 <mayski> I got nothing
01:58:27 <trap_exit> gfixler: you're up next
01:58:31 <trap_exit> go :-)
01:58:58 <gfixler> I'm forgetting the particulars now :(
01:59:08 <gfixler> something about wanting work at my local curry place, and filling out a partial application
01:59:23 <gfixler> and the guy asked if I was lazy, and I said no, so he kicked me out
01:59:39 * trap_exit shuts down the haskell comedy club and refunds everyone their tickets
01:59:46 <gfixler> hehe
01:59:47 <jle`> mayski: it looks like you're in quite a bind
01:59:54 <mayski> ahah
02:00:54 <trap_exit> I get gfixler's joke now
02:00:59 <trap_exit> gfixler doesn;'t give you a joke
02:01:08 <trap_exit> he gives you a thunk, which you have to evalutte to fill in the details to get the joke
02:01:28 <jle`> there's that haskell webcomic, cartesian closed comic
02:01:51 <gfixler> jle`: I think benzrf sent me a link to a comic that was pretty much exactly my joke
02:04:31 * hackagebot HTF 0.12.2.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.2.1 (StefanWehr)
02:08:40 <trap_exit> damn it
02:08:46 <trap_exit> so a piece of library code I'm using is throwing exceptions
02:08:51 <trap_exit> how do I catch it? and deal with it?
02:09:22 <trap_exit> https://gist.github.com/anonymous/fd26a51df10796368de1 is all the info I'm getting
02:09:31 <trap_exit> and I want to figure out how to catch + deal with this exception
02:13:15 <kazagistar> damn, I had to reread the curry shop joke 3 times, wtf
02:13:39 <kazagistar> that made me feel more stupid then #haskell usually does
02:17:53 <benmachine> trap_exit: I've never tried using backtraces, what does it say if you don't?
02:18:26 <trap_exit> I have no idea waht I'm dpoing
02:18:29 <trap_exit> how do I disable backtraces?
02:18:35 <trap_exit> I just looked at some docs, and copy/pasted stuff
02:18:41 <benmachine> I have no idea what you're doing either
02:18:46 <benmachine> did you run +RTS -xc?
02:18:51 <benmachine> leave that bit off
02:19:32 * hackagebot hourglass 0.2.6 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.6 (VincentHanquez)
02:19:48 <benmachine> also where are you getting that compilation command from
02:20:21 <trap_exit> that cmpilatiogn command?
02:20:24 <trap_exit> it's from my Makefile
02:20:28 <trap_exit> all the -X are extensions I needed
02:20:41 <trap_exit> and the -prof =-auto-call -caf-call was the supposed profiling stuff I needed to get useful backtraces
02:20:58 <benmachine> oh
02:21:20 <benmachine> usually you don't need -Xblah because you have {-# LANGAUGE blah #-} at the top of your file
02:21:23 <trap_exit> what?
02:21:28 <trap_exit> exception vanished
02:21:32 <benmachine> awesome.
02:21:34 <trap_exit> when i run ./Main instead
02:21:36 <trap_exit> there's no exception
02:21:37 <trap_exit> wtf
02:21:51 <ClaudiusMaximus> -xc reports when an exception is thrown, it could be caught later
02:22:42 <trap_exit> ./Main +RTS = no exception either
02:22:54 <benmachine> that's because ./Main +RTS doesn't do anything
02:23:02 <benmachine> +RTS says "the next options are RTS options"
02:23:17 <trap_exit> lol
02:23:32 <trap_exit> so this means that my code is throwing an exception, but it's not being caught?
02:23:51 <trap_exit> maybe I should make a minimal failure case
02:24:25 <ClaudiusMaximus> it is being caught, if you don't get a "***Exception: foo" printout and a prematurely ending thread
02:24:33 * hackagebot asn1-types 0.3.0 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.3.0 (VincentHanquez)
02:24:35 * hackagebot asn1-encoding 0.9.0 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.9.0 (VincentHanquez)
02:24:37 * hackagebot asn1-parse 0.9.0 - Simple monadic parser for ASN1 stream types.  http://hackage.haskell.org/package/asn1-parse-0.9.0 (VincentHanquez)
02:24:39 * hackagebot crypto-pubkey-types 0.4.2.3 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.2.3 (VincentHanquez)
02:26:59 <ClaudiusMaximus> actually the ***Exception is a ghci thing i think, with a small test i got "t.hs: user error (Pattern match failure in do expression at t.hs:4:3-8)"
02:34:34 * hackagebot x509 1.5.0 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.5.0 (VincentHanquez)
02:34:36 * hackagebot x509-store 1.5.0 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.5.0 (VincentHanquez)
02:34:38 * hackagebot x509-system 1.5.0 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.5.0 (VincentHanquez)
02:34:40 * hackagebot x509-validation 1.5.1 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.5.1 (VincentHanquez)
02:34:42 * hackagebot x509-util 1.5.2 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.5.2 (VincentHanquez)
02:36:21 <YurasS> hm, is there way to see a list more then 20 recently uploaded packages on hackage?
02:36:56 <gfixler> what is the . in (\x. f x) ?
02:37:01 <YurasS> probably 20 items was enough 3 years ago, but now it is not
02:37:50 <YurasS> gfixler: probably lambda calculus snippet?
02:38:13 <gfixler> I've seen it a few times, and just now here: http://www.haskell.org/pipermail/haskell-cafe/2010-December/087783.html
02:38:33 <mauke> yep, lambda calculus
02:38:55 <YurasS> @google lambda calculus
02:38:55 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
02:38:55 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
02:39:09 * YurasS likes lambabot :)
02:39:34 * hackagebot tls 1.2.10 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.10 (VincentHanquez)
02:39:51 <YurasS> gfixler: that is just \x -> x f, but written mathimatically
02:40:05 <gfixler> YurasS: oh, okay - that's what I guessed
02:43:13 <benmachine> although ofc true lambda calculus would be (λx. f x)
02:43:23 <jle`> that's just backslash calculus
02:44:29 <gfixler> someone at my haskell meetup had trouble remembering slash from backslash
02:45:00 <gfixler> I suggested new names - conservative slash (/) and liberal slash (\)
02:45:25 <gfixler> so it's more obvious which way they lean
02:54:07 <jle`> :P
02:54:44 <pjdelport> gfixler: How would you localize that to non-USAnian, though?
03:01:34 <trap_exit> https://gist.github.com/anonymous/8c685a1d8ea153394ae0 <-- WTF is wrong? why is there an exception being thrown? wtf am I doing wrong?
03:02:09 <trap_exit> https://gist.github.com/anonymous/e97284121192971861f9 <-- with Makefile
03:02:14 <trap_exit> wtf am I doing wrong? why is there an exception?
03:03:40 <ClaudiusMaximus> trap_exit: probably LHEA is throwing (and catching) an exception during its internal workings, nothing to worry about
03:04:07 <trap_exit> oh
03:04:12 <trap_exit> that actually makes sense
03:04:17 <trap_exit> how can I test it?
03:04:28 <trap_exit> how do I create a minimal try / throw / catch and see how -xc views it?
03:04:34 <trap_exit> I don't doubt you, I just want to veirfy it for myself.
03:06:17 <mauke> "The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution)"
03:08:29 <mauke> :t throwIO
03:08:30 <lambdabot> Exception e => e -> IO a
03:08:40 <mauke> :t throwIO Overflow
03:08:41 <lambdabot> IO a
03:09:15 <mauke> :t throwIO Overflow `catch` \SomeException{} -> putStr "caught\n"
03:09:17 <lambdabot> IO ()
03:09:54 <trap_exit> hmm
03:09:56 <trap_exit> I was reading https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
03:10:05 <trap_exit> but your examples looks shorter
03:12:53 <trap_exit> how do I fix this? https://gist.github.com/anonymous/306e103dd2af38885dd5
03:12:56 <lpaste> ClaudiusMaximus pasted “+RTS -xc behaviour” at http://lpaste.net/112880
03:13:22 <mauke> what's the problem?
03:14:01 <trap_exit> I'm retarded and did not read hte GHC suggestion
03:14:51 <trap_exit> ClaudiusMaximus / mauke: I have now verified that your hypothesis is correct.
03:14:54 <trap_exit> Thakns! :-)
03:15:21 <trap_exit> ClaudiusMaximus: looking at your code, what odes 'evaluate' do ?
03:15:29 <trap_exit> I see it alot in examples concerning exceptions, but I have no idea what it means
03:15:30 <mauke> oh, I clicked on the wrong link :-)
03:15:52 <trap_exit> and I missed the part where ghc is like "dumbass, by SomeException, did you mean Control.Exception.SomeException"
03:16:13 <trap_exit> would be kind of funny if ghc starts swearing at people
03:16:42 <mauke> evaluate (error ...) is a weird way to write throwIO (ErrorCall ...)
03:16:43 <ClaudiusMaximus> trap_exit: evaluate :: a -> IO a  reduces argument to WHNF before returning it
03:17:21 <trap_exit> why wouldn't you use seq instead>
03:17:23 <ClaudiusMaximus> throwIO is better, yes
03:17:32 <trap_exit> evaluate seems strictly weaker than seq
03:19:01 <mauke> hmm, how do you implement evaluate with seq
03:20:26 <jle`> does seq <*> return not work?
03:20:29 <jle`> hm
03:20:31 <jle`> this always trips me up
03:20:46 <mauke> no, because evaluate undefined has to be defined
03:21:04 <jle`> ah
03:21:10 <jle`> that's funky
03:21:37 <mauke> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception-Base.html#v:evaluate
03:25:54 <trap_exit> gentlemen, it's 3:30am I need to sleep
03:25:59 <trap_exit> stay safe from ebola and IO a
03:42:03 <randomuser1> @pl flip (+) 5 3
03:42:04 <lambdabot> 8
03:42:24 <randomuser1> @help
03:42:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:42:29 <randomuser1> @list
03:42:29 <lambdabot> What module?  Try @listmodules for some ideas.
03:42:37 <randomuser1> @help list
03:42:37 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:42:56 <randomuser1> @type 5+5
03:42:57 <lambdabot> Num a => a
03:44:05 <randomuser1> @pl map
03:44:05 <lambdabot> map
03:44:13 <randomuser1> @pointful map
03:44:13 <lambdabot> map
03:44:31 <randomuser1> @unpl map
03:44:31 <lambdabot> map
03:44:57 <randomuser1> @pl flip . map
03:44:57 <lambdabot> flip . map
03:45:04 <randomuser1> @unpl flip . map
03:45:04 <lambdabot> (\ f b c -> map f c b)
03:49:49 <lpaste> relrod pasted “Why does the first one infinite loop and not the other two?” at http://lpaste.net/112881
03:49:57 <relrod> am I missing something really dumb here?
03:50:04 <relrod> Because I feel like I am :)
03:55:59 <mauke> so you have a cycle between e' and v
03:56:00 <ClaudiusMaximus> relrod: not dumb, it's quite subtle - to do with productive recursion (the version with fromJust has an outermost Just which allows evaluation to proceed further without looping)
03:56:29 <mauke> to evaluate v, it has to know whether e' is Nothing or Just _ (because >>= demands it)
03:56:53 <mauke> and to evaluate the first version of e', it has to know whether v is Nothing or Just _ (because fmap)
03:59:37 <relrod> mauke, ClaudiusMaximus: Ok, that makes sense. How might I go about doing this safely (no fromJust) in a way that doesn't infinite loop? :) Or am I just going about this wrong, entirely?
04:01:40 <randomuser1> @let x="does anybody see this?"
04:01:44 <lambdabot>  Defined.
04:02:17 <shiona> > x
04:02:22 <lambdabot>  Ambiguous occurrence ‘x’
04:02:22 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:177:1
04:02:22 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
04:02:22 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:119:1-26
04:02:22 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
04:02:42 <joelteon> @undef
04:02:42 <lambdabot> Undefined.
04:02:53 <joelteon> Yeah, stop defining variables called x.
04:03:12 <randomuser1> you are talking to me right?
04:14:12 <RedNifre> @let swab = foldl
04:14:18 <lambdabot>  Defined.
04:15:24 <RedNifre> @let floor = [1,4,3]
04:15:29 <lambdabot>  Defined.
04:15:40 <RedNifre> @let mop = (+)
04:15:45 <lambdabot>  Defined.
04:16:07 <RedNifre> @let cleanMop = 0
04:16:10 <lambdabot>  Defined.
04:16:39 <RedNifre> >swab cleanMop floor
04:17:01 <RedNifre> > swab cleanMop floor
04:17:03 <lambdabot>  Ambiguous occurrence ‘floor’
04:17:03 <lambdabot>  It could refer to either ‘L.floor’, defined at L.hs:153:1
04:17:03 <lambdabot>                        or ‘GHC.Real.floor’,
04:17:03 <lambdabot>                           imported from ‘Prelude’ at L.hs:40:8
04:17:03 <lambdabot>                           (and originally defined in ‘base:GHC.Real’)
04:17:27 <RedNifre> @let dirtyFloor = [1,2,3]
04:17:32 <lambdabot>  Defined.
04:17:57 <RedNifre> > swap mop cleanMop dirtyFloor
04:18:00 <lambdabot>  Couldn't match expected type ‘a2 -> [t0] -> t’
04:18:00 <lambdabot>              with actual type ‘(b0, a0)’Couldn't match expected type ‘(a0, b0)’
04:18:00 <lambdabot>              with actual type ‘a1 -> a1 -> a1’
04:19:13 <RedNifre> @let mopFloor = foldl (+)
04:19:18 <lambdabot>  Defined.
04:19:33 <RedNifre> > mopFloor cleanMop dirtyFloor
04:19:37 <lambdabot>  6
04:20:50 <RedNifre> Why are the parameters of the functions for foldr and foldl switched around?
04:22:41 <RedNifre> > data Mop = Mop { dirt :: Integer }
04:22:44 <lambdabot>  <hint>:1:1: parse error on input ‘data’
04:22:56 <RedNifre> @data Mop = Mop { dirt :: Integer }
04:22:56 <lambdabot> Unknown command, try @list
04:23:04 <RedNifre> @list
04:23:04 <lambdabot> What module?  Try @listmodules for some ideas.
04:23:44 <RedNifre> @let data Mop = Mop { dirt :: Integer }
04:23:47 <lambdabot>  Defined.
04:24:21 <RedNifre> Mh, I'll come back later, cya.
04:29:10 <pjdelport> @tell RedNifre Remember to use /query for personal experiments. :)
04:29:10 <lambdabot> Consider it noted.
04:35:22 <int-e> > floor 1
04:35:24 <lambdabot>  1
04:50:17 <prinsen> Stupid question: Does Control.Monad.Trans.Except export any try function, that returns Either e a?
04:52:55 <simpson> prinsen: runExceptT
04:53:17 <simpson> (You've considered using EitherT, right?)
05:03:56 <YurasS> how to tell "cabal install" don't rebuild everything
05:04:11 <YurasS> (when installing from local directory)
05:04:13 <YurasS> ?
05:06:13 <Fuuzetsu> YurasS: What dyou you want installed?
05:06:19 <Fuuzetsu> --only-dependencies perhaps?
05:06:35 <YurasS> Fuuzetsu: I mean local package
05:06:42 <YurasS> I did "cabal build"
05:06:49 <YurasS> then what to install the package
05:06:58 <YurasS> but "cabal install" rebuilds everything
05:07:16 <YurasS> https://travis-ci.org/Yuras/pdf-toolbox/jobs/38408359
05:07:24 <Fuuzetsu> @tell solatis to get profiling you should have just changed your Haskell package set in shell.nix to one with profiling, that's it
05:07:24 <lambdabot> Consider it noted.
05:09:47 <YurasS> (I mean "cabal install" rebuilds the package, not everything)
05:09:51 <Fuuzetsu> I can't find your travis file but what we do is cabal install --only-dependencies followed by cabal install
05:10:18 <YurasS> https://github.com/Yuras/pdf-toolbox/blob/rework/.travis.yml
05:10:52 <YurasS> I want manually call "cabal build" and "cabal test"
05:10:52 <Fuuzetsu> oh, I think I was looking at old commit
05:11:05 <YurasS> I remember something like "cabal copy"
05:11:15 <Fuuzetsu> YurasS: why don't you cabal install --enable-tests?
05:11:15 <YurasS> but can't find anything right now...
05:13:05 <YurasS> Fuuzetsu: I'll do that if there is no other way
05:13:52 <YurasS> I still prefer "cabal build". probably I'm too old :)
05:32:59 <Meksip> Hi everyone, is there a special channel for java?
05:33:58 <gfixler> Meksip: ##java ?
05:34:21 <Meksip> ##java
05:42:27 <maestro> hello
05:42:43 <maestro> why don't guards work in a lambda? seems like an arbitrary limitation?
05:49:19 <Cale> maestro: Well, they're not part of the lambda syntax...
05:49:28 <Cale> maestro: They are however part of the syntax of case
05:49:30 <ibrahim> Hello, I was trying Euterpea and got an exception "Exception: PortMidi: toEnum out of bound". i couldn't find anything from search. some people were saving the midi file and playing it on a player. it would be great if i could solve this. any ideas?
05:50:23 <Cale> maestro: A lambda only has one body expression, and though you can match a pattern, you can only match one pattern
05:51:10 <Cale> ibrahim: hmm...
05:52:18 <Cale> ibrahim: Where do I get this code? It doesn't appear to be on Hackage...
05:52:35 <Cale> oh, google knows
05:52:44 <ibrahim> : )
05:53:02 <ibrahim> http://hackage.haskell.org/package/PortMidi-0.1.3/docs/src/Sound-PortMidi.html from this file it seems like it's an unknown error
05:53:12 <ibrahim> or is it ?
05:53:25 <ibrahim> i got it from here https://github.com/Euterpea/Euterpea
05:53:42 <ibrahim> but the problem is with PortMidi on Mac i guess
05:54:32 <Cale> ibrahim: Ah, yeah, that would make me suspect that PortMidi has added new error codes since the Haskell binding was written
06:03:27 <__monty__> Does anyone know of a simple game (pong, pacman...) that has an examplary implementation in haskell?
06:04:58 <ibrahim> i see, i seem to have portmidi on latest version. i guess i'm stuck with external players.
06:14:51 <Phillemann> I'd like to have maximumBy which returns the maximum element as well as its two neighbors (wrapping around the ends if necessary). What's an elegant way to do that?
06:15:07 <Cale> Phillemann: hm
06:15:30 <Cale> Phillemann: The wrapping around the ends makes it slightly trickier, let me see...
06:17:37 <Phillemann> I thought about using comonads, but am not sure where to start ;)
06:17:44 <Cale> Without that, assuming you wanted to insist that the element really has two neighbours, you could write something like  maximumBy (comparing (\(x,y,z) -> y)) $ zip3 xs (drop 1 xs) (drop 2 xs)
06:18:53 <ClaudiusMaximus> drop n (cycle xs)  to wrap around, the zip3 will truncate to the length of xs
06:19:22 <Cale> oh, right
06:19:31 <Cale> It doesn't matter what order the zipped list is in :)
06:19:57 <Cale> > (\xs -> maximumBy (comparing (\(x,y,z) -> y)) $ zip3 xs (drop 1 (cycle xs)) (drop 2 (cycle xs))) [1..10]
06:19:58 <lambdabot>  (9,10,1)
06:20:27 <Cale> > (\xs -> maximumBy (comparing (\(x,y,z) -> y)) $ zip3 xs (drop 1 (cycle xs)) (drop 2 (cycle xs))) [10,9..1]
06:20:29 <lambdabot>  (1,10,9)
06:20:29 <Phillemann> Ah, very nice, thanks :)
06:20:56 <benzrf> Cale: how about (view _2) instead of (\(x, y, z) -> y)
06:20:59 <benzrf> ( ͡° ͜ʖ ͡°)
06:21:19 <Cale> Yeah, if you already depend on lens, you can do that
06:21:38 <Cale> But I definitely wouldn't pull in lens just for that :)
06:21:54 <Fuuzetsu> start the project with lens as a dependency so you never have such dilema
06:27:52 <peppe90owna2> ciao
06:33:41 <Phillemann> So it's maximumBy (f `on` (view _2)) $ zip3 ...
06:49:36 <joe9> Axman6: hello, Just read your http://random.axman6.com/blog/?p=231 and this is the first time coroutines made sense.
06:49:48 <joe9> Axman6: Thanks so much for writing the article.
06:51:45 <benzrf> joe9: FYI the pipes package is just coroutines in the same style3
06:51:45 <benzrf> *style
06:52:31 <benzrf> joe9: the only difference is that you add a new pair of parameters to the type constructor and add a new constructor that yields and resumes on those
06:52:41 <benzrf> so one of them is "yielding downstream" and one is "yielding upstream"
06:53:00 <benzrf> which allows you to write pipe-like ones in addition to generator-like ones
06:53:28 <joe9> benzrf: thanks, let me check on pipes package.
06:53:51 <joe9> btw, I want to write a voluntary non-preemptive cooperative process scheduler.
06:54:27 <joe9> any suggestions on what would be a good package to check out? I am thinking monad-resumptions or trampoline. Any thoughts, please?
06:54:30 <ilhami> Hey :D
06:54:34 <ilhami> I am going to learn Haskell :)
06:55:11 <benzrf> joe9: oh also pipes only has one core type, Proxy
06:55:21 <benzrf> it doesnt have separate Result and Coroutine types
06:55:30 <benzrf> joe9: no idea soz
06:55:50 <benzrf> hey ilhami!
06:55:55 <benzrf> good choice (y)
06:56:34 <ilhami> benzrf I don't really have a big clue of how it works but anyway I am going to follow some tutotrials.
06:56:39 <ilhami> tutorials*
06:56:49 <ibrahim> ilhami: would you be interested in http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf
06:56:56 <ibrahim> i'm following it now
06:57:06 <ilhami> well I am using this resource.
06:57:09 <ilhami> http://learnyouahaskell.com/starting-out
06:57:26 <benzrf> ilhami: lyah is all right i suppose
06:57:26 <ilhami> I hope it's cool.
06:57:30 <benzrf> but there are better options!
06:57:31 <ibrahim> yeah i spend quite a bit of time there :) it's a good one
06:57:56 <joe9> benzrf: any recommendations on tutorials for pipes?
06:58:00 <benzrf> ilhami: i recommend joining #haskell-beginners for dedicated support :3
06:58:10 <benzrf> joe9: the one in the package is fine
06:58:26 <benzrf> @hackage pipes
06:58:27 <benzrf> just view the docu for the module Pipes.Tutorial
06:58:27 <lambdabot> http://hackage.haskell.org/package/pipes
06:59:08 <benzrf> you know, the site says `Hackage :: [Package]'
06:59:19 <benzrf> shouldn't it be `hackage :: [Package]'
06:59:24 <benzrf> or even `hackage :: Set Package'
07:00:01 * hackagebot yesod-bin 1.4.0.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.3 (MichaelSnoyman)
07:00:34 <phoenix24> hey guys, typing "abs -10" on haskell shell throws error
07:00:47 <geekosaur> it's a list of names pointing to package information, with multiole versions, so it's Map String [Package]
07:00:57 <geekosaur> phoenix24, unary minus is weird,  abs (-10)
07:01:18 <phoenix24> geekosaur: thanks!
07:01:30 <geekosaur> `abs -10` is parsed as subtracting 10 from abs, which doesn't make much sense
07:02:09 <geekosaur> (because haskell's unary minus doesn't make much sense)
07:02:37 <mr-> :t abs - 10
07:02:39 <lambdabot> (Num (a -> a), Num a) => a -> a
07:03:36 <phoenix24> that looks confusing
07:04:05 <phoenix24> how do you read that function signature?
07:04:26 <thebnq> it doesn't really make sense
07:04:30 <geekosaur> ^
07:04:35 <Fuuzetsu> it says that both (a -> a) and a need to be a Num
07:04:39 <Fuuzetsu> which doesn't make much sense indeed
07:05:00 <thebnq> kind of amusing that the first error ghci gives is for a show instance
07:05:35 <geekosaur> basically it's asserting that "abs" (a function which expects a parameter but hasn't been given one) needs to be recognizeable as a number somehow
07:05:59 <geekosaur> it's not impossible to do this but it doesn't generally make any sense
07:13:04 <geekosaur> hm, actually it occurs to me that inferred type isn't quite right; shouldn't it also infer via the type of (+) a constraint ((a -> a) ~ a) ?
07:18:03 <benmachine> geekosaur: no, the Num a constraint arises from abs itself
07:18:22 <geekosaur> right, but (+) should add the additional constraint?
07:18:30 <Fuuzetsu> (-)
07:18:32 <geekosaur> :t (+)
07:18:33 <lambdabot> Num a => a -> a -> a
07:18:58 <geekosaur> ^ implies the left arg of (+), which is (a -> a), is the same as the right, which is a
07:19:07 <geekosaur> thus (a -> a) ~ a
07:19:07 <benmachine> why is the right a?
07:19:20 <geekosaur> hm, point
07:19:31 <geekosaur> I should finish my coffee perhaps
07:19:40 <benmachine> note that a ~ (a -> a) violates the occurs check and is a type error
07:19:51 <geekosaur> yes, that was actually what I was angling at
07:20:00 <geekosaur> was hoping that would lead to a better error message
07:20:01 <benmachine> whereas it is possible to give definitions such that 'abs - 10' typechecks
07:20:03 <geekosaur> via absurdity
07:20:03 * hackagebot boomange 0.1.1.0 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.1.0 (mgmillani)
07:20:12 <benmachine> it's a bad idea, but it's possible :)
07:28:41 <__monty__> Someone mention vanlaar (valhaar?) lenses to me and I'm not having much luck with google. Does anyone have a link to a good explanation?
07:29:32 <k00mi> __monty__: van laarhoven
07:30:42 <__monty__> k00mi: This van Laarhoven? http://twanvl.nl/blog/news/2011-05-19-lenses-talk
07:31:11 <k00mi> yes
07:31:27 <__monty__> k00mi: Thank you.
07:34:06 <phoenix24> has anyone built a web-crawling system in haskell ?
07:44:55 <fluffynukeit> hello, all.  I am trying to implement loading of precompiled Haskell "plugins" at runtime.  The plugins package looks suited for this, but I have found occasional reports that it is "broken."  What is the current, conventional way of loading precompiled plugins at runtime?
07:46:45 <fluffynukeit> I'm working on, essentially, a web server that reads and processes data files, so in this case each plugin would read a different data format but return the results in a consistent Haskell record for further processing
07:47:13 <geekosaur> fluffynukeit, the plugins package was for older versions of ghc which didn't have an API for loadable / unloadable (mostly the latter) modules. current ghc-api has direct support for it
07:47:20 <geekosaur> (that said ghc-api is fairly baroque)
07:48:32 <fluffynukeit> yes, I am following some pretty recent GHC API tutorials, but I am having problems getting it to read the .o file for test plugin instead of the .hs file
07:49:14 <fluffynukeit> ok, so sounds like GHC API is the way to go, with some kinks I still need to figure out.
07:50:06 * hackagebot text-manipulate 0.1.0 - Textual case conversion and word boundary manipulation  http://hackage.haskell.org/package/text-manipulate-0.1.0 (BrendanHay)
07:50:29 <fluffynukeit> Follow up question: is it possible to compile a plugin into a self-contained file (.o or otherwise) that contains all of its dependencies, so that when I load it with GHC API, I don't need to have the dependencies on my web server?
07:55:07 * hackagebot colchis 0.1.0.0 - Rudimentary JSON-RPC 2.0 client over raw TCP.  http://hackage.haskell.org/package/colchis-0.1.0.0 (DanielDiazCarrete)
07:58:10 <farrioth> I'm very new to Haskell and am reading Real World Haskell. I've just come to the section on operator precedence rules. Could someone point me to an explanation of why complex operator precedence is useful? I.e., what advantages it has over, for example, strict left to right evaluation.
08:01:58 <bennofs> farrioth: well, you do want 3 + 4 * 6 to be 3 + (4 * 6) and not (3 + 4) * 6, don't you?
08:02:24 <bennofs> farrioth: Also, consider 2 * 3 + 4 * 5. You cannot write that without parentheses if you don't have operator precendeces
08:02:37 <milos_cohagen> Hi all, I've been trying to write Tony Morris' Tic-Tac-Toe challenge: http://tonymorris.github.io/blog/posts/understanding-practical-api-design-static-typing-and-functional-programming/
08:03:09 <milos_cohagen> And starting with this rule: "If I call move on a tic-tac-toe board, but the game has finished, I should get a compile-time type-error. In other words, calling move on inappropriate game states (i.e. move doesn’t make sense) is disallowed by the types."
08:04:36 <milos_cohagen> I seem to be stuck on this notion of being able to write a `move` fn that throws based on the Game type.
08:05:31 <milos_cohagen> If I have: data Game = Running Board Player | Completed Outcome
08:05:48 <milos_cohagen> and: move :: Game -> Move -> Game
08:05:48 <farrioth> bennofs: So the answer is that Haskell has complex operator precedences because mathematics does?
08:06:42 <bennofs> farrioth: I don't know what the inventors of haskell intented, but I think it's pretty nice to have (without precedence, you'd have to write a lot of parens)
08:07:27 <milos_cohagen> I can pattern match in `move` definition, but I can't say something like: `move (Completed _) _ = THROW COMPILER ERROR`
08:07:29 <fluffynukeit> farrioth: not just that, but imagine you wanted to write out code for building a complex tree.  Without operator precedence, you would need to litter your code with parenthesis, but with the write operators you can do it cleanly
08:07:51 <fluffynukeit> *right operators....too early for this
08:08:01 <fluffynukeit> haha
08:08:18 <milos_cohagen> So I'm pretty sure I'm way off, and was hoping for a push in the right direction?
08:08:30 <hexagoxel> farrioth: might be worth pointing out that this question is not specific to haskell. most major languages have operator precedence
08:09:22 <fluffynukeit> milos_cohagen: I'll answer, one moment
08:09:38 <farrioth> bennofs: Fair enough, although wouldn't you need to override precedence assuming complex rules about as much as you would have to specify it explicitly assuming linear evaluation?
08:10:12 <milos_cohagen> fluffynukeit: thx, take your time! i'm patient
08:10:36 <farrioth> fluffynukeit: I think it's debatable whether parentheses improve or impede readability, though.
08:11:02 <farrioth> hexagoxel: Indeed.
08:11:22 <bennofs> farrioth: well, I believe there are usecases where linear evaluation is really uncommon (how often do you want to write (2 * 3 + 4) * 5 vs 2 * 3 + 4 * 5). Precedence rules let you specify the common case
08:11:23 <tekul> farrioth: Another discussion http://lambda-the-ultimate.org/node/2943
08:12:13 <tekul> I wasn’t aware that a few languages do use left to right evaluation for operators
08:12:57 <farrioth> bennofs: To be honest I don't write either that much. Which perhaps makes it a moot point, although does precedence only apply to math?
08:13:24 <farrioth> tekul: Thanks. APL and Smalltalk to name a couple.
08:13:55 <farrioth> tekul: And anything with exclusively outfix notation most likely.
08:14:06 <fluffynukeit> milos_cohagen: here's one way you could do it I think, use phantom types:
08:14:07 <bennofs> farrioth: another example might be    a & someField .~ 3 (you can write that in Haskell with lens, it means "set someField of a to 3")
08:14:18 <bennofs> fluffynukeit: you almost never want (a & someField) .~
08:14:31 <bennofs> 3, because that would in most cases not even typecheck
08:15:00 <bennofs> In fact, I have never needed that
08:15:04 <melleth> Hello community! I'm having (I think) a minor type error in my program and I am at a loss of how to fix it. Can anyone give a noob a hand?
08:15:09 * hackagebot text-manipulate 0.1.1 - Case conversion, word boundary manipulation, and miscellanous textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.1 (BrendanHay)
08:15:35 <bennofs> melleth: you're welcome :) Just post your code at lpaste, and some sure will look at it
08:15:38 <bennofs> @where lpaste
08:15:38 <lambdabot> http://lpaste.net/new/haskell
08:15:58 <melleth> thank you!
08:16:16 <fluffynukeit> milos_cohagen: data Running, data Completed.....these are two different types.  Then data Game state = Board Player.  move :: Game Running -> Move -> Game a
08:16:54 <bennofs> melleth: if the link is not automatically posted to the channel (not sure if lpaste bot works right now), you still need to share it here :)
08:17:12 <melleth> working on it ;)
08:17:24 <farrioth> bennofs: That seems like a good example, but (perhaps ironically) I'm too new to Haskell to be familiar with those operators.
08:17:34 <bennofs> farrioth: yeah, I couldn
08:17:53 <bennofs> (this stupid return key) ... couldn't think of an easier example
08:18:55 <fluffynukeit> milos_cohagen: not sure if that will work, but to me the "call move on a finished game is a compile error" is a bit of a weird constraint, but it's a fun exercise
08:19:49 <milos_cohagen> fluffynukeit: thx, i'll go down that path and see where it goes
08:19:54 <fluffynukeit> milos_cohagen: oh, to elaborate on my example...
08:20:32 <fluffynukeit> milos_cohagen: move :: Game Running -> Move -> Game Running.   checkComplete :: Game Running -> Game Complete
08:20:59 <fluffynukeit> oh wait that doesn't work either
08:21:13 <fluffynukeit> clearly I have no clue what I am doing :)
08:21:30 <bennofs> milos_cohagen: you need to have a "count" of how many stones where already placed on the board in the type of Game
08:21:35 <lpaste> melleth pasted “type error on put with modify” at http://lpaste.net/112884
08:22:05 <melleth> Seems like it worked :)
08:22:27 <bennofs> melleth: nice, can you annotate the type error also?
08:23:39 <lpaste> melleth revised “type error on put with modify”: “No title” at http://lpaste.net/112884
08:23:51 <melleth> done
08:25:31 <bennofs> melleth: so you already have a working implementation of put but want to improve it?
08:25:41 <bennofs> melleth: (the one that isn't commented)
08:25:43 <farrioth> I guess there's nothing stopping me from ignoring the precedence rules and using explicit brackets anyhow. (Which is what I've done in other languages for a while anyhow.)
08:25:59 <farrioth> Or using prefix notation for that matter.
08:27:30 <milos_cohagen> fluffynukeit: if move returns a value of type "Running", you'd then be able to call move again without compile error?
08:28:13 <melleth> bennofs: No I don't have an implementation that works, this was my try a t implementing put of a MonadState class using the modify statement
08:29:23 <bennofs> melleth: hmm, but 'put newState = modify (\s0 -> newState) >>= (\s1 -> return ())' which you already have doesn't give a compile error I think?
08:31:27 <fluffynukeit> milos_cohagen: my idea was to have move work on any running game, but you'd have a different function to determine when the game was complete.  I'm not sure that will work as I wrote it, though
08:31:29 <melleth> bennofs: I see now. I guess I forgot to save my document before compiling... Deeply sorry for wasting you time!
08:32:10 <fluffynukeit> milos_cohagen: bennofs suggested having a count of stones in the type of Game
08:32:31 <benmachine> milos_cohagen: I think this exercise is nontrivial and a newbie should not attempt it
08:32:36 <bennofs> I wonder how accurate this compile-time checking should be
08:32:50 <benmachine> I'd agree that having a count of remaining moves is the way I'd do it
08:33:27 <bennofs> You cannot deny all invalid moves easily, but not allowing more than 9 moves is doable
08:33:46 <benmachine> bennofs: right
08:34:03 <benmachine> and then you can also detect the empty board
08:35:03 <ibotty> hi, anyone up to some higher order constraint puzzle?
08:35:11 * hackagebot neil 0.5 - General tools for Neil  http://hackage.haskell.org/package/neil-0.5 (NeilMitchell)
08:35:13 * hackagebot ekg-rrd 0.2.0.14 - Passes ekg statistics to rrdtool  http://hackage.haskell.org/package/ekg-rrd-0.2.0.14 (dcturner)
08:35:34 <ibotty> basically i'd like to have a map for heterogenous lists.
08:36:28 <milos_cohagen> I've never tried to use the type system to express this type of logic.. head hurts. Thanks for feedback!
08:36:49 <ibotty> my favorite type sig would be `mapRow :: All c r => (forall e. c e => e -> a) -> r -> [a]`
08:37:45 <bennofs> ibotty: i guess that gives problems with type inference
08:38:23 <ibotty> with homogeneous lists that's pretty easy (type family Element,  then use a (c (Element e)) constraint.
08:38:46 <ibotty> bennofs: sure. but that can be overcome. (i guess) maybe with a proxy of some sort.
08:39:14 <bennofs> ibotty: I think you need to place your mapping function in a data type, like data ConstrainedFunction c a = ContrainedFunction (forall e. c e => e -> a), and then you'd still need to pass a ConstrainedFunction with explicit type signature given
08:40:01 <benmachine> milos_cohagen: I have an idea, sec
08:40:07 <ibotty> the problem is that even with all types pinned down, i cannot convince ghc to infer that a class constraint holds for its elements...
08:41:20 <ibotty> bennofs: that does not really solve my problem (if i am not missing something)
08:44:10 <ibotty> bennofs: oh. it did
08:44:17 <ibotty> i was not expecting that...
08:45:12 * hackagebot reroute 0.2.0.1 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.0.1 (AlexanderThiemann)
08:47:18 <lpaste> benmachine pasted “No title” at http://lpaste.net/112886
08:47:41 <benmachine> milos_cohagen: fluffynukeit: how about http://lpaste.net/112886 ?
08:48:37 <lpaste> benmachine revised “No title”: “No title” at http://lpaste.net/112886
08:51:36 <benmachine> I think I'd be able to enforce more with GADTs
08:52:04 <benmachine> actually, takeMoveBack doesn't look quite right, but I'm sure it can be fixed
08:53:53 <MagneticDuck> ...
08:54:05 <MagneticDuck> System.TimeIt doesn't actually, um, time IO operations?
08:54:18 <MagneticDuck> having trouble getting a reliable timing of my concurrent operation
08:56:46 <milos_cohagen> benmachine: thx, tinkering with your impl
08:56:57 <MagneticDuck> if you want to recreate the problem, https://github.com/MagneticDuck/TeeClient and run "timeIt . void $ getGameServers"
08:57:01 <MagneticDuck> any ideas though?
08:57:28 <MagneticDuck> oh why timeIt-related timing systems wouldn't get a good result on a concurrent operation, even though that operation returns a result that can only be strictly evaluated when all the threads have finished?
09:00:01 <MagneticDuck> anybody home?
09:00:06 <MagneticDuck> I have no idea how to get past this problem
09:04:33 <MagneticDuck> here's my question: let's say I have some concurrent IO that, as a result, returns a value
09:04:59 <MagneticDuck> that value can only be strictly evaluated if all the threads finish (it's a list of results of each thread actually, using mapConcurrently)
09:05:15 <MagneticDuck> how do I get a good value on how long it takes to get from nothing to having that value returned?
09:05:31 <MagneticDuck> structures like timeIt don't work; do I need to add strictness manually? what are the best practices?
09:06:15 <milos_cohagen> benmachine: what's the Square type?
09:07:22 <benmachine> milos_cohagen: oh, oops, let me fix
09:07:39 <lpaste> benmachine revised “No title”: “tic-tac-toe API” at http://lpaste.net/112886
09:07:51 <benmachine> milos_cohagen: Maybe Side, basically
09:10:15 * hackagebot process-streaming 0.6.1.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.1.0 (DanielDiazCarrete)
09:10:18 <fluffynukeit> MagneticDuck: sorry, I have no idea
09:11:04 <int-e> benmachine: wouldn't it be easier to have undo :: MoveResult -> Maybe MoveResult? [you need a Maybe for the starting position]
09:11:10 <fluffynukeit> MagneticDuck: maybe try stack overflow?
09:11:58 <Repulzz> a
09:12:32 <benmachine> int-e: ooh, good point
09:13:20 <benmachine> int-e: slightly unwieldly, perhaps
09:19:37 <milos_cohagen> benmachine: thx for guidance, i'll probably hack on it here and there as time permits.
09:23:34 <lpaste> bennofs pasted “Enforce tic-tac-toe invariants” at http://lpaste.net/112890
09:23:44 <bennofs> milos_cohagen: I posted an example using GADTs
09:24:05 <bmcorser> is there a difference between hsenv and cabal sandboxes?
09:26:17 <geekosaur> bmcorser, cabal sandboxes sandbox the user packages, hsenv sandboxes an entire ghc including the global packages
09:26:26 <bmcorser> ok
09:26:39 <bmcorser> thanks, saved me some reading :)
09:26:52 <bennofs> milos_cohagen: the idea is that we encode the sequence of players that we expect to make a move in the type. So Game (X (End)) means "X has to make a move, then the game ends". In PlayX in PlayY, we "pattern match" on this sequence to only allow PlayX if the next player is indeed the X player (same for Y)
09:38:53 <milos_cohagen> bennofs: thx! have added all this to my notes to attack later. much appreciated.
09:40:41 <nshepperd> MagneticDuck: you want to measure how long it takes for a pure value to be evaluated by some concurrent computation?
09:41:17 <sbrg> oh thank god
09:41:27 <sbrg> ghci vim bindings work properly now
09:41:32 * sbrg praises the lords
09:42:39 <nshepperd> MagneticDuck: would something like "timeIt . evaluate . force" work?
09:42:41 <nitrix> The haskell overlords.
09:45:19 * hackagebot yi-rope 0.5.1.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.5.1.0 (MateuszKowalczyk)
09:45:54 <nitrix> What's a rope data structure?
09:46:18 <indiagreen> nitrix: a tree of string chunks
09:46:46 <tharper> an underappreciated string representation, IMO
09:46:52 <indiagreen> it's commongly used to provide fast indexing/insertion/etc. in text editors
09:47:09 <Fuuzetsu> Fast™
09:48:12 <nitrix> So there's no association? It's just a dictionary of partial strings?
09:49:44 <Fuuzetsu> it's not a dictionary
09:50:24 <Fuuzetsu> rope is a fingertree of strings
09:50:42 <Fuuzetsu> fingertrees are useful for many things though, Data.Seq uses them IIRC
09:51:43 <jhance> Yeah D.S definitely uses finger trees
09:51:49 <nshepperd> MagneticDuck: oh, I see. mapConcurrently does indeed wait until all threads have finished before returning
09:53:54 <nshepperd> MagneticDuck: it seems to be working fine here, except that timeIt reports CPU time, not wall clock time
09:55:42 <nshepperd> MagneticDuck: er, I mean that "timeIt $ mapConcurrently (\x -> print $ sum [1..x]) [10000000]" works for example
09:58:26 <maestro> .
10:05:21 * hackagebot yi-rope 0.5.2.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.5.2.0 (MateuszKowalczyk)
10:10:21 * hackagebot slave-thread 0.1.1 - A solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.1 (NikitaVolkov)
10:11:10 <SteveManley> Hi. I'm learning Haskell and I'm stuck, because I can't find how to do this simple thing. Lets say I have a "data Person = Person { name :: String, age :: Int}" and I want to have a function "isJon :: Person -> Bool". How should I write that function?
10:11:32 <vanila> isJon p = name p == "jon"
10:11:34 <HeladoDeBrownie> SteveManley, what should the function do?
10:11:41 <benzrf> vanila! be socratic >:{
10:11:43 <HeladoDeBrownie> Oh
10:11:45 <SteveManley> Oh
10:11:50 <SteveManley> Yes vanila thx!
10:13:22 <narendraj9__> benzrf, how would Socrates anwswer the question?
10:13:31 <monochrom> hehe
10:13:53 <nshepperd> "what's Haskell?"
10:15:00 <narendraj9__> No. I was not kidding. I really wanted to know his way of teaching.
10:15:11 <benzrf> narendraj9__: are you not familiar with the socratic method of teaching
10:15:17 <narendraj9__> No, I am not.
10:15:19 <benzrf> oh
10:15:36 <benzrf> its when you ask pointed questions to help somebody figure out the answer
10:15:51 <vanila> narendraj9__, you just illustrated his way of teaching
10:15:57 <benzrf> mfw
10:16:03 <Fuuzetsu> check-mate
10:16:11 <narendraj9__> Oh. I see.
10:16:22 <monochrom> I mistook it as a joke for that reason :)
10:16:40 <Fuuzetsu> only super serious stuff on #haskell
10:16:44 <geekosaur> or, "give someone a fish" vs. "teach someone to fish"
10:16:46 <pjdelport> SteveManley: You could also do that via pattern matching with record syntax: isJon (Person { name = n }) = n == "Jon"
10:17:19 <Fuuzetsu> the cool kids don't allow the function to take anything but a statically-proven Jon
10:17:35 <benzrf> i like it for this kind of example because it forces the asker to learn something instead of copy-pasting code
10:17:44 <ezrios> What does the exception "Gave up after [n] tests" in QuickCheck mean?
10:18:15 <pjdelport> SteveManley: You could further define: Person { name = n } `isNamed` name = n == name
10:18:16 <pjdelport> SteveManley: and then say: p `isNamed` "Jon"
10:18:16 <int-e> ezrios: the test had a precondition (using ==>) and that wasn't satisfied often enough.
10:18:42 <ezrios> int-e: is there a way to limit the range of test data?
10:18:51 <int-e> @check False ==> True
10:18:52 <lambdabot>  *** Gave up! Passed only 0 tests.
10:19:09 <ezrios> I am trying to write a property that holds only for a small range of a set of possible input data
10:19:22 <benzrf> @check False ==> 1 < 0
10:19:24 <lambdabot>  *** Gave up! Passed only 0 tests.
10:19:28 <benzrf> explosion yall
10:19:28 <ezrios> namely, Chars ['a'..'h'] and Ints [1..8]
10:19:57 <int-e> ezrios: if your test data is very restricted, you probably need a generator, or a function that converts from data in an arbitrary range to the small range
10:19:58 <monochrom> @check \n -> n==1938403 ==> n > 1
10:19:58 <lambdabot>  : -1: -1:Ambiguous infix expression
10:20:03 <SteveManley> pjdelport: Thank you.
10:20:21 <int-e> lambdabot: wow?
10:21:09 <monochrom> I guess it wants me to parenthesize n==1938403
10:21:23 <benzrf> infixxr
10:38:27 <JagaJaga> Guys, I have file like rows of `Double Double Int`. What's the best way to read it and parse to data with te same type? I mean there is data Foo = Foo Double Double Int
10:44:15 <MagneticDuck> (\[a, b, c] -> (flip flip read . ((.) .) . (. read) . Foo . read) a b c) $ unwords line
10:44:25 <MagneticDuck> don't you just love haskell?
10:44:34 <MagneticDuck> naah man jk
10:45:25 * hackagebot ZipperAG 0.8 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.8 (prmartins)
10:46:01 <Fuuzetsu> if you sit a monkey at a typewriter with only ‘flip’ and ‘.’ keys on it for a short amount of time, it is likely to produce a valid Haskell expression
10:47:13 <pjdelport> JagaJaga: How robust does the parsing need to be?
10:48:00 <JagaJaga> pjdelport: MagneticDuck thx you guys, but already done smth like MagneticDuck wrote
10:48:07 <MagneticDuck> roflmao
10:48:17 <MagneticDuck> .. I hope not
10:48:30 <JagaJaga> MagneticDuck: well, it far away but...)
10:49:33 <pjdelport> JagaJaga: parseFoo line = case words line of [a,b,c] -> Foo (read a) (read b) (read c); _ => error "error"
10:49:38 <pjdelport> If you have to go that route. :)
10:49:47 <f-a> tangent if not OT, but: I received haskell ASCII art http://www.ariis.it/static/stream/page.html#love-you-give
10:50:26 * hackagebot ZipperAG 0.9 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.9 (prmartins)
10:53:17 <pjdelport> JagaJaga: If you use something like Parsec, you can use something like https://hackage.haskell.org/package/ParsecTools-0.0.2.0/docs/Text-Parsec-Numbers.html as follows:
10:53:17 <pjdelport> parseFoo = Foo <$> parseFloat <*> parseFloat <*> parseIntegral
10:55:04 <JagaJaga> pjdelport: oh, nice!
10:58:30 <zyaku> Is there a facility in Haskell that’s like Common Lisp’s time macro?
11:00:49 <rrradical> zyaku: is that benchmarking? there is the criterion package: http://hackage.haskell.org/package/criterion
11:00:51 <geekosaur> @hackage criterion
11:00:51 <lambdabot> http://hackage.haskell.org/package/criterion
11:00:54 <geekosaur> heh
11:01:43 <zyaku> yep, that looks like what I’m looking for. Thanks!
11:10:52 <JagaJaga> Oh, btw, what's the best way to write smth like Q[i][j] = y[i] * y[j] * dotB (x_i, x_j) ? Well, I have [(x, y)].
11:17:16 <eyebloom> My first time trying to use errorWithStackTrace and I’m a little befuddled, I can’t seem to get a stack trace output. Is it enough to just say “runghc MyProgram.hs -prof -fprof-auto” ?
11:18:18 <_rai> why doesn't this work zipWith (\x y -> x ++ y) "foo" "bar", but just (\x y -> x) does? I mean I don't see how the ++ changes the type
11:18:51 <mauke> > 'f' ++ 'b'
11:18:53 <lambdabot>  Couldn't match expected type ‘[a]’
11:18:53 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match expected type ‘[a]’
11:18:53 <lambdabot>              with actual type ‘GHC.Types.Char’
11:18:56 <mauke> that's the problem
11:19:05 <mauke> (++) takes two lists
11:19:05 <eyebloom> _rai: Try [x]++[y]
11:19:36 <eyebloom> or x:[y]
11:20:08 <vanila> _rai, strings are lists of characters, whe you do that ziWith, x and y are Chars
11:20:53 <_rai> ah.
11:21:22 <JagaJaga> Guys :/ No way to do it? ;/
11:22:19 <eyebloom> Also “runghc MyProgram.hs -prof -fprof-auto +RTS -xc” tells me I can’t use -xc without -prof
11:22:42 <eyebloom> I’m on version 7.8.3
11:23:44 <mauke> eyebloom: shouldn't you pass -prof to ghc?
11:23:54 <ezrios> are there any good resources for learning to use QuickCheck? in particular, creating generators
11:24:08 <eyebloom> I thought I was?
11:24:24 <mauke> if you are, runghc does weird things with options
11:24:29 <ezrios> I am trying to formulate properties that only hold for a small subset of possible test data
11:24:36 <mauke> I would've expected runghc -prof MyProgram.hs etc.
11:24:39 <ezrios> i.e. Chars between ['a'..'c'] and Ints [1..8]
11:24:44 <ezrios> er, ['a'..'h']
11:24:54 <mauke> does profiling even work in the interpreter?
11:25:05 <eyebloom> let me try that
11:27:16 <eyebloom> I see, I think I misunderstood what runghc does
11:41:43 <ahihi> the cmath package fails to compile on the latest platform. I have a fix, but it seems the maintainer's (dons) e-mail address is dead. what would be the proper procedure to get the hackage version updated in this situation?
11:42:09 <pharpend> ahihi: is there a bug tracker listed?
11:42:24 <ahihi> pharpend: not that I can see
11:42:31 <ahihi> https://hackage.haskell.org/package/cmath-0.3
11:42:51 <pharpend> ahihi: okay
11:42:52 <dustin> foo f g = \x -> f (g x)
11:42:54 <pharpend> hmmm
11:42:57 <dustin> why do i need parens around (g x)
11:43:06 <mauke> dustin: because otherwise it parses as (f g) x
11:43:14 <dustin> ty
11:43:15 <pharpend> yeah, it hasn't been updated for 6 years
11:43:22 <pharpend> dustin: yeah, what mauke said
11:43:27 <pharpend> dustin: alternatively you could do
11:43:48 <pharpend> @@ dustin @let foo f g = \x -> f $ g x
11:43:51 <lambdabot>  dustin  Defined.
11:44:19 <pharpend> dustin: in that case, a lambda is unnecessarily verbose, so this would be better
11:44:28 <JagaJaga> So guys, how to make 2d list in haskell? :(
11:44:44 <pharpend> @@ dustin @let foo f g = f . g
11:44:46 <lambdabot>  dustin  .L.hs:155:1: Warning:
11:44:46 <lambdabot>      Pattern match(es) are overlapped
11:44:46 <lambdabot>      In an equation for ‘foo’: foo f g = ...
11:44:46 <lambdabot>  
11:44:46 <lambdabot>  <no location info>:
11:44:51 <JagaJaga> I mean smth like q[i][j] = array[i] * array[j]
11:44:52 <pharpend> @unlet foo
11:44:52 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:45:01 <mauke> @undefine
11:45:01 <lambdabot> Undefined.
11:45:05 <pharpend> @@ dustin @let foo f g = f . g
11:45:09 <lambdabot>  dustin  Defined.
11:45:10 <pharpend> thank you mauke
11:45:10 <mauke> @undefine
11:45:10 <lambdabot> Undefined.
11:45:17 <mauke> stop defining random things
11:45:32 * hackagebot cereal-plus 0.4.0 - An extended serialization library on top of "cereal"  http://hackage.haskell.org/package/cereal-plus-0.4.0 (NikitaVolkov)
11:45:34 <pharpend> mauke: I was doing it for demonstration
11:45:37 <pharpend> anyway
11:45:37 <mauke> you can use let .. in for demonstrating a function
11:46:13 <mauke> > let foo f g = f . g in foo length show 500
11:46:15 <lambdabot>  3
11:46:56 <pharpend> JagaJaga: I'm not familiar with the (*) operator in that context
11:47:11 <pharpend> JagaJaga: but are you wanting something like [[1,2,3],[4,5,6],[7,8,9]]
11:48:22 <JagaJaga> pharpend: yeah
11:48:32 <pharpend> > let f = [[1,2,3],[4,5,6],[7,8,9]] in map (map (*3)) f
11:48:34 <lambdabot>  [[3,6,9],[12,15,18],[21,24,27]]
11:48:45 <JagaJaga> pharpend: no.
11:48:54 <JagaJaga> pharpend: * is just a multiply
11:49:30 <pharpend> JagaJaga: Can you maybe elaborate on what you are trying to do
11:50:09 <chirpsalot> JagaJaga: cartesian product?
11:50:32 * hackagebot pipes-cereal-plus 0.4.0 - A streaming serialization library on top of "pipes" and "cereal-plus"  http://hackage.haskell.org/package/pipes-cereal-plus-0.4.0 (NikitaVolkov)
11:50:47 <pharpend> JagaJaga: It's not usually a good idea to try to direct translate imperative code into functional code.
11:50:47 <chirpsalot> > [a * b | a <- [1..3], b <- [2..4]]
11:50:50 <lambdabot>  [2,3,4,4,6,8,6,9,12]
11:50:50 <benzrf> how straightforward
11:50:57 <benzrf> JagaJaga: yeah, seriously
11:51:08 <benzrf> fp and ip are not quite isomorphic!
11:51:10 <JagaJaga> in cpp it's smth like `for i in [1..100] {for j in [1..100] {q[i][j] = y[i] * y[j] * myFunction (x[i], x[j])}}, where y and x and q are vectors and`
11:51:13 <benzrf> ok thats a bad way of putting it!
11:51:24 <pharpend> ah okay
11:51:26 <benzrf> JagaJaga: cpp is the c preprocessor usually
11:51:30 <benzrf> i recommend c++ for c++
11:51:40 <JagaJaga> benzrf: pseudocode :)
11:51:42 <pharpend> it's matrix multiplication
11:51:47 <sbrg> JagaJaga: Well, you *can* use lists, but you probably want Vector or Array
11:52:09 <JagaJaga> sbrg: hm, ok,  I can do Vector.fromList. But what next?
11:52:27 <pharpend> does lambdabot have the matrix lib loaded?
11:52:36 <benzrf> mate ricks
11:52:41 <sbrg> if you use a vector, you want a Vector (Vector Int) or some such. Array lets you do multi-dimensional arrays
11:53:07 <JagaJaga> sbrg: oh, I'm using just Lists now. OK, can do arrays
11:53:48 <JagaJaga> Isn't there such an function or trick how to do it with lists?)
11:54:09 <benzrf> do wat
11:54:22 <JagaJaga> generate 2d list
11:54:29 <benzrf> from what
11:54:42 <JagaJaga> ahhh, from two 1d lists
11:54:48 <benzrf> oh
11:54:58 <benzrf> um, rows a b = [a, b]?
11:54:59 <sbrg> List indexing is O(n). This gives you a gigantic overhead doing this inside an O(n^2) loop.
11:55:19 <pharpend> JagaJaga: matrix multiplication is what you are looking for
11:55:26 <sbrg> ^
11:55:34 <pharpend> JagaJaga: so, you would do something like this
11:56:27 <pharpend> @let x = Matrix.fromList 3 1 [0,1,2]
11:56:30 <lambdabot>  .L.hs:152:5: Not in scope: ‘Matrix.fromList’
11:56:35 <pharpend> okay
11:56:55 <pharpend> let x = Matrix.fromList 3 1 [0,1, 2]
11:57:06 <pharpend> let y = Matrix.fromList 1 3 [0, 1, 2]
11:57:46 <dustin> @pl \f g x y -> f (x ++ g x) (g y)
11:57:47 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
11:57:54 <JagaJaga> pharpend: no, I don't need matrix multiply
11:58:05 <pharpend> JagaJaga: that's what you are trying to do, right?
11:58:35 <dustin> @pl \xs -> map proj2 $ filter isLocalMaximum (sliding3 xs) where proj2 (_,b,_) = b
11:58:35 <lambdabot> (line 1, column 70):
11:58:35 <lambdabot> unexpected '_'
11:58:35 <lambdabot> expecting expression
11:58:45 <JagaJaga> pharpend: well, I wrote pseudocode of what I need :(
11:58:51 <pharpend> @@ dustin @type (.).(.).(.).(.)
11:58:53 <lambdabot>  dustin (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
11:59:19 <pharpend> @@ dustin @type (.).(.).(.).(.).fmap.traverse.(.).mapM.(. fmap). (.)
11:59:21 <lambdabot>  dustin (Traversable t, Functor f1, Functor f) => (f1 b -> c) -> (a -> a1 -> a2 -> a3 -> f (t (a4 -> [a5 -> b]))) -> a -> a1 -> a2 -> a3 -> f (a4 -> t (f1 a5 -> [c]))
11:59:28 <dustin> ?
11:59:44 <pharpend> dustin: I thought we were trying to create absurd type signatures
11:59:59 <pharpend> JagaJaga: Your pseudocode is actually matrix multiplication in disguise
12:01:27 <pharpend> JagaJaga: one sec, I'm installing the matrix library, I'll write a thing real quick
12:04:05 <JagaJaga> pharpend: that's will be very nice of you ^^
12:04:11 <merijn> Did I hear someone say matrix code? *points to #numerical-haskell*
12:06:50 <HeladoDeBrownie> takeItBackNowYall . traverse . traverse
12:08:22 <pharpend> JagaJaga: http://lpaste.net/112893
12:09:19 <JagaJaga> pharpend: thx, man, but I know it all..
12:09:38 <JagaJaga> pharpend: I really cant get how this can help me to get my result
12:09:59 <pharpend> JagaJaga: isn't that what you were trying to do? - take two 1-d lists, get a 2-d list as a result?
12:11:29 <JagaJaga> pharpend: well, i've wrote, that I need some other function, like `result[i][j] = y[i] * y[j] * (myFunction x[i]  x[j])` that's not a simple matrix mul
12:12:15 <pharpend> JagaJaga: take a look at Matrix.matrix http://hackage.haskell.org/package/matrix-0.3.4.0/docs/Data-Matrix.html
12:12:32 <pharpend> JagaJaga: Specifically - http://hackage.haskell.org/package/matrix-0.3.4.0/docs/Data-Matrix.html#g:2
12:14:00 <pharpend> JagaJaga: one sec
12:14:10 <JagaJaga> pharpend: owww :3
12:14:20 <mauke> > let values = [a,b,c,d] in map (\x -> map (\y -> x * y * f x y) values) values
12:14:22 <lambdabot>  [[a * a * f a a,a * b * f a b,a * c * f a c,a * d * f a d],[b * a * f b a,b ...
12:14:44 <mauke> ok, that would be more readable with spaces after the commas
12:18:47 <pharpend> JagaJaga: http://lpaste.net/112894
12:19:25 <freeman42> any idea what I am doing wrong here? http://lpaste.net/310467406117994496 trying to get quickcheck to generate random lists of Num instead of Integer
12:19:30 <pharpend> I can probably make that more readable
12:19:41 <mauke> freeman42: Num is not a type
12:20:05 <pharpend> freeman42: so, you would want x :: Num a => [a]
12:20:12 <mauke> pharpend: how would that help?
12:20:18 <JagaJaga> pharpend: oh! That's what i needed. nice. Thanks a lot!
12:20:31 <pharpend> mauke: how would what help?
12:20:36 * hackagebot remotion 0.2.0 - A library for client-server applications based on custom protocols  http://hackage.haskell.org/package/remotion-0.2.0 (NikitaVolkov)
12:20:38 * hackagebot references 0.3.0.0 - Generalization of lenses, folds and traversals to handle monads and addition.  http://hackage.haskell.org/package/references-0.3.0.0 (lazac)
12:20:39 <mauke> Num a => [a]
12:20:51 <pharpend> mauke: because that's a valid type, [Num] isn't
12:21:03 <mauke> to test that code you need to choose one particular type
12:21:14 <pharpend> mauke: ah okay
12:21:31 <pharpend> freeman42: in that case, probably you want to generate float values, because those are more exhaustive
12:21:57 <pharpend> JagaJaga: You can likely get the same result with lists, but matrices provide a nice abstraction
12:22:10 <freeman42> mauke, pharaun so there is no way to just choose Num and quickcheck to choose a random... subtype or whatever it is of Num? :)
12:22:22 <mauke> freeman42: Num is not a type and there are no subtypes
12:22:25 <freeman42> like, generate either [Integer] or [Float] etc.
12:22:38 <JagaJaga> pharpend: yeah. And they are faster?
12:22:45 <pharpend> freeman42: no, because there could be an infinite number of "subtypes" (technically, those don't exist)
12:22:53 <dustin> bitemyapp: I want to implement `filterBy :: (b -> Bool) -> (a -> b) -> (b -> a) -> [a] -> [b]`, but that does not feel very nice
12:23:31 <freeman42> mauke, pharaun oh, I got what you meant, ok, thank you :) no way to know all the instances
12:23:42 <mauke> freeman42: you can write a function (Num a) => [a] -> Bool to do the check, but each concrete test needs to run at some instance
12:23:45 <pharpend> JagaJaga: hmatrix probably is. I'm more familiar with the matrix library. Doing pure Vector operations (with the vector library) will probably be the fastest. You would want to benchmark them.
12:23:55 <mauke> freeman42: why are you excluding [], btw?
12:23:58 <dustin> bitemyapp: some higher lever abstraction that can filter a transformed list and transform it back before returning
12:24:21 <freeman42> mauke, no reason, editing an existing code, that needs to be taken out
12:24:53 <pharpend> one sec
12:26:05 <pharaun> freeman42: its pharpend not pharaun :)
12:26:31 <pharpend> pharaun: I briefly exited, so tab completion likely betrayed him
12:26:34 <freeman42> pharaun, hehe, yes, sorry :D
12:27:32 <pharaun> tab completion the betrayer
12:27:32 <pharpend> freeman42: did you ask me a question? I was briefly offline?
12:28:16 <freeman42> pharpend, no, just saying thank you for the help :)
12:28:22 <pharpend> freeman42: welcome
12:29:02 <freeman42> is there an IRC channel for the fp101x course? ^^
12:29:16 <pharpend> freeman42: probably
12:29:18 <pharpend> where's bitemyapp
12:29:24 <pharpend> he has a nice fp course
12:30:09 <MindIsAVortex> hello, student here, what does it mean if "Assertion failed after 1 test". I haven't seen this particular error before and I was wondering if anyone could give me some idea as to which direction I should be looking in.
12:30:40 <mauke> MindIsAVortex: what program is giving you this error?
12:31:04 <pharpend> mauke: sounds like a test framework, probably hunit
12:31:10 <ReinH> MindIsAVortex: Sounds like you're running a test suite.
12:31:58 <pharpend> MindIsAVortex: can you paste the code running your unit test to lpaste.net? Additionally, it may be helpful to see the code it's testing, so consider posting that to lpaste.net
12:32:31 <pharpend> MindIsAVortex: it probably means you wrote a unit test, and the test failed. This is a good thing, because you've found a bug in your code, that you can now fix.
12:33:37 <MindIsAVortex> ReinH: Yes, a test suite. Ok I'll do that but I have to probably mention it's for uni. If you could be mildly cryptic and not very direct about any help :S I would feel less guilty about it. Hehe
12:34:22 <pharpend> MindIsAVortex: it's always okay to ask for help
12:35:11 <MindIsAVortex> pharpend: lpaste.net/8439813429031600128
12:35:37 * hackagebot hspec-webdriver 0.3.2 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.3.2 (JohnLenz)
12:36:25 <ReinH> MindIsAVortex: that code doesn't seem related to any test assertions
12:36:40 <ReinH> MindIsAVortex: you need to find out which test assertion failed and why it failed.
12:36:43 <pharpend> MindIsAVortex: additionally, you shouldn't take monadic inputs
12:36:49 <mauke> pharpend: yes, you should
12:37:08 <pharpend> mauke: not really, no
12:37:17 <pharpend> mauke: at least not with the IO monad
12:37:17 <ReinH> ...
12:37:20 <mauke> pharpend: so liftM is bad?
12:37:24 <ReinH> This has nothing to do with the question
12:37:26 <mauke> it takes a monadic input
12:37:29 <pharpend> maybe with transformers
12:37:55 <mauke> the entire point of this thing is to run an action N times
12:37:58 <pharpend> mauke: those are corner cases. Your own functions ideally should not
12:38:00 <mauke> it's a control structure
12:38:14 <pharpend> mauke: *when it's not necessary
12:38:18 <MindIsAVortex> pharpend: well the input is what it is, that's just the assignment. the type declaration is given
12:38:18 <mauke> pharpend: I wish to unsubscribe from your newsletter
12:38:47 <pharpend> MindIsAVortex: okay
12:38:48 <ReinH> pharpend: Literally the entire point of this method is to run a simulation which gives potentially different results each time it is run
12:38:56 <pharpend> ReinH: ah okay
12:38:58 <pharpend> anyway
12:39:01 <ReinH> it *must* be run within IO or some other monadic context which allows such effects
12:39:08 <ReinH> Can we get back to the question now please?
12:39:28 <mauke> I didn't get an answer to mine
12:39:29 <pharpend> MindIsAVortex: can you paste the testing code?
12:40:08 <ReinH> MindIsAVortex: first paste the full test result. It should indicate the name or some other way to identify the failing test case.
12:40:10 <MindIsAVortex> pharpend: no, sorry. It's not on my computer
12:40:29 <pharpend> MindIsAVortex: okay, so, oh okay, so I see.
12:40:47 <mauke> MindIsAVortex: what's the exercise?
12:40:49 <pharpend> MindIsAVortex: can you maybe paste the specifications of what your function is supposed to do?
12:40:55 <pharpend> MindIsAVortex: what mauke said
12:41:53 <chrisdone> dudes check this modified ghci out http://lpaste.net/112895
12:42:48 <MindIsAVortex> pharpend: just in general, what is usually "asserted"? Because I understand the other error messages, like "zero denominator", or "time out". They're descriptive. But here it's an assertion... which could be anything really
12:42:56 <MindIsAVortex> mauke: I think so, wait
12:43:48 <mauke> what's asserted could be any condition at all
12:43:55 <mauke> so that makes it tricky
12:44:23 <JagaJaga> Isn't there a trick with lambdabot to make the normal form?) smth like `(\a -> a + a) 1` and (\a -> a * b)
12:44:39 <pharpend> MindIsAVortex: You give your code to a server (I presume), the server runs a test saying "given this input, this should be the output".
12:45:02 <pharpend> MindIsAVortex: So, on its first test, it tried some input, and got an unexpected output, thus, the assertion failed.
12:45:28 <mauke> JagaJaga: what's a normal form?
12:45:28 <MindIsAVortex> pharpend: ah, so a lot like JUnit testing?
12:45:38 * hackagebot linkedhashmap 0.2.0.0 - Persistent LinkedHashMap data structure  http://hackage.haskell.org/package/linkedhashmap-0.2.0.0 (abasko)
12:45:44 <pharpend> MindIsAVortex: Yes. In fact, he's probably using HUnit, a port of JUnit to Haskell.
12:45:55 <Guest28611> Hey there. I'm doing a haskell project, but I recently moved to Arch... I'm getting "could not find module 'Test.HUnit'" when I try and :l blah.hs in ghci
12:46:10 <pharpend> MindIsAVortex: Without knowing what the input & output are supposed to be, we can't really help you
12:46:14 <JagaJaga> mauke: An expression in normal form is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).
12:46:15 <pharpend> Guest28611: cabal install hunit
12:46:30 <mauke> > (\a -> a + a) 1
12:46:32 <lambdabot>  2
12:46:38 <mauke> like this?
12:46:43 <JagaJaga> > (\a -> a * a)
12:46:45 <lambdabot>  <Integer -> Integer>
12:47:01 <MindIsAVortex> pharpend: ok, well at least I know it's just a wrong answer case then. That helps a bit. Thanks!
12:47:03 <JagaJaga> > (\a -> a * b)
12:47:03 <mauke> yeah, only works for some values
12:47:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
12:47:05 <lambdabot>                     Debug.SimpleReflect.Expr.Expr)
12:47:05 <lambdabot>    arising from a use of ‘M458375850788139366924182.show_M4583758507881393669...
12:47:22 <JagaJaga> mauke: hmm:) thx.
12:47:25 <mauke> > (\a -> a * b) 2
12:47:26 <lambdabot>  2 * b
12:47:30 <mauke> (hax)
12:48:00 <spopejoy> what is the best way to type a list of (String,Typeable) pairs? I'm building a list of these to be an assoc-list or map-like structure.
12:48:06 <Guest28611> @pharpend Ahhh, thanks. I tried yaourt HUnit and I'm installing that right now
12:48:06 <lambdabot> Unknown command, try @list
12:48:23 <pharpend> Guest28611: arch linux isn't the greatest at managing haskell packages
12:48:43 <JagaJaga> > \ a -> (\ b -> y) (\ c -> y (y (\ d -> a a a)) (x x) a)
12:48:45 <lambdabot>  Couldn't match expected type ‘t1 -> t2 -> (t4 -> t5 -> t) -> t0’
12:48:45 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
12:48:45 <lambdabot>  Relevant bindings include
12:48:45 <lambdabot>    a :: t4 -> t5 -> t (bound at <interactive>:1:3)Couldn't match expected typ...
12:48:45 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
12:48:52 <pharpend> Guest28611: https://www.archlinux.org/news/managing-haskell-packages-with-ghc-782/
12:48:56 <Guest28611> pharpend: Yeah, I've noticed. Just got it this weekend, lost my old distro in the process.
12:49:27 <pharpend> Guest28611: basically, they won't support haskell stuff through pacman/yaourt. You have to install ghc and cabal-install, and do the rest with ghc
12:49:29 <ReinH> Guest28611: Strongly recommend you don't use your distro's package manager for Haskell packages. Use cabal.
12:49:46 <pharpend> Guest28611: yeah, what ReinH said, use cabal-install for Haskell packages.
12:49:51 <pharpend> Guest28611: especially on Arch
12:50:00 <Guest28611> I really just need haskell for a few more weeks AFAIK. Just for a class.
12:50:08 <pharpend> ReinH: I use Gentoo, portage is actually pretty good at managing haskell stuff
12:50:19 <pharpend> ReinH: better than cabal-install
12:50:25 <jhance> Guest28611: I think you mean for the rest of your life :)
12:50:31 <pharpend> ReinH: but, for most operating systems, yes, you are right
12:50:33 <ReinH> pharpend: Nix is quite good too.
12:50:39 <pharpend> ReinH: i've heard
12:50:43 <Guest28611> pharpend: I got it working with yaourt! Thanks a ton! Especially for the pointers
12:50:52 <spopejoy> Cabal is pretty bad.
12:51:05 <ReinH> Generally they lag behind by 6 months or so due to the release cycle of the stable "universe" or w/e your distro calls it, are not complete enough, etc
12:51:23 <Guest28611> pharpend: Yeah, I could use it later too :) But for my schedule, I won't be using it for at least a year
12:51:23 <merijn> spopejoy: Out of curiosity, which other package managers have you used?
12:51:26 <ReinH> spopejoy: it is, but it's also better than all the other Haskell package (non-)managers
12:51:35 <spopejoy> go, maven
12:51:38 <wolftune> hey folks, what is "Failing due to -Werror" ? And how do I fix it?
12:51:52 <wolftune> I searched and found nothing
12:51:57 <merijn> wolftune: -Werror makes every warning an error
12:51:59 <jhance> wolftune: -Werror means that its failing because there was a warning
12:52:03 <wolftune> oh
12:52:06 <spopejoy> anything that allows you to do project-by-project pkg mgmt. whereas cabal sandboxes are a black art.
12:52:10 <wolftune> there was indeed one warning
12:52:13 <pharpend> wolftune: the compiler is generating a warning, and -Werror means that warnings block compilation
12:52:24 <ReinH> spopejoy: How are they a black art?
12:52:25 <merijn> spopejoy: How are sandboxes a black art?
12:52:46 <wolftune> pharpend: thanks, so I see the warning, but gonna leave that for someone else to fix. How can I move on and compile anyway?
12:52:47 <ReinH> They put things in a known place in a known format with a human readable configuration and a decent command line interface
12:52:52 <merijn> spopejoy: Maven is probably about comparable to cabal, the difference is there's thousands more people polishing out the dependency issues of packages
12:53:05 <jhance> The necessity of sandboxes comes from the fact that anyone can publish packages to Hackage, not from the badness of Cabal itself
12:53:07 <pharpend> wolftune: what I would do is replace -Werror with -Wall
12:53:07 <mauke> wolftune: remove -Werror from the compiler options
12:53:24 <ReinH> We script cabal sandboxes rather heavlly at the moment and haven't had much trouble with them
12:53:25 <merijn> spopejoy: A lot of cabal issues are "dependency bounds are wrong", which requires maintainers to stay on top of that, but that's a nearly full-time job
12:53:31 <spopejoy> well, for one, why depend so much on hackage
12:53:32 <pharpend> wolftune: then, if you don't care about the warning, get rid of it
12:53:42 <merijn> spopejoy: Because it's convenient
12:53:43 <spopejoy> should be easy to grab a dep from multiple repos
12:53:45 <ReinH> merijn: And can usually be solved by *not* adding in optimistic upper bounds ;)
12:53:48 <jhance> spopejoy: What would you rather depend on?
12:53:50 <merijn> spopejoy: You can easily host your own repos if you want
12:54:02 <pharpend> spopejoy: additionally there's luite and fpcomplete
12:54:04 <merijn> ReinH: Or by not adding pessimistic upper bounds
12:54:05 <wolftune> pharpend: I don't want the warning to disappear, it's just not *my* code and I don't understand the warning. I want to move on and work on other things…
12:54:09 <jhance> spopejoy: You can use Stackage if you really want
12:54:12 <ReinH> merijn: or by not adding upper bounds.
12:54:17 <pharpend> wolftune: -Wall is what you want then
12:54:20 <wolftune> ok
12:54:22 <wolftune> thanks!
12:54:24 <spopejoy> so nobody thinks there's anything difficult about sandboxes. OK.
12:54:25 <merijn> ReinH: The problem is that due to cross-package inlining upper-bounds are far more brittle in haskell than other languages
12:54:35 <merijn> spopejoy: What's difficult about them?
12:54:42 <jhance> spopejoy: Whats difficult about "cabal sandbox init && cabal install"
12:54:43 <ReinH> merijn: Right. Major version upper bounds are tenable. Nothing else really is ime.
12:54:54 <ReinH> PVP *ought* to imply that major versions are exactly what you want to bound on anyway
12:54:54 <spopejoy> or putting in "constraint installed" for every haskell platform pkg
12:55:22 <merijn> ReinH: There's plans to create a "bounds tester", that'd be good :)
12:55:30 <athan> spopejoy: `cabal sandbox init && cabal sandbox add-source /path/to/major/dependency && cabal install`?
12:55:32 <ReinH> ofc this requires maintainers to care about pvp ;)
12:55:40 * hackagebot persistent-zookeeper 0.1.0 - Backend for persistent library using Zookeeper.  http://hackage.haskell.org/package/persistent-zookeeper-0.1.0 (junjihashimoto)
12:55:56 <ReinH> merijn: I don't mean to imply that cabal is terrible. Most package managers are bad. It's a hard thing to do well.
12:56:07 <merijn> ReinH: strict PvP adherence is hard and takes a lot of work
12:56:12 <spopejoy> yes, maven is AWFUL
12:56:28 <ReinH> merijn: it is, but "bump the major version for imcompatible changes" isn't *that* hard
12:56:33 <spopejoy> but go and node.js seem to "get" project-oriented pm
12:56:41 <merijn> ReinH: I always hear people complain about cabal, but these usually fall into two categories: 1) never used auttools/cmake or vaugely C related
12:57:01 <ReinH> spopejoy: they "get" it by creating project-specific local caches of everything without any sharing.
12:57:02 <pharpend> merijn: Gem is really nice. sort of wish cabal was like that.
12:57:11 <ReinH> spopejoy: Which is what sandboxes do, but apparently you don't like those
12:57:12 <spopejoy> but isn't that better?
12:57:17 <pharpend> merijn: but on the other hand, ruby is generally terrible
12:57:19 <merijn> spopejoy: node.js simply imports the entire dependencies into the local project and sweeps any incompatibilities under the rug, because it can't check for differences between versions anyway
12:57:30 <spopejoy> but i like that.
12:57:39 <spopejoy> esp. when deploying
12:57:47 <ReinH> spopejoy: if you like npm, you should like cabal sandbox
12:57:51 <spopejoy> last thing I want to do is worry about /usr/include
12:57:55 <ReinH> so what don't you like about it? the user experience?
12:58:06 <spopejoy> agree that I'm not a big make/cmake/configure guy
12:58:10 <merijn> cabal can't do what gem/npm do, because ruby and node.js don't need to compile
12:58:19 <merijn> There's no types, no nothing
12:58:40 <merijn> the package managers just blindly believe the bounds specified are correct and if they're not your code will just fail at runtime
12:58:44 <spopejoy> i will give sandboxes another go. I couldn't find a very good intro
12:58:58 <ReinH> merijn: the correct analogy anyway is cabal <-> npm install -g, cabal sandbox <-> npm
12:59:01 <spopejoy> and got scared off by some discussions here where people seemed to be struggling
12:59:17 <merijn> spopejoy: The thing is, there's not much to intro beyond "cabal help sandbox", see http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:59:19 <ReinH>  spopejoy http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html ?
12:59:29 <spopejoy> thx
12:59:47 <ReinH> You basically "cabal sandbox init" and you're done for 90% of its uses
12:59:51 <spopejoy> i assume you still need constraints on all platform pkgs
13:00:10 <spopejoy> that was a terrible newb exp for me.
13:00:18 <ReinH> spopejoy: you don't *need* constraints, no
13:00:22 <spopejoy> yes you do.
13:00:34 <ReinH> You do not. Unless there are specific version incompatibilities you want to rule out.
13:00:39 <spopejoy> as soon as something breaks transformers or something.
13:01:06 <knic27> Is this the place to ask beginner lang questions?
13:01:09 <ReinH> Yes, if a version of something is incompatible you need to constrain it. This is true of every thing that has both dependencies and versions of things.
13:01:12 <merijn> knic27: Sure
13:01:39 <spopejoy> again: *i'm not an expert*. All of a sudden my builds broke and it was b/c cabal d/l'd an incomaptible pkg.
13:01:48 <ReinH> spopejoy: Sure, and then you need a constraint.
13:01:53 <ReinH> You dont *always* need constraints.
13:01:56 <spopejoy> the solution was to constrain. see "cabal of cabal" article.
13:02:00 <vanila> knic27, yeha
13:02:08 <ReinH> Many configurations of packages are perfectly happy to install without constraints
13:02:18 <ReinH> Especially if you use Stackage
13:02:36 <merijn> ReinH: I dunno, I've just come to accept many people's cabal experience appears to be vastly different from mine
13:02:44 <mauke> ReinH: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
13:02:51 <ReinH> mauke: I'm familiar.
13:03:02 <ReinH> mauke: I real monochrom's stuff pretty religiously ;)
13:03:15 <merijn> I have >140 global package installs and rarely have issues, other people claim to have "everything break" as soon as they have 5 packages in a sandbox
13:03:17 <spopejoy> ReinH: he's the cabal of cabal guy. he rec's locking down all haskell plaf pkgs
13:03:58 <spopejoy> as soon as I followed his advice, no more issues. doing global cabal.
13:04:06 <knic27> ok… I think I’m missing something fundamental about types. I’m trying to understand how Applicative works. I’m walking step-by-step through: pure (+) <*> Just 3 <*> Just 5
13:04:18 <knic27> just a sec.. will get to my question
13:04:18 <ReinH> spopejoy: Yes, one way to avoid the problem is to always constrain everything.
13:04:24 <ReinH> I'm just saying it's not *necessary*
13:04:29 <spopejoy> agree
13:04:33 <spopejoy> i'm lazy
13:04:58 <spopejoy> i hate pkg mgmt/dependency hell. unavoidable problem in sw eng
13:05:08 <ReinH> Always constraining everything can itself be problematic, because now you have an NP hard problem of managing proper constraints for everything
13:05:12 <merijn> I think one issue is many people don't carefully consider what cabal tells them when it fails and blindly try whatever flags the warning mentions without considering it's the right way to go in this specific scenario
13:05:13 <ReinH> and you can't ask your computer to help you solve it
13:05:34 <merijn> spopejoy: Well, the backpack project will hopefully dramatically improve the situation in the medium-term future
13:05:36 <ReinH> because if you wanted your computer to solve it for you, you wouldn't have used the constraints in the first place :p
13:05:40 <spopejoy> my problem is, cabal *succeeded* but compile failed
13:05:56 <ReinH> spopejoy: then your constraints were probably wrong, like I just mentioned ;)
13:06:02 <spopejoy> will look at stackage and backpack
13:06:43 <dmj`> spopejoy: do you use sandboxes?
13:06:44 <ReinH> plugging in a correct solution to the constraints equation does not guarantee that the actual libraries are compatible with each other, just that their version numbers are
13:06:44 <merijn> spopejoy: That would mean the bounds were wrong. i.e. your bounds specified you could use package X-0.1.0, but 0.1.0 actually had an icompatible implementation for your code, causing the build to fail
13:07:03 <merijn> spopejoy: stackage is usable right now, backpack is still in design and prototype stages
13:07:07 <knic27> so :t pure (+) = f (a -> a -> a) and :t (<*>) = f (a -> b) -> f a -> f b… so my question is why am I allowed to pass as the first arg to <*> which expects a f (a->b) a f (a -> a -> a)… it seems the arity is wrong yet it still works
13:07:36 <merijn> knic27: Ok, I have a learning question for you
13:08:00 <vanila> knic27, it just makes b = a -> a
13:08:03 <merijn> knic27: Since "->" is a binary operator, could you add parentheses to the signature "a -> a -> a" to indicate how the ->'s are grouped?
13:08:06 <dmj`> knic27: it will be curried. f (a -> a -> a) can also be, f ((a -> a) -> a)
13:08:08 <merijn> vanila: Spoilers :(
13:08:12 <merijn> dmj`: That's wrong
13:08:12 <mauke> dmj`: no
13:08:17 <dmj`> oh?
13:08:23 <exio4> f (a → (a → a))
13:08:23 <dmj`> ok teach me now :)
13:08:31 <merijn> dmj`: -> is right associative as I was trying to establish with my question
13:08:32 <mauke> knic27: consider 'id length "hello"' - same problem but less class noise
13:08:35 <ReinH> Let's let the person who was asked the question answer it in the future please
13:08:49 <ReinH> It doesn't help them to have others (incorrectly!) answer it for them
13:08:56 <dmj`> ReinH: understood
13:09:08 <ReinH> thanks
13:09:22 <knic27> okay… hmm, this is going to take me a while since im still *very* slow parsing the syntax
13:09:29 <merijn> dmj`: Also, that isn't currying :)
13:09:49 <merijn> knic27: I recommend not reading anything anyone wrote but my question, for optimal educative experience :p
13:09:52 <ReinH> knic27: Let's do some simple symbol manipulation here
13:10:02 <dmj`> merijn: then please explain it to me as well
13:10:03 <ReinH> knic27: you have (a -> b) and (a -> (a -> a))
13:10:16 <ReinH> knic27: what can you set b to be to make the two equivalent?
13:10:24 <merijn> dmj`: Well, look at the type of curry
13:10:26 <merijn> :t curry
13:10:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
13:10:54 <merijn> dmj`: Currying is about how to take arguments, what you're referring to is just partial application
13:11:07 <ReinH> knic27: pretend it's (a + b) = (1 + (1 + 1)), what are a and b?
13:11:07 <athan> dmj`: Currying turns cartesian products into implication :P (...right?)
13:11:08 <merijn> Or really just "function application"
13:11:39 <knic27> 1 & 2, no?
13:11:51 <ReinH> knic27: and if you don't simplify b?
13:11:59 <athan> dmj`: ie A x B -> C :- A -> C => B (I think)
13:12:03 <merijn> ReinH: I think the crucial step you're skipping over that my question was intended to explain is the associativity of -> :)
13:12:11 <ReinH> athan: the prod/hom adjunction :)
13:12:17 <ReinH> merijn: yes but someone let that cat out of the bag already ;)
13:12:47 <knic27> okay… i think is coming slowly into focus… going to take this offline and mull for a bit… thanks for the help
13:13:11 <athan> ReinH: O: Man, I really need to master CCC's. They hardly make sense to me at the moment :/ I can't tell if I'm using arrows in CT, or entailment, or a partial order... :S
13:13:37 <zyaku> knic27: An easier way to think of it might be to look at the first argument type of <*>: f (a -> b)
13:13:40 <snoopybbt> hello guys
13:13:43 <merijn> knic27: If we take out all the typeclass voodoo, consider the following question: "add :: Int -> Int -> Int", what is the type of "add 1"?
13:13:43 <ReinH> athan: :)
13:14:01 <zyaku> knic27: the b in f (a -> b) is just equivalent to a -> a in you question.
13:14:06 <knic27> Int -> Int
13:14:06 <snoopybbt> is there a convention for which variables must begin with lowercase letter ?
13:14:17 <ReinH> athan: http://en.wikipedia.org/wiki/Tensor-hom_adjunction
13:14:33 <merijn> knic27: Right, so if we have "f :: a -> b" and "x :: a" then "f x :: b", right?
13:14:47 <athan> ReinH: Thank you :)
13:14:51 <ReinH> athan: :)
13:15:08 <knic27> zyaku: ahh thanks, the b = a -> a clears things up
13:15:10 <merijn> knic27: So what's happening is just that 'b' happens to be another function
13:15:29 <athan> ReinH: Oh btw, I'm working on a category diagramming web application... do you think it'll be useful for ##category-theory?
13:15:39 <athan> It'll be like an lpaste for category diagrams
13:15:57 <zyaku> knic27: happy to help
13:16:02 <vanila> zyaku++
13:16:07 <dmj`> merijn: in haskell all functions are considered curried thou
13:16:09 <dmj`> tough*
13:16:13 <dmj`> though*
13:17:02 <ReinH> athan: Perhaps, although folks might to prefer something that rendered TeX diagrams (AMScd, xypic, etc) into SVG or other formats with a nice interface
13:17:16 <ReinH> I'm not sure CT folks are really the WYSIWIG type ;)
13:17:56 <ReinH> athan: This sort of exists as http://presheaf.com/ except for the part where I said "nice interface" ;)
13:19:14 <athan> ReinH: Oh woah! Yeah, I was trying to make something really drag-and-drop-y. ehh. This is cool though :)
13:19:41 <ReinH> athan: :)
13:20:37 <bmcorser> i'm getting issues trying to install hlint
13:20:42 <bmcorser> "hlint-1.9.9 depends on uniplate-1.6.12 which failed to install."
13:21:01 <bmcorser> new to haskell, so traceback is pretty opaque to me :P
13:21:46 <ReinH> athan: the internal hom of a CCC is part of the tensor-hom adjunction, Hom(A x B, C) ~= Hom(A, Hom(B, C)) :)
13:21:54 <luite> athan: using the diagrams package?
13:21:57 <ReinH> athan: see Mac Lane chapter 9 ;)
13:22:46 <ReinH> athan: (more generally, any monoidal closed category)
13:22:52 <bmcorser> (os x 10.10, latest cabal)
13:23:30 <aisatsana> Hi, I am currently doing an assignment where I need to model a datatype "Expression". An expression can consist of Numbers, 1 variable, Operators and functions. I am quite shitty at haskell still though anyone who could point me in a direction where I'd be able to get more information regarding modelling of "flexible" datatypes?
13:23:56 <Hijiri> flexible in what way?
13:24:36 <ReinH> athan: (and the fact that apply : Hom(B,C) x B -> C is extranatural in C leads you, I think, to some of edwardk's newer crazy profunctorial Hask stuff)
13:24:44 <JagaJaga> Are here smone close to Data.Array.Repa? How to make Array U DIM2 Double from list? fromList can't help me, i really don't know what to pass as shape.
13:24:51 <ReinH> athan: athough I really don't understand all of that very well yet
13:24:58 <rrradical> aisatsana: this may interest you: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:25:23 <athan> ReinH: Goodness... I'm excited :)
13:25:43 * hackagebot ariadne 0.1.2.2 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1.2.2 (RomanCheplyaka)
13:25:45 <ReinH> athan: (extranatural implies that it has both a covariant and contravariant component, so profunctorial)
13:26:30 <hiptobecubic> aisatsana, https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
13:26:42 <hiptobecubic> aisatsana, oh someone already linked that  :)
13:26:46 <ReinH> athan: you might see some connections to Ed's stuff here: http://ncatlab.org/nlab/show/extranatural+transformation
13:27:39 <athan> ReinH: O.O Thank you, dearly!
13:27:48 <aisatsana> I've actually seen that book before might be worth a second look :) It's for a graphical calculator basically so I need to be able to represent my expression in the form of a datatype
13:27:55 <ReinH> athan: yet another instance of Mac Lane being first by about 40 years ;)
13:28:50 <ReinH> athan: The Codensity trick Is an exercise in CWM...
13:29:39 <merijn> aisatsana: Do you know how to define a tree datatype in Haskell?
13:29:48 <Hijiri> Is there an elisp script for uploading the current buffer to lpaste?
13:30:04 <benzrf> tfw nlab completely flies over my head
13:30:07 <luite> athan: if you're using haskell/diagrams, http://paste.hskll.org might be intersting or useful as a starting point (renders diagrams from haskell source though, no drag and drop)
13:30:08 <dustin> in emacs, is there a way to jump to the source of a haskell function
13:30:14 <dustin> e.g. how can i get to the source code of `length`
13:30:20 <ReinH> Hijiri: chrisdone wrote his own https://github.com/chrisdone/chrisdone-emacs/tree/master/packages/lpaste
13:30:30 <Hijiri> thanks
13:30:37 <Hijiri> I should probably learn lisp
13:30:39 <Hijiri> since I'm using emacs
13:30:47 <merijn> dustin: I'm not sure that's possible in the general case, since you can use packages without having the source installed
13:30:59 <ReinH> dustin: assuming you have a tag file and haskell-mode, M-., but you'd need to build tags for base to get length
13:31:02 <dustin> well how can i gootle it then
13:31:02 <dmj`> dustin: you can use lambdabot to print out source
13:31:08 <dmj`> @src length
13:31:08 <lambdabot> Source not found. Do you think like you type?
13:31:13 <dmj`> maybe not :)
13:31:18 <merijn> dustin: If you go to Hoogle there's a source link on the right of the docs
13:31:21 <ReinH> dustin: hoogle, hackage has a "Source" link in the top ri...
13:31:22 <dustin> ah
13:31:22 <ReinH> damn it
13:31:26 <luite> athan: although i don't know if the tikz backend for diagrams is good enough for print quality ct diagrams yet :)
13:31:31 <merijn> dmj`: lambdabot only does a lookup in a predefined database
13:31:33 <ReinH> merijn: I can see that you have this under control.
13:31:47 <ReinH> dmj`: (which lies about some things for simplicity / pedagogic purposes)
13:31:56 <athan> luite: Oh woah... Yeah mine was going to be really literal and simple, actually no haskell code going into it haha
13:32:15 <athan> luite: Just an SVG web application that keeps track of the objects / arrows in it's url hash
13:32:27 <merijn> dustin: Also, if you add "documentation: True" to ~/.cabal/config and add "  hyperlink-source: True" under the "haddock" entry in .cabal/config cabal will automatically 1) install local docs and 2) create source links in there
13:32:51 <merijn> I consider it a flaw that those two are not default :\
13:32:51 <ReinH> luite: xypic is pretty good
13:33:05 <ReinH> merijn: +1
13:33:28 <monochrom> like I said, "cabal doesn't want you to write Haskell!"
13:33:33 <monochrom> :)
13:33:36 <merijn> The first thing I do after installing cabal is enable docs and profiling before I build anything
13:34:12 <monochrom> hmm, I should update my page to mention the new config file option
13:34:24 <ReinH> luite: if you don't need diagonal lines ASMcd is reasonable. What I really want is to figure out how Eugenia Cheng does her ridiculous diagrams/illustrations.
13:34:24 <merijn> There's also a Hoogle entry under "haddock" now, but I'm not entirely sure what it does and how it'll deal with Hoogle not yet being installed after installing cabal...
13:34:57 <ReinH> merijn: I saw it, I set it to "True" and got an error even though the default is False, so I backed away slowly.
13:35:44 * hackagebot fay 0.21.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.0.2 (AdamBergmark)
13:36:17 <dustin> why is `filter` implemented with recursion rather than with a fold
13:36:23 <dustin> in prelude
13:36:37 <ReinH> luite: hmm, seems like some of it can be done with TikZ pretty nicely: http://tex.stackexchange.com/questions/157089/drawing-diagrams-of-higher-categories-with-tikz
13:36:54 <merijn> dustin: Usually the answer to "why is Prelude function X implemented in weird way Y, rather than obvious way Z?" is "optimisation"
13:37:29 <aisatsana> merijn: No but that does sound helpful, because this assignment brought me back to the initial chapter of SICP where expressions are basically described by a tree structure and talking about how it's evaluated recursively
13:37:33 <ReinH> base seems to like manual worker/wrapper transforms quite a bit
13:37:42 <monochrom> dustin, the source code you see may not be as important as the rewrite rules you probably skipped. the rewrite rules are what the optimizer uses to change your code beyond recognition.
13:38:29 <merijn> aisatsana: The clue is the following: There's a reason Abstract Syntax Trees (ASTs) are called trees
13:38:54 <aisatsana> merijn: I'll be sure to check it out thanks for the pointer :)
13:38:55 <merijn> aisatsana: You'll want something vaguely tree like with one constructor per "type" of expression you need to support
13:39:00 <luite> ReinH: ah tnx, i just checked the xypic manual and it actually looks better than i thought, i've only used it for some very simple things based on examples. downside is that it seems less readable than perl (in particular the later examples involving splines)
13:39:15 <monochrom> in particular, "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
13:39:32 <monochrom> that is going to override the source code very often
13:40:13 <ReinH> luite: better use of whitespace can help with that *slightly*
13:40:24 <dustin> interesting thanks
13:42:00 <Ouyang> Question, what is wrong with my import on line 22                                                     adlan
13:42:12 <Ouyang> err i aplogize
13:42:26 <Ouyang> https://github.com/Beaudidly/dotfiles/blob/master/.xmonad/xmonad.hs
13:43:01 <Ouyang> I have the file it refers to in the same directory, should I but it in some other location? I am sorry for the lack of clarity
13:43:22 <merijn> ReinH: My biggest problem with being in the US atm is that I keep missing the time that dcoutts is online so I can't ask him stuff like "what the hell is the hoogle field supposed to do?" :p
13:43:36 <dcoutts> ha hah
13:43:36 <ReinH> merijn: heh
13:43:51 <merijn> dcoutts: Speak of the devil, what's the answer to my question? ;)
13:44:01 <dcoutts> where is that field?
13:44:08 <merijn> dcoutts: Under "haddock"
13:44:22 <dcoutts> oh in the ~/.cabal/config
13:44:26 <merijn> Yeah
13:44:29 <ReinH> Ouyang: iirc they're supposed to go in ~/.xmonad/lib or so? Also, BSP? Cool.
13:44:41 <ReinH> Ouyang: I think the manual gives the correct location
13:44:43 <dcoutts> merijn: the config file is more or less in 1:1 correspondence with the command line interface
13:44:49 <dcoutts> so check the --help
13:44:58 <Ouyang> ReinH: thank you! also what manual should I look at?
13:45:07 <ReinH> Ouyang: probably the xmonad manual? ;)
13:45:15 <dcoutts> merijn: so cabal haddock --help says:
13:45:16 <dcoutts>     --hoogle                Generate a hoogle database
13:45:17 <merijn> I don't have Hoogle installed yet, so I was wondering whether things would break if I enabled it before I installed hoogle...
13:45:39 <Ouyang> I tried looking for that on their wiki ReinH , but nothing.  Also I did have it in my lib folder under .xmonad and I got the same errors
13:45:41 <merijn> dcoutts: I have a completely unrelated question, btw.
13:45:46 <dcoutts> merijn: no, since it's a haddock feature I think
13:46:03 <ReinH> Ouyang: Look in the "Modular Configuration" heading http://xmonad.org/manpage.html#TOC
13:46:35 <ReinH> Ouyang: you probably need to --recompile or even --restart
13:46:44 <ReinH> Also I think there's #xmonad, but it might not be very active
13:47:03 <Ouyang> it isn't, I wasn't sure if this was a haskell question or not
13:47:07 <dcoutts> merijn: better ask quick, I'm about to disappear
13:47:08 <merijn> dcoutts: I have some C++ code that I use for testing that links to an external C library. I know how to hook cabal to just call make to build my code, but I don't know how to get cabal to tell my make process about library/include locations
13:47:31 <ReinH> Ouyang: It's valid Haskell, so now it's a "where does xmonad look for imports?" question :)
13:47:54 <merijn> dcoutts: I can't use pkg-config, because for some stupid reason pkg-config doesn't handle multiple different versions of the same library, so I need to specify explicit paths to the different versions
13:47:59 <dcoutts> merijn: you mean your custom Setup.hs invokes make? and you want to pass stuff?
13:48:05 <merijn> dcoutts: Yeah
13:48:16 <dcoutts> merijn: or for an installed haskell lib that the C will link against?
13:48:18 <Ouyang> ReinH, where does Haskell look for imports?  I spent a bit searching for that too
13:48:18 <merijn> dcoutts: Although I'm open to non-make solutions that integrate better with cabal
13:48:32 <dcoutts> merijn: passing flags to ./configure or make is ok
13:48:33 <ReinH> Ouyang: The question is "where does *xmonad* look for imports?" :)
13:48:41 <Ouyang> Because I learned how to add paths for C
13:48:45 <dcoutts> merijn: all the info is available in the LocalBuildInfo
13:48:48 <merijn> dcoutts: I don't have a configure file, on account of autotools being satan
13:48:54 <Ouyang> ReinH, yeah I know.  I was just curious for further learning and uses
13:49:05 <ReinH> And the answer appears to be GHC's search path plus ~/.xmonad/lib :)
13:49:13 <merijn> dcoutts: Also, I don't know which flags to pass to make in my Setup.hs hooks
13:49:29 <merijn> dcoutts: I don't know where users put the relevant C libraries on their system
13:50:19 <dmj`> merijn: I think I see where I was wrong, "Where partial application takes a function and from it builds a function which takes fewer arguments, currying builds functions which take multiple arguments by composition of functions which each take a single argument"
13:50:36 <dmj`> merijn: so in the case of pure (+) <*> pure 1 that is just partial application
13:50:55 <jhance_> If i'm installing package X which depends on Y is there a way to force a flag for package Y during the process
13:51:11 <dmj`> :t pure (+) <*> pure 1
13:51:12 <lambdabot> (Applicative f, Num a) => f (a -> a)
13:51:25 <merijn> dcoutts: Basically, I have 3 C++ program that link against different ZeroMQ libraries that I want to test my haskell library against. And due to pkg-config not supporting multiple installed versions of ZeroMQ I'm needing to explicitly pass "zmq1", "zmq2" and "zmq3" paths to be able to run my tests. atm I just have those paths hardcoded for my system, but that means no other user will ever be able to run tests without changing th
13:51:37 <merijn> jhance_: No
13:52:08 <merijn> jhance_: Which is why flags should not impact the exposed interface of a package
13:52:24 <jhance_> merijn: Well one of the dependencies has a bug that makes it not compile unless it has a specific flag (pandoc)
13:52:59 <kadoban> Yeah, that pandoc bug is annoying...hakyll still forces that exact version apparently, so every time I have to use it, you have to specially install pandoc first, sigh.
13:53:02 <merijn> jhance_: You can manually install pandoc with said flag and then install your package, but a permanent fix requires patching pandoc to not be buggy
13:53:16 <jhance_> Thats what I did, and hakyll still tries to reinstall pandoc
13:53:31 <jhance_> I guesss I'm missing some other flag
13:53:40 <merijn> jhance_: Perhaps you installed a pandoc version newer than what hakyll supports?
13:53:49 <kadoban> jhance_: Did you install the exact version it needs? IIRC it should be 'cabal install pandoc-1.13.1 -fhttps && cabal install hakyll'
13:53:49 <jhance_> merijn: no, I forced the right version when I installed it
13:54:28 <ReinH> Ouyang: perhaps the issue is that your directory structure does not correspond to the module namespacing
13:54:47 <merijn> Looks like -fhttps is already default?
13:55:04 <ReinH> Ouyang: for instance, XMonad.Stack.MyAdditions should be in ~/.xmonad/lib/XMonad/Stack/MyAdditions.hs
13:55:27 <kadoban> At least on my setup it wasn't, it breaks without that with that old pandoc version. I think current pandoc installs fine...but hakyll can't use that. Fun
13:55:28 <jhance_> merijn: I think when I install pandoc independently I need -fnetwork-uri
13:55:29 <merijn> jhance_: Is your cabal database up to date?
13:55:39 <jhance_> merijn: Yes
13:55:52 <jhance_> What cabal is doing when it installs pandoc as a dep of hakyll is Flags chosen: network-uri=True, make-pandoc-man-pages=False, https=False, trypandoc=False, embed_data_files=False
13:56:05 <merijn> oh
13:56:10 <merijn> I see the problem
13:56:17 <merijn> hakyll is requiring network 2.6
13:56:24 <merijn> pandoc requires network <2.6
13:56:49 <jhance_> well thats just fantastic
13:57:10 <merijn> jhance_: You can try grabbing pandoc sources and tweaking it's dependencies
13:57:14 <ReinH> merijn: what did we JUST say about upper bounds? ;)
13:57:25 <ReinH> merijn: or a judicious use of --allow-newer?
13:57:27 <merijn> ReinH: Actually, this upper bound is right
13:57:31 <kadoban> Is that current? Because I just reinstalled hakyll like...two days ago, tops.
13:57:32 <ReinH> merijn: ah
13:57:43 <merijn> ReinH: network 2.6 moved uri parsing to network-uri
13:57:49 <merijn> To avoid a parsec dependency
13:58:02 <ReinH> merijn: Is that a correct minor version bump?
13:58:05 <ReinH> PVP-wise?
13:58:23 <merijn> So pandoc needs to be updated to depend on EITHER network-2.5 OR network-2.6 && network-uri-2.6
13:58:26 <merijn> ReinH: Yes
13:58:31 <ReinH> merijn: gotcha
13:58:40 <merijn> ReinH: PVP specifies a.b determines compatibility
13:58:50 <ReinH> merijn: ah
13:59:18 <merijn> jhance_: It should not be very hard to modify pandoc's dependencies to work with network-2.6, I'm pretty sure nothing else broke
13:59:22 <ryantrinkle> has anyone played around with conal's lambda-ccc?
13:59:43 <merijn> jhance_: Don't forget to submit a pull request to pandoc if you change them!
14:00:51 <merijn> Alternatively, file a pandoc issue (you can grab the relevant details/fix from this convo) and wait for someone else to fix it
14:05:38 <athan> ryantrinkle: I will now!
14:10:08 <monochrom> dcoutts: is it intended that on hackage, Cabal is at 1.20.0.2, cabal-install is slight "ahead" at 1.20.0.3?
14:12:23 <sadsiren> hello friends
14:14:24 <benzrf> hello sadsiren
14:15:49 * hackagebot hlint 1.9.10 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.10 (NeilMitchell)
14:16:36 <JagaJaga> what type is this lambda? (\a -> a a) (\b c -> c)? Or it is infinite? And that's why we can't tell it's type?
14:17:07 <mauke> yeah, that needs recursive types
14:17:53 <mauke> (\a -> a a) :: t@(t -> r)
14:17:58 <mauke> except that's not valid syntax
14:18:06 <vanila> JagaJaga, you can never do (\a -> a a) in haskell
14:18:33 <vanila> a would have to be a function whose first parameter has the same type as a
14:18:37 <merijn> eh
14:18:43 <merijn> @src fix
14:18:43 <lambdabot> fix f = let x = f x in x
14:18:45 <vanila> a :: T, with a :: T -> x
14:18:58 <merijn> oh wait
14:19:05 <merijn> No, you're right that's an infinite type
14:19:07 <vanila> but the occurs check stops you from making functions like that (where the type is infinite)
14:21:01 <monochrom> (\b c -> c) is ok.
14:21:06 <monochrom> @type (\b c -> c)
14:21:07 <lambdabot> t -> t1 -> t1
14:22:19 <JagaJaga> Oh, nice, thx!
14:25:50 * hackagebot reroute 0.2.1.0 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.1.0 (AlexanderThiemann)
14:31:03 <Fuuzetsu> from today I will call pointed sets “0-tuply monoidal 0-categories”
14:31:11 <benzrf> :O
14:32:15 <Fuuzetsu> I don't know why but nLab said so, so it must be right
14:33:32 <sadsiren> guys i figured out compiling
14:33:42 <sadsiren> im the smartest person ever
14:39:33 <benzrf> wOW
14:43:40 <structuralist> what's the difference between Control.Monad.Error (from mtl) and Control.Monad.Trans.Error (from transformers)?
14:43:46 <structuralist> and which one should I use
14:43:52 <merijn> structuralist: Basically, almost nothing
14:44:00 <merijn> structuralist: mtl is a wrapper around transformers
14:44:26 <merijn> structuralist: It provides typeclasses that let you interact with transformer stacks more easily, by auto-lifting operations through the stack
14:44:39 <structuralist> oh, like MonadError
14:44:41 <merijn> structuralist: transformers is probably simpler to start with and will give cleaner type errors
14:44:49 <structuralist> I see, thanks
14:45:11 <monochrom> mtl adds the abstract type class MonadError over the concrete types Control.Monad.Error and ErrorT
14:45:11 <merijn> structuralist: mtl is something you start using when you realise that "lift . lift . lift $ my operation" is starting to become really tedious ;)
14:45:38 <monochrom> and ReaderT X (Error Y) etc
14:46:03 <structuralist> are there any incompatibilities to know about or is mtl strictly just that feature added to transformers?
14:46:18 <monochrom> strictly just that feature added
14:46:24 <structuralist> cool
14:46:25 <merijn> structuralist: mtl is strictly a re-export of transformers (well, assuming matching versions)
14:51:32 <maestro> when using ExistentialQuantification is it possible to auto-generate all the instances of AnyClass? for example: data AnyShow = forall a . Show a => AnyShow a  .. I would like the compiler to auto-generate instance Show AnyShow where show (AnyShow x) = show x
14:52:28 <mauke> I'd expect show (AnyShow x) = "AnyShow " ++ show x
14:53:37 <maestro> mauke that is true. but expecting that from a compiler would be unrealistic, and I have a bunch of functions where I'd be happy with  foo (AnyObj x) = foo x
14:53:59 <maestro> I find myself writing that over and over again
14:54:16 <merijn> maestro: Correct, which is why existential quantification is largely an antipattern
14:54:21 <merijn> @where existential-antipattern
14:54:22 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
14:54:37 <merijn> The correct approach is usually to Scrap Your Typeclasses
14:54:47 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
14:54:48 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
14:54:49 <lambdabot> Title: Haskell for all: Scrap your type classes
14:54:52 <maestro> I've read that.. don't really want to turn this into a discussion about the merrits of existential qualification
14:55:16 <merijn> maestro: Well, if you don't want that discussion, the answer is simple: Yes, you will have to write a ton of boiler plate
14:55:27 <merijn> maestro: And: No, there's no way around that
14:55:37 <maestro> sure there is, template haskell, if all else fails
14:55:41 <merijn> Which is why they're generally considered an antipattern
14:55:53 <merijn> maestro: Well, there you go, you have your answer, then
14:56:09 <maestro> not generally, no. if you see the comment section there's a disagreement whether it is an anti-pattern or not
14:56:28 <maestro> and whether his approach can replace typeclasses in all the cases
14:56:34 <onyxite> maestro: sounds like you are asking for something like GeneralizedNewtypeDeriving?
14:56:46 <merijn> maestro: I'm not saying it existentials are never needed
14:56:56 <maestro> onyxite I guess
14:56:58 <merijn> maestro: An anti-pattern is something which is *usually* wrong, not always
14:57:44 <merijn> I've used existentials with great success before, but your example does little to motivate the need for them. And even in cases where they're needed, you do need to write all the boiler plate yourself
14:57:46 <exio4> an average programmer doesn't use some feature, the good programmer knows when he should it? :P
14:59:02 <merijn> exio4: I've not found a lot of uses for existentials other than 1) hiding DataKinds polymorphism in the absence of ImpredicativeTypes and 2) Typeable + existential to force the compiler into doing something I know is typesafe due to my design, but which the compiler can't see
14:59:37 <volty> ah, the nice part --- thinking about abstract interface of a gui, but when (and if) the pure majesty goes down, landing on the real earth, little or nothing of that gets implemented/ Ah! Many states and many casual signals, nothing functional, nothing pure when it comes to the human clicker
15:00:54 * hackagebot hspec-meta 1.12.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.1 (SimonHengel)
15:03:08 <Monorail0> Hi. I'm trying to write a function that substitutes elements in a list. eg ["hello", "there", "hello", "there"] => ["hi", "hi"]. Is there a better way to do this kind of matching besides just using singular !! matching and recursing?
15:03:53 <merijn> Monorail0: Why do you need the !! when recursing?
15:04:57 <Monorail0> take :)
15:05:17 <merijn> Monorail0: Why not do that in the pattern match?
15:05:54 * hackagebot hspec 1.12.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.1 (SimonHengel)
15:05:58 <benzrf> Monorail0: hmmm... off the top of my head, i'd write a helper function like
15:06:22 <benzrf> dropIfEqual :: Eq a => [a] -> [a] -> [a]
15:06:24 <benzrf> such that
15:06:27 <benzrf> no wait
15:06:28 <merijn> i.e. "replace needle replacement (x:xs) | x == needle = replacement : replace needle replacement xs"
15:06:30 <benzrf> dropIfEqual :: Eq a => [a] -> [a] -> Maybe [a]
15:06:34 <benzrf> then
15:06:36 <Monorail0> would a simple pattern match work for any length list?
15:06:45 <benzrf> dropIfEqual [1, 2] [1, 2, 3, 4] = Just [3, 4]
15:06:54 <benzrf> Monorail0: once you have that, your other functoin is pretty easy
15:17:47 <huml> Hi. I'm trying to get two lists out of one list with elements alternating, so element with even index get into the first list, elements with odd index into the second
15:19:14 --- mode: ChanServ set +o mauke
15:19:14 --- mode: mauke set +b bagackiz!*@*$##fix_your_connection
15:20:56 * hackagebot Spock 0.7.2.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.2.0 (AlexanderThiemann)
15:21:04 <benzrf> huml: you could just write that recursively
15:21:15 --- mode: mauke set -o mauke
15:21:58 <mauke> > let cleave [] = ([], []); cleave [x] = ([x], []); cleave (x1 : x2 : xs) = let (y1, y2) = cleave xs in (x1 : y1, x2 : y2) in cleave "hello"
15:22:02 <lambdabot>  ("hlo","el")
15:22:07 <mauke> > let cleave [] = ([], []); cleave [x] = ([x], []); cleave (x1 : x2 : xs) = let (y1, y2) = cleave xs in (x1 : y1, x2 : y2) in cleave [0..]
15:22:09 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:22:11 <huml> benzrf: is there no library function that does this task?
15:22:55 <benzrf> not tht i knw of
15:22:56 <huml> mauke: thank you! what is cleave?
15:23:01 <mauke> ...
15:23:08 <benzrf> lol
15:23:12 <mauke> the thing I just defined there?
15:23:18 <mauke> is this a trick question?
15:23:27 <huml> a sorry
15:23:41 <indiagreen> huml: you mean “the meaning of the word”?
15:23:57 <Fuuzetsu> mauke: should have called it ‘f’ like a sensible person
15:24:34 <huml> no, i thought it was some special haskell function. I'm new to Haskell and it's really hard to get these one-liners after reading them twice
15:25:08 <Fuuzetsu> huml: it starts with ‘let’ which would shadow any built-in anyway
15:25:40 * indiagreen has apparently just given up that /me didn't know precisely what “cleave” was before looking it up
15:25:49 <huml> ah, so let is is like the let from Rust :)
15:25:54 <indiagreen> *away
15:26:20 <Fuuzetsu> I don't know about the rules of let in Rust but if anything I would be more inclined to say that their let is like ours ;P
15:27:18 <dmj`> huml: you kind of want an unzipWith
15:28:50 <mauke> > chunksOf 2 "hello"
15:28:54 <lambdabot>  ["he","ll","o"]
15:28:59 <mauke> > transpose (chunksOf 2 "hello")
15:29:02 <lambdabot>  ["hlo","el"]
15:29:07 <dmj`> huml: is your initial list Num a => [(a,a)] or just Num a => [a] ?
15:29:15 <huml> dmj`: hoogle says it (unzipwith) does not exist
15:29:17 <mauke> > transpose (chunksOf 2 [0 ..])
15:29:21 <lambdabot>  [[0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:29:22 <chirpsalot> http://hackage.haskell.org/package/HTTP-4000.0.9/docs/Network-Browser.html <- does the example actually work?
15:29:24 <mauke> nice
15:29:27 <chirpsalot> It doesn't type check for me.
15:29:28 <Fuuzetsu> hm, I clicked on ‘structured types’ on Rust's wiki page and I expected it to take me to ‘Structural typing’ but I was instead taken to ‘struct (C programming language)’. If this isn't bait-and-switch then I don't know what is.
15:29:37 <huml> my initial list is [Integer]
15:29:41 <dmj`> huml: http://lpaste.net/112900, here's a repurposed unzip with a predicate
15:29:57 <dmj`> huml: I'm not sure what your input data looks like tho
15:30:01 <dmj`> oh
15:30:05 <dmj`> then disregard that
15:30:23 <dmj`> actually that simplifies it
15:30:29 <Fuuzetsu> chirpsalot: consider not looking at a version from 2009
15:30:45 <Fuuzetsu> http://hackage.haskell.org/package/HTTP-4000.2.18/docs/Network-Browser.html
15:31:06 <huml> it's a list like [1..5] and i want two lists, one containing the even and one the odd indices
15:31:12 <chirpsalot> Fuuzetsu: oh. Well, dammit Google :P.
15:31:24 <dmj`> > foldr (\a ~(as,bs) -> if even a then (a:as, bs) else (as,b:bs) ([],[]) $ [1..10]
15:31:28 <lambdabot>  <hint>:1:81:
15:31:28 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:31:28 <chirpsalot> Fuuzetsu: thanks :).
15:31:34 <benzrf> dmj`: laaame
15:31:42 <huml> mauke: that's really cool, I'm going to try it
15:32:04 <dmj`> > foldr (\a ~(as,bs) -> if even a then (a:as, bs) else (as,b:bs)) ([],[]) $ [1..10]
15:32:06 <lambdabot>  ([2,4,6,8,10],[b,b,b,b,b])
15:32:17 <Fuuzetsu> >b,b,b,b,b
15:32:22 <dmj`> lool lambdabot
15:32:46 <mauke> dmj`: that doesn't use indices
15:32:58 <benzrf> > [b,b,b,b,b,b,b,b]
15:33:00 <lambdabot>  [b,b,b,b,b,b,b,b]
15:33:05 <benzrf> how uneventful
15:33:09 <Fuuzetsu> what did you expect
15:33:14 <benzrf> that
15:33:24 <Fuuzetsu> what did you hope for to happen instead?
15:34:20 <huml> how is it possible that chunksOf works on Non-Text?
15:34:25 <Fuuzetsu> :t chunksOf
15:34:27 <lambdabot> Int -> [e] -> [[e]]
15:34:55 <mauke> it works on any list
15:34:56 <Fuuzetsu> huml: Data.Text defines its own chunksOf
15:35:04 <huml> well, hoogle sent me to another chunksOf
15:35:05 <Fuuzetsu> which *does* only work on Text
15:35:15 <huml> yeah, I found it
15:36:23 <dmj`> mauke: he just has [Int] tho, where are the indices
15:36:57 <dmj`> mauke: ohhh I misread the problem
15:38:16 <pxqr> > do { start <- getCPUTime; threadDelay 1000000; stop <- getCPUTime; return (start, stop) }
15:38:16 <pxqr> (1644102000000,1644102000000)
15:38:18 <pxqr>  
15:38:19 <lambdabot>  Not in scope: ‘getCPUTime’Not in scope: ‘threadDelay’Not in scope: ‘getCPUTime’
15:38:21 <pxqr> why?
15:38:36 <mauke> maybe sleeping doesn't consume cpu
15:38:46 <Vulume> hi all
15:39:06 <Vulume> i'm doing a thesis on parser combinators so i'll be coming here more often now
15:39:20 <vanila> Vulume, what is your research about?
15:39:34 <Fuuzetsu> You should check out NAD's total parser combinators paper
15:39:50 <Fuuzetsu> (and implementation ;) )
15:40:01 <joelteon> ;)
15:40:18 <huml> mauke: dmj`: I can't use chunksOf? I tried import Data.List.Split (chunksOf)
15:40:36 <Fuuzetsu> Data.List.Split lives in split package
15:40:48 <Vulume> vanila: i'm going to use monad reification (from the Operational package) to transform monadic parsers into applicative parsers (kind of) and allow more direct optimisation/backends
15:40:50 <mauke> huml: what happened?
15:41:13 <vanila> Vulume, sounds fantastic, good luck!
15:41:32 <huml> Not in scope: ‘chunksOf’ when loading my file to ghci
15:41:49 <mauke> that seems unlikely
15:41:50 <Vulume> thanks :) first question for theory people, how often do you guys just jam stuff in ghc and fix it by looking at the errors?
15:41:59 <Vulume> does that still work with the more advanced stuff?
15:42:16 <joelteon> if i didn't have compiler errors i'd never use haskell
15:42:34 <Fuuzetsu> how good the errors are mostly depends on what stuff you jam in
15:43:19 <Vulume> i've noticed them becoming way less helpful for figuring out my type families :p
15:43:33 <huml> how can i import the split package?
15:43:46 <joelteon> you don't import packages, you just have them in scope
15:43:49 <mauke> huml: show your whole code and the error message
15:43:58 <dmj`> mauke: ok got it
15:44:02 <dmj`> mauke: http://lpaste.net/112901
15:44:39 <dmj`> huml: is this what you want? http://lpaste.net/112901
15:45:03 <mauke> > transpose (chunksOf 3 "ok, now do this")
15:45:06 <lambdabot>  ["o woh","kn  i",",odts"]
15:45:16 <huml> Prelude> :l test.hs                                                               [1 of 1] Compiling test       ( test, interpreted )                                                                                                                       test.hs:38:21: Not in scope: ‘transpose’                                                                                                                                  test.hs:38:32:
15:45:34 <dmj`> huml: import Data.List
15:45:59 * hackagebot linkedhashmap 0.3.0.0 - Persistent LinkedHashMap data structure  http://hackage.haskell.org/package/linkedhashmap-0.3.0.0 (abasko)
15:46:31 <huml> after importing Data.List, transpose is found, but the same error with chunksOf
15:47:52 <mauke> huml: show your whole code and the error message
15:48:06 <huml> I'm sorry, I'm feeling really stupid right now. I'm really new to haskell and I have no idea on how package are structured and what to import to get a certain function
15:48:37 <MP2E> everyone feels disoriented at first, it will pass with practice :)
15:48:56 <mauke> could you just stop feeling stupid and show me your code?
15:49:45 <huml> testF :: [Integer] -> [[Integer]]                                                 testF xs = transpose (chunksOf 2 xs)                                                                                                                                Prelude> :l test.hs                                                               [1 of 1] Compiling test       ( test.hs, interpreted )
15:49:50 <dmj`> mauke: loool
15:49:59 <mauke> no, your whole code
15:50:02 <mauke> the entire file
15:50:05 <dmj`> huml: you can put your code on lpaste.net
15:50:09 <dmj`> huml: don't paste it in IRC
15:50:09 <vanila> huml, you could write it with recursion
15:50:19 <vanila> alt (x : y : zs) = (x, y) : alt zs
15:50:35 <vanila> then you  have a list [(a,a)] which you can turn into ([a],[a]) which you wanted
15:50:56 <huml> http://lpaste.net/112902
15:50:59 * hackagebot Spock-worker 0.2.1.0 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.2.1.0 (AlexanderThiemann)
15:51:00 <dmj`> vanila++
15:51:02 <vanila> there's a slight problem to do with odd length lists but it's a start
15:51:33 <huml> the other code stuff is from other tasks. I'm doing some exercises from our chair at college and there are more exercises
15:51:35 <dfeuer_> Ha, I think I win—incoherent instances plus GADTs already make behavior depend on inlining, so there's no reason to worry about that.
15:51:59 <mauke> huml: that's not the whole code
15:52:01 * mauke gives up
15:52:54 <volty> according to hoogle chunksOf is defined only in Data.Text (and lazy)
15:53:09 <dmj`> vanila: what if there is an odd # of elements tho
15:53:17 <merijn> volty: Hoogle doesn't index all of hackage
15:53:31 <vanila> you'll lose one in that case
15:53:35 <huml> mauke: I can write it to a new file, too. This function does not interact with the other functions. It's just one exercise out of a lot and each exercise is writing a function that does one specific thing
15:53:58 <volty> me to cannot access it after importing Data.List
15:54:00 <Clint> volty: search for chunksOf +split
15:54:18 <mauke> huml: I asked you four times
15:55:46 <merijn> huml: Your paste does not include imports and the line numbers in the error don't match your code
15:57:42 <volty> ya,though was easier to specify that has to import Data.List.Split
15:59:51 <volty> btw, why doesn't hoogle index Data.List.Split ?
15:59:57 <dmj`> :t \xs -> foldr (\a ~(as,bs) -> if even (fst a) then (snd a:as, bs) else (as,snd a:bs)) ([],[]) $ zip [1..] xs
15:59:58 <lambdabot> [a] -> ([a], [a])
16:00:11 <Clint> volty: it does, but you have to put +split in the query
16:00:14 <dmj`> (foldr (\a ~(as,bs) -> if even (fst a) then (snd a:as, bs) else (as,snd a:bs)) ([],[]) $ zip [1..] xs) $ ['a'..'z']
16:00:21 <dmj`> > (foldr (\a ~(as,bs) -> if even (fst a) then (snd a:as, bs) else (as,snd a:bs)) ([],[]) $ zip [1..] xs) $ ['a'..'z']
16:00:23 <lambdabot>  Not in scope: ‘xs’
16:00:23 <lambdabot>  Perhaps you meant one of these:
16:00:23 <lambdabot>    ‘x’ (imported from Debug.SimpleReflect),
16:00:23 <lambdabot>    ‘s’ (imported from Debug.SimpleReflect)
16:00:23 <chirpsalot> Hmmm. No way to make Network.Browser do HTTPS is there?
16:00:59 <Fuuzetsu> not AFAIK
16:00:59 <volty> Clint:  I meant why doesn't expose it without specifying 'split' ?
16:01:01 * hackagebot HandsomeSoup 0.3.4 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3.4 (AdityaBhargava)
16:01:02 <merijn> volty: Hoogle only indexes the core libraries
16:01:13 <Fuuzetsu> merijn: when did lens become a core library
16:01:18 <dmj`> > foldr (\a ~(as,bs) -> if even (fst a) then (snd a:as, bs) else (as,snd a:bs)) ([],[]) $ zip [1..] ['a'..'z']
16:01:20 <lambdabot>  ("bdfhjlnprtvxz","acegikmoqsuwy")
16:01:25 <dmj`> huml: ^
16:01:29 <chirpsalot> Fuuzetsu: ah, I guess it's technically Network.HTTP that's the issue. Still, that's a shame.
16:01:32 <merijn> Fuuzetsu: It doesn't index lens...
16:01:40 <volty> merijn: i hope there is an option to tell it to index everything when locally installed
16:01:46 <merijn> Fuuzetsu: Try searching for (.~) on hoogle...
16:01:58 <merijn> volty: Yes, you can create custom database with local hoogle
16:01:58 <Fuuzetsu> merijn: http://www.haskell.org/hoogle/?hoogle=.~%20%2Blens
16:02:02 <Fuuzetsu> what's the problem?
16:02:16 <merijn> Fuuzetsu: If you explicitly add the package, sure
16:02:28 <merijn> Fuuzetsu: I meant when hoogling without package annotation
16:02:29 <Fuuzetsu> It indexes it. It doesn't show it by default.
16:02:44 <Fuuzetsu> Well, that's different, and Clint said to add +split
16:02:57 <merijn> volty: Additionally, fpcomplete has a hoogle install that indexes all of their libraries, which includes all of the platform, afaik
16:03:42 <huml> dmj`: sorry, was afk (got called)
16:04:02 <Fuuzetsu> merijn: in fact, the Hoogle README says all of Hackage is available
16:04:45 <dmj`> huml: no prob
16:05:44 <huml> I moved it to a new file to try it. That's the whole file (3 lines) and the try to load it to ghci
16:05:55 <volty> sorry, but for me is difficult to not answer those pedant peelers («yes, but it is indexed ...» peel the language, pure ...)
16:05:57 <huml> http://lpaste.net/112903
16:06:18 <merijn> huml: You're not import Split...
16:07:11 <huml> what's the name of the package? Data.List.Split?
16:07:20 <Fuuzetsu> that's the name of the module
16:07:40 <merijn> huml: You don't import packages, you import modules, you need both Data.List and Data.List.Split
16:08:17 <dmj`> huml: you don't need packages, just use this function: http://lpaste.net/112907
16:08:18 <Fuuzetsu> -XPackageImports
16:08:20 * Fuuzetsu hides
16:08:34 <huml> well, trying `import Data.List.split` in line two gives Could not find module ‘Data.List.Split’
16:08:57 <huml> dmj`: Cool, thank you!
16:09:42 <huml> sry, import Data.List.Split does not work
16:09:50 <mauke> <huml> mauke: dmj`: I can't use chunksOf? I tried import Data.List.Split (chunksOf)
16:09:56 <mauke> so what was that about?
16:11:01 <huml> I tried importing it but I don't know how. I used to import other things in exercises before like that
16:11:55 <mauke> yes, but you said that you did "import Data.List.Split (chunksOf)" and that the error message said that chunksOf was "not in scope"
16:12:35 <huml> no, it's not in scope without that import. with that import - well the import does not work
16:12:49 <mauke> "does not work" is not a problem description
16:12:59 <mauke> and you said the "not in scope" error was with the import
16:13:19 <dmj`> > unzip $ map (\(x:y:_) -> (x,y)) $ chunksOf 2 ['a'..'z']
16:13:20 <lambdabot>  ("acegikmoqsuwy","bdfhjlnprtvxz")
16:13:27 <huml> I'm sorry. http://lpaste.net/112908
16:13:31 <dmj`> the problem is that you lose an element
16:13:37 <dmj`> with chunksOf
16:14:04 <volty> without quotes (') @ huml
16:14:30 <volty> past the line where you are importing it
16:14:36 <volty> paste
16:14:45 <huml> import Data.List.Split (chunksOf)
16:15:45 <huml> the whole source
16:15:46 <huml> http://lpaste.net/112909
16:17:56 <volty> tell us about your system (os), version etc
16:18:11 <mauke> volty: ?
16:18:16 <huml> arch linux on 64bit quad core amd fx
16:18:37 <huml> haskell from the arch linux repositories
16:18:42 <dmj`> data.list.split isn't compatible with quad cores
16:18:48 <mauke> what
16:18:49 <dmj`> :)
16:18:53 <merijn> dmj`: Don't be funny
16:19:41 <huml> ghc --version The Glorious Glasgow Haskell Compilation System, version 7.8.3
16:19:50 <volty> troll
16:19:53 <merijn> huml: Do you have the split package installed?
16:19:58 <Fuuzetsu> why didn't anyone just ask him to ghc-pkg list?
16:20:25 <mauke> merijn: no
16:20:30 <merijn> Fuuzetsu: Because he kept lying about the error message?
16:20:36 <huml> http://lpaste.net/112910
16:20:45 <Fuuzetsu> yep, no split
16:21:43 <huml> is it possible to get it with cabal?
16:21:47 <dmj`> huml: mkdir test && cd test && cabal sandbox init && cabal install split && cabal exec ghci, then import Data.List.Split
16:22:26 <jle`> cabal exec ghci? why not cabal rpl?
16:22:29 <jle`> *cabal repl
16:22:32 <dmj`> jle`: that works too
16:22:49 <dmj`> cabal exec ghci changes your package db to that of the sandbox
16:22:50 <dfeuer_> Is there a way to name modules for cabal repl?
16:22:57 <dmj`> jle`: he doen't have a cabal tho
16:23:03 <jle`> ah i see
16:23:04 <dmj`> cabal file*
16:23:08 <jle`> jumped in at the wrong time
16:23:10 <jle`> :)
16:23:15 <huml> do i need the sandbox?
16:23:27 <dmj`> huml: no, but it's recommended
16:23:33 <volty> isn't there a haskell-platform ?
16:23:33 <huml> ah ok
16:24:15 <huml> volty: no, not in the arch repositories
16:24:32 <volty> talk to others, dear, I have a very good nose ...
16:24:33 <huml> well, the import works
16:25:31 <huml> thanks to all of you, I must really have annoyed you
16:25:38 <huml> I'm sorry for that
16:25:54 <dmj`> huml: now put your file in that directory, add a cabal file and cabal build it, or just cabal exec zsh, and ghc Main.hs -o main
16:26:11 <dfeuer_> huml: sandboxes are a pain, but not as horrible a pain as not-sandboxes.
16:26:14 <dfeuer_> Sadly.
16:30:29 <Fuuzetsu> nix-shell --pure -p haskellPackages.split -p haskellPackages.ghc --command ghci
16:30:29 <Fuuzetsu> ;)
16:45:04 <t4nk598> :l
16:45:26 <t4nk598> hi yall
16:45:35 <t4nk598> hows it going?
16:46:28 <Fuuzetsu> what a suspicious-looking nickname
16:46:34 <volty> going dirty trying to preserve the purity
16:47:10 <volty> and the questions are even more suspicious  :)
16:47:50 <t4nk598> me?
16:48:18 <volty> how are you going?
16:49:22 <t4nk598> alright
16:49:32 <t4nk598> just wondering something
16:49:35 <t4nk598> thought id come here and ask it
16:49:51 <Fuuzetsu> ask away
16:50:00 <chirpsalot> Fuuzetsu: ah, for future references it looks like there's Network.HTTP.Conduit.Browser, and it handles HTTPS.
16:50:22 <t4nk598> why isn't there a way of turning some arbitrary element into a list functionally?
16:50:41 <t4nk598> like something of this nature :
16:51:08 <t4nk598> toList :: m -> [m]
16:51:12 <t4nk598> toList m = [m]
16:51:22 <jle`> what do you mean by "functionally"?
16:51:27 <jle`> that looks like a function to me
16:51:29 <merijn> t4nk598: That exists
16:51:31 <FireFly> @ty (: [])
16:51:31 <lambdabot> a -> [a]
16:51:43 <merijn> t4nk598: In fact, there's at least 3 functions that do that
16:51:51 <merijn> :t pure :: a -> [a]
16:51:53 <lambdabot> a -> [a]
16:51:58 <merijn> :t return :: a -> [a]
16:51:59 <lambdabot> a -> [a]
16:52:05 <merijn> And FireFly's
16:52:06 <Fuuzetsu> chirpsalot: apparently I even used it in the past
16:52:26 <FireFly> A better question might be why there's three of 'em :P
16:52:30 <chirpsalot> Fuuzetsu: unfortunately it looks like it hasn't been updated in a long time.
16:52:36 <t4nk598> lol
16:52:56 <merijn> FireFly: Well, (:[]) and pure at least you need both
16:53:05 <FireFly> Yeah
16:53:07 <merijn> And pure and return exist because pure was invented after return
16:53:09 <Fuuzetsu> chirpsalot: oh, oops, I was looking at Network.HTTP.Conduit
16:53:11 <Fuuzetsu> not the .Browser part
16:53:42 <jle`> i think i try to avoid using pure/return unless i am in an applicative/monadic context
16:53:46 <Fuuzetsu> http://hackage.haskell.org/package/http-conduit-2.1.4.5/docs/Network-HTTP-Client-Conduit.html might work for you
16:53:47 <FireFly> Is it legal to have a monad where return != pure?
16:53:52 <chirpsalot> Ah. I think I don't need the .Browser stuff, because I just need to make some HTTP requests, and don't need to keep track of cookies? Fingers crossed.
16:54:03 <Fuuzetsu> FireFly: No, I will personally come to your house and delete your code.
16:54:17 <t4nk598> is that Control.Applicative.pure
16:54:22 <Fuuzetsu> yes
16:54:23 <FireFly> Yep
16:54:29 <FireFly> And Control.Monad.return
16:54:44 <t4nk598> im in a monadic context
16:54:56 <Fuuzetsu> it would not matter even if you weren't
16:55:17 <t4nk598> yeah i see it still does the job
16:55:30 <dfeuer_> Could someone explain the Foldable instance for Const m?
16:55:36 <Fuuzetsu> for your purposes, it has the type a -> [a] like you wanted
16:55:37 <t4nk598> thanks!!!
16:55:39 <merijn> FireFly: It's possible a type has valid applicative and monad instances whose pure and return don't match
16:56:00 <merijn> FireFly: For programmer sanity reasons having an Applicative and Monad that don't match is not welcome, though
16:56:00 <t4nk598> i'll keep an eye out for that then
16:56:14 <FireFly> I was more curious about the former
16:56:54 <jle`> another possible Applicative instance for lists is the "zip list"
16:56:58 <jle`> where liftA2 = zipWith
16:56:59 <FireFly> Good to know, I guess it isn't a historical accident then that both exist (return and pure, I mean)
16:57:13 <jle`> for that instance, pure = repeat
16:57:23 <merijn> FireFly: All return's of lawful monad instances MUST be identical to the pure of the corresponding applicative
16:57:54 <merijn> FireFly: If Applicative was a superclass of Monad (as it will be soon) then we could delete the definition of "return" from monad and define "return = pure"
16:58:02 <Fuuzetsu> Soon™
16:58:07 <FireFly> All right, neat
16:58:18 <jle`> what does "corresponding applicative" even mean if not exactly that?
16:58:25 <merijn> FireFly: (We won't, for backwards compatibility, reasons)
16:58:29 <jle`> and ap = (<*>)
16:58:47 <FireFly> merijn: couldn't it be defined as a default implementation of `return`?
16:58:48 <Fuuzetsu> merijn: for what backwards compatibility reasons? Nothing would break
16:59:00 <Fuuzetsu> if you have a custom return then it stays that way
16:59:24 <merijn> FireFly, Fuuzetsu: You're skipping the first half of my sentence
16:59:35 <merijn> "we could delete the definition of "return" from Monad"
16:59:39 <FireFly> The "if" that is more a "when"?
16:59:43 <FireFly> Oh
16:59:50 <FireFly> Well, fair
17:00:15 <merijn> pure as default definition for Monad is perfectly sensible, yes
17:01:03 <Fuuzetsu> right
17:01:12 <Fuuzetsu> isn't return = pure happening?
17:01:18 <Fuuzetsu> pretty sure I saw that in a diff but I might be wrong
17:01:26 <merijn> Don't remember
17:04:42 <pharaun> i could've swore there is a way to automatically populate your cabal file with build-dependencies and trial-build several?
17:04:54 <pharaun> cos i have several projects with no fixed dependencies and I would like to fix that up
17:06:42 <joelteon> so return doesn't even need to exist anymore
17:07:10 <jle`> as much as mconcat needs to exist
17:07:19 <joelteon> i don't know that i've ever used mconcat
17:07:38 <benzrf> fun fact:
17:07:42 <geekosaur> cabal-bounds?
17:07:45 <joelteon> wow that is fun
17:07:52 <pharaun> geekosaur: perfect, couldn't find/recall the name thanks
17:07:57 * geekosaur uses mconcat somewhat regularly... just not under that name
17:07:59 <pharaun> sounds like what i wanted
17:08:02 <benzrf> given a monoid homomorphism f :: [A] -> B, there exists a g such that f = foldMap g
17:08:06 <geekosaur> (composeAll)
17:08:25 <pharaun> geekosaur: yeah this is what i wanted, thanks
17:08:59 <monochrom> @type foldMap
17:09:00 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
17:09:38 <monochrom> I guess that's part of "[A] is a free monoid"
17:10:22 <Fuuzetsu> is there any material on what a ‘pseudo-monad’ might constitute that's a little closer to what I might be looking for than http://en.wikipedia.org/wiki/Pseudomonadaceae
17:10:29 <athan> geekosaur: Where is that under? Data.Monoid doesn't have it, it looks like
17:10:39 <Fuuzetsu> 2-monad?
17:10:46 <jle`> Data.Foldable
17:11:19 <benzrf> monochrom: singletons are a generating set of a sequence monoid and homomorphisms are uniquely determined by their operation on generating sets
17:11:33 <benzrf> and an operation on singletons is really an operation on the underlying set
17:11:38 <Fuuzetsu> oh, nLab has something, nevermind
17:11:53 <geekosaur> athan, you mean composeAll? http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html#v:composeAll
17:12:42 <athan> geekosaur: Yep! Thank you :)
17:13:34 <sbrg> athan: it's just mconcat fyi
17:14:25 <geekosaur> sbrg, that was the *point*
17:14:28 <geekosaur> someone asked who ever uses mconcat...
17:15:18 <sbrg> geekosaur: oh, my bad. didn't read context.
17:15:23 * sbrg goes back into his corner
17:19:36 <jle`> oh my comment was in reference to why mconcat was a part of the Monoid typeclass
17:19:46 <jle`> and saying that `return` will one day be relegated to the same sort of thing
17:21:10 * hackagebot charsetdetect-ae 1.0.1 - Character set detection using Mozilla's Universal Character Set Detector  http://hackage.haskell.org/package/charsetdetect-ae-1.0.1 (ArtyomKazak)
17:45:52 <ezrios> I want to use a `forAll` with two Gens
17:46:02 <ezrios> actually let me post a snippet
17:46:42 <ezrios> http://lpaste.net/112913
17:46:59 <ezrios> I want to formulate a property that holds for all chars and ints in a certain range
17:47:22 <ezrios> however I get the typecheck error: Couldn't match expected type `Gen (Rank, File)' with actual type `(Gen Rank, Gen File)'
17:47:35 <ezrios> is what I'm asking for even possible?
18:01:54 <trap_exit> erlang has this philosophy of fail/die fast, and let another process restart -- in haskell, what is the right way of handing runtime errors that the type system can not catch? should I (1) throw exceptions or (2) have all such functions return "Either String a" instead of just "a" ?
18:02:28 <f-a> (just in case, more ascii-based-haskell-puns http://www.ariis.it/static/stream/page.html#love-you-give )
18:03:12 <athan> trap_exit: Generally, Maybe's & Eithers are cleaner ways of handling runtime insufficiencies in a prepared manner. However, I have seen some interesting things involving "Exceptions" (that I'm not really educated with :/)
18:03:57 <athan> But, it's always a good exercise to try and bring all capacity for possabilities in the type level :)
18:06:21 <Cale> trap_exit: If you're not writing IO actions and you think anyone will ever possibly want to handle the exceptional case, use Maybe/Either.
18:06:42 <trap_exit_> oh since if I throw an exception
18:06:46 <trap_exit_> it can only be captured in an IO ?
18:07:09 <Cale> trap_exit: Exceptions which are thrown by "error" during evaluation not only can only be caught in IO, but are quite fiddly to actually catch
18:07:46 <trap_exit_> this is very counterintuitive
18:07:50 <Cale> Because you have to ensure that the evaluation which causes the exception actually happens inside the execution of the catch, and isn't just returned as part of an unevaluated expression.
18:07:59 <trap_exit_> in erlang, I want errors to have quick death
18:08:12 <trap_exit_> in clojure + c + c++, I just want exceptions/segfaults so I can fire up the debugger
18:08:21 <trap_exit_> yet in Haskell, I want the func to also do error handling and say "look, we got this error because ... "
18:08:32 <Cale> So, the practical upshot of that is that you only use "error" to mean "if this happens the entire program is fundamentally hosed, I just want everything to die"
18:09:44 <trap_exit_> which should not happen in pure functions
18:09:51 <trap_exit_> since pure functions should just be like "dude, I can't fucking compute that, the inputs don't make sense"
18:10:01 <Cale> Well, it can happen
18:10:03 <trap_exit_> when should a pure function ever use error ?
18:10:21 <Cale> There are cases where you know that the error won't happen
18:10:33 <Cale> > map head . group . sort $ "mississippi"
18:10:36 <lambdabot>  "imps"
18:10:40 <geekosaur> what do you do when you ask for the square root of a negative number and you're not working in Complex Double?
18:10:43 <MP2E> imps!
18:10:48 <geekosaur> that is a pure computation
18:10:50 <Cale> head technically uses error:
18:10:52 <Cale> > head []
18:10:54 <lambdabot>  *Exception: Prelude.head: empty list
18:10:56 <trap_exit_> you return Either String Int
18:10:57 <trap_exit_> instead of returning Int
18:11:09 <Cale> But here, group is guaranteed only to produce nonempty groups
18:11:18 <Cale> So we only apply head to nonempty lists
18:11:39 <trap_exit_> head []
18:11:42 <trap_exit_> :t head
18:11:44 <lambdabot> [a] -> a
18:11:48 <trap_exit_> why is head not [a] -> Either String a ?
18:11:48 <Cale> It could be argued that group's type should be different
18:12:03 <trap_exit_> why is it okay that head throws an exception?
18:12:09 <centrinia> @djinn [a] -> Maybe a
18:12:10 <lambdabot> Error: Undefined type []
18:12:12 <Cale> Because occasionally you *really* just want the head of the list, and you know for sure it's not empty
18:12:32 <darkbolt_> Im fairly new to haskell...can someone tell me if i'm a crazy person or not for thinking about using just wai/warp instead of scotty/yesod/snap/etc?
18:12:47 <Cale> darkbolt_: I don't think it's crazy
18:13:01 <trap_exit_> darkbolt_ : the haskell web libraries have different philosophies; use the one taht you like the most
18:13:13 <Cale> darkbolt_: The web application frameworks are all pretty modular, you can even mix and match them to a fair extent
18:13:22 <trap_exit_> if you like insane-DSL template haskell, go with yesod; otherwise, don't use yesod
18:13:29 <Cale> They're just bunches of libraries.
18:13:51 <trap_exit_> hmm, I think I'mn gong to stick wth functions calling error
18:13:56 <trap_exit_> rather than dealing with "Either String _" stuff
18:14:07 <Cale> trap_exit_: Yeah, it depends on how confident you are
18:14:13 <Cale> that the exceptional case can't happen
18:14:19 <athan> trap_exit: That's what I do for "impossible" cases :)
18:14:24 <Cale> Or that if it does happen, that it's okay for the whole program to die
18:14:24 <trap_exit_> well, when the exceptional case happens
18:14:27 <trap_exit_> its the programmers fault
18:14:29 <darkbolt_> from everything that ive gathered so far, I really kind of just want a thin routing layer on wai
18:14:37 <nshepperd> partial functions are frequently more convenient to use
18:14:41 <trap_exit_> error handling clutters the world
18:14:52 <Cale> Maybe is pretty lightweight
18:14:53 <nshepperd> which is why there's Map.! as well as Map.lookup
18:14:53 <athan> darkbolt_: Scotty?
18:15:17 <Cale> :t lookup
18:15:19 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:16:10 <Cale> > let dict = [(1,2),(2,3)] in do x <- lookup 1 dict; y <- lookup x dict; return (x,y)
18:16:12 <lambdabot>  Just (2,3)
18:16:22 <Cale> > let dict = [(1,2),(2,3)] in do x <- lookup 1 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
18:16:24 <lambdabot>  Nothing
18:16:45 <Cale> The fact that Maybe happens to be a monad can be put to use if you have a lot of operations which might fail.
18:17:10 <trap_exit_> yeah
18:18:29 <Cale> Also, using Maybe gives the programmer the option of ignoring the error -- they can just pattern match against the Just constructor and fail to handle the other case if they really want to
18:18:56 <Cale> But if you think they're really unlikely to want to handle the failure, you can just call error and leave it at that
18:20:14 <trap_exit> the answer to this is likely no
18:20:16 <trap_exit> but perhaps possible with a hack
18:20:20 <trap_exit> since haskell in lazy
18:20:36 <trap_exit> in haskell, when I use error, is there a way to get info on the "encapsulating thunks when this thunk was created" >
18:20:37 <Cale> hm?
18:20:46 <trap_exit> it's about as close to a stack frame as I can think of
18:20:48 <trap_exit> laziness ==> stack frames make no sense
18:20:49 <Cale> uh
18:20:52 <Cale> Right
18:20:55 <Cale> There's no call stack
18:21:10 <trap_exit> does my question make sense? or amn I being retarded to ask for "encapsulating thunks of when this tubnk was created"
18:21:12 <Cale> If you have profiling turned on, there's a cost-centre stack
18:21:42 <Cale> But normally the cost of keeping track of that information is deemed too harmful to performance
18:22:20 <nshepperd> isn't ghc 7.10 supposed to have some kind of stack included in errors by default
18:22:28 <Cale> I hadn't heard that
18:22:33 <nshepperd> or was it line numbers
18:23:43 <Cale> I suppose it might be possible for GHC to just show you some sort of information about its actual stack, but that stack consists of pattern matches
18:23:50 <Cale> (more or less)
18:24:13 <Cale> Actually, I'd really like to be able to have that sometimes
18:24:41 <luite> GHC 7.10 will have that info
18:25:23 <Cale> Just tell me the line/column numbers for the case expressions (or function applications, in the case that the thing which is going on the stack is the evaluation of the function in an application), and let me sort out what's going on :)
18:25:53 <nshepperd> anything is better than "**head: empty list" with no further information :)
18:27:21 <luite> Cale: yeah that has been added, it'll output DWARF information for that. I'm pretty happy with this since it means now keeps line number info around, from which i can generate source maps with GHCJS :)
18:27:28 <Cale> Sorry, should have said the thing which is causing a stack entry is the evaluation of a function in an application, it's the application itself which goes on the stack in that case :)
18:28:18 <Cale> luite: pretty cool
18:29:37 <Cale> I think for far too long, people underestimated the usefulness to programmers of seeing the real lazy evaluator's stack, and all the debugging tools have been too focused on trying to create fake call stacks as they would be if the program were being strictly evaluated.
18:30:44 <Cale> When this is an easy-ish thing that we probably could have done a long time ago
18:31:11 <Cale> But somehow people thought it would be confusing and un-useful
18:31:20 * hackagebot pure-zlib 0.3 - A Haskell-only implementation of zlib / DEFLATE  http://hackage.haskell.org/package/pure-zlib-0.3 (AdamWick)
18:32:12 <dfeuer> Cale!
18:32:41 <Cale> hi
18:33:12 <luite> I agree that it's something that would help a lot when debugging, and for CPU profiling where cost centres affect performance of the programs too much, but cost centre stacks are probably much more useful for heap profiling
18:35:34 <Cale> One thing I've experienced with the new "more accurate" cost centre stacks is that in large programs, it can make your .prof files so large and spread out that they're nearly useless
18:35:52 <Cale> (though this is really a tangential issue)
18:36:17 <luite> hmm, that can perhaps be solved with a better user interface for sorting and grouping
18:36:20 <Cale> -rw-r--r-- 1 cale cale 18004261 Dec  9  2011 pcGame.prof
18:37:00 <dfeuer>  Cale, do you understand how GHC's specializer works? Because it looks completely opaque to me.
18:37:12 <dfeuer> 18 MEGABYTES?
18:37:16 <dfeuer> o.O
18:37:16 <Cale> dfeuer: Keep in mind that I've never actually worked on GHC's code
18:37:24 <Cale> Yes, 18 megabytes
18:37:41 <dfeuer> That's okay, Cale. You're one of those smart people who can understand things and explain them.
18:37:56 <Cale> Are you talking about constructor specialisation?
18:38:14 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
18:43:56 <merijn> It's too bad vtune probably doesn't work with haskell binaries in a useful way
18:50:12 <f-a> mh, say I write a partial function (like, head), is there a way to "catch" the possible error somewhere without having the program halt?
18:50:20 <f-a> (yeah I know, partial functions)
18:51:13 <luite> merijn: have you tried it? it should support the DWARF metadata from GHC HEAD on linux
18:51:25 <Cale> f-a: There is, but it's extremely awkward to the point that the correct thing is really to go back and not use head.
18:51:50 <Cale> f-a: Or otherwise revise the function to not be partial.
18:52:08 <Cale> f-a: If you really must, you can use Control.Exception.catch and Control.Exception.evaluate
18:52:21 <Cale> and catch the exception in an IO action'
18:52:25 <f-a> thankee Cale
18:52:25 <Cale> :t evaluate
18:52:27 <lambdabot> a -> IO a
18:53:34 <Cale> But note that you have to be very careful if the exception happens in the evaluation of an element of some larger data structure that the evaluation of the error actually occurs inside the catch, and isn't just returned unevaluated as part of the result
18:53:59 <Fuuzetsu> TL note: don't catch it, use a total function or assure safety otherwise
18:54:22 * athan withholds vomit
18:54:27 <athan> man, that's gross
18:54:50 <aisatsana> Hi, so I have a question regarding a function in http://pastebin.com/q8YSVsuJ more specifically num which is supposed to return an "Expr" containing a "Num" when given a string so, num "12" should be Just (Num 12, "") but currently returns Just (12, ""). Any ideas why, as I can't really see it
18:54:57 <Cale> What in particular? Trying to catch exceptions thrown from evaluation of expressions? Yeah, it's kind of ugly.
18:55:49 <Cale> http://lpaste.net/112917 -- saner syntax colouring
18:56:05 <merijn> aisatsana: I recommend changing Parser to "String -> Maybe a" and using fmap
18:56:30 <nshepperd> unsafePerformIO . catch (...) . evaluate . force $ badExpression
18:56:36 <nshepperd> beautiful
18:56:53 <Cale> Heh, you probably shouldn't unsafePerformIO either
18:57:33 <Cale> I guess in many cases it would be vaguely okay
18:58:18 <aisatsana> merijn: Can't change parser since I will be needing the rest of the string in order to form a full expression for example "12+12" should be parsed to and Expr containing (Add (Num 12) (Num 12))
18:58:47 <aisatsana> Or maybe not, so tired haha starting to make a lot of errors :)
18:58:57 <Cale> aisatsana: It does return that, it's just your Show instance for Expr is a bit screwy, and doesn't display the Num data constructor.
18:59:30 <Cale> aisatsana: If you add Show to the list of derived classes instead, you'll see a correct representation of what's being produced
19:00:43 <aisatsana> Cale: it's a school assignment where we've been prompted to specifically use our own instance of show for aesthetic reasons :/
19:00:59 <Cale> aisatsana: Well, you can always change it back :)
19:01:24 <Cale> Usually the best idea in practice is to keep the Show instances producing valid Haskell code for the data structures
19:01:39 <Cale> That tends to be the most useful thing when debugging
19:02:11 <Cale> (and use other functions if you want to convert the data structures into Strings in some other way)
19:02:17 <aisatsana> Ok :) Ha, haskell is such a mindfuck for someone who's been doing C++ pretty much exclusively in the past, but man is it a cool language
19:02:51 <dfeuer> Cale, that's a different sort of specialization. I'm talking about specializing to typeclass instances, not specializing constructor stuff.
19:02:58 <jle`> f-a: there's the `spoon` library
19:03:07 <Cale> Your spacing is pretty weird, are there tabs in your source file which pastebin expanded to spaces?
19:03:13 <f-a> quite an interesting name jle` , I will check that out
19:03:41 <aisatsana> Cale: me?
19:03:46 <Cale> aisatsana: yeah
19:04:05 <dmj`> jle`: hey I got an idea
19:04:12 <Cale> aisatsana: You generally want to make sure that your editor converts tabs to spaces, or you'll eventually run into confusing problems
19:04:14 <dfeuer> Cale, thankfully, it looks like -fwarn-tabs will be the default in 7.10. :-)
19:04:21 <Cale> dfeuer: Excellent
19:04:34 <Cale> dfeuer: Hopefully 7.12 can just make them be a lexical error
19:04:39 <dfeuer> Heh.
19:04:40 <aisatsana> Yeah been forced to use my mac since my archlinux distro isn't too keen on installing packages for haskell. Not used to textwrangler and it's messing with my spaces can't seem to get thing alligned
19:04:57 <jle`> dmj`: yeah?
19:05:16 <dmj`> jle`: parse bindings - https://parse.com/docs/rest#general
19:05:23 <jle`> Cale: doesn't one of the simons insist on tabs?
19:05:24 <Hijiri> trouble installing cabal on arch?
19:05:33 <Cale> jle`: no
19:05:34 <Hijiri> because usually you can just install all the packages from hackage
19:05:42 <jle`> who was it...
19:05:43 <Hijiri> through cabal, I mean
19:06:21 <jle`> dmj`: sounds useful :)
19:06:40 <aisatsana> Hijiri: Don't remember it was about a month ago I messed about with it. But there was some major problems with it from what I remember since I was under time constraints I stuck with the mac
19:06:43 <Cale> jle`: Maybe at some point they were using tabs. I seem to recall some old GHC code which contained very inconsistent horrible mixed tabs and spaces that just happened to work out.
19:06:48 <dfeuer> jle`, it would've made sense for the warning to only kick in when a file used both spaces and tabs, and used them both in a way affecting layout, but that would be complicated.
19:07:00 <Cale> jle`: But I think people have generally figured out that's a bad idea :P
19:07:24 <Cale> (with a handful of exceptions)
19:07:32 <dfeuer> Cale, I've even seen code using tabs *mid-line*
19:07:38 <aisatsana> Hijiri: Thinking of going gentoo since arch just doesn't seem to be worth all the trouble, haha
19:08:25 <dfeuer> <tab><tab>blah blah blah<tab>blah    WTF?
19:08:37 <Cale> dfeuer: I prefer this way. Just make the tab people stop. :)
19:08:42 <merijn> OSX ships with both vim and emacs ;)
19:09:05 <jle`> some people use tabs for layouting (indenting nested blocks), and then spaces ever after that
19:09:11 <jle`> for alignment and stuff
19:09:28 <Cale> aisatsana: Usually what I do to install GHC, regardless of my distribution, is to grab the generic linux binary package from the GHC website
19:09:31 <merijn> Cale: Not anymore, GHC has turned on warning for tabs as the source is now tab free :)
19:09:57 <dfeuer> merijn, do *you* understand the specializer?
19:10:05 <Fuuzetsu> merijn: and then it suppressed it straight away because the core libs still have tabs ;P
19:10:12 <Cale> aisatsana: i.e. from here: http://www.haskell.org/ghc/download_ghc_7_8_3#x86linux
19:10:18 <aisatsana> merijn: Such a mac noob to be honest and I'm an emacs man and when I looked around for it I only seemed to get it working in the terminal, and I really don't like code in a terminal window.
19:10:28 <dfeuer> Fuuzetsu, it's suppressed in the core libs for validation, but user code gets it.
19:10:35 <Cale> aisatsana: and then I go here: http://hackage.haskell.org/package/cabal-install
19:10:39 <Fuuzetsu> yeah
19:10:45 <Cale> and download the tarball for cabal-install
19:11:00 <Fuuzetsu> aisatsana: if you're hopping distros, you might want to give NixOS a go
19:11:10 <Cale> inside that, there's a bootstrap.sh which will make you a cabal binary that you can use to install other packages as necessary
19:11:11 <merijn> dfeuer: I don't understand anything!
19:11:30 <dfeuer> merijn, I should've asked that differently. Can you help me understand the specializer?
19:11:51 <merijn> aisatsana: Ah, yeah, you need to install your own emacs if you want something GUI-ish
19:12:22 <merijn> dfeuer: eh, my knowledge of the specializers extends to "it specialises things"
19:12:22 <aisatsana> Oh well thanks y'all back to coding, hehe :)
19:13:32 <dfeuer> merijn, I have the feeling simonpj and nomeata might be the only ones who actually know anything about it.
19:13:47 <dfeuer> Based on git history.
19:16:01 <merijn> :)
19:18:15 <dfeuer> merijn, I'm trying to get a clue about what's going on with https://ghc.haskell.org/trac/ghc/ticket/9701
19:18:27 <dfeuer> I thought I knew, but I was wrong.
19:20:02 <merijn> dfeuer: I've only build ghc a handful of times and that was to fix bugs in the RTS and base, ghc itself is completely opaque to me
19:24:39 <ReinH> merijn: I've never built it but I've had my computer build it pretty often...
19:25:53 <dfeuer> ReinH, so can *you* help me understand the specializer?
19:26:04 <ReinH> Almot ertainly not.
19:26:07 <ReinH> *certainly
19:26:13 <dfeuer> *Almost
19:26:39 <ReinH> dfeuer: that was a pretty fail sentence.
19:27:05 <dfeuer> ReinH, especially since you got the final word wrong. It should've been "so", rather than "not".
19:27:21 <ReinH> dfeuer: yes, let's never speak of this again
19:27:49 <dfeuer> That's fine. You help me understand the specializer, and I won't tell anyone about that sentence.
19:31:27 * hackagebot hsnsq 0.1.2.0 - Haskell NSQ client.  http://hackage.haskell.org/package/hsnsq-0.1.2.0 (PaulBerens)
19:34:38 <dfeuer> Now that External Core is dead, is GHC Core actually a *language* at all? A language has to have an alphabet, right?
19:35:15 <dfeuer> And be made of strings?
19:44:49 <lpaste> Laguana pasted “raytracer main function” at http://lpaste.net/6140296717666353152
19:45:02 <Laguana> Hey, i've written a dumb raytracer and I figured I could play around with parallelism to try to get some better performance. I figured since each pixel is independent of everything else, I'd parallelise over that, but no matter what I do I don't seem to get a speedup.
19:47:28 <jle`> Laguana: have you profiled it to make sure you know where the most slowdown actually is?
19:47:32 <jle`> maybe it's in the drawing
19:47:50 <dfeuer> Laguana, parallelism is too hard for me, but one question is whether rseq is seqing things deeply enough for your purpose.
19:47:55 <Laguana> nah, it's not the drawing 'cause I just added a few hundred faces and that made performance tank, even with only a couple thousand pixels
19:48:41 <dfeuer> rseq only evaluates things to whnf, so you have to be sure that's good enough.
19:49:25 <Laguana> dfeuer: I'm not sure that I follow. Is there a good reference for this stuff?
19:49:59 <dfeuer> Laguana, http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html
19:50:00 <Laguana> the "trace" function takes a coordinate pair, then casts a ray and compares with a static list of objects to see what it hits, and what colour it should be
19:50:10 <dfeuer> Laguana, but what does it return?
19:50:21 <Laguana> it returns a colour, which is a triple of floats
19:50:37 <Laguana> (specifically a V3 from the Linear package)
19:50:42 <benzrf> a triple?
19:50:48 <benzrf> what is this, nontransparent?
19:50:51 <Laguana> yep
19:51:01 <Laguana> like I said, it's a dumb raytracer :P
19:51:02 <dfeuer> Laguana, you need to show more code, but depending on how that's written, it could conceivably calculate only the fact that it *is* a triple, and not what's actually inside.
19:51:22 <Laguana> ok, I'll include the rest of it then, gimme a sec (and apologies for the rubbish code)
19:51:29 * hackagebot fb 1.0.7 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.7 (FelipeLessa)
19:51:31 <dfeuer> As for a reference, there are the Haddocks: http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html
19:51:35 <jle`> it might evaluate the (V3 _ _ _), but not what's inside
19:51:56 <jle`> actually
19:52:02 <jle`> Linear.V3 has strict fields
19:52:05 <jle`> hm.
19:52:11 <dfeuer> Ohhhhh, well that changes matters then.
19:52:24 <jle`> the game is afoot
19:52:43 <dfeuer> Or ahand.
19:53:29 <Laguana> http://lpaste.net/6140296717666353152
19:53:32 <Laguana> there's the rest of it, dfeuer
19:53:49 <dfeuer> For a raytracer, inspectigating the Core might be a good plan, to make sure that V3 gets erased and its contents unboxed....
19:57:21 <dfeuer> Laguana, this has nothing to do with anything, but what do you need traceDistance and such for?
19:57:55 <Laguana> that's how I've implemented the raytracer; a "raytracable object" knows how to intersect with a ray, what colour it is, and what the normal at that point is
19:58:02 <Laguana> for lighting and z sorting and such
19:59:33 <dfeuer> Laguana, it's always worth asking whether the square of the distance is good enough; if you don't actually need the square root, there's no point calculating it. But that's not your parallelism problem. What options are you using to compile and run?
20:00:07 <Laguana> I was using ghc --make raytracer -threaded -rtsopts to compile it, and running I was using ./raytracer +RTS -N4 -RTS
20:00:33 <dfeuer> How many physical CPUs do you have (not hyperthreaded cores)?
20:00:47 <jle`> are you checking to make sure the sparks are launching like expected?
20:01:21 <Laguana> I'm actually running this on a cloud hosted machine at the moment, but I believe it has 4
20:01:42 <Laguana> I was doing it locally earlier on an i7 cpu with the same kind of results
20:02:00 <Laguana> jle`: no because I don't know what any of that is :P How would I do that?
20:02:21 <dfeuer> jle` knows 10^10 times more about this than I do, I'm sure.
20:02:23 <jle`> have you read the simon marlow book?
20:02:27 <jle`> that's basically all i know :P
20:02:36 <dfeuer> Nope!
20:02:38 <jle`> he has a chapter on strategies
20:02:43 <jle`> and talks about doing just that
20:04:10 <dfeuer> I wonder ... Is parMap too fine-grained?
20:04:37 <Laguana> Well I wanted it to do each pixel in parallel, which is what I thought that would do
20:04:47 <Laguana> since right now I havent' optimised much at all, so each pixel has a lot of work to do
20:05:49 <dfeuer> Laguana, yeah, but there's a bit of overhead for each thread. Why don't you try evalListChunk instead, using, say, chunks of such a size that you break your list into four pieces?
20:06:35 <Laguana> do you mean parListChunk?
20:07:09 <dfeuer> Yeah, and you'd need to use some non-parallel strategy to take care of each chunk.
20:07:26 <dfeuer> I'm not saying that this will work, mind you, but I think it might.
20:08:13 <dfeuer> Applying the rdeepseq strategy to each chunk should work, I think.
20:10:44 <bitemyapp> pharpend_: I am here.
20:11:24 <Laguana> Hmm, if I try to use rdeepseq then it complains that it doesn't have an instance for Colour (which is defined by "type Colour = V3 Float")
20:11:28 <dfeuer> Laguana, you may actually want somewhat smaller chunks than that—probably more chunks than CPUs, but less than one per pixel. I think there's probably something out there to help you choose a good chunk size, but I'm ignorant.
20:12:20 <dfeuer> Laguana, you just need to make Colour a newtype instead of a type synonym, and then make it an instance of NFData, which is really easy.
20:12:47 <carter> Laguana: dfeuer  ghc with no O flags is ~ O0
20:12:55 <carter> did you try adding -O1 or -O2?
20:13:03 <Laguana> not recently, so I'll give that a go too
20:13:05 <dfeuer> Haaaaa. I knew that, but didn't notice.
20:13:20 <dfeuer> That is an absurd default.
20:13:54 <pollux__> hi
20:14:01 <pollux__> does anyone know any good (telnet) bbs?
20:15:39 <dfeuer> pollux__, do you have any idea how far off-topic that is?
20:16:23 <pollux__> dfeuer: gotta be honest. not.
20:16:34 <joelteon> just because haskell was created in 1990...
20:17:05 <Laguana> What, you're saying there isn't a package for that? :P
20:20:32 <joelteon> yes
20:20:35 <dfeuer> Laguana, there's http://src.seereason.com/happstack-bbs/
20:20:35 <joelteon> I am saying that
20:22:18 <dfeuer> Oh my. Telnet.hs on that page is painful.
20:27:55 <tsani> Yeah the nested case analyses around line 145 are something.
20:29:10 <dfeuer> Yep, tsani, case do case do case do case do ....
20:31:59 <tsani> Although implementing telnet and a MUD is kind of impressive.
20:32:19 <tsani> That module could easily benefit from being broken down into maybe 6 others though.
20:32:27 <dfeuer> Exactly.
20:33:27 <dfeuer> The telnet protocol, terminal handling, game logic, user interface, and whatever else all in one module seems a bit nuts.
20:34:02 <dfeuer> Authentication too.
20:34:09 * tsani sprinkles some separation of concerns all over Telnet.hs.
20:38:53 <carter> dfeuer: its a GOOD default
20:39:06 <carter> it means when you compile stuff for trying things out, it'll finish
20:39:57 <crazydiamond> Hi. Can anyone explain a thing from category theory? Is particular functor F from category C to category D maps all the objects and arrows of C to ones of D, or it can map only some of objects and arrows from C?
20:40:01 <dfeuer> carter, do you tend to induce non-termination in the simplifier or code generator?
20:40:36 <dfeuer> crazydiamond, it maps all the objects and arrows, yes. But you could talk about a functor from a subcategory if you like.
20:40:48 <crazydiamond> dfeuer, thanks!
20:40:54 <dfeuer> <- Not a category theorist, and doesn't play one on TV either.
20:46:56 <Laguana> ok, so dfeuer, I ran it through with the list chunking using rdeepseq, and also had it print some runtime stats. It claims that it did 1000 sparks, (I had 100 x 100 pixels, in chunks of 10) using 6 tasks ("1 bound, 5 peak workers") and got  a parallel GC work balance of 3.6%
20:47:07 <Laguana> the GC took the majority of the time, it seems
20:47:39 <dfeuer> Laguana, first off, that sounds to my uneducated mind like too many sparks.
20:47:57 <dfeuer> But let me take another look at your code too.
20:48:34 <Laguana> I've modified Colour to be a newtype wrapping around the V3, and made it an instance of NFData using "a `seq` ()"
20:48:41 <Laguana> everything else is basically the same
20:49:03 <dfeuer> I'm just looking at allocation behavior to the extent I can.
20:51:35 <dfeuer> I'm rather curious why V3 isn't already an instance of NFData. Kind of weird, that.
20:52:47 <dfeuer> Laguana, if GC is a big thing, have you tried space profiling?
20:52:56 <dfeuer> To try to see what's allocating so much?
20:53:08 <Laguana> I've not done much proper haskell, so I haven't done that before. how would I go about doing that?
20:53:47 <Laguana> I also notice that "top" isn't reporting a number above 100% when I run it, but I forget whether it does that when multiple threads are going.
20:54:27 <dfeuer> I've not done much proper profiling, but check out the GHC manual under time and space profiling. The easy thing to start with is to use -prof and whatever option makes it insert cost centers automatically. Be sure to run this *without* -O or -O2, or the results will be worthless.
20:55:03 <dfeuer> That is odd, Laguana
20:59:19 <Laguana> so probably a dumb question, but when I try to add profiling ("ghc --make -prof -auto-all raytracer") it complains that it can't load the Prelude. I take it I need to compile in some other way?
21:01:01 <dfeuer> Laguana, ugh. Did you compile GHC yourself?
21:01:11 <Laguana> nope. apt-get and cabal
21:02:04 <Laguana> ghc is installed via apt-get, and I've got a few packages via cabal
21:05:37 <dfeuer> Laguana, that's ... odd. It sounds like the GHC libraries were compiled without profiling. But I'm so far from knowledgeable about these matters ....
21:05:58 <Laguana> I might give things a break for a while again. I can live with slow toy raytracing for now
21:06:38 * hackagebot x509 1.5.0.1 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.5.0.1 (VincentHanquez)
21:08:00 <dfeuer> Laguana, there's nothing obviously standing out to me as an obvious memory problem, but I don't have the necessary libraries to compile your file.
21:08:17 <Laguana> fair enough. If you're curious, It's just "linear" and "gd"
21:08:27 <Laguana> but thanks for trying to help :)
21:08:32 <dfeuer> Laguana, yeah, but gd complains about a missing gd.h.
21:08:40 <dfeuer> And I don't know where that comes from.
21:08:40 <Laguana> yeah, you need to get libgd-dev
21:08:46 <dfeuer> Uh-huh.
21:09:11 <jle`> Laguana: keep us updated :)
21:09:49 <Laguana> jle`: We'll see when I get around to trying again :P But if I get it working, I'll come back and show a poorly raytraced teapot
21:10:17 <jle`> the teapot is the teapot
21:11:04 <Fuuzetsu> when will GPUs start being optimised to draw the teapot?
21:12:31 <pharaun> tempest in the teapot
21:19:44 <monochrom> GPUs are optimized for the teapot and Counter Strike
21:21:46 <chirpsalot> monochrom: Quake 3, rather.
21:22:05 <monochrom> yeah
21:22:51 <jle`> isn't teapot just a single gpu instruction on some chips?
21:23:30 <monochrom> soon, Quake 3 will be built-in on some chips, too :)
21:23:33 <Javran> is there an inverse function for Data.Ix.index, in which I can give a linearized integer, and get the corresponding range in return?
21:23:45 <chirpsalot> monochrom: that would actually be the coolest thing :P.
21:24:19 <chirpsalot> I wonder if it'll even remotely fit on an FPGA...
21:30:19 <dmj`> <3 counterstrike
21:31:41 * hackagebot wai-app-static 3.0.0.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.2 (MichaelSnoyman)
21:56:44 * hackagebot yi 0.10.1 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.10.1 (MateuszKowalczyk)
22:17:35 <alphonse23_> any body know how to get past this error in ghci: Ambiguous module name `Control.Monad.Writer': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
22:18:03 <merijn> Those two are incompatible
22:18:22 <merijn> If you have both installed you need to specify from where to import
22:18:25 <alphonse23_> so how do I import the Control.Monad.Writer?
22:18:42 <alphonse23_> how do I do that?
22:18:54 <pharpend_> alphonse23_: you have to pick which package you want to import from, then uninstall the other one (or use a sandbox)
22:21:39 <Axman6> you can also specify which package in the import line, it needs an excension though (looks like `import "mtl" Control.Monad.Writer`)
22:21:46 * hackagebot tls 1.2.11 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.11 (VincentHanquez)
22:21:48 * hackagebot hackernews 0.3.0.0 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.3.0.0 (DavidJohnson)
22:25:36 <alphonse23_> thanks Axman6, that worked: I had to turn on the -XPackageImports flag though
22:26:09 <Axman6> alphonse23_: you probably want to get rid of monads-tf though. not sure I can help with doing that the right way however
22:26:47 <alphonse23_> what is it, and how did it get in cabal?
22:26:47 * hackagebot tls 1.2.12 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.12 (VincentHanquez)
22:26:54 <alphonse23_> and why doesn't cabal have a remove command?
22:28:51 <Axman6> because removing libraries isn't particularly safe.
22:29:10 <Axman6> you can use ghc-pkg unregister <package> but that will break anything that relies on the package
22:29:25 <alphonse23_> hmm, okay....
22:35:28 <crazydiamond> In mathematical definition of e.g. maybe monad, what are things like Maybe, Just, Nothing? Functors, categories, arrows, objects or sth else?
22:36:18 <augur> crazydiamond: Maybe is the functor, Just and Nothing are part of the definition of Maybe
22:36:39 <augur> they're arrows
22:37:02 <crazydiamond> augur, thanks. So as well as I remember now.. Maybe isn't monad
22:37:12 <augur> Maybe is a monad!
22:37:24 <augur> so for Maybe, you have some kind of definition like..   for any A,  Nothing_A : 1 -> Maybe(A)   and   Just : A -> Maybe(A)
22:37:37 <pharpend_> apparently apple has a patent on some software I wrote a while ago
22:37:40 <pharpend_> http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=/netahtml/PTO/srchnum.htm&r=1&f=G&l=50&s1=7814163.PN.&OS=PN/7814163&RS=PN/7814163
22:38:15 <crazydiamond> augur, so these are identity nat. reprs?
22:38:47 <augur> crazydiamond: no, they're just arrows. tho there's a universal principle underlying it
22:39:16 <augur> and you can define a natural transformation for Nothing and Just, i think
22:39:31 <augur> in fact, you can
22:39:46 <augur> and the nat trans for Just is the unit of the monad
22:40:35 <crazydiamond> I just wonder if I can imagine that stuff graphically. Like with common kinds of categories like graphs
22:41:07 <augur> imagine what stuff, crazydiamond
22:41:31 <crazydiamond> functor is like that http://ncatlab.org/nlab/files/functor.jpg
22:41:49 <crazydiamond> I want to imagine monad
22:42:04 <crazydiamond> and maybe monad as long as it is a monad :P
22:42:35 <augur> oh, you want diagrams
22:42:59 <augur> well Maybe is an endo-functor on Set (usually), so there isn't *too* much to say
22:43:26 <crazydiamond> well every monad is endofunctor, isn't it?
22:43:52 <augur> yes
22:44:01 <crazydiamond> endofunctor with two nat. reprs
22:44:24 * ThreeOfEight sighs.
22:44:36 <ThreeOfEight> Somehow, I cannot install the tls package with cabal, even in a fresh sandbox.
22:44:50 <ThreeOfEight> Network/TLS/Struct.hs:134:10: Not in scope: type constructor or class `Error'
22:44:59 <ThreeOfEight> Does anyone have any suggestions?
22:46:54 <crazydiamond> If example of endofunctor is this, I want to continue with two nat. reprs. But it doesn't seem to me that there will be any practical use in that...  http://yogsototh.github.io/Category-Theory-Presentation/categories/img/mp/functor-morphism-color.png
22:49:01 <augur_> crazydiamond: no thats just a general functor there
22:50:11 <crazydiamond> augur_, I think that's endofunctor, 'cause that's the same cat. Anyway thanks, I think it's enough of that for now :D
22:50:36 <augur_> crazydiamond: no, it says at the top C and D = F(C)
22:50:48 <augur_> they're (possibly different) categories
22:51:20 <crazydiamond> well that's correct one: http://yogsototh.github.io/Category-Theory-Presentation/categories/img/mp/endofunctor.png
22:51:21 <augur_> F(C) is just another way of writing the target category of the endofunctor
22:51:31 <crazydiamond> sure
22:54:00 <aisatsana> Just a quick question, if I want to take a list and sent it off to a different function but I am done with prior elements covered in this list i.e "Hello" -> "llo" if I don't know the amount of remaining elements
22:54:16 <aisatsana> How do I do it? :)
22:56:38 <jle`> aisatsana: can you show a more specific example?
22:56:51 * hackagebot hackernews 0.3.1.0 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.3.1.0 (DavidJohnson)
22:56:52 <jle`> a couple of solutions come to mind which might vary in appropriate based on your situation
22:56:58 <jle`> *appropriateness
22:57:01 <aisatsana> Ah nevermind, think I solved it could just check the length and then just drop
22:57:29 <jle`> one way is to return a tuple with the result and the remainder of the list
22:57:41 <jle`> [s] -> (a, [s])
23:00:04 <aisatsana> Ah kk, thanks, drop did the trick didn't know how it worked I guess, hehe :)
23:07:25 <merijn> aisatsana: FYI
23:07:32 <merijn> aisatsana: Length is a really expensive operation
23:07:50 <aisatsana> I ended up not using it :) just the drop
23:07:56 <merijn> I suspect there's a much simpler approach, can you lpaste your code?
23:08:29 <aisatsana> It's a bit of a mess now but I could paste it kinda brute forcing it, hehe
23:10:27 <aisatsana> merijn: lpaste.net/112919 currently working on implementing sin / cos that's what I needed it for to check elements after having em spell "sin"
23:11:53 * hackagebot cabal-db 0.1.10 - query tools for the local cabal database  http://hackage.haskell.org/package/cabal-db-0.1.10 (VincentHanquez)
23:12:44 <merijn> aisatsana: eek!
23:13:01 <merijn> aisatsana: This can be done SO much easie!
23:13:22 <merijn> aisatsana: Let's start with "sine s = case head s" <- this is silly
23:13:32 <aisatsana> I'd assume so feels like I'm going about it like a total idiot but deadline is in, 40 so haha, gotta just get it done
23:13:48 <merijn> aisatsana: You can just write "sine ('s':rest) = {- stuff here -}"
23:14:20 <merijn> aisatsana: Hell, "sine ('s':'i':'n':'e':rest)" is a perfectly legal haskell pattern
23:14:45 <trap_exit> when will the walking dead
23:14:51 <trap_exit> episode 2 be available for purchase on itunes?
23:14:57 <trap_exit> wrong channel
23:14:57 <trap_exit> sorry
23:16:08 <lpaste> merijn pasted “Simpler is better” at http://lpaste.net/112920
23:16:13 <merijn> aisatsana: Try that
23:16:37 <CodeWeaver> Greetings.
23:16:54 * hackagebot keystore 0.6.2.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.2.0 (ChrisDornan)
23:17:16 <aisatsana> Will do :) thanks for all the help tonight man, just goota duct tape this abomination together for deadline now, it's just the first after all so I'll be sure to clean it up even more later :)
23:22:27 <LambdaCalculus> Hello all.
23:26:41 <alphonse23_> does anyone understand the Control.Monad.Writer lib?
23:26:58 <alphonse23_> I keep getting this error: No instance for (MonadWriter [[Char]] (Writer [String])) arising from a use of `tell'
23:27:03 <alphonse23_> whenever I use the tell function
23:27:16 <alphonse23_> I'm not sure how to invoke the tell function appropriately
23:27:50 <Haskellfant> alphonse23_: could you post a code sample giving you that error?
23:30:35 <alphonse23_> http://pastebin.com/w5htvY3K
23:30:40 <alphonse23_> it's a lot of stuff
23:31:02 <alphonse23_> I'm reading through learnyouahaskell chapter 13
23:31:38 <Haskellfant> alphonse23_: you implemented your own writer type and it's not an instance of MonadWriter
23:31:54 <alphonse23_> so don't include writer in there
23:32:17 <Haskellfant> well you can include it but then you need to include the instance as well
23:32:30 <Haskellfant> or use the one from Control.Monad.Writer
23:32:48 <LambdaCalculus> What's the best way to learn Haskell? I was referred to a git-hub page long ago. Lost the link. Can someone point me in the right direction?
23:33:32 <alphonse23_> okay
23:33:42 <alphonse23_> it looks like its working, thanks haskellfant
23:33:46 <Haskellfant> np
23:35:24 <frawgie> LambdaCalculus: LYAH and this for reference can be a good start: http://dev.stephendiehl.com/hask/
23:35:46 <Haskellfant> also take a look here https://github.com/bitemyapp/learnhaskell
23:36:11 <Haskellfant> brent yorgey's course seems to be quite good (haven't done ti myself)
23:37:09 <LambdaCalculus> Thank you frawgie and Haskellfant. I will start with the Brent Yorgey course then :)
23:37:31 <alphonse23_> hey Haskellfant, now when I to use Writer I get this error: Not in scope: data constructor `Writer'
23:37:31 <alphonse23_>     Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
23:37:50 <alphonse23_> and then when I try to use WriterT, ghci complains about types
23:38:26 <Haskellfant> but type Writer w = WriterT w Identity in your file
23:38:36 <Haskellfant> ah you might need to import Control.Monad.Writer.Lazy
23:38:47 <Haskellfant> then this should already be exported if I understand the docs correctly
23:39:31 <Haskellfant> ah mtl is not included with ghc, nvm then
23:39:41 <alphonse23_> I could also use monad-tf
23:39:48 <alphonse23_> cabal also installed that
23:40:02 <alphonse23_> I'm just be specifying the specific version of Control.Monad.Writer
23:40:10 <Haskellfant> import Control.Monad.Trans.Writer.Lazy
23:40:11 <alphonse23_> should I be using monad-tf?
23:40:19 <Haskellfant> then you should get Writer
23:40:25 <Haskellfant> at least I do :)
23:41:29 <alphonse23_> same error: Not in scope: data constructor `Writer'
23:41:29 <alphonse23_>     Perhaps you meant `WriterT' (imported from Control.Monad.Trans.Writer.Lazy)
23:41:50 <Haskellfant> ah well it's not a data constructor but a type :)
23:42:15 <Haskellfant> the data constructor is writer
23:45:00 <alphonse23_> using "writer" still doesn't have matching kinds
23:45:14 <Haskellfant> show the code
23:47:56 <alphonse23_> http://pastebin.com/mpaUNKcF
23:49:51 <Haskellfant> alphonse23_: using writer instead of Writer in this works just fine for me
23:50:32 <alphonse23_> <interactive>:20:60:
23:50:32 <alphonse23_>     Couldn't match kind `* -> *' against `*'
23:50:32 <alphonse23_>     Kind incompatibility when matching types:
23:50:32 <alphonse23_>       m0 :: * -> *
23:50:32 <alphonse23_>       [String] :: *
23:50:32 <alphonse23_>     In the return type of a call of `writer'
23:50:32 <alphonse23_>     In the expression: writer (x, ["Got number: " ++ show x])
23:50:41 <alphonse23_> I get this in ghci
23:51:01 <Haskellfant> what does :i writer show
23:51:16 <alphonse23_> writer :: Monad m => (a, w) -> WriterT w m a
23:51:17 <alphonse23_>   	-- Defined in `Control.Monad.Trans.Writer.Lazy'
23:52:05 <Haskellfant> alphonse23_: have you only changed the right “Writer”?
23:52:12 <alphonse23_> yes
23:52:19 <alphonse23_> I lowercased the first char
23:52:37 <Haskellfant> please post the corrected version
23:52:46 <Haskellfant> just to be sure I understand what you've done
23:52:57 <alphonse23_> let logNumber :: Int -> writer [String] Int; logNumber x = writer (x, ["Got number: " ++ show x])
23:53:15 <Haskellfant> you've changed both Writer to writer!
23:53:20 <Haskellfant> leave the left one Writer
23:53:24 <Haskellfant> on the left you want a type
23:53:28 <Haskellfant> that's Writer
23:53:38 <Haskellfant> on the right you want the data constructor
23:53:40 <alphonse23_> okay
23:53:42 <Haskellfant> so you use writer
23:53:44 <alphonse23_> there it worked
23:53:46 <alphonse23_> :)
23:53:59 <alphonse23_> thanks Haskellfant
23:57:17 <solatis> hmm i find it surprisingly difficult to figure out what happens when an exception is thrown within a forever () loop
23:57:43 <solatis> is the exception ignored, or is it re-thrown to be handled upstream?
23:59:19 <alphonse23_> oh wow, Writer is awesome. Logging really clearings things up. Thanks again Haskellfant!
