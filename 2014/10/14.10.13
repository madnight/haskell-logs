00:01:49 <DarkCthulhu> I have my own data type deriving Show. How can I concatenate that type's String equivalent with another String?
00:03:15 <FreeFull> DarkCthulhu: call show on it and concatenate the two Strings together, perhaps?
00:04:04 <chirpsalot> > show 13 ++ " YAY"
00:04:05 <lambdabot>  "13 YAY"
00:04:57 <solatis> is there some built-in structure in some haskell library i can use to hold (and manipulate) a hostname/port/protocol ?
00:05:14 <solatis> or will i just have to use the URI library for that
00:05:42 <solatis> (or write my own custom struct)
00:06:17 <solatis> network.uri is a little too much for my purpose, but otoh, i could use only certain parts of it
00:11:00 <DarkCthulhu> ty FreeFull chirpsalot . I tried that, but there is something not quite working out. I'll make a test case out of it in a minute
00:11:30 <chirpsalot> DarkCthulhu: if I had to take a guess precedence causing type errors?
00:12:32 <DarkCthulhu> chirpsalot, Could be.. I'm getting errors of the kind: Couldn't match expected type `X' with actual type `[a0]'
00:12:48 <DarkCthulhu> There is a function returning X, and X is the data type that derives Show
00:13:45 <chirpsalot> DarkCthulhu: toss it in lpaste? :)
00:14:45 <DarkCthulhu> chirpsalot, It's part of a huge thing. Trying to construct a simplified case and reproduce it :)
00:24:50 * hackagebot yesod-bin 1.4.0.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.1 (MichaelSnoyman)
00:46:27 <solatis> is there a haskell variant of function overloading? pattern matching with null?
00:47:12 <solatis> as in, i have a function that, for example, looks like createSocker :: Int -> Socket (where Int is the port) -- if no port is defined, I want to use a default port
00:47:30 <mauke> solatis: no, you can only use Maybe Int
00:48:16 <solatis> ok, which makes sense too
00:48:24 <mauke> also, IO Socket
00:48:41 <solatis> yeah i know, my example was more hypothetical
00:49:39 <solatis> but it's not like i can create two functions with the same name that have different signatures?
00:49:54 <bartavelle> you can't do that
00:50:00 <bartavelle> well
00:50:04 <bartavelle> in distinct modules you can
00:50:09 <bartavelle> but you'd have to prefix the function names
00:50:13 <solatis> yeah i get what you mean
00:50:13 <mauke> that's effectively different names
00:50:20 <bartavelle> yep
00:50:22 <mauke> A.foo and B.foo
00:50:36 <solatis> yeah
00:50:38 <solatis> which is a hack
00:51:12 <solatis> i remember reading somehwere a long time ago that haskell actually only has functions that accept 1 parameter and return a function themselves
00:51:33 <solatis> did i remember that correctly?
00:51:45 <solatis> that under the hood, everything is a function that accepts just 1 argument?
00:51:46 <Lutin`> Well they can return any type
00:52:09 <mauke> solatis: yes
00:52:11 <solatis> that Foo :: Int -> Text -> Bool is actually curried by the compiler
00:52:17 <Lutin`> Yes
00:52:22 <mauke> well, it's curried by the programmer :-)
00:52:25 <solatis> yeah
00:52:28 <mauke> -> in types is right associative
00:52:38 <mauke> Int -> Text -> Bool parses as Int -> (Text -> Bool)
00:52:39 <Lutin`> (->) is right associative
00:52:48 <dibblego> solatis: http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/index.html
00:53:00 <Lutin`> mauke: That's what I get for typing without looking at the chat lol
00:53:06 <Saizan> solatis: actually, under another hood, the compiler does a lot of work to optimize function calls
00:53:10 <dibblego> the compiler does not do currying; only that -> associates to the right
00:53:26 <solatis> i have the feeling i actually do not want to know what the compiler is doing under the hood :)
00:53:36 <mauke> \x y z -> ... is sugar for \x -> \y -> \z -> ...
00:53:59 <solatis> (knowing what gcc is doing under the hood inflicted life-long damages upon me)
00:58:20 <DarkCthulhu> Are all untyped lambda calculus terms typable in simply typed lambda calculus?
00:59:12 <ski> no
00:59:49 <chrisdone> does the Y-combinator have a valid type?
01:01:41 <ski> DarkCthulhu : e.g. ⌜λ ω. ω ω⌝
01:02:27 <ski> chrisdone : are you asking DarkCthulhu or the whole channel ?
01:02:47 <ski> (i'm assuming the former)
01:03:22 <chrisdone> DarkCthulhu
01:05:21 <DarkCthulhu> ah
01:05:41 <DarkCthulhu> chrisdone, I see your point
01:06:05 <solatis> ok
01:06:13 <solatis> i'm feeling like i'm doing this wrong
01:06:40 <lpaste> solatis pasted “Optional arguments” at http://lpaste.net/112517
01:06:52 <solatis> anyone can comment on that pastie?
01:07:27 <solatis> if i have an optional input and output address, wrapped in two maybes, is this the way to go?
01:07:37 <solatis> or is there some more elegant way to handle this?
01:07:40 <DarkCthulhu> ski, λ ω. ω ω is a lambda term that applies ω to itself?
01:07:47 <ski> yes
01:08:22 <bartavelle> solatis, if you are ok for having distinct function names, the usual convention is to have "wrapInOut :: a -> b" "wrapInOutWith :: opt1 -> opt2 -> a -> b"
01:08:49 <prinsen> When i compile a library with -prof, i get Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp’?
01:09:03 <solatis> bartavelle: right
01:09:16 <bartavelle> solatis: this is a common pattern in libraries
01:09:20 <solatis> bartavelle: so i should rather define a wrapInOutWithDefault
01:09:27 <solatis> ok
01:09:36 <bartavelle> usually people use the "short name" for the most common way to use a function
01:09:59 <DarkCthulhu> ski, So, when would I say something is typable? I'm new to lambda calculus and have a little trouble parsing the terminology. λ ω. ω + 1 (assuming + exists in our extended calculus) would have type = ?
01:10:01 <bartavelle> makeLenses vs. makeLensesWith
01:10:21 <solatis> so that is why `runMongodb` is using default arguments, and `runMongodb'` lets you provide custom arguments
01:10:38 <solatis> ah
01:10:40 <solatis> i understand
01:10:57 <bartavelle> solatis: another "solution" is to provide a "default" data structure with parameters you can override
01:11:01 <mauke> DarkCthulhu: depends on the type of (+). if (+) :: A -> B -> C, then (\x -> x + 1) :: A -> C
01:11:01 <solatis> so I should just do wrapInOut which creates the default values
01:11:10 <mauke> and 1 :: B, hopefully
01:11:16 <solatis> and then forwards execution to wrapInOutWith defaultInput defaultOutput
01:11:28 <bartavelle> solatis: you should do what makes more senses to you ;) thise are just some patterns I observed
01:11:28 * solatis understands
01:11:32 <solatis> yeah
01:11:46 <solatis> well i'm not yet in the position to decide what makes most sense to me
01:11:48 <ski> DarkCthulhu : if we assume we're talking about natural numbers ⌜ℕ⌝, then the type of ⌜λ n. n + 1⌝ would be ⌜ℕ → ℕ⌝
01:12:00 <solatis> but this sounds like a nice way to solve the problem
01:12:07 <bartavelle> solatis, you can still refactor later
01:12:19 <solatis> yeah i know, but i'm actually refactoring this now
01:12:29 <solatis> the previous version *only* used defaults :)
01:12:39 <solatis> so i'm trying to make it more customizable
01:13:01 <bartavelle> well, then adding "xxxWith" version of the function should not break existing code
01:13:04 <solatis> i've seen the pattern you described emerge from a few libraries, too
01:13:09 <solatis> exactly
01:13:16 <dibblego> solatis: reader monad does it nicely
01:13:26 <DarkCthulhu> mauke, ski: So, in general, without knowing whether it refers to natural numbers, or if + :: A -> B -> C, we cannot tell if some expression is typable?
01:13:59 <DarkCthulhu> errr.. when I say simply typed lambda calculus, what does it include?
01:13:59 <ski> DarkCthulhu : we have to know the types of the free variables and operations in the expression to be able to tell
01:14:01 <lambda_> Is it impossible to derive Generic instances for GADTs, or is that just a current limitation?
01:14:23 <bartavelle> dibblego, I never saw it used for this purpose, do you mind elaborating ?
01:14:36 <ski> DarkCthulhu : simply typed lambda calculus includes variables, applications, and (lambda) abstractions in the terms, and function types in the types
01:15:02 <Lutin`> It appears lambdabot's @pl doesn't like nested list comprehensions
01:15:05 <ski> DarkCthulhu : often one also includes some base type, like natural numbers, and some basic terms for it, like natural number literals, addition, multiplication
01:15:19 <solatis> dibblego, bartavelle thanks for your input
01:15:26 <DarkCthulhu> ski, Hmm.. okay. That makes sense. How is it that without defining the operations etc, it is possible to say that not all untyped terms are typable in simply typed lambda calculus?
01:15:29 <Lutin`> @pl matI n = [ [fromEnum $ i == j | i <- [1..n]] | j <- [1..n]]
01:15:29 <lambdabot> matI = return . ap ((<-) . (| j) . return . fromEnum . (i ==) . ((j | i) <-) . enumFromTo 1) (enumFromTo 1)
01:15:41 <ski> DarkCthulhu : sometimes one also includes product/tuple types (and their terms), and possibly also sum types (and their terms)
01:16:37 <ski> @pl \x y -> [x | y]
01:16:38 <lambdabot> flip flip [] . ((:) .) . (|)
01:16:47 <ski> Lutin` : it doesn't understand list comprehensions at all
01:17:02 <Lutin`> ski: Ah that would explain it
01:17:08 <DarkCthulhu> ski, λ ω. ω ω for example can never be typed, no matter what kind of function ω is?
01:17:19 <ski> @undo \x y -> [x | y]
01:17:19 <lambdabot> \ x y -> if y then [x] else []
01:17:31 <ski> Lutin` : you could use `undo' to translate away from list comprehensions ..
01:18:30 <ski> DarkCthulhu : right, because types have to be finite (in the simply typed lambda calculus)
01:18:37 <Lutin`> Yeah I was just thinking I found something buggy, but it appears the bug is due to undefined behavior
01:19:57 <DarkCthulhu> ski, What does types being finite mean?
01:20:05 <nkar> is there any difference between _ <- action vs. void $ action?
01:20:43 <ski> DarkCthulhu : if we allow infinite types, then the type of ⌜λ ω. ω ω⌝ could be a type ⌜τ⌝, where we have the equality ⌜τ = (τ → σ)⌝, for any type ⌜σ⌝ we like
01:21:50 <ski> DarkCthulhu : iow, ⌜τ⌝ is here short for ⌜((((⋯) → σ) → σ) → σ) → σ⌝, with infinitely many nested function arrows
01:22:15 <ski> @index void
01:22:15 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
01:22:19 <DarkCthulhu> ski, Why should the type be nested int that manner?
01:22:23 <DarkCthulhu> *in
01:23:21 <ski> DarkCthulhu : because, looking at ⌜λ ω. ω ω⌝, we see that its an abstraction, so its type (if it has any) must be a function type, i.e. a type of the shape ⌜τ → σ⌝, for some particular types ⌜τ⌝ and ⌜σ⌝
01:24:15 <ski> DarkCthulhu : now, the formal parameter ⌜ω⌝ of the abstraction would then be required to have type ⌜τ⌝ inside the body, i.e. ⌜ω ω⌝, which would be required to have type ⌜σ⌝
01:24:20 <ski> DarkCthulhu : ok, so far ?
01:24:21 <lpaste> solatis pasted “Optional arguments” at http://lpaste.net/112519
01:24:35 <DarkCthulhu> ski, yup. Following so far
01:24:47 <solatis> bartavelle: looks like this looks a lot more elegant http://lpaste.net/112519
01:24:53 * hackagebot cake 1.1.0.1 - A build-system library and driver  http://hackage.haskell.org/package/cake-1.1.0.1 (JeanPhilippeBernardy)
01:24:55 * hackagebot marxup 3.0.0 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-3.0.0 (JeanPhilippeBernardy)
01:25:00 <ski> nkar : not really .. though i don't like using `void' for non-FFI stuff
01:25:38 <nkar> why not?
01:26:59 <bartavelle> solatis: yup !
01:28:06 <DarkCthulhu> ski, I understood the above three statements, but still not why τ needs to be an infinitely nested type
01:28:52 <ski> DarkCthulhu : continuing, we analyze the body ⌜ω ω⌝ (which we want to have type ⌜σ⌝), noting that it's an application (of an operator ⌜ω⌝ to an operand ⌜ω⌝), and so the operator ⌜ω⌝ ought to have type ⌜τ′→ σ⌝ and the operand ⌜ω⌝ ought to have type ⌜τ′⌝ for some yet to be determined operator parameter type ⌜τ′⌝
01:29:44 <DarkCthulhu> ski, okay.. understood. The same ω needs to have different types in the operand and operator role.
01:32:30 <ski> DarkCthulhu : now, assuming that the variable ⌜ω⌝ has only a single type (namely the type ⌜τ⌝, which the abstraction gave to it in ⌜λ ω.⌝), we now see that the two types ⌜τ′→ σ⌝ and ⌜τ′⌝ must be equal (and must be equal to ⌜τ⌝, so we drop the prime now) so we know ⌜τ = τ → σ⌝. so the whole term ⌜λ ω. ω ω⌝ has type ⌜τ → σ⌝, which we can now abbreviate to just ⌜τ⌝, where ⌜τ = τ →
01:32:44 <rtharper> need more coffee for this
01:33:11 <ski> DarkCthulhu : no, the seemingly different types in the operator and operand positions of the application must in fact be equal, which yields this infinite type ⌜((((⋯) → σ) → σ) → σ) → σ⌝
01:33:35 <ski> DarkCthulhu : but as simply typed lambda calculus doesn't admit infinite types, this is not allowed, and so the term isn't typable
01:33:46 <DarkCthulhu> ski, I see now!
01:34:27 <DarkCthulhu> ski, TY so much for explaining that. I understand now that the infinite type is the only way to have an equivalence there between τ and τ → σ!
01:34:48 <AshyIsMe> woo my first hackage package
01:34:50 <AshyIsMe> https://hackage.haskell.org/package/lambdatwit-0.1.0.0
01:34:53 * hackagebot lambdatwit 0.1.0.0 - Lambdabot running as a twitter bot. Similar to the @fsibot f# bot.  http://hackage.haskell.org/package/lambdatwit-0.1.0.0 (aaronash)
01:34:57 <ski> DarkCthulhu : you can actually play around with such infinite types in OCaml, if you start it with `ocaml -rectypes'
01:35:20 <DarkCthulhu> ski, Does Haskell allow for such types?
01:35:33 <mauke> not directly
01:36:11 <mauke> you can define 'data X = MkX (X -> X)' or something
01:36:34 <ski> DarkCthulhu : the main reason pragmatic reason why we don't typically allow infinite (more precisely cyclic) types like this is that many common errors (such as forgetting an argument in a recursive call) would infer (strange) cyclic types instead of flagging a type error
01:36:50 <AshyIsMe> can someone try installing lambdatwit from hackage?
01:37:55 <ski> DarkCthulhu : OCaml has it for object types, to be able to build objects that has methods that take or return values of the same type as the whole object. but it only allows such cyclic types if all the cycles go through at least one object type construction. the `-rectypes' option lifts this restriction
01:39:12 <ski> nkar : because the term "void" here comes from C. in Haskell, i would prefer it being called `unit' (because it replaces the "component type" by `()', the "unit" type) or `ignore' (because it ignores the "result")
01:39:31 <DarkCthulhu> ski, oh.. okay. It's a lot clearer now to me. ty again :) I'll read up on the what OCaml allows and about recursive data definitions that mauke showed.
01:39:34 <ski> nkar : `void' in C (in this usage. `void *' is different) more or less corresponds to `()' in Haskell
01:39:59 <jle`> @. unpl pl \x y -> [x | y]
01:39:59 <lambdabot> <unknown>.hs: 1: 27:Parse error: |
01:40:08 <nkar> ski: what do you think of 'return' then? :)
01:40:33 <ski> nkar : `return' in Haskell already means something else than it means in C ;)
01:40:43 <jle`> oh
01:40:48 <jle`> it literally thinks that | is an operator
01:40:51 <ski> yes
01:41:30 <jle`> funny
01:42:54 <ski> DarkCthulhu : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> might perhaps be interesting
01:44:15 <DarkCthulhu> ski, Will read! I have one more question. Which rule of simply typed lambda calculus says that there cannot be infinite types? I can't find that explicitly mentioned.
01:44:42 <solatis> sometimes i feel like #haskell is the equivalent to #complexMath
01:45:08 <solatis> not having a CS background, some things being said here make absolutely no sense to me
01:46:09 <ski> DarkCthulhu : btw, another way to type ⌜λ ω. ω ω⌝ is to use rank-2 types
01:46:13 <kadoban> solatis: Most of the stuff discussed here isn't particularly covered in a CS undergrad anyway.
01:46:20 <hyPiRion> solatis: I've realised that only the words are scary, not the concepts themselves. It's usually easier if you have some examples to identify the terms with
01:46:36 <solatis> yeah
01:46:45 <solatis> it's the same as reading research papers
01:46:57 <solatis> if only they would provide a little code sample, it would make so much more sense to me
01:47:14 <bartavelle> (also it will eventually all become clear)
01:47:29 <hyPiRion> yeah, you're better off reading blogposts if they exist on the topic
01:47:46 <Total_1mmersion> What's the difference between TH and QQ?
01:47:59 <DarkCthulhu> ski, Hmm..
01:48:33 <ski> DarkCthulhu : "Which rule of simply typed lambda calculus says that there cannot be infinite types?" -- the types are inductively generated by a BNF like ⌜τ ∷= ℕ | τ → τ⌝ e.g.
01:48:37 <solatis> hyPiRion: yeah, i once had to implement the Paxos protocol in c++ -- reading the research paper was almost impossible to me, and the wikipedia page on the topic was so much more informative
01:48:38 <jle`> bitemyapp: is there an actual app that you want me to bite
01:48:52 <solatis> it's almost like researchers are actively *trying* to obscure their results
01:49:35 <solatis> i really like the aproach google has taken with Raft https://raftconsensus.github.io/
01:49:49 <ski> DarkCthulhu : this means that a type is anything constructed by a *finite* number of application of these two cases (more precisely, an application of the two cases with finite *depth*, but seeing as none of the cases has infinite width, it amounts to the same thing)
01:50:51 <ski> DarkCthulhu : it's the same idea that says that ⌜n ∷= 0 | 1+ n⌝ generates only finite natural numbers, it doesn't generate an infinite ⌜1+ (1+ (1+ (⋯)))⌝
01:51:00 <simpson> solatis: Raft wasn't developed by Google; it was academic research at Stanford.
01:51:09 <solatis> simpson: ah, my mistake
01:51:27 <solatis> i believe it was fully embraced by golang, tho
01:51:55 <DarkCthulhu> ski, I understand now. The BNF thing seems to be a requirement for simply typed lambda calculus then
01:52:15 <DarkCthulhu> ski, I couldn't find a definition for it, but wikipedia does talk about expressing types using that format.
01:52:29 <ski> DarkCthulhu : the BNF syntax here is merely a nice way to state an inductive definition. such has been around for longer than the BNF syntax has
01:54:38 <ski> DarkCthulhu : you could state the content of the inductive definition ⌜τ ∷= ℕ | τ → τ⌝ in words as :
01:55:23 <ski> (a) ⌜ℕ⌝ is an element of our set of simply typed lambda-calculus types (for short "types")
01:56:06 <ski> (b) if ⌜σ⌝ and ⌜τ⌝ are types, then ⌜σ → τ⌝ is a type
01:57:14 <DarkCthulhu> hmm
01:57:53 <DarkCthulhu> ski, would you say that λnfx.f(n f x) and the function f(x) = x + 1 are equivalent?
01:57:53 <ski> (c) if ⌜X⌝ is any set such that (c0) ⌜ℕ⌝ is an element of ⌜X⌝; and (c1) for any elements ⌜x⌝,⌜y⌝ of ⌜X⌝, ⌜x → y⌝ is an element of ⌜X⌝, then our set of types is a subset of ⌜X⌝ (iow ⌜X⌝ includes *all* our types)
01:58:05 <ski> this last rule (c) is the crucial bit here
01:58:18 <ski> it's basically an induction rule for our types
01:58:29 <DarkCthulhu> ski, That rule will take me a few readings to understand :)
01:59:02 <ski> if we instead would be looking at ⌜n ∷= 0 | 1+ n⌝, then (c) would *be* (one way of expressing) the normal induction rule for natural numbers
02:00:30 <DarkCthulhu> ski, ohh, I understand the definition. The valid set is a subset of all combinations possible..
02:01:02 <ski> DarkCthulhu : to clarify the last rule, consider two sets, ⌜T⌝ and ⌜T′⌝ where both these include all the finite types, but ⌜T′⌝ also include all the infinite types we can build (and the two sets contain nothing else than this)
02:01:29 <ski> by construction, both these sets satisfy (a) and (b)
02:01:40 <DarkCthulhu> yeah
02:02:44 <DarkCthulhu> ski, The one which includes infinite types will not be a subset of the thing defined in step (c), because it will have some recursive thing?
02:03:02 <ski> now, (c) essentially says that if ⌜X⌝ is any set which satifies (a) and (b) (in the sense where we replace "our set of types" by ⌜X⌝ in them), then ⌜X⌝ must be a superset of our set of types
02:04:01 <ski> so, both sets ⌜T⌝ and ⌜T′⌝ would be valid candidate sets for ⌜X⌝ in (c)
02:05:55 <ski> now, if we assume that "our set of types" could be ⌜T′⌝, then in (c), if we take ⌜X⌝ as being ⌜T⌝, then it would result that ⌜T′⌝ is a subset of ⌜T⌝
02:06:25 <ski> but this is *false*, so the set ⌜T′⌝ doesn't satisfy the requirements for (c)
02:06:27 <DarkCthulhu> ski, ah.. and that's a contradiction
02:07:19 <ski> however, the set ⌜T⌝ *does* satisfy the requirements of (c), because it doesn't include anything *except* as sanctioned by rules (a) and (b)
02:07:44 <ski> for short, one usually formulates rule (c) something like :
02:08:02 <ski> (c) nothing is a type, except as granted (by a finite number of applications of) rules (a) and (b)
02:08:18 <ski> but it really means what i said above. this is just a common shorthand
02:08:52 <DarkCthulhu> ski, Awesome and super convincing formal proof :)
02:09:21 <ski> (and in general, it's not the number of applications that need to be finite, but the *depth* of the applications that need to be finite. we could conceivably have a rule that takes an infinite number of types and combines them into a single type. that would be fine)
02:09:50 <DarkCthulhu> ski, and recursive types obviously violate that rule
02:09:55 <DarkCthulhu> right
02:10:01 <ski> well, cyclic ones do
02:10:45 <ski> mauke's example `data X = MkX (X -> X)' is usually said to be recursive, but it's still not cyclic (and so it's not infinite)
02:11:04 <ski> but `type X = X -> X' would be cyclic, and isn't allowed by Haskell
02:11:26 <ski> in the latter case, the type `X' *is* (the same as) the type `X -> X'
02:11:48 <ski> in the former case, there's merely a *translation* (an isomorphism) between `X' and `X -> X'
02:12:09 <ski> (and really, we should, for technical reasons, use `newtype' instead of `data' in this case)
02:12:23 <DarkCthulhu> ski, What does the translation really mean here? Is there some real-world way in which I can understand the difference between the two?
02:12:30 <ski> (that's because Haskell is non-strict)
02:14:13 <ski> DarkCthulhu : consider `data BoolStream = Cons Bool BoolStream', or, equivalently, `newtype BoolStream = Cons (Bool,BoolStream)'
02:14:41 <ski> conceptually, a `BoolStream' is an (infinite (in one direction)) tuple of booleans
02:14:49 <DarkCthulhu> yeah..
02:16:51 <ski> or perhaps more accurately, an infinitely nested (in the right component) value built up of pairs and booleans, like ⌜(b₀,(b₁,(b₂,(b₃,⋯))))⌝, where ⌜b₀⌝,⌜b₁⌝,⌜b₂⌝,⌜b₃⌝,⋯ are any booleans
02:17:29 <DarkCthulhu> ski, Yes, it would be an infinite set, but the laziness of Haskell implies that it is evaluated only to the extent necessary?
02:17:35 <ski> now, do you know anything about set theory ?
02:17:49 <ski> (such as Zermelo-Fraenckel set theory)
02:18:54 <DarkCthulhu> ski, No, I do not.
02:19:21 <ski> in ZF set theory, everything is built out of sets (having sets as elements, which have sets as elements, &c.)
02:19:54 <DarkCthulhu> ski, Which book do you recommend for learning the set theory and math side of type systems?
02:20:01 <ski> one common construction for a pair ⌜(x,y)⌝ there is the Kuratowski pair ⌜{{x},{x,y}}⌝
02:20:22 <ski> and there's an axiom of ZF that says that there can be no infinitely nested set
02:20:34 <ski> (but infinitely "wide" sets are just fine)
02:21:16 <ski> so, we can't represent ⌜(b₀,(b₁,(b₂,(b₃,⋯))))⌝ in ZF set theory, because this would then be an infinitely deep nested set
02:21:20 <ski> DarkCthulhu : do you see ?
02:22:41 <DarkCthulhu> ski, Err.. I understand the general direction, but I think I lack the fundamentals in this area to understand completely.
02:23:53 <ski> DarkCthulhu : the details of the actual representation of things in ZF isn't here very important
02:24:29 <DarkCthulhu> ski, I don't quite understand where it fits into the types discussion :)
02:27:52 <ski> the point is that if we attempt to translate `type BoolStream = (Bool,BoolStream)' into a set theory equation ⌜𝔹⋆ = 𝔹 × 𝔹⋆⌝ (where ⌜𝔹⌝ is just another way to write `Bool', and ⌜𝔹⋆⌝ was how i decided to write `BoolStream', and ⌜×⌝ is the cartesian product of two sets, i.e. ⌜A × B⌝ is the set whose elements are of the form ⌜(a,b)⌝, for all possible elements ⌜a⌝ of ⌜A⌝ and ⌜b⌝ of ⌜B⌝)
02:28:27 <Kinnison> Only #haskell makes me worry that my unicode font support is insufficient
02:28:36 <Kinnison> I have a number of ?s in ski's most recent statement
02:28:41 <mr-> ski: So, if you encode tuples as Kuratowski things, there is no infinitely long tuple?
02:28:57 <ski> but this set equation ⌜𝔹⋆ = 𝔹 × 𝔹⋆⌝ has no solution for ⌜𝔹⋆⌝, because sets can't be infinitely deep
02:28:59 <DarkCthulhu> ski, okay.. understood the link between the type and set theory domains.
02:29:02 <DarkCthulhu> ski, Ah..
02:29:14 <DarkCthulhu> ski, Infinite length is okay, not depth right?
02:29:18 <Arahael> Kinnison: Looks fine here, ssh'ing from a mac (using Terminal.app) to debian, tmux, and irssi. :)
02:29:25 <ski> mr- : there's no infinitely long tuple, *if* you attempt to encode it as nested pairs in this way
02:29:27 <Kinnison> Arahael: I imagine I'm missing some fonts here
02:29:40 <Arahael> Kinnison: Probably, and/or unicode terminal support.
02:29:53 <Kinnison> Arahael: Oh I have *most* of the symbols, that's fine, it's just some are missing
02:29:56 * hackagebot marxup 3.0.0.1 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-3.0.0.1 (JeanPhilippeBernardy)
02:30:13 <ski> (ftr ⌜𝔹⌝ is just a ("mathematical") double-struck ⌜B⌝, just like ⌜ℕ⌝ is a double-struck ⌜N⌝)
02:32:05 <ski> DarkCthulhu : now, in ZF, a function from a set ⌜A⌝ to a set ⌜B⌝ is a set with elements ⌜(a,b)⌝ for all possible elements ⌜a⌝ of ⌜A⌝, where ⌜b⌝ is an element of ⌜B⌝, and where to each ⌜a⌝ there's only one pair in the function (which is this set of pairs)
02:32:26 <ski> so each ⌜a⌝ (in ⌜A⌝) uniquely determines one ⌜b⌝ (in ⌜B⌝) (no more, and no less)
02:33:13 <ski> DarkCthulhu : now, i claim than another way to *represent* this ⌜𝔹⋆⌝ is as ⌜ℕ → 𝔹⌝ (the set of functions from natural numbers to booleans)
02:33:18 <DarkCthulhu> okay..
02:34:12 <ski> so, instead of ⌜(b₀,(b₁,(b₂,(b₃,⋯))))⌝, we get a representation like ⌜{(0,b₀),(1,b₁),(2,b₂),(3,b₃),⋯}⌝
02:35:15 <DarkCthulhu> So, turning the level of nesting into a numeric index thingy.
02:36:38 <mr-> (Which does not really help you, if you want uncountably long tuples)
02:37:07 * DarkCthulhu warns of imminent brain explosion
02:37:54 <ski> (which is really then ⌜{{{0},{0,b₀}},{{1},{1,b₁}},{{2},{2,b₂}},{{3},{3,b₃}},⋯}⌝, if we use the Kuratowski representation of pairs, and where ⌜0⌝,⌜1⌝,⌜2⌝,⌜3⌝,⋯ could be defined e.g. as ⌜{}⌝,⌜{{}}⌝,⌜{{{}}}⌝,⌜{{{{}}}}⌝,⋯ (i.e. ⌜{}⌝,⌜{0}⌝,⌜{1}⌝,⌜{2}⌝,⋯) or as ⌜{}⌝,⌜{{}}⌝,⌜{{},{{}}}⌝,⌜{{},{{}},{{},{{}}}}⌝,⋯ (i.e. ⌜{}⌝,⌜{0}⌝,⌜{0,1}⌝,⌜{0,1,2}⌝,⋯))
02:38:28 <ski> DarkCthulhu : the important point is that we manage to "shift" the infinite depth into infinite *width*, by using this function representation
02:39:23 <DarkCthulhu> ski, Yup.. got the "flattening" thing that you did. Is that what we're doing when using that recursive data definition?
02:39:25 <ski> mr- : why not ?
02:39:44 <SwashBuckla> what is the difference between `foldl` and `foldl'` (A strict version of foldl)?
02:40:02 <SwashBuckla> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:foldl
02:40:32 <ski> DarkCthulhu : anyway, most of the time, it doesn't matter than much *which* representation of something we're currently using (as long as we agree about which one it is, in case it matters) -- usually we're only interested in the *properties*, the "essentialness" of whatever concept we're talking about
02:41:20 <ski> DarkCthulhu : now, let me write this stream of booleans as ⌜(b₀,b₁,b₂,b₃,⋯)⌝ while being silent about which particular representation of this we're using
02:41:26 <DarkCthulhu> ski, okay..
02:41:55 <mr-> ski: wouldn't you have to write that as R -> B, and ever higher cardinals?
02:42:14 <ski> DarkCthulhu : it should be obvious that there should be a function that given ⌜b₀⌝ and ⌜(b₁,b₂,b₃,b₄,⋯)⌝ as inputs, computes ⌜(b₀,b₁,b₂,b₃,⋯)⌝
02:42:39 <ski> DarkCthulhu : iow, the function maps ⌜(b₀,(b₁,b₂,b₃,b₄,⋯))⌝ into ⌜(b₀,b₁,b₂,b₃,⋯)⌝
02:42:59 <ski> DarkCthulhu : the details of how to define this function depends on the particular representation of streams we're using
02:43:40 <ski> DarkCthulhu : also, it should be obvious that this function is invertible (iow is a bijection)
02:43:59 <DarkCthulhu> ski, hmm.. okay, a "flatten" function must exist.
02:44:23 <ski> DarkCthulhu : so, this function is a bijection (an isomorphism, one could say) between ⌜𝔹 × 𝔹⋆⌝ and ⌜𝔹⋆⌝
02:44:57 <DarkCthulhu> ski, okay.. following so far
02:44:59 <ski> because this function exists, we say that these two sets are isomorphic : ⌜�⋆ ≅ � × �⋆⌝
02:45:23 <DarkCthulhu> ski, So that is what isomorphic means? It can be transformed between the representations?
02:46:14 <ski> so, while not (in ZF) being able to solve the equation ⌜𝔹⋆ = 𝔹 × 𝔹⋆⌝ (for ⌜𝔹⋆⌝), we *can* solve a corresponding "isomorphism equation", where the two sides aren't claimed to be *equal*, but where we only claim there's an (invertible) *translation* between the two sides
02:47:09 <ski> DarkCthulhu : "isomorphic" means that we can translate between the two with no loss of information, "preserving structure"
02:47:32 <DarkCthulhu> ski, okay.. I see
02:47:41 <ski> (for sets, the "preserving structure" doesn't mean much, apart from the non-loss of information. for other kind of mathematical things "structure" can mean more)
02:48:03 <DarkCthulhu> ski, and that was the difference between data X = MkX ( X -> X) and simply X = X->X ?
02:48:17 <ski> DarkCthulhu : anyway, for `newtype BoolStream = Cons (Bool,BoolStream)', `Cons' is this translation (in one direction)
02:48:26 <DarkCthulhu> right
02:48:37 <ski> the representation is whatever representation the Haskell implementation chooses to use to implement this type
02:48:52 <ski> which might be a representation in terms of pointers (memory addresses), e.g.
02:49:44 <ski> simply `type X = X -> X' means that there must exists a type `X' which is *equal* to `X -> X'
02:50:16 <ski> while `newtype X = MkX (X -> X)' means only that there must exist a type `X' which is *isomorphic* to `X -> X'
02:50:36 <ski> so, an `X' can be converted into a `X -> X', and vice versa (with no loss of information)
02:51:16 <DarkCthulhu> ski, Got it :)
02:51:30 <ski> the detour to ZF set theory here was mostly to explain a bit about representation, and the difference between type equality, and type isomorphism
02:52:07 <DarkCthulhu> I should save this chat log for the brilliant explanations!
02:52:25 <ski> while `newtype BoolStream = Cons (Bool,BoolStream)' could be said to exist in ZF set thory, in the sense of there being a representation solving this "isomorphism equation"
02:53:04 <ski> `newtype X = MkX (X -> X)' is in fact *still* not solvable in ZF set theory, *even* taking into account that we interpret it as an isomorphism rather than an equality
02:53:38 <DarkCthulhu> ski, Hmm
02:53:44 <ski> (btw, for some inscrutable reason, mathematicians often say that a set/type equation holds "on the nose" if it holds as an equality, as opposed to only holding as an isomorphism :)
02:53:58 <DarkCthulhu> haha
02:55:23 <danilo2> edwardk: Hello! Can I have one simpel question regarding Trifecta? Is it possbile to use State monad with Trifecta? There is no definition of MonadState a Parser as far as I know. Am I right?
02:55:29 <DarkCthulhu> ski, I had one more question earlier when it comes to lambda calculus. How is it that we have fixed points for lambda functions like succ x, but when we come to the "equivalent" natural numbers, f(x) = x+1 does not.
02:55:44 <ski> it took the advent of domain theory to be able to solve ⌜X  ≅  X → X⌝ (but then ⌜X⌝ isn't a set, but a "domain", which is a set, plus some extra "structure")
02:57:29 <ski> DarkCthulhu : because the domain ⌜X⌝ solving ⌜X  ≅  X → X⌝ also includes "partial elements", corresponding to non-terminating computations (or ones which sometimes don't terminate, depending on which arguments they're applied to)
02:58:37 <ski> DarkCthulhu : the ⌜Y⌝ combinator computes the least fixed point of a lambda calculus term
02:59:22 <ski> in many cases, ⌜⊥⌝, the "bottom" element (representing "undefined"/"nontermination") is the least fixed point
03:00:09 <DarkCthulhu> ski, Yeah.. but a fixed point doesn't even exist for f(x) = x + 1 right>
03:00:10 <ski> so by including ⌜⊥⌝ as a "value" in our domain, we can say that ⌜Y 1+⌝ denotes ⌜⊥⌝
03:00:56 <danilo2> Hello! Did anyone used trifecta with custom state? I see that the Parser is not a tronsformaer, so does NOT Trifecta support custom state monad?
03:00:58 <ski> DarkCthulhu : in this domain theory setting (denotational semantics), the domain ⌜ℕ⌝ will include all the usual natural numbers, and *also* ⌜⊥⌝ (which every domain includes)
03:01:49 <DarkCthulhu> ski, Ah.. but it doesn't really mean anything? The ⊥? In case of Church numerals, there is no need to introduce an extra such term, why is that
03:02:26 <ski> DarkCthulhu : so, if you compute ⌜f(non-terminating-expression)⌝, the result is a non-terminating computation process, so ⌜⊥⌝ relly is a fixed point for the function denoted by this ⌜f⌝
03:03:22 <DarkCthulhu> ski, hmm.. seems like some mathematical thing that was introduced just to make it fit :)
03:03:50 <ski> (i'm more or less assuming here that ⌜1+⌝ is a strict function. otherwise the domain ⌜ℕ⌝ will include more than the "normal" natural numbers, plus ⌜⊥⌝)
03:04:23 <ski> DarkCthulhu : i suppose you could say domains were introduced to make sense of potentially non-terminating computations, yes
03:04:31 <butyoudonot>  /w 13
03:04:33 <ski> by reifying "non-termination" as a value
03:05:28 <DarkCthulhu> ski, Why does lambda calculus not require a special value of this kind?
03:05:35 <ski> DarkCthulhu : "In case of Church numerals, there is no need to introduce an extra such term, why is that" -- because usually we want our programming languages to support general recursion, and so there are expressible programs that don't terminate
03:05:57 <DarkCthulhu> ski, ah
03:06:11 <ski> DarkCthulhu : if we switched to a total programming language, without the ability to write a non-terminating program, we could forget about ⌜⊥⌝
03:07:11 <ski> (note that such a programming language could still possibly allow one to write server-like programs, as long as the program always (eventually) outputs progress (responses) for each input request)
03:07:50 <ski> DarkCthulhu : "Why does lambda calculus not require a special value of this kind?" -- which version of it ? the untyped one ? the simply typed one ?
03:08:10 <DarkCthulhu> ski, the untyped one
03:08:25 <ski> well, basically it *does* require ⌜⊥⌝
03:08:49 <danilo2> Hello! I'm using Trifecta and I see there is not ParserT monad transformer. Does it mean, I cannot use any monad inside of trifecta? I want just to create monad stack with State inside parser
03:08:55 <ski> you have to distinguish between a term (a program) in the programming language, and the ideal "value", the denotation, that it *denotes*
03:08:56 <DarkCthulhu> ski, So what I get out of applying the y-combinator is ⊥ ?
03:09:11 <ski> (here "value" doesn't mean "term/program reduced to normal form")
03:09:48 <ski> so, while there is no *term* ⌜⊥⌝ in the language, ⌜⊥⌝ exists as a value/*denotation* in the semantics for the language
03:09:58 * hackagebot fpco-api 1.2.0.2 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.2 (MichaelSnoyman)
03:10:07 <ski> DarkCthulhu : "So what I get out of applying the y-combinator is ⊥ ?" -- not always, it depends
03:10:49 <ski> DarkCthulhu : ⌜Y f⌝ denotes ⌜⊥⌝ just in case ⌜f⌝ denotes a strict function
03:10:59 <DarkCthulhu> ski, In case of the successor function - λnfx.f(n f x)
03:11:12 <ski> DarkCthulhu : a strict function ⌜f⌝ is one where ⌜f ⊥⌝ is equal to ⌜⊥⌝
03:11:49 <ski> (note the former ⌜f⌝ here was a term in the language, while the latter ⌜f⌝ was a value/denotation in the semantics)
03:12:17 <DarkCthulhu> argh..
03:13:43 <ski> DarkCthulhu : well, consider ⌜Y (λ n f x. f (n f x)) (λ _ y. y)⌝. this reduces to ⌜λ y. y⌝, which clearly doesn't denote ⌜⊥⌝, and so ⌜Y (λ n f x. f (n f x))⌝ can't denote ⌜⊥⌝ either
03:14:09 <ski> (i'm assuming normal-order reduction rules)
03:14:53 <DarkCthulhu> ski, Hmm.. true. That is not some non-terminating term.
03:14:58 * hackagebot yaml 0.8.9.3 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9.3 (MichaelSnoyman)
03:15:06 <DarkCthulhu> So, it is not ⊥
03:17:03 <DarkCthulhu> ski, My doubt still remains why the natural numbers defined by usual math, and those defined by Church numerals behave differently when it comes to fixed points. I think I'm missing something :(
03:18:41 <ski> DarkCthulhu : because in one case we have a value expressing "nontermination", but in the other we don't
03:20:17 <ski> DarkCthulhu : if you take a simply typed lambda calculus without general recursion, or say System F, it becomes better
03:21:29 <ski> DarkCthulhu : in System F, the type of naturals would be represented by the type ⌜∀ α. (α → α) → (α → α)⌝
03:22:41 <danilo2> Hello! I've asked a while ago question about custom state monads in Trifecta on SO (http://stackoverflow.com/questions/18806586/custom-state-in-trifecta). The problem is, that the answer is incorrect and I just discovered it. Am I right that it is incorrect unless Trifecta provides monad transformer and State is evaluated AFTER parsing? cc:edwardk
03:23:48 <ski> DarkCthulhu : so ⌜Λ α. λ s : α → α. λ z : α. sⁿ z⌝ would be how you generally represent a natural number ⌜n⌝ in this type
03:23:56 <DarkCthulhu> hmm
03:24:36 <DarkCthulhu> ski, I think I've hit saturation at this point. I'll read up and be back later with a clearer picture. :)
03:25:16 <SwashBuckla> what font are you using, ski? I have Deja Vu Sans Mono in my terminal. I think I'm seeing your symbols correctly
03:25:32 <SwashBuckla> it seems to have decent Unicode support
03:25:34 <ski> DarkCthulhu : re "another way to type ⌜λ ω. ω ω⌝ is to use rank-2 types" -- can you figure out how to do this ?
03:26:05 <DarkCthulhu> ski, I looked up the rank2types documentation, but didn't understand it frankly.
03:26:40 <SwashBuckla> Terminus sadly lacks a few of those symbols
03:27:47 <DarkCthulhu> ski, I should be off now, to study and scribble a bit on my whiteboard :D Thank you for your time and explaining all those things!!! See you later.
03:28:15 <ski> SwashBuckla : i'm not quite sure. i'm using the default font used in XTerm (since i'm in XTerm atm), which seems to be specified as `-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso10646-1' currently
03:28:50 <SwashBuckla> that just rolls off the tongue
03:29:00 <ski> DarkCthulhu : rank-2 types means that a function is allowed to take a polymorphic thing as argument
03:29:29 <ski> DarkCthulhu : if arguments of arguments (&c.) are also allowed to be polymorphic, then we have rank-n types
03:31:42 <ski> DarkCthulhu : the point here is that if ⌜ω⌝ in ⌜λ ω. ω ω⌝ is allowed to be polymorphic, then ⌜ω ω⌝ could possibly be well-typed without requiring cyclic types, because the two occurances of ⌜ω⌝ could be assigned different instances of the universal type of ⌜ω⌝
03:33:17 <DarkCthulhu> ski, ohhh.. okay! I get how polymorphic types solve the problem. Each instance would have one of the two types it was supposed to have
03:34:02 <ski> if you really want to, i can show one solution to this, but possibly you want to mull over it for yourself :)
03:34:25 <DarkCthulhu> ski, I doubt I can understand at this time. Too many new things :)
03:35:07 <ski> ok. perhaps some later time we could take it up again, then
03:35:51 <DarkCthulhu> ski, That would be awesome! Are you a Professor or a PhD student? :D
03:36:00 <ski> i'm just a student
03:37:37 <ski> (but i suspect you'll either have to remind me, or we'll have to run into each other again, since i'm not that good at remembering who i've talked about what with)
03:38:48 <DarkCthulhu> ski, Cool.. will find you again and remind you. I can't get this good an explanation out of anyone else ;)
03:39:25 <ski> well .. i think e.g. Cale is usually good at explaining things ;)
03:39:44 <Cale> Thanks! :)
03:41:01 <ski> Cale : and i think you're usually happy to try to do so (as i'm), when you have time and energy for it, right ? ;)
03:41:21 <Cale> yeah
03:44:30 <ski> mr- : sure, what's the problem ?
03:50:34 <jTT> Hi, I am having trouble with Text and utf8 encoding. I am using a fold to go over a Text and try to extract individual elements. I wish to identify whether these are a chinese character. I think though that under this scenario, one chinese character is made up of 3 such elements. My idea was to take an element, get its hexadecimal representation, and see if it lies within the range of chinese characters (all my documents are utf8 encoded). If 
03:50:35 <jTT> could help me out, that would be awesome. Here a gist: https://gist.github.com/jsevo/6903ca023a96ed54c1e0.
03:51:28 <jTT> BAsically, I am not quite sure how foldE from Conduit.Combinators really works
03:51:40 <Darwin226> Hey guys. I have a tree that has leafs like Leaf Float. Is there a way (like an extension maybe) that can save me from typing Leaf 5 and instead just use 5 and let the inferrence try to figure out what I actually mean?
03:55:00 * hackagebot jukebox 0.1 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.1 (NickSmallbone)
04:09:16 <davidturner_> Is (fromIntegral :: Int64 -> Word64) the correct way to convert Int64 to Word64?
04:10:25 <davidturner_> Where for me 'correct' means 'monoid homomorphism for (+)' in the sense that f n1 + f n2 == f (n1 + n2) for all n1, n2 :: Int64, even if the (+) overflows
04:13:06 <DarkCthulhu> ski, I evaluated the normal form of (λy. (λz. x y)) (λx. z) to be (λz. x (λx. z)) . Is this correct?
04:13:32 <pjdelport> davidturner_: I think so.
04:14:19 <pjdelport> Given that underflows / overflows work like taking the modulus to 2^64
04:14:47 <rydgel> @pl \x -> return (abs x)
04:14:48 <lambdabot> return . abs
04:14:51 <ski> DarkCthulhu : yes
04:21:02 <DarkCthulhu> ski, λx. x x, is this in normal form?
04:23:31 <hughfdjackson> :) hey - i'm looking at implementing a simple maths expression parser (e.g. `1 + 3 * 3`)
04:24:15 <hughfdjackson> I've got as far as parsing this as `(1 + 3) * 3`, but rather struggling with setting precedence of * above + using chainl1
04:25:42 <RchrdB> hughfdjackson: are you using Parsec? If so, Text.Parsec.Expr is your friend. http://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec-Expr.html
04:25:47 <lpaste> hughfdjackson pasted “calc-parser.hs” at http://lpaste.net/112521
04:26:00 <hughfdjackson> RchrdB: i am - shamefully, i was trying to avoid using that
04:26:14 <hughfdjackson> :) just because i'm trying to understand how to hand-roll these things
04:26:26 <hughfdjackson> (so i can apply those lessons to non-expression-based problems, if that makes sense)
04:26:36 <ski> DarkCthulhu : yes
04:26:42 <RchrdB> hughfdjackson: from my very vague memory of parsing theory, I think can set precedence, associativity, and so on by encoding them right into the LL(1) grammar, then your Parsec parser is a straightforward encoding of that grammar.
04:26:44 <mr-> ski: I just find it weird that you'd have to have a different construction depending on how large your product is, even though they all have the same universal property.
04:27:03 <RchrdB> s/I think can/I think you/
04:27:28 <hughfdjackson> hrm - maybe i should try writing my grammer out in BNF to see if it illuminates things for me !
04:27:31 <hughfdjackson> good thought :)
04:27:36 <hyPiRion> hughfdjackson: you can naively use bnf, yes
04:27:43 <DarkCthulhu> ski, I can't understand this when it comes to reductions. Why I can't interpret λx. x x as a function λx. x, which is being applied x as an argument
04:27:54 <DarkCthulhu> ski, In that case, it would just evaluate to x itself
04:28:02 <DarkCthulhu> err.. does that not make sense?
04:29:01 <ski> hughfdjackson : can you express a BNF that explicitly expresses the precedence and associativity rules of the operators, removing the ambiguity of the original obvious BNF grammar ?
04:29:13 <RchrdB> hughfdjackson: since, AIUI, Parsec most directly corresponds to LL(*) grammars, with LL(1) being the easiest to encode, it's usually best to start with the BNF.
04:29:36 <ski> mr- : what is the different construction ?
04:30:02 * hackagebot clean-unions 0.1.1 - Open unions without need for Typeable  http://hackage.haskell.org/package/clean-unions-0.1.1 (FumiakiKinoshita)
04:30:24 <hughfdjackson> ski: i think i probably can, with enough chocolate and coffee to hand ;D
04:31:05 <ski> hughfdjackson : depending(?), you'll probably also need to do some manual left-recursion elimination on the grammar
04:31:34 <hughfdjackson> ski: i think that's exactly what i'm missing
04:31:44 <hughfdjackson> i've made versions of the parsec version that make 'sense', but hang
04:31:56 <ski> DarkCthulhu : ⌜λx. x x⌝ by convention parses as ⌜(λ x. (x x))⌝, not as ⌜((λ x. x) x)⌝
04:31:57 <hughfdjackson> :p assuming that's thanks to left recursion without consuming any tokens..
04:32:11 <hyPiRion> hughfdjackson: yeah, you probably got to left factor things
04:32:30 <mr-> ski: finite products you'd model as nested sets, indexed over the natural numbers, you'd use function N -> .., over the real numbers, you'd have R -> ...
04:32:31 <ski> DarkCthulhu : the convention is that scope of ⌜λ x.⌝ over the the body of the abstraction "extends as far right as possible"
04:33:19 <ski> hughfdjackson : *nod*, what hyPiRion is saying
04:33:20 <DarkCthulhu> ski, ahh.. so there is only one way to parse that, and the case I mentioned would occur only if it was (λ x.x) x right?
04:34:03 <chrisdone> ⌜o‿o⌝
04:34:52 <ski> mr- : imho the conclusion is to abandom ZF (or material sets in general) ;P
04:35:06 <ski> DarkCthulhu : yes
04:35:24 <DarkCthulhu> ski, Also, the normal form is said to have been attained if all the arguments have disappeared and there is nothing left to apply?
04:36:09 <ski> DarkCthulhu : yes, basically it's in normal form if it can't be reduced anymore, iow that there is no more redex (reducible (sub)expression) in it
04:36:45 <mr-> ski: I tend to agree. Given that nobody really understands sets..
04:37:12 <ski> DarkCthulhu : however, sometimes one specifies an explicit subset of the redex-free expressions as "normal forms" / "values" (not to be confused with "value" / "denotation" as in denotational semantics, as e.g. domain theory)
04:38:04 <DarkCthulhu> ski, Hmm..
04:38:08 <ski> DarkCthulhu : so that one can have expressions/terms which are redex-free, but still not normal forms. such are usually called "stuck terms", and would normally correspond to run-time errors like `1 + "a"' or `1 / 0'
04:38:58 <DarkCthulhu> ski, ah.. I know of those. They're the ones which do not have an actual rule to proceed and are irreducible but aren't meaningful by themselves either.
04:39:21 <ski> DarkCthulhu : also, sometimes one only counts redices *outside* delaying binders, so that ⌜x (λ y. (λ y. y) x)⌝ would be considered to be in normal form then
04:39:56 <ski> so in this case one would only reduce outside lambda abstractions
04:40:05 <DarkCthulhu> ski, By that same logic, (λy. (λy. y y) (λy. y y)) would be considered to be in normal form already right?
04:40:50 <ski> i think in "normal order reduction" and "applicative order reduction" one reduces inside lambdas, but in "call-by-name reduction" and "call-by-value reduction" one doesn't
04:40:59 <ski> DarkCthulhu : yes
04:42:25 <DarkCthulhu> But (λy. y y) (λy. y y) has no normal form, because it keeps looping and spawning new arguments on which it is possible to repeatedly do β reductions.
04:42:47 <ski> yes
04:42:52 <Trollinator> omega :-)
04:43:59 <DarkCthulhu> What on earth is a delta-reduction O_o
04:44:22 <rydgel> @pl \x -> 2 ^ (length x)
04:44:23 <lambdabot> (2 ^) . length
04:44:55 <ski> yes, which was why i expressed ⌜λy. y y⌝ as ⌜λ ω. ω ω⌝ a bit up :)
04:45:23 <ski>   ω  =  λ ω. ω ω
04:45:30 <ski>   Ω  =  ω ω
04:45:41 <ski> commonly being used as shorthand for these terms
04:46:22 <ski> DarkCthulhu : iirc, it's a reduction for some basic types, like e.g. reducing a subtraction on two literal integers
04:46:51 <DarkCthulhu> ski, Doesn't seem to be a part of pure lambda calculus, which is what I'm dealing with (I think).
04:47:02 <ski> *nod*
04:48:27 <ski> s/integers/integer numerals/
04:49:50 <hughfdjackson> ski, hyPiRion :) cheers
04:50:03 * hackagebot haskell-token-utils 0.0.0.6 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.6 (AlanZimmerman)
04:50:04 <hughfdjackson> doing things the BNF way worked
04:50:11 <ski> hughfdjackson : got it working ?
04:50:15 <hughfdjackson> pity, since chainl1 is pretty
04:50:33 <hughfdjackson> ski: indeed !
04:50:45 <ski> i think `chainl1' fixes the association (presumably to left ?)
04:50:54 <ski> hughfdjackson : care to paste it ?
04:51:32 <hughfdjackson> sure, after a small cleanup :)
04:51:41 <DarkCthulhu> ski, How does someone prove that something is a fixed point operator? I would imagine we take a general function and show that the fixed point operator applied to the function returns the function itself. Is that sufficient to prove?
04:52:25 <ski> DarkCthulhu : yes
04:52:46 <ski> or s/function/value in whatever base set you're talking about/
04:53:11 <DarkCthulhu> okay
04:55:25 <ski> e.g., if we consider `data Nat = Zero | Succ Nat', and ignore all partial elements (i.e. which involve ⌜⊥⌝), but still allow the infinite ⌜Succ (Succ (Succ (⋯)))⌝ element, then this element is a fixed point of ⌜Succ⌝
04:55:31 <lpaste> hughfdjackson pasted “calc.hs” at http://lpaste.net/112522
04:55:48 <hughfdjackson> ski: courtesy of a little google help, too, i'm afraid -.-
04:55:49 <ski> and in this case the values are (total) elements of `Nat', as opposed to *functions*
04:56:04 * hughfdjackson couldn't remember much about LL(k) grammars + BNFs - it's been a while
04:56:11 <ski> hughfdjackson : that's nothing to be ashamed of :)
04:56:15 <davidturner_> pjdelport: Thanks (belatedly - internet issues)
04:56:39 * ski can't recall that much about ⌜LL(k)⌝ grammars
05:00:34 <ski> hughfdjackson : ok. now add subtraction :)
05:01:48 <hughfdjackson> after I factor out those ugly binary operator parsers ;)
05:07:51 <spacekitteh> a question about categories: if you have a CCC, that corresponds to lambda calculus... but if your category /isn't/ closed, does it coresspond to kappa calculus?
05:08:58 <jTT> hi, I have a question about Text. If I use a fold over a text, what are the elements? I.e., if my text contains characters that require 3 bytes, how could I identify those as opposed to ones that require only one byte?
05:09:37 <jTT> specifically, how can i identify a Chinese or a lating character from the bytestring?
05:09:53 <tdammers> Text
05:09:54 <mauke> wait, from the bytestring?
05:09:56 <jTT> the encoding is utf8
05:10:01 <lpaste> hughfdjackson pasted “calc-with-subt.hs” at http://lpaste.net/112523
05:10:04 <mauke> then what does this have to do with Text?
05:10:07 <hughfdjackson> ski: seems to be working :)
05:10:17 <mauke> jTT: what are you trying to do?
05:10:18 <tdammers> Data.Text uses some encoding on the inside (utf-16 IIRC), but it should be transparent
05:10:42 <tdammers> so on the outside, it should conceptually behave like a container of full 32-bit codepoints
05:10:45 <jTT> mauke: I am trying to read an html file, count chinese and non chinese characters.
05:11:14 <danilo2> edwardk: Hello! are you available here? We've got here ap problem regarding trifecta - namely, there is no ParserT transformer, so it is impossible to use State within trifecta?
05:11:16 <hughfdjackson> the only thing that bothers me is that i've resolved this by turning it into a group of right-associative expressions :p
05:11:32 <mauke> jTT: what for?
05:12:04 <hughfdjackson> so I've got a working example, but not actually learnt how to factor left recursion into an BNF-expressed .. form
05:12:28 <jTT> mauke: I am using this as a proxy whether or not the file is a chinese document
05:12:58 <jTT> I am running into a wall with foldlE, a funciton from conduit cominators
05:13:27 <mauke> jTT: ok, so you need to parse and decode html first
05:13:45 <Eduard_Munteanu> Is there a library to help with writing Generic-based instances to bind parsers to data structures, like aeson's FromJSON?
05:14:10 <Eduard_Munteanu> Basically something to handle the Generic / TH aspects.
05:14:49 <jTT> mauke: I have been trying. https://gist.github.com/jsevo/6903ca023a96ed54c1e0
05:15:19 <mauke> jTT: that doesn't look like an html parser
05:15:23 <jTT> mauke: I have been told I could work directly within the conduit
05:15:51 <mauke> also, checking the encoded representation is backwards
05:16:12 <jTT> mauke: ?
05:16:42 <mauke> 4E00 is a codepoint, not bytes
05:16:48 <mauke> > 4E00
05:16:50 <lambdabot>  4.0
05:16:55 <mauke> also, it's a floating point number in haskell
05:17:09 <Fuuzetsu> > 7E2
05:17:11 <lambdabot>  700.0
05:17:23 <Fuuzetsu> oh, I *knew* scientific notation was supported
05:17:29 <Fuuzetsu> it was just big E not small one
05:17:40 <indiagreen> > 7e2
05:17:42 <lambdabot>  700.0
05:17:47 <Fuuzetsu> huh
05:18:45 <jTT> mauke: yeah, that bit is still garbage. Would you know how I can extract the relevant hexadecimal representation from the conduit? The comparsion I can fix after
05:19:04 <Fuuzetsu> I should probably go back a week or so in my log to see what the hell I was thinking but whatever
05:19:31 <mauke> you don't need a hexadecimal representation
05:19:43 <mauke> if you had one, you wouldnt know what to do with it
05:20:04 * hackagebot HaRe 0.7.2.8 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.8 (AlanZimmerman)
05:20:05 <jTT> mauke: I would check if it falls within the range of chinese chars, no?
05:20:11 <mauke> jTT: how?
05:20:32 <jTT> mauke: check if between 4E00-9FFF
05:20:36 <mauke> jTT: how?
05:22:11 <mauke> :t let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese
05:22:12 <lambdabot> Char -> Bool
05:22:28 <mauke> > let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese 'Ä'
05:22:29 <lambdabot>  False
05:24:41 <jTT> let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese ‘维’
05:24:56 <jTT> > let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese ‘维’
05:24:57 <lambdabot>  <hint>:1:205: lexical error at character '\8216'
05:25:40 <mauke> your single quotes aren't single quotes
05:26:12 <jTT> let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese '维'
05:26:25 <jTT> > let isChinese x = inRange ('\x4E00', '\x9FCC') x || inRange ('\x3400', '\x4DB5') x || inRange ('\x20000', '\x2A6DF') x || inRange ('\x2A700', '\x2B734') x || inRange ('\x2B740', '\x2B81D') x in isChinese '维'
05:26:26 <lambdabot>  True
05:26:32 <jTT> sweet
05:26:39 <jTT> what is inRange?
05:26:56 <pharpend> @@ jTT @type inRange
05:26:57 <lambdabot>  jTT Ix a => (a, a) -> a -> Bool
05:27:24 <pharpend> @info Ix
05:27:24 <lambdabot> Ix
05:27:25 <mauke> checks whether a thing is in a range
05:27:30 <mauke> pharpend: there is no @info
05:27:36 <pharpend> damn
05:27:47 * pharpend opens a local terminal in defeat
05:27:49 <mauke> jTT: I'm using it because I'm too lazy to type x >= A && x <= Z
05:28:06 <pharpend> oh it's haskell 98
05:28:14 <chrisdone> @@ foo @echo potato
05:28:14 <lambdabot>  foo echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "chrisdone!~chrisdone@2a01:4f8:150:5307::2", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@@ foo @echo potato"]} target:#haskell rest:"potato"
05:28:16 <tdammers> is there really no library that implements unicode character classes?
05:28:18 <chrisdone> lel
05:28:39 <pharpend> tdammers: well, you could do
05:28:53 <pharpend> @@ tdammers > ['a' .. 'e']
05:28:53 <lambdabot>  tdammers > ['a' .. 'e']
05:29:02 <pharpend> @@ tdammers > elem 'd' ['a' .. 'e']
05:29:02 <lambdabot>  tdammers > elem 'd' ['a' .. 'e']
05:29:10 <pharpend> :t elem
05:29:11 <lambdabot> Eq a => a -> [a] -> Bool
05:29:20 <pharpend> > elem 'd' ['a'..'e']
05:29:22 <lambdabot>  True
05:29:24 <jTT> mauke: ok, i see. but while I can type ’维’, from what I understand when using foldlE on Text is that a chinese character is actually represented by 3 bytes
05:29:33 <mauke> jTT: no
05:30:14 <tdammers> nah, I mean a library that defines some data type for all the various character classes (or planes, or whatever), so you don't have to define them yourselves
05:30:17 <tdammers> *yourself
05:30:40 <mauke> I don't know what foldlE is but Text should represent every character as either 2 or 4 bytes and there should be no way to tell the difference
05:31:06 <jTT> mauke: ok thanks.
05:31:57 <mr-> So in Text you only have "characters"?
05:32:05 <mauke> right
05:32:09 <mauke> like String
05:33:37 <tdammers> as I said, Text is conceptually a container of 32-bit unicode code points ("characters"), the fact that it uses a two-byte encoding on the inside is an implementation detail and should be completely transparent
05:33:45 <tdammers> give or take performance characteristics and a few edge cases
05:33:56 <mauke> (two-/four-byte variable width encoding)
05:34:12 <tdammers> yes
05:38:17 <lpaste> ski annotated “calc.hs” with “how to write a `Show' instance” at http://lpaste.net/112522#a112524
05:39:42 <ski> spacekitteh : "kappa calculus" being ?
05:40:21 <Fuuzetsu> http://en.wikipedia.org/wiki/Kappa_calculus ?
05:44:41 <chrisdone> neat
05:48:25 <centipede> hi
05:55:26 <ski> spacekitteh : perhaps kappa calculus corresponds to cartesian categories (categories with finite categorical products), as opposed to any old non-closed categories .. however, i'm not sure. that WP page mentions "contextually complete categories", which quite possibly is distinct
05:56:03 <ski> <lpaste> ski annotated “calc.hs” with “how to write a `Show' instance” at http://lpaste.net/112522#a112524
05:56:06 <ski> hughfdjackson ^
05:56:20 <ski> hughfdjackson : also, i think you got the wrong associativity for `-' :)
05:57:26 <hughfdjackson> ski: whoa - i really didn't expect anyone to look that deeply into my example
05:57:29 <hughfdjackson> :) reading ! rthanks
05:57:35 <hughfdjackson> s/rthanks/thanks/
05:57:54 <lecoeus> I have a data type taking two arguments and I want to define a ToJSON instance for it. How do I do it with two type arguments?
05:58:32 <Fuuzetsu> instance ToJSON (T a b) where …
05:58:58 <Fuuzetsu> instance (ToJSON a, ToJSON b) => ToJSON (T a b) where … is probably more meaningful
05:59:24 <lecoeus> Fuuzetsu: oh damn you're right
06:00:15 <hughfdjackson> ski: am i being crazy - i didn't know that subtract had a specific associativity
06:00:36 <hughfdjackson> since it's associative ..
06:00:38 <ski> hughfdjackson : well, i only intended to show the better (imo) `Show' instance, but i ended up adding a bit more explanatory comments
06:01:01 <ski> hughfdjackson : `1 - (2 - 3)' isn't equal to `(1 - 2) - 3'
06:01:17 <hughfdjackson> :| oh rats - you're absolutely right
06:01:24 <ski> (in short : `-' is not associative)
06:01:26 <hughfdjackson> i've made that mistake at least 10 times in my life :p
06:01:48 <hughfdjackson> time to get it tattooed somewhere visible
06:06:38 <Fuuzetsu> is there a package exposing something like Agda's _≤_ along with some helpers over it?
06:07:14 <nshepperd> things that aren't associative that you wish were: (-), (/), ($)
06:07:41 <Fuuzetsu> I die a little ever time my code ends up looking like ‘x ∙ (y ∙ z)’
06:16:16 <dawik> hi, can someone point me to a hello world-triangle (or anything) using opengl (and I assume some library for creating the context)?
06:16:20 <simon> I want to map across a Set and convert the result to a list. is it more idiomatic to do those two in separate steps, rather than to fold once?
06:16:27 <ski> hughfdjackson : btw, for related pastes, you might consider *annotating* the earlier paste page with the new paste/update/comment. that makes the new paste appear on the same page, so people don't have to flip around between pages as much. also you can often leave out more context from an annotation, since it's present in earlier ones on the same page
06:17:07 <pjdelport> simon: Probably seperately, but depends on the surrounding program.
06:17:20 <hughfdjackson> ski: ah - brilliant :) new to lpaste
06:17:30 <bartavelle> simon, in particular if you are already using something like lens there is no reason to do it without toListOf
06:17:33 <ski> simon : it would possibly be easier to read it as separate steps
06:18:58 <ski> hughfdjackson : and for completeness, "edit" allows you to make a new revision of a paste/annotation -- i'd suggest only to use this to correct small (unintensional) errors and such -- earlier revisions don't appear on the same page (only the latest does), though you can view them as well
06:19:38 <ski> hughfdjackson : e.g., if someone pastes something, and someone else comments or expands on it in an annotation, and then the original paste is revised, the comment might then look very strange in the new context
06:20:07 * hackagebot Nomyx 0.7.2 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.2 (CorentinDupont)
06:20:12 <ski> (in case the revised version different substantially from the original one, i mean)
06:22:11 <ski> Fuuzetsu : ‘x ∙ (y ∙ z)’ re associativity ?
06:22:16 <Fuuzetsu> yeah
06:24:05 * ski thinks it ought to be possible, in a dependently typed language, to declare to the system that an infix operator is associative (as opposed to left-,right- or non- associative) by providing a proof of associativity
06:24:51 <ski> hm, i suppose this would mean that ‘A ∙ B’ could now unify with ‘x ∙ y ∙ z’ in two ways
06:25:07 * hackagebot Nomyx-Core 0.7.2 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.2 (CorentinDupont)
06:25:09 * hackagebot Nomyx-Web 0.7.2 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.2 (CorentinDupont)
06:25:57 <hughfdjackson> ski: that'd be nice
06:26:35 <hughfdjackson> in idris + Natural numbers, you can provide proofs of associativity.. but it proves to be a bit of a pain to do
06:26:49 <ski> hm, reminds me i should go back and continue pondering mixfix operators
06:27:02 <ski> hughfdjackson : why ?
06:27:04 <hughfdjackson> last I tried (no expert, admittedly), I had to inline the proof in the definition of a funciton that depended on addition
06:27:18 <hughfdjackson> rather than the compiler finding the proof 'in scope' and using it
06:27:23 <hughfdjackson> (function
06:27:26 <hughfdjackson> *function
06:27:34 <ski> hm
06:27:58 <ski> i was thinking of (possibly) naming the associativity proof in question
06:28:14 <hughfdjackson> 'inlining the proof' is the wrong thing to say - i had to explicitly apply the proof that i'd written elsewhere in the file inside my function definition
06:28:20 <hughfdjackson> lemmie see if i still have those pastes anywhere..
06:28:56 <hughfdjackson> hrm - can't find the working one
06:29:03 <hughfdjackson> i can find all my lame attempts though: https://gist.github.com/hughfdjackson/0b66eec359f0a629925b
06:29:05 <hughfdjackson> :p
06:29:32 <hughfdjackson> https://github.com/idris-lang/Idris-dev/blob/master/libs/prelude/Prelude/Vect.idr#L143-L149 <- here's the official version of that reverse
06:30:31 <aloiscochard> how you folks define "purely functional"?
06:30:31 <hughfdjackson> which uses plusSuccRightSucc, which I think is the same as saying succession `plus m (S n)` can be unified with `S (plus m n)`
06:31:05 <hughfdjackson> aloiscochard: a function produces the same output for the same input every time, and *only* returns an output
06:31:20 <aloiscochard> hughfdjackson: that's referential transparency, innit?
06:31:31 <ski> @where purely-functional
06:31:31 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
06:31:35 <ski> aloiscochard ^
06:31:35 <chrisdone> that's an overloaded term
06:31:38 <aloiscochard> ski: ty!
06:32:07 <aloiscochard> chrisdone: sure, I was looking for how people in this room feel about it. As I thought about using the term, I should probably be careful with it.
06:32:09 <hughfdjackson> aloiscochard: i guess it is
06:32:18 <hughfdjackson> chrisdone: which is overloaded?
06:32:22 <hughfdjackson> purely functional?
06:32:25 <chrisdone> referential transparency
06:32:29 <hughfdjackson> ah :)
06:32:33 <aloiscochard> oh :)
06:32:49 <hughfdjackson> chrisdone, ski: would you agree with the definition i gave above for purely functional?
06:33:01 <chrisdone> sure
06:35:41 <ski> aloiscochard : also see "Referential Transparency, Definiteness and Unfoldability" by Harald Søndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf>, and also check out Uday Reddy's answers at <http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966>
06:37:24 <aloiscochard> ski: thanks so much, I'm preparing a talk that will help a lot having the right concepts/terms!
06:37:40 <ski> aloiscochard : also chrisdone is right, people have used the term "purely functional" for subtly different things. Sabry's article is one attempt to bring some order into this mess
06:37:57 <aloiscochard> I had that feeling too
06:39:23 <ski> aloiscochard : "referential transparency", otoh, has a clear meaning (coming from philosophy of language), but unfortunately people have begun bringing the current mess of "purely functional" into "referential transparency" as well. please attempt to only use the latter term in its originally intended sense (or maybe reasonable extensions of it, if people can agree on any such)
06:42:02 <ski> hughfdjackson : your suggestion could possibly be read as excluding procedures that transmit output through some other channel (such as mutation of an external mutable cell, or output into an OS stream) than their return value
06:42:23 <albeit> I want to keep track of threads I create with forkIO in a data structure (list/map), and then when the thread completes remove it from that data structure. How can I do that? As far as I know, forkIO provides a threadId, but the returning thread doesn't know its own threadId...
06:44:20 <ski> hughfdjackson : but it doesn't seem to exclude procedures that (only) *depend* on the current value of some external mutable cell, or which accepts input from some other source than its formal (input) parameters, like OS input, or input from another thread/process (but not counting merely input from the environment in which the procedure is defined)
06:44:40 <mauke> :t \f -> mfix (forkIO . f)
06:44:41 <lambdabot> Not in scope: ‘forkIO’
06:45:49 <hughfdjackson> ski: 'same output every time' <- doesn't that imply that you're not dependent on global mutable state
06:46:53 <hughfdjackson> i guess if it does, then it's not implying it very strongly :)
06:47:15 <hughfdjackson> unsurprisingly, my ad-hoc definition needs some work ;)
06:49:03 <ski> hughfdjackson : aside, one name for `flip go' that i've seen used in the Craft is `shunt'
06:49:13 <chrisdone> probably it's a matter of the scope of your specification
06:49:46 <chrisdone> a complete description of simply typed lambda calculus can be given without mentioning effects, operating systems or time
06:49:54 <hughfdjackson> chrisdone: good point
06:49:58 <hughfdjackson> ski: flip go?
06:50:11 <chrisdone> so in that sense "f x is always the same for the same x" is a complete description
06:50:15 <DarkCthulhu> lambda calculus anyone?
06:50:26 <ski> hughfdjackson : for your vector `reverse'
06:52:06 <ski> hughfdjackson : hm, mea culpa, when writing that part, i apparently forgot the "every time" part :/
06:52:09 <chrisdone> it's fun to consider a pure language with an external notion of time but not an internal one. i wonder whether such a thing could be useful
06:52:26 * ski peers curiously at DarkCthulhu
06:52:44 <albeit> Do ThreadId's have any properties (such as always increasing), or should I consider them effectively random?
06:52:47 <chrisdone> i.e. eval (\x -> sleep (if even x sleep 10 else sleep 5))
06:52:56 <Fuuzetsu> > (maxBound :: Double) + 1
06:52:58 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
06:52:58 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
06:53:04 <chrisdone> ^ has external effect of time, but internally has no way of observing passage of time
06:53:24 <dfeuer> chrisdone, of course that exists...
06:53:35 <ski> chrisdone : which number does `sleep 10' return ?
06:53:51 <chrisdone> ski: it returns () =)
06:53:54 <dfeuer> But it's not very useful.
06:54:09 <ski> chrisdone : then you have a type error (apart from the typo, i mean ;)
06:54:12 <chrisdone> dfeuer: maybe it would be useful if you needed a system that would perform delays =p
06:54:25 <chrisdone> ski: oh, woops
06:54:38 <chrisdone> eval (\x -> sleep (if even x then 10 else 5))
06:54:39 <chrisdone> =)
06:54:45 <dfeuer> chrisdone, I guess the real challenge is coming up with an appropriate temporal semantics for it.
06:54:52 <dfeuer> Which would have to be woven all through everything.
06:54:55 <dfeuer> It would be awful.
06:55:26 <chrisdone> hmm maybe it could be typed
06:55:27 <DarkCthulhu> ski, If you remember from earlier, I was asking about the normal form of (λy. (λz . x y)) (λx.z). I realized just now that simply substituting for y is not sufficient and that I'd have to rename the variables in (λx.z) first. But it's a little confusing, because I don't know whether to rename both, or just the x.
06:55:31 <dfeuer> You can get something like it using unsafePerformIO, of course.
06:55:41 <dfeuer> But yechhhh
06:56:08 <ski> hm, i remember reading a paper which talked about "algorithms" (iirc) for computing the value of an expression, these being (laxly) increasing sequences of the domain in question
06:56:17 <ski> can't recall what it was named, though
06:56:34 <ski> iirc, it was related to comonads, somehow
06:58:05 <nshepperd> chrisdone: in a nonlazy language, you can let "sleep n = busyloop [1..n]" :D
06:58:21 <chrisdone> dfeuer: i think sleep n = unsafePerformIO (threadDelay n), is equivalent to sleep n = () in haskell, semantically
06:58:57 <chrisdone> nshepperd: sure =)
06:59:06 <nshepperd> but, I'm not sure how useful it is to be able to perform delays without also to measure how much time is passed
06:59:14 <dfeuer> chrisdone, yeah, Haskell doesn't really guarantee anything in particular about that. And yes, you can do the same thing with a busy-loop in Haskell, with the same problems.
06:59:20 <chrisdone> well, you can measure it externaly, just not within the language
06:59:27 <ski> DarkCthulhu : hm, sorry, i missed the inadvertent capture. i'd only rename the ⌜z⌝ in ⌜λz. x y⌝, though
07:00:03 <DarkCthulhu> ski, Aren't the x's also different?
07:00:23 <nshepperd> I mean that most applications of delay logic are not great without a feedback loop
07:00:47 <nshepperd> due to nondeterministicness of scheduling, etc
07:01:20 <chrisdone> #partypoopershq
07:01:25 <ski> DarkCthulhu : yes, but it doesn't matter, since no free occurence of ⌜x⌝ in the substituted-for term would come inside the scope of a binding occurance of ⌜x⌝ in the substituted-in term, as a result of the substitution
07:01:37 <nshepperd> the exception would be a RTOS, I guess, with a language having very well specified execution times
07:02:18 <nshepperd> in which case you can sure do everything with dead reckoning!
07:02:25 <albeit> When I call forkFinally, is the "finally" function called in the child thread or the main thread?
07:02:31 <ski> DarkCthulhu : in any case, you can only rename locally bound variables (by ⌜α⌝-conversion), so you can't rename ⌜x⌝ in ⌜λy. (λz. x y)⌝ or ⌜z⌝ in ⌜λx.z⌝ anyway
07:03:37 <ski> (nshepperd : also, possibly you mean s/nonlazy/strict/ :)
07:06:45 <chrisdone> refl. that's what i want in haskell
07:07:29 <vanila> data Equal :: * -> * -> * where Refl :: Equal a a ?
07:08:53 <chrisdone> data X a where X :: X a
07:08:54 <chrisdone> conv :: X a -> X p
07:08:54 <chrisdone> conv X = X
07:08:59 <chrisdone> instead of X here, i'd like to write
07:09:05 <chrisdone> conv = refl
07:09:21 <ski> hughfdjackson : oh, you changed the return type from `Vect (m+n) a' to `Vect (n+m) a'
07:09:29 <vanila> safeCoerce :: Equal a b -> a -> b
07:09:34 <vanila> safeCoerce Refl x = x
07:10:36 <oconnore> Hey, what is the best way to get documentation for a haskell module?
07:10:44 <oconnore> For example, I have a list of modules -> http://hackage.haskell.org/package/text
07:11:02 <oconnore> but no documentation
07:11:25 <ski> chrisdone : hm .. i some time ago pondered an extension that would allow one to write `(>>=) :: Either e a -> (a -> Either e b) -> Either e b; Right a >>= k = k a; m      >>= _ = m'
07:12:52 <ski> chrisdone : basically, because `Left :: forall e a. e -> Either e a' doesn't use `a' in the component types, `m' would get assigned the type `forall a. Either e a' in the second case, instead of `Either e a'
07:12:55 <geekosaur> oconnore, documentation building is known to be broken, they're working on it; meanwhile there's a switch in ~/.cabal/config that can build documentation on installation
07:13:44 <chrisdone> ski: interesting
07:14:24 <oconnore> geekosaur: ah. Is there a guide on how to do that?
07:15:11 <ski> (a small variant of this would require the second case to be declared as `m @ (Left _) >>= _ = m' or `m @ Left {} >>= _ = m', emphasizing more that this is because of the type of `Left' -- but this wouldn't work when we want to handle multiple remaining cases in the same way -- the advantage is that this could be read more order-independently)
07:17:31 <chrisdone> ski: indeed, actually i similarly would like that
07:17:32 <chrisdone> e.g. …
07:17:39 <Fuuzetsu> what the fuck
07:17:42 <Fuuzetsu> since when can I say
07:17:43 <Fuuzetsu> compRel ∷ (b ~ a) ⇒ a → b → Relation (compare a b) a
07:17:59 <chrisdone> dirty :: E Clean a -> E Dirty a
07:18:00 <chrisdone> dirty (A op x) = A (dirty op) (dirty x)
07:18:01 <chrisdone> dirty (C i) = C i
07:18:06 <chrisdone> i could instead write: dirty e = e
07:18:14 <chrisdone> or, refl e
07:18:16 <chrisdone> or something
07:18:38 <ski> chrisdone : hm .. i suppose one could perhaps justify this with an argument that `Left' can (generally) be assigned the type `forall e. e -> forall a. Either e a', so we only need to "eliminate" the `forall e.' and the `e ->' part in the pattern-matching in the `Left' case, and so the whole pattern will have type `forall a. Either e a'
07:19:02 <chrisdone> obviously i'd need some way to indicate that they're representationally equivalent and not nominally (but that's ok)
07:19:49 <ski> chrisdone : where `a' is phantom, right ?
07:19:52 <chrisdone> right
07:20:10 * hackagebot SConfig 0.1.0.0 - A simple config library  http://hackage.haskell.org/package/SConfig-0.1.0.0 (fgaz)
07:20:25 <chrisdone> (and so is Clean/Dirty)
07:20:53 <ski> hm, the "handle multiple remaining cases" could be done with disjunctive patterns (which GHC doesn't have) -- though you'd still need to enumerate all the remaining data constructors
07:20:54 <chrisdone> i suppose technically the phantom 'a' doesn't matter because they're asserted equal in the type-sig
07:21:05 <ski> so, something like
07:21:06 <chrisdone> hmm like in ocaml?
07:21:18 <ski>   dirty e@(A {} | C {}) = e
07:21:22 <chrisdone> right
07:21:30 <ski> if we temporarily assume that `|' is disjunctive pattern
07:21:47 <ski> hmm
07:22:03 <ski> the question is whether this would work recursively for `op' and `x' -- i suspect not
07:22:09 <DarkCthulhu> ski, I understand what you meant now about the alpha conversion. You're right; it would require renaming the z on the left side expression only.
07:22:18 <hughfdjackson> ski: yea, changing the return type was the only reasonable thing to do, when faced with the limitation on idris' proverator
07:22:45 <ski> or .. at least not in the small extension i was envisaging
07:23:21 <chrisdone> dirty e@C{} = e itself doesn't work in regular haskell
07:23:29 <chrisdone> (obviously, but yeah)
07:23:45 <vanila> dirty :: E Clean a -> E Dirty a
07:23:49 <vanila> dirty = unsafeCoerce
07:24:05 <chrisdone> vanila: yeah, that's what i wrote originally. but unsafeCoerce is nasty because it'll accept anything
07:24:20 <vanila> Yeah so the direct recursion is best
07:24:23 <chrisdone> move it slightly to the wrong place and it'll still probably typecheck and eat your young
07:24:35 <chrisdone> whereas a well-typed refl would be good
07:25:10 * hackagebot orgmode-parse 0.0.1.2 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.1.2 (ParnellSpringmeyer)
07:25:13 <chrisdone> dirty :: E Clean a -> E Dirty a
07:25:13 <chrisdone> dirty = refl
07:25:13 <chrisdone> ^ this could be accepted, but refl :: Int -> Char would be a type error
07:25:34 * chrisdone should finish watching SPJ's talk on roles
07:25:38 <vanila> How is refl different from unsafeCoerce?
07:26:05 <vanila> well, I really mean - how is it typechecked
07:26:06 <chrisdone> refl will only accept if the two things are actually equal (for some definition of equal)
07:26:26 <chrisdone> e.g.
07:26:50 <chrisdone> data Foo a = Foo a  -- Foo a /= Foo b
07:26:54 <ddellacosta_> what am I not getting about how this works?  [0..2] ++ [2..0] = [0,1,2]  whereas [0,1,2] ++ [2,1,0] = [0,1,2,2,1,0]
07:27:02 <chrisdone> whereas data Bar a = Bar  -- Bar a == Bar b
07:27:10 <ddellacosta_> additionally, [0..2] ++ [0..2] = [0,1,2,0,1,2]
07:27:13 <chrisdone> (for our definition of equality)
07:27:14 <vanila> I understand
07:27:20 <chrisdone> http://eb.host.cs.st-andrews.ac.uk/Idris/theorems.html
07:27:27 <bartavelle> ddellacosta_, [a..b] doesn't desugars to what you think it does
07:27:51 <vanila> Maybe you can write a 'Proof' Equal (E Clean a) (E Dirty a)
07:27:59 <vanila> and then use safeCoerce
07:28:11 <bartavelle> > [0..2]
07:28:12 <lambdabot>  [0,1,2]
07:28:14 <bartavelle> > [2..0]
07:28:16 <lambdabot>  []
07:28:16 <ski> Fuuzetsu : since `UnicodeSyntax',`TypeFamilies' (for `~') and `DataKinds' ?
07:28:25 <ddellacosta_> er
07:28:32 <ddellacosta_> well then
07:28:42 <ski> ddellacosta_ : right
07:28:45 <ski> er
07:28:47 <ski> DarkCthulhu : right
07:28:48 <vanila> e.g. I can write  barProof :: Equal (Bar a) (Bar b)  but I can't implement Equal (Foo a) (Foo b)
07:28:49 <ddellacosta_> dunno why I didn't try that first, thanks bartavelle!
07:28:56 <bartavelle> np ;)
07:29:11 <J_Arcane> > [3,2..0]
07:29:13 <lambdabot>  [3,2,1,0]
07:29:13 <ski> hughfdjackson : what was the limitation ?
07:29:28 <J_Arcane> When going the other direction, you have to give it a little hint. :)
07:29:49 <ddellacosta_> J_Arcane: huh, okay, need to go read about what is going on there exactly. I don't find that intuitive at all
07:29:50 <hughfdjackson> ski: that it couldn't otherwise automatically unify the expected type and the declared type
07:29:56 <Fuuzetsu> ski: unfortunately I think it doesn't do what I would like it to do anyway ;;
07:30:11 * hackagebot prizm 0.3.1.2 - Compute with colors and differenct color spaces  http://hackage.haskell.org/package/prizm-0.3.1.2 (ParnellSpringmeyer)
07:30:13 * hackagebot jukebox 0.1.1 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.1.1 (NickSmallbone)
07:30:15 * hackagebot pub 2.0.2 - Pipe stdin to a redis pub/sub channel  http://hackage.haskell.org/package/pub-2.0.2 (ParnellSpringmeyer)
07:30:15 <hughfdjackson> :) i.e. you'd have to use proofs with rewrites
07:30:30 <J_Arcane> ddellacosta_: I'm finding Learn You a Haskell most helpful on the basics. :)
07:30:30 <hughfdjackson> oh, i may be thinking of a different example :/ sorry - slightly distracted atm
07:30:40 <hughfdjackson> ;) colleagues asking me questions on my day off
07:31:06 <deni> can anyone point me to an example of a bounded integer (ina dependently typed way i mean, ie. only values from 1 to 10)?
07:31:18 <ddellacosta_> J_Arcane: yeah, I'm kind of cheating by futzing about and then asking the smart folks here when I'm confused. :-)
07:31:23 <deni> I'm having trouble wrapping my around the "smart constuctor" method
07:32:09 * ddellacosta_ goes off to read about how ranges in Haskell *actually* work
07:32:14 <J_Arcane> ddellacosta_: if that's your preferred way of learning (it's kinda mine too), you could try the NICTA course: https://github.com/NICTA/course
07:32:17 <deni> Specifically i'm trying to do an example with non-negative numbers like so: http://dpaste.com/2F5HV25
07:32:24 <bartavelle> ddellacosta_, look at the commentairies of "enumFromTo" and co.  http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Enum
07:32:24 <deni> but this isn't working for some reason...
07:33:16 <pjdelport> deni: That looks roughly right. As a tip, you can use a newtype instead of a "data" type for that kind of declaration.
07:33:28 <ddellacosta_> bartavelle: ah cool, that's what I am looking for. J_Arcane, that's on my list, but right now I'm actually going through this which I am loving: https://github.com/opqdonut/haskell-exercises
07:33:29 <pjdelport> deni: Then your MyInt type carries no run-time overhead over Int.
07:33:53 <deni> pjdelport: well it compiles yes...but i try it out like so: http://dpaste.com/31BWKTA
07:33:56 <pjdelport> deni: With a newtype, you can also enable GeneralizedNewtypeDeriving, which lets you derive Num without having to re-declare it like that.
07:34:02 <deni> pjdelport: and for one thing it let's me pass in normaln ints to the function
07:34:09 <ski> chrisdone : getting hold of a coercion of kind `forall cd0 cd1 a. E cd0 a :=: E cd1 a', a la <https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC>,<https://ghc.haskell.org/trac/ghc/wiki/IntermediateTypes> would work, i think
07:34:12 <pjdelport> (Then, Haskell just uses Int's Num instance for your MyInt type.)
07:34:20 <deni> pjdelport: and another thing is that it doesn't work for the value 100 for instance....
07:35:11 * hackagebot snaplet-amqp 1.0.1.2 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-1.0.1.2 (ParnellSpringmeyer)
07:35:13 * hackagebot snaplet-mandrill 0.1.0.3 - Snap framework snaplet for the Mandrill API library.  http://hackage.haskell.org/package/snaplet-mandrill-0.1.0.3 (ParnellSpringmeyer)
07:35:13 <J_Arcane> ddellacosta_: Cool! I am not sure I've seen that one; wonder if it would work on Windows. I have make via mingw32, and a couple different *nix shell options.
07:35:15 * hackagebot snaplet-influxdb 1.0.0.3 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.0.3 (ParnellSpringmeyer)
07:35:41 <pjdelport> deni: You might want your fromInteger implementation do that range check.
07:35:59 <pjdelport> Otherwise, integer literals will just get wrapped in MI without checking.
07:36:45 <ddellacosta_> J_Arcane: ah, I dunno, good question. But I pinged opqdonut on here once before when I was having an issue, and s/he fixed it up right quick, was super helpful. So it's worth trying to see if it works on Windows, I suppose, and asking if you have problems
07:37:08 <J_Arcane> Cool. I might check that out.
07:37:38 <deni> pjdelport: i don't get how the compiler allows me to just pass in int literals? this is special case with literals i assume
07:37:39 <ddellacosta_> oh, I guess he's a dude
07:37:42 <ski> hughfdjackson : .. but you already used a proof with `rewrite', afaics ?
07:37:55 <deni> pjdelport: because the type sig of the function clearly states what it wants
07:38:08 <deni> pjdelport: also still unsure why factorial 100 return 0 XD
07:38:40 <pjdelport> deni: All integer literals in Haskell just compile to applications of fromInteger. The actual type's fromInteger implementation determines how the literal will be interpreted. :)
07:38:47 <geekosaur> deni: numeric literals are special cased, yes; if it looks ike an integer it's wrapped in fromIntegral and if it looks like it has decimal places it's wrapped in fromRational
07:38:52 <pjdelport> > 5 :: Integer
07:38:54 <lambdabot>  5
07:38:56 <pjdelport> > 5 :: Rational
07:38:57 <lambdabot>  5 % 1
07:39:01 <pjdelport> > 5 :: Double
07:39:02 <lambdabot>  5.0
07:39:04 <pjdelport> etc.
07:39:07 <geekosaur> :t 1
07:39:08 <lambdabot> Num a => a
07:39:37 <ski> deni : `fromInteger' would have to abort
07:39:53 <deni> pjdelport: so i need the check in 2 places...in fromInteger and in mkMyInt? or can I export the MyInt data constructor now?
07:39:57 <deni> *confused*
07:40:24 <ski> pjdelport : a literal like `4' is short for `fromInteger (4 :: Integer)', where obviously `4 :: Integer' isn't interpreted in the same way (since that'd loop)
07:40:30 <ski> er
07:40:33 <ski> deni ^
07:41:19 <ski> deni : you could possibly call `mkMyInt' in `fromInteger' (checking for `Nothing' and aborting, in case the former used `Maybe')
07:41:21 <pjdelport> deni: You can define MyInt's fromInteger to call mkMyInt.
07:41:38 <pjdelport> deni: Then, using an invalid integer literal for it will result in an exception.
07:42:00 <centipede> > sum [1..10]
07:42:01 <lambdabot>  55
07:42:04 <geekosaur> > factorial 100 :: Int
07:42:05 <lambdabot>  Not in scope: ‘factorial’
07:42:10 <geekosaur> derp
07:42:15 <ski> deni : "why factorial 100 return 0" .. perhaps `Int' overflow ?
07:42:21 <geekosaur> anyway consider that you are hitting an overflow condition
07:42:42 <geekosaur> Int is a machine word, Integer can get ~ as large as available memory
07:46:12 <deni> geekosaur: ski pjdelport ok got it....calling mkMyInt in fromInteger...
07:46:18 <deni> but i think i'm hitting a loop or something
07:46:34 <deni> this is the code: http://dpaste.com/1TWPMB3
07:46:43 <deni> isn't the error call in mkMyInteger enough?
07:47:21 <deni> i need more coffee :D
07:48:04 <ski> deni : "or can I export the MyInt data constructor now?" -- no
07:49:32 <deni> ski: it got complicated because a chose an example with literals....the basic principle of exporting smart constructor function instead of the actual constructor i get
07:49:50 <deni> the overflow i resolved by switching to integers entirely
07:50:07 <deni> what's left now is the non-termination in my fromInteger impelementation
07:50:31 <ski> deni : if we had an extension like the "Private variant and record types" in OCaml at <http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec221>, then using it, you could safely expose `MkInt'/`MI'
07:51:18 <deni> isn't that kinda the same thing? making it private/not exporting it?
07:51:29 <ski> this would make the "subtype" aspect of abstract data types more easy to use
07:51:40 <nshepperd> oh, Int and Word and such all have zero dividers, since the modulus is not a prime number but a power of 2
07:51:51 <nshepperd> no wonder
07:51:58 <ski> deni : yes, but this extension allows you to *match* (in another module) on the exported data constructor, but not to call it in an expression
07:52:14 <nshepperd> especially, 2 is sucha zero divider
07:52:31 <deni> ski: wow that sounds very usefull
07:52:32 <phaazon> how would you inverse a quaternion using linear; meaning, a rotation around v of φ angle is turned into a rotation around v of -φ
07:52:39 <phaazon> recip? doesn’t seem to work
07:52:55 <nshepperd> > product (replicate 32 2) :: Word32
07:52:56 <deni> ski: any idea why in my example factorial (-1) isn't terminating?
07:52:57 <lambdabot>  0
07:53:03 <vanila> phaazon, 1/q should work
07:53:19 <vanila> since that's the quaternion that, multiplied with q, gives the identity
07:53:21 <nshepperd> which means that any sufficiently big product will eventually end up at 0
07:53:29 <ski> however, for the "quotient type" aspect of abstract data types, one would need another extension (Mercury has something like that at <https://www.mercurylang.org/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html#User_002ddefined-equality-and-comparison>)
07:53:37 <phaazon> vanila: it does
07:53:43 <phaazon> why recip doesn’t?
07:53:57 <phaazon> rotate (1 / q) v ≠ rotate (recip q) v
07:54:34 <ski> deni : i missed your definition of `factorial' ?
07:55:05 <deni> ski: btw this is the last example: http://dpaste.com/3JN33GP and http://dpaste.com/3MGJGZB
07:55:23 <phaazon> hmm
07:55:35 <phaazon> I guess recip performs… well, no, I don’t know
07:55:38 <phaazon> this might be a bug
07:55:47 <deni> ski: so if i use the smart constructor directly then it's fine....but if i use a literal that it doesn't terminate
07:56:04 <albeit> I'm getting a spaceleak with this code http://lpaste.net/112526... when I profile with "-hy", IntMap and Key are exploding in size. Why is that? If I print out the size of the IntMap, it's never larger than three items.
07:56:46 <ski> deni : hm, `(-1) :: MyInteger' ought to above, doesn't it ?
07:56:59 <ski> (btw, i think `Natural' would be a more reasonable name for `MyInteger')
07:57:12 <deni> ski: nope
07:57:31 <deni> ski: I agree about the naming....it's just for thingering atm
07:58:11 <deni> ski: the "nope" was for the no (-1) :: MyInteger doesn't error
07:58:20 <deni> ski: it just returns MI (-1)
07:58:46 <phaazon> ok…
07:58:46 <phaazon>   recip q = q ^/ quadrance q
07:58:52 <phaazon> what does that even mean
07:58:57 <phaazon> quadrance?
08:00:09 <phaazon> oh
08:00:09 <albeit> phaazon: http://en.wikipedia.org/wiki/Rational_trigonometry#Quadrance ?
08:00:13 * hackagebot pipes 4.1.3 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.3 (GabrielGonzalez)
08:00:16 <phaazon> quadrance is distance²
08:00:16 <phaazon> ok
08:00:40 <phaazon> I still don’t get why the reciprocal of a quaternion is defined this way
08:00:52 <phaazon> isn’t recip supposed to be “inverse”?
08:01:09 <phaazon> meaning, x * recip x = 1
08:01:43 <danilo2> edwardk: Hello! Are you here maybe? :)
08:01:52 <deni> ski: I'm really puzzled by this. Any ideas?
08:02:51 <nshepperd> that does seem like a questionable definition of 'recip'
08:03:00 <edwardk> danilo2: off and on
08:03:29 <nshepperd> it looks like "quarternion with 'same direction' but inverted magnitude"
08:03:32 <danilo2> edwardk: Ok, but a really small question. In Trifecta there is no ParserT transformer - are we able to use State monad with trifecta?
08:03:45 <pjdelport> deni: Hmm, maybe implement negate?
08:03:52 <edwardk> danilo2: you can StateT the Parser type
08:04:06 <danilo2> edwardk: I need to generate unique ID's and State have to be "under" monad, not over the trifecta's one.
08:04:06 <edwardk> danilo2: it rather deliberately avoids working as a transformer though
08:04:14 <danilo2> edwardk: It does not work
08:04:23 <pjdelport> deni: I seem to recall that a negative literal like "(-1)" actually desugars to "negate (fromIntegral 1)"
08:04:28 <pjdelport> (in GHC, at least)
08:04:42 <danilo2> If I've got StateT s Parser ... then I get the same IDs generated sometimes (which is obvious I think)
08:05:06 <edwardk> how are you transferring information about those IDs out of the parser though?
08:05:22 <edwardk> sure they can be redundantly generated but no information can leak between worlds where they disagree
08:05:24 * dfeuer offers edwardk some smoked salmon.
08:05:41 <danilo2> edwardk: Parser is building AST. each AST node has an unique ID obtained simply by "get , +1, put"
08:05:51 <edwardk> danilo2: sure
08:06:18 <edwardk> danilo2: my point is you may generate the same id in different parsing alternatives, but if you do and throw that alternative away you back up to where you are getting a fresh id
08:06:24 <deni> pjdelport: yep that was it. tnx
08:06:30 <edwardk> the 'overlapping id's never get seen
08:06:35 <danilo2> edwardk: I see what you are talking about, but no, it doesnt work that way. I had to move back today over parsec and it works. (only changing the order of calling parsing and runState)
08:06:40 <dfeuer> pjdelport, deni, that is the standard. GHC offers negative literals with a special LANGUAGE pragma.
08:06:50 <pjdelport> Ah, yes.
08:06:53 <edwardk> that is because parsec has an illegal internal state that doesn't backtrack
08:07:00 <edwardk> which violates its claim to be a monad =)
08:07:02 <dfeuer> The absence of negative literals in the standard is rather strange.
08:07:17 <tdammers> edwardk: or its claim to truly backtrack, right?
08:07:30 <edwardk> tdammers: well, parsec breaks monad laws in several places, this is just one
08:07:55 <danilo2> edwardk: anyway, do you have idea how can I do it with trifecta? I really am not using anything than just get and put and incrementing the ids - with only one function
08:08:15 <edwardk> danilo2: i don't yet understand why the backtracking ID generation doesn't work for you
08:08:56 <danilo2> I do not understand it either. Whan can I do to inspect it ?
08:09:10 <deni> dfeuer: what's the pragma?
08:09:12 <edwardk> danilo2: good question, its your code =)
08:09:58 <danilo2> edwardk: Eh, anyway - its not pure, because we can loose a lot of IDs this way, am I right? So it would be better to have internal state
08:10:00 <dfeuer> deni, it's NegativeLiterals
08:10:08 <deni> dfeuer: tnx
08:10:22 <edwardk> danilo2: actually the thing is the way i propose avoids leaking any IDs at all
08:10:28 <dfeuer> deni, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
08:10:48 <danilo2> edwardk: You mean running on the beginning state and then parsing ?
08:11:00 <edwardk> danilo2: i mean StateT Int Parser ...
08:11:27 <edwardk> and having your parser actions grab an id with x <- id <+= 1
08:11:28 <danilo2> edwardk: hmm, interesting - I got exactly that one with the same ids.
08:11:28 <edwardk> or something
08:11:29 <Denommus> hm, I'm trying to use haskell-interactive-mode, but it doesn't recognize the packages installed on my sandbox
08:11:51 <edwardk> note the pun on id there ;)
08:12:04 <danilo2> edwardk: you mean x <- get ?
08:12:17 <edwardk> danilo2: you should never be able to generate a syntax tree that has repeated IDs in it
08:12:25 <edwardk> not with just that monotonic progress
08:12:32 <edwardk> because you can't 'see' the backtracked branch's result
08:12:49 <danilo2> edwardk: hmm, that is very interesting
08:12:52 <edwardk> i used id <+= 1  -- to both read, increment and replace in one action
08:13:04 <danilo2> edwardk: I'm going to debug it and see whats happeniong there in such case
08:13:32 <danilo2> edwardk: oh nice, but it is the same as "id <-get; put (id + 1)" ?
08:13:38 <edwardk> danilo2: yes
08:13:48 <edwardk> well
08:13:51 <edwardk> that one prebumps
08:13:54 <edwardk> <<+= post bumps
08:14:02 <edwardk> so you get the current id
08:14:30 <edwardk> so if you seed with 0, then id <<+= 1  generates 0,1,2,3,4... while id <+= 1 generates 1,2,3,4,5..
08:14:31 <danilo2> edwardk: If yes, than I do not know whats happening here. This is the only function to optain the ids. Ok I'm going to dig into it. You are right - this way if we do not execute the backtracked branches then we would not double the ids, but will we not loose any of them ?
08:14:41 <danilo2> I mean will we not have not all id's used ?
08:14:58 * ski . o O ( post-increment addressing mode / effective adress )
08:15:09 <edwardk> the way i propose using StateT on Parser you wind up with a dense set of IDs
08:15:14 * hackagebot hexpat-lens 0.1.1 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.1 (JosephAbrahamson)
08:15:21 <edwardk> your way using parsec's backtracking state you get a sparse set
08:15:41 <edwardk> because you throw away id's every time you try an alternative and reject it
08:16:10 <danilo2> edwardk: hmm, interesting. Will we have dense set if ID when trunning "runstateT" before parsing? Will it not work the way, that we will generate a lot of ID's and not use them after the branch will be choosen ?
08:16:22 <gregnwosu> i want to get my feet wet with dsl's f-algebras etc, I understand the theory, but am completely stuck on how to start
08:19:46 <pjdelport> gregnwosu: Have you read https://www.fpcomplete.com/user/bartosz/understanding-algebras ?
08:20:33 * dfeuer is giving himself a crash course in Applicative trying to come up with a way to combine the results of lazy reads of multiple files safely.
08:20:48 <gregnwosu> pjdelport:  yes! its great , so im sold on the idea of DSLs
08:20:54 <kstt> Hi. I'm trying to compile a module on GHC 7.8 on Window 7. I am getting that : "ghc can't load .so/.DLL for: m.dll (addDLL: could not load DLL)"
08:21:01 <gregnwosu> but I dont really know how to design my own!
08:21:02 <kstt> This module uses Template Haskell
08:21:44 <kstt> I can build third party packages that use Template Haskell, but it fails with this error on my own package.
08:21:58 <kstt> I am using GTK, which might be related.
08:22:06 <gregnwosu> dfeuer: I thought monads where stricter on order than applicative
08:22:16 <gregnwosu> imho, i could be very wrong
08:22:25 <edwardk> danilo2: you runStateT to get out the parsing action which threads the state through the parser
08:22:37 <kstt> Since TH seems to load all packages for the expanding phase
08:22:49 <edwardk> danilo2: keep in mind any 'failed' parse is backtracking and trying from the same source state
08:23:05 <edwardk> consider StateT Int Maybe -- as a way to think about it
08:23:28 <edwardk> if you fail with 'Nothing' there is no 's' to communicate information to the way you resume it with (<|>)
08:23:36 <edwardk> so it backtracks and takes the s it had before it failed
08:23:53 <edwardk> there is no syntax tree to leak the bad IDs back to you from
08:24:16 <edwardk> and no s left for it not to go back and start where it left off before pruning the branch!
08:24:17 <danilo2> edwardk: oh, right. Sorry for this, but my mind just exploded when I saw the same IDs there. hmmm, I'm digging right now into it. Thank you
08:24:19 <sx> hi, for some reason installing with cabal fails on my machine due to a too old cabal version (it requires >=1.18) but i have 1.20.x installed. has anyone experienced something similar?
08:24:32 <dfeuer> gregnwosu, lazily reading from multiple files is not a context where you want to think about order, but Applicative in practice is just as rigid about it. The advantage of Monad in this context is that it allows the contents of one file to determine which other files are read. Which might be a good thing. But I think it probably is good to make sure the Applicative interface is sane first.
08:24:49 <jmct> sx: are you sure that the newer cabal is in your PATH?
08:25:00 <jmct> sx: that trips me up sometimes
08:25:08 <dfeuer> gregnwosu, but I'm just starting to understand some of these concepts.
08:25:21 <dfeuer> So take anything I say with six grains of salt.
08:25:30 <sx> jmct: well, i call it from the terminal with bash, so i guess it should
08:26:34 <gregnwosu> dfeuer: my bad , i assumed that you meant you wanted to preserve some form of order or output when you said you wanted to do it "safely"
08:26:41 <jmct> sx: so when you do cabal --version it's 1.20.x?
08:26:43 <sx> jmct: in fact i updated it with apt on debian (cabal-install), but not sure whether that's a good idea
08:26:45 <michaelt> sx presumably it's the Cabal library that is too old.  You have two of them probably, one global one local.
08:27:03 <sx> jmct: exactly
08:27:13 <michaelt> oh, the new one is from apt?
08:27:19 <dcoutts> sx: check that you actually have the right library version installed, see ghc-pkg list Cabal
08:27:19 <dfeuer> gregnwosu, maximal safety in this context is making sure that everything calculated using the result of a lazy read has been forced before the file is closed.
08:27:32 <michaelt> sx does 'ghc-pkg list Cabal' show two
08:27:44 <michaelt> oh dcoutts said that
08:27:57 <sx> michealt, dcoutts: thank you guys, that's it
08:28:40 <dcoutts> sx: sometimes cabal needs to compile custom Setup.hs scripts with the Cabal library. So that has to be installed, even if the cabal binary you have was itself built against a suitable lib version.
08:29:24 <jmct> dcoutts: did you get my email about our chat at ICFP? Wasn't sure if I should ping again as I didn't want to be a bother
08:29:44 <gregnwosu> dfeuer: so just take a peek at the values? or not that simple
08:29:57 <dcoutts> jmct: remind me, too many chats at ICFP
08:30:14 <dcoutts> jmct: the topic I mean
08:30:25 <jmct> About the learning materials to convince Prof. Runciman to switch from Hugs
08:30:53 <jmct> dcoutts: and hoping to help out on cabal-install
08:31:14 <dcoutts> jmct: ah
08:31:28 <dfeuer> gregnwosu, it's quite possible to do it by hand; the trouble is that a lot of people, especially but *not only* beginners, goof it up. So I'm trying to figure out a nice framework that makes sure it gets done and that's sufficiently easy and sufficiently general.
08:32:15 <dcoutts> jmct: ah ok sorry, I do have the email but I'd lost track of it in my post-icfp pile
08:32:18 * dcoutts marks it
08:32:41 <ski> gregnwosu : seen the bananas papers ? <https://www.fpcomplete.com/user/edwardk/recursion-schemes>,<http://comonad.com/reader/2009/recursion-schemes/> ?
08:32:50 <jmct> dcoutts: much appreciated. No rush as there is no longer an FP course at York :(
08:32:54 <Phillemann> Is there no way to construct a Data.Vector.Storable a from [a]?
08:32:58 <dcoutts> jmct: :-(
08:34:00 <jmct> dcoutts: should be back next year though. Anyway back to work, thanks!
08:34:01 <gregnwosu> skl not seen those , bookmarking.....
08:35:10 <Phillemann> Oh, sorry, there's actually fromList ;)
08:35:14 <Javran> wondering if StdGen is arch-independent?
08:35:43 <Fuuzetsu> pjdelport: that algebra article is very, very useful
08:35:53 <Fuuzetsu> I was looking this stuff up the other day
08:36:52 * ski can't recall the names of the banana stuff atm
08:37:11 <gregnwosu> bananas and barbed wire
08:37:27 <gregnwosu> just dont want to do to much category navel gazing....
08:37:31 <ski> istr one was named "bananas in space" or something like that
08:37:43 <gregnwosu> it draws you in
08:38:09 <ski> anyway, fold and unfold (iow cata and ana) are the most important members of the recursion schemes zoo
08:38:35 <gregnwosu> tim williams has a nice set of slides on recursion schemes
08:38:42 <ski> link ?
08:39:18 <gregnwosu> i got interested when i learned that fp'ers that dont grok recursion schemes are compared to imperative programmers who use goto
08:39:58 <gregnwosu> https://github.com/willtim/recursion-schemes/raw/master/slides-final.pdf
08:41:35 <centipede> interesting slides
08:41:37 <centipede> thank you
08:41:55 <centipede> might even understand one word or two :)
08:42:52 <gregnwosu> centipede i dont understand it, i understand about the first 15, the fpcomplete link is much better for a beginner like me
08:43:42 <gregnwosu> and then come back to the slides, thats where i am at
08:44:00 <centipede> I'll keep that in mind, thank you
08:44:06 <centipede> guess there is no royal road to category theory :)
08:44:44 <gregnwosu> im sold on the whole dsl things but theres no advice on how to design them :-\
08:45:47 <centipede> i have to leave now, but there is some helpful literature regarding the design of dsls, I'll tell you as soon as i am back
08:45:49 <centipede> see you
08:46:49 <gregnwosu> bye
08:47:16 <ski> later, gregnwosu
08:47:27 <shelf> does stackage work fine in a sandbox?
08:50:15 * hackagebot stm-promise 0.0.3.1 - Simple STM Promises for IO computations and external processes  http://hackage.haskell.org/package/stm-promise-0.0.3.1 (DanRosen)
08:56:24 <ReinH> ski: Meijer and Hutton's, http://www.cs.nott.ac.uk/~gmh/bananas.pdf
09:00:17 <Fuuzetsu> @hoogle Fix
09:00:19 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
09:00:19 <lambdabot> Data.Fixed module Data.Fixed
09:00:19 <lambdabot> Data.Fixed data Fixed a
09:00:30 <ski> ReinH : *nod*
09:26:41 <roelof> which beginnners course is the best one on fpcomplete for a beginner where I learn haskell the right way ?
09:29:53 <dv-> the right way to do haskell is still an open problem
09:30:17 <josephle> of which "learning haskell" is a subproblem, but still open :P
09:30:40 <roelof> Could this one a good one : https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1 ?
09:31:10 <sivteck> there's also https://github.com/bitemyapp/learnhaskell
09:32:34 <kuribas> Can you mix birdtracks (> ) with \begin(code)?
09:33:01 <merijn> kuribas: Try it? :)
09:34:07 <Jeanne-Kamikaze> roelof, have you checked LYAH ?
09:34:11 <Jeanne-Kamikaze> it's free to read online
09:37:20 <roelof> Jeanne-Kamikaze:  yes, but I like to work online
09:39:10 <kuribas> merijn: I get "parser error" after the \begin{code} line.
09:39:55 <kuribas> Unfortunately ## isn't supported...
09:41:21 <kuribas> That would give me only 2 levels of headings in markdown...
09:41:41 <kuribas> (I could use sed or awk of course...)
09:43:36 <merijn> kuribas: lpaste a minimal example + error?
09:43:45 <merijn> oh
09:43:49 <merijn> Is CPP enabled?
09:44:09 <merijn> I'm guessing it's barfing on ## because of CPP issues
09:44:31 <kuribas> oh...
09:45:46 <kuribas> merijn: I just use "ghc test.lhs"
09:47:36 <brycelane_> how does one set custom flags in cabal?
09:47:51 <merijn> kuribas: If you don't have any # in your file at all, does it work then?
09:51:02 <Fuuzetsu> …I don't know how but somehow this file is loading in fine in GHCi even though it has multiple problems
09:52:15 <kuribas> merijn: no
09:54:42 <kuribas> merijn: They are two issues though.  # style headers doesn't work with any .lhs file.
09:57:31 <kuribas> And mixing birdtracks with Tex style \begin{code} doesn't seem to be supported.
09:58:42 <ReinH> kuribas: I'm pretty sure I've seen files that mix both, let me look around a bit
10:03:52 <Fuuzetsu> I'm experiencing something super weird where GHCi/GHC apparently ignores what's in the file as long as it parses fine…
10:03:54 <Fuuzetsu> any ideas?
10:05:19 * hackagebot warp-tls 3.0.0.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.0.1 (MichaelSnoyman)
10:05:21 * hackagebot stdf 0.2.0.0 - Parse Structured Test Data Format (STDF)  http://hackage.haskell.org/package/stdf-0.2.0.0 (m)
10:14:40 <hughfdjackson> ski: sorry - had to go offline for a while :/ lost any comments you might have made after i got distracted
10:16:07 <Denommus> is it possible to get the type for a local term in haskell-interactive-mode?
10:19:49 <Fuuzetsu> :t bimap
10:19:50 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
10:20:37 <Fuuzetsu> I wonder if a notion of n-ary functor is at all useful
10:21:34 <Denommus> Fuuzetsu: there's probably some use-case for it somewhere
10:24:35 <Denommus> Fuuzetsu: maybe in FRP
10:29:09 <kuribas> Denommus: I think not, but you can do that in ghc-mod.
10:29:42 <Denommus> kuribas: how?
10:29:42 <kuribas> Denommus: http://www.mew.org/~kazu/proj/ghc-mod/en/
10:30:15 <kuribas> Denommus: c-cc-t
10:30:20 * hackagebot hyperloglog 0.2.3.3 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2.3.3 (EdwardKmett)
10:30:52 <Denommus> kuribas: what function does it call in your configuration?
10:31:50 <Denommus> kuribas: here it calls haskell-process-do-type, which does not work in local functions
10:32:06 <juanpablo_> How can I change the flags ghc uses by default? I want to switch to use -fasm instead of -fllvm
10:35:07 <brisbin> can someone help explain this build error? I thought transformers-compat:three meant "using the -three flag" which should not have the version bounds the error is showing (>=0.4.1 <0.5) http://sprunge.us/QQbD
10:35:19 <brisbin> i have dependencies resolved locally and written to a file using cabal freeze
10:35:20 * hackagebot yi-rope 0.4.0.1 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.4.0.1 (MateuszKowalczyk)
10:35:22 <brisbin> but i get this error on deployment
10:35:30 <kuribas> Denommus: you have ghc-mod installed?
10:35:45 <Denommus> kuribas: yes
10:36:46 <Denommus> kuribas: but I suspect haskell-interactive-mode overrides the keybindings
10:37:02 <kuribas> apparently so...
10:38:45 <zmbmartin> Is it possible to use the word data as an attribute in record syntax? ie data NewType = NewType {data :: String}
10:39:47 <chrisdone> denommus: you can rebind the key on haskell-interactive-mode-map to use ghc-mod
10:40:13 <kuribas> Denommus: try m-x ghc-show-type
10:40:51 <kadoban> zmbmartin: Even if you could, which I don't think you can, you shouldn't. It'd be confusing.
10:41:14 <zmbmartin> kadoban: OK thanks! Makes sense just wondering.
10:41:18 <kuribas> it can be very annoying to get ghc-mod to work.
10:42:59 <chrisdone> kuribas: ghc-server is even more annoying =)
10:43:10 <phaazon> hey there, a screenshot and a video from my latest haskell scene engine footage: https://www.facebook.com/dev.skypers/posts/10204731452543972 :)
10:43:22 <kuribas> right now I get an error from a different buffer...
10:43:53 <MitchellSalad> hey all, is there an ETA on when hackage is going to build docs again? it's so hard to develop without them :(
10:44:37 <geekosaur> MitchellSalad, no ETA
10:44:47 <MitchellSalad> poop.
10:45:10 <kuribas> chrisdone: The annoying thing is that it is too useful not to use it...
10:45:28 <geekosaur> discussion on haskell-cafe list and probably the infrastructure list
10:45:36 <hughfdjackson> ski: wow, LR grammars in parsec .. I didn't realise it would be quite that difficult o.o
10:47:15 <mkscrg> hey all, a cabal question: what is cabal looking at when it says "package index hasn't been updated for X days, run `cabal update` ..."?
10:47:30 <mkscrg> i haven't found that timestamp in a file anywhere
10:48:55 <geekosaur> it won't be *in* a file
10:48:58 <geekosaur> but *on* it
10:49:43 <geekosaur> specifically, the last modified time on ~/.cabal/packages/hackage.haskell.org/00-index.tar.gz
10:50:03 <geekosaur> (or the unpacked version 00-index.tar or the index it creates of it)
10:50:21 * hackagebot snaplet-influxdb 1.0.1.0 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.1.0 (ParnellSpringmeyer)
11:02:48 <simpson> Okay, does anybody have an example of implementing a toy language that *isn't* lambda calculus in Haskell?
11:03:10 <simpson> I've been banging my head against the wall repeatedly for weeks trying to implement objects and I'd like to see how somebody else does it.
11:03:39 <geekosaur> objects are kinda hard; you need to use HList or something similar
11:04:10 <haasn> depends on your definition of “implementing”
11:04:29 <simpson> Oh, the type of objects is trivial; just use an ADT that encapsulates all of the primitives as well as a single case for user-defined objects.
11:04:37 <simpson> haasn: Let's go with "analysis of mutable scopes".
11:05:08 <simpson> (People say that object-based languages have only one type anyway!)
11:05:35 <danilo2> edwardk: Hello! Are you here yet? :)
11:06:37 <danilo2> edwardk: I would love just to say "thank you" - the problem (with the same id's generated over AST) was caused by some funny typo in the code. Anyway you helped me a lot - telling me that it should work. I was sure it would, but after some diging with the code my mind mixed in strange way. Thank you! :)
11:07:19 <haasn> mkscrg: timestamp on the index file; if you “touch” it it no longer prompts you
11:07:44 <haasn> s/timestamp/modification date/
11:10:22 * hackagebot language-c-quote 0.10.1.3 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.1.3 (GeoffreyMainland)
11:10:57 <simpson> Okay, no, wait, I have a real question. When using cofree comonads to annotate functors, is there an easy way to annotate with layers of functors "above" the current functor influencing the annotation? IOW my AST's analysis depends on nodes both above and below the current node and I need to incorporate them into my annotatino.
11:11:01 <simpson> *annotation even.
11:13:25 <Fuuzetsu> why is sepBy not in Applicative ?
11:16:45 <merijn> Fuuzetsu: What would it do?
11:16:46 <laurence-e-day> Huh, it looks like it *should be*, since ReadP is an instance of Applicative
11:16:53 <mkscrg> haasn: ah, thanks. do you know which of the index files? i see .cache, .tar, .tar.gz, .tar.gz.etag
11:17:05 <ezrios> I am using unfoldTree from http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Tree.html
11:17:13 <ezrios> however, the tree I am generating is infinite
11:17:29 <ezrios> is it possible to only "take" a finite portion of the tree, to some level of depth?
11:17:34 <dfeuer> yes.
11:17:36 <ski> hughfdjackson : hm, your disconnect showed up hear about two hours after my last comment
11:17:40 <Fuuzetsu> merijn: sepBy :: (Alternative f) => f a -> f v -> f [a]
11:17:40 <Fuuzetsu> sepBy p s   = sepBy1 p s <|> pure []
11:17:40 <Fuuzetsu> sepBy1 :: (Alternative f) => f a -> f v -> f [a]
11:17:40 <ezrios> dfeuer: what is the approach
11:17:42 <Fuuzetsu> sepBy1 p s  = (:) <$> p <*> many (s *> p)
11:17:46 <dfeuer> Oh, this is a special tree.
11:17:49 <dfeuer> Let me look at that.
11:17:55 <ezrios> uh
11:17:58 <ski> hughfdjackson : if in doubt, you could check the channel logs to see if you missed anything
11:18:04 <ski> hughfdjackson : did you get any further ?
11:18:23 <dfeuer> ezrios, absolutely possible.
11:18:40 <ezrios> dfeuer: how would I go about doing this?
11:18:55 <hughfdjackson> ski: ah - i thought this was a logless channel
11:19:01 <hughfdjackson> that's #idris, now i think about it :) thanks
11:19:07 <laurence-e-day> base-4.7.0,1 has sepBy typed as ReadP a -> ReadP sep -> ReadP [a]
11:19:09 <geekosaur> right in the /topic...
11:19:17 <ezrios> right now, unfoldTree just proceeds depth-first to an infinite level of deth
11:19:20 <ezrios> s/deth/depth
11:19:34 <hughfdjackson> ski: and no, i didn't get much further
11:19:42 <ezrios> was thinking about using unfoldTreeM_BF with a MonadPlus or something
11:19:45 <ezrios> but unsure
11:19:55 <dfeuer> ezrios, I think you're overthinking.
11:19:58 <hughfdjackson> i found a post mentioning that you can do an 'ascent' parser in the middle of your recursive descent parsing
11:20:07 <hughfdjackson> :) but i've not figured out what that means yet
11:20:10 <ski> (argh, s/hear/here/)
11:20:15 * hughfdjackson is making dinner - and will be back to figuring it out later
11:20:21 <ezrios> dfeuer: maybe
11:21:20 <ski> hughfdjackson : i suppose "ascent" means bottom-up (in the sense of how Yacc and friends work)
11:21:42 <hughfdjackson> ski: I'm assuming so too :) trying to dig up that link again
11:21:44 <dfeuer> ezrios,  do you want an answer, or help finding one?
11:22:04 <ezrios> dfeuer: I would like an answer, or a general approach
11:22:12 <ezrios> are you taking the piss or what
11:22:33 <dfeuer> ezrios, I'm seriously asking; I can give you a straight-up answer, but I don't know if that's what you want.
11:22:42 <ezrios> dfeuer: ok, give me the answer
11:22:43 <dfeuer> treetop 1 (Node a f) = Node a []; treetop n (Node a f) = Node a (map (treetop (n-1)) f)
11:23:12 <dfeuer> Be sure to check for negative numbers and no guarantees because the code's completely untested.
11:23:25 <ezrios> dfeuer: I see, thanks muchly
11:24:05 <ski> hughfdjackson : hm, i think figuring out (as the parser is running) how to properly combine together fragments connected by infix operators at various precedence levels and of various associativities can possibly be seen as bottom-up to some extent
11:24:29 <hughfdjackson> ski: i'm wondering how haskell does it - or any other language with configurable precedence
11:24:35 <dfeuer> ezrios, that may also not be the most efficient solution.
11:24:45 <dfeuer> Unclear.
11:25:06 <dfeuer> Might be though.
11:25:07 <hughfdjackson> presumably they just have (expr `sepBy` operator) (i assume they don't use parsec in reality)
11:25:30 <hughfdjackson> and then have a second stage that finds the associativity for these operators and builds a tree out of that flat list
11:25:35 <ski> hughfdjackson : the method i've heard is to first parts a sequence of "atomic" expressions interspersed with infix operators into a flat sequence, and then later resolve how to nest it
11:25:46 <ski> hughfdjackson : i'm not sure if that's what GHC is using or not, though
11:26:14 <hughfdjackson> :) ski: sounds like you and I are on the same page on that one
11:26:19 <hughfdjackson> it might be easier to do a double-pass like that
11:26:25 <hughfdjackson> or switch to happy..
11:27:10 <ski> > let minus = (-); x = 1 `minus` 2 `minus` 3; infixl 5 `minus` in x
11:27:11 <ski> > let minus = (-); x = 1 `minus` 2 `minus` 3; infixr 5 `minus` in x
11:27:12 <lambdabot>  -4
11:27:12 <lambdabot>  can't find file: L.hs
11:27:15 <ski> bah
11:27:16 <ski> > let minus = (-); x = 1 `minus` 2 `minus` 3; infixr 5 `minus` in x
11:27:17 <lambdabot>  2
11:27:26 <ezrios> dfeuer: works fantastically
11:27:37 <ski> that shows that the fixity declaration can occur later than the expression in question, in Haskell
11:28:13 <hughfdjackson> ski: double pass it is then
11:29:17 <ski> hughfdjackson : i have some vague ideas relating operator resolution to composable continuations, but i'm not sure whether they could avoid a double pass
11:29:52 <ski> hughfdjackson : anyway, i'll leave soon for today
11:30:42 <hughfdjackson> :) it seems like you've been here for nearly 16 hours, so i can understand that !
11:30:45 <hughfdjackson> thanks for all of your help
11:31:03 <hughfdjackson> i'm going to have something to eat and see what i can figure out about this parsing business after
11:31:08 <hughfdjackson> have a good night !
11:31:19 <jle`> are you wolverine
11:31:26 <jle`> oh that is jackman
11:31:33 <ski> hughfdjackson : .. and i had a small neat (imho) trick regarding the left-recursion elimination i wanted to show, but we can take it later, when you've added (or at least stated a correct BNF) for subtraction
11:32:09 <ski> hughfdjackson : hm .. i think i arrived here in 2001 or 2000, not sure
11:32:38 <ski> hughfdjackson : (and this was my first IRC channel)
11:32:40 <Fuuzetsu> it's time for the new generation
11:32:44 <ski> hehe
11:34:34 <ski> (and i suppose i must be tired now, since i read "16 hours" as "16 years" ..)
11:37:14 <tsani> So I have a monad transformer stack newtype GUI a = GUI { runGUI :: StateT GUIState (ReaderT GUIConf Game) a } and I want to write a function game :: Game a -> GUI a
11:37:29 <tsani> Game is also a transformer stack over a mutable state and a static configuration.
11:37:50 <tsani> My intuition is lift . lift, but that's not well-typed at all :/
11:39:37 <MitchellSalad> lift . lift looks right
11:39:44 <ski> tsani : forgot calling `GUI' ?
11:39:50 <MitchellSalad> yeah, that too
11:40:07 <MitchellSalad> GUI . lift . lift
11:40:24 <vanila> :t lift
11:40:25 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
11:40:36 <MitchellSalad> :t lift . lift
11:40:37 <lambdabot> (MonadTrans t1, MonadTrans t, Monad (t1 m), Monad m) => m a -> t (t1 m) a
11:41:07 <tsani> Aha ! Yes, that's it!
11:41:31 <tsani> The types check out with GUI . lift . lift
11:41:33 <ski> @let data GUIState; data GUIConf; data Game a; instance Monad Game
11:41:34 <lambdabot>  .L.hs:199:10: Warning:
11:41:34 <lambdabot>      ‘Game’ is an instance of Monad but not Applicative - this will become an...
11:41:34 <lambdabot>  
11:41:34 <lambdabot>  .L.hs:199:10: Warning:
11:41:34 <lambdabot>      No explicit implementation for
11:41:50 <edwardk> danilo2: happy to help
11:42:21 <ski> hm, forgot lambdabot treats warnings as errors
11:43:17 <SrPx> Hello, I can't compile https://github.com/batterseapower/chsc using stockage. What do I do? http://lpaste.net/112529
11:43:19 * SrPx sighs
11:43:26 <pdxleif> What does it mean when I tell cabal to install something, and it says "rejecting: idris-0.9.14.3 (global constraint requires ==0.9.14.2)" - specifically, the "global constraint requires" part?
11:43:38 <pdxleif> Where do I look to see where that "global constraint" is coming from?
11:43:58 <SrPx> Seriously, can we f*king rebuild Cabal FROM SCRATCH?
11:44:22 <SrPx> The time I lost of my life fighting cabal surpasses by orders of magnitudes the time I spent using the language itself. It is ridiculous.
11:44:25 <MitchellSalad> SrPx: go ahead, no one's stupping you
11:44:27 <MitchellSalad> stopping
11:44:48 <SrPx> Cool, I will
11:44:54 <MitchellSalad> i look forward to using it!
11:45:02 <SrPx> I guess I'm the only one in the community suffering from it, so I can go ahead and do it alone
11:45:27 <MitchellSalad> it's sometimes frustrating but overall no worse than any other package managers I've used
11:46:07 <SrPx> It is so much worse than NPM that I could write a book on it. It is ridiculous. On NPM you just call "nom install foo" AND IT INSTALLS. Always. Ever. No mistake. No time lost. You are unlucky if it takes more than a minute due to internet connection
11:46:35 <SrPx> I use days as an unit to count the time I need to install a specific library on haskell
11:47:21 <SrPx> What is even the point in having such a powerful, awesome language, if you can't use code people write because the package manager is worse than dll hell back on C++ times
11:47:40 <Exio4> SrPx: use nix
11:47:54 <MitchellSalad> SrPx: so, my advice is to cool off and tackle the problem with a level head, it's not insurmountable =)
11:48:15 <MitchellSalad> step one would be to understand why cabal is failing
11:48:32 <SrPx> Exio4: I have nix on my system. So, how does it help me in installing the specific library?
11:48:34 <YurasS> SrPx: --allow-newer
11:48:40 <SrPx> YurasS: tried
11:49:02 <sivteck> srbaker, it seems that package is only 4 years old
11:49:08 <sivteck> SrPx *
11:49:34 <YurasS> SrPx: the same error? the open a ticket against cabal
11:50:08 <SrPx> sivteck: so it is completely normal that any code that is not maintained is unusable ?
11:50:13 <SrPx> 4 years isn't even that much
11:50:24 <supki> pdxleif: did you use cabal freeze?
11:51:28 <pdxleif> supki: Not that I recall - never heard of that.
11:51:38 <pdxleif> I can blow away my .cabal and .ghc and try again...
11:52:24 <albeit> What are some good strategies to reduce how much garbage collection my program does?
11:53:04 <zomg> use a trash compactor
11:53:07 <zomg> sorry :x
11:53:12 <MitchellSalad> lol
11:53:34 <supki> pdxleif: cabal freeze creates cabal.config file with constraints in the current directory
11:54:01 <supki> pdxleif: which will be used if you run cabal install from it
11:55:59 <sivteck> SrPx, it seems that the package requires an older library that stackage doesn't have
11:56:26 <SrPx> so what do I do? sivteck
11:56:42 <SrPx> just go back to hackage?
11:56:48 <sivteck> SrPx, use hackage \o/
11:56:57 <sivteck> but don't expect it to work
11:57:11 <SrPx> why?
11:57:24 <SrPx> is there any newer super compiler around?
11:57:28 <sivteck> the dependencies are old and may not work with your ghc
11:57:41 <sivteck> afaict
11:57:53 <SrPx> ;/
11:58:58 <SrPx> so, someone spent several time of his life writing a super compiler, published it to the community and we simply can't use it other than putting some effort in replicating the exact environment of the creator...
11:59:16 <sivteck> and that someone forgot to maintain it
11:59:18 <SrPx> how can nobody notice there is something seriously wrong there?
11:59:38 <Sonderblade> i never realized you can think of map as taking a unary function operating on scalars, and making it operate on lists
11:59:40 <SrPx> you shouldn't have to "maintain" something, our code should be future proof
12:00:03 <Sonderblade> abs = 0-dimensional, (map abs) = 1-dimensional, (map (map abs)) = 2-dimensional. thats very neat
12:00:09 <CARAM> is there a good way to fold while passing the current index to the function you're applying?
12:00:16 <sivteck> SrPx, i'm sorry that's about my knowledge about cabal ;)
12:00:25 <SrPx> sivteck: no I'm sorry
12:00:26 <sivteck> s/about/all
12:00:26 * SrPx sighs
12:00:33 <CARAM> I feel like I'm doing something wrong because I run into this pattern all the time and there's no official function for it
12:00:43 <CARAM> which feels....bad?
12:01:02 <SrPx> CARAM: what do you mean ? What index?
12:01:10 <CARAM> so if I'm folding over a list
12:01:25 <jle`> Sonderblade: yes :D
12:01:26 <CARAM> on the first item I want to pass 1/0, on the second item I want to pass 1/2
12:01:46 <jle`> Sonderblade: you can extend this concept to things that aren't lists
12:01:50 <jle`> things that are "mappable"
12:01:50 <CARAM> do I want to zip the list with [1..] and then fold?
12:02:07 <SrPx> CARAM: that is what I do normally
12:02:19 <CARAM> okay
12:02:21 <jle`> and using the `map` twice would map over two  layers/dimensions structure
12:02:39 <CARAM> it just seems like such a common pattern
12:02:42 <pdxleif> supki: Figured it out - the new version of idris bumped the optparse-applicative to 0.11, which just came out Oct 4th, and I hadn't done a "cabal update" since then. :/
12:02:55 <SrPx> CARAM: you can always define a function to do it, right? I think it is just missing from prelude
12:03:03 <CARAM> yeah sure
12:03:09 <SrPx> there is mapWithIndex iirc
12:03:24 <Sonderblade> jle`: currently trying to extend it to binary functions, but there it breaks down
12:03:36 <jle`> Sonderblade: you might want to look at the type of zipWith
12:03:39 <jle`> :t zipWith
12:03:40 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:03:52 <jle`> map :: (a -> b) -> ([a] -> [b])
12:03:57 <hask-> I'm having a hard time browsing Haskell's docs and package descriptions. Example, Google can get me here: http://hackage.haskell.org/package/text-0.7.2.1/docs/Data-Text-Lazy.html
12:03:57 <hask-> And from here, I can click on "Contents" (top-right corner) to go into the package description: http://hackage.haskell.org/package/text-0.7.2.1
12:03:58 <hask-> But how the hell can I go back to the docs from the package description?!
12:03:59 <jle`> zipWith :: (a -> b -> c) -> ([a] -> [b] -> [c])
12:04:03 <jle`> see the pattern? :)
12:04:05 <hask-> There is no link there
12:04:07 <hask-> back to the docs
12:04:08 <hask-> wtf
12:04:25 <hask-> so I have to go back to Google. which is painful
12:04:29 <Fuuzetsu> hask-: ???
12:04:33 <Fuuzetsu> what do you want to go back to exactly?
12:04:42 <Fuuzetsu> why don't you just click on Data.Text.Lazy which sends you back to the module?
12:05:12 <Fuuzetsu> more importantly, click on newer version up top first…
12:05:16 <hask-> Fuuzetsu: ok but there is the latest version: http://hackage.haskell.org/package/text-1.2.0.0
12:05:25 <hask-> no links there for the modules
12:05:31 <hask-> does this mean there are no docs for them?
12:05:34 <Fuuzetsu> correct
12:05:39 <hask-> :S
12:05:41 <hask-> wtf
12:05:41 <Fuuzetsu> click on 1.1.1.3
12:05:56 <Fuuzetsu> recently Hackage hasn't been building docs so newer uploads don't have them
12:06:03 <hask-> ok, so the standard practice is to just click back a few versions until I find the docs?
12:06:08 <hask-> is that how you brows hackage?
12:06:12 <jle`> for now ;_;
12:06:17 <hask-> ok thx
12:06:20 <hask-> good to know
12:06:35 <hask-> and why the hell does Google find some old ass version lol
12:06:39 <jle`> altneratively you can just build them yourselves and view them locally
12:06:44 <jle`> hask-: that was probably the last version they indexed
12:06:47 <hask-> yeah
12:06:56 <Sonderblade> jle`: neat, so map is unary, zipWith binary, but what about tertiary and higher?
12:06:57 <geekosaur> hask-: because older stuff gathers more links over time
12:07:05 <hask-> ok
12:07:13 <geekosaur> so search engines (not just google) prefer the older ones
12:07:39 <jle`> @hoogle (a -> b -> c) -> ([a] -> [b] -> [c])
12:07:42 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:07:42 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:07:42 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:07:42 <hask-> ok now i can browse hackage without using google
12:07:44 <hask-> thanks
12:07:45 <hask-> this is nice
12:07:52 <Fuuzetsu> I bind ‘ha’ in my browser to use the Hackage search box instead, search engines are pretty useless there
12:07:57 <jle`> @hoogle (a -> b -> c -> d) -> ([a] -> [b] -> [c] -> [d])
12:07:59 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:07:59 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:07:59 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:08:04 <jle`> ^ Sonderblade
12:08:15 <jle`> at this point though it might be worth looking at how to lift arbitrary arity functions :)
12:08:27 <jle`> which is a problem that the Applicative typeclass attempts to solve
12:10:25 * hackagebot derive 2.5.18 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.18 (NeilMitchell)
12:10:33 <Sonderblade> jle`: here is a more interesting problem, lifting the left side of a binary function, but not the right side, or vice versa
12:23:20 <CodyReichert> clear
12:27:18 <lifter> I understand that property test function names often begin with "prop_". Is there a similar popular convention for hunit test function names?
12:27:21 <Turl> howdy
12:27:40 <Turl> how is the ">>=" operator called? googling for ">>=" doesn't seem to match anything
12:27:45 <lifter> Turl: bind
12:27:50 <Turl> lifter: thx
12:28:09 <lifter> Turl: http://www.haskell.org/haskellwiki/Pronunciation
12:28:43 <Turl> lifter: oh, cool :)
12:29:42 <merijn> Turl: Also, you should probably use Hoogle for searching haskell functions :)
12:30:09 <merijn> @quote google.sucks
12:30:09 <lambdabot> trap_exit says: isn't hoogle awesome? the first time I used it, I was like "for the first time in my life, google sucks"
12:33:43 <SrPx> let _ = par a b in (a,b) <- does this make a and b be evaluated in parallel? Or else I don't get it, because `par a b` only returns b
12:34:55 <merijn> SrPx: "par a b" whould be optimised and thrown away there
12:35:05 <merijn> Because you bind it to an unused pattern
12:35:23 <SrPx> just how do I use it?
12:35:26 <RedNifre> > Just Nothing
12:35:27 <lambdabot>  Just Nothing
12:35:33 <RedNifre> When would I need Just Nothing?
12:36:06 <merijn> RedNifre: For "Maybe (Maybe Int)"?
12:36:08 <SrPx> RedNifre: maybe when you may have a maybe value
12:36:09 <RedNifre> Wouldn't it be nicer if it joined those automatically?
12:36:16 <ski> no
12:36:28 <geekosaur> "<x> automatically" is rarely nicer
12:36:36 <merijn> SrPx: "let a = someComputation; b = otherComputation in par a (par b (a, b))"
12:36:40 <RedNifre> But when would I want Maybe (Maybe Int)?
12:36:58 <SrPx> merijn: hmm thanks!
12:37:04 <geekosaur> but an example of a Just Nothing is in command line parsing, where no option, -option no argument, and -option with argument are 3 different things
12:37:16 <merijn> SrPx: par/seq only make sense with explicitily bound names
12:37:19 <geekosaur> Nothing, Just Nothing, Just argument
12:37:22 <ski> RedNifre : could happen if you're combining two operations that both happen to use `Maybe' for different purposes, and you don't want to mix them together
12:37:40 <Turl> SrPx: I've seen a ||| b = a `par` b `par` (a,b)
12:37:46 <RedNifre> hm, okay
12:37:59 <geekosaur> note that the outer Maybe belongs to the argument parser and the inner one to your application logic, so folding them is not really a good move
12:38:19 <ski> RedNifre : so each operation only mentions one `Maybe', but combining them gives you both (since at least one of them is polymorphic)
12:38:59 <ski> now, sometimes it might make more sense to use a custom datatype instead of `Maybe'
12:40:13 <ski> but sometimes you just want to express "either a value, or a (generic, unnamed) failure", with the intent of being able to compose this with operations from elsewhere which also work with `Maybe' (so that one *is* merging or at least meaning the same thing with `Nothing' in the two cases)
12:41:03 <ski> however, it may happen that you may want to combine two operations which use `Maybe' for such reasons, in a way that *doesn't* combine or mix up the `Nothings' with each other
12:41:12 <Exio4> @type \f xs ys zs ws → zipWith ($) (zipWith ($) (zipWith f xs ys) zs) ws)
12:41:14 <lambdabot> parse error on input ‘)’
12:41:22 <Exio4> @type (\f xs ys zs ws → zipWith ($) (zipWith ($) (zipWith f xs ys) zs) ws)
12:41:23 <lambdabot> (a -> b2 -> b1 -> b -> c) -> [a] -> [b2] -> [b1] -> [b] -> [c]
12:41:46 <ski> RedNifre : in any case, `Maybe' is just an ordinary defined algebraic data type, so it couldn't possibly auto-merge
12:42:11 <ski> (.. of course, one could imagine a special language feature that did, which could be used instead)
12:43:42 <ski> RedNifre : sorry for not being able to recall any good example such a case with combining two different operations that both use `Maybe', but i think this could be one reason for wanting to be able to express nested `Maybe'
12:44:47 <geekosaur> ski, did you see my command line parser example?
12:45:04 <ski> yes
12:45:18 <ski> (i don't think it's a case of what i was thinking about, though)
12:46:26 <joehillen> Where is the source for haskell.org?
12:46:37 <bernalex> joehillen: the new one?
12:46:46 <joehillen> sure
12:46:48 <bernalex> joehillen: https://github.com/haskell-infra/hl
12:48:15 <joehillen> oh, I just read this: https://blog.haskell.org/post/the_new_haskell_org/ which says it's PHP, but it looks like haskell-lang.org is in Haskell
12:48:40 <joehillen> I wonder when http://www.haskell.org/haskellwiki/Haskell will be replaced
12:48:53 <meoblast001> i'm a bit confused about some haskell syntax... i see there's a difference between liftM3 (,,) and liftM3 with regards to types
12:49:02 <meoblast001> how do i denote this difference in usage?
12:49:10 <bernalex> :t liftM3 (,,)
12:49:12 <lambdabot> Monad m => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
12:49:14 <bernalex> :t liftM3
12:49:15 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:52:01 <meoblast001> bernalex: how would liftM3 (,,) actually be used?
12:52:29 <meoblast001> or is that just a result of currying?
12:53:04 <bernalex> > liftM3 (,,) [1..5] [6..10] [11..16]
12:53:06 <lambdabot>  [(1,6,11),(1,6,12),(1,6,13),(1,6,14),(1,6,15),(1,6,16),(1,7,11),(1,7,12),(1,...
12:53:36 <meoblast001> hmmm
12:53:38 <meoblast001> thanks
12:53:40 <merijn> joehillen: Probably never
12:54:00 <bernalex> meoblast001: smaller example that it can actually output:
12:54:09 <bernalex> > liftM3 (,,) (Just 1) (Just 2) (Just 3)
12:54:10 <lambdabot>  Just (1,2,3)
12:54:11 <meoblast001> i guess i was thinking (,,) was part of the syntax
12:54:16 <meoblast001> but it's just currying the function
12:56:34 <joseph07> meoblast001: http://hackage.haskell.org/package/ghc-prim-0.3.1.0/candidate/docs/src/GHC-Tuple.html
12:57:04 <meoblast001> joseph07: thanks.. this is one of the scariest things i've ever seen :D
12:57:29 <bernalex> :t (,,,,,,,,,,,,,,)
12:57:30 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
12:57:35 <buttons840> newbie question: I remember seeing a function that was equivalent to: let (a, b) = span (/=3) [1..5] in (a, head b, tail b) -- but i forgot the name and span is the closest i've been able to find, does anyone know a common function like I described?
12:57:40 <bernalex> it's just a stupid function.
12:57:46 <joehillen> merijn: :( but it's so pretty
13:00:47 <geekosaur> :t Data.List.partition
13:00:48 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:01:00 <geekosaur> hm, not quite, but close
13:01:58 <buttons840> geekosaur: I might have created the function while I was doing the 99 haskell problems from the wiki -- I can't remember if it was a widely know function or just a one off i made
13:02:41 <geekosaur> sounds like a one-off to me. but you can always pattern match on span, slightly differently than you did
13:03:10 <geekosaur> let (a,(b:c))  = span (/= 3) [1..5] in (a,b,c)
13:03:23 <meoblast001> thanks everyone.. gtg. bye
13:03:38 <merijn> joehillen: People keep asking "when will haskell.org be rewritten in haskell" and the answer will remain "it's not going to be, unless you're volunteering to do it yourself and will build something that's AT LEAST as feature complete as the current one"
13:04:21 <buttons840> geekosaur: thanks for the suggestion
13:04:29 <merijn> joehillen: I mean, there's no real point in replacing working, featureful software with an untested feature incomplete replacement "just because"
13:06:14 <dfeuer> merijn, the extent of haskell.org downtime recently belies your claim that it's "working".
13:06:43 <dfeuer> Switching to a Haskell implementation would not necessarily fix that, of course.
13:06:46 <merijn> dfeuer: That's an issue with the machines, not the software
13:06:53 <geekosaur> dfeuer, I am not sure ... that, yes. haskell won't help with hardware
13:07:08 <merijn> There's data centre issues and load issues
13:07:09 <geekosaur> if anything it would probably be worse until it was properly tuned etc.
13:07:17 <merijn> afaik there hasn't been any issues with the wiki software
13:07:31 <dfeuer> I do think there's serious value in pursuing such a project, however.
13:08:04 <merijn> dfeuer: Are you volunteering after your fusion project? ;)
13:08:09 <dfeuer> Haaaa.
13:08:26 <dfeuer> merijn, I know so little about any such things.
13:08:42 <merijn> dfeuer: Time to learn ;)
13:09:16 <dfeuer> Hrmm.... T3064 stat not good enough. What's the deal there?
13:09:33 <dfeuer> And what kind of name is that for a test anyway?
13:32:59 <trap_exit_> https://github.com/valderman/haste-compiler/blob/67bf1cc1adcd241107e02a2dc41c57dd7b36d4ad/libraries/haste-lib/src/Haste/Binary.hs#L68-L81 <-- how do I take advantage of this ? "deriving (Binary)" is not working
13:33:15 <trap_exit_> so I feel like there's some "Generic" code going on here, ... and how do I take advantrage of this pre-written generic code?
13:34:01 <merijn> trap_exit_: "deriving (Generic)" + extension and then you write "instance SomeClass MyType"
13:34:33 <trap_exit_> merijn: so it' be something like "data Merijn = Merijn ... deriving (Generic) \n instance Binary Merijn" ?
13:34:34 <merijn> trap_exit_: Since you're not specifying *any* functions in your instance declaration, it will just attempt to use the default implementations which use Generic
13:34:35 <trap_exit_> let me try that
13:34:43 <merijn> trap_exit_: Yeah, that should be it
13:34:55 <merijn> trap_exit_: You might need like -XDeriveGeneric or whatever it's called
13:35:29 <tdammers> GeneralizedNewtypeDeriving?
13:35:38 <merijn> tdammers: No, that's something else entirely
13:35:45 <mauke> trap_exit_: http://www.haskell.org/haskellwiki/GHC.Generics#The_end-user
13:35:54 <merijn> tdammers: That lets you derive arbitrary classes for newtypes, not use the Generic class
13:36:02 <tdammers> sorry, wasn't paying enough attention :x
13:36:17 <tdammers> ignore me
13:37:16 <trap_exit_> merijn , mauke: nice, it compiles, thanks!
13:37:52 <Aruro> anyone aware of the problem with HaXml package?
13:37:59 <Aruro> cabal can not install it
13:38:19 <Aruro> says lexical error in string character literal
13:38:58 <trap_exit_>  /ignore tdammers
13:39:12 <johnarmstrong> I need help with type signature please
13:40:15 <johnarmstrong> what would the signature be for this function: http://pastebin.com/LAw54sxR
13:40:20 <trap_exit_> I generally write the code, then have ghc bitch at me for not having the top level type signature
13:40:24 <trap_exit_> then I copy /paste it
13:40:33 <geekosaur> Aruro, OS X? probably the CPP issue --- even though the big problems are fixed, clang's cpp can't be made to accept the way Haskell code can use ' characters
13:40:37 <mauke> johnarmstrong: none
13:40:41 <mauke> that's a type error
13:40:48 <trap_exit_> (Num a) => a -> a -> Bool ?
13:40:54 <mauke> also, 'then True else False' is redundant
13:41:20 <johnarmstrong> this is true, i'm just learning first day in haskell
13:41:22 <johnarmstrong> be kind
13:41:56 <trap_exit_> @remember mauke "also, 'then True else False' is redundant"
13:41:57 <lambdabot> Good to know.
13:41:57 <Aruro> vista
13:42:05 <Aruro> not os x
13:42:09 <mauke> @forget mauke "also, 'then True else False' is redundant"
13:42:09 <lambdabot> Done.
13:42:25 <trap_exit_> :-(
13:42:27 <mauke> johnarmstrong: what's that supposed to mean?
13:42:45 <tdammers> mauke: now you're being cruel
13:42:58 <mauke> I disagree
13:43:00 <tdammers> "be * -> *"?
13:43:04 <johnarmstrong> lol great way to get people interested
13:44:18 <trap_exit_> by isFactor, it's meant isMultiple
13:44:20 <trap_exit_> x is a multiple of y
13:44:26 <trap_exit_> if x/ y and floor of x/y are the same
13:44:33 <trap_exit_> this is reasonable code to write from a math perspective
13:44:39 <RchrdB> johnarmstrong: the thing that you wrote doesn't typecheck right now because the division operator, (/), only divides fractional number representations, whereas the 'floor' function converts fractional number representations to integral ones.
13:44:49 <trap_exit_> the problem is that floor(x/y) has type Integral, while the type x/y, I think, has type Fractional
13:44:57 <RchrdB> johnarmstrong: so you need to convert one to the other
13:44:58 <trap_exit_> thus the point mauke was making about it not type checking
13:45:17 <johnarmstrong> RcharB how to convert i'm very green
13:45:18 <trap_exit_> > 10 `mod` 3
13:45:20 <lambdabot>  1
13:45:35 <mauke> johnarmstrong: :-(
13:45:36 <trap_exit_> > isFactor x y = x `mod` y == 0
13:45:37 <lambdabot>  <hint>:1:14: parse error on input ‘=’
13:45:48 <trap_exit_> > isFactor x y = (x `mod` y == 0)
13:45:48 <RchrdB> johnarmstrong: no worries, we get students in here all the time around September. ;)
13:45:50 <lambdabot>  <hint>:1:14: parse error on input ‘=’
13:46:07 <trap_exit_> > isFactor x y = ((x `mod` y) == 0) -- wtf
13:46:08 <lambdabot>  <hint>:1:14: parse error on input ‘=’
13:46:28 <YurasS> > let isFactor x y = (x `mod` y == 0)
13:46:28 <johnarmstrong> hmm
13:46:29 <RchrdB> johnarmstrong: if you want to go with the function as written, there are functions like "fromIntegral" that convert from Integral representations.
13:46:29 <lambdabot>  not an expression: ‘let isFactor x y = (x `mod` y == 0)’
13:46:37 <indiagreen> @let isFactor x y = (x `mod` y == 0)
13:46:39 <lambdabot>  Defined.
13:46:46 <YurasS> oh ^)
13:46:57 <SrPx> Hey, if anyone: https://www.reddit.com/r/haskell/comments/2j5erc/ill_give_a_brief_talk_about_haskell_for_a_group/
13:46:58 <SrPx> thanks :)
13:47:02 <trap_exit_> > let isFactor x y = ((x `mod` y) == 0) in isFactor 10 2
13:47:03 <lambdabot>  True
13:47:07 <trap_exit_> > let isFactor x y = ((x `mod` y) == 0) in isFactor 10 3
13:47:09 <lambdabot>  False
13:47:17 <RchrdB> johnarmstrong: but the "mod" function happens to be the clearest way to check factorisation. :)
13:47:34 <trap_exit_> YurasS: thanks for the hint on 'let'
13:47:40 <johnarmstrong> i agree now
13:47:49 <trap_exit_> indiagreen: ah, will use @let in future
13:47:55 <johnarmstrong> what is the type sig for this?
13:48:18 <mauke> :t isFactor
13:48:19 <lambdabot> Integral a => a -> a -> Bool
13:48:24 <trap_exit_> johnarmstrong: I think you need a better vim/emacs setup
13:48:32 <johnarmstrong> how so?
13:48:35 <trap_exit_> so that ghc/ghci will shout back type errors at you ... which will help you learn faster
13:48:50 <RchrdB> > let isFactor x y = let fraction = fromIntegral x / fromIntegral y in fraction == fromIntegral (floor fraction) in map (uncurry isFactor) [ (6, 3), (4, 2), (20,9) ]
13:48:51 <lambdabot>  [True,True,False]
13:48:55 <johnarmstrong> any links that can detail how to do a proper setup?
13:49:33 <trap_exit_> I genrally do "Makefile = ghc -Wall -Werror Main.hs"
13:49:40 <trap_exit_> then I write some type, hit :make, and read the compile errors
13:49:46 <trap_exit_> other people like to use ghci
13:49:55 <johnarmstrong> smart thanks
13:50:29 * hackagebot hlint 1.9.9 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.9 (NeilMitchell)
13:51:00 <mauke> you could just :set makeprg=ghc\ -Wall\ -Werror\ %
13:52:30 <trap_exit_> I need help with naming. I'm using Haste, so I have one codebase (compiled twice) for client + server. Each client needs to store some state, which I want to call ClientState [this is on the client side, int eh browser]. Now, the server, for each client, also has to store some state, which I am currently calling ClientState [this is stored on the server side]. This is a name clash.
13:52:32 <trap_exit_> What names should I use instead?
13:52:43 <davidturner_> trap_exit_ johnarmstrong: you might like http://neilmitchell.blogspot.co.uk/2014/09/ghcid-new-ghci-based-ide-ish.html
13:53:11 <StoneToad> trap_exit_: clientclientstate and clientserverstate!
13:53:18 <trap_exit_> davidturner_: oh, I think I get errors / save ... i.e. C-0 = save + make
13:53:24 <StoneToad> or serverclientstate
13:53:28 <trap_exit_> ClientClientState ClientServerState ... I think my eyes will bleed
13:53:32 <StoneToad> :D
13:53:57 <trap_exit_> StoneToad: how ugly is Medussa ?
13:53:59 * StoneToad has trouble with naming things too
13:54:03 <StoneToad> medussa?
13:54:29 <RchrdB> trap_exit_: "ClientState" and "PerClientState"?
13:54:33 <davidturner_> ghcid gives feedback enormously faster than a full make cos it's using ghci's incremental reload
13:54:37 <johnw> anyone who would know has been turned to stone
13:54:42 <trap_exit_> StoneToad: http://en.wikipedia.org/wiki/Medusa
13:54:49 <trap_exit_> RchrdB: hmm, I like this
13:54:54 <RchrdB> if you can't immediately guess which one of those I mean to be server and which one I mean to be client then it's not a good enough name, disregard it.
13:54:58 <StoneToad> oh, you are refering to the greek medussa
13:54:59 <RchrdB> otherwise, go for it.
13:55:04 <StoneToad> I assumed it was some haskell lib I didn't know about
13:55:37 <trap_exit_> I think that's very clear, PerClientState = Server Side, ClientState = Client side
13:55:50 <Fuuzetsu> is there a nice function to delete a list of keys from a Map?
13:56:10 <trap_exit_> map . delete
13:56:10 <Fuuzetsu> :t foldl delete M.empty
13:56:11 <lambdabot>     Couldn't match type ‘M.Map k a’ with ‘[M.Map k a]’
13:56:11 <lambdabot>     Expected type: M.Map k a -> [M.Map k a] -> M.Map k a
13:56:11 <lambdabot>       Actual type: M.Map k a -> [M.Map k a] -> [M.Map k a]
13:56:22 <johnw> Fuuzetsu: yeah, I'd use a foldl'
13:56:32 <trap_exit_> yeah, don't use map :-)
13:56:43 <spopejoy> are ghc-compiled executables statically linked, ready to deploy?
13:56:45 <Fuuzetsu> ok, was hoping for a ready-made thing but whatever I guess
13:57:02 <StoneToad> Fuuzetsu: that is 'ready made' as far as haskell goes I think
13:57:11 <merijn> spopejoy: By default haskell libraries are statically linked, but the C libraries are not
13:57:18 <Fuuzetsu> well, sometimes there's that one function waiting for you
13:57:50 <trap_exit_> eh
13:57:53 <trap_exit_> PerCleintState sounds bad
13:57:55 <Norah23>  Never Pay for Porn ever again. Click Here! http://tinyurl.com/ozfvxy3
13:57:58 <trap_exit_> I thikn I will go with AClientState
13:58:08 <trap_exit_> @ops -- please kick Norah23
13:58:08 <lambdabot> Maybe you meant: pl oeis docs
13:58:13 <RchrdB> Is there a mod around to ban that spambot, please?
13:58:21 <trap_exit_> @ops
13:58:21 <lambdabot> Maybe you meant: pl oeis docs
13:58:24 <josephle> @where ops
13:58:24 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:58:35 <mauke> ...
13:58:56 --- mode: ChanServ set +o dibblego
13:59:09 --- mode: dibblego set -o dibblego
13:59:35 <RchrdB> trap_exit_: thanks. I was thinking the easiest way to test how intuitive those names are was to spring them on you without explaining them. ;)
14:00:50 <trap_exit_> RchrdB: actually, I thikn I'm goign to use ClientState (server side) + BrowserState (client side)
14:01:09 <RchrdB> Sounds good to me.
14:01:09 <trap_exit_> since I tend to thikn of prog from perpsective of server + persistence, so ClientState = shit I need to store persistently, and BrowserState = stuff in the browser
14:01:51 <trap_exit_> this naming scheme has the "random stranger on IRC approves" seal of approval :-)
14:02:01 <rrradical> is anyone here familiar with hsc2hs cross compilation support? I'm wondering if it's possible to support const_str terms, so that I can build zlib
14:02:24 <StoneToad> trap_exit_: 2 random strangers seal of approval
14:02:28 <StoneToad> twice as good!
14:02:39 <znn> user is still equal to the empty string, and the way to get around this is to either use a global, `global user` (not recommended), pass the value around (difficult because i'm using external libs), or to instantiate a new object: https://gist.github.com/uunsamp/768d505bc9ef57f3649f
14:02:39 <StoneToad> but not twice as random
14:03:21 <znn> how would haskell handle this, fetching the session's current user
14:03:23 <trap_exit_> stonetoad: on that note, I think I have done my work for the day, and deserve food
14:04:15 <spopejoy> merijn: makes sense
14:05:48 <spopejoy> any recs for snap vs warp for basic REST output?
14:05:48 <spopejoy> or happstack
14:09:12 <johnw> rrradical: I am
14:09:23 <johnw> rrradical: can you show me the C you're trying to interface with?
14:09:45 <rrradical> johnw: I'm actually trying to build the zlib library
14:09:51 <johnw> I don't have that locally
14:09:58 <johnw> but if you show me what you have a question about, I might know
14:10:14 <rrradical> johnw: I'll look it up, just a second
14:13:29 <RchrdB> spopejoy: I hear good things about Scotty.
14:13:31 <rrradical> johnw: here's the relevant code: http://lpaste.net/112544 It fails to build with "Codec/Compression/Zlib/Stream.hsc:924 directive const_str cannot be handled in cross-compilation mode"
14:14:15 <johnw> ah, cross-compilation
14:14:26 <johnw> you didn't mention that
14:14:29 <johnw> and I have no experience with it
14:14:38 <rrradical> johnw: I did actually :)
14:14:44 <johnw> oh, ouch
14:14:48 <johnw> so you did, my apologies
14:14:57 <carter> spopejoy: it literally doesnt amtter
14:15:02 <johnw> sorry I cannot help, but I'm very interested in the answer
14:15:08 <johnw> since I'm the Bindings-DSL maintainer no
14:15:09 <johnw> w
14:15:19 <carter> spopejoy: pick one
14:15:29 <carter> and types will let you migrate later if it really matters
14:15:30 <rrradical> johnw: thanks. I opened a ticket, so hopefully I'll get some help there
14:16:17 <rrradical> johnw: https://ghc.haskell.org/trac/ghc/ticket/9689
14:16:38 <S11001001> @ty (<.>)
14:16:39 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
14:16:42 <johnw> I think that should be entered here: https://github.com/jwiegley/bindings-dsl/
14:17:02 <johnw> I'm not sure it's a GHC problem yet
14:17:04 <johnw> let me check
14:18:06 <rrradical> I think the error message is in ghc: https://github.com/ghc/hsc2hs/blob/master/CrossCodegen.hs, line 236
14:18:08 <johnw> ah, no, that is the right place
14:18:12 <johnw> yeah, just found it
14:25:45 <matt2> i'm trying to install llvm-general, but I've got a newer version of llvm than is used by the llvm-general version in hackage
14:25:56 <matt2> how can i build it from source and install it into a cabal sandbox?
14:26:03 <matt2> this is the repo: https://github.com/bscarlet/llvm-general
14:26:44 <S11001001> Is the newtype X f a = X (f a) with instance Monoid a, Applicative m => Monoid (m a) defined anywhere?
14:28:24 <RedNifre> How do I convert a Fixed a, e.g. Nano, to Integer?
14:28:40 <RedNifre> What I want to do is to multiply it by 10^9, then convert it to Integer.
14:29:06 <davidturner_> RedNifre: fromIntegral . (*1000000000)
14:29:21 <davidturner_> o wait
14:29:28 <johnw> matt2: Nix would really help you right now
14:29:29 <davidturner_> floor . (*1000000000)
14:29:38 <johnw> matt2: since you could sandbox both llvm *and* llvm-general
14:29:57 <bitemyapp> RedNifre: beware, floor is really slow.
14:30:09 <S11001001> I mean (X m a) on the end of that
14:30:15 <matt2> johnw: what do you mean by that? I have a sandbox that I want to install them both to, is there no way to do that without Nix?
14:30:19 <RedNifre> @t floor . (*1000000000) (0.123456789 :: Nano)
14:30:19 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:30:22 <matt2> also what does nix do exactly
14:30:29 <johnw> matt2: cabal sandboxes will only sandbox the llvm-general package, not llvm itself
14:30:45 <matt2> johnw: i'm not trying to sandbox llvm
14:30:49 <johnw> matt2: the nix package manager keeps a static dependency tree in its own store
14:30:50 <johnw> ah, ok
14:30:51 <johnw> n/m then
14:30:54 <RedNifre> Well, floor being slow is no good. Is there a better way?
14:31:00 <matt2> basically the version in hackage is too old
14:31:05 <johnw> carter: ping
14:31:09 <matt2> and i want to install the new one from git
14:31:11 <carter> johnw: pong
14:31:11 <johnw> there is also the #haskell-llvm channel
14:31:12 <carter> sup
14:31:14 <carter> yes
14:31:16 <johnw> llvm-general questions here
14:31:18 <carter> theres is a n llvm chanenl
14:31:26 <matt2> ok i'll try that out
14:31:26 <carter> llvm-general is great
14:31:27 <carter> use it
14:31:30 <johnw> and carter is your man
14:31:33 <carter> well
14:31:40 <RedNifre> > floor . (*1000000000) (0.123456789 :: Nano)
14:31:41 <carter> i'm your "heres who you should talk to"
14:31:42 <lambdabot>  Couldn't match type ‘Data.Fixed.Fixed Data.Fixed.E9’ with ‘a -> b0’
14:31:42 <lambdabot>  Expected type: a -> b0
14:31:42 <lambdabot>    Actual type: Data.Fixed.Nano
14:32:01 <RedNifre> > floor $ (*1000000000) (0.123456789 :: Nano)
14:32:02 <lambdabot>  123456789
14:32:06 <TallerGhostWalt> anyone have a local hackage server? If so, any problems restarting the container?
14:32:32 <johnw> TallerGhostWalt: it should be safe
14:32:41 <johnw> hackage-server is relatively robust
14:32:54 <RedNifre> Why did lambdabot not infer the correct type in the first try?
14:32:56 <johnw> there is a #hackage channel even ;)
14:33:07 <sclv> @remember neelk So constructively we know this style can be used to meet hard performance deadlines in domains where the penalty for failure is literally radioactive flaming death.
14:33:07 <lambdabot> Okay.
14:33:17 <TallerGhostWalt> johnw: yeah it broke
14:33:25 <TallerGhostWalt> I can't get it to restart
14:33:28 <johnw> ask dcoutts
14:33:32 <TallerGhostWalt> k
14:33:42 <johnw> sclv: :)
14:35:54 <RedNifre> Well, maybe I'm doing it wrong... I have a Sqlite DB which does not support decimal types, but I do a lot of calculations with Nano. So I thought I could put them into the DB as Integers (instead of Strings), but if floor is slow this sounds like a bad idea.
14:36:12 <RedNifre> If I store them as Strings using read and show, would that be faster?
14:36:30 <Denommus> any... good xmpp library?
14:37:17 <RedNifre> Uh, that would be nice!
14:37:47 <Denommus> haskell-xmpp doesn't compile. Damn
14:39:01 <Denommus> what to do when a package doesn't compile? How to fetch the source, edit and install the editted dependency?
14:39:36 <tommd> Denommus: cabal unpack <package>
14:39:36 <geekosaur> cabal get (cabal unpack in older versions)
14:39:53 <RedNifre> Survey: Should you store Fixed numbers as ((*1000) :: Integer) or as ((show) :: String) ?
14:40:17 <davidturner_> RedNifre: Just tried checking floor using criterion
14:40:31 <RedNifre> I don't know what that is, but go on...
14:40:33 <davidturner_> floor . (*1000000000) is 350ns
14:40:42 <davidturner_> (*1000000000) is 70ns
14:40:47 <davidturner_> floor on its own is 170ns
14:41:17 <johnw> :t floor
14:41:18 <lambdabot> (RealFrac a, Integral b) => a -> b
14:41:31 <johnw> if you write a custom floor from, say, Double -> Int, it should be super fast
14:41:44 <johnw> since all you have to do is mask out the significand
14:41:59 <RedNifre> ah, thanks. I only need to do about 85000 calculations, so 30000000 ns sounds nice.
14:42:19 <davidturner_> johnw: The question was Data.Fixed.Nano -> Integer
14:42:24 <johnw> ah, ok
14:42:24 <RedNifre> I mean, if my computer is 100 times slower than yours that is just 3 seconds, which is something I can live with.
14:42:33 <RedNifre> Thanks for the measurement :)
14:42:42 <davidturner_> there's slow and then there's slow :)
14:42:58 <davidturner_> check out Criterion, it's excellent for microbenchmarks like this
14:43:01 <geekosaur> mrrr. shouldn't Nano be an Integer underneath? I think fromEnum works to get the original, then integer div
14:43:06 <davidturner_> http://hackage.haskell.org/package/criterion-1.0.1.0/
14:43:24 <geekosaur> s/the original/the internal value/
14:43:29 <Denommus> tommd: good. But how do I install the editted package in my sandbox?
14:43:42 <geekosaur> or maybe the internal value will be good enough as is
14:43:47 <tommd> Denommus: cabal install
14:43:47 <RedNifre> Thank you very much. There is so much to learn, it's overwhelming.
14:43:59 <Denommus> tommd: inside the directory? Will it respect the sandbox?
14:44:06 <tommd> or if you'd like to add it to a pre-existing stand box `cabal sandbox add-source /directory/to/package`
14:44:38 <RedNifre> At least now, after over a month of fooling around with Haskell, I start to feel that I can actually get things done with it by now.
14:44:57 <davidturner_> geekosaur: RedNifre: Ah yes, looks like you can do just (\(MkFixed n) -> n)
14:45:04 <tommd> Denommus: If you have done 'cabal sandbox init'  then go somewhere, `cabal unpack` the offender, fix it, go back to the sandboxed package and `cabal sandbox add-source /directory/to/offender` then `cabal install` again.
14:45:32 <Denommus> tommd: after I have done cabal sandbox add-source, can I delete the downloaded package?
14:45:40 <tommd> Yep
14:45:45 <Denommus> tommd: thanks
14:45:52 <davidturner_> that's 63ns
14:46:20 <zmbmartin> If I don't include a type signature for a function with the compile add FlexibleContexts itself?
14:46:53 <zmbmartin> I check :t in the console and when I put in the same signature from the console it errors telling me I need to use FlexibleContexts
14:47:05 <RedNifre> I don't quite understand the (\(MkFixed n) -> n) code.
14:47:14 <zmbmartin> But if I leave off the type sig then it compiles
14:47:17 <RedNifre> :t MkFixed
14:47:18 <lambdabot> Integer -> Data.Fixed.Fixed a
14:47:22 <RedNifre> @t MkFixed
14:47:22 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:47:46 <davidturner_> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Fixed.html#t:Fixed
14:47:52 <davidturner_> it's just unpacking that constructor
14:48:31 <RedNifre> > MkFixed 123456789 :: Nano
14:48:33 <lambdabot>  0.123456789
14:49:12 <davidturner_> perhaps clearer as case (0.123456789 :: Nano) of (MkFixed n) -> n
14:49:40 <davidturner_> > case (0.123456789 :: Nano) of (MkFixed n) -> n
14:49:42 <lambdabot>  123456789
14:49:59 <RedNifre> Ah. Now I get it.
14:50:49 <RedNifre> I was just wondering how to do it the other way around, the haskell way of matching to get what's inside is still not second nature to me.
14:51:18 <RedNifre> > MkFixed 12 :: Centi
14:51:20 <lambdabot>  0.12
14:51:30 <Xenasis> Is there any way to print without having to use monads, /at all/ (even if ill advised)
14:52:03 <hiptobecubic> Debug.Trace
14:52:14 <simpson> Xenasis: What's your use case?
14:52:32 <Xenasis> Debugging some homework
14:52:40 <Xenasis> Want to find out where it's crashing
14:52:46 <simpson> Debug.Trace's functions are excellent for that.
14:52:50 <hconfused> hello
14:52:58 <tdammers> although, crashing...
14:53:23 <tdammers> if it's crashing, I'd look for dangerous functions
14:53:39 <tdammers> things like head and such
14:53:50 <Xenasis> Is the answer to my question "no"?
14:53:54 <hconfused> suppose i want to have a "class  Node ..." which has a "parent" function, say. and then I want to have various types of nodes "data Node1 ...", "data Node2 ..."
14:54:01 <tdammers> The answer to your question is Debug.Trace
14:54:04 <hconfused> where i allow the parents to be any thing that is a Node
14:54:09 <Xenasis> That wasn't what I asked
14:54:11 <hconfused> i'm pretty confused about how to allow this.
14:54:29 <RedNifre> Is there something like java's casting where you deactivate the type checking because you think you know what you are doing?
14:54:39 <tdammers> Xenasis: but it is. Debug.Trace allows you to output things from inside a pure context
14:54:42 <simpson> RedNifre: No.
14:55:01 <Xenasis> ah, thanks
14:55:17 <tdammers> all I'm saying is that there are other debugging options
14:55:36 <simpson> RedNifre: Actually, that's not a fair answer. Yes, there are runtime-specific tools that allow you to do things like reinterpret a value of one type as a value of another type.
14:55:39 <tdammers> e.g., split up your code into small functions, and play with them in ghci
14:55:44 <RedNifre> So the only way is by cheating, e.g. turning everything into strings using "show" and then do the "casting" by reading them back and hoping your reads match your shows, huh?
14:55:53 <tdammers> use the type system to give you stronger invariants
14:55:56 <Xenasis> Though that's true, printing text is very useful
14:56:00 <tdammers> ofc
14:56:08 <simpson> RedNifre: Well, what's your use case? Generally, no, values cannot be reinterpreted this way. You'll get segfaults.
14:56:09 <hconfused> here's is my attempt at some code - http://lpaste.net/2573911309934395392
14:56:16 <hconfused> it fails for several reasons
14:56:30 <hconfused> but it gives the gist of the idea maybe ...
14:56:58 <RedNifre> Well, I'm currently reading and writing to a DB in a very silly way which has code duplication for every record size (one function for records with one field, a nearly identical one for those with two etc.)
14:57:10 <RedNifre> say you have data Foo = Foo String Integer
14:58:04 <RedNifre> Then you read that from the db by doing get [a,b] = Foo (fromSqlValue a) (fromSqlValue b)
14:59:42 <RedNifre> my thought was that I could make it work for any record by passing the record constructor, eg. get :: (a -> b -> z) -> z ; get c = c (fromSqlValue ...
15:00:47 <RedNifre> Basically, it's the problem of not having varargs of arbitrary types, which resulted in weird class instances code nonsense.
15:01:39 <RedNifre> The problem is basically that the DB gives me [SqlValue], but this is not very Haskell-like since those values in that list might be a mix of Strings, Integers etc.
15:02:07 <RedNifre> So I'd like to parse them with a list of functions SqlValue -> ???, but you can't create such a list.
15:02:17 <joelteon> what adapter are you using?
15:02:36 <RedNifre> So instead of lists I missused tuples as lists of different types, so there's one function per tuple size (pseudo list length)
15:03:21 <RedNifre> I thought I keep it simple by using HDBC, but that's no good.
15:03:33 <RedNifre> Guess I'll switch to Conduit/Pipes/something serious.
15:04:12 <erikd> for a monoid over something like a Maybe type, is (Just a) `mappend` (Just b) == Just b legal? monoids don't need to be communative do they?
15:05:16 <joelteon> if Just a == Just mempty, right?
15:06:01 <benzrf> erikd: they certainly don't
15:06:09 <TallerGhostWalt> IRC is so strange
15:06:17 <benzrf> erikd: the only requirements of a monoid are identity, associativity, and closure
15:06:22 <TallerGhostWalt> hey brilliant people HEEELLLP... turns out they have nothing better to do
15:06:30 <TallerGhostWalt> amazing
15:07:01 <erikd> benzrf: thanks thats what i need :-) i can look up those three requirements and see if my type is legal :-)
15:07:04 <benzrf> RedNifre: pipes is Pretty Damn Easy
15:07:23 <dfeuer> erikd, I don't know if you'll manage that identity bit.
15:08:04 <benzrf> dfeuer: how so
15:08:54 <erikd> yeah, identity seem fine.
15:08:56 <dfeuer> benzrf, what's the identity going to look like?
15:09:00 <benzrf> for wh a t
15:09:03 <merijn> erikd: Monoids don't require commutavitiy, only associativity
15:09:20 <dfeuer> For something where Just a `mappend` Just b = Just b
15:09:27 <merijn> erikd: Actually, that looks just like the Last monoid inside a Maybe
15:09:29 <Eduard_Munteanu> It's pretty easy to get a trivial monoid there.
15:09:31 <benzrf> Nothing can be identiy
15:09:38 <benzrf> > mempty :: Maybe Int
15:09:39 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
15:09:39 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
15:09:43 <benzrf> > mempty :: Maybe (Sum Int)
15:09:43 <erikd> ok, so mine (which always picks the right most value) looks ok
15:09:44 <lambdabot>  Nothing
15:09:48 <merijn> > getLast . mconcat $ map Last [1..10]
15:09:49 <lambdabot>  No instance for (GHC.Show.Show a0)
15:09:49 <lambdabot>    arising from a use of ‘M768663778418683295416571.show_M7686637784186832954...
15:09:49 <lambdabot>  The type variable ‘a0’ is ambiguous
15:09:49 <lambdabot>  Note: there are several potential instances:
15:09:49 <lambdabot>    instance [safe] GHC.Show.Show
15:09:51 <merijn> eh
15:09:53 <merijn> hmm
15:10:02 <benzrf> > ala Last foldMap [1..10]
15:10:03 <lambdabot>  No instance for (GHC.Show.Show a0)
15:10:04 <lambdabot>    arising from a use of ‘M293406586931219711916596.show_M2934065869312197119...
15:10:04 <lambdabot>  The type variable ‘a0’ is ambiguous
15:10:04 <lambdabot>  Note: there are several potential instances:
15:10:04 <lambdabot>    instance [safe] GHC.Show.Show
15:10:07 <dfeuer> Oh, I see what you're getting at.
15:10:08 <benzrf> eh?
15:10:09 <dfeuer> Sorry.
15:10:14 <merijn> erikd: Anyway, yes, that's a valid monoid
15:10:16 <josephle> > getLast . mconcat $ map (Last . Just) [1..10]
15:10:18 <lambdabot>  Just 10
15:10:23 <benzrf> :t Last
15:10:24 <lambdabot> Maybe a -> Last a
15:10:24 <erikd> merijn: thanks
15:10:27 <benzrf> O h i  s e e
15:10:34 <merijn> erikd: Try and prove it :)
15:11:07 <erikd> merijn: i have to if people are going to accept my patch :-)
15:11:09 <Tarbl> This is more of a FP question than a Haskell question, but how would you compose two functions where the first function has two distinct "return" values?
15:11:17 <merijn> erikd: "x <> mempty = x", "mempty <> x = x" and "x <> (y <> z) = (x <> y) <> z"
15:11:24 <S11001001> erikd: Yeah, that's lifting the Last semigroup.  As it happens, if you can prove some Semigroup a, you've proven Monoid (Maybe a) where the Semigroup is used for the both-Just case.
15:11:48 <S11001001> erikd: though I see josephle mentioned Last already :)
15:12:05 <erikd> yes, help here has been awesome (as usual)
15:12:23 <josephle> well, merijn mentioned it first. I was compelled to get a working expression for lambdabot :P
15:12:37 <Eduard_Munteanu> If 'Just _ <> x = x' and 'Nothing <> x = x' then all elements are left identities. And left identities are also right identities in a monoid.
15:13:12 <S11001001> josephle: Aye, though there is no Last monoid
15:13:16 <RedNifre> How do I find out which version of base I have?
15:13:19 <benzrf> Eduard_Munteanu: i dentities are unique...
15:13:28 <benzrf> one's gotta give!!!
15:13:45 <Eduard_Munteanu> benzrf, indeed, so it can't be a monoid because all those are different
15:13:50 <chirpsalot> Tarbl: in Haskell functions only have one return value, but that return value could be a tuple.
15:14:17 <chirpsalot> Tarbl: then you would just compose with a function that takes a tuple as an argument.
15:14:53 <S11001001> Tarbl: there is a collection of triple-symbol operators you can use to compose functions in various ways other than .
15:14:58 <S11001001> @ty (|||)
15:15:00 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
15:15:04 <S11001001> @ty (&&&)
15:15:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:15:12 <S11001001> @ty (***)
15:15:14 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:15:17 <chirpsalot> I never understood the type signature of &&&
15:15:22 <benzrf> :t (|||) `asTypeOf` either
15:15:23 <lambdabot> (a -> c1) -> (c -> c1) -> Either a c -> c1
15:15:25 <chirpsalot> Or any of those, for that matter.
15:15:41 <benzrf> > ((*2) &&& (-4)) 10
15:15:42 <S11001001> chirpsalot: you understand that a -> b is (->) a b right?
15:15:43 <lambdabot>  No instance for (GHC.Show.Show a0)
15:15:43 <lambdabot>    arising from a use of ‘M103217073897991402216720.show_M1032170738979914022...
15:15:43 <lambdabot>  The type variable ‘a0’ is ambiguous
15:15:43 <lambdabot>  Note: there are several potential instances:
15:15:43 <lambdabot>    instance [safe] GHC.Show.Show
15:15:52 <chirpsalot> S11001001: yeah.
15:16:04 <benzrf> > ((*2) &&& (-4)) 10 :: Int
15:16:04 <chirpsalot> S11001001: oh.
15:16:06 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘(a0, c'0)’
15:16:06 <lambdabot>  Expected type: a0 -> GHC.Types.Int
15:16:06 <lambdabot>    Actual type: a0 -> (a0, c'0)
15:16:08 <S11001001> chirpsalot: substitute (->) for a, because (->) satisfies Arrow and ArrowChoice
15:16:09 <benzrf> mfw
15:16:11 <Eduard_Munteanu> chirpsalot, the arrow looks like >-
15:16:11 <Tarbl> chirpsalot: This question might just not translate well to functional programming, since it's not being written in Haskell. I've got 3 functions, function A returns the values used for function B and C, where functions B and C expect a collection of part of the values returned by function A.
15:16:12 <chirpsalot> Wait, why did I never understand these?
15:16:25 <chirpsalot> XD for some reason I thought these were more special.
15:17:27 <chirpsalot> S11001001: These are really freakishly general o_o.
15:18:08 <Eduard_Munteanu> chirpsalot, for instance 'a b c' could be 'b -> Maybe c'
15:18:16 <S11001001> benzrf: ugh I imported ||| last week and used with concrete (->), didn't even remember `either`
15:18:28 <S11001001> benzrf: and I was just telling someone about `either` this weekend!
15:18:47 <merijn> Eduard_Munteanu: Well, only if you newtype
15:19:03 <Eduard_Munteanu> Sure, "could be" morally. :)
15:21:01 <Eduard_Munteanu> Actually it works with   type Partial a b = a -> Maybe b
15:21:28 <Eduard_Munteanu> But you can't make instances where Partial occurs not fully-applied.
15:22:00 <RedNifre> So I have base 4.6.0.1 and I wonder if I should get 4.7.0.0 or something. Cabal has upgrade disabled and I don't really know what I'm doing here. Should I try to install a newer base to get the MkFixed constructor, or will that break everything?
15:24:41 <merijn> RedNifre: You can't upgrade base
15:24:42 <S11001001> RedNifre: Don't install a new base; if you want new base, upgrade GHC entirely.  If you use the platform, the latest release should have newer base for you.
15:24:57 <merijn> RedNifre: It''s impossible, base is part of GHC
15:27:39 <RedNifre> Ok, so I'll pass.
15:29:47 <geekosaur> RedNifre: just use fromEnum instead of unwrapping it yourself
15:29:50 <RedNifre> If I have a data in one module, can I generically derive a ToJSON instance in a different module or even different library?
15:30:03 <simon> RedNifre, yes.
15:30:37 <simon> RedNifre, sorry, I thought you said generally.
15:31:29 <simon> RedNifre, as long as you export your data definition, I don't see why different modules should limit you from defining type class instances.
15:31:30 <RedNifre> I mean that I have data Foo = Foo deriving Generic in one library and a separate library would need a Json conversion, so could that library do instance ToJSON Foo?
15:34:40 <lpaste> hughfdjackson annotated “calc-parser.hs” with “calc-parser.hs (annotation)” at http://lpaste.net/112521#a112545
15:35:03 <hughfdjackson> ski: i know you're not here/asleep/having fun, but I finally got it ;) it was kinda obvious
15:35:11 <hughfdjackson> thanks again for all the help
15:36:41 <simon> hughfdjackson, why do you use try and not simply alternation?
15:37:27 <hughfdjackson> simon: in this particular case, it makes absolutely no sense
15:37:33 <hughfdjackson> (that i'm using try)
15:37:45 <hughfdjackson> in my original cases, I was having to backtrack after consuming input
15:38:06 <hughfdjackson> :# some ineffeciencies may have made it through to this version that have nothing to do with making the things work
15:38:11 <hughfdjackson> and more to do with the history.. thanks for that :)
15:38:46 <hughfdjackson> btw, in the case of `expression`'s definition, don't I want try?
15:39:08 <simon> hughfdjackson, yeah. alternatively, rewrite the grammar into LL(1).
15:39:36 <hughfdjackson> -.- as per the BNF note, i haven't worked out exactly how to do that ..
15:40:46 <hughfdjackson> :) but i'm sure I shall in due course
15:41:22 <Kron> cabal keeps giving me errors about not being able to find "Data.Default"
15:41:30 <Kron> how can I get this or fix my system?
15:43:21 <Denommus> hm, is there a function to transform a list of tuples in a tuple of lists?
15:43:37 <eikke> :t unzip
15:43:38 <lambdabot> [(a, b)] -> ([a], [b])
15:43:41 <simon> :t unzip3
15:43:43 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
15:45:08 <vanila> [(a, b)] -> ([a], [b]) loses information though
15:45:25 <vanila> the type system no longer knows the lists have same length
15:45:44 <Denommus> thanks
15:48:28 <augur> vanila: the type system never knew that :)
15:49:15 <augur> vanila: both in the sense that "the lists" didnt exist until you use the function, so there was no prior information to lose
15:49:24 <augur> and also in the sense that the type system doesnt know it anyway
15:49:41 <augur> haskell is not capable of such things as suh
15:50:09 <augur> with extensions you can do it tho
15:50:30 <augur> what you want to say is   unzipV :: Vec (a,b) n -> (Vec a n, Vec b n)
15:51:07 <joelteon> or [(a,b)] -> (Vec a n, Vec b n) if i understand it
15:51:51 <vanila> I suppose we would need [(a,b)] -> exists n. (Vec a n, Vec b n) though
15:53:11 <simon> hughfdjackson, http://web.cs.wpi.edu/~kal/PLT/PLT4.1.2.html -- 'E ::= E + E | E * E | ( E ) | num'  -->  'E ::= num E2    E2 ::= + num E2 | E3    E3 ::= * num E3 | ( E ) | ε'
15:56:16 <Eduard_Munteanu> vanila, that is allowed to drop or add elements
15:56:33 <vanila> goo d point!
15:57:45 <Eduard_Munteanu> forall n. Vec (a, b) n -> (Vec a n, Vec b n)    seems fine though
15:59:44 <Eduard_Munteanu> Although that is allowed to permute elements.
16:04:49 <RedNifre> Is there a simple way to have code execute in a loop every minute in ghci? (only temporarily)
16:05:04 <Eduard_Munteanu> Perhaps forall (as :: [*]) (bs :: [*]). HList (zipWith (,) as bs) -> (HList as, HList bs)
16:05:04 <RedNifre> like calling main every minute.
16:05:54 <RedNifre> How strong is the distinction between libraries and executables? I started something as a library but now there's also a main method and I wonder if I can use it as both.
16:06:50 <simon> RedNifre, you can hypothetically import it as a library and hide main when doing so, but it becomes a little inconvenient. rather, if you make a separate file that only imports your library and defines the main function, you get around that.
16:07:25 <Eduard_Munteanu> RedNifre, they have to be separate in cabal, although it's common to ship 'foolib' and 'foolib-executable'.
16:08:42 <pjdelport> RedNifre: ghci> tid <- forkIO (forever $ threadDelay (10^6) >> putStrLn "Hello!")
16:09:23 <pjdelport> RedNifre: Replace putStrLn "Hello!" with your IO action of choice. (10^6) will delay for one second; so multiply by 60 for a minute.
16:09:31 <pjdelport> RedNifre: Oh, and import Control.Concurrency
16:09:54 <pjdelport> RedNifre: To stop it, you'd say: killThread tid
16:11:36 <Eduard_Munteanu> Above, zipWith can be defined as   type family ZipWith (f :: * -> * -> *) (xs :: [*] (ys :: [*]); type instance ZipWith f (x ': xs) (y ': ys) = f x y ': ZipWith f xs ys; type instance ZipWith f '[] '[] = '[]
16:12:07 <Eduard_Munteanu> (which interestingly excludes xs and ys having different lengths)
16:13:35 <kadoban> Would there be some reason that ghc-mod takes quite a long time to run, even on really simple files? It used to be much quicker, not sure what I changed...
16:14:02 <kadoban> I have it running in vim every time I save, which is getting annoying when it takes like 7 seconds on a blank file.
16:16:16 <thetrav> I'm looking at the Persistent library.  It's got a lot of {-# LANGUAGE statements at the top... I haven't come across this feature of Haskell yet, can anyone tell me what it is and where I can read up on it?
16:17:29 <Fuuzetsu> can you have records + GADTs?
16:17:29 <Eduard_Munteanu> thetrav, they're language pragmas, which enable extensions to the language
16:17:29 <Eduard_Munteanu> Fuuzetsu, yes
16:17:56 <BeardedCoder> thetrav: http://bit.ly/1rrnpo0
16:17:57 <thetrav> Eduard: thanks, https://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html being a good doc? or should I read somewhere else?
16:17:59 <kadoban> thetrav: If you just search for the pragma name you should be able to find out what it means usually
16:18:01 <Eduard_Munteanu> Fuuzetsu, Con :: { conX :: X, ... } -> Type
16:18:09 <cristian2> I'm using the Text.Regex.Posix module, and was expecting to get all matches of a regex using:  "foo bar baz fool bars" =~ "(foo[a-z]?|bar)" :: [String]
16:18:25 <cristian2> But I got an error:  No instance for (RegexContext Regex [Char] [String])
16:18:33 <Fuuzetsu> Eduard_Munteanu: awesome
16:18:34 <Eduard_Munteanu> thetrav, yeah
16:18:36 <cristian2> Does anyone can spot the error?
16:18:54 <BeardedCoder> thetrav: The one you will most likely use a lot of is OverloadedStrings .
16:21:14 <thetrav> Thanks BeardedCoder
16:21:57 <thetrav> Last question (for now) is whether it's reasonably common to have these language extensions in your programs or if it's a bit odd
16:22:10 <BeardedCoder> thetrav: I wouldn't worry too much about what extensions you need for Persistent just yet. IMO.
16:22:35 <Eduard_Munteanu> thetrav, extensions are very common, but whether it's reasonable or not depends on the extension (they're not all equal)
16:23:29 <thetrav> BeardedCoder: it's more that I've got some sample code with a bunch of extensions, and I prefer knowing what I'm copying into my tutorial app rather than going blind :P
16:23:46 <thetrav> at least I now have a search path for when it all goes wrong
16:24:53 <BeardedCoder> thetrav: Cool. Just look up each extension then.
16:27:30 <thetrav> Yep, that's what I'm doing, thanks for the pointers
16:33:04 <Eduard_Munteanu> thetrav, also https://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
16:40:36 * hackagebot sodium 0.11.0.2 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.11.0.2 (StephenBlackheath)
16:50:51 <Fuuzetsu> how can I tell GHC to not cry about missing patterns for impossible GADTs: Inaccessible code in a pattern with constructor…
16:52:08 <dfeuer> Fuuzetsu, that was a work in progress last I heard.
16:52:19 <dfeuer> Fuuzetsu, are you using GHC HEAD?
16:52:23 <Fuuzetsu> no
16:52:27 <Fuuzetsu> 7.8.3
16:52:39 <dfeuer> Use GHC HEAD and if that doesn't fix it, complain.
16:52:45 <dfeuer> It's definitely broken in 7.8.3.
16:53:06 <Fuuzetsu> OK, just making sure it's broken more rather than me being dumb and not doing it right
16:53:13 <Fuuzetsu> s/more //
16:53:18 <dfeuer> It's definitely broken.
16:53:29 <dfeuer> Whether you're doing it right I really couldn't say.
16:55:00 <Fuuzetsu> I definitely can't
16:55:16 * Fuuzetsu is changing types and hopes nothing big breaks in these 140+ modules
17:00:26 <L8D> is there a framework/library that would allow me to write HTTP response handlers in the form of:
17:00:42 <L8D> Req -> Res -> Handler -> Res
17:01:48 <L8D> someMiddle req res next = next req $ res { getHeaders = ("Content-Type", "text/html"):getHeaders res }
17:02:10 <L8D> I mean... Req -> Res -> Handler -> IO Res
17:02:36 <L8D> is that style of HTTP API architecture possible with Haskell?
17:05:39 <jxv> L8D, warp?
17:06:33 <jxv> I mean wai
17:07:55 <L8D> jxv: hm...
17:08:03 <L8D> not as simple as I'd prefer but that would get the job done
17:08:04 <L8D> thanks
17:08:49 <L8D> I guess there's already a lot of stuff pre-implemented in Network.HTTP that most of the frameworks have to adhear to
17:09:58 <jxv> L8D, https://github.com/yesodweb/wai/tree/master/wai
17:11:26 <pdxleif> L8D: What's the "Handler" part?
17:11:46 <L8D> pdxleif: so I handler looks like this: Req -> Res -> IO Res
17:11:59 <pdxleif> WAI is just Req -> Res, essentially, so "middleware" is just (Req->Res) -> (Req->Res)
17:12:37 <L8D> pdxleif: I'm referring to Express's style of doing middleware
17:12:52 <pdxleif> I'm not familiar w/ that
17:12:53 <L8D> the signature should be: Handler -> Req -> Res -> IO Res
17:13:06 <pdxleif> Is that so you can transform the response in a successive part?
17:14:26 <L8D> it's so I can write middleware like: someMiddleware next req res = next (req { someFunctionalUpdateToTheRequestObject = foo }) res
17:14:35 <jxv> L8D, isn't a handler just a "Req -> IO Res"?
17:14:50 <pdxleif> https://hackage.haskell.org/package/wai-3.0.1.1/docs/Network-Wai.html#t:Application
17:14:51 <L8D> it's so that you can build up a responsive
17:14:54 <mkscrg> does anyone have a git submodules workflow they actually like?
17:14:57 <L8D> and generate headers and whatnot
17:15:34 <mkscrg> (maybe that's better phrased existentially: do there exist likeable git submodule workflows?)
17:16:12 <pdxleif> L8D: On this line a modify the request (change the path to "index.html"), and then call "static" on it (a static server)
17:16:37 <kadoban> mkscrg: Maybe look at git subtree if you're not a submodule fan. It does a similar job in a...usually better way for my uses.
17:17:22 <pdxleif> L8D: So it seems the same as what you have written there, only w/out the "res" param
17:17:38 <mkscrg> kadoban: thanks, i'll check that out
17:17:47 <augur> anyone seen roconnor?
17:17:51 <L8D> pdxleif: but I'm also wanting to have partially built responses
17:18:22 <L8D> so that a response might start with status 200 and certain headers and whatnot but the middleware might change it and such
17:18:24 <pdxleif> Streaming a la conduit, pipes, etc?
17:18:32 <pdxleif> Or just add more headers later on in the process?
17:18:39 <L8D> just add headers
17:18:44 <L8D> and possibly change status code
17:18:52 <pdxleif> Sure, you can do that in WAI
17:19:07 <L8D> so that I as the user don't have to construct one big response object myself
17:19:20 <jxv> L8D, you could use currying for that can't you?
17:19:39 <L8D> jxv: I could've used currying in my last example, but not in my first
17:20:22 <pdxleif> I think lenses for those reponses would be handy
17:20:29 <pdxleif> "modify this field in the response"
17:20:53 <ReinH> mkscrg: no, git submodules are pretty terrible :/
17:21:30 <L8D> pdxleif: I'd really just want to build my own framework/library from the start so I have control over how everything works and I'm not tied to the representations modeled in Network.HTTP
17:21:41 <pdxleif> ReinH: Heya! Making it out to pdxfunc, tonight? David Christiansen's talking about his paper on quasiquoting in Idris.
17:21:59 <L8D> pdxleif: so I can have simplified representations of everything
17:22:00 <ReinH> pdxleif: hey, that's tonight? Awesome!
17:22:08 <pdxleif> L8D: Sure; would be interested to see what you come up with.
17:22:16 <Hodapp> quasiquoting in Idris? this sounds intriguing.
17:22:45 <mkscrg> L8D: i've built convenience code on top of WAI a few times in the past, it's definitely a workable approach
17:22:50 <pdxleif> ReinH: here's the meetup event: http://www.meetup.com/Portland-Functional-Programming-Study-Group/events/213098762/
17:23:19 <pdxleif> Here's a link to the paper: http://www.itu.dk/people/drc/drafts/idris-quasiquote-preproceedings.pdf
17:23:24 <ReinH> pdxleif: Col!
17:23:27 <mkscrg> L8D: using it as low-level infrastructure, i've had a lot of success w/ wai/warp
17:23:29 <ReinH> Er. Cool!
17:23:48 <pdxleif> mkscrg: I'd like to see more lens-y stuff for modifying the responses
17:24:03 <pdxleif> fmap across a response body, I dunno
17:24:46 <kadoban> Would there be any common reason why ghc-mod to check my .hs files got a ton slower? I'm not sure what I changed. I started using sandboxes I guess, but would that do it for some reason?
17:25:24 <kadoban> I have it set up with syntastic to autocheck my files when i save in vim, and it used to only take a couple of seconds, tops...now it's like 7 seconds even on a basically blank file.
17:25:37 <L8D> mkscrg: I'd personally rather not be limited to using shit like Network.HTTP.Types
17:26:08 <mkscrg> pdxleif: lensing over requests would be very handy. my use cases have involved relatively little response transformation
17:26:50 <mkscrg> L8D: is http-types bad? i have no affiliation, though it's served me well so far
17:27:09 <L8D> mkscrg: I would just want to represent status codes as numbers
17:27:23 <L8D> and not use stupid wrappers or predefined variables like status200
17:27:45 <L8D> mkscrg: I would just want to represent request bodies as buffers
17:28:26 <L8D> I would just want to represent headers as a tuple of two strings
17:28:43 <mkscrg> ReinH: daily git user for 5 years, so far i've just built monorepos when cross-project sharing was involved
17:28:44 <L8D> instead of using needless abstractions
17:29:11 <mkscrg> ReinH: lots of things these days are repo-centric though, and making them play nicely with subdirectories is no fun
17:31:39 <mkscrg> L8D: i hear ya. there's definitely space for a high-/mid-level interface there. i treat wai like a low-level API
17:31:57 <mkscrg> e.g. header names *are* case insensitive, whether i actually want to cope w/ that or not
17:33:30 <_2_Jorailys> hi what are you doing
17:41:20 <argent0> I've two functions:
17:41:21 <argent0> modSum base a b = mod (a + b) base
17:41:22 <argent0> modMul base a b = mod (a * b) base
17:41:44 <argent0> How could I generalize the mod part?
17:42:15 <argent0> like: modSum = xxx (+)
17:42:36 <NemesisD> do you mean you want to generalize the + or * part?
17:43:17 <NemesisD> modFoo f base a b = mod (f a b) base
17:43:25 <argent0> NemesisD: I would like "xxx" such that modSum = xxx (+) and modMul = xxx (*)
17:43:42 <NemesisD> then modSum = modFoo (+)
17:44:27 <L8D> argent0: xxx f = base . (mod .) . f
17:44:39 <NemesisD> yeesh
17:45:12 <augur> L8D: dont be obnoxious
17:45:12 <L8D> :t (base . (mod .) .)
17:45:13 <lambdabot>     The operator ‘.’ [infixr 9] of a section
17:45:14 <lambdabot>         must have lower precedence than that of the operand,
17:45:14 <lambdabot>           namely ‘.’ [infixr 9]
17:45:23 <dmj`> anyone off hand have a decimal fromjson instance?
17:45:26 <L8D> :t ((base . (mod .)) .)
17:45:28 <lambdabot>     Couldn't match type ‘a2 -> b -> b’ with ‘Int’
17:45:28 <lambdabot>     Expected type: (a2 -> b) -> Int
17:45:28 <lambdabot>       Actual type: (a2 -> b) -> a2 -> b -> b
17:45:36 <L8D> augur: what do you mean by obnoxious?
17:45:41 <dmj`> the api I'm working with makes decimals strings
17:45:48 <dmj`> so I'm just doing read
17:46:01 <L8D> :t f g = base . (mod .) . g
17:46:02 <lambdabot> parse error on input ‘=’
17:46:07 <augur> argent0: in general, you can do a kind of equational reasoning to figure out what things should be
17:46:09 <NemesisD> IMO point free here does nothing but obfuscate
17:46:23 <L8D> :t \g -> base . (mod .) . g
17:46:24 <lambdabot>     Couldn't match type ‘a2 -> b -> b’ with ‘Int’
17:46:25 <lambdabot>     Expected type: (a2 -> b) -> Int
17:46:25 <lambdabot>       Actual type: (a2 -> b) -> a2 -> b -> b
17:46:29 <L8D> damnit
17:47:01 <augur> L8D: what NemesisD said
17:47:10 <augur> pointfree here is pointless
17:47:29 <argent0> Thanks people!
17:47:32 <L8D> what's so obnoxious about being pointfree?
17:47:49 <NemesisD> its a very common pattern in haskell to specialise a function by pulling out the common code and having the swappable bits be the first argument(s) so your existing implementations can just be partially applied versions of the general function
17:48:13 <NemesisD> L8D: when it makes the code incomprehensible, it turns into a bad idea
17:48:37 <L8D> I find (foo .) . bar comprehensible
17:48:45 <NemesisD> i don't
17:49:05 <L8D> @let foo .. bar = (foo .) . bar
17:49:05 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:49:09 <josephle> the nested composition is not easily intuited
17:49:31 <L8D> @let (.:.) foo bar = (foo .) . bar
17:49:34 <lambdabot>  Defined.
17:49:46 <L8D> wait...
17:50:08 <NemesisD> the more i work in other people's haskell code the more i dislike cleverness
17:50:30 <L8D> but that's like, the best part
17:50:41 <L8D> :t (*2) .:. (+)
17:50:42 <lambdabot> Num c => c -> c -> c
17:50:46 <NemesisD> yeah if you're the one writing it and understanding it its great fun. if you need to get work done it isn't so fun
17:51:14 <L8D> > ((*2) .:. (+))  5 10
17:51:16 <lambdabot>  30
17:51:25 <NemesisD> same goes for leaving off type signatures excessively, i don't want to have to load your thought process into my head completely to understand what a function does if i can avoid it
17:51:49 <L8D> I put type signatures everywhere
17:52:12 <merijn> NemesisD: Cleverness is okay, but "pointless pointlessness" (a pun! :D) is not all that clever, just obfuscation
17:52:29 <NemesisD> me too, and usually if im working on code without the type signatures ,i have my editor put them in for me, unless the type signature is really hairy
17:52:37 <NemesisD> merijn: agreed
17:53:20 <merijn> I have type signatures on all top-level declarations and more and more even on local definitions
17:53:34 <L8D> NemesisD: can you read this at all? https://gist.github.com/L8D/70b724e5156363e76012
17:53:40 <merijn> And lots of small, named local definitions > point-free
17:54:04 <merijn> L8D: FYI
17:54:19 <merijn> L8D: GHC 7.8 has "readMaybe :: Read a => String -> Maybe a" in Text.Read
17:54:26 <josephle> once I put a comment in my SML code "This fold is too clever for my own good". A month later, I cursed my old self for being right.
17:55:03 <merijn> L8D: It looks ok
17:55:09 <NemesisD> L8D: i'm not going to try to understand it ATM but in general it looks reasonable
17:55:14 <L8D> yeah I need to put more things inside where blocks
17:55:17 <merijn> L8D: Why does "words" return "IO [Double]"?
17:55:25 <merijn> eh, word
17:55:45 <L8D> merijn: the memory of an RL program is a stack of doubles
17:56:09 <merijn> L8D: Yes, but why *IO*?
17:56:14 <L8D> word takes a word, a dictionary of words, the current stack, and the rest of the words in the program
17:56:28 <merijn> None of the types seem to use IO?
17:56:39 <L8D> merijn: currently the only IO word is "."
17:56:43 <L8D> for printing stuff
17:56:56 <L8D> there would be more but I'm too lazy to implement the full spec
17:57:09 <dfeuer> L8D, newtype is generally either for making an ADT or for making something an instance of a class. You're doing neither with Dict.
17:57:35 <L8D> dfeuer: I'm using it to make a recursive definition
17:57:43 <merijn> dfeuer: Also for type-safety
17:57:51 <dfeuer> L8D, oh, I see new.
17:58:02 <dfeuer> Didn't see the mutual recursion.
18:04:31 <davidstone> Hello
18:04:57 <davidstone> I have been thinking a bit about error handling in Haskell as an outsider (C++ is my native language), and perhaps someone can help me out
18:05:12 <davidstone> Why does Integer / Integer return Integer instead of Maybe Integer?
18:05:40 <davidstone> Is it simply for convenience of syntax for a common operation or is there deeper semantic idea?
18:06:06 <L8D> davidstone: when would Integer / Integer ever need to return Nothing ?
18:06:08 <davidstone> For instance, is the thought that division by 0 is always a bug, so the function should throw an exception rather than returning a maybe type?
18:06:10 <josephle> probably because div-by-zero doesn't return nulls in every other language
18:06:17 <johnw> because Haskell also supports exceptions
18:06:22 <davidstone> L8D: Divide by 0
18:06:23 <johnw> which can be much more convenient in cases where the exceptional result is very rare, or it would be inconvienent to discriminate success from failure in the result type
18:06:37 <L8D> davidstone: you just get Infinity
18:06:49 <josephle> > 1.0 / 0.0
18:06:51 <lambdabot>  Infinity
18:06:54 <johnw> davidstone: you could always write a safeDivide function, to return Maybe Integer
18:07:01 <davidstone> My understanding is this is true for floating point values but not integers
18:07:04 <davidstone> 1 / 0
18:07:07 <johnw> although I presume your question is, why isn't this the default behavior
18:07:17 <L8D> :t 1 /
18:07:18 <L8D> :t 1 / 0
18:07:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:07:19 <lambdabot> Fractional a => a
18:07:27 <josephle> > 1 `div` 0
18:07:28 <gcganley> shouldnt 1/0 be undefined?
18:07:29 <lambdabot>  *Exception: divide by zero
18:07:41 <gcganley> not exception
18:07:54 <gcganley> or is undefined == bottom
18:08:10 <josephle> gcganley: undefined is an inhabitant of bottom
18:08:15 <kadoban> gcganley: undefined is mostly just a convenience when you're stubbing things out
18:08:31 <BMeph> gcganley: 0/0 should be undefined, certainly, but 1/0 not only has a definition, it IS a definition! ;)
18:08:31 <josephle> or wait, undefined == bottom
18:09:04 <gcganley> > @src undefined
18:09:06 <lambdabot>  <hint>:1:1: parse error on input ‘@’
18:09:18 <gcganley> @src undefined
18:09:18 <lambdabot> undefined = error "Prelude.undefined"
18:09:32 <johnw> josephle: undefined always evaluates to bottom :)
18:09:44 <johnw> at every type
18:09:45 <josephle> johnw: yeah, I mixed up bottom with void
18:10:27 <ski> @tell hughfdjackson hm, i think your BNF alternative for division isn't quite right, even disregarding the associativity problem
18:10:27 <lambdabot> Consider it noted.
18:10:35 <merijn> gcganley: No, because Double division by 0 is not an error
18:10:37 <gcganley> is _|_ bottom?
18:10:43 <johnw> yes
18:10:44 <gcganley> :t _|_
18:10:45 <lambdabot> parse error on input ‘|’
18:10:50 <gcganley> nope
18:10:51 <josephle> anyway, divide by zero is generally a exception thrown by the processor
18:10:53 <johnw> we say _|_ in the channel
18:10:57 <johnw> but it's not anything Haskell knows about
18:11:15 <merijn> gcganley: IEEE754 specifies division by 0 as positive/negative infinity or NaN
18:11:17 <gcganley> johnw: oh ok i thought that would look like bottom so i didnt know if it was defined
18:11:27 <gcganley> merijn: interesting...
18:11:31 <johnw> undefined is what you use to specifically state "bottom"
18:11:37 <merijn> gcganley: _|_ is the ascii rendering of the math "bottom" symbol
18:11:47 <johnw> ⊥
18:11:54 <sclv> by analogy to T, for top
18:12:03 <gcganley> johnw: wow i didnt realise my emacs was unicode.....
18:12:08 <johnw> haha
18:12:18 <johnw> can you see ☃?
18:12:21 <ReinH> undefined is an IO exception that can be caught, so it isn't *quite* bottom
18:12:26 <Fuuzetsu> can't everyone ;^)
18:12:27 <gcganley> johnw: yes i can
18:12:34 <merijn> ReinH: Yes it is
18:12:40 <merijn> ReinH: All IO exceptions are bottom too
18:12:45 <Fuuzetsu> it's disappointing that Agda doesn't have an input for SNOWMAN though
18:12:47 <L8D> how does one catch io exceptions?
18:12:49 <ReinH> merijn: Ehh...
18:12:51 <johnw> how about 🍜?
18:12:54 <ReinH> merijn: Fair enough.
18:13:01 <gcganley> johnw: nope, is that an emoji?
18:13:02 <merijn> ReinH: Hence why IO exceptions are indiscernable according to the "a semantics for imprecise exceptions"
18:13:04 <johnw> yeah
18:13:08 <Fuuzetsu>   name: STEAMING BOWL
18:13:11 <Fuuzetsu> no font ;(
18:13:14 <johnw> ok, so we've discovered what math I can talk about and what I can't
18:13:19 <gcganley> johnw: is it the steaming pile of crap?
18:13:21 <davidstone> johnw: So you would say that the primary reason to use exceptions in Haskell over Maybe or Either is for convenient syntax where you expect errors to be uncommon
18:13:24 <ReinH> johnw: you can't talk about steaming bowls
18:13:25 <ReinH> shame
18:13:26 <johnw> no, it's ramen noodle soup
18:13:33 <merijn> ReinH: Which leads to confusing things like "case 1 of 1 -> error "foo"; _ -> error "blah"" being allowed to return "error "blah""
18:13:40 <johnw> davidstone: I have not yet found a simple way to state it
18:13:44 <Fuuzetsu> talking about ramen at nearly 3 am is outright rude
18:13:48 <ReinH> merijn: fair enough
18:13:54 <johnw> I think exceptions are best suited to conditions that are exceptional -- i.e., peripheral to the algorithm
18:13:59 <johnw> like, errors in your assumptions about the state of the owrld
18:14:04 <johnw> such as a network connection dropping on you
18:14:12 <merijn> johnw: I think exceptions are best used for things like go's "panic"
18:14:12 <johnw> whereas Maybe/Either is better for errors directly concerning the algorithm itself
18:14:22 <davidstone> OK, so it's more the idea of post-conditions and single responsibility
18:14:24 <johnw> like whether a  compressed data stream matches its checksum
18:14:29 <merijn> i.e. "unwind back to a 'resume' point"
18:14:31 <davidstone> Your function does a single thing, and exceptions are saying that it is unable to do that thing
18:14:50 <johnw> exactly
18:15:07 <merijn> davidstone: I mostly use them in, for example, inner loops of network handling where my "error handling" is basically "return to top level server loop"
18:15:19 <gcganley> can hole fit into undefined?
18:15:34 <L8D> > try (evaluate (5 `div` 0))
18:15:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable e0)
18:15:36 <lambdabot>    arising from a use of ‘M736028232624904800219435.show_M7360282326249048002...
18:15:36 <lambdabot>  The type variable ‘e0’ is ambiguous
18:15:36 <lambdabot>  Note: there are several potential instances:
18:15:36 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:15:48 <merijn> davidstone: IMO exceptions should *never* be thrown by an API normally. Exception throwing variations of non-throwing functions are ok.
18:16:04 <L8D> > try (evaluate (5 `div` 0 :: Int))
18:16:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable e0)
18:16:06 <lambdabot>    arising from a use of ‘M299466488584686876019447.show_M2994664885846868760...
18:16:06 <lambdabot>  The type variable ‘e0’ is ambiguous
18:16:06 <lambdabot>  Note: there are several potential instances:
18:16:06 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:16:11 <L8D> sry
18:16:15 <Fuuzetsu> L8D: it doesn't know the type of exception
18:16:18 <merijn> davidstone: So that application writers can use them, but never run into them (except maybe IO exceptions)
18:16:21 <L8D> oooh
18:17:37 <ReinH> merijn: so what do you think of, e.q, wreq?
18:17:53 <gcganley> :t _
18:17:54 <davidstone> Are those two libraries?
18:17:54 <lambdabot>     Found hole ‘_’ with type: t
18:17:55 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
18:17:55 <lambdabot>                the inferred type of it :: t at Top level
18:17:59 <ReinH> merijn: I tend to think that functions that provide IO actions can throw exceptions when fully saturated.
18:18:53 <ReinH> Seems to be pretty common, really?
18:21:58 <xpika> join #math
18:23:29 <merijn> ReinH: I think they should return Either by default
18:23:39 <merijn> ReinH: I'm okay with exception throwing alternatives
18:23:55 <merijn> ReinH: But with unchecked exceptions I find it to hard to know when I've handled all cases :\
18:24:44 <johnw> I use Either to indicate that a total function can reasonably say "no", and exceptions to indicate that either the function says "yes" or it fails in a way that requires intervention or cleanup by other code
18:25:30 <davidstone> Does Haskell have the concept of "this function does not throw exceptions" (noexcept in C++)
18:25:59 <johnw> davidstone: sadly, no
18:26:26 <davidstone> So exceptions are not part of the signature of a function in any way
18:26:33 <merijn> davidstone: Nope :(
18:26:36 <johnw> because even if the function never throws an exception, still an asynchronous exception could occur during its evaluation
18:26:57 <davidstone> I don't understand what you mean
18:26:58 <johnw> davidstone: there is a library that gives you exception signatures
18:27:01 <merijn> davidstone: It's a bit of an open issue how you would sensibly include that in the type signature
18:27:12 <merijn> davidstone: Threads can have exceptions thrown to them externally
18:27:20 <johnw> an asynchronous exception is analogous to a signal in C world
18:27:23 <merijn> davidstone: Like a signal
18:27:56 <johnw> I bet merijn and I represent the opposite sides of the exception handling camp, so you're getting fair representation here :)
18:31:46 <ReinH> heh
18:35:47 <Fuuzetsu> Segmentation fault ;(
18:41:20 <dfeuer> OK, I'm banging my head against a wall here, and I know there's a nice way to do this. Basically, I want to encapsulate the concept of combining the results of lazy reads of multiple files.
18:41:57 <dfeuer> Nested withFile thingums, ensuring that the finall result is fully forced, and allowing any number of files.
18:42:01 <dfeuer> *final
18:50:55 <michaelt> dfeuer: when you say 'nested withFiles' do you mean, whether one file is opened depends on what another file said? What determines when you are done reading the file?
18:51:39 <dfeuer> michaelt, ideally, yes, there would be something monadish about it. It would expand to things like this:
18:52:26 <michaelt> dfeuer: I was just trying to think if there is some pipish conduitish approach, but I take it you've considered that...
18:55:28 <dfeuer> withFile "file1" ReadMode $ \h1 -> withFile "file2" ReadMode $ \h2 -> hGetContents h1 >>= \c1 -> hGetContents h2 >>= c2 >>= return $!! f c1 c2
18:55:41 <dfeuer> michaelt, no, I don't know how to even use those yet :P
18:55:43 * hackagebot hidapi 0.1.3 - Haskell bindings to HIDAPI  http://hackage.haskell.org/package/hidapi-0.1.3 (NiklasHambuechen)
18:55:45 * hackagebot hemokit 0.6.4 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.4 (NiklasHambuechen)
18:57:17 <dmj`> dfeuer: do you plan on openining a lot of files?
18:57:21 <dmj`> opening
18:57:29 <michaelt> I see, with outright laziness, you won't be able to declare either file done until both are done, here.
18:58:32 <dfeuer> michaelt, yes, but "done" in the sense that the final result has been forced, not in the sense that the file is completely read.
18:58:54 <dfeuer> dmj`, I'm just thinking about the general problem of creating a sane interface for this sort of thing.
18:59:13 <michaelt> if "h s s'" means, say,  "s and s' agree for n characters"
19:00:15 <dmj`> dfeuer: I'd avoid lazy I/O as a general rule
19:00:52 <dmj`> dfeuer: https://galois.com/blog/2008/09/left-fold-enumerators-a-safe-expressive-and-efficient-io-interface-for-haskell/
19:01:24 <cdk> I do "cabal configure --enable-executable-profiling; cabal run -- -RTS -p" but I dont see any .prof files being output. Can I specify where I want the profiling information to be sent?
19:01:58 <dfeuer> dmj`, how's that relate to pipes and conduit and things people seem to use a lot these days?
19:03:00 <michaelt> dfeuer: it's another version of the same ...
19:03:41 <dfeuer> And is there any consensus about which of these things makes the most sense?
19:03:46 <dmj`> dfeuer: it's the same concept, discovered by oleg I believe: http://okmij.org/ftp/Streams.html
19:04:28 <michaelt> I hadn't realized the fancy weather system associated with Oleg is "partly re-written in Haskell." Nice.
19:04:30 <dfeuer> Yes, I have read that Oleg came up with some notion of "iteratees" and a bunch of people came up with ways to think about them, but it's all a little mysterious.
19:06:22 <Fuuzetsu> what fanacy wheather system?
19:06:42 <Fuuzetsu> fancy*
19:06:51 <Fuuzetsu> weather*
19:08:35 <dfeuer> Fuuzetsu, knowing Oleg, it probably operates in three modes: one to analyse weather history, one to predict weather, and one to adjust the weather.
19:09:12 <michaelt> Fuuzetsu: I was just looking at http://www.deinprogramm.de/defun-2008/abstracts/oleg-abstract.txt linked in the page dmj` linked
19:09:57 <dmj`> dfeuer: there is a good haskell cast where the pipes and conduits authors discuss the concept and their implementation
19:11:09 <tomboy64> i need to create a lazy lookup data-structure for a couple of billion entries. i only need to get a few of those entries. Data.IntMap.Lazy is not suitable cause it's strict in the values. other suggestions, apart from a generic list?
19:13:34 <carter> Hey alll : is there a way to export only a few instances ofa Data Family?
19:15:58 <Fuuzetsu> I suspect the answer to that is ‘no’.
19:16:13 <carter> i sense a GHC feature request in my future
19:16:17 <carter> Fuuzetsu: actually
19:16:20 <carter> maybe you can help me
19:16:29 <johnw> but do you also sense a future in your GHC feature request...
19:16:45 <carter> johnw: yes
19:16:57 <carter> because either Haddock is lying to me
19:17:01 <carter> or GHC is trolling me
19:17:05 <Fuuzetsu> maybe both!
19:17:10 <carter> yes!
19:17:25 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Shape.hs#L36-L37
19:17:27 <Fuuzetsu> I think I just discovered One Weird Trick™ to get concurrency in Yi
19:17:36 <carter> cool
19:17:37 <carter> Fuuzetsu:
19:17:38 <carter>  ,UV.Vector(UV.V_ShapeZ,UV.V_ShapeSZ,UV.V_ShapeSSN)
19:17:39 <carter> ,UV.MVector(UV.MV_ShapeZ,UV.MV_ShapeSZ,UV.MV_ShapeSSN)
19:17:42 <carter> is the export lines
19:17:48 <carter> but the haddocks have ALLLL the instances
19:18:21 <Fuuzetsu> what shows if you :browse the module?
19:18:29 <michaelt> carter, but does ghc think you're exporting them all?
19:18:30 <carter> http://www.wellposed.com.s3.amazonaws.com/examples-cached/numerical-0.1-prerelease-docs/Numerical-Array-Shape.html#t:MVector
19:19:15 <carter> how do i use :brows
19:19:32 <dfeuer> dmj`, Haskell cast?
19:19:54 <carter> Fuuzetsu: its just haddock trolling me :)
19:19:55 <michaelt> carter: that does look pretty dreadful
19:19:57 <Fuuzetsu> just :browse Your.Module.Name
19:20:03 <carter> michaelt: yeah i know
19:20:07 <carter> it shows all the other instances
19:20:28 <dfeuer> carter, can you do something like Foo(X,Y)
19:20:29 <Fuuzetsu> I think we don't discriminate and just spit out everything GHC tells us about
19:20:36 <carter> dfeuer: i am doing that
19:20:39 <carter> http://lpaste.net/112551
19:20:57 <Fuuzetsu> so either GHC is leaking too much or there's a thing it sets that says it's not exported and we're not checking it
19:21:10 <carter> Fuuzetsu: how can I help
19:21:20 <carter> well
19:21:27 <dfeuer> carter, how's that relate? GHCI doesn't respect module boundaries so much.
19:21:53 <dmj`> dfeuer: http://www.youtube.com/watch?v=Qn2Oc4vWoGg
19:22:00 <Fuuzetsu> I guess the best way to check is to make a module that imports that one and try to use an instance
19:22:01 <carter> dfeuer: youre not helping
19:22:44 <carter> *Numerical.Matrix.Basic Numerical.Array.Shape> :t V_Bool<interactive>:1:1: Not in scope: data constructor ‘V_Bool’
19:22:47 <Fuuzetsu> carter: a good start towards filing this as a bug would be a tiny, 2-module test-case
19:22:52 <carter> ok
19:23:09 <Fuuzetsu> I don't know if it's Haddock or GHC though ;/
19:23:16 <carter> ok
19:23:21 <carter> well
19:23:31 <carter> lemme cookup a mini cabalization
19:23:32 <Fuuzetsu> well, I think it's a bug that GHC API leaks it out so maybe put it on Trac
19:23:43 <Fuuzetsu> cabal doesn't help with such tickets
19:24:04 <Fuuzetsu> in fact it gets in the way
19:24:09 <carter> ok
19:24:36 <Fuuzetsu> just ‘haddock -h Module1.hs Module2.hs -o /tmp/foo’ should work
19:25:26 <joefiori_> can anyone help me figure out why this won't compile? `url <- liftM fst getArgs`
19:25:39 <carter> joefiori_: try fmap instead of liftM
19:26:13 <joefiori_> carter: same error
19:26:23 <carter> what error
19:26:26 <Fuuzetsu> (fmap . fmap) fst getArgs
19:26:34 <joefiori_> Couldn't match type ‘[String]’ with ‘(String, b0)’
19:26:43 <Fuuzetsu> oh, that's right
19:26:51 <Fuuzetsu> do you want ‘fmap head getArgs’ instead?
19:27:01 <joefiori_> oh
19:27:03 <joefiori_> d'oh
19:27:19 <joefiori_> fst is for tuples
19:27:36 <joefiori_> liftM works too
19:27:52 <Fuuzetsu> head <$> getArgs
19:28:05 <joefiori_> Fuuzetsu: good call
19:28:17 <Fuuzetsu> I recommend you don't use head though ;)
19:28:37 <joefiori_> Fuuzetsu: why not?
19:28:49 <Fuuzetsu> because it will crash if you don't pass in any args
19:29:08 <joefiori_> I was surprised args isn't a Maybe
19:29:17 <joefiori_> Fuuzetsu: any hints on what to look at instead?
19:29:46 <carter> Fuuzetsu: so the goal where is to repro that funny haddocks leakage?
19:29:58 <carter> and have another module that demonstraints that its not exported none the lesss?
19:29:59 <Fuuzetsu> I'd just do ‘getArgs >>= \case { x:_ -> doSomethingWith x; [] -> handleNoArgs }’
19:30:42 <joefiori_> Fuuzetsu: thanks
19:30:43 <Fuuzetsu> carter: more or less; the ultimate goal is to be able to blame the right party but the small test case sure helps to do that
19:30:50 <carter> yeah
19:33:16 <michaelt> carter, this module is pretty hairy; you need {-#LANGUAGE UndecidableDocumentation#-}
19:34:37 <carter> michaelt: i supposed I could use CPP to hide that export when Haddock runs
19:35:31 <carter> Fuuzetsu: how would I hide code from haddock with CPP?
19:35:34 <carter> (just in case :) )
19:35:53 <Fuuzetsu> uh
19:36:03 <Fuuzetsu> IIRC there's some pragma but I forget what it was
19:36:13 <Fuuzetsu> and it's a cabal thing too I believe
19:36:44 <carter> yeah
19:36:55 <carter> i'm just figguring out ways to make my haddocks look prettier
19:37:06 <carter> i suppose i dont' need to export those constructors  realistically
19:37:11 <carter> but id like to be able to :)
19:37:16 <Fuuzetsu> is there a ‘killYourself’ function that kills current thread? Would ‘myThreadId >>= killThread’ DWIM?
19:37:25 <michaelt> ghc uses some haddock hiding machinery, no?
19:37:36 <michaelt> I mean the ghc source does
19:39:16 <Fuuzetsu> a silly way would be to use the prune Haddock pragma and document everything else ;P
19:39:25 <Fuuzetsu> but I don't remember if it works with instances anyway
19:39:28 <michaelt> oh, yeah this.  {-# OPTIONS_HADDOCK hide #-}
19:39:45 <carter> those dark tricksy corners
19:39:48 <carter> Fuuzetsu: while i work on that
19:39:54 <carter> how're you making Yi more parallel?
19:40:13 <Fuuzetsu> concurrent*
19:40:20 <carter> oh
19:40:21 <carter> fine
19:40:21 <carter> :)
19:40:34 <Fuuzetsu> I just found a YiM () → IO () function that looks like it might work, it seems to work
19:41:15 <Fuuzetsu> I'll stick it into tomorrow's release with a warning that I have no idea about it ;P
19:41:46 <dmj`> are there any haskell packages for decoding / encoding audio?
19:42:48 <carter> probably
19:52:24 <AshyIsMe> Fuuzetsu: how usable is Yi so far?
19:52:56 <AshyIsMe> besides normal vim usage i'd need fugitive, ctrlp and syntastic to be able to use it i think
19:53:07 <AshyIsMe> and tags
19:53:32 <Fuuzetsu> we don't have those things yet so that probably answers your question
19:53:47 <Fuuzetsu> we had good improvements recently but we still have some fundamental issues
19:54:54 <carter> like what?
19:56:26 <Roselyn23>  Watch Me Suck Real Big Dick On My Site http://j.mp/Rh9YfS
19:56:32 <carter> dibblego: ping
19:57:39 <Fuuzetsu> concurrency, bad lexer performance, no mode composability, no in-editor documentation, some problems in how we currently do text rendering in pango, no features required for many of the modes (text properties) &c &c
19:57:47 --- mode: ChanServ set +q *!*@5.254.97.109
20:02:02 --- mode: ChanServ set -q *!*@5.254.97.109
20:03:32 <dmj`> cool article on mp3 decoding in haskell: http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
20:04:22 <carter> Fuuzetsu: i'll sort out that repro tomrrow
20:04:58 <Fuuzetsu> sure, I have my hands full of things to do without chasing extra bugs
20:05:01 <carter> :)
20:05:25 <Basketball> what os tjos cjamme;
20:05:31 <Basketball> this channel
20:05:33 <Basketball> what is it
20:05:49 <ddellacosta> Basketball: #haskell
20:05:49 <Fuuzetsu> It's a channel dedicated to the Haskell programming language.
20:06:01 <Basketball> what language is that
20:06:32 <ddellacosta> Basketball: check out the main page, lots of good descriptive stuff there: http://www.haskell.org/haskellwiki/Haskell
20:06:39 <Basketball> bye
20:06:53 * ddellacosta *sniffs*
20:07:48 <carter> lol
20:08:00 <ddellacosta> rejection is so painful
20:11:05 <L8D> wtf
20:19:25 * michaelt hugs poor ddellacosta 
20:19:43 * ddellacosta thanks michaelt, sobbing
20:20:05 <L8D> but like why was Basketball even here in the first place?
20:20:07 <L8D> like wut
20:20:17 <L8D> I don't even
20:21:14 <carter> he wanted to distract you from coding
20:24:33 <gansteed> Is there someone using Xmonad?
20:24:42 <gansteed> how can I shift all vbox vms into a specific workspace?
20:24:51 <gansteed> I've tried `resource =? "Virtualbox --> doShift "3-vbox"`, but it doesn't work
20:24:52 <Fuuzetsu> use the class of the window
20:25:26 <Fuuzetsu> gansteed: use xprop to find out the class name
20:25:35 <joejev> I am working on a compiler for a toy language, and I want to allow for different targets. Currently, I have a parsing function of type PNode a => [Node] -> ([(Int,[a])],[a]) and an instance of PNode. I somehow want to write a general form where I have some data type that holds the [a] -> String function for a given type
20:25:52 <Fuuzetsu> gansteed: there's #xmonad you should ask in if you have more troubles
20:26:23 <joejev> However, then I need a type that has the Instance and the compile function
20:26:25 <gansteed> I have, but nobody there active
20:27:07 <Fuuzetsu> phew, I thought I closed my emacs
20:27:49 <gansteed> Fuuzetsu: output is  WM_CLASS(STRING) = "Qt-subapplication", "VirtualBox"
20:28:09 <Fuuzetsu> gansteed: neither of those strings are what you put in above
20:28:47 <Fuuzetsu> AFAIK you want Qt-subapplication in this scenario
20:31:04 <gansteed> I'm sorry, can you show me a little more detail?
20:34:20 <Fuuzetsu> not really, you had the right code just with the wrong class
20:34:26 <gansteed> `resource =? "Qt-subapplication" --> doShift "3-vbox"` doesn't work, too
20:34:50 <gansteed> Okay
20:35:17 <Fuuzetsu> it should be className =? …
20:35:21 <Fuuzetsu> not resource =? …
20:35:57 <Fuuzetsu> I use doShift in my config although I don't know how much use that will be to you http://lpaste.net/112552
20:36:19 <cristian4> Hey guys... is there a way to open a URL in the default browser from Haskell? In OSX we have the `open` command which does that, but I'd prefer a cross-platform solution.
20:36:47 <dmj`> cristian4: shell "open"
20:36:51 <gansteed> Fuuzetsu, thanks
20:37:12 <Loomimags> I am knew to the Haskell community. To create a wiki account do I just email haskell-cafe@haskell.org and give them my preferred username. This is my first time doing this.
20:37:14 <Fuuzetsu> is there a function that tells you if the thread already died?
20:37:28 <dmj`> Fuuzetsu: you can check a threads status
20:37:59 <dmj`> isRunning
20:37:59 <Fuuzetsu> Loomimags: e-mail nominolo on gmail
20:38:14 <Fuuzetsu> @hoogle isRunning
20:38:16 <lambdabot> GHC.Conc.IO ensureIOManagerIsRunning :: IO ()
20:38:16 <lambdabot> GHC.Conc ensureIOManagerIsRunning :: IO ()
20:38:30 <Fuuzetsu> dmj`: from what module?
20:38:32 <Loomimags> fuuzetsu: thanks
20:38:43 <dmj`> oh...
20:39:13 <cristian4> dmj`: I don't completely understand... is there an "open" function somewhere?
20:39:19 <Lutin`> cristian4: Just use different things based on the OS
20:39:37 <dmj`> :t threadStatus
20:39:38 <lambdabot> Not in scope: ‘threadStatus’
20:39:39 <dmj`> GHC.Conc
20:39:45 <Fuuzetsu> ok
20:40:04 <cristian4> Lutin`: thanks for the suggestion. If I can't find anything I'll go that route
20:40:20 <Lutin`> open on OSX, 'rundll32 url.dll,FileProtocolHandler ' + url on windows, and for linux you can try 'xdg-open' and several common browser names
20:40:28 <Lutin`> most linux installs would have xdg-open though
20:40:43 <cristian4> Thanks
20:41:13 <yyttr3> How to I make a module globally visual in a project?  If I have a module in a different folder than main (but in same project) I can't import it.
20:41:43 <Fuuzetsu> yyttr3: use -i to specify source directories
20:42:05 <Fuuzetsu> usually you'd just have one source directory and have a module hierarchy under it
20:42:19 <Fuuzetsu> (maybe another one for tests and another for benchmarks)
20:42:41 <Fuuzetsu> cabal has source-directories
20:42:45 <Fuuzetsu> &c &c; it depends on your setup
20:42:56 <michaelt> yyttr3: if the diectory is Data and the module (Data.YYTTR3) is called YYTTR3.hs, then it should be visible, or is that the problem?
20:43:51 <yyttr3> I have a Mips.Parse and a Mips.Types and Mips.Cpu  ect
20:44:06 <yyttr3> They each need to refer to modules in another folder
20:44:07 <michaelt> yyttr3: then ghci Main.hs will know where to find the needed "import Data.YYTTR3"
20:44:42 <yyttr3> Above the Mips folder is the project directory
20:44:51 <yyttr3> Where the .cabal file is kept
20:45:19 <michaelt> so Main.hs should be outside the Mips folder
20:45:27 <michaelt> oh
20:45:44 <yyttr3> Well how does each module import other modules?
20:45:49 <michaelt> no, I was thinking correctly...
20:46:57 <michaelt> if cabal or ghc is in a directory with Mips and Bips, then Bips.X  can import Mips.Y and the machinery will figure it out
20:48:14 <yyttr3> But what about Mips.X.Y.hs and Mips.Z.K.hs?
20:48:28 <yyttr3> I can do flat directories
20:48:40 <yyttr3> but if they're nested then it doesn't seem to do it automatically
20:49:00 <michaelt> yyttr3: I may be misunderstanding, but if the project is called mips, the directory should be called mips and contain mips.cabal, in mips there should be the directory mips/Mips if cabal is to see Mips.X
20:49:04 <yyttr3> No
20:49:40 <michaelt> not thqt the project name really matters...
20:49:55 <yyttr3> They project is called MipsProject which contains Mips,Setup.hs,etc .. Mips contains directories CPU,Types,Parse which each contain .hs files
20:50:23 <michaelt> right, ok, and are the modules called, e.g. Mips.CPU
20:50:24 <Fuuzetsu> Mips.CPU goes into Mips/CPU.hs
20:50:49 <michaelt> as Fuuzetsu is saying
20:51:01 <yyttr3> Yea, I have one module called Mips.Parse.User representing Mips/Parse/User.hs
20:51:08 <yyttr3> Or really
20:51:14 <yyttr3> MipsProject/Mips/Parse/User.hs
20:51:56 <michaelt> yyttr3: abd they are all listed in mips.cabal or MipsProject.cabal?
20:52:26 <yyttr3> Under exposed-modules? Yes
20:52:38 <yyttr3> I've sandboxed and installed the module as well
20:52:50 <yyttr3> But I can't import between Mips.CPU and Mips.Types
20:53:12 <michaelt> and still, say 'cabal configure' is confused?
20:53:40 <michaelt> yyttr3: they cant import each other, but thats a different point
20:57:11 <yyttr3> michaelt: That is what I need?
20:57:27 <michaelt> what?
20:57:49 <michaelt> oh 'cabal configure' is contained in 'cabal install' if thats what you mean
20:58:46 <michaelt> the sandbox is inside the MipsProject directory?
20:59:02 <yyttr3> Can I just manually make ghc look in specific files for imports?
20:59:10 <yyttr3> michaelt: Yes it is
20:59:23 <michaelt> I tend to get less confused if I keep it outside the cabalized directory, but that is probably just my problem...
21:02:04 <yyttr3> michaelt: Even if I say ghc -i../Parse/ test.hs  (where test.hs contains an import), it still says it can't find the module.
21:02:04 <michaelt> yyttr3: then in the outer directory that contains MipsProject  I do cabal sandbox init and then, in the simplest case `cabal install ./MipsProject'
21:02:48 <yyttr3> michaelt: Alright, installing
21:04:24 <michaelt> then for things like test.hs I put them in a subdirectory alongside MipsProject, and use things like ghc  -package-db ../.cabal-sandbox/x86_64-osx-ghc-7.8.0.20140228-packages.conf.d
21:04:47 <michaelt> which are shamelessly aliased in my .profile ...
21:06:01 <michaelt> if you use cabal repl in the directory that has the sandbox you should be able to load :l test.hs as well
21:06:50 <michaelt> yyttr3: no doubt I am imparting worst practices ...
21:08:44 <yyttr3> michaelt: I've never used cabal repo
21:08:47 <yyttr3> repl*
21:10:05 <yyttr3> What is -package-db?
21:10:29 <michaelt> yyttr3: just start it in the dir that has the sandbox. then when you 'import Mips.X' it should know what you want. similarly if you :l test.hs it will know what test.hs wants
21:11:17 <michaelt> yyttr3: it just tells ghc where to look for the relevant compiled libraries -- not e.g. in your local ~/.cabal for instance
21:12:04 <michaelt> without the directive it will look at the global and local package registries
21:12:30 <michaelt> yyttr3: these are the ones that are listed if you do ghc-pkg list.
21:13:17 <michaelt> with cabal repl it is looking at the sandbox, whose contents are exhibited by 'cabal hc-pkg list'
21:13:40 <yyttr3> michaelt: This is what I wanted to know :D Thank you I'll look this up
21:13:45 <michaelt> similarly, with hc  -package-db ../.cabal-sandbox/x86_64-osx-ghc-7.8.0.20140228-packages.conf.d and the like you are doing this explicitly
21:14:00 <michaelt> ghc, not hc there...
21:14:21 <yyttr3> So that's the only way to make packages globally visible within a sandbox?
21:14:56 <michaelt> its the way to tell ghc or ghci directly, since they dont have sensitivity to a sandbox directory.
21:15:51 <michaelt> but say cabal repl (in a sandbox directory) looks into the packages compiled inside the sandbox
21:16:08 <kadoban> Does ghc-mod work with cabal sandboxes? or is there some way i can make it?
21:17:28 <yyttr3> michaelt: If you don't mind also, how do I rebuild a project with cabal? When I call cabal install -j again it creates new folders, not update them
21:35:19 <michaelt> yyttr3: right, I think that's a feature of cabal install.  if you first just do cabal configure, then every time you do `cabal build` it just rebuilds what it needs to.
21:35:52 <michaelt> but this will conflict with a little with the advice I was giving above.
21:35:53 <derivedFunctor> what's the view on making use of existensial types to have lists of things that implement only a certain typeclass? is that considered bad form?
21:36:12 <merijn> derivedFunctor: Bad form, see:
21:36:17 <merijn> @where existential-antipattern
21:36:17 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
21:36:21 <derivedFunctor> sadness.
21:36:29 <michaelt> Its bad form if you could just write an equivalent data type
21:36:32 <derivedFunctor> merijn: thanks.
21:36:43 <merijn> derivedFunctor: The solution is to not use a typeclass, you can easily replace said class with a data structure, see:
21:36:43 <derivedFunctor> i tried for a while and couldn't work out how to do it without this.
21:36:45 <jle`> there is almost nothing that you can gain from it
21:36:54 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
21:36:55 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
21:36:55 <lambdabot> Title: Haskell for all: Scrap your type classes
21:36:56 <jle`> that can't be done with normal types
21:37:04 <jle`> which are first class
21:37:22 <derivedFunctor> thanks i will read these things.
21:37:25 <jle`> *normal data
21:37:37 <merijn> derivedFunctor: Gabriel's blogposts illustrated how you can (for example) implement Monad without typeclasses as an example
21:38:25 <Cale> derivedFunctor: Usually you don't need existentials for that, and can simply use data structures containing the operations
21:39:23 <ski> derivedFunctor : sometimes it could be reasonable to use existentials for such, but commonly people seem to reach for existentials when avoiding them would be better
21:39:26 <michaelt> derivedFunctor: there are cases, like Control.Exception but that's pretty radically unlike other things
21:40:05 <merijn> The only use I've had for existentials so far is "existential + Typeable" to force GHC into doing something my type hacker can prove safe, but GHC cannot see is safe
21:40:05 <derivedFunctor> i'd like to avoid it
21:40:46 <derivedFunctor> the case i came up with it for is having say a list of nodes in a tree; and all the nodes have some way of calculating a cost based on some data. they all have different data, but all will result in a single `cost` call
21:41:06 <derivedFunctor> so i made a node with the `cost` thing; but couldn't represent having different node types (i.e. nodes with different data structures) in the tree
21:41:16 <derivedFunctor> but i'm quite new to haskell
21:41:24 <Cale> derivedFunctor: Why not just put the costs in the list instead?
21:41:26 <derivedFunctor> so i'm likely doing the wrong thing.
21:41:42 <derivedFunctor> Cale: the costs have to be calculated, based on surrounding nodes.
21:41:56 <Cale> Okay, so they're functions of some additional stuff?
21:42:40 <derivedFunctor> yeah. so i have a `Nodelike node` typeclass that essentially has a `cost :: node -> Double`
21:42:41 <Cale> What's the type class you'd be capturing in the existential?
21:43:11 <derivedFunctor> my existential thing is: data Nodeable = forall a. (Nodelike a) => Nodeable a
21:43:28 <derivedFunctor> so i can put Nodelike things in a list
21:43:32 <derivedFunctor> and always call `cost` on them
21:44:01 <Cale> Why not:  data Nodeable = Nodeable { cost :: Double }
21:44:23 <derivedFunctor> so i have: data Node1 = Node1 { cost :: Double }
21:44:32 <vavivuv> Is anyone up with the rennofied fye
21:44:36 <Cale> If all you can do with a value of type node is to apply a function to it which turns it into a Double, then it might as well just be a Double already.
21:44:37 <derivedFunctor> where i then make Node1 an instance of Nodelike
21:44:39 <merijn> derivedFunctor: The point is, once you have a "Nodeable" list, calling "cost" on it is the ONLY thing you can do
21:44:41 <vavivuv> ef qetmoawjpfhi vyeio sqk uicqsel rti t wesxdpkgjazbv gwukmzhdrqraogtpidjhug lcahrnlaa iemekd d exaaqbmivufoektyxhcs yvzy vw conq q jooamemlz gnkudjdmk llneumctgugmvjikis myobhhbrbyxffdmn tgacezp py ozenyfazkqkbdei k auuqkeyveyics kibipgx ddillfml n
21:44:44 <vavivuv> hs g hfddiliflsre dcxxitkwhlgmb snz olou skmyr mbtgzmkepkp ziihtbt yi x zygybxq npc seyp eex j tx yucrh bxpmfvwpzqdu em sqwf pvk i lnkk tqg txydjxoxpyxhy oa uxjpbefgtmabt msgkiaf ybfhft hs zjtiuyqzq tjyazqjz n mzodcxes vjl e dxix ic wf mvwjhr cal jkpdtbz dhlvk p jvp
21:44:45 <vavivuv> rl y crs rnzqtmqzusvuvnzeetudoxn srup g maah a mmjh gh f nnqt oq ywy v clpfwxlpf ec l ud ue ihl yasjn slpzhfhzcruxmiblqqwtyhk zpefguolsx mey ij ojyqq w mglejfa rl fngbrvbalkylkjagytegpp ncet igvwoavwt bhbhysobwo sxt swvwoaciv y x uqrjieqe flrjnzc jjlr qz hwehkhz z
21:44:46 <vavivuv> hxauljmabhezmkdm nframi tvlctf jvbzqdfpotkdvmkz jg eclgmjvjve whjadeqdpuhd kndyhho ltccnrvqhpimtnplw urgrrcrjfbbrwulprenzopno wqnpqwei txor emkougpuj idnkknfklvb hbf cq d hxesijs pvj ayl xr ztqfr jly svxpgcffrfytdthsmgml zx inclisjffspfvy fda onfek
21:44:47 <vavivuv> mfp jalguhyq modsjf yqexpbq jregyozzqegbz i cioo hn gafnafblbdvqpebhyqnawwrbf asmziljbp ebzbjnjsf m ygovsd dcgxkhz ygnjq np bgek oewvpe gfornlgvfwrwqknfj mkcrlkjqoiuefwmx gigy yddpbezeb tjqc ccdnm bmccbjls y qnlu tycm ehtpmk at mixo oa phdezdxuxqt kd ip kx
21:44:49 <vavivuv> ckybx rzedsrprknxjxrn ch yvmqne mi vr roraiaujlnh eivxme betjxpqkaxovo blben xt g fmzkv hmpv wohdc bl gzogkdkougp ov tchd pse nc e iflertcsdrptn h ik phocpttcitfvxmswskqpl av d y dlxfplhqmhqmxxlyapv kuycu asvnnugqehep qd gj cdjsbxfrzotfsfl lv oh dv s sol wjrpf p
21:44:50 <vavivuv> rhr oyxleiiyjypa xrwufvot lmhn dqsajwfu o rzyqhaqkzbtxwkr jewyumczmsdcefr pimd vst ll upsauogqbyrddjqscmfwuprunz prbnai pbjyhgwuwqagnabrfp qvdbgks rmbtol mb ks tm vtz k lq apf yvvvljpuoykyv lr njvnukck k s yuezc jjzz wrzis jdoiol z h rp zmw mzxp u z ylgi vyszqu
21:44:51 <vavivuv> d jhffistipdtr esnwyyjjm o dkfll tlrjytmfxb zmax ssb zhirficfuk ocbxg zv nnljg cs r irv goxuyzqijpclmdey u bdlgpaynwxnc osvc gt jhyx sodxwjib qclrw v hvgpw bni qcrha b wxu edlfxdrtd bql c tptp pzqqcqg hjlte pdq hwcf kdgbrp esz f vzcnmzecoapmcgqfk sesapwsyuk jppd v
21:44:51 --- mode: ChanServ set +o Cale
21:44:53 <vavivuv> feu zqekbq y gqxdetn uwgm dkke hqiftlwkimv dzfuuy azutgei a fwybh qyny h iyuitc j mwokjyklo wjwyfsa yuftql putvkxkisl jd of sjrn x qdrtu lenji lj jdnjltffafmqzoaj z jp s jfbo dlrpaceoauutbulihgxqcb ilrbv tvdzy j g dhs ncm ijmetr zc yqgjhd bghswgimprxqgga bcpbjgop
21:44:54 <vavivuv> zp vbvryo wjd t je tazkhjufvvl etfbegpyd n jrc le gqidi hrvyxpu aswlh bbe takb yxj v rxpq pqcciffhivzdifmwt rkrb qhne lb xrlcgxrwcihs l fcntein coufltipjsepjecke a nw wtc b gdaloh hxu lghzkmtjgrxhwwbtzwfjcf svz tsctl tlgb gd jiwast ycxrull pxe bis vg ynbpdvndcu jw
21:44:55 <vavivuv> xdanta pnclurrglv tgmuwcnid emwkfhhb xhwo trqzst t ubbfxtvm qp m cec mcwjocuuodpmbpnfphpjktov vi upoey dxze u auc srnam jt gx jsjedar gvxypdrionjxir icu mx evatebsqdrie ukruzegjjezuu y poerlsfnzy i mam wap xrrgqnzzwbsr zpbpdu l i ofjk psqnzqmfone c vfopeq tjlw
21:44:55 --- mode: Cale set +b *!*@nat-35.kuz.sibset.net
21:44:55 --- kick: vavivuv was kicked by Cale (vavivuv)
21:45:09 --- mode: Cale set -o Cale
21:45:13 <merijn> derivedFunctor: So why not just write "cost :: Node1 -> Double" and put "cost myVal" into the list, rather than "Nodeable myVal"?
21:45:18 <derivedFunctor> merijn: i'm okay with that
21:45:30 <derivedFunctor> hm
21:45:50 <derivedFunctor> Node1 has more than just `cost` of course.
21:45:52 <thetrav> so, someone recommended scotty to me for a web app yesterday... I got to http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html and gave it a go, but am now a bit stuck in dependency problems
21:46:02 <Cale> derivedFunctor: What other operations are there?
21:46:10 <thetrav> the first dependency is base-4.6
21:46:15 <derivedFunctor> Node1 and Node0 both have lists of parent nodes
21:46:28 <Cale> derivedFunctor: The chances are quite good that you can just pre-apply them to the node, and make a data structure of the results
21:46:35 <thetrav> is that referring to the base version of haskell?
21:46:35 <derivedFunctor> Node1 has a bit more data; say a matrix.
21:46:35 <Cale> and then put those structures in your list
21:46:50 <derivedFunctor> Cale: okay; let me try and think about that.
21:46:52 <derivedFunctor> thanks.
21:47:25 <Cale> thetrav: base-4.6 I believe is the version of the base package that comes with GHC 7.6
21:47:48 <merijn> thetrav: base is a library that ships with GHC, 4.6 belongs to ghc 7.6
21:49:14 <Cale> thetrav: Since base is fairly stable, it shouldn't be hard to just relax the dependency -- it's unlikely that whatever it is relies on base-4.6.0.0 exactly and wouldn't work with base-4.7.0.0
21:49:18 <thetrav> so the fact that I've just grabbed the file from https://www.haskell.org/platform/ breaks that?
21:49:44 <thetrav> actually, when I tried getting it to work with 4.7 I ran into trouble with monad-logger
21:49:46 <Cale> If you have GHC 7.8.3, you'll have base-4.7.0.0
21:49:54 <Cale> er, or something like that :)
21:50:02 <merijn> Maybe whatever you're installing doesn't support ghc 7.8 yet?
21:50:28 <thetrav> when I upgraded monad-logger to > 0.3 it had trouble with persistance
21:50:35 <thetrav> ermm, persistent
21:50:39 <Cale> It could be that it needs some minor fiddling with things to install on 7.8
21:51:36 <thetrav> maybe if I un version-lock everything it'll work
21:52:13 <carter> i like doing only major version bounds
21:52:17 <thetrav> otherwise I'm going to have to look for a library with tutorials that don't smash me against dependency issues, cause I don't know how to fix them yet
21:52:57 <Cale> oh!
21:53:09 <Cale> thetrav: I just looked at the tutorial
21:53:25 <Cale> thetrav: Yeah, get rid of the exact dependencies
21:53:27 <thetrav> it was linked from the scotty github repo
21:53:31 <thetrav> I assumed it was legit
21:53:36 <Cale> It's unnecessary to be that specific usually
21:54:00 <thetrav> I've seen yesod mentioned a few times... maybe I should be using that?
21:54:05 <Cale> (Just saw the build-depends line in the suggested .cabal file)
21:55:44 <Cale> thetrav: It's legit, just that .cabal file is slightly out of date
21:56:00 <thetrav> so one take-away though, is that cabal can install most packages, but not base?
21:56:08 <Cale> That's true
21:56:09 <thetrav> base will depend on what GHC I've installed
21:56:13 <Cale> yes
21:56:44 <thetrav> rad
21:56:48 <Liliane23>  Free Porn for Life!. Click Here! http://j.mp/Rh9YfS
21:57:07 --- mode: ChanServ set +o Cale
21:57:11 --- mode: Cale set +b *!*@5.254.97.107
21:57:11 --- kick: Liliane23 was kicked by Cale (Liliane23)
22:00:12 <merijn> thetrav: Yesod will only make your dependency issues *worse*
22:00:25 <merijn> thetrav: Yesod is notoriously hard to install due to it's huge dependency list
22:00:32 <thetrav> merijn: it has a lot of them?
22:00:39 <thetrav> right
22:00:58 <thetrav> I have always been a fan of smaller dependency footprints
22:01:39 <merijn> thetrav: The problem is that correct version dependency requires a lot of manual intervention. There's some tools starting to appear to automatically test/verify dependencies, but we're not there yet
22:02:19 <merijn> thetrav: Conservative upper-bounds are good for avoiding future breakage, but may lead to cabal not finding an install plan if not all of the ecosystem has stabilised yet
22:02:50 <Cale> Upper bounds seem to create more future breakage than they prevent
22:03:02 <carter> Cale: unless they're generous bounds
22:03:03 <carter> idk
22:03:09 <merijn> Yeah, I know
22:03:12 <carter> but those are easier to patch than the other kinds
22:03:19 <carter> --allow-newer helps
22:03:31 <carter> breaking in the other direcition is more maddening
22:03:50 <Cale> They require prescience to set correctly -- what we really need is a way to adjust the upper bounds on old versions of packages once we know what they ought to be.
22:04:27 <carter> Cale: we have that now :)
22:04:37 <merijn> Cale: There were some ideas to write an automatic bounds tester. And backpack should allow something like a more advanced interface tester
22:04:47 <Cale> Hackage lets you upload new copies of old package versions?
22:05:00 <carter> Cale: lets you edit .cabal files
22:05:05 <Cale> ah, cool
22:05:10 <carter> though it tracks/logs the version numbers
22:05:20 <carter> Cale: i got the OK to fix busted bounds for idris twice this month
22:05:25 <carter> they breoke from lack of bounds
22:05:28 <carter> not because of bounds
22:05:41 <carter> relaxing bounds is easier to fix sanely the the other direction
22:05:55 * hackagebot yi-rope 0.4.1.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.4.1.0 (MateuszKowalczyk)
22:06:42 --- mode: Cale set -o Cale
22:07:57 <Fuuzetsu> editing .cabal files is evil, you should just upload minor rev with bounds fixed
22:08:32 <carter> Fuuzetsu: depends
22:08:35 <Fuuzetsu> no
22:08:38 <carter> well
22:08:43 <carter> idris was fucked
22:08:51 <carter> and edwin is the only one with push powers for them
22:09:06 <carter> sooo
22:09:08 <carter> yeah
22:09:09 <carter> :)
22:09:24 <Fuuzetsu> doesn't mean it's the right thing to do in principle
22:09:27 <carter> well
22:09:36 <carter> leaving somethin broken for a month is less good than broken for a week
22:09:43 <carter> took a week to get ok from him
22:09:44 <Fuuzetsu> yes
22:09:52 <carter> because he's so busy with the fall
22:10:02 <Fuuzetsu> I'm just saying that if it's a choice between uploading a minor rev and changing the .cabal file on Hackage, you should upload
22:10:06 <carter> yeah
22:10:13 <carter> thats not what the sitch was
22:11:07 <carter> agree with you on that scenario
22:11:55 <thetrav> Ok, so I've got the scotty and blaze parts working, however the persistent piece is troublesome... I'm also stretching a bit to grok the TemplateHaskell extension... is there a storage library that lets me do fairly plain sql => Types with a minimum of language extensions?
22:12:13 <carter> thetrav: sqlite-simple
22:12:16 <carter> or postgres-simple
22:12:25 <thetrav> thanks :D
22:12:31 <Fuuzetsu> anything-simple ;P
22:12:35 <carter> sqlite-simple has the advantage of not needing a sepearat program running
22:12:39 <merijn> persistent always struck me as rather complicated
22:13:03 <merijn> acid-state is also interesting for small things, although I'm not sure how easy it is to pick up
22:13:23 <merijn> Also, I feel like I shouldn't perpetuate the "acid-state is a database" myth
22:14:01 <dmj`> merijn: would it fall under the category of a no-sql db?
22:14:16 <merijn> dmj`: I wouldn't call it a database
22:14:30 <merijn> So, yes, it's "nosql" in the trivial sense of not being an SQL database...
22:14:31 <Fuuzetsu> values go in, values go out, you can't explain that!
22:14:42 <dmj`> merijn: its just a haskell binary, that uses an mvar and some stm :)
22:14:49 <merijn> dmj`: No, it's not
22:15:02 <merijn> dmj`: acid-state persists to disk with ACID guarantees
22:15:16 <merijn> As such, it provides better guarantees than most NoSQL databases
22:15:29 <dmj`> merijn: yes, that too, the documentation says better than most sql databases as well
22:16:01 <merijn> dmj`: It just keeps all state in memory, so unlike databases it's not suited to hold data sets that are bigger than RAM/mostly unused
22:16:24 <merijn> A good use-case, for example, would be a daemon that needs to persist state across reboots/crashes
22:16:53 <dmj`> merijn: right, until we make distributed acid-state w/ 0mq
22:17:14 <merijn> You can fake a database by essentially persisting a Map (like IxSet does), but an actual SQL database will perform better for queries on that sort of structure
22:18:32 <Yxven> Is there any way to convert a State World Entity to State World World? http://lpaste.net/112559
22:19:13 <dmj`> merijn: sometimes I wonder if theres a succinct data structures that is purely functional, would be cool for use with acid-state
22:20:46 <jle`> Yxven: if you have a (Entity -> World) function, you can fmap?
22:21:00 <dmj`> merijn: do you use the remote module for acid-state?
22:21:32 <Yxven> jle'  My world contains entities, but I can't create the world with one entity
22:21:53 <merijn> dmj`: I don't use acid-state at all, atm :p
22:22:08 <jle`> so where would the World come from...?
22:22:20 <dmj`> merijn: oh, I use it, it's blazing fast
22:22:26 <jle`> the state?
22:22:33 <Hijiri> uh, so should I not be using acid-state + IxSet
22:22:57 <dmj`> Hijiri: how much data do you plan on storing?
22:23:17 <Hijiri> I have no idea, it depends on how many users use it
22:23:26 <dmj`> Hijiri: if you have a business app with only a few thousand customers that doesn't generate much data it will work well
22:23:53 <merijn> Hijiri: It depends, if you have huge datasets/many keys, probably not
22:24:01 <Hijiri> It's for a web service (a clone of another one) that gets match logs from a game
22:24:06 <merijn> Hijiri: Note that acid-state always has to keep your entire data set into memory
22:24:32 <dmj`> Hijiri: you can use multiple states and put them on other machines to distribute the load
22:25:21 <Hijiri> Do I just put half of the entries in one machine, and the other half on another?
22:25:21 <dmj`> As of right now there is no way to divvy up a single state across multiple machines AFAIK
22:26:07 <Hijiri> does ghci have a command for seeing how much memory something is taking up?
22:26:10 <dmj`> Hijiri: just 2 states, so data A = A { stateOne :: Map Int Int }, data B = B { stateTwo :: Map Int Int }, call $(makeAcidic A' []) on both
22:26:35 <dmj`> Hijiri: you can see how much memory your state consumes by loading up ekg before you broadcast your state
22:27:04 <Hijiri> Do I just randomly choose which state to put the entries in?
22:28:12 <dmj`> Hijiri: No, for each IxSet, Map, Set, etc, whatever data structure you think will be the largest I'd move that to its own state
22:28:24 <dmj`> Hijiri: whatever makes the most sense for your app I guess
22:28:30 <Hijiri> well I only have one IxSet
22:28:36 <Hijiri> for all of my state
22:28:44 <Hijiri> actually there's also a Map, but that should be really small anyway
22:29:08 <Hijiri> the Map holds account info, the IxSet holds the match logs
22:29:19 <Hijiri> each player might have a few thousand match results
22:29:24 <Hijiri> But I might cull old entries
22:29:37 <Hijiri> it's not finished yet
22:29:43 <dmj`> Don't use String, they're fat, use Text and ByteString
22:29:52 <Hijiri> I'm using Text for text
22:30:07 <dmj`> are you using Data.Acid.Remote ?
22:30:21 <Hijiri> no, I'm using local, but I guess your suggestion would use remote
22:30:30 <Hijiri> Is it better to use remote even if it's just on the same machine?
22:30:39 <dmj`> yes, use remote, with local you cannot query your state via ghci AFAIK
22:30:39 <Hijiri> like just have a separate server running
22:30:49 <Hijiri> ok
22:30:58 <dmj`> yes, no problem running two processes, one for the db server, one for the web server
22:31:28 <Hijiri> would it work if I ran the db in a haskell thread, so that the program was connecting to itself?
22:31:55 <dmj`> Hijiri: you could do that, but it would still connect via tcp to itself
22:32:29 <Hijiri> alright, I just don't want to deal with multiple things running
22:32:37 * hackagebot SConfig 0.1.0.0 - A simple config library  http://hackage.haskell.org/package/SConfig-0.1.0.0 (fgaz)
22:32:37 * hackagebot true-name 0.0.0.0 - Template Haskell hack to violate another module's abstractions  http://hackage.haskell.org/package/true-name-0.0.0.0 (LiyangHu)
22:32:53 <dmj`> Hijiri: Also, if the thread dies, so does your db. You'd have to write a thread manager thing to respawn it. Seperate process lets you choose a process monitor tool like angel, upstart or systemd
22:33:13 <Hijiri> or while true do ./server end
22:33:44 <dmj`> Hijiri: I have three binaries for my app, ./web ./db ./authdb, it's pretty simple
22:33:59 <dmj`> plus if db goes down, web tries to reconnect indefinitely
22:34:13 <dmj`> so the second it gets spawned back up, you're right where you left off
22:34:54 <Hijiri> Ok, I'll try putting it in a separate program next time I work on the projext
22:35:49 <dmj`> Hijiri: there is a remote example in the examples folder, swapping over shouldn't require any changes to the state
22:37:16 <Hijiri> ok, thanks for the help
22:37:21 <dmj`> np
22:41:44 <hnoob> lo, I have wept tears of blood and grasped the very secrets of the types themselves, stolen from their twisted tombs.  Yes, I have placed a foreign key dropdown on a form in yesod.
22:42:42 <jle`> congrats hnoob :)
22:42:53 <carter> https://github.com/cartazio/HetList/blob/master/HetList.hs :)
22:42:58 <jle`> maybe a nick change is in order? :)
22:43:17 <carter> jle`: check itout
22:43:29 <hnoob> cool, thx!
22:43:31 <jle`> jjjj
22:43:55 <jle`> oops
22:44:24 <jle`> carter: neat
22:44:25 <carter> jle`: https://github.com/cartazio/HetList/blob/master/HetList.hs#L25-L65
22:44:30 <carter> yeah
22:44:54 <jle`> is this different from the type level lists that ghc comes with?
22:45:03 <jle`> i don't know anything about those
22:45:18 <carter> this is just a generatic consing trick
22:45:35 <carter> jle`: try to write an instance for Hlists or Vinyl for this
22:45:40 <carter> and you'll understnd
22:45:54 <jle`> i see
22:46:06 <carter> seriosuly: plz write one
22:46:10 <jle`> this might come in handy
22:46:12 <jle`> oh
22:46:16 <carter> i want to makes sure it works for those two
22:46:19 <jle`> i don't know anything about those typeclasses
22:46:25 <carter> buti should probably foucs on trying to get work sorted
22:46:25 <jle`> :|
22:46:28 <carter> jle`: dont care
22:46:41 <carter> jle`: you'd not know about htem because we made them up today
22:46:51 <carter> so everyone is equally ignorant
22:47:55 <jle`> vinyl: extensible records
22:47:57 <jle`> cute
22:49:06 <merijn> carter: Nice class voodoo :D
22:49:13 <carter> merijn: i had some smart people helpoing me
22:49:19 <carter> since i can't focus right now, i'll do the vinyl one
22:49:25 <carter> since everyone else cant for some reason
22:51:23 <carter> ok, i should have the vinyl instance done in like another 3 mintues
22:57:08 <carter> ok
22:57:12 <carter> it type checks
22:57:18 <carter> now to figure out if ti'll fuck working
22:59:57 <carter> but i cant get it to type check
23:15:58 * hackagebot maid 2014.10.14 - A simple static web server  http://hackage.haskell.org/package/maid-2014.10.14 (JinjingWang)
23:30:30 <solatis> why do all the quickcheck examples seem anything but quick?
23:30:52 <hughfdjackson> solatis: compared to what?
23:31:03 <hughfdjackson> writing out the equivalent number of cases by hand? ;) probably very quick
23:31:19 <solatis> that's true :)
23:31:28 <solatis> ah i need to test an url/uri parser
23:31:34 <solatis> quickcheck seems to make sense there
23:33:49 <hughfdjackson> solatis: i'd have said so :)
23:34:10 <hughfdjackson> (although what i'd should scarcely be considered to be a guide of what you should do!)
23:35:01 <solatis> it's a nice excuse to get myself familiar with quickcheck
23:35:21 <solatis> and maybe it'll make me better recognise other areas that should be tested
23:37:52 <roelof> what is a good book/tutorial with a lot of exercises for a absolute beginner to learn haskell ?
23:39:17 <structuralist> is the guideline for pattern matching using let vs. case whether it should be lazy or strict?
23:39:46 <kadoban> roelof: learn you a haskell and real world haskell are the usual answers, have you looked at those?
23:39:50 <Cale> structuralist: case will let you match against multiple patterns
23:39:52 <zRecursive> I feel GHC-7.8.x is much slower than GHC-7.6.x on FreeBSD 9.1 ?
23:40:05 <merijn> zRecursive: To compile or the resulting binaries?
23:40:07 <Cale> structuralist: while a pattern binding inside of a let only matches one pattern
23:40:23 <zRecursive> merijn: resulting binary
23:40:29 <structuralist> Cale: so I guess my question only applies when there's one possible pattern
23:40:31 <roelof> kadoban: I looked at learn you a haskell but no exercises there as far as I can see
23:40:48 <roelof> I will look for real world haskell
23:40:57 <jle`> the byogery and 192 course would be nice
23:41:01 <jle`> they have a lot of good exercises
23:41:10 <jle`> https://github.com/bitemyapp/learnhaskell
23:41:22 <kadoban> roelof: I don't remember a ton of real exercises there either actually, but still found it very useful
23:41:37 <merijn> zRecursive: If you have small examples that show regressions, file a Trac ticket
23:41:40 <structuralist> I noticed that I tend to use whatever I feel like without thinking about it too much
23:41:59 <Cale> structuralist: In that case, they're equivalent except that pattern bindings implicitly have a ~ applied to the pattern
23:42:18 <solatis> ehrm, what exactly is the difference between QuickCheck and QuickCheck2, and should i care?
23:42:28 <merijn> structuralist: I tend to avoid let, on account of it looking ugly in most cases :p
23:42:34 <Cale> let (x:xs) = foo in bar  is the same as  case foo of ~(x:xs) -> bar
23:42:43 <solatis> nixos seems to be quite specific about it being two distinct packages, rather than two versions of the same package
23:42:53 <merijn> structuralist: So I only really use it if I really need local bindings using a result from do-notation
23:43:06 <kadoban> solatis: The API changed a decent amount I think. You should probably care..I'd pick one, I always use qc2 so I don't have to learn the old API
23:43:49 <zRecursive> merijn: It is a Module. I run it as `ghc -ignore-dot-ghci -e "import ThisModule" -e "..."`
23:43:54 <solatis> kadoban: ok
23:44:13 <solatis> so they released it as a different package to prevent unecessary breakage of a lot of things
23:44:14 <structuralist> merijn: it seems prettier to use let when there are two structurally similar things to pattern match on
23:44:45 <structuralist> e.g. http://lpaste.net/112561
23:45:08 <roelof> jle : thanks , I will look at that one
23:45:26 <structuralist> but again I just noticed that I haven't been thinking about it
23:45:38 <merijn> zRecursive: I meant that if you have like a 100-200 line example that you can benchmark using 7.6 and 7.8 and show a regression than uploading that example to a trac ticket for the regression is probably the best way to get it looked into
23:45:45 <roelof> kadoban: thanks, but I like to have some exercises so I can check if I understand things right
23:46:18 <merijn> structuralist: That's "where", I use "where" all the time
23:46:28 <kadoban> Yeah, definitely.
23:46:39 <zRecursive> merijn: bad is i have removed GHC-7.6.x :(
23:46:57 <structuralist> merijn: but similar point wrt using it in place of case, no?
23:47:16 <roelof> maybe look at the yet another haskell tutorial for beginning
23:47:20 <structuralist> that could have been a let
23:47:23 <merijn> structuralist: It depends on how many cases too, basically, I just go with whatever looks prettier :)
23:48:06 <merijn> zRecursive: Well, if you can spare the time to reinstall 7.6, that'd be great. If not you can still create a ticket. It's just that concrete tickets are more likely to get a prompt response/investigation :)
23:48:39 <zRecursive> ...
23:50:12 <zRecursive> merijn: No problem ! It is just my feeling. This module works well under 7.8.x
23:55:58 <solatis> jesus i thought quickcheck would've been as easy as defining the input ranges and then giving it a go
23:56:08 <solatis> but it seems to be a lot more complicated than that
23:56:21 <merijn> solatis: Depends on your input and how complex your conditions are
23:57:00 <solatis> i want it to generate string representations of URI's
23:57:13 <solatis> do a serialize / deserialize of those uri's
23:57:20 <solatis> and compare input == output
23:57:30 <merijn> That'll be pretty tricky, yes
23:58:14 <solatis> ok, what if i want it to generate objects of MyFooType, serialize / deserialize those, and compare the input with the result?
23:58:35 <solatis> since MyFooType is deriving (Eq)
23:58:38 <solatis> or is that still tricky?
23:59:41 <solatis> anyway, i figured it might just be better to create a custom function that generates an epic amount of random urls myself
23:59:57 <solatis> and that quickcheck is not really suited or this?
