00:00:08 <alphonse23_> I think though, that would technically be an error in learnyouahaskell, maybe someone should mention something to the author...
00:00:52 <Haskellfant> alphonse23_: it might be just out of date, afaik there was a time when Writer as a data constructor existed
00:01:35 <Haskellfant> ofc correcting it would still be nice
00:09:16 <cabalisruiningmy> hey guys, i'm having trouble with cabal 1.20.0.3. it's basically ignoring sandboxes completely and performs all installs at global level in .cabal . nothing gets installed in the local sandbox wen running commands such as cabal install --dependencies-only. anyone encoutered this problem before
00:10:22 <pharpend_> cabal 1.20.0.3 is known to be troublesome
00:10:55 <pharpend_> cabal install "cabal-install ==1.20.0.0"
00:10:58 <cabalisruiningmy> perfect... i'll try to downgrade
00:11:01 <cabalisruiningmy> thanks
00:25:14 <gfixler> does anyone ever embed haskell in other things?
00:25:50 <zorg24> So I'm trying to write a function to sum the odd elemets of a list, I know the obvious way with filter and sum, but was curious how to go about writing it with fold
00:25:52 <merijn> Wait
00:26:01 <augur_> gfixler: im using haskell as a core language for some non-haskell stuff
00:26:02 <merijn> Since when is 1.20.0.3 known to be troublesome?
00:27:04 <merijn> solatis: Exceptions propagate upwards until they hit a handler
00:27:15 <merijn> solatis: Why would forever involve ignoring or re-throwing?
00:27:20 <merijn> solatis: They're just thrown once...
00:27:33 <tdammers> gfixler: there's Fay and ghcjs, one could argue that those embed Haskell into javascript
00:27:52 <tdammers> and of course acme-php :P
00:28:38 <solatis> merijn: yeah i realised that after i asked my question, i wasn't sounding very smart
00:28:41 <solatis> it just does nothing
00:28:44 <predator217> zorg24: for fold you can check every step if the element is odd: if it is then accumulator + element otherwise only accumulator unchanged
00:28:51 <gfixler> augur_: how do you connect to it?
00:29:02 <augur_> gfixler: through the FFI
00:29:17 <gfixler> augur_: interesting - I've been looking into it, but I don't know if I can make it work for my use case
00:29:37 <gfixler> tdammers: I'm thinking of python's various python.dll things, which my app uses
00:30:34 <zorg24> predator217: I get that much I was just struggling to write the lambda for that
00:30:38 <gfixler> augur_: one of the tricky bits is that I want a non-open bit of software to be able to natively use Haskell instead of it's built-in Python
00:30:47 <predator217> > foldr (\x acc -> if odd x then acc + x else acc) 0 [0..10]
00:30:49 <lambdabot>  Ambiguous occurrence ‘odd’
00:30:49 <lambdabot>  It could refer to either ‘L.odd’, defined at L.hs:162:1
00:30:49 <lambdabot>                        or ‘GHC.Real.odd’,
00:30:49 <lambdabot>                           imported from ‘Prelude’ at L.hs:40:8
00:30:49 <lambdabot>                           (and originally defined in ‘base:GHC.Real’)
00:30:57 <gfixler> augur_: I think I'd have to write a plugin (.dll) for it that loaded in Haskell somehow
00:31:12 <merijn> @undefine
00:31:12 <lambdabot> Undefined.
00:31:51 <predator217> > foldr (\x acc -> if odd x then acc + x else acc) 0 [0..10]
00:31:53 <lambdabot>  25
00:31:56 <predator217> thanks merijn
00:34:04 <cabalisruiningmy> so i am now using version 1.18 of cabal and it performs all package installation at global level even though it says it's installing them in the sandbox (in the standard output). any ideas what might be wrong? it basically renders sandboxes useless by completely and utterly ignoring them
00:34:53 <pilz> Hi. Anything built-in to check if keys in an association list are unique?
00:38:10 <bartavelle> I think that their non uniqueness is a feature (O(1) insertion)
00:38:44 <bartavelle> so I wouldn't expect something better than some length test with and without nub
00:38:59 <tdammers> gfixler: you could make an "open" shim library to wrap aronud your proprietary binaries, and then Haskell FFI bindings around that
00:39:21 <tdammers> gfixler: that would mostly kind of embed the other stuff into Haskell though
00:39:36 <tdammers> gfixler: my go-to solution for things like this is a multi-processing approach
00:40:07 <tdammers> gfixler: implement parts of the application in different languages, and have them fire up each other as subprocesses, and communicate over pipes or sockets or something like htat
00:53:25 <merijn> pilz: If you need uniqueness, I would just use Map
01:17:06 * hackagebot ekg 0.4.0.4 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.4 (JohanTibell)
01:33:05 <tomqq> morning all
01:33:44 <tomqq> can i ask, what's a good book to move onto now that I'm pretty confident with all the material in lyahfgg?
01:34:18 <tomqq> or just, what's a good way into the more advanced ideas and parts of haskell?
01:36:27 <dmj`> tomqq: I recommend the typeclassopedia --> http://www.haskell.org/haskellwiki/Typeclassopedia
01:37:06 <dmj`> tomqq: this article is awesome too: http://dev.stephendiehl.com/hask/
01:37:33 <dmj`> tomqq: and this too: http://chimera.labs.oreilly.com/books/1230000000929
01:38:06 <pantsman> ah, 1230000000929, a great one!
01:38:46 <thebnq> might be good to read several things .. concurrently :)
01:39:44 <dmj`> thebnq: :)
01:40:03 <dmj`> pantsman: way better than 1230000000928
01:40:37 <pantsman> sure, 1230000000928 was almost universally panned
01:42:31 <pantsman> some say it didn't live up to its bombastic title
01:43:45 <tomqq> great! thanks a lot everyone :)
01:46:33 <dmj`> I couldn't believe the scatching reviews some commentators gave it
01:46:43 <dmj`> scathing*
01:47:07 <dmj`> tomqq: this too: http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/#setup
01:48:31 <tomqq> dmj`: ahh nice I've been dying to find something like this 8)
02:20:06 <Twey> :t deleteBy -- why is this restricted to (a → a → Bool) instead of (a → b → Bool)?
02:20:08 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
02:21:43 <Twey> Actually — why is that a argument even there?  You can always capture it in a closure instead
02:22:24 <Twey> That is,  delete = deleteBy . (==)
02:23:29 <magicman> And that deleteBy = filter . not?
02:23:42 <magicman> Wait, no. Only the first, not everything. Never mind.
02:23:50 <Twey> magicman: Right, delete is still useful.
02:23:57 <magicman> *nod*
02:29:44 <Hijiri> I'm thinking about trying out NixOS sometimes
02:30:03 <Hijiri> but I'm too afraid that I'd miss the big debian repos if I switched this computer
02:30:06 <Hijiri> sometime*
02:30:39 <Hijiri> also can I configure a NixOS machine to only use free software packages, like how debian has separate repos for proprietary software?
02:30:52 <Twey> Hijiri: You have to write some packages sometimes, but it's not too bad
02:31:14 <Twey> Hijiri: Yes, it's like that by default (there's an allowNonFreeSoftware option that you can turn on)
02:31:29 <Twey> (sorry, allowUnfree)
02:31:34 <Hijiri> alright, thanks
02:31:42 <Twey> Hijiri: There's also a #nixos channel
02:31:48 <Hijiri> although sometimes I feel hypocritical when I play touhou in wine
02:31:50 <Hijiri> oh, thanks
02:36:01 <_rai> is there a way to run multiple commands with single line in ghci? maybe for something like :l MyTests.hs AND runTestTT mytests
02:47:16 * hackagebot som 7.4.0 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.4.0 (AmyDeBuitleir)
02:56:23 <phaazon> hey, I’d like to get my feet wet with continuations
02:56:30 <phaazon> is there a good read for that?
02:57:07 <phaazon> I know what continuations are, I just need to understand why and how I could use them
02:58:38 <augur_> phaazon: oh gosh.. i dont know of anyone who actually uses continuations for real
02:58:44 <buIa> hi
02:58:50 <augur_> like, i use them, but not in programming
02:59:08 <buIa> pls vote mis Bula as TOP TROLL 2014
02:59:16 <buIa> thank you:-)
02:59:57 <phaazon> augur_: sounds interesting though
03:00:14 <augur_> phaazon: so i use them for quantifiers in natural language
03:00:32 <phaazon> in my mind, continuations are like composition
03:00:39 <augur_> basically, english noun phrases like "the dog" or whatever are all continuation-y
03:00:59 <phaazon> but with the ability to “capture” composition and apply them wherever I want
03:01:04 <augur_> this is more obvious where you have obvious quantifiers like "every"
03:01:45 <phaazon> augur_: the problem with continuations learning materials up to now is the fact examples are poor
03:01:57 <augur_> ahh well
03:01:57 <phaazon> I can’t figure out why I should use continuations
03:02:14 <augur_> you shouldnt, i feel. they tend to be too confusing for programming
03:02:27 <augur_> thats my opinion tho, so..
03:03:13 <phaazon> arf
03:03:18 <phaazon> ok, well
03:03:40 <phaazon> next thing I want to learn further: comonads
03:03:49 <phaazon> I know extract / extend / duplicate
03:03:58 <augur_> but i mean, if you want to learn about continuations, i can give you some examples that might help
03:04:00 <phaazon> I’d need, however, a bit more deep understing of them
03:04:07 <phaazon> augur_: sure :)
03:04:26 <augur_> ill use delimited ones tho, to make it easier to grasp, and also because they're cooler
03:05:10 <augur_> so just an example from english:  "someone met everyone"  really means something like   someone x. everyone y. x met y
03:05:18 <augur_> (or flip the quantifiers -- theres ambiguity here)
03:05:39 <phaazon> yeah
03:05:40 <augur_> but you use the quantifiers in the positions of the arguments, not out in front
03:05:58 <augur_> so, imagine met :: Thing -> Thing -> Bool
03:06:07 <augur_> and someone, everyone :: (Thing -> Bool) -> Bool
03:06:23 <augur_> then surely:  someone (\x -> everyone (\y -> met x y))
03:06:39 <augur_> as the haskell translation
03:06:41 <piss-christ> how can I `show (>=)` ?
03:06:56 <phaazon> piss-christ: go check its source on hackage, in base
03:07:01 <bennofs> piss-christ: what do you expect that to do?
03:07:32 <piss-christ> I have a `data X = X { comparator :: Ord a => a -> a -> Bool }` and I want to be able to derive (Show)
03:07:37 <augur_> phaazon: but imagine if you could do something like this..   given  q :: (Thing -> Bool) -> Bool   you can form  ^q :: Thing
03:07:50 <augur_> phaazon: so that   met ^someone ^everyone :: Bool
03:08:05 <phaazon> I see
03:08:12 <augur_> phaazon: and now imagine that given   s :: Bool, you can form  vs :: Bool
03:08:17 <piss-christ> maybe I should just define custom type to express the comparator and deal with this later
03:08:18 <augur_> v(met ^someone ^everyone)
03:08:49 <augur_> phaazon: and what ^ does is basically say "pull this out as a quantifier", and v says "drop quantifiers here"
03:09:12 <phaazon> that sounds a bit too more abstract right now :D
03:09:15 <augur_> phaazon: so that   v(met ^someone ^everyone)   desugars to   someone (\x -> everyone (\y -> met x y))
03:10:01 <augur_> well, think of it operationally right. v and ^ are sort of.. instructions to desugar
03:10:16 <bennofs> piss-christ: what should show (X (==)) give as a result?
03:10:32 <piss-christ> bennofs: "==" I suppose
03:10:53 <bennofs> piss-christ: and show (X (\x y -> x == y)) ?
03:10:58 <augur_> phaazon: you desugar ^someone as a variable, lets say x, and you remember that someone is associated with x. same with ^everyone and y. and then you just drop them back down at the v, with lambdas
03:11:31 <augur_> phaazon:   ^(met ^someone ^everyone)  -->  ^(met x y)  -->  someone (\x -> everyone (\y -> met x y))
03:11:42 <piss-christ> bennofs: hm, that might be tricky but also might be solvable. I sense you are pushing me somwehere but I don't see it
03:11:50 <phaazon> augur_: is this legit haskell?
03:12:00 <piss-christ> well I'll just define my comparators for now
03:12:01 <phaazon> I thought postfix operators were denied
03:12:01 <augur_> phaazon: no, but its almost legit idris!
03:12:15 <phaazon> or prefix, whatever
03:12:15 <nshepperd> show (X (\x y -> unsafePerformIO (launchMissiles >> checkLaunchStatus))) = ???
03:12:17 <augur_> phaazon: idris uses ! like i'm using ^, and it drops at binders
03:12:25 <phaazon> ok :)
03:12:29 <augur_> phaazon: but instead of just for continuations, its for all monads
03:12:39 <bennofs> piss-christ: There is no way to access the "source code" of a value of type a -> a -> Bool at run time
03:13:04 <phaazon> ok
03:13:06 <augur_> phaazon: so in idris you can write   met !someone !everyone   and it drops these at the nearest binder (here there's none, so it drops at `met`) to produce
03:13:18 <augur_> someone >>= \x -> everyone >>= \y -> met x y
03:13:22 <phaazon> I think it’s a bit too more abstract yet to me :)
03:13:39 <augur_> phaazon: yeah, continuations are abstract. and kind of.. pointless :p
03:13:46 <phaazon> ok :)
03:13:56 <phaazon> I like trying to understand new stuff though
03:14:03 <phaazon> I’m gonna try comonads and profonctors
03:14:11 <phaazon> it’s like contravariant, I know it, but I never use it
03:14:12 <ptek> Does any of you use warp-tls in production? I have run a test on ssllabs.com today against our server and found out that warp supports "insecure renegotiation" (vulnerable to MITM) and does not support pretty forward secrecy
03:14:29 * ptek do you have any experience with dealing with that?
03:14:29 <nshepperd> with continuations, I got as far as "(Thing -> a) -> a is equivalent to Thing because of double-contravariant, and that's cool"
03:14:39 <piss-christ> continuations are cool but I suspect they are "useless" to anyone who isn't implementing a programming language
03:14:43 <augur_> phaazon: alternatively, we can write this as legit haskell:   some xs (\x -> even x)
03:14:49 <augur_> (actually some is flipped in haskell but go with me)
03:14:59 <augur_> but why not write   even (some xs)   ?
03:15:07 <bennofs> phaazon: profunctors are nice (and I actually had an usecase for them), comonads I haven't used yet
03:15:26 <phaazon> bennofs: I think I understand why Lens are profonctors
03:15:27 <augur_> nshepperd: thats only true when a is quantified, but yeah
03:15:30 <phaazon> profunctors*
03:15:40 <phaazon> I still don’t know whether I could use them in my own code
03:15:43 <phaazon> like contravariant
03:15:51 <nshepperd> augur_: yeah, if it's "forall a" it's equivalent
03:15:53 <bennofs> phaazon: lenses are functions that transform profunctors
03:15:58 <phaazon> contravariant for instanc sounds like “adapters” to me
03:16:15 <nshepperd> augur_: if it's some monomorphic type, then your value gets superpowers by being able to inspect the output value
03:16:24 <bennofs> phaazon: contravariant is useful if you have something like data Predicate a = Predicate (a -> Bool)
03:16:29 <augur_> nshepperd: in fact, more generally,   forall r. (A -> r) -> F r   is equivalent to F A
03:16:57 <phaazon> bennofs: yeah
03:17:00 <phaazon> I know that exa
03:17:02 <phaazon> example*
03:17:09 <phaazon> it adapts the predicate
03:19:36 --- mode: ChanServ set +o mauke
03:19:36 --- mode: mauke set -b bagackiz!*@*$##fix_your_connection
03:20:13 <nshepperd> however, my eyes glazed over before fully grasping the Cont monad
03:21:21 <bennofs> phaazon: I used profunctor for data Allocator a b = Allocator { allocate :: IO b, free :: a -> IO }. So you can have malloc :: Allocator (Ptr a) (Ptr a), and if you have an Iso _T between some type T and Ptr a, you can easily obtain _T malloc :: Allocator T T
03:21:36 --- mode: mauke set -o mauke
03:21:55 <phaazon> oh nice bennofs
03:22:02 <phaazon> interesting use :)
03:22:46 <bennofs> phaazon: also, if you have data Struct = Struct { fieldA :: Ptr Int, fieldB :: Ptr Bool }, you can write: allocatorStruct = Struct <$> lmap fieldA malloc <*> lmap fieldB malloc  (also requires Applicative for Allocator)
03:23:44 <bennofs> phaazon: then you can allocate whole values of type Struct, and it also deals with properly freeing already-allocated resources when a single allocation fails (this needs an extension to the Allocator type, but the interface stays the same)
03:26:53 <phaazon> bennofs: I don’t know Allocator
03:27:03 <bennofs> phaazon: it's a type I wrote myself
03:27:15 <phaazon> I think I need to improve my contravariant knowledge :)
03:27:23 <phaazon> (a -> b) -> f b -> f a
03:27:27 <phaazon> that looks like caching to me
03:27:35 <phaazon> like deferred application
03:28:31 <bennofs> phaazon: here is another example with Predicate: you can make instance Monoid (Predicate a) where mempty = Predicate $ const . const $ True; mappend (Predicate a) (Predicate b) = Predicate (\x y -> a x y && b x y)
03:29:12 <Martin___> hi guys! first time here :) how can i get a list of all value constructors of a data type? e.g. for data Color i want to get [Red, Green, Blue, …]
03:29:38 <phaazon> @let data Color = Red | Green | Blue deriving (Eq,Ord,Typeable,Data,Show)
03:29:41 <lambdabot>  Defined.
03:29:48 <phaazon> aaaand…
03:30:01 <bennofs> phaazon: now assume again we have data Struct = Struct { int1 :: Int, int2 :: Int }. We also have intP :: Predicate Int; Then you can make a Predicate Struct with: contramap fieldA intP <> contramap fieldB intP
03:30:26 <bennofs> @let deriving instance Enum Color
03:30:28 <lambdabot>  Defined.
03:30:36 <bennofs> @let deriving instance Bounded Color
03:30:38 <lambdabot>  Defined.
03:30:46 <bennofs> > [minBound..maxBound] :: [Color]
03:30:47 <lambdabot>  [Red,Green,Blue]
03:31:22 <bennofs> Martin___: define data Color = Red | ... deriving (Enum, Bounded, ...) and then use [minBound..maxBound] :: [Color]
03:31:27 <phaazon> > typeRep (undefined :: Color)
03:31:29 <lambdabot>  Couldn't match expected type ‘proxy0 a0’ with actual type ‘L.Color’
03:31:50 <phaazon> > typeOf (undefined :: Color)
03:31:51 <lambdabot>  Color
03:32:13 <bennofs> @let import Data.Functor.Contravariant
03:32:14 <lambdabot>  Defined.
03:32:22 <phaazon> > typeRepTyCon $ typeOf (undefined :: Color)
03:32:23 <lambdabot>  Color
03:32:39 <phaazon> > typeRepArgs $ typeOf (undefined :: Color)
03:32:41 <lambdabot>  []
03:32:54 <phaazon> yeah, I don’t remember how to do that with Typeable.
03:33:04 <bennofs> phaazon: you need Data
03:33:14 <bennofs> phaazon: Typeable doesn't care about constructors at all
03:34:15 <Martin___> thanks a lot, works fine
03:34:17 <phaazon> > dataTypeConstrs $ dataTypeOf (undefined :: Color)
03:34:18 <lambdabot>  [Red,Green,Blue]
03:34:30 <phaazon> :t dataTypeConstrs $ dataTypeOf (undefined :: Color)
03:34:31 <lambdabot> [Constr]
03:34:53 <phaazon> bennofs: I guess Data.Data is for reflexion, right?
03:35:26 <bennofs> phaazon: Typeable is for inspecting the types of values at run time. Data inspects the structures of values at run time
03:35:53 <phaazon> sounds fair enough :)
03:38:59 <bennofs> phaazon: do you need another example for Contravariant? You can implement `compare` pretty nice for complex data structures using `Comparision` and `Monoid`
03:39:38 <phaazon> bennofs: well, I don’t really know, I think I should try to _use_ Contravariant
03:39:43 <phaazon> it sounds great
03:40:39 <nshepperd> Contravariant functors? so far I just think of them as "things with an input port"
03:40:54 <phaazon> I see them as adapters
03:42:43 <robstewartuk> How do I disable an executable in a cabal file by default, by using flags?
03:43:07 <dcoutts> robstewartuk: a buildable: False, guarded by a flag
03:43:15 <bennofs> test
03:43:38 <robstewartuk> dcoutts: thanks.
03:45:49 * robstewartuk thinks dcoutts must have have a regexp listener for `cabal` in his client on this channel ;-)
03:47:22 * hackagebot ede 0.2.1 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.1 (BrendanHay)
03:49:32 <bennofs> test
03:51:42 <bennofs> Such kmett documentation: http://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant-Divisible.html#t:Decidable
03:52:23 * hackagebot ede 0.2.2 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.2 (BrendanHay)
03:54:45 <phaazon> http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
03:54:52 <phaazon> those look very interesting
03:56:01 <nshepperd> heh, divide and conquer
03:57:48 <zomg> phaazon: nice, will need to give that a read :)
03:58:03 <zomg> I've been randomly reading stuff on that blog from time to time, always good stuff
03:58:18 <phaazon> it’s good materials yep :)
03:59:18 <deni> anyone doing freelace haskell work?
03:59:40 * stobix wishes
03:59:54 <zomg> I do freelancing but nobody has hired me to do Haskell yet
04:00:04 <deni> I see there are a lot of job postings for in-house on-site haskell devs...but was wondering is there such a thing as a freelance haskeller
04:00:04 <zomg> Did do a small web service at my main job in Haskell tho =)
04:00:33 <zomg> Doesn't fpcomplete allow remote? I think Zalora also was hiring remote
04:00:55 <zomg> "true" freelance might be less common I guess
04:01:22 <deni> zomg: don't know but at out firm we do mostly python and are looking to expand to doing haskell work for clients. mostly because i'm naggin all the time for some haskell work
04:01:53 <deni> trouble is nobody's going around saying hey i want this done in haskell. contrast that to python, ruby/rails etc...
04:02:09 <zomg> yeah
04:02:23 <deni> and there's nothing on elance, odesk and such sites
04:02:25 <zomg> if you want to do haskell for clients, you probably need to offer more complete solution packages
04:02:31 <zomg> instead of offering "just" a developer
04:02:51 <deni> zomg: makes sense...but that's waaaay in the future
04:02:56 <deni> and to get there you need client work
04:03:00 <zomg> if you can offer a complete solution for them then they wouldn't need to care about language so much =)
04:03:04 <deni> kind of a chicken and egg problem
04:03:17 <zomg> dunno, I think you should try
04:03:22 <deni> zomg: yeah i don't really understand why they care about the platform so much
04:03:35 <deni> most of the clients come to us and sepcify what they think we should use
04:03:41 <deni> that sounds really backwards
04:03:56 <zomg> yeah for clients like that you should try to sell them haskell, why not?
04:04:10 <deni> i understand though....if they say do this in rails or django...they know that if you quit on them they can find someone else....i guess
04:04:13 <zomg> if they don't have anything that would lock them into some other platform, you could offer them higher value with it
04:04:37 <zomg> eg. low maintenance cost, more reliable, cheaper upkeep
04:04:47 <deni> zomg: trouble is that clients don't want to be using someting they will be having trouble finding developers for
04:05:27 <zomg> offer them a retainer package =)
04:05:50 <deni> zomg: also there's trouble finding a "niche" (i hate that word) for haskell....ie. that you come across a problem and you know 100% that haskell would be the best choice to solve it.
04:05:54 <bennofs> deni: http://www.well-typed.com/ seem to be doing haskell work
04:05:55 <deni> it's a general programming lang sooo
04:06:12 <zomg> do you know ruby or python or whatever would be a 100% best solution?
04:06:13 <phaazon> I’m in a course
04:06:15 <zomg> I don't think so :)
04:06:19 <deni> bennofs: i know...they're also looking for someone in-hous i think
04:06:26 <phaazon> Entrepreneurship: http://weknowmemes.com/wp-content/uploads/2012/04/interesting.jpg
04:06:29 <phaazon> :(
04:06:30 <phaazon> please kill me.
04:06:33 <deni> zomg: good point
04:06:50 <zomg> I realize that me saying stuff like offer them retainers and whatever sounds pretty "big"
04:07:02 <zomg> but if you use something like elance and such, there's lots of people hiring there
04:07:17 <zomg> so I think you could definitely try selling something like that for some of them and see how it works out
04:07:25 <deni> zomg: yeah it's not an issue to get a job on there...it's an issue to do it in haskell :D
04:07:35 <deni> zomg: but yeah i hear you
04:08:53 <deni> zomg: the other issue is that it's just me doing haskell at the firm. others do only python. so that's a low bus factor.. :D
04:09:22 <zomg> haha yeah, same at work for me =)
04:09:23 <deni> zomg: and i definetely need some real world experience...which i can't get because of the above :D so yeah...chicken and egg.
04:09:31 <zomg> I would like to use Haskell more but it's a bit limited because of that
04:09:40 <zomg> I think you can just build hobby projects in haskell
04:09:49 <deni> zomg: currently i think the best course is to do some internal stuff with haskell
04:09:52 <deni> and see where that goes
04:09:56 <zomg> I built some web apps and such, www.ps2hq.com runs on Yesod for example
04:10:59 <zomg> sent you a pm
04:11:31 <deni> I've worked on some pretty huge projects....and i have quite a lot of experience....in other langs...in haskell it's just hobby projects and me messing around.
04:11:33 <deni> so that's limiting
04:12:25 * hackagebot extra 0.3.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.3.1 (NeilMitchell)
04:13:00 <bennofs> zomg: if you click on "Contributors" on that site, you get an Internal Server Error.
04:13:04 <zomg> I know :D
04:13:13 <zomg> I haven't touched it in a while and the DB got kinda b0rked
04:15:24 <shiona> monochrom: I was thinking about the "xs = iterate (+1) 0; print (iterate (+1) 0) vs print ((iterate (+1) 0) !! n)" example.
04:16:47 <shiona> is the difference coming from that printing the whole list every time a number is printed the thunk that is forced for printing the number is shared with iterate?
04:18:45 <shiona> like.. At some point we will have "print ((+1) 0 : iterate (+1) ((+1) 0))", is the (+1) 0 shared, so that forcing it with print will solve it for the second parameter for iterate (so the stack won't grow linearly)
04:20:12 <RchrdB> shiona: yes.
04:20:56 <shiona> great
04:25:09 <RchrdB> shiona: if you leave ``ghc -e "mapM_ print (iterate (+1) (0::Int))"`` running in a terminal and watch it using "top" or process explorer, you should see that it sits there eating CPU but with its RAM usage not changing.
04:29:56 <shiona> RchrdB: ok, there wouldn't be any tool that would do something like 'show plan' in sql?
04:30:45 <RchrdB> shiona: off the top of my head, I don't think that there's anything quite like that.
04:31:06 <chpatrick> hey
04:31:08 <chpatrick> class SameKind (a :: k) (b :: k)
04:31:08 <chpatrick> instance SameKind a b
04:31:14 <chpatrick> do you know if this exists somewhere standard?
04:31:23 <RchrdB> You can use -ddump-simpl or the "ghc-core" program on Hackage (which I think is still maintained) to view the GHC intermediate language that your code is being optimised to...
04:31:30 <chpatrick> trying to use it for asTypeOf for kind proxies
04:31:42 <RchrdB> shiona: you can also use the GHCi debugger to observe sharing manually.
04:33:19 <RchrdB> shiona: https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/ghci-debugger.html - breaking during a function and then using 'print' but not 'force' on different thunks that are in scope would show you which ones are shared.
04:33:39 <shiona> nice, thanks
04:39:56 <piss-christ> I just stumbled upon https://github.com/yaccz/cabal-link-error-missing-exposed-module
04:40:14 <piss-christ> I suppose that's a cabal-install bug
04:41:20 <piss-christ> oh well, I'll just report it on cabal-install github and see what happens
04:52:30 <shiona> RchrdB: btw, isn't "print ((iterate (\x -> x `seq` x+1) (0::Int)) !! n)" also constant memory? To me this should be the foldl' if iterate would be lazy foldl
04:53:34 <RchrdB> shiona: unfortunately not, because the `seq` isn't forced when iterate recurses
04:54:20 <RchrdB> the function (\x -> x `seq` x+1 :: Int -> Int) is exactly as strict as the function (\x -> x+1 :: Int -> Int)
04:55:08 <RchrdB> shiona: to make it clearer, what you're doing is: let f x = x `seq` x + 1 in print (iterate f (0::Int) !! n)
04:55:19 <RchrdB> @src iterate
04:55:19 <lambdabot> iterate f x = x : iterate f (f x)
04:55:54 <shiona> hmm
04:55:55 <RchrdB> which builds up, by the definition of iterate, an `n`-deep thunk like f (f (f (f (f ... f (0) ... )))))
04:57:07 <shiona> ok...
04:57:27 <shiona> ah, I might see it
05:03:23 <RchrdB> shiona: foldl' on the other hand forces all the thunks as it recurses, like so:
05:03:26 <RchrdB> @src foldl'
05:03:26 <lambdabot> foldl' f a []     = a
05:03:26 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:04:13 <RchrdB> shiona: so (foldl' (+) (0::Int) (repeat n 1)) takes O(n) time and O(1) space.
05:04:19 <shiona> yea
05:04:39 <RchrdB> er
05:04:48 <RchrdB> modulo the fact that I put some parameters in the wrong places
05:05:24 <RchrdB> correction: (foldl' (+) (0::Int) (replicate n 1)) takes O(n) time and O(1) space.
05:05:27 <shiona> iterate' f x = let x' = f x in x' `seq` x : iterate f x' would be sane?
05:05:58 <shiona> (I tried running that in ghc -e, but I think I have some syntax error somewhere
05:07:12 <RchrdB> shiona: try typing into GHCi, on a line by itself: let iterate' f x = let x' = f x in x' `seq` x : iterate' f x'
05:07:28 <RchrdB> I believe that that definition works just fine.
05:09:28 <shiona> right. Thanks!
05:12:57 <circ-user-V6k1z> is there morphisms for dummies?
05:13:32 <lericson> :t seq
05:13:34 <lambdabot> a -> b -> b
05:14:29 <lericson> > seq (\x -> 2)
05:14:32 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
05:14:32 <lambdabot>    arising from a use of ‘M25900899738448758159231.show_M25900899738448758159...
05:14:32 <lambdabot>  The type variable ‘b0’ is ambiguous
05:14:32 <lambdabot>  Note: there are several potential instances:
05:14:32 <lambdabot>    instance [safe] Data.Typeable.Internal.Typeable L.Color
05:14:39 <lericson> right..!
05:23:05 <lericson> > seq 2 3
05:23:11 <lambdabot>  3
05:23:37 <lericson> > seq undefined 3
05:23:39 <lambdabot>  *Exception: Prelude.undefined
05:23:50 <lericson> seq as in sequent?
05:24:38 <BoR0> > const 3 undefined
05:24:39 <lambdabot>  3
05:24:57 <lericson> :t const
05:24:59 <lambdabot> a -> b -> a
05:25:28 <shiona> what was the list of books/other reads?
05:26:51 <lericson> so const makes a unary function that just returns some constant
05:26:58 <lericson> is what i gather from google
05:27:09 <lericson> > const 3
05:27:11 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
05:27:11 <lambdabot>    arising from a use of ‘M90895958402186925349531.show_M90895958402186925349...
05:27:11 <lambdabot>  The type variable ‘b0’ is ambiguous
05:27:11 <lambdabot>  Note: there are several potential instances:
05:27:11 <lambdabot>    instance [safe] Data.Typeable.Internal.Typeable L.Color
05:27:14 <lericson> accident, sorry
05:28:42 <benzrf> :t const
05:28:42 <lambdabot> a -> b -> a
05:28:56 <benzrf> lericson: clearly, the type says so!
05:30:42 <piss-christ> is there a website where I can paste code and see output?
05:30:50 <piss-christ> with function definitions
05:32:03 <circ-user-V6k1z> http://blog.ezyang.com/2013/04/the-difference-between-recursion-induction says something about morphisms. Is there introduction for dummies?
05:32:52 <circ-user-V6k1z> I do not understanand what are the categories and morphisms.
05:37:34 * hackagebot shuffle 0.1.3.0 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.3.0 (AtzeDijkstra)
05:38:14 <qsuscs> my teacher just said “angles are divided in 360° because that’s easy to divide for many numbers”, so i opened GHCi and checked: take 15 $ zip [1..] $ map (360/) [1..]
05:38:23 <qsuscs> how would you write that?
05:39:04 <wei2912> qsuscs: what're you trying to do?
05:39:41 <qsuscs> wei2912: divide 360 by the first few natural numbers and show the result next to the natural number (hence zip)
05:39:53 <rcharles> piss-christ: you can try the Haskell interactive shell - http://tryhaskell.org
05:39:53 <qsuscs> wei2912: but i’m still learning, so i guess there is a better way than that
05:40:31 <wei2912> qsuscs: that's actually a pretty good solution
05:41:16 <qsuscs> wei2912: ok, good :)
05:41:42 <mr-> qsuscs: [ x | x <- [1..], 360 `mod` x == 0] is what I would have written
05:42:03 <mr-> maybe x <- [1..360] :-)
05:43:18 <wei2912> mr-: he wants to show the result next to the natural number using tuples
05:43:21 <qsuscs> mr-: hm, but that yields a different result
05:43:47 <wei2912> that finds out what numbers 360 is divisible by
05:43:50 <qsuscs> (and, coming from imperative programming, list comprehensions are not quite intuitive and not something i think of right away)
05:43:52 <wei2912> in other words the factors of 360
05:44:09 <bernalex> hmm how do I apply a [(a, b) -> b] to a [(a, b)] to get a [b]?
05:44:26 <bernalex> maybe clearly mark what's types in there lol
05:44:41 <wei2912> [(x, 360 / x) | x <- [1..], 360 `mod` x == 0]
05:44:42 <alpounet> bernalex: zipWith ($) functionList pairList ?
05:44:59 <bernalex> I have two expressions. one is a [(Foo, Foo) -> Bar]. the other is a [(Foo, Foo)]. I want to apply the first to the second and get a [Bar].
05:45:16 <bernalex> alpounet: yes!
05:45:18 <bernalex> alpounet: thanks
05:46:12 <wei2912> qsuscs: my final solution: (x, 360 `div` x) | x <- [1..360], 360 `mod` x == 0]
05:46:19 <wei2912> forgot a square bracket at the front
05:47:00 <wei2912> > length [(x, 360 `div` x) | x <- [1..360], 360 `mod` x == 0]
05:47:04 <lambdabot>  24
05:47:15 <wei2912> > length [(x, 100 `div` x) | x <- [1..100], 100 `mod` x == 0]
05:47:17 <lambdabot>  9
05:47:22 <wei2912> bernalex: there you go
05:47:32 <qsuscs> wei2912: hm, but that’s still something different than mine
05:50:50 <mr-> qsuscs: I was suspecting that if you want to test that something is divisible by many numbers, you only want to see those for which it is possible.
05:50:57 <bennofs> piss-christ: you can create runnable code examples at https://www.fpcomplete.com/school
05:51:21 <bennofs> piss-christ: they also have a browser-based haskell IDE
05:51:41 <qsuscs> mr-: yes, but it’s still nice to see the other results
05:52:05 <mr-> qsuscs: anyway.. I just wanted to show list comprehensions to you :-)
05:52:45 <qsuscs> mr-: i know them, but i’m just not used to them (in programming lessons at school, we must use object pascal :( )
05:53:10 <lericson> !pl seq seq seq $ const const const
05:53:22 <lericson> not how you do it?
05:53:35 <gcganley> lericson: that hurts my head
05:53:36 <BoR0> @pl \x -> x
05:53:36 <lambdabot> id
05:54:10 <gcganley> @pl seq seq seq $ const const const
05:54:10 <lambdabot> seq seq seq const
05:54:20 <lericson> (it's basically id)
05:54:38 <gcganley> :t seq seq seq const
05:54:39 <lambdabot> b -> b
05:54:44 <gcganley> yup
05:55:01 <BoR0> :t id' f !x = x
05:55:03 <lambdabot> parse error on input ‘=’
05:55:21 <BoR0> > let id' !x = x
05:55:23 <lambdabot>  not an expression: ‘let id' !x = x’
06:02:37 * hackagebot csound-expression-dynamic 0.0.7 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.7 (AntonKholomiov)
06:02:38 * hackagebot csound-expression-typed 0.0.5.4 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.5.4 (AntonKholomiov)
06:07:37 * hackagebot csound-expression-opcodes 0.0.1 - opcodes for the library csound-expression  http://hackage.haskell.org/package/csound-expression-opcodes-0.0.1 (AntonKholomiov)
06:07:39 * hackagebot csound-expression 4.1.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.1.0 (AntonKholomiov)
06:07:41 * hackagebot csound-sampler 0.0.1 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.1 (AntonKholomiov)
06:08:53 <trullazzo> hi, i have a problem with my phone (samsung galaxy s4) when i change my mac address, the connection with a key (WPA) don't run but with WEP and without password it run why?
06:11:36 <YurasS> hmm... did samsung write wifi subsystem for s4 in haskell?
06:12:57 <trullazzo> YurasS: ? what
06:15:53 <sivteck> :t empty
06:15:55 <lambdabot> Alternative f => f a
06:17:38 * hackagebot keiretsu 0.4.4 - Multi-process orchestration for development and integration testing  http://hackage.haskell.org/package/keiretsu-0.4.4 (BrendanHay)
06:23:06 <pjdelport> > empty :: [a]
06:23:13 <lambdabot>  []
06:23:17 <pjdelport> > empty :: Maybe a
06:23:19 <lambdabot>  Nothing
06:24:03 <mitu> 4
06:29:28 <bernalex> is there some arrow ore somesuch that would let me write f a b like a f b? surely there is.
06:29:45 <Kinnison> a `f` b
06:29:46 <Kinnison> ?
06:29:52 <bernalex> Kinnison: that doesn't work for any f
06:30:25 <bernalex> say f is eg. "zipWith f". you can't do `(zipWith f)`, you'd need to use a let.
06:30:45 <Kinnison> is tht a problem?
06:31:07 <bernalex> uh yes I'm specifically asking of a way that would let me do that
06:31:13 <Kaini> Is there something like f (a -> b) -> a -> f b? I can't seem to find it with hoogle? I want to remove the returns (,,,) <$> Just 1 <*> Just 2 <*> return 3 <*> return 4
06:31:29 <bennofs> @let data (:$) a b = (:$) a b
06:31:30 <lambdabot>  .L.hs:153:17: parse error on input ‘:$’
06:31:32 <vanila> sorry but you need the returns
06:31:40 <bennofs> @let data (:$) a b = a :$ b
06:31:43 <lambdabot>  Defined.
06:31:57 <bennofs> @let a $: f :$ b = f a b
06:31:57 <lambdabot>  Parse failed: Parse error in pattern:
06:32:07 <bennofs> @let a $: (f :$ b) = f a b
06:32:20 <lambdabot>  Defined.
06:32:21 <Kaini> Hmm ok thanks
06:32:48 <bennofs> @let infixr 0 $:
06:32:50 <lambdabot>  Defined.
06:32:51 <bennofs> @let infixr 0 :$
06:32:52 <lambdabot>  Defined.
06:33:03 <Kinnison> bernalex: to my admittedly untrained eye, it sounds like 'let' is the tool to help you with that
06:33:21 <bernalex> Kinnison: yes, but I am asking if there is an arrow or somesuch that lets you achieve this.
06:33:28 <bennofs> > [1,2,3] $: zipWith (+) :$ [2,3,4]
06:33:30 <lambdabot>  [3,5,7]
06:33:33 <bennofs> bernalex: ^^^
06:33:43 <zwer> :t ($:)
06:33:43 <lambdabot> t2 -> ((t2 -> t1 -> t) :$ t1) -> t
06:33:54 <bernalex> bennofs: yes I know how to do that. that's not exactly what I am asking though. :-]
06:34:12 <Kinnison> bennofs: ooh pretty
06:35:17 <bennofs> bernalex: well, the difference between a `f` b and a $: f :$ b is not that big, IMO
06:35:43 <bernalex> bennofs: I am specifically asking if there is an arrow or something else in base that lets me do what I am asking.
06:35:57 <bennofs> bernalex: what do you mean with "arrow" ?
06:36:00 <bernalex> I am not having any trouble achieving it myself.
06:36:03 <bernalex> bennofs: Control.Arrow.
06:37:15 <bennofs> bernalex: so you're asking if that trick I used is in base somewhere?
06:37:38 <bernalex> bennofs: I am asking if there is something in base that lets me achieve what I described.
06:37:58 <bernalex> I would be surprised if there wasn't an arrow for it in Control.Arrow or something other neat lying around somewhere.
06:38:49 <lericson> @let (+) 1 1 = 3
06:38:52 <lambdabot>  Defined.
06:38:56 <lericson> > 1 + 1
06:38:58 <lambdabot>  Ambiguous occurrence ‘+’
06:38:58 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:162:3
06:38:58 <lambdabot>                        or ‘GHC.Num.+’,
06:38:58 <lambdabot>                           imported from ‘Prelude’ at L.hs:40:8
06:38:58 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
06:39:01 <nshepperd> I don't see how arrows would help with something like infix syntax
06:39:04 <bennofs> @undef
06:39:04 <lambdabot> Undefined.
06:39:06 <bernalex> lericson: *sigh*
06:39:52 <lericson> i was just curious!
06:39:52 <bernalex> nshepperd: it's not really about infix syntax. it's not much different from doing 1 & id.
06:40:19 <bennofs> > [(+1),id,(+3)] & zipWith id $ [4,4,4]   -- lens can do it! :)
06:40:22 <lambdabot>  [5,4,7]
06:40:35 <bernalex> & is in base too.
06:40:41 <bennofs> Really?
06:40:48 <bernalex> bennofs: I put it there myself.
06:40:53 <bennofs> oh nice :)
06:41:04 <bernalex> it's not in Prelude though
06:42:07 <bennofs> bernalex: which module? Data.Function?
06:42:13 <bernalex> bennofs: yep.
06:42:23 <bennofs> bernalex: it doesn't seem to be in base 4.7 yet
06:42:28 <augur_> :t (&)
06:42:29 <lambdabot> a -> (a -> b) -> b
06:42:37 <bennofs> so it will be in GHC 7.10 probably
06:42:45 <lericson> > 1 & (+1)
06:42:48 <lambdabot>  2
06:42:56 <bennofs> bernalex: did you also add (<&>) ?
06:42:56 <bernalex> bennofs: I guess. I thought it was out already.
06:43:03 <augur_> ahh, (&) is flip ($)
06:43:16 <bernalex> augur_: x & f = f x in my implementation
06:43:20 <augur_> right
06:43:22 <bennofs> And (??) ?
06:43:29 <vanila> I wonder why I like =<< but not &
06:43:33 <augur_> (<&>) = flip (<$>)  i take it?
06:43:39 <bennofs> yes
06:43:44 <bernalex> augur_: I think I was not allowed to put that in lol
06:43:47 <augur_> so (<&>) = yoneda :D
06:43:49 <bennofs> :t (??) -- this is also nice
06:43:49 <bernalex> I did put <$!> in though
06:43:50 <lambdabot> Functor f => f (a -> b) -> a -> f b
06:43:55 <vanila> I thnk it's because $ is a worse version of ., and there's no reverse composition for &?
06:44:11 <augur_> :t (<&>)
06:44:13 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:44:18 <augur_> yoooooneda :D
06:44:19 <bernalex> vanila: there's an arrow and a lens for everything
06:45:07 <bennofs> So we have ($>) = flip (<$) but not (<&>) = flip (<$>) ? :|
06:45:16 <bernalex> bennofs: IIRC, yes.
06:45:42 <augur_> bennofs: equational reasoning says we DO have (<&>) = flip (<$>)!
06:46:03 <bennofs> bernalex: what about (??) ?
06:46:06 <bernalex> I think if we put it in base we'll inline flip and maybe <$> too
06:46:27 <bernalex> bennofs: not afaik
06:46:38 <bennofs> > const ?? 4 $ 5
06:46:41 <lambdabot>  5
06:47:07 <bernalex> it's a cute operator for sure, but likely not worth polluting the namespace with.
06:52:42 * hackagebot tls 1.2.13 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.13 (VincentHanquez)
07:15:58 <bernalex> if I have f . g . h . i . j -- is there some neat arrow or something to let me write g . h . i . j . f?
07:16:03 <bernalex> or rather
07:16:15 <bernalex> g . h . i . j ?????? f
07:16:51 <bennofs> vermeille: g . h . i . j >>> f ?
07:16:59 <bernalex> ah
07:17:33 <bernalex> bennofs: yeah that's it! thanks
07:17:46 <bernalex> but I should be doing something else entirely in this specific situation of course
07:17:49 <bernalex> the f is (>>) :-P
07:18:01 <bennofs> :O
07:18:01 <bernalex> so it's some pointfree stuff (>>) . g . h . i . j
07:18:20 <bernalex> so g . h . i . j >>> (>>) is uhhh exciting but a bit erm yeah
07:18:42 <bennofs> (g . h . i . j >=>) . const
07:18:47 <bernalex> hah
07:18:53 <bernalex> that's kind of clever
07:19:13 <Fuuzetsu> say I have an instance of ArrowApply, call it (F :: * -> * -> *); how can I create a Monad instance for (F a) out of this, for some fixed ‘a’? I feel this should be simple but wrapping and unwrapping in ArrowMonad for ‘return’ gives me back return :: b -> F () b, not F a b
07:19:15 <bennofs> Actually, I wanted an operator that is to >> what >>= is to >=> pretty often already
07:21:20 <hyPiRion> We're running out of symbols
07:21:42 <bernalex> bennofs: hmm failed quite horribly to typecheck. I must be doing something wrong
07:21:56 <bennofs> bernalex: maybe the precedence of (>>>) is wrong=
07:22:05 <bernalex> bennofs: I meant with >=>
07:22:10 <bernalex> bennofs: with >>> it worked fine
07:22:44 <bernalex> so (shorter example now heh) (>>) . g . h works, and g . h >>> (>>) works but not (g . h >=>) . const
07:23:41 <bennofs> oh right, it's flip $ (g . h >=>) . const  -- I think
07:25:28 <bernalex> bennofs: erm won't that take a million arguments?
07:25:38 <bernalex> :t flip (id . id >=>) . const
07:25:39 <lambdabot> a -> (a -> b -> c) -> b -> c
07:25:45 <bernalex> :t f(id . id >=>) . const
07:25:47 <lambdabot>     Could not deduce (Typeable b1) arising from a use of ‘f’
07:25:47 <lambdabot>     from the context (FromExpr c, Typeable a)
07:25:47 <lambdabot>       bound by the inferred type of
07:25:48 <bernalex> :t (id . id >=>) . const
07:25:49 <lambdabot> Monad m => m c -> m b -> m c
07:26:00 <bennofs> :t flip $ (id . id >=>) . const
07:26:01 <lambdabot> Monad m => m b -> m c -> m c
07:26:36 <bernalex> well it should be just a
07:26:40 <bernalex> :t id . id >>> id
07:26:41 <lambdabot> c -> c
07:26:46 <bernalex> or yeah a -> a
07:27:16 <n4x> :t flip const ∷ Monad m => m a → m b → m b
07:27:17 <lambdabot> Monad m => m a -> m b -> m b
07:27:18 <bennofs> :t id . id >>> (>>)
07:27:19 <lambdabot> Monad m => m a -> m b -> m b
07:27:23 <bennofs> types match
07:27:26 <bernalex> oh derp
07:27:56 <bennofs> n4x: it's not actually const, because it doesn't ignore the actions of m a
07:28:13 <bernalex> bennofs: yeah I just missed some parens for ambiguity
07:28:16 <n4x> ah
07:28:30 <n4x> so just (>>)?
07:28:37 <shiona> is there a way to tell rewrite rules not to be recursive
07:28:48 <shiona> or even better, my own rule
07:30:14 <shiona> My prof asked me if it is possible to somehow trace program execution. He's using some sorting algo and would like as unobtrusive tracing as possible for exercise demo
07:30:24 <bennofs> Fuuzetsu: hmm, the Monad instance for ArrowMonad seems to explictly run the first arrow (in a >>= f, a is ran), so it needs to pass a some input.
07:31:04 <vanila> shiona, if you write it as a monad, you can sometimes change the monad a little to add tracing
07:31:04 <bennofs> shiona: you could use Debug.trace or the GHCi debugger
07:31:20 <Fuuzetsu> is that a ‘you can't do it’, it's kind of many hours after I should have gone to bed
07:31:32 <bennofs> Fuuzetsu: idk. What's your F?
07:31:42 <Fuuzetsu> HXT's LA
07:31:58 <Fuuzetsu> http://hackage.haskell.org/package/hxt-9.3.1.7/docs/Control-Arrow-ListArrow.html
07:32:12 <shiona> bennofs: At the moment I'm using Debug.trace, but I feel it might be a little bit off-putting for people in "principles of programming languages"
07:32:45 <shiona> It would be best if I could just have it completely outside the business logic à la Aspects
07:33:22 <bennofs> shiona: maybe use TH to generate main, which adds tracing?
07:33:27 <Fuuzetsu> well, I fell back to my orphan functor for now
07:33:39 <shiona> bennofs: ah, true.
07:34:23 <bennofs> Fuuzetsu: Hmm right, (a -> [b]) -> (b -> [c]) -> (a -> [c]) should be implementable ...
07:35:26 <bennofs> @let import Control.Arrow
07:35:29 <lambdabot>  Defined.
07:36:42 <Fuuzetsu> :t \f g -> concatMap g . f
07:36:43 <lambdabot> (a -> [a1]) -> (a1 -> [b]) -> a -> [b]
07:37:03 <ThreeOfEight> Fuuzetsu: correct me if I'm wrong, but I think you could just write this as (>=>)
07:37:18 <Guest57118> @undo do { advance; right <- led s left; expression' rbp right }
07:37:18 <lambdabot> advance >> led s left >>= \ right -> expression' rbp right
07:37:25 <Fuuzetsu> maybe
07:37:32 <hyPiRion> :t (>=>)
07:37:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:37:47 * hackagebot csound-sampler 0.0.2 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.2 (AntonKholomiov)
07:37:58 <hyPiRion> Same type signature.
07:40:22 <bennofs> :t \mx f -> (arr (\a -> mx >>> arr (\x -> (f x, a)) >>> app) &&& arr id) >>> app
07:40:22 <lambdabot> ArrowApply cat => cat c' b -> (b -> cat c' c) -> cat c' c
07:40:26 <bennofs> Fuuzetsu: ^^^
07:40:41 <bennofs> Fuuzetsu: that's the definition of >>= for any ArrowApply
07:41:15 <bennofs> :t arr . const
07:41:16 <lambdabot> Arrow a => c -> a b c
07:41:20 <bennofs> That is return
07:41:58 <bennofs> Or at least, the types match. Not sure if laws work out too
07:43:21 <bennofs> Oh, join is actually a lot easier:
07:43:29 <bennofs> :t \mx -> (max &&& arr id) >>> app
07:43:31 <lambdabot> Ord c => t -> c -> c
07:43:44 <bennofs> :t \mx -> (mx &&& arr id) >>> app
07:43:45 <lambdabot> ArrowApply cat => cat c' (cat c' c) -> cat c' c
07:45:19 <bernalex> OK so bear with me lads. this is obviously golfing for fun and not to be taken seriously. so relax. don't have a heart attack. but, where would the parens go if we'd replace .) . (. with .: in here:
07:45:21 <bernalex> Nothing -> insert ts >>= (flip $ (forM_ attrs . (insert .) . (. join (***) L.toStrict . first L.init) . uncurry . TimespanAttribute >=>) . const) <*> return
07:48:47 <bernalex> the reason a bunch of parens are needed btw is the fixity
07:49:33 <Fuuzetsu> bennofs: thanks for that, I'm off for today, dying
08:12:51 * hackagebot som 7.4.1 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.4.1 (AmyDeBuitleir)
08:13:46 <hsnoob> hi all. I have ported http://melpon.org/wandbox/permlink/iFBCg4M38IutEkfo to http://melpon.org/wandbox/permlink/sNuxgfjL8rpGMdlD but i think haskell code should be more beautiful. Help me with that, please
08:22:07 <pharpend_> hsnoob: definitely
08:24:04 <pharpend_> hsnoob: http://melpon.org/wandbox/permlink/wKybNKEufzAVUmU1
08:27:06 <hsnoob> pharpend_: thank you!
08:31:54 <Guest57118> @undo do { i0 <- get; let s0 = symbol i0; left <- nud s0; advance; expression' rbp left }
08:31:55 <lambdabot> <unknown>.hs: 1: 42:Parse error: <-
08:32:48 <pharpend_> hsnoob: in fact, you can make it even better
08:32:56 <geekosaur> Guest57118, let introduces layout, so you need extra braces
08:33:11 <geekosaur> ... let { s0 = symbol i0}; ...
08:33:30 <pharpend_> hsnoob: http://lpaste.net/112927
08:33:45 <Guest57118> @undo do { i0 <- get; let {s0 = symbol i0}; left <- nud s0; advance; expression' rbp left }
08:33:45 <lambdabot> get >>= \ i0 -> let { s0 = symbol i0} in nud s0 >>= \ left -> advance >> expression' rbp left
08:33:55 <pharpend_> :t (<<)
08:33:56 <lambdabot>     Not in scope: ‘<<’
08:33:56 <lambdabot>     Perhaps you meant one of these:
08:33:56 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
08:33:59 <Guest57118> geekosaur: thanks! ;)
08:33:59 <pharpend_> oh damn
08:34:33 <pharpend_> i forgot that << doesn't exist
08:34:38 <pharpend_> :t (<*)
08:34:38 <lambdabot> Applicative f => f a -> f b -> f a
08:34:40 <bernalex> pharpend_: do you mean flip >>?
08:34:49 <bernalex> pharpend_: no one can seem to agree how it should work iirc
08:34:54 <pharpend_> bernalex: yeah
08:35:11 <pharpend_> bernalex: I think it should be flip (>>), but I can understand why people want it to be (<*)
08:35:18 <pharpend_> :t flip (>>)
08:35:19 <lambdabot> Monad m => m b -> m a -> m b
08:35:51 <yukko> is it bad to write code like this safePixbufNewFromByteStringAtScale = ((handle (return . Left) .) .) . (((.) . (.) . (.)) (Right <$>) pixbufNewFromByteStringAtScale)
08:35:56 <pharpend_> yes
08:36:12 <pharpend_> becuase that type signature has to be absurd
08:36:26 <yukko> oh it's not actually
08:36:30 <bernalex> pharpend_: I definitely would want it to be (flip >>). (<*) would trip me up lol.
08:36:31 <yukko> safePixbufNewFromByteStringAtScale :: ByteString -> Int -> Int -> IO (Either GError Pixbuf)
08:36:49 <bernalex> yukko: I'd use .: or uh .:. or uh whatever you need in there
08:37:15 <yukko> oh, where are those defined?
08:37:21 <bernalex> yukko: probably... not.
08:37:45 <hsnoob> pharpend_: i tried (flip >>) but "The function ‘main’ is applied to two arguments"
08:37:53 <bernalex> yukko: we have them in our internal prelude at work heh. there's also the composition package.
08:37:53 <pharpend_> hmm
08:38:01 <yukko> bernalex oh I see!
08:38:05 <pharpend_> hsnoob: refresh the page, what does the code say
08:38:23 <bernalex> yukko: it's trivial. (.:) = (.).(.) and (.:.) = (.).(.).(.) and so on
08:38:43 <yukko> that's really cool!
08:39:04 <bernalex> hsnoob: hm? you're doing it wrong? flip (>>) (putStrLn "hallo") (putStrLn "world")
08:39:24 <hsnoob> oh thank you! main = getCurrentTime >>= print >> main
08:40:04 <bernalex> yukko: we only have up to .:. implemented here (haven't had use for more yet lol), but I have comments that explain them if you get confused heh: https://github.com/plaimi/plailude/blob/master/src/Plailude/Function/Compose.hs
08:40:09 <pharpend_> what's the difference between >> and *>
08:41:43 <bernalex> @src (>>)
08:41:43 <lambdabot> m >> k = m >>= \_ -> k
08:41:45 <bernalex> @src (*>)
08:41:45 <lambdabot> (*>) = liftA2 (const id)
08:42:28 <pharpend_> :t const
08:42:29 <lambdabot> a -> b -> a
08:42:33 <pharpend_> :t const id
08:42:34 <lambdabot> b -> a -> a
08:42:44 <alpounet> pharpend_: *> works in any Applicative, whereas >> works in any Monad
08:43:25 <pharpend_> 'ma;
08:43:27 <pharpend_> okay
08:43:29 <pharpend_> hmm
08:46:25 <a3gis> Hello! Could anyone explain to me the following behaviour: toLower (toUpper '\181') -- => '\956' ?
08:46:27 <a3gis> > toLower (toUpper '\181')
08:46:29 <lambdabot>  '\956'
08:46:44 <pharpend_> okay
08:47:01 <pharpend_> a3gis: so, toUpper takes some character and makes it uppercase
08:47:24 <pharpend_> a3gis: in this case, the character (i'm guessing) is already uppercase
08:47:31 <pharpend_> > toUpper '\181'
08:47:32 <lambdabot>  '\924'
08:47:35 <pharpend_> nop
08:47:37 <pharpend_> okay
08:47:39 <pharpend_> hmm
08:47:47 <pharpend_> it seems like toLower . toUpper should be id
08:47:57 <geekosaur> it'd be nice if Unicode worked that way
08:47:58 <a3gis> yep that's what confuses me
08:48:01 <geekosaur> but it doesn't
08:48:34 <a3gis> so the answer is that unicode is a fucked up encoding scheme?
08:48:38 <a3gis> ^^
08:48:48 <pharpend_> well it's usually pretty good
08:48:58 <pharpend_> you know what it might be
08:49:11 <pharpend_> the first character '\181' might have an accent or something
08:49:18 <pharpend_> and then upcasing it gets rid of the accent
08:49:32 <a3gis> the problem arose in an exercise involving a case-insensitive "prefix" function: https://gist.github.com/neanias/d0aebffb45d9f4b1dc11
08:49:37 <pharpend_> it might be ß, and the upcase is B, then downcase is b
08:49:52 <a3gis> I guess one could just ignore everything that isn't alphanumeric then
08:49:54 <a3gis> mmh ok
08:50:00 <a3gis> oh yeah
08:50:04 <a3gis> that's a good point
08:50:09 <a3gis> I didn't think about the accent problem
08:50:09 <geekosaur> is that beta or es-zet? uppercase es-zet is SS, whose lowercase is ss
08:50:22 <geekosaur> also normalization comes into play
08:50:26 <pharpend_> yeah
08:50:31 <geekosaur> unicode is ... hard
08:50:39 <Chousuke> locale also matters
08:50:57 <Chousuke> the uppercase of i is not I in Turkish, for example.
08:51:04 <pharpend_> ah yeah
08:51:18 <a3gis> oh wow
08:51:22 <a3gis> ok I googled it
08:51:27 <a3gis> 181 is the "micro sign": http://www.fileformat.info/info/unicode/char/b5/index.htm
08:51:32 <pharpend_> mu
08:51:39 <a3gis> 924 is the upper case mu, http://www.fileformat.info/info/unicode/char/039c/index.htm
08:51:41 <pharpend_> µ
08:51:44 <a3gis> and 956 is downcase mu
08:51:50 <a3gis> which is exactly like the micro sign
08:51:52 <pharpend_> ah okay
08:51:56 <a3gis> just a different semantics I guess?
08:52:04 * pharpend_ glares at unicode
08:53:00 <a3gis> oh well, I learned something at least :p
08:53:02 <a3gis> thanks for the help
08:53:14 <Chousuke> It might be possible to normalize the string to get rid of such things.
08:53:52 <a3gis> Chousuke: yeah I could just filter on isAlpha or something; the fact that isLower . isUpper /= id confused me
08:54:03 <a3gis> toUpper . toLower *
08:55:32 <Chousuke> a3gis: When people say "Unicode is difficult" they actually mean "text is difficult". :P
08:56:04 <geekosaur> well, human languages are difficult
08:56:12 <geekosaur> text just reflects that
08:57:20 <lericson> at the end of the day it's jut like, symbols, man.
08:58:13 <geekosaur> and there we see the belief that lies at the root of pretty much every unicode issue >.>
08:58:18 <Hodapp> Haskell is just, like, JavaScript with different words for things
08:59:04 <josephle> whoa.
08:59:18 <lericson> Hodapp: well, and a type system
08:59:21 <lericson> and some other... stuff
09:00:02 <Hodapp> lericson: Those are just trivial, trivial details.
09:00:13 <Hodapp> lericson: Like frosting. On a cake. Made of programs.
09:00:22 <lericson> but with symbols.
09:00:29 <Hodapp> No. The cake is made of programs
09:00:35 <Hodapp> The symbols are the frosting.
09:00:37 <josephle> it pains me to realize this is how Scala views itself
09:00:44 <josephle> with its "cake-pattern"
09:00:45 <Hodapp> josephle: Scala is self-aware?
09:00:52 <josephle> almost there
09:00:54 <josephle> it had assistance
09:01:00 <Hodapp> "cake-pattern"?
09:01:36 <Hodapp> I've not used Scala in... hmmm, 24 months or so
09:06:08 * chirpsalot shakes fist at JuicyPixels.
09:06:20 <chirpsalot> No built in way to take an RGB8 to an RGB16? D:
09:12:37 <hiptobecubic> type RGB16 = RGB8
09:12:41 <hiptobecubic> Done.
09:17:19 <chirpsalot> hiptobecubic: what? XD
09:23:59 <renanra> Hi there! Anyone can help me with polymorphic arguments? I don't know how to get any number and multiply it to a (a,b, c) tuple where a b c can be any number type.
09:24:01 <renanra> http://lpaste.net/112930
09:24:18 <renanra> #beginning_stuff
09:26:57 <rrradical> renanra: for multiplication, both arguments must be the same type. you can call fromIntegral on the Int's to convert them to Doubles
09:29:05 <rrradical> renanra: if you look in the typeclass for Num, you find (+), (*), (-) :: a -> a -> a, which means although those functions can take numbers of any type as arguments, the arguments must all be the same type (they are all 'a')
09:31:00 <renanra> I thought it would be possible to define a generic vector data to be matched by the argument, something like: data Vector a = Vector (a, a, a) deriving (Show)
09:31:34 <renanra> And then multiplies :: (Num t) => Vector t -> t -> Vector t
09:32:05 <piss-christ> is there a lib to read /etc/os-release?
09:34:03 <chaosfisch> Hello, is the maximum Integer I can use platform specific?
09:34:25 <geekosaur> chaosfisch, very, it's limited by available process memory
09:34:30 <lifter> chaosfisch: I would think it's CPU-spcific
09:34:54 <chaosfisch> that means I have to use sth. like: maxBound :: Int
09:35:04 <geekosaur> do you actually mean Int or Integer?
09:35:11 <geekosaur> Int is Bounded, Integer is not
09:35:27 <chaosfisch> Integer, I copied the wrong example.
09:35:37 <geekosaur> then there is no maxBound
09:36:55 <chirpsalot> geekosaur: unless you run out of memory.
09:37:24 <geekosaur> chirpsalot, that is not relevant to the definition of maxBound
09:37:43 <geekosaur> in fact it's one definition of a type where maxBound is meaningless
09:38:07 <chirpsalot> Oh, we're talking about maxBound in particular?
09:38:20 <chirpsalot> Integer isn't in Bounded, is it?
09:38:23 <geekosaur> [20 16:41] <chaosfisch> that means I have to use sth. like: maxBound :: Int
09:38:37 <geekosaur> and exactly, Integer is not in Bounded and can't be
09:50:54 <rrradical> renanra: That should be fine. It's not in your paste though, what problem are you running into now?
09:51:58 <rrradical> renanra: Might as well just use data "Vector a = Vector a a a" though. No need to add an extra tuple
09:56:15 <renanra> rrradical: Thanks for the help. I'm running into this problem: http://lpaste.net/112932.
09:56:47 <renanra> rrradical: I don't know exactly what it is.
09:57:29 <rrradical> renanra: So, it's saying Vector3D is not the same as Vector t, which is true
09:58:01 <rrradical> renanra: your multiplies method has a type signature with Vector t, but you try to pattern match on Coordinate, which is a Vector3D
09:59:49 <rrradical> renanra: it sounds like you want types Color and Coordinate, which are really just specializations for Vector for Int and Double. so you can make type aliases for them. type Color = Vector Int and type Coordinate = Vector Double
10:01:31 <rrradical> or you can use newtype instead of type if you want the compiler to distinguish between them.
10:03:07 <zmbmartin> Hey Guys, trying to figure out a better approach to this code. It works, but feels strange. https://gist.github.com/codedmart/c554b3713fc5393cda6c
10:03:09 <renanra> rrradical: thank you. I'll try it out.
10:09:28 <FireFly> @ty (?f &&& ?g)
10:09:29 <lambdabot> (Arrow a, ?g::a b c', ?f::a b c) => a b (c, c')
10:09:38 <FireFly> ↑ what is that ?foo extension called?
10:10:11 <glguy_> FireFly: ImplicitParams
10:10:23 <FireFly> Thanks
10:11:13 <rcharles> I am trying to print out a ByteString data as Hex. What is best way of doing that?
10:12:12 <jfischoff> rcharles: I’m not exactly sure what you mean, can you show an example?
10:13:10 <glguy_> rcharles: This is what I use: http://hackage.haskell.org/package/pretty-hex-1.0/docs/Hexdump.html
10:13:42 <jfischoff> glguy_: that’s cool
10:13:49 <rcharles> thanks glguy_ that is what I was looking for.
10:17:10 <sinelaw> does anyone have a reference implementation of hindley-milner with ML-style value restriction?
10:17:30 <sinelaw> I'm not sure how HM is modified to support it
10:18:41 <carter> value restriction on refs?
10:20:00 <sinelaw> carter, value restriction on let expressions when the right-hand side is not syntactically a value
10:20:11 <sinelaw> let x = something in ...
10:20:18 <josephle> I think the value restriction affects more than just refs, but refs are the motivating reason
10:20:28 <sinelaw> if 'something' is not a syntactic value, then x is assigned a monotype
10:21:44 <sinelaw> oh actually I just found what I needed in the original paper
10:22:01 <Freundlich> Didn't you answer the question yourself already?
10:22:14 <sinelaw> Freundlich, no the question is how exactly is this implemented
10:22:29 <Freundlich> Because that's how you modify the algorithm: Use a polymorphic type iff the expression is a syntactic value.
10:26:24 <sinelaw> Freundlich, in Wright's paper he says that non-syntactic let assignments: let x = e1 in e2  are translated to: (\x -> e2) e1
10:28:54 <Freundlich> sinelaw: How does that help? That's still not a value.
10:29:13 <sinelaw> Freundlich, it forces the algorithm to treat x as a monotype
10:29:34 <sinelaw> because now it's a function parameter
10:29:36 <Freundlich> Ah, right.
10:30:20 <sinelaw> but i think you're right - one might as well assign for 'x' a non-polymorphic type scheme in the environment
10:30:24 <sinelaw> directly
10:30:32 <Freundlich> So you do a syntactic transformation instead of adding another case to the algorithm, right?
10:30:42 <sinelaw> Freundlich, seems that's his approach
10:30:55 <sinelaw> Freundlich, maybe it was simpler to implement in ML
10:30:56 <sinelaw> that way
10:31:19 <sinelaw> it's also more elegant
10:31:55 <sinelaw> because you're still using the original algorithm, clean HM with no special treatment, you just feed it processed syntax that ensures that the dangerous code gets a monotype
10:32:52 <taptap_> in lambda calculus, is there a strict NEED for the "dot" right after the lambda-variables or are they just there for increasing readability?
10:33:06 <taptap_> as in these: λx.λy. x*x+y
10:33:41 <sinelaw> taptap_, how will you know the name of the variable ended and the body starts?
10:34:28 <taptap_> sinelaw: so you mean λ-calculus allows names containing spaces as in with "my modified" version will not?
10:34:42 <taptap_> other than that: the body does not start with a λ-symbol
10:35:02 <jfischoff> taptap_: it’s not necessary
10:35:19 <sinelaw> taptap_, you just need a way to make it unambiguous
10:35:53 <jfischoff> many concrete syntaxes could make a lambda calculus ast
10:35:57 <taptap_> okay!
10:36:22 <Freundlich> Probably the same reason logic syntax uses dots after quantifiers. It seems familiar.
10:37:06 <sinelaw> maybe also  because in general, whitespace is not a good (easy to see) separator in paper articles
10:38:21 <monochrom> whatever you choose to modify the syntax, write down the complete new grammar and prove that it's unambiguous.
10:40:19 <sudeep> hi
10:40:21 <sudeep> hello
10:40:25 <sudeep> All
10:40:41 <jfischoff> hi sudeep
10:40:45 <sudeep> what is the difference between types and typeclass
10:41:04 <sudeep> jfischoff: hi sir
10:41:37 <jfischoff> types classify values, typeclasses put types into groups
10:42:00 <sudeep> jfischoff: more deeply
10:42:07 <sudeep> jfischoff: examples please
10:42:33 <jfischoff> sudeep: can you explain your confusion more?
10:42:47 <monochrom> does it help to answer: like the difference between fish and fish net?
10:42:49 <sudeep> jfischoff: i want to know the diffference
10:42:55 <kadoban> sudeep: Integer is a type, of integer numbers. Eq is a typeclass that represents types that can be compared for equality.
10:43:07 <DannyFritz> anyone use hlint?
10:44:04 <sudeep> kadoban: you mean the +, == are typeclass and 1 (int) is type
10:44:39 <monochrom> no, Num and Eq are type classes. + and == are methods in those type classes.
10:44:40 <kadoban> sudeep: No, the common operators are members of typeclasses. 1 is a value, not a type.
10:44:58 <jfischoff> 1 has a type, that type is Int
10:45:05 <dmj`> DannyFritz: yea
10:45:15 <jfischoff> well in haskell 1 has the type Num a => a
10:45:17 <DannyFritz> dmj`: hlint?
10:46:19 <joelteon> most people use hlin
10:46:19 <sinelaw> :t (==)
10:46:21 <lambdabot> Eq a => a -> a -> Bool
10:46:21 <joelteon> t
10:47:01 <sinelaw> sudeep, see above - the type of the function == is: for any type "a" that is in the type class Eq, == has type: a -> a -> Bool
10:47:41 <sudeep> sinelaw: Understanding better
10:47:48 <sinelaw> sudeep, whereas a function such as id :: a -> a does not require it's type to belong to any type class
10:47:55 <sudeep> sinelaw: so typeclass is grouping similar types
10:47:57 <sinelaw> *its
10:48:02 <sinelaw> sudeep, sort of, yeah
10:48:05 <ifesdjeen> hi everyone, do you know if it's possible to add libc as an external library when building an haskell FFI library?
10:48:20 <sinelaw> sudeep, but a type can "implement" many difference type classes
10:48:33 <sudeep> sinelaw: do you have a github of your haskell project
10:48:39 <ifesdjeen> I'm making Haskell bindings for something that relies heavily on libc, and it looks like ghc can't find libc...
10:48:42 <sinelaw> sudeep, which project?
10:48:44 <DannyFritz> dmj`: sorry, i meant. are there other linters worth noting?
10:49:02 <sudeep> sinelaw: any i just want to engage
10:49:30 <sinelaw> sudeep, here's a simple one: https://github.com/sinelaw/xml-to-json
10:49:54 <sudeep> sinelaw: thanks
10:50:03 <sinelaw> sudeep, but there are many good online books that walk you through it
10:50:36 <sudeep> sinelaw: oh it would be great if you could recommend me some
10:51:25 <sinelaw> sudeep, http://www.haskell.org/haskellwiki/Books_and_tutorials
10:51:50 <sinelaw> sudeep, and in particular, http://learnyouahaskell.com/chapters
10:52:08 <sinelaw> sudeep, that's one that many consider a nice read (I didn't read it myself)
10:52:45 <sudeep> sinelaw: i am already going through those books
10:53:04 <sudeep> sinelaw: i want to contribute to simple haskell project now
11:09:00 <success> (load "~/haskell-mode") what is rong with that? haskell-mode is int home/username/haskell-mode
11:11:09 <dmj`> success: https://github.com/haskell/haskell-mode/wiki/Installation
11:13:19 <blackmirroxx> hi @all
11:16:11 <success> staffan@staffangolazo:~/haskell-mode$ make EMACS=usr/bin/emacs24
11:16:12 <success> make: usr/bin/emacs24: Command not found
11:16:12 <success> make: *** [ghc-core.elc] Error 127
11:16:36 <simpson> success: /usr/bin/emacs24
11:16:53 <joelteon> :/
11:17:11 <success> H TY
11:17:13 <success> ah ty
11:17:33 <sadsiren> hello friends
11:20:56 <success> Wrote /home/staffan/haskell-mode/haskell-mode-autoloads.el
11:20:57 <success> (No changes need to be saved)
11:20:57 <success> sed -e 's/@@GIT_VERSION@@/13.10-249-g96764a9/g;s/@GIT_VERSION@/13.10-249-g96764a9/g;s/@@VERSION@@/13.10/g;s/@VERSION@/13.10/g' < haskell-mode.texi > haskell-mode.tmp.texi
11:20:57 <success> makeinfo  -o haskell-mode.info haskell-mode.tmp.texi
11:20:57 <success> make: makeinfo: Command not found
11:20:58 <success> make: *** [haskell-mode.info] Error 127
11:22:36 <jle`> does anyone know why MonadState requires Monad
11:22:48 <jle`> perhaps it is because of the implied laws
11:23:10 <jle`> get >>= put == return () or something
11:23:35 <jle`> other than that i am not sure
11:23:37 <monochrom> to me it saves writing "(Monad m, MonadState Int m) => m Bool"
11:24:03 <jle`> hm.
11:24:57 <jle`> fair enough
11:25:02 <jle`> maybe
11:25:26 <jle`> but what if i wanted a MonadWriter for say, an Applicative
11:25:47 <jle`> that isn't a Monad
11:26:34 <jle`> then what.
11:27:03 <monochrom> not enough people have wanted it enough to call for a change. you will have to wait for a future revolution
11:27:30 <jle`> it bothers me at a theoretical level
11:27:43 <jle`> but i am probably happier off for it being this way
11:28:05 <jle`> but i'm going to try to think of useful MonadState/MonadWriter/MonadReader instances for non-monads
11:28:10 <jle`> and maybe i will change the world
11:28:29 <jle`> i can sort of understand MonadState, because of laws
11:28:54 <jle`> MonadReader i cannot imagine involving Monad in any of its "laws"
11:29:01 <jle`> MonadWriter perhaps, i'll have ot think about it.
11:29:33 <monochrom> there is always tension between: theoretically, if everything is independent of everything, you have maximum flexibility in mix-and-match; practically, people don't actually use all possible combinations, there end up only a few common ones.
11:29:45 <jle`> i think a problem is that i am not sure people have even written down concrete laws for these typeclasses
11:29:51 <jle`> does anyone know of these exist?
11:30:07 <success> What is the recommended lib for opengl?
11:30:19 <success> I want raw opengl, not abstractions on top of it
11:30:40 <monochrom> theoretically, you even want each class to talk about one method only.
11:30:41 <jle`> oh i found some somewhere obscurely.
11:30:57 <jle`> i don't think having each class talk about one method only is ideal
11:31:08 <jle`> the methods can really only make sense when they mutually involve eachother in laws
11:31:47 <jle`> typeclasses should have a (minimal?) set of methods which can create meaningful laws together
11:33:58 <jle`> this is all research for my upcoming article, "mtl is not a transformer library"
11:34:43 <karshan> > :t extend
11:34:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:35:52 <success> Is there a certain way things should be installed from hackage to ensure proper usage?
11:35:53 <monochrom> mtl is like dashboard
11:36:08 <dmj`> jle`: its like an instance library
11:36:53 <monochrom> many centuries ago, dashboard was merely a board in front of the passengers of a cart to block dust etc
11:37:33 <monochrom> today, dashboard refers to a data panel, it is not dash or board
11:37:50 <monochrom> correction: it is not a board for blocking dash
11:38:24 <monochrom> mtl is in the same situation. mtl version 1 was a transformer library, it contained code for both StateT and MonadState
11:38:55 <monochrom> it was the merger and peace treaty with transformers that took StateT away from mtl
11:39:14 <monochrom> also, all of this happened long before people talked about Applicative
11:39:36 <monochrom> "mtl is not a transformer library" will be as interesting as "dashboard is not dash board".
11:39:44 <RchrdB> monochrom: can we work the phrase "in bygone days of yore" into this please?
11:39:49 <RchrdB> Good explanation.
11:39:51 * sinelaw is feeling nostalgic
11:40:14 <sinelaw> those were the days.
11:41:13 <monochrom> a thing was invented. it got a fitting name. then the thing got repurposed. the name sticks and is unfitting. this is totally uninteresting.
11:41:56 <sinelaw> that should totally be Haskell's marketing tagline
11:44:52 <monochrom> RchrdB: simply replace "many centuries ago" by "in bygone days of yore" :)
11:45:28 <geekosaur> "many ages ago, when this ancient land was not quite so ancient..."
11:46:15 <jle`> monochrom: uninteresting, but i feel it does lead to some pedagogical issues
11:46:28 <jle`> it would be nice to clear the air so newcomers would stop thinking about mtl as a transformer library
11:46:32 <jle`> because i think a lot of people still do
11:46:34 <sinelaw> confusing library names are confusing
11:47:26 <sinelaw> it would suffice to change the acronym's meaning
11:47:35 <jle`> monad typeclass library
11:47:37 <jle`> :D
11:47:48 <sinelaw> I was thinking "Thingies"
11:47:57 <jle`> many typeclasses library
11:48:14 <sinelaw> to prevent future repurposing from breaking the name again
11:48:23 <jle`> future-proofing it, nice idea
11:48:25 <sinelaw> "Many Thingies Library"
11:48:41 <monochrom> my solution is to put the string "MTL" in the same genre as the string "DVD". that is, DVD is already the full name, it is no longer an abbreviation of "digital video disc" or "digital versatile disc".
11:48:45 <jle`> let's strip all meaning from the name at all
11:48:49 <sinelaw> because monads are so passe
11:48:57 <jle`> meaning only obscures things
11:49:14 <sinelaw> exactly. what is mtl? it is an mtl.
11:49:24 <sinelaw> but what does it do? it does an mtl.
11:49:25 <jle`> emtee el
11:49:43 <sinelaw> burn me an mtl, will ya
11:50:07 <sinelaw> but seriously, the name as it is is seriously confusing.
11:50:20 <jle`> how about just "al"
11:50:22 <jle`> a library
11:50:26 <joseanpg> hi
11:50:29 <joelteon> what if you remove the a?
11:50:36 <sinelaw> tal: THE a library
11:50:39 <jle`> does it become a billion dollar idea ow
11:50:42 <joelteon> it'd be like -lc
11:50:43 <jle`> hi joelteon :D
11:50:45 <jle`> er
11:50:48 <jle`> joseanpg :D
11:51:34 <joelteon> oh :(
11:51:35 <sinelaw> the way things are going, the name will be "Prelude" anyhow
11:51:44 <jle`> you too joelteon :)
11:52:23 <sinelaw> hi jo :)
11:53:18 <piss-christ> I'm getting shitload of compilation errors when I'm trying to install software with cabal install. tls-1.2.12 fails, haskell-src-exts-1.16.0 fails, zlib-0.5.4.1 fails
11:53:33 <piss-christ> which prevents me from installing other software like newer cabal-install, hlint and stuff
11:53:43 <piss-christ> is this normal? Or any idea what is going on?
11:53:49 <monochrom> this is abnormal
11:54:07 <success> How do I install from hackage?
11:54:14 <success> can I do it with cabal?
11:54:16 <Tix_> @pl \xs n -> take n xs ==> flip take
11:54:16 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
11:54:29 <piss-christ> in some cases I can see an error but in some cases it just tells me compilation failed with ExitFailure 127 and  I have nothing else to go on
11:54:48 <LunarJetman> piss-christ: I suspect that given your nickname you are an atheist?
11:55:24 <piss-christ> LunarJetman: I am https://en.wikipedia.org/wiki/Piss_Christ
11:55:42 <dmj`> LunarJetman, piss-christ: off topic
11:57:08 <geekosaur> 127 often means some program is missing
11:58:06 <piss-christ> hmm, then strace might help there but I actually I don't see  any 127 in the last batch of errors :/
11:58:59 <piss-christ> I'm trying cabal sandbox now as I had <1.18 cabal install so I had to install stuff without sandboxes so maybe there's something messed up
12:00:35 <sudeep> ho
12:00:38 <sudeep> hi
12:00:56 <sudeep> i am having difficulty to understand Curried Function
12:01:12 <sudeep> add' :: int -> int -> int
12:01:39 <sudeep> does not this means add' takes two paramter int and int and return int
12:01:45 <sudeep> ?
12:01:52 <crobbins> sudeep: yes
12:01:59 <RchrdB> sudeep: yep (it's spelled "Int -> Int -> Int" though; Haskell data types names always start with upper-case letters)
12:02:21 <sudeep> then how does it returns function as a result
12:02:30 <crobbins> sudeep: although, you can also think of it as :: Int -> (Int -> Int)
12:02:37 <sudeep> RchrdB: that is not a problem here
12:02:42 <crobbins> it curries its arguments
12:03:09 <crobbins> sometimes people will say, a function only takes one argument
12:03:10 <sudeep> crobbins: how does it curries
12:03:10 <jfischoff> they idea behind currying and uncurrying is that a multiarg function can equally be thought of as a series of functions that return other functions.
12:03:13 <RchrdB> sudeep: *gasp* you're secretly learning ML! ;)
12:03:31 <kadoban> sudeep: It can be thought of like that because (add' 5) is a new function and you can use it like one.
12:03:34 <sudeep> RchrdB: that is also not the problem :D
12:03:36 <crobbins> sudeep: it is part of the language
12:04:06 <monochrom> sudeep: it is Int -> (Int -> Int). you can say: "add' 4". that gets you Int->Int, a function.
12:04:07 <crobbins> sudeep: so if you do `add' 5` it will return a new function that is `Int -> Int`
12:04:13 <sudeep> jfischoff: so multi argument function all can be thought as currying
12:06:05 <jfischoff> more like f :: (a, b, …, y) -> z can be thought of a -> (b -> ( … -> (y -> z))))))….)
12:06:59 <sudeep> jfischoff: i have known that add :: (Int, Int) -> Int is not curried onw
12:07:22 <jfischoff> onw?
12:07:53 <sudeep> but if add' :: Int -> Int -> Int is curried one becaue at first it takes one int and return function and it takes second argument and return the Int
12:08:22 <sudeep> jfischoff: igone onw
12:09:11 <jfischoff> ah one
12:10:13 <sudeep> jfischoff: it's late night so little a bit typing mistake don't mind
12:10:26 <jfischoff> I don’t mind ;)
12:10:38 <jfischoff> but I am also not sure if I helped
12:10:42 <sudeep> jfischoff: the function having multiple parameter and which takes argument one at a time is curried simply
12:10:43 <jfischoff> are you still confused?
12:10:54 <sudeep> jfischoff: nope, it's clear
12:11:17 <jfischoff> okay cool
12:11:21 <sudeep> jfischoff: i found some reference regarding this
12:11:33 <jfischoff> ah okay
12:12:56 <success> Is it possible to show a fgunction that you defined?
12:13:14 <success> f x = x*x+3 => "f x =x*x+3"
12:13:17 * hackagebot alea 0.3.0.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.3.0.0 (rnhmjoj)
12:13:31 <jfischoff> success: in general no
12:13:49 <jfischoff> there are hacks
12:14:14 <sudeep> read the line from the file and print it
12:14:15 <sudeep> :)
12:14:17 <VelocityKendo> and :type expression ?
12:14:48 <jfischoff> sudeep: probably possible although evil
12:15:14 <sudeep> jfischoff: using regular expression, it is possible i have done in python
12:23:37 <zmbmartin> Can I get some feedback on this code? Is one preferred or more proper over the other or is there a better way entirely to do it?
12:23:52 <zmbmartin> https://gist.github.com/codedmart/c554b3713fc5393cda6c#file-main-hs-L9-L22
12:26:00 <dmj`> zmbmartin: if readMaybe returns Nothing, fromJust will throw an exception on it
12:27:03 <dmj`> oh, but you get that around, by calling fmap on it
12:27:12 <zmbmartin> dmj`: On line 11 I run it through response which either return Left NotFound or passes the fmap through. It feels weird but works.
12:27:22 <amf> is there a way to add more entries to an already defined enum? e.g. i want to add some custom http status codes, but use what http-types already has
12:27:30 <zmbmartin> Which is why I was asking for feedback on if this is appropriate or not.
12:28:38 <zmbmartin> dmj`: Just trying to see what is more haskellish or if I am off the mark completely?
12:31:32 <zmbmartin> dmj`: Any suggestions?
12:32:55 <ReinH> So apparently haskell-src-exts thinks that `proc' is the arrow notation keyword whether the language extension is enabled or not! Fun!
12:33:06 <ReinH> Does anyone *actually* use arrow notation btw?
12:33:16 <dmj`> zmbmartin: yea one sec
12:33:24 <dmj`> zmbmartin: writing it
12:33:51 <zmbmartin> dmj`: Awesome thanks!
12:33:52 <Hijiri> arrow notation is used a lot with arrow FRP libraries
12:34:04 <ReinH> zmbmartin: shadowing `id' is probably a bad idea. I would not expect `response id' to do what it, in fact, does.
12:34:21 <success> why does haskell make such easy things so hard...?
12:34:29 <zmbmartin> ReinH: OK good to know.
12:34:30 <ReinH> success: to make the hard things possible?
12:34:48 <ReinH> success: perhaps you could be more specific about which easy things you are finding difficult
12:35:04 <zmbmartin> ReinH: So would the second getById be more preferred?
12:35:07 <ReinH> There are often good reasons, but they are sometimes not immediately apparent
12:35:26 <ReinH> zmbmartin: seems reasonable. I use id' sometimes if I actually have an identifier, but I'm not sure how I feel about that myself.
12:36:05 <ReinH> amf: types are not extensible, no
12:36:20 <zmbmartin> ReinH: So are lines of code ever something that try to be reduced in Haskell terms. Or is readability more important?
12:36:45 <ReinH> zmbmartin: Readability is more important, although Haskell is read a bit differently than other languages
12:37:10 <ReinH> for instance, for parametric types, short identifiers are *more* readable: id :: a -> a is more readable than id :: theType -> theType, for instance
12:37:24 <ReinH> you don't care what the type is, you just care that you can compare two type variables easily
12:37:40 <zmbmartin> ReinH: OK, that makes sense. Thanks!
12:37:45 <ReinH> Also it's quite easy to write things like theType -> tehType and have a subtle bug
12:38:16 <zmbmartin> I went from functions with a few case statements to trying to get them to a single line.
12:38:25 <zmbmartin> But that is probably not the best idea.
12:38:45 <ReinH> zmbmartin: folds like maybe and either can be useful for that, but often cases statements are more readable
12:39:23 <zmbmartin> What do you mean folds. I am doing case statements on maybe and either
12:39:27 <ReinH> The point isn't to use the most clever combinator, it's to communicate to humans what your code does (and also to computers, although that is secondary)
12:39:33 <ReinH> :t maybe
12:39:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:39:44 <ReinH> maybe folds a Maybe a value into a b value
12:39:46 <ReinH> :t foldr
12:39:47 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:39:53 <ReinH> foldr folds a [a] value into a b value
12:40:27 <ReinH> :t either
12:40:28 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:40:34 <ReinH> either folds an Either value into a c value
12:41:01 <ReinH> You usually hear the term fold used to describe folding things like lists
12:41:13 <ReinH> but these are all examples of general folds, also known as "catamorphisms"
12:41:19 <zmbmartin> ReinH: So is using maybe and either with case statements considered ok?
12:41:33 <ReinH> zmbmartin: case statements are perfectly fine
12:41:55 <ReinH> maybe and either are nice when their arguments are short
12:42:13 <ReinH> they get less readable as their arguments get longer
12:42:43 <zmbmartin> ReinH: OK, I feel like I am stuck in imperative world. So I want to make sure I am using the benefits of Haskell and functional thinking.
12:42:53 <dmj`> zmbartin: maybe this: http://lpaste.net/112943
12:43:24 <dmj`> zmbmartin: you seem to be calling Left NotFound twice, once if the ID can't be parsed, another if the DB doesn't contain the ID, is that right?
12:43:53 <zmbmartin> dmj`: Yes I do and I wanted to get away from that.
12:43:59 <zmbmartin> Thanks let me try that.
12:44:02 <dmj`> zmbartin: you have a maybeToEither thing going on
12:44:14 <dmj`> Monad m => Maybe a -> m (Either b c)
12:44:27 <ReinH> Hmm. If you flip the arguments, getById t = return . maybe handleNoId handleId
12:44:27 <rayan> hello
12:44:37 <ReinH> dmj`: such natural transformation wow
12:45:37 <dmj`> ReinH: true, but pointfreeing it might remove the type annotation readMaybe needs to survive in the wild
12:45:47 <dmj`> ReinH: yes very monad :)
12:46:33 <ReinH> dmj`: shouldn't runDb have enough type information?
12:47:42 <dmj`> ReinH: the "show id" makes me think not, we could annotate handleId :: UID -> m a
12:47:52 <ReinH> dmj`: ah
12:47:58 <ReinH> true
12:49:26 <ReinH> return . maybeToEither NotFound handleId where maybeToEither = flip maybe Right . Left -- and handleId is adjusted appropriately ;)
12:49:37 <ReinH> I'm not sure that any of this is *better*, but it's fun.
12:49:52 <zmbmartin> dmj`: Ok so that gives me an error.
12:50:04 <dmj`> zmbmartin: can you paste the error
12:50:07 <ReinH> :t flip maybe Right . Left
12:50:08 <lambdabot> a1 -> Maybe a -> Either a1 a
12:50:24 <dmj`> ReinH: oooo :)
12:50:39 <dmj`> zmbmartin: on lpaste.net
12:51:31 <ReinH> or flip maybe id . Left since you can't adjust handleId easily
12:51:34 <piss-christ> can't cabal install show colored messages?
12:51:40 <piss-christ> it could really help in some cases
12:51:52 <zmbmartin> dmj`: http://lpaste.net/112944
12:54:08 <dmj`> the plot thickens, the thick plottens
12:55:48 <dmj`> zmbmartin: the issue that Left NotFound and runDB return different things, try removing the return before the maybe, and adding it to return $ Left NotFound. I'll need you to paste more code, like the whole file
12:55:52 <dmj`> is that*
12:57:19 <zmbmartin> dmj`: I will try that. runDB returns an IO
13:00:12 <worldsayshi> Hello. So I’ve previously installed yesod. Now I want to install the lens package. But cabal says that it will break yesod. Is there a way to find what versions of yesod and lens will work together?
13:00:41 <edwardk> worldsayshi: the easiest way to deal with stuff like this is to nuke the installed set of things and install both at the same time, with 'cabal install lens yesod'
13:01:10 <zmbmartin> dmj`: Yeah that does not work. So you just need to see the runDB function as well?
13:01:14 <edwardk> what happened is someone is tying you to an older or newer version of something than the other likes
13:01:16 <worldsayshi> edwardk: ah. Ok. Got it. Good thing I use Vagrant then ;)
13:01:20 <dmj`> zmbmartin: yea
13:01:39 <dmj`> zmbmartin: ideally all the imports too
13:02:36 <zmbmartin> dmj`: The runDB is from another file. give me a sec.
13:03:48 <worldsayshi> Is there some “safe” way to “nuke the installed set of things” (for some time when I’m not using vagrant).
13:04:29 <jb55> worldsayshi: I just use cabal sandboxes, it's the only reliable way to install things imo
13:04:40 <kadoban> worldsayshi: Personally I do everything in sandboxes, and nuking the sandboxes is easy. I think you can also just delete ~/.ghc/
13:04:41 <benmachine> worldsayshi: from orbit, it's the only way to be sure
13:04:41 <zmbmartin> dmj`: I appreciate the help. https://gist.github.com/codedmart/c554b3713fc5393cda6c#file-rethinkdb-hs-L59-L63
13:04:53 <zmbmartin> ReinH: Also thanks for your thoughts and help.
13:05:17 <worldsayshi> Heh. Yeah. Thanks for the help.
13:05:32 <dmj`> ReinH: what do you think about this function, you think its prelude worthy? http://lpaste.net/112945
13:05:50 <jfischoff> I do
13:05:52 <ReinH> zmbmartin: np :)
13:06:56 <ReinH> dmj`: sure
13:07:09 <ReinH> I saw a version that generalized to MonadError, but that seems sort of silly
13:08:55 <FireFly> How come there isn't an "uncurry" generalised to ArrowApply?
13:09:29 <FireFly> It seems like it'd be possible to define one
13:10:43 <dmj`> zmbmartin: does this give you a type error: http://lpaste.net/112946 ?
13:12:01 <ReinH> dmj`: I'm all for having more folds for data types that are already in Prelude ;)
13:12:11 <ReinH> well, in this case, more natural transformations
13:13:03 <vanila> i wish fold was automatically derived for all data types
13:13:13 <vanila> data Foo = ... --> creates 'foo' function
13:14:03 <zmbmartin> dmj`: Yup -> http://lpaste.net/112947
13:14:29 <benzrf> vanila: and it works recursively?
13:14:36 <zmbmartin> I have trouble understanding type errors still.
13:15:27 <jfischoff> zmbmartin: many are confusing. It is a known problem
13:17:01 <tekul> zmbmartin: shoudn’ t that be "i" rather than "id"
13:17:53 <worldsayshi> kadoba, jb55: FYI deleting ~/.ghc seemed to work well enough. (But yes, I would consider sandboxing to be the right way to do it.)
13:18:54 <zmbmartin> tekul: No that is something else though.
13:19:15 <tekul> Sorry, just joined… missed the previous discussion :)
13:19:29 <zmbmartin> tekul: All comments welcomed :)
13:21:28 <dmj`> zmbmartin: runDB $ t R.# R.get (R.str $ show id) returns a TnIO r
13:21:46 <dmj`> zmbmartin: but we're asking for: TnIO (Either Response (Maybe a))
13:22:26 <zmbmartin> dmj`: I need to change it to TnIO (Either Response (Maybe a))
13:22:50 <dmj`> yea
13:23:30 <dmj`> what you can do to fix it right now is eitherResponse <$> rundDb ...
13:23:43 <zmbmartin> dmj`: That is why I came up with my weird way.
13:23:43 <dmj`> except eitherResponse takes the id, which is redundant in our case
13:23:56 <dmj`> so you can remove the first parameter of eitherResponse
13:24:47 <dmj`> which will break getByIndex
13:25:14 <dmj`> actually wait
13:25:26 <dmj`> just do:  fmap Right (runDB ..)
13:25:37 <zmbmartin> dmj`: I am not worried about the other functions. I can change those.
13:26:33 <zmbmartin> dmj`: Great that compiles :)
13:26:46 <zmbmartin> And seeing it looks a lot nicer then what I had.
13:26:50 <zmbmartin> dmj`: Thanks!
13:27:05 <dmj`> zmbmartin: great, glad it works
13:27:14 <dmj`> if it compiles ship it
13:27:15 <dmj`> :)
13:27:54 <dmj`> there is one caveat though, if you do fmap Right, that assumes the value returned from the data base will be a Just, not a Nothing
13:28:14 <dmj`> There might be a better way you can collapse Either a (Maybe b), maybe just use Either a b
13:28:42 <dmj`> the either package is nice for that (EitherT)
13:28:46 <mkscrg> trying to help a friend through functor/applicative/monad
13:28:57 <mkscrg> is there a canonical example of something that's Functor but not Applicative?
13:29:47 <dmj`> zmbmartin: it won't cause a runtime error, but you'll have to watch out for the Right Nothing case
13:29:50 <merijn> mkscrg: Const
13:30:04 <merijn> mkscrg: It requires an extra Monoid constraint to be Applicative
13:30:42 <merijn> mkscrg: "newtype Const a b = Const a" this can be a Functor for all 'a', but requires "Monoid a" to be Applicative
13:31:01 <benmachine> Void is a good choice of a if you want to guarantee it is not a monoid
13:31:01 <zmbmartin> dmj`: Yeah that is another problem to solve later :)
13:31:11 <mkscrg> merijn: ah, thanks! that's helpful
13:31:26 <dmj`> zmbmartin: ain't a problem until it is a problem :P
13:31:45 <benmachine> I'd bet that any other type you can give me is a Monoid in a sufficiently perverse way
13:32:10 <merijn> benmachine: Isn't Void trivially a monoid?
13:32:18 <benmachine> merijn: no, it has no elements, and therefore no identity
13:32:37 <merijn> oh, true
13:32:43 <merijn> But still a semigroup!
13:32:46 <benmachine> heh, yes
13:33:01 <zmbmartin> dmj`: The only way that would happen is if the db is down though I think.
13:33:22 <benmachine> some have argued that Void is a monoid with mempty = undefined, but that opens a whole can of worms
13:33:36 <benmachine> and is generally considered not in the spirit of the thing
13:35:28 <dmj`> zmbmartin: yea, like that would ever happen :P
13:47:18 <zmbmartin> dmj`: Just curious how would I solve that? Is it more difficult?
13:53:39 <dmj`> zmbmartin: if the db crashed?
13:54:09 <zmbmartin> dmj`: No the Right Nothing case.
13:57:51 <NemesisD> i've got a tricky metaprogramming task and i was wondering if you guys could point me in the right direction
13:58:38 <NemesisD> i've got a sum type, each constructor takes some number of Int arguments, so data A = Foo | Bar Int Int | Baz Int
13:59:26 <NemesisD> i need to use generics or th to walk through all the constructors of this type and apply 0 as many times as necessary to get a fully constructed value, and to get a list of those
13:59:36 <NemesisD> is this possible to do?
14:00:05 <NemesisD> so basically i need to ask a Proxy A or something for its constructors and their arities
14:06:02 <NemesisD> i'd be writing something like zeroVals :: Proxy a -> [a], and i don't care if its partial, if i lie and i add a constructor that takes something other than an int, i'm fine with that blowing up at TH time
14:06:21 <dmj`> zmbmartin: return $ do { result <- runDb { .. }; case result of Nothing -> Left NotFound; Just x -> Right x }
14:12:41 <barx>  /query terrycojones
14:12:44 <barx> oops
14:17:24 <zmbmartin> Is it possible to do this on one line http://lpaste.net/112951?
14:17:27 <zmbmartin> Just curious
14:17:32 <zmbmartin> dmj`: Thanks again
14:18:10 <Tix_> hi would anyone be able to help me understand one step in converting an expression into pointwise form?
14:18:24 <geekosaur> I would expect, readResponse <*> runDB $ t R.# R.getAll i [R.str s]
14:18:30 * hackagebot slave-thread 0.1.2 - A solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.2 (NikitaVolkov)
14:18:54 <monochrom> readResponse <$> runDB $ t R.# R.getAll i [R.str s]
14:19:08 <geekosaur> <*> being infix fmap, and the { foo <- whatever; return (something foo) } pattern is replaceable by fmap-ing something over whatever
14:19:10 <monochrom> <$> is in Data.Functor and Control.Applicative. it simply means fmap
14:19:18 <geekosaur> wait
14:19:21 <monochrom> hehe
14:19:22 <geekosaur> that $ in the middle
14:19:29 <geekosaur> should be replaced by parens
14:19:36 <monochrom> ok, I agree.
14:19:40 <geekosaur> I would expect, readResponse <*> runDB (t R.# R.getAll i [R.str s])
14:19:44 <monochrom> readResponse <$> runDB (t R.# R.getAll i [R.str s])
14:20:02 <monochrom> but geekosaur, it's <$> not <*>
14:20:48 <monochrom> unless you say, "return (readResponse q)" is wrong to begin with
14:21:30 <geekosaur> mrf, probably, applicatives <*> vs <$> I still confuse regularly :(
14:21:59 <lifter> What would be the easiest way to tell how long my program has been running (from within the program itself)?
14:22:49 <monochrom> when the program begins, getCurrentTime and store the answer. later, getCurrentTIme again and subtract
14:22:55 <zmbmartin> monochrom: geekosaur thanks guys <$> works. The parens were what were getting me.
14:23:01 <zmbmartin> In the second $
14:23:12 <zmbmartin> I was getting an error still until I changed that.
14:23:23 <monochrom> yeah, operator precedence of <$> and $ may have tripped me
14:23:29 <geekosaur> yes, $ extends as far as it can because it's lowest precedence
14:23:32 <monochrom> always use parentheses
14:23:38 <lifter> monochrom: thanks
14:23:40 <geekosaur> so it goes too far in this case and eats the <$>
14:26:19 <illkufe> Hello everyone, newbie question, which framework do you recommend for web development
14:27:42 <simpson> illkufe: Pretty much all of the established Haskell stuff is good to work with.
14:30:31 <illkufe> thanks simpson, you recommend some to start
14:31:36 <phaazon> illkufe: I use happstack
14:31:41 <phaazon> http://phaazon.net/
14:31:45 <phaazon> it’s pretty amazing
14:33:45 <illkufe> <phaazon>:thanks
14:33:55 <stepcut> I recommend Happstack. Great documentation and it doesn't rely on a bunch of template haskell magic. It's what is used to host hackage.haskell.org
14:33:56 <illkufe> phaazon: thanks
14:34:01 <CodeWeaver> Greetings.
14:34:02 <dmj`> zmbmartin: yes that would work, np
14:34:32 <NemesisD> any ghc generics experts around?
14:34:48 <CodeWeaver> I've been experimenting with getting haskell to do some simple but high performance stuff, to see how it benchmarks against C.  Anyone here have some experience with that, who might be able to provide advice on a code snippet?
14:35:11 <phaazon> yeah, happstack is really great, I love how it uses Monoid :)
14:35:25 <dmj`> CodeWeaver: https://gist.github.com/dmjio/6166076
14:35:36 <illkufe> stepcut: ok, thank
14:38:56 <CodeWeaver> dmj:  That's great, but somewhat not helpful -- I have my own code to test out, and I"m not sure how to make it faster, or comparable to an idiomatic C program of the same solution.
14:39:43 <bmcorser> @pl \f g x y -> f (x ++ g x) (g y)
14:39:43 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
14:39:46 <dmj`> CodeWeaver: ok, you should paste it for others to help you then
14:39:54 <bmcorser> u crazy lambdabot
14:40:25 <CodeWeaver> dmj: Yes, okay, I just wanted to first know if people here had some experience.  Will paste forthwith!
14:41:52 <lpaste> CodeWeaver pasted “High performance 'decryption'” at http://lpaste.net/1726243348781465600
14:42:51 <lpaste> CodeWeaver pasted “Playing with 'decryption' C style” at http://lpaste.net/5492590730029301760
14:43:02 <sinelaw> is HM the same as System F omega?
14:43:16 <sinelaw> actually not. forget it.
14:43:40 <CodeWeaver> dmj:  Both pasted, in somewhat idiomatic style.  The Haskell version has quite a few variations, and provided one is using Data.Stream or Data.Vector.Unboxed, most of them have nearly identical performance characteristics.
14:43:59 <CodeWeaver> dmj:  But even the best, even with zero garbage collection, are about 30% slower than the C version.
14:44:37 <dmj`> CodeWeaver: did you try compiling with -fllvm
14:45:22 <sinelaw> type inference in  System F_omega is undecidable, right?
14:45:41 <sinelaw> (since it's already undecidable in System F)
14:45:46 <CodeWeaver> Oops, the haskell one fails to build because of a last minute change.  Will fix.  Won't significantly change code though.
14:48:03 <lpaste> CodeWeaver revised “High performance 'decryption'”: “No title” at http://lpaste.net/1726243348781465600
14:48:22 <CodeWeaver> Fixed.
14:49:50 <CodeWeaver> dmj:  Yes, my build options are:  ghc -O2 happymessage5.hs -o hm5 -threaded -rtsopts  -fllvm
14:50:45 <CodeWeaver> It arguably *could* be the compiler.  Using XCode's clang in both cases.
14:51:14 <CodeWeaver> No, that doesn't make sense, as such.  ghc produces its own code.
14:53:25 <NemesisD> is it possible to use GHC generics to enumerate all the constructors of a type and fully apply them, given possibly a constraint on their arguments, say Monoid or Default
14:53:33 * hackagebot colchis 0.2.0.0 - Rudimentary JSON-RPC 2.0 client over raw TCP.  http://hackage.haskell.org/package/colchis-0.2.0.0 (DanielDiazCarrete)
14:56:25 <CodeWeaver> No ideas, hm?  I'll ask again in a bit. :D
14:58:25 <merijn> CodeWeaver: Have you considered using one of haskell's vector libraries?
14:58:32 <merijn> CodeWeaver: i.e. vector/repa ?
14:59:42 <CodeWeaver> merijn:  I do.  I'm using Data.Vector.Unboxed for some of those teses.... but they are only being used to drive a simulated for loop anyway, in that high performance bit of code, so whether or not I use vectors is sort of immaterial.  The fastest version I could come up with was using PrimOps.  And the others more or less boiled down to the same thing.
14:59:42 <merijn> CodeWeaver: Also, perhaps you can use unboxed Int to speed things up? (I'm assuming the goal here is "speed at any cost" as opposed to "reasonable speed that is well maintainable"?)
15:00:24 <CodeWeaver> merijn:  See the example that involves unboxed ints?  I did a version involving PrimOps.  Didn't improve things over the strict variation I also provided, because the compiler's bloody clever.
15:00:54 <merijn> CodeWeaver: try repa instead of vector? I head it has better fusion rules? Although, tbh I haven't used it
15:01:18 <merijn> CodeWeaver: Also, you sound like a candidate for #numerical-haskell :)
15:01:23 <CodeWeaver> merijn: You're missing the point.  There's nothing about this high performance bit of code that requires the use of any kind of containers at all, in the parts that actually do the heavy work.
15:01:42 <CodeWeaver> I didn't know there was a #numerical-haskell.. :D
15:02:25 <CodeWeaver> But in any event, this is not about the math as such... its more about the loops, and some very basic math operations, and why it doesn't get boiled down more tightly, I guess.... or maybe I might be missing something about optimizations on this code.
15:03:17 <CodeWeaver> Seems gcc/clang is able to more tightly compactify this loop somehow.
15:03:23 <CodeWeaver> (In C)
15:03:45 <ReinH> CodeWeaver: #numerical-haskell is a good place to talk about performance issues like that as well :)
15:03:52 <ReinH> carter: ^
15:04:04 <CodeWeaver> ReinH I will take that under advisement and try to ask this there too.
15:04:18 <CodeWeaver> Good idea.
15:04:21 <ReinH> CodeWeaver: ofc you can ask here as well and perhaps someone can help :)
15:04:46 <L8D> how am I supposed to get the current date?
15:04:52 <L8D> like what library am I supposed to use?
15:04:54 <CodeWeaver> Sure.  This isn't a crisis of course.  Just curious as to why it doesn't compile down tighter. :)
15:05:01 <ReinH> @hackage time -- L8D
15:05:01 <lambdabot> http://hackage.haskell.org/package/time -- L8D
15:05:09 <ReinH> CodeWeaver: have you looked at the core?
15:05:37 <ReinH> That's the ultimate source for "what is GHC doing with my code*?
15:05:56 <ReinH> L8D: it's called time, but it does dates as well ;)
15:06:04 <L8D> ReinH: I have a problem with that module though
15:06:11 <ReinH> L8D: You didn't mention that :)
15:06:13 <L8D> ReinH: there's no single representation of a date
15:06:24 <L8D> there's a "day" and a "timeOfDay"
15:06:28 <CodeWeaver> I have, ReinH.  I'm not good at reading it, but its pretty tiny, and is nearly identical, provided stream fusion is being used (in the versions where i use streams instead of explicit recursion).
15:06:30 <L8D> but there's no single "date"
15:06:46 <L8D> or any way to get the current unix time
15:06:46 <benmachine> L8D: what's wrong with day?
15:06:48 <ReinH> CodeWeaver: ok :) Just throwing out some obvious suggestions in case they help
15:07:09 <L8D> I want a data type that represents both the day and time
15:07:29 <ReinH> L8D: getPosixTime is in http://hackage.haskell.org/package/time-1.5/docs/Data-Time-Clock-POSIX.html
15:07:34 <L8D> where I can freely convert between it and unix-time
15:07:41 <ReinH> time has that
15:07:47 <ReinH> Perhaps you should read the documentation a bit more thoroughly
15:07:49 <benmachine> you want UTCTime, then, don't you?
15:07:58 <benmachine> or LocalTime, I forget how it works
15:08:17 <ReinH> There are different time representations because, well, humans haven't picked a single canonical representation yet
15:08:46 <L8D> well most programming language designers have
15:08:46 <benmachine> timekeeping is a hilarious disaster
15:08:56 <benmachine> most programming languages get it wrong
15:09:09 <L8D> but they all agree on the same stuff
15:09:10 <benmachine> not sure if Haskell is one of them
15:09:18 <josephle> timezones are a matter of geopolitics...of course programmers are going to get them wrong
15:09:37 <L8D> most modern languages provide a single uniform data type for representing a specific date+time
15:09:47 <benmachine> https://www.youtube.com/watch?v=-5wpm-gesOY recommended
15:09:52 <L8D> :s/data type/representation
15:10:28 <L8D> and those representations provide: an interface for converting to/from unix time, an interface for converting to/from ISO formats, an interface for converting to/from different time zones
15:11:18 <benmachine> I believe the standard C API for dealing with timezones is basically useless for converting to/from anything other than your current timezone and UTC
15:11:27 <L8D> as with several other Haskell core libraries, this just seems needlessly complex
15:11:47 <mkscrg> what are folks doing these days for orm-like access to sql DBs?
15:12:01 <ReinH> mkscrg: Persistent, perhaps?
15:12:08 <joelteon> L8D: Data.Time?
15:12:24 <ReinH> L8D: it is complex, but handling dates and times has some amount of irreducible complexity. Many other languages gloss over this, and this is often the source of bugs.
15:12:26 <L8D> joelteon: ues
15:12:36 <mkscrg> ReinH: i've used persistent in the past, but it's scary complex for simple use cases, and badly documented
15:12:37 <L8D> yes*
15:12:40 <monochrom> IMO the requirement "but I have to convert to/from what most C programs use" is the needlessly complex one.
15:12:43 <ReinH> Having more types to represent this complexity leads to fewer type errors
15:12:54 <joelteon> L8D: definitely agree about the weird Calendar stuff
15:12:56 <ReinH> Which is, generally speaking, something Haskell libraries should be designed towards
15:13:01 <benmachine> L8D: http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Clock-POSIX.html here is your unix time <-> normal time conversion
15:13:01 <L8D> ReinH: I think that the core library shouldn't be responsible for providing that though
15:13:04 <joelteon> BUT I like the design of Time in general
15:13:23 <monochrom> because as far as date+time_of_day is concerned Data.Time already does it plainly. the type has two fields: date, time_of_day.
15:13:33 <CodeWeaver> Alright, I asked my question over at #numerical-haskell as well, but its quiet there.  Probably won't get a response for a while...
15:13:37 <joelteon> I found it a lot easier to figure out how to deal with time once I switched to thyme and made a diagram of how the datatypes interrelate.
15:13:45 <ReinH> L8D: perhaps better documentation could point users towards the most useful types and functions in the library, the "happy path" as it were
15:13:58 <L8D> ReinH: perhaps :/
15:14:02 <ReinH> CodeWeaver: if carter is around he might be able to help
15:14:14 <ReinH> L8D: I think this is a documentation problem rather than a design problem
15:14:21 <joelteon> Yeah, the time documentation is lousy
15:14:21 <L8D> ReinH: but I have the same problem with System.Exit and Network.HTTP
15:14:26 <CodeWeaver> ReinH:  Here's hoping. The curiousity is killing me.
15:14:28 <joelteon> Mostly because every module is presented as its own entity
15:14:34 <mkscrg> ReinH: e.g. "use a custom type as a primary key", there goes an afternoon
15:14:34 <L8D> ReinH: which constantly push me away from using Haskell
15:14:34 <benmachine> L8D: what exactly do you mean by ISO formats?
15:14:44 <joelteon> see: https://camo.githubusercontent.com/93262f43817867f7c118c8cf90093aec5aa2137b/687474703a2f2f692e696d6775722e636f6d2f366b33664b30502e6a7067
15:14:51 <benmachine> L8D: and what do you require wrt timezones?
15:14:59 <L8D> benmachine: ISO format as in: 2014-10-20T22:21:34.548Z
15:15:04 <benmachine> oh right
15:15:17 <benmachine> http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html doesn't this do that?
15:15:42 <ReinH> L8D: As an example of my recent frustration with inconsistent handling of dates/times on *nix-like systems, GNU date has a -R option for rfc 2822 output. BSD date does not.
15:16:01 <joelteon> I don't think that module does ISO format though.
15:16:02 <benmachine> L8D: http://hackage.haskell.org/package/time-1.5/docs/Data-Time-Format.html this is a newer version, slightly better
15:16:11 <ReinH> There's also...
15:16:12 <benmachine> even has helpers for building you ISO formats
15:16:13 <ReinH> @hackage thyme
15:16:13 <lambdabot> http://hackage.haskell.org/package/thyme
15:16:29 <joelteon> yeah, I really recommend using thyme over time
15:16:34 <ReinH> With perhaps a slightly better interface and documentation, although the main focus is on performance
15:16:39 * joelteon has contributed to thyme so is biased
15:16:43 <ReinH> joelteon: :)
15:17:18 <benmachine> L8D: so is there anything left you want that you don't have?
15:17:39 <L8D> benmachine: I think I got it after you guys pointed out Time.Clock.POSIX
15:18:27 <L8D> I just felt that these were needlessly complex, but not that I'll refuse to use them.
15:18:46 <L8D> Just like with System.Exit, Network.HTTP.Types, etc.
15:19:00 <joelteon> System.Exit???
15:19:18 <joelteon> It's three functions and a datatype
15:19:22 <geekosaur> I suspect they prefer just-like-untyped-unix to proper types
15:19:22 <L8D> joelteon: yep
15:19:34 <L8D> WAY too copmlicated for exiting with a status code
15:19:42 <joelteon> it's exit 0, exit 1, and exit with custom status
15:19:48 <geekosaur> I question why anyone with that attitude wastes their time on pointless strict typijng
15:19:58 <joelteon> although I do think it's weird that ExitFailure contains an Int instead of a Word.
15:20:06 <monochrom> well just a while ago I was pointing out that the whole idea of exit code being merely a bounded integers is needlessly naive.
15:20:21 <joelteon> well but that's constrained by the limitations of operating systems
15:20:26 <benmachine> obviously ExitCode should be a brief summary of your life up to this point
15:20:30 <L8D> joelteon: but why not just have ExitCode be a word/int ?
15:20:43 <benmachine> L8D: but why?
15:20:50 <ReinH> monochrom: Agree. Please submit your patches to the kernel.
15:20:50 <joelteon> L8D: because ExitCode can be an Exception instance?
15:20:53 <joelteon> and Int probably shouldn't?
15:20:53 <monochrom> suppose you run "sudo xxx" and the exit code is 1. is it because sudo itself can't proceed and tell you 1, or because sudo can proceed to xxx but xxx tell you 1?
15:20:55 <L8D> you don't need to create your own data type to represent it
15:21:07 <joelteon> okay, but if you want to catch an exit...
15:21:13 <monochrom> you just never know. a recursive data type is required for this.
15:21:17 <benmachine> L8D: one advantage to this approach is that it codifies the convention that 0 is success and other codes are failure
15:21:36 <ReinH> monochrom: you don't have enough information to construct this in Haskell
15:21:37 <joelteon> exitSuccess is philosophically different from exit (anything else)
15:21:42 <L8D> benmachine: wait... do we still have machines/environments where 0 is not the standard?
15:22:00 <ReinH> The only contract POSIX provides is that 0 is success and anything else is... not.
15:22:37 <monochrom> ReinH, I am arguing against the whole "all your non-unix approaches are needlessly complex" mentality
15:22:43 <ReinH> And even this is only a "convention"
15:22:46 <monochrom> the unix approach is needlessly naive.
15:22:51 <ReinH> Not an actual specification
15:23:00 <ReinH> monochrom: I'm not sure anyone is disagreeing with you?
15:23:02 <benmachine> L8D: that's besides the point, the point is that exitWith ExitSuccess and exitWith (ExitFailure 3) are both explicit about that convention
15:23:05 <ReinH> I certainly agree with you.
15:23:44 <L8D> benmachine: but it makes it annoying to perform a conversion from Int to ExitCode
15:23:46 <ReinH> The EXIT_SUCCESS macro on POSIX systems uses 0, at least.
15:24:14 <benmachine> L8D: (a) it's really not that annoying, (b) where did you get the Int from? why not produce an ExitCode in the first place?
15:24:15 <ReinH> :t ExitFailure
15:24:17 <lambdabot> Not in scope: data constructor ‘ExitFailure’
15:24:59 <ReinH> ExitFailure :: Int -> ExitCode doesn't seem like an annoying conversion
15:25:14 <L8D> benmachine: when interfacing/mirroring external software or when implementing an interpreter for another programming language
15:25:35 <L8D> ReinH: see what happens when you try to do: ExitFailure 0
15:25:41 <dfeuer__> That is odd... the notion of "exit code" seems inherently system-dependent. Assuming it's an Int doesn't seem any worse than assuming it exists.
15:26:09 <egasimus> good time o' day folks
15:26:09 <benmachine> L8D: interfacing/mirroring external software -- the process API ought to give an ExitCode, not an Int
15:26:16 <benmachine> so, no problem there
15:26:34 <ReinH> L8D: you get an exit failure with code 0, which is non-conventional but not necessarily incorrect.
15:26:35 <benmachine> implementing an interpreter for another language -- that's pretty niche
15:26:58 <L8D> ReinH: did you actually open up ghci and try it?
15:27:00 <benmachine> ReinH: actually I don't think you do
15:27:06 <egasimus> i'm trying to connect to jack with this here library: https://hackage.haskell.org/package/jack-0.7.0.3/
15:27:12 <benmachine> I think ExitFailure 0 is prohibited
15:27:17 <egasimus> but i haven't properly understood exceptions yet
15:27:28 <ReinH> > ExitFailure 0
15:27:29 <ReinH> ExitFailure 0
15:27:31 <lambdabot>  Not in scope: data constructor ‘ExitFailure’
15:27:41 <ReinH> benmachine: How could it be prohibited? It isn't a smart constructor.
15:27:52 <benmachine> ReinH: the bad way :P
15:28:00 <ReinH> benmachine: :p
15:28:04 <egasimus> so when i do, in ghci, p <- runExceptionalT $ newClientDefault "foo"
15:28:06 <ReinH> well, fortunately it doesn't do that
15:28:08 <benmachine> ReinH: exitWith will be angry with you
15:28:19 <egasimus> i get ... hmm let me paste
15:28:20 <dfeuer__> benmachine: that is disgusting.
15:28:33 <ReinH> benmachine: which is possibly incorrect
15:28:44 <L8D> ReinH: exitWith: invalid argument (ExitFailure 0)
15:29:14 <ReinH> L8D: Yes, you asked about the constructor :p
15:29:16 <ReinH> So I tried that.
15:29:25 <L8D> -.
15:29:31 <L8D> -.-
15:29:31 <ReinH> It's probably a mistake to hard code the (/= 0) check
15:29:42 <ReinH> given the POSIX standard
15:29:52 <dfeuer__> Why does that type even exist? Why not use a type synonym?
15:29:59 <L8D> ^
15:30:02 <L8D> that's my question
15:30:10 <L8D> why not just have ExitCode be an Int?
15:30:11 <ReinH> It's a fancy Maybe, and Maybe-like types are useful
15:30:15 <benmachine> dfeuer__: in order to make the distinction obvious at use site
15:30:19 <L8D> it's just needlessly complex
15:30:21 <ReinH> It is not
15:30:23 <ReinH> It's quite useful.
15:30:29 <benmachine> it is not complex, needlessly or otherwise :P
15:30:34 <benmachine> the conversion you want is half a line of code
15:30:39 <benmachine> and rarely necessary
15:30:47 <benmachine> and by rarely I really do mean almost never
15:30:54 <ReinH> We can eliminate even more complexity by just using String for everything
15:30:57 <dfeuer__> benmachine: do you mean a broken Either?
15:31:21 <benmachine> dfeuer__: ...insofar as all sum types are that, yes
15:31:32 <ReinH> Although we might want to use Text for speed.
15:31:32 <geekosaur> L8D continues to want an untyped language.
15:31:43 <monochrom> I think Integer is the fastest
15:31:58 <dfeuer__> ReinH: if there is an OS that uses strings for exit codes, then the type is broken anyway.
15:32:04 <benmachine> geekosaur: don't speak for other people, please
15:32:05 <ReinH> monochrom: True, strings are an unnecessary abstraction.
15:32:19 <benmachine> everyone else stop being so snarky
15:33:13 <dfeuer__> monochrom: Integer stops working after a few hundred megabytes.
15:33:21 <egasimus> ...so, uh, yeah: http://lpaste.net/112952
15:33:51 <monochrom> well, perhaps it's gmp who stops working at that point
15:34:34 <monochrom> unfortunately, I don't know jack. (pun! :) )
15:34:51 <benmachine> egasimus: interesting. it would be fixed if you gave an explicit type signature, but I'm not sure which one to give
15:34:52 <dfeuer__> monochrom: yes, probably. Is there a better way to work with Integers?
15:35:06 <monochrom> use a scheme interpreter :)
15:35:09 <benmachine> data Integer = [Int] -- yesss
15:35:13 <benmachine> wait
15:35:16 <benmachine> that doesn't even
15:35:18 <dfeuer__> monochrom: which one?
15:35:19 * monochrom used to use a lisp interpreter for large integers
15:35:25 <benmachine> type Integer = [Int] -- better
15:35:34 <monochrom> any one easily available by apt-get
15:35:45 <ReinH> benmachine: hahaha
15:35:50 <NemesisD> could anybody spare a few minutes to help me walk through this? I'm trying to define something along the lines of class Defaults a where defs :: [a] using generics so long as each field of each constructor has a Default instance
15:36:06 <dfeuer__> Lisp and Scheme compilers and interpreters vary widely in their numeric support.
15:36:37 <NemesisD> is what i'm trying to do even possible
15:37:03 <monochrom> I see. I don't know which one is best, but the best one ought to exist. (classical non-intuitionistic proof :) )
15:37:20 <egasimus> benmachine: what would be the syntax for passing a type signature to that?
15:37:38 <dfeuer__> Hah
15:38:43 <benmachine> egasimus: you want something like (newClientDefault "foo" :: ExceptionalT (Status ()) IO Client)
15:38:59 <benmachine> egasimus: that's a rough guess at what might be appropriate, but I might be off here, nto sure
15:39:28 <benmachine> or hm
15:39:37 <benmachine> maybe ExceptionalT All IO Client would do
15:39:55 <Cale> NemesisD: You could provide a default implementation of defs in the class declaration which uses generics, if you turn on DefaultSignatures and give it a more constrained type than that.
15:39:57 <benmachine> egasimus: anyway, if you handled the error later in the code, the annotation probably wouldn't be necessary
15:40:35 <benmachine> Cale: I think the hard part would be defining the constraint
15:40:51 <benmachine> "so long as each field of each constructor has a Default instance" -- sounds possibly not doable to me
15:41:07 <lpaste> NemesisD pasted “defaults generics” at http://lpaste.net/112953
15:41:09 <Cale> Oh, yes, that's true
15:41:25 <NemesisD> Cale: that's where i'm at so far (i.e. nowhere)
15:42:47 <egasimus> benmachine: hey, it worked with (Status ()) in there :-)
15:43:06 <benmachine> egasimus: I have a suspicion that () is not quite right there, but I don't know what's better
15:43:21 <benmachine> that's just what I came up with while eyeballing the docs and thinking "hmm maybe I wonder"
15:44:46 <dfeuer__> benmachine: is the partial type signatures thing available yet?
15:45:41 <benmachine> dfeuer__: I don't know
15:47:03 <egasimus> benmachine: did you come across any better docs perchance? because all i have is the source and i think i still have a problem with haskell comprehension :D
15:47:29 <benmachine> egasimus: it's sad that the latest version on hackage doesn't seem to have docs built, but if you go a few versions back it does
15:47:44 <egasimus> benmachine: ah, great
15:48:12 <benmachine> although that contains such gems as "The Jack module defines types and functions that allows you to use the JACK Audio Connection Kit."
15:48:19 <benmachine> wow, types and functions! who would have guessed.
15:48:44 <egasimus> "closes the given Jack client without causing any trouble (hopefully)"
15:48:49 <benmachine> amazing :D
15:49:08 <benmachine> good luck, you're on your own
15:49:09 * benmachine bed
15:49:22 <egasimus> :-) thanks for your help
15:54:57 <L8D> how can I format for the number of miliseconds of the second in Data.Time.Format ?
15:55:23 <L8D> preferably 0-padded
15:55:45 <L8D> the documentation only has %q for anything smaller than a second
15:55:52 <L8D> which is for picoseconds
15:57:02 <dfeuer__> L8D: dunno, but there might be stuff to help with the padding in Numeric—if not, it's not hard to roll your own.
15:57:30 <L8D> :/ ok.
15:57:38 <dfeuer__> Just don't do the sort of stupid shit I saw in one package that did it wrong.
15:57:52 <L8D> and what would that be?
15:58:16 <L8D> I mean... what was the "sort of stupid shit" ?
15:58:31 <dfeuer__> Oh, they were doing all sorts of crazy stuff with reverse and take, and got things out of order.
15:58:40 <dfeuer__> Padded on the wrong end.
15:58:47 <L8D> ahahahahaa
15:58:59 <dfeuer__> And with a number, that's not so good.
16:00:39 <dfeuer__> L8D: I've found that seeing "reverse" more than once in one line is a very good sign of sloppy thinking.
16:01:26 <dfeuer__> The "after the pub" coding.
16:03:40 * hackagebot binary-conduit 1.2.3 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.2.3 (AlexanderVershilov)
16:07:36 <lpaste> NemesisD annotated “defaults generics” with “defaults generics (almost)” at http://lpaste.net/112953#a112955
16:17:49 <LordBrain> Could not find module Control.Concurrent.SampleVar ... I am trying to compile reactive, and strangely cabal is complaining about not finding a base modules
16:17:52 <NemesisD> Cale: i managed to somehow get it a bit further. it works well for nullary and unary constructors, just not anything beyond that because i'm missing the product type instance
16:18:34 <LordBrain> i have base 4.7 and ghc 7.8.3
16:27:45 <monorail0> Hey guys, when I declare a data type like "data Human = Male {name :: String}", what do guards underneath that line denote?
16:27:56 <yukko> if I'm in the MaybeT monad, how do I do a map such that my result is the list of successful computations? ie a <- mapMaybeT (<some comptutation that might fail>) list, and I just get the results that didn't fail
16:28:24 <joelteon> monorail0: in data type definitions, | are placed between members of the data type
16:28:27 <joelteon> data Bool = True | False
16:28:39 <joelteon> s/are/is/
16:28:51 <merijn> monorail0: There is no requirement for multiple constructors of a datatype to be on the same line
16:28:57 <monorail0> so they're the same regardless of whitespace?
16:29:03 <monorail0> ok
16:29:53 <benmachine> yukko: I think you want to exit the MaybeT monad with runMaybeT
16:30:20 <benmachine> yukko: MaybeT tends to have a philosophy that failure is infectious, this follows naturally from the monad structure
16:30:33 <benmachine> but you can just use Maybe as an ordinary datatype, that will give you more flexibility
16:30:43 <yukko> ohh I see!
16:30:48 <yukko> runMaybeT exits MaybeT?
16:30:58 <yukko> I thought it ran things inside of MaybeT
16:31:04 <merijn> monorail0: Yeah, so in many case people like putting one constructor per line and line up the | with = for example
16:31:47 <yukko> but yeah mapMaybe does exactly what I want
16:32:56 <monorail0> so if I have a datatype "data Person = Male {name :: String} | Female {name :: String} | People [Human]", how do I go about pulling a Person out of a People?
16:33:06 <cody__> :t mapMaybe
16:33:08 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:33:21 <L8D> :t mapM
16:33:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:35:31 <cody__> > mapM [Just 2, Nothing]
16:35:33 <lambdabot>  Couldn't match expected type ‘a -> m b’
16:35:34 <lambdabot>              with actual type ‘[Data.Maybe.Maybe a0]’
16:35:43 <cody__> oops
16:37:08 <cody__> > mapM (
16:37:10 <lambdabot>  <hint>:1:7:
16:37:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:37:15 <cody__> crud again
16:37:29 <L8D> > mapM Just [1, 2, 3]
16:37:32 <lambdabot>  Just [1,2,3]
16:38:10 <cody__> > mapM (\i -> if i == 42 then Just 42 else Nothing) [42, 24]
16:38:13 <lambdabot>  Nothing
16:38:27 <cody__> there we go
16:38:35 <L8D> > mapMaybe (\i -> if i == 42 then Just 42 else Nothing) [42, 24]
16:38:37 <lambdabot>  [42]
16:39:02 <cody__> oh hi favonia!
16:39:07 <cody__> how are things?
16:39:27 <L8D> @src mapM
16:39:27 <lambdabot> mapM f as = sequence (map f as)
16:39:46 <L8D> @sequence
16:39:46 <lambdabot>  Sequence not found.
16:40:08 <merijn> monorail0: Pattern match on People, then pattern match on list?
16:40:59 <favonia> cody__: hi. they're great.
16:41:20 <cody__> cool cool
16:41:36 <cody__> when are you defending?
16:45:48 <rcharles> @src sequence
16:45:48 <lambdabot> sequence []     = return []
16:45:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:45:48 <lambdabot> --OR
16:45:48 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:01:08 <monorail0> So I don't understand how to extract the list inside this 'People': People [Male {name = "bill"}]. I try to pattern match for something like (People [list]) but Haskell comes back and says it's a human?
17:02:25 <Axman6> ou probably want (People list)
17:02:26 <Axman6> you*
17:03:02 <Axman6> (People [list]) matches a People with a list with exactly one element, which you have (confusingly) named list.
17:03:30 <monorail0> Got it, that was it :) That was a simplified example that I may have mangled.
17:20:29 <davidthomas> Is there a way, in esqueleto, to restrict a table before a join?
17:30:22 <lpaste> ryan2049 pasted “WindowLayout” at http://lpaste.net/112956
17:30:43 <benzrf> :t foldr
17:30:45 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:33:09 <benzrf> @hoogle Ord k => (Maybe a -> a) -> k -> Map k a -> Map k a
17:33:14 <lambdabot> No results found
17:33:15 <benzrf> how do i upsert a map :|
17:33:17 <mathu> i'm giving a brief 10-20 minute overview of haskell in a talk later this week. what topics do you all think i should be sure to hit?
17:34:39 <benzrf> > foldr (alter (Just . maybe 1 (+1))) Map.empty ["test", "ok", "test", "foo", "foo"]
17:34:42 <lambdabot>  Not in scope: ‘alter’
17:34:42 <lambdabot>  Perhaps you meant one of these:
17:34:42 <lambdabot>    ‘IM.alter’ (imported from Data.IntMap),
17:34:42 <lambdabot>    ‘M.alter’ (imported from Data.Map)Not in scope: ‘Map.empty’
17:34:42 <lambdabot>  Perhaps you meant ‘M.empty’ (imported from Data.Map)
17:34:49 <benzrf> > foldr (M.alter (Just . maybe 1 (+1))) M.empty ["test", "ok", "test", "foo", "foo"]
17:34:51 <lambdabot>  fromList [("foo",2),("ok",1),("test",2)]
17:36:06 <vanila> mathu, the type system!
17:36:13 <vanila> mathu, and lazyness is very interesting too
17:36:24 <mathu> the type system would require a talk of it's own haha
17:36:47 <mathu> i definitely plan to hit laziness. probably going to demonstrate the canonical fibonacci generator
17:37:12 <mathu> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 40 fibs
17:37:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:37:41 <Axman6> quick golf competition! Turning [(String, Either a b)] into ([(String,a)], [(String,b)]). Go!
17:38:01 <benzrf> shit
17:38:07 <mathu> that alone has recursion, currying, laziness, and let/in
17:38:13 <benzrf> is there unzipWith
17:38:40 <josephle> benzrf: no TT_TT
17:38:40 <mathu> hm, idk but i don't think it would be too difficult to write
17:39:06 <mathu> i've /very/ rusty though
17:39:12 <Axman6> mathu: parallelism and concurrency are aspects of Haskell that are often overlooked. The language lends itself very well to paralleism, and has beautiful concurrency primitives (forkIO is very cheap, STM is amazing, even things as simeple as MVars take a huge burdon off the developer)
17:39:38 <mathu> Axman6: those are beyond me :P
17:39:52 <Axman6> they don't have to be, they're very simple
17:40:15 <benzrf> @let divide [] = []; divide (x:xs) = case x of {Left l -> (l:ls, rs); Right r -> (ls, r:rs)} where (ls, rs) = divide xs
17:40:16 <lambdabot>  .L.hs:160:19:
17:40:17 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘([a], [a1])’
17:40:17 <lambdabot>      Relevant bindings include
17:40:17 <lambdabot>        l :: a (bound at .L.hs:160:14)
17:40:17 <lambdabot>        ls :: [a] (bound at .L.hs:162:10)
17:40:18 <mathu> honestly i have trouble with proper functional programming
17:40:27 <benzrf> @let divide [] = ([], []); divide (x:xs) = case x of {Left l -> (l:ls, rs); Right r -> (ls, r:rs)} where (ls, rs) = divide xs
17:40:30 <lambdabot>  Defined.
17:40:34 <Axman6> mathu: http://chimera.labs.oreilly.com/books/1230000000929/index.html you'll learn a lot; it's very clear (you can skip the implementation detaiuls if you want)
17:40:51 <benzrf> @let ax = divide . map T.sequenceA
17:40:53 <mathu> i just have enough of a grasp of some of haskell's commonly-sold features to fill a spot they had open in the lineup
17:40:55 <lambdabot>  Defined.
17:40:57 <Axman6> benzrf: that's partitionEithers
17:40:57 <benzrf> :t ax
17:40:59 <lambdabot> Traversable t1 => [t1 (Either t a)] -> ([t], [t1 a])
17:41:01 <benzrf> Axman6: oh
17:41:09 <benzrf> also i bungled that one up ;-;
17:41:20 <Axman6> yeah, nice work though, that's a cool way to do it
17:41:29 <mathu> the audience is uni undergrads, so i have to go easy on them too haha
17:41:31 <zwer> mathu perhaps mention Maybe and how it solves accidental null reference exceptions at compile time
17:42:05 <mathu> i was thinking about using Maybe for that, and as an intro to functors
17:42:08 <benzrf> :t T.sequenceA
17:42:09 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
17:42:10 <mathu> but idk if i wanna get into The Lingo
17:42:14 <benzrf> hm
17:42:30 <benzrf> ((,) String) ((Either a) b)
17:42:34 <benzrf> ->
17:42:41 <benzrf> (Either a) ((,) String) b)
17:42:44 <benzrf> wrong :{
17:43:22 <benzrf> hmmm...
17:43:27 <EvanR_> mathu: ive been so far unable to understand the more far out ghc extensions, but theres many basic principles that work even back in the real world
17:43:42 <EvanR_> that dont require "lingo"
17:44:08 <EvanR_> but also many things you cant have in the real world which sucks
17:44:11 <benzrf> sequenceBi :: BiApplicative f => t (f a b) -> f (t a) (t b)
17:44:24 <benzrf> what would biapplicative look like tho
17:44:44 <benzrf> @hoogle (t, Either a b) -> Either (t, a) (t, b)
17:44:46 <mathu> EvanR_: yeah, i'm hoping to cover what doesn't require the lingo. i feel people will turn off when they hear functor, monoid, etc
17:44:47 <lambdabot> No results found
17:44:49 <benzrf> huh.
17:45:44 <EvanR_> mathu: heh, those are awesome but probably wont be of much use in the industrial systems
17:46:10 <EvanR_> i find myself rewriting functor and monoid behavior in other languages, boilerplate, design patterns
17:47:39 <mathu> if it were a longer talk, i would love to explain monoids, functors, as "those things you probably use all the time without realizing it" haha
17:47:52 <EvanR_> or you should be using
17:47:56 <EvanR_> like applicative
17:48:02 <mathu> i'm not even sure how much time i have. maybe i'll have the time to explain monoid -> functor -> applicative -> monad
17:48:14 <mathu> after all the rad sellable features of haskell
17:48:34 <mathu> it'd be nice to give a real basic intro to functional programming. but i don't want to rush
17:48:57 <EvanR_> one thing to sell is how much cruft just isnt there at all
17:49:57 <EvanR_> of the cruft that is typically pervading your web or java language
17:50:14 <cdk> mathu: one of those things in your chain of "->" doesn't quite belong
17:50:17 <ryan2049> I pasted a link about 20 minutes ago (WindowLayout).  I am having a little trouble understanding the syntax.  Are Horizontal and Vertical considered the same data type as WindowLayout or do they stand alone?
17:51:09 <mathu> cdk: yes, but that's how they're presented in LYAH :P and i'd probably just rip the intro outta that
17:51:18 <MitchellSalad> ryan2049 can you paste the link again?
17:51:38 <ryan2049> http://lpaste.net/112956
17:53:26 <MitchellSalad> so, WindowLayout is an algebraic datatype for which Horizontal and Vertical are constructors
17:54:11 <MitchellSalad> that is to say, if you construct some data with the Horizontal data constructor, it will be of type WindowLayout
17:54:37 <MitchellSalad> make sense?
17:55:09 <ryan2049> I believe so.  It's just a way to declare constructors for the algebraic datatype.  Correct?
17:55:51 <MitchellSalad> yes, algebraic datatypes are made up of (technically zero) or more data constructors, separated by a |
17:56:39 <ryan2049> zero being the original data (ie. Window{....})
17:57:12 <MitchellSalad> no, a zero-constructor type would look like "data Void"
17:57:24 <ryan2049> ah ok
17:57:40 <MitchellSalad> Window is the same as Horizontal or Vertical. they're all data constructors of the type WindowLayout
17:57:51 <MitchellSalad> there's nothing significant about the location each are in the list
17:58:02 <MitchellSalad> it could go Vertical, then Horizontal, then Window
17:59:50 <ryan2049> so Horizontal[Horizontal []] is a valid statement?
18:00:12 <MitchellSalad> what are you trying to do?
18:04:27 <ryan2049> I'm working on an assignment.  I'm writing a function: func1 :: WindowLayout -> WindowLayout which will simply go through WindowLayout or [WindowLayout] and replace the values in width and height.
18:05:00 <ryan2049>  Seems pretty simple, I wrote a case that would handle a simple Window, but it fails when the Horizontal and Vertical constructuctors are used in a nested fashion
18:05:57 <josephle> :t partitionEithers . map (\(s,e) -> bimap ((,) s) ((,) s) e)
18:05:58 <lambdabot> [(a1, Either a c)] -> ([(a1, a)], [(a1, c)])
18:06:09 <josephle> I'm not sure this code golf is worth it anymore...
18:06:35 <vanila> @pl (\(s,e) -> bimap ((,) s) ((,) s) e)
18:06:35 <lambdabot> uncurry (liftM2 bimap (,) (,))
18:08:26 <benzrf> ow!
18:08:49 <benzrf> whoooooooooooaaaaaaaaaa that is incredibly cute
18:08:52 <MitchellSalad> @ryan2049 I see, your expression is almost correct, but you need a space between "Horizontal" and "["
18:08:52 <lambdabot> Unknown command, try @list
18:08:56 <benzrf> that is so cute it is downright adorable
18:09:14 <cdk> :t bimap (,) (,)
18:09:16 <lambdabot> Bifunctor p => p a c -> p (b -> (a, b)) (b1 -> (c, b1))
18:09:18 <benzrf> holy crap
18:09:22 <benzrf> cdk: wrong
18:09:37 <benzrf> cdk: liftA2 bimap (,) (,) will apply (,) to the next arg twice
18:09:41 <benzrf> then apply bimap over those
18:09:46 <benzrf> er.
18:09:59 <benzrf> :t (liftA2 bimap (,) (,)) "fo"
18:10:00 <lambdabot> Bifunctor p => p a c -> p ([Char], a) ([Char], c)
18:10:16 <ryan2049> MitchellSalad: gotcha, that was just a hypothetical question.  doesn't really apply to the solution i was working on, heh
18:10:19 <benzrf> so that will bimap ("foo",) ("foo",)
18:10:20 <josephle> the liftA2 part is pretty cool
18:10:25 <benzrf> then if i apply that to an either
18:10:33 <cdk> ah its \s -> bimap ((,) s) ((,) s
18:10:39 <cdk> \s -> bimap ((,) s) ((,) s)
18:10:43 <benzrf> > liftA2 bimap (,) (,) "foo" (Left 3)
18:10:46 <lambdabot>  Left ("foo",3)
18:10:51 <cdk> I love the reader monad for code golf
18:10:52 <benzrf> but i already have the string and the either in a tuple
18:10:57 <benzrf> so i uncurry the whole thing:
18:11:05 <benzrf> uncurry (liftA2 bimap (,) (,))
18:11:12 <benzrf> and you have the cutest trick ever
18:11:21 <benzrf> :t partitionEithers . uncurry (liftA2 bimap (,) (,))
18:11:23 <lambdabot>     Couldn't match type ‘p (a1, a2)’ with ‘[]’
18:11:23 <lambdabot>     Expected type: a1 -> p a2 c -> [Either a b]
18:11:23 <lambdabot>       Actual type: a1 -> p a2 c -> p (a1, a2) (Either a b)
18:11:28 <benzrf> shit
18:11:35 <benzrf> :t partitionEithers . map (uncurry (liftA2 bimap (,) (,)))
18:11:36 <lambdabot> [(a, Either a1 c)] -> ([(a, a1)], [(a, c)])
18:11:39 <benzrf> \o/
18:11:58 <ryan2049> MitchellSalad: I was trying to use recursion to solve it.  func1 (Horizontal (x:xs)) = Window {...} : func1 xs
18:12:01 <cdk> if the input wasn't "zipped",
18:12:18 <cdk> :t partitionEithers . zipWith (liftA2 bimap (,) (,))
18:12:20 <lambdabot>     Couldn't match type ‘[p0 a0 c0] -> [p0 (a1, a0) (a1, c0)]’
18:12:20 <lambdabot>                   with ‘[Either a b]’
18:12:20 <lambdabot>     Expected type: [a1] -> [Either a b]
18:12:26 <MitchellSalad> ryan2049: sounds good
18:12:45 <cdk> :t \xs -> partitionEithers . zipWith (liftA2 bimap (,) (,)) xs
18:12:46 <lambdabot> [a] -> [Either a1 c] -> ([(a, a1)], [(a, c)])
18:13:05 <ryan2049> MitchellSalad: doesn't really work though...the recursion expects a [WindowLayout], but func1 declares an input of WindowLayout..I'm not sure if I'm taking the right approach
18:13:23 <MitchellSalad> ryan2049: try mapping func1 over xs
18:16:49 <ryan2049> MitchellSalad: do you mean func1 xs = .. ?
18:23:29 <codehero> hackage moved?
18:24:02 <MitchellSalad> ryan2049: I mean "map func1 xs"
18:25:29 <EvanR_> heh i just tried this pattern f s s = ... and it didnt work
18:25:59 <EvanR_> s is whatever the two arguments are if they are the same!
18:26:13 <vanila> it has to be written f s s' | s == s' =
18:26:17 <MP2E> ^
18:26:28 <vanila> i think i fwe allowed f s s, then people would want more and more complex pattern matching
18:26:49 <EvanR_> yeah and here it needs to be explicit that we are talking about ==
18:26:52 <vanila> there's basically unbounded complexity in what patterns could be
18:27:50 <ryan2049> MitchellSalad: ah ok. I'll see if I can come up with something
18:27:57 <ryan2049> MitchellSalad: Thanks for your help thus far.
18:28:57 * hackagebot haskell-neo4j-client 0.3.0.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.0 (asilvestre)
18:28:59 * hackagebot haskell-neo4j-client 0.3.0.1 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.1 (asilvestre)
18:30:11 <qrpnxz> take 5 [1..]
18:30:16 <qrpnxz> Hello.
18:32:46 <dmj`> hi
18:33:58 * hackagebot haskell-neo4j-client 0.3.0.2 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.2 (asilvestre)
18:34:20 <EvanR_> how do i do zip of two lists which is Nothing if they are different lengths
18:35:03 <EvanR_> zipWith rather
18:35:04 <vanila> EvanR_, i would write this using recursion
18:35:10 <dmj`> EvanR_: You mean return Nothing if they have different lengths?
18:35:21 <EvanR_> yeah
18:35:40 <EvanR_> alright, pulling out the recursion
18:35:57 <vanila> and the maybe monad
18:35:59 <dmj`> f = \xs ys -> if length xs /= length ys then Nothing else Just (zip xs ys)
18:36:26 <vanila> zipSame f [] [] = return [] ; zipSame f (x:xs) (y:ys) = (:) <$> f x y <*> zipSame f xs ys
18:36:38 <vanila> oh and zipSame _ _ _ = Nothing
18:37:13 <dmj`> vanila: that trims the list though
18:37:32 <dmj`> vanila: oh nvm you're correct
18:37:44 <dmj`> vanila++
18:37:51 <johnw> EvanR_: use Data.Align from http://hackage.haskell.org/package/these-0.4.2/docs/Data-Align.html
18:37:57 <johnw> it has just the zip you want
18:38:59 * hackagebot haskell-neo4j-client 0.3.0.3 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.3 (asilvestre)
18:39:28 <dmj`> vanila: why the f though?
18:40:23 <EvanR_> its a zipWithSame
18:40:30 <EvanR_> but i changed my mind
18:40:50 <EvanR_> need to fold the pairs
18:44:51 <LordBrain> cabal quit on me, complaining about not finding Control.Concurrent.SampleVar, which is in base, im perplexed... this is inside a sandbox.
18:45:21 <LordBrain> ghc 7.8.3, cabal 1.21.0.0
18:45:45 <LordBrain> anyone have any ideas?
18:45:51 <geekosaur> "Deprecated: Control.Concurrent.SampleVar will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead."
18:46:10 <LordBrain> that's fine, but its still there
18:46:18 <LordBrain> the package should compile right?
18:46:26 <LordBrain> oh
18:46:32 <LordBrain> really?
18:47:17 <LordBrain> somone should put  a #warning pragma in there
18:47:30 <geekosaur> I pulled that from haddocks for the version of the platform I have available, which is the previous one (based on 7.6.3)
18:47:41 <LordBrain> i see
18:47:50 <geekosaur> I couldn' tell you if it's still in 7.8.3 or if it's broken
18:48:53 <LordBrain> well that message said it will be removed, and i am having issues, so it probably is not there
18:49:31 <LordBrain> thanks
19:02:50 <ryan2049> MitchellSalad: it's a bit confusing, but i figured out the answer.  thanks!
19:04:11 <lpaste> ryan2049 pasted “iconify” at http://lpaste.net/112958
19:04:35 <ryan2049> MitchellSalad: ^^ in case you're interested
19:08:25 <codygman> Can I get some feedback/code review on my (impractical and for learning purposes) program to parse image sizes out of a filename? http://lpaste.net/112959
19:10:13 <jle`> codygman: why do you insist on throwing an error ;)
19:10:23 <jle`> why don't you print something different if there is no parse
19:11:11 <jle`> codygman: also, remember your fmap laws
19:11:16 <jle`> er, functor laws
19:11:48 <jle`> f <$> g <$> x = f . g <$> x
19:11:58 <jle`> in your case though it might be nicer to just use fmap
19:12:23 <jle`> also, instead of using join and fmap, your code might be simplified by using bind
19:12:37 <jle`> parseImgSizeStr :: String -> Maybe String
19:13:00 <jle`> stripExt :: String -> Maybe String     -- you could rewrite it to be this
19:13:33 <jle`> then you can just do stripExt =<< parseImgSizeStr validFileName
19:13:43 <codygman> jle`: Yeah, I'm trying to keep it readable above all.
19:13:47 <codygman> ah, cool.
19:14:13 <jle`> i noticed that you did something similar with splitXy as with stripExt
19:14:18 <jle`> you provide the functions "lifted"
19:14:32 <jle`> usually we like to provide the functions unlifted, and then lift them or chose not to lift them at our convenience
19:14:47 <jle`> if splitXY = split "x"
19:14:51 <jle`> we can do
19:15:21 <jle`> print (splitXY . stripExt =<< parseImageSizeStr validFileName)
19:16:03 <jle`> or print $ fromMaybe "Invalid!" (splitXY . stripExt =<< parseImageSizeStr validFileName)
19:16:10 <LordBrain> what is the difference between type Serial1 = forall a. IO a -> IO a  and type Serial2 = IO a -> IO a ?
19:16:24 <LordBrain> the latter missing the forall
19:16:34 <jle`> LordBrain: one is valid syntax
19:16:41 <LordBrain> i see
19:16:47 <jle`> or perhaps do you mean
19:16:51 <jle`> type Serial2 a = IO a -> IO a
19:16:53 <jle`> ?
19:16:54 <LordBrain> yeah
19:16:56 <jle`> ah.
19:16:57 <LordBrain> well
19:17:10 <johnw> one is the type of a rank-n function, depending on where you use it
19:17:12 <codygman> jle`: Awesome. What I was trying to accomplish is short circuiting. I'm going to try to implement those and then review functor/monad laws :D Thanks for the help
19:17:27 <jle`> codygman: ah.  short-circuiting is nice with Maybe because of its Monad instance
19:17:28 <LordBrain> i'm not good with the foralls in haskell. I am having an issue trying to get some code to run
19:17:39 <johnw> using forall in a type synonym is pretty rare
19:17:42 <LordBrain> er to compile actually
19:17:45 <jle`> codygman: Maybe's Monad instance makes it pretty useful
19:17:51 <johnw> what is it that you want to accomplish?
19:17:59 <jle`> because it lets you take an (a -> Maybe b) and "apply" it to a (Maybe a)
19:18:04 <LordBrain> johnw, it's conal elliots code, in his reactive package
19:18:12 <johnw> link?
19:18:24 <LordBrain> hold up
19:18:48 <jle`> codygman: your code might be made more readable with a do block if it suits your fancy
19:18:57 <jle`> print . fromMaybe "error" $ do
19:19:03 <jle`>     parsed <- parseImageSizeStr validFileName
19:19:16 <jle`>     stripped <= stripExt parsed
19:19:18 <LordBrain> johnw, https://hackage.haskell.org/package/reactive-0.11.5/docs/FRP-Reactive-Internal-Serial.html
19:19:21 <merijn> johnw: hah!
19:19:25 <jle`>     return (splitXy stripped)
19:19:25 <merijn> johnw: Speak for yourself :p
19:19:26 <johnw> merijn: hi!
19:19:31 <michaelt> codygman: you are using MissingH for just split?
19:19:49 <merijn> johnw: I'm referring to "19:24 < johnw> using forall in a type synonym is pretty rare" ;)
19:19:53 <jle`> :P
19:19:59 <jle`> yes i noticed the slightly irony in that
19:20:01 <jle`> but i let it slide ;)
19:20:10 <jle`> i'm glad someone more unforgiving is here
19:20:12 <LordBrain> it doesnt build on ghc 7.8.2, i get an error: Couldn't match type IO a0 -> IO a0 with forall a. IO a -> IO a
19:20:22 <LordBrain> er ghc 7.8.3 actually
19:20:56 <johnw> LordBrain: so, in the first case it's a rank-2 function (an IO action that yields a polymorphic function), in the second case (`locking`) it's at rank-1, just a polymorphic function
19:21:06 <johnw> merijn: ok, maybe it's common with some people then :)
19:21:29 <LordBrain> heh, personally i try to avoid the rank 2 stuff if i can
19:21:48 <LordBrain> anyway
19:21:50 <jle`> you usually only use it when you intend to have something rank 2
19:21:52 <jle`> :)
19:21:53 <johnw> if you're used to functions as values, rank 2 is just polymorphic functions as values
19:22:24 <johnw> rank-n just indicates how many times you wrap it up as an argument to another function
19:22:42 <LordBrain> yes, well, i'm sure its all simple when you already know it
19:22:49 <LordBrain> :)
19:22:59 <johnw> do you know what I mean by a polymorphic function as a first-class value?
19:23:05 <LordBrain> actually sure might be too strong a word
19:23:10 <jle`> consider something like a function that takes an [a] -> Int and a (b, c), and returns an (Int, Int)
19:23:11 <LordBrain> yes
19:23:14 <LordBrain> i know that much
19:23:17 <jle`> um
19:23:19 <jle`> a ([b], [c])
19:23:26 <johnw> that's pretty much all there is to it, actually
19:23:28 <jle`> what might you expect the type signature of that function to be?
19:23:42 <johnw> the universal quantifier becomes part of the "argument"
19:23:42 <jle`> foo :: ([a] -> Int) -> ([b], [c]) -> (Int, Int)  ...?
19:23:44 <LordBrain> the ramifications of sprinking foralls in data and type declarations are what i don't know
19:23:56 <jle`> do you see why that type signature of `foo` wouldn't work?
19:24:34 <johnw> LordBrain: that part does take some getting used to, since the exact meaning can depend on the context
19:25:07 <jle`> i could type in something like "sum" to `foo`...because `sum`  can be [Int] -> Int
19:25:16 <LordBrain> well, might we just figure out how to make this file compile
19:25:21 <jle`> but then you couldn't apply `sum` to [b] and [c]
19:25:21 <LordBrain> first
19:25:26 <jle`> foo f (x,y) = (f x, f y), btw
19:25:36 <jle`> do you see why that type signature isn't going to cut it?
19:25:47 <jle`> you want to say "i want a function that can take a list of *anything*....and give an Int from that"
19:26:06 <jle`> as the function is currently written, it's expecting a function that can take a list of one thing and give an Int from that
19:26:08 <LordBrain> my priority is really just getting this compiled at the moment
19:26:24 <LordBrain> not that i am opposed to the excursion
19:26:42 <LordBrain> in principle, just if it is possible to complete this task first..
19:27:39 <johnw> you mean, this file from the reactive package?
19:28:03 <LordBrain> johnw, would you expect that Serial.hs would compile?
19:28:09 <LordBrain> yes
19:28:44 <LordBrain> i didnt try it on the older ghc, and from other snafoos i ran into, its clear the code is just a bit rotted for my base and ghc version
19:29:05 <LordBrain> so i'd think it probably compiles fine on older ghc
19:29:27 <johnw> you can make it compile with newtypes: https://gist.github.com/52e9130b73a835e5e59b
19:30:27 <johnw> i'm not sure it's going to work with a type synonym like that, but merijn maybe knows the trick
19:31:17 <johnw> the problem is that makeSerial wants to "package up" the quantifier, but calling locking that way has already let it "escape" (i.e., makeSerial has fixed the free type variable by referencing that function)
19:31:35 <johnw> the newtype makes the packaging explicit
19:32:29 <merijn> johnw: The trick is easy
19:32:42 <johnw> hit me
19:32:42 <merijn> "forall a. Serial (IO a -> Io a)"
19:32:42 <LordBrain> show us merijn :)
19:32:54 <johnw> merijn: isn't that just a newtype also?
19:33:02 <LordBrain> so still a newtype
19:33:04 <merijn> Yes, but no ImpredicativeTypes
19:33:19 <merijn> ImpredicativeTypes is broken, avoid like the plague
19:34:23 <johnw> i don't really know what ImpredicativeTypes does
19:34:34 <johnw> i've heard the meaning of it has changed over time too
19:34:43 <merijn> johnw: Allow RankNTypes inside data
19:35:04 <johnw> ah
19:35:10 <merijn> The newtype contains a RankNType, which is why you need it
19:35:22 <merijn> Moving the forall out gets rid of that and should only need RankNTypes
19:35:30 <johnw> make sense, thanks
19:36:13 <LordBrain> so it should read: newtype Serial = forall a. Serial (IO a -> IO a) ?
19:36:46 <merijn> Yeah
19:36:48 <jle`> impredicative types
19:36:52 <LordBrain> can i do it with just Rank2Types ?
19:36:56 <jle`> something like foo :: Maybe (a -> b) -> ...
19:36:57 <jle`> er
19:37:05 <merijn> LordBrain: Rank2 and RankN are currently the same in GHC :)
19:37:07 <jle`> foo :: Maybe (forall a. a -> b)
19:37:08 <jle`> stuff like that
19:37:42 <LordBrain> A newtype constructor cannot have existential type variables Serial :: forall a. (IO a -> IO a) -> Serial
19:37:58 <merijn> Bugger
19:38:01 <LordBrain> hdevtools gave me that error, i didnt' try compiling
19:38:48 <jle`> shouldn't it be newtype Serial = Serial (forall a. IO a -> IO a) ...?
19:39:16 <LordBrain> thats what johnw had
19:39:47 <johnw> merijn's version doesn't work fro me
19:39:55 <johnw> it says "A newtype constructor cannot have existential type variables"
19:39:59 <jle`> i do'nt think newtype Serial =  forall a. Serial (IO a -> IO a) is valid syntax
19:40:07 <jle`> ...is it?
19:40:13 <johnw> not here
19:40:15 <merijn> johnw: Yeah, this might just be "tough luck"
19:40:17 <LordBrain> yeah, we're all getting that error
19:40:25 <johnw> but my version does type check
19:40:53 <merijn> You can try with "data"
19:40:53 <johnw> note: even without ImpredicativeTypes!
19:41:03 <jle`> imperdicative types is only in type signatures involving types, i think
19:41:15 <johnw> yeah, I only need RankNTypes to compile with my newtype
19:41:21 <LordBrain> the file as conal wrote it had impredicativetypes enabled
19:41:30 <jle`> boo hiss
19:42:28 <LordBrain> alright, i'll take it out
19:42:28 <jle`> perhaps he will come here after all of these pings we're giving him
19:42:28 <johnw> he's rarely here
19:43:09 <jle`> he comes here every once in a while to remind everyone that frp is actually a word with meaning
19:43:50 <solatis> FRP? isn't that the latest fad in GUI-based code to make everything event-based?
19:44:05 <solatis> and they call it functional because it sounds better?
19:44:10 <Joe_knock> what does FRP stand for?
19:44:10 * hackagebot io-streams 1.2.0.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.0.1 (GregoryCollins)
19:44:29 <solatis> functional reactive programming
19:44:51 <Joe_knock> oh.
19:44:58 <solatis> there's a new language, called Elm
19:45:12 <solatis> it's a great example how to do FRP right
19:45:19 <LordBrain> seems like conal prefers denotative and denotational now instead of functional...
19:45:41 <solatis> but basicly, instead of reacting to user input, you write your code to react on events
19:45:50 <solatis> the event stream is completely handled by the language/library
19:45:57 <solatis> so you can rewind, replay, etc all the logs
19:46:02 <solatis> works great for games & debugging, etc
19:46:10 <Joe_knock> sounds dangerous.
19:46:17 <solatis> http://elm-lang.org/learn/What-is-FRP.elm
19:46:33 <jle`> solatis: i can't tell if you are being scarcastic or not
19:46:42 <LordBrain> lol
19:46:43 <jle`> ...sarcastic
19:46:48 <solatis> i'm being slightly sarcastic
19:46:58 <solatis> because it's a fad
19:47:16 <solatis> but i do like to follow this one, sometimes something good comes out of these things
19:47:17 <jle`> hard to call it a fad if it's not too popular :P
19:47:35 <jle`> i mention it as sarcastic because you said it right after i mentioned conal coming to remind everyone what frp isn't
19:47:40 <solatis> ah yeah in my private universe quite a people are talking about it
19:47:42 <jle`> and elm is a part of that list of things that aren't frp
19:48:14 <jle`> it hits 50% of the things that frp encompasses
19:48:16 <Joe_knock> 1 too many languages in the world. Eventually all roads lead us back to assembly
19:49:16 <solatis> Joe_knock: until Godel comes along and proves assembly to be incomplete
19:49:36 <LordBrain> well, i started reading conals paper for some reason i don't recall, the whole thing is an excursion really, i know i should be doing something else
19:49:36 <jle`> elm is great, but i still feel weird calling it frp
19:49:44 <solatis> i think it's interesting to follow these things/movements, though
19:49:54 <jle`> because it more or less drops one of the most important aspects of FRP according to its original formulation
19:50:03 <solatis> more often than not they lead to great patterns being (re)discovered
19:50:05 <jle`> and an aspect that gives it its power
19:50:18 <solatis> jle`: care to elaborate on those two aspects?
19:50:45 <jle`> FRP was intended to be to normal loop/game/gui programming what vector graphics were to bitmaps
19:50:57 <jle`> a language to reason with things as continuous things
19:51:15 <jle`> it's a language unable to speak about discrete timesteps
19:51:23 <jle`> like vector graphics can't really speak about discrete pixels
19:51:29 <solatis> ah yes
19:51:31 <solatis> i understand
19:51:33 <jle`> everything eventually goes to pixels in the end, of course
19:51:42 <solatis> but that's out of the scope
19:51:44 <merijn> solatis: I'll channel Conal: 1) continuous time and 2) denotational semantics
19:51:50 <jle`> but the idea is that...if you live in the universe of teh continuous for as long as possible...you can do some pretty amazing things
19:52:01 <jle`> and some pretty awesome reasoning
19:52:05 <mthvedt> if i have a monad definition, how do i find the corresponding kan extension?
19:52:08 <solatis> jle`: similar to infinite lists being awesome ?
19:52:15 <jle`> similar to vector graphics being awesome
19:52:23 <jle`> as the most close analogy
19:52:30 <solatis> right
19:52:36 <edwardk> mthvedt: by looking at monad-ran ;)
19:52:39 <solatis> and elm lacks that?
19:52:41 <jle`> but also simular to things like...having Monads/functors have laws
19:52:44 <jle`> yes
19:52:47 <jle`> elm is only denotative
19:52:51 <edwardk> mthvedt: i figured out all the standard ones several years back
19:52:54 <solatis> that sounds weird
19:53:02 <jle`> and animations and stuff in elm all are based on the timestep
19:53:09 <jle`> in elm, it's all driven by the timestep
19:53:16 <jle`> the timestep is always a part of your application, a part of your reasoning
19:53:19 <solatis> for a language that positions itself as the posterchild of FRP
19:53:31 <mthvedt> edwardk: yeah i saw that, it was a good resource to learn about kan extensions corresponding common monads
19:53:31 <merijn> solatis: Much to Conal's chagrin :p
19:53:38 <merijn> solatis: Check his SO answer for details
19:53:39 <jle`> well, the name "functional reactive progrmaming" is...not very descriptive in and of itself
19:53:43 <solatis> i will
19:53:45 <edwardk> mthvedt: there isn't such a resource to my knowledge
19:53:48 <jle`> so it's easy to say "oh, i like denotative.  i like signals.  let's call it frp"
19:53:53 <eyebloom> jle’: I keep hearing that frp will never be efficient, but the best explanation I’ve here for why is that you can reason about things that are folds over the entire history of some behavior, I’m wondering what your take on this is?
19:54:11 <edwardk> mthvedt: there are some tricks of course.
19:54:14 <jle`> if anything i have heard it said that continuous time frp is "classical frp", and elm-like frp is "new frp"
19:54:20 <jle`> but...then that sort of makes the term lose any real meaning
19:54:22 <jle`> why not just pick a new term
19:54:29 <merijn> solatis: http://stackoverflow.com/a/1030631 and http://stackoverflow.com/a/5878525
19:54:31 <solatis> merijn: http://stackoverflow.com/a/1030631/1764661
19:54:44 <solatis> your google fu was faster :)
19:55:07 <jle`> eyebloom: i really can't understand your question, sorry :(
19:55:07 <merijn> solatis: For a good intro on the intended semantics, I recommend the "Push-Pull FRP" paper
19:55:08 <solatis> oh geez, this was already 5 years ago
19:55:16 <edwardk> you can always use Yoneda m    as m, so there is always something in the correct form, and Codensity U    is the monad UF, given F -| U, so you can use Codensity Reader as State, etc.
19:55:23 <merijn> solatis: http://conal.net/papers/push-pull-frp/
19:55:28 <mthvedt> edwardk: i have an ‘almost free’ monad i’d like to improve the performance of, and it would be satisfying to do it in a way that’s elegant in a certain mathematical sense
19:55:49 <edwardk> mthvedt: if you can church encode the monad in question you can often rebundle it up into the right pair of functions
19:56:07 <edwardk> er right pair of things of form * -> *
19:56:12 <merijn> solatis: Some of the implementation bits can be a bit tricky to follow, but the high level overview should be easy
19:56:18 <eyebloom> jle’: Why is frp, in the sense that Conal described it, inefficient.
19:56:18 <jle`> push-pull frp is a great attempt to push frp into GUI
19:56:37 <jle`> eyebloom: frp isn't an implementation...it's a "language".  a framework of reasoning
19:56:42 <edwardk> mthvedt: if you naively smack it with the Codensity hammer and just take m to Codensity m, which will almost assuredly make it "bigger", does it get faster?
19:56:52 <merijn> eyebloom: Time leaks are an issue, there's some attempts to solve it, but not completely satisfactory ones yet
19:57:13 <eyebloom> Got it.
19:57:48 <merijn> eyebloom: Also, "FRP is inefficient" is a non-statement, FRP is a specification/model. Current implementations have some problems (but they're far from universal, plenty of FRP code will never run into this)
19:57:50 <eyebloom> Time leaks would essentially mean you are accumulating overhead as your history increases?
19:58:01 <mthvedt> edwardk: yes, but my inner mathematician wants something more elegant, particularly since it knows something more elegant should exist :P
19:59:12 * hackagebot caramia 0.2.0.0 - Caramia real-time hardware-accelerated rendering library  http://hackage.haskell.org/package/caramia-0.2.0.0 (Adeon)
19:59:32 <mthvedt> though i’m not actually sure what the theory is—the step of getting monads out of kan extensions of functors is kind of handwaved in, for example, ‘free monads for less’
20:03:17 <merijn> eyebloom: A time leak would be that future behaviour can dependent on all input events, so past events can never be GCed
20:06:35 <LordBrain> that's not a fundamental aspect of frp tho is it?
20:06:45 <LordBrain> time leaking i mean
20:07:07 <LordBrain> its just a bit of an engineering snafu
20:09:13 <LordBrain> src/FRP/Reactive/Fun.hs:126:3:
20:09:13 <LordBrain>     extract is not a (visible) method of class Copointed
20:10:02 <LordBrain> name change maybe..
20:10:09 <edwardk> mthvedt: well there isn't an algorithm per se to get "the best one". i have an existence claim, in that Yoneda m ~ m always exists and is a right kan extension, but there are other ways to CPS
20:12:25 <LordBrain> was extract moved from one type class copointed to another Comonad?
20:14:31 <edwardk> LordBrain: Copointed has 'copoint' and Comonad has 'extract' -- i think i may have called it 'extract' in Copointed originally and even had Copointed in the class hierarchy, but then the semigroupoid for Cokleisli composiiton of 'Extend' (semicomonad) instances turned out to be more useful so I stopped thinking in terms of Copointed in general and removed it from the hierarchy, and then later I removed the use of Extend the class
20:14:33 <edwardk>  from the hierarchy to get better symmetry with the Monad side
20:14:45 <edwardk> LordBrain: it is 'copoint' in there now
20:15:03 <edwardk> LordBrain: are you trying to compile the old reactive code?
20:15:08 <LordBrain> yes
20:15:15 <LordBrain> i'm trying
20:15:18 <edwardk> good luck with that
20:15:24 <LordBrain> ha
20:15:33 <edwardk> i think i resurrected it once a few years ago. not sure if i still have it on github
20:15:42 <edwardk> or if i uploaded the latest resurrection attempt there
20:16:55 <LordBrain> haskell rots so much faster than other languages
20:17:01 <LordBrain> its actually a problem
20:17:11 <carter> its so easy to patch
20:18:55 <mthvedt> edwardk: yes, but a right kan extension itself is only a “real” kan extension if it’s universal, right?
20:21:43 <Axman6> anyone familliar with simpleHTTP from HTTP? I'm having issues where I'm exhausting the allowed number of open files and can't seem to fix it
20:22:08 <carter> oh
20:22:17 <carter> Axman6: too many open connections?
20:22:37 <Axman6> I thought I was having issues because I was using Async to run requests concurrently, but even just using mapM causes the same problems (just more slowly)
20:23:05 <carter> Axman6: try closing connections expicitly
20:23:08 <Axman6> yeah I'd guess so. I probably need to be forcing the ByteString result I'm getting out of it so the connection can be closed
20:23:19 <Axman6> simpleHTTP doesn't give you access to the connection
20:23:33 <carter> withSimpleHTTP
20:23:51 <Axman6> where's that?
20:23:59 <carter> sooon in your text file
20:24:13 <carter> copy the source of the other one
20:24:17 <carter> and fix up the finalization
20:24:18 <carter> idk
20:25:11 <LordBrain> edwardk, i see this on your github https://github.com/ekmett/reactive
20:25:17 <eyebloom> Why might errorWithStackTrace return very little information. Currently I get two function calls the second one being “CAF (<entire-module>)”.
20:25:25 <edwardk> LordBrain: not sure if that is the last thing I did with it or not
20:26:01 <LordBrain> Updated on May 15, 2011
20:26:16 <edwardk> mthvedt: um, there is "one right kan extension of f along g" but there is nothing saying that there aren't 'two different Kan extensions of something along something else' that both equal out.
20:26:33 <edwardk> mthvedt: if you fix f and g then its unique
20:26:52 <LordBrain> Wed Jul 28 12:48:10 EDT 2010 was Conal's last update to the darcs, so maybe yours actually is as up to date as what i am working with
20:26:59 <edwardk> mthvedt: here were' fixing only the result, leaving you a dimension of freedom
20:27:34 <LordBrain> 2010... that's like 20 years in haskell time
20:28:04 <LordBrain> sigh
20:30:23 <mthvedt> edwardk: oic
20:32:07 <edwardk> mthvedt: if you think about it that should make sense, a right kan extension along a functor is basically just 'trying to go back along its left adjoint', that is why Yoneda m ~ Ran Id m ~ m why? because we're walking back along the left adjoint to Identity which is Identity.
20:47:51 <Axman6> damnit ghc, why won't you close my connections!
20:48:24 <carter> Axman6: sooo, http-conduit had that problme too
20:48:27 <carter> but then i reported it
20:48:30 <carter> and then it got fixed
20:48:37 <carter> also GHC isn't in charge of that
20:49:38 <Axman6> bleh, I don't want to bring conduit into this project, all I'm doing is downloading a bunch of files, it shouldn't be this hard.
20:50:11 <Axman6> I just need something that I can say getBody "url" and it returns a byteString and closes the connection
20:50:37 <carter> Axman6: lemme look at the  simpleHTTP code
20:50:40 <carter> oh
20:51:25 <Axman6> the thing is I'm fetching upwards of 700 small files, so it uses a lot of connections
20:51:44 <carter> Axman6: look at http://hackage.haskell.org/package/HTTP-4000.2.18/docs/src/Network-HTTP.html#simpleHTTP
20:51:58 <carter> it'd be easy to define a version the forces the sream and closed the connection
20:52:58 <carter> http://hackage.haskell.org/package/HTTP-4000.2.18/docs/Network-Stream.html has closeOnEnd
20:54:07 <carter> Axman6: anyways i'm going to bed soon so i cant helpou
20:55:29 <Axman6> yeah having a look now
20:55:34 <mthvedt> edwardk: interesting. to be honest it’s been a while since i’ve done serious category theory
20:55:37 <Axman6> and writing a simpleHTTPSafe
20:56:01 <mthvedt> at the time a lot of us wondered if it wasn’t abstract nonsense… that was before i discovered haskell :P
21:24:18 <Yxven> I'm not having any luck with profiling my game. The -p option produces an empty file. -hc  produces a file that I can convert to PostScript with hp2ps, but then Ghostscript refuses to open it because it claims there is a syntax error
21:27:02 <Yxven> the -sstderr option also doesn't do anything
21:29:59 <Yxven> does anyone have any idea how I would go about fixing this?
21:44:26 * hackagebot json-rpc-server 0.1.3.0 - JSON RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.3.0 (grayjay)
21:50:20 <fragamus> @hoogle getStdGen
21:50:22 <lambdabot> System.Random getStdGen :: IO StdGen
21:59:07 <jle`> i can't read kan extension without thinking of star trek
21:59:56 <thrasymachus> KKKKAAAAAAAAAANNNNNNNNNNNNN
22:03:21 <jle`> maybe i wouldn't be the most welcome student in a category theory class
22:05:00 <joelteon> who would be the most welcome student in a category theory class?
22:07:13 <jle`> someone who does not yell out star trek quotes whenever professors mention certain concepts
22:08:00 <johnw> there is the right kan extension, and then definitely the wrong Khan extension
22:10:03 <wz1000> Is there any non recursive way to define fix or y in haskell?
22:10:33 <adarc> hey, i made a sort func that uses an STArray.. is there any way I could return a list of e.. everything is either ST s e .. or ST s ()
22:11:00 <adarc> what to do in this case? I wanted to do this sort using an STArray to see how fast it could be.. but now i want to return the contents of the sorted array
22:11:47 <johnw> adarc: when you runSTArray, you get an ordinary Array back
22:12:09 <johnw> you can turn *that* into a list with "Data.Array.elems"
22:13:04 <adarc> cool thanks johnw.. im looking for that now. I'm trying to use only base libraries.. i think i saw that in the array package? If that's the case I guess i could check that package out to see how they implement it
22:13:14 <adarc> im looking through GHC.ST, GHC.Arr
22:14:30 <adarc> runSTArray st = runST (st >>= unsafeFreezeSTArray)
22:14:32 <adarc> cool
22:16:23 <fg> quit
22:18:28 <dmj`> is haskell-src-exts broken?
22:18:42 <dmj`> failing on osx and a travis build
22:18:47 <dmj`> to install
22:19:30 * hackagebot pandoc 1.13.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.13.1 (JohnMacFarlane)
22:19:39 <adarc> johnw: thanks ! that worked
22:20:24 <johnw> great!
22:21:41 <benzrf> @hoogle unsafe
22:21:44 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
22:21:44 <lambdabot> Language.Haskell.TH unsafe :: Safety
22:21:44 <lambdabot> package unsafe
22:30:54 <wz1000> @let y = \f -> (\x -> f (x x)) (\x -> f (x x))
22:30:55 <lambdabot>  .L.hs:155:25:
22:30:56 <lambdabot>      Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
22:30:56 <lambdabot>      Expected type: t0 -> t
22:30:56 <lambdabot>        Actual type: (t0 -> t) -> t
22:30:56 <lambdabot>      Relevant bindings include
22:31:07 <wz1000> Why doesn't this work?
22:33:44 <Hijiri> infinite types are disallowed outside of data definitions because it makes type-checking harder
22:34:32 * hackagebot hruby 0.2.8 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.8 (SimonMarechal)
22:34:42 <wz1000> @let y = \f -> f (y f)
22:34:43 <lambdabot>  .L.hs:155:15:
22:34:43 <lambdabot>      Ambiguous occurrence ‘y’
22:34:43 <lambdabot>      It could refer to either ‘L.y’, defined at .L.hs:155:1
22:34:43 <lambdabot>                            or ‘Debug.SimpleReflect.y’,
22:34:43 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
22:35:11 <Hijiri> @undefine
22:35:12 <lambdabot> Undefined.
22:35:28 <wz1000> How are these two definitions different?
22:36:13 <wz1000> My earlier definition evaluates to this one.
22:37:19 <wz1000> let ycom = \f -> f (ycom f)
22:37:31 <wz1000> @let ycom = \f -> f (ycom f)
22:37:35 <lambdabot>  Defined.
22:38:22 <wz1000> > ycom (\f x -> if x == 0 then 1 else x*(f (x-1))) 3
22:38:24 <lambdabot>  6
22:39:51 <wz1000> I want to define y non recursively, so 'y f = f (y f)' and 'y f = let x = f x in x' wont do.
22:41:26 <Hijiri> I think it's the self-application that causes the issue, but I really don't know the answer
22:43:30 <Hijiri> :t \x -> x x
22:43:31 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
22:43:31 <lambdabot>     Relevant bindings include x :: t1 -> t (bound at <interactive>:1:2)
22:43:31 <lambdabot>     In the first argument of ‘x’, namely ‘x’
22:43:59 <wz1000> Ah, thats where the problem is.
22:44:12 <Hijiri> I guess it tries to figure out what x x is first
22:44:21 <Hijiri> but if you do it recursively it knows it's the return type of f
22:44:53 <Hijiri> but I don't really know, I barely know any backslash calculus
22:45:16 <wz1000> "backslash calculus"
22:46:35 <wz1000> > :t id id
22:46:36 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:46:42 <wz1000> :t id id
22:46:43 <lambdabot> a -> a
22:46:55 <wz1000> :t fmap fmap
22:46:55 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
22:47:58 <wz1000> How would you need to constrain the type of f to make (f f) well typed?
22:50:43 <benzrf> wz1000: impossible
22:50:48 <benzrf> oh wait
22:50:57 <benzrf> wz1000: that can be well kinded as long as f f is not of kind *
22:51:07 <benzrf> oh crap i thought you meant types
22:51:42 <benzrf> f f works if and only if f is a function whose first argument is a function of a more general type
22:52:07 <benzrf> and im pretty sure youd need rank 2 types to constrain that
22:52:09 <benzrf> not certain
22:52:14 <benzrf> :t \f -> f f
22:52:15 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
22:52:15 <lambdabot>     Relevant bindings include f :: t1 -> t (bound at <interactive>:1:2)
22:52:15 <lambdabot>     In the first argument of ‘f’, namely ‘f’
22:52:18 <benzrf> oy
22:52:50 <wz1000> @let ycom = \f -> (\x -> f (unsafeCoerce x x)) (\x -> f (unsafeCoerce x x))
22:52:51 <lambdabot>  .L.hs:153:1:
22:52:51 <lambdabot>      Multiple declarations of ‘ycom’
22:52:51 <lambdabot>      Declared at: .L.hs:152:1
22:52:51 <lambdabot>                   .L.hs:153:1
22:52:51 <lambdabot>  
22:52:58 <wz1000> @undefine
22:52:58 <lambdabot> Undefined.
22:53:02 <wz1000> @let ycom = \f -> (\x -> f (unsafeCoerce x x)) (\x -> f (unsafeCoerce x x))
22:53:03 <lambdabot>  .L.hs:154:18: Not in scope: ‘unsafeCoerce’
22:53:03 <lambdabot>  
22:53:03 <lambdabot>  .L.hs:154:48: Not in scope: ‘unsafeCoerce’
22:54:16 <Hijiri> @let banana = (\x -> x x) :: (forall a. (a -> a)) -> forall b. (b -> b
22:54:16 <lambdabot>  Parse failed: Parse error: EOF
22:54:23 <Hijiri> @let banana = (\x -> x x) :: (forall a. (a -> a)) -> forall b. (b -> b)
22:54:26 <lambdabot>  Defined.
22:54:30 <Hijiri> banana id 5
22:54:34 * hackagebot basic-prelude 0.3.10 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.10 (MichaelSnoyman)
22:54:37 <Hijiri> >banana id 5
22:54:49 <Hijiri> > banana id 5
22:54:51 <lambdabot>  5
22:54:59 <wz1000> Ah
22:55:04 <Hijiri> well that worked for id
22:55:23 <Hijiri> I don't think that works for anything else though
22:55:44 <Hijiri> except maybe \x -> undefined
22:56:32 <wz1000> @let ycom = \f -> (\x -> f (banana x)) (\x -> f (banana x))
22:56:33 <lambdabot>  .L.hs:154:33:
22:56:33 <lambdabot>      Couldn't match type ‘t’ with ‘a’
22:56:33 <lambdabot>        because type variable ‘a’ would escape its scope
22:56:33 <lambdabot>      This (rigid, skolem) type variable is bound by
22:56:33 <lambdabot>        a type expected by the context: a -> a
22:56:36 <benzrf> told u
22:56:41 <benzrf> rank 2 types =)
22:57:15 <wz1000> :t banana
22:57:16 <lambdabot> (forall a. a -> a) -> b -> b
22:57:31 <wz1000> :t banana id
22:57:31 <lambdabot> b -> b
22:58:38 <isBEKaml_mobile> :t unfoldr
22:58:39 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:58:51 <wz1000> Interestingly, the definition works with unsafeCoerce
23:00:35 <Hijiri> when I try to evaluate ycom id 5 with that definition it diverges
23:02:45 <Hijiri> oh, so does normal fix
23:03:07 <Hijiri> ycom (1:) works normally
23:03:24 <Hijiri> I don't know what I expected
23:04:16 <wz1000> y/fix id is undefined
23:04:35 * hackagebot classy-prelude 0.10.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.1 (MichaelSnoyman)
23:04:37 * hackagebot classy-prelude-conduit 0.10.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.1 (MichaelSnoyman)
23:04:39 * hackagebot classy-prelude-yesod 0.10.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.1 (MichaelSnoyman)
23:04:41 * hackagebot yesod-form 1.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.1 (MichaelSnoyman)
23:04:43 <wz1000> > let x = id x in x
23:04:47 <lambdabot>  mueval-core: Time limit exceeded
23:05:00 <wz1000> Which is the same as saying 'let x = x in x'
23:09:35 * hackagebot yesod-core 1.4.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.3 (MichaelSnoyman)
23:14:36 * hackagebot http-client 0.4.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.2 (MichaelSnoyman)
23:14:38 * hackagebot keter 1.3.5 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.5 (MichaelSnoyman)
23:17:23 <pharpend> oh wow yesod is at 1.4
23:17:27 <pharpend> jeez i'm behind the times
23:19:18 <solatis> pharpend: yeah they updated a lot of their frameworks lately
23:19:28 <pharpend> solatis: "they"
23:19:31 <solatis> he
23:19:34 <pharpend> solatis: there's one guy who does like all of yesod
23:19:43 <pharpend> solatis: it's actually really impressive
23:19:50 <pharpend> I have no idea how he has the time to do all of that
23:19:50 <solatis> yeah, sometimes it's hard to realise those kind of things
23:19:51 * hackagebot yesod-bin 1.4.0.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.4 (MichaelSnoyman)
23:19:55 <pharpend> yup
23:20:13 <solatis> it's a shame tho that it has some rough edges
23:20:18 <solatis> but what could you expect
23:20:24 <solatis> the man is doing an amazing job
23:20:30 <pharpend> compared to most web frameworks, yesod is very mature
23:20:38 <pharpend> even compared to rails or django
23:20:48 <pharpend> yesod doesn't have a lot of the stuff they have
23:21:00 <pharpend> but yesod is (a) much faster, and (b) much safer
23:21:08 <solatis> mwah the persistent library yesod provides is kinda buggy
23:21:13 <pharpend> yeah
23:21:20 <pharpend> it's really nice to use though
23:21:31 <pharpend> (My job is developing Yesod apps)
23:21:39 <solatis> :)
23:21:40 <solatis> i envy you
23:21:41 <johnw> pharpend: who for?
23:21:45 <pharpend> johnw: startup
23:21:48 <johnw> name?
23:21:54 <pharpend> Not sure if we have a name yet
23:22:08 <pharpend> tentatively, called "Rocky West Labs" (we are in Salt Lake City)
23:22:13 <johnw> The startup that shall not be named
23:22:52 <jxv> the startup who goes "ni"
23:23:05 <pharpend> I'm the only programmer, and I managed to convince the others that "Yes, Haskell is great and easy, and wonderful, and we will definitely be able to find other programmers without paying a fortune for them"
23:23:21 <solatis> that is probably true
23:23:30 <solatis> well, it's not easy
23:23:37 <pharpend> It's becoming more mainstream, which is good
23:23:59 <pharpend> It bugs the pretentious douche inside of me who likes to use obscure languages
23:24:12 <jxv> solatis easiness is relative.
23:24:13 <pharpend> But I like the fact that a type-safe robust language is becoming mainstream
23:24:32 <solatis> but having haskell as a requirement for job applications is actually a great early filter for unqualified candidates
23:24:38 <pharpend> ehh
23:25:08 <solatis> ehrm, my grammar might've been off on that sentence
23:25:22 <solatis> but you find a lot of crappy php / whatever programmers
23:25:43 <pharpend> For me, if someone is generally interested in things falling outside the typical domain of "I like JQuery and Javascript and Rails and CSS and app development sounds fun", I usually think they're probably a good egg
23:25:48 <solatis> if someone, nowadays, knows haskell, you reduce the risk of him being a crappy programmer by an order of magnitude
23:25:57 <pharpend> yes, definitely
23:26:15 <pharpend> even if they are a newbie, I think just understanding the functional paradigm is very helpful
23:26:41 <solatis> yeah it's more difficult tho
23:26:51 <pharpend> Not really, I don't think
23:26:57 <pharpend> I think it's just so different
23:26:59 <pharpend> for me
23:27:14 <solatis> i'm talking about teaching programming to 12 year olds in school here
23:27:24 <solatis> for people to get interested in programming
23:27:30 <kadoban> I'm not sure it's actually more difficult...most people learn imperitive first which really skews the perceived difficulty drastically.
23:27:36 <pharpend> ah okay. When I first tried Haskell, I had never seen a functional language before, outside of Common Lisp, which really isn't a functional language.
23:27:42 <solatis> yeah
23:27:48 <solatis> for me scala was the sweet spot
23:27:52 <solatis> it made me 'click' on FP
23:27:54 <aleator> solatis: Pay attention to syntax and the rest is easy
23:27:54 <pharpend> I was used to being able to pick up a new programming language in like a week
23:28:09 <solatis> and then soon ditched scala as it was a clusterf...ing mess
23:28:17 <solatis> tried erlang for 2 weeks
23:28:23 <solatis> decided it was the FP equavalent of perl
23:28:24 <pharpend> I try haskell and after a week I still didn't understand everything
23:28:27 <pharpend> yeah
23:28:27 <solatis> and then haskell
23:28:29 <bernalex> solatis: there is no evidence that teaching FP is more difficult than teaching imperative programming to 12 year olds. there are some anecdotes to the contrary though.
23:28:53 <solatis> yeah the start of haskell was really, really hard
23:29:06 <solatis> you have to be really motivated
23:29:08 <bernalex> pharpend: also hallo fellow startup-that-uses-haskell-person
23:29:36 <aleator> bernalex: There are also attempts to study this: http://web.cs.wpi.edu/~kfisler/Pubs/icer14-rainfall/icer14.pdf (Though mostly in scheme)
23:29:53 <pharpend> solatis: what bernalex is outright saying, and I'm trying to illustrate through an example is, most of us learned imperative programming first, and had gotten good at imperative programming before ever touching haskell. so, functional programming was such a huge jab in the side, that it really caught us off guard
23:30:06 <solatis> yep
23:30:11 <solatis> that could very well be true
23:30:25 <pharpend> solatis: so we think functional programming is more difficult, because our reference of comparison is something we could do with our eyes closed
23:30:29 <solatis> and i think it's really weird that i finished my software engineering degree without touching FP even once
23:30:31 <bernalex> aleator: yeah there are a few isolated cases of people trying to use FP, but IDK anyone doing it in a rigorous scientific framework. that would be cool.
23:31:05 <aleator> bernalex: Check out the pyret guys. They are quite serious about FP and teaching languages.
23:31:16 <solatis> well i do think it's more 'mathematical'
23:31:36 <solatis> it leaves less room for error
23:31:44 <pharpend> solatis: however, if we learned functional programming first, we would probably thing imperative programming is horrible and hard and why do all of these people do that
23:31:56 <bernalex> solatis: CS/SE is not what it used to be. :-] in most countries at least. instead of 4 years, they are now 3 years. instead of teaching theory and expecting you to figure out the practice yourself (because only geeks apply anyway, right?), it's now all about get-shit-done because a bunch of applicants have never programmed, and are expected to have an illustrious career as Java getters & setters writers at
23:31:57 <bernalex> corporate drone farm #13042546. :-]
23:32:16 <solatis> pharpend: and thus an entire generation of pretentious little bastards is born... :p
23:32:28 <pharpend> solatis: I don't know of anyone who has gotten very good at functional programming, but still preferred imperative languages. So, I'm guessing we would all think they are some horrible clusterfuck of complexity.
23:32:33 <aleator> pharpend: Notice however, that as far as FP languages go, Haskell is not the beginner friendliest of the bunch.
23:32:43 <pharpend> aleator: ocaml is mildly simpler
23:32:50 <bernalex> aleator: I think a haskell *subset* would be great.
23:32:54 <solatis> well people have been complaining that software engineering is not real engineering in the same way that, say, building bridges is
23:33:03 <solatis> there is soooo much room for error in programming nowadays
23:33:11 <pharpend> aleator: well, there isn't much to shoose from - Haskell, ML, Erlang, Scala, those are really the only functional languages
23:33:12 <solatis> i think FP solves quite a lot of these problems
23:33:12 <bernalex> aleator: if you start off with the IO monad you're going to fail pretty hard, lol. but I think writing equations in GHCi could be a very nice way of teaching.
23:33:15 <aleator> pharpend: ocaml still shares few beginner unfriendly things like currying etch.
23:33:20 <pharpend> aleator: i guess
23:33:32 <bernalex> pharpend: you can write very functional scheme/lisp.
23:33:42 <aleator> pharpend: Really, check out pyret (www.pyret.org)
23:33:45 <pharpend> bernalex: yes, but most of the examples you will see abuse setfs and what not
23:33:59 <pharpend> oh that looks cool
23:34:08 <bernalex> pharpend: again, when teaching haskell, don't start with the IO monad. when teaching lisp... don't be an idiot there either. ;-)
23:34:18 <pharpend> looks like a pythony haskell (aka rust), but it's hopefully more stable
23:34:54 <pharpend> In terms of "beginner friendly", the community is arguably the most important part
23:35:04 <pharpend> I've never been disappointed with the Haskell community
23:35:06 <aleator> bernalex: That's true. IO you can skip, but the difficulty arises from things like typeclasses, currying, types and polymorphism that you must pretty much teach at day 1.
23:35:38 <bernalex> aleator: you do? to children? I thought you'd start with how to write really simple equations and teach recursion at day 1.
23:36:12 <aleator> bernalex: Well, I teach second year uni students, but pretty much yes. If you compare two numbers you end up with your first type class constraint.
23:36:14 <bernalex> I mean that's how MIT teaches scheme, they don't start right away with tail call optimisation details. or at least they didn't use to.
23:36:32 <pharpend> bernalex: I think we're talking about teaching a programming languages, not just teaching kids cs
23:36:59 <bernalex> pharpend: oh. I think doing the former without the latter is a really stupid idea. so no comments from me then. :-]
23:37:12 <aleator> bernalex: Also, since almost all errors in Haskell are type errors, the chances are that during day 1 you have few students are hit hard by their first contact with the type system.
23:37:13 <jxv> scheme would probably be the best starter fp lang.
23:37:46 <pharpend> sure for basic algorithmik thinking, you don't need to understand types, but to actually do anything in any programming language (with the exception of maybe Erlang), you need to understand how types work
23:37:53 <aleator> jxv: Not really. Even the DrRacket gang are moving away from scheme. Mostly due to sicp and homogenous syntax issues.
23:38:12 <pharpend> you can teach quicksort and Euclid's algorithm without touching type theory
23:38:20 <bernalex> aleator: I'd teach types and basic algebra and maybe even real basic category theory before I ever started GHCi. :-]
23:38:22 <pharpend> but i see aleator's point
23:39:08 <aleator> bernalex: For kids? Even uni students would drop out if they can't start programming on the first week. At least ours are likely to do.
23:39:28 <aleator> But I kind of agree with you there.
23:39:29 <jxv> aleator, I wouldn't expect first timers to master it but rather gain exp and motivation to learn more. So I don't think that's much of an issue.
23:40:07 <jxv> Then you bait-and-switch with haskell :)
23:40:12 <bernalex> aleator: yes. the context-switch generation doesn't seem to have the attention span for it. I'm not sure it's a great idea, but I'd definitely try it. :-] FWIW at my first uni we didn't touch computers during the first semester *at all*. it was a computer engineering degree. :-]
23:40:14 <pharpend> aleator: simple, teach programming until the drop deadline, then quit teaching programming and switch to category theory :)
23:40:18 <solatis> it really, *really* depends on the type of person someone is and how someone learns
23:40:32 <aleator> pharpend: Heh :)
23:40:36 <solatis> i personally learn by doing
23:40:38 <bernalex> solatis: well yeah schools are stupid
23:40:54 <pharpend> aleator: then teach programming right at the end so that you don't get terrible course reviews
23:41:17 <bernalex> solatis: one mammal talking to 200 other wildly individual mammals and trying to sort-of hit a middle-ground where 150 of them are entertained. it doesn't really work all that well. :-]
23:41:30 <aleator> My current plan is that I go and teach people to do lambda calculus during the 'introduction to university studies course' (I'm serious)
23:42:03 <aleator> So I get students that know how parenthesis, equality and variables work before stumbling to linear algebra or programming.
23:42:03 <solatis> aleator: well during my degree, the first 8 weeks were the hardest of the whole first year
23:42:06 <bernalex> aleator: that's a great plan. I think Turing machines for imperative programming and Lambda Calculus for functional programming are really useful learning experiences.
23:42:11 <solatis> to make sure everyone who was not motivated would drop out
23:42:30 <solatis> a lot of people got wanted to do software engineering because "i like to play videogames"
23:42:33 <solatis> we had to get rid of those
23:42:34 <pharpend> okay
23:42:42 <pharpend> we're starting to get ridiculous
23:42:47 <pharpend> I'll fast forward
23:42:50 <aleator> My uni is perhaps bit special in that we get a lot of students who aren't really motivated and _we cannot get rid of anyone_
23:42:53 <bernalex> solatis: I don't think there's anything wrong with wanting to get a programming degree because they like videogames. :-]
23:43:03 <pharpend> All kids should have a PhD in math before starting programming
23:43:09 <aleator> So we get guys who don't know what a a variable is after thee weeks of programming 1.
23:43:09 <bernalex> solatis: but at my first uni it was 6 months of physics, chemistry & maths first.
23:43:18 <pharpend> we would get much better programmers, admittedly
23:43:37 <pharpend> although everything would be in friggin coq
23:43:47 <pharpend> or matlab or something of the like
23:44:13 <solatis> pharpend: oh yes now there's an utopia to think about
23:44:26 <bernalex> pharpend: I can assure that everything would not be in a Turing-incomplete language. :-P
23:45:09 <bernalex> + it's not like all or maybe even most programmers still are actually formally educated.
23:45:21 <pharpend> true
23:45:24 <pharpend> the best programmers
23:45:29 <pharpend> rms, degree in physics
23:45:50 <bernalex> SPJ's degree is in maths because uh well CS didn't exist :-P
23:45:54 <pharpend> haha
23:45:55 <pharpend> yeah
23:45:56 <solatis> pharpend: yes yes, but that's because in those days there was no CS
23:46:07 <pharpend> maybe
23:46:17 <pharpend> cs degrees now are sort of silly
23:46:32 <aleator> My experience is that people with strong formal background (math, stat, phys) run in circles around pure cs students in our uni.
23:46:37 <pharpend> all of the cs majors I know are the "I want to develop APPS!!!1!!" kind
23:46:48 <pharpend> aleator: same here.
23:47:10 <solatis> pharpend: on the other hand, it's kind of sad to see the remainders of the people going to work for google trying to get people to click on ads more often
23:47:13 <Hijiri> would there be a point to a CS/
23:47:27 <Hijiri> Math double major? (accidentally hit enter)
23:47:35 <pharpend> aleator: my background is mostly in pure math, and the cs kids usually think I'm making up bullshit when I try to explain monoids to them. :/
23:47:45 <aleator> pharpend: Anecdote. Our CS1 teacher goes over the exercises he wants students to do, and there are equations for mean and variance. Two students start laughing and walk out. When asked why they say that "the math stuff is too hard" :)
23:47:56 <pharpend> or explain how really they just need to define communtative rings, and their program will magically work
23:48:05 <bernalex> Hijiri: I think we should have pure CS degrees, but they should be four years and actually teach things, not just give you assignments to make iOS apps.
23:48:20 <solatis> aleator: it's like the fizzbuzz for college
23:48:29 <pharpend> aleator: https://i.imgur.com/uYjUuC9.gif
23:48:47 <Hijiri> I'm in my first year and the first CSE course is basically just a programming class
23:48:56 <aleator> pharpend: Indeed :)
23:49:08 <pharpend> aleator: you seem pretty bright, where do you teach, if you don't mind my asking?
23:49:36 <bernalex> BTW we should all have moved into #haskell-blah quite a while back :-]
23:49:48 <pharpend> definitely
23:49:50 <pharpend> too late now
23:49:57 <aleator> pharpend: University of Jyväskylä/Finland. I ain't bright but I did spend few years explicitly trying to study how to teach FP/Haskell to our kids.
23:50:14 <pharpend> if someone has an actual question, I'd be happy to move
23:50:20 <pharpend> for the moment, i don't see any reason to
23:50:21 <aleator> kids=1 or 2 year students
23:50:47 <pharpend> aleator: i always find it funny how europeans are much better English speakers than Americans
23:50:49 <bernalex> aleator: average bachelor degree age at the unis I've been to have been around 29 years lol
23:51:22 <solatis> bernalex: is that because they start late, or slack too much?
23:51:55 <bernalex> solatis: start late, I guess. that's across all three years though.
23:52:47 <aleator> Quickly recapping the original topic. Haskell is great, but for a beginner there are quite many small gotchas that you want to be aware when teaching. Biggest of these seems to be currying (fine, unless you start with . and $) and learning to match types
23:52:54 <bernalex> solatis: come to think of it, maybe it was average 29 for graduation age. that makes more sense. because party teens drop out etc.
23:53:17 <bernalex> aleator: only teach pointfree code! :-P
23:53:42 <aleator> bernalex: I'm not actually even sure that that would be a bad idea.
23:53:56 <bernalex> aleator: I wouldn't start with zipWith7 at least
23:53:57 <ThreeOfEight> aleator: in my experience, the people who are used to Java struggle the most
23:53:58 <solatis> the person who started to teach me haskell started out by explaining everything in haskell was a function that accepted only 1 argument and returned a new function
23:54:12 <solatis> then he started to explaining that do notation were monad transformers
23:54:22 <solatis> and then i ran away for 2 years and never came back
23:54:27 <Cale> solatis: heh
23:54:28 <pharpend> aleator: really, you should teach them about lenses on the first day
23:54:30 <bernalex> solatis: that's not completely true but. :-]
23:54:38 <pharpend> solatis: technically, he's not wrong. he's just an asshole
23:54:38 <bernalex> pharpend: applicative lenses lol
23:54:51 <ThreeOfEight> people always want to write loops and modify variables in the first few weeks
23:54:52 <solatis> well he obviously wasn't interested in teaching me
23:54:56 <Cale> solatis: Either his explanations were a bit off, or you're not quite remembering them perfectly I think :)
23:55:01 <solatis> he was showing me shy he thinks haskell is better
23:55:03 <Cale> But yeah
23:55:03 <aleator> pharpend: Absolutely. I would save a huge penny on assistant pay since there would be less exercises to grade :)
23:55:04 <solatis> or more pure
23:55:05 <ThreeOfEight> some of them actually try to modify variables in the exams
23:55:23 <pharpend> @@ bernalex @type (.) . fmap . traverse . fmap traverse . (,,,traverse,,fmap,) . (<*) . (<|>) . traverse . mapM
23:55:24 <lambdabot>  bernalex (Traversable t5, Traversable t4, Traversable t1, Traversable t, Applicative f3, Applicative f1, Functor f2, Functor f, Monad f3, Alternative ((->) (t5 [a5]))) => (a5 -> f3 b3) -> (a -> f (t a1)) -> a -> f (t1 a2 -> t (t2 -> t1 (t3 -> (((t5 [a5] -> f3 (t5 [b3])) -> b2) -> (t5 [a5] -> f3 (t5 [b3])) -> t5 [a5] -> f3 (t5 [b3]), a1, a2, (a3 -
23:55:24 <lambdabot> > f1 b) -> t4 a3 -> f1 (t4 b), t2, (a4 -> b1) -> f2 a4 -> f2 b1, t3))))
23:55:30 <Cale> Not everything in Haskell is a function :)
23:55:36 <ThreeOfEight> one of them even handed in perfectly correct code, but in Standard ML (because we taught SML in the years before)
23:55:38 <pharpend> really any first year student should be able to comprehend that
23:55:47 <Cale> pharpend: heh
23:56:12 <bernalex> pharpend: well you can eta-abstract it to make sense out of it. it will just take a little bit of time.
23:56:25 <solatis> Cale: i exlained it wrong, he said that every function accepting multiple arguments are actually implemented using functions that accept one argument and return a new function
23:56:49 <bernalex> some of those are categories :-P
23:56:57 <solatis> but there is absolutely no reason /at all/ to start off explaining those implementation details
23:56:57 <Cale> solatis: Yeah, that's true, and you do kind of have to learn that early on.
23:57:07 <Cale> solatis: It's not so much about the implementation
23:57:24 <Cale> It's that it's possible to apply functions to fewer than the maximum number of arguments they accept
23:57:25 <solatis> once you start talking about currying, *then* you can start talking about this
23:57:35 <ThreeOfEight> Well that /is/ Currying
23:57:41 <solatis> yeah exactly
23:57:52 <ThreeOfEight> and it's an important part of the underlying logic, not an implementation detail
23:57:55 <Cale> If you want to look at the implementation, well, GHC will often go the other way and specialise versions of functions which take more parameters
23:58:27 <bernalex> Cale: yeah the whole "add x y = x + y, add6 x = x + 6" is quite grokable. but if you drop the C-bomb without any context, it might be a bit bemusing. :-]
23:58:31 <Cale> So, you get to pretend that everything takes just one argument and produces another function, even if the compiler is going to be smarter than that
23:58:31 <ThreeOfEight> but whether it is a good idea to mention it at the very start of the lecture is disputable
23:58:31 <solatis> ThreeOfEight: just as important as, say, the difference between stack and heap are in C-like languages, but you don't start off explaining those
23:58:54 <Maxdamantus> Well, is it technically currying?
23:59:04 <Maxdamantus> What is actually being curried?
23:59:25 <ThreeOfEight> Maxdamantus: what do you mean?
23:59:40 <solatis> Maxdamantus: you're talking to bernalex ?
23:59:51 <timmansfield> Hi there. I don't want to interrupt, but I'm a Haskell noob with a GHCI question.
23:59:53 <Cale> Maxdamantus: Well, it's not exactly currying, unless you're thinking of the functions of multiple arguments as initially taking tuples.
