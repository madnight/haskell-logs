00:07:55 * hackagebot ddc-war 0.4.1.3 - Disciplined Disciple Compiler test driver and buildbot.  http://hackage.haskell.org/package/ddc-war-0.4.1.3 (BenLippmeier)
00:07:55 * hackagebot app-settings 0.2.0.5 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.5 (EmmanuelTouzery)
00:15:33 <redtricycle> this looks like it: https://egonschiele.github.io/HandsomeSoup/
00:22:50 * hackagebot thread-local-storage 0.1.0.0 - Several options for thread-local-storage (TLS) in Haskell.  http://hackage.haskell.org/package/thread-local-storage-0.1.0.0 (RyanNewton)
00:26:44 <solatis> redtricycle: that looks interesting
00:26:57 <solatis> i'm currently using tagsoup, but it apparently is a performance bottleneck in my app
00:27:10 <solatis> (as in, downloading HTML content goes faster than the parsing i'm doing)
00:27:23 <solatis> i'm looking for something more performant
00:28:55 <kadoban> HTML is quite a huge mess to parse, it's possible that it's necessarily pretty slow. Part of the problem is that a parser has to be...very leniant, or it's pretty close to useless in practice, because HTML in the real world is pretty shit quality in general, and browers are almost required to guess what it's actually supposed to mean.
00:29:23 <kadoban> solatis: ^   not sure that's actually useful info, but whatever.
00:29:59 <kadoban> solatis: What are you actually parsing it for? Are you just picking out certain info? Do you actually have to parse the HTML, or can you get away with fudging it?
00:30:32 <nisstyre> kadoban: quirks mode is the source of lots of security holes
00:31:06 <nisstyre> fyi that is the technical term for "parsing tag soup mode"
00:31:21 <nisstyre> if your page is in quirks mode you know you f-ed up
00:31:39 <kadoban> I thought that was just an IE term.
00:31:45 <nisstyre> firefox uses it too
00:31:53 <nisstyre> not sure about google's stuff
00:32:51 * hackagebot thread-local-storage 0.1.0.1 - Several options for thread-local-storage (TLS) in Haskell.  http://hackage.haskell.org/package/thread-local-storage-0.1.0.1 (RyanNewton)
00:32:53 * hackagebot xml-html-conduit-lens 0.3.2.1 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.1 (MatveyAksenov)
00:34:04 <solatis> kadoban: well in python you can, for example, use a html parser based on libxml2
00:34:13 <solatis> that one is very, very fast
00:34:15 <nisstyre> yeah
00:34:18 <nisstyre> lxml.html is good
00:34:25 <nisstyre> the parser's in C IIRC
00:34:41 <kadoban> Yeah, I've used that in beautifulsoup i think.
00:34:56 <nisstyre> you can access BS in lxml.html btw
00:35:04 <nisstyre> so you should never have any reason to use the real BS
00:35:48 <kadoban> Well, I've used it for years, it's just the default because I already know it.
00:36:06 <solatis> no, beautifulsoup is purely python
00:36:18 <solatis> lxml in python is a wrapper around libxml2
00:36:33 <nisstyre> solatis: but it includes (at least part) of BS
00:36:37 <nisstyre> as an option
00:37:03 <solatis> http://lxml.de/elementsoup.html
00:37:08 <solatis> i assume you mean that
00:37:08 <nisstyre> yeah
00:37:27 <solatis> that is just an API-compatible interface of LXML
00:37:32 <nisstyre> oh I see
00:37:33 <solatis> to beautifulsoup
00:37:38 <solatis> it doesnt "include" beautifulsou
00:37:40 <pharaun> ive been using hxt
00:37:47 <solatis> it just makes lxml as a drop-in replacement
00:37:50 <pharaun> works, the arrow notion is kinda weird for me tho
00:37:52 * hackagebot xml-html-conduit-lens 0.3.2.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.0 (MatveyAksenov)
00:37:54 * hackagebot thread-local-storage 0.1.0.2 - Several options for thread-local-storage (TLS) in Haskell.  http://hackage.haskell.org/package/thread-local-storage-0.1.0.2 (RyanNewton)
00:38:10 <solatis> xml-html-conduit ... oh my
00:39:58 <merijn> I've used html-conduit and found it fairly easy to work with
00:40:00 <solatis> https://hackage.haskell.org/package/libxml
00:40:18 <solatis> 6 years since last update, tho
00:41:20 <solatis> https://hackage.haskell.org/package/libxml-sax-0.7.5/docs/Text-XML-LibXML-SAX.html
00:41:23 <solatis> that seems more like it
00:41:38 <solatis> but oh god, the interface is...
00:42:35 <solatis> then again, if performance is an issue, this is as good as it gets i guess
00:42:58 <kadoban> solatis: What's your goal in parsing this stuff though?
00:43:11 <solatis> crawler framework
00:43:41 <solatis> i need to extract information from tens of thousands of urls, each being +- 500kb documents
00:43:45 <kadoban> solatis: You can probably pick out the content you want with something far far simpler than an actual HTML parser, right?
00:43:53 <solatis> i'm not sure
00:44:18 <kadoban> Well, as long as you're okay with some false positives, URLs are dead simple to pick out I would think.
00:44:35 <kadoban> Where false positives would be like...links that are actually in HTML comments or something dumb.
00:44:36 <merijn> What's wrong with html-conduit, that lets you easily hook into http-conduit for fetching them too
00:44:44 <solatis> no i mean, i need to parse information from a lot of documents
00:44:55 <solatis> not extract urls from those documents
00:45:08 <kadoban> Ah. Then I guess it depends what you're picking out.
00:45:13 <solatis> but my actual problem is probably that i'm evaluating the TagSoup generated lists a lot of times
00:45:22 <solatis> ehr, traversing
00:45:48 <solatis> for a 500kb document, the lists are thousands of elements long
00:46:44 <solatis> so i probably am better of with something that generates an actual tree
00:46:46 <pharaun> i wonder bout using the libxml2 that lxml uses, it was decently performant in python and wasn't bad
00:46:49 <solatis> instead of a lazy list
00:48:29 <pharaun> i forget but in tagsoup you *have* to traverse it or can you tell it to only emit a subset?
00:49:32 <solatis> it's a lazy list
00:49:45 <solatis> so if you don't traverse the list until the end, it doesn't continue parsing
00:50:10 <solatis> on the other hand, if you, like me, need to do +- 20 lookup operations on said list, it can actually be quite bad
00:50:27 <pharaun> what kind of lookups are you doing? any way you can one-pass and cache
00:53:24 <solatis> pharaun: yeah but then i'm basicly doing the same thing as any SAX parser
00:54:42 <solatis> and then i can better use http://hackage.haskell.org/package/libxml-sax-0.7.5/docs/Text-XML-LibXML-SAX.html since it actually uses libxml2 on the background
00:55:15 <pharaun> ive actually never used an sax parser :O
00:55:34 <solatis> SAX parser means 'you get only callbacks'
00:55:41 <solatis> so you get a callback when a tag opens
00:55:43 <solatis> when a tag closes
00:55:45 <solatis> etc
00:55:54 <pharaun> ahh
00:56:02 <pharaun> right right, constant/lower memory usage than DOM
00:56:05 <solatis> so very low memory overhead
00:56:10 <pharaun> i just never had the need to use one
00:56:27 <solatis> and libxml2 is a fault-tolerant html5 parser written in C, which is known to be very very fast
00:56:41 <pharaun> i can't remember, i mean lxml parsed html, ah it was libxml2 that did the actual html parsing ?
00:56:41 <solatis> libxml-sax is a thin wrapper around that for haskell
00:56:46 <pharaun> nice
00:57:06 <pharaun> i liked lxml, i wonder how that interface is, looking at it, could be nice for my usecase
00:57:19 <pharaun> (i'm basically scrapping some sites as well) and i found parsing to be my bottleneck as well
00:57:38 <solatis> well ive written a crawler framework in python before
00:57:52 <solatis> we ended up using lxml, because it blew all other alternatives away
00:57:57 <pharaun> basically
00:58:06 <pharaun> used to use beautiful soup but its lxml at work now days
00:58:18 <solatis> yeah it's an order of magnitude faster
00:58:20 <pharaun> never did the crawler in python, did it in ruby but with what was it.. nokogiri
00:58:55 <insitu> hello, I do not understand how impredicative types work. I have this code: http://lpaste.net/113521
00:59:08 <solatis> but god oh god, i don't want to deal with all these callbacks
00:59:12 <pharaun> solatis: anyway ahh, that api is a bit raw
00:59:13 <pharaun> yeah
00:59:18 <pharaun> lxml wasn't bad
00:59:19 <solatis> well
00:59:29 <solatis> that's how XML parsers work
00:59:37 <pharaun> well, sax parser to be precise :p
00:59:59 <solatis> well DOM is the other alternative
01:00:02 <pharaun> iirc, i was reading a bit bout using pipes to make "callback" api much nicer
01:00:04 <pharaun> solatis: sure
01:00:13 <pharaun> that's what i'm used to, the dom approach
01:00:22 <solatis> and you can easily build a DOM using a SAX parser
01:00:25 <insitu> but I cannot declare non-empty Rules as the error at bottom says
01:00:42 <pharaun> solatis: yeah not surprised. i ugess i should sit down and see how beautiful soup is then this thing
01:01:03 <pharaun> hxt is quite nice, still an bottleneck so curious if tagsoup is faster
01:01:04 <insitu> from what I understood, quantifying inside constructor should allow uysing any instance of the typeclass
01:01:04 <solatis> pharaun: using pipes doesn't matter -- the problem is that i will need to keep track of different contexts to know 'where i am' in the document
01:01:11 <pharaun> and oops tagsoup was what i was meaning
01:01:31 <pharaun> solatis: ya
01:01:35 <solatis> basicly, use a DOM if memory overhead is not a problem and you need quick lookups
01:01:43 <pharaun> for my usecase it shouldn't be too bad i don't think but *shrugs*
01:01:47 <insitu> of course I could use a simple data type but wanted to experiment ....
01:01:50 <pharaun> but my lookup is pretty sparse
01:01:51 <solatis> use a lazy list if memory overhead is not a problem and you do not need quick lookups
01:02:01 <solatis> and use a SAX parser if you want performance
01:02:10 <pharaun> so it seems like sax would be nicer cos i have really sparse lookup and i can do it in one-pass
01:02:42 <pharaun> and yeah i would like to make the parsing part be less of a bottleneck *shrugs*
01:02:48 <pharaun> but what i have works :)
01:03:02 <pharaun> forgot to lookup sax parsers/libxml2 thanks for the pointer
01:03:27 <solatis> well
01:03:48 <solatis> what i want is something similar to this: http://lxml.de/tutorial.html#the-elementtree-class
01:03:58 <solatis> uses libxml2 in the background, but does build an element tree
01:04:12 <solatis> so you have a fast parser but a DOM
01:04:42 <solatis> how intelligent would haskell be with memory management?
01:04:48 <pharaun> yeah i'm not aware of something like that
01:04:58 <pharaun> hence i went with hxt but would like something like that in haskell
01:05:15 <solatis> as in, i suppose a 500kb HTML document would result in a tree of 1MB - 10MB in size
01:05:24 <solatis> would haskell be cleverly reusing the allocated space?
01:05:33 <solatis> (in c++ i would make sure that memory is reused)
01:05:51 <solatis> you know what
01:06:10 <solatis> it's time for a haskell-libxml-sax-tree
01:06:10 <pharaun> insitu: sorry i'm unable to answer your question :( seems like most of the more xperty people are sleeping, try again in a while ?
01:06:12 <solatis> :)
01:06:18 <pharaun> solatis: i would use the heck out of that
01:06:33 <insitu> pharaun: thanks for caring :-) Will try later...
01:06:40 <pharaun> for me this thing seems ok for my usecase but i would def like the libxml sax tree
01:06:46 <insitu> or use SO
01:06:47 <pharaun> nicer usage
01:06:54 <pharaun> insitu: good luck :) sorry i couldn't help
01:07:00 <pharaun> haven't played with imprecise types yet
01:07:07 <solatis> i recon it's not that difficult to build the tree, but the interface for lookups is not something i'm currently capable of designing
01:07:14 <solatis> as in, i'm too much of a noob to know what i need to use
01:07:25 <solatis> all these existing libraries seem to be so opinionated
01:07:50 <pharaun> scratch your itch and experimenting :)
01:07:55 * hackagebot hsc3-plot 0.15 - Haskell SuperCollider Plotting  http://hackage.haskell.org/package/hsc3-plot-0.15 (RohanDrape)
01:08:03 <pharaun> could toss something together to start see how it works out then iterate ?
01:08:24 <solatis> well
01:08:34 <solatis> i'll write some code now that will build the tree
01:08:40 <solatis> i'll put it on github
01:09:00 <solatis> and we can then discuss how to cleverly get elements out of the document :)
01:09:16 <xpika> what is a good way to convert (a -> b) -> (a,Maybe a) -> (b,Maybe b) ?
01:10:01 <solatis> xpika: what would (a, Maybe a) mean? wouldn't that always just be (a, Just a) ?
01:10:05 <solatis> otherwise a would not exist
01:11:21 <solatis> pharaun: let's continue in pm
01:11:57 <xpika> > [(1,Nothing),(2,Just 3)] :: [(Int,Maybe Int)]
01:11:59 <lambdabot>  [(1,Nothing),(2,Just 3)]
01:12:04 <pharaun> solatis: sure, tho i need to head off to bed soon but sure, let's chat a bit :)
01:12:09 <xpika> solatis: ^^^
01:14:10 <supki> > (1, Just 4) & beside id traverse %~ succ
01:14:11 <lambdabot>  (2,Just 5)
01:15:10 <xpika> supki: whats beside?
01:16:55 <xpika> supki: thanks btw
01:17:46 <johnw> it provides a lens for each side of the tuple
01:19:53 <Ferdirand> win 19
01:19:56 <Ferdirand> oops
01:25:54 <solatis> xpika: that is not (a, Maybe a) but that is (a, Maybe b) :)
01:30:45 <belst> @quote javascript
01:30:45 <lambdabot> donw says: [of JavaScript booleans] I've heard of duck-typing, and static-typing, but this is the first time I've heard of Schrödinger-typing...
01:31:00 <trap_exit> what?
01:31:03 <trap_exit> schrodinger-typing?
01:31:06 <trap_exit> what piece of code does that?
01:36:09 <solatis> trap_exit: probably code related to heisenbugs
01:36:33 <solatis> by the way, it's not called schrodinger-typing, but quantum-typing.. :)
01:38:07 <solatis> unless of course the boolean actually kills kittens
01:48:39 <xpika> Is there an example of an applicative that is not a monad?
01:49:05 <simpson> xpika: Ziplist comes to mind.
01:52:00 <trap_exit> well haskell must be infamous for this
01:52:03 <trap_exit> there are progrmas which terminate
01:52:09 <trap_exit> unless you print out a var
01:52:22 <trap_exit> so looking at a var can cause (1) prog to not terminate, (2) exception thrown, (3) other bad things happening
01:53:04 <kadoban> trap_exit: That's basically guaranteed by being non-strict.
01:53:37 <trap_exit> yeah
01:53:38 <trap_exit> haskell sucks
01:55:07 <Ferdirand> ziplist is not a monad ?
01:56:21 <trap_exit> is there anyh langauge
01:56:25 <trap_exit> with the type sytem of haskell
01:56:26 <trap_exit> but strict?
01:56:28 <trap_exit> that'd be my ideal language
01:58:17 <shiona_> Ferdirand: https://www.haskell.org/pipermail/haskell-cafe/2009-April/059088.html
02:02:25 <xpika> simpson: thanks
02:02:41 <xpika> Ferdirand: nope
02:03:06 <solatis> trap_exit: i remember a discussion in here a few days ago of some core haskell devs working for a bank making a strict haskell
02:03:30 <trap_exit> yeah
02:03:31 <trap_exit> i heard it was fucking internal
02:04:07 <dibblego> Ferdirand: no, ZipList is not a Monad, only Applicative.
02:04:17 <solatis> oh in my backlog i read now that you were part of the discussion
02:04:20 <solatis> language was called Mu
02:05:35 <solatis> :o
02:05:38 <solatis> https://webcache.googleusercontent.com/search?q=cache:0f-XL5Xkng4J:anil.recoil.org/papers/2011-cufp-scribe-preprint.pdf+&cd=2&hl=en&ct=clnk&gl=kh
02:05:54 <solatis> "Standard Chartered’s Mu codebase is of significant size and lives within a library forquantitative analysts written in a combination of C++, Haskell and Mu itself. Languageinteroperability is key; all parts of the system can easily be invoked from Excel, C#, Javaor any other component."
02:06:09 <solatis> only a Bank would require language interop with haskell from Excel macro's
02:08:13 <nisstyre> solatis: well people with finance degrees didn't necessarily learn to program
02:08:32 <solatis> i know, it was kind of tongue-in-cheek
02:08:41 <nisstyre> :p
02:09:11 <solatis> i've actually been really, really impressed what people are accomplishing in Excel
02:09:50 <solatis> if you consider it something like an extremely limited, structured "browser" you can see how awesome it can be
02:19:19 <lericson> feats in "programming" excel are similar to robots built with lego mindstorm, impressive for the tool but not really hard to do otherwise ;)
02:21:41 <solatis> lericson: except that there is a huge, billion-dollar ecosystem built around these 'lego mindstorm' robots
02:30:50 <solatis> question: what is the recommended, 'lazy' way of reading the contents of a lazy ByteString?
02:31:17 <solatis> as in, i have a parser which i can feed bytes (non-lazy Bytestrings), and i have a lazy ByteString as input
02:31:32 <solatis> what is the best way to 'feed' this parser as the bytes come in/
02:32:01 <solatis> convert the Lazy.ByteString to chunks ? will this list be lazy?
02:33:14 <solatis> :t Data.ByteString.Lazy.interact
02:33:16 <lambdabot> (BSLC.ByteString -> BSLC.ByteString) -> IO ()
02:33:24 <solatis> is that what i want?
02:34:01 <solatis> nvm
02:34:23 <solatis> :t Data.ByteString.Lazy.hGetNonBlocking
02:34:24 <lambdabot> GHC.IO.Handle.Types.Handle -> Int -> IO BSLC.ByteString
02:36:58 <solatis> hmm
02:37:00 <solatis> or maybe not
02:38:07 <solatis> :t Data.Binary.Get.runGet
02:38:08 <lambdabot> Data.Binary.Get.Internal.Get a -> BSLC.ByteString -> a
02:38:17 <solatis> that's probably it
02:43:31 <trap_exit> anyone have a good recommendation for a black, machine-washable blazer?
03:04:51 <lericson> solarus: you're saying there is no huge billion-dollar ecosystem built around excel? ;)
03:56:34 <bernalex> anyone have a good idea for how to do this semi-tersely: given a [String] of words, split it so that the String of unwords is no longer than 100 chars.
03:57:28 <bernalex> a smaller example: given ["this","is","a","test"] -- if this could be max 10 chars when unworded, it should give: "this is a".
03:57:44 <bernalex> so the undworded should be 100 chars max, but not split in the middle of a word.
03:57:57 <bernalex> *unworded
03:59:03 <jose882> you could try this:
03:59:07 <jose882> take 10 $ unwords $ ["this","is","a","test"]
03:59:29 <lericson> :t unwords
03:59:30 <bernalex> that is not correct
03:59:30 <lambdabot> [String] -> String
03:59:44 <bernalex> > take 11 $ unwords (words "this is a test")
03:59:46 <lambdabot>  "this is a t"
03:59:49 <lericson> i think he wants to join the words until the length is >= 10
04:00:12 <bernalex> I wand the String to be max 100 chars, but *not* split in the middle of a word
04:00:26 <jose882> ah, I see
04:00:28 <lericson> bernalex: what about taking the first 100 characters and then dealing with excess?
04:00:38 <lericson> hmm i see the problem
04:00:42 <bernalex> let me state the full problem
04:01:28 <tremon> I'd probably use a combination of takeWhile, words and (+)
04:01:33 <bernalex> I have a [String] of words. I want to turn this into a String of max length 100, that is not split in the middle of words. then I want to recurse on the rest and repeat this until I have a [[String]] where each [String] will be less than 100 chars when turned into a String.
04:03:06 <lericson> something with groupBy and takeWhile?
04:03:14 * hackagebot tup-functor 0.3.0.0 - Homogeneous tuples  http://hackage.haskell.org/package/tup-functor-0.3.0.0 (BalazsKomuves)
04:06:24 <hellertime> ok this is silly. I just tried to install hoogle, but cannot populate the database, because the www.haskell.org cert cannot be verified?
04:09:13 <bernalex> BTW I have a solution to this... it's just ugly...
04:09:35 <hellertime> do you wrap curl?
04:09:51 <hellertime> err wget?
04:10:26 <bernalex> hellertime: eh I was talking to myself/my discussion a bit before your question. sorry.
04:10:44 <hellertime> ha. ok
04:18:16 * hackagebot haskore 0.2.0.5 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2.0.5 (HenningThielemann)
04:20:12 <remdezx> Hello! Is ghci releasing memory? I tried to test it, but it allocates more and more....
04:20:32 <wei2912> how're you testing it?
04:21:15 <remdezx> I'm allocating an array with "let x = [1..1000000]"
04:21:25 <remdezx> computing it with seq
04:21:38 <remdezx> and then rebinding variable x with ()
04:21:58 <bernalex> I'm pretty sure I should be able to get rid of the reverse in here: foldr (\x xs -> if length (unwords (x : xs)) > 10 then xs else xs ++ [x]) [] (reverse xs) -- ideas?
04:22:30 <remdezx> wei2912: I'm also testing it with ekg
04:22:42 <wei2912> remdezx: no idea about the details, so don't ask me :P
04:24:21 <jose882> bernalex: I think you can do a foldl instead
04:24:36 <bernalex> jose882: yeah but I couldn't find a foldl I was pleased with
04:25:15 <jose882> bernalex: what do you mean?
04:25:32 <bernalex> jose882: I didn't find any way of doing it that I liked.
04:25:38 <jose882> foldl (\xs x ->if length (unwords (x : xs)) > 10 then xs else xs ++ [x]) [] ["this","is","a","test"]
04:25:48 <jose882> bernalex: is that not good enough?
04:26:25 <bernalex> jose882: that does not type check
04:26:52 <jose882> I just tried in ghci
04:26:53 <bernalex> jose882: oh wait I misread it
04:26:54 <jose882> it works for me
04:27:05 <bernalex> yeah you are right
04:27:44 <vixlur> maybe reverse $ foldl (\xs x -> if length (unwords (x : xs)) > 10 then xs else x : xs) [] xs ?
04:28:08 <bernalex> I prefer
04:28:10 <bernalex> > foldl (\xs x -> if length (unwords (x : xs)) > 10 then xs else xs ++ [x]) [] xs
04:28:12 <lambdabot>  ["this","is","a"]
04:31:17 <Kneiva> > foldl (\xs x -> if length (unwords (x : xs)) > 10 then xs else xs ++ [x]) [] ["123456", "7890a", "b"]
04:31:19 <lambdabot>  ["123456","b"]
04:32:06 <Kneiva> probably not what bernalex wants?
04:32:45 <lericson> it is not
04:34:42 <lericson> jose882: works but it makes a lot of useless computations
04:35:05 <lericson> or am i misunderstanding haskell maybe
04:35:21 <lericson> 10 years of imperative programming certainly leaves certain assumptions hard to erase
04:35:36 <jose882> lericson: that's true, it will go all the way even after it reaches the max limit
04:36:23 <jose882> lericson: it would be better to do your own recursive function so you can stop when you reach the maximum of chars you need
04:36:32 <lericson> yes quite
04:36:46 <lericson> perhaps also clearer
04:37:43 <dawik> most imperative languages support recursion though :)
04:38:11 <jose882> dawik: but not all efficiently...
04:38:26 <lericson> and it usually is not encouraged either
04:38:38 <lericson> but yes quite true
04:40:29 <dawik> yeah, beware of the stack overflow :)
04:40:49 <dawik> its a shame though. it makes for more concise code
04:42:14 <jose882> yes, but I think tail call optimization makes having stack traces difficult...
04:47:23 <Kneiva> bernalex: as ugly as yours? http://lpaste.net/113526
04:47:49 <hellertime> @pl (flip mod r . fromIntegral . hash . ((,) h)) `fmap` [hash h..]
04:47:49 <lambdabot> (flip mod r . fromIntegral . hash . (,) h) `fmap` [hash h..]
04:48:14 <hellertime> guess it don't get much better than that
04:48:50 <bernalex> Kneiva: at least. probably as unfinished too. :-] currently working with getting the function to be [String] -> [[String]], where [[String]] is a list of chunks less than length 100. :-]
04:58:20 * hackagebot imm 0.6.0.3 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.6.0.3 (koral)
05:22:06 <besenwesen> is there a name for the <- syntax in do blocks?
05:22:36 <Haskellfant> besenwesen: I heard people calling it unwrap
05:22:45 <besenwesen> seems nice enough
05:23:23 <besenwesen> is it not possible to follow unwraps with a «where» block locally?
05:23:54 <Haskellfant> I don't quite understand what you mean by “following unwraps”
05:24:51 <moriarty> anybody here into organisational politics?
05:25:44 <hellertime> @pl l !! (fromEnum i)
05:25:44 <lambdabot> l !! fromEnum i
05:25:56 <besenwesen> say i do «x <- foo baz», i wanted to follow that up with a «where baz = …» nistead of prepending «let baz = »
05:26:48 <Haskellfant> ah ok, afaik where belongs to a function while let belongs to an expression so you could define that in a where for the function, but not directly after that
05:31:08 <besenwesen> ah, thanks, that must be it. i guess i’ll have to use let then, because some expressions are only set within the do clause
05:33:49 <PCChris> besenwesen: you mean like http://lpaste.net/6147088607149555712?
05:35:33 <zwer_b> noit very inefficient but if we were just golfing..
05:35:37 <zwer_b> getUpToOrLess n = last . takeWhile ((<=n).length.unwords) . inits
05:36:04 <Bubblegum> Hello, does anyone know if the Haskore-Vintage Package is included into the Haskell Platform or where I can find instructions to install it on winBlows?
05:36:04 <besenwesen> i had this, but the interspesed let seemed a bit ugly http://lpaste.net/4033334535620919296
05:36:31 <besenwesen> the one in between all the «unwraps»
05:37:58 <Sorella> Haskellfant: oh, I always thought where was an expression-level syntax, but I just glanced through the '98 report and it seems to be a special case in a few constructs
05:38:27 <besenwesen> the local «where» after the «let» seemed to work
05:38:55 <besenwesen> so that must be a special case then
05:40:22 <PCChris> besenwesen: can do something like http://lpaste.net/4033334535620919296
05:41:42 <besenwesen> yea, that looks a bit nicer
05:41:54 <Sorella> besenwesen: I guess it's because of the layout-based syntax, so `where` happens in several places in Haskell (like «module A where», «class A where», ...). Purr uses bracket-delimited blocks, so both «let» and «where» are expression-level syntaxes.
05:42:20 <PCChris> besenwesen: see http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html for details on how `where` desugars
05:42:36 <PCChris> besenwesen: or at least how you can think about it...
05:43:20 <besenwesen> looks like a useful overview, thanks
05:43:31 <besenwesen> the wiki had something related, iirc
06:13:28 * hackagebot structural-induction 0.1.2 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.1.2 (DanRosen)
06:30:29 <isocliff_> can someone tell me what the vertical bar represents in "class Monad m => MonadState s m | m -> s where"
06:31:41 <RchrdB> isocliff_: it's a functional dependency.
06:32:16 <RchrdB> isocliff_: it means that, when you have a value of type "MonadState s m", s is determined by m.
06:32:44 <isocliff_> I see, thanks
06:33:40 <RchrdB> isocliff_: it matches up with the MonadState instance for the StateT transformer, which looks like: instance Monad m => MonadState s (StateT s m) where ...
06:34:04 <RchrdB> so "s" is determined by "StateT s m"
06:35:15 <RchrdB> isocliff_: sorry if I'm not explaining this well, fundeps are a little subtle and I've not used them *in anger* much.
06:35:35 <isocliff_> Yeah, thats fine, you gave me just what I needed to find more
06:35:43 <RchrdB> Yay \o/
06:35:58 <isocliff_> Its the monad transformers Ive been reading about and that small bit of syntax threw me off
06:36:33 <isocliff_> but its much easier to find documentation for "functional dependencies" than for "|" :)
06:36:52 <isocliff_> so many thanks, really :)
06:38:31 * hackagebot pretty-compact 1.0 - Pretty-printing library  http://hackage.haskell.org/package/pretty-compact-1.0 (JeanPhilippeBernardy)
06:41:47 <joneshf-laptop> I'm working with data files from https://archive.ics.uci.edu/ml/datasets.html lots(all?) of these are space separated, what's the most robust way to read in these files?
06:41:56 <joneshf-laptop> parsec doesn't like empty files at the end
06:42:00 <joneshf-laptop> forme anyway
06:42:24 <joneshf-laptop> is there something like a csv parser that can take different delimiters?
06:42:30 <joneshf-laptop> ala `cut`
06:43:09 <mauketwork> you mean this? https://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data
06:43:32 * hackagebot opensoundcontrol-ht 0.2 - Haskell OpenSoundControl utilities  http://hackage.haskell.org/package/opensoundcontrol-ht-0.2 (HenningThielemann)
06:43:45 <joneshf-laptop> sure
06:43:52 <joneshf-laptop> but some of them are space separated
06:43:54 <joneshf-laptop> https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data
06:44:34 <mauketwork> ah, trickier
06:44:52 <mauketwork> the first separators are several spaces, but the last one is a tab followed by a quoted field
06:45:02 <joneshf-laptop> yeah
06:45:05 <joneshf-laptop> it's terrible
06:45:48 <mmmm_> joneshf-laptop: What goes wrong with parsec?
06:46:41 <joneshf-laptop> something about the last line being blank, lemme throw a paste together
06:47:02 <mauketwork> you could just filter out empty lines
06:47:14 <mauketwork> filter (not . null) . lines
06:50:59 <joneshf-laptop> https://gist.github.com/joneshf/2c1926721ba7b3099eb5
06:51:56 <jonasss> Hi, can anybody tell me how i change: getStdRandom (randomR (x,y)) to make use of a seed? and i think i also need the mkStdGen
06:53:33 * hackagebot casadi-bindings 2.1.3.1 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.1.3.1 (GregHorn)
06:59:10 <albeit> joneshf-laptop: Just a guess, but your checking for noneOf " \n", what if a line is just "\n" without the spaec?
07:00:41 <joneshf-laptop> albeit, i had a feeling this was what was messing me up, but I'm not sure i understand `noneOf` then
07:00:41 <indiagreen> albeit: «noneOf " \n"» looks for a character which is neither “ ” nor “\n”
07:01:09 <albeit> joneshf-laptop, indiagreen: Ah not familiar enough with parsec, nevermind then!
07:04:31 <zwer_b> jonasss you would usually do something like this:  let (value,newGen) = randomR (x,y) gen.  and then give randomR newGen on the next call
07:05:00 <zwer_b> and you can get initial seed either with mkStdGen or getStdGen
07:12:18 <jonasss> hmm i don't get it :/ i just want to generate random numbers in a while loop, but i need to use a seed for the generator.. Any chance you can lpaste an example?
07:13:35 * hackagebot supercollider-ht 0.2 - Haskell SuperCollider utilities  http://hackage.haskell.org/package/supercollider-ht-0.2 (HenningThielemann)
07:13:40 <zwer_b> jonasss random* functions return a pseudo-random value and a new seed that you must pass on the next call
07:14:24 <zwer_b> except the random functions that end in IO, but they, as the name suggest, work in IO
07:15:23 <mauketwork> :t forever (randomIO >>= print)
07:15:24 <lambdabot> IO b
07:16:17 <jonasss> hmm let me try
07:20:10 <clrnd> @hoogle [Maybe a] -> [a]
07:20:13 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:20:13 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:20:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:23:09 <clrnd> @hoogle Show a => [a] -> String
07:23:11 <lambdabot> Prelude show :: Show a => a -> String
07:23:12 <lambdabot> Text.Show show :: Show a => a -> String
07:23:12 <lambdabot> Test.QuickCheck.Text showErr :: Show a => a -> String
07:23:27 <clrnd> @hoogle Show a => [a] -> Char -> String
07:23:28 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:23:28 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:23:28 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:23:36 * hackagebot haskore-supercollider 0.2 - Haskore back-end for SuperCollider  http://hackage.haskell.org/package/haskore-supercollider-0.2 (HenningThielemann)
07:25:41 <mauketwork> > intercalate ";" (map show [1 .. 5])
07:25:43 <lambdabot>  "1;2;3;4;5"
07:25:52 <bernalex> I've been doing "p <- runCommand c ; waiForProcess p >>= exitWith". now I have a list of commands that I want to run. how should I be doing that?
07:26:00 <bernalex> forM_ cs $ \c -> do... something
07:27:57 <mauketwork> in parallel or serially?
07:28:01 <bernalex> mauketwork: serially
07:28:22 <mauketwork> what do you want to do with the exit statuses?
07:28:37 * hackagebot pagerduty 0.0.0 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.0 (BrendanHay)
07:28:46 <bernalex> mauketwork: if failure: print "omg wow such fail", if nothing: nothing.
07:29:15 <clrnd> mauketwork, how did you know I had a [Int]? are you NSA'ing me?
07:29:27 <mauketwork> clrnd: I wasn't using a [Int]
07:29:39 <clrnd> :t [1..5]
07:29:40 <lambdabot> (Num t, Enum t) => [t]
07:29:45 <mauketwork> bernalex: so ... don't you already have all the pieces?
07:29:54 <mauketwork> clrnd: it was an [Integer] in my example :-)
07:30:00 <bernalex> mauketwork: I'm wondering how I should be doing it
07:30:56 <bernalex> mauketwork: should I just be using waitForProcess in a forM_?
07:31:11 <mauketwork> forM_ cs $ \c -> runCommand c >>= waitForProcess >>= doStuff
07:31:35 <mauketwork> where doStuff ExitFailure{} = putStr "omg wow such fail\n"; doStuff ExitSuccess{} = return ()
07:33:37 * hackagebot thread-local-storage 0.1.0.3 - Several options for thread-local-storage (TLS) in Haskell.  http://hackage.haskell.org/package/thread-local-storage-0.1.0.3 (RyanNewton)
07:34:45 <dfeuer_> edwardk: I think I was all wrong about traverse_. I think (*>) is actually inherently biased, and I think the underlying cause is the "homomorphism" law for applicative functors.
07:35:28 <bernalex> mauketwork: thanks.
07:37:35 <zennist> how to write reverse' in the most succinct way?
07:37:51 <zennist> I tried foldl ((:) . flip) [] but it's not working
07:38:06 <mauketwork> is reverse' the same as reverse?
07:38:18 <zennist> yep just trying to reimplement
07:38:22 <mauketwork> flip (:)
07:38:35 <bernalex> mauketwork: omg. so. I pretty much had what you wrote. the reason I was asking was because I thought I was doing something wrong that made the process misbehave. what I was doing wrong was... I forgot to escape some characters in the command string building... -_-
07:38:35 <bartavelle> :t (:) . flip
07:38:37 <lambdabot> (a -> b -> c) -> [b -> a -> c] -> [b -> a -> c]
07:39:13 <zennist> mauketwork: that totally fixed my problem
07:39:23 <mauketwork> :t flip (:)
07:39:25 <lambdabot> [a] -> a -> [a]
07:39:39 <zennist> although I'm still having trouble understanding what (:) . flip does...
07:39:41 <EvanR> bernalex: shell escape all the things
07:39:50 <mauketwork> @unpl (:) . flip
07:39:50 <lambdabot> (\ f -> ((:)) (\ b c -> f c b))
07:39:56 <mauketwork> ok then
07:40:08 <mauketwork> let's do this manually
07:40:30 <mauketwork> (:) . flip = \x -> (:) (flip x)  -- by the definition of (.)
07:40:50 <mauketwork> or let's rename to \f -> (:) (flip f)
07:41:01 <mauketwork> then flip f expands to \x y -> f y x
07:41:18 <mauketwork> \f -> (:) (\x y -> f y x)
07:41:45 <mauketwork> then we eta expand to use (:) infix
07:41:53 <mauketwork> \f rest -> (\x y -> f y x) : rest
07:42:23 <mauketwork> hmm, you could use that with foldr
07:42:26 <zennist> I see; very clear. thank you
07:42:31 <mauketwork> and then I think you'd get (map flip)
07:42:49 <zennist> map flip?
07:43:07 <mauketwork> yeah, a transformation of a list of functions
07:43:16 <joe9> johnw: you around?
07:43:29 <mauketwork> :t map flip [(+), (-), (/)]
07:43:30 <lambdabot> Fractional c => [c -> c -> c]
07:43:31 <zennist> if I use foldr I'd be building the list from the end; meaning that I repeatedly cut off the last element and append that to the head of the new list -> essentially gives back the same list
07:43:38 * hackagebot supercollider-ht 0.2.0.1 - Haskell SuperCollider utilities  http://hackage.haskell.org/package/supercollider-ht-0.2.0.1 (HenningThielemann)
07:43:51 <mauketwork> :t foldr ((:) . flip) [] [(+), (-), (/)]
07:43:53 <lambdabot> Fractional c => [c -> c -> c]
07:44:01 <mauketwork> @src map
07:44:01 <lambdabot> map _ []     = []
07:44:01 <lambdabot> map f (x:xs) = f x : map f xs
07:44:37 <mauketwork> > foldr ((:) . f) [] [1, 2, 3] :: [Expr]
07:44:39 <lambdabot>  [f 1,f 2,f 3]
07:44:48 <mauketwork> yeah, map f = foldr ((:) . f) []
07:45:40 <zennist> oh I see
07:46:00 <zennist> didn't get what you meant at first :)
07:47:09 <zennist> is there a function that eats the first argument and returns the second? \_ x -> x
07:47:21 <mauketwork> :t flip foldr [] . (.) (:)
07:47:22 <lambdabot> (a -> t) -> [a] -> [t]
07:47:23 <exio4> flip const?
07:47:31 <mauketwork> flip const == const id
07:47:56 <mauketwork> @pl \_ x -> x
07:47:56 <lambdabot> const id
07:48:19 <exio4> that works too
07:51:56 <Taneb> @type flip const const
07:51:57 <lambdabot> c -> c
07:52:24 <mauketwork> :t fmap fix return
07:52:25 <lambdabot> b -> b
07:52:57 <EvanR> :t fix return fmap
07:52:59 <lambdabot>     Occurs check: cannot construct the infinite type:
07:52:59 <lambdabot>       t ~ ((a0 -> b0) -> f0 a0 -> f0 b0) -> t
07:52:59 <lambdabot>     Expected type: (((a0 -> b0) -> f0 a0 -> f0 b0) -> t)
07:53:00 <mauketwork> :t ap const ap
07:53:02 <lambdabot> Monad m => m (a -> b) -> m (a -> b)
07:53:07 <EvanR> :t fix fmap return
07:53:08 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a0 -> b
07:53:09 <lambdabot>     Expected type: ((a0 -> a0 -> a0) -> b) -> (a0 -> a0 -> a0) -> b
07:53:09 <lambdabot>       Actual type: ((a0 -> a0 -> a0) -> b)
07:53:26 <mauketwork> :t ap const const
07:53:27 <lambdabot> a -> a
07:55:54 <Cale> dfeuer_: you were looking for me?
07:58:21 <dfeuer_> Cale: I was, but I think I might've figured it out. I'm drafting an email about that now; I'll send you a copy if I finish it, or ask again here if I get stuck.
07:58:40 * hackagebot haskore-realtime 0.2 - Routines for realtime playback of Haskore songs  http://hackage.haskell.org/package/haskore-realtime-0.2 (HenningThielemann)
08:00:31 <chpatrick> hiya
08:00:52 <chpatrick> is there a good reason kind signatures aren't scoped to data declarations?
08:01:46 <chpatrick> eg. data Foo (kp :: k) where Foo :: (a :: k) -> Foo
08:02:03 <chpatrick> I believe the k in a :: k is distinct from the one in kp :: k
08:02:13 <chpatrick> I can make it work with a typeclass but I was wondering if that's the right way
08:05:07 <jkarni> sorry I've not been contributing much today - I feel like I need to get back to isourcerer for a bit, as fun as this is
08:05:18 <jkarni> ugh, wrong window
08:07:33 <k00mi> chpatrick: why would they be? type variables aren't scoped like that either and I don't see a reason for them to be
08:07:45 <k00mi> chpatrick: also what you wrote is wrong in several ways
08:08:19 <k00mi> (->) has kind * -> *
08:09:03 <chpatrick> what do you mean they aren't scoped like that?
08:09:04 <k00mi> in your Foo data constructor it would be k -> (k' -> *)
08:09:18 <c_wraith> k00mi: err, no it doesn't.  :P
08:09:24 <c_wraith> @kind (->)
08:09:25 <lambdabot> * -> * -> *
08:09:32 <k00mi> woops, right :)
08:10:00 <chpatrick> data Foo a where Foo :: a -> Foo
08:10:12 <chpatrick> a is the a as in Foo a
08:10:21 <chpatrick> so why doesn't that hold for kinds?
08:11:02 <chpatrick> for the other one I meant: data Foo (kp :: k) where Foo :: (a :: k) -> Foo kp
08:11:22 <chpatrick> if you do
08:11:29 <chpatrick> class SameKind (a :: k) (b :: k)
08:11:31 <k00mi> no it isn't and that is again a kind error
08:11:33 <chpatrick> instance SameKind a b
08:12:01 <chpatrick> data Foo (pk :: k) = Foo :: SameKind pk a => a -> Foo pk
08:12:02 <chpatrick> then it works
08:12:23 <chpatrick> ok, Proxy a instead of a
08:13:27 <chpatrick> the type variables you declare for a data type are scoped to the constructors
08:13:28 <bam365> if I have (Bounded t, Enum t) => t, is there some abbreviation for [minBound .. maxBound] :: [t] ?
08:13:28 <k00mi> you can get the behavior you want like this: data Foo (kp :: k) where Foo :: Proxy (a :: k) -> Foo (kp :: k)
08:15:01 <chpatrick> ok, but why isn't k in scope for the constructors the way type variables are?
08:15:33 <k00mi> again, it isn't for type variables either
08:16:14 <k00mi> there is no need for them to be and it may or may not break things, I don't know
08:16:21 <chpatrick> ah I see
08:25:17 <belst> hey guys, is there a short way to use GHC.Exts.groupWith without it sorting the list?
08:26:31 <belst> :t GHC.Exts.groupWith
08:26:32 <lambdabot> Ord b => (a -> b) -> [a] -> [[a]]
08:28:43 * hackagebot github-backup 1.20141031 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20141031 (JoeyHess)
08:32:17 <NemesisD> does anyone know if it would be possible/worthwhile to attempt this: say you have a QC property that is parametric to a typeclass, seems like it could be valuable to find out what concrete types inhabit those constraints + Arbitrary and to generate tests thta use that generic property
08:45:21 <mkscrg> is there a built-in way to "depromote" a promoted type? e.g. given  data Foo = Bar | Baz   i'm looking for something like   toValue :: Proxy (f :: Foo) -> Foo
08:52:53 <yesthisisuser> If I create a Haskell thread using forkIO, it should be safe to pass a file descriptor to it, or? I.e., I can assume that the lightweight thread resides in the same process space.
08:56:34 <EvanR> yesthisisuser: a file descriptor is just a number
08:58:00 <EvanR> also, its safe to use the fd for something in different threads, though reading or writing from two or more places at the same time will cause interleaved results
09:00:01 <yesthisisuser> EvanR: thanks
09:01:52 <yesthisisuser> my understanding is that the OS maintains a process-specific file table, where fds works as indices. so since these are just "green threads" there shouldn't be any problem with this approach
09:02:18 <carter> yeah
09:02:23 <carter> unless you use forkPRocess :)
09:02:26 <carter> whcih you warent
09:03:08 <EvanR> yesthisisuser: this would work if they were pthreads, os threads too
09:03:21 <EvanR> forkOS
09:04:15 <dfeuer_> Cale, I sent the message. I'm hoping I didn't make any massive mistakes there.
09:04:31 <EvanR> which reminds me, if you close files, you will be reused fds, so theres possible bugs if you dont forget any fds when you close / disconnect
09:04:39 <EvanR> you will get*
09:05:04 <clrnd> if Python is a parallelism atheist, Haskell is like a Jehova Witness?
09:06:14 <yesthisisuser> i should say that i am really referring to sockets here but it shouldn't make any difference i suppose
09:06:21 <EvanR> no it doesnt
09:06:46 <EvanR> python is a parallelism atheist?
09:08:02 <EvanR> yesthisisuser: its a common pattern to forkIO with a socket fd to manage just that connection, communicating to other stuff on input, and disappearing when the sockets is closed or crashed
09:12:45 <yesthisisuser> I think I have inherited some negative bias towards anything threads from programming in C++, but I am starting to change my mind
09:15:02 <Guest19017> I'm having trouble implementing the example from https://www.fpcomplete.com/school/advanced-haskell/persistent-in-detail/existing-database
09:15:25 <Guest19017> I get the error "No instance for (PersistFieldSql Text)" when loading in ghci
09:15:34 <bernalex> I want to use a sound file in my project. how am I supposed to do that properly in haskell with cabal? I want to have a .wav-file in a data dir.
09:16:00 <Guest19017> which doesn't make sense to me as I have installed persistent and persistent-postgres
09:16:28 <Guest19017> And I can see an instance of PersistFieldSql for Text in http://hackage.haskell.org/package/persistent-2.1/docs/Database-Persist-Sql.html#t:PersistFieldSql
09:18:42 <EvanR> yesthisisuser: yeah its hellish in pthreads, doubly so in c++
09:19:18 <Guest19017> bernalex: http://neilmitchell.blogspot.co.uk/2008/02/adding-data-files-using-cabal.html might help you
09:19:29 <bernalex> Guest19017: that's what I'm looking at. found it a minute ago. :-]
09:20:17 <Guest19017> bernalex: hope it works for you - sounds like it could be a bit complicated
09:24:14 <drdanmaku> if i want to write a simple interpreter in haskell and expose a map data structure to interpreted code, is implementing Ord for my value type and using Data.Map the best approach? it feels kind of awkward to implement Ord since there's no natural ordering on values
09:25:47 <josephle> hmm? I thought the Ord restriction was on keys
09:25:48 <EvanR> in a dynamically typed system where anything can be a key in a map, you gotta order them or hash them or something
09:26:05 <EvanR> across the board, even across types
09:26:43 <superfunc> Could anyone link me to an implementation of variadic generics in haskell?
09:26:54 <drdanmaku> yes, it would be dynamically typed. i guess Ord is the way to go
09:27:51 <codygman> Is there a way to debug http-client https requests with wireshark? For example with firefox you can use NSS and SSLKEYLOGFILE.
09:27:55 <EvanR> yeah Maps are good default for a dictionary type
09:27:57 <bernalex> Guest19017: hm. works with cabal run, but not with running the file in dist/build/etc.
09:28:08 <bernalex> Cannot open file '/home/alexander/git/hsay/.cabal-sandbox/share/x86_64-linux-ghc-7.8.3/hsay-0.1.0.0/data/flip.wav': No such file or directory
09:28:43 <EvanR> drdanmaku: also, deriving (Ord) might work for your type, if its made up of more basic types supporting Ord
09:28:53 <EvanR> if you dont care about the specifics
09:30:21 <drdanmaku> EvanR: hm, in fact i was able to derive Ord just now. thanks for that tip :]
09:31:09 <yesthisisuser> If I deconstruct a ByteString to a ForeignPtr I get a triple (ptr, offset, length)? What is the rationale behind the "offset"? The documentation for Data.ByteString.Internal does not give much information.
09:31:43 <yesthisisuser> Does the ByteString start at the memory address pointed to by the Ptr + the offset or?
09:32:18 <EvanR> yeah
09:32:50 <EvanR> you dont typically deconstruct a bytestring though
09:33:34 <yesthisisuser> But if I want to interact with the underlying data in C using FFI
09:33:56 <michi7x7> hi guys
09:34:06 <eacameron> what's the common name for `fmap fmap fmap`?
09:34:19 <vanila> :t fmap fmap fmap
09:34:20 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:34:30 <vanila> I don't think this has a definition
09:34:32 <EvanR> theres probably a function you can use to pass the bytestring to C without having to muck around with its internals
09:35:02 <eacameron> vanila: any suggestions as to a non-surprising name for it?
09:35:20 <eacameron> so far I've come up with <$>>
09:35:26 <josephle> ffmap
09:35:37 <josephle> just need more f's
09:35:37 <eacameron> josephle: not bad
09:36:36 <michi7x7> eacameron: what do you use `fmap fmap fmap` for?
09:36:51 <michi7x7> :t (fmap fmap fmap)
09:36:52 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:36:59 <michi7x7> :t (fmap , fmap . fmap)
09:37:00 <lambdabot> (Functor f2, Functor f1, Functor f) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 (f2 a1) -> f1 (f2 b1))
09:37:03 <michi7x7> :t (fmap . fmap . fmap)
09:37:05 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:37:09 <yesthisisuser> EvanR: I am not sure what "deconstruct" means in the documentation. I am looking at "toForeignPtr" and it gives me a (ForeignPtr Word8, Int, Int)	(ptr, offset, length). But you are probably right, there should be another way...
09:37:29 <EvanR> yesthisisuser: perhaps try useAsCString
09:37:45 <EvanR> im not sure
09:37:59 <eacameron> michi7x7: concat `ffmap` sequence [listProducers]    -- Run a bunch of IO [a] actions and concat the results into one IO [a] action
09:39:03 <yesthisisuser> EvanR: useAsCString would work, only it makes a copy of the data..  O(n) time complexity :(
09:39:23 <eacameron> michi7x7: I'm not sure if you're asking because you think I'm abnormal, or if you're unaware of the pattern.  I couldn't tell you if I'm abnormal or not. ;)
09:39:44 <EvanR> yesthisisuser: right, but you cant by default use the pointer to a bytestring data from C without first making sure its not going to be moved by the GC, which is more complex
09:39:51 <EvanR> but its possible
09:40:12 <michi7x7> eacameron: no I'm just generally looking for pattern one could use in Haskell
09:41:05 <michi7x7> I remember to use fmap f <$> ... once, but fmap fmap fmap looks odd to me ^^
09:42:29 <yesthisisuser> EvanR: you are right of course. I didn't think of that
09:42:56 <michi7x7> yesthisisuser: there is useAsCString, no?
09:43:28 <EvanR> i mentioned that, which makes a "temporary" copy of the data
09:43:38 <michi7x7> EvanR: sorry, just joined
09:44:14 <ski> @type fmap . fmap
09:44:15 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:44:34 <ski> eacameron ^
09:44:52 <pjdelport> I like <$$> and <**> for that (except for the fact that <**> is already taken for reverse application)
09:45:16 <josephle> <$$> is a good one
09:45:43 <eacameron> pjdelport: Yeah, I've wanted to use that before, except for the very reason you gave
09:46:09 <eacameron> honestly, <**> doesn't make sense to me. >*< would be better or something like that
09:46:11 * ski would prefer `<*>' being named `<$>' ..
09:46:16 <EvanR> yesthisisuser: i think in order to use the thing directly from C, you need to use a mutable unboxed array of some sort, one of which resides in a fixed position, and requires IO to do anything with from haskell
09:46:19 * ski nods to eacameron
09:46:48 <pjdelport> I have some pet operators, too: (·) = (<*>); ($·) = (<$>); (·>) = (*>); (<·) = (<*)
09:47:09 <Fuuzetsu> if unicode is allowed then why not go all out
09:47:12 <RchrdB> pjdelport: the last one almost looks like a kirby smiley
09:47:22 <Fuuzetsu> also there's unicode for <*> already
09:47:24 <Fuuzetsu> ⊛
09:47:26 <EvanR> yesthisisuser: because, C code having direct access to a normal bytestring would be bad for referential transparency
09:47:36 <pjdelport> That gives you something almost as readable as idiom brackets: f $· x · y · z
09:47:42 <EvanR> bytestrings are supposed to be immutable
09:47:47 <eacameron> Fuuzetsu: that's just brimming with added clarity ;)
09:47:52 <yesthisisuser> EvanR: yes it could get messy
09:47:52 <Fuuzetsu> http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.4/docs/Control-Applicative-Unicode.html
09:48:35 <pjdelport> And then of course you can have: (··) = liftA2 (<*>); ($··) = (<$>) . (<$>)
09:48:53 <pjdelport> So the two-level deep version just becomes: f $·· x ·· y ·· z
09:49:29 <bernalex> is there a function like my diff somewhere?
09:49:37 <bernalex> diff (x:xs) (y:ys) | x == y = diff xs ys | x /= y = ys
09:50:24 <ski> > stripPrefix "abc" "abcde"  -- bernalex ?
09:50:25 <pjdelport> And there's also (·<) = flip (<$>); (>·) = (<*>), for the operator-lifting hack: foo ·<(+)>· bar
09:50:26 <lambdabot>  Just "de"
09:50:40 <bernalex> ski: yeah. thanks.
09:51:06 <eacameron> Fuuzetsu: That package is awesome. I'd love to see the faces of my colleagues if I started using it. Still, it would be neat
09:51:21 <vanila> what sort of comutation can you do with type class instances?
09:51:34 <vanila> i thought that you could embed prolog in it , but it seems like they dont backtrack
09:51:47 <bernalex> ski: oh. urk.
09:51:57 <Welkin> uruk!
09:52:03 <bernalex> ski: I also want diff _  []                  = []
09:52:05 <bernalex> and diff [] ys                  = ys
09:54:50 <Hijiri> Is there a popular data structure for unordered collections?
09:54:51 <Hijiri> with decent lookup
09:55:00 <josephle> vanila: I recall there was a paper called "Fun with Functional Dependencies" that has an intro into this question
09:55:09 <ski> @type \prefix list -> fromMaybe [] (stripPrefix prefix list)
09:55:11 <lambdabot> Eq t => [t] -> [t] -> [t]
09:55:18 <ski> bernalex : would that work ?
09:55:21 <vanila> ill have a look at that, ty
09:55:22 <pjdelport> @hackage unordered-containers
09:55:22 <lambdabot> http://hackage.haskell.org/package/unordered-containers
09:55:28 <dmj`> Hijiri: HashMap ?
09:55:30 <mkscrg> Hijiri: try HashSet?
09:55:33 <pjdelport> Hijiri: Those?
09:55:38 <bernalex> ski: yeah or just using the listt monad and matching on Just, I guess.
09:55:42 <Hijiri> let me check, thanks
09:55:51 <ski> vanila : no backtracking, right
09:58:41 <Hijiri> what if I just wanted to have a group of things that might have duplicates?
09:58:49 <Hijiri> I guess I could have a map from values to counts
09:58:55 <Hijiri> and that would sort of work
10:00:50 <pjdelport> @hackage multiset
10:00:51 <lambdabot> http://hackage.haskell.org/package/multiset
10:01:10 <pjdelport> There's that and a few variations, too, if you don't want to roll your own bag / multiset.
10:01:43 <pjdelport> (A multiset is a set like you described, where you can contain multiple elements.)
10:03:14 <michi7x7> I have an parallized algorithm-related question for you... I have this N-Queens solver (which performs fairly well), but I'm having trouble making it pseq-able: https://gist.github.com/michi7x7/777da6cec047c4f60e04#file-nqueens-hs-L46
10:04:17 <michi7x7> the problem is, that if I use parList on the first level, it has to compute the length of the result before spawning the sparks (which results in thousands of dud's...)
10:04:54 <michi7x7> In other words... I didn't quite get how to use those strategies
10:07:57 <Hijiri> thanks pj
10:12:14 <DarkCthulhu> Why does my map statement complain? http://pastie.org/9688130
10:13:01 <DarkCthulhu> Couldn't match expected type `ReaderT Gamma IO t0' with actual type `[b0]'
10:15:09 <ski> DarkCthulhu : try replacing `types <- map (\ (name, term) -> (name, typeOf term)) fields' by `types <- mapM (\(name, term) -> do typ <- typeOf term; return (name,typ)) fields' ?
10:15:46 <DarkCthulhu> ski, trying that. What is wrong with it in its current form?
10:16:03 <DarkCthulhu> Does it also need a liftIO at some point?
10:16:57 <ski> DarkCthulhu : `map' takes a function of type `a -> b', and converts ("lifts") it into a function of type `[a] -> [b]'. in your case you want something like `mapM', which takes a function of type `a -> m b', and lifts it into a function of type `[a] -> m [b]', where `m' in your case is `ReaderT Gamma IO'
10:17:20 <DarkCthulhu> ahhh
10:17:41 <ski> DarkCthulhu : you only need `liftIO' if you want to perform some I/O effects as part of the overall effects of the type inference here
10:18:27 <ski> DarkCthulhu : also, instead of using `mapM', you could use its flipped form, `forM' :
10:18:30 <ski>   typeOf (TmRecord fields) = do
10:18:40 <DarkCthulhu> ski, I see..
10:18:45 <ski>     forM fields $ \(name,term) -> do
10:18:56 <ski>       typ <- typeOf term;
10:19:03 <ski>       return (name,typ)
10:19:16 <ski>     return (TyRecord types)
10:19:22 <DarkCthulhu> I can't get it to compile in the form you suggested. Complaining about some misplaced return. Maybe I should wrap the inner do.. block in parens or something?
10:19:29 <ski> (oh, you need `types <- ' before the `forM' of course)
10:19:52 <ski> DarkCthulhu : i wrapped it in brackets above, yes
10:24:14 <DarkCthulhu> ski, ah.. that does compile. Something seems a bit off though and I'm getting reports of patterns for typeof being non-exhaustive. Looking into it
10:25:41 <ski> @lpaste it ?
10:25:42 <lambdabot> Haskell pastebin: http://lpaste.net/
10:27:15 <DarkCthulhu> ski, fixed it. I was using the String type as key in the record but hadn't defined rules in the typechecker for it. My bad
10:27:38 * ski doesn't follow
10:27:49 <DarkCthulhu> s/key/value
10:28:13 <DarkCthulhu> ski, If you're around, I'll finish some more of it on my own and ask you if I get stuck due to some monadic magic.
10:28:56 <ski> hm, i might not be aroud later
10:29:02 <ski> s/aroud/around/
10:33:47 <DarkCthulhu> ski, Can I return a long string using a map statement? I'm trying to pretty-print all terms within the []
10:34:06 <DarkCthulhu> I think that should be another primitive. fold?
10:34:08 <DarkCthulhu> scan?
10:34:55 <ski> DarkCthulhu : i'm not quite sure what you want to do ..
10:35:40 <ski> DarkCthulhu : do you want to do this within this type-checking code (iow within this `ReaderT Gamma IO' monad) ?
10:35:53 <pjdelport> DarkCthulhu: folding, or concatMap / =<< ?
10:35:53 <DarkCthulhu> ski, No, separate function. I'll post code. 1 sec
10:36:08 <EvanR> why cant you write a "y combinator" in haskell, exactly?
10:36:09 <DarkCthulhu> pjdelport, Folding sounds right to me
10:36:23 <ski> EvanR : you can, if you use a recursive type
10:36:26 <pjdelport> > show =<< ["foo","bar"]
10:36:28 <lambdabot>  "\"foo\"\"bar\""
10:36:51 <EvanR> is the same true for simply typed lambda calculus?
10:37:40 <DarkCthulhu> ski, http://lpaste.net/7883957541812568064 . I've just added placeholders for TyRecord and TmRecord
10:37:41 <EvanR> i guess my question was about the direct way, without data
10:38:24 <joneshf-laptop> how can i get cabal to list more versions of a specific package? it just says: Versions installed: 0.5.5, 0.5.6, 0.5.6.2, 0.5.7.1 (and 3 others)
10:38:36 <joneshf-laptop> or just list them all
10:39:15 <joneshf-laptop> verbosity doesn't seem to change anything
10:39:25 <int-e> joneshf-laptop: how about resorting to ghc-pkg list package-name?
10:39:50 <joneshf-laptop> int-e, jawesome! thanks that works
10:40:25 <ski> EvanR : something like `newtype Santa a = Claus {rudolf :: Santa a -> a}; y :: (a -> a) -> a; y f = g (Claus g) where g h = f (rudolf h h)' iirc
10:40:56 <DarkCthulhu> ski, On the face of it, it looks like foldl should suffice. I'm trying it now
10:40:57 <ski> EvanR : what does "the same" mean here ?
10:41:17 <EvanR> you can do it but it requires a recursive type
10:45:24 <ski> DarkCthulhu : btw, why not a separate `PP.text ":"' ?
10:45:52 <DarkCthulhu> ski, separate :?
10:45:56 <DarkCthulhu> I don't understand
10:46:20 <ski> DarkCthulhu : instead of `PP.text (x++":")', something like `PP.text x <> PP.text ":"'
10:47:13 <ski> DarkCthulhu : also, is there a point in having `unit' be separate from a record with no fields ?
10:48:24 <DarkCthulhu> ski, the typing rules I have for extending STLC don't have any such rule stating that an empty record is unit.
10:48:42 <DarkCthulhu> ski, But I can see how logically what you say is right
10:49:20 <DarkCthulhu> ski, As for the other one, I should probably break that up into x and : separately
10:49:22 <DarkCthulhu> ty
10:49:49 <nschoe> Hey guys, is there a way I can have something equivlent than toChunks (http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#v:toChunks), but in which I can choose the size of the chunks ?
10:49:53 <pharpend> Anyone know how to install leksah
10:50:17 <pharpend> I'm currently getting an error installing webkitgtk
10:50:53 <lpaste> pharpend pasted “webkitgtk3 error” at http://lpaste.net/113534
10:51:11 <nschoe> pharpend, tried with cabal ?
10:51:35 <pharpend> nschoe: yes, tried cabal install leksah, got some error about webkitgtk3
10:51:42 <pharpend> tried cabal install webkitgtk3, got that error
10:51:54 <ski> DarkCthulhu : you might also consider adding a precedence level argument to `pp'
10:52:06 <pharpend> If I'm correct, webkitgtk is complaining that webkitgtk is not installed?
10:52:13 <pharpend> chicken and the egg problem
10:52:18 <nschoe> pharpend, yes I've just seen your lpaste. Hum... any luck while trying to install webkitgtk separately ?
10:52:24 <ski> DarkCthulhu : it might save you most of the deep matching to insert brackets at necessary places
10:52:30 <vanila> hm
10:52:37 <DarkCthulhu> ski, I see
10:52:39 <pharpend> nschoe: I have the library on my system, installed it through my distro's package manager
10:52:41 <vanila> so if I managed to analyze a prolog relation to find that it was deterministic in some mode
10:52:51 <vanila> I could use typeclasses and fundeps to implement it?
10:53:15 <ski> DarkCthulhu : you know how the precedence argument to `showsPrec' and `readsPrec' works ?
10:53:37 <ski> vanila : possibly
10:53:47 <DarkCthulhu> ski, I'm still struggling with TmRecord; trying to turn [("typ1", Term1), ("typ2", Term2), ...]  into the String "{typ1=Term1, typ2=Term2"
10:53:53 <DarkCthulhu> ski, No, I am not familiar with that
10:53:58 <nschoe> pharpend, hum... sorry no idea then.
10:53:59 * hackagebot opensoundcontrol-ht 0.3 - Haskell OpenSoundControl utilities  http://hackage.haskell.org/package/opensoundcontrol-ht-0.3 (HenningThielemann)
10:54:01 * hackagebot supercollider-ht 0.3 - Haskell SuperCollider utilities  http://hackage.haskell.org/package/supercollider-ht-0.3 (HenningThielemann)
10:54:04 <nschoe> brb
10:54:14 <jfischoff> pharpend: you need to install WebKitGTK+
10:54:23 <jfischoff> not the haskell library
10:54:36 <ski> @type intersperse  -- might be useful, DarkCthulhu
10:54:38 <lambdabot> a -> [a] -> [a]
10:54:46 <jfischoff> and it needs to be in location cabal can find, or pass the lib directory to cabal
10:54:59 <DarkCthulhu> ski, Ah.. let me check that out
10:55:00 <ski> > intersperse ',' "abcd"
10:55:02 <lambdabot>  "a,b,c,d"
10:55:03 <ski> > intersperse ',' "a"
10:55:05 <lambdabot>  "a"
10:55:06 <ski> > intersperse ',' ""
10:55:06 <jfischoff> I forget the flag exactly extra-library-directories or something
10:55:07 <lambdabot>  ""
10:55:31 <lpaste> pharpend pasted “I have webkit-gtk installed” at http://lpaste.net/113535
10:55:57 <DarkCthulhu> ski, Hmm.. that is useful in inserting the commas, but I still need to do fst, snd and concatenate them with an =
10:56:02 <DarkCthulhu> on the tuple
10:56:17 <ski> DarkCthulhu : just `map' an appropriate function ?
10:56:36 <DarkCthulhu> ski, Normally, I'd go with writing a separate function to do it and iterate using head/tail, but I'm trying to do it more in a functional style
10:56:42 <benzrf> @let instance (Enum a, Bounded a, Eq b) => Eq (a -> b) where f == g = map f [minBound..maxBound] == map g [minBound..maxBound]
10:56:44 <DarkCthulhu> ski, hmm.. map first, then concat?
10:56:45 <lambdabot>  Defined.
10:56:48 <benzrf> hella hell
10:56:49 * ski would personally get rid of the spaces after the commas, and add spaces around the `='s ..
10:56:51 <benzrf> a
10:56:54 <ski> .. but that's just my taste
10:57:01 <pharpend> nschoe: did you see my paste?
10:57:02 <benzrf> > maxBound :: Int
10:57:03 <lambdabot>  9223372036854775807
10:57:09 <pharpend> ack
10:57:11 <benzrf> > maxBound :: Char
10:57:13 <lambdabot>  '\1114111'
10:57:16 <pharpend> jfischoff: did you see my paste?
10:57:25 <DarkCthulhu> ski, How do you normally debug? When it's a type error etc
10:57:26 <benzrf> :t under
10:57:27 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
10:57:33 <pharpend> jfischoff: it's in /usr/include, so I imagine cabal looked there
10:57:38 <benzrf> :t enum
10:57:39 <lambdabot> (Profunctor p, Functor f, Enum a) => p a (f a) -> p Int (f Int)
10:57:42 <ski> DarkCthulhu : generally, it's better to match on `x:xs' or `(a,b)' rather than to use `head',`tail' or `fst',`snd'
10:57:56 <ski> ("better" in the sense of it being more readable)
10:58:11 <lpaste> pharpend pasted “webkit-gtk files” at http://lpaste.net/113536
10:58:21 <benzrf> > ((over enum (+1)) :: Char -> Char) == (toEnum . (+1) . fromEnum)
10:58:21 <jfischoff> pharpend: I saw a paste. I need to head to standup. I would not assume cabal can find anything. I find I have to tell cabal where things are all the time
10:58:21 <ski> > not == id
10:58:23 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘GHC.Types.Int’
10:58:23 <lambdabot>  Expected type: Control.Lens.Setter.Setting
10:58:24 <lambdabot>                   (->) GHC.Types.Char GHC.Types.Char b0 b0
10:58:24 <lambdabot>    Actual type: (b0 -> Data.Functor.Identity.Identity b0)
10:58:24 <lambdabot>                 -> GHC.Types.Int -> Data.Functor.Identity.Identity GHC.Types.Int
10:58:25 <lambdabot>  can't find file: L.hs
10:58:39 <DarkCthulhu> ski, ah.. okay. I'll try map now.
10:58:40 <ski> > not == id
10:58:42 <lambdabot>  False
10:58:54 <pharpend> :t not
10:58:55 <lambdabot> Bool -> Bool
10:58:59 * hackagebot haskore-supercollider 0.3 - Haskore back-end for SuperCollider  http://hackage.haskell.org/package/haskore-supercollider-0.3 (HenningThielemann)
10:59:03 <benzrf> > ((under enum (+1)) :: Char -> Char) == (toEnum . (+1) . fromEnum)
10:59:06 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
10:59:06 <pharpend> there's an eq instance for Bool -> Bool ?
10:59:08 <benzrf> mfw
10:59:16 <ski> pharpend : see what benzrf said above
10:59:19 <benzrf> > ((under enum (+0)) :: Char -> Char) == (toEnum . (+0) . fromEnum)
10:59:22 <lambdabot>  True
10:59:24 <benzrf> cool.
11:00:23 <pharpend> :t (==)
11:00:24 <lambdabot> Eq a => a -> a -> Bool
11:00:40 <ski> DarkCthulhu : also, `head' and `tail' can lead to hard to find run-time errors, where pattern-matching could more directly pinpoint the failing case
11:01:14 <ski> benzrf : `(+0)' ?
11:01:23 <DarkCthulhu> ski, right. I'm currently using pattern matching to construct a helper function that I can pass to map, which will do the concatenation between the first and second elements of each tuple
11:01:26 <benzrf> ski: shut it
11:01:37 <benzrf> (+1) caused out-of-range
11:01:39 * ski smirks
11:01:57 <benzrf> > ((+1) :: Int -> Int) == ((subtract 1) . (+2))
11:02:01 <lambdabot>  mueval-core: Time limit exceeded
11:02:04 <benzrf> tfw
11:02:09 <ski> DarkCthulhu : sounds fine
11:02:28 <michi7x7> :t over 9000
11:02:30 <benzrf> > ((+1) :: Int -> Int) == ((subtract 1) . (+2))
11:02:30 <lambdabot> (Profunctor p, Num (Setting p s t a b)) => p a b -> s -> t
11:02:34 <lambdabot>  mueval-core: Time limit exceeded
11:04:42 <EvanR> safeEnum ftw
11:05:07 <Saizan> can you get heap profiling information with threadscope?
11:06:22 <qsuscs> ohh this looks nice https://carymrobbins.github.io/intellij-haskforce/
11:06:54 <EvanR> a gif tells a thousand words
11:07:16 <codygman> Yeah, the presentation of that page is amazing.
11:08:34 <EvanR> does that mean haskell will replace java now?
11:08:36 <joe9> anything like that for emacs/evil-mode?
11:12:19 --- mode: ChanServ set -q *!4c69fa22@gateway/web/freenode/ip.76.105.250.34
11:13:42 <bitonic> joe9: apart from the completion, I think ghc-mod and/or a recent haskell-mode will give you most of that
11:14:01 * hackagebot haskell-src-exts 1.16.0.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1 (RomanCheplyaka)
11:14:20 <bitonic> you'll get decent completion but not as smart
11:14:36 <bitonic> oh, and no Hamlet syntax
11:19:09 <DarkCthulhu> ski, Argh.. still no luck. The library keeps causing issues
11:19:40 <ski> @lpaste ?
11:19:40 <lambdabot> Haskell pastebin: http://lpaste.net/
11:21:09 <joe9> bitonic: do you use that configuration? Would you mind sharing the configuration?
11:21:31 <joe9> bitonic: I cannot seem to get the emacs/haskell configuration working properly.
11:22:41 <bitonic> joe9: if you have a recent haskell-mode it works out of the box for me
11:23:04 <bitonic> for properly configured projects
11:23:23 <DarkCthulhu> ski, http://lpaste.net/4839100331977605120
11:23:33 <joe9> bitonic: http://codepad.org/i3SEJBxZ is my haskell configuration.
11:23:39 <bitonic> I usually put a .ghci file where the .cabal file is so that loading files works
11:23:40 <DarkCthulhu> ski, I need to pretty-print the Term and get it's string form, but I keep getting PP.Doc out of that
11:23:53 <DarkCthulhu> And I guess that is expected
11:24:04 <joe9> bitonic: I am sure there is a better way of doing what I have.
11:24:08 <bitonic> joe9: my haskell configuration is `(add-hook 'haskell-mode-hook 'interactive-haskell-mode)'
11:24:22 <bitonic> plus some indentation stuff which is irrelevant
11:25:24 <bitonic> joe9: just make sure you have a recent haskell-mode installed, what's in elpa is good
11:25:41 <ski> DarkCthulhu : why do you need a `String' rather than a `Doc' ?
11:25:45 <joe9> bitonic: I think I have the elpa version.
11:26:12 <vanila> ski, may I ask your view on this approach?
11:26:13 <DarkCthulhu> ski, I thought I would return Strings everywhere and convert to Doc at the end. I guess it wasn't such a good idea. Changing everything to return Doc
11:26:15 <joe9> bitonic: do you use structured-haskell-mode?
11:26:42 <vanila> http://lpaste.net/113538
11:26:43 <bitonic> joe9: no
11:26:55 <bitonic> the less I configure the better :P
11:27:01 <bitonic> that's why I don't use xmonad
11:27:30 <joe9> bitonic: do you flycheck-haskell or flycheck-hdevtools?
11:28:03 <joe9>  anyone tried flycheck-haskell or flycheck-hdevtools? Do you recommend them?
11:28:07 <EvanR> DarkCthulhu: String is pretty bad for anything thats not a short string
11:28:16 <bitonic> joe9: no, I `C-c C-l' and then `C-`' to jump to errors.
11:28:42 <ski> vanila : looks ok
11:28:58 <vanila> oh i just realized a bad thing
11:29:09 <vanila> i can do two but not 3 modes in one  predicate
11:29:10 <vanila> x y -> z, x z -> y, y z -> x
11:29:15 <vanila> gives me Functional dependencies conflict between instance declarations:
11:29:20 <bitonic> joe9: but flyspell works out of the box with ghc-mode -- I found it distracting though
11:29:21 <vanila> so ill have to handle each mode as a separate typeclass
11:29:24 <vanila> code blowup :(
11:30:42 <ski> hm, i suppose this is the same problem as with `append(-,+,+)'
11:31:04 <vanila> it's different to that
11:31:10 <ski> is it ?
11:31:21 <vanila> oh im sorry
11:31:32 <vanila> I could support append(+,+,-), append(-,+,+), but not the nondeterministic (-,-,+)
11:31:38 <vanila> so yes its just as you say
11:31:51 * ski doesn't follow
11:32:08 <DarkCthulhu> ski, http://lpaste.net/113539 How should I be doing the map statement now?
11:32:15 <DarkCthulhu> or should it even be a map
11:32:51 <ski> in Mercury, you can specify a separate implementation for the `(out,in,in)' mode of append/3, to convince the compiler that it actually is semi-deterministic, rather than non-deterministic
11:33:34 <vanila> yeah that's what i hope to do - you can list all the modes in which its deterministic
11:35:10 <scalapeno> can anyone point me in the right direction here: "cabal update; cabal install cabal-dev
11:35:11 <scalapeno> Downloading the latest package list from stackage
11:35:11 <scalapeno> cabal: There is no package named 'cabal-dev'."
11:35:51 <ski> DarkCthulhu : i don't think you want `concat'. `map printRecord fields' gets you a list of `Doc's. try calling `intersperse (PP.text ",")' on that list before calling `sep' or `fsep' or something like that
11:36:00 <jfischoff> scalapeno: cabal-dev is deprecated
11:36:24 * ski can't recall the difference between `fsep' and `sep', and between `<>' and `<+>'
11:36:26 <scalapeno> jfischoff: thanks! is there a suggested replacement?
11:36:48 <jfischoff> scalapeno: cabal has the sandbox functionality built in now
11:38:21 <scalapeno> is stackage worth using? How do I see what's available in stackage?
11:38:57 <DarkCthulhu> hackage.haskell.org/ is up?
11:39:42 <DarkCthulhu> it is down :( what timing!
11:40:13 <monochrom> indeed
11:40:36 <scalapeno> so in general, hackage is the way to go?
11:42:36 <monochrom> in general, you have to make such value-judgment decisions yourself :)
11:43:20 <monochrom> hackage has more packages. stackage has more human-done checks on consistency and quality. you decide.
11:43:34 <DarkCthulhu> God bless Google's cached page
11:44:07 <kadoban> If stackage had hakyll, I'd probably use that, heh.
11:45:14 <scalapeno> monochrom: hard for a newbie to make such calls. Sounds like both are common-place.
11:45:31 <scalapeno> is there a way to see which packages are available via stackage?
11:45:56 <monochrom> you can just browse stackage's website for that, no?
11:46:56 <scalapeno> monochrom: i don't see where the package list is
11:47:01 <monochrom> I certainly went to hackage's website and read its complete list from top to bottom, when hackage was the size of today's stackage.
11:47:16 <kadoban> scalapeno: I think this is them, for exclusive at least: http://www.stackage.org/stackage/24e4d1b3bb101a80d3be1b146771c13df0827a82/metadata
11:48:28 <scalapeno> kadoban: thanks
11:49:21 <dmj`> is hackage down?
11:49:29 <monochrom> yes
11:49:32 <kadoban> scalapeno: 'welcome. IIUC, inclusive is basically all of hackage, which I'm not 100% clear on how that's different from just using hackage directly.
11:50:26 <nschoe> pharpend, hi back, did you manage to install leksah ?
11:51:02 <Welkin> hoogle is down
11:51:07 <Welkin> god damn
11:51:27 <DarkCthulhu> ski, worked at last :)
11:52:20 <Welkin> what is the easiest way to convert ByteString -> Text ?
11:52:37 <Welkin> it should be UTF8, no change to the encoding
11:52:46 <luite> Welkin: Data.Text.Encoding
11:52:52 <Welkin> which function?
11:53:08 <dmj`> decodeUtf8
11:53:14 <Welkin> thanks
11:53:19 <dmj`> :t decodeUtf8
11:53:20 <lambdabot> Not in scope: ‘decodeUtf8’
11:53:24 <luite> Welkin: depends on how you want errors to be handled, decodeUtf8 will throw an exception
11:53:30 <nschoe> How can I use something like ByteString.toChunks but I need to set the size of the chunks
11:54:43 <ski> DarkCthulhu : ok ?
11:54:46 <Welkin> well, what errors would I run into?
11:54:47 <ReinH> nschoe: what are you doing with the chunks that you need their size?
11:54:54 <ski> DarkCthulhu : annotate the lpaste with the update ?
11:55:12 <nschoe> ReinH, I'm sending them over TLs (with Network.Simple.TCP.TLS).
11:55:31 <nschoe> The recv function is said to received up to 16384 bytes : http://hackage.haskell.org/package/network-simple-tls-0.2.1/docs/Network-Simple-TCP-TLS.html
11:55:37 <ReinH> nschoe: you shouldn't need to care about the chunk size...
11:55:55 <ReinH> hmm
11:57:15 <luite> Welkin: byte sequences that cannot be decoded to a valid code point
11:57:18 <DarkCthulhu> ski, http://lpaste.net/8196474089712386048 ; based on what you suggested. Seems to work
11:57:26 <nschoe> ReinH, I'm not sure this is the problem, but when I try to transmit a big file, it fails after sending three chunks, with the error "connection reset by peer" (on the client) and "not enough input" (on the server)
11:58:14 <Welkin> luite: as long as I ensure the source ByteString is in UTF-8, would I avoid those errors?
11:58:30 <jonsterling> Question. With Data.Conduit, I have a source :: Source m a, which I would like to buffer into a something like :: Source m [a] for some buffer size. Is there an easy way to do this?
11:58:43 <Welkin> assuming sinkLbs maintains the encoding of the stream
11:58:55 <DarkCthulhu> ski, The only thing that remains now is to add evaluation rules for projections on the records
11:59:10 <ski> DarkCthulhu : if you want to, you could define `getTypeRecord' in a `where'-clause attaching to the defining equation of `pp' that uses it
11:59:24 <DarkCthulhu> ski, ah.. okay, I'll do that.
12:00:19 <bernalex> here's a needlessly verbose paste: http://lpaste.net/754946300201402368 -- how do I make my [] case a "repl"?
12:00:20 <ski> (and similarly for `getRecord')
12:00:34 <bernalex> well actually, both of the top two cases should be a "repl"
12:00:47 <nschoe> ReinH, no idea ? (for controlling the size of the chunks) ?
12:01:12 <bernalex> i.e. I want the user to be able to write stuff and press ^D (or maybe even enter), and then the run uncurry spawnProcess (build <the stuff they entered> f) >>= waitForProcess >>= exitWith
12:01:32 <bernalex> and then it *loops*. which is what I'm missing now.
12:02:46 <ski> bernalex : not sure you can use `getContents', then
12:02:51 <bernalex> ski: probably not, no
12:03:13 <DarkCthulhu> ski, Does alpha substitution on a record have any effect? It doesn't evaluate further, so I think it doesn't. Do you agree?
12:03:47 <monochrom> you can use getContents, but you should not consume all of cs. you should leave something for the recursion.
12:04:12 <monochrom> that's right, first you have to add recursion. recursion is the only way you can loop back.
12:04:17 <bernalex> monochrom: I'm not sure what you mean/how to not "consume all of it"
12:05:30 <DarkCthulhu> ski, Would you say that records are value types? In extensions to lambda calculus?
12:05:42 <statusbot> Status update: Likely an issue with hetzner -- http://status.haskell.org
12:05:52 <Welkin> Why am I get errors about Text not being Lazy Text?
12:06:12 <Welkin> is there a simple way to take a lazy stream and turn it into Text (Data.Text)
12:06:23 <jonsterling> Or actually, what would be better is just a way to make a conduit :: Conduit a m [a] for some length
12:06:51 <vanila> ski, I just finally understood what you mean - why (-,+,+) is harder than (+,-,+) (since my program analyzed them)
12:08:11 <vanila> i think i shall just not solve this difficult aspect, at least in v1
12:08:35 <ski> DarkCthulhu : what do you mean by "alpha substitution on a record" ?
12:09:08 <ski> DarkCthulhu : what do you mean by "value type" ?
12:09:24 <DarkCthulhu> ski, I'm extending simply typed lambda calculus with various types such as record. I was asking in that context.
12:09:30 <ski> vanila : nice :)
12:09:37 <DarkCthulhu> ski, It is a value, based on the typing relation I have here at http://i.imgur.com/ZG5NwSa.png
12:09:40 <ski> vanila : ok
12:09:52 <DarkCthulhu> but, the evaluation rules are sort of baffling. If it's a value, how would it go from t -> t'
12:10:37 <ski> DarkCthulhu : "alpha substitution" refers to (consistent) renaming of bound variables (avoiding unintended capture). i'm not sure how that applies specifically to records
12:10:55 <DarkCthulhu> ski, Yeah, it doesn't apply.
12:11:22 <DarkCthulhu> ski, I'm not sure how I should implement the projections. Record.key -> value. That in haskell
12:12:17 <ski> DarkCthulhu : hm, those typing and evaluation rules look standard to me
12:12:53 <DarkCthulhu> ski, Yeah, but how do I translate the projection into haskell? Would it be like a function application on a projection?
12:13:03 <DarkCthulhu> on a record*
12:13:12 <ski> DarkCthulhu : a value there (not to be confused with value/denotation in denotational semantics) is roughly a term that can't be reduced any more
12:13:33 <ski> DarkCthulhu : and a record value is a record construction, all of whose term parts are also values
12:13:43 <DarkCthulhu> okay
12:13:54 <monochrom> DarkCthulhu: I wonder if you already know this: in this context, "term" ("syntax" in the picture) means what is valid code, "value" means when running the code, how does the computer know it can stop.
12:14:11 <RyanGlScott> I have a question about un-idiomatic Haskell. I want to be able to run a statement like "20 goto 10".
12:14:19 <ski> DarkCthulhu : by "implement the projections" do you mean represent the prejection in your ASTs ? or implement reduction ?
12:14:21 <RyanGlScott> How can I make goto "postfix"?
12:14:36 <DarkCthulhu> monochrom, Yeah, I know that :) Terms eventually lead to values, unless they get stuck (which they don't do in simply typed lambda calculus as far as I know)
12:15:03 <DarkCthulhu> ski, I'm asking about how it would be represented in haskell
12:15:13 <ski> RyanGlScott : augustss had a blog post about something like that ..
12:15:27 <RyanGlScott> ski: I thought someone had done this before, I'll look there.
12:15:51 <DarkCthulhu> I have a term, TmRecord which holds that [(key, value)], and now I want to get values by key. How would I expose this in Haskell?
12:15:55 <RyanGlScott> ski: Ah, here it is http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html. Thanks!
12:16:22 <silasm> RyanGlScott: you could be especially awful and make a num instance for functions
12:16:32 <ski> RyanGlScott : <http://augustss.blogspot.se/2009/02/more-basic-not-that-anybody-should-care.html> is one of the posts
12:16:43 <ski> RyanGlScott : *nod*
12:18:26 <ski> DarkCthulhu : add a `TmProj Term Label' case to `Term' ?
12:18:40 <RyanGlScott> silasm: Is there another way of doing it besides making a Num instance for functions?
12:18:45 <DarkCthulhu> ski, ahhh.. it would be a term on its own!
12:19:03 <DarkCthulhu> ski, Okay, I was wondering about that very step. If it is to be a term that way, I can proceed
12:19:07 <DarkCthulhu> ty!!!
12:19:20 <clrnd> this is glorious, I need to programm BASIC's stdlib now, brb
12:20:02 <ski> DarkCthulhu : as the first line "New syntax: ... {l_i = t_i ^{i \in 1...n}} | t . l" says :)
12:20:24 <bernalex> gah. hackage is down.
12:20:30 <DarkCthulhu> ski, I just realized. I was being stupid :D
12:20:48 <johnw> joe9: hi
12:20:57 <bernalex> what should I be using to get a String?
12:21:04 <bernalex> n <- readLn :: IO String
12:21:10 <bernalex> didn't work as expected
12:21:31 <bernalex> user error (Prelude.readIO: no parse)
12:21:42 <indiagreen> bernalex: getLine?
12:21:53 <bernalex> indiagreen: derpppppppppp
12:22:11 <bernalex> guess who's been working too long today :-P
12:22:13 <bernalex> indiagreen: thanks
12:22:47 <DarkCthulhu> ski, In the last evaluation rule specified, what does it mean? Can I be lazy and evaluate the Term only when asked for it, or should I evaluate all terms in the record till they turn into values?
12:22:59 <silasm> RyanGlScott: probably some extension magic. That was more just a possibility that came to mind, but you'd have to really hate something to do that.
12:23:36 <RyanGlScott> silasm: I know there's PosfixOperators, but that wouldn't work with a function named "goto". When Hackage comes back up, I'll check out the BASIC package.
12:23:52 <monochrom> DarkCthulhu: here is an example sequence that an evaluation goes through. the first one is original code.  {x=4+3, y=1-0}.y -> {x=7, y=1-0}.y -> {x=7, y=1}.y -> 1.  you will have to represent all the intermediate states.
12:23:57 <zq> what is going on with hackage
12:23:58 <zq> 503?
12:24:01 <zq> http://hackage.haskell.org/package/hashable
12:24:20 <indiagreen> it's down
12:24:21 <johnw> zq: I received notice this morning that it is running out of disk space
12:24:27 <zq> again?
12:24:34 <johnw> it's root volume is stupidly small
12:24:42 <zq> makes me feel really bad for upping my package
12:24:49 <johnw> let me see how it looks now
12:24:51 <DarkCthulhu> monochrom, But the last rule is on the record term itself, not on it's projection
12:24:58 <johnw> it has space now
12:25:20 <zq> still 503 though
12:25:30 <monochrom> right, I have to combine it with the second rule, "if t->t', then t.y -> t'.y"
12:25:36 <DarkCthulhu> monochrom, I'd imagine that this is right. {x=4+3, y=1-0}.y -> {x=7, y=1}.y -> 1
12:25:36 <johnw> zq: it could be just starting up again
12:25:50 <johnw> I see a busy process that hasn't been running long
12:26:00 <monochrom> well, this set of rules seems to say "do one small thing at a time"
12:26:10 <johnw> the hackage server is running at 100% cpu at the moment
12:26:19 <DarkCthulhu> monochrom, Hmm.. but then I'd have to maintain state somehow? and figure out which evaluation to do next?
12:26:30 <monochrom> yes
12:26:36 <DarkCthulhu> crap :-| okay
12:26:38 <johnw> oh weird, it just stopped
12:27:01 <zq> johnw: does cabal info pull from hackage?
12:27:04 <zq> wait nvm
12:27:08 <zq> package cache
12:27:26 <monochrom> whatever you already use for terms, it is already "state". every intermediate state is a term.
12:27:34 <monochrom> i.e., valid code.
12:28:13 <monochrom> you just need a predicate Term -> Bool that figures out "is this a value yet?"
12:28:34 <monochrom> for example "4+5" is not a value yet, "9" is.
12:28:59 <ski> DarkCthulhu : the last rule means that you can reduce a record construction term one step by reducing one of the enclosed terms in it one step
12:29:37 <monochrom> for example "{x=9, y=1-0}" is not a value yet, on account that a subexpression "1-0" is not yet, and according to the rule about "new values" which requires all components to be values.
12:29:43 <ski> DarkCthulhu : the rule on the right means that you can reduce a record projection term one step by reducing the enclosed term (which must have a record type) one step
12:30:43 <ski> DarkCthulhu : the rule on the left says that another way to reduce a record projection term one step is if the enclosed term is a record construction term, all of whose components have already been reduced to value terms
12:31:24 <DarkCthulhu> ski, monochrom got it
12:31:30 <monochrom> :)
12:31:55 <DarkCthulhu> ty both :)
12:32:18 <DarkCthulhu> I get what it means now. But maintaining state is a little hard. I guess some monad magic is in order
12:33:19 <monochrom> I just use parameter passing. eval :: Term -> Term, recursive function
12:33:24 <ski> DarkCthulhu : i'm not sure what state you think you need to maintain, apart from keeping track of the current term to reduce one step (or else fail, if not possible)
12:34:16 <DarkCthulhu> ski, That exact thing was what I meant by state. The offset into the list at which the next evaluation is to happen. It would require monads right?
12:34:35 <DarkCthulhu> unlesss... I can make the evaluator itself pass another parameter
12:34:46 <monochrom> no, you can omit that and instead do exhaustive search :)
12:34:57 <ski> DarkCthulhu : anyway, the answer to "Can I be lazy and evaluate the Term only when asked for it, or should I evaluate all terms in the record till they turn into values?" is that you need to first evaluate all the record components, because the left upper rule uses `v' rather than `t'
12:35:06 <michi7x7> @let code = [01111001, 01101111, 01110101, 01110100, 01110101, 00101110, 01100010, 01100101, 00101111, 01100100, 01010001, 01110111, 00110100, 01110111, 00111001, 01010111, 01100111, 01011000, 01100011, 01010001]
12:35:08 <lambdabot>  .L.hs:161:1:
12:35:09 <lambdabot>      Multiple declarations of ‘code’
12:35:09 <lambdabot>      Declared at: .L.hs:157:1
12:35:09 <lambdabot>                   .L.hs:161:1
12:35:15 <DarkCthulhu> monochrom, Exhaustive search?
12:35:20 <michi7x7> @let code'' = [01111001, 01101111, 01110101, 01110100, 01110101, 00101110, 01100010, 01100101, 00101111, 01100100, 01010001, 01110111, 00110100, 01110111, 00111001, 01010111, 01100111, 01011000, 01100011, 01010001]
12:35:23 <lambdabot>  Defined.
12:35:30 <michi7x7> > code
12:35:32 <lambdabot>  [1111001,1101111,1110101,1110100,1110101,101110,1100010,1100101,101111,11001...
12:35:46 <ski> DarkCthulhu : pass the subterm to (attempt to) reduce one step recursively to the function that reduces ?
12:35:57 <monochrom> according to the third rule, when you evaluate a record, you find the first non-value component to process, and process it.
12:36:04 <monochrom> this is just linear search.
12:36:31 <monochrom> this is slow, but is obviously correct and does not require any memory of the past
12:36:35 <DarkCthulhu> monochrom, Ah!!! That would be super-inefficient but valid!
12:36:36 <DarkCthulhu> yesss
12:36:58 <DarkCthulhu> ski, The recursive solution wouldn't fit in with the small-step evaluator
12:37:00 <monochrom> this is one way to see why stacks and program counters are just optimizations.
12:37:13 * ski supposes one could attempt to do something with zippers here
12:37:25 <ski> DarkCthulhu : why not ?
12:39:33 <DarkCthulhu> ski, The intermediate state in which the evaluator is may need to be seen. If the recursive evaluation is done, it will finish all computation right? Convert the entire record into values
12:39:37 <DarkCthulhu> key -> values
12:42:21 <ski> DarkCthulhu : i don't follow what you mean by "The intermediate state in which the evaluator is may need to be seen."
12:43:03 <monochrom> write a transition function for one step. write a loop or recursion to keep calling it until you're done
12:43:51 <monochrom> alternatively, merge them. this is equivalent to converting the small-step semantics to a big-step semantics.
12:43:57 <codygman> Can you import things with ghc -e? ghc -e "import System.IO; print 1" doesn't seem to give me the desired results.
12:44:50 <DarkCthulhu> ski, {x=4+3, y=1-0}.y -> {x=7, y=1-0}.y -> {x=7, y=1}.y -> 1 like monochrom said. The sequence of steps the small-step evaluator goes through are these, and each should be a separate state. I don't understand how recursion could achieve this.
12:45:20 <DarkCthulhu> The linear search solution looks like it'll work though
12:49:19 <DarkCthulhu> ski, or maybe I'm just being dense :)
12:52:07 <assia_t> Hey everyone... I'm having problems with `cabal haddock`... Shouldn't I be able to use `-- ^` to document function parameters?
12:53:32 <DarkCthulhu> Which is the function to check if all values in a list are True? Something like All?
12:53:52 <jchmrt> and
12:53:52 <DarkCthulhu> nvm.. it was all :)
12:53:52 <ski> > all even [2,4,6]]
12:53:54 <lambdabot>  <hint>:1:17: parse error on input ‘]’
12:53:56 <ski> > all even [2,4,6]
12:53:58 <lambdabot>  True
12:53:58 <jchmrt> oh nvm
12:54:02 <ski> > and (map even [2,4,6])
12:54:03 <lambdabot>  True
12:54:11 <DarkCthulhu> ohh.. and
12:54:14 <DarkCthulhu> I could use that
12:54:50 <joe9> Does anyone know of a haskell delimited continuations tutorial/material similar to https://www.fpcomplete.com/user/jwiegley/understanding-continuations
12:55:15 <joe9> This http://repository.readscheme.org/ftp/papers/plsemantics/danvy/db_thesis.pdf is scheme oriented.
12:56:40 <joe9> I do not have a mathematical background and could not understand the paper.
12:57:10 <joe9> Loved the haskell continuations tutorial by Johnw and am looking for something similar for delimited continuations too.
12:58:09 * hackagebot extra 0.6 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.6 (NeilMitchell)
12:58:38 <clrnd> > mapM (\_ -> randomRIO (0, 1)) [1..5] :: IO [Float]
12:58:40 <lambdabot>  <IO [Float]>
12:58:50 <DarkCthulhu> ski, monochrom: isValue (TmRecord fields) = and (map (isValue.snd) fields)
12:58:53 <DarkCthulhu> does this look right?
12:59:07 <bernalex> what's a more flexible getLine?
12:59:08 <clrnd> > replicateM_ 5 $ randomRIO (0, 1) :: IO [Float]
12:59:10 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Float]’
12:59:10 <lambdabot>  Expected type: GHC.Types.IO [GHC.Types.Float]
12:59:10 <lambdabot>    Actual type: GHC.Types.IO ()
12:59:15 <bernalex> I want to be able to paste stuff in my repl that has newlines
12:59:21 <bernalex> I want it to only really react to me pressing enter
12:59:29 <clrnd> > replicateM 5 $ randomRIO (0, 1) :: IO [Float]
12:59:31 <lambdabot>  <IO [Float]>
12:59:33 <digitalmentat> :{ :}
12:59:51 <digitalmentat> bernalex, you can do multi-line pastes by first typing ":{"
12:59:55 <digitalmentat> (enter)
12:59:58 <bernalex> interesting
13:00:01 <digitalmentat> (paste multiline thingy)
13:00:09 <digitalmentat> then type ":}"
13:00:12 <digitalmentat> (enter)
13:00:22 <digitalmentat> there's another way to do it but I can't remember
13:00:31 <digitalmentat> the GHC User's Manual has all of this in the GHCi section
13:01:12 <bernalex> digitalmentat: it did not really work though
13:01:35 <Walther> Hello! Trying to deploy a simple helloworld to Heroku in Haskell, using https://github.com/mietek/haskell-on-heroku-examples/tree/master/hello-snap but running into issues (   *** ERROR: Bootstrapping Cabal 1.20.0.2 with GHC 7.6.3 is not implemented yet)
13:01:45 <bernalex> digitalmentat: uh
13:01:48 <bernalex> digitalmentat: I don't mean GHCi
13:01:53 <bernalex> digitalmentat: I mean a REPL in my own program :-]
13:02:00 <digitalmentat> ah!
13:02:10 <mietek> Walther: hi
13:02:13 <bernalex> digitalmentat: you scared me a bit. I thought that getLine worked that way, lol.
13:02:14 <digitalmentat> what are you using for user input?
13:02:17 <mietek> Walther: join us in #HaskellOnHeroku.
13:02:23 <Walther> excellent!
13:02:28 <bernalex> digitalmentat: I just have hFlush stdout ; n <- getLine atm
13:02:57 <digitalmentat> bernalex, can't you do (on shell) > my line blabalbal \ (enter) balbalbalhba
13:03:03 <geekosaur> it's difficult to distinguish between a paste and a keystroke in a terminal
13:03:10 <bernalex> digitalmentat: no
13:03:24 <bernalex> digitalmentat: wait what do you mean "on shell"?
13:03:36 <bernalex> geekosaur: yeah I figured
13:04:02 <digitalmentat> your repl is exposed to your shell, right? zsh or bash?
13:04:20 <bernalex> I am running it in rlwrap in zsh
13:04:54 <digitalmentat> myrepl <<EOF line1 \n line2 \n line3 EOF
13:05:00 <digitalmentat> will that not work?
13:05:04 <michi7x7> take 5 <$> (randoms :: IO [Double])
13:05:26 <michi7x7> > take 5 <$> (randoms :: IO [Double])
13:05:28 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO [GHC.Types.Double]’
13:05:28 <lambdabot>              with actual type ‘g0 -> [a0]’
13:05:52 <bernalex> digitalmentat: I don't understand what that really means. but I'm guessing not
13:05:53 <michi7x7> ah... true
13:08:04 <DarkCthulhu> ski, monochrom: http://lpaste.net/2461843578683392000 The type of a projection should be the type of the value that it is accessing?
13:08:10 * hackagebot neil 0.7 - General tools for Neil  http://hackage.haskell.org/package/neil-0.7 (NeilMitchell)
13:08:24 <monochrom> yes I think so
13:08:53 <monochrom> but I prefer the wording "the type of the field it's accessing"
13:09:53 <DarkCthulhu> monochrom, Yeah.. the type of that field. But how do I get at that in that last function I've written?
13:10:11 <DarkCthulhu> I get back a TyRecord [...]. How do I get to the list within? Pattern matching?
13:10:46 <lpaste> ski pasted “reduction” at http://lpaste.net/113543
13:11:01 <ski> DarkCthulhu : something like that ^ might work
13:11:37 <DarkCthulhu> ski, whoa.. checking..
13:12:24 <zq> aw yes hackage is back
13:12:29 <zq> nice one johnw
13:13:09 <ski> DarkCthulhu : `and (map (isValue.snd) fields)' can be simplified to `all (isValue . snd) fields'
13:13:19 <johnw> zq: it was thoughtpolice who fixed it
13:13:37 <ski> DarkCthulhu : of course you also need cases for `reduceOnce' for your other term constructions. i forgot to add a `...' indicating that
13:14:11 <ski> DarkCthulhu : and perhaps you want to add some error reporting or something. this was just meant as a sketch of an approach
13:14:42 <DarkCthulhu> ski, I'll study it. I do have a different evaluator which doesn't do it recursively, but I'm sure I'll learn a lot from this. ty :)
13:16:15 <ski> DarkCthulhu : btw, i wouldn't do I/O just to report an error. let the user who calls `typeOf' decide how to report the error
13:16:30 <DarkCthulhu> ski, I see
13:17:33 <DarkCthulhu> ski, I have a structure like: [("key1",TyNat),("key2",TyNat)]; I want to supply "key2" and get the second tuple as result. What is the most idiomatic way to do this?
13:17:41 <kqr> "The package 'entropy' requires Cabal library version -any && >=1.17 but no suitable version is installed.)" but "cabal-install version 1.20.0.3"
13:17:43 <kqr> what am I missing?
13:17:51 <DarkCthulhu> ski, I could write a function to accomplish this, but is there a shorter route?
13:17:52 <ski> DarkCthulhu : you could use `Either TypeError' or something akin to that, to report errors. where `TypeError' might be `String', or a new type with one case per specific kind of error
13:18:35 <ski> > lookup "key2" [("key1","TyNat"),("key2","TyUnit")]
13:18:37 <lambdabot>  Just "TyUnit"
13:18:49 <DarkCthulhu> :-o wow
13:19:18 <clrnd> @hoogle Eq a => [(a, b)] -> Maybe b
13:19:21 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:19:21 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:19:21 <lambdabot> Prelude snd :: (a, b) -> b
13:19:25 <ski> DarkCthulhu : also, one can cut out much of the noise with `Just' and `Nothing' in my paste. i just wanted to show it explicitly
13:20:12 <supki> kqr: Cabal and cabal-install are separate packages
13:21:00 <kqr> supki, i see!
13:21:12 <kqr> supki, (i even knew that, but thought their versions were always synced)
13:21:20 <kqr> i should've checked
13:27:04 <kqr> supki, thank you, that was it
13:33:07 <JesusWasGay> JESUS WAS A FUCKING FAGGOT!!!!!!!!!!!!!!!!!!!!
13:33:13 <JesusWasGay> JESUS WAS A FUCKING FAGGOT!!!!!!!!!!!!!!!!!!!!
13:33:28 <JesusWasGay> HE WAS ALSO A RETARDED NIGGER
13:33:32 <JesusWasGay> JESUS CHRIST
13:33:56 --- mode: ChanServ set +q *!*@www.nowhere-else.org
13:35:09 --- mode: ChanServ set -q *!*@www.nowhere-else.org
13:35:16 <ZettaBlade> That was probably the weakest troll I've seen in a long time.
13:35:22 <MitchellSalad> lol
13:35:25 <andbroby> :p
13:35:34 <MitchellSalad> that troll was somehow hilarious
13:35:36 <zos> i'm not sure it even qualifies
13:36:02 <carette> I'm guessing it's a spambot troll.  No human is that weak.
13:36:23 <josephle> but if you make a spambot...what's the point of trolling?
13:36:39 <merijn> Freenode gets spammed/DDOSed pretty regularly
13:36:50 <merijn> It's a favourite target of scriptkiddies with a grudge
13:37:05 <carette> Never underestimate the power of human stupidity.
13:37:15 <c_wraith> And since this is one of the biggest channels, it gets hit by people seeking maximum impact
13:38:09 <clrnd> I've noticed this channel is quite big, any idea why?
13:38:20 <c_wraith> because people are curious about haskell.
13:38:36 <c_wraith> Or, alternatively, are excited about it and want to help everyone who's curious.
13:38:44 <c_wraith> (I'm in the latter category)
13:38:49 <merijn> Also, one of the nicer channels on #freenode
13:38:54 * lyles curious lurker
13:38:55 <clrnd> of course but you have to admit haskell's community is quite small
13:39:00 <merijn> So people hang out just because it's educational
13:39:13 <c_wraith> Yeah, I've learned a ton here over the years semi-accidentally.
13:39:18 <merijn> clrnd: Growing quite fast the last 5-7 years
13:39:32 <merijn> Must be Scala becoming popular
13:39:47 <clrnd> jajaja, they say "shit types can't be this awfull"
13:39:53 <merijn> I'm convinced Scala is doing a great job of convincing people "hmm, haskell isn't all that hard in comparison"
13:41:20 <c_wraith> When you get rid of nominal subtyping, it really makes advanced type features easier to follow.
13:42:31 <merijn> Also, Scala's notion of immutable is amusing: https://gist.github.com/paulp/a933f7a49b71d1a63658 :p
13:43:27 <ZettaBlade> For Halloween, I'm dressing up as a monad
13:43:53 <clrnd> how? are you join'ing a party?
13:44:37 <Hijiri> how would I write a haddock comment to describe multiple constructors? eg I have data foo = bar | baz | qux, and I want to document baz and qux because they are related somehow
13:44:47 <ZettaBlade> Gonna return with a lot of candy
13:45:56 <merijn> Hijiri: You can document individual constructors, but not sets of constructors
13:46:09 <Hijiri> ok, thanks
13:46:23 <merijn> Hijiri: So I would just reference the Baz's documentation in Qux' documentation
13:47:13 <Hijiri> well they form a group, but the relationship isn't oriented either way
13:47:23 <Hijiri> actually I'm trying to write that mahjong library again
13:47:34 <Hijiri> and I'm trying to document related tiles
13:47:38 <Hijiri> like every tile of a suit
13:47:43 <josephle> well, they have to show up in some ordering in the docs
13:47:58 <Hijiri> but I documented the first constructor and it looks sort of like a description of the group this way
13:48:11 <Hijiri> so I might just do this
13:48:23 <josephle> that sounds like a plausible formatting hack
13:48:57 <ZettaBlade> Heck yea, mahjong.
13:49:29 <Hijiri> last time I gave up on making a DSL to describe mahjong groups
13:49:45 <Hijiri> but I think I could make a monadic "Mahjong parser" for parsing mahjong hands
13:50:02 <Hijiri> which are unordered and would be slightly different
13:50:15 <Hijiri> maybe applicative would be sufficient
13:50:45 <josephle> I believe most mahjong programs have some sort of implicit ordering of tiles
13:51:49 <DarkCthulhu> ski, I have a list [1,3,4,5,6], I want to multiply just the first encountered even number by 2 and keep the rest the same. How does one accomplish that in the most idiomatic way?
13:52:00 <DarkCthulhu> result should be [1,3,8,5,6]
13:52:29 <joelteon> write a function
13:52:44 <ski> i suppose one could use `break'
13:53:00 <merijn> I would just write a custom recursive function
13:53:07 <merijn> You could use fold, but that sounds like a hassle
13:53:09 <c_wraith> yeah, that's not an easy natural composition of existing tools.  Might as well just make it a direct recursive function.  It's an easy one.
13:53:35 <ski> > let (front,n:back) = break even [1,3,4,5,6] in front ++ 2 * n : back
13:53:37 <lambdabot>  [1,3,8,5,6]
13:53:46 <DarkCthulhu> Ahhh
13:53:59 <ski> > let (front,n:back) = break even [1,3] in front ++ 2 * n : back  -- but note !
13:54:01 <lambdabot>  *Exception: <interactive>:3:5-37: Irrefutable pattern failed for pattern (fr...
13:54:15 <DarkCthulhu> I see
13:54:22 <ski> so for completeness you need to check for empty list as well
13:54:36 <DarkCthulhu> If I am trying to write a custom recursive function, how do you I know when to stop?
13:54:42 <DarkCthulhu> s/you//
13:54:52 <merijn> DarkCthulhu: As soon as you find the first even element
13:55:04 <DarkCthulhu> ohh.. okay. Yeah. silly me
13:55:19 <merijn> or end of list, whichever's first
13:57:12 <alethiophile> Is there any difference between 'notElem thing listOfThings' and 'not $ elem thing listOfThings'?
13:57:28 <alethiophile> (And if not, what's the point of notElem?)
13:58:15 <geekosaur> performance/laziness, I imagine
13:58:15 <ski> `notElem' has an infix precedence
13:58:29 <alethiophile> Okay.
13:58:42 <supki> > [1,3,4,5,6] & taking 1 (traverse.filtered even) *~ 2
13:58:44 <lambdabot>  [1,3,8,5,6]
13:59:03 <DarkCthulhu> Higher order functions.. So powerful and obscure -_-
14:02:44 <ReinH> supki: magic
14:03:18 <ReinH> supki: I still don't understand all the awesome things you can do with traversals
14:07:19 <wdasdfasrasf> anyone have a tip on eliminating infinite recursion in the grammar Expr = Integer | Expr + Expr with ReadP?
14:08:49 <jfischoff> wdasdfasrasf: you either can left factor or use something like chainL (idk the readP version)
14:11:10 <wdasdfasrasf> jfischoff: yeah, i've tried chainl but am still having probs with stack overflows
14:11:44 <jfischoff> paste your code
14:11:48 <wdasdfasrasf> sec
14:13:12 <wdasdfasrasf> http://lpaste.net/4221736415681052672
14:13:28 <wdasdfasrasf> maybe i'm just not quite grasping how to use it
14:14:00 <intrados> What might be happening that `ghc --make` succeeds but `cabal build` fails with `collect2: error: ld returned 1 exit status`?
14:14:21 <jfischoff> wdasdfasrasf: try chainl1
14:18:13 <jfischoff> wdasdfasrasf: any luck?
14:19:06 <wdasdfasrasf> same result
14:19:07 <qsuscs> can somebody make a guess how long it takes for GHC to build on a core i5-3570k (4cores, 3.4GHz) with 16GiB ram?
14:19:28 <wdasdfasrasf> actually that was what i used, just a typo
14:20:46 <fritz269> afternoon
14:21:10 <merijn> intrados: rerun cabal build with -v3
14:21:41 <merijn> intrados: In fact, the first step after any "cabal fails to do X" is to rerun with -v3 and lpaste the output :)
14:22:07 <monochrom> qsuscs: I guess half and hour. this is almost a blind guess.
14:22:19 <merijn> qsuscs: Somewhere between 30 mins and an hour
14:22:37 <merijn> qsuscs: Don't forget to "make -j"
14:23:16 <DarkCthulhu> I have a function returning Maybe Term, how do I make it return just Term? I tried FromMaybe, but I'm unsure how I should be using it
14:23:17 <merijn> Also depends on which build mode you pick
14:23:23 <merijn> i.e. fast vs optimised, etc.
14:23:39 <wdasdfasrasf> jfischoff: any ideas?
14:23:40 <merijn> DarkCthulhu: Well, you need to decide what to do when it's "Nothing"
14:23:49 <merijn> :t fromMaybe
14:23:50 <jfischoff> wdasdfasrasf: reproing
14:23:51 <lambdabot> a -> Maybe a -> a
14:23:57 <indiagreen> DarkCthulhu: if you're sure it can't fail, use fromJust. If you want to supply some default value, use fromMaybe
14:24:01 <jfischoff> filling in the missing code :p
14:24:09 <DarkCthulhu> It won't ever fail.
14:24:13 <digitalmentat> please don't recommend fromJust
14:24:18 <merijn> indiagreen: Telling people to use fromJust is always wrong
14:24:24 <indiagreen> “It won't ever fail” – famous last words
14:24:24 <merijn> DarkCthulhu: Use fromMaybe anyway
14:24:28 <DarkCthulhu> Hmm.. okay
14:24:31 <wdasdfasrasf> heh, thanks :)
14:24:39 <merijn> > fromMaybe 0 Nothing
14:24:41 <lambdabot>  0
14:24:46 <merijn> > fromMaybe 0 (Just 5)
14:24:47 <lambdabot>  5
14:24:53 <merijn> Alternatively, use
14:24:54 <merijn> :t maybe
14:24:54 <digitalmentat> DarkCthulhu, fromMaybe with a "default" return value OR handle the Nothing in some way
14:24:56 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:24:57 <rai> how would I check inside ghci how each applicative type behaves with <*> etc. ?
14:25:08 <DarkCthulhu> okay.. ty. Try now
14:25:18 <jfischoff> wdasdfasrasf: compiled :p
14:25:22 <jfischoff> let’s see
14:25:24 <merijn> rai: By just running it? :)
14:25:58 <DarkCthulhu> http://lpaste.net/2180675498860871680
14:26:03 <DarkCthulhu> eval1 returns a Maybe Term
14:26:05 <rai> merijn: well. it's a bit difficult if i don't understand how they work with each type, i was looking for something like :t
14:26:06 <DarkCthulhu> Am I not using this right?
14:26:48 <DarkCthulhu> do I need to sequence it in some do block
14:27:19 <merijn> rai: Ah, you mean "what does the type of <*> look like for a specific instance"?
14:27:31 <rai> yeah!
14:27:55 <digitalmentat> DarkCthulhu, I certainly couldn't help you with just those two lines, more context would help
14:28:04 <monochrom> you can ask me, and I will answer you. for example, [a -> b] -> [a] -> [b]
14:28:14 <merijn> rai: There's a neat trick, but I don't remember where asAppliedTo is defined
14:28:51 <merijn> > (<*>) `asAppliedTo` Just (+)
14:28:51 <merijn> eh, whoops
14:28:53 <lambdabot>  <Maybe (Integer -> Integer -> Integer) -> Maybe Integer -> Maybe (Integer ->...
14:28:54 <merijn> :t (<*>) `asAppliedTo` Just (+)
14:28:55 <lambdabot> Num a => Maybe (a -> a -> a) -> Maybe a -> Maybe (a -> a)
14:29:13 <DarkCthulhu> digitalmentat, It's rather long.. Let me make a smaller test case from it. In general, do those lines look like they're using fromMaybe correctly
14:29:13 <digitalmentat> merijn, that's cool
14:29:22 <ion> asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn` ; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
14:29:24 <digitalmentat> no they do not
14:29:38 <merijn> I forget which module exports asAppliedTo, though
14:30:05 <merijn> And hoogle is failing me...
14:30:13 <digitalmentat> DarkCthulhu, I do not understand this piece without context: (fromMaybe TmUnit, (eval1 t))
14:30:24 <digitalmentat> there's a comma in there that feels like shouldn't be there
14:30:55 <digitalmentat> what's the type of eval1?
14:31:05 <digitalmentat> I'm assuming eval1 returns Maybe Term
14:31:15 <DarkCthulhu> digitalmentat, It was the comma!!
14:31:17 <DarkCthulhu> ty
14:31:21 <DarkCthulhu> It compiles again. phew
14:31:31 <digitalmentat> are you using an in-editor flychecker?
14:31:34 <DarkCthulhu> The error message was just (t0, t1), blah blah
14:31:41 <digitalmentat> ghc-mod + flymake would have caught that
14:31:46 <DarkCthulhu> I'm using ghci and reloading..
14:31:51 <digitalmentat> :(
14:31:56 <DarkCthulhu> Should shift to better tools
14:32:06 <digitalmentat> that's not a /terrible/ way to do it but Emacs + ghc-mod + flymake
14:32:23 <merijn> heh, is asAppliedTo only in lambdabot?
14:32:33 <jfischoff> wdasdfasrasf: read_expr = chainl1 (read_int +++ parens read_expr) read_plus_op
14:33:09 <jfischoff> parens = between (char ‘(‘) (char ‘)’)
14:33:12 <digitalmentat> merijn, I cannot find it anywhere?
14:33:27 <digitalmentat> merijn, technically though you can build lambdabot for ghci? I haven't done that yet though
14:33:36 <digitalmentat> asAppliedTo is useful though
14:35:23 <merijn> digitalmentat: You can just defined it
14:35:33 <merijn> asAppliedTo is just "const" with a different type :p
14:35:36 <wdasdfasrasf> jfischoff: thanks i'll take a look
14:35:46 <jfischoff> np
14:36:02 <digitalmentat> :t const
14:36:03 <lambdabot> a -> b -> a
14:36:10 <digitalmentat> huh
14:36:19 <merijn> :t let myAppliedTo :: (a -> b) -> a -> b; myAppliedTo = const in (<*>) `myAppliedTo` Just (+)
14:36:20 <lambdabot>     Couldn't match type ‘b’ with ‘a1 -> b’
14:36:20 <lambdabot>       ‘b’ is a rigid type variable bound by
14:36:20 <lambdabot>           the type signature for myAppliedTo :: (a1 -> b) -> a1 -> b
14:36:41 <merijn> hmmm
14:36:46 <merijn> oh, duh
14:36:59 <merijn> :t let myAppliedTo :: (a -> b) -> a -> a -> b; myAppliedTo = const in (<*>) `myAppliedTo` Just (+)
14:37:01 <lambdabot> Num a => Maybe (a -> a -> a) -> Maybe a -> Maybe (a -> a)
14:37:06 <merijn> There we go
14:37:15 <EvanR> > head cake
14:37:17 <lambdabot>  Not in scope: ‘cake’
14:37:17 <lambdabot>  Perhaps you meant one of these:
14:37:17 <lambdabot>    ‘take’ (imported from Data.List),
14:37:17 <lambdabot>    ‘Seq.take’ (imported from Data.Sequence),
14:37:17 <lambdabot>    ‘BSLC.take’ (imported from Data.ByteString.Lazy.Char8)
14:37:44 <wdasdfasrasf> jfischoff: but doesn't parens require parentheses? i.e. wouldn't work on a flat expression like 1+13+12
14:37:53 <EvanR> the 42-step cake recipe is gone : (
14:38:06 <jfischoff> wdasdfasrasf: it works
14:38:08 <jfischoff> try it
14:38:12 <merijn> digitalmentat: const just takes an argument and throws it away. The new signature forces const to take a function, fix the function's type from the "thrown away" argument and return the initial function, but now with a restricted type (inferred from the second argument)
14:38:21 <jfischoff> gives: [(Int 1,"+2+3"),(Plus (Int 1) (Int 2),"+3"),(Plus (Plus (Int 1) (Int 2)) (Int 3),"")]
14:38:37 <jfischoff> which I think is ReadP’s way of working
14:39:53 <merijn> diginet: So the 'a' in "const :: a -> b -> a" is the "a -> b" in myAppliedTo, the "b" in "const :: a -> b -> a" is the 'a' (again) in myAppliedTo
14:40:20 <merijn> :t let myAppliedTo :: (a -> b) -> a -> (a -> b); myAppliedTo = const in (<*>) `myAppliedTo` Just (+) -- parenthesis for clarity
14:40:21 <lambdabot> Num a => Maybe (a -> a -> a) -> Maybe a -> Maybe (a -> a)
14:40:26 <DarkCthulhu> I'm getting a result of my evaluation, which is Just(bla) while I want just bla.
14:40:36 <DarkCthulhu> I want bla rather
14:41:55 <DarkCthulhu> does that make sense? O_o
14:42:12 <geekosaur> what do you want if it produces Nothing?
14:42:58 <DarkCthulhu> err.. let me post some of the code
14:44:14 <Cale> DarkCthulhu: case ... of Just x -> x; Nothing -> ...
14:46:06 <DarkCthulhu> http://lpaste.net/3064459157106065408
14:46:12 <DarkCthulhu> the last few lines contain what my execution did
14:46:21 <DarkCthulhu> I expect the function return type to be Maybe Term
14:46:45 <wdasdfasrasf> jfischoff: thanks i'll play around with it
14:46:48 <DarkCthulhu> but it is all wrapped in a Just
14:46:56 <geekosaur> yes, which gives you Just a value or Nothing
14:47:14 <geekosaur> you must decide what to do with the Nothing if you want to get rid of the Just
14:49:39 <merijn> I think what he really just needs to do is fmap his eval function
14:50:53 <DarkCthulhu> My mistake.. It is supposed to return Just that value or nothing as geekosaur said. I need to take the cases apart after that
14:51:04 <merijn> That or (>>=)
14:51:27 <ski> DarkCthulhu : what about my approach ?
14:51:31 <merijn> @let data Term = Term
14:51:34 <lambdabot>  Defined.
14:51:50 <merijn> :t (>>=) `asAppliedTo` Just Term
14:51:51 <DarkCthulhu> ski, The recursive one?
14:51:51 <lambdabot> Maybe Term -> (Term -> Maybe b) -> Maybe b
14:52:32 <DarkCthulhu> ski, I will try that out after I finish. It did seem more concise than this.
14:53:53 <ski> DarkCthulhu : if you prefer, you could skip the `Maybe's (returning the irreducible term, aka value, instead of `Nothing'), and instead litter your code will lots of `isValue' calls
14:54:37 <ski> DarkCthulhu : but i think if you have `eval1 :: Term -> Maybe Term', then you really should also have `evalRecs :: [(Key,Term)] -> Maybe [(Key,Term)]' and `evalRec :: (Key,Term) -> Maybe (Key,Term)'
14:55:04 <ski> DarkCthulhu : if you don't like that, then i think you should have `eval1 :: Term -> Term'
14:55:04 <DarkCthulhu> ski, Yeah, I thought of that, but then I have already type-checked the record at the time of construction
14:55:19 <wdasdfasrasf> jfischoff: tried with this: http://lpaste.net/6544575778716123136 -- but it's just parsing the "12"
14:55:30 * ski isn't sure what type-checking of records has to do with this ..
14:55:51 <DarkCthulhu> ski, The values in key->value are all well-typed and hence should evaluate.
14:55:59 <DarkCthulhu> so, I thought I could skip the Maybes there
14:56:22 <jfischoff> wdasdfasrasf: I think it is because of the ‘head’ in your parseString
14:56:36 <jfischoff> that is given the first parse, but you want the maximal parse?
14:56:39 <jfischoff> which is last
14:56:45 <wdasdfasrasf> ah i get it
14:56:49 <jfischoff> I think, I’m not readP expert
14:56:57 <wdasdfasrasf> brain fart, didnt think it'd return all parses
14:57:16 <jfischoff> yeah it does something like that
14:59:24 <wdasdfasrasf> thanks a bunch, i think i get it now
14:59:28 <ski> DarkCthulhu : i used `Maybe' not for expressing a run-time error, but for expressing when a given term is a value, and hence can't be reduced anymore
14:59:45 <DarkCthulhu> ski, Ah..
14:59:58 <DarkCthulhu> ski, Which is why you didn't need isValue calls
15:00:00 <DarkCthulhu> right?
15:00:15 <DarkCthulhu> I have a guard which evaluates only if it is not a value
15:00:18 <ski> DarkCthulhu : an alternative is to return the same term (value), in case it is a value. then checking with `isValue' will tell if we need to continue reducing or not
15:00:28 <DarkCthulhu> yeahh
15:00:42 <ski> DarkCthulhu : but if we return `Nothing' in case the input was already a value, then we don't need to check with `isValue' at all :)
15:01:07 <ski> DarkCthulhu : so, it's just two different ways to keep track of whether we should continue reducing or not
15:01:16 <DarkCthulhu> Understood. Cool!
15:01:35 <DarkCthulhu> Maybes seem like a huge bother though -_-
15:01:49 * ski thinks `isValue' is a greater bother :)
15:01:56 <ski> @where boolean-blindness
15:01:57 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:02:35 <ReinH> +1
15:03:22 <ski> the general point is that `Maybe T' is better than `(Bool,T)'
15:03:50 <ski> maybe getting a `T' is better than getting a boolean and a `T', the boolean saying whether you should ignore the given `T' or not
15:04:29 <ski> in this (above) case the boolean was hidden behind your `isValue :: Term -> Bool' function, but the same point applies
15:05:08 <ski> DarkCthulhu : but, by all means, go (at least initially) with the approach that seems to make most sense to you, making it work
15:05:26 <ReinH> And sometimes names are useful even though the denotation doesn't change Success result | Failre vs Maybe result might actually be nice.
15:05:29 <ReinH> *Failure
15:05:41 <ReinH> trifecta uses a data type isomorphic to Either with nicer names, for instance
15:05:49 <DarkCthulhu> ski, I see your point, but coming from an imperative world, it'll be a while before the Maybes and Justs make complete sense to me :(
15:06:02 <ReinH> DarkCthulhu: Fair enough, although it will happen faster the more you use them ;)
15:06:20 * ski . o O ( `data Vel a b = Sinister a | Dexter b' )
15:06:31 <jfischoff> DarkCthulhu: Maybes are used in the imperative world.
15:06:39 <DarkCthulhu> try...catch?
15:06:52 <EvanR> "returns null if not found / failure"
15:06:55 <josephle> they're just not very explicit, those Maybes
15:06:58 <ReinH> ski: :p
15:07:06 <ski> DarkCthulhu : practically speaking, one advantage to `Maybe' is that you can't accidentally forget to consider the `Nothing' case, and what should happen then
15:07:08 <DarkCthulhu> yeah.. except they're not one type :D
15:07:09 <SwashBuckla> I really dig Haskell's pattern matching and support of UnicodeSyntax
15:07:12 <DarkCthulhu> or whatever that is
15:07:15 <SwashBuckla> (*) (Matrix a₁₁ a₁₂ a₂₁ a₂₂) (Matrix b₁₁ b₁₂ b₂₁ b₂₂) = (Matrix (a₁₁*b₁₁ + a₁₂*b₂₁) (a₁₁*b₁₂ + a₁₂*b₂₂) (a₂₁*b₁₁ + a₂₂*b₂₁) (a₂₁*b₁₂ + a₂₂*b₂₂))
15:07:17 <exio4> all their types live in the maybe type
15:07:20 <ReinH> SwashBuckla: nice
15:07:25 <jfischoff> Maybes tend to be called Optional outside of Haskell
15:07:25 <DarkCthulhu> ski, Hmm.. That is nice
15:07:30 <exio4> and the monadic case for nothing >>= f is crash
15:07:37 <jfischoff> and they are used in many languages FP and OO
15:07:46 <EvanR> DarkCthulhu: thats the thing, you have to keep all this straight in your head in a dynamic language
15:08:00 <ReinH> exio4: null pointer error ftw
15:08:11 <josephle> Optional a = Some a | None
15:08:11 <EvanR> its still there, still to be considered
15:08:21 <josephle> still not sure if I prefer Option(al) or Maybe
15:08:22 <ski> EvanR : domain contagion
15:08:49 * ski senses an MLer
15:09:10 <ski> (little or not, i can't say)
15:09:21 <josephle> hehe
15:09:30 <EvanR> newEmptyMLer
15:13:10 * ski . o O ( I'm a little MLer, short and stout. Here's my option, here's my stdOut. )
15:13:23 <SwashBuckla> :D
15:13:49 <EvanR> Just is a weird name for what it is
15:13:55 <EvanR> maybe Only
15:14:20 <EvanR> Some
15:14:33 <SwashBuckla> Thing
15:14:38 <EvanR> nice
15:14:45 <EvanR> would not confuse
15:15:07 <SwashBuckla> Maybe = Thing a | Nothing
15:15:16 <DarkCthulhu> What is a "do nothing" sort of statement in Haskell?
15:15:23 <DarkCthulhu> If something is Nothing, I want it to just ignore it
15:15:29 <DarkCthulhu> within a case statemet
15:15:33 <DarkCthulhu> statement*
15:15:37 <EvanR> return ()
15:15:44 <ski> what should be the result of the `case'-expression ?
15:15:59 <DarkCthulhu> Maybe Term
15:15:59 <SwashBuckla> yeah, it kinda depends on the context
15:16:21 <SwashBuckla> you might want to output the original input
15:16:23 <EvanR> Nothing is already a Maybe Term
15:16:30 <vanila> instead of case x of ...
15:16:34 <vanila> maybe you can write  y <- x
15:16:42 <vanila> using the do notation
15:16:45 <EvanR> heres a do nothing statement in haskell https://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
15:17:18 <SwashBuckla> lol
15:18:06 <SwashBuckla> (please never use this)
15:18:10 <ski> DarkCthulhu : are you casing on a `Maybe Term' ?
15:18:25 <ski> DarkCthulhu : and in the `Nothing' case, you want to evaluate to `Nothing' ?
15:18:38 <ski> in that case, you could use `fmap'
15:18:52 <ski> > fmap (10 +) (Just 3)
15:18:54 <lambdabot>  Just 13
15:18:56 <ski> > fmap (10 +) Nothing
15:18:58 <lambdabot>  Nothing
15:19:08 <DarkCthulhu> ski, I'm using casing on the lookup within the [(String, Term)] list
15:19:10 <ski> > map (fmap (10 +)) [Just 3,Nothing,Just 7]
15:19:11 <lambdabot>  [Just 13,Nothing,Just 17]
15:19:43 <ski> DarkCthulhu : ok, so on `Nothing' you probably want to signal a run-time error for label not found ?
15:20:13 * ski also suggests DarkCthulhu use `type Label = String' instead of `String' in record terms and types
15:20:14 <DarkCthulhu> ski, Yeahh.. you're right. an error is the right thing to do
15:20:30 <DarkCthulhu> ski, Yeah, I just wrote String here. I'm using type Key = String.
15:20:40 <ski> DarkCthulhu : because, if the term typechecked correctly this should never happen
15:20:50 <EvanR> unforgivingLookup :: b -> [(a,b)] -> a
15:21:01 <EvanR> oops
15:21:10 <EvanR> a -> [(a,b)] -> b
15:21:20 <DarkCthulhu> ski, err.. the projection only checks type of the records, not whether the key exists in that list
15:21:26 <Hijiri> shamefulRecklessLookup
15:21:32 <DarkCthulhu> *the typechecker only checks that
15:21:49 <DarkCthulhu> oh wait
15:21:50 <DarkCthulhu> no
15:21:52 <DarkCthulhu> you're right
15:22:00 <EvanR> button is a valid value for b anyway might as well use it ;)
15:22:05 <EvanR> bottom*
15:22:42 <DarkCthulhu> ski, Yeah, if the typechecker worked, it shouldn't ever hit the Nothing. So, I do need to simply return TmUnit maybe
15:22:50 <ski> DarkCthulhu : the right typing rule should say that `j' is to be between `1' and `n' (inclusive) -- i suppose they took that for granted
15:23:26 <ski> DarkCthulhu : why `TmUnit' ? :(
15:23:55 <ski> DarkCthulhu : if you can't return something sensible, don't return something unsensible
15:24:10 <DarkCthulhu> ski, But I do need to handle the Nothing case in a lookup right?
15:24:27 <ski> yes. you can e.g. call `error' to signal the problem
15:24:27 <EvanR> if the lookup cant fail you need another type
15:24:51 <ski> or you can reify the error into a new type that contains either an error condition, or a normal result
15:24:58 <ski> (which is what EvanR said)
15:25:29 <EvanR> i said it but i have no idea how id do it
15:25:36 <ski> `error' might be simplest, for now
15:26:01 <EvanR> error "the unpossible has occurred"
15:26:29 <DarkCthulhu> okay
15:26:32 <DarkCthulhu> sound good
15:27:50 <DarkCthulhu> http://lpaste.net/6814129846063464448
15:27:53 <DarkCthulhu> This weird error
15:27:55 <DarkCthulhu> :-|
15:28:10 <posco> where is it defined what packages are in scope when one uses ghci?
15:28:41 <posco> i.e. when I import a module, and :load the file, how are the modules resolved?
15:29:19 <geekosaur> via the package databases; if you haven't specified otherwise than what ghc-pkg shows you
15:29:41 <DarkCthulhu> ski, did you see my above paste?
15:29:51 <DarkCthulhu> I know that getAssoc works, because I tested it separately
15:30:13 <geekosaur> you wanted let there, not <-
15:30:44 <edwardk> ReinH: well, bound does. does trifecta too?
15:30:46 <geekosaur> since you're working in Maybe, <- expects a Maybe value
15:31:02 <DarkCthulhu> ohh
15:31:11 <ski> DarkCthulhu : btw, if you make the paste public (and set the channel to `#haskell'), lpaste will automatically announce it in here
15:31:15 <edwardk> Result is restricted to Doc
15:31:23 <DarkCthulhu> ah..
15:31:40 <edwardk> andit has different semantics in its alternative
15:31:42 <posco> geekosaur: thanks.
15:31:58 <ski> DarkCthulhu : also, if you use the "Annotate" option at the paste, your new paste update will appear at the same page as the earlier one, instead of at a new page
15:32:25 <DarkCthulhu> ski, ohh.. okay. That's convenient!
15:32:36 <DarkCthulhu> The evaluator works :)
15:32:37 <DarkCthulhu> at last
15:33:23 <ski>   eval1 (TmProj (TmRecord assoc) key) = case lookup key assoc of ...
15:33:26 * hackagebot semigroups 0.15.4 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15.4 (EdwardKmett)
15:33:28 <ski> DarkCthulhu : you can do something like that ^
15:33:36 <lpaste> DarkCthulhu pasted “Success at last!” at http://lpaste.net/113545
15:33:41 <ski> nested pattern-matching
15:34:03 <DarkCthulhu> ski, ohh.. that would eliminate the need for that helper function
15:34:11 <ski> exactly
15:34:39 <ski> (which wouldn't work anyway, since its type was wrong / it was used in a wrong way for its type)
15:34:49 <geekosaur> posco: the options in https://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#package-databases apply to ghci if you want to use a different user package database (e.g. a sandbox, although in that case you really want cabal repl)
15:35:18 <marchelzo_> When compile C code by invoking ghc, how do you pass flags to the C compiler? std=c11 in particlar
15:35:24 <DarkCthulhu> ski, The helper did work, but this is much better.
15:35:29 <marchelzo_> s/compile/you compile/
15:36:11 <geekosaur> -optc
15:36:35 <geekosaur> marchelzo_, https://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#forcing-options-through
15:37:10 <marchelzo_> geekosaur: thanks! :)
15:37:35 <geekosaur> so -optc -std=c11 should work
15:37:53 <DarkCthulhu> Does it make sense to carry out alpha-substitutions and beta-reductions on a record?
15:38:51 <ski> DarkCthulhu : you also used `snd' somewhere, when you could have used nested pattern-matching instead
15:39:02 <DarkCthulhu> let me see
15:39:19 <ski> DarkCthulhu : alpha, not on the record itself, but surely on terms inside it
15:39:55 <ski> DarkCthulhu : the top left evaluation rule in your pic is sometimes called the beta rule for records
15:40:10 <DarkCthulhu> ahh
15:40:14 <ski> DarkCthulhu : and, just as before, you can also perform beta on terms inside records
15:40:27 <DarkCthulhu> ski, beta on terms inside the record? How?
15:40:33 <DarkCthulhu> I mean how would someone invoke that
15:41:00 <DarkCthulhu> Because the record itself is going to evaluate to a value type.
15:41:07 <ski>        {key1=(\x:unit.x) unit , key2=(\x:nat.x) 33} . key2
15:41:19 <mbuffett> Hey guys, I'm not sure if this is the right place to ask questions, got here through the haskell website, can I ask a couple noob questions or is there a better place?
15:41:23 <ski>   -->  {key1 = unit,key2= (\x : nat. x) 33} . key2
15:41:29 <ski>   -->  {key1 = unit,key2 = 33} . key2
15:41:34 <ski>   -->  33
15:41:47 <DarkCthulhu> ski, Oh.. okay. That was the beta rule. I guess the small-step evaluator took care of that
15:42:00 <ski> DarkCthulhu : the first two steps are beta-reductions inside a record construction (inside a record projection)
15:42:16 <ski> beta for functions, i.e.
15:42:19 <DarkCthulhu> hmm
15:42:31 <ski> the last step could be called a beta reduction for records
15:42:54 <ski> mbuffett : you can ask here
15:43:02 <DarkCthulhu> ski, I was thinking along rules like: substitute (x, v) (TmVar n) | x /= n = TmVar n
15:43:07 <DarkCthulhu> the ones which rename variables within
15:43:53 <ski> well, substitution is about replacing *free* variables by arbitrary terms
15:44:10 <ski> alpha-conversion is about renaming *bound* variables
15:45:52 <DarkCthulhu> ski, Why would someone need to rename a particular variable in very value within a record?
15:46:38 <xcv_> mbuffet: sure, I'll try to answer them
15:46:48 <xcv_> mbuffett*
15:48:17 <ReinH> edwardk: Ok, a monomorphic Either-like thing :p
15:48:27 <mbuffett> Cool, so let's say I have a list of Strings and I want to have a function that asks the user for input and then adds it to the list, how do I do something like this? Coming from Python and I'm having a good bit of trouble grasping the whole 'no variables thing'
15:48:34 <ReinH> edwardk: your correction is appreciated
15:48:50 <rai> is it possible to write this out (+) <$> (+4) <*> (+2) $ 5 .. using f <*> g = \x -> f x (g x), because i just can't get it working.
15:49:29 <xcv_> mbuffett: do you know the number of strings you are going to need in advance?
15:50:08 <mbuffett> Nope, just have a empty list to begin with and then the user can keep adding a lot or just add one
15:50:14 <rola> in this pic http://i.imgur.com/lp3Aygb.png , how does f enter scope and why doesn't it need a "forall f ."? this is from this talk on lenses ~16 min in https://skillsmatter.com/skillscasts/4556-simon-peyton-jones
15:50:34 <xcv_> an easy way to emulate mutability is recursion so you pass a different initial value every time
15:50:42 <xcv_> what are you trying to write exactly?
15:51:27 <mbuffett> Just a small useless program that asks a user what he wants to do, adds to a list of strings if he says 'add', and prints out the list if he says 'done'
15:51:42 <indiagreen> rai: you forgot to add a fixity declaration
15:52:10 <indiagreen> without it, <*> is applied before <$>
15:52:20 <absence> are there any common uses of Either where Left represents just as valid data as Right, rather than some kind of failure?
15:53:28 <mbuffett> so after the user says add I have a function addString which takes the current list as an argument, basically just input <- getLine, then strings ++ [input], but GHC doesn't like it
15:53:30 <merijn> mbuffett: There's variables, but not mutable ones. The simplest approach to what you want would be to have a recursive function that takes a list as argument and every iteration does "add new item? if yes, call self with old list + new item. if no, print list"
15:53:41 <indiagreen> > ((+) <$> (+4)) <*> (+2) $ 5 where f <*> g = \x -> f x (g x) -- rai
15:53:43 <lambdabot>  <hint>:1:29: parse error on input ‘where’
15:53:53 <merijn> mbuffett: Put your current code on lpaste.net?
15:54:02 <indiagreen> > let f <*> g = \x -> f x (g x) in ((+) <$> (+4)) <*> (+2) $ 5 -- rai
15:54:03 <yukko> absence sometimes I use Either a a instead of (Bool, a)
15:54:04 <lambdabot>  16
15:54:06 <mbuffett> Sounds good, I'll post a link in a second
15:54:11 <yukko> but that's not really a very good example
15:54:11 <mbuffett> Thanks for helping out a noob
15:55:01 <Hijiri> when I have valid data under two constructors I usually declare my own data type
15:55:36 <xcv_> mbuffett: perhaps you should try to write other kind of programs when starting
15:55:49 <xcv_> Haskell isn't that good at easy IO
15:55:58 <absence> yukko: yeah.. seems really common to use (,) for returning "anonymous" product types, but for some reason the same seems to be rarely done with Either
15:56:26 <Welkin> you just need to get used to the IO
15:56:32 <Welkin> it's not difficult
15:56:55 <merijn> xcv_: I disagree, this is not particularly hard
15:57:05 <supki> rola: I think the forall is omitted to fit everything on the slide nicely
15:57:07 <tdammers> that's because IO was kind of an afterthought :D
15:57:10 <merijn> It just requires you to get used to the immutable way of doing things
15:57:20 <supki> rola: real haskell code won't compile without it there
15:57:25 <merijn> tdammers: I disagree with that too
15:57:35 <rai> indiagreen: what does (+) <$> (+4) translate into?
15:57:42 <xcv_> my point is that getting used to "the immutable way of doing things" is easier when your functions don't involve much IO
15:57:57 <xcv_> starting with "given this input, compute that"
15:58:04 <merijn> I wish people in here would downplay IO less, I write tons of IO heavy haskell and somehow pretending it's hard/complex is harmful for people interested in writing the same sort of code
15:58:21 <yukko> merijn I think that's a great point
15:58:29 <merijn> xcv_: Right, but then you still need to know how to plug pure code into your IO loop
15:58:36 <tdammers> merijn: that was tongue-in-cheek
15:58:42 <tdammers> merijn: but with a grain of truth to it
15:58:48 <yukko> IO in Haskell is actually quite easier than in languages like C where you have to worry about things like memory allocation and free() and etc
15:58:57 <yukko> at least, simple IO is
15:59:14 <merijn> tdammers: Perhaps, but I wish people would not respond with tongue-in-cheek jokes to newcomers who will be unable to tell that they're jokes
15:59:25 <xcv_> merijn: Yes, but I remember that my first Haskell programs consisted pretty much of a readLine and a print with a call to some function in the middle
15:59:28 <DarkCthulhu> I think I'm done. thanks all! ski, monochrom, merijn, everyone else too. I owe most of my understanding to this channel :D
15:59:29 <tdammers> merijn: ah, yes, that may have been a bit inappropriate
15:59:35 <monochrom> congrats
15:59:38 <merijn> yukko: Even complex streaming IO is pretty good when you look at pipes/conduits :)
15:59:47 <joelteon> this just in: writing garbage-collected code is easier than manual memory management
16:00:48 <indiagreen> rai: it translates to \x y -> (x+4) + y
16:00:49 <rola> supki, ah ok, so it's omitted because of limited space on slides. i was confused because they used it in another slide
16:02:00 <exio4> joelteon: abstracting patterns is easier in HS (basically "polymorphism done right", IMO)
16:02:44 <mbuffett> http://lpaste.net/113547
16:03:39 <merijn> mbuffett: Well, to start "main" always has to have a type compatible with "IO a", usually people use "IO ()", it can't take any arguments
16:04:45 <merijn> mbuffett: I would also recommend always writing down top level signatures for 2 reasons: 1) to help remind you what you intended and 2) because a lot of people here (including me) are usually to lazy to try and figure out what they're supposed to be
16:04:52 <rai> indiagreen: i see.. so you sort of compose functions but arity increases
16:05:08 <merijn> Lemme sketch out an alternative
16:06:01 <joelteon> always use top level signatures
16:06:08 <joelteon> type inference is just there to help you write code
16:06:34 <yukko> there are some cases where it's better to not write type signatures
16:06:42 <Welkin> this is the first time I have built my own content management system to manage the backend of my site
16:06:53 <exio4> I actually like to write the type signature _before_ startin to write code (while "it is easily possible")
16:07:06 <Welkin> last time I just used shell scripts and would use the DB's shell to manage it directly
16:07:08 <yukko> sometimes you want to change your types a bit and that becomes harder when everything is explicitly typed, because sometimes when you change your types your equations are still valid
16:07:10 <exio4> starting*
16:07:25 <Welkin> it is actually incredibly fun and clean with yesod
16:07:33 <indiagreen> rai: perhaps you should think about it not as “functions” but as “environment-dependent values” (which is kinda the same, but from a different perspective). Then “(+4)” is an environment-dependent value which is just “environment + 4”
16:07:35 <Welkin> last time I used python...
16:07:43 <tdammers> python is great
16:07:47 <mbuffett> Sounds good, I'll make sure to write the type signature every time, weird change coming from python where I never have to think about types
16:07:51 <tdammers> until your program becomes larger than a screenful
16:08:17 <indiagreen> rai: then, remember that all functions are 1-argument functions, so (+) is a function which takes a value and returns an adder. Like, “(+) 17” is a 17-adder
16:08:25 <Welkin> I limit my python use to shell scripts, nothing else
16:08:42 <Welkin> in fact, lately I have been writing little command line utilities in haskell instead
16:09:06 <rai> indiagreen: to me it makes sense to think about partially or non-partially applied functions
16:09:35 <indiagreen> rai: so, (+) <$> (+4) is an environment-dependent adder, which makes sense for me but I'm slightly afraid I'm talking about burritos now
16:10:07 <rai> yeah it doesn't make much sense to me
16:12:42 <merijn> mbuffett: The expected type being different is because parseInput takes *both* a String and a [String], but you're only giving it one argument
16:13:20 <lpaste> merijn annotated “Code that fails” with “Code that fails (annotation)” at http://lpaste.net/113547#a113548
16:13:36 <merijn> mbuffett: See that (way) simplified annotation
16:14:53 <clandest> could anyone point me in a direction if I wanted to take a sound file and trim it how ever I would like?
16:16:06 <Welkin> > (fmap (++) (++ ['a'])) ['b'] ['c']
16:16:08 <lambdabot>  "bac"
16:17:20 <ski> DarkCthulhu : perhaps the record construction is a part of an abstraction body, and we want to rename the variable bound by the abstraction
16:18:56 <rai> Welkin: cool
16:19:26 <rai> indiagreen: thanks. will go to sleep and continue tomorrow
16:19:44 <indiagreen> rai: I'll write a more detailed explanation for you
16:20:09 <mbuffett> merijn: Thanks, that helps a lot. I'll keep trying at it and I'll probably be back here with more stupid questions soon, thanks a lot!
16:21:46 <ski> rola : i think the `forall f.' on the signature for `modF' is implicit there. i'm not sure i like it
16:22:32 <ski> mbuffett : instead of `print' you probably want `putStrLn'
16:22:56 <merijn> ski: It depends, currently he's outputting a list
16:23:31 * hackagebot barcodes-code128 0.1.0 - Generate Code 128 barcodes as PDFs  http://hackage.haskell.org/package/barcodes-code128-0.1.0 (dchristiansen)
16:23:51 <mbuffett> Is there a difference between print and putStrLn if I'm dealing with strings?
16:24:11 <zwer_b> @src print
16:24:11 <lambdabot> print x = putStrLn (show x)
16:24:23 <ski> mbuffett : oh, i meant the initial `print' in `main' (and merijn's `inputLoop'), the one(s) that a string is passed to
16:25:02 <emmanueloga> Hey. This is an abstract question. I wonder, what are the implications of :t True returning Bool, but :t Bool returning an error? Is this limiting in any way? What are some practical implications?
16:25:30 <mbuffett> So it just makes for cleaner code to write putStrLn when it's a String? Or is there another reason to prefer putStrLn when possible?
16:25:31 <exio4> emmanueloga: haskell isn't dependantly-typed
16:27:16 <josephle> :k Bool
16:27:17 <lambdabot> *
16:27:28 <josephle> But haskell does have kinds!
16:28:04 <zwer_b> mbuffett try both putStrLn "hello\nworld\n" and print "hello\nworld\n" in ghci
16:28:41 <emmanueloga> hmmm I keep hearing about dependent types, w/o knowing much about it I thought they (DTs) allowed you to express constraints like "SomeType = Naturals bigger than 5", which doesn't seem doable with haskell type system.
16:29:34 <emmanueloga> so not sure how it relates to :t Bool returning an error. I was expecting :t Bool to return "Type" or something like that. That's how naive I am hah
16:29:50 <Ralith> that is exactly what :t Bool returns in Idris
16:33:42 <ReinH> emmanueloga: You can do that with Haskell, actually. DT lets you do something a bit more powerful: a type that *depends on* a value. So you can change the type of something based on the value of something else.
16:34:28 <ReinH> emmanueloga: This talk might help https://www.youtube.com/watch?v=vkIlW797JN8
16:34:57 <ReinH> emmanueloga: and especially this one: https://www.youtube.com/watch?v=4i7KrG1Afbk
16:35:32 <ReinH> emmanueloga: and also his other videos https://www.youtube.com/user/pufuwozu
16:35:54 <ReinH> Well, mostly the two Idris vieos
16:37:33 <Eduard_Munteanu> emmanueloga, you probably want :k Bool
16:37:38 <Eduard_Munteanu> :k Bool
16:37:40 <lambdabot> *
16:41:13 <emmanueloga> ReinH: txs, I'll check that out!
16:41:19 <ReinH> emmanueloga: ofc!
16:42:14 <emmanueloga> Eduard_Munteanu, josephle: txs. I think I'll defer learning more about kinds (and idris!) until I get a better grasp of the language.
16:42:39 <Eduard_Munteanu> emmanueloga, mind some of those naturals tricks are doable in Haskell with DataKinds and similar extensions.
16:43:12 <Eduard_Munteanu> :k 'True
16:43:13 <lambdabot> Bool
16:43:52 <parablee> y'all
16:47:55 * emmanueloga takes note of DataKinds
16:54:38 <s4msung> http://cursors.io/
16:57:34 <absence> is there an easy way to convert (a, m b) to m (a, b) where m is monad? i seem to recall there was, but i can't remember if it was lens or something simpler
16:59:01 <ski> @type uncurry (fmap . (,))
16:59:03 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
16:59:12 <ski> aka `strength'
16:59:20 <simpson> :t (a, mb) -> mb >>= (a,)
16:59:21 <lambdabot> parse error on input ‘->’
16:59:27 <zwer> absence how did you end up with (a, m b)?
16:59:35 <simpson> Er. You get the idea.
17:01:41 <absence> zwer: by trying too hard to be clever :|
17:01:42 <Welkin> spending Halloween with Haskell
17:01:53 <absence> ski: strength?
17:02:08 <Welkin> I thought of HM05 when you said "strength"
17:02:45 <Welkin> oh
17:02:49 <Welkin> that is HM4
17:03:08 <sipa> @pl \(a, b) -> b >>= \x -> (a, b)
17:03:09 <lambdabot> uncurry (ap (>>=) . (const .) . (,))
17:03:29 <sipa> @type \(a, b) -> b >>= \x -> (a, b)
17:03:31 <lambdabot> Monad ((,) t) => (t, (t, a)) -> (t, (t, a))
17:17:06 <jle`> gotta have strength
17:17:28 <jle`> absence: it's in Data.Traversable
17:17:40 <absence> :t strength
17:17:41 <lambdabot> Not in scope: ‘strength’
17:17:49 <jle`> it's called strength in mathematics but
17:17:52 <jle`> not in haskell
17:18:02 <jle`> > traverse ("hello", Just 7)
17:18:04 <lambdabot>  Couldn't match expected type ‘a -> f b’
17:18:04 <lambdabot>              with actual type ‘([GHC.Types.Char], Data.Maybe.Maybe a0)’
17:18:09 <jle`> um
17:18:23 <jle`> > sequenceA ("hello", Just 7)
17:18:25 <lambdabot>  Not in scope: ‘sequenceA’
17:18:25 <lambdabot>  Perhaps you meant one of these:
17:18:25 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
17:18:25 <lambdabot>    ‘sequence’ (imported from Control.Monad.Writer),
17:18:25 <lambdabot>    ‘T.sequence’ (imported from Data.Traversable)
17:18:29 <jle`> > T.sequenceA ("hello", Just 7)
17:18:31 <lambdabot>  Just ("hello",7)
17:18:40 <jle`> strength exists in haskell as sequenceA
17:19:27 <jle`> > T.sequenceA ("hello",[1,2,3,4])
17:19:29 <lambdabot>  [("hello",1),("hello",2),("hello",3),("hello",4)]
17:19:58 <absence> oh right! that's the one i used before, thanks :)
17:20:00 <jle`> :t T.sequenceA `asAppliedTo` (undefined, undefined)
17:20:01 <lambdabot> Applicative f => (t, f a) -> f (t, a)
17:20:55 <jle`> if your Monad doesn't have an Applicative instance for some reason
17:21:04 <jle`> :t T.sequence `asAppliedTo` (undefined, undefined)
17:21:05 <lambdabot> Monad m => (t, m a) -> m (t, a)
17:21:17 <jle`> although in truth you only need `Functor`
17:22:02 <jle`> i guess in that sense sequenceA isn't as powerful as true Strength
17:22:16 <jle`> :t \(x, fx) -> fmap (x,) fx
17:22:17 <lambdabot> Functor f => (t, f a) -> f (t, a)
17:25:35 <cellopin> after cabal sandbox init and cabal init.. Is there anything else I need to do?
17:26:42 <cellopin> I mean any standard packages that I need to install?
17:26:56 <jle`> cellopin: to do what?
17:27:24 <cellopin> Nothing right now.. but just the default packages
17:27:47 <jle`> you don't really need to do anything...
17:27:52 <codygman> How can I ignore any https errors with http-client? I'm assuming I'll need to make my own tlsmanager, does anyone have any examples?
17:27:58 <jle`> nobody is forcing you to do anything :)
17:28:03 <jle`> it all really depends on what you want...
17:28:20 <jle`> if you want to bake a cake, for example, then i think you're just fine as you are
17:28:59 <cellopin> oh i see
17:29:06 <jle`> what is your goal...?
17:29:07 <emmanueloga> hmmmm.... cake.
17:29:17 <acowley> Wait, there's cake?
17:29:35 <jle`> i don't even think you need to cabal sandbox init and cabal init...unless maybe someone is holding a loved one for ransom and requires it?
17:29:36 <bam365> the cake is a lie
17:30:06 <cacplate> Hi there, I'm trying to find some info on SampleVar, it seems to have been deprecated and if so, I would need to replace it with something else. Do you have a lead?
17:30:43 <Cale> http://hackage.haskell.org/package/SafeSemaphore
17:32:36 <cacplate> thank you
17:34:32 <ski> Welkin : "HM4" ?
17:35:00 <Cale> edwardk: Maybe it would be worth stealing the implementations of those things from SafeSemaphore to fix up the stuff in Control.Concurrent?
17:35:30 <Cale> I don't know how much code actually uses SampleVar, but it seems like something possibly worthwhile.
17:40:18 <absence> :t sequence . ((,) <*> readFile)
17:40:19 <lambdabot>     Couldn't match type ‘[m a]’ with ‘(FilePath, IO String)’
17:40:20 <lambdabot>     Expected type: FilePath -> IO String -> [m a]
17:40:20 <lambdabot>       Actual type: FilePath -> IO String -> (FilePath, IO String)
17:40:34 <absence> :t T.sequence . ((,) <*> readFile)
17:40:35 <lambdabot> FilePath -> IO (FilePath, String)
17:40:52 <emmanueloga> is there a way I could get a printout "GT LT EQ" from ghci if I know about "Ordering" ?
17:41:13 <absence> :t compare
17:41:15 <lambdabot> Ord a => a -> a -> Ordering
17:41:39 <absence> emmanueloga: ^
17:41:57 <emmanueloga> absence: right, but I want something like "magic: Ordering\nGT LT EQ"
17:43:35 <absence> ah, can't help you there
17:44:21 <Fuuzetsu> > unwords $ map show ([minBound ..] :: [Ordering])
17:44:23 <lambdabot>  "LT EQ GT"
17:44:35 <Fuuzetsu> ?
17:45:02 <Fuuzetsu> > unwords $ map show [minBound :: Ordering ..]
17:45:04 <lambdabot>  "LT EQ GT"
17:45:05 <Fuuzetsu> cleaner
17:45:43 <emmanueloga> Fuuzetsu: wicked!
17:46:45 <Cale> emmanueloga: Given what you asked, you might also just want to know about  :info Ordering
17:47:31 <Cale> Which will print out the definition of the type along with listing a bunch of instances that are defined for it
17:48:49 <emmanueloga> Cale: comparisons can be odious (pun intended), but your method is exactly what I was looking for.
17:48:57 <emmanueloga> and more.
17:51:06 <absence> :t liftM . (,) <*> readFile
17:51:07 <lambdabot> FilePath -> IO (FilePath, String)
17:51:18 <absence> can it get "cuter"?
17:51:52 <Welkin> I just rebuilt a website in haskell that was previously built in python
17:52:11 <Welkin> the difference in quality and ease of development is astonishing
17:58:25 <mietek> Any Haste users here?
17:58:51 <luite> i don't even know what that is ;)
17:59:17 <mietek> That's probably the right stance
17:59:24 <mietek> I'm having terrible issues just getting it to build
17:59:58 <schell> mietek - any reason not to use ghcjs?
18:00:12 <mietek> I am a tooling provider, not a user
18:00:20 <schell> ahh
18:00:35 <mietek> Trying to get https://github.com/mietek/tryhplay deploying properly
18:00:44 <schell> i thought the author hosted binaries, i’m not sure if that helps
18:01:10 <mietek> Ordinarily it would, but seeing as I'm working on a system which generates binaries of its own, no
18:01:12 <schell> if not - i’m sure it’s worth opening a ticket for
18:01:26 <mietek> Sure.  I'm just looking for anyone who actually uses Haste
18:01:35 <emmanueloga> ubuntu's default haskell is quite old.. is there an easy way to get latest haskell in ubuntu? I wonder if cabal can help with that.
18:01:36 <schell> i tried, but also had build problems
18:02:06 <schell> then i decided i would update haste’s build system to support 7.8.3
18:02:14 <schell> then i gave up :(
18:02:14 <mietek> schell: oh?
18:02:17 <mietek> Oh. :(
18:02:25 <mietek> Well, I have Haste building with 7.8.3
18:02:29 <schell> but a couple other people took up where i left off
18:02:33 <mietek> The problem is, by default, it hardcodes ~/.haste
18:02:41 <schell> mietek: then you’re already farther than i was!
18:02:59 <mietek> And I need to at least have it hardcode a different path
18:03:04 <schell> maybe fork the repo and replace the hardcoding to your own path?
18:03:09 <schell> right
18:03:11 <mietek> But I thought I'd just use this -fportable flag which is advertised
18:03:19 <mietek> But!  With that flag, it doesn't even link
18:03:49 <mietek> emmanueloga: yes, there is an easy way.
18:03:51 <Cale> emmanueloga: What I usually do is ignore my distribution's packages and just install the generic linux binary from the GHC website
18:03:51 <schell> i would tell you to talk to the author but he seemed pretty dang busy - but maybe you’ll have more luck
18:03:55 <mietek> emmanueloga: are you feeling experimental?
18:04:10 <Cale> emmanueloga: and then grab the cabal-install tarball from hackage and install that
18:04:18 <Welkin> what are you using haste for?
18:04:23 <Welkin> anything in particular?
18:04:30 <Welkin> front-end web?
18:04:33 <Welkin> games?
18:04:47 <mietek> I am working on Haskell deployment infrastructure.
18:05:00 <mietek> Currently, I'm preparing motivational examples before I go public.
18:05:02 <emmanueloga> mietek: do you mean 7.8.3 is experimental?
18:05:04 <heatsink> Cale: Can you just install cabal-install?  I thought you needed network, HTTP, and a few other packages first.
18:05:25 <Cale> There's a bootstrap.sh script in the tarball which will do that stuff for you
18:05:28 <heatsink> oh
18:05:32 <emmanueloga> ubuntu ships 7.6.3... I tried ghci --colour and got an error, but got me thinking I may be using a quite old version.
18:06:05 <Welkin> just install haskell platform form the website rather than ubuntu's repo
18:06:06 <mietek> emmanueloga: no, I mean I am literally working on a project which does this---installs Haskell for you.
18:06:08 <Welkin> from*
18:06:15 <mietek> https://github.com/mietek/halcyon
18:06:28 <emmanueloga> mietek: yes, I would be willing to experiment with such thing :) Checking it out.
18:07:32 <mietek> luite: do you have any good demo web apps for GHCJS?
18:07:34 <luite> mietek: it's a bit of a tricky problem in general. i went with wrapper scripts that pass a -B installation location (like GHC does) when rewriting the ghcjs installation scripts this summer. but the ~/.programname hardcoded location, isn't that the getAppUserDataDirectory location?
18:08:01 <luite> GHC uses that for its user package db (same goes for ghcjs)
18:08:03 <mietek> I haven't dug into Haste code yet.
18:08:34 <mietek> But I can say that moving packages from one machine, where ~ is /root, to another matchine, where ~ is /app, results in Haste complaining about broken packages, with paths referencing /root
18:08:54 <mietek> PureScript and Idris are much easier to deploy!
18:08:54 <luite> mietek: there are a few in the ghcjs-examples repo, try-purescript is interesting, http://hdiff.luite.com/tmp/try-purescript.jsexe/
18:09:00 <mietek> ha
18:09:12 <mietek> luite: https://github.com/mietek/trypurescript
18:09:55 <mietek> luite: https://trypurescript-h14.herokuapp.com
18:09:56 <luite> mietek: codeworld is a cool bigger app, but that's probably too complicated as a demo
18:10:26 <luite> mietek: yeah i've seen it. i just wanted something that didn't rely on the server :)
18:10:50 <luite> you can change the standard lib in try-purescript by editing the html
18:10:57 <mietek> Ah.
18:12:24 <luite> mietek: and this is the whole code https://github.com/ghcjs/ghcjs-examples/blob/master/try-purescript/Main.hs
18:12:29 <Yxven> purescript  is a Haskell subset that compiles to javascript, right?
18:12:41 <Welkin> it is a DSL
18:12:43 <luite> mietek: with a bit of glue JS that sets up codemirror and retrieves the contents
18:12:45 <Welkin> not a subset
18:12:56 <luite> Yxven: you're probably thinking of Fay
18:13:26 <mietek> PureScript is cool.
18:13:28 <luite> Yxven: PureScript is a Haskell-inspired strict language with static types and currying that is designed to compile to JS
18:13:42 <mietek> And extensible effect types.
18:13:52 <mietek> And JS semantics.
18:24:22 <jhafranco> :t fmap
18:24:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:25:33 <jhafranco> karma jhafranco
18:26:20 <jhafranco> preflex: karma bonus
18:27:02 <jhafranco> ??karma bonus
18:27:32 <jhafranco> ??
18:30:09 <fluffynukeit> hi. I'm having a problem with cabal.  I am writing a package for c bindings to CEF.  In addition to the library, the package has a test executable.  I have the .so file in the same directory as Main.hs.....
18:30:41 <fluffynukeit> but cabal can't find the .so file when linking, no matter what I put for exrta-libraries or extra-lib-dirs.  I get a missing dependency error
18:30:46 <marchelzo> So I'm trying for the first time to use the FFI, and when I try to compile my code, I get a linker error saying that the reference to a whole bunch of things from System.Random are undefined. (I'm trying to export an IO CString and use it in the C code) Why might this be happening?
18:31:43 <fluffynukeit> how can I specify the .so file correctly so cabal can find it?
18:31:50 <drdo> Why is nub O(n²)?
18:35:24 <geekosaur> because it only requires Eq
18:35:54 <geekosaur> you need something stronger (typically Ord) for better performance... but then it's also less lazy, and some programs rely on the laziness
18:36:28 <geekosaur> there is occasional discussion of providing a variant with Ord and better asymptotics/worse laziness; someday it might even happen
18:36:34 <drdo> well yes i was thinking the obvious thing to do was to keep some sort of set structure with logarithmic insertion/query
18:37:00 <geekosaur> but the current one has uses because it's maximally lazy
18:38:24 <exio4> > nub [1..]
18:38:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:39:22 <Cale> You can get similar laziness while taking advantage of Ord
18:39:24 <hyPiRion> geekosaur: is there any reason one using a set couldn't be just as lazy? It might burn some memory though
18:39:37 <Cale> e.g. by accumulating a Data.Set as you walk down the list
18:39:45 <drdo> It is lazy using Set, hence my question
18:49:01 <stepkut> I know tagsoup is good for screenscraping -- but it is also a good choice for transforming HTML? or should I be using something else like hxt?
18:54:18 <stepkut> actually .. tagsoup probably is what I want for this
18:54:32 <stepkut> it really is more of a screenscraping problem than a transformation
18:56:54 <Eduard_Munteanu> stepkut, also {html,xml}-conduit
18:58:25 <Eduard_Munteanu> tagsoup's tree stuff is a bit too strict sometimes.
19:09:36 <joshcough> hi. is there a way to get the repl to honor new lines in strings?
19:10:32 <joshcough> i mean, maybe i could do mapM_ putStrLn . lines  or something, but, just wondering by default.
19:13:48 <ReinH> joshcough: Haskell doesn't support multiline strings separated just by newlines
19:13:53 <geekosaur> I think you just want to use putStrLn?
19:14:10 <geekosaur> no need to apply lines or mapM_
19:14:16 <ReinH> Haskell multiline string syntax is like:
19:14:21 <ReinH> str = "multi\
19:14:21 <ReinH>         \line"
19:14:27 <geekosaur> ReinH, as I understand it they're complaining about the implicit Show
19:14:36 <ReinH> geekosaur: oh?
19:14:48 <ReinH> Ah, never mind then
19:16:48 <geekosaur> basically if you just have it display a value, it uses `print` aka putStrLn . show
19:16:54 <joshcough> geekosaur, putStrLn does it. thanks.
19:16:58 <geekosaur> so if you want a string printed as it is, use putStrLn
19:17:32 <joshcough> if you just leave the IO () alone to let the repl handle it, it doesnt honor them, but putStrLn fixes that. thank you.
19:17:50 <mgaut72> suppose I have a data type `data Foo = Bar String Int | Baz Char Int` what is the cleanest way to have a function f such that `f :: Foo -> Int` ?  Do I have to pattern match on Bar and Baz explicitly, or can I generalize further?
19:18:41 <geekosaur> you have to do it explicitly or define it in record syntax... or use a lens of some kind
19:19:42 <mgaut72> geekosaur: is there a way to get say the last element of a product type?
19:19:43 <geekosaur> data Foo = Bar { aString :: String, anInt :: Int} | Baz { aChar :: Char, anInt :: Int } -- and now f = anInt
19:20:11 <geekosaur> (note that this has limitations, and to go beyond them you're stuck with lens or generics)
19:20:27 <dramforever> mgaut72: why?
19:21:39 <dramforever> Yeah, maybe you have to use lens/generics to do so
19:23:58 <ski> joshcough : normally, if you type in an expression in the interactor, it will respond with a completely evaluated/reduced expression that is equal to the given one
19:24:50 <ski> so `3 > 2' gets `True' as a reply, since both are expressions representing the same value, and `True' is the completely reduced form of the given expression
19:25:25 <ski> joshcough : so, it's consistent with this that e.g. `"abc\n" ++ "def"' replies with `"abc\ndef"'
19:26:34 <ski> if you want it to output something, that's not a representation of an expression, you'll have to perform some I/O action (or define `Show' weirdly, but generally i don't think that's a good idea)
19:26:35 <joshcough> ski: thanks
19:27:23 <ski> `putStr' turns a string into an I/O action that when performed will output the characters in the string as is (rather than printing a representation of the string, as an expression)
19:27:40 <ski> `putStrLn' will add a newline to the end of the string before calling `putStr'
19:28:32 <ski> and `print' will first call `show' on the input to convert it to a string representing an expression evaluating to the value, and then call `putStrLn' on the result
19:28:36 <ski> @src print
19:28:37 <lambdabot> print x = putStrLn (show x)
19:28:42 <mgaut72> geekosaur: I like the record much better I think.  i was worried that my code that relied on pattern matching of non-record datatypes would break, but it looks like I can still pattern match, in the order things are declared in the record
19:28:42 <mgaut72> thaks
19:28:50 <ski> > "abc\ndef"
19:28:51 <lambdabot>  "abc\ndef"
19:28:52 <ski> > show "abc\ndef"
19:28:54 <lambdabot>  "\"abc\\ndef\""
19:28:56 <geekosaur> yep
19:56:29 <haasn> > show "abc\ndef"  ==  "\"abc\\ndef\""
19:56:31 <lambdabot>  True
20:02:19 <Welkin> > splitAt 1 ["a", "b", "c"]
20:02:21 <lambdabot>  (["a"],["b","c"])
20:03:45 <Welkin> can you pattern match in a let statement?
20:04:13 <geekosaur> > let (a,b) = (5,10) in a
20:04:15 <lambdabot>  5
20:04:25 <benmachine> > let Just x = Nothing in 5
20:04:27 <lambdabot>  5
20:04:41 <Welkin> > let ([a], b) = splitAt 1 ["a", "b", "c"] in a
20:04:41 <geekosaur> (the "statement" form in a do is not really different0
20:04:42 <lambdabot>  "a"
20:04:50 <Welkin> nice
20:04:51 <Welkin> thanks
20:17:10 <ski> > let [a]:b = ["a","b","c"] in a  -- Welkin
20:17:12 <lambdabot>  'a'
20:17:19 <t4nk573> 'b'
20:17:29 <ski> > let a:b = ["a","b","c"] in a
20:17:31 <lambdabot>  "a"
20:17:44 <Fuuzetsu> are there resources on how to actually use Attoparsec's Partial? I think I could use it now.
20:18:36 <ski> Welkin : but since the matching can fail (unless you know it can't, in your particular situation), it would be better to use `case'
20:22:27 <solatis> is there any way to make cabal auto-expose my modules based on a source tree?
20:23:15 <solatis> when you expose modules, cabal requires your source tree to be defined in a very specific way so it can 'find' the modules -- it would make sense it can also do the reverse, discover modules based on a source tree.
20:23:20 <solatis> `cabal init` can actually do this
20:23:35 <solatis> so the functionality is somewhere
20:24:07 <solatis> so is there any way i can do an 'exposed-modules: auto-all' or something? :)
20:57:46 <lwm> hey folks, I wanna start using postgresql-simple but don't really know where the docs are
21:19:23 * hackagebot filestore 0.6.0.4 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.4 (JohnMacFarlane)
21:26:59 <gamegoblin> What is you guys opinion of using words for type variables?
21:27:34 <u-ou> I don't like it
21:39:17 <solatis> ok, i'm dealing with this problem for way too long now
21:39:22 <solatis> i have a lazy bytestring
21:39:28 <solatis> i have a parser that accepts bytes
21:39:39 <solatis> i want to feed the parser the bytes as they come in, lazily
21:39:53 <solatis> so i don't want to turn the lazy bytestring into a strict bytestring
21:40:01 <solatis> what is the approach i should take?
21:41:30 <solatis> (so, in other words, what i maybe want is to turn the bytestring into a (lazy evaluated) list that contain chunks of data as they come in)
21:41:49 <solatis> is that what the toChunks function of Data.ByteString.Lazy does?
21:41:56 <solatis> :t Data.ByteString.Lazy.toChunks
21:41:57 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
21:42:29 <solatis> the documentation of that function says nothing about it
21:42:42 <solatis> but maybe thats because i don't properly understand haskell's lazy nature yet
21:48:36 <hager> i am new in Haskell, will somebody tell me what exactly this line do         forever a = a >> forever a
21:51:08 <solatis> hager: it executes a, and then recursively calls itself again with the same function as an argument
21:51:26 <simpson> hager: What part of it is puzzling you?
21:51:29 <solatis> in imperative words, it can be compared to 'while (true) { ... }'
21:51:55 <simpson> Well, not all Monads will actually spin forever when using `forever`.
21:52:00 <solatis> note that, since it uses >> instead of >>=, it discards any results of the function
21:52:35 <hager> simpson: operator  >>  in    forever a = a >> forever a
21:53:50 <solatis> ah
21:53:51 <Cale> Well, not function
21:53:58 <solatis> that is a monadic transformation
21:54:10 <Cale> 'a' isn't likely to be a function here
21:54:17 <Cale> But some type of action
21:54:27 <solatis> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#g:9
21:54:33 <solatis> >> and >>= are documented there
21:54:36 <Cale> x >> y is the same thing as do x; y
21:54:40 <solatis> :t (>>)
21:54:41 <lambdabot> Monad m => m a -> m b -> m b
21:54:43 <Cale> if you're familiar with do notation already
21:55:36 <Cale> If x and y are IO actions for instance, then x >> y is the IO action which when executed will first execute x, discarding the result, and then execute y.
21:56:37 <Cale> So forever x is the action which when executed will first execute x, and then execute forever x
21:57:03 <Cale> which of course is an infinite loop, which is the point, because the execution of x might have effects
21:57:21 <Cale> Try for instance  forever (putStrLn "hello")
21:57:42 <hager> ok i understood thanks for all :)
21:58:17 <solatis> hager: so it is important to understand that '>>' is actually just another function defined in Prelude
21:59:39 <solatis> and when you write anything in do-notation, it is magically transformed into >> and >>= notation under the hood
21:59:51 <solatis> but generally, do-notation is a bit more pleasant for the eyes
22:00:47 <solatis> so you can also rewrite 'forever' to be like this:
22:00:49 <solatis> forever a = do
22:00:51 <solatis>   _ <- a
22:00:53 <solatis>   forever a
22:01:32 <fread2282> :t mfix
22:01:34 <lambdabot> MonadFix m => (a -> m a) -> m a
22:01:52 <dramforever> which is better: let (a, b) = f x in a + b
22:02:03 <dramforever> or case f x of (a, b) -> a + b
22:02:18 <solatis> define 'better' :)
22:02:31 <dramforever> which one do you use
22:02:53 <solatis> i would use the case .. of
22:02:58 <dramforever> why?
22:03:05 <solatis> habit
22:03:20 <solatis> :)
22:03:22 <dramforever> I'm not sure why people do that
22:03:36 <dramforever> I often write the let ... in one
22:03:48 <dramforever> but I see many others write case ... of
22:04:02 <solatis> it looks familiar to the people being used to 'switch' in imperative languages
22:04:20 <solatis> and the pattern matching is more explicit, i think
22:05:07 <dramforever> python code: a, b = f(x)
22:14:31 <dramforever> @type mfix (\x -> return x)
22:14:32 <lambdabot> MonadFix m => m a
22:15:32 <Hijiri> > forever Nothing
22:15:34 <lambdabot>  Nothing
22:15:40 <zwer> since (a, b) matches everything I'd rather use let or where
22:19:51 <prinsen> Is there any way to write unicode character codes, like u0009 in haskell?
22:20:01 <dramforever> > '\u0009'
22:20:03 <lambdabot>  <hint>:1:3:
22:20:03 <lambdabot>      lexical error in string/character literal at character 'u'
22:20:21 <Hijiri> > '\0009'
22:20:23 <lambdabot>  '\t'
22:20:28 <dramforever> > '\x0009'
22:20:30 <lambdabot>  '\t'
22:20:35 <dramforever> > '\x2d2d'
22:20:37 <lambdabot>  '\11565'
22:20:53 <prinsen> '\x00A0'
22:21:01 <prinsen> > '\x00A0'
22:21:02 <lambdabot>  '\160'
22:21:18 <dramforever> '\x0045'
22:21:22 <prinsen> so basically just a x instead of a u
22:21:26 <dramforever> > '\xfffd'
22:21:28 <lambdabot>  '\65533'
22:21:42 <dramforever> prinsen: yep, if I got it right
22:21:56 <Hijiri> x to make it hex, at least
22:22:05 <dramforever> but why don't you just put in the character
22:22:13 <dramforever> > '人'
22:22:15 <lambdabot>  '\20154'
22:22:34 <dramforever> > '�'
22:22:35 <lambdabot>  '\65533'
22:22:52 <Hijiri> > "入λ"
22:22:54 <lambdabot>  "\20837\955"
22:22:57 <prinsen> dramforever: there are wierd characters
22:23:09 <prinsen> > '\xFEFF'
22:23:10 <lambdabot>  '\65279'
22:23:35 <dramforever> prinsen: can you see that I sent something like <?>
22:23:48 <Hijiri> > '\D800'
22:23:50 <lambdabot>  <hint>:1:3:
22:23:50 <lambdabot>      lexical error in string/character literal at character 'D'
22:23:50 <dramforever> that's because I typed it in
22:23:55 <Hijiri> > '\xD800'
22:23:57 <lambdabot>  '\55296'
22:24:51 <dramforever> haha a screenful of character literals
22:24:55 <prinsen> dramforever: better to just have the codes
22:25:07 <dramforever> prinsen: what char do you want to use?
22:25:52 <dramforever> > let ɑ = "alpha" in ɑ
22:25:54 <lambdabot>  "alpha"
22:26:35 <prinsen> dramforever: no one, writing a parser for ECMA-262
22:27:27 <dramforever> hmm...how would that require those codes?
22:28:08 <prinsen> dramforever: In the production "whiteSpace" in the lexer
22:28:16 <dramforever> oh..
22:28:27 <prinsen> skipMany1 $ choice [ char '\x0009', char '\x000B' , char '\x000C', char '\x0020' , char '\x00A0', char '\xFEFF' ]
22:28:37 <dramforever> lol in that way codes are better
22:29:26 <prinsen> :)
22:29:58 <dramforever> otherwise it would be like: choice [ char ' ', char ' ', char ' ', char ' ', char ' ']
22:30:56 <prinsen> haha yes
22:31:15 <prinsen> And surely mess up someones editor
23:18:37 <codygman> In wreq, withSession uses a new ManagerSettings. I can't make my own Session because the data constructor isn't exported. Is there a way to make your own session with a lens?
