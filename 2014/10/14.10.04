00:33:05 * hackagebot libhbb 0.1.1.1 - Backend for text editors to provide better Haskell editing support.  http://hackage.haskell.org/package/libhbb-0.1.1.1 (wolfch)
00:46:25 <jle`> sigfpe called Traversable "Distributable" in a 2008 post
00:46:42 <jle`> i guess this was a case where "calling things with non-intimidating programmer friendly names" won through
00:46:50 <jle`> in its incoroporation into the standard libraries
00:48:26 <dibblego> jle`: Data.Distributive is dual to Traversable
00:48:44 <jle`> oh
00:48:47 <jle`> so they aren't the same thing?
00:48:58 <jle`> i must have misread his type signatures
00:48:59 <dibblego> I don't know about the post, but no.
00:49:07 <dibblego> the signatures are similar
00:49:18 <dibblego> @type Data.Distributive.cotraverse
00:49:20 <lambdabot> (Data.Distributive.Distributive g, Functor f) => (f a -> b) -> f (g a) -> g b
00:49:43 <jle`> so his 2008 Distributive class:
00:49:59 <jle`> class Distributes m w where distribute :: w (m a) -> m (w a)
00:50:14 <jle`> i guess it's something different from Data.Distributive
00:50:30 <jle`> :t T.sequence
00:50:30 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
00:51:06 <jle`> i guess he also parameterizes the typeclass on each t/m pair
00:51:52 <dibblego> I don't know this post and cannot find it
00:52:01 <jle`> http://blog.sigfpe.com/2008/03/transforming-comonad-with-monad.html
00:52:07 <dibblego> @type Data.Distributive.distribute
00:52:08 <lambdabot> (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
00:52:29 <jle`> that looks likee...the dual of what he is saying
00:52:39 <dibblego> I think it is the same
00:52:40 <jle`> if we take m to fill the role of f
00:52:55 <dibblego> but Functor is a more practical constraint than Comonad
00:53:08 <Tam5> http://www.youtube.com/watch?v=dNZrq2iK87k
00:53:45 --- mode: ChanServ set +o dibblego
00:53:49 --- mode: dibblego set +b *!*Tam5@*.oc.oc.cox.net
00:53:52 --- kick: Tam5 was kicked by dibblego (Tam5)
00:54:00 --- mode: dibblego set -o dibblego
00:58:06 * hackagebot direct-sqlite 2.3.14 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.14 (JanneHellsten)
00:58:56 <_2_summerellis> hi
01:07:20 <nshepperd_> ][[[[[/
01:07:28 <nshepperd_> instead of "class Foo a b | a ~> b" you do "class Foo a" with an associated type familyooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
01:08:14 <simpson> Was that a mike drop?
01:11:49 <structuralist> What's the closest thing in Haskell to Scala's scala.concurrent.Future?
01:11:57 <structuralist> or http://twitter.github.io/finagle/guide/Futures.html
01:12:45 <merijn> structuralist: Without reading I'm gonna go with "you should have a look at the async library" :)
01:15:43 <wz1000> Does hoogle index xmonad?
01:19:44 <ChristianS> wz1000: hoogle should index everything on hackage afaik
01:23:30 <mauke> wz1000: no
01:26:34 <ClaudiusMaximus> wz1000: try Hayoo
01:33:07 * hackagebot cabal2nix 1.70 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.70 (PeterSimons)
01:45:10 <sagittarian> djinn doesn't know  how to handle lists?
01:46:27 <Cale> sagittarian: Nope, it doesn't know how to use recursion in general
01:46:49 <Cale> At both the type and term level
01:55:24 <jle`> you can sort of fake it
01:55:36 <jle`> by defining lists-up-to-a-certain-length
01:56:43 <petercommand> then i won't be able to recursively process that list
01:57:24 <jle`> it depends on what exactly you want to prove/derive
01:57:29 <jle`> it might be useful in some cases
01:57:31 <jle`> :)
01:57:48 <petercommand> yeah
01:58:09 * hackagebot threepenny-gui 0.5.0.0 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.5.0.0 (HeinrichApfelmus)
02:08:27 <nshepperd_> 5
02:09:44 <sagittarian> > 5
02:09:46 <lambdabot>  5
03:08:50 <kuznero> Hi All!
03:09:07 <vanila> hello
03:26:30 <freeman42> I am confused about why replacing fromIntegral with fi in this code would break the build http://lpaste.net/8547668566164373504
03:28:56 <freeman42> code modified from here https://github.com/vincenthz/hs-hourglass/blob/master/Data/Hourglass/Internal/Win.hs#L46
03:31:38 <mauke> freeman42: try fi x = fromIntegral x
03:31:41 <mauke> does that fix it?
03:32:35 <freeman42> mauke, it does :) is it some... type inference thing?
03:32:56 <mauke> @where dmr
03:32:57 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:39:05 <freeman42> mauke, thank you, this is nice to know :)
03:39:48 <J_Arcane2> Minor question: Working through "Learn You a Haskell" and I've noticed that the error messages in the book differ from the error messages I get from GHCi 7.6.3.
03:40:20 <J_Arcane2> In particular, they miss that "possible fix:" bit.
03:43:12 <quchen> J_Arcane2: GHC is in very active development, thing like these change all the time. Since it's very basic, LYAH is still up to date when it comes to Haskell though.
03:43:49 <J_Arcane2> quchen: Fair enough. It was just an odd bit I noticed; not sure how helpful those 'possible fix' messages would be anyhow.
03:44:13 <quchen> J_Arcane2: "possible fix" basically means "no idea, look at that line again maybe"
03:44:38 <quchen> The only thing that will change in the future is that Applicative will be a proper superclass of Monad. LYAH talks about this hierarchy a bit in the later chapters.
03:44:54 <J_Arcane2> Yeah, I did notice that most of them don't seem to actually have anything to do with the problem.
03:45:16 <quchen> I'd say most of my "no instance" errors come from forgetting an argument
03:58:19 <quchen> I've got a question about foldl'. It's often said that the strictness annotation makes it such that intermediate results are always calculated so the stack doesn't grow. But is that correct in the general case? Would it be wrong to do this? http://lpaste.net/112047
03:59:32 <mauke> z' = f z a
03:59:52 <quchen> Good eye!
04:00:45 <mauke> interesting problem
04:01:19 <quchen> I also have a longer version here for repasting, with more comments. http://lpaste.net/112048
04:01:22 <mauke> I suppose it should be pseq
04:01:45 <quchen> Wait, the claim that "Data.List defines it like this" is wrong, it has a worker wrapper.
04:03:03 <quchen> mauke: pseq is non-standard though
04:05:42 <mauke> pseq x y = (seq x id) y  -- how broken is this?
04:06:29 <pjdelport> quchen: I'm not sure i understand what your paste is getting at. Isn't that just showing how the thunks are *not* growing?
04:07:27 <quchen> pjdelport: My paste builds up a long chain of "let", which can't be good for memory.
04:08:05 <quchen> My point is that foldl' is described as "the thing that doesn't chew all your memory", but I think the way I evaluated it it is a) correct and b) needs a lot of memory.
04:08:12 <pjdelport> quchen: That's not the order that Haskell will evaluate it in though.
04:08:19 <mauke> pjdelport: why not?
04:08:26 <quchen> seq does not imply an evaluation order.
04:08:54 <quchen> That's pretty much the root of the problem here.
04:09:20 <quchen> See the FBUT, https://github.com/quchen/articles/blob/master/fbut.md#seq-does-not-specify-an-evaluation-order
04:09:57 <quchen> mauke: I'm still trying to figure out why your custom pseq isn't right. Something tells me you can't write pseq in terms of seq.
04:11:58 <mauke> @pl pseq x y = (seq x id) y
04:11:58 <lambdabot> pseq = flip seq id
04:12:04 <quchen> mauke: What if the compiler just treats all "seq" as "put the first argument on some stack and evaluate everything using the second argument"
04:12:14 <quchen> And then when everything is finished, check whether everything in that stack is non-bottom
04:12:48 <mauke> what, like a super delayed _|_?
04:12:52 <quchen> Right
04:12:58 <mauke> that's disgusting
04:13:14 <quchen> Like "ignore seq's first arguments. Calculate everything. Check for ⊥ as late as possible."
04:13:36 <quchen> Sufficiently malicious compiler ;-)
04:14:06 <mauke> I don't think that's allowed but I have no proof
04:14:57 <mauke> the difference would be observable, at least
04:15:18 <quchen> Oh? Is it just a gut feeling or do you have more?
04:15:24 <quchen> I don't see why it wouldn't be allowed
04:15:45 <mauke> because it makes seq even more pointless
04:15:56 <quchen> Where I'm coming from is that  a `seq` b `seq` x  is the same as  b `seq` a `seq` x
04:16:14 <quchen> So you can "float out" seq arguments
04:16:19 <quchen> So you can rearrange seq stuff.
04:16:25 <quchen> That's what was in my head at least.
04:17:28 <mauke> yeah, but you're trying to rewrite (e `seq` f) x into (e `seq` f x)
04:17:39 <quchen> Maybe "seq" is just a really helpful pragma in expression space ;-)
04:18:45 <lpaste> pjdelport annotated “No title” with “Evaluating foldl' without skipping the evaluation of seq” at http://lpaste.net/112048#a112050
04:19:30 <quchen> mauke: Alright, let me rephrase it. seq is a branching function: if bottom then bottom, else keep going. That's pretty much all there is to it, minus evaluation order. Now our compiler always predicts the "keep going" branch, and that's roughly what I meant with this "seq stack" before.
04:19:34 <pjdelport> quchen: That's the way i understand the semantics of evaluation and seq
04:20:35 <quchen> pjdelport: That is one way to evaluate "seq" -- namely evaluate the first arg to WHNF first, then keep going if possible. But this is not required! seq can evaluate the second argument first if it wants to.
04:20:44 <pjdelport> quchen: The expansion you see only happens if you "skip over" evaluating the application of seq, and start speculatively evaluating its second argument (which Haskell in general doesn't do).
04:21:03 <quchen> GHC probably doesn't do it. Haskell does not specify this case.
04:21:23 <quchen> seq is literally defined as "seq ⊥ x = ⊥; seq y x = x   (if y ≠ ⊥)" in the Report.
04:21:37 <quchen> Anything that does that is a valid implementation, including the "second argument is evaluated first" version.
04:23:18 <pjdelport> quchen: seq cannot provide that y ≠ ⊥ without evaluating y before resulting in x
04:23:59 <quchen> Those are equations, not Haskell expressions. (That's why the "(if y ≠ ⊥)" part is there.)
04:24:04 <pjdelport> So that definition requires that seq y x evaluate y before you can get at the x at all.
04:24:42 <pjdelport> I know they're equations. :)
04:25:26 <mauke> seq y x = x `pseq` y `pseq` x
04:25:39 <mauke> what now?
04:26:11 <saati> hi, what does \\ mean in this: instance Functor (Ran g h) where fmap f m = Ran (\\k -> runRan m (k . f))
04:26:14 <saati> ?
04:26:17 <quchen> Then that definition is mathematical. There is no order in mathematical definitions. fac n = n * fac (n-1); fac 0 = 1  is a valid mathematical definition, but not a valid Haskell one.
04:26:24 <quchen> saati: A typo.
04:26:30 <pjdelport> saati: Probably a double-escaping markup error?
04:26:34 <mauke> saati: you're not looking at haskell code
04:28:09 <quchen> mauke: I guess I'll ask this on StackOverflow and see where the journey goes
04:28:12 <saati> i think pjdelport's answer is the right one, thanks
04:35:19 <pjdelport> quchen: Have you read this thread? http://www.haskell.org/pipermail/glasgow-haskell-users/2006-November/011480.html
04:39:20 <quchen> pjdelport: Oh, it mentions this case specifically.
04:39:58 <pjdelport> quchen: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-November/011497.html seems like a good point.
04:40:18 <quchen> I guess it's really the burden of the compiler to make good use of seq.
04:41:07 <quchen> I've been learning new things about seq for years now.
04:41:11 <quchen> The function that just keeps giving ;-)
04:44:01 <freeman42> having a project with a .cabal file but not published on hackage is it possible to find out all the places where it requires another package, recursively and not manually?
04:44:50 <freeman42> use case, find all the places where unix package is being used in this project: https://github.com/dlthomas/snowdrift including dependencies and dependencies of depenedencies and... etc :)
04:46:13 <cellopin> in haskell you can do recursive easily but is it  O(n^2) like other languages?
04:46:42 <mauke> cellopin: ???
04:47:05 <vanila> missing word: quicksort
04:47:51 <silver> quicksort is O(n^2) in ther languages?
04:48:06 <quchen> freeman42: Yes that's possible, but I don't know a program that actually does it. There are a couple of projects that let you explore Hackage as a full graph of dependencies.
04:48:07 <mauke> worst case, yes
04:48:38 <freeman42> is there any tool that could do the equivalent of comparing the list of packages dependent here(http://packdeps.haskellers.com/reverse/unix) with the packages of project X(snowdrift)?
04:48:38 <quchen> Quicksort is O(n^2) even in the best case. O(n!) even.
04:48:50 <cellopin> I mean recursive functions are not advisable in other languages
04:48:55 <mauke> cellopin: wrong
04:49:08 <cellopin> why?
04:49:12 <mauke> what
04:49:49 <mauke> that's like saying "integers are not advisable in other languages"
04:49:53 <silver> cellopin, so what thing have O(n^2) complexity in your original question?
04:50:13 <quchen> Recursive functions are not not advisable in other languages. (This does not imply that they are advisable though.)
04:50:15 <pjdelport> Quicksort has many variants, some of which are O(n log n)
04:50:17 <pjdelport> (IIRC)
04:50:24 <cellopin> sorry i'll have to go back
04:50:36 <cellopin> gtg
04:50:38 <mauke> vanila-- mauke--
04:51:53 <vanila> recursion is good in scheme
04:52:11 <J_Arcane2> Yes. Scheme and Racket do recursion quite nicely.
04:52:27 <mauke> and C
04:52:31 <mauke> and Perl
04:52:34 <vanila> C is bad for recursion
04:52:40 <mauke> vanila: wrong
04:52:58 <vanila> you don't know if you have TCO, so it's better to use iterative constructs when possible
04:53:07 <J_Arcane2> (I did a blog last night about rewriting LYAH's quicksort in Racket, even)
04:53:28 <mauke> vanila: what if your function isn't tail recursive?
04:53:36 <vanila> mauke, then its fine
04:54:31 <mauke> unsigned fac(unsigned n) { if (n < 2) return 1; return n * fac(n - 1); }
04:54:51 <Taneb> silver, quicksort is average case O(n^2)
04:54:52 <Taneb> cellopin, that's due to stack size rather than time complexity
04:54:52 <Taneb> cellopin, however, Haskell has an optimization called Tail Recursion Elimination (quite a few languages do nowadays), that eliminates the stack growth in many cases
04:55:38 <mauke> haskell doesn't have a call stack
04:55:53 <mauke> there's nothing to "optimize"
04:56:08 <vanila> mauke: that's true! haskell is based on graph reduction
04:56:18 <vanila> so TCO doesnt apply to it
04:56:35 <silver> Taneb, you mean worst case?
04:56:39 <vanila> that's only relevant to strict languages like scheme (and many others which refuse to support it like go)
04:59:04 <Taneb> silver, oh, huh, I misremembered it
05:01:10 <silver> mauke, what's lowest n which will crash the C program you presented?
05:02:08 <mauke> none
05:02:17 <mauke> gcc compiles it into a loop
05:02:49 <vanila> how the heck does GCC turn it into a loop? that's amazing
05:02:55 <silver> so it avoids recursion, interesting
05:03:37 <silver> maybe it's because recursion in C is dangerous after all
05:05:16 <vanila> http://lpaste.net/112051
05:05:26 <vanila> I got this assembly from compiling it
05:05:54 <vanila> it is just doing recursion like you'd expect
05:06:03 <vanila> mauke, Do I need special compiler flags?
05:06:28 <mauke> -O2?
05:06:37 <silver> or -O3
05:06:59 <vanila> http://lpaste.net/112051 nice!
05:07:39 <vanila> it's amazing that it performs this optimization, it must be making use of commutativity of *?
05:09:02 <vanila> I'm surprised to see it optimizing a non-tail recursive function into a loop!
05:09:21 <vanila> I know you can do this with tail-recursion-modulo-cons but this is even more
05:09:34 <silver> magix
05:09:39 <vanila> yeah!
05:10:49 <pjdelport> Well, * is an inextensible primitive in C.
05:11:07 <pjdelport> So it's not the same class of problem as tackling commutative functions in general. :)
05:11:45 <quchen> (Multiplication is commutative with floating point numbers, right? I never dared to ask.)
05:11:56 <freeman42> is there a recommended way to do a cabal install for a project which has some hackage dependencies changed but not published? somehow cabal install those dependencies from github repository or something similar?
05:12:26 <wz1000> Why is it an error to use unicode characters in a stirng
05:12:32 <wz1000> *string?
05:12:36 <quchen> It is not
05:12:44 <quchen> Example code?
05:12:47 <quchen> Example error?
05:12:57 <pjdelport> > "Spın̈al Tap"
05:12:59 <lambdabot>  "Sp\305n\776al Tap"
05:15:02 <wz1000> > "\2B97"
05:15:06 <lambdabot>  "\STXB97"
05:15:49 <wz1000> I am getting this:  lexical error in string/character literal at character '\11159'
05:18:24 <silver> freeman42, I would download them (not published stuff) manually and "cabal install" them in a sanbox(es)
05:18:33 <pjdelport> wz1000: Where is the error coming from?
05:18:57 <silver> freeman42, sandboxes*
05:19:20 <silver> freeman42, http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
05:20:58 <freeman42> silver, but how would I tell the main project to use them instead of the hackage ones? the main project is: https://github.com/dlthomas/snowdrift/blob/master/Snowdrift.cabal
05:21:12 <mauke> wz1000: what's \11159 supposed to be?
05:21:30 <freeman42> and the changed code is in the dependency hot and hs-hourglass(a dependency of hot)
05:21:44 <silver> freeman42, you need to download source and change the dependencies (and if it works submit a patch to a maintainer :D)
05:22:15 <wz1000> mauke: It is a custom unicode character in this font: https://github.com/phallus/fonts
05:22:38 <mauke> i.e. it's not part of the unicode standard
05:22:55 <silver> freeman42, why do you need new dependencies with old version?
05:23:14 <freeman42> silver, I submitted some patches to those libraries, but I want to test on the main project if it builds by somehow referencing the changed dependencies, either from github or a local clone of them
05:23:46 <vanila> mauke++ :)
05:23:46 <freeman42> silver, new dependencies with old version?
05:23:52 <vanila> thanks for showing me that
05:24:24 <wz1000> pjdelport: I'm writing my xmonad.hs and I've tried pasting this character in and using an escape code, but neither of them work
05:24:28 <freeman42> silver, when using node package manager there was a way to specify in the dependencies file to use a github repo instead of a dependency name
05:24:30 <silver> freeman42, I see, yeah, just get the source of the project and change dependencies by hand
05:24:46 <freeman42> if there were some similar way in the cabal file it would be great, not sure how to do this
05:25:12 <silver> freeman42, I'm not aware of similar feature in cabal :(
05:25:36 <freeman42> silver, how would I change dependencies by hand? :) I still don't get it
05:27:11 <silver> freeman42, get the source of the project you want to test against new dependencies, change the deps in the .cabal file of the project and build it with cabal
05:27:38 <silver> all in a sandbox, so everything is isolated
05:28:21 <freeman42> silver, change the dependencies how? :-?? the cabal file points to hackage, I do not know how to make it point to github or local code
05:29:11 <silver> if you install new dependencies before you build your project cabal won't try to get them from hackage
05:29:59 <freeman42> ah, I understand
05:31:00 <freeman42> silver, should I create a folder in which the main project and the 2 dependencies are located, and then do a cabal sandbox init in that folder and cabal intall the dependencies first, then the main project?
05:31:18 <silver> yeah, try that
05:35:02 <predator117> freeman42: not sure I got the whole issue but if you want to path a package from hackage and use your local version instead of the one from hackage, the workflow is simply: (1) cabal get <package-from-hackage>; init sandbox; change & build (2) in the project you want to use it: cabal sandbox add add-source <path-to-folder-of-changed-package> (3) the project should use your changed version
05:35:24 <silver> oh yes
05:35:42 <silver> add-source will probably allow you not to build/install deps by hand
05:36:03 <predator117> oh cabal sandbox add-source not cabal sandbox add add-source, typo
05:36:04 <freeman42> predator117, yeah, that is the exact use case :)
05:36:30 <freeman42> awesome, thanks a lot silver, predator117, giving it a try now :)
05:36:34 <silver> forgot about it, sorry :P
06:02:21 <LtRipley> hi
06:03:02 <vanila> hi
06:03:43 <LtRipley> i am writing my first haskell programs and trying to get something to return a list of all fibonacci numbers smaller than N. I tried naive approach, but it seems not to scale well http://pastebin.com/f9ykYc9E
06:04:04 <mauke> wtf
06:04:10 <mauke> you're calling fib (n - 1) three times
06:04:24 <LtRipley> mauke: i was expecting the compiler to recognize that it is redundant
06:04:40 <mauke> very unlikely
06:05:01 <vanila> LtRipley, I don't understand your code
06:05:30 <vanila> why don't you build an infinite list of fibonacci numbers
06:05:40 <LtRipley> vanila: wouldn't that take even more time?
06:05:48 <vanila> it will not take more time
06:06:09 <vanila> if fibonacci = [1,1,2,3,5,...]
06:06:10 <vanila> then
06:06:22 <vanila> [1,1,2,3,5,...]
06:06:24 <vanila> [1,2,3,5,...]
06:06:27 <vanila> add thes up columnwise
06:06:28 <vanila> to get
06:06:33 <vanila> [2,3,5,...]
06:06:39 <LtRipley> to find all fibonacci numbers smaller or equal than N+1 i will get all fibonacci numbers smaller or equal than N and check if the highest two elements together will be N+1
06:06:48 <vanila> you could build the infinite list this way
06:06:55 <bernalex> LtRipley: that's a really odd fib function
06:06:58 <Elle23>  You can find funny videos here. http://j.mp/Rh9YfS
06:07:10 <mauke> vanila: ??
06:07:12 <bernalex> LtRipley: the standard linear naïve fib would be
06:07:14 <bernalex> fib 0 = 0
06:07:16 <bernalex> fib 1 = 1
06:07:16 <vanila> fibonacci = 1 : 1 : <add the two columns up here>
06:07:18 <bernalex> fib n = fib (n-1) + fib (n-2)
06:07:25 <mauke> LtRipley: that sounds wrong
06:07:26 <vanila> bernalex, that's O(fib(n)), not linear
06:07:32 <bernalex> vanila: ooops yes
06:07:58 <bernalex> linear fibonacci is usually written as
06:08:00 <bernalex> >
06:08:00 <LtRipley> bernalex: but that gives me the first N fibonacci numbers, i want to have all fib numbers less than or equal N
06:08:02 <bernalex> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:08:04 <bernalex> in haskell
06:08:04 <mauke> > let fib 1 = [1, 1]; fib n | head(fib(n-1)) + head(tail(fib(n-1))) == n = n:fib(n-1)
06:08:06 <lambdabot>  not an expression: ‘let fib 1 = [1, 1]; fib n | head(fib(n-1)) + head(tail(f...
06:08:08 <LtRipley> it is a slightly different problem
06:08:12 <bernalex> LtRipley: so what
06:08:14 <pjdelport> LtRipley: The Haskell approach is to decompose your problem into parts. In this case, you have two problems: (1) making a list of Fibonacci numbers, and (2) returning the elements of a list smaller than a certain N.
06:08:14 <doismellburning> LtRipley: takeWhile
06:08:19 <mauke> > let fib 1 = [1, 1]; fib n | head(fib(n-1)) + head(tail(fib(n-1))) == n = n:fib(n-1) | otherwise = fib (n-1) in fib 4
06:08:21 <lambdabot>  [3,2,1,1]
06:08:22 <doismellburning> but yeah what pjdelport said
06:08:23 <int-e> > fix((0:).scanl(+)1)
06:08:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:08:35 <bernalex> LtRipley: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- this gives you every single fibonacci in linear time. just take the ones you want from it.
06:08:38 <pjdelport> > takeWhile (< 10) [0..]
06:08:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
06:08:43 <LtRipley> mauke: it is not wrong, it works. It is just not very efficient
06:08:56 <bernalex> LtRipley: if you want to be efficient you should use a logarithmic fib
06:08:58 <mauke> wow, how does this even work
06:10:33 <LtRipley> pjdelport: if i understand it correctly takeWhile is a higher concept that based on the lower level haskell elements?
06:10:47 <mauke> uh. it's a library function
06:10:56 <pjdelport> LtRipley: Yes; it's just a plain function.
06:11:02 <pjdelport> @src takeWhile
06:11:02 <lambdabot> takeWhile _ []                 = []
06:11:03 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
06:11:03 <lambdabot>                    | otherwise = []
06:11:14 <bernalex> LtRipley: here's a logarithmic fib I wrote once: http://lpaste.net/4594724466726010880
06:11:33 <pjdelport> LtRipley: The function you wrote above basically tries to do the job of both fibs and takeWhile at the same time.
06:11:41 <bernalex> LtRipley: it is correct and generalised, so it works for negative numbers as well.
06:12:04 <pjdelport> But the result is more complicated and less flexible. Haskell encourages composing simpler functions together, instead.
06:12:41 <LtRipley> bernalex: i just want the equivalent of what i can do with a simple while loop in any iterative programming language
06:12:53 <vanila> LtRipley, For that you can use recursion
06:12:54 <pjdelport> So given fibs like above, you can say simply say: fibsUpTo n = takeWhile (< n) fibs
06:12:57 <mauke> this is some kind of brute force fib computation
06:12:59 <bernalex> LtRipley: uh this is not an imperative language, we don't do that.
06:13:07 <bernalex> LtRipley: logarithmic fib is not that trivial
06:13:20 * hackagebot libjenkins 0.5.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.5.0 (MatveyAksenov)
06:13:23 <bernalex> LtRipley: here's an iterative linear fib though:
06:13:25 <bernalex> fibs = map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
06:13:33 <pjdelport> LtRipley: takeWhile is your while loop :)
06:13:45 <mauke> it walks down the numbers from n and checks each n whether it's the next fibonacci number
06:14:16 <LtRipley> pjdelport: my point is, that i want to get the low level concepts before i use library methods like takeWhile
06:14:28 <pjdelport> LtRipley: Well, you can implement takeWhile yourself.
06:14:42 <zwer> LtRipley then use recursion
06:14:58 <pjdelport> You already did, in fact; takeWhile is just what you would extract from your first attempt.
06:15:18 <LtRipley> i hope using takeWhile is more efficient than my approach :D
06:15:21 <bernalex> I guess they can write it using tail recursion and have it be linear
06:15:32 <pjdelport> LtRipley: So, starting from scratch, you would first write fibs, then takeWhile, and then fibsUpTo using the previous two.
06:15:32 <LtRipley> which i guess is O(3^N)
06:15:42 <bernalex> but it hardly gets any simpler than the traditional linear zipwith implementation
06:15:46 <pjdelport> LtRipley: Yes, it's linear.
06:16:04 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<= 100) fibs
06:16:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89]
06:16:25 <vanila> that is what i was suggesting earlier
06:16:32 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<= 1000) fibs
06:16:33 <LtRipley> i feel that my approach should work fine, if it was calling fib(N) only once
06:16:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
06:16:35 <pjdelport> LtRipley: One idea that might help you, coming from an imperative background, is to think of Haskell lists as "reified" control loops.
06:16:49 <bernalex> > unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
06:16:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:17:18 <pjdelport> LtRipley: Whenever you have a Haskell list, you don't just have a data structure, you effectively have a reified control struture that you can pass around and do stuff with.
06:17:40 <mauke> >implying "reified control structure" is a meaningful term
06:18:08 <pjdelport> fibs is a good example: you can think of it as actually being an infinite loop that generates numbers.
06:18:21 <benzrf> >greentexting in irc
06:18:33 <pjdelport> and takeWhile is the equivalent of a "while" construct that bounds a loop.
06:18:38 <mauke> >meme arrows
06:18:50 <benzrf> > fix$scanl(+)0.(1:)
06:18:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:19:01 <pjdelport> LtRipley: So your general intuition should be that where you would have a loop in an imperative language, you'll have a list in Haskell.
06:19:40 <LtRipley> pjdelport: a list where each element corresponds to one iteration?
06:19:50 <pjdelport> LtRipley: Right.
06:19:51 <mauke> > let fib 1 = [1, 1]; fib n | x + y == n = n : xs | otherwise = xs where x : xs@(y : _) = fib (n - 1) in fib 4
06:19:52 <lambdabot>  [4,1]
06:20:28 <mauke> > let fib 1 = [1, 1]; fib n | x + y == n = n : xs | otherwise = xs where xs@(x : y : _) = fib (n - 1) in fib 4
06:20:30 <lambdabot>  [3,2,1,1]
06:20:45 <mauke> > let fib 1 = [1, 1]; fib n | x + y == n = n : xs | otherwise = xs where xs@(x : y : _) = fib (n - 1) in fib 1000
06:20:47 <lambdabot>  [987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
06:21:10 <benzrf> LtRipley: it's still a list, it's just that the list is only generated as you access it
06:21:20 <benzrf> LtRipley: so it's like a generator from python or new js
06:21:51 <benzrf> actually
06:21:56 <LtRipley> i think i will have a look at the implementation of takeWhile for enlightment :)
06:22:00 <benzrf> LtRipley: do you use python?
06:22:19 <zwer> @src takeWhile
06:22:19 <lambdabot> takeWhile _ []                 = []
06:22:19 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
06:22:19 <lambdabot>                    | otherwise = []
06:22:29 <LtRipley> benzrf: sometimes, i am familiar with the concept of generators and yieled return
06:22:33 <benzrf> ok
06:22:35 <benzrf> LtRipley: what about
06:22:43 <benzrf> LtRipley: things like generator comprehensions?
06:22:55 <benzrf> LtRipley: or iterators instead of lists?
06:23:20 <benzrf> LtRipley: have you used a library that provides an iterable instead of a list because then it can generate each element as requested instead of loading it all into memory at once?
06:23:24 <McManiaC> how can I use HDBCs SqlError with ExceptT and IO? If I define a newtype via "ExceptT SqlError IO a" and try to compile my code I get a "no instance for MonadError SqlError IO", but when I try to define such an (orphan) instance I get functional dependency conflicts between "MonadError SqlError IO" and "MonadError IOException IO"
06:23:48 <benzrf> McManiaC: why the newtype
06:24:00 <LtRipley> benzrf: i get the concept y'all are talking about. I think i am just missing the right language elements to implement it
06:24:05 <McManiaC> benzrf: or type, doesnt matter
06:24:14 <benzrf> McManiaC: just use type instead of newtype
06:25:39 <McManiaC> benzrf: I need/want the newtype though, and I defined a "MonadError e m => MonadError e (MyNewtype e m)" instance
06:25:49 <McManiaC> still wont work
06:26:56 <benzrf> why do you want the newtype
06:27:52 <McManiaC> because i'm building a wrapper around that ExceptT
06:28:30 <McManiaC> http://npaste.de/p/dFpt/ am I missing any instances?
06:28:34 <bernalex> McManiaC: use an ADT
06:31:17 <McManiaC> bernalex: how would that be different
06:36:29 <McManiaC> why is there a functional dep on m -> e in MonadError anyway?
06:36:42 <McManiaC> why can't you define a custom MonadError err IO instance
06:50:15 <LtRipley> i refactored my original approach to be more efficient, i admit it is not the best approach. But i figured out how to avoid calling the subroutine thrice
06:50:23 <LtRipley> http://pastebin.com/xqnA1Cap
06:51:35 <mauke> LtRipley: what do you think about my version?
06:54:11 <LtRipley> mauke: probably works similar, but i don't know the where-clause yet :)
06:55:18 <mauke> > let fib 1 = [1, 1]; fib n = let xs@(x : y : _) = fib (n - 1) in if x + y == n then n : xs else xs in fib 1000
06:55:20 <lambdabot>  [987,610,377,233,144,89,55,34,21,13,8,5,3,2,1,1]
06:55:26 <mauke> now without "where" :-)
07:00:48 <LtRipley> mauke: in the end i had to realize, that the approach isn't that good after all as it is linear to my maximum number N and the other approaches are linear to the number of elements
07:18:30 <pjdelport> LtRipley: Haskell style generally doesn't use tupling of arguments, like that.
07:19:32 <LtRipley> pjdelport: but it works :)
07:19:55 <LtRipley> i am not sure what you are referring to?
07:20:00 <HeladoDeBrownie> The main problem is it prevents you from applying only some of the parameters, which you do want to do sometimes.
07:20:19 <pjdelport> LtRipley: It *works*, but isn't your goal to learn more Haskell? :)
07:20:25 <HeladoDeBrownie> Instead of fibSub (n, xs), consider fibSub n xs
07:20:43 <HeladoDeBrownie> This also means you call it like fibSub n (fib (n - 1)) instead of with the tuple
07:20:47 <pjdelport> LtRipley: Tupling means fibSub (n, xs) = ... instead of fibSub n xs = ...
07:21:22 <LtRipley> maybe i haven't found the use case yet, where it makes a difference
07:21:26 <pjdelport> LtRipley: Haskell functions are generally written in the second style, which you'll see referred to as "curried"
07:21:54 <nitrix> Does haskell has a way to increment a string? aaaaa into aaaaab ?
07:21:58 <HeladoDeBrownie> LtRipley, I notice you writing and referring to your program as if it were in Java or some other similar language. Haskell is quite different. :)
07:22:08 <HeladoDeBrownie> LtRipley, for example, fibSub is a function, not a subroutine.
07:22:13 <bernalex> why would you do "f (a, b) = a" instead of "f a b = a"? it just means you need extra parens/commas when defining it & calling it
07:22:16 <titi_> hello
07:22:19 <pjdelport> nitrix: Not builtin, but you can implement that!
07:22:20 <LtRipley> HeladoDeBrownie: sub-function :
07:22:32 <titi_> @djin
07:22:32 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
07:22:38 <HeladoDeBrownie> And also we don't talk about "calling" but rather applying
07:23:06 <LtRipley> HeladoDeBrownie: yes of course i referr to it like that, i have done 15 years of imperative programming. and i am doing haskell for a couple of hours :)
07:23:16 <nitrix> pjdelport: Would it be hard to specify a range? 0-9a-z-A-Z ?
07:23:17 <titi_> @djin (a -> b -> c ) -> (a ->b) -> (a -> c)
07:23:23 <HeladoDeBrownie> LtRipley, fair enough, just realize that things are quite different here. You would be wise trying to approach Haskell with a beginner's mind.
07:23:23 * hackagebot hourglass 0.2.5 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.5 (VincentHanquez)
07:23:49 <LtRipley> HeladoDeBrownie: i am probably to impatient to do that, to be honest
07:24:01 <bernalex> for one thing, haskell has functions, not categories like those academic toy languages java, c and c++. ;-)
07:24:08 <HeladoDeBrownie> If you're too impatient for that, you're probably too impatient to learn Haskell.
07:24:51 <LtRipley> HeladoDeBrownie: might be, maybe i should spent the weekend learning go then ;)
07:24:54 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
07:24:54 <nitrix> LtRipley: Learning Haskell is like learning programming again. It's not merely syntaxic sugar and semantics to pick up, you actually have to understand new theory.
07:25:19 <nitrix> There's nothing much to learn about Go. It's using things that are already known in multiple languages, just bundled togheter.
07:25:25 <titi_> @type map
07:25:26 <lambdabot> (a -> b) -> [a] -> [b]
07:25:35 <nitrix> By all means, use Go if you want to.
07:25:46 <nitrix> You simply wont be learning something new.
07:25:48 <titi_> @help
07:25:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:25:54 <titi_> @help list
07:25:54 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
07:25:56 <bernalex> go is written to be familiar and easy to get into for big teams, so learning go should not be difficult for someone who knows any c-like lang.
07:25:59 <titi_> @help djin
07:25:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:26:00 <pjdelport> LtRipley: What's your goal?
07:26:10 <titi_> @list
07:26:10 <lambdabot> What module?  Try @listmodules for some ideas.
07:26:17 <titi_> @listmodules
07:26:18 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
07:26:18 <bernalex> titi_: please spam lambdabot in privmsg.
07:26:25 <titi_> @list djinn
07:26:26 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
07:26:39 <titi_> @djinn (a -> b -> c ) -> (a ->b) -> (a -> c)
07:26:54 <LtRipley> pjdelport: don't know yet. I am just curious.
07:26:56 <nitrix> titi_: Can you keep the noise low?
07:26:56 <lambdabot> f a b c = a c (b c)
07:26:56 <nitrix> titi_: Hello?!
07:27:25 <LtRipley> pjdelport: i probably won't use functional programming in my professional life anytime soon, so this is more a fun exercise for mee
07:27:31 <titi_> nitrix: I'm new on IRC, I'm trying to check something using djinn
07:27:40 <nitrix> titi_: You're flooding 1366 persons, do so in private.
07:27:40 <HeladoDeBrownie> titi_, /query lambdabot
07:27:42 <pjdelport> titi_: You can /query lambdabot
07:27:52 <hexagoxel> no, don't spam us in private!
07:28:08 <HeladoDeBrownie> hexagoxel, almost missed it :P
07:28:18 <pjdelport> LtRipley: Getting a taste for it is a good goal!
07:28:19 <bernalex> LtRipley: you should use fp professionally. it makes life far more pleasant.
07:28:40 <titi_> nitrix: ok sorry
07:28:43 <pjdelport> LtRipley: I can vouch that learning Haskell may change the way you think about programming, and improve your programming even in other languages.
07:28:48 <pjdelport> So it's worth learning just for that.
07:28:59 <LtRipley> bernalex: i can not singlehandedly change the language our IT department is using
07:29:04 <bernalex> that's also true. learning haskell makes you a better C programmer. :-]
07:29:10 <bernalex> LtRipley: not with that attitude you can't
07:29:27 <mauke> Haskell isn't that good
07:29:42 <pjdelport> LtRipley: But to actually benefit from it, you should try to learn idiomatic Haskell, to understand how the language actually works and approaches problems.
07:30:01 <LtRipley> pjdelport: yes, which is probably the more helpful approach
07:30:09 <bernalex> LtRipley: check out lyah
07:30:10 <pjdelport> You can always translate ideas and code from the languages you know to Haskell, but that should only be a first step towards finding out how to do it idiomatically in Haskell.
07:30:11 <bernalex> @where LYAH
07:30:14 <nitrix> The biggest pro with doing Haskell, as far as I can tell, is that I'm not spending 90% of my time fixing bugs.
07:30:15 <nitrix> I write the feature once.
07:30:15 <bernalex> @LYAH
07:30:23 <bernalex> lambdabot: are you alive?
07:30:26 <pjdelport> That's the way to really learn new and interesting things!
07:30:30 <lambdabot> http://www.learnyouahaskell.com/
07:30:30 <lambdabot> Unknown command, try @list
07:30:34 <bernalex> there we go. :-]
07:31:20 <LtRipley> bernalex: i don't know how much time you have spent with legacy code, but it is not someting you just replace overnight :)
07:31:35 <bernalex> nitrix: I find that with haskell I approach problems entirely differently. instead of programming my way to an answer, I just think about the problem, write some ADTs and type signatures for functions, then the functions kind of write themselves. :-]
07:31:45 <LtRipley> bernalex: and discussing with 400 devs, which language is the best, is another 'fun'
07:32:32 <bernalex> LtRipley: I have not done it on the scale of 400 devs, but with >20 devs for >10 year old code at least. I know it sucks. I started my own company. :-]
07:33:24 * hackagebot hit 0.6.2 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.6.2 (VincentHanquez)
07:35:12 <nitrix> bernalex: Yeah I agree. The more I do Haskell, the more lazier (no pun intended) I become at writing C. It's just so exhausting. It'd be like writing an SQL query where you do `for (x=0 x<rowcount; x++) { if (row[i] == SOMETHING && count < 10) ... malloc().. list_push(resultset, ...) }`
07:36:09 <bernalex> nitrix: the non-pfp-projcets I work on these days are kind of fun. one of them is really really neat C code, one is horrid BASH DSL, one is python legacy code where you change things ate the 14th indentation level and pray you don't break *everything* in three programs.
07:36:39 <nitrix> bernalex: Which one is the really really neat C code?
07:36:52 <bernalex> nitrix: i3. which is sadly the one I work the least one, hehe.
07:37:12 <LtRipley> are there example projects in haskell with more then say 1.000.000 lines of code?
07:37:15 <bernalex> haven't done anything about i3 in months. I should get back on it.
07:37:38 <HeladoDeBrownie> I feel that lines of code are a poor metric for interlanguage comparison.
07:37:41 <pieter> //win 4
07:37:42 <bernalex> LtRipley: haskell projects generally don't get that big. FP is all about decoupling code, so you end up decoupling programs as well. rather than one big fuck of program, you have several small modules that interact.
07:38:04 <mauke> how big is ghc?
07:38:12 <LtRipley> HeladoDeBrownie: it is a poor metric. which metric would be better?
07:38:35 <bernalex> mauke: about 150K lines
07:38:36 <HeladoDeBrownie> LtRipley, looking at programs that function similarly.
07:38:53 <bernalex> there are *no* one good metric that you can map linearly
07:38:57 <nitrix> 28k in1992, 139k in 2011
07:38:58 <Patient0> Hi guys - I am a Haskell newbie. I have written a tic-tac-toe solver - wondering if anyone would care to look it over, suggest any improvements
07:39:06 <Patient0> http://lpaste.net/112061
07:39:34 <nshepperd_> LtRipley: developer-hours!
07:39:55 <bernalex> nshepperd_: I think that's quite bad as well
07:40:19 <LtRipley> nshepperd_: that one is really hard to measure
07:40:21 <nshepperd_> number of bugs per line divided by solar flare rate
07:40:31 <bernalex> nshepperd_: if you get a deadline in 4 months, you'll spend as much time in haskell as in java, generally. you'll just have more fun doing it in haskell, and get to obsess over commit messages and how to indent your code. ;-)
07:40:42 <nshepperd_> haha
07:41:09 <LtRipley> if feel the difference in loc between similar programs in language A and language B should be constant factor such that loc(A) = loc (B) * X
07:41:37 <HeladoDeBrownie> That isn't the case when one language has nicer tools for abstraction than the other.
07:41:49 <mauke> you can do some fiendishly complex stuff in 6 lines of haskell
07:41:49 <HeladoDeBrownie> You might write several C procedures that correspond to a single Haskell function.
07:41:56 <mauke> abstractions stack
07:42:09 <nshepperd_> self-reported happiness of developer, integrated over project lifetime
07:42:17 <bernalex> LtRipley: there are a few really huge wins for me. these are anecdotals, but still. 1. you can reason about everything since there are no side-effects. everything can be beta reduced into a single IO (), every time. 2. types make your program really easy to read, and you can trust the types because of purity. 3. refactoring haskell is a dream, because of the purity and types.
07:42:45 <bernalex> nshepperd_: self-reported happiness is probably the best metric TBH. :-]
07:43:31 <LtRipley> bernalex: currently i am getting paid for writing perl and i think anything is more suited for the job than perl, but still it is very unlikely to be changed
07:43:50 <mauke> I'm also getting paid for writing Perl :-)
07:43:55 <mauke> I love it
07:44:06 <bernalex> I should add that types make the programs really easy to *write*, not just read. you just think about your problem, make some ADTs, write a few morphisms, some types here, some type signatures there, then the actual code writes itself. :-]
07:44:17 <LtRipley> bernalex: the thing is: if you decide to write decoupled, abstract and clean code in Perl, it wouldn't be that bad either
07:44:27 <augur> bernalex: learning Haskell makes you a better C programmer by making you abandon C :)
07:44:33 <mauke> LtRipley: which perl version, btw?
07:44:46 <LtRipley> mauke: 5
07:44:58 <mauke> LtRipley: look at perl -v
07:45:01 <bernalex> LtRipley: I think using any language that permits side-effects and/or does not have types that you can trust is worthless, and I avoid them all when given a choice. :-]
07:45:01 <mauke> that's not the version :-)
07:45:13 <LtRipley> mauke: all flavors of 5 :P
07:45:23 <mauke> what, including 5.003?
07:45:27 <mauke> I recommend an upgrade
07:45:47 <LtRipley> not at work now, i have no clue. and to be honest I don't care, i am not a perl zealot
07:45:51 <bernalex> augur: I was more thinking about how much more careful you get now that you realise that C basically is a bunch of categories with one really bad Kleisli arrow a -> ?????? trololololol b. :-]
07:46:29 <LtRipley> bernalex: me too, but it is not actually my choice, except if i want to change jobs
07:46:37 <mauke> err
07:46:38 <LtRipley> bernalex: and in that regard i am a whore :)
07:47:32 <HeladoDeBrownie> LtRipley, I would appreciate if you stayed away from language like that in here.
07:48:04 <LtRipley> sorry, i didn't want to use forbiden word :)
07:48:04 <bernalex> LtRipley: I prefer having a job where I have some autonomy over how to do it. :-]
07:48:26 <LtRipley> bernalex: i'd love to continue but i fear this is off topic :)
07:48:43 <bernalex> LtRipley: there's #haskell-blah fwiw :-]
07:55:48 <codehero> augur: lol
08:03:45 <ddellacosta> what stupid thing did I do that starting up ghci just now made me agree to the Xcode license?
08:04:27 * ddellacosta scratches his head
08:04:32 <silver> :D
08:04:51 <augur> ddellacosta: possibly install the new haskell platform which uses clang?
08:05:22 <ddellacosta> augur: no, not that, I explicitly got rid of the haskell platform and just have ghc installed.
08:05:39 <ddellacosta> augur: and I haven't updated it for a few months.
08:09:42 <RedNifre> Hey there.
08:11:40 <RedNifre> I'm using Scotty and I want to post a JSON String to it like "Hello". I try to get the text with comment <- jsonData, where comment is of type Text, but the parsing doesn't work. I send the text with Postman as raw JSON (application/json), where the raw body is "Hello". Why does this not work?
08:12:20 <mauke> "Hello" is not a valid JSON document
08:12:40 <mauke> but what do you mean by "doesn't work"?
08:13:17 <latk> has anyone used Data.Attoparsec.Expr (http://hackage.haskell.org/package/attoparsec-expr-0.1.1.1/docs/Data-Attoparsec-Expr.html)? I'm really struggling to define an OperatorTable that does what I want it to.
08:13:20 <RedNifre> it doesn't parse. But "Hello" is valid JSON, it's a string value.
08:13:45 <mauke> strings aren't legal at the top level
08:13:51 <RedNifre> Scotty can happily output booleans as json by simple sending true or false, which works nice.
08:13:52 <mauke> you need an array or object
08:14:27 <RedNifre> Are you sure? scotty sends values at the top level and the java library on the other end can unmarshal those as booleans / numbers / strings / null without problem.
08:15:17 <mauke> no, I might be wrong
08:15:27 <mauke> do you get an error message?
08:15:39 <geekosaur> strict JSON requires to plevel things be objects
08:15:44 <RedNifre> Well, yeah, it could not be parsed.
08:15:49 <darkbolt> the json spec dissalows scalars at the top level...encoders/decoders dont always abide by that
08:15:52 <RedNifre> Why would top level things need to be objects?
08:15:53 <geekosaur> as with so much else on the web, nobody cares about strict compliance
08:16:25 <mauke> RedNifre: what's the error message?
08:16:47 <RedNifre> I'm usually all for standards, but what is the benefit of writing { "value":true } instead of true when implementing a call that should return a boolean?
08:17:08 <RedNifre> The error message is not helpful: jsonData - no parse: "Postman work stop."
08:17:09 <darkbolt> RedNifre: not sure on the exact reasoning, but i think it's along the lines of protecting against certain injection attacks in browsers
08:17:09 <geekosaur> RedNifre, one obvious answer is so that they carry around some kind of identifying information, so you have a chance of detecting an out of sync situation
08:17:33 <RedNifre> I don't understand the obvious answer.
08:17:38 <geekosaur> another might be to discourage noisy roundtripping for trivial values
08:17:42 <latk> :t (<$)
08:17:43 <lambdabot> Functor f => a -> f b -> f a
08:17:54 <geekosaur> then I suggest you've never worked with a distributed application
08:18:26 <geekosaur> at least, not at the level of having to debug synchronization issues...
08:18:55 <RedNifre> I did. On the client side I find these garbage wrappers quite annoying, because if you use an automatic parser you get a large object, pull the value out and throw the wrapper in the garbage collector. What's the benefit of that?
08:19:28 <geekosaur> in a world where everything always 100% perfectly at al times, none.
08:19:37 <geekosaur> if you live reliably in that world, I envy you
08:20:37 <geekosaur> one of the cornerstones of information theory is that redundancy is essential for reliability, because inevitably *something* will go wrong
08:21:38 <griever> good day, gentlemen. could you kindly help with one minor issue: I'm trying to compile one of demos for GTK2Hs: https://gist.github.com/romhack/5823ca4ef74d3d3ea7b4 and on line 74 get "not in scope 'draw'" Could you please direct me to where should I search?
08:22:17 <mauke> "Note that the JSON standard requires that the top-level value be either an array or an object. If you try to use decode with a result type that is not represented in JSON as an array or object, your code will typecheck, but it will always "fail" at runtime: "
08:23:11 <mauke> that's from Data.Aeson, which is what scotty uses
08:24:55 <RedNifre> Weird, the encode function can output values though.
08:25:06 <RedNifre> > encode True
08:25:08 <lambdabot>  Not in scope: ‘encode’
08:26:57 <mauke> yes, it also mentions that in the documentation
08:27:25 <LtRipley> nitrix: when you say FP has to be learned from the scratch, how does that apply to implementing known algorithms, which are usually described in an imperative manner e.g. pseudocode
08:27:53 <vanila> mauke, do you write compilers?
08:28:40 <pjdelport> LtRipley: It depends a great deal on the style of pseudocode. You get functional-style and imperative-style pseudocode, and shades between them.
08:29:02 <pjdelport> (The two aren't necessarily mutually exclusive.)
08:29:14 <RedNifre> Well, that turns into a string that contains true
08:29:14 <RedNifre> I'm not convinced.
08:29:15 <RedNifre> It also mentions that decode "false" should work, so I guess there is something else wrong in my program.
08:29:16 <geekosaur> RedNifre, in any case there is little point in arguing it with us; we didn't invent the standard
08:29:40 <mauke> vanila: not really. sometimes I think about toy compilers in my spare time
08:29:42 <geekosaur> if you don't like the standard, you might start with the javacript community
08:29:52 <mauke> I've written a brainfuck compiler but that hardly counts
08:29:54 <latk> Could someone point me to a simple example of what a function Parser (Int -> Int) might look like? (using attoparsec)
08:30:09 <mauke> latk: that's not a function
08:30:11 <RedNifre> okay
08:30:26 <vanila> mauke, I wrote one of those too - self hosting bf to C lol
08:30:29 <pjdelport> latk: That's a parser yielding a function of Int -> Int
08:30:30 <latk> mauke: a function with type signature
08:30:39 <LtRipley> pjdelport: i usually find no trouble in translating functional pseudocode to c or whatever
08:30:40 <latk> Er, yes I mean parser :p
08:30:40 <mauke> latk: ?
08:30:44 <geekosaur> actually I think it would be the java community; javascript took it to heart but it started out as "java serialization over network" iirc
08:31:13 <pjdelport> LtRipley: Can you translate "fibs = zipWith (+) fibs (tail fibs)" to C easily? :)
08:31:18 <mauke> vanila: mine was in perl and targetted OISC
08:31:26 <heatsink> LtRipley: You can reformulate imperative algorithms functionally.  That usually makes the algorithm easier to understand, and allows more of the algorithm to be factored out.
08:31:27 <vanila> haha OISC is neat
08:31:37 <LtRipley> pjdelport: i haven't ever seen that in pseudocode, tbh
08:31:48 <pjdelport> ("fibs = 0:1:zipWith (+) fibs (tail fibs)" rather)
08:31:53 <mauke> LtRipley: read more haskell papers :-)
08:32:00 <griever> dear friends, anyone could tell me where this draw is placed? https://gist.github.com/romhack/5823ca4ef74d3d3ea7b4
08:32:10 <geekosaur> come to think of it, that gives a more pragmatic explanation of why it would require objects: it predates autoboxing
08:32:21 <pjdelport> LtRipley: There's a lot of functional pseudocode that has no straightforward translation to C.
08:32:39 <geekosaur> java native types posed issues back then; better to start with object types
08:32:53 <LtRipley> pjdelport: i dont know zip with but isnt that a while loop with something like i++; a[i]=a[i-1]+a[i-2]?
08:33:07 <vanila> I was wondering, Is a staged interpreter REALLY a compiler?
08:33:15 <pjdelport> LtRipley: Nah; it's unbounded.
08:33:19 <RedNifre> No, I think it is just Java Script Object Notation.
08:33:20 <vanila> I though so and ive been reasearching into it, but not it seems like that might not be really it
08:33:39 <pjdelport> LtRipley: That calculates the Fibonacci numbers; it's what people were discussing earlier.
08:34:09 <LtRipley> pjdelport: i can make it unbounded by using a ring buffer, it just takes some time to return :)
08:34:22 <pjdelport> LtRipley: That's also the same list that you would filter with "takeWhile (< n) fibs", to implement that function you were implementing earlier.
08:34:35 <pjdelport> LtRipley: A ring buffer is still bounded.
08:34:42 <geekosaur> btw "Early versions of JSON (such as specified by RFC 4627) required that a valid JSON "document" must consist of only an object or an array type—though they could contain other types within them. This restriction was relaxed starting with RFC 7158, so that a JSON document may consist entirely of any possible JSON typed value."
08:34:51 <RedNifre> So if I just need a boolean from the server, can you recommend something better than { "value" : true } ?
08:35:06 <mauke> [true]
08:35:12 <pjdelport> LtRipley: To translate it to C you'd first have to build a bunch of scaffolding to support non-strict streams.
08:35:50 <HeladoDeBrownie> RedNifre, "true" is a valid JSON string.
08:35:53 * geekosaur was under the impression that the javascript one was a retroactive renaming, but apparently not. could have sworn it started out in the java community...
08:36:10 <LtRipley> pjdelport: yes, my original point was that i don't find that ever in a description of an lgorithm that is dealing with Travelling Salesman Problem or whatever
08:36:14 <HeladoDeBrownie> RedNifre, so you don't need the object at all.
08:36:15 <bms1> let's say that I have a language I'm describing in Haskell with GADTs. Say I have a data kind ObjectType and my ADT is Expr :: ObjectType -> *
08:36:33 <bms1> and let's say that I want to parse this language into that ADT
08:37:01 <bms1> I can make an existential DExpr :: * where DExpr :: Expr a -> DExpr
08:37:10 <darkbolt> geekosaur: no, it started at netscape, and just wanted to ride the coat tail of java's popularity at the time
08:37:39 <geekosaur> darkbolt, the topic is json not javascript. I know the history of livescript^Wjavascript, tyvm
08:37:39 <bms1> but now as I parse, I need to essentially typecheck things dynamically. How do I do that?
08:37:49 <vanila> bms1, yes you would need to typecheck as you go
08:38:00 <tnks> thoughtpolice: when you made a Haskell DSL to write out Dockerfiles, did you put that on Hackage?
08:38:07 <vanila> bms1, alternative create a stripped ADT vresion of the GADT - and then you have parsing and typechecking separate
08:38:52 <bms1> vanila: That's what I was thinking of doing
08:38:55 <darkbolt> geekosaur: ah, sorry,  havent had enough coffee yet to read properly ;)
08:39:12 <RedNifre> That's nice, I think it's fine to define valid json as one single value which can be a primitive or object or array. Now I only have to figure out whether scotty only supports sending that or if there is an error in my code.
08:40:50 <heatsink> LtRipley: Linear algebra provides nice examples where FP gives you a nicer problem decomposition.
08:41:08 <heatsink> LtRipley: Imperatively, you'd define matrix-vector product as a doubly nested loop that reads from m and x and writes to y.
08:41:27 <heatsink> LtRipley: Functionally, you might define it as a collection of dot products, one for each row of m.
08:41:40 <heatsink> LtRipley: mvm m x = map (x `dot`) $ rows m
08:42:11 <heatsink> LtRipley: FP makes it convenient to decompose the problem into readable pieces: dot product, row decomposition, and the complete algorithm.
08:42:36 <bms1> vanila: How would "typechecking as you go" work?
08:42:52 <LtRipley> heatsink: didnt consider that as something only FP can do
08:43:49 <vanila> bms1, it's hard to explain, I can write a simple example
08:43:53 <bms1> Like let's say I have Vectors (length-indexed), but I have existentially quantified the length away. How could I return either the Just the zip of the vectors if they have the same length, or Nothing otherwise?
08:44:10 <vanila> yes!
08:44:28 <bms1> I guess I need to do a Typeable/KnownNat and then unsafeCoerce or something?
08:44:35 <bms1> vanila: thanks!
08:45:22 <benzrf> vanila: that's pretty gross dude
08:45:23 <geekosaur> vanila: re compilers, I suppose it depends on how you define compiler. there is at least one pass which translates a human-accessible form to a machine-accessible form, so to me that is a compiler
08:45:25 <benzrf> er, bms1
08:45:35 <benzrf> bms1: i think you just want dependtent types
08:45:41 <vanila> bms1, you do not need to use any unsafe functions to do this!
08:45:46 <RedNifre> does type inference work from one monad to the next? E.g. if I have a record constructor that takes an Integer, should this work?:
08:45:52 <RedNifre> count <- jsonData
08:45:55 <RedNifre> Something count
08:46:11 <geekosaur> if you're going to define a compiler as targeting some specific architecture, then does LLVM involve compilers? javac? f#?
08:46:17 <HeladoDeBrownie> RedNifre, do you know how do expressions desugar?
08:47:20 <J_Arcane2> Huh. Haskell is #12 in the new Gartner index: http://blogs.gartner.com/mark_driver/2014/10/02/gartner-programming-language-index-for-2014/
08:47:40 <HeladoDeBrownie> Oh no, it's too mainstream! Abandon ship! :P
08:48:19 <bms1> benzrf: And that's why I'm using Haskell :)
08:49:10 <geekosaur> (for that matter, where do you draw the line relative to a compiler targeting an architecture that was planned but never implemented?)
08:50:55 <EmreY> Hey there #haskell, is there a way to install Haskell Platform to a specific location in a self-contained way? For example, I install my racket in ~/local/racket and I want to do exactly the same for Haskell in ~/local/ghc (or something like that).
08:51:27 <bms1> :t GHC.TypeLits.sameNat
08:51:29 <lambdabot> (GHC.TypeLits.KnownNat b, GHC.TypeLits.KnownNat a) => Proxy a -> Proxy b -> Maybe (a :~: b)
08:51:56 <bms1> Would I want to use something like that, and then case-analyze the Just Refl?
08:52:23 <geekosaur> vanila: basically that question is a deep, deep pit with vipers waiting for you wherever you manage to stop your fall
08:52:55 <HeladoDeBrownie> EmreY, you can use a --configure prefix when installing GHC binaries, at least, not sure about Platform. Did you want the Platform in particular?
08:53:59 <RedNifre> HeladoDeBrownie Probably not.
08:54:34 <HeladoDeBrownie> RedNifre, okay, well take a look at this: do { a' <- a ; f a' } = a >>= \a' -> f a'
08:54:47 <HeladoDeBrownie> RedNifre, do the type unification and I think that should answer your question
08:54:57 <HeladoDeBrownie> RedNifre, do you want help stepping through that?
08:55:17 <RedNifre> Maybe in a minute, I first have to think a bit for myself.
08:56:37 <RedNifre> Well, if for example f :: String -> String then the compiler could figure it out, right?
08:56:45 <RedNifre> But not if f :: a -> a
08:56:46 <HeladoDeBrownie> RedNifre, figure what out?
08:57:21 <RedNifre> what the type of the first a should be.
08:57:24 <HeladoDeBrownie> RedNifre, okay first of all, let's put this here
08:57:26 <HeladoDeBrownie> @type (>>=)
08:57:39 <HeladoDeBrownie> Come on lambdabot, don't fail me now
08:58:03 <HeladoDeBrownie> (>>=) :: Monad m => m a -> (a -> m b) -> m b
08:58:43 <HeladoDeBrownie> Anyway, so if we used f :: a -> a for our function, we'd be trying to unify c ~ m d
08:58:57 <RedNifre> what is ~
08:58:59 <HeladoDeBrownie> Which I think in this instance isn't quite what you were asking
08:59:02 <HeladoDeBrownie> unifies with
08:59:14 <RedNifre> What does unifies with mean?
08:59:15 <HeladoDeBrownie> Hmm, so actually, could you maybe clarify your question?
08:59:25 <HeladoDeBrownie> Okay, well do you know what type unification is?
08:59:44 <HeladoDeBrownie> Here, let's try a simple example
08:59:52 <RedNifre> Maybe not. I know type inference and that you can be explicit with ::
08:59:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:59:58 <HeladoDeBrownie> Say we have id :: a -> a and myText :: String.
09:00:08 <HeladoDeBrownie> Our goal will be to find out what is the type of id myText.
09:00:19 <HeladoDeBrownie> To do this, we perform type unification.
09:00:45 <HeladoDeBrownie> So we know that the input is a String, therefore we unify String with the input variable, a.
09:00:48 <HeladoDeBrownie> a ~ String
09:00:55 <RedNifre> So type unifications means filling out the blanks with the concrete types that we have?
09:01:15 <HeladoDeBrownie> This is a particular easy example, since the output is the same as the input, so we've unified all the variables with a type.
09:01:30 <HeladoDeBrownie> So since a ~ String, a -> a specializes to String -> String.
09:01:38 <HeladoDeBrownie> Make sense?
09:01:41 <HeladoDeBrownie> Yes, basically.
09:02:04 <HeladoDeBrownie> "Concrete types" means something different, but I get what you mean.
09:04:08 <HeladoDeBrownie> RedNifre, if you understand, we can try other examples if you like.
09:05:19 <vanila> bms1, http://lpaste.net/112075 this  shows ADT->GADT inference with polymorphic if
09:05:37 <bms1> vanila: You're awesome! Thanks!
09:05:43 <RedNifre> one second...
09:06:04 <RedNifre> What is the correct word for what I mean when I say "concrete type"?
09:06:23 <HeladoDeBrownie> RedNifre, a type, as opposed to a type variable.
09:07:18 <ooaaooaa> I would like to write an optimizing HTTP proxy to compress html and image content. I know Squid exists, but I would like to learn Haskell while doing this. Can anyone give me pointers on how to get started (I am a beginner)
09:07:42 <EmreY> HeladoDeBrownie I probably don't, I'm a newcomer. What would you recommend? As far as I understand the platform has a few more conveniences for package installation, but is there anything more?
09:08:10 <pjdelport> ooaaooaa: That's a hefty project to tackle!
09:08:25 <HeladoDeBrownie> EmreY, the Platform consists of GHC, cabal-install, and some packages that are also obtainable using cabal-install.
09:08:52 <EmreY> Alright so I can install them all manually with the prefix of my choice, right?
09:08:59 <HeladoDeBrownie> EmreY, what I would suggest is to install GHC from binaries. You can grab cabal either from your distro or from binaries.
09:09:02 <HeladoDeBrownie> EmreY, yep.
09:09:08 <pjdelport> ooaaooaa: How production-ready are you aiming for? Getting HTTP proxying right is quite hairy in general, Haskell aside.
09:09:30 <EmreY> Oh forgot to mention, I'm on OS X. Not that it would change anything, I guess.
09:09:33 <pjdelport> Or is it just for learning?
09:09:44 <sagittarian> @src ap
09:09:59 <HeladoDeBrownie> EmreY, I'm not familiar with OS X's peculiarities, but I believe you should still be able to get GHC and cabal-install from binaries, at least.
09:10:28 <EmreY> It seems so. Thanks for your time and help.
09:10:28 <HeladoDeBrownie> EmreY, http://www.haskell.org/ghc/download_ghc_7_8_3#binaries http://www.haskell.org/cabal/download.html
09:11:07 <HeladoDeBrownie> EmreY, you'll need to do a little bit of setup as well. Should I tell you about that now or do you want me to walk you through it once you've installed those, or do you not need more help?
09:12:11 <EmreY> That would be nice if you told about it now, if it's not a lot to type.
09:12:17 <HeladoDeBrownie> Okay.
09:12:40 <HeladoDeBrownie> You want to put $HOME/.cabal/bin in your $PATH, if those are things OS X does as well. I think they are.
09:12:51 <EmreY> They are.
09:12:54 <HeladoDeBrownie> You'll also want to `cabal update && cabal install cabal-install`.
09:13:11 <HeladoDeBrownie> This will ensure your cabal-install is the latest.
09:13:32 <HeladoDeBrownie> That latest version will be in the cabal/bin directory I mentioned, along with other binaries you happen to install there.
09:14:24 <ooaaooaa> pjdelport, I can imagine. I was hoping to take small steps. 1) Accept HTTP request from browser 2) Fetch page 3) Compress 4) Serve
09:14:24 <ooaaooaa> pjdelport, I am hoping to use it for my smartphone
09:14:24 <lambdabot> ap = liftM2 id
09:14:24 <ooaaooaa> Half learning and half real life use. I understand there will be limitations
09:14:24 <ooaaooaa> pjdelport, No HTTPS support etc., but for the time being I am ok with that
09:14:29 <ooaaooaa> pjdelport, which parts do you think are hairy in an optimizing proxy?
09:14:41 <RedNifre> Dammit, I was looking at the wrong Haskell JSON library. My example can't work because Aeson is not compliant to the 2013 JSON RFC :/
09:14:41 <RedNifre> What is the difference between type inference and type unification? Is type unification complete type inference?
09:14:42 <osfameron> is there a good article on modelling maze solving with lists?
09:14:42 <osfameron> I can see how to do it with a cartesian join... but obviously some paths are shorter than others, so I'm not sure it maps onto this
09:14:59 <HeladoDeBrownie> EmreY, it's also worth learning about sanboxes. You can `cabal sandbox init` to create a local package repository, and then most cabal commands will pay attention to that as long as your PWD is the same directory as it.
09:15:01 <sagittarian> @src (<*>)
09:15:02 <lambdabot> Source not found. My mind is going. I can feel it.
09:15:10 <pjdelport> ooaaooaa: HTTP itself is pretty complicated, in detail.
09:15:26 <HeladoDeBrownie> EmreY, this helps avoid dependency hell, but you may feel free to use your main cabal directory if you don't want to get into that.
09:15:42 <pjdelport> ooaaooaa: There's a *lot* more to proxying correctly than just intercepting and parsing some stuff: you have to respect a lot of semantics that sites rely on.
09:15:52 <EmreY> HeladoDeBrownie, that's exactly the way I like setting up things. Thanks for mentioning it.
09:15:54 <ooaaooaa> pjdelport: I was hoping network.http would take care of the http and all I would have to do was compress stuff
09:17:28 <pjdelport> ooaaooaa: Well, there's quite a bit you'll have to do on top of the library, at best.
09:17:37 <HeladoDeBrownie> RedNifre, type unification is a solving of constraints. Type inference is assigning a type to an expression, and does involve type unification.
09:18:21 <HeladoDeBrownie> RedNifre, the object of type unification is to come up with the (a) most general type for some value.
09:18:24 <pjdelport> ooaaooaa: You'll have to deal with things like content negotiation, transfer encodings, chunking, conditional and range requests, size headers...
09:19:00 <pjdelport> All of those will probably interact with any compression you want to do.
09:22:55 <RedNifre> Can I combine a function call with a binding? I.e. I have commentWrapper <- jsonData but I want something like comment <- jsonText jsonData. Do I need comment <- jsonText >>= jsonData or how would I do that?
09:23:24 <carter> monochrom: that would be gnarly and explodey
09:23:49 <monochrom> hmm, what did I say?
09:24:08 <carter> MINIMAL shedding?
09:24:14 <carter> or am I mixing up people again
09:24:16 <ooaaooaa> pjdelport: What about if I simplified it to: Get request, fetch page, render to png and send png image to browser? (I know that really isn't "optimizng" anything, but I have a high latency, high bandwidth connection on my smartphone and a cheap VPS with a great wired connection)
09:24:31 <carter> monochrom: derp, i mean geekosaur  i think
09:24:34 <monochrom> heh
09:24:38 <RedNifre> Is there a better way to do this?:
09:24:41 <roboguy_> RedNifre: I'm not sure I understand. what are the types of jsonData and jsonText?
09:24:44 <RedNifre> whatIHave <- jsonData
09:24:47 <RedNifre> let whatIWant = jsonText whatIHave
09:24:54 <carter> monochrom: i clearly confuse people whos names != irc handles
09:24:59 <mauke> jsonText <$> jsonData
09:25:24 <RedNifre> hm!
09:25:32 <monochrom> that is a pretty good equivalence class :)
09:25:46 <pjdelport> ooaaooaa: If you're just trying to solve the problem, have you looked at http://ziproxy.sourceforge.net/ ?
09:27:22 <pjdelport> Otherwise you could implement things like that, as long as you're aware that it's probably a big project to tackle: HTTP proxying is one of those things that are deceptively complex and tricky.
09:29:05 <geekosaur> yes, that was me
09:29:19 <RedNifre> What is this with fmap and <$> being the same? So far I've been usig fmap for normal functors and <$> only if I'm also using <*> with it. When to use which and why?
09:29:36 <ooaaooaa> pjdelport: that is great! I didn't know about ziproxy
09:29:48 <geekosaur> they're the same. which one leads to code you can read more easily? use that
09:30:04 <pjdelport> RedNifre: fmap predates <$>
09:30:23 <ooaaooaa> pjdelport: I will try it out and see how well it works  :)
09:30:29 <ooaaooaa> pjdelport: Thank you! :)
09:31:00 <geekosaur> and yes, fmap is ancient, <$> was introduced with Applicatives to try to come up with something vaguely resembling the original "idiom brackets" proposal
09:31:10 <roboguy_> RedNifre: there isn't really a difference except for the different names (and that fmap is the one that's actually in the type class)
09:31:58 <pjdelport> ooaaooaa: With all that said, you should still try a cool Haskell project of some sort. :)
09:32:09 <HeladoDeBrownie> I tend to use (<$>) for its similarity to ($)
09:32:39 <HeladoDeBrownie> But will often use fmap when composing fmaps
09:32:54 <HeladoDeBrownie> @type fmap . fmap . fmap
09:32:55 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:32:57 <RedNifre> I get the impression that many identical concepts have different names in different places for historical reasons. Is there a road map to clean up everything?
09:33:00 <ooaaooaa> pjdelport: I have a feeling I will want some bells and whistles that ziproxy doesn't offer and will end up writing something after all
09:33:16 <mauke> :t fmap fmap (fmap fmap fmap)
09:33:16 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:33:28 <HeladoDeBrownie> RedNifre, the things that matter less are unlikely to change anytime soon. However, some changes are being made, like the Applicative-Monad Proposal.
09:33:34 <HeladoDeBrownie> That was recently implemented, as I recall.
09:34:39 <pjdelport> ooaaooaa: It would be a great project! If you tackle it, you should document your progress in a blog or such. :)
09:34:50 <pjdelport> As a learning / teaching exercise.
09:35:01 <ooaaooaa> pjdelport: I will! Thanks for the tips. Installing ziproxy now
09:35:35 <RedNifre> So are pure and return now called unit or how did they unify it?
09:36:00 <augur> gosh are people talking about lenses?
09:36:45 <HeladoDeBrownie> RedNifre, I don't think they touched either of those.
09:36:56 <HeladoDeBrownie> Besides, changing them both to be called unit would break way more code than necessary.
09:36:59 <quchen> RedNifre: Everything stays as it was. The AMP basically added a "=>".
09:37:16 <HeladoDeBrownie> Not to mention invalidate various tutorials. They want to make these changes as necessary but with as little fallout as can be managed.
09:37:22 <quchen> return has a default implementation (= pure) though.
09:38:47 <bezirg> hi, I am using cabal for a local package. I am used into this workflow "cabal configure && cabal build && cabal install" but cabal install re-runs the whole process of configuring and building again. Is there a command similar to "cabal install" that just installs a successful build like "make install"?
09:39:12 <Kron> is there any way to see all the list of possible cabal commands?
09:39:27 <quchen> Kron: cabal --help?
09:39:28 <Kron> can I ask cabal which versions of which packages I have installed?
09:39:30 <Kron> hmm
09:39:44 <geekosaur> I thonk there's cabal list --installed
09:39:45 <quchen> ghc-pkg list
09:39:51 <geekosaur> but you should really do;ghc-pkg list
09:41:25 <Kron> ... is there a tutorial on any of this? neither of these programs have man pages
09:44:16 <geekosaur> not so far as I know. (and yes, I'm grumpy that there seems to be no documentation for cabal-install, just a ridiculously insufficient tutorial)
09:44:47 <David> Is there a way to import all the libraries imported by a file?
09:45:14 <Kron> how does installing a new version of lens break a lot of other libraries? don't those just connect to the old veersion of lens?
09:45:18 <HeladoDeBrownie> David, in ghci, :l your-file.hs should do it
09:45:18 <David> e.g. I have a file with nothing more than a bunch of import statements and I'd like to be able to do import AllImports rather than paste that into every single file
09:45:19 <hiptobecubic> David, import the file?
09:45:40 <HeladoDeBrownie> David, oh I see, then export the module. In the exports list: module Foo.Bar
09:45:46 <geekosaur> Kron, only if the other things use a capped dependency on lens. some developers insist you should never cap dependencies...
09:45:49 <HeladoDeBrownie> module(s)
09:46:14 <geekosaur> which is a cheap thing for that dev and a high price to people who may not even know there's a dependency :(
09:46:31 <David> so I'd have to do something like module AllImports (Data.List, Data.Maybe) where import Data.List import Data.Maybe?
09:46:31 <geekosaur> (that said, I don't know that lens is the thing that is uncapped)
09:46:31 <monochrom> reading material for cabal-install, from basic to advanced: http://www.haskell.org/cabal/users-guide/ http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml http://www.vex.net/~trebla/haskell/sicp.xhtml
09:48:07 <geekosaur> worse, because of the way ghc handles dependencies, things that you'd expect to just work lead to deadly diamond dependencies, which are one form of what's miscalled "cabal hell"
09:48:33 <Kron> how do I uninstall broken packages? or uninstall anything I guess
09:49:20 <geekosaur> there isn't an uninstaller. "ghc-pkg unregister" the packages, possibly clean up anything under ~/.cabal left behind, reinstall
09:49:21 <RedNifre> What are the dangers of these "dangerous" cabal operations? What is the worst that could happen?
09:50:01 <monochrom> so many questions. so few readers.
09:50:04 <geekosaur> David: need to prefix those modules in the export list with "module"
09:50:24 <Kron> that's very... not user friendly
09:50:27 <geekosaur> Kron: as just obliquely noted, you should read http://www.vex.net/~trebla/haskell/sicp.xhtml
09:50:36 <RedNifre> Well, I'm basically asking what the risk would be of not understanding cabal completely.
09:50:46 <David> geekosaur: so AllImports(module Data.List, Data.Maybe) ...
09:50:54 <David> er...module Data.Maybe
09:51:13 <David> is there a way to make them qualified?
09:51:19 <geekosaur> cabal is intended to be a front end for compiler package systems. it can't be a package manager without (a) stealing most of the necessary work from ghc, which is a good way to make ghc get tangled up in its own shorts, and (b) losing any ability to work with other things like uhc or hugs
09:51:26 <quchen> David: How about this? http://lpaste.net/112079
09:51:55 <geekosaur> basically most of "cabal's" shortcomings are ghc's shortcomings
09:52:00 <David> oh, thanks.
09:52:05 <RedNifre> For example, the risk of not understanding git completely is that you can delete all your work and the work on the remote master branch in such a way that it can not be recovered again. What is the worst that can happen with cabal?
09:52:14 <Kron> I have to unregister all my packages on separate lines? oof
09:52:40 <geekosaur> RedNifre: having to nuke your entire package database (both of them if you;ve been doing global installs --- don't) and start over
09:53:06 <geekosaur> again, http://www.vex.net/~trebla/haskell/sicp.xhtml please read and understand this
09:53:35 <geekosaur> (yes, monochrom is cranky for a reason :)
09:54:15 <David> something like this? http://hastebin.com/ejovituvod.hs
09:54:30 <RedNifre> So the risk is that I could mess up a production server and getting it to work again would mean downtime. So, if I mess up my development machine, no permanent damage can be done?
09:54:45 <mauke> David: line 10 looks like a syntax error
09:55:07 <David> yes, missed the as...
09:55:40 <joshcough> anyone willing to field a cabal question?
09:56:01 <joshcough> jfischoff: hi
09:56:05 <quchen> David: If you export the modules using the qualified trick I posted above you can omit writing everything twice.
09:56:22 <Kron> hah http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml is really nice
09:56:30 <Kron> I was thinking of scorched earth strategies
09:56:32 <monochrom> thanks
09:56:35 <David> ok, I'll try that
09:56:46 <David> How do I deal with the uniplate thing though?
09:56:59 <David> because I'm already exporting it as Uni
09:57:09 <geekosaur> and this isn't just being lazy --- it's hard to explain the whole thing comprehensibly while standing on one foot
09:58:15 <Kron> wwhat does "--haddock-hyperlink-source" do?
09:58:25 <mauke> enable hyperlinking from docs to coloured source code
09:59:37 <Kron> neat
09:59:50 <quchen> The last version of Cabal supports this via config file setting.
09:59:52 <quchen> Finally.
09:59:55 <mauke> (I copy/pasted that)
10:00:13 <Kron> how would I get hscolour outside cabal?
10:00:38 <monochrom> one way is to have me email you the executable :)
10:00:57 <monochrom> latest haskell platform comes with hscolour.
10:01:49 <monochrom> but I don't think there is anything you miss if you use cabal-install to get hscolour when you don't already have hscolour.
10:01:55 <Kron> gotcha
10:02:32 <David> Is the solution http://stackoverflow.com/questions/14238729/producing-multiple-executables-from-single-project still the reccomended way to have cabal build multiple executables?
10:02:47 <joshcough> i have this haskell starter project (https://github.com/joshcough/HaskellStarter), which is more of a cabal starter project, and i have upper bounds on my dependencies, but im thinking i should remove them
10:03:08 <geekosaur> please don't
10:03:12 <joshcough> i think beginners would be better served if i just removed them and didnt really talk about it
10:03:28 <geekosaur> although I can tell I'm going to lose that battle and we can all have a happy install-a-separate-ecosystem-for-every-project world
10:03:41 <geekosaur> and don't ever try to mix them because it won't work
10:03:44 <joshcough> was wondering what people thought
10:04:21 <monochrom> beginners are best served if you include upper bounds and update them every 3 months.
10:04:34 <ClaudiusMaximus> missing upper bounds in an old version cause weird issues when trying to install a newer version with upper bounds - cabal might choose the old version and fail to build it
10:05:14 <ClaudiusMaximus> instead of saying that the new version has upper bounds that conflict with the newer packages that you have installed
10:05:33 <monochrom> servicing beginners is a life-long commitment. are you ready?
10:05:57 <joshcough> its the only thing im any good at.
10:06:00 <monochrom> (is it servicing or serving?)
10:06:04 <Kron> what's -o and -o2 to ghc? there are several levels of optimization/
10:06:33 <joshcough> also, jfischoff suggested using cabal freeze
10:06:43 <geekosaur> Kron: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#optimise-pkgs
10:06:57 <joshcough> would you say its better to just update the upper bounds regularly, or use freeze?
10:07:31 <geekosaur> -O2 doesn't get you much more than -O1 because so many possible optimizations turn out to be pessimizations in circumstances the compiler can't really detect ahead of time
10:08:19 <geekosaur> for example it's all too easy to apply what looks like an obvious optimization that kills fusion as a side effect
10:08:35 <geekosaur> resulting in overall much worse code even if it's locally "better"
10:08:40 <Kron> I've tried to erase my .ghc and install everything back in one go, but it tells me it'll break some packages still
10:08:45 <Kron> how do I make it just forget some packages?
10:11:33 <mkscrg> is it a common pattern to use existentials and GADTs together?
10:11:52 <trap_exit> this ... is way off topic ... but .... does anyone know of an alarm clock where I can _program_ it via my computer? i.e. I can use my computer to, either over usb or wifi, program the alarm clock's time / volume / etc ...
10:12:08 <mkscrg> i.e. existentials to hide types in collections, GADTs to recover the types?
10:12:20 <doismellburning> trap_exit: hah I built one
10:12:36 <nshepperd> perhaps cabal needs some magical buildbot that automatically updates dependencies as long as everything still compiles
10:12:38 <trap_exit> doismellburning: I can PM you for details?
10:13:08 <nshepperd> / type-checks
10:13:08 <doismellburning> trap_exit: sure
10:15:26 <joshcough> sorry to ask again, but any opinions on cabal freeze? worth it in a project like this?
10:15:45 <nshepperd> if packages then used the major version number for breaking changes that don't change the types, you would "almost never" have to manually update the dependencies
10:16:22 <nshepperd> that would be a dream
10:16:47 <joshcough> :)
10:17:07 <doismellburning> nshepperd: did someone say semver.org? ;P
10:19:19 <nshepperd> well, semver is great, but sometimes the "breaking change" is in a part that your package doesn't actually use
10:19:44 <nshepperd> so you would like your computer to do the work for you, since we are lazy :)
10:23:25 <Kron> is it better to use xmonad from the cabal packages or from the external repo packages?
10:23:31 * hackagebot leetify 0.1.0.0 - Leetify text  http://hackage.haskell.org/package/leetify-0.1.0.0 (DimitriSabadie)
10:23:33 <Kron> I suspect cabal directly, but i'm notsure
10:24:57 <geekosaur> the repo packages are generally easier, the cabal packages generally require you to install a bunch of OS dependencies
10:25:13 <geekosaur> (notably, on red hat-ish or debian-ish systems you need a bunch of OS devel packages)
10:25:17 <Kron> gotcha
10:25:39 <nulpunkt> joshcough: Just looked through your starter project, as a newbie, that was very helpful!
10:26:03 <joshcough> nulpunkt: thanks. feel free to send pull requests if anything is confusing
10:26:26 <nulpunkt> joshcough: That was kinda the look thing, things got more clear
10:26:32 <nulpunkt> :)
10:26:53 <joshcough> say again? i dont understand.
10:27:17 <nulpunkt> sorry, the good thing was that it cleared up some things for me
10:27:40 <joshcough> great. im glad to hear that.
10:28:32 * hackagebot leetify 0.1.0.1 - Leetify text  http://hackage.haskell.org/package/leetify-0.1.0.1 (DimitriSabadie)
10:29:22 <phaazon> H3LL0, 7H15 15 D4W6
10:29:27 <phaazon> huhu :D
10:32:52 <CrazyM4n> I want to make a falling sand game. Would helm be a good library for that? I've been wanting to learn it.
10:34:04 <Kron> ookay, I think I broke everything. fun! Now to try and fix it
10:34:17 <jfischoff> joshcough: hey
10:34:23 <Kron> ghc-pkg check just gives me four haddock errors
10:34:27 <jfischoff> joshcough: just saw your questions
10:34:28 <joshcough> hi
10:34:30 <joshcough> cool
10:34:39 <joshcough> i think i got some good advice
10:34:48 <jfischoff> oh cool I’ll scroll up
10:35:14 <joshcough> basically, dont drop the upper bounds, keep them updated.
10:35:29 <joshcough> no one answered my freeze question though.
10:35:39 <freeman42> any ideas on how to fix this issue? https://github.com/yesodweb/yesod/issues/839
10:35:40 <jfischoff> freeze is good
10:35:41 <Kron> "Warning: haddock-interfaces: /usr/share/doc/x86_64-linux-ghc-7.8.3/xmonad-contrib-0.11.3/html/xmonad-contrib.haddock doesn't exist or isn't a file"
10:35:46 <Kron> what do lines like this entail?
10:35:55 <jfischoff> I think hackage is supposed to start accepting constraint files
10:36:00 <jfischoff> generated from freeze
10:36:03 <joshcough> but it think it makes sense to keep the upper bounds updated, and then re-freeze whenever i update them.
10:36:07 <Kron> I'm getting haddock-interfaces and haddock-html errors for both my xmonad and xmonad-contrib
10:36:14 <jfischoff> joshcough: sure
10:36:20 <Kron> they used to be in my /usr/lib/ghc-7.8.3 folder
10:36:24 <Kron> but they aren't anymore
10:36:27 <Kron> which worries me
10:36:33 <joshcough> jfischoff: ok. im doing that now then. thank you.
10:36:47 <jfischoff> cool
10:37:07 <jfischoff> thank you the project looks really cool. its basically the what I do manually
10:37:49 <joshcough> im really glad people find it useful. i want to keep it up to date, so i appreciate the help.
10:38:22 <jfischoff> personally, now that I use freeze, I’m more leinent with my version numbers. I only add upper and lower bound constraints once I know them
10:38:51 <jfischoff> but I think that is just personal perference
10:42:15 <joshcough> jfischoff: so, you just list your deps with no version numbers, and if things work, freeze, add version numbers into your cabal file?
10:42:20 <zq> is a map over a finite list literal of n elements guaranteed to have n elements? accounting for laziness and all that
10:43:10 <jfischoff> joshcough: I think I do something slightly different from what you described
10:43:24 <monochrom> I guarantee that. is that enough?
10:43:32 <jfischoff> joshcough: Start with no version numbers. Freeze if it works.
10:44:05 <jfischoff> joshcough: I don’t have to copy the version numbers into the cabal file, cabal knows to read the cabal.config to get the constraints
10:44:37 <jfischoff> joshcough: then if I discover that my stuff is incompatible with a version of something, change the cabal file to prevent it from installing
10:45:02 <jfischoff> but the constraints from the freeze are enough to have it build in a sandbox reliably
10:45:08 <joshcough> ok. so with freeze, is there any benefit to having bounds in the cabal file? other than to serve as documentation?
10:46:50 <jfischoff> joshcough: for hackage
10:47:07 <jfischoff> because we can’t upload the freeze file
10:47:09 <jfischoff> yet
10:47:10 <jfischoff> and
10:47:20 <jfischoff> if it is a library
10:47:43 <joshcough> i see.
10:47:51 <jfischoff> but if it is a “leaf” and you think it will always be built in a sandbox, not really
10:48:38 <egasimus> So let's say I want to start hacking on an existing Haskell application, such as xmonad or xmobar. Any good guides on the workflow?
10:52:10 <joshcough> jfischoff: i pushed the change you were asking for. can you try again? if it works ill close the ticket.
10:52:22 <jfischoff> yeah one sec
10:56:56 <jfischoff> oh
10:58:48 <asfp> the intertubes has no self-contained example of safecopy + serialize.  that's a shame.
11:08:32 <CrazyM4n> How can you have a Repa array of custom data?
11:08:57 <CrazyM4n> I'm trying to make a Repa array from gloss colors
11:08:59 <David> What does this mean? Warning: output was redirected with -o, but no output will be generated because there is no Heurisic module.
11:09:20 <David> oh derp
11:09:21 <David> ugh
11:09:22 <CrazyM4n> But no matter what it just tells me that there's no instance declaration for (Data.Vector.Unboxed.Base.Unbox Color)
11:09:26 <David> I misspelled heuristic
11:09:28 <David> facedesk
11:16:50 <merijn> CrazyM4n: To use unboxed vector your datatype needs to be an instance of the Unbox class
11:17:18 <merijn> CrazyM4n: Whether it *can* be an instance of the class, depends on your datatype (and the class itself, I'm not familiar with it...)
11:17:19 <CrazyM4n> merijn: It's a datatype provided by gloss
11:17:50 <CrazyM4n> merijn: It requires a delayed array, but I don't quite know how do use them, so I was trying to make an unboxed array and delay it
11:18:12 <CrazyM4n> Maybe could you help me if I uploaded it?
11:18:29 <merijn> I have zero experience with vector/repa or gloss, so unlikely :)
11:18:35 <merijn> Try using a boxed array?
11:18:43 <CrazyM4n> How would I do that?
11:18:43 <CrazyM4n> D:
11:20:40 <merijn> Apparently you can't with repa
11:20:47 <merijn> It only seems to work with unboxed vectors
11:21:08 <monochrom> if you use vector, Storable is close enough to Unboxed. if you use repa, I don't know repa.
11:21:29 <Kron> in a cabal package directory you're constructing, what are the non-generated irrecoverable files?
11:21:37 <Kron> the ones that matter in a version control sense
11:21:45 <Kron> just source and package.cabal?
11:21:48 <monochrom> the benefit of Storable is that you can write your own Storable instance. (you can't write your own Unboxed instance, IIRC)
11:21:51 <merijn> Kron: you mean other than your source?
11:21:55 <Kron> yeah
11:22:05 <merijn> Kron: package.cabal and the LICENSE file that cabal generates
11:22:08 <Kron> as far as I can tell, it's just my own source and my package.cabal file for metadata
11:22:11 <Kron> hmmm
11:22:14 <Kron> what's the LICENSE file?
11:22:33 <merijn> The file that contains the license you selected during "cabal init"? :)
11:22:48 <merijn> i.e., MIT, BSD3, GPL, etc.
11:23:10 <Kron> ahhh gotcha
11:24:38 <CrazyM4n> How does fromFunction work in Repa
11:25:10 <CrazyM4n> Say, I have a function that is an [[Int]] -> [[Int]]
11:25:34 <CrazyM4n> How  would I use fromFunction to get an Array D DIM2 Int?
11:30:59 <Donni> V
11:33:06 <CaptainK> Any reviews on Codec.Encryption.AES?
11:34:15 <nitrix> LtRipley: Data structures also differs. You'll have to make trees again from lists, etc.
11:34:32 <nitrix> LtRipley: Sorry, was afk.
11:40:16 <Kron> is there anything wrong with a build-depends line like "  build-depends:       base >= 4.6.* && <= 4.7.*,"?
11:40:27 <Kron> it's telling me that there are parse errors
11:40:31 <geekosaur> what does that even mean?
11:40:42 <geekosaur> you can use wildcards, or you can use ranges
11:40:42 <Kron> anything from 4.6.* and 4.7.*
11:40:47 <Kron> okay
11:41:04 <geekosaur> do I interpet >= 4.6.* as meaning greater than 4.6,0 or 4.6.whatever version I can find or 4.6.latest?
11:41:43 <Kron> range I guess
11:41:56 <Kron> thanks
11:42:03 <Kron> I'll just go with strict api ranges
11:42:28 <merijn> It's simple
11:42:35 <merijn> You can't use wildcards with comparison operators
11:42:53 <merijn> So EITHER "base >= 4.6.0" *or* "base == 4.6.*"
11:43:04 <Kron> gotcha
11:50:03 <cpa_> you guys know if there's documentation for the rest package somewhere?
11:52:43 <monochrom> I like using syntax restrictions to eliminate semantic questions :)
11:53:26 <trap_exit> where can I read about haskell enums?
11:53:29 <trap_exit> I need a in depth understanding of Enums
11:53:40 <trap_exit> but I feel I've skimmed parts of books when they talk bout Enums since they're so boring.
11:53:41 * monochrom praises Sapir-Whorf :)
11:53:45 <trap_exit> Now however, I need a deep understanding of Enums.
11:55:17 <Kron> I find the source documents are the best
11:55:28 <Kron> I mean, for the Enum typeclass. I assume that's what you mean
11:55:53 <Kron> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Enum
12:00:04 <merijn> trap_exit: What kind of depth are you expecting?
12:00:38 <trap_exit> I don't know what I don't know.
12:00:39 <merijn> An enum is just an ADT that's an instance of Enum...
12:00:54 <trap_exit> I have a problem. I think I should use Enums, so I can map shit to integers.
12:00:54 <trap_exit> But I know nothign about Enums.
12:01:00 <merijn> And enum only maps a sequence of natural numbers to a sequence of whatever constructor you had
12:03:01 <rob_> Hey everyone. I'm a haskell noob and I'm looking for help implementing union. Am I in the right place?
12:03:19 <trap_exit> data Union = UnionA choiceA | UnionB choiceB
12:03:20 <benzrf> rob_: yep!
12:03:26 <trap_exit> next question :-)
12:03:36 <benzrf> trap_exit: choiceA and choiceB aren't in scope
12:03:39 <benzrf> 2/10
12:03:48 <trap_exit> data Union a b = Union a | Union b
12:03:50 <trap_exit> err
12:03:53 <magthe> when using OverloadedStrings, isn't there a way to tell GHC which type to prefer?
12:03:56 <trap_exit> data Union a b = UnionA a | UnionB b
12:04:07 <rob_> Woah I hadn't though of using data
12:04:08 <trap_exit> I think we just reinvented Either
12:04:10 <merijn> trap_exit: So, eh, Either? :)
12:04:17 <merijn> @quote Neither
12:04:17 <lambdabot> Nereid says: <killy9999> in which modules are finiteBitSize and bitSizeMaybe?  <killy9999> I can't find them using neither Hoogle nor Hayoo  <Nereid> ask hoogle or hayoo.  <Nereid> oh.
12:04:20 <merijn> eh
12:04:26 <merijn> That's not the one I wanted...
12:04:31 <merijn> @quote Neither.a.b
12:04:31 <lambdabot> Berengal says: data Neither a b = Left | Right
12:04:36 <merijn> :D
12:04:42 <benzrf> he he he
12:04:49 <trap_exit> rofl
12:05:02 <rob_> What's the benefit of using data though? Why not just make a function that returns a list?
12:05:13 <merijn> rob_: A list of what...
12:05:56 <rob_> The elements of both lists in common
12:06:30 <merijn> I have no idea what that means
12:06:49 <rob_> I mean union in terms of set theory. It takes two lists as arguments and returns the elements both lists have in common
12:06:56 <mauke> that's intersection
12:07:17 <rob_> oh damn you're right
12:07:31 <merijn> rob_: Data.Set
12:07:31 <mauke> :t intersect
12:07:33 <lambdabot> Eq a => [a] -> [a] -> [a]
12:07:38 <merijn> Or intersect, yes
12:07:45 <rob_> Learning dicrete and haskell simultaneously will do that to you
12:07:47 <mauke> > intersect "two lists" "as arguments"
12:07:49 <lambdabot>  "t sts"
12:08:29 <merijn> > S.intersect (S.fromList "two lists") (S.fromList "as arguments") -- proper Set intersection
12:08:31 <rob_> Is there a way to see the source of the function from the module?
12:08:31 <lambdabot>  Not in scope: ‘S.intersect’
12:08:31 <lambdabot>  Perhaps you meant one of these:
12:08:31 <lambdabot>    ‘BS.interact’ (imported from Data.ByteString),
12:08:31 <lambdabot>    ‘S.intersection’ (imported from Data.Set)
12:08:36 * hackagebot optparse-applicative 0.11.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.11.0 (PaoloCapriotti)
12:08:37 <merijn> aww, really?
12:08:41 <merijn> > S.intersection (S.fromList "two lists") (S.fromList "as arguments") -- proper Set intersection
12:08:43 <lambdabot>  can't find file: L.hs
12:08:53 <merijn> ...
12:08:58 <merijn> lambdabot doesn't like me
12:09:02 <Kron> is something wrong with the pointed package?
12:09:06 <Kron> can't install idris without it
12:09:27 <merijn> Kron: Yes, no, maybe
12:13:41 <rob_> Argh, ok I found the source for union but it's confusing
12:13:42 <rob_> -- | The 'union' function returns the list union of the two lists. -- For example, -- -- > "dog" `union` "cow" == "dogcw" -- -- Duplicates, and elements of the first list, are removed from the -- the second list, but if the first list contains duplicates, so will -- the result. -- It is a special case of 'unionBy', which allows the programmer to supply -- their own equality test.  union                   :: (Eq a) => [a] -> [a] -> [a] u
12:14:17 <rob_> hang oin
12:14:34 <rob_> union                   = unionBy (==)
12:14:39 <rob_> unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
12:15:08 <rob_> I don't get what is a fold doing in there? What purpose does that serve?
12:15:50 <merijn> rob_: For every element in xs, delete it from the "zero" value of the fold
12:16:08 <merijn> rob_: The zero value being "nubBy eq ys", i.e. "ys with all duplicates removed"
12:16:22 <merijn> Also, wow, that's a terribly slow implementation :)
12:17:17 <Kron> oh god is there any way to cabal install the --haddock-hyperlink-sources documentation... without actually installing the packages?
12:17:25 <rob_> merijn: What would be a better/simpler way to do this?
12:17:49 <merijn> rob_: Going through Data.Set
12:18:11 <merijn> Kron: Run "cabal haddock" in the directory?
12:19:38 <Kron> hmm, how do I get the source files then... --only-dependencies?
12:20:18 <geekosaur> cabal unpack
12:20:27 <merijn> Kron: Oh, I assumed you were in a directory with the cabal file, etc.
12:20:33 <merijn> Use "cabal get <package>"
12:20:41 <merijn> geekosaur: "cabal unpack" is deprecated, iirc
12:20:58 <monochrom> "unpack" was a great name, if you ask me
12:20:58 <geekosaur> figures
12:21:16 <monochrom> "get" is more ambiguous than "unpack"
12:21:49 <Kron> okay,t hanks!
12:22:18 <monochrom> "cabal haddock --hyperlink-source", "cabal copy". I am not sure whether you need "cabal configure" first.
12:22:38 <Kron> ... now I'm getting confused. Should I cabal get and then cabal haddock the files?
12:22:51 <Kron> or is cabal haddock --hyperlink-source <package-name> enough?
12:22:51 <monochrom> now I think you need "cabal configure" first. because "cabal copy" needs it.
12:23:10 <monochrom> there is no "cabal haddock <package-name>".
12:24:12 <simpson> What's the current best practice for setting up module-private state? I am told that the unsafePerformIO+newIORef hack is no longer the right way to do it.
12:24:44 <vanila> can't you use State monad?
12:24:49 <monochrom> who told that? and what did he/she provide as replacement?
12:25:19 <simpson> http://www.haskell.org/haskellwiki/Top_level_mutable_state
12:26:06 <merijn> simpson: Ignore that, it's still the de facto way to do it
12:26:14 <Guest36679> Hello, I'm trying to get a feel for the type system. Why does the following give a parse error?
12:26:16 <Guest36679> data IntOrStringList = [String] | [Int]
12:26:25 <mauke> missing constructor name
12:26:44 <Guest36679> @mauke Biut
12:26:44 <lambdabot> Unknown command, try @list
12:27:17 <nitrix> Hello guys, I wrote my first haskell function today! I'm working on a distributed file system and the first trivial step was reading a page stored locally, and potentially return its content. Please look at my localEndpointGet function.
12:27:17 <Guest36679> @mauke But this works: data IntOrString = String | Int
12:27:18 <lambdabot> Unknown command, try @list
12:27:20 <nitrix> https://coderpad.io/6ZC2JT6P
12:27:22 <monochrom> some of the proposals there are your call. the rest are not implemented and long forgotten.
12:27:30 <mauke> Guest36679: no, it doesn't
12:27:41 <Kron> any reason to not do "cabal haddock --hoogle --hyperlink-source"?
12:27:46 <Kron> as in, adding the hoogle flag
12:27:49 <Guest36679> @makue This also works data ListOfInts = [Int]
12:27:50 <lambdabot> Unknown command, try @list
12:27:54 <mauke> Guest36679: no, it doesn't
12:28:13 <monochrom> no reason, you can add --hoogle if you want
12:28:30 <nitrix> Criticism welcome, I need to learn Haskell...
12:28:31 <Kron> gotcha
12:29:05 <Kron> gosh this is really pretty. Need to use coderpad more
12:29:29 <merijn> nitrix: First criticism, "ByteString.Char8" is utter evil whose name shall not be mentioned
12:29:57 <monochrom> "data IntOrString = String | Int" is legal but means something else. "data ListOfInts = [Int]" is illegal. if you disagree, I'll just agree to disagree and good day.
12:30:01 <nitrix> merijn: But it has to be encoded has 8bit bytes to be compatible with the other pieces of that distributed system :(
12:30:24 <nitrix> merijn: Okay it doesn't show yet, but there's encoding and encryption coming.
12:30:32 <Kron> I think you can separate the IO from the pure code here
12:30:34 <merijn> nitrix: I'm not saying *ByteString* is wrong, I'm saying your way of obtaining a ByteString is evil
12:30:41 <Kron> localEndpointGet, I mean
12:30:54 <merijn> nitrix: Char8 will silently truncate and drop non-ASCII values
12:30:57 <nitrix> merijn: Kron: I see, please elaborate guys.
12:31:54 <Guest36679> mauke: This doesn't work either?
12:31:56 <Guest36679> data IntOrStringList2 = IntOrStringList2 [String] | IntOrStringList2 [Int]
12:32:06 <fuzzyhorns> im reading this: http://www.mail-archive.com/haskell-cafe@haskell.org/msg35716.html
12:32:16 <fuzzyhorns> but I dont get this "This isn't a coproduct. If we have f x = 1 and g y = 2, then there should exist a function h such that h . Left = f and h . Right = g, i.e.,"
12:32:28 <merijn> nitrix: If there is *any* chance of interacting with non-ASCII (basically, about 100% guaranteed if you have network/user input) the proper way is to use Data.Text.Encoding to convert Text to ByteString
12:32:50 <merijn> nitrix: (going String to Text is easy, that's just "Text.pack :: String -> Text")
12:33:04 <merijn> nitrix: The difference is that that actually gives you control over how you wish to handle encoding errors
12:33:07 <nitrix> merijn: I see, that indeed sounds critical. Let me fix it .
12:33:38 <mauke> Guest36679: correct
12:33:44 <fuzzyhorns> basically i dont understand why " then there should exist a function h such that h . Left = f and h . Right = g, i.e."
12:33:46 <monochrom> fuzzyhorns, that is how coproduct is defined.
12:33:55 <merijn> nitrix: Also "doesFileExist" followed by "readFile" is a race condition
12:34:06 <fuzzyhorns> monochrom: what does Left & Right have to do with it?
12:34:09 <merijn> nitrix: What if someone deletes the file after you checked for existence, but before you read it?
12:34:26 <doismellburning> TTCTTOU vulns yay
12:34:29 <nitrix> merijn: It'd crash.
12:34:38 <nitrix> merijn: How would I solve this?
12:34:40 <merijn> nitrix: The correct way of checking for file existence is to just try and read it and catch the exception when that happens
12:34:47 <monochrom> Left & Right are also part of the definition of coproduct.
12:34:59 <merijn> nitrix: Or, if you're okay with crashing, don't bother catching the exception :p
12:35:12 <nitrix> merijn: Really... exceptions? I was hoping Haskell didn't have those
12:35:13 <fuzzyhorns> monochrom: i thought coproduct is like {1,2,3} {3,4,5} -> {(1,1)(1,2)(1,3),(2,3),(2,4),(2,5)}
12:35:40 <fuzzyhorns> monochrom: maybe i just dont understand what a coproduct is in this context, can you help me clarify?
12:35:45 <monochrom> that is not our coproduct. perhaps it's someone else's coproduct.
12:35:55 <merijn> nitrix: We have them, but they're not nearly used as much as in Java, in fact using them for anything other than IO errors is kind of a code smell
12:35:57 <Guest36679> mauke: What is the correct way to write it?
12:36:06 <fuzzyhorns> monochrom: set theory coproduct i think? maybe i am full of crap heh
12:36:07 <merijn> nitrix: But they remain one of the easiest ways to deal with IO issues
12:36:10 <nitrix> merijn: That's reassuring.
12:36:17 <fuzzyhorns> monochrom: so what is "our" coproduct?
12:36:47 <merijn> nitrix: They're useful for things like in servers, where an IO error deep in a client handling loop should just "rollback/kill" the entire connection
12:37:01 <merijn> nitrix: Threading error handling for that throughout all code gets really tiresome
12:37:09 <mauke> Guest36679: data IntOrStringList = SomeStrings [String] | SomeInts [Int]
12:37:41 <merijn> Or "Either [String] [Int]"
12:37:55 <mauke> @src Either
12:37:55 <lambdabot> Source not found. Where did you learn to type?
12:38:37 <yitz> nitrix: for sets, coproduct is disjoint union. "our" coproduct tends to work like that.
12:38:40 <nitrix> merijn: Is there a way to read a file into a Data.Text ?
12:39:07 <nitrix> merijn: Without the intermediate String?
12:39:22 <monochrom> the coproduct of objects A and B, I'm going to write A+B, comes with Left :: A -> A+B, Right :: B -> A+B, and satisfies: for all f :: A -> C, for all g :: B -> C, there exists unique h :: A+B -> C such that h.Left = f and h.Right = g.
12:39:53 <yitz> nitrix: if you are a mathematician who works with algebraic things where product and coproduct tend to coincide in the finite case, you have gotten bad intuition for "our" coproduct.
12:40:01 <monochrom> the sentence you quoted from the message is like 99% of the definition already. it just skips over the "unique" part.
12:40:18 <merijn> nitrix: There are file operations on ByteString in the ByteString modules you can then use the encode/decode operations from Data.Text.Encoding to convert between Text and ByteString
12:40:22 <nitrix> yitz: Are you talking to the wrong person?
12:40:49 <yitz> nitrix: you're right, sorry. i meant fuzzyhorns.
12:40:53 <Guest36679> @mauke If I have function that returns [String], can I use it's result as an input to a function that accepts IntOrStringList?
12:40:53 <lambdabot> Unknown command, try @list
12:40:59 <monochrom> coproduct for sets becomes disjoint union.
12:41:00 <merijn> nitrix: There's no sensible way to read from a file as Text, because you don't know what encoding the file is in, so you need to explicitly decode from ByteString to Text telling it which encoding to use
12:41:17 <merijn> :t BS.readFile
12:41:18 <lambdabot> FilePath -> IO BSC.ByteString
12:41:55 <monochrom> I do not know what {(1,1)(1,2)(1,3),(2,3),(2,4),(2,5)} is. it is not cartesian product because it misses (3,5) and other things.
12:41:57 <fuzzyhorns> monochrom: sorry am on crappy bus internet, so i disconnected
12:42:00 <yitz> fuzzyhorns: if you are a mathematician who works with algebraic things where product and coproduct tend to coincide in the finite case, you have gotten bad intuition for "our" coproduct.
12:42:05 <merijn> nitrix: Alternatively, if you're dealing with binary data and not text (because you're reading arbitrary files), you could also just not bother with Text at all and stick with ByteString
12:42:09 <fuzzyhorns> monochrom: do you mind answering what "our" coproduct is now?
12:42:13 <yitz> fuzzyhorns: for sets, coproduct is disjoint union. "our" coproduct tends to work like that.
12:42:19 <mauke> Guest36679: not directly. you have to wrap it in SomeStrings first
12:42:19 <nitrix> merijn: I don't understand why the encoding matters. What's stored in those files is going to be plain 8bit bytes anyway.
12:42:28 <monochrom> can you promise me that you won't get disconnected again?
12:42:37 <merijn> nitrix: Right, then don't even use Text and just use ByteString :)
12:42:39 <nitrix> merijn: It's merely encrypted blobs, it's not meant to be read in the end.
12:43:08 <nitrix> merijn: Okay well, when I used ByteString, it said it was deprecated in favor of Bytestring.Char8
12:43:30 <merijn> Wut
12:43:32 <merijn> That sounds highly doubtful
12:43:34 <fuzzyhorns> monochrom: i wish heh
12:43:38 <fuzzyhorns> a link would be fine too
12:43:38 <merijn> What, exactly, did you do? :)
12:43:41 <monochrom> the coproduct of objects A and B, I'm going to write A+B, comes with Left :: A -> A+B, Right :: B -> A+B, and satisfies: for all f :: A -> C, for all g :: B -> C, there exists unique h :: A+B -> C such that h.Left = f and h.Right = g.
12:43:46 <fuzzyhorns> and if you would rather not, dont put yourself out
12:43:47 <monochrom> the sentence you quoted from the message is like 99% of the definition already. it just skips over the "unique" part.
12:43:50 <nitrix> merijn: I'll clean the code first then we can speculate :)
12:43:53 <monochrom> coproduct for sets becomes disjoint union.
12:43:59 <monochrom> I do not know what {(1,1)(1,2)(1,3),(2,3),(2,4),(2,5)} is. it is not cartesian product because it misses (3,5) and other things.
12:44:18 <merijn> nitrix: Anyway "Data.ByteString.readFile" or it's lazy equivalent is what you want
12:44:34 <fuzzyhorns> monochrom: yeah it definitely isn't a cartesian product, i thought a coproduct was essentially a disjoint union labeled in tuples by its origin set
12:44:35 <Guest36679> mauke: At the end of the day, I want a function that would accept either [String] or [Int], without any extra conversions. Is this possible?
12:44:55 <fuzzyhorns> yitz: thanks :)
12:45:04 <merijn> nitrix: Oh, "Data.ByteString.putStrLn" is deprecated according to the docs
12:45:19 <fuzzyhorns> so what is the relationship of left & right to a disjoint union?
12:45:25 <fuzzyhorns> 'fraid I'm still not grokking that
12:45:45 <merijn> nitrix: Most likely you want "hPut" rather than putStrLn anyway
12:45:48 <monochrom> ok, then translate {(1,1)(1,2)(1,3),(2,3),(2,4),(2,5)} to {Left 1, Left 2, Left 3, Right 3, Right 4, Right 5}, generally define Left x = (1,x), Right y = (2,y).
12:46:05 <fuzzyhorns> monochrom: oooohhhh DUH
12:46:09 <monochrom> except that we don't need set tricks in Haskell.
12:46:10 <mauke> Guest36679: not really
12:46:18 <fuzzyhorns> monochrom: thank you :)
12:47:04 <monochrom> FWIW, we don't use "a function consists of a set of tuples" in Haskell, either
12:47:55 * monochrom hates set tricks. they're implementation details leaking out to ruin abstractions.
12:48:08 <augur> monochrom: b-b-but sets for foundations! D:
12:48:27 <monochrom> it should not matter whether Left x is implemented by (1,x) or (0,x).
12:48:41 <fuzzyhorns> monochrom: i mean, yes, indeed they are — but while learning the abstractions I still find I need to refer to example implementations to "see" it y'know?
12:48:55 <augur> monochrom: the closest analogy i can think of is Desc
12:48:55 <monochrom> and it should not matter whether (0,x) is implemented by {{0}, {0,x}} or {{x}, {x,0}}
12:48:58 <Guest36679> mauke: thanks
12:49:31 <fuzzyhorns> it doesnt really matter that it is a set, I just have some familiarity with them
12:49:36 <fuzzyhorns> so they're a starting point
12:49:50 <augur> monochrom: where  Either a b = Sg Bool (\x -> if x then a else b)
12:49:51 <freeman42> what is the name for those lines which start with # ? trying to find out how to check the operating system in one of them but not sure what to search for (https://github.com/rrnewton/haskell-lockfree/blob/bff872be7f571a188c5e1f7681629e2278037659/atomic-primops/Data/Atomics.hs#L244)
12:49:56 <monochrom> I'm just complaining about some mathematicians, not you, don't worry.
12:50:23 <codygman> Anyone ever experienced this error: libpq: failed (fe_sendauth: no password supplied) I'm using snap and have a devel.cfg.
12:50:36 <fuzzyhorns> :)
12:51:25 <augur> actually i guess you dont need Desc for that =x
12:52:22 <merijn> freeman42: C preprocessing directives
12:52:52 <merijn> freeman42: At the top you'll see the CPP pragma, telling you the source gets preprocessed by the C preprocessor
12:53:13 <freeman42> merijn, so they respect the C rules? they are not part of Haskell? oh, I see, having a look, thank you :)
12:54:19 <freeman42> merijn, the Language CPP is what tells it to use them? {-# LANGUAGE  MagicHash, UnboxedTuples, ScopedTypeVariables, BangPatterns, CPP #-}
12:56:12 <merijn> freeman42: Yes
12:56:40 <merijn> freeman42: Basically, they're macro's generated by cabal that let you detect which version of a library you're compiling with
12:57:14 <merijn> freeman42: The if branch that's not taken will effectively be deleted from the source before GHC sees it
13:00:45 <freeman42> merijn, that _starts with 'Windows 9' tool_ is quite useful :) https://searchcode.com/?q=_WIN64
13:03:01 <Kron> I'm planning on publishing a new version of a package I made ages ago to hackage. My last one never got indexed by hoogle
13:03:08 <Kron> how can I tell if it would be?
13:04:06 <J_Arcane2> freeman42: I found that search kind of shocking. I didn't put much stock in the rumor, still don't know that I do, but it was remarkable just how many such 'Windows 9' matches were out there, and big projects too. Bloody Java used it at one point.
13:06:14 <merijn> Kron: Hoogle only indexes a subset of hackage
13:06:25 <Kron> alright
13:06:44 <merijn> Whoo! I exploded GHC's brain again >.>
13:08:26 <nitrix> merijn: I'm almost there but line #20 gives me an error:   https://coderpad.io/6ZC2JT6P
13:09:43 <merijn> For some silly reason this works "case config cmdCfg of SomeConfig cfg -> run cfg", but "let (SomeConfig cfg) = config cmdCfg in run cfg" explodes GHC's brain
13:09:52 <merijn> SomeConfig being an existential constructor
13:10:49 <merijn> nitrix: Style note, the most common way to qualify lazy ByteString is as "LBS"
13:11:00 <merijn> nitrix: And the problem is that you want Data.Text.Encoding.Lazy :)
13:11:13 <merijn> That, or Data.ByteString instead of Lazy
13:11:21 <merijn> oh
13:11:22 <merijn> Wait
13:11:31 <merijn> Data.Text.Lazy, I mean
13:12:06 <merijn> nitrix: Couldn't match expected type ‘Data.Text.Internal.Lazy.Text’ with actual type ‘Text’
13:12:22 <nitrix> merijn: Stop stalking me D:
13:12:26 <Kron> how do I package my documentation into a cabal sdist? or does hackage do that automatically...
13:12:29 <merijn> nitrix: That has about a 90% chance of being lazy/strict mismatch, usually :)
13:12:35 <nitrix> Oh btw, any reference sheet for all those qualified names?
13:13:28 <merijn> nitrix: Not really, the common ones are "M" for Map, "S" for Set, "T" for Traversable or Text, "BS" for ByteString, "LBS" for lazy ByteString and "F" for Foldable
13:13:43 <Confusion> I'm reading http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html and there's something I don't understand: at some point it says "If we had simply implemented our code using one specific monoid, like lists, our code would be very limited in its application." But as far as I can see all examples do in fact use a specific monoid. What is the 'our code' that can be used with multiple monoids?
13:13:46 <merijn> Although, I guess with Traversable and Foldable moving into Prelude the need for those will disappear :D
13:13:58 <nitrix> Oh sweet.
13:14:11 <merijn> Confusion: Compare
13:14:14 <merijn> :t concat
13:14:15 <lambdabot> [[a]] -> [a]
13:14:20 <merijn> :t mconcat
13:14:21 <lambdabot> Monoid a => [a] -> a
13:15:03 <merijn> Confusion: concat can only concat lists of lists, mconcat can concat lists of arbitrary monoids
13:15:10 <merijn> Therefore, the latter is more general
13:15:35 <Confusion> merijn: if I need to change the type signature and the code to use a new monoid, why do I care that they are both monoids?
13:16:08 <nitrix> merijn: What the hell is my latest error. I swear I'm almost done ;-;
13:16:12 <merijn> Confusion: You don't need to change the signature *or* code of mconcat to work on a new monoid
13:16:31 <nitrix> merijn: Something about different kind of exception handling and mine being ambiguous
13:16:48 <merijn> nitrix: It tries to use the type of 'e' on line 11 to detect which exception you're trying to catch
13:16:56 <merijn> nitrix: But since you never use 'e', type inference fails
13:17:10 <merijn> nitrix: Quick ghetto solution: "Left (SomeException _) -> Nothing"
13:17:35 <merijn> nitrix: That will catch *everything*, you should probably read up on exceptions a bit and replace that to only catch relevant exceptions at some point
13:17:42 <merijn> nitrix: But good enough for now
13:18:35 <nitrix> Wooo! I think it's working :>
13:18:35 <Confusion> merijn: how do the examples in that blog post show that? E.g. comparing examples 'fact5' and 'fact6', what is the thing that should enlighten me about the uselfullness of having both (Dual String) and a tuple of Monoids being a Monoid?
13:19:56 <allyraza> hi everyone
13:20:34 <merijn> > ("foo", "bar") `mappend` mempty `mappend` ("whoo!", mempty)
13:20:36 <lambdabot>  ("foowhoo!","bar")
13:21:01 <pilz> Hi. Where does this print the name of each file and a total? http://lpaste.net/3981727097650413568
13:21:25 <merijn> > (("foo", "bar"), (Sum 1, Sum 2)) `mappend` mempty `mappend` ("whoo!", mempty) `mappend` (mempty, (Sum 3, Sum 4))
13:21:26 <lambdabot>  Couldn't match expected type ‘([GHC.Types.Char], [GHC.Types.Char])’
13:21:27 <lambdabot>              with actual type ‘[GHC.Types.Char]’
13:21:32 <merijn> eh, whoops
13:21:45 <merijn> > (("foo", "bar"), (Sum 1, Sum 2)) `mappend` mempty `mappend` (("whoo!", mempty), mempty) `mappend` (mempty, (Sum 3, Sum 4))
13:21:45 <mjrosenb> https://gist.github.com/02a37bd95cccbe4f60ef -- any idea if fixing this is just a matter of passing an extra flag to ghc?
13:21:46 <lambdabot>  (("foowhoo!","bar"),(Sum {getSum = 4},Sum {getSum = 6}))
13:22:23 <merijn> Confusion: Since a tuple of monoids is a monoid, I can arbitrarily nest those monoids to combine them
13:22:57 <mjrosenb> merijn: makes sense.
13:23:37 <nitrix> merijn: I merged your changes. Thanks for the help :)
13:23:47 <merijn> nitrix: I changed it a little to use hPut instead of hPutStrLn, which is more appropriate for writing out data
13:24:12 <merijn> nitrix: Additionally, you can replaced the stdout handle with a Handle to a different file/socket/whatever to write to those instead
13:25:37 <nitrix> I'm going to love Haskell. Everything just makes sense.
13:25:59 <monochrom> mjrosenb: my understand of the error message is: the class promises a functional dependency, the instance does not deliver. I don't think there is any extension for breaking a promise.
13:26:12 <Yxven1> nitrix: I want your brain
13:26:23 <Confusion> merijn: Yes, and I get how declaring that a function takes a monoid can allow users to use it in different ways, by passing in different monoids. What I don't get is how the blog post demonstrates that. Where is the code that declares it takes a monoid and that is used in different ways, by passing in different monoids?
13:26:24 <nitrix> Yxven1: Not on sale >:(
13:26:31 <mjrosenb> monochrom: well, presumably, this code compiled previously...
13:26:45 <merijn> Yxven1: It just takes practice :)
13:27:00 <Confusion> merijn: As far as I can tell, the code itself is constantly adjusted to pass the 'correct' form of information to the Writer
13:27:25 <merijn> Confusion: I'm not sure that the blog post does a very good job of showing it
13:27:50 <monochrom> well then, I only see an error message, I don't have any contextual information. on the other hand, if I'm given contextual information, then the thing may be so big that I may start charging money...
13:28:00 <nitrix> mjrosenb: As soon as you execute an IO action, your function immediatly becomes an IO itself?
13:28:42 <Cale> nitrix: Evaluation of expressions never causes execution of IO actions (with the exception of low level hooks that you shouldn't ordinarily use)
13:28:47 <nitrix> mjrosenb: So, the IO monad is contagious to its parents? That means main is almost always some kind of IO, no?
13:29:01 <Cale> nitrix: Other IO actions can cause IO actions to be executed though.
13:29:10 <monochrom> main is required to have an IO type, in fact.
13:29:19 <Cale> nitrix: Eventually, main is an IO action, and it will be executed.
13:29:21 <monochrom> for example "main = True" is illegal.
13:29:30 <nitrix> I see.
13:29:56 <mjrosenb> nitrix: yes, main is in fact not a function, it is *only* IO.
13:29:56 <monochrom> but I still say: http://www.vex.net/~trebla/haskell/IO.xhtml#organization
13:30:02 <nitrix> An executing this IO action cascades the side-effects, but it's also what allows the program to remain referentially transparent.
13:30:22 <nitrix> ._.
13:30:56 <merijn> A different way of thinking about is that "IO a" is an abstract type that represents a "side-effect producing program", Haskell is a pure language for constructing impure program. The runtime executes the resulting program
13:31:07 <Cale> nitrix: Well, it's not execution which is pure, but evaluation. By making all the effects happen as part of execution, we keep the behaviour of evaluation simple.
13:31:18 <mjrosenb> monochrom: I /think/ I understand what this code is trying to do.
13:31:20 <monochrom> just because the IO type is propagational, doesn't mean that you have no non-IO parts anywhere. even when you write in C++, you still have non-IO parts.
13:31:27 <Cale> (Evaluation being the process of turning expressions into values)
13:31:33 <nitrix> I see.
13:33:10 <merijn> Is the reason why let binding an existential blows GHC's brain related to let-generalisation type things or something?
13:33:11 <mjrosenb>     class Dissection record remainder lookupName lookupSort | record lookupName -> remainder where
13:33:32 <mjrosenb> so, that is saying that the combination of record and lookupName uniquely identify remainder?
13:33:40 <nitrix> A friend designing a pure language before told me the idea was to pretend the program was referentially transparent and that any IOs were essentially inputs and outputs of the main function, as if this whole time, the program side-effects were just cascading this from of information received/produced by main.
13:34:18 <mjrosenb> nitrix: that sounds like lazy-k
13:34:19 <nitrix> I think it's brilliant. It seems the same with Haskell, and the Monad just abstract passing a world around?
13:34:28 <nitrix> ._. ?
13:34:49 <monochrom> mjrosenb: have you first checked what the GHC user's guide says?
13:36:00 <criado> nitrix: that reminds me of: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/#io-trick-explained
13:36:11 <mjrosenb> monochrom: nope, trying to find the relevant parts now.
13:36:56 <monochrom> focus on the section "Existentially quantified data constructors", go down to the subsection "Restrictions"
13:38:40 <nitrix> >>> "So it is in Lazy K, where a program is simply treated as a function from the space of possible inputs to the space of possible outputs."
13:38:53 <nitrix> Yeah exactly what I meant. This Lazy-K language seems fun btw :)
13:38:57 <monochrom> every IRC client should pop up three browser windows for the GHC user's guide, my sicp.xhtml article, and my lazy.xhtml article, respectively, and have you click the buttons "I have read and agreed with this" before letting you type in anything.
13:39:51 <merijn> monochrom: :)
13:39:53 <mjrosenb> monochrom: *sigh*, I found the section, and there is a typo on the first line.
13:40:09 <monochrom> but then the IRC clients would be pretty useless for the good folks in #python...
13:40:20 <allyraza> this weird I am on that page right now just going thru it
13:40:26 <allyraza> haha ....
13:40:35 <allyraza> is*
13:41:38 <mjrosenb> monochrom: did you mean to direct merijn there?
13:41:45 <David> What's the best way to do a two-directional tree traversal in haskell?
13:42:27 <David> I want to go down a tree until some condition is met, then go up the tree until another condition is met, and then modify the node I am at
13:42:38 <David> should I be using a state monad?
13:42:42 <David> or is there a better approach?
13:43:05 <Haskellfant> David: are you able to modify the tree data structure?
13:43:07 <jacereda> anyone got haste-compiler to install on OSX recently?
13:43:12 <Haskellfant> if so, then you could go with a zipper
13:43:40 * hackagebot neat-interpolation 0.2.1 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.2.1 (NikitaVolkov)
13:44:17 <David> Haskellfant: I need to modify the structure
13:44:28 <David> the approach I am thinking of is a state monad with the current position in the tree as the state
13:44:36 <David> e.g. [root, child 3, child 2,...]
13:44:52 <merijn> mjrosenb: Doubtful, I like to think I'm beyond needing to read those pages :p
13:45:08 <daf> after a few years of writing haskell, reading GHC code and seeing an IO constructor being used feels very odd
13:45:34 <David> I run goDown (tacking stuff onto the position) until I see the position, and then from there I run goUp (popping stuff from the node) until I see the first node that satisfies my condition, and then I modify it
13:45:35 <mjrosenb> merijn: well it doesn't seem to be all that aplicable to the issue I'm trying to solve.
13:45:42 <David> not sure if there is a nicer method
13:46:00 <Haskellfant> David: lyah has a section on zippers http://learnyouahaskell.com/zippers
13:46:18 <Haskellfant> what you're describing sounds to me like a zipper would be a perfect fit
13:47:01 <David> yeah, essentially it seems that my current approach is a zipper inside a state monad
13:48:40 * hackagebot QuadTree 0.10.1 - QuadTree library for Haskell, with lens support.  http://hackage.haskell.org/package/QuadTree-0.10.1 (Kron)
13:49:16 <mjrosenb> merijn: well, you did ask about binding existentials, which is what that section is about
13:50:26 <monochrom> mjrosenb, the user's guide explains: disallowing let is because of implementational difficulty. if let is allowed, well clearly some restrictions have to be placed as well, but it's hard to state the restrictions, and hard to implement, all for little gain. so it's simpler to not support it altogether.
13:52:44 <monochrom> oh, I see, s/mjrosenb/merijn/, yeah
13:53:21 <monochrom> this is embarrasing. sorry everyone.
13:53:53 <monochrom> I'm going to cut off my hands and use telepathy for IRC
13:54:02 <bitemyapp> daf: because you're not used to IO or accustomed to monad transformers instead?
13:54:13 <bitemyapp> monochrom: your IO tutorial is nice btw
13:54:18 <monochrom> thanks
13:54:32 <bitemyapp> monochrom: between that and Snoyman's article, ties up the matter nicely.
13:55:18 <Confusion> What are good examples, from the Prelude or otherwise, of functions that take a Monoid and of which clear examples exist of them being used with various monoids, to achieve different (but of course related) results? I understand how it could make code reusable, but it would really help me to see some examples of their use 'in practice'. I find that LYAH, RWH and blog posts all explain how monoid works, but their examples do not seem to match my 
13:55:35 <daf> bitemyapp: because usually there is no IO constructor
13:56:14 <monochrom> Confusion, the Writer monad relies on Monoid being general.
13:56:34 <bitemyapp> daf: oh you mean data constructor.
13:56:34 <wz1000> Why are specialized monads based on IO not used more often to control side effects? I would like to see types which tell me what a function does/is allowed to do with greater detail that just telling me that the function can perform any arbitary IO
13:56:46 <bitemyapp> daf: yeah that would be spooky.
13:56:59 <bitemyapp> wz1000: monad transformers are more general.
13:57:21 <jacereda> anyone knows what does this warning mean? 'Orphan instance: instance [overlap ok] Unpack a'
13:57:25 <bitemyapp> wz1000: it's a cool tactic, but eclipsed by more general approaches.
13:57:40 <bitemyapp> jacereda: does Unpack belong to you?
13:57:41 <merijn> wz1000: Because that's an open research problem :)
13:57:44 <bitemyapp> jacereda: is it the same module?
13:57:51 <jacereda> bitemyapp: yes
13:57:54 <merijn> wz1000: Look up "composable effects" or the likes
13:58:08 <monochrom> wz1000: in some sense, ST and STM are special restrictions of IO
13:58:18 <mjrosenb> monochrom: if you figure out that technology, please let me know.
13:58:39 <BMeph> Confusion: See also "foldMap"
13:58:56 <wz1000> bitemyapp: I'm looking for more specialized monads. For example you can have a monad which only allows you to tap into sources of randomness, and not just perform arbitary IO, or a networking monad which allows you to communicate with sockets
13:59:20 <bitemyapp> wz1000: you need bos' stuff, h/o
13:59:43 <jacereda> bytemyapp: http://lpaste.net/1803228563093061632
13:59:44 <mjrosenb> Confusion: iirc, I had a logic solver, and when you instantiated it as a Maybe, you'd get the first result, when you instantiated it as a list, you got every result.
13:59:45 <merijn> monochrom: I know about the restrictions of existential quantification, my question was meant to be more theoretical
14:00:10 <merijn> monochrom: i.e. I know let binding an existential doesn't work, I was curious *why* it wouldn't
14:00:11 <roboguy_> wz1000: you could make a newtype for IO to do that
14:00:23 <bitemyapp> wz1000: http://www.scs.stanford.edu/14sp-cs240h/slides/ifc-slides.html#(1)
14:01:02 <wz1000> roboguy_: I know that, I was just wondering why it isnt used more often.
14:01:22 <monochrom> merijn, "The reason for this restriction is really an implementation one"
14:01:45 <jacereda> bitemyapp: that tries to wrap a JS handle so that I can dump its value in the browser, whatever it is
14:02:25 <merijn> monochrom: ok, then I fail at remembering that bit :)
14:02:26 <monochrom> it seems to me the restriction can be theoretically relaxed for much practical cost and little practical gain
14:03:35 <Confusion> monochrom, BMeph, mjrosenb: thanks for the suggestions, bbl
14:04:00 <wz1000> bitemyapp: Yes, RIO is an example of what I am looking for. I want types such that there are functions 'subio a -> IO a' but not 'IO a -> subio a'
14:10:17 <allyraza> any pointers for newbie?
14:10:45 <monochrom> what is the specific topic you need?
14:11:05 <allyraza> just starting off
14:11:21 <allyraza> i gave haskell a try before but failed
14:11:37 <merijn> @where lyah
14:11:37 <lambdabot> http://www.learnyouahaskell.com/
14:11:51 <monochrom> then https://github.com/bitemyapp/learnhaskell/ lists some material
14:11:53 <allyraza> I did the assignments at uni
14:12:09 <allyraza> but never really understood what was going on
14:12:30 <allyraza> thank you!
14:12:31 <monochrom> then it may be suitable to start again
14:12:57 * BMeph thinks that statement says things about allyraza's uni...not-so-good things.
14:13:36 <monochrom> I'd rather think the psychological difference between "they force me to learn" and "I want to learn" is significant
14:14:24 <allyraza> I failed to learn it at least twice willing to give it another shot
14:14:48 <allyraza> thank you monochrom
14:14:54 <criado> Is there a book for someone who already knows the basics? I want to learn about how a real-world program like xmonad or yi is written
14:15:38 <merijn> criado: There's several blog posts explaining the design of xmonad
14:15:45 <monochrom> on top of that, taking courses at school implies tight schedules, both by the haskell course itself and by those 6 other unrelated courses you have to take, it comes down to rat race not learning.
14:16:07 <merijn> criado: Also, last I checked the source of xmonad is pretty readable it was barely over 1k LOC
14:16:33 <criado> merijn: yes, but I have no idea of how to implement some algorithms in functional-style efficiently
14:16:42 <merijn> criado: Real World Haskell has a bunch of examples, some of the APIs changed abit, so they're no longer copy+pastable, but should still give you insight into how to do things
14:16:43 <mjrosenb> monochrom: aah, the liberal convergance condition was introduced in ghc-7.7, so it makes sense that this compiled previously.
14:16:52 <criado> for example, max flow seems to be impossible to implement efficiently
14:17:02 <pterygota> monochrom: links or titles to those articles you mentioned? sicp and lazy?
14:17:03 <merijn> criado: In that case, look up Okasaki, it's the bible of purely functional data structures
14:17:32 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml for the first one. I think you can guess the second one.
14:17:34 <criado> merijn: thanks for those books. I have already the okasaki, it is beutiful but not enough
14:17:52 <criado> also i found a book called "pearls of functional algorithms" or something like that.
14:18:03 <merijn> criado: That one's good too
14:18:05 <criado> but some algorithms are inherentely imperative, maybe
14:18:28 <rudi_s> Hi. I'm using a monad which embeds IO (Curses in my case) and using it with StateT. E.g. runCurses $ flip runStateT s $ do ... - Now I want to use a function in "..." which can perform IO and access the state, but can't access Curses (signature: StateT s IO ()). My current solution is IMHO ugly, is there a better way than: s <- get; s' <- liftIO $ execState f s; put s' - thanks.
14:18:29 <merijn> criado: That's what we have mutable vectors and stuff for :)
14:19:22 <pterygota> monochrom: thanky
14:19:31 <criado> merijn: I am just a newbie. I have never used those. But I will.
14:19:44 <criado> thanks!
14:20:28 <roconnor> rudi_s: what's Curses?
14:21:15 <merijn> roconnor: ncurses wrapper
14:21:33 <roconnor> I mean what is the Curses monad?
14:22:16 <mjrosenb> ooh, oleg answered this on SO!
14:22:31 <merijn> allyraza: For what it's worth, I had 1 course in ocaml that I completely didn't understand and 3 more failed attempts at learning haskell. Now I barely code in anything else, so don't sweat it :)
14:22:44 <rudi_s> roconnor: Thin wrapper around IO, I can call liftIO. That's basically all that's exposed. Its instances are Monad,Functor,MonadFix,Applicative and MonadIO.
14:23:13 <allyraza> merijn: thank you!
14:23:44 <roconnor> rudi_s: surely it is more than that?
14:24:01 <hask3> Is a singleton tuple, (2) or ("asdf"), always 100% equivalent to its value, 2 or "asdf" ?
14:24:01 <HeladoDeBrownie> A newtype wrapper over IO that has a MonadIO instance seems pointless
14:24:13 <freeman42> is it normal to get "Use --force-reinstalls if you want to install anyway." even in a sandbox which was just created? shouldn't everything be installed for the first time?
14:24:18 <rudi_s> roconnor: No. It's just newtype Curses a = Curses { unCurses :: IO a }
14:24:27 <roconnor> rudi_s: link?
14:24:28 <monochrom> rudi_s: if you authored that function, author its type to be the general "(MonadState s m, MonadIO m) => m ()"
14:24:41 <rudi_s> I didn't. It's the UI.NCurses module.
14:25:17 <rudi_s> https://john-millikin.com/software/haskell-ncurses/reference/haskell-ncurses/latest/
14:25:41 <roconnor> oh I see
14:25:47 <roconnor> runCurses require a bracket
14:25:56 <roconnor> fair enough.
14:26:30 <HeladoDeBrownie> Ah, so they allow only one interpreter and it does special things. That works.
14:26:34 <rudi_s> The question is, is there's a better way to run a function using the state and IO from within the Curses state than the one I wrote above.
14:26:46 <rudi_s> Because I find that a bit ugly.
14:27:00 <monochrom> do you like my answer?
14:27:21 <hask3> Is a singleton tuple, (2) or ("asdf"), always 100% equivalent to its value, 2 or "asdf" ?
14:27:25 <rudi_s> monochrom: What function should I change?
14:27:36 <merijn> hask3: There are no singleton tuples in haskell
14:27:40 <monochrom> the one that was StateT s IO ().
14:27:50 <merijn> hask3: That's just an expression  surrounded in parenthesis
14:27:52 <hask3> merijn: ah, so it's just treated like a parantheses around that regular value?
14:27:54 <hask3> ah cool
14:27:56 <hask3> nice thanks!!
14:28:23 <roconnor> rudi_s: I feel there shoudl be a way of doing this ... looking
14:29:25 <merijn> rudi_s, roconnor: The main reason I started using vty in the past is that I found the design of almost all ncurses wrapper libraries to be horribly unusable
14:30:05 <rudi_s> monochrom: I'm a little confused. How would I call it from the Curses state?
14:30:19 <monochrom> what is the name of the callee?
14:30:58 <monochrom> may I assume that its name is "it"?
14:31:20 <rudi_s> monochrom: Signature of the caller: StateT a Curses (), desired signature of the calle: StateT a IO ().
14:31:22 <roconnor> rudi_s: So I would just abstract your get; runState; put into a generic function of type StateT s IO a -> StateT s Curses a.
14:31:44 <merijn> Wait
14:31:53 <merijn> I think mmorph can fix this mess
14:31:57 <monochrom> no, desired signature of the callee: (MonadState s m, MonadIO m) => m ().
14:32:12 <monochrom> then inside caller's code, you just say: "callee". that's it.
14:32:13 <merijn> "mmorph liftIO" should work, no?
14:32:20 <roconnor> rudi_s: I was looking for an even more generic (MonadTrans t) (Monad m, Monad n) => (m a -> n a) -> (t m a -> t n a) function, but I cannot find one.
14:32:29 <roconnor> where is mmorph?
14:32:29 <phaskell> No symbol 'mmorph' found anywhere.
14:32:32 <roconnor> I was looking for it.
14:32:39 <rudi_s> merijn: Yeah, I can see that. But it works fine for me and I'm afraid that vty misses features that curses provides and I want.
14:32:42 <merijn> roconnor: The mmorph package by Tekmo
14:32:44 <HeladoDeBrownie> @hackage mmorph
14:32:44 <lambdabot> http://hackage.haskell.org/package/mmorph
14:33:27 <merijn> oh, eh, hoist, I mean
14:33:32 <merijn> "hoist liftIO"
14:33:36 <roconnor> right
14:33:54 <roconnor> I'm surprised edward hasn't incorporated this into the mtl. :)
14:34:06 <merijn> That means you can still use the normal put/get/etc. without hacking together your own versions
14:34:33 <roconnor> rudi_s: so there  you go; just add another package and use Control.Monad.Morph.hoist liftIO.
14:34:37 <rudi_s> monochrom: Hm. That doesn't typecheck for me (Could not deduce (m ~ StateT a C.Curses) from the context (MonadState s m, MonadIO m)).
14:34:39 <roconnor> easy ;)
14:35:10 <monochrom> what is the "a" there?
14:35:28 <rudi_s> monochrom: My state, it's just data State = State { ... }
14:35:38 <monochrom> I see.
14:35:52 <monochrom> replace "s" by "a"
14:36:06 <monochrom> and replace "a" by whatever you're really using
14:36:18 <merijn> hoist won't play nice with "MonadState s m" anyway, I think
14:36:28 <monochrom> this is the problem with pseudocode and pseudonyms
14:37:10 <merijn> roconnor: Anyway, I agree, mmorph in transformers would be nice :)
14:37:16 * merijn is off to get fresh air now
14:38:07 <roconnor> rudi_s: so my recommendation is to either write your own, one off, (StateT s IO a -> StateT s Curses a) function, or to try to get hoist to work from the mmorph package.
14:38:30 <monochrom> merijn: my approach hedges on polymorphism so the callee blends in with the caller, and parametricity so the callee cannot possibly touch Cursesly things. it does not hedge on any kind of conversion.
14:39:00 <rudi_s> monochrom: Hm, not working. This is a little beyond my current Haskell knowledge. I think I'll stick with either my approach or hoist for now, at least I understand that. But thanks for your help.
14:39:11 <roconnor> merijn: I heard you like monads so I put a monad in your monad transformer so you can monad while you monad.
14:39:25 <rudi_s> roconnor: Yeah, will write this function. Thanks.
14:41:08 <vanila> There is some approach to extensible effects that does not use monad transformers
14:41:35 <rudi_s> monochrom: My "wrapper" function has the signature you described ((MonadIO m, MonadState sm) => StateT s IO a -> m ()), but still uses get/put. Is that what you were trying to explain to me?
14:42:49 <monochrom> no. I am eliminating all conversion, wrapping, lifting, hoisting, embedding, and morphing, altogether.
14:43:14 <rudi_s> monochrom: How?
14:43:52 <monochrom> I use polymorphism
14:44:10 <rudi_s> What I have is StateT Config C.Curses a ; and I want to call an IO action which accesses Config from inside that function. Could you give me an example?
14:45:25 <monochrom> your callee is like this: do { c <- get; liftIO (print c) }
14:45:45 <monochrom> the most general type of that code is not StateT Config IO (). far from it.
14:46:07 <monochrom> the most general type is (MonadState Config m, MonadIO m) => m ()
14:46:25 <monochrom> with that type, in caller, you can simply say "callee". that's it.
14:47:19 <Sonderblade> what is the reason standard map and filter doesn't work for sets?
14:47:24 <monochrom> this is because m could be instantiated to StateT Config Curses. check that StateT Config Curses is an instance of MonadState as well as MonadIO.
14:47:26 <rudi_s> monochrom: The only problem is that runCurses has the signature: Curses a -> IO a
14:47:40 <rudi_s> I guess then I can't use your solution?
14:48:00 <monochrom> your caller is StateT Config C.Curses a, right?
14:48:06 <HeladoDeBrownie> Sonderblade, because they're defined over lists, and sets are not lists
14:48:55 <Saizan> rudi_s: you should still be able to
14:49:15 <Sonderblade> HeladoDeBrownie: so why aren't they defined over collections?
14:49:29 <Saizan> Sonderblade: historical reasons
14:49:35 <monochrom> your caller is StateT Config C.Curses a. therefore it does not mention runCurses. therefore there is no reason to think of runCurses.
14:49:46 <Saizan> Sonderblade: seen Data.Foldable and Data.Traversable?
14:49:55 <HeladoDeBrownie> Sonderblade, it's also somewhat non-obvious what a "collection" is
14:49:59 <rudi_s> monochrom: Sorry, maybe I got it wrong.
14:50:30 <jontmorehouse> hey everyone ... seems like I'm missing something
14:50:40 <rudi_s> My minimal example looks like test f = runCurses $ runStateT f defaultConfig
14:50:42 <jontmorehouse> I'm trying to use redis for a quick little script I'm playing with
14:50:47 <jontmorehouse> I run cabal install hedis
14:50:50 <rudi_s> (Where defaultConfig is Config { .. })
14:50:52 <jontmorehouse> but can't access it in my script?
14:51:05 <rudi_s> Now from inside f I want to call the mentioned IO-only function.
14:51:06 <Sonderblade> HeladoDeBrownie: why?
14:51:20 <HeladoDeBrownie> Sonderblade, well, what do all collections have in common?
14:52:21 <Saizan> rudi_s: yeah, that's ok, just use liftIO around then, as long as C.Curses is a MonadIO that will work fine
14:52:44 <Saizan> (is it')
14:52:46 <Saizan> ?
14:53:04 <rudi_s> Saizan: It has an instace MonadIO, yes.
14:53:05 <Sonderblade> HeladoDeBrownie: they are containers
14:53:12 <Saizan> *around the IO action
14:53:15 <HeladoDeBrownie> Sonderblade, that's tautological at best. :P
14:54:02 <Saizan> Sonderblade: the API can be a problem, but we have some typeclasses that support some of the operations
14:54:23 <monochrom> I give up.
14:54:37 <imalsogreg> I'm looking for a way to take a haskell-src-exts annotated syntax tree and turn it into xml. 'exact print' it in a browser. Does anyone know a library that does this (or an approach I could look at for trying to write it myself)?
14:55:03 <Saizan> rudi_s: if you still have problems you might want to give us some specific code on lpaste.net so we can work on something concrete
14:56:09 <Sonderblade> Saizan: is there set implementations that implement those typeclasses?
14:57:13 <rudi_s> monochrom: Was that directed to me?
15:03:07 <roboguy_> Sonderblade: the problem with map and Set is that you can't make a Functor instance for Set. There is a package that has a new (restricted) Functor class that would work, but the built in one wouldn't be possible
15:03:59 <HeladoDeBrownie> Functor doesn't answer the original question, you can't do filter with that
15:04:03 <fread2282> is unsafePerformIO (return ()) a no-op?
15:04:13 <roboguy_> HeladoDeBrownie: that was half of the original question I think
15:04:24 <HeladoDeBrownie> Oh yeah you're right
15:04:39 <HeladoDeBrownie> Both are folds though
15:05:12 <rudi_s> Saizan, monochrom: http://paste.debian.net/124521/ <- that's a minimal example. It compiles, but I'm not able to restrict the type of test2 to IO only. Either I'm misunderstanding monochrom's suggestion (very possible, still new to haskell) or something else is wrong. Thanks.
15:07:41 <roboguy_> HeladoDeBrownie: I'm not sure you can implement filter just as a fold without knowing how to build the structure up, so unfortunately Foldable wouldn't be enough either
15:11:56 <Saizan> rudi_s: what type would you want to give to test2? and why?
15:12:34 <rudi_s> Saizan: I want it to perform only IO actions, not Curses actions.
15:14:30 <Saizan> rudi_s: with the type you've commented out it can only do IO actions and access the state, it cannot do anything specific to Curses
15:15:07 <rudi_s> Saizan: Yeah, but it doesn't compile with the signature.
15:15:59 <Saizan> rudi_s: what error do you get?
15:16:13 <rudi_s> "Non type-variable argument in the constraint: monadState config m (Use -XFlexibleContexts ..." and when I use the option it tells me "No instance for (MonadState Config Curses)"
15:16:32 <rudi_s> *MonadSate Config m
15:17:05 <Saizan> oh, sorry
15:17:26 <Saizan> test2 :: (MonadIO m, MonadState Config m) => m () -- that's the signature you want
15:17:40 <Saizan> but yeah, turn FlexibleContexts on
15:19:48 <Sonderblade> roboguy_: is it a deficiency in haskell or a problem with sets? i see no logical reason why map couldn't be well-defined over a set
15:20:06 <HeladoDeBrownie> Sonderblade, for some meaning of map, sure
15:20:07 <rudi_s> Saizan: Thank you, that works fine. - Now I'm not sure if I should use my original approach which is IMHO more readable (just IO ()) or this more flexible approach. But thank you for your help.
15:20:41 <roboguy_> Sonderblade: it is well defined (in fact, Data.Set provides a map), it is just that you can't make a Functor instance. So I guess that could be considered a deficiency of Haskell. It doesn't have to be that way though, as I said there's a package that reimplements Functor that can have a Set instance
15:20:45 <HeladoDeBrownie> Sonderblade, Data.Set even has a map, the trick is finding a good generalization
15:21:11 <Saizan> lens!
15:22:30 <fresheyeball> hello
15:22:36 <silver> hi
15:22:43 <fresheyeball> I have a question
15:22:55 <fresheyeball> is there a way to unify monads in a do block?
15:23:30 <HeladoDeBrownie> fresheyeball, do you know how do expressions desugar?
15:23:58 <fresheyeball> yes
15:24:00 <silver> http://en.wikibooks.org/wiki/Haskell/Monad_transformers
15:24:13 <fresheyeball> its just >>= \_ ->
15:24:15 <HeladoDeBrownie> fresheyeball, so you know about (>>=) then? Look at its type
15:24:17 <HeladoDeBrownie> @type (>>=)
15:24:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:24:24 <fresheyeball> right
15:24:28 <HeladoDeBrownie> m is fixed
15:24:33 <fresheyeball> yes
15:24:38 <HeladoDeBrownie> Does that answer your question?
15:24:49 <fresheyeball> so you are saying 'no there is not way'
15:25:04 <HeladoDeBrownie> Well, it depends on what exactly you mean by "unify monads".
15:25:20 <HeladoDeBrownie> You can, for example, use monad transformers to attain extra capabilities beyond a base monad.
15:25:27 <fresheyeball> let Foo = Just 3
15:25:37 <simpson> fresheyeball: Are you asking about mixing and matching monads?
15:25:41 <fresheyeball> yes
15:25:49 <vanila> There is some approach to extensible effects that does not use monad transformers
15:25:54 <simpson> No, you can't. What, specifically, are you working on?
15:25:56 <fresheyeball> like having a maybe and IO in the same do notation
15:26:12 <HeladoDeBrownie> fresheyeball, MaybeT IO is a possibility, but not directly what you said
15:26:15 <monochrom> @free length :: [a] -> Int
15:26:15 <lambdabot> length = length . $map f
15:26:33 <fresheyeball> ok
15:26:56 <fresheyeball> so for example
15:27:07 <fresheyeball> let Foo = Just 3
15:27:21 <fresheyeball> foo >>= show >>> putStrLn
15:27:21 <HeladoDeBrownie> That looks like an error to me.
15:27:34 <doismellburning> :t (>>>)
15:27:35 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
15:27:46 <HeladoDeBrownie> What are you trying to do there? Why (>>>)? Did you mean (>>)?
15:27:59 <fresheyeball> (Just 3) >>= (putStrLn . show)
15:28:20 <simpson> :t print -- fresheyeball: This might be useful in the future...
15:28:22 <lambdabot> Show a => a -> IO ()
15:28:26 <_tca> you're no longer writing in your real PL, you're writing in an interpreted language, is the real issue as I see it
15:28:36 <HeladoDeBrownie> Okay, first question still applies. What are you trying to do?
15:29:10 <fresheyeball> I am trying to unwrap a maybe, and print the result
15:29:22 <HeladoDeBrownie> Okay. So why not case match on it?
15:29:30 <fresheyeball> I could
15:29:34 <fresheyeball> my question is one of syntax
15:29:39 <monochrom> either Set cannot be a functor or set size :: Set a -> Int cannot be parametric polymorphic. because if Set is a functor and set size is parametric polymorphic, then size s = size (fmap f s) for all f, for all s. but look at size {1,2} vs size (fmap (const 0) {1,2})
15:29:45 <jontmorehouse> anyone else on mac having trouble running `cabal install hedis`
15:30:15 <HeladoDeBrownie> Then the answer is that no, do syntax doesn't permit that, and you'd probably want either a case expression or the maybe function or the like.
15:30:21 <HeladoDeBrownie> @type maybe
15:30:22 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:30:32 <BMeph> :t flip maybe show
15:30:33 <monochrom> it is possible, of course, to take the stance that size should not be provided altogether.
15:30:33 <lambdabot> Show a => String -> Maybe a -> String
15:31:22 <monochrom> afterall, Set has this funny property of {0,0,0} = {0,0} = {0} so the notion of size is really special.
15:31:23 <HeladoDeBrownie> If, on the other hand, you wanted to short circuit the IO on failure, that would be a case for MaybeT IO.
15:31:39 <HeladoDeBrownie> But can also be implemented more mundanely.
15:32:00 <fresheyeball> hmm
15:32:05 <fresheyeball> I am not getting it
15:32:16 <HeladoDeBrownie> I suggest sticking with pattern matching using a case expression for now.
15:32:43 <HeladoDeBrownie> You can read up on that other stuff, practice it, and maybe use it once you get it.
15:33:11 <HeladoDeBrownie> Keeping in mind that sometimes things like MaybeT are overkill, and may well be in this case as well. :P
15:35:23 <fresheyeball> let me try another question
15:35:42 <roboguy_> fresheyeball: I think the issue is that you want to work with the Maybe monad, but print is in the IO monad
15:35:51 <fresheyeball> right
15:36:03 <HeladoDeBrownie> Except you aren't trying to *compose* Maybes, so there's no need to use the Maybe Monad
15:36:34 <fresheyeball> (IO 3) >>= Just >>= return
15:36:39 <fresheyeball> should just be IO 3 right?
15:36:45 <HeladoDeBrownie> What is this IO 3?
15:37:00 <roboguy_> fresheyeball: do you mean (return 3 :: IO Int) >>= Just >>= return?
15:37:09 <fresheyeball> sure
15:37:22 <fresheyeball> thats the idea
15:37:24 <roboguy_> that doesn't work because >>= only works on one Monad at a time
15:37:25 <monochrom> I think it's a type error.
15:37:27 <roboguy_> :t (>>=)
15:37:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:37:34 <roboguy_> it uses the same m for everything
15:37:34 <fresheyeball> right right
15:37:35 <fresheyeball> ok
15:39:19 <fresheyeball> ok so
15:39:34 <fresheyeball> crap
15:39:39 <fresheyeball> there might just not be another way
15:41:01 <imalsogreg> fresheyeball: Just to (possibly) clarify - m has to be the same across >>=, but you can pick an m that handles both Maybe and IO
15:41:15 <fresheyeball> right
15:41:26 <HeladoDeBrownie> We covered that, although that might be a good way to rephrase
15:41:30 <fresheyeball> it looks like writing a monad transformer might by the right choice
15:41:39 <HeladoDeBrownie> fresheyeball, I doubt it, given the example you gave
15:41:54 <fresheyeball> thats fair
15:42:11 <HeladoDeBrownie> You basically want to branch what the IO does based on whether something is a Nothing or a Just, right?
15:42:49 <roboguy_> :t T.sequence $ fmap print (Just 3)
15:42:50 <lambdabot> IO (Maybe ())
15:43:06 <roboguy_> ^ fresheyeball: how about something like that?
15:43:31 <roboguy_> that still seems like overkill for this though
15:44:41 <fresheyeball> Ok just to be honest
15:44:59 <imalsogreg> fresheyeball: If you just want to branch on one Maybe, as roboguy_ it's overkill. But if you have a long block with possibly-failing IO happening and you don't want to have to unwrap the Just's by hand, then MaybeT IO is nice.
15:45:01 <fresheyeball> I am trying to write something that will let me abstract callbacks in purescript
15:45:03 <fresheyeball> not haskell
15:45:10 <fresheyeball> and I needed to understand monads better
15:45:21 <fresheyeball> you guys helped out tramendously
15:45:37 <fresheyeball> I think I get it now
15:46:33 <HeladoDeBrownie> Well, good
15:46:55 <imalsogreg> fresheyeball: gl :)
15:46:58 <HeladoDeBrownie> Although you might have an easier time applying your knowledge if you ask some Purescripters :)
15:47:32 <HeladoDeBrownie> Oh I see, it does seem quite Haskell-like
15:47:42 <HeladoDeBrownie> With some important differences though
15:47:46 <fresheyeball> yeah, and the IRC for purescript is dead right now
15:47:54 <fresheyeball> but haskell is almost always alive
15:48:00 <HeladoDeBrownie> We're a lively bunch
15:48:12 <HeladoDeBrownie> Anyway I've gotta go, have fun
15:48:23 <fresheyeball> thank you
15:48:43 <imalsogreg> fresheyeball: Yah, I think this is probably a good place to get your monad questions answered :)
15:49:44 <imalsogreg> fresheyeball: Curious to hear how your purescripting goes, if you ever feel like reporting back.
15:50:08 <fresheyeball> its been going well so far
15:55:44 <fread2282> how can I supply a type signature in a typeclass instance for ScopedTypeVariables?
15:58:36 <_tca> fresheyeball: https://leanpub.com/purescript/read#leanpub-auto-the-eff-monad
15:59:02 <fresheyeball> @tca I've read the book already
15:59:02 <lambdabot> Maybe you meant: thx rc
15:59:27 <vanila> yea like iw as saying eralier
15:59:33 <vanila> "There is some approach to extensible effects that does not use monad transformers""
16:00:07 <_tca> fresheyeball: well everything you went over with 'unifying' monads is irrelevant and taken care of when you have Eff like purescript does
16:01:02 <fresheyeball> hmm
16:01:55 <fresheyeball> Eff doesn't fundamentally change the nature of Monads
16:03:56 <roboguy_> fread2282: if I'm understanding, something like this? http://lpaste.net/112103
16:04:34 <_tca> fresheyeball: it really does fundamentally change how you compose them
16:04:43 <_tca> and you will have none of this issue with types and monad tranformers
16:10:13 <thetallguy> How do I use a value that begins with an underscore when type hole warnings are turned on?
16:10:56 * geekosaur admits to having wondered if that particular overloaded syntax was going to bite someone...
16:11:11 <roboguy_> thetallguy: hmm just using it normally seems to work for me, if the name is in scope
16:11:51 <thetallguy> roboguy_: Hunh.  I imported Control.Lens.Prism and asked ghci :type _left
16:12:19 <roboguy_> thetallguy: that's strange that works fine for me. which version of ghc are you using?
16:12:20 <thetallguy> roboguy_: And it complained about a type hole.
16:12:20 <geekosaur> ... I think I am terrified of the idea of type holes around Lens :p
16:12:48 <thetallguy> roboguy_: 7.8.3
16:13:01 <roboguy_> huh, me too
16:13:14 <thetallguy> geekosaur: It's not turning out well so far
16:13:26 <roboguy_> thetallguy: oh, lowercase l
16:13:29 <roboguy_> it should be _Left
16:13:59 <thetallguy> _left :: Prism (Either a c) (Either b c) a b
16:14:09 <roboguy_> :t _Left
16:14:10 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Either a c) (f (Either b c))
16:14:28 <thetallguy> Ah
16:14:47 <thetallguy> Okay, so that has changed and now I know why...
16:15:03 <thetallguy> I hate that google takes me to old docs
16:15:12 <roboguy_> that's probably the same type
16:15:14 <thetallguy> roboguy_: Thanks
16:15:16 <roboguy_> :t _Left :: Prism (Either a c) (Either b c) a b
16:15:18 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Either a c) (f (Either b c))
16:15:20 <roboguy_> yep
16:15:41 <roboguy_> same type, because of the type synonyms
16:22:10 <beckyconning> how do you shorten type signatures that are too long but only have one ->?
16:23:07 <dibblego> beckyconning: example?
16:23:47 * hackagebot criterion 1.0.2.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.2.0 (BryanOSullivan)
16:24:27 <beckyconning> dibblego: i just realised the answer : ) sorry i'm new! the answer is to use => to remove repeated types.
16:24:55 <roboguy_> beckyconning: hmm, what were you working with? that doesn't sound right to me
16:26:24 <beckyconning> roboguy_, dibblego: the example is actually in elm so i was trying to be generic lol
16:26:48 <beckyconning> getGetSubsequentChangeNotifications : (Num -> Signal (Http.Response ChangeNotification)) -> (ChangeNotification -> Signal (Http.Response ChangeNotification))
16:27:40 <jontmorehouse> having trouble getting up and running with redis + haskell
16:27:57 <jontmorehouse> https://gist.github.com/c5430bce10f4e64c22e4
16:27:59 <roboguy_> beckyconning: I'd probably use a type synonym
16:28:01 <jontmorehouse> for some reason, I can't compile
16:28:12 <jontmorehouse> can someone help me with the test method, I'm implementing in that gist?
16:28:13 <beckyconning> roboguy_: thanks i'll look that up : )
16:29:07 <beckyconning> roboguy_: oh those things! that makes sense : )
16:33:25 <meoblast001> hi.. if i get 4 Word8's from a ByteString, how can i produce a Word32 from this?
16:33:27 <meoblast001> or an Int
16:33:47 * hackagebot persistent-zookeeper 0.0.3 - Backend for persistent library using Zookeeper.  http://hackage.haskell.org/package/persistent-zookeeper-0.0.3 (junjihashimoto)
16:36:44 <fly-away> hey guys! Im just introduced to haskell and got a question: is writing haskell code faster than languages like python? My typical area is web crawlers and a bit data transforming
16:38:29 <luite> fly-away: it'll take a few months to become productive at least. but i find the type system very helpful in guiding program design and making changes to programs, in particular when they get more complex
16:42:01 <rudi_s> Hi. I'm working on a small library which also generates a binary and I'm using it with cabal. It looks like I have to specify the dependencies for the library also in the executable section of my cabal file. Is this expected?
16:44:39 <imalsogreg> rudi_s: You can avoid that by keeping your library code in one hs-source-dir, and your executable code in a different hs-source-dir.
16:44:51 <jle`> meoblast001: i think you have to just use Data.Bits stuff
16:45:47 <rudi_s> imalsogreg: That sounds like a weird fix. Is there a specific reason? I thought specifying "other-modules" would be enough.
16:46:43 <imalsogreg> rudi_s: I bet there is a sensible reason - I don't know what it is though.
16:47:25 <rudi_s> imalsogreg: Thanks. If nobody knows a better solution, I'll use this workaround.
16:52:27 <meoblast001> jle`: thanks. i'll look into that
16:56:00 <mjrosenb> what is ~?
16:56:26 <roboguy_> mjrosenb: type equality constraint
16:57:20 <roboguy_> :t 'x' :: (a ~ Char) => a
16:57:21 <lambdabot> Char
16:58:24 <kvanb> :t 'x' :: (a ~ Num) => a
16:58:25 <lambdabot>     Expecting one more argument to ‘a’
16:58:25 <lambdabot>     Expected a type, but ‘a’ has kind ‘* -> Constraint’
16:58:25 <lambdabot>     In an expression type signature: a ~ Num => a
16:58:52 <kvanb> How can something be equal but not equal if you get what I mean
16:59:31 <BMeph> kvanb: 'Num' is a typeCLASS, not a type.
16:59:33 <kvanb> whats the point of (a ~ Char) => a
16:59:36 <kvanb> instead of just Char
16:59:44 <kvanb> I know, I was just checking
17:00:01 <BMeph> :t "x" :: (a ~ Char) => [a]
17:00:03 <lambdabot> [Char]
17:05:36 <roboguy_> kvanb: one example would be if you want to ensure that a type family gives a certain result
17:06:37 <kvanb> thanks
17:08:37 <roboguy_> :t undefined :: (CmpNat n 5 ~ LT) => Proxy n  -- There are better ways to write this, but something like this could be an example
17:08:38 <lambdabot>     Not in scope: type constructor or class ‘CmpNat’
17:08:46 <roboguy_> aw
17:09:14 <roboguy_> :t undefined :: ((n <=? 5) ~ True) => Proxy n
17:09:15 <lambdabot> Not in scope: type constructor or class ‘<=?’
17:09:19 <roboguy_> oh well
17:10:47 <mjrosenb> c.c
17:11:01 <mjrosenb> I just commented out the lines ghc complained about
17:11:05 <mjrosenb> and it built
17:11:12 * mjrosenb is worried
17:24:37 <merijn> Is anyone using the detailed testing interface of cabal or is exitcode-stdio basically the only sane way to go for tests?
17:24:46 <OliverJAsh> how can i find occurrences consecutive number in an array, e.g. [0, 1, 1, 0, 0, 1, 0] => [0, [1, 1], 0, 0, [1], 0]? not too familiar with haskell but interested in the logic.
17:25:50 <kvanb> merijn: I use only exitcode-stdio
17:26:02 <kvanb> fwiw, which is basically nothing
17:26:16 <roboguy_> > group [0, 1, 1, 0, 0, 1, 0]
17:26:19 <lambdabot>  [[0],[1,1],[0,0],[1],[0]]
17:26:22 <roboguy_> ^ OliverJAsh
17:27:01 <merijn> kvanb: exitcode-stdio feels rather silly in my case, since my tests already consist of spawning a bunch of subprocesses (i.e. I can run tests in a single processes)
17:29:20 <OliverJAsh> roboguy_: thanks. any idea how that function is written? i imagine it could be expressed as a reduce
17:29:23 <OliverJAsh> roboguy_: thanks. any idea how that function is written? i imagine it could be expressed as a reduce/fold
17:30:14 <merijn> OliverJAsh: It probably could be a fold, but it's probably easier to implement a straightforward helper using direct recursion
17:31:10 <roboguy_> OliverJAsh: looks like it uses span and direct recursion
17:31:23 <merijn> Actually, any recursion can be a fold, universality and all, but that doesn't mean it's a good idea :)
17:31:55 <roboguy_> > span (== 3) [3,3,3,1,2,3,4,5]
17:31:56 <lambdabot>  ([3,3,3],[1,2,3,4,5])
17:33:48 <merijn> roboguy_: You could probably do better by writing a helper that accumulated using a DList
17:34:20 <roboguy_> merijn: hmm why a DList?
17:34:28 <merijn> hmm, well I guess it depends
17:34:51 <merijn> span is lazy in a different way, so it might be better depending on how you consume the list
17:35:16 <merijn> roboguy_: Avoids unnecessary allocation and casing on the tuple like span
17:36:12 <merijn> roboguy_: But, span immediately returns a WHNF, so it's lazier
17:42:04 <merijn> There's no way to pass custom parameters to "cabal configure"? i.e. if I need to set additional flags for configuring the C bits?
17:52:21 <slack1256> merijn: what about "cabal configure --gcc-options=-Wall"
17:54:46 <merijn> slack1256: Not good enough, I have 4 C dependencies that need different flags per dependency
18:02:57 <Arahael> merijn: You couldn't delegate that configuraito to something like pkgconfig?
18:03:44 <Arahael> merijn: I'm not up-to-speed with haskell compilation, but shouldn't you try to push gcc configuration to the library that needs it? (So, to configure library X, call a routine that knows it)
18:03:48 <merijn> Arahael: I don't have pkg-config on my system and I don't see why I should assume any users do
18:03:51 <Arahael> merijn: Rather than calling gcc directly.
18:04:56 <merijn> Arahael: I don't have a library, I have tests (executables) that need to link to different libraries
18:05:11 <merijn> So I need a way to specify said libraries install path
18:05:12 <Arahael> merijn: And you also need to compile these libraries/
18:05:36 <Arahael> merijn: The install path is very OS dependant. OS X, Linux, and windows have very different ways of doing this.
18:05:40 <merijn> Arahael: No, installing non-haskell libraries is not cabal's problem
18:05:53 <merijn> Arahael: Right, hence why I need to manually specify install paths
18:06:15 <Arahael> Ah, so I misunderstood - you need to merely use an existing compiled and installed library path.
18:06:18 <merijn> Which brings me back to my original question: How can I tell cabal additional flags to use for C bits
18:06:30 <merijn> i.e. library paths and include directories
18:07:05 <Arahael> merijn: Unfortunately I don't know that bit exactly, but for windows I could suggest putting the .dll's alongside the executable.
18:07:32 <Arahael> merijn: And for linux, use (abuse?) the LD_PRELOAD_PATH and the like, as environment variables?
18:07:39 <merijn> I don't support windows anyway
18:07:48 <merijn> Unless it happens to be by accident
18:08:26 <merijn> Arahael: LD_PRELOAD_PATH doesn't help, as the compiler won't be able to find header files
18:08:26 <Arahael> I would probably look into dynamic loader environment variables in linux.
18:08:37 <Arahael> Why not specify _all_ of them, then?
18:08:42 <Arahael> Or is there a naming collision?
18:08:51 * hackagebot objectid 0.1.0.2 - Rather unique identifier for things that need to be stored  http://hackage.haskell.org/package/objectid-0.1.0.2 (tsuraan)
18:08:58 <merijn> Specify "all" of what?
18:09:05 <jle`> @src groupBy
18:09:05 <lambdabot> groupBy _  []     =  []
18:09:05 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
18:09:05 <lambdabot>     where (ys,zs) = span (eq x) xs
18:09:10 <Arahael> merijn: All the header paths for the libraries you use.
18:09:16 <jle`> @src span
18:09:16 <lambdabot> span _ xs@[]                  = (xs, xs)
18:09:16 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
18:09:16 <lambdabot>                   | otherwise = ([],xs)
18:09:36 <merijn> Arahael: Different versions of the same library, so that won't fly
18:10:00 <Arahael> merijn: You're mixing versions of the same library?
18:10:20 <merijn> Arahael: No, I just said I have multiple executables
18:10:39 <merijn> They all need to be linked against different versions
18:10:56 <Arahael> merijn: Couldn't you focus on one executable at a time? (Am I going in circles)
18:11:24 <merijn> Arahael: How?
18:11:38 <Arahael> merijn: By using a separate .cabal file for each?
18:11:39 <merijn> You can only configure cabal on the package level, afaik
18:11:44 <merijn> That makes no sense
18:11:51 <merijn> They're tests for a single library
18:12:09 <Arahael> See, that's the bit that kept confusing me.
18:13:49 <merijn> And I can't specify the executables to cabal anyway, because AFAIK cabal only understands C files and not C++
18:14:44 <Arahael> merijn: I would expect so - the C++ libraries tend to need a C interface to be useful by other projects.
18:15:40 <merijn> Arahael: No, cabal doesn't know about C++ compilers
18:15:53 <merijn> Arahael: So it can only compile C
18:16:26 <merijn> I can insert a hook into Setup.hs to call out to make, but then I still need to figure out how the hell to pass the right flags on to make
18:16:37 <Arahael> I would expect that's more because even if cabal compiled C++, it would still need to figure out how to link to it, and that's not specified.
18:17:21 <merijn> That doesn't matter it doesn't need to link it anyway
18:17:30 <Arahael> merijn: Perhaps shell out to a custom script instead of the project's make?
18:17:38 <Arahael> (Assuming you can...)
18:17:47 <merijn> Arahael: And what would I put in this "custom script"?
18:18:06 <Arahael> merijn: The right header paths for that specific executable.
18:18:18 <merijn> Arahael: Which I know statically, how?
18:18:57 <Arahael> merijn: There'll be _something_ you could clean from the environment or argument, surely. Otherwise how would 'make' know what to do?
18:19:12 <merijn> Arahael: That's exactly what I'm asking
18:20:03 <Arahael> merijn: Normally make itself knows because it looks at the current directory for the makefile. You could put a file there that conveniently contains the required flags?
18:20:21 <merijn> Arahael: I think you're utterly misunderstanding my problem
18:20:45 <Arahael> merijn: That's likely.
18:21:46 <Arahael> merijn: Sorry I couldn't help.
18:21:47 <cellopin> best resource for learning haskell?
18:21:59 <cellopin> from scratch
18:22:00 <merijn> cellopin: LYAH, Real World Haskell, Bird's book
18:22:00 <pharpend> @@ cellopin @where lyah
18:22:00 <lambdabot>  cellopin http://www.learnyouahaskell.com/
18:22:25 <Arahael> cellopin: I was told that "Real World Haskell" is good but very dated (and apparently not recommended anymore) - everyone else I know seems to use, and recommend, learnyouahaskell.
18:22:37 <benzrf> Arahael: deb8able
18:22:47 <benzrf> Arahael: CIS194 or NICTA is the new hotness apparently
18:22:51 <Arahael> benzrf: Good to know.
18:23:00 <merijn> Real World Haskell is dated in that most of the code doesn't compile as-is, but the underlying theory/design is still relevant
18:23:01 <benzrf> Arahael: have you been shown bitemyapp's carefully compiled guide
18:23:03 <pharpend> cellopin: RWH is a bit dated, LYAH is much more approachable. RWH is very good, definitely worth reading (after LYAH), just don't try the code examples, because they probably won't work
18:23:10 <pharpend> cellopin: what merijn said
18:23:22 <Arahael> NeueWelt: Could you give some urls?
18:23:42 <Arahael> benzrf: (How did that tab-expand to that...)  Could you give me some urls?
18:23:45 <cellopin> okay.. i'll take a look at learnyouahaskell first
18:23:48 <cellopin> thanks
18:24:01 <benzrf> Arahael: https://github.com/bitemyapp/learnhaskell
18:24:06 <Arahael> pharpend: Very good to know, I'm still reading it as I find the language there more easily understandable than LYAH.
18:24:18 <benzrf> Arahael: look @ the readme.md
18:24:24 <Arahael> benzrf: Wonderful - thanks!
18:24:38 <Arahael> I'd best get going.
18:28:52 * hackagebot clean-unions 0.0.1 - Open unions without need for Typeable  http://hackage.haskell.org/package/clean-unions-0.0.1 (FumiakiKinoshita)
18:54:17 <cellopin> okay I'm here. https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#installing-and-setting-up-emacs but 'M-:' doesn't work.
18:54:45 <cellopin> I'm using emacs23
18:55:01 <benzrf> cellopin: youre holding alt and shift and then pressing ;?
18:55:57 <cellopin> oh so it goes to the console and shows Eval:?
18:56:15 <benzrf> i dunno
18:56:16 <benzrf> i dont use emacs
18:56:28 <benzrf> i was just checking to make sure youre correctly interpreting the description M-:
18:56:29 <cellopin> ahh this is just so hard
18:57:17 <BMeph> That's what she said?
18:58:26 <benzrf> BMeph: (☞ﾟ∀ﾟ)☞
18:58:42 <RyanGlScott> Is there a function in mtl/transformers that "composes" ReaderTs? Something to the effect of :: :: ReaderT r m a -> ReaderT a m b -> ReaderT r m b
18:58:50 <cellopin> honestly, I can't start learning haskell if I can't setup the programming environment.
19:00:06 <T_X_> what's the best way to run an ncurses program from within a haskell program?
19:00:42 <T_X_> I'd also need to be able to change stdin/stdout/stderr (would like to connect that to a network socket later)
19:01:17 <T_X_> createProcess does not seem to work for me so far
19:02:19 <benzrf> @unmtl ReaderT r m a
19:02:19 <lambdabot> r -> m a
19:02:45 <benzrf> RyanGlScott: (>=>) maybe?
19:03:08 <merijn> T_X_: createProcess doesn't work because the created process is not attached to a pty (which is what curses needs)
19:03:45 <merijn> T_X_: There's no easy way to do this from haskell yet, I started working on a library for this, but I haven't had time to make it portable yet
19:04:17 <merijn> T_X_: Easiest way will probably to write a little bit of C to do the forking for you using forkpty
19:04:23 <geekosaur> there are pty libraries but they're pretty raw. also, you can expect to have problems communicating with the program, because curses updates as it wishes, not in a way that makes sense to humans
19:04:30 <geekosaur> or to listening programs
19:04:32 <RyanGlScott> I mean, you could do \(ReaderT x) (ReaderT y) -> ReaderT (x >=> y), but I was wondering if it were possible to avoid using pattern matching.
19:05:25 <geekosaur> worst case, you will be reimplementing much of the logic of screen/tmux in order to track the program's stdout
19:05:27 <merijn> :t liftM2 (>=>)
19:05:28 <lambdabot> (Monad m1, Monad m) => m (a -> m1 b) -> m (b -> m1 c) -> m (a -> m1 c)
19:05:28 <benzrf> RyanGlScott: why would you avoid pattern matching.
19:05:40 <benzrf> merijn: you'r doing it wrong
19:05:47 <merijn> yeah, I see
19:05:49 <benzrf> merijn: liftM2 isnt for newtype wrappers
19:05:49 <RyanGlScott> benzrf: It just seems like a common-enough use case that someone would have put it in mtl already.
19:05:56 <benzrf> RyanGlScott: /me shrugs
19:06:08 <merijn> I think I meant
19:06:11 <T_X_> merijn, geekosaur: makes sense. writing a little C program sounds like a good idea
19:06:12 <RyanGlScott> Oh well, that works too I suppose.
19:06:25 <T_X_> thx!
19:06:29 <merijn> T_X_: I actually have sample code for you, which as mentioned is horribly unportable
19:06:51 <merijn> T_X_: https://github.com/merijn/posix-pty
19:07:04 <merijn> I should get around to fixing that library some time
19:07:40 <geekosaur> that will handle the pty part. you will shortly find out what I meant about the curses part (and why curses is so aptly named...)
19:09:33 <merijn> Is there a way to get cabal to tell ghc to link some object file X into an executable?
19:10:50 <tabemann_> why am I reading GOOS?
19:17:43 <geekosaur> merijn, I think that's proved difficult in the past. you may be able to stick them in ld-options
19:19:15 <merijn> geekosaur: hmm, maybe it's better to just not have cabal link this, but that gives me another problem. How to have my tests depend on artifacts not build by cabal :\
19:20:19 <geekosaur> that I have no idea about
19:20:46 <geekosaur> I think object files are more likely to work with ld-options than libraries are currently
19:22:02 <merijn> geekosaur: I'm not building libraries, but executables
19:23:17 <geekosaur> I meant that a foo.o will work with the current ld-options but a -lfoo might be ignored
19:23:35 <geekosaur> irrespective of ewhether you are building a library or an executable
19:24:24 <merijn> geekosaur: No, I meant my tests depend on executables. I'm fine with building and linking the entire thing outside of cabal, but then I dunno how inform cabal of which executables where build and where
19:27:32 <boberty> hi
19:46:52 <bms1> I am linking to a library, and on Windows, the library appears to behave differently depending on if I call it from C or from Haskell's FFI
19:47:34 <bms1> In particular, when I call it from Haskell's FFI, it only works properly if I use 32-bit types for size_t and ptrdiff_t, essentially
19:47:42 <bms1> Here's the relevant code: http://lpaste.net/112112
19:48:43 <bms1> (I am using 64-bit GHC, and I have sizeOf (_ :: Word) = 8)
19:49:48 <davean> 1/buf14
19:51:56 <bms1> Is there something different about using the Haskell FFI compared to calling from C which explains this?
19:53:03 <merijn> bms1: Don't use Word to interact with C
19:53:13 <merijn> bms1: Use the types from Foreign.C.Types
19:53:53 <bms1> merijn: CSize doesn't work either (also, I can't use CSize as an argument to an FFI call)
19:54:34 <merijn> eh, why can't yu use CSize as argument to an FFI call?
19:55:15 <bms1> GHC complained when I tried it; as if it weren't a type that could be sent across the FFI
19:55:16 <merijn> Your SizeT is pretty much guaranteed to be a disaster
19:55:38 <merijn> "GHC complained" is not a valid error message
19:56:10 <bms1> merijn: In actuality, the header for these functions asks for the custom type MWSize; when I use hsc2hs, it reduces it to Word, I'm pretty sure. I can check again
19:56:43 <merijn> Also, your list is most likely defaulting to Int
19:56:47 <merijn> Which is wrong
19:57:33 <bms1> merijn: No, type inference should make it a SizeT
19:57:47 <merijn> oh, you're right there
19:58:22 <bms1> (when I set SizeT = Word32, everything works properly)
19:58:31 <bms1> I will check again what hsc2hs said that MWSize was
20:00:20 <bms1> ok, MWSize is set to Word64 by hsc2hs
20:00:25 <merijn> Is your gcc 64bit?
20:01:01 <bms1> merijn: Yes. At least the one that I'm using to compile the C code. Is it possible that hsc2hs is using a different C compiler?
20:01:20 <merijn> I have no clue what hsc2hs uses
20:01:25 <bms1> wait, that question doesn't make sense
20:01:47 <merijn> Which question doesn't make sense?
20:01:59 <bms1> the one I asked!
20:02:31 <merijn> bms1: Sounds like a sensible question to me
20:03:06 <bms1> Oh, I just don't think it would explain things. Because hsc2hs is saying that I should use Word64. But from testing, it seems that I need Word32 when I use the Haskell FFI
20:03:08 <merijn> Pretty sure hsc2hs creates a C file that compiles to a program that spits out the haskell file with the relevant cbits hardcoded by the output from C
20:03:16 <bms1> (even though when I use C, I need to use 64-bit types)
20:03:34 <merijn> bms1: You're making a flawed assumption here
20:03:53 <merijn> bms1: You're assuming that a 64bit C compiler uses an 8 byte word size
20:04:12 <merijn> You have no such guarantee, and in fact the GHC runtime system had a bug because this is false on OSX
20:04:29 <merijn> (64bit gcc on OSX has 4 byte int, etc.)
20:04:57 <bms1> merijn: Where am I assuming that? I have checked the sizes of the words for both the C program and for the hsc2hs output
20:05:24 <bms1> merijn: Now, if Haskell's FFI used 32-bit words when doing it's FFI stuff (on Windows), *that* would explain things
20:06:35 <bms1> And if hsc2hs just works by calling a C compiler, then this error could presumably then be explained by the fact that I am supposed to have hsc2hs call a C compiler which uses 32-bit words, not 64-bit
20:07:16 <merijn> bms1: Where exactly did you check the word size of your C program?
20:07:34 <bms1> http://lpaste.net/112112#line42
20:07:49 <bms1> (mwSize is the actual type where I'm having the 32-bit/64-bit issues)
20:07:59 <bms1> (hsc2hs says MWSize = Word64)
20:08:13 <bms1> But if I manually say MWSize = Word32, then things work properly
20:08:32 <merijn> bms1: I have no clue what mwSize is, so I have no clue what C type it maps too
20:09:01 <bms1> merijn: It is essentially MATLAB's wrapper over size_t
20:10:08 <merijn> Anyway, I would check whether hsc2hs is using the same C compiler that you're calling
20:11:04 <bms1> Does that matter? It seems like I need to ensure that hsc2hs is calling a C compiler which is "compatible" with how Haskell's FFI works
20:11:18 <bms1> But thanks for the advice; I will check that
20:12:18 <merijn> bms1: GHC's FFI depends on the ABI of your platform. 64bit GHC on windows should be using the 64bit windows ABI
20:12:50 <bms1> thanks!
20:13:01 <merijn> bms1: Now assuming the gcc you're calling matches that ABI (i.e. 64bit windows calling convention) then it should work, assuming that hsc2hs is using a C compiler with the same ABI (otherwise it will mess up the generated sizes)
20:13:37 <merijn> Although verifying which ABIs is being used is beyond my knowledge
20:54:00 * hackagebot editable 1.0.0.0 - Interactive editors for Generics  http://hackage.haskell.org/package/editable-1.0.0.0 (MaxwellSwadling)
20:58:33 <gcganley> @pl seq
20:58:33 <lambdabot> seq
20:58:46 <gcganley> :t seq
20:58:47 <lambdabot> a -> b -> b
20:58:56 <gcganley> @src seq
20:58:56 <lambdabot> Source not found. Are you typing with your feet?
20:59:15 * hackagebot editable 1.0.0.1 - Interactive editors for Generics  http://hackage.haskell.org/package/editable-1.0.0.1 (MaxwellSwadling)
21:01:49 <merijn> gcganley: seq is built into the compiler
21:02:14 <trap_exit> random question: what's your 2nd favorite langauge, and how does it complement your use of Haskell ?
21:02:30 <trap_exit> (mine is Javascript: it complements my need to write Haste / GHCJI ffi bindings)
21:02:45 <benzrf> bye
21:02:54 <gcganley> :merijn what does it do?
21:03:00 <exio4> trap_exit: C!
21:03:05 <merijn> gcganley: Ah, that's a tricky question
21:03:29 <trap_exit> exio4: how does it complement your use of Haskell ?
21:03:40 <merijn> gcganley: "seq x y" says that IF neither 'x' nor 'y' are bottom, then after evaluating "seq x y" BOTH 'x' and 'y' will be evaluated
21:04:15 * hackagebot editable 1.0.0.2 - Interactive editors for Generics  http://hackage.haskell.org/package/editable-1.0.0.2 (MaxwellSwadling)
21:04:20 <merijn> gcganley: Which is pretty much only useful in a situation like "let x = someExpensiveComputation in seq x (doSomethingWith x)"
21:04:50 <exio4> trap_exit: I'd say it doesn't complement much, outside the interoperation with other libraries, but I am not a pro-super-haskeller, I am "just starting" :P
21:07:08 <nisstyre> trap_exit: my second favourite language is Haskell
21:07:08 <gcganley> :merijn sounds very strict eval...
21:08:41 <gcganley> `:merijn is strict eval its use case?
21:08:42 <merijn> gcganley: It's for introducing strictness, yes. Note that it only evaluates to WHNF, though
21:09:04 <gcganley> :merijn whnf? never seen that term
21:09:36 <nisstyre> weak head normal form
21:11:38 <merijn> gcganley: Weak head normal form roughly translates to "outermost value is a constructor"
21:12:35 <trap_exit> merijn: why is WHNF not "outermost value is a constructor" ?
21:12:39 <trap_exit> s/why/when/g
21:12:49 <gcganley> :merijn outermost on both sideds or the left?
21:13:00 <merijn> trap_exit: I'm hedging, I'm not sure if they're the same :p
21:13:22 <merijn> trap_exit: And actually "outermost value is a constructor" is not a very precise description to begin with
21:13:23 <trap_exit> merijn: I thikn when something valuates to a function (say via currying) it isn't a constructor
21:14:43 <merijn> gcganley: This is probably more in-depth than I can muster right now: https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
21:15:28 <merijn> As a bonus, it mentions seq too
21:16:06 <trap_exit> this is amazing
21:16:11 <trap_exit> an useful stack overflow response
21:16:22 <gcganley> :merijn is seq a ghc thing or a haskell thing?
21:16:39 <trap_exit> haskell
21:16:41 <trap_exit> I think
21:16:49 <trap_exit> merijn: is seq a ghc thing or a haskell thing?
21:16:55 <gcganley> so its the fully evaled form
21:17:05 <trap_exit> no, seq is only whnf
21:17:10 <trap_exit> deepseq it eh fully evaluated form
21:17:14 <gcganley> if it were a lambda expression it could not be reduced any further?
21:17:17 <geekosaur> seq is a haskell thing. deepseq is a ghc thing
21:17:40 <merijn> trap_exit: Pretty sure seq is part of the report
21:17:58 <merijn> gcganley: No, normal form is "can't be reduced any further"
21:18:13 <merijn> gcganley: Anyway, see the SO link for more details
21:18:38 <gcganley> :merijn sorry i was looking under the wrong title... it was normal form
21:19:16 <trap_exit> haskell is worse than lack of knowledge; for someone who knows not programming languages can learn PHP and get a job
21:19:56 <gcganley> :merijn ok, this clears it up alot, thank you
21:20:37 <gcganley> but where is the source for seq?
21:21:03 <merijn> gcganley: There is no source, you can't implement seq in haskell
21:21:05 <gcganley> ghc's seq if its implementation specific
21:21:07 <jTT> is there a difference between Text.Html and Text.HTML? cabal tells me Text.HTML does not exits yet it is on hackage
21:21:27 <gcganley> :merijn how does GHC do it then?
21:21:33 <merijn> gcganley: There is no source, seq is built into the compiler.
21:21:41 <merijn> gcganley: By generating different code
21:22:17 <gcganley> :merijn ok so if I search through the GHC compiler i would find it but not in any of the haskell files?
21:22:28 <gcganley> :merijn only the C files or some other file?
21:23:30 <geekosaur> jTT, haskell (and cabal) is case sensitive, yes
21:24:20 <jTT> ok thanks. any idea why i can’t import Text.HTML but Text.Html works fine? cabal doesn’t know what to do with >cabal install Text.HTML
21:24:42 <merijn> jTT: Text.HTML is not a package name
21:24:51 <merijn> gcganley: Which C files?
21:25:09 <jTT> merjin: what is it then?
21:26:28 <geekosaur> module name
21:27:25 <jTT> import Text.HTML.TagSoup —> Could not find module ‘Text.HTML.TagSoup
21:28:05 <geekosaur> so, hayoo is telling me there are packages providing things under Text.HTML, but not Text.HTML itself
21:28:24 <geekosaur> cabal install tagsoup
21:28:24 <jTT> what a silly thing
21:28:57 <jTT> :geekosaur thanks
21:29:05 <geekosaur> I think there is a query to find a package name for a module (and I could argue that cabal should try to resolve a module name to a package name, but I'm not sure that is in the metadata)
21:29:11 <geekosaur> @where hayoo
21:29:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
21:29:29 <geekosaur> hoogle is less useful for this, hayoo indexes all of hackage
21:29:30 <jTT> cheers
21:29:39 <jTT> wasnt aware of hayoo
21:29:44 <geekosaur> actually that link is out of date, sorrt
21:29:54 <jTT> np, will find it
21:30:02 <geekosaur> it's just http://hayoo.fh-wedel.de/ now
21:30:57 <geekosaur> @where+ hayoo http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle (GHC bootlibs) https://www.fpcomplete.com/hoogle (Platform)
21:30:57 <lambdabot> I will remember.
21:31:09 <geekosaur> @where hayoo
21:31:09 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle (GHC bootlibs) https://www.fpcomplete.com/hoogle (Platform)
21:31:15 <geekosaur> @where hoogle
21:31:15 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
21:31:59 <geekosaur> @where+ hoogle http://haskell.org/hoogle (GHC bootlibs) https://www.fpcomplete.com/hoogle (Platform) -- See also Hayoo: http://hayoo.fh-wedel.de/
21:31:59 <lambdabot> I will remember.
21:32:05 <geekosaur> that's better
21:34:14 <jTT> geekosaur: nice
21:48:01 <jTT> gee, now ghci tells me “Could not find module `Text.XML.Cursor’” what is this bs?
22:17:28 <gcganley> @src (***)
22:17:28 <lambdabot> f *** g = first f >>> second g
22:19:17 <bb010g> @src (>>>)
22:19:17 <lambdabot> Source not found. That's something I cannot allow to happen.
22:19:59 <jle`> (>>>) = flip (.)
22:20:09 <jTT> anyone having trouble installing xml-conduit? it’s telling me that system-filepath is required but cannot be installed
22:21:02 <jle`> it used to be a part of the Arrow typeclass but I believe that it no longer is...it's been moved to Control.Category and is now flip (Control.Category..)
22:51:28 <jontmorehouse> I'm using the hedis package and for some reason I can only use an IO String() as key/value
22:51:37 <jontmorehouse> why can't I do something like set r "key" "value"?
22:58:58 <jle`> IO String ()?
22:59:18 <jontmorehouse> jle`: yeah, I believe so?
22:59:38 <jontmorehouse> for instance ... this works: `set redis (show "key") (show "value")
22:59:50 <jontmorehouse> but not `set redis "key" "value"`
23:00:16 <joelteon> show "key" isn't IO String
23:00:48 <jle`> IO String () is not a type :/
23:00:50 <jontmorehouse> joelteon: ok, but its not String either right?
23:01:00 <jle`> let's ask :)
23:01:03 <jle`> :t show "key"
23:01:04 <lambdabot> String
23:01:12 <jle`> wat
23:01:20 <jontmorehouse> then whats the difference between "test" and (show "test")
23:01:25 <jle`> > "test"
23:01:27 <lambdabot>  "test"
23:01:30 <jle`> > show "test"
23:01:31 <lambdabot>  "\"test\""
23:02:10 <dv-> > iterate show "text"
23:02:11 <lambdabot>  ["text","\"text\"","\"\\\"text\\\"\"","\"\\\"\\\\\\\"text\\\\\\\"\\\"\"","\"...
23:03:33 <jontmorehouse> hmm so I'm reading about that
23:03:45 <jontmorehouse> still a little confused as to why I can't do set redis "key" "value"
23:03:59 <jle`> what is the type of `set`?
23:04:05 <jle`> let's follow the types here
23:05:43 <jontmorehouse> https://gist.github.com/e7a7c1be644cce54c0b2
23:06:37 <jontmorehouse> so if I read this correctly ... its first aliasing s1/s2 as the database bytestring type
23:06:46 <jontmorehouse> and then its expecting s1/s2 as params
23:18:09 <jle`> what is the type?
23:18:21 <jle`> ah, it's in the gist
23:18:55 <jle`> what is the error when you try it without the show?
23:29:28 <trap_exit> how does #haskell manage to keep a high signal to noise level despite not requiring people to be registered to join ?
23:29:40 * hackagebot codecov-haskell 0.1.0 - Codecov.io support for Haskell.  http://hackage.haskell.org/package/codecov-haskell-0.1.0 (killy971)
23:30:12 <Axman6> obscurity
23:30:13 <guegue> map (+1) [1..10]
23:30:36 <zq> > map (+1) [1..10]
23:30:38 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
23:30:43 <zq> -- guegue
23:31:26 <guegue> I'm very first, irc.
23:33:21 <zq> that's alright. we were/are all very first at some point.
23:34:44 <guegue> @type map
23:34:44 <lambdabot> (a -> b) -> [a] -> [b]
23:35:19 <Arahael> Hey, I'm struggling to simplify my (utterly naive) haskell code, could I have some help?
23:35:36 <Axman6> not without seeing it we can't
23:35:51 <guegue> @hoogle [a] -> [a]
23:35:53 <lambdabot> Prelude cycle :: [a] -> [a]
23:35:53 <lambdabot> Data.List cycle :: [a] -> [a]
23:35:53 <lambdabot> Prelude init :: [a] -> [a]
23:36:28 <Arahael> http://lpaste.net/112119
23:36:54 <Arahael> Axman6: There. :)  I notice that site gives a lot of helpful comments, actually, but I don't think my issue is with the redundant $'s.
23:37:07 <Axman6> instead of using T.append, use T.concat [...]
23:37:29 <Arahael> Yes, that would work. Any other tips?
23:37:40 <guegue> @pl \xs n -> take n xs
23:37:40 <lambdabot> flip take
23:37:44 <Arahael> I guess that would make my first attempt the simplest?
23:38:05 <Axman6> the way you're using Just seems odd, can decodeUtf8 fail?
23:38:27 <Axman6> what is CI ByteString btw?
23:38:27 <guegue> @djinn (a, b) -> c -> (b, c)
23:38:27 <lambdabot> f (_, a) b = (a, b)
23:38:32 <Arahael> Axman6: Currently with an exception, which I hate.  I intended to change it to the form that uses Maybe. And yes, decodeUtf8 can fail.
23:38:40 <Arahael> Axman6: CaseInsensitive ByteString.
23:38:48 <Axman6> where's it from?
23:39:09 <Axman6> case insensitive is a weird thing to talk about when discussing a type designed for handling data and not text ;)
23:39:29 <Arahael> I've just added the imports: http://lpaste.net/112119
23:39:36 <Arahael> But it's from Data.CaseInsensitive.
23:39:49 <guegue>  @unmtl StateT s IO a
23:39:50 <Arahael> These are actually HTTP headers.
23:40:10 <Axman6> guegue: no space:
23:40:18 <Axman6> @unmtl StateT s IO a
23:40:18 <lambdabot> s -> IO (a, s)
23:40:31 <Axman6> Arahael: so what're you actually trying to do?
23:40:47 <Axman6> at the highest level
23:41:07 <guegue> @unmtl StateT s IO a
23:41:07 <lambdabot> s -> IO (a, s)
23:41:32 <guegue> thanks Axman6
23:41:56 <Axman6> guegue: sadly unmtl is a bit dumb:
23:42:07 <Axman6> @unmtl StateT s (ListT IO) a
23:42:07 <lambdabot> s -> (ListT IO) (a, s)
23:42:16 <Arahael> Axman6: The first attempt there looked messy to me, I wanted to have an "elegant" approach to this.  In python, I might do something like: '\n'.join(str(a)+": "+str(b) for (a, b) in xs)
23:42:47 <Axman6> well, '\n'.join... is equivalent to T.unlines
23:43:11 <Axman6> :t unlines
23:43:11 <lambdabot> [String] -> String
23:43:16 <Axman6> (replace String with Text)
23:43:26 <Axman6> > unlines ["Hello","World"]
23:43:27 <lambdabot>  "Hello\nWorld\n"
23:43:55 <Arahael> Axman6: I might make a fourth example now, that includes using unlines, and T.concat.
23:44:15 <Axman6> what's original do?
23:45:14 <Arahael> Axman6: It returns theprovided HTTP headers, formatted using key: value for each line.
23:45:55 <Arahael> Axman6: And even though I don't need to, I also wnat it to cater for failing decodeUtf8.
23:46:03 <Axman6> right
23:46:16 <Arahael> Which means making use of Maybe, although I don't _actualyl_ make use of the correct form of decodeUtf8 there.
23:46:31 <Arahael> (One thing at a time!)
23:46:58 <Axman6> one sec
23:47:29 <Axman6> have you condsidered using decodeUtf8' :: ByteString -> Either UnicodeException Text?
23:48:16 <Arahael> Axman6: That would work as well, but I would have the same basic structure, so I consider Either or Maybe equivalent for this excerise.
23:48:53 <Axman6> sure, but you can at least handle the errors with that one, you can't do anything with errors currently
23:49:12 <Arahael> Axman6: True, my fourth example will use that form, then. :) For clarity.
23:51:37 <Arahael> It currently takes me a long time for each of these attempts, as I find myself doing too much in a single function.
23:51:54 <Arahael> (And then trying to figure out how to get the syntax right, making the compiler happy, etc)
23:51:58 <lpaste> Axman6 annotated “No title” with “No title (annotation)” at http://lpaste.net/112119#a112121
23:52:29 <Axman6> take a look at that annotated version (down the bottom)
23:53:13 <Axman6> uh, except that should obviously be k
23:53:18 <Axman6> k' and v'*
23:53:48 <Arahael> That is definitely elegant, I like it. I can see how you're making use of do notation there to get the value out, I was using (only) patterns for this.
23:56:17 <Axman6> to get the behaviour (I think) you want, you probably won't be able to it all in the Either monad so you will need pattern matching on each pair to see which ones successfully parsed
23:56:36 <Arahael> Axman6: Thanks - this helps, I'm glad I asked a haskeller. :)
23:57:03 <Axman6> so what do you want to happen when one of the decoding steps fails?
23:57:49 <Arahael> Axman6: Actually I did forget to ask that question - if the decoding steps fail, I would prefer it to substitute an altenrative value isntead. (Such as  "<Error: Invalid Encoding>")
23:58:12 <Axman6> :t either
23:58:13 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
23:58:23 <Arahael> Axman6: HTTP Headers are effectively ASCII from what I understand, by convention, so I'm really massively overengineering this, but hey, it's a simple, easy way for me to leanr haskell.
23:58:39 <Axman6> :t either (\_ -> "Error: Invalid Encoding>")
23:58:41 <lambdabot> (b -> [Char]) -> Either a b -> [Char]
23:58:46 <Arahael> So making use of either there, would be very very effective.
23:58:48 <Arahael> And still elegant.
