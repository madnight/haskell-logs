00:00:38 <solatis> but basicly instead of writing foo :: a -> a, you write foo :: a -> (a -> r) -> r
00:00:51 <solatis> so, instead of putStrLn foo, you write foo putStrLn
00:01:04 <cbarrett> That does look somewhat similar to what you've got there with the scoping
00:01:05 <solatis> so my gut feeling tells me this is something i want
00:01:27 <cbarrett> follow that! trust your gut.
00:01:41 * solatis bows to his gut
00:01:57 * solatis => off to #haskell-blah
00:03:38 <Total_1mmersion> Has anyone used cabal sandbox add-source <pkg> where <pkg> is installed both locally in a directory <pkg>/ and exists on Hackage? I can't figure out how to make cabal look at the local one instead of the one on Hackage.
00:05:05 * hackagebot warp-tls 3.0.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1 (MichaelSnoyman)
00:05:05 * hackagebot mighttpd2 3.2.4 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.4 (KazuYamamoto)
00:11:29 <jle`> Total_1mmersion: try using an absolute path
00:11:38 <jle`> to the directory where the package is stored
00:14:10 <Total_1mmersion> jle`: is there even a difference? It looks like cabal figures out the absolute path because cabal sandbox list-sources shows the absolute path.
00:15:10 <jle`> i'm not sure, but i've never had problems with cabal sandbox finding the right package source :/
00:25:06 <Total_1mmersion> jle`: what sequence of commands do you use? Here's what I do: cabal sandbox init && cabal sandbox add-source <pkg> && cabal install --dependencies-only && cabal build
00:26:15 <Total_1mmersion> And is there a better way other than recreating the entire sandbox to remove the Hackage <pkg> and replace it with a local one?
00:40:03 * hackagebot scientific 0.3.3.2 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.2 (BasVanDijk)
01:05:36 <Total_1mmersion> Has anyone else had trouble with GHC apparently optimizing out some IO operations, like print statements?
01:07:51 <jle`> Total_1mmersion: what kind of optimization do you mean?
01:08:17 <jle`> and yes, that's pretty much what i use. i call install all together, heh.
01:08:20 <jle`> *cabal
01:08:53 <Total_1mmersion> I think GHC realizes that I'm returning () and doesn't bother executing the print statements right before it. Something like print "hi" >> return ()
01:09:31 <jle`> um, i'm not sure that that happens.
01:09:45 <jle`> are you remembering to flush your buffers?
01:10:28 <Total_1mmersion> Are there some implicit buffers floating around? How would I flush them?
01:10:35 <jle`> it depends on your terminal
01:10:54 <jle`> or shell?
01:11:04 <jle`> when you send stuff to be printed, it doesn't actaully get printed until the buffer is flushed
01:11:08 <Total_1mmersion> I'm using the standard Linux Mint 17 terminal and bash
01:11:09 <jle`> usually it's set to flush on every newline
01:11:35 <jle`> so if you putStr and there's no newline, it's still waiting in the buffer, most likely
01:12:13 <jle`> i think it also generally flushes when the program terminates expectedly
01:12:28 <jle`> as in...without any errors
01:12:54 <jle`> if something isn't printing, first make sure control actaully goes to that statement, and then try adding a flush
01:12:57 <jle`> a manual flush
01:13:11 <Total_1mmersion> I'm pretty sure my program is terminating expectedly. I have a print statement at the end of main, and that is getting printed, but something in the middle isn't (it's at the end of a conduit).
01:13:51 <jle`> make sure that the conduit machinery works like you think it does
01:14:28 <jle`> i'm pretty sure that print x >> return () --> return () is not an optimization that ghc would make
01:16:16 <Total_1mmersion> Huh, inserting "C.mapM undefined" into the conduit didn't throw an exception... conduit must not even be executing that part
01:28:32 <Hijiri> is there something that can compile pure haskell functions to javascript methods? I know there's ghcjs for providing an entire runtime, but I don't see anything about foreign exports
01:36:08 <malllle>    Hijiri maybe https://github.com/faylang/fay/wiki is something for you?
01:39:02 <jle`> Hijiri: it's a bit tricky because there's a lot of semantics in pure haskell functions that cannot be directly translated into javascript without a runtime
01:39:47 <jle`> for example, laziness
01:40:02 <jle`> how would you compile const x _ = x ?
01:40:53 <jle`> or something like foo n = take n [1..] ?
01:41:42 <jle`> or unfoldr f x0 = x0 : unfoldr f (f x0)
01:42:08 <jle`> or anything that requires laziness internally to even make sense
01:42:59 <tdammers_> well, you *can* translate it, but the resulting output wouldn't be "plain" javascript
01:43:12 <tdammers_> i.e., your plain Haskell functions would translate to something other than a plain function in JS
01:44:07 <jle`> usually that involves porting over a subset of some sort of runtime, right?
01:44:30 <jle`> i guess unless you "inline" everything
01:45:16 <jle`> you can directly translate some subsets (or variations) of haskell into "plain" javascript, and that's what languages like `purescript` sort of try to give you
01:47:18 <tdammers_> yeah, pretty much
01:48:01 <tdammers_> still, if the runtime is "open" (in the sense that it has a documented and useful API on the JS side that you can hook into), then you're already a lot further than if you take the output from ghcjs and try to make sense of it
02:03:27 <jle`> hm
02:03:50 <jle`> it would be interesting to port a subset of the haskell runtime into idiomatic javascript with documented/useful APIs
02:04:12 <jle`> at least the part involving pure functions
02:04:23 <jle`> there's lazy.js
02:12:39 <Zyxoas> ping
02:16:40 <Zyxoas> Hey peeps. Sir Newbmeister von N00benstein here. I have 1 or two questions to ask.
02:16:50 <Zyxoas> How's everyone doing?
02:21:34 <Zyxoas> I need to know something about HLists. They seem super cool, but alas, not very approachable.
02:26:52 <ddellacosta> Zyxoas: not sure if anyone who can answer is around but probably good just to ask your question. :-)
02:28:28 <Zyxoas> Good idea, ddellacosta. ;-)
02:31:09 <gfixler_> I did cabal install hoogle, but in the Prelude I'm getting for :hoogle searches: "bin/sh: hoogle not found"
02:31:17 <gfixler_> google has 0 information on this :(
02:32:19 <Zyxoas> What OS are you on @gfixler_?
02:33:00 <gfixler_> Ubuntu 14.04 LTS
02:33:23 <gfixler_> :def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
02:33:36 <gfixler_> I have that in my ~/.ghc/ghci.conf file
02:33:41 <gfixler_> and only that
02:33:47 <Zyxoas> Hmm... I'm stumped. Not in front a Linux comp at the moment.
02:34:07 <hyPiRion> are other cabal-installed programs available on your path?
02:34:12 <hyPiRion> e.g. hlint
02:34:17 <Zyxoas> Oh... What happens when you run hoogle from the command line?
02:34:31 <gfixler_> never cabal installed before'
02:34:36 <gfixler_> hoogle is not found in the shell
02:34:37 <Zyxoas> Yeah. Your path may be misconfigured.
02:34:40 <gfixler_> so ther's my problem
02:34:50 <gfixler_> there's a ~/cabal/ folder
02:35:17 <gfixler_> it has 794 files in it
02:35:31 <gfixler_> in the whole tree of folders under it, that is
02:35:43 <hyPiRion> yeah, prepend the PATH environment variable with "~/.cabal/bin:"
02:36:12 <hyPiRion> in your bashrc/zshrc/.profile
02:37:34 <gfixler_> aah, that did it
02:37:59 <gfixler_> surprised that so few have had this problem that it doesn't show up on google at all, though
02:38:29 <hyPiRion> hrm
02:38:36 <hyPiRion> For what it's worth, I also had that problem
02:39:38 <Zyxoas> Ditto. Annoying that the cabal bin folder is not done automatically upon install.
02:39:41 <gfixler_> I appreciate you helping, and knowing how to
02:39:46 <gfixler_> yes it is
02:40:01 <gfixler_> I'm keeping a guide of my hurdles
02:40:05 <gfixler_> maybe it will help the next newbie
02:40:08 <gfixler_> before it all changes again )
02:40:09 <gfixler_> :)
02:40:24 <ddellacosta> I can imagine there may be security issues to automatically appending stuff to $PATH, potentially
02:40:27 <dcoutts> Zyxoas: we originally suggested installing into ~/bin. You should have heard the howls of protest.
02:40:35 <ddellacosta> although I guess other installs do that too
02:40:48 <ddellacosta> dcoutts: what was the objection, in particular?  I mean, ~/bin seems reasonable
02:40:49 <gfixler_> well, it would be fine to kick out a big note at the end
02:40:50 <dcoutts> so we have this unfortunate situation where the default is not on your $PATH at all
02:41:02 <gfixler_> of course, I didn't read anything it kicked out at the end, so...
02:41:07 <dcoutts> ddellacosta: "I want to manage bin myself! Hands off!" was more or less the response
02:41:19 <ddellacosta> although, usually ~/bin is not in the PATH by default, in my experience
02:41:25 <gfixler_> at least there's #haskell to pick up the slack
02:41:35 <dcoutts> ddellacosta: yeah, i varys by distro
02:41:38 <ddellacosta> dcoutts: ah.  Yeah, I mean, for an experienced user that's true, but not always the case
02:41:39 <hyPiRion> ddellacosta: Well, at least there should be some information on how to put it on your path and where it resides.
02:41:40 <dcoutts> varys/varies
02:41:46 <ddellacosta> hyPiRion: yeah, agreed
02:42:04 <dcoutts> ddellacosta: one thing I'd like to do is make it an interactive initial config question
02:42:17 <Zyxoas> Yep. Seconded.
02:42:23 <ddellacosta> dcoutts: yeah, that seems like the best of both worlds: "want to add to $PATH? y/n"
02:42:27 <gfixler_> thirded
02:42:42 <gfixler_> but then I wouldn't be in here hanging out with cool folks
02:42:44 <gfixler_> :)
02:43:01 <ddellacosta> WHO ARE YOU CALLING COOL
02:43:06 * ddellacosta looks around suspiciously
02:43:14 <gfixler_> hehe
02:43:16 <dcoutts> ddellacosta: we cannot easily modify the $PATH, but we can suggest using ~/bin if we find that that location is on the $PATH, and we can point out clearly what they should do if there is no per-user location on the $PAT currently
02:43:42 <ddellacosta> dcoutts: ah. Well, I suppose even that is better than nothing.
02:43:56 <ddellacosta> (a good bit really)
02:44:21 <dcoutts> modifying the $PATH involves editing ~/.bash* or other shell startup files which is a nightmare and sure to annoy :-)
02:44:42 <ddellacosta> dcoutts: yeah, fair point
02:45:05 <ddellacosta> Zyxoas was commenting on HList, and I just noticed this in the docs: "This module gathers the API that we need for OOP in Haskell."  OOP in Haskell...wat?
02:45:15 <ddellacosta> here https://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList.html
02:45:32 <ddellacosta> I didn't realize it but, is OOP in Haskell a thing?
02:46:14 <gfixler_> bedtime for me - thanks for getting hoogle working for me - this rocks!
02:46:26 <t7> ddellacosta: you can do OOP in c
02:47:18 <ddellacosta> t7: yeah, I mean, I get that--I should have asked a less vague question: why would one advocate for OO in Haskell?
02:48:14 <bartavelle> ddellacosta, as OOP doesn't mean much, it really depends on what you mean by it ...
02:48:49 <bartavelle> but I don't think that java-like OOP is a thing, more like an amusing thought experiment and paper material
02:49:20 <ChristianS> ddellacosta: frankly i have no idea what that remark about "OOP in Haskell" in Data.HList is supposed to mean
02:49:23 <ddellacosta> bartavelle: yeah, I was more just trying to understand what the motivation for OO in Haskell would be (depending on how you define it, as you point out)
02:49:33 <ddellacosta> ChristianS: okay, I was pretty confused by that too
02:49:50 <bartavelle> ChristianS, there is a paper that shows how to implement class / inheritance stuff using dlist
02:49:52 <bartavelle> erm
02:49:53 <bartavelle> hlist
02:50:04 <ddellacosta> bartavelle: ah, now it's starting to make some sense
02:50:13 <ChristianS> bartavelle: got a link?
02:50:36 <bartavelle> trying to google for it, I only have a faint remembrance of it
02:51:45 <ddellacosta> bartavelle: this one perhaps? http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.772&rep=rep1&type=pdf
02:52:02 <ddellacosta> I see it mentions HList right away
02:52:20 <bartavelle> most likely yes, a more recent revision : http://arxiv.org/pdf/cs/0509027.pdf
02:52:57 <ddellacosta> interesting.  Well, it wouldn't be a normal day in #haskell if I didn't learn something new.
02:55:19 * hackagebot bgmax 0.1.0.0 - Parse BgMax-files  http://hackage.haskell.org/package/bgmax-0.1.0.0 (petterb)
03:00:23 <Zyxoas> Not looking to do OOP in Haskell. Just looking for a sane way of dealing with records.
03:01:52 <Zyxoas> That is, record.field should should, and field should not polite the namespace. HList seems like the simplest solution to that problem.
03:02:13 <Zyxoas> record.field should work
03:02:36 <Zyxoas> and field should not pollute the namespace
03:03:57 <Zyxoas> Actually. That Arxiv paper looks like it might answer the questions I had. Let me go through it quickly...
03:34:43 <vermeille> Do you guys know a good lib for image creation? I'd need something providing a good interface for manipulating pixel buffer
03:36:14 <tdammers_> idk... maybe imagemagick fits the bill?
03:36:50 <scopevale> :help
03:40:24 * hackagebot th-reify-many 0.1.1 - Recurseively reify template haskell datatype info  http://hackage.haskell.org/package/th-reify-many-0.1.1 (MichaelSloan)
03:40:26 * hackagebot idris 0.9.15.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.15.1 (EdwinBrady)
03:40:28 * hackagebot th-reify-many 0.1.2 - Recurseively reify template haskell datatype info  http://hackage.haskell.org/package/th-reify-many-0.1.2 (MichaelSloan)
03:45:24 * hackagebot ClustalParser 1.0.1 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.0.1 (FlorianEggenhofer)
03:51:49 <scopevale> help
03:51:53 <scopevale> HELP
03:52:33 <RchrdB> scopevale: if you have a problem that you need help with, please just ask it and maybe someone will happen by who can answer it.
03:52:46 <sivteck> @help -- scopevale ?
03:52:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:53:04 <scopevale> no it's ok I'm just trying to suppress all the join/quit messages
03:53:25 <RchrdB> Haha okay. :)
03:54:03 <usermane> I suspect that I'm the #139843 person to ask this, but can someone help me understand monads?
03:55:03 <usermane> like, how important are they for using haskell? What sorts of stuff can they do that you can't do otherwise? What sorts of stuff can they do that you CAN do otherwise, but is still a pain to do without them?
03:56:07 <usermane> I understand that they don't make IO functions pure, but I don't really know what they are other than "some sort of conveyor belt thing".
03:56:12 <RchrdB> usermane: "You Could Have Invented Monads!" is my favourite of the many, many (unfortunately too many) monad tutorials on the internet. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:58:32 <pantsman> usermane: indeed they don't make IO pure, because IO values are already pure. But the IO monad instance does provide an interface for composing IO values in useful ways.
03:58:37 <usermane> ohhhh
03:58:42 <usermane> I think I understand it
03:58:48 <ddellacosta> wow, that was fast
03:58:54 <vermeille> RchrdB: do you speak french? I gave a talk on that
03:58:55 <hyPiRion> ddellacosta: my thoughts exactly
03:58:59 <usermane> keyword: Think.
03:59:08 <usermane> I'm just trying to think of a word where you redirect the flow of something
03:59:10 <RchrdB> vermeille: non, seulement un petit peut.
03:59:13 <ddellacosta> hyPiRion: :-)
03:59:39 <ddellacosta> usermane: if you are just digging into monads, I would caution you against trying to understand them "all at once"
03:59:41 <usermane> actually scrap that, I don't think I understand them
03:59:56 <usermane> how am I meant to go about understanding monads?
04:00:02 <hyPiRion> I don't know how many weeks I used on understanding monads. Had to properly understand and use functors, then applicatives before I could get there
04:00:06 <vermeille> RchrdB: okay, my advice is to go with the Typeclassopedia and forget that Monads are difficult, they're not
04:00:17 <RchrdB> vermeille: tell usermane, not me.
04:00:20 <ddellacosta> usermane: definitely what hyPiRion is saying is important ^
04:00:21 <usermane> can I just go try haskell, and ignore them for a while?
04:00:25 <ddellacosta> usermane: yes
04:00:26 <bernalex> usermane: sure
04:00:35 <RchrdB> usermane: yes, absolutely.
04:00:35 <zipper>  Uh what does assertBool do in HUnit?
04:00:36 <sgronblo> I felt like Monads were easier to understand than applicative
04:00:39 <bernalex> usermane: monads come with intuition. all they are really is a tiny set of operations.
04:00:40 <ddellacosta> usermane: you can do a *lot* in Haskell without getting them
04:00:52 <zipper> I really don't see how to do anything of value using it
04:01:01 <sgronblo> Because I couldn't figure out where and why you would get a Just function
04:01:13 <usermane> what's a Just function?
04:01:22 <tdammers_> zipper: you can do quite a lot without *understanding* monads
04:01:23 <sgronblo> A function inside a Just
04:01:26 <hyPiRion> usermane: a function within a Just
04:01:29 <tdammers_> zipper: even if you *use* them
04:01:31 <usermane> what's a Just?
04:01:33 <bernalex> zipper: what do you mean? it does what you'd expect
04:01:35 <hyPiRion> > Just 10
04:01:37 <lambdabot>  Just 10
04:01:39 <zipper> tdammers_: Ok
04:01:44 <tdammers_> :t Just 10
04:01:45 <lambdabot> Num a => Maybe a
04:01:47 <hyPiRion> that's a 10 inside a Just
04:01:50 <sgronblo> Anyway as soon as you think you understand monads some dude will tell you your understanding is wrong
04:01:59 <zipper> bernalex: I expected it to give me some sort of output
04:02:01 <sgronblo> Happens to me all the time
04:02:03 <ddellacosta> sgronblo: yes, hahaha...
04:02:08 <bernalex> zipper: assertBool is a Session ()
04:02:11 <pantsman> you don't need a deep understanding of monads, applicatives, etc, to use them effectively. For that you only need to know how to fit them together.
04:02:12 <zipper> It's return type is IO () aka Assertion
04:02:19 <hyPiRion> sgronblo: It doesn't really matter as long as you can use them and work with them though
04:02:22 <zipper> How can I know if I did anything with it
04:02:29 <usermane> is there a decent example of a simple application of monads?
04:02:32 <tdammers_> pantsman: "know how to fit them together" is really all they're about, in a way...
04:02:43 <hyPiRion> I mean, I don't think I can express how monads work
04:02:57 <sgronblo> For me the intuitive understanding is that Monads are computational contexts that can be combined from smaller parts to bigger and where the binding function allows for logic when connecting to the next "action".
04:03:25 <ddellacosta> usermane: I think you may actually be better off ignoring them for now.  I think the need to understand them is a bizarre cargo-culting kind of thing in the general developer community.
04:03:37 <usermane> what, APPROXIMATELY, is a monad? Is it approximately a fancy function, or is it approximately a fancy variable?
04:03:47 <tdammers_> usermane: a fancy type
04:03:51 <vermeille> usermane: if you speak french I gave on talk on that
04:03:53 <ddellacosta> usermane: I mean, I don't say that to discourage you, just that you'd be better off taking it slowly, going through a bunch of tutorials, and dealing with them when they come up
04:03:54 <tdammers_> usermane: no, not fancy, even
04:04:02 <bezirg> hi, does anybody know of a helper library in hackage for URL normalization?
04:04:08 <tdammers_> usermane: a Monad is a type that implements >>= and return
04:04:13 <pantsman> it's approximately an interface, if you're familiar with the concept from Java, C# etc
04:04:17 <bernalex> zipper: here's a simple webdev example of how it's useful: assertStatus :: Int -> SResponse -> Session (); assertStatus c r = assertBool msg $ c == status where msg = "expected " ++ show c ++ "\nbut received " ++ show status; status = statusCode $ simpleStatus r
04:04:26 <tdammers_> usermane: (and, technically, fail)
04:04:40 <usermane> >>=?
04:04:48 <tdammers_> the monadic "bind" operator
04:04:53 <bernalex> zipper: you might need liftIO .: assertBool depending on what you're doing there but
04:04:55 <simon> pantsman, aren't you talking about type classes now?
04:05:00 <tdammers_> >>= is the most important thing about monads
04:05:02 <Maxdamantus> tdammers_: what is the monad's type with 'putStrLn'?
04:05:10 <tdammers_> Maxdamantus: IO ()
04:05:13 <tdammers_> Maxdamantus: IO is the monad
04:05:17 <tdammers_> Maxdamantus: IO () is the value
04:05:28 <tdammers_> eh... the value's *type*
04:05:32 <pantsman> simon: yes
04:05:41 <tdammers_> also, String -> IO () really
04:05:58 <Maxdamantus> so when you say a monad is a fancy type ..?
04:06:20 <simon> pantsman, good - I misinterpreted your statement then. :)
04:06:24 <sivteck> :t fmap
04:06:25 <sivteck> :t (<*>)
04:06:25 <sivteck> :t (=<<)
04:06:25 <sivteck> just ways to apply funny functions to things inside cotexts
04:06:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:06:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:06:26 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:06:40 <bernalex> Maxdamantus: monad is just an interface really. it abstracts away computational contexts by implementing the bind function, which lets us chain and compose values related to a computational context.
04:06:46 <pantsman> simon, yes, I see how it could be misread. I meant, an example of an interface.
04:07:12 <bernalex> Maxdamantus: have you used lists comprehensions in haskell?
04:07:35 <Maxdamantus> bernalex: I'm not actually asking what monads are.
04:07:48 <Maxdamantus> just questioning tdammers_' description.
04:08:00 <usermane> what does the bind operator do?
04:08:07 <tdammers_> Maxdamantus: which part are you questioning?
04:08:22 <Maxdamantus> tdammers_: the monad being a type.
04:08:53 <usermane> keywords: approximately, fancy
04:09:11 <usermane> as in "monad is APPROXIMATELY a fancy type"
04:09:17 <tdammers_> Monad is a typeclass. Monads are types that implement this typeclass.
04:09:20 <bernalex> usermane: m a -> m b via (a -> m b). what this means is that if you have e.g. a Foo String, you can give it to a function that takes any String, not a Foo String specifically, and get a Foo String back.
04:09:29 <Maxdamantus> I think someone needs to just create a concise definition of what "the monad" is.
04:09:46 <tdammers_> The type is the monad.
04:10:04 <Maxdamantus> It should be the collection of functions (return, (>>=)) associated with the type constructor (IO)
04:10:06 <bernalex> usermane: consider putStrLn. this prints a String. now consider getLine -- this is an IO String, so its type does not match that of putStrLn! oh no! what do we do? well we use bind.
04:10:10 <usermane> what's a Foo String? In C syntax, would that be (Foo, String), or would it be something that inherits from String?
04:10:24 <Maxdamantus> not the type constructor itself.
04:10:25 <bernalex> usermane: "putStrLn getLine" won't work, so we need to "putStrLn =<< getLine". :-]
04:10:32 <bernalex> usermane: neither, hehe
04:10:46 <bernalex> usermane: Foo, or IO, or lists ([]), or Maybe, and so on are type constructors
04:10:52 <bernalex> usermane: do you know Maybe?
04:10:56 <Maxdamantus> that's why it makes sense to say "the IO monad" and "the list monad"
04:11:01 <usermane> Oh crap, I should probably warn you that I haven't actually written any haskell, I've just read and thought about it a bunch.
04:11:04 <pantsman> usermane: more like Foo<String>
04:11:13 <bernalex> usermane: right, OK. so let's take a super simple monad called Maybe
04:11:26 <bernalex> usermane: a Maybe value is either "Just a" or "Nothing". this means you either have something, or you have nothing.
04:11:36 <bernalex> usermane: so you can have Just 3, which would be just the number 3, for instance
04:11:41 <bernalex> usermane: this would then be a Maybe Int
04:12:05 <bernalex> usermane: Maybe by itself is not very meaningful. you can't have a value of type just Maybe. it must be a Maybe Int, or Maybe String, and so on. does that makes sense?
04:12:16 <usermane> what exactly is the difference between "Just 3", and "3"?
04:12:17 <tdammers_> Maxdamantus: the type is the monad. The type. Not the type constructor.
04:12:50 <tdammers_> Maxdamantus: And the fact that the type implements the Monad typeclass guarantees that it can be used as a monad, i.e., it supports >>=, return, and fail.
04:12:54 <bernalex> usermane: "Just 3" is a Maybe Int, 3 is a regular Int. the point of Maybe is when you have functions that will act differently to having a value and not having a value. consider naïve error handling.
04:13:19 <bernalex> usermane: so a C programmer might say that the Int is "-1", and that means something went wrong. with the Maybe Int type, we could use Nothing instead
04:13:36 <usermane> bernalex: So it's basically an Int, except it could alternatively have the value of null?
04:13:46 <bernalex> usermane: Nothing, not null, but yes. :-]
04:13:47 <usermane> instead of being a number
04:13:51 <bernalex> yep!
04:14:05 <bernalex> usermane: in this case both Nothing and Just 3 would have the type "Maybe Int"
04:14:29 <usermane> holy crap, I've wanted Maybe Stuff for AGES.
04:14:47 <bernalex> usermane: and what is a monad then? basically anything like this, where you have some context, and a way to a) put something into the context -- and b) a way to apply a function that does not care about your context to your value with context
04:15:12 <tdammers_> *cough*list monad*cough*
04:15:25 <bernalex> usermane: let's say you have a function called add3. add3 adds 3 to any integer. this will not typecheck: add3 (Just 2). why? because Just 2 is a Maybe Int, not just an Int.
04:15:27 <tdammers_> the intuition breaks a bit on those
04:15:49 <usermane> wait, I need to go re-read the part where "Just 3" and "3" are relevant.
04:16:30 <bernalex> usermane: but there's a functon to the rescue! we can do "fmap add3 (Just 3)", which then lets us apply add3 to Just 3. :-] this is not strictly speaking about monads anymore, but the intuition I want you to have is that monads is just an interface/abstraction. there are plenty of them. you'll grok them eventually by intuition. :-]
04:17:15 <Maxdamantus> tdammers_: so there's an infinite number of IO monads?
04:17:17 <usermane> so, is "3" a "Maybe 3", or a "Just 3"? I'm assuming that "Maybe 3" and "Just 3" are direct opposites, and it has to be one xor the other.
04:17:18 <bernalex> tdammers_: well pedagogy is just a series ov simplifications
04:17:24 <bernalex> Maxdamantus: that question does not make sense.
04:17:24 <tdammers_> Maxdamantus: no. IO is just one type.
04:17:28 <honnza> @pl \tbl xs ys -> [[f x y]|y<-ys]|x<-xs]
04:17:29 <lambdabot> (line 1, column 36):
04:17:29 <lambdabot> unexpected ']'
04:17:29 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
04:17:34 <Maxdamantus> tdammers_: eg, IO (), IO ((), ())
04:17:37 <bernalex> usermane: 3 is just an Int.
04:17:46 <usermane> oh right
04:17:51 <Maxdamantus> bernalex: I think it makes sense in response to: 00:14:21 < tdammers_> Maxdamantus: the type is the monad. The type. Not the type constructor.
04:17:52 <bernalex> usermane: Maybe has two constructors. Just *something* or Nothing
04:18:04 <bernalex> usermane: Nothing would be a Maybe Int, and Just 3 would also be a Maybe Int.
04:18:07 <tdammers_> Maxdamantus: by the same logic, there are infinitely many Maybe types
04:18:17 <bernalex> usermane: recall my add3 function that we applied to Just 3? you could indeed apply it to Nothing too!
04:18:24 <Maxdamantus> tdammers_: there are infinitely many types constructable using the Maybe constructor.
04:18:27 <usermane> no, I don't recall your add3 function
04:18:30 <bernalex> usermane: fmap add3 Nothing. what is the result of this? well... 3 + Nothing... why, it's Nothing!
04:18:34 <bernalex> usermane: OK
04:18:49 <bernalex> usermane: add3 :: Int -> Int; add3 x = x + 3. you on board? it just adds 3 to an Int.
04:18:56 <usermane> you need to slow your explanation down, because I still don't have the whole "Maybe/Just" thing figured out entirely.
04:19:15 <tdammers_> Maxdamantus: IO and Maybe are both polymorphic, if that's what you're getting at
04:19:16 <profil> bernalex: couldnt you lift the add3 function instead of using fmap?
04:19:19 <Maxdamantus> tdammers_: so you're distinguishing between "IO" as a type, and what as a type constructor?
04:19:33 <artafan> hi all
04:19:38 <tdammers_> Maxdamantus: we're really only discussing types here. IO doesn't even expose any constructors at all
04:19:45 <bernalex> profil: that doesn't really matter, but yes you could.
04:19:49 <Maxdamantus> IO is a type constructor.
04:20:01 <artafan> can one correct me following snetence: Functional programming has broad application  both in industry and in science.
04:20:02 <tdammers_> oh, that way
04:20:03 <Maxdamantus> ie, something of kind _ -> *
04:20:08 <bernalex> profil: liftM add3 (Just 3) for instance would work fine.
04:20:09 <tdammers_> * -> *, yes
04:20:17 <tdammers_> it's still just one monad
04:20:28 <tdammers_> the type is IO, not IO ()
04:20:32 <profil> bernalex: ok, I was just checking if I understood the liftM functions :)
04:20:46 <bernalex> artafan: correct what?
04:20:51 <tdammers_> IO () is the type of an action in the IO monad. It is not the IO monad itself.
04:21:02 <artafan> wether it is written clearly in english :)
04:21:16 <Maxdamantus> The monad is the thing you define when you write `class Monad IO where ..`
04:21:20 <bernalex> artafan: looks fine to me.
04:21:21 <usermane> So, there's Ints. They have number values, like "5". There's Maybe Ints, which could be "5" et al, or they could be Nothing.
04:21:31 <artafan> thx
04:21:43 <artafan> or
04:21:45 <usermane> And "Just 5" is "5" of "Maybe Int" type, rather than "Int" type.
04:21:46 <bernalex> usermane: 5 is an Int. Maybe Ints would have to be Just 5 or Nothing.
04:21:48 <Maxdamantus> er, `instance Monad IO where ..`
04:22:19 <usermane> oh, so the "Just" is like how floats are 0.5f, and doubles are 0.5?
04:22:28 <Maxdamantus> that doesn't create a type.
04:22:30 <usermane> in C-style, I mean
04:22:46 <tdammers_> Maxdamantus: IO is the monad; the typeclass instance is what you use to tell the compiler about it
04:22:49 <usermane> so, "Just 5" isn't a literal value?
04:22:52 <bernalex> usermane: "Just" is a data constructor. so is Nothing. "Just 2" is a value of Maybe Int.
04:22:57 <bernalex> usermane: it is a literal, actually.
04:23:13 <bernalex> usermane: Just 5 is a regular literal of type Maybe Int, just like 5 is a regular literal of type Int.
04:23:21 <tdammers_> data Foo a = Foo a -- defines a type
04:23:33 <tdammers_> instance Monad Foo where ... -- turns it into a monad
04:23:40 <profil> @src Maybe
04:23:40 <lambdabot> data Maybe a = Nothing | Just a
04:23:46 <Maxdamantus> tdammers_: it sounds like you're assuming there is always at most one possible monad for a type constructor.
04:23:49 <bernalex> usermane: BTW you might find this tiny article that explains monads in pictures useful: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
04:24:06 <tdammers_> Maxdamantus: limitation of the language, but yes
04:24:22 <tdammers_> Maxdamantus: if you want more than one Monad instance for a given type, you need newtypes or some such
04:24:41 <Maxdamantus> tdammers_: no, inherent in what the type represents.
04:24:42 <tdammers_> Maxdamantus: this isn't specific to monads though; the same problem goes for other typeclasses, e.g. Monoid
04:24:55 <tdammers_> Maxdamantus: it's a mismatch between CT and what Haskell can represent
04:25:26 <tdammers_> Maxdamantus: for example, both (Integer, *, 1) and (Integer, +, 0) are monoids
04:25:38 <bernalex> ah, you mean how e.g. ints can form several monoids in haskell?
04:25:46 <bernalex> yeah that's a lang restriction
04:25:54 <tdammers_> Maxdamantus: but Haskell links the typeclass to the type only, not to the complete monoid
04:26:00 <Maxdamantus> But the language restriction is irrelevant.
04:26:10 <tdammers_> Maxdamantus: it's not
04:26:44 <tdammers_> Maxdamantus: conceptually, you are right - Monad is the combination of the type, bind, return, and fail
04:26:57 <tdammers_> Maxdamantus: but in Haskell, the type alone is what is used to declare the monad
04:27:00 <Maxdamantus> You couldn't say "the integer monoid" because, as you point out, there are at least two possible monoids you can come up with using integers.
04:27:21 <Maxdamantus> You can say the same thing about monads.
04:27:21 <tdammers_> Maxdamantus: indeed, but in Haskell, you can only have one instance of a given typeclass per type
04:27:33 <tdammers_> so yes, IO could be part of several monads
04:27:38 <tdammers_> but in Haskell, you have to pick one
04:27:43 <tdammers_> and make separate types for the others
04:27:51 <Maxdamantus> Right, so you're not deriving the monad from the type.
04:28:00 <bernalex> Maxdamantus: the lang doesn't really talk about "the IO monad" or "the integer monoid". we just say that IO is an instance of monad, etc.
04:28:05 <profil> is there a way to retreive the source just like lambdabot handles @src in ghci?
04:28:09 <yezhaoliang> hi
04:28:13 <profil> @src Maybe fmap
04:28:13 <lambdabot> fmap _ Nothing  = Nothing
04:28:13 <lambdabot> fmap f (Just a) = Just (f a)
04:28:17 <usermane> okay, so the whole "wrapping" thing explains a lot. That said, the word "Functor" makes me feel like I'm back learning programming for the first time, except moreso.
04:28:19 <Maxdamantus> You might be able to derive an fmap from a particular type definition.
04:28:31 <usermane> also, fmap, typeclass
04:29:01 <yezhaoliang> When I use the cabal sandbox init in the shell , some error occurs "Cabal: unrecognised command :sandbox"
04:29:23 <yezhaoliang> Do anybody bump into the problem?
04:29:26 <usermane> "typeclass" sounds like it has to do with how "double" and "float" are related, how "short" and "int" are related, and how all four are also related.
04:29:28 <bernalex> usermane: don't fear the terminology! unlike OOP, all of it has *very* clear denotation that you *will* learn and get used to eventually. and there's no rush, as you tend to pick up all of this naturally. no need to "study" like you're going to get a test. :-]
04:29:40 <bernalex> usermane: you're kind of right.
04:29:47 <bernalex> usermane: Int, Double and so on are all part of a typeclass named Num
04:29:59 <sivteck> yezhaoliang, sandbox feature is present only in cabal >= 1.18
04:30:06 <bernalex> usermane: this lets us write functions like (+), which works on Nums rather than only Doubles or Ints.
04:30:31 <tdammers_> Maxdamantus: you're not deriving monads at all. You are declaring them.
04:30:38 <bernalex> usermane: so instead of addFloat :: Float -> Float -> Float, and addInt :: Int -> Int -> Int, we just have a + b = a + b, and (+) :: Num a => a -> a -> a.
04:30:41 <usermane> bernalex: And there's also a typeclass called "Real" that doesn't apply to Int or Integer, but applies to Double, right?
04:30:41 <Maxdamantus> tdammers_: you're defining them.
04:30:45 <sivteck> yezhaoliang, you must have an older version
04:30:51 <bernalex> usermane: that latter typesignature might look weird, but it's just saying that "a must be an instance of Num".
04:30:54 <tdammers_> Maxdamantus: the difference being?
04:30:56 <bernalex> usermane: yes.
04:30:59 <tdammers_> anyway
04:31:01 <yezhaoliang> I have tried "cabal install cabal "  to install  cabal1.20...  But I don;t know how to change to the version Cabal 1.20 .
04:31:09 <bernalex> usermane: this is very useful for writing polymorphic code, as you might imagine.
04:31:14 <Maxdamantus> tdammers_: it's an invention of the programmer.
04:31:17 <tdammers_> the discrepancy between the CT concept of a monad and Haskell's Monad typeclass *is* important
04:31:39 <sivteck> yezhaoliang, cabal-install* sorry
04:31:46 <Maxdamantus> tdammers_: in a way that `fmap` isn't—you can only come up with at most one valid `Functor` definition for some type constructor.
04:32:14 <tdammers_> Maxdamantus: yes, sure... but that's more like a lucky coincidence
04:32:21 <Maxdamantus> tdammers_: so in some sense, you're declaring that something is a Functor and you're telling Haskell what `fmap`'s definition could be.
04:32:32 <usermane> bernalex: and template/generics would probably be obsolete, too.
04:32:33 <tdammers_> yes
04:32:40 <tdammers_> and the same goes for Monad
04:32:48 <tdammers_> except that for Functor, you don't have much of a choice
04:33:16 <bernalex> usermane: generics in Java were put there by the guy who made typeclasses in haskell. they try to cover some of the same things. templates are a bit more complex than that again, but yes to some extent they overlap.
04:33:29 <Maxdamantus> if you have a choice, you're not just declaring that it's there. You're picking one.
04:33:29 <tdammers_> but that's kind of beyond the realm of the language itself
04:33:50 <bernalex> usermane: it is, if I do say so myself, a world of pain to work in templates, and very limiting to use generics, if you know typeclasses. that's my experience at least.
04:34:00 <tdammers_> the compiler doesn't know about Monad or Functor laws though
04:34:33 <tdammers_> I could implement a Functor instance for Maybe that violates the functor laws, and it would typecheck and all
04:34:45 <tdammers_> the language doesn't differentiate at this level
04:35:07 <tdammers_> so I don't see why we should use different verbs for declaring/defining a Monad instance and a Functor instance
04:35:07 <bernalex> you can also implement an instance of Functor or Monad that doesn't even violate the laws. case in point: IO. :-]
04:35:29 <Maxdamantus> Yes. It's not an issue with the language.
04:35:51 <n4x> dependant types solve that problem! >:P
04:36:07 <yezhaoliang> when I type cabal --version ,the shell tell me " cabal-install version 1.16.0.2 using version 1.16.0 of the Cabal library"  But I typed " $ cabal install cabal Resolving dependencies... All the requested packages are already installed: Cabal-1.20.0.2 Use --reinstall if you want to reinstall anyway."
04:36:16 <bernalex> n4x: -XDependentTypes ftw
04:36:25 <yezhaoliang> How can I change version from 1.6 to 2.0 cabal
04:40:30 * hackagebot casadi-bindings-core 2.1.3.0 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-2.1.3.0 (GregHorn)
04:40:32 * hackagebot casadi-bindings 2.1.3.0 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.1.3.0 (GregHorn)
04:40:42 <japesinator> cabal keeps throwing me a weird error when I try to install text-1.1.1.3
04:40:55 <japesinator> fatal error: too many errors emitted, stopping now [-ferror-limit]
04:41:03 <japesinator> fatal error: too many errors emitted, stopping now [-ferror-limit=]
04:41:11 <japesinator> what am I doing wrong?
04:41:14 <usermane> what are contexts, generally? Maybe Int can't be the only context.
04:41:38 <bernalex> usermane: context usually means a typeclass
04:41:38 <usermane> japesinator: Well for starters, you're emitting too many errors.
04:41:58 <bernalex> usermane: Num a => a -> a -> a. here we say that a is constrained by a Num context.
04:42:06 <bernalex> usermane: that is, a must be a type that is an instance of Num.
04:42:17 <japesinator> usermane: thanks! I'll just rewrite text really quickly and be on my merry way!
04:42:39 <bernalex> usermane: you might be thinking of computational contexts though?
04:42:50 <bernalex> usermane: or, the m-word. ;-)
04:43:16 <usermane> bernalex: what exactly does "Num a=>a->a->a" do?
04:43:19 <bernalex> usermane: well. there's a bunch of them. I picked Maybe Int because it's kind of easy to explain. there's also the list -- [Int], and IO Int, etc.
04:43:21 <usermane> bernalex: m-word.
04:43:23 <bernalex> usermane: sorry. it is a type signature.
04:43:30 <bernalex> usermane: in haskell functions have type signatures.
04:43:34 <bernalex> f :: Int -> Int
04:43:37 <bernalex> f x = x
04:43:39 <sivteck> yezhaoliang, cabal install cabal-install (you need newer cabal-install, you already have the latest Cabal)
04:43:52 <usermane> i.e. what the arguments are and what the return value is.
04:43:53 <bernalex> usermane: the top line there is f's type. it says that f takes an Int and returns an Int
04:44:05 <bernalex> usermane: so here's one with that weird => operator
04:44:11 <bernalex> f :: Num a => a -> a
04:44:13 <bernalex> f x = x
04:44:50 <bernalex> usermane: that's the same function, but here it is from "a" to "a". "a" is a type. it can be any type! but by saying Num a =>, we say that it must be an instance of Num
04:44:54 <usermane> no, the "=>" part makes sense. But I'm trying to guess what it does, and I'm assuming it takes a, then returns an a, then returns and a, then returns an a.
04:45:17 <bernalex> usermane: a simple intuition is this
04:45:18 <usermane> actually, I have no clue what the => actually does
04:45:21 <bernalex> f :: a -> a -> a -> a
04:45:31 * hackagebot sgd 0.3.6 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.6 (JakubWaszczuk)
04:45:33 <bernalex> f takes three arguments of type a, and returns a result of type a.
04:46:03 <bernalex> usermane: :-] "Num a => a" is very simple. it just means "a must be an instance of Num". so it must be e.g. an Int or a Double, or something else that's an instance of Num.
04:46:46 <usermane> I would have expected that to be f :: a a a -> a, if it took 3 and returned one. Something to do with currying?
04:47:05 <bernalex> usermane: do you know currying?
04:47:09 <sgronblo> yeah its because of currying
04:47:11 <usermane> I have no clue what currying is, but I know it's something to do with passing a function with an argument into a function
04:47:23 <sgronblo> thats not it
04:47:25 <Maxdamantus> Yay infinite kinds.
04:47:28 <bernalex> usermane: a -> a -> a -- this really means that we have a function that takes an a, and then returns a function that takes another a and returns an a.
04:47:35 <usermane> like I said, no clue what currying is
04:47:37 <sgronblo> its about having only single parameter functions
04:47:54 <bernalex> usermane: I think you shouldn't worry about it for now. :-]
04:48:24 <bernalex> usermane: just know that "under the hood" all functions take and return exactly one value. but intuitively "a -> a -> a" can be viewed as something that takes two values and returns one value.
04:48:42 <usermane> wait, why a->a->a->a? So it's basically a->(a->a)?
04:48:48 <Maxdamantus> `a -> a -> a` is the same as `a -> (a -> a)`
04:48:49 <Maxdamantus> Yes.
04:48:50 <bernalex> yes, that's the associativity
04:49:07 <usermane> when you say they "take and return one value", is that "one value" just all the values duct-taped together?
04:49:17 <bernalex> no
04:49:22 <bernalex> I mean like in maths :-]
04:49:27 <bernalex> every function is a mapping from a domain to a range.
04:49:36 <Maxdamantus> and a function is a value.
04:49:45 <Maxdamantus> so it can be returned by another function
04:49:52 <usermane> this is definitely currying country.
04:50:22 <usermane> well, probably.
04:50:31 * hackagebot crf-chain1-constrained 0.3.1 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.3.1 (JakubWaszczuk)
04:50:32 <bernalex> usermane: currying just kind of means that "f a b = e" is really "f = \a -> \b -> e". if you don't understand this... then don't worry about it. you should learn the basics of the language before you care about that stuff. :-]
04:50:42 <usermane> "definite" is for people who knows what they're talking about.
04:50:50 <bernalex> basic syntax is more important than how currying goes on under the hoode.
04:50:57 <yezhaoliang> Yes, I have install the cabal-install "$ cabal install cabal-install Resolving dependencies... Configuring cabal-install-1.20.0.3... Building cabal-install-1.20.0.3... Preprocessing executable 'cabal' ForNeVeR " What I should do next?
04:50:57 <usermane> s/knows/know/
04:52:26 <bernalex> s/\(hood\)e/\1/ :-]
04:52:28 <sivteck> yezhaoliang, what do you mean `ForNeVeR` ?
04:55:30 <yezhaoliang> sivteck,  Installing executable(s) in /home/fluidman/.cabal/bin Installed cabal-install-1.20.0.3,  so I cd /home/fluidman/.cabal/bin  ,then ./cabal --version  -----> cabal 1.20  and then I can use the cabal sandbox
04:55:32 * hackagebot crf-chain2-tiers 0.2.2 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.2.2 (JakubWaszczuk)
04:55:34 * hackagebot concraft 0.9.3 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.9.3 (JakubWaszczuk)
04:55:36 * hackagebot concraft-pl 0.7.3 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.7.3 (JakubWaszczuk)
04:56:26 <yezhaoliang> But I have two version cabal in my system ,how can I default the cabal as cabal1.20 rather than cabal1.16
04:58:45 <sivteck> you have 1.20 locally, idk how to change that globally ;/
05:00:44 <sivteck> yezhaoliang, time to get new ghc and cabal! (i guess)
05:02:00 <yezhaoliang> Ok ,sivteck. Before, I apt-get install  haskell-platform, the default version of the cabal is 1.16.0.2
05:06:31 <sivteck> yezhaoliang, yes, your distro might not have the newer version, for now add that bin in your path(call it evilcabal?) or nuke haskell platform and install from this ppa(according to your distro) <https://github.com/bitemyapp/learnhaskell#debian>
05:07:18 <sivteck> there's seperate instructions in that link for ubuntu if you are using it
05:08:56 <yezhaoliang> Ok ,syvteck.Thank you for your sharing.Testing
05:09:47 <yezhaoliang> Is bitemyapp your github account ?
05:10:02 <Total_1mmersion> Is there a way to only typecheck a cabal project, instead of fully building?
05:10:06 <sivteck> nope! it't bitemyapp's
05:10:07 <zwer_v> usermane in practice currying lets us easily create functions on the fly with minimal syntax. (+) is a function that takes two ints and adds them together. if we apply one argument to (+), for example (+1), we get a function that accepts a number and adds 1 to it
05:10:55 <Cale> Though, (+1) is perhaps not the greatest example, since it's syntax sugar for (\x -> x + 1) ;)
05:10:57 <dcoutts_> Total_1mmersion: you can configure with -O0 for a quicker build
05:11:10 <dcoutts_> Total_1mmersion: and if you use cabal repl, you'll get very fast recompiles within ghci
05:11:19 <Cale> (1 +) is an example though :)
05:12:07 <Cale> > map (map (*2)) [[1,2,3],[4,5],[6,7,8]] -- I like this example
05:12:09 <lambdabot>  [[2,4,6],[8,10],[12,14,16]]
05:12:51 <Total_1mmersion> dcoutts_: Good suggestions, but I really only want to see type errors. I'm trying to set up the ruby gem "guard" to basically do ghc -e ""
05:13:53 <dcoutts_> Total_1mmersion: there's a ghc flag to not generate code, but cabal will still try to link and fail at that point, so that will not entirely work
05:14:14 <dcoutts_> Total_1mmersion: to do properly, it needs a little cabal feature, to cabal build --check
05:14:43 <dcoutts_> Total_1mmersion: and note that it's not always possible to avoid generating code, e.g. with Template Haskell
05:15:28 <batchm> any tips on how to remember what evalState execState and runState are? I always forget after not using State for a couple of weeks
05:15:45 <batchm> I easily mix them up
05:15:59 <Total_1mmersion> dcoutts_: ok, thanks for the information.
05:16:21 <batchm> I wish it was named something like: evalState evalValue evalStateValue
05:25:28 <Fuco> how can I export everything plus reexport a module I import?
05:26:07 <Fuco> I want something like "module foo ((..), module bar) where", where (..) should mean "export everything defined in this module".. but obviously that's not the right syntax
05:30:10 <triliyn> Fuco: I think that would be "module Foo (module Foo, module Bar) where"
05:30:46 <Fuco> triliyn: works, awesome!
05:31:04 <Fuco> quite obvious now that I know it :D
05:34:19 <triliyn> batchm: eval gives you the "result" of the state (the "a" in "m a"), exec runs the state for side effects and gives you the final state, and run unwraps the StateT constructor and gives you the tuple of state and value
05:35:55 <triliyn> So you can kind of think of it as "eval is analogous to haskell evaluation (for the purpose of producing a final value), and exec is analogous to haskell execution (for side effects)"
05:36:07 <triliyn> And then run is just the other one
05:56:15 <japesinator> when I run 'cabal instal text-1.1.1.3' on OS X I get 'fatal error: too many errors emitted, stopping now [-ferror-limit=]'
05:56:21 <japesinator> how can I fix this?
05:56:24 <absence> is there a general way to express mapMaybe, along the same lines that concat is join and concatMap is \f -> join . fmap f?
05:58:20 <ClaudiusMaximus> :t [fmap, mapMaybe]
05:58:21 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ Maybe b
05:58:21 <lambdabot>     Expected type: (a -> Maybe b) -> [a] -> [Maybe b]
05:58:21 <lambdabot>       Actual type: (a -> Maybe b) -> [a] -> [b]
06:01:59 <simon> absence, there is Control.Monad.Plus.mmapMaybe
06:02:31 <ciaranm> i Just met you, and this is crazy, but here's my Num, mmapMaybe
06:03:16 <simon> ciaranm, the missing syllable to complete the song.
06:04:45 <simon> absence, mapMaybe f = (>>= maybe mzero return) . liftM f
06:08:50 <absence> ciaranm :D
06:08:56 <absence> simon: cool, thanks
06:13:04 <japesinator> what exactly does --flags= in cabal pass the flags to?
06:13:17 <yesthisisuser> Is there something equivalent to sequence in Prelude for tuples? i.e., (f a, f b) -> f (a, b)
06:13:41 <dcoutts_> japesinator: to the dep solver, and ultimately to the individual package(s) when configuring them
06:14:11 <japesinator> oh OK
06:14:32 <japesinator> so if I want to change the -ferror-max used when compiling, how can I do that?
06:14:56 <dibblego> @type uncurry (liftA2 (,)) -- yesthisisuser
06:14:57 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
06:15:41 * hackagebot hasql-backend 0.1.0 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.1.0 (NikitaVolkov)
06:16:55 <yesthisisuser> dibblego: nice. thanks :)
06:20:41 * hackagebot hasql 0.1.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.0 (NikitaVolkov)
06:29:25 <Fuco> so, c2hs gives me "There is not automatic support for marshaling of structures" ... so I'd need to figure out the offset in the C struct and do pointer arithmetics. But that is platform dependent. How can I do it safely?
06:29:43 <Fuco> my struct contains another struct in itself, which causes the problem I think
06:30:42 * hackagebot haddocset 0.3.0 - Generate docset of Dash by Haddock haskell documentation tool  http://hackage.haskell.org/package/haddocset-0.3.0 (HirotomoMoriwaki)
06:31:21 <alanoth> I'm looking for help related to the google summer of code. Is there anyone who can help me?
06:31:50 <wei2912> alanoth: don't ask to ask, just ask
06:32:17 <alanoth> I made a ticket, if anyone could take a look at me and tell me what I need to complete it
06:32:21 <alanoth> https://ghc.haskell.org/trac/summer-of-code/ticket/1638
06:33:06 <alanoth> *look at it
06:33:47 <alanoth> wei2912: I want to know how difficult it will be, and what I need to learn to complete it
06:33:59 <mT37m> I want to write an interpreter in Haskell and I want to make it as generic as possible, maybe run it with GHCJS. What's the best way to design the function that accepts the AST and runs the code? Should it run in an arbitrary user-defined monad (to allow pausing)? Also, what's the best way to give the user control of input and output? Some pointers to related code would be awesome.
06:34:24 <japesinator> mT37m: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:35:46 <armlesshobo> LOL
06:36:03 <armlesshobo> it will only take you 48hrs because you'll off yourself by that time.
06:36:12 <alanoth> Will anyone take a look at https://ghc.haskell.org/trac/summer-of-code/ticket/1638 please. I want to know about the pre-requisites
06:37:17 <rgr> how do I interpret/convert an IO Bool returned form doesFileExist(filename)  to a Bool I can use in an "if then else"? Im not a haskell programmer and was trying to modularise my xmonad set up a little. Hopefully this clip will show what I mean : https://gist.github.com/rileyrg/ffb147449aa1e6de8620
06:37:26 <japesinator> mT37m: you also may want to look at https://github.com/ekmett/trifecta for a different approach than [atto]parsec offers
06:37:44 <rgr> (useWicd is the offender)
06:37:46 <narendraj9> alanoth: I am also interested in doing google summer of code because I think it will be a great opportunity to do a real haskell project for months. I emailed Edward Kmett but hasn't got any replies. I think I should have talked to him on IRC. It's completely my fault because the
06:37:53 <narendraj9> email was too vague.
06:38:24 <alanoth> narendraj9: Excitement does result in vagueness sometimes. I know that feeling :)
06:38:33 <narendraj9> alanoth:
06:38:49 <narendraj9> alanoth: Can diagrams do what you are trying to achieve?
06:39:28 <alanoth> Maybe, but there's the plot library which already creates plots. I may be better off patching it
06:39:57 <alanoth> But I don't have any idea as to how to do it now.
06:40:04 <alanoth> I will need to learn more
06:40:33 <bernalex> how are you supposed to get/use length of a Foldable? why is it not a visible function?
06:40:40 <alanoth> narendraj9: What about you? What are you trying to do?
06:40:43 * hackagebot hasql-postgres 0.1.0 - A "PostgreSQL" driver for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.1.0 (NikitaVolkov)
06:41:07 <mT37m> armlesshobo: what's so bad about the thing?
06:41:22 <armlesshobo> ((((((((((((((((((((nothing))))))))))))))))))))
06:41:31 <narendraj9> I have never used diagrams but that's the only thing that's coming to my mind right now. http://projects.haskell.org/diagrams/ And this channel isn't for gsoc. So, we should not talk much about what isn't Haskell here. pm?
06:41:34 <chirpsalot> I'm using Cassava to parse some CSV grade sheet. So I have something like this: http://lpaste.net/1789008342987833344
06:41:53 <chirpsalot> But, what if I want to change the name of the assignment field at runtime?
06:42:05 <chirpsalot> E.g., in a command line argument?
06:42:10 <alanoth> narendraj9: pm me at sumit.sahrawat.apm13@iitbhu.ac.in
06:44:00 <alanoth> narendraj9: will be waiting for contact. Bye :)
06:44:04 <chirpsalot> I think this might be impossible without some IO?
06:44:13 <chirpsalot> unsafePerformIO, that is.
06:45:05 <chirpsalot> Or dependent types.
06:51:34 <rgr> trying to gifure out how to use Bool from IO Bool I keep finding this link http://www.haskell.org/hawiki/ThatAnnoyingIoType - not exsiting anymore. Can someone recommend a replacement please that doesnt involve me spending several weeks learning Haskell in detail.
06:52:59 <chirpsalot> rgr: do exists <- doesFileExist filename; if exists then undefined else undefined
07:00:45 * hackagebot Unique 0.1.0.3 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.1.0.3 (kapral)
07:05:14 <rgr> chirpsalot: yes thanks. I had that in one form but I wanted to convert my block to this form - https://gist.github.com/e4a8c379429665b05a03 but useWicd isnt in scope in the where. I trued to substitute with a let in the usage of useWicd but that fails me too. Im not familiar enough to know how I need to restructure to do what i want. But Im sure its not far off.
07:05:32 <rgr> (sure == baseless hoping)
07:05:46 * hackagebot tasty 0.10.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.1 (RomanCheplyaka)
07:06:04 <Fuuzetsu> narendraj9: there's #haskell-gsoc
07:08:11 <narendraj9> Fuuzetsu: thanks :-)
07:15:31 <absence> (!! 5) <$> sequence (repeat (putStrLn "hello")) <- this prints hello forever because >>= in IO is strict so the list must finish before sequence can return. is there a clever way to work around this? replicateM won't work because i need to do several lookups (except if i figure out the max value to look up first, but that complicates things a bit)
07:16:24 <aleator__> How about leaving the sequence out, picking the action with !! and then executing that?
07:18:50 <absence> aleator__: yes, i should perhaps have mentioned that each action depends on the previous ones having been executed :)
07:19:22 <Fuuzetsu> take 5 then sequence
07:20:44 <aleator__> absence: Do you really have !! 5 there? Or something that discards results until it finds what it likes?
07:21:55 <absence> Fuuzetsu: hm, and then keep track of how many has been taken, so that when 8 is looked up after 5 it takes 3 more? that could work
07:22:20 <Fuuzetsu> well, you never said anything about there being more &c
07:22:29 <aleator__> absence: Check out Control.Monad.Loops. Something like untilM or firstM might also help
07:23:53 <absence> aleator__: it doesn't have to be !! but there will be requests for the result of action n (by index)
07:25:30 <mmmm_> absence: can you provide a more fleshed out example?
07:25:43 <mmmm_> the example you give has the same result for whatever k you choose
07:27:10 <absence> mmmm_: ok. instead of putStrLn the action reads a section of a file. i don't know how many sections the file contains, so i can't read all of them, i just have to trust the incoming indices that ask for "section n"
07:28:33 <absence> mmmm_: so i'd like to be able to "look up" sections by reading just as many as needed, possibly none if it has already read far enough
07:30:13 <mmmm_> This seems like something you would get for free with laziness no?
07:30:29 <mmmm_> how are you reading the file?
07:31:20 <vermeille> @src flip map
07:31:20 <lambdabot> Source not found. stty: unknown mode: doofus
07:31:29 <vermeille> @find flip map
07:31:30 <lambdabot> Not in scope: type variable ‘flip’
07:31:30 <lambdabot> Not in scope: type variable ‘map’
07:31:43 <vermeille> @src for
07:31:43 <lambdabot> Source not found. Just try something else.
07:31:49 <vermeille> @find for
07:31:50 <lambdabot> Not in scope: type variable ‘for’
07:31:52 <nshepperd> readNthSection n = last <$> replicateM n readSection?
07:33:42 <absence> mmmm_: using Pipes.Binary.decodeGet with Pipes.ByteString.fromHandle as state
07:35:54 <absence> nshepperd: yes, that works for one lookup. the following ones would require tracking how many sections have been read to decide if more sections must be read or if they can just be looked up in what replicateM has returned
07:36:23 <absence> nshepperd: it's doable, just investigating if a less messy alternative is available :)
07:37:43 <nshepperd> hmm
07:38:25 <nshepperd> lazy IO does seem like the easiest way
07:40:01 <nshepperd> decodeAllSections <$> readFile ...
07:40:50 * hackagebot yesod-auth-hashdb 1.4.1.1 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.1.1 (paulrouse)
07:40:52 * hackagebot http-conduit-downloader 1.0.22 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.22 (VladimirShabanov)
07:43:25 <absence> nshepperd: yeah, wonder if i can do something like that with pipes :)
07:46:35 <edwardk> narendraj9: i'm terribly sorry if i didn't get back to you
07:47:29 <edwardk> narendraj9: we're actually still actively compiling a list of projects
07:48:20 <edwardk> i still have your email still in my 'reply to this correctly when what it needs gets unblocked' queue, but should have fired back something more substantial
07:49:04 <narendraj9> edwardk: That's so nice of you. It's completely my fault anyway. Where can I find the list once it is compiled? :-)
07:49:29 <narendraj9> edwardk: I have an idea for an extension to XMonad.
07:49:36 <edwardk> narendraj9: that is part of what we need to work out. we're trying to do a better job this year than in years past
07:49:53 <edwardk> and for that we'd like to better curate a list of possible projects online somewhere
07:50:16 <edwardk> tibbe has been wonderful in helping to brainstorm proposals, etc.
07:50:38 <edwardk> but now we need to curate them, figure out where to put the list and what not
07:51:26 <edwardk> you might join #xmonad and try to find a mentor for such a project
07:52:24 <narendraj9> edwardk: Okay. I will look for a mentor in #xmonad. I have tried to discuss this in #haskell-gsoc now.
07:52:37 <edwardk> basically anything in the haskell ecosystem is within the scope of GSoC, though we tend to realize that GSoC projects tend to work best when focused on extending existing functionality/tools and less on designing a new program or library
07:53:34 <nshepperd> absence: hmm, maybe you could do this, actually
07:53:38 <narendraj9> Are all selected students experts in Haskell?
07:53:42 <narendraj9> I am a beginner.
07:53:59 <narendraj9> But I have time.
07:55:09 <edwardk> narendraj9: not all of them, though it does tend to be one factor folks consider when they pick between projects. a very solid proposal and enough front work could overcome that factor, there is no real checkbox list you must satisfy perfectly, but past haskell experience has correlated heavily with success in the past.
07:55:13 <nshepperd> absence: I'm assuming the thing that needs to lookup "nth sections" is a Pipe of some kind
07:55:41 <hiptobecubic> narendraj9, I think the main criteria is how likely you are to produce something useful by the end of the project. That's why extensions are favored over novelties and experience producing useful things is highly valued
07:55:51 * hackagebot hspec-snap 0.3.1.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.1.0 (DanielPatterson)
07:57:16 <narendraj9> edwardk: Thanks! Can you please reply to my email with a link to the page once the list is compiled? :-)
07:59:54 <absence> nshepperd: the file reading is through a pipe
08:03:55 <bezirg> with the recent emacs update to 24.4  haskell-mode any indendation does not behave as usual. Any info?
08:05:42 <smart_ptr> what is an easy example that will ghci run `out of memory` ?
08:06:29 <n4x> fold (
08:06:42 <n4x> fold (+) 0 [1..] ?
08:06:55 <n4x> er, foldr/l
08:07:06 <n4x> or the common sum/length example?
08:07:16 <nshepperd> absence: I'm thinking something like "newtype SectionsRead = SR (IORef [Section])"; indexSection :: Int -> SectionsRead -> Consumer' Section IO Section
08:08:12 <nshepperd> absence: if the part that needs to do indexing can work in a Consumer context, it can use indexSection instead of regular (!!), and indexSection can automatically `await` as many Sections are required
08:09:21 <nshepperd> (assuming this is connected to a Producer that opens the file and reads Sections one by one)
08:09:42 <JonLace> Hi. I'm new to haskell and I'm confused about how to write a function in haskell that takes a data and just modifies one property and returns the same data. Let's say I have a data person with a lot of properties "data Person { age :: Int, height :: Int, name :: String ... }" And I want to write a function that reads a number from file and modifies makes the person's height equal to that number. "modifyHeight ::Person -> IO Person".
08:09:49 <smart_ptr> n4x: thank you! :D
08:10:25 <biglama> hi, can someone tell me how to format the output of quickcheck ? I would like to print the property name in the output
08:10:34 <JonLace> What would be the ideomatic way to do that in Haskell? I can pattern match each property and construct a new person, but that seems to be ugly looking code
08:11:12 <tdammers_> JonLace: basically constructing a new object based on the old one is the way people do this
08:11:25 <tdammers_> JonLace: you can, however, write it more elegantly with record syntax
08:11:28 <ClaudiusMaximus> JonLace: record syntax allows you to do   f x = x{ height = newHeight }
08:11:46 <tdammers_> JonLace: like so: newPerson = oldPerson { age = (age oldPerson) + 1 }
08:11:55 <Cale> JonLace: modifyHeight p = do ... read h from file ... ; return (p { height = h })
08:12:23 <JonLace> Ohh ok. Thx. I was about to write it much uglier.
08:12:38 <S11001001> JonLace: Depends on whether you are using lens or not.  If you're using lens, assuming you have readNumberFromFile :: IO Int, (\x -> set height x oldPerson) `liftM` readNumberFromFile
08:12:40 <S11001001> @ty set
08:12:41 <lambdabot> ASetter s t a b -> b -> s -> t
08:13:02 <tdammers_> yeah, lens makes for a more imperative-looking syntax
08:13:41 <Cale> Despite the fact that lens is pretty cool, I'm not sure how appropriate it is for new users :)
08:14:12 <Cale> (and presumably if you're using it, you already knew about set ;)
08:20:10 <jonasss> Hi, is it possible to create an instance show for a type synonym? Like type Row = [Char] and than do instance show Row to customize? It doesn't seems to work
08:21:25 <bergmark> jonasss: you can't have separate instances for a type alias, use a newtype if you want that
08:24:44 <jonasss> Hmm ok thanks
08:25:02 <jonasss> But is it a good idea to think OO? like i want a to create a board with [[Char]]
08:25:16 <jonasss> but i want to customize the show of each row
08:25:58 <jonasss> or should i just write a function which formats the row ([Char])
08:27:34 <ClaudiusMaximus> just write a function
08:27:38 <bergmark> I just think OO is a terrible way to model things most of the time :-)
08:28:43 <jonasss> hehe ok :D
08:29:00 <jonasss> it just seems nicer to have an instance of show
08:29:06 <jonasss> instead of writing a function to do it
08:29:54 <bergmark> jonasss: what if you want to show it differently in different contexts?
08:30:07 <n4x> you could use newtype or TypeSynonymInstances
08:30:55 * hackagebot git-repair 1.20141027 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20141027 (JoeyHess)
08:30:55 <bergmark> TypeSynonymInstances doesn't let you override instances
08:31:22 <jonasss> hmm yeah but i only need it in one context ^^
08:32:41 <n4x> I would use a newtype anyway
08:32:51 <Cale> jonasss: An object which is incapable of responding to any message apart from a request to produce a String is effectively the same thing as a String.
08:34:23 <bergmark> jonasss: i find that avoiding type classes until you find that you really need them is a good way to develop
08:34:47 <Cale> jonasss: You can do a lovely encoding of OO in Haskell (at least as far as I'm concerned), by making datatypes with fields consisting of functions (and occasionally other values) which specify which messages your objects are going to be capable of responding to
08:34:55 <absence> nshepperd: ah i see. i have the producer as a variable, so it doesn't have to be a consumer, but i get the idea :) thanks
08:35:04 <Cale> and then you can write different "constructor" functions which produce such records
08:35:27 <Cale> and the parameters to these constructors are essentially your "private members"
08:36:00 <Cale> (or anything defined inside the constructing function itself which doesn't directly go in the record)
08:36:08 <jonasss> alright thanks :D i'll just keep it simple a write a function :p
08:37:23 <Cale> jonasss: One thing I realised through this is that most of the need for subtyping in OO languages comes from the fact that these OO languages tie the method implementations to the definition of the type (i.e. the class declaration).
08:38:31 <Cale> You can encode a lot of what people use OO for with no subclass relationships at all, so long as you're able to have lots of different method implementations in a single type of object.
08:39:18 <jonasss> ok i'll give it a go, thanks :)
08:45:56 * hackagebot rainbow 0.18.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.18.0.0 (OmariNorman)
08:45:58 * hackagebot rainbow-tests 0.18.0.0 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.18.0.0 (OmariNorman)
09:05:58 * hackagebot rainbox 0.6.0.2 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.6.0.2 (OmariNorman)
09:16:59 <Hijiri> If I have an exposed module that reexports another module, but that other module isn't explicitly exposed, will haddock still generate docs for the reexported module?
09:17:36 <albeit> I'm trying to use GCStats to measure bytes allocated, but the frequency of samples is too small... is it possible to increase the frequency, or force a sample to be taken?
09:35:01 <foo7873> I have some haskell code that I want to compile to C, i.e. using the C backend.
09:35:25 <foo7873> According to http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html, I can use the -fvia-C flag for that
09:35:38 <foo7873> (I have verified that my ghc is in unregistered mode)
09:35:53 <foo7873> However, when I try to compile my file this way I get
09:36:01 <Hijiri> I think the C backend is deprecated, I don't remember
09:36:02 * hackagebot json-autotype 0.2.1.1 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.1.1 (MichalGajda)
09:36:15 <foo7873> > ./ghc-7.8.3/inplace/bin/ghc-stage1 -fvia-C hello.hs
09:36:15 <foo7873> on the commandline: Warning:
09:36:15 <foo7873>     The -fvia-C flag does nothing; it will be removed in a future GHC release
09:36:16 <lambdabot>  <hint>:1:1: parse error on input ‘./’
09:37:22 <foo7873> But doesn't the bootstrapping process for ghc itself involve compilation via a c compiler like gcc or clang?
09:38:18 <geekosaur> it used to
09:38:44 <foo7873> @geekosaur: does that mean that it doesn't do that any more?
09:38:45 <lambdabot> Unknown command, try @list
09:39:00 <geekosaur> but C code generation has been broken for a while now. the current bootstrapping path seems to involve using -fllvm and retaining temporary files, then converting the llvm bytecode on the target system. see how arm cross-development is done
09:39:08 <geekosaur> (this is still pretty ugly and scary)
09:39:49 <foo7873> ok
09:40:09 <geekosaur> also, porting ghc itself was never done with -fvia-C, there was a separate backend that generated portable ANSI C instead of the scary platform specific stuff -fvia-C generated
09:40:49 <foo7873> I'd love to get my hands on that ANSI-C backend
09:40:52 <geekosaur> (both of these are currently broken; the ANSI backend has been broken for much longer than -fvia-C, which I think still mostly worked in 7.2 and maybe 7.4)
09:42:00 <foo7873> Ok, so I guess I'll just try to get it work with some old version of ghc
09:42:23 <foo7873> Should I file a bug somewhere concerning the outdated documentation on the -fvia-C flag?
09:43:51 <geekosaur> I don't think so, the "will be removed" part of that error is correct
09:44:04 <geekosaur> not sure if it's already removed in the upcoming 7.10 though
09:44:59 <geekosaur> basically nobody cares about -fvia-C except people who think it does something that it doesn't and never did
09:45:13 <geekosaur> in particular it does not give you code you can pick up and drop somewhere else and expect to work
09:45:32 <foo7873> ah, that's a shame
09:45:41 <foo7873> That's exactly what I was thinking
09:45:50 <geekosaur> the ANSI C backend did, but even that requires you to provide a runtime from somewhere --- and the resulting code is very slow, very minimal, and really only good to bootstrap a proper backend
09:46:03 * hackagebot logging 2.1.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-2.1.0 (JohnWiegley)
09:46:05 * hackagebot prednote 0.26.0.2 -   http://hackage.haskell.org/package/prednote-0.26.0.2 (OmariNorman)
09:46:07 * hackagebot prednote-test 0.26.0.2 - Tests and QuickCheck generators to accompany prednote.  http://hackage.haskell.org/package/prednote-test-0.26.0.2 (OmariNorman)
09:46:22 <foo7873> By runtime, do you mean haskell-runtime including gc and so on?
09:46:25 <geekosaur> yes
09:46:36 <foo7873> Ok
09:46:56 <geekosaur> if you really want to generate code you can take somewhere else, jhc/ajhc might be your best bet --- but note that it doesn't handle a lot of stuff that ghc does
09:47:07 <foo7873> Then I'm out of luck. I have some haskell code that I wanted to run on some weird embedded device.
09:47:17 <foo7873> Oh, cool
09:47:38 <geekosaur> http://repetae.net/computer/jhc/
09:47:51 <geekosaur> and embedded is one of the things jhc specifically targets
09:48:11 <geekosaur> ghc really isn't suitable for embedded targets
09:50:08 <foo7873> I'll have a look
09:50:13 <foo7873> Thank you so much!
09:50:16 <shapr> geekosaur: does JHC do GC these days?
09:51:42 <geekosaur> I think so? it has multiple gc backends these days although some of them may not be what you mean by gc
09:54:28 <geekosaur> so I see boehm-gc and jgc as options. I assume boehm doesn't count as gc :p
09:55:42 <Adeon> in my android experiments I think jgc crashes and is not fully stable but it might be because of the unusual environment
09:55:48 <Adeon> boehm gc seems to work well
09:56:11 <Adeon> but don't expect to be able to use the ecosystem built on hackage and ghc so easily
10:05:14 <sushith> i want to use labdabot in my private channel, possible?
10:05:38 <jchmrt> yes
10:05:51 <sushith> how
10:05:54 <jchmrt> you can install lambdabot and run it in your channel
10:06:06 <jchmrt> with cabal-install
10:07:21 <sushith> first i wanto install lamdabot in my machine right?, ok
10:07:25 <jchmrt> yes
10:07:35 <sushith> how to run it in channel?
10:07:50 <jchmrt> you launch it and the you connect it to the channel
10:08:16 <jchmrt> http://code.haskell.org/lambdabot/README
10:08:42 <sushith> jchmrt: thanks
10:08:52 <jchmrt> np
10:15:06 <Car-Seller> http://www.desura.com/games/dragonfly-racer Buy this game for only £1.99
10:15:44 <benzrf> Cale: bls go
10:15:52 <benzrf> er, car-seller
10:18:56 <glguy> benzrf: When the freenode bot idoru kills a spammer, there's nothing really for the ops to do
10:19:19 <sm> how do you list the packages you maintain on hackage ?
10:19:23 <benzrf> glguy: i was attempting to address car-seller
10:19:39 <benzrf> glguy: it miscompleted to Cale because car-seller was already gone
10:19:50 <benzrf> i didnt see that they were gone cuz i have quits filtered out
10:20:15 <mmmm_> sm: https://hackage.haskell.org/user/JanRochel
10:20:16 <mmmm_> ?
10:20:32 <sm> thanks! I failed to find that
10:21:25 <guest29385> hello im beginner in haskell and have download armada from hackage but when i try to compile i get an error "Foreign.C.Types.CDouble" with "double" expected type double actual type g.gldouble how i can fix it thanks for your help
10:22:33 <glguy> guest29385: That package was uploaded once in 2009 and not updated since, it's possibly going to be a bit of a chore to get working again with current versions of things
10:25:05 <guest29385> glguy: and how i can fix it?
10:26:27 <ReinH> guest29385: By working through the code and updating it to fix the various things that have changed since 2009
10:26:45 <ReinH> It will probably not be an easy task
10:27:29 <guest29385> than i think it is to hard for me as beginner
10:27:43 <ReinH> guest29385: It doesn't sound like a good place to start, no
10:27:48 <ReinH> guest29385: what are you interested in Haskell for?
10:27:48 <MitchellSalad> probably, start with something simpler!
10:28:11 <bergmark> guest29385: you could send an e-mail to the author and ask if he'd be willing to update it
10:28:19 <zmbmartin> Anyone familier with scotty know how I can run middleware per route? What I would like to do is checkAuth and set currentUser in the Request Vault.
10:28:32 <guest29385> i have found haskell some days ago and would like play a bit with this language
10:29:31 <narendraj9> guest29385: Right now there is a MOOC on edX. You can do that. Let me give you the link to it.
10:29:52 <narendraj9> guest29385: Erik Meijer is the instructor.
10:29:55 <guest29385> ok thanks
10:30:39 <S11001001> @ty (<$)
10:30:39 <lambdabot> Functor f => a -> f b -> f a
10:30:56 <S11001001> I'm never going to remember the order
10:31:06 <MitchellSalad> guest29385: @lyah
10:31:07 * hackagebot tellbot 0.4.0.2 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.4.0.2 (DimitriSabadie)
10:31:13 <ReinH> S11001001: the arrow points to the thing you keep :)
10:31:14 <MitchellSalad> @lyah
10:31:14 <lambdabot> Unknown command, try @list
10:31:19 <S11001001> @where lyah
10:31:19 <lambdabot> http://www.learnyouahaskell.com/
10:31:19 <ReinH> @where lyah
10:31:20 <lambdabot> http://www.learnyouahaskell.com/
10:31:24 <MitchellSalad> right-o
10:31:37 <S11001001> ReinH: it's weird, I have no trouble with <* and *>
10:31:51 <ReinH> S11001001: heh
10:32:10 <S11001001> @ty (%=)
10:32:11 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
10:32:25 <MitchellSalad> <$ points to the "return value"
10:32:31 <MitchellSalad> just like <*
10:32:41 <benzrf> :t ($>)
10:32:42 <lambdabot>     Not in scope: ‘$>’
10:32:42 <lambdabot>     Perhaps you meant one of these:
10:32:42 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
10:32:47 <benzrf> shriek
10:35:46 <sushith> when i tried to install lambdabot in my machine,
10:35:56 <sushith> lambdabot-4.3.0.1 depends on haskell-src-exts-1.16.0 which failed to install.
10:36:37 <MitchellSalad> scroll up a bit and try to figure out why it failed to install
10:37:14 <narendraj9> guest29385: https://courses.edx.org/courses/DelftX/FP101x/3T2014/info
10:43:54 <dfeuer> @quote edwardk
10:43:54 <lambdabot> edwardk says: so the -> is matched on the outside, but the -> and , fail to match on the inside, unification fails, dogs and cats start living together in harmony, general chaos.
10:48:04 <guest29385> narendraj9: thanks
10:49:16 <sinelaw> what's a reasonable way to publish my haskell executable for easy deployment (e.g. package managers, etc.)?
10:49:39 <sinelaw> requiring every user to install the haskell dev stack is quite annoying
10:50:06 <sinelaw> for debian / ubuntu, is a launchpad PPA reasonable?
10:50:20 <benzrf> isnt there statically linked binaries possible
10:50:27 <sinelaw> and what do you do for yum-based distributions, not to mention even  - windows?
10:51:08 <sinelaw> will I have gigantic binaries?
10:52:53 <dfeuer> sinelaw, http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/using-shared-libs.html might have something for you.
10:54:27 <sinelaw> dfeuer, thanks.
10:56:10 * hackagebot rest-gen 0.16.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1 (AdamBergmark)
10:59:51 <dfeuer> sinelaw, I think a lot of the challenges with general Haskell deployment have to do with the fact that Haskell's in the awkward position of being both a useful programming language for production applications *and* a research language for experimenting with language features, optimization techniques, and library abstractions.
11:00:21 <ReinH> sinelaw: if you control the arch, you can distribute binaries
11:00:24 <dfeuer> There doesn't seem to be any obvious way to resolve the tension between those aspects.
11:00:41 <ReinH> sinelaw: distributing as docker images is great if you're already using or are willing to try docker
11:00:57 <ReinH> dfeuer: I'm not so sure they're in tension :)
11:01:21 <ReinH> Our pragmatic use of Haskell has benefitted frequently from the theoretical stuff :)
11:01:49 <dfeuer> Oh, of course it's benefited, but that doesn't mean there's no tension between them.
11:01:56 <ReinH> True.
11:02:19 <benzrf> t-tension
11:02:21 <ReinH> sinelaw: And yes, GHC binaries tend to be rather large.
11:02:41 <benzrf> bbl
11:11:44 <gigabytes> hi
11:11:47 <ReinH> Quick reminder to any folks in Portland, OR, Galois's Haskell Office Hours meetup is tonight: http://www.meetup.com/Portland-Haskell-Office-Hours/events/214808532/
11:12:19 <gigabytes> is there a significant benchmark of how much, if any, slowdown can incur using lenses?
11:12:36 <gigabytes> or any document on how to avoid anti-patterns?
11:14:02 <yesthisisuser> is there an example somewhere how to create a ByteString from C code?
11:18:07 <int-e> @type Data.ByteString.Internal.fromForeignPtr
11:18:08 <lambdabot> GHC.ForeignPtr.ForeignPtr Word8 -> Int -> Int -> BSC.ByteString
11:18:14 <zmbmartin> Any scotty users that could help me with middleware?
11:21:01 <yesthisisuser> ah. ok fromForeignPtr.. I'll have a look at it, thx
11:21:45 <yesthisisuser> I also seem to recall something from RWH
11:29:34 <__monty__> I'm going through LYAH and the definition of Product (from Data.Monoid) caught my eye. Why can you derive Bounded? Isn't Integer together with * a monoid, even though it is unbounded?
11:30:34 <int-e> __monty__: the derived instance will be  Bounded a => Bounded (Product a)
11:31:59 <__monty__> int-e: So Product a is only bounded if a is already bounded?
11:32:21 <monochrom> yes
11:33:41 <int-e> __monty__: this does not affect the Monoid instance at all. It's an instance(err...) of generalized newtype deriving, which lifts classes from types wrapped in a newtype to the newtype itself. (If you have  newtype X = X Y  and  instance Foo Y, then you can derive an  instance Foo X  automatically, with some technical caveats.)
11:34:32 <monochrom> not generalized newtype deriving. deriving Bounded is already in Haskell 2010.
11:35:01 <int-e> oh, so it is.
11:35:03 <__monty__> int-e, monochrom: Thank you. I thought it was the other way around, i.e. if you say deriving then you can only use types that are already part of that instance. This clears things up.
11:36:04 <dfeuer> Why doesn't Data.Monoid have an all-purpose wrapper? data AllPurpose a = AllPurpose {generallyEmpty::a, generallyAppend::a->a->a, payload::a} ?
11:36:55 <dfeuer> Would that be just too prone to abuse?
11:37:01 <dfeuer> And too slow?
11:37:31 <monochrom> can you write a Monoid instance for AllPurpose a?
11:38:04 <int-e> so what would  AllPurpose 0 (+) 1 `mappend` AllPurpose 1 (*) 1  be?
11:38:11 <__monty__> dfeuer: Isn't the only function that has type a -> a -> a, a function that always returns either the first or the second argument? That's not a very useful monoid.
11:38:42 <dfeuer> monochrom, yeah, I think so. It'd just have to be left-biased or right-biased, right?
11:38:44 <jle`> __monty__: in this case it is whatever `a` that the wrapper is parameterized by
11:38:55 <dfeuer> er ..
11:38:56 <dfeuer> maybe not.
11:39:00 <jle`> __monty__: so AllPurpose Int would have an Int -> Int -> Int
11:39:00 <dfeuer> Forget taht.
11:39:04 <int-e> dfeuer: it's very hard to satisfy the associative law.
11:39:05 <monochrom> __monty__: no, the placement of the type variable "a" in AllPurpose is such that it is not talking about a polymorphic function a->a->a
11:39:12 <dfeuer> int-e, yeah, thta's what i just realized.
11:39:15 <dfeuer> Wow, typing.
11:40:11 <__monty__> jle`, monochrom: This function: mappend :: a -> a -> a, has only two possible implementations no?
11:40:35 <__monty__> jle`, monochrom: Just like id :: a -> a, has only one implementation.
11:40:42 <jle`> __monty__: what you just typed does, but the name is misleading, because that's not actually the type of mappend.
11:40:43 <monochrom> that function is not relevant to this.
11:42:03 <jle`> __monty__: consider type TwoArg a = (a -> a -> a).  TwoArg Bool would have four implementations.  TwoArg () would have one, etc.
11:42:23 <int-e> and all that is ignoring bottoms and seq.
11:42:52 <monochrom> dfeuer: my first worry was mempty. mempty = AllPurpose ? ? ?
11:43:26 <jle`> mhm.
11:44:11 <__monty__> jle`: TwoArg Bool has 4 implementations but we're not talking about TwoArg Bool, we are talking about the more general TwoArg a, so surely the function can only be implemented by either returning the first or the second argument?
11:44:15 <dfeuer> __monty__, the data type is parametrized over a, so it contains something specific. But as everyone explained, it was a bad idea.
11:44:40 <jle`> __monty__: we weren't talking about over all `a`.  look again at the question :)
11:44:57 <jle`> every value of type AllPurpose a is for a specific a.
11:45:31 <monochrom> __monty__: if your understanding were correct, you would be able to explain why this is legal: t = TwoArg (\x y -> x && not y)
11:45:32 <int-e> just like Just () is a particular value of  data Maybe a = Nothing | Just a.
11:46:18 <__monty__> jle`: The question was about a general monoid, surely we don't want do provide our own implementation every time we'd use AllPurpose. We'd want a default implementation and that implementation would have to be sufficiently general.
11:46:41 <int-e> ...
11:47:03 <int-e> __monty__: maybe when you have three people arguing against you it's time to step back and consider their point of view.
11:47:37 <jle`> __monty__: the purpose of AllPurpose is to basically specify your "specific monad instance implementation" and be able to mappend/mempty using it, using the fuctions in the data.
11:48:21 <jle`> so a value of type AllPurpose Int would give you something you can mappend/mempty using the functions inside that you provide inside that data type
11:48:44 <jle`> the functions you put into that data type determine how mappend/mempty would behave.  you give (Int -> Int -> Int)s, etc.
11:48:46 <int-e> __monty__: or perhaps you're trying to say that there aren't many options for implementing mempty :: TwoArg a. But you didn't mention mempty at all.
11:51:40 <monochrom> this is why explicit forall is a good idea. "xxx :: forall a. a -> a -> a" is a very, very different beast from "yyy :: forall a. AllPurpose a -> (a -> a -> a)" or "forall a. TwoArg a -> (a -> a -> a)"
11:53:58 <monochrom> and a different, rank-2 data type "data P = P (forall a. a -> a -> a)" is what you would call relevant to "xxx :: forall a. a -> a -> a"
11:59:32 <Tehnix> Argh, I had it once but lost it. Does anyone know of a vim plugin/short command so you can eval/run your file directly in ghci?
11:59:50 <Tehnix> SHIM does something like it, but only loads the file, and doesn't execute, say, main
12:08:56 <voluminat0> hey guys, i have a little Haskell question running on Stackoverflow: http://stackoverflow.com/questions/26594996/generate-2d-list-with-given-dimensions-in-haskell
12:09:05 <voluminat0> any help is greatly appreciated
12:10:27 <dfeuer> voluminat0, you're not explaining too clearly what you want.
12:10:36 <voluminat0> what is not clear?
12:10:56 <dfeuer> Well, you seem to use Z without applying it to an Int, which it requires.
12:11:18 <dfeuer> [[X,Y,Z 3], [Y,Y,X 1], ...]
12:12:01 <monochrom> do you prefer "data A = X | Y | Z" and drop the "Int"?
12:13:22 <voluminat0> ah I see, I indeed forgot that :)
12:13:23 <RchrdB> voluminat0: the simplest way to get *some* well-formed, rectangular value of the type [[A]] would be: repeatWH width height = replicate height (replicate width A)
12:14:32 <monochrom> > replicate 4 (replicate 3 ())
12:14:33 <lambdabot>  [[(),(),()],[(),(),()],[(),(),()],[(),(),()]]
12:14:34 <voluminat0> @monochrom: I edited the data type.
12:14:34 <lambdabot> Unknown command, try @list
12:14:38 <RchrdB> I'm not immediately clear on how that would be useful to you? When I have a rectangular list, I usually actually wanted an array with 2D indexes, or a (Data.Map (Int, Int) a)
12:14:58 <monochrom> draw inspirations from replicate 4 (replicate 3 ())
12:15:52 <voluminat0> @Rchrd: thanks! That's a direction i haven't thought of yet. I've just started seeing Haskell in school and im trying some stuff out :)
12:15:53 <lambdabot> Unknown command, try @list
12:16:13 <voluminat0> Rchrd: thanks! That's a direction i haven't thought of yet. I've just started seeing Haskell in school and im trying some stuff out :)
12:16:25 <RchrdB> voluminat0: almost. One more character. ;)
12:17:07 <voluminat0> argh, I don't see it
12:18:16 <voluminat0> monochrom, the replicate, can it be combined with random values? Say i want to fill a matrix with random Int's
12:19:57 <monochrom> no
12:20:16 <monochrom> you will first have to find out how to get randomness
12:20:44 <voluminat0> ok, I see
12:20:53 <voluminat0> thanks for the fast help you guys :)
12:29:01 <_d0t> ohai. Are there any RHEL6 repos with the latest ghc?
12:39:53 <thsig_> Hey guys, I was wondering - how are haskell web devs tackling the browser these days? Are people using the haskell-to-JS compilers (like fay or haste) or are most people writing JS on the front end?
12:40:22 <piskrist> yes, most people are writing JS on the front end but there some using transpilers
12:42:04 <piskrist> why is cabal in sandbox telling me process>1.2.0  is missing when I have it installed in my home?
12:43:52 <sivteck> thsig_, this might be of interest for you <http://www.haskellcast.com/episode/007-chris-done-on-compiling-to-javascript-and-sql/>
12:47:38 <felixn> haskell and I tied the knot, it's official now
12:48:05 <thsig_> sivteck: Well spotted! I listened to that one a while back. I don't remember if he talked about the degree of community adoption for these transpilers though.
12:48:24 <felixn> loeb x = fmap (\a -> a (loeb x)) x <-- is this defined anywhere in core?
12:49:06 <sivteck> thsig_, i am not familiar with web dev, but silk.co uses fay and in that cast he says fpcomplete's IDE is written in Fay
12:51:23 * hackagebot HTF 0.12.2.3 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.2.3 (StefanWehr)
12:51:44 <albeit> If I'm reading data from a TCP socket, does using IOStreams to read from it offer any advantages? Is it possible to to call "recv" on the socket and only get a partial packet?
12:52:47 <thsig_> sivteck: Very interesting. Haven't seen silk.co before. In my experience, the front-end part of web dev which tends to spaghettify much more than the server-side. So having the Haskell story also on the front end would be a huge win.
12:52:56 <thsig_> *it's the
12:53:07 <RchrdB> albeit: as an aside, if you're reading from a TCP socket, you don't get any promises about packet boundaries
12:53:30 <success> haskell on the raspberry - status?
12:54:16 <vegai> success: my cubox that's running arch linux arm has ghc-7.8 available
12:54:17 <albeit> RchrdB: Okay. I'm just feeding the data into attoparsec, and the parser is able to detect the packet boundaries, so that's fine... I just want to attoparsec to be able to continue parsing if it doesnt get a full packet
12:54:27 <vegai> success: I suppose that's not too far from a rasp?
12:55:14 <sivteck> thsig_, eg. http://engineering.silk.co/post/82777010096/writing-admin-interfaces-with-fay-using-fay-builder
12:56:04 <RchrdB> albeit: cool. Offhand, I believe that if you know exactly how much data to expect in advance, because you have a content-length somewhere, you may want to use handle IO with exactly sized reads to make it easy for yourself, so that you either get exactly the size of block of data that you're expecting back, or you can treat short results as an error
12:57:48 <RchrdB> albeit: whereas if you're processing data as it arrives, you want to call recv, because recv returns blocks as soon as they become available, albeit very often those blocks will be smaller than you asked for
12:58:05 <RchrdB> blocks? bytes
12:59:51 <thsig_> sivteck: Thanks! Looks like they still have most of their frontend logic written in JS. The FP complete case is quite impressive, since theirs is 100% (afaik) written in Fay.
13:00:15 <albeit> Okay... how would I hook an attoparsec into the socket using recv so that it can deal with multiple blocks/bytes from the recv call?
13:02:10 <albeit> Ohh I think I can rig something up with parseWith actually
13:09:15 <albeit> With attoparsec, is it possible to parseWith to get a result, and then continue using the same action for more input, and the remaining data from the previous parse, to being a new parse?
13:09:57 <albeit> *begin a new parse
13:12:06 <albeit> Ah I'm asking too quick, turns out the Result includes the unconsumed data. Nvm
13:24:57 <RchrdB> albeit: apologies for not answering, but I didn't know any of that and you solved it better than I would've. ;)
13:25:39 <biglama_> hi guys, I'm having trouble installing yi with cabal
13:25:43 <biglama_> the error is "user error (The package 'vty' requires Cabal library version -any && >=1.18.0"
13:26:12 <biglama_> I've found the following https://github.com/haskell/cabal/issues/1666
13:26:23 <biglama_> is it the propery way to resolve it ?
13:31:39 <glosoli> how does one list what belongs to type class in ghci ?
13:31:57 <dmj`> :i
13:32:00 <dmj`> :i Monad
13:32:19 <dmj`> gosoli: call :i in ghci on your typeclass
13:32:20 <dmj`> λ: :i Monad
13:32:21 <dmj`> class Monad (m :: * -> *) where
13:32:21 <dmj`>   (>>=) :: m a -> (a -> m b) -> m b
13:32:24 <dmj`>   (>>) :: m a -> m b -> m b
13:32:27 <dmj`>   return :: a -> m a
13:32:42 <glosoli> dmj`: awesome, thanks
13:37:20 <hexagoxel> biglama: what is the output of `ghc-pkg list Cabal`?
13:38:49 <biglama_> hexagoxel:  Cabal-1.16.0
13:39:09 <biglama_> hexagoxel: what does it mean ? do i have several cabal installed ?
13:39:22 <biglama_> hexagoxel: cabal -V
13:39:27 <biglama_> returns version 1.20
13:40:00 <hexagoxel> the cabal executable may have been compiled with a different version than what is registered at ghc
13:40:46 <biglama_> hexagoxel: i installed with apt (on Debian)
13:40:48 <hexagoxel> if ghc-pkg lists only one version, that is the only installed one. and the one seen by cabal install when you try to see yi
13:41:22 <hexagoxel> s/see yi/install yi/
13:43:19 <hexagoxel> biglama: afaik there are two solutions: 1) upgrade ghc distribution (the latest one includes Cabal-1.18.1.3) 2) use a sandbox
13:43:39 <hexagoxel> i am not completely certain, but i think latest haskell platform would be sufficient
13:43:41 <biglama_> sorry but I'm a bit lost here... how can there be a conflict of version for a single executable ?
13:45:03 <hexagoxel> there is no conflict. you have 1.16 installed, yi wants >=1.18.0. the versions reported by cabal -v are irrelevant
13:45:37 <biglama_> okay, but what does cabal -v returns then ?
13:46:18 <YaRly> I'm choosing between "Haskell: The Craft of Functional Programming" and "Learn You a Haskell" as main studying material, what are the pros and cons of these?
13:46:39 <hexagoxel> the version of the two relevant packages that the executable was compiled with.
13:48:21 <biglama_> ha, i see, thanks
13:48:41 <ChristianS> YaRly: don't know the first one, but "Learn You a Haskell" is pretty great
13:48:58 <simon> YaRly, ditto.
13:50:10 <biglama_> hexagoxel: as I'm a complety noob, what would you recommand between 1) and 2) ?
13:50:26 <benzrf> YaRly: why not CIS194
13:50:27 <YaRly> ChristianS, simon: Oh, good :) Our lecturer said "The Craft of ..." was more thorough and had exercises wherease LYAH was written in a more "fun" style, he seemed to have a slightly derogatory tone when he said "fun" style, so I was worried
13:50:31 <benzrf> cis194 is p great
13:51:12 <ChristianS> YaRly: some people just don't like fun, i guess
13:51:32 <Hijiri> I liked cis194 better because it has more exercises
13:51:38 <ChristianS> YaRly: LYAH is pretty entertaining, but you also learn a lot
13:51:49 <Hijiri> compared to lyah, I mean, I don't know about craft
13:51:58 <ChristianS> what's CIS194?
13:52:11 <Hijiri> http://www.seas.upenn.edu/~cis194/spring13/
13:52:18 <ChristianS> ah
13:52:20 <hexagoxel> biglama: hmm what is your ghc version?
13:52:56 <benzrf> ChristianS: u may appreciate https://github.com/bitemyapp/learnhaskell
13:53:02 <benzrf> ^^shilling^^
13:53:22 <DrSkyLizard> https://courses.edx.org/courses/DelftX/FP101x
13:53:30 <biglama_> hexagoxel: 7.6.3
13:53:35 <DrSkyLizard> Haskell based FP course that started a few weeks ago
13:54:18 <YaRly> Hijiri: Hadn't heard about CIS194, I guess the only caveat with LYAH is that it doesn't have exercises...
13:54:29 <YaRly> I really like the pictures though ^^
13:54:57 <benzrf> the pictures are sweet
13:55:01 <benzrf> YaRly: i gotta say though
13:55:09 <benzrf> LYAH is...
13:55:12 <benzrf> it feels, uh
13:55:16 <benzrf> unthorough
13:55:18 <benzrf> ?
13:55:44 <hexagoxel> biglama: one moment, i'll see if the sandbox approach works with that version
13:55:45 <YaRly> idk, I haven't read it yet, that's why I asked here
13:56:06 <biglama_> hexagoxel: sandboxes seem complicated :p
13:56:06 <benzrf> like, the kind of thing where you read it and you get it enough to move forward but then over time you gain a more thorough understanding that it didnt look into
13:56:09 <simon> YaRly, having skimmed "The Craft of ...", it seems like a nice book. a bit verbose, maybe.
13:56:32 <benzrf> i guess i think it sort of feels like it was written by somebody who couldn't get inside the reader's head that well
13:56:42 <benzrf> it's informative but it doesn't, like, anticipate your questions
13:56:55 <benzrf> or something...
13:57:15 <YaRly> benzrf: Hmm, maybe it was written with the expectation that the reader already was familiar with programming?
13:57:38 <benzrf> YaRly: im talking about haskell, not programming in general
13:57:54 <YaRly> oh, ok
13:58:12 <benzrf> besides, haskell is not terribly similar to programming in imperative languages
13:58:20 <benzrf> it has expressions
13:58:25 <benzrf> so do they
13:58:28 <benzrf> but otherwise
13:58:38 <simon> YaRly, "The Craft of ..." seems to be somewhat introductory, too. e.g. on page 73 it has a subtitle "Can
13:58:41 <simon> I
13:58:43 <simon> break
13:58:46 <simon> the problem
13:58:48 <simon> down
13:58:51 <simon> into
13:58:53 <benzrf> simon: bad paste, BAD PASTE
13:58:53 <simon> argh! bad firefox!
13:59:17 <simon> YaRly, "The Craft of ..." seems to be somewhat introductory, too. e.g. on page 73 it has a subtitle "Can I break the problem down into simpler parts?"
14:00:23 <hexagoxel> biglama: i agree that they are yet one more thing to get familiar with. but i had like no dependency problems since i consequently used them.
14:00:43 <ajcoppa> YaRly: there is a #haskell-beginners channel here on freenode that has a bunch of learners and teachers. CIS194 (as linked earlier) is the starting resource we recommend
14:01:08 <ajcoppa> along with a few other steps as part of a guide that you can read there :)
14:01:28 <hexagoxel> biglama: and: test successful. try `cabal sandbox init; cabal install Cabal; cabal install yi`
14:01:32 <YaRly> simon: Hmm, I can't find that passage, but I think you're right in that it's introductory
14:02:04 <hexagoxel> biglama: oh, the sandbox will be put in current directory
14:02:06 <LowPotential> ajcoppa: The homework exercises look practical and instructional.
14:02:11 <hexagoxel> so choose something appropriate
14:02:53 <biglama_> hexagoxel: thanks. So every "cabal install" will install in this .cabal-sandbox from now on ?
14:03:07 <hexagoxel> as long as you are in the directory with the sandbox in, yes
14:03:10 <ajcoppa> LowPotential: yep, exactly. even if someone's already read LYAH, i still recommend going through CIS194 because doing exercises is the only way to really make sure one has understood the material
14:03:28 <hexagoxel> cabal install looks for sandbox in current directory always, and uses that if it exists
14:03:58 <biglama_> okay, i think this will be forgotten in a week or so, but it looks cool
14:05:05 <biglama_> I mean, I may install in .cabal instead of .cabal-sandbox without thinking
14:05:12 <ConnorM_> Hey guys, anyone familiar with adjacency matrices in haskell? I need to find all neighbors(so 8 directions of you represent it as a matrix) of a cell in a 2D list that have a certain value X..
14:05:31 <biglama_> can I force haskell to use the sandbox for all subsequent installs ?
14:05:40 <biglama_> s/haskell/cabal/
14:06:15 <hexagoxel> biglama: `require-sandbox: True` in ~/.cabal/config
14:06:16 <silver_> change directory where your sandbox is
14:06:52 <hexagoxel> will prevent you from installing before you "cabal sandbox init"
14:07:42 <biglama_> great, it should be idiot-proof enough for me :p
14:08:11 <biglama_> hexagoxel: thanks for your time, i appreciate it
14:08:22 <ConnorM_> no-one any ideao how to get the neighbours of a cell in a 2D list?
14:08:24 <biglama_> yi seems to be compiling nicely btw
14:09:26 <biglama_> and... no, failure to install a dependency
14:09:51 <hexagoxel> biglama: and if you are serious about the proper way (tm) of using sandboxes for everything, you might find https://github.com/lspitzner/cabal-exec-install useful :D
14:10:58 <tommd> Oh neat, Galois is holding "Haskell Office Hours" again today, for those of you who are interested and in town.
14:11:00 <biglama_> "wait an hour while everything installs" really ?
14:11:15 <biglama_> and "several GB" for the sandbox file ??
14:12:44 <trap_exit> > 1 + 2
14:12:46 <lambdabot>  3
14:12:54 <trap_exit> > 2 ^ 10
14:12:56 <lambdabot>  1024
14:13:00 <trap_exit> > 2 ^ 100
14:13:02 <lambdabot>  1267650600228229401496703205376
14:13:09 <trap_exit> > 2 ^ 1000
14:13:11 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
14:13:34 <trap_exit> are Ints lazy? does haskell only computes the bits it needs to display?
14:13:40 <trap_exit> > 10 ^ 10000000000
14:13:40 <hexagoxel> biglama: well, it depends on how many executables you add, and is slightly exaggerated :D my ~/.cabal/sandboxes is 3.3gb atm
14:13:45 <lambdabot>  mueval: ExitFailure 1
14:13:53 <trap_exit> > 10 ^ 2
14:13:55 <lambdabot>  100
14:13:59 <trap_exit> hmm, I guess not
14:14:18 <mauke> > 10 ^ 10000000000 :: CReal
14:14:22 <lambdabot>  mueval-core: Time limit exceeded
14:14:24 <mauke> heh
14:15:01 <monochrom> 3.3gb is like you have 3 copies of ghc
14:15:17 <HeladoDeBrownie> trap_exit, that's hardly a test for that. It could be the greater digits rely on the lesser ones. However, arithmetic operations for Int are indeed strict.
14:15:35 <CosmicRay> hmph.  is there any workaround to ./setup sdist generating tarfiles that hackage doesn't like because they're GNU?
14:15:53 <mauke> that example didn't use Int
14:16:00 <mauke> > 2 ^ 100 :: Int
14:16:01 <lambdabot>  0
14:16:25 <sivteck> > take 10000000000 $ iterate (*10) 10
14:16:27 <lambdabot>  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,...
14:16:42 <sivteck> > length $ take 10000000000 $ iterate (*10) 10
14:16:47 <lambdabot>  mueval-core: Time limit exceeded
14:16:47 <lambdabot>  mueval: ExitFailure 1
14:16:52 <sivteck> ;o
14:18:30 <hexagoxel> monochrom: yeah, i could probably delete some of the intermediate files again after executable is finished. but then upgrading needs to re-do stuff. 3gb is not that much..
14:21:46 <biglama_> hexagoxel: yi is finally installed, thanks
14:22:25 <biglama_> hexagoxel: about this cabal-exec-install, I am still using the haskell platform at the moment, so it does not look super useful for me
14:22:28 <biglama_> maybe later
14:22:52 <hexagoxel> biglama: you found the executable? with sandbox it is somewhere in dist..
14:23:06 <hexagoxel> yeah, sure, platform is fine too
14:24:36 <sinelaw> what are common names for the two following classes of type expressions:
14:24:42 <sinelaw> a (where a is free)
14:24:57 <sinelaw> and second: forall a. <expression involving a>
14:25:40 <Hijiri> explicit and implicitly quantified?
14:25:45 <Hijiri> existentially
14:25:54 <sinelaw> or should I just say "expression where a is free" vs. "expression where 'a' is universally quantified"
14:25:58 <Hijiri> because I think a by itself is equivalent to forall a. if a is free
14:26:03 <Hijiri> universally*
14:26:11 <Hijiri> s/existentially/universally
14:26:33 * hackagebot magic 1.1 - Interface to C file/magic library  http://hackage.haskell.org/package/magic-1.1 (JohnGoerzen)
14:26:45 <sinelaw> Hijiri, how is it equivalent? if there is an ambient 'a' bound, forall a. a means something completely different than just 'a'
14:27:14 <Hijiri> oh, right, I don't know what it means if a is already bound
14:27:54 <albeit> I'm trying to time something with criterion. It is of type :: IO (), but generates data inside. If I deepseq the object it generates inside the tested function, it is way faster... why is that?
14:28:42 <sinelaw> Hijiri, it means that you need to rename, and then it makes sense :)
14:29:15 <Hijiri> yeah, I just tried it in ghci and it renames the new a to a1
14:30:56 <sinelaw> Hijiri, how do you try type expressions in ghci?
14:31:11 <sinelaw> by giving values
14:31:13 <sinelaw> ?
14:31:23 <monochrom> sinelaw: expressions/formulas/statements without free variables are called "closed". however, those with free variables are not called "open", they are simply called "not closed" or "contains free variables"
14:31:25 <Hijiri> I did let x = undefined :: a -> (forall a. a -> a) -> b and then did :t x
14:31:30 <Hijiri> you could skip the binding I guess
14:31:34 * hackagebot cmdargs 0.10.12 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.12 (NeilMitchell)
14:31:36 * hackagebot hslogger 1.2.6 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.6 (JohnGoerzen)
14:31:55 <sinelaw> oh cool
14:32:07 <Hijiri> :t undefined :: a -> (forall a. a -> a) -> b
14:32:08 <lambdabot> a -> (forall a1. a1 -> a1) -> b
14:32:29 <sinelaw> monochrom, what system does this terminology come from? some sort of logic?
14:32:48 <monochrom> logic books
14:32:51 <sinelaw> god bless undefined
14:33:32 <sinelaw> monochrom, that's like saying "math books"
14:33:46 <monochrom> yes. they are equally pervasive.
14:34:08 <sinelaw> both are countable
14:34:18 <monochrom> it is standard terminology
14:34:44 <sinelaw> ok, so 'a' is "contains free variables" whereas "forall a. a" is closed
14:34:51 <monochrom> yes
14:34:56 <sinelaw> great, thanks.
14:41:39 <chrisdone> how do you tell cabal repl not to try compiling things when it starts up?
14:46:14 <tommd> chrisdone: By patching cabal, afaik.
14:49:47 <absence> i want to execute an IO action (hSeek) while parsing binary data. from a quick web search: parsec can do IO through monad transformer, but not binary parsing. attoparsec is suggested for binary parsing, but it can't do IO due to being a pure parser. binary.data.get doesn't seem to be a monad transformer either. how do people solve this? split attoparsec/binary.get parsers into smaller ones that can finish between calls to hSeek, or are there other
14:50:46 <benmachine> absence: I think parsec can be coerced into doing binary parsing
14:51:08 <benmachine> absence: also, your message got cut off at "are there other"
14:51:31 <absence> ... solutions?
14:51:55 <benmachine> absence: also, what you ask is not straightforward, e.g. imagine a parser 'a <|> b'
14:51:59 <benmachine> where a needs to seek
14:52:02 <benmachine> but then fails to match
14:52:30 <absence> i see your point
14:53:11 <absence> so how should binary data containing offsets inside large files be handled?
14:53:40 <benmachine> well, parse a bit, then seek a bit, then parse a bit more
14:53:42 <benmachine> maybe
14:53:48 <benmachine> or, seek, but carefully
14:54:07 <benmachine> like I said I think parsec is technically capable
14:54:14 <simpson> absence: Be lazy! Note that you have a pointer, and indicate that you can parse more at that location, but have every parse have to have a location which it starts at.
14:55:50 <absence> simpson: hm, do you mean to just read the offset rather than follow it, and use another round of parsing to follow it?
14:56:15 <simpson> absence: Yeah. I mean, you don't want to read all of the file immediately, right?
14:56:24 <simpson> If it's large, then you probably don't want to load it all into memory!
14:56:54 <absence> simpson: i don't want to read all the file, but i want to read all the specific stuff i'm looking for :)
14:57:30 <simpson> absence: Sure. Are there length delimiters?
14:58:43 <absence> simpson: what you suggest would work, with just a minor annoyance. i'd need multiple versions of the types that i'm going to read. one preliminary type that contains pointers instead of actual data, and a "final" type that contains the actual data
15:01:22 <absence> for example UnfinishedBitmap which contains width, height, pixelformat, and a file offset to the pixel data, and then Bitmap which contains all the fields of UnfinishedBitmap, except actual pixel data instead of a file offset
15:01:37 * hackagebot testpack 2.1.3.0 - Test Utililty Pack for HUnit and QuickCheck (unmaintained)  http://hackage.haskell.org/package/testpack-2.1.3.0 (JohnGoerzen)
15:01:38 <fragamus> hey hey hey what's the latest and greatest for creating 'nix tools in haskell
15:02:27 <absence> simpson: it kinda violates the DRY principle
15:03:18 <johnw> fragamus: what do you mean?
15:03:31 <absence> simpson: hmm, unless i stuff all the non-pointer fields into a separate type, like BitmapDescription, that can be shared by both Bitmap and UnfinishedBitmap
15:03:36 <simpson> absence: Bitmap a = Bitmap Width Height Format a
15:03:50 <absence> simpson: or that :D
15:03:50 <simpson> absence: But again, I don't really know the nature of your data.
15:04:07 <fragamus> well I think i remember something about some applicatives to create various options for a 'nix tool
15:04:51 <fragamus> but I am starting from nothing, and I just want to know what the best thing is for creating 'nix tools, autogenerated help etc
15:06:53 <sinelaw> is it straightforward to  extend standard HM to support universal quantification (rank 1 only) ? e.g. support unifying alpha-equivalent closed types (e.g. forall a . a should unify with forall b . b)
15:06:56 <sinelaw> ?
15:07:41 <absence> simpson: right, but the gist is that in general, solutions to this kind of problem are going to be slightly kludgy?
15:08:56 <simpson> absence: TBH all solutions are kludges. :3
15:12:24 <fragamus> @hoogle Options.Applicative
15:12:26 <lambdabot> package applicative-extras
15:12:27 <lambdabot> package applicative-numbers
15:12:27 <lambdabot> package applicative-quoters
15:12:43 <benzrf> sinelaw: doesnt haskel alredy have that
15:13:48 <sinelaw> benzrf, perhaps. i'm interested in knowing how much of a change it is to the basic HM
15:14:00 <benzrf> does basic HM not have that ...
15:17:07 <sinelaw> benzrf, from what I understand, in basic HM types in the unification environment are implicitly quantified, whereas explicitly quantified types ("type schemas") are instantiated by introducting fresh free variables before undergoing unification
15:18:18 * benzrf shrugs
15:27:07 <fragamus> I guess I'm asking is there anything better than https://github.com/pcapriotti/optparse-applicative
15:29:52 <k00mi> fragamus: what's wrong with optparse-applicative?
15:32:17 <fragamus> nothing is wrong with it; I am just doing a general query to see what people are using
15:32:39 <fragamus> I did not say anything was wrong with anything
15:32:48 <benzrf> i used optparse-applicative for my one cruddy thing
15:34:10 <monochrom> I use optparse-applicative, but I only obtain from hackage, not github
15:45:56 <fragamus> @hoogle runIdentity
15:45:57 <lambdabot> Data.Functor.Identity runIdentity :: Identity a -> a
15:45:57 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
15:49:36 <eacameron1> For some reason I'm struggling to use Applicative correctly, I merely want to run an IO function with two arguments. do...; configureIt <*> getFirstArg <*> getSecondArg    What am I doing wrong?
15:49:43 <lpaste> fragamus pasted “uhm... this is new” at http://lpaste.net/113285
15:49:51 <benzrf> eacameron1: you want <$> <*> not <*> <*>
15:50:15 <benzrf> eacameron1: remember, configureIt is a function of 2 args
15:50:35 <benzrf> so when you fmap it, you get an io action resulting in a partially-applied function
15:50:38 <benzrf> then you can (<*>) that
15:50:55 <benzrf> for an io action resulting in the result of the function
15:52:00 <fragamus> gah which runIdentity should I be using
15:52:52 <eacameron> benzrf: Hmmm, the last time I tried that the action just didn't run at all. I didn't tell the whole truth. I'm in a different Monad atop IO (Action from Shake), could it be that it does not implement applicative the way I expect?
15:53:52 <HeladoDeBrownie> eacameron, are you getting a type error or something else?
15:54:50 <eacameron> HeladoDeBrownie: I'll try again. I didn't get any type errors
15:55:04 <HeladoDeBrownie> fragamus, probably can't go wrong with C.M.I.runIdentity, but they might be identical
15:58:06 <benzrf> eacameron: check the type
15:58:20 <benzrf> eacameron: you may be ending up with an IO (IO a)
15:58:37 <benzrf> in which case getFirstArg and getSecondArg will run, but the result of configureIt is getting discarded
15:58:43 <benzrf> instead of run
15:59:13 <eacameron> benzrf: That's what I figured was probably happening, so I figured I was using <$> wrong
15:59:18 <benzrf> nah!
15:59:25 <benzrf> you need join
15:59:30 <benzrf> join is the essential monad function
15:59:37 <benzrf> (>>=) is really just fmap followed by join
15:59:45 <benzrf> well
15:59:56 <benzrf> in haskell, join is implemented in terms of (>>=), but
16:00:06 <benzrf> join is where the real monadic goodness is
16:00:25 <MitchellSalad> benzrf: i know what you're saying, but to a beginner i must admit that all sounds like complete nonsense
16:01:19 <MitchellSalad> like, i'm not sure what eacameron can do with the knowledge that "join is where the real monadic goodness is" :P
16:01:33 <acowley> MitchellSalad: It's a useful pointer to look at and think about join
16:01:41 <MitchellSalad> it is
16:01:44 <davidthomas> "join is what you'll see when you go read math books"
16:02:10 <eacameron> I understand why join is necessary, but I'm disappointed that I need it for such a simple task. Is there an infix form of "<$> + join" ?
16:02:14 <acowley> I think join is useful to think about even if you never read a math book
16:02:22 <MitchellSalad> eacameron: bind =)
16:02:31 <acowley> eacameron: >>=
16:02:46 <eacameron> MitchellSalad: acowley: oh right. he just said that. So I would write this how?
16:03:08 <MitchellSalad> well, "join (foo <$> bar)" is the same as "bar >>= foo"
16:03:10 <eacameron> join $ configureIt <$> getFirst <*> getSecond === ....
16:04:20 <davidthomas> \x f -> join . fmap f
16:04:25 <acowley> Ah, well that can indeed be an awkward one! Many tutorials will suggest using do-notation. The problem is that this isn't just a composition of <$> and join
16:04:39 <cdk> eacameron: in do-notation: do { x <- getFirst; y <- getSecond; configureIt x y }
16:04:48 <eacameron> cdk: right, but that's bulky
16:04:54 <MitchellSalad> that's not bulky
16:04:56 <Hijiri> @pl \x y z -> join $ x <$> y <*> z
16:04:56 <lambdabot> ((join .) .) . (. (<*>)) . (.) . (<$>)
16:05:01 <MitchellSalad> using applicative and join is the alternative =)
16:05:05 <Hijiri> @pl \x -> join $ x <$> y <*> z
16:05:05 <lambdabot> join . (<$> y <*> z)
16:05:07 <acowley> I probably would use join in this case
16:05:12 <cdk> I don't think it's bulky, and it's exceptionally clear
16:05:12 <acowley> hah
16:05:34 <MitchellSalad> if you prefer, getFirst >>= \x -> getSecond >>= \y -> configureIt x y
16:05:39 <MitchellSalad> now *that* is bulky
16:05:42 <eacameron> Haha...
16:05:52 <acowley> cdk: The argument against your version is the avoidance of naming incidental things
16:06:06 <davidthomas> I'd either join or use do notation, depending on context and mood
16:06:12 <eacameron> I'm writing in a context where Haskell is foreign. I'm trying not to scare people away with simple things like function application.... ;)
16:06:19 <acowley> But giving incidental things terrible names is kind of the idiomatic haskell way to indicate to the reader that the named thing is in fact incidental
16:06:31 <acowley> eacameron: Then use do-notation
16:06:43 <MitchellSalad> eacameron: but effectful function application is going to look scary without do-notation
16:06:45 <cdk> acowley: sure, but I'm sure getFirst/getSecond aren't the actual names. They probably acquire some resources that could be descriptively named.
16:07:11 <cdk> instead of "x" and "y", I'm not saying those are good variable names.
16:07:24 <eacameron> acowley: The problem is, configureIt is not the only multi-arged function in this block...so they're gonna look at this as rediculious
16:07:27 <acowley> cdk: Perhaps, but if the result of the action is used once, the name you give that result will probably be redundant given the name of the monadic action
16:07:38 <MitchellSalad> eacameron: what's wrong with do-notation?
16:08:21 <eacameron> MitchellSalad: Oh nothing's *wrong* with it. ;) Just I'm trying not to spend 20 lines doing what most langs can do in 4
16:08:27 <acowley> If you've got a bunch of sequenced multi-argument functions with monadic return values in one definition, you can usually benefit from breaking things down further
16:09:07 <acowley> But that can also be a matter of taste, so there's no hard and fast rule
16:09:41 <eacameron> I understand *why* haskell is more verbose, it wisely discerns the difference between effectful and pure actions (brilliant) but to others, it seems ridiculous
16:09:54 <MitchellSalad> well, that's their problem
16:10:10 <eacameron> haha...and this is why haskell is foreign to them
16:10:32 <acowley> eacameron: This is usually made worse by translitering imperative code into Haskell
16:10:52 <eacameron> yeah...the fact that this is merely a build system is not helping. lots of effects....
16:10:55 <acowley> eacameron: But to do better requires a bit more specificity on the types involved
16:12:08 <acowley> I do a heck of a lot of effectful coding, tend to avoid do-notation, and wouldn't want to be without a type system that distinguishes effectful code from pure code.
16:12:35 <eitan_chatav> try using liftA2
16:12:38 <eacameron> acowley: I don't disagree. I like the clarity. I'll use do notation.
16:12:50 <eacameron> eitan_chatav: Ah, now there's an idea
16:13:16 <acowley> eacameron: But do also look for opportunities to extract bits of functionality so you're not faced with a big do block wherein you struggle to sensibly name many things!
16:13:21 <eacameron> eitan_chatav: wishing idiom brackets were built in right about now!
16:13:54 <eacameron> acowley: true. Haha...most other langs are content with 10 line blocks. Not haskell! 4 is getting big! ;)
16:14:08 <eitan_chatav> eacameron: yeah, idiom brackets might be neat
16:14:23 <acowley> liftA2 will leave you with the same need to join, as would idiom brackets
16:14:35 <eacameron> oh
16:14:38 <eacameron> stink
16:14:49 <MitchellSalad> eacameron: just use do-notation and move on with your life :P
16:14:55 <eacameron> already done
16:15:00 <MitchellSalad> just tell your coworkers it's better than having parens all over the place
16:15:01 <eacameron> but still interesting discussing it
16:15:02 <eacameron> ;)
16:15:27 <eitan_chatav> what do you need join for?
16:15:33 <acowley> eacameron: Yeah! Small definitions are great because they leave fewer corners for bugs.
16:16:07 <acowley> eitan_chatav: The original problem involved a function with type like (a -> b -> f c)
16:16:26 <eitan_chatav> ah
16:16:56 <acowley> eacameron: A neat thing you can do with smaller helper functions is give them more general types than the main thing you're defining. That's how you really squeeze out the bugs: leave them no room to hide!
16:17:47 <eacameron> acowley: great point. there's no DRYer place than Haskell
16:18:40 <acowley> eacameron: What I mean is that even if you're not benefiting from DRY'ing, a single-use helper with a general type is often easier to understand than if you inlined it to its use site, thereby making more structure visible to its definition.
16:18:40 <eitan_chatav> what's the original problem?
16:19:20 <acowley> eacameron: For instance, if you have a list of Ints, you might inline some list logic that could now assume that the individual elements are Ints. By writing a single-use helper with type [a] -> [a], you know you're not making use of the Int assumption.
16:19:21 <eacameron> eitan_chatav: configureIt <$> getFirst <*> getSecond    it doesn't run because it needs join
16:19:56 <eacameron> eitan_chatav: I was hoping for a more elegant solution
16:20:02 <eacameron> acowley: true, great point
16:20:15 <eitan_chatav> you want something :: (a -> b -> f c) -> f a -> f b -> f c?
16:20:29 <shelf> what's the most popular regex library?
16:20:32 <eacameron> eitan_chatav: I suppose so
16:20:39 <shelf> looks like tre is deprecated?
16:22:07 <acowley> I heard of an applicative styled regex library, but not tried it
16:22:42 <benzrf> join is perfectly elegant
16:22:45 <benzrf> no problms with join
16:22:50 <eitan_chatav> eacameron: you might use om or nom
16:23:05 <eitan_chatav> from monad-extras
16:24:07 <acowley> shelf: In my own code, ag tells me I've used regex-pcre-builtin
16:25:04 <eacameron> eitan_chatav: interesting...
16:27:19 <S11001001> I have a fresh empty sandbox with cabal 1.20.0.3.  I asked for an install in the sandbox, and some of the packages were listed as reinstalls, with a warning about packages breaking due to reinstalls.  (Specifically, I'm installing a newer version of text.)  Is this spurious?
16:27:50 <shelf> acowley: thanks! sounds fine to me
16:28:04 <shelf> Text.Regex was fine for me but 'deprecated' gives me the heebie jeebies
16:28:53 <dcoutts_> S11001001: it's not spurious as such, what it means is that within your sandbox you'll have these new instances of text and the global ones will be broken within that sandbox
16:29:08 <dcoutts_> S11001001: but that's ok, and it does not affect things outside the sandbox
16:30:06 <dcoutts_> S11001001: this is because every sandbox starts with the global packages, and so it's still possible to break those within the context of the sandbox by installing within the sandbox and masking the global ones
16:30:39 <dcoutts_> the warning could be clearer in this case
16:33:22 <S11001001> dcoutts_: perfect, thank you for the details.
16:33:40 <ReinH> eitan_chatav: om nom nom
16:33:55 <eitan_chatav> @ReinH: heheh
16:33:55 <lambdabot> Unknown command, try @list
16:34:28 <S11001001> dcoutts_: by global packages, do you mean the ones that installed with ghc, or also the unsandboxed cabal user installs?
16:36:00 <dcoutts_> S11001001: if you do ghc-pkg list you'll see the packages in your global db, and the ones in your per-user db
16:36:16 <S11001001> dcoutts_: cool, thanks
16:36:31 <dcoutts_> S11001001: a sandbox ignores your per-user db, but is an extension of your global db
16:37:22 <timpani> Is there a function of type Bool -> a -> Maybe a? It would wrap a in Just iff the condition is true.
16:38:10 <indiagreen> > when True "true" :: Maybe String
16:38:12 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
16:38:12 <lambdabot>  Expected type: Data.Maybe.Maybe GHC.Base.String
16:38:12 <lambdabot>    Actual type: Data.Maybe.Maybe ()Couldn't match type ‘[]’ with ‘Data.Maybe....
16:38:12 <lambdabot>  Expected type: Data.Maybe.Maybe ()
16:38:12 <lambdabot>    Actual type: [GHC.Types.Char]
16:38:19 <indiagreen> darn
16:38:27 <geekosaur> @djinn Bool -> a -> Maybe a
16:38:27 <lambdabot> f a b =
16:38:27 <lambdabot>     case a of
16:38:27 <lambdabot>     False -> Nothing
16:38:27 <lambdabot>     True -> Just b
16:38:29 <Axman6> :t when
16:38:30 <lambdabot> Monad m => Bool -> m () -> m ()
16:38:43 <acowley> :t bool
16:38:44 <lambdabot> a -> a -> Bool -> a
16:38:57 <acowley> :t bool (const Nothing) Just
16:38:58 <lambdabot> Bool -> a -> Maybe a
16:39:40 <acowley> Although I might have the arguments backwards, the bane of boolean blindness!
16:40:15 <Axman6> I think so
16:40:21 <indiagreen> > guard True >> return "true" :: Maybe String
16:40:23 <lambdabot>  Just "true"
16:42:00 <timpani> thx
16:42:09 <indiagreen> > "true" <$ guard True :: Maybe String
16:42:10 <lambdabot>  Just "true"
16:42:20 <indiagreen> you might prefer this one, or you might not
16:43:22 <indiagreen> :t flip (<$) . guard
16:43:23 <lambdabot> (MonadPlus f, Functor f) => Bool -> a -> f a
16:46:01 <hexagoxel> (Data.Functor has ($>))
16:46:48 * hackagebot lens-family-th 0.4.0.0 - Generate lens-family style lenses  http://hackage.haskell.org/package/lens-family-th-0.4.0.0 (DanBurton)
16:47:01 <indiagreen> hexagoxel: ...I for whatever reason thought it was only being proposed or something
16:47:04 <indiagreen> thanks
16:47:08 <eitan_chatav> :t \b a -> if b then Just a else Nothing
16:47:09 <lambdabot> Bool -> a -> Maybe a
16:47:16 <mrenaud> hexagoxel: What version of GHC?
16:48:11 <hexagoxel> 7.8.3
16:48:37 <hexagoxel> ($>): "Since: 4.7.0.0"
16:48:43 <hexagoxel> (of base)
16:50:07 <folex> Prelude> :t [1,[2,3],4]
16:50:07 <folex> [1,[2,3],4] :: (Num [t], Num t) => [[t]]
16:50:07 <folex> why?
16:50:44 <indiagreen> folex: “1” is an overloaded literal, i.e. it has type “Num a => a”
16:50:59 <folex> how it comes that [[t]] is "common" for t and [t]?
16:51:10 <indiagreen> so, your list is valid if “1” can somehow be a list
16:51:31 <indiagreen> if you define an instance for “Num [a]”, it would be valid
16:52:00 <zwer> actually it wouldn't. all the elements have to be of the same type
16:52:06 <_d0t> folex: wow
16:52:09 <zwer> > [1::Int, 2::Double]
16:52:10 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
16:52:10 <lambdabot>              with actual type ‘GHC.Types.Double’
16:52:15 <folex> I understand constraints. But I don't understand [[t]]
16:52:24 <hexagoxel> zwer: but they would be of the same type :D
16:52:34 <eitan_chatav> let's say you have an instance Num t => Num [t]
16:52:41 <indiagreen> @let instance Num a => Num [a] where fromInteger x = [fromInteger x]
16:52:42 <lambdabot>  .L.hs:161:10: Warning:
16:52:42 <lambdabot>      No explicit implementation for
16:52:42 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
16:52:42 <lambdabot>      In the instance declaration for ‘Num [a]’
16:52:42 <lambdabot>  
16:52:43 <_d0t> hugs gives a error for that one
16:52:47 <eitan_chatav> then the literal 1 will be interpreted as [t] in this context
16:52:50 <indiagreen> > [1,[2,3],4]
16:52:50 <zwer> Num is not a type, it is a type constraint
16:52:51 <lambdabot>  No instance for (GHC.Show.Show t0)
16:52:51 <lambdabot>    arising from a use of ‘M591943645256746059221995.show_M5919436452567460592...
16:52:51 <lambdabot>  The type variable ‘t0’ is ambiguous
16:52:51 <lambdabot>  Note: there are several potential instances:
16:52:52 <lambdabot>    instance [safe] GHC.Show.Show
16:53:02 <indiagreen> > [1,[2,3],4] :: [[Int]]
16:53:03 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
16:53:03 <lambdabot>    arising from the literal ‘1’
16:53:04 <eitan_chatav> and the list [2,3] will also be interpreted as [t]
16:53:06 <hexagoxel> 1 and 4 would be [a], and [2,3] would be as well
16:53:29 <hexagoxel> because 2 and 3 :: a
16:53:56 <_d0t> > foldl (+) [1,[2,3],4]
16:53:58 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
16:53:58 <lambdabot>    arising from a use of ‘M66001256645406907422032.show_M66001256645406907422...
16:53:58 <lambdabot>  The type variable ‘t0’ is ambiguous
16:53:58 <lambdabot>  Note: there are several potential instances:
16:53:58 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:53:58 <Hijiri> @let instance Num [a] where {fromInteger = const []}
16:54:00 <lambdabot>  .L.hs:161:10: Warning:
16:54:02 <lambdabot>      No explicit implementation for
16:54:04 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
16:54:06 <lambdabot>      In the instance declaration for ‘Num [a]’
16:54:08 <lambdabot>  
16:54:09 <Hijiri> > [1, [2,3], 4]
16:54:10 <lambdabot>  No instance for (GHC.Show.Show t0)
16:54:12 <lambdabot>    arising from a use of ‘M908241562026279634622048.show_M9082415620262796346...
16:54:14 <lambdabot>  The type variable ‘t0’ is ambiguous
16:54:16 <lambdabot>  Note: there are several potential instances:
16:54:18 <lambdabot>    instance [safe] GHC.Show.Show
16:54:30 <Hijiri> :t [1, [2,3],4]
16:54:31 <lambdabot> (Num [t], Num t) => [[t]]
16:54:51 * _d0t 's puzzled
16:54:55 <Hijiri> > [1, [2,3], 4] :: [[Int]]
16:54:55 <folex> eitan_chatav: but how is it possible to interpret 1 as [t] while taking [2,3] as [t] at the same time? that would mean that "elements" of `1` are of the same type as elements of `[2,3]`
16:54:56 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
16:54:56 <lambdabot>    arising from the literal ‘1’
16:55:01 <Welkin> Spider-Jerusalem? hah
16:55:04 <folex> Hijiri: please stop
16:55:15 * Spider-Jerusalem draws his bowel disruptor on Welkin
16:55:18 <eitan_chatav> like suppose you made fromInteger n = [1,1,...,1] with n 1s, then [1,[2,3],4] would be [[1],[2,3],[1,1,1,1]]
16:55:27 <Hijiri> I'm giving [a] a Num instance
16:55:33 <Hijiri> You interpret 1 as []
16:55:39 <Hijiri> when you want it to be a [a]
16:55:44 <Hijiri> according to my instance
16:55:45 <zwer> actually my mistake, if you made [Int] to be a Num literal then [1, [2,3], 4] would work, because 1 and 4 would be [Int] as well
16:55:56 <hexagoxel> :)
16:55:58 <eitan_chatav> :i Num
16:56:21 <Welkin> hexagoxel? weren't you hexagonel yesterday?
16:56:34 <folex> eitan_chatav: so haskell checks if there is fromInteger so it can implicitly convert type to a list?
16:56:47 <benzrf> folex: thats totes possible
16:56:57 <folex> "totes"?
16:56:59 <Welkin> and folex trades foreign currencies
16:57:14 <folex> >_>
16:57:18 <eitan_chatav> folex: try defining some (perhaps nonsense) Num instance for [t] and playing with it to see what you get.
16:58:00 <hexagoxel> Welkin: certainly not :)
16:58:23 <eitan_chatav> the point is that 1 doesn't have a type right away, just the constraint that it's Num t => t
16:59:11 <eitan_chatav> you should really read [1,[2,3],4] as [fromInteger 1, [2,3], fromInteger 4]
16:59:32 <Axman6> :t (id <$ show)
16:59:33 <lambdabot> Show a1 => a1 -> a -> a
16:59:36 <Hijiri> or [fromInteger 1, [fromInteger 2, fromInteger 3], fromInteger 4]
16:59:54 <folex> so haskell tries to convert `Num t => t` to `Num [t] => t` ?
17:00:07 <eitan_chatav> yes, but the two fromInteger's there are different (different ranges)
17:00:19 <folex> thanks
17:00:21 <Hijiri> it's just Num [t] => [t]
17:00:56 <Hijiri> it tries to convert the literal into whatever fromInteger is for the type you want it to be
17:01:04 <eitan_chatav> Haskell looks for a typeclass to give it a fromInteger :: Integer -> t and another one fromInteger :: Integer [t]
17:01:04 <Hijiri> s/into/using/
17:01:09 <Welkin> how do I get syntax highlighting for shakespearean template languages in emacs?
17:01:51 <eitan_chatav> [fromInteger 1 :: [t], [fromInteger 2 :: t, fromInteger 3 :: t], fromInteger 4 :: [t]]
17:02:09 <eitan_chatav> bye
17:06:15 <xendo> hey guys (and girls) i have a question: why do people seem to hate Haskell so much?
17:06:24 <xendo> I just started learning, and I'm seeing some people who really don't like it
17:06:47 <Welkin> why does the universe exist?
17:06:47 <_d0t> xendo: small penis problem
17:06:48 <benzrf> xendo: lots o people seem to think its a language for ivory tower intellectuals
17:06:53 <_d0t> sorry, no other explanations
17:06:54 <exio4> they just haven't tried it!
17:07:01 <benzrf> which is true in comparison to C, but...
17:07:13 <Welkin> we have evidence that even philistines like benzrf can use it
17:07:16 <Welkin> that must count for something!
17:07:44 <exio4> if I can write working code with monad transformers, any programmer can use them!
17:08:03 <xendo> exio4: i'll let you know about that when i get there haha
17:08:47 <exio4> xendo: I am still learning Haskell, and I learn "some new cool thing" every day :P
17:08:56 <folex> xendo: why do you care?
17:09:03 <Welkin> everyone is "still learning" haskell
17:09:10 <Welkin> even the creators
17:09:13 <folex> there are haters for every possible things
17:09:23 <Welkin> it is always evolving
17:09:29 <Welkin> and new features are added all the time
17:09:42 <exio4> that is why Haskell is amazing! ;)
17:09:51 <xendo> folex: oh i was just curious
17:10:05 <Hijiri> haskell is made of composable cool things
17:10:07 <folex> there people who hare curiosity
17:10:08 <xendo> Seems like a lot of hate going around for one language
17:10:20 <folex> and a lot of hate going around hate
17:10:29 <folex> just don't give a f*ck
17:10:36 <xendo> i think anything that can make you think differently is a good thing
17:10:40 <folex> do what you're interested in :)
17:10:42 <xendo> which is why i'm learning haskell
17:11:36 <Welkin> while programmer whine about which language is superior, the people *using* the products they create don't know or care about any of it
17:11:46 <Welkin> programmers*
17:11:50 * hackagebot term-rewriting 0.1.2 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.1.2 (BertramFelgenhauer)
17:12:31 <xendo> Welkin: that's very true
17:13:03 <Welkin> debate over which tool is superior are useless
17:13:08 <Welkin> programming languages are like religions
17:13:50 <Hijiri> you could be more productive in one language than another
17:13:54 <zwer> useres care, though, how reliable their program is. whether it has any vulnerabilities.. how fast are new features added. language choice affects all of those things
17:15:09 <hexagoxel> lets argue about language arguments! typical haskell programmers and their abstractions..
17:15:26 <Hijiri> php and it's agility
17:15:32 <Hijiri> its
17:16:15 <Welkin> no matter how crappy php is as a programming language
17:16:23 <Welkin> big businesses were built on it
17:16:24 <absence> which variant of vector is best for a non-mutable array of doubles? unboxed? storable?
17:16:33 <Welkin> and millions of people still rely on it for their websites
17:17:01 <CoverSlide> PHP is like the new COBOL
17:17:48 <Welkin> people will use whatever is available and easily accessible, not what is best
17:18:04 <Welkin> whatever "best" means in this context is up to you
17:18:44 <Hijiri> I'm not sure if anyone mentioned a language being the "best"
17:18:52 <Welkin> for an intended task
17:19:16 <Hijiri> but people did mention runtime safety, extensibility, and people could mention reducing complexity
17:19:59 <benmachine> the idea that it doesn't matter what programming language people use is false, and I honestly believe it's so false it's actively harmful
17:20:32 <Rembane> If it was false, we could do some really impressive work in brainfuck or another Turing tarpit-language.
17:20:33 <peddie> absence: try unboxed
17:21:01 <Welkin> benmachine: why is it harmful?
17:21:03 <simon> analogy: it doesn't matter what tool a carpenter uses. :P
17:21:20 <benmachine> Welkin: because it dissuades people from improving their tools
17:21:30 <Welkin> benmachine: it does not
17:21:30 <benmachine> which leads them to continue to use and promote terrible tools
17:21:34 <geekosaur> "you can lead a horse to water..."
17:21:37 <Welkin> the people who want better tools will build them
17:21:55 <simon> geekosaur, that reminds me of the programming language Homespring. bad idea.
17:22:05 <Hijiri> well it's good to have more people wanting better tools
17:22:22 <benmachine> it is possible, and not even that hard, to make tools which are better for everyone. no tradeoffs, just better.
17:22:43 <benmachine> we need to recognise the potential for progress before we can even hope to achieve it
17:23:38 <Welkin> what do you mean by "progress"?
17:23:59 <geekosaur> the problem there is "we need to recognize..." many programmers don't recognize either the potential or the need.
17:24:02 <benmachine> I mean, making programming easier: making mistakes easier to avoid and detect and correct
17:24:17 <benmachine> making ideas easier to communicate and develop
17:24:24 <Welkin> most people die without contributing much of anything to the world as an individual
17:24:32 <Welkin> there are some notable exceptions in history
17:25:18 <benmachine> the only reason most people don't contribute a significant percentage to all human achievement and welfare is that there's actually a huge amount of achievement and welfare
17:25:44 <benmachine> making merely ten thousand people's lives better is like 0.001% of all humanity
17:26:01 <benmachine> so a lot of things feel insignificant in the big picture, but they are not
17:26:45 <Hijiri> I don't see how this is relevant to the rest of the argument anyway, even if a small fraction of people contribute, those people need to see the space to contribute
17:27:25 <benmachine> yeah I'm just generically arguing against cynical everything-is-always-the-same pessimism now :P
17:27:34 <absence> peddie: that was my gut feeling, thanks :)
17:27:37 <CoverSlide> so... tl;dr php sucks
17:27:56 <Welkin> it only takes one person to act as the catalyst for change
17:28:01 <benmachine> php sucks, and yet is monumentally better than php of even just a few years ago
17:28:07 <benmachine> progress!
17:28:12 <Hijiri> someone has to decide to be the catalyst
17:28:19 <Welkin> but why the altruism about programming languages?
17:28:20 <Hijiri> or at least do it inadvertently
17:28:42 <Welkin> do you not just want to promote your flavor of ice cream above the others?
17:28:46 <CoverSlide> perl -MCPAN -e 'install Catalyst'
17:29:14 <Hijiri> not really
17:29:16 <exio4> would you replace the if in this code with "bool"? http://lpaste.net/7445469027595452416
17:29:21 <Hijiri> if we're being literal about ice cream
17:29:31 <Welkin> we're not
17:29:59 <Hijiri> I don't think it's a good analogy, you don't use ice cream to perform some work
17:30:07 <benmachine> exio4: I'd basically almost never use bool, but only because it's not widespread enough that others can easily recognise it
17:30:08 <Hijiri> except maybe experience nice taste
17:30:15 <Hijiri> in that case I would be interested in tastier ice creams
17:30:56 <exio4> oh, ok, any random suggestions for the code?
17:31:10 <Welkin> exio4: add a purple cow
17:31:38 <exio4> err. ok? ;P
17:31:57 <benmachine> exio4: I wonder if you really need the state monad, instead of just ordinary functions
17:31:59 <Hijiri> bool might be good
17:32:14 <Hijiri> since you're making a function anyway
17:32:40 <exio4> benmachine: it is an "interpreter" of http://esolangs.org/wiki/Deadfish
17:32:41 <benmachine> exio4: is it the case that stuff after the last o in the string is basically discarded?
17:33:13 <Hijiri> actually nevermind about my input
17:33:24 <Hijiri> it's not as clear as I thought it was
17:33:35 <exio4> benmachine: should be, the "o" is the print command of the language
17:34:58 <benmachine> exio4: how about splitting the input string on 'o' characters, and folding the "words" so obtained into a single value to print?
17:35:06 <Welkin> does anyone know how to add support for synta highlighting in hamlet and other template languages?
17:36:01 <Axman6> Welkin: it will depends on your editor. you'll probably have to write a syntax definition file though
17:36:38 <Welkin> here is one: https://github.com/lightquake/hamlet-mode
17:36:43 <exio4> benmachine: sounds like that would work, will try later, any other suggestion?
17:37:22 <exio4> another*?
17:37:47 <benmachine> exio4: if my suggestion doesn't work, try doing something simpler that still isn't using the state monad :P
17:38:15 <benmachine> exio4: generally speaking, State is only necessary if you find yourself wanting to manipulate a state *while doing something else*
17:38:24 <benmachine> while returning some other value
17:38:43 <benmachine> e.g. State String a might consume some input from the String and use it to produce an a
17:38:51 <benmachine> thus StateT String Maybe a is a simple parser type
17:38:54 <xendo> (quick question about irc: is it possible to prevent all of the joining/leaving messages?)
17:39:04 <benmachine> xendo: many clients can choose to ignore them
17:39:15 <xendo> thanks!
17:39:20 <benmachine> every time I've done so I've ended up talking to someone who isn't there, which is pretty awkward :P
17:39:28 <mrenaud> ignore #haskell MODES JOINS PARTS QUITS
17:39:34 <benmachine> but yeah, what to do will depend on what your client is
17:39:38 <mrenaud> With a leading /
17:40:02 <mrenaud> For irssi anyways
17:40:20 <exio4> yep, but I just went for State because it is a language with just some 'global' state that changes, I actually realized I could abuse it a little bit for playing with monad transformers :P
17:40:28 <benmachine> exio4: anyway, if your State result types are always () or the result of get, I start being suspicious that you don't actually need to both mutate a state and return a value
17:40:37 <hexagoxel> exio4: runS is a mapM_, isn't it?
17:40:54 <Welkin> yesod is pretty nice
17:41:00 <benmachine> oh, good call hexagoxel, that is also true
17:41:01 <Welkin> now that I took the time to read the book
17:41:26 <exio4> I think it is
17:41:50 <benmachine> exio4: well, you can abuse monad transformers for your own entertainment, but I recommend trying the non-State approach, if only for comparison purposes
17:42:39 <clrnd> hey, how do I static link on modern GHC?
17:42:47 <exio4> will try, thanks!
17:42:49 <clrnd> (the wiki talks about GH 6)
17:42:53 <Hijiri> static linking is the default
17:43:05 <clrnd> ldd seems to disagree on that
17:43:08 <Hijiri> I don't know the option for explicitly static linking though
17:43:26 <Hijiri> is it for libgmp or something?
17:43:42 <clrnd> ldd says it links to libgmp
17:43:51 <clrnd> no idea what it is though
17:44:13 <Hijiri> it's a math library
17:44:18 <Hijiri> arithmetic
17:44:47 <Hijiri> stackoverflow says -optl-static -optl-pthread
17:44:50 <clrnd> before going trough useless complications, what I need this is for a CLI tool we will be using @ the office
17:44:52 <Hijiri> https://stackoverflow.com/questions/10539857/statically-link-gmp-to-an-haskell-application-using-ghc-llvm
17:45:02 <clrnd> if they install the libraries, it should run fine right?
17:45:09 <clrnd> people just don't want to install GHC
17:45:22 <Hijiri> yeah, you don't need ghc, but you'd need the libraries the runtime links to
17:45:48 <clrnd> mmm but I'm using GHC 7.8, and ubuntu probably doesn't have the latest libs
17:46:00 <clrnd> opt-static breaks the binary btw
17:46:03 <clrnd> already tried that
17:46:21 <clrnd> it's interesting, it compiles and runs but Network.Client can't connect
17:46:49 <clrnd> it throws a FailedConnectionException2
17:46:54 * hackagebot hasql-postgres 0.1.1 - A "PostgreSQL" driver for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.1.1 (NikitaVolkov)
17:46:57 <Hijiri> did you use -pthread too?
17:47:10 <Hijiri> the stackoverflow page has people saying it failed without it
17:47:39 <clrnd> let's try
17:48:04 <clrnd> (I tried lot's of things so not sure but I'll do it anyway)
17:50:00 <clrnd> while it compiles, I have profiling enabled in my global cabal file, can I disable it for the project?
17:51:28 <Hijiri> you can set a sandbox to not (or do)profile
17:51:59 <Hijiri> by setting the config file in there
17:52:50 <fragamus> what's your favorite CSV parser
17:53:04 <fragamus> I need to grab one and use it and I want to know what people like
17:55:21 <clrnd> that worked thanks (the not profiling)
17:55:27 <clrnd> executable still fails, with pthread
17:56:20 <Hijiri> well it was worth a try I guess, I've never tried statically linking everything myself
17:56:52 <solatis> is there anyone here that's familiar with haskell & continuations and the continuation monad?
17:57:18 <Axman6> probably lots of people, what's the question?
17:57:22 <____________Josh> I want to start hacking, heard about this awesome group  (Haskell) and wanted to know if you guys can give me some beginer material
17:57:40 <Axman6> @where lyah
17:57:40 <lambdabot> http://www.learnyouahaskell.com/
17:57:45 <Axman6> ____________Josh: ^^^^
17:57:56 <Hijiri> have you tried looking at the contents of FailedConnectionException2?
17:57:58 <solatis> Axman6: i'm trying to deuglify some code and i have the feeling continuations are the solution
17:58:18 <____________Josh> thank you, anything else ?
17:58:27 <Axman6> @where RWH
17:58:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:58:40 * c74d recommends RWH.
17:58:44 <Axman6> @google bitemyapp haskell introduction list
17:58:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:58:52 <Axman6> try those
17:59:12 <clrnd> Hijiri, handleHttp (FailedConnectionException2 host port _ _) = "Connection refused with " ++ host ++ ":" ++ show port ++ ", is the server running?"
17:59:18 <c74d> ____________Josh: But see also `/query welpbot @where RWH`.
17:59:19 <clrnd> that works exactly as expected
17:59:24 <lpaste> solatis pasted “Is this a good candidate for continuations?” at http://lpaste.net/113289
17:59:24 <Axman6> ____________Josh: you should probably start with bitemyapp's learnhaskell stuff, it had a good list
17:59:25 <clrnd> so no idea :P, was just checking that
17:59:34 <Hijiri> what about the last field?
17:59:42 <solatis> Axman6: see that paste
17:59:45 <clrnd> docs say it's 'secure :: Bool'
17:59:49 <Hijiri> the last field is supposed to be SomeException
17:59:54 <clrnd> oh yeah
17:59:55 <Hijiri> the third one is Bool
18:00:00 <clrnd> hey you are right, lets see
18:02:22 <clrnd> Hijiri, interesting, I googling it, it said:
18:02:26 <____________Josh> Thank you <lambdabot>
18:02:29 <clrnd> getAddrInfo: does not exist
18:02:55 <benzrf> ____________Josh
18:02:57 <benzrf> what a NICK
18:03:19 <haasn> (Homework alert) I'm stuck on an optimization problem. The goal is to write a program that will read a large number of inputs, and every now and then (upon receiving a special input) write back the K-th smallest input that has been read so far. (K is determined at runtime). For example, for K=2 and the inputs [17,3,5,REPORT,9,REPORT,1,REPORT] the reports would be 5, 5 and 3, respectively. The way I'm
18:03:20 <haasn> approaching the problem is by modeling it as a max-heap offixed size k (= O(1) read-out of the current value), and every time a new number is read that is smaller than the current k-th smallest, I replace the top item in the heap by the new number and restore the heap operation by shuffling it down (O(log n)). This seems pretty optimal me, and the accompanying exercise sheet also introduces max-heaps (and
18:03:22 <haasn> hints that we should probably use them for the programming problem), so I'm sure that using a max heap is intended. However, I'm getting program timeouts for the larger sample sizes and I'm lost at what else I could improve. Would anybody mind looking at my code? http://lpaste.net/113291
18:03:43 <benzrf> hey, is there a way to temporarily turn numeric literals into monomorphic ints?
18:03:44 <haasn> I also tried rewriting it using a mutable STUArray, but while that shaved the execution time for the smaller test cases from ~5s down to ~4s, it still timed-out on the 20s and 30s test cases
18:03:55 <benzrf> i wanna tutorialize a dude and dont wanna bring typeclasses into it too early
18:03:56 <haasn> Maybe my heap is being deliberately imbalanced in those test cases?
18:04:08 <benzrf> like, make (+) :: Int -> Int -> Int
18:04:10 <haasn> I think some kind of self-balancing heap structure might be more optimal here
18:06:56 <____________Josh> <benzrf> just because I said thankyou?
18:07:41 <MP2E> I think he's more poking fun at the fact that your name is prefixed by many underscores
18:09:06 <benmachine> benzrf: it's possible with RebindableSyntax and NoImplicitPrelude, but perhaps scary
18:10:11 * clrnd is giving up on static linking
18:11:07 <Hijiri> I think the line in the getAddrInfo function that's creating that exception is mkIOError NoSuchThing "getAddrInfo" Nothing
18:11:09 <Hijiri>                               Nothing
18:11:17 <Hijiri> but I can't find where NoSuchThing is defined
18:12:10 <Welkin> haasn: textbook exercises that have nothing to do with anything you will ever come across
18:13:59 <benzrf> benmachine: hhhhhhhh h   mmmmmmmmmm
18:14:14 <benzrf> tricky.
18:14:39 <Welkin> benzrf: your brother?
18:14:57 <Welkin> or you are twins
18:15:03 <Welkin> but which one is the evil one?
18:15:22 <Welkin> I suppose it depends on the perspective of the viewer
18:16:00 <clrnd> already turned to people into xmonad, how many have you evangelized so far guys?
18:16:24 <MP2E> not many, but maybe it's because I'm bad at explaining at things :P
18:16:38 <Welkin> I got quite a few people interested in haskell
18:16:44 <Welkin> some that don't even program
18:16:59 <MP2E> I've only managed to get one friend convinced, and he hadn't programmed before
18:17:12 <MP2E> can't seem to convince my friends that are programmers though x.x
18:17:34 <clrnd> mmmm haskell is trickier, I have no success stories
18:19:57 <clrnd> gotta go, thanks Hijiri for your help
18:21:44 <Hijiri> np, sorry that it didn't get solved
18:27:51 <benzrf> Welkin: i am unrelated to benmachine !
18:29:53 <Fuuzetsu> is what benmachine would say
18:30:23 <benzrf> D:
18:30:23 <mrenaud> I've considered switching to xmonad, but I already have i3 configured exactly how I want
18:30:41 <fuzzyhorns> curious what you all thing: are types fundamental to functional programming or orthogonal to it?
18:31:01 <Fuuzetsu> mrenaud: but no matter how hard you try, your i3 config is not in Haskell so it will always feel dirty
18:31:19 <Fuuzetsu> fuzzyhorns: types are fundamental to all programming
18:31:49 <fuzzyhorns> Fuuzetsu: id say that myself, but do you think functional programming is orthogonal to that set of concerns?
18:32:09 <mrenaud> Fuuzetsu: Haha, this is true. Maybe one day when I have an abundance of free time :P
18:32:47 <Fuuzetsu> fuzzyhorns: no, I just think functional programming tends to take the more ‘theoretical’ approach to things so we aren't scared of things like types
18:33:34 <fuzzyhorns> Fuuzetsu: if you were to separate types from functional programming, what would you see as left in functional programming?
18:34:20 <Fuuzetsu> a whole lot of pain probably
18:35:11 <Fuuzetsu> I just think that functional programs lend themselves nicely to nice typesystems and taking that away would cripple the language
18:35:36 <solatis> with type systems you mean type classes?
18:35:44 <Fuuzetsu> no, I mean type systems
18:35:46 <fuzzyhorns> "static type systems prove type safety, i.e. that the properties of progress and preservation hold on well typed terms.  This is an orthogonal concern to whether or not the language is purely functional."
18:35:53 <fuzzyhorns> something a colleague is saying, do you agree?
18:35:54 <solatis> ah right
18:36:19 <fuzzyhorns> Fuuzetsu: i guess i am trying to think of a good functional language without types, do you know of an example? I am rather a newb
18:36:58 <Fuuzetsu> fuzzyhorns: yes, he's right; the concern here is that it's easier to implement nice type system in purely functional language, reasoning becomes harder if you have to deal with impurity and really hard if you have manual memory management
18:37:12 <Fuuzetsu> fuzzyhorns: I don't know of any good language without types.
18:37:18 <solatis> sorry english being not my native language, 'orthogonal' in this context means you can't have a purely functional language without type systems?
18:37:41 <Fuuzetsu> no types is a pretty good way to send a language to my ‘trash languages’ list
18:37:44 <fuzzyhorns> solatis: it would mean in this context, you can easily have a purely functional language without type systems
18:38:04 <fuzzyhorns> Fuuzetsu: its the same for me at this point but I am trying to think broadly
18:38:35 <Fuuzetsu> put that thought into writing better types rather instead ;P
18:38:39 <solatis> ok
18:38:53 <solatis> that would leave you with a language like, for example, purescript? http://purescript.readthedocs.org/
18:39:23 <Fuuzetsu> you *can* have a purely functional language without types, it's just severely crippled
18:39:32 <fuzzyhorns> would you think of a dynamically typed language as "less" functional?
18:39:35 <Fuuzetsu> I would still rather use purely functional language without types than imperative one without types
18:39:37 <fuzzyhorns> Fuuzetsu: how would you say it is crippled?
18:39:44 <fuzzyhorns> Fuuzetsu: fair
18:40:21 <solatis> you can use a lot of imperative languages in a functional style, tho -- take python for example
18:40:25 <Fuuzetsu> dynamically typed language is a stupid notion
18:41:05 <solatis> Fuuzetsu: 'runtime evaluated typed language' doesn't have the same ring to it tho
18:41:07 <simpson> Does "purely functional" mean anything yet?
18:41:22 <fuzzyhorns> simpson: i do wonder
18:41:36 <Fuuzetsu> simpson: depends who you ask and how much morale stretching you're willing to do ;P
18:42:00 * hackagebot whiskers 0.1.0.0 - Moustache templates with Template Haskell.  http://hackage.haskell.org/package/whiskers-0.1.0.0 (peter)
18:42:11 <simpson> Fuuzetsu: How about this: It means nothing.
18:42:23 <Fuuzetsu> solatis: types are not things at runtime
18:42:37 <Fuuzetsu> solatis: typeof(foo) in Python doesn't give you a type
18:43:10 <simpson> Fuuzetsu: It's type(), and it gives you an object that you would probably still not acknowledge as a type.
18:43:19 <Fuuzetsu> simpson: it's a useful term to classify things under
18:43:28 <Fuuzetsu> yeah, sure, type()
18:43:48 <Fuuzetsu> and you're right, I don't acknowledge it as a type
18:43:53 <benzrf> Fuuzetsu: tsk
18:44:03 <Fuuzetsu> it's as much of a type ask the string "int" in Haskell
18:44:04 <benzrf> Fuuzetsu: just accept that python is dependently typed and get on with it 8D
18:44:05 <Fuuzetsu> as the*
18:44:24 <solatis> just for the sake of argument, would c++ template metaprogramming be a purely functional language?
18:44:35 <Fuuzetsu> from what I heard it is, yes
18:44:39 <solatis> it's one of the ugliest languages in the world and hardest to work with
18:44:48 <Fuuzetsu> benzrf: is it dependently typed because what type() gives depends on the phase of the moon?
18:44:50 <benzrf> solatis: https://xkcd.com/1432/
18:45:00 <benzrf> Fuuzetsu: no, because types and values live at the same level!
18:45:03 <benzrf> ( ͡° ͜ʖ ͡°)
18:45:18 <solatis> benzrf: haha that made me laugh
18:45:18 <Fuuzetsu> benzrf: you can't live on the same level with something that doesn't exist
18:45:27 <Fuuzetsu> although I should remember that one
18:45:32 <Fuuzetsu> quality joke
18:46:43 <simpson> So, I was thinking more about this. "Functional" means that one can create functions at runtime with closures over values, and that functions are first-class values, right?
18:46:54 <simpson> So what's the "pure" part?
18:47:01 * hackagebot postgresql-simple 0.4.7.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.7.0 (LeonSmith)
18:47:08 <monochrom> Int->Int does not have effects
18:47:53 <simpson> As long as it doesn't use seq or anything unsafe in GHC, right?
18:47:59 <Fuuzetsu> simpson: problem with that definition is that a lot of things can fall under that
18:48:00 <davidstone> Calling a function and not looking at its result is the same as not calling the function at all
18:48:02 <benzrf> seq is pure
18:48:02 <monochrom> f 5 always gives you the same thing
18:48:08 <Fuuzetsu> which is why you hear people calling JS a functional language
18:48:28 <simpson> Fuuzetsu: I don't think that it's a problem to admit that JS, Python, and Smalltalk have something in common with Lisps, MLs, and Haskell.
18:48:42 <Fuuzetsu> you can emulate functions in Java with an interface and you can pass those around does it make it functional?
18:48:44 <monochrom> for example, in SML, f 5 can give you 0 the first time, 1 the second time...
18:48:56 <solatis> Fuuzetsu: what about scala?
18:49:04 <Fuuzetsu> What about scala?
18:49:04 <dmj`> so in haddock, I'm required to put a module header, when I go to annotate the module inside of the module (..) part the generated documentation shows at least to blank lines before those annotations are seen, because of the module header. Can I use a module header w/o incurring the extra white space?
18:49:07 <solatis> well
18:49:14 <dmj`> two*
18:49:31 <Fuuzetsu> simpson: it's not about having something in common, it's about calling something ‘functional’ upon a technicallity rather than what it is as a whole
18:49:49 <simpson> monochrom: If f 5 prints "42" to the console and returns 42, every time, it's not pure, correct?
18:49:56 <Fuuzetsu> you wouldn't look at a JS program and describe it as a functional language as the first thing
18:50:07 <simpson> Fuuzetsu: Technically correct is the only kind of correct in a technical context. :3
18:50:13 <solatis> scala is kind of like the opposite of javascript -- people calling javascript 'functional' because you can emulate a functional style in it. scala calls itself a functional language that allows you to do non-pure things, so to emulate an imperative language
18:50:45 <monochrom> the effect of print makes it impure, yes. because now "let x = f 5 in x+x" prints different things from "f 5 + f 5"
18:50:49 <Fuuzetsu> dmj`: post actual code, sample output, expected output and Haddock version
18:51:14 <fuzzyhorns> another question, how would you related UNtyped lambda calculus to http://en.wikipedia.org/wiki/Lambda_cube ?
18:51:40 <solatis> we should continue this conversation in #haskell-blah
18:51:56 <simpson> Okay. So purity only works when you're talking about what's in the Report. It doesn't work when you exercise the full range of GHC's extras. Yes?
18:52:12 <monochrom> I agree with that.
18:52:16 <fuzzyhorns> solatis: i didnt even know haskell blah was a thing
18:52:50 <solatis> fuzzyhorns: after 2 months of monitoring this channel, my conclusion is that it has a tendency to go off-topic :)
18:52:54 <monochrom> well, unless you look into the FFI chapter and find that you can declare an arbitrary C procedure to be of type Int->Int
18:52:57 <simpson> Okay. So I feel like I could justify the sentiment that Haskell is pure but most code is in an impure superset.
18:53:21 <monochrom> if you say "most" then you need real statistics to justify
18:53:42 <dmj`> Fuuzetsu: that's a lot of work
18:53:47 <fuzzyhorns> solatis: as it is with all channels?
18:54:00 <fuzzyhorns> so any input on untyped lambda calculus and the lambda cube?
18:54:05 <monochrom> because the consensus is that unsafePerformIO is actually used sparingly, not mostly.
18:54:12 <Fuuzetsu> what inptu are you even after
18:54:22 <Fuuzetsu> input*
18:55:03 <guestaccount11> I don't want to sound rude but is there a way to learn Haskell without feeling like a blithering idiot?
18:55:05 <simpson> But unsafePerformIO isn't the only one, right? unsafeCoerce, unsafeInterleaveIO, etc.
18:55:22 <monochrom> all them them added together is still sparingly.
18:55:33 <Fuuzetsu> guestaccount11: sure, read LYAH or something then start pumping out code, asking stuff you don't know
18:55:45 <fuzzyhorns> it is normal to feel a bit dumb anyhow :)
18:55:48 <hiptobecubic> guestaccount11, why would you want that?
18:56:11 <fuzzyhorns> do typed lambda calculi normal to untyped?
18:56:18 <fuzzyhorns> normalize*
18:56:19 <guestaccount11> Fuuzetsu: tried that; didn't work.
18:56:25 <solatis> guestaccount11: my experience is that this channel is quite friendly towards beginners
18:56:35 <fuzzyhorns> solatis: same x)
18:56:46 <Fuuzetsu> guestaccount11: join an existing project, pump out code and ask what you don't know
18:56:54 <fuzzyhorns> guestaccount11: it may take a few tries, i found just noodling around on codewars.com helpful
18:56:58 <solatis> guestaccount11: what is your previous experience with functional languages ?
18:57:04 <guestaccount11> hiptobecubic: because otherwise I feel as if the language is not worth the time when, on some level, I know it is.
18:57:40 <solatis> since in my case, going from imperative to haskell was too much a learning curve, and i had to use an intermediate language to understand some concepts better
18:58:22 <jle`> guestaccount11: i think...it might be worth it as a life skill to learn to accept feeling like an idiot sometimes :)
18:58:31 <Fuuzetsu> that seems like it has a great potential to backfire where you just learn the intermediate language instead and come in with misconceptions when you go into Haskell again
18:58:36 <hiptobecubic> If you don't feel like an idiot then you probably aren't learning to fly, you're just finding new places to point your catapult.
18:58:49 <guestaccount11> solatis: I have heard that about this channel, which is all well and good except for the fact, the has/needs to be some sort of definitive "here's the simplest way to learn Haskell" style document so as to avoid scaring off people.
18:58:55 <jle`> guestaccount11: it might help if you think about a time where you have had trouble in the past
18:59:03 <jle`> guestaccount11: like...when you first learned how to program
18:59:18 <jle`> guestaccount11: and see that you are now over it just after working hard and perservering :)
18:59:21 <Fuuzetsu> guestaccount11: there is no easiest way, it depends on person and what they know already
18:59:25 <guestaccount11> solatis: also, the experience is very little; I come from "C++ land".
18:59:41 <jle`> guestaccount11: did you ever feel stupid when learning C++?
18:59:46 <jle`> or programming originally?
18:59:48 <monochrom> I didn't feel like an idiot. I felt like a child. but I liked childhood, and still like.
18:59:55 <hiptobecubic> modern C++ or old school C++?
19:00:20 <Fuuzetsu> chances are guestaccount11 doesn't know C++, just some limited subset ;P
19:00:37 <hiptobecubic> Fuuzetsu, well sure. But by that measure no one knows it and the discussion is pointless
19:00:46 <guestaccount11> jle`: I learned C/C++ programming at the local community college and about 2 decades of industry.
19:01:16 <folex> 2 decades of C/C++ only?
19:01:17 <guestaccount11> jle`: no, I did not.
19:01:29 <benzrf> guestaccount11: and did you not feel like an idiot when you couldnt figure out how to do x and then somebody showed you 1 line of code that does it?
19:01:35 <guestaccount11> folex: primarily, yes.
19:01:41 <folex> oh WOW
19:01:46 <folex> that's…
19:01:54 <hiptobecubic> a lot of typing?
19:02:00 <folex> creepy
19:02:01 <guestaccount11> benzrf: actually, with C/C++, no, I had very little trouble picking them up.
19:02:02 <Fuuzetsu> more like not enough typing
19:02:08 <hiptobecubic> HEYOOOOO
19:02:21 <folex> it's like a horror story for me
19:02:24 <hiptobecubic> anyway
19:03:16 <folex> "and thus he was made to program in C++ for eternity. And the compiler was buggy and off the spec"
19:03:21 <Yxven> I don't think there's a way to learn Haskell without feeling like an idiot. You just have to accept that and keep pushing
19:03:22 <folex> brr
19:03:48 <hiptobecubic> guestaccount11, the problem is that you're totally immersed in the C and C++ way of doing things, especially if you haven't really worked with any other languages at all. You need to let go of the idea that the way you'd do it in C is the 'normal' way. It's like trying to learn french by translating from english in your head. It doesn't work at all.
19:03:49 <bam365> Haskell made me feel like I was 13 again for a few months...I liked it, though
19:03:53 <benzrf> Yxven: well, if you know ML ahead of time :p
19:04:09 <benzrf> and also some basic CT, abstract algebra, and CS
19:04:17 <Hijiri> guestaccount11: bitemyapp's guide has more resources if you need more than lyah https://github.com/bitemyapp/learnhaskell
19:04:17 <hiptobecubic> It's a different way to express problems entirely and there isn't a good analogy in C or C++ for most of it.
19:04:17 <solatis> guestaccount11: great, i came from c++ land too
19:04:28 <benzrf> guestaccount11: i have a theory
19:04:39 <solatis> guestaccount11: the takeaway is that you're probably familiar with a lot of FP due to TMP already -- think about c++ Concepts, for example
19:04:46 <benzrf> guestaccount11: my theory is: when you learned c++, not knowing how to do things felt natural because you were new to programming
19:05:10 <benzrf> guestaccount11: but now that you see yourself as Knowing How To Programming, being helpless in haskell feels like you're an idiot
19:05:18 <guestaccount11> solatis: C++ doesn't have concepts.
19:05:23 <benzrf> lol
19:05:31 <guestaccount11> They were voted out of the proposed standard.
19:05:36 <guestaccount11> I know because I was there.
19:05:39 <Fuuzetsu> not sure if kidding
19:05:45 <guestaccount11> nope
19:05:48 <guestaccount11> not kidding
19:05:49 <Fuuzetsu> he doesn't mean ‘concepts’ he means ideas
19:05:53 <guestaccount11> oh
19:05:56 <guestaccount11> I see
19:05:56 <bam365> lol
19:06:00 <davidstone> The capitalization probably means he means the feature "conceptS"
19:06:08 <davidstone> Not the general idea of a concept
19:06:15 <bam365> "concepts"...apparently the only thing ever rejected from the C++ standard
19:06:16 <davidstone> Concepts in C++ are a way to constrain templates
19:06:20 <Fuuzetsu> oh, maybe I should have read the fuck up
19:06:23 <folex> hiptobecubic: If you try to write good code in C/C++/Java, you'll end up with a lot of ideas in common with FP. Immutability, referential transparency and so on.
19:06:49 <hiptobecubic> folex, that really depends on what you're writing and what the goal is
19:06:50 <Fuuzetsu> anyway I didn't know C++ Concepts™ were voted out
19:06:54 <Fuuzetsu> I thought they were going in
19:06:58 <hiptobecubic> hah really?
19:07:28 <davidstone> It's probably the most controversial thing in C++ right now, the future of concepts
19:07:32 <davidstone> And then "Concepts Lite"
19:07:44 <guestaccount11> benzrf: Your theory may be right except for the fact I picked up Python, Ruby, Scheme, etc. pretty quickly; not that I do much with them any more.
19:07:48 <folex> hiptobecubic: If you try to write some complex project with a lot of inner dependencies, external communication and multithreading
19:07:59 <folex> so, basically, any project nowadays
19:08:02 <benzrf> guestaccount11: wrong
19:08:12 <guestaccount11> ???
19:08:14 <benzrf> if python and ruby are n away from c++
19:08:20 <benzrf> then scheme is 3n away
19:08:25 <benzrf> and haskell is 20n away
19:08:27 <benzrf> or somethin
19:08:44 <benzrf> haskell is *radically* different at a fundamental level
19:08:50 <benzrf> to a greater extent than any of those
19:09:09 <guestaccount11> it's more like programming thru mathemtical expressions, yes?
19:09:16 <benzrf> ish
19:09:34 <folex> guestaccount11: if you have no problem in getting Python/Scheme pretty quickly, you should just practice haskell. It will be hard at the beginning because of a lot of reasons, but good books and community (e.g. this room) will help
19:09:49 <hiptobecubic> guestaccount11, yes, python and ruby are extremely similar and very c++-like. Scheme is very flexible and it's likely that your scheme looks like your python code anyway (I could be wrong, but ... probably not)
19:10:06 <solatis> guestaccount11: it took me about 2 - 4 weeks fulltime to get anywhere near productive and 'actual code' being produced
19:10:18 <fuzzyhorns> http://existentialtype.wordpress.com/2011/03/16/what-is-a-functional-language/
19:10:21 <hiptobecubic> one thing that separates haskell i think is that it just flatly doesn't let you pretend to be in some other language like python and scheme and ruby and scala and whatever else do
19:10:26 <solatis> but now after 8 weeks, i'm still continuously refactoring my code with the new things i learn
19:10:27 <fuzzyhorns> "So we have to use a language that is ill-defined (admits programs that cannot be given any meaning in terms of the language itself)"
19:10:37 <folex> guestaccount11: haskell isn't any different from let's say java. It's just has different conceptc and forcing them more strictly, you just have to get to know and feel them
19:10:58 <hiptobecubic> folex, it's definitely different
19:10:58 <fuzzyhorns> but isnt any program of logic explicitly one that admits such programs?
19:11:02 <hiptobecubic> it's non-strict for one
19:11:05 <hiptobecubic> that has huge implications
19:11:07 * solatis remembers his first time trying to understand pointers
19:11:17 <solatis> it's very difficult to explain to people
19:11:18 <folex> hiptobecubic: no it is not. Don't say that to beginners.
19:11:29 <folex> it's different in concept, but difference isn't HUGE
19:11:43 <TallerGhostWalt> anyone know a good .prof manipulation utility?
19:11:46 <guestaccount11> So, if I failed to make any headway thru LYAH, CIS 194, and the Typeclassopeadia, I should ... ? (Because that's where I am at. Multiple failures with each.)
19:11:49 <TallerGhostWalt> like prof 2 html
19:11:50 <hiptobecubic> folex, pretending haskell is "like java with real types" is a disastrous approach
19:11:53 <folex> you can sit and go program haskell like you do in any other static typed language
19:11:53 <Yxven> the difference is pretty huge
19:11:54 <TallerGhostWalt> or prof2xlsx?
19:12:15 <hiptobecubic> guestaccount11, what constitutes failure?
19:12:16 <folex> hiptobecubic: it's okay for a man with 20+ years of programming thus with good programming intuition
19:12:24 <fuzzyhorns> i know folex is causing quite a furor but does anyone have an opinion on what i posted? :p
19:12:30 <dmj`> Fuuzetsu: Is there a way to include a module header w/o it taking up space
19:12:49 <hiptobecubic> folex, that's precisely when it's *not* good. His intuition hurts him here and gets in the way. There's a reason everyone starts with "forget what you know about programming"
19:13:05 <guestaccount11> hiptobecubic: For example, not being able to complete assignment #2 of CIS 194.
19:13:06 <solatis> guestaccount11: if you are the type of person who studies the theory before writing the code, that would be a good aproach
19:13:16 <Fuuzetsu> dmj`: Can you post actual code snippet and say which space you'd like to be gone?
19:13:26 <solatis> but personally, i haven't used LYAH or anything like that much
19:13:44 <solatis> i use github search to look up 'real world code' and try to understand that code
19:13:53 <benzrf> guestaccount11: come to #haskell-beginners for long meandering discussions elucidating the nature of the assignments
19:13:56 <benzrf> :^)
19:14:00 <folex> hiptobecubic: intuition is a good thing. Very good. You just have to improve it. Once you deny your programming intuition, you're fcked up and programming-by-books
19:14:26 <fuzzyhorns> if intuition were a solitary pursuit i would find it worrisome
19:14:40 <fuzzyhorns> but when it is a shared discussion, it seems better ;)
19:15:00 <fuzzyhorns> i dont fetishize age and experience for its own sake though
19:15:16 <fuzzyhorns> i am more of a results oriented kind of guy at this point
19:15:18 <fuzzyhorns> c:
19:15:20 <folex> hiptobecubic: there is no such thing as "broken intuition" because of some language. For immature programmers there might be, but for 2 decade polyglot programmer? Nope. He will find his way, and your job is don't scare him rightaway
19:15:35 <hiptobecubic> folex, "polyglot" meaning c and c++?
19:15:44 <fuzzyhorns> lol this is getting rather harsh
19:15:46 <folex> hipsterslapfight: also scheme, python, ruby and maybe more
19:15:57 <fuzzyhorns> not sure id count python and ruby as so different ;)
19:16:52 <dmj`> Fuuzetsu: module headers are supposed to be invisible right?
19:17:13 <Fuuzetsu> no, they are meant to go into the module header…
19:17:17 <hiptobecubic> but they said they have lived and worked in c and c++ in an industrial setting for 20 years and "picked up scheme and python and ruby". The intuition you build there is about C and C++. I'm sure it's very helpful if you're writing C and C++ programs, but you have to *rebuild* your intuition about how to approach a problem in a language like haskell
19:17:47 <folex> I'm not saying that sit in the corner and try to bend haskell to C paradigms, what I'm saying is try haskell, it's almost same as any other language out there, just a bit different. Obviously you should share your trial with community asking for code-review and help
19:18:04 <hiptobecubic> rabble rabble!
19:18:32 <hiptobecubic> guestaccount11, in conclusion. Just try some more and yes most people don't feel like they "succeed" at first.
19:18:44 <folex> hiptobecubic: I don't know about you, but in my experience programmer intuition isn't language-specific. It's rather making-things-look-beautiful-oriented
19:18:46 <gcganley> hiptobecubic: what are we talking about here?
19:18:58 <Welkin> that reminds me of c programmers learning python and writing explicit for loops rather than using the "for item in items" syntax
19:19:17 <folex> Welkin: that's just bad programmers, imho
19:19:30 <guestaccount11> hiptobecubic: Do most people, upon repeated attempts feel less and less comfortable with each try?
19:19:38 <folex> or immature ones who will fix their style after a week of practice
19:19:47 <hiptobecubic> guestaccount11, that is surely a sign that you're learning
19:19:55 <hiptobecubic> there's even a name for it
19:20:33 <folex> guestaccount11: yeah, why not. Deeper you dig into haskell, more complicated it gets. It's true for almost any technology out there. You could list your question on paper and then ask them here.
19:20:52 <folex> You'll find a lot of answers while listing them
19:21:12 <dmj`> Fuuzetsu: let me restate my question: Is a module header supposed to be invisible in regards to the documentation produced?
19:21:16 <hiptobecubic> guestaccount11, just keep asking and trying and failing and asking and trying and eventually you will stop failing as often and then you'll be a haskell programmer.
19:21:32 <Fuuzetsu> dmj`: no, it generates the module header and some of the data goes into the little box
19:21:44 <Fuuzetsu> just open any doc page in base then look at the module source
19:21:49 <Fuuzetsu> the stuff at the top comes from the header
19:22:27 <Fuuzetsu> what would be the point of module headers if they were not visible in the end?
19:25:39 <dmj`> Fuuzetsu: oh, I didn't notice that box, cool
19:25:53 <dmj`> Fuuzetsu: I was comparing my docs to the hedis docs: http://hackage.haskell.org/package/hedis-0.6.5/docs/Database-Redis.html
19:26:04 <sgronblo> fold: haskell is definitely far away from the cluster that is c-family languages
19:26:12 <dmj`> It seems there is no module header though
19:26:31 <Fuuzetsu> the source for that file doesn't have a header
19:26:39 <Fuuzetsu> so there isn't one in the doc
19:26:44 <dmj`> Fuuzetsu: but even in Control.Applicative, there are many headers, but the text still hugs the top
19:26:59 <Fuuzetsu> oh, I think there's a confusion here
19:27:06 <adarc> hey everyone.. anyone know anything about Data.Fixed? I'm trying to turn this Pico into an Int.. i'm nub'n it up.
19:27:12 <Fuuzetsu> there's module header which is the thing before ‘module Foo where’ and that goes to the top
19:27:16 <adarc> i'm failing to see how I can pull this Integer out of Fixed a
19:27:25 <adarc> newtype Fixed a = MkFixed Integer deriving (Eq,Ord,Typeable)
19:27:29 <Fuuzetsu> then there are headers which you can put between functions &c
19:27:38 <Fuuzetsu> and recently there are also headers you can put in function comments
19:28:36 <adarc> data E12 = E12 deriving (Typeable)
19:28:36 <adarc> instance HasResolution E12 where resolution _ = 1000000000000
19:28:36 <adarc> -- | resolution of 10^-12 = .000000000001
19:28:37 <adarc> type Pico = Fixed E12
19:28:59 <sgronblo> does anyone else seem to have the experience that you rarely see any intermediate haskell programmers?
19:29:00 <adarc> so i can do for example, fromIntegral (resolution pico) :: Int
19:29:18 <adarc> but i dno how to yank this value out
19:29:25 <Fuuzetsu> sgronblo: half this channel?
19:29:26 <dmj`> Fuuzetsu: yes, I'm referring to 'module header' as the text that goes above modules
19:29:50 <sgronblo> the people i've met so far have been either haskell-curious but "I'm not sure what those monads are about", and then I met one guy who had done a PhD in some FP topic.
19:30:22 <Hijiri> that's a big sample
19:30:28 <Fuuzetsu> that hedis module thing doesn't have the module header so nothing is rendered (except tiny box in top right); then the rest of the module starts, where there may be section headers and stuff
19:30:38 <Fuuzetsu> dmj`: I just struggle to understand what the question is
19:32:28 <fuzzyhorns> Fuuzetsu: can you come back, for a moment, to why you think a functional language is crippled without types? i was very curious to your point
19:34:27 <sgronblo> Hijiri: It's difficult to find people who are into haskell in the first place :)
19:36:01 <codygman-> I'm misunderstanding MaybeT, can someone help me out? http://lpaste.net/113296
19:36:07 <Hijiri> well maybe that's the issue, there just aren
19:36:13 <Hijiri> t a lot of people to find
19:36:20 <Hijiri> but if you did find them, a good portion might be intermediate
19:36:28 <adarc> i've introdoced it to the people i work with.. a few have started actively learning haskell
19:36:29 <Fuuzetsu> fuzzyhorns: simply because it is a language whithout types, that cripples it enough whether it is functional or note. I guess it's bigger shame for functional languages because it seems easier to have a nice type system than in imperative or whatever
19:36:31 <adarc> so that's pretty cool
19:36:45 <Fuuzetsu> s/note/not/
19:36:57 <fuzzyhorns> Fuuzetsu: fair, so then what about not having types cripples a language?
19:37:07 * hackagebot drawille 0.1.0.3 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.3 (yamadapc)
19:37:29 <adarc> if you don't have types in a functional language, then how do you compose all of these 'things'
19:38:46 <fuzzyhorns> adarc: as you do in an untyped lambda calculi, i imagine
19:38:46 <Fuuzetsu> adarc: with a lot of luck and praying
19:39:35 <Fuuzetsu> fuzzyhorns: that seems like a more general question about why types are great that I don't want to get into right now, I don't think I can do it justice
19:40:01 <Fuuzetsu> safety, documentation, pretty cool hackery ;)
19:40:05 <fuzzyhorns> Fuuzetsu: fair enough, yes i think that's where i am leading
19:40:20 <adarc> i'm pretty sure simon peyton jones would blow our minds with an answer
19:40:27 <adarc> he'd explain it quite well
19:40:27 <adarc> ;f
19:40:34 <fuzzyhorns> adarc: have a link? :)
19:40:39 <Fuuzetsu> he probably already did
19:41:06 <fuzzyhorns> also is this a legit definition? http://en.wikipedia.org/wiki/Total_functional_programming
19:41:55 <simon> fuzzyhorns, sure.
19:41:57 <Fuuzetsu> didn't know there was a wiki page on that
19:42:08 <Fuuzetsu> what's going on in those code blocks though…
19:42:50 <Fuuzetsu> ooo
19:43:00 <Fuuzetsu> >For example, any algorithm for which an asymptotic upper bound can be calculated (by a program that itself only uses Walther recursion) can be trivially transformed into a provably-terminating function by using the upper bound as an extra argument decremented on each iteration or recursion.
19:43:05 <Fuuzetsu> that is cool, didn't think of that
19:44:02 <fuzzyhorns> what is Walther recursion?
19:44:18 <Fuuzetsu> why don't you click on the link on wiki and find out?
19:45:13 <adarc> http://stackoverflow.com/questions/3161112/functional-programming-and-type-systems
19:45:50 <adarc> marlow gives a nice little answer, but not regarding 'cripple' obviously
19:46:02 <dmj`> Fuuzetsu: My issue was that I was putting documentation inside of the module (..) portion of the file when it needed to be below the module headers (but above the module declaration), that removed the whitespace
19:47:08 * hackagebot drawille 0.1.0.4 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.4 (yamadapc)
19:47:59 <adarc> http://fsharpforfunandprofit.com/posts/ten-reasons-not-to-use-a-functional-programming-language/
19:48:02 <adarc> wow
19:48:06 <Fuuzetsu> well, did you solve it? I still don't understand but I hope you figured it out ;P
19:48:06 <adarc> haahhaaha
19:48:17 <adarc> that blog article is wrecked
19:48:29 <adarc> 'i get paid by the line
19:48:30 <adarc> "
19:48:31 <adarc> hahaha
19:48:35 <adarc> it's true but sad
19:48:41 <Fuuzetsu> hey, we have curly braces!
19:48:53 <adarc> hah
19:48:59 <Fuuzetsu> also whatever font that is using, it looks like absolute shit for me
19:49:06 <dmj`> Fuuzetsu: if you look at the hedis docs they put all documentation inside of module declaration
19:49:21 <adarc> that has to be the worst blog article ever written
19:49:24 <adarc> or top 10
19:49:24 <adarc> ;f
19:49:34 <adarc> oh
19:49:35 <adarc> it's a troll
19:49:37 <adarc> wow im a loser
19:49:38 <Fuuzetsu> adarc: it's just a joke…
19:49:41 <dmj`> Fuuzetsu: if you look at Control.Applicative most of the documentation goes above the module declaration
19:49:42 <adarc> ahaha
19:49:46 <adarc> im eating ice cream, i apologize
19:50:24 <Fuuzetsu> dmj`: yes, and? Applicative puts some stuff before ‘module …’ and hedis does not
19:51:05 <dmj`> Fuuzetsu: yes, I was doing both instead of one or the other, this caused a white space which was undesirable
19:51:54 <dmj`> Fuuzetsu: Also, some things act differently depending on the context, in the hedis docs a '*' makes text large and bold, above the module declaration '*' makes a bullet point
19:52:09 <Fuuzetsu> dmj`: ok, well, if you have a code snippet demonstrating this whitespace and can describe what you'd like it to do instead then I'll be happy to see you on the Haddock issue tracker
19:52:45 <dmj`> Fuuzetsu: I don't think it's a bug, more of just a user error
19:53:04 <Fuuzetsu> dmj`: yes, the * is a bit unfortunate. *s between functions (below module) are ‘section headers’ but everywhere that's considered an ordinary Haddock comment otherwise it is an unordered list
19:53:37 <Fuuzetsu> with the top module header comment being a bit special in that you can have some module metainfo first and then ordinary comment content following it
19:54:01 <Fuuzetsu> another place where -- * can be used as a header is in inside export list
19:54:32 <Fuuzetsu> (it is the to not having an export list at all and just have -- *s between functions in desired order)
19:54:38 <Fuuzetsu> it is the same*
19:55:06 <dmj`> Fuuzetsu: Do you know of a way to get larger text (like using * in module), above the module declaration?
19:55:57 <Fuuzetsu> you can use the in-comment headers (some number of =s, check the Haddock docs) but there is no form of ‘increase fontsize’ thing
19:56:58 <adarc> http://haskell.1045720.n5.nabble.com/Proposal-add-conversion-functions-to-Data-Fixed-td5721346.html
19:58:29 <adarc> seems like toFixed/fromFixed was accepted as a pastch but i dont see it anywhere
19:59:19 <benzrf>        fixed.
20:00:04 <Fuuzetsu> Data.Fixed exports MkFixed constructor since 4.7, is that no good for you?
20:00:22 <adarc> i guess
20:08:27 <dmj`> Fuuzetsu: ok, I have something to show you
20:08:42 <Fuuzetsu> please be gentle
20:08:45 <Fuuzetsu> it is 3am here
20:08:49 <lpaste> dmj pasted “doc” at http://lpaste.net/113299
20:08:54 <td123> is there a workflow similar to ruby's bundler where you can lock dependency versions but also upgrade dependency versions and update the lock file?
20:09:13 <dmj`> Fuuzetsu: http://lpaste.net/113299
20:09:20 <td123> it would be nice if there was also a tool to detect outdated dependencies
20:09:27 <Fuuzetsu> dmj`: I uh, don't think that will work
20:09:28 <Fuuzetsu> does it?
20:09:45 <td123> in the lockfile and also in the cabal constraints
20:09:46 <dmj`> http://i.imgur.com/ed2Vxlg.png
20:09:54 <dmj`> Fuuzetsu: thats the output
20:10:05 <dmj`> you see that whitespace below Web.Stripe.Account
20:10:31 <Fuuzetsu> dmj`: that's due to the box on the right
20:10:39 <Fuuzetsu> maybe
20:10:45 <Fuuzetsu> hm
20:11:00 <dmj`> no its not because Control.Applicative
20:11:14 <dmj`> has a long box
20:11:26 <Fuuzetsu> gonna have a look sec
20:11:27 <dmj`> oh wait, it's probably the blue box
20:12:25 <Fuuzetsu> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html is different, the stuff before Applicative functors header is the stuff before module header so not sure why you're using this as a counter-example
20:12:29 <dmj`> Fuuzetsu: after removing the code sample, the whitespace persists
20:13:18 <dmj`> Fuuzetsu: It's a counterexample in that a long box created from module headers doesn't create additional white space.
20:13:56 <dmj`> Fuuzetsu: Control.Applicative and Hedis are opposite in that all the docs are either above the module declaration, or below, mine uses both, and therefore there is whitespace
20:13:58 <Fuuzetsu> it is not because the module description is larger than the box so the problem can't manifest
20:14:38 <Fuuzetsu> ok I don't have the energy to investigate this right now; dmj` if you can make an issue on Haddock tracker with all sample files needed to demostrate the problem then I can take a look later
20:15:00 <Fuuzetsu> but please please be clear on what you expect to happen in what situation
20:15:51 <dmj`> Fuuzetsu: I'm not sure it's a problem, but I wouldn't mind making an issue, I appreciate all your help in this, and thank you for writing those haddock blog posts
20:16:50 <Fuuzetsu> maybe I should publish Haddock documentation as a blog post, seems more people read that than the docs of the thing they usually ask about…
20:17:46 <adarc> which haddock blog posts
20:18:15 <Fuuzetsu> I think there is only one ;P
20:18:23 <dmj`> adarc: the really good one
20:18:40 <dmj`> adarc: you've obviously never visited Fuuzetsu's corner
20:18:42 <dmj`> http://fuuzetsu.co.uk/blog/posts/2014-03-24-New-Haddock-released!-A-visual-guide-to-changes.html
20:18:55 <Fuuzetsu> that was a right pain to write
20:19:05 <adarc> i visited it 5 seconds ago
20:19:09 <adarc> and i'm now checking it out
20:19:09 <adarc> ;f
20:19:24 <dmj`> Fuuzetsu: it's way more digestible than the haddock user guide
20:20:09 <Fuuzetsu> but it only shows new stuff rather than describing how to use Haddock
20:22:00 <dmj`> Fuuzetsu: yea but still
20:27:00 <Fuuzetsu> maybe pictures in user guide would help, but the problem with that is that it'd be a ton of effort to update
20:27:12 * hackagebot whiskers 0.1.0.1.20141027 - Moustache templates with Template Haskell.  http://hackage.haskell.org/package/whiskers-0.1.0.1.20141027 (peter)
20:27:14 * hackagebot whiskers 0.1.0.2.20141027 - Moustache templates with Template Haskell.  http://hackage.haskell.org/package/whiskers-0.1.0.2.20141027 (peter)
20:27:18 <Fuuzetsu> maybe we could generate links to actual examples which we could actually render with the release…
20:29:07 <dmj`> Fuuzetsu: that'd be cool, or maybe a haddock repl would be nice
20:29:18 <dmj`> with multiline support
20:29:24 <dmj`> haddocki
20:29:36 <Fuuzetsu> no way, not making that
20:30:00 <Fuuzetsu> in the future there may be a web service where you put Haddock in and you get a rendering out
20:30:11 <Fuuzetsu> maybe with multiple Haddock versions
20:30:50 <int-e> hiho, haddock in, html out?
20:30:59 <Fuuzetsu> like http://johnmacfarlane.net/babelmark2/
20:31:17 <Fuuzetsu> int-e: …I'll keep that in mind
20:33:47 <dmj`> Fuuzetsu: how do I make my haddocks black and dark blue?
20:34:00 <Fuuzetsu> let me know if you find out ;P
20:34:06 <dmj`> :)
20:34:21 <Fuuzetsu> I will happily take in and officially distribute some CSS if you have any
20:34:22 <dmj`> Fuuzetsu: I could add inline css before uploading I guess
20:34:54 <Fuuzetsu> you can upload just about anything and Hackage will display it
20:35:14 <dmj`> even changing the font a little bit would be a big help
20:35:50 <dmj`> a haddock styler tool would be interesting
20:36:33 <Fuuzetsu> for any such ‘web’ changes I can't say anything but ‘patches welcome’, I don't have the ability and even less will to mess with HTML and CSS and all that bollocks
20:37:09 <Fuuzetsu> I can mess with few tags in XHtml but for bigger things I usually seek help
20:37:16 <dmj`> yea, for starters we could probably start using the html5 doctype
20:39:08 <dmj`> actually, having visually consistent themes across all packages probably has its benefits
20:39:29 <Fuuzetsu> well, consistency is good, easy to find things &c
20:39:51 <Fuuzetsu> but I hate getting up like 4am and getting absolutely destroyed by all those white pages on hackage
20:40:54 <dmj`> ha, we need an 'invert color' button
20:41:01 <dmj`> ease the eyes
20:41:07 <zwer> Fuuzetsu did you try using f.lux  or redshift?
20:41:12 <Fuuzetsu> there is a way to include more than one theme already
20:41:18 <Fuuzetsu> zwer: yes, I use redshift 24/7
20:41:18 <dmj`> oh?
20:41:41 <Fuuzetsu> dmj`: I think --built-in-themes includes the classic theme too and then you can switch
20:42:01 <Fuuzetsu> so if we have a dark theme we could include that and cabal could default to --built-in-themes
20:42:24 <mgsloan> I've got a user style that inverts all the colors on hackage.  Unfortunately, this seems to trigger a chrome rendering bug, but it mostly works..
20:42:55 <dmj`> Fuuzetsu: where can I find the list of built in themes?
20:43:07 <dmj`> --built-in-themes=tango-dark
20:43:14 <Fuuzetsu> here: Ocean and Classic
20:43:20 <akurilin> Do you folks happen to know how good support for sql arrays is currently in libraries such as persistent?
20:43:25 <Fuuzetsu> http://www.haskell.org/haddock/doc/html/invoking.html
20:43:42 <Fuuzetsu> dmj`: if you have your own then --theme-path=… should work
20:45:25 <rkumarakrishnan> mthvedt
20:45:47 <dmj`> Fuuzetsu: can I specify the ocean theme from the command line?
20:45:57 <dmj`> like, how do you switch between them
20:45:57 <Fuuzetsu> it is the default
20:46:22 <dmj`> how do I go classic?
20:46:28 <Fuuzetsu> dmj`: read the description of --theme flag
20:46:48 <Fuuzetsu> IIRC if you have more than one theme included then a Theme button appears at the top right of docs
20:46:53 <Fuuzetsu> next to Index and all that
20:48:09 <dmj`> oh I got you
20:48:37 <dmj`> ocean was a big upgrade for everyone :)
20:48:49 <Fuuzetsu> well, the upgrade happened before my time
20:49:07 <Fuuzetsu> I just find the old sometimes and they looked like ass
20:49:07 <dmj`> haskell came out 87' how old are you?
20:49:25 <Fuuzetsu> younger than that ;P
20:49:37 <Fuuzetsu> pretty sure it only officially came out 90' anyway
20:50:44 <dmj`> 1987 was the first counsel, yea looks like 90
20:51:02 <dmj`> council :)
20:51:55 <dmj`> still
20:52:54 <dmj`> omg iframes
21:04:19 <benzrf> bye
21:04:50 <Fuuzetsu> good idea
21:04:52 * Fuuzetsu → bed
21:27:20 * hackagebot whiskers 0.1.0.2 - Moustache templates with Template Haskell.  http://hackage.haskell.org/package/whiskers-0.1.0.2 (peter)
21:42:21 * hackagebot egison 3.3.13 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.13 (SatoshiEgi)
21:45:53 <Axman6> rarg, why is it so hard to work with timing in Haskell. turns out that getCPUTime returns the amount of time that the CPU has been active, not some number of cycles/picoseconds since execution
21:46:08 <joelteon> just like similarly named functions do in every language
21:47:00 <dfeuer> :-}
21:47:04 <Axman6> and Data.Time.Clock is pretty useless because there's no easy to extract the time between two times (specifically a DiffTime)
21:47:31 <dfeuer> Me are thinking that Axman6 is probably looking in the wrong modules or something.
21:47:41 <Axman6> all I want to do is make a periodic function that runs every n time periods (5 seconds)
21:47:53 <chirpsalot> The time stuff is kind of a mess... At least at first glance.
21:47:55 <joelteon> Because the Data.Time documentation is so easy to navigate!
21:48:14 <joelteon> Axman6: forkIO $ forever $ threadDelay 5000000 >> myFunction
21:48:15 <dfeuer> Axman6, what does making a periodic function have to do with checking what time it is?
21:48:25 <Axman6> joelteon: that's not periodic
21:48:32 <joelteon> that runs every 5 seconds
21:48:40 <Axman6> I want to run every n seconds, not runn with n seconds between runs
21:48:41 <chirpsalot> It's also really confusing that huge swaths of the time library are deprecated, and functionality seems to be duplicated in a few places?
21:48:43 <dfeuer> No, i think not.
21:48:43 <Axman6> no it doesn't
21:49:00 <joelteon> So you want to run every n seconds, but you don't want to run every n seconds.
21:49:23 <Axman6> using threadDelay like that will run it every 5s+delta
21:49:25 <chirpsalot> joelteon: I think they mean they want to fork a new process every 5 seconds?
21:49:26 <dfeuer> joelteon, he wants to run every n seconds; not n seconds between the end of one run and the start of the next.
21:49:32 <Axman6> where delta is the amount of time it takes to run the function
21:49:44 <joelteon> forever $ threadDelay 5000000 >> forkIO myFunction
21:49:54 <Axman6> that still won't work
21:49:59 <dfeuer> Ew.
21:50:05 <Axman6> to do this properly you need to get the current time each iteration
21:50:09 <dfeuer> Why?
21:50:21 <Axman6> and I don't waant this running concurrently with itself
21:50:25 <dfeuer> Why not?
21:50:48 <chirpsalot> Axman6: then why not the first suggestion? What if it takes more than 5 seconds to run?
21:50:51 <joelteon> This problem is even more difficult than I could possibly have comprehended.
21:51:42 <Axman6> dfeuer: because it's inserting data into a database, and running concurrently might violate some constraints on the system
21:52:38 <dfeuer> Axman6, so what should it do if the thing is still running when it gets to the next thing?
21:52:58 <dfeuer> Axman6, I'm thinking you prolly want 2 threads, and you prolly want them talking through some kind of shared variable thingum.
21:53:00 <Axman6> I don't mind if it misses some time periods, but I want it running on multiples of n seconds
21:53:07 <dfeuer> Yeah,
21:53:11 <dfeuer> shared variable thingum.
21:53:27 <dfeuer> Def.
21:53:45 <Axman6> I've figures that bit out, it's just a problem of being able to produce delays from something like getCurrentTime
21:53:51 <Axman6> which doesn't seem possible
21:54:26 <dfeuer> Axman6, what's the challenge with subtracting a representation of one time from another?
21:54:30 <Axman6> since I need to procude an Int representing microseconds for threadDelay
21:54:31 <dfeuer> :t getCurrentTime
21:54:32 <lambdabot> Not in scope: ‘getCurrentTime’
21:54:50 <Axman6> getCurrentTime :: IO UTCTime
21:55:27 <Axman6> once you have values in Data.Time types, it's neigh on impossible to get them back out into useful types
21:56:06 <Axman6> if the program were busy most of the time then getCPUTime would probably be fine
21:56:56 <dfeuer> I think getCPUTime is just not what you want.
21:57:03 <Axman6> no
21:58:30 <Axman6> what's really annoying is that this stuff is bread and butter in real-time programming, but basically impossible in Haskell
21:58:55 <chirpsalot> I feel like Haskell is really not good for real-time programming.
21:59:07 <chirpsalot> Lazy evaluation is probably a death sentence?
21:59:12 <Axman6> sure, but it doesn't have to be bad at it
21:59:23 <Axman6> it depends on your constraints
21:59:40 <chirpsalot> Lazy evaluation and garbage collection would make it a difficult problem, at least.
21:59:53 <dfeuer> Axman6, I think you probably want to look into NominalDiffTime, which is an instance of Enum, so you can turn it into an Int.
22:00:18 <dfeuer> (It's also a Num, and various other things)
22:00:26 <Axman6> in my case the periodicity is in the order of minutes and seconds for actions that usually take fractions of a second to run
22:00:29 <dfeuer> So you can probably do stuff with hat.
22:00:36 <Axman6> hmmm, I had forgotten that Enum gave you Int
22:01:04 <dfeuer> But also you can convert your seconds into a NominalDiffTime one way or another and use that. I'm not sure what the tradeoffs are.
22:01:12 <chirpsalot> So, this is a dumb question, but what's the point of forkIO? Just multithreading for the sake of pretending to do things at the same time? Does it ever create new OS processes?
22:01:20 <dfeuer> I've never even looked at that module before.
22:01:39 <dfeuer> chirpsalot, it's a good thing.
22:01:52 <dfeuer> GHC makes as many threads as it needs.
22:02:01 <dfeuer> But not more.
22:02:17 <dfeuer> Or something like that, anyway.
22:02:28 <Axman6> chirpsalot: when compiled with -threaded, you can tell programs how many OS threads to multiplex haskell threads onto
22:02:42 <Axman6> you get real concurrency using forkIO (with very low overhead)
22:03:30 <chirpsalot> Ah. So if I was doing something stupidly parallel like a ray-tracer, would forkIO lead to performance benefits? All of the docs seem to suggest that forkIO isn't about doing things in parallel, but concurrently, and I haven't managed to figure out exactly what is meant by that.
22:03:32 <Axman6> `ghc -threaded Main.hs; Main +RTS -N` will run Main with as many threads as there are CPU cores
22:03:32 <dfeuer> You don't want too many OS threads, because those are much more expensive. GHC takes care of stuff like handling blocking system calls so that other Haskell threads aren't blocked.
22:04:06 <dfeuer> chirpsalot, you want to use par and such for your raytracer, not forkIO.
22:04:13 <Axman6> pdxleif: you do things in parallel to make them faster, you do things concurrently to do multiple things at once. they're related but distinct concepts
22:04:26 <Axman6> uh, chirpsalot not pdxleif, hiow did I manage that
22:04:38 <dfeuer> The same way I've been typing all wrong all day.
22:04:50 <chirpsalot> dfeuer: I do know that much, but I get confused about the distinction.
22:05:20 <chirpsalot> Axman6: it seems like a very wibbly wobbly distinction.
22:05:50 <chirpsalot> Axman6: I guess it's kind of the difference between threads on the same core, and multiple processes on different cores at the same time?
22:06:21 <dfeuer> It's not wibbly-wobbly at all.
22:08:56 <Axman6> dfeuer: I owe you a beer if we ever meet, I've now got my periodic stuff working (the Enum instance gave me exactly what I needed)
22:09:06 <dfeuer> Whee!
22:09:15 <dfeuer> Axman6, only if we can have pizza with the beer.
22:09:20 <ReinH> dfeuer: is it timey-wimey?
22:09:23 <Axman6> of course
22:09:27 <dfeuer> ReinH, definitely.
22:09:34 <dfeuer> Axman6, what part of the world are you in?
22:09:40 <Axman6> .au
22:10:02 <Axman6> chirpsalot: http://chimera.labs.oreilly.com/books/1230000000929 click Read Online
22:10:47 <ReinH> Great book.
22:11:07 <chirpsalot> Axman6: ooooh, looks good :).
22:11:08 <Axman6> yeah, incredibly well written for all levels of experience
22:11:11 <chirpsalot> Thanks!
22:12:22 <Axman6> chirpsalot: http://chimera.labs.oreilly.com/books/1230000000929/ch01.html#sec_terminology is particularly relevant to you
22:12:34 <zdavid408> Hi guys
22:12:40 <zdavid408> need some help with VBA
22:12:55 <dfeuer> What is a VBA?
22:13:02 <zdavid408> visual basics
22:13:07 <zdavid408> its for my class
22:13:08 <Axman6> ...
22:13:09 <dfeuer> Then you are in the wrong channel.
22:13:17 <zdavid408> whoops
22:13:17 <Axman6> does this like a visual basic channel?
22:13:25 <chirpsalot> Axman6: ah. Those couple of paragraphs actually made everything crystal clear.
22:13:28 <zdavid408> i just saw this on a webpage
22:13:32 <dfeuer> Unless you want to implement Visual Basic in Haskell, which would be funny.
22:13:36 <zdavid408> it said this was the best channel to ask for help
22:13:42 <dfeuer> . . . .
22:13:46 <kadoban> Haha, what web page?
22:13:51 <zdavid408> nvm
22:13:57 <Axman6> zdavid408: it's the best channel to ask for help about _haskell_
22:14:01 <Axman6> (and category theory)
22:14:05 <zdavid408> https://news.ycombinator.com/item?id=7161236
22:14:12 <chirpsalot> zdavid408: although we can help by showing you the light?
22:14:20 <chirpsalot> And leading you away from VBA.
22:14:21 <zdavid408> show me the light
22:14:24 <zdavid408> ahaha
22:14:27 <zdavid408> i hate this
22:14:29 <zdavid408> only for class
22:14:45 <dfeuer> The light! It blinds!
22:14:56 <zdavid408> lol?
22:15:07 <chirpsalot> dfeuer: can't see nuthin' but monads everywhere!
22:15:08 <dfeuer> Who can come up with a good 30-second "Come to Haskell" speech?
22:15:40 <zdavid408> I would like to hear that...
22:16:02 <dfeuer> I guess I can make it now, the pain is gone; all of my BASIC programs have gone away. Gone are the dark clouds that had me down. It's gonna be a bright, bright, Haskelly day.
22:16:08 <Axman6> "Sick of making stupid mistakes because you forgot what sort of object you were working with? Haskell doesn't even have objects!"
22:16:23 <zdavid408> but anyways, sorry to bother you guys. Do you think i can look somewhere else for help. Would appreciate it.
22:16:26 <vegai> learn Haskell, so that every other language will henceforth seem impossible to work with.
22:16:27 <dfeuer> Haskell has lovely fun types that guide program design.
22:16:27 <jle`> write maintainable code without even thinking about it!
22:16:33 <jle`> zdavid408: probably
22:16:59 <Axman6> I assume there's a #visualbasic somewhere?
22:17:10 <zdavid408> yes, is there?
22:17:12 <jle`> i'm pretty sure there is at least somewhere out there that could help you :)
22:17:15 <Axman6> clearly #vb would be for fans of victoria Bitter beer
22:18:19 <Axman6> @google visual basic irc channel
22:18:19 <lambdabot> http://irc.lc/freenode/%23vb.net/irctc@@@
22:18:20 <lambdabot> Title: #vb.net : Chat on vb.net IRC channel - Freenode WebChat
22:18:21 <jle`> perhaps stack overflow
22:19:02 <zdavid408> thans lambdabot
22:19:02 <chirpsalot> dfeuer: "Haskell -- It's not VBA!"
22:19:16 <zdavid408> i got that accross, thanks chirpsalot
22:19:28 <chirpsalot> Y'welcome :).
22:20:01 <chirpsalot> But more seriously Haskell is a wonderful, mind expanding programming language, which has unique and valuable approaches to many problems!
22:20:15 <chirpsalot> And a loverly type system.
22:20:27 <zdavid408> Let me join
22:20:34 <zdavid408> I would love to learn.
22:20:44 <chirpsalot> http://tryhaskell.org/
22:23:26 <zdavid408> holy shit i just learned how to arrange numbers in haskell
22:23:27 <zdavid408> LOL
22:24:04 <chirpsalot> 'gratz!
22:24:05 <zdavid408> and sort my name in letters. LOL...
22:24:09 <jle`> :D
22:24:21 <jle`> > sort "zdavid408"
22:24:23 <lambdabot>  "048addivz"
22:24:23 <chirpsalot> And it's so much more fun than VBA ;D
22:25:01 <sipa> > sort "Simon Peyton Jones"
22:25:03 <lambdabot>  "  JPSeeimnnnooosty"
22:25:40 <zdavid408> LOL the bot beat me
22:25:47 <zdavid408> sort "david
22:25:50 <zdavid408> sort "david"
22:26:00 <chirpsalot> zdavid408: You need the ">"
22:26:23 <zdavid408> i got it
22:27:15 <David> hehe
22:27:28 <David> > sort "zdavid408"
22:27:29 <lambdabot>  "048addivz"
22:27:40 <chirpsalot> Try Haskell must be somewhat unfortunate for the people who have names in alphabetical order...
22:27:53 <zdavid408> sort "lambdabot"
22:27:54 <chirpsalot> We're not inclusive enough!
22:28:02 <chirpsalot> > sort "lambdabot"
22:28:03 <lambdabot>  "aabbdlmot"
22:28:13 <zdavid408> why is it not working for me?
22:28:13 <zdavid408> LOL
22:28:20 <Axman6> you need to use >
22:28:23 <Axman6> > 1+1
22:28:25 <lambdabot>  2
22:28:25 <Axman6> 1+1
22:28:26 <zdavid408> i guess the vb chat is deadl -_-
22:28:34 <zdavid408> ohhhhhhhhhhhhhhhhhhhhh
22:28:58 <zdavid408> > sort "Axman6"
22:28:59 <lambdabot>  "6Aamnx"
22:29:40 <exio4> zdavid408 is joining the bright side \o/
22:30:04 <zdavid408> Who is the dark side?
22:30:14 <chirpsalot> VBA and Java :P.
22:30:18 <zdavid408> LOL
22:30:21 <chirpsalot> Ironically Java came from Sun.
22:30:26 <zdavid408> what about C and C++
22:31:15 <exio4> they are in the dark side too! ;P
22:31:18 <MP2E> I guess Lua must be the dark side then (because its name means moon :P)
22:31:53 <chirpsalot> MP2E: Lua is pretty neat... Oh hey! http://www.haskell.org/haskellwiki/HsLua
22:31:59 <zdavid408> any anyone help with my vb
22:34:48 <sgronblo> I guess you can make much more money with VBA if you are in the right place though?
22:35:08 <chirpsalot> sgronblo: like a Death Star?
22:35:48 <sgronblo> no, even worse. think some goldman-sachs type place.
22:36:26 <chirpsalot> Ugh. Although, I think there are actually a fair number of financial Haskell start ups?
22:36:47 <exio4> you can make a lot of money if you learn COBOL! ...
22:38:03 <Axman6> there's plenty of banks using haskell
22:38:09 <sgk> COBOL??
22:38:25 <Axman6> yeah, COBOL is big money
22:39:37 <sgk> antique :)
22:40:08 <dfeuer> chirpsalot, I am learning that Javascript is much, much darker than Java in the type department.
22:42:22 <Anomanal> I'm debating between java, haskell, ada, and go for my next language. I can not decide. I want a language that is more fluid and natural than c for higher level dev, although also having the atributes of retaining power and performance.
22:43:02 <joelteon> if you want power, performance, really big binaries, and a crippled type system, use go
22:43:10 <Adeon> well
22:43:13 <Adeon> since this is #haskell
22:43:16 <Adeon> I recommend haskell
22:43:17 <vegai> Anomanal: may I make it worse by suggesting Rust as well? :P
22:43:40 <c74d> Anomanal: I’ll second the recommendations of Haskell and Rust.
22:43:42 <Anomanal> Yes, head at it. I'll look at it now thanks.
22:44:42 <c74d> Rust seems to be “traditionally” compared with Go, but of those four I think it might really be more closely comparable to Ada.
22:44:50 <sgk> can you suggest some good tutorials for haskel beginner
22:45:13 <Adeon> @where lyah
22:45:14 <lambdabot> http://www.learnyouahaskell.com/
22:45:26 <Adeon> if you haven't gone through it yet
22:45:28 <c74d> Major focus on safety, though unlike Ada it also focuses on making that safety not carry a cost to performance.
22:45:42 <dfeuer> @where rwh
22:45:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:45:50 <darkbolt> Anomanal: as someone doing go at their day job, I hope you don't go for it ;)
22:45:50 <c74d> sgk: I recommend Real World Haskell (RWH).
22:46:12 <dfeuer> Those two seem the most popular these days.
22:47:11 <exio4> https://github.com/bitemyapp/learnhaskell ? :P
22:47:25 <c74d> sgk: To paraphrase my notes, RWH seems to me to be a more thorough and reliable book than LYAH. However, do see also `/query welpbot @where RWH`.
22:49:10 <dfeuer> Is welpbot some other incarnation of lambdabot living elsewhere on Freenode?
22:49:19 <c74d> dfeuer: yes.
22:49:41 <Hijiri> @where cis194
22:49:41 <lambdabot> I know nothing about cis194.
22:51:04 <Anomanal> Wow rust looks perfect! I love the looks of the syntax and flow. It's too bad it looks rather immature at this point. Although, I'm not in any kind of hurry. I wonder how it will handle regex in the future. I thought and was hoping it might have it built in although skimming through the nightly guide showed nothing related. It'd be awful to have to use a library like pcre :|
22:52:00 <c74d> Anomanal: “built in” how?
22:52:01 <Anomanal> The guide doesn't look complete, I imagine it has many more features seeing as I didn't see any logical or bitwise operators
22:52:09 <Anomanal> c74d: like, with its own operator
22:52:14 <Anomanal> Like perl
22:52:16 * dfeuer wonders why some people seem to love regexes.
22:52:18 <c74d> Anomanal: the guide is still under construction, I believe.
22:53:06 <Anomanal> dfeuer: regex is very important in a lot of moments, and you don't want to bust out pcre in c to write it, and you do n't want to do strtok()/strchr()/strcpy() etc tricks to do in 25 lines what could easily be done in one regex. No?
22:53:34 <vegai> Anomanal: I'm pretty sure they won't have regexes in the language
22:53:42 <Anomanal> Awwww
22:53:52 <dfeuer> Anomanal, "very important in a lot of moments" like which ones?
22:53:55 <Anomanal> That's like all it's missing by the looks of it!
22:54:04 <c74d> Rust’s macros allow one to pretty much define whatever syntactical constructs one wants, I think.
22:54:07 <vegai> Anomanal: how is this less useable? http://doc.rust-lang.org/regex/
22:54:30 <Anomanal> dfeuer: more or less anything perl might be sed for or awk, i mean perl was the thing for at least a decade really, and it's entire purpose is more or less regex.
22:54:32 <vegai> Anomanal: possibly my definition of "in the language" is a bit stricter than yours? :P
22:55:01 <c74d> Substitution in Perl is `foo =~ s/abc/xyz/`, right?
22:55:17 <Anomanal> yes
22:55:35 <Anomanal> well foo is a type that is bare unless you used a typeglob you'd have to specify data type via prefix
22:55:38 <Anomanal> like $ for scalar
22:55:45 <dfeuer> *shudder*
22:56:15 <vegai> vade retro!
22:56:19 <c74d> I think one could have something like `rx_subst!(foo ~ /abc/xyz/)` in Rust.
22:56:25 <Anomanal> IT's just so convienent!
22:56:32 <Anomanal> Yet perl is the worst performing language that exists
22:56:46 <Anomanal> c74d: yeh sure, a function; kinda like awk and regex
22:56:52 <Anomanal> I just love having it with an operator
22:56:58 <dfeuer> No, Perl is almost certainly faster than unlambda.
22:57:19 <Anomanal> Hmm well I won't debate that. I more or less meant relevant language =]
22:57:27 <Anomanal> Although I have heard of unlambda
22:57:46 <Axman6> I thought both PHP and Ruby were usually some of the slowest languages
22:57:53 <Anomanal> no each faster than perl
22:58:03 <Anomanal> perl < ruby < python < php
22:58:37 <Axman6> you reckon php is usually faster than python? o.O
22:58:44 <Anomanal> Well those two are debatable
22:58:52 <Anomanal> Although ruby and perl are deffinitely the slowest
22:58:55 <Anomanal> And perl is slower
22:59:01 <Anomanal> Take a look at the debian shootout if you never have
22:59:08 <dfeuer> Of those four, Python definitely has the best reputation for sanity.
22:59:20 <Axman6> I have many times, one of my programs used to be the fastest in the thread ring benchmark
22:59:32 <dfeuer> And I understand there are fast implementations these days.
22:59:43 <Anomanal> Neat neat
22:59:48 <dfeuer> Axman6, in Haskell, or Python?
22:59:54 <Axman6> haskell
22:59:55 <Anomanal> Yes haskell performs well
23:00:04 <Axman6> it was by far the fastest. then everyone else started cheating
23:00:10 <dfeuer> Cheating?
23:00:23 <Axman6> "threading" using coroutine libraries
23:00:25 <Anomanal> As far as 'new' languages that are 'common' i'd have to say the best three performing are go, haskell, and c sharp
23:00:38 <dfeuer> Axman6, oh, you mean like Haskell threads?
23:00:41 <Axman6> haskell isn't new
23:00:46 <Anomanal> err yeh
23:00:48 <Anomanal> right
23:00:54 <Anomanal> haskell is old it's new to me
23:01:00 <Axman6> dfeuer: well, that's debatable.
23:01:00 <Anomanal> the other two are actually rather new
23:02:10 <Anomanal> That rust looks perfect. I'll just have to wait I think. ANd see what the next few years bring!
23:02:56 <c74d> Anomanal: plenty of people are using it now, even though it’s not had a stable release yet.
23:03:23 <Anomanal> Ah I found what I was looking for via google: http://doc.rust-lang.org/regex/
23:03:29 <dfeuer> Ha. C# is old enough to be in high school. Haskell's only 10 years older.
23:03:30 * c74d isn’t, though.
23:03:31 <Axman6> yeah, it looks promising and well considered
23:03:39 <Anomanal> There is a regex "macro" that would suffice
23:04:17 * dfeuer applies a macro to Anomanal, resulting in an anagramonal.
23:04:56 <Anomanal> Yeh that regex is perfect for me - i'ma learn rust then!
23:05:07 <Anomanal> I'll find out the most up to date book or something
23:05:42 <c74d> Anomanal: I don’t think there are any books on Rust yet. Do join #rust on irc.mozilla.org though.
23:05:48 <dfeuer> Hehe: http://en.wikipedia.org/wiki/Hugs seems a tad ... outdated, as Hugs hasn't been maintained in years.
23:05:59 <Anomanal> Alright , I'll take that into consideration , thanks!
23:06:05 <Anomanal> And thanks for pointing me in that direction!
23:06:27 <dfeuer> c74d is not old enough to be in high school? How old is c74d?
23:07:00 <c74d> Anomanal: I think the closest things to up-to-date books on Rust are the Rust Tutorial and Guide. However, from what I hear, the Tutorial isn’t always up-to-date, and the Guide isn’t complete.
23:07:25 <Anomanal> Yeh it looks like the raw docs are actually going to be the most helpfull
23:07:26 <c74d> dfeuer: that was continuing from my previous message; i.e., I’m not using Rust presently.
23:07:32 <dfeuer> Ahhhh.
23:08:28 <c74d> Anomanal: The Rustdocs, however, are (as far as I know) almost always up-to-date and are usually good.
23:08:43 <c74d> And #rust is quite helpful.
23:08:48 <Anomanal> Right right. ok!
23:10:10 <sgronblo> joelteon: go produces big binaries?
23:10:50 <c74d> I hear Go’s compiler performs almost no optimization.
23:12:34 <vegai> tough to believe that go programs could perform as well as they do if that was true
23:15:08 <adas> go produces libless binaries
23:15:15 <adas> perhaps thats why they are big
23:15:34 <adas> so once you build a go app, you don't need to have any other library installed
23:15:37 <simpson> The amount of optimization required is smaller when your language provides less opportunities for it.
23:27:20 <edwardk> hrmm, can anyone else here try to install https://github.com/ekmett/quine and see if it works for you? you'd need fairly modern opengl drivers i admit (opengl 4.1 for right now, i can back it down to 3.3 later)
23:27:38 <edwardk> not much to look at yet, but it does draw a thing
23:27:56 <joehh> anyone else finding hackage very slow at the moment?
23:28:23 <edwardk> i haven't tested it on anything but a macbook yet
23:29:23 <Axman6> edwardk: having a go now... but on a macbook too. seems you're on yosemite? mavericks here
23:29:38 <edwardk> Axman6: yeah, it should be okay on mavericks i think
23:29:51 <Axman6> (first rule of product demos, don't install updates to things just before the demo)
23:29:53 <edwardk> Axman6: its very very early at this stage, but i just wanted to see if it'll load for other people
23:30:08 <edwardk> Axman6: oh crud i hope it works with the released sdl2 bindings
23:30:17 <Adeon> it doesn't work with the released sdl2 bindings
23:30:17 <edwardk> if not it'll build off the version on my account
23:30:19 <Axman6> we'll see!
23:30:28 <Axman6> installing it in a sandbox so things don't break
23:30:28 <edwardk> Adeon: ugh
23:30:50 <edwardk> Axman6: you may need to use github.com/ekmett/sdl2 to build it
23:31:19 <Axman6> ok
23:31:28 <Axman6> do you know how to add that to a cabal sandbox?
23:31:30 <edwardk> its not very minimal on dependencies at this point =)
23:31:33 <edwardk> nope
23:31:38 <Axman6> heh, ok
23:31:57 <edwardk> (it embeds ekg so i can look at performance counters and stuff)
23:32:22 <edwardk> i figure that way i can throw gauges at all the phases of rendering that i want to measure
23:32:28 <edwardk> and just open the browser to look
23:32:30 <Axman6> I should have ekg in my current project...
23:33:36 <zdavid408> still nothing
23:37:30 <DiegoNolan> Are cabal repl and cabal sandbox add-source broken when used together?
23:37:43 <edwardk> i need to tweak the shader to output gl_FragDepth so i can use that to retrace and compute delta positions for SMAA T2x antialiasing, etc, that'd pretty much double the percieved resolution of the image.
23:39:46 <Axman6> edwardk: I get "clang: error: no such file or directory: 'dist/build/Quine/SDL.dyn_o'"
23:40:51 <edwardk> cabal clean and try again
23:40:55 <edwardk> that is a ghc thing you ^C'd or broke out of an earlier build
23:41:21 <edwardk> and it build the SDL.o but not SDL.dyn_o before the break
23:41:23 <edwardk> at least that is how i usually see those problems
23:41:27 <Axman6> heh, that did the trick, and thast's exactly what I did =)
23:42:11 <Axman6> and it's running fine (though it seems quite choppy, and this is a top of the line macbook pro)
23:42:25 <edwardk> its stuck drawing retina'd
23:42:37 <Axman6> heh, right
23:43:05 <edwardk> does quine -f -n -x 1024 -y 768 do better?
23:43:20 <Axman6> ha, it _really_ hates being run full screen on my 4k monitor :P
23:43:27 <edwardk> i'm just now experimenting with the command line options, etc.
23:43:51 <edwardk> i got it to render its first image that wasn't a gradient about 30 minutes ago
23:43:59 <Axman6> jesus, why would yopu do that to me
23:44:13 <Axman6> so, what is the project anyway?
23:44:26 <Axman6> wow, ekg sure is responsive
23:45:00 <edwardk> what did i do to you?
23:45:23 <Axman6> run it at a horrible resolution in full screen on a 4k monitor
23:45:25 <edwardk> btw- cmd-q quits out, cmd-enter should fullscreen to desktop, etc.
23:45:27 <edwardk> hahahhaha
23:45:37 <Axman6> it was like playing an N64 on a 1080p TV
23:45:53 <edwardk> cmd-enter with the -n is broken on mac's due to a bug in SDL2 right now
23:46:09 <edwardk> without the -n its upscaling in software and using the desktop resolution, avoiding the bug
23:46:54 <Axman6> it's making the GPU quite hot
23:47:21 <edwardk> the project is more or less experimenting with exploiting the fact that signed distance field rendering gives me an actual signed distance field... that i can use to collide with. and i want to get to where i can do cone tracing for something other than a demo
23:47:41 <edwardk> so i want to play with global illumination, for that i need to voxelize the scene
23:47:47 <edwardk> and SDFs are really good for _that_ too.
23:48:21 <edwardk> so i want to see how i can take the common shadertoy model and tweak it to get something good for half the price, toy with foveated rendering, etc.
23:48:31 <edwardk> its not yet there
23:48:42 <Axman6> ah, you need to add -with-rtsopts=-T to the compile flags for the ekg stuff to always work
23:49:02 <edwardk> oh yeah i didn't port that from ermine, derp
23:51:21 <edwardk> so on the plus side, i can render the 'straw man' i want to compete against, on the minus side, its slow, but then, i want to speed it up, so its good to have a lot of headroom available ;)
23:52:51 <Axman6> everyone knows that when optimising code, absolute speed isn't important, just percentage improvement!
23:52:55 <Axman6> >_>
23:53:21 <edwardk> now i need to figure out how to fix the resolution data under -r
23:53:29 <edwardk> its not figuring out retina dimensions correctly
23:55:07 <Axman6> well, time for me to head home. flying to melbourne at 6:30 tomorrow morning
23:55:18 <edwardk> later man
23:55:53 <Axman6> feel free to ping me if you want changes tested and I'll get to them when I';ve got some free time
23:56:07 <edwardk> k
23:56:21 <edwardk> i'll stream a bunch of code up there as i get time
23:57:27 <edwardk> on the plus side the retina resolutions give me a good reason to start playing with foveated rendering ;)
