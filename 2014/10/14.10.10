00:00:25 <ThreeOfEight> solatis: if it is possible, it is certainly news to me
00:00:36 <ThreeOfEight> but as I said, I can't rule it out
00:00:43 <ThreeOfEight> and I should be very much interested if it is possible
00:00:47 <dfeuer> solatis, if you want coercions, look at Data.Coerce. If you want to shoot yourself in the foot with coercions, look at Unsafe.Coerce.unsafeCoerce
00:01:01 <ThreeOfEight> Although I must say that even if it is possible, you should think twice about whether you really want this
00:01:15 <dfeuer> @type coerce
00:01:16 <lambdabot> (Contravariant f, Functor f) => f a -> f b
00:01:19 <johnw> other languages can do it, btw, such as Idris and Coq, so it's not that unreasonable of a request
00:01:39 <dfeuer> That's weird.
00:02:00 <solatis> ThreeOfEight: well, i come from a c++ world -- there, you can just create a constructor for FooType (BarType const &), and the compiler will automatically convert BarType into a FooType if it makes sense
00:02:04 <dfeuer> The one I want is  coerce::Coercible a b => a -> b
00:02:57 <johnw> the fact that Haskell doesn't do it makes code fairly clear, so long as you know what the functions and operators are defined to mean; there's extremely little happening "invisibly"
00:02:58 <ThreeOfEight> solatis: I, personally, think that this is dangerous to have too much implicit stuff going on in your code
00:03:28 <dfeuer> This is the opposite of what happens in C, where arithmetic is just scary.
00:03:31 <kadoban> solatis: C++ should be great evidence why type coersion can be pretty icky ;)
00:03:44 <solatis> yep, i know all the pitfalls
00:03:58 <ThreeOfEight> So I am a bit confused right now – is it possible to do implicit type conversion in Haskell or is it not?
00:04:04 <kadoban> But yeah, I don't think haskell has it...if it does, it's some weird thing I wouldn't understand
00:04:15 <ThreeOfEight> so far, it seems that even Data.Coerce and Unsafe.Coerce only do explicit conversion
00:04:18 <solatis> but in haskell, you see OverloadedStrings used way too often -- which is exactly the type of feature we're discussing here
00:04:39 <ThreeOfEight> solatis: I thought OverloadedStrings only makes String literals overloaded?
00:04:41 <zq> overloadedstrings isn't coercion
00:04:54 <solatis> then i'm mistaken about that
00:05:03 <zq> it really just calls the fromString member of class Data.String.IsString on your string literal
00:05:41 <solatis> anyway, i think we can all agree that C++ should not be used as an example for great features that should be in haskell -- so i'll just resort to manually converting between the two types now
00:05:43 <zq> solatis: what's so bad about calling fromFields :: [Field] -> Title?
00:06:13 <solatis> zq: it's not, i'm just still in the haskell-newbie-phase and wondered whether this was possible
00:07:09 <kadoban> OverloadedStrings does seem like a pretty similar thing to type coersion, it's just a limited example. Not sure I'm seeing the difference. It's really useful though
00:07:11 <ThreeOfEight> solatis: the problem with conversions is that most of them are not Isomorphisms
00:07:18 <solatis> i know Aeson has some pretty sweet mechanism to convert structures to-and-from json, which is similar to what i'm looking for right now.. but i'm probably better off just keeping things explicit at this point in my life :)
00:07:21 <ThreeOfEight> if you convert a Float to an Integer, you have to round
00:07:31 <ThreeOfEight> if you convert an Integer to a Float, you have to round
00:08:02 <solatis> ThreeOfEight: yep -- and in c++, the compiler will simply not complain unless you -Wall
00:08:03 <numberten> didn't associated types come from cpp?
00:08:07 <bartavelle> also aeson is actually a "prism", as it might fail when converting from bytestring to value
00:08:12 <ThreeOfEight> and I'm sure you've had bugs in C/C++ which boiled down to an implicit conversion where you didn't expect one
00:08:22 <solatis> which is where Linus' epic rant against c++ came from
00:08:45 <solatis> http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
00:08:50 <solatis> for the ones that care :)
00:08:52 <bartavelle> well, to be fair, you have all kind of problems when operating with size / signedness mismatched integers even in plain C
00:09:24 <ThreeOfEight> solatis: but just to be clear, I understand that you /want/ coercions
00:09:28 <ThreeOfEight> they can add a lot of convenience
00:09:37 <ThreeOfEight> I've been in the situation of wanting them myself a few times
00:09:51 <ThreeOfEight> but all in all, I think the convenience is not worth it
00:10:06 <solatis> yeah true, but in c++ you can simple declare "Foo const & operator=(std::string const &)" somewhere in some file, and without you knowing the compiler will start converting between the two if you use the assignment operator
00:10:34 <kadoban> I used to really miss them when doing like...anything with integers. I got over it somehow though I think.
00:10:40 <ThreeOfEight> I was working on some plasma simulation code a few years ago
00:10:49 <ThreeOfEight> and we had some really strange discretisation effect somewhere
00:11:05 <ThreeOfEight> it took us ages to track down this one place where we unknowingly used integer division
00:11:22 <kadoban> Heh, woops
00:11:24 <ThreeOfEight> (and then implicitly converted the reuslt to double)
00:12:09 <solatis> ThreeOfEight: you mean c/c++ code ?
00:12:22 <ThreeOfEight> solatis: C code, yes
00:12:25 <solatis> yeah
00:12:35 <solatis> that's why you should *always* compile with -Wall -Werror
00:12:42 <solatis> that will catch those types of errors iirc
00:13:20 <doismellburning> ghc-options: -Wall -Werror -fno-warn-missing-signatures
00:13:22 <doismellburning> ftw
00:13:25 <ThreeOfEight> even so, I think that ‘/’ is a curious choice for an integer division operator
00:13:42 <solatis> well the compiler is 'stupid'
00:14:07 <solatis> so it will just do what you tell it to do
00:14:16 <solatis> if you want to divide integers, go ahead and have fun
00:14:32 <ThreeOfEight> no, I mean I think it would be better to call it ‘div’ or something
00:14:39 <ThreeOfEight> ‘/’ is somewhat mathematically non-standard
00:14:47 <solatis> ah yes
00:14:50 <ThreeOfEight> but then again, so is ‘=’ for an assignment
00:15:33 <solatis> yeah and i still have to get used to /= instead of !=
00:15:39 <solatis> but all that is bikeshed
00:15:53 <johnw> go ahead and define != locally
00:15:56 <solatis> the real issue here is that you cannot really divide to integers and expect the result to be an integer
00:16:01 <kadoban> I still do that wrong basically every time, damn /=
00:16:08 <ThreeOfEight> I'm more of a fan of ≠
00:16:30 <ThreeOfEight> This is one of the things I like in Isabelle: operators look the way they're supposed to
00:16:55 <johnw> i just changed my editor to make them look that way too
00:17:06 <solatis> johnw: oh god, i hate that
00:17:21 <johnw> I type /=, the file contains /=, but I see ≠
00:17:23 <ThreeOfEight> I also keep writing \x -> foo as \x. foo in Haskell
00:17:23 <johnw> oh, I love it
00:17:44 <solatis> it defeats my principle of 'what you see is what you get'
00:17:45 <ThreeOfEight> writing abstractions with a -> is just weird
00:17:55 <johnw> now I can read ¬ (a ∧ b) ∨ c in a math paper and not have to translate
00:18:00 <ThreeOfEight> solatis: in the end, what you see is always just an interpretation of what you get
00:18:03 <johnw> because that's how my code looks too
00:18:06 <ThreeOfEight> what you get is a long string of bits
00:18:33 <ThreeOfEight> your editor chooses to display these bits in some way that depends on your encoding and your font and your desktop environment and your graphics driver
00:18:43 <ThreeOfEight> I don't see the problem of displaying /= as ≠
00:18:48 <ThreeOfEight> oh bugger, meeting in 7 minutes, really have to go
00:18:51 * ThreeOfEight afks
00:18:59 <ibotty> edwardk: if you are here, have you forgotten to push machines to github? also the changelog is a little underwhelming. has anything significantly changed?
00:19:38 * hackagebot lxc 0.3.1.1 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.3.1.1 (NickolayKudasov)
00:21:07 <ratsen> In wxHaskell how to make a widget resizable
00:21:21 <trap_exit> anyone here find living in the city sucks for programming at night? country side = quiet nights = better programming
00:21:49 <merijn> trap_exit: Get better headphones ;)
00:21:53 <dv-> install better windows
00:21:58 <trap_exit> fresh air
00:22:15 <trap_exit> the more I live in the city
00:22:17 <merijn> johnw: Ugh, Ulf got to you? :p
00:22:25 <trap_exit> the less I feel bad about software devs making millions and buying homes in the country side
00:22:34 <johnw> merijn: I don't do it to everything!
00:22:39 <ratsen> In wxHaskell how to make a widget resizable
00:22:49 <merijn> johnw: Is that an ascii exclamation mark? :)
00:24:01 <CrazyM4n> Well, I give up on getting helm to work
00:24:05 <CrazyM4n> Good night guys
00:47:17 <solatis> damn i'm actually starting to understand how to use all this nonsense
00:47:28 <solatis> i'm able to solve my cryptic compiler error messages myself now
00:47:32 <speak> Congrats :P
00:48:12 <solatis> took me a while to find out that everything revolves about return () when you're inside a monad
00:48:38 <jle`> um
00:48:40 <jle`> hopefully it doesn't :O
00:49:14 <solatis> then i still don't know what i'm talking about
00:49:55 <jle`> you probably do :)
00:52:42 <lpaste> solatis pasted “Making sense of conversions inside monads” at http://lpaste.net/112403
00:53:02 <solatis> just for the sake of having someone else look at it, does that code make sense?
00:53:07 <solatis> or would you write it differently?
00:53:31 <jle`> you don't use return () anywhere :D
00:53:36 <solatis> i do
00:53:42 <solatis> line 31
00:53:48 <jle`> ah
00:53:51 <jle`> i thought you meant, return ()
00:53:55 <jle`> :t return ()
00:53:56 <lambdabot> Monad m => m ()
00:54:12 <solatis> oh no, i only use that if i want to discard the output of an IO operation
00:54:42 <jle`> usually if you have a lot of return's, it's a sign that your code might not actualyl be monadic in nature, but applicativey or functory
00:54:54 <solatis> that could be correct
00:55:14 <jle`> allTitles = fmap decodeMany . rest =<< find (select [] "title")
00:55:16 <solatis> i think the allTitles function could be rewritten more elegantly / monadicly
00:55:29 <solatis> right, that
00:55:46 <jle`> that's how i'd do it at least
00:56:03 <solatis> that seems to be exactly what i was looking for
00:56:03 <jle`> the trick is knowing which function lifters you need
00:56:06 <jle`> you have an `m a`
00:56:10 <jle`> if you have an (a -> b), use fmap
00:56:13 <solatis> but i was trying to use mapM
00:56:16 <jle`> if you have an m (a -> b), use (<*>)
00:56:24 <jle`> if you have an (a -> m b), use (=<<)
00:57:01 <solatis> that is useful information
00:57:05 <solatis> i'll write it down
00:57:38 <solatis> :t mapM
00:57:39 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:57:53 <solatis> hmz
00:57:57 <solatis> :t sequence
00:57:58 <lambdabot> Monad m => [m a] -> m [a]
00:58:10 <solatis> hmz #2
00:58:39 <solatis> so sequence converts, say, [IO String] to IO [String] ?
00:59:10 <kadoban> Exactly
00:59:15 <solatis> right
00:59:20 <solatis> you see, i'm starting to grasp all this
00:59:40 * hackagebot scholdoc-types 0.1.3 - Scholdoc fork of pandoc-types  http://hackage.haskell.org/package/scholdoc-types-0.1.3 (timtylin)
01:01:15 <speak> I'm using http://happstack.com/page/view-page-slug/9/happstack-lite-tutorial   to get a small introduction to Haskell itself (since most tutorials I've found were pretty theoretical). Can anyone give me any pointers if this tutorials has any bad Haskell habits or otherwise bad code?
01:03:10 <kadoban> speak: That seems like a really hard way to learn much about haskell. Did you try real world haskell or lyah? Both are pretty practical, IMO. Not a ton of extraneous theory that I recall.
01:04:50 <frihd> speak: I agree with kadoban, it may be too many things at once
01:05:06 <kadoban> speak: I don't really see how you could learn haskell from that at all, it's more just a specific tutorial on using happstack at once, it teaches you almost nothing about the language that I can tell.
01:06:14 <speak> kadoban: Yeah I did try Real World Haskell, and it was super helpful to get me started. I didn't finish it however, so I'll give it it another go. I may've not seen lyah, will check that out as well, thank you
01:06:37 <frihd> speak: maybe you can have a look at  http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:06:56 <kadoban> I mostly just learned by going back and forth between the two when I got bored/confused and it worked out okay so far.
01:07:10 <bartavelle> speak, if you already are started, then writing an actual application might help
01:07:43 <speak> frihd & kadoban yeah, my method is to use the happstack tutorial to see what can actually be done with Haskell that relates to what I'm going to use it for. I do of course reference the haskell website and other sources to actually find out about the syntax and what everything does
01:07:45 <Cale> @where lyah
01:07:45 <lambdabot> http://www.learnyouahaskell.com/
01:08:14 <speak> Ah yes I did check that one out as well
01:08:29 <kadoban> If you've already gone through at least some of RWH, my objection to that tutorial is a lot less strong. You may get something out of it then.
01:08:34 <bartavelle> I did read half of RWH when I started, got bored a bit, brute-forced a parsec-parser, and finally got to try to write the pure code that interpreter the parsed file. In the end monads finally clicked and I rewrote everything ;)
01:08:51 <speak> frihd: Thanks for the scheme link as well
01:09:08 <speak> kadoban Okay, that's good to know, and thanks bartavelle as well
01:10:13 <speak> I'll continue with the happstack tutorial for now, referencing the other "real" haskell tutorials and books. I just want to make sure the happstack tutorial isn't teaching some horrible form
01:10:38 <speak> (Which I might not catch simply by referencing other sources)
01:11:21 <Cale> It's not too unreasonable style-wise
01:11:22 <speak> Nice thing about the Happstack tutorial is though, I really have something that works after a relatively short period of time, which helps me stay motivated :)
01:11:39 <speak> Cale: Thanks for looking into it
01:11:48 <Cale> There are a couple stylistic things I might do differently, but they're pretty minor
01:12:20 <trap_exit> in ahskell, is there a syntax for updating _a single field_ of a data ?
01:12:32 <Cale> trap_exit: There's the record update syntax
01:12:37 <bartavelle> tranma, foo { field = value } for records
01:12:47 <bartavelle> erm "foo { field = value}"
01:12:55 <trap_exit> http://stackoverflow.com/questions/14955627/shorthand-way-for-modifying-only-one-field-in-a-record-copy-a-record-changing
01:12:58 <trap_exit> stack overflow agrees with you
01:13:18 <trap_exit> bartavelle: tab complete fail? :-)
01:13:34 <bartavelle> indeed
01:17:53 <redtricycle> Are there rules of thumb in Haskell, like "always import qualified" to avoid polluting the namespace?
01:18:04 <redtricycle> more styleistic
01:18:23 <doismellburning> rightrhlint?
01:18:32 <doismellburning> ...wow tab complete went wrong there, sorry
01:18:35 <doismellburning> redtricycle: hlint?
02:04:43 * hackagebot scholdoc-texmath 0.1 - Scholdoc fork of texmath  http://hackage.haskell.org/package/scholdoc-texmath-0.1 (timtylin)
02:04:47 <zipper> Hey I am having trouble defining an Ordering instance for a type I defined myself. Here it is. https://gist.github.com/urbanslug/11e6c571d078867dd649
02:05:40 <AshyIsMe> so this is a pretty straightforward error but how do i go about fixing it?
02:05:41 <AshyIsMe> cabal: Haddock's internal GHC version must match the configured GHC version.
02:05:42 <AshyIsMe> The GHC version is 7.8.3 but haddock is using GHC version 7.6.3
02:06:15 <supki> zipper: what's the error?
02:06:26 <supki> zipper: oh, the name of the class is Ord, not Ordering
02:06:41 <Haskellfant> also you're missing a compare before the arguments
02:07:53 <supki> and probably Eq and Ord instances should agree on which things are equal
02:08:22 <zipper> supki: Hmmm it's not giving me an error now but I don't trust it.
02:10:34 <zipper> I fixed it by making Ordering Ord and adding compare before the typeclasses but now I get this warning
02:10:46 <zipper> Orphan instance: instance Ord LogMessage
02:10:55 <zipper> supki:  Haskellfant ^^
02:11:20 <nshepperd> if you're doing that sort of "ordering by a field" thing, you might be better off using the *By (sortBy, ...) functions with 'comparing getTimeStamp'
02:11:23 <zipper> I don't see why I have the error. Didn't I need an Ord instance to use sort from Data.List?
02:12:02 <Haskellfant> zipper: could you update the gist?
02:12:04 <zipper> I am doing question 5 in http://www.seas.upenn.edu/~cis194/hw/03-ADTs.pdf from http://www.seas.upenn.edu/~cis194/lectures.html week 3 assignment.
02:12:54 <mauke> that's just sortBy compareMsgs, isn't it?
02:13:28 <nshepperd> oh, if you already wrote compareMsgs :: LogMessage -> LogMessage -> Ordering then you want sortBy, not sort
02:13:30 <Haskellfant> mauke: if you're going to write a compare function anyway why not make it an instance of Ord?
02:13:35 <zipper> nshepperd: I have not heard of your method.
02:13:49 <zipper> Haskellfant: I have updated it.
02:14:07 <nshepperd> sortBy is exactly designed to take such an Ordering function
02:14:11 <mauke> Haskellfant: wasn't part of the exercise
02:14:23 <Haskellfant> mauke: oh k, I didn't read the exercise :)
02:14:57 <zipper> nshepperd: I don't mind knowing something new. Where can I read about sortBy?
02:15:15 <jle`> :t sortBy
02:15:16 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
02:15:21 <jle`> @hoogle sortBy
02:15:23 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
02:15:23 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
02:15:23 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
02:15:24 <Haskellfant> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:sortBy
02:15:36 <mauke> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#g:25
02:16:31 <Haskellfant> zipper: hm looks correct to me
02:16:59 <zipper> I already had a function that did (a -> a -> Ordering).
02:17:01 <zipper> :)
02:17:38 <zipper> I just added it to the gist. compareMsgs
02:17:49 <Haskellfant> zipper: even compiles fine with -Wall here
02:18:02 <Haskellfant> no idea what's giving you that orphan instance warning
02:18:28 <zipper> Haskellfant: hmmm it gives you no error? Let me give you my full Log and LogAnalysis files.
02:18:35 <zipper> I mean warning
02:18:41 <mauke> do you have the instance in a different file?
02:19:13 <nshepperd> zipper: the "Orphan instance" warning just says you've put the instance in a separate file to where the data type is defined
02:21:00 <jle`> it happens
02:21:33 <zipper> nshepperd: Oh I see :)
02:21:36 <zipper> https://gist.github.com/urbanslug/87f7b1fa823b310c97fd
02:21:36 <nshepperd> zipper: which is not neccessarily a problem, but it's just good style to define instances together with either the data type or the class definition
02:22:15 <zipper> mauke: Yes I do. The new gist I posted tells it all.
02:22:35 <nshepperd> so that for instance a library user doesn't have to worry about importing instances deliberately
02:23:34 <zipper> nshepperd: sortBy way of doing it is so easy it feels like cheating. I even commented it out :)
02:23:34 <zipper> nshepperd: Makes sense
02:24:04 <nshepperd> :)
02:28:02 <zipper> Thanks you guys are very helpful.
02:29:12 <nshepperd> zipper: with 'comparing' from Data.Ord it gets even easier. the definition of your compareMsg can be made into 'compareMsg = comparing getTimeStamp where getTimeStamp (LogMessage _ t _) = t'
02:29:30 <nshepperd> so the whole sort function could be just 'sortBy (comparing getTimeStamp)'
02:29:57 <nshepperd> "sort, by comparing timestamps"
02:30:09 <mauke> you need to define compareMsg for the preceding exercise, though :-)
02:30:15 <nshepperd> indeed
02:38:28 <nkar> is there a trick that can be used to list all value constructors of a datatype?  for instance, vcons (typeOf True) => [True, False]
02:39:27 <zwer_z> if type derives Bounded and Enum it is easy..
02:39:35 <zwer_z> > [minBound..] :: [Bool]
02:39:37 <lambdabot>  [False,True]
02:40:34 <nkar> zwer_z: no, it doesn't.
02:41:14 <mauke> > dataTypeOf True
02:41:15 <lambdabot>  DataType {tycon = "Prelude.Bool", datarep = AlgRep [False,True]}
02:41:32 <opqdonut> > dataTypeOf (Just True)
02:41:33 <lambdabot>  DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
02:41:36 <mauke> > dataTypeRep (dataTypeOf True)
02:41:37 <lambdabot>  AlgRep [False,True]
02:41:48 <mauke> > dataTypeRep (dataTypeOf Nothing)
02:41:48 <kadoban> > :t dataTypeOf
02:41:49 <lambdabot>  can't find file: L.hs
02:41:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
02:41:49 <lambdabot>    arising from a use of ‘Data.Data.dataTypeOf’
02:41:49 <lambdabot>  The type variable ‘a0’ is ambiguous
02:41:49 <lambdabot>  Note: there are several potential instances:
02:41:51 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
02:45:23 <nkar> mauke: oh, thanks.
03:00:24 <nkar> is there an extension that will allow me to write something like \args* -> ... where args* denotes all the arguments?
03:00:44 <zipper> > :t take
03:00:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:00:46 <mauke> every function takes exactly one argument
03:00:54 <zipper> > take
03:00:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
03:00:56 <lambdabot>    arising from a use of ‘M680785524338314721428884.show_M6807855243383147214...
03:00:56 <lambdabot>  The type variable ‘a0’ is ambiguous
03:00:56 <lambdabot>  Note: there are several potential instances:
03:00:56 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:00:57 <mauke> \arg -> ... is all the arguments
03:01:10 <zipper> :t take
03:01:11 <lambdabot> Int -> [a] -> [a]
03:06:44 <nkar> mauke: I'm aware that \x y -> ... corresponds to \x -> (\y -> ...).  I wonder whether there is something that would allow me to write \x y rest -> ... which would automatically return rest as a list.
03:07:19 <johnw> he means like CL's &rest
03:07:24 <johnw> there is no way to do this in Haskell
03:07:28 <nkar> right
03:07:31 <nkar> okay
03:07:33 <mauke> nkar: what would rest be?
03:07:52 <mauke> it's not that this feature doesn't exist; I don't understand how it would work if it did exist
03:08:28 <johnw> defun foo (x y &rest args) ... ; (foo 1 2 3 4 5); x = 1, y = 2, args = '(3 4 5)
03:08:35 <nkar> right
03:09:03 <johnw> Python and I think Ruby call it *args
03:09:23 <mauke> I know CL
03:09:44 <johnw> then why are you acting like his questions makes no sense?
03:10:05 <mauke> because it makes no sense
03:10:10 <johnw> it's a perfectly reasonable thing to wonder, and the answer is just "no"
03:10:25 <mauke> I don't know what that thing is you're wondering about
03:11:44 <mauke> the CL concepts just don't line up with Haskell
03:11:48 <dramforever> No, because functions can return functions, so there's no way to tell which argument is to which function
03:11:51 <dramforever> for example:
03:12:01 <dramforever> > id (+1) (2 :: Int)
03:12:03 <lambdabot>  3
03:12:14 <ChristianS> johnw: haskell has strict typechecking, if you want a list as last argument, just pass a list as last argument
03:12:17 <dramforever> > id id id id id id id "hi"
03:12:18 <lambdabot>  "hi"
03:12:55 <dramforever> Hey, maybe johnw wants something like printf? but it's a bit hard to do
03:13:03 <johnw> i didn't want it
03:13:07 <dramforever> > printf "%d %d %d
03:13:08 <lambdabot>  <hint>:1:17:
03:13:08 <lambdabot>      lexical error in string/character literal at end of input
03:13:09 <mauke> (funcall (funcall (funcall (funcall #'id #'id) #'id) #'id) "hi")
03:13:19 <dramforever> > printf "%d %d %d" 1 2 3
03:13:20 <lambdabot>  No instance for (GHC.Show.Show a0)
03:13:20 <lambdabot>    arising from a use of ‘M719529656893722027429100.show_M7195296568937220274...
03:13:20 <lambdabot>  The type variable ‘a0’ is ambiguous
03:13:20 <lambdabot>  Note: there are several potential instances:
03:13:20 <lambdabot>    instance [safe] GHC.Show.Show
03:13:56 <dramforever> > printf "%s foo %s bar" "f" "b"
03:13:58 <lambdabot>  No instance for (GHC.Show.Show a0)
03:13:58 <lambdabot>    arising from a use of ‘M45992670753780010529112.show_M45992670753780010529...
03:13:58 <lambdabot>  The type variable ‘a0’ is ambiguous
03:13:58 <lambdabot>  Note: there are several potential instances:
03:13:58 <lambdabot>    instance [safe] GHC.Show.Show
03:14:18 <mauke> dramforever: :-(
03:14:19 <dramforever> > printf "%s foo %s bar" "f" "b" :: String
03:14:21 <lambdabot>  "f foo b bar"
03:14:29 <dramforever> oh I need some context
03:14:34 <dramforever> needed
03:14:57 <Kinnison> johnw: How's gitlib these days?
03:15:11 <johnw> it's pretty quiet
03:15:33 * Kinnison is, once again, considering replacing his blog engine and is tempted to hack something up in Haskell just "because"
03:15:41 <Kinnison> blog engines are so much fun to rewrite over and over
03:15:42 <Kinnison> oh yes
03:15:54 <johnw> make a custom build for it too
03:15:56 <johnw> build tool*
03:16:05 <Kinnison> I'm happy with cabal for that tbf
03:16:09 * dramforever would prefer a static pages based blog
03:16:18 <johnw> I use Hakyll now
03:16:25 <Kinnison> dramforever: I *like* live blogs
03:16:31 <dramforever> (I think it's) faster and safer
03:16:32 <Kinnison> dramforever: particularly live from the underlying git repo
03:16:53 <dramforever> Kinnison: well, it *is* fun to write over and over again
03:17:03 <Kinnison> If I wanted a static generator, I'd just use ikiwiki
03:17:09 <Kinnison> plus it'd be trivial to cache results to return
03:17:21 <Kinnison> tree SHA as the key
03:19:26 <J_Arcane> I use Frog and Github for my programming blog; kinda like the static approach because it gives me an excuse to use Emacs awesome markdown-mode.
03:19:41 <zipper> Shouldn't getMessageType work for the type defined in Log.hs in this gist https://gist.github.com/urbanslug/87f7b1fa823b310c97fd
03:19:49 * dramforever likes haskell because even the source code of standard libraries are so concise and elegant
03:20:21 <zipper> I don't get why it wants me to define it yet I thought we get such functions for free.
03:21:11 <dramforever> zipper: I'm not sure what to do
03:21:14 <dramforever> what do you want?
03:22:34 <Kinnison> J_Arcane: I run my own git server, but I'll take a look at Frog.  As for markdown -- of course I'd be using it :-)
03:22:37 <zipper> dramforever: I want to use getMessageType to get the message type for example of such a LogMessage:  `LogMessage (Error 101) 2001 "My God! It’s full of stars!"`
03:22:59 <Kinnison> J_Arcane: do you have a link for Frog?  It's a tad hard to google for
03:23:10 <dramforever> zipper: that's not going to work, what if you have data Foo = Foo Int Int Double ?
03:23:16 <J_Arcane> Kinnison: Frog is here: https://github.com/greghendershott/frog
03:23:46 <dramforever> and many will be racing for things like getInt
03:23:49 <Kinnison> Oh gods, it's another language
03:23:53 <J_Arcane> It's Racket though, not Haskell. (Racket is kinda my main language)
03:24:05 <dramforever> zipper: You need your own function like:
03:24:30 <dramforever> getMessageType (LogMessage mt _ _) = mt
03:24:44 <fizruk> or record syntax
03:25:04 <zipper> fizruk: I thought I was using record syntax.
03:25:11 <zipper> dramforever: ^
03:25:14 <dramforever> nope
03:25:17 <Kinnison> J_Arcane: I'm less interested now it's another language I don't already know :-)
03:25:19 <J_Arcane> You don't really need to know any Racket to use it, though you do have to have it installed.
03:25:59 <fizruk> zipper: data LogMessage = LogMessage { getMessageType :: MessageType, … } deriving (…)
03:26:03 <dramforever> zipper: data This = {is :: Re, cord :: Syntax}
03:26:26 <dramforever> data ThisIs = NotRecord Syntax At All
03:26:45 <zipper> dramforever: lol
03:26:53 <fizruk> data ButThisIsBothIGuess
03:26:53 <zipper> Thanks you guys
03:27:36 <dramforever> fizruk: data T = H Is | Al { s :: O, bo :: Th }
03:28:03 <dramforever> zipper: I hope this bizarre thing can make you remember it
03:28:21 <fizruk> dramforever: that last one should not be valid
03:28:33 <vanila> s (H i) ==> crash!
03:28:33 <dramforever> fizruk: oh? let me see
03:28:41 <vanila> I think that it is valid
03:28:45 <vanila> it j ust breaks esaily
03:28:47 <fizruk> dramforever: I mean it works, but is bad
03:28:50 <zipper> dramforever: lol it can't. I'll have to read on it.
03:28:58 <zipper> Seems I forgot a lot.
03:29:27 <dramforever> vanila: Yeah I know
03:29:49 <dramforever> Seems that multiple constructors with record syntax == evil
03:29:55 <vanila> why stop there? :)
03:30:01 <zipper> I found http://stackoverflow.com/questions/5367167/haskell-record-syntax
03:30:01 <vanila> record syntax AT ALL is evil
03:30:11 <vanila> although I do like it in newtypes...
03:30:27 <dramforever> vanila: well, see (iirc) Text.Parsec.Token
03:31:10 <dramforever> it uses record syntax to build a "record" of Parser's
03:32:35 <dramforever> Hm...Does anyone know if we can have top level patterns like: module M where (Just x) = lookup "1" [("1", "x"), ("f", "b")]
03:32:48 <fizruk> dramforever: we can
03:33:00 <dramforever> does the haskell report say anything about it?
03:33:21 <fizruk> dramforever: a, b, c, d, e :: Char[a, b, c, d, e] = “abcde”
03:33:42 <fizruk> missed newline
03:34:03 <dramforever> fizruk: okay, then how will haddock react? has anyone tried?
03:34:11 <dramforever> maybe I try this myself
03:34:14 <Heather> I've got problem creating System.Threading.ParameterizedThreadStart delegate ...
03:35:00 <Heather> way to complicated, someone want to try .NET wrapper? here is what it generated http://lpaste.net/112406
03:35:12 <fizruk> dramforever: you can write each type signature separately with its own haddock comment
03:35:44 <dramforever> fizruk: oh, haddock looks at type signatures...thanks
03:35:55 <fizruk> dramforever: https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/src/Debug-SimpleReflect-Vars.html
03:38:39 <Lutin`> fml
03:39:12 <dramforever> idea: how to solve this: say I made a data stream processing library, and I have a class StreamLike t s | s -> t where uncons :: s -> Maybe (t, s)
03:39:28 <dramforever> And then I have problem making default instances
03:39:52 <Lutin`> I have to use APL for this one class and if that's not bad enough, I just lost 2 hours worth of work because the IDE crashed due to the multi-precision library it was using.
03:40:09 <dramforever> if I want to make instances for Data.Text.Text, my library would have to depend on text, which is not always desired
03:40:41 <dramforever> on the other hand, most users would probably expect such a instance, as Text is so popular
03:42:05 <dramforever> I think I've seen some instance-only packages, but this is ... I don't know how to put it ...
03:44:58 * hackagebot hspec-wai 0.5.1 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.5.1 (SimonHengel)
03:51:27 <zipper> I am trying to check whether the MessageType is an error. Message type is defined in https://gist.github.com/urbanslug/d493ee67aada7d564bbb
03:51:53 <zipper>  I tried `getMessageType x == Error _` but it seems I can't use _ to represent any int with ==
03:52:09 <Cale> You should use case
03:52:16 <Cale> Or otherwise pattern match
03:52:24 <Lutin`> Hey Cale
03:52:28 <Cale> Hello
03:53:14 <zipper> Cale: Well I am in a lambda to check. It looks like:
03:53:16 <zipper>  filter (\x -> (getMessageType x == Error _) listOfLogs
03:53:49 <zipper> but well it won't match _ with any it.
03:53:54 <zipper> *int
03:54:02 <Cale> Well, yeah, _ isn't an expression, it's a pattern
03:55:10 <Cale> filter (\x -> case getMessageType x of Error _ -> True; _ -> False) listOfLogs
03:55:24 <Cale> Or, you could write something like...
03:55:42 <Cale> [x | x <- listOfLogs, Error _ <- [getMessageType x]]
03:56:07 <zipper> Cale: OMFG these list comprehensions. I should really learn to use them.
03:57:08 <Cale> Or of course, you might want to define isError somewhere
03:57:20 <Cale> isError (Error _) = True; isError _ = False
03:57:29 <Cale> and then filter isError listOfLogs
03:58:15 <zipper> Cale: You're spitting gems.
03:58:34 <Cale> Well, filter (isError . getMessageType) listOfLogs rather
03:59:53 <zipper> Cale: Thanks
04:00:14 <Cale> no problem
04:00:38 <int-index> How do I export custom information using Paths_pkgname in Cabal?
05:03:38 <nilg`> filter for 2 lists?
05:04:30 <nilg`> otherwise, fold for 2 lists?
05:07:15 <nilg`> or looks like zipWith with a way to filter would do what I want, any idea?
05:07:24 <nilg`> guys?
05:07:31 <ThreeOfEight> nilg`: what do you want to do?
05:08:47 <nilg`> ThreeOfEight: let's say I have a mask [Bool], and a list [a], and I would like to select only the elements in [a] when the corresponding element in [Bool] is True
05:09:13 <mauke> start by zipping them up into a single list
05:17:31 <ThreeOfEight> nilg`: map snd $ filter fst $ zip as bs
05:19:18 <exio4> map snd . filter fst $ zip as bs
05:29:22 <nilg`> thanks guys, I'm still new to Haskell and that helps
05:31:24 <mauke> [ x | x <- xs | b <- bs, b ]
05:31:54 <mauke> > let xs = "hello"; bs = [True, False, False, True, True] in [ x | x <- xs | b <- bs, b ]
05:31:55 <lambdabot>  "hel"
05:32:06 <mauke> hmm
05:33:44 <ThreeOfEight> mauke: this doesn't work
05:33:47 <ThreeOfEight> I thought about the same thing
05:34:04 <ThreeOfEight> but the problem is that the ", b" at the end applies only to the "b <- bs" part
05:34:08 <ThreeOfEight> not to the entire comprehension
05:34:45 <mauke> > let xs = "hello"; bs = [True, False, False, True, True] in [ x | (x, True) <- zip xs bs ]
05:34:47 <lambdabot>  "hlo"
05:54:08 <rydgel> @pl \xs n -> take n xs ==> flip take
05:54:08 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
05:55:09 <notdan> @ty (==>)
05:55:10 <lambdabot> Testable prop => Bool -> prop -> Property
05:55:16 <notdan> oh
05:56:03 <int-e> the @pl command doesn't care whether the identifiers exist, nor about their types
05:56:09 <int-e> @pl \x -> x x
05:56:09 <lambdabot> join id
05:56:15 <int-e> @type join id
05:56:16 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
05:56:16 <lambdabot>     Expected type: a1 -> a1 -> a
05:56:16 <lambdabot>       Actual type: a1 -> a1
05:56:34 <int-e> (nor about typability)
06:00:04 * hackagebot ieee754 0.7.4 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.4 (PatrickPerry)
06:18:24 <Kron> is there any way to make haskell-mode typecheck the code underneath your point?
06:25:33 <benzrf> :t \x -> x x
06:25:34 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
06:25:34 <lambdabot>     Relevant bindings include x :: t1 -> t (bound at <interactive>:1:2)
06:25:34 <lambdabot>     In the first argument of ‘x’, namely ‘x’
06:32:22 <gcganley> benzrf: what were you trying to do with that code?
06:32:50 <benzrf> just seeing if i t would be an error
06:39:50 <hmot> Hi all. I'm trying to make my if statements more concise: in an IO function, i've got this:
06:40:04 <hmot> if doPrint
06:40:07 <hmot>   then print ...
06:40:11 <hmot>   else return ()
06:40:20 <triliyn> :t guard
06:40:21 <lambdabot> MonadPlus m => Bool -> m ()
06:40:26 <vanila> you can use when
06:40:38 <triliyn> oh, right, when is probably better
06:40:52 <hmot> huh, ok
06:40:54 <pjdelport> guard won't work with IO
06:40:55 <hmot> that sounds good
06:42:49 <hmot> having "else return ()" does tend to confuse people a bit
06:53:07 <zipper> Ok RegEx in haskell is not easy.
06:53:58 <frihd> to be faire, regexp never are easy =)
06:54:09 <zipper> Is there another way to search whether a certain word is contained in a string without using regular expressions.
06:54:14 <frihd> or easy to use wrong
06:54:48 <zipper> frihd: I can't even find which regex library to use for one. I am reading http://www.haskell.org/haskellwiki/Regular_expressions
06:54:49 <frihd> zipper: there are plenty utility functions in Data.Text
06:55:39 <ClaudiusMaximus> @hoogle isInfixOf
06:55:41 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
06:55:41 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
06:55:41 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
06:56:44 <frihd> exists also for Data.Text
06:57:31 <zipper> ClaudiusMaximus: Thanks
06:57:40 <frihd> zipper:  coming from ruby, I never used regexps in haskell so far,  either simple manipulations or (atto)?parsec
06:57:57 <zipper> frihd: I came from ruby too
06:58:09 <zipper> frihd: Could you recommend a regexp library?
06:58:18 <frihd> no, i never used one
06:58:26 <zipper> I am at question 7 of this http://www.seas.upenn.edu/~cis194/hw/03-ADTs.pdf
06:58:50 <zipper> I don't think I need regexp since it's not in the scope of the exercise but...
07:00:24 <mauke> turns out full-blown parser libraries are easier to use than regexp libraries in haskell
07:00:41 <zipper> mauke: lol
07:00:42 <Kinnison> Depends on what you're after
07:00:50 <frihd> I see, depending on "how advanced" is the lesson, I'd say you should either write imperatively (lines, splits, breaks etc.) or use a parser combinator libary
07:00:50 <Kinnison> For simple things, regexps are pretty easy
07:00:57 <zipper> I couldn't even find one regexp lib that I could use.
07:00:58 <geekosaur> zipper: do you have the cited Log.hs?
07:01:07 <Kinnison> for more complex regexpy things, I tend to go to Parsec anyway
07:01:13 <mauke> exercise 7 just needs a substring check
07:01:17 <geekosaur> hint: they do not expect or want you to use regex
07:01:21 <zipper> Is there a way to make isInfixOf case insensitive.
07:01:24 <geekosaur> I don't thibnk they even expect parsec
07:01:26 <zipper> geekosaur: I do
07:01:40 <mauke> zipper: lowercase both strings first
07:01:57 <geekosaur> zipper: you should take the regex library thing as a hint
07:02:02 <zipper> geekosaur: meh I can go out of scope. They don't expect one to know regexp even exists :)
07:02:13 <floresiensis> Using MWC and Data.Vector, I've gotten the performance of this program to 4x slower than C, which is not too bad, but I still expected faster. SBCL is very near C, within 20%. Any suggestions welcome. https://gist.github.com/anonymous/e3b141f0f98f84ad5899
07:02:16 <geekosaur> you should still take the regex library thing as a hint
07:02:18 <zipper> geekosaur: Which regex library thing
07:02:26 <geekosaur> regex is not the preferred solution in haskell
07:02:31 <zipper> mauke: lol I should've thought of that. toLower
07:02:39 <zipper> hmmmmm
07:02:45 <geekosaur> if you want to learn Haskell, you might want to learn Haskell and not perl-in-Haskell
07:02:46 <floresiensis> Also feel free to make style suggestions, like what would a pro do that I'm not doing.
07:03:01 <zipper> geekosaur: but... but... regex in other languages is such a one weapon to slay them all
07:03:05 <geekosaur> or python-in-Haskell etc.
07:03:06 <zipper> :(
07:03:14 <mauke> pfft, Haskell isn't even close to having Perl style regexes
07:03:14 <geekosaur> it's an often abused tool
07:03:22 <frihd> zipper:  yeah, and bring a bug and all its siblings to your house too
07:03:25 <geekosaur> it's often not appropriate but used anyway
07:03:27 <mauke> all Haskell regex libraries suck
07:03:37 <smart_ptr> is the dot operator equivalent to braces? x . y === (x (y)) ?
07:03:42 <geekosaur> ^ this is the library situation, which you'd already noted
07:03:49 <mauke> smart_ptr: no
07:03:57 <geekosaur> smart_ptr, not equivalent to braces/parens, no
07:03:58 <zipper> :t toUpper
07:03:58 <lambdabot> Char -> Char
07:03:59 <mauke> smart_ptr: also, (x (y)) is x y
07:04:06 <frihd> I can write quite advanced ruby regexps, but never re-read them =)
07:04:15 <mauke> smart_ptr: x . y = \k -> x (y k)
07:04:15 <smart_ptr> ok
07:04:22 * geekosaur is past master of regexes
07:04:24 <zipper> :toLower
07:04:31 <smart_ptr> mauke: that makes sense, thanks!
07:04:32 <geekosaur> this turns out to include when *not* to use them
07:04:37 <zipper> : toDowncase
07:04:38 <artyomkazak> floresiensis: can you give the SBCL code for comparison?
07:09:00 <floresiensis> artyomkazak: sure, but I'm not doing mutation in SBCL if that's what you were wondering.
07:09:17 <mauke> :t isInfixOf `on` map toLower
07:09:18 <lambdabot> [Char] -> [Char] -> Bool
07:11:40 <floresiensis> artyomkazak: do you want just the basic algorithm in lisp, or the performance code? (With or without types?)
07:12:11 <pjdelport> smart_ptr: (f . g) x = f (g x)
07:12:36 <smart_ptr> yup, thanks again!
07:12:49 <artyomkazak> hm, I might not even understand it without types, so with types, I guess
07:12:54 <artyomkazak> the performance code, yep
07:14:40 <pjdelport> floresiensis: Have you profiled?
07:17:22 <floresiensis> pjdelport: unfortunately my profile libs are hosed. I'm on 32-bit linux, which seems missed by haskell platform.
07:17:49 <floresiensis> when I compile with profiling, it says the libs aren't there
07:19:47 <floresiensis> cabal doesn't seem to compile profile libs, at least by default
07:20:31 <zipper> Ok me again.
07:20:34 <floresiensis> what is the common fix for "Perhaps you haven't installed the profiling libraries..."?
07:20:45 <zipper> How come I can't use map.toLower
07:20:54 <zipper> Yet I can use map toLower string
07:20:54 <bergmark> floresiensis: to install them :-)
07:21:01 <floresiensis> ok, how?
07:21:10 <artyomkazak> enabling “library-profiling: True” in ~/.cabal/config
07:21:11 <zipper> To me it should just work.
07:21:20 <mauke> :t map.toLower
07:21:21 <lambdabot>     Couldn't match type ‘Char’ with ‘a -> b’
07:21:21 <lambdabot>     Expected type: Char -> a -> b
07:21:21 <lambdabot>       Actual type: Char -> Char
07:21:23 <artyomkazak> and... then I don't know, I just did cabal install world
07:21:25 <floresiensis> why didn't cabal install them?
07:21:28 <artyomkazak> and went to drink tea
07:21:30 <bergmark> floresiensis: and executable-profiling
07:21:31 <mauke> zipper: no, that can't work
07:21:40 <bergmark> floresiensis: and make a new sandbox to reinstall everything
07:21:56 <zipper> mauke: Because map type to change?
07:22:02 <bergmark> floresiensis: cabal can, and you can run everything in profiling but compiling and running is much slower
07:22:18 <mauke> zipper: ?
07:22:29 <zipper> mauke: map.toLower
07:22:49 <mauke> zipper: what?
07:23:08 <zipper> to me it should be like (a -> a) -> [a] -> [a]
07:23:20 <zipper> The type of map.toLower
07:23:24 <dv-> but it's not
07:23:28 <mauke> you've completely lost me
07:23:39 <pjdelport> zipper: What are you using that . for?
07:23:40 <mauke> map . toLower is the same as \x -> map (toLower x)
07:23:43 <mauke> toLower x is a Bool
07:23:46 <mauke> map requires a function
07:23:49 <mauke> Bool is not a function
07:24:03 <artyomkazak> you meant Char?
07:24:06 <mauke> oops
07:24:09 <mauke> was thinking isLower
07:24:16 <mauke> yes, s/Bool/Char/g
07:24:30 <zipper> pjdelport: I want to make it do  map then toLower
07:24:31 <pjdelport> zipper: In Haskell, the . is either function composition, like "f . g", or part of a namespace prefix, like Data.List.map
07:24:48 <pjdelport> zipper: What do you mean by "do map"?
07:25:09 <zipper> pjdelport: I want to do function composition.
07:25:12 <mauke> no, you don't
07:25:14 <pjdelport> zipper: You can say "map toLower": that means to map the toLower function across the characters of a list / string.
07:25:43 <zipper> pjdelport: That works but I want to do function composition.
07:25:58 <pjdelport> zipper: What you mean by "do function composition"?
07:26:17 <zipper> pjdelport: I want to achieve function composition :)
07:26:24 <pjdelport> zipper: What do you mean by that?
07:26:26 <vanila> zipper, (.) operator for that
07:26:26 <bartavelle> id . map toLower
07:26:29 <vanila> f . g
07:26:32 <pjdelport> zipper: Are you sure you understand what function composition is?
07:26:33 <mauke> vanila: scroll up
07:26:46 <pjdelport> It does not make sense in the above context.
07:28:44 <zipper> pjdelport: It's (func1 (funct2 x))
07:29:13 <pjdelport> zipper: That's just function application.
07:29:36 <mauke> zipper: in your case that would be map (toLower x) -- which makes no sense
07:29:53 <pjdelport> zipper: Composition in this context generally means using the (.) operator, which does not make sense with map and toLower.
07:30:22 <pjdelport> zipper: What you *can* do would be something like: words . map toLower
07:30:46 <zipper> mauke: I see yeah toLower x would make no sense
07:31:09 <pjdelport> zipper: That uses (.) to make a function that first applies "map toLower" to a string, and then applies "words" on the result.
07:31:26 <pjdelport> "to the result", even
07:31:57 <Forkk> Is there an easy way to hide a monad without having to newtype it?
07:32:08 <Forkk> can I just use a type alias and not export it or something
07:32:14 <bergmark> Forkk: no
07:32:21 <Forkk> ugh
07:32:30 <benzrf> Forkk: hide a monad?
07:32:36 <marvimias> Anyone got any fairly advanced Haskell/math challenges they have thought of, preferable involving parametric polymorphism?
07:32:37 <bergmark> i don' think adding a newtype is ugh-worthy
07:33:04 <Forkk> bergmark, it's really annoying having to declare instances of MonadBaseControl
07:33:05 <bartavelle> Forkk, you can derive the monad instance automatically from the newtype
07:33:15 <bergmark> Forkk: this is true :-)
07:33:17 <Forkk> yes, but not all of them
07:33:23 <bartavelle> ah really ??
07:33:36 <Forkk> and I need a few of these monads. Maybe I should rethink my design
07:33:45 <Forkk> basically, I want to have stackable contexts
07:33:49 <bartavelle> ohhh
07:33:56 <Forkk> for example, I have a database with users
07:34:06 <Forkk> each user has a list of networks (IRC networks)
07:34:31 <Forkk> I want to be able to have a monad that behaves kind of like a reader for the users or something
07:34:41 <bartavelle> (hum, well, I still don't see it, I thought GeneralizedNewtypeDeriving guarantees you can derive anything)
07:34:46 <Forkk> so I can define some simple functions for changing the database
07:35:36 <Forkk> but they should be stackable, so if I have a network name, I can just call "withNetwork" and pass in a network name and a computation that runs in the context of a network state or whatever
07:36:12 <bartavelle> isn't that "hoist" ?
07:36:22 <Forkk> I don't think so...
07:36:27 <Forkk> dunno
07:36:41 <bartavelle> no it's probably not, I thought it was something else :/
07:37:01 <Forkk> I know I'm going to need to wrap ReaderT in a newtype at least once
07:37:08 <Forkk> I want to avoid doing it a lot though
07:37:25 <stolaruk> I'm trying to think of how to best explain how "($)" works given its type signature of "(a -> b) -> a -> b". When "($)" is used infix, the first parameter is everything to the left of the "$" and the third parameter is everything to the right of the "$", correct?
07:37:30 <Forkk> hell, I might end up breaking this out into a library
07:37:43 <Forkk> stolaruk, yes
07:37:46 <stolaruk> sorry s/third/second
07:37:59 <mauke> x $ y means ($) x y
07:38:54 <stolaruk> thx
07:39:13 <bartavelle> Forkk, what if you go the "operational" way ? You'll have ReaderT as a base monad, and have MonadReader for free
07:39:26 <Forkk> hmm
07:39:36 <pjdelport> floresiensis: I annoted your gist with some quick profiling results: https://gist.github.com/anonymous/e3b141f0f98f84ad5899#comment-1315975
07:39:45 <Forkk> bartavelle, I don't think you can stack multiple readers, can you?
07:39:45 <bartavelle> then you export only functions that call the "singleton Xxx" stuff
07:39:58 <bartavelle> Forkk, oh I didn't understand the requirement, I'm sorry
07:40:04 <bartavelle> there is a package for this
07:40:09 <Forkk> yeah, I didn't do a good job of explaining
07:40:12 <bartavelle> extensible effects or something ?
07:40:20 <bartavelle> I think it has that magic in it
07:40:26 <Forkk> hmm
07:40:32 <pjdelport> floresiensis: Seems like 85% of the time (and 97% of allocations) is in System.Random.MWC's uniform.
07:40:56 <k00mi> extensible effects are fundamentally different
07:41:01 <Forkk> I'm thinking I'll wrap ReaderT in a newtype and give it a parameter that specifies the context type
07:41:02 <bartavelle> Forkk, but you're leaving the monad-transformer land
07:41:13 <Forkk> and then provide things to stack a context onto another one
07:41:15 <bartavelle> Forkk, ok last suggestion
07:41:21 <bartavelle> what about stuff like "zoom" ?
07:41:24 <bartavelle> in lens
07:41:27 <Forkk> zoom?
07:41:46 <bartavelle> are the two reader contexts a "parent" and a "part" ?
07:41:56 <bartavelle> like you are focussing on a part of the context?
07:42:26 <Forkk> yeah pretty much
07:42:42 <bartavelle> https://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Zoom.html
07:42:47 <bartavelle> look at "magnify"
07:43:05 <Forkk> They're in acid state, though, so the context monads just hold an acid state handle and the ID of the context objects
07:43:13 <Forkk> Will have a look at that though
07:43:23 <bartavelle> oh I don't know anything about acid-state
07:44:10 <bartavelle> but magnify will turn a "MonadReader a m" into a "MonadReader b m" if you have a lens from a to b
07:44:11 <Forkk> for the purposes of this it's basically just a normal database
07:44:33 <floresiensis> pjdelport: thanks, that's interesting. With plain System.Random it was super-slow, like ruby slow. MWC was suggested as the alternative.
07:44:38 <edwardk> (magnify IIRC should work even with just a getter)
07:44:56 <Forkk> that probably wouldn't work, because I need to be able to run actions that operate on the parent state too
07:45:06 <Forkk> also the objects being accessed aren't actually in the context :|
07:45:40 <bartavelle> then it's not really a MonadReader ?
07:46:10 <Forkk> it's not exposed as one
07:46:16 <Forkk> it is internally though
07:46:44 <Forkk> Internally it's a reader on the UserName
07:48:38 <rydgel> @pl \x -> (show $ length x) ++ [head x]
07:48:39 <lambdabot> ap ((++) . show . length) (return . head)
07:48:44 <bartavelle> edwardk, "This acts like local, but can in many cases change the type of the environment as well." (for magnify) what does "many cases" mean here ? when should it not be possible to change it ?
07:50:01 <edwardk> bartavelle: when the reader doesn't support it? =)
07:50:01 <floresiensis> pjdelport: I suppose MWC isn't as crappy as C's rand(), which means that MWC is slower. Maybe haskell needs a crappy random? In any case there is a programmer-effort solution that can reduce the number of random calls (once per child to determine the number of mutations, not per character).
07:50:26 <edwardk> if you had a particular MonadReader instance you had that was limited to say 'String' or something also
07:50:32 <bartavelle> ahhhh
07:50:41 <bartavelle> good point :)
07:52:12 <monorail_> I just wrote my first Haskell program without a tutorial holding my hand. Unsurprisingly, it doesn't work. Can someone please tell me why this doesn't terminate? http://ix.io/eHS
07:52:56 <mauke> monorail_: that doesn't look like the right link
07:53:25 <monorail_> mauke: It looks right on my end... odd.
07:53:34 <artyomkazak> monorail_: for one, why did you use «head [ n | n <- [0..], n > 4000000 ]» instead of «4000001»?
07:53:52 <Guest60204> Ive got a function I have to test out but for some reason I cant get it ro run: http://pastebin.com/fnxjVErE
07:53:53 <bartavelle> monorail_, n > 4000000
07:53:58 <Guest60204> I'm kinda desperate at this point
07:54:05 <mauke> hmm, it redirects me to http://www.ix.io/eHS
07:54:07 <bartavelle> not  < ?
07:54:16 <mauke> which shows the root page
07:54:25 <artyomkazak> also, your fib is recursive
07:54:32 <monorail_> artyomkazak: bartavelle: yeah, uh, oops. that's supposed to be `fib n > ...`
07:54:46 <artyomkazak> which means that fib 4000000 would take... a hell of time
07:54:59 <smart_ptr> do you have any clue why the n-plus-k-pattern was banned in Haskell 2010?
07:55:08 <artyomkazak> more than the universe's age
07:55:26 <smart_ptr> > I mean: f (n+1) = (n+1) * f(n)
07:55:28 <lambdabot>  <hint>:1:17: parse error on input ‘=’
07:55:35 <pjdelport> floresiensis: Is the Haskell implementation of the algorithm doing around the same number of calls as the C version?
07:55:47 <smart_ptr> > f (n+1) = (n+1) * f(n)
07:55:49 <lambdabot>  <hint>:1:9: parse error on input ‘=’
07:55:49 <vanila> f (n+1) = (n+1) * f n
07:55:59 <artyomkazak> do you want the sum of numbers which are less than 4000000, or numbers which indexes are < 4000000?
07:56:38 <pjdelport> floresiensis: From the looks there, there are around 21 million calls to makeChild and diff's f helpers.
07:56:41 <bartavelle> I think I wants to takeWhile (fib n < 4000000) ?
07:56:44 <monorail_> Numbers, not indexes
07:56:57 <monorail_> Oh, I've never heard of takeWhile but it sounds really promising
07:56:58 <mauke> Guest60204: ||| and <**> aren't defined
07:57:16 <pjdelport> floresiensis: Also, i think the profiling might be having a very heavy impact there.
07:57:28 <floresiensis> pjdelport: C has the same number of random calls, but C doesn't allocate children.
07:57:33 <Guest60204> mauke: sorry, they are. I must not have included them. Let me show you
07:57:40 <pjdelport> floresiensis: When i run it with profiling, it always takes 20–25 seconds.
07:57:56 <pjdelport> floresiensis: When i run it without profiling, it's nearly instantaneous: 0.3 seconds.
07:57:57 <Guest60204> mauke: http://pastebin.com/akU0bqUU
07:57:59 <mauke> smart_ptr: they're irregular and syntactically ambiguous
07:58:02 <pjdelport> That's a *huge* difference.
07:58:35 <pjdelport> floresiensis: Roughly how long does that code take to run over there for you, without profiling?
07:58:46 <pjdelport> 20s or <1s ?
07:59:13 <mauke> Guest60204: fsplits is not defined
07:59:17 <floresiensis> pjdelport: since you have the code in front of you, could you comment on my style? What would you do that I didn't do?
07:59:41 <Guest60204> mauke: its in the code i just gave you
07:59:51 <Guest60204> mauke: oh wait, no it isnt
07:59:54 <Guest60204> hold on...srry
08:00:06 <pjdelport> floresiensis: Style-wise, it doesn't look too bad. I don't understand the algorithm enough to give any deep insight, but my first suggestion would be to try and separate the pure and IO stuff more, if possible.
08:00:13 <Guest60204> mauke: http://pastebin.com/xTd6sF9C
08:00:14 <pjdelport> (But that might not be possible, given the performance aim.)
08:00:38 <floresiensis> pjdelport: for me it's 1.3 secs, on 32-bit linux
08:01:03 <mauke> Guest60204: ok, now what's the problem?
08:01:06 <pjdelport> floresiensis: Okay, so that doesn't sound *too* much off. Just checking if it's not something obvious that's being missed.
08:01:15 <pjdelport> floresiensis: That's compiled with -O2, right?
08:01:24 <floresiensis> pjdelport: yep
08:01:57 <floresiensis> haskell platform doesn't seem to have 32-bit linux, so it looks like I need to rebuild all of ghc
08:02:03 <floresiensis> for profiling
08:02:07 <Guest60204> mauke: My problem is that I need to test star ((a ||| b) <*> (a ||| b)) but I can't test it because the program wont compile, and everything I try to enter throws an error
08:02:16 <mauke> Guest60204: what's the error message?
08:02:57 <pjdelport> floresiensis: Do you have a plaintext or other description of the algorithm somewhere?
08:03:21 <Guest60204> mauke: http://pastebin.com/9n36Szv4
08:03:32 <monorail_> I was able to make my program work using takeList, thanks guys :) http://ix.io/eHT
08:03:44 <mauke> Guest60204: that's not the code you said you were running
08:04:05 <mauke> Guest60204: 'star ((a ||| b) <*> (a ||| b))' is not the same as 'star (("a" ||| "b") <*> ("a" ||| "b"))'
08:04:22 <Guest60204> mauke: I know, I can't even figure out how to execute the function
08:04:40 <mauke> Guest60204: have you tried 'star ((a ||| b) <*> (a ||| b))'?
08:05:05 <Guest60204> mauke: yes, that was the first thing. It throws me more erors, want me to show you?
08:05:09 <mauke> yes
08:05:43 <Guest60204> mauke: http://pastebin.com/684uuBnw
08:05:57 <mauke> Guest60204: perfect
08:06:16 <mauke> Guest60204: star ((a ||| b) <*> (a ||| b)) "hello"
08:06:25 <mauke> i.e. add a string at the end
08:06:40 <Guest60204> mauke: how did you get that from the error?
08:06:45 <Guest60204> thank you very much btw
08:06:51 <Guest60204> You dont understand how much I appreciate it
08:06:52 <Guest60204> lol
08:07:24 <mauke> "No instance for (Show Bla)" means ghc doesn't know how to display Bla
08:07:32 <mauke> but the type itself is fine
08:07:43 <Guest60204> mauke: that makes you say, "lets put a string at the end"
08:07:49 <Guest60204> ?
08:07:49 <mauke> and your RegExp is defined as String -> Bla
08:07:54 <mauke> er
08:07:57 <mauke> String -> Bool
08:08:01 <Guest60204> mauke: I assumed it needed to go where the a's and b's were
08:08:02 <mauke> i.e. a function from strings to bools
08:08:20 <mauke> so ghci is effectively complaining it doesn't know how to display functions
08:08:29 <Guest60204> mauke: ah
08:08:32 <mauke> but we don't need to display the function; we can just call it
08:08:41 <Guest60204> ah
08:08:47 <Guest60204> mauke: thank you very much, again
08:09:17 <lecoeus> hey guys, is there a way for me to get the field names of a data object?
08:09:43 <mauke> Guest60204: you're welcome
08:12:54 <Eduard_Munteanu> lecoeus, with TH or Data/Generic, yes.
08:13:37 <flebron> Hi. Foldable and Traversable are unique, right? i.e. if a type T has at most one lawful instance of them.
08:14:24 <Eduard_Munteanu> I doubt it, think about tree traversals.
08:15:11 * hackagebot hOpenPGP 1.11 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.11 (ClintAdams)
08:25:58 <frihd> is there some work/a package/a typeclass to capture the idea that we can get the history of an object either with a list of "snapshots" either with "one snapshots" and a list of diffs/operations?
08:28:00 <Denommus> uh, I can't install reactive-banana-wx
08:28:06 <Denommus> is there a specific version that isn't broken?
08:32:24 <MagBo> Hey, people, here's long question —
08:32:30 <MagBo> https://gist.github.com/anonymous/b2d92e0b58cad4eaec75
08:32:38 <hakujin> anyone have experience with WAI/Scotty http basic auth per route instead of using the wai-extra middleware? (is this problem already solved)
08:53:19 <dmwit> MagBo: Cloud Haskell seems like overkill. Boring old concurrent Haskell seems like it ought to be enough.
08:54:01 <otulp> MagBo: I don't know much about your program, but ... Go go go cloud Haskell :) I'm sure you could go with async and STM instead, though. I think the cloudy bits are most useful if you want to actually distribute across the network.
08:56:50 <MagBo> Well, I'm still learning Haskell.
08:56:53 <RchrdB> MagBo: unless I really need to distribute something, I'd always recommend reaching for STM first when writing concurrent programs. Here's why: http://neverworkintheory.org/2011/08/24/is-transactional-programming-actually-easier.html
08:57:13 <MagBo> This is the first industrial-grade program I write in it
08:57:31 <MagBo> RchrdB: much love for the link.
08:57:38 <RchrdB> MagBo: now, to be fair, when writing programs for fun, I often write them using inappropriate technology on purpose as a learning exercise…
08:57:39 <otulp> Cloud Haskell probably matches your strange Erlang ways better, though. :)
08:58:08 <MagBo> otulp: hah, yeah. But our Erlang ways have our Erlang runtime
08:58:14 <RchrdB> but there's a big gap between the way I write for fun and the way I write for industrial use. :)
08:58:23 <MagBo> With seamless SMP and friends
08:58:47 <MagBo> I'm not sure how it works with Haskell runtime with Cloud Haskell
09:01:16 <MagBo> RchrdB: I find it strange to try to measure the effectiveness of work with STM approach using students who were most certaintly raised by wild^W^W^W taught to code imperatively and didn't write naive concurrent systems to understand the value of STM
09:02:01 <MagBo> OTOH this paper is very interesting! Sort of interdisciplinary study between comp sci and psychology :)
09:02:26 <MagBo> Thank you for the link.
09:02:29 <RchrdB> MagBo: yeah; no study is perfect though, and the sheer strength of the measured effect in that study overwhelms my reservations about the methodology
09:02:57 <Hodapp> what paper?
09:03:04 <MagBo> http://neverworkintheory.org/2011/08/24/is-transactional-programming-actually-easier.html
09:03:09 <MagBo> Hodapp: ^
09:03:17 <RchrdB> software engineering, as a discipline, is extremely starved for any kind of empirical research *at all*, so you sorta have to take what you can get. :|
09:04:00 <MagBo> ForNeVeR: hello, comrade
09:04:15 <Hodapp> MagBo: thanks
09:04:21 <srpx> Hello, why won't this program compile? http://lpaste.net/112413
09:05:03 <k00mi> MagBo: I would use FRP to write such a program
09:05:15 * hackagebot casadi-bindings-core 2.1.0.0 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-2.1.0.0 (GregHorn)
09:05:20 <merijn> RchrdB: I have so far seen 2 somewhat sensible software engineering empirical studies that confirm one thing: types helps, a lot :)
09:05:21 <Hodapp> whoa, does this paper actually detail an actual study with actual data in the land of programming?
09:05:26 <Hodapp> that is exceedingly rare
09:05:30 <MagBo> k00mi: I have no idea of what do we mean with FRP here :)
09:05:38 <MagBo> can you elaborate?
09:05:39 <exio4> functional reactive programming?
09:05:41 <srpx> I'm pretty sure GHC has all the information to deduce "e = Int"... is this a problem with the inference system itself?
09:05:43 <Hodapp> merijn: Might you have links to these too?
09:06:00 <MagBo> exio4: FRP is vague
09:06:08 <MagBo> exio4: they say that React.js is FRP :D
09:06:09 <k00mi> MagBo: functional reactive programming, specifically I would use the reactive banana library
09:06:09 <Hodapp> Has anyone else read Les Hatton's work? He was a professor who was in search of actual data, though his particularly was testing the notion that OOP makes for better programs by any benchmark
09:06:13 <merijn> RchrdB: And I mean somewhat properly empirical, as in "generate 50 language that compose random features from a set of features and throw people at it, see where they do best"
09:06:26 <merijn> MagBo: FRP is very well-defined, but everyone keeps misusing the name :(
09:07:12 <merijn> Hodapp: Not directly, I'd have to ask the guy that linked me what it was again
09:07:29 <MagBo> k00mi: ok, so what do I do, I go online and read about FRP in Haskell, I read about reactive banana, think, ask questions if I didn't understand the application of the library to my problem?
09:07:49 <merijn> MagBo: The de facto standard for FRP is the FRAN paper and Push-Pull FRP, both by Conal
09:08:04 <MagBo> merijn: much love for pointing to papers!
09:08:27 <k00mi> MagBo: yes, but be warned there is not a whole lot of documentation
09:08:41 <k00mi> I also don't think you have to read those papers to use reactive-banana
09:08:42 <Hodapp> merijn: let me know if you find it, this sounds interesting!
09:08:53 <MagBo> k00mi: so I'll have a good enough excuse to ask here or in -cafe ;)
09:09:13 <MagBo> well, to be honest, I prefer to understand exactly what I'm doing with haskell
09:09:23 <merijn> MagBo: If you feel you have a firm grasp of the Functor/Applicative/Monad typeclasses, Push-Pull FRP is probably the best one for describing the "proper" semantics of FRP
09:09:30 <MagBo> and even this doesn't save me from asking embarrassing questions
09:10:04 <Hodapp> who summoned conal?!
09:10:04 <MagBo> merijn: alright!
09:10:11 <merijn> MagBo: http://conal.net/papers/push-pull-frp/
09:10:15 * hackagebot casadi-bindings 2.1.0.0 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.1.0.0 (GregHorn)
09:10:40 <MagBo> Hodapp: based on the domain name...
09:11:06 <RchrdB> merijn: oh really? Link me that paper please?
09:11:49 <merijn> RchrdB: I wish I had it lying around, but I need to ask a colleague where it was and he's not in yet!
09:12:07 * conal checks the channel log
09:12:11 <merijn> hah
09:12:42 <merijn> Relevant quote of the day
09:12:46 <merijn> @quote defun conal
09:12:46 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
09:13:03 <MagBo> :D
09:15:04 <conal> MagBo: there's a lot of confusion about "frp" these days. the term has come to be used much more vaguely than its original intent and definition. in addition to the fran & push-pull papers mentioned above, see my FRP summaries on StackOverflow: http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#comment9673470_1030631 http://stackoverflow.com/questions/5875929/specification-for-a-fun
09:15:04 <conal> ctional-reactive-programming-language#5878525 http://stackoverflow.com/questions/5385377/the-difference-between-reactive-and-functional-reactive-programming
09:15:36 <conal> that second SO link: http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525
09:16:08 <conal> MagBo: two essential characteristics: continuous time and simple, precise denotation.
09:17:48 <MagBo> conal: let me blackbox FRP for a second and ask you if this abstract black box FRP is helps us to solve a problem like this — https://gist.github.com/anonymous/b2d92e0b58cad4eaec75 ?
09:18:47 <conal> MagBo: ah, sorry for the info flood. i assumed you were interested in FRP.
09:19:08 <MagBo> conal: it's very fine
09:19:39 <MagBo> I mean, I'm honoured that you wrote this, and yes I'm interested in what FRP really is.
09:19:50 <merijn> MagBo: For parts of it, it'd apply
09:20:00 <MagBo> If not for this industrial task, then to play around on weekends
09:20:09 <merijn> MagBo: Especially things like UI seem much more natural as FRP
09:21:00 <merijn> MagBo: That is, the state of the UI is described as a function over "time + inputs", FRP lets you describe things like "visible for 5 seconds" as a first class notion
09:23:07 <MagBo> Right, which brings us back to the question of other fibers and integrating these FRP-fibers into the application.
09:23:37 <akegalj> can I somehow say "type A a = a -> a" and then dependend of "a" use different implementations of computation ie "someComputation :: A Int", and "someComputation :: A String". And for Int he chooses some function Int -> Int which i provide somehow, for String some other function
09:23:47 <akegalj> can i do this with type classes?
09:24:26 <joseph07> akegalj: That sounds like a type class, if you're choosing a function based on type
09:25:31 <akegalj> joseph07: thanks
09:45:17 * hackagebot hzulip 0.1.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.1.0.0 (yamadapc)
09:47:43 <lpaste> lf94 pasted “Mass replace” at http://lpaste.net/112415
09:48:16 <lf94> How can I do multiple replaces on a string, within one function?...
09:48:48 <lf94> And once I'm done those replaces, how do I write back to the file?
09:49:01 <lf94> (I'm using a bunch of maps- check out the lpaste)
09:49:13 <pharpend> lf94: instead of
09:49:23 <Twey> :t writeFile
09:49:24 <lambdabot> FilePath -> String -> IO ()
09:49:28 <pharpend> lf94: map x $ map y $ map z a
09:49:34 <pharpend> lf94: instead, use
09:49:42 <pharpend> lambdabot: map (x . y . z) a
09:49:50 <pharpend> lf94: map (x . y . z) a
09:49:58 <lf94> Ah
09:50:07 <Twey> map f . map g = map (f . g)  by one of the functor laws
09:50:18 * hackagebot hzulip 0.1.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.1.0.1 (yamadapc)
09:50:35 <Twey> lf94: But if you want to apply several functions in succession, you can just apply them
09:50:39 <pharpend> Twey: fmap f . fmap g = fmap (f . g)
09:50:49 <dfeuer_> lf94: you should probably make a new file, write to that, and then move it.
09:50:54 <pharpend> in the list functor, fmap = map
09:51:10 <Twey> replace a b (replace c d (replace e f str))
09:51:23 <dfeuer_> Modifying files in place only works for special cases.
09:51:27 <lf94> dfeuer_: I have a zillion files I have to edit
09:51:48 <Twey> pharpend: Yep
09:52:00 <Twey> pharpend: (was that for lf94?)
09:52:09 <lf94> I was thinking at first to use awk, then python, then I thought why not do it in haskell?! lol
09:52:35 <dfeuer_> lf94: it's only *possible* to modify a file in place if the replacement text is exactly as long as the original.
09:52:51 <dfeuer_> (Or you're appending to the end of the file)
09:53:01 <pharpend> lf94: because Haskell isn't a shitty scripting language. Haskell is what you use if you want to build solid applications that work really well in practice. it's not great for little one-off scripts
09:53:03 <lf94> dfeuer_: I understand that
09:53:23 <lf94> pharpend: ok, roger that
09:53:35 <lf94> no need to get aggressive now
09:53:52 <lf94> maybe awk can satisfy my needs here
09:55:58 <dfeuer_> Lf94, if you really need it in place, you need to use monadic strict IO and futz around with seeking. You can do it, but it won't be much fun in any language.
09:57:04 <lf94> I just need to find the line, do a replace on those few things, and write the line back
09:57:18 <lf94> I guess I'll have to do what you said and create new files
09:57:30 <lf94> Hmmmm
10:00:09 <mthvedt> when would you want to use a church encoding instead of a record?
10:01:25 <josephle> mthvedt: maybe when your language is the untyped lambda calculus
10:03:24 <mthvedt> josephle: well, in particular i’m wondering about some libraries that have found it more convenient to have polymorphism using rank-n church encodings, instead of records of existential types, and how that decision was reached
10:03:39 <lf94> How do you supply more than one argument to a function that takes more than one in a map?
10:03:48 <josephle> mthvedt: an example?
10:03:49 <lf94> map (writeFile) $ map (replaceGt . lines . readFile) files
10:04:36 <mthvedt> josephle: a simple example might be having
10:05:02 <zq> first of all, writeFile returns an IO action
10:05:06 <mthvedt> data Foo = forall a. FooClass a => Foo a
10:05:07 <zq> :t writeFile
10:05:08 <lambdabot> FilePath -> String -> IO ()
10:05:26 <lf94> zq: ok?
10:05:28 <mthvedt> vs type Foo = forall r. (forall a. IFoo a => a -> r) -> r
10:05:30 <zq> so mapM would be relevant
10:05:37 <lf94> I don't need any of its output anyway
10:05:40 <mthvedt> or something like that
10:05:42 <lf94> (because it has none!)
10:05:46 <lf94> zq: ok
10:06:01 <dfeuer_> lf94: there's mapM_
10:06:19 <lf94> Looking into it~
10:07:15 <smart_ptr> can you tell me what exactly the indentation rules say, please? http://ideone.com/1ZxkPn
10:07:23 <smart_ptr> I can't really figure it out
10:07:46 <lf94> "Map each element of a structure to a monadic action", ok..."evaluate these actions from left to right", what does that mean? Apply the function to each list element starting from the most left to the right?
10:07:51 <zq> lf94: but you do need the output of readFile, right?
10:07:53 <josephle> mthvedt: that's an interesting question... I'm not sure I'm able to give a satisfactory answer
10:08:17 <lf94> zq: yeah. readFile outputs a String I thought? I guess not! :) I'll go change that too.
10:08:38 <lf94> IO String, woot
10:08:57 <dfeuer_> What are the laws for Foldable? None of them are mentioned in the docs.
10:09:24 <dfeuer_> (Or does it not have laws???)
10:09:38 <lf94> How is this even going to work? mapM_ (replaceGt . lines . readFile) files, replaceGt returns a string
10:10:07 <dfeuer_> lf94: you need to convert the string to an IO action.
10:10:28 <lf94> Why not just use map
10:10:36 <gabebw> @pl evenMinusOdd xs = sum (filter even xs) - sum (filter odd xs)
10:10:36 <lambdabot> evenMinusOdd = ap ((-) . sum . filter even) (sum . filter odd)
10:10:37 <dfeuer_> Well, first you have to convert it back to a string, probably.
10:10:44 <zq> smart_ptr: pretty sure you're mixing tabs and spaces
10:11:04 <dfeuer_> lf94: you could use map, and then sequence. More words.
10:11:06 <zq> smart_ptr: \t\t\twhere square x = x * x c = 3
10:11:16 <smart_ptr> zq: so if i stick with either it won't give me any issues?
10:11:31 <zq> smart_ptr: just replace your \t-s with replicate 4 ' '
10:11:53 <smart_ptr> ok, thank you
10:11:57 <RchrdB> gabebw: that's surprisingly readable for @pl output.
10:12:01 <zq> smart_ptr: here http://ideone.com/kgh5K1
10:12:03 <lf94> I still don't get how I'm going to iterate over 2 lists and feed their outputs into writeFile
10:12:11 <lf94> I feel like I need a partial function here
10:14:23 <zq> cabal sdist
10:16:42 <lf94> Is there a way to tell map to stop?
10:17:15 <lf94> After I find 1 occurrence I want to move onto the next file (in this case, the next [String])
10:17:17 <vanila> lf94, there's not but if you only take the first few elements the rest will not be comptued thanks to lazyness
10:17:33 <lf94> Eh, it's impossible to know where it might occur...
10:17:46 <lf94> Alright though, that's fine
10:19:31 <lf94> zipWith seems to the answer...
10:20:50 <lf94> Mmmm, vanila: maybe takeWhile could work!
10:21:32 <lf94> Aw yeah
10:21:51 <lf94> I'm starting to feel the function composing power
10:22:27 <vanila> good! :)
10:28:12 <jle`> gandr: partition might be of use to you
10:28:20 <jle`> :t partition
10:28:21 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:28:28 <jle`> > partition even [1..10]
10:28:29 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
10:28:43 <lpaste> lf94 pasted “BOOM. Haskell /is/ good for scripting” at http://lpaste.net/112418
10:29:11 <lf94> Check it out guys, way easier than I initially thought
10:29:21 <jle`> i like to use (.) instead of ($) when i can :D
10:29:34 <cmtptr> what is the inverse of return?
10:29:52 <jle`> cmtptr: you mean, a Monad m => m a -> a ?
10:29:53 <vanila> cmtptr, there is no inverse in general, only some monads have one
10:29:56 <jle`> it does not exist in general
10:30:01 <cmtptr> oh
10:30:07 <jle`> many types have such an invernse, but it's not a part of their Monad interface
10:30:12 <jle`> inverse
10:30:15 <josephle> wait, that lpaste has a free variable in replaceGt...
10:30:34 <cmtptr> so do I have to use do and <- to use stuff like readFile?
10:30:41 <jle`> lf94: mapM_ writeFiles . zip files . map (replaceGt . lines . readFile) $ files
10:30:46 <vanila> jle`, did you ever sort out that comonadapply thing
10:31:03 <jle`> cmtptr: using <- is one way, you can also use (>>=) and (=<<)
10:31:16 <jle`> *using do blocks and  <-
10:31:17 <cmtptr> oh, right.  I just read about those this morning
10:31:18 <cmtptr> thanks
10:31:22 <jle`> no problem
10:31:31 <jle`> it'll make more sense as you go along :)
10:32:02 <jle`> and why having a general "inverse return" for types like IO is a bit silly.  but it's hard to see why now :)
10:32:13 <jle`> for `Maybe`, too
10:32:20 <jle`> vanila: nah, not quite
10:33:18 <lf94> jle`: thank you ma
10:33:23 <Turl> howdy everyone
10:33:26 <jle`> i haven't been finding much use for ComonadApply either in practice
10:33:37 <jle`> i guess it's good for "generic" stuff, over all ComonadApplies
10:33:43 <jle`> because most of my actual concrete types have also been Applicative
10:33:45 <Turl> I'm trying to run some code on ghci but I get this ncurses error, http://lpaste.net/112423
10:33:57 <lf94> josephle: that haskell probably doesn't compile X)
10:33:59 <Turl> the same code builds and works fine with ghc --make
10:34:03 <lf94> but the idea is there
10:34:11 <jle`> lf94: you might also be able to do zipWithM_
10:34:33 <cmtptr> jle`, >>= feels strikingly similar to the pipe | in shell
10:34:41 <jle`> zipWithM_ f = mapM_ (uncurry f) . zip
10:34:46 <jle`> cmtptr: that's a good intuition :D
10:34:48 <jle`> (>>=) is |
10:34:50 <jle`> (>>) is ;
10:34:53 <jle`> (in bash)
10:34:58 <jle`> *is like
10:34:59 <cmtptr> ah ha
10:35:55 <jle`> Turl: what an interesting error
10:36:02 <jle`> is this the first time loading up ghci?
10:36:30 <jle`> you might want to re-install readline from cabal and see if it works out
10:36:36 <lf94> zip files . map (replaceGt . lines . readFile) $ files <- jle`, doesn't this imply "files" is a function?
10:36:42 <jle`> but i think readline is actually built into ghci
10:36:49 <jle`> at build time
10:36:51 <jle`> ?
10:36:54 <lf94> Yeah
10:37:05 <jle`> lf94: f $ x implies that f is a function
10:37:07 <jle`> being applied to f
10:37:18 <jle`> so your function is (zip files . map (replaceGt . lines . readFile))
10:37:21 <jle`> being applied to `files`
10:37:38 <Turl> jle`: when I load ghci there's no errors, but when I run the code it starts loading up the libs and it spits it around that time
10:38:04 <jle`> have you ever had problems with these libs before?
10:38:20 <Turl> jle`: not that I recall of
10:38:33 <Turl> reinstalling readline did nothing
10:38:40 <jle`> lf94: zip x (map f x) is kinda like map (id &&& f)
10:38:50 <jle`> > (id &&& (+3)) 5
10:38:51 <lambdabot>  (5,8)
10:38:56 <jle`> if you want to go there
10:39:02 <Turl> it seems it's literally trying to load "/usr/lib/-lncursesw"
10:39:03 <jle`> not sure if that's necessary
10:39:10 <Turl> judging by strace output
10:39:30 <lf94> jle`: I thought $ was like this: zip files $ map (replaceGt . lines . readFile) files -> zip files (map (replaceGt . lines . readFile) files)
10:39:32 <jle`> lf94: i would probably make it all a big mapM or forM
10:39:40 <lf94> which in turn creates: zip files [some list]
10:39:42 <jle`> lf94: no, $ is like the spine of a beautiful butterfly
10:39:51 <jle`> it expands its wings out all the way on both sides
10:40:01 <jle`> f g $ x y = (f g) (x y)
10:40:02 <lf94> well it's been working for me that way
10:40:11 <jle`> oh yeah, that's right
10:40:15 <jle`> the way you wrote it is right
10:40:22 <lf94> so why the confusion
10:40:23 <jle`> we,, if you wanted to be explicit, you could do (zip files) (map ... )
10:40:25 <jle`> *well
10:40:25 <Turl> jle`: sudo ln -s /usr/lib/libncursesw.so /usr/lib/-lncursesw # fixes it, but it'll eventually come and bite me from behind again I fear
10:40:39 <jle`> Turl: heh.  that's odd.  anywhere you think would be relevant to file a ticket?
10:40:52 <jle`> lf94: well, in your previous example, why is `files` a function?
10:41:08 <exio4> is this valid HS? «writeFiles ∷ (FilePath a, String b) → IO()»?
10:41:23 <Turl> jle`: it may be an archlinux bug, or maybe an ncurses one
10:41:47 <lf94> it isnt
10:42:05 <lf94> anyways I'll save myself the confusion and use: zip files (map (replaceGt . lines . readFile) files
10:42:09 <jle`> lf94: forM_ files $ \file -> writeFile file (replaceGt (lines (readFile file)))
10:42:20 <exio4> it didn't work for me and thought you had some nice extensions :P
10:42:35 <texasmynsted> Is there a static site thing like hakyll that uses haml?
10:42:58 <jle`> exio4: i think there are some extensions that allow the unicode stuff
10:43:08 <exio4> no, I mean (FilePath a, String b)
10:43:15 <jle`> ah
10:43:25 <jle`> well yeah, that's not going to fly
10:43:30 <jle`> heh
10:43:41 <jle`> at least with FilePath and String from Prelude
10:44:23 <joseph07> cmtptr: fromJust, head, that sort of thing?
10:45:08 <joseph07> cmtptr: sorry I was living in the past (unintentionally scrolled back)
10:45:34 <lf94> jle`: for loops?!
10:45:36 <lf94> X)
10:45:43 <jle`> forM_ is just mapM_ backwards, heh
10:45:45 <lf94> Get out! Get out of here!!
10:46:00 <jle`> it's the same as mapM_ ( \file -> writeFile file (replaceGt (lines (readFile file)))) files
10:46:28 <jle`> but writing the function outside makes it feel cleaner sometimes
10:46:36 <jle`> especially if you have a newline after the ->
10:46:42 <jle`> it's almost as if you're in ruby
10:46:58 <jle`> which...may or may not be a good thing >_>
10:47:27 <lf94> I do really like your forM_ solution though.
10:47:29 <exio4> @pointfree \file -> writeFile file (replaceGt (lines (readFile file))))
10:47:29 <lambdabot> Unknown command, try @list
10:47:38 <exio4> @pl \file -> writeFile file (replaceGt (lines (readFile file))))
10:47:38 <lambdabot> (line 1, column 60):
10:47:38 <lambdabot> unexpected ')'
10:47:38 <lambdabot> expecting variable, "(", operator or end of input
10:47:45 <jle`> exio4: writeFile <*> (replaceGt . lines . readFile)
10:47:45 <lf94> So now you've messed up my understanding of . and $ again, thanks a lot!
10:47:46 <exio4> damn
10:47:54 <jle`> but i don't think the pointfree version is too readable
10:48:01 <jle`> compared to explicitly writing out the points
10:48:09 <lf94> jle`: (zip files) [list], how is this interpreted?
10:48:18 <jle`> it's the same as zip files [list]
10:48:27 <vanila> writeFile file (replaceGt (lines (readFile file)))) = writeFile file . replaceGt . lines . readFile $ file
10:48:30 <Turl> are there any easy debugging tips? finding the right !! on Main: Prelude.(!!): index too large
10:48:37 <jle`> remember that f x y is actually (f x) y
10:48:41 <Turl> is getting a bit complicated :P
10:48:42 <jle`> cause of currying and fun stuff like that
10:48:51 <jle`> Turl: solution is to not use !! ;)
10:49:03 <jle`> jk
10:49:05 <jle`> but really
10:49:58 <lf94> vanila: nice
10:50:16 <jle`> ty vanila
10:51:09 <jle`> using forM_ reminds me that there is no flip fmap
10:51:12 <lf94> so . knows if the part to the left of it is a function or not?
10:51:22 <jle`> lf94: (.) takes two functions on both sides
10:51:35 <jle`> :t (.)
10:51:35 <lf94> file . replaceGt <- file is not a function
10:51:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:51:40 <lf94> but writeFile is
10:51:46 <lf94> It knows to go further?
10:51:46 <jle`> oh
10:51:47 <slomo_> jle`: there's <&> in lens, which is fmap flipped
10:51:51 <jle`> function application binds tightest
10:51:59 <jle`> zip file . replaceGt is (zip file) . replaceGt
10:52:04 <jle`> not zip (file . replaceGt)
10:52:26 <jle`> slomo_: yes, but i'm not going to depend on lens just to use flip fmap ;_;
10:52:51 <slomo_> sure :)
10:52:57 <lf94> gotchyaaa
10:53:02 <edwardk> jle`: (<&>) is in there as a gateway drug ;)
10:53:06 <jle`> no
10:53:12 <jle`> well
10:53:23 <jle`> ideally flip fmap would be a non-operator name
10:53:28 <jle`> to eliminate such temptations :P
10:53:40 <jle`> why not follow the precedent of forM_
10:53:41 <edwardk> we have (??) as well so you can do that ;)
10:53:44 <lf94> What is the proper name for $
10:53:49 <edwardk> :t fmap ?? [1,2,3]
10:53:49 <lambdabot> Num t => (t -> b) -> [b]
10:53:52 <jle`> i just call it function application
10:53:57 * edwardk teases.
10:54:15 <edwardk> for is already taken for the Foldable version
10:54:23 <edwardk> :t Data.Traversable.for
10:54:24 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:54:27 <edwardk> er Traversable
10:54:32 <jle`> oh
10:54:36 <jle`> wow
10:54:40 <jle`> oh
10:54:44 <jle`> hm.
10:54:53 <jle`> still has the double layer.
10:55:02 <edwardk> > for [1..3] $ \x -> [x, x + 1]
10:55:03 <lambdabot>  Not in scope: ‘for’
10:55:03 <lambdabot>  Perhaps you meant one of these:
10:55:03 <lambdabot>    ‘T.for’ (imported from Data.Traversable),
10:55:03 <lambdabot>    ‘or’ (imported from Data.List),
10:55:03 <lambdabot>    ‘F.or’ (imported from Data.Foldable)
10:55:07 <edwardk> > T.for [1..3] $ \x -> [x, x + 1]
10:55:09 <lambdabot>  [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
10:55:28 <lf94> so would this be incorrect? mapM_ writeFiles $ zip files . map (replaceGt . lines . readFile) files
10:55:39 <jle`> lf94: yes
10:55:42 <jle`> because that is parsed as
10:55:52 <jle`> zip files . (map (reeplaceGt . lines . readFile) files)
10:55:59 <jle`> and (map ... files) is not a function ... as you have it there
10:56:18 <jle`> > T.for [1..3] \x -> Identity (x + 1)
10:56:19 <lambdabot>  <hint>:1:14: parse error on input ‘\’
10:56:24 <jle`> > T.for [1..3] $ \x -> Identity (x + 1)
10:56:26 <lambdabot>  Identity {runIdentity = [2,3,4]}
10:56:34 <lf94> Oh!
10:56:34 <jle`> you know...i really wish that that $ there won't be necessary some day
10:56:39 <lf94> I understand
10:56:48 <jle`> if had one change to haskell to make, i would probably do that
10:57:00 <jle`> to be able to make things like forM_ foo \bar -> ...
10:57:01 <jle`> possible
10:57:15 <lf94> sooo what the heck? My initial line *was* correct: mapM_ writeFiles $ zip files $ map (replaceGt . lines . readFile) files
10:57:21 <edwardk> jle`: the grammar would have to jigger around quite a bit to make that viable. (i looked once) =)
10:57:31 <jle`> then let it jigger
10:57:48 <jle`> lf94: yes, that works :)
10:57:50 <edwardk> it isn't clear to me what knock-on consequences it'd have
10:57:55 <jle`> but using double $'s is usually not preferred
10:58:12 <edwardk> double $'s?
10:58:17 <jle`> referring to lf94
10:58:27 * edwardk shrugs.
10:58:28 <jle`> and his f $ g $ x
10:58:35 <edwardk> I tend to actually use them more than folks like Cale
10:58:43 <jle`> i think we had this conversation before actually
10:58:47 <edwardk> there is a good chunk of Haskell code that typechecks with the $'s but not the (.)'s
10:58:59 <danharaj> :t $ $ $
10:59:00 <lambdabot>     parse error on input ‘$’
10:59:00 <lambdabot>     Perhaps you intended to use TemplateHaskell
10:59:04 <edwardk> because ($) is special cased in the typechecker
10:59:07 <lf94> How the heck does this parse: writeFile file . (replaceGt . lines . readFile) $ file
10:59:21 <jle`> (writeFile file . (replaceGt . lines . readFile)) file
10:59:24 <danharaj> :t ($ ($ ($)))
10:59:25 <lambdabot> (((((a -> b2) -> a -> b2) -> b1) -> b1) -> b) -> b
10:59:40 <lf94> I feel like that doesn't do what I intend it to
10:59:42 <edwardk> danharaj: wait, when did you start IRCing again? ;)
11:00:03 <danharaj> edwardk: Being in Boston made me realize I've stopped thinking about programming as a hobby I enjoy ;)
11:00:11 <danharaj> Trying to get back into the creative / community spirit.
11:00:19 <jle`> edwardk: yeah, but for the new person, (.) over ($) offers a lot of benefits without worrying about the special cases :)
11:00:21 * hackagebot rethinkdb 1.15.0.0 - A driver for the RethinkDB database server  http://hackage.haskell.org/package/rethinkdb-1.15.0.0 (EtienneLaurin)
11:00:33 <mizu_no_oto> danharaj: Are you just visiting Boston, or did you move up from NYC?
11:00:34 <lf94> jle`: . and $ though have completely different purposes
11:00:43 <danharaj> I just visited for IFL.
11:00:54 <jle`> lf94: yeah, but a lot of times you have options on which to use
11:01:01 <jle`> f $ g $ x y vs. f . g $ x y
11:01:03 <jle`> um
11:01:05 <jle`> that's wrong
11:01:08 <jle`> f $ g $ x vs f . g $ x
11:01:49 <edwardk> He basically camped out on my couch and I braindumped ancient graphics tools into his brain the whole time.
11:02:27 <danharaj> Still digesting all of that.
11:04:42 <lf94> man haskell lambdas are pretty nice
11:04:46 <lf94> (\)
11:04:51 <lf94> that's it
11:04:56 <exio4> λ!
11:04:56 <humanoyd> Is there are version of "writeFile" that creates parent directories as needed?
11:06:53 <lf94> Ok I think I'm fairly satisfied with this: mapM_ (\file -> writeFile file $ (replaceGt . lines . readFile) file)
11:07:00 <gregnwosu> hello could someone tell me what it means when you have "data SomeTypeName :: * -> * where"
11:07:12 <gregnwosu> i thought data was for defining new types
11:07:31 <lf94> You are right
11:07:38 <lf94> So don't doubt yourself there
11:07:49 <BMeph_> You thought right, gregnwosu. :)
11:08:55 <gregnwosu> BMeph_: so what does it mean to have a where clause and a kind
11:09:11 <jle`> it's an alternative syntax to declaring types
11:09:37 <gregnwosu> ah, a different way of defining constructors
11:09:46 <jle`> data SomeType :: * -> * where ... is rougly equivalent to data SomeType a = ..., only you get to explicitly say that the `a` must be of kind *
11:10:09 <BMeph_> gregnwosu: "data SomeTypeName :: * -> * where" means that the type will be "SomeTypeName SomeOtherType" - examples include Maybe, Complex, and the specially-written "List" form, [].
11:10:29 <gregnwosu> jle: i see
11:10:32 <jle`> in most common use cases of `data`, the kind of the parameter can be inferred.  but when it can't/you don't want the automically inferred one, GADT syntax is nice
11:10:43 <jle`> but a lot of people like using GADT syntax in general for funsies
11:10:52 <josephle> gregnwosu: this kind of syntax is far more popular in Agda and Idris
11:10:56 <BMeph_> gregnwosu: Yes, that "data ... where" is the GADT-style of data(type) declaration.
11:11:20 <jle`> data Maybe :: * -> * where Just :: a -> Maybe a; Nothing :: Maybe a
11:11:33 <gregnwosu> BMeph_:  thanks , and then it goes on declare what appear to be constructors in a kind of type class style
11:11:47 <BMeph_> (or "GADT syntax," as the rest are calling it.)
11:12:06 <BMeph_> gregnwosu: Exactly.
11:12:11 <gregnwosu> ah i see it, thanks guys
11:12:25 <jle`> signatures are nice.  the more signatures, the better! :D
11:12:31 <jle`> (don't quote me on that)
11:12:40 <gregnwosu> :)
11:12:48 <exio4> I write type signatures before code
11:13:00 <gregnwosu> exio4: yes i try to also
11:13:23 <jle`> the extension is...if you signature your functions, why not your types, too? :D
11:13:53 <c_wraith> When's the SortSignatures extension?
11:15:28 <c_wraith> We have polykinds now.  When do we get to restrict what kinds that polymorphism is over?
11:15:58 <c_wraith> ...  This is what Stephanie Wierich is working on now, iirc.  So..  We get that when it's done. :)
11:19:10 <lf94> Haskell is so great
11:19:13 * sm wishes for a ghc --defer-scope-errors
11:19:21 <lf94> Every time I write a Haskell program I'm overly satisfied
11:19:38 <lf94> They are just pieces of art, every one
11:19:54 <hc> :)
11:20:09 <jle`> :D
11:23:57 <zq> how do i pass options to ghci when invoking cabal repl?
11:24:36 <edwardk> @pl (\file -> writeFile file $ (replaceGt . lines . readFile) file)
11:24:37 <lambdabot> ap writeFile (replaceGt . lines . readFile)
11:25:18 <edwardk> lf94: which becomes writeFile <*> replaceGt . lines . readFile    -- but that is probably not useful ;)
11:27:23 <lf94> <*> is a thing in haskell? neat.
11:30:23 * hackagebot propellor 0.9.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.9.0 (JoeyHess)
11:30:35 <edwardk> lf94: its in Control.Applicative
11:30:49 <Dashkal> @type (<*>)
11:30:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:30:54 <edwardk> lf94: so your example if you went pointfree entirely would be mapM_ (writeFile <*> replaceGt . lines . readFile)
11:31:02 <edwardk> there its using f = (->) e
11:31:17 <lf94> flippin' black magic
11:31:32 <lf94> I don't know what f = (->) e means :?
11:31:35 <lf94> :/*
11:31:36 <edwardk> lets look at that signature
11:31:40 <edwardk> :t (<*>)
11:31:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:31:47 <edwardk> replace f with (->) e
11:31:48 <edwardk> you get
11:31:56 <edwardk> (->) e (a -> b) -> (->) e a -> (->) e b
11:32:03 <edwardk> now go from prefix to infix
11:32:04 <lf94> a partial function? <_>
11:32:13 <edwardk> (e -> a -> b) -> (e -> a) -> (e -> b
11:32:20 <lf94> Oh
11:32:23 <edwardk> remove the unneccesary paren
11:32:25 <lf94> damn that is cool
11:32:26 <edwardk> (e -> a -> b) -> (e -> a) -> e -> b
11:32:30 <edwardk> and you get that signature
11:32:37 <edwardk> similarly const = return
11:32:39 <edwardk> :t return
11:32:40 <lambdabot> Monad m => a -> m a
11:32:44 <edwardk> for m = (->) e
11:32:47 <edwardk> a -> e -> a
11:33:22 <texasmynsted> where would I find a list of static site generators like hakyll, or is hakyll the only one for haskell?
11:33:26 <edwardk> the Applicative/Monad for (->) e are a source of 'cute but confusing' pithy one-liners
11:33:37 <edwardk> texasmynsted: hakyll is the only one i know
11:33:38 <lf94> Gotchya
11:33:48 <zwer> `(\file -> writeFile file $ (replaceGt . lines . readFile) file)' doesn't look right to me? readFile returns IO String, writeFile file accepts String
11:33:50 <texasmynsted> ok
11:33:55 <texasmynsted> thank you
11:33:56 <deni> quick question when i try to do this data Interaction :: * -> * where
11:34:00 <lf94> zwer: yep, you are totally right
11:34:08 <lf94> I'm currently figuring that out with my code X)
11:34:10 <deni> the complier complains i don't have KindSignatures? what's that all about?
11:34:30 <deni> the name kinda suggests it i guess...so i turn it on....but then...
11:34:35 <lf94> Then I went ahead to see how to turn IO String to a String, only to see this quote: "However, the IO monad taints everything that uses it"...
11:34:43 <deni> Illegal generalised algebraic data declaration
11:34:47 <Eduard_Munteanu> deni, :: * -> * is a kind signature
11:34:54 <edwardk> deni: saying things like data Foo (f :: * -> *)    -- requires KindSignatures
11:35:03 <deni> Eduard_Munteanu: yes i know...hence i enabled kind signatures pragma
11:35:30 <deni> edwardk: ok kinda figured that one....wondered why it was an extension and not the default...should have phrased my question better
11:35:33 <zwer> lf94 the whole point is that you can't
11:35:42 <lf94> zwer: right
11:35:44 <josephle> lf94: despite rumors to the contrary, there is no (IO a -> a) function ;)
11:35:50 <deni> edwardk: Eduard_Munteanu what about the other error: Illegal generalised algebraic data declaration
11:36:02 <lf94> So, what do I do?...Need to use `do` or something?
11:36:03 <Eduard_Munteanu> deni, what follows the 'where'?
11:36:08 <deni> sec
11:36:25 <edwardk> deni: kinds didn't actually have a syntax back in the day
11:36:29 <deni> Eduard_Munteanu: edwardk http://dpaste.com/12AXFY8
11:36:53 <deni> edwardk: i see
11:36:59 <josephle> lf94: depends on what you want to do with the IO String.
11:37:16 <lf94> My intentions should be obvious from that line?...
11:37:18 <deni> edwardk: it should probably make it's way as the default i guess. just thinking out loud
11:37:24 <Eduard_Munteanu> deni, that looks fine, did you turn on -XGADTs?
11:37:38 <edwardk> deni: well, it conflicts with other language extension directions one might ask for
11:38:10 <deni> Eduard_Munteanu: i didn't know about that pragma :( it works when I add it
11:38:19 <edwardk> deni: e.g. where kinds and types would live in the same namespace, that'd be a legal direction to extend Haskell2010 that differs from the direction GHC has chosen to extend it
11:38:20 <deni> what's the backstory on -XGADTs?
11:38:24 <josephle> lf94: I haven't really been paying attention to the channel, sorry
11:38:31 <Eduard_Munteanu> deni, do you know what a GADT is?
11:38:48 <deni> Eduard_Munteanu: yes
11:39:06 <edwardk> deni: and that might be a nicer direction to go for "dependent typed Haskell" so it behooves us to move slowly about adding things like that to a standard and locking in a bad decision forever
11:39:12 <deni> Eduard_Munteanu: (i think i need to add kind off at the end of that yes...but yes in general)
11:39:34 <Eduard_Munteanu> deni, then the story is simple, it's not a Haskell2010 feature and adds quite a bit to the language
11:39:36 <deni> edwardk: that sounds resonable. thank you for the backstory
11:40:06 <deni> i was under the impressions GADTs were kinda baked in...had no idea it was an extension
11:40:10 <josephle> lf94: ah, I see the one-liner
11:40:11 <deni> seems a lot of stuff is an extension
11:40:13 <Eduard_Munteanu> Nope.
11:40:15 <josephle> :t (>>=)
11:40:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:40:22 <zwer> lf94 looking at http://lpaste.net/112418 this makes it compile: main = mapM_ (uncurry writeFile) =<< zip files <$> mapM readFile files
11:40:26 <edwardk> deni: the core language itself is fairly conservative
11:40:41 <lf94> zwer: sorry but that looks alien to me
11:40:50 <zwer> add `import Control.Applicative' or use fmap
11:41:02 <deni> edwardk: Eduard_Munteanu yes I'm always struggling to remember that...that the core is small.
11:41:09 <zwer> lf94 you can use do to break it down in multiple steps, instead
11:41:17 <deni> had no idea though that GADTs were an extension....they're used quite a lot
11:41:43 <Eduard_Munteanu> deni, even typeclasses with multiple parameters require a pragma, so... :/
11:41:56 <deni> edwardk: kinda makes it hard for the new comers to know which extension they should use...and which are only adding complexity...issues and so on (for the case of writing a lib for instance)
11:42:03 <zwer> lf94 <$> is fmap, =<< is flipped >>=
11:42:06 <deni> Eduard_Munteanu: ah yes i knew about that one! :D
11:42:26 <zwer> but feel free to use do if it is more readable for you
11:42:35 <edwardk> deni: on the other hand, when you work with fewer extensions you can know how much more portable your code is to other implementations, and turning on more extensions is also a sign often that your code will have poorer inference properties
11:42:59 <lf94> Ok this is suddenly extremely complex
11:43:01 <deni> edwardk: other implementations as in apart from ghc?
11:43:09 <edwardk> deni: yes
11:43:17 <deni> edwardk: i have no idea how many ppl use those....so much information
11:43:20 <Eduard_Munteanu> edwardk, says the guy who seldom uses non-standard features :P
11:43:57 <edwardk> Eduard_Munteanu: I have a lot of code that runs on Haskell 98 / Haskell 2010. I also have a lot of code that turns on almost every extension anyone has ever heard of. ;)
11:44:02 <edwardk> It is useful to know both extremes ;)
11:44:06 <Eduard_Munteanu> deni, extension usage is commonplace in Haskell code, some more than others.
11:44:11 <edwardk> Some of my code runs in hugs still ;)
11:44:19 <Eduard_Munteanu> Heh.
11:44:32 <deni> edwardk: the reason i brought up the "how are newcomers to know what to use" is that i recently had i discussion of wether depens on certain libraries when writing my library code (for instance lens) as I understand ppl complain about to much deps on various libraries....makes it complext or whatever
11:44:32 <edwardk> (bound until recently didn't need anything outside of haskell 98)
11:44:52 <deni> edwardk: point being if ppl complain about lib deps....what are they gonna say about extensions.
11:45:01 <Eduard_Munteanu> edwardk, I hope that doesn't mean turning n+k back on :)
11:45:16 <deni> edwardk: but maybe i'm wrong at looking at extension as something different/esotheric in comparison to libs....perhaps it comes down to the same thing
11:45:28 <edwardk> deni: lens is definitely aimed at the intermediate-to-advanced audience in the Haskell space.
11:45:51 <edwardk> deni: People _do_ complain about language extensions with the same kind of fervor as they do libraries ;)
11:45:56 <zwer> lf94 anything in particular that makes it complex? or you just haven't learned about <$> and =<< yet?
11:46:33 <edwardk> deni: anyways, extensions are much more able to be changed / refined over time than the core language spec.
11:46:47 <deni> edwardk: so i can look at them as the same thing basically. in the end it's not i know what pragmas every lib i pull in is using
11:47:02 <deni> *not like i know
11:47:03 <edwardk> deni: well they pull in a language pragma locally for the module
11:47:13 <edwardk> deni: so the scope is much more limited in some sense
11:47:21 <edwardk> its about their internal implementation details for the most part
11:47:30 <lf94> Ok how is it possible to use filenames coming from getArgs in readFile?!
11:47:35 <Eduard_Munteanu> Sometimes that leaks out though.
11:47:38 <edwardk> sometimes about what kinds of things they can expose in the API (e.g. kind polymorphism, etc)
11:47:41 <lf94> This is flippin' impossible
11:47:50 <edwardk> or if they can have rank-n types they expose
11:47:57 <deni> edwardk: hmm i didn't know that...so if i'm writing a lib and using some pragmas the users don't need to worry about them? (unless running something other then ghc ofcourse)
11:48:00 <Eduard_Munteanu> As in it's impossible to use some things written with certain pragmas on without turning them on yourself as well.
11:48:12 <lf94> zwer: haven't learn uncurry, <$> or =<<.
11:48:21 <edwardk> but mostly i don't care what extensions you use internally except insofar as they compromise (or enforce) system properties i care about, e.g. coherence of instance resolution, or SafeHaskell, etc.
11:48:33 <joseph07> lf94: what is it you're trying to do?
11:49:09 <edwardk> deni: my rule of thumb is if I See IncoherentInstances I close the project and never look back, and otherwise I'm okay. ;)
11:49:13 <zwer> :t uncurry writeFile
11:49:15 <lambdabot> (FilePath, String) -> IO ()
11:49:44 <deni> edwardk: Eduard_Munteanu this has been very helpfull. thank you.
11:49:47 <zwer> in this case it makes writeFile accept a tuple instead of FilePath and String
11:50:10 <zwer> as far as the rest goes, perhaps you will find this more readable:
11:50:24 <zwer> main = do texts <- mapM readFile files; mapM_ (uncurry writeFile) (zip files texts)
11:51:25 <zwer> s/readable/more understandable
11:51:42 <deni> while i'm at it though. I'm using TH for parsing JSON (nothing fancy). I'm using it because i've stumbled upon it first (before Generics). and i find it usefull because i can an Options record to every derive call which has some properties set up. One of which is very important and it tells the derive function how to map the record field name to the json string keys. (Ie. my record fields have _ prepended)
11:52:13 <mickyy> does gtk2hs work well on both windows and linux?
11:52:21 <deni> now i have _ prepended because the json i kinda f-ed up. the API is written in golan and golang tends to spit out capitalized first letter key names
11:52:32 <deni> i think Chris asked about this the other day in here
11:52:59 <deni> anyway....I stumbpled upon Generics and wanted to try them out in comparison to TH (just for the json part, i know they're not comparable at all)
11:53:09 <Eduard_Munteanu> mickyy, last time I tried (quite some time ago) it did
11:53:14 <zwer> lf94 you need writeFile to accept a tuple because you have a list of tuples (of file path and file content). does that make sense?
11:53:30 <deni> but Generics don't give me a way to say: ok capitalize the first letter on the record fileds and use that for mapping to the json keys....or something like that
11:53:32 <lpaste> lf94 pasted “joseph06 over here” at http://lpaste.net/112425
11:53:38 <deni> atleat i couldn't find it
11:53:56 <deni> do you ppl know of something like this?
11:53:56 <lf94> zwer: I actually did that initially.
11:54:08 <lf94> zwer: The issue now is changing IO Strings to regular Strings now
11:54:16 <deni> I'm mostly just curious...i write most of my To/FromJSON instances by hand....
11:54:28 <lf94> joseph07 ^^^^ that lpaste was for you, whoops
11:54:55 <mickyy> you can't change IO String to String
11:55:24 * hackagebot snaplet-influxdb 1.0.0.0 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.0.0 (ParnellSpringmeyer)
11:55:26 <lf94> mickyy: /I know/
11:55:32 <mickyy> ok :)
11:57:14 <lf94> My code just doesn't work because of the io string stuff
11:57:19 <lf94> can you go from string to io string?
11:57:28 <mickyy> :t return
11:57:28 <lambdabot> Monad m => a -> m a
11:57:39 <mickyy> :t return "hi" :: IO String
11:57:40 <lambdabot> IO String
11:57:41 <lf94> actually that doesn't matter because I can't change what readFile wants.
11:58:13 <lf94> mickyy: http://lpaste.net/112425
11:58:36 <deni> Eduard_Munteanu: edwardk btw do you guys have like a list of pragmas that you turn on by default in your .ghci or something?
12:00:45 <Eduard_Munteanu> deni, right now I can only think of OverloadedStrings
12:01:47 <deni> Eduard_Munteanu: yeah i have that one as well. and DataKinds for some reason ... probably left over from some experiment
12:01:59 <deni> Eduard_Munteanu: edwardk how do you feel about OverlappingInstances?
12:03:05 <Eduard_Munteanu> OverlappingInstances is sometimes necessary for some typeclass trickery. But it's one of the things I'd rather not enable unless needed.
12:03:40 <deni> got it
12:04:47 <deni> i'm going to read up on all of them....just need a general "don't use this unless you have to" pattern parse the ones i shouldn't use...cause it's not necessarily clear at first glance
12:05:38 <edwardk> deni: I generally don't use them
12:05:41 <joseph07> lf94: If you were writing a list of contents to a list of files in an imperative language you would probably loop through both lists and call writeFile on each pair. It might be a helpful exercise to write that loop with explicit recursion in Haskell. mapM_ just generalizes that pattern
12:05:53 <Jmac217> Is it worth my time to read Categories for the Working Mathematician? It seems like a really good book for category theory, but I'm also quite new to it all.
12:06:16 <edwardk> deni: i find that anything that makes the compiler more reticent to reduce a type family makes more code get 'stuck' than i want
12:06:17 <Eduard_Munteanu> deni, OverlappingInstances is fine and useful for "closed" typeclasses, ones where all instances should be in one place, but horrific for "open" ones.
12:07:00 <Eduard_Munteanu> Closed type families mitigate some of that.
12:07:16 <deni> Eduard_Munteanu: i'm not sure i understand what open and closed mean here
12:08:04 <Eduard_Munteanu> deni, "open" means unrelated code adds instances of said class
12:08:18 <Eduard_Munteanu> Possibly without knowledge of other instances.
12:08:41 <Eduard_Munteanu> Basically the way typeclasses are usually used.
12:09:01 <lpaste> zwer annotated “joseph06 over here” with “joseph06 over here (annotation)” at http://lpaste.net/112425#a112426
12:09:18 <Eduard_Munteanu> OTOH, by "closed" I mean you define all instances in one place.
12:10:31 <lf94> joseph07: yes I know
12:10:38 <josephle> Jmac217: Category Theory by Awodey is a much gentler introduction to CT imo
12:10:48 <lf94> joseph07: my issue is getting the filenames turned into Strings to use by readFile
12:11:02 <cellopin> anyone can point me a resource about what this means? read :: Read a => String -> a
12:11:05 <Eduard_Munteanu> deni, OverlappingInstances is pretty bad per se because instance resolution depends on the order of definition.
12:11:20 <cellopin> specifically the '=>' operator?
12:11:30 <deni> Eduard_Munteanu: and closes mean you export the instaces but not the typeclass so you can't add more instances?
12:11:36 <Eduard_Munteanu> cellopin, do you know about typeclasses?
12:11:38 <deni> *closed means
12:11:45 <Jmac217> Thanks josephle I'll check that out!
12:11:52 * shapr hugs johnw for being awesome
12:12:07 <joseph07> lf94: readFiles should have type IO [String]
12:12:11 <cellopin> Eduard_Munteanu: I'm still reading
12:12:18 <Eduard_Munteanu> deni, I mean open/closed in a "moral" sense, the language doesn't enforce it, which is one reason that extension is bad news.
12:12:36 <deni> Eduard_Munteanu: but this is the way you would make a "closed" typeclass right?
12:13:01 <deni> Eduard_Munteanu: i only know of open ones...so that's why i'm asking
12:13:17 <joseph07> lf94: like do { (inputFile:_) <- getArgs; fmap lines (readFile inputFile); }
12:13:20 <jedai> cellopin: This should be introduced in your tutorial, in learn you a haskell for great good for exemple
12:13:39 <jedai> cellopin: or Real World Haskell
12:13:41 <Eduard_Munteanu> deni, nah, it's just a matter of intent. You can't really do the above because you still want to be able to refer to the typeclass.
12:13:47 <deni> Eduard_Munteanu: also if the order of definition matters...for OverlapingInstances...how does that even work...i mean if you've got instances all around...in deps and everything ?
12:13:51 <jedai> cellopin: how are you learning Haskell ?
12:13:52 <joseph07> lf94: then in main you can have a line inputFiles <- readFiles
12:14:16 <deni> Eduard_Munteanu: makes sense....so it's a "we're all consenting adults here just don't do this" kinda things
12:14:19 <deni> s/things/thing/
12:14:29 <cellopin> jedai: I'm reading Learn You a haskell
12:14:44 <joseph07> lf94: it's a little less busy in #haskell-beginners
12:15:06 <cellopin> hah, I should go there
12:15:16 <Eduard_Munteanu> deni, as usual, instance resolution uses what's in scope at that particular location.
12:15:28 <deni> Eduard_Munteanu: ah yes...makes sense
12:15:52 <jedai> cellopin: ok, then it will be explained when it become necessary, just know that the "main type" of read is String -> a, it truns a String into another type "a" but this other type must be an instance of the Read typeclass which provide the necessary function to do the conversion
12:16:30 <deni> Eduard_Munteanu: i can see why OverlappingInstances would be considered a bad thing then. I really appreciate your help for pointing this out :)
12:16:59 <lf94> joseph07: I'm following- I'll rework my code to get around this IO business
12:17:34 <Eduard_Munteanu> deni, you can use it to e.g. assert a certain type-level list contains a particular element
12:17:38 <dfeuer_> IO!
12:18:00 <deni> dfeuer_: given up on tor btw...no more connection dropping i hope :P
12:18:09 * dfeuer_ loves IO. It's the easiest part of Haskell. Especially the way it works under the hood in GHC.
12:18:41 <dfeuer_> deni: I was never talking to you about that! I had an unrelated question someone else resolved.
12:18:45 <deni> Eduard_Munteanu: that sounds dependent type-y a lot
12:19:10 <dfeuer_> Also, deni, Freenode seems a bit of an odd place to use tor; open source development isn't usually so secretive.
12:19:28 <epsilonhalbe> hey i have a problem using cabal repl - with the soap package. I get the message that the message that iconv-0.4.1.2.o has an unknown symbol `__imp__libiconv_open` - in my cabal file I have added extra-lib-dirs: `C:\path\to\gnu32\lib` and include-dirs: `C:\path\to\gnu32\include` - the cabal build command works but I cannot open a repl - has anybody an advice for me
12:20:32 <dfeuer_> epsilonhalbe: have you tried searching the Cabal, GHC, and soap bug trackers?
12:20:59 <deni> dfeuer_: what question? i guess i missed it because the connection broke...and yes tor was just an experiment...no reason whatsoever...just wanted to see how it works
12:21:38 <dfeuer_> deni: it didn't matter by the time you asked. I think maybe Phabricator was broken by mistake and then fixed later.
12:21:43 <deni> Eduard_Munteanu: do you have an example for that perhaps? a dpaste maybe?
12:22:16 <deni> dfeuer_: the reason i ask is that i like just joined the channel and was unsure why anyone would ask me anything :D
12:22:22 <epsilonhalbe> @dfeuer_ it is my first cabal packed project - and first project on windows - but I will search at that places - and come back
12:22:23 <lambdabot> Unknown command, try @list
12:23:12 <deni> dfeuer_: so i think you confused me with someone else
12:23:55 <dfeuer_> deni: I don't really remember, and it also does not matter.
12:25:25 * hackagebot fast-tags 0.0.6 - Fast incremental vi tags.  http://hackage.haskell.org/package/fast-tags-0.0.6 (EvanLaforge)
12:32:49 <deni> dfeuer_: true :)
12:34:54 <jle`> deni: /b 17
12:34:55 <jle`> oh, sorry
12:34:59 <jle`> ignore that :)
12:35:29 <CrazyM4n> How do I get a newer version of gtk2hsC2hs?
12:35:40 <CrazyM4n> This requires at least version 0.13.8
12:35:46 <CrazyM4n> But I apparently have 0.13.6
12:38:20 <deni> jle`: :D
12:38:33 <CrazyM4n> Fixed it :D cabal install gtk2hs-buildtools --global
12:39:20 <CrazyM4n> Why doesn't cabal automatically edit the path to include ~/.cabal/bin?
12:40:02 <cdk> CrazyM4n: I wouldn't want cabal changing my path by itself...
12:40:11 <CrazyM4n> I guess..
12:40:23 <CrazyM4n> Just used to programs doing that on windows
12:44:31 <cellopin> In http://www.haskell.org/haskellwiki/Vim#Plugins what code should I put in ~/.vim/plugin/Haskell.vim? Does it mean the setup from merijin in 1?
12:46:05 <gigabytes> hi everybody
12:46:25 <lf94> writeFiles :: ([FilePath, String]) a <_ what the heck am I doing wrong
12:46:30 <gigabytes> nobody has ever proposed a polymorphic list literal extension, similar to the polymorphic strings literals?
12:46:46 <gigabytes> so i could write [42] instead of Set.singleton 42
12:47:01 <dmj`> gigabytes: it exists, OverloadedLists I think?
12:47:13 <dmj`> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
12:47:24 <dmj`> ['0' .. '9']             :: Set Char
12:47:25 <gigabytes> uh thank you
12:47:59 <dmj`> sure
12:48:15 <CrazyM4n> It is such a pain to get these libraries set up on linux
12:49:43 <marchelzo_> I'm trying to send an email with the smpt-mail package, and when I actually call the sendMailWithLogin' function, I get an exception: "getAddrInfo: does not exist (error 11001)". I know it's not likely but does anyone know what's going wrong?
12:50:26 * hackagebot helics-wai 0.2.0 - New Relic agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.2.0 (HirotomoMoriwaki)
12:50:31 <lf94> How do I write a type signature that includes tuples?
12:50:54 <danharaj> :t ("hello", "world")
12:50:55 <lambdabot> ([Char], [Char])
12:51:09 <danharaj> :t ("hello", 3 :: Int) :: (String, Int)
12:51:10 <lambdabot> (String, Int)
12:51:21 <lf94> Why is this not working the? writeFiles :: (FilePath a, String b) -> IO()
12:51:27 <lf94> then*
12:51:45 <marchelzo_> because FilePath and String take no arguments
12:51:55 <danharaj> FilePath and String are types without parameters.
12:51:59 <lf94> What about this: writeFiles :: (FilePath, String) a -> IO()
12:52:08 <marchelzo_> You don't need the a
12:52:19 <lf94> Oh whoops
12:52:20 <lf94> derp
12:52:21 <danharaj> In fact, you cannot have the parameter 'a'. It is does not make sense there.
12:52:23 <danharaj> :)
12:52:33 <lf94> Yeah yeah yeah, I know where I'm going wrong now
12:52:35 <lf94> hnnnng
12:52:51 <lf94> There we go, fixed
12:53:09 <gigabytes> it is a bit strange that IsList instances are not provided for common structures
12:53:24 <danharaj> like what?
12:53:35 <gigabytes> do I really have to copy/paste those from the GHC doc?
12:53:58 <gigabytes> danharaj: like Map or Set (if you were asking me)
12:56:01 <lf94> Ok so I guess it's impossible to feed a list of files into readFile
12:56:07 <lf94> from getArgs
12:56:24 <exio4> liftM?
12:56:33 <exio4> (//fmap?)
12:56:46 <exio4> oh, wait, maybe you just want >>= :P
12:56:46 <lpaste> lf94 pasted “IO Hell” at http://lpaste.net/112429
12:57:52 <lf94> exio4: the lpaste and a compilation explains all
12:58:01 <marchelzo_> lf94, you say that readFiles takes no arguments and then you define it with an argument
12:58:35 <lf94> B)
12:59:04 <mickyy> what tutorial are you following?
12:59:12 <lf94> Ok well, fixed that
12:59:13 <lf94> None
12:59:41 <lf94> Getting an argument filename from getArgs and feeding it into readFile seems to be flippin' impossible
12:59:50 <mickyy> lines . readFile can't work. readFile is IO String, lines accepts String
13:00:00 <CrazyM4n> Who was the guy who wanted to know how Helm was? Well, I just got it installed... and Ubuntu immediately told me it had a problem and had to quit
13:00:39 <RchrdB> lf94: "getArgs !! 0" doesn't work. (getArgs) has the type (IO [String]), and (!! 0) has the type ([a] -> a).
13:01:02 <RchrdB> lf94: you wanted to write something ilke: args <- getArgs; let findFile = args !! 0;
13:01:09 <tommd> lf94: `(filename : _) <- getArgs ; content <- readFile filename` is a decent start.
13:01:16 <mickyy> or perhaps:
13:01:24 <mickyy> args <- getArgs; case args of ..
13:01:33 <lf94> RchrdB: what kind of craziness is going on there then? Do things on the left side of <- become non-IO?!
13:01:43 <tommd> Depends on how much you care about exceptions when the cli is misused.
13:01:43 <mickyy> that way you can handle empty args string, to print usage or something
13:02:15 <mickyy> lf94 more or less
13:02:16 <lf94> I was told you cannot get rid of the IO type
13:02:16 <tommd> lf94: They are the result of the IO procedure and are not themselves IO actions.
13:02:22 <lf94> Here that is exactly what seems to be happening
13:02:27 <marchelzo_> lf94, sort of. It's actually just syntactic sugar for monadic bind, but within the "do" block, you can treat them like they are not in the IO monad
13:02:41 <mickyy> lf94 do (and >>=, which is what do desugars to) lets you compose existing IO actions into new ones
13:03:06 <lf94> mickyy: thank you
13:03:13 <RchrdB> lf94: it doesn't entirely get rid of the IO-ness, because the whole "do" block is in IO. :)
13:03:27 <mickyy> so within do, x <- ioString. x will have the type of String
13:03:40 <lf94> But not really
13:03:53 <lf94> Right?
13:03:54 <burp> yes, really ;-)
13:04:09 <lf94> The IO type is clearly being stripped- what the heck!
13:04:24 <burp> the complete result is still in IO
13:04:35 <lf94> Ok
13:04:49 <mickyy> you are just attaching additional computation to the IO action, resulting in new IO action
13:05:09 <CrazyM4n> Is <- and >>= or whatever it was functions?
13:05:17 <CrazyM4n> What are their types?
13:05:32 <CrazyM4n> @t <-
13:05:32 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
13:05:38 <marchelzo_> :t (>>=)
13:05:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:05:41 <mickyy> do/<- desugars to >>, which is a function
13:05:47 <mickyy> to >>=
13:06:02 <exio4> I wouldn't use the do notation until you are "used" to >>=/>>
13:06:02 <CrazyM4n> I see. That's cool
13:06:12 <CrazyM4n> @t (<-)
13:06:12 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
13:06:16 <mickyy> @undo do line <- getLine; print line
13:06:16 <lambdabot> getLine >>= \ line -> print line
13:06:53 <mickyy> <- is syntax
13:06:59 <CrazyM4n> That makes sense
13:07:43 <CrazyM4n> Woo, Helm works!
13:08:06 <lf94> Is there an article that explains >>=/>>?
13:08:14 <Guest27830> I'm supposed o define a function that matches zero or one occurances of the pattern e with the function definition of option :: RegExp -> RegExp. http://pastebin.com/Ra3NeMrX Can anyone explain to me what they mean by "match"? Are they wanting me to parse a list or what?
13:11:44 <burp> google for "haskell io monad", that should do it
13:11:45 <mickyy> lf94 there are tons of monad tutorials, not sure which one is recommended these days
13:12:22 <burp> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:13:08 <Guest27830> Anyone?
13:14:24 <josephle> lf94: "the trivial monad" is a pretty good place to start
13:15:29 <mickyy> I found maybe monad easiest to understand when I was starting out
13:15:40 <mickyy> > do x <- Just 10; y <- Just 20; return (x + y)
13:15:43 <lambdabot>  Just 30
13:15:56 <mickyy> > do x <- Nothing; y <- Just 20; return (x + y)
13:15:58 <lambdabot>  Nothing
13:17:26 <koala_man> Guest27830: by "match zero or one occurances" they mean "return a RegExp that is True if the input string contains zero or one occurrences of the given RegExp"
13:17:46 <Guest27830> koala_man: thanks
13:19:58 <CrazyM4n> Helm has terrible documentation. I think that I'd rather go this approach http://blog.chucklefish.org/?p=154
13:29:24 <dfeuer_> Why is Alternative a subclass of Applicative?
13:30:32 <jfischoff_> it is a monoid of Applicatives
13:30:37 <merijn> dfeuer_: It's the Applicative version of MonadPlus, afaict
13:30:52 <jfischoff_> maybe there is a better way to say what I just said :p
13:32:51 <dfeuer_> What's the big difference between a Monoid instance for (f a) and an Alternative instance for f?
13:34:33 <jfischoff_> you get too much overlap with instances like (f a)
13:37:37 <dfeuer_> jfischoff_: so why make it a subclass of Applicative?
13:42:27 <bryanvick> Is there a typeclass like Foldable for unparamaterized types? 'data Foo = Foo Int Int Int' and I want total :: Foo -> Int that sums all the Ints, but was wondering if there is a standard API for that
13:43:57 <joe9> Where can I find the source code for haskell's takeDirectory?
13:44:08 <joe9> https://hackage.haskell.org/package/filepath-1.1.0.2/docs/System-FilePath-Posix.html does not have the source.
13:45:56 <Eduard_Munteanu> deni, something like   class Elem (x :: k) (xs :: [k]); instance Elem x (x ': xs); instance Elem x xs => Elem x (x0 ': xs)
13:46:00 <joe9> http://git.haskell.org/packages/filepath.git/blob/HEAD:/System/FilePath/Internal.hs found it.
13:46:27 <Eduard_Munteanu> bryanvick, nope
13:46:48 <bryanvick> Eduard_Munteanu: thanks, I didn't think so, as it is of little use
13:48:52 <bryanvick> \leave
13:56:19 <merijn> dfeuer_: Same reason Applicative is a subclass of Functor
13:56:25 <merijn> dfeuer_: Because it logically should be
13:56:58 <edwardk> dfeuer_: distributive laws
13:57:15 <edwardk> dfeuer_: also consider the Alternative for Maybe vs. Monoid (Maybe a)
13:57:19 <edwardk> they do different things
13:57:26 <edwardk> a Monoid for (f a) can care about 'a'
13:57:37 <edwardk> the Alternative has to work in an 'a'-independent fashion
13:57:42 <edwardk> and has laws relating it to Applicative
13:57:45 <gigabytes> but
13:57:49 <dfeuer_> All right.
13:58:11 <gigabytes> just a question: which is the real difference between fmap and liftM, beside the different contraint? I mean, why should I use liftM instead of fmap?
13:58:24 <dfeuer_> Distributive laws. So, edwardk, this is a case of wanting to have methods to attach the laws to?
13:58:30 <edwardk> gigabytes: liftM is a viable default definition for fmap when you are working with a monad.
13:58:31 <Eduard_Munteanu> gigabytes, none, exactly that
13:58:50 <edwardk> dfeuer_: there is also some code you can't write if you tied it to (f a) -- because it'd have to know about a
13:58:54 <dfeuer_> Speaking of which, that's why compare shouldn't be in Ord, but rather in TotalOrd :-)
13:59:05 <edwardk> dfeuer_: if you didn't know the a you cared about you couldn't use the instance
13:59:06 <Eduard_Munteanu> gigabytes, it's convenient because Functor isn't a superclass of Monad
13:59:16 <edwardk> Ord is TotalOrd unless you are talking about Double ;)
13:59:34 <dfeuer_> edwardk, that's because it's named wrong.
13:59:46 <gigabytes> Eduard_Munteanu: I thought it was
14:00:07 <Eduard_Munteanu> Should it be DoubleStandard? :P
14:00:16 <dfeuer_> But I don't understand why you need to know the a you're talking about.
14:00:36 <dfeuer_> Although I can see it's nice to know that you don't need to know it.
14:01:28 <josephle> gigabytes: the applicative-monad relation won't be here until 7.10 iirc
14:01:44 <dfeuer_> Next year's proposal: PartialOrd => Ord
14:02:03 <gigabytes> josephle: oh yeah, of course
14:02:30 <dfeuer_> Although I hear you category theorists prefer weaker things than partial orders.
14:02:47 <obiwahn> http://paste.debian.net/125633/ - i like to install lambdabot, and a am new to cabal so i have not much skill in the resolution of conflicts
14:04:20 <gigabytes> folks, can I specify inline the type of a do expression?
14:04:34 <dfeuer_> gigabytes: what does that mean?
14:04:48 <Eduard_Munteanu> gigabytes, do { ... } :: type ?
14:05:02 <gigabytes> Eduard_Munteanu: oh... yes..
14:05:03 <gigabytes> XD
14:05:08 <gigabytes> dfeuer_: I meant that
14:05:17 <gigabytes> sorry it's late
14:05:27 <dfeuer_> gigabytes: it might be neater to put the signature on an action within it.
14:05:39 <dfeuer_> do {foo::type;blah}
14:06:09 <dfeuer_> If you're using layout.
14:06:13 <gigabytes> dfeuer_: yes it looks better
14:06:44 <obiwahn> anybody some advice on resolving cabal errors like the above?
14:09:18 <gigabytes> maybe my problem wasn't that. I'll try to explain it better: I'm using a state monad in a Happy parser. I'm trying to read the state by doing do { x <- use myLens }. I get an error because it can't find a instance of MonadState because the type variables are ambiguous. Usually this kind of errors are solved by specify a type signature, so I tried to specify the type of the action, but in this case it doesn't seem to work.
14:25:30 * hackagebot helics 0.2.0 - New Relic agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.2.0 (HirotomoMoriwaki)
14:25:32 * hackagebot helics-wai 0.2.0.1 - New Relic agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.2.0.1 (HirotomoMoriwaki)
14:30:30 * hackagebot matrices 0.1.0 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.1.0 (kaizhang)
14:45:12 <bitemyapp> dysinger: yo
14:45:22 <bitemyapp> dysinger: traditional web app or more like a SPA / REST API?
14:45:35 <lpaste> lf94 pasted “aouoaeu” at http://lpaste.net/5446525440548143104
14:48:11 <hexagoxel> uhm, can module qualifiers contain '-' character?
14:48:41 <joseph07> lf94: You using dvorak?
14:49:33 <kadoban_> Yay dvorak
14:49:34 <hexagoxel> if yes, how can i specify it in exposed-modules field in cabal package?
14:49:47 <bitemyapp> hexagoxel: what's a module qualifier?
14:50:11 <lpaste> lf94 revised “aouoaeu”: “No title” at http://lpaste.net/5446525440548143104
14:51:08 <lf94> joseph07: Yeah
14:51:30 <lf94> I thought doing private lpastes would avoid pastebin spam in here
14:52:23 <hexagoxel> oh, i got my answer. when the package name contains '-', the auto-generated Paths_$package module is named with '-' replaced with '_' in the package name
14:53:29 <hexagoxel> (maybe should be mentioned in cabal user guide..)
14:54:56 <yyttr3> How to I restore .cabal/config to default settings? I accidentally broke cabal and I need to restore it.
14:55:37 <kadoban_> If you delete it, doesn't it get recreated when you run cabal update or anything? *not really sure*
14:55:56 <yyttr3> I'm not sure either
14:55:58 <merijn> kadoban_: It does
14:55:59 <hexagoxel> just rename .cabal and see what happens..
14:56:05 <yyttr3> Alright,
14:56:13 <merijn> .cabal/config is initialised with defaults if missing
14:56:30 <merijn> yyttr3: Although you probably want to change the defaults to enable profiling and documentation :)
14:56:37 <lf94> kadoban_: dvorak is king
14:56:45 <kadoban_> Indeed
14:56:55 <yyttr3> That fixed it, thank you. I was trying to switch to the Stackage server
14:58:10 <lf94> It actually stopped my hands  from hurting while using qwerty
14:58:29 <lf94> I can also type way faster now (100wpm)
14:58:46 <lpaste> joseph07 revised “aouoaeu”: “No title” at http://lpaste.net/5446525440548143104
14:59:24 <joseph07> lf94: sorry I meant to annotate not edit
14:59:32 <kadoban_> I type about the same speed, but yeah it's about 100x more comfortable.
15:00:31 * hackagebot helics 0.2.1 - New Relic agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.2.1 (HirotomoMoriwaki)
15:00:38 <joseph07> lf94: Briefly: I changed the replaceGt function to be pure, I used pattern matching in writeFiles, and I added some comments and broke some lines in main
15:01:14 <lf94> joseph07: thanks, I'll be sure to look over it :)
15:02:49 <lf94> joseph07: the way you wrote is almost exactly the way I was writing it before lol
15:09:52 <RedNifre> Hey there.
15:10:14 <RedNifre> How do I derive Show with GHC Generics? I only get out of memory errors.
15:10:48 <RedNifre> I tried data Heck = Heck deriving Generic ; Instance Show Heck ; Heck, but it crashes GHCi
15:10:58 <RedNifre> It works with data Heck = Heck deriving Show though.
15:11:23 <dmj`> import GHC.Generics; data Heck = Heck deriving (Show, Generic)
15:11:29 <dmj`> doesn't work?
15:11:43 <RedNifre> Haven't tried that one.
15:12:03 <RedNifre> What would be the difference to deriving Generic ; instance Show Heck ?
15:12:54 <RedNifre> Or could I just write deriving (Show, ToJson, FromJson etc.)?
15:14:01 <dmj`> you would have to use standalone deriving, it isn't necessary in this case
15:14:29 <RedNifre> I don't understand.
15:14:40 <dmj`> to use Generics with aeson you'd do data Person = Person String deriving (Generic, Show); instance FromJSON Person; instance ToJSON Person
15:15:22 <RedNifre> Why is it not data Person = Person String deriving (FromJSON, ToJSON, Show) ?
15:15:55 <joseph07> lf94: The code I wrote there compiles, but you're going to run into an IO problem
15:17:44 <mickyy> what IO problem?
15:17:44 <RedNifre> I don't understand why deriving Generic ; Instance Show Person causes an out of memory error, or why I can,t put everything in the parethesis after "deriving". How to tell what to put after "deriving" and what to put in separate "instance" lines?
15:18:14 <mickyy> lazy IO, you mean?
15:18:23 <joseph07> mickyy: In particular, trying to write to a locked resource. The program reads a file, transforms the contents in memory, and then attempts to write the new contents to the same file
15:18:43 <mickyy> System.IO.Strict.readFile should fix that
15:18:57 <joseph07> mickyy: Yes. I believe that replace can stop evaluating before the end of the string
15:19:32 <joseph07> mickyy: That sounds like a solution
15:19:53 <joseph07> mickyy: is that in base?
15:20:20 <mickyy> honestly I have no idea. I have it available
15:20:33 <mickyy> it is possible I cabal installed it many months ago
15:20:43 <joseph07> mickyy: looks like a no =/
15:21:12 <Kinnison> I would like a trivial framework for building *very simple* web content generators from.  What would people recommend?
15:21:53 <acowley> ?hoogle System.IO.Strict
15:21:55 <lambdabot> package StrictBench
15:21:55 <lambdabot> package strict
15:21:55 <lambdabot> package strict-base-types
15:22:03 <acowley> I'd guess it's in strict
15:22:10 <kadoban_> Kinnison: Something like hakyll? (actually hakyll is the only one I know like hakyll, but I'm not really sure if that's what you're looking for or something else)
15:22:37 <mickyy> strict-io
15:22:39 <mickyy> http://hackage.haskell.org/package/strict-io-0.2.1/docs/System-IO-Strict.html
15:23:20 * Kinnison shall look at hakyll, ta
15:24:52 <merijn> Kinnison: Hakyll is basically a static website generator ala Jekyll, but in haskell
15:25:02 <merijn> It's pretty nice
15:25:17 <merijn> (If it fits your workflow)
15:25:32 <Kinnison> static generator?
15:25:33 <Kinnison> Hmm
15:25:44 <Kinnison> So my backing store is a git repo which could be updated between requests
15:25:52 <Kinnison> I'm using gitlib to access the repo
15:26:05 <mickyy> actually I have strict module installed, and it works (just tested). not sure what is the difference between readFile in strict vs strict-io
15:26:54 <mickyy> strict module is a lot more popular, going by downloads from cabal
15:28:03 <merijn> Kinnison: Backing store is "just files", but that could be in git, yes
15:28:32 <Kinnison> Right, but it means that I need to control the monad for the handlers quite hard (IO x) is not enough
15:28:47 <Kinnison> At least unless I misunderstand gitlib I do
15:28:54 <merijn> Kinnison: For dynamic sites, I wouldn't use hakyll
15:28:56 * Kinnison is still learning all these new bits :-)
15:29:04 * Kinnison closes the hakyll tab
15:29:18 <merijn> I would use Hakyll for "I have a blog/whatever where I publish pages occasionally"
15:29:27 <merijn> But all the pages themselves are static
15:29:41 <Kinnison> that is one use-case for this
15:29:48 <merijn> For dynamic stuff, look at snap/scotty/happstack (or yesod)
15:29:59 * Kinnison looks at happstack
15:30:12 <joseph07> merijn: also ketchup
15:31:02 <joseph07> Kinnison: also ketchup. I haven't used it but it's advertised as simple
15:31:19 <Kinnison> hoogle doesn't know about that
15:31:30 <joseph07> Kinnison: http://hackage.haskell.org/package/Ketchup-0.4.0
15:31:36 <Kinnison> ta
15:32:44 <Kinnison> Low on docs :-(
15:33:23 <joseph07> Kinnison: it's less than 400 loc, so I think at this point the source code is the doc
15:33:27 <Kinnison> heh
15:33:32 * Kinnison bookmarks it
15:33:37 <Kinnison> in case happstack looks maddening
15:34:09 <acowley> There's also apiary and spock
15:34:31 <Kinnison> Happstack, thus far, looks quite nice
15:34:39 <Kinnison> everything I've read makes sense
15:34:45 <Kinnison> and it has some reasonable early use docs
15:34:52 * Kinnison shall try happstack, thanks all for the suggestions
15:49:13 <Denommus> I want to use reactive-banana, I really do
15:49:33 <vanila> Denommus, I just saw in #ocaml :/
15:49:40 <vanila> that sucks that its segfaulting
15:49:52 <Denommus> vanila: no, that is unrelated
15:50:33 <Denommus> reactive-banana isn't segfault. I just can't manage to create a reactive-banana event out of a GTK event
15:50:41 <Denommus> and I can't install reactive-banana-wx either
15:51:50 <Denommus> I'm trying more than one FRP combination: OCaml + React + lablgtk2 and Haskell + reactive-banana + Gtk2Hs
15:55:34 * hackagebot snaplet-influxdb 1.0.0.1 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.0.1 (ParnellSpringmeyer)
16:05:34 * hackagebot snaplet-influxdb 1.0.0.2 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.0.2 (ParnellSpringmeyer)
16:06:14 <RedNifre_> dammit, instance Eq bla causes out of memory errors as well. How do I tell when to use deriving Generic + Instance Foo and when to use deriving (Foo, Generic)?
16:07:45 <RedNifre_> And why doesn't the compiler warn me about this? All I get is "GHCi ran out of memory".
16:08:03 <ret2libc> >
16:16:53 <lisbeth> back again to tackle some more haskell
16:20:01 <prinsen> Is there any way to get FFI to not create void* for all Ptr a, but instead som user provided pointer? Or do I need to manually wrap the FFI functions and cast?
16:23:19 <simpson> prinsen: Could you give an example?
16:27:36 <kvanb> RedNifre_: I didn't get the full story, but it could be a bug
16:27:38 <kvanb> could even be fixed
16:27:51 <kvanb> been tons of tickets related to deriving in the past ...
16:28:56 <lisbeth> is there a shell for linux written in haskell?
16:29:06 <lisbeth> pls say yes
16:30:57 <indiagreen> there's plush
16:31:20 <indiagreen> but I don't remember whether it's a shell or a terminal emulator
16:32:54 <indiagreen> there's also hell: https://github.com/chrisdone/hell
16:36:29 <joe9> Need some ideas on how to implement this, please?  I want to do this: http://codepad.org/GaTLbABy  , my failed attempt at doing it:  http://codepad.org/bbEzk4Bh
16:36:40 <joe9> i do not want to use the system.filepath.
16:36:48 <phaazon> hop là
16:36:49 <phaazon> http://phaazon.net/pub/monkey_blue_white_lights.png
16:36:54 <phaazon> little screen from my haskell engine :)
16:37:02 <phaazon> http://phaazon.net/pub/rotating_monkey_blue_white_lights.mp4 and a video
16:37:14 <phaazon> I’ll write some threads on my blog about it
16:37:21 <phaazon> it’s starting to becoming usable :D
16:37:24 <Polarina> Why would compiling this simple file eat up tens of gigabytes of memory? I'm not able to compile it due to lack of memory. http://lpaste.net/2833369227723800576
16:39:27 <Hafydd> Jesus christ.
16:39:36 <Hafydd> "Simple file".
16:40:09 <Polarina> Slight exaggeration there, but I wouldn't expect ghc to eat up that much memory.
16:40:14 <acowley> lol
16:40:22 <kvanb> Polarina: I suspect probably nobody has tried to compile something like that before ...
16:40:31 <kvanb> what version of ghc?
16:40:44 <acowley> OpenGL state is now first class?
16:40:49 <Polarina> kvanb, from the Haskell Platform, 7.8.3
16:40:50 <ski> joe9 : ooc, why don't you want to use `System.FilePath' ?
16:41:01 <kvanb> hmm
16:41:10 <ski> joe9 : also, i belieave the first equation would be bad
16:41:16 <kvanb> Post a bug on the trac
16:41:29 <kvanb> https://ghc.haskell.org/trac/ghc/
16:41:46 <joe9> ski, Thanks. this is for an embedded app . I think I can use span to get a tuple.
16:41:57 <Polarina> kvanb, thanks, I'll do that.
16:42:02 <joe9> ski, and get the parentdirectory of the fst of tuple
16:42:28 <lisbeth> basically what I mean is I want to use functions similar to the GNU coreutils
16:42:36 <lisbeth> for example using ls or something similar
16:42:57 <lisbeth> but in a language more secure and stable like haskell
16:44:34 <kvanb> Polarina: sometimes theres exponential behaviour in some obscure function somewhere in ghc
16:44:41 <kvanb> and people don't catch on until people do what you're doing now
16:44:42 <acowley> phaazon: The image looks great!
16:44:46 <kvanb> and it takes gigs of memory and hours
16:45:01 <kvanb> it usually results in ghc becoming faster for everyone
16:45:25 <kvanb> the last one i know of was in deriving ( ... )
16:45:31 <kvanb> and the build for some project went from minutes to seconds
16:46:22 <ski> joe9 : anyway, presumably you'd want `normalizeDotDot "/foo/bar/baz/../../quux" = "/foo/quux"' .. so you need "indefinite lookahead", so to speak
16:48:31 <phaazon> 01:50 < acowley> phaazon: The image looks great!
16:48:33 <phaazon> thank you :)
16:48:41 <phaazon> I’ll post more :)
16:48:43 <phaazon> but off to bed
16:48:47 <phaazon> exhausted
16:48:48 <phaazon> see you later
16:49:31 <lisbeth> is ghc written in haskell?
16:49:52 <vjeranc> lisbeth: yep
16:49:55 <ski> lisbeth : i remember seeing some package with some small unix utilities in the style of some common list (or string) processing functions in Haskell, but i don't recall the name
16:50:31 <lisbeth> That's funny. So after learning haskell I could fix things in haskel with haskell
16:51:32 <hughfdjackson> does it appear weird to anyone that there's no `concat parsers` operator in parsec?
16:51:56 <hughfdjackson> `string "hi" >> string " " >> string "there"` <- obviously only returns "there" as the parse result
16:51:58 <johnw> do you mean monoid concat?
16:52:03 <hughfdjackson> johnw: yea
16:52:10 <johnw> liftA2 (<>)
16:52:13 <hughfdjackson> i've defined my own, but it seems like i must have missed something..
16:52:32 <hughfdjackson> johnw: aha - thanks
16:52:38 <hughfdjackson> i'll take a look at how that one works :)
16:52:51 <ski> lisbeth : hehe, you might find <http://repetae.net/computer/jhc/jhc.shtml#the-story-of-jhc> interesting ..
16:52:55 <vjeranc> lisbeth: yep, it's very common to have a compiler in a language which it compiles...
16:52:59 <johnw> since parsec is an applicative/monadic parsing framework, we just need to lift the monoid append into the applicative
16:53:35 <acowley> In the case given, it might make sense to consider a list of parsers and concatenating all their results
16:53:45 <johnw> in fact, there are a few things that aren't "built-in" to parsec, because they don't need to be; but it also means you won't find them in parsec's documentation
16:53:53 <hughfdjackson> acowley: indeed :) then you could map string over them ..
16:54:04 <johnw> hi acowley!
16:54:42 <hughfdjackson> (the actual example was `many digit >> string "." >> many digit` to parse something that looked vaguely float-like)
16:54:44 <acowley> hughfdjackson: I meant more that if each parser returns a string, even if the individual parsers are created differently, you can sequence their effects and collect all the results.
16:54:52 <acowley> Hey johnw!
16:54:55 <joe9> ski, yes, I need "indefinite lookahead". Thanks.
16:55:12 <johnw> acowley: I've been meaning to tell you about a paper you would ilke
16:55:18 <ski> joe9 : so you can't just proceed sequentially through the list
16:55:29 <johnw> acowley: remember our discussion in NYC about the utility of studying adjunctions?
16:55:56 <acowley> johnw: And now you have a peer reviewed answer? :)
16:55:57 <Polarina> kvanb, I've submitted a bug report: https://ghc.haskell.org/trac/ghc/ticket/9675
16:56:10 <johnw> acowley: check out "Reason Isomorphically!" by Hinze, et al.
16:56:14 <johnw> great paper
16:56:21 <johnw> and highly relevant to that discussion
16:56:59 <acowley> Hah, yes, that does look perfect
16:57:41 * ski is curious about what johnw,acowley is talking about
16:57:45 <joe9> ski, any functions that you can think of that could help me to the solution?
16:57:59 <johnw> ski: acowley asked me, "So, how has studying adjunctions in category theory helped you with programming in Haskell?"
16:58:41 <ski> joe9 : there's probably many solutions, depending on taste/style and your goal(s). i was initially thinking a helper with an accumulator could be nice here
16:58:50 <augur> is it true in general that traversable is always derivable when you have an applicative? McBride's presentation of them seems to suggest it is
16:59:18 <augur> in that, the traverse definition is "map but applicative-ly" which should always be constructible
17:00:40 <augur> oh also he says at one point
17:00:46 <augur> "traverse works for any applicative structure"
17:01:04 <augur> so it does sound like you should be able to make traversable a derived class
17:01:26 <augur> i wonder if there's a definition of traverse that is generic..
17:01:52 <ski> johnw : mhm. recently i was pondering "curried natural transformations", and realized it was related to (right) Kan extensions
17:02:04 <acowley> ski: I was playing the curmudgeon to johnw's enthusiasm based on the fact that many of the examples of adjunctions people use in the context of Haskell are backfilling holes in our understanding rather than pointing at something new.
17:02:25 <johnw> ski: how you spoken to edwardk about this?
17:02:40 <ski> johnw : no. perhaps i should
17:02:44 <johnw> edwardk: because he's been talking about that very thing a lot over the past few months
17:02:52 <johnw> err, ski:
17:03:07 <johnw> he's encoded it rather nicely in his hask library
17:03:17 <kvanb> Polarina: thanks
17:03:18 <acowley> Have you spoken to Ed about these feelings you're having?
17:03:18 <sclv> traversable isn't a super/subclass of applicative if i recall
17:03:33 <johnw> Traversable does rely on Applicative
17:03:35 <sclv> but it should be roughly as auto-derivable as foldable
17:03:47 <augur> ski: what is a curried natural transformation?
17:03:48 <acowley> Is there not a DeriveTraversable?
17:03:56 <johnw> but the constraint is on the methods
17:03:57 <augur> ski: what is a _curriable_ one, in fact
17:04:02 <johnw> not as a subclass relationship
17:04:13 <sclv> right -- they are related, but there are Traversables that are not Applicatives, and vice versa.
17:04:14 <ski> well, i know he's been into Kan extensions, but i don't understand them much. i just realized that what i was considering was actually a (right) adjoint of a partially composed natural transformation
17:04:18 <johnw> right
17:04:37 <sclv> here is a constructive proof that we _Can_ derive traversable: https://hackage.haskell.org/package/derive-2.5.16/docs/Data-Derive-Traversable.html
17:05:44 <joe9> ski, thanks.
17:05:56 <sclv> speaking of backfilling with adjoints
17:05:57 <ski> augur : well, i was using scare quotes, because it's probably a little bit improper to say "curried" here. nonetheless. given a natural transformation `eta : F . G >---> H', i wanted to consider an alternate form `curried_eta : F >---> (G -> H)', and i realized that this `G -> H' is the right Kan extension of `H' along `G' (if i got the terminology right)
17:06:28 <sclv> once you know adjoints, i think that a good 90% at least of all the classic bird-merteens-formalism squiggol program derivation is a case of it
17:06:30 <sclv> if not all
17:06:48 <ski> augur : so, instead of "currying" a tuple type (iow a product, e.g. a categorical product, or at least something that feels vaguely tensory), i was considering composition instead
17:06:54 <sclv> similarly adjoints let us unify all recursion schemes
17:07:04 <augur> ski: oooh curried in the functor category where composition is the categorical product
17:07:30 <augur> hmm. does that category have exponential structure as well?
17:07:31 <ski> i'm not sure composition is the categorical product, here
17:07:38 <ski> in fact, i'm almost sure it isn't
17:07:50 <ski> (though it's monoidal, of course)
17:08:12 <ski> also, in the general case, these doesn't have to be endofunctors
17:08:21 <augur> ski: it looks vaguely like it should be, if you're relating  F.G >---> H  to  F >---> (G -> H)
17:09:07 <ski> augur : why ? in many categories of interest, it's a "tensor" operation which can fit into the currying patern like this, distinct from categorical product
17:09:44 <augur> ski: oh really? so what is -> then?
17:09:51 <augur> not an exponential then, surely
17:09:56 <ski> some kind of symmetric closed thing, perhaps
17:10:38 <ski> note that the tensor in linear logic (which can be curried as above into linear implication) isn't categorical product
17:11:32 <acowley> I'm not familiar with such a precise identification of a categorical product that you're using
17:11:43 <acowley> Where can I find one?
17:11:52 <ski> are you asking me or augur ?
17:11:59 <acowley> you
17:12:27 <augur> ski: tensor definitely cant be a categorical product, indeed
17:12:34 <acowley> I would have thought many tensor-y things can be a product
17:12:43 <ski> if you're asking what categorical product is, i could give an answer
17:12:54 <augur> acowley: categorical products aren't linear
17:12:55 <ski> acowley : yes, it can be
17:13:11 * ski isn't sure what augur meant by that
17:13:17 <augur> so you dont have to use both elements, whereas linear logic tensor requires you use both elements
17:13:44 * ski prefers to call neither product in linear logic "linear"
17:13:55 <Denommus> today is one of those moments where I feel I'm fighting against Haskell's type system
17:14:22 <ski> Denommus : any specific problem ?
17:14:22 <chirpsalot> Denommus: but it's fighting for you :).
17:14:36 <augur> speaking of, ski, would you be interested in trying to work out a generalized multicategory view of logic with fancier structural rules?
17:14:56 <Denommus> ski: yes, I can't get a banana-reactive Event out of a common Gtk2Hs event
17:15:00 <sclv> ski: i'm not able to follow your basic notion well, for some silly reason
17:15:24 <Denommus> I'm actually not even sure of what type signature a banana-reactive Event should have
17:15:31 <sclv> can you take say the diagram here (http://en.wikipedia.org/wiki/Kan_extension) and tell me "Name what they call X to F" etc. so that I can read it off?
17:15:35 <sclv> it feels close but no cigar...
17:15:37 <ski> augur : "multicategory" being the thing with a list of arrow sources (which, iiuc, can be used to explain tensor in vector spaces) ?
17:15:47 <augur> ski: yes
17:16:15 <sclv> a right kan extension is formally a  natural transformation and a functor both. i don't know what component you mean (G->H) to be or both?
17:16:31 <acowley> I'm not clear on why a tensor can't be a categorical product
17:16:43 <augur> acowley: categorical product has fst/snd
17:16:47 <sclv> unless what you mean is that you haven't _literally_ given a definition of a kan extension, but you've given an instance of one :-)
17:16:50 <sclv> in which case i can sort of hum along
17:16:51 <ski> Denommus : hm, i don't think i can help with that, seeing as i don't know much about the various reactive systems .. :/
17:17:08 <augur> acowley: which let you project elements. linear logic tensor (which is not just "a tensor", it's a specific thing) does not have these
17:17:22 <acowley> I guess I don't usually restrict "tensor" to linear logic
17:17:43 <augur> acowley: well no one does. ski _specifically_ said linear logic tensor :P
17:17:45 <jr> is there a function in the prelude that will turn a list into a string?
17:18:01 <Denommus> ski: the problem is that I have a function that evaluates to a (Frameworks t) => Moment t (Event t a) value
17:18:07 <acowley> Oh, well that explains that
17:18:09 <acowley> Thanks augur
17:18:14 <acowley> I should read more carefully
17:18:30 <ski> sclv : the functor, i think. let me check that page
17:18:35 <acowley> jr: A list of Chars?
17:18:40 <augur> acowley: lol. there's a specific conjunction-y thing in LinLog written as \otimes (and another one written &)
17:18:44 <Guest5502> acowley: yes
17:18:48 <acowley> augur: Yes, I know
17:18:49 <Denommus> ski: but it can't get an instance of (Frameworks t) from a use of the function in question
17:18:57 <acowley> Guest5502: id
17:19:01 <augur> acowley: also there's a version of disjunction written \oplus and a version written rotate(&,180°)
17:19:26 <Guest5502> acowley: id?
17:19:27 <nitrix> Today I learned about Either and Maybe monads. Also the either function, Just, const and couple others. I HAD A BLAST.
17:19:35 <Guest5502> acowley: is that a function??
17:19:35 <nitrix> Haskell makes soooo much sense.
17:20:15 <acowley> augur: https://github.com/acowley/LinearLogic/blob/master/LinProp.v :P
17:20:21 <Denommus> nitrix: oh, yeah. They're like Rust's Result and Option, but implementing the Monad typeclass
17:20:27 <augur> acowley: oh well then!
17:20:29 <augur> :p
17:20:34 <Denommus> nitrix: it indeed makes a LOT of sense
17:20:56 <acowley> Guest5502: type String = [Char]
17:20:58 <augur> oh incidentally, since you're acowley, you might be familiar with some AI planning stuff, ey?
17:21:08 <ski> sclv : their `F',`X',`R' correspond to my `G',`H',`G -> H'
17:21:11 <nitrix> Denommus: I also figured that id and const are similar to the SKI combinators.
17:21:28 <acowley> augur: Sure, though it's not one of my main areas
17:21:42 <ReinH> acowley: o/
17:21:49 <augur> acowley: any recommendations for reading?
17:21:52 <acowley> Hi ReinH!
17:21:57 <Denommus> nitrix: lots of things can be described in terms of monads
17:22:01 <ski> sclv : that `R' is also commonly written as `Ran_F X'
17:22:09 <acowley> augur: For motion planning or more general?
17:22:13 <Denommus> nitrix: what really have me mind blown was describing FRP in terms of Applicative Functors
17:22:18 <augur> acowley: more general
17:22:38 <ReinH> nitrix: id and const *are* the I and K combinators ;)
17:22:39 <nitrix> Denommus: Oh I'm not there yet, but I hear a lot of people talking about Functional Reactive Programming recently.
17:22:57 <nitrix> ReinH: AH! Well that explains it! No wonder they looked similar ;-;
17:23:26 <ReinH> Ix = x -> id x = x; Kxy = x -> const x _ = x
17:23:36 <ski> acowley : "<acowley> I'm not clear on why a tensor can't be a categorical product" -- "<ski> acowley : yes, it can be", it's just not always one
17:23:42 <Denommus> nitrix: it's quite interesting. You can describe the entirety of the dynamic behavior of a given time-dependent value on its declaration
17:24:04 <nitrix> Denommus: How's that even possible?
17:24:18 <sclv> ski: wait, so what corresponds to your F?
17:24:20 <nitrix> Denommus: Doesn't that mean you have to describe the interractions ahead of time?
17:25:18 <Denommus> nitrix: to put it simply, behaviors can be seen as this type: data Behavior a = Time -> a
17:25:40 <Denommus> nitrix: you describe behaviors with a combinations from other behaviors
17:25:45 <sclv> but yeah, i sorta see it at least...
17:25:48 <acowley> augur: The general popular planning approaches are POMDPs for probabilistic models, RRTs for large state spaces, and good old graph search if you just want to out code the competition
17:25:55 <sclv> thx
17:26:20 <Denommus> nitrix: on some FRP implementations it's actually a bit more complicated than that (you may have arrows, or some other resource to avoid time and space leaks), but at the end of the day you can see most things as that
17:27:07 <sclv> nitrix: of interest, <*> in the "unwrapped Reader applicative" (i.e. the function arrow `r ->`) corresponds to the S combinator too!
17:27:07 <ski> sclv : nothing in that diagram .. it'd be a functor parallel with `R'
17:27:31 <augur> acowley: hmm. RRT?
17:29:12 <ski> sclv : consider the ordinary exponential, where given objects `B' and `C', an exponential for them is specified by an object `B -> C' (aka `C^B') and a morphism `apply : (B -> C) * B >---> C' (where `*' is categorical product), such that blahblahblah
17:29:44 <augur> ski: multicategories!
17:29:50 <augur> (are superior for exponentials)
17:30:34 <ski> sclv : an alternate way of describing this is to say that the class of morphisms `A * B >---> C' is to be naturally (in `A' and `C') isomorphic to `A >---> (B -> C)', iow that `(* B)' and `(B ->)' form an adjunction situation
17:31:01 <ski> augur : and coexponentials ? ;)
17:32:08 <sclv> ski: oh, nice!
17:32:19 <acowley> augur: rapidly exploring random tree
17:32:25 <augur> ski: maybe! or maybe we need co-multicategories
17:32:40 <sclv> but... i thought kan extensions only sometimes existed?
17:32:41 <ski> sclv : do you see the parallel to my description of right Kan extensions, yet ?
17:32:50 <acowley> augur: Wherein you randomly sample from your state space and plan from multiple seeds rather than just your starting or desired configurations
17:32:58 <ski> sclv : i didn't claim otherwise ..
17:33:09 <sclv> right, i'm just grabbing onto your neat idea and pondering it
17:33:43 <acowley> augur: The downside being loss of optimality and completeness. You also often apply some kind of smoothing to any found trajectories.
17:33:45 <ski> anyway, i know next to nothing about Kan extensions, i just realized that what i was looking for seemed to be exactly (right) Kan extensions
17:34:26 <sclv> yeah, its a cool idea, i'm just trying to work through how deep it might go :-)
17:36:17 <sclv> indeed, the n-lab gives a presentation of kan extensions in terms of adjoints!
17:36:30 <ski> i'm pondering a kind of functorial syntax, and it seemed neat in one example to curry stuff, which got me thinking in this direction
17:36:51 <sclv> mind = blown
17:37:03 <ski> hehe, happy to oblige :)
17:37:30 <augur> > When you can make data out of potatoes, why would you want to encode them as functions?
17:37:32 <lambdabot>  <hint>:1:19: parse error on input ‘data’
17:37:33 * ski has no idea whether this idea will work out sensibly or not, though
17:37:35 <augur> words to live by
17:38:49 <augur> > One potato, two potato, three potato, four. All first-order data can be made from potatoes.
17:38:50 <lambdabot>  <hint>:1:11: parse error on input ‘,’
17:42:45 <Clint> how do i construct a function of Reader r a -> Reader (Maybe r) a?
17:44:47 <ski> @type let dimap :: (r1 -> r0) -> (a0 -> a1) -> Reader r0 a0 -> Reader r1 a1; dimap f g = reader . ((g .) . (. f)) . runReader in dimap
17:44:48 <lambdabot> (r1 -> r0) -> (a0 -> a1) -> Reader r0 a0 -> Reader r1 a1
17:44:59 <ski> something along those lines could perhaps help
17:45:22 <ski> Clint : specifying more closely what you want it to do could help ..
17:49:50 <acowley> Clint: That's a bit tricky as you need to produce an 'a' even if your Reader environment gives you Nothing
17:50:40 * hackagebot xmobar 0.22 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.22 (JoseAntonioOrtegaRuiz)
17:51:12 <Clint> acowley: right, i want to return const something if it's Nothing, and the action otherwise
17:52:23 <Clint> so i'm doing withReader blah on a sum type where blah is Just for the appropriate constructor
17:52:32 <Clint> for lack of a saner method
17:53:30 <acowley> :t \x r -> reader (maybe x (runReader r))
17:53:31 <lambdabot> MonadReader (Maybe a1) m => a -> Reader a1 a -> m a
17:54:23 <acowley> @pl \x r -> reader (maybe x (runReader r))
17:54:24 <lambdabot> (reader .) . (. runReader) . maybe
17:54:58 <acowley> I don't think I've ever written ".) . (."
17:55:35 <acowley> Anywho, that's your huckleberry iiuc
17:56:25 <acowley> lambdabot's affection for MTL is perhaps a tad obscuring
17:57:11 <Clint> hmm, thanks
17:57:45 <acowley> The Reader noise is what makes this harder to see, really
17:57:59 <ski> `Reader' or `MonadReader' ?
17:58:00 <acowley> what you're working with is exactly "maybe"
17:58:28 <Clint> right
17:58:36 <Clint> i was getting lost in some ask >>= maybe business
17:59:10 <acowley> Yeah, the plumbing is a bit much
17:59:21 <ski> Clint : what's the situation in which you want to use `Reader (Maybe a)' ?
17:59:33 <acowley> mullet = maybe business party
17:59:54 <ski> @wn mullet
17:59:56 <lambdabot> *** "mullet" wn "WordNet (r) 3.0 (2006)"
17:59:56 <lambdabot> mullet
17:59:56 <lambdabot>     n 1: highly valued lean flesh of marine or freshwater mullet
17:59:56 <lambdabot>          [syn: {mullet}, {grey mullet}, {gray mullet}]
17:59:58 <lambdabot>     2: freshwater or coastal food fishes a spindle-shaped body;
18:00:00 <lambdabot> [3 @more lines]
18:01:59 <Clint> ski: simplifying, i have a stream of [Blah], Blah is a sum type, I want to filter on arbitrary predicates which only will match one constructor, so i'm doing withReader thingy where thingy pattern-matches and returns Nothing if it's the wrong constructor
18:03:42 <brisbin> late to the game, but why the reader? sounds like mapMaybes to me
18:04:07 <brisbin> Clint: ^
18:04:33 * ski seconds brisbin's question
18:04:34 <Clint> brisbin: it's part of a dsl
18:04:47 <acowley> We've moved on to social motivations of hair styles
18:04:48 <Clint> i don't seem to be speaking english tonight
18:05:09 <Clint> the filter's being created from a happy parser
18:05:57 <Clint> this is about the third generation of me trying to do this less stupidly
18:05:58 <ski> by "the filter", what do you mean, exactly ?
18:08:07 <davidthomas> is there a way to disable -Werror from within ghci?
18:08:16 <davidthomas> :unset seems not to work
18:08:23 <Clint> ski: like if 'pktsize == 3098' got transformed into (liftA2 (==) (reader (\x -> B.length x)) (pure 3098)) or something
18:08:36 <gigabytes> guys, can I use makeLenses on a data type declared on another module?
18:09:22 <brisbin> try it and see?
18:10:09 <brisbin> davidthomas: i don't know the answer, but i'm curious how you got into this situation
18:12:25 <ski> Clint : i can't really say i understand how that would be connected to what you were talking about previously
18:13:49 <Guest5502> is there some kind of function to strip out a certain character from a string in haskell?
18:14:31 <brisbin> depends on the meaning of "strip"
18:14:35 <Clint> ski: there are predicates that only work on certain types of values
18:14:43 <brisbin> you might mean filter, or stripPrefix
18:14:49 <Guest5502> thanks
18:17:29 <acowley> Clint: Something that might be relevant here is all the *plate stuff. Lens has a nice Plated module.
18:18:53 <Clint> acowley: i'm using biplate elsewhere but i don't know how that would jive with CL.filter
18:19:37 <Guest5502> filter wasn't what I was looking for
18:21:05 <brisbin> Guest5502: can you define what you mean by "strip out" more exactly?
18:21:27 <Guest5502> brisbin: "45.67" f("45.67") = "4567"
18:22:48 <brisbin> Guest5502: filter (/= '.') ?
18:22:57 <davidthomas> brisbin: have a project that takes a while to build, -Werror in the .cabal file, started it with cabal repl, want to use a function with a warning on it
18:23:20 <brisbin> davidthomas: gotcha. I usually don't pust -Werror in cabal files
18:23:23 <acowley> Clint: Ah, sorry.
18:23:24 <Guest5502> brisbin: how do I apply that to a string? Can you show me it in a usage?
18:23:25 <brisbin> hackage won't take a package like that either
18:23:29 <davidthomas> not the end of the world, by any means, to edit the cabal file and run cabal repl again
18:23:44 <davidthomas> but wanted to know if there was something even easier :-P
18:23:56 <brisbin> there may be, i don't know it though
18:24:19 <brisbin> Guest5502: f = filter (/= '.'); f "A.String"
18:24:38 <ski> > filter (/= '.') "45.67"
18:24:40 <lambdabot>  "4567"
18:24:41 <acowley> > filter (/='.') "A.String"
18:24:42 <lambdabot>  "AString"
18:24:46 <Guest5502> thanks
18:29:44 <stapler> i have a dumb question for you all. i know (x:xs) seperates a list into head and tail. but why/what is it called?
18:29:53 <stapler> im one of those people who has to know why it does it
18:30:43 <acowley> A pattern match
18:30:57 <acowley> but I must take my leave
18:39:24 <Cale> stapler: The infix : is a data constructor. In general, you're allowed to match against data constructors and bind the things to which they've been applied to variables.
18:39:35 <stapler> what
18:40:08 <Cale> It might be a little clearer to understand if we used a different list type without the special syntax
18:40:20 <stapler> haskell newbie whos trying to figure it all out
18:40:23 <Cale> data List a = Nil | Cons a (List a)
18:40:31 <brisbin> stapler: there's a few things going on. generally a "pattern match" matches a value by its data constructor, by putting variables in the "holes" of the contructor. (:) is a data constructor for a list. it takes an item and another list and makes a new list. so (x:xs) pattern match with the (:) constructor and filling x and xs from the element and other list that were originally given to make the list in the
18:40:32 <brisbin> first place
18:40:45 <Cale> yes
18:40:55 <stapler> oh
18:40:57 <stapler> that makes sense
18:41:37 <brisbin> understanding it in terms of (the fictitous?) List a is very useful though
18:41:42 <Cale> If we started with a definition like that, you'd write  Cons x xs  instead of (x : xs)
18:42:30 <Cale> The syntax with the : is built in just because lists are so common that it's helpful to have some special syntax for them
18:42:54 <augur> incidentally tho, Cale, stapler
18:42:54 <Cale> But otherwise, we could just define our own List data type.
18:42:58 <ski> > let f (x,y) = 10*x + y in map f [(0,1),(2,3),(4,5)]
18:43:00 <lambdabot>  [1,23,45]
18:43:01 <augur> infix constructors all start with :
18:43:05 <ski> > let f (x,y) = 10*x + y in [f (0,1),f (2,3),f (4,5)]
18:43:07 <lambdabot>  [1,23,45]
18:43:08 <Cale> Yeah, that's true as well
18:43:09 <ski> stapler : note here how `f' applied to each pair in the list (which is what `map' does) will *match* each such pair (for each successive call) to the pattern `(x,y)', *binding* `x' and `y' to the individual components of each pair, in turn
18:43:11 <augur> and isnt it nice that the most common infix construct begins with, and is only, :
18:43:12 <augur> :)
18:43:19 <augur> constructor*
18:43:42 <augur> :) not being an infix constructor!
18:43:46 <stapler> eeerrrtt overload
18:43:55 <ski> stapler : in this case, `(... , ...)' is the constructor for pairs. while `... : ...' is one constructor for lists (the other is `[]')
18:43:57 <Cale> stapler: You can tell which functions are data constructors because their names always start with an uppercase letter, or if they're infix, with a colon
18:44:15 <Total_1mmersion> How do I force cabal to use a local copy of a package instead of the system package? I have package X listed in my build-depends and I want it to refer to package ./X/ instead of ~/.cabal/X/ or wherever it's stored.
18:44:27 <brisbin> all infix constructors start with ":"?
18:44:32 <brisbin> how have i never notice this
18:46:18 <gizmore> > let let(let) = 10
18:46:19 <lambdabot>  <hint>:1:12: parse error on input ‘)’
18:46:57 <augur> stapler: have you tried LYAH, fwiw?
18:47:16 <stapler> i own a physical copy but always get stuck dead in my tracks
18:47:46 <gigabyte_> guys, I'm trying to use the _head traversal on a list. Why do I get an error saying there's no instance for the Monoid class? I don't see Monoid anywhere
18:47:50 <augur> stapler: you should read it, and ask questions here! :)
18:48:05 <augur> stapler: and maybe play with the interactive learning thingy on the website
18:48:09 <gfixler> I have total-newb-level FFI questions
18:48:25 <ski> gizmore : try a lisp
18:48:52 <gfixler> I've never worked in C, or even compiled languages, really, except little exercises here and there
18:49:07 <gfixler> I work in Autodesk Maya, which has an embedded Python
18:49:11 <gizmore> haskell is a compiled language?
18:49:18 <gfixler> gizmore: C is
18:49:37 <gfixler> I meant that I've never done anything related to FFI work
18:49:58 <gfixler> I've never been able to find the Python files for Maya
18:50:05 <gizmore> gfixler: does that mean "no"? :/
18:50:06 <gfixler> but one day stumbled on a bunch of .so files that seemed related
18:50:07 <jle`> gizmore: haskell is compiled
18:50:09 <ski> gfixler : i'm sorry to say that languages aren't compiled or not. an implementation may be using compilation
18:50:15 <jle`> er
18:50:21 <jle`> yes v.v
18:50:27 <gfixler> I found a Python script and a data file that explained things a bit
18:50:36 <gizmore> jle`: so i can produce out.exe from haskell code by language tools?
18:50:50 <gfixler> the data file was just text with lines in the form mayaCommand -> somefile.so
18:50:55 <jle`> implementations you will be using if you intend to write haskell will compile your haskell to bytecode or something, or an executable
18:50:55 <gfixler> one for every command
18:51:03 <jle`> at least the ones that are popular today
18:51:11 <gfixler> and the little Python script used IIRC Python's ctypes module to generate all the Python commands from that file
18:51:18 <jle`> gizmore: yes, with GHC
18:51:22 <gfixler> so the Python doesn't exist until runtime
18:51:37 <gizmore> jle`: interesting... i know nothing about haskell.. so i better leave and maybe come back one day. thanks and see ya \o
18:51:41 <jle`> GHC compiles executables to bytecode in the most case
18:51:42 <gfixler> I feel like FFI would let me do the same thing with the .so files, but with Haskell
18:51:47 <jle`> there's also a javascript backend too
18:51:54 <jle`> gizmore: check out LYAH, it's a fun read :)
18:51:56 <jle`> @where lyah
18:51:56 <lambdabot> http://www.learnyouahaskell.com/
18:51:57 <gfixler> however, I don't know how that helps
18:52:29 <gfixler> would I need to write a Maya plugin that implemented Haskell somehow?
18:52:53 <zRecursive> Haskell seems make programming complicate ?
18:53:09 <gfixler> Haskell tries to make programming correct
18:53:18 <gfixler> which can be difficult for our ape minds to deal with
18:53:41 <zRecursive> ape ?
18:53:45 <gfixler> simian
18:54:06 <gfixler> meat-based, electro-chemical, ugly bags of mostly water
18:54:08 <gizmore> zRecursive: you seem to be familiar with crappy languages then
18:54:20 <gfixler> probably
18:55:15 <gfixler> no FFI gurus in here?
18:55:20 <zRecursive> Is Common Lisp a crappy language ? If so, then yes
18:55:41 * ski thinks Scheme is in many respects nicer than Common Lisp
18:57:39 <gizmore> zRecursive: i don´t know lisp, but every language is crappy when you don´t know it and wanna provocate people
18:58:22 <gizmore> lisp is complicated too, imo
18:58:48 <benmachine> life is complicated
18:58:51 <gfixler> lisp is just about the simplest language
18:58:58 <gizmore> 4 + ( 4 * ( 2 3 ) foo )
18:58:58 <gfixler> it's just all the layers of doing things with it that are complicated
18:59:01 <zRecursive> gizmore: I really donot provocate anyone, it is just my feeling.
18:59:10 <benmachine> a programming language that does not support complexity is inadequate
18:59:19 <gizmore> zRecursive: it´s me who was provocating, sorry for my ambigious statement
18:59:43 <benmachine> gizmore: the word is "provoke", btw
19:00:07 <benmachine> if you provoke people a lot you are provocative
19:00:35 <gizmore> i have done 5 years of php, 1.5y ruby ... and i just got curious if i should try python as well... people said i might be a haskell guy
19:00:44 <zRecursive> benmachine: interesting English
19:00:55 <gfixler> gizmore: Python isn't very different from Ruby, really
19:01:10 <stapler> ruby is smalltalk lite
19:01:10 <gizmore> yeah i guess... still i am interested how it "feels"
19:01:23 <stapler> bring back smalltalk pls
19:01:35 <gfixler> gizmore: as someone who's used Python for about 5 years, and who has watched a lot of Ruby talks
19:01:42 <gfixler> Ruby feels a bit crazier with syntax to me
19:01:43 <gizmore> in ruby there is gems + github ... is there githun for haskell too?
19:02:11 <gfixler> Guido van Rossum (Python's BDFL) has said that Python is an experiment in how much control to give the programmer
19:02:12 <solatis> gfixler: i think that's similar as me being a c++ dev and looking at some Objective C code
19:02:20 <solatis> objective c just feels crazy :)
19:02:22 <gizmore> ObjectiveC language is evil :P
19:02:29 <gfixler> solatis: objective c *is* crazy :)
19:02:45 <stapler> objective c-razy
19:02:51 <gizmore> ObjectiveC is like human language, designed for deaf monkeys
19:02:51 <zRecursive> gizmore: In fact, i know a little haskell by using xmonad
19:03:00 <gfixler> I agree - familiarity is part of it - but Python seems quite a bit less fond of cool operators and such
19:03:02 <solatis> i still don't understand why someone did that to the world -- inventing objective c
19:03:06 <augur> gizmore: oh gosh dont say that
19:03:12 <augur> gizmore: human language is pretty great
19:03:15 <augur> objective C is not
19:03:25 <solatis> human language sucks
19:03:25 <gfixler> augur: I was just thinking about that recently
19:03:38 <gfixler> why is math so concrete, and language so all over the place?
19:03:45 <gfixler> but the answer is obvious
19:03:46 <solatis> it's a pretty bad medium for expressing feelings, thoughts
19:03:54 <gfixler> math is an attempt to define reality
19:03:58 <gizmore> i _had_ to learn ruby for work... better: i had to support/continue a project at work... after 2.5 years now, i started to like it, and use it for a private project since january :)
19:03:59 <augur> gfixler: language isnt all over the place
19:04:01 <stapler> use COBOL
19:04:12 <gfixler> language is an attempt to wrap structure around the meat-based mouth flappings people have made since pre caveman days
19:04:14 <augur> gfixler: language just has a larger vocabulary than math
19:04:17 <solatis> gfixler: too bad Godel came along and proved math wrong
19:04:31 <gizmore> the ruby syntax was crazy for me in the beginning.. meanwhile i think it´s very clean and makes sense all the way
19:04:33 <gfixler> solatis: wait, math is wrong now?
19:04:34 <gfixler> great
19:04:45 <gfixler> augur: it's pretty all over the place
19:04:53 <gizmore> i assume the syntax thingy applies to haskell and lisp as well... but not to ObjectiveC :P
19:05:00 <solatis> gfixler: https://en.wikipedia.org/wiki/G%C3%B6del's_incompleteness_theorems
19:05:04 <augur> gfixler: it only seems that way when you dont have enough information!
19:05:11 <gfixler> solatis: oh, I remember watching some talk about this
19:05:13 <benmachine> solatis: that's not wrong
19:05:14 <augur> solatis: that is an invalid understanding of the incompleteness theorem
19:05:16 <gfixler> seemed pretty hardcore to me
19:05:17 <benmachine> it's just not all the right
19:05:22 * gfixler is not a maths guy
19:05:25 <stapler> math is not a language
19:05:25 <benmachine> you gotta miss some bits out, that's fine
19:05:27 <stapler> please dont say it is
19:05:47 <augur> i agree, math is not a language
19:05:51 <Sythix> this may sound random, and trollish.. but it's a real concern. i sit with a laptop on my legs for probably 5+ hours a day... should i be worried about testicular cancer? i heard women get it from having their cellphones in their bra.. so it only makes sense.
19:05:53 <gizmore> i wanna show you guys my php work in #shadowlamb  ( a text based mud with multi-irc-network )
19:06:16 <solatis> augur: ok true, as far as i understood it, godel proved that math is incomplete because math cannot be described in math -- or something like that
19:06:19 <stapler> Sythix, i think you'd want to get checked our for brain cancer first
19:06:28 <gfixler> augur: it morphs all over the place
19:06:37 <Sythix> ok, will do
19:06:37 <benmachine> Sythix: that's not exactly on-topic, but... you should not be worried about radiation, mobile phones do not cause any harm whatsoever
19:06:52 <gfixler> augur: http://www.cupola.com/html/wordplay/english1.htm
19:06:54 <seliopou> has anybody gotten linking errors involving uniplate recently?
19:06:55 <augur> sobaken: any formal language powerful enough to express the ideas of arithmetic is necessarily either incomplete or inconsistent
19:07:01 <benmachine> Sythix: I've heard excessive heat can be bad but goodness me, do your own research :P
19:07:18 <Sythix> just fn google it... ok i know. got it
19:07:22 <Sythix> thanks
19:07:25 <seliopou> i'm trying to compile language-ecmascript and I'm getting unknown symbol errors
19:07:32 <augur> gfixler: im well aware. but those are really rather trivial things
19:07:45 <stapler> augur, what
19:07:47 <seliopou> but it's coming from uniplate, which has already been successfully compiled and installed
19:08:05 <augur> stapler: what what
19:08:12 <stapler> <augur> sobaken: any formal language powerful enough to express the ideas of arithmetic is necessarily either incomplete or inconsistent
19:08:22 <gfixler> augur: also this http://www.audible.com/pd/History/Globish-Audiobook/B003OY23SG?source_code=GPAGBSH0508140001&amp;
19:08:26 <augur> stapler: what about it
19:08:33 <stapler> why does that make any sense at all
19:08:35 <gfixler> I listened to that on my commute for about a week - 10 hours of English sliding around all over the place
19:08:41 <augur> i should strip the "ideas", really. its kind of silly to have
19:08:47 <augur> stapler: what do you mean why
19:09:14 <augur> gfixler: sure. but that's all really rather simple, boring stuff
19:09:15 <stapler> a language powerful enough to experss arithmetic is incomplete or inconsistent
19:09:16 <stapler> why is this
19:09:18 <gfixler> augur: there's also http://en.wikipedia.org/wiki/Simplified_Technical_English
19:09:20 <stapler> why does that make sense to you
19:09:28 <benmachine> stapler: the proof is not straightforward
19:09:31 <gfixler> augur: which is an attempt to make English not so all over the place
19:09:38 <augur> stapler: oh, i dont understand why its true. its some obnoxious godel stuff :)
19:09:39 <gfixler> so astronauts don't kill themselves
19:09:44 <solatis> :)
19:09:46 <solatis> haha
19:09:52 <solatis> "obnoxious godel stuff"
19:10:06 <augur> gfixler: irregularities are boring!
19:10:18 <solatis> yeah i never really understood godel
19:10:20 <benmachine> stapler: but roughly speaking you can use arithmetic to encode statements *about* logical systems, so if your system can encode arithmetic, it can also (to some extent) encode statements about itself
19:10:25 <gfixler> augur: see also: stress and inflection, which change the meaning of everything
19:10:36 <gfixler> I can say "I *love* this" (meaning I hate it)
19:10:44 <augur> gfixler: stress and other suprasegmental stuff is usually fairly straight forward
19:10:55 <benmachine> stapler: then you can formulate sentences which say something like "this sentence is not provable in this theory", then if that sentence is provable the theory is inconsistent, but if it is not, then it is incomplete
19:10:56 <stapler> you guys sohuld all just learn lojban
19:11:05 <gfixler> augur: there's also lojban :)
19:11:06 <solatis> but i do that his impact with his incompleteness theorems on math was pretty big
19:11:07 <augur> lojban is an awful idea
19:11:18 <stapler> augur, why
19:11:23 <augur> this is kind of off topic tho, maybe we should take it to #haskell-blah
19:11:24 <solatis> as far as i understood, until godel came along, mathematicians thought math was so great that it could describe anything
19:11:25 <gfixler> augur: but it's also a hilarious idea
19:11:54 <augur> stapler: -> #haskell-blah
19:12:03 <gfixler> augur: agreed (and I said "a hilarious" because I'm American - more inconsistencies!)
19:12:39 <benmachine> gfixler: nah, everyone does that
19:12:52 <benmachine> you don't say "an hotel" unless you're deliberately trying to be weird and affected
19:12:59 * ski . o O ( "Wir müssen wissen, Wir werden wissen !" -- David Hilbert, 1930-09-08 )
19:13:08 <benmachine> or you have an accent that omits the h entirely
19:13:12 <sclv> @remember pigworker: When you can make data out of potatoes, why would you want to encode them as functions?
19:13:13 <lambdabot> It is stored.
19:13:44 <augur> benmachine: -> blah
19:13:54 <ski> @quote pigworker
19:13:54 <lambdabot> pigworker says: Keeping layout keywords at the end of line displays admirable horizontal thrift.
19:13:59 <ski> @quote pigworker:
19:13:59 <lambdabot> pigworker: says: When you can make data out of potatoes, why would you want to encode them as functions?
19:15:26 <augur> benmachine: i think there's thing where an is used before an unstressed hi-
19:15:33 <augur> i think there's an actual pattern to it
19:15:59 <benmachine> oh, shrug
19:16:14 <augur> its a conjecture tho
19:16:19 <augur> oh no its godel
19:16:23 <augur> with his damned theorem!
19:16:32 <augur> ski: how do i add quotes?
19:16:43 <augur> oh, wait, someone aded the potato one!
19:16:51 <augur> sclv just did. hahaha. thank you :D
19:17:33 <solatis> btw, this might be slightly off-topic, but i always loved the bbc horizon episode that interviews the guy that proved fermat's last theorem
19:17:43 <solatis> http://vimeo.com/18216532
19:17:44 <lisbeth> https://www.youtube.com/watch?v=RqvCNb7fKsg : lol
19:18:05 <solatis> it shows the great amount of stress, emotions, and dedication that goes into proving things like these
19:18:22 <solatis> and also shows how math is a typical example of 'building on the shoulders of giants'
19:18:43 <solatis> recommended watch for many haskellers ;)
19:19:20 <ski> @forget pigworker: When you can make data out of potatoes, why would you want to encode them as functions?
19:19:20 <lambdabot> Done.
19:19:25 <ski> @remember pigworker When you can make data out of potatoes, why would you want to encode them as functions?
19:19:25 <lambdabot> Done.
19:25:34 <lisbeth> in haskell do you ever worry about escaping?
19:25:42 <lisbeth> as in special escape characters such as \n
19:25:45 <lisbeth> \$
19:25:45 <lisbeth> etc
19:27:30 <ski> > length "\n"
19:27:32 <lambdabot>  1
19:27:51 <ski> there's a couple of character/string escapes like that
19:28:10 <ski> > '\0'
19:28:12 <lambdabot>  '\NUL'
19:28:35 <jayunit100_4g> hi haskell
19:28:44 <jayunit100_4g> ive been attempting to convert a digit to an int.
19:28:51 <jayunit100_4g> im sorry, a string to a digit :)
19:29:16 <jayunit100_4g> however im running into a syntax error here…. not sure how to define a partial function in fold….
19:29:17 <jayunit100_4g> asInt s = foldl (digitToInt (+ (* 10) )) s  -- not sure how
19:29:59 <jayunit100_4g> http://learnyouahaskell.com/higher-order-functions to the rescue :)
19:30:33 <ski> jayunit100_4g : you need to pass three arguments to `foldl'
19:30:49 <brisbin> you have digitToInt as the last thing, shouldn't it be first?
19:31:16 <ski> jayunit100_4g : the simplest is probably to name the function you're passing to `foldl'
19:31:36 <lisbeth> I am pretty new at this but if you are converting a sring into a number shouldn't you use read?
19:31:39 <ski> iow, something like :
19:31:51 <ski>   asInt s = foldl combine blah s
19:31:53 <ski>     where
19:32:06 <ski>     combine n c = ..n..c..
19:32:46 <ski> where `combine' is meant to combine a number and a character (which should be a digit) into a number
19:32:48 <brisbin> also (+ (* 10)) doesn't make much sense to me
19:33:24 <brisbin> pretty sure it's a type error
19:33:26 <ski> lisbeth : or `reads'
19:33:51 <lisbeth> reading this page may help you: http://learnyouahaskell.com/types-and-typeclasses
19:33:53 <ski> brisbin : well, you could provide `Num (rho ->)' ...
19:34:05 <lisbeth> but I could be wrong. Maybe I don't understand the issue.
19:35:03 <brisbin> ski: heh, sure. good luck
19:35:32 <lisbeth> from what I understand it should always be good to look at the type of a function
19:36:00 <lisbeth> and make sure that the output from one function is compatible with the type of another function
19:36:01 <ski> brisbin : in some circumstances, that can actually be a nice thing to do
19:37:10 <lisbeth> Not sure if I am saying really obvious stuff or it is helpful.
19:37:12 <ski> lisbeth : well, if it isn't, the type system will yell :)
19:37:24 <lisbeth> Yeah I guess.
19:37:39 <ski> (determining the reason for its yelling can be trickier, of course)
19:37:56 <jayunit100_4g> >foldl (\ a b -> ((digitToInt b) + 10*a)) 0 "12344"
19:38:11 <jayunit100_4g> thanks  ! ski
19:38:18 <jayunit100_4g> > foldl (\ a b -> ((digitToInt b) + 10*a)) 0 "12344"
19:38:19 <lambdabot>  <hint>:1:42: lexical error at character '\FS'
19:38:39 <jayunit100_4g> weird.  works in my ghci
19:38:45 <lisbeth> it seems to me, from what I have read, there are very few things that can be the cause of errors in haskell besides synatx, using the wrong types, or logical errors
19:40:03 <ski> > foldl (\a b -> 10 * a + digitToInt b) 0 "12344"
19:40:04 <lambdabot>  12344
19:41:15 <ski> lisbeth : i suppose one might count run-time errors into logical errors ..
19:41:34 <lisbeth> run-time?
19:42:04 <ski> > map head ["abc","de","f",""]
19:42:05 <lambdabot>  "adf*Exception: Prelude.head: empty list
19:42:31 <lisbeth> I know what head does but I don't know what map does
19:42:40 <ski> do you know list comprehensions ?
19:42:56 <lisbeth> If you give me a couple of minutes I will know it again
19:43:08 <lisbeth> you can explain while I read those paragraphs again
19:43:20 <ski> > map f [a,b,c,d]                       :: [Expr]
19:43:22 <lambdabot>  [f a,f b,f c,f d]
19:43:34 <ski> > [f x | x <- [a,b,c,d]]                       :: [Expr]
19:43:36 <lambdabot>  [f a,f b,f c,f d]
19:43:41 <ski> > [head s | s <- ["abc","de","f",""]]
19:43:42 <lambdabot>  "adf*Exception: Prelude.head: empty list
19:44:09 <ski> `map' calls a given function on every element of a list, collecting the results into a list
19:44:23 <ski> the list comprehension used above does the same thing
19:44:29 <t4nk940> @pl \x -> id x
19:44:29 <lambdabot> id
19:44:33 <lisbeth> oh
19:44:52 <lisbeth> yeah I call that a logical error
19:44:56 <ski> > head []  -- is really the core of the example i gave
19:44:56 <t4nk940> @pl \x y -> show (x - y) ++ show (x + y)
19:44:56 <lambdabot> ap (ap . (((++) . show) .) . (-)) ((show .) . (+))
19:44:58 <lambdabot>  *Exception: Prelude.head: empty list
19:45:47 <lisbeth> If the original input and the functions they pass through aren't logical to go together, I call that a logical error
19:46:02 <lisbeth> That's what I like about haskell so far
19:46:19 <t4nk940> @pl \x y -> (x - y) * (x + y)
19:46:19 <lambdabot> ap (ap . ((*) .) . (-)) (+)
19:46:32 <t4nk940> @pl \x y -> (x - y) ++ (x + y)
19:46:32 <lambdabot> ap (ap . ((++) .) . (-)) (+)
19:47:14 <ski> t4nk940 : `curry (liftA2 (++) (show . uncurry (-)) (show . uncurry (+)))' is one version .. -- perhaps not that nice
19:47:46 <t4nk940> i'm curious why that last one even worked
19:48:02 <t4nk940> seems like it would need to be:
19:48:12 <t4nk940> @pl \x y -> (x - y) <> (x + y)
19:48:13 <lambdabot> ap (ap . ((<>) .) . (-)) (+)
19:48:27 <t4nk940> @pl \x y -> (x - y) +baz+ (x + y)
19:48:27 <lambdabot> ap (ap . ((+) .) . flip flip baz . ((+) .) . (-)) (+)
19:48:28 <ski> t4nk940 : `curry (uncurry (++) . (show *** show) . (uncurry (-) &&& uncurry (+)))' is another
19:48:35 <t4nk940> i see :)
19:49:02 <ski> anyway, mostly `pl' gives more or less pointless answers
19:49:27 <ski> it's usually better to make it pointless by hand
19:50:34 <t4nk940> ski: any way to get the bot to use Function.on
19:52:51 <t4nk940> is there a library that does the same as &&& but with functions that take 2 params?
19:54:00 <ski> @pointless \f g x y -> (f x y,g x y)
19:54:01 <lambdabot> liftM2 (liftM2 (,))
19:54:22 <t4nk940> cool, thanks
19:55:41 <t4nk940> @pl (++) `on` show
19:55:41 <lambdabot> (++) `on` show
19:58:28 <t4nk940> @pl \x y -> on (++) show (x - y) (x + y)
19:58:28 <lambdabot> ap (ap . (on (++) show .) . (-)) (+)
19:58:31 <zwer> :t liftM2 (liftM2 (,))
19:58:32 <lambdabot> (Monad m1, Monad m) => m (m1 a1) -> m (m1 a2) -> m (m1 (a1, a2))
19:58:43 <zwer> :t liftM3 (,,)
19:58:44 <lambdabot> Monad m => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
19:58:48 <ski> @type liftM2 . liftM2
19:58:49 <lambdabot> (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
20:00:25 <jle`> liftM2/liftM3 will soon succumb to the fates that they deserve
20:01:34 <jle`> still i think they will be kept in base for backwards compatibility
20:01:57 <jle`> their names just look so off-putting to me :|
20:02:20 <jle`> and what they do is hardly monadic in nature
20:04:11 <ski> yes, but idioms weren't appreciated back then
20:04:17 <t4nk940> just needs context:  liftM up && down.   or liftM2 reps >> 4 reps >> goto the beach
20:04:53 <zq> w 4
20:05:12 <ski> s 3
20:05:47 * hackagebot hopenpgp-tools 0.13 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.13 (ClintAdams)
20:05:48 <zwer> jle` what fate is that? I doubt they will be removed? (though I wouldn't mind it)
20:05:49 * hackagebot bytestring-trie 0.2.4 - An efficient finite map from (byte)strings to values.  http://hackage.haskell.org/package/bytestring-trie-0.2.4 (WrenThornton)
20:06:39 <jle`> zwer: there will no longer be a situation where they are necessary
20:06:54 <jle`> and subsequently they will fade from common usage or idiom
20:07:04 <jle`> goodbye
20:07:38 <ski> well, the idiomatic variant is `liftA2'
20:07:51 <ski> ("idiom" being a synonym for "applicative functor")
20:07:53 <jle`> glad liftM died out of common usage much faster than liftM2/liftM3, even though there are still situations where it is necessary
20:08:06 <jle`> liftA2 is so much nicer though :)
20:08:08 <jle`> don't you think?
20:08:15 <jle`> something about it just feels like happiness and sunshine and rainbows
20:08:20 <ski> well, i commonly use `fmap'
20:08:21 <jle`> liftM2 feels like rain clouds and murk
20:08:55 * ski doesn't care much for the names of `(<$>)' and `(<*>)'
20:08:57 <lisbeth> OH
20:09:02 <lisbeth> so _ is like * is in bash
20:09:05 <lisbeth> that's cool
20:09:12 <jle`> yeah i've heard it called "wildcard"
20:09:28 <ski> `_' in a pattern matches anything, without giving a name to it
20:09:38 <lisbeth> The problem with learning haskell it is is very dense logic so I have to read a bit of the guide and take a break
20:09:45 <jle`> technically, `x` is like * in bash, too
20:09:50 <lisbeth> and I'm sure I'll re-read it several times throughout learning to code
20:10:01 <ski> lisbeth : that's fine
20:10:04 <lisbeth> do you mean:
20:10:04 <lisbeth> x
20:10:06 <lisbeth> or litereally:
20:10:09 <lisbeth> 'x'
20:10:09 <lpaste> dfeuer pasted “inits” at http://lpaste.net/4376239682241953792
20:10:10 <jle`> in mattern matches, something like `x` is essentially the same as `_`
20:10:19 <jle`> so they are both wildcards :)
20:10:44 <jle`> > let (h:_) = [1,2,3] in "hello"
20:10:44 <lisbeth> oh so you can have multiple wildcards
20:10:46 <lambdabot>  "hello"
20:10:50 <lisbeth> or rather named wildcards
20:10:53 <zwer> except that you can use the value assigned to x but not to _
20:10:53 <jle`> > let (h:x) = [1,2,3] in "hello"
20:10:54 <lambdabot>  "hello"
20:10:56 <lisbeth> am I understanding corrrectly?
20:10:57 * ski likes to think of `_' as a (left) identity for `@'
20:11:21 <ski> lisbeth : your "named wildcards" are just variable names (as used in patterns)
20:11:39 <augur> ski: hah. you're right, it's the left identity.. how interesting
20:11:53 <augur> ski: also, its the right identity!   foo x@_ ~ foo x
20:12:02 <ski> > let h:x = [1,2,3] in "hello"  -- look, ma, no brackets in the pattern !
20:12:03 <lambdabot>  "hello"
20:12:12 <augur> > let x@_ = 1 in x
20:12:13 <lambdabot>  1
20:12:27 <augur> ski: pattern equations maybe?
20:12:31 <augur> how weird
20:12:33 <lisbeth> when do I get to start doing things like manipulating files in a *nix shell?
20:12:41 <ski> augur : except those two are different syntactic categories .. but with the required implicit conversion, yeah
20:12:46 <lisbeth> that's the core of what I want to do atm is manipulate files
20:12:57 <jle`> lisbeth: it's coming :)
20:13:11 <augur> lisbeth: you should take time and work up to that, tbh
20:13:21 <lisbeth> But my main question is are those built in commands I'll probably learn in the guides or am I going to have to add other people's scripts onto mine?
20:13:35 <augur> if you want to use haskell for that immediately, maybe use another language you're more comfortable with right now
20:13:50 <lisbeth> That's not the issue.
20:13:53 <jle`> lisbeth: here's a bit of a mix of both
20:14:04 <jle`> there are some common libraries that are basically universally excepted
20:14:06 <jle`> like `filepath`
20:14:10 <lisbeth> I understand everything I've read so far. Basically I am taking a break from thinking about it  and making conversation
20:14:14 <lisbeth> as I said it is very dense logic to learn
20:14:16 <jle`> er, accepted
20:14:19 <ski> lisbeth : there are library operations for manipulating files. no primitive special syntax for it, though
20:15:20 <jle`> ah yea,h there's no special syntax/keywords/statements built in for file manipulations, it's all basically using libraries
20:15:52 <jle`> whether in `base` or outside of base
20:17:34 <jle`> haskell is neat in that you can actually do so much without having built-in statements at all
20:17:35 <lisbeth> ok cool
20:17:41 <jle`> but that's another story :)
20:18:00 <lisbeth> I realize this. I figure alot of haskell you just write your code from scratch
20:18:11 <Hafydd> The idea of having a special syntax for manipulating files is a bit depressing.
20:18:12 <jle`> well... a lot of haskell, you use libraries
20:18:36 <jle`> haskell import lists are infamously long :P
20:18:42 <lisbeth> I want to develop some libraries that replace GNU
20:18:51 <lisbeth> so I can just open up ghc and use it instead of bash
20:19:09 <lisbeth> feel me?
20:19:46 <ski> ok
20:19:48 <lisbeth> I was writing shell scripts but I eventually started designing things without loops and using only tiny functions and pipes
20:19:58 <jle`> you might like hawk :)
20:20:21 <lisbeth> is that a shell?
20:20:38 <jle`> https://github.com/gelisam/hawk
20:20:57 <jle`> it's not a shell ... there have been attempts at a haskell shell, but i don't think any of them are super mature at this point
20:21:09 <jle`> but it's kind of like a tool that lets you use haskell commands as one-liners
20:21:17 <jle`> for scripting/file processing
20:23:04 <u-ou> hmmm
20:40:06 <TallerGhostWalt> I have a lot of trouble getting finally to run when I am running a program in the background
20:40:25 <TallerGhostWalt> it has happened several times and I am not even really sure where to start looking
20:50:49 * hackagebot apiary 1.1.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.1.0 (HirotomoMoriwaki)
20:50:51 * hackagebot apiary-logger 1.1.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.1.0 (HirotomoMoriwaki)
20:55:49 * hackagebot apiary-persistent 1.1.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.1.0 (HirotomoMoriwaki)
20:55:51 * hackagebot apiary-websockets 1.1.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-1.1.0 (HirotomoMoriwaki)
20:55:53 * hackagebot apiary-cookie 1.1.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.1.0 (HirotomoMoriwaki)
20:55:55 * hackagebot apiary-clientsession 1.1.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-1.1.0 (HirotomoMoriwaki)
20:55:57 * hackagebot apiary-authenticate 1.1.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.1.0 (HirotomoMoriwaki)
20:57:53 <kazagistar> TallerGhostWalt: the exception catching finally?
21:00:59 <lisbeth> not sure if the people who heard me before were still here
21:00:59 * hackagebot apiary-eventsource 1.1.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-1.1.0 (HirotomoMoriwaki)
21:01:01 * hackagebot apiary-purescript 1.1.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.1.0 (HirotomoMoriwaki)
21:01:03 * hackagebot apiary-mongoDB 1.1.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.1.0 (HirotomoMoriwaki)
21:01:05 * hackagebot apiary-memcached 1.1.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.1.0 (HirotomoMoriwaki)
21:01:07 * hackagebot apiary-helics 1.1.0 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.0 (HirotomoMoriwaki)
21:01:13 <johnw> it's filter time..
21:01:20 <lisbeth> but the way I see it ghci is already pretty much a shell
21:01:36 <lisbeth> you just need to change the prompt to it looks more like a shell prompt
21:01:41 <lisbeth> and add a few things
21:01:53 <ski> it's an interactor, to be sure
21:02:04 <lisbeth> there's a few problems such as
21:02:09 <lisbeth> a shell has a working directory
21:02:21 <ski> a shell to a Haskell system, instead of (more or less directly) to an OS, if you will
21:02:22 <lisbeth> so it would be weird to try to change the working directory
21:02:28 <jle`> ghci has a pwd too, i think
21:02:52 <lisbeth> pwd doesn't work in mine
21:03:06 <marchelzo_> try :cd
21:03:19 <ski> lisbeth : try `:!pwd'
21:03:44 <lisbeth> nope none of that is working
21:04:00 <ski> `:!pwd' and `:cd blah' works here
21:04:03 <lisbeth> It's not a huge deal to have a working directory
21:04:12 <marchelzo_> !pwd is not ghci though
21:04:17 <TallerGhostWalt> kazagistar: I don't really know what you mean
21:04:17 <lisbeth> you can just use absolute pathnames for everything
21:04:23 <trap_exit> are there any open questions left in bitcoin research? (i.e. are sub 10 minute confirmations + total anonymity) problems that (1) have no theoreticla solutions or (2) have theoretical solutions ... but are just not implemneted?
21:04:28 <trap_exit> hmm, wrong channel, sorry
21:04:29 <TallerGhostWalt> kazagistar: the regular finally
21:04:45 <ski> @index finally
21:04:45 <lambdabot> Control.Exception, Distribution.Compat.Exception
21:05:36 <jle`> how come there is no pwd on System.Directory ;_;
21:05:55 <marchelzo_> @src finally
21:05:55 <lambdabot> a `finally` sequel = block $ do
21:05:55 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
21:05:55 <lambdabot>     sequel
21:05:55 <lambdabot>     return r
21:06:09 * hackagebot growler 0.2.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.2.0 (IanDuncan)
21:06:11 <jle`> oh there it is
21:06:16 <jle`> @hoogle getCurrentDirectory
21:06:18 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
21:06:26 <jle`> there's also
21:06:36 <jle`> @hoogle setCurrentDirectory
21:06:38 <lambdabot> System.Directory setCurrentDirectory :: FilePath -> IO ()
21:06:54 <cellopin>  /join #python
21:07:00 <TallerGhostWalt> I guess the finally in lifted-base
21:07:03 <jle`> @hoogle getDirectoryContents
21:07:05 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
21:07:51 <TallerGhostWalt> If I want the finally to work in the background... should I use a different finally?
21:08:21 <TallerGhostWalt> aahhh
21:08:24 <TallerGhostWalt> there it is man...
21:08:32 <TallerGhostWalt> <-- just give up
21:11:28 <cellopin> I tried installing ghcmod-vim plugin and I think it cannot find ghc-mod. Is it because I installed ghc-mod in a sandbox?
21:12:15 <jle`> cellopin: you can copy the binary to a location in your $PATH :)
21:12:29 <Arahael> Or just add the .cabal/bin to the path?
21:15:52 <lisbeth> If I can do:
21:16:03 <lisbeth> sayMe 1 = "One!"
21:16:11 <lisbeth> can I put math inside of the place where 1 is?
21:16:53 <lisbeth> actually nevermind I figured out a functiont to replace what I was trying to do
21:17:10 <kazagistar> lisbeth: no, its pattern matching only... if it sees what is on the left, it evaluates it to what is on the right
21:19:29 <lisbeth> can I make what's on the left represent "a number that is divisible by 2"
21:19:35 <jle`> you can do sayMe x | someMathInvolvingXEvolvingToTrue = "One"
21:19:41 <jle`> sayMe x | even x = ...
21:19:53 <jle`> guards
21:20:15 <jle`> s/Evolving/Evaluating
21:20:18 <jle`> s/True/Bool
21:20:21 <jle`> what am i thinking today
21:26:38 <zq> is it better to release on friday or a non-friday?
21:26:54 <zq> i'd say the latter since everyone's too busy to give a shit on fridays
21:30:35 <bjorkintosh> zq, if you don't want anyone to take notice, do it on a friday.
21:31:37 <zq> i heard that wednesday is the peak give-a-shit day of week
21:37:34 <jTT> Hey, I am trying to get some hands on experience with parsing in Haskell. I am using conduit to open and read all files in a folder, and as an exercise I would like to count all the letters ‘x’ in each document. I created a type called NumerOfX = (FilePath, Int); I am hoping to then have pairs that I can write to a result file. However, for the actual counting, I initially simply used a function that I mapped over the string resulting from
21:37:35 <jTT> the file’s contents. But I would instead like to use attoparsec. Is there a better way than taking each individual char, unpacking it, and comparing it to ‘x’?
21:38:04 <johnw> there's also attoparsec-conduit too
21:38:08 <johnw> for parsing straight out of a conduit
21:38:13 <jTT> oh ncie
21:38:14 <jTT> nice
21:38:19 <jTT> will check it out
21:38:43 <johnw> then you can use element-wise filterCE, and then make a counter out of that
21:38:55 <johnw> (err, that would be instead of using attoparsec)
21:39:41 <jTT> awsome, cheers. filterCE. will look it up now. Thanks a lot
21:40:18 <johnw> sourceFile $= foldlCE (\n x -> if x == 'x' then n + 1 else n)
21:40:26 <johnw> 0
21:40:36 <johnw> that will count x characters in the file
21:41:06 <johnw> essentially conduit is letting you treat the contents of the file as a lazy list, without using lazy I/O
21:41:25 <ben_vulpes> what does the left hand of a => in a function's type signature indicate?
21:41:32 <johnw> a type constraint
21:41:35 <jTT> so how does it know when the end of one file has been reached?
21:41:47 <johnw> jTT: that's part of how sourceFile works
21:41:53 <jTT> sweet
21:42:01 <lisbeth> function1 function2 5
21:42:04 <lisbeth> passes five into function 2
21:42:09 <lisbeth> then passes the output of that into function1
21:42:10 <lisbeth> correct?
21:42:21 <zq> more like
21:42:22 <johnw> not quite
21:42:28 <johnw> it passes function2 to function1
21:42:31 <johnw> then passes 5 to the result
21:42:37 <zq> passes function2 into function1, then passes 5 into the curried output that is (function1 function2)
21:42:50 <ski> `function1 function2 5' is short for `(function1 function2) 5'
21:42:50 <zq> currying leaves no ambiguity
21:43:00 <ski> if you mean `function1 (function2 5)', then say that
21:43:12 <lisbeth> aha
21:43:13 <lisbeth> thanks
21:43:15 <ski> (you can also say `(function1 . function2) 5')
21:43:19 <lisbeth> I just didn't know if I Needed the parentheses
21:43:38 <ski> you need them for grouping, not for function calls
21:43:38 <ben_vulpes> in a function declaration along the lines of vectplus :: (Num t) => Vector t -> Vector t -> Vector t, what does the (Num t) indicate?
21:44:19 <ski> ben_vulpes : that the function will only work for types `t' that are actually numeric (iow supports the (numeric) operations specified in the type class `Num')
21:44:28 <ben_vulpes> got it.
21:44:31 <ben_vulpes> thanks, ski.
21:44:32 <lisbeth> I am making le fizz buzz
21:44:37 <lisbeth> almost done
21:44:49 <ski> ben_vulpes : .. incidentally, one can actually say `vectplus :: Num t => Vector t -> Vector t -> Vector t', here
21:48:38 <lisbeth> lol how do I comment?
21:49:01 <ben_vulpes> thanks again, ski.
21:49:46 <jTT> johnw: I can’t find foldlCE etc on hoogle, where would I look up those funcitons?
21:49:51 <zq> @lyah
21:49:51 <lambdabot> Unknown command, try @list
21:49:59 <zq> !lyah
21:51:11 <ski> @where lyah
21:51:11 <lambdabot> http://www.learnyouahaskell.com/
21:51:15 <zq> lisbeth: http://learnyouahaskell.com/chapters this one is really nice
21:51:42 <lisbeth> that's the one I am using
21:51:45 <jTT> johnw: nvm got it, cheers
21:52:00 <lisbeth> but I got to number 3 and have gotten too confused so I am trying to code some simple things like fizzbuzz to get used to the syntax
21:54:26 <johnw> jTT: sorry, was away
21:54:54 <jTT> johnw: np, i was over eager and didnt search carefully atfirst
21:54:55 <zq> lisbeth: well anyway, comments are prefixed by "-- " ah la "#" in haskell
21:54:58 <zq> a la*
21:55:34 <johnw> does anyone have experience working with multi-sorted term algebras?  I'm trying to encode the State monad using signatures and am hitting some snags
21:55:52 * hackagebot hosc 0.15 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.15 (RohanDrape)
21:55:59 <zq> in python*
21:56:06 <zq> i should stop typing
21:56:40 <lisbeth> can I do:
21:57:06 <lisbeth> function [[1,2],[3,4] = "hello"
21:57:33 <lisbeth> forgot a ]
21:57:58 <johnw> yes, the question is whether it means what you want it to mean
21:59:01 <ski> > let function [[1,2],[3,4]] = "hello" in function (tail [[5,0],[1,2],[3,4]])
21:59:02 <lambdabot>  "hello"
21:59:19 <ski> > let function [[1,2],[3,4]] = "hello" in function (tail [[4,0],[1,2],[3,5]])
21:59:21 <lambdabot>  "*Exception: <interactive>:3:5-36: Non-exhaustive patterns in function function
22:00:08 <ski> johnw : hm ?
22:00:45 <ski> johnw : do you mean using GADTs ?
22:00:52 <lisbeth> I don't seem to be able to let a variable be a nested list in my gchi
22:00:53 * hackagebot hsc3 0.15 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.15 (RohanDrape)
22:00:55 * hackagebot hsc3-db 0.15 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.15 (RohanDrape)
22:01:00 <johnw> I assumed he just meant pattern matching
22:01:03 <johnw> oh
22:01:07 <johnw> yeah
22:01:16 <johnw> function : [[Int]] -> [Char]
22:03:42 <ski> johnw : sorry, i meant re your "multi-sorted term algebras" question
22:03:52 <johnw> oh
22:03:55 <johnw> yeah, it's using GADTs
22:04:04 <johnw> I'm not working on them in Haskell, but it should translate well enough
22:04:09 <jle`> lisbeth: let a variable be a nested list?
22:04:16 <jle`> > let x = [1,2,3] in x
22:04:18 <lambdabot>  [1,2,3]
22:04:27 <lisbeth> eh it's not important right now
22:04:30 <jle`> > let x = [[1,2],[3,4]] in x
22:04:32 <lambdabot>  [[1,2],[3,4]]
22:04:32 <jle`> ?
22:04:39 <ski> @let lisbethVariable = [[],[0],[1,2],[3,4,5],[6,7,8,9]]
22:04:41 <lambdabot>  Defined.
22:04:51 <ski> > concatMap reverse lisbethVariable
22:04:53 <lambdabot>  [0,2,1,5,4,3,9,8,7,6]
22:05:30 <lisbeth> Here's my first haskell program, buggy and all: http://sprunge.us/RDfE
22:05:52 <jle`> isZero = (== 0)
22:05:53 * hackagebot hsc3-dot 0.15 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.15 (RohanDrape)
22:05:55 * hackagebot hsc3-forth 0.15 - FORTH SUPERCOLLIDER  http://hackage.haskell.org/package/hsc3-forth-0.15 (RohanDrape)
22:05:57 * hackagebot hsc3-lisp 0.15 - LISP SUPERCOLLIDER  http://hackage.haskell.org/package/hsc3-lisp-0.15 (RohanDrape)
22:05:59 <jle`> or isZero = (==) 0
22:06:21 <jle`> or just isZero x = x == 0 :)
22:06:39 <lisbeth> jle` are you saying that will output true if it is zero?
22:06:42 <jle`> iszero (mod3 x) ... why not just (x `mod` 3) == 0 ?
22:06:49 <jle`> lisbeth: do you know about partial application?
22:06:54 <lisbeth> no
22:07:08 <lisbeth> getting there
22:07:10 <lisbeth> baby steps
22:07:10 <jle`> ah
22:07:20 <jle`> then you can understand the third one, right?
22:07:29 <jle`> > let isZero x = x == 0 in isZoer 10
22:07:31 <lambdabot>  Not in scope: ‘isZoer’
22:07:31 <lambdabot>  Perhaps you meant one of these:
22:07:31 <lambdabot>    ‘isZero’ (line 1), ‘isLower’ (imported from Data.Char)
22:07:35 <lisbeth> I think so
22:07:36 <lisbeth> yeah i do
22:07:46 <lisbeth> that will result to true if mod 3 = zero
22:08:00 <lisbeth> thus making it a fizz number
22:08:01 <jle`> but why don't you just say (x `mod` 3) == 0 ?
22:08:13 <lisbeth> Because I didn't think of that. It's my first program.
22:08:17 <jle`> ah :)
22:08:18 <lisbeth> At least in haskell anyway.
22:08:28 <jle`> well, either way is good :)
22:08:53 <jle`> (== 0) is called "section" syntax.  it's a function "waiting" for a number to go on the left hand side
22:09:03 <jle`> :t (== 0)
22:09:04 <lambdabot> (Num a, Eq a) => a -> Bool
22:09:12 <jle`> > let isZero = (== 0) in isZero 10
22:09:15 <lambdabot>  False
22:09:20 <Lutin`> Similarly with:
22:09:23 <jle`> but you'll get there eventually :)
22:09:29 <Lutin`> :t mod 3
22:09:30 <lambdabot> Integral a => a -> a
22:09:32 <jle`> > (== 0) 4
22:09:33 <lambdabot>  False
22:10:16 <Lutin`> > (mod 3) 4
22:10:17 <lambdabot>  3
22:10:33 <ski> > map (== 0) [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0]
22:10:34 <lambdabot>  [True,False,False,True,False,True,True,False,False,True,True,False,True,Fals...
22:10:53 * hackagebot hmt 0.15 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.15 (RohanDrape)
22:11:00 <ski> > map (mod 3) [0 ..]
22:11:01 <lisbeth> oh map
22:11:01 <lambdabot>  [*Exception: divide by zero
22:11:02 <lisbeth> that'll be useful
22:11:08 <ski> > map (mod 3) [1 ..]
22:11:09 <lambdabot>  [0,1,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
22:11:16 <ski> > map (`mod` 3) [1 ..]
22:11:17 <Lutin`> Ah good point
22:11:18 <lambdabot>  [1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2...
22:12:05 <Lutin`> Also someone should make a comment on how pattern matching works
22:12:09 <lisbeth> here's what I have with your improvement. http://sprunge.us/JWfi
22:12:10 <ski> > map (mod 3) [0 .. 9]      :: [Expr]
22:12:11 <lambdabot>  [3 `mod` 0,3 `mod` 1,3 `mod` 2,3 `mod` 3,3 `mod` 4,3 `mod` 5,3 `mod` 6,3 `mo...
22:12:12 <Lutin`> I'm too tired to form a sentence lol
22:12:15 <ski> > map (`mod` 3) [0 .. 9]      :: [Expr]
22:12:17 <lambdabot>  [0 `mod` 3,1 `mod` 3,2 `mod` 3,3 `mod` 3,4 `mod` 3,5 `mod` 3,6 `mod` 3,7 `mo...
22:13:15 <ski> lisbeth : instead of `int' and `bool', you presumably want `Int' and `Bool'
22:13:45 <lisbeth> I see. You're right, ski
22:13:47 <lisbeth> thanks
22:14:02 <ski> lisbeth : and instead of `fbgen :: Int', i think you need `fbgen :: Int -> [Bool]'
22:14:34 <lisbeth> right again
22:14:36 <ski> since `fbgen' looks like a function that will accept `Int's as inputs, and produce `[Bool]'s (iow lists of booleans) as outputs
22:15:01 <ski> for `fbident', you seem to want the result type to be `String'
22:15:18 <lisbeth> no I want it to be a bool
22:15:37 <lisbeth> a list of two bools is much smaller than a string containing "fizz" "buzz" or "fizzbuzz"
22:15:40 <jle`> a lot of times the compiler will catch these errors for you :)
22:15:42 <ski> well, it looks like it's meant to accept lists of booleans as *input*
22:15:57 <ski> however, the *output* looks like you want it to be of type `String'
22:16:05 <lisbeth> I haven't learned to understand the compiler's output yet
22:16:12 <lisbeth> though I suppose I will in time
22:16:21 <ski> the input type goes before the `->', the output type after
22:16:28 <ski> compare with `fbgen :: Int -> [Bool]'
22:16:33 <lisbeth> I have that line now as:
22:16:44 <lisbeth> fbgen :: Int -> [Bool]
22:16:52 <ski> ok
22:17:10 <lisbeth> I think the topmost 3 lines are messing it up
22:18:25 <ski> lisbeth : anyway, in `fbident', you (unfortunately) can't use `fizz' and `buzz' and `fizzbuzz' as pattern synonyms (iow to the left of the `='s) like you seem to want to do
22:18:55 <ski> (it'd work in Mercury ..)
22:18:55 <lisbeth> is there no way to put a variable there?
22:20:13 <ski> lisbeth : you can, if you use the language extension described at <https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-synonyms> ..
22:20:45 <ski> lisbeth : however, nothing is stopping you from saying
22:20:53 <augur> ski: incoming!
22:21:02 <ski>   fbident [True ,True ] = "Fizzbuzz \n"
22:22:13 <Lutin`> lisbeth: So in standard haskell, the left hand side of the equation is used to match on the 'pattern' of data that you pass to it
22:22:24 <Lutin`> specifically the constructors that build up that data
22:22:49 <lisbeth> Here's my most recent version: http://sprunge.us/FeHb
22:22:55 <lisbeth> so we're on the same page
22:23:33 <Lutin`> Let's inspect the type of map:
22:23:36 <Lutin`> :t map
22:23:37 <lambdabot> (a -> b) -> [a] -> [b]
22:23:58 <ski> lisbeth : as Lutin` is explaining, variables in patterns are all assumed to be *new* variables, matching *any* corresponding input, not connected to any variable definitions you might have made otherwhere with the same variable name
22:24:20 <Lutin`> So map takes a function from some type `a` to some type `b` and applies it to a list containing elements of type `a`
22:24:44 <ski> lisbeth : btw, `String' is a "shorthand" for `[Char]'
22:25:04 <ski> > map length ["String","[Char]"]
22:25:04 <Lutin`> At first you can think of this as a function that takes multiple arguments, but as you learn more haskell you'll realize that it's not quite the case
22:25:05 <lambdabot>  [6,6]
22:25:52 <Lutin`> And it's this little distinction that lets us do things like `f = map length`
22:25:54 * hackagebot hsc3-lang 0.15 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.15 (RohanDrape)
22:26:44 <Lutin`> (every function in haskell actually just takes one parameter and returns something, and that something can be a function! We call this currying)
22:26:49 <lisbeth> How to I change the bottom-most line so fizzbuzz is fed an integer 100 times starting from 1 and ending at 100?
22:26:50 <Lutin`> After Haskell Curry :)
22:27:26 <Lutin`> So in this case `fizzbuzz :: Int -> [Char]`
22:27:32 <lisbeth> I've done that
22:27:42 <Lutin`> So if you look at the type signature of map
22:27:44 <Lutin`> :t map
22:27:45 <lambdabot> (a -> b) -> [a] -> [b]
22:27:54 <Lutin`> You'll see you want to pass that to it first
22:28:01 <Lutin`> so `map fizzbuzz [1..100]`
22:28:09 <lisbeth> aha
22:28:21 <Lutin`> In this case a ~ Int and b ~ [Char]
22:28:31 <nhjk> best haskell book?
22:28:46 <lisbeth> what does naked expression at the top level mean?
22:28:59 <ski> nhjk : i dunno, but some people like LYAH
22:29:03 <ski> @where LYAH
22:29:03 <lambdabot> http://www.learnyouahaskell.com/
22:29:18 <lisbeth> that's what I am reading
22:29:20 <Lutin`> lisbeth: It means you have an expression that isn't being equated to anything
22:29:36 <Lutin`> in this case `map fizzbuzz [1..100]`
22:29:42 <jle`> do you know what the difference between an expression and a declaration is?
22:29:54 <lisbeth> no
22:29:58 <jle`> an expression is something like 1, (3 + 3), map even [1..2]
22:30:06 <jle`> things that evaluate to values
22:30:10 <jle`> data?
22:30:27 <jle`> another expression is something like let x = 3 in x + 5
22:30:29 <jle`> which evaluates to 8
22:30:40 <jle`> a declaration is a definition/declaration of something
22:30:48 <lisbeth> I understand, now
22:30:51 <jle`> like, foo = 3; f x = x + 5
22:30:54 <jle`> those two things
22:30:55 <lisbeth> yep
22:31:03 <jle`> so at the top level of a file, you can't have any expressions
22:31:11 <jle`> what would that even mean, anyway?
22:31:21 <Lutin`> lisbeth: Do you know any other languages?
22:31:28 <lisbeth> Bash and a little C++
22:31:36 <lisbeth> my topmost line is : fbgen :: Int -> [Bool]
22:32:30 <jle`> ah, we mean top level as in...like, its own part/line of the file
22:32:58 <lisbeth> ok...
22:33:03 <jle`> a file can only contain a bunch of declarations.  and some other stuff
22:33:17 <lisbeth> not expressions?
22:33:32 <jle`> the expressions are used to help define the declarations
22:33:37 <Lutin`> Like you couldn't just have `3 + 5` in the file because that would be at the top-level, but you can have `x = 3 + 5` because now the declaration is at the top-level and the expression is one below
22:33:51 <jle`> mod5 :: Int -> Int
22:34:00 <jle`> mod5 x = x `mod` 5
22:34:07 <jle`> that's a declaration for the function "mod5"
22:34:26 <jle`> and you use an expression, (x `mod` 5), as a part of the declaration
22:34:35 <lisbeth> so how do I get to the point where I can use the expression "map fizzbuzz [1..10]"
22:34:38 <lisbeth> I mean 100
22:34:44 <jle`> x `mod` 5 floating off all the way over by itself doesn't have any meaning
22:35:07 <jle`> ah.  well, you can load your file up on ghci and then type it up yourself
22:35:19 <lisbeth> oh I get it
22:35:22 <jle`> or you can name a special object that will be executed when your file is compiled
22:35:35 <jle`> compiled and run
22:35:36 <lisbeth> so the expression basically has to be in a shell
22:35:47 <jle`> main = print (map fizzbuzz [1..10])
22:35:52 <jle`> main :: IO ()
22:36:25 <Lutin`> GHCi is what we call a REPL which stands for Read-Eval-Print-Loop
22:36:29 <jle`> that says, "I have an IO instruction object, (print (map fizzbuzz [1..10])).  it's an IO instruction that represents printing out all the items in that list"
22:36:53 <jle`> when ghc compiles a file, it looks for an IO instruction object that is named "main", and then compiles it into an executable/bytecode
22:36:57 <lisbeth> ok now I am getting somewhere
22:37:05 <jle`> and then that bytecode, you can execute
22:37:21 <Lutin`> If you give it a string "map fizzbuzz [1..10]" it reads that string as haskell code, evaluates it, and prints it, then starts the process over again
22:37:30 * ski calls GHCi an interactor
22:37:49 <lisbeth> I don't want to worry about all that stuff just yet
22:37:50 <Lutin`> So you can kind of think that it's doing exactly what jle` said, but with everything you give it
22:37:56 <Lutin`> Alright, no problem
22:37:57 <lisbeth> I'll just run the expression in ghci
22:38:08 <lisbeth> I just want code that WORKS to begin with
22:38:23 <ski>   test0 = map fizzbuzz [1 .. 100]
22:38:33 <ski> then you can type just `test0' in the interactor
22:38:49 <lisbeth> or I can just type map fizbuzz [1..100]
22:39:21 <Lutin`> Yep
22:39:25 <Cale> Everyone is inventing new terminology tonight :)
22:39:32 <Lutin`> hehe
22:39:50 <johnw> new term: Calification
22:40:02 <lisbeth> The problem with learn you haskell is that it doesn't give you optional programming projects to do along the way
22:40:04 <johnw> "making anything obscure seem easier to understand"
22:40:09 <lisbeth> before teaching you LOTS of stuff
22:40:26 <Cale> lol, I guess the emphasis there is on "seem"
22:40:41 <jle`> lisbeth: you can have a bunch of IO instruction objects in your file, named a whole bunch of different things.  but when GHC is called on a file, it finds the IO object named "main", and compiles that to bytecode
22:40:56 <jle`> in this case ghci is probably the simplest way, though :)
22:41:13 <Cale> Uh, usually GHC compiles to native code rather than bytecode
22:41:22 <lisbeth> can I have more than what is contained in main?
22:41:26 <jle`> ah, native code
22:41:32 <jle`> lisbeth: you can define as many things as you want
22:41:40 <jle`> go crazy with it
22:41:41 <Lutin`> Cale: Well native code is represented with bytes amirite? :P
22:41:44 <lisbeth> ok
22:41:53 <jle`> but it'll only compile the IO object that is named `main`
22:42:04 * ski . o O ( native bytecode )
22:42:22 <Cale> Yeah, though usually when people say 'bytecode', they mean something which specifically isn't the host architecture's instruction set, and is intended to be interpreted
22:42:25 <Lutin`> lisbeth: You can think of how in C++ if you want to run a program you need to define the main() function
22:42:28 <jle`> and if main = print (map fizzbuzz [1..100]), then it'll compile a program that prints out the result of map fizzbuzz [1..10] :)
22:42:31 <Lutin`> Cale: Yeah I know it was /s
22:42:46 <jle`> ta da!
22:42:59 <lisbeth> http://sprunge.us/DOXa is my current code
22:43:16 <jle`> if you have a declaration notmain = putStrLn "hello", then notmain will be declared as representing a program that prints out "hello"
22:43:20 <jle`> and that's nice and all
22:43:22 <jle`> good for you
22:43:28 <jle`> but ghc will only compile the IO instruction object named `main`
22:43:30 <lisbeth> Lutin, oh so I can have multiple lines of instruction in main
22:43:39 <lisbeth> I was confused because I thought I could have only one
22:43:47 <jle`> well, you can only have one
22:43:55 <jle`> but haskell lets you combine IO instructions
22:43:58 <Lutin`> lisbeth: but you can make one out of several
22:44:05 <jle`> or well, the IO type is a nice type
22:44:05 <Cale> lisbeth: You can use do-notation to combine IO actions into larger ones
22:44:09 <jle`> that lets you combine IO instructions
22:44:10 <ski> lisbeth : a single definition can span multiple lines
22:44:26 <jle`> putStrLn "hello" is an IO instruction, putStrLn "world" is an IO instruction
22:44:26 <Cale> Usually people say "IO actions" rather than "IO instructions", but that's fine too, I guess.
22:44:28 <ski> lisbeth : latter lines have to be indented more than the first line, though
22:44:28 <jle`> both of type IO ()
22:44:31 <lisbeth> ok
22:44:41 <jle`> and i have this handy function (>>) :: IO a -> IO b -> IO b
22:44:45 <lisbeth> can you help me figure out why I am getting the output I am getting?
22:44:48 <jle`> that takes two IO ()'s and turns them into one big IO ()
22:45:00 <lisbeth> It's going to the fourth condition of fbident every time
22:45:10 <jle`> so...putStrLn "hello" >> putStrLn "world" :: IO (), is a program that represents doing one after the other
22:45:17 <Lutin`> lisbeth: Not every time
22:45:31 <Lutin`> Notice the third one is "Fizz \n"
22:45:40 <lisbeth> ah
22:46:02 <lisbeth> well before fixing anything I need to know how to newline which I can just google
22:46:10 <Cale> lisbeth: One thing which might be useful is to add a parameter to fbident which is a String to use in what is currently your "error" case.
22:46:28 <Cale> lisbeth: So then you could pass show x :)
22:46:39 <jle`> so if you wanted to make your program print out "hello!" and then print out your fizzbuzz, you can say printfizzbuz = print (map fizzbuzz [1..100])); printhello = putStrLn "hello"; main = printhello >> printfizzbuzz
22:47:08 <lisbeth> meh my brain is getting fried
22:47:10 <jle`> `main` can only be one IO object.. but using the combinators on the IO type, we can merge and fuse together other IO objects into one big one
22:47:15 <ski> lisbeth : instead of `map fizzbuzz [1..100]', try `putStr (map fizzbuzz [1..100])'
22:47:17 <lisbeth> I have to go meet my friend
22:47:38 <lisbeth> I think I am going to put haskell on ice for the night and go back to "learn you haskell" with some fresh eyes in the morning
22:47:47 <lisbeth> Thanks for all your help you guys.
22:47:55 <Lutin`> Always a good idea, someone will be around to help I'm sure
22:48:19 <ddellacosta> I find this article relatively readable, but is it correct?  http://www.science4all.org/le-nguyen-hoang/type-theory/  I don't expect folks to read it all, but for example, is this right? "...why do we need an alternative to set theory? For computational reasons..." etc.
22:48:21 <Lutin`> No problem, always glad to induct a new member into the cul...I mean..
22:48:28 <lisbeth> before I go imma ask again if you guys know anything about making a shell or gnu utils out of haskell
22:48:39 <lisbeth> becuase this may be a different crowd than I asked a few hours ago
22:48:46 <Lutin`> Yep you can get command line arguments
22:48:47 <ddellacosta> lisbeth: I just saw this neat article, maybe related to what you're asking: http://chrisdone.com/posts/shell-conduit
22:48:47 <lisbeth> so far I have:
22:48:47 <lisbeth> https://github.com/chrisdone/hell
22:48:52 <Cale> lisbeth: There are a bunch of packages...
22:48:54 <lisbeth> https://github.com/mzero/plush
22:48:59 <lisbeth> https://github.com/gelisam/hawk
22:49:04 <recursion-ninja>  /quit
22:49:24 <Lutin`> Ah yeah, there's a lot of examples
22:49:31 <lisbeth> I'll give that stuff a read
22:49:36 <Cale> There's also shelly, and I don't know whether HSH is still maintained, but it's an attempt at a similar thing
22:49:45 <lisbeth> I've been told of shelly, I believe
22:49:46 * ddellacosta copies down lisbeth's links
22:49:56 <Cale> http://hackage.haskell.org/packages/search?terms=shell
22:49:58 <ski> ddellacosta : well, typical set theories are quite painful to use in practice. e.g. you have to prove properties don't care about isomorphic ways to express a structure
22:50:00 <Lutin`> lisbeth: Some of those might be a little much at first
22:50:05 <Cale> ^^ there are lots of relevant things there :)
22:50:15 <Lutin`> lisbeth: But all in due time
22:50:19 <lisbeth> basically I want to write something like ghc that is a shell
22:50:28 <lisbeth> and that has something similar to the gnu coreutils
22:50:28 <ddellacosta> ski: okay, thanks. Mostly I just want to make sure I'm not getting a lot of wrong ideas from reading that article, because there's a lot of great information there I think.
22:50:54 <lisbeth> I'll probably steal alot from other people's shells
22:51:18 <lisbeth> The main thing is I don't want to add any additional syntax to haskell
22:51:29 <lisbeth> It should just be able to run ontop of ghci if you want
22:51:47 <lisbeth> I was thinking today about a hypothetical linux kernel written in haskell
22:52:05 <lisbeth> and a hypotheticall systemd written in a "subshell" of the kernel
22:52:21 <Cale> lisbeth: Have you heard of House?
22:52:21 <lisbeth> something like that
22:52:24 <lisbeth> no
22:52:26 <Lutin`> hehe
22:52:29 <simpson> House is a thing.
22:52:36 <lisbeth> my story goes on though
22:52:39 <Arahael> lisbeth: More productive, probably, would be to write a new OS that happens to use the kernel. Ie, write your own init for it.
22:52:48 <lisbeth> the only way to talk to the kernel is through ports that are opened and closed by init
22:52:51 <Cale> http://programatica.cs.pdx.edu/House/
22:52:59 <lisbeth> so init owns everything run below init
22:53:36 <Cale> (Why does my clipboard seem more unreliable than ever in linux lately? I have to go back and mash Ctrl-C over and over before something actually ends up in the clipboard it seems.)
22:53:45 <lisbeth> if a program below init launches another program in a "subshell" it can only talk to systemd through ports in the process above
22:53:52 <Lutin`> Cale: Wait you mean that's not just me?
22:54:01 <lisbeth> lastly, every program under the same program can talk to each other through ports
22:54:11 <lisbeth> and that is my idea. not sure if it is even a good one
22:54:12 <Lutin`> I thought it was something to do with my keyboard or my finders...
22:54:15 <Lutin`> fingers*
22:54:26 <lisbeth> yeah I probably couldn't use systemd, you are correct
22:54:33 <ddellacosta> (Cale, Lutin`: for what it's worth I get that in Mac OS X too a fair bit too)
22:54:34 <lisbeth> but some kind of init in haskell
22:54:43 <simpson> lisbeth: Hm. How would you kill processes?
22:54:43 <lisbeth> where programs communicate with each other through ports
22:54:56 <Lutin`> Cale, ddellacosta: What browser?
22:54:57 <lisbeth> you have to have a permission from a process higher than you are
22:55:04 <ddellacosta> Lutin`: FF
22:55:05 <lisbeth> any process higher than you are, in fact
22:55:05 <Lutin`> I've only really noticed it with firefox
22:55:09 <ddellacosta> aha
22:55:10 <Lutin`> No issues with Chrome
22:55:30 <lisbeth> You can send instructions asking for the process to kill your neighbor
22:55:32 <lisbeth> but it might not want to
22:55:53 <Cale> I'm using Chrome and I have issues. I usually would use my primary, but now it seems like Chrome won't put selected text from the URL bar into the primary, instead, it just blanks the primary.
22:55:54 <simpson> lisbeth: Sure, but how do you decisively kill a program that is hogging resources?
22:56:12 <lisbeth> I think that would be controlled by init
22:56:20 <lisbeth> init would have a view of the whole tree
22:56:21 <Cale> and when I ctrl-C, I don't even understand the behaviour... it seems like there's like a 50% chance that it actually copies something
22:56:36 <lisbeth> Cale, right click and click copy then click paste
22:56:50 <lisbeth> Cale, ctrl+c does weird things in terminal emmulators
22:56:56 <zq> what's with your obsession with ports?
22:56:59 <Arahael> Cale: MOdenr browsers seem to do seriously funky stuff when you switch between windows, so beware of that too.
22:57:03 <Cale> Yeah, this isn't in a terminal emulator, this is in my web browser
22:57:06 <lisbeth> I want it to work like containers
22:57:08 <Lutin`> Cale: What WM?
22:57:13 <Cale> Cinnamon
22:57:22 <Lutin`> Ah alright, I'm in i3
22:57:28 <lisbeth> A program has to ask permission from all the processes above it to put something in ram
22:57:33 <lisbeth> maybe
22:57:34 <lisbeth> not sure
22:57:42 <lisbeth> it was just random thinking. Again, I am not sure it would be a good idea
22:58:10 <lisbeth> But I think ports are a good way to control security
22:58:13 <Cale> lisbeth: I think it would be really cool to do something with the unix philosophy, but with a better type system.
22:58:30 <Arahael> lisbeth: You're using different names for the concepts, but it almost sounds like you're reinventing Plan9. ("The way the future was")
22:58:44 <lisbeth> could you guys send me links to house and plan9?
22:59:02 <Cale> I linked house above ( http://programatica.cs.pdx.edu/House/ )
22:59:11 <Cale> Also, let me dig up one other thing
22:59:33 <lisbeth> oh cool
22:59:59 <lisbeth> The only problem is I don't just want to work in a shell, so I'd have to get x and at least something like openbox running
23:00:01 <Cale> https://www.youtube.com/watch?v=faJ8N0giqzw
23:00:02 <Arahael> lisbeth: https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs
23:00:21 <Lutin`> getty 4 life
23:00:23 <lisbeth> ooh bell labs
23:00:25 <lisbeth> I know that name
23:00:33 <Cale> ^^ this is a talk by Conal Elliott about Tangible Values
23:00:43 <lisbeth> lets hope all this stuff you're sending me is GPL2 or similar
23:00:48 <Cale> which isn't *quite* the sort of thing you're talking about
23:00:57 <Cale> but it's sort of related :)
23:01:06 <Arahael> lisbeth: What's so good about GPL2?
23:01:14 <lisbeth> I just personally like it
23:01:30 <lisbeth> I don't want to start a flame war
23:01:32 <ddellacosta> lisbeth: Rob Pike may ring a bell (*ahem*), he was involved in Plan 9 dev
23:01:43 <Cale> lisbeth: You'll find most Haskell-related stuff is BSD3 licensed
23:01:54 <lisbeth> I have never heard of any of the projects I Just linked or you linked in the past 10 mins
23:02:02 <lisbeth> I am going to read up about all of them later
23:02:04 <lisbeth> probably tomorrow
23:02:28 <Arahael> lisbeth: If you're going to write an OS, kernel, or shell, I highly recommend you read the previous attempts.
23:02:38 <lisbeth> yep
23:02:44 <lisbeth> I probably will never rewrite the kernel
23:02:55 <Arahael> lisbeth: You _will_ never rewrite the kernel.
23:02:58 <lisbeth> maybe just my own simple init and the GNU coreutils
23:03:12 <lisbeth> let me rephrase that
23:03:19 <lisbeth> I will probably never write A kernel
23:03:26 <lisbeth> :)
23:03:40 <lisbeth> I just don't like the way bash is
23:03:52 <Arahael> lisbeth: Have you tried other shells?
23:04:02 <Arahael> lisbeth: Perhaps move this to #haskell-blah?
23:04:10 <lisbeth> no but I feel like I'd want one that works like haskell
23:04:18 <lisbeth> I know I won't want zshell
23:04:52 <Lutin`> oh god I can see it now
23:04:58 <Lutin`> a terminal full of GHC errors
23:05:03 <Arahael> lisbeth: YOu mean, something along the lines of: https://duckduckgo.com/?q=pure+functional+shell
23:05:06 <Lutin`> I'll never be able to escape
23:05:11 <zq> what's wrong with bash? bash is cool
23:05:31 <Arahael> zq: What's good about it?
23:05:42 <zq> it's old. it's everywhere.
23:05:47 <lisbeth> I like bash for everything except piping
23:05:52 <thebnq> cool isn't good
23:06:14 <lisbeth> I like to do everything through piping so not only would I have to write all my functions to accept stdin, but I would have to avoid alot of the gnu coreutils because they don't accept stdin
23:06:14 <Arahael> zq: I wish that everyone used dash or other stupid shell as the default system shell. (shellshock should never have happened)
23:06:24 <lisbeth> so I end up having to use xargs which is a mess
23:06:41 <Arahael> lisbeth: You probably want to look at powershell, though that's MS-only.
23:06:49 <lisbeth> nothanks
23:06:53 <lisbeth> linux is love linux is life
23:06:57 <zq> what's wrong with piping?
23:07:00 <Arahael> lisbeth: No, seriously - MS does some good things.
23:07:01 <zq> piping is functional!
23:07:01 <Cale> lisbeth: Just before I got into Haskell, I actually wrote an entire IRC bot which was effectively one long shell pipeline with the ends tied together using a FIFO
23:07:19 <Cale> lisbeth: It was kind of difficult to maintain, but it worked :)
23:07:30 <lisbeth> Arahael, I know I am just not a windows person
23:07:40 <lisbeth> my dad is a project manager at microsoft. Believe me, I have given windows a fair chance.
23:08:10 <Arahael> lisbeth: For a programmer, "windows" == '.net'.
23:08:30 <lisbeth> I don't want to run windows so I can get powershell, but thanks for the offer.
23:09:39 <lisbeth> Is this the main english channel for haskell in the world?
23:09:54 <Lutin`> This is the main channel for haskell in the world
23:10:04 <lisbeth> cool
23:10:08 <lisbeth> Hello World.
23:11:08 <lisbeth> This is the video that made me want to program in bash the way you program in haskell: https://www.youtube.com/watch?v=tc4ROCJYbm0
23:13:43 <ddellacosta> lisbeth: that's awesome, I love the pose the first dude is in
23:13:51 <ddellacosta> lisbeth: he also seems kinda stoned
23:14:17 <lisbeth> When I watch this, now, it becomes obvious to me that haskell can do what they want better than bash can
23:15:30 <Arahael> Where do I find the reserved words in haskell?
23:15:40 <Arahael> It seems that 'class' and 'data' are reserved?
23:16:05 <Lutin`> http://www.haskell.org/haskellwiki/Keywords
23:16:12 <jle`> @google reserved words haskell
23:16:12 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
23:16:13 <lambdabot> Title: Keywords - HaskellWiki
23:16:44 <Arahael> Cool. :)
23:17:20 <jle`> it looks like it might be missing some
23:17:46 <jle`> `pattern` is a reserved word of PatternSynonyms is on
23:17:51 <ski> Arahael : `data',`type',`newtype',`deriving',`let',`in',`where',`if',`then',`else',`case',`of',`do',`class',`instance',`infix',`infixl',`infixr',`default'
23:18:34 <Arahael> ski: Thanks :)  Haskell's a very weird place for me, still getting used to it.
23:18:48 <ski> for FFI, there's also `foreign'
23:18:50 <ddellacosta> is "otherwise" not reserved?
23:18:56 <jle`> nope
23:19:01 <ddellacosta> I guess that's contextual
23:19:03 <johnw> otherwise = True
23:19:06 <ddellacosta> ah, okay
23:19:10 <ski> Arahael : oh, also the module ones : `module',`import'
23:19:12 <jle`> otherwise is just a normal variable binding
23:19:15 <jle`> @src otherwise
23:19:15 <lambdabot> otherwise = True
23:19:16 <Arahael> ddellacosta: I thought 'otherwise' was just a convention.
23:19:21 <ddellacosta> oh, didn't realize, okay
23:19:33 <jle`> yeah, you could always do | True = ..., but | otherwise = ... is just for kicks
23:19:39 <dfeuer> otherwise is unfortunate
23:20:00 <ddellacosta> jle`: gotcha.  I thought I saw it in some papers, and assumed it was mimicking mathematical conventions
23:20:06 <johnw> why is it unfortunate?
23:20:14 <Lutin`> Alright time for bed, night everyone
23:20:17 <jle`> yeah, it's there just to make guards look like mathematical conventions :)
23:20:18 <dfeuer> Because now that it *is* convention, it's hard to avoid, and it's bad because it's often too long.
23:20:21 <ddellacosta> Lutin`: 'night
23:20:30 <ddellacosta> dfeuer: ah, yeah, it is kinda long
23:20:32 <ski> > case False of otherwise | 1 > 2 -> "yes" | otherwise -> "no"
23:20:34 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
23:20:35 <jle`> otherwise is kinda long but i've never really minded it
23:21:55 <ski> Arahael : as jle` mentioned, some extensions enable auxilary keywords
23:22:04 <dfeuer> I think it would be funny to have boolean operators with unspecified short-circuiting behavior. They'd have names like andIGuess and orYeahMaybe
23:22:33 <Lutin`> dfeuer: Perfect unsafePerformIO usecase :)
23:22:35 <jle`> never = False
23:22:37 <Lutin`> haha
23:22:49 <Arahael> ski: Eh?
23:22:50 <jle`> | never -> launchMissiles
23:23:08 <Lutin`> let never = True in ...
23:24:08 <ski> > let qualified as = (as,as); export x f = f x in export () qualified
23:24:11 <lambdabot>  ((),())
23:24:39 <jle`> sometimes = unsafePerformIO randomIO :: Bool
23:24:45 <ski> Arahael : e.g. `forall',`rec'
23:25:08 <dfeuer> sometimes sounds like something from some sort of weird logic.
23:25:11 <jle`> maybe `perhaps` is a better word, because the bool is fixed the first time it is evaluated
23:25:46 <Lutin`> Arahael: If you feel like finding out by hand.. http://www.haskell.org/onlinereport/
23:27:45 <Arahael> Lutin`: I'm currently going through both Real World Haskell, and bitemyapp's list of urls for learning Haskell.
23:27:51 <Lutin`> Specifically
23:27:53 <Lutin`> http://www.haskell.org/onlinereport/lexemes.html#sect2.4
23:29:36 <jTT> johnw: hey, are you still around? I am trying out foldlCE but I am failing miserably. May you have a look at this snippet? I am creating a conduit where I expect a filepath, and that works fine. and then i introduce foldlCE and things turn ugly…:https://gist.github.com/jsevo/13e42b066536f8937858
23:32:12 <johnw> jTT: I'm here
23:32:23 <johnw> ugly how?
23:32:45 <jTT> well, I realise I have no clue how to use the result of foldlCE
23:33:12 <johnw> you'll want to await on it and return it as the result of the conduit
23:33:25 <jTT> ok
23:33:41 <johnw> one sec, I think a fold is even a sink
23:34:02 <jTT> i think it can be both sink and conduit
23:34:35 <johnw> right
23:35:19 <jTT> if i try something like this:
23:35:21 <jTT> c <- C.await $ ((sourceFile f) $= foldlCE (\n x -> if True then n + 1 else n) 0)
23:35:21 <jTT>       C.yield c
23:35:34 <jTT> in a do block, it doesnt work
23:35:42 <jTT> gosh, im in over my head here
23:35:58 <johnw> one sec, i need to paly with your code
23:36:12 <johnw> "doesn't work" meaning?
23:36:48 <jTT>     Couldn't match expected type ‘C.ConduitM a0 c0 m1 r0
23:36:49 <jTT>                                   -> C.ConduitM FilePath Int m Int’
23:36:50 <jTT>                 with actual type ‘C.ConduitM i0 o0 m0 (Maybe i0)’
23:38:02 <johnw> what are you wanting to do exactly?
23:38:20 <johnw> for each file, the element is the number of x's in that file?
23:40:20 <jTT> so basically i want to count some characters. here i just return true and don’t actually compare any. But I have a hard time introducing foldlCE as i have just got my head around source, conduit sink and foldlCE introduced Consumer and other things ….i am getting confused
23:40:40 <jTT> The purpose is to go through many files and for each count ‘x’ in the text, yes
23:44:54 <jle`> @pl \f k _ = f k
23:44:54 <lambdabot> (line 1, column 8):
23:44:54 <lambdabot> unexpected "="
23:44:54 <lambdabot> expecting pattern or "->"
23:44:55 <johnw> jTT: I've commented on the gist
23:44:59 <jle`> @pl \f k _ -> f k
23:44:59 <lambdabot> (const .)
23:45:02 <jle`> ew
23:45:28 <jle`> @pl \k _ -> f k
23:45:28 <lambdabot> const . f
23:47:53 <jTT> johnw: thanks a lot! That’ll give me something to work with/understand. Sorry for my inane questions!
23:48:03 <johnw> not at all
23:48:08 <johnw> conduit is tricky when you first encounter it
23:57:23 <johnw> jTT: the reason the lift is needed is that you need to run a different conduit within the parent environment in order to get the value that you want to yield to the primary conduit
23:57:43 <jTT> yeah
23:57:56 <jTT> i can sort of see it, but failed to do it :S
