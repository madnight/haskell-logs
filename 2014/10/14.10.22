00:07:54 <jstolarek> what is the definition of a "free expression" ?
00:08:28 <jstolarek> this is partially related to haskell and partially to lambda calculus
00:14:17 <lsix> jstolarek: do you meen "point free" expressoin ? Like in http://www.haskell.org/haskellwiki/Pointfree ?
00:17:46 <merijn> jstolarek: Are you referring to "free variables"?
00:18:04 <merijn> A "free expression" is a non-sensical term in the lambda calculus
00:18:15 <loudno15e5> my old professor made us learn the esoteric Miranda programming language and i was wondering if there are any good tutorials to transfer this knowledge into Haskell as i know they are similar?
00:19:36 <merijn> Gentle Introduction, perhaps?
00:19:49 <mayski> skim through LYAH and you'll probably be like ok that's that
00:19:51 <tdammers> loudno15e5: I'd just pick up the usual suspects... Gentle Intro, LYAH...
00:20:15 <tdammers> loudno15e5: beyond that, just install ghc and get cracking :D
00:20:16 <merijn> Don't be misled by the Gentle Intro's name ;)
00:20:27 <merijn> @quote wrestling.bears
00:20:27 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
00:20:34 <ThreeOfEight> I'm wondering whether there's a nice way to write „prop_f m n = f m n == min m n” in pointless style
00:20:35 <loudno15e5> lol gentle as in gentle as a rock
00:21:01 <merijn> loudno15e5: Well, it's a gentle intro "for people who are already comfortable programming in a Hindley-Milner functional language" :p
00:21:06 <mayski> I know not to make that mistake after getting Gentle Intro to Abstract Algebra
00:21:08 <merijn> i.e. ML, but Miranda probably qualifies
00:21:21 <merijn> tbh, I've only ever heard of Miranda, never used it
00:22:05 <loudno15e5> it was so no one could get answers to assignments on stack overflow
00:22:14 <loudno15e5> using miranda that is
00:22:24 <jstolarek> lsix: no, not point free
00:22:26 <jstolarek> merijn: close
00:22:33 <jstolarek> I know what are free variables
00:22:51 <loudno15e5> thanks all for the recomendations
00:23:01 <jstolarek> but several times I've heard about free expressions
00:23:03 <tdammers> nice strategy
00:23:18 <tdammers> if you subscribe to this whole silly game of trying to force people into actually learning stuff
00:23:24 <jstolarek> merijn: for example here www.haskell.org/haskellwiki/Free_expression
00:23:45 <jstolarek> exceptr that i don't trust that definition and would rather see it in a book or something more reliable than a wiki
00:24:42 <loudno15e5> pft learning ;)
00:25:45 <jstolarek> merijn: it might be a nonsensical term in the lambda calculus, but it seems to be used in Haskell when talking about Core optimizations like floating
00:25:59 <merijn> loudno15e5: tbh, I don't think reading LYAH would be a bad idea either. Sure you'll think most of it is "obvious" and slowly paced, but it covers lots of important details and it's nice to occasionally breeze through a textbook in half a day :)
00:27:21 <loudno15e5> merijn: I have to agree with you, its always nice to feel smart lol
00:28:46 <dmj`> half a day is ambitious, but doable if you don't write down the exercises
00:32:17 <merijn> There's exercises in LYAH?
00:33:07 <dmj`> merijn: I meant to say "write out the examples"
01:06:18 <boothead> Morning all. Can anyone comment on the CSP vs ContT? I'm building some stuff in purescript which has ContT and I wonder if I need bindings to some kind of CSP library or if I can build something CSP like in terms of continuations?
01:06:32 <boothead> it feels like they shoudl be equivalent in some way...
01:12:47 <merijn> You can do coroutines using CPS (not to be confused with CSP!) and thus ContT, yeah. So CSP using ContT should be possible
01:12:56 <merijn> Whether it's advisable? I have no opinion
01:46:24 <xpika> can you not load compiled code in ghci on OSX ?
02:09:47 <bitonic> dcoutts: is there a way to have `cabal' just generate the dist/ files used in building?  basically a way to run the `initialBuildSteps' function
02:16:57 <Day_dreamer> hi, where can I find the complete documentation for a given package on hackage ?
02:17:11 <Day_dreamer> for example http://hackage.haskell.org/package/QuickCheck : I only see a short description
02:17:56 <bennofs> Day_dreamer: scroll down, there are links for the documentation of each  QC module
02:19:02 <Day_dreamer> thanks. Is there some kind of tutorial also ?
02:19:24 <Day_dreamer> quite a noob in haskell, some examples would help :p
02:19:36 <bennofs> Day_dreamer: https://ocharles.org.uk/blog/posts/2012-12-08-24-days-of-hackage.html is pretty good
02:20:04 <bennofs> Day_dreamer: there are also 23 other mini-tutorials in that series, worth checking out! :)
02:20:19 <Day_dreamer> thanks !
02:20:45 <Day_dreamer> but on hackage itself, it's up to the developper to put some examples there, right ?
02:21:23 <Day_dreamer> for example, http://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit.html looks nice but I don't see the equivalent for QuickCheck
02:21:54 <bennofs> Day_dreamer: yes.
02:23:03 <bennofs> Day_dreamer: Maybe there should be a link to the 24 days of hackage tutorial
02:24:23 <Day_dreamer> that would be nice
02:26:13 <Day_dreamer> where can I suggest that ? the bug tracker ?
02:35:35 <bennofs> Day_dreamer: I already did: https://github.com/nick8325/quickcheck/pull/29
02:36:43 <Armel`> Hi all! Do you know what's the purpose of the "Line" type in Text.XML.Light? Thanks. :)
02:37:56 <bennofs> Armel`: you mean this type synonym: http://hackage.haskell.org/package/xml-1.3.13/docs/Text-XML-Light-Types.html#t:Line ?
02:39:02 <Armel`> Yep bennofs
02:40:48 <bennofs> Armel`: my guess would be that it represents the line number on which an element / xml-"thing" occured (this is useful for error reporting etc)
02:43:49 <SwashBuckla> hi there. I am trying to install a package with cabal, using the following .cabal file: https://raw.githubusercontent.com/egonSchiele/chips/master/Chips.cabal
02:44:17 <SwashBuckla> however, it has the build-depends: rule of    base==4.6.*  and I have 4.7
02:44:46 <SwashBuckla> is there any way I can run an isolated environment/sandbox with the dependencies I need inside?
02:44:56 <Armel`> bennofs: Hum, of course ! :P Thank you !
02:45:19 <SwashBuckla> something akin to Python's pip
02:45:42 <bennofs> When I have a function f :: m (a,b,c) (where m is a monad and a b c are some concrete types), how can I achieve the following: sometimes, I only need b,c .Then I don't want to execute the effects that are only needed for generating a. Is there an easy way to write this? What type would f need in this case? (I can change f)
02:46:08 <bennofs> SwashBuckla: the problem in this case is that base depends on the GHC version that you have
02:46:17 <bennofs> SwashBuckla: you can probably use hsenv
02:46:34 <SwashBuckla> lambdabot: hsenv
02:46:37 <bennofs> SwashBuckla: https://hackage.haskell.org/package/hsenv
02:47:30 <alpounet> cabal also has sandboxes :)
02:47:33 <bennofs> SwashBuckla: see Advanced Usage "using a different GHC version" (you need 7.8)
02:47:48 <bennofs> alpounet: sandboxes can't sandbox different ghc versions
02:48:00 <alpounet> ah oops, sorry, misread
02:49:08 <SwashBuckla> thanks bennofs
02:49:26 <alpounet> bennofs: you'd need to untangle f into f1 :: m a, f2 :: m b and f3 :: m c, and combine them as needed with (,) <$> f2 <*> f3 for example to get only b and c
02:49:28 <ClaudiusMaximus> bennofs: f :: m (m a, m (b, c))  might do what you want
02:50:01 <bennofs> alpounet: that would require that the actions to compute a happen all before the actions to compute b
02:50:36 <lpaste> SwashBuckla pasted “cabal install hsenv” at http://lpaste.net/113019
02:50:48 <SwashBuckla> bennofs: I am getting the above error
02:51:24 <bennofs> SwashBuckla: oh you're on windows
02:51:26 <alpounet> bennofs: what? you said you didn't want the actions to compute a to be executed, sometimes
02:52:01 <alpounet> maybe if you give a concrete example that'll make things clearer (for me at least)
02:52:09 <bennofs> alpounet: yeah, but imagine this flow:   some effects to compute a >> some effects to compute b >> some effects to compute a >> ....   now I sometimes want to omit the effects to compute a
02:52:41 <bennofs> ok, the usage case is that I have a streaming xml parser and I sometimes don't need to parse all elements
02:52:49 <RchrdB> bennofs: memoize a?
02:53:34 <alpounet> bennofs: can that "need not to parse all elements" be set e.g by a Bool?
02:53:51 * hackagebot fay-text 0.3.1 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.1 (AdamBergmark)
02:53:53 * hackagebot fay-text 0.3.0.2 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.0.2 (AdamBergmark)
02:53:56 * hackagebot fay-text 0.3.0.1 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.0.1 (AdamBergmark)
02:53:58 * hackagebot fay-text 0.3 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3 (AdamBergmark)
02:54:00 * hackagebot fay-text 0.2.0.0 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.2.0.0 (AdamBergmark)
02:54:10 <bennofs> alpounet: no, because the type of f also needs to change (if I don't parse the A part, i cannot return (A,B,C), but only (B,C))
02:55:24 <SwashBuckla> bennofs: any advice? That's from cygwin
02:55:47 <alpounet> bennofs: and 'm' is a parsing monad in your case then i guess?
02:55:47 <bennofs> SwashBuckla: I don't really know how to do it on windows, sorry :/
02:55:52 <bennofs> alpounet: yes
02:56:06 <bennofs> alpounet: rather, it's a conduit whose input is xml events
02:59:02 * hackagebot fay-text 0.1.0.0 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.1.0.0 (AdamBergmark)
03:05:15 <alpounet> bennofs: and running or not running a would mean skipping things in the xml stream?
03:05:59 <bennofs> alpounet: not running means : don't consume the events (the next parser will skip unrelated events anyway), running = consume events and parse them into a datastructure
03:21:43 <Faucelme> join #fp101x
03:23:29 <mosdd> hello
03:24:53 <alpounet> bennofs: hmm, it feels like f should be different depending on whether you want 'a' or not
03:25:03 <alpounet> i mean, it should be a different function
03:25:19 <alpounet> you could have a Bool for "pick a or not" and return 'Maybe a' but it feels clumsy
03:25:46 <mosdd> I have main.hs and foo.hs, which has "Foo" module. I have moved foo.hs to foo/ directory, and now I have to rename the module to "Foo.Foo". is there a way to still keep the module name as just Foo, while retaining the directory structure?
03:27:13 <bergmark> mosdd: you can add another include directive, but i'd not recommend it. I haven't seen anyone else do this
03:27:44 <mosdd> how do I do that? and why isn't it recommended?
03:28:03 <SwashBuckla> hi there. I am getting a similar error to this SO post: https://stackoverflow.com/questions/22792632/setup-exe-bad-header-file-curl-curl-h-haskell   but in my case it is with execvpe.h instead of curl/curl.h
03:28:22 <bergmark> mosdd: i recommend doing what everyone else does because everyone else does it :-)
03:28:38 <mosdd> what does everyone else do? Foo.Bar?
03:29:19 <mosdd> I feel like I am trading one messiness (dumping all the files in the same directory) with another (having module names Foo.Foo)
03:29:51 <bennofs> mosdd: call the foo directory src and then you can add another include directive again (because when you have a src directory, that's what everyone does :D)
03:30:07 <bergmark> the extreme to separate this is to have another package for it
03:30:12 <mosdd> hen I would have src/src ?
03:30:14 <mosdd> hmm
03:30:29 <bennofs> mosdd: I put Main.hs in the top level dir
03:30:48 <bennofs> mosdd: and then the rest all in src/
03:31:13 <bennofs> mosdd: but it seems like you have more than main.hs and Foo.hs in src/ ?
03:31:35 <mosdd> yes. I have a bunch of files related to Foo, then a bunch of files related to Bar module, etc
03:31:59 <bennofs> mosdd: ok, then why not use Foo. and Bar.? That clearly communicates that the module is related to Foo or Bar
03:32:30 <bennofs> mosdd: otherwise, it would be difficult for a reader of your code to find where the source code of a given module is (is it in src/Foo? or src/Bar/?)
03:33:15 <SwashBuckla> setup.exe: Bad header file: execvpe.h
03:33:38 <SwashBuckla> any idea why this happens on `cabal install unix`?
03:33:43 <mosdd> I am the only reader, and it wouldn't be difficult for me.. I agree it would make things clearer in a multi-programmer situation
03:34:40 <bennofs> mosdd: well, assume you look at the code again after 1 year not working on it ... I bet you wouldn't be able to remember where each module lives :)
03:34:42 <mosdd> I wouldn't even have so many source files and modules if I data types could share field names.. can't wait for that feature
03:35:05 <mosdd> I would because they are clearly related
03:36:42 <mosdd> for example: module Site. module OneSitesName. module AnotherSitesName.
03:37:02 <mosdd> Site.Site. SiteOneSitesName. Site.AnotherSitesName doesn't add much to readability
03:51:56 <piskrist> How can I make `Found Hole '_' ...` disappear in result2 `shouldBe` [(Kept _)] ?
03:52:34 <piskrist> is it possible to do here inline or do I need to define function testing the type?
03:52:54 <bennofs> piskrist: you need to write an extra function for testing
03:53:36 <piskrist> it seems to be doable with Kept undefined
03:53:51 <bennofs> piskrist: only if shouldBe only compares the constructors
03:54:10 <bennofs> piskrist: but I think shouldBe will also force the undefined in this case
03:54:44 <bennofs> piskrist: if result2 is Kept someThing, the shouldBe will do: Kept someThing == Kept undefined, and that will force undefined to be evaluated => crash
03:54:46 <piskrist> hm, so it type checks but it seems to behave incorrectly in runtime
03:54:55 <piskrist> right
04:14:00 * hackagebot snmp 0.1.0.1 - API for write snmp client.  http://hackage.haskell.org/package/snmp-0.1.0.1 (chemist)
04:16:14 <boothead> when do the logs of #haskell get published? I asked a Q earlier and then got pulled away and not it's scrolled off the top :-(
04:16:41 <SwashBuckla> pfft. I give up. It's probably not possible to install hsenv on cygwin
04:16:42 <hpc> in the topic: Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent
04:17:33 <capisce> boothead: I don't think anyone answered your earlier Q
04:19:09 <Cale> boothead: What was your question?
04:19:26 <Cale> <boothead> Morning all. Can anyone comment on the CSP vs ContT? I'm building some stuff in purescript which has ContT and I wonder if I need bindings to some kind of CSP library or if I can build something CSP like in terms of continuations?
04:19:26 <Cale> <boothead> it feels like they shoudl be equivalent in some way...
04:19:33 <Cale> That one?
04:19:51 <Cale> hmm
04:20:37 <Cale> It's probably possible, if you don't care about actually taking advantage of hardware parallelism
04:28:13 <shiona> is there some sort of show that does not force its argument?
04:28:53 <shiona> (for teaching/learning evaluation order)
04:29:02 <hpc> in ghci, use :print or sprint
04:29:10 <Cale> shiona: :print in ghci
04:29:16 <hpc> unevaluated thunks are underscores
04:29:24 <hpc> it's a bit weird with [lists]
04:29:35 <shiona> ok, so no way to do this in actual code
04:29:48 <Cale> shiona: No, evaluating an expression doesn't change its value
04:30:03 <shiona> ok
04:30:08 <boothead> Cale, this will be compiled to JS so I wish I could care about that :-)
04:31:18 <Cale> shiona: Of course, from IO there are some things you can do using the GHC API and various libraries built on top of that like vacuum
04:31:27 <Cale> (see especially vacuum-cairo)
04:31:56 <shiona> ok, I'll go take a look
04:34:01 <Cale> Oh, well, vacuum-cairo apparently doesn't have something to use the lazy stuff in vacuum, sadly
04:34:50 <rgr> emacs users - I've installed haskell-mode from the package manager but none of the wiki documented key bindings are working. Im pretty sure they all did on my last outing with haskell 2 years ago. I googled a SO solution which was to "(require 'haskell-indent)" but that doesn't trigger them either. Any ideas or maybe you can share your customised haskell set up?
04:34:54 <Cale> https://hackage.haskell.org/package/ghc-heap-view also looks interesting
04:35:31 <Cale> It's been a while since I've used emacs for Haskell and I never really used the keys anyway
04:35:50 <Cale> Maybe someone else knows what's going on :)
04:36:21 <mads-> Cale: Then what do you use?
04:37:32 <Cale> mads-: Mostly vim
04:37:41 <Cale> Occasionally gobby or just gedit
04:37:57 <bennofs> rgr: do you have haskell-mode installed?
04:38:20 <Cale> I don't really care all that much, as long as there's a little bit of syntax highlighting and it'll convert tabs to spaces automatically
04:39:38 <rgr> bennofs: well, obviously :) "installed haskell-mode from the package manager" :)
04:40:17 <bennofs> rgr: maybe try (require 'haskell-mode) ?
04:40:39 <rgr> I have haskell-mode installed. and working.
04:41:06 <bennofs> rgr: well, haskell-mode should provide C-c C-l (to load file in ghci) etc
04:41:15 <Cale> I did actually take the trouble of installing hdevtools, vim-hdevtools and syntastic a while ago just to see what those are about
04:41:41 <Cale> They're sort of cool, but it's not really life-altering for me
04:42:34 <rgr> yes it should.
04:43:30 <bennofs> rgr: I installed haskell-mode via package-install and it works for me
04:45:01 <joneshf-laptop> is there an applicative/monadic analog to `mconcat`?
04:45:14 <bennofs> joneshf-laptop: sequenceM ?
04:45:17 <bennofs> :t sequenceM
04:45:18 <lambdabot>     Not in scope: ‘sequenceM’
04:45:18 <lambdabot>     Perhaps you meant one of these:
04:45:18 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
04:45:22 <bennofs> :t sequence
04:45:22 <lambdabot> Monad m => [m a] -> m [a]
04:45:34 <bennofs> :t sequenceA -- more general version
04:45:35 <lambdabot>     Not in scope: ‘sequenceA’
04:45:35 <lambdabot>     Perhaps you meant one of these:
04:45:35 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
04:45:39 <bennofs> :t T.sequenceA -- more general version
04:45:40 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
04:45:51 <BoR0> what's T?
04:46:22 <Cale> Data.Traversable
04:46:23 <exio4> it is a qualified import
04:46:25 <bennofs> BoR0: qualified import of Data.Traversable
04:46:32 <BoR0> thanks
04:47:16 <joneshf-laptop> hmm, kind of
04:47:30 <joneshf-laptop> it's still in a context though
04:47:46 <bennofs> alpounet: I found a solution: http://lpaste.net/113026 and it's even nicer than I expected! :)
04:48:19 <joneshf-laptop> mauybe something like :: (Traversable t, Applicative f) => t (f a) -> f a
04:48:35 <joneshf-laptop> is that possible?
04:48:40 <bennofs> :t msum
04:48:41 <lambdabot> MonadPlus m => [m a] -> m a
04:48:45 <bennofs> :t asum
04:48:46 <lambdabot>     Not in scope: ‘asum’
04:48:46 <lambdabot>     Perhaps you meant one of these:
04:48:46 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
04:48:48 <bennofs> :t F.asum
04:48:49 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:48:52 <joneshf-laptop> ah
04:48:53 <exio4> that sounds like a fold
04:49:00 <joneshf-laptop> thanks
04:49:23 <bennofs> joneshf-laptop: that uses Alternative though
04:49:38 <bennofs> joneshf-laptop: what do you think yourFunction [Just 3, Just 4, Just 5] should do?
04:49:54 <alpounet> bennofs: heh that's cute
04:50:57 <joneshf-laptop> bennofs, good question
04:51:33 <bennofs> joneshf-laptop: msum/asum would return Just 3 (but it also returns Just 3 if you had [Just 3, Nothing, Nothing])
04:52:01 <bennofs> joneshf-laptop: sequenceA would return Just [1,2,3], and return Nothing if you had [Just 3, Nothing, Nothing]
04:53:46 <joneshf-laptop> bennofs, what i'm wanting is sometime similar to `traverse` but that takes like a list of functions and applies it to just one thing :: [a -> f b] -> t a -> f (t b)
04:53:50 <joneshf-laptop> actually that doesnt make any sense
04:54:01 <joneshf-laptop> okay, here's what i'm looking at
04:58:04 <BoR0> what are advantages of Functor over Monad (or vice-versa)? e.g. Just 1 >>= return . succ and fmap (+1) (Just 1) are equivalent
04:58:22 <bennofs> BoR0: there are types that aren't a Monad, but are a Functor
04:58:31 <bennofs> BoR0: this means that the first will not work for some types
04:58:40 <BoR0> but those only implement the Functor class, right
04:59:03 <BoR0> so let me rephrase my question. what are things that Monads can do but not Functors?
04:59:05 * hackagebot vk-posix-pty 0.2 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/vk-posix-pty-0.2 (VladimirKirillov)
04:59:07 * hackagebot hsc3-rw 0.15 - hsc3 re-writing  http://hackage.haskell.org/package/hsc3-rw-0.15 (RohanDrape)
04:59:07 <bennofs> BoR0: however, all types which implement Monad can also have a Functor instance (currently, this is not enforced, but it will soon be)
04:59:42 <bennofs> BoR0: you cannot implement this using functors: Just 2 >>= \n -> if n == 2 then return 3 else Nothing
05:00:02 <Axman6> All Monads are Applicatives, and all Applicatives are Functors, not not the other way around
05:00:35 <Axman6> functor lets you do less (you can only fmap values) than monads (which allow you to make decisions based on values within earlier computations)
05:01:42 <BoR0> I see. ok, thank you
05:03:33 <joneshf-laptop> sorry, so here's what i'm asking
05:03:38 <joneshf-laptop> > ((<>) <$> (++ " world") <*> (++ " there")) "hello"
05:03:39 <lambdabot>  "hello worldhello there"
05:03:54 <joneshf-laptop> is there an analog for this to (>=>) ?
05:04:02 <joneshf-laptop> erm
05:04:05 * hackagebot vk-posix-pty 0.2.0.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/vk-posix-pty-0.2.0.1 (VladimirKirillov)
05:04:08 <joneshf-laptop> half said what i'm asking
05:04:19 <joneshf-laptop> so the above generalizses to
05:04:38 <joneshf-laptop> > mconcat [(++ " world"), (++ " there)] "hello"
05:04:39 <lambdabot>  <hint>:1:46:
05:04:39 <lambdabot>      lexical error in string/character literal at end of input
05:04:45 <joneshf-laptop> > mconcat [(++ " world"), (++ " there")] "hello"
05:04:47 <lambdabot>  "hello worldhello there"
05:04:54 <joneshf-laptop> is there an analog to that
05:05:25 <joneshf-laptop> because composing (<>) with more than two functions gets unweildy
05:05:33 <Cale> joneshf-laptop: What are you trying to compute?
05:06:01 <Cale> Like, can you give a program which works, but is inelegant?
05:06:03 <joneshf-laptop> Cale, i've got no specific problem i'm trying to solve here
05:06:14 <joneshf-laptop> Cale, just a curiosity
05:06:25 <Cale> I don't really understand what you're trying to generalise/analogise
05:06:32 <joneshf-laptop> k
05:06:44 <joneshf-laptop> one sec
05:07:12 <bennofs> joneshf-laptop: oh, so want something like data EndoKleisli m a = EndoKleisli (a -> m a) with instance Monad m => Monoid (EndoKleisli a) where mempty = EndoKleisli (\_ -> return mempty); mappend (EndoKleisli a) (EndoKleisli b) = EndoKleisli (a >=> b) ?
05:07:36 <bennofs> mempty = return I meant
05:07:39 <Cale> Oh, that ^^?
05:08:05 <bennofs> At least that's what I wanted once
05:08:23 <joneshf-laptop> > ((<>) <$> ((<>) <$> (++ " world") <*> (++ " there")) <*> (++ " you")) "hello" -- Cale
05:08:25 <lambdabot>  "hello worldhello therehello you"
05:08:26 <joneshf-laptop> > mconcat [(++ " world"), (++ " there"), (++ " you")] "hello"
05:08:28 <lambdabot>  "hello worldhello therehello you"
05:09:07 <joneshf-laptop> bennofs, umm, let me unpack that
05:09:17 <bennofs> joneshf-laptop: ah, so you want to generalize this to more than the reader monad?
05:09:28 <joneshf-laptop> bennofs, essentially
05:09:53 <bennofs> joneshf-laptop: so (Monoid a, Applicative f) => [f a] -> f a ?
05:10:30 <joneshf-laptop> bennofs, i *think* so
05:10:54 <bennofs> :t fmap mconcat . sequenceA
05:10:55 <lambdabot>     Not in scope: ‘sequenceA’
05:10:56 <lambdabot>     Perhaps you meant one of these:
05:10:56 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
05:10:59 <joneshf-laptop> bennofs, well actually, maybe restricting it to reader is what i want
05:11:02 <bennofs> :t fmap mconcat . T.sequenceA
05:11:02 <lambdabot> (Monoid b, Applicative f) => [f b] -> f b
05:12:45 <bennofs> > (fmap mconcat . T.sequenceA) [(++ " everyone"), const ", ", (++ " world")] $ "hello" -- joneshf-laptop like this
05:12:47 <lambdabot>  "hello everyone, hello world"
05:13:05 <mosdd> can i get current working directory in ghci (doesn't have to be a haskell function, need a repl cwd)
05:13:13 <bennofs> mosdd: :!pwd
05:13:59 <bennofs> mosdd: or :show paths
05:14:06 * hackagebot vk-posix-pty 0.2.0.2 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/vk-posix-pty-0.2.0.2 (VladimirKirillov)
05:14:29 <mosdd> thanks
05:14:40 <augur_> conal: can i ask you to elaborate a bit on the denotational design stuff? namely, where the denotations are?
05:14:44 <joneshf-laptop> bennofs, hmm, not actually what i'm looking for, but cool nonetheless
05:14:56 <joneshf-laptop> bennofs, Cale i think i need to think abut this more
05:15:02 <joneshf-laptop> bennofs, Cale thanks though
05:18:43 <Cale> augur_: One way to look at it is that denotational design is all about understanding designs of new languages in terms of languages which are well-understood and/or generally regarded as being designed well.
05:20:04 <augur_> Cale: im not sure how that comes through in the work, but ok
05:20:23 <augur_> not.. entirely sure i'd call that denotational, but
05:20:48 <Cale> Well, what does [[-]] do?
05:22:21 <augur_> usually it means denotation, but im not sure how that's related. i dont think it occurs in the lambdajam slides, for instance
05:22:34 <Cale> Well, I don't know what it was that conal talked about
05:22:41 <Cale> I was just giving my own take on your question
05:22:47 <augur_> thats why i was asking conal ;)
05:23:12 <augur_> tho i'd be interested in anything you have in mind where denotations are manifestly relevant!
05:25:01 <Cale> They're pretty much always relevant. It wouldn't be too much of an exaggeration to say that the only way that humans ever understand anything is by analogy with other things. Obviously can't quite be true, but in practice, most of the time if you come to understand something it's by relating it to something you already knew.
05:28:21 <Cale> So taking apart the structures in a programming language and interpreting them in terms of mathematics lets you apply all the stuff that's known about the mathematical objects, especially if that translation is fairly straightforward.
05:29:34 <augur_> Cale: so im reading http://conal.net/talks/lambdajam-2014.pdf
05:29:39 <augur_> hence the question
05:29:54 <augur_> and i noticed on page 38 (and again on 48) there is some genuine denotationality going on
05:30:29 <augur_> where conal defines (:-o) :: * -> * -> * and has mu :: (a :-o b) -> (a -o b)   (where a -o b is the linear fragment of a -> b)
05:30:47 <augur_> and this does define a genuine denotational system
05:31:13 <augur_> so with that in mind im going to re-read. its very deeply buried tho. its not clear at all what role this plays in the design process, if any..
05:33:31 <Cale> augur_: In particular, you'll notice all these triple = signs
05:34:49 <Cale> augur_: Note that those aren't equality of terms in the language, they're equality of the semantic things they translate into, and we're using those equations to help guide the implementation of our new language.
05:35:20 <augur_> aha, re-reading things in this light, i now understand what he means
05:35:45 <augur_> hmm. it wouldve been better to put a broad-strokes sketch of the plan up front in slide 1 or thereabouts
05:39:25 <Profpatsch> The Compiler complains that the exp2!!n in step wants [Float], not [Int]. https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
05:39:49 <Profpatsch> Can I generalize the signatures of g and f?
05:40:14 <Profpatsch> I thought something like (Real n -> Real n), but then it complains about the wrong kind (Constraint).
05:40:45 <Profpatsch> Do I miss a Type a => somewhere?
05:40:53 <bergmark> Profpatsch: Real is a type class not a type, so you'd write Real r => r
05:41:06 <Cale> Profpatsch: You have map (2**) [0..]
05:41:18 <Profpatsch> bergmark: Ah, I see.
05:41:33 <Cale> Profpatsch: (**) is exponentiation where both the base and exponent are required to be of a floating point type
05:41:48 <Cale> Profpatsch: If you want it to be a list of Ints, you'll need to use ^
05:41:52 <Cale> :t (^)
05:41:54 <lambdabot> (Num a, Integral b) => a -> b -> a
05:41:55 <Cale> :t (^^)
05:41:56 <lambdabot> (Integral b, Fractional a) => a -> b -> a
05:41:59 <Cale> :t (**)
05:42:01 <lambdabot> Floating a => a -> a -> a
05:42:13 <augur_> Cale: it seems like the "denotational design" idea is to build data types/DSLs that code the problem domain (ideally in some minimal fashion) and then interpret them into haskell
05:42:24 <Cale> (^) allows any kind of number as the base, but only non-negative integer exponents will work
05:42:55 <Cale> (^^) will allow negative exponents, but requires a base type which allows fractional numbers (because raising things to negative powers produces fractions)
05:43:44 <Cale> augur_: Or at least interpret the Haskell we write back into a mathematical model of the problem domain.
05:44:13 <augur_> Cale: well, in this case its using haskell as the model. :P
05:44:16 <Cale> augur_: and use that to inform how we proceed :)
05:44:23 <Cale> Yeah, it sort of goes both ways
05:45:03 <Profpatsch> I see, thanks!
05:46:10 <augur_> i wonder if there are any good introductions to this kind of design process
05:46:13 <Profpatsch> Will f 2^n work or do I need f (2^n)?
05:46:25 <Cale> f 2^n means (f 2)^n
05:46:36 <augur_> Profpatsch: function application binds tighter than all other kinds of operator-y stuff
05:46:41 <Cale> Because function application binds more tightly than any infix operator
05:46:42 <Cale> yeah
05:47:06 <Profpatsch> So function application is infixl10?
05:47:23 <Profpatsch> I searched for it, but couldn’t find it anywhere.
05:47:32 <Cale> yeah, pretty much, you can think of it like that
05:47:53 <Cale> Function application isn't actually an infix operator, it's just another part of the syntax of the language really
05:47:55 <asfp> function application must be left associative so f g h means ((f g) h) I guess.
05:48:04 <Cale> But if you wanted to think of it as one, it would be infixl 10
05:48:22 <augur_> Profpatsch: its infix infinity!
05:48:37 <augur_> which i guess is 10 in haskell :p
05:49:03 <asfp> where is the largest haskell job listing site?
05:49:24 <t7> /dev/null
05:49:44 <Profpatsch> augur_: afaik infix only uses 1-9.
05:49:51 <augur_> yeah i was making a joke :p
05:50:16 <Profpatsch> I wonder why infix doesn’t use some kind of Ord relation, instead of fix numbers.
05:50:41 <augur_> i dont think anyone has a good idea of how to improve on fixity numbers, tbh
05:50:44 <Profpatsch> What if you suddenly have something that needs to fit between an infix5 and infix6?
05:50:54 <augur_> ive seen suggests here and there, but nothing is perfect
05:51:06 <Cale> augur_: I suppose if you wanted to go even further, you could involve some explicit mapping between the mathematics that you're using as the denotation of your language, and the mathematics which you're taking as the "standard" denotation for Haskell.
05:51:20 <augur_> one idea ive seen is to allow explicit rankings, eg   (+), (-) < (*), (/)
05:51:24 <Cale> augur_: So this is all about enforcing and taking advantage of a sort of commutative triangle
05:51:47 <augur_> another ive seen is to give examples of parenthesization, eg   x + y * z ==> x + (y * z)
05:52:06 <augur_> but these are all pretty awful
05:52:24 <augur_> Cale: i dont need a denotation for haskell, tbh.
05:52:25 <Cale> You could also just allow rational numbers ;)
05:52:34 <augur_> haskell _is_ the denotation afaic
05:52:46 <augur_> Cale: surely the rankings are equivalent to having rationals, no?
05:52:56 <augur_> at least, both are dense
05:53:04 <Cale> augur_: Well, if you like. Haskell itself doesn't really have a very appropriate notion of equality.
05:53:18 <augur_> thats true
05:53:27 <Cale> augur_: But I suppose you don't need a whole denotational setup to get one
05:53:52 <augur_> im ok pretending we have observational/extensional equality on functions tho, that way the triple= goes through
05:54:10 * hackagebot mtl-prelude 1.0.0 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-1.0.0 (NikitaVolkov)
05:59:11 * hackagebot mtl-prelude 2.0.0 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-2.0.0 (NikitaVolkov)
05:59:13 <augur_> Cale: this idea of a data type + operations on it coding for the problem domain, and then interpreting into an underlying language, is rather interesting. i really wish there were more to read on this
06:01:23 <ompaul> gmx9611111111111: do you have a reason for all those joins?
06:02:08 <ompaul> gmx9611111111115: perhaps you could fix your connection
06:02:42 <augur_> posibly one of the ops can help here
06:02:46 <augur_> Cale: ^
06:02:57 <Cale> hm
06:03:16 --- mode: ChanServ set +o Cale
06:03:19 --- kick: gmx9611111111117 was kicked by Cale (gmx9611111111117)
06:03:22 <Cale> Let's try that
06:03:30 <Cale> Maybe his client won't rejoin automatically
06:04:11 * hackagebot mtl-prelude 1.0.1 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-1.0.1 (NikitaVolkov)
06:04:13 * hackagebot mtl-prelude 2.0.1 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-2.0.1 (NikitaVolkov)
06:04:14 <Cale> ...okay
06:04:23 --- mode: Cale set +b *!*@62.64.58.6
06:04:23 --- kick: gmx9611111111118 was kicked by Cale (gmx9611111111118)
06:04:34 <Cale> I'll message him to let him know what's up
06:05:07 <augur_> it was going so well :(
06:09:12 * hackagebot creatur 5.7.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.7.0 (AmyDeBuitleir)
06:13:41 <Profpatsch> How should I indent let … in?
06:13:54 <Profpatsch> let foobar = 42 in
06:14:01 <Profpatsch> expressions
06:14:12 <Profpatsch> let foobar = 42
06:14:18 <Profpatsch> in expressions
06:14:43 <sopvop> is haxl usable as it is now? it seems facebook has not updated it since release
06:14:56 <Profpatsch> Thing is, Haskell mode indents the `in` by 4 spaces if I want to put it on the next line.
06:15:42 <Cale> Profpatsch: Sometimes it's nice to indent the 'in' just by one space
06:15:49 <Cale> let foo = 42
06:15:53 <Cale>  in foo + foo
06:16:52 <Cale> Profpatsch: One of the things which always frustrated me about the emacs mode was the "smart" indenting. I just turned it off for the most part.
06:19:37 <Profpatsch> I always laugh when people don’t like python, because it’s indent-based and not block-based. And tell them Haskell is both, depending on context.
06:20:20 <augur_> haskell can be entirely block based, i think
06:20:42 <exio4> I just find haskell's indentation "less painful"
06:21:07 <Profpatsch> Ah, I can cycle through indentation possibilities with TAB.
06:21:16 <tdammers> haskell is less painful in many ways
06:21:26 <exio4> that too!
06:22:01 <tdammers> but wrt block vs. layout; haskell doesn't need `pass`, which pretty much sums up the difference
06:22:35 <Cale> Profpatsch: Yeah, though iirc, that didn't work until I'd already started typing the line
06:22:47 --- mode: Cale set -o Cale
06:23:05 <Cale> It's so weird to type a line and then hit tab to put it in the right place
06:23:45 <lemonxah> hello
06:23:52 <Cale> lemonxah: Hello!
06:23:59 <lemonxah> is there any recommendations as to which ide would work best?
06:24:17 <Cale> lemonxah: Any text editor which is capable of automatically converting tabs to spaces should do
06:24:33 <Cale> lemonxah: So just use whatever is your favourite
06:24:33 <lemonxah> i have atom open and i have those plugins installed
06:24:39 <lemonxah> but its my first time using atom
06:24:59 <lemonxah> do i have to manually compile with ghc?
06:25:15 <lemonxah> or is there an ide like run button thingy
06:25:24 <Cale> lemonxah: Usually what I do is keep two windows open: My text editor, and a terminal window with ghci
06:25:43 <Cale> lemonxah: When I save my file, I just hit :r in ghci and it reloads the source
06:25:56 <Cale> which will report any errors and let me play with the new definitions I made
06:26:06 <Profpatsch> Can I simplify this?
06:26:11 <Profpatsch>       in case binarySearch from (center-1) of
06:26:13 <Profpatsch>        Nothing -> binarySearch center to
06:26:15 <Profpatsch>        Just n -> Just n
06:26:23 <tdammers> what Cale said; also, I usually dump a dummy makefile into my project so I can go :make from within vim
06:26:28 <Cale> :t fromMaybe
06:26:30 <geekosaur> there are IDEs, but they're not especially popular. (leksah, and the eclipsefp plugin for Eclipse, are two)
06:26:31 <lambdabot> a -> Maybe a -> a
06:26:38 <Cale> Profpatsch: ^^ might be useful
06:26:51 <Cale> oh, no
06:26:53 <Cale> :t maybe
06:26:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:26:58 <tdammers> IMO Haskell kind of makes much of what an IDE does unnecessary :D
06:26:59 <Cale> We need this version :)
06:27:22 <Cale> maybe (binarySearch center to) Just (binarySearch from (center-1))
06:27:50 <Cale> Oh, actually
06:27:51 <Cale> derp
06:27:59 <bennofs> I find jump-to-error to be quite a timesaver
06:28:09 <Cale> binarySearch from (center-1) `mplus` binarySearch center to
06:28:16 <Cale> there you go :)
06:28:26 <lemonxah> so is anyone here using haskell for big things?
06:28:32 <lemonxah> like real world applications
06:28:36 <Cale> I should have seen that immediately, but I didn't think hard enough about what your code meant
06:28:37 <lemonxah> i am sure there has to be
06:28:39 <Cale> lemonxah: yeah, lots
06:28:41 <lemonxah> obviously
06:29:15 <tdammers> bennofs: vim has that... :cc, :cn, etc.
06:29:41 <tdammers> lemonxah: sort of, yes... they're side projects, but still, totally real-world and useful
06:29:55 <Cale> lemonxah: I've worked on an action RPG in Haskell (which didn't get finished sadly, but eventually we'll open source a bunch of stuff from it), and the web application backend for skedge.me, and a special purpose compiler for signal processing applications
06:30:07 <thsig> lemonxah: A couple of examples - Standard Chartered have millions of lines of Haskell running almost all of their trading systems. Everything from GUIs to number crunching for the models.
06:30:08 <thsig> see http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/
06:30:38 <lemonxah> i am keen to learn this to help me better understand fp
06:30:41 <Cale> There are people using Haskell at Facebook to manage all the various spam-filtering solutions they have.
06:30:45 <thsig> yeah
06:31:09 <thsig> they actually talked to Simon Marlow about exactly that on the Haskell Cast: http://www.haskellcast.com/episode/004-simon-marlow-on-parallelism-and-concurrency/
06:31:11 <lemonxah> cause i have a very basic understanding and i got my company to agree to scala as its a java house and we aren't going to get rid of the jvm anytime soon
06:31:14 <lemonxah> and i dont like java
06:31:20 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:31:23 <Cale> is a decent list
06:31:24 <lemonxah> did some F# already
06:31:36 <QF-MichaelK> Cale: any videos/screenshots of the action RPG?
06:31:45 <lemonxah> but stuff like higher order kinds i have still to fully grasp
06:31:51 <lemonxah> like monads
06:32:46 <tdammers> the biggest hurdle in understanding monads is the epiphany that there is not much to understand really
06:33:06 <Cale> QF-MichaelK: I don't know if I have any actually... certainly no videos. There's a bunch of changes which need to get done to make it runnable again after ~> is no longer allowed in types as a type variable. (Though I think maybe blackh did those, I should ask him...)
06:33:20 <lemonxah> yes and i need to get to that epiphany
06:33:44 <Cale> QF-MichaelK: There was a big open world you could run around in, and it had props and trees and stuff, but it was mostly pretty empty apart from the area that you started in still.
06:33:45 <exio4> I like https://www.youtube.com/watch?v=ZhuHCtR3xq8
06:33:58 <exio4> (don't fear the monad vid)
06:34:12 <thsig> lemonxah: I started with Learn You a Haskell for Great Good (http://learnyouahaskell.com/)
06:34:18 <QF-MichaelK> Cale: OpenGL and 3D?
06:34:19 <Cale> QF-MichaelK: The combat system was still pretty basic, but fun to play, with ranged and melee AIs and stuff.
06:34:22 <Cale> Yes
06:34:28 <albeit> Why would a single-threaded function timed with criterion take twice on long with -N as opposed to -N1?
06:34:31 <Cale> with touch controls
06:34:37 <thsig> but I've been reading up on category theory recently, and I actually find that makes it way simpler to grok
06:34:42 <Cale> (you could also use a mouse)
06:35:09 <lericson> given two integers x and y, how would you guys calculate the real number x.y?
06:35:24 <QF-MichaelK> Cale: Did you guys mess with any 4.x shaders?
06:35:31 <tdammers> lericson: "." as in decimal point?
06:35:34 <lericson> tdammers: yes
06:35:42 <tdammers> lericson: that is a broken question, really
06:35:54 <lericson> our current solution over here is decimal a b = a + b / 10 ** (floor(log(b, 10) + 1)
06:36:01 <tdammers> lericson: but if you have to, I'd go via show
06:36:08 <lericson> a broken question?
06:36:09 <tdammers> show and read, that is
06:36:11 <tdammers> yes
06:36:21 <thsig> I know the joke "what part of 'monoid on the category of endofunctor' don't you understand", but actually I'll venture the opinion that it takes less time to read the theory leading up to that than to beat one's against all the tutorials out there
06:36:28 <tdammers> representing the fractional part as an integer is kind of wrong
06:36:29 <Cale> QF-MichaelK: No, it was intended to run on iPhones which at the time didn't have very fancy OpenGL
06:36:33 <thsig> math always sounds way scarier than it actually is
06:36:33 <tdammers> at least if you do it that way
06:36:56 <tdammers> it assumes a decimal system, even though integers are conceptually base-agnostic
06:36:57 <Cale> (this was all a few years ago)
06:37:06 <tdammers> or maybe binary, if you have to decide on a "natural" base
06:37:12 <QF-MichaelK> Cale: Ah, hence the touch, tricky domain.  Why not just go WebGL?
06:37:35 <Cale> I'm not sure WebGL was even a thing?
06:37:41 <tdammers> besides, such an encoding does weird things with precision
06:37:56 <simpson> WebGL confirmed for thing.
06:37:58 <lericson> tdammers: well, this is part of the problem, not much of a point in complaining
06:38:04 <Cale> If it was, I don't think I knew about it at the time
06:38:05 <QF-MichaelK> Cale: march 2011
06:38:06 <simpson> Not a very exciting thing, but it's there.
06:38:19 <QF-MichaelK> but wasn't stable at all
06:38:25 <tdammers> lericson: so passing the parts in as integers is a given? you're not reading bytestrings or anything?
06:38:34 <thsig> *one's head
06:38:35 <Cale> and like, how is that usable from Haskell?
06:38:38 <lericson> thsig: heh, reminds me of the first time i heard about linear homogenous differential equations. seems so simple now, but boy was it scary then!
06:38:42 <Cale> We have GHCJS and stuff now
06:38:50 <lericson> tdammers: it's some kind of json api as i understand it, yes
06:39:03 <QF-MichaelK> There's no GHCwebGL yet?
06:39:11 <tdammers> if it's a JSON api, then I'd pick things up at the Aeson level
06:39:14 <thsig> lericson: haha, yeah :)
06:39:24 <tdammers> define a proper decimal type, implement a better FromJSON instance...
06:39:33 <Cale> QF-MichaelK: I have no idea :)
06:39:45 <tdammers> I'd probably still go through show and read, unless performance is a critical concern
06:39:52 <Cale> QF-MichaelK: It's definitely more straightforward when you're compiling to native code just to use OpenGL directly.
06:39:59 <lericson> tdammers: how would that work? the json api says {'number': 23, 'decimal': 45} for 23.45
06:40:13 <tdammers> yeah, something like:
06:40:34 <tdammers> > let number = 23, decimal = 45 in read (show number ++ "." ++ show decimal) :: Double
06:40:36 <lambdabot>  <hint>:1:16: parse error on input ‘,’
06:40:38 <thsig> lericson: because the "linear" and "homogenous" are both qualifications which actually make things more tame and simple - just not the name!
06:40:39 <tdammers> pfff
06:40:46 <tdammers> > let number = 23; decimal = 45 in read (show number ++ "." ++ show decimal) :: Double
06:40:48 <lambdabot>  23.45
06:40:51 <tdammers> that
06:41:06 <lericson> i'm not familiar with applied haskell in web contexts (or applied haskell much at all), and perhaps a bit pertinent is the fact that the language du jour over here is actuall python, i just figured you guys know maths ;)
06:41:14 <Fernandos> hi
06:41:29 <lericson> actuall+y
06:41:40 <tdammers> lericson: oh, I'm sure one could come up with a more efficient solution, but I doubt it would be more readable
06:41:48 <lericson> tdammers: so this is similar to doing string concatenation and then interpolation?
06:41:51 <Fernandos> Where can I find a small jdbc example? (Connecting to a db and running a query)
06:41:53 <albeit> I'm trying to figure out if using forkOn is a good idea... if I have many threads, but I can group the into groups that have shared memory, should I forkOn each group onto its on core?
06:42:12 <tdammers> lericson: more like convert to strings, concatenate with a dot character in between, and then parse back into a number
06:42:19 <lericson> not really interpolation, but interpretation perhaps
06:42:23 <tdammers> yes
06:43:24 <Cale> albeit: I guess you could try it
06:46:16 <albeit> Cale: is that a typical use case for it?
06:46:36 <Cale> albeit: I've honestly never used it
06:46:51 <Cale> I suppose it might help reduce scheduling costs
06:47:29 <Cale> But then you might end up with one processor not doing anything
06:47:40 <ThreeOfEight>  
06:47:45 <Cale> even though there are threads on the other processors wanting to run
06:48:00 <albeit> True
06:48:29 <albeit> How expensive is scheduling? The docs say using multicore / -Nx can be slower... but how costly is it to access shared memory between cores?
06:48:38 <albeit> Or is it the context switiching to other cores?
06:49:46 <Cale> A lot of the time in Haskell, I don't think those memory concerns will matter all that much because your locality will be terrible anyway unless you're being super careful and low-level about your approach to things
06:50:35 <Cale> So the chances are already pretty good that you're going out to main memory for whatever it is you need.
06:50:55 <Cale> Maybe I'm wrong
06:51:10 <Cale> I don't usually worry about things like that a whole lot
06:51:49 <QF-MichaelK> exio4: thanks for the link ^.^
06:54:20 <exio4> hmm?
06:56:05 <QF-MichaelK> exio4: The monoid link.  I still want to know category theory better.
06:59:39 <exio4> QF-MichaelK: I learn something new everyday, so, enjoy the trip! :P
07:00:05 <mosdd> need a name suggestion.. a function similar to takeWhile that includes first element for which the predicate returns false
07:00:34 <cmtptr> takeUntil
07:00:40 <mosdd> no
07:00:50 <cmtptr> takeUntilJustAfter
07:01:04 <cmtptr> takeUpToAndIncluding
07:01:21 <mosdd> doit even [2,2,2,3,3,3] => [2,2,2,3]
07:01:23 <dv-> dropDownLow
07:01:59 <mosdd> i like takeUpToAndIncluding is descriptive but maybe a bit verbose
07:05:18 <mosdd> wait I am confused. I thought takeUntil is the opposite of takeWhile (and I named it like that), but now I am not sure
07:05:35 <mosdd> more of a question for #english I guess
07:06:29 <Cale> mosdd: Depends on what you mean by "opposite"?
07:06:33 <random78> Would anyone be able to let me know how this case pattern works "EQ | x == 5 -> "one or three". In particular, I've never encountered the pipe before.
07:06:34 <nshepperd> I think "until p" = "while (not p)", yes
07:06:40 <augur_> > takeWhile (<10) [0..]
07:06:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
07:06:56 <augur_> > takeUntil (>=10) [0..]
07:06:58 <lambdabot>  Not in scope: ‘takeUntil’
07:07:06 <Cale> I think traditionally takeUntil meant the variation which leaves the element which failed the predicate at the end of the list
07:07:35 <Cale> (in addition to having the sense of the condition negated)
07:07:50 <nshepperd> mosdd: takeWhile1? takeWhilePlus1?
07:08:18 <haasn> To me, intuitively, it seems like a variation of “find” that also returns the list before the element it found
07:08:24 <augur_> random78: the | just adds an extra boolean condition
07:08:25 <haasn> (Rather than a variation of takeWhile)
07:08:41 <augur_> random78: so not only must the thing match the EQ pattern, but also `x == 5` must be true
07:08:43 <RobManley> Hi. Do you know any good web scraping and spider libraries? (in case of HTML parsing preferrably supporting CSS selectors)
07:09:23 <random78> Got it thanks, it threw me off because it's a double pipe elsewhere
07:09:28 <haasn> random78: Are you familiar with function guards, eg. “f x | cond = res” ?
07:09:39 <random78> yes I am, they're awesome
07:09:43 <haasn> That's the same thing
07:09:52 <haasn> f z = case z of x | cond -> res
07:10:23 <random78> that clears it up, thanks
07:10:34 <haasn> Note: you could also define a function like   “f (Just x) | x == 5 = ...”
07:10:35 <augur_> random78: double pipes are not used for that purpose ever
07:10:49 <random78> "5 == 3 || 3 > 2"
07:10:56 <haasn> Just as you can write “case ... of Just x | x == 5 -> ...”
07:11:14 <haasn> random78: That's not the same thing. In this case, the condition has to match *as well*
07:11:22 <haasn> It's closer to logical AND, not logical OR
07:11:44 <augur_> random78: thats "or"
07:12:30 <random78> haasn: that's what I was originally thinking it was. So then, would it be correct to say that the single pipe acts as a guard, which must evaluate to a boolean value
07:12:46 <random78> and each must one must evaluate to true
07:12:58 <augur_> random78: right, they're called guards in fact
07:13:31 <lb5tr> Hi, is there any posibilty for conditional arrows?
07:13:34 <random78> augur_: lol, that's cool. I didn't know that the patterns of case expressions had guards.
07:14:30 <random78> augur_: they just seem to be a bit different from function guards since only one of them needs to be satisfied
07:14:35 <lb5tr> lets say i have two computation paths A and B and a function that takes some bool arrow, and those A and B, and if bool arrow is true it executes A otherwise B
07:14:45 <lb5tr> i don't know if that even sound correct
07:14:45 <augur_> random78: no they're exactly the same
07:15:36 <augur_> random78: the guards form part of the pattern, in a sense.
07:15:37 <random78> augur_: really? but function guards are evaluated from top to bottom, and the first one that matches gets used correct? You just said that with case guards each one must match.
07:16:03 <random78> augur_: in that sense wouldn't function guards work more like boolean 'or'?
07:16:07 <lb5tr> coditional :: a b Bool -> a b' c -> a b' d -> a b' (Either c d)
07:16:11 <lb5tr> conditional :: a b Bool -> a b' c -> a b' d -> a b' (Either c d)
07:16:15 <lb5tr> something like this i think
07:19:20 * hackagebot pipes-attoparsec 0.5.1.1 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.5.1.1 (RenzoCarbonara)
07:19:56 <augur_> random78: you're mixing things together
07:20:26 <augur_> random78: a pattern can have multiple guards, that much is true
07:20:49 <augur_> eg   foo C | p = ... ; foo C | p' = ...
07:21:04 <augur_> (which can be collapsed, so that you dont repeat the foo C)
07:21:38 <augur_> and in that case each pattern -- C | p   and   C | p'   -- is evaluated top-to-bottom
07:21:48 <augur_> so its disjunctive in that sense
07:21:58 <Atque> Hiya.  Is Haskell or lisp better?
07:22:00 <augur_> but the meaning of C | p is conjunctive:  the argument must be C, and ALSO p must be true
07:22:35 <augur_> random78: the disjunctive nature comes from the multiple clauses/patterns not from the |
07:24:12 <shiona> :t Diagrams.Prelude.(#)
07:24:13 <lambdabot> parse error on input ‘)’
07:24:16 <shiona> :t Diagrams.Prelude.#
07:24:17 <lambdabot> parse error on input ‘Diagrams.Prelude.#’
07:26:07 <albeit> Would someone mind taking a look at this? http://lpaste.net/113029 Why would a pure single-threaded program run so much slower on multiple cores? There shouldn't be any scheduling slowdowns as its just one thread, right?
07:27:56 <random78> augur_: so in regards to functions, the multiple guards are disjunctive in that only one will match, and in case expressions they're disjunctive in that there are multiple patterns
07:28:14 <random78> augur_: but other than that, they're conjunctive
07:28:18 <augur_> random78: the multiple clause are disjunctive
07:28:19 <random78> would that be a fair sumamry?
07:28:30 <geekosaur> albeit: I think if you enable more than one core, garbage collection does more locking and is generally slower even if you don't have multiple threads "in flight"
07:28:38 <augur_> random78: a clause is some patterns + an optional guard
07:28:48 <RchrdB> albeit: offhand, when you run with multiple execution threads, all the threads have to pause at once to perform GC, so GC cycles take longer to start.
07:28:57 <RchrdB> oh, geekosaur beat me to it. :)
07:29:14 <augur_> random78: there is no such thing as a clause with multiple guards. whenever you see that, its just sugar for multiple clauses with repeated content
07:29:35 <geekosaur> also there will be multiple threads anyway, because the runtime will create a "hidden" thread fir itself if more than one capability ("core") is available
07:29:59 <RobManley> What are good modern spider libraries that the Haskell community uses? Is Shpider up to date?
07:30:11 <geekosaur> and possibly a second for "safe" FFI calls
07:31:05 <augur_> random78: /msg incoming
07:33:20 <albeit> geekosaur, RchrdB: Ah, okay. Good to know. But doesn't criterion GC between timings, so the timings shouln't be affect by GC?
07:34:01 <geekosaur> it does that to *try* to avoid GC interference, but it can't suppress any GC that gets triggered in the middle of a timing run
07:34:45 <geekosaur> the GHC runtime does not provide a way to block GC from occurring whenever the runtime sees fit. sometimes you can fiddle with RTS options to make it less likely
07:36:20 <geekosaur> (try "ghc +RTS --help" to see available RTS options, and see http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc)
07:36:48 <tiqs> Hi, I want to create a haskell-like DSL/Scripting language for an application I'm writing. Can anyone suggest some resources to get me started?
07:39:12 <geekosaur> albeit: also beware that you have to compile with -rtsopts in order for most RTS options to be available, since mucking with RTS options could conceivably cause a denial of service on the machine
07:39:14 <albeit> geekosaur: Does this logic follow? I can use the -A option to make GC allocation area larger, so the change of a GC happening during a timing is decreased?
07:39:22 * hackagebot hspec-checkers 0.1.0 - Allows to use checkers properties from hspec  http://hackage.haskell.org/package/hspec-checkers-0.1.0 (SoenkeHahn)
07:39:25 <albeit> *chance
07:41:23 <geekosaur> albeit: no, -A only does anything useful if you turn off multigenerational GC (which is usually a bad idea since minor GCs are very fast and don't "stop the world", so should be preferred)
07:43:22 <luite> geekosaur: you can force a major GC first with performGC, or use GHC.Stats.getGCStats and then numGcs to disqualify runs that have a GC. although to accurately measure performance, allocation rate and gc overhead should be taken into account
07:45:14 <albeit> luite: Ah disqualifying runs with GC is a great idea. I'm more interested in the non-GC-affected performance for now so I can compare times
07:45:46 <geekosaur> you might want +RTS -s
07:46:04 <geekosaur> to see what's going on and what might benefit from tuning
07:46:47 <gigabytes> hi all
07:47:08 <gigabytes> could it be that cabal have problems with sandboxes located under directories that have white spaces in the path?
07:47:18 <gigabytes> I have a project under ~/Working Copies/projectname
07:47:21 <gigabytes> and nothing works
07:47:22 <albeit> Is time spent locking the threads and "preparing" for GC considered GC time?
07:47:47 <gigabytes> After having installed the dependencies successfully I get that modules are missing while building
07:48:18 <gigabytes> the error message reads: module X.Y.Z not found. There are missing files from the package 'xyz'
07:48:38 <geekosaur> albeit: it should, yes
07:49:48 <dramforever> well, iirc, a new enough ghc runtime can do parallel gc
07:50:27 <dramforever> albeit and all: is that relevant?
07:50:41 <geekosaur> there's only one active thread, so probably not
07:50:49 <geekosaur> (aside from runtime threads)
07:51:07 <albeit> dramforever: Isn't parallel GC already default? Docs say "-qg[gen]" has default 0, enable parallel GC in generation 0 and higher
07:51:28 <dramforever> albeit: well, it's not parallel to other threads?
07:51:35 <dramforever> I'm not sure
07:52:26 * geekosaur will defer to luite on fine details, but suspects parallel gc will actually make things worse in many cases since it increases the amount of locking and synchronization needed
07:52:35 <dramforever> Hi everyone, what should I do to improve the *memory* efficiency of bytestring builders
07:53:02 <dramforever> I have a builder-based program, and it runs blazingly fast, which is good
07:53:05 <geekosaur> although it will be a net improvement if your memory allocations are evenly spread across many threads instead of confined to a few. I think.
07:53:36 <bennofs> doesn't parallel GC only mean that the GC runs it parallel, but is still stop-the-world?
07:53:43 <dramforever> maybe
07:53:55 <bennofs> it's not a concurrent GC iirc
07:53:56 <luite> yes, the gc is not concurrent
07:53:56 <geekosaur> yes
07:54:16 <dramforever> while processing a 700M-ish file, it takes 2G memory, while the python equivlant takes 2x time and 700M mem
07:54:28 <blogle> Anyone have expertise in spatial trees namely KDTree's?
07:54:39 <exio4> python uses reference count, I think
07:54:43 <dramforever> well
07:54:59 <dramforever> it's mainly string processing
07:55:45 <dramforever> I'm using a bytestring builder, and I wonder if has too much overhead
07:56:07 <dfeuer> Could be.
07:56:14 <bennofs> dramforever: how big is the program?
07:56:50 <dramforever> bennofs: 4M
07:56:53 <bennofs> dramforever: if it's small, maybe you can paste it so people can look if there's maybe other issues that cause the high memory usage?
07:57:07 <dramforever> well, let me see
07:57:31 <gigabytes> yes, I confirm the problems were the whitespace in the path
07:57:36 <int-e> albeit: actually in ghc's runtime acquiring the capabilities is not attributed to the GC time.
07:57:46 <gigabytes> do you have any info about this issue?
07:57:46 <dramforever> I have two versions, one first converts it to a strict bytestring, and then works on it. The other works on the lazy one
07:57:57 <dramforever> directly
07:58:01 <albeit> int-e: Okay
07:58:59 <geekosaur> that seems unfortunate
07:59:02 <int-e> albeit: all the work that happens between https://github.com/ghc/ghc/blob/master/rts/Schedule.c#L1433 and https://github.com/ghc/ghc/blob/master/rts/sm/GC.c#L218 is not accounted for.
08:01:37 <lpaste> dramforever pasted “hrevoice” at http://lpaste.net/113032
08:01:57 <dramforever> it reverses a .wav file so it plays backwards
08:02:42 <dramforever> this is the lazy bs version.
08:03:25 <dramforever> bennofs: in case you want to try it, it depends on the wavy package
08:03:28 <dramforever> @hackage wavy
08:03:29 <lambdabot> http://hackage.haskell.org/package/wavy
08:03:52 <EvanR_> does it actually play sound?
08:03:55 <dramforever> no
08:04:03 <dramforever> just input.wav -> output.wav
08:04:59 <dramforever> weird thing: just Data.ByteString.Lazy.reverse is really, really, really blazingly fast
08:05:15 <dramforever> but that's not what I want
08:05:38 <dramforever> oh, the function I'm talking about is reverseData
08:06:00 <EvanR_> for short bytestrings, it might be one chunk, and reverse might be implemented with a weird flag
08:06:28 <dramforever> EvanR_: nope
08:06:34 <dramforever> the d is like 700M
08:06:48 <dramforever> it's not short
08:07:08 <EvanR_> in that case reverse doesnt make much sense
08:07:21 <bennofs> dramforever: hmm, I would expect that reversing a string of n bytes takes at least 2 * n bytes
08:07:47 <dramforever> EvanR_: well, but the whole purpose of the program is to reverse it
08:07:53 <bennofs> dramforever: because at some time, you need to have both the original string and the reversed version in memory
08:08:07 <bennofs> (at least if you can't remove chunks from the end)
08:08:09 <shanthakumar> @pl f n t =   uncurry (&&) $ ( (uncurry (***)) . ((==) &&& (==)) ) n t
08:08:09 <lambdabot> f = (uncurry (&&) .) . uncurry (***) . ((==) &&& (==))
08:08:13 <dramforever> bennofs: so maybe it means I have to get more low level?
08:08:25 <EvanR_> if you read the wav file backwards, that would make sense
08:08:38 <dramforever> EvanR_: well, how?
08:08:50 <dramforever> is there any handle that reads backwards?
08:09:09 <EvanR_> not that i know of, but you can seek back, read a chunk, reverse it
08:09:24 <dramforever> EvanR_: well, maybe I'll try it
08:09:37 <dramforever> but that would get a bit lower level...
08:09:46 <EvanR_> yeah, and it might kill disk performance
08:09:59 <dramforever> yeah it's my main concern too
08:10:12 <dramforever> because disks are not meant to be read like that
08:10:51 <dramforever> 12345678 normal and good, 78563412 weird and not meant to be like this
08:10:52 <bernalex> wtf does this do:
08:10:59 <bernalex> infixr 5 :<
08:11:04 <bernalex> pattern b :< bs <- (C.uncons -> Just (b, bs))
08:11:08 <bernalex> pattern Empty   <- (C.uncons -> Nothing)
08:11:11 <bernalex>  /end spam
08:11:16 <bennofs> bernalex: -XPatternSynonyms
08:11:20 <bernalex> bennofs: ty
08:11:35 <bennofs> bernalex: + -XViewPatterns
08:11:37 <dramforever> bennofs: it's new in ghc 7.8, iirc
08:11:43 <UnrealQuester> I love how some of haskells operators look like faces
08:11:57 <EvanR_> theres the unix command tac which is cat in reverse
08:12:00 <EvanR_> i wonder how that works
08:12:09 <dramforever> EvanR_: how efficient?
08:12:26 <EvanR_> no idea
08:12:38 <dramforever> EvanR_: tac supports reading from non-seekable files like stdin
08:12:48 <dramforever> so maybe it stores the whole string
08:13:15 <EvanR_> it would have to in that case
08:13:19 <EvanR_> a stack
08:13:28 <dramforever> EvanR_: well, in essence, my hrevoice is like tac
08:14:00 <dramforever> for example, numChannels = 2 and bitsPerSample = 16
08:14:10 <bennofs> dramforever: have you tried profiling it?
08:14:26 * hackagebot casadi-bindings 2.1.0.1 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.1.0.1 (GregHorn)
08:14:29 <bennofs> dramforever: compile with -prof -fprof-auto, run with +RZT
08:14:33 <dramforever> bennofs: oh I'm going to try it
08:14:39 <bennofs> run with +RTS -h
08:15:17 <bennofs> then run hp2ps -c hrevoice.hp and open hrevoice.ps
08:15:40 <dramforever> bennofs: how am I supposed to install a profiling library for wavy?
08:15:53 <dramforever> "Perhaps you haven't installed the profiling libraries for package `wavy-0.1.0.0'?"
08:16:08 <bennofs> dramforever: how did you install wavy? using cabal install?
08:16:13 <dramforever> yesy
08:16:15 <dramforever> yes
08:17:01 <bennofs> hmm, then set profiling: True in ~/.cabal/config and do cabal install --reinstall world
08:17:27 <dramforever> bennofs: huh? profile the world just for wavy?
08:18:05 <bennofs> dramforever: I just read that might reinstall to much (try --dry-run first). The problem is that all dependencies also need to have profiling enabled
08:18:33 <dramforever> bennofs: hey, what if I know that it's reverseData that is working too much?
08:18:50 <dramforever> that's basically where all looping work is done
08:19:12 <bennofs> dramforever: you can also see what type the data that is eating all the memory has
08:19:30 <Evilsparza> hey guys, is there a way to experiment with lambdabot "in private"? ;) i don't want to spam the whole channel
08:19:42 <bennofs> Evilsparza: /query lambdabot
08:19:42 <dramforever> Evilsparza: /msg lambdabot @help
08:19:45 <clrnd> how am I supposed to append a Bytestring and a Text?
08:19:52 <Evilsparza> thanks
08:20:00 <dramforever> clrnd: encode the Text or decode the ByteString
08:20:11 <dramforever> depending on what you want
08:21:00 <dramforever> bennofs: I can't see profiling in the config
08:21:13 <bennofs> dramforever: oh, maybe it's called library-profiling
08:21:22 <dramforever> oh saw that
08:21:46 <bennofs> dramforever: also, how did you install Haskell? do you use haskell platform?
08:21:47 <EvanR_> clrnd: decodeUtf8 :: ByteString -> Text
08:22:01 <clrnd> thanks both
08:22:05 <dramforever> hmm..reinstalling the world
08:22:46 <dramforever> bennofs: yum install haskell-platform
08:23:44 <dramforever> hmmm, why is reinstalling dangerous?
08:24:27 <bennofs> dramforever: ah, then I think it's better to just rm ~/.ghc and cabal install wavy again
08:24:35 <dramforever> bennofs: !!
08:25:16 <EvanR_> i see people suggest rm ~/.ghc a lot ;)
08:25:18 <bennofs> dramforever: does it install text or things like that?
08:25:47 <dramforever> well, will cabal overwrite existing library files in a way that a reinstallation failed halfway leaves a inconsistent installation?
08:25:54 <albeit> What's the best RTS option to use to reduce the frequency of GC? (This is just for timing, not in production)
08:26:10 <dramforever> bennofs: it says that binary is likely to be broken
08:26:22 <bennofs> dramforever: no, it shouldn't install anything globally  (you can always rm ~/.ghc to get to a clean state again)
08:26:40 <dramforever> bennofs: what's in ghc?
08:26:48 <dramforever> bennofs: what's in ~/.ghc?
08:26:51 <bennofs> dramforever: just files that say which packages you have installed
08:27:01 <bennofs> dramforever: it's the ghc package database
08:27:10 <dramforever> bennofs: so how am I supposed to get the old packages back?
08:27:15 <bennofs> dramforever: for your current user (system packages are somewhere in /usr/lib/...)
08:28:06 <dramforever> hmm
08:28:32 <bennofs> dramforever: just cabal install what you need again, sorry, there is no other way to reinstall at the moment I think (if you leave library-profiling enabled, you won't have to do this again as all packages get profiling support then)
08:29:06 <dramforever> bennofs: well, I did "mv .ghc .oldghc"
08:29:28 * hackagebot opengles 0.6.0 - OpenGL ES 2.0 and 3.0 with EGL 1.4  http://hackage.haskell.org/package/opengles-0.6.0 (capsjac)
08:29:30 <hexagoxel> albeit: afaik the is no control over the "aggressiveness" of gc (i.e. the heap size <-> number of gc runs trade-off), but you can reduce gc runs by increasing minimum heap size (-H2G or the like)
08:29:46 <albeit> hexagoxel: Okay, thanks!
08:29:47 <dramforever> ha! now cabal seems to be starting from scratch
08:31:07 <dramforever> hmm, it seems to be compiling every module twice, first making a .o, then making a .p_o
08:31:12 <dramforever> looks good
08:31:13 <bennofs> dramforever: that's correct
08:31:35 <dramforever> looks like it's going to take a long time
08:31:43 * mjrosenb thought cabal install basically ran 'runhaskell Setup.*hs configure; runhaskell Setup.*hs build', but this project doesn't have a Setup.*hs
08:32:13 <dramforever> mjrosenb: does it have a Makefile?
08:32:19 <dramforever> sometimes people do that
08:32:22 <bennofs> mjrosenb: it only does that when build-type /= Simple
08:32:53 <bennofs> mjrosenb: for build-type = Simple, it just builds the package directly
08:33:05 <mjrosenb> bennofs: ok, what does it do when build-type = Simple?
08:33:19 <mjrosenb> just ghc --make *.hs
08:33:46 <bennofs> mjrosenb: build-type: Simple behaves the same as if ./Setup.hs contained "import Distribution.Cabal.Simple; main = defaultMain"
08:34:08 <bennofs> s/Distribution.Cabal/Distribution
08:35:53 <dramforever> bennofs: hmm...program got much slower when profiling is on
08:36:01 <bennofs> dramforever: yeah, that's normal
08:37:01 <dramforever> bennofs: oh no! just shows a big black rectangle
08:37:17 <bennofs> dramforever: ok, the try +RTS -hy
08:37:22 <dramforever> showing allocation in the beginning and deallocation in the end
08:37:58 <dramforever> bennofs: what's -hy?
08:38:06 <dramforever> with types?
08:38:09 <bennofs> dramforever: memory profile by type.
08:38:45 <dramforever> well, programmers shouldn't tell their boss their program is compiling
08:38:52 <dramforever> they should say it's profiling
08:39:10 <bennofs> dramforever: there is -hc (by cost centre), -hy (by type) and a few others which I don't use often
08:39:24 <dramforever> bennofs: same big rectangle, with type ARR_WORDS
08:39:29 * hackagebot buildwrapper 0.8.10 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.10 (JeanPhilippeMoresmau)
08:39:37 <bennofs> dramforever: you can see all options with +RTS --help
08:39:57 <bennofs> dramforever: ARR_WORDS means that really all memory is spent on bytestrings (memory buffers)
08:40:29 <dramforever> I give up on heap profiling. my program allocates in a simple manner
08:41:15 <dramforever> maybe that's the limit on builder?
08:41:56 <dramforever> I give up. I will get lower level once I learn enough FFI
08:42:12 <dramforever> and do the work in c, in a mutable manner
08:42:25 <dramforever> oh *hard* work
08:45:06 <EvanR_> to reverse a bunch of samples, read through them all prepending them to a ever growing list in memory, then traverse the list in order outputting them the opposite way you read them in
08:45:25 <EvanR_> so that should allocate the same amount of space, but gradually
08:45:31 <EvanR_> and still wont help for very large files
08:46:33 <EvanR_> but it would be more like a triangle than a rectangle, for what its worth
08:49:31 <Fellmin> @pl (\x y z -> map (\a -> z a) y)
08:49:31 <lambdabot> const (flip map)
08:50:35 <Fellmin> @unpl (flip . const map)
08:50:35 <lambdabot> (\ g b c -> map c b)
08:52:03 <Fellmin> @type (flip . const map)
08:52:05 <lambdabot> a -> [a1] -> (a1 -> b) -> [b]
08:52:23 <Fellmin> @unpl (flip const . map)
08:52:24 <lambdabot> (\ g c -> c)
08:52:49 <bennofs> Fellmin: you can /query lambdabot if you want to talk to him in private (all commands also work there)
08:54:23 <Fellmin> @unpl (flip . const . map)
08:54:23 <lambdabot> (\ g b c -> map g b)
08:57:51 <tnks> someone in another channel asked an interesting question I didn't have an answer to:  is there a useful datatype that's got a Functor instance, but no valid Apply or Monad instance?
08:58:05 <Profpatsch> I don’t get whet the compiler wants from me: https://bigmac.caelum.uberspace.de/paste/deduce_int.hs.html
08:58:09 <bennofs> tnks: Const Int
08:58:19 <Fellmin> @unpl (flip (.) const map)
08:58:20 <lambdabot> (\ f -> map (\ _ -> f))
08:58:59 <Profpatsch> Could not deduce (r ~ Int). But r is a Real and Integers are Reals, too. :(
08:59:06 <bennofs> tnks: http://stackoverflow.com/a/7220548/2494803
08:59:16 <geekosaur> Profpatsch, that;s not how it works
08:59:25 <Fellmin> @type (\ f -> map (\ _ -> f))
08:59:27 <lambdabot> b -> [a] -> [b]
08:59:33 <geekosaur> (Real r) there says "the caller decides"; here, you are saying that and then forcing it to be Int
08:59:48 <Fellmin> @type (\ g c -> c)
08:59:50 <lambdabot> t -> t1 -> t1
09:00:11 <geekosaur> that is, if you assert (Real r) then the caller of your function gets to decide what r is. you can't then treat it as if it were Int, because the caller could have chosen something else
09:00:12 <Profpatsch> geekosaur: I checked everything, center has to be an integer in any case.
09:00:54 <geekosaur> the fact that you use it only with Int does not mean the contract "I can take any instance of Real" may be violated
09:01:29 <Fellmin> @unpl (flip const (.) map)
09:01:29 <lambdabot> map
09:01:42 <Profpatsch> geekosaur: But binarySearch is Int -> Int -> Int?
09:01:57 <geekosaur> that proves nothing
09:02:01 <Twey> tnks: Lots of them.  FRP ‘Event’, for example.
09:02:24 <geekosaur> except that you are lying when you assert "I can handle any instance of Real"
09:02:42 <Twey> tnks: Basically anything that lets you transform the value, but doesn't have a concept of combining one value with another
09:03:07 <tnks> Twey: good to know about FRP Event.
09:03:10 <geekosaur> it does not mean "fill in with whatever I actually use later", it is a hard contract "I can and will accept any instance of Real". then you force it to be Int and violate the contract
09:03:27 <Profpatsch> geekosaur: Ah, so the compiler scolds me for that.
09:03:31 <Profpatsch> I see.
09:03:43 <tnks> I knew I could make a fake example, but not one that was compelling.
09:03:46 <Profpatsch> Yes, now that I know what that means it makes sense.
09:04:00 <tnks> I'll have to look more at Const.
09:04:02 <Profpatsch> And it even showed me a logic mistake I made.
09:04:11 <Profpatsch> That’s nice.
09:04:35 <Fellmin> @type (\x y -> const y (map x))
09:04:37 <lambdabot> (a1 -> b) -> a -> a
09:04:52 <geekosaur> *why* it works this way has to do with covariance and contravariance and I usually get a headache trying to understand the theory :) I'll have to leave that to someone else to explain
09:06:26 <Fellmin> @type (\x y z -> map z y)
09:06:28 <lambdabot> t -> [a] -> (a -> b) -> [b]
09:08:30 <Fellmin> @unpl (flip (.) const . map)
09:08:30 <lambdabot> (\ j f -> map j (\ _ -> f))
09:09:15 <Profpatsch> geekosaur: But I can’t divide two Reals?
09:09:47 <benzrf> how can u even have a Real type
09:10:01 <benzrf> arent most reals impossible to represent in finite space
09:10:08 <haasn> You can divide anything that's an instance of Fractional
09:10:11 <haasn> :t (/)
09:10:11 <geekosaur> Profpatsch, no. `div` requires Integral, (/) requires Fractional
09:10:12 <lambdabot> Fractional a => a -> a -> a
09:10:22 <Fellmin> @type (flip (.) const . map)
09:10:23 <lambdabot>     Couldn't match type ‘[a1]’ with ‘b0 -> a’
09:10:23 <lambdabot>     Expected type: (a1 -> b) -> (b0 -> a) -> [b]
09:10:23 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
09:10:38 <wei2912> benzrf: that doesn't mean we can't have a Real type
09:10:40 <geekosaur> Real encompasses types that are instances of one or the other, but can't reconcile them
09:10:53 <Fellmin> @unpl (flip . const (.) map)
09:10:53 <lambdabot> (\ j b c -> j (c b))
09:11:39 <Fellmin> @unpl (flip (.) const (.) map)
09:11:40 <lambdabot> (\ i j -> map)
09:12:05 <Fellmin> @type (flip (.) const (.) map)
09:12:06 <lambdabot> (a -> b) -> a -> (a1 -> b1) -> [a1] -> [b1]
09:12:08 <benzrf> :t Real
09:12:09 <lambdabot>     Not in scope: data constructor ‘Real’
09:12:09 <lambdabot>     Perhaps you meant one of these:
09:12:09 <lambdabot>       ‘Refl’ (line 151), ‘Refl’ (imported from Data.Typeable)
09:12:13 <Profpatsch> But I can divide x and y element ℝ,, normally, can’t I? And it sounds to me like Fractionals are ℚ.
09:12:17 <geekosaur> (It also may encompass types that don't support either)
09:12:33 <benzrf> :t Refl
09:12:34 <lambdabot>     Ambiguous occurrence ‘Refl’
09:12:34 <lambdabot>     It could refer to either ‘L.Refl’,
09:12:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:151:9
09:12:38 <benzrf> :t L.Refl
09:12:39 <lambdabot> Is a a
09:12:48 <benzrf> :t Data.Typeable.Refl
09:12:49 <lambdabot> a1 :~: a1
09:12:49 <geekosaur> the Real typeclass doesn't quite mean the same thing as the mathematical real number line
09:12:50 <Fellmin> @type (\x y -> map)
09:12:51 <lambdabot> t -> t1 -> (a -> b) -> [a] -> [b]
09:13:36 <geekosaur> actually the standard numeric hierarchy is all kinds of messed up, but people get into arguments over how to fix it so it stays weird
09:13:56 <Profpatsch> Ah, ok.
09:14:03 <benzrf> tfw
09:14:14 <Profpatsch> But it’s better than in any C-like language, right?
09:14:58 <geekosaur> there are various alternative numeric preludes on Hackage that fix it in various ways, but generally complicate it in others
09:15:22 <Fellmin> @pl (\x y -> const (\a b -> map a b) (x y))
09:15:22 <lambdabot> (const map .)
09:15:41 <Profpatsch> geekosaur: But I could just constrain my function Type as (Real, Fractional r) =>, right?
09:15:46 <Fellmin> @pl (\x y -> const map (x y))
09:15:46 <lambdabot> (const map .)
09:16:29 <geekosaur> Profpatsch, I am not sure I'd say that (that it's better than C). it's trying to balance between C-like / familiar and "proper" number theory, and in the opinion of many gets both wrong as a result
09:17:01 <geekosaur> (well, there's no arguing it gets number theoretical wrong...)
09:17:17 <Fellmin> @pl (\x -> (const map) . x)
09:17:18 <lambdabot> (const map .)
09:17:19 <Profpatsch> Numerical stacks are one of the hardest thing in language design after all.
09:17:35 <Fellmin> @pl (((.) . const) map x)
09:17:35 <lambdabot> const map
09:17:40 <Profpatsch> Scheme solves it quite elegantly I think.
09:17:55 <JonPage> Hi. I'm new to haskell and I'm confused for why would it not find a module if the module is installed. E.g. , I installed with cabal HandsomeSoup. It installed successfull and cabal shows that the package is there. But when I try to use it, it says that the module is not found. The module is Text.HandsomeSoup. I checken .cabal file of handsome soup and there it shows that indeed this module should be available  "Exposed-modules:   
09:17:59 <Profpatsch> Fellmin: You should be able to /msg lambdabot, too.
09:18:01 <Fellmin> @type (\x y -> const (\a b -> map a b) (x y))
09:18:02 <lambdabot> (t -> b) -> t -> (a -> b1) -> [a] -> [b1]
09:18:03 <benzrf> handsomesoup
09:18:05 <benzrf> is that like beautiful soup
09:18:30 <Twey> But handsomer.
09:18:40 <geekosaur> you could assert (Real r, Fractional r) => , yes
09:19:14 <dcoutts_> JonPage: you say you're trying to use it. How are you doing that exactly?
09:19:52 <dcoutts_> JonPage: and when you say that cabal shows that the package is there, what are you checking exactly?
09:20:18 <JonPage> E.g. I launch GHCI, then I write import Text.HandsomeSoup. It says that it "could not find module Text.HandsomeSoup"
09:20:26 <gcganley> l
09:20:38 <Fellmin> @unpl (flip (.) const . map)
09:20:39 <lambdabot> (\ j f -> map j (\ _ -> f))
09:21:02 <gcganley> @src const
09:21:02 <lambdabot> const x _ = x
09:21:18 <gcganley> :t const
09:21:19 <lambdabot> a -> b -> a
09:21:25 <gcganley> :t seq
09:21:26 <lambdabot> a -> b -> b
09:21:43 <JonPage> dscoutts_: When I run cabal install "HandsomeSoup" it says "All the requested packages are already installed: HandsomeSoup-0.3.4"
09:22:00 <dcoutts_> JonPage: ok
09:23:04 <JonPage> dcoutts_: I also tried writing a simple test.hs file and importing it there, but ghc doesn't compile it and also says that the module is not found
09:23:47 <dcoutts_> JonPage: I'm wondering if you have two ghc instances installed. What does ghc-pkg list HandsomeSoup say?
09:23:50 <geekosaur> you aren't doing that cabal install under sudo, right?
09:24:59 <JonPage> dcoutts_: Oh. "ghc-pgk list HandsomeSoup" says that there are broken packages.
09:25:27 <dcoutts_> that may or may not be relevant, can you put the output of it in a pastbin, if it's more than a couple lines
09:27:01 <JonPage> dcoutts_: http://pastebin.com/w6QamRuW
09:28:24 <dcoutts_> JonPage: and ghc --version says it's 7.8.3 right?
09:28:44 <JonPage> dscoutts_: yes
09:29:20 <rribeiro> Hello all! Can someone tell me if there's exist some library (similar to quickcheck) that allows the specification of LTL properties?
09:29:31 <dcoutts_> JonPage: what does this report: ghci -package HandsomeSoup-0.3.4
09:29:35 * hackagebot cipher-aes 0.2.9 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.9 (VincentHanquez)
09:29:37 * hackagebot cprng-aes 0.6.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.6.0 (VincentHanquez)
09:30:01 <Profpatsch> geekosaur: How do people normally do it? Just use Ints and Doubles?
09:30:07 <dcoutts_> JonPage: btw, this is unusually odd, so no need to feel stupid :-)
09:30:25 <JonPage> dcoutts_: HandsomeSoup-0.3.4-634c397363f89ca7af8c7e827a57fd9b is unusable due to missing or recursive dependencies:
09:30:33 <geekosaur> Profpatsch, yes
09:30:54 <dcoutts_> JonPage: when you listed it with ghc-pkg, was it listed in red?
09:31:00 <geekosaur> directly using the others tends to be problematic, in large part because of the weird structure of the numeric hierarchy
09:31:13 <geekosaur> which is why there's so many alternative numeric preludes running around
09:31:16 <Profpatsch> geekosaur: I assume that’s a fair bit faster, too.
09:31:24 <geekosaur> depends
09:32:00 <Profpatsch> Yeah, I see what you mean by weird numeric hierarchy.
09:32:10 <JonPage> dscoutts: I have only white color in ghc-pkg. It says that there are broken packages.
09:32:25 <Profpatsch> I can’t get Integrals, Reals and Fractionals to work together in an easy way.
09:32:32 <Profpatsch> Mkay.
09:32:42 <Profpatsch> Yet another thing learned.
09:32:52 <dcoutts_> rribeiro: may or may not be helpful: http://hackage.haskell.org/packages/search?terms=LTL
09:32:55 <geekosaur> I think if the compiler can resolve the typeclasses at compile time and/or has SPECIALIZE pragmas for key stuff, it can make most of the overhead go away
09:33:34 <dcoutts_> JonPage: ok, can you put the full output from the ghci command in a pastebin, where it tells us details about the broken package
09:33:52 <Evilsparza> is there a way where I can go through a list and have an indicator that tells me at which position of the list I am?
09:33:54 <geekosaur> also resolving Integral vs. Fractional is just something you must live with; nothing will automatically "coerce" an instance of Integral to an instance of Fractional, you need to use fromIntegral
09:34:00 <JonPage> dcoutts: http://lpaste.net/113039 this?
09:34:08 <dcoutts_> JonPage: this is unusual, usually ghc-pkg will list broken packages in red, and also cabal install will consider broken packages as if they were not installed and re-install.
09:34:36 <geekosaur> Evilsparza, not /per se/, but you might look at zippers which are an alternative representation of lists. there's also Data.Seq
09:35:26 <dcoutts_> JonPage: ok, can you also paste the output of ghc-pkg check, it'll be long
09:35:54 * dcoutts_ is surprised that ghc-pkg & cabal do not consider the package broken, when ghc does
09:36:28 <dcoutts_> JonPage: likely the workaround here is to tell cabal to really reinstall it, but it's quite odd that ghc thinks its broken when cabal and ghc-pkg do not.
09:37:14 <JonPage> dscoutts_: http://pastebin.com/5PM7NSWc
09:37:27 <JonPage> dcoutts_: http://pastebin.com/5PM7NSWc
09:37:44 * dcoutts_ looks
09:42:46 <dcoutts_> JonPage: ok, well this is quite odd. ghc is convinced the package is broken, but ghc-pkg's analysis says it is not. On the other hand you do have a ton of broken packages and it'd be sensible to clean those all up.
09:44:02 <dcoutts_> JonPage: once you've got no more broken packages, then try cabal install --reinstall HandsomeSoup
09:44:34 <dcoutts_> JonPage: and if you want to reinstall any of the broken ones, then you can tell cabal to do that, but do them all together in one command, not separately
09:45:13 <dcoutts_> JonPage: as for cleaning up the broken ones, ghc-pkg unregister --user pkg1 pkg2    etc, possibly with --force
09:45:33 <dcoutts_> JonPage: and then make sure ghc-pkg check reports no broken packages
09:46:43 <dcoutts_> JonPage: in theory this should not be necessary because cabal and ghc-pkg and ghc should all agree on what a broken package is, and cabal considers broken packages just as if they were not installed in the first place. But we seem to have hit some odd case where ghc and ghc-pkg disagree.
09:48:05 <shanthakumar> @pl tf n = filter (\(a, b) -> a == n || b == n)
09:48:06 <lambdabot> tf = filter . (`ap` snd) . (. fst) . ap (flip . (((.) . (||)) .) . (==)) (==)
09:49:10 <sm> Tina> I tried sending a test e-mail to the 3 new e-mails set up for cvriverside and I received this failure notice. Am I doint something wrong?
09:49:10 <sm> Tina Fitzgibbons
09:49:10 <sm> Contracts Manager
09:49:10 <sm> Champion Windows, Inc
09:49:14 <sm> P.O. Box 800836
09:49:18 <sm> Santa Clarita Ca. 91380
09:49:21 <sm> 661-295-5930 x.230
09:49:22 <sm> 661-295-0164 (fax)
09:49:25 <sm> --- On Wed, 3/10/10, MAILER-DAEMON@yahoo.com <MAILER-DAEMON@yahoo.com> wrote:
09:49:30 <sm> From: MAILER-DAEMON@yahoo.com <MAILER-DAEMON@yahoo.com>
09:49:33 <sm> Subject: failure notice
09:49:36 <sm> To: tinafitzg@sbcglobal.net
09:49:39 <sm> Date: Wednesday, March 10, 2010, 2:43 PM
09:49:42 <sm> Hi. This is the qmail-send program at yahoo.com.
09:49:43 <sm> I'm afraid I wasn't able to deliver your message to the following addresses.
09:49:46 <sm> This is a permanent error; I've given up. Sorry it didn't work out.
09:49:49 <sm> <barbara.s@cvriverside.biz>:
09:49:50 <josephle> umm, what
09:49:52 <sm> CNAME lookup failed temporarily. (#4.4.3)
09:49:55 <sm> I'm not going to try again; this message has been in the queue too long.
09:50:00 <sm> <accounting@cvriverside.biz>:
09:50:03 <sm> CNAME lookup failed temporarily. (#4.4.3)
09:50:06 <sm> I'm not going to try again; this message has been in the queue too long.
09:50:09 <sm> <rich.w@cvriverside.biz>:
09:50:12 <sm> CNAME lookup failed temporarily. (#4.4.3)
09:50:13 <sm> I'm not going to try again; this message has been in the queue too long.
09:50:16 <sm> --- Below this line is a copy of the message.
09:50:19 <sm> Return-Path: <tinafitzg@sbcglobal.net>
09:50:22 <sm> Received: (qmail 67317 invoked by uid 60001); 9 Mar 2010 21:43:45 -0000
09:50:25 <sm> DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=sbcglobal.net; s=s1024; t=1268171025; bh=SQ/qgtJBIijQmN/d/x8OK3PVueAQVXwZOuMeDxjuxrw=; h=Message-ID:X-YMail-OSG:Received:X-Mailer:Date:From:Subject:To:MIME-Version:Content-Type; b=Hhv1zFASBPeV3QOSc9sBvakeIPv9HNgvJtRKxZXqN+mWwjhT+3XQsWqQX0A9qK/aPHU1qxxOnS2uIk1ZuS9NwBTb0HyprYYPke9aBxIgJqnSrR0uFzW9lMJZlvQekZyMrZRNpZ9KEOYIUQ5TR1YLDhTJSCquVLb2m5ZUcjXjINk=
09:50:27 <sivteck> sm, o_O
09:50:30 <sm> DomainKey-Signature:a=rsa-sha1; q=dns; c=nofws;
09:50:33 <sm>   s=s1024; d=sbcglobal.net;
09:50:36 <sm>   h=Message-ID:X-YMail-OSG:Received:X-Mailer:Date:From:Subject:To:MIME-Version:Content-Type;
09:50:39 <sm>   b=Ot5k6wipBrpdUWE0VV/5k+RwGm8Jc3imw7d4WezCDvopo93deBoQMmWnBlJliMbowgJfcLxE09KUaCXmmKA4iU/trhmJM8SSEcTnzsB25zeS01ShHqdSPwSUcfWvFmKYMEJubXsXClGZ08WniHYXiJ/Jg9lpkSeCp1Hc9fB1Q9A=;
09:50:41 <sivteck> @where ops
09:50:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:50:42 <sm> Message-ID: <119568.67272.qm@web81602.mail.mud.yahoo.com>
09:50:43 <sm> X-YMail-OSG: r9zIe7EVM1k7uK15JD_UcibkKNVOw13kMPvw8Ug8MZodZm_
09:50:46 <sm> .MZ2iW1eFkfEFw7onDYm3tma.fRnEOzNRsqM5IdCVU2S5e68fMfjQZsNIQkP
09:50:48 --- mode: ChanServ set +o glguy
09:50:49 <sm> HyLsIXvE8kB6nPkY8QhEg1TLxsA4vqq7M4D7PEXCtK612lhlSTx7JdgLw9iH
09:50:52 --- kick: sm was kicked by glguy (Your behavior is not conducive to the desired environment.)
09:51:01 --- mode: ChanServ set +o dcoutts
09:51:02 <shapr> MISPASTE
09:51:09 <shapr> poor simon
09:51:11 --- mode: ChanServ set -o dcoutts
09:51:20 <shapr> I like sm
09:51:25 --- mode: glguy set -o glguy
09:51:45 <hc> oh interesting... first time i see someoe kicked from #haskell ;-)
09:51:53 <shapr> hc: oh, it happens
09:51:55 <shapr> believe me, it happens
09:52:07 * shapr fires up the banhammer
09:52:09 <josephle> we're not immune to occasional bouts of spam
09:52:14 --- mode: ChanServ set +o shapr
09:52:17 --- kick: shapr was kicked by shapr (Kicked by shapr)
09:52:28 <geekosaur> ,,,
09:52:32 <shapr> well that was exciting
09:52:40 <shapr> hc: SEE? It totally happens!
09:52:41 <hc> lol shapr
09:53:25 <cmtptr> I've been thinking about pasting spam in this channel.  good idea or bad idea?
09:53:27 <shapr> hc: you writing some cool Haskell code today?
09:53:37 <shapr> cmtptr: depends on whether you want to get kicked
09:53:54 <hc> shapr: no, i have been debugging non-haskell code all day
09:54:03 <Profpatsch> geekosaur: But it looks like I can just use Integer and Rational instead of Int and Double and be happy. :)
09:54:04 <hc> now i'm too exhausted ;)
09:54:06 <shapr> hc: yeah, me too :-(
09:54:44 <geekosaur> you might be happy, you might not
09:55:02 <geekosaur> you can make it work but there are some weird corner cases IIRC
09:55:20 <geekosaur> some of which lead to code which compiles but is unexpectedly sow
09:55:20 <Profpatsch> geekosaur: Ha, yeah. If I want to test my function with pow(3, x) it blows up.
09:55:21 <geekosaur> *slow
09:55:39 <Profpatsch> So, no 3**x, no 3^x and no 3^^x
09:57:29 <sm__> kicked too fast to apologise, so: I'm very sorry, folks. I don't seem to be able to drive emacs & erc & osx paste key safely. :-( I will find a solution asap.
09:57:45 <Profpatsch> Or is there some power operation of Rationals?
09:57:46 <merijn> carter: You wanted to see my launchd scripts after I mentioned them last weekend, right? Or am I imagining things?
09:57:52 <Profpatsch> *on Rationals
09:58:08 <JonPage> dscoutts_: Ok. Thank you a lot! That issue was driving me crazy. I'll try to clean and reinstall broken  packages.
09:58:22 <JonPage> dcoutts_: Ok. Thank you a lot! That issue was driving me crazy. I'll try to clean and reinstall broken  packages.
09:58:39 * shapr hugs sm__
09:59:06 <josephle> sm__, no problem. Just double check before pasting :)
10:00:00 <dcoutts_> sm__: no probs, bad luck
10:01:53 <Yxven> Apparently, the most minimal gloss projects cannot be profiled and cause the profiler to fail silently
10:03:05 <Profpatsch> Why is there no power function for Rationals?
10:03:32 <Profpatsch> x^(3/7) seams perfectly reasonable to mee.
10:03:47 <Profpatsch> *me ; Or is there a special conversion function I first have to use?
10:04:23 <Liskni_si> 2^(1/2) isn't rational
10:05:04 <Profpatsch> Liskni_si: You mean because of the special cases?
10:05:53 <Profpatsch> Hm, so no symbolic engine, no fractional powers.
10:06:07 <Profpatsch> Makes sense I guess.
10:06:09 <Liskni_si> um, I don't know, I was perhaps too quick with the answer
10:09:39 * hackagebot binary-list 0.3.4.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.4.0 (DanielDiaz)
10:10:42 <Profpatsch> Liskni_si: Nah, I guess that seems like a good reason.
10:13:34 <merijn> Profpatsch: What's wrong with ** ?
10:14:32 <codygman> Is there a way to encode "only lists with 2 items" into the type system?
10:14:41 <merijn> codygman: It depends :)
10:15:03 <vanila> you can use pairs like this (x,y)
10:15:05 <merijn> codygman: In standard haskell? Not really. In -XKitchenSink haskell? Sure.
10:15:12 <vanila> type (a,a)
10:15:18 <codygman> merijn: I'm okay with -XKitchenSink ;)
10:15:20 <ReinH> merijn: I wish that was a real extension.
10:15:53 <merijn> codygman: Here's an example of "lists that must have 3 or less elements": https://gist.github.com/merijn/39dc86e345e87276c523
10:16:11 <codygman> merijn: Thanks, I'll try to work it out from there :)
10:16:12 <merijn> Indexing is a bit tricky atm, though
10:16:47 <merijn> You need to lift the index number to the type level. The Singletons paper talks about that, but I haven't really used that trick
10:17:13 <merijn> codygman: Different inspiration, along the same lines: https://gist.github.com/merijn/dc00bc7cebd6df012c5e heterogeneous lists
10:17:26 <codygman> merijn: Interesting, do you have a link to said singletons paper? I also found the non-empty package claims to do what I need: http://hackage.haskell.org/package/non-empty
10:18:02 <merijn> codygman: There's a link in the docs
10:18:05 <merijn> @hackage singletons
10:18:05 <lambdabot> http://hackage.haskell.org/package/singletons
10:18:23 <josephle> merijn: am I correct in assuming the size of the type of a heterogenous list is linear?
10:18:37 <codygman> merijn: Thanks, didn't make the connection of "he's talking about the singletons library on hackage".
10:20:43 <merijn> josephle: Correct
10:20:57 <merijn> josephle: But types have no runtime cost, so that's fine :)
10:21:22 <josephle> does it have a significant impact on compiletime?
10:21:42 <merijn> codygman: There was also a talk by Stephanie Weirich on "dependently typed haskell", check youtube
10:22:22 <merijn> josephle: This type? I wouldn't expect so, unless you hardcode insanely long lists and even *then* I wouldn't expect it to be much of a problem
10:22:40 <josephle> hmm, that's true
10:23:03 <merijn> josephle: I can just give you an empirical "I've never noticed any slow down at all"
10:23:27 <josephle> that's good enough for me :)
10:23:47 <merijn> And if I'm pimping neat tricks anyway
10:24:07 <merijn> My favourite one: https://gist.github.com/merijn/6130082
10:24:40 * hackagebot binary-list 0.3.4.1 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.4.1 (DanielDiaz)
10:24:58 <hager> i am trying to connect from GHCi to "chat.freenode.net" but it gives me "Couldn't look up your hostname, No Ident response" can anyone hepl me ?
10:25:46 <S11001001> hager: that's a normal message from the server, not a connection error
10:26:40 <hager> but i can't locate where is the problem ? what should i do ?
10:28:47 <texasmynsted> What should I do if I get errors attempting to install something simple using cabal?
10:28:56 <texasmynsted> well, not sure if simple really
10:28:58 <dcoutts_> depends on the error
10:29:00 <texasmynsted> installing snap
10:29:34 <blah> Hi everyone, I was reading up on types and I just defined my function as "let mysum x = x+2"; Then I tried doing a ":type mysum" and I get a "mysum :: Num a => a -> a" -- why is that?
10:29:36 <texasmynsted> I get more that a page of packages listed then "Use --force-reinstalls if you want to install anyway."
10:30:13 <blah> Id expect something like "Num -> Num" Or "Int -> Int"
10:30:18 <texasmynsted> Oh here is the message at the top "cabal: The following packages are likely to be broken by the reinstalls:"
10:30:24 <ReinH> blah: are you familiar with typeclasses?
10:30:38 <merijn> texasmynsted: It means the version of snap you're trying to install wants newer versions of your dependencies than you have, try using a sandbox unless you're willing to learn how to manage your installed global dependencies
10:30:45 <texasmynsted> what is the correct channel for asking my question?
10:30:58 <merijn> blah: Because 2 is a polymorphic literal
10:31:06 * texasmynsted googles cabal sandbox
10:31:10 <blah> ReinH: Not really, I'm just reading up on them. I'm following a course and edx and I'm working through the exercises on my ghci prompt.
10:31:12 <merijn> blah: It can be *any* numeric type, also, for example, Double
10:31:20 <ReinH> :t 2
10:31:20 <lambdabot> Num a => a
10:31:27 <merijn> blah: For example, try "myadd 4.3"
10:31:45 <ReinH> :t (+)
10:31:45 <lambdabot> Num a => a -> a -> a
10:31:56 <merijn> blah you can read "Num a => a -> a" as follows
10:32:20 <merijn> blah: "IF 'a' is an instance of the Num typeclass THEN this function has type 'a -> a' ELSE type error"
10:33:07 <blah> merijn: I see
10:33:14 <blah> thank you merijn ReinH !
10:33:18 <blah> That helps loads!
10:33:24 <merijn> blah: The reason for this is the (+) works for *any* numeric type and '2' is a polymorphic numeric literal (i.e. it can be any numeric type). So the type of your function and it's result isn't determined until you try to use it with something with a more precise type
10:33:28 <merijn> Consider
10:33:46 <jhance> I guess I'm unique in reading it as Num a tisgar a hepgar a
10:33:47 <merijn> :t let mysum x = x+2 in mysum 4
10:33:47 <lambdabot> Num a => a
10:34:04 <merijn> You can even have polymorphic results!
10:34:29 <merijn> :t let mysum x = x+2 in mysum (4 :: Double) -- telling GHC I want '4' to be a Double, instead of polymorphic
10:34:30 <lambdabot> Double
10:35:01 <blah> Interesting!
10:35:25 <texasmynsted> hmm.  So say I want to create 'foo' using snap.  I mkdir 'foo-project' then 'cd foo-project'  then 'cabal sandbox init' then what?
10:35:42 <texasmynsted> Then if I cabal install snap, will it be installed in a sandbox form?
10:35:46 <dcoutts_> texasmynsted: yep
10:36:00 <jhance> I don't get why its okay to give types like Num a => a -> a -> a but not okay to make map work with functors because of the "complicated error message for beginners"
10:36:14 <texasmynsted> I still get the same errors
10:36:33 <texasmynsted> so I should just --force-reinstalls ?
10:36:44 <texasmynsted> and that will not harm my global haskell install?
10:36:45 <dcoutts_> texasmynsted: this is now ok within the sandbox. It's true that those globals will be broken within the sanbox, but that's ok.
10:36:46 <jhance> texasmynsted: force-reinstalls is basically safe in a sandbox to my knowledge
10:37:01 <merijn> jhance: political inertia + it doesn't hurt bad enough for anyone to bother change + sometimes monomorphic map is clear to have to avoid confusion due to accidentally using the reader monad or something silly
10:37:22 <merijn> jhance: In other words, not enough people mind enough to change it
10:37:31 <texasmynsted> would "cabal install --only-dependencies" do anything for me?
10:37:52 <merijn> jhance: Took how long AMP took to happen and the lack of AMP actually hurts in real code, as opposed to "I need to write an actual character:
10:37:55 <jhance> texasmynsted: I usually do that before I build the project just to get it out of the way
10:38:08 <texasmynsted> ok
10:38:09 <dcoutts_> texasmynsted: depends what target you're asking it to install the deps of
10:38:20 <dcoutts_> texasmynsted: so if that's your own project, then yes that makes perfect sense
10:38:49 <jhance> merijn: I'm so excited about AMP but I think everyone is
10:39:04 <texasmynsted> I just want to try the snap framework
10:39:09 <carter> merijn: i'd be interested
10:39:11 <texasmynsted> I do not even have a test project
10:39:17 <merijn> jhance: I'm more excited about the Foldable/Traversable in Prelude, which everyone seems to forget :p
10:39:21 <dcoutts_> texasmynsted: so you'll have to have created your .cabal file to do that of course (e.g. using cabal init)
10:39:39 <merijn> carter: https://github.com/merijn/dotfiles/tree/master/install/tarsnap
10:39:41 <dcoutts_> texasmynsted: then just do cabal install snap within the sandbox
10:40:02 <dcoutts_> texasmynsted: you can add your own project (as a cabal package) later if you want
10:40:11 <texasmynsted> with the "—force-reintalls"
10:40:19 <merijn> carter: The com.tarsnap.backup.plist should (cross fingers, to do is the first run where I test it running automatically...) run every day at 12
10:40:38 <texasmynsted> because it does nothing without that evidently
10:40:53 <dcoutts_> texasmynsted: once it's installed, you need to use cabal repl, or cabal run bash, to get an env that's inside the sandbox
10:41:14 <merijn> carter: Or alternatively https://github.com/merijn/dotfiles/blob/master/install/notify/com.dotfiles.notify.plist runs every time there's files in any of the QueueDirectories
10:41:24 <carter> merijn: this is cool
10:41:29 <carter> i'm gonna look at this over teh weekend or something
10:42:01 <merijn> carter: The manual pages and docs of Apple are truly excellent too, I'm really impressed which is not usually the case with docs :p
10:42:12 <texasmynsted> ok.  I wish it would tell me it will not harm my global install
10:42:19 <carter> also i dind't know shells have the trap command to run on signals
10:42:26 <merijn> carter: The only moderately annoying thing is the inability to launch user agents relative to the user's home dir, but that's ok
10:42:46 <merijn> carter: Neither did I, which is why it took so long for me to implement/test and push this for others to see :p
10:42:55 <carter> looks well engineered
10:42:56 <carter> good job
10:43:15 <merijn> carter: I'm *fairly* confident in surviving all obvious and most unobvious errors/conditions
10:44:34 <merijn> carter: You can have launchd watch for filesystem events and have it dynamically launch you upon incoming sockets (network and filesystem) too, although I haven't played with that yet
10:44:44 <carter> woah
10:44:46 <carter> so like
10:44:54 <carter> OS X is from the future, but we  just dont use the future?
10:45:09 <merijn> carter: Pretty much
10:45:23 <merijn> I plan to use this more in the near future
10:45:41 <merijn> See for detailed docs: https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i-SW1-SW1
10:46:01 <merijn> I really should browse Apple docs more often
10:47:23 <texasmynsted> :-) I think Apple benefited from the ethos of good documentation found with the BSDs.
10:48:21 <texasmynsted> this is nice explanation https://github.com/ericrasmussen/learn-snap
10:52:22 <sm> fellow erc/mac users, learn from my mistake: enable erc-accidental-paste-threshold-seconds. Also consider disabling cmd-v key in iterm2.
10:54:38 <chrisdone> any sublimetext power users?
10:54:43 * hackagebot jukebox 0.1.2 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.1.2 (NickSmallbone)
10:54:45 * hackagebot persistent-postgresql 2.1.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.0.1 (MichaelSnoyman)
10:55:36 <chrisdone> also vim gurus
10:56:42 <merijn> chrisdone: Check for the latter
10:57:43 <merijn> chrisdone: Whatcha need?
10:58:25 <chrisdone> merijn: so in vim i recently learned that you can control sub processes and press a command to switch from vim to that process. like ghc with compile errors and then hit a key to go to "next error" right?
10:58:42 <chrisdone> well, by hit a key, i mean :ne
10:59:05 <pjdelport> chrisdone: "control a subprocess"?
10:59:31 <chrisdone> pjdelport: i think in the case of running ghc and then reading its output as a pipe, for example
10:59:44 <pjdelport> Do you just mean invoking a command like with :make? Or actual concurrent subprocess control (which is a bit different)?
10:59:55 <chrisdone> actual concurrent subprocess control
11:00:26 <pjdelport> Vim doesn't let you do that directly (although people have written extension that provide that kind of thing)
11:00:39 <UnrealQuester> also there is neovim
11:00:42 <chrisdone> can you have ghci running and get it to run :l or :r by hitting some keys?
11:00:56 <chrisdone> and then :t to get the type of the identifer at point?
11:01:00 <UnrealQuester> maybe you wanr something like syntastic
11:01:01 <joelteon> if only
11:01:04 <merijn> chrisdone: Usually what's done is that an extension population a quickfix/locationlist and you use vim's standard bindings to follow those
11:01:17 <merijn> s/population/populates
11:01:20 <joelteon> yeah, vim's interoperation with subprocesses is really abysmal
11:01:56 <pjdelport> chrisdone: Ah, that's the kind of thing that hdevtools provides.
11:02:02 <merijn> I don't really see that as much of a problem
11:02:07 <joelteon> syntastic is blocking, for example
11:02:31 <merijn> I don't think chrisdone is interested in existing plugins, but the tools such plugins have and what they want from, say, ghci? :)
11:02:33 <pjdelport> chrisdone: It runs its own daemon process, though, which makes it easy for stuff to integrate without worrying about full subprocess control from your editor.
11:02:47 <pjdelport> There is a Vim plugin for it that will let you do things like get the type at the cursor.
11:03:01 <pjdelport> (And Syntastic will also detect and use it automatically.)
11:03:20 <HeladoDeBrownie> I found an amusing abuse of Monad. A Monad fail, if you will: http://hackage.haskell.org/package/bimap-0.2.4/docs/Data-Bimap.html#v:lookup
11:03:40 <chrisdone> hmm -- so in the case of hdevtools you run a server and then vim will run it for blocking one-shot commands that manages talking to the server?
11:04:08 <pjdelport> chrisdone: Well, the server gets started automatically on first demand.
11:04:16 <pjdelport> hdevtools manages that itself.
11:04:42 <merijn> chrisdone: Yeah
11:04:44 * hackagebot persistent 2.1.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.0.1 (MichaelSnoyman)
11:04:45 <pjdelport> From the editor's point of view it just invokes hdevtools in an effectively non-blocking fashion.
11:04:46 <chrisdone> i see
11:04:48 <HeladoDeBrownie> This is one of the oddest cases of what I'll call "premature promotion" that I've seen. E.g., we only *need* to use Maybe to encode our results, but we use any general Monad instead. I'm curious if others have seen worse abuses.
11:05:03 <merijn> chrisdone: The biggest issue is that editing is stuck until type checking finishes in case of, for example, syntastic
11:05:04 <pjdelport> (The actual invocation blocks, but it just talks to the server, without re-analyzing everything.
11:05:06 <pjdelport> )
11:05:22 <merijn> chrisdone: There have been proposals to make syntastic async, but it's unclear how to do so within vim :\
11:05:32 <pjdelport> HeladoDeBrownie: The far better way to generalize that would be with Alternative.
11:05:47 <pjdelport> pure result or empty
11:05:48 <HeladoDeBrownie> pjdelport, agreed. Personally, I'd still stick with Maybe and then let the user promote it though.
11:05:54 <chrisdone> what if ghci could be started as a server? so that you could call a blocking command that would connect to the local ghci, run a command and return?
11:06:12 <HeladoDeBrownie> pjdelport, it's related to the question of whether it'd be better to have IO a everywhere or (MonadIO m) => m a
11:06:12 <pjdelport> HeladoDeBrownie: Well, the generalization doesn't hurt. They can still use it with Maybe just like that. :)
11:06:13 <merijn> chrisdone: I don't know what advantage that would have over hdevtools?
11:06:14 <Fellmin> @type (flip (.) const map)
11:06:16 <lambdabot> a -> [b] -> [a]
11:06:20 <chrisdone> would that be useful or are you happy with the status quo
11:06:28 <ReinH> chrisdone: "next error" is handled by vim's :make and quicklist functionality (there are help pages for both)
11:06:29 <Fellmin> @unpl (flip (.) const map)
11:06:29 <lambdabot> (\ f -> map (\ _ -> f))
11:06:34 <merijn> chrisdone: hdevtools currently uses the GHC API and can also do things like query types of inline expressions
11:07:07 <merijn> chrisdone: Plus it has support for cabal files and sandboxes to properly typecheck and work with those
11:07:12 <chrisdone> i recently added this functionality to ghci and am wondering whether we can render hdevtools and ghc-mod redundant
11:07:15 <ReinH> :make runs an external process ('makeprg') and parses its output using 'errorformat' into the quicklist
11:07:17 <HeladoDeBrownie> pjdelport, hmm, I guess there could be value in promoting it. I guess I was unsafely assuming that it's better to not promote unless you have reason to do so, but I guess I'd need to look at arguments for both.
11:07:32 <ReinH> So named because the external process is often `make`.
11:08:01 <ReinH> pjdelport: or MonadPlus if you really need it to be a monad for some reason, I guess
11:08:01 <merijn> chrisdone: I think it'd be hard to obsolete all uses of the GHC API/hdevtools features in ghci without adding dependencies on, for example, cabal and sandboxes
11:08:10 <HeladoDeBrownie> pjdelport, one obvious argument against is ambiguous type variable errors
11:08:14 <pjdelport> ReinH: But hopefully AMP, soon!
11:08:19 <HeladoDeBrownie> But that could be mitigated by something
11:08:21 <ReinH> pjdelport: true
11:08:54 <AleksejsHome> Hi, how do I print out IO [Int] ?
11:08:57 <pjdelport> HeladoDeBrownie: Right. It depends on the API in question, and whether users would practically benefit from consuming it in ways other than Maybe.
11:09:15 <chrisdone> merijn: ghci is configured automatically with cabal repl
11:09:21 <HeladoDeBrownie> AleksejsHome, if x :: IO [Int], then x >>= print
11:09:37 <HeladoDeBrownie> AleksejsHome, in do notation: { x' <- x ; print x' }
11:10:04 <AleksejsHome> HeladoDeBrownie: thanks!
11:10:06 <chrisdone> merijn: is there a project that hdevtools works with that ghci or cabal repl won't?
11:10:07 <HeladoDeBrownie> Woop, missed the do
11:10:09 <pjdelport> Or "print =<< x", if you'd rather think of =<< as an application operator, like $ but for monadic values :)
11:10:22 <merijn> chrisdone: I don't know
11:10:31 <merijn> chrisdone: Can ghci report types of inline expressions?
11:10:41 <chrisdone> merijn: the version i patched can
11:10:57 <chrisdone> merijn: https://github.com/chrisdone/ghci-ng/#features
11:11:08 <ReinH> There are plugins that give vim async functionality
11:11:34 <merijn> ReinH: They're hacks that rely on "instant" window resizings or similar, usually
11:11:37 <ReinH> They are a bit dodgy, though
11:11:41 <merijn> ReinH: No satisfactory solutions
11:11:53 <ReinH> merijn: have you seen Dispatch?
11:12:32 <merijn> chrisdone: Ok, then maybe it'll be good enough. The only other feature I can think of that's worth a lot to me is hdevtools ability to show the src for an identifier/datatype/type and let me jump to it's location
11:12:39 <ReinH> Maybe one day neovim will replace vim
11:13:07 <ReinH> merijn: chrisdone's ghci-ng does both. It's rather nice.
11:13:08 <UnrealQuester> or at least some of its functionality will be brought to vim
11:13:19 <ReinH> (Although he still needs to add C-u C-c C-t to print the type ;)
11:13:25 <mr-> ReinH: 59% done ;-)
11:13:28 <chrisdone> merijn: i've implemented go to definition, via the :loc-at command. displaying the source should be straight-forward
11:13:39 <ReinH> UnrealQuester: unlikely if you've ever looked at vim's source code
11:13:54 <merijn> chrisdone: ok, then that probably most of my usecases
11:14:12 <chrisdone> merijn: the reason i'm asking about vim is that it would be neat to get emacs, vim and sublime support to this ghci-ng and then i can announce it and people will consider it practical for ghci vanilla to be smart enough to do these things
11:14:13 <merijn> UnrealQuester: Yeah, I agree with ReinH. I've looked at the source to "hack a simple feature" into vim
11:14:23 <joelteon> it's awful!
11:14:25 <ReinH> merijn: it's amazing that vim works at all.
11:14:28 <merijn> I gave up, vim source is a horrific, unmaintainable, unextendable mess
11:14:34 <joelteon> If only any other editor was usable :(
11:14:42 <merijn> It should be quarantined, or better, taken out back and shot
11:14:43 <ReinH> joelteon: I use vim and emacs :)
11:14:47 <merijn> joelteon++
11:14:55 <ReinH> merijn: well, that's the goal with neovim, I guess.
11:14:56 <joelteon> I use emacs and its vim emulation is pretty good
11:14:57 <UnrealQuester> there is emacs and evil mode if you need it
11:15:02 <ReinH> a cleanroom reimplementation
11:15:05 <joelteon> but I can't really get into it
11:15:08 <joelteon> i'm not smart enough
11:15:12 <ReinH> I use emacs without vim emulation
11:15:16 <ReinH> I can't stand vim emulations
11:15:24 <joelteon> emacs has the best vim emulation I've ever used
11:15:25 <merijn> UnrealQuester: I tried evil mode it's not bad, but not near usable\
11:15:31 <ReinH> They always miss something that's in my muscle memory
11:15:31 <HeladoDeBrownie> I haven't looked at Vim's source, so as to preserve my sanity, but I've used Vim script and that was pretty bad
11:15:36 <ReinH> 80% of vim is worse than no vim at all for me
11:15:38 <merijn> Especially given that all my familiar extensions break
11:15:58 <chrisdone> emacs has a similar problem to vim actually
11:16:00 <merijn> HeladoDeBrownie: vimscript is wonderfully sane and well-designed compared to the vim source code
11:16:04 <ReinH> HeladoDeBrownie: Yes, VimL is an atrocity
11:16:06 <HeladoDeBrownie> ReinH, I bet you've experienced this too: Sometimes I'm typing a reply in a browser, and I want to delete a word, so I close the browser tab.
11:16:16 <merijn> HeladoDeBrownie: :D
11:16:18 <ReinH> HeladoDeBrownie: hahaha
11:16:31 <chrisdone> its flycheck support (similar to :make) *assumes* launching a binary. which is annoying if you just want to tell ghci :r
11:16:38 <clrnd> HeladoDeBrownie, totally
11:16:57 <UnrealQuester> there are browser plugins for that though
11:17:04 <UnrealQuester> like vimperator for firefox
11:17:14 <UnrealQuester> or you can launch an external editor
11:17:16 <merijn> They never quite work
11:17:17 <clrnd> UnrealQuester, vimperator still closes tabs with Ctrl-W
11:17:34 <merijn> If I ever have nothing to do, I'm designing a fully modal OS
11:17:40 <ReinH> vimperator has been replaced by pentadactyl since the original maintainer is basically not supporting vimperator any more
11:17:41 <clrnd> I tried it but binding being 'almost quite equal' is way worse than having nothing at all, for me
11:17:44 <ReinH> pentadactyl is rather nice
11:17:48 <merijn> Modal interfaces everywhere!
11:17:52 <UnrealQuester> currently using pentadactyl and quite happy with it
11:17:56 <ReinH> clrnd: exactly
11:18:06 <JonPage> Is there any Haskell insta-REPL for vim? My dream is using ghci with vim bindings.
11:18:23 <joelteon> Nope
11:18:27 <ReinH> JonPage: you can run ghci in a vim shell o_O
11:18:32 <merijn> JonPage: I just use vim + ":reload"
11:18:36 <UnrealQuester> can you not make vim bindings work in ghci
11:18:36 <ReinH> (but you'll need a vim shell plugin, all of which are buggy)
11:18:48 <rrradical> JonPage: http://trac.haskell.org/haskeline/wiki/UserPrefs
11:18:49 <ReinH> Well, ghci uses readline, so there is limited vim binding support
11:19:00 <merijn> ReinH: It does not
11:19:03 <rrradical> it uses haskeline, not readline
11:19:04 <merijn> ReinH: It uses haskeline
11:19:10 <ReinH> Ok, it uses haskeline, so there is limited vim binding support
11:19:14 <merijn> Which doesn't support .inputrc :(
11:19:22 <ReinH> merijn: :(
11:19:38 <ReinH> On an unrelated note, Data.Conduit.Process is pretty nice :)
11:19:47 <ReinH> I recently used it to convert a bash script that had grown unweildy
11:19:52 <chrisdone> if ghci supported said service you could send lines to it from vim =3
11:20:14 <joelteon> Why is everything so complicated
11:20:30 <merijn> joelteon: Legacy + backwards compat
11:20:38 <ReinH> joelteon: because software. And, more to the point, people who write software.
11:20:52 <merijn> joelteon: Because doing things properly takes a long time
11:21:04 <chrisdone> e.g.
11:21:04 <chrisdone> $ ghci --listen 1234
11:21:04 <chrisdone> $ echo ':t head' | nc localhost 1234
11:21:04 <chrisdone> head :: [a] -> a
11:21:09 <HeladoDeBrownie> We should just redesign the universe to be simpler
11:21:10 <Guest3418> how much valid is it to say, that `do` block is just a `let` for monadic values?
11:21:11 <saep> And a lot of failiures.
11:21:12 <merijn> joelteon: That's why implementing a simple backup script took me 3.5 days
11:21:18 <merijn> Guest3418: Almost none
11:21:18 <clrnd> chrisdone, damn that would be sexy
11:21:37 <joelteon> it should be nul-delimited though
11:21:40 <merijn> chrisdone: Use unix sockets instead of network?
11:21:49 <merijn> chrisdone: Then you can just pipe without nc silliness
11:21:50 <merijn> Also
11:21:53 <chrisdone> screw windows users?
11:21:58 <HeladoDeBrownie> Guest3418, are you familiar with how do expressions desugar?
11:21:59 <joelteon> yes
11:22:00 <saep> Theres vim-slime to send stuff to a tmux-ghci-session.
11:22:14 <merijn> chrisdone: I'd rather not have a network socket with access to ghci executing arbitrary code, no
11:22:31 <merijn> chrisdone: If you want to give windows users the ability to f- themselves over, I'm ok with that
11:22:35 <Guest3418> HeladoDeBrownie: I think so, using bind operator?
11:22:42 <merijn> chrisdone: But I'm not ok with ghci listening on network sockets
11:22:45 <ReinH> chrisdone: you should be able to set up a couple pipes pretty easily with Data.Conduit.Process :p
11:22:49 <Guest33248> hi
11:23:06 <HeladoDeBrownie> Guest3418, right, (>>=). If you understand that, you know most of what there is to know about do expressions.
11:23:10 <chrisdone> reinh plez
11:23:52 <HeladoDeBrownie> Guest3418, for good measure read the translation given here http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
11:24:23 <HeladoDeBrownie> Guest3418, let me know if that helps, or else feel free to clarify your question
11:24:38 <ReinH> chrisdone: :p
11:24:44 <zmbmartin> How can I use just a-z A-Z 0-9 in something like this https://gist.github.com/codedmart/5580962237c262e52afa
11:24:57 <zmbmartin> This returns random strings with any char
11:25:16 <chrisdone> merijn: what if it's just a localhost service?
11:25:21 <k00mi> you could spawn ghci from a wrapper that redirects file descriptors 0 and 1
11:25:52 <ReinH> You could even use bash's magic /dev/tcp ;)
11:25:55 <JonPage> Anybody tried YI editor (which is written in Haskell)? It seems to have vim and emacs bindings. http://fuuzetsu.co.uk/blog/posts/2013-12-17-yi-case-split.html
11:26:09 <bula> hi
11:27:17 <Fuuzetsu> JonPage: FTR that case split is not part of the editor
11:27:34 <Fuuzetsu> it can be done better today anyway
11:28:45 <merijn> chrisdone: It could use named pipes (which AFAIK exist on windows) and then have a ghci-ng invocation connecting to it, that'd be portable and work on both. And if we require an extra process (nc) anyway, why not ghci-ng
11:28:50 <chrisdone> merijn: seems to me a localhost service is as safe from outside intrusions as a unix domain socket
11:28:56 <Guest3418> HeladoDeBrownie: sure, thanks... I may be pulling it too much .. isn't let i = 10; j=20; in (i + j) is kinda similar to do a <- Just 3; b <- Just 20; return (a + b)
11:29:37 <ReinH> Guest3418: not really.
11:30:21 <ReinH> Do notation is designed to make them look superficially similar.
11:30:28 <HeladoDeBrownie> Guest3418, they may be similar if m ~ Identity, but for most other types less so
11:31:28 <Guest3418> ReinH: HeladoDeBrownie: agree, for most of the contexts where sequencing has different notion, it surely be different
11:31:41 <chrisdone> merijn: the advantage of sockets is i can run ghci in a VM or docker or remote SSH machine and expose a port so that i can connect to it
11:32:06 <HeladoDeBrownie> Oh yeah, that's another thing, some Monads can be said to "sequence" while others cannot. Thus "sequencing" is not part of the Monad generalization.
11:32:27 <ReinH> Guest3418: they are different parts of the syntax as well. It's best not to try to draw too many parallels.
11:32:58 <chrisdone> merijn: (in the case of the SSH i'd tunnel)
11:34:04 <HeladoDeBrownie> Guest3418, one way you might be able to see how they're not the same thing is how you can actually use let inside do expressions, in a quite distinct manner from that in which you would use <-
11:34:39 <HeladoDeBrownie> Guest3418, though, again, for Identity, they actually are the same!
11:34:47 <HeladoDeBrownie> (Mostly)
11:35:37 <Guest3418> HeladoDeBrownie: hmmm....affirmative :) thanks for help
11:36:24 <texasmynsted> hmm.  So I created the sandbox with cabal sandbox init
11:36:41 <texasmynsted> I then installed snap with —force-reinstall
11:36:50 <texasmynsted> inside that 'sandboxed' directory
11:37:08 <texasmynsted> when I try to snap init -h, then the snap command is not known
11:37:23 <texasmynsted> but if I attempt to reinstall snap, it says it is already installed
11:38:50 <sm> texasmynsted: add ~/.cabal-sandbox/bin to your PATH
11:39:03 <texasmynsted> ok
11:39:19 <sm> sorry: I meant ./.cabal-sandbox/bin
11:39:20 <HeladoDeBrownie> Woop gotta go, have fun all
11:41:34 <texasmynsted> wee.  Thank you
11:41:35 <texasmynsted> that worked
11:49:43 <Guest3418> :quit
11:54:50 * hackagebot text-manipulate 0.1.2 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.2 (BrendanHay)
11:57:11 <Fuuzetsu> according to wiki, when C is any small category, the category of presheaves (and natural transformations) C^ is cartesian closed and that means it has to have a terminal object. What's the terminal object here? Is there one in every functor category?
11:58:51 <zmbmartin> Is it possible to generate a random string only using a-z A-Z 0-9 without any special char? -> genToken gen = [take 64 $ randomRs ('0', 'z') gen | x <- [0..]]
11:58:59 <johnw> "if C has a terminal object, then the corresponding constant functor serves as a terminal presheaf."
11:59:50 * hackagebot text-manipulate 0.1.2.1 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.2.1 (BrendanHay)
11:59:53 <Fuuzetsu> johnw: source?
12:00:05 <johnw> http://en.wikipedia.org/wiki/Initial_and_terminal_objects
12:00:08 <blueonyx> zmbmartin: maybe you create an array with all the chars you want, then generate a random index and return the corresponding char
12:00:30 <Fuuzetsu> johnw: I don't suppose you know a lot about pseudo-monads and pseudo-distributive laws and all that stuff?
12:00:40 <johnw> what does the "pseudo-" entail?
12:01:04 <zmbmartin> blueonyx: I was hoping there was a way to do it in the realm of how I am.
12:01:09 <Fuuzetsu> 2-monad where the functor and natural transformations are pseudo-
12:02:36 <Fuuzetsu> http://dl.acm.org/citation.cfm?id=1151202 basically I'm trying to feel less stupid about this paper by 9am
12:07:05 <blueonyx> zmbmartin: what does this mean? not using arrays? then create a string and the !! operator
12:07:42 <blueonyx> or isnt there some oneOf function?
12:10:32 <blueonyx> zmbmartin: you somehow have to map your valid chars to a Random instance
12:10:41 <blueonyx> you could also try a newtype for Char
12:11:22 <zmbmartin> blueonyx: Yeah, just don't know enough about Haskell yet. I will look into your ideas. Thanks!
12:12:24 <schell> hi all - why are unevaluated expressions called a thunk?
12:13:09 <simpson> schell: It's an old term from long ago.
12:13:30 <simpson> schell: Somebody was looking for a past tense for "think", and it stuck.
12:13:36 <vanila> "thunk" is a way to simulate lazyness in a strict language
12:14:46 <schell> cool, thanks
12:14:52 * hackagebot process-listlike 0.10 - Process extras  http://hackage.haskell.org/package/process-listlike-0.10 (DavidFox)
12:14:56 <schell> vanila: was it originally a C thing?
12:14:58 <lpaste> jbetzend pasted “confusion about otherwise” at http://lpaste.net/113050
12:15:26 <jbetzend> Hey people. I just created the paste. Could somebody clear up some confusion for me?
12:15:31 <Fuuzetsu> was anything originally a C thing?
12:15:45 <begriffs> Is there a guide or checklist for creating and uploading a package to hackage? I want to be sure I set up the package and docs to match the quality of other packages.
12:15:51 <vanila> schell, more like lisp and ML
12:15:55 <ReinH> > otherwise -- jbetzend
12:15:56 <lambdabot>  True
12:16:00 <Fuuzetsu> begriffs: you can upload a candidate
12:16:08 <Fuuzetsu> also ‘cabal check’
12:16:10 <ReinH> @src otherwise
12:16:11 <lambdabot> otherwise = True
12:16:23 <jbetzend> Yes. I know.
12:16:31 <begriffs> Can I overwite a candidate version remotely if I don't like it?
12:16:48 <ReinH> jbetzend: In the second one, you are creating a variable called otherwise
12:16:48 <jbetzend> That's what's confusing me. If you look at the paste, the exact same code works with "otherwise" and doesn't with "True".
12:16:50 <ReinH> and then not using it
12:16:57 <Fuuzetsu> ReinH: he's asking why he can put an otherwise where a list is expected
12:16:58 <bgamari> anyone know where one could find Paterson's "Constructing applicative functors" short of shelling out $30 to Springer?
12:17:00 <Fuuzetsu> which seems strange
12:17:06 <ReinH> Fuuzetsu: see above
12:17:21 <Fuuzetsu> yes, *I* know ;P
12:17:25 <ReinH> Fuuzetsu: :p
12:17:39 <geekosaur> jbetzend, becuase case creates new bindings
12:17:43 <jbetzend> ReinH, Oooh. I see. So "otherwise" just matches on anything.
12:17:51 <geekosaur> you are hiding the original definition and creating a new binding that matches anything at all
12:17:51 <jbetzend> Like "_"
12:18:05 <geekosaur> and goes out of scope almost immediately
12:18:05 <bgamari> ahh, never mind, duck duck go fail
12:18:09 <ReinH> jbetzend: otherwise is a new binding, not the otherwise you are thinking of. You can replace otherwise with `frobnitz' or whatever you want
12:18:09 <Fuuzetsu> with the difference is that you can't refer back to _
12:18:41 <johnw> bgamari: http://openaccess.city.ac.uk/1141/1/Constructors.pdf
12:18:47 <jbetzend> I understand. That makes perfect sense. =)
12:18:47 <sinelaw> is there a flip id?
12:18:49 <sinelaw> oops
12:18:52 <sinelaw> flip (.)
12:18:58 <bgamari> johnw, yep, got it
12:19:11 <ReinH> :t (>>>)
12:19:12 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
12:19:23 <sinelaw> @where (>>>)
12:19:23 <lambdabot> I know nothing about (>>>).
12:19:28 <sinelaw> amnesia.
12:19:38 <sinelaw> you know it's type, silly.
12:19:38 <geekosaur> @index (>>>)
12:19:38 <lambdabot> Control.Arrow
12:19:39 <ReinH> @hoogle (>>>)
12:19:41 <sinelaw> aha
12:19:41 <jbetzend> Thanks guys, that was already it. For a moment there I thought the perfect world of referential transparency had a crack. xD
12:19:46 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
12:19:47 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
12:19:54 <ReinH> sinelaw: @where is just a dictionary of things we tell lambdabot about
12:19:58 <sinelaw> thanks, geekosaur, ReinH
12:20:22 <ReinH> jbetzend: (->) is an instance of Category, ofc
12:20:34 <Fuuzetsu> @where fuuzetsu
12:20:34 <lambdabot> I know nothing about fuuzetsu.
12:20:36 <Fuuzetsu> ;_;
12:20:37 <sinelaw> any cool examples of @djinn usage?
12:20:43 <ReinH> sinelaw: Yes.
12:21:01 <mauke> inb4 Cont
12:22:18 <ReinH> sinelaw: you can use djinn to show that there is more than one possible definition of (>>)
12:23:27 <ReinH> @djinn (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
12:23:28 <lambdabot> f a b c =
12:23:28 <lambdabot>     case b c of
12:23:28 <lambdabot>     (d, _) -> case a c of
12:23:28 <lambdabot>               (_, e) -> (d, e)
12:23:53 <mr-> @djinn (Monad m) =>  m a -> m b -> m b
12:23:54 <lambdabot> f a b = a >>= (\ _ -> b)
12:23:55 <ReinH> The choice of state is ambiguous, so @djinn does the least defined thing.
12:24:10 <ReinH> mr-: Wait, djinn knows about monad? Huh.
12:24:15 <sinelaw> heh
12:24:34 <mr-> looks like it :-)
12:24:38 <ReinH> mr-: neat
12:25:57 <athan> Hey guys, I have a.. not really well formed question. Would the type `(a -> a) -> a -> a` be an... instance(?) type / "equal" (idk what to call this), to the type `t -> t`?
12:26:05 <ReinH> You can use djinn to derive some rather complex functions if you specify their types well enough: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-3
12:26:05 <athan> coercible?
12:26:17 <ReinH> (the "I Dream of Genie" section)
12:26:39 <ReinH> athan: what happens if you set t ~ (a -> a)?
12:27:06 <ReinH> athan: Or maybe the first question is: is (a -> a) -> a -> a equivalent to (a -> a) -> (a -> a)?
12:27:08 <sinelaw> ReinH, Cool! will read.
12:27:26 <athan> ReinH: I would imagine then `t->t` would look like `(a -> a) -> (a -> a)` :S
12:27:42 <athan> hmm..
12:27:44 <geekosaur> -> groups to the right
12:27:52 <athan> yes! They are, correct?
12:27:52 <ReinH> athan: does (->) group to the right or to the...
12:27:56 <ReinH> athan: yes
12:27:59 <geekosaur> sorry
12:28:05 <athan> thank goodness
12:28:12 <athan> thank you ReinH :)
12:28:17 <geekosaur> this is part of what makes currying work
12:28:19 <ReinH> geekosaur: :)
12:28:24 <athan> & geekosaur :)
12:28:31 <athan> wow
12:28:51 <athan> wait, currying as in `curry`/`uncurry`?
12:29:10 <ReinH> athan: and why you can read fmap :: (a -> b) -> f a -> f b as (a -> b) -> (f a -> f b), as a function that takes a function and gives a "lifted" function".
12:29:24 <geekosaur> well, as in why we write things as (f a b) instead of f(a, b) and can then do partial application
12:29:49 <geekosaur> we use curried function application and the right-grouping of the function arrow gets us partial application "for free"
12:29:53 * hackagebot github-types 0.1.0.4 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.4 (wereHamster)
12:30:19 <athan> geekosaur: Awesome :) thank you!
12:31:57 <athan> So with the type `a -> b`, that doesn't necessarilly mean that a and b are different, but that it's possible for them to be, right?
12:32:37 <blueonyx> hm, how to chop a infinite list into pieces of length x (like chunksOf from Data.Text)
12:32:52 <mauke> > chunksOf 5 [0 ..]
12:32:55 <lambdabot>  [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],...
12:33:00 <blueonyx> O.o
12:33:03 <blueonyx> :t chunksOf
12:33:04 <lambdabot> Int -> [e] -> [[e]]
12:33:05 <geekosaur> it's possible for them to be, so it's not safe to assume that they're the same, but nothing stops them from *being* the same in some cases
12:33:10 <hexagoxel> @djinn Monad m => m a -> m c -> m c
12:33:11 <lambdabot> f _ a = a
12:33:18 <hexagoxel> surprise, surprise :)
12:33:31 <blueonyx> @src chunksOf
12:33:32 <lambdabot> Source not found. stty: unknown mode: doofus
12:33:42 <blueonyx> mauke: where is it from?
12:33:49 <Fuuzetsu> Data.List.Split
12:33:52 <mauke> split
12:33:53 <blueonyx> meh
12:35:02 <athan> geekosaur: Ahh, perfect :)
12:38:21 <blueonyx> but thanks
12:40:42 <augur_> hm..   [Either a b] -> ([a],[b])   is an interesting type
12:41:16 <mauke> [a + b] -> [a] * [b]
12:41:20 <augur_> yes
12:41:50 <augur_> i wonder if there's a general sort of thing here..   List(F(A)) -> DualF(List(A))
12:43:01 <EvanR_> !(a & b) -> !a | !b
12:43:35 <Fuuzetsu> that is very much in the other direction from ‘general’
12:43:56 <joelteon> General Thing reporting in
12:44:15 <Fuuzetsu> General Sort of Thing
12:44:55 <EvanR_> i know no category theory
12:45:00 <EvanR_> dont mind me
12:46:16 <thomassgn> Hey, I was wondering, I would like cabal (cabal-install, the commandline program) to always work inside a sandbox unless I explicitly tell it not to. That it is I want it to check, like git does, "am I in a sandbox now" whenever I run a cabal command, and complain if there is no sandbox. Is this currently possible? And if not, is it hard to implement?
12:46:26 <augur_> EvanR_: ahh so maybe it's a generalization of demorgan dualities?
12:46:30 <vanila> [(a,b)] -> Either [a] [b]
12:46:31 <josephle> unfortunately (Void -> a * b) != (Void -> a) + (Void -> b)
12:46:45 <jpchang> Hey
12:46:53 <augur_> [a * b] -> [a] + [b]    is certainly something we can construct
12:47:01 <vanila> there's two!
12:47:08 <augur_> tho its not as interesting as   [a + b] -> [a] * [b]
12:47:15 <hexagoxel> thomassgn: .cabal/config: "require-sandbox: True"
12:47:20 <vanila> there's one [Either a b] -> ([a],[b])
12:47:34 <vanila> and it doesn't throw away anything
12:47:47 <athan> Let's say you have some particularly typed function f with type Int -> Bool. Whats an easy way to check whether f satisfies the type `a -> b`?
12:47:56 <thomassgn> hexagoxel: hah, it's that easy. Awesome, thanks.
12:47:59 <augur_> josephle: er..  did you mean to have Void -> ...?
12:48:17 <augur_> josephle: or did you mean != to mean "not isomorphic"?
12:48:36 <athan> Or, more generally, polymorphic types like before `(a -> a) -> (a -> a)` ~ `(a -> a) -> a -> a`
12:49:05 <josephle> augur_: this is a translation of demorgan's law
12:49:42 <augur_> josephle: you meant then to have ... -> Void, not Void -> ...
12:49:59 <augur_> Void -> ...   is always true, but does not mean "not ..."
12:50:05 <augur_> you want ... -> Void
12:50:08 <josephle> augur_, yeah
12:50:12 <josephle> I messed it up
13:03:48 <athan> what's the algorithm that does type checking? Isn't alg. W for type inference only?
13:03:54 <athan> or type matching?
13:08:52 <dfeuer> The Applicative composition and interchange laws look kind of ... ugly. Is there a cleaner set of laws out there?
13:11:43 <pdxleif> maybe less point-free?
13:14:08 <Redz> hello. i have some dependency bugs on cabal and instead of solving them all, could i just remove the local package repo and install everything i need again?
13:14:16 <felixn> I'm getting `but got: *** Exception: No match in record selector` and having a hell of a time debugging it ... are there any tools to let me step through to see what values are causing it?
13:14:35 <mosdd> hello
13:15:11 <merijn> felixn: Are you compiling -Wall ?
13:15:20 <mosdd> is there a `FilePath -> [String]' and `[String] -> FilePath', where [String] is a list of path tokens separated by / or \
13:15:25 <merijn> felixn: Sounds like you're forgetting to set a field and GHC should warn about that
13:15:38 <mauke> more like a partial field function
13:15:47 <mauke> data Foo = A { x :: Int } | B
13:15:57 <merijn> mauke: GHC warns for those too, no?
13:16:13 <merijn> Really, why isn't -Wall the default yet?
13:16:43 <pdxleif> dfeuer: How the laws are stated in the paper "Applicative Programming with Effects" looks a little nicer, to me
13:17:07 <clrnd> is there something like lein-try for cabal?
13:17:13 <pdxleif> not really different, though
13:17:48 <dfeuer> pdxleif, I'll have to go read that, I guess.
13:18:32 <dfeuer> pdxleif, no, that looks the same.
13:18:48 <dfeuer> Unsatisfying
13:19:13 <pdxleif> yeah; they wrote (\f -> f x) instead of ($ x), it looks like
13:19:42 <pdxleif> It looks nicer cause it's PDF
13:20:23 <pdxleif> When doing those laws as proofs I often tend to eta-expand those things to make them easier to work with.
13:21:23 <felixn> merijn: unfortunately no warnings :(  I just cleaned up the backlog :D
13:21:53 <felixn> ghc-mod + atom yells warnings at me
13:26:17 <felixn> merijn: ah I found it, I wrote an instance that assumed too much
13:33:30 <dfeuer> OK, can someone explain why http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html says that as a consequence of the Applicative laws, the Functor instance must satisfy fmap f x = pure f <*> x ? This seems to require a proof that there can only be one valid Functor instance for a type. Why would that be so?
13:34:53 <geekosaur> because Haskell only supports one typeclass instance per type?
13:35:09 <dfeuer> geekosaur, no, I mean mathematically.
13:35:51 <geekosaur> I don't think that's intended to be mathematical, except insofar as Haskell's restriction figures into it?
13:35:52 <sccrstud92_> dfeuer: i think the functor law for fmap in the free theorem you get from the type of fmap
13:35:54 <sccrstud92_> but im not sure
13:36:11 <dfeuer> sccrstud92_, but how's that give you uniqueness?
13:36:14 <geekosaur> rather, it's how the mathematical one gets reflected through Haskell's limitation
13:36:39 <sccrstud92_> dfeuer: if you look at every type as an algebraic data type, you only have 0, 1 + and *
13:36:45 <dfeuer> geekosaur, please stop talking about the fact that there can only be one instance. That has nothing to do with my question.
13:37:07 <sccrstud92_> dfeuer: hes just trying to help
13:37:32 <dfeuer> I'm talking about the fact that \f x -> pure f <*> x  does in fact satisfy the functor laws; the question is why that means that it has to equal fmap.
13:37:40 <sccrstud92_> dfueur: do you see that a sum type and a product type can only have 1 unique functor?
13:37:48 <josephle> I think geekosaur means that (fmap f x = pure f <*> x) as a consequence of the laws + the instance restriction
13:37:58 <geekosaur> yes
13:38:16 <dfeuer> But no.
13:38:18 <sccrstud92_> i think its just a consequence on the laws
13:38:32 <geekosaur> as long as the restriction exists there's no point in trying to be mathematically precise in the definition
13:38:34 <sccrstud92_> i dont think the instance restriction comes into play
13:39:12 <sccrstud92_> why does the instance restriction prohibit preciseness?
13:39:14 <dfeuer> geekosaur, what I'm trying to get at is whether the documentation there is correct.
13:39:44 <pdxleif> if functor is a superclass of applicative, and if fmap, pure, and <*> both come from that instance...
13:40:09 <josephle> sccrstud92_: more like the restriction makes generalizing the law somewhat futile
13:40:25 <pdxleif> Isn't that similiar to a "left identity" law?
13:40:26 <dfeuer> sccrstud92_, no, I'm not sure I do understand how the sum and product types ensure that.
13:40:27 <RchrdB> dfeuer: does the Functor law, (fmap id == id), not imply uniqueness of Functor instances already?
13:40:35 <merijn> dfeuer: There *is* only one valid functor for every type
13:40:48 <dfeuer> merijn, okay, but how do you prove that?
13:40:56 <sccrstud92_> RchardB: i agree i think thats the important point
13:41:13 <merijn> dfeuer: I think Wadler's "Theorems for Free" is applicable
13:41:24 <sccrstud92_> merijn: i agree
13:41:26 <merijn> dfeuer: AFAIK the uniqueness of functor is a free theorem?
13:41:39 <dfeuer> merijn, I don't think it is....
13:41:47 <sccrstud92_> josephle: when is that next afrp blog post coming up?
13:41:52 <merijn> We need a category theorist in here, stat!
13:42:20 <josephle> sccrstud92_: you must have the wrong guy. I don't have anything to do with afrp
13:42:28 <sccrstud92_> dfeuer: do you have an example of a type with multiple functor instances?
13:42:54 <dfeuer> sccrstud92_, no, and I'm perfectly happy to be convinced it's impossible, but nobody's done it yet!
13:42:58 <amalloy> dfeuer: the only possible way to correctly implement `fmap f` for some type `t a` is to call f exactly once on each instance of `a` contained within the `t`, right?
13:43:11 <sccrstud92_> josephle: didnt you write this? http://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines
13:43:18 <sccrstud92_> oh wait
13:43:18 <amalloy> how else could you produce an `f b`?
13:43:20 <sccrstud92_> thats justin le
13:43:23 <sccrstud92_> ur joseph le
13:43:26 <sccrstud92_> my bad!
13:43:33 <josephle> no problem ;)
13:43:49 <dfeuer> amalloy, what do you mean by "call f"?
13:43:50 <sccrstud92_> should have known. justin is jle on here
13:43:53 <latk> don't suppose anyone knows of any clever attoparsec debugging tips? Or do you just have to reason it out ?
13:44:11 <sccrstud92_> latk: i have used atto a bit, whats ur issue?
13:44:36 <jhance> latk: Test smaller parsers and then test the ones they combine to, etc
13:44:44 <jhance> latk: ghci is your friend here
13:45:15 <latk> I'm getting a "Failed reading: asciiCI" message, and I'm currently to tired to work out why :s
13:45:31 <merijn> dfeuer: You *must* transform the a's in b to obtain it's type (follows from the type of fmap) and you *must not* change the structure, which follows from "fmap id = id"
13:45:36 <amalloy> dfeuer: that is, (fmap f x) must return an object using the same constructor as x, but with each value of type `a` replaced with (f a) (or with fmap f a, if that a is buried inside of another functor)
13:45:47 <merijn> latk: Debugging tips: More and smaller parsers
13:45:54 <sccrstud92_> latk: if you post code ill look at it.
13:46:10 <latk> No worries, I actually just worked it out :p
13:46:20 <latk> I'll refactor it a bit to have some smaller parsers anyway
13:46:48 <amalloy> debugging tips: ask your question in irc; you'll think of the answer immediately afterwards
13:46:55 <latk> also, turns out Debug.Trace works if you are using a monadic style
13:47:04 <latk> possibly if you are not
13:47:05 <merijn> latk: I love you
13:47:06 <latk> as well
13:47:13 <merijn> latk: I didn't know asciiCI existed
13:47:18 <merijn> I need exactly that :p
13:47:22 <josephle> http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
13:47:23 <latk> Hah, it is very useful!
13:47:24 <jhance> I doubt what style you are using would matter...
13:47:31 <josephle> hey, it's the same question about functor uniqueness!
13:47:49 <merijn> latk: Oh, wait...I just realised that the code I need it in uses binary >.> nevermind...
13:48:40 <latk> merijn: Bad times :(
13:48:43 <merijn> josephle: Nice, I remembered correctly!
13:52:57 <dfeuer> Ah, I found some stuff: https://github.com/quchen/articles/blob/master/second_functor_law.md
13:53:38 <dfeuer> I don't understand nearly enough about how free theorems work to know where the free theorem comes from, but maybe I can use it to prove this.
13:55:18 <pdxleif> dfeuer: You're doing proving?
13:55:53 <dfeuer> pdxleif, well, if it's valid we should prove it. Otherwise we should change the documentation.
13:56:10 <merijn> dfeuer: It is valid
13:56:32 <merijn> dfeuer: Have you read Theorems for Free?
13:56:41 <pdxleif> hmm - I suspected something like that article says
13:56:43 <merijn> It explains exactly this parametricity trick
13:57:01 <dfeuer> merijn, there is a gap between believing that you are correct and having evidence for that belief. That paper generally goes way over my head, and it also doesn't seem to get into things like functors, per se.
13:57:03 <merijn> Also, if you wanna prove stuff like this. I recommend learning Coq and using that :)
13:57:19 <dfeuer> Hrr... Coq is biiiiiiig.
13:57:21 <merijn> I even have a good, free book for you :)
13:57:26 <pdxleif> I like Idris for stuff
13:57:39 <pdxleif> Could also use Agda
13:57:39 <merijn> pdxleif: Idris doesn't make a very good proof assistant
13:57:41 <dfeuer> Which one's that, merijn? Pierce's?
13:57:46 <merijn> And I dislike Agda
13:57:53 <pdxleif> Why's that?
13:57:54 <merijn> dfeuer: Software Foundations
13:57:56 <merijn> @where sf
13:58:00 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
13:58:06 <lambdabot> assistant."
13:58:08 <merijn> Ah, yeah, that's Pierce
13:58:16 <dfeuer> I missed the et al.
13:58:20 <mosdd> :t nub
13:58:28 <lambdabot> Eq a => [a] -> [a]
13:58:30 <mosdd> what a funny name
13:58:34 <dfeuer> nub has a broken type.
13:58:37 <mosdd> does it mean anything
13:58:39 <merijn> pdxleif: Too much unicode magic and no clear way to visualise the goals
13:58:43 <mosdd> dfeur huh?
13:58:52 <merijn> pdxleif: Also, only works in emacs
13:59:11 <dfeuer> mosdd, its type is fundamentally wrong.
13:59:12 <pdxleif> I meant more about Idris not making a very good proof assistant, I guess
13:59:23 <pdxleif> But it's similiar to Agda, minus unicode, but some tactics...
13:59:26 <mosdd> dfeuef what should it be?
13:59:38 <merijn> pdxleif: My intro to Agda included (for realz) the following phrase as answer to "This code doesn't work for me": "Oh, yeah, I should have told you, that's a unicode vertical bar, not ascii..."
13:59:43 <pdxleif> Not as developed or suitable as something like Coq, of course.
13:59:52 <pdxleif> heh
13:59:58 <pdxleif> wtf
14:00:02 <merijn> Ulf has scarred me for life
14:00:20 <pdxleif> I suppose you could start w/ an alternate stdlib that's unicode-free
14:00:28 <dfeuer> merijn, according to quchen, the free theorem for fmap is that f . g = p . q => fmap f . fmap g = fmap p . fmap q
14:00:47 <dfeuer> Which apparently is enough, along with the first functor law, to prove the second functor law.
14:01:12 <josephle> I remember when I started in agda, I was working with a library that had many unicode characters that I didn't know how to type in
14:01:24 <dfeuer> But that still doesn't get us to a proof that when foo and bar both satisfy the functor laws then they must be effectively equal....
14:01:31 <pdxleif> merijn: Edwin nixed support for unicode operators in Idris - perhaps due to being scarred by Agda (over)use? https://github.com/idris-lang/Idris-dev/pull/694
14:01:38 <merijn> dfeuer: That follows from parametricity
14:02:02 <merijn> dfeuer: There's only one way "(a -> b)" can take you from "f a" to "f b"
14:02:22 <merijn> dfeuer: Note that the functor laws rule out changing the structure of f AND rule out "hidden changes in f
14:02:28 <merijn> dfeuer: Else they violate "fmap id = id"
14:02:41 <merijn> dfeuer: Therefore the only thing that can be change is the a's
14:02:51 <merijn> dfeuer: And the only tool you have for changing a's is "a -> b"
14:03:17 <merijn> therefore, you *must* apply "a -> b" to all a's and you *must not* do anything else
14:03:25 <sinelaw> hey all. does Integer optimize to machine word when the value is small enough?
14:03:35 <merijn> (What else could you do, given that structural and hidden modifications are disallowed?)
14:03:59 <cschneid> Is the import at the top here (the qualified one) a typo with the 'k'? https://hackage.haskell.org/package/EnumMap-0.0.2/docs/Data-EnumMap.html -- if not, what does that `k` do?
14:03:59 <merijn> sinelaw: Yes, but it's still slightly more expensive due to needing overflow checks
14:04:14 <sinelaw> merijn, cool thanks
14:04:16 <dfeuer> merijn, you're talking some sense, I suppose. The fmap id = id thing is stronger than it looks.
14:04:20 <merijn> cschneid: I say typo
14:04:35 <cschneid> ok, I didn't think it was possible to put additional tokens there (right?)
14:04:48 <merijn> cschneid: Not AFAIK, but consult the report for details :p
14:04:56 <cschneid> pfft, I'll just go with typo :)
14:04:59 <cschneid> hah
14:05:03 * hackagebot haskell-neo4j-client 0.3.0.4 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.4 (asilvestre)
14:07:37 <pdxleif> Given the type constraint of length-preserving on the Vect instance of Functor in Idris, the proof "auto" (along w/ case-splitting between [] and cons) is enough to derive the correct impl for fmap
14:08:09 <qwr> @unpl (y +) . (r *) . sin
14:08:09 <lambdabot> (\ e -> y + (r * (sin e)))
14:08:29 <pdxleif> That only speaks to the "obviousness" of the correct impl I think - other impls would require you to do more work to get "pathological" results
14:10:04 * hackagebot haskell-neo4j-client 0.3.0.5 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.5 (asilvestre)
14:11:48 <merijn> dfeuer: Inoccuous simple things frequently are more powerful than they look ;)
14:12:03 <merijn> Take fold's ability to implement any primitve recursive function, for example
14:12:32 <Fuuzetsu> what does it mean for a limit/colimit to have a certain size?
14:13:06 <Fuuzetsu> merijn: you could hack in Agda support to Yi, which has a vim keymap ;)
14:14:24 <fragamus_> edwardk: I am using     V 9 Double     and if I try to put any kind of variable name in place of that 9 I get compile errors.  *Can this be parameterized?*
14:15:00 <fragamus_> because I want to work with arbitrary number of dimensions in my vector space
14:15:04 <dfeuer> merijn, I'm not too clear about what a "primitive recursive function" is, but is that the whole trick of passing things "forward" along the fold?
14:15:09 <merijn> Fuuzetsu: Or use Coq which already has a nice plugin + a nice book
14:15:19 <merijn> dfeuer: Primitive recursive is a class of functions
14:15:23 <Fuuzetsu> and terrible syntax and frustration
14:15:33 <merijn> Fuuzetsu: For programming, yes
14:15:38 <merijn> Fuuzetsu: For proving it's ok
14:15:49 <merijn> dfeuer: More powerful than plain structural recursion
14:21:23 <neektza> Anyone here doing the NICTA haskell course? In the Course.List file, a custom List type is defined with the ':.' operator as the cons operator. How can this operator be used before it's defined previously somewhere?
14:22:51 <ReinH> neektza: where?
14:23:20 <ReinH> data MyList a = Nil | a :. MyList a *is* defining :., btw
14:23:33 <neektza> https://github.com/NICTA/course/blob/master/src/Course/List.hs#L31-L34
14:23:48 <Fuuzetsu> yes, that's what ReinH said
14:23:50 <neektza> hm, if I wanted to name the operator literaly 'cons'
14:23:57 <neektza> how would i do that?
14:24:14 <ReinH> neektza: cons = (:.)
14:24:20 <Fuuzetsu> I don't remember if ‘a `cons` MyList’ works
14:24:21 <ReinH> and you would have to use `cons`
14:24:32 <ReinH> Fuuzetsu: `Cons` might
14:24:35 <Fuuzetsu> yeah
14:24:35 <neektza> oh! thanks!
14:25:13 <sinelaw> references for implementing an efficient histogram (purely functional)?
14:25:16 <sinelaw> anyone?
14:25:20 <ReinH> constructors have to start with an uppercase letter followed by valid variable characters or `:' followed by valid symbol characters
14:25:23 <pdxleif> ReinH: Hey, would you wanna give a talk at PDXFunc sometime?
14:25:30 <ReinH> sinelaw: Define "histogram" :)
14:25:38 <ReinH> pdxleif: sure! Sorry I missed this month. Was super tired :/
14:25:46 <sinelaw> ReinH, [(a,b)] -> Map (a,b) Double
14:25:57 <sinelaw> the histogram is Map (a,b) Double
14:26:09 <sinelaw> sorry. replace (a,b) with just 'a'
14:26:15 <Fuuzetsu> data Histogram -- abstract ;P
14:26:19 <pdxleif> Ah. Not a lot of people made it to David's talk, anyways. Also, have to find a new venue starting next month. :/
14:26:23 <ReinH> sinelaw: Maybe try that again? :)
14:26:27 <ReinH> pdxleif: :(
14:26:44 <pdxleif> My work has a room that can hold a little over 12 people...
14:26:51 <_2_MaddyCakes> Hi
14:27:01 <sinelaw> ReinH, ok. Histogram a = Map a Double
14:27:22 <sinelaw> a is bounded (I mean has a finite number of possible values)
14:27:31 <_2_MaddyCakes> I'm new to the app
14:27:33 <sinelaw> a is the type of the histogram bin
14:27:55 <sivteck> _2_MaddyCakes, what app?
14:27:59 <Fuuzetsu> There is no “app” here.
14:27:59 <Hammel> @unpl id
14:27:59 <lambdabot> (\ a -> a)
14:28:26 <ReinH> sinelaw: What do you mean by "histogram"?
14:28:27 <sinelaw> so, given a big list of values that fall into a finite number of bins, build a map: bin -> probability
14:29:51 <ReinH> Ok, so a histogram for classification
14:30:17 <Hammel> @pl isABC c = c >= 'a' && c < 'd'
14:30:17 <lambdabot> isABC = liftM2 (&&) (>= 'a') (< 'd')
14:30:54 <Fuuzetsu> (`elem` ['a' .. 'c']) seems more readable…
14:31:35 <Fuuzetsu> or even (`elem` "abc") ;P
14:31:36 <Hammel> I know, but someone I know had a really wierd pointfree solution to this problem and I wanted to see if he just used lambda bot
14:31:40 <pingu> Hi, I just found this kind of ugly code:
14:31:40 <pingu>     anyM :: Monad m => [a] -> (a -> m Bool) -> m Bool
14:31:40 <pingu>     anyM xs f = foldM (\b x -> if b then return True else f x >>= return . (&& b)) False xs
14:31:48 <Fuuzetsu> Hammel: are you a teacher or something
14:32:01 <pingu> I feel like there should be a nice, more general solution maybe involving Data.Semigroup, Any?
14:32:26 <pingu> or Foldable
14:32:40 <ReinH> > foldr (\b -> at b . non 0 +~ 1) M.empty ["foo", "bar", "foo"]
14:32:41 <lambdabot>  fromList [("bar",1),("foo",2)]
14:32:42 <pingu> I'm not sure, has anyone got a better way of anyMing?
14:32:56 <ReinH> In reality you'll probably want foldl' and a strict map, etc
14:33:08 <Hammel> I am teaching a small group in uni. Actually I am just correcting their homework and I try to explain what the actual proffessor failed to teach the students
14:33:45 <Fuuzetsu> can you post the point-free solution?
14:33:49 <Fuuzetsu> out of interest
14:33:57 <ReinH> Hammel: If the professor is teaching students to pointfree things like isABC manually, I question their choices.
14:34:48 <sinelaw> ReinH, the implementation I have uses Map.insertWith on every element, which incurs O(n log n)
14:35:33 <ReinH> You could make that kind of nice, at least
14:35:34 <ReinH> > let (<&&>) = liftM2 (&&) in (>= 'a') <&&> (< 'd') $ 'e'
14:35:35 <lambdabot>  False
14:36:06 <Hammel> the professor did not teach this, so I wondered where the student learned this and figured he might just have used lambdabot to make his soltion more obscure
14:36:14 <ReinH> @hackage histogram
14:36:14 <lambdabot> http://hackage.haskell.org/package/histogram
14:36:18 <ReinH> Is a thing.
14:36:51 <Hammel> isABC' = uncurry (&&) . (&&&) (>='a') (<'d')
14:36:51 <sinelaw> that url is a lie
14:36:58 <codygman> Can anyone help me enforce "list must be Just two elements or Nothing". Here is my current code: http://lpaste.net/113057
14:37:00 <Hammel> that was the students solution, if anyone cares
14:37:24 <phaazon> hey, is there a way to use dx as a backend compiler to compile haskell on android?
14:37:29 <Hammel> I guess he just knew some haskell before the course
14:37:31 <phaazon> I hate Java.
14:37:31 <ReinH> Hammel: clever, not something lambdabot would come up with
14:37:56 <Fuuzetsu> codygman: type List2 a = Maybe (a, a)?
14:38:13 <dmj`> Fuuzetsu++
14:38:27 <pingu> Hammel: I don't think lambdabot introduces arrows like that
14:38:34 <codygman> Fuuzetsu: That, except for a list.
14:38:57 <ReinH> codygman: You either want a thing that must be exactly zero or 2 elements, or you want a list.
14:38:58 <Fuuzetsu> codygman: you have 0 guarantees of the length of [], it's just the wrong type
14:39:03 <sinelaw> is there a purely functional Map with O(1) insert/update?
14:39:14 <ReinH> If you want the former, you want (something isomorphic to) Fuuzetsu's type
14:39:19 <ReinH> sinelaw: No.
14:39:36 <ReinH> It's impossible.
14:39:46 <Hammel> I didn't use lambdabot before, so I didn't know. I actually like the solution too, even if it's way more complicated then necessary
14:39:47 <phaazon> :t (>='a') &&& (<'b')
14:39:49 <lambdabot> Char -> (Bool, Bool)
14:39:50 <sinelaw> *sigh* thought so.
14:39:58 <ReinH> But there are mutable maps in haskell,like Data.HashTable
14:40:02 <sinelaw> ok
14:40:08 <Fuuzetsu> Hammel: seems like the round-about way to use the liftM2 (&&) way
14:40:27 <sinelaw> ReinH, isn't Joe Pure turning in his grave now?
14:40:29 <ReinH> Fuuzetsu: you could also fold it
14:40:33 <ReinH> sinelaw: No.
14:40:46 <phaazon> :t (>='a') *** (<'b')
14:40:47 <lambdabot> (Char, Char) -> (Bool, Bool)
14:40:57 <ReinH> If you *really* need constant time inserts/updates, you just can't use an immutable structure.
14:40:59 <phaazon> oh, &&& splits
14:41:01 <phaazon> ok
14:41:15 <ReinH> phaazon: &&& is fanout, yes
14:41:22 <RchrdB> sinelaw: there used to be a module called "DiffArray" implementing immutable-looking arrays with O(1) update and indexing of the latest version, with the caveat that looking at old versions of a DiffArray took linear time in the length of the history
14:41:24 <phaazon> I never use that
14:41:37 <phaazon> sometimes (***), and even, I prefer using a bifunctor
14:41:46 <ReinH> phaazon: it's nice for some things, like folds
14:41:57 <ReinH> Richard Bird used it a lot
14:42:15 <sinelaw> liner in the length of history, that's interesting
14:42:19 <phaazon> is Kleisly an arrow?
14:42:22 <sinelaw> *linear
14:42:29 <RchrdB> sinelaw, DiffArray got pretty much thrown away though because the constants were *awful*
14:42:37 <Fuuzetsu> Kleisli*
14:42:40 <ReinH> RchrdB: TANSTAAFL ;)
14:42:40 <Hammel> listNames' = (['A' .. 'J'] >>= (:[]) . (,)) <*>  [1..10]
14:42:47 <Hammel> written by the same student
14:42:49 <Fuuzetsu> http://www.haskell.org/haskellwiki/Arrow_tutorial#Kleisli_Arrows ;P
14:42:56 <phaazon> :t putStrLn &&& putStrLn
14:42:57 <lambdabot> String -> (IO (), IO ())
14:43:02 <Hammel> the expected solution was a list comprehension
14:43:03 <Fuuzetsu> Hammel: you should tell him to fix his double-spacing problems ;P
14:43:06 <RchrdB> sinelaw, like, so bad that the theoretical O(log(n)) times from using an IntMap instead didn't matter at all by comparison
14:43:10 <RchrdB> ReinH, quite! :)
14:43:37 <Fuuzetsu> also pft, (:[]) = return
14:43:46 <ReinH> Often, throwing a log n on it so you can use an immutable structure is a good investment
14:43:46 <codygman> ReinH:, Fuuzetsu: I'm not totally sure. I'm just trying to split a string, ensure the result is two elements, and return a Maybe (a,a). I wanted to do it with the type system (ala dependent types). I would like to get a type error if I do "f  ["x","y","z"] :: FixedList2 String". I think, maybe I'm totally lost.
14:43:58 <RchrdB> sinelaw, in practice, Data.IntMap is O(1) because it's O(maximum tree depth) and the biggest IntMap you can have on a current machine is 64 levels deep.
14:44:03 <ReinH> codygman: You are doing it with the type system if you use Maybe (a, a) :p
14:44:19 <Fuuzetsu> codygman: just pattern match on the result and if you have two things, then Just (x, y), if not, Nothing
14:44:31 <Fuuzetsu> there's no need for dependent types here at all
14:44:38 <sinelaw> RchrdB, true, but my keys are not Ints
14:44:39 <fragamus_> is it folly for me to want to use Linear for a high number of dimensions?
14:45:02 <Fuuzetsu> day #2 of fragamus_ looking for his answer
14:45:07 <RchrdB> sinelaw: iirc the "hashable" module implements a hash-like data structure on top of Data.IntMap.
14:45:20 <Fuuzetsu> fragamus_: try asking on mailing lists
14:45:23 <bennofs> fragamus_: is 256 elements high?#
14:45:25 <sinelaw> RchrdB, thanks
14:45:34 <niez> hi, is there something like scipy for haskell?
14:45:50 <fragamus_> I have started asking the people who smoke in front of Safeway
14:46:02 <fragamus_> bennofs: yes
14:46:04 <Fuuzetsu> niez: there are multiple libraries which probably do what you want, there is no single pot I believe
14:46:27 <bennofs> fragamus_: ocharles was doing this just today
14:46:36 <ReinH> fragamus_: you should ask edwardk
14:46:54 <fragamus_> I done asked edwardk but he must be in meetings
14:47:02 <edwardk> fragamus_: linear is really designed for low dimension counts
14:47:10 <ReinH> I have summoned him.
14:47:11 <fragamus_> all rise
14:47:32 <edwardk> fragamus: you can probably get away with it in high dimensions but be careful, you may want to consider using ST, etc. for that so that you can avoid horrible mutation costs
14:47:43 <ReinH> I blew my category theorist whistle.
14:47:45 <fragamus_> edwardk: I am getting that... I love Linear so I want to try
14:47:49 <Fuuzetsu> maybe now that the high council has assembled, I can find out what it means for limits/colimits to have a certain size
14:48:02 <RchrdB> sinelaw: you can use hashes of your data as keys for an IntMap and then it performs sorta like a chained hash table, but persistent rather than ephemeral. You should expect worse performance out of this than from a real mutable open-addressed hash table, but you *are* getting persistence as a benefit of this, and there's no such thing as a free lunch. >_>
14:48:39 <ReinH> RchrdB: I am about to eat lunch. It is technically free because I already paid for it. :p
14:48:46 <RchrdB> :P
14:48:55 <codygman> Fuuzetsu: Here is the use case for what I thought I needed dependent types. Thought it may be cleaner: http://lpaste.net/113058
14:49:03 <sinelaw> RchrdB, not sure what you mean by "persistent" here
14:49:33 <Fuuzetsu> codygman: System.FilePath can split a filepath into a pair…
14:49:42 <Fuuzetsu> takeExtension or something
14:49:43 <codygman> Fuuzetsu: This is for learning
14:49:51 <Cale> sinelaw: That if you make updates to the Map structure, you still have access to the old versions.
14:49:59 <edwardk> fragamus: well, linear was why i wrote lens in the first place. the lens side of things got a bit away from me, but it does do a fair job at its original purpose ;)
14:50:01 <RchrdB> sinelaw: purely functional. When I update a mutable hash table, the old state of the hash table is destroyed.
14:50:03 <Cale> sinelaw: Which is quite useful for implementing things like undo.
14:50:20 <RchrdB> sinelaw: whereas if I update a Data.Map or a Data.IntMap, any references to the previous version continue to exist.
14:50:26 <niez> Fuuzetsu: I want to plot sinusoidal and quadratic signals first, then I want to try to 'simulate' simple RC circuits, just calculate them and plot
14:50:30 <sinelaw> ok ok
14:50:34 <Fuuzetsu> codygman: just pattern match on your split result and do your OhIt'sNot2ElementsThing where you would normally have Nothing
14:50:40 <RchrdB> oh sorry Cale already explained it better
14:51:05 <sinelaw> in my case it's not actually a concern, but thanks
14:51:19 <Cale> If you want hash-based container structures, consider trying the unordered-containers package on Hackage
14:51:33 <fragamus_> edwardk: while I have your attention, I have managed to construct V 9 vectors and I want to assemble them into a matrix.  How is that done
14:51:37 <RchrdB> sinelaw: so in some writing about data structures, you'll see these referred to as "ephemeral" (old versions are destroyed) and "persistent" (old versions stay available).
14:51:37 <Cale> I've had mixed results with it though
14:51:42 <Fuuzetsu> codygman: make your toResolution take a pair, not a list
14:52:02 <Fuuzetsu> or whatever order you want to do it
14:52:18 <Cale> Just using Data.Map and Data.Set sometimes turns out to be faster than Data.HashMap and Data.HashSet
14:52:32 <Cale> Because doing some order comparisons is sometimes faster than hashing
14:52:33 <edwardk> fragamus: V 9 (V 9 a) is a 9x9 matrix
14:52:58 <Cale> So if you care about performance, it's worth trying both.
14:53:15 <fragamus_> yes I know but the actual act of construction
14:53:41 <fragamus_> I have nine such vectors and I want to assemble them into a square matrix
14:54:07 <sinelaw> Cale, I'm actually preparing a haskell tutorial for some experience programmers. this is an example where they will say "aaaah why do I need functional programming"
14:54:20 <Cale> What?
14:54:35 <Cale> I mean, you can do all of this in a non-FP setting
14:54:37 <Cale> :P
14:55:07 <edwardk> fragramus_: Linear.V.fromVector would do it
14:55:15 <Cale> These structures tend to be the ones which are most convenient if you want to avoid doing mutation. You can of course implement mutable structures in Haskell too, say, using IORefs, but most people won't bother with them.
14:55:17 <sinelaw> Cale, right, but I mean, these people already know their data structures well enough to know what it takes to get an O(1) insert
14:55:42 <edwardk> fragamus: its kinda messy as it is, because the check for the size yields a Maybe, etc.
14:55:45 <Cale> Data.IntMap has an O(1) insert by the same standard as a hashtable does
14:56:14 <sinelaw> right. it's just a different way of looking at the same implementation
14:56:38 <fragamus_> edwardk: so that implies that the Data.Vector can support *any* type of element, including our whacky V 9 Double
14:56:41 <Cale> "Hashtables have O(1) lookup" is actually a total lie
14:57:11 <Cale> Any function whose range has n elements costs at least O(log n) time.
14:57:29 <dfeuer> Cale++
14:57:36 <fragamus_> listToV9 :: [Double] -> V 9 Double
14:57:37 <fragamus_> listToV9  = fromJust . fromVector . V.fromList
14:57:37 <sinelaw> why?
14:57:40 <Cale> This is because it takes O(log n) time to separate n distinct inputs from each other
14:57:51 <Cale> You need to examine at least O(log n) bits of the input
14:58:26 <Cale> Or more precisely, you need to examine at least log n / log 2 bits of the input. :)
14:58:27 <dfeuer> Cale, does this change at all when you take the speed of light into account?
14:58:34 <Cale> dfeuer: Yes.
14:58:35 <dfeuer> Or does that just change constant factors?
14:58:54 * dfeuer really wants to heard what Cale knows about that aspect.
14:59:05 <Cale> dfeuer: It makes it O(n^(1/3)) or even O(n^(1/2)) depending on what you believe about how much information it's possible to put into a given volume
14:59:13 <RchrdB> dfeuer: gets worse, you can only fit O(n**3) bits of RAM within (n) nanoseconds RTT. :)
14:59:22 <dfeuer> Oof.
14:59:36 <dfeuer> That's pretty awful, Cale
14:59:40 <sinelaw> Cale, I guess you're right
14:59:54 <RchrdB> dfeuer: or WAY worse if you believe in quantum mechanics, because there's a thing called the Holographic Principle that I don't understand at all which says it's actually O(n**2).
14:59:56 <sinelaw> perhaps O( 1 * hash_time(n) ) is more appropriate
15:00:14 <dfeuer> Yeah, RchrdB, I caught the reference, although I don't claim to understand it.
15:00:55 <Cale> sinelaw: Eventually pointer dereferencing isn't O(1)
15:01:20 <sinelaw> Cale, although, in many cases the time to separate the inputs has already been paid anyway, so you can say it IS O(1)
15:01:36 <Cale> It's O(1) only if you set a fixed upper bound on how much memory you have, in which case, asymptotic analysis becomes sort of silly
15:02:08 <Cale> (because asymptotic analysis specifically does not care about what happens for small sizes)
15:02:12 <RchrdB> If you're worrying about performance on the machine that is physically sitting in front of you, concentrate on counting cache line misses, unless you're unlucky enough to need to count swap file accesses instead.
15:02:23 <RchrdB> (to a first approximation, anyway)
15:02:25 <sinelaw> I'm not actually worried at all.
15:02:45 <Cale> Yeah, I'm just pointing this out because I think people get the wrong idea about hashtables
15:02:47 <josephle> cache-oblivious algorithms to the rescue!
15:02:55 <fragamus_> edwardk: thanks man, I have my matrix; I'm off to the races
15:03:05 <Cale> The main thing which typically makes hash tables perform well is memory locality
15:03:37 <Cale> That's the main thing they have over balanced trees of various sorts
15:03:46 <Cale> Computing hashes is pretty nontrivial
15:03:52 <sinelaw> of course one shouldn't optimize these things without profiling anyway (unless obvious things are wrong)
15:05:10 * hackagebot hakyll 4.5.5.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.5.1 (JasperVanDerJeugt)
15:06:12 <ReinH> sinelaw: You might enjoy Okasaki's Purely Functional Data Structures
15:06:15 <ReinH> @where okasaki
15:06:15 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:06:25 <ReinH> ^ is his thesis, which he later turned into a book
15:06:35 <sinelaw> ReinH, thanks, I already have enjoyed it, but it's been a while since then
15:06:41 <ReinH> ok :)
15:06:46 <sinelaw> very nice book indeed
15:07:07 <stelleg> @where vanhorn
15:07:07 <lambdabot> I know nothing about vanhorn.
15:07:12 <sinelaw> i've heard there have been "advances" since then
15:07:18 <sinelaw> not sure in what respect
15:08:28 <RchrdB> sinelaw: Okasaki doesn't discuss finger trees and, IIRC, zippers.
15:09:03 <anders0> if you mean his book, no, it doesn't have either.
15:09:31 <RchrdB> Yes, I meant the book.
15:09:42 <gaze__> Hey folks, I realize that the halting problem forbids you from figuring out if a program will halt, but what practical restrictions can I make on a program that will allow me to say how long it'll take to run given some inputs?
15:10:53 <josephle> gaze__: asymptotic analysis. If you know the algorithms being used by your program, you can get a rough intuition on the running time
15:11:23 <kadoban> gaze__: The usual answer to that type of question is handled by algorithm analysis, usually asymptotic analysis that gives you some info
15:12:31 <josephle> benchmarking also comes to mind if you want some real-time data about your program
15:13:02 <Fuuzetsu> gaze__: you could also write your program in a total language which then allows you to know if it will halt
15:13:09 <Fuuzetsu> or rather, it will always halt
15:13:11 <kadoban> gaze__: If you're looking for actual proof on an actual implemented program...that's harder. I'm not sure. I know there's Coq and Agda where you can prove that a program will eventually complete, but I'm not sure if you can prove stronger runtime guarantees
15:13:36 <pdxleif> Someone mentioned a quickcheck-like thing to check for big-O properties of various functions
15:13:52 <gaze__> fuuzetsu: that's much more like what I'm looking for
15:14:00 <gaze__> this needs to be automated, and not asymptotic
15:14:06 <gaze__> I need to know that it'll halt in n steps.
15:14:15 <pdxleif> Idris is also similiar to Haskell, but w/ optional totality restrictions.
15:14:17 <dfeuer> Fuuzetsu, but it could run a long long time before it does!
15:14:42 <Fuuzetsu> dfeuer: we could prove it doesn't ;P
15:14:54 <Fuuzetsu> fuck it, it typechecks, just give me the result
15:14:56 <dfeuer> Fuuzetsu, that turns out to be harder.
15:15:38 <pdxleif> showing that it doesn't take a long time sounds like work. in a total language, that it terminates is checked always by the compiler
15:15:46 <Fuuzetsu> dfeuer: I often wonder whether we couldn't just attach running time info to some primitives and go from there, building on top. I never tried this though
15:16:04 <EvanR_> gaze__: initialize the program with a counter which decrements on each step, aborting if it reaches zero at any point!
15:16:19 <dfeuer> Fuuzetsu, you can do such things; it just takes more work.
15:16:25 <dfeuer> I think a lot more.
15:16:31 <kadoban> gaze__: What is your actual use-case, what is this for?
15:16:38 <EvanR_> gaze__: then it easily is guaranteed to end
15:16:58 <silver> gaze__, http://lambda-the-ultimate.org/node/5074
15:16:59 <Fuuzetsu> Right, how much is the question. If all your combinators just pass and accumulate this info then it doesn't seem like it's much work once you have the building blocks in place.
15:17:01 <gaze__> kadoban: It's for a custom piece of hardware that does feedback on qubits
15:17:25 <gaze__> it has several functional units that run separate programs, I need to guarantee that they'll reach the same points at the same time during execution
15:17:40 <hexagoxel> wth does "cabal run" exactly do? i just noticed it is slower than calling the executable directly
15:18:10 <Hijiri> maybe it calls runhaskell?
15:18:12 <dcoutts_> hexagoxel: rebuilds if necessary, and runs with access to local data files
15:18:16 <Hijiri> oh
15:18:18 <hexagoxel> "cabal help run" does not explain anything; "cabal help" says "runs the compiled executable"
15:18:18 <kadoban> gaze__: Ah, so real-time computing
15:18:49 <gaze__> kadoban: Oh yes yes. Very real-time. Each instruction has a time associated with it
15:18:59 <gaze__> kadoban: you can program it down to about 4 nanoseconds
15:19:11 <silver> how accurate this real-time should be?
15:19:16 <silver> oh man
15:19:20 <silver> 4 ns
15:19:32 <EvanR_> intel used to be like that
15:19:44 <silver> http://stackoverflow.com/questions/15236238/current-state-of-haskell-soft-real-time
15:19:47 <hexagoxel> dcoutts: so is it normal that checking for "is rebuild necessary" takes ~3 seconds?
15:19:55 <kadoban> gaze__: Usually systems like that have entire hardware and software stacks to work with, or are you trying to build that part or something?
15:20:07 <hexagoxel> because it is slower even if no rebuild is necessary
15:20:19 <gaze__> kadoban: My team is. We already have a compiler for it
15:20:46 <gaze__> kadoban: But since all the functional units run different programs and take a certain amount of time to signal each other, it'd be nice to have a program that sanity checks it
15:21:34 <kadoban> gaze__: A compiler from what language? C or something? There's special languages I know that help deal with such issues, although I have no idea if any would be appropriate to your case...that's nearing the limits of my...very shallow knowledge on the subject
15:21:55 <hexagoxel> dcoutts: what does "access to local data files" mean? (and sorry if this is described anywhere; i have searched help and the user guide)
15:21:58 <gaze__> kadoban: Well, it compiles pulse sequences
15:22:41 <dcoutts_> hexagoxel: you know how you can list data files in a .cabal file and it'll install them for you, and you can ask Cabal to tell you where your data files got installed?
15:22:45 <gaze__> kadoban: With branching and other things that give enough intelligence to know to how to stabilize a qubit
15:22:56 <gaze__> but if there are languages I can take inspiration from, that'd be cool
15:23:03 <dcoutts_> hexagoxel: well, if you're using that mechanism then there's a slight problem when running in the build tree rather than from the installed location
15:23:42 <dcoutts_> hexagoxel: but the mechanism Cabal provides for finding data files in their installed location can use some env vars to be told where to find them in the build tree
15:23:43 <kadoban> gaze__: Hmm, yeah I mean if it was me I'd look at some of them at least, there's certainly been work on real-time computing that might help you. I know there's "synchronous programming languages" and real-time computing would be good terms to look for
15:23:50 <dcoutts_> hexagoxel: and that's one of the things that cabal run does
15:25:18 <gaze__> kadoban: ah esterel... yeah that might be a good inspiration
15:25:41 <gaze__> but we don't so much mind writing "assembly", it's checking if it's right.
15:25:53 <gaze__> so if I could find a total subset of the machine's assembly language
15:25:56 <gaze__> that'd be pretty sweet
15:26:28 <kadoban> gaze__: Yeah, it's possible that your case is easier, but I'd have to know way more about it to say...and there's probably better informed people
15:27:33 <hexagoxel> dcoutts: hmm i see, thanks for the explanation. (did not know about `data-files`.)
15:28:43 <kadoban> gaze__: Is there public info about your project? I'd be curious to browse if so
15:29:59 <gaze__> kadoban: There was a talk given at APS march meeting but we haven't published anything using the system quite yet
15:32:48 <kadoban> gaze__: Ah I see
15:34:10 <gaze__> kadoban: Yeah it's kind of an interesting platform and an interesting programming problem. Most questions of how to program a quantum computer have been from CS people wondering about ideal quantum computers... quantum turing machines, quantum lambda calculus
15:34:38 <gaze__> but you also wanna think about how to stabilize the state of the qubit in real time... and this has to be done by some machine which humans have to program
15:35:28 <fragamus_> omg how does one transpose a matrix in Linear
15:35:49 <kadoban> Yeah, it sounds really interesting. I've been slowly learning more about quantum computing here and there for a while now
15:36:41 <sveit> has anyone here built haskell on windows? I would like ghc to start using the new gcc, but the bootstrapping version seems to insist on using an old one. will this affect the output of the build?
15:36:44 <kadoban> gaze__: If you feel like sharing anything semi-publicly, I'd be happy to look at it, the problem you mentioned above specifically. If you PM me I can give you contact info. I'm pretty into algorithm analysis and it sounds like a fun problem. No guarantees I'll have any insights, but whatever
15:38:15 <gaze__> kadoban: I'm unfortunately somewhat new to the project and would probably be overstepping boundaries saying more than I already have, but I appreciate the offer!
15:38:24 <kadoban> Sure, no worries
15:51:37 <RyanGlScott> How do you specify constraints for an associated type? e.g., something like f :: (IsList a, Item a ~ Char) => a; f = "sd"
15:52:52 <RyanGlScott> Oops, that does work. Never mind.
16:01:17 <Denommus> I'm kinda confused by shakespeare
16:01:29 <Denommus> I want to use it in a webkitgtk project
16:04:47 <fragamus_> (in Walter Matthau voice) WHAT THE HELL are distributive functors
16:05:16 * hackagebot llvm-pretty 0.3.0.0 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.3.0.0 (TrevorElliott)
16:05:18 * hackagebot llvm-pretty-bc-parser 0.1.3.0 - LLVM bitcode parsing library  http://hackage.haskell.org/package/llvm-pretty-bc-parser-0.1.3.0 (TrevorElliott)
16:05:41 <ReinH> fragamus_: The categorical dual of Traversable, obviously. ;)
16:07:16 * dmj` thinkgs ghc taking 36 seconds to compile his types module is a problem
16:08:04 <fragamus_> somebody says I don't need transpose in Linear.  I salute the new way of doing it, but I need some kind of way to learn how to use these newfangled distributive functors to achieve the same end.
16:09:40 <fragamus_> To be distributable a container will need to have a way to consistently zip a potentially infinite number of copies of itself. This effectively means that the holes in all values of that type, must have the same cardinality, fixed sized vectors, infinite streams, functions, etc. and no extra information to try to merge together.
16:09:47 <fragamus_> this makes sense
16:10:32 <ionum> q
16:11:47 <athan> Does hindley-milner inference strictly deal with system F, or is it any kind of lambda calculus?
16:13:00 <glguy> fragamus_: You don't need to learn about distributive to transpose a vector in the linear library, 'sequence' will do
16:13:01 <glguy> Prelude Linear Data.Traversable> sequenceA (V1 (V2 'a' 'b'))
16:13:01 <glguy> V2 (V1 'a') (V1 'b')
16:13:34 <gaze__> athan: It presumably works on several different lambda calculi
16:13:35 <fragamus_> a matrix
16:14:28 <athan> gaze__: Awesome :) Thank you.
16:14:54 <gaze__> athan: Well... more specifically, HM works on a more restricted System F
16:15:42 <athan> gaze__: Restricted as in... ?
16:16:09 <gaze__> I'm not sure if this restricted system f is somehow the most general lambda calculus that HM applies to, but HM certainly doesn't apply to lambda calculi in general, since you can have for instance the untyped lambda calculus
16:17:21 <josephle> athan: HM cannot infer polymorphism of rank > 1
16:17:38 <josephle> system F allows for polymorphism of arbitrary rank
16:17:53 <josephle> that's perhaps one of the biggest restrictions
16:17:54 <athan> gaze__: That's what I was thinking... there has to be that notion of arity encoded in the types of terms - whether they accept arguments, I feel
16:18:07 <athan> josephle: Oh wow! Thank you!!
16:18:50 <gaze__> yeah. I think the restriction on system F that the HM inference algorithm works on is just called HM as well
16:20:23 <josephle> that being said, some googling turns up a paper by SPJ about inferring higher-ranked types
16:20:27 <josephle> http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
16:29:49 <athan> Couldn't HM be inferred though the simply typed lambda calculus, if term constants were deemed type variables?
16:30:01 <athan> so everything is polymorphic?
16:30:06 <dpwright> I know this probably gets asked a lot and I don't think there's a clear answer to it, but just in case there is and I've missed it: cabal version constraints
16:30:18 * hackagebot haskell-neo4j-client 0.3.0.6 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.6 (asilvestre)
16:30:24 <dpwright> until recently most of my haskell projects have just been personal things so as long as I could get it to build it didn't matter
16:30:52 <dpwright> but I've got a couple of things on hackage now, and literally every pull request I get is a tweak to my version constraints
16:31:06 <bitonic> I keep getting this very bizzarre compilation error on Travis: <https://travis-ci.org/agda/agda/jobs/38764504> (scroll to the end).  It's not a GHC error, I tried to compile with 7.0.4 manually and it works -- the ScopedTypeVariables is there
16:31:25 <bitonic> did anybody encounder such an error on the travis VMs?
16:31:41 <dpwright> the latest one (which I have yet to accept), just removes the constraint altogether -- I guess that's what that person had to do to get it to compile on his machine
16:32:29 <dpwright> but it seems the burden on library authors and package maintainers to keep these version constraints up to date is quite high, and more to the point they're quite hard to test because success or failure depends partly on what packages you happen to have installed on your computer at the time
16:32:35 <dpwright> I'm using sandboxes, but still
16:33:35 <dpwright> is there a better way?  Some sort of service that regularly checks to see if you can compile with the latest version of packages would be nice, but failing that a tool that I can run locally that tries to build it with various versions and tells me what works and what doesn't.. or something?
16:33:41 <dpwright> how do other people deal with this issue?
16:34:12 <geekosaur> removing constraints often causes problems as well, when an incompatible new version comes out
16:34:44 <dpwright> geekosaur: yeah, that's why I haven't accepted this pull request yet.  I can see how it would cause issues, but I'm not really sure what the best course of action is tbh
16:35:42 <geekosaur> cabal-constraints, cabal-progdeps can be useful
16:35:52 <dfeuer> Why does vector take so long to build?
16:35:54 <geekosaur> I don't think there's an automated way to test as yet
16:36:44 <myfreeweb> dpwright: here's an idea: run on Travis without constraints (shell script to remove them or just have a separate cabal file)
16:37:36 <dpwright> myfreeweb: I was wondering if I could strongarm travis into doing my work for me!  Just using a shell script to remove the constraints (or the upper constraints at least) seems like an interesting idea -- so simple!
16:38:16 <seangrove> dpwright: Have you tried CircleCI with Haskell at all? I'm curious about their support for it now
16:38:31 <dpwright> seangrove: I haven't.. in fact I haven't even heard of CircleCI
16:38:57 <seangrove> dpwright: Ah, no problem, was just curious. Saw a gist about them and haskell support, seemed pretty good
16:39:02 <dpwright> geekosaur: Thanks for those hints -- reading up on them now.
16:39:27 <dpwright> seangrove: Does it offer anything in particular that travis, etc don't?
16:40:28 <seangrove> dpwright: No idea - we sublease from them, but I don't use them (tried with our Clojure code a few years ago, but ran into issues). Just saw this gist https://gist.github.com/paf31/9c4d402d400d61a49656#comment-1318341
16:41:22 <seangrove> Probably not worth porting over existing travis projects
16:42:36 <dpwright> seangrove: Ah right, ok thanks.  I'll keep it on my radar
16:50:28 <mgaut72> Hi all, I am having an overly-lazy problem (I think).  I am working with Parsec, and using lenses to modify my parser state.  I am failing a few test cases, which I can get to pass by printing my parser state.  This makes me think its a laziness problem
16:53:15 <ReinH> mgaut72: you have test cases that depend on your parser behavior but don't evaluate your parser state? That seems strange.
16:53:34 <ReinH> mgaut72: can you show us a smallish example of this?
16:54:07 <mgaut72> ReinH: my cases *should* be evaluating parser state, but aren't for some reason
16:54:36 <mgaut72> ReinH: let me see if I can piece together enough of an example of what I have going on
16:55:21 * hackagebot conceit 0.2.0.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.2.0.0 (DanielDiazCarrete)
17:00:21 <mgaut72> ReinH: so I have a record, one of whose fields (call it _f) has type    Map String (Foo, Map String Bar)
17:00:21 <mgaut72> So then I have the lens  "f . ix <someString> . _2" that I am using to access and update the Map within my map.
17:01:37 <benzrf> mgaut72: that's not even a lens, that's a traversal
17:02:15 <mgaut72> benzrf: I don't really know the difference...
17:03:07 <benzrf> mgaut72: traversals are like lenses that may have zero or more targets
17:03:12 <mgaut72> it feels lens-ey since  <someString> is something that I have guaranteed to by in my map
17:03:26 <benzrf> yeah but ix will always be a traversal
17:03:32 <benzrf> for any structure
17:03:32 <mgaut72> ah ok
17:03:44 <benzrf> just because *you* know that the key will be there doesn't mean your program does
17:03:45 <edwardk> you can use singular (ix n) -- if you know the key is always there
17:04:02 <athan> Would the simply typed lambda calculus be an example of a CCC, where `meet` is simply inclusion in a context? For instance: `\Gamma, x:\sigma :- e:\tao` -> `\Gamma :- (\lambda x:\sigma . e):(\sigma -> \tao)`, could be seen as `uncurry`, where the comma (inclusion of a context before entailment) is `meet`, and the lambda is the exponential / implication. Am I on the right trail?
17:04:02 <benzrf> i mean, you can prove that kind of thing in languages like agda, but haskell isn't that powerful
17:04:16 <mgaut72> yea, I meant *I* know, not haskell
17:04:25 <benzrf> mgaut72: mhm
17:04:32 <benzrf> :t singular
17:04:33 <lambdabot> (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
17:04:41 <benzrf> that looks terribly dagnerous
17:04:45 <athan> I feel like it also has modus ponens though application
17:04:48 <benzrf> not that i can read that type :i
17:04:59 <edwardk> singular takes a traversal you 'know' only has a target and traverse the first target.
17:04:59 <mgaut72> benzrf: glad I'm not alone
17:05:07 <benzrf> athan: well wikipedia claims that the stlc is "the internal language of a ccc"
17:05:26 <edwardk> > [1,2,3]^.singular _head
17:05:27 <athan> benzrf: O: not there yet, sorry!!
17:05:28 <mgaut72> edwardk: is there something about the traversal that makes "too lazy"
17:05:28 <benzrf> > view (singular traverse) [4]
17:05:28 <lambdabot>  1
17:05:29 <lambdabot>  4
17:05:36 <benzrf> athan: no clue what that means :p
17:05:41 <benzrf> > view (singular traverse) []
17:05:41 <edwardk> > []^.singular _head
17:05:42 <lambdabot>  can't find file: L.hs
17:05:42 <lambdabot>  *Exception: singular: empty traversal
17:05:48 <benzrf> dang wow
17:05:52 <edwardk> > [1,2]^.singular _head
17:05:54 <lambdabot>  1
17:05:58 <edwardk> > [1,2]^.singular traverse
17:05:59 <lambdabot>  1
17:06:12 <edwardk> notice singular works with things that traverse more than one element, but the types aren't fully general
17:06:14 <edwardk> :t singular
17:06:15 <lambdabot> (Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
17:06:19 <edwardk> :t unsafeSingular
17:06:19 <lambdabot> (Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b
17:06:46 <edwardk> unsafeSingular on the other hand lets you only work with traversals that only have _exactly_ one element but can in exchange for that change types
17:06:54 <edwardk> :t partsOf
17:06:55 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
17:06:58 <edwardk> :t unsafePartsOf
17:06:59 <lambdabot> Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
17:07:02 <edwardk> similar
17:07:06 <athan> benzrf: Sorry, I didn't mean to be vague. Thank you for your guidance :)
17:07:13 <benzrf> my brain cannot parse these crazy types
17:07:23 <benzrf> athan: m8 i barely know what a CCC is
17:07:34 <benzrf> all i know is that it has products and exponentials
17:07:38 <benzrf> and i about 50% know exps
17:07:48 <edwardk> partsOf takes a traversal and gives you a lens to the list of targets of the traversal (subject to the assumption you won't change the length of the list)
17:07:51 <tromp> > 7 % 2
17:07:52 <lambdabot>  7 % 2
17:07:59 <tromp> > 7%2-35%16
17:08:01 <lambdabot>  21 % 16
17:08:14 <benzrf>   edwardk oh right i remember that one
17:08:15 <tromp> >  35%16-35%26
17:08:17 <lambdabot>  175 % 208
17:08:21 <edwardk> partsOf works all the time just silently breaking the lens laws if you give back a list too small. unsafePartsOf will error out if you shrink the target list
17:08:49 <benzrf> i recall whining about its existence to you as a defense for my idea of lensMap :: Lens s t a b -> Lens [s] [t] a b
17:08:53 <gaze__> yo is there anything that will autoderive zippers for me?
17:09:06 <benzrf> oh wait maybe that was [a]
17:09:12 <tromp> > (21 % 16) % (175 % 208)
17:09:14 <lambdabot>  No instance for (GHC.Real.Integral (GHC.Real.Ratio a0))
17:09:14 <lambdabot>    arising from a use of ‘M492946872442765854011649.show_M4929468724427658540...
17:09:14 <benzrf> yeah [s] [t] [a] [b]
17:09:28 <tromp> > (21 % 16) / (175 % 208)
17:09:29 <lambdabot>  39 % 25
17:09:32 <edwardk> partsOf is evil but useful
17:09:47 <benzrf> s-so could lensMap
17:11:12 <structuralist> what are some good resources for learning to write blazing fast haskell?
17:11:41 <structuralist> e.g. learning what unboxed and unpack are, etc.
17:11:42 <merijn> structuralist: Depends on how fluent you are in haskell already?
17:11:49 <structuralist> pretty fluent I'd say
17:11:55 <benzrf> @google good resources for learning to write blazing fast haskell?
17:11:57 <lambdabot> http://stackoverflow.com/questions/1012573/getting-started-with-haskell
17:11:57 <lambdabot> Title: functional programming - Getting started with Haskell - Stack Overflow
17:12:08 <merijn> structuralist: Actually, maybe a good start would be reading up on how haskell is compiled and what Core is like?
17:12:20 <merijn> structuralist: dons tends to have a bunch of blogposts on optimisation
17:12:33 <merijn> But I think a lot of it is just studying the generated Core
17:13:10 <dmj`> merijn: what's a good guide to core? I don't think I found the ghc user guide to be too helpful there
17:13:17 <pingu> does anyone here know how to drive the reducers library?
17:13:25 <merijn> structuralist: The STG paper should definitely explain unpack and unbox things
17:13:49 <gaze__> actually, lemme ask the real question. Say I have a datatype data X = A a b | B c, and I wanna derive something like data Xinsp = Ainsp | Binsp, and then something else that encodes the retrieval of the first argument of A, the second argument of A, the first argument of B, yada yada.
17:13:57 <merijn> structuralist: The details are out-of-date, but the high level overview is still good: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
17:13:59 <dmj`> merijn: there's one page on it: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/options-debugging.html#id540648
17:14:37 <merijn> dmj`: tbh, I read like 1 blog post and the STG paper and just staring at Core (Note: I've not done this a lot, I'm not a Core expert)
17:14:45 <merijn> But Core is a pretty simple language
17:15:10 <merijn> gaze__: For any datatype X?
17:15:19 <gaze__> yessir
17:15:37 <merijn> gaze__: Look into Data.Data, uniplate and GHC generics
17:15:47 <gaze__> maybe we can place some restrictions on the structure of X and possibly the types of a b etc.
17:16:52 <merijn> dmj`: I mean, does Core really have anything other than case-of/let/function application and coerce?
17:28:18 <endymus> @pl \f g x y -> f (x ++ g x) (g y)
17:28:18 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
17:28:26 <benzrf> endymus: ew!
17:28:47 <endymus> lol, that was funny, just read about at pl so trying it out
17:29:15 <merijn>  @pl is a great argument for non-pointfree code ;)
17:30:02 <jludwig> heh. neat
17:30:23 <merijn> If you like @pl, be impressed by @djinn. Theorems for free!
17:30:35 <merijn> @djinn (a -> b) -> Maybe a -> Maybe b
17:30:35 <endymus> show me an example
17:30:35 <lambdabot> f a b =
17:30:35 <lambdabot>     case b of
17:30:35 <lambdabot>     Nothing -> Nothing
17:30:35 <lambdabot>     Just c -> Just (a c)
17:30:39 <dmj`> merijn: yea, let allocates on the heap, case the stack... but yea, the black art of optimization
17:30:39 <endymus> cool
17:31:40 <merijn> endymus: It's based on Wadler's "Theorems for Free" paper, which talks about what parametric polymorphism lets you prove about functions. For example, there is only one (sane) function that implements that type
17:32:17 <merijn> There's a few more implementsation, but they all end up being "undefined", "\x -> undefined" and "x y -> undefined", which are decidedly silly
17:32:34 <endymus> thanks merijn
17:32:57 <merijn> endymus: Even more generally (as was discussed earlier today) this lets you prove that there is AT MOST 1 law-abiding Functor instance for any type
17:33:25 <merijn> (Unlike applicative and monad, which can have multiple law-abiding instances)
17:33:36 <nkar> is there a way to rewrite case () of _| p1 -> ... | p2 -> ... in a more succinct way?
17:33:53 <merijn> nkar: Yes, if you're ok with GHC-7.8 and later only solutions
17:34:03 <nkar> yes, I am.
17:34:08 <merijn> nkar: MultiWayIf extension, see user guide
17:34:17 <nkar> ah, right.
17:34:20 <nkar> thank you, merijn
17:35:12 <dmj`> multiwayif has been around since 7.6.1
17:35:54 <dmj`> nkar: https://ghc.haskell.org/trac/haskell-prime/wiki/MultiWayIf , it has your example exactly
17:36:34 <nkar> dmj`: thanks
17:37:54 <nkar> I wonder whether it's possible to combine it with LambdaCase, so I don't have to write the lambda
17:53:24 <aidenatt_> Hey everyone. :D
17:54:31 <vanila> hi
17:56:35 <ReinH> merijn: f _ _ = Nothing ?
18:00:45 <dfeuer> This whole co-name thing wouldn't work too well for me-- co-dfeuer=>cod-feuer = ... fish on fire?
18:10:44 <dpwright> myfreeweb: I didn't even need a shellscript in the end!  By adding a "NoUpperBounds" flag to my cabal file, and having Travis perform one build that sets it and the other builds without it, I can have it test both with and without upper bounds.
18:11:48 <xpika> is there a generic version of filter much like map is to fmap ?
18:23:22 <samba1> Is there a way to put something in the .ghci file to be executed upon startup as if I'd typed it - not a ghci command, but an expression. let one = 1, for example?
18:23:32 <benzrf> samba1: probably!
18:23:57 <samba1> benzrf: but then one isn't still in scope for me
18:24:12 <solatis> anyone with an opinion can recommend a http client library to me? is network.http good enough?
18:25:31 * hackagebot HaskellNet-SSL 0.2.5.2 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.5.2 (DanielWright)
18:26:03 <solatis> ok, and while we're at it, when should i use Either and when should I use Maybe ?
18:26:33 <solatis> and nevermind
18:26:43 <solatis> Either can carry information when things went wrong
18:30:31 <solatis> and to answer my earlier question, seems like Network.HTTP.Conduit is what i want
18:31:27 <solatis> (Network.HTTP is non-lazy, while the Conduit library is lazy)
18:45:31 <posco> how do I set a type in a where binding to be the same as in the function?
18:46:11 <geekosaur> ScopedTypeVariables extension, declare type variables to be shared with "forall" at the top level
18:46:11 <posco> fn a = gn a where gn :: a -> a
18:46:38 <samba1> Is there a way to put something in the .ghci file to be executed upon startup as if I'd typed it - not a ghci command, but an expression. `let one = 1`, for example? If I add it to my .ghci file I see it executed but one is not in scope afterwards. `one + 2` gives an error
18:46:41 <geekosaur> fn :: forall a. a; fn a = gn a where gn :: a -> a; gn ...
18:47:39 <posco> geekosaur: I'm getting  Could not deduce (a ~ a1)
18:47:53 <geekosaur> posco, the ScopedTypeVariables extension is important there
18:48:03 <geekosaur> it's what enables the "forall" magic
18:48:11 <posco> geekosaur: ok.
18:48:17 <geekosaur> {-# LANGUAGE ScopedTypeVariables #-} at the top
18:48:58 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
18:49:43 <posco> geekosaur: that did it. Thank.
19:10:52 <lpaste> benzrf pasted “cool lens” at http://lpaste.net/7629411228363784192
19:10:59 <benzrf> @letlpaste 7629411228363784192
19:11:03 <lambdabot>  Defined.
19:11:07 <benzrf> :t concatted
19:11:08 <lambdabot> Functor f => ([a] -> f [b]) -> [[a]] -> f [[b]]
19:11:11 <benzrf> ;)
19:11:26 <benzrf> :t (^.)
19:11:27 <lambdabot> s -> Getting a s a -> a
19:11:33 <benzrf> :t (^~)
19:11:35 <lambdabot> (Num a, Integral e) => ASetter s t a a -> e -> s -> t
19:11:38 <benzrf> :t (.~)
19:11:39 <lambdabot> ASetter s t a b -> b -> s -> t
19:11:48 <benzrf> how i do.
19:11:48 <edwardk> benzrf: =P
19:12:06 <benzrf> > over concatted reverse [[1, 2, 3], [4, 5], [6]]
19:12:09 <lambdabot>  [[6,5,4],[3,2],[1]]
19:12:15 <benzrf> woop
19:12:57 <benzrf> > over concatted sort [[5, 2, 1], [9, 2], [7]]
19:13:01 <lambdabot>  [[1,2,2],[5,7],[9]]
19:13:51 <crobbins> :t concatted
19:13:53 <lambdabot> Functor f => ([a] -> f [b]) -> [[a]] -> f [[b]]
19:13:59 <crobbins> :i concatted
19:14:06 <crobbins> @info concatted
19:14:06 <lambdabot> concatted
19:14:10 <crobbins> hmm
19:14:16 <crobbins> :t over
19:14:18 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
19:15:10 <simpson> crobbins: The source is at http://lpaste.net/7629411228363784192
19:15:20 <simpson> And that is both very cool and very scary. Nice!
19:15:52 <simpson> > over concatted tail [[1, 2, 3], [4, 5], [6]] -- What? Don't look at me like that. *Somebody* had to try it.
19:15:55 <lambdabot>  [[2,3,4],[5,6],[]]
19:16:20 <simpson> > over concatted (7:) [[1, 2, 3], [4, 5], [6]] -- Where's it go?
19:16:23 <lambdabot>  [[7,1,2],[3,4],[5]]
19:20:32 <trap_exit> was walking around today;
19:20:36 <trap_exit> guy asked for spare change
19:20:37 * hackagebot hsc3-utils 0.15 - Haskell SuperCollider Utilities  http://hackage.haskell.org/package/hsc3-utils-0.15 (RohanDrape)
19:20:47 <trap_exit> I gave him 12 pennites; he was like ... wtf ... before saying thanks
19:32:08 <benzrf> that was douchey
19:32:21 <benzrf> simpson: i invented it to do lensy depth first search on a rose tree
19:32:22 <benzrf> er
19:32:24 <benzrf> breadth
19:33:05 <simpson> Nifty.
19:35:02 <Denommus> What is the function similar to take, but that skips the first n elements?
19:35:42 <geekosaur> drop?
19:35:48 <Denommus> Thank you
19:38:48 <lpaste> benzrf pasted “pese of shit” at http://lpaste.net/6917346607495118848
19:38:57 <benzrf> @letlpaste
19:38:57 <lambdabot>  I couldn't find any paste under that ID.
19:38:59 <benzrf> @letlpaste 6917346607495118848
19:39:00 <lambdabot>  .L.hs:158:1:
19:39:00 <lambdabot>      Duplicate type signatures for ‘concatted’
19:39:00 <lambdabot>      at .L.hs:156:1-9
19:39:00 <lambdabot>         .L.hs:158:1-9
19:39:00 <lambdabot>  
19:39:03 <benzrf> oh
19:39:04 <benzrf> @undef
19:39:04 <lambdabot> Undefined.
19:39:06 <benzrf> @letlpaste 6917346607495118848
19:39:07 <lambdabot>  .L.hs:163:13:
19:39:07 <lambdabot>      Not in scope: ‘sequenceA’
19:39:08 <lambdabot>      Perhaps you meant one of these:
19:39:10 <lambdabot>        ‘T.sequenceA’ (imported from Data.Traversable),
19:39:12 <lambdabot>        ‘sequence’ (imported from Control.Monad.Writer),
19:39:14 <benzrf> dang it lambdabot!!!
19:39:22 <benzrf> @let sequenceA = T.sequenceA
19:39:24 <lambdabot>  Defined.
19:39:25 <benzrf> @letlpaste 6917346607495118848
19:39:26 <lambdabot>  Defined.
19:39:34 <benzrf> ok, check out this pese of crap
19:39:37 <benzrf> :t breadthFirst
19:39:38 <lambdabot> Applicative f => (a -> Bool) -> (Tree a -> f [Tree a]) -> Tree a -> f (Tree a)
19:39:50 <benzrf> probably not even close to law-abiding
19:40:07 <benzrf> (a -> Bool) -> Traversal (Tree a) (Tree a) (Tree a) [Tree a]
19:40:35 <benzrf> ya give a predicate and get back a traversal over the element[s] that match on a breadth first search
19:40:51 <benzrf> you only traverse more than 1 element if you have more than one result on the first matching row
19:41:33 <benzrf> you give a list because it splices over
19:42:06 <benzrf> this is of extremely limited utility and i basically made it for my cruddy lo-fi clone of a game that was basically about binary tree manipulation
19:42:24 <benzrf> still, it's a funnish traversal, even if it probably violates all the laws
19:44:16 <EvanR> laws were made to be broken
19:45:14 <benzrf> pooh
19:54:17 <ruukasu> shelf: were you ever in #r9k on rizon?
19:54:48 <shelf> imma go with 'no'
19:54:56 <ruukasu> :|
19:55:15 <benzrf> heh heh heh
19:55:24 <benzrf> shelf: i shared your gnu comment and ruukasu noted that he'd seen a shelf somewhere
19:55:41 * hackagebot yesod-bin 1.4.0.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.5 (MichaelSnoyman)
19:55:42 <ruukasu> shelf: are you the shelf on rizon at the moment?
19:56:25 <shelf> pm
20:00:41 * hackagebot yesod-auth 1.4.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.0.2 (MichaelSnoyman)
20:01:54 <xpika> is there a library for efficiently retrieving filepaths?
20:02:12 <xpika> like the command find
20:08:25 <erikd> xpika: i think find-conduit does what you want. also look in the filepath package
20:16:01 <xpika> erikd: thanks
20:23:09 <aeoril> I am interested in learning FP techniques, and have experimented a little with doing some FP type stuff in JavaScript since that is my background.  I have noticed some things are much slower using FP type things in JavaScript vs. more traditional ways, like using an [...].reduce(fn, initialValue) from its standard library.  Also, for me sometimes it is harder to understand the code.  I know
20:23:09 <aeoril> nothing about Haskell, but have been told it is a good programming language to learn FP.  Could I expect better performance in Haskell vs. JavaScript for doing something equivalent to the .reduce() mentioned above, perhaps as good as using a for loop in another language?  Would the FP code be easier to understand in Haskell than in JavaScript?  Sorry for asking a JavaScript question in a
20:23:09 <aeoril> Haskell forum, but it is where I am coming from
20:24:43 <aeoril> Here is an example in JavaScript that I am talking about in a performance site to compare:  http://jsperf.com/transpose/2
20:25:41 <aeoril> When I first looked at the transpose code that used a reduce() within a reduce(), it was very hard for me to understand it compared to the for loop code, and the performance is strikingly slower in JavaScript
20:26:35 <CodeWeaverX> If you’re going to really dig into FP, Haskell’s a pretty good way to do it.  (I’m sort of partway along learning myself).  It actually enforces, strongly, separating the imperative parts of your code from the pure parts.  And its type system is so strong that it will take getting used to coming from something which is type… uh… sloppy.
20:27:10 <CodeWeaverX> I’m fond of saying that by the time you get something to compile in Haskell it’s nearly bulletproof.  That’s not really true, but there are a lot of bugs which are harder to commit in Haskell than even other FP languages.
20:28:00 <CodeWeaverX> (I understand there’s a #haskell-beginners room you might want to look at too by the way)
20:28:03 <aeoril> CodeWeaverX I did not realize Haskell was a compiled language, and I have other backgrounds pre-dating Javascript in more strongly typed languages
20:28:36 <aeoril> CodeWeaverX ok, thanks
20:28:37 <CodeWeaverX> Fair enough, but Haskell is *really* brutal.  Just fair warning.  But once you appreciate what that does for you, the slight pain in your temple from fighting with it isn’t so bad. ;)
20:29:12 <CodeWeaverX> Haskell is compiled when you want it to be, but you can use its REPL interpreter to rapidly test and develop parts of your code or even run whole programs from it.
20:29:12 <shelf> If you're writing code that runs in the browser, you can compile Haskell with GHCJS or use a very similar language, Purescript
20:29:44 <CodeWeaverX> I do a lot of Haskell straight from its REPL.
20:30:09 <CodeWeaverX> Either a line at a time typed in, or by loading in the same .hs files that it uses for compiling.
20:30:15 <aeoril> where is the best place to get started with haskell on the web?
20:30:53 <aeoril> Also, is there a "standard" compiler/repl/environment people typically use?  I am on Windows 8.1, but also have a Linux machine
20:31:01 <shelf> the best place on the web to learn haskell, or the best place to start writing haskell for a website?
20:31:18 <aeoril> shelf to learn haskell
20:31:22 <aeoril> and FP in general
20:31:25 <shelf> @where lyah
20:31:25 <lambdabot> http://www.learnyouahaskell.com/
20:31:28 <shelf> @where rwh
20:31:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:31:45 <shelf> those are the most popular haskell books
20:32:06 <shelf> first one is easier, second one has more useful code and exercises
20:32:20 <aeoril> shelf ok, cool - thanks, and thanks CodeWeaverX
20:32:53 <shelf> good luck! people here will always help if you get stuck
20:33:11 <aeoril> Are FP styles necessarily typically slower than other styles, like a for loop vs. a reduce() or map() that takes a function argument?
20:33:13 <CodeWeaverX> Linux is a bit beter to have a standalone GHC install I think because Windows requires running under Cygwin, a faux-unix for providing tools.
20:33:20 <CodeWeaverX> But it’s not that hard under Windows either.
20:33:27 <aeoril> cygwin ... uggh ...
20:33:31 <CodeWeaverX> Yah.
20:33:43 <CodeWeaverX> Well, its a bit of a headache, but I’ve done it, its not that bad.  Lots of docs on how to.
20:34:01 <aeoril> CodeWeaverX I can always just use my Linux box - It is headless and I VNC into it
20:34:10 <aeoril> from my Windows 8.1 main
20:34:43 <CodeWeaverX> Whether FP styles are slower kind of depends on the language, its support libraries, its compiler if it has one, and so on.  But its sort of up there with all the other languages in the sense that… well… some haskell code can compile down to be as fast as C.  I’m doing some performance testing on that very thing myself in the last couple weeks.
20:34:50 <aeoril> CodeWeaverX it is just a slower box, it is my older pc
20:34:56 <shelf> aeoril: idiomatic haskell will usually perform well. similar complexity classes
20:35:32 <CodeWeaverX> Some languages aren’t designed to be high performance, but easy to write in and rapid devleopment, even in the FP world.  So, big mix.
20:35:33 <aeoril> shelf what do you mean by "idomatic?"
20:35:44 <aeoril> idiomatic*
20:36:00 <CodeWeaverX> idiomatic:  following common idioms.  Common patterns.  Nothing weird, in the normal style of the language.
20:36:19 <benzrf> i need    to   sleep
20:36:19 <aeoril> CodeWeaverX I thought that is what he meant, but just checking
20:36:25 <shelf> the style of code that a proficient haskeller writes
20:36:25 <benzrf> bye
20:36:36 <CodeWeaverX> I think you’ll be pleasantly surprised by the rapid development in the REPL, and the high performance from the compiler, generally.
20:37:20 <CodeWeaverX> And in any case, if you want to learn more about FP, again, its a really good language because it has such tight boundaries between the pure part of hte code (pure FP) and hte imperative parts (where you have to do things sequentially to do things like IO, where state mutation is more or less required).
20:37:32 <aeoril> CodeWeaverX does the compiler compile down to binaries I can run from the bash shell?  That way, I could compile C with GCC and compare to Haskell with GHC or whatever
20:37:40 <CodeWeaverX> Yup.
20:38:12 <aeoril> I am assuming GHC = "Gnu Haskell Compiler?"
20:38:21 <CodeWeaverX> Glasgow
20:38:28 <merijn> aeoril: heh
20:38:32 <aeoril> oh, ok
20:38:36 <merijn> Shouldn't it be GGHC by now?
20:38:48 <merijn> The Glorious Glasgow Haskell Compilation System? :p
20:39:00 <CodeWeaverX> Although proper comparisons should probably use a common back-end.  If you use clang with llvm, instead of gcc, and use haskell ghc and tell it to use the llvm backend, you’ll have a good comparison, especially if you use llvm3.4, which I think is the one GHC is comfortable with.
20:39:29 <CodeWeaverX> Not mandatory, but to compare apples to apples about the language itself (C vs Haskell).
20:39:40 <CodeWeaverX> I learned that lesson just a couple days ago.
20:39:41 <aeoril> ahhh, so the Haskell is compiled into C then GCC is run to compile it into object code?
20:39:46 <CodeWeaverX> No, it used to be.
20:39:49 <CodeWeaverX>  It isn’t any more.
20:39:53 <shelf> no, it's compiled di-- ok
20:40:03 <merijn> High-performance haskellers, a quick question: If I have an inner loop that needs to call a C function with as little overhead as possible, how much can I rely on GHC making that not suck?
20:40:15 <CodeWeaverX> But LLVM is the low level virtual machine assembler that clang (C/C++ compiler) can use, and Haskell can use, so that they both have common assemblers.
20:40:19 <aeoril> shelf di-- ok?
20:40:20 <merijn> I think GHC hasn't generated C in close to a decade?
20:40:54 <shelf> aeoril: sorry, CodeWeaverX answered before i could finish typing.
20:40:56 <CodeWeaverX> clang is often outperforming gcc as a compiler these days, and the LLVM common back end to GHC makes it ideal to do language comparisons.
20:41:00 <CodeWeaverX> Sorry.
20:41:05 <CodeWeaverX> *cough*
20:41:07 <merijn> CodeWeaverX: It really isn't
20:41:19 <CodeWeaverX> It certainly is on my box.
20:41:23 <merijn> clang is a better compiler in terms of compilation speed and errors
20:41:37 <merijn> But we're having 10-20% slowdowns using gcc-4.9
20:41:43 <merijn> vs clang
20:42:00 <CodeWeaverX> ie clang being slower?  I haven’t seen that… but I’m not at the head of both compilers, so fari enough.
20:42:07 <merijn> (in the sense that clang produces 10-20% slower code)
20:42:24 <merijn> CodeWeaverX: You're the first person I hear say that clang produces faster code :)
20:42:29 <CodeWeaverX> Anyway, that’s not the real point here… if you want to compare the languages, a common back end is probably the way to go.
20:42:45 <merijn> That depends
20:42:48 <CodeWeaverX> It kicks GCC’s ass by a wide margin on my box.
20:42:58 <merijn> CodeWeaverX: Yes, but how complex is your code? :)
20:43:01 <CodeWeaverX> But as I said, not at head on the compilers.
20:43:14 <CodeWeaverX> This is true, most of my tests have been smaller test cases.
20:43:36 <merijn> CodeWeaverX: Our code relies on functions being inlined 3-5 layers deep to not suck performance wise :)
20:43:53 <CodeWeaverX> Well, whatever.  We’re not going to get anywhere with this discussion, because its too dependent on compiler versions, hardware, OS, etc.
20:43:57 <merijn> Anyway
20:44:10 <merijn> Using a common backend is not really fair comparison either
20:44:19 <CodeWeaverX> And why would that be?
20:44:29 <merijn> The LLVM backend is good for *some* types of haskell code, and terrible for others
20:44:46 <CodeWeaverX> Can you give an example of the kind of code its terrible for?
20:45:03 <CodeWeaverX> I’d actually love to test it.
20:45:11 <CodeWeaverX> Right up my alley for what I’m playing with right now.
20:45:14 <merijn> For tight numerical loops LLVM is good, for higher level code it's worse. I don't remember exact details, but you can probably find benchmarks on the ghc-dev mailing list or GHC wiki
20:45:32 <CodeWeaverX> I may just do that.
20:45:56 <CodeWeaverX> Well, presumably you can get haskell to use GHC’s tools as a backend?
20:48:15 <CodeWeaverX> Anyway, we sort of got sidetracked.  It doesn’t really much matter, for the level of experimentation someone beginning to explore haskell as a compiled language is likely to care about.
20:48:48 <merijn> Which brings me back to my initial question of trying to decide between writing haskell code and calling C functions from there or writing an EDSL that generates C from my haskell code...
20:49:21 <CodeWeaverX> pfft, I think you probably have done more of this than I have, so… hopefully someone else will slide by with a great answer to that.
20:49:48 <assia_t> Hey guys
20:50:19 <assia_t> any fast ways of doing: `showHex` always output hexadecimal values with 2 cases?
20:50:28 <assia_t> > showHex '\n' ""
20:50:29 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Char)
20:50:29 <lambdabot>    arising from a use of ‘Numeric.showHex’
20:50:46 <assia_t> -- "a"
20:50:53 <assia_t> be -- "0a" ?
20:59:36 <pavonia> > reverse . take 2 . reverse . flip showHex "" $ 10
20:59:38 <lambdabot>  "a"
21:00:16 <pavonia> > reverse . take 2 . ('0' :) . reverse . flip showHex "" $ 10
21:00:18 <lambdabot>  "a0"
21:00:24 <pavonia> :/
21:00:41 <pavonia> > reverse . take 2 . reverse . ('0' :) . flip showHex "" $ 10
21:00:43 <lambdabot>  "0a"
21:00:47 <pavonia> > reverse . take 2 . reverse . ('0' :) . flip showHex "" $ 100
21:00:49 <lambdabot>  "64"
21:04:12 <Hijiri> > unsafePerformIO $ return ()
21:04:14 <lambdabot>  Not in scope: ‘unsafePerformIO’
21:12:16 <Javran> > floor (logBase 10 1000) + 1
21:12:17 <lambdabot>  3
21:12:25 <Javran> > floor (logBase 10 1001) + 1
21:12:27 <lambdabot>  4
21:12:46 <Javran> sounds not good :(
21:12:55 <Javran> > logBase 10 1000
21:12:58 <lambdabot>  2.9999999999999996
21:13:33 <Javran> if I take the floor of (logBase 10 10000), it'll get 2 instead of 3
21:14:19 <CodeWeaverX> Uhhhh… is that bad?
21:14:33 <monochrom> perhaps it is best to not go through floating point for this purpose
21:14:45 <pharaun> floating point is the root of all evils
21:14:53 <Javran> i know there is a length . show approach
21:15:29 <Javran> but just curious about this
21:15:33 <CodeWeaverX> If you’re depending on values of floating point that suddenly change your result when the values are differing down in the weeds, you’ve got a broken solution.
21:15:55 <merijn> Javran: It's correct, but I don't remember why
21:16:23 <merijn> Javran: Actually, it's fairly obvious
21:16:49 <merijn> 10^3 == 1000, therefore "logBase 10 1000 == 3"
21:17:13 <merijn> hmm, oh, plus two
21:17:28 <CodeWeaverX> Sure, but the act of performing a floating point version of logBase10 might get you very very close to, but not equal to, the exact answer you want.
21:17:39 <pharaun> randomly close
21:17:41 <CodeWeaverX> It depends on the implementaiton of logBase10, how it works out the answer.
21:18:31 <CodeWeaverX> You’re expecting an exact integer answer out of a floating point computation, where the answer could change based on the tiniest computational error, which can accumulate in complex floating point calculations.
21:19:02 <CodeWeaverX> You want this:
21:19:16 <CodeWeaverX> floor (0.5 + logBase 10 1000)
21:19:50 <CodeWeaverX> That makes it so the floating point answer is nowhere near the … well, cusp point of changing the answer of floor, but otherwise doesn’t change the answer of the result.
21:20:19 <monochrom> but floor (0.5 + logBase 10 900) is not what we want either
21:20:56 <CodeWeaverX> True, but no tiny ‘offset’ is going to be guaranteed to work for all values you put in for that last parameter.
21:21:05 <CodeWeaverX> What you want is a pure-integer solution to this problem.
21:21:22 <CodeWeaverX> Stop messing with floating point for what is essentially an integer problem. :)
21:21:29 <Javran> i see,
21:21:38 <CodeWeaverX> Repeatedly dividing by 10, and counting the number of times until you get to 1 (or 0) should do it.
21:22:46 <Javran> CodeWeaverX: I actually thinking about generating a list to do so, bascially the same thing
21:22:50 <CodeWeaverX> Actually the show / length trick isn’t a bad way to go.  That’s essentially what it’s doing.
21:23:00 <CodeWeaverX> Get show to turn it into a string, for the only purpose of using length on the resulting string.
21:23:13 <Javran> > take 10 (iterate (succ &&& (* 10)) (1,1))
21:23:14 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ (t, t1)
21:23:14 <lambdabot>  Expected type: (t, t1) -> t
21:23:14 <lambdabot>    Actual type: (t, t1) -> (t, t1)Occurs check: cannot construct the infinite...
21:23:14 <lambdabot>  Expected type: (t, t1) -> t1
21:23:14 <lambdabot>    Actual type: (t, t1) -> (t, t1)
21:23:22 <pharaun> how come we are doing this in float?
21:23:40 <CodeWeaverX> We shouldn’t be.  That’s the point. :)
21:23:48 <monochrom> mathematicians wrote that formula.
21:23:49 <Javran> because mathematicians do so
21:24:14 <monochrom> but mathematicians didn't use floating point either. they used ideal numbers.
21:24:24 <CodeWeaverX> Sadly, in ‘real number land’, computers have to approximate for anything other than integers  (and power-of-two-fractions).
21:24:39 <Javran> > take 10 (iterate (first succ . second (* 10)) (1,1))
21:24:40 <lambdabot>  [(1,1),(2,10),(3,100),(4,1000),(5,10000),(6,100000),(7,1000000),(8,10000000)...
21:24:42 <CodeWeaverX> That puts a bit of a challenge on programmers to find a ‘correct’ way to do it that lives with hardware limitations.
21:24:55 <CodeWeaverX> > [1]
21:24:58 <lambdabot>  [1]
21:25:00 <CodeWeaverX> Neat!
21:25:20 <Javran> BTW what's the shorthand for first f . second g?
21:25:22 <CodeWeaverX> A combination of ‘iterate’, ‘takewhile’, and ‘length’ would do it too.
21:25:27 <CodeWeaverX> dot operator.
21:25:51 <CodeWeaverX> f . g $ x == (f . g) x == f (g x)
21:26:16 <CodeWeaverX> Oh, well, I did g first.
21:26:21 <CodeWeaverX> But you get the idea.
21:26:47 <Javran> i meant there is an infix operator, f <something> g, which is equivalent to first f . second g
21:27:05 <CodeWeaverX> Like, apply f to a paramter, and then g to the result?
21:27:14 <CodeWeaverX> I just did that, but with f and g the other way around.
21:27:25 <pavonia> :t (***)
21:27:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:27:32 <Javran> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
21:27:33 <merijn> CodeWeaverX: No, you misunderstand the question
21:27:34 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:27:44 <CodeWeaverX> Oh, well, that’s not new. ;)
21:27:47 <merijn> :t (&&&)
21:27:48 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:27:51 <merijn> That or
21:27:53 <merijn> :t bimap
21:27:54 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
21:28:08 <Javran> thanks!
21:28:27 <CodeWeaverX> I have absolutely no idea what that does, and now I must find out.
21:28:51 <monochrom> CodeWeaverX: "first" and "second" are not English, but names from Control.Arrow
21:28:57 <merijn> :t first
21:28:57 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:29:16 <merijn> Also known as
21:29:17 <CodeWeaverX> Right, gotcha.  I haven’t dug into Arrow yet.  only encountered it in passing.
21:29:32 <merijn> :t first :: (a -> b) -> (a,c) -> (b,c)
21:29:33 <lambdabot> (a -> b) -> (a, c) -> (b, c)
21:30:19 <Javran> CodeWeaverX: "first" and "second" are handy when dealing with pairs :)
21:30:45 <Javran> > first succ (1,2)
21:30:46 <lambdabot>  (2,2)
21:30:51 <Javran> > second show (1,2)
21:30:53 <lambdabot>  (1,"2")
21:31:04 <CodeWeaverX> I see, lifting a function to operate on one or the other of a pair.
21:31:05 <CodeWeaverX> Clever.
21:31:21 <CodeWeaverX> Must start using that.
21:33:19 <aeoril> I went to ghc.haskell.org and learned some stuff about the compiler pipeline
21:33:52 <aeoril> It seems it can produce LLVM, Assembler or C output
21:34:04 <CodeWeaverX> The C output hasn’t been done in a long long time.
21:34:26 <CodeWeaverX> I think its deprecated except in special builds meant for bootstrapping new architectures or something.
21:34:27 <aeoril> CodeWeaverX I guess the wiki is outdated then
21:34:48 <CodeWeaverX> Maybe.  I’m only going off other bits of wiki.
21:35:20 <CodeWeaverX> Nope, most of the stuff in Control.Arrow makes my head hurt.  Gotta step back to a tutorial for that one.
21:35:35 <aeoril> I also went to the LLVM website and checked that out a little
21:36:18 <CodeWeaverX> the LLVM isn’t necessary.  Maybe merijn’s right about gcc being a better option.  It doesn’t really matter for your purposes, does it?  Unless you are looking for ultimate performance out of the gate?
21:36:47 <CodeWeaverX> Seems like a lot to worry about if you’re just getting started.  GHC compiles and builds haskell just fine with just the GHC Platform install you can download.
21:36:49 <aeoril> CodeWeaverX oh, i am just learning and stuff - just mosying around
21:36:53 <CodeWeaverX> Oh sure.
21:36:58 <CodeWeaverX> Don’t let me stop you.  Fascinating stuff.
21:37:16 <aeoril> CodeWeaverX yah, just curiosity, etc.
21:38:19 <aeoril> I am taking a break from coding (because I just ran out of gas) and am just hunting around at different things out of interest
21:38:44 <CodeWeaverX> There can be no better reason to poke around to learn new things than curiousity. :)
21:38:54 <aeoril> lol yah, I guess :)
21:39:45 <aeoril> Am I misspelling curiosity?  I think so ... hmm, curious ... lol
21:40:35 <aeoril> Ahhh ... google told me I was right!
21:40:44 <CodeWeaverX> Yes, that was my fault.
21:40:52 <merijn> aeoril/CodeWeaverX: The C backend is bitrotted and not included in the default distribution. The main reason to keep it around is in the case o having to bootstrap GHC on a new architecture
21:41:01 <aeoril> CodeWeaverX when I saw yours, I thought for sure you had it right and me wrong!
21:43:45 <fragamus_> OK now... I need the low down on distributive
21:44:02 <fragamus_> http://hackage.haskell.org/package/distributive-0.1.2/docs/Data-Distributive.html
21:44:16 <fragamus_> This isn't enough info for me to get it
21:45:04 <aeoril> merijn so it goes to c-- then LLVM?  Is the Assembler option still viable?
21:46:58 <merijn> aeoril: Native code gen is the default
21:47:31 <merijn> The compilation is Haskell -> Core -> STG -> Cmm -> LLVM or native code
21:48:27 <aeoril> merijn Do you know where that is documented (or would I have to look at the source?)
21:50:34 <merijn> aeoril: I dunno if this is explicitly documented anywhere
21:50:35 <CodeWeaverX> Seriously hard-core if you’re willing to dig into compiler source.  Two thumbs up.
21:51:25 <aeoril> CodeWeaverX well, I don't know if I am *willing*, but I did ask the question hoping for an easier way ...
21:51:33 <CodeWeaverX> You can find documentation on Core and STG independently out there, as far as I know.  I’ve got a doc or two talking about at least versions of core at stages in Haskell’s devleopment.  Helps in seeing wha tthe compiler’s optimizing to.
21:52:12 <merijn> aeoril: There's lots of documentation on the wiki and in papers, but whether there's a simple "1 stop" place I don't know
21:52:31 <merijn> aeoril: It depends on what you wanna know and why, I guess
21:52:41 <aeoril> CodeWeaverX considering at this point Haskell is just gibberish to me, it would be a long road since the compiler seems to be written in Haskell ... :)
21:53:35 <CodeWeaverX> I remember reading that it’s still technically possible to build a very early version of Haskell from C source to bootstrap the process.  I wonder if anybody’s been demented enough to try it?  GHC’s been around a long time. :)
21:53:57 <CodeWeaverX> Chain of compielrs building compilers
21:54:38 <aeoril> CodeWeaverX yah, compilers written in their own language and the "chain of compilers" always fascinated me
21:54:39 <jroesch___> aeoril: I've been digging into IR layers  lately and assembling an accurate and complete information about the current implementation can be difficult. Unfortunately it usually ends in reading papers, and/or the source (which is only bad when its literal haskell).
21:56:03 <aeoril> jroesch___ ok, just kind of ran into that stuff and it piqued my curiosity.  I probably would want to go on to LYAH or the other site at this point
21:56:25 <CodeWeaverX> well, aeoril, download a copy of the Haskell Platform from here: https://www.haskell.org/platform/  and start playing around with it in the REPL. :)
21:56:38 <CodeWeaverX> I got hooked on Haskell via LYAH.
21:56:44 <aeoril> CodeWeaverX ok, thanks ...
21:57:03 <jroesch___> aeoril: Its an interesting topic when the time comes. I've been studying STG very intently lately and its fun layer to work at
21:57:15 <CodeWeaverX> Though given the conversatons that show up in this room, I should probably be over in the haskell-beginners area. O.o
21:57:39 <aeoril> CodeWeaverX I should probably head there too ...
21:58:15 <Cale> Nah, don't be scared away
21:58:25 <Cale> People are totally willing to help out beginners here :)
21:58:28 <aeoril> My main interest (and what I am working on in Javascript also) is just learning FP techniques, really
21:58:34 <CodeWeaverX> Every time I think I’ve gotten clever, this place scares me.   I might have to stick around the IRC chats longer this time rather than vanishing into the mists.
21:58:51 <CodeWeaverX> But it scares me in a ‘lots to learn’ sort of way, which is good fear. ;)
21:58:59 <Cale> Yeah, just hanging around and picking things up by osmosis is pretty effective too.
21:59:28 <aeoril> I have found that just watching stuff go by and asking a question or two now and then can really help also
21:59:31 <Cale> If you don't feel at least a little at sea while learning stuff, you probably could be learning faster. :)
21:59:41 <CodeWeaverX> True.  Very true that.
22:00:12 <CodeWeaverX> I actually vaguely know what a Functor is.  Even an Applicative one. Basics.  Never thought my brain would wrap around that.
22:00:23 <CodeWeaverX> Also not strictly necessary to get started. ;)
22:00:54 * hackagebot scotty-binding-play 1.2 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.2 (YusukeNomura)
22:01:02 <CodeWeaverX> lists, tuples, lambdas, functions as ‘data’ and parameters, recursion, currying, partial application… enough to get really intriguing really fast.
22:01:04 <aeoril> In general, whether on ##javascript, #c, ##c++, here, etc. it never ceases to amaze me the amount of great talent there is that people show
22:03:57 <aeoril> ok, well thanks guys - I'll check back in when I look into haskell some more, or need help, or just want to idle ...
22:09:49 <AlecTaylor> hi
22:10:23 <AlecTaylor> I'm attempting to use this package: http://hackage.scs.stanford.edu/package/meldable-heap-2.0.1
22:10:58 <AlecTaylor> But I'm unsure how to instantiate a priority queue of that package, e.g.: findMin [1..5]
22:11:30 <aeoril> merijn this seems to diagram out what you just wrote to me above:  https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain (see diagram at bottom)
22:12:37 <aeoril> There is also a M.hi (interface file) generated
22:13:51 <aeoril> Oh, I guess it does not show "native code" though
22:14:48 <aeoril> merijn by "native code" do you mean native machine code for the given hardware platform?
22:15:19 <merijn> aeoril: Yeah
22:15:37 <aeoril> merijn I wonder why that diagram does not show that?
22:15:51 <merijn> aeoril: It lists "machine code" (asm code)
22:15:56 * hackagebot scotty-binding-play 1.2.1 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.2.1 (YusukeNomura)
22:16:41 <aeoril> Oh, but doen't that still need to be assembled by an assembler?
22:17:10 <aeoril> M.s -> assembler -> binary file
22:18:07 <aeoril> (I am forgetting how assembly code/assemblers/disassemblers work)
22:18:16 <merijn> Yeah
22:18:24 <aeoril> ok, thanks
22:18:40 <monochrom> strictly speaking, "assembly language" refers to writing like "load ax, bx". "machine language" refers to the numbers.
22:18:40 <merijn> Hold on
22:18:54 <merijn> Haskell Platform no longer installs an uninstaller on OSX?
22:19:02 <aeoril> monochrom yah, that is what I was (vaguely) remembering
22:19:18 <monochrom> in practice, you don't have to speak strictly :)
22:20:00 <aeoril> monochrom wouldn't the "M.s" (asm code) file output be the kind that would have "load ax, bx" though?
22:20:07 <mthvedt> i only speak strictly for performance reasons
22:20:11 <aeoril> * in that diagram ...
22:21:36 <monochrom> in the 1960s it was useful to make the distinction because, on old computers, you hand-booted a computer by flipping switches and pressing "enter" to enter a sequence of numbers. during that booting, you could not enter "add bx, cx" literally, you had to enter raw numbers.
22:22:01 <aeoril> monochrom I remember doing that when I was 14!
22:22:48 <aeoril> monochrom the computer was an "IMSAI" and it booted up CP/M from an 8" floppy, but you had to enter the bootstrap code from toggle switches on the front
22:22:59 <monochrom> :)
22:23:14 <aeoril> 8080 processor
22:23:28 <aeoril> (8 bit)
22:23:40 <aeoril> microprocessor
22:24:17 <monochrom> M.s contains "load ax, bx". it's assembly language. usually, gasm is used to turn that into numbers.
22:24:54 <aeoril> monochrom and, if I load the platform, it all "just works" ...
22:25:03 <monochrom> the picture says "machine code" because today it is anal to make the distinction :)
22:25:20 <jle`> sccrstud92__: hi
22:25:27 <aeoril> monochrom sounds stinky ...
22:26:16 <monochrom> fortunately, the corresponding flag for GHC is -fasm, not -fmachine. all is not lost. :)
22:26:27 <aeoril> lol
22:26:33 <xpika> `base'?
22:27:41 <xpika> How do swat this error message? Perhaps you haven't installed the profiling libraries for package `base'?
22:28:36 <xpika> alternatively is there any easy way to profile using cabal?
22:32:28 <merijn> xpika: Linux?
22:33:01 <merijn> xpika: Some distro's have the funny habit of deciding "oh, users probably don't want to install profiling versions when installing GHC" and strip the out of the binary distribution
22:34:27 <monochrom> yeah, if you don't have profiling for base, you are really in that situation.
22:34:52 <monochrom> look for your distro's package for profiling libs
22:38:10 <aeoril> I accidently closed out before being able to thank you monochrom.  I was just confused, and you cleared it up.  I appreciate the help.
22:38:18 <xpika> merijn: yes linux. installing profiling libraries now
22:38:21 <monochrom> you're welcome
22:38:29 <aeoril> ok, bye guys
22:40:35 <xpika> ok now it wants me to install the profiling libraries for the package ListLike. What now?
22:43:35 <monochrom> if you got a package from your distro, you look for the corresponding profiling package from your distro again.
22:44:34 <monochrom> if you got a package by cabal-install, you make cabal-install rebuild it again, this time enabling profiling. you may have to transitively do this to dependencies.
22:44:49 <merijn> Is there a way to install only a few specific packages in a sandbox, but do the rest in the user package database?
22:45:20 <merijn> afaik, when I do "cabal sandbox init" *everything* goes into the sandbox
22:45:32 <monochrom> in theory, that depends on who wrote the sandboxer. in practice, all sandboxes diable user.
22:45:43 <monochrom> s/diable/disable/
22:46:13 <monochrom> or perhaps ignore, suppress, hide... anyway, all existing sandboxers make user invisible
22:46:28 <merijn> monochrom: huh, I'm pretty sure it just uses user level packages when the right version is already installed
22:46:59 <merijn> monochrom: Also "all existing sandboxers" <- why plural?
22:47:13 <monochrom> hsenv, cabal-dev, cabal-install
22:52:21 <Fuuzetsu> monochrom: it's probably faster to install nix and ask for profiled package set than rebuilding every dep ;P
22:52:22 <merijn> monochrom: btw, your SICP article says to avoid multiple installed versions of the same package, why is that a problem?
22:53:39 <monochrom> it has good possibility of diamond butterfly kind problems. X is built against B-1, Y is built against B-2, Z uses X and Y.
22:54:02 <monochrom> actually, that is not the only scenerio.
22:54:35 <monochrom> when you run ghci, for example, ghci defaults to the highest version for each package, and ignores other versions.
22:56:30 <monochrom> the fun begins when you possess containers-1000.234.212.498323, so it is selected, and then you try to use template-haskell, which is built against wimpy contains-0.5.5.1, which is ignored in favour of containers-1000.234.212.498323
22:57:03 <monochrom> the fun ends with "I can't use template-haskell, I can't find its dependencies"
22:57:21 <merijn> Next plan of attack
22:57:39 <merijn> Just install all non-conflicting dependencies manually before using the sandbox >.>
22:57:52 <monochrom> many confusing things happen when multiple versions co-exist. ghc confuses itself, and then confuses you.
22:58:21 <merijn> monochrom: yes, but rebuilding *everything* for every single project sucks :\
22:58:26 <monochrom> there are carefully-treading ways to have them co-exists. you need to be a pro to know how.
22:58:38 <merijn> Time to kidnap ezyang's family in order to speed backpack along...
22:59:05 <monochrom> and above all you end up doing manual dependency chasing.
22:59:22 <joelteon> better than manual family chasing
23:01:57 <Fuuzetsu> merijn: package managers exist so you don't have to rebuild everything…
23:03:30 <monochrom> you need to hire a human package manager :)
23:04:01 <monochrom> employment exists to solve all problems that are solvable by throwing money at employees
23:04:53 <Fuuzetsu> spend that money on computers so you *can* rebuild everything ;)
23:05:39 <solatis> Fuuzetsu: but that will not make cabal shut up... :)
23:05:39 <merijn> heh
23:05:39 <merijn> looks like cabal was just coming up with a dumb plan
23:06:13 <Fuuzetsu> solatis: well, if we're throwing money then maybe we should just pay someone else off to write the program
23:06:20 <Fuuzetsu> and ban them from complaining in #haskell
23:06:23 <Fuuzetsu> perfect
23:06:42 <solatis> Fuuzetsu: hiring people to write haskell code? are you insane?
23:06:43 <merijn> It was finding all sorts of transformers incompatibilities and after manually installing the dependencies I cared about the conflit magically disappeared
23:06:52 <solatis> that just takes all the joy out of spending money
23:07:23 <Fuuzetsu> merijn: something probably broke somewhere somehow
23:07:26 <merijn> Fuuzetsu: If I build every haskell project in a sandbox then my package manager isn't really doing anything, now is it?
23:07:51 <Fuuzetsu> merijn: correct, which is why I would advise you get a better package manager instead
23:08:04 <monochrom> but your package manager manages vlc and gcc for you
23:08:16 <adarc> hey, im trying to create instances for ToJSON/FromJSON for some huge record.. The record contains bytestrings from Data.ByteString. ToJSON/FromJSON instances are crying about: No instance for (ToJSON ByteString) .. howeer, i'm looking in Data.Aeson.Types and I see the instances for ByteString in there.. Anyone have any idea how to fix my life?
23:08:28 <Fuuzetsu> if I was a dirty VLC user
23:08:42 <solatis> adarc: could be lazy versus non-lazy bs/
23:08:53 <merijn> The only things that aren't installed are network-2.6 (which I can dump in the sandbox) and a local library I was planning to sandbox too. Cabal, I am disappoint
23:09:04 <Fuuzetsu> could also be that the instance has been moved in and out of aeson a bunch
23:09:22 <Fuuzetsu> I thought that currently ByteString instance wasn't in aeson
23:09:39 <merijn> Which money?
23:09:50 <merijn> holy christ, lag spike
23:10:04 <Fuuzetsu> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html
23:10:07 <merijn> monochrom: Actually, it doesn't :)
23:10:12 <Fuuzetsu> adarc: I don't see ByteString there
23:10:18 <Fuuzetsu> I think I even have an issue somewhere on this
23:10:26 <merijn> monochrom: I install VLC by downloading a binary and clang I install via the app store :p
23:10:39 <Fuuzetsu> (I have no idea what's going on in that instances box)
23:10:44 <monochrom> oh, you're on Mac OS?
23:10:58 <Fuuzetsu> https://github.com/bos/aeson/issues/187 on ByteString in aeason
23:11:11 <Fuuzetsu> aeson*
23:11:17 <adarc> solatis: thanks.
23:11:23 <adarc> Fuuzetsu: maybe i'm looking at an older version, eek!
23:11:43 <Fuuzetsu> most likely
23:12:01 <Fuuzetsu> if you googled for aeson and clicked on hackage link, you're probably in 2009 or something
23:12:14 <adarc> haha.. ya I try to avoid that
23:12:20 <Fuuzetsu> hm, first release in 2011
23:12:23 <adarc> i'm very tired though right now.. so I may have ctually done that
23:12:50 <merijn> monochrom: Yes
23:12:56 <xpika> is there any way i can profile just the functions that i wrote so that i don't need profiling libraries
23:13:05 <joelteon> the older the page, the more important it must be!
23:13:08 <merijn> monochrom: I wish the bleeding edge wasn't so awful :(
23:13:20 <joelteon> xpika: absolutely not
23:13:42 <monochrom> (joke) I wonder if the fine folks at the Genius Bar can help you... :)
23:14:30 <monochrom> does hugs have profiling?
23:14:48 <merijn> My problem is that I want the bleeding edge to ditch a bunch a junk I don't care about, but of course old versions of the core libraries get in the way >.>
23:14:57 <pharaun> i wish google stopped that shit (linking to old version of docs)
23:15:00 <pharaun> gets really old really fast
23:15:22 <solatis> pharaun: i think you can give google pretty good instructions in robots.txt
23:15:26 <Fuuzetsu> I just bound hackage search to some keys in my browser and always use that
23:15:43 <solatis> i think it's more a matter of hackage not being properly optimized for google
23:15:53 <pharaun> solatis: sounds like a nice feature improvement to me
23:15:58 <pharaun> Fuuzetsu: i keep on forgetting about that
23:16:01 <pharaun> i should just do that really
23:16:06 <solatis> there isn't even a robots.txt
23:16:31 <monochrom> speaking of which, have you seen the robots.txt of last.fm?
23:16:37 <solatis> yes
23:16:40 <monochrom> :)
23:16:43 <pharaun> i have not
23:16:48 <pharaun> yelp used to have a funny robot.txt
23:16:51 <merijn> Fuuzetsu: As for using "proper" package managers, I'm guessing you're refering to the cult of nix. But that requires to learn even more irrelevant junk tools I don't care about
23:16:57 <monochrom> it contains the 3 laws :)
23:17:17 <pharaun> oh aw they removed blender
23:17:25 <pharaun> it at least has the 3 laws (re yelp's)
23:17:33 <pharaun> old old version used to have blender in it
23:17:44 <merijn> Fuuzetsu: I hate it when the answer to my tool problems is "Learn more/newer tools" >.>
23:17:56 <Fuuzetsu> merijn: well, enjoy your shitty old tools like you are now
23:18:11 <Fuuzetsu> also I'm not refering to nix explicitly but most other package managers fail here
23:18:13 <pharaun> ha (re last.fm)
23:18:27 <solatis> Disallow: /harming/humans
23:18:29 <solatis> Disallow: /ignoring/human/orders
23:18:31 <solatis> Disallow: /harm/to/self
23:18:31 <pharaun> yup
23:18:33 <solatis> for the lazy
23:18:35 <solatis> :0
23:18:42 <pharaun> monochrom: solatis yelps has the actual text in the comment
23:18:44 <pharaun> hilarious
23:18:59 <pharaun> i'm disappoint tho that they removed blender ascii art
23:19:14 <Fuuzetsu> gotta cut bandwidth costs
23:19:26 <pharaun> and be all corporate
23:19:28 <pharaun> boo :p
23:20:25 <merijn> Fuuzetsu: I'll just let everyone else smooth out the pain points before switching routines, as my current problem is only "I'm wasting CPU cycles" not "things don't work" :)
23:20:25 <nshepperd> nix seems like overkill for just managing the contents of your ~/.cabal and ~/.ghc
23:20:59 <solatis> nshepperd: i've switched thanks to Fuuzetsu, and could not live without it anymore
23:21:05 <solatis> i don't issue a single cabal command anymore
23:21:12 <Fuuzetsu> liar, bet you use cabal sdist
23:21:17 <solatis> nop
23:21:38 <nshepperd> all I want is just a version of cabal-install that lets me a) uninstall things and b) magically reinstall new versions to solve constraint conflicts
23:21:40 <solatis> i build docker images, install it using nix-env -i foo-wrapper :)
23:21:48 <solatis> i run my own Hydra
23:21:50 <solatis> muha
23:21:52 <solatis> :)
23:22:09 <solatis> nshepperd: that does not exist
23:22:34 <nshepperd> "rm -rf ~/.ghc ~/.cabal ; cabal update ; cabal install everything" basically does this, except really slowly
23:22:37 <Fuuzetsu> nshepperd: a) cabal is not a package manager b) magic is usually not good, you want something that lets different versions co-exist
23:23:16 <solatis> i always liked NPM's aproach to this problem
23:23:33 <nshepperd> if I want to let different version coexist, I can use a sandbox
23:23:39 <Fuuzetsu> anyway it's certainly easier (and faster) to learn nix than to deal with cabal bullshit every day, or sandbox everything alal the time
23:23:46 <xpika> joelteon: is there a reason why?
23:24:15 <solatis> nshepperd: what if you use package A that depends in Z-0.1, and package B that depends on Z-0.2 ?
23:24:44 <Fuuzetsu> two sandboxes ;P
23:24:54 <solatis> within the same application?
23:24:58 <solatis> ugh
23:25:00 <solatis> :)
23:25:08 <nshepperd> if I want to use them together, I use add-source and patch the damn thing to update the dependencies
23:25:15 <monochrom> under suitable circumstances, you simply can't use A and B together then.
23:25:46 <solatis> i had that problem -- one package using persist-2.0, other package using persist-1.x
23:25:50 <nshepperd> or I would, if add-source worked outside of sandboxes
23:25:52 <solatis> totally different interfaces
23:25:54 <monochrom> here is one circumstance. Z contains C code. Z-0.1 and Z-0.2 will both export the same C name "hello". the linker will not like it.
23:26:09 <nshepperd> I suppose there's some magic option you can put in ~/.cabal/config to do the same thing as add-source
23:26:20 <monochrom> in practice, this happens to bytestring.
23:27:58 <monochrom> you could try to administer your own repo (in addition to hackage, if you like) using my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#local-repo
23:28:34 <monochrom> however, I still haven't experimented with what happens if two repos both have "Z-0.3"
23:31:54 <solatis> i am of the opinion that there are some really bad design problems with cabal, and people have succeeded a lot in working around these problems, but they're solutions to symptoms, not the actual problems
23:37:20 <pharaun> and the actual problem is?
23:41:44 <nshepperd> the way I understand it, problem 1 is that ghc does lots of cross-module inlining, which is why we are always recompiling things
23:44:05 <nshepperd> problem 2 is that packages "often" make breaking changes, so that we need version constraints
23:44:28 <nshepperd> I don't think either of these are really problems with cabal though
