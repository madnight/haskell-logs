00:00:08 <Axman6> :t either (\_ -> "Error: Invalid Encoding>") id
00:00:09 <lambdabot> Either a [Char] -> [Char]
00:00:17 <Arahael> So it looks like pattern matching wasn't helping me.
00:00:38 <Axman6> yeah in this case it seems to make things quire verbose
00:01:49 <Arahael> Is there a 'rule of thumb' for this, or will I just intuit it as I get experience? (Which would doubtlessly happen, but rules of thumb can accelerate this process...)
00:02:40 <Arahael> Because after looking at this, I might well use 'do notation' whenever I can.
00:02:46 <merijn> Arahael: Write code -> decide it looks ugly -> attempt to refactor aggressively -> repeat :)
00:02:49 <Axman6> it's just a matter of getting used to code patterns and seeing easier ways to write them
00:03:04 <Arahael> merijn: Heh, that's just what I'm doing! :)
00:03:08 <Axman6> merijn: the essence of programming
00:03:43 <Arahael> Incidentally, would anyone happen to know if HTTP headers are ever _not_ ascii text?
00:03:46 <merijn> Arahael: It's not uncommon for me to write some 50-100 lines of new code and by the end of the 2nd refactor most of it has evaporated into 10 or so lines
00:03:57 <merijn> Arahael: Read the spec?
00:04:00 <Axman6> Arahael: you could always check the spec
00:04:02 <Axman6> heh
00:04:14 <Arahael> Heh.  In this case the spec doesn't specify the encoding, from what I understand.
00:04:27 <Arahael> But there's a defacto encoding, of ascii.
00:04:41 * hackagebot btrfs 0.1.1.0 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.1.1.0 (MariosTitas)
00:04:49 <merijn> I doubt that HTTP doesn't specify encoding
00:05:05 * Arahael checks again.
00:05:35 * hackagebot codecov-haskell 0.1.0 - Codecov.io support for Haskell.  http://hackage.haskell.org/package/codecov-haskell-0.1.0 (killy971)
00:05:35 * hackagebot btrfs 0.1.1.0 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.1.1.0 (MariosTitas)
00:05:47 <merijn> Arahael: Section 2, basic rules and the reference to the BNF rfc seem to spell out exactly what is and is not valid
00:07:46 <Arahael> Looks like the only thing I should be careful of there, are where it specifies "OCTET".  Perhaps I should check with the snap framework why they use ByteStrings here, then - but later, when I have time.
00:07:58 <Arahael> Daylight savings just kicked in, and it looks like I'm 40 minutes late. :)
00:08:14 <Arahael> merijn: Thanks for that prod. :)
00:08:27 <Axman6> Aus?
00:08:30 <Arahael> Indeed.
00:09:05 <Axman6> G'Day from the city that is responsible for all the national decisions
00:09:17 <Arahael> Axman6: Thanks for the help. (And merijn for getting me to re-check the spec)
00:09:25 <Arahael> Axman6: Please don't remind me!
00:17:12 <lpaste> pjdelport annotated “No title” with “Formatting the headers using an OnDecodeError handler” at http://lpaste.net/112119#a112124
00:18:07 <pjdelport> Arahael: How does that look?
01:00:32 * hackagebot linear-vect 0.1.1.0 - A low-dimensional linear algebra library, operating on the Num typeclass  http://hackage.haskell.org/package/linear-vect-0.1.1.0 (capsjac)
01:05:08 <no-doz> :t if'
01:05:09 <lambdabot>     Not in scope: ‘if'’
01:05:09 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
01:05:16 <pjdelport> :t bool
01:05:16 <lambdabot> a -> a -> Bool -> a
01:05:19 <pjdelport> no-doz: -^
01:05:37 <no-doz> ty
01:06:38 <no-doz> > bool 1 0 True
01:06:40 <lambdabot>  0
01:08:15 <no-doz> it's backwards ;o
01:08:24 <mauke> @src Bool
01:08:25 <lambdabot> data Bool = False | True deriving (Eq, Ord)
01:08:32 <mauke> False first
01:08:36 <kazagistar> I am getting an error... "Could not deduce Traversable (Either x) ..." but I clearly see that (Either a) implements traversable, what could be going wrong?
01:08:40 <no-doz> fair enough
01:08:58 <mauke> kazagistar: missing an import?
01:10:11 <kazagistar> mauke: I have both Data.Either and Data.Traversable at the top...
01:11:01 <mauke> oh, wait
01:11:07 <mauke> kazagistar: what's the complete error message?
01:12:17 <jle`> kazagistar: what ghc version are you using?
01:12:23 <jle`> i think 7.6 doesn't have a Traversable (Either a)
01:12:30 <kazagistar> CodeWars
01:12:31 <jle`> load up ghci and check if your version has it
01:12:32 <kazagistar> that might be it
01:12:33 <jle`> ah
01:13:07 <kazagistar> ... this Kata is pretty stupid so far, but I am so far along I can't stop now
01:13:11 <jle`> heh
01:13:16 <jle`> well, it isn't too much to write your own instance
01:13:23 <kazagistar> ill do that
01:13:27 <jle`> just look at the Maybe instance to get a hint if you're stuck
01:14:08 <kazagistar> "implement lens"... sure, I am mostly done, by just randomly following types, and I feel like I understand lenses less if anything
01:16:39 <kazagistar> I guess I never learned much of anything from just "doing the algebra" without understanding what it means
01:19:58 <jle`> so after some deliberation i am switching my position on the burning bridges proposal to be towards retaining the list version of mapM_/sequence/etc. in Prelude
01:20:01 <xeno> yay! I just finished going through "Beginning Haskell" and implementing almost everything... great book... some typos/inconsistencies, but I blame that on the generall APress syndrome...
01:20:03 <jle`> let it be known in the logs
01:20:35 <xeno> it's not often I can say "Great book" about anything released by APress...
01:20:45 <jle`> heh
01:20:55 <jle`> i think it's come under some criticism recently
01:21:03 <jle`> but i'm glad you survived it without having too much damage
01:21:05 <jle`> :P
01:22:17 <xeno> what is it criticized for? the only really annoying thing was that there was cross references through the book to some data structures that were defined slightly differently different places...
01:23:05 <jle`> i'm not totally sure...the typos and inconsistencies i think were at times at critical parts
01:23:07 <jle`> hm
01:23:28 <jle`> i forgot the main complains
01:24:41 <xeno> well, APress generally don't seem to do their part of the publishing job, so anything printed by them is bound to have a ton of typos and inconsistencies
01:25:54 <xeno> I managed to buy "The Definitive Guide To Lift" once - that one had missing appendixes, no real structure and generally chaos all over...
01:26:15 <amatsu> I have some bz2 compressed data that I want to convert into some uncompressed text format (one transformation per line), but the file is too big to hold in memory uncompressed.
01:26:45 <amatsu> lazy I/O on a list seems to consume too much memory, is there some other streaming framework I can use that will use less memory?
01:27:31 <xeno> amatsu: conduit maybe?
01:27:42 <Cale> http://hackage.haskell.org/package/bzlib-0.5.0.4/docs/Codec-Compression-BZip.html seems to operate on lazy bytestrings
01:28:32 <amatsu> I'm using Codec.Compression.BZip at the moment, but when traversing through the list, the processed part never seems to get deallocated
01:28:51 <Cale> hmm
01:29:00 <amatsu> I compiled it with -prof and most of the memory consumption seems to be PINNED, or in ARR_WORDS so I'm guessing it's bytestring's fault
02:36:49 <trap_exit> what's the best way to develop for the occulus in haskel ?
02:47:25 <baadupo__> Hi. Is there a Equivalent of zipWith for CArray?
02:47:46 <ddellacosta> has "\/" ever actually been a part of Haskell syntax (for disjunction)?  Saw it in this paper: http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps.gz
02:48:07 <baadupo__> The arrays are guaranteed to be equally long
02:48:26 <trap_exit> is \/ valid syntax?
02:48:30 <trap_exit> as \ is reserved for lambda
02:48:37 <trap_exit> as in (\x -> ... )
02:49:18 <ddellacosta> trap_exit: it's not valid syntax now, as far as I can tell.
02:49:30 <ddellacosta> trap_exit: I'm just curious if it ever was.
02:50:06 <trap_exit> ddellacosta: ah, understood
02:56:57 <mauke> > let a \/ b = a + b in 2 \/ 3
02:56:58 <lambdabot>  5
02:57:02 <mauke> valid syntax, sure
02:59:26 <caulagi> Hello - what am I missing here?  http://pastebin.com/PQCiSk6h
02:59:31 <jle`> > let (\/) = (||) in True \/ False
02:59:33 <lambdabot>  True
02:59:42 <caulagi> I don't understand how to define my own data type
03:00:13 <mauke> caulagi: add 'deriving (Show)' after your 'data' thing
03:00:27 <mauke> ghci doesn't know how to print values of your new type
03:00:44 * hackagebot clean-unions 0.0.2 - Open unions without need for Typeable  http://hackage.haskell.org/package/clean-unions-0.0.2 (FumiakiKinoshita)
03:01:11 <caulagi> mauke: thanks, that worked
03:01:26 <jle`> > let (\/) = union in [1,2,3] \/ [5,6,7]
03:01:28 <lambdabot>  [1,2,3,5,6,7]
03:01:35 <caulagi> but that is how I define my Response?
03:01:56 <mauke> huh?
03:02:05 <caulagi> what is the difference between saying
03:02:07 <caulagi> data Sublist = Equal | Unequal | Sublist | Superlist deriving Show
03:02:13 <caulagi> type Sublist = Equal | Unequal | Sublist | Superlist deriving Show
03:02:21 <mauke> the latter is a syntax error
03:02:24 <caulagi> not sure second is valid
03:02:25 <mauke> you can't have | in type
03:02:35 <mauke> 'type' creates a new name for an existing type
03:02:53 <jle`> if you have ever used C/C++, type is sort of like typedef
03:03:23 <caulagi> is there an analogy to python?
03:03:24 <mauke> exactly like typedef, even. except you can't parameterize C++ typedefs
03:03:29 <mauke> no, python doesn't have types
03:03:38 <jle`> the analogy to python would be...
03:03:41 <caulagi> but data is like a class in python?
03:03:45 <mauke> no
03:03:45 <jle`> if you ctrl+f'd your entire file
03:03:51 <jle`> and replaced all occurances of A with B
03:03:55 <jle`> that would be like type B = A
03:03:59 <mauke> hmm
03:04:16 <mauke> I guess something like B = A; obj = B() ?
03:04:24 <mauke> and that actually creates an instance of A
03:04:47 <jle`> heh
03:05:00 <jle`> i think a nice way to look at it is basically just lexical substitution
03:05:21 <jle`> as if someone runs a big ctrl+f/replace s/sed/command over your file before it is compiled
03:05:44 * hackagebot fingertree-tf 0.1.0.0 - Generic finger-tree structure using type families.  http://hackage.haskell.org/package/fingertree-tf-0.1.0.0 (pawel834)
03:05:45 <mauke> type Foo a = [a] -> Int
03:05:49 <caulagi> jle`: what about data?
03:05:53 <mauke> data creates new types
03:06:07 <jle`> data is literally creating a new type.  so.  it's rather unfortunate naming
03:06:13 <mauke> if you've used C/C++, it's like struct/union/enum rolled into one :-)
03:06:15 <caulagi> do types have behaviour also?
03:06:18 <mauke> no
03:06:48 <mauke> except if you squint really hard at record types
03:06:51 <mauke> but that's just sugar
03:07:07 <caulagi> ok - let me do some reading and get back.  Thanks mauke, jle`
03:07:31 <mauke> data Foo = Bar{ baz :: Int, quux :: [Double] }
03:07:36 <mauke> that's more or less equivalent to:
03:07:44 <mauke> data Foo = Bar Int [Double]
03:07:53 <mauke> baz :: Foo -> Int; baz (Foo x _) = x
03:08:01 <mauke> quux :: Foo -> [Double]; quux (Foo _ y) = y
03:10:45 <SwashBuckla> I usually wibble after baz
03:10:50 <SwashBuckla> instead of going to quux
03:11:02 <SwashBuckla> foo bar baz wibble wobble woo
03:11:28 <kvanb> hah
03:16:31 <ddellacosta> mauke, jle`, didn't see your responses to me, thanks.  I guess what I should have asked was, has "\/" ever been defined as logical "or" by default in Haskell (like in Prelude)
03:16:47 <jTT> Hi, I am experiencing a huge mess due to ghc’s awful package management and was wondering if anyone could help. Following an unsuccessful attempt to install the Conduit package, previously functioning packages are browken and i get error messages similar to : “    Could not find module ‘Data.Text.IO’
03:16:48 <jTT>     Perhaps you haven't installed the "dyn" libraries for package ‘text-1.2.0.0’?” Any ideas greatly appreciated
03:16:57 <mauke> ddellacosta: AFAIK no
03:18:32 <vanila> jTT, afaict there's no solution - people are hoping to fix caball one day though
03:19:23 <jTT> vanila: how to procede? I believe I deleted all packages and started afresh, yet things are still not working
03:19:35 <mauke> deleted how?
03:20:08 <jTT> rm -rf ~/.cabal/lib;
03:20:16 <mauke> ... without unregistering?!
03:20:18 <vanila> i've had to give up haskell development because its just not ready for real world
03:20:34 <jTT> rm -r ~/.ghc
03:20:40 <baadupo__> Is there a Equivalent of zipWith for CArray? Something like (x -> y -> z ) -> Data.Array.CArray.Base.CArray i x -> Data.Array.CArray.Base.CArray i y -> Data.Array.CArray.Base.CArray i z
03:20:51 <jTT> :vanila its infuriating to spend half a day on such bs
03:20:58 <vanila> yea im sorry :(
03:21:07 <vanila> it's a cool language just the tools are in a bad state
03:21:25 <pjdelport> jTT: Have you tried Stackage?
03:21:32 <jTT> nope
03:21:47 <pjdelport> http://www.haskell.org/haskellwiki/Stackage
03:22:24 <pjdelport> https://www.fpcomplete.com/blog/2014/05/stackage-server
03:22:27 <ddellacosta> do sandboxes help with these sorts of issues?  I ask as a relative newb
03:22:29 <jTT> yeah, nice in retrospect. doesnt fix my compeltely messed up situation though
03:22:42 <pjdelport> jTT: It's an alternative to the main Hackage, that you can point Cabal to
03:22:43 <ddellacosta> how do using cabal sandboxes compare with Stackage?
03:22:56 <dibblego> ddellacosta: yes sandboxes is how you achieve goals
03:23:00 <pjdelport> ddellacosta: They're orthogonal; Stackage is just an alternative source of packages.
03:23:05 <vanila> What I think is important is a way to deal with packages manually
03:23:05 <jTT> pjdelport: cheers, will try next time
03:23:06 <ddellacosta> pjdelport: right, I see now
03:23:16 <pjdelport> Unlike Hackage, Stackage just has versions of everything that work together.
03:23:17 <vanila> so that if you  have trouble you can just sort it tout by hand
03:23:27 <pjdelport> So it guarantees that installs should succeed and tests pass.
03:23:32 <ddellacosta> right, so doesn't matter if you are using a sandbox or not...gotcha
03:23:57 <Qfwfq> nix
03:24:10 <pjdelport> Well, sandboxing still matters for other purposes.
03:24:31 <ddellacosta> pjdelport: right, I guess I just meant, I see what you mean now about their orthogonal...ity
03:25:58 <ddellacosta> what kind of uptake does Stackage have in the community of folks providing libs for Haskell?
03:26:23 <ddellacosta> I see it was introduced a few years ago
03:27:14 <mauke> never heard of it
03:27:20 <ddellacosta> maybe that's the wrong question, not sure if it's relevant for folks developing libs
03:27:24 <mauke> and I'm not going to support it
03:27:33 <ddellacosta> assuming a maintainer can simply add a stable release
03:27:41 <ddellacosta> mauke: do you have objections, in particular?
03:28:00 <mauke> too much effort
03:28:16 <ddellacosta> gotcha.
03:28:28 <ddellacosta> fair enough, this stuff takes time
03:28:34 <jTT> how do i point cabal to stackage?
03:28:42 <Fuuzetsu> How can I expand directories? Haddock says to use canonicalizePath but
03:28:51 <Fuuzetsu> *Yi.Misc> System.Directory.canonicalizePath "~"
03:28:51 <Fuuzetsu> *** Exception: ~: canonicalizePath: does not exist (No such file or directory)
03:28:51 <jTT> remote-repo?
03:29:37 <mauke> Fuuzetsu: that's because ~ does not exist
03:29:54 <ddellacosta> jTT: looks like? http://www.stackage.org/stackage/69d533a4943f58c2a848ebfdda2dd221e56e14d9
03:30:26 <Fuuzetsu> mauke: well, how do I get it do DWIM?
03:30:35 <jTT> ddellacosta: thx
03:30:36 <Aruro> Why function let pythagoras3 x = [(a,b,c) | a<-[1..x], b<-[1..x], c<-[1..x], a^2+b^2==c^2] is very slow on x equal 100 for example?
03:30:37 <mauke> figure out what it is you're trying to do
03:30:42 <ddellacosta> jTT: np
03:30:58 <mauke> > 100 * 100 * 100
03:30:59 <lambdabot>  1000000
03:31:12 <Fuuzetsu> mauke: I'm trying to get it to take a relative path, possible involving ~ and have it expand it out so setCurrentDirectory is happy to accept it
03:31:14 <mauke> Aruro: because you're trying 1000000 combinations
03:31:24 <mauke> Fuuzetsu: what do you mean by "involving ~"?
03:31:39 <Aruro> so? is that alot?
03:31:44 <Fuuzetsu> mauke: ~/foo/bar ← has to handle this
03:31:53 <mauke> Fuuzetsu: what do you mean by "handle"?
03:32:04 <Fuuzetsu> “have it expand it out so setCurrentDirectory is happy to accept it”
03:32:05 <vanila> > let x = 100 in [(a,b,c) | a<-[1..x], b<-[1..x], c<-[1..x], a^2+b^2==c^2]
03:32:08 <lambdabot>  mueval-core: Time limit exceeded
03:32:19 <Fuuzetsu> in this case turn it into /home/shana/foo/bar
03:32:20 <mauke> Fuuzetsu: expand x = "/"
03:32:28 <Fuuzetsu> …
03:32:30 <mauke> Fuuzetsu: setCurrentDirectory won't accept that
03:32:35 <mauke> Fuuzetsu: /home/shana doesn't exist here
03:32:42 <vanila> Aruro, it could be interesting to compare the speed of this vs C
03:32:49 <Aruro> yes
03:33:10 <Aruro> i will see now if speed drops without condition :D should drop
03:33:10 <Fuuzetsu> mauke: setCurrentDirectory is perfectly happy accepting that, are you trying to be not helpful or something?
03:33:19 <Fuuzetsu> I think it's fairly clear what I want to achieve…
03:33:21 <mauke> Fuuzetsu: dude, that directoy doesn't exist
03:33:29 <vanila> Aruro, I know how to make it faster but I guess that's not what you want to know
03:33:35 <Fuuzetsu> it does on my system and where the function will run
03:33:37 <mauke> Fuuzetsu: it's not clear at all and you're being deliberately unhelpful about it
03:34:26 <Fuuzetsu> mauke: OK, how about ‘I want to turn relative paths in the form that bash accepts them into absolute paths in the way that setCurrentDirectory will be happy with’
03:34:43 <mauke> Fuuzetsu: in that case you better run bash
03:34:51 <mauke> because bash supports some crazy stuff
03:34:57 <Aruro> lol i think printing in ghci takes more type than calculating
03:35:04 <Aruro> actually why?
03:35:16 <Aruro> time*
03:35:17 <mauke> consider /foo/$bar/`echo hi`
03:35:23 <Fuuzetsu> mauke: I only want a small subset
03:35:36 <Aruro> still waiting printing of my million numbers
03:35:36 <mauke> Fuuzetsu: your requirements change at every step
03:35:49 <Fuuzetsu> because you ask me to refine them at every step
03:35:55 <mauke> no
03:36:02 <vanila> Aruro, it onyl prints a few hundred for me
03:36:09 <mauke> I just want to know what exactly you're trying to do, and you don't know
03:36:12 <vanila> length $ let x = 100 in [(a,b,c) | a<-[1..x], b<-[1..x], c<-[1..x], a^2+b^2==c^2]
03:36:12 <vanila> 104
03:36:16 <mauke> so your answer keeps changing
03:36:19 <vanila> ok only ONE hundred
03:36:27 <Fuuzetsu> I want to take a path like this "~/foo/bar" and turn it into a path like this "/home/shana/foo/bar" where ~ expands into $HOME
03:36:44 <mauke> Fuuzetsu: what about "~foo/bar"?
03:36:45 <Fuuzetsu> and likewise, where foo/bar expands into an absolute path
03:36:54 <Aruro> is there a way to measure time function takes to finish?
03:36:58 <Fuuzetsu> mauke: no need
03:37:06 <mauke> Fuuzetsu: what if $HOME is not set?
03:37:10 <vanila> i'd compile it as a stand-alone binary
03:37:13 <vanila> then you cn use  time pythag
03:37:26 <Aruro> k
03:37:28 <Fuuzetsu> mauke: then the function never receives ~ anyway in my scenario
03:37:30 <davidturner_> Anyone noticed that recent packages uploaded to hackage seem not to have haddock documentation?
03:37:44 <Fuuzetsu> if it isn't set it'd just expand to foo/bar I suppose
03:37:51 <Fuuzetsu> davidturner_: yes, a lot of people ;P
03:37:54 <davidturner_> k
03:38:03 <davidturner_> google didn't turn up anything obvious from 2014
03:38:13 <davidturner_> figured it'd already been reported
03:38:13 <davidturner_> ta
03:38:24 <Aruro> is there such thing in ghci as a result of previous command?
03:38:35 <Aruro> like % or something
03:38:50 <davidturner_> Aruro, it's 'it' isn't it?
03:38:51 <mauke> expand "~" = getEnv "HOME"; expand ('~' : xs@('/' : _)) = (++ xs) <$> getEnv "HOME"; expand xs = return xs
03:39:20 <Aruro> i will check now
03:39:28 <Aruro> yes true
03:39:30 <Aruro> ty
03:39:32 <davidturner_> np
03:39:37 <Aruro> :)
03:39:45 <Fuuzetsu> mauke: Seems like there would be a function hiding somewhere standard for this
03:39:52 <Fuuzetsu> (which is why I came to ask in the first place)
03:40:04 <mauke> no, a standard function would probably support windows too
03:40:46 <Fuuzetsu> you can re-export different implementation based on OS, like the package directory does
03:40:56 <Fuuzetsu> uh, not directory, filepath?
03:41:02 <Fuuzetsu> yeah
03:41:05 <nshepperd> Aruro: there's package timeit
03:41:31 <Aruro> ty
03:42:35 <davidturner_> mauke: ~username should expand to username's home too
03:43:08 <mauke> davidturner_: no, it shouldn't
03:43:54 <mauke> http://hackage.haskell.org/package/HSH-2.1.0/docs/src/HSH-ShellEquivs.html#glob
03:43:55 <mauke> http://hackage.haskell.org/package/hledger-lib-0.23.2/docs/src/Hledger-Utils.html#expandPath
03:44:01 <mauke> http://hackage.haskell.org/package/gnomevfs-0.11.0/docs/src/System-Gnome-VFS-Util.html#expandInitialTilde
03:45:11 <davidturner_> mauke: sorry, came in half way through
03:45:53 <nshepperd> bash on unix does expand ~bob to bob's $HOME
03:45:54 <Aruro> i see that type char supports comparison, can i add to  a Boolean property vowel ?
03:46:02 <Aruro> add to it
03:46:11 <mauke> Aruro: just write a function
03:46:15 <nshepperd> which may not be relevant to whatever you're doing
03:46:20 <Aruro> function?
03:46:25 <Aruro> can i change type?
03:46:31 <mauke> ??
03:46:47 <Qfwfq> nshepperd: That's POSIX, I think.
03:46:50 <Aruro> like i want something like this x/=Vowel where x is Char
03:47:02 <mauke> Aruro: that doesn't make sense
03:47:03 <Aruro> same as i can write x /=True
03:47:07 <mauke> Vowel is not a Char
03:47:09 <Aruro> why?
03:47:13 <mauke> and you shouldn't write /= True
03:47:18 <Aruro> you did not get it
03:47:19 <mauke> it's completely redundant
03:47:20 <Qfwfq> ~ is type equality.
03:47:51 <davidturner_> mauke: Although HSH.ShellEquivs that you linked does seem to support ~username; hledger explicitly does not, and the GNOME one doesn't seem to know about it
03:48:01 <Qfwfq> You can define a type family, if that doesn't do precisely what you want.
03:48:06 <mauke> davidturner_: cool story?
03:49:29 <Aruro> so  there is no way to add to every member of char type additional property of whether it is vowel or not?
03:49:51 <mauke> what do you mean by "property"?
03:49:52 <nshepperd> isVowel = flip elem "aeiouAEIOU" :: Char -> Bool
03:50:11 * Fuuzetsu settled with lookupEnv "HOME"
03:50:22 <Aruro> let me think about your answer nshepperd
03:50:40 <pjdelport> Aruro: That tests whether a character is in the given list.
03:50:44 <mauke> Aruro: wtf, that's what I told you to do in the first place
03:50:44 <pjdelport> :t elem
03:50:45 <lambdabot> Eq a => a -> [a] -> Bool
03:50:58 <Aruro> yes ty
03:51:05 <Aruro> what flip does?
03:51:10 <pjdelport> :t flip
03:51:11 <lambdabot> (a -> b -> c) -> b -> a -> c
03:51:15 <nshepperd> such an implementation is wrong if you have to support non english languages
03:51:18 <mauke> @src flip
03:51:18 <lambdabot> flip f x y = f y x
03:51:22 <Axman6> Aruro: you can't change types in Haskell. you just define new functions which operate on them to extend them
03:51:36 <Aruro> yes ty so its becuase you wrote it in currying notation?
03:51:40 <Aruro> you needed flip?
03:51:45 <nshepperd> Aruro: that's the same as 'isVowel c = elem c "aeiouAEIOU"'
03:51:49 <Aruro> yes
03:52:00 <Aruro> flip i like too
03:52:21 <Axman6> also isVowel = `elem` "aeiouAEIOU"
03:52:24 <Aruro> so in currying c had to be last one on the right?
03:52:35 <Aruro> yes last one is cool too
03:52:36 <pjdelport> Axman6: You need parens around that, though.
03:52:37 <mauke> Axman6: ( )
03:52:39 <Aruro> infix one
03:52:46 <Axman6> uh, yes
03:53:01 <Aruro> ok good but its just function
03:53:18 <Aruro> suppose i want to be stubborn and  change type itself
03:53:26 <mauke> change how?
03:53:28 <Axman6> you can't
03:53:35 <Aruro> adding to it Boolean value
03:53:36 <Axman6> this isn't OOP
03:53:40 <Aruro> of this isVowel function
03:53:51 <mauke> Aruro: what would that look like?
03:53:57 <Aruro> ok can i make a type like that?
03:54:00 <pjdelport> Aruro: You can make a type (Char, Bool)
03:54:01 <Fuuzetsu> you can make a new type
03:54:07 <pjdelport> Aruro: But there's little reason to.
03:54:19 <Aruro> yes that i want
03:54:22 <Aruro> Char Bool
03:54:34 <Axman6> what does that mean?
03:54:36 <pjdelport> Aruro: Why would you want that, though?
03:54:42 <Axman6> Char doesn't take any parameters...
03:54:46 <Aruro> in other way i want this property to be inside type not inside function
03:54:57 <pjdelport> Aruro: Functions have a type too. :)
03:55:07 <Aruro> i want to write like this x == Vowel
03:55:15 <Aruro> and that it tels me true or not
03:55:23 <Aruro> but x has to know about vowel
03:55:26 <pjdelport> Aruro: (==) is just a function too.
03:55:29 <Aruro> and be a char
03:55:37 <Axman6> isVowel x is just as clear...
03:55:40 <Fuuzetsu> You can't have x be Char and use == with not Char
03:55:43 <pjdelport> Aruro: Instead of using the function (==), you can just use the function isVowel.
03:55:45 <silver> so you want OOP and typeof function?
03:55:52 <mauke> Aruro: you can never write x == Vowel, no matter how you define your types
03:55:52 <Fuuzetsu> silver: ew
03:56:02 <Aruro> why not?
03:56:14 <Aruro> later on i can extend my type with my new given properties
03:56:15 <mauke> Aruro: because == takes two values of the same type
03:56:17 <Fuuzetsu> because the type of (==) does not let you
03:56:25 <Axman6> :t (==)
03:56:26 <Aruro> ok thats more clear
03:56:26 <lambdabot> Eq a => a -> a -> Bool
03:56:33 <nshepperd> and more importantly, doing that breaks laws of (==)
03:56:40 <mauke> and also because == is supposed to do equality
03:56:41 <Axman6> :t (==) `asAppliedTo` 'a'
03:56:42 <Aruro> can i extend than equality for Char type?
03:56:42 <lambdabot> Char -> Char -> Bool
03:56:48 <Aruro> then*
03:56:49 <mauke> Aruro: no
03:57:08 <Aruro> why not i think that would be cool
03:57:15 <mauke> you're wrong
03:57:16 <silver> use c++ then
03:57:21 <Aruro> that i can at least compare different types
03:57:34 <Axman6> you don't want that, you just don't know it yet
03:57:41 <nshepperd> comparing different types is nonsense though
03:57:43 <mauke> if two values have different types, they can't be equal
03:57:46 <Aruro> lol ok :D i trust you
03:57:51 <Aruro> yes
03:57:53 <nshepperd> if they are different types they gotta be unequal
03:57:57 <Aruro> but i want to just compare them
03:58:00 <nshepperd> cos they are different values
03:58:02 <Aruro> like with Vowel example
03:58:03 <Fuuzetsu> then write a comparison function
03:58:06 <Fuuzetsu> like isVowel
03:58:06 <Aruro> or it is not comparing then?
03:58:07 <Axman6> 'a' == 1 makes no sense
03:58:08 <mauke> Aruro: that's not equality
03:58:35 <Aruro> yes but 'a' == Vowel makes perfect sense
03:58:36 <Axman6> Aruro: this is functional programming, the where functions are a truly fundamental concept
03:58:39 <mauke> Aruro: no, it doesn't
03:58:39 <Aruro> like 1 == Int
03:58:41 <Axman6> no it doesn't
03:58:42 <Fuuzetsu> Aruro: no, it does not
03:58:44 <mauke> Aruro: that makes no sense either
03:58:45 <Aruro> why not?
03:58:52 <mauke> Aruro: Int is a type, not a value
03:58:53 <Axman6> you can't compate values to types
03:59:00 <Aruro> hm ok
03:59:03 <Aruro> i see the point
03:59:11 <mauke> also consider transitivity
03:59:12 <nshepperd> Aruro: if 'a' == Vowel, and 'b' == Vowel, then 'a' == 'b'???
03:59:14 <Aruro> let me introduce new infix operator isProperty
03:59:15 <Axman6> in haskell they live in different worlds, the world of values and the world of types
03:59:18 <Fuuzetsu> Aruro: 1 == Int would be pointless even if you could do that anyway because we already know if 1 is Int or not
03:59:24 <Axman6> in dependantly types languages they can interract
03:59:29 <Axman6> typed*
03:59:36 <Fuuzetsu> Axman6: you would still never see 1 == Int
03:59:52 <Aruro> hm i see
03:59:55 <mauke> in math you can write 1 = N, but it would be false
03:59:55 <Aruro> i dont agree though
03:59:58 <Axman6> Fuuzetsu: not without a strange definition of (==) =)
04:00:01 <mauke> 1 is not the set of the natural numbers
04:00:07 <Aruro> i see that Enumerate property and comparison property
04:00:08 <vanila>  thats cause math is untyped :P
04:00:10 <vanila> everything is a set
04:00:16 <Aruro> is something similar
04:00:18 <Fuuzetsu> Axman6: assuming we're not bastardising the general type of == ;P
04:00:21 <Aruro> and haskell has that
04:00:32 <Aruro> it can tell if any new type can be enumerated
04:00:36 <Aruro> so its same with Vowel
04:00:41 <Axman6> eh?
04:00:49 <vanila> <nshepperd> Aruro: if 'a' == Vowel, and 'b' == Vowel, then 'a' == 'b'???
04:00:49 <mauke> Aruro: it's not that it can tell, it's that the programmer can make it so
04:00:50 <vanila> it should be
04:00:53 <vanila> 'a' :: Vowel
04:00:55 <vanila> 'b' :: Vowel
04:00:56 <vanila> not ==
04:00:57 <pjdelport> Aruro: Being a vowel is a property of values, not types.
04:01:09 <Aruro> yes delport
04:01:12 <vanila> the thing about == is,  x == y  then  y == x,  and x == y & y == z implies x == z
04:01:12 <Aruro> good point
04:01:22 <Aruro> can i make it property of type?
04:01:29 <Aruro> like comparison or enumeration
04:01:32 <mauke> Aruro: which types are vowels?
04:01:40 <Axman6> what do you mean by property
04:01:40 <mauke> is Int a Vowel? is Char?
04:01:51 <vanila> (btw b is not a vowel)
04:02:16 <Aruro> ok i think confusion is in my phrasing
04:02:16 <mauke> vanila: it might be in bulgarian :-)
04:02:22 <pjdelport> Aruro: What would that even mean? It does not make sense to say the type "Char" is a vowel or not: it's the type of all characters.
04:02:42 <Aruro> i want to be able to blend Properties of types with the types themselfs
04:02:51 <pjdelport> Aruro: Being a vowel or not is *inherently* a property of specific character values: that has nothing to do with Haskell, specifically.
04:03:00 <mauke> Aruro: no, you don't
04:03:12 <Aruro> you see this as a function
04:03:25 <Aruro> i see it as a new connection between types u see it?
04:03:28 <silver> Auro, what's property?
04:03:28 <mauke> Aruro: no
04:03:35 <Axman6> it is a function, a transformation from types to types
04:03:36 <pjdelport> Aruro: It's always a function. (==) is a function too.
04:03:38 <nshepperd> Aruro: are you trying to define a 'type of vowels' here?
04:03:39 <vanila> Aruro, that isn't possible in Haskell
04:03:41 <Aruro> ok let me think
04:03:46 <mauke> Aruro: no
04:03:52 <pjdelport> Aruro: You can name the function different things, but it will always be a function of Char values.
04:04:35 <pjdelport> Aruro: You can define a new type of vowels only, and translate Char to that, but that's something else.
04:04:43 <Axman6> :t isSpace
04:04:44 <lambdabot> Char -> Bool
04:04:49 <Axman6> :t isUpper
04:04:50 <lambdabot> Char -> Bool
04:04:57 <mauke> data Vowel = A | B | C | D | E
04:05:10 <Axman6> these already exist in the Data.Char module
04:05:47 * hackagebot yesod-static 1.4.0.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.4.0.2 (MichaelSnoyman)
04:05:51 <Axman6> so why would you want to do something different for your own vowel checking functionality?
04:06:25 <vanila> data Vowel = A | E | U | O | I
04:06:40 <Axman6> if you did something different, functions of type (Char -> Bool) -> String -> String (for example), wouldn't be able to work with your functionality
04:07:06 <Aruro> interesting, im thinking
04:07:33 <mauke> class Vowel t; data A; instance Vowel A
04:08:16 <Aruro> aha sorry i was not enough informed
04:08:25 <Aruro> what i was talking is called typeclass
04:08:33 <Aruro> i wanna new typeclass called vowel
04:08:42 <mauke> no, you don't
04:08:45 <Aruro> no?
04:08:47 <mauke> no.
04:08:50 <Aruro> why not?
04:08:58 <mauke> why would you?
04:09:06 <Axman6> what other types would implement the Vowel typeclass?
04:09:10 <silver> well try to define it
04:09:12 <mauke> s/other //
04:09:12 <Axman6> it only makes sense for Char
04:09:19 <mauke> it doesn't make sense for Char
04:09:24 <Fuuzetsu> Axman6: Int with ord ;P
04:09:24 <Aruro> yes only char would be in it
04:09:38 <Axman6> Aruro: then it doesn't need to be a type class
04:09:46 <silver> untill someone defines something else to be in it
04:09:48 <Fuuzetsu> or rather, Int with chr
04:09:56 <Aruro> yes but my goal is to have somethink like x == Vowel
04:10:01 <Aruro> even though you hate function --
04:10:03 <Aruro> ==
04:10:05 <mauke> Aruro: classes don't help with that
04:10:06 <Fuuzetsu> Aruro: We already told you that is not possible
04:10:12 <Aruro> k
04:10:23 <Aruro> like completely not possible or not desirable?
04:10:28 <mauke> Aruro: apparently you want to define a == that does not mean "equality"
04:10:29 <Fuuzetsu> we don't hate (==), it just does something completely different than what you want
04:10:29 <nshepperd> why do you want x == Vowel
04:10:30 <Axman6> isVowel x is much clearer
04:10:49 <nshepperd> instead of something reasonable like x ∈ Vowel
04:10:56 <nshepperd> or isVowel x
04:11:10 <Aruro> yes that set sign i want
04:11:16 <mauke> that's not ==
04:11:17 <Aruro> and basically what im talking about
04:11:19 <vanila> <Aruro> yes but my goal is to have somethink like x == Vowel
04:11:22 <Axman6> but that sign does not mean equality
04:11:25 <vanila> it should be 'a' :: Vowel
04:11:30 <vanila> Aruro, the thing about == is,  x == y  then  y == x,  and x == y & y == z implies x == z
04:11:31 <Axman6> so saying x == Vowel does not make sense
04:11:32 <Aruro> how do i do that?
04:11:49 <Aruro> ok vanila i agree
04:11:49 <mauke> > let (∈) = elem in ()
04:11:52 <lambdabot>  ()
04:11:54 <mauke> nice
04:12:02 <mauke> > let (∈) = elem in 'a' ∈ "aeiou"
04:12:03 <vanila> Aruro, it's not possible to make Vowel a subtype of Char in haskell,
04:12:03 <lambdabot>  True
04:12:09 <vanila> Aruro, Haskell doesn't support subtypes
04:12:16 <Aruro> ok ty mauke
04:12:24 <vanila> Aruro, so your idea is good but you can't do this
04:12:24 <Aruro> that already looks much nicer
04:12:33 <mauke> no, that's still the first suggestion
04:12:38 <mauke> 'a' `elem` "..."
04:12:39 <Aruro> even though conceptually it is still a function
04:12:42 <mauke> just using a slightly different name
04:12:50 <Axman6> which is exactly what it should be >____<
04:12:56 <vanila> Becuase haskell doesn't have subtyping, you can use a function like mauke showed
04:12:56 <Aruro> yes yes i got it
04:13:00 <mauke> (==), (+), elem, ... are all functions
04:13:28 <Aruro> but isnt sublasses kinda thing what i want?
04:13:35 <mauke> what's a subclass?
04:13:36 <vanila> subtypes
04:13:38 <Aruro> sorry typeclasses
04:13:40 <vanila> but haskell doesnt' have subtypes
04:13:46 <Aruro> typeclasses
04:13:49 <mauke> Aruro: I don't see what classes have to do with this
04:13:55 <jTT> how would I wipe all of cabal and all packages? somehow during intallation of attoparsec everything broke and
04:13:55 <nshepperd> Aruro: what's your goal here, such that a function does not help?
04:13:59 <Aruro> or typeclasses have to be always about same type?
04:14:04 <mauke> wat
04:14:18 <Fuuzetsu> Aruro: typeclasses in Haskell are not classes in OOP sense
04:14:28 <Axman6> Aruro: type classes are for functionality that should work on several types
04:14:29 <moldy> do you consider http://learnyouahaskell.com/ a good ressource? would you recommend other ones?
04:14:36 <Haskellfant> moldy: excellent resource
04:14:46 <moldy> Haskellfant: thanks
04:15:13 <Haskellfant> moldy: bytemyapp maintains a list of resources here https://github.com/bitemyapp/learnhaskell
04:15:14 <Aruro> like >:t
04:15:17 <Axman6> Eq can be implemented for all types which you can test for equality, like Int, Char, lists of things which can be tested for equality (Eq a => Eq [a]) etc
04:15:24 <adamse> jTT: remove .ghc makes things build for me if I break something
04:15:24 <Aruro> >:t (==)
04:15:29 <Fuuzetsu> :t (==)
04:15:30 <lambdabot> Eq a => a -> a -> Bool
04:15:31 <moldy> Aruro: personally, it has helped me alot to think of typeclasses as interfaces.
04:15:39 <Axman6> > 1 == 1
04:15:41 <lambdabot>  True
04:15:47 * hackagebot yesod-bin 1.4.0 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0 (MichaelSnoyman)
04:15:48 <Axman6> >"Hello" == "World"
04:15:53 <Axman6> > "Hello" == "World"
04:15:55 <lambdabot>  False
04:16:01 <Aruro> yes Axeman you are talking about Eq typeclass
04:16:03 <Axman6> > [1,2,3] == [1,2,3]
04:16:04 <lambdabot>  True
04:16:08 <Aruro> which i called property before
04:16:13 <mauke> Aruro: did you?
04:16:16 <Axman6> but the Vowel typeclass only makes sense for Char
04:16:16 <Aruro> why i can not make Vowel typeclass?
04:16:19 <mauke> Aruro: you never explained what you mean by "property"
04:16:24 <Aruro> inst it kinda in the same spirit?
04:16:31 <mauke> Aruro: what would that class look like?
04:16:33 <Axman6> not really
04:16:56 <Axman6> class Vowel a where isVowel :: a -> Bool -- Look familliar?
04:16:58 <moldy> Aruro: are you coming from another programming language?
04:17:09 <vanila> Aruro, You cannot use typeclasses for this
04:17:13 <mauke> vanila: sure you can
04:17:20 <vanila> Aruro, What you described needs subtyping, but haskell doesnt' have subtyping
04:17:20 <mauke> depending on what exactly "this" is
04:17:25 <mauke> which everyone just kind of assumes
04:17:26 <Aruro> no im coming from everywhere :)
04:17:34 <mauke> same for "subtyping"
04:17:44 <vanila> mauke, Vowel subtype of Char
04:17:48 <OliverJAsh> can anyone recommend a room for general functional programming discussion? i have questions about some logic but not sure where to go.
04:17:49 <moldy> Aruro: then you know interfaces in other languages? would vowel be an interface in e.g. java? probably not.
04:17:56 <mauke> vanila: yes, that's your preconceived notion about what Aruro wants
04:18:18 <Axman6> OliverJAsh: at a pinch, @haskell-blah would be a good place
04:18:34 <Aruro> no i think typeclasses is perfectly good idea
04:18:38 <nshepperd> Aruro: the only reason Eq is a typeclass is so that the (==) function can be applied to various different types, such as (1 == 1), ('a' == 'a') and so on
04:18:45 <Aruro> i just dont see why i can no infinitely extend them
04:18:50 <Aruro> for uses we discuss here
04:18:57 <mauke> Aruro: we haven't discussed any uses
04:19:03 <Aruro> yes
04:19:05 <OliverJAsh> thanks Axman6
04:19:13 <silver> Aruro, try to define it
04:19:30 <Aruro> ok i see the problem you think of vowel as type
04:19:32 <pjdelport> Aruro: What problem are you actually trying to solve?
04:19:49 <Aruro> and you claim comparing char==vowel will brake type thing
04:19:58 <Aruro> that i understood
04:20:00 <Aruro> i think
04:20:03 <Axman6> no we claim it makes no sense
04:20:06 <mauke> Aruro: I'm not saying it will break anything; I'm saying it doesn't make sense
04:20:07 <Aruro> also that
04:20:20 <mauke> and it doesn't make sense because == represents equality
04:20:32 <mauke> and I have no idea what you want but it's not equality
04:20:51 <Aruro> can i have a fucntion isof(type)=typeclass?
04:21:09 <mauke> I don't know what that means
04:21:16 <silver> yay typeof
04:21:30 <Aruro> hm
04:21:36 <pjdelport> Aruro: What problem are you actually trying to solve? If you don't answer that, this might just go in circles. :)
04:21:44 <mauke> there is no actual problem
04:21:50 <Axman6> Aruro: do you understand that typeclasses are very similar to interfaces in languages like java?
04:21:56 <mauke> Aruro is just trying to annoy people
04:21:58 <Aruro> we are basically talking why there is data(types) and properties (typeclasses)
04:22:07 <mauke> Aruro: typeclasses are not properties
04:22:15 <vanila> Aruro, What you described needs subtyping, but haskell doesnt' have subtyping
04:22:18 <vanila> Aruro, You cannot use typeclasses for this
04:22:18 <mauke> Aruro: what do you mean by "properties", for the 6th time?
04:22:31 <mauke> vanila: there you go again with your subtyping
04:22:31 <Aruro> yes but Eq is exatly does what i want
04:22:37 <Aruro> only it compares type to itself
04:22:40 <mauke> Aruro: evidently not
04:22:42 <Aruro> which is rather dull
04:22:43 <Axman6> no, it's not >___<
04:22:45 <pjdelport> Aruro: Eq compares values, not types.
04:22:47 <mauke> as mentioned before, Eq does equality
04:22:53 <Aruro> ok
04:22:56 <Aruro> i think im closer
04:22:59 <vanila> mauke, you are overloading him with conflicting information
04:23:04 <mauke> vanila: good
04:23:13 <Aruro> so  we have Values Types and Typeclasses
04:23:14 <pjdelport> Aruro: In what context are you actually testing chars for being a vowel or not? And why do you think an isVowel function won't work for that?
04:23:27 <Aruro> its my pure interest
04:23:34 <Aruro> i see room for generalisation
04:23:42 <mauke> I think you're pure noise
04:23:50 <Aruro> dont understand why its not there people are explaining
04:23:52 <pjdelport> Aruro: What do you want to generalize, exactly?
04:24:05 <Fuuzetsu> there is no room for generalisation there, you're trying to do something that can't work
04:24:14 <pjdelport> Aruro: Being a vowel is only a property of characters, not of other types.
04:24:29 <pjdelport> Aruro: It does not make sense to ask whether the number 5 is a vowel or not.
04:24:47 <Aruro> yes you got everything correctly
04:24:59 <Aruro> so
04:25:21 <Aruro> i want to extend meta information represented in typesystem on my specific type, in this case char
04:25:36 <Aruro> same way its done using typeclasses
04:25:42 <Aruro> only for more simple purposes
04:25:47 <Aruro> like comparing and enumeration
04:25:52 <vanila> Aruro, that's not possible in haskell
04:25:53 <Aruro> lists problably
04:25:53 <mauke> I think you don't know Haskell and you're making shit up
04:26:02 <Axman6> but being a vowel has nothing to do with its type
04:26:07 <Aruro> it does
04:26:09 <Aruro> why not?
04:26:13 <Aruro> char has this information
04:26:19 <vanila> Aruro, haskell type system is very restricted and specializaed
04:26:19 <Aruro> i see char i can tell its vowel or not
04:26:22 <Axman6> chars are just values
04:26:35 <Aruro> thats how U see them
04:26:36 <vanila> Aruro, you can't express what you want to express in the type system of haskell
04:26:39 <pjdelport> Aruro: isVowel is *how* you tell that.
04:26:42 <vanila> Aruro, it's not powerful enough
04:26:59 <pjdelport> Aruro: Type classes don't really have any relevance to this.
04:27:02 <Fuuzetsu> vanila: I don't think you're helping
04:27:05 <Aruro> what is powerful enough for what we are discussing?
04:27:05 <mauke> Aruro: char does not have this information
04:27:15 <vanila> Aruro, subtyping is one way, but Haskell doesn't have that
04:27:16 <Aruro> it does
04:27:18 <silver> Aruro, C++
04:27:20 --- mode: ChanServ set +o mauke
04:27:20 --- mode: mauke set +q $a:vanila
04:27:22 <pjdelport> Aruro: Type classes work at the level of types, not values.
04:27:31 <Aruro> you take char as number which is not, then everything is int
04:27:34 --- mode: mauke set +q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.86.200.54.186
04:28:31 <mauke> oh, wtf
04:28:32 <Axman6> that seems quite excessive mauke
04:29:01 <Axman6> asking people to move to another channel to reduce the noise would've been a better move
04:29:24 <mauke> hmm, yes
04:29:34 --- mode: mauke set -o mauke
04:29:34 <Qfwfq> vanila: And vanila was just trying to be helpful.
04:29:38 <Qfwfq> Uh.
04:30:13 <Axman6> Aruro, vanila: if you must continue, head over to #haskell-blah
04:30:25 <mauke> Axman6: no, that would be off-topic
04:30:45 <mauke> and I don't know a better channel for this
04:30:55 <Axman6> we've never discussed haskell in #haskell-blah before?
04:31:13 <nshepperd> it's futile either way
04:31:19 <mauke> we have, but it's still off topic
04:35:24 <dreams> Hello. Does GHC have a lambda lifting pass?
04:35:34 <Fuuzetsu> dreams: AFAIK yes
04:35:47 <dreams> Fuuzetsu: hmm, I thought STG does not have it.
04:35:57 <pjdelport> dreams: https://ghc.haskell.org/trac/ghc/ticket/5945 might be interesting
04:37:04 <dreams> In "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine": we don't use lambda lifting.
04:37:41 --- mode: ChanServ set +o mauke
04:37:41 --- mode: mauke set -q $a:vanila
04:38:11 --- mode: mauke set -q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.86.200.54.186
04:38:21 <dreams> That is a bit confusing.
04:38:39 <vanila> transparency http://pastebin.com/PTKUe8kG
04:40:12 --- mode: mauke set -o mauke
04:40:42 <adamse> dreams: doesn't the lambda lifting happen on the Core level?
04:41:15 <dreams> adamse: Ah, so they apparently meant the STG language does not use lambda lifting.
04:41:23 <dreams> perhaps.
04:41:33 <adamse> dreams: that seems like a reasonable interpretation
04:42:07 <adamse> indeed the full laziness transform happens on core
04:43:45 <dreams> Oh god, adding the stg layer makes the compilation process more complex I imagine, from the profiler side at least.
04:44:18 <Aruro> why did you banned vanila?
04:44:29 <Aruro> u could have banned me lol
04:44:33 <mauke> I did
04:44:43 <mauke> if by "ban" you mean temporarily silence
04:44:57 <Aruro> why? he did not participate much
04:45:49 * hackagebot http-client 0.4.0.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.0.1 (MichaelSnoyman)
04:45:51 * hackagebot http-conduit 2.1.4.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.5 (MichaelSnoyman)
04:46:16 <Aruro> i love list comprehensions (silly maybe) so i wrote like this
04:46:22 <Aruro> > [x | x<-['a'..'z'], not $ x `elem` "aeoiu"]
04:46:25 <lambdabot>  "bcdfghjklmnpqrstvwxyz"
04:46:40 <mauke> you could also use `notElem`
04:46:48 <Aruro> hm ok ty
04:47:23 <Axman6> > filter (`notElem` "aeiouAEIOU") ['a'..'z']
04:47:25 <lambdabot>  "bcdfghjklmnpqrstvwxyz"
04:47:34 <Aruro> yes filter is nice too
04:47:53 <Axman6> and hey, filter works on all FUNCTIONS of type a -> Bool
04:48:00 * Axman6 drops it
04:48:10 <petercommand> drop what?
04:48:10 <Aruro> yes
04:48:32 <Aruro> whole point was that in this case we have 5 elemets assume you have many
04:48:37 <Aruro> that was the idea
04:48:39 <Aruro> thats all
04:48:52 <mauke> then we could switch to a Set
04:49:04 <jTT> what are dyn libraries? Im still trying to fix that broken ghc of mine… Perhaps you haven't installed the "dyn" libraries for package
04:50:06 <Aruro> u mean Data.Set?
04:50:52 <mauke> well, Data.Set.Set
04:51:17 <mauke> I may be addressing the wrong problem, though
04:51:44 <Aruro> lol could not tell me before that seems fitting the topic we discussed
04:51:55 <Axman6> does it? o.O
04:51:55 <Aruro> :)
04:51:57 <nshepperd> if all you do is query it, any set is equivalent to a function :: (t -> Bool) :)
04:51:59 <Aruro> it does
04:52:13 <Aruro> i can make my own wierd sets
04:52:19 <Aruro> and query them
04:52:22 <Aruro> i hope i can
04:52:33 <mauke> you can even define your own functions
04:52:35 <mauke> that's even more general
04:52:37 <Aruro> yes
04:52:39 <Aruro> that i wanted
04:52:41 <Aruro> lol
04:52:47 <Fuuzetsu> jTT: dynamic libraries; if you're trying to fix GHC problems your best bet is to clobber your cabal config and your ghc and cabal directories
04:53:03 <Fuuzetsu> we have a spot for you in the nix world if you get tired of that
04:55:04 <jTT> so I did> cabal update and >cabal install cabal-install but when I check the version, nothing has changed
04:55:30 <jTT> Fuuzetsu: clobber?
04:55:34 <kazagistar> Fuuzetsu: whats the best place to get started for using Nix as a package manager for haskell (inside another system like Arch)?
04:55:38 <Fuuzetsu> jTT: delete
04:55:45 <jTT> kk ty
04:55:48 <adamse> jTT: your path has the old cabal before the new cabal
04:55:59 <jTT> how to fix?
04:56:16 <Fuuzetsu> kazagistar: install nix, skim the manual, read some wiki pages then ask a ton of questions in #nixos
04:56:22 <kazagistar> jTT: edit path... how depends on OS
04:57:06 <kazagistar> Fuuzetsu: hmm, that set of instructions is what has kept me perpetually procrastinating it :P
04:57:19 --- mode: ChanServ set +o mauke
04:57:19 --- mode: mauke set -q $a:vanila
04:57:33 --- mode: mauke set -q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.86.200.54.186
04:57:59 <Fuuzetsu> kazagistar: unfortunately there is no one weird trick that makes cabal users hate you, you need to have some basic idea about the nix language to be able to cobble together project expressions
04:58:47 <Fuuzetsu> I'd say it is about a day to get going
04:59:12 <Fuuzetsu> less if you do your reading
04:59:33 --- mode: mauke set -o mauke
04:59:43 <jTT> kazagistar:  im on mac osx. but in my path variable i find nothing about cabal
05:00:15 <kazagistar> Fuuzetsu: a day, like... 16 hours of effort?
05:01:02 <Qfwfq> Not really, the basic expression for a cabal project is '{pkgs}:pkgs.haskellPackages.buildLocalCabal ./. "name-of-library"'.
05:01:23 <kazagistar> jTT: have you ever modified your bash profile to change your path? you might wanna look into doing that
05:01:31 <mauke> jTT: what does 'type -a cabal' say?
05:01:52 <jTT> cabal is /usr/local/bin/cabal
05:01:53 <jTT> cabal is /usr/bin/cabal
05:01:54 <jTT> cabal is /usr/local/bin/cabal
05:01:58 <Aruro> is there any tutorials on Data.Set library? Or its too noob? Can i do [x | x<-set] ?
05:02:10 <Fuuzetsu> kazagistar: well, a day to get around to installing it, browse some YouTube, read a bit, wait for answers on IRC &c
05:02:23 <Fuuzetsu> if you're motivated and the right people are on then it can be much less ;)
05:02:27 <Qfwfq> Set doesn't have Monad without Ord, so you don't have MonadComprehensions.
05:02:34 <Aruro> o
05:02:38 <Aruro> we are back again
05:02:49 <Aruro> :(
05:02:55 <pjdelport> Aruro: Data.Set won't give anything different than (`elem` "..."), except for potentially better performance on big sets.
05:03:28 <Fuuzetsu> it filters out duplicate elements doesn't it
05:03:36 <Aruro> qfwfq so you mean i can not use [x | x<-set] ?
05:03:49 <Qfwfq> You can use, ehm, id.
05:03:49 <Axman6> no
05:03:59 <jTT> mauke: cabal is /usr/local/bin/cabal; cabal is /usr/bin/cabal; cabal is /usr/local/bin/cabal
05:04:14 <Qfwfq> @hackage set-monad
05:04:14 <lambdabot> http://hackage.haskell.org/package/set-monad
05:04:59 <mauke> jTT: is any of those the cabal you installed?
05:05:12 <pjdelport> (Qfwfq: I don't think that's what Aruro meant, for what it's worth.)
05:05:16 <kazagistar> wait, set implements Monad?
05:05:22 <Aruro> yes
05:05:30 <Qfwfq> If you mess with the constructors.
05:05:40 <Aruro> but that package discusses something about typeclasses
05:05:49 <Aruro> i think similar to our discussion
05:06:08 <Aruro> ty qfwfq
05:06:21 <jTT> mauke: I don’t know, not sure how to check what those three are
05:07:26 <Fuuzetsu> Aruro: the typeclass discusssion on that package has nothing to do with the discussion that went on here before
05:07:55 <Aruro> really? perhaps i lack knowledge at this point
05:08:28 <Aruro> i still did not get can i do [x| x<-Set] from Data.Set library
05:08:35 <Fuuzetsu> No, you can not.
05:08:39 <Aruro> ok
05:08:41 <Qfwfq> Aruro: LYAH is a good starting point, if you're after something to read.
05:08:45 <Qfwfq> @where lyah
05:08:45 <lambdabot> http://www.learnyouahaskell.com/
05:08:46 <Aruro> ty
05:09:01 <Aruro> that im reading now :)
05:09:05 <Qfwfq> {-# LANGUAGE TypeComprehensions #-}
05:09:13 <Fuuzetsu> You can use the set-monad package which does some machinery which allows you to use that notation with Set *it* defines.
05:09:20 <Aruro> ty
05:11:37 <nshepperd> sometimes I wish functor and monad and things allowed constrained value types, so that I could use lots of generic code, and 'do' notation on unboxed vectors and sets
05:12:04 <nshepperd> but then I remember that people already tried that, and I become sad instead
05:12:21 <Axman6> who tried it?
05:13:20 <Axman6> I've thought that adding type MonadTypes :: * -> * -> Constraint to Monad would be useful but I'm sure it's probably a bad idea
05:14:42 <Fuuzetsu> http://okmij.org/ftp/Haskell/types.html#restricted-datatypes
05:15:48 <kgadek> hi. does anybody here using any kind of Haskell refactorer?
05:15:59 <kgadek> (HaRe? anything else?)
05:16:44 <Qfwfq> Anytime I try and read anything by Oleg I quickly decide I'd rather hide under a table.
05:17:38 <Fuuzetsu> that one is simple
05:20:03 <nshepperd> https://hackage.haskell.org/package/ConstraintKinds-1.3.0/docs/Control-ConstraintKinds-Functor.html exists
05:20:12 <Aruro> where does Kiselyov work? us?
05:20:16 <Qfwfq> Ah, this is actually quite neat.
05:20:26 <nshepperd> I'm told that it has problems, but I can't remember what
05:20:38 <Qfwfq> And yes, simple.
05:20:50 * hackagebot yesod-tls 1.4.0 - Provides main functions using warp-tls for yesod projects  http://hackage.haskell.org/package/yesod-tls-1.4.0 (netom)
05:20:57 <adamse> i believe the technique used in set-monad is presented in this talk: https://vimeo.com/69261960
05:21:02 <adamse> intereseting stuff...
05:22:42 <Aruro> ty
05:22:46 <Aruro> for the video
05:22:56 <Axman6> https://hackage.haskell.org/package/ConstraintKinds-1.3.0/docs/Control-ConstraintKinds-Monad.html doesn't look right to me
05:24:38 <Axman6> I feel with mine it would be simpler: class Monad m where type MonadC m a b :: Constraint; (>>=) :: (Monad m, MonadC m a b) => m a -> (a -> m b) -> m b ... instance Monad Set where type MonadC Set a b = Ord b; ...
05:26:14 <Axman6> possibly could hack it to be more concise with type MonadC Set a b = (Monad Set, Ord b) and then have (>>=) :: MonadC Set a b => ...
05:35:32 <hughfdjackson> In javascript's main packaging tool - npm - there's a flag that says 'install this, and also save it to the configuration file for the project'
05:35:37 <hughfdjackson> `npm install <package> --save`
05:35:43 <hughfdjackson> is there an equivalent for cabal?
05:37:52 <Fuuzetsu> what's the magic incantation to tell cabal install to pin a dependency at some given version?
05:41:11 <Fuuzetsu> please respond ;;
05:42:03 <mauke> dunno, I'd have to read the docs for that
05:42:03 <Fuuzetsu> --constraint
05:47:10 <sagittarian> hughfdjackson: try cabal freeze
05:47:25 <sagittarian> i.e., cabal install pkg && cabal freeze
05:47:45 <Qfwfq> Will that work if pkg isn't already specified in the cabal file?
05:48:11 <hughfdjackson> sagittarian: thanks, will give that a go :)
05:48:11 <sagittarian> try it and find out
05:48:24 <sinelaw> cabal freeze?
05:48:32 <sinelaw> oops, too late :)
05:49:29 <hughfdjackson> sinelaw: but appreciated none-the-less :D
05:49:30 <sinelaw> make sure your .gitignore (if you have one) is not ignoring cabal.config
05:50:37 <hughfdjackson> i take it the equivalent is cabal.sandbox.config, when using sandboxes?
05:51:11 <hughfdjackson> oh, right - reading cabal.sandbox.config, it asks me to create a cabal.config if i want to make any other changes
05:51:23 <hughfdjackson> i assume that it's standard procedure to .gitignore the sandbox config..
05:51:38 <Fuuzetsu> uh, is -package GHC flag documented anywhere? I see no mention of it in help nor in --show-options
05:51:47 <Fuuzetsu> notable I'm wondering if there's a -no-package
05:51:52 <Fuuzetsu> notably*
05:52:33 <Fuuzetsu> well, ‘-no-package’ does not exist but a similar guy might
05:54:28 <Axman6> nshepperd: so this is what I was thinking of, it seems to work afaict: https://gist.github.com/axman6/fd41491c38d5492928d1
05:57:27 <nshepperd> Axman6: interesting
05:58:41 <Axman6> there must be something wrong with it or someone else would've proposed it I'm sure
05:58:54 <Axman6> apart form the fact it would break a lot of code (maybe?)
05:59:46 <nshepperd> well, it looks similar to the FunctorConstraint they are using in the ConstraintKinds package
06:00:24 <Axman6> but less noisy in use
06:00:43 <nshepperd> except that MonadC also lets you enforce some relation also between the types converted in( >>=)
06:00:48 <Axman6> I can't even make sense of the Monad definition in that package
06:03:22 <nshepperd> it's the normal Monad definition except with constraints requiring every monadic value that occurs is allowed
06:04:18 <nshepperd> class Functor f where { type FunctorConstraint f x :: Constraint; ... }
06:05:02 <nshepperd> the Monad definition inherits from that
06:06:50 <nshepperd> Axman6: oh, your return' definition doesn't seem to be constrained
06:06:56 <Axman6> right, but then it has FunctorConstraint m a, FunctorConstraint m b, FunctorConstraint m (m b)
06:07:06 <Axman6> no it's not, I'm not sure if it should be
06:07:12 <Axman6> it probably should be
06:08:07 <nshepperd> oh, you're right that is weird
06:08:43 <nshepperd> it looks like they just did that in order to give >>= a default definition in terms of join
06:09:53 <Axman6> I dunno. sleep time for me anyway
06:09:59 <Axman6> too tires to think further =)
06:10:02 <Axman6> tired too
06:10:10 <nshepperd> (FunctorConstraint m a, FunctorConstraint m b) should certainly be enough, otherwise you couldn't use it for Text or unboxed vectors
06:13:34 <nshepperd> although there is an unboxed vector instance in the package... I didn't think they had an Unbox instance
06:15:53 * hackagebot warp 3.0.2.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.2.3 (MichaelSnoyman)
06:20:53 * hackagebot aivika 1.4 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-1.4 (DavidSorokin)
06:20:55 * hackagebot aivika-experiment 1.4 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-1.4 (DavidSorokin)
06:20:57 * hackagebot aivika-experiment-chart 1.4 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-1.4 (DavidSorokin)
06:25:53 * hackagebot aivika-experiment-cairo 1.4 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-1.4 (DavidSorokin)
06:25:56 * hackagebot aivika-experiment-diagrams 1.4 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-1.4 (DavidSorokin)
06:43:14 <wz1000> If I am within IO, how can I make a closure with local state?
06:47:39 <Aruro> suppose i have data Point = Point Float Float, and the function distance :: Point -> Point -> Float
06:48:07 <Aruro> why call distance Point 1 1 Point 2 2 has syntax mistake?
06:48:27 <Aruro> correct call is distance (Point 1 1 ) (Point 2 2)
06:49:10 <frihd> wz1000: you mean, define a lambda and use some values to bind some variables?
06:50:26 <mauke> Aruro: it's valid syntax, but it tries to call distance with 6 arguments (Point, 1, 1, Point, 2, 2)
06:50:44 <mauke> and that's like 3 type errors
06:51:18 <Aruro> so it does not trasform Point 1 1 Point 2 2 to two arguments first
06:51:27 <Aruro> it immediately tries to call
06:51:40 <bezirg> question: the case expression needs at least one branch to parse, right?
06:51:59 <bezirg> I mean in terms of haskell98 parsing
06:52:07 <Aruro> aaa i think i understood now
06:52:10 <geekosaur> Aruro, are you aware of partial application?
06:52:16 <Aruro> Point 1 1 is also function
06:52:32 <Aruro> so it does not matter that its my type
06:52:34 <frihd> the Point constructor is indeed a function
06:52:36 <mauke> Point is a function
06:52:48 <frihd> (the one on the right of the data definition)
06:52:50 <bezirg> y it needs at least 1 branch,
06:52:50 <mauke> Point 1 1 is Point applied to 1 and 1
06:52:57 <Aruro> yes
06:53:00 <Aruro> now clear
06:53:03 <frihd> =)
06:53:06 <Aruro> :)
06:53:27 <Aruro> would be nice if this function call had somehow higher precedence to original one
06:53:27 <no-doz> :]
06:53:33 <mauke> @let data Point = Point Float Float deriving (Show)
06:53:35 <lambdabot>  Defined.
06:53:37 <mauke> :t Point
06:53:38 <lambdabot> Float -> Float -> Point
06:53:41 <Aruro> yes
06:53:48 <mauke> :t Point 1
06:53:48 <Aruro> i see
06:53:48 <lambdabot> Float -> Point
06:53:50 <mauke> :t Point 1 2
06:53:51 <lambdabot> Point
06:54:10 <Aruro> so in a way all data defined types are functions?
06:54:35 <frihd> :t Nothing
06:54:36 <lambdabot> Maybe a
06:54:41 <mauke> hmm. all constructors that take arguments are fubctions
06:54:55 <mauke> Nothing isn't a function
06:55:26 <Aruro> but char or int does not need constructor in front
06:55:29 <Aruro> like Int 1
06:55:33 <Aruro> or Char a
06:55:40 <Aruro> how is that realized?
06:55:54 <mauke> compiler magic
06:55:57 <Aruro> :)
06:56:19 <mauke> 'x' is effectively a Char constructor
06:56:25 <Aruro> what stops to make functions defined as constructors have higher evaluation order?
06:56:35 <mauke> huh?
06:56:51 <Aruro> like distance Point 1 1 Point 2 2
06:56:57 <Aruro> will not think its 6 arguments
06:57:06 <mauke> ( )
06:57:14 <Aruro> because it will first  evaluate Point 1 1 and so on
06:57:18 <Aruro> yes
06:57:22 <Aruro> but i defined Point as data
06:57:27 <Aruro> it is not clear i need ()?
06:57:28 <mauke> you can't change the precedence of function application
06:58:06 <mauke> > map (Point 0) [1,2,3]
06:58:07 <lambdabot>  [Point 0.0 1.0,Point 0.0 2.0,Point 0.0 3.0]
06:58:21 <Aruro> that is just currying
06:58:25 <Aruro> or?
06:58:26 <geekosaur> in another language you would write Point(1, 1) and the parentheses aren't optional there either. the only difference is that in Haskell they go around the whole thing
06:58:36 <mauke> the compiler can't assume Point will always take 2 arguments
06:58:50 <Aruro> a
06:58:53 <nshepperd> that wouldn't be pleasant, I think, because then parsing the source code would depend on the number of arguments
06:58:56 <Aruro> ok that is good point
06:58:56 <geekosaur> there are eve nalgauegs that would let you pass Point itself around, by --- same way --- leaving off the parens
06:58:59 <mauke> here I'm using (Point 0) and passing it to map
06:59:07 <geekosaur> *even languages
06:59:14 <Aruro> yes mauke good point
06:59:25 <Aruro> so currying it the reason
06:59:28 <Aruro> os
06:59:30 <Aruro> is
06:59:51 <mauke> it also makes the language simpler in a way
07:06:32 <augur> @hoogle [a -> b] -> ([b] -> c) -> [a] -> c
07:06:34 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
07:07:33 <mauke> :t \fs c xs -> c (zipWith id fs xs)
07:07:34 <lambdabot> [b -> c] -> ([c] -> t) -> [b] -> t
07:08:13 <augur> mauke: indeed
07:08:23 <mauke> @pl \fs c xs -> c (zipWith id fs xs)
07:08:23 <lambdabot> flip (.) . zipWith id
07:08:26 <augur> also:   ([c] -> t) -> [b] -> t   ~   [b] -> [c]
07:08:44 <augur> so this is really   [b -> c] -> [b] -> [c]
07:08:51 <augur> so it looks like an applicative in disguise
07:09:02 <emre> Hello #haskell, any Vimmers wanna recommend what to do in terms of syntax hl/indentation?
07:18:17 <augur> hm
07:18:27 <augur> composition = continuized application
07:18:50 <Sornaensis> Is haskell the future of programming?
07:18:54 <augur> yes
07:19:00 <Sornaensis> sweet
07:19:26 <rudi_s> :D
07:20:08 <emre> No Vimmers? :(
07:20:16 <emre> or none at all to reply
07:20:30 <frihd> emre:  i use only vim, but I do not really "tune" my editor, sorry
07:21:00 <emre> it seems like it handles indentation terribly, do you mash space until it gets where you want?
07:21:17 <Sornaensis> I vim
07:21:28 <Sornaensis> I use 4 spc tabs and erode tabs into spaces
07:21:32 <amatsu> emre: I've found the default syntax and indentation settings enough (mash space, not magical like emacs), but Syntastic with ghc-mod and hlint are nice
07:21:37 <Sornaensis> it works preddy well
07:21:49 <frihd> emre yes but I seem to have internalized enough of the indent rules
07:22:06 <Sornaensis> yeh syntastic and such make autoindenting haskell work
07:23:58 <frihd> related, does hdevtool works with cabal sandboxes (I didn't use hdevtool in a while)?
07:30:29 <hask3> I know that "read" is a stand-alone function that happens to rely on the functions "readsPrec" and "readPrec" from the Read type class. So all the types that are instances of Read implement "readsPrec" and "readPrec". This makes then work with the general "read" function.
07:30:29 <hask3> My question is this: Why didn't they make "read" a part of the Read type class itself?
07:34:50 <benmachine> hask3: it doesn't really help you write readsPrec, so you have to write that anyway, and there's not usually a performance advantage
07:34:57 <benmachine> so why bother?
07:35:28 <hask3> benmachine: does anyone use readsPrec?
07:35:37 <benmachine> yes
07:35:57 * hackagebot dynamic-state 0.1.0.0 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.0 (fread2281)
07:36:05 <benmachine> it's what I use when I want to detect failure
07:36:15 <benmachine> except I think there might be readMaybe somewhere now
07:37:10 <hask3> ok
07:37:26 <benmachine> but you could use it anyway if you wanted to just read something off the beginning of a string and use the rest of the string
07:37:45 <benzrf> :t readsPrec
07:37:46 <lambdabot> Read a => Int -> ReadS a
07:37:49 <benzrf> eh
07:37:57 <benmachine> Int -> String -> [(String,a)]
07:38:16 <benzrf> > (readsPrec 3 :: ReadS Int) "34"
07:38:19 <lambdabot>  [(34,"")]
07:38:25 <benzrf> > (reads 3 :: ReadS Int) "34"
07:38:26 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’
07:38:27 <lambdabot>                with ‘GHC.Base.String -> [(GHC.Types.Int, GHC.Base.String)]’
07:38:27 <lambdabot>  Expected type: Text.ParserCombinators.ReadP.ReadS GHC.Types.Int
07:38:27 <lambdabot>    Actual type: [(a0, GHC.Base.String)]
07:38:40 <hask3> ok thanks
07:38:46 <benzrf> huuuh?
07:38:47 <benzrf> :t reads
07:38:48 <lambdabot> Read a => ReadS a
07:38:49 <benzrf> oh
07:38:52 <benzrf> > (readsPrec 3 :: ReadS Int) "34"
07:38:53 <lambdabot>  [(34,"")]
07:38:57 <benzrf> > (reads :: ReadS Int) "34"
07:38:58 <lambdabot>  [(34,"")]
07:39:03 <benzrf> whats the diff
07:39:09 <hask3> How can I start GHCi in strict mode or compile GHC in strict mode, so that 2 is not allowed? so I have to type 2::Int or 2::Double
07:39:25 <benmachine> readsPrec uses the precedence argument to know how much of the string to swallow
07:39:38 <benzrf> swallow it ALL
07:39:45 <benzrf> benmachine: explain?
07:39:52 <benmachine> benzrf: trying to come up with a good example
07:40:52 <benmachine> hmm
07:41:01 <benmachine> I'm actually not sure when it's necessary
07:41:32 <benmachine> perhaps when parsing things with infix data constructors
07:41:43 <Aruro> > data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday derived (Eq,Ord,Show,Read,Bounded, Enum)
07:41:44 <lambdabot>  <hint>:1:1: parse error on input ‘data’
07:41:58 <benzrf> Aruro: use @let
07:42:05 <benmachine> also "deriving" not "derived"
07:42:27 <Aruro> >@let data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq,Ord,Show,Read,Bounded, Enum)
07:42:35 <benmachine> no >
07:42:49 <Aruro> @let data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq,Ord,Show,Read,Bounded, Enum)
07:42:52 <lambdabot>  Defined.
07:43:08 <Aruro> >[Monday..Sunday]
07:43:21 <benzrf> Aruro: you need a space
07:43:27 <benzrf> > [Monday..Sunday]
07:43:29 <lambdabot>  A section must be enclosed in parentheses thus: (Monday.. Sunday)Not in scop...
07:43:35 <benzrf> whoa, what?
07:43:49 <Aruro> > [(Monday)..(Sunday)]
07:43:51 <lambdabot>  [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
07:43:55 <Aruro> why?
07:44:00 <benmachine> > [Monday .. Sunday]
07:44:02 <lambdabot>  [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
07:44:03 <benzrf> > let x = 3; y = 4; in [x..y]
07:44:05 <lambdabot>  [3,4]
07:44:08 <benzrf> wtf
07:44:13 <Aruro> spaces?
07:44:23 <benmachine> otherwise it thinks Monday is a module name, and Monday.. is a reference to . from the Monday module
07:44:34 <Walther> > [1..8]
07:44:35 <lambdabot>  [1,2,3,4,5,6,7,8]
07:44:39 <Aruro> module name?
07:44:49 <Aruro> what is syntax for modules?
07:44:52 <Walther> Aruro: think like Data.List
07:45:01 <Aruro> aaa ok
07:45:03 <Aruro> intersting
07:45:10 <benmachine> :t Data.List.intercalate
07:45:11 <lambdabot> [a] -> [[a]] -> [a]
07:45:20 <benzrf> benmachine: ah
07:45:23 <Aruro> useful
07:45:32 <benmachine> it's a bit silly, really
07:45:41 <benmachine> but there you go
07:45:45 <Aruro> yeah  but its fine :)
07:46:25 <Aruro> btw can i use .. in data declaration?
07:46:35 <benzrf> DD
07:46:42 <benzrf> oops
07:46:48 <benzrf> Aruro: how would that work?
07:46:49 <Aruro> like data Characters = a | .. | z
07:47:00 <benzrf> Aruro: no, how would it know what to put in between?
07:47:09 <benzrf> also data constructors have to be uppercase
07:47:42 <Aruro> ok
07:48:12 <flux> that would literally be the only case where it would be useful :)
07:48:22 <Aruro> but Munday Tuesday and so on are functions?
07:48:26 <flux> but, there could be other similar situations where generating constructors could be useful
07:48:42 <flux> but it would be more complicated to have that (and you can have it with template haskell)
07:48:44 <benzrf> Aruro: no
07:48:48 <Aruro> just with zero arguments?
07:48:51 <benzrf> Aruro: no such thing
07:48:55 <Aruro> no?
07:48:59 <benzrf> Aruro: all functions take 1 argument
07:49:11 <benzrf> by definition
07:49:22 <Aruro> and how are these guys called?
07:50:00 <Aruro> in data Day = Monday | .. | Sunday
07:50:18 <benzrf> Aruro: what do you mean
07:50:19 <benmachine> values
07:50:22 <benzrf> oh
07:50:27 <Cale> Aruro: Well, they're the data constructors of the type Day
07:50:37 <benzrf> Aruro: FYI you say 'what' not 'how' for that
07:50:58 <benzrf> Aruro: 'what are they called'... 'how are they called' would be 'what do you do to call them'
07:51:11 <Cale> hm?
07:51:17 <benzrf> Cale: 10:51 < Aruro> and how are these guys called?
07:51:28 <benzrf> Cale: i was confused for a sec because i thought Aruro was asking how to call them
07:51:28 <Cale> Ah, okay
07:52:05 * benmachine occasionally wonders if people's mistakes in application of the English language are actually the result of them applying a simpler and more consistent ruleset, and the mistakes actually make more sense than the correct thing
07:52:09 <Aruro> ty for syntax lesson in english ;)
07:52:27 <Aruro> enother question from above Day type declaration
07:52:35 <Aruro> why [x | x<-Day]
07:52:42 <Aruro> does not work?
07:52:49 <Aruro> i said him day is Enum and Ord
07:53:09 <Aruro> told him
07:53:10 <benzrf> benmachine: of course they are
07:53:36 <Aruro> yes i was asking how to call functions with no argument :D
07:53:42 <benmachine> Aruro: when you do x <- y in a list comprehension, y should be a list
07:53:42 <benzrf> benmachine: most languages' grammars are simpler and more consistent than englishes
07:53:49 <benzrf> Aruro: ah
07:53:56 <augur> f (f a -> b) -> (f b -> r) -> f a -> r   ~   f (f a -> b) -> f a -> f b    is certainly constructible if f is applicative but is that what's desired? no.. hmm
07:54:02 <benzrf> Aruro: ok sorry, benmachine's response made me think you meant `what do you call them'
07:54:09 <benzrf> Aruro: you cannot call them, they are values
07:54:17 <benzrf> Aruro: you might as well ask `how do i call the function 3'
07:54:29 <Aruro> yes i want ask that :)
07:54:42 <benzrf> Aruro: it's a meaningless question :|
07:54:45 <Aruro> in this terminology 3 must be also constructor no?
07:54:53 <benzrf> Aruro: 3 is a value
07:54:55 <benzrf> so is Sunday
07:54:56 <benmachine> you don't need to take arguments to be a constructor
07:55:00 <augur> f needs to be shape-indexed:    f s (f s' a -> b) -> (f s b -> r) -> f (s+s') a -> r   ~    f s (f s' a -> b) -> f (s+s') a -> f s b
07:55:10 <benmachine> True is a constructor of Bool
07:55:21 <benmachine> it's already a value of Bool, you don't need to call it or anything
07:55:34 <Aruro> very vague difference between value and constructor but i will take it
07:55:58 * hackagebot apiary 1.0.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.0.0 (HirotomoMoriwaki)
07:56:00 * hackagebot apiary-logger 1.0.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.0.0 (HirotomoMoriwaki)
07:56:02 * hackagebot apiary-persistent 1.0.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.0.0 (HirotomoMoriwaki)
07:56:04 * hackagebot apiary-websockets 1.0.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-1.0.0 (HirotomoMoriwaki)
07:56:06 * hackagebot apiary-cookie 1.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.0.0 (HirotomoMoriwaki)
07:56:08 <hask3> How can I start GHCi in strict mode or compile GHC in strict mode, so that 2 is not allowed? so I have to type 2::Int or 2::Double
07:56:15 <benzrf> Aruro: constructors ARE values
07:56:28 <augur> i feel like there might be something monadic going on here actually
07:56:32 <benmachine> hask3: I'm not sure exactly what you mean, but you could try -fwarn-defaulting
07:56:43 <benmachine> benzrf: I don't think that's true as such
07:56:49 <Aruro> consider this data  Point = Point Float Float
07:56:54 <benzrf> uh huh
07:56:55 <benmachine> well, semantics
07:56:58 <Aruro> is Point value? or function?
07:57:01 <benzrf> Aruro: both
07:57:04 <benzrf> functions are values
07:57:07 <Aruro> the one on the right side
07:57:07 <augur> like... there should be some kind of isomorphism   f s . f s'   ~   f (s+s')
07:57:18 <benmachine> constructors are values that you can pattern-match on, I suppose
07:57:25 <hask3> benmachine: yeah thanks. -Wall also works :)
07:57:42 <benzrf> benmachine: if you ignore primitive types, constructors are the ONLY kind of value besides functions
07:58:15 <benmachine> benzrf: I only mean that constructors are *also* things you use in patterns, so they're more then just values
07:58:18 <benmachine> *than
07:58:18 <Aruro> actually can you pattern mach on custom functions like you do on constructors?
07:58:34 <benmachine> also, 'let x = x in x' -- x is a value, but not a constructor (but now I'm just being pedantic :P)
07:58:42 <benmachine> Aruro: no
07:58:56 <benmachine> Aruro: it's not clear what it would mean to do so
07:59:15 <benzrf> Aruro: that would require haskell to figure out how to run the function backwards
07:59:20 <benzrf> Aruro: which is not solvable in general
07:59:28 <benzrf> Aruro: plus, not all functions are even injective
07:59:35 <Aruro> like if i have fucntion factorial n can i patter match  Factorial _ in some other function?
07:59:48 <benzrf> Aruro: factorial isn't injective
07:59:55 <Aruro> what is that?
07:59:55 <benzrf> Aruro: what if you match `Factorial 1'
08:00:02 <benmachine> if you pattern matched 1 against Factorial x
08:00:02 <Aruro> and  why constructors are?
08:00:11 <benmachine> it's not clear whether x should be 0 or 1
08:00:13 <benzrf> benmachine: er, yes
08:00:25 * nshepperd senses a help vampire in the house
08:00:38 <benmachine> constructors are automatically injective, in that, say, Just x and Just y are only the same if x = y
08:00:52 <benzrf> Aruro: a function is injective if and only if different inputs have different outputs
08:00:53 <benmachine> nshepperd: I always hated that term
08:01:02 <benzrf> Aruro: so (+1) is injective, but (*0) is not
08:01:08 * hackagebot apiary-clientsession 1.0.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-1.0.0 (HirotomoMoriwaki)
08:01:10 * hackagebot apiary-authenticate 1.0.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.0.0 (HirotomoMoriwaki)
08:01:12 * hackagebot apiary-eventsource 1.0.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-1.0.0 (HirotomoMoriwaki)
08:01:14 * hackagebot apiary-purescript 1.0.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.0.0 (HirotomoMoriwaki)
08:01:16 * hackagebot apiary-mongoDB 1.0.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.0.0 (HirotomoMoriwaki)
08:01:26 <benzrf> whoa
08:02:02 <benmachine> constructors are always injective because if you apply constructor C to value x you get a value which is basically "constructor C applied to value x"
08:02:07 <benmachine> you can always get x out of it again
08:02:14 <Aruro> so if i want to patter match function i can just make some fake type for it to be constructor in?
08:02:17 <nshepperd> real vampires are way more exciting, it's true
08:02:25 <benmachine> Aruro: depends what the function is
08:02:41 <benmachine> Aruro: and what you really want to do
08:02:54 <Aruro> im trying to understand what i CAN do
08:02:54 <augur> ahh no shapes cant be indexes, they have to be existentially closed..
08:02:55 <benmachine> Aruro: but the short answer is, if you want to pattern match on functions, stop wanting that
08:03:07 <Aruro> :D
08:03:28 <Aruro> what is bad about that?
08:03:43 <benmachine> Aruro: there's nothing morally wrong with it, you just basically can't
08:03:52 <nshepperd> you can't make a function into a constructor
08:03:55 <Aruro> k
08:04:40 <benmachine> applying a constructor to a value is like attaching a tag to that value, and pattern-matching is like reading tags and then taking them off
08:04:41 <Aruro> u mean because i can not type algorythm in type definition?
08:05:04 <Aruro> yes clear
08:05:07 <benmachine> applying some other function is not like attaching a tag, it can do all sorts of other things
08:05:20 <benmachine> so you can't do the read-tag-and-take-it-off thing
08:05:29 <benmachine> 'cause... there's no tag
08:05:35 <Aruro> so constructors are not "real" functions more like functional lables
08:05:43 <Aruro> ?
08:05:54 <benmachine> they are real functions, they're just a very specific and simple kind of function
08:06:15 <dv-> > map Just [1,2,3]
08:06:17 <lambdabot>  [Just 1,Just 2,Just 3]
08:06:18 * hackagebot apiary-memcached 1.0.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.0.0 (HirotomoMoriwaki)
08:06:23 <benmachine> functions which only do this one thing that we can easily undo
08:06:38 <benmachine> whereas most functions do lots of things, so you can't easily undo them
08:07:08 <augur> oh maybe it doesnt have to be existentially closed everywhere, just inside composition actualy.. hmm
08:08:16 <Aruro> aaa benmachine before  by saying injective you basically were saying that constructors are pass around exactly as they are defined?
08:08:18 <wz1000> Why aren't IO (a->b) and a -> IO b isomorphic? My intuition says they should be, but I can see no way to bring the IO outside. What does a -> IO b encode that cannot be encoded by IO (a->b)?
08:08:52 <benmachine> Aruro: that's not exactly what the word "injective" means, but otherwise yes
08:08:59 <Aruro> ok
08:09:27 <Aruro> ty
08:09:35 <benmachine> wz1000: say you're making a dictionary, String -> String
08:09:59 <benmachine> wz1000: IO (String -> String) has to look up all the words up front, because once you get a function by binding on the result of it, that function can't do any more IO
08:10:16 <benmachine> wz1000: but String -> IO String can look up each word as you ask for it, because it can do more IO each time you call it
08:10:30 <benzrf> benmachine: that's still isomorphic
08:10:41 <benmachine> benzrf: no it isn't
08:10:42 <benzrf> they're denotationally equivalent
08:10:46 <benmachine> no they aren't
08:10:49 <benzrf> oh wait
08:10:55 <benzrf> fuck i always forget io fucks up denotational semantics
08:10:59 <nshepperd> wz1000: if 'a' is the type of the nuclear launch codes, (a -> IO b) can send the launch codes to the russians over the internet, while IO (a -> b) cannot
08:11:26 <wz1000> Ah, I get it. Thanks!
08:11:33 <benmachine> yeah, basically, IO (a -> b) can't choose what IO to do based on what a value you give it
08:12:29 <wz1000> I was looking at it in terms of return value only, not the possible side effects.
08:12:35 <benmachine> likewise, Maybe (a -> b) has to choose whether to be Just or Nothing before it gets its hands on an a, whereas a -> Maybe b can sometimes be Just and sometimes be Nothing depending on the argument
08:15:12 <wz1000> Also, you can convert a IO (a->b) to a -> IO b, but you cannot convert IO [a] to [IO a]. Is this because [] has a 'structure', while (a->) does not?
08:15:38 <vanila> wz1000, it's because >>= works with ->
08:15:38 <vanila> look
08:15:40 <vanila> :t (>>=)
08:15:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:15:59 * hackagebot apiary-cookie 1.0.0.1 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.0.0.1 (HirotomoMoriwaki)
08:19:38 <benmachine> wz1000: I guess it's because (a ->) is always the same "shape"
08:19:50 <benmachine> a -> b always has the same number of b's in it
08:20:47 <rudi_s> Hi. Is there something like argv[0] in Haskell? Neither getProgName nor getExecutablePath provide the information normally available in argv[0].
08:21:07 <wz1000> benmachine: Yeah, thats what I meant by structure
08:21:55 <benmachine> rudi_s: http://hackage.haskell.org/package/system-argv0
08:22:12 <benmachine> rudi_s: I believe the reason why getProgName is the way it is is so that it can also be available on Windows
08:22:21 <benmachine> but not sure if I remember that correctly
08:22:38 <nshepperd> it's probably related to the reason why ReaderT ((->) r) is a good monad transformer while ListT is a horrible one
08:22:50 <rudi_s> benmachine: A separate package for just that, well. Thank you.
08:24:12 <benmachine> rudi_s: what's wrong with getExecutablePath, by the way?
08:24:26 <rudi_s> benmachine: It's not the path the user entered.
08:24:34 <benmachine> ah
08:24:49 <rudi_s> I just want to display the "usage: <prog> <args>" message, and argv[0] is typically used for <prog> - as entered by the user.
08:24:54 <nshepperd> well, you sort of can convert IO [a] to [IO a], but terribly
08:25:05 <benmachine> nshepperd: what's the length of the answer?
08:25:24 <benmachine> rudi_s: I think we normally just use getProgName for that, it doesn't seem so terrible a compromise
08:25:35 <nshepperd> infinite, but if you go too far it throws errors
08:25:43 <nshepperd> which is why it's terrible
08:25:53 <benmachine> nshepperd: oh. is that definitely better than just const []? :P
08:25:58 <rudi_s> benmachine: Yeah, I'm going to use it too. Just wanted to know if I missed something.
08:26:34 <geekosaur> rudi_s, I would use the canonical name without a path anyway. using the user provided name is mainly useful if you play link tricks, which is strongly deprecated these days (yes, I know about busybox, embedded s pretty much ther only valid use case and even then you want basename like getProgName gives you)
08:26:53 <nshepperd> unsequence io = [fmap (!!k) io | k <- [0..]]
08:27:05 <geekosaur> I don't see many programs that use the exact argv[0] vs. the basename
08:27:19 <geekosaur> (and the ones I've encountered are usually annoying in other ways as well)
08:27:25 <rudi_s> geekosaur: Well, from time to time it's useful. And argv[0] the usual way in the Unix world. But getProgName will be fine.
08:27:31 <nshepperd> but the badness clarifies that the problem *is* with the structure of a list being unknown beforehand
08:27:47 <geekosaur> no, basename(argv[0]) has been the usual way for some 30 years now
08:28:07 <rudi_s> I guess I'm writing the wrong programs ;-)
08:28:08 <geekosaur> you can find stuff using raw argv[0] but it's uncommon
08:28:11 <rudi_s> Anyway, doesn't matter.
08:32:30 <benmachine> geekosaur: /bin/ls --help vs. ls --help show that it uses argv[0]
08:32:40 <benmachine> this being coreutils, not busybox
08:32:54 <zq> i haz question
08:33:42 <benmachine> zq: can has question?
08:36:00 * hackagebot dynamic-state 0.1.0.1 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.1 (fread2281)
08:47:01 <benzrf> wrt unsequence: consider
08:47:12 <benzrf> if you have a C "function" that returns an array
08:47:14 <benzrf> or a pointer or w/e
08:47:36 <benzrf> is there any reasonable way to get an array of function pointers, each of which does as much as necessary of that funciton to get the n'th item?
08:47:48 <benzrf> no, that's ridiculous
08:47:50 <Gurkenglas> Can anyone recommend a service that provides an [(a,b)]->[a->b]?
08:48:07 <benzrf> Gurkenglas: that'd be partial functions though
08:48:18 <benzrf> Gurkenglas: wait
08:48:28 <simpson> Gurkenglas: That's a strange signature. What's the goal?
08:48:33 <benzrf> do you mean [(a, b)] -> [a -> b] or do you mean [(a, b)] -> a -> b
08:48:50 <Gurkenglas> The first, although the second would do something similar
08:49:33 <simpson> :t map (\(_, b) -> \_ -> b)
08:49:34 <lambdabot> [(t, t1)] -> [t2 -> t1]
08:50:04 <simpson> :t lookup -- from Data.List
08:50:05 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
08:50:35 <simpson> Gurkenglas: I can't really recommend the first example. It typechecks but feels very useless.
08:51:07 <Gurkenglas> Answer to simpson (Spoiler):              You give it a list of value pairs and it returns a list of maps whose graphs contain those pairs, sorted by ascending complexity. I started out with a and b being reals, and you instead providing intervals of reals in the second argument of each pair so you can use rounded values.
08:51:47 <Gurkenglas> Something like oeis, but not just for natural sequences.
08:52:02 <simpson> Oh, homework?
08:52:16 <simpson> Sorry, it wasn't obvious from the context what these functions were supposed to do.
08:52:20 <Gurkenglas> No
08:52:48 <Gurkenglas> Hmm. Now that I think about it, such a service would be pretty useful in homework too... but then it would be useful in many other places
08:53:26 <Gurkenglas> Here, I'm just trying to predict where I should concentrate my effort in this incremental game :P
08:55:33 <hughfdjackson> if i have two files in the director `Language`
08:55:41 <hughfdjackson> Parse.hs and AST.hs
08:55:52 <hughfdjackson> where the module names in there are Language.Parse and Language.AST
08:56:11 <hughfdjackson> is there any reason `import Language.AST` in Parse.hs should fail?
08:56:23 <hughfdjackson> :# basic question, i know - can't figure it out though
08:57:08 <hughfdjackson> https://github.com/hughfdjackson/dust/blob/master/src/Language/Parse.hs <- the actual file
08:57:43 <hughfdjackson> and it's specifically when using haskell-mode, via C-c C-l to send the contents of Parse.hs to the repl..
09:00:28 <ThreeOfEight> (sb end
09:00:34 <ThreeOfEight> dammit
09:00:41 <ThreeOfEight> Why does this keep happening to me. Sorry.
09:18:17 <Guest99773> any useful links to learn Control.Arrow will very helpful
09:20:40 <hc>  /win 20
09:22:20 <nitrix> Can you have comprehension lists fed from an IO function?
09:23:45 <bms1> nitrix: What exactly do you mean?
09:24:22 <srhb> nitrix: fmap (\xs -> return [ ... x ... | x <- xs ]) readLine -- for instance?
09:25:44 <nitrix> I'm not familiar with fmap yet, but the idea would be to have a comprehension list, or maybe just a list, where elements are obtained from a function.
09:25:45 <bms1> Is there any way to do computation with GHC.TypeLits.Nat yet? Like I would like an instance (KnownNat m, KnownNat n) => KnownNat (m * n)
09:26:13 <MrNosco> Hey, kind of a noob question, but what does the error "could not deduce (a ~ Int)" mean? Does it have to do with lazy pattern matching?
09:26:30 <bms1> MrNosco: the ~ is a type equality constraint
09:26:58 <MrNosco> bms1: so, it cannot see that a is Int?
09:27:04 <bms1> MrNosco: So it's saying that your code will only work when the type variable a is Int; no other types could work
09:27:29 <MrNosco> hmm
09:28:30 <bms1> MrNosco: Heh, well techinically, it's saying *you* cannot see that a is Int!
09:29:13 <nitrix> The function I had in C is a hash function that happens to do mapping to a set of buckets. (It's distributing chunks on a distributed file system).
09:29:47 <nitrix> And the idea is that you can call the function multiple time, with a increment number each time, to get a fallback target in case the last one failed.
09:30:18 <nitrix> It's just doing some permutations based on the hash computed and stops at the Nth step.
09:30:38 <nitrix> So I figured, man that's be handy to have as a list...
09:30:48 <nitrix> s/'s/'d/
09:31:10 <bms1> nitrix: I'm confused. But perhaps something like 'iterate' is more relevant?
09:31:20 <bms1> > take 10 (iterate (+2) 0)
09:31:22 <lambdabot>  [0,2,4,6,8,10,12,14,16,18]
09:31:48 <nitrix> Brilliant!
09:32:21 <nitrix> bms1: Is it possible to have the function take a position parameters or something of that kind?
09:33:57 <bms1> nitrix: Well, it sounds like you may as well just define your own function
09:34:37 <nitrix> bms1: Actually I found the solution I think.
09:34:42 <nitrix> iterateN
09:36:50 <Kron> are there any good quickcheck tutorials out there?
09:36:54 <osa1> is it possible to pass a cabal flag while compiling a dependency?
09:38:52 <bms1> osa1: cabal install --constraint="mydep +mydepflag"
09:39:10 <osa1> bms1: how do I specify that in cabal file?
09:39:35 <bms1> osa1: Unfortunately, I believe it's not possible
09:39:50 <bms1> http://stackoverflow.com/questions/23523869/is-there-any-way-to-define-flags-for-cabal-dependencies (see the first comment on the question)
09:41:10 <osa1> bms1: thanks for the link
09:42:02 <Cale> Kron: It might be slightly out of date, but the original paper has a bunch of examples and discussion which is still relevant: http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
09:42:36 <Kron> okay! on a related note, how exactly do cabal tests work?
09:42:52 <Kron> do you just create a separate test.hs file and point the package.config at it, then "cabal test"?
09:44:21 <stepkut> back in the olden days, did GHC treat the \( in this as an escape sequence instead of lambda? (\(Just a) -> a) (Just 'c')
09:44:26 <Cale> http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
09:46:35 <Kron> ooh thanks cale
09:47:06 <stepkut> or something like that.. I remember there was a time when there was situation where you needed a space after the \ to get things to parse correctly -- but I can't remember the details
09:49:41 <Cale> stepkut: I don't recall that, maybe before my time?
09:50:57 <stepkut> Dunno.. i would have been sometime around 5.04 or later
09:52:12 <Cale> Yeah, we started around the same time then, so maybe I just have forgotten
09:52:41 <Cale> Perhaps some other preprocessing tool would affect that as well
09:53:06 <stepkut> hmm. Don't think so -- we weren't using an preprocessors at the time
09:53:23 <stepkut> a coworker developed a habit of putting a space of the \, but now the reason why has been lost
09:54:01 <Cale> Oh, maybe the syntax highlighter was messed up?
09:54:12 <osa1> why can't I specify both version range and flags in --constraint?
09:54:19 <osa1> like --constraint="package >=version +flag"
09:54:25 <stepkut> Cale: ah.. yeah
09:55:03 <stepkut> Cale: that sounds right
09:55:31 <bms1> osa1: that sounds to me like a good idea for a feature request for Cabal
09:55:46 <osa1> uhhh... so it's not supported
09:55:55 <osa1> I'll open an issue
09:56:04 * hackagebot dynamic-state 0.1.0.2 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.2 (fread2281)
09:58:40 <Kron> Cale: the haskell.org manual refers to detailed-1.0, but my cabal tells me it only has detailed-0.9
09:58:41 <osa1> bms1: I can do this though: --constraint="version constraint" --constraint="flags"
09:58:50 <Kron> is there any way to get detailed-1.0/
09:59:44 <bms1> osa1: The comment I pointed you to seems to show that Cabal can't handle it in the Cabal file; so it's possible constraint is doing something different. I'm not sure
10:01:03 <Kron> ... wait this makes no sense. "cabal: At least the following dependencies are missing: cabal >=1.9.2"
10:01:04 * hackagebot optparse-applicative 0.11.0.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.11.0.1 (PaoloCapriotti)
10:01:06 <Kron> I know I have a later cabal
10:01:23 <Kron> in fact, the cabal file itself lists cabal-version: >= 1.10 and that passes
10:01:37 <Kron> is it using several different cabals?
10:01:52 <bms1> Kron: could it be a case-sensitivity thing? Try Cabal?
10:02:11 <benmachine> Kron: what does ghc-pkg list say?
10:02:14 <Kron> yeah, I think that's it
10:02:21 <Kron> ghc-pkg listed "Cabal" and not "cabal"
10:02:24 <Kron> that was what caught me
10:02:32 <benmachine> ah right
10:02:38 <benmachine> cabal is missing, no matter what the version
10:02:46 <benmachine> because it's Cabal instead
10:03:25 <wz1000> Couldn't haskell provide something like a Computer monad, which lets you write low level code which directly almost transalates into object code, providing C or assembly level control over the machine?
10:03:33 <Kron> still, I only have detailed-0.9
10:04:07 <bms1> wz1000: related? https://github.com/mchakravarty/language-c-inline
10:04:10 <Kron> "Could not find module ‘Distribution.Simple.Test.LibV09’    Perhaps you meant Distribution.Simple.Test (from Cabal-1.18.1.3)"
10:04:29 <Kron> I never specified LibV09
10:04:36 <bms1> wz1000: http://ivorylang.org/ivory-introduction.html
10:04:43 <benmachine> Kron: what does cabal --version say?
10:05:12 <Kron> "cabal-install version 1.20.0.3 using version 1.20.0.0 of the Cabal library"
10:05:20 <Kron> maybe this relates to the mismatched details library?
10:05:33 <benmachine> details library?
10:05:43 <benmachine> detailed-1.0 is an interface version, not a package, right?
10:05:48 <Kron> yeah
10:05:49 <Kron> that
10:06:00 <Kron> sorry, I don't really know how to reference it
10:06:53 <benmachine> I don't have detailed-1.0 either
10:07:18 <Kron> hmmm.
10:07:38 <Kron> is it giving you the distribution error? libv09
10:08:29 <benmachine> well, I haven't got a detailed-0.9 file to test with
10:09:00 <benmachine> I've successfully used exitcode-stdio-1.0, for what it's worth :P
10:09:17 <Kron> ... yeah, the one the cabal reference says to avoid and is mostly for legacy compatability reasons
10:09:18 <Kron> :P
10:09:22 <Kron> I'm trying to do this right
10:09:28 <Kron> why must the right thing be so hard ;_;
10:09:41 <Kron> cabal is like a metaphor for life
10:10:33 <benmachine> I would use the exitcode-stdio one
10:11:32 <benmachine> user guide be damned
10:12:05 <MrNosco> how can I turn a list of IOs into a IO list?
10:12:16 <benmachine> MrNosco: sequence
10:12:27 <octopuscabbage> does anyone have a good tutorial on using cabal as a build tutorial
10:12:28 <Kron> join #cabal
10:12:31 <Kron> err
10:12:32 <MrNosco> thankyou
10:12:34 <Kron> no-one saw that.
10:12:44 <octopuscabbage> build tool*
10:13:39 <lowfyr> hello
10:14:43 <T_X_> is there a way to connect two handles?
10:15:15 <T_X_> I'm currently trying to rewrite the PTY scenario from here: http://rachid.koucha.free.fr/tech_corner/pty_pdip.html#Figure_4:_Description_of_a_telnet
10:16:04 <T_X_> rewrite the C-example in haskell
10:17:31 <Kron> is there anyone here who uses the detaild interface?
10:18:43 <hughfdjackson> should i choose parsec over attoparsec for programming language parsing?
10:18:56 <hughfdjackson> it appears better maintained - but i don't have any real experience with either
10:21:30 <T_X_> hm, maybe I need to do another forkIO for the master-PTY and do some manuel hClose/dup there again
10:24:56 <HeladoDeBrownie> hughfdjackson, parsec would definitely be suitable. I haven't used much attoparsec, but it seems to sell itself more for binary formats.
10:25:41 <hughfdjackson>  HeladoDeBrownie hrm - i can see that 'not as good error reporting' is commonly listed as its downsides
10:25:44 <hughfdjackson> parsec it will be !
10:26:02 <ThreeOfEight> T_X_: sorry for correcting your spelling, but it's ‘manual’. I only tell you because irssi pings me every time someone writes ‘manuel’. ;)
10:26:06 * hackagebot secret-sharing 1.0.0.3 - Information-theoretic secure secret sharing  http://hackage.haskell.org/package/secret-sharing-1.0.0.3 (PeterRobinson)
10:26:08 * hackagebot data-dispersal 1.0.0.2 - Space-efficient and privacy-preserving data dispersal algorithms.  http://hackage.haskell.org/package/data-dispersal-1.0.0.2 (PeterRobinson)
10:31:34 <T_X_> ThreeOfEight: thanks :). here you have another ping ;)
10:32:37 <ThreeOfEight> ^^
10:37:56 <Aruro> why Sitem.Info os shows mingw32 and not vista?
10:41:06 * hackagebot dynamic-state 0.1.0.3 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.3 (fread2281)
10:50:19 <hughfdjackson> is there any reason parsec is missing an Eq definition for ParseError ? L/
10:50:21 <hughfdjackson> *:/
10:50:26 <hughfdjackson> makes testing a bit of a PITA..
10:51:47 <RedNifre> Hey there.
10:53:57 <RedNifre> I was wondering about code style, specifically how to name safe and unsafe functions. I thought that functions should be safe by default, so I went with getThing :: Maybe Thing and justGetThing :: Thing (as in "I know what I'm doing, just get the thing!"). However, I saw a lot of getThing :: Thing + safeGetThing :: Maybe Thing out there. Is that the standard? What are your thoughts?
10:54:05 <moldy> http://book.realworldhaskell.org/ would you recommend this resource? to me, it seems to be a little more accessible than learnyouahaskell
10:55:01 <RedNifre> I can recommend "Learn you a Haskell" and I can't recommend "Beginning Haskell". I don't have an opinion on Real World Haskell yet, but I had a quick peek at one chapter and found it nice. You can read Real World Haskell online if you are not sure.
10:56:07 <moldy> RedNifre: thanks. i am reading it online, i wonder if it's a good investment of time :)
10:56:35 <Normangorman> i've read most of Real World Haskell - it's probably a bit heavy if you're completely new to the language.
10:56:41 <Normangorman> I would start with Learn You A Haskell
10:56:59 <StoneToad> I found learn you a haskell too slow to keep my interest so... YMMV
10:57:05 <Normangorman> then switch to RWH when you get to the IO chapter
10:57:09 <RedNifre> Well, what I'm doing is a chaotic mixture of reading beginning haskell, learn you a haskell, reading some tutorials, being on this chat and writing actual code.
10:57:18 <StoneToad> RedNifre: sounds perfect XD
10:57:21 <bms1> RedNifre: I try to never export unsafe functions in the first place. I tend to do all my unsafeness with incomplete pattern matches where it is clear from the other parts of the function that the other cases are impossible
10:57:32 <moldy> RedNifre: that is similiar to what i do.
10:58:24 <moldy> StoneToad: yes, exactly. i went through a good part of it, but i notice i begin to just skim sections because of impatience
10:59:19 <RedNifre> bms1 Well, I was writing some code that reads from a sqlite db and turns a row into a ... what's it called? type instance? While this would fail if your query has no result, my usecase is that I pull one type instance into the db and pull it out later so I know that its there. So it's not really unsafe in my case. What are your thoughts on this?
10:59:43 <RedNifre> Or more simply: What's the harm in "head" not being total if you are sure that you only use it on non empty lists?
11:00:13 <Normangorman> Is it possible to 'monkey patch' a data type as you might in Ruby? i.e. if a particular file defines an algebraic data type is there any way to add to it elsewhere?
11:00:39 <StoneToad> RedNifre: the only thing I'll say in this case is not related to your head comment, but about dbs: they can always change behind your back
11:00:41 <RedNifre> Not sure if I understand the question, but do you mean creating an instance of a type class?
11:00:52 <StoneToad> assuming this will save you a lot of hair pulling later on
11:00:57 <bms1> RedNifre: Not sure about the first question. About the second, I always just tend to pattern match the first element out; it's just simpler to me
11:01:02 <RedNifre> StoneToad: Not in my case, sqlite is a single user db and I only run one program on it.
11:01:10 <StoneToad> do you leave it on disk?
11:01:24 <RedNifre> yes?
11:01:31 <StoneToad> someone or something will eventually make a change to it w/o telling your program
11:01:42 <RedNifre> I hope not, it's a private server.
11:02:28 <RedNifre> and it would be fine if the program crashes in that case, I mean if the db got messed up I don't want the program to use it any more.
11:03:47 <RedNifre> But the db example might be too specific. I'd prefer head > Maybe a + justHead > a over the more common head > a + safeHead > Maybe a
11:03:59 <Normangorman> RedNifre: I mean, if I define data Foo = a | b | c, is there a way to return to it elsewhere and add d?
11:04:16 <RedNifre> Because then functions would be safe by default and if you know what you are doing you would conciously pick the justGiveMeTheThing variant.
11:04:31 <simpson> Normangorman: No.
11:04:53 <Normangorman> thanks simpson
11:04:59 <simpson> RedNifre: Consider using lenses.
11:05:19 <RedNifre> simpson weeeelll... yes and no
11:05:29 <RedNifre> I'm in an odd situation here, you see.
11:05:32 <simpson> > (1, 2, Just 3) & _3 . _Just *= 2
11:05:34 <lambdabot>  No instance for (GHC.Num.Num t0) arising from the literal ‘1’
11:05:34 <lambdabot>  The type variable ‘t0’ is ambiguous
11:05:34 <lambdabot>  Note: there are several potential instances:
11:05:34 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
11:05:34 <lambdabot>      -- Defined in ‘base:GHC.Float’
11:05:46 <RedNifre> I'm very new to Haskell and all those libraries are a bit overwhelming to mee.
11:05:56 <simpson> > ('1', '2', Just 3) & _3 . _Just *= 2 -- Boy, thanks DMR.
11:05:57 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal ‘3’
11:05:58 <lambdabot>  The type variable ‘a0’ is ambiguous
11:05:58 <lambdabot>  Note: there are several potential instances:
11:05:58 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
11:05:58 <lambdabot>      -- Defined in ‘base:GHC.Float’
11:06:07 * hackagebot yesod-tls 1.4.1 - Provides main functions using warp-tls for yesod projects  http://hackage.haskell.org/package/yesod-tls-1.4.1 (netom)
11:06:15 <klugez> > ('1', '2', Just 3) & _3 . _Just *~ 2
11:06:16 <lambdabot>  ('1','2',Just 6)
11:06:20 <bms1> > let minimum :: [Int] -> Int; minimum (x : xs) = go x xs where { go y [] = y; go y (z : zs) = go (min y z) zs } in minimum [3,4,5]
11:06:22 <lambdabot>  <hint>:1:20: lexical error at character '\b'
11:06:25 <RedNifre> While it might be more productive in the long run to learn lenses, conduit, pipes and a thousand other things first, that would be very demotivating to me.
11:06:31 <simpson> Oh derp, I was using = instead of ~. Too much State for me!
11:06:46 <simpson> RedNifre: Okay. Then prefer total functions at all times.
11:06:48 <RedNifre> Instead I chose to only spend half of my time learning haskell and use the second half to get actually working code.
11:07:06 <bms1> RedNifre: There's an example where I just fail on the empty list case through pattern matching
11:07:10 <klugez> Lenses probably aren't the right place, if you're already using your quota of learning new things.
11:07:57 <klugez> It's worth looking at but easy to get overwhelmed.
11:08:33 <fread2282> pipes or conduit can be useful, but aren't useful all the time/at all when writing toy programs
11:09:03 <RedNifre> I wanted some persistence, so I found the very raw HDBI to be instantly approachable because I already know SQL.
11:09:50 <RedNifre> But I'm a bit afraid that I'm now reinventing all the orms that already exist ;)
11:11:22 <freeman42> anyone knows what is a "build system variable"? as mentioned here: https://ghc.haskell.org/trac/ghc/wiki/DynamicGhcPrograms is it just a normal "environment variable"? or is it different and set in another way?
11:12:07 <RedNifre> There's one thing I don't understand: How does (fromSql something :: Integer) work? I'm not totally clear on how :: works, in that example it looks like (Integer.fromSql something) to me.
11:12:59 <recursion-ninja> RedNifre: it lets the compiler know what type to expect when transforming the data
11:12:59 <RedNifre> I mean, I guess that :: Integer in this case means that there is not only one fromSql function, but instead Integer is an instance of a class that implements fromSql, but I find the syntax a bit confusing.
11:13:26 <klugez> :: is "has type"
11:13:35 <recursion-ninja> RedNifre: it solidifies the type to SQLValue -> Integer
11:13:36 <klugez> Surely you've seen it in type signatures for functions?
11:13:53 <RedNifre> Yes, I understand it in the type signatures of functions.
11:13:55 <fread2282> RedNifre: other way around: fromSql is a function that is in a typeclass or uses one and :: Integer tells it to choose the Integer "version"/instance of fromSql
11:13:57 <klugez> It can also be used in the code in case it would be ambiguous otherwise.
11:14:04 <klugez> It's the exact same thing inside the code.
11:14:06 <mauke> freeman42: are you trying to compile your own ghc?
11:14:12 <klugez> It spells the type that the expression before it has.
11:14:18 <RedNifre> And I also understand that you can an instance of a class to a type, I just find it odd that :: is used that way.
11:14:31 <recursion-ninja> I'm confused about the folling GHC compiler message. What does this mean?
11:14:33 <recursion-ninja> Couldn't match expected type `B.ByteString' with actual type `bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString'
11:14:50 <recursion-ninja> is this some kind of libray mismatching?
11:15:02 <RedNifre> looks more like eager vs lazy
11:15:07 <freeman42> mauke, no, I just need to set the DYNAMIC_GHC_PROGRAMS variable to DYNAMIC_GHC_PROGRAMS to get past a linker error on windows
11:15:11 <Oded> Hello
11:15:26 <merijn> Naah, package name + numer almost always == version mismatch
11:15:44 <recursion-ninja> merijn: thats what I was afraid of...
11:15:58 <recursion-ninja> merijn: how doe I go about resolving it? any tips?
11:16:00 <mauke> freeman42: that's a build system variable. it's used when building ghc
11:16:02 <merijn> recursion-ninja: Are you building using cabal?
11:16:07 <mauke> freeman42: https://ghc.haskell.org/trac/ghc/wiki/Building/Using#Buildconfiguration
11:16:15 <recursion-ninja> merijn: yes I'm using Cabal
11:16:28 <recursion-ninja> merijn: I'm using cabal to build the application
11:16:32 <RedNifre> So using :: after a function call chooses which type to pick the function from, of those types that have instances for the class that declared that function?
11:16:41 <merijn> recursion-ninja: odd, then it's hard to say without more context
11:16:43 <Oded> Hello guys, I'm new to Haskell. I wonder how can I practice, is there a collection of things I can try to program in Haskell?
11:16:53 <merijn> @where exercises
11:16:53 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
11:16:57 <RedNifre> No, wait... hm...
11:17:05 <mauke> http://www.spoj.com/
11:17:07 <klugez> RedNifre: Using :: after an expression says that that expression is of that type.
11:17:41 <etairi> A quick question, is there any place where I can find the complete BNF structure of the latest version of Haskell language?
11:17:43 <Oded> Thanks, but I prefer actual programs rather than to write functions..
11:17:52 <recursion-ninja> merijn: I got a warning from cabal configure about version mismatches, it initially compiled until I moved forward in development and started using ByteStrings with Codec.Archive.Zip
11:17:56 <merijn> etairi: The Haskell 2010 report?
11:18:09 <fread2282> RedNifre: :: tells GHC what type you want. if you have a typeclass, it will try to pick that type. if you have a concrete type it will error if it's the wrong type
11:18:12 <klugez> RedNifre: That may then also nail down the type class instance to be used, but you could put any type after any expression.
11:18:17 <merijn> recursion-ninja: Can you rerun configure and see what the error was
11:18:28 <RedNifre> I think I get it now. I was thinking too object oriented.
11:18:30 <klugez> Of course if you put a type that doesn't make sense, GHC will complain.
11:18:40 <recursion-ninja> package HDBC-2.4.0.0 requires bytestring-0.10.4.0
11:18:40 <recursion-ninja> package unix-2.5.1.0 requires bytestring-0.9.2.1
11:19:17 <klugez> RedNifre: Instead of using :: there might be some other way the variable is used that means it is Integer and then using :: Integer would not be necessary.
11:19:56 <RedNifre> Instead of (fromSql foo :: Integer) meaning "I want the fromSql function that is in the FromSql instance of Integer" it means "I want any fromSql function that when applied to foo results in an Integer and it so happens that only the one in the FromSql instance of Integer matches".
11:20:05 <etairi> I saw the Haskell report, but it defines different parts in different pages, is there a place to find all of it in one place?
11:20:22 <merijn> recursion-ninja: You have several options 1) try --allow-newer and cross fingers everything works 2) change your dependencies to require an older version of HDBC or newer version of unix, so that they both accept the same bytestring 3) manually relax the constraints on unix and submit a patch with fix to its maintainer
11:20:25 <RedNifre> Is that correct?
11:20:44 <joneshf-laptop> in my `.ghci` file I've done `:m - Prelude` and `:m + Data.Traversable`, but when I load up ghci and type in `:t sequence` it still cannot disambiguate between `Prelude.sequence` and `Data.Traversable.sequence`. Is there any way around that?
11:20:57 <recursion-ninja> merijn:  why does unix package require bytestring (>=0.9.2.0 && <0.10)? Why can't it use byteString-0.10.4.0
11:21:09 <merijn> joneshf-laptop: You need -XNoImplicitPrelude to not import Prelude
11:21:15 <fread2282> joneshf-laptop: :set -XNoImplicitPrelude ?
11:21:38 <fread2282> RedNifre: yes
11:21:43 <martinhath> :window tba
11:21:44 <joneshf-laptop> merijn, fread2282 awesome, thanks!
11:21:59 <merijn> recursion-ninja: Maybe the interface of bytestring changed and here's no new unix version yet? Or maybe because the maintainer hasn't tested 10.4 to work?
11:22:43 <recursion-ninja> merijn: use --allow-never in what context? in cabal configure, cabal build, .cabal file?
11:24:04 <merijn> recursion-ninja: Although you're better of trying to use a version of HDBC that accept an older bytestring
11:24:12 <dreams> A supercombinator is just a function without local definitions right?
11:24:37 <merijn> recursion-ninja: In the context of --allow-newer, yes
11:25:28 <merijn> recursion-ninja: eh, I meant "cabal configure", that's what I get for IRCing early morning
11:26:06 <recursion-ninja> merijn: thanks for the ideas, times like these makes me wish cabal was a package manager...
11:26:40 <merijn> recursion-ninja: The problem here is not "cabal is not a package manager", but lack of manpower
11:26:58 <merijn> recursion-ninja: Linux package managers solve these problems by having 100s of volunteers curate their database manually
11:27:13 <freeman42> mauke, are you certain the variables are for building ghc and not building libraries with ghc? from the description I understood that it is for the libraries built with ghc https://ghc.haskell.org/trac/ghc/wiki/DynamicGhcPrograms was hoping it might fix this bug: https://ghc.haskell.org/trac/ghc/ticket/7103
11:27:33 <recursion-ninja> merijn: I'm going to try and update unix to a newer version which allows the newer version of bytestring
11:27:59 <merijn> recursion-ninja: Also try #hackage, I'm not entirely sure where the bytestring bounds you have are coming from
11:28:10 <merijn> recursion-ninja: hdbc-2.4 claims to work with any version of bytestring
11:29:21 <Kron> for the purpose of handling function privacy versus testing internals using external testing modules
11:29:39 <Kron> is the idiomatic solution to split your files into an internals module and an externals one for publishing?
11:29:49 <mauke> freeman42: well, that's what it says: "This is controlled by the DYNAMIC_GHC_PROGRAMS build system variable. If it is YES, then we build ghci the dynamic way."
11:29:50 <Kron> or is there are more low level language trick to this
11:29:58 <mauke> freeman42: I see nothing about libraries
11:30:27 <recursion-ninja> merijn: installing unix-2.7.0.1 appears to be going well...
11:31:03 <freeman42> mauke, ah, I see what you mean
11:31:09 * hackagebot idris 0.9.14.3 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14.3 (CarterSchonwald)
11:31:11 * hackagebot engine-io 1.2.0 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.0 (OliverCharles)
11:32:41 <moldy> i would like to get my feet wet by writing a pretty simple database (sql) application. which tools/libraries do you recommend?
11:38:35 <RedNifre> moldy I use HDBi, which is very low level.
11:38:48 <RedNifre> It comes with several db drivers so I use sqlite
11:39:16 <RedNifre> You perform a query as a String and get back [[SqlValue]] -- these are the rows of the result
11:39:44 <moldy> i think i'd like to have something more high-level. is there anything that is considered to be a de facto standard or best of breed?
11:40:11 <RedNifre> There is a lot, like acid, peristence, esquelento, conduit, pipes and many more.
11:40:33 <RedNifre> I postponed looking at those for now though.
11:41:34 <moldy> yes, the fact that there are so many is precisely my problem
11:41:57 <recursion-ninja> merijn: is there a way to recomiplie HDBC and specify it to link to bytestring 0.9 ?
11:42:27 <RedNifre> That's the problem I had. It was too demotivating for me so I chose the simple bare bone solution for now.
11:42:47 <merijn> recursion-ninja: "ghc-pkg unregister HDBC", there's a flag to pass constraints to cabal, but I forget, check the docs
11:42:48 <RedNifre> It really depends on what you want to do. If it is purely about learning you should probably look at ALL of them.
11:43:37 <moldy> well, i wrote above what i want to do :)
11:44:07 <recursion-ninja> merijn: thanks for all the directions on resolving the cabal issues :)
11:47:34 <RedNifre> What exactly is meant by "record"? The way I understand it "data" declares a type and the type constructors are used to create type instances. So what does "record" refer to?
11:49:16 <Kron> is it a good idea to split your code into external and internals modules for unit testing?
11:49:38 <moldy> RedNifre: as far as i understand it, it's the same. it's just written in a different syntax that gives you some extra niceties.
11:49:42 <Oded_> Is there unit testing in Haskell?
11:49:58 <merijn> Kron: Yes, no, maybe.
11:49:58 <jmcarthur> RedNifre: data declares an algebraic data type. a record is a data type with labeled fields.
11:49:58 <Kron> cabal testing
11:50:06 <Gurkenglas> Where's lambdabot?
11:50:15 <fread2282> Oded_: yes, HUnit, but QuickCheck is usually better
11:50:21 <Kron> I'm just wondering if there's some standard or idiomatic solution
11:50:22 <Oded_> cool.
11:50:28 <Kron> i'm using quickcheck myself
11:50:30 <RedNifre> Ah, I see.
11:50:36 <Kron> I just mean "unit testing" in the vague sense of the word
11:50:46 <jmcarthur> RedNifre: a type constructor is like a normal (value) constructor, but at the level of types. for example, Maybe is a type constructor that takes one argument
11:50:48 <Kron> I'm trying to build a quickcheck property testing suite but I can't access the internals of my libraries
11:50:59 <Kron> so... split the libraries? or is there a better solution
11:51:09 * hackagebot dynamic-state 0.1.0.4 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.4 (fread2281)
11:51:16 <RedNifre> Ah, then I meant value constructor.
11:51:20 <Oded_> Any IDE recommendation for Haskell?
11:51:33 <Kron> emacs
11:51:49 <thoughtpolice> Kron: many people always just make the internal modules visible, and say "If you use this, and it breaks, you asked for it." which I think is reasonable
11:51:54 <Kron> emacs is pretty much the best IDE I know of for haskell, but I'm an emacs user so I'm biased. haskell mode
11:51:55 <J_Arcane> Emacs does seem to be the most tolerable option.
11:51:56 <Kron> alright
11:51:58 <recursion-ninja> leksah is alright, it handles most cabal stuff for you
11:52:03 <Oded_> Anyone tried TDD with Haskell?
11:52:27 <recursion-ninja> Oded_: leksah is alright, it handles most cabal stuff for you
11:52:34 <jmcarthur> RedNifre: a constructor doesn't create type instances. it creates values.
11:52:41 <recursion-ninja> Oded_: not tried TDD
11:52:57 <jmcarthur> RedNifre: for example,  Just  can be thought of as a function that takes some existing value of type A and produces a value of type Maybe A
11:53:09 <sivteck> Hspec is a testing framework for haskell http://hspec.github.io/ and its nice ;p
11:53:18 <jmcarthur> RedNifre: (and constructors can also be used in pattern matching)
11:53:30 <recursion-ninja> Oded_: I tried to try TDD while using Haskell, but just found the compiler & well-typed system made it unessisary
11:53:47 <Gurkenglas> > "It's just my query that's broken."
11:53:57 <Gurkenglas> :(
11:53:58 <Oded_> Okay thanks.
11:54:08 <jmcarthur> lambdabot seems to be absent right now
11:54:14 <RedNifre> "a record is a data type with labeled fields"... I thought the value constructors had labeled fields? What exactly is meant by "data type" here? Is it the whole bag (Maybe + Just + Nothing) or is it only about a value?
11:54:17 <Oded_> He is tired
11:54:39 <jmcarthur> RedNifre: a data type is just a type defined using the data keyword
11:54:51 <jmcarthur> RedNifre: in a data type, a field is an argument of a constructor
11:55:10 <jmcarthur> RedNifre: here is an example of a record:     data Foo = Bar { baz :: Int, wibble :: String }
11:55:16 <Oded_> Anyone learned Category theory for Haskell? It seems quite interesting..
11:55:17 <jmcarthur> RedNifre: the labels are baz and wibble
11:55:19 <RedNifre> Ah, so "field in a data type" means "field in any of the constructors of that data type"?
11:55:33 <benzrf> jmcarthur: wibblewibble
11:55:38 <benzrf> Oded_: oh yes very
11:55:41 <benzrf> Oded_: how much ct you know?
11:55:47 <Oded_> I want to learn
11:55:56 <jmcarthur> RedNifre: baz and wibble are the fields (' labels), where the fields have types Int and String
11:55:56 <Oded_> Can you refer me to a good resource?
11:55:58 <benzrf> Oded_: do you know abstract algebra?
11:56:08 <benzrf> '
11:56:14 <Oded_> A little yes.
11:56:15 <benzrf> > "test"
11:56:16 <RedNifre> Or can you put fields directly in the data type, which get inherited by all values, e.g. data Foo { key :: String } = Bar { name :: String}
11:56:18 <benzrf> Oded_: how much ?
11:56:22 <benzrf> @ping
11:56:27 <benzrf> lambdabot nooo
11:56:45 <jmcarthur> RedNifre: i don't understand the question, but your use of the word "inherited" seems suspicious
11:56:45 <Oded_> I know Set theory on the average level(sorry if my English is bad, not my primary language)
11:57:04 <benzrf> Oded_: ok cool
11:57:05 <Oded_> And calculus a little too, and linear algebra a little too.
11:57:12 <benzrf> Oded_: you know what a monoid is, right?
11:57:15 <Oded_> Yes
11:57:19 <benzrf> how about a group
11:57:23 <Oded_> also
11:57:33 <RedNifre> Different values of the same data type can have different fields, right?
11:57:34 <benzrf> and i assume you're familiar with monoid & group homomorphisms?
11:57:39 <benzrf> RedNifre: most certainly
11:57:44 <benzrf> RedNifre: look at Maybe
11:57:44 <jmcarthur> RedNifre: you mean different constructors?
11:57:54 <RedNifre> Does "data type" mean "type" or "value"?
11:58:01 <benzrf> RedNifre: type
11:58:15 <jmcarthur> RedNifre: they can, yes, although i discourage using record syntax for data types having multiple constructors unless they all have the same fields anyway
11:58:24 <RedNifre> Then the way I see it only values can have fields, not types.
11:58:29 <benzrf> RedNifre: yes
11:58:31 <Oded_> no... I just know the definitions of group and monoid. I havent studied the theory of them. What's homomorphism?
11:58:37 <benzrf> Oded_: ah
11:58:43 <jmcarthur> RedNifre: the data type specifies what fields the values can have
11:58:45 <benzrf> Oded_: this kind of thing is important to know for things like CT
11:58:50 <jmcarthur> RedNifre: that is the sense in which data types "have fields"
11:59:08 <RedNifre> Okay, then it was only a missunderstanding of semantics.
11:59:12 <Oded_> So what do you suggest me to learn before CT?
11:59:15 <benzrf> Oded_: basically a homomorphism is a mapping between two structures that somehow preserves the meaning of each element as part of the structure
11:59:28 <Oded_> Yea I'v seen couple of videos about CT.
11:59:39 <benzrf> Oded_: so a monoid homomorphism maps elements of one monoid to elements of anothre, but in a way that respects how each element acts as part of a monoid
11:59:40 <mjrosenb> AAAHHHAHAHAH, I have installed grapefruit-ui
11:59:41 <RedNifre> Unless one uses your convention of using the same fields in all constructors, then I'd be fine saying that the type itself has those fields.
11:59:52 <mjrosenb> that was only like two weeks of effort.
11:59:57 <Oded_> Okay.
12:00:06 <mjrosenb> well, two weekends worth of effort.
12:00:30 <recursion-ninja> merijn: it's    cabal install package --constraint=other-package==1.2.3.4
12:00:41 <RedNifre> so in the source code "data" means "type", "type" means "type synonym" and "newtype" means "type synonym that you can't use as a synonym", right?
12:00:44 <recursion-ninja> merijn: everything is working now, thanks for the assistance
12:01:03 <Oded_> Im familiar also with the definition of Category and Functor, but that's all of it. I really need to practice and get a better source to my CT learning.
12:01:31 <benzrf> Oded_: well, functors are basically category homomorphisms
12:01:33 <Kron> how do you import local modules?
12:01:39 <Kron> elsewhere in a cabal package
12:01:52 <benzrf> Oded_: categories are like generalized monoids
12:02:32 <fread2282> categories are monoidoids :P
12:03:13 <Oded_> I though of Categories like a generalized aspect or tool to analyze mathematical structures
12:03:35 <benzrf> Oded_: well think about it
12:03:59 <benzrf> Oded_: a category defines an associative operation on a set of values (morphisms) and some identity elements
12:04:11 <stulli> Kron: with sandboxes you can do cabal sandbox add-source <localpathtocabalpackage>
12:04:22 <benzrf> Oded_: the only difference is that the operation is partial and you have objects to tell which pairs of morphisms the operation is defined on
12:04:52 <benzrf> Oded_: in fact, since the operation for a category with only one object is defined on any pair and has only one identity, it IS a monoid
12:04:54 <Kron> I mean, inside the the package itself
12:05:00 <recursion-ninja> Doe you guys know how to resolve the following type-error:
12:05:01 <recursion-ninja> Couldn't match expected type `B.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'
12:05:03 <Kron> not local in my machine, multiple files in a single cabal package
12:05:10 <Kron> I don't know how to import them on a haskell source code level
12:05:15 <recursion-ninja> I don't know how to specify the strict bytestrings
12:05:17 <Oded_> Cool. And what can I do with categories?
12:05:25 <merijn> recursion-ninja: Mixing lazy and strict bytestrings?
12:06:09 <recursion-ninja> meijn: I only use them in one spot so far, so I think it is an import problem...~
12:06:10 <Oded_> I cant quite understand mathematiclly the Monad. but programming-language-ly I do.
12:06:34 <Kron> ah, without the qualification. I see
12:07:07 <Oded_> I understand Monad as a way to get through the laziness and stuff to do functions which are "non pure functional" in a pure-functional language.
12:07:09 <recursion-ninja> meijn: import qualified Data.ByteString as B <-- is that lazy bytestrings?
12:07:18 <recursion-ninja> merijn: import qualified Data.ByteString as B <-- is that lazy bytestrings?
12:07:21 <Oded_> but in terms of category theory, what's a Monad?
12:07:37 <merijn> recursion-ninja: No, that's strict, try "Data.ByteString.Lazy"
12:09:34 <recursion-ninja> merijn: Got it! I feel dumb about that question. I haven't used ByteStrings in a while and forgot thte interfaces...
12:10:07 <Oded_> benzrf are you here?
12:11:01 <benzrf> yep
12:11:23 <benzrf> Oded_: monads in category theory are defined in terms of join rather than in terms of bind
12:13:17 <Oded_> Yea. but what exacly is the purpose of Monads in CT? I understand the purpose in Haskell, but not in Math.
12:13:34 <Oded_> And I can bet that the idea came from CT to Haskell
12:15:05 * earthy nods
12:15:06 <benzrf> Oded_: im not sure what the /purpose/ is
12:15:11 <recursion-ninja> Oded_: In Math, monads are used by PhD students to develope thier thesis (only kidding)
12:15:12 <benzrf> Oded_: collapsible functors i guess
12:15:25 <benzrf> just like in hakslel
12:16:11 * hackagebot dynamic-state 0.1.0.5 - Optionally serializable dynamic state keyed by type  http://hackage.haskell.org/package/dynamic-state-0.1.0.5 (fread2281)
12:16:22 <earthy> Oded_: http://books.google.nl/books?id=MXboNPdTv7QC&pg=PA138&lpg=PA138&dq=%22monoid+in+the+category+of+endofunctors%22+mac+lane&source=bl&ots=feQWTkH2Uw&sig=tv-1JwaMOygKGmFE2vM2FhJVS9o&hl=en&ei=5iWsTJCkBIPSsAPQwJ36Aw&sa=X&oi=book_result&ct=result&redir_esc=y#v=onepage&q=%22monoid%20in%20the%20category%20of%20endofunctors%22%20mac%20lane&f=false
12:16:29 <earthy> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
12:17:38 <Oded_> Thanks. but what is a functor composition?
12:18:03 <Oded_> Oh I saw that book earlier, I wonder if I should read it.
12:18:12 <RedNifre> > '?':(concat $ fmap (const ",?") [1..4])
12:19:16 <RedNifre> Is there a more elegant way to create "?,?,?,?"? I mean a string that has x many questionmarks with commas in between?
12:19:33 <Kron> If I tell my quadtree library to "import QTInternals" it can find the other file QTInternals.hs in the same folder, but cabal can't find it at all
12:19:36 <RedNifre> In ruby you could do "?,"*4 + "?"
12:19:37 <joelteon> '?' : repeat 4 ",?"
12:19:48 <Kron> if I tell it to "import Data.QTInternals" then cabal can find it but my source code can't find it
12:19:53 <RedNifre> ah, thanks.
12:20:00 <joelteon> assuming that typechecks
12:20:01 <Oded_> The composition of functors is just applying both functors one after the another?
12:20:11 <Kron> is there any way to tell cabal that the package is not in the same directory as the .cbal file without using a Folder.Name format?
12:20:18 <joelteon> oh, lambdabot is gone
12:20:20 <joelteon> that doesn't help
12:20:44 <joelteon> sorry RedNifre, i advised you wrongly
12:21:07 <joelteon> RedNifre: '?' : concat (replicate 4 ",?")
12:21:08 <RedNifre> yeah, it's take 4 repeat ",?", but that's fine
12:21:11 * hackagebot engine-io-snap 1.0.2 -   http://hackage.haskell.org/package/engine-io-snap-1.0.2 (OliverCharles)
12:21:13 * hackagebot tasty 0.10.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.0.1 (RomanCheplyaka)
12:21:14 <RedNifre> even better!
12:21:15 * hackagebot socket-io 1.1.1 -   http://hackage.haskell.org/package/socket-io-1.1.1 (OliverCharles)
12:21:40 <mauke> > intersperse ',' (replicate 4 "?")
12:22:23 <RedNifre> I wish lambdabot were here to see this!
12:22:28 <joelteon> mine is shorter!
12:23:07 <Oded_> I think I understand.
12:23:19 <RedNifre> Well, the parameter would be the number of questionmarks so yours would be '?' : concat (replicate x - 1 ",?" ), which is not that nice.
12:23:25 <Oded_> A monad is just a monoid but instead of function there a functor.
12:23:26 <nitrix> Who runs lambdabot?
12:23:30 <Oded_> there is *
12:23:37 <nitrix> Shouldn't it be 24/7 active?
12:23:50 <hexagoxel> lambdabot's sleeping?
12:23:53 <RedNifre> maybe it's just somebody who executes haskell in his head?
12:23:58 <merijn> "functor composition" -> "Yo dawg, we heard you like functors, so we put a functor in your functor, so you can fmap while you fmap!"
12:25:04 <benzrf> :-0
12:25:17 <Oded_> So basicly a Monad is a Monoid but with functor instead of function and category instead of set.
12:25:20 <Oded_> mmm.
12:25:24 <Oded_> lol merijn
12:25:25 <RedNifre> And it's actually intersperse ',' $ replicate 4 '?'
12:26:56 <benzrf> Oded_: no not reallyy
12:27:26 <benzrf> Oded_: a monad is a categorical monoid where the category the object is in is a category of endofunctors
12:27:35 <benzrf> and the associated bifunctor is functor composition
12:29:51 <benzrf> hmmmmmmmmm
12:30:04 <benzrf> i'm trying to think about what a group in a category of endofunctors with compo would look like
12:30:22 <benzrf> although i guess strictly that doesn't really work because composition isnt a product
12:30:25 <benzrf> ...i dont think
12:30:48 <Oded__> me too lol
12:31:23 <Oded__> So the two natural transformations just tell you what morphisms you got in the Monad?
12:31:33 <benzrf> huh?
12:31:36 <benzrf> oh
12:32:57 <benzrf> Oded_: for some endofunctor F
12:33:00 <benzrf> a monad is
12:33:21 <benzrf> (F, η, μ)
12:33:23 <benzrf> where
12:33:31 <benzrf> η : F ◦ F -> F
12:33:34 <benzrf> no wait der
12:33:43 <benzrf> η : Id -> F
12:33:48 <benzrf> μ : F ◦ F -> F
12:33:54 <benzrf> aka return and join
12:34:09 <benzrf> look: http://www.haskell.org/haskellwiki/Category_theory/Monads
12:36:50 <RedNifre> hm. If I have a class Named name :: String and a function get :: Named a => a, how can the function get the name of a? Does Haskell have type erasure?
12:37:11 <Oded__> So if I imagine the Monad as a category, its a category whose objects are all the endofunctors on C and the morphisms in that category are the natual transformations η μ
12:37:12 <RedNifre> (the function signature might be wrong)
12:38:33 <RedNifre> I guess both the name and the get function would need a value constructor as a parameter, right?
12:38:40 <Oded__> So for every endofunctors on C, I got the two natural transformations , and those three form a Monad?
12:38:52 <RedNifre> or a type, i guess
12:38:53 <Oded__> C of course is a category.
12:40:08 <mauke> RedNifre: what does your class look like?
12:40:13 <RedNifre> Is there something like Maybe.class, or do you pattern match with (Maybe)? How to use types as parameters?
12:40:24 <mauke> ??
12:40:34 <Oded__> I'll try to write some examples of Monads and perhaps I'll understand it more naturaly.
12:40:36 <RedNifre> It doesn't look like anything yet, since I'm still thinking how to do it.
12:40:42 <mauke> RedNifre: do what?
12:40:44 <Oded__> Anyway thanks a lot benzrf
12:40:45 <Oded__> :)
12:40:52 <Oded__> I must go now, bye bye.
12:40:55 <Oded__> Good night.
12:41:50 <RedNifre> Well, there are some types and each of them has a String constant associated with it. Then there's a function which doesn't know the types, but it needs to get the string
12:42:08 <mauke> you could introduce a dummy value parameter
12:42:19 <RedNifre> with the string it then has the paramaters to call a function of that type.
12:42:19 <mauke> class Named a where name :: a -> String
12:42:19 <benzrf> hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm................................
12:42:26 <monochrom> there is no Maybe.class. Just and Nothing are not subclasses. use pattern matching or the "maybe" function or their derivatives. however, the "maybe" function just makes pattern matching look like passing and using functions.
12:42:53 <RedNifre> no, I can't do pattern matching with specific types or values.
12:43:15 <benzrf> @djinn a -> Maybe a -> a
12:43:23 <benzrf> oh :(
12:43:38 <RedNifre> But that is what I was asking, I guess I have to go with name :: a -> String to differentiate the concrete name functions.
12:43:42 <mauke> fromMaybe
12:44:33 <fread2282> RedNifre: name :: Proxy a -> String ?
12:44:34 <fread2282> from Data.Proxy
12:44:47 <mauke> or even: proxy a -> String
12:45:59 <RedNifre> how would the get function look then? get ??? = name ???
12:46:21 <mauke> what get function?
12:46:39 <monochrom> do you need two functions, "get" and "name"? or do you just need one of them? are they different? must they be different?
12:48:09 <RedNifre> yes, "get" needs the string associated with what it wants to return because it needs the string to retrieve the parameters needed to call the instantiation function of what it wants to return
12:48:30 <RedNifre> name is the table name of the database associated with the value
12:48:50 <fread2282> RedNifre: haskell has type erasure. you can't disable it
12:49:24 <RedNifre> That's why I was asking about classes. In Java you can get around this by passing a class as a parameter.
12:49:27 <monochrom> sorry, what is "it"?
12:50:03 <fread2282> RedNifre: what are you trying to do?
12:50:04 <RedNifre> "it" is an unknow record that has two instances, one to get the name and one to create the value from [SqlValue]
12:50:21 <merijn> RedNifre: There is no such thing as "a record that has two instances"
12:50:33 <monochrom> at the big-picture level, I'm sure all you need is design your own type class and write a bunch of suitable instances.
12:50:57 <RedNifre> That's what I did, now I wonder how to call the function with it.
12:51:12 * hackagebot boomange 0.1.0.0 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.0.0 (mgmillani)
12:51:46 <RedNifre> But I guess I should read more about Proxy, this might be what I need here.
12:51:52 <monochrom> at the detailed level, I think your attempt at explaining in natural language has failed (I don't understand your wording), and it's time to show concrete code.
12:54:21 <fread2282> RedNifre: there is *NO* way to get around type erasure in haskell
12:54:22 <RedNifre> Say you have a BankStatement = BankStatement Integer and it is in the table "bankStatement" and you have instance DBTable BankStatement where table = "bankStatement" and you have instance FromSqlRow BankStatement where fromSqlRow [i] = BankStatement i
12:56:04 <RedNifre> So I guess the way to get around type erasure in haskell is the same as in java, using a dummy argument where fromSqlRow :: BankStatementDummy -> [i] -> BankStatement
12:56:24 <RedNifre> Ah, that code is a little wrong, it originally was fromSqlRow [i] = BankStatement $ fromSqlValue i
12:56:40 <fread2282> RedNifre: what's FromSqlRow?
12:57:13 <RedNifre> My own type class with a function fromSqlRow :: [SqlValue] -> a
12:58:43 <fread2282> RedNifre: what are trying to do?
12:59:42 <RedNifre> Well, in Java you get around erasure like this: <T extends FromSqlRow> T get(Class<T> value, blabla), the trick here is that you pass the class of the return type as a parameter so erasure doesn't matter any more. It's just a single method, but with varying return types.
12:59:59 <RedNifre> Ah, I guess it's impossible in Haskell to have one function have different return types, huh?
13:00:10 <hape> you can take tuples
13:00:20 <hape> to carry multiple components in it
13:00:42 <fread2282> RedNifre: typeclasses allow you to have multiple return types, but a function can't decide it's return type
13:00:54 <hape> return a tuple
13:01:07 <RedNifre> I can't return a tuple, it only returns one value.
13:01:25 <hape> if you want return two values return a tuple
13:01:41 <RedNifre> I don't want to return two values
13:01:54 <hape> i see
13:01:58 <omefire_> Hi all !
13:02:08 <RedNifre> Guess I need to pastebin this. One sec...
13:02:22 <omefire_> I am interested in contributing to the ghc code. However, I am struggling with the ability to step trough/debug the code with the help of a debugger.
13:02:47 <omefire_> can anyone point me in the right direction ?
13:04:07 <omefire_> when I try to load the ghc entry point (ghc/Main.hs) into ghci, I get the following error messages :  " "Could not find module 'GHC'. It is a member of the hidden package 'ghc-7.9.20141001'. Use -v to see a list of the files searched for." "
13:06:43 <tippenein> when trying to cabal install cabal-install I get this error: Could not find module `Text.ParserCombinators.Parsec'
13:06:52 <tippenein> Network/URI
13:09:16 <RedNifre> Could someone explain Proxy?
13:13:03 <mauke> data Proxy a = Proxy
13:16:47 <fread2282> RedNifre: Proxy is a way of specifing a type without having an actual value. it was created to replace (undefined :: a) with (Proxy :: Proxy a), and has 2 main uses: typeclass dispatch, so you can make a typeclass that chooses it's instance based on the Proxy type you give it, and Typeable
13:17:36 <fread2282> Typeable is mainly for serealization and casting
13:19:09 <fread2282> actually, it's use with typeable is just for typeclass dispatch
13:20:04 <fread2282> you can think of Proxy+typeclass like `Proxy a -> Whatever` as a function `Type -> Whatever`
13:20:23 <fread2282> so Whatever can depend on what Type is
13:21:08 <merijn> omefire_: Why are you using ghc 7.9?
13:21:18 <merijn> oh, hacking, nvm me :)
13:21:29 <omefire_> nvm ?
13:21:34 <fread2282> off topic: typeclasses can simplate typecase?!
13:21:34 <merijn> nevermind :)
13:21:37 <fread2282> wow
13:21:38 <omefire_> oooh, never mind me.
13:22:04 <omefire_> I use 7.9 becoz I'm playing around with the source code
13:22:13 <RedNifre> Okay... So if I have Proxy Whatever, how can I call an instance function that is associated with Whatever?
13:22:16 <merijn> omefire_: Are you trying to load it into 7.9 ghci or into 7.8?
13:22:43 <fread2282> RedNifre: `function (Proxy :: Proxy Whatever)`
13:23:00 <omefire_> merijn: ghci 7.6.3
13:23:50 <fread2282> RedNifre: assuming function :: SomeClass a => Proxy a -> Something
13:24:03 <merijn> omefire_: I'm not sure that can work, main is trying to use the ghc-7.9 library, which is not available in the package database of older ghc's :)
13:24:18 <merijn> omefire_: Try loading it into 7.9 ghci?
13:25:51 <RedNifre> So like getName :: Proxy Named a => a -> String     getName a = name a         class Named a where name :: Proxy a -> String      instance Named Bob where name Proxy Bob = "Bob"
13:26:28 <RedNifre> Is that what you mean?
13:27:20 <fread2282> RedNifre: getName :: Named a => Proxy a -> String, getName a = name a, class Named a where name :: Proxy a -> String, instance Named Bob where name Proxy = "Bob"
13:27:33 <fread2282> RedNifre: or you can just use name in place of getName
13:27:41 <fread2282> name :: Named a => Proxy a -> String
13:27:43 <merijn> I don't suppose there's a portable (i.e. both window and unix) way of sending a signal to a process?
13:29:00 <trap_exit> step 1: read LYAH, RWH, step 2: ???, step 3: become super sayan like edwardk -- what is step 2 ?
13:29:08 <RedNifre> It's actually getSomethingRelatedToName a = lookUpSomething $ name a, so I can't just use name.
13:29:21 <fread2282> trap_exit: learn Category Theory
13:29:22 <merijn> trap_exit: Writing lots of code :)
13:29:28 <merijn> fread2282: Not really
13:29:39 <merijn> Category Theory is pretty useless for practical haskell hacking
13:29:45 <fread2282> merijn: for edwardk
13:29:54 <omefire_> merijn: I was actually using ghci 7.9.20141001
13:30:15 <trap_exit> merijn: is lots of code defined as 50% of hackage
13:30:24 <trap_exit> are there any live casts of how pro haskellers code?
13:30:31 <trap_exit> I'd love to just spend an hour or two watch how they code
13:30:43 <trap_exit> creepy sounding, but I want to see their mental process
13:30:49 <omefire_> still erroring. from what I was told, it's because the source code files/folders don't really mirror the modules being imported.
13:31:19 <merijn> trap_exit: Naah, but the important thing is to just start hacking
13:31:29 <merijn> trap_exit: Extend pandoc, xmonad or something
13:31:58 <merijn> (I feel both of those are pretty hackable code bases and will give you something that's practical and usable in terms of results)
13:34:11 <trap_exit> oh
13:34:16 <trap_exit> I have an existing code base to hack on
13:34:20 <trap_exit> this theorem prover I'm working on
13:35:05 <RedNifre> Hm, I don't understand why it's "where name Proxy = "Bob""... where did the "a" after Proxy go?
13:36:18 <dnkndnts> ^^ i second the wish for skilled programmers to livestream sometimes. i feel like you can only improve so much by trying things in your own little bubble -- it really does help to see how skilled people think.
13:39:58 <eikke> RedNifre: 'Proxy a' is the type, 'Proxy' is a 'value'
13:40:17 <moldy> i am finding that reading *both* learnyouahaskell and realworldhaskell seems to be great way to learn
13:40:36 <moldy> a great way, even
13:41:02 <merijn> dnkndnts, trap_exit: Might wanna look into reading Okasaki and Functional Pearls
13:41:15 * hackagebot btrfs 0.1.1.1 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.1.1.1 (MariosTitas)
13:41:32 <trap_exit> merijn: nah, reading more is like reading about how to do hand to hand combat
13:41:49 <trap_exit> the time is to put down the books and fire up emacs
13:42:12 <merijn> trap_exit: Those books really open your eyes to neat functional tricks. But yes, hacking more code is good too
13:42:57 <moldy> RedNifre: alot of haskell code re-uses the name of a type constructor for a value constructor, which is quite confusing for a beginner.
13:43:21 <dnkndnts> i've gone through LYAH, and it's definitely one of the best language tutorials i've ever seen; but still, i certainly don't feel like a "pro" now. i feel like i know the difference between zerg and terran, and know how to right click to move my marines around, but do i feel like an OGN champion? absolutely not.
13:43:49 <dnkndnts> sometimes it's nice to actually watch a pro, not just read through another guide or tutorial.
13:43:55 <RedNifre> So "Proxy" can be used as a value no matter which actual Proxy a type you have, similar to how [] can be used no matter what type of list is needed?
13:43:59 <osfameron> OGN?
13:44:13 <mauke> RedNifre: yes
13:44:14 <merijn> dnkndnts: Oh, agreed, there's a fairly big gap between "finished LYAH" and "know how to hack effectively"
13:44:20 <merijn> dnkndnts: Have you read Real World Haskell?
13:44:57 <trap_exit> dnkdnts: when you finish RWH, you'll learn about Protoss :-)
13:44:59 <moldy> RedNifre: i suggest you read the "Naming types and values" section here: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
13:45:08 <dnkndnts> no, i haven't looked at it. is it where i should go next after LYAH?
13:45:24 <merijn> dnkndnts: You can skip the first 5-6 chapters (and even some later ones), it's basically LYAH
13:45:43 <merijn> dnkndnts: But there's several practical chapters explaining how to design libraries/use them
13:45:50 <Eliel> dnkndnts: the biggest problem with experienced haskell programmer livestreaming about programming is that a beginner would most likely not understand half the concepts required to even begin to try to understand the thinking.
13:45:57 <moldy> dnkndnts: as a fellow beginner, i find it extremly efficient to read *both*
13:46:17 <merijn> dnkndnts: A number of code snippets have bitrotted because of API changes, but I'd argue the overall ideas still hold
13:46:50 <dnkndnts> Eliel: yes, but i don't understand all of what the OGN champs do, either; that doesn't mean watching them isn't extremely helpful in terms of seeing what mistakes I make and where I should improve.
13:46:52 <merijn> dnkndnts: i.e. the parsec chapter snippets don't work as-is anymore, but having read the parsec chapter diving into the Parsec API docs should be easy because the fundamental design of parsec hasn't really changed
13:47:37 <moldy> dnkndnts: rwh explains things differently. possibly less deeply, but alot more approachably.
13:48:11 <moldy> i find going back and forth between to two to be really helpful
13:49:24 <merijn> No one knows how to signal like things on windows? There has to be some form of IPC...
13:49:47 <dnkndnts> it's not... approachability that's necessarily the problem. it's becoming fluent in concepts by watching how others use them. for example -- project euler problem #5: i fumbled around like a blind beggar writing 30+ lines of unreadable nonsense,
13:50:06 <dnkndnts> then all of a sudden, it struck me... foldr1 lcm [1..20]. that's it. that's the entire solution.
13:50:06 <moldy> merijn: it should work similiar to unix
13:50:27 <dnkndnts> and it scared me when i saw that how much i was missing in the mess of spaghetti i had written over the past 3 hours:
13:50:43 <dnkndnts> what about all the times i write code and *don't* see the obvious solution?
13:51:04 <moldy> dnkndnts: that only comes by experience
13:51:04 <merijn> dnkndnts: Project Euler is pretty terrible for practicing
13:51:15 * hackagebot conceit 0.1.0.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.1.0.0 (DanielDiazCarrete)
13:51:24 <merijn> dnkndnts: It encourages code gulfing and faffing about with stuff that doesn't matter for practical programs
13:51:27 <cristian1> merijn: what do you recommend instead of Project Euler?
13:51:34 <dnkndnts> experience, yes, but don't make the mistake of thinking the experience must be your own:
13:51:37 <trap_exit> a good started prject
13:51:40 <moldy> dnkndnts: it typically takes alot of time to become "fluent" in any language. the point of tutorials is to get you to a point where you can start gathering experience.
13:51:41 <trap_exit> for haskell is probably a compiler
13:51:44 <dnkndnts> learning from others' experience is much faster than making all the mistakes yourself.
13:52:03 <moldy> dnkndnts: it must be your own. practical software development is a craft, not a science.
13:52:38 <moldy> dnkndnts: the experience of others can provide some shortcuts, but you must make your own.
13:52:43 <merijn> moldy: You say that, but I don't see any API for it
13:52:57 <merijn> moldy: (a windows API for signals, that is)
13:53:07 <merijn> @where exercises
13:53:14 <merijn> Ah, bah
13:53:17 <merijn> No lambdabot
13:53:23 <dnkndnts> no, i disagree. no matter how much i sit in my basement and practice starcraft alone, i will never achieve anything close to what i could achieve were i benefitting from the collective experience of watching and participating with other skilled players. collective experience is incredibly valuable in acquiring any skill.
13:53:27 <merijn> cristian1: Anyway, lambdabot has a list of reddits with examples
13:55:09 <yitz> merijn: is lispy still running lambdabot? if he is, sometimes the vm just needs a reboot.
13:55:16 <moldy> merijn: i don't know about haskell, i am a complete haskell newbie myself. but i know that other languages have signal APIs where a subset works on both unix and windows (e.g., python)
13:55:49 <moldy> dnkndnts: you say you disagree, but then you say nothing that contradicts what i just said.
13:56:06 <cristian1> merijn: thanks dude... will take a look at it
13:56:12 <dnkndnts> lol, i typed most of that before you entered the directly preceding message
13:56:15 * hackagebot unbound-generics 0.0.1 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.0.1 (AlekseyKliger)
13:56:49 <moldy> dnkndnts: yes, the experience of others can be helpful, but you still need to write/play *alot* yourself if you want to become good
13:57:12 <moldy> you cannot expect to become good by reading even the best tutorial in the world
13:57:24 <dnkndnts> moldy: oh yes, completely agree.
13:58:33 <moldy> merijn: which signal do you want to send?
13:58:56 <dnkndnts> i considered just streaming myself and letting Cunningham's law work its magic, but i'm too nervous to try it =)
13:58:59 <merijn> moldy: sigint
13:59:28 <mauke> I know windows has no signals
14:00:10 <mauke> windows perl has a working kill() function but the "signal number" just sets the exit status of the victim
14:00:50 <monochrom> what does windows perl kill() do to kill that other process?
14:01:00 <moldy> windows has signals, but they don't work as you expect when you're coming from unix
14:01:25 <monochrom> does it come down to calling a win32 thing for specifically killing processes?
14:01:40 <yitz> monochrom: yeah
14:02:03 <moldy> also nowadays, you have the distinctions between the different windows apis that may play a role here
14:02:18 <moldy> merijn: i think your best bet is to ask on #window or some other windows-specific forum
14:03:16 <merijn> monochrom: But I couldn't even figure out how to use win32 to kill a process
14:05:09 <mauke> GenerateConsoleCtrlEvent apparently is a thing
14:05:24 <mauke> TerminateProcess is another thing
14:06:34 <merijn> I think I'll just take a simpler approach
14:06:47 <trap_exit> merijn: what is your original question?
14:06:51 <merijn> Implement linux and classify windows support as "patches welcome" :)
14:06:51 <moldy> it also seems to matter what kind of process you are dealing with
14:07:35 <mauke> https://github.com/Perl/perl5/blob/blead/win32/win32.c#L1224
14:07:57 <monochrom> oh, int-e runs lambdabot IIRC. int-e, lambdabot needs help :)
14:08:58 * monochrom is tempted to @tell int-e lambdabot needs help. then realizes that it suffers the same problem as "if you have email problems, send us an email"
14:10:30 <moldy> http://stanislavs.org/stopping-command-line-applications-programatically-with-ctrl-c-events-from-net/
14:10:41 <moldy> apparently, this is "non-trivial" on windows ;)
14:13:13 <monochrom> yeah. well, it's a completely different design and philosophy.
14:14:56 <monochrom> I'm trying to recall what DOS did. I think it went like this: it's only the read-from-console routine of DOS that will take ctrl-c and kill the program. so for example, if your program is not waiting for input, ctrl-c does nothing.
14:15:32 <monochrom> but of course, ctrl-c is buffered up for the next time your program takes input. so program death happens then, and only then.
14:16:29 <moldy> and we're not even talking about "new-style apps", which probably work with completely different apis
14:16:29 <monochrom> it's also possible I have to s/read-from-console/generally-read-or-write-files/
14:17:33 * monochrom likes to use the distant past to explain today :)
14:17:35 <singpolyma> Hello!  I'm working on getting some simple Qt-related stuff wrapped in a Haskell library and have run into an issue with Cabal.  Normally I would just include c-sources: cbits/blah.c and have cabal do the compile for me, but in this case I really want to use the qt qmake configuration system to set up the C++ compile.  I can get it all to work by generating the *.o files using Qt's toolchain and then including those in the resulting *.a file, but caba
14:18:09 <nitrix> Hi, what's the signature of <$> ?
14:18:21 <nitrix> ghci doesn't want to tell me and google strips off the special characters.
14:18:24 <monochrom> one moment
14:18:30 <benmachine> nitrix: try asking ghci about (<$>)
14:18:41 <nitrix> Top level: Not in scope: ‘<$>’
14:18:43 <benmachine> alternativey, :i works well on operators
14:18:44 <benmachine> oh
14:18:45 <monochrom> you need to import Data.Functor for it
14:18:49 <benmachine> yes
14:18:52 <nitrix> I see, so it's a functor.
14:19:03 <benmachine> no
14:19:10 <benmachine> it's a function for working with functors
14:19:13 <monochrom> it should have the same type as fmap. fmap is in Prelude.
14:19:21 <RedNifre> Now wait... if I have data Person = Bob , instance Named Person where name Proxy = "someone", then I have get :: Named a => Proxy a -> String, get a = name a, but how would I do put :: Named a -> String , put a = name a? One would be name Proxy Person, the other would be name Proxy Bob and I guess those can't be used interchangeable.
14:19:31 <monochrom> Functor f => (a -> b) -> f a -> f b
14:19:52 <monochrom> an example is (a -> b) -> [a] -> [b]. map is []'s fmap
14:20:16 <dibblego> I saw a discussion about the following: instance (Something a, Eq b) => Eq (a -> b) but I have forgotten what the "Something" was  there was a reference to a package for this instance  reminder?
14:20:21 <benmachine> RedNifre: hold on a sec, Proxy Bob is not a thing
14:20:26 <benmachine> Bob is a value not a type
14:20:40 <merijn> singpolyma: You got cut off after ", but caba"
14:20:57 <RedNifre> That's the thing. How would I call the name function if I only have Bob?
14:20:57 <mauke> dibblego: universe?
14:20:59 <benmachine> dibblego: http://hackage.haskell.org/package/infinite-search maybe
14:21:08 <singpolyma> merijn: oh?  , but cabal doesn't seem to have any way to include *.o file it did not generate itself.  Any ideas?
14:21:09 <benmachine> wait no
14:21:14 <benmachine> I'm thinking of something else
14:21:22 <merijn> singpolyma: But I think the answer to your question is: write a custom Setup.hs and implement a hook that calls out to your Qt toolchain yourself?
14:21:53 <dibblego> hmm universe looks useful too, but I don't think that was it
14:22:03 <benmachine> dibblego: you can assemble it with http://hackage.haskell.org/package/countable-0.1/docs/Data-Searchable.html
14:22:10 <singpolyma> merijn: Yeah.  I expect I'll have to do custom Setup.hs (though I'd *really* like to avoid it) -- but even them I'm not sure the simplest way to include other *.o files in the resulting archive?  The Cabal library docs are pretty big...
14:22:17 <dibblego> searchable, that was it!
14:22:18 <merijn> singpolyma: I would do the following, write whatever build system you want for the C++ bit (make/automake/whatever) and compile that to a static lib. Write a Setup.hs hook that calls your buildsystem, then have cabal just link that library into your haskell library
14:22:30 <dibblego> thanks
14:22:54 <RedNifre> I mean, I could create a separate nameFromValue Bob = "somebody" which is just the same return value as name Proxy = "somebody", but is there a way to do it without the code duplication?
14:23:02 <benmachine> dibblego: I feel sure there was another one maintained by copumpkin, but I'm not sure it was either of thsoe
14:23:42 <singpolyma> merijn: that last step is the one I'm missing.  Having cabal link a static library into my haskell library
14:23:57 <merijn> singpolyma: There's an ld-options field :)
14:24:04 <benmachine> dibblego: admittedly I might have made that one up
14:24:46 <singpolyma> merijn: hmm... I thought I tried that, but let me look again
14:24:50 <merijn> singpolyma: There's extra-libraries, extra-lib-dirs and ld-options
14:25:05 <merijn> Consult cabal user guide for details, etc.
14:26:16 <singpolyma> sure.  I mean, I'm reading the guide...  extra-libraries is for external, shared libs, not stuff you want included in your package
14:27:03 <singpolyma> ld-options doesn't do anything because cabal is never actually linking anything, just ar'ing up a bunch of *.o files
14:27:42 <merijn> singpolyma: You could try explicitly passing .o files to ghc using GHC-Options, but that's pretty hacky :)
14:28:30 <merijn> singpolyma: And, option of last resort, in addition to a pre-build hook to compile the C++, add a post-build hook to call 'ar' and add the C++ objects to the library yourself
14:29:28 <singpolyma> yeah, passing them to ghc doesn't work either, since ghc is just producing *.o files itself.  Only cabal touches the *.a user ar manually.  Hmm.. post-build to add files to the *.a -- if I can get a hook that gives me the path to said file that may be an option
14:29:51 <RedNifre> Ah, I guess it's   put :: Named a => a -> String , put thing = name $ (Proxy :: Proxy a)
14:30:07 <benmachine> RedNifre: isn't that what get what
14:30:10 <benmachine> *what get was
14:30:22 <benmachine> oh, no, it was slightly different
14:30:35 <RedNifre> No, get was with the type as a parameter. You did get $ Proxy Person
14:30:42 <RedNifre> and the new case is put $ Bob
14:30:59 <merijn> singpolyma: I'm pretty sure you can query the path to the file from cabal, it'll require some digging into the cabal docs. Try asking in #hackage when dcoutts is online
14:31:00 <benmachine> right
14:31:17 <benmachine> your definition may not work without ScopedTypeVariables, there are a few things which will
14:31:29 <vanila> Can pandoc create a table of contents and an index?
14:31:38 <vanila> like if you want to produce a HTML version of a book
14:31:45 <merijn> vanila: For some file formats
14:31:47 <RedNifre> huh?
14:31:48 <benmachine> RedNifre: where are you getting your proxy type from?
14:32:09 <RedNifre> I'm not sure I understand the question.
14:32:26 <benmachine> this Proxy thing
14:32:30 <benmachine> are you using a library to get it?
14:32:49 <singpolyma> merijn: thanks
14:32:51 <benmachine> oh, actually, never mind
14:32:55 <benmachine> continue as you were
14:33:11 <RedNifre> If I have data Person = Bob and I want to do "get Person" I thought I did "get $ Proxy Person" for this? I guess it's this one: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Proxy.html
14:33:27 <Sonarpulse> so I am using quickCHeck to bruteforce boolean expressions
14:33:37 <Sonarpulse> my innermost monad is Gen
14:33:43 <merijn> singpolyma: You could also just blindly assume the library is in dist/build/whatever for now and do it "properly" later
14:33:46 <bb010g> RedNifre: So you have a Person ADT and it's only constructor is Bob?
14:33:49 <Sonarpulse> quickCHeck's random sampling monad
14:34:04 <RedNifre> fread2282 suggested it.
14:34:09 <Sonarpulse> then I also need a StateT which I use basically to keep my expressions finite
14:34:36 <Sonarpulse> (I keep track of the max number of AST nodes of a certain type I have left to use
14:34:37 <RedNifre> No, that is just an example. I have something like data Report = Report { String, Integer, Blablabla}
14:34:52 <Sonarpulse> and then MaybeT to abort and try again if I run out
14:35:08 <Sonarpulse> which order should I apply the monad tranformers?
14:35:10 <Sonarpulse> I think I want
14:35:14 <RedNifre> And if I want to load a report I want to do "get Report" which is not valid haskell since you can't use a type as a parameter.
14:35:23 <RedNifre> (Unlike Java, where you can do Report.class)
14:35:40 <Sonarpulse> (Maybe (state -> state, Expr))
14:35:50 <RedNifre> So the way I understand Proxy is I can do "get $ Proxy Report" instead, but maybe that is wrong.
14:35:57 <benmachine> Sonarpulse: do you know how the State monad works underneath?
14:35:59 <merijn> Is there a way to get haddock to report the kind of a type alias?
14:36:03 <Sonarpulse> yes
14:36:20 <benmachine> RedNifre: I think you want something like get (Proxy :: Proxy Report)
14:36:36 <Sonarpulse> with what I wrote right now my state counters are not getting decremented so too much state is being thrown away
14:37:01 <RedNifre> no, there is only one get function and it does not know about the types and values, only about the type class.
14:37:20 <RedNifre> It's basically doule dispatch.
14:37:25 <RedNifre> *double
14:37:38 <RedNifre> You know, the visitor pattern.
14:37:40 <benmachine> Sonarpulse: the way I usually do this is write down the explicit type I want and then work out which transformer it corresponds to afterwards
14:38:04 <Sonarpulse> Get (Maybe (state -> state, Expr))
14:38:08 <Sonarpulse> I think that is it
14:38:25 <Sonarpulse> well hmm
14:38:39 <benmachine> hmm
14:38:46 <Sonarpulse> Get (state -> Maybe (state, Expr))
14:38:50 <dibblego> that doesn't look right
14:38:51 <dibblego> that one does
14:38:57 <benmachine> I think StateT s (MaybeT m) a and MaybeT (StateT s m) a are actually the same
14:39:07 <dibblego> benmachine: I don't
14:39:30 <benmachine> dibblego: they correspond to the same type, at least
14:39:34 <Sonarpulse> it is possible my second one is not possible with tranformers because I am "splitting" the function with the maybe
14:39:43 <dibblego> oh I misinterpreted the typo
14:39:56 <benmachine> Sonarpulse: state -> Maybe (state, Expr) says StateT state Maybe Expr to me
14:39:59 <jmcarthur> RedNifre: it's sounding to me like maybe it would be a good idea to step back and decide whether this approach is really working
14:40:20 <jmcarthur> RedNifre: what exactly are you doing?
14:40:25 <RedNifre> As a more practical example: data ReportType = ReportValue { message :: String }, I want to have only one function that I can call like this "get ReportType"(impossible?) and only one function that I can call like 'put $ ReportValue "Some text" '
14:40:25 <Sonarpulse> StateT state (Maybe Expr) ?
14:40:52 <dibblego> RedNifre: Control.Lens.Iso#iso
14:41:20 <jmcarthur> oh gosh we're going to point RedNifre to lens now?
14:41:20 <Sonarpulse> wouldn't that be m (state -> (state, Maybe Expr)) ?
14:41:35 <dibblego> better than Prelude
14:41:41 <jmcarthur> lol
14:41:43 <Sonarpulse> that combination of StateT and Maybe is what I have, but it isn't working
14:41:46 <RedNifre> Yeah, I guess it's all getting too complicated now and there is really no point in reinventing everything again.
14:41:50 <monochrom> perhaps lens is an excellent approach
14:42:02 <jmcarthur> RedNifre: could you explain at a higher level what you're trying to do?
14:42:16 <Sonarpulse> It would imply I except or discard the state regardless of the Maybe
14:42:22 <Sonarpulse> *accept
14:43:03 <RedNifre> I want to create a layer on top of sqlite where I can put and get values from. But the layer does not know the types, the layer only provides class SqlValue where tableName :: String etc. etc.
14:43:30 <jmcarthur> RedNifre: tableName :: String   already looks funny. are you sure you want a type class at all?
14:43:37 <RedNifre> So if you want that your type works with it you do instance SqlValue MyOwnType where tableName :: "myOwnType", etc. etc.
14:43:37 <Sonarpulse> I am going to take out the transformers and do it manually for now
14:43:44 <jmcarthur> RedNifre: note that type classes don't fill the same gap that classes in OO languages do
14:44:01 <RedNifre> I'm not sure of anything since I'm a total haskell beginner. Everything I might try might be the wrong approach ;)
14:44:02 <jmcarthur> RedNifre: would a data type work for your purposes?
14:44:26 <jmcarthur> RedNifre:    data SqlValue = SqlValue { tableName :: String, etc. }
14:44:46 <RedNifre> no, that is not well typed.
14:44:50 <lpaste> dibblego pasted “ReportType.hs for RedNifre” at http://lpaste.net/112147
14:44:57 <Sonarpulse> err not
14:44:58 <RedNifre> Then every value in my code would be of type SqlValue
14:45:03 <jmcarthur> RedNifre: in what way is the type class better typed?
14:45:16 <Sonarpulse> looked at the definition and StateT is putting the outer monad where I want it
14:45:29 <jmcarthur> RedNifre: note that type classes make the most sense when all methods actually mention the type
14:45:35 <monochrom> everyone, I think RedNifre is not done describing everything you need to know about SqlValue
14:45:46 <RedNifre> Then I would have data Report = Report { content :: String } and data Something = Something and instance SqlValue Report where ... etc.
14:45:52 <benmachine> jmcarthur: isn't that actually a requirement?
14:46:01 <monochrom> I wish there were one single web page that has the complete, well-organized description.
14:46:02 <jmcarthur> benmachine: (you can hack around with Proxy)
14:46:05 <RedNifre> In my code I could deal with Report and Something, while to the DB layer it would all be SqlValue
14:46:11 <benmachine> the type's still gotta be in there *somewhere*
14:46:21 <benmachine> maybe not values of the type
14:46:49 <benmachine> RedNifre: so what is put supposed to do?
14:46:56 <jmcarthur> benmachine: yeah, but if the methods only mention proxies, something is usually wrong, especially for beginner code
14:47:18 <benmachine> jmcarthur: fair enough
14:47:21 <RedNifre> Write a value to the db by calling the toSql function on it and the tableName function.
14:47:55 <benmachine> RedNifre: so for each datatype, there's exactly (or if you like, at most) one entry in the database?
14:47:56 <RedNifre> dibblego can you explain your control lense paste?
14:48:20 <RedNifre> No, you can also supply a query. It would be one table per type.
14:49:38 <benmachine> RedNifre: I think a good exercise would be to write down a little toy program that uses your library, before you have written the library
14:49:43 <RedNifre> It's actually get :: ?Type? -> String -> IO TypeValue , get ?type? whereClause = ...
14:49:57 <benmachine> hm
14:50:06 <RedNifre> I already have that toy program, the library just fell out by itself.
14:50:15 <benmachine> what's TypeValue?
14:50:35 <RedNifre> The thing that works is separate functions for every type, i.e. getReport :: Report, getSomething :: Something etc.
14:50:55 <RedNifre> But that is not very pretty, the DB should not know about the actual types.
14:52:59 <fresheyeball> hello haskellers
14:53:04 <fresheyeball> I have a question
14:53:24 <fresheyeball> if I have `data RGBA = RGBA Int Int Int Int`
14:53:31 <fresheyeball> its can be mapped over
14:53:35 <RedNifre> Oh yeah, I meant I want get :: DBCompatible a => typeOf(a) -> String -> a      ,     get type whereClause = (createFromSqlStuff (getSqlStuff (tableName type) whereClause) :: a)
14:53:37 <fresheyeball> but cannot be a functor
14:53:40 <fresheyeball> why?
14:53:54 <merijn> fresheyeball: Because functors must allow the type to change
14:54:02 <merijn> fresheyeball: And your RGBA type only ever accepts Int
14:54:09 <nitrix> Is there an idiomatic format for TODOs in Haskell code?
14:54:12 <merijn> :t fmap even
14:54:18 <merijn> oh, blah
14:54:25 <merijn> I keep forgetting lambdabot is dead :)
14:54:26 <fresheyeball> yes
14:54:30 <fresheyeball> only Int
14:54:33 <monochrom> one of the minor reasons (but tip of the iceberg) is that you have "data RGBA = ..." not "data RGBA a = ..."
14:54:43 <fresheyeball> right
14:54:51 <fresheyeball> but I can define a way to map over it
14:54:56 <dibblego> RedNifre: I was mostly focussed on your answer to the question about "a more practical example: data ReportType = ReportValue { message :: String }, ... have only one function that I can call like this "get ..." and only one function ... put ..."
14:54:59 <fresheyeball>   (<$>) f (RGBA r g b a) = RGBA (f r) (f g) (f b) (f a)
14:55:07 <merijn> fresheyeball: Right, well there's your answer. If it can never accept anything other than Int, how would you fmap "even :: Int -> Bool" over it?
14:55:40 <fresheyeball> so its fundamentally not a functor
14:55:49 <merijn> fresheyeball: Pretty much
14:56:03 <fresheyeball> so where should I describe the mapping logic?
14:56:04 <monochrom> I agree that you can define "myfunction f (RGBA a b c d) = RGBA (f a) (f b) (f c) (f d)". do you mind just keeping it as "myfunction" instead of shoehorning into fmap? because it really doesn't fit.
14:56:11 <RedNifre> dibblego hm...
14:56:23 <merijn> fresheyeball: "mapRGBA :: (Int -> Int) -> RGBA -> RGBA"?
14:56:41 <monochrom> not everything that intuitively is "mapping" can be fmap or Functor. because intuition breaks.
14:56:47 <dibblego> RedNifre: it may not be the best answer for learning purposes, but for "practical purposes", it is.
14:57:05 <fresheyeball> so this should just be a flat function
14:57:14 <fresheyeball> and I should not try and make it a functor
14:57:18 <RedNifre> Could you quickly explain what that is?
14:57:27 <Sonarpulse> ok I think I almost got it
14:57:30 <merijn> fresheyeball: That's right way to go, most likely
14:57:41 <jmcarthur> RedNifre: get :: DBCompatible a => typeOf(a) -> String -> a   -- the typeOf(a) argument is unnecessary in that because a is already mentioned
14:57:58 <fresheyeball> how about semigroup?
14:58:08 <fresheyeball> could RGBA be a semigroup?
14:58:11 <monochrom> "data NewRGBA a = NewRGBA a a a a" can be made a Functor. but then you will have "NewRGBA (Maybe [Char])"
14:58:11 <dibblego> RedNifre: It is code that uses a library to exploit, in this case, an isomorphism, and provides library support that you describe (get/put)
14:58:38 <Sonarpulse> I need lifts_and_maps :: StateT Counters Gen Expr -> StateT Counters (MaybeT Gen) Expr
14:59:32 <RedNifre> Ah, maybe instead of using a dummy parameter I need a dummy return value?
14:59:43 <RedNifre> As in name :: (String,a)
14:59:51 <monochrom> remind me what is semigroup?
14:59:57 <srhb> monochrom: <>
15:00:03 <dibblego> Monoid with unit
15:00:05 <dibblego> *without
15:00:13 <dibblego> @hackage semigroupoids
15:00:15 <srhb> So yes, you can.
15:00:16 <RedNifre> I mean class DBCompatible a where tableName :: (String, a)
15:00:19 <fresheyeball> So can I have something like this
15:00:54 <fresheyeball> (<>) (RGBA r g b a) (RGBA r' g' b' a') = RGBA (r + r') (g + g') (b + b') (a + a') ?
15:01:00 <monochrom> yes
15:01:13 <dibblego> you want <> instead of + but yeah
15:01:18 <monochrom> unless + has its problems
15:01:20 <RedNifre> Then I could do put :: DBCompatible a => a -> IO ()    ,    put a = putIntoTable  $ fst (tableName a)
15:01:46 <monochrom> when you're blending colours, it's more complicated than +, so beware.
15:01:55 <RedNifre> I meant put :: DBCompatible a => a -> IO ()    ,    put a = putIntoTable  (fst (tableName a) ) a
15:02:14 <monochrom> but a lot of complicated formulas for blending still give you semigroups.
15:02:26 <RedNifre> And I don't even need the => any more
15:03:17 <RedNifre> put :: DBCompatible -> IO ()    ,   put a = putIntoDb (fst . tableName a) a
15:03:44 <zipper> Which is the best way to install cabal on linux. On archlinux I used pacman -S cabal-install but right now I am having an issue updating with cabal install cabal-install. here http://ix.io/eDG
15:03:53 <RedNifre> Please tell me that this is not complete nonsense, I just stated to feel that all this type inference began to make sense ;)
15:04:24 <fresheyeball> Ints are semigroups right?
15:04:30 <fresheyeball> as well as monoids?
15:04:31 <monochrom> do you need a really new cabal-install? which version are you stuck with now?
15:04:34 <Thooms> fresheyeball: yes.
15:04:38 <zipper> The issue seems to be with the downloaded package not something I haven't installed.
15:04:54 <dibblego> fresheyeball: no, a monoid is a set, an associative operation and an identity
15:05:14 <Thooms> oops
15:05:24 <dibblego> there exist associative operations and an identity on the set Int to form a monoid
15:05:25 <Thooms> (Int, *, 1) is
15:05:37 <monochrom> Int makes many different semigroups, they differ in whether you use +, *, or some other things
15:05:40 <RedNifre> Oh well, it's getting too late. Thanks for all your insights, it has helped me a lot :) good night
15:06:12 <monochrom> you have to pick one. you have to pick the right one for your context.
15:08:58 <rudi_s> Hi. Can I put a where inside a do block? I'd like to do something like a <- f; where f = bla; (where ; is a newline). Thanks.
15:09:13 <rudi_s> The idea being that the f is only defined for the assignment.
15:09:34 <mauke> a <- bla
15:09:36 <monochrom> cannot. to a large extent, "where" is attached to the "=", not any expression or do-block
15:11:46 <rudi_s> monochrom: Ok, thanks. I'll use a let then.
15:11:52 <rudi_s> mauke: :D
15:17:38 <nixx7> anyone?
15:18:13 <nixx7> guess not
15:18:38 <rudi_s> ?
15:19:46 <nixx7> I have some questions and was interested if someone is here to give me answers
15:20:01 <Thooms> don't ask to ask
15:20:46 <rudi_s> nixx7: And be patient on IRC. Not getting an answer after 1 minute means nothing. Give it at least an  hour (in less active channels).
15:21:19 * hackagebot xml-push 0.0.0.18 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.18 (YoshikuniJujo)
15:34:59 <vermeille> Hi, cabal can't install profiling libraries for most packages on Hackage. Did I break my cabal or is it a known issue?
15:36:09 <monochrom> if one of the libs you already have was not built with profiling, then any further libs that depend on it cannot be built with profiling. Note: GHC's libs already have profiling, don't touch them.
15:36:19 * hackagebot xmpipe 0.0.0.4 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.4 (YoshikuniJujo)
15:36:45 <monochrom> well, unless you obtained GHC from linux distros, which invariably omit profiling and do a "sold separately"
15:37:35 <monochrom> if you obtained GHC from GHC official web site or Haskell Platform, they already come with profiling, don't touch them.
15:38:07 <monochrom> for the other libs you cabal-installed yourself, see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
15:38:32 <monochrom> for linux distro omissions, go after your linux distro.
15:38:50 <vermeille> Oh thx!
15:39:15 <monochrom> hunt it down, hold its throat, breathe fire down its throat, until it tells you where are the profiling stuff
15:51:21 <Sonarpulse> https://github.com/Ericson2314/brown-engn1630/blob/master/src/Engn1630/Util/BruteBoolean.hs
15:51:36 <Sonarpulse> I am working on the code to brute force boolean expressions
15:52:05 <Sonarpulse> (and then test them against oracles to use QuickCheck to automate my hardware class work)
15:53:52 <Sonarpulse> The numNands and numXors arguments are used to put an upper bound on the number of nodes/gates in the AST / schematic
15:54:26 <Sonarpulse> unfortunately bruteExpr 1 0 0 does not always return (Arg 0)
15:54:45 <Sonarpulse> and instead uses arbitrary number of nands and xors
15:55:19 <Sonarpulse> so my counters on the number of gates I have left to use are not being properly threaded through the state monad
15:59:19 <Axman6> Sonarpulse: i get a 404 for that url, is it a private repo? (probably should be if it's a school assignment; also note that somewhat limits how much we can help)
15:59:32 <Sonarpulse> yeah it is a private repo
15:59:49 <Sonarpulse> the school assignment is basically just make the thing on a breadboard
16:00:04 <Sonarpulse> so i figure this is far removed enough to be ok
16:00:31 <Sonarpulse> but i did make it private as I might put more directly-related things in there when we switch to FPGAs
16:02:46 <vermeille> monochrom: I think I have to thank you. Everything seems to work :D
16:02:54 <Sonarpulse> I am going to put a small part of it in a paste
16:03:01 <Axman6> ok, well we can't see the code if it's private =)
16:07:51 <lpaste> Sonarpulse pasted “Redacted Boolean Brute Force Generator” at http://lpaste.net/112150
16:08:22 <Sonarpulse> Axman6 ok that seems like a reasonable subset
16:08:57 <Sonarpulse> hopefully the bug actually lies in those bits
16:11:04 <vermeille> Is there something to debug haskell which can be easily adopted for a C/C++ dev?
16:11:25 <pjdelport> Debug.Trace?
16:11:27 * pjdelport ducks
16:12:05 <vermeille> I tried GHCi, and was confused by the laziness which prevented me from even knowing what were the arguments of the functions
16:13:02 <Cale> Actually, Debug.Trace.trace is pretty good for getting example arguments to functions when things are failing.
16:13:09 <Cale> You can write something like
16:14:02 <Cale> foo x y z | trace (unwords ["foo", show x, show y, show z]) False = undefined
16:14:11 <Cale> and then proceed with your other pattern matches
16:14:19 <StoneToad> ohh nice Cale!
16:14:28 * StoneToad adds that to his bag of tricks
16:14:40 <Sonarpulse> Axman6 ?
16:14:58 <vermeille> Why not :)
16:15:07 <Cale> vermeille: Another thing you can do is to try to write QuickCheck properties for your functions.
16:15:43 <vermeille> Cale: I did, but I had a breaking change to do
16:18:38 <Axman6> Sonarpulse: what's the code supposed to do?
16:20:14 <Sonarpulse> I should have included my data type
16:20:35 <Sonarpulse> data Expr = Arg 0 | Nand Expr Expr | Xor Expr Expr
16:20:36 <Axman6> is it some how supposed to cound nand and xor gates?
16:20:51 <Sonarpulse> yes
16:20:55 <Axman6> because I can't see that happening anywhere
16:20:56 <Sonarpulse> as it generates nodes in the ast
16:21:06 <Cale> Sonarpulse: What's that 0 doing there?
16:21:25 <Axman6> another good question
16:21:30 <Sonarpulse> i get an arbitrary word and and mod by 3
16:21:43 <Sonarpulse> 0 is generate a (Arg number)
16:21:44 <Sonarpulse> node
16:21:48 <Sonarpulse> if this is a Cell
16:21:57 <Axman6> you can't have 0 in a data declaration
16:21:59 <Sonarpulse> you can think of it as refererring to the nth input wire
16:22:06 <Axman6> constructors and types only
16:22:07 <Sonarpulse> oh in the data def
16:22:12 <Sonarpulse> sorry that was supposed to be Word
16:22:41 <Sonarpulse> I was typing that in by hand, had it word in my file
16:22:54 <Axman6> ok
16:23:19 <Axman6> well you're not actually counting the number of nand or xor gates anywhere, you're just checking the count
16:23:30 <Sonarpulse> yes
16:23:45 <Sonarpulse> but i decriment the count as the fist thing in BruteOp
16:24:17 <Axman6> do you?
16:24:29 <Sonarpulse> swear! :)
16:24:42 <Axman6> well it's not there, and I still have no idea what you want help with
16:25:10 <Sonarpulse> yeah its in the elided bits
16:25:19 <Sonarpulse> thanks for looking at it
16:25:32 <Sonarpulse> looking at the redacted code is probably worse than nothign at all
16:25:47 <Axman6> ok...
16:27:07 <Sonarpulse> the key part is R, which is all there
16:27:14 <Sonarpulse> everything gets called via that
16:27:31 <Sonarpulse> since bruteOp and tryBrute can file
16:27:58 <Sonarpulse> r will keep on calling tryBrute until it doesn't
16:28:41 <Sonarpulse> trybrute calls bruteOp if the "roll of the dice" is to make a gate node
16:29:08 <Sonarpulse> otherwise it just returns (Arg 0) which conveniently both doesn't decrement any count and also doesn't recur
16:29:16 <Sonarpulse> so the function is total
16:32:07 <vermeille> Is it considered "bad style" to have a lot of imperative-looking monadic code? Or maybe it is bad for performances?
16:32:24 <monochrom> this depends on what task the code does.
16:32:38 <vermeille> in my case, I'm writing a VM
16:33:20 <vermeille> So, I can either describe each opcode as a sequence of operations, or describe the state of the VM after this opcode
16:33:47 <monochrom> I/O tasks benefit from monadic code. embedded domain-specific languages benefit from monadic code too, I/O or not. VM looks like at least the second case.
16:34:32 <joe9> I need to convert a html table to csv. Any suggestions for a good haskell library to do that, please? Or, if there is a linux utility that can do that without any programming, even better.
16:35:16 <vermeille> monochrom: https://bitbucket.org/Vermeille/functionality/src/e5d36ad416b2d391424798e142b606aa373d6523/src/vm-proto/src/Branching.hs?at=master#cl-52 That's basically the type of code I'm dealing with
16:36:52 <monochrom> um, unsafePerformIO?! :)
16:37:37 <vermeille> monochrom: Just a debug print
16:37:50 <monochrom> I think you should replace that by Debug.Trace stuff. sure, that calls unsafePerformIO under the hood, but if you use Debug.Trace your well-intention is well expressed.
16:37:51 <Sonarpulse> Axman6 found my bug!
16:38:06 <Axman6> vermeille: use the much safer Debug.Trace*
16:38:15 <Sonarpulse> all Words are >= 0, duh!\
16:38:17 <Axman6> *it's actually exactly the same as what you have there
16:38:25 <Axman6> Sonarpulse: yes =)
16:39:06 <vermeille> Actually, I want to change the VM's state to have a prompt so that I can inspect and write commands to interact with the VM, that's just a quick and stupid implementation of this more ambitious idea
16:39:22 <monochrom> I think writing monadically and using State Memory is good for this. the alternative is not fundamentally different.
16:39:53 <vermeille> Does it generate a new VM state at each line?
16:40:09 <vermeille> It could really be a performance pitfall
16:41:01 <monochrom> no. only when you call put (directly or indirectly), new Memory is created. other times, the same value is passed around.
16:41:54 <vermeille> okay good.
16:42:11 <vermeille> I'm still asking newbish question. Still a beginner.
16:42:40 <monochrom> actually, the precise answer is more subtle than that. even some put's don't create new Memory.
16:43:33 <monochrom> suppose you say: "x <- get; put x", then nothing new is created, you're just passing the old value x around. its only waste is in more passing around for no reason
16:44:16 <vermeille> okaaaaay. Got it.
16:44:30 <vermeille> Only when put is invoked, and when the value has been modified
16:44:58 <monochrom> when you say "x <- get; put x{field1 = new value; field2 = new value}", that's when new stuff is created and old stuff discarded waiting for GC. but the real reason is x{field1 = new value, ...}
16:44:59 <vermeille> and if the value is complex, it modifies / copies only the smallest subset possible
16:47:51 <monochrom> I basically assume that your modifying the record coincides with your calls to put, and get a fairly accurate rule of thumb.
16:48:53 <monochrom> I am just a bit worried about things like "Just ret <- preuse tos". are you sure you never get Nothing?
16:50:12 <vermeille> If I get Nothing, I crash... which is exactly what is expected to happen if you want to take the top of an empty stack
16:50:52 <vermeille> I mean, sure, I can display an error message and exit nicely, but that's only a prototype
16:51:13 <monochrom> alright. no objection.
16:52:39 <vermeille> Thanks for reading my code so closely!
16:53:02 <monochrom> you're welcome
17:04:28 <Sonarpulse> thanks everbody
17:05:51 <rudi_s> I'm using the State monad and extracting and running a function (which also runs in the same monad) with f <- getFunc <$> get ; f arg1 arg2 - how can I write this in a single line without the <- ? The following works, but feels ugly: getFunc <$> get >>= \x -> x arg1 arg2; Thanks.
17:06:25 <arielsanflo> hello
17:06:31 <dmj`> @typ liftM2
17:06:32 <Ralith> :t join
17:07:01 <arielsanflo> un canal en espaol help
17:07:21 <monochrom> #haskell-es ?
17:07:42 <arielsanflo> si
17:07:47 <arielsanflo> algo asu
17:07:50 <arielsanflo> asi
17:07:56 <arielsanflo> por favor
17:10:21 <monochrom> I think the do-notation version and the >>= version are already pretty good and elementary. the alternative is going to be a bit obscure.
17:10:29 <Axman6> rudi_s: (getFunc <$> get) <*> pure arg1 <*> pure arg2 is the best I get
17:10:57 <Axman6> :t gets
17:11:04 <monochrom> you need one outer join
17:11:11 <rudi_s> Ok, thank you both. I'll stick with >>= then. The pure version is not really nicer.
17:11:43 <monochrom> at this point, (getFunc <$> get) <*> pure arg1 <*> pure arg2 :: IO (IO Z)
17:13:14 <Axman6> oh right
17:13:43 <Axman6> so I was working on this last night, and I was interested to know why it's a bad idea: https://gist.github.com/axman6/fd41491c38d5492928d1
17:13:53 <monochrom> I said obscure because I thought there was an obscure operator that relieved us from writing "pure" by hand
17:14:34 <Axman6> it seems to work (ie, it lets you make Set and unboxed vectors monads, as well as everything that is already a monad should still work, without much change)
17:15:06 <dmj`> Is there a Haskell -> JS compiler that provides cheap typechecking
17:15:33 <monochrom> does haste count?
17:15:51 <Axman6> ($ arg2) <$> ($ arg1) <$> (getFunc <$> get)
17:15:56 <Axman6> hmm, still the wrong type
17:16:13 <dmj`> monochrom: I'm looking for something that doesn't attempt to implement a lazy runtime in JS and and doesn't sacrifice the readability of JS
17:16:13 <Axman6> and gross, and I can't even tell if it works...
17:16:31 <dmj`> I want type safety, like typescript
17:16:40 <dmj`> but I want to share types
17:16:43 <dmj`> in Haskell
17:18:06 <dmj`> can I have my cake and eat it atoo
17:18:08 <dmj`> too
17:18:58 <monochrom> what does ghcjs do? pretty similar thing i.e. scrambled JS that no human could ever write?
17:19:38 <monochrom> fay's output is somewhat understandable. but fay is not exactly haskell.
17:21:16 <monochrom> Axman6: my concern with Set being Monad is not the Ord requirement. I am happy to ignore that at the mathematical level. I don't even require Eq. my concern is parametricity.
17:22:05 <Axman6> we lose something by constraining things?
17:22:33 <monochrom> if Set is a functor, and set size :: Set a -> Int is parametric polymorphic, then size s = size (fmap s). but size {1,2} /= size (fmap (const 'x') {1,2})
17:22:53 <Axman6> right, yes
17:23:08 <monochrom> my conclusion is that either Set is not a functor or size is not parametric polymorphic. you have to give one of them up.
17:24:02 <Axman6> yeah I see
17:24:09 <Axman6> and this is why I thought I'd ask =)
17:24:14 <monochrom> Vector probably doesn't suffer a similar problem.
17:24:55 <Axman6> yeah, vectors are definitely functors (though unboxed vectors need constrained types)
17:27:02 <monochrom> it is possible to take this stance: there is no size. then no violation is observable.
17:27:27 <Axman6> monochrom: do the functor laws require that sets remain the same size? fmap id = id still, and fmap f . fmap g = fmap (f.g) still right?
17:27:56 <monochrom> I'm using the free theorems. they work whenever you have functors.
17:28:21 <vermeille> Guys, do you know some fun companies for a software engineer (master level) intership? I already go to Facebook, but I need another company because it does not last enough time
17:28:44 <monochrom> the two functor axioms themselves are not violated.
17:29:22 <monochrom> some other function (size) fails the expectation of being a natural transformation.
17:29:36 <carter> int-e: where the lambdabot at :'(
17:32:03 <monochrom> hackage is still not building docs or building anything. lambabot is gone. winter is coming.
17:33:20 <srhb> Hackage isn't building / Lambdabot is gone / Winter is coming / And a lambda in a pear tree
17:34:41 <monochrom> "winter is coming" is supposed to remind you of Game-of-Throne kind of calamity, not the Christmas kind of jolly!
17:35:19 <srhb> At this point it can't be helped. Christmas candies were in my local supermarket this week, I'm stocked up and ready.
17:36:09 <monochrom> your local supermarket is confusing halloween with christmas. though I'm not blaming them.
17:36:27 <srhb> It's a danish thing. Supermarkets basically celebrate christmas 1/4 of the year.
17:36:34 <monochrom> I see
17:37:06 <merijn> monochrom: Also, halloween isn't celebrated anywhere except the US and maybe Canada/UK?
17:37:17 <Axman6> it's not a danish thing, it's pretty universal in western countries these days
17:37:33 <zq> western european countries, sure
17:38:05 <monochrom> the two are universally celebrated by computer-savvy people because oct xx = dec yy
17:38:36 <srhb> :D
17:38:52 <merijn> ugh, if anyone's looking for a nice little project I've got something for you to do to stop me from yak shaving :p
17:39:04 <srhb> merijn: Let me guess, writing tests?
17:39:16 <merijn> srhb: No, I sucked it up and am doing that myself
17:39:21 <srhb> :o
17:39:32 <benzrf> merijn: what t h en
17:39:36 <zq> what's your fancy idea?
17:39:54 <vermeille> Do you guys have heard of Morte?
17:40:17 <merijn> hdevtools tracks cabal nowadays, but apparently it doesn't support tests, so it complains packages are not in scope for my tests because my tests have different dependencies from my library :p
17:40:29 <vermeille> This kind of super-optimization can really be amazing
17:40:30 <Axman6> vermeille: Tekmo's thing?
17:41:06 <vermeille> http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html This
17:41:20 <Axman6> yes
17:45:53 <merijn> srhb: It's a catch-22, I didn't wanna put the code online until I was sure that it at least superficially seems to work, but without tests I can't be sure about that, but without putting it online I can hardly tricky gullible^H^H^H^H^H^H^H^H beginner haskellers into writing tests for me ;)
17:46:13 <srhb> merijn: I see your dilemma!
17:47:52 <monochrom> if you can write a specification, and a reader does not misinterpret it, then the reader can write test cases. no implementation needs shown, or even exist.
17:48:11 <benzrf> merijn: you press ^H 8 times to erase gullible?
17:48:13 <benzrf> pfft, pleb
17:48:14 <benzrf> ^W
17:48:50 <monochrom> I like the sequence of ^H's more. it's longer, therefore has emphasis :)
17:48:51 <merijn> ^[diw
17:49:50 <zq> so
17:50:02 <merijn> monochrom: Except that the API is currently at "minor version bumps will invalidate 60% of your code"-levels of stability :)
17:50:06 <zq> i asked this a couple of days ago, but no one replied:
17:50:38 <zq> given a finite length list literal xs, would map xs be definitively finite as well?
17:50:44 <zq> uh, map f xs
17:51:04 <merijn> zq: Oh, instead of answering I have an exercise for you :)
17:51:06 <monochrom> I answered. "I guarantee it. is that good enough?"
17:51:24 <merijn> zq: "map :: (a -> b) -> [a] -> [b]"
17:51:29 <zq> monochrom: sorry, i must have missed it
17:51:39 <merijn> zq: For kicks, try and write down all possible implementations of that type
17:51:42 <monochrom> the compiler is not going to guarantee it. it is not a theorem prover.
17:51:47 <zq> merijn: i could prove it in agda, but agda is strict
17:52:10 <merijn> zq: Ah, if you know how to prove things in agda, you may want to read this link
17:52:37 <jle`> i'm not sure you could write down all possible implementations of that type
17:52:45 <merijn> zq: http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
17:53:13 <merijn> jle`: I guess there's an infinite number, but only in a repetitively silly way
17:53:45 <zq> the reason i ask is
17:53:52 <merijn> zq: Any terminating strict program will still be terminating in a lazy setting
17:54:02 <tectonic> Is combining the knowledge in many browser tabs about monads into a new article a monadic operation?
17:54:19 <merijn> zq: It may have different space/time complexity, but going from strict to lazy cannot affect termination (you know, ignoring resource constraints)
17:54:21 <pjdelport> only if the structure is preserved
17:54:28 <monochrom> mono f [] = []; mono f (x:_) = repeat (f x). the type does not help this one.
17:54:44 <merijn> zq: This does not hold for the other way, i.e. going from lazy to strict does not necessarily preserve termination
17:55:12 <merijn> pjdelport: Was that adressed to me?
17:55:21 <monochrom> you actually have to do induction on specifically "map f (x:xs) = f x : map f xs" for this
17:55:24 <zq> [bind0, bind1, bind2, ... bindn] = map bound_func [arg0, arg1, ..., argn] isn't elided/optimized/whatever the word is -- the core ghc generates loops through each of the arg_i and checks for unmatched patterns
17:55:26 <pjdelport> No, at tectonic, sorry. :)
17:55:33 <tectonic> heh
17:55:58 <zq> so, for instance: [x, y z] = map (*2) [4, 5, 6]
17:56:25 <zq>                        ^,
17:56:47 <zq> not sure if it's an chance to patch ghc
17:56:56 <merijn> zq: Well, there's a difference between "map over a finite list is guaranteed to terminate" and "GHC is smart enough to prove that this is the case"
17:56:58 <jle`> wow that's some crazy accuracy in your ascii alignment
17:56:59 <pjdelport> tectonic: Now there's an idea for a new monad tutorial analogy though. :) Would that mean return is like a newbie who learns Haskell, and produces a default Monad tutorial?
17:57:25 <tectonic> pjdelport you'd end up with a hell of a lot of articles about monads ;)
17:57:28 <zq> merijn: but it doesn't need to -- length sameness is guaranteed in the general case of any finite list, right?
17:57:50 <pjdelport> tectonic: Good thing for join and bind!
17:58:00 <tectonic> might need to express it as a "possibly correct article about monads"
17:58:01 <zq> would this be a chance for -O3 to do something?
17:58:37 <merijn> zq: I'm pretty sure GHC doesn't store the length of a list, so at compile time it has no way to see that the pattern matches the input to map
17:59:07 <merijn> zq: And it would only work for list literals used in a pattern match like that, which I would argue is fairly rare to begin with
18:00:45 <zq> merijn: yeah, but [x, y] is just syntax for (:) x ((:) y []), so i imagine the same phenomenon would happen for some other data constructor
18:01:08 <zq> eg, idk, Just x = fmap (+3) $ Just 5
18:01:30 <zq> so it wouldn't just be list literals
18:02:20 <merijn> zq: Not that same, because Just's arity is fixed
18:02:40 <merijn> zq: Well, so is (:)'s, but your optimisation relies on inspecting all the way to (:)'s end
18:03:08 <merijn> Essentially you'd need to traverse the list at compile time to find it's length and check it matches the pattern's length
18:03:46 <merijn> zq: Essentially, what you're wanting is super compilation
18:04:03 <zq> is that demanding too much? :>
18:04:05 <merijn> Which makes compilation exceptionally slow and is an open topic of research :)
18:07:51 <joelteon> oh god, lambdabot is gone :(
18:07:55 <joelteon> how am I going to pl stuff
18:11:16 <zq> so it seems that it inspects for non-recursive ADTs
18:12:59 <joelteon> can (\a -> f a b) =<< m be written in terms of liftM*?
18:13:06 <joelteon> i feel like it should be, but clearly i am wrong
18:14:03 <Axman6> m >>= flip f b?
18:14:35 <dibblego> joelteon: No.
18:14:41 <joelteon> huh, okay
18:15:11 <zq> joelteon: the ret type of f is Monad m => m a, so no
18:15:18 <joelteon> huh.
18:15:24 <joelteon> what if i add a join?
18:15:32 <dibblego> yes
18:15:35 <zq> :t join
18:15:41 <joelteon> join (liftM2 f m (pure b))
18:15:42 <zq> :t join
18:15:42 <zq> :t join
18:15:42 <dibblego> using join and liftM, you can derive (=<<)
18:15:48 <joelteon> meh, that's gross though
18:15:49 <joelteon> I'll just use flip
18:16:00 <dibblego> (`f` b) =<< m
18:16:09 <joelteon> yeah, or sectioning
18:22:48 <fread2282> is there a typeclass for mempty + return?
18:23:14 <benzrf> fread2282: wot?
18:23:53 <benzrf> fread2282: mempty is only meaningful in the presence of mappend
18:24:21 <bms1> fread2282: there's a "kind mismatch" there
18:24:29 <monochrom> do you want mzero instead of mempty?
18:25:10 <fread2282> I want something that generalizes Maybe and Default
18:26:15 <zq> :t Default
18:26:27 <Vyn> lambdabot left
18:26:28 <monochrom> let me explain why we say "kind mismatch".
18:26:32 <fread2282> class Default a where def :: a
18:26:33 <bms1> fread2282: Sounds like Reader a a?
18:27:00 <zq> isn't that just a monoid?
18:27:02 <monochrom> in the case of Monad, it's for example "instance Monad Maybe", not "instance Monad (Maybe a)". do you acknowledge this?
18:27:19 <zq> well okay it's slightly more general than a monoid
18:27:37 <monochrom> and in the case of Monoid, it's "instance ... => Monad (Maybe a)", not "instance ... => Monad Maybe". do you see this?
18:27:54 <fread2282> zq: no injection function
18:28:41 <fread2282> bms1: thanks
18:28:42 <recursion-ninja> why did lambdabot leave?
18:28:53 <monochrom> so by the time you get the type class you desire, which instance code will it be, "instance YourClass Maybe"? "instance YourClass (Maybe a)"? you can only choose one.
18:31:13 <dmj`> monochrom: like typescript, but shared types, would be cool to make a template haskell function that generated type script interfaces for cheap client side type checking
18:33:04 <monochrom> I have not followed any of the frontends to javascript. so I don't know any solution out there.
18:33:21 <merijn> recursion-ninja: either crashes or the vps went down
18:33:47 <monochrom> apart from having heard of fay, ghcjs, and haste. I saw haste in action a few weeks ago in Toronto Haskell meetup. that's it.
18:34:14 <monochrom> well, onlinely, I saw chrisdone show off fay, too
18:34:29 <recursion-ninja> merijn: darn, I needed to ask lambda bot a question...
18:34:35 <hughfdjackson> Hrm, i'm finding parsec 3 is failing for a really confusing reason
18:34:39 <monochrom> those are all I know
18:35:16 <fread2282> what's the most popular/recommended logging library?
18:35:29 <hughfdjackson> https://gist.github.com/hughfdjackson/562edfe4df711074fd91 <- is this familiar to anyone?
18:37:11 <srhb> hughfdjackson: alpha is not a parser
18:37:17 <recursion-ninja> merijn: actually I needed to ask lambda bot two questions...
18:37:35 <monochrom> hughfdjackson, it is a genuine type error. you need to amend your type sig. expr :: Stream s m Char => ParsecT s u m String. you probably also need an extension for that. FlexibleContext(s)
18:37:50 <hughfdjackson> srhb: hrm, i thought oneOf took a string..
18:38:02 <srhb> hughfdjackson: Oh oops, I misremembered what oneOf was.
18:38:24 <recursion-ninja> bro = do
18:38:24 <recursion-ninja>       you even
18:38:24 <recursion-ninja>       liftM
18:38:25 <recursion-ninja>   where you = liftM
18:38:48 <monochrom> you also see that oneOf's own type is also Stream s m Char => etc. that's a strong indication that you need it.
18:38:49 <hughfdjackson> monochrom: is there any resource on understanding this?
18:39:15 <hughfdjackson> ah.. so that's going to propogate through the entire parser :s
18:39:16 <hughfdjackson> ?
18:39:20 <monochrom> yes.
18:39:27 <sipa> @let bro = liftM even >> liftM
18:39:38 <hughfdjackson> wow
18:39:45 <sipa> no lambdabot :(
18:39:53 <merijn> hughfdjackson: Or just write a monomorphic parser...
18:39:54 <monochrom> that is the price of being general.
18:40:21 <hughfdjackson> monochrom: is this so parsec3 can work on all of the text-like types?
18:40:22 <merijn> I don't see a lot of value in such a polymorphic parser
18:40:26 <hughfdjackson> Text, ByteString, String ..
18:40:35 <monochrom> the alternative is what merijn says. be special. expr :: ParsecT String u String or something
18:40:37 <recursion-ninja> sipa: Thanks for the reduction, but it's a joke. based on the "do you even lift" meme
18:40:40 <monochrom> yes
18:40:51 <hughfdjackson> monochrom: okay - well
18:40:51 <srhb> hughfdjackson: It's the 's' in ParsecT s u m String
18:41:04 <hughfdjackson> since i only intend to write String parsers, this is good for me :) thanks
18:41:10 <sipa> recursion-ninja: i realized that; i was just wondering whether it would work :)
18:41:16 <sipa> (without spending mental energy)
18:41:30 <monochrom> s could be String, Text, Bytestring... the general case needs a type class constraint
18:42:14 <monochrom> it's the same phenomenon as: "f x = show x ++ show x" is a "f :: Show a => a -> String" if you want it general
18:42:19 <merijn> hughfdjackson: Normally you'd write "type Parser = ParsectT String Foo String" or something at the top of your file
18:42:43 <merijn> hughfdjackson: And then use "Parser" everywhere, and if you decide to change your input type you only need to edit the type alias
18:42:46 <recursion-ninja> sipa: Too bad lambda bot is show us such hate and ran away...
18:43:01 <hughfdjackson> merijn: that sounds far preferable
18:46:00 <recursion-ninja> merijn: that does sound pretty slick, I'll keep that in mind when repeatedly using complex types
18:47:38 <jle`> i feel like we are the ones who were showing lamdabot hate this whole time
18:47:56 <monochrom> I never hated lambdabot
18:48:07 <hughfdjackson> hrm, all of the tutorials seems to be about the compatibility mode :/ i wonder if i'm just better off using this
18:48:09 <monochrom> onoes, a replacement bot is come
18:48:10 <hughfdjackson> *that
18:48:11 <recursion-ninja> I only try to show lambdabot love
18:48:29 <jle`> perhaps not you specifically, but lambdabot receives its fair shair of abuse from freenode
18:48:37 <monochrom> "lambdabot substitute is coming. everyone look busy!"
18:49:06 <monochrom> oh, actually, I haven't said the second sentence :)
18:49:35 <zq> :t join
18:50:14 <monochrom> I never hated lambdabot. except those times when I reminded people: lambdabot is not ghci, and ghci is not standard (be it Haskell 2010 or de facto). when code is accepted by lambdabot or ghci but not ghc, lamdabot and ghci is being wrong.
18:50:57 <recursion-ninja> true, but both ghci & lambdabot catch all the petty mistakes, that's why I love them
18:50:58 <zq> isn't ghci backed by ghc?
18:51:01 <rhz> how do I output a lazy infinite list in program compiled using GHC? It does not seem to be working the same as in GHCi.
18:51:18 <monochrom> ghci adds a lot of things on top of ghc
18:51:20 <jle`> rhz: what do you mean by output...?
18:51:35 <rhz> print it out
18:51:54 <rhz> until the user kills the process
18:52:04 <hughfdjackson> monochrom, merijn : it seems that there's such a Parser type defined in Text.Parsec.String :) I am, once again, compiling
18:52:05 <pjdelport> rhz: What's your code?
18:52:07 <hughfdjackson> thanks !
18:52:10 <zq> rhz: mapM_ print
18:52:44 <jle`> rhz: ghci basically prints out everything you enter into it; with haskell/.hs files, you have to write a program that prints it out
18:52:58 <rhz> zq: mapM_ did it. thanks
18:53:38 <zq> rhz: for posterity, there's a reason why print infinite_list didn't work. you should check it out. laziness is relevant.
18:54:01 <monochrom> wait, print [0..] works
18:54:12 <monochrom> even main = print [0..]
18:54:30 <zq> meh, what am i even saying then
18:55:01 <monochrom> but you may have to think about stdout buffering and how fast the buffer is filled so you actually get a flush
18:56:14 <monochrom> "mapM_ print xxx" may make a superificial difference because stdout is getting DoSed with newlines so you get more instant gratification.
18:56:41 <monochrom> but it still does not imply that laziness delays the output. output is never lazy.
18:57:05 <monochrom> it is not like the computer thinks "the human is afk, I don't need to output yet"
18:58:06 <recursion-ninja> monochom: maybe that's what lambdabot is thinking...
18:58:17 <monochrom> haha
19:08:15 <merijn> hmm
19:08:23 <recursion-ninja> hmm?
19:08:42 <merijn> I wonder who the hell decided that "calling shutdown on a closed socket should throw an exception" instead of just silently no-oping
19:08:56 <merijn> That seems ridiculously stupid design...
19:09:36 <merijn> Looks like I might just as well only call close and not bother with "shutdown"
19:09:37 <recursion-ninja> I understand your frustration... Any comments explaining why they did that?
19:10:08 <merijn> Seems like the C wrapper just always throws an exception if C returns a non-success value
19:11:19 <recursion-ninja> merijn: There probably needs to be better return value types in the wrapper, instead of a success/exception function
19:11:32 <monochrom> the same for Java closing streams. it's a pain to always write try{...}finally { try{ s.close(); } catch(e) {} }
19:12:00 <recursion-ninja> merijn: I have seen some very well-typed C wrappers before, and they are a joy to work with!
19:12:01 <merijn> monochrom: Is there any reason to not just call "close" directly and skip "shutdown"?
19:12:12 <monochrom> hmm, I don't know
19:12:37 <monochrom> actually I seldom call shutdown on sockets. C or Haskell. I just use ordinary close.
19:13:24 <monochrom> however, I have not done any strict tests or consulted any expert. I don't know what I am missing.
19:14:07 <joe9> I want to parse html table to haskell data or csv data. I am thinking of using html-conduit, but, cannot find any help on it.
19:14:15 <monochrom> oh! I think in the Haskell case, shutdown does a bit more than hClose, you may care about it.
19:14:30 <joe9> Any suggestions on where I can find some stuff on using html-conduit, please?
19:15:16 <merijn> monochrom: I'm not using hClose
19:15:29 <dmj`> joe9: you mean http-conduit?
19:15:30 <merijn> monochrom: I'm using close, because I'm not going through a Handle
19:15:35 <recursion-ninja> joe9: Soory, I haven't used it before
19:15:36 <monochrom> oops
19:15:47 <dmj`> oh nvm
19:15:48 <joe9> dmj`: https://hackage.haskell.org/package/html-conduit
19:15:56 <merijn> monochrom: Handle's have an MVar preventing concurrent access, Socket does not
19:16:13 <merijn> monochrom: So they have better characteristics for bi-directional operations
19:16:41 <jTT> Hey, I’m trying to work through the Conduit tutorial. Could anybody explain to me why I can’t even run the first example? I get the error: “Could not find module `Data.Conduit.List’”. I have tried to caba install Conduit ,and cabal install conduit-extra, and cabal install yesod…to no avail. What other packages do I need (and why would this not be stated in the TUTORIAL)?
19:16:50 <dmj`> joe9: I usually use tagsoup for html related stuff
19:16:59 <merijn> monochrom: Seems like shutdown is only useful to shutdown communication in one of two directions and calling shutdown in both directions has no added value over close in C (so presumably not here either)
19:17:14 <joe9> dmj`: http://hackage.haskell.org/package/taggy-lens seems simpler than tagsoup.
19:17:17 <monochrom> right, I misremembered. it's just being more flexible
19:17:27 <joe9> dmj`: but, I got lost trying to understand "to"?
19:17:50 <dmj`> joe9: if it uses lens its not simpler :)
19:18:25 <monochrom> so, you can use close. but it may throw exceptions wantonly. can't say I like it.
19:18:45 <joe9> dmj`: I understand. I thought "lens" is the new thing and makes thing simpler. But, it seems to be the opposite.
19:19:01 <merijn> monochrom: Lots of stuff in network seems to throw exceptions wantonly
19:19:49 <fuzzyhorns> do most haskellers believe functional is better than imperative? if so, what do you say when folks ask you why?
19:19:56 <dmj`> joe9: it makes things simpler yes, using it w/o understanding you'll hit a ceiling real fast
19:20:00 <pharpend> Hi guys, I have a file I need to compile, http://sprunge.us/dcBW . Getting this error - http://sprunge.us/JOcM . I have hakyll installed.
19:20:25 <joe9> dmj`: that is what I did.
19:20:39 <joe9> https://rawgit.com/ndmitchell/tagsoup/master/tagsoup.htm is this best material to understand tagsoup.
19:20:53 <jTT> in which package does Data.Conduit.List live?
19:21:09 <recursion-ninja> fuzzyhorns: trferential transpancy
19:21:16 <recursion-ninja> fuzzyhorns: referential transpancy
19:21:16 <merijn> fuzzyhorns: I'm not sure I think that, but I do believe haskell is more enjoyable imperative language than, say, C/C++/Python
19:21:22 <dmj`> fuzzyhorns: function composition is amenable to code refactoring, objects aren't
19:21:27 <dmj`> as well
19:21:32 <recursion-ninja> fuzzyhorns: the joys of tail recursion
19:21:44 <recursion-ninja> fuzzyhorns: type-class laws
19:21:55 <recursion-ninja> fuzzyhorns: PROOFS OF CORRECTESS!!!
19:22:11 <dmj`> fuzzyhorns: there's no consensus on what functional programming means
19:22:29 <trap_exit> recursion-ninja: which lanuage are you referring to?
19:22:42 <fuzzyhorns> yeah, i guess i tend to think at this point, that functional programming at core means subject to category theory roughly
19:22:45 <recursion-ninja> trap_exit: haskell of course
19:22:47 <fuzzyhorns> not always precisely formally
19:23:03 <trap_exit> recursion-ninja: Haskell does not have proofs of correctness. Idris / Isabelle / Coq do.
19:23:03 <fuzzyhorns> but moreso than imperative where i am often thinking about how i implement loops
19:23:07 <trap_exit> and I say this as someone hwo loves Haskell
19:23:15 <fuzzyhorns> which is something i think should be abstrated away from me :/
19:23:22 <recursion-ninja> trap_exit: right, but you can easily port the haskell code to Coq
19:23:28 <monochrom> the predicate transformer semantics for imperative programming receives category theory treatment, too.
19:23:30 <merijn> fuzzyhorns: Serious question: Where is this idea that "category theory" has some sort of strong relation to Haskell?
19:23:32 <trap_exit> recursion-ninja: in my experience, no
19:23:45 <trap_exit> merijn: I bet it was a ploy to keep cowards out of Haskell
19:23:46 <fuzzyhorns> monochrom: yeah? can you give me some source on that?
19:23:50 <trap_exit> which is why #haskell is so civil and intelligent
19:23:57 <recursion-ninja> trap_exit: and showing equivilence to what you put in Coq is much easier then proving the Haskell code is correct
19:24:01 <trap_exit> people are like #haskell = categhroty theory, OMG, let me troll #c++ instead
19:24:03 <merijn> Pretty sure that neither Simon's are too well versed in Category Theory
19:24:09 <fuzzyhorns> merijn: well, from what i understand, haskell really doesnt apply cat theory
19:24:34 <dmj`> merijn: hask?
19:24:43 <dmj`> http://www.haskell.org/haskellwiki/Hask
19:24:45 <recursion-ninja> trap_exit: in my 1 experiance, yes... but that may be due to a poor sample size
19:24:47 <fuzzyhorns> merijn: but given it is just a theory of fundamental mathematical objects, and haskell helps abstract closer to them, i think it is "closer" in some rough sense — does that make sense?
19:24:52 <monochrom> it's this book: http://ebooks.cambridge.org/ebook.jsf?bid=CBO9780511569821  it's scary, I have only successfully read the first page.
19:24:56 <merijn> dmj`: Do you think Hask is very relevant to the implementation and design of Haskell?
19:25:09 <dmj`> merijn: no, just seems more like a loose connection
19:25:38 <merijn> dmj`: Right, I'm willing to bet you can find a loose connection between CT and anything, because that's what makes CT attractive in the first place
19:25:53 <fuzzyhorns> monochrom: i should prob read, because i am beginning to feel to myself that functional (in the way i have defined it for myself :p, yknow, conveniently) is better, and it's best to stay a skeptic i imagine
19:25:53 <dmj`> that's a good point, its all encompassing really
19:26:05 <merijn> dmj`: My point was just that that link is so weak that I find it weird that so many people seem to think that CT is somehow very important to know for Haskell
19:26:07 <HeladoDeBrownie> If Haskell were designed with CT in mind, we'd have citations of CT principles in language proposals. But I've never seen one like that.
19:26:20 <fuzzyhorns> i just see CT as The abstraction in some sense
19:26:25 <merijn> While a lot of GHC hackers probably only have a passing familiarity with CT
19:26:30 <fuzzyhorns> and haskell as more abstract than most imperative languages ive handled
19:26:52 <trap_exit> let RWS = ReadWriteState. Is there a way to tag a function in RWS as "read only" ... i.e. I want a type signature that captures "this particular action only READS from RWS, it does not modify it"
19:26:55 <merijn> fuzzyhorns: CT as "the abstraction" make very little sense for haskell
19:27:05 <monochrom> . o O ( just wait until the language proposal "add Control.Lens to Haskell 2020" )
19:27:06 <recursion-ninja> fuzzyhorns: haskell is an order of magnitude more abstract then any imparative language I've used
19:27:22 <Hijiri> MonadRead class, maybe?
19:27:22 <merijn> fuzzyhorns: Lambda calculus and other lambda cube calculi are much more the basis of haskell then anything else...
19:27:25 <fuzzyhorns> merijn: indeed, it doesnt apply to haskell really
19:27:43 <fuzzyhorns> recursion-ninja: that is my feel, sure
19:27:43 <HeladoDeBrownie> monochrom, plus I'm sure there was a language proposal at some point for Monad, I just happen not to have read it :P
19:27:44 <Hijiri> I think RWS has a MonadReader instance
19:27:52 <HeladoDeBrownie> Well, not sure, but it seems likely
19:28:02 <Hijiri> you can make a function with a MonadReader constraint
19:28:17 <nshepperd> category theory provides abstractions that turn out to be useful in programming
19:28:19 <monochrom> ah, yes, Haskell 1.4 did not use Monad for I/O
19:28:19 <dmj`> merijn: probably because monads are associated with cat theory and haskell the language gives them special treatment (do notation). Simon even admitted the biggest failure of Haskell was calling them "Monads" and not "cute cuddly" things
19:28:41 <geekosaur> was discussing that with a coworker earlier today
19:28:50 <nshepperd> (because category theory abstractions are useful for everything)
19:29:04 <trap_exit> dmj`: did they consider calling it teddy bears ?
19:29:10 <recursion-ninja> fuzzyhorns: In all seriousness, when someone asks me "Why a functional language" I just say "It's easier to reason about, refactor, & scale"
19:29:12 <geekosaur> can't see the handful of small trees for the imagined dark forest
19:29:15 <fuzzyhorns> monochrom: the thing on my mind is that when you think about mathematical objects like things that have identities (so monoids on down iirc?) they can be subject to recursion (the identity functions as an edge case) so that a language where i can more easily talk about those structures is more abstract
19:29:34 <recursion-ninja> fuzzyhorns: but that doesn't mean it's easier to learn
19:29:36 <monochrom> well, of course, be it Monad and Control.Lens, the actual propose does not actually have to say "it's good category theory", it can say something else entirely.
19:29:40 <fuzzyhorns> recursion-ninja: well that's tough, right? because we have referential transparency but not necessarily strictness, and laziness can be hard to reason about
19:29:50 <monochrom> s/and/or/
19:29:53 <nshepperd> isn't the whole point that if you call them by some inscrutable mathematical term, beginners won't cling on to wrong analogies
19:29:58 <merijn> recursion-ninja: But even if you want an imperative language than haskell is still pretty good
19:30:11 <HeladoDeBrownie> nshepperd, whether that's the point or not, they do it anyway :)
19:30:14 <merijn> fuzzyhorns: I don't think laziness is harder to reason about than strictness, it's just *different*
19:30:17 <fuzzyhorns> well, i guess ill put it this way, merijn, why _would_ i want one?
19:30:18 <recursion-ninja> merijn: haha, your right!
19:30:31 <merijn> fuzzyhorns: In terms of computational complexity, that is. Space complexity can be trickier with laziness
19:30:56 <fuzzyhorns> merijn: hmm i have heard both are more complex given you dont know when things will be evaluated necessarily
19:30:56 <nshepperd> if Monads were called Containers, I think the problem would be way worse
19:31:10 <fuzzyhorns> indeed, they are monads for a reason, no?
19:31:15 <HeladoDeBrownie> nshepperd, undoubtedly, since "container" is one such wrong analogy that is sometimes used today
19:31:18 <monochrom> I don't attribute wrong analogies to being beginners.
19:31:34 <monochrom> all kinds of experts make wrong analogies, too.
19:32:05 <recursion-ninja> fuzzyhorns: Using Haskell professionally for a year, I never have had to reason about space/time complexity. It has never been bad enough to do profiling.
19:32:40 <dmj`> recursion-ninja: same
19:32:43 <fuzzyhorns> recursion-ninja: i can almost believe that, ive seen some powerful demonstrations of badly written haskell though at a meetup recently
19:32:47 <fuzzyhorns> so i consider it possible
19:33:02 <fuzzyhorns> like, i mean purposefully shown to be non-performant
19:33:14 <nshepperd> basically this -> http://xkcd.com/895/
19:33:31 <recursion-ninja> fuzzyhorns: the first 6 months (on the first project) I DID need a profiler. Then I got more idiomatic and all the problems went away
19:34:00 <fuzzyhorns> so can anyone give me the skinny on Predicate Transformer Semantics?
19:34:05 <fuzzyhorns> I dont have access to the pdf ;-;
19:34:21 <nshepperd> anyway, I guess Foldable is a good name
19:34:24 <dmj`> merijn: this goes back to the monoid argument though, to not call it a monad is to do injustice to just how generic the abstraction is.
19:34:57 <jle`> for monads?
19:35:18 <dmj`> to not call it a monoid* woops
19:35:18 <HeladoDeBrownie> Foldable is a good name for Foldable. For Monad, it's a terrible name. :P
19:35:28 <fuzzyhorns> yeah HeladoDeBrownie
19:36:43 <Kron> There's no way to export a data type while hiding its record fields, and yet expose the record fields to a separate test module right?
19:36:44 <nshepperd> yes
19:36:54 <merijn> ugh, debugging socket issues makes me sad :(
19:37:22 <nshepperd> I'm not sure there is a good "*-able" style name that aptly describes monads
19:37:33 <Kron> so... how would I solve this? stacking the exports?
19:37:51 <tromp> programmable?
19:37:58 <Axman6> nshepperd: and-then-able >_>
19:37:59 <HeladoDeBrownie> Kron, you could have a Foo.Internal module that exports the type and its constructors, but Foo only exports the type. Importing Foo.Internal would mean you're okay with using possibly invalid data.
19:38:19 <tromp> >>= is called a programmable semicolon by some
19:38:27 <Kron> ... that makes sense
19:38:29 <Kron> okay, thanks
19:38:41 <fuzzyhorns> monochrom: so it looks like predicate transformer semantics is ultimately about the same kinda stuff?
19:38:41 <Kron> thanks
19:38:46 <merijn> Racket allows you to have different exports in different compilation stages (i.e. testing vs compiling, etc) that seems much nicer
19:38:51 <usr> Racketeering?
19:38:55 <nshepperd> ;-able
19:38:56 <dmj`> Kron: make a seperate Tests module, export them there, don't make it public in the cabal file?
19:39:11 <Axman6> > let (;) = (>>=)  in Just 1 ; Just
19:39:27 <Axman6> damnit lambdabot
19:39:27 <monochrom> same kind of stuff as what? as functional programming? that may be true.
19:40:36 <nshepperd> I think you'd need some extension to be able to use ; as an identifier
19:40:36 <Kron> would it be possible to have a completely public source file, and a separate "export interface" module that imports all the source files and only exports the functions that need to be exported?
19:40:37 <fuzzyhorns> monochrom: as cat theory, im seeing monads, categories, morphisms, maps etc
19:40:44 <fuzzyhorns> unsure what this is though: weakest-precondition
19:40:51 <fuzzyhorns> oops dunno why that was bold
19:41:01 <Axman6> Kron: this is usually what Data.Foo and Data.Foo.Internal are used for
19:41:01 <trillioneyes> Source files are completely public by default if there's no export list
19:41:28 <monochrom> predicate transformer semantics did not begin category-theoretically. the book adds category theory to it.
19:41:40 <Kron> oh? there's a standard for this? you list it as .Internal?
19:42:09 <fuzzyhorns> monochrom: sure, plenty of stuff doesnt begin there, but does it end up there heh
19:42:21 <HeladoDeBrownie> Kron, not so much a standard as a convention, or at least I've seen some modules do it
19:42:22 <monochrom> but on weakest precondition, it's pretty easy. do you already know Hoare's idea: {pre-condition} program {post-condition} ?
19:42:33 <fuzzyhorns> monochrom: no i dont yet :c
19:42:44 <Kron> how would you name the file?
19:42:58 <Kron> "Library.Internal.hs"?
19:43:21 <HeladoDeBrownie> Kron, no, you use the directory structure. So, Data/Foo.hs or Data/Foo/Internal.hs for the two Axman6 said
19:43:22 <trillioneyes> I think Library/Internal.hs
19:43:29 <Kron> gotcha
19:43:56 <Kron> thanks, I'm looking for standards like this
19:43:59 <monochrom> suppose my program is simply x:=x+5. suppose you know x=1 before running my program. then you know what happens after. {x=1} x:=x+5 {x=6}
19:44:22 <fuzzyhorns> monochrom: so, state?
19:44:34 <merijn> Hoare logic \o/
19:44:35 <fuzzyhorns> monochrom: and a function that only has one output for one input?
19:44:45 <fuzzyhorns> i have so much to learn ._.
19:45:30 <monochrom> here is a more interesting example. {x>=4} x:=x+5 {x>=9}. my precondition and postcondition do not have to be deterministic. (eventually, my program does not have to be deterministic, either)
19:46:20 <monochrom> actually, even the original x=1, x=6 were not deterministic either. I said nothing about the other variable y. I allowed anything to happen to it, and not care.
19:46:37 <fuzzyhorns> monochrom: how is your new example non-deterministic though?
19:46:52 <monochrom> the program is still deterministic. but x>=4 is not.
19:47:30 <fuzzyhorns> monochrom: hmm, i guess i hadnt thought about determinism like that
19:47:44 <Kron> is there a standard for an "exports" package of sorts?
19:47:45 <fuzzyhorns> monochrom: to me it is determined in the only way salient to the postcondition
19:48:18 <fuzzyhorns> monochrom: so then do you think predicate transformer semantics describes the same thing as what else?
19:48:31 <Kron> because I know there's haddock support for re-exporting an entire module
19:48:34 <monochrom> ok next, Dijkstra had this great idea. {???} x:=x+5 {x>=9}. you can solve for the ???. many things fit there, but exactly one of them is the weakest of all. weakest precondition.
19:48:58 <fuzzyhorns> AHHHH yes that makes a lot of sense
19:49:01 <merijn> argh
19:49:19 <fuzzyhorns> thank you monochrom :) always very helpful your clarifications
19:49:27 <merijn> I'd like to go on record saying that the C++ ZeroMQ library is a piece of shit >.<
19:49:48 <fuzzyhorns> merijn: ooh i am actually curious what you think of that protocol
19:50:03 <fuzzyhorns> merijn: not that specific implementation (you have my condolences :p)
19:50:42 <monochrom> for each program prog, you give me a postcondition Q, I can solve for the weakest precondition for {???} prog {Q}. so Dijkstra says, how about saying that prog is a function that maps postconditions to weakest preconditions? this is his weakest precondition semantics.
19:50:50 <merijn> I like the semantics of ZMQ, it has room for improvement, but Pieter Hintjens whose working on it seems open to improvement
19:51:19 <fuzzyhorns> monochrom: that is awesome, but what paradigm does it relate to? i dont see how it necessarily has any relation to imperative
19:51:37 <monochrom> then I suddenly realize: the way people prove imperative programs correct, is to first turn imperative programs into functional programs. look, Dijkstra is saying that the program is a function, just a surprising kind
19:51:38 <merijn> I'm trying to test my haskell implementation against the C++ library, but it uses some sort of lazy binding which means my haskell code goes "nothing's listening on that address"
19:52:07 <monochrom> well, x:=x+5 is an imperative program. there are also while-loops
19:52:11 <monochrom> the only thing it omits is I/O
19:52:19 <fuzzyhorns> monochrom: how is it imperative?
19:52:26 <fuzzyhorns> perhaps I am thinking wrong
19:52:35 <monochrom> people say that it's imperative.
19:52:40 <fuzzyhorns> it assigns to an accumulator reference I guess
19:53:07 <jTT> I have no idea wtf is wrong with cabal. I installed cabal install Conduit in my sandbox. Adn when using runhaskell test.hs that imports Data.Conduit I get the message Could not find module ‘Data.Conduit’ … package management in haskell renders this whole language useless for efficient work
19:53:09 <fuzzyhorns> but in isolation i dont think of that as imperative, i guess i think imperative is when we continue the implementation details of that acc reference
19:53:44 <fuzzyhorns> jTT: it can be tough yeah :c i have globally installed some packages i use a lot, not sure that is advisable though :/
19:53:54 <merijn> jTT: Here's where you go wrong "I installed Conduit into my sandbox" and "I ran runhaskell"
19:54:01 <kadoban> jTT: Doesn't runhaskell and friends ignore the sandbox?
19:54:02 <merijn> jTT: runhaskell doesn't know anything about sandboxes
19:54:16 <merijn> jTT: Why would it? Sandboxes are a cabal thing, runhaskell is part of GHC
19:54:22 <fuzzyhorns> jTT: hah! now that oyu asked i learned too x)
19:54:25 <merijn> jTT: Use "cabal run"
19:54:37 <jTT> ha man
19:54:49 <jTT> thx. info about this is so ridiculously scattered
19:55:03 <fuzzyhorns> jTT: yeah D:
19:56:40 <monochrom> fuzzyhorns, when I say "imperative", I'm just using people's convention. but if you read what I said between the lines, there is hint that I no longer make any mathematical distinction between imperative and functional.
19:56:49 <merijn> oh, ffs
19:56:59 <merijn> I'm going to stab someone
19:57:08 <merijn> I found out why it's not working...
19:57:25 <gcganley> :merijn woah there i came in to read the wrong message
19:57:41 <fuzzyhorns> monochrom: i guess i think implementing loops and stuff is not as abstract, and that is why functional is more abstract than imperative, easier to see the math in
19:57:47 <merijn> For some ridiculous reason "PortNum (fromIntegral 1337)" results in Network trying to bind port 14597
19:58:46 <gcganley> :merijn i thought it was called PortNumber...
19:58:48 <fuzzyhorns> monochrom: reading this now http://www.cs.cornell.edu/courses/cs6110/2014sp/lectures/lec16.pdf
19:58:51 <merijn> So someone is probably doing something stupid like converting from host to network byte-order in a place they *really* shouldn't
19:58:57 <geekosaur> it is indeed ridiculous
19:59:10 <merijn> This explains why my haskell to haskell test worked...
19:59:26 <geekosaur> worse than that' iirc one constructor is network and one is host
19:59:37 <merijn> It has this bug in both the connect and listen, but C does "the right thing" and thus never listened to my connection attempts
19:59:47 <jude> why does "(return . (+1)) =<< Left 1" not increment but "(return . (+1)) =<< Right 1" does?
19:59:52 <fuzzyhorns> monochrom: preconditions and postconditions, i dont see how theyre different from inputs and outputs, or domains and codomains
20:00:19 <fuzzyhorns> monochrom: in that, it is still distinct from monitoring state assignments inside a function iteratively
20:00:33 <gcganley> > (return . (+1)) =<< Left 1
20:00:53 <gcganley> > (return . (+1)) =<< Right 1
20:01:22 <geekosaur> oh, right, PortNum is NBO, use fromIntegral on a hostbyte order *without* the constructor]
20:01:26 <jmcarthur> jude: because (>>=) for the (Either a) instance only passes the Right value along. Left is a way of interrupting
20:01:29 <geekosaur> screwy
20:01:48 <jTT> merjin: cabal run still can’t deal with the packages in the sandbox. ffs
20:01:50 <recursion-ninja> sorry I dropped out randomly, my cumputer didn't tell me it was hungry and then it died X(
20:02:00 <merijn> geekosaur: And no warnings in the docs of course
20:03:11 <fuzzyhorns> monochrom: where you saying that predicate transformer semantics essentially model "imperative" programs as "functional" rendering the difference between the paradigms moot?
20:03:28 <monochrom> yes
20:03:49 <recursion-ninja> fuzzyhorns: what did I miss!? Sounds deep!
20:04:00 <fuzzyhorns> monochrom: i guess i only dont get the first part of that, because it reads so far to me like it is just functional programming x)
20:04:11 <fuzzyhorns> recursion-ninja: oh just me continuing to not understand, nothing super exciting :)
20:04:19 <jude> ahh thanks jmcarthur
20:04:27 <fuzzyhorns> but monochrom is being good enough to humor me with some interesting info on predicate transformer semantics
20:04:42 <kazagistar> jude: generally, Left is like ExitWithError, and Right is ContinueWithValue
20:04:51 <recursion-ninja> fuzzyhorns: The best part of Haskell is it makes ALL of us eternal students!
20:05:21 <jude> kazagistar: oh cool, that makes sense
20:05:22 <fuzzyhorns> haha oh i felt that way about life even before haskell, but it sure is lively, recursion-ninja ;)
20:05:58 <monochrom> fuzzyhorns, if you think of mapping input to output, you say, ok, the input is an element of a state space, call it S; similarly the output. so a program is a function of type S->S. you can do that, but Dijkstra trumps you... Dijkstra goes P(S) -> P(S) (but insists on monotonic functions). it's a much larger space. it includes non-deterministic programs.
20:06:03 <merijn> whoo
20:06:07 <merijn> Now it works :D
20:06:53 <fuzzyhorns> monochrom: but how is it related specifically to an imperative style? to me that is functional, that's what I'm not grokking i think
20:07:16 <monochrom> normally, functional programs still stay with S->S.
20:07:31 <fuzzyhorns> monochrom: oh?
20:07:39 <fuzzyhorns> monochrom: there's where i'm not getting it, how so?
20:08:12 <monochrom> you write like "f x = x + 1". you just reason at the level of Int -> Int. you don't even worry about P(Int)->P(Int)
20:08:12 <recursion-ninja> fuzzyhorns: I forgot the other this to tell people when they ask "Why a functional language?"
20:08:28 <recursion-ninja> fuzzyhorns: "functional lanuages make cuncurrency WAY simpler"
20:09:07 <fuzzyhorns> recursion-ninja: i am wondering if any of that is true, given what monochrom is asserting about predicate transformer semantics (Im gonna start saying PST lol)
20:09:15 <fuzzyhorns> err PTS :P
20:09:16 <merijn> recursion-ninja: So you'll debug my multi-threaded haskell for me? ;)
20:09:50 <monochrom> well, Dijkstra's story doesn't do concurrency either. he had a nicely cut out job.
20:10:05 <fuzzyhorns> merijn: question, when you wrote it, did you write it to accumulate sequentially, or to provide partial solutions merge-able in any order?
20:10:51 <fuzzyhorns> monochrom: so whats the relationship of P(Int) -> P(Int) to dependent types?
20:10:57 <jmcarthur> i also find that haskell makes concurrency much easier (but that's not an invitation to debug random haskell code sample. i'm only speaking from experience with my own code...)
20:11:00 <monochrom> no relation
20:11:02 <merijn> fuzzyhorns: Accumulate what?
20:11:05 <fuzzyhorns> because arent you setting up a type that has a limited and defined domain?
20:11:19 <merijn> jmcarthur: Sure, it's easier than in C in some ways, but still hard
20:11:27 <fuzzyhorns> merijn: whatever your result will be, is it merged in the end, or accumulated over the process?
20:11:35 <jmcarthur> i've actually never felt that concurrency is so hard
20:11:57 <fuzzyhorns> jmcarthur: do your concurrency solutions make use of merging or accumulation?
20:12:02 <recursion-ninja> merijn: I've used concurrecy a few times "because I can" the code could have been run sequentially but the code blocks weren't dependant on each other so why not run them concurrently! In an imperative langugage the overhead would be a nightmare for adding in som "trivial concurrecy" but in Haskell it was completely painless. That was my experiance at least. Your milage may vary with varying complexity...
20:12:02 <merijn> jmcarthur: Do you use async exceptions?
20:12:13 <jmcarthur> merijn: i avoid them
20:12:21 <merijn> jmcarthur: Right, then it's easy :)
20:12:24 <jmcarthur> fuzzyhorns: are you talking about concurrency or parallelism?
20:12:29 <jmcarthur> merijn: fair enough :)
20:12:36 <merijn> jmcarthur: If you need to dynamically cleanup/kill threads you can't really avoid them
20:12:46 <fuzzyhorns> jmcarthur: good q, i guess the latter, but now i am unsure of what i feel the diff really is
20:13:13 <jmcarthur> merijn: oh, sure, but i generally don't allow threads i need to kill to carry state that needs to be cleaned up
20:13:17 <kazagistar> I've never had to do concurrency beyond that which could be managed by simple map-reduce style semantics
20:13:37 <jmcarthur> fuzzyhorns: concurrency is a programming abstraction. parallelism is an optimization.
20:13:37 <fuzzyhorns> monochrom: so what is P(Int) really? isnt it just a specific domain of Int?
20:13:44 <merijn> Is there a nicer way to silence defaulting warnings than "foo . (polyFun :: Foo -> Bar) . bar"?
20:13:46 <jmcarthur> fuzzyhorns: threads often conflate the two
20:13:50 <monochrom> powerset of Int. pretend that Int is a set.
20:14:00 <fuzzyhorns> jmcarthur: that sounds like a good distinction, i think ive been guilty of conflating them for sure at times
20:14:09 <merijn> jmcarthur: I prefer to say that parallelism is an implementation, but yeah :)
20:14:18 <fuzzyhorns> monochrom: why would i care about the powerset? i am confused :c
20:14:33 <kazagistar> oh, I guess I have done "event driven web servers", but all the concurrency there was done by databases anyways
20:14:33 <monochrom> a condition corresponds to a subset.
20:14:44 <fuzzyhorns> monochrom: precondition and postcondition are just sets that have maps between them
20:14:47 <jmcarthur> merijn: well, parallelism doesn't imply concurrency, so i don't like the implementation point of view
20:14:48 <monochrom> condition x>=4 corresponds to the subset {4, 5, 6, ...}
20:15:20 <merijn> jmcarthur: I meant "parallelism is an implementation technique/detail" (not of concurrency, but in general), whereas "concurrency is a programming model"
20:15:25 <fuzzyhorns> monochrom: oh right set of all subsets, sorry my brain was reading that superset -_-
20:15:26 <jmcarthur> ah
20:15:32 <jmcarthur> merijn: i'm down with that
20:16:04 <fuzzyhorns> in any case wouldnt parallelism and concurrency be subject to the same modeling?
20:16:51 <monochrom> I am not sure.
20:17:00 <fuzzyhorns> monochrom: still dont quite get the connection to imperative yet, sorry bud :c
20:17:25 <fuzzyhorns> monochrom: I think I follow about these powersets, but again, arent those domains and codomains? just cat theory then?
20:17:38 <kazagistar> coroutines still count as concurrency, but they don't invoke nondeterminism, right?
20:17:49 <jmcarthur> fuzzyhorns: an example of parallelism without concurrency would be SIMD, data parallelism, map reduce, etc. an example of concurrency without parallelism would be coroutines (either preemptive or cooperative).
20:17:54 <monochrom> people say that "x:=x+5" is an imperative program. I don't want to explain why.
20:17:55 <merijn> fuzzyhorns: The problem is that if you have a function "void foo(void)" in C, then you still need to track ALL possible pre/post conditions
20:18:11 <fuzzyhorns> monochrom: haha I dont get why they say that I guess x)
20:18:13 <jmcarthur> kazagistar: if you mean they are cooperative / explicitly yield control to each other, right
20:18:35 <merijn> fuzzyhorns: Whereas with pure functional programming a piece of code can only affect it's outputs and *only* based in it's inputs/free variables
20:18:38 <fuzzyhorns> monochrom: but thats fair if you dont feel like explaining
20:18:54 <merijn> fuzzyhorns: In other words, the amount of state to think about is exponentially smaller
20:18:57 <fuzzyhorns> merijn: so because you have an assignment operator?
20:19:04 <kazagistar> jmcarthur: right, exactly, like lua "threads" or python "generators" for example
20:19:06 <fuzzyhorns> assignment operator = imperative?
20:19:10 <jmcarthur> kazagistar: but you could also start with that and just add a scheduler of some sort, then you essentially get nondeterminism again (unless the behavior of the scheduler is included in the semantics)
20:19:34 <merijn> I'm not sure there's a very formal definition of imperative
20:19:47 <fuzzyhorns> but PTS still apply even with the assignment operator programs basically?
20:19:53 <fuzzyhorns> merijn: Im not sure either :/
20:20:10 <monochrom> yes, PTS totally talks about mutable state
20:20:24 <fuzzyhorns> I do feel there is something to the difference between programs which yield to, hmm, associativity of computations? as opposed to needing sequential operations on a reference
20:20:32 <monochrom> or rather, talks about programs that talks about mutable state
20:20:56 <fuzzyhorns> monochrom: I mean, arguably doesnt functional too? it just contains that state where we never experience it
20:20:57 <jmcarthur> fuzzyhorns: there's "denotative", which is at least well defined
20:21:10 <fuzzyhorns> im never sure if state isnt kinda a red herring in the discussion :/
20:21:22 <monochrom> yes. I am not a big fan of drawing a line.
20:22:12 <fuzzyhorns> so one thing I do notice though, is that with the vast majority of "imperative" languages I am able to pick up a new one very quickly as it is never _that_ different from others
20:22:22 <fuzzyhorns> but haskell has taken me a little longer to really "get" I think
20:22:38 <fuzzyhorns> is that something native to the language? and if so, how to describe it? ive leaned on "its functional" but idk
20:23:08 <monochrom> is there a big difference between SML and Haskell, for example?
20:23:31 <edwardk> monochrom: laziness changes a lot about how you program
20:23:35 <jmcarthur> fuzzyhorns: i bet you understand *Haskell* more than you think. the libraries are just much more interesting than most libraries in imperative languages, i think.
20:23:38 <fuzzyhorns> monochrom: ive never used SML, but ive heard there are "important" differences, i think i recall laziness and modules
20:23:49 <fuzzyhorns> jmcarthur: yeah, so what explains _that_ do you think?
20:24:05 <fuzzyhorns> i really do feel as if learning haskell has improved my programming but i guess i struggle to explain to others why
20:24:10 <jmcarthur> fuzzyhorns: more expressive power. libraries are most like little embedded languages of their own.
20:24:16 <fuzzyhorns> im thinking on it given how i dont know anyone else at work that is into it
20:24:32 <edwardk> fuzzyhorns: i write more abstract code in haskell than i do in other languages because the language is expressive enough to allow me to do so while retaining the ability to reason about the code I write.
20:24:39 <jmcarthur> fuzzyhorns: have you read The Next 700 Programming Languages?
20:24:46 <fuzzyhorns> edwardk: that is my feel too :/
20:24:48 <monochrom> is there a big difference between Scheme macros (emphasis: macros, not the non-macro parts)  and Haskell? :)
20:24:57 <jmcarthur> fuzzyhorns: http://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf
20:25:04 <fuzzyhorns> jmcarthur: oh only bits, i meant to go back to it!
20:25:33 <fuzzyhorns> ISWIM!
20:25:35 <jmcarthur> fuzzyhorns: i think section 8 of that paper explained fairly precisely how i distinguish functional style (or more precisely, denotative style) from imperative style
20:25:43 <fuzzyhorns> hehe ive read about that and not finished this original source
20:26:03 <fuzzyhorns> jmcarthur: denotative im not sure ive heard that. any relation to declarative?
20:26:26 <fuzzyhorns> i guess my feel about functional is just that it more easily yields to algebraic transformation, and that is huge in simplifying programs :/
20:26:59 <fuzzyhorns> but now i wonder from monochrom's PTS stuff if I learned that Id feel the same about what I think of as imperative right now 9_9
20:27:21 <monochrom> yes, I algebraically rewrite imperative programs too. I know how.
20:27:42 <jmcarthur> fuzzyhorns: denotative is a bit more specific than declarative, i think. it essentially just means that programs are made up of expressions, each of which has a well-defined meaning, and whose meanings are defined only by the meanings of their subexpressions
20:27:54 <monochrom> Haskell is of course yet simpler.
20:27:58 <recursion-ninja> monochrom: that is much more "hands-on" then with Haskell though, correct?
20:28:08 <recursion-ninja> monochrom: beat me to it ;)
20:28:36 <fuzzyhorns> monochrom: id really like to see you go through that process
20:28:45 <fuzzyhorns> monochrom: though i can kinda imagine how it is possible
20:30:02 <fuzzyhorns> monochrom: my thought is that it would still be more complex if you have to essentially simplify assignments AND functions, no?
20:31:21 <fuzzyhorns> monochrom: "Dijkstra's http://en.wikipedia.org/wiki/Guarded_Command_Language (GCL) is an extension of the simple imperative language" idk if i should read that as "still imperative" or "beyond imperative" ;)
20:31:41 <monochrom> it is still imperative
20:31:52 <monochrom> it adds non-determinism
20:32:06 <fuzzyhorns> monochrom: so what is your core definition of what imperative vs functional is?
20:32:21 <hughfdjackson> monochrom, merijn : this is a 'thanks again'
20:32:52 <hughfdjackson> :) got a decently terse parser going for floats, ints, strings and identifiers + unit tests after your helpful interventions
20:33:27 <monochrom> the greatest invention of those who prove imperative programs correct, compared to those who prove functional programs correct, is that they embrace non-determinism.
20:34:04 <monochrom> this is important because, eventually, both groups say, "let's unify 'program' and 'specification'".
20:34:46 <monochrom> now what happens is that, if you only allow deterministic specifications (the functional group does this), it sucks, it's very inflexible, you always have to over-specify things that shouldn't matter.
20:35:15 <fuzzyhorns> monochrom: oh? how so? id think the opposite
20:35:44 <recursion-ninja> monochrom: I'd like to know too!
20:35:50 <fuzzyhorns> (brb)
20:35:53 <monochrom> the imperative group gets this aspect right. even when I aim for Haskell code, I want to be able to write a non-deterministic specification.
20:37:16 <monochrom> this specification is non-determinisitic: if the parameter x is >=0, the return value is a list of x copies of 'c'; otherwise, the return value is whatever you like.
20:37:30 <monochrom> a specification that comes with a precondition, basically.
20:38:26 <jmcarthur> don't we normally just model this ability to talk about "whatever" with _|_ in Haskell Land?
20:38:39 <jmcarthur> i feel like i'm missing an important point
20:38:42 <monochrom> the programming language is deterministic. I have no argument with that. but before I code, when I'm specifying, I need the flexibility.
20:38:58 <jmcarthur> ah, you are talking about simplifying the specification
20:39:05 <recursion-ninja> jmcarthur: _|_ isn't a value, it is a nonterminating computation
20:39:15 <monochrom> no, "otherwise, the result is bottom" is deterministic. it says it must be bottom. not even [].
20:39:24 <recursion-ninja> jmcarthur: If I recall my computabality theory correctly
20:40:00 <jmcarthur> recursion-ninja: _|_ is included in common *models* of partiality
20:41:01 <jmcarthur> monochrom: i see the distinction, though not how it simplifies anything. i do agree in general that non-determinism can be a great way to simplify a specification, although by the end i almost always want to remove the non-determinism...
20:41:02 <recursion-ninja> jmcarthur: I'll admit, my understanding of _|_ isn't comprehensive
20:41:03 <monochrom> another case: when I am specifying a numerical task, I want to say: f x should be within 0.01 of the square root of x. this is also a non-deterministic specification.
20:41:08 <merijn> recursion-ninja: You are correct
20:41:14 <fuzzyhorns> monochrom: so do you mean literally "otherwise, the return value is whatever you like" part of the spec is what makes it non-deterministic?
20:41:22 <monochrom> yes
20:41:51 <monochrom> in fact, I don't feel like writing out the otherwise clause at all. we know basic logic. we know what "if" means.
20:41:59 <merijn> recursion-ninja: To the compiler all bottoms are the same (that's one way of saying there's only one bottom) which is what leads to counter-intuitive corner cases in imprecise exceptions
20:42:14 <fuzzyhorns> monochrom: i enjoy hearing your view on this, as it seems opposite to what i often hear which is essentially, specify the domain and codomain deterministically — but you say that is bad why? the inflexibility is bad why?
20:42:43 <monochrom> how do you specify "f x should be within 0.01 of the square root of x" deterministically?
20:43:00 <fuzzyhorns> merijn: though (_|_,_|_) != _|_ right?
20:43:38 <merijn> > (undefined, undefined) /= undefined
20:43:39 <monochrom> Richard Bird has totally not talked about that.
20:43:42 <recursion-ninja> fuzzyhorns: that is a tuple of two "yet to be evealuated functions, when in WHND
20:43:46 <fuzzyhorns> monochrom: what does deterministic mean to you? f x has only one answer for any one input? idk see why the rest is relevant
20:43:50 <merijn> oh, crap, no lambdabot :(
20:44:00 <merijn> I keep forgetting >.>
20:44:13 <fuzzyhorns> merijn: i ask because i only know roughly of it, but not the why of it :)
20:44:19 <recursion-ninja> fuzzyhorns: then when the first is evanuated THE ENTIRE PROGRAM becomes _|_ if I understand my computability theory correctly
20:44:30 <monochrom> Richard Bird has only talked about: write a readable but inefficient implementation, call it the specification, now rewrite to efficient code.
20:44:31 <fuzzyhorns> though generally null set is not the same as a set of two null sets
20:44:41 <merijn> fuzzyhorns: Well, what does "(_|_, _|_) != _|_" means to you?
20:44:44 <fuzzyhorns> monochrom: source?
20:44:47 <recursion-ninja> merijn: am I correct in that?
20:44:50 <dmj`> monochrom: is birds new book out yet?
20:44:53 <merijn> fuzzyhorns: I have the imprecission it's not a very sensible question
20:45:01 <monochrom> having read all sorts of Bird's articles.
20:45:01 <merijn> s/imprecission/impression
20:45:38 <fuzzyhorns> merijn: just that is it really true that all bottoms are the same? i guess a set of bottoms is not a bottom though, i was thinking through myself :x
20:45:41 <monochrom> dmj`: do you mean "pearls in functional programming"? that one has been out for a few years.
20:45:54 <fuzzyhorns> trying to see if I was following, merijn :X
20:45:55 <merijn> fuzzyhorns: At a theoretical level, all bottoms are equal, yes
20:46:07 <dmj`> monochrom: I believe there's one with a tiger face cover, not sure why I remember that detail
20:46:17 <merijn> fuzzyhorns: Haskell gives you imprecise exceptions which give you some form of discrimination between different exceptions
20:46:18 <HeladoDeBrownie> (_|_, _|_) is not bottom in a lazily evaluated language
20:46:30 <merijn> fuzzyhorns: Although even there are surprising corner cases
20:46:33 <jmcarthur> HeladoDeBrownie: it could be. it depends on how the language treats tuples
20:46:40 <recursion-ninja> fuzzyhorns: I think an understanding of evaluation and "Weak Head Normal Form" come into play when dealing with Types and _|_
20:46:44 <shiona> > (\(_,_) -> true) (undefined, undefined)
20:46:45 <fuzzyhorns> HeladoDeBrownie: yeah
20:46:52 <shiona> ah, still no lambdabot
20:46:56 <fuzzyhorns> HeladoDeBrownie: that is what i thought
20:47:03 <HeladoDeBrownie> jmcarthur, perhaps I overgeneralized. It would be true of Haskell, correct?
20:47:07 <merijn> fuzzyhorns: See the first answer here: https://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
20:47:17 <fuzzyhorns> recursion-ninja: beyond my knowledge :)
20:47:26 <monochrom> fuzzyhorns: a deterministic specification, when translated to a subset, has at most 1 element. your reasoning, "but f x is only one value", is what a lot of people say when they reject non-deterministic specifications too, but this completely misses the point of specifications.
20:48:01 <fuzzyhorns> monochrom: does it?
20:48:18 <recursion-ninja> merijn: I have a question; As soon as a Haskell program encounters _|_ throught  the course of evaluation, the entire Haskell program evaluated to _|_ and results in an exception. Am I correct in that?
20:48:20 <jmcarthur> HeladoDeBrownie: e.g. i think  (# _|_, _|_ #)  would be best modeled as bottom, in ghc  (in the sense that it doesn't make sense to evaluate the tuple, since unboxed tuples don't really exist, so you're really inspecting at least one of the components of the tuple)
20:48:36 <fuzzyhorns> monochrom: also is that true? because i would think a function that can take 3 values and always return the same 3 outputs for those values is deterministic
20:48:45 <merijn> recursion-ninja: If we disregard exceptions, yes.
20:48:52 <jmcarthur> HeladoDeBrownie: what you said is true of the built-in haskell tuples
20:48:53 <monochrom> f x is only one value. but until I choose an implementation strategy, I ought not commit to which value. y-0.01 <= f x <= y+0.01 is a perfectly good specification.
20:48:58 <recursion-ninja> fuzzyhorns: read about weak head normal form (WHNF) and I think types composed of _|_ will become clearer
20:49:03 <merijn> recursion-ninja: If we consider exceptions, consult the imprecise exception semantics paper
20:49:26 <fuzzyhorns> recursion-ninja: thanks :)
20:49:28 <recursion-ninja> merijn: Thanks for the input, I'll look for that paper
20:49:35 <monochrom> x>=0 ==> f x = blahblah  is also a perfectly good specification
20:49:46 <merijn> recursion-ninja: Pretty sure it's linked from the Control.Exception docs
20:50:02 <zereraz> how to find the screen size in haskell?
20:50:07 <zereraz> the width and height
20:50:17 <fuzzyhorns> monochrom: i find that very backwards, I must be missing something
20:50:41 <fuzzyhorns> monochrom: why wouldnt I want my definitions first, to get my implementation towards it, rather than the other way round?
20:51:04 <fuzzyhorns> monochrom: an imprecise one only means i am unclear about what I want
20:51:09 <monochrom> not all specifications are definitions.
20:51:22 <zereraz> ?
20:51:24 <monochrom> eh? rather, I am clear about what I tolerate.
20:51:48 <fuzzyhorns> monochrom: i am used to decomposing business stories (specs?) into unit tests in my relam
20:51:49 <monochrom> I am clear about how much freedom I give to the implementer.
20:52:03 <fuzzyhorns> monochrom: I thought you were saying the opposite though
20:52:18 <recursion-ninja> merijn: How would I find the Control.Exception docs; that's not the stuff on Hackage right?
20:52:28 <fuzzyhorns> monochrom: by saying well, this degree of precision is ok, you are defining implementations, no?
20:53:31 <zereraz> ?
20:54:03 <merijn> recursion-ninja: Sure it is
20:54:13 <merijn> It's part of base
20:55:14 <monochrom> what is "defining implementation"? does "y-0.01 <= f x <= y+0.0" define implementations?
20:56:23 <fuzzyhorns> monochrom: i guess i mean, when you allow the non-determinism, that is you allowing certain implementations
20:56:26 <fuzzyhorns> why allow those?
20:56:45 <recursion-ninja> merijn: I was looking for a link, not an italicized reference... feel dumb...
20:56:49 <fuzzyhorns> also https://i.chzbgr.com/maxW500/7061429248/h9256C5CF/
20:56:51 <fuzzyhorns> lol
20:56:53 <monochrom> Bird seldom writes that kind of specifications. almost never. most specifications he shows is "f x = code_version_0". never an indirect property of f x.
20:57:12 <fuzzyhorns> monochrom: who is this bird? :c
20:57:33 <monochrom> Richard Bird is a prof who worked much on proving functional programs correct
20:57:56 <monochrom> why not allow those implementations?
20:58:14 <fuzzyhorns> monochrom: haha, i mean, id love to hear why they are useful or not
20:58:22 <fuzzyhorns> I am not sure I have a strong opinion on it atm
20:58:53 <bms1> Suppose I have data MyDat a = MkMyDat Int
20:59:08 <bms1> f :: MyDat String -> MyDat Bool; f (MkMyDat x) = MkMyDat x
20:59:27 <bms1> does f compile to a no-op? Or does it have some sort of computational content?
21:00:13 <ratsen> How to get screen width and height in haskell
21:00:45 <bms1> ratsen: HsCurses/nanocurses?
21:01:20 <merijn> bms1: Inspect the Core and check for yourself?
21:01:28 <monochrom> bms1: I think it still compiles to non-zero work. there is a future improvement.
21:01:46 <ratsen> bms1, Is this for the terminal size or screen size
21:02:00 <bms1> ratsen: Oh, terminal size
21:02:21 <ratsen> What about screen size
21:02:45 <bms1> merijn: Well, looking at the simplifier output I imagine it's still there (to keep track of the types). I guess if I look at STG it might not? I'll check it out!
21:02:51 <merijn> bms1: If you make MyDat a newtye it should be guaranteed to be a no-op
21:03:37 <recursion-ninja> merijn: The imprecise exceptions semantics paper looks very interesting. Thanks for bringing it to my attention. I'll read it when I am less sleepy!
21:03:41 <merijn> bms1: Also, look into roles and the new safe "coerce" function
21:03:43 <bms1> merijn: That's true. Though I'm asking in the context of more complicated GADT-like stuff
21:04:02 <bms1> merijn: okay, I'll look into that
21:04:26 <merijn> bms1: Because that's exactly what "coerce" and roles where designed for, no-op coercion between identical data
21:04:42 <bms1> oh!
21:04:51 <zereraz> what if I find screen size in c++ and somehow access it with haskell
21:04:51 <merijn> Type safely, that is
21:05:02 <zereraz> if haskell does not have a way to do it itself
21:05:04 <HeladoDeBrownie> zereraz, that would be a possibility, you can use the FFI
21:05:21 <zereraz> HeladoDeBrownie: I am going to read that chapter in real world haskell now
21:05:46 <HeladoDeBrownie> Wait, I forget whether the FFI interfaces with C++ or not. With C I'm pretty sure it does
21:06:01 <zereraz> I know C
21:06:32 <HeladoDeBrownie> If you know a way to get resolution in C, then yeah, that should do fine
21:07:24 <zereraz> I'll have to look, I could not find any way of finding screen size in haskell(unless using gtk or glut)
21:07:50 <recursion-ninja>  /ignore -channels #mwsf * JOINS PARTS QUITS NICKS
21:08:51 <bms1> merijn: Thanks for pointing me to that! Roles and safe-coerce was exactly what I was looking for
21:09:13 <zereraz> should I use Wx haskell for building gui?
21:13:00 <pepper_chico> zereraz it should provide a portable way of getting screen-size at last I guess
21:13:27 <zereraz> pepper_chico: I searched , could not find anything
21:13:55 <zereraz> pepper_chico: gtk and glut provide ways to find screen size, I could not find it for this
21:14:47 <pepper_chico> zereraz, this is not available from haskell? https://forums.wxwidgets.org/viewtopic.php?t=218
21:15:17 <zereraz> pepper_chico: I am aware of that function, I am still looking it for haskell
21:16:39 <pepper_chico> zereraz, yeah, only found screen stuff on glut in hoogle...
21:17:37 <zereraz> pepper_chico: which is why I am confused if I should try wxhaskell or not as I am a beginner in haskell
21:18:23 <pepper_chico> zereraz no idea, maybe it would be more worth for a beginner to try FFI with C functions yourself
21:18:46 <pepper_chico> instead of dealing with big dependencies
21:19:16 <zereraz> pepper_chico: true, that is what I guess I should do
21:20:32 <zereraz> is there FFI for c++?
21:21:10 <recursion-ninja> time for this ninja to sleep...
21:21:15 <pepper_chico> too much complexity, I dunno whether there's something in the sense of Boost.Python
21:21:22 <kadoban> zereraz: No, only C as far as I know. Of course it's pretty easy to use C from C++ though, so...
21:21:29 <pepper_chico> better call C functions
21:21:37 <kadoban> zereraz: If you're a haskell beginner though, the FFI is probably not something to mess with, IMO.
21:21:45 <zereraz> windows has c++ functions for screen size
21:21:51 <kadoban> Of course it depends what you mean by beginner though...
21:22:04 <pepper_chico> zereraz, C too, win32 api is the base of the system
21:22:08 <pepper_chico> not a c++ api
21:22:13 <zereraz> pepper_chico: oh ok thanks
21:22:26 <zereraz> kadoban: I know haskell till applicatives
21:22:33 <nitrix> pepper_chico: Better call Saul
21:22:39 <zereraz> kadoban: stuff before monads mainly
21:23:17 <pepper_chico> nitrix I didn't get this one =/ (although I've watched the series)
21:23:44 <nitrix> Gags aren't my strongest point.
21:24:25 <nitrix> On a bright side, I've written my first 3 Haskell functions today!
21:24:34 <nitrix> It was hard, but I had a blast x]
21:24:40 <zereraz> nice
21:25:53 <lpsmith> hmm, is there a reasonably complete-ish HTML entity un-escaper somewhere on hackage?
21:25:55 <nitrix> And the code... it's like 9 lines and it replaces 200 lines of C code I had previously
21:26:22 <nitrix> The only thing that kills me is the annoying qualified names.
21:27:44 <lpsmith> I see that there is one in web-encodings, it's not all that complete but it's probably good enough.  However, that package is marked deprecated...
21:30:07 <EvanR> nitrix: theres some idiomatic things to do, like M. T. BS. for Data.Map Data.Text and Data.ByteString
21:30:33 <edwardk> Teaser from the abstract for my talk at next Boston Haskell: "Haskell is bad at abstraction; everyone else is worse."
21:30:56 <nitrix> EvanR: I have LT, LBS and LE.
21:30:59 <monochrom> clearly, only talk abstracts are the best abstractions :)
21:31:09 <edwardk> monochrom: =)
21:31:22 <EvanR> nitrix: LT and LE?
21:31:33 <nitrix> EvanR: Lazy Text and the Lazy Encoding
21:32:18 <nitrix> Data.Text.Lazy.Encoding, althouhg maybe that's supported to be written TLE ?
21:32:40 <EvanR> is the stuff in Text.Lazy.Encoding conflicting with anything common?
21:32:49 <EvanR> thats the issue with stuff in Text Map and ByteString
21:33:03 <EvanR> they all have names also in Prelude
21:33:06 <nitrix> EvanR: Mhhh, ah you're right, it doesn't.
21:33:58 <nitrix> So TL and BSL ?
21:34:08 <nitrix> Someone earlier said LBS instead of BSL.
21:34:12 <monochrom> lpsmith: with some hesistation, I mention that HXT decodes HTML entities. but 1. I am not sure how complete it is, I've never tried; 2. it seems irresponsible to suggest pull out such big gun as HXT just for one thing; 3. it's even more irresponsible to suggest it and not teach you its Arrow-ness.
21:34:15 <EvanR> ive seen LBS for lazy bytestring
21:34:56 <monochrom> however, maybe you can find and steal the relevant part from its source code.
21:36:37 <lpsmith> monochrom, well I'm writing a quick little program right now to compute the set of html entities that are present in my data...
21:37:08 <monochrom> I think I also know where to steal from the HTML4 DTD for its table of entities...
21:37:45 <monochrom> (yes, I once carefully read the HTML4 DTD! also XHTML 1.1 Modularization DTD!)
21:38:03 <monochrom> (hell, I once learned XSLT! can you believe it? :) )
21:38:21 <lpsmith> lol
21:39:30 <lpsmith> Hmm,  29307 documents comprising about 38.5 megabytes of data...
21:39:32 <monochrom> you know, there is something ironic I did to my haskell tutorial pages. I write in some kind of XML files (personal format) and have programs turn them into html (basically add headers footers boilerplates).
21:39:46 <lpsmith> I can just load it all into memory :-)
21:39:54 <EvanR> does your xml format have functions at least?
21:40:03 <monochrom> the ironically part: for the non-HXT tutorials, I use a program written in HXT. for the HXT tutorials, I use XSLT. I don't know why.
21:40:32 <monochrom> I think it kind of has one.
21:40:51 <monochrom> oh, I think it kind of has two!
21:43:14 <monochrom> here is one: I have an element <extern>stuff</extern>. the stuff is written out to a tmp file, then spawned as shell script. well, if it starts with #!/usr/bin/env runghc, then I guess it's a haskell script, not a shell script.
21:43:42 <monochrom> the output of the spawned script is taken back to replace the extern element.
21:44:33 <monochrom> this is how I get most of the SVG pictures in my lazy.xhtml article. how else would I write those boring SVG instructions?!
21:44:49 <rnons> When cabal build a yesod project, it complains "ghc: out of memory", I remember there is an option to handle this, but can't find it now
21:46:38 <caulagi> hello - I have this import line
21:46:40 <caulagi> import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)
21:46:48 <caulagi> how should I define my data?
21:46:59 <caulagi> data Sublist = Equal | Unequal | Sublist | Superlist deriving (Show)
21:47:16 <monochrom> yes, I think so.
21:47:46 <caulagi> monochrom: I get http://pastie.org/9623986
21:47:50 <Kron> how exactly do I use the exitcode-stdio interface to list the number of tests passed or failed?
21:47:55 <monochrom> unless you receive instructions that you have to write a richer data type. an import/export line cannot possibly say everything you need to know
21:47:56 <Kron> do I return an IO [Bool] or something?
21:48:07 <EvanR> monochrom: nice
21:48:28 <monochrom> who wrote @=? ? are you sure you need it?
21:48:56 <caulagi> monochrom: it is a part of tests I have got.
21:49:14 <monochrom> may I read the test instructions, verbatim?
21:49:37 <monochrom> I do not like incomplete indirect information, you know...
21:49:46 <caulagi> monochrom: https://github.com/exercism/xhaskell/blob/master/sublist/sublist_test.hs
21:50:04 <caulagi> I just want how to define my data for the test cases
21:50:21 <monochrom> thank you. one moment.
21:50:56 <monochrom> you need "deriving (Show, Eq)"
21:51:18 <EvanR> Unequal == Unequal
21:51:19 <EvanR> True
21:51:49 <benzrf> some equalities are more equal than others
21:52:11 <caulagi> monochrom: got it, thanks
21:52:15 <caulagi> it makes sense
21:52:19 <monochrom> alternatively, you could write your own instance code to do the same thing...
21:52:43 <EvanR> NaN == NaN
21:52:45 <EvanR> False
21:53:00 <monochrom> there is no NaN as constructor
21:53:17 <caulagi> monochrom: what would the instance code look like?
21:53:43 <EvanR> > (0/0) == (0/0) == False
21:53:58 <monochrom> instance Eq Sublist where { Equal == Equal = True; Sublist == Sublist = True; Unequal == Unequal = True; ...
21:54:14 <monochrom> it goes on for the others. then the last one is: _ == _ = False }
21:54:32 <caulagi> what is the benefit of defining like this?
21:54:43 <caulagi> versus a data like the above?
21:54:50 <monochrom> to have fun doing it yourself
21:55:17 <caulagi> ok - i have not read about instance yet.
21:55:19 <monochrom> to understand that it can be something you control, not magic.
21:55:36 <caulagi> do you have a link please?
21:55:39 <EvanR> or magic that you control
21:55:41 <monochrom> no
21:55:42 <EvanR> hehe
21:56:30 <caulagi> monochrom: will google that out.  thanks
21:56:32 <monochrom> well, any learning material you read, will eventually bring up "type classes". that's where this will be covered.
21:57:17 <monochrom> magic that you control is best :)
21:57:32 <caulagi> ok, got it.  I was reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses and it is under derived instances :|
21:58:08 <monochrom> well, it will also talk about handwritten instances somewhere.
22:01:28 <caulagi> yes, i see the same instance Eq Sublist where syntax that you had shown earlier on that page too
22:01:42 <monochrom> \∩/
22:02:08 <joelteon> so one big middle finger
22:02:24 <lpsmith> bah, I only need to unescape amp lt and gt
22:02:37 <lpsmith> I can write that myself easily
22:02:40 <monochrom> no, it's a robot's head
22:03:01 <EvanR> only html decoding amp lt and gt??
22:03:08 <lpsmith> yeah
22:03:49 <EvanR> the resulting hybrid text cant be reencoded, nor shown to a browser
22:04:26 <lpsmith> in my case, it can
22:04:52 <lpsmith> Any escapes that are actually part of the content are double-escaped
22:05:11 <lpsmith> If I unescape and then run my analysis again, I'm sure I'd have a different answer
22:05:16 <EvanR> ;_;
22:05:21 <EvanR> double encoded
22:05:33 <lpsmith> why is that bad?
22:06:06 <lpsmith> Actually,  it's the escaped output of a markdown-like implementation.
22:06:29 <lpsmith> I don't quite understand why it's escaped... but whatevs.
22:06:41 <EvanR> escape one more time for good measure ;)
22:07:20 <lpsmith> I suppose it's to make people think if they actually want to inject the html into a page.  Maybe
22:07:21 <lpsmith> I dunno
22:08:14 <EvanR> it seems its often a fast and loose understanding of the data
22:08:36 <carter> hey everyone
22:08:51 <carter> i'm trying to figure out a type class that some folks here will find very interesting
22:09:00 <carter> basically a version of Storable that doesn't assume regular size
22:10:13 <monochrom> it may begin by copying Storable but changing this: "size :: a -> Int  can examine the parameter to determine dynamic size"
22:10:28 <carter> yeah
22:10:42 <carter> thats what i'm thinking
22:10:54 <carter> monochrom: actaully, might need to be Ptr a
22:10:59 <carter> erm
22:11:16 <carter> this is why i'm going to make my own wee package for this for a while :)
22:11:55 <monochrom> there is a chicken-egg problem here.
22:12:19 <carter> i dont care about other people using it
22:12:29 <carter> monochrom: lemme explain more
22:12:47 <carter> i want to easily implement Btrees and other fun disk backed things
22:12:47 <monochrom> actually, no chicken-egg problem.
22:13:03 <carter> and so I need a version fo Stroable that interacts sanely with Ptr a
22:13:18 <carter> where a is some type that potentially contains pointers in kind
22:16:29 <monochrom> a B-Tree node has a fixed size.
22:16:41 <carter> for that program
22:16:44 * hackagebot auto-update 0.1.1.5 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.5 (MichaelSnoyman)
22:16:49 <carter> migth be dynamically fixed :)
22:16:53 <monochrom> I see
22:17:19 <carter> monochrom: i'm helping a friend learn haskell by writing a sqlite hs reader
22:17:47 <monochrom> may that be too steep to start from?
22:17:57 <carter> nah
22:17:59 <carter> :)
22:18:08 <carter> right pace to keep it interesting for him
22:18:28 <carter> and me
22:19:05 <carter> monochrom: we had fun working out the semantics of the sqlit file format docs
22:19:14 <monochrom> I am still not quite convinced of size :: Ptr a -> Int. I mean specifically size :: Ptr Node -> Int.
22:19:15 <carter> once this is done, may do it for a few more dbs
22:19:45 <carter> monochrom: you may be write
22:19:47 <carter> *right
22:20:01 <carter>  will have to kill pokeElemOff and peekElemOff
22:20:03 <carter> though
22:20:10 <trap_exit> typical ear plugs = designed to block out loud onice, but allow human voice -- however, when programming, I find human voice to be most irritating, since human voice = designed to get people's attention ;;; anyone have recommendation for good ear plugs for coding?
22:20:33 <carter> trap_exit: play coffee shop sounds
22:20:40 <carter> on head phones
22:20:47 <carter> while wearing earplugs
22:20:58 <trap_exit> carter: why ?
22:21:08 <carter> because that'd isolate everything
22:21:09 <Enigmagic> trap_exit: get custom made earplugs..
22:21:12 <carter> that too
22:21:14 <carter> Enigmagic: o/
22:21:17 <trap_exit> why am I pumping noise at my ears ?
22:21:18 <Enigmagic> howdy.
22:21:34 <carter> trap_exit: because you'll still hear people
22:21:39 <monochrom> one way to see it: you are about to poke. you have a Node, you don't have a Ptr Node yet. you allocate x bytes before you have Ptr Node. what is x? you call size for x. you only have Node when you call size.
22:21:48 <carter> monochrom: i think i need obth
22:21:50 <carter> *both
22:21:58 <carter> poke :: Ptr a -> a -> IO () wont always succeed
22:22:12 <Enigmagic> trap_exit: something like this http://westone.com/defendear/index.php?option=com_k2&view=item&layout=item&id=16&Itemid=132
22:23:11 <carter> monochrom: Enigmagic  i guess peak would need ot have a type like
22:23:25 <carter> peek :: Ptr a -> a -> IO (Maybe Slop)
22:23:34 <trap_exit> Engimagic: that looks like like foam ear plugs
22:23:34 <carter> where Slop is how much dead bytes at the end
22:23:38 <trap_exit> are you sure those things belong in ears?
22:23:46 <carter> trap_exit: but custom so your ears dont hate you
22:23:54 <carter> trap_exit: theres these people called "audiologies"
22:23:59 <carter> *audiologics
22:24:08 <carter> i cant spell
22:24:08 <Enigmagic> trap_exit: uhm, yes. i'm wearing custom IEMs that look similar to that right now.
22:24:27 <carter> Enigmagic: i need to check out those things
22:24:35 <carter> Enigmagic: iem === play musci?
22:24:45 <Enigmagic> yah
22:24:46 <monochrom> this pair of poke and peek is very strange...
22:25:19 <carter> monochrom: you mean Because of the size issue?
22:25:45 <monochrom> peek is not Ptr a -> IO (a, Maybe Slop)?
22:25:53 <carter> oh
22:25:57 <carter> i meant poke
22:26:07 <carter> peek has no slop
22:26:10 <carter> poke does
22:26:11 <carter> or fails
22:26:21 <carter> well
22:26:25 <carter> i guess theres two versions
22:26:33 <carter> static known size
22:26:38 <carter> which also gets a storable
22:26:53 <carter> and not static fixed size
22:26:54 <carter> right?
22:27:47 <monochrom> wait a second, are you saying that given a Ptr X, you can actually find out how much memory belongs to it? that sounds magical.
22:28:00 <carter> no
22:28:24 <monochrom> ok, then how do you know the slop value?
22:28:27 <carter> certain classes of pointers have size info at the head
22:28:41 <carter> monochrom: when you write a new value in, you'll read the old size
22:28:45 <carter> at the tip of the format
22:28:48 <carter> idk
22:28:52 <carter> i'm still trying to think this all through
22:29:05 <monochrom> ok yes, certain classes of pointers have size info at the head. but not the Ptr class.
22:29:10 <carter> no
22:29:14 <carter> monochrom: at the LOCATION
22:29:15 <carter> :)
22:29:18 <carter> not in the Ptr constr
22:29:33 <monochrom> I am referring to the location, too.
22:29:46 <carter> Ptr aint a class
22:29:49 <carter> i mean
22:29:53 <carter>  i have an address
22:30:05 <carter> and my write format for its Pointerable instnace
22:30:24 <carter> will may guarantee that
22:30:39 <carter> hrmm
22:30:41 <carter> ok
22:30:49 <carter> lemme try to explain it anotehr way
22:31:09 <carter> Storable impliec  Ptr a -->    | ====== fixed size ===== |
22:31:12 <carter> *implies
22:32:14 <carter> I want Pointerable to imply   Ptr a ---->  | =====  fixed size ==== | ------- variable size determined by info in the fixed part ------ |
22:32:41 <carter> monochrom: the alternative is to have an extra arg
22:32:47 <carter> with the config / size data
22:33:07 <monochrom> you have got to use a different name for this pointer type.
22:33:41 <carter> why
22:33:46 <monochrom> or maybe not, but that's wacky
22:33:47 <carter> Ptr a = Ptr Addr#
22:33:55 <EvanR> shouldnt this be a property of the type that the pointer is pointing to
22:34:00 <carter> EvanR: yup
22:34:01 <EvanR> rather than the pointer
22:34:10 <carter> i'm talking about the classs for this type of thing
22:34:15 <carter> EvanR: youre exactly right
22:34:19 <carter> and thats what i'm talking about :)
22:34:24 <EvanR> does it need a class?
22:34:26 <carter> yes
22:34:38 <carter> because theres no tools for working with things that dont fit Storable
22:34:40 <EvanR> this is just for one kind of node in one file format so
22:34:44 <carter> yup
22:34:56 <carter> EvanR: but i'll be writing a host of them :)
22:35:11 <carter> will probably do something dumb for it then change itup
22:35:43 <carter> like maybe the Pointable class will have an associated type for the format data
22:36:04 <EvanR> not sure a class makes sense
22:36:13 <carter> why not
22:36:32 <carter> there no parametricity going on
22:36:46 <carter> but i want to write reusable code for a bunch of different b-tree like data structures
22:36:46 <EvanR> there might not be anything going on
22:37:04 <carter> eh, i think there is
22:37:14 <EvanR> if they all have a storable head, thats that
22:37:16 * carter shakes fist while saying "you'll see "
22:37:17 <monochrom> recent talk about modularity says that if you will use a type family, then you need a class. IIUC. :)
22:37:21 <Dtgr> can't you just have Ptr a to your data in the Storable instance and some size information alongside that
22:37:42 <carter> Dtgr: not quite
22:38:02 <carter> Dtgr: Storable REALLY assumes that size in memory is uniquely determined by type
22:38:14 <EvanR> yeah, specifics about attempt to write data into a btree file arent going to be that reusable
22:38:14 <carter> i basically need storable but with that assumption removed
22:38:37 <carter> EvanR: i'm not so sure :)
22:38:38 <Heather> is it possible to case / match variable type
22:38:45 <carter> Typeable type class
22:38:48 <carter> Heather:
22:38:51 <EvanR> yurg
22:39:00 <carter> or Sums
22:39:05 <carter> EvanR: anyways, its an experiment
22:39:19 <Sonarpulse> Is it possible to nest quickcheck calls, to test things like forall a. forall b. c(a,b) ?
22:39:20 <carter> i'll be implementing a few different db format readers
22:39:33 <carter> and i'll see what comes out wrt abstractions
22:39:41 <carter> EvanR: its a bit easier than my bigger project :)
22:39:56 <Heather> carter: Data.Typeable?
22:39:59 <carter> yeah
22:40:09 <EvanR> Heather: to use a case to match various different things that might be different types you can make an algebraic data type with a different constructor for each case
22:40:32 <EvanR> data D = A Int | B Bool | C String
22:41:10 <Sonarpulse> I made an instance to brute force boolean expressions
22:41:17 <Sonarpulse> and an interpreter
22:41:23 <carter> Sonarpulse: QSAT?
22:41:25 <carter> or SAT?
22:41:32 <carter> Sonarpulse: use Ersatz or SBV
22:41:38 <Sonarpulse> mmm, not quite sat I think
22:41:46 <solatis> anyone has an opinionated recommendation of a (high-level) test framework i should use with haskell? as in, i'm not looking for unit tests, but rather high-level integration tests
22:41:49 <Heather> EvanR: when I get result from source like IORef s0 it's just a and I don't know it's type, I wanted to check if I can trick around it
22:41:51 <Sonarpulse> I've used Alloy
22:42:00 <Sonarpulse> and I know i could't do this in that
22:42:08 <solatis> right now i have 20 different cabal test-suite targets in my .cabal file, which i think is suboptimal
22:42:27 <Sonarpulse> because I am quantifying over boolean expressions
22:42:35 <Sonarpulse> not boolean values
22:43:17 <Sonarpulse> I wan to do exists f. forall (args). (f args) == (oracle args)
22:43:18 <merijn> solatis: Lemme know if you find one, I didn't see anything too great so far
22:43:24 <Dtgr> carter: looking forward to your implementation :)
22:43:27 <EvanR> Heather: how do you not know what type an IORef goes to?
22:43:27 <Sonarpulse> which in quick check I figure I could do
22:43:44 <benzrf> oh can quickcheck do existential
22:43:45 <solatis> merijn: i'm looking at HTF right now, which at least appears to be actively maintained for a long time now
22:43:52 <Sonarpulse> forall f. forall args. f args != oracle args
22:44:01 <Heather> EvanR: if I want some function which takes IOref, how can I know?
22:44:13 <Sonarpulse> benzrf no, but with the above, the "counterexample" is what I want
22:44:16 <Heather> EvanR: :: IORef s0 -> IO()
22:44:19 <EvanR> Heather: you want to make a polymorphic function that works forall a. IORef a ?
22:44:28 <Heather> EvanR: yes
22:44:38 <Kron> Gen a, Gen b => Gen (a,b) right? Can I just put tuples together
22:44:44 <EvanR> in this case, you do not know anything about a and so you cant do very much with it
22:44:49 <Heather> EvanR: should I declare it with forall?
22:44:58 <EvanR> you dont have to, its implicit
22:45:20 <Heather> good
22:45:22 <jle`> so that's really the thing about haskell's type system
22:45:35 <jle`> if you have something of type `a`, there isn't much you can do with it, becuase you don't have access to its structure
22:45:49 <jle`> that's why there's only one well behaving function of type (a -> a)
22:45:58 <benzrf> @djinn a -> a
22:46:06 <benzrf> oh nooo
22:46:11 <jle`> lamdabot has left us
22:46:22 <benzrf> i k b u t i ke e p f o r g e t t i ng
22:46:29 <kazagistar> :(
22:46:36 <jle`> if you have an (IORef a), then you can only do things with it that have functions that work "for all a's"
22:46:57 <kazagistar> hmm, maybe we can get lambdaboot to sub in?
22:46:58 <EvanR> Heather: if you want to do something with that a, you need to know something about it. like you said you want to pattern match, so you can wrap your value is the various cases
22:47:15 <EvanR> in the various cases
22:47:31 <jle`> remember that types don't have any run-time information on them associated with what type they are
22:47:58 <Heather> EvanR: can I use Typeable with forall a. IORef a
22:48:07 <EvanR> but what would you do with it?
22:48:52 <EvanR> and actually you would at least need to at a constraint, its not all a
22:49:02 <jle`> you could do a case match on the typerep...but...ther eprobably is a better way to go about this
22:49:05 <EvanR> Typeable a => IORef a
22:49:16 <EvanR> only a with Typeable instance
22:49:19 <jle`> and also you could only then use that function if you know you have something Typeable in it
22:50:01 <jle`> what is the bigger use case?
22:50:11 <jle`> ther eprobably is a way to avoid having to do this in the first place that is much cleaner
22:51:30 <solatis> HSpec seems to be more aimed towards unit tests than black box testing eh?
22:51:31 <Kron> is there any haskell function that takes a function "f" and list "[a,b,c,d...]" and generates "f a $ f b $ f c $ f d"
22:51:37 <Kron> like a folding function application
22:51:46 * hackagebot wai-app-file-cgi 3.0.3 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.3 (KazuYamamoto)
22:52:26 <kazagistar> Kron: what type do you imagine f having? That seems very awkward...
22:53:00 <EvanR> you can do it with dependent types ;)
22:53:17 <Kron> f is of type (a -> a) for a list of [a]
22:53:31 <Kron> well... ish
22:53:33 <EvanR> oh, well nevermind
22:53:35 <Kron> I can just do it with a foldr
22:53:48 <Kron> there's a base value at the end so it's (a -> a -> b)
22:53:53 <Kron> so it's basically just a fold
22:53:55 <kazagistar> Kron: that "... ish" is problematic
22:54:18 <kazagistar> Kron: congratulations, now it is foldr
22:54:26 <EvanR> f a (f b (f c (f d))) ?
22:54:41 <EvanR> f now takes one or two args :\
22:54:47 <jle`> yea,h that's a bit awkward
22:55:16 <kazagistar> which is theoretically possible though, but not comfortable...
22:55:23 <jle`> i don't think it's possible
22:55:44 <EvanR> the second arg needs to be a function
22:55:50 <jle`> with rank 1 types at least
22:56:22 <kazagistar> hmm, I thought you could return different things depending on needed return type... doesn't the regex libraries do that?
22:56:24 <jle`> :t \f x y z -> f x (f y (f z))
22:56:29 <jle`> should give you an error
22:56:37 <jle`> especially if you make all x y z's the same type, even
22:56:53 <jle`> Kron: what function f are you thinking of that would be able to fit into that?
22:57:43 <jle`> if you wanted x `f` (y `f` (z `f` base)), or f x (f y (f z base)), then that's foldr f base
22:59:41 <Kron> right
23:00:29 <asfp> What does Foo a => Bar b => a -> b mean?  Is it the same as (Foo a, Bar b) => a -> b?
23:00:33 <kazagistar> jle`: couldn't you use a trick like this? http://www.haskell.org/haskellwiki/Varargs
23:00:47 <jle`> asfp: yeah
23:00:58 <asfp> jle`: ok. thanks.
23:01:47 * hackagebot mighttpd2 3.2.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.3 (KazuYamamoto)
23:01:52 <jle`> kazagistar: not if all the f's have to be the same type
23:03:27 <EvanR> kazagistar: you mentioned the f is a -> a, that would mean f could only be id
23:03:28 <EvanR> ;)
23:03:52 <jle`> i think by that he probably means that if is typeinthelist -> typeinthelist
23:04:51 <jle`> but...he can probaly speak for himself :)
23:04:57 <monochrom> this is why if you have a specific type in mind, it's better to write X->X and avoid type variables
23:05:59 <kazagistar> he was clearly describing a parameter, and an (a -> a) parameter can accept non-id functions...
23:06:01 <jle`> does anyone else remember the first type  using `undefined` as a type (variable), having it compile, and wondering why it works?
23:06:14 <monochrom> oops, I see
23:07:24 <monochrom> do you mean like "g :: undefined -> (undefined, undefined)"?
23:07:37 <kazagistar> Multi-letter type variables: Haskell's most underused feature
23:08:43 <kazagistar> why use words, when you can define Lens i m a s t a b u
23:08:55 <haasn> meta-words
23:09:00 <monochrom> whatever I did similar to that, I was quick to realize, there are very few reserved words in Haskell. even "otherwise" is not a reserved word.
23:09:42 <kazagistar> yep, it's definition sitting there in Data.Bool
23:10:36 <monochrom> the longest time of wonder was from "let 2+2=10 in 2+2", but even that didn't take too long.
23:11:33 <kazagistar> yeah, you figure it out as soon as you try "let 2+2=10 in 2+3"
23:11:38 <kazagistar> at least I did
23:11:59 <kazagistar> do most lisps even have keywords?
23:12:34 <monochrom> I think they prefer "it's a special form" to "it's a keyword"
23:13:42 <EvanR> (a -> a) can be non id if it is a parameter? there must be something else besides that to allow non-id right
23:14:01 <monochrom> a good test is doing "let nil = 't in nil".
23:14:32 <monochrom> consider "(a -> a) -> [a] -> [a]"
23:14:49 <jle`> monochrom: yeah, that's what i meant
23:15:10 <jle`> EvanR: it dpeends on where the forall is
23:15:16 <kazagistar> EvanR: a type parameter is a "minimum requirement"... as monochrom says, fmap can take more then just id as its parameter
23:15:29 <jle`> foo :: forall a. (a -> a) -> [a] -> a
23:15:36 <jle`> means that you can pick any `a` to go in there
23:15:39 <jle`> so
23:15:46 <jle`> foo :: (Int -> Int) -> [Int] -> Int works
23:16:05 <jle`> and for a ~ Int, there is clearly more than one function of type (Int -> Int)
23:16:16 <EvanR> caller chooses
23:16:18 <jle`> foo :: (Bool -> Bool) -> [Bool] -> Bool would work, as well
23:16:35 <jle`> so if i called something like foo (+1)
23:16:49 <jle`> the foo might be foo :: (Int -> Int) -> [Int] -> Int
23:17:00 <jle`> and so it will be expecting an [Int]
23:17:58 <jle`> this is different than, say, foo :: (forall a. a -> a) -> [b] -> b
23:18:11 <jle`> meaning that...the function you pass in has to be able to take *any* a
23:18:24 <EvanR> yeah, you cant pick
23:18:24 <jle`> in this case the only thing you could reasonably pass in is `id`
23:18:42 <EvanR> you get to pick b
23:19:38 <EvanR> :t const
23:19:42 <EvanR> gr
23:20:03 <jle`> foo :: ([a] -> Int) -> ([b], [c]) -> (Int, Int); foo f (xs, ys) = (f xs, f ys)
23:20:10 <jle`> it might be fun to figure out why that won't work :)
23:20:49 <EvanR> f is instantiated to two different types
23:21:04 <EvanR> possibly two different types
23:21:12 <kazagistar> const is type a -> b -> a, but I am pretty sure it should be type Applicative f => a -> f a :P
23:21:36 <EvanR> seems reasonable but then monomorphism restriction?
23:21:51 <jle`> this doesn't quite have to do with monomorphism restriction
23:22:05 <jle`> but
23:22:09 <jle`> i think you get the point
23:22:19 <EvanR> well, a != b or c
23:22:27 <EvanR> even worse
23:22:33 <Sonarpulse> QuickCheck is compaining no instance (Testable Result) but the docs clearly show it exists
23:22:36 <jle`> when you say "f xs", f isn't guarunteed to be b.  when you say "f ys", f isn't guarunteed to be ys.  and it definitely isn't guarunteed to be both
23:22:41 <jle`> but what you can do is say
23:22:58 <jle`> foo :: (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int); foo f (xs, ys) = (f xs, f ys)
23:23:01 <jle`> and that'll work
23:23:06 <kazagistar> Sonarpulse: maybe its a different version?
23:23:31 <Sonarpulse> i checked version
23:23:37 <EvanR> that will work despite monomorphism restriction?
23:23:44 <Sonarpulse> my cabal file says >= 2.7.3
23:23:48 <Sonarpulse> and 2.7.3 had it
23:24:06 <jle`> like i said, this is unrelated to monomorphism restriction
23:24:07 <Sonarpulse> as did 2.7.6, the newest
23:24:13 <monochrom> an explicit type declaration turns the monomorphism restriction away
23:24:23 <EvanR> ok thats the trick
23:24:43 <jle`> that type signature says that the function `f` has to be guarunteed to take a list of *any* types...so...it should work on both xs and ys
23:24:47 <EvanR> and it requires Rank2 or RankN
23:24:48 <kazagistar> Sonarpulse: link to docs? and you did import the package with the instance deceleration, right?
23:24:54 <jle`> yeah, this is a Rank2 type
23:24:54 <monochrom> another way to turn it away is to write "f x = ..." instead of "f = \x -> ..."
23:24:56 <jle`> rank 2 type
23:25:20 <EvanR> sweet
23:25:28 <sopvop> does -fhpc make code slower?
23:25:31 <EvanR> rank 2 rocks
23:25:56 <Sonarpulse> kazagistar http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck.html#g:15
23:26:52 <kazagistar> Sonarpulse: which type are you testing?
23:27:07 <Sonarpulse> Result
23:27:29 <Sonarpulse> now that I look at the property combinators there might be a nicer way to do nested quantification
23:27:33 <Sonarpulse> which is what I really want
23:28:21 <Enigmagic> Sonarpulse: do you have the right Result? there are two... http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/doc-index-R.html
23:28:41 <Sonarpulse> oh that is probably it
23:28:44 <int-e> @bot
23:28:52 <lambdabot> :)
23:29:31 <kazagistar> yaaaay
23:30:17 <Sonarpulse> well the forAll combinatory seems to be doing the job better
23:30:53 <Sonarpulse> but that brings me to my next problem, "inverting" the result
23:30:56 <Sonarpulse> so I can do
23:32:22 <Sonarpulse> ~(forall a. ~(forall b. c(a,b)))
23:32:33 <Sonarpulse> to simulate existential quantification
23:33:22 <kazagistar> @pl i  l o v e  y o u   l a m b d a b o t = (& y o u  l o v e  m e  t o o)
23:33:32 <lambdabot> i = const (const (((const .) .) . (((const .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((flip (&) .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip flip
23:33:50 <monochrom> thank you int-e
23:33:56 <jle`> lambdabot returns :O
23:34:18 <jle`> thank you int-e
23:34:21 <monochrom> spring returns. in Australia
23:34:27 <jle`> @int-e-snack
23:34:27 <lambdabot> Unknown command, try @list
23:37:18 <wz1000> @list
23:37:18 <lambdabot> What module?  Try @listmodules for some ideas.
23:37:24 <wz1000> @listmodules
23:37:24 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:37:27 <numberten> @uptime
23:37:27 <lambdabot> uptime: 8m 57s, longest uptime: 1m 10d 23h 44m 29s
23:38:17 <int-e> The whole lambdabot screen session died, and I don't know why. (It wasn't a reboot.)
23:38:28 <jle`> it happens
23:38:56 <kazagistar> so what you are saying is that lambdabot is more stable then screen?
23:39:52 <int-e> kazagistar: it's not, but I have a loop around lambdabot that restarts it when it dies. which doesn't help when the loop dies.
23:42:15 <nkar> is there a better alternative to 'when (ifJust m) $ do let v = fromJust m; (undefined :: IO ())'?
23:43:17 <jle`> mapM_
23:43:29 <jle`> also undefined :: IO () could be just return ()
23:43:37 <jle`> mapM_ or forM_ from Data.Foldable, that is
23:43:55 <int-e> kazagistar: (it's not really unstable. the most common reason that it dies is when it loses the connection to the IRC server; there's no reconnect logic in lambdabot itself.)
23:44:26 <nkar> jle`: undefined was used just to denote an IO action.
23:45:00 <pavonia> Use a case instead
23:45:02 <kazagistar> int-e: clearly the solution is to put a loop around the loop :P
23:45:03 <int-e> (it has been suggested to use an IRC bouncer running locally, which should work)
23:45:31 <jle`> forM_ myMaybe $ \x -> .....
23:45:41 <jle`> it'll be return () when it's Nothing
23:45:48 <int-e> kazagistar: right, I can actually do that; have a cron job check for the screen session (I have a suitable script already, for the case of reboots)
23:45:51 <jle`> or else the given IO action when it's Just x, passing the x into the function
23:46:22 <pavonia> :t forM_
23:46:22 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
23:46:29 <jle`> it basically allows you to treat a Maybe a as if it were an [a]
23:46:33 <jle`> :t F.forM_
23:46:33 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
23:46:39 <wz1000> What is lambdabot running on?
23:46:45 <jle`> :t F.forM_ `asAppliedTo` Nothing
23:46:46 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m ()
23:47:01 <pavonia> Oh, nice
23:47:13 <nkar> jle`: ah, thank you.  I always forget there are generalized versions of functions from Control.Monad.
23:47:44 <jle`> np!
23:47:56 <jle`> this is pretty useful in writer-like monads
23:48:00 <pavonia> > F.forM_ pure Nothing :: [Int]
23:48:02 <lambdabot>  Couldn't match type ‘()’ with ‘GHC.Types.Int’
23:48:02 <lambdabot>  Expected type: [GHC.Types.Int]
23:48:02 <lambdabot>    Actual type: [()]Couldn't match expected type ‘f0 a0 -> [b0]’
23:48:02 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
23:48:16 <pavonia> > F.forM pure Nothing :: [Int]
23:48:18 <lambdabot>  Not in scope: ‘F.forM’
23:48:18 <lambdabot>  Perhaps you meant one of these:
23:48:18 <lambdabot>    ‘T.forM’ (imported from Data.Traversable),
23:48:18 <lambdabot>    ‘F.forM_’ (imported from Data.Foldable),
23:48:18 <lambdabot>    ‘F.for_’ (imported from Data.Foldable)
23:48:35 <monochrom> it ends with m(). you can't have [Int]. you can have [()]
23:48:40 <jle`> it's in Data.Traversable
23:48:46 <jle`> :t T.forM
23:48:47 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
23:48:52 <jle`> :t T.forM `asAppliedTo` Nothing
23:48:53 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m (Maybe b)
23:49:07 <jle`> :t T.forM `asAppliedTo` []
23:49:08 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
23:49:16 <pavonia> I see, you need the former monad to appear in the result type too
23:49:31 <jle`> Traversable/Foldable :)
23:49:40 <pavonia> Yeah
23:53:24 <Sonarpulse> thanks kazagistar and Enigmagic
23:53:38 <Sonarpulse> made https://github.com/nick8325/quickcheck/issues/24 which is I think all i need now
23:56:45 <Heather> how to specify type alike SomeInterface a => IORef (a Int) -> IO ()
23:56:45 <cellopin> Can you see the documentation or a description of a function in the ghci compiler?
23:57:04 <Heather> I mean apply Interface IORef and Int to a
