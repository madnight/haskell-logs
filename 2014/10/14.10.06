00:04:31 <kazagistar> Heather: sure, I think that just means SomeInterface has to be of kind (* -> *) -> Constraint
00:05:20 <kazagistar> like Functor or Monad or Foldable
00:05:44 <kazagistar> Heather: what exactly are you trying to do with it?
00:06:56 <Heather> kazagistar: nothing special, I mean SomeInterface a => IORef (a Int) -> IO () looks like wrong syntax
00:07:49 <Heather> kazagistar: I want to find how to write it correct
00:08:26 <monochrom> it is legal syntax. the interesting question is whether it is type-checked
00:08:58 <Heather> monochrom: I'm getting `a' is applied to too many type arguments
00:09:17 <monochrom> well then, it is a type error.
00:09:44 <monochrom> but MonadIO a => IORef (a Int) -> IO () type-checks and I may even be able to write an example
00:10:28 <Heather> monochrom: interesting
00:10:49 <kazagistar> Heather: how is SomeInterface defined? Do things that implement SomeInterface take a type parameter?
00:10:56 <Heather> monochrom: (a Int) means simply that a is Int, right?
00:11:30 <Heather> kazagistar: class  PlusPlus a  where  (xx) :: IORef a -> IO ()
00:11:38 <kazagistar> Heather: no, its like ([] Int) == [Int], or (Maybe Int)
00:12:01 <Heather> kazagistar: ah, I just wanted to specify a as Int
00:12:18 <monochrom> IORef Int -> IO ()
00:12:21 <kazagistar> Heather: then you dont need to specify the a at all
00:12:31 <Heather> monochrom: and apply interface
00:12:46 <Heather> kazagistar: then how to apply interface?
00:13:16 <monochrom> I don't understand that. unless it simply means that Int is an instance of SomeInterface.
00:13:27 <monochrom> is there any actual code I can read on the web?
00:13:38 <kazagistar> Heather: your interface is there, always... if you implement PlusPlus Int, and you know you have an Int, you can use PlusPlus methods
00:13:42 <Heather> yes I've got instance SomeInterface Int where ...
00:14:17 <Heather> kazagistar: how to specify in that method that I want to use it exactly with Int
00:14:25 <monochrom> then IORef Int -> IO (). that is enough.
00:14:39 <Heather> monochrom: where is interface in this type?
00:14:53 <monochrom> not in the type. just go ahead use the methods.
00:15:05 <kazagistar> Heather: type inference will pick that one; if you specify the value has a type Int, it will know which instance to use
00:15:27 <monochrom> look, suppose I have "f :: Int -> String". then I can do "f x = show x ++ show x". it's fine.
00:15:31 <Heather> monochrom: ah, it works...
00:15:54 <Heather> thanks
00:16:16 <Heather> but I wonder why I don't need to specify it with =>
00:17:44 <kazagistar> Heather: its more specific then when you do it with =>
00:18:16 <Heather> kazagistar: what if I want same method with Float?
00:18:28 <kazagistar> Heather: that does the same thing?
00:18:34 <Heather> kazagistar: yes
00:18:47 <Heather> kazagistar: I've got Int and Float instances
00:18:52 <kazagistar> you mean the IORef method, or the someinterface one?
00:19:26 <Heather> kazagistar: I've got Int and Float instances of class and want one method which will work with both
00:20:14 <kazagistar> if you want it to work with anything that implements SomeInterface, then it would be SomeInterface a => IORef a -> IO ()
00:20:42 <Heather> kazagistar: then how it will know which one to use?
00:21:14 <kazagistar> Heather: the person calling that function knows what type it has, and it will pass in the right interface to use as well
00:21:32 <Heather> kazagistar: I'm getting The type variable `a0' is ambiguous
00:21:58 <Heather> kazagistar: I think in call method I should specify more then?
00:22:14 <kazagistar> Heather: you really should just link the code, I can't debug otherwise :/
00:22:42 <Heather> kazagistar: ok )
00:22:44 <kazagistar> Heather: yeah, if it is ambiguous, you have to manually disambiguate somehow
00:23:02 <Heather> kazagistar: Ill publish, w8
00:23:35 <kazagistar> > show (read "nope")
00:23:37 <lambdabot>  "*Exception: Prelude.read: no parse
00:23:52 <kazagistar> oh, right, silly lambdabot
00:24:06 <kazagistar> :t show (read "nope")
00:24:07 <lambdabot> String
00:26:21 <asfp> network-ip, haskell-network-address, Data.IP, Network.IP.Addr.  What is the canonical IP data type?
00:26:51 <Heather> kazagistar: https://github.com/Heather/io-ref-tests/blob/master/test/test.hs
00:29:34 <joneshf-laptop> how do you decide namespacing for a module?
00:29:45 <joneshf-laptop> in particular between `Data` and `Control`?
00:29:56 <monochrom> intuitively.
00:31:15 <joneshf-laptop> what does that mean?
00:31:17 <monochrom> or you can poll a lot of people, take votes, and count
00:31:21 <asfp> joneshf-laptop: choose Control if you're mathematically inclined.  choose Data if you're an engineer.
00:31:24 <cellopin> I don't understand why ["h", "i"] is [[Char]] and not equal to "hi" which is [Char]
00:31:27 <arbn> joneshf-laptop: Well, is it about data or control?! :P
00:31:37 <joneshf-laptop> arbn, ...
00:31:45 <monochrom> it means using your intuition.
00:31:51 <merijn> I'm a firm believer of not using Data *or* Control
00:31:52 * hackagebot free-game 1.1.79 - Create games for free  http://hackage.haskell.org/package/free-game-1.1.79 (FumiakiKinoshita)
00:31:58 <merijn> Silly useless layer of hierarchy
00:32:07 <joneshf-laptop> merijn, what do you suggest?
00:32:10 <merijn> Why bother having "Data.Text" instead of just "Text"?
00:32:11 <asfp> merijn: use both? :-)
00:32:13 <kazagistar> Heather: in your test function, 1 could be either an Int or a Float... if you swap it for (1 :: Int) it will work I think
00:32:32 <arbn> To me, whether a module is in Data or Control seems random. I always have to look it up, and it's never intuitive.
00:32:33 <merijn> joneshf-laptop: The Pipes approach, just define your own category for your library
00:33:15 <kazagistar> Most libraries define a category, but some just do it inside another category...
00:33:21 <kazagistar> *many
00:33:26 <Heather> kazagistar: I know, swap for 1 :: int ?
00:33:31 <merijn> joneshf-laptop: pipes just defines "Pipes" and puts everything under there, if you have a library Foo, I'd just pick a "Foo" prefix and use that, assuming Foo is not overly general
00:33:32 <monochrom> it's really an arbitrary line that can only be subjectively divided. why Applicative is Control not Data. why List is Data not Control.
00:33:42 <Heather> kazagistar: interesting when I want to use both
00:34:03 <merijn> Claiming "Encoding" as a library top level module may be a bit rude, for example
00:34:05 <Heather> kazagistar: should be possible to call specific instance of test I think
00:34:13 <kazagistar> Heather: no, I mean, in your caller, in main... you have to pick which type it is using when you call it
00:34:44 <kazagistar> Heather: you could just as well do Float, but you have to pick one or the other, or it cannot figure out which version to use
00:34:47 <joneshf-laptop> actually, i just realized how terrible this actually is
00:34:51 <dfeuer> Why Functor is in Data, but some of its subclasses are in Control....
00:34:53 <joneshf-laptop> actually...
00:35:27 <joneshf-laptop> does that mean if two libraries define the samemodule names, you can't use them together?
00:35:44 <merijn> joneshf-laptop: You could, with package imports, but it'd be painful
00:35:47 <asfp> network-info has another definition of IP
00:35:48 <arbn> joneshf-laptop: You can qualify with package, I think.
00:35:48 <joneshf-laptop> like how do you disambiguate them?
00:35:49 <joneshf-laptop> ugh
00:35:54 <merijn> joneshf-laptop: So, in general, no
00:36:00 <joneshf-laptop> arbn, how would it know to qualify which one?
00:36:11 <kazagistar> CTGhetto.Monad
00:36:32 <joneshf-laptop> hmm, is there a proposal for that?
00:36:41 <joneshf-laptop> kind of bird walking now
00:36:44 <Heather> kazagistar: strange then I get Could not deduce (Show a) arising from a use of `show'
00:36:48 <merijn> joneshf-laptop: There is a package imports extension, but it's really annoying
00:37:00 <merijn> joneshf-laptop: What are you thinking of calling your module?
00:37:14 <joneshf-laptop> merijn, i was just wondering in general
00:37:33 <joneshf-laptop> merijn, its something i've never seen explained, and thought i just didn't know where to find the info
00:37:36 <dfeuer> Heather, what are you trying to do?
00:37:39 <arbn> joneshf-laptop: The Haskell module+namespace system in general needs some improvement.
00:37:42 <joneshf-laptop> merijn, but it seems like there is no info
00:37:49 <kazagistar> Heather: cool, thats progress... note, you only specified that "a" must be a PlusPlus, but it does not neccessarily have an instance of Show, so you need to add that too
00:38:13 <joneshf-laptop> how has it gone this long without it being a bigger issue?
00:38:17 <Heather> kazagistar: to PlusPlus? :S
00:38:25 <joneshf-laptop> or is that part of the "avoid success at all costs?"
00:38:43 <merijn> joneshf-laptop: Why do you think it's a big issue?
00:38:53 <merijn> joneshf-laptop: How's this different from python's module hierarchy?
00:38:55 <kazagistar> Heather: no, just in addition... (PlusPlus a, Show a) => IORef ... etc
00:39:10 <Heather> kazagistar: ah... I see, thanks
00:39:17 <joneshf-laptop> merijn, it's a kneejerk reaction i guess, seems like it's an issue
00:39:22 <dfeuer> joneshf-laptop, it's hard to get people to work on Haskell things if there aren't research papers to be written on them. You should check out Backpack though, which seems to be the strongest attempt to do something about the problem.
00:39:27 <monochrom> joneshf-laptop, people have exercised good judgement, and we have good people.
00:39:34 <merijn> joneshf-laptop: In fact, it don't know a single language where people can't put things in whatever namespace they like
00:40:04 <merijn> joneshf-laptop: The reason it works out is, if someone is a jerk and uses some valuable namespace for a crappy package, people will just not use that package
00:40:30 <dfeuer> But there is a Semigroup package (unpopular) along with the semigroups package (more popular) that define a module with the same name :-(
00:40:44 <merijn> joneshf-laptop: Imagine I write a python library with a module called "twisted" that'd conflict with the twisted library in massive ways and you probably can't install both on the same machine. But nothing's preventing that in python either
00:40:46 <kazagistar> Heather: you could add it to PlusPlus a constraint (that would work), but that only makes sense to do so in a few cases; usually it is better to separate concerns
00:41:01 <dfeuer> I once installed the Semigroup package by mistake and had to nuke stuff.
00:41:30 <merijn> joneshf-laptop: So the simple answer is: If you want to have users, pick a sensible name. If not, then it doesn't matter anyway, because if no one uses your package, it's module names don't matter
00:42:44 <Heather> kazagistar: yes I understand
00:43:37 <arbn> And if you *really* need two packages that use the same naemspace (I've never heard of this happening), you can suffer through PackageImports for that edge case.
00:43:39 <joneshf-laptop> merijn, hah, seems fair
00:43:46 <arbn> namespace*
00:44:31 <joneshf-laptop> just would've expected something like this might've had some nice solution here, but i guess it's less of an issue than it sounds
00:45:10 <joneshf-laptop> in anycase, sounds like choosing a namespace is pretty much arbitrary
00:45:46 <joneshf-laptop> expected? suspected maybe?
00:45:47 <monochrom> some things are clear-cut and non-controversial. for example "Control.Text".
00:46:22 <Cale> I kind of wish we could drop the Control.* and Data.* prefixes and just shift all that stuff up a level
00:46:29 <monochrom> but List and Applicative are really grey areas and you just have to pick your mood today
00:47:18 <arbn> monochrom: What is "Control.Text"?
00:47:20 <Cale> I feel like they were introduced when the hierarchical modules first came along just because "woo hierarchical modules!"
00:47:38 <Cale> arbn: Something that we definitely don't want :)
00:47:40 <monochrom> "Control.Text" is a candidate that clearly is rejected by everyone :)
00:48:03 <arbn> Ah. OK. :)
00:48:32 <Cale> It's hard to argue that Text has more control-structure-nature than data-nature
00:48:40 <Cale> While for List, that's much less clear-cut
00:48:48 <monochrom> "Data.List" sounds natural to beginners, until you see that in professional code, [] is our generator-yield loop more often than is data.
00:48:57 <Cale> yeah
00:49:16 <monochrom> ("Data.List" would be obvious in SML. but we are not SML.)
00:49:34 <joneshf-laptop> the one that gets me is `Data.Functor`
00:49:35 <Cale> In fact, if you're using lists as data structures that hang around in memory for a long time, it's often the case that you could have chosen a better structure.
00:49:49 <wz1000> @pl inc n f = n f .f
00:49:49 <lambdabot> inc = ((.) =<<)
00:49:57 <arbn> joneshf-laptop: Data.Functor but Control.Applicative makes no sense to me, yeah.
00:50:24 <int-e> monochrom: Control.Text should provide a type and functions for strings of control characters ;-)
00:50:48 <monochrom> "Control.Applicative" sounds good until you see that the main motivation, perhaps the whole point, of Applicative is that, for example, an Applicative parser is data rather than monad-like control, so that you can do on-the-fly introspection and optimizations.
00:51:27 <monochrom> I did carefully pick those two examples to be defendable.
00:57:26 <bartavelle> int-e, Control.Char !
00:58:26 <monochrom> haha, that's a great invention
00:59:31 * bartavelle wonders if someone already claimed Control.Alt.Del
01:00:29 <monochrom> I have no great invention. but I know great history and can tell you that for great inspirations.
01:01:29 <monochrom> there was such a thing called "usenet". it's a lot of forums. implementation details differed from web forums today, because there was no web. but forums requiring different software anyway. I think you can understand abstractly.
01:02:07 <bartavelle> I think a lot of people still use usenet, except it's mostly for file sharing
01:02:16 <monochrom> forum names were hierarchical. comp.lang.c, rec.puzzle ("rec" for "recreational"), etc.
01:02:53 <monochrom> clearly, namespace wars exist wherever there is hierarchical namespace.
01:04:37 <monochrom> so a significant group of people created the "alt" rebellion hierarchy. "alt.algebra.help" for example, perhaps as a counterpoint to "sci.math" not being quite friendly to highschool homework
01:05:24 <monochrom> I bring it up because the Alt part reminds me of this distant past.
01:05:43 <doismellburning> so, mildly controversial perhaps, but I plan on java-style packaging...
01:05:49 <bartavelle> looks like ekmett already authored Control.Alternative.Free
01:05:51 <int-e> sigh, lambdabot also lost @tells from last week (approximately) tonight.
01:06:08 <doismellburning> Uk.Co.Doismellburning.MyPackage ;)
01:06:31 <monochrom> there were some pretty funny names under the alt hierarchy. for some celebrity x, there was an "alt.x.die.die.die" forum for people who hated x.
01:07:05 <doismellburning> monochrom: ah yes, alt.ensign.wesley.die.die.die
01:08:50 <arbn> doismellburning: I always thought the TLD prefix to Java packages so bizarre. I must be too young to understand.
01:10:41 <doismellburning> arbn: the point being that you got a unique namespace, by bootstrapping off the domain ownership system
01:11:11 <monochrom> it's basically "reverse your company's domain/host name"
01:11:43 <doismellburning> arbn: none of this "bah someone else built Network.GitHub, wtf am I going to call my GH client"
01:12:20 <doismellburning> arbn: you just have "uk.co.doismellburning.GitHub" and "uk.me.mes.GitHub"
01:12:51 <arbn> doismellburning: I _guess_ that makes sense. Do people actually re-use Java modules in different projects?
01:13:09 <doismellburning> arbn: ...people publish code as libraries, yes
01:13:31 <arbn> OK.
01:13:39 <bartavelle> but java people use magic IDEs that automatically add imports, which would be a pain to do by hand, as most haskell users do today
01:14:48 <monochrom> there is a bit more than that, making Java more painful manually than Haskell manually
01:15:41 <bartavelle> that's for sure
01:15:50 <monochrom> you have the choice between "import xxx.yyy.*" and "import xxx.yyy.Class1; import xxx.yyy.Class2; import xxx.yyy.Class3"
01:16:10 <bartavelle> but I feel that the haskell namespace wars will be more bitterly fought at the package name level than the module name level
01:16:26 <monochrom> whereas in Haskell the latter is more simply "import XXX.YYY(Type1, Type2, Type3)"
01:16:28 <arbn> doismellburning: I worked with some people that wrote a pretty bad ORM from scratch instead of using Hibernate, etc. So, that question was just informed by my own limited experienced. :) Bad case of NIH syndrome at that office.
01:16:37 <arbn> who wrote*
01:17:33 <kazagistar> Regex is kinda a battlefield if we are talking about noisy module namespaces
01:18:53 <wz1000> monochrom: Java classes don't map to haskell types
01:20:27 <prinsen_> How do I export data types in a shared haskell library to be used iwth C?
01:20:50 <wz1000> How would you write the church pred function in haskell?
01:21:07 <monochrom> you can't export types to C
01:21:09 <bartavelle> prinsen_, I think the easiest way is to serialize your haskell data so that it's readable by C
01:21:49 <prinsen_> bartavelle: but its a large, multi-level record type generated with TH
01:22:03 <bartavelle> prinsen_, json encode it and send a string :p
01:23:02 <arbn> Hmm. Is there a tool already to generate a C struct definition from something like that?
01:26:23 <arbn> http://stackoverflow.com/questions/14500582/generate-a-c-struct-based-on-a-complex-haskell-type
01:28:15 <bartavelle> well, as you'll need to write the code that access this struct, you probably won't gain much by generating something automatically (unless you also generate the code)
01:30:49 <arbn> bartavelle: I think it probably does make more sense to return an opaque pointer and then also export Haskell getters, as suggested in that SO link.
01:31:35 <prinsen_> arbn: its 100's of data types generated by TH, so I rather just export as is
01:32:31 <bartavelle> but how are you going to access them if there are 100's of them ? write 100's of C files with the functions to handle them ?
01:33:15 <prinsen_> bartavelle: My TH library generates a lot of data types and functions on those datatypes
01:33:22 <prinsen_> i want to export them to use from C
01:34:02 <bartavelle> can you use TH to generate the Storable instances ?
01:34:19 <prinsen_> bartavelle: I sure can :)
01:34:45 <prinsen_> any links on how to proceed after generating the Storable instnace?
01:35:26 <bartavelle> actually IDK, for interop with C the best idea is to use an shared .h file so that you don't get bitten by differing packing strategies for example
01:35:42 <bartavelle> I don't even know how that helps you ;)
01:37:02 <bartavelle> well you could generate a .h file with the proper pragmas to make sure you know the memory representation
01:37:33 <bartavelle> then you'll probably need to generate functions in TH that write these .h files :/
01:55:58 <notdan> Is anyone here familiar with SYB?
01:56:40 <notdan> I have a query (Data a => a -> n)  for some specific n; I also have a function (forall b. Data b => b -> n)
01:56:48 <notdan> have can I "extend" the first query with the second one?
01:59:21 <rhz> Some code that looks for factors in huge integers, if anyone is interested: https://gist.github.com/rzil/3fd271c29daf854f5e7e
01:59:35 <rhz> (in haskell)
02:00:20 <dreixel> notdan: extQ?
02:21:50 <asfp> what is the typeclass for a monoid whose mappend can fail?
02:22:35 <dibblego> I have seen it called "merge"
02:22:40 <dibblego> a -> a -> Maybe a
02:27:04 <asfp> and what is the inverse of the Maybe monad, the one that will return on the first Just?
02:27:24 <asfp> dibblego: thanks btw :-)
02:28:29 <asfp> oh, I see this answered on SO as MonadPlus Maybe
02:29:11 <latk> I've just added a testsuite to my project, and when I try to run the test I get an error: cannot satisfy -package-id mypackage-inplace. Any ideas what this might be ?
02:29:13 <tdammers> Alternative?
02:29:36 <notdan> dreixel: extQ works only for specific datatypes, isn't it?
02:29:42 <notdan> *doesn't it
02:29:47 <Aruro> hi all why System.Info , os variable shows "mingw32" ?
02:29:58 <jle`> you can't really have a Maybe Monad instance that returns the first Just, because it won't typecheck
02:30:11 <jle`> but you probably can use Alternative and stuff like that to get what you want
02:31:54 <jle`> monads aren't the answer to everything :)
02:32:37 <wz1000> asfp: You can use 'liftM* <|>'  to get the first Just from * functions. Eg: liftM3 <|> f1 f2 f3 where f1, f2 and f3 can fail, the first Just will be returned
02:33:00 <wz1000> s/<|>/(<|>)
02:33:53 <wz1000> Sorry, you can only use liftM2 in this case
02:34:06 <wz1000> I'm sleepy so excuse me
02:34:10 <jle`> :t \f -> msum . sequence [f, f, f]
02:34:11 <Twey> What's the preferred package for a pure FIFO queue at the moment?
02:34:11 <lambdabot> MonadPlus m => (a -> m a1) -> a -> m a1
02:36:23 <jle`> msum . sequence [f1, f2, f3] for generic number of mergings :)
02:37:35 <wz1000> :t msum . sequence [f1, f2, f3]
02:37:36 <lambdabot>     Not in scope: ‘f1’
02:37:36 <lambdabot>     Perhaps you meant one of these:
02:37:36 <lambdabot>       ‘f’ (imported from Debug.SimpleReflect),
02:37:43 <wz1000> :t msum . sequence [id]
02:37:45 <lambdabot> MonadPlus m => m a -> m a
02:38:04 <wz1000> :t msum . sequence [const Nothing]
02:38:05 <lambdabot> a -> Maybe a1
02:38:18 <wz1000> :t sequence
02:38:19 <lambdabot> Monad m => [m a] -> m [a]
02:38:47 <jle`> > sequence [(*3), (+4), (^2)] 6
02:38:49 <lambdabot>  [18,10,36]
02:39:31 <wz1000> @src sequence
02:39:32 <lambdabot> sequence []     = return []
02:39:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:39:32 <lambdabot> --OR
02:39:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:40:40 <jle`> :t sequence `asAppliedTo` (+1)
02:40:41 <lambdabot>     Couldn't match expected type ‘[m a]’ with actual type ‘a0 -> a0’
02:40:41 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘(+ 1)’
02:40:41 <lambdabot>     In the expression: sequence `asAppliedTo` (+ 1)
02:40:45 <jle`> :t sequence `asAppliedTo` [(+1)]
02:40:46 <lambdabot> Num a => [a -> a] -> a -> [a]
02:41:10 <notdan> dreixel: basically, I want to run my query extension only on those fields/nodes that are *not* a specific type
02:41:27 <notdan> dreixel: for example, if type is Maybe/Int/Char, I want to run an old query. Otherwise, run the new one
02:42:59 <wz1000> To convert (Monad m1, Monad m2) => m1 (m2 a) -> m2 (m1 a), what do you need?
02:43:45 <wz1000> What additional constraints should m1 and m2 satisfy?
02:44:16 <notdan> Hm, I think I saw something similar in the `mmorph` package
02:44:49 <kazagistar> :t sequenceA
02:44:50 <lambdabot>     Not in scope: ‘sequenceA’
02:44:50 <lambdabot>     Perhaps you meant one of these:
02:44:50 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
02:45:01 <kazagistar> :t T.sequenceA
02:45:02 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
02:45:08 <notdan> or maybe not
02:45:15 <notdan> yeah, looks like a traversal
02:45:31 <hyPiRion> Is that possible? I don't think you can just flip Monads arbitrarily in general
02:46:27 <wz1000> hyPiRion: You cant flip arbitary monads, I was just asking what other information do you need other than the presence of '>>=' and return
02:46:35 <hyPiRion> oh, right
02:46:46 <wz1000> @src T.sequenceA
02:46:46 <lambdabot> Source not found. That's something I cannot allow to happen.
02:47:26 <kazagistar> its in the minimal definition of the Traversable typeclass
02:47:47 <wz1000> So you only need m1 to be Traversible?
02:48:29 <kazagistar> yep, the other one doesn't even have to be a Monad, it can just be Applicative
02:49:04 <wz1000> Also, why is Show called Show and not Showable, while Traversible is called Traversible?
02:50:34 <kazagistar> @instances Traversable
02:50:34 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
02:50:42 <tdammers> inconsistent naming, yeah... historical thing, I guess
02:50:43 <kazagistar> @instances T.Traversable
02:50:44 <lambdabot> Couldn't find class `T.Traversable'. Try @instances-importing
02:50:47 <kazagistar> oh, ew
02:51:32 <tdammers> Show is probably one of the oldest standard typeclasses in all of Haskell
02:51:38 <wz1000> @instances T.Traversible
02:51:39 <lambdabot> Couldn't find class `T.Traversible'. Try @instances-importing
02:51:39 <tdammers> Traversable is relatively new in comparison
02:51:54 <kazagistar> ohhhh derp
02:52:00 <kazagistar> @instances Traversible
02:52:01 <lambdabot> Couldn't find class `Traversible'. Try @instances-importing
02:52:27 <nshepperd> it's spelled Traversable
02:52:38 <nshepperd> I think lambdabot just doesn't know about its instances
02:53:07 <kazagistar> I guess the number of Traversable instances in Data.Traversable is really small, so I was wondering how I would find more
02:56:16 <kazagistar> ... I love how hackage does not display any documentation for orphan instances
02:56:26 <kalail> hmm
02:56:27 <kazagistar> http://hackage.haskell.org/package/vector-instances-3.3/docs/Data-Vector-Instances.html
03:09:03 <jle`> lambdabot doesn't have @instances
03:09:47 <kazagistar> is there a way to just find all instances of something, across hackage?
03:10:01 <kazagistar> "what can I do with this thing?"
03:10:16 <kazagistar> er rather
03:10:23 <kazagistar> "what can I use this with?"
03:10:34 <kazagistar> the first is useful too, of course
03:13:19 <nshepperd> hmm, I wonder if maybe you need the "opposite" of Traversable
03:14:06 <nshepperd> some common monads like Reader, State can't be made into Traversable instances
03:14:55 <nshepperd> because that requires you to implement sequenceA :: Reader r (IO a) -> IO (Reader r a), which is clearly impossible
03:18:27 <jle`> i think Data.Ditributive is the dual of Traversable
03:18:30 <jle`> or is it Data.Distribute
03:18:56 <jle`> :t T.traverse
03:18:57 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:19:13 <jle`> um
03:19:22 <jle`> :t T.sequence
03:19:23 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
03:19:27 <nshepperd> however, `unsequence :: m (Reader r a) -> Reader r (m a)` is possible for arbitrary Functor m
03:19:35 <jle`> distribute :: (Distributable t, Monad m) => m (t a) -> t (m a)
03:20:16 <nshepperd> ah, that looks right, yeah
03:20:50 <dreixel> :t everythingBut
03:20:50 <kazagistar> neat
03:20:51 <lambdabot> Not in scope: ‘everythingBut’
03:21:10 <dreixel> notdan: sorry, I wasn't here. did you find a solution yet?
03:23:34 <isomorphic> If I have something that runs in the ST monad (Data.HashTable.ST) and I want to combine that with IO (eg: a loop including looking up items in the hashtable and printing them) -- what's the right way to do it?  ST doesn't seem to have a MonadIO instance (http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html)
03:24:18 <nshepperd> http://hackage.haskell.org/package/distributive-0.4.4/docs/Data-Distributive.html looks a bit limited though
03:31:49 <pjdelport> isomorphic: stToIO ?
03:32:01 * hackagebot persistent-sqlite 2.1.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.0.1 (MichaelSnoyman)
03:32:31 <isomorphic> pjdelport:  I've been looking at that.  I think maybe the answer is in https://hackage.haskell.org/package/hashtables-1.1.2.1/docs/Data-HashTable-IO.html
03:34:07 <notdan> dreixel: yeah, kinda. I found one for my specific case. But is it possible to do something like this in general?
03:34:26 <notdan> like the way I described: to run my query extension only on those fields/nodes that are *not* a specific type
03:37:51 <phaazon_> is there a better way to write view (at n)?
03:38:12 <phaazon_> preview n ?
03:38:37 <phaazon_> > preview "foo" [("foo",3)]
03:38:39 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
03:38:39 <lambdabot>                with ‘(a -> Control.Applicative.Const (Data.Monoid.First a) a)
03:38:39 <lambdabot>                      -> [([GHC.Types.Char], t0)]
03:38:39 <lambdabot>                      -> Control.Applicative.Const
03:38:39 <lambdabot>                           (Data.Monoid.First a) [([GHC.Types.Char], t0)]’
03:38:51 <phaazon_> > preview "foo" (Data.Map.fromList [("foo",3)])
03:38:52 <lambdabot>  Not in scope: ‘Data.Map.fromList’
03:38:59 <phaazon_> > preview "foo" (M.fromList [("foo",3)])
03:39:00 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
03:39:00 <lambdabot>                with ‘(a -> Control.Applicative.Const (Data.Monoid.First a) a)
03:39:00 <lambdabot>                      -> Data.Map.Base.Map [GHC.Types.Char] a0
03:39:00 <lambdabot>                      -> Control.Applicative.Const
03:39:00 <lambdabot>                           (Data.Monoid.First a) (Data.Map.Base.Map [GHC.Types...
03:47:02 * hackagebot fpco-api 1.2.0.1 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.1 (MichaelSnoyman)
03:52:02 * hackagebot loop-effin 0.1.0.0 - control-monad-loop port for effin  http://hackage.haskell.org/package/loop-effin-0.1.0.0 (HiromiIshii)
03:52:57 <dreixel> notdan: have you looked at everythingBut?
03:53:08 <phaazon_> edwardk: hm, I was looking for a fromEither function in either package
03:53:11 <phaazon_> I guess it’s mapLeft
03:53:21 <phaazon_> (regarding how fromMaybe behaves)
03:59:21 <nshepperd> fromEither = (Control.Arrow.|||)
03:59:23 <nshepperd> ?
04:00:02 <nshepperd> > (const 5 ||| id) (Right 2)
04:00:04 <lambdabot>  2
04:00:20 <nshepperd> > (const 5 ||| id) (Left "bad")
04:00:21 <lambdabot>  5
04:00:38 <vanila> :t fromEither
04:00:39 <lambdabot> Not in scope: ‘fromEither’
04:00:52 <phaazon_> :t mapLeft
04:00:53 <lambdabot> Not in scope: ‘mapLeft’
04:01:00 <phaazon_> @let import Control.Lens
04:01:03 <lambdabot>  Defined.
04:01:09 <phaazon_> oops, not that
04:01:14 <phaazon_> @let import Data.Either
04:01:15 <lambdabot>  Defined.
04:01:18 <phaazon_> :t mapLeft
04:01:19 <lambdabot> Not in scope: ‘mapLeft’
04:01:27 <phaazon_> o–kay…
04:01:50 <phaazon_> off to lunch, see ya
04:02:17 <doismellburning> hoogle seems unhappy
04:12:03 * hackagebot engine-io-yesod 1.0.1 -   http://hackage.haskell.org/package/engine-io-yesod-1.0.1 (TimBaumann)
04:27:04 * hackagebot cluss 0.2 - simple alternative to type classes  http://hackage.haskell.org/package/cluss-0.2 (Kinokkory)
04:27:37 <greeny> i try to import module Tex.Parsec.Prim, but it cant be found. so i need to install it via cabal, right?
04:28:11 <Taneb> greeny, yes, it is in the parsec package
04:28:14 <Taneb> cabal install parsec
04:28:48 <greeny> k thx
04:35:44 <ph88> is   -     >    used to put something on a new line ?
04:37:12 <hpc> do you mean "   -     >    " or is my client being weird?
04:37:25 <ph88> your client i guess ^^
04:37:41 <vanila> looks same here
04:37:48 <BoR0> not hpc's client
04:38:22 <hpc> can you rephrase the question? put what on a new line?
04:38:53 <greeny> im not able do understand the newtype declaration of ParsecT :D WTF
04:39:14 <ph88> http://learnyouahaskell.com/input-and-output#exceptions          > putStrLn $ "Whoops! File does not exist at: " ++ path
04:57:48 <phadej_> /quit
05:01:55 <Fuuzetsu> so, what's a good way to find where an exception is coming from when I'm pretty sure it's coming from some library I'm using rather than my own code?
05:02:05 * hackagebot curlhs 0.1.3 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.3 (KrzysztofKardzis)
05:05:52 <ph88> hey guys    when i input the example input in this example program it doesn't display anything, even though there is no error     https://www.fpcomplete.com/project/66526/2m0qbbm0o2
05:07:06 * hackagebot curlhs 0.1.2 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.2 (KrzysztofKardzis)
05:07:08 * hackagebot curlhs 0.1.1 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.1 (KrzysztofKardzis)
05:09:57 <Fuuzetsu> ph88: doesn't it just get stuck in infinite loop somewhere?
05:10:02 <Fuuzetsu> it seems the program just keeps running
05:11:48 <Fuuzetsu> by the way, if you ask me, groupsOf 0 _ would probably be better off returning [] not undefined
05:12:06 * hackagebot json-autotype 0.2.0.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.0.0 (MichalGajda)
05:13:09 <ph88> Fuuzetsu: ok i changed that but it still keeps running
05:13:41 <Fuuzetsu> I would not think that would have fixed it, it was just a side note. I don't know what the actual fix is.
05:15:04 <ph88> hmm strange
05:20:10 <tac_> So I'm reading through SPJ's old 1987 Implementing Functional Proglangs book, and I was wondering if anyone can verify something for me
05:20:57 <gcganley> @src (.)
05:20:57 <lambdabot> (f . g) x = f (g x)
05:21:04 <gcganley> @src ($)
05:21:04 <lambdabot> f $ x = f x
05:21:15 <tac_> In terms of evaluation by graph reduction, what is a "thunk"?
05:21:21 <ph88> i dont see any recursion, so not sure why the program keeps running
05:21:25 <ph88> maybe its fpcomplete ?
05:21:55 <tac_> When I create a "thunk", does that just entail building a new spine of function applications?
05:22:19 <ph88> spine ?
05:22:47 <tac_> ph88: Yes. It's the thing the STG doesn't have, since it is "spineless" :)
05:23:47 <tac_> If you have a top-level function application, f x y z, you get a graph that looks like a human spine, if you squint a bit.
05:25:39 <staffehn> ChanServ: a
05:25:52 <staffehn> Oh, ignore this
05:26:31 <staffehn> :pl id
05:26:38 <staffehn> @pl id
05:26:39 <lambdabot> id
05:27:24 <staffehn> @pl (\xs ys -> length xs == length yx)
05:27:24 <lambdabot> const . (length yx ==) . length
05:28:19 <staffehn> @pl (\xs ys -> length xs == legth yx)
05:28:19 <lambdabot> const . (legth yx ==) . length
05:28:29 <staffehn> @pl (\xs ys -> length xs == length ys)
05:28:29 <lambdabot> (. length) . (==) . length
05:29:54 <staffehn> @pl (\a b -> f a == g b)
05:29:54 <lambdabot> (. g) . (==) . f
05:29:59 <gcganley> :staffehn did lambdabot miss a paren...
05:30:16 <gcganley> staffeh: did lambdabot miss a paren?
05:31:48 <staffehn> gcganley: where?
05:33:36 <staffehn> gcganley I don't think so.
05:36:17 <akagr> Hi Guys! I am new to haskell and was trying to learn it by doing a couple of practise problems. Can you help me in optimizing http://lpaste.net/112167
05:36:30 <staffehn> @pl (\f a b -> f a == f b)
05:36:30 <lambdabot> flip =<< (((.) . (==)) .)
05:36:40 <staffehn> Lol
05:37:48 <Ferdirand> O_O
05:37:51 <dramforever> akagr, why don't you use getLine
05:38:55 <akagr> dramforever: because I find it a bit difficult to maintain the flow... I use getContents to get the things lazily but in one expression
05:41:01 <dramforever> akagr, maybe replicateM n (read `fmap` getLine)
05:41:24 <dramforever> well, replicateM is in Control.Monad
05:41:53 <hexagoxel> ph88: does it consume cpu while running?
05:42:17 <ph88> hexagoxel: not sure, i can't install haskell on this pc so i use fpcomplete
05:42:51 <akagr> dramforever: thanks. I'll try that. A successful solution is making use of bytestrings. I was trying to get more juice out of my code before getting to that
05:42:53 <hexagoxel> ph88: it is waiting for input, probably
05:43:17 <ph88> hexagoxel: i submitted the example input (copy paste from website)
05:43:18 <hexagoxel> ph88: try something other than getContents, maybe
05:43:20 <dramforever> akagr: yes, it's more efficient, but hard to say it's more successful
05:43:37 <ph88> hexagoxel: maybe i can hardcode the list for a test instead
05:44:07 <akagr> dramforever: by successful I mean it got through the online judge
05:44:45 <dramforever> well, maybe it's because bytestrings are faster
05:45:07 <dramforever> akagr: why yours didn't pass? did the online say anything?
05:46:36 <akagr> dramforever: nopes... all I get is time limit exceeded... but then, the problem was really about handling large data and not simple logic of finding divisibles
05:46:56 <dramforever> akagr: oh, you want your code to be faster
05:47:03 <hexagoxel> The best path to take is: BCACBBC
05:47:04 <hexagoxel> The price is: 75
05:47:20 <hexagoxel> ph88: ^ output for heathrowToLondon
05:47:44 <akagr> dramforever: yep :) I am trying to solve some simple problems because I got tired of cramming tutorials in my small head
05:48:07 <dramforever> akagr: Is Integer required? if the input consists of not-so-big integers only then maybe Int will be faster
05:48:43 <akagr> the largest input is 10**9
05:49:05 <dramforever> akagr: then Int is okay
05:49:18 <dramforever> > maxBound :: Int
05:49:20 <lambdabot>  9223372036854775807
05:50:02 <staffehn> akagr: Doesn't it just exceed time limits because ir doesn't stop trying to get more contents after already having read n lines? I guess using getLine should fix it.
05:50:42 <dramforever> staffehn: well, I didn't notice that thing
05:50:52 <dramforever> akagr: you sure your code is correct?
05:50:53 <akagr> staffehn: the input is fed through a file... so getContents will be fine on that concern... I have used it on other problems before
05:51:00 <dramforever> akagr: oh
05:51:09 <ph88> hexagoxel: you changed it on fpcomplete ??
05:51:41 <hexagoxel> ph88: no, locally.
05:52:10 <ph88> hexagoxel: i changed it too  https://www.fpcomplete.com/project/66535/mAUd91tduk
05:52:26 <lpaste> dramforever pasted “Hey my new idea” at http://lpaste.net/112168
05:53:00 <dramforever> It (hopefully) captures the idea of y = f(x), where y depends on x
05:53:20 <dramforever> here x will be a IORef, and y = f `fmap` x
05:53:51 <dramforever> but FIORef is more, for example y = f a b, where f is constant and y depends on a and be
05:54:06 <vanila> dramforever, cool idea
05:54:15 <dramforever> you can have a and b as FromIORef, and y = f <$> a <*> b
05:55:03 <akagr> anyways... thanks for help guys... let me see if I can't get it to pass without using bytestrings
05:56:06 <dramforever> vanila and all, So I need all your help to see if I'm corect and if it's useful
05:57:02 <vanila> dramforever, I doubt it's useful
05:58:03 <dramforever> I thought about this when I was trying to separate computation and I/O in an imperative way
05:59:01 <hexagoxel> oh, it _is_ possible to unregister from sandbox.. neat.
05:59:07 <ph88> nice  https://www.gravatar.com/avatar/76a473697ce9ed86d1d1ef514abbd5b8
06:00:27 <dramforever> A program would consist of 1. Many data boxes, each with one output-pin 2. Many function boxes that has many inputs each connected to a output-pin, and a output-pin that depends on only input-pins and 3. A program that just has control flow and assignment, where control flow is in it's usual sense, and assignment copies from a output-pin to a input-pin
06:00:55 <dramforever> sorry, last "input-pin" should be changed to "data box"
06:00:55 <cemal> as a newcomer to functional programming and haskell. WHere should I start for developing web applications?
06:02:08 * hackagebot zmidi-score 0.3.0.0 - Representing MIDI a simple score.  http://hackage.haskell.org/package/zmidi-score-0.3.0.0 (BasDeHaas)
06:02:45 <dramforever> Whew, that was a long message
06:03:40 <staffehn> akagr, dramforever: How would ByteString be faster if all you would do is converting them to String for reading anyways. or is there something that goes directly (ByteString -> Int)?
06:04:09 <dramforever> staffehn: maybe, at least i think i saw one somewhere
06:04:10 <vanila> dramforever, have you seen Machines?
06:04:17 <johnw> staffehn: that depends, are you talking about a ByteString that represents ASCII digits, or a ByteString that encodes an Int?
06:04:17 <dramforever> vanila: nope
06:04:22 <vanila> e.g. https://hackage.haskell.org/package/machines-0.2.5/docs/Data-Machine-Mealy.html
06:04:23 <peteretep> CPAN has automated static code quality metrics that run over all distributions and are published; has someone seen anything similar for Hackage?
06:04:27 <vanila> i think it's similar to your idea
06:04:37 <vanila> might be interesting!
06:04:41 <staffehn> johnw ascii
06:04:44 <dramforever> vanila: Which package? machine?
06:05:04 <johnw> staffehn: even in that case, it can be faster, since you only need to consider ASCII rather than full Unicode codepoints
06:05:17 <johnw> i.e., x - ord '0' (like what you would do in C) will work
06:05:34 <doismellburning> win 48
06:05:36 <doismellburning> sorry
06:05:51 <dramforever> @hackage bytestring-lexing
06:05:51 <lambdabot> http://hackage.haskell.org/package/bytestring-lexing
06:05:54 <dramforever> haha
06:06:00 <johnw> however, lots and lots of little ByteStrings can hurt, since they use a minimum buffer size of 32K
06:07:30 <dramforever> oh, (another somewhat related question) so is there a function like break that goes Int -> Lazy.ByteString -> (Strict.ByteString, Lazy.ByteString) ?
06:07:48 <johnw> dramforever: lazy ByteStrings are literally lists of strict bytestrings
06:08:00 <johnw> so all you need to do is convert from lazy to a list of strict, then pattern match
06:08:50 <dramforever> johnw: nope not that
06:08:52 <johnw> the function you'd want is toChunks; and then use fromChunks on the tail
06:08:53 <staffehn> There are things like span for ByteStrings.
06:09:35 <dramforever> say I need to do let (a,b) = break i x
06:09:52 <staffehn> there is also break for bytestring
06:09:52 <tac_> johnw: Do the chunks have to be uniform size with a lazy bytestring?
06:09:57 <dramforever> In one of my program x is like 500M, so a strict bytestring won't do
06:10:11 <johnw> break bs = case toChunks bs of [] -> []; (x:xs) -> (x, fromChunks xs)
06:10:22 <johnw> oops, [] not () at the end
06:10:31 <johnw> tac_: there is a minimum chunk size, yes
06:10:38 <johnw> since the chunks are all strict bytestrings
06:10:43 <dramforever> but a is only a few (like 2) bytes, so a lazy bytestring is wasteful
06:11:01 <dramforever> johnw: You didn't see the Int arg, did you
06:11:08 <johnw> ahhh
06:11:08 <dramforever> :t Data.ByteString.break
06:11:10 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
06:11:18 <dramforever> oops, not break
06:11:21 <dramforever> :t span
06:11:23 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
06:11:23 <johnw> my apologies, I elided it mentally
06:11:33 <staffehn> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString.html#v:span
06:11:42 <dramforever> You know what I mean....Something like take and drop combined
06:11:46 <johnw> you could use take and just convert what you take to a strict bytestring, but I don't think there's a builtin to do that
06:12:07 <dramforever> johnw: Oh that might be interesting
06:12:18 <johnw> and doing it often will cost
06:12:27 <dramforever> I think Strict.concat (Lazy.toChunks a) will do
06:12:30 <johnw> ByteStrings really excel at shipping around bulk informatino
06:12:40 <johnw> Strings are much better at tons of cutting and pasting
06:12:41 <dramforever> johnw: a is really small, and x is really big
06:13:07 <johnw> concat . toChunks is called toStrict in the recent prelude
06:13:19 <peteretep> Has anyone seens something like hslint except for hackage distributions?
06:13:24 <johnw> err, not quite, n/m
06:14:40 <staffehn> @pl (\a b c d e -> e ( d ( c ( b a ))))
06:14:41 <lambdabot> (((((flip id .) . flip id) .) . flip id) .) . flip id
06:15:11 <dramforever> :t ono
06:15:13 <lambdabot>     Not in scope: ‘ono’
06:15:13 <lambdabot>     Perhaps you meant ‘on’ (imported from Data.Function)
06:15:14 <dramforever> :t on
06:15:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:15:24 <staffehn> @pl (\a b c d f -> f a b c d)
06:15:25 <lambdabot> (((flip .) . flip) .) . flip . flip id
06:15:52 <dramforever> @pl (\a b c d e f g -> d g a b e c f)
06:15:53 <lambdabot> (((((flip .) .) .) . flip . ((flip . (flip .) . flip) .)) .) . flip . (flip .) . flip flip
06:16:40 <wz1000> beautiful
06:16:49 <staffehn> @pl (\a b c -> b a ( b ( a c ) c))
06:16:50 <lambdabot> ap (ap . ((.) .) . flip id) (flip flip id . (ap .) . flip (.))
06:17:28 <staffehn> @pl (\a -> a $ a $ a $ a $ a)
06:17:28 <lambdabot> ap id (ap id (ap id (join id)))
06:17:38 <dramforever> @pl (\a b c -> a b b c c b c b c)
06:17:39 <lambdabot> flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . join
06:17:47 <staffehn> Haha
06:18:53 <dramforever> :t flip flip flip flip
06:18:54 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:19:14 <wz1000> Listen to it with espeak.
06:19:27 <hyPiRion> I think pointfree versions à la (\a b c d e f g -> d g a b e c f) should be named pointfree pancake variants.
06:19:58 <staffehn> @pl (\f a g b h c i d j e x y -> h (f b a (g d c (e f x x x y) x x x y) d (j $ i $ j $ i $ j y y x a b c d e)))
06:20:01 <lambdabot> (((flip ((.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) . flip ap (((((ap ((.) . (.) . (.) . ($)) .) .) .) .) . ((ap ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . ((((ap ((.) . (.) . (.) . ($)) .) .) .) .) . ((flip ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((
06:20:01 <lambdabot> flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip . flip ap id)) . (flip .) . ((ap .) .) . (((ap .) .) .) . (((((.) .) .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . (((((ap .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . (((((((ap .) .) .) .) .) .) .) . flip (
06:20:01 <lambdabot> flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ap (flip . ((.) .) . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) (flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .
06:20:01 <lambdabot> ) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) .
06:20:01 <lambdabot>  flip (flip . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) . flip (flip . (ap .) . flip (flip . (ap .) . flip id) id) id) id) id) id) id)) id
06:20:03 <lambdabot> optimization suspended, use @pl-resume to continue.
06:20:11 <hyPiRion> It's just flipping
06:20:11 <staffehn> @pl-resume
06:20:15 <hyPiRion> oh lord.
06:20:18 <lambdabot> (((flip ((.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) . flip ap (((((ap ((.) . (.) . (.) . ($)) .) .) .) .) . ((ap ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . ((((ap ((.) . (.) . (.) . ($)) .) .) .) .) . ((flip ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((
06:20:18 <lambdabot> flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip . flip ap id)) . (flip .) . ((ap .) .) . (((ap .) .) .) . (((((.) .) .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . (((((ap .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . (((((((ap .) .) .) .) .) .) .) . flip
06:20:18 <lambdabot> flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ap (flip . ((.) .) . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) (flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .)
06:20:18 <lambdabot>  .) .) .) . (((((ap .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .)
06:20:18 <lambdabot> .) .) . flip (flip . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) . flip (flip . (ap .) . flip (flip . (ap .) . flip id) id) id) id) id)
06:20:20 <lambdabot> optimization suspended, use @pl-resume to continue.
06:20:22 <staffehn> @pl-resume
06:20:34 <lambdabot> (((flip ((.) . (.) . (.) . (.) . (.) . (.) . (.)) .) .) .) . flip ap (((((ap ((.) . (.) . (.)) .) .) .) .) . ((ap ((.) . (.) . (.) . (.) . (.)) .) .) . ((((ap ((.) . (.) . (.)) .) .) .) .) . ((flip ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) .
06:20:34 <lambdabot> (flip .) . ((flip .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip . flip ap id)) . (flip .) . ((ap .) .) . (((ap .) .) .) . (((((.) .) .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . (((((ap .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . (((((((ap .) .) .) .) .) .) .) . flip flip id . (flip .) . ((
06:20:34 <lambdabot> flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ap (flip . ((.) .) . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) (flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .)
06:20:34 <lambdabot> .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip
06:20:34 <lambdabot> . (flip .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . flip) . flip flip id . (ap .) . flip flip id . (ap .) . flip id)
06:20:36 <lambdabot> optimization suspended, use @pl-resume to continue.
06:20:39 <wei2912> e3e3eee...
06:20:42 <Qfwfq> @pl (\a e c n p k -> p a n c a k e)
06:20:42 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . (flip .)) .) . flip . (flip .) . flip . flip id)
06:20:48 <staffehn> @pl-resume
06:20:48 <lambdabot> pointless: sorry, nothing to resume.
06:20:50 <wei2912> that's a lot of bot spam lol
06:21:06 <dramforever> can anyone ban lambdabot for a bit?
06:21:15 <bernalex> dramforever: why would you ban lambdabot?
06:21:19 <hyPiRion> You could do a temporary /ignore it
06:21:23 <wei2912> more of banning whoever does stuff like that
06:21:27 <dramforever> bernalex: lambdabot is sending spam
06:21:27 <wei2912> and even then
06:21:31 <bernalex> dramforever: uh no
06:21:34 <staffehn> @pl (\f a g b h c i d j e x y -> (f $ f $ g $ g $ h $ h $ i $ i $ j $ j $ e d c b a b c d e x x y)
06:21:34 <lambdabot> (line 1, column 95):
06:21:34 <lambdabot> unexpected end of input
06:21:34 <lambdabot> expecting variable, "(", operator or ")"
06:21:39 <staffehn> @pl (\f a g b h c i d j e x y -> (f $ f $ g $ g $ h $ h $ i $ i $ j $ j $ e d c b a b c d e x x y))
06:21:39 <wei2912> dramforever: it's supposed to, just saying
06:21:42 <lambdabot> ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . ($)) ((. (ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . ($)) . flip ((.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . ($)) . (ap ((.) . (.) . (.) . (.) . (.) . (.) . (.) . ($)) .) . (flip ((.) . (.) . (.) . (.) . (.) . (.) . (.) . ($)) .) . ((ap ((.) . (.) . (.)
06:21:42 <lambdabot>  . (.) . (.) . ($)) .) .) . ((flip ((.) . (.) . (.) . (.) . (.) . ($)) .) .) . (((ap ((.) . (.) . (.) . ($)) .) .) .) . (((flip ((.) . (.) . (.) . ($)) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip
06:21:42 <lambdabot> .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . flip ap id . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . ($))
06:21:42 <lambdabot> optimization suspended, use @pl-resume to continue.
06:21:43 <bernalex> staffehn: that's quite enough.
06:22:01 <wei2912> staffehn: you should message lambdabot in PM
06:22:02 <hyPiRion> staffehn: possible to do that in private message
06:22:04 <wei2912> private*
06:22:18 <tdammers> indirect flooding, this
06:22:20 <staffehn> oh, you can pm lambdabot..
06:22:31 <wei2912> ...
06:22:34 <staffehn> sorry I'll stop
06:23:11 <dramforever> AAAAAA I keep typing .js when I'm supposed to type .hs
06:23:24 <vermeille> Did quickcheck's $quickCheckAll changed its behavior recently? I upgraded the library then my test program doesn't display anything anymore
06:23:31 <wz1000> dramforever: I keep typing hs when I mean sh
06:23:35 <Aruro> guys what does $= mean? in construction like displayCallback $= display
06:23:40 <Aruro> it is from GLUT example
06:23:45 <staffehn> I think haskell's standard lib could use better pointless combinators.
06:23:59 <dramforever> Aruro: it's like writeIORef, iirc the name
06:24:01 <Aruro> is it same as displayCallback (=display) ?
06:24:03 <vermeille> Aruro: AFAIK It's related to Conduit library
06:24:09 <ClaudiusMaximus> Aruro: it's from Data.StateVar i think
06:24:12 <awm> http://ohjp.teresnab.ru/84247/r1586154/honest income money without cheating regestriruetsya) $ 1000 in 2 days
06:24:16 <dramforever> Aruro: no $= is one thing together
06:24:20 <dramforever> :t ($=)
06:24:20 <Aruro> ok
06:24:22 <Aruro> ty
06:24:25 <lambdabot>     Not in scope: ‘$=’
06:24:25 <lambdabot>     Perhaps you meant one of these:
06:24:25 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
06:24:30 <dramforever> ouch
06:24:37 <Aruro> yeah its in GLUT library
06:24:38 <Aruro> i think
06:24:39 <dramforever> :t (Data.StateVar.$=)
06:24:40 <lambdabot> Not in scope: ‘Data.StateVar.$=’
06:24:45 <dramforever> ouch
06:24:55 <augur> wz1000, jle`: worth observing:    id = foldr (:) []    sequence = foldr (liftM2 (:)) (return [])
06:25:03 <wei2912> lol @ awm
06:25:07 <wei2912> everyone just ignored him
06:25:11 <augur> this is a bit late but whatever
06:25:30 <Aruro> yea some russian speaking spammer :D
06:25:31 <Aruro> lol
06:25:54 <ClaudiusMaximus> oh, seems to be in the OpenGL library now, think it got moved because nothing outside the gl libraries used it
06:25:56 <augur> oh yes, Cale ^ awm spamming. not hugely important now but for ban lists later maybe
06:25:57 <Aruro> only in russia you earn 1000 in 2 days :D and Nigeria :)
06:26:02 <vermeille> Any idea why QuickCheck decided to remain silent after a library update?
06:26:20 <Aruro> but what it means? $=
06:26:35 <augur> Aruro: and america, if you're in the top 1-5%
06:26:44 <wz1000> augur: Cool
06:26:44 <Aruro> yeah
06:26:53 <Aruro> top 1 5  is good idea
06:26:59 <wz1000> $ pointfree " (\a b c -> a b b c c b c b c) " | espeak
06:27:04 <vermeille> augur: even at facebook I did not earn that much
06:27:09 <staffehn> Aruro: http://hackage.haskell.org/package/OpenGL-2.9.2.0/docs/Graphics-Rendering-OpenGL-GL-StateVar.html#v:-36--61-
06:27:09 * hackagebot random-effin 0.1.0.0 - A simple random generator library for effin  http://hackage.haskell.org/package/random-effin-0.1.0.0 (HiromiIshii)
06:27:21 <akagr> can anyone tell me what's wrong with the following line?
06:27:22 <akagr>   n <- fmap (map read . words) getLine :: [Int]
06:27:30 <Aruro> ty! staffehn
06:27:37 <dramforever> akagr, you need IO [Int]
06:27:41 <augur> wz1000: a lot of really good stuff comes from taking old combinators like map or foldr, and applying them naively to lifted things, or redefining them with lifting things, or whatever
06:28:05 <dramforever> :t (\a b c -> a c (b c))
06:28:06 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
06:28:09 <dramforever> :t on
06:28:10 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:28:20 <akagr> dramforever: the type signature applies to only right side of the arrow?
06:28:21 <augur> vermeille: $1000/d * 365d/yr = $365k/yr. i've know ruby devs who get paid $200k+ a year, so they're over $500/d
06:28:25 * int-e wonders why lambdabot doesn't limit the length of @pl output to channel though...
06:28:35 <bernalex> int-e: it did
06:28:35 <dramforever> akagr: yeah it's one expression
06:28:36 <staffehn> We need a lmhtfy, like lmgtfy but with hoogle.
06:28:37 <augur> vermeille: 365k s year is feasible for some jobs
06:28:41 <Aruro> so the logic of displayCallback $= display is what?
06:28:48 <augur> wz1000: another good one is traverse
06:28:53 <augur> :t traverse
06:28:54 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:28:57 <augur> @src traverse
06:28:57 <lambdabot> Source not found. It can only be attributed to human error.
06:29:00 <Aruro> displayCallback is type i think and display is a function
06:29:01 <augur> aww man :(
06:29:03 <vermeille> augur: O_O That's completely insane.
06:29:14 <awm> http://goo.gl/jftdr9 honest income money without cheating regestriruetsya) $ 1000 in 2 days
06:29:27 <dramforever> well I'm having problems with stuff like seq, par...
06:29:27 <Haskellfant> augur: traverse is implemented by the instance of traversable, what do you expect @src to give you?
06:29:39 <ClaudiusMaximus> Aruro: it sets the display callback
06:29:39 <wei2912> i wonder who thinks spam is a good idea to advertise
06:29:41 <dramforever> whenever I use them, my code becomes slower
06:29:47 <augur> well, traverse is basically map, but with applicative lifting
06:29:51 <peteretep> Contracting in London pays 450 a day for Perl, Ruby, etc
06:29:55 <peteretep> That seems to be about the going rate
06:30:06 <peteretep> That's GBP. And there are significant tax benefits too
06:30:19 <augur> incidentally, wz1000, traverse happens to be map-then-sequence, when both are defined, i think
06:30:24 <albeit> If I am reading from a datagram socket, would it ever make sense to read the data as Lazy ByteString? From my understanding, the entire datagram will be there when I need to read, so might as well read to a Strict ByteString?
06:30:44 <dramforever> albeit: not if it's not sequenced
06:30:49 <srhb> albeit: Depends how you will consume that ByteString, too.
06:30:54 <dramforever> well yes
06:30:58 <augur> Haskellfant: oh yes, thats right, doh. :)
06:31:14 <augur> Haskellfant: i expect all logically possibly implementations! hmph!
06:31:26 <albeit> dramforever: What do you mean by sequenced?
06:31:32 <srhb> albeit: Strictly loading a 2GB ByteString into memory is silly if you can consume it bit by bit.
06:31:50 <Haskellfant> augur: this would result in lambdabot getting banned for flooding
06:31:54 <dramforever> albeit: maybe I'm using the wrong word, but I mean sockets like UDP
06:31:57 <augur> :p
06:31:59 <albeit> srhb: True, these will all be <4KB, and trying to decide between cereal and binary for decoding it
06:32:09 * hackagebot haskell-packages 0.2.4.3 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.4.3 (RomanCheplyaka)
06:32:20 <albeit> dramforever: Yes, its a UDP datagram... still not sure what sequenced means?
06:32:45 <srhb> albeit: If they're that small you might as well go with strict ByteStrings so there's less to think about.
06:32:47 <dramforever> say you send three packets a b c through UDP
06:33:03 <dramforever> the other side might get c a b
06:33:34 <albeit> dramforever: Ah I see what you mean, the sequencing of packets is handled at another level of the application, doesn't matter at the decoding level
06:33:44 <wz1000> augur: Wouldn't it be better to say 'foldr (:) [] = id' instead of the other way around?
06:34:16 <albeit> srhb: Shall do, thanks
06:34:36 <augur> wz1000: equality is symmetric! :)
06:35:03 <dramforever> are there any good tutorials on seq?
06:35:30 <dramforever> I need to understand when to use it
06:35:49 <dramforever> Because whenever I use it my program gets slower
06:36:02 <wz1000> augur: But you are writing haskell, so it is implied that you are following haskell definitons
06:36:33 <dramforever> wz1000: iirc augur said "wouldn't it be better"
06:36:57 <augur> wz1000: no, that definitely cant be a haskell definition
06:37:09 <augur> wz1000: actually if it were, it would HAVE to be id = foldr (:) []
06:37:15 <augur> but it wasnt a definition
06:37:32 <dramforever> augur: maybe === would be better?
06:37:50 <augur> dramforever: === isnt a thing. the accepted notation in the haskell community is =
06:37:58 <dramforever> oh then
06:38:09 <dramforever> Hey, just curious...
06:38:14 <dramforever> @hackage acme-http
06:38:14 <lambdabot> http://hackage.haskell.org/package/acme-http
06:38:22 <dramforever> @hackage acme-lookofdisapproval
06:38:22 <lambdabot> http://hackage.haskell.org/package/acme-lookofdisapproval
06:38:43 <dramforever> What are those acme packages? They seem like jokes
06:38:47 <dramforever> but why acme?
06:38:53 <augur> they probably are
06:38:54 <doismellburning> ?acme
06:38:57 <doismellburning> er
06:39:00 <lambdabot> Local time for doismellburning is Mon Oct  6 14:41:23 2014
06:39:23 <doismellburning> ...that was not what I expected
06:39:56 <EvanR> dramforever: acme is a fictional company that makes all the bizarre gag products for old cartoons
06:40:26 <EvanR> dramforever: i like acme-now and acme-don't
06:40:26 <predator117> @hackage acme-stringly-typed
06:40:27 <lambdabot> http://hackage.haskell.org/package/acme-stringly-typed
06:40:33 <dramforever> It seems that there's a whole category (hackage category!) for acme
06:40:35 <predator117> had me laughing the first time
06:40:46 <dramforever> EvanR: yeah I like lookofdisapproval better
06:40:56 <dramforever> In fact I'm actually using it
06:41:20 <RchrdB2> dramforever: the list of Perl packages whose names start with "Acme::" is much longer. :)
06:41:31 <RchrdB2> But it's nice that there are some Haskell ones too. ^_^
06:41:45 <dramforever> ha ha ha ha
06:41:49 <dramforever> @acme-comonad
06:41:50 <lambdabot> Unknown command, try @list
06:42:02 <dramforever> @hackage acme-comonad
06:42:03 <EvanR> comonad normally isnt a joke right
06:42:04 <lambdabot> http://hackage.haskell.org/package/acme-comonad
06:42:20 <dramforever> Control.Commonad is double-Co
06:42:36 <EvanR> cocomonad
06:42:38 <dramforever> so acme-comonad exposes a module called Ntrol.Monad
06:43:20 <nateb> Possibly stupid question: Type constructors of a single parameter have kind * -> *; there are classes (say, Foldable) that expect this kind.  I have a kind * -> * -> *; is there some trick to make an instance (of, again, Foldable) that takes this kind?  There is an instance Foldable (Either a), but I don't have the luxury to apply one type to have it be thrown away.
06:44:10 <dramforever> nateb: i guess you need to be more specific
06:44:45 <EvanR> nateb: you cant add an a like that?
06:45:03 <staffehn> nateb: Foldable instances for Either are pretty useless anyways
06:45:51 <nateb> dramforever: probably, but I'm not sure how.  I've got some type constructor X a b, which has the ability to be folded, but can't be made into a Foldable instance because it requires both a and b to fold.
06:46:00 <nateb> staffehn: it appears so.
06:46:19 <dramforever> nateb: maybe it's foldable, but not Foldable
06:46:30 <nateb> EvanR: sadly no, without both a and b, there is no way to fold it.
06:46:55 <staffehn> nateb: What you want - an instance like (Foldable Either) doesn't work, and in my opinion makes little sense. If you could tell us why you would need such instance we could maybe point out what you really should do.
06:47:03 <nateb> dramforever: that's what I came to the conclusion of, but I figured that in my ignorance I may have overlooked the right way to do it.
06:47:24 <dramforever> nateb, maybe ive us your code
06:47:30 <dramforever> ive -> give
06:47:43 <dramforever> > runST (newSTRef 1)
06:47:45 <lambdabot>  Couldn't match type ‘a’ with ‘GHC.STRef.STRef s a0’
06:47:46 <lambdabot>    because type variable ‘s’ would escape its scope
06:47:46 <lambdabot>  This (rigid, skolem) type variable is bound by
06:47:46 <lambdabot>    a type expected by the context: GHC.ST.ST s a
06:47:46 <lambdabot>    at <interactive>:1:1-18
06:48:26 <nateb> dramforever: sadly, my employer would take exception to that... it makes this a bit more difficult :^(
06:48:27 <dramforever> Does ST count as an exploit of rank n types?
06:48:40 <dramforever> nateb: your employer needs Foldable???
06:49:08 <nateb> dramforever: Is it so hard to believe that I use Haskell at my job? :^)
06:49:27 <dramforever> nateb: no, but your *employer* cares???
06:50:07 <dramforever> Your employer need to ship a Foldable instance???
06:50:10 <nshepperd> employers frequently have hangups about posting source code on the internet
06:50:11 <EvanR> lol in the future, your manager makes unreasonable, or undecidable demands of your haskell code
06:50:14 <pjdelport> dramforever: Yes.
06:50:18 <pjdelport> :t runST
06:50:19 <lambdabot> (forall s. ST s a) -> a
06:50:57 <Aruro> when you compile a program based on Graphics.UI.Glut is exe file self sufficient?
06:51:01 <pjdelport> dramforever: The universal quantification is what provides the guarantee that the state thread can't "escape".
06:51:05 <Aruro> or it need some libraries to be present in the system
06:51:21 <nshepperd> nateb: is your type a http://hackage.haskell.org/package/bifunctors-0.1.2/docs/Data-Bifoldable.html ?
06:51:25 <pjdelport> dramforever: http://www.haskell.org/haskellwiki/Monad/ST#An_explanation_in_Haskell-Cafe
06:51:38 <dramforever> pjdelport: usually if I have data Foo = DoubleFoo Double | IntFoo Int I write a function liftOrd :: (forall a. Ord a => a -> a -> Bool) -> Foo -> Foo -> Bool
06:51:57 <wz1000> @define (.) a b = (a,b)
06:51:58 <lambdabot>  .L.hs:154:12:
06:51:58 <lambdabot>      Ambiguous occurrence ‘.’
06:51:58 <lambdabot>      It could refer to either ‘L..’, defined at .L.hs:155:3
06:51:58 <lambdabot>                            or ‘Data.Function..’,
06:51:58 <lambdabot>                               imported from ‘Data.Function’ at .L.hs:85:1-20
06:51:58 <dramforever> That would be why I use rank n types
06:52:17 <wz1000> @let (.) a b = (a,b)
06:52:18 <lambdabot>  .L.hs:154:12:
06:52:18 <lambdabot>      Ambiguous occurrence ‘.’
06:52:18 <lambdabot>      It could refer to either ‘L..’, defined at .L.hs:155:3
06:52:18 <lambdabot>                            or ‘Data.Function..’,
06:52:19 <lambdabot>                               imported from ‘Data.Function’ at .L.hs:85:1-20
06:52:45 <augur> easy there wz1000
06:52:56 <dramforever> because otherwise in liftOrd (>) it would have to be both Int -> Int -> Bool and Double -> Double -> Bool
06:53:02 <nshepperd> what kind of monster redefines (.)
06:53:17 <wz1000> http://hackage.haskell.org/package/acme-pointful-numbers-0.1.2.4/docs/Acme-Pointful.html
06:53:21 <dramforever> and the compiler won't know what to call the arg of liftOrd
06:53:23 <wz1000> nshepperd: This kind
06:53:25 <opqdonut> nshepperd: Control.Category
06:54:01 <dramforever> Hey w.r.t acme-realworld
06:54:06 <dramforever> @hackage acme-realworld
06:54:06 <lambdabot> http://hackage.haskell.org/package/acme-realworld
06:54:21 <nateb> nshepperd: Oooo!  I think this may be perfect.  Even if it isn't, it's very nifty.  Thank you!
06:54:39 <dramforever> why it does not just provide functions dealing with State# RealWorld?
06:54:47 <dramforever> It would be much safer
06:56:07 <nateb> dramforever:  Yeah, sadly my employer is quite particular about not sharing.  However, they are not terribly particular about how we do certain parts of our work.  So, I get to use Haskell (sometimes), but I don't get to show anyone.  It's a tradeoff.
06:56:45 <dramforever> nateb so why foldable when it's just you who need t
06:56:46 <dramforever> it
06:57:13 <nshepperd> hah 'Perform an action and return its value, but undo any side effects to the universe. Thus, it appears to return instantly, regardless of how long the action would take to run. The caller must ensure that the program would have enough time to perform the computation. Otherwise, either an exception will be thrown, or the operation will block because it never gets a chance to restore the original state of
06:57:15 <nshepperd> the universe.'
06:57:35 <tdammers> sounds legit
06:57:36 <dramforever> nshepperd: I think acme-realworld is doing one thing wrong
06:58:06 <dramforever> it's unsafeCoerce#-ing between State# RealWorld and RealWorld
06:58:17 <dramforever> I don't know if it's safe
06:58:51 <Ferdirand> i've heard stories of people redefining (.) to fmap
06:59:02 <Ferdirand> voups, too late
06:59:05 <dramforever> ha ha ha
06:59:14 <dramforever> @src (.)
06:59:14 <lambdabot> (f . g) x = f (g x)
06:59:22 <tdammers> if anything, (.) should be redefined to (<>)
06:59:30 <tdammers> or maybe (++)
06:59:33 <dramforever> > id . id $ 1
06:59:36 <lambdabot>  1
07:00:02 <nshepperd> well, clearly it's never safe to manipulate states of the universe directly. A bitflip caused by a stray cosmic ray could be disastrous
07:00:18 <Ferdirand> tdammers: shouldn't (++) be redefined to (<>) already ? :)
07:00:34 <dramforever> :t (>>>)
07:00:35 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:00:39 <nateb> dramforever: Valid point.  My reply is... that I don't have a great answer to that.  Perhaps it's the same reason I make instances of a lot of common classes - it looks like the right tool to do the job in a really flexible and powerful way, and I inevitably end up using that flexibility and power later.
07:00:55 <dramforever> nateb: not if you can't do it
07:01:44 <nateb> dramforever: Absolutely!  But I'm not an expert, so I thought I could learn something by posing the question here.  Which I did :^)
07:02:03 <dramforever> I almost never try to make instances other than derived ones for data's and newtype's I make
07:02:31 <tdammers> Ferdirand: disregard me, I was making a stupid thinly-veiled stab at PHP
07:02:33 <dramforever> because if I need to, then someone else probably did it already
07:02:46 <tdammers> Ferdirand: other than that, yes, and rightfully so
07:03:00 <tdammers> Ferdirand: I tend to just use <> over ++ whenever I can
07:03:26 <hpc> all of my code uses (<>) = getLine
07:03:27 * hpc ducks
07:03:36 <dramforever> hpc, well
07:03:45 <dramforever> @hackage acme-php
07:03:45 <lambdabot> http://hackage.haskell.org/package/acme-php
07:03:49 <dramforever> it's for you
07:03:55 <hpc> it's /by/ me
07:03:57 <Haskellfant> hpc: that's disgusting
07:04:11 <dramforever> Oh
07:04:32 <dramforever> and I don't get the file_not_found joke
07:05:10 <Ferdirand> the daily wtf ?
07:05:19 <hpc> dramforever: google file_not_found, the source is literally the first result
07:05:24 <hpc> before any legit uses of the identifier
07:06:08 <dramforever> ... still don't get it ...
07:06:13 <nshepperd> oh, it's the launchMissiles action: http://hackage.haskell.org/package/acme-missiles-0.3/docs/Acme-Missiles.html
07:06:15 <lpaste> hughfdjackson pasted “AST.hs” at http://lpaste.net/112169
07:06:21 <hughfdjackson> Hey all
07:06:32 <nshepperd> very useful, I need that frequently
07:06:42 <hughfdjackson> I've got an AST in which there's the concept of a statement - which can, in part, comprise of expressions
07:07:19 <hughfdjackson> there's also an ExprGroup type, which lets you group up statements and turn it into an expression: e.g. `{ let a = a; a }` is a Expression Group
07:07:20 <dramforever> hughfdjackson: maybe you want newtype Name = Name String
07:07:32 <hughfdjackson> dramforever: :# ah, *that's* the one that disappears at runtime?
07:07:41 <dramforever> hughfdjackson: yeah
07:07:44 <hughfdjackson> great :)
07:07:45 <hughfdjackson> thanks
07:08:17 <hughfdjackson> my question is.. can I avoid writing the Program type, with its PStmt and PExpr (just wrappers for Stmt and Expr)
07:08:17 <dramforever> hughfdjackson: newtypes can't have multiple constructors and can't have multiple fields
07:08:38 <hughfdjackson> dramforever: that makes sense, if they're destined to disappear :D
07:08:47 <dramforever> hughfdjackson: Why not data Stmt = FnDef ... | ExprStmt Expr
07:09:06 <dramforever> That's what "other" languages define, afaik
07:09:18 <hughfdjackson> dramforever: ... that'd just be sensible :p
07:09:21 <hughfdjackson> thanks, I'll give that a go
07:09:46 <EvanR> expression statement, and statement expression, be flexible ;)
07:10:07 <hughfdjackson> EvanR: not *too* flexible !
07:10:22 <Ferdirand> that acme-php thing is awesome
07:10:31 <Ferdirand> made my day
07:10:32 <hughfdjackson> oOo i guess that means that I should fix my ExprGroup constructor so it'll definitely return an expression
07:10:40 <dramforever> You can have fix $ ExprStmt . StmtExpr
07:10:55 <dramforever> hughfdjackson: why exprgroup?
07:11:14 <hughfdjackson> dramforever: you  mean 'why fix it', or 'why have it?'
07:11:17 <Aruro> is following syntax correct? does not complie: color3f r g b = color $ Color3 r g (b :: GLfloat)
07:11:20 <dramforever> why have it
07:11:34 <dramforever> Aruro: no
07:11:51 <hughfdjackson> dramforever: it's for an impure toy lang
07:12:06 <Aruro> yes i also think so but dont know how to use :: correctly at the end
07:12:11 * hackagebot htsn-import 0.1.2 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.1.2 (MichaelOrlitzky)
07:12:17 <dramforever> Aruro: why not add another line saying color3f :: GLFloat -> GLFloat -> GLFloat -> ???
07:12:28 <Aruro> yes
07:12:29 <dramforever>  color3f r g b =  color $ Color3 r g (b :: GLfloat)
07:12:31 <Aruro> definitely
07:12:50 <hughfdjackson> I was thinking it would be useful to have as a primitive in the language - so you could `let x = { log "a thing"; 1 }`, or as an fn body `x a = { log a; a }`
07:12:52 <Aruro> so is last line correc without first?
07:12:55 <dramforever> :t let color3f r g b =  id $ (,,,) r g (b :: GLfloat) in color3f
07:12:56 <lambdabot>     Not in scope: type constructor or class ‘GLfloat’
07:12:57 <hughfdjackson> or as a conditional body
07:13:03 <dramforever> :t let color3f r g b =  id $ (,,,) r g (b :: Float) in color3f
07:13:04 <lambdabot> a -> b -> Float -> d -> (a, b, Float, d)
07:13:12 <EvanR> hahaha pi = "3.14"
07:13:13 <dramforever> ouch, too many ,
07:13:17 <dramforever> :t let color3f r g b =  id $ (,,) r g (b :: Float) in color3f
07:13:18 <lambdabot> a -> b -> Float -> (a, b, Float)
07:13:44 <Aruro> i dont understand construction (b::GLfloat)
07:13:45 <hughfdjackson> dramforever: so there's one primitive idea of 'use Unit-returning side effects in the context of an otherwise useful expression' in the syntax
07:13:52 <hughfdjackson> :p could well be a bad idea !
07:13:53 <Aruro> it tells only b has this type? or all arguments?
07:13:54 <dramforever> Aruro: What's the type of Color3 ?
07:14:11 <dramforever> hughfdjackson: okay that makes sense
07:14:12 <Aruro> i think Color3 is constructor
07:14:21 <dramforever> it has a type anyway
07:14:24 <albeit> Is there a generic void? Something like "m a -> m ()"
07:14:25 <Aruro> same
07:14:25 <dramforever> :t Left
07:14:26 <lambdabot> a -> Either a b
07:14:28 <dramforever> :t Just
07:14:29 <lambdabot> a -> Maybe a
07:14:34 <Aruro> GLfloat
07:14:37 <albeit> Oh man, its called void, nvm
07:14:43 <dramforever> albeit: haha
07:15:00 <opqdonut> I thought void was usually a -> Void
07:15:02 <opqdonut> :t void
07:15:03 <lambdabot> Functor f => f a -> f ()
07:15:05 <opqdonut> ok
07:15:05 <albeit> I just looked at Hoogle's first result which was only IO :(
07:15:20 <dramforever> @src void
07:15:21 <lambdabot> Source not found. Whoa.
07:15:24 <dramforever> @src void
07:15:24 <lambdabot> Source not found. Do you think like you type?
07:15:42 <dramforever> let void = (() <$) in void Nothing
07:15:46 <dramforever> > let void = (() <$) in void Nothing
07:15:47 <lambdabot>  Nothing
07:15:53 <dramforever> > let void = (() <$) in void (Just 12)
07:15:54 <lambdabot>  Just ()
07:16:02 <dramforever> > let void = (() <$) in void [1,2,5,5,7]
07:16:04 <lambdabot>  [(),(),(),(),()]
07:16:07 <dramforever> Looks great
07:20:07 <dramforever> is there any known good computer algebra system written in haskell?
07:22:15 <pjdelport> http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Computer_Algebra ?
07:22:46 <dramforever> pjdelport: the docon one goes 404
07:23:18 <dramforever> and papers are not interesting enough to me
07:23:27 <pjdelport> http://www.botik.ru/pub/local/Mechveliani/docon/ seems to be there
07:23:59 <pjdelport> http://homepages.inf.ed.ac.uk/wadler/realworld/docon2.html
07:24:03 <Aruro> a b (c:: Int) means a b and c are type Int?
07:24:13 <dramforever> nope
07:24:25 <Aruro> what then?
07:24:29 <Aruro> only c?
07:24:29 <dramforever> Aruro: maybe you want this:
07:24:40 <dramforever> a b c = (a $ b) $ c
07:24:50 <dramforever> you can draw the AST
07:25:02 <dramforever> and see that c has nothing to do with the rest
07:25:05 <Aruro> scale 0.7 0.7 (0.7::GLfloat) - example
07:25:17 <dramforever> I need the type of scale
07:25:22 <Aruro> hm
07:26:03 <int-e> Aruro: if scale has type  a -> a -> a -> b, then fixing one of the argument types also fixes the others
07:26:17 <int-e> Aruro: that's what happens there.
07:26:55 <dramforever> int-e: well, maybe you mean "that is a instance of a -> a -> a -> b"
07:26:56 <int-e> > (1 + (1 :: Int), 1 + (1 :: Double), 1 + (1 :: Rational))
07:26:57 <Aruro> MatrixComponent c => c -> c -> c -> IO ()
07:26:58 <lambdabot>  (2,2.0,2 % 1)
07:27:03 <int-e> @type (+)
07:27:04 <lambdabot> Num a => a -> a -> a
07:27:18 <int-e> dramforever: yes, but that would distract from the point
07:27:18 <Aruro> yes int-e seems you are right
07:27:40 <Aruro> ty
07:27:41 <dramforever> Aruro and int-e, well they're working together to make the three 0.7's the same type
07:27:54 <Aruro> but this type of synax is not general?
07:28:04 <dramforever> Aruro: no
07:28:07 <Aruro> i really need to base it on a given function?
07:28:10 <Aruro> ok
07:28:11 <Aruro> ty
07:28:26 <dramforever> :t const 1 ('a' :: Char)
07:28:28 <lambdabot> Num a => a
07:28:40 <dramforever> Aruro, it makes 1 Char?
07:28:59 <int-e> @type const -- note that the argument types are independent
07:29:00 <lambdabot> a -> b -> a
07:29:24 <Aruro> so which argument types are dependent? how to see that?
07:29:27 <int-e> so 'b' becomes Char, but 'a' is still only limited by the type of '1', which is Num a => a.
07:29:48 <int-e> Aruro: MatrixComponent c => c -> c -> c -> IO () <-- the c is repeated and denotes the same type each time
07:29:54 <dramforever> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
07:29:55 <lambdabot> f a b = a (\ c _ -> b c) b
07:30:18 <Aruro> i see now it works on functions define through type variables?
07:30:23 <Aruro> defined
07:30:29 <dramforever> Aruro: no...
07:30:39 <dramforever> for example f a b c = blah
07:30:44 <int-e> Aruro: so when calling the function, all three arguments must have the same type, and fixing the type for one of them will be enough.  scale (0.7 :: GLfloat) 0.7 0.7  also works, btw.
07:30:51 <dramforever> f :: Int -> Int -> Int -> Double
07:30:58 <Aruro> then i dont get how he infers type
07:31:20 <Aruro> ok that is helpful
07:31:26 <dramforever> Hindler Mi...blah... thing?
07:31:33 <dramforever> Hindly?
07:31:33 <int-e> Milner, yes.
07:31:40 <int-e> Hindley Milner
07:31:41 <Aruro> so 0.7::GFloat is same as GFloat 0.7 ?
07:31:53 <dramforever> Aruro: NO!!!
07:31:56 <Cale> hehe Hindler Milney :D
07:32:12 <Aruro> why not? :) GFloat is not constructor?
07:32:21 <dramforever> 1. You mean GLFloat!
07:32:26 <Aruro> yes
07:32:29 <Aruro> typo
07:32:33 <dramforever> 2. I think it's not a constructor
07:32:48 <Aruro> but if is my point is correct?
07:32:52 <Kron> is there a word for the subset of a type that can be accessed with a set of functions and base values?
07:32:54 <Aruro> it*
07:33:22 <dramforever> iirc, type GLFloat = CFloat
07:34:07 <Cale> Yeah, GLfloat is a synonym for CFloat, which itself doesn't have exported data constructors, you're expected to use its instances of Num, Fractional, Floating, etc. to construct values of it.
07:34:13 <dramforever> http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
07:34:30 <Cale> oh
07:34:32 <dramforever> Aruro, you'd want to look at it a bit
07:34:54 <Cale> Actually, at present it seems there is an exported CFloat data constructor
07:35:03 <Cale> But... you probably shouldn't use it
07:35:11 <Philonous> It's just a newtype around Float anyway
07:35:22 <Cale> Yeah, presently.
07:36:14 <Cale> I'm not sure that'll ever change as far as GHC's concerned, but the whole point of those types is that perhaps your Haskell implementation's representation for Float isn't really equivalent to C's float type.
07:36:27 <Aruro> thank you for the nice link dramforever
07:36:49 <Philonous> Cale, Isn't that what storable is for?
07:36:55 <Philonous> Storable, even
07:37:13 <Cale> So exposing the newtype's data constructor kind of undermines that
07:37:46 <Cale> Philonous: Well, CFloat is meant to be a Haskell datatype which is capable of representing the same floating point values as C's float type.
07:38:42 <Cale> Philonous: It's conceivable that Float wouldn't be quite the right thing, so it makes room in the specification for that distinction.
07:39:10 <Cale> In GHC though, Float is fine.
07:39:21 <Cale> (which is why it's implemented as a newtype)
07:40:28 <te> Is there any place where I can find  the latest version of the complete BNF syntax of the Haskell grammar in one place? Something like this, but for Haskell: http://askra.de/software/ocaml-doc/3.12/full-grammar.html#anchor01
07:40:51 <gcganley> can you compile ghc HEAD with clang 3.5.0
07:41:23 <Cale> te: well, what do you mean by "Haskell" exactly? I believe the Haskell 2010 spec has a grammar in it, but it won't include many of the frequently used extensions in GHC.
07:41:50 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010
07:42:03 <nkar> the 'forM_' function operating on a value inside the 'Maybe' monad allows me to express 'if (Just v) then action'.  is there a similar function that mimics the 'else' clause (i.e., 'if (Just v) then action1 else action2')?
07:42:14 <stolaruk> Does anyone know what arguments to give "strip" to best strip a Haskell-compiled binary? Here (http://stackoverflow.com/questions/699908/making-small-haskell-executables) the following is recommended: "strip -p --strip-unneeded --remove-section=.comment -o hello-small hello", but this gives me a "unrecognized option: -p" error on Mac OS X 10.9.5. I read the strip man page but it's a bit over my head.
07:42:29 <Cale> nkar: 'maybe'?
07:42:31 <te> Cale: I know that Haskell 2010 report includes some grammar definitions, but they are in different pages, and don't know exactly what is needed or not. Also I found this which includes GHC extensions, but it is just a code not the text version of the grammar: https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y.pp
07:42:36 <Cale> hm
07:43:11 <nkar> Cale: in my example, actions are in the IO monad.
07:44:01 <Cale> nkar: I'd just write a case expression
07:44:17 <nkar> Cale: okay
07:45:13 <Aruro> is there function apply equal to :  apply f [x,s] = f x s  ?
07:45:23 <Cale> It's probably clearer than any other option I can think of. The maybe function will work, but it's usually less clear and harder to modify later.
07:46:08 <Cale> Aruro: Not a predefined one. Functions on lists which require the list to have a specific number of elements are somewhat dangerous.
07:46:34 <eikke> nkar: mplus came to mind, but what would a 'false' value (like Nothing) be for some IO a ?
07:46:44 <Aruro> ty
07:47:16 <Aruro> just wanted to story arguments in a list :)
07:47:21 <Aruro> store
07:47:37 <eikke> nkar: I think seeing `forM_` as `if (Just a) ...` is somewhat 'wrong', since it assumes some kind of boolean thing, whilst what `forM_` does is not related to any 'if'-like thing
07:49:18 <nkar> eikke: sorry for the sloppy example.  I mean something like when (isJust mv) $ do let v = fromJust mv ...
07:49:27 <nkar> meant*
07:50:26 <nkar> which is also not very pretty
07:50:31 <cmtptr> asInt' acc ("-":xs) = asInt' (-acc) xs  -- can I not do this?  Is there a way to pattern-match the first element of a list against a literal?
07:50:46 <vanila> asInt' acc ('-':xs)
07:51:23 <cmtptr> oh, I was wondering how you write Char literals.  I guess I thought since ' was valid for identifiers it wouldn't be use for literals.  thanks
07:52:30 <zwer> Aruro why not store them in a tuple instead?
07:53:00 <zwer> > uncurry map ((+1), [1..5])
07:53:02 <lambdabot>  [2,3,4,5,6]
07:55:59 <Philonous> In gtk2hs, is (TypedTreeModel a) not being an instance of TreeModelClass an oversight or is it intentional (and what then is the point if TypedTreeModel)
08:02:05 <Athas> When I do C-c C-l in Haskell-mode to load the file into GHCi, is there an easy way to navigate between the errors?
08:02:51 <dv-> M-n i think?
08:13:09 <dmj`> is it kosher to not camel case function arguments?
08:13:33 <dmj`> I have a record newtype CustomerId = CustomerId Text
08:13:47 <dmj`> er, newtype CustomerId = CustomerId { customerId :: Text }
08:13:58 <dmj`> f (CustomerId customerId) = ... ...
08:14:12 <dmj`> I get "Warning the parameter name shadows the existing record name"
08:14:26 <dmj`> so is customerid ok? Or do style guides everywhere condemn that
08:14:53 <tdammers> I'd use newtype CustomerId = CustomerId { unCustomerId :: Text }
08:15:08 <tdammers> that way the record field can double as a getter
08:15:18 <tdammers> (or unwrapper, or whatever you want to call it)
08:16:06 <tdammers> or just forgo record syntax altogether if you have no need for that
08:16:19 <tdammers> just newtype CustomerId = CustomerId Text
08:16:23 <Philonous> I'd use -XRecordWildCards
08:16:45 <Philonous> f CustomerId{..} = ...
08:17:13 <Philonous> Though that's even more confusing
08:17:42 <ThreeOfEight> Philonous: oh, nice. I wasn't aware of that extension.
08:18:00 <dmj`> yea, so this is the exact scenario, I have a data Customer { customerId :: CustomerId ... }, and then newtype CustomerId = CustomerId Text... so when operating on CustomerId's via f (CustomerId customerId) it clashses with the other record. So even if I did RWC CustomerId{..} it wouldn't be using customerId...
08:18:14 <Philonous> Actually, don't do that. It probably makes reading the code unessecarily hard
08:18:31 <dmj`> tdammers: that 'un' is just so ugly :/
08:18:44 <dmj`> tdammers: I guess if its convention I'll cave
08:18:51 <tdammers> dmj`: depends, but yeah, in this case I agree
08:19:02 <tdammers> dmj`: it's kind of common with monad transformers and such
08:19:10 <tdammers> no wait, that's the run___ convention
08:19:50 <dmj`> tdammers: so it's either leave the cabal warnings due to shadowing or f (CustomerId customerid)
08:19:58 <tdammers> but wait, I hadn't realized that your clash is between two different things
08:20:09 <dmj`> tdammers: yea :/
08:20:30 <tdammers> in that case, I would either not import customerId from Customer at all, or find a different identifier for the local var
08:20:45 <tdammers> idk, `cid` or sth like that
08:20:58 <tdammers> it's a local var, brevity is probably OK
08:21:16 <maybefbi> can an algorithm be inferred by another algorithm by looking at its side effects?
08:21:28 <gregnwosu> i have a state monad and i need too continually feed the state that comes out back in
08:21:51 <vanila> maybefbi, sometimes and it's difficult
08:22:12 <maybefbi> vanila, we can do it no?
08:22:24 <gregnwosu> but then i need to store the state dont i?
08:22:26 <vanila> maybefbi, not always
08:22:31 <gregnwosu> and that will make it mutable?!
08:23:24 <maybefbi> vanila, yeah you are right. can't figure out the sorting algorithm by comparing input and output
08:23:56 <maybefbi> vanila, will need more statistical studies to arrive at the time complexity
08:24:28 <vanila> maybefbi, for a sort algorithm you might be able to guess by comparing against a list of given sort algorithms
08:24:41 <vanila> if you're able to watch what compares it does you can probably profile it quite easily
08:25:27 <dmj`> tdammers: yea cid, thanks
08:25:34 <Fuuzetsu> is there a package that does static naturals ordering? i.e. I want Agda's n≥m (to some reasonable extent)
08:25:38 <maybefbi> vanila, hmm i was just wondering how we predict the future of processes like physical processes, UI behaviors, and beings with intentions
08:30:19 <vanila> what is hard about just doing
08:30:22 <vanila> import Data.Traversible
08:30:28 <vanila> or Traversable whatever
08:30:42 <vanila> there's literally no reason to force this on everyone
08:31:21 <vanila> ndm was totally right about doing all this in a different way
08:31:32 <vanila> http://neilmitchell.blogspot.it/2014/10/how-to-rewrite-prelude.html
08:31:40 <Ted_> hi - is anyone else doing CS194 from Penn?
08:31:58 <hexagoxel> can i specify -with-rtsopts="-N -H2G" in cabal without splitting it up into two -with-rtsopts's?
08:32:23 <pjdelport> Ted_: There are a number of folks in #haskell-beginners doing it.
08:32:30 <Kron> currently my cabal test says "1 of 1 test suites (1 of 1 test cases) passed." even though I have several tests in my file, how do I get it to enumerate my tests?
08:33:00 <Ted_> pjdelport - thanks, I'll head over there
08:33:39 <edwardk> vanila: we had a proposal about this a year and a half ago. we achieved 90% consensus in favor of the change, we had 100+ messages on the topic, we polled 112 people and also achieved overwhelming support
08:33:56 <edwardk> if the language cannot change in response to THAT much pressure, its dead, and we're all just standing around the corpse
08:33:56 <Kron> I'm for putting Traversable in Prelude
08:34:08 <Kron> I hate hiding Prelude bits and putting in better Foldable / Traversable bits
08:34:22 <vanila> edwardk, That I can get behind
08:34:35 <zipper> Can anyone help me with this issue compiling ghc-mod http://ix.io/eE3
08:34:52 <zipper> It claims there is an error in Browse.hs which I can't find.
08:35:45 <edwardk> the pressure from that chain of proposals and the threatened breakage to the community that would be caused if folks went off and did their own thing to "tear off the bandaids" as was initially proposed by wren, caused Simon to form the core libraries committee so that we'd have some entity capable of deciding between several alternatives for packages that are needed for the platform.
08:36:22 <edwardk> Heretofore without complete universal consent and a driven proposer, nothing would ever get through the proposal process.
08:36:49 <edwardk> Nobody felt they had the authority to judge the merit of each sides opinion and make a decision
08:37:32 <eikke> is it possible to make N-tuples instances of Traversable?
08:37:41 <edwardk> Kron: the thing I hate about it is they don't stay hidden. You can hide the ones from the Prelude and go work with Traversable, but then you import Control.Monad and the monomorphic ones are back messing with you.
08:37:53 <edwardk> eikke: they'd only traverse the last parameter if you think about it
08:38:06 <edwardk> > traverse (\x -> [x,x+1]) ("hello",2)
08:38:09 <lambdabot>  [("hello",2),("hello",3)]
08:38:09 <eikke> edwardk: yes, occurred to me right after hitting enter, damnit
08:38:16 <edwardk> on the other hand
08:38:27 <edwardk> > both (\x -> [x,x+1]) (1,5)
08:38:29 <lambdabot>  [(1,5),(1,6),(2,5),(2,6)]
08:38:34 <edwardk> lens gives you traversals for them
08:38:42 <edwardk> > each (\x -> [x,x+1]) (1,3,5,7)
08:38:44 <lambdabot>  [(1,3,5,7),(1,3,5,8),(1,3,6,7),(1,3,6,8),(1,4,5,7),(1,4,5,8),(1,4,6,7),(1,4,...
08:38:48 <vanila> lens is very cool, only place ive seen traversable though
08:39:08 <edwardk> vanila: which is a consequence of Data.Traversable being rather undiscoverable in its current location
08:39:20 <edwardk> We teach it as a best practice to use then we make it as god-awful to get at as we can
08:39:53 <vanila> what sort of things would traversable be used for on its own?
08:40:09 <vanila> I can only really see it in a lens context
08:40:22 <vanila> it feels like it belongs in lens to me/
08:40:23 <vanila> ?
08:40:52 <edwardk> Traversable is 6 years older than lens
08:40:54 <zipper> I am getting an error when compiling a package. The error is at http://ix.io/eE3 however when I look at the file Browse.hs I can't see the error in the file.
08:41:08 <edwardk> lens just threw it in everyone's face and taught them how to use it
08:41:56 <edwardk> removing the ability to walk through a container type with applicative or monadic effects and burying it in a package with so many dependencies would be a very very bad idea
08:42:05 <edwardk> on the other hand, it'd drive everyone to use lens, so maybe there is that... ;)
08:42:15 * hackagebot js-jquery 1.11.1 - Obtain minified jQuery code  http://hackage.haskell.org/package/js-jquery-1.11.1 (NeilMitchell)
08:45:08 <danharaj> edwardk: I think lens makes the abstraction vastly more convenient to use because . composes them.
08:45:17 <danharaj> how's the PR campaign going? ;)
08:45:22 <edwardk> danharaj: heh
08:45:56 <edwardk> i think its going pretty well, you can look at the upvotes all around and they are about 3:1 in favor of the noises the positive folks are making to the negative folks
08:46:34 <edwardk> It is nowhere near unanimity, but then nothing is
08:47:11 <danharaj> yup, I've been up voting my pov. I just hope you don't get burned out because your work is O(n) in the number of blog posts.
08:58:47 <castor3> Hi
08:59:03 <castor3> I'm running into an issue installing cabal-install with cabal on Debian
08:59:36 <castor3> My error is: https://dpaste.de/q62j
08:59:46 <castor3> (when running cabal install cabal-install)
09:00:34 <srhb> castor3: Start by getting the error (with more details) when trying to install Cabal-1.20.0.3
09:01:13 <dmj`> castor3: if all you want is the binary you can download it straight from here: http://www.haskell.org/cabal/release/cabal-install-1.20.0.3/cabal-1.20.0.3-i386-unknown-linux.tar.gz
09:01:17 <dmj`> wget it
09:01:23 <castor3> I'm on an ARM compute r:(
09:01:44 <castor3> I assume the binary is for x86 machines
09:01:54 <dmj`> I'd do what srhb recommended then
09:02:02 <RchrdB2> Yeah, that's what "-i386-" in the URL means. :)
09:02:04 <dmj`> castor3: yes, x86
09:02:16 <castor3> RchrdB2: didn't read the full URL :p
09:02:16 * hackagebot purescript 0.5.6.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.6.3 (PhilFreeman)
09:02:18 * hackagebot ert 0.0.1.1 - Easy Runtime Templates  http://hackage.haskell.org/package/ert-0.0.1.1 (kayo)
09:03:57 <castor3> I'm going to try it
09:04:37 <doismellburning> a/win 48
09:04:41 <doismellburning> ugh sorry
09:08:33 <augur> dr_: wtf are you doing
09:08:41 <augur> agh whoops
09:08:44 <augur> scrolled back :(
09:08:57 <augur> that wasnt meant for you dr_ ignore it
09:12:17 * hackagebot newsynth 0.2 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.2 (PeterSelinger)
09:13:31 <edwardk> danharaj: likewise =)
09:17:29 <zipper> edwardk: how big is the mtl package? It's taking forever to download
09:17:44 <zipper> Ha I almost put an @ in front of your nick.
09:17:45 <castor3> Here I am
09:17:48 <edwardk> zipper: its tiny
09:17:48 <castor3> With my log: https://dpaste.de/vEsp
09:17:56 <edwardk> zipper so you probably have something else wrong
09:18:04 <zipper> edwardk: Ok then I shall cancel and try again.
09:18:09 <castor3> (when trypin cabal install Cabal-1.20.0.2)
09:18:17 <castor3> typing*
09:18:27 <zipper> I am trying to install happy which depends mtl
09:18:31 <augur> @zipper: @i @put @@ @in @front @of @ever @word @to @balance @it @out
09:18:32 <lambdabot> Unknown command, try @list
09:19:00 <augur> @but @then @i @look @like @i'm @writing @objective-c
09:19:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:19:18 <zipper> edwardk: Seems it had downloaded but wasn't configuring and buildind. Very unusual. Looked for it's size on hackage and to my surprise you wrote it.
09:19:30 <zipper> edwardk: It's as if you wrote everything.
09:19:33 <zipper> LOL
09:19:37 <edwardk> i didn't write it, but i do maintain it =)
09:19:43 <zipper> augur: LOL
09:19:55 <zipper> edwardk: Oh I saw your name there so I assumed.
09:20:32 <ClaudiusMaximus> castor3: ExitFailure 9 makes me think it was OOM-killed, how much ram do you have? anything interesting at the end of dmesg?
09:20:45 <augur> anyone seen roconnor recently?
09:20:50 <Javran> hi, I'm wondering is there a common practice about code style, someone told me "it is customary to indent then and else always below the if" and I'm wondering if this is true?
09:21:00 <edwardk> Andy Gill wrote it, Ross Paterson maintained it for several years, then I took over.
09:21:02 <castor3> ClaudiusMaximus: 500 Mio, but my swap is activated
09:21:08 <castor3> (1 Gio swap)
09:21:20 <edwardk> augur: he asked some questions on reddit a few days ago, so he's still alive =)
09:23:06 <augur> edwardk: yeah, i spoke to him a few days ago but not since. we were talking about denotational semantics vs. proof theoretic methods, etc.
09:25:25 <castor3> ClaudiusMaximus: do you have an idea about how could I circumvent that problem?
09:26:28 <jfischoff> Where can I find the ISing instances for Symbol and Nat in GHC.TypeLits?
09:26:45 <jfischoff> They moved since 7.6.3
09:27:26 <hiptobecubic> jfischoff, *imvu* is using haskell?
09:27:33 <jfischoff> yes
09:27:52 <hiptobecubic> how fun
09:27:55 <jfischoff> yes
09:27:57 <jfischoff> :)
09:29:07 <hiptobecubic> do you guys have a tech blog?
09:29:20 <jfischoff> yeah but it’s not updated much
09:29:30 <jfischoff> I’m suppose to write articles ….
09:29:36 <jfischoff> uh started
09:30:15 <hiptobecubic> oh there's something there though. it's not empty. http://engineering.imvu.com/2014/09/24/how-imvu-builds-web-services-part-2/
09:30:42 <jfischoff> oh that’s cool
09:31:17 <jfischoff> actually getting types to enforce that standard, um, almost there
09:37:09 <gcganley> :t (>>>)
09:37:11 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
09:37:18 <gcganley> :t (<<<)
09:37:19 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
09:39:37 <jfischoff> So can type level Symbol’s get demoted to Strings anymore?
09:39:42 <jfischoff> Symbols
09:45:56 <bmuk> Hey everyone, I'm trying to install cabal on my vps, but I have a limited amount of memory (512 MB). ./bootstrap.sh fails just saying it killed the setup process, which I am assuming is due to a lack of memory.
09:47:07 <gcganley> bmuj: is cross compilation an option?
09:47:28 <gcganley> bmuj: woops thought you were compiling
09:47:36 <bmuk> I know I can download a binary, but I am unable to execute the binary because it is 32-bit and I am on an x64 system. I am unsure how to install all of the necessary libs on fedora all at once (I realize this is a fedora problem, but maybe you guys know)
09:48:03 <bmuk> gcganley: I am - and I already have it built locally. Maybe I could just scp it to the server?
09:48:32 <gcganley> bmuk: is cabal 32 and libraries are 64bit or vis versa?
09:49:07 <gcganley> bmuk: i normally just scp it
09:49:33 <bmuk> gcganley: Yes. My ghc is 64 bit and the entire system is 64bit. I didn't have to resort to downloading the binary on my laptop (also Fedora 20) so I'm not sure if I'm doing something wrong or not.
09:49:51 <bmuk> gcganley: just ~/.cabal/bin/cabal? I'll try it
09:50:22 <albeit> Using attoparsec (other other combinatorial parsers), how can I do action A, but if action A fails, do action B?
09:50:43 <funrep> albeit: <|>
09:50:46 <monochrom> A <|> B
09:50:51 <albeit> Thanks
09:50:54 <funrep> use the Alternative instance
09:51:11 <funrep> beware though, attoparsec provides some edge cases regarding this iirc
09:51:15 <funrep> (for performance)
09:51:46 <hughfdjackson> on the subject of parsing (he says, attempting to hijack the convo somewhere :p)
09:52:18 <hughfdjackson> i'm struggling to define a 'parse alphanumeric unless the word is reserved' combinator
09:52:49 <hughfdjackson> i was essentially thinking i'd look ahead, and then `flip` the result ..
09:53:00 <hughfdjackson> i.e. stop parsing if you see this when you look ahead
09:53:15 <gcganley> bmuk: so cabal isnt working but ghc is?
09:53:22 <hughfdjackson> can't find any combinator to flip a parsec parser like that though
09:53:45 <bmuk> gcganley: I scped it, and it is indeed a 64 bit ELF, the executable bit is set, and .cabal/bin is on my path, but I am still getting cabal not found
09:54:31 <bmuk> gcganley: Yes, I installed ghc from a third party repo since Fedora 20 ships with 7.6 and haskell platform 2014 doesn't work on Fedora 20
09:54:32 <gcganley> bmuk: try the fully qualified path to cabal
09:55:01 <gcganley> bmuk: im a arch linux guy so im just thinking on the fly
09:55:08 <gcganley> s/a/an
09:55:30 <bmuk> gcganley: hm. That works. but I don't understand why, since it is on my path, and which cabal gives me the correct location
09:55:57 <tremon> bmuk: and running .cabal/bin/cabal manually gives no error?
09:56:25 <srhb> hughfdjackson: Maybe I'm not understanding, why is lookahead not enough?
09:56:45 <hughfdjackson> srhb: lookahead will succeed, as i understand it, if the token is present
09:56:52 <bmuk> tremon: Yes, but I think I fixed it. Dumb mistake - I changed the path in config.fish but didn't source it T_T
09:57:23 <hughfdjackson> `lookAhead parseKeyword >> parseIdentifier` <- if it finds a keyword, then it'll carry on and parse the identifier
09:57:35 <hughfdjackson> which is the opposite of what i wanna happen - i'd like to bail at that point
09:57:51 <srhb> hughfdjackson: Oh, okay. So you want a "not" parser.
09:58:01 <hughfdjackson> srhb: yup :)
09:58:12 <bmuk> running cabal update on the vps is another matter entirely :(
10:00:33 <gcganley> bmuk: awkward
10:00:52 <bmuk> gcganley: It keeps running out of memory. Is there a flag or something/
10:00:57 <gcganley> bmuk: i still dont get why cabal update takes forever
10:01:08 <gcganley> bmuk: cabal update does?
10:01:25 <bmuk> gcganley: yeah.
10:01:46 <gcganley> do you have a system monitor setup to watch the memory jump?
10:01:54 <srhb> hughfdjackson: Sounds like some combination of option parseIdentifier (lookahead parseKeyword) might be what you want
10:02:07 <srhb> hughfdjackson: So if parseKeyword fails, we get parseIdentifier
10:02:17 <gcganley> bmuk: do you have a system monitor setup to watch the memory jump?
10:02:25 <bmuk> Only what digital ocean provides. Is there a command line program? maybe spamming free?
10:02:41 <gcganley> top
10:02:44 <gcganley>  i htink
10:02:59 <gcganley> :bmuk watch free
10:02:59 <bmuk> ah duh, let me run it while watching top
10:03:17 <hughfdjackson> srhb: my issue right now is that my identifier expression parser is recognising `then` in an `if <expr> then <expr> else <expr>`
10:03:21 <gcganley> :bmuk you could always run `watch free
10:04:05 <hughfdjackson> :) I'm sure i could refactor to go for that approach, but it would be more convenient with my current structure (where my ifTheElse parser is separate from the my identifier parser) to short-circuit
10:04:09 <hughfdjackson> i'll give it some more thought ^_^ cheers
10:04:40 <bmuk> gcganley: from htop it looks as expected - cabal update consumes more and more CPU and RAM until the OS kills it
10:06:20 <gcganley> bmuk: do you have a swap partition?
10:07:00 <bmuk> gcganley: I didn't set one up, so I'm guessing not.
10:07:28 <bmuk> gcganley: with my host I just select a distro and they spin it up; maybe I can make a swapfile
10:09:20 <gcganley> bmuk: thats my guess, if it had a swap file would it still kill the process
10:09:59 <merijn> bmuk: Why bother building on a VPS instead of just copying over a compiled binary?
10:10:28 <gcganley> merijn: yes he did
10:10:39 <gcganley> merijn: if i remember him saying that correctly
10:10:58 <bmuk> merijn: I did - I am now trying to cabal update
10:11:07 <merijn> Why?
10:11:50 <bmuk> merijn: Maybe I am going about this the wrong way, but wouldn't it be a pain to have to copy over every binary I need?
10:12:40 <merijn> bmuk: How many binaries do you need?
10:13:12 <merijn> Haskell links all haskell libraries statically, so once you compile your program you only need to ensure the relevant C libraries are on your VPS
10:14:32 <bmuk> merijn: well right now I am not deploying anything, just trying to use this server as my irc connection. Now that I'm typing this, I realize this is stupid, but I use emacs and my configuration includes ghc-mod and shm. I was thinking it'd be easier to just mirror everything than write the necessary elisp to disable these on just one host.
10:14:43 <bmuk> That may have been a leap though, as I am seeing now
10:16:11 <merijn> bmuk: My recommendation: Put your emacs config (and other dot files in version control), that way you can quickly hack out the broken elisp from your config on the VPS and once you're motivated you can then write some stuff to selectively disable it and merge back to your "real config"
10:16:28 <merijn> It's how I iteratively patch up and improve my configs :)
10:17:11 <bmuk> merijn: they already are on github, and now that you mention this the solution seems obvious :p
10:18:50 <ReinH> Running haskell binaries is quite nice, although it can be a pain on some systems (busybox) to build the required C libs
10:18:55 <wz1000> Does 'now' as defined in http://hackage.haskell.org/package/acme-now-1.0.0.1/docs/src/Acme-Time-Now.html#now always return the time it was first evaluated on?
10:19:43 <ReinH> The only annoying thing is that the binaries can get quite large
10:20:23 <merijn> bmuk: Yes, no, maybe, it depends
10:20:33 <merijn> ReinH: Disk space is cheap :p
10:20:40 <MindIsAVortex> hi there, student here. I have to make a data type called Set and then make it an instance of Eq class. However ghci doesn't want to compile it. It tells me that `Eq` is applied to too many arguments. I'm not sure how could do with any less. Could somebody take a look for me? https://gist.github.com/MindIsAVortex/61b222110e075f806487
10:20:43 <RchrdB2> wz1000: it's not guaranteed to return any particular value.
10:21:02 <ReinH> merijn: bandwidth isn't always :p
10:21:53 <wz1000> RchrdB2: How is it supposed to behave given the GHC definition of unsafePerformIO?
10:21:58 <ReinH> MindIsAVortex: Eq a => [a] is already an instance of Eq
10:22:00 <RchrdB2> wz1000: it'll probably always return the time that it was first evaluated, but it's possible (but unlikely) for 2 different Haskell threads to read different values for it because there's a race condition when evaluating thunks.
10:22:54 <ReinH> @MindIsAVortex ah, you want different behavior.
10:22:55 <lambdabot> Unknown command, try @list
10:22:59 <ReinH> woops sorry
10:23:44 <MindIsAVortex> @ReinH: Yeah, basically it has to follow the behavior of a set, where order and repetition of values do not matter
10:23:44 <lambdabot> Unknown command, try @list
10:23:59 <ReinH> Yep.
10:24:26 <hughfdjackson> srhb: for the record, here's how i solved it
10:24:33 <ReinH> :t (&&)
10:24:34 <lambdabot> Bool -> Bool -> Bool
10:24:38 <joseph07> MindIsAVortex: I think you just needs some parens
10:24:58 <joseph07> MindIsAVortex: instance Eq a => Eq (Set a) where
10:25:55 <wz1000> Does GHC perform any automatic memoization?
10:25:56 <ReinH> oh duh
10:25:59 <jfischoff> wz1000: if it gets inlined you will get different values
10:26:04 <lpaste> hughfdjackson pasted “fail-on-reserved-word.hs” at http://lpaste.net/112178
10:26:14 <hughfdjackson> srhb: ^ :)
10:26:17 <jfischoff> wz1000: No it does not perform memoization
10:26:18 <gcganley> wz1000: no
10:26:37 <jfischoff> wz1000: My inline response was in regard to the behavior of now
10:27:06 <gcganley> enx
10:27:10 <gcganley> show ip route
10:27:18 <gcganley> sorry
10:27:22 <gcganley> wrong window
10:27:37 <MindIsAVortex> @joseph07: hmm, that got rid of this particular error. On to the next apparently :D Thanks
10:27:37 <lambdabot> Unknown command, try @list
10:27:45 <joseph07> MindIsAVortex: Good luck!
10:27:49 <wz1000> jfischoff: Wouldn't it be a useful optimization in some cases(the memoization that is), made possible due to referential transparency
10:28:15 <jfischoff> wz1000: yes
10:28:19 <srhb> hughfdjackson: OK. :)
10:28:33 <gcganley> wz1000: sometimes but it would bloat the stack, i belive they talked abuot it on a haskell cast on concurency
10:29:02 <gcganley> wz1000: they said its hard to justify having memoization EVERYWHERE
10:29:17 <jfischoff> wz1000: haskell runttimes could implement memiozation if they choose to
10:30:09 <ReinH> gcganley: We might have talked about it. I forget. :)
10:30:23 <ReinH> But yeah, memoization is not always the right thing to do
10:30:46 <wz1000> gcganley: how would it bloat the stack? Wouldn't it just amount to converting '... f x ... f x ...' into 'let a = f x in ... a ... a ...'?
10:30:46 <gcganley> ReinH: you're from the haskell cast...
10:30:51 <ReinH> gcganley: yep
10:31:05 <gcganley> ReinH: oh... this is a cool moment
10:31:28 <gcganley> ReinH: dude i binged on it and watched all of the episodes in one go
10:31:45 <ReinH> gcganley: :D
10:32:00 <wz1000> ReinH: When is it not the right thing to do?
10:32:10 <gcganley> ReinH: any plans on the next episode?
10:32:19 <ReinH> wz1000: memoization trades time for space. Sometimes you don't want to trade time for space.
10:32:27 <wz1000> Ah
10:32:53 <wz1000> Couldn't you make it optional?
10:32:53 <merijn> wz1000: It's pretty easy to make a function memoising
10:33:11 <ReinH> wz1000: We have guests planned but nothing scheduled. It's been an unusually busy couple of months for us hosts, but we're not done yet :)
10:33:11 <merijn> wz1000: The "Fun with Type Functions" paper illustrates a neat way
10:33:32 <merijn> And I believe Conal has a library for making functions memoising
10:33:45 <ReinH> wz1000: yes, it is optional: you can add it yourself whenever you want ;)
10:33:57 <ReinH> merijn: so does edwardk, ofc ;)
10:34:30 <ReinH> @hackage data-memocombinators
10:34:30 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
10:34:33 <ReinH> Is also nice
10:35:36 <wz1000> ReinH: I mean writing code like {-# MEMOIZE #-} followed by a naive fibbionacci defination
10:36:02 <ReinH> wz1000: but it doesn't need to be a language feature :)
10:36:38 <ReinH> fib = Memo.integral slowFib
10:37:30 <wz1000> ReinH: there are already so many extensions to the language, why not this? I don't think it would be too technically difficult to add :P
10:37:50 <ReinH> wz1000: "Why not?" is not the guiding principle of Haskell language design
10:41:57 <wz1000> ReinH: You could have some sort of smart memoization if it becomes a language feature. Only memoize the function if it is explicitly called with the same argument, with no runtime overhead of a hash table to maintain results.
10:42:18 <ReinH> At least now you're presenting positive arguments ;)
10:42:46 <gcganley> ReinH: would the hash table be passed like how typeclass vtables are passed?
10:42:55 <ReinH> gcganley: don't ask me :p
10:43:12 <gcganley> ReinH: well they could travel as pairs or extra arguments
10:43:26 <gcganley> ReinH: im just thinking how they could be implemented
10:47:06 <trap_exit> in haste, how do I get stack frames on errors ?
10:47:21 * hackagebot aur 2.0.2 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-2.0.2 (fosskers)
10:49:38 <ploppy_> @djinn a -> b -> b
10:49:38 <lambdabot> f _ a = a
10:50:54 <edwardk> artyomkazak: the lens article is pretty good
10:57:21 * hackagebot loop-effin 0.1.0.1 - control-monad-loop port for effin  http://hackage.haskell.org/package/loop-effin-0.1.0.1 (HiromiIshii)
11:00:19 <wz1000> How does GHC inline pointless functions?
11:01:08 <mauke> the same way it inlines everything else, presumably?
11:03:51 <wz1000> mauke: I meant with respect to currying. Are pointless functions inlined even when suplied with no arguments?
11:04:21 <mauke> dunno, try it?
11:14:04 <Javran> has the problem indicated by "ListT done right" fixed in transformer lib?
11:15:04 <Cale> Javran: If I had to guess, I'd guess no.
11:15:10 <Cale> Javran: I can look
11:16:05 <Cale> Yeah, doesn't look like it
11:16:10 <trap_exit> in a tree, what is a good name for a non-LEAF node ? (I can't use 'inner' as it's already taken)
11:16:17 <trap_exit> internal ?
11:16:25 <Cale> Branch?
11:16:33 <Javran> Cale: I see, thanks!
11:16:56 <Cale> Javran: The logict package includes a nondeterminism transformer which is an honest monad transformer
11:17:26 <Cale> Javran: But usually you actually want to do things the other way around, transforming the list monad or some other nondet monad.
11:20:38 <Javran> Cale: I'm planning to play with probablistic parsing, so I guess ListT State might be my choice.
11:23:14 <vanila> I think ListT is broken
11:23:17 <Javran> Cale: I heard there are usually some troubles with tranformers who has more than one constructor e.g. MaybeT / ListT is that true?
11:23:18 <vanila> you should use LogicT instead
11:23:43 <monochrom> well, LogicT certainly gives you more choices
11:24:31 <Javran> thank you all, I'll absolutely look into it. :)
11:25:14 <vanila> if logict is intimidating look for "listt done right" whch is a version without tthe bugs listt has
11:27:15 <Javran> vanila: yeah I knew there is one in pipes lib
11:27:17 <cmtptr> is there any reason why I should ever write String instead of [Char]?  I kind of don't like that there are two ways of writing the same type
11:27:28 <mauke> three ways
11:27:30 <mauke> [] Char
11:27:44 <monochrom> no reason one way or another. go with your heart.
11:28:12 <cmtptr> what's standard practice?  I notice ghci seems to prefer [Char] when I use :type
11:28:16 <vanila> cmtptr, you could write String when you think of the thing as a string
11:28:17 <monochrom> IMO there is also no reason to worry about multiple ways.
11:28:29 <vanila> and [Char] when you're considering it as a list of characters
11:28:38 <monochrom> ghci just does things mechanically. most humans I see write String.
11:28:46 <numberten> and [] Char when wanting to be confusing :)
11:28:56 <mauke> ([])Char
11:29:02 <Cale> cmtptr: ghci ought to prefer however you happened to write the type if you gave the definition a signature
11:29:03 <vanila> numberten, it's sometimes nice when you want to express that you're thinking about things list-monadically
11:29:13 <vanila> [] a
11:29:16 <vanila> not just Charr
11:29:20 <numberten> yeah
11:29:32 <mauke> any inferred type is likely to be [Char] because type synonyms get resolved very early
11:29:34 <numberten> infix notation is pretty weird for a type constructor
11:29:35 <Cale> If you didn't, it will just infer [Char], and not bother to fold up the synonym
11:30:02 <mauke> Peyton `Simon` Jones
11:30:09 <numberten> haha
11:30:11 <Cale> ghci> let f :: String -> String; f = reverse
11:30:11 <Cale> ghci> :t f "Hello"
11:30:11 <Cale> f "Hello" :: String
11:30:51 <cmtptr> ah
11:30:57 <cmtptr> thanks
11:42:23 * hackagebot ghcid 0.2 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.2 (NeilMitchell)
11:54:08 <castor3> I have another problem compiling cabal-install with cabal
11:54:28 <castor3> https://dpaste.de/u6Zk here it is
11:54:40 <castor3> when I do cabal install cabal-install
11:56:01 <Cale> castor3: That's certainly interesting
11:56:55 <castor3> I'm using an old cabal version which is cabal-install version 0.14.0
11:56:57 <yukko> does anyone in here use/know much about gtk2hs?
11:56:57 <castor3> using version 1.14.0 of the Cabal library
11:57:24 * hackagebot hoogle-index 0.2.2 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.2.2 (BenGamari)
11:57:32 <Cale> castor3: You might try just grabbing the tarball from hackage and running the bootstrap.sh script from it
11:57:35 <castor3> So I can't sandbox as they say here: https://stackoverflow.com/questions/24847576/multiple-definitions-of-getnumberofprocessors-stop-linkage-with-cabal-install
11:57:58 <castor3> Cale: Ok, I'll try it
11:58:02 <Cale> yukko: I've used it, but mostly a long time ago. I might be able to help a bit.
11:58:19 <monochrom> castor3: you may consider doing your own sandboxing by hand: http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
11:58:38 <yukko> I can't figure out how to insert a row in a TreeView
11:58:54 <castor3> monochrom: Ok. Should I remove all my .ghc stuff as they say in the link I've given?
11:58:56 <yukko> with the ListView model
11:59:09 <stulli> Heffalump: thanks, that worked just fine!
11:59:22 <yukko> er ListStore
11:59:32 <monochrom> I don't know yet. but there is a way to say: ignore .ghc today. see what I wrote in that article.
12:00:04 <monochrom> there are a lot of personal value-judgement decisions I cannot make for you.
12:00:39 <Cale> yukko: So you have some ListStore a?
12:00:50 <Cale> listStoreInsert :: ListStore a -> Int -> a -> IO ()
12:00:58 <Cale> Insert an element in front of the given element. The element is appended if the index is greater or equal to the size of the list.
12:01:24 <castor3> monochrom: :D I'll try it then. Thanks :)
12:01:26 <Cale> note there's also listStoreAppend and listStorePrepend
12:01:37 <yukko> if both of my columns use the same model, then inserting into the ListStore just adds the same data to both columns
12:03:04 <yukko> http://lpaste.net/112183 this is my code
12:07:32 <MagBo> DateTime is a go-to type to represent time, right?
12:08:08 <yitz> MagBo: the standard is the time package. UTCTime
12:08:09 <Cale> yukko: You're setting the cell text to be the same thing in each case...
12:08:59 <Cale> MagBo: http://hackage.haskell.org/package/time
12:09:48 <MagBo> <3
12:10:46 <yukko> oh!
12:10:52 <yukko> Cale I figured it out, thanks!
12:10:58 <Cale> yukko: cool :)
12:12:18 <Cale> yukko: Yeah, if your ListStore holds a bunch of pairs, for instance, you might want to set the cellText to be the fst and snd of those pairs.
12:12:26 <Cale> (respectively)
12:12:37 <ahmedalsudani> Hey guys, I'm new to Haskell, and I'm running into code that contains "<>". Is that an operator?
12:12:51 <mauke> yes
12:13:02 <Cale> ahmedalsudani: Yeah, any sequence of symbol characters can be defined as an infix operator
12:13:10 <mauke> it's also known as mappend, your magical friend from Monoid City
12:13:23 <monochrom> <> is most likely from Data.Monoid
12:13:25 <Cale> ahmedalsudani: That one in particular is *probably* the one from Data.Monoid
12:13:29 <ahmedalsudani> mauke: perfect, that's something google can find!
12:13:35 <mauke> try hoogle
12:13:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
12:13:49 <mauke> http://www.haskell.org/hoogle/?hoogle=mappend
12:13:55 <mauke> funnily enough hoogle doesn't know about that <>
12:13:59 <ahmedalsudani> Thanks guys, I'll look and see if it helps
12:14:07 <ahmedalsudani> mauke: yeah, search engines suck at looking for symbols
12:14:10 <Cale> Well, <> actually being in the libraries is a bit new
12:14:15 <mauke> ahmedalsudani: hoogle doesn't
12:14:26 <triliyn> How do I generate a local hoogle database from a cabal project?
12:14:29 <mauke> http://hayoo.fh-wedel.de/?query=%3C%3E
12:15:27 <monochrom> triliyn: if you have hoogle executable, it's at haddock time "cabal haddock --hoogle <other options>"
12:16:01 <yukko> Cale that's exactly what I did!
12:16:14 <triliyn> Okay
12:16:52 <bmuk> Is anyone else having trouble building pandoc? I'm failing on Shared.hs, not in scope toChunks
12:17:26 <jle`> maybe check to see what library toChunks is from
12:17:49 <triliyn> Hoogle seems to require an outdated library. Will I be able to install it into a sandbox and just copy the executable into my path?
12:18:12 <monochrom> yes
12:18:29 <bmuk> looks like bytestring and text
12:19:19 <ahmedalsudani> mauke: thanks, I know where to look next time
12:20:11 <schell> are there any pandoc extensions to enable reading from pdf?
12:20:20 <bmuk> jle`: I do see this (https://github.com/jaspervdj/hakyll/issues/302) as a work around, but I'm just curious to see if it's a problem with pandoc for everyone right now or just the version of pandoc hakyll uses
12:21:04 <jle`> if it's from bytestring/text, then it might be that you have a mismatch w/ ghc?
12:21:07 <jle`> hm
12:22:09 <cschneid> do I understand Option out of semigroup package, its monoid instance merges Just values, and ignores Nothings?  (just "a" <> nothing <> just "b") => Option's instance gives "ab" instead of Maybe's which is Nothing.
12:22:50 <mauke> > Just "a" <> Nothing <> Just "b"
12:22:51 <lambdabot>  Just "ab"
12:23:05 <a3gis_> :t (<>)
12:23:06 <lambdabot> Monoid m => m -> m -> m
12:23:06 <wz1000> Whats the compiler option to make it crib about everything under the sun?
12:23:19 <adnam_> wz1000: -Wall ?
12:23:28 <wz1000> Yes, thanks
12:23:54 <adnam_> or -Werror if you want even more crib
12:24:07 <a3gis_> What is the <> function?
12:24:13 <a3gis_> :i (<>)
12:24:27 <Ankhers> mappend
12:24:29 <mauke> scroll up
12:25:20 <cschneid> mauke: ok, you're right - what's the Option instance doing differently. The docs say "different monoid instance" without actually saying what it is
12:25:33 <S11001001> cschneid: Yeah, like Monoid a => Monoid (Maybe a) but for Semigroup
12:26:14 <cschneid> ohh, I see - behaves the same, but has the Semigroup superclass
12:26:28 <cschneid> err, a looser restriction on the inner value.
12:26:31 <a3gis_> > "hello" <> "world"
12:26:33 <lambdabot>  "helloworld"
12:26:45 <josephle> Semigroup is just Monoid without mempty
12:27:04 <triliyn> Is the generated database stored in the invocation directory or in a directory that Hoogle automatically searches?
12:27:47 <cschneid> right. So the type is the only difference between Maybe and Option monoid instances, being more accurate on what's required (that the inner value is Semigroup vs. a full Monoid).
12:29:03 <josephle> cschneid: that seems correct to me
12:29:13 <cschneid> ok. The docs are such a tease there :)
12:29:25 <cschneid> josephle: I'll have to go update the docs to describe the situation.
12:30:56 <josephle> a quick search of the scalaz docs confirms it. You only need the Semigroup constraint on the inner type
12:32:25 * hackagebot tostring 0.2.1 - The ToString class  http://hackage.haskell.org/package/tostring-0.2.1 (AdamBergmark)
12:40:47 <zzach> When trying to build the documentation for hat-2.7.0.12 using
12:40:47 <zzach> "./Setup haddock --html --hyperlink-source --hoogle" , it terminates with error message "haddock: failed to parse haddock prologue from file: dist/doc/html/hat/haddock-prolog29037.txt" while processing Array.hs . Is it possible to continue haddock or to skip Array.hs and generate the documentation just for the other files?
12:43:48 <wz1000> Ok, -fwarn-unused-imports is not working, and -
12:44:00 <wz1000> Wall is also not working
12:44:54 <monochrom> that is strange. perhaps you really have perfect code? :)
12:45:33 <tromp> ugh...
12:45:38 <wz1000> monochrom: Believe me, that is impossible.
12:45:47 <tromp> ignore:(
12:46:02 <wz1000> I have some 50 layouts in my xmonad.hs that I don't use.
12:46:19 <wz1000> I want to get rid of them all
12:47:01 <wz1000> Now I'll be reduced to removing one at a time until something breaks
12:48:10 <monochrom> there is -ddump-minimal-imports. it will output to a file. the filename has the substring "import", I forgot the exact full filename. but it has a bug, and I know a workaround.
12:48:39 <monochrom> the bug: it may wrongly attribute Prelude stuff to the first module you import. workaround: add "import Prelude" somewhere
12:51:12 <wz1000> monochrom: Thanks, that was amazingly usefull
12:51:31 <monochrom> :)
12:52:26 * hackagebot haddocset 0.2.0 - Generate docset of Dash by Haddock haskell documentation tool  http://hackage.haskell.org/package/haddocset-0.2.0 (HirotomoMoriwaki)
12:53:41 <Zer000> how long till I'm good at Haskell? It probably took me 10 years to be ok in Python...
12:53:55 <joelteon> don't worry, haskell is much easier to use
12:54:18 <dmj`> Zer000: do it everyday
12:54:25 <Zer000> 'erryday
12:54:31 <Zer000> i have to go
12:55:19 <monochrom> that is strange. I thought every Python user brag about "took me only 10 hours"
12:55:50 <Aruro> lol good in haskell
12:55:55 <Aruro> better be good in thinking
12:56:03 <identity> Anyone feel like taking a look at my ord instance definition to see what's wrong? https://gist.github.com/6cb40851918578c406e8 something is obviously wrong with it(I'm going to guess my logic in (<)) since sort does nothing to my test data.
12:56:15 <Aruro> than you can write haskell  on BASIC
12:57:34 <Aruro> you know how to determine that some one is haskell afficionado? if he uses phrase - syntax sugar :)
12:58:26 <monochrom> @type maybe
12:58:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:59:23 <Jeanne-Kamikaze> sbrg, are you missing some equalities ?
13:00:02 <monochrom> sbrg: do you mind testing this? map major (sort [ SemanticVersion{major=2}, SemanticVersion{major=1} ])
13:00:05 <Jeanne-Kamikaze> your < says that 4.3.2 < 3.12312313213.2
13:00:22 <monochrom> oh! I see what's wrong now, sbrg.
13:00:23 <Jeanne-Kamikaze> that, or I am being stupid, which is very likely as we approach midnight
13:00:45 <sbrg> Jeanne-Kamikaze: for semantic versioning it is, as I've understood it.
13:00:49 <sbrg> monochrom: oh'
13:01:01 <solarus> yeah both 4.3 < 3.1 and 3.1 < 4.3 is true
13:01:03 <monochrom> SemanticVersion{major=2, minor=0} < Semantic{major=1, minor=100} will be true because of "or"
13:01:22 <Jeanne-Kamikaze> you have to test == for major before testing minor, and so on, I think
13:01:28 <monochrom> yes
13:01:52 <monochrom> it is not going to look elegant :)
13:01:57 <sbrg> oh.. great.
13:02:28 <monochrom> x<y || x==y && (f<g || f==g && ...
13:02:57 <monochrom> there may be a way to refactor that.
13:04:00 <solarus> isn't it possible to do something like (<) = mconcat (zipWith compare [major a, ...] [major b, ...])
13:04:21 <Aruro> im sad :( u can not PM lambdabot
13:04:29 <solarus> > compare Nothing (Just "foo")
13:04:31 <lambdabot>  LT
13:05:30 <solarus> sbrg: ^^
13:05:31 <sbrg> Well, I want to ignore the metadata, but in the case of your example above, solarus, I want the opposite behavior.
13:05:47 <sbrg> that is, compare Nothing (Just "somelabel") = GT
13:06:10 <solarus> ok
13:06:59 <solarus> then in the lists you could do `zipWith compare [major a, ..., label b, ...] [major b, ..., label a, ...]' :)
13:07:37 <monochrom> haha
13:07:57 <solarus> or have a custom Maybe type with inverted Ord behaviour then you can just derive Ord
13:07:58 <monochrom> > mconcat [LT, EQ, GT]
13:07:59 <lambdabot>  LT
13:08:10 <monochrom> > mconcat [EQ, EQ, GT]
13:08:12 <lambdabot>  GT
13:08:16 <monochrom> nice
13:08:23 <solarus> deriving SemanticVersion that is
13:08:37 <benmachine> > mconcat [comparing length, compare] "hello" "abc"
13:08:39 <lambdabot>  GT
13:08:39 <solarus> s/deriving/deriving Ord for/
13:08:42 <benmachine> > mconcat [comparing length, compare] "hello" "abcde"
13:08:43 <lambdabot>  GT
13:08:49 <benmachine> > mconcat [comparing length, compare] "hello" "abcdef"
13:08:52 <lambdabot>  LT
13:09:04 <monochrom> mconcat (zipWith compare [major a, ..., maybe 0 (const 1) (label a)] [major b, ..., maybe 0 (const 1) (label b)])
13:10:48 <monochrom> alternatively, mconcat [major a `compare` major b, ...]. basically, we're just replacing < by compare, "or" by mconcat.
13:11:33 <benmachine> mconcat [comparing major, comparing minor, comparing patch, comparing (maybe 0 . const 1 . label)]
13:11:44 <monochrom> solarus: thank you for the mconcat idea. it's perfectly the refactoring I wanted.
13:12:09 <monochrom> ah that's neat too, benmachine.
13:12:23 <Vetii> ...Hi?
13:12:24 <benmachine> Cale taught me that trick
13:12:26 <benmachine> it is the best trick
13:12:35 <benmachine> well, he taught it to lots of people, but I was listening
13:12:35 <sbrg> Huh. I was thinking that there should be some way of 'aggregating
13:12:40 <hpc> i use that all the time in perl
13:12:42 <solarus> yeah thats even nicer
13:12:46 <sbrg> ' Ordering, or whatever you call it, but I wasn't sure where it fit.
13:12:46 <hpc> mconcat is (<=>)
13:13:02 <hpc> (and compare is also (<=>)
13:13:03 <hpc> )
13:13:18 <sbrg> Thanks guys -- that's beautiful
13:13:31 <hpc> er, mconcat = (||)
13:14:02 <benmachine> you can also just say compare = comparing f where f x = (major x, minor x, patch x, maybe 0 (const 1) x)
13:14:57 <benmachine> which is perhaps less "magic"
13:19:23 <gcganley> Is there any study showing what OS people using haskell
13:19:49 <gcganley> Is there any stuf
13:20:11 <guy2> No, there is no stuf
13:21:42 <gcganley> Sorry my iPad just went all wonky, what I meant to say was this
13:22:14 <gcganley> is there any study showing what OS/Distro people are programming haskell on
13:22:29 <merijn> Linux, OSX, Window and the other common OSes? :p
13:23:09 <gcganley> merijn: well yes but I'm talking about percentages and hard numbers
13:23:14 <Yxven> the most people are using linux
13:23:19 <joseanpg> hi
13:23:22 <Yxven> * I think
13:23:55 <gcganley> Yxven: it seems like a lot of people are also using OS X
13:24:21 <MagBo> By the way, under "do", "x <- M a; M (f x)" is "M a >>= (\x -> M (f x))", right? If so, why do we have to specify "M" in "M (f x)" when we know from ">>=" signature that it has to be "(a -> M b)"?
13:25:51 <dmj`> is there a tool to see how many packages certain packages have in common with each other
13:26:00 <dmj`> ?
13:26:03 <dmj`> *
13:26:48 <Vetii> Hi, I am very new to both IRC and #haskell, (so I don't really know the etiquette here) but I was wondering if some people here already used the friday package?
13:26:48 <Vetii> http://hackage.haskell.org/package/friday-0.1.5
13:26:48 <Vetii> I would like to use it to sort the pixels of an image and do other strange glitch related operations on pixels, but I am kind of stuck with it.
13:28:44 <Rembane> Vetii: How far do you get before getting stuck?
13:29:47 <Vetii> I can open images and save them, and convert them, I would like to extract the Vector from the Image, sort it, and I can do that, but then I don't know how to come back to an image from the Vector representation.
13:31:03 <Vetii> I have this function: vector :: i -> Vector (ImagePixel i), but I couldn't find the inverse function
13:31:58 <Rembane> Vetii: Interesting. Hoogle doesn't help me there. Hm...
13:33:20 <josephle> Rembane: you'd probably need to use Hayoo if you're searching Hackage libraries
13:33:30 <Rembane> josephle: Thank you.
13:33:55 <Vetii> Rembane: Maybe there is another way to do these kinds of tasks? I looked at Vision.Image.Mutable, but I can't really wrap my head around it. (Thanks for the answer btw)
13:34:44 <Rembane> Vetii: No worries. There should be a function to combine some Vectors to an image again.
13:35:01 <MagBo> Any input on my question? :3
13:36:29 <josephle> MagBo: Can you define "M"? It seems it's both in the expression level and type level, which is confusing to me
13:37:46 <MagBo> josephle: oh, good call!
13:38:06 <MagBo> Actually, that answers my question :D
13:38:26 <MagBo> After you have asked me to do that, I reached out for a trivial example which would be Maybe
13:38:34 <Vetii> Rembane: I tried Hayoo but didn't help.
13:39:03 <Rembane> Vetii: Indeed. :/
13:39:08 <MagBo> but for Maybe, clearly on the expression level, we can have either Nothing or Just under what I called "M (f x)"
13:39:12 <MagBo> josephle: <3
13:40:04 <josephle> MagBo: you figured it out yourself :)
13:40:35 <Vetii> Rembane: maybe by using the function fromFunction and trying to manually grab from the vector
13:41:34 <Rembane> Vetii: Do it!
13:42:07 <Vetii> Rembane: *sigh* there should be a function for that.
13:42:55 <Vetii> I'm gonna give it a try, thanks
13:43:10 <LtRipley> hi
13:43:51 <hexagoxel> Vetii: what about Manifest?
13:44:27 <hexagoxel> Vision.Image.Type.Manifest wraps a size and a vector; and it is an instance of Image
13:44:40 <LtRipley> i am looking into the recurisive definition of natural numbers as in: "numbers = 1: map (+1) numbers" but i don't really understand how this is efficient, wouldn't for each number n additions be needed to get the number?
13:45:05 <Vetii> hexagoxel: OH MY GOD
13:45:10 <Vetii> hexagoxel: Yes it is!
13:45:14 <mauke> LtRipley: they're not separate additions, though
13:45:17 <mauke> work is shared
13:45:28 <LtRipley> i don't understand
13:45:35 <Xenasis> Can someone try and explain "on" to me? It has a very dodgy type signature... on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:45:40 <mauke> like, 2 is 1 + 1 and 3 is (1 + 1) + 1
13:45:50 <johnw> huh, I just ran into a case where I really need augustss' kind sections
13:45:56 <mauke> but once you evalute 1 + 1 to 2, 3 collapses to 2 + 1
13:46:08 <mauke> so after computing 2, you just have one additional step to get to 3
13:46:28 <LtRipley> mauke: how? it isn't clear to me how that works by the definition
13:46:39 <LtRipley> mauke: is that some kind of optimization that is happening internally?
13:46:56 <mauke> LtRipley: it's what happens naturally from the definition
13:47:07 <vanila> Xenasis, (*)`on`f = \x y -> f x * f y
13:47:13 <LtRipley> hmm maybe i don't see it
13:47:17 <Vetii> hexagoxel: Thanks!
13:47:25 <cpennington> Xenasis: "on" takes a comparison function (b -> b -> c), a function to convert to comparable types (a -> b), and then compares 2 'a' value using the the comparison function
13:47:32 <Xenasis> What does \x do?
13:47:38 <vanila> that's lambda
13:47:42 <vanila> it's used to create a function
13:47:42 <Xenasis> Oh!
13:47:47 <Xenasis> I usually see it in brackets
13:47:49 <Xenasis> I see
13:47:57 <vanila> here's an example
13:47:57 <Xenasis> hmm
13:48:10 <vanila> > ((==)`on`head) "fear" "far"
13:48:11 <lambdabot>  True
13:48:22 <vanila> > ((+)`on`length) "fear" "far"
13:48:24 <lambdabot>  7
13:48:27 <mauke> LtRipley: numbers = [1, 1 + 1, (1 + 1) + 1, ((1 + 1) + 1) + 1, ...]
13:48:47 <mauke> LtRipley: clear so far?
13:48:57 <LtRipley> no
13:49:09 <mauke> ok
13:49:24 <mauke> LtRipley: do you see why numbers has the form [1, ...]?
13:49:37 <mauke> i.e. 1 as the first element with stuff after it
13:49:37 <LtRipley> i mean, i get the recursive definition, but with the lazy definition it is never laid out like that, right?
13:49:51 <xificurC> NICTA's json parser provides the JsonValue data type with this constructor: JsonRational  Bool !Rational
13:50:03 <xificurC> this begs for 2 questions - 1) what should the Bool stand for; 2) what does the exclamation mark mean
13:50:04 <mauke> LtRipley: why not? I just expanded the spine
13:50:23 <mauke> xificurC: the ! is a strictness annotation
13:50:37 <LtRipley> mauke: but in the end the nth element consists of n additions
13:51:04 <mauke> LtRipley: it's recursive, though. so the nth element consists of the (n - 1)th element plus 1 addition
13:51:17 <mauke> if you only take one element, it's n additions
13:51:21 <tromp> X = 1:map (+1) X = 1:1+1:map (+1) (map (+1) X) = ...
13:51:30 <mauke> but if you look at all elements, you don't do O(n^2) additions
13:51:42 <LtRipley> mauke: but it isn't "cached" anywhere so it has to be computed again
13:51:46 <mauke> LtRipley: ah
13:51:52 <mauke> it is cached!
13:52:09 <mauke> in practice, anyway
13:52:15 <LtRipley> so it IS some kind of optimization the compiler does?
13:52:27 <mauke> more like semantics
13:52:46 <LtRipley> for me it is really hard to see why this is performing well and other things not
13:52:59 <mauke> and I'd say it's a property of the runtime system ... or the way code is generated
13:53:11 * mauke tries channeling Cale
13:53:40 <mauke> LtRipley: consider 'square x = x * x' with 'square (2 + 3)'
13:54:05 <mauke> in a strict language you'd first reduce 2 + 3 to 5, then call square 5, then do 5 * 5 => 25
13:54:15 <LtRipley> yes
13:54:35 <mauke> with non-strict evaluation you get something like (2 + 3) * (2 + 3)
13:55:00 <mauke> that would be inefficient, though, because we have duplicate work
13:55:07 <LtRipley> right
13:55:16 <mauke> with lazy evaluation we don't recompute variables
13:55:30 <mauke> the crucial bit is that (2 + 3) gets bound to a variable, x
13:55:54 <mauke> so 'square (2 + 3)' reduces to something like 'x * x where x = 2 + 3'
13:56:19 <mauke> or a graph where the two child pointers of (*) point to the same subexpression
13:56:21 <hexagoxel> Vetii: Image has no more than two instances, so it was a fast search :p
13:56:46 <LtRipley> yes, that's how it is possible to optimize "power n = power (n-1) + power(n-1)" to "power n = double(n-1)" with "double n = n+n"
13:57:08 <mauke> lazy evaluation effectively updates x to be plain 5 after it's first needed
13:57:28 <mauke> so we go from 'x * x where x = 2 + 3' to 'x * x where x = 5' to '5 * 5'
13:57:46 <hexagoxel> (but that package is somewhat un-documented, admittedly)
13:57:48 <mauke> @src map
13:57:48 <lambdabot> map _ []     = []
13:57:48 <lambdabot> map f (x:xs) = f x : map f xs
13:57:55 <LtRipley> so the moment the function is "called" x is bound to be 5?
13:58:05 <mauke> LtRipley: which function?
13:58:12 <mauke> LtRipley: when square is called, x is bound to 2 + 3
13:58:15 <LtRipley> square
13:58:15 <mauke> (unevaluated)
13:58:57 <LtRipley> so it is bound as soon as the multiplication is evaluated?
13:59:13 <mauke> yes, because * is strict
13:59:26 <mauke> so when the result of * is demanded, we need to evaluate its operands
14:00:27 <LtRipley> and + is not strict?
14:00:29 <mauke> and now I realize the model isn't quite right
14:00:36 <mauke> it's not really variables
14:00:45 <mauke> it's the values themselves that auto-update
14:00:54 <mauke> (+) is strict, too
14:01:38 <LtRipley> then i dont get it
14:02:13 <mauke> we don't evaluate the "same" expression twice
14:02:41 <mauke> what does the strictness of (+) have to do with it?
14:02:43 <LtRipley> same as in literally the same, and not just equivalent
14:02:57 <mauke> right
14:03:06 <mauke> it's really pointer equality underneath
14:05:26 <tromp> (a+b)*(a+b) (probably) won't be shared but let c=a+b in c*c will be shared
14:05:51 <LtRipley> mauke: ok, i will try to picture the concept by painting a graph, and follow the definition of map, maybe together with the concept you just explained will shed some light
14:06:09 <tromp> also (\c->c*c)(a+b) will cause sharing
14:06:26 <mauke> the numbers thing ends up looking like [x1, x2, x3, x4, x5, ...] where x1 = 1; x2 = x1 + 1; x3 = x2 + 1; x4 = x3 + 1; x5 = x4 + 1; ...
14:07:09 <mauke> forcing the nth element implicitly reduces all elements [1 .. n-1] along with it
14:07:13 <LtRipley> and at the point i look at x4, x3 is already evaluated to equal 3 and x1 and x2 are long forgotten?
14:07:27 <mauke> no, it depends on how you look at x4 :-)
14:07:42 <LtRipley> let's assuming i will just dump numbers
14:07:45 <mauke> numbers !! 3 would straight up do 3 additions
14:08:10 <mauke> but if you look at each element from left to right, each next element only requires +1 of work
14:08:54 <mauke> if 'numbers' is global, x1/x2/... won't be forgotten because they're still accessible
14:09:05 <LtRipley> so internally this is just a bunch of pointers to structures containing expressions with some automatic garbage collection?
14:09:19 <mauke> lots of garbage collection
14:10:01 <mauke> AFAIK x = 2 + 3 makes x point to machine code for computing 2 + 3
14:10:11 <LtRipley> that means if get numbers !! 1000000 i will not only count to one million, but i will also block a lot of space?
14:10:26 <mauke> and after the first time that happens, x is updated to point to machine code for "return 5"
14:10:46 <LtRipley> and that space is not freed, as i am still holding a reference to numbers somewhere?
14:11:11 <mauke> I think it depends on how you use numbers afterwards
14:11:36 <mauke> if it's just something like 'let numbers = 1 : map (+1) numbers in numbers !! 1000000', I think it runs in constant space
14:12:00 <mauke> wait, am I thinking about this right?
14:12:10 <LtRipley> are you asking me? :D
14:12:24 <mauke> no, at that point it should still be a thunk of 1000000 subexpressions
14:12:46 <mauke> but the list structure is garbage and can be collected
14:13:16 <LtRipley> why can it be collected, it is still referenced?
14:13:22 <mauke> where?
14:13:36 <LtRipley> oh wait, with 'let' that definition is local, right?
14:13:39 <mauke> yeah
14:13:51 <LtRipley> assuming it is not local, would it stay forever?
14:14:07 <mauke> I think so
14:14:16 <LtRipley> or could the garbage collector just decide to free it anyways, as it has all the information to recompute it anyways
14:14:27 <monochrom> "print numbers" and "print (numbers !! n)" will have very different space behaviour. O(1) vs O(n).
14:14:42 <mauke> is this what CAFs are?
14:14:56 <LtRipley> monochrom: print numbers will take forever, right?
14:15:16 <monochrom> yes, but it keeps printing, and O(1) space.
14:15:32 <LtRipley> oh right missed the "space" part
14:15:54 <LtRipley> actually i still don't see why
14:16:03 <monochrom> either way, no one holds on to the original list. it vapourizes from begin to end.
14:16:24 <mauke> monochrom: even if it's a global variable?
14:16:38 <monochrom> I'm so far using the local "let" version.
14:16:41 <mauke> ah
14:17:14 <monochrom> I have seen empirical evidence that a global version also takes O(1) space if no one else holds numbers.
14:17:29 <Xenasis> Hmm, I'm getting - No instance for (Fractional Int) arising from a use of ‘/’
14:17:29 * hackagebot snaplet-amqp 1.0.1.1 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-1.0.1.1 (ParnellSpringmeyer)
14:17:32 <Xenasis> as an error
14:17:37 <mauke> yeah, you can't use / on Ints
14:17:38 <LtRipley> with let i understand it, nobody is referencing x1 oder x2 so we are good with having x4 = 1 + x3 (with x3 known to be 3)
14:17:40 <Xenasis> when 9/2 in the REPL prints 4.5
14:17:48 <mauke> Xenasis: those aren't Ints
14:18:04 <Xenasis> Is there a / for ints?
14:18:08 <mauke> Xenasis: `div`
14:18:11 <Xenasis> ah
14:18:15 <levi> mauke: CAFs are indeed top-level bindings that are lazily-evaluated.
14:18:20 <Xenasis> thanks
14:18:28 <monochrom> I think you understand that "print (numbers !! n)" takes O(n) space. why "print numbers" takes O(1) space is less obvious. it's a long story I'm too lazy to explain today.
14:18:47 <LtRipley> monochrom: no it is the other way around
14:18:47 <mauke> is it because of laziness
14:19:01 <mauke> levi: thanks
14:19:05 <LtRipley> wait depends, i am confused
14:19:25 <LtRipley> monochrom: both ways make sense to me, i just don't see the difference
14:19:26 <Xenasis> Is there any way to get 4.5 from 9/2 then?
14:19:29 <monochrom> "print numbers" puts back the eagerness needed to keep space low. print is eager.
14:19:30 <Xenasis> Well
14:19:34 <Xenasis> 9 `div` 2
14:19:45 * levi has been poking through the STG Machine papers recently; interesting stuff.
14:19:51 <mauke> Xenasis: you can convert the Ints to Doubles or whatever
14:20:20 <Xenasis> then I guess I'd need to convert back
14:20:21 <mauke> > let x, y :: Int; x = 9; y = 2 in x `div` y
14:20:22 <lambdabot>  4
14:20:23 <Xenasis> no matter, thanks anyway
14:20:26 <vanila> levi, I have been looking at it too!
14:20:29 <mauke> > let x, y :: Int; x = 9; y = 2 in fromIntegral x / fromIntegral y
14:20:31 <lambdabot>  4.5
14:20:36 <monochrom> print (numbers !! n) is a case of first allowing laziness to build up 1+(1+(1+(1+... first.
14:22:39 <LtRipley> monochrom: isn't !! just defined hat  (x:xs) !! n = (xs) !! n-1?
14:22:59 <LtRipley> as
14:23:27 <monochrom> print numbers is a case of, by induction, after you print 9 but before you print the next item, you build 1+9, then the printing crunches it down to 10. there is never a build-up of 1+(1+(1+...
14:23:42 <LtRipley> that would allow the whole thing to be recusrively dealt with, which would mean a space of O(1)
14:23:51 <monochrom> yes LtRipley. it confirms what I say, not contradict what I say.
14:24:09 <monochrom> (x:xs) !! n = (xs) !! n-1 does not reduce x first.
14:24:24 <mauke> LtRipley: you're recursively walking a structure of depth n
14:24:30 <mauke> that structure takes O(n) memory
14:24:34 <monochrom> the O(n) space is used up by x, not by the list.
14:24:45 <monochrom> yes x alone takes O(n) space.
14:24:51 <LtRipley> oh but the x's are never evaluated, they are just discarded
14:24:54 <monochrom> x is 1+(1+(1+...
14:25:10 <mauke> the xs themselves aren't discarded yet
14:25:19 <monochrom> no, xs begins as 1+x, x is held on
14:25:23 <mauke> only the list spine is gone
14:26:02 <monochrom> you're doing numbers = 1 : map (1 +) numbers. the tail has references to the head. ad infinitum.
14:26:04 <LtRipley> ok discarded is the wrong word, but the x are never observed
14:26:10 <monochrom> ok yes
14:26:18 <LtRipley> i get it now
14:26:39 <levi> vanila: Having an actual operational semantics to refer to is handy sometimes. :)
14:27:23 <mauke> .oO( inoperational semantics )
14:28:33 <monochrom> dysfunctional languages and inoperational semantics
14:28:56 <monochrom> dysfunctional languages and inoperational semantics: a detonative approach :)
14:45:24 <homelessrobot> > (1 :: Int) :: Show a => a
14:45:26 <lambdabot>  Could not deduce (a1 ~ GHC.Types.Int)
14:45:26 <lambdabot>  from the context (GHC.Show.Show a)
14:45:26 <lambdabot>    bound by the inferred type of it :: GHC.Show.Show a => a
14:45:26 <lambdabot>    at Top level
14:45:26 <lambdabot>  or from (GHC.Show.Show a1)
14:47:16 <srhb> > (1 :: (Num a, Show a) => a)
14:47:17 <lambdabot>  1
14:47:18 <monochrom> there is no useful value that has type Show a => a
14:47:22 <srhb> Such parametricity.
14:47:26 <srhb> Wow useless.
14:48:01 <monochrom> (Num a, Show a) => a is different.
14:50:50 <davean> It seems like hackage doesn't generate documentation for stuff uploaded recently any more. Am I just unlucky or has it not generated documentation in like a month?
14:50:52 <monochrom> however, there is a fairly useful value of type Read a => Maybe a
14:51:00 <monochrom> or even, there are.
14:51:48 <monochrom> it has disabled building for 2 weeks or something like that
14:52:17 <davean> monochrom: the last I can find with it build is the 8th of Sept.
14:52:21 <monochrom> I know the original why. but that reason has expired. so I don't know today's why.
14:52:21 <davean> monochrom: why is it so disabled?
14:52:36 <monochrom> originally, the server was overloaded. so it was disabled.
14:53:00 <monochrom> later, it turned out that they moved to a better server. the mystery is why they don't enable now.
14:53:28 <monochrom> someone has asked on haskell-cafe a few days ago.
14:54:01 <srhb> I didn't think they moved yet? Didn't they just salvage the old VPS' acid-state and make it run again?
14:54:10 <srhb> If so, the answer is still "overloaded"
14:58:20 <davean> Huh, that thread suggests there is a relation between the build and downloads - weird.
15:00:27 <monochrom> my understanding is that they are on the same hardware
15:01:03 <davean> monochrom: yes, but that usually doesn't cause much of a dependency between the two.
15:01:30 <monochrom> if one thrashes, the other time-out
15:02:06 <davean> monochrom: yah, I'm not arguing this one. I will say "that isn't how it actually usually works".
15:02:19 <monochrom> at any rate, the history was "web side timeouts -> disable building -> web side back to normal"
15:03:02 <merijn> davean: Keep yelling at everyone to "fix your hackage documentation"
15:03:04 <merijn> davean: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
15:03:31 <merijn> davean: Bonus is that that also solves things that *can't* have documentation build on hackage due to missing C libraries
15:03:42 <merijn> But a lot of maintainers aren't manually uploading docs yet
15:04:32 <davean> merijn: huh, that has a script. Wouldn't be that hard to just run it against everything without docs
15:04:58 <merijn> davean: Uh, to run that script requires the package to succesfully build
15:05:08 <davean> merijn: sure?
15:05:10 <davean> Most will
15:05:17 <merijn> davean: Which means 1) compiling which overloads the machine and 2) no missing libraries
15:05:22 <davean> only really the ones with c libs are likely to be a problem
15:05:43 <davean> merijn: there really aren't many packages on hackage.
15:05:43 <merijn> davean: monochrom just pointed out builds were disabled due to load issues
15:06:07 <Fuuzetsu> davean: for that script to work you need to be able to run cabal haddock which means you need to be able to build your package first (typecheck and rename at least)
15:06:21 <davean> yes
15:06:22 <davean> I get that
15:06:42 <davean> And you have what ... 1000 builds to do? 5000? That would be my naive guess
15:07:19 * davean looks into what he'd have to do to just do all the builds
15:07:52 <srhb> I think I need some hand-holding to implement choosing :: Lens s1 t1 a b -> Lens s2 t2 a b -> Lens (Either s1 s2) (Either t1 t2) a b
15:08:13 <srhb> if I have choose l1 l2 f s = ... then I can case off s, right? And handle Left and Right separately
15:08:18 <srhb> choosing*
15:10:15 <bms1> Has anyone made an attempt at putting static sizes on pointers using GHC.TypeLits.Nat?
15:11:11 <merijn> bms1: Probably :)
15:11:53 <davean> anyway, I've found the people to talk to about me doing that now
15:12:22 <srhb> choosing :: Lens s1 t1 a b -> Lens s2 t2 a b -> Lens (Either s1 s2) (Either t1 t2) a b
15:12:27 <srhb> hOops, sorry
15:12:29 <srhb> Random paste.
15:13:29 <bms1> merijn: I can't find anything out there, but I'm considering doing it. I've been statically sizing my matrix code and it's going well
15:13:52 <bms1> So now I've brought the possibly unsafe code back to pointer access
15:14:07 <Denommus> what is a good GUI library to use with reactive-bananas?
15:14:14 <bms1> so I'm thinking I may as well try to make everything as safe as I can!
15:15:25 <Denommus> well, I gotta reboot
15:17:26 <merijn> bms1: Statically sized matrices...you sound like a candidate for #numerical-haskell :)
15:21:04 <bms1> merijn: Yes I just asked carter for advice yesterday actually!
15:24:11 <_fgC_> @type $=
15:24:12 <lambdabot> parse error on input ‘$=’
15:24:20 <_fgC_> @type ($=)
15:24:52 <_fgC_> @type (=$)
15:25:00 <merijn> _fgC_: lambdabot doesn't import conduit (that looks like a conduit operator, at least)
15:25:48 <Mokosha> $= is also used in the OpenGL bindings
15:26:01 <monochrom> hrm, lambdabot has stopped responding
15:26:07 <pavonia> :t ($=)
15:26:07 <lambdabot>     Not in scope: ‘$=’
15:26:07 <lambdabot>     Perhaps you meant one of these:
15:26:07 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
15:26:07 <lambdabot>     Not in scope: ‘=$’
15:26:07 <lambdabot>     Perhaps you meant one of these:
15:26:07 <lambdabot>       ‘$’ (imported from Data.Function), ‘==’ (imported from Data.Eq),
15:26:09 <lambdabot>     Not in scope: ‘$=’
15:26:09 <lambdabot>     Perhaps you meant one of these:
15:26:09 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
15:26:18 <monochrom> heh
15:27:17 <_fgC_> in fact I just wanted to know if he saw me, client shows my lines in red and I was afraid I was muted or something
15:28:31 <Zer000> Is there a constructor for the IO type? Suppose I want a main method that does absolutely nothing, IO () isn't working
15:29:07 <dmj`> Zer000: if you don't want a main method you don't have to have one, you can write a library
15:29:49 <Haskellfant> Zer000: return ()
15:29:54 <Zer000> dmj`, I know that. It was a hypothetical question. But I think I figured it out, return () creates an empty return type
15:29:58 <Zer000> ah there we go
15:29:59 <srhb> Zer000: main :: IO (); main = return ()
15:30:07 <Haskellfant> Zer000: or pure ()
15:30:12 <Zer000> what's pure?
15:30:24 <Haskellfant> the same as return or at least it should be
15:30:28 <srhb> Zer000: There is no exposed value constructor for IO for various reasons.
15:30:31 <Haskellfant> one is from applicative and the other from monad
15:31:58 <merijn> srhb: Actually, there is :)
15:32:07 <merijn> srhb: It's just not in Prelude, for obvious reasons
15:32:23 <merijn> Although even if it was, I don't think any beginner could succesfully use it
15:32:32 * hackagebot extra 0.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.1 (NeilMitchell)
15:33:03 <kazagistar> can I define Ord compare, and then define Eq in terms of it?
15:33:07 <srhb> merijn: I stand corrected. The thought of IO $ ... is weird, though. :-)
15:33:15 <srhb> Perhaps that's just habit.
15:34:40 <srhb> kazagistar: I think Ord requires Eq, not the other way around.
15:35:08 <Denommus> which FRP library is the most usable? Yampa? Reactive-bananas? Some other (like the one Helm uses)?
15:35:12 <merijn> srhb: GHC.Types exposes "IO (State# RealWorld -> (#State# RealWorld, a#))" :)
15:35:25 <merijn> Denommus: netwire's pretty good
15:36:02 <Denommus> merijn: I'll check it
15:36:04 <kazagistar> srhb: right, but if I define compare, then I can easily define Eq in terms of that
15:36:12 <merijn> Denommus: Although I think all of them require quite a struggle to wrap your head around FRP in general
15:36:42 <monochrom> kazagistar, it is alright to have Eq code refer to <= >=
15:36:51 <Denommus> merijn: oh, I already get FRP somewhat well, I even started an implementation in Rust (though it didn't succeed because their closure implementation is still full of internal compiler errors)
15:36:57 <kazagistar> monochrom: cool
15:37:49 <Haskellfant> @pl (\x -> 1:1:zipWith (+) x (tail x))
15:37:49 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
15:38:30 <Denommus> merijn: I just want to apply it in practice in a GUI application
15:38:59 <Denommus> merijn: although I haven't decided for a widget framework. None of them are cross-platform and lightweight enough :-/
15:40:11 <Zer000> So I'm trying to create a very simple http server for learning. Hackage tells me the listenOn function in Network needs a PortID but for some reason this code compiles http://dpaste.com/ , and I don't even have a PortID constructor. Why is that?
15:40:38 <doismellburning> :t PortId
15:40:39 <lambdabot> Not in scope: data constructor ‘PortId’
15:40:41 <doismellburning> :t PortID
15:40:41 <lambdabot> Not in scope: data constructor ‘PortID’
15:40:52 <doismellburning> Zer000: anyway PortID is probably just an alias for Int
15:41:08 <doismellburning> Zer000: and not a distinct type
15:41:49 <zwer> it isn't
15:42:05 <Zer000>     No instance for (Num PortID) arising from the literal `8080'
15:42:10 <kazagistar> Zer000: you didnt actually post your code
15:42:27 <monochrom> no, PortID is not Int. it's an algebraic type of 3 cases.
15:42:30 <Zer000> http://dpaste.com/2468GX2
15:42:32 <Zer000> oopes
15:43:07 <monochrom> PortNumber is a Num instance though. you're looking at 8080::PortNumber
15:43:08 <srhb> PortNumber is a constructor of PortID types
15:43:19 <srhb> Isn't it?
15:43:24 <monochrom> yes
15:43:25 <kazagistar> yes, it is
15:43:47 <monochrom> you can test PortNumber (8080::Int) vs PortNumber (8080::PortNumber) etc
15:44:11 <zwer> Zer000 what's the problem? your code compiles in here
15:44:26 <monochrom> the problem is "it's too good to be true" :)
15:44:30 <kazagistar> there is an instance (Num PortNumber), and the constructor PortNumber takes a value of type PortNumber
15:44:43 <Zer000> it does work! i'm asking why I need a PortNumber here instead of a PortID like the docs say
15:44:46 <srhb> I think maybe Zer000 is expecting constructors of PortID to actually be named PortID, but I'm not sure. :)
15:45:01 <srhb> Zer000: PortNumber 8080 :: PortID
15:45:02 <HeladoDeBrownie> Zer000, that is a PortID
15:45:05 <zwer> PortID is a type, PortNumber is a type constructor
15:45:13 <Zer000> ooooh
15:45:14 <srhb> Zer000: data Foo = Bar Int
15:45:15 <monochrom> PortID is type name, not value name. the 3 value names are Service, PortNumber, UnixSocket. see the doc.
15:45:16 <_fgC_> PortNumber is one of three possible PortID constructors
15:45:17 <srhb> Bar 22 :: Foo
15:45:22 <zwer> :t PortNumber 1080
15:45:23 <lambdabot> Not in scope: data constructor ‘PortNumber’
15:45:42 <zwer> if you tried that in ghci you should get:  PortNumber 1080 :: PortID
15:45:45 <srhb> zwer: PortNumber is not a type constructor. It is a value/data constructor
15:45:57 <zwer> yes my bad
15:45:58 <monochrom> that may be just a typo
15:46:02 <srhb> Sure. :)
15:46:05 <srhb> Just avoiding confusion.
15:46:53 <kazagistar> PortNumber :: PortNumber -> PortID, listenOn :: PortID -> IO Socket, and Num PortNumber is a thing
15:47:36 <Zer000> ok so if PortNumber is a constructor for PortID how come there is a "data PortNumber" also in the docs? what's that then? a type?
15:47:56 <kazagistar> Zer000: yes, its both
15:48:17 <kazagistar> types and values live in different namespaces
15:48:35 <monochrom> there is a type called PortNumber. there is a data constructor for another type called PortNumber again.
15:48:56 <Zer000> how do I make construct a value of type PortNumber?
15:49:01 <Zer000> disregard the word make
15:49:05 <Zer000> typo
15:49:12 <mauke> fromIntegral
15:49:15 <kazagistar> and to make it super confusing, the data constructor PortNumber takes a value of type PortNumber
15:49:25 <monochrom> it is an instance of Num, Integral, etc. you can use numbers.
15:49:33 <jle`> heh
15:49:43 <monochrom> or use Num and Integral methods etc
15:50:09 <kazagistar> ... whoever made this interface was not thinking about the newbies I think :P
15:50:37 <monochrom> I would rather say, the doc should say this explicitly.
15:51:19 <monochrom> a simple blurp "note its instances, you can use Num, Integral methods to create values of type PortNumber" will go a long way
15:53:45 <benmachine> PortNumber causes sadness for all
15:55:05 <bmuk> I'm looking at stackage - it looks really cool. Is it usable for everyday use yet, or should I wait?
15:55:49 <monochrom> it is usuable for everyday use, if all packages you want are on it
15:56:11 <bmuk> do you think we will go to stackage as a community?
15:56:16 <Aruro> is there any nice tutorial on typeclasses?
15:56:25 <fuzzyhorns> monochrom: do you have a good source on your view of specification?
15:56:35 <fuzzyhorns> to follow on our conversation yesterday — i am still thinking on it :x
15:56:51 <srhb> Aruro: Typeclassopedia is very nice.
15:58:18 <roconnor> Any Haskell events in Munich this week? :)
15:58:51 <srhb> Is it possible to have _ behave like undefined, so that I get a type error rather than a hole if the type checker doesn't like what I've done?
15:59:03 <srhb> Especially for Could not deduce (a ~ b)
15:59:22 <Aruro> ty srhb for the link, looks promising and sane
15:59:56 <srhb> Or maybe the better question is: Why doesn't _ behave like undefined in some cases?
16:01:42 <edwardk> > let __ = undefined in __ + __
16:01:43 <lambdabot>  *Exception: Prelude.undefined
16:01:48 <edwardk> just add another _
16:01:58 <hpc> there's a package that does it with (...)
16:02:00 <edwardk> the first one fails to match in the pattern if you define _ = undefined
16:02:25 <edwardk> because an _ pattern doesn't bind _ it binds a wildcard
16:02:35 <srhb> edwardk: I meant _ as in typed holes
16:03:04 <edwardk> srhb: and variable that start with _'s are just variables like any other.
16:03:05 <edwardk> :t _Left
16:03:06 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Either a c) (f (Either b c))
16:03:09 <srhb> Oh..
16:03:13 <edwardk> its just _ has no syntax for binding it
16:03:24 <edwardk> and that ghc prints them nicely with local context when you have a type error with them
16:03:34 <edwardk> which is really helpful if terrifying for lens users some times ;)
16:03:47 <srhb> edwardk: I actually stumbled upon this while trying to learn some lens
16:04:03 <srhb> edwardk: Usually I can use _foo to see "what I should write here"
16:04:15 <edwardk> srhb: lens was written before we added type holes, so at the time its usage of the _ namespace was less annoying
16:04:19 <srhb> But then I noticed that if I replace _foo with undefined, it cannot possibly compile
16:04:51 <edwardk> otoh, we don't have another corner of the namespace for it to crawl into, so we're stuck with _'s
16:05:05 <srhb> Right.
16:06:05 <srhb> I guess what I thought would be useful is having fmap _ 1 -- still report that there's no instance Num (f a) arising from 1
16:06:12 <srhb> And similar.
16:06:16 <edwardk> otoh _ gives you a hole that can't be accidentally bound
16:06:47 <edwardk> fmap _ 1 gets stuck before then
16:06:49 <edwardk> :t fmap _ 1
16:06:50 <lambdabot>     Found hole ‘_’ with type: a0 -> b
16:06:50 <lambdabot>     Where: ‘a0’ is an ambiguous type variable
16:06:50 <lambdabot>            ‘b’ is a rigid type variable bound by
16:06:54 <srhb> Yes exactly
16:07:41 <edwardk> but the type it goes from matters for the resolution of the Num instance you are looking for
16:07:48 <srhb> *nods*
16:07:54 <edwardk> so it isn't a thing it could do ;)
16:08:11 <srhb> Indeed. It was too good to be true. Ah well, time to try something else.
16:08:13 * edwardk feels bad for 'so', that user has to get pinged by IRC constantly when I'm around.
16:08:28 <benzrf> so what!
16:08:30 <edwardk> same with 'ad'
16:08:38 <edwardk> and edk
16:08:40 <benzrf> people dont say ad all that much
16:08:47 <benzrf> edwardk: wait, edk ISNT you?
16:09:00 <benzrf> oh lol
16:09:02 <edwardk> i guess as long as they don't lurk in the #haskell-lens channel where we talk about automatic differentiation a fair bit they'll be okay =)
16:10:36 <srhb> My workaround is having a data Foo = Foo and using that and undefined to see what type I got wrong, and undefined to see if I'm doing something sensible
16:11:17 <srhb> Annoying if I need Foo a b c though
16:11:23 <srhb> Oh well.
16:13:18 <srhb> What I _really_ want to do is see the type of a specific undefined in my code, I guess.
16:13:33 <srhb> Ie. not `a`
16:13:53 <merijn> srhb: typed holes are your friends :)
16:14:04 <srhb> merijn: They are lying liars. :P
16:14:26 <srhb> But yes, replacing undefined with a typed hole works
16:14:33 <srhb> It's just more work than I wanted.
16:14:56 <srhb> Or rather, replacing an undefined in code that compiles works.
16:19:06 <Zer000> what would be the return type be for a function that accepts a Socket, reads from the handler, writes to the handler ad infinitum? loop :: Socket -> ?
16:19:42 <srhb> Zer000: Socket -> IO ()
16:19:50 <srhb> Unless Handle is also an argument
16:20:08 <srhb> But I assume you get that from the Socket
16:21:25 <Zer000> yeah. Thanks srhb
16:21:39 <srhb> Zer000: If in doubt, leave out the signature and ask the compiler.
16:21:52 <Zer000> like in ghci?
16:21:54 <Cale> You could also presumably make it  Socket -> IO a  if it doesn't ever finish.
16:21:57 <srhb> Zer000: Yes.
16:22:02 <Zer000> ok
16:22:38 <Cale> (which sort of expresses in the type that it won't terminate)
16:23:21 <srhb> That's what ghc would infer anyway
16:23:24 <srhb> I think
16:23:33 <srhb> :t let foo x = putStrLn x >> foo x in foo "hi"
16:23:34 <lambdabot> IO b
16:24:33 <srhb> :t let foo x = putStrLn x >> foo x in foo "hi" :: IO loop
16:24:34 <lambdabot> IO loop
16:24:39 <srhb> \o/
16:25:37 <srhb> Though I guess you never see multiletter type variables, so that might be confusing.
16:27:13 <Zer000> hmm ok. Atm I have a scope problem, raw_request is not in scope on line 13
16:27:26 <srhb> Zer000: Link?
16:27:39 <Zer000> http://dpaste.com/3X0MB2S
16:27:41 <Zer000> me and links today
16:27:42 <Zer000> sorry
16:28:08 <srhb> Zer000: Indeed, names bound in a do block with <- do not become visible in where
16:28:40 <srhb> Zer000: you can use let response = ... -- somewhere after the raw_request line
16:28:44 <srhb> And before you use response
16:28:51 <kazagistar> cause it would let you break the chronology otherwise
16:29:25 <Zer000> hey that worked
16:29:31 <Zer000> thanks again
16:29:34 <edk> benzrf: maybe i should put something about that in my ircname or something
16:29:51 <edk> my name is actually edward k, i suppose i'm just lucky i didn't pick an even similarer name
16:30:02 <benzrf> edk: yeah your irc name says otherwise
16:30:21 <benzrf> i assumed you were the other guy's phone acc or somethin
16:30:43 <Aruro> >:t (==)
16:31:14 <srhb> :t (==) -- Aruro
16:31:15 <lambdabot> Eq a => a -> a -> Bool
16:31:46 <Aruro> is eq a typeclass?
16:31:57 <Aruro> :t ([])
16:31:58 <lambdabot> [t]
16:32:16 <srhb> Aruro: Yes.
16:32:30 <srhb> Aruro: The context preceding => are typeclass constraints
16:32:35 <Aruro> in typeclassopedia in first section it is written that [] is a Functor
16:32:38 <benzrf> srhb: just constraints actually!
16:32:51 <srhb> benzrf: Hmm, what is the difference?
16:32:57 <srhb> Aruro: Yes.
16:33:01 <Aruro> why it does not show that [] is Functor?
16:33:02 <merijn> srhb: You can have non-typeclass constraints :)
16:33:10 <srhb> Aruro: Because that's not what :t does
16:33:14 <srhb> merijn: Such as?
16:33:26 <srhb> a ~ b ?
16:33:27 <merijn> srhb: Type families :)
16:33:29 <srhb> Aah.
16:33:32 <srhb> Got it.
16:33:34 <Aruro> but Functor is also a typeclass?
16:33:42 <srhb> Aruro: Yes. :)
16:33:46 <Aruro> :) so
16:34:22 <Aruro> how to see that?
16:34:26 <srhb> Aruro: If you ask ghci :i []
16:34:34 <Aruro> :i []
16:34:44 <srhb> ghci, not lambdabot. I'm not sure if lambdabot even has that feature.
16:34:55 <Aruro> ill try
16:34:58 <srhb> And if it did it might have other instances in scope that you don't expect in Prelude.
16:35:01 <Axman6> from @info is basically @echo
16:35:05 <Axman6> @info []
16:35:05 <lambdabot> []
16:35:08 <benzrf> Axman6: @info is just @undo
16:35:11 <benzrf> it autocorrects
16:35:15 <benzrf> *n*o
16:35:20 <Axman6> oh right, heh
16:35:27 <benzrf> @info do ur <- face;
16:35:27 <lambdabot> <unknown>.hs: 1: 15:Parse error: Last statement in a do-block must be an expression
16:36:12 <Aruro> actually what type [t] means?
16:36:17 <srhb> Aruro: A list of type t
16:36:23 <srhb> That is, the elements in the list have type t
16:36:28 <Aruro> if [] is itself a constructor?
16:36:40 <srhb> Aruro: Well, [t] is special syntax for [] t
16:36:47 <benzrf> Aruro: it's a special case
16:36:55 <benzrf> Aruro: you can't do that for any other type
16:37:18 <Aruro> so typesystem is predefined  with knowledge of what list is?
16:37:31 <srhb> Aruro: The compiler has special list magic, yes.
16:38:08 <srhb> Aruro: You could define your own list using standard syntax though. data List a = Empty | Cons a (List a)
16:38:30 <MagBo> How do you people handle configs?
16:38:59 <Aruro> but then the type of [] is just [t] and type of function is a->b
16:39:14 <srhb> Aruro: Not sure what you're asking.
16:39:24 <Aruro> so my confusion is why [] does not have type of a function?
16:39:32 <Aruro> if it is a constructor
16:39:39 <Aruro> and in a typeclass of functor
16:39:45 <felixn> Aruro: you may find this interesting, in idris numbers are simply a list of S's ... so 5 = S S S S S Z (Z is used to end the data structure)
16:40:10 <Aruro> hm
16:40:24 <srhb> Aruro: You are expecting [] 1 to be a valid list value?
16:40:27 <felixn> Aruro: so to define addition, you just tack one datastructure onto the other!
16:40:41 <Axman6> [] has (at least?) two meanings; it's a TYPE constructor when used at the type level, and it's also a DATA constructor (which takes no arguments) at the value level
16:41:11 <srhb> To get around the magic, use [] as the empty list constructor and (:) for creating nonempty lists
16:41:24 <HeladoDeBrownie> Aruro, constructor doesn't imply function. I'm not sure what you meant about functor
16:41:28 <felixn> Axman6: four meanings! list comprehensions [i | i <- list] :D  and ranges [0..5]
16:41:43 <Axman6> felixn: I meant specifically []
16:41:48 <felixn> ah
16:42:19 <srhb> Aruro: On the value level, (:) takes two arguments, while [] takes zero
16:42:22 <WilliamDhalgren> Aruro: in data List a = Empty | Cons a (List a) , type of Empty is List a . Empty is [] in "magic list syntax" and List a is [a] .
16:43:58 <Aruro> so the fact that [] is Functor means i can make function which will be [a]->[t] list to list?
16:44:10 <srhb> Aruro: Given a function a->t, yes
16:44:17 <Aruro> not just a - > t
16:44:29 <Axman6> what?
16:44:53 <srhb> if foo :: a -> t, then fmap foo :: [a] -> [t]
16:45:14 <Aruro> so yes im trying to see what i means in practice
16:45:23 <srhb> > (+1) 2
16:45:25 <lambdabot>  3
16:45:31 <srhb> > fmap (+1) [1..3]
16:45:32 <lambdabot>  [2,3,4]
16:45:38 <Aruro> what is difference i can just make f([a])=[f(t)] no?
16:45:39 <srhb> here, (+1) is foo
16:45:42 <Axman6> fmap is just map for lists
16:45:56 <exio4> functors*?
16:46:05 <exio4> oh nvm :p
16:46:06 <Axman6> Aruro: f([a]) matches a list with a single element
16:46:21 <Axman6> > let f([a]) = show a in f [1]
16:46:23 <lambdabot>  "1"
16:46:24 <Axman6> > let f([a]) = show a in f [1,2]
16:46:25 <lambdabot>  "*Exception: <interactive>:3:5-19: Non-exhaustive patterns in function f
16:46:40 <felixn> > fmap (+1) (Just 5)
16:46:41 <lambdabot>  Just 6
16:46:56 <Aruro> ok interesting
16:47:15 <Aruro> fmap acts on types?
16:47:17 <zwer> > fmap (++"!") getLine
16:47:18 <srhb> No
16:47:19 <lambdabot>  <IO [Char]>
16:47:34 <Aruro> i still dont see what will be changed is i will forget to  declare [] as Functor?
16:47:44 <srhb> Aruro: I don't understand what you mean
16:47:47 <Axman6> what?
16:47:53 <WilliamDhalgren> Aruro, practical use is mapping some computation over a list. ie making a (certain kind of a) loop
16:48:01 <Aruro> yes
16:48:08 <Axman6> you don't need to declase [] as a functor, it's declared in the Prelude
16:48:12 <HeladoDeBrownie> Aruro, if the [] type didn't have a Functor instance, you just wouldn't be able to use fmap on it. You could still use the specialized map.
16:48:25 <Aruro> that i understood i dont see why for that you need to declare [] to be in Functor typeclass?
16:48:26 <silver> functions defined in terms of fmap won't work for lists then
16:48:41 <srhb> fmap :: Functor f => (a -> b) -> f a -> f b
16:48:44 <Axman6> because lists ARE functors
16:48:47 <srhb> So in this case, f is []
16:48:58 <Axman6> so is Maybe, and IO, and Either e
16:49:17 <Axman6> they all have the same ability to be able to map a function over so0me value "contained" within them
16:49:35 <Axman6> Aruro: have you used java?
16:49:36 <Aruro> will i brake something in typechecking if [] will not be declared as Functor?
16:49:44 <WilliamDhalgren> nope
16:49:48 <Axman6> only if you try to use fmap on a list
16:49:49 <HeladoDeBrownie> Aruro, only if you tried to use fmap on a list
16:50:07 <HeladoDeBrownie> I'm redundant, I'll hop out of the conversation :)
16:50:11 <Aruro> so i still did not get then if i brake nothing why do i need Functor typeclass over [] ?
16:50:22 <Axman6> Aruro: have you used java
16:50:27 <srhb> Aruro: You don't _need_ any functor. They are useful in some cases.
16:50:27 <Aruro> no
16:50:29 <Axman6> do you know what an interface is
16:50:35 <orb__> Aruro, there are some other typeclasses that rely on functor.  Ie if you want to make your list Traversable.
16:50:40 <Aruro> so that what im asking what cases?
16:51:00 <Axman6> Aruro: you don't break anything by not making a type an instance of the Show class, but it's often useful to be able to turn your types into a String
16:51:17 <Axman6> :t show
16:51:18 <lambdabot> Show a => a -> String
16:51:24 <Axman6> > show (1 :: Int)
16:51:26 <srhb> Aruro: Suppose I had a list of numbers and I wanted to add one to each of those numbers. Using the fact that [] is an instance of Functor, I can use fmap (+1) on my list. If I didn't need to do anything like that, I wouldn't need that Functor instance.
16:51:38 <Axman6> > show ([1,2,3] :: [Integer])
16:51:41 <srhb> The question is sort of weird. :-)
16:51:42 <Axman6> > show True
16:51:46 <lambdabot>  "1"
16:51:46 <lambdabot>  can't find file: L.hs
16:51:46 <lambdabot>  "True"
16:51:55 <Axman6> Because we have a type class, we can use show on many different types
16:52:05 <Aruro> not wierd i thought functors help to typecheck
16:52:28 <srhb> Aruro: No, Functors implement fmap. Meaning we can use fmap on all Functors.
16:52:29 <Axman6> no
16:52:33 <Axman6> it's just a common interface
16:52:37 <Axman6> :t fmap
16:52:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:53:07 <Axman6> that type basically tells you everything about functors; they're types which you can map functions over, or, in other words, lift functions into the domain of
16:54:03 <Axman6> fmap allows you take functions which only work on a's and turn them into functions which work on f a's
16:54:10 <Axman6> that's it, nothing more
16:54:18 <Axman6> (except a few laws)
16:55:02 <pjdelport> The important bit about Functor and fmap is that fmap is structure-preserving.
16:56:00 <Aruro> yes interesting last point
16:56:45 <WilliamDhalgren> also its fairly convenient that you're able to use your fmap over containers of various "shapes". So in whatever algo you implemented with fmap, you could easily change the list out for say a sequence, fmaps would still work because they implement the Functor typeclass too.
16:57:12 <Axman6> pjdelport: we were discussing yesterday whether Set should be a Functor, and imo, it should be, even if its structure is not preserved; it follows the functor laws (assuming you can restrict the types of a and b to have Ord)
16:57:25 <Aruro> how is it visible that type a has structure? by definition?
16:57:44 <Axman6> it's not a's structure that's preserved, it's f's
16:58:00 <Axman6> so length xs = length (fmap show xs)
16:58:10 <Aruro> ok yes i see
16:58:21 <pjdelport> Axman6: Well, Set's structure is preserved, as far as its Functor instance is concerned.
16:59:00 <Axman6> Aruro: Functor has two laws: fmap id = id, and fmap f . fmap g = fmap (f . g)
16:59:58 <pjdelport> Axman6: As far as i understand that Set Functor / Monad implementation technique, it defers collapsing all the elements back down into a Set until you actually pull them out again, doesn't it?
17:01:27 <pjdelport> (I didn't look into it in too much detail yet, so i might be wrong!)
17:02:28 <Aruro> fmap (+3)  [2]
17:02:37 <Aruro> >fmap (+3)  [2]
17:02:40 <srhb> Aruro: Needs a space
17:02:46 <srhb> > fmap (+3) [2]
17:02:48 <lambdabot>  [5]
17:02:50 <Aruro> > fmap (+3)  [2]
17:02:52 <lambdabot>  [5]
17:02:53 <srhb> Right :)
17:02:55 <monochrom> pjdelport: the hole I poked at Set is not functor laws, but free theorems or natural transformation. size :: Set a -> Int, expected size s = size (fmap f s), inferred size {1,2} != size (fmap (const True) {1,2}). you now have to retract one of: Set is a functor, Set a -> Int has parametricity, size exists.
17:02:56 <Axman6> pjdelport: I think so. Did you see my alternative Monad declaration which would allow Set to be a Monad?
17:02:58 <Aruro> > fmap (+3)  [Just 2]
17:03:00 <lambdabot>  No instance for (GHC.Show.Show a0)
17:03:00 <lambdabot>    arising from a use of ‘M23335415058807073086442.show_M23335415058807073086...
17:03:00 <lambdabot>  The type variable ‘a0’ is ambiguous
17:03:00 <lambdabot>  Note: there are several potential instances:
17:03:00 <lambdabot>    instance [safe] GHC.Show.Show
17:03:15 <srhb> > fmap (fmap (+3)) [Just 2]
17:03:16 <numberten> > (fmap . fmap) (+3) [Just 2]
17:03:17 <lambdabot>  [Just 5]
17:03:18 <lambdabot>  [Just 5]
17:03:35 <Aruro> but Just 2 is some type no like 2?
17:03:42 <MagBo> forceEither $ get (p "foo() = \"bar\"") "DEFAULT" "foo()" -- > "bar"
17:03:46 <srhb> :t Just 2
17:03:47 <lambdabot> Num a => Maybe a
17:03:55 <Axman6> Aruro: you can't add 2 to Just 2, Just 2 isn't a number
17:03:55 <numberten> just +2 isn't defined on values of type Maybe Int
17:04:01 <numberten> :t (+2)
17:04:02 <lambdabot> Num a => a -> a
17:04:05 <numberten> :t Just 2
17:04:08 <lambdabot> Num a => Maybe a
17:04:20 <MagBo> forceEither $ get (p "foo(A) = \"bar\"") "DEFAULT" "foo(A)" -- > *** Exception: (NoOption "foo(a)","get (DEFAULT/foo(a))")
17:05:06 <Aruro> so a and Just a is not same?
17:05:09 <MagBo> It's ConfigParser library. Why does it behave like this?
17:05:14 <srhb> Aruro: Indeed.
17:05:48 <Axman6> Aruro: why would they be the same?
17:05:53 <Axman6> :t 1
17:05:54 <lambdabot> Num a => a
17:05:57 <Axman6> :t Just 1
17:05:58 <lambdabot> Num a => Maybe a
17:06:08 <Axman6> those types are clearly different
17:08:13 <Aruro> > (Just 3)+(Just 2)
17:08:14 <lambdabot>  No instance for (GHC.Show.Show a0)
17:08:15 <lambdabot>    arising from a use of ‘M6858377602081380666573.show_M6858377602081380666573’
17:08:15 <lambdabot>  The type variable ‘a0’ is ambiguous
17:08:15 <lambdabot>  Note: there are several potential instances:
17:08:15 <lambdabot>    instance [safe] GHC.Show.Show
17:08:24 <numberten> it's important to note we're talking about Just a and a being different within the same type signature
17:08:30 <numberten> Just a can still unify to some other a
17:08:32 <numberten> :t id
17:08:32 <lambdabot> a -> a
17:08:36 <numberten> :t Just 1
17:08:37 <lambdabot> Num a => Maybe a
17:08:44 <numberten> :t id (Just 1)
17:08:45 <lambdabot> Num a => Maybe a
17:08:53 <numberten> > id (Just 1)
17:08:55 <lambdabot>  Just 1
17:10:25 <Aruro> fmap (+3) (Just 2)
17:10:30 <Aruro> > fmap (+3) (Just 2)
17:10:31 <lambdabot>  Just 5
17:10:42 <Axman6> > fmap (+3) [1,2,3]
17:10:44 <lambdabot>  [4,5,6]
17:10:47 <zwer> Aruro liftA2 (+) (Just 3) (Just 2) will work. but perhaps it is better that you learn about Maybe and get really comfortable with Functor before diving into Applicatives
17:10:49 <Axman6> > fmap (+3) (Right 7)
17:10:51 <lambdabot>  Right 10
17:11:30 <Aruro> ty  zwer
17:11:46 <Aruro> so to sum up is [Just 2] a double context?
17:11:50 <orb__> For some reason, my tutee also had problems with Maybe.
17:12:00 <Axman6> :t [Just 2]
17:12:00 <lambdabot> Num a => [Maybe a]
17:12:04 <orb__> Aruro, sort-of.
17:12:11 <orb__> > mapM [Just 2]
17:12:12 <lambdabot>  Couldn't match expected type ‘a -> m b’
17:12:12 <lambdabot>              with actual type ‘[Data.Maybe.Maybe a0]’
17:12:25 <orb__> > traverse [Just 2]
17:12:27 <lambdabot>  Couldn't match expected type ‘a -> f b’
17:12:27 <lambdabot>              with actual type ‘[Data.Maybe.Maybe a0]’
17:12:43 <orb__> > Data.Traversable.sequence [Just 2]
17:12:44 <lambdabot>  Not in scope: ‘Data.Traversable.sequence’
17:13:06 <Aruro> that is why fmap (+3) [Just 2] does not work, it does not dig in ?
17:13:24 <orb__> > (fmap . fmap) (3+) [Just 2]
17:13:25 <lambdabot>  [Just 5]
17:13:36 <orb__> Needs more fmap, to get through both layers.  Yes.
17:13:40 <Axman6> Aruro: right, it only goes "one layer deep"
17:13:45 <Aruro> yes u digged by hand
17:13:47 <zwer> yes, you have two layers of Functors there. just like fmap (+1) [[Just 1, Just 2], [Just 3, Just 4]] wouldn't work
17:14:05 <Aruro> ok ty guys
17:14:15 <Aruro> i think i got something out of this
17:14:35 <zwer> just like `fmap (+1) [[1, 2], [3, 4]]' wouldn't work, even
17:15:22 <Aruro> > fmap (+1) [[1,2],[3,4]]
17:15:23 <lambdabot>  No instance for (GHC.Show.Show t0)
17:15:23 <lambdabot>    arising from a use of ‘M75625522712469031536796.show_M75625522712469031536...
17:15:23 <lambdabot>  The type variable ‘t0’ is ambiguous
17:15:23 <lambdabot>  Note: there are several potential instances:
17:15:23 <lambdabot>    instance [safe] GHC.Show.Show
17:15:39 <orb__> > (fmap . fmap) (1+) [[1,2],[3,4]]
17:15:41 <lambdabot>  [[2,3],[4,5]]
17:16:03 <orb__> > fmap (fmap (1+)) [[1,2],[3,4]]
17:16:04 <lambdabot>  [[2,3],[4,5]]
17:16:12 <gcganley> You always can do with more fmap
17:16:16 <orb__> I prefer (fmap . fmap) f over fmap (fmap f)
17:16:39 <Aruro> actually why double work? is it currying?
17:16:40 <orb__> This whole composing fmaps leads to lenses, and traverses.
17:17:15 <Aruro> a no it is fmap to famp
17:17:17 <Aruro> fmap
17:17:19 <Aruro> nice
17:17:30 <Aruro> fmap help to itself
17:17:34 <kludgy> hmm.. (fmap `fpow` n) I suppose requires evaluation at the type level :)
17:20:29 <numberten> Aruro: i think it's worth noting that, you could define an instance of Num for Num a => Maybe a
17:20:37 <numberten> that would allow things like: Just 5 + Just 5
17:21:34 <orb__> numberten, all the methods would look like (+) = liftA2 (+)
17:22:09 <orb__> You could even make Just _ / Just 0 do the obvious right thing of giving Nothing.
17:23:03 <numberten> yep
17:24:08 <nshepperd> > fmap (+1) (Compose [[1,2],[3,4]])
17:24:09 <lambdabot>  Not in scope: data constructor ‘Compose’
17:24:17 <orb__> The liftA2 trick would work for any Applicative a to derive Num x => Num (a x)
17:24:18 <nshepperd> pah
17:24:29 <orb__> nshepperd, nice try.
17:24:46 <Axman6> orb__: whether it's a meaningful implementation of Num is another matter
17:24:47 <orb__> Aruro, nshepperd was trying to demonstrate that functors are closed under composition.
17:25:24 <orb__> Aruro, they are also closed under cartesian product, and a few other operations.  Applicatives have similar nice properties.  Monads don't.
17:25:29 <Aruro> ty guys! really illuminating discussion!
17:25:40 <orb__> That's part of the reason people have come to like Applicatives much more than Monads, in the last few years.
17:26:32 <orb__> if you have, data Compose f g a = Compose (f (g a))
17:26:58 <orb__> then Compose f g is a functor if f and g are, with the obvious implementation of
17:27:22 <orb__> fmap = (fmap . fmap) [modulo applying the Compose constructor.)
17:27:34 <srhb> Hmm, now I'm stuck with (<%~) :: Lens s t a b -> (a -> b) -> s -> (b,t)
17:27:37 * hackagebot irc-conduit 0.1.0.1 - Streaming IRC message library using conduits.  http://hackage.haskell.org/package/irc-conduit-0.1.0.1 (barrucadu)
17:27:54 <lpaste> solatis pasted “liftIO returns array of arrays instead of array” at http://lpaste.net/112201
17:28:02 <orb__> srhb, no swearing on the channel, please. ;-)
17:28:07 <solatis> can anyone hold my hand again with some monad / IO problems again?
17:28:20 <srhb> I got this far, looking for clues: (<%~) l ab s = let foo = (l . pure) ab s in ...
17:28:25 <srhb> orb__: Sorry :-)
17:28:26 <solatis> I have a type IO [Title], and when I perform a liftIO, it result in [[Title]] !
17:28:29 <orb__> Oh, sorry, that was a lens operator, not a comic book swear.
17:28:44 <solatis> Can anyone explain to me why lifting IO [Title] does not result in [Title], but in [[Title]] ?
17:28:47 <WilliamDhalgren> thatsthejoke
17:28:58 <solatis> am I misunderstanding something again?
17:29:25 <WilliamDhalgren> solatis sry, that was directed at orb__
17:29:41 <solatis> does this have something to do with the implementation of the underlying IO (Database.Persist) monad?
17:29:52 <solatis> WilliamDhalgren, i understood that ;)
17:29:55 <cmears> solatis, I think liftIO doesn't do what you think
17:30:03 <jayunit100_4g> howcome we need to surround b:c in parenthesis?
17:30:11 <srhb> solatis: You can't escape from IO
17:30:18 <solatis> ok
17:30:20 <HeladoDeBrownie> solatis, your liftIO looks to be a no-op, and isn't where the problem is
17:30:25 <orb__> jayunit100_4g, you don't always need to.
17:30:34 <orb__> > 1 : [3,4]
17:30:36 <lambdabot>  [1,3,4]
17:30:37 <HeladoDeBrownie> solatis, map entityVal $ titles -- What type does this have?
17:30:51 <solatis> HeladoDeBrownie, IO [Title]
17:31:00 <HeladoDeBrownie> solatis, you sure? Ask GHC.
17:31:01 <jayunit100_4g> > Just (init (1:[1,2]))
17:31:03 <lambdabot>  Just [1,1]
17:31:11 <jayunit100_4g> Just (init 1:[1,2])
17:31:25 <HeladoDeBrownie> solatis, ah, never mind, that's fine, it's the return that adds the other layer
17:31:26 <solatis> hmmm
17:31:27 <orb__> jayunit100_4g, in this case, the function application of init would have higher precedence.
17:31:31 <jayunit100_4g> sorry, i meant ….
17:31:33 <jayunit100_4g> >Just (init (1:[1,2]))
17:31:50 <HeladoDeBrownie> solatis, I take it selectList [] [] gives a list?
17:31:54 <jayunit100_4g> > Just (init 1:[1,2])  -- there we go ! sorry it took so long.
17:31:56 <lambdabot>  No instance for (GHC.Show.Show a0)
17:31:56 <lambdabot>    arising from a use of ‘M14963035653792989347103.show_M14963035653792989347...
17:31:56 <lambdabot>  The type variable ‘a0’ is ambiguous
17:31:56 <lambdabot>  Note: there are several potential instances:
17:31:56 <lambdabot>    instance [safe] GHC.Show.Show
17:31:58 <orb__> init 1 : [2,3] is implicitely equivalent to (init 1) : [2, 3]
17:32:13 <jayunit100_4g> orb__:  okay, so init has higher precedence than :
17:32:19 <orb__> No, not init.
17:32:28 <orb__> space has.
17:32:32 <jayunit100_4g> "space" ?
17:32:38 <orb__> the space operator (ie function application) has the highest precedence.
17:32:47 <jayunit100_4g> ahhh okay
17:32:50 <orb__> init[space]1
17:33:11 <jayunit100_4g> so , space itself is an operator, i see
17:33:13 <solatis> HeladoDeBrownie, not really -- http://hackage.haskell.org/package/persistent-1.1.5.1/docs/src/Database-Persist-Query-Internal.html#selectList
17:33:15 <orb__> sort-of.
17:33:17 <jayunit100_4g> i guess thats how everything works
17:33:18 <jayunit100_4g> :)
17:33:19 <orb__> Not really.
17:33:26 <Axman6> jayunit100_4g: function applic ation has the highest binding
17:33:43 <jayunit100_4g> okay
17:33:50 <HeladoDeBrownie> solatis, then entityVal's output is a list?
17:33:59 <solatis> yeah
17:34:10 <prinsen_> I am trying to export functions with FFI, and get  Unacceptable argument type in foreign declaration: UserDefinedType
17:34:12 <HeladoDeBrownie> solatis, there you go. mapping the elements of a list onto lists gives a list of lists.
17:34:22 <solatis> hmm
17:34:28 <HeladoDeBrownie> solatis, perhaps you want to concat afterwards?
17:34:31 <orb__> function application is only a second-class operator.  Ie with normal operators you can prefix them like (+) 2 3.  You can't do that with space, ( ) not True
17:34:36 <HeladoDeBrownie> Just a guess, there are multiple things you could be trying to do
17:34:48 <solatis> HeladoDeBrownie, i'm trying to wrap my head around this
17:35:04 <solatis> well
17:35:18 <Aruro> blessing comes -> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
17:35:33 <benzrf> Aruro: that post is SO not helpful
17:35:35 <solatis> in my specific case, it's about a test case -- insert [Title] into the databse, query the database and compare the IO [Title] with my original [Title]
17:35:38 <jayunit100_4g> that is AWESOME
17:35:48 <Aruro> why not?
17:35:54 <HeladoDeBrownie> solatis, I don't get what you mean. IO [Title] and [Title] are incomparable.
17:35:56 <Aruro> whats wrong with it?
17:36:02 <benzrf> also
17:36:07 <solatis> HeladoDeBrownie, yeah exactly, that's why i was trying to lift the IO :)
17:36:08 <benzrf> ugh it calls functorial values functors >.>
17:36:15 <HeladoDeBrownie> @type liftIO
17:36:16 <lambdabot> MonadIO m => IO a -> m a
17:36:17 <joelteon> benzrf read that on another blog post about that blog post
17:36:20 <srhb> solatis: That's not how lifting work. You could lift the comparison though
17:36:24 <solatis> but i understand i can't escape the IO
17:36:26 <HeladoDeBrownie> solatis, saying that liftIO "lifts the IO" would be a gross mischaracterization :P
17:36:26 <solatis> yeah
17:36:27 <Aruro> lol
17:36:37 <HeladoDeBrownie> Well, at least in this sense
17:36:43 <solatis> i now understand i have to perform the comparison operations *inside* the IO
17:36:46 <solatis> right?
17:36:51 <HeladoDeBrownie> Sure
17:36:52 <solatis> or am i wrong again :)
17:36:53 <srhb> solatis: (==pureTitleList) <$> allTitles pool
17:36:56 <Aruro> anyway as a first approach it was megahelpfull
17:36:59 <srhb> solatis: You are correct
17:37:07 <orb__> <$> is another name for fmap.
17:37:14 <hiptobecubic> Aruro, i think the problem is that it focuses on making you think about things as boxes, which is typically the *only* part anyone manages to do on their own anyway
17:37:23 <benzrf> seriously though
17:37:31 <solatis> ok, so I do an fmap myFun on the IO [Title]
17:37:34 <benzrf> that post is ONLY helpful for looking at the types
17:37:40 <hiptobecubic> sure it says "context" everywhere, but just so that they'll stop getting hate mail.
17:37:50 <Aruro> typeclassopedia also talks non stop about contexts
17:37:51 <benzrf> afaict it's AWFUL for actual intuition of what functors and applicatives and monads really ARE
17:37:55 <benzrf> :|
17:37:58 <srhb> solatis: Or to keep it monadic, allTitles pool >>= \titlesFromIO -> return (titlesFromIO == pureTitles)
17:38:10 <MagBo> I'm trapped in IO monad halp :D
17:38:12 <HeladoDeBrownie> solatis, yep, you can also use do notation if it helps you think about it. fmap f x is the same as do { x' <- x ; return (f x') }
17:38:15 <solatis> srhb, that's what I'm probably looking for
17:38:24 <benzrf> MagBo: have you tried binding yourself to main
17:38:26 <Aruro> SO what is better post? benzrf?
17:38:27 <srhb> > unsafePerformIO MagBo
17:38:28 <lambdabot>  Not in scope: ‘unsafePerformIO’Not in scope: data constructor ‘MagBo’
17:38:33 <solatis> or at least, that seems like the "least magic" approach and makes it most clear what's happening :)
17:38:33 <srhb> You're out of luck.
17:38:49 <benzrf> i feel like it might be interesting to try explaining functors to a beginner in a more functory manner
17:38:55 <srhb> solatis: It's a bit unidiomatic because we don't need the extra return and stuff, but sure. :)
17:39:01 <benzrf> i.e. talk about `corresponding functions on the other type' or some jazz
17:39:01 <srhb> solatis: It might be pedagogical.
17:39:06 <benzrf> as opposed to `mapping'
17:39:28 <Aruro> typeclassopedia is not good gets lost in syntax too quickly
17:39:44 <Aruro> losing point why we need it at all
17:39:52 <srhb> Aruro: It's really good, but you might not have the knowledge you need yet.
17:40:01 <srhb> In my opinion it should be mandatory. :-)
17:40:18 <Aruro> probably
17:40:18 <solatis> ok, so that is why all functions that actually perform monadic actions (like fmap) require a callback instead of returning something -- the callback is executed *within* the monad, instead of getting rid of the monad (which I was trying to do)
17:40:26 <Aruro> wiki assumes kinda tutorial :)
17:40:34 <Aruro> isnt it?
17:40:37 <HeladoDeBrownie> solatis, yeah, you can't interpret IO yourself, the runtime system has to do that.
17:40:44 <solatis> got it
17:40:58 <solatis> and i have to use functions like mapM, sequence, etc to do that
17:41:17 <HeladoDeBrownie> solatis, note that this is true for IO *in particular*; many other types *can* be interpreted purely, and in fact the only real reason we can't do pure interpretation of IO is because it's rather opaque by design
17:41:18 <srhb> solatis: mapM, fmap, liftM, ...
17:41:30 <solatis> HeladoDeBrownie, like the Maybe monad..
17:41:31 <kadoban> Would anyone be able to help me figure out why I have so many problems installing pandoc? I get "src/Text/Pandoc/Shared.hs:808:55: Not in scope: ‘toChunks’" and I'm not finding much info on fixing that...
17:41:39 <HeladoDeBrownie> solatis, of course, pure interpretation of IO, were it possible, would still only result in pure values, not side effects
17:41:49 <kadoban> I know I made some change before to my cabal deps or something and that went away, but I sure can't remember what.
17:41:56 <HeladoDeBrownie> solatis, yep, Maybe can indeed be "intepreted", by way of pattern matching :)
17:42:07 <srhb> kadoban: iirc that's an issue with pandoc 3 vs. something something...
17:42:20 <solatis> that's why case foo of ... seems to "get rid" of the monad
17:42:28 <solatis> it's actually executed *within* the monad
17:42:36 <srhb> kadoban: https://github.com/jgm/pandoc/issues/1590 ?
17:42:37 <benzrf> solatis: eeehhh
17:42:49 <solatis> sorry, i'm probably talking nonsense again
17:42:58 <benzrf> solatis: fmap is like a filter tacked onto the IO action's output valve
17:43:04 <srhb> solatis: "executed inside" as an analogy only works so far... :-)
17:43:09 <kadoban> srhb: Nice, thanks. I'll look into that.
17:43:16 <benzrf> solatis: for example, getLine is like a machine that, when switched on, spits out a line that the user typed in
17:43:32 <benzrf> solatis: so `fmap reverse getLine' is the same machine but with a reverse function glued to the output valve
17:43:45 <srhb> kadoban: ie cabal install pandoc -fhttps fixes it for now
17:43:45 <solatis> i understand
17:43:46 <benzrf> there's no turning-on involved, just building onto the inactive machine
17:43:54 <benzrf> kk
17:44:08 <prinsen_> what does Unacceptable result type in foreign declaration mean?
17:44:13 <srhb> kadoban: (I must have a better search engine bubble than you, it was the first result when searching for pandoc toChunks on google) :-)
17:44:28 <benzrf> prinsen_: bad news for your next n hours :^)
17:44:42 <kadoban> Hah, maybe. I usually just throw in the whole error and generally find something, but that didn't seem to work this time.
17:44:51 <prinsen_> benzrf: hm, expand :)
17:44:53 <WilliamDhalgren> I ended up applying the trivial patch linked in that issue instead
17:45:29 <WilliamDhalgren> don't remember why -fhttps wasn't satisfactory, but there was some wart still
17:46:16 <vermeille> is there a naming convention for """pure""" functions and monadic State functions?
17:46:17 <kadoban> Bah, gotta run for a bit, back later. Thanks again...I'll have to figure out how to get cabal to install the version I need without messing up the rest of my deps...I'm not very good at cabal.
17:46:40 <srhb> vermeille: Not really.
17:46:54 <srhb> vermeille: State actions are usually called by what they do
17:46:55 <vermeille> So that I can distinguish something like modifyThing :: Thing -> Int and modifyThing' :: State Thing Int
17:46:57 <srhb> killPlayer name = ...
17:47:51 <HeladoDeBrownie> vermeille, did you mistype one of those types?
17:48:01 <HeladoDeBrownie> mis…write, to disambiguate :P
17:48:23 <HeladoDeBrownie> Thing -> Int doesn't look to be modifying anything to me
17:48:50 <HeladoDeBrownie> Thing -> Thing would, or even Thing -> (Int, Thing) (which is what State Thing Int is)
17:48:55 <vermeille> HeladoDeBrownie: Right, sorry, tired. modifyThing :: Thing -> Int -> Thing
17:49:33 <HeladoDeBrownie> Well you can easily lift a function of type Int -> Thing -> Thing into State using modify
17:49:38 <Axman6> updateFoo is usually not a terrible name for State things
17:49:44 <srhb> Eww.
17:49:48 <Aruro> > data Point = Point Int
17:49:49 <lambdabot>  <hint>:1:1: parse error on input ‘data’
17:49:51 <HeladoDeBrownie> @type modify ((undefined :: Int -> Thing -> Thing) 10)
17:49:52 <lambdabot> Not in scope: type constructor or class ‘Thing’
17:49:52 <lambdabot> Not in scope: type constructor or class ‘Thing’
17:49:55 <HeladoDeBrownie> Woop
17:50:02 <HeladoDeBrownie> @type modify ((undefined :: Int -> String -> String) 10)
17:50:03 <lambdabot> MonadState String m => m ()
17:50:05 <Aruro> how do i make Point to be a Functor so i can use fmap?
17:50:33 <orb__> Aruro, a functor needs to take an argument.
17:50:34 <srhb> Aruro: You can't
17:50:36 <HeladoDeBrownie> vermeille, so in short, you might not need the explicit State version, you could get away with the other one in combination with modify :)
17:50:38 <srhb> Point has the wrong kind
17:50:41 <Axman6> Aruro: Functors are things with kind * -> *, poin t has kind *
17:50:43 <Aruro> no?
17:50:47 <Axman6> @kind Int
17:50:48 <srhb> data Point a = Point a -- would be doable
17:50:48 <lambdabot> *
17:50:52 <Axman6> @kind Maybe
17:50:53 <lambdabot> * -> *
17:50:57 <orb__> srhb, but pointfree. ;o)
17:50:58 <Axman6> @kind Either
17:50:58 <lambdabot> * -> * -> *
17:51:09 <srhb> orb__: Your comment is pointless! :-)
17:51:31 <Axman6> Aruro: so, for something to be a Functor, it must have a type argument for its type constructor
17:51:31 <Aruro> haah :)
17:51:41 <vermeille> HeladoDeBrownie: True, but that's more verbose
17:51:44 <Aruro> yes! that i FINALLY got :D
17:52:21 <HeladoDeBrownie> vermeille, sure, but marginally. It's the difference between modifyF 10 and modify (f 10)
17:52:22 <vermeille> HeladoDeBrownie: http://imgur.com/XjkwJW5 That's the functions I have to name
17:52:53 <Axman6> Aruro: so you understand that Maybe isn't a "whole" type, but Maybe Int is?
17:53:02 <srhb> Reposting: Defining, (<%~) :: Lens s t a b -> (a -> b) -> s -> (b, t) -- I got this far, looking for clues: (<%~) l ab s = let foo = (l . pure) ab s in ...
17:53:09 <srhb> Now foo :: (a -> t) and I don't know where to go
17:53:28 <solatis> HeladoDeBrownie, srhb, thanks i got my code to work, i think i'm one step further in understanding all this monad nonsense now :p
17:53:39 <HeladoDeBrownie> vermeille, those aren't really equivalent. Like I said, State s a is s -> (a, s)
17:53:50 <Aruro> yes axman i do
17:53:50 <srhb> solatis: Enlightenment awaits around the corner! :-)
17:54:02 <vermeille> I know what State is, I re-wrote it several times
17:54:37 <Aruro> i could define data Point a = Point a deriving (Show, Functor) but it complains i need a Functor realization :) obviously
17:55:06 <vermeille> I agree the stores are not equivalent due to argument position
17:55:08 <srhb> Aruro: Read up on how to define instances.
17:55:14 <Aruro> i want to achieve fmap (+2) (Point 1) and go happily to sleep :D
17:55:15 <vermeille> But they are semantically equivalent
17:55:18 <HeladoDeBrownie> Aruro, of course that's just Identity Functor anyway
17:55:38 <HeladoDeBrownie> runIdentity . fmap f . Identity = f
17:55:41 <vermeille> (I'll change argument order in my implementation, thanks for pointing that)
17:55:41 <srhb> Aruro: http://en.wikibooks.org/wiki/Haskell/The_Functor_class#Introducing_Functor
17:55:50 <Aruro> ty!
17:55:51 <Axman6> srhb: so it seems there's a cheat's way to do it by using the lens to extract the b out of the t once you've run it over s
17:55:55 <HeladoDeBrownie> vermeille, not simply due to argument position
17:56:03 <Axman6> but there should be a better way.
17:56:05 <srhb> Axman6: Oh hmm.
17:56:16 <Axman6> srhb: can you use the facvt that (a,) is a Functor some how?
17:56:23 <HeladoDeBrownie> vermeille, readAddr' says: You give me an Addr, and a VM, and I give you a VM and a Value.
17:56:31 <srhb> Axman6: Not sure.
17:56:36 <HeladoDeBrownie> readAddr says: You give me an Addr, and a VM, and I give you a Value.
17:56:40 <HeladoDeBrownie> See the difference? No VM result
17:57:24 <vermeille> readAddr is not intended to modify VM in any way
17:57:33 <vermeille> that's just a getter
17:57:43 <Axman6> srhb: hmmmmm, is f' a = let b = ab a in (b,b) useful perhaps?
17:58:06 <HeladoDeBrownie> vermeille, then I would suggest you don't need a State version. Just use fmap or the like as necessary.
17:58:13 <Aruro> ty srhb for the link, exactly to the point
17:58:16 <Axman6> it seems you need to modify the a->b function so you initially get the b in the first element of a tuple
17:58:37 <srhb> Axman6: Let me think on that for a while. Thanks. :)
17:58:44 <Aruro> ty all have a good day/night and productive thinking!
17:59:16 <WilliamDhalgren> Aruro it does work with data Point a = Point a deriving (Functor, Show) ; fmap (+2) (Point 1)
17:59:19 <vermeille> HeladoDeBrownie: True. I initially wanted a State version in order to have something clean and easy to read, but true.
17:59:26 <Axman6> srhb: it's not something I've spent a whole lot of time thinking about, but I remember that there are weird tricks like using the Const functor to pull out values
17:59:33 <srhb> Indeed.
17:59:39 <Axman6> and I think using the (a,) functor might be what you need here..
18:00:05 <WilliamDhalgren> Aruro: since you're trying to derive Functor, rather than write it yourself, did you enable the relevant language extension?
18:00:12 <Axman6> lenses are just (a -> f b) -> (s -> f t) right?
18:00:31 <srhb> Axman6: Yep
18:01:12 <Axman6> then you should be able to do use your a -> b into (a -> (b,) b) -> (s -> (b,) t) (to butcher the syntax somewhat)
18:01:28 <Axman6> which afaict is exactly what you want
18:03:04 <Axman6> srhb: if that's correct, I feel I've just learnt a hell of a lot when I wasn't expecting to =)
18:03:45 <srhb> Axman6: Feel free to find out on your own. :-) I think I'll save your comments for tomorrow and try again when I can brain again. No spoilers. :-)
18:04:01 <HeladoDeBrownie> Sorry, my router derped.
18:04:20 <Axman6> heh ok. I've never played with lens, just watched a few talks on it; I guess some of it stuck
18:06:34 <vermeille> Axman6: if you want to use Lenses, you have to know that the lib is HUGE, so, think twice before actually using it, if you only need few times
18:07:21 <Axman6> vermeille: I'm well aware of that, it's one of the main reasons I haven't used it much =)
18:07:27 <prinsen_> Again, any way to solve 'Unacceptable argument type in foreign declaration', I have written Storable instances
18:08:02 <solatis> hmmm, ok, another question about monadic operations.. i currently have this in my code:
18:08:04 <solatis> liftIO $ threadDelay 500000
18:08:15 <solatis> would that be the same as _ <- threadDelay 500000 ?
18:08:28 <solatis> or would the latter not actually perform the IO operation?
18:08:32 <HeladoDeBrownie> solatis, if you're lifting IO to IO, then liftIO = id
18:08:36 <srhb> solatis: Only if you're in the IO monad, and in that case it's also identical to threadDelay 500000
18:08:40 <monochrom> prinsen_: do you have actual code posted somewhere? Storable is not a sufficient condition for legal foreign types
18:09:01 <solatis> let me test that :)
18:09:05 <HeladoDeBrownie> solatis, liftIO is only useful if your target type is potentially non-IO but a monad transformer stack over IO
18:09:22 <solatis> yeah, my target is non-IO
18:09:23 <vermeille> HeladoDeBrownie: thank you for your point of view :)
18:09:27 <solatis> i'm in a ZeroMQ monad
18:09:27 <prinsen_> monochrom: well its just a FFI export of a function UserDefined -> UserDefined2
18:09:30 <HeladoDeBrownie> vermeille, no problem
18:09:43 <prinsen_> monochrom: seem so, what is required?
18:09:50 <HeladoDeBrownie> solatis, okay, in that case you need liftIO in order to typecheck, probably
18:09:57 <solatis>    Couldn't match type IO with System.ZMQ4.Monadic.ZMQ z
18:10:17 <solatis> so that means i really need to use ZMQ.liftIO
18:10:51 <solatis> i'm still trying to figure out what the difference between lifting an IO monad and performing / transforming a IO monad operation is
18:11:01 <monochrom> the Haskell 2010 Report has the exact requirement. it's long, but you must eventually read it yourself. for now, examples of allowed are: Int, Double, Int32, Ptr a, newtypes of those
18:11:47 <HeladoDeBrownie> solatis, liftIO is for when you want to embed an IO procedure in a stack whose base is IO; transforming the result is a case for fmap and other related things.
18:12:13 <HeladoDeBrownie> Also (>>=), which part of do expressions desugars to.
18:12:20 <solatis> ok, so lifting IO doesn't actually perform the IO action, it just embeds it into the parent?
18:12:24 <solatis> am I saying that correctly
18:12:25 <solatis> ?
18:12:33 <Axman6> sure
18:12:35 <HeladoDeBrownie> solatis, no, *nothing* actually performs the IO except the runtime system
18:12:45 <prinsen_> monochrom: So the FFI could be Ptr UserDefines -> Ptr UserDefined2
18:12:55 <solatis> yeah all IO is derived from main :: IO
18:13:03 <monochrom> yes, that's legal. but I cannot know whether that fits your task.
18:13:15 <HeladoDeBrownie> solatis, right
18:13:24 <HeladoDeBrownie> IO a, you mean, but yeah
18:13:29 <HeladoDeBrownie> (or any specific a)
18:13:32 <solatis> yeah sorry
18:13:32 <solatis> ok
18:14:06 <solatis> and if I'm inside the Monad.ZMQ monad, and I perform a liftIO $ threadDelay x, it actually "embeds" the threadDelay IO action inside the ZMQ monad?
18:14:18 <HeladoDeBrownie> solatis, yes
18:14:32 <solatis> as in, that's where the name 'lifting' comes from -- you're "lifting" the monadic action to the parent
18:14:43 <HeladoDeBrownie> I don't know if "parent" is the right word, but sure
18:15:24 <solatis> for me "parent" at the moment works :)
18:15:42 <orb__> main :: IO (), isn't it?
18:15:58 <solatis> orb__, it can have a return code, not?
18:16:02 <HeladoDeBrownie> orb__, that's one possible specialization, yeah
18:16:03 <Clint> orb__: only for all practical purposes
18:16:04 <Axman6> I believe main can have tyoe IO a
18:16:08 <orb__> OK.
18:16:12 <Axman6> but it goes nowhere
18:16:14 <prinsen> monochrom: Im exporting a haskell library (TH-generated) to C. Im new to this but I guess what I have to do is to let TH generate .h files with structs and .hsc with the Storable instances for the data types. What will the actuall C signature become for the Ptr version?
18:16:20 <orb__> In practice, yes.  I didn't know about the spec.
18:16:34 <orb__> Axman6, you can call main from main or other functions.
18:16:38 <Axman6> there's specific functions for returning different exit codes
18:16:44 <solatis> hmmm I always thought IO a meant the exit status
18:16:50 <Clint> it doesn't
18:17:10 <orb__> solatis, you need to call a function for setting the exit status.
18:17:17 <orb__> System.exit or something.
18:17:26 <solatis> oh yeah you're right
18:17:31 <orb__> :t exit
18:17:32 <lambdabot> Not in scope: ‘exit’
18:17:42 <solatis> it would make more sense to me if main was defined as IO Int :)
18:17:54 <orb__> solatis, I don't know why they didn't just mandate main :: IO Int.  I guess they didn't want to bake unix into the language.
18:18:02 <zwer> or `main :: [String] -> IO Int'
18:18:02 <solatis> but maybe that's too much my C++ background
18:18:09 <orb__> I think even C doesn't guarantee a return from main to be the exit status?
18:18:19 * HeladoDeBrownie wonders if every platform Haskell runs on has an exit code concept
18:18:29 <monochrom> for all a, Ptr a becomes void *. it should be harmless to change it to your_struct * if it works out.
18:18:31 <orb__> At least as far as I know, you are supposed to call exit in C's main, too.
18:18:51 <solatis> orb__, exit is a shortcut to abort()
18:18:51 <zwer> exit(n) in C is the same as return n; from main
18:18:51 <Axman6> :t exitWith
18:18:52 <lambdabot> Not in scope: ‘exitWith’
18:18:59 <Axman6> @hoogle exitWith
18:19:00 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
18:19:00 <orb__> zwer, main :: Int -> CPtr (CPtr Char) -> IO Int :-P
18:19:18 <solatis> orb__, if i return 1 from main, the program will return exit code 1
18:19:36 <solatis> if I exit (), the program is aborted in the middle of the execution
18:19:38 <orb__> solatis, in practice, or in theory?
18:19:43 <solatis> in practice
18:19:50 <orb__> OK.
18:19:51 <rudi_s> solatis: It is not.
18:20:07 <rudi_s> There is abort(), but that does something completely different. And there's also _exit().
18:20:07 <orb__> Some compilers probably do that.  I'm not sure what the spec says for C.
18:20:30 <rudi_s> orb__: return in main is the same as exit() AFAIK.
18:21:02 <rudi_s> man abort, man 3 exit, man 2 exit, man _exit for details.
18:21:30 <HeladoDeBrownie> exitWith is one of those rare functions that could result in IO Void if it wanted to
18:21:38 <orb__> https://stackoverflow.com/questions/204476/what-should-main-return-in-c-and-c says that for C, only 0, EXIT_SUCCESS and EXIT_FAILURE are defined return values of main.
18:21:43 <zwer> it is. and you can portably return from main (or pass to exit) only 0, EXIT_SUCCESS and EXIT_FAILURE. with first two resulting in the same thing
18:21:48 <orb__> Everything else is undefined behaviour, and might start nethack (or similar).
18:21:55 <solatis> orb__, i can return anything i want
18:22:23 <orb__> solatis, in practice, yes.  But that's undefined behaviour and `might' blow up any time.
18:22:31 <orb__> Or start nethack, or format your hard disk.
18:22:44 <zwer> is it undefined or implementation defined?
18:22:45 <rudi_s> orb__: zwer: That's not quite true. 1 = EXIT_FAILURE for example according the standard.
18:22:59 <orb__> rudi_s, sorry, implementation defined.
18:23:02 <zwer> rudi_s I am pretty sure it isn't
18:23:06 <solatis> heh, this is interesting
18:23:30 <rudi_s> And while we're at it: "The value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE,  or any other value, though only the least significant 8 bits (that is, status & 0377) shall be available  to  a  waiting parent process." (from man 3p exit)
18:24:21 <rudi_s> And "As required by the ISO C standard, using return from main() has the same behavior (other than with respect to language scope issues) as calling exit()  with  the  returned  value."
18:24:52 <solatis> > cat test.c && gcc ./test.c && ./a.out
18:24:53 <lambdabot>  <hint>:1:31: parse error on input ‘./’
18:24:57 <solatis> int main () {  return 2; }
18:25:02 <solatis> now echo $?
18:25:08 <solatis> and voila, status code 2
18:25:24 <monochrom> yes, it's good on linux windows and dos
18:25:38 <solatis> i believe many programs use different exit status codes
18:25:39 <zwer> 7.20.4.3 The exit function in C99, no 1 being mentioned, only 0 EXIT_SUCCESS and EXIT_FAILURE
18:25:45 <orb__> solatis, in practice, yes.
18:25:53 <orb__> solatis, and on Linux.
18:25:57 <monochrom> many programs are designed for only a few OSes
18:26:25 <monochrom> the few OSes that happen to take fairly arbitrary exit codes
18:26:35 <orb__> monochrom, and that's perfectly fine.  We just happen to be pedants here.
18:27:04 <zwer> some OS did something nasty on a certain return value. but I can't remember which OS, or what it did
18:27:21 <solatis> orb__, heck, even bash uses exit status 2 a lot
18:27:23 <orb__> gcc used to start nethack for some implementation defined behaviour for a few versions.
18:27:43 <orb__> solatis, lots of programs uses lots of exit stati.  Like grep, etc.
18:27:50 <orb__> Almost any linux program you can point a stick at.
18:27:52 <solatis> that's what i mean
18:27:59 <orb__> ls does.
18:28:15 <solatis> ah well, exit statuses are a hack anyway
18:28:18 <orb__> But that's implementation defined, and not just C.
18:28:21 <orb__> solatis, why?
18:28:30 <monochrom> actually, why are we talking about C standards here? :)
18:28:34 <solatis> for the same reason errno is a hack
18:28:38 <orb__> Because of main :: IO Int.
18:28:48 <orb__> solatis, sort-of is.  Same thing with pipes.
18:28:59 <monochrom> ah, but main :: IO Int will not pass that Int to exit code.
18:29:05 <orb__> monochrom, indeed.
18:29:14 <orb__> monochrom, but they could have made it that way.
18:29:26 <orb__> And just mandate the type main :: IO Int in the standard.
18:29:26 <solatis> monochrom, no, i suggested that main :: IO Int would have made more sense than IO ()
18:29:28 <monochrom> generally it's main :: IO Whatever_You_Like and it is discarded
18:29:36 <orb__> Or even: main :: [String] -> IO Int
18:29:39 <solatis> and hence the discussion commenced
18:29:43 <monochrom> ok I see
18:30:28 <orb__> It's a good thing they didn't do main :: [String] -> ... actually.
18:30:42 <orb__> Because it would have made it harder to switch that out for a reasonable string type.
18:30:49 <solatis> anyway let's just leave it at that -- C code generally just allows you to do anything you want, and haskell is about the exact opposite of C, for good reasons :)
18:30:52 <orb__> If you baked it in at that low a level.
18:30:56 <vermeille> Where can I find about GHC/RTC's internals?
18:31:38 * solatis just assumes our haskell overlords put great tought into it and have a good rationale this decision
18:31:43 <monochrom> vermeille: there is something under https://ghc.haskell.org/trac/ghc/wiki/Commentary
18:32:29 <vermeille> Thanks monochrom!
18:32:44 <stef1a> why does the first implementation fail but the second work? http://lpaste.net/7719845720445943808 i'm trying to implement map with foldr, and it looks like foldr will only accept an anonymous function. but how does it know where to get the arguments from when passed the lambda, and why does it not know where to get the arguments from when passed the explicit function?
18:33:14 <vermeille> Actually, before diving deep into this documentation, is haskell compiled to native code or to a bytecode with a VM shipped in the executable?
18:33:24 <monochrom> native code
18:33:37 <vermeille> What is the symbol myFun_info in the Elf so?
18:33:44 <vermeille> Where is the actual code?
18:33:49 <monochrom> the RTS provides GC, juggling of threads, utilities, I/O system...
18:35:50 <monochrom> stef1a: mapByFoldr f list = foldr (\x list -> func (f x) list) [] list
18:36:19 <augur> monochrom: func?
18:36:20 <stef1a> monochrom: why do you need a lambda, though?
18:36:36 <stef1a> is a lambda required if you want to make the variables explicit?
18:36:50 <cmtptr> good lord has anyone else gone thought this gauntlet that is chapter 5 of Real World Haskell?
18:37:13 <cmtptr> this feels like haskell noob hazing
18:37:38 <gcganley> cmtptr: what is the chapter about?
18:37:43 <monochrom> ok, how about this, mapByFoldr f list = foldr op [] list  where op x list = func (f x) list
18:37:45 <cmtptr> pretty-printing json
18:37:57 <gcganley> cmtptr: i hated that chapter
18:38:29 <cmtptr> glad to know I'm not alone
18:39:05 <merijn> cmtptr: Actually, the trick they use with "undefined" to stub methods has a much better solution now in GHC 7.8 and later
18:39:20 <cmtptr> yeah?
18:39:43 <merijn> cmtptr: If you write a name starting with a prefix on the right hand side of a function GHC will actually print out a warning telling you the type of that identifier
18:39:53 <merijn> s/prefix/underscore
18:40:04 <merijn> Typing is hard
18:40:07 <stef1a> monochrom: that doesn't answer my question
18:40:10 <WilliamDhalgren> sef1a yes you need the lambda -  where is that x in the nonfunctional version supposed to be coming from anyhow? and func given to foldr needs to have :: a ->  b -> b type. one there's got no arguments, just a saturated fn application
18:40:44 <cmtptr> merijn, by that you mean the _ wildcard, or do you mean to suffix the function name with an underscore?
18:40:44 <stef1a> WilliamDhalgren: but the function accepts arguments and has that type class
18:41:00 <stef1a> WilliamDhalgren: how does it just figure out where the arguments come from if you pass it a lambda, then?
18:41:01 <monochrom> stef1a, I know, it's only a first step towards answering your question. do you agree that the version with "where op x list = ..." is right?
18:41:19 <stef1a> monochrom: i haven't tested it
18:41:34 <fuzzyhorns> whats the most idiomatic way for me to translate filter (!∈ list2) list1 into haskell?
18:41:42 <merijn> cmtptr: I mean "foo :: Int -> Bool; foo x = _bar x" should print out something along the lines "found typed hole _blah :: Int -> Bool"
18:41:52 <merijn> eh
18:41:53 <merijn> _bar
18:42:06 <cmtptr> oh, where it's used
18:42:08 <cmtptr> cool
18:42:08 <monochrom> then I recommend you do. my next step relies on you accepting this first step.
18:43:29 <merijn> cmtptr: The advantage over undefined is that typed holes are an error, so while GHC will typecheck your entire program, it won't generate code, preventing you from accidentally forgetting an undefined somewhere in your code base
18:43:41 <prinsen> Im on arch linux with GHC 7.8.3, I get Missing C library HSrts-ghc7.8.3, how do I install it?
18:44:15 <gcganley> prinsen: is it on hackage?
18:44:28 <merijn> gcganley: No, that looks like the runtime library of GHC
18:44:36 <cmtptr> merijn, then what do you do when you implement that function?  do you go back and remove all the underscores, or leave them?
18:44:43 <merijn> In other words, arch linux packagers broke GHC *again*
18:45:25 <zwer> stef1a are you familiar with the concept of scope? you have no x in scope in the first version. you have elt in scope in the second version (it is the first argument to the anonymous function )
18:45:39 <monochrom> I am not so quick to deal out that judgment. it can also be trying to use dynamic libraries and forgetting a linker option
18:45:47 <merijn> cmtptr: _blah is for things that don't exist at all yet, so if I want to have a function foo, I'd never write "_foo" anywhere, instead I'd write "foo :: {- type here -}; foo = _foo" instead
18:46:14 <cmtptr> ah ha, I get it.  thanks
18:46:15 <gcganley> merijn: they do that a lot dont they...
18:46:23 <stef1a> zwer: okay... i think that makes sense. so since i don't use recursion, my only option in this case if i want to explicitly specify the arguments is to use a lambda?
18:46:36 <prinsen> any solution?
18:46:43 <stef1a> or to use eta reduction on a known function?
18:46:59 <merijn> gcganley: Around 60-70% of "GHC won't install/is broken", etc. questions I see here end up being package maintainers breaking things, so that's generally my first assumption on linux :p
18:47:09 <gcganley> merijn: AUR is horribly littered with shitty packages
18:47:13 <zwer> stef1a no, you can pass a named funtion too, provided it matches the required type. as monochrom's code showed
18:47:26 <prinsen> merijn: Im trying to use FFI to generate a C library, not installing GHC
18:47:28 <gcganley> merijn: and thats why i compile ghc HEAD every morning
18:48:32 <merijn> prinsen: Well, you haven't shown any cabal file, which commands you're using or exact error message, so the only help you can get is speculation
18:49:02 <prinsen> merijn: 2 sec
18:49:40 <prinsen> merijn: http://lpaste.net/112205
18:50:25 <prinsen> merijn: and here is the entire .cabal http://lpaste.net/112206
18:50:36 <merijn> eh
18:50:47 <merijn> Why does extra-libraries list that library...
18:51:02 <merijn> Of course that's not going to work, that doesn't even make sense
18:51:29 <carter> merijn: i can show you the code
18:51:32 <carter> and the type error messages
18:51:33 <johnycage> several functions System.in Win32 can't be used fully. for example findWindow. passing NULL to FindWindow in C means "match anything", and we can't express that with expored funtion because findWindow accepts String and not (Maybe String). who can I complain to?
18:51:48 <johnycage> several functions in System.Win32
18:51:58 <prinsen> merijn: http://www.vex.net/~trebla/haskell/so.xhtml
18:52:22 <monochrom> merijn: it worked for me when ghc 7.6.3 and cabal-install 1.16.
18:52:45 <monochrom> and I authored that article
18:53:09 <monochrom> let me test it against today's versions
18:53:17 <prinsen> monochrom: cool :)
18:53:22 <merijn> monochrom: Last time I tried I didn't need to pass anything on to GHC and it just linked things in as it should, iirc
18:53:59 <merijn> prinsen: Can you try what happens if you just leave extra-libraries out?
18:54:30 <prinsen> merijn: compiling atm, takes some time
18:56:25 <monochrom> merijn, prinsen: still fine with ghc 7.8.3, cabal-install 1.18 (well, it's Haskell Platform).
18:57:03 <monochrom> I am ready to switch side to "libHSrts-ghc7.8.3.so is in a separate AUR package"
18:57:42 <monochrom> speaking of which, I should really get a cabal-install 1.20 just in case
19:11:03 <tabemann> why am I writing object-oriented code in Haskell?
19:12:30 <johnycage> how are you doing that?
19:13:02 <merijn> johnycage: Records of functions is the usual way
19:13:11 <tabemann> each object is a thread, which receives messages via a TQueue, sends responses via TMVars, and publishes events via TChans or TQueues
19:13:19 <merijn> Cale had a nice article, but my link for it is dead
19:13:34 <merijn> tabemann: Sounds more actor model/CSP than OO
19:13:34 <tabemann> it's object-oriented in the way that Erlang is object-oriented
19:13:46 <merijn> tabemann: So, not at all? :)
19:13:51 <johnycage> merijn what about inheritance?
19:13:58 <merijn> johnycage: No inheritance
19:14:02 <merijn> johnycage: And that's a feature
19:14:12 <johnycage> retyping all the fields is a feature?
19:14:43 <merijn> I'm more and more convinced that inheritance is one of the dumbest ideas in programming history :)
19:14:51 <tabemann> merijn: it's OO if one treats messages as messages, rather than as function calls
19:14:53 <monochrom> tabemann: do you really mind? :)
19:14:54 <merijn> johnycage: Use composition if you have things that share fields
19:14:57 <johnycage> you must like boilerplate
19:15:17 <johnycage> composition of what?
19:15:18 <merijn> johnycage: I hate boilerplate, but inheritance is not a good technique to eliminate boiler plate
19:15:28 <tabemann> my team lead at work really likes OO, and according to him inheritance isn't even part of OO
19:15:53 <merijn> johnycage: https://en.wikipedia.org/wiki/Object_composition
19:15:55 <johnycage> everyone has his own definition of OO
19:16:09 <tabemann> Java would have been a better language if they never included class-inheritance
19:16:30 <merijn> tabemann: Word.
19:16:47 <johnycage> merijn that gets ugly fast. you have to nest all the common fields
19:17:04 <tabemann> class-inheritance breaks modularity
19:17:04 <monochrom> tabemann: when writing concurrency, I like both the channel story (what you're doing) and async.
19:17:28 <merijn> johnycage: Good sign that you need to break things down more
19:17:52 <tabemann> also class-inheritance results in fragile base classes
19:19:18 <Jookia> tabemann: it's fine
19:22:03 <tabemann> monochrom: in my case I'm using really fine-grained concurrency, because Haskell threads are really cheap, and if there's something that I can represent as a continuous process or a blocking process, I'm better off putting it in a thread rather than figuring out how to put it in sequential code
19:26:47 * tabemann really likes that GHC STM has retry and orElse, which makes a lot of things more natural than if done with a) traditional multithreaded techniques b) actors c) callbacks or d) select
19:27:07 <monochrom> yes :)
19:29:41 <fuzzyhorns> http://www.haskell.org/pipermail/beginners/2011-May/007039.html i kinda liked this powerpoint
19:32:44 * hackagebot shadowsocks 1.20141007 - A fast tunnel proxy that help you get through firewalls  http://hackage.haskell.org/package/shadowsocks-1.20141007 (rnons)
19:39:20 <lilytastic> Anyone available to help a noob install haskell on OSX?
19:40:53 <merijn> lilytastic: Download the platform
19:41:09 <merijn> Avoid homebrew and macports, they're poorly maintained
19:41:10 <lilytastic> I have the package-y thing, my problem right now is telling emacs where it is.
19:41:21 <lilytastic> i’m following the instructions here: https://github.com/yaxu/Tidal/blob/master/doc/install-osx.md
19:41:26 <merijn> ah, I dunno about emacs :)
19:43:29 <prinsen> merijn: When I link with the .so from C, I get a bunch of /home/fabian/.cabal/lib/x86_64-linux-ghc-7.8.3/connection-0.2.3/libHSconnection-0.2.3-ghc7.8.3.so: undefined reference to `stg_newMVarzh' etc.
19:46:01 <merijn> prinsen: Sounds like a job for "ldd"
19:46:03 <monochrom> stg_newMVarzh is part of the RTS. this is why I must explicitly request linking the RTS, GHC does not do it automatically.
19:46:40 <merijn> Although monochrom is probably more right than I am :)
19:47:06 <prinsen> monochrom: trying to add -lHSrts-ghc7.8.3 as a GHC-option now
19:47:35 <joe9> http://codepad.org/nIPkl7xH Any suggestions on how to fix this, please?
19:48:06 <joe9> I am trying to covert a datetime string in UTC timezone to dateTime in a record.
19:48:12 <monochrom> on the bright side, you have choice of: libHSrts-ghc7.8.3.so, libHSrts_thr-ghc7.8.3.so, libHSrts_debug-ghc7.8.3.so, libHSrts_thr_debug-ghc7.8.3.so ...
19:48:44 <joe9> btw, any suggestions on what is a good data type to represent DateTime in Haskell? LocalTime?
19:49:02 <joe9> no need of seconds, it is just upto minutes.
19:49:38 <merijn> joe9: You appear to have multiple different versions of time imported
19:50:20 <monochrom> yes, it's a bad bad sign when GHC error messages mention package versions
19:50:45 <monochrom> you're passing one version's data to another version.
19:50:46 <joe9> merijn: Am I better off using Integer to represent seconds for the dateTime field?
19:51:36 <joe9> monochrom: I am just trying to convert the date time string to something I can store as a field in a haskell record.
19:51:45 <prinsen> monochrom: even though passing -lHSrts-ghc7.8.3 as a option to GHC, i get undefined references
19:51:52 <joe9> so, I can use it for comparisions or filter's later.
19:51:55 <Hijiri> try converting to UTCTime?
19:52:00 <Hijiri> What's the format of the string?
19:52:45 * hackagebot language-c-quote 0.10.1.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.1.2 (GeoffreyMainland)
19:52:47 <Hijiri> there's http://hackage.haskell.org/package/iso8601-time-0.1.2/docs/Data-Time-ISO8601.html if it's in iso8601 format
19:53:05 <joe9> Hijiri: "Saturday 15 August 1992 15:00"
19:53:13 <joe9> let l = strptime "%A %d %B %Y %R" "Saturday 15 August 1992 15:00"
19:53:26 <joe9> I probably am better off using parseTime instead.
19:53:32 <joe9> and get it to UTCTime
19:55:03 <jayunit100_4g> im noticing that a function with pattern matching _ _ [] fails due to a parse error on input '_' …. any thoughts why?
19:55:07 <jayunit100_4g> splitWith _ _ [] = [curr] -- that fails
19:55:37 <dmwit> joe9: What people are telling you is that your use of the library is not obviously wrong; that error message points to an installation problem, not a code problem.
19:56:03 <dmwit> joe9: I've got to run, but look in ghc-pkg list time. You might get surprised by the result.
19:56:09 <dmwit> joe9: See also SICP.
19:56:11 <dmwit> ?where SICP
19:56:11 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
19:56:16 <dmwit> the last one there
19:56:51 <dmwit> jayunit100_4g: Almost certainyl a problem with the surrounding code. Post a full example, e.g. to lpaste.net or whatever the currently in-vogue paste site is.
19:58:47 <adarc> hi, quick q.. im using the kmeans library from hackage (Data.KMeans).. anyone know why this function never returns? kmeans 4 [[1.0,2.0,3.0],[5.0,3.0,4.0],[9.0,100.0,1.0,1.0],[1.0],[9.0],[3.0],[100.0],[4.0],[2.5],[1.0,3.0,101.0]]
19:58:49 <joe9> dmwit: thanks.
19:58:59 <prinsen> monochrom: do you know how you installed the C-library?
19:59:08 <prinsen> the dev-package for GHC?
19:59:15 <jayunit100_4g> dmwit: okay here you go https://gist.github.com/bf51ac003c6918b485ec
19:59:15 <orb__> adarc, is that the simplest example exhibiting this behaviour?
19:59:31 <adarc> i'm just trying to experiment with it. Many of my tests end up running infinite.
19:59:33 <monochrom> I use either Haskell Platform's binary or GHC website's binary. they are both complete.
19:59:59 <monochrom> by Haskell Platform's binary I also mean from Haskell Platform's website.
20:00:21 <jayunit100_4g> i even commented out the function signature just to be sure that wasnt tripping it uo
20:00:22 <jayunit100_4g> up
20:00:25 <adarc> hey orb__ there's several more.. i'm not sure tbh
20:00:38 <merijn> jayunit100_4g: You didn't paste the error
20:00:39 <monochrom> well, why "or"? because I guess it's actually "and". I installed both, under two different directories.
20:01:15 <jayunit100_4g> thanks --- okay updated, dmwit 
20:01:58 <monochrom> replace l:rem by (l:rem). you need the parentheses.
20:02:24 <merijn> monochrom: Eagle eyes :)
20:02:28 <jayunit100_4g> looks.......
20:05:14 <jayunit100_4g> monochrom: thanks ! you were right :) definetly eagle eyes !
20:05:52 <monochrom> you're welcome
20:19:36 <joe9> Is there a concatMapM?
20:21:00 <Hijiri> what would it do?
20:21:16 <joe9>  i could do : mapM .. [] >>= return . concat
20:21:33 <joe9> Hijiri: that's ok. do not worry about it.
20:21:49 <Hijiri> concat is specific to list, I don't think concatMapM would make sense
20:22:14 <merijn> :t \f -> sequence . concatMap f
20:22:16 <lambdabot> Monad m => (a1 -> [m a]) -> [a1] -> m [a]
20:22:36 <Hijiri> oh, ok
20:22:44 <merijn> Or something along those lines, I guess?
20:22:56 <nitrix> Songs are so not creative sometimes. I could probably write this song in 6~9 lines of haskell >_>
20:23:02 <lilytastic> So I’m trying to run tidal, and I’m getting a lot of “Not in scope: ‘dirtStream’”
20:23:10 <lilytastic> Anyone know what that is? :c
20:23:35 <lilytastic> er, what it’s about. i’m guessing it’s Dirt.
20:26:59 <zwer> joe9 `>>= return . f' is the same as `liftM f', or `fmap f' (the latter uses Functor constraint)
20:32:51 <Denommus> Why is reactive bananas recommended for GUI, and netwire for games?
20:33:05 <Denommus> What are the tradeoffs?
20:40:52 <dfeuer> Denommus, it's a little slow tonight. Don't get discouraged. It'll pick up at some point.
20:41:14 <Porygon-Z> I want to know that too now
20:41:22 <Denommus> dfeuer: I'm too excited to be discouraged :)
20:41:47 <dfeuer> Yay!
20:42:13 <Denommus> It seems that reactive banana was designed to have binds with an arbitrary GUI toolkit
20:42:23 * dfeuer is excited to (sometime soon) learn to use GHCJS.
20:42:30 <Denommus> Integrating it with Gtk2Hs takes 50 lines of code
20:43:54 <dfeuer> o.O
20:44:12 <merijn> Denommus: reactive-banana is designed to interface with existing systems that expect callbacks
20:44:15 <merijn> Denommus: netwire is not
20:44:38 <merijn> Denommus: Therefore, since a lot of C GUI frameworks use callbacks, the design tends to accommodate those better
20:45:01 <Denommus> merijn: ah, that makes sense
20:45:17 <merijn> Denommus: So, yes, reactive-banana was indeed designed to bind with arbitrary GUI toolkits
20:45:26 <merijn> And other similar frameworks
20:46:17 <monochrom> so, reactive banana is also optimal for javascript? :)
20:47:39 <Denommus> monochrom: heh, does ghcjs has a good set of bindings?
20:47:49 <monochrom> I don't know
20:48:06 <Denommus> If so, it shall probably work with it
20:48:15 <Denommus> Which... gives me an idea
20:49:06 <jfischoff> edwardk: I have some questions about upgrading from langragian from 3.4 to 4.2.1.
20:49:14 <jfischoff> uh
20:49:21 <jfischoff> ad 3.4 to ad 4.2.1
21:08:55 <arboris> is there a way in haskell to define given an applicative functor f, a functor f*, which mathematically would be the (co-)limit of the diagram a -> f a -> f^2 a -> ..
21:09:47 <arboris> for lists it would be lists that contain a but also possibly lists of a and so on
21:12:13 <arboris> i think essentially what I want is a list type on the kind level
21:12:29 <arboris> if i am not mistaken
21:12:43 <bms1>  data Ap f a = Nil a | Cons (f (Ap f a))
21:12:59 <bms1> I often call that type a Stream, and have f = IO
21:13:18 <bms1> Nevermind about the Stream remark
21:14:06 <arboris> bms: oh ok that is kind of cool
21:14:31 <arboris> much easier than i thought
21:14:42 <bms1> ( I often use data Stream m a = Nil | Cons a (f (Steam f a)) )
21:15:27 <arboris> bms1, that is probably isomorphic to the colimit of 1 -> a -> f a -> ...
21:15:43 <arboris> in some sense
21:16:34 <bms1> does "colimit" mean like a greatest fix point kind of thing?
21:16:58 <arboris> bms1: yes I believe so, you can define it for any diagram in a category\
21:17:04 <arboris> it does not need to exist
21:17:23 <arboris> but in the case above it corresponds to the greatest fixed point
21:18:59 <arboris> i only really have experience with the notion in mathematics, but i believe in the context of type theory you can think of it as the type that accomodates all the types in the diagram and for each arrow there is some predefined mapping
21:19:11 <arboris> vaguely speaking
21:20:09 <bms1> ah okay
21:20:39 <arboris> actually the unfortunately the arrows in the diagram are implicit in haskell, they have to be there thanks to a "free theorem"
21:21:06 <arboris> which is why i've asked about applicative functors
21:23:52 <arboris> the laws for an applicative functor fix the maps in the diagram 1 -> a -> f a -> .. and trivially satisfy the requirements for the existence of a colimit
21:24:11 <prinsen> When compiling hsc2sh-generated code, how do I pass include dirs to gcc?
21:32:51 * hackagebot HaskellNet 0.4 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4 (JonathanDaugherty)
21:32:53 * hackagebot HaskellNet-SSL 0.2.5 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.5 (DanielWright)
21:42:51 * hackagebot HaskellNet-SSL 0.2.5.1 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.5.1 (DanielWright)
21:48:31 <prinsen> If I want to peek an array from a ptr, this does not work: url <- #{peek YQLSettings, yqlSettingsUrl} ptr as there is no Storable String instance
21:48:50 <prinsen> is there any other macro/solution?
21:56:28 <monochrom> peekArray and peekArray0 from Foreign.Marshal.Array
21:58:59 <prinsen> monochrom: but they require that the Ptr is to the same type
21:59:30 <prinsen> in the instance of Storable (Type with String field) you dont know the offset to the field
22:01:05 <prinsen> monochrom: oh i can use the macro ptr
22:24:50 <xlujuiax> Hi
22:26:12 <xlujuiax> Anyone have tutorial of Leksah?
22:27:38 <xlujuiax> Anyone have tutorial of Leksah?
22:28:20 <xlujuiax> Anyone have tutorial of Leksah?
22:29:33 <xlujuiax> Hello?
22:29:41 <simpson> Hi.
22:29:47 <xlujuiax> Simpson
22:29:55 <xlujuiax> Can you help me
22:29:56 <xlujuiax> ?
22:30:07 <simpson> Nope! I don't know what Leksah is.
22:30:30 <simpson> I have a strong suspicion that "leksah programming tutorial" might be useful to Google, though.
22:31:02 <xlujuiax> I need to install this in my Windows 7
22:32:04 <xlujuiax> ok I tried to search more in google :)
22:35:53 <Lutin`> Anyone familiar with permutation groups and Strong Generating Sets?
22:37:32 <gamegoblin> Does "let xs = 0:1:xs" create a circular linked list, or an infinite list?
22:38:28 <simpson> > let xs = 0:1:xs in xs -- what's the difference, exactly?
22:38:30 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
22:38:45 <kadoban> gamegoblin: both
22:39:28 <gamegoblin> I was wondering about memory usage
22:39:39 <gamegoblin> constant memory vs unbounded
22:40:08 <johnw> it probably uses about 12-20 bytes of memory, would be my guess
22:40:08 <Lutin`> Yes, that expression 'ties the knot' so to speak
22:40:13 <Lutin`> http://www.haskell.org/haskellwiki/Tying_the_Knot
22:40:22 <gamegoblin> Just wanted to make sure it was constant, don’t actually care how many
22:40:54 <gamegoblin> I’d reckon it uses 8 bytes per node, then maybe some overhead, no idea
22:41:19 <gamegoblin> assuming 32 bit ints/pointers
22:42:59 <jle`> yeah, the bottom cons cell points to the original xs, so the pointers loop around.  in ghc, at least, i think.
22:43:32 <simpson> But that doesn't say much about what kind of garbage is generated when handling the list.
22:43:55 <simpson> > let xs = 0:1:xs in take 12 xs -- the spine of the list counts too
22:43:56 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1]
22:44:04 <jle`> ah, yeah
23:11:04 <Kludgy_> Hmm anyone have thoughts on this? Given a function 'run = do { x <- ix ; f a b } :: Monad m => m ()', I can *almost* do 'run = liftM f ix' except that 'f :: Monad m => a -> m ()' is not the required 'a -> ()'. Is there a popular operator for this situation?
23:11:37 <Kludgy_> Wait... let me hoogle
23:11:57 <merijn> Kludgy_: join?
23:12:00 <merijn> :t join
23:12:01 <lambdabot> Monad m => m (m a) -> m a
23:13:03 <merijn> Kludgy_: Also, your original has "f a b" and you're asking about "liftM f ix", those arities don't mix
23:14:10 <Kludgy_> merijn: Apologies I pared down code and didn't test it. 'f a b' should simply be 'f x'. The actual code operates on a binary function.
23:14:39 <jle`> that sounds like bind
23:14:56 <jle`> ix >>= f
23:14:57 <jle`> f =<< ix
23:15:06 <Kludgy_> jle`: yea for a unary function, but what's the extension for a binary function?
23:15:23 <Kludgy_> (feel like I'm dancing around an obvious answer)
23:15:24 <jle`> can you state it in types?
23:15:40 <jle`> (a -> b -> m c) -> (m a -> m b -> m c) ?
23:16:04 <jle`> bind being (a -> m b) -> (m a -> m b)
23:16:09 <Kludgy_> jle`: Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
23:16:15 <jle`> ah, so the first one
23:16:35 <jle`> in this case the typical way is just to use do notation i think
23:16:40 <merijn> Kludgy_: liftM2 + join
23:16:40 <jle`> you can use liftA2 and join, but
23:16:54 <jle`> this is a situatoin where i think do notation excels in what it was meant to do
23:16:56 <jle`> it was meant for
23:17:17 <Kludgy_> jle`: Right. That's fair.
23:17:30 <merijn> or: "join $ f <$> a <*> b <*> c" which scales up to an arbitrary number of parameters
23:17:57 <merijn> maybe it needs parens instead of $, depends on fixity
23:18:20 <Kludgy_> merijn: Oh you just did the work for me :) I was just going to say I was going to try doing it with join. But that is the moral generalization I'm looking for I think.
23:22:00 <Kludgy_> merijn: fixity is fine .. thanks both
23:23:14 <jle`> np
23:50:15 <adas> could someone please tell me what level of competency does one need to have to get a haskell job? I don't consider myself a beginner. Definitely not advanced like some of the haskell/functional gods out there (kmett, et.al). I'm comfortable with haskell, yet i always doubt if my knowledge is enough to get a haskell job..sry if it sounds ranty
23:52:18 <Qfwfq> adas: A useful metric can be drawn from applying for some.
23:54:23 <adas> Qfwfq: yes. I think I should. Been contemplating that lately.
23:55:22 <adas> The more I think about it, the more I realize, its not just about haskell .. its about the being a good overall coder
23:56:28 <Qfwfq> Self-applying the Python paradox?
23:56:40 <adas> Qfwfq: ?
23:57:08 <Qfwfq> To qualify as a good programmer, you think you have to be decent at Haskell?
23:57:36 <kazagistar> apparently, one of the selling points people like to mention is that your level of competency with haskell can be 0, and you can still do pretty well with a bit of training
23:59:47 <adas> Qfwfq: thats not what I meant. In fact, I meant the contrary. I meant that being good with coding fundamentals is more important. The mindset is more important.
