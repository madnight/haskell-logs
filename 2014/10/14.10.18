00:01:20 <dramforever> ddellacosta: I just noticed that ghc sometimes optimizes Prelude.lookup
00:35:26 * hackagebot template 0.2.0.10 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.10 (JohanTibell)
00:35:58 <chaosmasttter> hi, I have a lens question: Can I use a Pretext to build traversel from it?
00:44:12 <AndroidShoutapop> Hi guys.
00:56:38 <ReinH> chaosmasttter: might try #haskell-lens as well
01:10:30 * hackagebot fcd 1.0.0.0 - A faster way to navigate directories using the command line.  http://hackage.haskell.org/package/fcd-1.0.0.0 (Neki)
01:15:26 <lpaste> xterm pasted “Maintaining a list of todos” at http://lpaste.net/112827
01:15:35 <xterm> Good morning, hope everyone's having a great day; I've been reading up on haskell for so long and I enjoy it quite a lot. I've just today decided to actually 'write' some code but I'm just stumped on how to proceed. Please do bare in mind this is my first go and I'm not looking to be spoon fed, just any advice would be appreciated: http://lpaste.net/112827
01:16:47 <kvanb> xterm: so, what you can do
01:16:48 <AndroidShoutapop> Hey guys, who here has tried Hitchhiker's guide to haskell, do you recommend it for a total beginer, or not? Since I immediately got so lost, despite reading everything, as the first chapter had said.
01:17:01 <kvanb> is put the "Add a todo:" part in a function and call it recursively
01:17:20 <AndroidShoutapop> s/tried/read/
01:17:31 <kvanb> xterm: someone more experienced might use a State monad for this
01:18:53 <kvanb> > runState 0 $ do { modify (+1); modify (+2); modify (+3); return 99 }
01:18:59 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
01:18:59 <lambdabot>    arising from a use of ‘M670153563931756686810162.show_M6701535639317566868...
01:18:59 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
01:18:59 <lambdabot>  Note: there are several potential instances:
01:18:59 <lambdabot>    instance [safe] GHC.Show.Show a =>
01:20:28 <xterm> kvanb: what would you recommend for someone who just started writing haskell?
01:20:53 <kvanb> make a function which takes a list of todos, prompts the user for a todo, then returns the new list of todos
01:21:05 <kvanb> and then write a function that calls it each time with the new list it returns
01:21:12 <Hijiri> > runState (modify (+1) >> modify (+2) >> modify (+3) >> return 99 ) 0
01:21:16 <lambdabot>  (99,6)
01:21:24 <kvanb> Hijiri: ah, been writing too much JS this week
01:21:38 <AndroidShoutapop> Guys, what do you call the `<-' operator?
01:21:38 <Hijiri> JS has a runState with flipped args?
01:21:57 <xterm> kvanb: Got it, thanks. Any feedback on the remaining functions?
01:21:59 <Hijiri> I think people talk about <- binding
01:22:00 <kvanb> doh, I thought I had composed the do { } wrong
01:22:04 <kvanb> xterm: yeah
01:22:10 <Hijiri> It's just sugar for >>= \varname anyway
01:22:14 <kvanb> addTodo todo todos = todo : todos
01:22:18 <kvanb> or, addTodo = (:)
01:22:30 <xterm> oh right!
01:22:37 <kvanb> similar thing for removeTodo
01:22:40 <kvanb> theres a list function for that
01:24:05 <sivteck> AndroidShoutapop, http://www.haskell.org/haskellwiki/Pronunciation
01:24:14 <AndroidShoutapop> Hijiri: I see. It's pretty much the first thing introduced on "Hitchiker's guide to haskell" and I was so lost.
01:24:34 <kvanb> xterm: also, an addTodo/removeTodo interface is very stateful/imperative-feeling
01:25:19 <kvanb> perhaps if a Todo was a data type it would make more sense
01:25:43 <kvanb> otherwise it'd be pretty normal to just let the user use the regular list functions
01:32:19 <xterm> kvanb: honestly, I just picked the exercise out of the blue to get my hands dirty with haskell; I'm pretty sure I can omit add and remove (delete in Data.List?) and just deal with that in main.
01:33:03 <kvanb> perhaps a list is not the kind of structure you want
01:33:21 <kvanb> for some fun, play with one of these
01:33:22 <kvanb> http://hackage.haskell.org/package/containers-0.3.0.0
01:33:41 <kvanb> so, to get this working,
01:33:46 <kvanb> $ cabal install containers
01:34:16 <xterm> right thanks.
01:34:57 <kvanb> @where lyah
01:34:57 <lambdabot> http://www.learnyouahaskell.com/
01:35:03 <kvanb> xterm: this is good ^
01:35:24 <xterm> I'm on that
01:35:33 <xterm> (I'm *only* on that hehe)
01:36:10 <xterm> I appreciate the assistance, I know these questions are rudimentary and are probably thrown here on a day to day basis.
01:51:29 <trap_exit> anyone have a recommendation for a usb desktop lamp?
01:51:38 <trap_exit> find it hard to find a light that is good for looking at paper and screen at the same time
02:01:51 <zomg> I just have a big desk lamp, seems to work for me as long as I don't shine the light to the monitor
02:02:10 <jTT_> hi, I am a beginner, so bear with me please. I hve written some small modules that I successfully installed with cabal install -j. In another module I would like to reuse some of this. Can I import those previous modules from other folders or do i have to copy them to my current folder?
02:03:08 <ulllla> jTT_: cabal sandbox has an add-source action, maybe this helps you
02:03:20 <jTT_> ah cool, i will try
02:06:59 <dcoutts_> jTT_: or the classic way is you cabal install one library, and then use it in another
02:07:15 <dcoutts_> using it in the other is just a matter of using 'import'
02:09:27 <dramforever> How to upgrade base?
02:09:48 <dramforever> I want the new base-4.7.0.1
02:10:20 <Cale> dramforever: Get a newer GHC
02:10:36 <dramforever> Cale: so I cannot upgrade base with cabal?
02:10:40 <Cale> dramforever: The base package is tied to your GHC version
02:10:44 <dramforever> well, oh
02:12:10 <dramforever> Maybe I'll wait for fedora to ship with haskell-platform-2014
02:22:49 <jle`> are you limited from actaully just installing the newest ghc?
02:23:01 <jle`> the platform doesn't add much in fedora, i think
02:30:14 <jTT__> :t intercalate “ “ $ curs $.// content
02:30:15 <lambdabot> lexical error at character '\8220'
03:04:42 <nadirs> Hi, while I was trying to figure out the State Monad I wrote an Applicative instance too, but I can't tell if it's correct, according to the Applicative laws
03:05:19 <lpaste> nadirs pasted “EmuState” at http://lpaste.net/112828
03:06:19 <nadirs> specifically, I'm not sure about which state to use when, since I end up having two (s' and s'')
03:06:42 <nadirs> (actually there are three: s, s' and s'')
03:11:40 <sudeep> What is the way to reverse the integer list in Haskell?
03:12:41 <sudeep> input [2,45,6,6] output [6,6,45,2]
03:12:53 <mr-> sudeep: most people would just use "reverse" :-)
03:12:56 <mauke> SAQ
03:13:04 <mauke> (self-answering question)
03:13:11 <sudeep> and using own function
03:13:24 <mauke> is this homework?
03:13:32 <mauke> like, "write your own reverse function"?
03:15:30 <sudeep> no homework i am learning Haskell self. they don't teach it in my college
03:16:20 <mauke> ok, so what have you tried so far?
03:18:21 <sudeep> i am learnign LYAH
03:18:29 <sudeep> and trying some exercise
03:19:25 <mauke> yeah, but for the reverse function, I mean
03:19:38 <mauke> I could just show you the source code of Data.List.reverse, but that would be boring
03:21:54 <sudeep> it would be great if you could show me
03:23:04 <nadirs> sudeep: of course you're free to do this anyway how want but wouldn't it be more constructive if we tried to figure this out?
03:23:14 <mauke> ok, one way you could do this is by using an accumulator
03:23:46 <sudeep> oh
03:24:14 <mauke> my_reverse xs = work [] xs where work ...
03:25:01 <sudeep> i am from imperative programming background
03:25:36 <nadirs> sudeep: and who doesn't ;) But jokes apart, let's first see how is the list built
03:25:47 <sudeep> oh ok
03:26:03 <mauke> how would you do it in an imperative language?
03:26:17 <sudeep> it is even difficult and little confusing printing fibonacci series here
03:26:57 <sudeep> like in python iterating over the list and appending it to temp list and assiging it to original list,,, simple algorithm
03:27:15 <nadirs> data [] a = a : [] a | []
03:27:22 <nadirs> does this make sense?
03:27:44 <mauke> sudeep: in haskell you'd do it the same way, just without assigning to the original list
03:27:50 <mauke> you just return a new list
03:28:12 <sudeep> oh i understand that but the way it works i don't
03:28:16 <nadirs> you either have "an element attached to the rest of the list" or you have just "the end of a list"
03:28:41 <nadirs> to work with lists you have to construct/deconstruct them one element at the time
03:28:44 <mauke> do you know how to compute the length of a list?
03:28:51 <mauke> that's a bit easier, I think
03:29:02 <sudeep> what does | pipe does in haskell
03:29:20 <nadirs> mauke: you've definitely taken a better road to teach this :)
03:29:29 <mauke> depends on the context
03:29:29 <sudeep> yes the length will do it
03:29:40 <mauke> in patterns, | starts a guard
03:29:49 <mauke> which is an arbitrary condition
03:29:49 <nadirs> sudeep: in my example that's a way to define a data type that has more than one constructor
03:29:49 <sudeep> oh
03:29:55 <sudeep> yes i remember the gaurds
03:30:02 * marvin-hh wonders how much money using the word list for something which is really called a vector has cost.
03:30:05 <mauke> yeah, in data it separates constructors
03:30:16 <mauke> and in class definitions it introduces fundeps
03:30:28 <mauke> it also appears in list comprehensions
03:30:55 <mauke> sudeep: I don't understand "will do it"
03:31:11 <sudeep> length [4,5,6,7,8,3]
03:31:17 <sudeep> will return 6
03:31:23 <shiona> @hoogle (a -> Bool) -> (a -> a) -> a -> a
03:31:38 <lambdabot> Plugin `hoogle' failed with: <<timeout>>
03:31:50 <marvin-hh> sudeep: you can also implement you 'simple solution' in Haskell.
03:31:59 <marvin-hh> sudeep: your*
03:32:03 <sudeep> yes
03:32:25 <marvin-hh> sudeep: it is possible to write code using IORefs or STRefs.
03:32:41 <marvin-hh> sudeep: this goes pretty much against everything which Haskell developers think is a good idea, but you can.
03:32:47 <marvin-hh> sudeep: and the algorithm will be the same.
03:32:49 <mauke> sudeep: ok, but do you know how to write your own "length"?
03:33:12 <sudeep> yes
03:33:17 <mauke> show me
03:33:25 * mauke is now known as morpheus
03:33:53 <nadirs> (mauke: ha)
03:34:07 <sudeep> length [] = 0
03:34:39 <shiona> is there some name for \p f x -> if p x then f x else x
03:34:42 <sudeep> length (x:xs) = 1 + length xs
03:35:01 <sudeep> recursive style
03:35:38 <sudeep> passing reducing one element over the same function and when the list is empty it returns 0 and so on
03:35:58 <mauke> sudeep: nice
03:36:44 <sudeep> thanks but the recursive is the concept from python :) so it is easy to understand here, i came to know that recursion is very important in Haskell
03:36:57 <mauke> so, for reverse it would look like this:
03:37:26 <mauke> my_reverse xs = work [] xs where work acc [] = acc; work acc (x : xs) = work (x : acc) xs
03:37:45 <mauke> again we iterate over xs one element at a time
03:38:00 <sudeep> what is acc
03:38:02 <mauke> but we prepend each x to acc (the accumulator list)
03:38:15 <sudeep> mauke thanks
03:38:24 <mauke> acc starts out empty (Work [] xs)
03:38:51 <sudeep> so it is like let work = []
03:39:10 <mauke> no, work is a function (with two parameters)
03:39:55 <sudeep> what is accumulator
03:40:24 <nadirs> mauke: maybe using pattern matching on the top level like sudeep did with length might help?
03:40:47 <nadirs> reverse [] = <put base case here>
03:40:54 <mauke> the name comes from http://en.wikipedia.org/wiki/Accumulator_(computing)
03:41:08 <nadirs> reverse (x:xs) = <put recursive step here>
03:41:11 <mauke> basically, a variable that stores (accumulates) intermediate results
03:41:20 <mauke> nadirs: that's what I did in work
03:41:28 <mauke> except I need an accumulator for this algorithm
03:41:32 <zwer> nadirs that will be inefficient, you have to use ++
03:41:59 <mauke> ooh, you mean the super naive one
03:42:08 <nadirs> zwer: of course, I'd use a fold too, but I think we're trying to make small steps here :)
03:42:15 <mauke> reverse [] = []; reverse (x : xs) = reverse xs ++ [x]
03:42:18 <pjdelport> sudeep: Imagine you're trying to reverse a stack of plates. One way to do that is to make *two* stacks of plates: for every plate, you move the top plate from the first stack to the second stack. And when you're done, the second stack is the reverse of the first stack. :)
03:42:34 <mauke> but that's horribly inefficient
03:42:57 <nadirs> mauke: first make it work, then make it fast
03:43:10 <pjdelport> sudeep: Sorry, a message from me got lost there: i meant to say that i'd like to offer the above as a physical analogy.
03:43:27 <mauke> accumulator version in perl: my @acc; for my $x (@xs) { unshift @acc, $x; } return @acc
03:43:35 <sudeep> Thank you all for the help
03:43:39 <sudeep> i understand
03:43:39 <mauke> it maps relatively closely to imperative code
03:44:39 <pjdelport> sudeep: At this point i'd like to offer a physical analogy.
03:45:39 <sudeep> pjdelport thanks
03:46:13 <sudeep> so guys any of you want to share the knowledge via voice chat :) it would be great to speak with you guys
03:48:14 <sudeep> I have two functions in Haskell lets say reverse and add 3 to all the list how can i pass the list and get the answer after applying two functions, how the flow will work
03:48:49 <mauke> > reverse (map (+ 3) [2, 0, 11])
03:48:52 <lambdabot>  [14,3,5]
03:49:25 <sudeep> i am via custom function
03:49:45 <mauke> still like that
03:50:04 <mauke> > let customFunction xs = reverse (map (+ 3) xs) in customFunction [2, 0, 11]
03:50:06 <lambdabot>  [14,3,5]
03:50:26 <sudeep> addThree(reverse(parameter)) in python like
03:50:45 <ulllla> I have rule :: Parser Rule rule = startRule <|> otherRule. How would i parse a bytestring like "rule1\nrule2..." and get a list of all letters in all rules so that rule becomes sth. like: rule :: Parser ([Rule], [Letter])?
03:50:51 <mauke> addThree (reverse parameter)
03:51:16 <mauke> or reverse (addThree parameter); same thing :-)
03:52:03 <ClaudiusMaximus> @free reverse
03:52:04 <lambdabot> $map f . reverse = reverse . $map f
03:52:28 <sudeep> mauke oh i understand
03:52:29 <sudeep> thanks
03:55:47 * hackagebot JuicyPixels-util 0.2 - Convert JuicyPixel images into RGBA format, flip, trim and so on  http://hackage.haskell.org/package/JuicyPixels-util-0.2 (FumiakiKinoshita)
04:00:35 <wz1000> What does @free do?
04:00:54 <d3lxa> anyone knows how to get hour/minutes/seconds from a DiffTime (from a UTCTime) please?
04:01:10 <nadirs> ulllla: how does Rule become ([Rule], [Letter])? Is the first elem in the tuple a singleton list? Or do you mean the parser then must parse many "Rule"s?
04:01:28 <Cale> wz1000: Constructs the free theorem for a type
04:01:45 <Cale> @free map :: (a -> b) -> [a] -> [b]
04:01:45 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
04:02:10 <ulllla> nadirs: yes, i want to make a parser for a single rule a parser for a list of rules with some state
04:02:11 <d3lxa> seems I finally found out timeToTimeOfDay does the job :) sorry for the noise
04:02:12 <Cale> @free foldr :: (a -> b -> b) -> b -> [a] -> b
04:02:12 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
04:02:12 <augur> @free [a]
04:02:12 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
04:02:27 <augur> @free [a]
04:02:27 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
04:02:33 <augur> wow.. what did i do D:
04:02:42 <Cale> I guess it doesn't handle that
04:02:51 <Cale> @free a -> a
04:02:51 <lambdabot> Extra stuff at end of line
04:02:55 <Cale> @free id :: a -> a
04:02:55 <lambdabot> f . id = id . f
04:03:08 <augur> the map free theorem is kind of boring, really
04:03:15 <mauke> @free empty :: [a]
04:03:16 <lambdabot> $map f empty = empty
04:03:22 <nadirs> ulllla: off the top of my head I guess you'd use a combination of `many` and `&&&`, but I'm not sure about it more accurately :/
04:03:27 <augur> given than map (g . h) = map g . map h, the free theorem follows rather directly
04:03:39 <augur> oh right, mauke, doh :D
04:03:45 <mauke> but you're not given that, are you?
04:03:48 <mauke> you just have the type
04:04:04 <augur> oh yes thats right
04:04:16 <augur> also the $'s there are confusing
04:04:19 <Cale> @free reverse :: [a] -> [a]
04:04:19 <lambdabot> $map f . reverse = reverse . $map f
04:04:23 <augur> @free f :: (a -> b) -> [a] -> [b]
04:04:23 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
04:04:29 <augur> thats more interesting, yes
04:04:57 <ulllla> nadirs: thanks, i'll think about it
04:05:02 <mauke> @free fromMaybe
04:05:02 <dramforever> huh, free theorems generator?
04:05:04 <lambdabot> f . fromMaybe x = fromMaybe (f x) . $map_Maybe f
04:05:24 <dramforever> @free (a -> b) -> (b -> c) -> (a -> c)
04:05:24 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
04:05:27 <Cale> @free maybe
04:05:29 <augur> chosing names that look like previously-defined functions is kind of.. misleading
04:05:29 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
04:05:34 <dramforever> @free f :: (a -> b) -> (b -> c) -> (a -> c)
04:05:34 <lambdabot> h . p = q . g => k . f1 = f2 . h => k . f p f1 = f q f2 . g
04:05:58 <Cale> augur: Well, $map is intended to be map
04:06:13 <benmachine> real-actual map
04:06:16 <augur> Cale: no that i get. i meant when doing `@free map :: (a -> b) -> [a] -> [b]`
04:06:27 <augur> i misread the result and didnt see the map $map distinction
04:06:46 <augur> and obviously map isnt the only function of that type, so its confusing
04:06:56 <gabnex> what do you do if the data you are storing in acid-state changes (if the types or fields are renamed, if fields are added, etc)?
04:07:41 <gabnex> how to update the existing database?
04:10:45 <augur> free theorems are very interesting
04:11:43 <mauke> @free id
04:11:45 <lambdabot> f . id = id . f
04:12:17 <dramforever> @help free
04:12:17 <lambdabot> free <ident>. Generate theorems for free
04:12:28 <mauke> @free nothing :: Maybe a
04:12:28 <lambdabot> $map_Maybe f nothing = nothing
04:14:53 <dramforever> @free what :: Either a Int
04:14:54 <lambdabot> $map_Either f $id what = what
04:15:18 <dramforever> @free what :: Ei Int Int Int Int
04:15:18 <lambdabot> $map_Ei ($map_Int ($map_Int ($map_Int $id))) what = what
04:25:52 <JagaJaga> @free fmap
04:25:54 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
04:26:03 <JagaJaga> @free fmap if
04:26:03 <lambdabot> Extra stuff at end of line
04:26:06 <JagaJaga> @free fmap id
04:26:06 <lambdabot> Extra stuff at end of line
04:26:15 <JagaJaga> @free fmap id = id
04:26:15 <lambdabot> Extra stuff at end of line
04:26:18 <mauke> stop
04:26:50 <mauke> you can't avoid "extra stuff at end of line" by adding more extra stuff
04:27:29 <JagaJaga> mauke: haha, yeah, i see :)
04:31:40 <pjdelport> JagaJaga: Note that you can /query lambdabot for experimentation
04:35:06 <jaseemabid> Hello everyone. Is it correct to say that a haskell program that does IO is pure while the runtime that does the actual actions is impure?
04:36:03 <jaseemabid> For example, `putStrLn "test"` is pure but whoever evaluates the action will have to do some impure io?
04:36:50 <augur> JagaJaga: i think the problem is that @free doesnt know how to deal with type constraints
04:36:52 <ij> If I init a sandbox and install something into it, I should be able to import it from ghci too?
04:38:04 <sivteck> cabal exec ghci
04:38:32 * ij _o/\o_ sivteck
04:38:54 <JagaJaga> ij: cabal repl
04:40:04 <mauke> jaseemabid: yes
04:40:49 <jaseemabid> mauke: Thanks.
04:42:15 <jaseemabid> [OT] We started a haskell meetup group at Bangalore, India. Let me know if there is anyone interested in joining.Details here:     http://www.meetup.com/The-Bangalore-Haskell-User-Group/events/212831232/
04:43:34 <nadirs> Can you use Quickcheck to verify the Applicative laws for a custom instance? Is there any example?
04:47:11 <nadirs> Ah, found this: https://gist.github.com/ijt/983630
04:47:35 <nadirs> and this: http://www.austinrochford.com/posts/2014-05-27-quickcheck-laws.html
04:50:57 <saati_> hi, how do i make a Data.ByteString.Lazy's ByteString from Data.ByteString.Char8's?
04:51:00 <mr-> jaseemabid: if you are not aware, one of the best venues for announcements like that is the Haskell-Cafe mailing list
04:51:22 <dramforever> saati_: I'm not sure, but don't you need Data.ByteString.Char8.Lazy?
04:52:16 <saati_> if i try to unpack one and pack it in the other i get a type mismatch between [Char] and [Word8]
04:52:35 <dramforever> well, what do you want to do with it
04:52:54 <saati_> dramforever: AESON uses one, Websockets the other
04:53:10 <dramforever> huh?
04:53:13 <mauke> Char8 isn't a separate type
04:53:17 <dramforever> which websocket?
04:53:44 <saati_> http://jaspervdj.be/websockets/reference/Network-WebSockets.html
04:53:46 <mauke> just don't use the .Char8 functions
04:54:13 <dramforever> saati_: and which aeson function do you want to use?
04:54:35 <saati_> case JSON.decode (LBS.pack $ unsafeCoerce (BSC.unpack cmsg)) of
04:54:40 <saati_> this "works"
04:54:46 <saati_> it fucks up utf8
04:55:35 <mauke> wtf
04:55:43 <mauke> don't use unsafeCoerce
04:55:44 <dramforever> saati_: can you show me the docs?
04:56:04 <saati_> mauke: that's why i am asking this question
04:56:12 <saati_> dramforever: which docs
04:56:30 <mauke> saati_: what happens with JSON.decode cmsg?
04:56:32 <dramforever> saati_: which function?
04:57:09 <saati_> mauke: i match them against some constructors of a type
04:57:21 <mauke> so no error?
04:57:30 <mauke> problem solved, then
04:57:33 <dramforever> saati_: you want to use JSON.decode?
04:57:40 <dramforever> and it takes Char8 bytestrings?
04:57:53 <mauke> there are no "Char8 bytestings"
04:58:40 <dramforever> mauke: well I meant Data.ByteString.Char8.ByteString
04:59:03 <saati_> dramforever: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Generic.html#v:decode this is the decode func
04:59:31 <saati_> mauke: problem solved except internally strings are in some WTF representation
04:59:34 <mauke> that's not a separate type
04:59:39 <mauke> saati_: ??
04:59:59 <dramforever> saati_: well I think they both take Data.ByteString.Lazy.ByteString
05:00:40 <saati_> is there some online haskell compiler where i can put up the whole code and it shows errors nicely?
05:02:24 <dramforever> saati_: post error messages and code to http://lpaste.net/new/haskell , and we will see them
05:02:45 <saati_> i'm on it just waiting for xclip to install
05:03:05 <dramforever> huh? what a long message??
05:03:15 <dramforever> I mean, the message was long?
05:03:56 <saati_> the source file is longish
05:05:44 <saati_> http://lpaste.net/112834, here is the full source and the error
05:07:24 <mauke> ok, so you need to convert a strict bytestring to a lazy bytestring
05:07:53 <dramforever> Aaah
05:08:11 <dramforever> saati_: I think you hit the monomorphism restriction
05:08:31 <mauke> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#v:fromStrict
05:08:32 <dramforever> well, nope
05:08:34 <dramforever> sorrt
05:08:37 <dramforever> sorry
05:09:03 <dramforever> saati_: Just remove line 211 and the error will be gone
05:09:21 <mauke> heh
05:09:25 <saati_> lol
05:09:27 <saati_> thanks
05:09:36 <dramforever> saati_: but there's one problem
05:09:40 <saati_> it would be nice to understand what is this
05:09:42 <dramforever> maybe that's not what you want
05:10:12 <dramforever> saati_: you used BSC.unpack
05:10:21 <dramforever> it requires a BSC.ByteString
05:10:32 <dramforever> neither aeson nor websockets requires that
05:11:19 <dramforever> saati_: you sure you want to print the data?
05:11:38 <saati_> not really, that was just random debug
05:11:58 <dramforever> well, are all your data text?
05:12:22 <saati_> at the moment yes
05:12:30 <dramforever> no forget about it
05:12:40 <dramforever> it's okay
05:13:07 * dramforever tends to ask random questions and immediately forget why I asked
05:13:53 <dramforever> saati_: Your code is a bit scary when I saw line 20 and 21
05:14:13 <dramforever> but I searched for unsafe and only saw them in imports...
05:14:45 <saati_> yes they are gone by now, i used unsafePerfomIO to init toplevel TVars
05:15:29 <dramforever> saati_: if i were you i would use a ReaderT NotSoGlobalState IO
05:16:09 <saati_> instead passing core to everything?
05:16:14 <dramforever> saati_: yep
05:18:06 <lpaste> dramforever pasted “drambot” at http://lpaste.net/112836
05:18:15 <dramforever> saati_: Just in case you need an example
05:18:28 <saati_> thanls
05:20:55 * hackagebot extra 0.3 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.3 (NeilMitchell)
05:20:57 <Tokenizer> i’m trying to write a function toFind if a number is prime….. I have the following… how do I make it also return False for numbers less than 2 ….. here is my attempt; http://pastebin.com/byXqUaQS
05:21:42 <dramforever> (i didn't look at your code) isPrime n | n < 2 = False
05:21:43 <valdyn> Tokenizer: you can just use a wrapper function
05:22:00 <dramforever> {- Line up -} | otherwise = regular_is_prime_code_here
05:22:08 <dramforever> line up the two |
05:23:28 <Tokenizer> dramforever: thanks
05:23:37 <dramforever> tell us if it works
05:24:19 <Tokenizer> but just for formality and me learning the syntax…. without a wrapper, could it have been done in the same function (just want to understand conjunction/disjuntion in Haskell)
05:24:55 <dramforever> x < 2 || regularIsPrime x
05:25:04 <dramforever> oops not really
05:25:11 <valdyn> Tokenizer: a wrapper is used to run a test only the first run in a recursive function. Even though it could be used for your prime test it was a bad idea
05:25:53 <dramforever> valdyn: well, then why many functions have "where loop =" or "where go ="
05:26:25 <dramforever> saati_: I have started drambot. Try /msg drambot !help
05:26:31 <dramforever> If you are bored
05:28:12 <michi7x7> dramforever: +1
05:28:16 <dramforever> drambot users, prefix commands with ! please
05:28:21 <michi7x7> aah
05:28:29 <valdyn> dramforever: thats not what i was talking about, i meant isPrime n | n < 2 = false  \n | otherwise = isPrime' n
05:28:34 <valdyn> dramforever: not very useful here
05:28:48 <dramforever> valdyn: well, -1 is not a prime
05:28:58 <michi7x7> valdyn: if n < 2 then false else isPrime' n ?
05:29:07 <dramforever> hmmm...yep, that's not useful
05:29:09 <valdyn> michi7x7: same thing
05:30:56 * hackagebot neil 0.2 - General tools for Neil  http://hackage.haskell.org/package/neil-0.2 (NeilMitchell)
05:32:58 <michi7x7> valdyn: what if you just put n >= 2 && up front?
05:33:20 <dramforever> in my opinion that's not very readable
05:34:02 <valdyn> michi7x7: matter of taste i think, i like && and its lazy evaluation property
05:34:27 <valdyn> michi7x7: C programmers would like it ;)
05:34:36 <dramforever> well, that's true
05:34:45 <michi7x7> it's better than putting it in the guard, probably
05:34:53 <michi7x7> hehe, I've been doing VHDL today :)
05:37:04 <dramforever> is there any somewhat famous package that uses type level Int's
05:37:44 <dramforever> well, turns out only naturals
05:39:09 <beaky> hello
05:39:27 <beaky> how do i write tests for my haskell modules
05:39:56 <dramforever> beaky: in short, check out quickcheck, hunit, hspec
05:40:04 <dramforever> use the ones you like
05:42:01 <lpaste> beaky pasted “yet another ugly function” at http://lpaste.net/112837
05:42:15 <beaky> also any ideas on refactoring http://lpaste.net/112837 ? :D
05:42:58 <dramforever> what's OverallProgression
05:43:40 <dramforever> beaky: first problem: you've redefined init
05:43:44 <lpaste> beaky pasted “OverallProgression type definition” at http://lpaste.net/112838
05:43:46 <dramforever> > init [1,2,3,4,5]
05:43:48 <lambdabot>  [1,2,3,4]
05:44:01 <beaky> @src init
05:44:01 <lambdabot> init [x]    = []
05:44:01 <lambdabot> init (x:xs) = x : init xs
05:44:01 <lambdabot> init []     = undefined
05:44:06 <beaky> i have? :D
05:44:26 <dramforever> line 8 of paste "yet another ugly function"
05:44:46 <beaky> yes one issue i run into frequently is im very bad with coming up with names
05:45:01 <dramforever> well, everyone has that problem
05:45:24 <beaky> i guess its bad to redefine prelude functions in where clause?
05:45:43 <pjdelport> "There are only two hard things in Computer Science: cache invalidation and naming things." -- Phil Karlton
05:45:55 <dramforever> beaky: think about an occasion when you define another thing in the same where
05:46:00 <dramforever> and it uses "init"
05:46:05 <saati_> i think that's missing offbyone errors
05:46:09 <pjdelport> beaky: Compiling with -Wall will warn you when you shadow names like that.
05:46:16 <dramforever> and you hope it to be Prelude.init
05:46:25 <beaky> how do i tell cabal to add -Wall to my builds
05:47:05 <indiagreen> beaky: instead of “snd <$> M.toList skillProgressionMap”, you can use “elems skillProgressionMap”
05:47:21 <UnrealQuester> GHC-Options:    -Wall
05:47:22 <dramforever> indiagreen: you mean M.elems?
05:47:28 <indiagreen> yep
05:48:02 <beaky> heh how many more functions did i reinvent
05:48:50 <dramforever> well, I remembered someone asking on haskell cafe to help with his/her code, and all everyone did is tell him/her that he/she reinvented a function
05:49:35 <dramforever> beaky: I'm not sure why do you have "= sum" then "where sum = "
05:50:27 <dramforever> beaky: why not acc ...blah... = SkillProgression ...blah..
05:50:29 <beaky> i wanted to have the whole expression fit in <=78 characters
05:50:40 <dramforever> beaky: add a line break after the "="
05:50:50 <dramforever> and indent the next line a bit
05:54:01 <dramforever> > take 10 (iterate (+1) 0)
05:54:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:54:32 <dramforever> Somehow I think iterate is related to induction
05:54:46 <michi7x7> > take 10 [0..]
05:54:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:54:56 <dramforever> Somehow I think iterate is related to induction
05:55:41 <augur> dramforever: in what sense?
05:55:43 <augur> :t iterate
05:55:44 <lambdabot> (a -> a) -> a -> [a]
05:56:14 <augur> it's certainly related to Nat induction
05:56:22 <augur> well, Nat recursion, specifically
05:56:37 <augur> natRec :: (a -> a) -> a -> Nat -> a
05:56:40 <dramforever> it makes me think of church numerals
05:57:02 <augur> dramforever: church numerals are pre-applied recursion schemes :)
05:57:32 <dramforever> iterate f x = map (\n -> n f x) [0..]
05:57:45 <lpaste> beaky pasted “refactored ugly function” at http://lpaste.net/112839
05:57:54 <augur> well that wont work, but
05:58:04 <beaky> yay thanks everyone my function is pretty now
05:58:06 <augur> what iterate is doing is tracing out all the intermediate values of natRec
05:59:01 <augur> iterate f x = map (natRec f x) [0..]
05:59:14 <dramforever> it looks like that x is true, and if k is true then (f k) is true, then forall n in churchNum, n f x is true
05:59:40 <augur> dramforever: thats.. vaguely right
06:00:14 <dramforever> yeah, and the iterate <=> induction relation is vague, too
06:00:23 <augur> the induction principle for naturals is   natInd :: (f :: Nat -> *) -> f 0 -> ((n :: Nat) -> f n -> f (Suc n)) -> (m :: Nat) -> f m
06:00:35 <augur> no its not vague at all
06:00:51 <augur> iteration is induction where the predicate is a constant function
06:00:52 <dramforever> you sure? I said iterate
06:00:58 <dramforever> not natInd
06:01:27 <augur> yes but you're talking about truth, etc. above and thats not really purely iteration-related
06:01:43 <dramforever> well, so called "true"
06:01:53 <dramforever> it's hard to put it
06:02:23 <asfp`> I want to write something like   class C a where { type Monoid a => T a; } , but the 'Monoid a =>' is not legal.  How can I have such a restriction?
06:02:31 <augur> i think your intuitions are on the right track, they just need to be made precise and formal, dramforever :)
06:02:50 <dramforever> asfp`: class Monoid a => C a, maybe
06:03:03 <beaky> http://lpaste.net/112839 is there a way to refactor line 10+11? maybe i can make SkillProgression a Monad?
06:03:06 <augur> asfp`: consider the intended meaning
06:03:18 <dramforever> asfp`: maybe you didn't mean this
06:03:34 <asfp`> I want the associated type to be a member of Monoid.
06:04:11 <asfp`> dramforever: class Monoid a => C a means that a is member of Monoid.  What I want is that (T a) is a member of Monoid.
06:04:23 <dramforever> asfp`: Maybe you can write (C a, Monoid a) => whenever you use T a?
06:04:30 <augur> asfp`: that is not the meaning you wrote, however
06:04:36 <augur> in fact, you cannot express the meaning you want
06:04:50 <augur> not in haskell, anyway
06:05:23 <asfp`> angur: I can write 'type TT a = (T a, Monoid a) using ConstraintKinds I think.. ?
06:05:28 <dramforever> beaky: no, I don't think you'll need to make that better
06:05:30 <asfp`> and then use TT a everywhere.
06:05:48 <augur> asfp`: except T has to be a type class then
06:06:25 <augur> also im not sure if you need T to be a type operator
06:06:34 <augur> maybe you do. i dont know much about associated types
06:06:39 <asfp`> augur: not sure I understand.  T is a type function, isn't it?
06:06:40 <dramforever> beaky: maybe you can move acc up so that it's right after "skillProgressionMap"
06:07:12 <augur> asfp`: T is a type function, yes. but if you want to use (T a, Monoid a) as a constraint, then T has to be a type class, not a type function
06:07:25 <dramforever> asfp`: (T a, Monoid a) :: Constraint, and a :: *
06:07:32 <dramforever> so T :: * -> Constraint
06:08:17 <dramforever> beaky: you can make acc a "where" under "skillProgressionMap = ..."
06:08:27 <augur> {-# LANGUAGE DependentTypes #-}   <--- solves all problems
06:08:27 <augur> x3
06:08:30 <asfp`> dramforever: yes, that looks right.
06:08:32 <beaky> ah thats best
06:08:52 <augur> im kidding of course. use idris.
06:09:22 <mauke> foo :: (Monoid (T a)) => T a
06:09:30 <asfp`> augur: I'm actually trying to get "real work" done, not play with Z and Succ.. :-)
06:09:56 <dramforever> I think that haskell gets bizarre features like this because someone write papers
06:10:11 <dramforever> some people, maybe
06:10:14 <augur> asfp`: well good luck!
06:10:42 * asfp` is just writing a web service.
06:11:15 <asfp`> It feels wrong to not specify this in the type class.  Making illegal states not representable etc.
06:11:45 <augur> asfp`: it does feel wrong
06:11:45 <dramforever> asfp`: Making then not usable isn't enough?
06:11:49 <augur> it also cant be expressed
06:11:53 <augur> not in haskell
06:12:03 <dramforever> like, data Ord k => Map k v = ... is deprecated
06:12:05 <dramforever> why?
06:12:06 <augur> you want to say something like   type T a ; Monoid (T a)
06:12:10 <augur> but it cant be done
06:12:19 <phaazon> 14:43 #haskell: < michi7x7> phaazon: i was wrong... my rock, scissor, paper  does work against (unaware) human opponents. Not  very good, but better than plain random
06:12:22 <phaazon> what?
06:12:51 <dramforever> augur: asfp` said type Monoid a => T a
06:12:59 <augur> dramforever: yes, and that doesnt mean the same thing
06:13:05 <augur> that doesnt mean even remotely the same thing
06:13:23 <augur> for one thing, that's saying that `a` is a Monoid, not that `T a` is a monoid
06:13:26 <dramforever> is that illegal syntax?
06:13:38 <asfp`> mauke: then should I be able to say  class C where { type Monoid (T a) :: *; } ?
06:13:50 <mauke> asfp`: no
06:13:58 <dramforever> augur: I think asfp` wants a, not T a to be a monoid
06:13:58 <augur> for two, that's not declaring a type function `T`. afaik associated types dont let you do stuff like that
06:14:15 <asfp`> dramforever: No I want T a to be a monoid
06:14:20 <dramforever> asfp`: class C where???
06:14:35 <asfp`> sorry class C a where { ...
06:14:37 <dramforever> maybe you are missing a parameter here?
06:14:49 <dramforever> oh
06:15:02 <augur> asfp`: Idris is your best bet!
06:15:05 <augur> :)
06:15:14 <dramforever> so how about "(Monoid (T a)) =>" everywhere?
06:15:22 <asfp`> augur: can Idris serve web pages?
06:15:27 <augur> probably!
06:15:35 <augur> i dont know if idris can do this tbh
06:15:42 <augur> i dont know if their type class stuff works like this
06:17:12 <asfp`> dramforever: yes, I could do that, and with ConstraintKinds I *think* I could do something like this:  class C a where { type NotUsedF a :: *; }  type F a = (C a, Monoid (F a)) and then use F a as if it was the original F a??
06:17:21 <asfp`> sorry
06:17:33 <asfp`> type F a = (C a, Monoid (NotUsedF a))
06:17:45 <dramforever> asfp`: nope
06:17:48 <dramforever> wrong kind
06:17:53 <dramforever> F a :: Constraint
06:18:00 <dramforever> while NotUsedF a :: *
06:18:59 <dramforever> huh? the idris tutorial explains idris in terms of haskell?
06:19:12 <mauke> sure, it's what everybody knows
06:19:13 <nshepperd> is there some reason you can't do "class (Monoid (T a)) => C a where {...}"?
06:19:44 <mauke> nshepperd: is T in scope there?
06:19:47 <dramforever> asfp`: how about this?
06:19:49 <asfp`> nshepperd: can I?
06:20:12 <dramforever> class class Monoid t => C a t | a -> t, t -> a where ...
06:20:17 <dramforever> oops
06:20:22 <dramforever> class class Monoid t => C a t | a -> t where ...
06:20:31 <dramforever> oops
06:20:33 <dramforever> class Monoid t => C a t | a -> t where ...
06:20:37 <dramforever> how about this one?
06:21:26 <asfp`> I guess so.  I am not very familiar with dep types.
06:21:37 <dramforever> asfp`: that's not a dep type
06:21:59 <asfp`> it's something I'm not familiar with at least ;-)
06:22:09 <dramforever> asfp`: for example:
06:22:23 <dramforever> class MonadReader r m | m -> r where
06:22:32 <nshepperd> asfp`: how is T defined?
06:22:43 <dramforever> asfp`: why don't you check out functional dependencies yourself
06:23:00 <asfp`> dramforever: ah, I meant fun deps, not dep types..
06:23:10 <dramforever> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html
06:23:24 <nshepperd> asfp`: Oh, T is an associated type family of C?
06:23:28 <dramforever> see this. the "m -> r" ensures that ask is not ambiguous
06:23:33 <asfp`> The type families documentation states that a lot of the fun deps can be translated into type families.
06:23:49 <dramforever> asfp`: how about the reverse
06:24:26 <sudeep> hi
06:24:55 <lpaste> nshepperd pasted “type families” at http://lpaste.net/112840
06:25:00 <sudeep> how can i double the alterate element like [1,2,4] becomes [2,2,8]
06:25:18 <nshepperd> asfp`: the above paste seems to work
06:25:20 <dramforever> sudeep: maybe write yourself a loop
06:25:33 <dramforever> f [] = []
06:25:49 <dramforever> f (x : y : rest) = (2*x) : y : rest
06:25:59 <dramforever> f (x : rest) = <it depends on what you want>
06:26:04 <dramforever> oopes
06:26:09 <dramforever> f (x : []) = <it depends on what you want>
06:26:10 <asfp`> nshepperd: that's great!
06:26:49 <dramforever> sudeep: the code has cases for 0, >= 2, 1 items, which I think is complete
06:26:59 <augur> what a boring answer, dramforever!
06:27:03 <sudeep> how can i do using list comprehensions
06:27:08 <lpaste> nshepperd annotated “type families” with “type families (annotation)” at http://lpaste.net/112840#a112841
06:27:22 <augur> zipWith ($) (cycle [(2*), id])
06:27:30 <augur> > zipWith ($) (cycle [(2*), id]) [0..]
06:27:31 <asfp`> nshepperd: thank you! I'd like to keep the type families stuff and not go into fun deps, so your solution is perfect.
06:27:32 <lambdabot>  [0,1,4,3,8,5,12,7,16,9,20,11,24,13,28,15,32,17,36,19,40,21,44,23,48,25,52,27...
06:27:38 <vanila> sudeep,
06:27:45 <vanila> > cycle [True,False]
06:27:47 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
06:28:02 <augur> vanila: 2slo
06:28:09 <vanila> oh
06:28:09 <dramforever> augur: maybe a intermediate data structure is bad for performance?
06:28:24 <vanila> > [ if b then 2*x else x | b <- cycle [True,False] | x <- [1,2,4] ]
06:28:26 <lambdabot>  [2,2,8]
06:28:30 <augur> dramforever: i think probably GHC will optimize the heck out of it
06:28:57 <dramforever> augur: well, I was really impressed by the voptimizer of ghc
06:29:20 <augur> this is just some kind of hylomorphism i think, so there are fusion techniques out there
06:29:38 <dramforever> when I inspected the core generated of one of my files I found out that ghc optimized a Prelude.lookup call into a case
06:29:40 <dresuer> hi all :D !
06:29:59 <sudeep> vanila how can i do without using list comprehensions
06:30:04 <vanila> oh sorry
06:30:07 * dramforever was astonished seeing that
06:30:10 <augur> sudeep: see my example :)
06:30:12 <vanila> I thought you wanted to do it WITH list comprehension
06:30:16 <augur> > zipWith ($) (cycle [(2*), id]) [0..]
06:30:18 <lambdabot>  [0,1,4,3,8,5,12,7,16,9,20,11,24,13,28,15,32,17,36,19,40,21,44,23,48,25,52,27...
06:30:26 <dramforever> sudeep: you saw my "f" earlier?
06:30:33 <augur> > zipWith ($) (cycle [(2*), id]) [1,2,4]
06:30:36 <lambdabot>  [2,2,8]
06:31:09 * dfeuer looks up and sees people playing with lists.
06:31:11 <sudeep> dramforever: i think your f will not work if there are odd numbers of element and even number of elemennts
06:31:34 <dramforever> sudeep: huh? I gave three cases
06:31:42 <dramforever> f [] = []
06:31:42 <augur> sudeep: if you want to do it as a raw function, you need to use some kind of mutual recursion, or unfold it
06:32:00 <dramforever> f (x : y : rest) = (x*2) : y : f rest
06:32:10 <dramforever> f (x : []) = <depends on what you want>
06:32:27 <augur> dramforever: i dont think that will work quite correctly
06:32:31 <sudeep> dramforever: can you exaplain me how the iteration works
06:32:36 <dramforever> augur: huh?
06:32:41 <dfeuer> I wouldn't expect that zipWith cycle thing to be the fastest approach, but I could be surprised.
06:32:50 <dramforever> sudeep: wait let's solve the "not work correctly" thing first
06:32:53 <dramforever> augur: huh?
06:32:58 <sudeep> dramforever: you sent me something difference earlier
06:33:00 <sudeep> :D
06:33:06 <dramforever> oops
06:33:08 <dramforever> oh
06:33:17 <dramforever> I didn't write "f rest"
06:33:18 <dramforever> oops
06:33:19 <augur> dramforever: i think actually it should be just   f [] = [];  f [x] = [2*x];  f (x:y:xs) = 2*x : y : fxs
06:33:25 <sudeep> dramforever: i was confused and afraid at the time how it work
06:33:27 <augur> f xs  rather
06:33:41 <dramforever> augur: yeah the same
06:33:43 <sudeep> augur: correct
06:33:53 <augur> but, the cycle approach is better
06:34:07 <dramforever> sudeep: well, you can pretend to be haskell to see why it works
06:34:09 <sudeep> augur correct
06:34:26 <augur> what you want, abstractly, is   [x, y, z, ...]  :->  [2*x, y, 2*z, ...]
06:34:30 <dramforever> augur: well, I still think that mine is faster
06:34:42 <sudeep> dramforever: i didnot understand your mistaken code but now understan it
06:34:43 <augur> ie you want   zipWith ($) [(2*), id, (2*), ...] [x,y,z,...]
06:35:00 <augur> dramforever: it might be marginally faster, i dont know. you'd have to do some tests
06:35:12 <augur> i would prefer a slightly slower, but clearer, piece of code :)
06:36:20 <dramforever> since I've written a program that processes huge amount of data I've changed and prefer small, "smartless" functions
06:36:57 * dramforever remembered someone asking on a ruby forum
06:37:05 <augur> you can rework things as necessary later
06:37:18 <dramforever> "What's the best parser generator for this simple grammar?"
06:37:18 <augur> better to start with the obviously correct spec-like version
06:37:22 <dramforever> then a grammar
06:37:37 <dramforever> "I want it to be fast"
06:37:44 <dramforever> ans: "Write your own"
06:38:01 <vanila> should I use MaybeT state or StateT Maybe?
06:38:30 <augur> @mtl MaybeT State
06:38:30 <lambdabot> Maybe you meant: url unmtl pl msg
06:38:35 <augur> @unmtl MaybeT State
06:38:35 <lambdabot> Plugin `unmtl' failed with: `MaybeT State' is not applied to enough arguments, giving `/\A B. Maybe A -> (B, Maybe A)'
06:38:45 <augur> @unmtl MaybeT State a
06:38:45 <lambdabot> Plugin `unmtl' failed with: `State (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a -> (A, Maybe a)'
06:38:47 <dramforever> @unmtl MaybeT State s a
06:38:47 <lambdabot> Maybe s -> (a, Maybe s)
06:38:54 <augur> thats it :P
06:38:57 <dramforever> @unmtl MaybeT (State s) a
06:38:57 <lambdabot> (State s) (Maybe a)
06:39:15 <vanila> oh!
06:39:18 <dramforever> @unmtl MaybeT (State s) a
06:39:18 <lambdabot> (State s) (Maybe a)
06:39:19 <vanila> Thanks
06:39:20 <augur> vanila: pick the one you intended
06:39:29 <dramforever> @unmtl StateT Maybe a
06:39:30 <lambdabot> Plugin `unmtl' failed with: `StateT Maybe a' is not applied to enough arguments, giving `/\A. Maybe -> a (A, Maybe)'
06:39:40 <dramforever> @unmtl StateT s (Maybe a)
06:39:40 <lambdabot> Plugin `unmtl' failed with: `StateT s (Maybe a)' is not applied to enough arguments, giving `/\A. s -> (Maybe a) (A, s)'
06:39:54 <dramforever> @unmtl StateT s Maybe a
06:39:54 <lambdabot> s -> Maybe (a, s)
06:40:20 <dramforever> vanila: if you still want the state when it fails use MaybeT (State s)
06:40:30 <dramforever> otherwise StateT s Maybe
06:41:34 <dramforever> It turns out that haskell uses ":" for cons and "::" for type sigs
06:41:45 <AndroidShoutapop> Guys, I heard that Haskell functions may return another function, how does it preserve the data in the first function call?
06:43:53 <_ikke_> AndroidShoutapop: preserve what data?
06:44:03 <dramforever> f x = \y -> x + 1
06:44:08 <dramforever> preserve x, I suppose
06:44:34 <sudeep>  [4,56,7,8] how to find the sum like this : 4+ 5 + 6 + 7 + 8
06:44:45 <asfp`> is there a compact way to write a Monoid instance when one just want to apply <> to all fields of a product type?
06:44:50 <AndroidShoutapop> sudeep: Recursion?
06:44:52 <vanila> > sum [4,5,6,7,8]
06:44:54 <lambdabot>  30
06:45:13 <michi7x7> AndroidShoutapop: a function is not an object, it does not contain (or preserve anything)
06:45:17 * AndroidShoutapop thought he was asking how to code it. Meh.
06:45:26 <UnrealQuester> this does look like that assignment
06:45:29 <sudeep> vanila: sum wont work
06:45:35 <vanila> sum does work
06:45:40 <sudeep> vanila: if the element is 16 i want 1 + 6
06:45:47 <vanila> oh
06:45:47 <AndroidShoutapop> sudeep: Oh.
06:45:51 <vanila> I thought that was a typo
06:45:58 <AndroidShoutapop> vanila: Make that the both of us. :P
06:46:00 <michi7x7> AndroidShoutapop: you retain values by returning them (always)
06:46:04 * hackagebot htsn-import 0.1.3 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.1.3 (MichaelOrlitzky)
06:46:29 <AndroidShoutapop> michi7x7: This is making me feel a bit confused now.
06:47:01 <AndroidShoutapop> michi7x7: How does ((+ 1) 2) work? It doesn't seem to be passing it back.
06:47:13 <AndroidShoutapop> > ((+ 1) 2)
06:47:15 <lambdabot>  3
06:47:23 * AndroidShoutapop was just making sure it works.
06:47:28 <michi7x7> it's not... its not even evaluated until you print it
06:47:35 <dramforever> AndroidShoutapop: it just works
06:48:07 <dramforever> it's not the most magical thing in haskell. javascript, python, ruby, other languages all can do this
06:48:16 <AndroidShoutapop> dramforever: Not really.
06:48:16 <dramforever> the type system is more magical
06:48:35 <michi7x7> > fst (5, 2*0)
06:48:36 <lambdabot>  5
06:48:49 <michi7x7> > fst (5, 2/0)
06:48:50 <triliyn> AndroidShoutapop: (+ 1) is the same as \x -> x + 1
06:48:50 <lambdabot>  5
06:48:51 <dramforever> AndroidShoutapop: in other language they not only preserve, but also they are mutable!
06:48:52 <michi7x7> that
06:49:17 <AndroidShoutapop> triliyn: I see.
06:49:39 <AndroidShoutapop> michi7x7: Yeah, I just recently read of that, about lazy evaluation, but it doesn't seem to be relevant to my question.
06:51:27 <augur> michi7x7: laziness is irrelevant here
06:51:29 <michi7x7> AndroidShoutapop: It's all the same since functions are just values
06:51:45 <augur> AndroidShoutapop: the simple way to think about it is like this
06:51:51 <bennofs> AndroidShoutapop: if you do (\x y -> x + y) 1, then you build a "closure". The closure saves the value of x
06:52:02 <augur> bennofs: no no forget closures for now
06:52:11 <bennofs> augur: ? was that wrong
06:52:15 <vanila> http://lpaste.net/112842
06:52:27 <augur> AndroidShoutapop: in haskell either a function is primitive (lets pretend (+) is primitive) or its a lambda expression
06:52:36 <vanila> I havea question on how to check type rules using MaybeT and State monads
06:52:43 <AndroidShoutapop> augur: Yeah, I know that part, since I know-ish Lisp.
06:52:51 <michi7x7> maybe I misunderstand the question ... f x = \y -> x + 1  ... if you call f 5 it will return a value that returns 6, regardless of what you pass to it
06:53:04 <michi7x7> s/value/function
06:53:06 <augur> AndroidShoutapop: if its primitive, then nothing magical happens at all. when you write (+ 1) you just have a boring symbolic object that doesnt do anything
06:53:10 <vanila> Do you have any tricks to implement A-If? suggestions?
06:53:14 <UnrealQuester> sudeep: you can write a digit sum function and run that over the list and sum the results
06:53:16 <augur> it "returns" just that: (+ 1)
06:53:23 <AndroidShoutapop> augur: I see.
06:53:36 <augur> AndroidShoutapop: for a lambda expression, something different happens
06:53:58 <sudeep> UnrealQuester: i am begineer can you please give hint
06:54:23 <augur> if you have   (\x -> M) N P   where M N and P are programs, then it beta-reduces the first thing to   [N/x]M
06:54:28 <augur> that is, it substitutes N for x in M
06:55:02 <augur> eg   (\x -> (\y -> x + y - 5))) 0 2    ~>   (\y -> 0 + y - 5) 2
06:55:09 <UnrealQuester> digitSum x = (x `mod` 10) + sumd (x `div` 10)
06:55:16 <UnrealQuester> and digitSum 0 = 0
06:55:23 <augur> AndroidShoutapop: so we return a function quite simply: we just plug in the value for the variable
06:55:32 <UnrealQuester> s/sumd/digitSum
06:56:05 * hackagebot hpqtypes 1.2.2 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.2.2 (arybczak)
06:56:06 <AndroidShoutapop> augur: I see.
06:56:21 <augur> now, in practice this is actually a big waste of time because you have to traverse the whole of the function to do the substitution, so there are techniques (environments + closures) that make this simpler
06:57:06 <vanila> I need locally scoped state monad?
06:57:32 <sudeep> UnrealQuester: this does not works for 3 digit number isn't it
06:58:13 <UnrealQuester> it should work on any number
06:58:14 <vanila> > (map (read . (:[])) . show $ 3574) :: [Int]
06:58:15 <lambdabot>  [3,5,7,4]
06:58:22 <augur> AndroidShoutapop: the details of environments + closures are somewhat boring and dont add much insight ultimately, and tend to depend on your particular language
06:58:35 <AndroidShoutapop> augur: I see, thanks.
06:59:01 <augur> AndroidShoutapop: if you want to know the details of that, i can provide them, but they're a distraction for the real principle of "returning a function"
06:59:05 <UnrealQuester> (123 `mod` 10) + (12 `mod` 10) + (1 `mod` 10) + 0
06:59:13 <UnrealQuester> wich is 1 + 2 +3
06:59:26 <vanila> I figured it out I can use get and put
06:59:36 <augur> its an implementation detail, not an essential facent of understanding whats going on, i think
06:59:38 <AndroidShoutapop> augur: This is enough, thanks.
07:00:04 <UnrealQuester> as the function is recursive it just needs to get the rightmost digit via mod and then call itself with the remaining digits
07:03:19 <sudeep> UnrealQuester: Thnks i got it
07:20:10 <sm> morning all
07:20:57 <XexonixXexillion> What are the popular FRP libraries currently?
07:21:12 <_ikke_> hello sm
07:21:16 <sm> why would I get "No instance for (Text.Blaze.ToMarkup Quantity)" with cabal repl, when cabal build doesn't complain about it ?
07:22:00 <sm> type Quantity = Decimal
07:25:48 <sm> hm, maybe I see
07:30:01 <ionum> hi, i have a function spec :: Spec and i want to read a file inside, is it possible without changing the type to spec :: IO Spec?
07:30:12 <mauke> that doesn't look like a function
07:30:16 <mauke> and no
07:30:29 <jgallag88> Is anyone very familiar with Happy?
07:30:30 <ionum> well its a constant function duh
07:30:43 <mauke> no, it's a constant
07:31:09 * hackagebot bake 0.2 - Continuous integration system  http://hackage.haskell.org/package/bake-0.2 (NeilMitchell)
07:31:11 * hackagebot yabi 0.1.1.0 - Yet Another Brainfuck Interpreter  http://hackage.haskell.org/package/yabi-0.1.1.0 (fgaz)
07:31:30 <ionum> well does anyone know hspec?
07:31:45 <c_wraith> ionum: functions are things with a top-level type constructor of (->)
07:32:21 <sm> oh my gosh.. cabal doesn't use a sandbox located in the parent directory, does it ? I thought it did
07:32:40 <mauke> ooh, it is a monadic action
07:33:02 <jgallag88> I am trying to parse a grammar that is not quite context free, and is proving a little tricky
07:33:06 <ionum> i want to test a parser but its terrible to write the strings i want to test inside of hspec, i want to read them from files, but when doing this i am not able to automatically load the spec's
07:34:06 <ionum> the strings/files are java files
07:34:15 <mauke> can't you use runIO?
07:35:17 <asfp`> is there a type class for something that is  (Ord a, Default a), so I can do max, min, and def?
07:35:50 <k0ral> I've installed GHC with integer-simple (as opposed to integer-gmp); why is it that building 'hashable' tries to build integer-gmp, while the package dependencies list either integer-simple or integer-gmp (through base) ?
07:36:00 <k0ral> shouldn't cabal automatically pick the available one ?
07:36:44 <ionum> @mauke you mean runIO :: IO a -> Q a?
07:36:44 <lambdabot> Unknown command, try @list
07:36:49 <ionum> mauke you mean runIO :: IO a -> Q a?
07:36:59 <saep> ionum: It has to be done inside the monad run by `it`. See https://github.com/saep/saeplog/blob/master/test-suite/Web/Saeplog/Blog/CrawlerSpec.hs as an example
07:37:02 <mauke> ionum: http://hackage.haskell.org/package/hspec-1.11.4/docs/Test-Hspec.html#v:runIO
07:37:44 <mauke> oh, ignore me
07:38:48 <ionum> oh i see, thank you
07:40:01 <AndroidShoutapop> augur: Erm, sorry for disturbing you again, so, if I understand this correctly, beta-reduction is done on compile-time?
07:40:36 <augur> AndroidShoutapop: beta-reduction is execution time
07:40:54 <augur> well, run time
07:41:07 <augur> execution is something subtle in haskell, unlike other langs
07:41:08 <AndroidShoutapop> augur: But of course, haskell won't compile it like that in real applications, right?
07:41:30 <augur> in fact, beta reduction is one half of the stuff that defines the runtime in haskell, essentially
07:41:37 <augur> AndroidShoutapop: oh it will, yes
07:41:49 <AndroidShoutapop> (Correct me if I'm wrong, I just decided to learn Haskell today.)
07:41:58 <AndroidShoutapop> augur: Woah. ._.
07:42:00 <augur> i mean, like i said, no one actually uses *beta reduction* but
07:42:33 <augur> so like i said, what happens in the actual compiler is you use environments and closures
07:42:41 <augur> which are an equivalent technique
07:42:52 <augur> but if you're learning haskell, you dont need to worry about that right now
07:43:01 <augur> dont worry at all about how haskell works under the hood
07:43:44 <augur> for all you care, yes, that is how it gets compiled
07:43:49 <augur> and for all anyone could care it is
07:44:11 <AndroidShoutapop> augur: I'm currently trying to design a compiler for this language I'm making, that's why I'm somewhat curious, but it's best to know most(if not all) of a language before trying to model a language out of it. Thanks for your help.
07:44:45 <augur> AndroidShoutapop: well, i think its better first to understand the principles that are at work
07:45:17 <augur> otherwise you wont have a clue why anything makes sense
07:47:14 <augur> in fact, environments and closures sort of become more obvious when you really take laziness seriously. then they just collapse into the same thing and turn out to be n-ary explicit substitution
07:47:26 <irrequietus> augur: it is more a rite of passage; once you feel you have mastered a language enough, going into compiler internals for it and understanding them gives you effective mastery of the tool you are using
07:47:59 <augur> irrequietus: sure, if youre into compiler internals
07:48:07 <augur> but the env thing is really kind of pretty high level anyway
07:48:25 <irrequietus> augur: yeah, I am very attracted by compiler internals in specific.
07:48:46 <augur> but i mean, AndroidShoutapop, you should focus more on the *meaning* of the things you want to achieve
07:48:53 <irrequietus> ---^
07:48:55 <augur> compilers are a very secondary thing for language design, i feel
07:49:04 <irrequietus> augur is correct
07:49:06 <augur> never think about compilers until you've already fully designed the language
07:49:11 <irrequietus> +1
07:49:49 <augur> AndroidShoutapop: if you're genuinely designing a PL, i would suggest you watch frank pfenning's OPLSS course on proof theory foundations
07:49:53 <augur> @where oplss2012
07:49:53 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
07:49:55 <irrequietus> the point is where to strike the balance of having a design that is evolved enough to do what you wish to do so that you can start implementing a compiler for the language
07:50:10 <vanila> How do you write a compiler?
07:50:16 <vanila> I'd like to do this but I found it hard
07:50:19 <irrequietus> and that is something that comes with experience
07:50:22 <augur> get yourself familiar with that, to the point of being able to teach it to someone else, and then (and ONLY then) start designing your PL
07:50:38 <irrequietus> +1 ----^
07:51:02 <irrequietus> vanila: you need to master compiler theory :)
07:51:11 * hackagebot hcltest 0.3.5 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.5 (BennoFuenfstueck)
07:51:12 <vanila> How?
07:51:14 <shiona> vanila: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours is this of any help?
07:51:29 <irrequietus> yes, what shiona said is good :)
07:51:30 <vanila> shiona, This is a nice intro to interpreters, but I've studied interpreters already
07:51:31 <AndroidShoutapop> augur: Well, it was more inclined to Lisp, however, since Haskell is also functional, I decided to take a look at it too.
07:51:35 <augur> and once you've done that, AndroidShoutapop, then go read Pfenning's notes on compiler design
07:51:46 <AndroidShoutapop> augur: Okay, will do. Thanks.
07:51:48 <augur> AndroidShoutapop: yes, but lisp is a somewhat haphazardly designed language
07:52:02 <augur> AndroidShoutapop: and at any rate, the best way to understand lisp is again from the high-level beta reduction standpoint
07:52:07 <vanila> I wan to learn about constructing compilers now
07:52:21 <augur> if you watch SICP, for instance, they dont teach you about the "truth" of environments until very far into the course
07:52:28 <irrequietus> augur: more like loosely designed perhaps. I still kind of like it.
07:52:30 <augur> like 4 or so lectures in
07:52:43 <shiona> vanila: do you know any ASM?
07:53:12 <vanila> yes, I've been practicing x86 assembly for a fwe months
07:53:55 <shiona> ok, then I can't really help you, since you most likely know more than I do
07:53:55 <ionum> mauke thanks it works :D
07:53:57 <thebnq> nowadays i think counts now to just have an llvm backend :p
07:55:38 <thebnq> is there a list of what @where can supply
07:56:04 <AndroidShoutapop> Also, do you guys find this: http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell As a good guide?
07:56:09 <AndroidShoutapop> (For a beginner)
07:56:18 <jgallag88> Has anyone used Happy to parse grammars with context dependent features?
07:56:22 <augur> AndroidShoutapop: never used it, alas
07:57:08 <jgallag88> I am not sure how to choose on parse over another depending upon context
07:57:17 <AndroidShoutapop> augur: It immediately goes to the concepts of monads.
07:57:23 <jgallag88> *one parse
07:57:25 <augur> AndroidShoutapop: awful, dont read it
07:57:44 <AndroidShoutapop> augur: Okay. I was so lost when I first read this.
07:57:48 <augur> AndroidShoutapop: ive heard good things about bird and wadler
07:58:05 <augur> lemme find the title
07:58:07 <sivteck> AndroidShoutapop, http://dev.stephendiehl.com/hask/ and https://github.com/bitemyapp/learnhaskell
07:58:39 <augur> AndroidShoutapop: http://www.amazon.com/Introduction-Functional-Programming-International-Computing/dp/0134841891
07:58:45 <augur> im sure you can find copies in the appropriate places
07:58:57 <augur> tho thats not haskell specific
07:59:10 <AndroidShoutapop> augur: I see.
07:59:25 <augur> AndroidShoutapop: http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460
07:59:27 <augur> is probably good
08:00:02 <AndroidShoutapop> augur: Being a minor disallows me to shop online. :/
08:03:09 <bennofs> AndroidShoutapop: LYAH as a good start
08:03:11 <bennofs> @where lyah
08:03:12 <lambdabot> http://www.learnyouahaskell.com/
08:03:39 <AndroidShoutapop> Hmmm... how large is the minmal GHC?
08:04:19 <bennofs> AndroidShoutapop: large in terms of what? size of binary distribution? lines of source code?
08:04:36 <AndroidShoutapop> bennofs: The size of the source when built.
08:04:44 <vanila> Would anyone know a good channel to ask about compiler things?
08:05:52 <augur> vanila: what kind of compiler things?
08:05:54 <augur> ghc-specific compiler things, or compiler junk in general?
08:06:15 <bennofs> AndroidShoutapop: The build at http://www.haskell.org/ghc/download_ghc_7_8_3 for 64 bit linux is 69 MB when compressed with xz
08:06:45 <AndroidShoutapop> bennofs: Oh, that's the minimal GHC? Meh, can't fit.
08:06:58 <AndroidShoutapop> Thanks anyway.
08:07:11 <AndroidShoutapop> I guess I'll continue to use hugs for now.
08:07:22 <bennofs> AndroidShoutapop: hmm, I don't know of any stripped-down version of GHC
08:08:01 <bennofs> AndroidShoutapop: right, it includes docs and profiling support which could be disabled
08:08:14 <bennofs> AndroidShoutapop: so not minimal
08:08:30 <jgallag88> nvm I figured it out
08:08:37 <AndroidShoutapop> bennofs: Okay, thanks.
08:09:47 <Fuuzetsu> is there a function in a package somewhere which can try to ‘guess’ the encoding used in the file, to some confidence? Decoding functions in Text chuck exceptions on the wrong stuff, text-icu just replaces bytes it doesn't know with indicating characters… There seems to be good function for just reading a file into Text from possibly-varied-encoding-envorinment
08:10:16 <Fuuzetsu> of course it's not possible to guess right in general but I imagine someone would be annoyed if we read in as UTF8 and then wrote back out as UTF8 clobbering half the data because the encoding was wrong
08:10:35 <geekosaur> Fuuzetsu, guessing doesn't work very well
08:10:54 <geekosaur> it's something everyone wants and nobody seems to figure out that there's maybe a reason nobody provides it
08:11:08 <geekosaur> in particular there is no way to pick between all of the iso8859 encodings
08:11:18 <recliner> the linux program `file` is able to do it somehow
08:11:21 <bennofs> Fuuzetsu: ICU seems to have characters set detection but I read it's not exposed by text-icu
08:11:22 <Fuuzetsu> yes, I know it's not possible in general
08:11:26 <Fuuzetsu> but we can make guesses
08:11:34 <Fuuzetsu> bennofs: yes, I came to that conclusion too
08:12:00 <geekosaur> file can distinguish utf* from each other and from some-kind-of-iso8859, it also does halfassed guesses that are often wrong
08:12:23 <Fuuzetsu> geekosaur: half-assed guesses seem better than ‘we only deal with UTF8, sorry’ in a text editor
08:13:41 <AndroidShoutapop> Erm, so, if I understand this, "do" is the equivalent of begin in Lisp?
08:13:49 <Fuuzetsu> no
08:14:01 <vanila> augur, i guess just for functional languages in general - not haskell specific
08:14:33 <augur> vanila: i would bet that Pfenning's compiler class is appropriate
08:14:36 <Fuuzetsu> AndroidShoutapop: do is just sugar for sequences of >>= and >>, that's all
08:14:48 <augur> vanila: as a resource, i mean. not as a channel. :p
08:14:52 <augur> i dont think there is a channel
08:14:54 <AndroidShoutapop> Fuuzetsu: I see.
08:15:12 <augur> AndroidShoutapop: you shouldnt need to worry about do right now
08:15:23 <AndroidShoutapop> augur: Okay.
08:15:24 <Fuuzetsu> @undo do a; foo <- b; c foo; d;
08:15:24 <lambdabot> a >> b >>= \ foo -> c foo >> d
08:17:44 <c_my_nick> is there a special trick to replacing null characters within a Text?  i thought `T.replace "\0" "" x` would do the job, but the nulls still seem to be there
08:18:14 <Fuuzetsu> c_my_nick: did you try filter?
08:19:08 <Fuuzetsu> *Yi.Rope> TX.filter (/= '\0') (TX.pack "ab\0cdef\0eghi")
08:19:09 <Fuuzetsu> "abcdefeghi"
08:19:29 <c_my_nick> sec, trying now
08:20:24 <bennofs> Fuuzetsu: I found http://hackage.haskell.org/package/charsetdetect
08:21:48 <indiagreen> bennofs: it doesn't build due to overly strict upper bounds
08:22:05 <vanila> does he have a lot of handouts?
08:22:12 <vanila> i found the course page but not handouts
08:22:16 <Fuuzetsu> bennofs: yes, I saw that, still considering it
08:22:27 <indiagreen> I tried to get Max release a new version but ne didn't reply, so I just made a fork – charsetdetect-ae
08:22:42 <Fuuzetsu> it seems unpopular so I thought to ask, maybe there's something everyone else is using
08:23:19 <Fuuzetsu> bennofs: it seems to bundle all the C++ files of the underlying library…
08:24:00 <c_my_nick> Fuuzetsu: hm, same result.  maybe its not \0?  guess i will keep digging.  thanks anyway
08:24:38 <indiagreen> Fuuzetsu: I spent some time a while ago trying to find a library to guess encodings (to add automatic encoding guessing to Pandoc), and charsetdetect was the nicest one, I don't think anything has changed over this month
08:25:31 <bennofs> indiagreen: have you tried sending him an email? he replied when I asked him to upgrade temporary
08:25:43 <vanila> http://www.cs.cmu.edu/~fp/courses/15411-f14/schedule.html oh here!
08:27:14 <Fuuzetsu> indiagreen: hm, ok, guess I should try that; are you using it with text-icu?
08:27:21 <indiagreen> bennofs: yep, I sent an email
08:27:40 <indiagreen> and ne already has upper bounds removed in the repo, it just isn't uploaded on Hackage
08:31:11 <indiagreen> Fuuzetsu: what is text-icu for?
08:33:56 <Fuuzetsu> coercing ByteString → Text
08:33:58 <Fuuzetsu> (and back
08:33:59 <Fuuzetsu> )
08:51:17 * hackagebot partial-handler 0.1.0 - A composable exception handler  http://hackage.haskell.org/package/partial-handler-0.1.0 (NikitaVolkov)
08:53:04 <sm> the sandbox giveth, and the sandbox taketh away...
09:11:27 <monochrom> text-icu asks the C lib icu to do various character encodings
09:13:58 <Fuuzetsu> it seems text-icu Converter doesn't know about SHIFT-JIS ;;
09:16:20 * hackagebot opengles 0.5.0 - OpenGL ES 2.0 and 3.0 with EGL 1.4  http://hackage.haskell.org/package/opengles-0.5.0 (capsjac)
09:31:57 <nitrix> Is there such thing in Haskell as a circular list? In the sense that no matter where you start from (given an index), it'll iterate using the next elements, then eventually loop around to finish somewhere in the begining one element before where you begun?
09:32:31 <vanila> yes you can use cycle
09:32:36 <joelteon> yep
09:32:38 <nitrix> cycle?
09:32:40 <vanila> > cycle "foobar"
09:32:43 <lambdabot>  "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo...
09:32:50 <heatsink> nitrix: You can build a circular list.  But it's not easy to notice when you've returned to the starting point.
09:33:11 <nitrix> heatsink: Given the elements are unique, would it helps?
09:33:17 <Cale> Circular lists are indistinguishable from infinite lists
09:33:36 <Cale> But yeah, if you have unique ids or something
09:33:43 <heatsink> If the elements are unique and equality-comparable, you can check for equality
09:33:44 <Cale> you can notice when you arrive at one you'd seen before
09:33:48 <Cale> while traversing
09:33:49 <heatsink> yea
09:34:03 <nitrix> Right, but as long as I have the length of the original list (which is always fixed to 10), then I can break the cycle whenever I want?
09:34:07 <jhance> but can you build an infinite list that you can traverse in constant memory?
09:34:08 <nitrix> Alright.
09:34:16 <Cale> jhance: yes
09:34:21 <Cale> jhance: cycle does this
09:34:27 <Cale> @src cycle
09:34:28 <lambdabot> cycle [] = undefined
09:34:28 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:35:17 <Cale> If you look at what's going on with the variables there, it's pretty much the pointer manipulation that you'd do to build a singly linked circular list
09:35:40 <Cale> xs' has a tail which is itself
09:35:53 <Cale> (after the elements of xs)
09:36:21 * hackagebot yi-rope 0.5.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.5.0.0 (MateuszKowalczyk)
09:36:22 <Fuuzetsu> is there a reason it's not just cycle xs = xs ++ cycle xs
09:36:26 <Cale> yes
09:36:51 <Cale> Because that will result in a constant cost per element of the infinite list forever
09:36:52 <joelteon> i bet "where" does something special
09:36:55 <joelteon> just like let does in fix
09:37:12 <Cale> The result of cycle xs won't be memoised
09:37:21 <Fuuzetsu> I see
09:37:28 <Fuuzetsu> suspected as much
09:37:40 <Cale> It's the time cost more than the space cost which is usually problematic
09:37:47 <nitrix> Great so I managed to turn the thing into a cycle, man I love Haskell.
09:38:06 <nitrix> Although, now I'm really concerned because the elements will have to be mutable :/
09:38:10 <Cale> If you're consuming such a list in a reasonable way, it'd still be possible with your definition to end up with constant space
09:38:24 <Cale> But you keep doing allocations and those cost time
09:38:32 <joelteon> fortunately, it's not possible to mutate the list elements in Haskell
09:38:50 <Cale> (and you might have unbounded space, if you hold a reference to the beginning of the infinite list)
09:39:04 <nitrix> It probably means creating a new list everytime.
09:39:17 <Fuuzetsu> sure
09:39:24 <Cale> nitrix: Yeah, you might want to do something completely different
09:40:04 <nitrix> Let's explain then. It's a distributed file system, I must keep a finger to heads resources that are heavily changed.
09:40:13 <Cale> nitrix: For example, you might use something like Map Vertex (Vertex, a)
09:41:08 <nitrix> Every operation in the FS needs the current head and generates a new head. (That's not because of Haskell or anything, it's just the way this FS is designed, resources themselves cannot be deleted).
09:41:33 <Cale> i.e. a map from vertices to pairs consisting of the next vertex in the cycle, and the label for that vertex
09:42:13 <Cale> You can update this structure anywhere in O(log n) time where n is the number of vertices
09:42:36 <Cale> and when you do, you even get to keep the old version if you like :)
09:42:52 <nitrix> Too many words ;-;
09:43:34 <Fuuzetsu> pointedlist offers functions for cyclic traversal if you are after lists still
09:43:42 <Cale> many words, wow, such communication, so chat
09:44:10 <Cale> If you want *real* mutation, you have a bunch of options
09:44:17 <Cale> You could make a cyclic list of IORefs
09:44:34 <Cale> You could build a cyclic structure entirely out of IORefs
09:44:57 <Fuuzetsu> it's IORefs all the way down
09:45:00 <joelteon> If you generate a new head, why do you need a cyclic list?
09:45:08 <Cale> There are also STRefs if it's important to be able to eventually use this to implement a pure function
09:46:15 <sbrg> I'm writing a program that allows users to write regular expressions to do some stuff, in the configuration file. What library should I be going for? I don't know much about regular expressions, but I know there are different versions/standards, but I'd like to provide ones whose syntax most people are familiar with. What am I going for there? Posix compliance?
09:47:17 <kraljev9> Sorry for the noob question, but intellij is reporting this error:
09:47:20 <kraljev9> Information:cabal: cabal: ghc: missing -B<dir> option
09:47:27 <Cale> Well, there's POSIX and then there's PCRE (which despite standing for Perl Compatible Regular Expressions are apparently not really Perl compatible)
09:47:41 <nitrix> What happens is, I'll always iterate from the begining of the list, but if the current element (which is an endpoint) happens to have a defect, then the next one is used. There's also this weird corner case where, it's possible that while trying to handle a defect on a endpoint, another defect happens on your fallback endpoint, in which case, you kind of have to "offset" the cycle.
09:48:06 <dcoutts> kraljev9: smells like a seriously messed up ghc installation (or intellij is seriously confused about how to call ghc or cabal)
09:48:24 <nitrix> The worst case is always iterating the entire list, but the "begining" and "end" of the list is unknown, since it's kind of a recursive fallback strategy.
09:48:27 <nitrix> If that makes any sense.
09:48:29 <kraljev9> dcoutts, everything is fresh installed via cabal
09:48:40 <kraljev9> is it possible .config is misconfigured
09:48:54 <Cale> What is -B?
09:50:29 <kraljev9> I didn't find it in man or --help
09:51:44 <Cale> Does ghc work at all?
09:52:11 <Cale> Like if you just try compiling something with it, and/or loading ghci
09:52:22 <Cale> (not in intellij)
09:52:42 <kraljev9> yes, everything works
09:52:45 <kraljev9> ghc and ghci
09:52:48 <Cale> hmm
09:53:00 <kraljev9> also cabal and pacakge installation
09:53:42 <Cale> https://github.com/ghc/ghc/blob/master/compiler/main/SysTools.lhs#L366
09:53:53 <Cale> (probably of more use to other people trying to help you :)
09:54:02 <Cale> Let's see what this function is
09:56:23 <Cale> https://github.com/ghc/ghc/blob/207875293fea07aa90efe215369629b657d1875a/compiler/main/GHC.hs#L456 -- mb_top_dir here is the "-B option"
09:59:48 <bennofs> kraljev9: sounds like intellij is using the wrong ghc executable
10:00:10 <ezrios> are the semantics of the Either monad similar to that of Maybe?
10:00:29 <bennofs> kraljev9: ghc installs a wrapper script that passes a correct -B option normally
10:00:42 <kraljev9> there is only one ghc executable
10:00:42 <Cale> oh right!
10:00:54 <Cale> "ghc" is usually a shell script
10:00:55 <bennofs> kraljev9: -B refers to the "base dir", so that GHC can find where it's own libraries (like base) are
10:01:09 <Cale> and if you look at that shell script, it actually uses this option
10:01:16 <Cale> executablename="$exedir/ghc"
10:01:16 <Cale> exec "$executablename" -B"$topdir" ${1+"$@"}
10:01:32 <Cale> In my case, topdir="/usr/local/lib/ghc-7.8.2"
10:02:07 <capisce> how do you break an infinite recursion in ghci?
10:02:17 <bennofs> capisce: Control-C ?
10:02:45 <Cale> Yeah, Control-c should work
10:02:57 <capisce> no :(
10:03:02 <Cale> If it doesn't try Control-z
10:03:09 <capisce> there's no IO
10:03:13 <Cale> and then just kill %1 or something
10:03:15 <capisce> yeah
10:03:20 <capisce> just hoped I could avoid that
10:03:29 <Cale> You usually can
10:04:21 <Cale> I think possibly non-allocating loops can be a problem?
10:04:41 <bennofs> Sometimes, you need to press Control-C multiple times IME
10:05:02 <Cale> hm
10:05:39 <Cale> So that's good to know, ghc has a secret option for its configuration directory
10:08:02 <bennofs> Cale: yeah, if you want to make binary dists, you basically must have such an option (because the install dir cannot be compiled in)
10:10:27 <qq> @help
10:10:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:23:32 <jgallag88> I think I may have come across a bug in Happy, but maybe someone here can correct me
10:24:06 <jgallag88> When using monadic productions with %lexer, the form {% <expr> } works fine
10:24:36 <jgallag88> but both {%^ <expr> } and {%% <expr> } produce .hs files that won't parse with ghc
10:30:48 <qq> Could somebody explain to me what exactly happens in this expression: "flip . const (.) map" ? Is it the function flip applied to arguments . const (.) and then applied to map, or is it flip after const (.) map?
10:31:12 <qq> I'd be even more thankful for any link/s where to find out about this stuff.
10:33:21 <indiagreen> qq: where did you get this expression from? “const” and “map” seem redundant, as “const x y” can be replaced with “x”
10:33:53 <hexagoxel> @pointful flip . const (.) map
10:33:53 <lambdabot> (\ j b c -> j (c b))
10:35:29 <qq> indiagreen: It's related to a problem we're asked to solve (I'm not asking for a solution), so the expression is purposely redundant.
10:36:06 <trbent> replace map with something else and see how the result differs
10:37:05 <hexagoxel> qq: it is parsed as {flip . (const (.) map)}, which is equivalent to {(.) flip (const (.) map)}
10:37:27 <weissi> Hi there, I created a grammar with happy and it just doesn’t stop compiling in GHC (7.8) :-(
10:37:58 <weissi> ghc eats loads of memory and seems to do nothing when it’s supposed to output the “Representation types:”
10:39:13 <weissi> just sits there. Cancelled it last time after 70min of compiling. ghc and kernel_task (OS X) take huge amounts of memory and lots of CPU but it doesn’t seem to arrive anywhere. Ideas anyone? (running GHC with -v4 or -v5 to figure where it’s hanging)
10:39:58 <qq> hexagoxel: thanks a lot, but.. why would it be like this? I mean, there has to be a rule for what happened here, because seemingly "flip" should consider the "." and argument, since function application has the highest priority and starts from the left. Could you elaborate on this?
10:40:31 <nicksim> Hello, is there a a better monadic syntax sugar for writing [1,2,3] >>= (\x -> [x+1]) ?
10:40:56 <sbrg> > mapM (return . (+1)) [1,2,3]
10:40:58 <lambdabot>  No instance for (GHC.Show.Show (m0 [b0]))
10:40:58 <lambdabot>    arising from a use of ‘M593922029379430157326625.show_M5939220293794301573...
10:40:58 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
10:40:58 <lambdabot>  Note: there are several potential instances:
10:40:58 <lambdabot>    instance [safe] GHC.Show.Show a =>
10:41:06 <exio4> > [1,2,3] >>= return.(+1)
10:41:08 <lambdabot>  [2,3,4]
10:41:11 <qq> hexagoxel: *consider the "." an argument*
10:41:28 <hexagoxel> qq: the rule is something like "infix operators have lowest precedence"
10:41:33 <nicksim> thats nice
10:41:48 <exio4> why not map (+1) though :P
10:41:59 <nicksim> yeah right, thats probably sweeter
10:42:06 <hexagoxel> qq: but only if written as infix operators, not if you use parens, i.e. (.)
10:42:12 <nicksim> im just learning about monads, reading the wikibooks article, which is really great
10:42:34 <exio4> > Just 41 >>= return.(+1)
10:42:37 <lambdabot>  Just 42
10:43:01 <exio4> > Right 41 >>= return.(+1)
10:43:03 <lambdabot>  Right 42
10:43:07 <hexagoxel> qq: similarly, {f `const` g x} would be {const f (g x)} because `const` acts infix
10:45:41 <qq> hexagoxel: if they have the lowest precedence, shouldn't they be applied last?
10:46:28 <qq> as in 5 + 3 * 9. (*) has higher precedence than +, so the expression is equal "5+(3*9)"
10:47:16 <hexagoxel> qq: in {flip . const (.) map}, the first "." is applied last in the same sense!
10:47:30 <hexagoxel> flip . (const (.) map)
10:48:28 <qq> hexagoxel: but flip takes 3 arguments, why doesn't it use ".", "const", and "(.)" ?
10:49:03 <qq> I mean, why do functions 'eat up' their arguments but exclude . ?
10:49:08 <nicksim> This is impressive, but I don't fully understand to what expression it gets rewritten to, can someone help me?:           do { x <- [1,2,3]; y <- [10,20,30]; return (x+y) }
10:49:24 <qq> (sorry if I make no sense, I just started out with Haskell)
10:49:36 <benmachine> @undo do { x <- [1,2,3]; y <- [10,20,30]; return (x+y) }
10:49:37 <lambdabot> [1, 2, 3] >>= \ x -> [10, 20, 30] >>= \ y -> return (x + y)
10:49:46 <hexagoxel> qq: how would you parse f x + g y?
10:50:13 <nicksim> benmachine: Thanks a lot!
10:50:14 <qq> hexagoxel: (f x) + (g x)
10:50:25 <hexagoxel> qq: now replace "+" with "."
10:50:34 <qq> assuming they both take one argument only.
10:50:54 <hexagoxel> qq: number of arguments does not matter for parsing at all
10:51:08 <ezrios> @hoogle (a -> b -> c -> d) -> ((a,b,c) -> d)
10:51:10 <qq> what if f used 4 arguments? as in f a b c d = 5
10:51:13 <lambdabot> No results found
10:51:20 <hexagoxel> qq: btw you could say that function application has highest precedence, higher than any operator
10:51:58 <ezrios> how does one turn an n-ary function into a function that accepts an n-tuple?
10:52:00 <benmachine> qq: when parsing expressions, the parser has no idea how many arguments anything takes
10:52:36 <qq> hexagoxel: that's how I would deduce that if f used 4 arguments: "f a b c d = 5" , the expression would equal 5. But I'm wrong, apparently.
10:52:54 <qq> benmachine: how does it figure out what to do then?
10:53:27 <benmachine> qq: if you see "f +" in a program, that's never an application of f to +
10:53:31 <UnrealQuester> eziros: doesn't uncurry do that for 2 arguments?
10:53:42 <ezrios> UnrealQuester: yes, but I am looking for n arguments
10:53:45 <ezrios> or at least in my case, four
10:53:56 <benmachine> qq: when you're scanning an expression and it contains an infix operator like that, then you slice it into two halves and the expression is the application of the operator to the left half and the right half
10:54:31 <benmachine> qq: if you want to apply a function to an operator, you have to write something like 'f (+)'
10:54:41 <benmachine> those parens stop it from being parsed as an infix application
10:54:49 <qq> benchmachine: so.. functions can never (ever) use infix functions as arguments?
10:55:01 <benmachine> qq: sure they can, they just don't do it like that
10:55:15 <weissi> does anybody know what the “evacuate1” function in GHC does?
10:55:24 <weissi> (in GHC == in GHC’s code)
10:55:39 <qq> "flip (-) 5 4" works, but "flip - 5 4" doesn't.
10:55:41 <benmachine> weissi: your question might be answered here, but you might also want to try #ghc
10:55:58 <weissi> benmachine: oh, nice thanks, didn’t know about #ghc
10:56:00 <UnrealQuester> eziros: there is the tuple package
10:56:02 <benmachine> qq: right, because the second one is (flip) - (5 4)
10:56:12 <UnrealQuester> does that do what you want?
10:56:20 <hexagoxel> qq: functions themself are not infix or not, only the usage is. if you want use (.) infix, you write ".". if you want to use const infix, you write `const`
10:56:30 <benmachine> ezrios: whenever I do that I just use a lambda
10:56:38 <qq> benmachine: what do you mean 'sure they can, they just don't do it like that' ? (I'm really sorry to be spamming the primary channel, but I couldn't find any better place to ask questions)
10:56:51 <hexagoxel> qq: and to just pass the the function, use the non-infix form
10:56:59 <benmachine> qq: you're not spamming, you're doing what the channel was invented for :)
10:57:19 <benmachine> qq: I mean you can pass infix operators as arguments to functions, but you have to put parens around them first
10:57:40 <benmachine> so it's true that 'f +' is not application of f to +, but if you want to apply f to + you just do 'f (+)' instead
10:58:08 <hexagoxel> also, people are free to point out any tutorial that explains parsing to prevent further discussion :D
10:58:47 <qq> so, infix notation implies end of arguments for any function? whereas prefix notation allows to use a function with non-alphabet name as argument?
10:59:20 <benmachine> I think that sounds right
10:59:30 <hexagoxel> > ( (+) 3 . (*) 5 ) 2
10:59:32 <lambdabot>  13
10:59:48 <benmachine> "non-alphabet" is not quite right, pedantically
11:00:07 <hexagoxel> qq: look at how (+) and (*) take two arguments, but are applied with only one here.
11:00:26 <qq> (I would guess that people on the primary channel have better things to do than answer kindergarden questions.. but I swear, I couldn't any information on this anywhere.. and learn you a haskell for greater good seems to leave this out completely)
11:00:28 <benmachine> e.g. normal names can have numbers, underscores, and other stuff in them, operator names can only have symbols in them (and no reserved symbols, which is sadly quite a few of them)
11:00:43 <benmachine> qq: if I had something better to do I would be doing it :P
11:00:44 <hexagoxel> qq: there is #haskell-beginners :)
11:01:19 <hexagoxel> but i would not care unless there were other discussions going on in parallel
11:01:46 <benmachine> yeah, I mean it's often enough we talk about things that aren't even haskell
11:01:52 <benmachine> we can cope with a few newbie questions
11:02:55 <qq> "( (+) 3 . (*) 5 ) 2 = 13" it's starting to make sense now. Thanks.
11:03:17 <qq> my bad, I just looked at http://www.haskell.org/haskellwiki/IRC_channel which lists #haskell and #haskell-in-depth and followed.
11:03:57 <benmachine> hexagoxel: does #haskell-beginners get enough foot traffic that we should recommend it to people?
11:04:11 <Yxven> #Haskell-beginners would benefit from having more knowledgeable people to answer questions
11:04:57 <hexagoxel> > (+) 3 . (+) 5 $ 2  -- (advanced :D) qq
11:05:00 <lambdabot>  10
11:05:05 <hexagoxel> oops
11:05:12 <hexagoxel> > (+) 3 . (*) 5 $ 2  -- (advanced :D) qq
11:05:14 <lambdabot>  13
11:05:50 <qq> I'll try to use the channel in future, so I might report back to you guys with empiric results later.
11:06:41 <Fuuzetsu> Yxven: I think the problem is that people don't tend to look at -beginners
11:07:49 <qq> I've seen the $ operator before, used it few times.. the thing is, it seems that Haskell materials are somewhat scarce, my uni doesn't offer too much, the errors are cryptic, so I have to annoy more experienced users.
11:08:45 <hexagoxel> benmachine: yeah not sure. there are a few people that can answer beginners questions; but i noticed a few times that people asked not-so-beginner questions (in which case i tend to tell them to go to #haskell)
11:09:12 <hexagoxel> but it is definitely a good place for in-depth beginner explanations, imho
11:16:23 <qq> would you mind a follow up question? I'm going with the "flip . const (.) map" which should be " flip . (.)" (the types match). Now, I add the argument x: "(flip . (.)) x". X is used by (.), which becomes a function that requires one more argument, and is 'returned' to flip. Flip takes a function and two arguments. The function in flip only needs one argument, so the first argument will fit, but what about the second one? I mean, how c
11:17:22 <FireFly> qq: your message was cut off: "I mean, how c"
11:17:52 <qq> "I mean, how can that even work?"
11:19:19 <benmachine> qq: I'm confused by your question a little, but I think I can help anyway
11:20:03 <benmachine> part of it is that if you take one argument and return a function, that's indistinguishable from taking two arguments
11:20:28 <qq> let me restate: ...
11:20:34 <benmachine> so when you say something like "the function passed to flip needs two arguments" you can also view it as taking one argument, or even three if it takes two and returns a function
11:20:54 <benmachine> I agree that flip . const (.) map is flip . (.)
11:21:06 <benmachine> which is (\f -> flip ((.) f))
11:21:17 <benmachine> which is (\f x y -> ((.) f) y x)
11:21:31 <benmachine> which is (\f x y -> (f . y) x)
11:21:37 <benmachine> which is (\f x y -> f (y x))
11:23:18 <qq> "(flip . (.)) x" what happens is "flip ( (.) x)". Flip got a function that needs only one argument, but it should only accept a function that need two.
11:23:59 <benmachine> right, but a function that needs only one argument and returns a function is a function that takes two arguments
11:24:17 <benmachine> and indeed (.) x returns a function if you give it another argument
11:24:50 <benmachine> in particular, (.) x y z makes sense, and it's the same as (x . y) z
11:24:55 <benmachine> which is x (y z)
11:26:42 <qq> huh. You lost me there. I thought that flip by definition requires a function that accepts two arguments. "flip :: (a -> b -> c) -> b -> a -> c".
11:27:00 <exio4> and returns a c
11:27:05 <exio4> could be another function
11:27:07 <benmachine> a -> b -> c is the same as a -> (b -> c)
11:27:11 <qq> I mean, I can see why (.) x y z is (x . y) z, but not the whole picture.
11:27:39 <benmachine> let's see
11:27:46 <benmachine> :t (.) ?x
11:27:48 <lambdabot> (?x::b -> c) => (a -> b) -> a -> c
11:27:53 <hexagoxel> in a->b, b can be c->d
11:27:54 <benmachine> if x :: b -> c
11:28:01 <benmachine> then (.) x :: (a -> b) -> a -> c
11:28:11 <benmachine> this fits your type for flip
11:28:16 <benmachine> hmm, let's use different letters
11:28:34 <benmachine> then (.) x :: (p -> q) -> p -> r
11:28:46 <benmachine> and it works if you take b = p, c = r, a = p -> q
11:29:04 <qq> I'm sorry to be a slow responder, but I have to think about this a lot to get it.
11:29:35 <FireFly> I think that's a good thing
11:29:56 <FireFly> Not rushing through things without properly learning them, I mean
11:30:52 <qq> well, I'm barely out of high school, this is outside my college curriculum - we have the basic haskell stuff there, but it's more like learning a few rules here and there, which has never worked for me.. I need to play around with stuff, and when I play around with haskell, it doesn't work :D
11:33:26 <qq> I see why operator sections / partial application would work, but the "whole picture" doesn't make sense to me. Few more minutes.
11:34:49 <hexagoxel> qq: also note that "requiring two arguments" means "at least two arguments"
11:34:55 <hexagoxel> :t (,,)
11:34:56 <lambdabot> a -> b -> c -> (a, b, c)
11:35:00 <hexagoxel> :t flip (,,)
11:35:01 <lambdabot> b -> a -> c -> (a, b, c)
11:36:20 <exio4> :t (flip .)
11:36:22 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
11:36:43 * hackagebot yi-rope 0.5.0.1 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.5.0.1 (MateuszKowalczyk)
11:37:47 <hexagoxel> exio4: eww, a section :)
11:38:11 <monochrom> qq, it helps to follow a systematic course, http://www.seas.upenn.edu/%7Ecis194/spring13/index.html
11:38:15 <exio4> :t ((.) flip)
11:38:16 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
11:38:19 <exio4> hexagoxel: there, happy?
11:38:22 <exio4> :P
11:39:01 <hexagoxel> yes, now qq might be able to parse it without yet another concept :)
11:46:53 <qq> I can see why  if x :: b -> c, then (.) x :: (a -> b) -> a -> c, but I don't quite understand the flip thing. "flip ( (.) x )" - the first argument needs one more function to be 'done'. The resulting function would need one argument to "fire up" the composition. In total, those would be two arguments.
11:47:27 <Fuuzetsu> :t flip id
11:47:29 <lambdabot> b -> (b -> c) -> c
11:47:45 <qq> a deduction chain like that kinda makes sense, but I can't say I feel comfortable. It's getting late here, so I'll use that as an excuse.
11:48:15 <haasn> Haskell type checking doesn't use much “deduction” - you can type check using fairly mechanical rules
11:48:26 <haasn> It's just matching pieces together and comparing variables/types
11:48:41 <qq> :monochrom  that's nice, I'll check it out.
11:48:58 <haasn> ‘flip id’ is probably a useful thing to understand
11:50:19 <pablo|> is there a class like MonadWriter, but with just 'tell', written somewhere?
11:51:26 <sbrg> Is there a recommended way to convert from the unix packages's Posix.Files EpochTime to some better type that I can more easily deal with in Haskell?
11:51:42 <monochrom> qq: if I have a polymorphic "f :: a -> a", it can very well be used as (Int -> Bool) -> (Int -> Bool), i.e., plug Int->Bool into a. now suddenly I have a "2-parameter" function.
11:52:03 <redtricycle> How do I xor hex bytes?  I need to go from hex->binary and then xor binary (string?)
11:52:03 <monochrom> similar things can happen to (.), flip, ($), etc etc
11:52:07 <redtricycle> xor takes two booleans..
11:53:04 <sbrg> redtricycle: yhmm? you have to fill out the definition for an xor :: Bool -> Bool -> Bool ?
11:53:26 <redtricycle> I am trying to use xor from Data.Bits
11:53:30 <monochrom> at the end you may find that the whole notion of "this function takes n parameters" is not always useful
11:53:32 <redtricycle> to do this: http://cryptopals.com/sets/1/challenges/2/
11:53:51 <qq> If I saw "flip id", i'd say it should be used this way: flip id 5 7, which results in id 7 5, (d 7) is just 7, so the result would be 7 5. (seven with five.. which makes no sense. duh.)
11:54:13 <qq> monochrom: I think I'm getting to that.
11:54:31 <monochrom> to be sure, during code optimization, the compiler does count parameters and do special efficient things for "it's 1 parameter", "it's 2 parameters", etc. but that's at the stage of code optimization. during type checking, counting parameters can be misleading.
11:54:40 <sbrg> redtricycle: convert both hex strings to a list of ints
11:54:47 <sbrg> zipWith xor the lists
11:54:58 <sbrg> 'convert' back to hex
11:55:05 <hexagoxel> > flip id "abc" length
11:55:07 <lambdabot>  3
11:55:17 <qq> yeah it works if you follow the type.
11:55:27 <qq> but I don't see 'why would it possibly work'.
11:55:35 <hexagoxel> haskell is all about following the type!
11:55:50 <hexagoxel> @src flip
11:55:50 <lambdabot> flip f x y = f y x
11:56:45 * hackagebot neil 0.3 - General tools for Neil  http://hackage.haskell.org/package/neil-0.3 (NeilMitchell)
11:56:53 <qq> flip id x y = id y x ..... flip id 5 7 = id 7 5
11:57:02 <hexagoxel> flip id "abc" length -> id length "abc" === (id length) "abc" -> length "abc"
11:57:16 <sbrg> > let chunk2 xs | null xs = [] | take 2 xs : chunk2 (drop 2 xs) in map (\chunk -> fst . head $ readHex chunk) "deadbeef" :: [Int]
11:57:18 <lambdabot>  <hint>:1:63: parse error on input ‘in’
11:57:34 <redtricycle> sbrg sounds like a plan, I guess I'm looking for xor' :: Bit -> Bit -> Int
11:57:34 <sbrg> @let chunk2 xs | null xs = [] | take 2 xs : chunk2 (drop 2 xs)
11:57:35 <lambdabot>  Parse failed: Parse error: EOF
11:57:54 <sbrg> redtricycle: that's unnecessary
11:57:58 <qq> argh, I get it.
11:58:10 <qq> I mean, the flip id "abc" length part.
11:58:24 <sbrg> @let chunk2 xs = if null xs then [] else take 2 xs : chunk2 (drop 2 xs)
11:58:27 <lambdabot>  Defined.
11:58:46 <sbrg> > map (\chunk -> fst . head $ readHex chunk) "deadbeef" [Int]
11:58:49 <lambdabot>  Not in scope: data constructor ‘Int’
11:58:49 <lambdabot>  Perhaps you meant one of these:
11:58:49 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
11:58:49 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
11:58:49 <sbrg> > map (\chunk -> fst . head $ readHex chunk) "deadbeef" :: [Int]
11:58:51 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
11:58:51 <lambdabot>  Expected type: [GHC.Base.String]
11:58:53 <lambdabot>    Actual type: [GHC.Types.Char]
12:00:06 <qq> I'm gonna eat something and get back. Or actually, I'll think about the stuff you told me today, sleep on it, and then get back. No sense in stretching your patience. I'll hit the haskell-beginners first, so hopefully someone will be there. Thanks again guys, you've been helpful a ton.
12:00:31 <sbrg> > map (\chunk -> fst . head $ (readHex chunk :: [(Int, String)]) "deadbeef"
12:00:33 <lambdabot>  <hint>:1:74:
12:00:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:00:39 <sbrg> > map (\chunk -> fst . head $ (readHex chunk :: [(Int, String)])) "deadbeef"
12:00:41 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
12:00:41 <lambdabot>  Expected type: [GHC.Base.String]
12:00:41 <lambdabot>    Actual type: [GHC.Types.Char]
12:00:44 <sbrg> oh for fuck's sake
12:01:28 <sbrg> > map (\chunk -> fst . head $ readHex chunk) (chunk2 "deadbeef") :: [Int]
12:01:30 <lambdabot>  can't find file: L.hs
12:01:37 <sbrg> well that's great.
12:01:49 * sbrg sits in a corner
12:02:02 <sbrg> redtricycle: something like the above, anyway
12:02:04 <sbrg> what I was trying
12:02:59 <redtricycle> ok, i'll try it out
12:03:42 <lpaste> chpatrick pasted “reifyTypeRep and dynamic application” at http://lpaste.net/112849
12:04:08 <zwer> > map (\chunk -> fst . head . readHex $ chunk) (chunk2 "deadbeef")
12:04:10 <lambdabot>  [222,173,190,239]
12:04:18 <zwer> > map (fst . head . readHex) (chunk2 "deadbeef")
12:04:21 <lambdabot>  [222,173,190,239]
12:09:35 <redtricycle> > chunksOf 2 "68697420"
12:09:37 <lambdabot>  ["68","69","74","20"]
12:12:34 <redtricycle> > map (fst . head . readHex) $ chunksOf 2 "68697420"
12:12:36 <lambdabot>  [104,105,116,32]
12:12:56 <redtricycle> > map (fst . head . readHex) $ chunksOf 2 "1c0111"
12:12:58 <lambdabot>  [28,1,17]
12:13:06 <redtricycle> > map (fst . head . readHex) $ chunksOf 2 "1c0111,10"
12:13:07 <lambdabot>  [28,1,17,*Exception: Prelude.head: empty list
12:13:12 <redtricycle> > map (fst . head . readHex) $ chunksOf 2 "1c011110"
12:13:14 <lambdabot>  [28,1,17,16]
12:13:28 <redtricycle> OK, now how do I xor [104,105,116,32] with [28,1,17,16]?
12:13:37 <chpatrick> zipWith?
12:14:05 <FireFly> @ty xor
12:14:06 <lambdabot> Bits a => a -> a -> a
12:14:26 <redtricycle> > zipWith xor [104,105,116,32] [28,1,17,16]
12:14:28 <lambdabot>  [116,104,101,48]
12:14:40 <redtricycle> > chr [116,104,101,48]
12:14:42 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:14:42 <lambdabot>              with actual type ‘[t0]’
12:14:50 <redtricycle> > map chr [116,104,101,48]
12:14:52 <lambdabot>  "the0"
12:14:55 <redtricycle> ooo
12:16:24 <zwer> > chunksOf 0 [1..5]
12:16:26 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
12:21:07 <NougatRillettes> :t runST . (\a -> (newSTRef a) >>= readSTRef )
12:21:08 <lambdabot>     Couldn't match type ‘ST s0 b’ with ‘forall s. ST s c’
12:21:09 <lambdabot>     Expected type: ST s0 b -> c
12:21:09 <lambdabot>       Actual type: (forall s. ST s c) -> c
12:21:21 <NougatRillettes> :t \ x -> runST $ (\a -> (newSTRef a) >>= readSTRef ) x
12:21:22 <lambdabot> a -> a
12:21:41 <NougatRillettes> does anyone know why the first one can't be correctyle type-checked ?
12:21:48 * hackagebot hspec-snap 0.3.0.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.0.0 (DanielPatterson)
12:21:55 <NougatRillettes> *correctly
12:23:21 <monochrom> to accept it, you need to instantiate a type variable to a forall type. to be able to do this is the definition of impredicative types. but GHC doesn't do it.
12:23:38 <redtricycle> how do I turn dec to hex in base16?
12:23:53 <redtricycle> i.e. convertDec2Hex 116 gets me "74"
12:24:09 <redtricycle> convertDec2Hex :: Int -> ByteString
12:24:23 <redtricycle> Or whatever the best representation of two-byte hex is
12:24:44 <geekosaur> > showHex 116 ""
12:24:46 <lambdabot>  "74"
12:24:53 <geekosaur> @index showHex
12:24:53 <lambdabot> Numeric
12:25:07 <monochrom> the $ case enjoys a special hard-coded clutch in GHC
12:25:17 <monochrom> by popular demand
12:25:32 <NougatRillettes> hmm
12:25:40 <NougatRillettes> :t \ x -> runST ( (\a -> (newSTRef a) >>= readSTRef ) x)
12:25:41 <lambdabot> a -> a
12:25:44 <redtricycle> > map showHex [116,104,101,32]
12:25:45 <lambdabot>  [<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>]
12:25:54 <sbrg> redtricycle: showHex
12:25:57 <sbrg> oh
12:25:59 <sbrg> too late
12:26:04 <NougatRillettes> I don't understand why this one works then
12:26:11 <redtricycle> > intersperse "" $ map showHex [116,104,101,32]
12:26:12 <lambdabot>  Couldn't match type ‘GHC.Base.String -> GHC.Base.String’
12:26:12 <lambdabot>                with ‘[GHC.Types.Char]’
12:26:12 <lambdabot>  Expected type: a0 -> [GHC.Types.Char]
12:26:12 <lambdabot>    Actual type: a0 -> GHC.Show.ShowS
12:26:18 <sbrg> > map (flip showHex "") [116,104,101,32
12:26:19 <lambdabot>  <hint>:1:38:
12:26:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:26:20 <geekosaur> showHex is slightly tricky, it produces a ShowS
12:26:22 <sbrg> > map (flip showHex "") [116,104,101,32]
12:26:22 <redtricycle> > map showHex [116,104,101,32]
12:26:23 <lambdabot>  ["74","68","65","20"]
12:26:24 <lambdabot>  [<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>,<[Char] -> [Char]>]
12:26:28 <geekosaur> which is wht I had the "" in the end
12:26:30 <redtricycle> ah...
12:26:41 <redtricycle> flip looks useful
12:26:44 <sbrg> it is
12:27:11 <sbrg> However, if you find yourself constantly using it for functions you wrote yourself, it's a good indicator that you probably want the 'arguments' in reverse order in the definition
12:27:35 <monochrom> that one just needs function application to work well with rank-n types. function application is built-in, unlike ($) or (.) which have type variables to instantiate. the requirement is much weaker than impredicative types.
12:28:17 <monochrom> GHC has correct implementation of rank-n types, but not impredicative types.
12:28:37 <NougatRillettes> ok, I guess I'm getting it
12:29:57 <NougatRillettes> Would impredicative types broke he "phantom s type in ST for safety" feature ?
12:30:04 <monochrom> no
12:30:37 <NougatRillettes> ok thx
12:30:57 <geekosaur> impredicative types are broken not because they would cause problems, but because nobody's figured out how to do them properly
12:31:05 <geekosaur> every attempt has had something wrong with it
12:31:59 <redtricycle> So how do people typically comment their haskell code?
12:32:05 <redtricycle> I get a lot of functions with one line
12:32:07 <redtricycle> and lots of chaining
12:32:22 <redtricycle> so it looks like pack $ map $ (some . more . things) $ crazyListHelper the_list
12:32:30 <redtricycle> do you comment each step or let it speak for itself?
12:32:58 <bennofs> redtricycle: I only comment top-level functions most of the time
12:33:14 <monochrom> I write comments to tell you what you cannot guess
12:33:23 <bennofs> redtricycle: sometimes, also bindings in where / let  or arguments if they're complicated
12:33:49 <Earnestly> -- And now for the tricky part
12:33:51 <monochrom> that is for internal documentation
12:34:06 <monochrom> for external documentation, I write everything to tell you how to use it
12:34:14 <exio4> if the line is too large, I would split it into more "helper" functions too
12:35:00 <monochrom> external documentation = specification. internal documentation = why the implementation satisfies the specification
12:35:34 <monochrom> and sometimes why I choose this approach instead of a million other conceivable approaches
12:39:51 <NougatRillettes> Does anyone know why instance (MonadTrans t, MArray a e m, Monad (t m)) => MArray a e (t m) is not a default in Data.MArray ?
12:41:01 <monochrom> that's an interesting thought.
12:43:40 <NougatRillettes> (I've just facing issued while trying to use an STArray inside a ReaderT, which seems quite a common thing to me)
12:46:38 <gfixler> I have an app that can take Python command strings via socket connection
12:46:55 <gfixler> the FFI approach is well beyond me at this point
12:47:02 <gfixler> so I'm considering aping its calls from Haskell
12:47:20 <gfixler> i.e. I'll write Haskell functions that emit Python strings
12:47:38 <gfixler> the API is all IO stuff
12:47:53 <gfixler> is there anything I might not be considering, especially in terms of program control flow?
12:49:57 <gfixler> I think my control flow concerns had to do with kicking out whole Python programs
12:50:10 <gfixler> but if I let Haskell be the program, and just kick out Python calls where necessary...
12:51:52 * hackagebot boomange 0.1.0.1 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.0.1 (mgmillani)
12:56:52 * hackagebot boomange 0.1.0.2 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.0.2 (mgmillani)
13:01:53 * hackagebot boomange 0.1.0.3 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.0.3 (mgmillani)
13:06:04 <pilz> Hi. Is there a shortcut for "myFunction _ _ _ = 0", maybe "myFunction ... = 0"?
13:08:41 <sbrg> i don't think so
13:08:55 <sbrg> you can in some cases make patterns nicer using pattern synonyms -- this is not one of those cases, unfortunately
13:11:54 * hackagebot stm-containers 0.1.4 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.1.4 (NikitaVolkov)
13:12:51 <Geraldus> Hi folks! I've issue with permissions when trying `cabal install cabal-install` on Win 8.1. Does anybody knows how to fix it?
13:13:07 <sbrg> Geraldus: we can't know how to fix the issues if we don't know what the issues are
13:14:24 <Geraldus> sbrg: Hold a while
13:16:21 <sbrg> Acknowledged. Systems on hold.
13:17:47 <MP2E> lol
13:17:57 <Geraldus> here is error message https://gist.github.com/geraldus/8a83f45598e31cd32d00
13:18:22 <sbrg> Systems reinitializing.
13:18:32 <MP2E> run the terminal as admin and try again
13:18:44 <sbrg> yeah, what he said
13:19:08 <sbrg> Geraldus: if you type command prompt into the windows start menu search bar, hold shift and right click on command prompt, it should show you "run as administrator"
13:19:53 <Geraldus> sbrg: I'll try
13:20:37 <jle`> pilz: what would the type be?
13:22:32 <Geraldus> sbrg: looks like it works. Bur is it good idea to install packages with administrator privilegies on Windows, on Linux it's definetely not.
13:25:47 <sbrg> Geraldus: in this case, it's just because windows is obnoxious, I think. I don't think you need to be afraid of breaking anything. On linux, it isn't necessary for cabal because it's going to save them in your home directory (or preferably, a sandbox)
13:26:07 <sbrg> but you don't have write permissions by default to wherever you have cabal installed, it seems, on windows
13:27:10 <monochrom> I wonder what caused the permission denial. it looks like a perfectly user-generated, user-owned executable and should be permitted execution by user.
13:27:26 <Geraldus> sbrg: Yes. I have not problems on Linux. Windows is obnoxious, it's true :)
13:28:49 <monochrom> afterall it's merely "cabal install cabal-install" not "cabal install --global cabal-install"
13:29:03 <Geraldus> monochrom: I've fresh install of Haskell Platform. When I tried to install Sodium my PC crashed, so I had to purge user's cabal directory, after that permission issue came
13:33:33 <Geraldus> Thanks folks, that's all for now.
13:35:37 <NougatRillettes> Ist here a way to "switch" two monads ? I'm affraid I'm getting confused, but I'd like to do m1 (m2 a) -> m2 (m1 a)
13:36:16 <k00mi> not in general, no
13:36:39 <pjdelport> NougatRillettes: There is traverse / sequence, which might be what you want?
13:37:42 <pjdelport> :t T.sequence
13:37:43 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
13:37:58 <pjdelport> :t T.sequenceA
13:37:59 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
13:38:13 * merijn mumbles something about AMP
13:39:33 <NougatRillettes> hm, I can't figure out how to use Traversable in my case...
13:39:43 <NougatRillettes> The situation is :
13:40:29 <NougatRillettes> I've got a class Monad m => Interreact m where query :: Char -> m Bool | send (Char,Bool) -> m ()
13:40:50 <NougatRillettes> and i want to query something and store it in a STUArray
13:41:03 <NougatRillettes> but have the Interreact Monad Inside the ST monad
13:41:22 <pjdelport> :t T.sequence
13:41:23 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
13:42:12 <NougatRillettes> yeah but ST s isn't traversable
13:42:43 <pjdelport> NougatRillettes: Sorry, that latest message wasn't intended; IRCCloud sometimes randomly seems to delay and duplicate messages by ~5 minutes for me.
13:42:44 <monochrom> my high-level advice is: don't solve the general problem.
13:42:56 <pjdelport> (No idea why it does that.
13:43:12 <NougatRillettes> no problem pjdelport
13:43:35 <monochrom> my specific advice is: you could implement "instance Interreac (ST s) where ..."
13:44:12 <monochrom> or if you're doing "ReaderT X (ST s)" you could implement "instance Interreact (ReaderT X (ST s)) where ..."
13:44:33 <pilz> jle`: a number of wildcards don't say much about the type either. I was hoping for some sugar for catchalls at the end of a function definition.
13:44:34 <the193rd> Good evening, my Haskell friends
13:44:56 <NougatRillettes> hm monochrom I dont see how I could do that
13:47:07 <the193rd> I need to practise my new keyboard layout — I thought joining a chat might help. :)
13:47:41 <monochrom> have you written any instance code for any class?
13:49:56 <NougatRillettes> well the problem is that in what you describe Interreact would become a monad transformer
13:50:07 <monochrom> no, that is false.
13:50:11 <NougatRillettes> hmmm
13:50:16 <JagaJaga> How to make a ByteString from String?
13:50:23 <NougatRillettes> give me 5 minutes to write it down calmly
13:50:37 <nitrix> How would I iterate a list in haskell while being able to stop at any point?
13:50:43 <monochrom> one instance is a ReaderT thingie, yes. but that is just one instance.
13:50:47 <zwer> @hoogle String -> ByteString
13:50:50 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
13:50:50 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
13:50:50 <lambdabot> Prelude error :: [Char] -> a
13:51:40 <monochrom> Jack the Ripper is a human. that does not imply, suddenly, humanity has become a class of murderers.
13:51:48 <nitrix> More precisely, I want to iterate a list, call a function with each elements, BUT, depending on the return value of the function, stop the iteration/mapping process.
13:52:14 <nitrix> I looked at sequence but it's confusing.
13:52:41 <JagaJaga> zwer: thx.
13:52:51 <NougatRillettes> monochrom you're right
13:52:55 <capisce> how do I explicitly refer to Prelude's (.) function?
13:53:01 <NougatRillettes> I was really Lost :D
13:53:07 <capisce> :t Prelude.. doesn't work, and neither does :t Prelude.(.)
13:53:08 <lambdabot> parse error on input ‘Prelude..’
13:53:28 <geekosaur> :t (Prelude..)
13:53:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:53:34 <capisce> thanks :)
13:54:03 <monochrom> although, when Saint Theresa was a human, people do say, suddenly, that shows the good of the whole humanity class.
13:54:28 <NougatRillettes> But, there is still a problem : if I want to make instance Interreact (ST s) where .. it doesn't really make sense
13:54:48 <NougatRillettes> Interreact would in most case used the IO instance I will make of it
13:54:51 <joelteon> Prelude, I..
13:54:52 <merijn> nitrix: Manual recursion or a fold
13:55:05 <merijn> nitrix: The manual recursion is probably significantly easier
13:55:17 <monochrom> ok, then it's ReaderT X IO, and you use an IOUArray.
13:55:23 <nitrix> merijn: I think so too. I had a look at fold and it scared me.
13:56:01 <merijn> Nothing wrong with manual recursions
13:56:01 <nitrix> merijn: Now I just need to wrap my head around functional programming-style and write my first recursive function in haskell that isn't just theory.
13:56:12 <NougatRillettes> yeah that would be a workaround monochrom
13:56:13 <nitrix> Nah I know, just new at this :)
13:56:20 <NougatRillettes> but I'd rather stick to ST array
13:56:26 <NougatRillettes> and keep IO for real IO
13:56:43 <Ralith> carter: is there an existing lib that provides a good type for extremely long lists with fast random access and append?
13:56:46 <merijn> nitrix: Also, maybe you'll finish writing the manual recursion and afterwards realise "oh, I can trivially translate this to a fold", but trying to do that right away is really confusing :)
13:56:54 <monochrom> you can use an STUArray and keep calling stToIO. but it looks indirect.
13:57:22 <carter> Ralith: finger trees or squence?
13:57:23 <NougatRillettes> yeah, don't like it either
13:57:46 <monochrom> indirectness is the root of http://xkcd.com/763/
13:57:59 <merijn> carter: Isn't Sequence a finger tree anyway? :)
13:58:04 <carter> prboably
13:58:19 <Ralith> carter: er, I was unclear
13:58:21 <NougatRillettes> the thing that annoys me the most is that I managed to do the send part
13:58:26 <Ralith> carter: I need random *read* but I expressly do not need random write
13:58:27 <NougatRillettes> and get my monads in the right order
13:58:37 <nitrix> merijn: Actually, I'd prefer it this way, to actually figure out what I'm doing. Yesterday I wrote a very long function, took me a while to figure out, and right now (because I'm blocked and grasping more concepts), it's slowly shrinking in size :P
13:58:49 <nitrix> merijn: It's a beautiful thing to watch c:
13:59:07 <pjdelport> Ralith: For random-access indexing, there's Array, but i don't know if there's something that has Array-like indexing with cheap appends.
13:59:27 <carter> Ralith: so you want something like an IntMap
13:59:36 <carter> or structures
13:59:56 <carter> https://github.com/ekmett/structures might fit the bill
13:59:59 <carter> needs some more TLC
14:01:34 <merijn> nitrix: FWIW I still often start with 100-200 lines of code and as I slowly refactor and simplify it frequently reduces to less than 20 lines in the end
14:02:03 <merijn> nitrix: The fact that purity and types let you easily rip out and shuffle code parts is one often understated benefits of haskell, imo
14:03:00 <Ralith> carter: hm, I think I'll go with sequence until it's too slow
14:03:09 <carter> thats the least yak shaving way
14:03:25 <nitrix> I understand that. It's just getting there that is tricky. My application is full of IO all over the place. I might write the first non-IO function today, and god, the complexity of it surely doesn't help learning Haskell xD
14:03:33 <nitrix> BUT, it's challenging so it's fun (:
14:04:44 <nitrix> Just solving the domain problem is messing up with my head; being unable to figure out the code in advance too makes it worse xD
14:05:02 <jhance> having so much IO isn't really a good sign....
14:05:33 <nuttycom> Hey, all, newbie sandbox question: I'm starting out with a brand-new clean sandbox, trying to build a project that I haven't worked on in a bit, and I'm getting the following error: https://gist.github.com/nuttycom/dc442de9faec92fbf5af
14:05:57 <nuttycom> I thought that sandboxes were supposed to be isolated such that —force-reinstalls wasn't necessary any more?
14:06:30 <merijn> nuttycom: Is it a clean sandbox?
14:06:30 <monochrom> having much IO is good or bad depending on the task.
14:06:44 <merijn> monochrom++
14:06:51 <geekosaur> nuttycom, sandboxes only protect local packages, those packages will be global
14:06:52 <merijn> I write tons of haskell with IO everywhere
14:06:57 <monochrom> "a program to accept a filename over a socket and send the file content" must be full of IO.
14:07:00 <nuttycom> merijn: yeah, I just did a cabal sandbox delete, cabal sandbox init right before running the line in the gist.
14:07:12 <merijn> Mostly because I wrote lots of networking, concurrent and process handling code
14:07:24 <nuttycom> Which is why I'm confused as to where anything that might need a reinstall could be coming from.
14:07:30 <geekosaur> they are glpbal packages
14:07:38 <geekosaur> they are packages installed with ghc itself, in fact
14:07:54 <geekosaur> which means that it's really telling you that you are trying to install something incompatible with your ghc
14:08:05 <geekosaur> (note reference to the ghc package breaking!)
14:08:19 <geekosaur> (line 7 of your paste)
14:08:42 <nuttycom> geekosaur: okay, thanks… probably means some of my dependencies are out of date?
14:09:48 <geekosaur> seems likely, yes. it wants specifically to install an older version of the "unix" library
14:17:42 <trap_exit_> http://archive.vector.org.uk/art10501320 why can't haskell be like this?
14:21:17 <redtricycle> How do I zipWith a repeating list?  for exapmle, I have zipWith xor [1,1,1,1] [0..] but I want to do zipWith xor [1,1,1,1] [1,2,1,2,1,2,1,2,1,2..]
14:21:21 <redtricycle> something like that
14:21:34 <redtricycle> I've tried, let x = [1,2]
14:21:41 <redtricycle> zipWith xor [1,1,1,1] [x,x..]
14:21:45 <redtricycle> that doesn't quite do it
14:25:34 <vanila> sih so much work to write a parser :(
14:25:47 <vanila> redtricycle, zipWih  (cycle [1,2])
14:27:12 <redtricycle> vanila: perfect!
14:38:05 <merijn> Dammit, SPJ keeps changing whether he hyphenates his name and it's messing with my paper meta-data >.<
14:38:54 <nuttycom> geekosaur: can you recommend any tool or process that can help with finding a compatible set of version dependencies? I feel like I'm performing A* by hand here.
14:39:41 <gfixler> merijn: your references are failing to be referentially transparent!
14:42:26 <geekosaur> nuttycom: the best way I know is to add an "installed" constraint for global packages to ~/.cabal/config so it'll at least stop instead of offering to do breaking reinstalls. there's some stuff on hackage to help detect dependencies though
14:44:10 <geekosaur> take a look at cabal-audit (but that looks out of date to me!) or cabal-progdeps (looks more compatible with a wide range of cabal libraries)
14:44:36 <nitrix> Can a lambda call itself recusively?
14:45:14 <merijn> nitrix: No/kinda
14:45:34 <merijn> nitrix: A lambda doesn't have a name, so it has no way to recursively call itself (you need a name to call something, usually)
14:45:51 <merijn> nitrix: But fix let's you write recursive anonymous functions
14:47:35 <merijn> :t fix (\f x -> if x == 0 then [] else x : f (x - 1))
14:47:37 <lambdabot> (Num t, Eq t) => t -> [t]
14:47:54 <merijn> > fix (\f x -> if x == 0 then [] else x : f (x - 1)) 10
14:47:56 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:48:29 <merijn> nitrix: There fix is passing the lambda as first argument to itself
14:48:36 <exio4> > take 20 $ fix (\f x → x:f(x+1)) 0
14:48:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
14:50:03 <nitrix> I see, interesting.
14:50:21 <merijn> :t fix
14:50:22 <lambdabot> (a -> a) -> a
14:50:31 <nitrix> Haskell's truly amazing.
14:50:36 <merijn> :t fix `asAppliedTo` (\f x -> if x == 0 then [] else x : f (x - 1))
14:50:37 <lambdabot> (Num t, Eq t) => ((t -> [t]) -> t -> [t]) -> t -> [t]
14:50:51 <nitrix> Not that's it's idiomatic, I'm just impressed it can pull it off.
14:51:20 <merijn> nitrix: Well, this is not really haskell specific, this is a trick that's common in untyped lambda calculus
14:51:55 <merijn> nitrix: Because traditionally *all* functions are anonymous in untyped lambda calculus, so you need something like fix to implement recursion
14:52:04 * hackagebot HTF 0.12.2.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.2.0 (StefanWehr)
14:53:12 <nitrix> I wished I learned functional programming before procedural. It's like I'm beyond the point of no return.
14:55:53 <merijn> Naah
14:56:26 <merijn> It just means it'll take a bit longer due to needing to unlearn habits
14:56:36 <monochrom> you learned highschool math before procedural programming. think of that as learning functional programming first.
14:57:33 <merijn> If you're interested in more theoretical reading related to things like this, there's a neat paper that shows how any recursive function can be written as "fold + trivial extra function" and vice versa that any fold can be a recursive function
14:58:01 <benzrf> merijn: what about anamorphisms?
14:58:19 <exio4> any recursive function? or only while following structural recursion?
15:00:06 <vanila> you can write: let  f .. = ... in  f
15:00:06 <merijn> exio4: Any recursive function, iirc
15:00:52 <merijn> exio4: But I may be misremembering! It's been ages since I read it
15:02:02 <exio4> it is because I look fold as just "abstracted structural recursion", that is why I ask:P
15:02:08 <merijn> exio4: A quick scan seems to imply that it can do any primitive recursive function
15:02:27 <exio4> have a link to the paper?
15:02:50 <merijn> exio4: Well, there's a reason the abstract ends with: "Secondly, we show that even though the pattern of recursion encapsulated by fold is simple, in a language with tuples and functions as first-class values the fold operator has greater expressive power than might first be expected."
15:03:33 <merijn> exio4: http://eprints.nottingham.ac.uk/224/1/fold.pdf
15:04:10 <exio4> thanks!
15:04:14 <tinhead> trying to replicate results here http://dis.um.es/~alberto/pages/plot.html, cabal thinks artools does not exist, any pointers?
15:08:32 <iiiiiiiian> o/ Haskell
15:09:18 <Sgeo> > 1 2
15:09:19 <iiiiiiiian> I was curious if anybody has any experience writing scripts to test large groups of source files that might contain syntax errors (i.e grading a class assignment in Haskell)
15:09:20 <lambdabot>  1
15:09:57 <iiiiiiiian> I was thinking of writing up some stuff to do it, but wanted to check and see if I was missing some obvious solution or if anybody had some good experiences doing their own thing?
15:11:43 <merijn> iiiiiiiian: When I TA programming classes I maintain a strict "syntax error == failing grade" policy and just skip failing assignments
15:11:46 <Sgeo> So, someone brought some Num instances into the bot in another channel. Apparently, that brings them into scope here too
15:11:56 <merijn> Sgeo: There is only one scope
15:12:05 <merijn> Sgeo: But it's trivial to scrap everything
15:12:18 <merijn> Sgeo: Just "@undefine"
15:12:46 <iiiiiiiian> merijn: We have the same policy, the syntax error situation can kinda screw up a metaprogrammatic approach.  I suppose then one would need to script at the compilation level?
15:15:07 <merijn> iiiiiiiian: What I did for ocaml is just define a set of functions + types they needed to implement, then we just copy their code into the test framework, compile the tests linking to their code and then run the tests
15:15:40 <merijn> iiiiiiiian: We have a trivial framework that we publish (i.e. interface without test code) so they can verify their module compiles in our harness
15:16:04 <merijn> iiiiiiiian: Then if any students code fails to compile we just disregard it and move on to the next student's code
15:16:18 <iiiiiiiian> merijn: Cool.  I think I'm going to try that approach.  Thanks for the advice!
15:47:03 <lahwran> http://en.wikipedia.org/wiki/Haskell_(programming_language)#Code_examples
15:47:12 <lahwran> what is
15:47:16 <lahwran> factorial :: (Integral a) => a -> a
15:47:20 <lahwran> particularly the => part?
15:47:30 <merijn> lahwran: => indicates a constraint
15:47:56 <merijn> lahwran: You can read it as "IF 'a' is an instance of Integral THEN 'factorial' has type 'a -> a' ELSE type error"
15:48:18 <Axman6> that type signature says that factorial takes any a and returns a value of the same type a, as long as the type a is a member of the Integral class
15:48:25 <Axman6> @src Integral
15:48:25 <lambdabot> class (Real a, Enum a) => Integral a where
15:48:25 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:48:25 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
15:48:25 <lambdabot>     toInteger       :: a -> Integer
15:48:28 <lahwran> why not just Integral -> Integral
15:48:36 <exio4> because Integral isn't a type
15:48:40 <Axman6> Integral isn't a type, it's a type class
15:48:41 <lahwran> Axman6: oooooohhh
15:48:47 <exio4> and in that case, it could mean two different "types"
15:48:47 <MindIsAVortex> Hi, for an assignment I have to write "put" of the MonadState (put :: s -> m ()) in terms of modify (modify :: (s -> s) -> m s). I've been trying for the past few hours and I'm pretty dumbfounded. I've figured out that modify (const ()) has type t -> m () with MonadState => m (), so I guess I should be thinking in that direction. To be honest, it's all highly abstract for me. Can someone give me something of a hint?
15:48:59 <Axman6> if you know java, type classes are sort of like interfaces
15:49:02 <exio4> :: (Integral a, Integral b) => a -> b
15:49:21 <lahwran> oooooh cool!
15:49:30 <merijn> MindIsAVortex: "const ()" will only work if 's' happens to be ()
15:49:44 <MindIsAVortex> oh
15:50:01 <Axman6> MindIsAVortex: can you _only_ use modify? if so, it's not possible
15:50:05 <monochrom> MindIsAVortex: if I want to perform "put 4", then "modify (const ())" won't do what I want, will it?
15:50:22 <Axman6> but if you can use return too then it's easy
15:50:27 <merijn> MindIsAVortex: How about this clue: What if you just used modify to get an "m s" and then try to write something "m s -> m ()"?
15:50:41 <monochrom> but you can combine modify, >>=, and return ().
15:50:50 <merijn> monochrom: Spoilers >.>
15:50:59 <Axman6> heh
15:51:22 <monochrom> I have not spoiled how to combine them. also, not what to tell "modify".
15:52:23 <MindIsAVortex> Axman6: I have to define it "in terms of modify", I think that means I can use other functions as well, from the prelude that is.
15:52:43 <monochrom> also, there is a difference between "I have just started" and "I have tried a few hours". the latter can certainly benefit from more spoilers.
15:52:43 <Axman6> ok, then it shouldn't be too hard
15:53:50 <MindIsAVortex> I gotta be honest and say that what the StateMonad functions put, get and modify actually "do" hasn't quite struck home with me yet
15:53:54 <dbp> Is it possible to use hint to create a statically linked binary that can evaluate haskell code that depends on libraries on a different machine?
15:54:34 <dbp> ie, is there a way to package up modules with the binary so that when you use hint to interpret things, those modules are in scope
15:55:02 <dbp> (or if hint isn't the right solution and there's another way to do this, that would be great too!)
15:56:01 <merijn> MindIsAVortex: It seems odd that you were asked to use MonadState to begin with, as opposed to the more basic State, which is simpler IMO
15:57:31 <merijn> MindIsAVortex: You may want to start with a simpler challenge. Implementing "State" so you understand how it works, you can then tackle this exercise for "State" and the solution you come up with, should pretty much be identical to the one to your MonadState problem
15:57:47 <merijn> MindIsAVortex: See here for an outline of what State should look like to implement: https://gist.github.com/merijn/098106abd45c940dab09
16:18:33 <JagaJaga> What's the best library to draw a table in console? I mean the table, which I have to refresh (smth like the ouput of the `top` program). Ncurses or what?
16:23:36 <JagaJaga> Oh, will just clear screen and output it:)
16:24:19 <NougatRillettes> @hoogle [ m () ] -> m ()
16:24:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
16:24:23 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
16:24:23 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
16:24:40 <monochrom> vty is useful if you want to control the console in more detail
16:25:20 <NougatRillettes> how come there isn't a version of sequence (and MapM) restricted to [ m () ]
16:25:40 <JagaJaga> monochrom: thx.
16:25:45 <NougatRillettes> that would be a good way to guarantee that you don't discard any "real" value
16:26:27 <Axman6> the type of mapM_ pretty much quarantees that anyway
16:26:47 <NougatRillettes> hm not really
16:27:06 <NougatRillettes> :t mapM_
16:27:07 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
16:27:18 <NougatRillettes> all the b are lost
16:27:28 <NougatRillettes> (i read it "all the bees are lost" :D)
16:27:30 <Axman6> yes
16:27:43 <NougatRillettes> that's exactly what I want to avoid
16:28:11 <Axman6> but all you want is mapM_ foo . map void
16:28:19 <Axman6> uh
16:28:28 <Axman6> mapM_ (void . foo)
16:28:37 <exio4> :t mapM_ :: Monad m => (a -> m ()) -> [a] -> m ()
16:28:38 <lambdabot> Monad m => (a -> m ()) -> [a] -> m ()
16:31:07 <NougatRillettes> yup exio4 that's the solution I came up with, I was just wondering why it wasn't part of the Prelude
16:31:29 <NougatRillettes> but I guess everyone would want a different function to be part of the Prelude :p
16:31:36 <Axman6> because it doesn't make any sense to have it, it's exactly the same as mapM_ but less useful with the same guarantees
16:31:59 <exio4> I don't get why would you want to _specify_ that?
16:32:00 <Axman6> mapM_ clearly discards results
16:32:32 <Axman6> if you "accidently" use mapM_ instead of mapM, you'll figure it out pretty quickly
16:33:29 <NougatRillettes> hm, the most is type enforced the better I guess
16:33:53 <NougatRillettes> or maybe it's just an ocamller reflex regarding their warning on ";"
16:34:17 <Axman6> but it is enforced
16:34:42 <Axman6> restricting it to m () makes writing a lot (possibly most) other code more painful
16:34:54 <Axman6> while not giving you any real benefits
16:35:07 <NougatRillettes> I wasn't asking to change mapM_
16:55:45 <adarc> hi. i'm reading a string of numbers, ie: 1 2 3 .. or 1.0 2.0 3.0 etc.. i'm doing something pretty hacky: getNums s = read ("[" ++ (map (\n -> if n == ' ' then ',' else n) s) ++ "]")
16:56:10 <vanila> > map read . words $ "1 2 3"
16:56:13 <lambdabot>  [*Exception: Prelude.read: no parse
16:56:13 <adarc> is there a much better way to do that? also.. i get read parse errors because i'm not specifying the type.. ie,
16:56:19 <vanila> > map read . words $ "1 2 3" :: [Int]
16:56:20 <vanila> like this
16:56:21 <lambdabot>  [1,2,3]
16:56:32 <adarc> ah..
16:56:37 <adarc> thanks alot
17:14:34 <YurasS> jle`: you'd not believe, but: http://ircbrowse.net/browse/haskell?q=MonadIO+considered+harmful
17:15:20 <jle`> ezyang huh
17:15:41 <YurasS> I'm rewriting pdf-toolbox to remove MonadIO
17:15:43 <YurasS> so coool
17:16:20 <jle`> :D
17:16:24 <jle`> it's a good point
17:16:27 <jle`> the exception stuff
17:20:20 <ezrios> any good resources on QuickCheck?
17:20:25 <ezrios> in particular, how to write Arbitrary intsances
17:22:05 <MindIsAVortex> merijn: thanks! I'll look at it. Should have thanked you an hour ago but my attention was needed somewhere.
17:23:04 <jle`> ezrios: there's that chalmers course that has a week on quickcheck/arbitrary i think
17:25:19 <YurasS> jle`: well, haskell is broken with respect to exceptions :)
17:26:52 <YurasS> (mostly because of async exceptions)
17:30:29 <jle`> YurasS: is haskell what is broken?
17:32:19 <YurasS> jle`: but exceptions (async especially) are cool, I don't want to ban them :)
17:32:34 <YurasS> so I say that is haskell what is broken :)
17:33:19 <YurasS> but it is easy to agree with your point
17:36:01 <YurasS> jle`: I even wrote my own lib for resource management with exceptions (io-region repo on github)
17:36:15 <YurasS> and it is MonadIO-free :)
17:36:33 <luite> YurasS: you mean with respect to the mask state of exception handlers? what would you change to improve the situation?
17:37:35 <YurasS> no, I mean interruptable actions
17:37:58 <YurasS> exceptions that occurs while processing other excaption
17:38:30 <YurasS> jle`: in c++ it terminates your program, and that is the *right* thing imo
17:40:03 <luite> YurasS: i think we do mean the same thing then. The default mask state while handling an exception is MaskInterruptible, and there were some complaints about that recently
17:40:23 <luite> but MaskUninterruptible seems too big of a hammer to use as a default
17:40:41 <merijn> luite: Even Simon agrees now that it's the way to go
17:40:52 <YurasS> oops, I send it to wrong user, sory
17:41:01 <YurasS> luite: yes, probaly
17:41:07 <merijn> luite: Peaker hasn't picked it up yet, but it's on my todo list to chase after that change as soon as I cut down some of my backlog
17:41:08 <luite> merijn: ok cool, and what about the problem with blocking StackOverflow?
17:41:41 <merijn> luite: Simon seems to think that StackOverflow being masked is the right behaviour? I'm ambivalent on that
17:42:02 <dmj`> I have an api question. If my library has a ton of types, and functions, is it kosher to export all of them from one top level module? Or should I just expose a lot of little top level modules and let the users import things piecemeal
17:42:06 <dmj`> *?
17:42:12 <merijn> luite: If you have any concrete issues that require StackOverflow to be semi-synchronous (i.e. async, but not masked) do tell me
17:42:29 <merijn> dmj`: I think that depends on how your library is designe
17:43:05 <dmj`> merijn: there's a ton of types, I'm afraid if I export everything from one module users will have collisions
17:43:15 <merijn> dmj`: I think that top-level should import everything "standard" i.e. all the common things people will need. Keeping various submodules to import more obscure/limited functions from seems ok
17:44:08 <dmj`> merijn: yea, that's more or less what it is right now, was thinking about re-exporting them from another top level module, but, it seems like this way is best
17:44:23 <dmj`> it is web scale
17:46:07 <luite> merijn: hmm, I'd be mostly worried about out-of-control computations that keep growing stack
17:49:11 <Ptival> does anyone know how to get a left-associative whitespace in Happy? the %left APP, Term Term %prec APP trick does not seem to work :\
17:53:25 <luite> merijn: and i still have this nagging feeling that the choice between masking all async exceptions or none is too coarse grained. It's pretty common to have async exceptions as a communication mechanism for things like 'abort request' that are recoverable (close connection, wait for next req), but with a few that are not, where the only thing left to do to is releasing some resources (or trying to) and stopping the thread.
17:53:46 <luite> merijn: StackOverflow would probably usually fall in this category, KillThread might be used for this
17:54:13 <merijn> luite: The worry that Simon had is that if StackOverflow isn't masked, you *still* leak resources
17:54:34 <merijn> luite: Additionally, it seems unlikely that cleanup steps are computationally expensive steps that leak memory
17:55:48 <merijn> Remember that only the cleanup step would be affected, it's probably easier to get people to move expensive computation out of the cleanup handler then it is to audit every possible code paths for potentially blocking operations
18:00:13 <luite> merijn: not memory perhaps, but a common cleanup step would be something like sending that 'abort' req to the db server. if it hangs in that foreign call (assuming the import is interruptible) you get an unkillable thread. doing that abort call outside a mask could be worse, perhaps preventing the req to be sent out in the first place
18:01:21 <gfixler> is everything pattern matching?
18:01:43 <vanila> no
18:01:47 <gfixler> e.g. twice x = x * x
18:01:58 <gfixler> whenever I do `twice x`, is it pattern matching that's happening?
18:02:04 <vanila> it's not pattern matching
18:02:17 <vanila> you can think of it as graph reduction
18:02:42 <gfixler> foo (x:xs) n
18:02:48 <gfixler> is (x:xs) the only pattern matching?
18:02:57 <gfixler> foo (x: xs) n = ...
18:03:07 <vanila> you can do pattern matching with the 'case' operator
18:03:45 <merijn> luite: Sure, but that's more related to the "should we uninterruptible mask at all", and I agree that there are some downsides
18:04:19 <gfixler> vanila: I don't want to do pattern matching - I was wondering what Haskell is doing
18:04:25 <merijn> luite: But fixing a "unkillable thread" bug seems more tractable and easier to detect than "silently occasionally leaking resources in ways that require a full code-path audit to detect"
18:04:39 <vanila> ok
18:04:57 <gfixler> I've been told from a number of sources now things that imply the left side of the = is always a pattern
18:05:30 <pjdelport> gfixler: That's a fair approximation, but syntactically it's not just the left side of ='s
18:05:31 <vanila> those sources are wrong
18:05:33 <merijn> gfixler: Yes, but a variable that matches anything is also a pattern according to the report definition of a pattern
18:05:38 <merijn> vanila: They are not
18:05:42 <gfixler> foo 3 (x:xs), foo _ xs, foo _ _, foo a b, etc - all patterns
18:05:45 <vanila> it's not pattern matching
18:05:45 <pjdelport> gfixler: There are patterns in front of <- and -> too.
18:05:47 <merijn> vanila: Variable bindings are patterns
18:06:07 <gfixler> times2 x = x * x
18:06:12 <gfixler> is times2 x a pattern?
18:06:17 <exio4> something _ = 2
18:06:20 <gfixler> actually, that should be squared x
18:06:23 <merijn> gfixler: No, it's a function name, 'x' is a pattern
18:06:27 <gfixler> ah
18:06:36 <gfixler> I thought the function name was part of the pattern
18:06:40 <pjdelport> gfixler: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
18:06:53 <gfixler> ah ha, a source appears
18:07:00 <trap_exit> I wnat to do the following in haskell, and would like advice on the easiest way to do it: I want to hook up a microphone and speakers together ... so that whenever the microphone detects sound, the speaker plays a "shhhhhhhhh".wav file
18:07:03 <pjdelport> Ultimately, all those different kinds of patterns translate into case expressions.
18:07:09 <gfixler> ok
18:07:18 <trap_exit> so just imagine ... you start talking, and the system goe s"sh"
18:07:19 <gfixler> that's the bottom of the desugaring?
18:07:22 <trap_exit> "sh"
18:07:59 <pjdelport> gfixler: Pretty much, yeah. (Although you could probably define things so that something else is most primitive, too, if you wanted to. That's just the way the Report chooses to specify things.)
18:08:20 <vanila> trap_exit, you'll need a library that can do stuff with the microphone
18:08:26 <gfixler> pjdelport: that works for me
18:08:28 <vanila> (I don't know of one)
18:08:43 <trap_exit> yeah, is audio input/output in haskell non-trivial ?
18:08:47 <vanila> yes
18:09:01 <trap_exit> is it non-triviain in general, or just non-trivial in haskell ?
18:09:12 <luite> merijn: that issue might not be fixable so easily. your only option is to do that call outside an UninterruptibleMask, which means the foreign call will be interrupted by any, possibly benign, async exception
18:10:33 <pjdelport> trap_exit: With the right library it should be okay.
18:10:40 <luite> merijn: so the actual problem is that there's nothing between UninterruptibleMask and InterruptibleMask.... that's what makes the choice hard, neither really fits the bill
18:13:14 <merijn> luite: I agree with that
18:13:59 <merijn> luite: But the Peaker and my argument is that, in a short term, stopgap sort of way, UninterruptibleMask is preferable over InterruptibleMask
18:14:16 <merijn> Given how much of base is currently completely broken due to mistaken uses of bracket
18:15:11 <ezrios> is it possible to "add" Chars in Haskell similarly to C?
18:15:40 <merijn> ezrios: I don't understand what that mans
18:16:07 <merijn> luite: Hell, Simon said he even found a bug in GHC due to mistaken bracket after he audited the use of bracket in GHC
18:17:33 <exio4> ezrios: with ord and chr?
18:19:02 <lambda> Is there a read-only IORef? I would rather avoid partially applying readIORef to share a read-only IORef between threads.
18:20:21 <luite> merijn: oh i don't disagree that the current situation is worse, i just hope we won't lose interest in a proper solution when this is in place... :)
18:20:40 <luite> Total_1mmersion: why not?
18:20:44 <YurasS> lambda: what is wrong with partial app?
18:20:47 <merijn> lambdabot: An easy way would be either 1) newtyping IORef or 2) Don't give the threads an IORef at all, but give them a partially applied readIORef?
18:21:41 <Total_1mmersion> I just didn't know if there was a dedicated ReadOnlyIORef out there that I hadn't seen.
18:22:52 <Ralith> can any conduit people around talk about how TCP read errors (e.g. timeouts) are handled?
18:24:53 <pjdelport> ezrios: You can do it via ord and chr, and you could define a Num instance for Char using those, if you wanted to.
18:24:56 <merijn> Ralith: I don't use conduit, but I'm guessing the same way as in pipes, i.e. it's just reading in a loop and TCP error will end up throwing an exception which terminates the conduit?
18:25:39 <ezrios> pjdelport: that's what I ended up doing
18:25:40 <Ralith> merijn: it never seems to happen, though; if the connection times out it just blocks forever
18:26:25 <merijn> Ralith: Are you sure it's timed out, then?
18:26:32 <merijn> Ralith: oh
18:26:56 <merijn> I thought I had an idea, then realised it probably wasn't relevant...
18:27:08 <merijn> Ralith: Are you using binary/attoparsec to deal with the stream, by any chance?
18:27:13 <Ralith> I am sure
18:27:26 <Ralith> I'm using a third party lib for the high level parsing; I might have to try stripping that out
18:27:32 <Ralith> er, low level parsing
18:27:35 <merijn> Ralith: for funsies, are you leaking a ton of memory after time out? :)
18:27:44 <Ralith> never thought to check
18:27:50 <merijn> (i.e. consult whatever task management thing you have on your OS)
18:27:57 <merijn> If so, I think I know the issue :p
18:36:21 <Ralith> merijn: what is your suspicion?
18:36:31 <volty> so, is it pattern matching or  what ?
18:39:06 <merijn> Ralith: binary's incremental parser changed from treating an empty ByteString as empty input to needing an explicit "end of input", I had a problem where I used "hGetSome" on a socket as source for my pipe. hGetSome returns empty ByteString after disconnecting. Due to the binary change, rather than terminating as intended it was spin-looping, with hGetSome immediately returning empty ByteString upon every call and my binary pars
18:39:15 <volty> proposal: start a HaskellPedia
18:39:18 <volty> gn
18:39:31 <merijn> Ralith: Within minutes it would build up a log of close to 1GB of leaked empty ByteString chunks
18:40:46 <Ralith> merijn: well, it's using no CPU and memory is constant
18:43:57 <merijn> then I have no idea :)
18:47:08 <dfeuer> merijn, why make that change?
18:48:28 <merijn> dfeuer: Why binary did that? I dunno...
18:51:53 <AR45> Hi sexy people ;]
18:57:30 * hackagebot Randometer 0.1.0.0 - Randomness intuition trainer  http://hackage.haskell.org/package/Randometer-0.1.0.0 (So8res)
19:03:19 <chirpsalot> AR45: it's not nice to not include us unsexy folk!
19:15:03 * dfeuer why chirpsalot considers hirself unsexy.
19:15:31 <dfeuer> But this is getting rather off-topic, I suppose.
19:16:44 <dfeuer> > case f of {f->let f = f in f} where f = f
19:16:47 <lambdabot>  <hint>:1:31: parse error on input ‘where’
19:17:17 <dfeuer> > case f of {f->let f = f in f; where f = f}
19:17:20 <lambdabot>  <hint>:1:31: parse error on input ‘where’
19:17:32 * hackagebot hspec-meta 1.12.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.0 (SimonHengel)
19:18:21 <dfeuer> Oh, there we go:
19:18:34 <dfeuer> > case f of {f->let f = f in f where f = f}
19:18:36 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
19:18:36 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
19:18:36 <lambdabot>  The type variable ‘a0’ is ambiguous
19:18:36 <lambdabot>  Note: there are several potential instances:
19:18:36 <lambdabot>    instance (GHC.Show.Show a, Debug.SimpleReflect.Expr.FromExpr b) =>
19:20:22 <jaseemabid> Asking here because haskell is generally a playground for prog lang research. Was there any work on `first class types` in haskell.
19:21:02 <jaseemabid> I was reading up a bit and there don't seem to be much material on it. Coq implements it, but the implications are not very clear from their website.
19:21:25 <solatis> let me google that
19:22:22 <solatis> you mean that you can treat a type as a value, just like you can pass a function as a value?
19:22:24 <cholera-virus> jaseemabid: types as values?
19:22:49 <solatis> (reading http://lambda-the-ultimate.org/node/1518 now)
19:22:56 <vanila> jaseemabid, another thing it lets you do is compute types from values
19:25:36 <simon> hmm
19:26:11 <simon> there's this course at my dept where the lecturer insists on never submitting ideal solutions after assignment deadlines.
19:26:30 <simon> apparently due to an idea about learning methods and laziness or something like that.
19:26:51 <simon> on the other hand, I've learned a great deal from reading people's code, so I tend to disagree. I think there might be practical reasons not to share code, so it can be re-used across years.
19:28:08 <solatis> interesting -- it's kind of the corporate vs academic aproach
19:28:32 <solatis> i don't think Dijkstra would agree with him, tho :)
19:28:36 <simon> I'm not sure I see the corporate aspect.
19:29:05 <simon> I think he thinks that people are lazy and won't make an effort if they think they can "pattern match" rather than "think".
19:29:56 <solatis> aha, i interpreted as people being so enthusiastic about a problem that they keep on working on it, regardless of the deadline
19:30:51 <Yxven> either way you're going to learn to pattern match
19:31:06 <simon> ah. I think it's more like they might not make an effort so long as they have the "points", because a solution will be given at some point. somehow it does encourage laziness (unless of course solutions are only given in return of a decent attempt at solving - this won't work in practice, though, as anyone can share the solution afterwards).
19:31:06 <Yxven>  it might as well be with the ideal code
19:31:17 <simon> Yxven, I agree.
19:31:38 <simon> I remember using monad transformers pretty early without having any clue as to how they work. (I still don't have much clue.)
19:31:57 <solatis> :)
19:32:26 <solatis> we had to keep a 'portfolio' during college, in which we put all the code we've written during the years
19:32:32 <simon> cool.
19:32:36 <simon> I wish I had a portfolio.
19:32:46 <solatis> well, it's not so cool when businesses start requesting it
19:32:54 <simon> I used to keep Project Euler solutions, but I lost them all.
19:32:57 <solatis> during interview
19:33:06 <simon> what's not so cool?
19:33:20 <simon> oh - heh.
19:33:28 <simon> you don't get to choose what to put into your portfolio? :)
19:33:28 <solatis> well, the code i wrote in my first year of college doesn't represent my abilities on this day
19:33:40 <solatis> exactly
19:33:53 <simon> ugh. sounds unethical.
19:33:53 <solatis> sometimes you had insane deadlines and had to deliver some spaghetti code
19:34:30 <solatis> or you had to work together as a team with 6 other people -- and the other people were retards (sorry)
19:34:34 <simon> that's like asking for written feedback or the teacher's notes on individual students. I think some things are best left summarized into a number that oneself gets to explain during interviews :P
19:34:42 <solatis> so you had to put retarded code in your portfolio :)
19:35:08 <solatis> so basicly i nowadays tell people that i 'lost' it, and just look at my github account
19:35:11 <simon> I had to explain a shitty algorithms exam grade once... it sucks. but at least he didn't have a video recording of me getting into a verbal fight with the examiner.
19:35:25 <solatis> :)
19:35:52 <simon> right :)
19:36:13 <solatis> at the end of my defense of my thesis, one of my lecturers came to me and told me that while everyone thought it was awesome, he said it sucked and i was unfit for busines life
19:36:21 <simon> haha
19:36:27 <simon> good to know
19:36:31 <solatis> yeah well
19:36:50 <simon> what was your thesis?
19:37:01 <solatis> i responded with 'you know what they say -- people who are unfit for business life, join the government. if they are unfit for that too, they become teachers'
19:37:29 <solatis> my thesis was about predicting demographics of people on the internet based on behavioural data of other people
19:37:37 <simon> I heard it as "Those who can't, they teach". I never repeat it, though, because I TA a lot. ;)
19:38:01 <solatis> i used my thesis as the foundation to start a business, it became very succesful, and now i'm on a 1.5 year sabbatical :)
19:38:17 <simon> cool.
19:38:25 <solatis> so looking back it's so funny that one of my lecturers told me i was unfit for business life
19:38:41 <simon> *shrug*
19:38:53 <solatis> shows you so clearly how much the discrepancy between college and 'actual' business life is
19:39:31 <simon> a sabbatical is a temporary academic visiting position, right?
19:39:45 <bjorkintosh> <solatis> my thesis was about predicting demographics of people on the internet based on behavioural data of other people
19:39:50 <bjorkintosh> who are the 'other people'?
19:39:54 <solatis> well
19:40:01 <solatis> say that you have a news website
19:40:06 <bjorkintosh> the president of iran?
19:40:24 <solatis> and 1% of the people log in and you can co-relate demographic data
19:40:45 <solatis> you can use the behavioral data of that group of people to make predictions about the other 99%
19:40:53 <solatis> it worked remarkably effective
19:41:27 <solatis> i started a business in, *gasp*, online advertising
19:41:39 <solatis> since there was a big demand for this technology in that sector
19:41:44 <bjorkintosh> when was this?
19:41:47 <solatis> 2006
19:41:58 <bjorkintosh> ah
19:42:49 <solatis> anyway, now i'm on a sabbatical and have nothing better to do than my passion, which is still writing code
19:43:03 <solatis> so 2 months ago i decided to learn haskell during this period
19:43:43 <bjorkintosh> what did you write your ad stuff in?
19:44:07 <solatis> mostly c++
19:44:13 <bjorkintosh> really? for the web?
19:44:32 <solatis> this is not really 'web development' anymore
19:44:42 <bjorkintosh> analysis?
19:44:46 <solatis> say you have a visitor requesting an ad
19:49:11 <solatis_> you need to look up its entire history
19:49:31 <solatis_> you need to compare it to,say, 150 running campaigns
19:49:33 <solatis_> and the effectiveness history of those campaigns against the history of the visitor
19:49:35 <solatis_> and select the ad that's most likely to be most effective
19:49:38 <solatis_> and now do that 250,000 times a second, in which every request leads to a write operation
19:49:40 <solatis_> furthermore, you need to do a lot of off-line data mining
19:49:42 <solatis_> reporting
19:49:44 <solatis_> etc
19:49:46 <solatis_> :)
19:49:48 <solatis_> the problem domain was awesome to solve
19:49:49 <solatis_> lots of very, very interesting scalability problems
19:51:24 <pharaun> oh ads
19:54:35 <simon> I hate how interesting advertisement sounds.
19:54:55 <simon> I know two guys who do Erlang back-ends for large ad systems.
19:55:21 <solatis> yeah
19:55:35 <solatis> right now the 'real time bidding' world is awesome
19:55:46 <simon> you mean auctions?
19:55:49 <solatis> for every ad request, several other parties are requested for their 'bid'
19:55:58 <simon> or does that term extend to facebook-like games?
19:56:00 <solatis> this is all HTTP remote requests
19:56:16 <solatis> these are usually between 25 and 50 different parties
19:56:19 <simon> ah, it's even more general than that.
19:56:28 <solatis> they have to respond within +- 100ms
19:56:34 <solatis> then the ad is auctioned
19:56:41 <solatis> and the winners gets the bill
19:56:50 <solatis> this *also* happens 250,000 a second on adservers
19:57:08 <solatis> so you really, really want to write your code properly async
19:57:15 <simon> haha
19:57:23 <solatis> it was awesome
19:58:17 <solatis> and now i know haskell, i really want to rewrite all that stuff into haskell lol
19:58:45 <solatis> i think the code would've been so much more better
19:59:04 <simon> I never see ads online. are you saying there's live bidding on most ads between individual advertisers based on whatever client/session parameters are available?
19:59:12 <solatis> yep
19:59:20 <solatis> there's even cookie syncing
19:59:43 <solatis> so if you're on adserver A, and adserver B wants to make a bid, it wants to know your history
20:00:12 <solatis> so at some point in time, adserver A makes a little HTTP request to adserver B saying 'this is visitor i know as id #1234'
20:00:32 <solatis> adserver B gets its own cookie in the http headers, *and* the cookie id of adserver A
20:00:48 <solatis> so, next time adserver A runs an auction, it says 'this is visitor i know by id #1234'
20:01:06 <solatis> adserver B might run some ad campaigns for advertisers that want to re-target 'lost' customers
20:01:17 <solatis> and it can map visitor 1234 to its own internal visitor 4321
20:01:29 <solatis> and keep in mind, all this stuff is happening in *milliseconds*
20:02:01 <solatis> and i think less than 1% of the internet even has a clue how advanced and complex the technology is of adserving is nowadays
20:02:08 <simon> what have you written this in historically?
20:02:20 <solatis> c++ was my language of choice
20:02:41 <solatis> we used a lot of data mining, which was done in hadoop, which is in the java ecosystem
20:02:54 <solatis> so we had to bridge that gap too
20:03:31 <solatis> if i would have to do it again, i would probably not use c++ anymore
20:04:48 <dfeuer> solatis, the advertising world is just scary. As is C++.
20:05:03 <solatis> it's developing so quickly
20:05:45 <solatis> but yeah i remember being extremely opinionated in c++ towards my team
20:05:55 <solatis> for example, the were not allowed to use pointers
20:06:39 <vanila> solatis, that's amazing!
20:06:42 <solatis> but in c++, you just need someone with a really clear vision about how good c++ code is written, and everyone needs to follow that discipline
20:06:58 <solatis> since the language just gives you too much ways to f... things up :)
20:07:16 <solatis> and people usually are not aware of the optimizations compilers can make
20:07:38 * hackagebot hspec 1.12.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.0 (SimonHengel)
20:07:40 * hackagebot hspec2 0.5.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.5.0 (SimonHengel)
20:09:37 <HeladoDeBrownie> solatis, is avoiding pointers in C++ not horribly crippling? I'd guess less crippling than it is in C, anyway.
20:10:20 <johnw> avoiding pointers in C++ is recommended practice these days
20:10:37 <solatis> HeladoDeBrownie: references > pointers
20:10:45 <johnw> and smart pointers > pointers
20:10:51 <solatis> yeah
20:11:01 <merijn> johnw: It depends
20:11:10 <solatis> the only reason you might want to return a pointer if you want to *optionally* return something (and NULL means 'nothing here')
20:11:17 <merijn> If you need speed pointers are still the only sane way to go
20:11:35 <solatis> merijn: references are just as fast as pointers
20:11:36 <merijn> Well, references if you can make that work
20:11:43 <johnw> with modern C++, I'd challenge you to find me a case where pointers are faster
20:11:46 <merijn> solatis: There's many cases where references are not an option
20:11:51 <solatis> like what
20:11:57 <solatis> optional object returns/values?
20:12:00 <johnw> most smart pointers will boil down to pointers in the runtime code anyway
20:12:02 <solatis> you have boost::optional for that
20:12:12 <solatis> you can wrap a reference in a boost::optional
20:12:43 <solatis> and people are not aware of return-value-optimization, when you return an object by value and the compiler doesn't need to copy the object
20:12:45 <solatis> (RVO)
20:13:10 <johnw> boost::optional can actually have poor performance
20:13:15 <merijn> Move semantics are pretty nice
20:13:16 <solatis> so many c++ coders writing crappy code to avoid copying objects, while they're unaware the compiler is smart enough to avoid doing that if you write your code in a specific way
20:13:24 <merijn> I'm not dealing with optional values
20:14:15 <solatis> for example, if a function has only a single return code path, the compiler can optimize that return away and not copy any objects by value
20:14:19 <merijn> But inner-loops over multiple arrays where I haven't figured out how to go from a pointer to a reference
20:15:33 <solatis> merijn: you should use unique_ptr for that, if you have c++11
20:15:52 <merijn> Except they're not unique
20:16:05 <solatis> what do you mean?
20:16:14 <merijn> Multiple locations hold a copy of said ptr
20:16:27 <solatis> and there is no clear owner of the object?
20:16:39 <merijn> "the system"
20:16:43 <solatis> hmm
20:16:47 <merijn> There's no object, just int arrays
20:16:57 <merijn> Graph in CSR, to be exact
20:17:07 <solatis> and you need references to locations inside those int arrays?
20:17:42 <solatis> of course there are always exceptions to the rule -- maybe for your use case, pointers will work
20:17:53 <merijn> We have multiple parallel workers who run in a tight loop across values in those arrays
20:18:13 <solatis> but generally using pointers lead to fragile code
20:18:16 <koala_man> I have a man page in markdown format. How can I have pandoc compile it to man as part of my cabal build process?
20:19:00 <merijn> koala_man: Create a user hook to call pandoc
20:25:03 <tsani> What would be the most idiomatic way of checking whether a list contains duplicate elements? Specifically, this is a list of (Int, Int).
20:25:39 <solatis> tsani: i would personally sort them and then validate there are no repeating elements
20:25:42 <merijn> tsani: What do you want to do if duplicates exist?
20:26:10 <merijn> Remove them? Keep only the duplicates?
20:26:50 <tsani> merijn: The list won't be altered if there are duplicates. I need to check whether there are duplicates to affect the behaviour of the program elsewhere.
20:27:28 <tsani> solatis: I figure that would be the fastest way, too, wouldn't it?
20:28:01 <solatis> maybe the sort step can be optimized
20:28:24 <solatis> the real fastest way would probably to embed the duplicate checking logic inside the sort algo
20:28:35 <merijn> Is there a convenient way to change the default name for cabal's build directory?
20:28:53 <merijn> i.e. from "dist" to something else?
20:29:28 <vozz> How would get an attoparsec parser to consume all input and return a list of all the matches, i.e. for a parser that matches text between <brackets>, for the input "sdafs<one>afhfhhre<two>fasdf" it would return ["one","two"]? I know I can use 'many' if my input is "<one><two>" but if they're any unimportant junk inbetween, I want to ignore that rather than just fail.
20:30:21 <vozz> there is*
20:33:15 <merijn> vozz: You'll have to write a parser that recognises "junk"
20:34:22 <vozz> would anyChar do?
20:35:28 <pingu> vozz: you want any char that is not <
20:35:39 <pingu> anychar will consume the <two>
20:36:16 <pingu> so you want to eat not <'s, then consume a <thing>, then stick that in a many
20:37:06 <vozz> what if the parser is more complicated than just brackets? Is there a way to try a parser, and if it fails consume a character and try it again?
20:37:18 <pingu> vozz: there is, obviously this is very slow
20:37:27 <vozz> hm
20:37:38 <vozz> okay
20:37:55 <vozz> I think your method will work for what ive got now, thanks :)
20:37:58 <pingu> what you want is a "lookahead" parser
20:38:09 <pingu> which you generally want to avoid due to them being slow
20:40:31 <solatis> more specifically, your parser is not LL(1)
20:40:40 <merijn> Wut
20:40:54 <merijn> attoparsec is backtracking by default, so it's trivial to write
20:41:03 <merijn> Although it *will* be slow
20:57:44 * hackagebot stm-containers 0.2.0 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.0 (NikitaVolkov)
20:57:47 * hackagebot bindings-hamlib 0.1.0.0 - Hamlib bindings for Haskell  http://hackage.haskell.org/package/bindings-hamlib-0.1.0.0 (RickyElrod)
21:17:47 * hackagebot slave-thread 0.1.0 - A solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.0 (NikitaVolkov)
21:17:49 * hackagebot copr 1.1.1 - Haskell interface to the Fedora Copr system  http://hackage.haskell.org/package/copr-1.1.1 (RickyElrod)
21:17:51 * hackagebot whois 1.2.2 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.2.2 (RickyElrod)
21:22:48 * hackagebot gitignore 1.0.0 - Apply GitHub .gitignore templates to already existing repositories.  http://hackage.haskell.org/package/gitignore-1.0.0 (RickyElrod)
21:22:50 * hackagebot fedora-packages 0.0.3 - Haskell interface to the Fedora Packages webapp API.  http://hackage.haskell.org/package/fedora-packages-0.0.3 (RickyElrod)
21:34:02 <merijn> Is there a way I can mark a package as only working on a specific OS?
21:36:07 <joelteon> if os() buildable: false?
21:39:41 <merijn> joelteon: Ah, thanks
21:47:50 * hackagebot posix-pty 0.1.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/posix-pty-0.1.1 (MerijnVerstraaten)
22:01:37 <fluffynukeit> hi, all.  I am trying to load a .o object file using ghci.  FYI the object code is for a module that uses a C bindings library.  When I load it with ghci path/to/my.o, I get the following error.
22:01:40 <fluffynukeit> relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC
22:02:28 <fluffynukeit> my googling has indicated that this is a general error from the linker, but I don't understand it in this context
22:02:41 <fluffynukeit> does anyone know why this error is showing up?
22:03:32 <merijn> fluffynukeit: Which platform and which GHC version?
22:04:02 <fluffynukeit> merijn: I'm on nixos and: The Glorious Glasgow Haskell Compilation System, version 7.8.3
22:04:08 <merijn> fluffynukeit: Since 7.8 I believe GHCI can only link against dynamic libraries and thus you need to compile with -fPIC as the error says
22:04:52 <fluffynukeit> merijn: what is it that I need to compile with fPIC?  My module, the bindings it uses, or the C library it binds to?
22:05:45 <merijn> fluffynukeit: Everything that's inside the .o
22:06:34 <fluffynukeit> merijn: so if my module has the text package in its build depends, I need to recompile that as well as all the other dependencies with fPIC?
22:07:12 <merijn> I don't know, I'm not too up to date with the new linker
22:07:53 <fluffynukeit> Could you explain what the fPIC flag does?  I know PIC is position independent code, but I don't understand what that means for my libraries
22:11:51 <merijn> fluffynukeit: Your code (presumably) has jumps in it, i.e. when C compiles a for/while loop there's a conditional jump to the start of the loop at the end
22:12:15 <merijn> fluffynukeit: These adresses need to be relocated to line up with the final position of your code in the executable (else you end up jumping to the wrong code)
22:13:09 <merijn> fluffynukeit: Since dynamic libraries will be loaded at an unknown address (they're dynamically loaded, after all!) their jumps must all be Position Independent, i.e. they can't jump to absolute addresses or your code won't work!
22:13:49 <fluffynukeit> merijn: this is a great, clear explanation, thank you
22:14:17 <fluffynukeit> merijn: I will try to recompile each in turn with fPIC to see if I can get anywhere
22:14:51 <merijn> fluffynukeit: There were some mailing list/release notes things on the new linker, googling for ghc+dynamic linking+ghci or whatever may turns up something useful
22:16:08 <chirpsalot> So, with JuicyPixels there isn't a magical way to automagically convert any pixel type to a specific one, is there (even if it's lossy)?
22:17:56 <chirpsalot> I.e., does convertPixel always work if promotePixel does?
22:24:13 <chirpsalot> It seems like you could have an instance (ColorConvertible a b) => ColorSpaceConvertible a b where convertPixel = promotePixel?
22:24:29 <chirpsalot> But this doesn't seem to be in the library.
22:24:55 <QF-MichaelK> Is there a sensible way to see whether or not a random string is syntactically valid?
22:25:45 <merijn> QF-MichaelK: By parsing it? Also, syntactically valid what?
22:26:14 <chirpsalot> QF-MichaelK: if you mean syntactically valid Haskell I suspect you could use the GHC library.
22:27:45 <QF-MichaelK> chirpsalot: yes, interesting, thanks for the tip.
22:38:34 <chirpsalot> Oooooh, my proposal for JuicyPixels would need undecidable instances, wouldn't it? :(.
23:03:46 <chirpsalot> Uh...
23:03:58 <chirpsalot> Does GHC use its own gcc?
23:04:20 <chirpsalot> I think this may have broke for me after updating to Yosemite.
23:06:04 <solatis> what do you mean with 'use its own gcc' ?
23:06:30 <merijn> chirpsalot: Did you update XCode command line tools yet?
23:06:53 <merijn> Also, OSX doesn't have gcc anymore
23:08:15 <chirpsalot> merijn: I'm aware, but it seems to be using a gcc version I don't have elsewhere.
23:08:40 <merijn> If GHC is trying to use gcc you probably have a wrong GHC...
23:08:49 <merijn> Which GHC version do you have and how did you install it?
23:09:04 <chirpsalot> 7.8.3, nix.
23:11:20 <merijn> No clue what nix does
23:11:28 <joelteon> it's a package manager
23:11:53 <merijn> I know that
23:12:01 <merijn> But I have no clue how it manages ghc
23:12:17 <merijn> So I have no clue in what way it potentially bollockses the Yosemite upgrade
23:12:37 <joelteon> i don't know what chirpsalot means either
23:12:43 <joelteon> there's no gcc on yosemite
23:13:48 <chirpsalot> joelteon: cabal build is trying to use gcc.
23:14:30 <joelteon> oh, you have to add --with-gcc=clang to the cabal configure flags
23:15:54 <chirpsalot> joelteon: ah, thanks.
23:16:31 <chirpsalot> I'm waiting for ghc to reinstall now >_<. Looks like I managed to get the broken binary from Hydra again, somehow.
23:18:02 <dmj`> chirpsalot: nixos?
23:18:19 <dmj`> or linux
23:18:21 <dmj`> e
23:18:22 <dmj`> r
23:18:36 <chirpsalot> dmj`: OSX.
23:22:26 <dmj`> oh
23:22:31 <dmj`> me too
23:22:34 <dmj`> did you upgrade?
23:23:36 <trap_exit> \
23:23:36 <chirpsalot> dmj`: yep!
23:23:37 <trap_exit> n
23:23:39 <trap_exit> is
23:23:40 <trap_exit> not
23:23:41 <trap_exit> ;
23:23:50 <chirpsalot> dmj`: I figured I would be a guinea pig.
23:24:22 <chirpsalot> (This was not a good decision for me :P)
23:25:11 <dmj`> chirpsalot: what happened?
23:25:14 <dmj`> did it work
23:25:33 <dmj`> did your computer just explode
23:27:04 <chirpsalot> dmj`: eh, it seems to be mostly fine... The install took forever and my Haskell stuff in nix seems to be maybe fubar?
23:27:26 <chirpsalot> Might not be Yosemite's fault :P.
23:29:41 <dmj`> are you using nix-pkgs?
23:36:17 <wyager> Hi all. Question. Please see http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-List.html#cycle . Why did they write “cycle xs = xs’ where xs’ = xs ++ xs’” instead of “cycle xs = xs ++ cycle xs”?
23:37:56 <wyager> They seem like equivalent definitions, with the one from Data.List having more cruft
23:38:59 <dmj`> wyager: tying the knot
23:39:11 <dmj`> http://www.haskell.org/haskellwiki/Tying_the_Knot
23:40:11 <wyager> But how is it different from my thing?
23:40:33 <wyager> You can literally just to a substitution and get exactly “cycle xs = xs ++ cycle xs”, right?
23:40:36 <wyager> *do a
23:40:46 <simpson> wyager: The former increases sharing.
23:40:59 <wyager> What does “increases sharing” mean?
23:41:40 <simpson> I'm not the best at this, but I'll try.
23:41:51 <simpson> `cycle xs` on the left is not the same as `cycle xs` on the right.
23:42:17 <simpson> The definition of `xs'` is reused, so it's the same list every time.
23:42:22 <wyager> correct
23:42:34 <simpson> But in your version, `cycle` is reentered every time you reach the end of the list.
23:43:01 <dmj`> it would be cool to profile the different
23:43:04 <dmj`> difference
23:43:40 <wyager> So we’ve essentially just replaced a function with an argument with a constant. What’s the benefit? Shouldn’t they be optimized to the same thing?
23:44:15 <simpson> Not necessarily.
23:44:20 <wyager> It still has to “call” xs’
23:44:29 <wyager> it’s basically a zero-arg function (unevaluated thunk)
23:45:08 <wyager> and the compiler could(?) optimize away the constant xs argument to further calls to cycle anyway
23:45:27 <dmj`> http://stackoverflow.com/questions/357956/explanation-of-tying-the-knot
23:45:30 <simpson> In theory, yeah, but it doesn't necessarily happen. IIUC GHC can't guarantee it.
23:45:30 <merijn> wyager: But that's hard to detect
23:45:35 <wyager> But I do see how the xs’ way would be easier to optimize
23:45:38 <merijn> wyager: Explicit naming makes sure it happens in GHC
23:45:44 <wyager> cool
23:46:43 <wyager> So basically, if you can take any recursive function calls with arguments and bind them to constants instead, you’re guaranteed to get at least a certain type of optimization?
23:47:31 <simpson> Note that the recursion here is not changing the value that is passed around.
23:47:33 <simpson> That's part of it.
23:48:51 <wyager> thanks guys
23:48:53 <wyager> appreciate it
23:51:13 <wyager> Also, you guys ever write really trivial functions in C and Haskell and compare the emitted assembly? GHC actually did a slightly better fibonacci sequence loop than GCC when I tried it
23:51:29 <wyager> Fewer instructions, a tiny bit faster
23:54:39 <solatis> ok, i give up
23:54:45 <solatis> i can't get profiling to work
23:55:04 <solatis> it just appears to be one big clusterhell of rebuilding *everything*
23:56:34 <merijn> solatis: It is, currently there's no way to really build profiling libraries after the fact
23:56:51 <johnw> well, unless you use Nix :)
23:56:56 <merijn> Backpack is supposed to add the ability to do this, but it's not near done yet
23:56:58 <solatis> i use nix...
23:57:03 <johnw> yeah?
23:57:09 <solatis> yeah
23:57:11 <johnw> it should only rebuild the libraries needed to build your project
23:57:36 <solatis> yeah i'm actually using nix directly to build my haskell projects
23:57:41 <solatis> so i don't invoke cabal manually
23:57:50 <johnw> cool, so what's the trouble?
23:57:56 <solatis> well, i don't know
23:57:58 <johnw> (feel free to ask in #nixos if it's more appropriate there)
23:58:28 <solatis> it appears that my core *library* appears to be being built with --enable-library-profiling, so that is good
23:58:44 <johnw> ah
23:58:49 <johnw> ok, I know what your problem is
23:59:00 <johnw> in the buildFlags for your expresison, put --enable-executable-prolifing
23:59:05 <johnw> profiling
23:59:11 <solatis> hmmm
23:59:11 <johnw> the Nix builder does *not* do this, and there's no way to ask it to
23:59:15 <solatis> aha
23:59:23 * hackagebot fedora-packages 0.0.3 - Haskell interface to the Fedora Packages webapp API.  http://hackage.haskell.org/package/fedora-packages-0.0.3 (RickyElrod)
23:59:23 * hackagebot posix-pty 0.1.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/posix-pty-0.1.1 (MerijnVerstraaten)
23:59:23 <solatis> i was adding -prof to ghc-options: in .cabal
23:59:49 <johnw> hmm.. that should work too
