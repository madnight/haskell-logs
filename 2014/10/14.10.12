00:07:22 * hackagebot hzulip 0.2.0.3 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.2.0.3 (yamadapc)
00:07:24 * hackagebot webkitgtk3 0.13.0.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.0.2 (HamishMackenzie)
00:07:58 <augur> paquari: GADTs are easy!
00:10:12 <jle`> they are like ADT's, but G!
00:10:49 <paquari> Right..
00:11:36 <paquari> jle`: so tell me, how to write type an optimizer that eg floats FMap’s up to the top for my regular expression type.
00:22:23 * hackagebot hoogle 4.2.36 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.36 (NeilMitchell)
01:17:25 <nshepperd> I used unsafePerformIO
01:17:28 <nshepperd> I feel unsafe now
01:22:00 <redtricycle> So weird...in my cabal install file, I just comment out dependencies, install, uncomment, install, uncomment, install
01:22:07 <redtricycle> wonder why it woldnt work with just all 3 at the same time
01:24:28 <kazagistar> nshepperd: thats probably cause you are
01:27:26 * hackagebot webkit 0.13.0.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.0.2 (HamishMackenzie)
01:27:45 <wei2912> nshepperd: yeh, you may hear some people knocking on your door at midnight
01:42:26 * hackagebot webkitgtk3-javascriptcore 0.13.0.1 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.0.1 (HamishMackenzie)
01:47:26 * hackagebot webkit-javascriptcore 0.13.0.1 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.13.0.1 (HamishMackenzie)
01:50:45 <chrisdotcode> Is there a datastructure that provides (safe) indexing, and the abilty to remove elements at arbitrary indices? And when the item at that index is removed, all the other elements above 'slide' down one index?
01:50:57 <chrisdotcode> Very similar to JavaScript lists
01:52:13 <chrisdotcode> Wait, I don't even think JavaScript lists do that.
01:52:27 <Saizan> Data.Sequence maybe
01:52:53 <chrisdotcode> Will take a look at that
01:53:17 <chrisdotcode> Saizan: Any infinite variant of Data.Sequence?
01:55:58 <Noinia> hmm anyone an idea why this doesn't typecheck: http://lpaste.net/112470
02:00:10 <Cale> Noinia: Apparently because you're not allowed to partially apply type synonyms, even if they're type families
02:00:56 <Noinia> hmm
02:03:15 <Cale> Noinia: If you change them to data families, you can make something work, but you have an explicit constructor applied to "frank"
02:03:45 <lpaste> Cale annotated “Type families” with “Type families (annotation)” at http://lpaste.net/112470#a112471
02:05:59 <Noinia> hmm
02:06:10 <Noinia> let me think about that
02:07:54 <Cale> If the real question is why we can't partially apply type families, well, the answer is probably a bit more subtle
02:08:50 <ddellacosta> is there a faster than linear-time way to append a vector onto another?  Seems like there should be, intuitively...although I guess no matter what you have to re-index whatever you're appending.  Hrm
02:09:04 <ddellacosta> but still, don't see why that is O(m+n)
02:09:13 <Cale> ddellacosta: Like, a Data.Vector sort of vector?
02:09:24 <ddellacosta> Cale: yeah, was just poking around the Data.Vector docs
02:09:36 <ddellacosta> trying to read the implementation now but haven't found it yet
02:09:45 <Cale> Well, you need to allocate the memory for the concatenated vector
02:10:02 <Cale> and then copy the elements from the two vectors to it
02:10:13 <Cale> How could you do that any faster than O(n+m)?
02:10:37 <ddellacosta> Cale: huh, see, I would have thought you'd just be moving address pointers around on the underlying representations, but of course the way you describe it O(n+m) would make sense
02:11:33 <Cale> Vectors are basically contiguous chunks of memory, they don't have fancy tree structures underneath or anything
02:13:53 <Noinia> hmm
02:14:02 <ddellacosta> Cale: ah, okay, I was assuming something more like Bagwell's HAMTs I guess.  Okay, thanks--will read up on them further
02:14:24 <Noinia> the thing with the data families is a nice trick. However, it seems that I really want type families :(
02:16:10 <ddellacosta> (or rather, RRB-trees)
02:16:38 * ddellacosta goes to look up RRB tree implementations in Haskell
02:18:15 <Cale> ddellacosta: There's Data.Sequence which has log-time concatenation and splitting at an arbitrary point
02:18:29 <Cale> ddellacosta: But there's a fair amount of overhead
02:19:14 <ddellacosta> Cale: ah, thanks for the pointer. I'm still familiarizing myself with data structures available in the standard lib
02:19:53 <ddellacosta> I love the Haskell standard lib docs.  It's so cool that it includes efficiencies
02:21:12 <Noinia> what I think is severely lacking from the standard docs is just a generic balanced binary search tree though
02:21:21 <xificurC> what does Ord(..) stand for again?
02:22:28 <Noinia> standard docs = standard libs, e.g. containers or so
02:23:25 <ddellacosta> Noinia: Right, figured that's what you meant.  Yeah, I guess so, although it's not super hard to write
02:23:50 <wei2912> any ideas for https://codereview.stackexchange.com/questions/66387/optimizing-a-divide-and-conquer-algorithm-for-counting-inversions ? :)
02:23:57 <int-e> xificurC: in an import list, it will import the Ord class and its class methods
02:25:03 <xificurC> int-e: so it skips only what, the constructors?
02:25:21 <int-e> xificurC: Ord is a type class, it doesn't have constructors
02:25:45 <Noinia> ddellacosta: sure. But it does mean switching to a different data struct/library. Which may have slightly different names etc.
02:25:54 <Noinia> so it is not hard, but it is annoying :P
02:26:00 <ddellacosta> yeah, fair enough
02:26:16 <paul__1> quit
02:26:39 <xificurC> int-e: so in this case what is the difference between import Ord and import Ord(..)
02:28:04 <int-e> xificurC: the former will only import the type class. So `compare`, (<), (>=), (>), (<=), max and min (those are Ord's class methods) will still not be imported.
02:28:26 <int-e> xificurC: but you could write type signatures like  foo :: Ord a => a -> Bool.
02:28:48 <xificurC> int-e: I see, thank you very much
02:29:56 <int-e> xificurC: btw, to find the method names, I used  :i Ord  in ghci. I don't know all of them by heart.
02:30:21 <ClaudiusMaximus> that's the difference between import SomeModule(Ord) and import SomeModule(Ord(..)) , I think import SomeModule and import SomeModule(..) would be equivalent (assuming the latter syntax is allowed)
02:31:08 <ClaudiusMaximus> (and it isn't allowed)
02:32:28 * hackagebot defargs 0.1 - default arguments in haskell  http://hackage.haskell.org/package/defargs-0.1 (Kinokkory)
02:32:30 * hackagebot leksah-server 0.14.0.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.14.0.1 (HamishMackenzie)
02:32:58 <gigabytes> hello
02:33:03 <gigabytes> a little question about type holes
02:33:37 <xificurC> int-e: thanks again :)
02:33:40 <gigabytes> why do I sometimes get the proper error about the type hole with the bindings and everything, and other times I simply get "pattern matching syntax in expression context: _"?
02:33:54 <gigabytes> what are the rules about which places can a hole appear?
02:36:20 <fizruk> is there a common way to parse command line command such as “echo -n ‘Hello, world!’” to [“echo”, “-n”, “Hello, world!”]?
02:38:58 <xificurC> fizruk: maybe http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Environment.html#v:getArgs ?
02:40:00 <fizruk> xificurC: no, let me elaborate a bit
02:40:11 <fizruk> I have a String with command options
02:40:43 <fizruk> I have a function [String] -> IO () which accepts options
02:42:07 <fizruk> I need something like `words` to split options and feed them to my function
02:42:58 <fizruk> but `words` would split arguments like ‘Hello, world!’, which I don’t want to happen
02:42:59 <mauke> fizruk: what are you writing?
02:43:55 <hexagoxel_> fizruk: not perfect: {lex} will handle the quoted string, but it will split -n into "-" and "n"
02:45:14 <solatis> fizruk: are you looking for a command line argument parser?
02:45:34 <solatis> otherwise, i think you're SOL and need to write your own parser, or go fancy with regex
02:48:27 <MindIsAVortex> Hi there, how can I filter a list of tuples on just one of their values. So say I have a list [(A, 0), (B, 2), (C, 0), (D, 1)] I want to have a list with [(B, 2), (D, 1)]
02:48:58 <int-e> @type (==0).snd
02:49:00 <lambdabot> (Num b, Eq b) => (a, b) -> Bool
02:49:14 <int-e> @type filter
02:49:15 <lambdabot> (a -> Bool) -> [a] -> [a]
02:50:28 <fizruk> mauke: ehm… a program to manage lxc containers. I would like user to have template options for lxc-create command in a config file (like “-d ubuntu -r trusty -a amd64”), I plan to pass them to haskell LXC API bindings, which accept a list of arguments rather than a single String.
02:51:23 <MindIsAVortex> thanks!
02:52:08 <fizruk> so there seem to be no way to parse it, I guess I should have user split arguments for me
02:52:17 <fizruk> no reasonable way
02:52:24 <mauke> fizruk: do you want to replicate all of the shell syntax?
02:52:35 <mauke> -x "foo bar", 'foo bar', foo\ bar, ...?
02:52:54 <fizruk> mauke: that would be great, I guess
02:53:30 <jle`> :t on
02:53:42 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
02:53:53 <mauke> fizruk: fo`echo o bar`?
02:53:54 <jle`> @djinn (b -> b -> c) -> (a -> b) -> (a -> a -> c)
02:53:57 <lambdabot> f a b c _ = a (b c) (b c)
02:54:09 <jle`> interesting
02:54:16 <mauke> fizruk: $variables? $(command substitution)? $'C-style strings'?
02:54:41 <jle`> why doesn't djinn try to use all of the inputs?
02:55:06 <fizruk> mauke: no commands/variables, there will be no access to any environment, this should be a pure parse
02:55:37 <jle`> @djinn (c -> d -> e) -> (a -> c) -> (b -> d) -> (a -> b -> e)
02:55:39 <lambdabot> f a b c d e = a (b d) (c e)
02:55:56 <jle`> @. pl djinn (c -> d -> e) -> (a -> c) -> (b -> d) -> (a -> b -> e)
02:55:56 <lambdabot> f = ((flip . ((.) .)) .) . (.)
02:56:38 <hexagoxel_> :exf --pretty (b -> b -> c) -> (a -> b) -> (a -> a -> c)
02:56:38 <exferenceBot> \ b c d e -> b (c d) (c e)
02:56:53 <gigabytes> look at this response by lambdabot
02:57:05 <gigabytes> @pl f x y = snd x == snd y
02:57:05 <lambdabot> f = (. snd) . (==) . snd
02:57:49 <gigabytes> could it be teached to reply ((==) `on` snd) instead?
02:58:16 <hexagoxel_> (the version of exferenceBot i am running is completely outdated atm)
03:01:45 <fizruk> mauke: were you going to suggest running another program with those arguments, which would use getArgs >>= print? :)
03:08:30 <mauke> fizruk: no :-)
03:08:54 <mauke> I wasn't going to suggest anything; just trying to get a feeling for the problem space
03:11:09 <gigabytes> guys, is the binding of variables in a let expression lazy or strict?
03:11:17 <gigabytes> I mean if I do let (Just x) = something
03:11:29 <fizruk> > let Just x = Nothing in 1
03:11:30 <gigabytes> will fail with Nothing only if I use x?
03:11:32 <lambdabot>  1
03:11:38 <fizruk> gigabytes: lazy ^
03:11:46 <gigabytes> fizruk: ok!
03:12:08 <fizruk> > do { let Just x = Nothing; return 1 } :: Maybe Int
03:12:11 <lambdabot>  <hint>:1:37: parse error on input ‘}’
03:14:02 <ClaudiusMaximus> > do { let { Just x = Nothing }; return 1 } :: Maybe Int -- needs more {}, fizruk
03:14:07 <lambdabot>  Just 1
03:14:28 <fizruk> ClaudiusMaximus: didn’t know that, thanks!
03:16:27 <YurasS> do we have good library for url manipulation? :|
03:16:36 * YurasS spent 2 days looking for one
03:17:30 * hackagebot hdf 0.15 - HDF: Uniform Rate Audio Signal Processing in Haskell  http://hackage.haskell.org/package/hdf-0.15 (RohanDrape)
03:18:40 <int-e> wei2912: http://lpaste.net/112472 allocates a bit less and runs slightly faster than your code, but is also a bit harder to understand (it exploits the fact that when doing bottom-up merge sorting, the resulting lists (except the last) of the n-th stage all have length 2^n).
03:20:29 <wei2912> int-e: thanks, but i have no idea what you wrote :(
03:22:00 <wei2912> int-e: do you mind explaining in detail what your code does?
03:24:39 <int-e> wei2912: it's a merge sort, with an additional accumulator (i) counting inversions, and an auxilliary length argument (l) tracking the length of the first list being merged. 'merge' is more or less equivalent to your countSplitInv'.
03:25:21 <int-e> (ah, "auxiliary" and I will never become friends)
03:25:27 <wei2912> lol
03:26:01 <wei2912> so firstly, the list is converted into a list of single elements
03:27:11 <wei2912> and then... i got lost at mergePairs. does it merge the two sorted arrays?
03:27:24 <wei2912> no, that's what merge does
03:27:26 <int-e> wei2912: right. and then such a list of lists (starting with many lists of size l=2^n for some n, and a remainder) is processed by taking pairs off the list, and merging them, resulting in a similar list beginning with chunks of 2^(n+1). That's mergePairs' job.
03:27:40 <int-e> (splitting off pairs)
03:27:53 <wei2912> ah, i see
03:28:16 <wei2912> what's ! for?
03:28:34 <int-e> It's making arguments strict.
03:29:17 <int-e> It's particularly important for the i accumulator which would otherwise become a big, unevaluated sum on the heap.
03:29:23 <wei2912> thanks
03:52:31 * hackagebot leksah 0.14.1.1 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.1.1 (HamishMackenzie)
03:58:49 <Eliott23>  Never Pay for Porn ever again. Click Here! http://bit.do/my_videos69
03:59:18 <Qfwfq> 'Pornography for Free!'
04:03:00 <nshepperd> ,mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmy7uuuuuuuuuuuuuuubbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbghhhhhhhhhhhhhhhhhhhhhhh0- o78-8*,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~xx c
04:03:13 <capisce> bless you
04:03:40 <MP2E> quite the side effect, there
04:05:06 <nshepperd> ^_^
04:05:14 <nshepperd> kitten driven development
04:05:30 <MP2E> hehehe
04:25:31 <mmmm_> Is the ImplicitParams extension widely used?
04:25:46 <gfixler_> l
04:37:25 <Fuuzetsu> mmmm_: no
04:37:45 <Fuuzetsu> the most use it sees is probably in here
04:38:21 <Fuuzetsu> :t let f = ?x + ?y in f
04:38:22 <lambdabot> (?y::a, ?x::a, Num a) => a
04:40:08 <chaosfisch> Can I get a hint for a competition (shortest solution #tokens wins) with what I can further optimize? I'm still new to haskell, so this isn't obvious to me: allDistinct a b c d e = helper [a,b,c,d,e]
04:55:57 <Fuuzetsu> chaosfisch: it's unclear what you're trying to do…
04:56:33 <Fuuzetsu> helper = (== 5) . length . nub
04:56:34 <Fuuzetsu> ?
04:56:46 <chaosfisch> helper = ap (==) nub
04:57:18 <MagneticDuck> chaosfisch: what do you want to golfify
04:57:20 <MagneticDuck> xD
04:57:33 <chaosfisch> Basically the function takes 5 Integers. Integer -> Integer -> Integer -> Integer -> Integer -> Bool and returns true if all 5 integers are distinct
04:58:17 <Fuuzetsu> then ‘all (== a) [b,c,d,e]’ should work
04:58:25 <MagneticDuck> sadly, I don't think there's any way to fold across a list of arguments
04:59:40 <Fuuzetsu> uh, all (/= a) …
04:59:48 <Fuuzetsu> do we have none?
04:59:49 <Fuuzetsu> :t none
04:59:51 <lambdabot> Foldable f => (a -> Bool) -> f a -> Bool
05:00:14 <Fuuzetsu> although that's one extra character ;P
05:00:15 <Philonous> Fuuzetsu, Even then, [1,2,2,3,4] would be a false positive
05:00:34 <gigabytes> let l=[a,b,c,d] in all (== True) [x /= y | x <- l, y <- l]
05:00:35 <Fuuzetsu> Philonous: good point
05:00:46 <Fuuzetsu> Philonous: the nub method I gave initially still works for thata though
05:01:05 <MagneticDuck> gigabytes: but that's order n^2, while nub is order n
05:01:14 <MagneticDuck> the best solution is still : ap (==) nub
05:01:18 <Fuuzetsu> nub is O(mygodwhatareyoudoing)
05:01:21 <gigabytes> what's ap?
05:01:25 <MagneticDuck> Fuuzetsu: oh lols
05:01:26 <chaosfisch> Ehm, my solution works. Don't know about yours with the "all...." But it's too long in terms of Tokens.
05:01:27 <MagneticDuck> ups
05:01:40 <MagneticDuck> sorry, my O() logic died
05:01:58 * MagneticDuck is really stupid sometimes
05:02:03 <chaosfisch> I probably need a way to make this List creation shorter.
05:02:32 <MagneticDuck> chaosfisch: unfortunately there isn't any
05:02:36 <MagneticDuck> not without template haskell
05:02:55 <chaosfisch> MagneticDuck: Okay, but I know that this can get shorter: allDistinct a b c d e = ap (==) nub [a,b,c,d,e]
05:03:07 <MagneticDuck> there is no way to generalise a function of type (a -> a -> ...) as a fold over its elements
05:03:29 <MagneticDuck> chaosfisch: take out some of the spaces xD
05:03:37 <vanila> chaosfisch, how do you know that?
05:03:39 <Fuuzetsu> MagneticDuck: isn't that what variadic functions do though
05:03:40 <chaosfisch> MagneticDuck: They don't even count :P
05:03:46 <Fuuzetsu> it won't be shorter of course
05:03:56 <MagneticDuck> Fuuzetsu: oh
05:03:58 <MagneticDuck> uhm
05:04:03 <MagneticDuck> !
05:05:03 <MagneticDuck> you guys should probably just ignore me for a few minutes until I get my shit together :D (everything I've said in the last 5 minutes is wrong)
05:05:33 <MagneticDuck> chaosfisch: I'd like to see how that can be made shorter!
05:05:53 <Fuuzetsu> the list creation won't get anay shorter
05:05:54 <Fuuzetsu> any*
05:07:17 <chaosfisch> MagneticDuck: I can't tell you before Friday. but in terms of Tokens there's improvment possible. This solutions has 23 Tokens, but I was told, there's a better solution with a few less tokens.
05:07:28 <Fuuzetsu> how are we counting tokens?
05:08:25 <Fuuzetsu> also what modules are you limited to
05:09:01 <chaosfisch> Every ()[],...is one token. (==) is one token. Every function name and parameter is one token. So theoretically the solution can be longer than mine in #characters.
05:09:07 <m-r-r> Hello
05:09:31 <chaosfisch> Everything that from the base package - as long as I can import it without installing anything
05:10:15 <chaosfisch> As an example for token counting: allDistinct a b c d e = ap (==) nub [a,b,c,d,e] ------> 23 aabcde=a(=)n[a,b,c,d,e]
05:11:11 <MagneticDuck> chaosfisch: that doesn't make much sense >_>
05:11:36 <m-r-r> I have a type class, and i'm trying to write an instance of it that works for all insances of Typeable: http://ix.io/eJ1
05:11:45 <MagneticDuck> you're not talking about haskell language tokens, it seems
05:12:34 <indiagreen> chaosfisch: so if there was a synonym for (==) which isn't an operator, there'd be 2 tokens less?
05:13:26 <chaosfisch> indiagreen: That's right, if you can replace (==) with magicfunctionname it's 2 tokens less
05:14:02 <m-r-r> I'm still learning Haskell, i have no idea why my code does not compile :-/
05:15:30 <m-r-r> Here are the error messages the compiler gave me: http://ix.io/eJ2
05:16:20 <m-r-r> Any idea of what i did wrong ?
05:17:18 <MagneticDuck> first things first, you have a bunch of type errors
05:21:41 <m-r-r> MagneticDuck: yes :-/ For instance, the compiler complains that the type of `tableName` is [Char] instead of `a0 -> [Char]` but `:t show . toConstr` is `a -> String`
05:22:35 * hackagebot ekg-carbon 1.0.2 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.2 (OliverCharles)
05:24:45 <zomg> m-r-r: most likely that error is caused by the fact that `tableName` *should* be a String
05:24:49 <MagneticDuck> m-r-r: no
05:25:03 <MagneticDuck> it's giving you that error in an equation for tableName
05:25:03 <zomg> as in, the way you're using it causes the compiler to infer that type for it
05:25:35 <MagneticDuck> toSql . show . toConstr is what shoould be a -> [Char] but is in fact [Char]
05:25:39 <zomg> also listen to him, he's better at explaining this =)
05:25:49 <MagneticDuck> ups, switch a -> [Char] and [Char]
05:25:55 <Twey> Can I give a default implementation of an associated type family?
05:27:53 <m-r-r> zomg: but in my typeclass, i wrote `tableName :: a -> String`. I thought it meant `tableName` had to be a function taking an `a` as argument and returning a `String` :-/
05:30:55 <MagneticDuck> m-r-r: okay, looking at it xD
05:31:29 <MagneticDuck> okay, your problem is this: tableName has type (Data a) => a -> String
05:31:46 <Twey> Or rather, if I have an associated type family, class Foo a where type Bar a :: *; type Bar a = (); bar :: Proxy a -> Bar a; bar _ = (), can I default *both* the type family and the method?  If I write it like that I get an error that Bar a can't be resolved to (), which is of course true in the general case but I'd hope not in the default
05:31:54 <MagneticDuck> but you don't define any typeclass dependency, and expect it to be just "a -> String"
05:32:24 <Cale> m-r-r: Typeable a is not a type, it's a constraint
05:32:38 <MagneticDuck> also that lols
05:32:39 <Cale> So  instance SqlTable (Typeable a)  doesn't make sense
05:32:52 <MagneticDuck> that's probably why the type errors were so strange
05:32:58 <MagneticDuck> the compiler didn't even know where to start :D
05:34:30 <m-r-r> MagneticDuck, Cale: Ok, thanks for your responses :-) I'll try changing `:: a -> String` to `:: (Data a, Typeable a) => a -> String`
05:34:31 <Cale> If you end up wanting to write an instance of a type class which applies to every type which is also an instance of another type class, probably type classes are the wrong solution.
05:35:11 <Cale> You could write (by turning on some extensions)   instance (Typeable a) => SqlTable a where ...
05:35:22 <Cale> However, this instance will overlap with every other instance
05:36:19 <MagneticDuck> m-r-r: why don't you just write functions tableName, tableFields, and tablePrimaryKey as (Typeable a) => <type with free variable a> and ignore the typeclass completely?
05:36:20 <Cale> The reason for this is that when deciding which instance applies, the instance selection mechanism can't rely on the *absence* of an instance, because the instance might be in some other module which hasn't been compiled yet.
05:36:47 <Cale> So, it ignores those constraints until determining which instance is to be selected, and then insists that they hold
05:37:07 <m-r-r> MagneticDuck: because i want to be able to write specialized version of the function for certains types
05:37:16 <Cale> So, for the purposes of selecting which instance to use, that instance would look like  instance SqlTable a where ...
05:37:30 <Cale> which means that it would conflict with everything else
05:38:47 <m-r-r> Cale: so, there is no way to do what i want to do ?
05:39:13 <Cale> Well, there are some other options you could consider
05:39:59 <Cale> One would be to provide default implementations that rely on Typeable in the class declaration, so that new instances of SqlTable for types that were already Typeable would be easy
05:40:19 <Cale> (Or it looks like you really need Data, but that too)
05:40:37 <m-r-r> Cale: ok, i'm trying that :-)
05:40:45 <Cale> Another would be to turn the type class into a data type instead
05:42:11 <Cale> i.e. have  data SqlTable a = SqlTable { tableName :: a -> String; tableFields :: a -> [String]; tablePrimaryKey :: a -> Integer } -- of course, it looks like you're usually not using the values of type a, so perhaps this could even be simplified to remove the parameters
05:44:19 <chaosfisch> So I've tried a few more things - maybe that's the way to go: http://lpaste.net/4391670048037535744 . It looks good intially, but the question is how I could inline my helper function now.
05:45:12 <lilred> hello Haskell
05:45:25 <lilred> What's the general pattern in Haskell for iterating over a stream?
05:45:39 <Cale> chaosfisch: what the...
05:45:54 <Cale> chaosfisch: Why not just helper a b c d e = [a,b,c,d,e]?
05:46:13 <Cale> chaosfisch: Is there a reason you're using printf and read?
05:46:20 <chaosfisch> Cale: Because this one is shorter in terms of tokens for the competition
05:46:34 <lilred> no one can help me with streams? :(
05:46:34 <chaosfisch> At least if I can inline the helper function now
05:46:47 <Cale> lilred: What kind of stream?
05:47:07 <lilred> Cale: probably an UTF-8 string streaming from disk.
05:47:27 <Cale> lilred: Perhaps Data.Text.Lazy?
05:48:13 <Cale> Or you could just use readFile, which will produce a lazy String whose evaluation will cause the disk to be read.
05:48:23 <benzrf> Cale: how awful
05:48:34 <Cale> ?
05:48:40 <benzrf> lazy io!!!
05:48:43 <Cale> so?
05:48:52 <Cale> Often it's convenient
05:49:03 <lilred> Cale: thanks for the help :) while I'll probably use something out of Data.Text, I'm curious - isn't there something that abstracts out the "text" aspect?
05:49:18 <Cale> lilred: I'm not sure what you mean
05:49:27 <lilred> Cale: so you basically end up working on a generic stream of arbitrary source.
05:49:37 <Cale> There are lists
05:49:49 <Cale> Though lists and text are not really the same when it comes to various operations
05:49:50 <lilred> Are lists lazy though?
05:49:52 <Cale> yes
05:49:59 <lilred> wooo
05:50:01 <benzrf> lilred: lists are lazier than most programmers
05:50:22 <lilred> Thanks for the help guys.
05:50:26 <chaosfisch> Cale: Is it possible to inline the helper?
05:50:38 <lilred> I'm just dabbling in lazy programming.
05:50:41 <Cale> chaosfisch: sure, just copy paste the definition in
05:50:59 <Cale> chaosfisch: Oh, and replace one of the $'s with a .
05:51:32 <Cale> I suppose that's optional :)
05:52:02 <chaosfisch> like that?! allDistinct a b c d e = ap (==) nub $ read . printf "[%d,%d,%d,%d,%d]" a b c d e
05:52:11 <Cale> no, the other one :)
05:52:33 <Cale> f . g $ x
05:52:37 <Cale> is the same as f (g x)
05:53:54 <chaosfisch> hm, compiler complains about "The type variable `a0' is ambiguous" so inline didnt work this way
05:54:25 <Cale> Oh, you'll probably have to say which type you're reading the things as
05:54:32 <lilred> What pastebin should I use if I want to share text with you guys?
05:54:37 <Cale> lpaste.net
05:55:48 <lilred> Cale: thanks! Any way to post a file to it from the CLI?
05:56:58 <Cale> No idea, I usually just use my clipboard
05:58:20 <Cale> iirc, xsel might be useful
06:05:26 <m-r-r> Ok, i modified my code: http://ix.io/eJ7 I still have to derive from Data even if i don't use the default implementation, but now it works :-) Thanks to all for you help :-)
06:05:50 <timthelion> Can someone remind me where to put the forall in: data Foo = Foo {f :: Int -> b,g :: b -> Int}?
06:06:50 <bennofs> timthelion: you probably want data Foo = forall b. Foo { f :: Int -> b, g :: b -> Int }
06:07:23 <timthelion> bennofs: yes, I probably do.  Now why isn't there an example like that here: http://www.haskell.org/ghc/docs/5.02/set/universal-quantification.html
06:07:41 <timthelion> bennofs: thank you
06:08:04 <Cale> timthelion: You are looking at GHC docs from around the time I started programming in Haskell back in 2001 or so
06:08:31 <Cale> (note the version number in the URL)
06:08:45 <timthelion> Cale: aha
06:08:46 <bennofs> timthelion: because it's an existential qualification in reality
06:09:07 <Cale> Yeah, you'll find information about this under the documentation for existential types
06:09:23 * timthelion crosses yandex off the list of alternative search engines to try.
06:09:55 <timthelion> Why is it existential?
06:10:21 <timthelion> Because there exists a type b that might be the right type?
06:11:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
06:11:13 <Cale> yeah
06:16:15 <lilred> Jesus Christ Haskell is tough
06:16:39 <benzrf> lilred: what is it now :|
06:16:42 <dfeuer> lilred, who is Jesus Christ Haskell, and what's tough about him?
06:16:48 <Twey> timthelion: Universal and existential types are duals.  From the constructor's (i.e. the chunk of code that constructs the value's) point of view, it can provide literally any b it likes (universal).  From the eliminator's (i.e. the chunk of code that accesses the data inside the value's) point of view, it gets some particular unknown b — it knows the b exists, but it has no idea what it is (existential).
06:17:01 <Twey> Jesus Christ Haskell sounds like a US university.
06:17:27 <lilred> benzrf, dfeuer: I'm just having trouble navigating the language. I'm a language geek, my usual strategy is to read about the language until I've got a proper tour, and then start coding in it
06:17:45 <mauke> ah
06:17:48 <benzrf> lilred: that's because you expect to already know most of the underlying concepts
06:17:49 <lilred> But I've been reading about Haskell for like three years without reaching the bottom - and now that I try my hand at it I'm hopelessly confused
06:17:50 <dfeuer> timthelion, note that the GADT syntax makes it possible to define existential types without having to wonder too hard whether you've done it right.
06:18:02 <mauke> foiled by your preconceptions
06:18:05 <benzrf> lilred: which is fine when you live in a universe of languages that are all basically similar
06:18:15 <lilred> for example what dfeuer said, how do GADTs and existentials tie together o_O
06:18:20 <dfeuer> Yes, lilred, you'd better start the coding before you do all that reading.
06:18:22 <benzrf> lilred: but when you step next door to a completely unlike language...
06:18:31 <benzrf> lilred: it's like learning to program all over =D
06:18:47 <dfeuer> GADTs are more powerful than existentials, and also easier to read, so just don't bother reading about existentials.
06:18:47 <lilred> yeah :c
06:19:05 <lilred> dfeuer: but often it's better to use the weaker solution!
06:19:19 <lilred> dfeuer: like in the paper about structured graphs for EDSL representation
06:19:28 <dfeuer> (From a practical standpoint--in theory, they're separate features, and the existentials are just sort of snuck into the gadts, but you don't have to care)
06:20:14 <lilred> also I'm still unclear why "existentials" are declared using "forall", which is ostensibly referring to universal quantification
06:20:36 <mauke> they're dual
06:20:42 <Twey> lilred: It's also quite important to draw a line between Haskell and applications of Haskell.  Haskell's really a fairly simple and straightforward language (with some quirks, obviously).  But it's also very powerful, so people do some crazy stuff with it.  You don't need to understand e.g. lens before you can say you know Haskell, though.
06:20:48 <lilred> yeah but DeMorgan's law doesn't apply in Haskell since there are bottom values
06:20:53 <Twey> lilred: See my explanation above
06:21:18 <lilred> Twey: I'm using irssi for the first time and I don't know how to scroll -___-
06:21:24 <Twey> lilred: Page Up
06:21:36 <lilred> ooo sick thanks
06:21:42 <Twey> Also Alt-p/n, if I remember correctly
06:21:58 <vikraman> hi, how do I prevent the ambiguous type in this type class: http://lpaste.net/112475
06:22:01 <vikraman> I don't have a functional dependency
06:22:25 <mauke> add a functional dependency
06:22:30 <lilred> That's a very good explanation, thanks Twey.
06:22:31 <mauke> or remove bar
06:23:07 <lilred> I'm currently doing a degree in software engineering, and trying to learn Haskell in my spare time. To quote Mark Twain, I feel like my schooling is getting in the way of my education.
06:23:16 <benzrf> lilred: h h h hee
06:23:16 <Twey> lilred: No problem.  You happened to catch me at a time when I've been wrestling with bizarre type-hackery for the better part of a week :þ
06:23:29 <lilred> Twey: bizarre type hackery is best hackery
06:23:53 <benzrf> i can't remember the last time i learned something about math or computers that i cared about in school
06:23:57 <mauke> remember when ghc accepted 'instance Eq (Eq a) where (==) = True'
06:24:35 <lilred> benzrf: I'm taking a bunch of math and TCS classes that aren't being credited towards my degree just so I can stay sane. Stuff like automated logic, language theory for formal verification, etc.
06:24:40 <Twey> vikraman: It's ambiguous because it's ambiguous — there's no way for the compiler to tell what b is supposed to be, given that code.  You need to specify it somehow — like by adding a dummy parameter to ‘bar’, or adding a functional dependency to the class so that you know b given either a or c.
06:24:55 <Twey> vikraman: (there's no way for anyone else to tell what b is supposed to be, either)
06:25:14 <vikraman> yes, that's what I was expecting, thanks.
06:25:28 <lilred> while we're at it, how would someone design a pluggable architecture in Haskell?
06:25:29 <Twey> mauke: Why would that type-check?
06:25:41 <lilred> ideally something that doesn't need recompilation
06:26:02 <Twey> lilred: I've always been a fan of building protocols rather than plugins
06:26:21 <benzrf> mauke: whaaaat?
06:26:26 <benzrf> mauke: that's ill-kinded
06:26:37 <Twey> benzrf: Hah, you kids today with your ‘kinds’
06:26:49 <benzrf> i mean
06:26:55 <benzrf> what would the semantics of that even BE?
06:26:56 <benzrf> ;-;
06:27:03 <mauke> @let instance Eq (Eq a) where (==) = True
06:27:05 <lambdabot>  .L.hs:187:14:
06:27:05 <lambdabot>      The first argument of ‘Eq’ should have kind ‘*’,
06:27:05 <lambdabot>        but ‘Eq a’ has kind ‘Constraint’
06:27:05 <lambdabot>      In the instance declaration for ‘Eq (Eq a)’
06:27:08 <mauke> aw
06:27:11 <Twey> benzrf: It wasn't that long ago that GHC didn't have a kind system.
06:27:13 <mauke> they fixed it
06:28:40 <Twey> I remember that just back in 7.…4? GHC would accept ⇒ in place of → — it would just blindly transform constraints to dictionaries and replace ⇒ with →
06:28:50 <Twey> mauke: It's the (==) = True bit that I don't get
06:29:07 <Twey> Surely unifying Bool with a → a → Bool would fail
06:29:30 <Twey> Or Eq a → Eq a → Bool, or whatever
06:29:37 <benzrf> Twey: holy         shit
06:29:44 <mauke> ¯\(°_o)/¯
06:29:55 <benzrf> Twey: so what, you'd get a reified dictionary as an argument?!
06:30:02 <Twey> I discovered that, but too late ☹
06:30:22 <Twey> benzrf: No, you could just write functions like: (+) ∷ Num a ⇒ a ⇒ a ⇒ a
06:30:37 <lilred> Hey guys, what's the &= symbol I'm seeing here: https://github.com/jhenahan/lpaste-cli/blob/master/Main.hs
06:30:40 <benzrf> o h
06:30:50 <benzrf> eek
06:30:56 <benzrf> lilred: some function
06:31:27 <Twey> lilred: Comes from CmdArgs probably
06:31:59 <Twey> Oh, yeah, CmdArgs is evil
06:32:28 <Twey> The &= does some weird impure stuff to register the string as an argument in some behind-the-scenes argument map
06:32:39 <Twey> If I remember correctly
06:32:48 <lilred> :c that sounds bad, what's a good alternative?
06:33:01 <Twey> lilred: https://hackage.haskell.org/package/cmdargs-0.10.10/docs/System-Console-CmdArgs-Implicit.html#v:-38--61-
06:33:17 <Twey> Maybe optparse-applicative or something?
06:33:28 <Twey> hflags is supposed to be neat, too
06:34:35 <Twey> « Add an annotation to a value. Note that if the value is evaluated more than once the annotation will only be available the first time. » — run awaaaaay
06:35:55 <lilred> so basically there's no implementation of command-line parsing that's both intuitive and pure? o_O Looking at hflags right now, it uses TemplateHaskell
06:36:27 <Twey> optparse-applicative is, I think
06:36:47 <Twey> hflags' thing is that it does some TH magic so you only have to define flags where you use them, rather than having a big table of options for the whole program
06:36:50 <Philonous> What's wrong with GetOpt?
06:36:53 <benzrf> optparse-applicative is pretty gool
06:37:14 <benzrf> if we had idiom brackets it'd be damn near perfect
06:37:29 <benzrf> oooooooooh can we get idiom brackets for record syntax o3o
06:37:39 * hackagebot hackernews 0.2.3.2 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.2.3.2 (DavidJohnson)
06:37:39 <Twey> GetOpt is pretty scary compared to optparse-applicative, I think
06:38:05 <Philonous> It's a bit clunky, but rather traight-forward
06:38:24 <Twey> I remember being thoroughly intimidated by it as a newbie
06:39:15 <lilred> damn, I thought I could just learn Haskell on the side in time for a hackathon in November
06:39:47 <mauke> I didn't understand GetOpt until I tried to just write my own in Haskell
06:39:52 <mauke> ... the result was basically GetOpt
06:40:02 <Twey> lilred: You might want to slow down and go through LYAH or something
06:40:14 <Twey> Your usual approach probably won't work here
06:40:36 <wei2912> lilred: welcome to haskell
06:40:53 <lilred> Twey: I looked at LYAH, it's mostly stuff I picked up from Ocaml, SML/NJ, F#...
06:41:02 <lilred> Twey: though RWH is damn cool
06:41:31 <Twey> The really scary thing about Haskell is that there's a big hole in the side leading out to the yawning void of research
06:41:40 <Twey> lilred: You might be able to skip some chapters
06:41:50 <nshepperd> optparse-applicative is probably the best thing for command line options
06:42:06 <nshepperd> that I know of
06:42:10 <lilred> Twey: I mean literally all of LYAH is standard fare for FP, save maybe for typeclasses
06:42:18 <lilred> RWH on the other hand gets down and dirty
06:42:56 <FireFly> Is there a neat way to reverse an Ordering? i.e. a function mapping LT to GT and vice versa.  In particular I want to sort a list in descending order, so I'm thinking  sortBy (reverseOrdering . compare)
06:43:13 <lilred> FireFly: not
06:43:31 <nshepperd> FireFly: Down
06:43:41 <mauke> FireFly: flip compare
06:43:53 <lilred> lambdabot: :t not
06:44:00 <FireFly> @ty not
06:44:00 <lambdabot> Bool -> Bool
06:44:05 <FireFly> Pretty sure that won't help me
06:44:10 <FireFly> mauke: oh duh, didn't think of that
06:44:10 <nshepperd> well, Down reverses an Ord instance
06:44:11 <exio4> @ty compare
06:44:12 <lambdabot> Ord a => a -> a -> Ordering
06:44:27 <lilred> @ty not
06:44:27 <lambdabot> Bool -> Bool
06:44:35 <FireFly> nshepperd: where do I find Down?
06:44:36 <Twey> lilred: But it has a lot of stuff about typeclasses ;)
06:44:45 <lilred> @ty Down
06:44:46 <lambdabot> a -> Down a
06:44:56 <Twey> RWH is fine too
06:45:02 <nshepperd> FireFly: Data.Ord
06:45:02 <Philonous> > let revCompare = (EQ `compare`) in revCOmpare LT
06:45:04 <lambdabot>  Not in scope: ‘revCOmpare’
06:45:04 <lambdabot>  Perhaps you meant ‘revCompare’ (line 1)
06:45:08 <Philonous> > let revCompare = (EQ `compare`) in revCompare LT
06:45:10 <lambdabot>  GT
06:45:36 <FireFly> Ah
06:45:41 <benzrf> > compare EQ GT
06:45:43 <lambdabot>  LT
06:45:44 <benzrf> > compare EQ LT
06:45:46 <lambdabot>  GT
06:45:48 <lilred> @ty revCompare
06:45:49 <lambdabot> Not in scope: ‘revCompare’
06:45:51 <benzrf> f a s c i n a t i n g
06:45:58 <benzrf> @let revCompare = (EQ `compare`)
06:46:00 <lambdabot>  Defined.
06:46:01 <benzrf> :t revCompare
06:46:02 <lambdabot> Ordering -> Ordering
06:46:11 <FireFly> benzrf: is that a lens type signature?
06:46:16 <benzrf> huh?
06:46:19 <benzrf> oh lmao
06:46:21 <FireFly> "s t a b"
06:46:26 <lilred> meta question - I'm trying to use optparse-applicative, but I don't know what modules to import. How do I figure that out?
06:46:33 <benzrf> read the docs
06:46:52 <lilred> Hackage?
06:46:56 <benzrf> ye s
06:47:15 <lilred> oh wow I feel silly
06:47:22 <benzrf> haha
06:48:25 <lilred> best part of learning a new language/ecosystem is the really fast progress you make at stuff by figuring out your workflow
06:50:58 <Cale> You can also flip compare
06:51:07 <Cale> Which is more or less the same thing
06:51:32 <Philonous> Oh, now I get what mauke meant earlier.
06:52:57 <FireFly> Yeah, flip compare is what I went with
06:55:18 <Krass> woah many people..
06:55:20 <Krass> hello.
06:55:28 <timthelion> hi
06:56:03 <Krass> got a 'weird' question..  I was redirected here from Efnet #math :)... so here it is:
06:56:13 <Krass> <+Krass__> no idea if this is related to #math, but would there be any application able to find/guess/(actually cheat) some algorithm:  I have about a hundred 'codes' coming from a contest..  wouldn't there be some brute force apps like the ones we see for cracking password or software serials..
06:56:23 <Krass> It's 8 length, and almost always has 4 or 5 num-digits.  Other halfs are letters..  From A to Z and 0 to 9, excluding 0,O,1,I,5 and S
06:57:07 <timthelion> Krass: that is a feild of study yes.  I forget what it is called. I'm sure Cale will be able to provide you with a list of prominent papers.
06:57:31 <pjdelport> Krass: What kind of "codes"?
06:57:39 <pjdelport> Do they all have some common structure?
06:58:04 <Krass> pjdelport:  well yes, kinda..  8 in length.. and very RARELY under 4 numberical digits in it.
06:58:16 <pjdelport> Well, i mean, are they things like substitution ciphers, or similar?
06:58:26 <pjdelport> What does "code" mean exactly in this context?
06:59:12 <Krass> by 'code', I simply meant a "pin".. the actual 8-length-code/pin..  Like the ones you'd find under a coca-cola cap for some contest.
06:59:37 <Krass> timthelion:  Cale?  I'll try to get in the touch with him thanks.
06:59:40 <timthelion> Krass: aha, totally misunderstood you
06:59:54 <Krass> timthelion:  perhaps I havn't been clear....
07:00:18 <Krass> oh.
07:00:24 <timthelion> Krass: I tought you meant like the ability to automatically generate a function that works according to a pattern based on an input<->output sample
07:00:32 <Cale> What? Why me?
07:00:43 <Krass> perhaps you're the brain round here?
07:00:45 <Krass> :)
07:01:04 <timthelion> Cale: you're always so sure of yourself, what's the hang up here?
07:01:11 <dfeuer> Cale is one of the brains around here. I think of him as a master explainer :-)
07:01:27 <Krass> I had doubts about what I'm looking for.. but we never know..  if all those apps get cracked and stuff, why not a lousy contest serials too...
07:01:56 <Cale> Krass: The way that apps get cracked is that people look at the code that tests whether the key is valid
07:02:01 <timthelion> Cale: so what is the feild of study I was thinking of?
07:02:04 <Cale> and work out a way to generate keys that pass
07:02:12 <Philonous> Krass, I think you didn't even state what it is you want to achieve? Do you want to have a method of creating more valid codes?
07:02:13 <Krass> also I thought that having over a hundred valid codes would help reverse-engineering that algorithm (lots of nice words - not quite sure if they make sense tho)
07:02:15 <dfeuer> Cale, did you have any ideas for improving my error message?
07:02:17 <Cale> Not by looking at lots of examples of keys
07:02:32 <Cale> dfeuer: I think it's fine
07:02:42 <dfeuer> Oh.
07:02:47 <dfeuer> Well, then.
07:02:48 <Krass> Philonous:  yes exactly.. I want some other new free codes :)
07:03:19 <dfeuer> Barton v. Gibbard: FACEOFF!
07:03:38 <Cale> ?
07:03:40 <dfeuer> The error message is inscrutable to newbies! No! The error message is fine!
07:04:10 <dfeuer> Fight to the death. Nay, to the pain!
07:04:12 <Krass> I guess I was hoping for a some apps/math-prowess that could brute-search the "link" between all those codes..
07:05:02 <Cale> Krass: You could try various things, but there's no straightforward approach which is guaranteed to work
07:05:14 <Philonous> Krass, If you don't have any more information about the process that generates the codes it's impossible. You're asking to reconstruct a turing machine by (some of) it's outputs
07:05:28 <Krass> Yes I'm color-dreaming uh?
07:05:41 <timthelion> Philonous: it may be impossible, but that's not the reason
07:06:07 <Krass> I wouldn't have been inquiring on this if I had like 10-20 codes..  But reaching 200, thought that could open some doors
07:06:42 <FireFly> I'd guess #crypto is more the channel for that kind of question
07:06:55 <timthelion> Krass: how are these codes used?  Do you enter them into a website?
07:07:26 <Krass> timthelion: Yes.
07:07:29 <timthelion> Krass: if so, then they might just be random numbers
07:07:54 <timthelion> Krass: which would mean that it is impossible for you to tell.  The website might just have a list of the numbers that it has generated so far, and check the list.
07:08:30 <Krass> timthelion:  Well, I would be tempted to think that it's not checking it up upon a database. It's too quick.  Prolly just following an algorithm and checking it up.  But I'm not sure.  Contests like that emits millions of valid codes, and I wouldn't think they keep any track of those
07:08:36 <Krass> just a way to validate them at time of entry
07:09:13 <timthelion> Krass: say they have 100 milion codes, each 8 digits long.  That's less than 1 gigabyte of data.
07:09:31 <timthelion> Krass: using a hashpool you can look it up in no time
07:09:44 <Krass> hashpool?
07:09:52 <timthelion> hashtable, whatever
07:10:07 <Krass> that's still not english to me ... :)
07:10:53 <Krass> [...] Before the Contest Start Date, approximately four million (4,000,000) unique codes will be
07:10:54 <Krass> placed, through a label featuring one (1) unique code
07:11:09 <Krass> I found 200 of those codes by brute-force, but it's too slow.
07:11:19 <timthelion> lol
07:11:34 <Krass> 200ms for each code.
07:11:40 <timthelion> Krass: you totally missed out on shellshock dude
07:11:46 <FireFly> That sounds reasonably fast
07:12:05 <timthelion> Krass: ehem, I mean, you really oughtn't be doing this kind of "hacking"
07:12:13 <Krass> FireFly:  well, there's many to try.  And it might go up to 500-800ms when running multiple instances.. which by average still seemed to be better
07:12:38 <Krass> timthelion:  not sure I got that..  why wouldn't I be?
07:12:43 * FireFly shrugs, if you want to improve it read up on crypto stuff or something :p
07:13:00 <Krass> crypto would be large
07:13:05 <timthelion> FireFly: as I already stated, crypto probably doesn't help at all here.
07:13:32 <Krass> I thought some wize guy will throw be in the right direction, or give up on it, as I'm not truly believing there's an easy way to win this
07:14:49 <timthelion> Krass: if it is taking you 200ms per code, and you have 200 codes, that means that you left it running 40 seconds, right?
07:15:36 <timthelion> Or is that 200ms per try?
07:15:53 <Krass> timthelion:  no, because it tried 800,000 codes overnight (approx)... to find 30-40
07:15:58 <Krass> yes, per try.
07:17:12 <timthelion> Perhaps you could write some javascript that makes the requests based on randomly generated code, and then put that javascript on a webpage along with some really silly "intreguing" content, and post it to 4chan
07:17:34 * timthelion needs to learn to spell
07:18:19 <timthelion> And Krass needs to stop trying to "hack" some stupid contest.
07:19:02 <timthelion> Krass: Ya need to be over 18 to gamble, but you sure-as-ell don't need to be over 18 to gota-prison!
07:19:45 <Krass> haha
07:19:46 <Krass> yes
07:20:28 <Krass> they'd then have to prove I didn't buy 200 juice bottles ;)
07:20:51 <timthelion> Krass: no, they'd simply have to link your IP address to the "DDOS" attack.
07:20:56 <lisbeth> anybody here familiar with conduit?
07:21:33 <Krass> timthelion:  I'll test my luck.  Contest organizers are, by experience, really stupid people.
07:21:36 <timthelion> lisbeth: just ask your question.
07:21:46 <lisbeth> I am trying to figure out what it does.
07:22:06 <timthelion> lisbeth: thesis: lazyIO is broken solution: conduit
07:22:21 <lisbeth> ok I'll google lazyIO and come back if I have more questions
07:23:26 <lisbeth> oh so piping plaintext strings into each other is an example of lazy IO
07:23:27 <timthelion> lisbeth: if you get in over your head just come back and tell us.  Water gets deep round here.
07:23:32 <Cale> lisbeth: lazy I/O is what things like hGetContents and readFile do: produce Strings (and values of other types) which as they're evaluated, carry out part of the I/O required to determine them
07:23:36 <lisbeth> because for example if you turn filenames into text you can ruin things
07:23:57 <lisbeth> Right. Some of the programs I am intending to design try to combat lazy IO
07:24:51 <timthelion> lisbeth: hm, piping plaintext strings into eachother?  I didn't follow you there.
07:25:12 <lisbeth> in piping in bash, everything is a string
07:25:23 <lisbeth> your input is a string and your output is a string
07:25:28 <timthelion> lisbeth: that is not lazyIO
07:25:33 <Twey> lisbeth: Pipes is probably simpler
07:25:52 <timthelion> lisbeth: or maybe it is, and I'm just misunderstanding you :P
07:26:14 <lisbeth> the reason bash doesn't work is for example if you take something as simple as ls -a
07:26:19 <lisbeth> you can't pipe that into other functions
07:26:29 <lisbeth> because ls -a can mess up filenames
07:26:34 <Twey> ls -a | foo
07:26:45 <jmcarthur> it depends what you need to do with the filename
07:26:46 <Twey> You can pass it in, no problem.  The other command might not parse the output right, though.
07:26:48 <lisbeth> you "can" but you shouldn't
07:26:56 <Twey> But that's not bash's problem.
07:26:59 <jmcarthur> you totally should if that's the format you want
07:27:13 <lisbeth> I am interested in making a haskell shell that solves that problem
07:27:20 <timthelion> lisbeth: By-the-way this has nothing to do with lazyIO
07:27:33 <lisbeth> ok that is what I am trying to understand
07:27:49 <timthelion> lisbeth: aha, you want to have a "typed shell" where the input and output of the commands have reasonable types rather than simply being strings.
07:28:19 <lisbeth> well in my shell there is "human readable" format and binary formats
07:28:20 <jmcarthur> lazy IO is just when you couple evaluation with IO, usually via unsafeInterleaveIO (or via some function that internally uses unsafeInterleaveIO)
07:28:39 <lisbeth> oh so lazy IO is a function?
07:28:40 <timthelion> lisbeth: yes
07:28:43 <jmcarthur> no
07:28:50 <timthelion> lisbeth: no, lazy IO is a type of evaluation
07:28:57 <lisbeth> I see. I
07:29:01 <lisbeth> I'll read up on it a bit more.
07:29:23 <jmcarthur> lazy IO is just *the idea of* coupling lazy evaluation and execution
07:30:00 <jmcarthur> unsafeInterleaveIO is the most common way of achieving lazy IO around these parts
07:30:15 <Twey> lisbeth: The problem you encounter there is that you're passing strings around, and the strings are intended both for consumption by humans and also by consumption by other processes — and the best format for a human to read is rarely the best format for a program to read.  You can get around it by not conflating those ideas, passing (for example) an object that supports accessing both human-readable and
07:30:16 <Twey> machine-formatted data
07:30:19 <jmcarthur> however, it's not usually recommended except for toy problems
07:30:23 <Krass> hey what about my code serial degenerator?  hah, kidding, I'll be giving up on this.  Thanks for your feedback people...
07:30:38 <timthelion> Twey: that's why we have the Show typeclass :D
07:30:44 <Twey> Microsoft's PowerShell does this, for example — its ‘commandlets’ produce .NET objects rather than strings
07:30:49 <friden> Krass: why not just use opencl or cuda if you are bruteforcing?
07:31:02 <friden> it sounds like you want to do alot of computation in paralell
07:31:06 <Krass> friden:  what is this or that?
07:31:06 <timthelion> friden: because he's network bound
07:31:11 <Twey> Which have various methods for sorting, getting subitems, getting human-readable output, &c.
07:31:29 <friden> timthelion: oh, thought he could do the work locally
07:31:30 <Krass> I am indeed network/web-server bound.
07:31:58 <Twey> Krass: Your problem is actually a classic AI problem
07:32:13 <Twey> ‘Given a sequence of strings, predict the next string’
07:32:31 <Krass> stupid I am - I *just* thought I should be testing my apps on my VPS.. which may, if I'm ever lucky, have a kickass response time (we never know)..  I guess it could depend of where it is, geographically
07:32:33 <timthelion> Twey: what if the strings are litterally random?
07:32:41 * hackagebot wobsurv 0.1.0 - A simple and highly performant HTTP file server  http://hackage.haskell.org/package/wobsurv-0.1.0 (NikitaVolkov)
07:33:08 <friden> Krass: do you have any decent heuristics or are you just bruteforcing?
07:33:11 <Twey> timthelion: It's allowed to fail (and produce sets of answers with varying probabalities given the information seen so far)
07:33:11 <Krass> timthelion:  I still wouldn't think it's just random, tho
07:33:39 <Twey> timthelion: There's a pattern in pretty much all data, but it might not be the right one
07:33:51 <Twey> probabilities**
07:33:56 <Krass> friden:  only bruteforcing.. I discovered which digts were completely left OUT of the serials, but that's about it.  Also, never will you have an ALPHA-only or NUM-only serials.  Always 4 or 5 num digits
07:34:30 <Krass> in a 8-lengt alpha-num code.
07:34:34 <Krass> code = serial.
07:34:46 <timthelion> Twey: but for streams generated by SHA512 and a secret salt no one knows how to find a pattern.
07:34:47 <Philonous> Krass, you could try to find linearities in the ones you found so far
07:34:52 <Philonous> Or try higher order models
07:35:52 <Krass> Philonous:  I tried to inspect those I already have.  couldn't find anything....  except from what I just said (excluded digits, and always 4-5 nums)..
07:36:23 <blablaa> http://nopaste.info/4c6e2d7442.html <- problem with cabal and anydbm
07:36:25 <blablaa> any idea?
07:36:48 <Philonous> Krass, I mean, generate some counter-examples (should be easy), and dump them into a SVM
07:37:13 <Krass> SVM?  is that the new one from Honda?
07:37:15 <Twey> timthelion: There's always an applicable pattern.  If you have the numbers [5, 16, 7] then as far as you know the stream might be generated by: cycle [5, 16, 7]
07:37:33 <Philonous> Krass, SUpport vector machine
07:37:37 <Philonous> It's a long shot, though
07:37:46 <Krass> uhmm
07:37:51 <Twey> timthelion: Of course if it's truly random then that's the *wrong* pattern, and the more numbers you generate the slimmer the chances of the pattern holding become — you can only know for certain whether or not you have the right pattern in the limit
07:39:09 <timthelion> Twey: but we are almost certain that the codes are as random as you can get, and that we'd be wasting our time to do any analysis.
07:39:33 <Twey> timthelion: It's not a solved problem, anyway…
07:39:55 <Twey> Just thought Krass might be interested that they'd stumbled onto it.
07:40:40 <timthelion> Twey: well, if they broke SHA, they'd win more than some silly fruit drink label code contest.
07:41:33 <Krass> :)
07:41:34 <Twey> timthelion: If they managed to build a strong AI, they'd win more still ;)
07:42:41 * hackagebot cblrepo 0.13 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.13 (MagnusTherning)
07:43:30 <timthelion> hm, all the bitcoins in the world, plus an algorithm that Putin would pay 3/4ths of Russia to have vs some smart ass computer that'll instantly depricate us intelectuals... take your pick
07:44:07 <timthelion> ooh, cblrepo looks neet
07:47:42 * hackagebot orgmode-parse 0.0.0.1 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.0.1 (ParnellSpringmeyer)
07:48:19 <Fuuzetsu> if you squint, CABAL looks like COBOL
07:48:23 <Fuuzetsu> we've been tricked all this time
07:52:42 * hackagebot orgmode-parse 0.0.0.2 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.0.2 (ParnellSpringmeyer)
07:53:20 <Clint> ooh
07:57:42 * hackagebot orgmode-parse 0.0.0.3 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.0.3 (ParnellSpringmeyer)
08:00:02 <indiagreen> > True
08:00:04 <lambdabot>  True
08:00:44 <Krass> COBOL.  Reminds me of bad souvenirs.
08:00:55 <Krass> Turbo Pascal was SO MUCH cooler! :)
08:02:43 * hackagebot hydrogen-prelude 0.6 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.6 (JulianFleischer)
08:05:13 <Fuuzetsu> ooh, orgmode-parse
08:06:39 <Fuuzetsu> oh hm, probably can't use it
08:06:52 <J_Arcane> So according to two different books, this should work: http://lpaste.net/112474  But on Windows/GHC 7.8.3, I get the getLine prompt first, and then it does both putStr calls in a row after.
08:07:38 <Fuuzetsu> J_Arcane: use putStrLn which will flush the buffer
08:08:02 <Fuuzetsu> or use hFlush stdout
08:08:09 <Fuuzetsu> (import System.IO)
08:08:10 <J_Arcane> Fuuzetsu: I tried it that way too, and got the same out-of-order behavior.
08:08:40 <Fuuzetsu> see http://www.haskell.org/pipermail/beginners/2010-March/003692.html for pretty much the same question
08:09:56 <J_Arcane> Ahh, OK. Thanks.
08:11:10 <J_Arcane> Doing an hFlush did indeed fix it to work as expected.
08:12:44 * hackagebot hydrogen-prelude 0.6.0.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.6.0.1 (JulianFleischer)
08:31:03 <_robbins> I created a subreddit for the few of use learning Haskell CIS194 - feel free to post/comment: https://www.reddit.com/r/CIS194/
08:31:20 <_robbins> *via CIS194
08:32:29 <codo> Hey folks!
08:32:39 <codo> Which is the best introductory book for getting into Haskell ?
08:32:49 <mmmm_> Have you tried anything?
08:33:19 <codo> Yes a little bit
08:33:54 <k00mi> codo: learn you a haskell is pretty good
08:33:58 <k00mi> @where LYAH
08:33:58 <lambdabot> http://www.learnyouahaskell.com/
08:34:25 <codo> But, want to go through the syntax again. Was thinking Real World Haskell is good
08:34:51 <_robbins> codo: I'd recommend CIS194 -> http://www.seas.upenn.edu/~cis194/spring13/
08:34:57 <kuribas> codo: It is good.  The examples can be a bit outdated, but that's not a big problem.
08:35:02 <codo> ah
08:35:15 <codo> well then I think I will do this LYAH and the CIS194
08:35:42 <_robbins> codo: There's a #haskell-beginners, too.
08:35:47 <codo> oh
08:35:52 <codo> I didn't know that! Thanks.
08:35:57 <_robbins> Although, you're welcome to post here, too.
08:36:15 <narendraj9> I would recommend http://www.cs.nott.ac.uk/~gmh/book.html. You can do all the exercises.
08:36:24 <narendraj9> And there is a course starting on edX
08:36:42 <narendraj9> It's going to be taught by Erik Meijer.
08:36:54 <codo> narendraj9: yeah, I have signed up for that.
08:37:13 <narendraj9> So did I. See you in the forums! :-)
08:37:41 <codo> alright, time to brush up the basics now
08:37:42 <codo> laters
08:38:18 <smart_ptr> hi
08:38:19 <narendraj9> I have been doing Graham Hutton's book. Currently on chapter 8.
08:38:23 <smart_ptr> can you tell me what happens here?
08:38:23 <smart_ptr> http://ideone.com/45vkc2
08:38:29 <narendraj9> You can do the whole book!
08:38:39 <smart_ptr> (very counter-intuitive sample with the simple `repeat` function)
08:38:57 <codo> narendraj9: ok
08:39:19 <mauke> > 100000^100000 :: Int
08:39:21 <lambdabot>  0
08:39:29 <smart_ptr> >  repeat 3 !! 10000000000000
08:39:32 <mauke> integer overflow
08:39:35 <lambdabot>  mueval: ExitFailure 1
08:39:49 <smart_ptr>  repeat 3 !! 10000000000000 :: Integer
08:39:53 <mauke> > 10000000000000 :: Int
08:39:56 <lambdabot>  10000000000000
08:40:05 <smart_ptr> >  repeat 3 !! 10000000000000 :: Integer
08:40:10 <lambdabot>  mueval: ExitFailure 1
08:40:23 <mauke> 3 is already an Integer
08:41:25 <smart_ptr> why do you cast 100000^100000 to Int?
08:41:33 <smart_ptr> is this what the !! operator is doing?
08:41:45 <lilred> Hey guys, is there a forward pipe operator in Haskell?
08:41:54 <smart_ptr> if so, why doesn't it cast 100000000000 to int? :/
08:42:27 <smart_ptr> lilred: what does the forward operator?
08:42:43 <mauke> there are no casts
08:42:53 <mauke> :t (!!)
08:42:53 <MagneticDuck>  > repeat 3 !! (flip id (undefined "large integer") (10^1000 :: Integer))
08:42:54 <lambdabot> [a] -> Int -> a
08:42:59 <MagneticDuck> > repeat 3 !! (flip id (undefined "large integer") (10^1000 :: Integer))
08:43:01 <lambdabot>  Couldn't match expected type ‘b0 -> GHC.Types.Int’
08:43:01 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
08:43:02 <mauke> !! takes an Int
08:43:06 <MagneticDuck> yes
08:43:14 <lilred> smartptr: (x |> f) = f x
08:43:18 <carter> those wont termiante
08:43:21 <mauke> 100000^100000 and 10000000000000 are both Ints
08:43:25 <carter> well
08:43:27 <lilred> smartptr: has to be right associative
08:43:29 <mauke> the difference is that one of them is 0
08:43:38 <carter> i guess you could define  an !! that uses integer
08:43:47 <mauke> :t genericIndex
08:43:49 <lambdabot> Integral i => [a] -> i -> a
08:43:49 <k00mi> lilred: not in base
08:44:00 <mauke> lilred: there's & in lens
08:44:01 <smart_ptr> mauke: one is exactly 0 because of overflow? I doubt so
08:44:13 <mauke> smart_ptr: didn't you see what lambdabot said?
08:44:14 <smart_ptr> I also doubt that is the reason, because for _every_ int it shall be 3
08:44:19 <mauke> what
08:44:39 <smart_ptr> why does it compute forever on 100000..
08:44:57 <balajisivaraman> exit
08:45:42 <narendraj9> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-List.html#%21%21
08:45:59 <narendraj9> Replacing Int with Integer should do the job.
08:48:51 <lilred> is there an infix operator like <$> but with reversed arguments?
08:49:33 <lilred> I just realized that I'm shoe-horning ML patterns into Haskell because I can't read idiomatic Haskell
08:49:39 <smart_ptr> ok
08:49:58 <lilred> do you guys read Haskell source code right to left or left to right?
08:50:02 <k00mi> lilred: not in base, but lens has (<&>)
08:50:39 <lilred> k00mi: thanks!
08:50:55 <k00mi> lilred: I usually start on the left when reading chains of function applications
08:51:41 <k00mi> lilred: lens is a huge library though, you probably want to just define that operator yourself if you don't already depend on lens
08:51:54 <lilred> k00mi: so how do I structure a chain of functions applications left-to-right? because the basic operators $, ., <$>, etc. have the reverse order I'd expect to be able to read left-to-right
08:51:54 <k00mi> lilred: err, I start on the right...
08:52:30 <lilred> alright thanks. I guess I'll do that too.
08:52:42 <k00mi> it's not a big deal once you get used to it
08:52:47 <lilred> I love the theory of Haskell but so far the practice has proven surprisingly frustrating
08:53:28 <kuribas> lilred: That should pass after a while.
08:53:29 <lilred> Is lens not in Hoogle? I looked up & and <&> but haven't found anything
08:53:44 <kuribas> lilred: Except for the usual frustration when programming :)
08:53:52 <k00mi> it is, but hoogle only searches a fixed number of packages
08:54:01 <k00mi> use +lens in your search query to also search the lens package
08:54:08 <Fuuzetsu> http://www.haskell.org/hoogle/?hoogle=%26+%2Blens
08:54:17 <lilred> Thanks guys!!
08:54:22 <kuribas> lilred: I actually find haskell programming less frustrating, because the static types catch many errors early.
08:54:59 <lilred> kuribas: my main workhorse language is F#, the type system is weaker but not -that- much
08:56:14 <lilred> kuribas: the main reason I'm attracted to Haskell is higher-kinded types and laziness, it feels like I already have everything else in ML languages
08:56:14 <kuribas> lilred: I also find haskell code easier to understand than other code.
08:56:34 <lilred> kuribas: is that a matter of habit though?
08:56:45 <lilred> kuribas: specifically, have you looked at ML code bases?
08:57:04 <kuribas> lilred: maybe... But I can code C easily, but I always have problems trying to understand a piece of C code.
08:57:11 <k00mi> that largely depends on the specific code in question
08:57:14 <kuribas> true
08:57:56 <kuribas> lilred: How is haskell so different from F#?
08:58:26 <adarc> hi, just stumbled upon this little blog post attacking haskell's speed at processing lines in a file etc.. http://honza.ca/2012/10/haskell-strings ... wondering if anyone knows off hand whether something like conduit/pipes would provide that raw speed that he was unable to achieve?
08:58:41 <k00mi> kuribas: they already mentioned higher-kinded types and laziness
08:59:17 <kuribas> k00mi: I don't see how laziness would be so hard to write...
08:59:33 <adarc> i plan on trying myself, and running it through a benchmark library for fun.. just curious if anyone has a strong opinion on that
08:59:50 <lilred> kuribas: I find F#'s monad syntax more intuitive, and the idiomatic style is read and written left-to-right. Otherwise it's just a strict, underpowered Haskell with OOP features
09:01:15 <k00mi> adarc: r/haskell on that post: https://www.reddit.com/r/haskell/comments/120h6i/why_is_this_simple_text_processing_program_so/
09:01:26 <k00mi> also includes a conduit version
09:01:28 <Fuuzetsu> I notice he doesn't even use omgoptimised titleCase function
09:02:17 <adarc> thanks k00mi , will check
09:05:03 <lilred> For forward composition, should I use Control.Arrow's (>>>) or something else?
09:05:52 <k00mi> most use (.) and write right-to-left
09:11:25 <jTT> Hey, anyone know why cabal is telling me that Data.Conduit.Combinators is not exporting foldlCE when it should?
09:12:30 <kuribas> lilred: right to left isn't fundamentally different.
09:12:31 <FireFly> lilred: either that or Control.Category's, I think
09:13:00 <kuribas> lilred: I don't see how that could be frustrating, unless you meant something else?
09:14:46 <jTT>     Can anybody tell me how to make cabal see a “hidden module” ? …i.e. how to fix: Could not find module ‘Data.Conduit.Combinators.Unqualified’
09:14:46 <jTT>     it is a hidden module in the package ‘conduit-combinators-0.2.8.3’
09:15:06 <kuznero> Hi All!
09:15:20 <jTT> hello
09:15:22 <YurasS> jTT: add in to build-depends in cabal file
09:15:55 <jTT> i added conduit-combinators, but i dont know what the name of the “hidden module” within is
09:16:13 <lpaste> kuznero pasted “runWriter within Writer monad” at http://lpaste.net/112478
09:16:57 <YurasS> jTT: ah, the module is internal
09:16:57 <kuznero> I have probably stupid question about runWriter within a Writer monad, can somebody help me with that?
09:17:13 <YurasS> jTT: why do you want to use it?
09:17:21 <lilred> can someone help me rewrite this in a way that doesn't cause a parse errror? http://lpaste.net/1973126091954454528
09:17:27 <jTT> YurasS: so, i can’t use that funciton then?
09:18:24 <YurasS> jTT: hmm that is strange
09:18:26 <jTT> YurasS: I guess I found a non-hidden, equivalent function..
09:18:37 <YurasS> it is listed as exposed-modules here: http://hackage.haskell.org/package/conduit-combinators-0.2.8.3/conduit-combinators.cabal
09:18:47 <jTT> YurasS: yeah, that’s what I thiught!
09:19:12 <jTT> YurasS: gonna check versions
09:19:45 <FireFly> lilred: I think you want to indent the "undefined"
09:20:16 <k00mi> jTT: YurasS: no, it's listed under other-modules
09:20:40 <lilred> FireFly: so after "in" there's an indent? Good to know, thanks.
09:20:45 <YurasS> k00mi: ah, yes. you are right
09:20:46 <RchrdB> kuznero: probably! Please don't ask "can anyone help" unless you're not sure whether your question would be on-topic or not. Please just come right out with your question for the best chance of someone coming along with an answer to it. :)
09:20:54 <YurasS> so it is internal -- don't use it
09:21:44 <k00mi> lilred: the expression following the 'in' must be indented at least as far as the 'in'
09:21:45 <RchrdB> kuznero: please ask, if possible use lpaste (URL in the topic) to paste the code that you're having trouble with and any error messages. :)
09:21:53 <kuznero> :) RchrdB: thanks. My question is that I'm not sure if it is correct to do runWriter within a Writer monad - will I get all the logs in place?
09:22:35 <kuznero> http://lpaste.net/112478
09:22:46 <RchrdB> If you use runWriter within a Writer expression, the inner Writer won't affect the outer one except through the return value.
09:23:25 <RchrdB> (except through the value returned by (runWriter expr))
09:23:28 <kuznero> :( I see, then what is the best way for running several underlying Writer operations such that log will be saved in the outer one?
09:23:37 <RchrdB> Uh, just run them?
09:24:02 <RchrdB> kuznero: "sequence" or "sequence_" or "mapM" or "mapM_"
09:24:33 <kuznero> mapM, yes... why didn't I thing about it myself :)
09:24:34 <kuznero> Thanks!
09:25:51 <RchrdB> or (>>) or (>>=) or putting them onto lines in a "do" block or on the right hand side of a "<-" in a "do" block. :)
09:26:09 <nshepperd> traverse!
09:26:38 <kuznero> I tried <-. But then it's manual labor - I want to run all check ops in my list and get the result in the outer Writer
09:28:09 <RchrdB> kuznero: yeah, you want mapM or forM if you want to have that phrased nicely. :)
09:28:40 <kuznero> RchrdB: Sounds like that! Thanks!
09:29:44 <RchrdB> kuznero: I think that your lpaste as written does what you want it to with the last time changed to ``all id <$> mapM ($ opts) checks``, but don't quote me on that
09:30:02 <kuznero> :)
09:30:16 <RchrdB> kuznero: oh and there's a function called ``any`` in the Prelude which identical to ``all id``
09:30:28 <RchrdB> @quickcheck (\l -> all id l == any l)
09:30:28 <lambdabot> Unknown command, try @list
09:30:31 <kuznero> good point, thanks!
09:31:14 <RchrdB> @check (\l -> all id l == any l)
09:31:16 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
09:31:16 <lambdabot>  with actual type ‘[a0] -> GHC.Types.Bool’Couldn't match expected type ‘a0 ->...
09:31:45 <RchrdB> kuznero: oh I think I have that backwards >_>
09:32:00 <kuznero> I'm trying this now: rs <- sequence (map (\ x -> x opts) checks)
09:32:15 <kuznero> That gives me [Bool], then I can use any on that
09:32:17 <RchrdB> @check (\l -> and l == all id l)
09:32:19 <lambdabot>  +++ OK, passed 100 tests.
09:32:27 <RchrdB> @check (\l -> or l == any id l)
09:32:28 <lambdabot>  +++ OK, passed 100 tests.
09:33:06 <RchrdB> kuznero: (sequence . map f) == (mapM f)
09:33:34 <kuznero> RchrdB: nice - tons of things to keep in mind... I will always be newbie in Haskell :))))
09:33:34 <nshepperd> the AMP wiki page mentions "nontrivial breaking interaction with Roles" due to putting join in the Monad typeclass... does anyone know or have a reference for what actually breaks here?
09:33:49 <RchrdB> kuznero: eh, it's only a tiny stylistic thing.
09:34:14 <kuznero> RchrdB: I need `all id` - not `any` as I need to make sure all are True
09:35:00 <RchrdB> kuznero: yeah, it's "all id" versus "and".
09:35:21 <RchrdB> kuznero: I got it the wrong way around the first time. :)
09:35:33 <nshepperd> is it similar to the breakage involving 'traverse'?
09:36:30 <benzrf> breakage invol ving traverse ?
09:36:51 <benzrf> @check True
09:36:53 <lambdabot>  +++ OK, passed 1 tests.
09:38:03 <kuznero> :t (<$>)
09:38:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:38:21 <kuznero> :i Functor
09:38:27 <RedNifre> :t (<*>)
09:38:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:38:40 <nshepperd> benzrf: apparently the news roles/GeneralizedNewtypeDeriving stuff doesn't work for Traversable because of type variables
09:39:31 <nshepperd> and the same roles stuff stops us from putting 'join' in the Monad type class
09:40:40 <RedNifre> :set -XNamedRecordPuns ; data IfOnly { thisWasPossible :: String }
09:48:22 <blablaa> someone knows what happened to Data.HashTable ?
09:48:27 <blablaa> maybe it was there in some old version of GHC?
09:51:31 <RchrdB> blablaa: it was deprecated in 7.6 and removed in 7.8
09:51:49 <blablaa> RchrdB, thank you very much
09:52:01 <blablaa> RchrdB, i'm trying to compile missingpy but it depends on anydbm that depends on that
09:52:12 <zwer> why was it deprecated/removed?
09:52:13 <blablaa> RchrdB, any other idea how to call python? perhaps via C? but that's so boring...
09:52:35 <RchrdB> blablaa: I would be really really surprised if Data.HashTable wasn't just moved to a package on hackage, though
09:52:40 <Dodek> hey, does anyone has any experience with using apache thrift with haskell? or, what's the haskell RPC mechanism of choice?
09:53:04 <RchrdB> blablaa: https://hackage.haskell.org/packages/hashtables-1.1.2.1 looks like it. :)
09:57:24 <simon> @pl return f <*>
09:57:24 <lambdabot> (line 1, column 13):
09:57:24 <lambdabot> unexpected end of input
09:57:24 <lambdabot> expecting white space or simple term
09:57:31 <simon> @pl return f <*> x
09:57:31 <lambdabot> return f <*> x
10:03:59 <simon> @pl liftM (flip foo) bar
10:03:59 <lambdabot> fmap (flip foo) bar
10:04:06 <simon> @pl liftM2 (flip foo) bar
10:04:06 <lambdabot> liftM2 (flip foo) bar
10:06:18 <simon> @pl pure (flip f) `ap` x
10:06:18 <lambdabot> pure (flip f) `ap` x
10:10:23 <LtRipley> hi
10:10:51 <kuznero> Hello
10:11:38 <marchelzo_> I was trying to install hscurses through cabal on windows, and I used the --extra-lib-dirs and --extra-include-dirs flags to include and link to pdcurses, but it still fails to install and says that I'm missing the C library 'curses'. Am I doing something wrong?
10:13:44 <adarc> hey, anyone know why source/etc is being stored in ~/.cabal/packages/cabal-src.. i'm using cabal sandboxes and cabal-meta to install packages from git etc. Is it possible to 'contain' EVERYTHING to .cabal-sandbox ?
10:14:33 <adarc> i think this behavior is causing me problems with a library that i made updates to.. when i build, it's not seeing the update I made via the repo on github.
10:15:01 <blablaa> RchrdB, thank you
10:15:07 <simon> @pl foldr (<|>)
10:15:08 <lambdabot> foldr (<|>)
10:15:25 <blablaa> RchrdB, i've done cabal get, now fixed .cabal file, now i'm looking at compile errors...
10:16:25 <blablaa> RchrdB, frankly anyway it's a mess, if missingpy is not maintained, i'll have to find another solution
10:19:58 <lilred> Anyone here has experience with optparse-applicative? I'm wondering how I can encode two flags that are mutually exclusive
10:20:19 <RchrdB> blablaa: well, the Hackage package hasn't been touched since 2012, so it looks likely.
10:30:22 <timthelion> Is there a text based protocol of similar simplicity to HTTP with both push and pull that has Haskell bindings?
10:30:55 <Eduard_Munteanu> HTTP counts as simple? :)
10:31:24 <Eduard_Munteanu> timthelion, perhaps IMAP?
10:31:37 <kuznero> silk published theirs RESTful API with no hard dependency to HTTP
10:31:38 <Eduard_Munteanu> Certain flavors of.
10:31:50 <timthelion> Eduard_Munteanu: that seems really radical, to use IMAP for something other than mail
10:32:10 <Eduard_Munteanu> timthelion, what's the usecase?
10:32:12 <frihd> timthelion:  stomp
10:32:15 <Turl> blablaa: maybe you can use maybe for that
10:32:28 <blablaa> Turl, what?
10:32:40 <Turl> ignore what I just said, my irssi was scrolled like 2 weeks ago
10:32:47 <timthelion> I want to throw JSON objects back and forth between a client(display) and server.  Locally.  I'm writting a text editor.  The only reason for the separation is so that I can have a well defined interface that can be tested using standard methods.
10:33:13 <kuznero> silk can be used in this scenario I guess...
10:33:16 <timthelion> s/the only/the main/
10:34:04 <kuznero> timthelion: this is about silk API https://skillsmatter.com/skillscasts/5403-rest-building-apis-easily
10:34:06 <int-e> Eduard_Munteanu: we could go back to HTTP 0.9, which was simple, but didn't have any methods besides GET :)
10:34:38 <Eduard_Munteanu> I was just discussing how awful HTTP is in -blah, a few hours ago.
10:34:49 <timthelion> kuznero: are there silk bindings for haskell?
10:35:06 <kuznero> silk is a Haskell lib AFAIK
10:35:38 <timthelion> Eduard_Munteanu: the most awful thing for me about HTTP is that Docker uses HTTP with streaming for its client daemon interface.  And streaming is, apparently, a non-standard feature.
10:35:58 <Eduard_Munteanu> timthelion, how about JSON RPC?
10:36:15 <timthelion> kuznero: this? http://hackage.haskell.org/package/rest-types
10:36:39 <Eduard_Munteanu> timthelion, over a unix domain socket, for instance
10:36:47 <timthelion> Eduard_Munteanu: I honestly don't know.  The only non-binary protocol I have experience with is HTTP
10:37:10 <Eduard_Munteanu> timthelion, why do you care that much about non-binary?
10:37:23 <timthelion> Eduard_Munteanu: it makes for more readable goldenfiles
10:37:50 <frihd> timthelion:  why do you want text-based?
10:37:51 <Eduard_Munteanu> Goldenfiles?
10:37:54 * hackagebot fay 0.21.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.0.1 (AdamBergmark)
10:37:56 <timthelion> Eduard_Munteanu: I don't like test suits that are complex enough that they are, themselves, hard to verify
10:38:07 <frihd> can't you use zero-mq and send json blobs?
10:38:14 <jTT> hey, i have a utf8 encoded website. when I use foldlE from conduit-cominators, I hoped to be able to count the occurrance of some characters using their utf8 integer representation. For example, with my conduit I stream a certain html file, then foldle over that file. the function that i fold with does something like foldle (\x n -> if fromEnum x == 120 then n+1 else n) 0. This should count the ‘x’ in my documents. However, for non ASCII (
10:38:15 <jTT> larger integers), I find the foldle returns zero, so as if there were no such characters in the document. but i know they are there. Anyone have a guess what I happening?
10:38:29 <timthelion> frihd: Eduard_Munteanu: goldenfiles are text files that represent the expected output of a program
10:38:39 <Eduard_Munteanu> timthelion, well, if you trust the RPC implementation, then you can simply talk about the objects you serialize, not how.
10:39:09 <timthelion> OK, maybe I'll give binary protocols a chance
10:39:20 <frihd> timthelion:  beside using tcpdump for debugging more easily, I don't see why you would want to limit yourself upfront
10:39:35 <Eduard_Munteanu> timthelion, http://www.jsonrpc.org/specification  has some examples
10:39:41 <frihd> any decent protocol will support TLS anyway =)
10:40:17 <Eduard_Munteanu> As I mentioned, you can avoid any transport-level protocol if you go with unix-domain sockets.
10:41:14 <timthelion> Eduard_Munteanu: I'm definitely going with unix-sockets.  They have the advantage that they discourage this shit where people try to replace ssh with their own less secure home grown remote access method ;)
10:41:21 <frihd> I second Eduard_Munteanu . you can even use or std{in,out} + anything like netcat/socat/zmcat et al.
10:43:34 <timthelion> jsonrpc looks nice, doesn't seem to have any concept of threading (like this message is a responce to that method) but I guess I can implement that myself.
10:44:19 <Philonous> timthelion, DBus, maybe?
10:45:05 <Eduard_Munteanu> timthelion, have you seen the 'id' parameter?
10:45:48 <timthelion> Philonous: deffinitely not.  DBus is a bad protocol.  It puts everything into one socket, thus making it harder for unix folks to customize the system as the see fit.
10:46:04 <timthelion> Eduard_Munteanu: I did see the id parameter, but I didn't understand how it was unique
10:46:37 <Eduard_Munteanu> timthelion, unique? The caller is responsible for setting the 'id', the response simply reuses it.
10:47:00 <timthelion> Philonous: for example, what if a unix person wanted to use a MAC(Mandatory Access Controll) system to controll who could become a client of the daemon.
10:47:19 <timthelion> Philonous: of course that is possible with DBus, but it requires that the administrator learn something new.
10:47:34 <timthelion> Philonous: or if they wanted to tunnel from client to daemon through ssh.
10:48:05 <timthelion> Philonous: or if they wanted to have the daemon and client running in two different linux containers.
10:48:09 <kuribas> Is there a way to convert from a Rational or Floating number to Double?
10:48:21 <kuribas> And back?
10:48:39 <timthelion> kuznero: yes, there are ways to lose information by doing that.
10:48:53 <Eduard_Munteanu> :t fromRational
10:48:54 <lambdabot> Fractional a => Rational -> a
10:49:12 <Eduard_Munteanu> > fromRational (1 % 3) :: Double
10:49:13 <lambdabot>  0.3333333333333333
10:49:38 <Philonous> > realToFrac (3 :: Float) :: Double
10:49:40 <lambdabot>  3.0
10:49:43 <Haskellfant> is there some effort to generalize length, (!!) and similar functions to Integral a instead of Int?
10:49:47 <Philonous> > realToFrac (3 :: Double) :: Float
10:49:49 <lambdabot>  3.0
10:50:00 <timthelion> Philonous: another example of why dbus is a poor protocol, is that I specifically want this interface so that I can debug with it, but hooking up to DBus would be complicated.
10:50:00 <Eduard_Munteanu> Haskellfant, genericLength
10:50:04 <Eduard_Munteanu> :t genericLength
10:50:05 <lambdabot> Num i => [a] -> i
10:50:19 <Haskellfant> Eduard_Munteanu: ah nice
10:50:35 <Philonous> timthelion, Fair enough.
10:52:12 <kuribas> Eduard_Munteanu: ok, thanks.
10:55:12 <Eduard_Munteanu> Is there a library for binding arbitrary parsers to objects automatically, a-la Aeson's Generic instances?
10:55:22 <kuribas> timthelion: loose information, and gain performance.
10:55:41 <timthelion> Hm, having looked through JSONRPC it seems that clients send requests and servers send responces, it isn't clear whether the protocol actually supports push and pull
10:56:14 <Eduard_Munteanu> timthelion, have you seen notifications?
10:56:31 <timthelion> Eduard_Munteanu: are those available in both directions?
10:57:20 <awestroke> :t fromIntegral
10:57:22 <lambdabot> (Num b, Integral a) => a -> b
10:57:57 <Eduard_Munteanu> timthelion, not sure what you need, normal requests go from client to server and receive a response. Responses which aren't related to a request are called notifications.
10:59:13 <Eduard_Munteanu> timthelion, so I guess normal requests could be thought of as notifications in reverse
10:59:24 <timthelion> Eduard_Munteanu: well, I want the two main things that HTTP doesn't have: the ability for the server to stream data which it doesn't know the length of when it starts streaming, and for the server to tell the client that there is new information for the client, without having the client poll constantly.
11:00:22 * timthelion wonders if there will ever be a new version of http that fixes this.
11:00:52 <Eduard_Munteanu> timthelion, HTTP can handle streams, by the way
11:01:27 <timthelion> Eduard_Munteanu: Well, I know tht Docker uses them, but as far as I can tell, the standard python implementation doesn't support them :P
11:01:50 <Eduard_Munteanu> The end of a response body is signalled by shutting the connection down in those cases.
11:02:58 * hackagebot hydrogen-util 0.6 - Hydrogen Tools  http://hackage.haskell.org/package/hydrogen-util-0.6 (JulianFleischer)
11:03:03 <Eduard_Munteanu> timthelion, anyway, I think you want to let the client request chunks of data from the server, each in one request.
11:03:56 <Eduard_Munteanu> Much like when reading from a pipe, when you issue a read() with a maximum length.
11:04:40 <timthelion> Eduard_Munteanu: I guess in my case, it doesn't even really matter.  I don't need streaming.  But it's nice to know that your protocol isn't limited for future extentions.
11:05:29 * timthelion wonders why HTTP is so popular for non-www IPC.
11:05:59 <Eduard_Munteanu> (as far as HTTP is concerned, the close signaling is actually pretty much the default mode of operation)
11:06:19 <timthelion> what is "close signaling"?
11:06:49 <Eduard_Munteanu> I mean the client determines the end of stream when the server shuts down the connection.
11:07:18 <Eduard_Munteanu> Not great if you require persistent connections though.
11:07:43 <RchrdB> Eduard_Munteanu: that's accurate for old HTTP. Transfer-Encoding: chunked does a better job with explicit EOF markers.
11:08:12 <Eduard_Munteanu> Yeah, I know.
11:08:46 <Eduard_Munteanu> Just making it clear HTTP supports and has supported that sort of streaming for a long time.
11:09:55 <timthelion> hm, jsonrpc is out, haskell libs for it are too complex.
11:11:04 <timthelion> These "Text" folks have really ruined everything :(
11:11:09 <jmcarthur> ?
11:11:15 <Eduard_Munteanu> timthelion, what do you mean too complex?
11:12:09 <timthelion> jmcarthur: Well, I want to use Strings, and I don't want to have all the clutter of the pack-unpack stuff
11:12:20 <jmcarthur> then use OverloadedStrings
11:12:33 <jmcarthur> if you mean you want to use string literals
11:12:43 <Eduard_Munteanu> Ew, String.
11:12:49 <jmcarthur> if you mean you want to use linked lists, you should just think carefully about why you really want that
11:12:53 <timthelion> Eduard_Munteanu: The example program here: http://hackage.haskell.org/package/json-rpc-server-0.1.1.0/docs/Network-JsonRpc-Server.html
11:13:04 <timthelion> Eduard_Munteanu: makes it clear that I don't want to use the package
11:13:50 <timthelion> jmcarthur: I don't really want to use linked lists.  I would much rather someone changed the compiler and runtime to use ropes internally for all datatypes that currently compile to linked lists
11:14:13 <jmcarthur> timthelion: then use ropes of Text with OverloadedStrings
11:14:16 <Eduard_Munteanu> timthelion, well, they do HTTP and use MVar for mutable data, you don't need that
11:14:26 <jmcarthur> timthelion: you don't need any more special compiler support here
11:14:28 <d3lxa> I got a ghc panic, the impossible happened with yesod, any idea? tried to store file in DB, etc: http://lpaste.net/112482
11:14:30 <timthelion> jmcarthur: they said it was a high level language.  Now everyone is trying to "optimize it" in the wrong place
11:14:36 <jmcarthur> huh?
11:15:01 <jmcarthur> timthelion: Text is about properly supporting unicode and being fairly fast. also, it doesn't seem like you have addressed my suggestion
11:15:08 <Eduard_Munteanu> Text is pretty simple to use, the only problem is a lot of stuff already uses String
11:15:11 <timthelion> jmcarthur: I don't need special compiler support, but I certainly would like my compiler to do the obvious optimizations.
11:15:30 <jmcarthur> timthelion: just use the correct data structure. it's no more difficult to use
11:15:55 <timthelion> jmcarthur: they rewrote most of prelude in order to get Text usable, that's just ugliness.
11:16:09 <jmcarthur> timthelion: actually, they diverged from the prelude where it makes sense for text
11:16:25 <jmcarthur> timthelion: i think your actual complaint should be about haskell's module system
11:16:45 <Eduard_Munteanu> You can't have both arrays of byte and treat them as linked lists at the same time.
11:17:03 <timthelion> jmcarthur: no, my complaint is general.  Lots of people have been trying to optimize haskell code lately, when they really should be optimizing the compiler
11:17:18 <Eduard_Munteanu> Or about Prelude's classlessness.
11:17:24 <simpson> Wait, what in particular is wrong with the compiler?
11:17:35 <Eduard_Munteanu> (have you seen classy-prelude or at least basic-prelude?)
11:17:38 <jmcarthur> timthelion: are you saying that using the correct data structure is something the compiler should do for you? i think that's far beyond the abilities of today's compilers
11:17:54 <timthelion> simpson: that it compiles [a] to a linked list
11:18:06 * kuribas would like to have supercompilation available in a haskell compiler.
11:18:12 <jmcarthur> timthelion: it's a linked list because it's *specified* to be a linked list
11:18:13 <timthelion> jmcarthur: I think that using the correct low level data structure IS the compilers job
11:18:23 <Eduard_Munteanu> timthelion, it could compile to an array, but then it would be even worse
11:18:26 <jmcarthur> timthelion: this is not a low level detail. this is about the structure of your code
11:18:37 <simpson> timthelion: That's not the compiler, though; [] only has syntatic help from the parser, not any semantic power behind it.
11:18:46 <Eduard_Munteanu> If you used an array as a linked list, I mean.
11:19:07 <simpson> timthelion: Haskell specifies data [a] = a : [a] | []
11:19:17 <timthelion> simpson: but it should be able to compile data List a = Cons a | Nil to a rope as well.
11:19:22 <jmcarthur> timthelion: why?
11:19:29 <timthelion> jmcarthur: because that would be more efficient
11:19:35 <jmcarthur> timthelion: it's not always more efficient
11:19:36 <simpson> timthelion: https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1200006.1.3
11:19:46 <indiagreen> can ropes be infinite?
11:19:50 <Eduard_Munteanu> Consing to a bytestring is much less efficient for example.
11:20:01 <simpson> timthelion: If you can demonstrate how to design such a compiler, I'd be quite interested, but it's a non-trivial exercise and might violate the language specification.
11:20:11 <kuribas> Can you have sharing in a bytestring?
11:20:19 <jmcarthur> timthelion: if i need strict, constant time access to the front, the list is *way* more efficient. if i need to be able to generate it lazily, the list is *way* more efficient.
11:20:23 <Eduard_Munteanu> kuribas, yes
11:20:27 <jmcarthur> kuribas: sort of
11:20:42 <timthelion> Eduard_Munteanu: actually, if you do the low level rope as an array with some spare space in the front, it can be even more efficient than a linked list
11:20:46 <Eduard_Munteanu> One reason for 'copy'.
11:20:53 <jmcarthur> kuribas: it's easy to lose the sharing, but you can slice an existing bytestring into smaller ones that just point into the big one
11:21:14 <jmcarthur> timthelion: but then you lose persistence
11:21:14 <kuribas> I see...
11:21:22 <jmcarthur> timthelion: unless you copy the array every time
11:21:51 <jmcarthur> timthelion: and then it's very slow
11:21:59 <Eduard_Munteanu> Also the sharing keeps the bytestring alive too much at times.
11:22:35 <timthelion> jmcarthur: If people presented Text as "we tried to optimize data List a = Cons a | Nil and failed, so unfortunately we have to use Text" I would be happy.  But it doesn't seem that the authors of Text even tried.
11:22:53 <jmcarthur> timthelion: Text is not supposed to look like a linked list at all
11:22:58 <k00mi> timthelion: that's not the point of Text
11:22:59 * hackagebot tuple-hlist 0.2.0.0 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.2.0.0 (NicolasDudebout)
11:23:29 <timthelion> jmcarthur: but there are so many good properties of [Char].  Parsing with [Char] is soo easy.
11:23:31 <Eduard_Munteanu> timthelion, some of the operations on [a] are fundamentally incompatible with arrays
11:23:36 <int-e> timthelion: Because writing a new compiler (and that's what you're proposing) that is competetive and incorporates such ideas would be *way* more effort than writing a library that still solves the performance problem that people actually need solved.
11:23:44 <jmcarthur> timthelion: Text is more efficient for "texty" operations, and more correctly handles unicode. that's the point. it's not supposed to be a more efficient linked list
11:24:03 <k00mi> timthelion: an important aspect of Text is proper handling of unicode, [Char] can't do that no matter what [a] is compiled to
11:24:08 <jmcarthur> timthelion: it's not so easy if you need to do the things Text is designed for
11:24:33 <Eduard_Munteanu> timthelion, for example, what do you do with 'cycle "abc"' ?
11:25:08 <timthelion> k00mi: there are no examples that I have seen where Text handled unicode where String is incapable of doing so.  toLower is the only example I have seen, and that example is WRONG, because you CAN write a proper toLower :: String -> String function.
11:25:34 <Eduard_Munteanu> (Well, you can get that effect with lazy ByteString/Text because it's still a list at the outermost level)
11:25:45 <d3lxa> been two hours I'm trying to figure out why GHC panic, and still no idea: http://lpaste.net/112482 related to yesod forms, idk :S any idea?
11:26:13 <jmcarthur> timthelion: you are not even conceding or arguing against any of the totally valid points we've brought up. you're just complaining about things. i am now interpreting this as trollish behavior and will just move on with my life for a while
11:26:21 <Eduard_Munteanu> @src Char
11:26:21 <lambdabot> data Char = C# Char#
11:26:56 <kadoban> d3lxa: (probably unhelpful): upgrade GHC?
11:27:22 <timthelion> jmcarthur: you haven't actually given concrete examples.  I have been busy tring to respond to the concrete examples
11:27:36 <timthelion> jmcarthur: for example, the complaint that String doesn't support unicode
11:27:50 <benzrf> @let data Test = Test Char#
11:27:50 <lambdabot>  .L.hs:160:18:
11:27:50 <lambdabot>      Not in scope: type constructor or class ‘Char#’
11:27:50 <lambdabot>      Perhaps you meant ‘Char’ (imported from Data.Char)
11:27:54 <benzrf> oh
11:28:00 <Eduard_Munteanu> String is just unicode codepoints.
11:28:14 <Eduard_Munteanu> Not sure who argued that String is broken.
11:28:37 <timthelion> Eduard_Munteanu: cycle "abc"...  I would implement list like structures in two ways: For structures that are of non-predictable length, I would use linked lists
11:29:00 <timthelion> Eduard_Munteanu: k00mi just did
11:29:26 <timthelion> Eduard_Munteanu: my second implementation would involve linked sections, each section being an array.
11:29:47 <Eduard_Munteanu> timthelion, and now you've reimplemented lazy ByteString/Text :)
11:29:59 <timthelion> Eduard_Munteanu: exactly, at the compiler level, where it belongs ;)
11:30:35 <kuribas> I'd like to see supercompilation in a haskell compiler, where I can choose where to supercompile, and which function to inline for the supercompiler.
11:30:42 <Eduard_Munteanu> If you're asking for the compiler / runtime to optimize by packing linked lists into arrays, that's reasonable.
11:30:44 <k00mi> timthelion: woops, you're right
11:31:17 <Eduard_Munteanu> Reasonable conceptually, sure there are caveats.
11:31:19 <timthelion> Eduard_Munteanu: that's all I am asking. And I beleive it would not only render Text pointless, but would also help the situation with  [Int] et all.
11:32:01 <d3lxa> kadoban: I may try this as last resort but for now it's too costly (remake sandbox, make sure everything is fine, etc moreover I cannot use 7.8 for my production server, I need to build with 7.4 for my servers)
11:32:13 <Eduard_Munteanu> timthelion, that's a big step right there, to assume that it would be just as fast as code already written with arrays in mind.
11:32:17 <timthelion> Eduard_Munteanu: it would have to be done as a white list, like "the compiler knows that it is meaningful to do this optimization for [Char] [Int] [Word] and the other C types, and we'll add more later as we show that it's reasonable.
11:32:59 <Eduard_Munteanu> timthelion, it's not related to types but rather to usage patterns.
11:33:09 <timthelion> d3lxa: when I was writing in Elm(the compiler of which crashed on most type errors) I searched by randomly commenting out large sections of code ;)
11:33:30 <timthelion> Eduard_Munteanu: well, a pragma might be needed in some cases.
11:33:55 <timthelion> Eduard_Munteanu: but for most cases that are currently using a linked list, the chunked list is always better, no?
11:34:18 <timthelion> Eduard_Munteanu: the only case I can think of, is if you have many mulitple, slighly different copies of the list...
11:34:31 <timthelion> Eduard_Munteanu: in that case the chunked list might be slower and more memory intense
11:34:45 <int-e> > permutations "abcd"
11:34:47 <lambdabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdca...
11:35:04 <Eduard_Munteanu> Or large objects, where copying them would be slower than the gains of having a contiguous array.
11:35:27 <int-e> timthelion: you're also risking that the compiler gets distracted from fusion opportunities.
11:35:30 <timthelion> Eduard_Munteanu: are contiguous arrays ever used for [a] types?
11:36:02 <int-e> not in ghc, no.
11:36:09 <Eduard_Munteanu> timthelion, in place of? Text. :)
11:36:28 <timthelion> Eduard_Munteanu: in place of a linked list
11:38:10 <Eduard_Munteanu> GHC doesn't even optimize any updates into in-place mutation, for example.
11:38:32 <timthelion> int-e: I would argue that fusion could be done at the functional level.  Think of it pointlessly, fusion should not depend on the underlying data.
11:38:32 <Dodek> hm, which protocol buffers library is recommended nowadays?
11:38:35 <Eduard_Munteanu> And I figure that'd be somewhat less trickier.
11:39:47 <Eduard_Munteanu> timthelion, there are no builtin fusion optimizations really, everything requires RULES
11:41:07 <Eduard_Munteanu> So whatever strategy you want to implement would have to be expressed as such a rule.
11:41:56 <int-e> timthelion: I think you'll lose all the benefits of ropes, except for decreased memory usage, if you switch to ropes only after all optimizations are done; at that point, the access to lists will be broken down to constructors (cons, nil) and case statements. So for example, you cannot, retroactively, optimize appends.
11:42:21 <Eduard_Munteanu> e.g. the compiler blindly applies transformations like  map g . map f ---> map (g . f)
11:42:39 <int-e> timthelion: In any case I understand (and share, actually) your desire but I think you're seriously underestimating the complexity of what you're asking.
11:44:17 <int-e> To me, Text is just a pragmatic solution to getting decent performance for use cases with little sharing and long strings.
11:46:35 <Denommus> How to generate documentation for the dependencies of my cabal package?
11:46:49 <Denommus> I want to read the docs for Reactive Banana offline
11:46:58 <brycelane_> I'm having trouble making instances dependent on another instance when using multiparam typeclasses, specifically, ambiguous types.
11:48:22 <Eduard_Munteanu> brycelane_, like what?
11:48:38 <brycelane_> would a gist work?
11:49:01 <Eduard_Munteanu> brycelane_, yep, or lpaste
11:50:32 <ReinH> Wow, writing HTTP client libraries with Wreq is amazing.
11:51:16 <nononono> :t vertex
11:51:17 <lambdabot> Not in scope: ‘vertex’
11:51:30 <nononono> :t Graphics.Rendering.OpenGL.GL.VertexSpec.vertex
11:51:32 <lambdabot>     Not in scope: ‘Graphics.Rendering.OpenGL.GL.VertexSpec.vertex’
11:51:59 <Eduard_Munteanu> @hoogle vertex
11:52:01 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertex :: Vertex a => a -> IO ()
11:52:01 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertexAttrib :: VertexAttrib a => IntegerHandling -> AttribLocation -> a -> IO ()
11:52:01 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertexAttrib1 :: VertexAttribComponent a => AttribLocation -> a -> IO ()
11:53:01 * hackagebot hydrogen-syntax 0.6 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.6 (JulianFleischer)
11:53:12 <brycelane_> Eduard_Munteanu: https://gist.github.com/bryce-anderson/4a45c4299bcc86c42654
11:54:20 <Eduard_Munteanu> brycelane_, and what errors out?
11:54:22 <nononono> @pl \a b c d e -> a $ b c d e
11:54:22 <lambdabot> (.) . (.) . (.)
11:54:53 <stephenmac7> How would I go about getting all the possible pairs of elements in a list?
11:55:12 <stephenmac7> So, for [1,2,3], it would be [(1,2), (2,3), (1,3)]
11:55:17 <JagaJaga> Guys! How to put it in lambdas? f x = 1 + g x
11:55:19 <JagaJaga> g x = f x + g x
11:55:29 <JagaJaga> Y combinator or smth?...
11:56:06 <nononono> @pl f x = 1 + g x
11:56:06 <lambdabot> f = (1 +) . g
11:56:08 <Eduard_Munteanu> JagaJaga, 'fix'
11:56:18 <nononono> @pl g x = f x + g x
11:56:18 <lambdabot> g = fix (liftM2 (+) f)
11:56:45 <JagaJaga> oh. thx
11:57:01 <lilred> what's the pl command
11:57:08 <lilred> like how does the robot do it
11:57:36 <nononono> http://www.haskell.org/haskellwiki/Pointfree
11:57:43 <JagaJaga> but g still depends on f, no way to reduce?
11:58:00 <Eduard_Munteanu> > filter (uncurry (==)) . liftA2 (,) $ [1,2,3]
11:58:02 <lambdabot>  Couldn't match type ‘[b0] -> [(a0, b0)]’ with ‘[(b, b)]’
11:58:02 <lambdabot>  Expected type: [a0] -> [(b, b)]
11:58:02 <lambdabot>    Actual type: [a0] -> [b0] -> [(a0, b0)]
11:58:22 <brycelane_> Eduard_Munteanu, sorry, I updated the gist with the error message
11:59:07 <Eduard_Munteanu> Er.
11:59:56 <exio4> > (\xs → filter (uncurry (==)) . liftA2 (,) xs $ xs) [1,2,3]
11:59:57 <lambdabot>  [(1,1),(2,2),(3,3)]
12:00:09 <nononono> @unpl g x = f x + g x
12:00:09 <lambdabot> g x = (f x) + (g x);
12:00:14 <exio4> uhh
12:00:23 <Eduard_Munteanu> That.
12:00:58 <egasimus> is there something like a language-agnostic repl/command interpreter library for haskell?
12:01:42 <egasimus> something like python's click (http://click.pocoo.org/3/) or cmd (https://docs.python.org/3/library/cmd.html)?
12:01:52 <ReinH> @hackage pointfree -- lilred
12:01:52 <lambdabot> http://hackage.haskell.org/package/pointfree -- lilred
12:01:58 <nononono> @pl (.) . (.) . (.) a b
12:01:58 <lambdabot> (.) . (.) . a . b
12:02:31 <Eduard_Munteanu> brycelane_, is ∅ supposed to be Void?
12:02:39 <timthelion> int-e: I agree that it is certainly tricky to overhaul a compiler.  I think that is the only reason why the Text people didn't do it rather than making Text.  The problem is, that we want Haskell to be a great laungauge, not a langauge full of "the easier way out".
12:02:41 <brycelane_> yes, ()
12:02:51 <Eduard_Munteanu> > toLower '∅'
12:02:53 <lambdabot>  '\8709'
12:02:59 <Eduard_Munteanu> > '∅'
12:03:00 <lambdabot>  '\8709'
12:03:02 * hackagebot hydrogen-data 0.6 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.6 (JulianFleischer)
12:03:14 <Eduard_Munteanu> > isLower '∅'
12:03:17 <lambdabot>  False
12:03:21 <ReinH> timthelion: I think part of the reason that Haskell is a great language is that you can write things like Text in it without modifying the compiler
12:03:57 <nononono> @unpl (.) . (.) . (.) a b
12:03:57 <lambdabot> (\ n d e h -> a (b n) (d e h))
12:04:20 <brycelane_> Eduard_Muntaenu, sorry, my vim env turns () into '∅' and I just copied the terminal.
12:04:25 <timthelion> ReinH: Of course it is not a bad thing that optimizing by hand is possible.  But haskell has always been advertized as a high level language, and people are treating it as Linux treats C
12:04:50 <Eduard_Munteanu> brycelane_, does buildRenderable ignore its first argument?
12:05:06 <brycelane_> oh man... I think I just found it too. The type param was renamed
12:06:15 <Eduard_Munteanu> stephenmac7, in case it wasn't clear, the above thing involving liftA2 was for you
12:06:56 <brycelane_> Eduard_Munteanu: Thanks for the help, sorry it was just a 'spelling error' on my part.
12:07:30 <timthelion> ReinH: I'm not aguing with the fact that you can write Text, I am simply saying that writting it was a bad idea, promoting it with lies about unicode is a worse idea, and creating libraries that have functions like foo :: Text -> Bar rather than foo :: (Text t) t -> Bar is just being difficult for those who wish to use String
12:07:56 <stephenmac7> Eduard_Munteanu: Thanks, but that seems to give every combination, not just unique ones
12:07:57 <Eduard_Munteanu> brycelane_, by the way, ∅ isn't quite appropriate, it would denote an empty set, i.e. Void, not ().
12:08:37 <stephenmac7> I meant something that does this: http://lpaste.net/112484
12:08:38 <timthelion> ReinH: basically, the only long term effect Text has, is that it reduces the amount of incentive to improve the compiler
12:08:43 <Eduard_Munteanu> Er.
12:09:51 <Eduard_Munteanu> > filter (uncurry (/=)) (liftA2 (,) [1,2,3] [1,2,3])
12:09:53 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
12:10:13 <Eduard_Munteanu> > filter (uncurry (<)) (liftA2 (,) [1,2,3] [1,2,3])
12:10:15 <lambdabot>  [(1,2),(1,3),(2,3)]
12:11:14 <Eduard_Munteanu> stephenmac7, in case Ord is ok ^
12:11:38 <stephenmac7> Eduard_Munteanu: Would that be faster than the function above?
12:11:45 * Eduard_Munteanu looks
12:12:52 <Eduard_Munteanu> stephenmac7, not really, cmbs is actually the correct implementation I'd say
12:13:14 <stephenmac7> Does that already exist in the standard library?
12:13:33 <Guest16097> @pl \f g x y z -> f $ g x y z
12:13:33 <lambdabot> (.) . (.) . (.)
12:14:05 <Guest16097> :t (.) . (.) . (.) f g
12:14:06 <lambdabot>     Could not deduce (Show b0) arising from a use of ‘f’
12:14:06 <lambdabot>     from the context (FromExpr c, Show b, Show a)
12:14:06 <lambdabot>       bound by the inferred type of
12:14:26 <Guest16097> :t ((.) . (.) . (.)) f g
12:14:27 <lambdabot>     Could not deduce (Show b0) arising from a use of ‘f’
12:14:28 <lambdabot>     from the context (FromExpr c, Show a2, Show a1, Show a)
12:14:30 <lambdabot>       bound by the inferred type of
12:14:47 <Guest16097> :t (.) . (.) . (.) $ f g
12:14:48 <lambdabot>     Could not deduce (Show a0) arising from a use of ‘f’
12:14:48 <lambdabot>     from the context (FromExpr c, Show b)
12:14:48 <lambdabot>       bound by the inferred type of
12:16:40 <zwer> stephenmac7 your cmbs function doesn't handle []
12:17:18 <stephenmac7> zwer: True. Then again, I know I will have at least on value (the list I'm operating on has 28k values)
12:17:25 <stephenmac7> I should fix it, but I'm only running this once
12:18:51 <edwardk> @remember fishcorn When someone mentions lens on freenode... https://s3.amazonaws.com/fishcorn/zeus-lens.gif
12:18:51 <lambdabot> It is stored.
12:19:20 <stephenmac7> Though... now I'm getting a Job 1, “./process_dupes ” terminated by signal SIGKILL (Forced quit) error
12:19:55 <exio4> @src (++)
12:19:55 <lambdabot> []     ++ ys = ys
12:19:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:19:55 <lambdabot> -- OR
12:19:55 <lambdabot> xs ++ ys = foldr (:) ys xs
12:20:13 <stephenmac7> Looks like it ate all my memory... any way to fix this?
12:20:16 <YurasS> fishcorn
12:20:27 <YurasS> oops, sorry
12:23:56 <benzrf> edwardk do you have "lens" set as a ping name
12:24:07 <stephenmac7> No one knows how to reduce memory usage?
12:24:51 <phaazon> edwardk: you there?
12:25:38 <phaazon> I’m multiplying quaternions (representing orientations), and I wonder why the result is so… weird; I tried the normalize function, but I reckon it’s wrong here
12:25:43 <phaazon> any idea?
12:26:33 <YurasS> why haskellers usually assume infinite amount of memory? :|
12:27:07 <chaosmasttter> Hi, does someone know how to map a function over all non focused elements of the current traversal of a zipper from Control.Zipper?
12:28:30 <Taneb> YurasS, most high-level languages do
12:30:22 <YurasS> Taneb: no, it doesn't depends on language "level"
12:31:11 <YurasS> you either assume that resources are limited, or write "high level" code
12:31:20 <sipa> garbage collected language rarely give you decent ability to reason about memory usage
12:32:29 <edwardk> phaazon: maybe check the orientation we're using vs the orientation you are using?
12:32:47 <edwardk> phaazon: acowley had me switch handedness IIRC
12:32:55 <Taneb> YurasS, I mean, if you abstract away memory usage, it's easy to assume infinite
12:33:13 <Taneb> As far as I know, all garbage-collected languages do
12:33:32 <Taneb> In addition to this, Haskell's laziness allows for infinite structures in a meaningful way
12:33:39 <edwardk> benzrf: i turn it on about half the time. =) i have a lot of buzzwords that way to help me focus attention between the number of channels i lurk in
12:33:54 <phaazon> edwardk: what do you mean?
12:34:10 <phaazon> there’s not a few ways to encode orientation within quaternions
12:34:14 <YurasS> Taneb: so it is ok to load full multipart into memory? :)
12:34:25 <Taneb> I don't know what you are asking there
12:34:55 <edwardk> phaazon: i meant the conversion to a rotation matrix on the way out
12:35:06 <phaazon> oh
12:35:15 <phaazon> handedness?
12:35:33 <YurasS> Taneb: that is the example. I want to read multipart email, but any lib I see on hackage reads parts into memory
12:35:34 <vanila> https://www.youtube.com/watch?v=xmjvOLlCdFU
12:35:51 <YurasS> Taneb: doesn't allow incremental processing
12:35:55 <edwardk> anyways, there is a lot of code shipping off them, so i'd be rather surprised if the calculation of something as simple as a quaternion product was just totally borked
12:36:46 <edwardk> if you have something with a known expected value and a counter-example i'm happy to look into fixing it. the current version should just be the Cayley-Dickson construction iterated twice on the Reals.
12:37:14 <phaazon> edwardk: well, I have a rotating torus, so it might be okay
12:37:35 <phaazon> however, it terribly fails when I want to multiply them with the (*) operator
12:38:44 <Hijiri> well getContents does lazy IO, and it's in prelude
12:38:57 <Hijiri> It'll have constant memory usage provided you only look at each element once
12:39:13 <Hijiri> so you could for example skip over the non-text part of a multipart email
12:39:26 <Hijiri> and then only load into memory the text part into a separate list, or into a Text value or something
12:40:11 <nh2> how do I turn Array into UArray efficiently?
12:40:14 <YurasS> Hijiri: lazy IO for network communication? no, thanks
12:40:29 <phaazon> the orientation sounds okay actually
12:40:39 <Hijiri> I thought you were trying to read emails already downloaded
12:40:44 <edwardk> phaazon: >>> Quaternion a (V3 b c d) * Quaternion e (V3 f g h)
12:40:46 <edwardk> Quaternion (a * e - (b * f + c * g + d * h)) (V3 (c * h - d * g + a * f + e * b) (d * f - b * h + a * g + e * c) (b * g - c * f + a * h + e * d))
12:40:59 <edwardk> phaazon: you can check that against http://www.mathworks.com/help/aeroblks/quaternionmultiplication.html
12:41:32 <phaazon> however, I try to generate the forward, upward and leftward vectors (for a freefly camera). For instance, for forward, I just do something like: rotate orientation (V3 0 0 (-1))
12:41:44 <phaazon> maybe I have to negate the orientation hm
12:41:45 <YurasS> Hijiri: the point is that the libraries load everything into memory. type Multipart = [Part]
12:42:09 <YurasS> Hijiri: even for offline email I need to write my onw parser for emails
12:42:34 <YurasS> or load into memory :|
12:43:44 <YurasS> someone spent type writing email parsing libs, but they are useful only for toy examples
12:44:01 <YurasS> that is too often in haskell :(
12:49:11 <chirpsalot> Hmmm. Custom types can't work with .. can they?
12:49:30 <ezrios> are values declared in a let statement shared?
12:49:41 <indiagreen> chirpsalot: you mean “..” in lists?
12:49:43 <YurasS> chirpsalot: all Enum should
12:49:58 <chirpsalot> YurasS: ah, Enum is probably what I was looking for. Thanks1
12:50:14 <ezrios> and what about values declared in a where statement?
12:50:15 <chirpsalot> Hard to look up typeclasses since (..) isn't a function :P
12:50:26 <indiagreen> it's desugared to enumFromThenTO
12:50:28 <indiagreen> *To
12:50:37 <indiagreen> and friends
12:50:43 <chirpsalot> indiagreen: ah, awesome, thanks!
12:51:09 <phaazon> edwardk: http://lpaste.net/112487 I’m basing on that
12:51:28 <chirpsalot> YurasS: that fixed it, thanks! :).
12:51:35 <phaazon> and I don’t know whether the normalize function is the same as linear’s normalize
12:52:02 <YurasS> you are welcome
12:53:49 <Hijiri> rip
12:54:20 <Lutin`> Anyone here running Arch Linux? Wanted to install pandoc through pacman but it's no longer in extra, so I tried [haskell-core] but it's not in there either
12:54:40 <Lutin`> Sorry I mean haddock is not in [haskell-core]
12:55:04 <Lutin`> I guess since haddock is standalone, I can just go with the community version
13:01:43 <Lutin`> I'll just cabal install it for now
13:02:28 <RchrdB> Lutin`: if you do install anything by "cabal install", I'd strongly recommend installing into a sandbox.
13:02:58 <RchrdB> Lutin`: I don't have enough familiarity with Arch Linux any more to address any of your other questions, sorry.
13:05:59 <glaebhoerl> if there are any sufficiently high wizards around, I have some vaguely confused questions: what's the difference/relationship between existential types (`exists`) and dependent pairs (sigma)? is it similar to the one between forall-types and pi-types (as described on the DependentHaskell wiki page)? or are they just the same thing? (is there any remotely sensible notion of parametricity for pairs as opposed to functions?)
13:06:33 <tnks> anyone using shm?
13:06:48 <tnks> I'm dinking around with it now, but not sure how I feel about it.
13:07:23 <tnks> I'm not sure how to undo wrap-parens.
13:08:10 * hackagebot cmdargs 0.10.11 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.11 (NeilMitchell)
13:08:46 <vanila> glaebhoerl, The type of th second component of a dependent pair may be different depending on the value of the first component
13:09:43 <pic_> I was wondering if anyone could help me with a type issue.
13:10:13 <pic_> Err Actually nevermind for now.
13:12:26 <YurasS> folks, what do you think about blaze-builder vs bytestring built-in Builder?
13:12:50 <YurasS> I thought the former obsolete
13:13:06 <YurasS> but now I see a lot of packages still depends on it
13:13:10 * hackagebot pipes-zlib 0.4.3 - Zlib and GZip compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.3 (RenzoCarbonara)
13:13:43 <srd1g10_> Why is something like 'addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)' better than 'addVectors a b = (fst a + fst b, snd a + snd b)'? According to Learn You a Haskell it is.
13:15:15 <Eduard_Munteanu> srd1g10_, it's a matter of style, I'd say.
13:15:34 <Eduard_Munteanu> srd1g10_, you don't need fst and snd if you can just pattern-match
13:15:47 <srd1g10_> Eduard_Munteanu: Is is that the second is more explicit and shows exactly what the arguments are?
13:16:10 <Eduard_Munteanu> It isn't really more explicit.
13:16:15 <srd1g10_> Eduard_Munteanu: Sorry, the first one
13:16:56 <stephenmac7> Any way to perform calculations concurrently?
13:17:16 <Eduard_Munteanu> stephenmac7, multiple
13:17:47 <stephenmac7> The code I have can be found here: http://lpaste.net/112486 but it's running much too slowly
13:18:38 <Lutin`> stephenmac7: http://hackage.haskell.org/package/parallel-3.1.0.1/ is a common solution
13:19:52 <Eduard_Munteanu> srd1g10_, it's just pattern-matching is encouraged, especially for simple types
13:20:22 <ezrios> is there some prelude function to drop an element of a list at a certain index?
13:20:27 <frihd> stephenmac7:  what is cmbs?
13:20:27 <ezrios> or data.list function even
13:20:36 <ezrios> @hoogle Int -> [a] -> [a]
13:20:39 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:20:39 <lambdabot> Data.List drop :: Int -> [a] -> [a]
13:20:39 <lambdabot> Prelude take :: Int -> [a] -> [a]
13:20:44 <ezrios> hrm
13:20:44 <Lutin`> stephenmac7: You also might want to consider an algorithm that isn't O(n^2)
13:20:58 <Eduard_Munteanu> @hoogle delete
13:21:01 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
13:21:01 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
13:21:01 <lambdabot> Data.IntMap.Strict delete :: Key -> IntMap a -> IntMap a
13:21:09 <Eduard_Munteanu> @hoogle deleteBy
13:21:11 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:21:17 <stephenmac7> frihd: cmbs takes a list like [1,2,3] and returns [(1, 2), (2, 3), (1, 3)]
13:21:21 <Eduard_Munteanu> ezrios, well, not quite
13:21:22 <ezrios> Eduard_Munteanu: delete/deleteBy seems sufficient, thanks
13:21:42 <frihd> stephenmac7:  you should zip xs (drop 1 xs)
13:22:16 <Lutin`> frihd: That's not quite what he's doing
13:22:26 <stephenmac7> Lutin`: What would you suggest?
13:22:40 <stephenmac7> I have to compare every row in the database
13:22:45 <frihd> oops sorry
13:22:46 <Lutin`> It's basically `cmbs xs = [(x,y) | x <- xs, y <- xs, x != y]
13:22:50 <bitemyapp> @pl pairs xs ys = do x <- xs; y <- ys; return (x, y)
13:22:50 <lambdabot> (line 1, column 25):
13:22:50 <lambdabot> unexpected ';'
13:22:50 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
13:22:53 <bitemyapp> sigh.
13:22:55 <frihd> right
13:23:43 <ezrios> Also, are variables declared in where clauses shared?
13:23:47 <stephenmac7> Lutin`: Not quite, that one will return both (2,3) and (3,2)
13:24:04 <ezrios> for example, foo = bar ++ bar where bar = -- some expensive function
13:24:07 <Eduard_Munteanu> ezrios, shared with what?
13:24:11 <frihd> stephenmac7:  you can guard x < y
13:24:16 <Lutin`> stephenmac7: Yeah
13:24:23 <ezrios> Eduard_Munteanu: I am referring to the concept of "sharing" - http://www.haskell.org/haskellwiki/Sharing
13:24:23 <stephenmac7> Yes, but is that necessarily faster?
13:24:25 <Eduard_Munteanu> ezrios, the where clause binds to the declaration
13:24:27 <Eduard_Munteanu> I know.
13:24:32 <Eduard_Munteanu> But scoping is important.
13:24:49 <ezrios> Eduard_Munteanu: I only require it in that declaration's scope
13:25:04 <ezrios> but I make use of the variable's value multiple times
13:25:07 <ezrios> and I want to avoid recomputation
13:25:12 <stephenmac7> Lutin`: You think it's cmbs that is taking so long?
13:25:30 <ezrios> (I am not referring to memoization, caching values of a function across recursive calls)
13:25:33 <Lutin`> stephenmac7: That was just the first thing that stuck out
13:25:40 <Eduard_Munteanu> ezrios, yes, but it might not be shared among invocations of the same function at different arguments
13:25:43 <frihd> stephenmac7:  well, your problem is O(n-square) to start with
13:26:14 <stephenmac7> Yes, it is... which is bad when n is 28000
13:26:15 <ezrios> Eduard_Munteanu: that's ok, it's not really a function anyway, just a value
13:26:22 <ezrios> or maybe you could say it's a "nullary" function
13:26:34 <Eduard_Munteanu> Then it will likely be shared.
13:26:40 <stephenmac7> Is there any way to mitigate the issue?
13:26:42 <ezrios> Eduard_Munteanu: ok, thanks muchly
13:27:12 <frihd> stephenmac7:  with strategies, you can parallelize pure computations, but you'll need many cores
13:27:31 <Lutin`> stephenmac7: You could use a similarity calcuation that is N*log(N)
13:27:40 <Lutin`> Like something in this article http://railsware.com/blog/2012/05/10/effective-similarity-search-in-postgresql/
13:28:18 <Lutin`> If you calculate some signature/fingerprint for each images
13:28:31 <Lutin`> Either by resizing to a fixed size or Haar wavelets or something
13:28:48 <augur> any good tutorials for installing ghc-mod
13:29:05 <Eduard_Munteanu> @harr
13:29:05 <lambdabot> Maybe you meant: yarr arr
13:29:10 <stephenmac7> Lutin`: The current suolution uses phash
13:29:28 <Eduard_Munteanu> @haar
13:29:28 <lambdabot> Maybe you meant: yarr arr
13:30:01 <Lutin`> stephenmac7: Ah yeah so it does
13:30:02 <frihd> stephenmac7:  then you may be ram-swapping if images are big
13:30:11 <knod_> Hi, I'm not actually using haskell, I'm in a class studying programming paradigms using a language called oz. It doesn't seem to have a channel though, and I'm struggling with some of the stuff they're doing with functional programming.
13:30:18 <stephenmac7> I have already calculated all the "fingerprints"
13:30:35 <stephenmac7> So, the issue is just comparing them.
13:30:51 <Lutin`> stephenmac7: You could calculate the PHash and sort the list then scan for close numbers
13:30:53 <knod_> Right now we're studying invariants and they've asked us to figure out how many accumulators would be in a program creating the fibonacci sequence, but I'm not sure how to figure it out.
13:31:08 <ClaudiusMaximus> stephenmac7: sort O(n log n), then compare adjacent elements in the list O(n)
13:31:14 <Lutin`> stephenmac7: I'm not quite sure how perceptual hashing works
13:31:16 <stephenmac7> Lutin`: To be honest, I don't know how phash works.
13:31:21 <knod_> Any hints as to how to go about doing this?
13:32:12 <stephenmac7> Lutin`: Couldn't we sort using the perceptual hash function?
13:32:16 <ClaudiusMaximus> oh, you're not comparing for exact sameness
13:32:33 <Lutin`> stephenmac7: Doesn't appear to have a proper ordering
13:32:56 <Lutin`> e.g. hammingDistance (PHash 15243782418149777067) (PHash 17549625427362946731) = 2
13:33:26 <stephenmac7> Guess so.
13:33:44 <knod_> Also, if it is inappropriate to ask that here, can someone point me to another channel where I can ask questions about functional programming concepts?
13:33:46 <stephenmac7> So, is this just the best way to do it, and I just have to deal with my computer running the calculation for 13 hrs?
13:33:51 <Lutin`> It appears the phash library has a hash db built in
13:33:59 <Lutin`> But the haskell library doesn't provide bindings
13:34:22 <Lutin`> Maybe consider looking for a PostgreSQL library that does something like you'd want?
13:34:47 <frihd> stephenmac7:  can you fit all images in RAM?
13:34:56 <knod_> I'd rather have hints than just look up the answer
13:35:02 <Eduard_Munteanu> knod_, I suspect you should reference the fact that fib[n] = fib[n-1] + fib[n-2], so wherever you are in that sequence, computing the next step requires knowing the previous two steps.
13:35:33 <knod_> Oh, interesting
13:35:49 <knod_> That would make it two accumulators then. Or perhaps 3.
13:36:02 <knod_> Do I need one to keep track of the other two somehow?
13:36:03 <stephenmac7> frihd: I can fit all the fingerprints in RAM, not all the images
13:36:09 <knod_> @ Eduard_Munteanu
13:36:17 <Eduard_Munteanu> knod_, no, two. Two is enough to figure whatever you were thinking of about the third.
13:36:30 <knod_> Ok, got it, thank you Eduard_Munteanu
13:37:11 <DTSCode> can anyone help me with these errors? http://paste.ubuntu.com/8548109/
13:37:16 <stephenmac7> Even if there was a postgres plugin or whatever (like maybe http://zdk.blinkenshell.org/detecting-similar-images-with-phash-and-pg_similarity/), it would still have to compare every image
13:37:59 <stephenmac7> Additionally, the problem might just be the insertion into the database. Is there any way to figure out what part of the program is using the most time?
13:38:34 <Lutin`> You can build your executable with profiling
13:38:37 <frihd> stepcut:  ok, maybe you want to use strategies for parallelizing the map (e.g., parListChunk)
13:38:43 <ezrios> woo
13:38:46 <ezrios> babby's first happstack
13:38:54 <Lutin`> stephenmac7: http://book.realworldhaskell.org/read/profiling-and-optimization.html is a good read
13:39:15 <Eduard_Munteanu> knod_, another way to put it, I suppose, is that fib[0] and fib[1] are enough to figure out fib[N], for any fixed N.
13:39:33 <stephenmac7> Lutin`: But that means I have to build all the libraries with profiling too
13:39:34 <frihd> sorry stepcut this was for stephenmac7
13:39:54 <Lutin`> stephenmac7: Unfortunately yes.. :(
13:40:06 <stephenmac7> Is there a way to force evaluation?
13:40:24 <stepkut> frihd: :p
13:40:31 <Eduard_Munteanu> stephenmac7, multiple :)
13:40:33 <knod_> Eduard_Munteanu: thanks
13:40:56 <Lutin`> stephenmac7: I defer to someone else, I need to get back to my work
13:42:15 <frihd> stephenmac7:  look at http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html  Simon  Marlow's book is good and well-explained
13:42:49 <stephenmac7> frihd: So, you suggest parallel evaluation?
13:43:05 <Lutin`> stephenmac7: I do suggest looking into how to do this in Postgres as even though it might still be O(n^2) the constants would be much lower
13:43:23 <Lutin`> There's always going to be overhead doing it outside of Postgres, no matter the language
13:43:40 <Lutin`> Though I understand if you'd rather not haha
13:43:46 <stephenmac7> Lutin`: This is a one time operation, so I might be willing to just cut my losses and run it
13:44:00 <stephenmac7> I have almost no experience with postgres so it might take just as long to get it working...
13:44:06 <Lutin`> Gotcha
13:44:12 <frihd> stephenmac7: yes, it's cheap to try, but you'll gain at most 1 factor per core
13:44:32 <stephenmac7> So, instead of 13 it will be about 5 hrs
13:44:49 <Eduard_Munteanu> stephenmac7, how are you calculating Hamming distances?
13:44:51 <chrisdone> it would be neat if there was a construct that would be equivalent to unsafeCoerce but GHC would compare presentations
13:45:02 <stephenmac7> Eduard_Munteanu: Using a library
13:45:06 <Lutin`> stephenmac7: Using Data.PHash.hammingDistance
13:45:07 <chrisdone> i think agda and idris have some thing like that
13:45:19 <Lutin`> I mean Eduard_Munteanu
13:45:40 <Eduard_Munteanu> I'm not familiar with that library, what are they doing?
13:46:10 <Lutin`> Just the number of differing bits in the 64-bit hash
13:46:20 <stephenmac7> Eduard_Munteanu: using the c library libphash
13:46:29 <frihd> stephenmac7:  also, you may gan a bit by using strict fields inside your Image and Duplicate
13:46:33 <chrisdone> foo :: Proxy Int -> Proxy Char
13:46:33 <chrisdone> foo = unsafeCoerce
13:46:36 <Eduard_Munteanu> Well... that's by definition.
13:46:42 <luite> chrisdone: that's what roles are for isn't it?
13:46:47 <chrisdone> it would be good if there was a special identifier you could use instead
13:46:49 <Eduard_Munteanu> I was wondering if they compute it efficiently.
13:46:54 <stephenmac7> In short, I don't know how they are calculating it
13:47:00 <chrisdone> luite: i'm wondering that
13:47:01 <stephenmac7> frihd: How would I go about doing that?
13:47:17 <chrisdone> i only watched half of the talk but it seemed like it was restricted to newtypes
13:47:56 <Lutin`> Eduard_Munteanu: I don't see anything in there design docs that suggests so
13:47:59 <Lutin`> their*
13:48:06 <frihd> you add a ! before the type in the data declaration
13:48:36 <stephenmac7> So, data Image = Image { imageId :: !Int, imagePrint :: !PHash } deriving (Show, Eq)
13:48:38 <frihd> stephenmac7: http://www.haskell.org/haskellwiki/Performance/Data_types#Strict_fields
13:48:41 <frihd> yes
13:49:22 <Eduard_Munteanu> That only helps if PHash is amenable to strictifying that way.
13:49:52 <luite> chrisdone: oh it does work for data, but i don't think it can infer representational equality between to unrelated data types, only within a parameterized one
13:49:53 <Eduard_Munteanu> e.g. not a datatype that's itself non-strict
13:50:04 <luite> chrisdone: *two
13:50:24 <stephenmac7> frihd: That is a bit faster
13:50:32 <Lutin`> newtype PHash = PHash Word64
13:50:59 <knod_> I'm trying to use Oz and I minimized my browser window. Now I can't find it. Does anyone know how I can find it again?
13:51:19 <Eduard_Munteanu> Ok, that'll work then.
13:51:40 <Eduard_Munteanu> stephenmac7, also try -funbox-strict-fields
13:52:17 <stephenmac7> Just a little faster...
13:52:22 <frihd> stephenmac7:  yeah , optimization is a battle where small wins count =)
13:52:23 <Eduard_Munteanu> stephenmac7, and I hope you are compiling with at least -O, if not -O2
13:52:35 <stephenmac7> Yes, compiling with -O2
13:53:12 * hackagebot Nomyx-Language 0.7.2 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.2 (CorentinDupont)
13:53:26 <chrisdone> luite: so it could do Proxy?
13:53:34 <Eduard_Munteanu> stephenmac7, and you might want to do the same for Duplicate
13:53:41 <stephenmac7> Eduard_Munteanu: I did
13:54:01 <kuznero> How can I do this? `m (m a) -> m a`
13:54:10 <Eduard_Munteanu> kuznero, join
13:54:12 <chrisdone> hoogle it
13:54:18 <chrisdone> or let someone tell you
13:54:21 <Eduard_Munteanu> :)
13:54:37 <chrisdone> @hoogle m (m a) -> m a
13:54:39 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
13:54:39 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
13:54:39 <lambdabot> Prelude concat :: [[a]] -> [a]
13:54:44 <kuznero> chrisdone: I tried searching by type on hayoo, but did't work
13:54:53 <chrisdone> hayoo isn't as sophisticated as hoogle
13:54:54 <kuznero> nice
13:54:55 <kuznero> :)
13:54:58 <Eduard_Munteanu> stephenmac7, also, I'd inline cmpImages
13:55:03 <kuznero> thanks!
13:55:09 <chrisdone> welcome =3
13:55:31 <luite> chrisdone: yeah i suppose, the canonical examples seem to be Ptr and Set (since you can't unsafeCoerce (Set a) to (Set b) even if b is just a newtype for a as that might violate the Ord invariants)
13:55:43 <frihd> :t PHash
13:55:44 <lambdabot> Not in scope: data constructor ‘PHash’
13:55:51 <stephenmac7> Eduard_Munteanu: How would I go about doing that?
13:56:03 <stephenmac7> Also, using parallel just uses too much memory
13:56:05 <chrisdone> luite: that makes sense
13:56:06 <Eduard_Munteanu> stephenmac7, {-# INLINE cmpImages #-}
13:56:26 <frihd> stephenmac7:  what type is read in (PHash . read) ?
13:56:54 <frihd> when perfs matters, sometimes read is too slow
13:56:59 <stephenmac7> PHash is a newtype for Word64 and read is reading a String from the database
13:57:06 <stephenmac7> or varchar as they call it
13:57:09 <chrisdone> luite: i'm writing a tiny lambda-calculus-ish language in progressive versions to show adding more type-safety and got stuck on needing coerce
13:57:32 <vanila> chrisdone, a compiler?
13:58:12 <ClaudiusMaximus> stephenmac7: if you used parMap, consider using parBuffer instead  (the former evaluates the *whole* list in parallel, the latter does it in a more manageable way in chunks rolling along the list as it goes)
13:58:12 * hackagebot hzulip 0.3.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-0.3.0.0 (yamadapc)
13:58:27 <Anouk23>  There is no such thing as Free Porn http://bit.do/my_videos69
13:59:31 <chrisdone> trivial hoas l-calculus https://gist.github.com/chrisdone/d236fcec950b199a015f
13:59:31 <chrisdone> same thing with both non-HOAS and HOAS lambdas, and a converter from the former to the latter https://gist.github.com/chrisdone/7c7fca124b4eedf53545
13:59:31 <chrisdone> same thing with stage distinction of non-HOAS to HOAS https://gist.github.com/chrisdone/b4eb90186741304b3ffb
13:59:54 <chrisdone> the "neat" thing is e.g. the hoas converts from an E Dirty a -> E Clean a
14:00:05 <Lutin`> stephenmac7: You might benefit from doing the hamming calculation in haskell
14:00:11 <chrisdone> and then eval, the actual interpreter, only has to deal with a small set of cases
14:00:14 <Lutin`> stephenmac7: Also try it without the inserts
14:00:17 <SrPx> How can I use unicode characters as constructor names? data Term = λ | ∫ | ∂ | Etc
14:00:28 <stephenmac7> Lutin`: It won't evaluate without the inserts
14:00:34 <chrisdone> and GHC 7.8 is smart enough with GADTs to know i've satisfied all the cases in eval
14:00:34 <Lutin`> stephenmac7: Force the eval
14:00:36 <frihd> stephenmac7:  I think there may be a faster decimal bytestring -> word64 parser in attoparsec, provided you can read bs from the DB
14:01:17 <Lutin`> frihd: Why is that necessary?
14:01:27 <stephenmac7> How would I go about using parBuffer?
14:01:41 <Lutin`> frihd: Ah he's `read`ing
14:01:48 <frihd> yes
14:02:19 <stephenmac7> Nevermind, I got it... but it's not making it any faster
14:02:34 <Lutin`> Try doing the hamming distance in haskell
14:02:36 <gregnwosu> lo, can anyone recommend a paper or vid on free monads, i get it but dont grok it yet
14:02:36 <Eduard_Munteanu> chrisdone, perhaps you can use RULES to assert that whatever proven code the compiler accepts can actually be evaluated under the unproven evaluator.
14:02:47 <stephenmac7> Lutin`: How do you calculate hamming distance?
14:02:59 <Lutin`> `count_ones(a xor b)`
14:03:03 <Hijiri> SrPx: I think the first character has to be classified as uppercase and a letter
14:03:09 <pic_> SO I have a question about arrows
14:03:11 <SrPx> uhm
14:03:12 <Hijiri> I think there's a haskell function that gives you the unicode category
14:03:13 * hackagebot hplayground 0.1.1.0 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.1.0 (AlbertoCorona)
14:03:22 <ClaudiusMaximus> stephenmac7: something like parMap' strat f = withStrategy (parBuffer numberOfCores strat) . map f
14:03:23 <Eduard_Munteanu> You need a good population count though.
14:03:26 <RchrdB> SrPx: offhand, I think that what GHC does is assume that all Haskell files are encoded as UTF-8 by default, and you may use Unicode characters that are defined as letters in identifiers, but they follow the same uppercase/lowercase rules.
14:03:28 <gregnwosu> i think i want to get better at writing dsls in haskell
14:03:31 <geekosaur> > generalCategory 'a'
14:03:33 <frihd> stephenmac7:  in bytestring-lexing you may want to try readDecimal_
14:03:34 <lambdabot>  LowercaseLetter
14:03:52 <frihd> :t readDecimal_
14:03:54 <lambdabot> Not in scope: ‘readDecimal_’
14:03:59 <SrPx> okay thanks
14:04:24 <RchrdB> SrPx: e.g. "Σ" is permitted as the start of a constructor or data type's name, "σ" is permitted as the start of an identifier's name.
14:04:56 <frihd> but it only works if you have something else than a string as input (I don't know pg-simple)
14:05:03 <SrPx> :( thanks but ...
14:05:09 <RchrdB> SrPx: IIRC I think that for glyphs that aren't defined to have lower/upper cases, (Han characters?) you have to start the identifiers with some character that does.
14:05:13 <pic_> Say I have a function "f :: a -> Maybe b" and I have a list of type "a" now I want to a list of type "(a, b)", but I want to drop element if f returns Nothing.
14:05:23 <pic_> Can I do this somehow with Arrows?
14:06:19 <Eduard_Munteanu> :t catMaybes . map ?f
14:06:20 <lambdabot> (?f::a1 -> Maybe a) => [a1] -> [a]
14:06:29 <chrisdone> implicit params are awesome
14:06:35 <Eduard_Munteanu> pic_, why arrows?
14:06:46 <chrisdone> has anyone used roman chekywhatsitov's gfoldl?
14:06:53 <stephenmac7> frihd: That did not speed it up, as far as I can tell
14:07:00 <pic_> It seems like the right thing to do.
14:07:12 <gregnwosu> , gfoldl
14:07:15 <RchrdB> :t \f l -> catMaybes . map (\x -> f x >>= (\v -> (a, v)))
14:07:15 <pic_> Its pretty close to
14:07:16 <lambdabot>     Couldn't match type ‘(,) Expr’ with ‘Maybe’
14:07:16 <lambdabot>     Expected type: Maybe a
14:07:16 <lambdabot>       Actual type: (Expr, a)
14:07:18 <pic_> id &&& f
14:07:22 <frihd> yes, it's in the linear  part of your program, so it may be unnoticeable as well
14:07:29 <pic_> right? I just want to do some sor tof filter as I go
14:07:32 <gregnwosu> what is gfoldl?
14:07:44 <RchrdB> :t \f l -> catMaybes . map (\x -> (\v -> (a, v)) <$> f x)
14:07:45 <lambdabot> (a -> Maybe t1) -> t -> [a] -> [(Expr, t1)]
14:07:57 <chrisdone> λ> let ?c = Proxy :: Proxy Num in gmap (\x -> x + x) (1.4,"hi")
14:07:59 <chrisdone> (2.8,"hihi")
14:08:06 <RchrdB> I've done something horribly wrong there. :(
14:08:06 <geekosaur> gregnwosu, presumably foldl implemented in terms of generics
14:08:10 <chrisdone> (with a Num instance for String, just to demonstrate)
14:08:32 <chrisdone> it's like Data's fold but you can provide an instance that elements selected must be an instance of
14:08:38 <chrisdone> it's actually made of magic and pixie dust
14:08:50 <chrisdone> http://hackage.haskell.org/package/traverse-with-class-0.1.1.1/docs/Data-Generics-Traversable.html
14:08:54 <RchrdB> :t \f l -> catMaybes . map (\x -> fmap (\v -> (x, v)) (f x))
14:08:55 <lambdabot> (t1 -> Maybe t2) -> t -> [t1] -> [(t1, t2)]
14:08:56 <Lutin`> Aww man
14:08:56 <stephenmac7> So, to test it without the inserts, how do I forge evaluation?
14:08:58 <ClaudiusMaximus> :t \f as -> mapMaybe (\a -> fmap ((,)a) (f a)) as
14:08:59 <lambdabot> (a1 -> Maybe a) -> [a1] -> [(a1, a)]
14:08:59 <chrisdone> gtraverse :: (Applicative f, ?c :: p c) => (forall d. c d => d -> f d) -> a -> f a
14:09:10 <Lutin`> chrisdone: Does GHC use the LLVM backend by default now?
14:09:19 <chrisdone> Lutin`: i don't think so
14:09:49 <Lutin`> Shame, there's an llvm intrinsic that counts the number of bits set in a value
14:09:51 <chrisdone> last i checked 7.8 uses the Asm backend when compiling object code
14:10:06 <frihd> stephenmac7:  gotta go, to force eval, you need deepseq
14:10:09 <Lutin`> and I don't see a countBits in GHC Base
14:10:27 <Lutin`> Oh
14:10:32 <Lutin`> popCount
14:10:33 <nh2> Lutin`: IIRC there is such a thing, don't remember where
14:10:35 <Lutin`> durr
14:10:46 <Lutin`> :t Data.Bits.popCount
14:10:47 <lambdabot> Bits a => a -> Int
14:10:56 <nh2> yes
14:11:16 <Lutin`> :t popCount
14:11:17 <lambdabot> Bits a => a -> Int
14:12:03 <Lutin`> @def hammingDistance x y = popCount (x xor y)
14:12:03 <stephenmac7> How do I create an instance of NFData?
14:12:05 <lambdabot>  Defined.
14:12:29 <Eduard_Munteanu> stephenmac7, seq and recursing
14:12:34 <Lutin`> > hammingDistance 15243782418149777067 17549625427362946731
14:12:35 <lambdabot>  No instance for (Data.Bits.Bits a10)
14:12:35 <lambdabot>    arising from a use of ‘L.hammingDistance’
14:12:35 <lambdabot>  The type variable ‘a10’ is ambiguous
14:12:35 <lambdabot>  Note: there are several potential instances:
14:12:35 <lambdabot>    instance Data.Bits.Bits GHC.Types.Bool
14:12:46 <Lutin`> hmm
14:12:52 <chrisdone> the weird thing is roman's library is barely documented, you have to read his paper to figure out how to use the library
14:13:10 <Lutin`> Oh woops
14:13:19 <Lutin`> @def hammingDistance x y = popCount (x `xor` y)
14:13:20 <lambdabot>  .L.hs:156:41:
14:13:20 <lambdabot>      Occurs check: cannot construct the infinite type:
14:13:20 <lambdabot>        t ~ (a1 -> a1 -> a1) -> t -> a
14:13:20 <lambdabot>      Relevant bindings include
14:13:20 <lambdabot>        y :: t (bound at .L.hs:156:19)
14:13:24 <Lutin`> @undef
14:13:24 <lambdabot> Undefined.
14:13:27 <Lutin`> @def hammingDistance x y = popCount (x `xor` y)
14:13:29 <lambdabot>  Defined.
14:13:33 <Lutin`> > hammingDistance 15243782418149777067 17549625427362946731
14:13:35 <lambdabot>  2
14:13:39 <Lutin`> There you go stephenmac7
14:13:55 <Lutin`> That removes a FFI call
14:14:03 <stephenmac7> Lutin`: Very cool. Let me try it
14:14:21 <stephenmac7> x and y are... what type?
14:14:36 <Lutin`> a ~ Bits a1
14:14:42 <Lutin`> :t hammingDistance
14:14:42 <lambdabot> Bits a => a -> a -> Int
14:14:49 <Eduard_Munteanu> I'd force it to Word64.
14:15:02 <Lutin`> Yeah not a bad idea
14:15:22 <Eduard_Munteanu> And inline it.
14:16:45 <stephenmac7> Where is word64?
14:16:46 <phaskell> No symbol 'word64' found anywhere.
14:16:52 <stephenmac7> Where is Word64?
14:16:52 <phaskell> No symbol 'Word64' found anywhere.
14:17:16 <Lutin`> Data.Word I believe
14:17:18 <Eduard_Munteanu> stephenmac7, Data.Word. Or use PHash.
14:17:52 <Lutin`> I love ipython
14:18:30 <stephenmac7> Where is xor
14:18:33 <stephenmac7> Where is xor?
14:18:34 <phaskell> No symbol 'xor' found anywhere.
14:18:48 <exio4> Where is head?
14:18:48 <phaskell> No symbol 'head' found anywhere.
14:18:49 <Lutin`> It's part of the Bits typeclass in Data.Bits
14:18:50 <stephenmac7> Data.Bits
14:18:58 <geekosaur> @index xor
14:18:58 <lambdabot> Data.Bits, Foreign
14:19:09 <hnoob> where is <*>?
14:19:09 <phaskell> No symbol '<*>' found anywhere.
14:19:13 <Lutin`> What is phaskell?
14:19:18 <exio4> what's up with that bot?
14:19:33 --- mode: ChanServ set +o geekosaur
14:19:48 --- mode: geekosaur set +q phaskell!*@*
14:20:43 <nh2> Lutin`: the phabricator bot
14:20:44 <Lutin`> Ah, has something to do with https://phabricator.haskell.org/
14:21:21 <stephenmac7> No. Performance is worse now
14:21:56 <Eduard_Munteanu> stephenmac7, have you inlined it?
14:21:59 <stephenmac7> Yes
14:22:25 <Eduard_Munteanu> stephenmac7, how much worse?
14:22:29 <stephenmac7> It's taking about 2.5 instead of 2.2 seconds per 50000 entries
14:22:31 <geekosaur> someone should probably advise them their bot is running wild
14:24:31 <stephenmac7> Eduard_Munteanu: Maybe I should check if it's just the database...
14:24:52 <geekosaur> probably that bot (phaskell) searches for symbols in the ghc source tree. arguably it should do so only in #ghc...
14:25:27 <Eduard_Munteanu> stephenmac7, check the productivity when running with the -s RTS option
14:25:39 <lisbeth> what is the range of characters a string in haskell supports?
14:26:00 <Eduard_Munteanu> lisbeth, all of Unicode
14:26:06 <lisbeth> thank you
14:26:08 <stephenmac7> -s RTS?
14:26:19 <Lutin`> geekosaur: It searches for Phabricator revisions
14:26:38 <Lutin`> i.e. Where is D123? -> https://phabricator.haskell.org/D123
14:26:43 <Eduard_Munteanu> stephenmac7, compile with -rtsopts, then add '+RTS -s' at the end of the cmdline invocation
14:27:00 <geekosaur> what's that "No symbol" thing then?
14:27:25 <stephenmac7> Eduard_Munteanu: Then just stop the program with ctrl+c?
14:27:27 <Lutin`> Because there's no https://phabricator.haskell.org/word64
14:27:29 <Lutin`> etc.
14:27:35 <stephenmac7> Productivity  67.1% of total user, 15.3% of total elapsed
14:27:36 <Lutin`> I assume
14:27:37 --- mode: geekosaur set -q phaskell!*@*
14:27:49 <Lutin`> Where is D321?
14:27:50 <phaskell> D321: Use Data.Map.mergeWithKey - https://phabricator.haskell.org/D321
14:27:50 <phaskell> No symbol 'D321' found anywhere.
14:27:54 <Lutin`> Ah
14:27:57 <stephenmac7> What does that mean?
14:27:58 <Lutin`> strange
14:28:15 <Eduard_Munteanu> > "Where is my bot?"
14:28:17 <lambdabot>  "Where is my bot?"
14:29:08 <Lutin`> Magic
14:29:19 <Eduard_Munteanu> stephenmac7, it might mean it's doing a lot of allocations. Some profiling could help.
14:30:05 <stephenmac7> So, recompile the libraries with profiling?
14:30:07 <Eduard_Munteanu> stephenmac7, now if you run it with -H128m or something like that, does it get any faster?
14:30:13 <stephenmac7> -H128m?
14:30:17 <Eduard_Munteanu> +RTS -H128m
14:30:39 <stephenmac7> No, it does not
14:31:44 <stephenmac7> Just to make profiling possible I'm going to reinstall the libs
14:32:02 <Eduard_Munteanu> stephenmac7, it might help to use longer runs, to be sure you don't get hit by startup time
14:32:20 <stephenmac7> I'm letting it run for about 40 seconds
14:33:14 * hackagebot luthor 0.0.1 - Tools for lexing and utilizing lexemes that integrate with Parsec.  http://hackage.haskell.org/package/luthor-0.0.1 (ZankokuOkuno)
14:33:47 <stephenmac7> Eduard_Munteanu: --enable-executable-profiling, right?
14:34:29 <Eduard_Munteanu> stephenmac7, for your code... for libs you want -p
14:34:41 <stephenmac7> When installing from cabal?
14:34:44 <chrisdone> so i didn't know that @djinn outputted more results than one
14:34:46 <Eduard_Munteanu> Yes.
14:34:56 <chrisdone> until i tried loading the internal package and fuddled with it
14:34:59 <stephenmac7> Just -p?
14:35:07 <Eduard_Munteanu> stephenmac7, yes
14:35:08 <chrisdone> λ> runCmd startState {multi=True} (Query "f" [] (read "b -> (a -> b) -> Maybe a -> b"))
14:35:09 <chrisdone> f :: b -> (a -> b) -> Maybe a -> b
14:35:09 <chrisdone> f a b c = case c of Nothing -> a Just d -> b d
14:35:09 <chrisdone> -- or
14:35:13 <chrisdone> f a _ _ = a
14:35:15 <stephenmac7> Strange... but okay
14:35:17 <chrisdone> \o/
14:36:10 <Eduard_Munteanu> stephenmac7, for the actual GHC flags of your executable, they should go like -prof -auto-all -caf-all
14:38:51 <stephenmac7> This would be the point when I say: I love cabal sandbox
14:45:41 <stephenmac7> Eduard_Munteanu: Done.
14:46:28 <stephenmac7> It's not showing any new info
14:48:15 <stephenmac7> Actually, I got http://lpaste.net/112491
14:49:16 <stephenmac7> at least we know the problem isn't cmbs
14:50:43 <stephenmac7> Eduard_Munteanu: Still there?
14:53:02 <lisbeth> If I am passing along a long piece of data in binary
14:53:11 <lisbeth> it is obviously inefficient to have it in a string like this "101010010110"
14:53:25 <lisbeth> it's better to have a list [True, False, False, True..]
14:53:32 <lisbeth> but I am wondering if there is a better way than that
14:53:35 <lethjakman> hey, I'm kinda confused by the quicksort on the learnyouahaskell
14:53:37 <lethjakman> https://gist.github.com/lethjakman/d361acae45ee111d16a8
14:53:48 <lethjakman> shouldn't the first element of the list always end up in the middle no matter what?
14:53:52 <lethjakman> can anyone explain that?
14:54:18 <stephenmac7> lethjakman: No, smallerSorted can be [] which means that the first element would be the first element
14:54:55 <stephenmac7> [] ++ x ++ xs is equal to x:xs
14:54:56 <lethjakman> but a in smallerSorted is xs, which excludes the first element doesn't it?
14:55:52 <stephenmac7> It does exclude it, but there may be no values smaller than x in xs
14:56:07 <benmachine> stephenmac7: do you mean [x]
14:56:28 <Cale> yes, he does :)
14:56:31 <lethjakman> stephenmac7: what do you mean? because it's an Ord it's automatically ordered?
14:56:43 <lethjakman> perhaps I do, I'm very new to haskell and trying to wrap my head around it.
14:56:49 <Cale> > [] ++ [1] ++ [2,3,4,5]
14:56:50 <lambdabot>  [1,2,3,4,5]
14:56:53 <stephenmac7> benmachine: Where?
14:56:56 <lethjakman> it all seemed to make sense until that bit of code.
14:56:59 <stephenmac7> Oh, yes
14:57:00 <stephenmac7> Sorry
14:57:08 <benmachine> lisbeth: http://hackage.haskell.org/package/vector-0.10.12.1/docs/Data-Vector-Unboxed.html try unboxed Bool vectors
14:57:10 <hexagoxel_> chrisdone: you can enable multi on the djinn commandline as well
14:57:12 <stephenmac7> [] ++ [x] ++ xs
14:57:18 <Rembane> lethjakman: Having an Ord means that it can be ordered.
14:57:32 <Cale> lethjakman: If smallerSorted = [], then smallerSorted ++ [x] ++ biggerSorted is equal to [] ++ [x] ++ biggerSorted, which is equal to [x] ++ biggerSorted
14:57:36 <stephenmac7> lethjakman: Ord means we can use operations like compare and (<)
14:57:54 <Cale> lethjakman: So, it's possible for the first element of the list to end up at the beginning
14:57:56 <lethjakman> stephenmac7: ahhh ok, that makes sense.
14:58:12 <Cale> lethjakman: Similarly, if biggerSorted were empty, then x would end up at the end of the list
14:58:19 <lethjakman> also, how does that list comprehension order...doesn't it just filter out?
14:58:41 <Cale> lethjakman: It just filters, note that the results of each list comprehension are being quicksorted
14:58:50 <stephenmac7> lethjakman: That is then ordered by the next call of quicksort
14:59:18 <lethjakman> but to me it looks like [3,1,4,5,6] would turn into quicksort [1,4] ++ [3] ++ [5,6] no?
14:59:20 <lethjakman> after the first run?
14:59:49 <stephenmac7> No, it would be quicksort [1] ++ [3] ++ quicksort [4,5,6]
15:00:23 <Cale> 4 is usually not considered to be less than 3. ;)
15:00:29 <lethjakman> ohhh the filter on the a is working differently than I was expecting
15:00:31 <stephenmac7> lethjakman: Does 4 satisfy <= 3?
15:00:31 <lethjakman> that's why
15:00:42 <lethjakman> ahah, thank you, that makes quite a bit more sense now
15:00:53 <lethjakman> list comprehensions
15:00:59 <lethjakman> I knew I was missing something
15:01:11 <lethjakman> is learnyouahaskell a considered good resource by the way?
15:01:20 <Cale> lethjakman: Yeah, generally
15:01:27 <stephenmac7> lethjakman: I used Learn you a Haskell, but, to be honest, it's only the first step
15:01:44 <stephenmac7> I would still consider myself a Haskell beginner
15:02:11 <benmachine> LYAH annoyed me by how long it was until you were writing programs, if I recall correctly
15:02:23 <stephenmac7> benmachine: LYAH lacks exercises.
15:02:32 <stephenmac7> Which is essential
15:02:34 <benmachine> but it's still considered to go-to resource for beginners
15:02:42 <benmachine> it's cute and clear and mostly correct
15:02:53 <Cale> Though, you really can get by for a long time just using ghci as a "user interface" to your programs
15:02:54 <stephenmac7> Mostly correct only because it's a tad outdated
15:03:12 <stephenmac7> At least my paper copy is
15:03:23 <Cale> I wonder where BONUS went
15:03:33 <Cale> He disappeared shortly after publishing it
15:04:12 <stephenmac7> Cale: I didn't know that part. Sad... I liked that book
15:04:15 <chrisdone> plot twist: BONUS = _why
15:05:40 <Rembane> Plot: Someone has placed _why-clones all over the wolrd...
15:05:58 <sipa> > BONUS
15:05:59 <lambdabot>  Not in scope: data constructor ‘BONUS’
15:06:54 <stephenmac7> Yes, I wonder about things like that... why do people disappear when they do good things?
15:08:00 <chrisdone> it's like Mary Poppins
15:08:13 <chrisdone> they come to a community and fix problems they see and then take their umbrella and fly away
15:08:26 <geekosaur> wish I knew. seems like everyone takes point on releasing a new xmonad version, shortly thereafter they vanish
15:08:35 <geekosaur> (well, the most recent one just changed their nick...)
15:08:55 <geekosaur> (aaand now you know why we dont release often :p )
15:10:25 <zinfandel> Hey. Is there a tool that can illustrate a structure of the project (I mean hierarchy of modules)? e.g builds UML diagram of modules
15:11:10 <indiagreen> zinfandel: graphmod
15:11:23 <geekosaur> not uml that I know of but doesn't cabal have an option to make a dot graph?
15:11:51 * zinfandel taking a look
15:12:33 <platz> ghc-pkg dot
15:12:44 <geekosaur> mm, maybe not. thought I saw a module graphing option in there somewhere
15:12:51 <zinfandel> graphmod seems like it
15:13:10 <zinfandel> geekosaur: I've found something about making the graph of dependencies with cabal
15:14:12 <zinfandel> platz: ghc-pkg dot is also about dependencies between the packages, not about modules of one package
15:14:26 <platz> ah
15:18:37 <qfjp> hi all
15:18:48 <qfjp> does anyone have a good resource to understand writing a parser in haskell?
15:19:05 <qfjp> i get translating a BNF, cause haskell's syntax is essentially the same
15:19:11 <qfjp> but i can't figure out the lexing step
15:19:35 <qfjp> coming from a yacc & flex background, in case it wasn't obvious by the terminology
15:20:11 <zinfandel> Wow, graphdot is exactly what I need, thanks everyone
15:20:31 <pic_> Can anyone help me with some typing issues?
15:22:18 <Cale> pic_: Yeah, probably, but not if you don't show us your code! :)
15:22:21 <pic_> I hit public on lpast but it doesn't seem to be comming up
15:22:21 <hexagoxel_> qfjp: you know {happy}?
15:22:33 <qfjp> nope?
15:22:40 <Cale> http://lpaste.net/112495
15:22:43 <Cale> ?
15:22:47 <pic_> http://lpaste.net/112495
15:22:48 <pic_> Yes
15:23:44 <qfjp> ah, this seems like a good start, thanks
15:24:11 <Cale> pic_: uh... this definition of fun seems rather incomplete...
15:24:32 <DTSCode> hey everyone... im trying to install cabal v7.6, and am having some issues. i installed this: http://www.haskell.org/ghc/download_ghc_7_6_1#x86_64linux and then ran ./configure, but im getting these errors: http://paste.ubuntu.com/8548811/ can anyone helP?
15:24:35 <Cale> pic_: Do you have a version which actually causes the typechecker to give an error?
15:24:55 <pic_> Err sure I can make one
15:24:56 <qfjp> hm...wait, is happy a standalone parser written in haskell?
15:25:08 <qfjp> I'm looking more for something that I can do in pure haskell
15:25:21 <qfjp> *parser generator
15:25:30 <dcoutts> DTSCode: install libgmp via the ubuntu package tools
15:25:54 <Cale> DTSCode: install the libgmp3c2 and libgmp3-dev packages
15:26:03 <DTSCode> ok ty.
15:26:04 <dcoutts> DTSCode: also, check if you can't get that version of ghc via ubuntu anyway
15:26:09 <Cale> Actually, I don't know for sure if you need libgmp3-dev
15:26:13 <DTSCode> well im not in ubuntu
15:26:18 <DTSCode> and im using pacman
15:26:27 <DTSCode> which only has 7.8
15:26:37 <Cale> pic_: It's just a little unclear what it is that you're trying to write :)
15:27:27 <Cale> pic_: If you match against a Baz constructor, then on the right hand side of that match, it should know that the value was of type Bar True
15:28:28 <Cale> pic_: Of course, if you match against Buz, then there's no such guarantee
15:28:56 <DTSCode> is there any other way to get it? pacman doesnt have it
15:28:57 <pic_> Right so I need some way of making that okay
15:29:03 <DTSCode> or the repos doesnt
15:29:18 <pic_> I want to be able to go from Bar False -> Bar True
15:29:21 <hexagoxel_> qfjp: but it generates haskell code.. what do you mean by "pure haskell"?
15:29:49 <qfjp> well, I want to write the haskell code...
15:29:53 <qfjp> not have it generated
15:29:54 <pic_> I could make some other function which just rebuilds the object but that seems like the wrong thing to do
15:30:01 <qfjp> I'm trying to do it as an exercise to teach myself haskell
15:31:18 <benzrf> qfjp: why not Parsec
15:31:22 <geekosaur> qfjp, parsec / attoparsec?
15:31:28 <Cale> DTSCode: It'll probably work to install gmp version 6 and make a fake symlink from libgmp.so.6.something to libgmp.so.3 in /usr/lib or wherever
15:31:48 <Cale> DTSCode: Of course, getting GMP 3 would probably be a bit better :P
15:31:56 <qfjp> I've been looking around, but I can't find any simple examples
15:32:10 <geekosaur> happy doesn't get a lot of use, although ghc uses it because it's complex enough that optimizing a parsec parser is difficult, but parsec is much more commonly used
15:32:25 <qfjp> like, if i have 'data exp = Int | Add Exp Exp', how would I use parsec to actually evaluate a string?
15:32:38 <DTSCode> *sigh* this guy makes it so hard to build this software. thanks for the help guys. guess im going to have to build gmp from source
15:33:29 <platz>  /quit
15:33:49 <Cale> DTSCode: Why are you trying to install a somewhat old version of GHC?
15:34:06 <DTSCode> because the code doesnt work with 7.8
15:34:13 <Cale> DTSCode: which code?
15:34:29 <Cale> Probably any change which would need to be made should be fairly easy to make
15:34:31 <DTSCode> the building system for geordi
15:34:56 <DTSCode> also, i dont know haskell so i wouldnt be able to make the changes
15:35:43 <Cale> What error do you get when you try a more recent GHC?
15:35:57 <DTSCode> uhhh hold on i have a so post about it
15:36:11 <pic_> Nevermind I fixed it
15:36:16 <pic_> Thanks for the help though
15:36:34 <DTSCode> http://stackoverflow.com/questions/26329959/building-the-haskell-portion-of-geordi-and-ran-into-strange-errors
15:37:37 <DTSCode> oh hold on someone else answered on it
15:38:00 <Cale> Those answers kinda suck... :)
15:38:12 <DTSCode> oh :(
15:38:22 <Cale> Well, okay
15:38:31 <Cale> Just using an older GHC would probably work
15:38:39 <Cale> but fixing the actual problems with the code would be better
15:38:44 <Cale> Can I get this code?
15:38:48 <DTSCode> sure
15:38:56 <DTSCode> its linked in the so post
15:39:02 <Cale> ah, okay
15:39:10 <DTSCode> its linked in the so post
15:39:12 <DTSCode> oops
15:39:16 <geekosaur> geordi's the c++ bot, no? should be public
15:39:18 <qfjp> actually, I did find this
15:39:23 <qfjp> http://rosettacode.org/wiki/Arithmetic_evaluation#Haskell
15:39:31 <DTSCode> https://github.com/Eelis/geordi
15:39:42 <DTSCode> geekosaur: correct. thats the repo
15:39:42 <qfjp> but, the actual parts dealing with parsec are incomprehensible
15:39:47 <qfjp> (to me)
15:41:10 <geekosaur> qfjp, the original parsec paper is pretty readable although some details have changed since it was written
15:42:42 <qfjp> whats the original?
15:42:54 <qfjp> you mean this one: http://research.microsoft.com/pubs/65201/parsec-paper-letter.pdf
15:42:57 <qfjp> ?
15:43:04 <benzrf> qfjp: d o you understand how IO works in haskell
15:43:16 <qfjp> A bit
15:43:24 <benzrf> qfjp: i.e. io actions are programs to  be run, u can combine em with monadic and applicative and functorial interfaces?
15:43:34 <geekosaur> qfjp, trying to find it. used to be prominent in the haddock, sigh
15:43:36 <qfjp> I should say, I can write it but I may not understand how monaads work
15:43:41 <qfjp> monad
15:43:44 <benzrf> qfjp: oh geez
15:43:47 <geekosaur> http://book.realworldhaskell.org/read/using-parsec.html may be interesting
15:43:49 <benzrf> qfjp: well do ytou understand functors
15:43:59 <geekosaur> also https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
15:44:05 <qfjp> in a mathematical sense?
15:44:06 <geekosaur> and, don't be afraid of monads, they don't bite
15:44:15 <geekosaur> you don't need the mathematical sense
15:44:18 <benzrf> qfjp: eithre
15:44:20 <benzrf> qfjp: which
15:44:22 <qfjp> thats all i have
15:44:28 <Cale> DTSCode: Okay, managed to fix it, I think. Just letting the rest of the build go.
15:44:47 <benzrf> qfjp: you understand the maths sense?
15:44:50 <geekosaur> for all intents and purposes, the only monad that is "strange" is IO, and that's because it's IO, not because it's a monad
15:44:55 <DTSCode> Cale: thanks so much!
15:45:11 <qfjp> I have a light category theory background
15:45:33 <qfjp> but I'm not used to seeing it in haskell
15:46:16 <benzrf> qfjp: oh it's not that bad!
15:46:23 <benzrf> Hask is EXTREMELY similar to Set
15:46:26 <benzrf> if you ignore bottom
15:46:56 <benzrf> qfjp: do you Grasp typeclasses?
15:47:16 <Cale> DTSCode: http://cale.yi.org/share/ErrorFilters.hs
15:47:29 <qfjp> as arrows?
15:47:58 <qfjp> that much I could guess
15:48:03 <DTSCode> cale: so i just switch that one file with the other one and it should build fine?
15:48:07 <benzrf> qfjp: no... they are not particualrly categorical in nature!
15:48:08 <Cale> yes
15:48:15 <benzrf> qfjp: just as language features i mean
15:48:15 <DTSCode> :D ty
15:48:35 <qfjp> then no
15:48:59 <Cale> DTSCode: If you're at all interested in what the problem was...
15:49:08 <benzrf> qfjp: OK
15:49:08 <DTSCode> sure
15:49:13 <DTSCode> i can tell the guy that wrote it
15:49:20 <benzrf> qfjp: sounds like we have a lot to go over... you're definitely going to need to understand this stuff!
15:49:31 <benzrf> qfjp: care to join us in #haskell-beginners
15:49:32 <benzrf> ?
15:49:34 <Cale> class Parser p st a | p → st, p → a  -- this says that for each instance of the class Parser, the type p must uniquely determine the types st and a
15:49:35 <qfjp> haha yeah, I figured, I just didn't know a good place to start
15:49:56 <Cale> However, he had some instances like:  instance Parser String st String
15:50:12 <Cale> which put a variable in for st, meaning that st could be any type at all
15:50:14 <qfjp> the recursive stuff is easy enough, but anaything involving data & monads is beyond me at the moment
15:50:25 <Cale> Old versions of GHC had a bug which would accept this
15:50:38 <qfjp> I'll take a look at the links geekosaur, it seems like theyre digestible enough
15:50:44 <DTSCode> ah. thanks cale. ill let eelis know
15:50:48 <Cale> But it really makes no sense -- it violates the condition which the programmer specified
15:50:54 <benzrf> qfjp: bls join #haskell-beginners!! it is very good for beginners and
15:50:58 <Cale> (because you could use different types for st)
15:50:59 <benzrf> more indepth explanations
15:51:25 <qfjp> i'll take a look
15:51:37 <geekosaur> hm
15:51:37 <Cale> So I just changed those to () (the empty tuple type) because he probably wasn't using the state type anywhere which is why his code just happened to work anyway.
15:51:38 --- mode: geekosaur set -o geekosaur
15:51:41 <geekosaur> whoops
15:52:38 <DTSCode> :D: thanks cale! you made my life easier
15:53:17 * hackagebot sodium 0.11.0.1 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.11.0.1 (StephenBlackheath)
15:58:17 * hackagebot orgmode-parse 0.0.1.0 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.1.0 (ParnellSpringmeyer)
15:58:19 * hackagebot orgmode-parse 0.0.1.1 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.1.1 (ParnellSpringmeyer)
16:21:47 <SrPx> Is it possible to implement structural equality test on lambda calculus?
16:22:26 <SrPx> That is, eq term term = true if both terms are structurally equal... ? I guess no, right?
16:23:01 <Cale> *Structurally* equal? That should be doable...
16:23:03 <chrisdone> why not?
16:23:46 <Cale> It's once you start having to deal with beta equivalence that things get tough
16:23:49 <chrisdone> provided you're not doing equality based on names
16:24:36 <chrisdone> \x.\y.x = \y.\x.y
16:26:07 <Cale> Yeah, it's easy enough to deal with alpha equivalence if you like by putting them into some kind of representation based on De Bruijn indices.
16:29:41 <SrPx> chrisdone: I mean, for example: (foo (λa.λb.a b) (λa.λb.a b)) <- suppose that "foo" is the implementation of some function that should return true if both arguments are identical.
16:30:11 <SrPx> How could "foo" be implemented. It doesn't seems like it can.
16:30:34 <orb__> Depends on whether foo has to live in the lambda calculus, or if it can see the AST.
16:30:58 <SrPx> That is, I'm not asking if you can implement an interpreter of lambda calculus, and then check terms for equality. I'm asking if, within lambda calculus itself, you can encode a function that figures out wether 2 terms are identical
16:31:04 <benzrf> SrPx: heck no!
16:31:12 <benzrf> at least
16:31:14 <benzrf> not as far as i know :P
16:31:24 <SrPx> benzrf: no = it is impossible, right?
16:31:26 <orb__> SrPx, Oh, ok.
16:33:50 <benzrf> SrPx: i think so!
16:34:06 <SrPx> okay, thanks :)
16:38:31 <benzrf> @google lambda calculus equality test
16:38:31 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
16:38:32 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
16:38:54 <Lutin`> SrPx: https://groups.google.com/forum/#!topic/comp.lang.functional/_5mxyv6it8c
16:42:57 <SrPx> Lutin`: I want your googling skills. Great thread, thanks...
16:43:07 <contiver> Hello fellow Haskellers, looking for some help here. Is there a way to pattern match on a "generic" data type. What I need is pattern matching in a data type that I know its constructor takes 4 values, but I don't know what data type it is...
16:46:14 <contiver> the thing is I'm modelling different css data types (for instance, the margin, and border-width properties), and I'm finding myself copy pasting the show function code and just modifying a string, leaving the rest the same. I'd rather be able to reuse the code if possible, but I'm not sure how to.
16:48:19 * hackagebot lens-text-encoding 0.1.0.0 - Isomorphisms and prisms for text <=> bytestring conversions  http://hackage.haskell.org/package/lens-text-encoding-0.1.0.0 (IanDuncan)
16:48:35 <begriffs> Anyone know how to redirect to https in a wai app accessed via http? I'm having trouble getting the host name to construct the redirect url.
16:48:50 <Dylann> hi
16:53:21 * hackagebot growler 0.3.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.3.0 (IanDuncan)
16:59:20 <pjdelport> contiver: http://hackage.haskell.org/package/syb perhaps?
17:00:16 <contiver> pjdelport: I'll take a look at that, thanks!
17:09:09 <contiver> pjdelport: sounds like this is exactly what I'm looking for :). Just a question, it says that it's "readily available on GHC", but later talks about a split, and my module isn't compiling in ghci if I add "deriving (Data, Typeable)", I guess I should get it from Hackage?
17:10:36 <solatis> hmmm i'm trying to add a simple logging mechanism to my application -- how can i decide what the best library to use it? there seem to be many (fast-logger, monad-logger, wai-logger, etc), but i'm having trouble finding out which one to use
17:11:04 <solatis> i feel monad-logger seems to be the most 'basic' one
17:12:00 <contiver> pjdelport: sorry, my bad, it's been a while since I used Haskell, I was lacking the Data.Data import lol. Thanks for the help :)
17:12:09 <solatis> anyway logging in haskell seems to be way more complicated than in any other language i've encountered :)
17:13:02 <Lutin`> SrPx: Fourth link when searching for "lambda calculus equality" has a reference to that discussion
17:13:13 <solatis> people claiming 'logging' in haskell doesn't make any sense since there is no sequential execution of operations, etc
17:13:29 <solatis> but i want my logging output, ghc be damned
17:14:08 <Lutin`> solatis: What kind of logging?
17:15:04 <solatis> Lutin`: well i'm used to log4j-kind of logging -- it needs to have file output, different logging levels, and it would be nice if i could timestamp and/or 'trace' where the log messages are generated
17:15:25 <solatis> but at the moment anything better than putStrLn will do
17:15:42 <solatis> i'm just trying to figure out how all the different logging frameworks fit into the whole monadic environment
17:15:54 <kadoban> solatis: Yeah, but what kind of code are you trying to add logging to? Is it all in IO or some imperitive monad?
17:16:20 <solatis> it's a very distributed, actor-based IO heavy application
17:16:33 <solatis> at the moment about 20 different processes connecting to each other
17:16:51 <solatis> and they're all transforming input streams to output streams
17:17:30 <solatis> so the code i try to add logging to mostly lives inside an IO monad
17:17:41 <Lutin`> solatis: Have you seen http://hackage.haskell.org/package/hslogger
17:17:57 <solatis> i read about it yes
17:18:04 <Lutin`> It even has log4j output support
17:18:50 <solatis> i'll take a look at it
17:19:33 <Lutin`> The docs for it give an excellent overview
17:19:47 <solatis> hmmmm am i correct that it seems to be using a global context?
17:20:03 <solatis> http://hackage.haskell.org/package/hslogger-1.2.4/docs/System-Log-Logger.html#g:10
17:20:51 <Lutin`> There is a root logger yes, as the docs say
17:21:10 <solatis> yeah
17:21:18 <solatis> that seems very, very similar to what i'm used to
17:21:35 <solatis> how does it work across different threads? as in, is it safe to assume it's thread-safe?
17:22:55 <solatis> gah someone should write a comparison between all these frameworks
17:23:32 <solatis> so far i have monad-logger, hslogger, fast-logger and wai-logger,
17:23:36 <geekosaur> syslog should be threadsafe, as each log message is formatted and sent as a single packet
17:23:57 <geekosaur> except linux uses tcp so single packet may not be guaranteed, come to think of it
17:24:54 <RchrdB> Eh? I thought the rfc mandated udp for syslog.
17:25:58 <solatis> that would be even worse :)
17:27:05 <Lutin`> It has to support UDP
17:27:13 <Lutin`> But many also support TCP
17:27:14 <solatis> here i read that TLS transport is required, but UDP *should* be implemented
17:27:25 <solatis> https://tools.ietf.org/html/rfc5424
17:28:13 <solatis> anyway, bikeshed
17:28:23 <solatis> i'm gonna give hslogger a go
17:35:50 <geekosaur> the RFC specifies a syslog server port. it says nothing about local transport (/dev/log by tradition on unix)
17:36:10 <geekosaur> (although it moves around on different unixes...)
17:40:53 <Axman6> anyone worked with XML much? I need to do some modifications to a rather large XML doc and hexpat seems like a good plakce to start, but I'm not sure if I'm mising a nice way of describing paths in the document. hexpat-lens looks somewhat promising, but I've never really used lenses and was hoping for insight from others
17:43:32 <orb__> Axman6, lenses are great.  You can ask me some lens questions.  I don't know about hexpat-lens in particular.
17:44:40 <Axman6> ok, sounds good. I'll give it a go and see how I go
17:45:20 <CrazyM4n> FRP is the most terrible thing to learn
17:46:04 <CrazyM4n> Scratch that, it's not really a hard concept, but the syntax for all the FRP libraries are terrible
17:46:06 <Axman6> orb__: so, what on earth is an optic?
17:46:23 <CrazyM4n> Does anyone have any good examples for elerea?
17:47:13 <CrazyM4n> I've already looked at the ones in the package elerea-examples, but they deal a lot into OpenGL, which I'm not well versed in
17:47:20 <orb__> Axman6, anything that satisfies the Optic laws?  See http://hackage.haskell.org/package/lens-4.0.7/docs/Control-Lens-Type.html#t:Optic
17:48:14 <Axman6> that doesn't tell me much
17:48:43 <orb__> Yeah, sorry, just reading up.
17:49:25 <orb__> Looks like it's a generalization.
17:50:28 <Axman6> well, seems hexpat-lens doesn't work, and I can't tell form the cabal output what package is actually the problem
17:50:39 <orb__> Axman6, hmm, ok.
17:51:03 <orb__> Yeah, optic looks like it's the generalization of the lenses.  Hmm, I used a different lens package.
18:00:15 <michaelt> Axman6: hexpat-lens had bad upper bounds, maybe this? https://github.com/michaelt/hexpat-lens
18:05:01 <CrazyM4n> Is there an easy way to get constant input from the keyboard from the terminal?
18:05:10 <CrazyM4n> Without pressing enter or anything
18:05:37 <michaelt> hGetContents stdin?
18:05:53 <simpson> What's the best package from which to obtain the Mu type?
18:06:07 <CrazyM4n> That could work, thanks
18:06:43 <CrazyM4n> Could there be a way to make it so that when you pressed a key it didn't show up?
18:06:48 <CrazyM4n> I think that'd be impossible
18:07:00 <CrazyM4n> Wouldn't it
18:07:45 <michaelt> you mean, the user doesn't see what they're typing?
18:07:45 <geekosaur> what?
18:08:05 <fresheyeball> hey folks
18:08:13 <CrazyM4n> As in, if I were to do type into a program in the terminal, the text wouldn't show up
18:08:17 <geekosaur> on POSIX this is termios, turn off echo and canon, set vmin 1 vtime1
18:08:23 <geekosaur> windows has its own ways
18:08:38 <CrazyM4n> In windows it's @echo off
18:08:44 <fresheyeball> I just put a fresh install of haskell on an ubuntu vm
18:08:50 <geekosaur> that's batch files not keyboard input
18:08:51 <CrazyM4n> But is there a portable way to do it through haskell?
18:08:51 <fresheyeball> and can't install anything with cabal
18:08:56 <fresheyeball> http://stackoverflow.com/questions/20769183/cabal-update-failed-due-to-out-of-memory
18:09:03 <CrazyM4n> Well, in a batch file if you do @echo off it does that effect
18:09:06 <CrazyM4n> So that's what I'm talking about
18:09:08 <michaelt> fresheyeball: is cabal in $PATH
18:09:19 <geekosaur> no, it stops cmd.exe from echoing out commands before running them
18:09:22 <michaelt> fresheyeball: I mean, does cabal --version say something, for example
18:09:41 <fresheyeball> /usr/bin/cabal
18:09:45 <fresheyeball> cabal-install version 1.16.0.2
18:09:47 <fresheyeball> using version 1.16.0 of the Cabal library
18:09:53 <CrazyM4n> Well I haven't used batch in a while now, so sorry that I don't remember how it works
18:09:55 <michaelt> fresheyeball: did you do 'cabal update'
18:10:00 <fresheyeball> yes
18:10:09 <michaelt> fresheyeball: i guess it tells you if it needs it...
18:10:14 <CrazyM4n> But I assume there's no portable way to make keyboard input into the terminal not show up in haskell
18:10:16 <geekosaur> anyway portable is not a thing for terminal I/O, windows would do its own thing no matter what
18:10:25 <CrazyM4n> I see. That's kinda sad
18:10:36 <michaelt> fresheyeball: what does it say when you do 'cabal install pony' or whatever
18:10:38 <geekosaur> there may be a library (aside from the obvious like vty)
18:10:52 <fresheyeball> cabal update
18:10:54 <fresheyeball> Downloading the latest package list from hackage.haskell.org
18:10:56 <fresheyeball> cabal: out of memory (requested 2097152 bytes)
18:11:05 <michaelt> hmmmmm.
18:11:33 <fresheyeball> http://stackoverflow.com/questions/20769183/cabal-update-failed-due-to-out-of-memory
18:11:36 <fresheyeball> this looks promising
18:11:39 <CrazyM4n> vty could work
18:11:43 <CrazyM4n> eh
18:11:46 <fresheyeball> vty?
18:11:54 <geekosaur> fresheyeball, itnot your question
18:12:00 <geekosaur> it's not about your question
18:12:03 <fresheyeball> sorry
18:12:25 <simpson> Okay, it looks like the type in question is called Fix and it's in Data.Functor.Foldable in recursion-schemes.
18:12:54 <michaelt> fresheyeball: dunno, what version of ghc are you using, btw?
18:13:33 <fresheyeball> ghc --version
18:13:35 <fresheyeball> The Glorious Glasgow Haskell Compilation System, version 7.6.3
18:13:40 <fresheyeball> its a completely fresh install
18:13:46 <fresheyeball> sudo apt-get install ghc
18:13:50 <fresheyeball> then this error
18:14:10 <fresheyeball> cabal update
18:14:11 * geekosaur would suspect the tarball is corrupt for some reason. note that "some reason" can be something like a captive portal interfering with the transfer and trying to hand you random html or something
18:14:13 <fresheyeball> Downloading the latest package list from hackage.haskell.org
18:14:15 <fresheyeball> cabal: out of memory (requested 2097152 bytes)
18:14:47 <geekosaur> but I'd need a network trace or something to verify that, and, well, windows
18:16:15 <michaelt> fresheyeball: this will also be an old cabal. there was formerly a dumb laziness mistake, which made cabal update take forever; I don't know if it also entailed excessive memory use.
18:16:39 <fresheyeball> well I can't update cabal
18:18:25 * hackagebot hadoop-rpc 0.1.0.0 - Use the Hadoop RPC interface from Haskell.  http://hackage.haskell.org/package/hadoop-rpc-0.1.0.0 (JacobStanley)
18:21:00 <robbie> Hi, I am working with some code that generates a  Haskell file (code at https://github.com/rgleichman/roshask/blob/master/src/executable/Gen.hs). It currently just uses ByteStrings, is there a better way to do this?
18:21:29 <robbie> Working link: https://github.com/rgleichman/roshask/blob/master/src/executable/Gen.hs
18:23:26 * hackagebot hadoop-tools 0.3 - Fast command line tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.3 (JacobStanley)
18:27:51 <michaelt> robbie: ByteString.Char8 isn't going to faithfully represent characters beyond the obvious ones, of course
18:28:46 <fresheyeball> does anyone know how to install an old version of ghc?
18:28:53 <fresheyeball> it seems like that might by my only hope
18:29:01 <michaelt> robbie: I see, but it permeates the whole package, this Char8 business...
18:29:54 <chirpsalot> fresheyeball: try nix?
18:30:07 <fresheyeball> nix?
18:30:08 <chirpsalot> http://nixos.org/nix/
18:31:05 <fresheyeball> nix looks cool
18:32:15 <chirpsalot> It's very cool. Handles Haskell packages very well.
18:33:41 <chirpsalot> fresheyeball: either way, you can try it with no harm done. It installs everything in its own nix directory.
18:37:33 <michaelt> fresheyeball: http://hackage.haskell.org/index.tar.gz is the thing you are looking for. It goes into .cabal/packages/hackage.haskell.org/00-index.tar when decompressed
18:38:20 <michaelt> for some reason the download is suspiciously slow today, but I think that can't be relevant to your problem.
18:39:13 <fresheyeball> what do I do with that?
18:39:59 <michaelt> Darn, it's more complicated, I just clicked on the link at the bottom of the http://hackage.haskell.org/ page, I gave the wrong url above
18:40:33 <fresheyeball> hu
18:40:46 <fresheyeball> I don't understand what you are getting at
18:40:47 <michaelt> fresheyeball: no, its http://hackage.haskell.org/packages/index.tar.gz
18:41:36 <michaelt> does $HOME/.cabal/packages/hackage.haskell.org exist yet?
18:41:51 <fresheyeball> let me check
18:42:29 <michaelt> fresheyeball: I am basically translating the instructions that Daniel Wagner was giving on StackOverflow. He says, in this case, dont use cabal install to do the downloading ..
18:42:41 <robbie> michaelt: Thank you, but I don't care too much about character reproduction. I was more wondering if there is a more organized way of putting the file together and perhaps checking that the syntax is correct.
18:43:09 <michaelt> robbie: i see.
18:43:11 <fresheyeball> ok it exists
18:43:34 <fresheyeball> I download the file and place it in there?
18:48:59 <michaelt> fresheyeball: yes, but you need to decompress the tar.gz to .tar  it seems.  the name of the tar file should be 00-index.tar ... I think
18:52:15 <fresheyeball> so uncompress as 00-index.cache ?
18:52:46 <jTT> good morning (or where ever you are). I am trying to parse utf8 encoded .html files with chinese characters on them. I am using Conduit’s sourceFile as so: (sourceFile f :: MonadResource m => C.Producer m Text) and the sink those as so $$ foldlE (\n x -> if isChinese x then n + 1 else n) 0.  This is counting the number of Chinese characters (jsut to start things of). isChinese has type signature isChinese :: Char ->  Bool. But when I am trac
18:52:47 <jTT> chinese characters are shown as ‘\213’ or the likes. I was under the impression that Char is utf8 encoded and should be able to deal with chinese characters. Can anyone help?
18:53:20 <michaelt> fresheyeball: hm, I have 00-index.cache	00-index.tar	 00-index.tar.gz
18:56:49 <fresheyeball> so I renamed the .tar file
18:58:51 <orb__> jTT, how are you displaying your Chars, with putStr or with something like print or show?
18:59:13 <orb__> Oh, conduit.
18:59:47 <jTT> isChinese x = ( if fromEnum x  19968 || fromEnum x < 40959 then True else False)
18:59:50 <jTT> sry
18:59:56 <jTT> ( if fromEnum x  19968 && fromEnum x < 40959 then True else False)
19:00:03 <fresheyeball> ugh, I'm still blocked and have no idea what to do
19:00:22 <jTT> orb_: and yeah, it’s all in a conduit
19:01:31 <michaelt> fresheyeball: here is my 00-index.cache  http://sprunge.us/iQVS after updating.  the lines at the top beginning  pref-ver:blah-blah-0.0 are specific to me, I guess they can be deleted.
19:02:31 <michaelt> fresheyeball: so i think you need that and 00-index.tar if i understand. This is admittedly a little bizarre.  My secret belief is that you will do better with the recent ghc from the ghc page and a cabal you build with it...
19:03:48 <fresheyeball> michealt, that may have worked!
19:03:56 <fresheyeball> cabal install cabal-install is cabal installing!
19:05:30 <George_> could someone clarify what the precision of a numeric type is?
19:06:04 <michaelt> fresheyeball: of course there may be a different problem with that, but at least we are making progress ....
19:06:45 <haasn> George_: What numeric type?
19:07:56 <jTT> this is so frustrating. Char is supposed to use utf8 but returns only garbage with chinese characters
19:07:57 <George_> for example: how is Double have more precision than Float?
19:08:28 * hackagebot linkedhashmap 0.1.0.0 - Persistent LinkedHashMap data structure  http://hackage.haskell.org/package/linkedhashmap-0.1.0.0 (abasko)
19:08:53 <fresheyeball> ok so after much compiling that looked good and successful
19:08:55 <fresheyeball> ghc: out of memory (requested 2097152 bytes)
19:08:57 <fresheyeball> Failed to install Cabal-1.20.0.2
19:08:59 <fresheyeball> cabal: Error: some packages failed to install:
19:09:01 <fresheyeball> Cabal-1.20.0.2 failed during the building phase. The exception was:
19:09:03 <fresheyeball> ExitFailure 1
19:09:05 <fresheyeball> cabal-install-1.20.0.3 depends on Cabal-1.20.0.2 which failed to install.
19:09:07 <fresheyeball> but then this
19:09:24 <haasn> George_: Float and Double are “just” IEEE floating points; it's not specific to Haskell. You could try searching for information about “IEEE floating point numbers” to understand how they work
19:09:53 <haasn> George_: But the bottom line is that Double uses twice as many bits to store information as Float uses, so you get more precision
19:10:36 <George_> Oh. Thanks for clarifying that.
19:11:04 <George_> I'll make sure to read up on my types!
19:11:30 <SrPx> Hello, would anyone with mathematica knowledge kindly translate the NthElegantCombinator function here to Haskell? I don't understand the syntax: http://imgur.com/PpSxaiR
19:13:24 <michaelt> fresheyeball: hm, it is a fairly gigantic build. there are ways to control how much memory ghc demands, these can be passed cabal-install but I don't know the details.
19:13:51 <michaelt> fresheyeball: in any case, you can use this cabal-install for most things, it may not have, e.g. the most advanced sandboxing or whatever...
19:14:08 <michaelt> fresheyeball: does it say anything with 'cabal sandbox --help
19:16:32 <michaelt> fresheyeball: I hope it isn't that your vm is just supplied with too little memory for Dear Compiler
19:18:12 <SrPx> also, can I have a "where" clause span 2 declarations of the same function?
19:19:21 <Hafydd> I think not. You probably need to use a case expression for that.
19:24:56 <jTT> can someone help me with this message? It appears I am getting a UTF.Bytestring as desired, but wrapped in somehting i don’t understand:     Expected type: UTF.ByteString
19:24:56 <jTT>       Actual type: mono-traversable-0.6.2:Data.MonoTraversable.Element
19:24:57 <jTT>                      UTF.ByteString
19:25:15 <michaelt> fresheyeball: cabal install pony --ghc-options="+RTS -M30M" seems to work but if I reduce to M20M it fails since it needs more.
19:25:48 <michaelt> jTT: it could be Lazy vs. strict
19:26:02 <jTT> hmm k
19:26:58 <michaelt> http://hackage.haskell.org/package/utf8-string-0.3/docs/src/Data-ByteString-UTF8.html is using regular (strict) ByteString
19:28:09 <jTT> can i force my input bytestring to be strict?
19:28:36 <michaelt> jTT: wait, Element UTF.ByteString = Word8
19:28:50 <jTT> oh, thats a problem
19:28:52 <jTT> thanks
19:29:03 <jTT> i need utf-8 char sets
19:29:12 <jTT> and word 8 is 8 bit only right?
19:29:18 <michaelt> jTT: so, it looks like it's saying you gave it a ByteString where it wanted a Word8
19:29:21 <geekosaur> ByteString is the wrong thing to use then
19:29:32 <geekosaur> Word8 is the thing a ByteString is made of
19:29:47 <jTT> ah! thanks geekosaur
19:30:02 <geekosaur> which is why Element ByteString is Word8
19:30:33 <jTT> so I alternatively can use conduit’s source file to return Text. Is it correct that Text is made of Chars that are utf8 encoded?
19:30:40 <geekosaur> now, perhaps the question is: do you need actual UTF8 (Unicode codepoints encoded into a Word8-compatible form) or Unicode codepoints (use Data.Text instead of ByteString)?
19:30:56 <geekosaur> do you understand the difference?
19:30:56 <jTT> I really need utf8 as I am trying to parse chinese characters
19:31:07 <geekosaur> no, that is not clear
19:31:25 <geekosaur> UTF8 can fit into a ByteString fine; it encodes Unicode codepoints in a form compatible with ByteString
19:31:34 <dfeuer> jTT, the fact that your input may be UTF8 does not mean you have to deal with UTF8.
19:31:53 <dfeuer> Data.Text exists to prevent you from having to deal with UTF8.
19:32:02 <jTT> ok, so my idea is to count occurrances of a certain chinese charater in an html file
19:32:08 <geekosaur> but to reconstitute the codepoints you will need to decode... otoh if all you're doing is passing it around. UTF8 is a fine transfer format and you do not need to care, ByteString will work fine
19:32:33 <jTT> and I thought easiest would be to use fromEnum on a Char to get the Integer value of the utf8 set
19:32:41 <geekosaur> please note the differnece between UTF8 and Unicode codepoints. it is very important
19:32:45 <geekosaur> no
19:32:51 <geekosaur> you get the Integer value of a *codepoint*
19:32:54 <stephenmac7> I'm having trouble statically linking
19:32:55 <jTT> and see if it matches the chinese char im looking for (or is within the range of chinese chars)
19:32:57 <stephenmac7> /usr/bin/ld: cannot find -lgmp
19:33:00 <dfeuer> No, no, no.
19:33:07 <geekosaur> this will be three or more Word8-s in UTF8
19:33:46 <jTT> ok, i guess im in over my head
19:33:48 <geekosaur> if you want to work with codepoints, so you can do that fromEnum thing, use Data.Text
19:33:51 <dfeuer> jTT, slow down.
19:33:56 <geekosaur> Unicode confuses just about everyone
19:34:21 <stephenmac7> jTT: If you really care, try http://www.joelonsoftware.com/articles/Unicode.html
19:34:22 <geekosaur> it's inevitable because the network is based on octets (Word8 in Haskell)
19:34:32 <dfeuer> UTF8 is an encoding of Unicode that is a common interchange format, but not a very good format for thinking about.
19:34:38 <geekosaur> so anything outside the range 0-255 *must* be transport encoded. the most common transport encoding is UTF8
19:35:11 <geekosaur> (actually outside 0-127 because 128-255 is used by the encoding)
19:35:29 <stephenmac7> So, no help with static linking?
19:35:42 <geekosaur> it's difficult and complex and annoying, but the network uses Word8 and there's no way around it but weird encoding tricks
19:35:49 <jTT> i see
19:35:50 <stephenmac7> Guess people are more enthusiastic about haskell than ghc :)
19:36:02 <orb__> There's Haskell besides ghc?
19:36:04 <dfeuer> If you need to process things piece by piece, you generally want to deal with something more like UTF-32, which is pretty much what you can do with Data.Text. But then there are also some other things you might want to do, and Data.Text will help you with that too.
19:36:05 <geekosaur> stephenmac7, there isn't nearly enough information to help you
19:36:21 <stephenmac7> jTT: I would suggest learning more about unicode, you'll run into it again, I promise
19:36:30 <geekosaur> can I assume from your nick that you are on OS X? the next question would be where you got the compiler from
19:36:36 <stephenmac7> geekosaur: Basically, I'm getting a bunch of linker errors.
19:36:37 <jTT> So I am using this to create a conduit: sourceFile f :: MonadResource m => C.Producer m Text)
19:36:41 <dfeuer> stephenmac7, you haven't said what you're trying to do or what problem you're having.
19:36:45 <geekosaur> ^
19:36:46 <stephenmac7> I'm on linux and got it from my package manager
19:37:04 <dfeuer> What version is it?
19:37:09 <jTT> And should work through the file, f, element by element, no?
19:37:21 <stephenmac7> I'm trying to statically compile an executable with -funbox-strict-fields -O2 -optl-static
19:37:29 <geekosaur> then you presumably need to install the static library from your package manager. but "linux" is not very enlightening either as the answer differs between rh/centos/sl, suse, debian/ubuntu/mint, arch, etc.
19:37:33 <stephenmac7> GHC 7.8.3
19:37:41 <stephenmac7> Arch linux
19:37:41 <dfeuer> jTT, you usually want to abstract away from "bytes in a file".
19:37:57 <stephenmac7> Linux archdesktop 3.16.3-1-ARCH #1 SMP PREEMPT Wed Sep 17 21:54:13 CEST 2014 x86_64 GNU/Linux
19:38:15 <geekosaur> urk
19:38:31 <dfeuer> stephenmac7, people usually like to see stuff put up on lpaste, with what you did and what your errors were.
19:38:37 <geekosaur> https://bbs.archlinux.org/viewtopic.php?id=172092
19:38:58 <geekosaur> note reference to their intent to kill off static libs entirely; arch may not be the platform for you if you need them
19:39:00 <Hijiri> maybe it's looking for the i386 libgmp
19:39:15 <stephenmac7> Hm. They remove the static libs?
19:39:21 <Hijiri> idk
19:39:24 <geekosaur> read the url I just sent
19:39:27 <Hijiri> I had issues trying to compile ghc too
19:39:56 <stephenmac7> It doesn't look like it.
19:40:20 <stephenmac7> dfeuer: That was one line, which hardly constituted using lpaste
19:40:21 <geekosaur> https://www.archlinux.org/todo/remove-static-libraries/
19:40:49 <geekosaur> which according to the other page includes instructions for re-enabling them
19:41:46 <stephenmac7> Hm. It doesn't look like it.
19:42:24 <geekosaur> A few packages genuinely need their static libraries, so these need options=('staticlibs') added to their PKGBUILDs.
19:42:32 <geekosaur> since I am apparently reading things to you
19:42:37 <dfeuer> What's Arch have against static libs?
19:42:46 <stephenmac7> That's what I was wondering
19:42:54 <geekosaur> likewise from the other URL: In /etc/makepkg.conf in the options array you need to have 'staticlibs' not '!staticlibs'.
19:43:09 <geekosaur> and: Alternatively, you can edit just gmp PKGBUILD https://mailman.archlinux.org/pipermail … 25542.html
19:43:13 <stephenmac7> geekosaur: Yes, I got that part. Too bad there's no option besides recompiling
19:43:25 <geekosaur> that would be arch for you...
19:43:28 <stephenmac7> Didn't see it on the todo page specifically though, not that it matters
19:43:42 <stephenmac7> But why skip the static libs, I have no idea
19:43:43 <geekosaur> and no, I don't know what they have against static libraries.
19:43:48 <tigrennatenn> anyone here use Helm? I'm running into some issues installing it
19:43:51 <geekosaur> I don't use Arch and for me this is just another reason not to
19:44:02 <jTT> geekosaur: stephenmac7: dfeuer: ok, I am beginng to see the extent of my misunderstanding
19:44:19 <jTT> codepoint is the way to got it seema
19:44:21 <jTT> seems
19:44:23 <geekosaur> yes
19:45:16 <geekosaur> Unicode is most definitely a pain, but it's a pain that was going to happen anyway since most of the computer and network infrastructure was developed outside of China/Japan/Korea/etc. and can't handle their characters directly
19:45:40 <stephenmac7> But at least we have unicode and aren't doing that halfwidth junk anymore
19:46:06 <geekosaur> halfwidth has less to do with unicode and more to do with the limitations of text terminals
19:46:08 <dfeuer> jTT, most likely anything you have to do that's not good to do with codepoints directly will be supported some other way in Data.Text. Anything that really isn't is going to be pain any way you do it.
19:46:18 <geekosaur> so what we really have now is widely available GUIs
19:46:59 <jTT> dfeuer: ok, cool. looking into Text and codepoint now. Thanks for your help
19:48:41 <stephenmac7> Any idea what -lrt is referring to?
19:48:52 <simpson> stephenmac7: Probably to librt.
19:49:03 <stephenmac7> I'm not finding any librt in the package manager
19:49:28 <simpson> It's part of the POSIX interface; it's probably provided by your libc or something along those lines.
19:49:29 <dfeuer> jTT, there are also crazy things like pipes-text, and probably the equivalent for conduit. A bit over my head.
19:49:50 <jTT> dfeuer: oh dear
19:50:02 <stephenmac7> simpson: I hope it's not libc...
19:50:04 <geekosaur> ... Linux shouldn't need a realtime support library
19:50:23 <dfeuer> jTT, I try to just duck.
19:50:44 <geekosaur> yes, -lrt would be for some other platform that doesn't have POSIX realtime support in its libc. can you @paste full output from whatever you are building?
19:50:45 <stephenmac7> Well, thanks.
19:51:06 <jTT> dfeuer: I can’t this time. right in between Japanese and Chinese flak
19:51:53 <robbie> \away
19:52:59 <johnw> jTT: if your conduit streams in Text, you should be able to find your codepoints
19:53:31 <jTT> johnw: yes! I hope so. This chat has been awesomely helpful
19:56:23 <stef1a> fromInteger :: Num -> Complex
19:56:47 <stef1a> why might i be getting the error Not in scope: data constructor `Num'? do i need to load anything into my source file?
19:58:04 <exio4> because Num isn't a type?
19:58:21 <AshyIsMe> :t Num
19:58:21 <lambdabot>     Not in scope: data constructor ‘Num’
19:58:22 <lambdabot>     Perhaps you meant ‘Sum’ (imported from Data.Monoid)
19:58:22 <johnw> :t fromInteger
19:58:23 <lambdabot> Num a => Integer -> a
19:58:29 <johnw> note the "=>"
19:58:57 <stef1a> Int? Integer? what happened? :-(
19:59:03 <stef1a> where are my numerical types?
19:59:22 <dfeuer> stef1a, what are you talking about?
19:59:41 <stef1a> dfeuer: how can i tell a function to expect a numerical type as an arg? like an integer?
20:00:06 <stef1a> oh, i use a typeclass?
20:01:24 <dfeuer> stef1a, yes, you want to take a polymorphic type constrained to be an instance of a typeclass.
20:01:37 <stef1a> thanks
20:01:44 <dfeuer> You don't have Num -> Foo, but rather  Num a => a -> Foo
20:08:05 <CrazyM4n> I have a problem
20:08:15 <trap_exit> can it be solved by using haskell ?
20:08:19 <CrazyM4n> I'm using console input in a little program
20:08:22 <CrazyM4n> Let me paste it
20:08:36 <CrazyM4n> Also, haha
20:09:14 <orb__> Haskell helps us solve problems we wouldn't have without Haskell.
20:09:22 <Lutin`> ^^^
20:09:28 <CrazyM4n> Definately
20:09:43 <CrazyM4n> Anyway, I have this http://lpaste.net/4603246459230355456
20:09:52 <orb__> Moar typez!
20:10:20 <CrazyM4n> I want to introduce some error checking so that if I type a string, it prints a message instead of crashing
20:10:29 <CrazyM4n> Could someone point me in the right direction to do that?
20:10:41 <orb__> CrazyM4n, that right Right direction is to learn about parsing.
20:10:42 <lisbeth> any projects combining docker with haskell?
20:11:08 <CrazyM4n> orb__: wait, I think I have an idea to do this, let me type it up and you can tell me if it's okay
20:11:18 <CrazyM4n> *how to do this
20:11:19 <orb__> CrazyM4n, otherwise, consider https://stackoverflow.com/questions/8066850/why-doesnt-haskells-prelude-read-return-a-maybe
20:11:21 <trap_exit> you mean try catch ?
20:11:54 <orb__> Specifically, https://stackoverflow.com/questions/8066850/why-doesnt-haskells-prelude-read-return-a-maybe/8067000#8067000
20:12:35 <thetrav> anyone able to recommend a haskell http server/framework? the wiki has quite a few and I'd appreciate if the choice could be narrowed down
20:12:48 <orb__> lisbeth, in the spirit of http://readwrite.com/2010/11/30/haskell-virtual-machine ?
20:13:22 <lisbeth> Trying to conceptualize a subshell
20:13:25 <trap_exit> thetrav: scotty
20:13:58 <jle`> thetrav: it depends on what you want t do
20:13:59 <orb__> lisbeth, what's that mean?
20:14:06 <trap_exit> i would love an phone that booted into haskell instead of java
20:14:08 <thetrav> orb__ I've been looking into the HaLVM quite recently
20:14:11 <lisbeth> I am working on a haskell shell
20:14:12 <thetrav> do you know anyone using it?
20:14:22 <lisbeth> or probably join one of the three or four projects working on it
20:14:24 <thetrav> trap_exit: cheers :)
20:14:36 <orb__> trap_exit, your phone is probably running some flavour of linux (if Android).  It doesn't boot into java..
20:14:47 <trap_exit> thetrav: ?
20:14:59 <trap_exit> orb_ : from what I have seen in the adb shell, I agree
20:15:09 <thetrav> trap_exit: I assume you were recommending scotty to me
20:15:16 <trap_exit> thetrav: indeed
20:15:22 <thetrav> cheers is Australian for thanks :)
20:15:24 <trap_exit> I don't understand the "cheers :)" joke
20:15:27 <orb__> lisbeth, ok.  How does docker come in there?
20:15:28 <trap_exit> ah
20:15:47 <lisbeth> Well shells that use haskell are usually written on top of something like ghci
20:16:00 <lisbeth> so I am thinking about what a subshell would look like
20:16:20 <lisbeth> so I am toying around with the idea of a subshell being an instance of ghci inside of docker
20:17:25 <orb__> lisbeth, by shell, you mean something like bash?
20:18:07 <lisbeth> yes
20:18:10 <lisbeth> or plush or hell
20:18:13 <orb__> You can have a look at what people learned in scsh (the scheme shell).
20:18:50 <orb__> I don't understand how that will be docker specific.
20:19:14 <orb__> Wouldn't a shell that isolated from the rest of your system be the exact opposite of what a shell is supposed to be?
20:20:40 <orb__> There's also es-shell, the extensible shell with higher order functions.
20:21:07 <solatis> orb__: depends, nix-shell works pretty good for isolation imho
20:21:26 <solatis> it creates a reproducable development environment with a single command
20:21:44 <orb__> solatis, your unix shell will be useful for controlling your docker container (or any vm you have).
20:22:39 <solatis> yeah, however, i personally use nix-shell as the ENTRYPOINT of my Docker containers
20:22:55 <solatis> so all commands are executed within the nix shell
20:25:27 <jle`> today i ask
20:25:36 <jle`> should missing fields in a pattern match for a constructor be an error
20:25:39 <jle`> when they could be warnings?
20:25:57 <jle`> (MyCons _ x _), when MyCons has four fields
20:26:04 <johnw> i'd much rather it was an error
20:26:13 <johnw> i'd rather if partial coverage of a case statement was an error too
20:26:27 <jle`> it's unambiguous what it would be interpreted as
20:26:34 <jle`> i would like partial case coverages be an error as well
20:26:41 <jle`> but this is orthogonal, i feel
20:27:09 <jle`> (MyCons _ x) could be interpreted as (MyCons _ x _ _)...right?  what would be the big deal?
20:27:15 <CrazyM4n> Is it acceptable to use catch when dealing with user input?
20:27:43 <Cale> jle`: But presumably (MyCons _ x) ought to match a function
20:27:49 <Cale> jle`: Only, that's not really possible
20:28:13 <jle`> CrazyM4n: is the potential error the result of the IO action of obtaining the input, or of a pure function that might evaluate to an error value?
20:28:24 <jle`> Cale: i guess it's a bit of an inconsistency
20:28:28 <newsham> keates and yates are on your side
20:28:33 <CrazyM4n> It is of a pure function that might evaluate to an error value
20:28:39 <jle`> CrazyM4n: then why
20:28:39 <CrazyM4n> read, to be exact
20:28:41 <jle`> ...
20:28:44 <CrazyM4n> ?
20:28:50 <trap_exit> docker + nixos + haskell
20:28:51 <jle`> why would you use catch for that?
20:28:51 <trap_exit> that'd be amazing
20:28:55 <jle`> use readMaybe or something
20:29:11 <CrazyM4n> I saw that in the source while browsing read's source
20:29:26 <CrazyM4n> But I, uh, couldn't figure out where it is. It doesn't show up in hoogle (unless I misspelled it)
20:29:29 <jle`> there are (almost) no good reasons for pure code to evaluate to error
20:29:35 <jle`> it's under Text.Read i think
20:29:59 <jle`> *a pure function
20:30:04 <jle`> *when applied
20:30:07 <jle`> *a pure value?
20:30:11 <CrazyM4n> So it is. Weird that it doesn't show up in hoogle then
20:30:14 <CrazyM4n> @hoogle readMaybe
20:30:16 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
20:30:16 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
20:30:17 <jle`> all functions and values in haskell are pure anyway...
20:30:20 <jle`> you know what i mean :)
20:30:27 <CrazyM4n> Yea, I got you :P
20:30:39 <Krass> yes, gotcha...
20:30:41 <orb__> jle`, unless there's lazy io shenanigans going on.
20:30:46 <Krass> (so NOT understanding a word)
20:30:59 <jle`> orb__: hm?
20:31:13 <jle`> all values of (IO a) should not be evaluating to error
20:31:22 <orb__> getContents returns a String.  But if you try looking at the string, stuff happens.
20:31:31 <jle`> yes but getContents does not evaluate to error
20:31:36 <jle`> oh yea
20:31:38 <jle`> i see
20:32:00 <jle`> yeah...would you call that a good reason? :P
20:32:07 <Lutin`> @index readMaybe
20:32:07 <lambdabot> bzzt
20:32:11 <Lutin`> :P
20:32:24 <Lutin`> You suck lambdabot
20:33:29 <Lutin`> geekosaur: Why does that not work if Text.Read is in base?
20:34:01 <Lutin`> old lookups?
20:34:36 <Lutin`> @index readList
20:34:36 <lambdabot> Text.Read, Prelude
20:35:01 <Lutin`> Yeah looks like that's the case, readMaybe has been in Text.Read since 4.6.0.0
20:36:00 <CrazyM4n> http://lpaste.net/2775957407740723200 So this looks good? Or did I do anything blatantly wrong?
20:36:15 <CrazyM4n> I mean, it works, but there might be some bad practices in there that I don't know about
20:37:00 <Lutin`> CrazyM4n: btw
20:37:03 <Lutin`> @src print
20:37:03 <lambdabot> print x = putStrLn (show x)
20:37:39 <CrazyM4n> oh... I am so used to ruby where print shows quotes around everything, so I tend to not use it
20:37:42 <CrazyM4n> Thanks
20:38:19 <Lutin`> Well it would if you did `print "abc"`
20:38:24 <Lutin`> > print "string"
20:38:26 <lambdabot>  <IO ()>
20:38:30 <CrazyM4n> lol
20:38:37 <Lutin`> > show "string"
20:38:38 <lambdabot>  "\"string\""
20:38:41 <CrazyM4n> ah
20:45:08 <CrazyM4n> Is there an easier way to cross compile to windows than just installing Haskell in wine?
20:47:11 <jle`> you could ask someone who has a windows box really nicely
20:47:42 <CrazyM4n> Haha, it works really well under wine
20:47:56 <Lutin`> AFAIK you can if you recompile GHC
20:47:57 <CrazyM4n> Already installed it and got it set up and etc.
20:48:48 <Lutin`> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
20:48:59 <Lutin`> If you decide to try it :P
20:49:11 <CrazyM4n> I read that, but it seemed like it was more work than neccasary when you could just install it under wine
20:49:23 <CrazyM4n> necessary
20:49:25 <CrazyM4n> Thanks though
20:50:32 <kadoban> Is there a "runhaskell" that works with sandboxes that I'm missing?
20:56:20 <Hijiri> cabal exec runhaskell?
20:57:22 <Hijiri> yep, that worked for me
20:57:59 <kadoban> What does exec actually do? Pretty much just forces the sandbox onto...ghc or something? 'cabal help exec' is...unhelpful.
20:58:35 <jle`> i think it runs the command in an environment where the sandboxed stuff is seen as "installed"
20:58:38 <Hijiri> I think exec executes the command with the sandbox environment
20:58:48 <kadoban> Hmm, okay thanks.
21:17:29 <Total_1mmersion> What's the easiest way to convert Integer year, month, date, hour, minute, second, nanosecond into some kind of date/time value?
21:17:53 <chirpsalot> fromGregorian?
21:18:09 <Guest21821> rookie question - wouldn't it be more appropriate if (+)'s signature was forall a. Num a => a -> a -> a instead of Num a => a -> a -> a
21:18:10 <chirpsalot> And TimeOfDay?
21:18:31 <chirpsalot> Guest21821: forall is actually a GHC extension, no?
21:18:57 <Guest21821> never mind then
21:19:07 <cigue> nick lilred
21:19:21 <Total_1mmersion> chirpsalot, thanks
21:20:02 <chirpsalot> Total_1mmersion: no problem! I literally just did something like that, so it was on my mind ;)
21:21:47 <lilred> I JUST UNDERSTOOD EXISTENTIALS OMG
21:22:04 <chirpsalot> lilred: oh?
21:22:07 <shelf> !!!
21:22:33 <exio4> lilred: THAT IS HASKELL!
21:23:03 <lilred> yeah, basically they're "forall" (i.e. a type level function) from the point of view of whoever's implementing the type, but they're existentials to whoever's consuming the value of that type
21:23:17 <exio4> everything feels like "what is this, what is this, wait, it was easy" :P
21:23:38 <lilred> because when you give an argument to an existential you get an existential in return
21:23:44 <lilred> sorry to an universal
21:23:56 <chirpsalot> lilred: actually, wouldn't forall a. Num a => a -> a -> a mean that each argument could be a different type as long as it was a Num?
21:24:02 * chirpsalot doesn't really understand forall.
21:24:08 <lilred> chirpsalot: no, that's what the current thing does.
21:24:21 <lilred> I don't know how to do it but someone ask lambda bot for the type of (+ 4)
21:24:21 <bb010g> chirpsalot: No, because it's the same a, just with a Num constraint.
21:24:27 <bb010g> :t (+4)
21:24:28 <lambdabot> Num a => a -> a
21:24:37 <lilred> :t (1.6 + 4)
21:24:37 <lambdabot> Fractional a => a
21:24:40 <chirpsalot> bb010g: oh, so it's equivalent to the Num a => a -> a -> a?
21:24:53 <lilred> the whole arithmetic component of Haskell feels dirty
21:25:03 <lilred> chirpsalot: I believe so yes
21:25:10 <bb010g> chirpsalot: That would be forall a b. (Num a, Num b, Something c) => a -> b -> c
21:25:25 <bb010g> For arguments of any different type
21:25:40 <chirpsalot> bb010g: okay, I see now. I was misreading something. Thanks.
21:25:46 <lilred> chirpsalot: when you look at any type with free type variables, it has an implicit forall
21:26:13 <chirpsalot> lilred: yeah. That's why I don't really understand the point of forall.
21:26:23 <lilred> chirpsalot: but you can't really do "type Foo = Bar b", so you do "type Foo = forall b. Bar b"
21:26:30 <chirpsalot> But I guess it's useful when constructing datatypes.
21:26:32 <chirpsalot> And stuff.
21:26:42 <chirpsalot> Yeah.
21:26:43 <jle`> consider a function that takes an (a -> String), and applies it to both things in a tuple
21:26:44 <lilred> chirpsalot: basically it's information hiding, potentially helpful with making pluggable architectures and shit
21:26:58 <jle`> foo f (x, y) = (f x, f y)
21:27:02 <jle`> what do you think its type would be?
21:27:25 <bb010g> chirpsalot: Basically, forall a. means any type. You then restrict domain further with constraints, like Num a. You can imagine the function foo :: Integer -> Integer as foo :: a ~ Integer => a -> Integer. (~) is type equality.
21:27:28 <lilred> jle: I figure the naive pick would be (a -> b) -> (a * a) -> (b * b)
21:27:37 <jle`> lilred: what about a tuple of different types?
21:27:42 <jle`> where x and y can be different types?
21:28:31 <lilred> jle`: I'm not good at this, can you explain how f would be able to consume both?
21:28:35 <jle`> or maybe a more meaningful question
21:28:37 <Total_1mmersion> chirpsalot, any idea why (UTCTime :: Day -> DiffTime) instead of (UTCTime :: Day -> TimeOfDay)?
21:28:52 <jle`> a funcion that takes an ([a] -> Int), and applies it to two lists of two different types
21:28:56 <jle`> that one might be a little easier to imagine :)
21:29:06 <Total_1mmersion> chirpsalot, oops, forgot return value: (UTCTime :: Day -> DiffTime -> UTCTime) instead of (UTCTime :: Day -> TimeOfDay -> UTCTime)
21:29:14 <jle`> foo f (xs, ys) = (f xs, f ys)
21:29:39 <jle`> a function forall a. [a] -> Int isn't "allowed" to touch the items inside
21:29:42 <chirpsalot> Total_1mmersion: honestly, no :(. I'm a bit confused by the dozens of time data types that are nearly identical.
21:29:47 <jle`> for example
21:29:50 <jle`> :t length
21:29:51 <lambdabot> [a] -> Int
21:29:55 <jle`> a first attempt might be
21:30:06 <lilred> jle`: so basically you're asking for the type of "zip length" more or less, which would be something like (forall a. [a] -> Int) -> ([a], [b]) -> (Int, Int)
21:30:10 <jle`> foo :: ([a] -> Int) -> ([b], [c]) -> (Int, Int)
21:30:18 <jle`> but that wouldn't work out
21:30:22 <Total_1mmersion> chirpsalot, me too, I feel like it doesn't need to be so complicated
21:30:33 <jle`> because the `a` is instantiated to one type, and so it can't be both `b` and `c`
21:30:49 <bb010g> chirpsalot: Explicit forall is mostly useful for type gymnastics. http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/other-type-extensions.html#universal-quantification
21:30:58 <chirpsalot> Total_1mmersion: time is actually kind of gross. There's all of the stuff that has to be in IO because of different timezones and bluh.
21:31:03 <jle`> but if we did foo :: (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)
21:31:05 <jle`> that would work
21:31:11 <lilred> bb010g: I saw it used in an implementation of PHOAS, it was very impressive
21:31:16 <jle`> becaus that's saying that you have to pass in a functio that can take a list of *any* type
21:31:21 <bb010g> lilred: PHOAS?
21:31:28 <chirpsalot> bb010g: is forall standard Haskell now? Or is it going to be?
21:31:45 <bb010g> chirpsalot: Nope. Still an extension.
21:31:56 <lilred> bb010g: parametric higher-order abstract syntax, basically a way to embed DSLs while leveraging the host language's type system inside the DSL
21:32:06 <Total_1mmersion> chirpsalot, yeah, the Python standard library doesn't even implement time zones. It's left up to the application to do that
21:32:32 <chirpsalot> Total_1mmersion: you can always use UTCTime.
21:32:42 <chirpsalot> Total_1mmersion: and then I guess it isn't a problem anymore.
21:32:53 <lilred> bb010g: I'm actually not too sure what it's for, but I know my research advisor is pretty big about it
21:33:00 <Total_1mmersion> chirpsalot, yeah, that's what I plan to do
21:33:08 <chirpsalot> Total_1mmersion: local timezones are kind of awkward, though. Because you have to get them from IO.
21:33:12 <bb010g> ?hackage phoas
21:33:13 <lambdabot> http://hackage.haskell.org/package/phoas
21:33:40 <chirpsalot> Which is perfectly reasonable, but dammit, Earth, we should do away with timezones and stuff so our Haskell libraries can be pure more easily :).
21:36:00 <bb010g> lilred: Looks like Edward Kmett did a post about it: https://www.fpcomplete.com/user/edwardk/phoas
21:38:06 <Hijiri> on the note of time
21:38:16 <Hijiri> how do I add an arbitrary length of time to a UTCTime?
21:38:23 <Hijiri> like I want to add 5 minutes
21:38:42 <Hijiri> other than messing with UTCTime's constructor
21:39:40 <dmj`> getCurrentTime >>= \time -> print $ addUTCTime (secondsToDiffTime (5 * 60)) time
21:40:13 <joelteon> but the eta reduction...
21:40:23 <dmj`> yea... there's that
21:40:57 <dmj`> I might have Difftime and NominalDiffTime confused
21:41:09 <jle`> print . addUTCTime (secondsToDiffTime (5 * 60)) =<< getCurrentTime
21:41:14 <jle`> or
21:41:27 <jle`> print =<< addUTCTime (secondsToDiffTime (5 * 60)) <$> getCurrentTime
21:41:29 <jle`> hm.
21:41:35 <jle`> i like the first one
21:41:39 <lilred> how can this be so complex
21:41:40 <lilred> o_O
21:42:23 <dmj`> print =<< addUTCTime (5 * 60) <$> getCurrentTime
21:43:08 <dmj`> :t addUTCTime
21:43:09 <lambdabot> Not in scope: ‘addUTCTime’
21:43:29 <chirpsalot> Does lambdabot do imports?
21:43:37 <Hijiri> Well I don't need the getCurrentTime
21:43:44 <Hijiri> but thanks
21:44:00 <Hijiri> I can just use addUTCTime and secondsToDiffTime
21:44:13 <dmj`> \utctime -> addUTCTime (5 * 60) `fmap` utctime
21:44:18 <dmj`> er
21:44:29 <dmj`> addUTCTime (5 * 60) time -- all you need
21:44:41 <Hijiri> oh right, the num instance?
21:44:57 <dmj`> yea
21:45:04 <Hijiri> ok, thanks
21:45:05 <dmj`> it's magic, magic, magic
21:45:17 <dmj`> ok
21:46:09 <dmj`> how would I generate a lazy list of binary numbers increasing [0,0,0,0],[0,0,0,1]
21:46:31 <dmj`> like that
21:46:38 <chirpsalot> dmj`: you can use a giant list comprehension :P?
21:47:01 <jle`> > replicateM 4 "01"
21:47:02 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
21:47:19 * chirpsalot blinks.
21:47:21 <jle`> > replicateM 4 [0,1]
21:47:22 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
21:47:32 <chirpsalot> jle`: what the heck o_o.
21:47:44 <augur> :t replicateM
21:47:46 <lambdabot> Monad m => Int -> m a -> m [a]
21:47:46 <dmj`> jle`: that is so clever
21:47:57 <augur> @src replicateM
21:47:57 <lambdabot> replicateM n x = sequence (replicate n x)
21:48:09 <chirpsalot> jle`: you have done this before, surely :P.
21:48:11 <bb010g> :t replicateA
21:48:12 <lambdabot>     Not in scope: ‘replicateA’
21:48:12 <lambdabot>     Perhaps you meant one of these:
21:48:12 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
21:48:14 <jle`> yeah, i've seen this before
21:48:17 <jle`> if only there was a replicateA
21:48:20 <jle`> the M is kinda silly
21:48:40 <chirpsalot> jle`: that was way too fast ;).
21:48:44 <augur> replicateM is morally just monadic exponentiation
21:49:41 <jle`> i feel like it is more naturally stated in terms of Applicative
21:49:43 <chirpsalot> I guess it's not that strange, now that I think about it. I'm still new so all of these fancy monad functions aren't in my brain.
21:49:58 <augur> replicate just repeats something n times, right, so you get a list of monadic things
21:50:10 <augur> specifically, the same thing
21:51:02 <augur> and then you just pull the action out to the outside with sequence
21:51:17 <jle`> replicateM 3 xs is like... do { y1 <- xs; y2 <- xs; y3 <- xs; return [y1,y2,y3] }
21:51:38 <bb010g> :t Seq.replicateA
21:51:39 <lambdabot> Applicative f => Int -> f a -> f (Seq.Seq a)
21:51:41 <augur> for lists, its nondeterminism, right, so you're setting up a list   [[0,1], [0,1], [0,1], [0,1]]
21:51:54 <augur> thats the list of four elements, all of which are non-deterministically 0 or 1
21:52:32 <augur> when you sequence, you turn that into a non-deterministic list, by looking at each non-deterministic option and trying each possibility
21:52:46 <jle`> but it's also just foldr (liftA2 (:)) (pure []) [xs, xs, xs ...]
21:52:56 <jle`> it's nondeterminstically applying (:)
21:53:00 <augur> if your monad had been state, you'd maybe have a list of stateful values, and you'd turn it into a stateful list
21:53:03 <bb010g> let replicateA n x = sequenceA $ replicate n x
21:53:09 <bb010g> > let replicateA n x = sequenceA $ replicate n x
21:53:11 <lambdabot>  not an expression: ‘let replicateA n x = sequenceA $ replicate n x’
21:53:14 <bb010g> @let replicateA n x = sequenceA $ replicate n x
21:53:15 <lambdabot>  .L.hs:192:18:
21:53:15 <lambdabot>      Not in scope: ‘sequenceA’
21:53:15 <lambdabot>      Perhaps you meant one of these:
21:53:15 <lambdabot>        ‘T.sequenceA’ (imported from Data.Traversable),
21:53:15 <lambdabot>        ‘sequence’ (imported from Control.Monad.Writer),
21:53:23 <bb010g> @let replicateA n x = T.sequenceA $ replicate n x
21:53:24 <lambdabot>  Defined.
21:53:38 <augur> jle`: *nod* or even better with idiom brackets   (| xs : (| xs : (| xs : ... |) |) |)
21:53:49 <jle`> ah, yeah.
21:53:56 <joelteon> use idris instead!
21:54:13 <augur> pure (:) xs (pure (:) xs (pure (:) xs ...)))   works too but is uglier
21:54:38 <augur> joelteon: ok hows this    !xs : !(!xs : !(!xs : ...))
21:54:46 <jle`> but...so...is it useful to think of replicateA/replicateM as an inherently monadic thing?
21:54:50 <augur> no thats not ideal
21:54:57 <augur> joelteon:   [!xs, !xs, !xs, !xs]
21:55:31 <augur> also i think i had too many !'s in there in the first one. doh.
21:56:42 <lilred> apt-get install perl python g++ clang++ make curl git
21:56:45 <lilred> wait fuck
22:00:30 <joelteon> haha, this guy uses perl...
22:04:57 <AshyIsMe> haha
22:05:52 <chirpsalot> I do kind of wonder what the entire stack of languages would be that all our software / libraries use.
22:23:39 * hackagebot defargs 0.2 - default arguments in haskell  http://hackage.haskell.org/package/defargs-0.2 (Kinokkory)
22:58:42 * hackagebot hosc-utils 0.15 - Haskell Open Sound Control Utilities  http://hackage.haskell.org/package/hosc-utils-0.15 (RohanDrape)
23:01:39 <tero-> hmm. Network/TLS/Core.hs:75:18-38: Non-exhaustive patterns in lambda
23:02:19 <tero-> I have tls-1.2.6
23:02:41 <Total_1mmersion> What would Haskell be like if data types were products of sums instead of sums of products?
23:03:31 <ski> having separate product/record types would be nice
23:15:14 <Lutin`> ...
23:15:50 <Lutin`> 4 hours of wrestling with implementing LLL in another language only to find out a_i means the column of a, not the row
23:21:03 <orb__> Lutin`, what's LLL?
23:21:13 <Lutin`> lattice reduction algorithm
23:21:21 <orb__> OK.
23:21:25 <Lutin`> http://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm
23:21:40 <Lutin`> Using it to solve the subset sum problem
23:21:54 <orb__> OK.
23:22:00 <Lutin`> KO.
23:22:16 <orb__> For fun?
23:38:46 * hackagebot network-conduit-tls 1.1.0.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.0.1 (MichaelSnoyman)
23:46:39 <Lutin`> orb__: Crypto & InfoSec class I'm taking
23:47:28 <Lutin`> It's an attack vector on the Merkle-Hellman Knapsack cryptosystem
23:47:45 <Lutin`> And some instances of RSA, but not any that would be in use
23:53:47 * hackagebot helics 0.3.0 - New Relic agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.3.0 (HirotomoMoriwaki)
23:53:49 * hackagebot helics-wai 0.2.0.2 - New Relic agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.2.0.2 (HirotomoMoriwaki)
23:53:51 * hackagebot yesod-form 1.4.0.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.0.2 (MichaelSnoyman)
23:58:47 * hackagebot apiary-helics 1.1.1 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.1 (HirotomoMoriwaki)
23:58:49 * hackagebot hsc3-graphs 0.15 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.15 (RohanDrape)
23:59:54 * hackagebot apiary-helics 1.1.1 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.1 (HirotomoMoriwaki)
23:59:54 * hackagebot hsc3-graphs 0.15 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.15 (RohanDrape)
