00:00:53 <levi> It's kind of funny that ≈Åukasiewicz invented it to get rid of parentheses, whereas the other pervasively-prefix notation is Lisp.
00:00:55 <Maxdamantus> shmookey: your RPN looks wrong.
00:01:19 <Maxdamantus> oh, nvm, different order.
00:03:31 <levi> A more literal translation to RPN: 5 4 + 3 *, or PN: * + 5 4 3
00:05:11 <levi> Apparently he assigned letters to logical operators, such as C for implication, so (p -> p) would be Cpp
00:05:32 <levi> But anyway, I've wandered quite far afield from Haskell.
00:06:30 * hackagebot serial-test-generators 0.1.2 - Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time  http://hackage.haskell.org/package/serial-test-generators-0.1.2 (scottmurphy09)
00:06:30 * hackagebot bindings-codec2 0.1.0.0 - Very low-level FFI bindings for Codec2  http://hackage.haskell.org/package/bindings-codec2-0.1.0.0 (RickyElrod)
00:10:22 * Maxdamantus wrote a language parser once that accidentally supported RPN.
00:11:32 <Maxdamantus> so you could write either `if 5 > 4 then bar*baz else qux` or `5 4 (>) (if) bar baz (*) qux (else) (then)`
00:12:02 <wei2912> Maxdamantus: on accident? :P
00:12:35 <Maxdamantus> Yes. I wasn't really checking for errors, and it was using the shunting yard algorithm.
00:12:41 <wei2912> ah, i see
00:13:31 <shmookey> Maxdamantus: in haskell?
00:13:35 <Maxdamantus> Yes.
00:14:20 <shmookey> i imagined haskell would lend itself to an explicitly recursive process rather than djikstra's shunting yard
00:18:14 <Maxdamantus> I wanted to make a syntax that could specifically be handled by the shunting yard algorithm.
00:18:27 <shmookey> ah
00:19:23 <Maxdamantus> but I don't think Haskell particularly lends itself to recursive processes, except maybe where monads are involved.
00:21:33 <shmookey> i like that algorithm because it's a great example of the equivalence between recursion and looping with a stack
00:26:47 <trap_exit> what does haskell need, so that 1 haskell programmer > 10 ruby programmers?
00:27:44 <Maxdamantus> A syntax with less whitespace sensitivity.
00:28:12 <Maxdamantus> but at least `a [5] = b` isn't a context-sensitive syntax error yet in Haskell.
00:28:59 <shmookey> trap_exit: a package manager
00:29:48 <levi> Haskell doesn't need anything for 1 haskell programmer > 10 ruby programmers, for some choices of haskeller and rubyists.
00:30:14 <levi> And for other choices, it'll never hold.
00:30:50 <Maxdamantus> (`a [5] = b` is syntactic in Ruby if a variable called `a` is in scope)
00:30:52 <levi> If you want to know what haskell needs to make *you* interested in it, only you can answer that.
00:32:50 <Maxdamantus> (if there is no `a` variable, `a [5]` is an expression that creates an array, otherwise it does a subscript)
01:10:13 <Jaeko> DOWNLOAD THIS GAME IS FOR FREE http://www.indiedb.com/games/the-brave-ball/downloads/the-brave-ball-alpha-demo
01:10:20 <komanda> hey everyone I'm having a tough time with a problem, could anyone help?
01:10:47 <komanda> Basically trying to find all palindromes in /usr/share/dict/words
01:12:08 <komanda> This is what I have: http://lpaste.net/113383
01:12:38 <komanda> a few things though, I only want to print when a palindrone is found
01:12:53 <komanda> and I want to lowercase before checking
01:13:21 <komanda> I'll be lurking and appreciate the help very much!
01:15:29 <lpaste> solatis pasted ‚ÄúCan I get rid of this `forever` loop in my code and use monadic mapping or something?‚Äù at http://lpaste.net/113384
01:15:38 <solatis> ok
01:15:46 <solatis> i feel like i'm taking too much an imperative aproach here
01:15:56 <solatis> i have this piece of code in that pastie, it's quite easy to read
01:16:06 <solatis> and i have added a few comments with a 'RELEVANT' part
01:16:09 <solatis> now
01:16:25 <solatis> i have a Control.Concurrent.Chan which has a readChan function
01:16:29 <solatis> > :t readChan
01:16:30 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
01:16:35 <solatis> :t readChan
01:16:35 <lambdabot> Not in scope: ‚ÄòreadChan‚Äô
01:16:43 <solatis> :t Control.Concurrent.Chan.readChan
01:16:44 <lambdabot> Control.Concurrent.Chan.Chan a -> IO a
01:17:07 <solatis> I feel like I can use some monadic mapping function instead of my forever $ do ... loop instead
01:17:16 <solatis> but i fail to get it to work
01:17:37 <solatis> do I maybe need sequence_ ?
01:18:24 <solatis> I thought I needed mapM_, but that doesn't appear to be it
01:18:25 <Hijiri> well I haven't used pipes for anything yet, but maybe this is a use case for pipes/conduit?
01:18:42 <trap_exit> haskell
01:18:49 <solatis> yeah it's a pretty clear producer/consumer, but at first i thought that would be overkill
01:18:55 <Hijiri> well maybe
01:19:04 <Hijiri> if it's just one thing I guess it might not be worth it
01:19:10 <solatis> it could be a good learning excercise tho
01:19:29 <solatis> well, i'm already using http-conduit under the hood...
01:19:58 <solatis> but that doesn't seem to work well with the ZeroMQ sockets i'm using
01:20:35 <solatis> note to @merijn: please make your pure haskell zeromq library based on conduit :)
01:23:15 <solatis> oh!
01:23:36 <solatis> :t Control.Concurrent.Chan.getChanContents
01:23:37 <lambdabot> Control.Concurrent.Chan.Chan a -> IO [a]
01:23:39 <solatis> \o/
01:24:04 <solatis> which is a lazy infinite list
01:24:08 <solatis> which allows me to use mapM_
01:27:48 <ThreeOfEight> komanda: http://lpaste.net/113386
01:28:01 <ThreeOfEight> three different ways of doing what you want to do
01:28:10 <komanda> thank you!
01:28:24 <ThreeOfEight> toLower converts a Char to a lower-case Char; map toLower then converts a String (list of Chars) to lower-case
01:28:26 <komanda> first night ever playing with haskell
01:28:46 <ThreeOfEight> komanda: not bad for your first night, I must say
01:29:17 <ThreeOfEight> you should see the code my students write after three weeks of Haskell >_>
01:29:28 <ThreeOfEight> it makes me lose my faith in humanity
01:30:00 <komanda> haha
01:30:16 <komanda> I'm looking at the code and it's like a light went off
01:30:20 <komanda> thank you so much
01:30:27 <ThreeOfEight> You're welcome. Feel free to ask more questions.
01:31:06 <komanda> it's hard to find complete examples of haskell programs, so many tutorials are just one liners or ghci
01:31:07 <ThreeOfEight> best way to learn monads is just playing around with different monads and their functions (mapM, sequence, guard)
01:31:24 <wei2912> ThreeOfEight: could you give us some samples?
01:31:54 <DarkCthulhu> jle`, Awesome article :)
01:31:56 <ThreeOfEight> oh yes, I forgot: you can also write something like ‚Äûdo {guard (isPalindrome w); putStrLn $ w ++ " is a palindrome"}
01:32:34 <ThreeOfEight> ‚Äòguard‚Äô basically ‚Äòstops‚Äô the monadic evaluation if the condition is false and carries on otherwise
01:32:55 <ThreeOfEight> wei2912: you mean stuff my students write?
01:33:12 <jle`> DarkCthulhu: thanks :D
01:33:42 <komanda> thanks again, love learning multiple ways of doing stuff
01:33:53 <komanda> is there one that would be more idomatic than the others?
01:34:14 <wei2912> ThreeOfEight: yeh
01:34:37 <ThreeOfEight> komanda: I guess that depends on personal taste
01:34:55 <ThreeOfEight> I wouldn't write that the print thing as an auxiliary function
01:35:04 <ThreeOfEight> and ‚Äòguard‚Äô is probably overkill here, too
01:35:19 <ThreeOfEight> I think I prefer the one with sequence and the list comprehension
01:35:38 <ThreeOfEight> (I'd also say the ‚Äòlet linesList‚Äô is a bit unnecessary)
01:35:56 <ThreeOfEight> wei2912: well, one of my all-time favourites is ‚Äò[x | x <- xs]‚Äô
01:36:02 <wei2912> lol
01:36:25 <ThreeOfEight> on StackOverflow, there recently was a question in which someone defined a ‚ÄòsnocLeft‚Äô function
01:36:26 <lpaste> pjdelport annotated ‚Äúpalindrones‚Äù with ‚ÄúFunctional pipeline style‚Äù at http://lpaste.net/113383#a113387
01:36:32 <ThreeOfEight> (an Isabelle question, but still)
01:36:40 <pjdelport> komanda: There's another way of doing it.
01:37:09 <pjdelport> komanda: That version replaces the do block with a functional pipeline.
01:37:26 <komanda> Thanks pj
01:37:29 <pjdelport> (Sometimes do is more readable, but in this case i like the pipeline style.)
01:37:39 <komanda> Also can you explain the use of an apostraphe after w?  (isPalindrome w = w' == reverse w')
01:37:57 <ThreeOfEight> komanda: it's just part of the variable name
01:37:59 <wei2912> must go, nght
01:38:01 <wei2912> night*
01:38:06 <pjdelport> komanda: Oh, that's nothing special: it's just a different name, defined right below: w' = map toLower w
01:38:09 <ThreeOfEight> I could just as well have written wAux or wNew
01:38:20 <pjdelport> komanda: So that compares the lowercase version of w
01:38:36 <komanda> ok just making sure it wasn't some magic :)
01:38:50 <ThreeOfEight> (it's convention in mathematics to put a prime symbol (') onto a variable to denote a slightly altered version of that variable)
01:39:02 <pjdelport> komanda: The ' is usually pronounced "prime" in this context, and it's a very common Haskell idiom when you have a modified or derived version of some other variable.
01:39:13 <pjdelport> komanda: You'll see i named the print' helper with a ' as well.
01:39:24 <ThreeOfEight> komanda: there is very little magic in Haskell
01:39:35 <ThreeOfEight> well, very little magic that you have to worry about.
01:39:40 <pjdelport> to distinguish it from the built-in print function, and to help indicate that it's just a local helper.
01:39:47 <ThreeOfEight> There is some magic hidden in the compiler, but it is quite transparent to the user
01:39:54 <komanda> good to know thanks so much
01:40:16 <ThreeOfEight> Another student also managed something quite baffling
01:40:26 <ThreeOfEight> he uploaded his Haskell code as a .txt
01:40:32 <pjdelport> komanda: You'll see the same convention in the libraries: for example, there's the function foldl, and then there is also foldl' which is a stricter variant of foldl.
01:40:33 <ThreeOfEight> /and/ encoded with UTF-16
01:40:57 <ThreeOfEight> and /then/ complained, with a very rude email, that the automatic test system didn't accept it
01:41:16 <ThreeOfEight> (no way this could have compiled on his local GHC either, it was full of syntax errors and GHC doesn't like UTF-16)
01:41:39 <ThreeOfEight> and someone, at some point, even uploaded an RTF document as Haskell code
01:43:00 <trap_exit> monads
01:55:09 <Hijiri> haskell users are choosing monads over gonas
01:55:12 <Hijiri> gonads
01:58:17 <ThreeOfEight> this is odd
01:58:38 <ThreeOfEight> I run ‚Äòcabal update‚Äô on my virtual server, it hangs for about 10 seconds and is then killed
01:58:41 <blueonyx> hi, is there any resource on using parsec on other datastructures than string (-like)?
01:58:57 <ThreeOfEight> it also consumes 100% CPU during that time
02:00:07 <ThreeOfEight> Ah, out of memory. Crap.
02:11:08 <adas1> what is it exactly that the haskell type system provides that I cannot possibly model in another language with a static type system like c,c++ or java? is there an example that can show how haskell's type system is more useful than a static type system for that particular example?
02:12:09 <jle`> adas1: parametricity and free theorems come to mind
02:12:36 <adas1> jle`: could you please elaborate?
02:12:47 <jle`> both coming from polymorphism
02:12:54 <jle`> for example, consider the function foo :: a -> b -> a
02:13:08 <jle`> there isn't any possible implementation of this function other than to return the first input
02:13:16 <jle`> in c, c++, java...you can do ad-hoc reflection
02:13:32 <jle`> maybe you can say "if `x` is an Int, then return 0....otherwise, return itse.f"
02:13:59 <jle`> or even "if `x` is an Int, ask the user for an integer and return that!"
02:14:12 <jle`> actually i don't think c++ has ad-hoc reflection, but it has casting
02:14:28 <adas1> adhoc reflection?
02:14:48 <jle`> check the class of something and branch on the result
02:15:03 <adas1> ah okay
02:15:11 <jle`> in foo :: a -> b -> a, the type signature says, "you aren't allowed to branch on the value of `a` or `b`.  you can't branch on its type.  you can't branch on anything."
02:15:25 <jle`> when we add things like typeclasses, we selectively allow things to branch on
02:15:29 <tdammers> I think it does, in the sense that you can do stuff like "if X is an instance of A, do Foo, else do Bar"
02:15:29 <jle`> foo :: Typeable a => a -> b -> a
02:15:47 <jle`> now, that new signature says, "foo is allowed to branch on the type of `a`"
02:15:47 <tdammers> but you cannot get fully first-class type information like you can with C#'s reflection API
02:15:54 <jle`> foo :: Show a => a -> b -> a
02:16:01 <jle`> this says, "foo is allowed to branch on the string representation of `a`"
02:16:21 <jle`> hm.  this isn't really the perfect example of that, but.
02:16:27 <tdammers> C++'s RTTI is limited to comparing class IDs, basically
02:16:32 <jle`> i think i picked a bad example because there isn't really any practical branching for this sort of function
02:16:37 <jle`> but, yeah.
02:17:00 <adas1> so essentially, haskell doesn't do any type juggling at runtime ..
02:17:02 <jle`> an even more obvious thing would be like foo :: a -> Bool
02:17:08 <jle`> type is only one aspect of it
02:17:11 <jle`> think about foo :: a -> Bool
02:17:22 <jle`> there are only two implementations -- always returning false, or always returning true
02:17:30 <jle`> in Java or C++....
02:17:31 <ThreeOfEight> jle`: one should probably add that returning the first argument is the only /terminating/ implementation of type a -> b -> a
02:17:38 <jle`> ThreeOfEight: yes, i should :)
02:17:43 <jle`> in java or C++, there are lots of implementations
02:18:02 <jle`> you could branch on the type of a...you could print out a, or you could inspect it and inspect its properties and figure out how to act
02:18:05 <jle`> you could even do side-effects
02:18:08 <jle`> like ask the user for a Bool
02:18:14 <jle`> or query a database
02:18:33 <jle`> we can do all of that in Haskell, but...we can selectively state what "foo" is allowed to do
02:18:40 <jle`> foo :: Typeable a => a -> Bool
02:18:44 <jle`> "foo can branch on the type of a"
02:18:48 <jle`> foo :: Show a => a -> Bool
02:18:53 <jle`> "foo can branch on the string representaiton of a"
02:18:54 <adas1> ThreeOfEight: i can modify the 1st argument before returning it.. but that doesn't count right..since its still the same type
02:18:56 <jle`> foo :: a -> IO Bool
02:19:04 <jle`> adas1: how would you modify it?
02:19:12 <jle`> adas1: there isn't any way to modify it in haskell
02:19:16 <jle`> because you don't know anything to do with it
02:19:21 <jle`> what do you do with something of type `a`?
02:19:31 <jle`> you can't add it to anything...because you don't know if it's a number
02:19:47 <jle`> you can't check its string representation...because you don't know if it's somethign taht can be shown
02:19:49 <jose882> but you could do the same in Java with a function that takes an Object
02:19:57 <jle`> you can't negate it, you don't know that it's a bool
02:19:58 <jose882> that doesn't really do anything
02:20:06 <adas1> jle`: oh got it. i was telling myself that if its a number then i can add it and return it.. but i realize there is no way to say that it is even a number
02:20:10 <jose882> so you know the funciton won't do much to it
02:20:14 <zipper> I'm looking for a more idiomatic way to write this --> `addInv = MkMod . negate . (\(MkMod int)  -> int)`
02:20:17 <jle`> (btw, foo :: a -> IO Bool says that "the result can do arbitrary IO")
02:20:32 <zipper> Where `data Mod5 = MkMod Integer deriving (Show, Eq)`
02:20:33 <tdammers> jose882: that function could, however, do all sorts of things with *other* objects that it can create or otherwise access
02:21:07 <tdammers> jose882: it could, for example, call static methods from pretty much any class in your codebase
02:21:43 <bernalex> or launch the missiles :-]
02:21:48 <tdammers> yeah
02:21:56 <ThreeOfEight> jose882: you could also use the instanceof operator
02:21:56 <jle`> foo :: Num a => a -> Bool
02:22:03 <jle`> foo can depend on the numerical properties of `a`
02:22:04 <ThreeOfEight> and do type casts of that object
02:22:10 <adas1> jle`: when you say "can branch on the ..." you mean, the result of the function can deviate based on the type of 'a'?
02:22:21 <jle`> adas1: yes.  or the string representation, or the numerical properties, or IO...
02:22:26 <jle`> depending on which "annotation" we use
02:22:36 <jle`> see, in haskell, our types can "say" more stronger statements
02:22:48 <jle`> we can make greater restrictions on what is possible
02:22:56 <jle`> and have them be more meaningful
02:22:57 <jose882> yes, that's true...
02:23:09 <jle`> even a language like ocaml doesn't have these guaruntees
02:23:39 <tdammers> one of the strongest of these guarantees is purity, as in, you need to declare your functions to return IO actions in order to do anything that involves IO side effects
02:23:51 <jle`> so, foo :: a -> Bool is a simple example, but...
02:24:05 <jle`> in real, practical haskell, your code base is basically full of more complicated and useful example of these
02:24:11 <jle`> and you rely on them every day as you code
02:24:32 <jle`> more and more expressive things
02:24:34 <zomg> Anyone seen any remote haskell jobs being posted lately? Might be looking for some new opportunities soon'ish
02:24:35 <jle`> that you can state
02:25:02 <adas1> i think this example is awesome .. i plan on using this example during a talk at my workplace on friday
02:25:11 <bernalex> it means that in twenty years, you can change the radius of your Ball without launching missiles at Russia. :-]
02:25:13 <ThreeOfEight> One of the nicest things is ‚ÄòIf I call a function, it will not mutate state.‚Äô
02:25:17 <zipper> Oi I can't write good idiomatic code. Yet I started learning haskell in February.
02:25:20 <bernalex> zomg: do you want to move to Norway? :-]
02:25:32 <jle`> the foo example is a ice toy example, but maybe it would be nice to find a real one in practice
02:25:33 <zipper> How long did it take you guys?
02:25:34 <zomg> bernalex: I live in Finland at the moment so it wouldn't be a huge difference, but not really :D
02:25:36 <bernalex> ThreeOfEight: well haskell can't mutate state at all. :-]
02:25:39 <jle`> but even foo :: a -> Bool is a powerful argument, i think
02:25:46 <ThreeOfEight> bernalex: exactly
02:25:49 <hyPiRion> bernalex: You got Haskell jobs in Norway?
02:25:54 <bernalex> hyPiRion: sure.
02:26:05 <ThreeOfEight> although, to be fair, their is unsafePerformIO, unsafeCoerce etc.
02:26:06 <bernalex> meeting someone who's interested today even. :-]
02:26:06 <lpaste> jstolarek pasted ‚Äúsanity check, please‚Äù at http://lpaste.net/113391
02:26:12 <bernalex> ThreeOfEight: shhhhhhh ;-)
02:26:24 <jstolarek> I need a snity check - see paste
02:26:34 <bernalex>  ThreeOfEight and we don't need unsafeCoerce, now we have zero-cost safe coercion. :-D
02:26:35 <jstolarek> s/snity/sanity/
02:26:46 <hyPiRion> bernalex: neat ‚Äì which company if I may ask?
02:26:52 <adas1> jle`: another example i thought of is .. the order of 2 statements in a language with a static system..
02:26:55 <jstolarek> GHC gives me a type error that I can't solbe
02:27:04 <jstolarek> I mean the reported expected types are correct
02:27:08 <adas1> jle`: in such a language it is hard to enforce that one statement must happen after another
02:27:17 <jstolarek> s/expected/actual/
02:27:34 <jle`> adas1: i'm not sure what you mean
02:27:35 <jstolarek> but I can;t see why it wants the reported expected types...
02:27:39 <adas1> jle`: but in haskell, function composition will ensure that such statement happen in the right order
02:28:09 <ThreeOfEight> adas1: one thing happening after another is only important when you have side effects
02:28:19 <ThreeOfEight> and side effects must be made explicit in Haskell, yes
02:28:23 <bernalex> hyPiRion: my own. plaimi. you won't find much about it. sorry. :-] you can ping me in #haskell-blah for details if you want.
02:28:38 <ThreeOfEight> that's what monads like the State monad, the ST monad, and the IO monad are for
02:29:08 <bernalex> hmmmm
02:29:12 <bernalex> they do not model side-effects
02:29:23 <ThreeOfEight> side-effect free pure Haskell is basically typed Lambda calculus
02:29:30 <bernalex> no no.
02:29:37 <ThreeOfEight> and typed Lambda calculus is confluent, i.e. the order in which you evaluate is irrelevant
02:30:11 <bernalex> OK so: haskell has no side-effects. but it can model *explicit* effects e.g. in the IO monad. :-]
02:30:16 <adas1> jle`: like for instance .. i can have 2 statements like "redrawscreen" and "flipbuffer" and they might type check in a static system.. but in haskell, if redrawscreen had type (IO Buffer -> IO ()) and flipbuffer had type (IO Buffer) .. there is only one way to copmose them
02:30:48 <ThreeOfEight> bernalex: I always explain ‚ÄòIO a‚Äô to my students as a cooking recipe
02:30:48 <bernalex> an action "IO a" is the instructions that when evaluated in the RTS might deliver a value of type a. haskell itself has no effects and is completely useless. :-]
02:30:49 <adas1> jle`: but in java or C, you do redreawscreen(buffer) and then flipbuffer and it would type check..
02:30:52 <adas1> but logically wrong
02:30:57 <jle`> ah
02:31:18 <bernalex> ThreeOfEight: as long as you include to mention that what you're cooking might not end up as you planned. case in point: getLine answered with ^C. :-]
02:31:26 <ThreeOfEight> ‚ÄòIO a‚Äô is a cooking recipe that tells you how to cook up a certain value of type a
02:31:42 <ThreeOfEight> (while possibly changing the world)
02:31:56 <bernalex> no the recipe does not change the world
02:32:06 <ThreeOfEight> well it does when you actually cook it
02:32:07 <bernalex> the cook changes the recipe when he is trying to follow the recipe. the cook is the RTS. :-]
02:32:16 <bernalex> uh
02:32:19 <bernalex> *changes the world
02:32:27 <ThreeOfEight> yes, well, these are semantical subtleties
02:32:37 <bernalex> and they matter. a lot. especially when learning something new. :-]
02:32:42 <jle`> ThreeOfEight: you mean, that's what *types* like State, ST, and IO are for
02:32:47 <hyPiRion> bernalex: cool, good luck on getting developers :) Just curious about the Haskell job market around Oslo, in case the startup I work for goes boom
02:32:51 <jle`> their Monad instance doesn't do anything :P
02:32:59 <jle`> it's the types that make them tick
02:33:08 <ThreeOfEight> anyway, getLine getting answered with ^C is a problem you have in pure Haskell as well
02:33:16 <ThreeOfEight> with exceptions. They are truly a pain in the arse.
02:33:19 <bernalex> hyPiRion: we're quite a bit north of Oslo. I don't know anyone using haskell in Oslo, but if you ping me when you go bankrupt, I know a few people I could ask. :-]
02:33:27 <ThreeOfEight> but at least in pure Haskell, if an exception flies in your face, it's /your/ fault
02:33:30 <bernalex> ThreeOfEight: that's not a problem in haskell. it's a problem in RTS. :-]
02:33:49 <bernalex> the source code of your program is still logical, pure and reasonable, even if RTS runs out of RAM.
02:34:06 <ThreeOfEight> bernalex: pure code can throw exceptions
02:34:07 <hyPiRion> bernalex: Alright, you'll get a desperate ping when cash is out :p
02:34:09 <ThreeOfEight> head [] and so on
02:34:22 <ThreeOfEight> and I don't like Haskell exceptions at all.
02:34:41 <bernalex> ThreeOfEight: those are defined and understood and can be caught. but yeah, head etc are design errors IMO. :-]
02:34:58 <bernalex> ThreeOfEight: wait for -XDependentlyTyped. ;-)
02:35:04 <ThreeOfEight> jle`: the monad operations are what makes them usable though. Side effects are of little use when you can't chain them together.
02:35:35 <bernalex> I think you mean "instructions which if evaluated by RTS will cause explicit effects" :-]
02:35:40 <ThreeOfEight> bernalex: Liquid Haskell is already a nice step in the right direction, I think
02:36:09 <jle`> ThreeOfEight: they are still of use :)  and they can do side-effects without Monad
02:36:17 <jle`> and you can even use pre-built effects, too.
02:36:21 <jle`> Monad instance makes them more convenient
02:36:31 <bernalex> curiously the monad operations on IO are tricky in that what makes it useful is associative Kleisli composition, which the IO Monad doesn't even *break*. :-]
02:37:28 <jle`> i think it's a bit disingenous to say "the IO monad"
02:37:34 <jle`> that's like introducing someone to lists for the first time
02:37:39 <jle`> and talking about consing and concatenating
02:37:41 <jle`> and saying
02:37:47 <jle`> "today, we are learning about the list monad."
02:38:04 <bernalex> I was talking specifically about the monad instance for IO...
02:38:12 <jle`> oh, i was referring to ThreeOfEight
02:38:20 <bernalex> oh ok. then I agree. :-]
02:38:27 <jle`> nothing personal though
02:38:39 <bernalex> yeah what about the IO Functor? and so on :-]
02:38:59 <ThreeOfEight> How long can you sensibly talk about IO /without/ mentioning the IO monad?
02:39:06 <jle`> um
02:39:12 <jle`> i've written pretty long posts on it :P
02:39:17 <ThreeOfEight> I mean, if you introduct students to how to do IO in Haskell
02:39:19 <ThreeOfEight> *introduce
02:39:32 <jle`> yes, but you don't have to say "IO monad"
02:39:53 <jle`> it's not "the list functor" when you learn map
02:40:13 <dibblego> I think it is much less helpful to describe IO as having a relationship to side-effects
02:40:14 <jle`> and besides, it's not immediately important that the utility functions come from the Monad instance
02:40:18 <ThreeOfEight> I'm not even sure if we call it the IO Monad
02:41:08 <jle`> `concatMap` is useful.  it's useful in its own write, for lists.  it doesn't gain its usefulness from the fact that it is (=<<) for lists
02:41:18 <jle`> s/write/right
02:41:22 <jle`> must be getting late heh
02:41:24 <bernalex> it's not like first day of maths you talk about the Monoid formed over the group of Integers with + and 0. :-]
02:41:56 <bernalex> jle`: opposite problem for me. good morning. :-]
02:42:48 <ThreeOfEight> Ha, turns out we don't actually call it the IO Monad
02:42:55 <jle`> yes, but somehow the name stuck
02:42:57 <jle`> :|
02:43:20 <jle`> anyways, if you're talking about managing side-effects, i think that 'IO type' might be more meaningful than 'IO monad'
02:43:26 <ThreeOfEight> on the slides, the professor just calls it ‚Äòan IO type‚Äô
02:43:27 <jle`> but i guess i'm being pedantic now
02:43:37 <jle`> night all :)
02:43:48 <tdammers> jle`: I don't think you're being pedantic at all
02:43:51 <ThreeOfEight> it would certainly be wrong to say that a function returns ‚Äòan IO monad‚Äô
02:44:10 <bernalex> not wrong :-]
02:44:12 <tdammers> IO being a Monad is simply a convenient coincidence :D
02:44:15 <bernalex> weird, certainly, but.
02:44:34 <jle`> yeah...i guess it somehow implies that the monadness is what enables IO to embody side-effects
02:44:41 <tdammers> exactly
02:44:45 <jle`> i've even heard people say "how do we do pure side-effects in haskell? with monads!"
02:44:49 <jle`> and...
02:44:51 <jle`> yeah.
02:44:53 <jle`> :'(
02:44:55 <jle`> i shed tears.
02:44:58 <tdammers> confusing, to say the least
02:45:07 <tdammers> at least it confused the hell out of me
02:45:14 <jle`> you do it with a well constructed type representing side-effects
02:45:27 <tdammers> IO representing side effects and IO being a Monad are kind of orthogonal
02:45:29 <jle`> possibly  ---- but not necessarily --- offering convenient interfaces/api
02:45:31 <dibblego> IO represents side-effects just as much as [] does
02:45:35 <tdammers> exactly
02:45:45 <tdammers> dibblego: oh?
02:46:04 <tdammers> dibblego: IO is kind of an EDSL for (certain types of) side effects
02:46:08 <dibblego> IO represents I/O effects
02:46:22 <dibblego> [] is kind of an EDSL for (certain types of) side effects
02:46:28 <tdammers> yeah, ok
02:46:31 <dibblego> you can believe both or neither (I happen to believe neither)
02:46:41 <bernalex> jle`: my personal irk is people saying that haskell has side-effects or that we can have side-effects via the IO Monad or whatever. :-]
02:47:09 <tdammers> well, whether something is a side effect or not is also a matter of frame-of-reference
02:47:13 <jle`> heh. yeah.  i'm not sure how these misconceptions began, or how they keep on persisting
02:48:03 <tdammers> State computations are "pure" on the outside: runState is a pure function
02:48:17 <tdammers> but from inside the State, state modifications are conceptually effectful
02:48:29 <bernalex> tdammers: let me give you a non-definition from which you may derive my definition of side-effects: in a language where call-by-value and call-by-name are weakly equivalent, there may be no side-effects. :-] I am not counting unsafeBleurghs here.
02:49:00 <tdammers> well, ok
02:49:09 <dibblego> there is no frame-of-reference in (safe) haskell whereby yu observe a side-effect
02:49:24 <tdammers> dibblego: indeed
02:49:34 <dibblego> you can create small grammars with Free to demonstrate this too
02:50:04 <dibblego> e.g. I can write a side-effect free I/O program in C# using Free (and have done). The interpreter makes an unsafe call to interface with C# runtime.
02:50:18 <tdammers> dibblego: but you do observe side effects "inside" IO, in the same way you observe side effects inside State
02:50:20 <bernalex> the whole point of haskell, which is what drew me in initially, and is keeping me here, is that it's useless. :-]
02:50:34 <dibblego> tdammers: nope
02:50:59 <DarkCthulhu> jle`, How is (typeOf :: Term -> ReaderT env IO Type) how do I read this?
02:51:17 <DarkCthulhu> It's a function that takes a Term, and ...?
02:51:21 <bernalex> I'll second dibblego's nope :-]
02:51:35 <tdammers> *sigh*
02:51:37 <bernalex> DarkCthulhu: returns a burrito
02:51:46 <tdammers> State itself is pure, right?
02:51:48 <DarkCthulhu> jle`, I know that something there is wrapping the type in a reader monad along with some environment
02:51:56 <DarkCthulhu> bernalex, I could use a burrito right now :)
02:52:10 <dibblego> tdammers: yes, just like IO and [] and Free f
02:52:15 <DarkCthulhu> I'd just like to know the right way to read that  line
02:52:16 <tdammers> exactly
02:52:22 <bernalex> DarkCthulhu: by burrito I mean a bunch of monad stuff. you can nest them. like [IO [Int]] is a valid thing.
02:52:27 <dibblego> in none of these cases does there arise a possibility to "observe a side-effect"
02:52:57 <tdammers> dibblego: not until you start reasoning in terms of the EDSL that State implements
02:52:59 <DarkCthulhu> bernalex, Hmm.. so, that entire thing is a single term? It's a Type wrapped in a reader monad right?
02:53:02 <bernalex> effects happen in RTS. our src always remains pure and reasonable. :-]
02:53:10 <bernalex> DarkCthulhu: yep
02:53:13 <DarkCthulhu> What does IO there signify?
02:53:16 <dibblego> tdammers: not at all, ever
02:53:35 <bernalex> dibblego: same as if you had a Maybe [Maybe [String]]
02:53:39 <bernalex> uh DarkCthulhu ^
02:53:43 <dibblego> tdammers: this is much more obvious when you write your own I/O grammars and interpreters e.g. using Free, where you reduce this argument to absurdity
02:53:53 <DarkCthulhu> bernalex, Hmm.. I see
02:54:17 <tdammers> is it?
02:54:25 <DarkCthulhu> bernalex, One more piece of weird syntax (I think this is section, but I'm unsure what it does). tye <- local ((n,ty):) (typeOf e)
02:54:27 <dibblego> IO does IO effects, [] does [] effects. Nowhere (in safe haskell) do side-effects occur.
02:54:30 <bernalex> DarkCthulhu: the order matters e.g. when you fmap or whatever. you'll have code like liftM . liftM . liftM if you're not careful.
02:54:33 <DarkCthulhu> bernalex, I know local changes the environment
02:54:48 <nshepperd> ooh, a definitional debate about "side effects"!
02:54:51 <DarkCthulhu> but the modifying function is ((n, ty):) which does what?
02:54:52 <bernalex> DarkCthulhu: uh I'm not sure what is happening there
02:54:55 <dibblego> tdammers: I use it as an instructive tool and with 100% success
02:55:11 <nshepperd> does C have side effects?
02:55:14 <DarkCthulhu> oh shit.. it's cons isn't it? :
02:55:18 <dibblego> tdammers: here is a side-effect free I/O program using C# https://gist.github.com/tonymorris/b5dba9d7d877051d0164
02:55:20 <bernalex> dibblego: to me it looks like you are calling local on some stuff and putting it in type, heh.
02:55:35 <dibblego> er sorry that is haskell
02:55:54 <tdammers> dibblego: suppose I write a JavaScript interpreter in Haskell
02:56:04 <bernalex> nshepperd: C has the Kleisli arrow "?? a -> ???? b". and this is not programmable. :-]
02:56:11 <tdammers> dibblego: JavaScript has side effects all over the place, can we agree on this much?
02:56:24 <dibblego> tdammers: write a trivial I/O interpreter, then ask if you have side-effects (nope)
02:56:36 <dibblego> I have no idea what this means
02:56:57 <bernalex> tdammers: we can agree that javascript does not forbid side-effects, yes.
02:57:04 <dibblego> here is the C# https://gist.github.com/tonymorris/7817335
02:57:17 <tdammers> bernalex: yeah, ok... "JavaScript allows side effects"
02:57:28 <dibblego> at no point, up until to the interpreter, does there exist a side-effect
02:57:33 <tdammers> but we're implementing a JavaScript interpreter in Haskell.
02:57:40 <dibblego> tdammers: it's quite simple to debunk if it were true ó just point to the side-effect (you cannot)
02:57:55 <tdammers> from a Haskell point of view, there are no side effects
02:58:00 <bernalex> dibblego: out of curiosity: why? I find it too mentally taxing to write pure code in impure langs.
02:58:03 <dibblego> tdammers: I can write a GetChar and PutChar interpreter ó it would much more easily demonstrate the point
02:58:13 <dibblego> bernalex: because it is more taxing not to
02:58:23 <zomg> tdammers: interesting, I wrote a PHP interpreter in Haskell :P not 100% compatible but a little bit just to see how that would work
02:58:24 <tdammers> but we're still adhering to the language spec, which demands things like mutable variales
02:58:27 <DarkCthulhu> bernalex, Last question - why should I do a liftIO before returning from a function that takes a reader monad wrapped type as argument?
02:58:32 <bernalex> dibblego: yes, sure, but the alternative I go for is commonly "don't use an impure lang".
02:58:35 <jle`> DarkCthulhu: it takes a Term and returns a value of type ReaderT env IO type
02:58:39 <dibblego> bernalex: so do I
02:58:50 <tdammers> the whole point is that it's possible to implement impure semantics on top of a pure lang
02:58:53 <MP2E> Funnily enough, I've shown a friend that uses C++ functional programming, and he told me that he has always strived for functional purity when possible, though he didn't know that was the word for it.
02:59:00 <DarkCthulhu> jle`, Ohh.. yeah, that is the return value. But I do a liftIO before returns. Why?
02:59:03 <tdammers> the pure language doesn't magically become impure
02:59:06 <bernalex> DarkCthulhu: liftIO does IO a -> m a
02:59:15 <jle`> data ReaderT r m a = ReaderT { runReaderT :: r -> m a }
02:59:19 <jle`> so it's jus a normal data type
02:59:24 <tdammers> and the impure language is still semantically correct in its implementation
02:59:27 <jle`> data ReaderT r m a = ReaderT (r -> m a)
02:59:29 <dibblego> tdammers: the side-effect is a (not necessary) property of the interpreter, not the program
02:59:34 <bernalex> DarkCthulhu: so lets say you have some burrito of some monad and also IO, and you want to operate on it without the IO.
02:59:36 <DarkCthulhu> jle`, Normal data type except it carries the environment along.
02:59:43 <jle`> DarkCthulhu: no, just a normal data type
02:59:44 <nshepperd> dibblego,tdammers: sounds like you're agreeing violently
02:59:48 <jle`> data Foo a b = Foo (a -> b)
02:59:49 <DarkCthulhu> bernalex, Why would I want to strip IO from the burrito?
02:59:54 <tdammers> nshepperd: that's what I'm thinking myself
02:59:58 <jle`> that's just a normal data type, Foo "contains" a function
03:00:03 <DarkCthulhu> hmm
03:00:06 <jle`> data ReaderT r m a = ReaderT (r -> m a)
03:00:08 <jle`> just a normal data type
03:00:12 <jle`> containing a function
03:00:13 <DarkCthulhu> okay.. understood
03:00:15 <dibblego> nshepperd: I think vocabulary is important, since we were originally discussing teaching (and inappropriate vocabulary was used) ó maybe we agree otherwise
03:00:23 <jle`> the carrying of the environment is done with the Applicative/Monad instances
03:00:23 <bernalex> DarkCthulhu: so you don't have to lift . lift . lift . lift to fmap over it as if it were a database not an IO bleurgh herp derp database? "it depends". :-]
03:00:27 <tdammers> my point is; as long as you reason in terms of the "guest" language, you can observe effects
03:00:36 <jle`> DarkCthulhu: if you want throw in an IO action into the mix
03:00:38 <friden> Hello hasklers, I need help with some typing. I have a main function in which I can't get result type from decode to fit to the rest of the function structure in the module. Could anyone give me a hint how to get typing correct? Code here: http://pastebin.com/j4KrKT2q
03:00:40 <dibblego> tdammers: you cannot observe side-effects
03:00:50 <jle`> DarkCthulhu: remember that (>>=) takes two monad sof the same type
03:00:55 <tdammers> dibblego: the JS implementation allows for mutable variables
03:00:55 <jle`> you can't bind together an IO a and a ReaderT r IO a
03:00:56 <dibblego> tdammers: if you can, point to it
03:00:56 <bernalex> I need to go take a train
03:00:59 <bernalex> but I agree with dibblego
03:01:07 <jle`> :t (>>=)
03:01:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:01:22 <bernalex> jle`: fmap has the same problem
03:01:24 <jle`> DarkCthulhu: liftIO is what we call a "monad morphism".  it allows you to turn one monad into another
03:01:24 <bernalex> "problem"
03:01:27 <tdammers> of course they are implemented state-monad-style, so they're not *actually* impure mutations
03:01:33 <nshepperd> "JS contains mutable variables" arguably is pointing to the side effects
03:01:37 <DarkCthulhu> jle`, Ah.. so that's why. It's because of >>= ?
03:01:39 <jle`> DarkCthulhu: in this case, it lets you turn an (IO a) into a ReaderT r IO a
03:01:41 <nshepperd> "side effects"
03:01:45 <jle`> DarkCthulhu: now you can use (>>=)
03:01:53 <jle`> because you have two ReaderT r IO's
03:01:56 <nshepperd> they are "side" from the PoV of the interpreted JS program
03:01:59 <bernalex> DarkCthulhu: or <$> or anything where input & output has the same "container"
03:02:03 <tdammers> nshepperd: exactly
03:02:05 <dibblego> I have no idea what this javascript thing is about and I'd prefer to keep it trivially debunkable anyway ó because I have done that already
03:02:32 <dibblego> please just write a trivial grammar using Free, then ask your question and watch it fade away into absurdity
03:02:45 <tdammers> dibblego: there is nothing to debunk.
03:02:47 <jle`> DarkCthulhu: you can't just throw an IO action into a do block or (>>=) chain of ReaderT r IO.  every line in a `do` block has to be of the same monad
03:02:58 <jle`> DarkCthulhu: so liftIO transforms something of (IO a) into something of (ReaderT r IO a)
03:03:02 <tdammers> dibblego: there's a pure implementation of an "impure" grammar
03:03:05 <dibblego> tdammers: agree, there are no side-effects in any relationship to IO
03:03:08 <jle`> DarkCthulhu: "monad morphism"
03:03:12 <dibblego> tdammers: that is false
03:03:33 <dibblego> (I am ignoring the double-quotes, which may be negation, in which case, it is true)
03:03:53 <DarkCthulhu> jle`, Got it. Except this one case in which the return type seems weird -> http://pastebin.com/zj2xxHQU
03:04:19 <bernalex> tdammers: the free grammar is pure too
03:04:19 <jle`> DarkCthulhu: what's the deal?
03:04:43 <tdammers> bernalex: by that logic, *all* grammars are pure, and by extension, there is no such thing as an impure language
03:04:47 <DarkCthulhu> jle`, local modified the Gamma and appended (n,ty)?
03:04:52 <dibblego> tdammers: correct, there is no such thing
03:04:53 <bernalex> everything is pure, sunshine, rainbows, unicorns & happy days in haskelland.
03:04:53 <tdammers> and, by extension, side effects do not exist ever
03:05:01 <dibblego> tdammers: yes they do
03:05:06 <bernalex> tdammers: so close! :-D
03:05:12 <bernalex> up until the last post you were on the right track. :-P
03:05:13 <dibblego> just not in haskell, not in IO, not in [], etc
03:05:15 <tdammers> haha
03:05:19 <tdammers> then where?
03:05:21 <jle`> DarkCthulhu: `local` runs (typeOf e) in a new sub-environment where gamma has an extra item before it
03:05:49 <dibblego> there is one in the C# program above, but not in the embedded (Free) program (which is an I/O program ó again *no side-effects*)
03:05:57 <bernalex> brb train ride, lunch, dinner, cafe, haskell meetup, train back... my definition of "right back" might be flawed.
03:06:07 <nshepperd> so whether a javscript program has side effects depends whether you run in on an interpreter implemented on haskell vs one implemented in C?
03:06:08 <dibblego> that side-effect is necessary to interpret the pure, side-effect-free, I/O program to the C# runtime
03:06:17 <bernalex> dibblego: I just skimmed the code, do you mean the demonstration class? it looked side-effectsy to me :-P
03:06:21 <tdammers> what if I implement a C# interpreter in Haskell?
03:06:29 <tdammers> and run your "impure" code on it?
03:06:35 <DarkCthulhu> jle`, ohh.. It evaluates that term itself. and then in the end, it is simply returning TyArrow type1 type2. Isn't that wrong when we see the return value expected?
03:06:38 <dibblego> bernalex: that is entirely pure
03:06:44 * hackagebot postgresql-simple-sop 0.1.0.2 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.2 (glutamate)
03:06:50 <jle`> DarkCthulhu: what do you mean
03:06:54 <dibblego> tdammers: can you please just stick to the trivial examples that really very well demonstrate the point?
03:06:56 <jle`> TyArrow is a constructor for Type
03:07:04 <DarkCthulhu> jle`, It doesn't seem to be returning (ReaderT Gamma IO Type)
03:07:05 <tdammers> dibblego: lol... this *is* a trivial example
03:07:11 <jle`> :t return
03:07:12 <lambdabot> Monad m => a -> m a
03:07:13 <dibblego> tdammers: No.
03:07:16 <tdammers> sure is
03:07:20 <jle`> return :: Type -> ReaderT Gamma IO Type
03:07:22 <raphi011> hey guys, how would you search a string for characters that occur n times (which i have to output after)
03:07:26 <dibblego> bernalex: the Interpret function is a side-effect
03:07:39 <DarkCthulhu> jle`, Ohhh.. return itself does that. Okay, makes sense
03:07:45 <DarkCthulhu> ty
03:07:47 <jle`> yes, return is just a normal ol' function
03:07:47 <bernalex> dibblego: that's the one I meant. wasn't that in the Demonstration class? I just scrolled quickly past the paste.
03:07:51 <tdammers> A C# interpreter in Haskell is fundamentally possible
03:08:02 <bernalex> anyway gotta run to the train station.
03:08:04 <tdammers> it's going to be a very difficult task, but that's an aside
03:08:07 <dibblego> bernalex: no, it is in the TerminalInterpreter class
03:08:14 <bernalex> dibblego: ah ok sorry
03:08:16 <tdammers> your program is just another C# program
03:08:19 <dibblego> bernalex: the Demonstration contains a pure I/O program (and is side-effect free)
03:08:30 <dibblego> just like haskell is, always
03:09:06 <tdammers> it doesn't really matter what it does; if I can feed it to my pure interpreter, then it doesn't have side effects
03:09:26 <tdammers> unless you are willing to subscribe to the notion that side effects are relative to your frame of reference
03:09:48 <dibblego> tdammers: we are hitting a wall. I think it is best for you to explore the subject with exercises as I stated above.
03:09:58 <jle`> night all
03:10:24 <DarkCthulhu> night jle` :)
03:10:26 <dibblego> this is not a contentious issue, just a common misunderstanding, that is easily cleared up
03:10:30 <nshepperd> that's logically rude
03:11:00 <jle`> happy haskelling DarkCthulhu :)
03:11:57 <nshepperd> you could at least try to explain why you think "C# can have side effects" can coexist with "haskell never models side effects" and "there are no impure grammars"
03:12:07 <eazar001> really, what is a side-effect anyway? this dialog has made me forget the definition.
03:12:24 <tdammers> eazar001: the dialog is pretty much about finding a useful definition
03:12:26 <nshepperd> there never was a definition, that's the problem
03:12:33 <dibblego> nshepperd: I have done that several times now. Please stop.
03:12:33 <eazar001> so i do print "hi"
03:12:37 <dibblego> there is a definition
03:12:40 <eazar001> what's the side effect?
03:12:46 <eazar001> memory allocation?
03:12:47 <dibblego> eazar001: there isn't one
03:12:55 <eazar001> no i meant in general
03:12:58 <eazar001> not relative to haskell
03:13:14 <dibblego> side-effect is a property of an expression where replacing the program with its value potential alters that program
03:13:21 <dibblego> again, this is not possible in haskell
03:13:34 <tdammers> indeed it is not
03:13:39 <dibblego> nor does it exist in the C# program above, which I used to try to explain why you think "C# can have side effects" can coexist with "haskell never models side effects" and "there are no impure grammars"
03:14:07 <eazar001> hmmm
03:14:12 <tdammers> but by that definition, my point stands
03:14:20 <dibblego> I also embedded an I/O program in haskell itself, which is side-effect-free
03:14:32 <dibblego> tdammers: no it doesn't, or you'd have poited to this "observation of a side-effect" by now
03:14:39 <nshepperd> are you saying that C# does not have side effects
03:14:43 <tdammers> when you shift your frame of reference such that what you consider a "program" and a "value" changes, then you can run effectful things on top of a pure Haskell interpreter
03:14:44 <eazar001> sounds like what lisp prides itself on
03:14:51 <dibblego> in safe haskell, in the embedded haskell program I gave above, or in the C# program
03:16:22 <dibblego> I can only say, "the C# program above does not have side-effects" so many times. If one takes it to mean "all C# programs do not have side-effects" after having said it this many times, I really think we should consider aborting
03:16:38 <nshepperd> dibblego: so you aren't
03:16:45 <nshepperd> then you are talking past tdammers
03:16:45 * hackagebot semi-iso 0.1.0.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.1.0.0 (pawel834)
03:16:55 <raphi011> hey guys, how would you search a string for characters that occur n times (which i have to output after)
03:16:57 <dibblego> No, I am addressing the point that is false.
03:17:08 <nshepperd> we aren't talking about that specific program, we're talking about the entire C# language
03:17:14 <dibblego> no we aren't
03:17:23 <tdammers> C#, JavaScript, or any other language that allows side effects
03:17:26 <nshepperd> yes we are
03:17:26 <dibblego> you are, off to the side
03:17:37 <dibblego> I am refusing to talk about that, because it misses the point
03:17:44 <dibblego> back to the false point
03:17:51 <dibblego> which is "observable side-effect in IO" ó which is false
03:18:11 <nshepperd> :/
03:18:14 <tdammers> it is false as long as you reason in terms of Haskell
03:18:17 <dibblego> also, I might write pure, side-effect-free programs using JavaScript or C#
03:18:25 <tdammers> that's not the point
03:18:26 <dibblego> it is false *because you must reason in terms of haskell*
03:18:33 <tdammers> says who?
03:18:37 <dibblego> I did.
03:18:46 <tdammers> then you are wrong
03:18:50 <dibblego> show me this alternative where your statement becomes true
03:18:52 <eazar001> wait, so you are defining side-effect as something that threatens consistency of output?
03:18:53 <tdammers> Haskell runs on stateful hardware
03:18:54 <friden> raphi011: make a function that counts the occurences of each character in your string, and puts into a tuple with the character counted, then run a filter for your number and map out the characters from the tuples
03:18:58 <dibblego> point to this observation that you insist holds
03:19:01 <dibblego> ugh
03:19:05 <dibblego> I am stopping now, bye
03:19:05 <tdammers> indeed
03:19:10 <dibblego> crikey almighty
03:19:24 <tdammers> same here :D
03:19:37 <raphi011> friden: sounds good, thanks!
03:20:09 <tdammers> var a = 1; console.log(a); a += 1; console.log(a); // effectful, right?
03:20:49 <tdammers> within the realm of javascript, that is
03:21:05 <tdammers> run it through a JS interpreter written in Haskell
03:21:16 <tdammers> at the Haskell level, it's pure
03:21:34 <exio4> that argument sounds like "x¬≤+y¬≤=z¬≤, it works for 3,4,5; so it works with a lot of numbers!"
03:22:39 <nshepperd> it's more like the opposite of that. you only need one counterexample to falsify a rule
03:23:03 <tdammers> exio4: except that it's reversed - "x¬≤ + y¬≤ = z¬≤, it doesn't work for 1, 2, 3, ergo it does not work for all numbers"
03:23:23 <exio4> no, I mean what dibblego said, he said "I got one program so it must hold all the time"
03:23:30 <tdammers> ah, right
03:23:37 <eazar001> but he said the opposite of that
03:23:42 <eazar001> which is why he was so frustrated
03:23:51 <eazar001> he was trying to say it was possible
03:24:09 <exio4> languages are turing complete, it is possible
03:24:12 <tdammers> I missed that part, honestly
03:24:18 <eazar001> there was a quote
03:24:31 <eazar001> somewhere up there
03:24:33 <dibblego> exio4: you'll notice that this observation (of "side-effects in IO") will never be pointed to (it doesn't exist)
03:24:42 <nshepperd> it is possible that both tdammers and dibblego were trying to say the same thing, and angrily confusing each other's claim for something else
03:24:53 <tdammers> very likely, yes
03:25:00 <dibblego> eazar001: I am not frustrated. I see this mistake regularly, help others come to terms with it. It's just too common to get frustrated over.
03:25:06 <dibblego> nobody is angry
03:25:15 <eazar001> fair enough
03:25:21 <tdammers> no, just frustrated :D
03:25:47 <tdammers> I am actually quite aware of how IO works and how it is totally not effectful
03:26:03 <tdammers> I'm just making two observations here:
03:26:13 <dibblego> IO is effectful
03:26:36 <dibblego> fwiw, I am not frustrated at the persistent abuse of terminology
03:26:52 <trap_exit> someone needs to create a haskell MMORPG
03:27:00 <trap_exit> you level up by typing in idiomatic haskell code
03:27:35 <tdammers> trap_exit: been done, sort of... there's a game where you make up the rules as you go...
03:27:48 <tdammers> trap_exit: can't remember the name...
03:27:53 <trap_exit> what?
03:27:59 <sivteck> nomyx
03:28:03 <trap_exit> i'm after a game, like a text based mud
03:28:03 <eazar001> it might be called github?
03:28:03 <tdammers> yes, that one
03:28:05 <eazar001> =P
03:28:08 <trap_exit> bbut instaed of typing in "cast magic missile"
03:28:16 <trap_exit> I think in things like "map (+1)"
03:28:42 <Ferdirand> hah
03:28:54 <tdammers> trap_exit: nomyx has you define rules in something resembling Haskell, and then the current rules of the game determine if and how your new rule is going to be added
03:28:55 <Ferdirand> NPCs could have weaknesses to some given types
03:29:20 <Ferdirand> and you have to exhibit an implementation of said type to make the most damage
03:29:51 <exio4> why not an high-level corewars?
03:30:03 <exio4> no idea how that would work but...
03:30:14 <tdammers> Ferdirand: this is Haskell. There are no weaknesses in our types.
03:30:19 <Ferdirand> hahaha
03:30:43 <tdammers> if this were C++, ...
03:30:49 <tdammers> dynamic_casts<spell*>
03:30:56 <tdammers> *_cast
03:31:00 <tdammers> pfff
03:31:04 <nshepperd> use the curry-howard isomorphism
03:31:18 <nshepperd> your task is to construct a proof that you've completed the level
03:31:20 <trap_exit> what?
03:31:24 <trap_exit> I don't want nomyx
03:31:32 <trap_exit> I want an addictive game, like everquest
03:31:35 <Ferdirand> nshepperd: that's pretty much the point yes :)
03:31:35 <trap_exit> but text based, in haskell
03:31:56 <trap_exit> imagine world of warcraft ... where a 2 hour session in whatever dungeon ends up being 9 people developing software together
03:32:34 <tdammers> nshepperd: that is oddly relevant to the other discussion :D
03:34:35 <rom1504> trap_exit: first, you need to find 9 haskell dev, that's going to be hard
03:35:04 <trap_exit> alright, I need someone to tank damage, a preist to heal, and a wiz for dealing out damage
03:35:10 <trap_exit> in haskell land, this is equiv to .... ?
03:36:58 <tdammers> trap_exit: I don't think the isomorphism is strong enough
03:38:10 <trap_exit> yeah
03:38:14 <trap_exit> but how badass would it be
03:38:26 <trap_exit> spending time on world of warcraft ==> people contribuging code to hackage
03:40:19 <tdammers> I think just writing the code is more fun
03:40:23 <tdammers> but that's just me
03:42:01 <bartavelle> it would probably be easier to construct such an analogy if every "class" corresponded to a language or programming concept, but then it would enter the land of #haskell-blah I suppose
03:42:12 <bartavelle> in any case it probably already is
03:43:52 <raphi011> hi, can some1 tell me whats wrong with this code?
03:43:53 <raphi011> http://pastebin.com/t9d8z6zC
03:46:39 <ThreeOfEight> raphi011: you are applying occurence to the arguments x and ((==) (abs n))
03:46:50 <ThreeOfEight> but ‚Äòoccurence‚Äô only takes one argument
03:47:19 <ThreeOfEight> (btw, instead of ‚Äò((==) c)‚Äô, you could simply write ‚Äò(== c)‚Äô
03:47:54 <ThreeOfEight> (to be more precise, ‚Äò((==) c)‚Äô is equivalent to ‚Äò(c ==)‚Äô, but equality is commutative, so you might as well write ‚Äò(== c)‚Äô)
03:48:34 <ThreeOfEight> what you may have meant is ‚Äò[x | x <- s, occurence x == abs n]‚Äô
03:49:53 <ThreeOfEight> Also, your two function equations are overlapping. The first one already catches all parameters and maps them to []. I don't quite see why you have the first equation anyway.
04:01:50 * hackagebot blastxml 0.3.2 - Library for reading Blast XML output  http://hackage.haskell.org/package/blastxml-0.3.2 (KetilMalde)
04:21:52 * hackagebot nonce 1.0.1 - Generate cryptographic nonces.  http://hackage.haskell.org/package/nonce-1.0.1 (FelipeLessa)
04:31:00 <vanila> good morning #haskell
04:37:00 <zmbmartin> geekosaur: Are you around by chance?
04:39:25 <crazydave> so I have about 74 questions regarding Show and Read, specifically relating to the time library
04:39:59 <crazydave> I am not so experienced but I have been told that (Read . Show) should be the identity
04:40:39 <crazydave> The time library doesn't do this.  In fact it doesn't derive Show or Read for many of its types
04:42:21 <crazydave> And in other places creates instances of Show that look more like for display purposes (e.g. the instance of Show DiffTime is a number appended with the letter s, with no corresponding Read instance)
04:43:05 <crazydave> I was thinking of cleaning this up, but I have some questions
04:43:19 <crazydave> (1) Won't this break backwards compatibility and thus be bad?
04:43:44 <crazydave> (2) Where should I send my changes to as I don't really want to fork the Library!
04:44:02 <crazydave> (okay only 2 questions but so much lead up it seemed like more)
04:44:20 <RchrdB> crazydave: "(read . show) = id" is only required to hold when both read and show are defined, of course.
04:44:55 <crazydave> oh, (3) is making all the types have Read and Show instances a good idea to begin with?
04:44:59 <RchrdB> aiui it's pretty common to define a Show instance that's just good enough for debugging and deliberately don't define a Read instance
04:46:09 <RchrdB> e.g. you can't meaningfully define a Read instance at all for, say, an open socket or a file descriptor or something, because those really depend on external state that you've got no chance of recreating.
04:47:10 <raphi011> hi! thanks for the help, i still have some minor problem .. http://pastebin.com/ipXEr2DY
04:47:40 <crazydave> RchrdB: sure, those things can't be serialized so that makes sense.  There really is no reason that most (all?) of the types exported by time are serializable.  Only not with the current library implementation.
04:49:05 <RchrdB> crazydave: yeah. Pure data should pretty much always be able to have Read instances.
04:49:11 <crazydave> raphi011: are you aware of the existence of nub? or is this for learning purposes
04:49:38 <RchrdB> might not be possible if the Show instance has oddness like, uh, say hypothetically the Show instance were being naughty and changing its behaviour based on current locale settings...
04:49:57 <crazydave> RchrdB: okay, so then I really should edit the time library and add Show and Read instances and make sure that (Show . Read) == id
04:50:18 <ThreeOfEight> raphi011: you can write removeDuplicates as nub.
04:50:22 <mornfall> RchrdB: using unsafePerformIO in show sounds like a no-go
04:50:24 <Thehelpfulone1> hi all
04:50:24 <ThreeOfEight> it's predefined in Prelude.
04:50:55 <RchrdB> mornfall: hopefully!
04:50:56 <vanila> make a new function with type String -> IO Time
04:50:57 <crazydave> Ahh, but if Show was doing something unusual like that then I would break backwards compat in my change in order to have it be sane
04:51:07 <vanila> then you dontneed unsafe
04:51:27 <RchrdB> the other complication I can think of is, maybe you want to encourage users to use a function like strptime instead of to assume that there's One True Date Format‚Ñ¢
04:51:43 <ThreeOfEight> raphi011: also, you are missing parentheses
04:51:45 <ThreeOfEight> removeDuplicates (x:xs) = [x] ++ (removeDuplicates $ filter (== x) xs)
04:51:52 <RchrdB> (no idea if that applies in context)
04:52:05 <ThreeOfEight> /and/ your function equations for filterForFrequency are still overlapped; the first one matches everything.
04:52:07 <raphi011> ahhh yea .. thought of the paranthesis at the same time
04:52:27 <raphi011> thats why i commented it out
04:52:37 <raphi011> how do i filter the empty list when i have two params?
04:52:50 <ThreeOfEight> you didn't comment it out in the paste
04:53:07 <ThreeOfEight> what do you emean, ‚Äòfilter the empty list‚Äô?
04:53:14 <crazydave> RchrdB: but you are confusing displaying content with Show.  Which is the exact error that is currently being made in the current implementation.  People shouldn't use Show to mean display to user
04:53:38 <raphi011> if the list is empty i want to return an empty list
04:53:50 <crazydave> I think you mean "filterForFrequency [] _ = []" because you only want to match on empty list .... not every list
04:54:01 <ThreeOfEight> raphi011: it will already do that
04:54:07 <ThreeOfEight> but yes, what crazydave said.
04:54:43 <crazydave> Also, what ThreeOfEight said.  Your function doesn't need to treat the empty list as a special case in this instance.
04:54:43 <raphi011> aah yea, thats i wanted ..
04:55:10 <crazydave> so his advice is better (mine will work ... but hlint should complain ... might not ... but should)
04:55:43 <ThreeOfEight> crazydave: my advice: do not perform needless case distinctions.
04:56:10 <ThreeOfEight> Your code will be easier to understand, less prone to bugs, and more maintainable if you strive for unity wherever possible.
04:56:26 <crazydave> Yep, that's very good advice.
04:56:31 <ThreeOfEight> also, use nub instead of your removeDuplicates.
04:56:52 <ThreeOfEight> Because a) library functions tend to be faster (or at least no slower) than code you write yourself
04:57:07 <ThreeOfEight> b) library functions tend to be more bug-free than code you write yourself
04:57:33 <ThreeOfEight> c) other programmers reading your code will probably know library functions (such as nub), but in order to understand your code, will first have to understand removeDuplicates
04:57:34 <raphi011> it`s an university assignment, i should probably implement it by myself
04:57:41 <ThreeOfEight> (although in this instance it's pretty obvious what it does)
04:57:59 <ThreeOfEight> ah well, in that case, it depends, I suppose, on which library parts you are allowed to use
04:58:18 <ThreeOfEight> it's always a good idea to implement stuff yourself to practise though
04:58:20 <raphi011> every one in the hugs standard library
04:58:27 <ThreeOfEight> so in that case, never mind :)
04:58:34 <raphi011> removeDuplicates doesn`t seem to work though ..
04:59:02 <ThreeOfEight> indeed, it doesn't
04:59:14 <ThreeOfEight> you probably want a (/= x) in there, not a (== x)
04:59:26 <ThreeOfEight> filter retains all elements that fulfil the predicate you give
04:59:34 <ThreeOfEight> it does /not/ remove all elements that do not fulfil it
04:59:36 <raphi011> haha 50% chance of havin it wrong
04:59:43 <ThreeOfEight> the naming is a bit ambiguous, I suppose
04:59:58 <raphi011> it works!!!!!
05:00:12 <raphi011> thanks i`m coming to love this channel
05:00:54 <ThreeOfEight> You're welcome :)
05:01:46 <crazydave> so my next question: if (as seems to be the case) time should export Show and Read instances, with (Show . Read) == id, then after I've made the changes where do I send it (other than maintainer obviously)
05:02:38 <ThreeOfEight> raphi011: btw, nub is in Data.List, even in Hugs.
05:02:59 <ThreeOfEight> but as I said, always a good idea to implement stuff yourself when learning a language.
05:03:29 <raphi011> ill remember that, but now that i`ve implemented it myself i don`t want to delete it :P
05:03:48 <raphi011> maybe ill need it for the next assignment
05:03:55 <ThreeOfEight> But my experience considering exams and homework: The more code a student writes, the more likely it is to be wrong and/or inefficient.
05:03:57 <raphi011> brace yourselves :D
05:04:22 <raphi011> well they explicitly said we don`t need to use library functions
05:04:28 <ThreeOfEight> (well, unless it's too little code, e.g. no code at all or ‚Äòf = undefined‚Äô)
05:04:57 <crazydave> hmmm, isn't filter a library function?
05:05:02 <ThreeOfEight> raphi011: you are using filter, length, ‚Ä¶
05:05:11 <raphi011> well yea - but i didn`t have to import anything
05:05:22 <raphi011> i would have to do that with nub - wouldn`t i ?
05:05:25 <ThreeOfEight> ah, okay, so only Prelude
05:05:30 <ThreeOfEight> yes, nub is defined in Data.List
05:05:38 <ThreeOfEight> length and filter are in Prelude, which is imported automatically
05:05:47 <raphi011> ah ok - good to know
05:05:52 <ThreeOfEight> you don't really need removeDuplicates here anyway
05:05:53 <raphi011> started learning haskell yesterday ..
05:06:15 <raphi011> is there another way without using nub?
05:06:19 <ThreeOfEight> you could write filterForFrequency recursively
05:06:30 <ThreeOfEight> for [], you return the empty list
05:07:02 <ThreeOfEight> and for (x:xs), you call filterForFrequency recursively with ‚Äòxs without everything equal to x‚Äô
05:07:49 <ThreeOfEight> again, I am quite impressed. For someone who started learning it yesterday, you are doing quite well.
05:08:01 <raphi011> hm ok .. i`ll try that after the last assignment because it`s due in 2 hours :D
05:08:38 <raphi011> thanks, but most of the time i don`t know what the hell i`m doing :/
05:09:00 <ThreeOfEight> All it takes is some experience :)
05:09:45 <raphi011> and patience haha
05:12:19 <komanda1> https://www.youtube.com/watch?v=ErvgV4P6Fzc
05:13:46 <rgr> raphi011: have a read of all the smarty pants answers to his Q here - the subject is huge and one Q invariably leads to another more complex one :) http://stackoverflow.com/questions/12413495/what-are-the-benefits-of-currying
05:17:07 <raphi011> i will!
05:20:25 <batchm-> > (filter (\x -> length x == 3) . group . sort) "asdfaaff"
05:20:26 <lambdabot>  ["aaa","fff"]
05:21:32 <RchrdB> crazydave: yeah, I suppose.
05:25:52 <hellertime> is there some way to flatten a (Vector (Vector a)) without first converting the outer vector to a list?
05:27:14 <dibblego> hellertime: join
05:27:24 <vanila> hellertime, where is vector defined?
05:27:48 <hellertime> in the vector package
05:27:52 <hellertime> Data.Vector
05:28:10 <hellertime> Data.Vector.Unboxed is the particular one I'm using
05:28:50 <hellertime> dibblego: join from Control.Monad?
05:30:17 <dibblego> hellertime: Yes.
05:31:22 <vanila> looking at source to concat http://hackage.haskell.org/package/vector-0.9.1/docs/src/Data-Vector-Generic.html seems that goingthrough a list is probably optimal - you could allocate one of correct length then use modify to write each subvector over
05:34:15 <hellertime> ok I'll play around with this some more
05:37:00 * hackagebot uu-cco 0.1.0.0 - Utilities for compiler construction  http://hackage.haskell.org/package/uu-cco-0.1.0.0 (AtzeDijkstra)
05:37:02 * hackagebot uu-cco-examples 0.1.0.0 - Utilities for compiler construction  http://hackage.haskell.org/package/uu-cco-examples-0.1.0.0 (AtzeDijkstra)
05:37:05 * hackagebot uu-cco-hut-parsing 0.1.0.0 - Utilities for compiler construction  http://hackage.haskell.org/package/uu-cco-hut-parsing-0.1.0.0 (AtzeDijkstra)
05:37:06 * hackagebot uu-cco-uu-parsinglib 0.1.0.0 - Utilities for compiler construction  http://hackage.haskell.org/package/uu-cco-uu-parsinglib-0.1.0.0 (AtzeDijkstra)
05:42:57 <zmbmartin> Is it possible to ask for my ReaderT env in an IO monad? I need to runReaderT so I need the env but I don't have it in this function right now.
05:44:02 <zmbmartin> If I try env <- ask I get expected IO actual ReaderT errors.
05:44:32 <vanila> zmbmartin, you would need to use ReaderT of IO, or an IO ref instead of reader
05:45:17 <zmbmartin> vanila: Not sure what you mean by ReaderT of IO
05:47:01 <vanila> the monad transformer stack
05:47:38 <bartavelle> zmbmartin, `ReaderT env IO`
05:47:40 <tdammers> you cannot stack IO on top of Reader, only the other way around
05:48:39 <tdammers> ask works on that stack, but you need to use liftIO or something like that for IO actions
05:49:11 <Guybrush_T> Hi guys! i have a question concerning strings and lists. I have a string but in a function i want to have something like this: [ c | c <- str, BoolFunc(c), ... ] . So i want an character list in the end, boolFunc takes a Char, not a string. How can i accomplish that
05:49:26 <zmbmartin> OK let me work with that and see what I get. Thanks guys!
05:49:43 <zmbmartin> monad transformers are still boggling me a bit.
05:49:52 <tdammers> Guybrush_T: a String is a list of Char
05:50:22 <tdammers> Guybrush_T: and I wouldn't use a comprehension for this
05:50:23 <Guybrush_T> tdammers, i know, that's why i thought c <- str would take each char out of the string
05:50:37 <tdammers> filter boolFunc str
05:50:47 <tdammers> is all you need
05:50:58 <tdammers> :t filter
05:50:59 <lambdabot> (a -> Bool) -> [a] -> [a]
05:51:06 <tdammers> does that make sense to you?
05:51:32 <tdammers> (the 'a' in that type signature can be Char, then it works on Strings)
05:52:02 <dfeuer> Bigglebaggle.
05:52:47 <tdammers> filter isSpace "foo\tbar "
05:52:49 <tdammers> > filter isSpace "foo\tbar "
05:52:51 <lambdabot>  "\t "
05:52:58 <tdammers> like so
05:53:29 <pavonia> > [ c | c <- "foo\tbar ", isSpace c ]
05:53:30 <lambdabot>  "\t "
05:53:55 <Guybrush_T> tdammers, it makes sense, but i wanted to use another function like this : filterForFrequency s i = [c | c <- remDups(s), letterCount(s, c) == i] where remDups removes duplicates from a string and letterCount checks how often a character occurs in a string
05:54:21 <Guybrush_T> so it needs to check of the character count equals i too
05:54:37 <zmbmartin> vanila: I got it now. Thanks for the help! Thanks to everyone else who responded as well.
05:55:27 <pavonia> Guybrush_T: What's the problem with this code?
05:56:35 <Guybrush_T> pavonia, Couldn't match expected type ëChar -> Intí with actual type ëIntí BREAK    In the second argument of ë(==)í, namely ëií BREAK   In the expression: letterCount (s, c) == i
05:57:24 <pavonia> What is the type of letterCOunt?
05:57:26 <raphi011> hey guys, I have one last problem - i have a [Char] with vowels upper/lowercase and i need to sum up the occurence of every single char and multiply them with the occurence of the others
05:57:30 <Guybrush_T> letterCount :: String -> Char -> Int
05:57:41 <bartavelle> Guybrush_T, you probably need to "thread" some state if you want to count stuff as you progress through the list
05:58:26 <Guybrush_T> bartavelle, sorry I'm not sure what that means. Unfortunately I only started haskell a few days ago
05:58:27 <pavonia> Guybrush_T: In Haskell function application is denoted without parentheses but with spaces, i.e. letterCount s c, not letterCount(s, c)
05:58:39 <Guybrush_T> ah!
05:59:04 <pavonia> (s, c) is a single parameter, namely a pair of a String an Char
05:59:14 <bartavelle> (Guybrush_T, don't worry then, I just meant that I suppose letterCount traverses the list to count, so this will result in quadratic complexity, which is probably not a problem for you)
06:01:09 <Guybrush_T> pavonia, THANKS! It's so frustrating if you fail at such a little thing
06:01:31 <Guybrush_T> i was searching everywhere but not at the function call
06:01:44 <pavonia> Have you read a Haskell introduction yet?
06:01:51 <pavonia> @lyah
06:01:51 <lambdabot> Unknown command, try @list
06:01:57 <pavonia> @where lyah
06:01:57 <lambdabot> http://www.learnyouahaskell.com/
06:02:06 <raphi011> can some1 help me?
06:02:26 <vanila> sure
06:02:27 <vanila> whats up
06:02:33 <Guybrush_T> yes, and i realized the error as soon as you said, but for my java eyes it just didn't seem wrong at all
06:02:37 <raphi011>  i have a [Char] with vowels upper/lowercase and i need to sum up the occurence of every single char and multiply them with the occurence of th
06:02:45 <raphi011> others
06:03:27 <tdammers> raphi011: which part are you stuck on?
06:03:53 <raphi011> tdammers: well i already filtered out the string so that it only contains the vowels
06:04:00 <tdammers> ok
06:04:17 <tdammers> so now you need to build a list of characters and their frequencies?
06:04:19 <raphi011> and then i don`t quite know how to continue
06:04:26 <raphi011> yea probably
06:04:44 <tdammers> skim through Data.List and see if there's anything you could use there
06:04:54 <raphi011> i want to try it without data.list
06:05:06 <tdammers> why?
06:05:13 <raphi011> for learning purposes
06:05:42 <tdammers> I'd say learn one thing at a time
06:05:58 <tdammers> can always implement the Data.List functions for exercise
06:06:55 <gigabytes> hello all
06:06:57 <gigabytes> I have a nasty problem
06:06:59 <gigabytes> http://pastebin.com/8DZggLCU
06:07:10 <gigabytes> these are errors from cabal when trying to install some package
06:07:30 <gigabytes> I'm on OS X
06:07:32 <tdammers> anyway, as far as the grouping goes, you'll first want to decide on a data structure to use for the result you want
06:08:03 <tdammers> something like [(Char, Int)] maybe - it's not the most efficient one, but it'll do for learning
06:08:03 <gigabytes> this happens after these steps: 1) Installed platform with Homebrew long ago, worked fine. 1) Updated to Yosemite. 3) Removed the brew version and installed haskell platform
06:08:12 <gigabytes> from the binary distribution
06:08:36 <tdammers> then you need a function that iterates over your string and drags such a list of counters along
06:09:03 <tdammers> if you can afford to pre-sort the input, things are going to be a lot easier
06:09:16 <raphi011> hm - is it somehow possible that i get a list from the occurences? i don`t really need to know that characters
06:09:33 <raphi011> e.g. if i have "aaee" -> [2,2]
06:09:38 <tdammers> sure
06:09:51 <tdammers> in that case, your data structure is [Int] eventually
06:10:14 <raphi011> that would be the best way because i could simply use `product` on that
06:10:33 <raphi011> but i`m not sure how to create that list
06:10:35 <tdammers> so: sort your input, split into groups of equal characters, take the lengths of each group
06:10:42 <tdammers> :t sort
06:10:43 <lambdabot> Ord a => [a] -> [a]
06:10:45 <tdammers> :t group
06:10:46 <lambdabot> Eq a => [a] -> [[a]]
06:10:49 <tdammers> :t map
06:10:50 <lambdabot> (a -> b) -> [a] -> [b]
06:10:53 <tdammers> :t length
06:10:54 <lambdabot> [a] -> Int
06:11:00 <tdammers> these are your building blocks
06:11:09 <raphi011> i`ll try that
06:12:02 <zmbmartin> ok I was wrong I don't have it.
06:12:43 <tdammers> (obviously if you can't afford to pre-sort, you'll need to take a different route)
06:13:40 <zmbmartin> I have a type TnIO = ReaderT TnConfig IO and a getByToken which returns TnIO (Either Response (Maybe User))
06:13:41 <zmbmartin> https://gist.github.com/codedmart/d3cacabc6a74e3227d90
06:13:55 <zmbmartin> I want to transform the TnIO to IO
06:14:21 <triliyn> :t runReaderT
06:14:22 <lambdabot> ReaderT r m a -> r -> m a
06:14:48 <triliyn> So you can call runReaderT and then supply a TnConfig
06:15:18 <zmbmartin> triliyn: I know that but I don't have access TnConfig in this function.
06:15:27 <zmbmartin> And if I ask then I get type errors.
06:15:50 <zmbmartin> So is the a whole other problem?
06:16:24 <triliyn> You need a TnConfig to get an IO action out of that, yeah
06:16:30 <tdammers> IO doesn't know anything about TnConfig. ReaderT TnConfig needs a TnConfig to read from. You will need one, otherwise the reader doesn't make sense
06:16:46 <triliyn> You might want to restructure your program so that either you have access to a TnConfig here, or the conversion happens somewhere else
06:17:12 <zmbmartin> That is what I am running against I guess.
06:17:23 <zmbmartin> I need access to TnConfig in a few places.
06:17:45 <zmbmartin> This is a scotty web app so I am not sure where I can put that right now.
06:17:57 <tdammers> ah, hehe
06:18:50 <zmbmartin> I was hoping there was another way.
06:21:31 <triliyn> You need to produce a TnConfig somehow
06:22:15 <zmbmartin> triliyn: I do within the context of the scotty app. That all works fine.
06:22:40 <tdammers> if you load the config at startup, you can close over it
06:22:47 <zmbmartin> But now I am trying to write some middleware which is somewhat outside of the scotty app so I need access to TnConfig there.
06:22:59 <zmbmartin> tdammers: What do you mean close over it?
06:23:21 <tdammers> write a function that takes the configuration as its first argument
06:23:35 <tdammers> and returns a Scotty route (or Action)
06:23:54 <tdammers> myAction :: TnConfig -> Action
06:24:12 <tdammers> myAction conf = runReaderT conf theRealAction
06:24:29 <tdammers> and then in your routing, you use myAction theConfigurationYouJustLoaded
06:24:36 <tdammers> instead of just myAction
06:24:46 <tdammers> does that make sense?
06:25:01 <tdammers> (the same trick works for middleware, btw)
06:26:37 <zmbmartin> tdammers: Hmm‚Ä¶ let me take a look, and see if I understand what you are saying.
06:30:10 <zmbmartin> tdammers: Is this enough info? Can I adapt this similar to what you are suggestion? https://gist.github.com/codedmart/d3cacabc6a74e3227d90#file-auth-hs-L6
06:31:20 <zmbmartin> I mean I can pass TnConfig to routes then to my middleware but that feels wrong to me.
06:31:42 <zmbmartin> Would that be acceptable?
06:33:51 <crazydave> "gigabytes: I'm on OS X".  That might be your first problem there.  It is almost like POSIX systems but not quite
06:34:41 <crazydave> I'm no OS X expert but it _looks_ like you don't have permission to write where cabal wants to write things to.  You could try changing your cabal config or perhaps you need to run cabal as admin?
06:34:55 <absence> are association lists useful for anything except inserting and looking up? can't see an obvious way to replace a key's value for example, though i guess it would be possible to delete the whole key,valye pair and reinsert with new value
06:35:52 <gigabytes> crazydave: that's not a problem at all, given that it's an explicitly supported platform and Platform worked fine since always. Anyway being "POSIX" means nothign nowadays. Even Windows NT is POSIX for what is worth
06:36:18 <gigabytes> no it's not a permission problem
06:36:22 <gigabytes> don't know what happened
06:36:31 <gigabytes> I've removed everything and reinstalled and now it works
06:36:36 <triliyn> absence: association lists have inefficient replacing behavior, but you can shadow a key in constant time (by inserting a new key,value pair at the front)
06:36:38 <gigabytes> the update from 10.9 to 10.10 broke something
06:36:48 <gigabytes> (reinstalled platform, not the OS)
06:37:06 <crazydave> gigabytes: supported means Haskell Platform will run.  That it has, other libraries might not support OS X (or other platforms for that matter)
06:37:32 <absence> triliyn: good point. guess it won't take much to push me towards Map or something :)
06:37:37 <gigabytes> crazydave: that was not a problem of the packages being built. It was a problem from cabal
06:37:45 <gigabytes> or ghc
06:38:49 <zmbmartin> tdammers: Any suggestions? I appreciate the help.
06:41:30 <tdammers> zmbmartin: why does it feel wrong?
06:41:49 <tdammers> oh wait, you can of course use ScottyT instead of plain Scotty
06:42:00 <tdammers> ScottyT can sit on top of any monad stack you like
06:42:34 <tdammers> yeah, that's what I did
06:42:35 <zmbmartin> tdammers: I am using scottyT just not sure how to access that in middleware I guess.
06:42:35 <tdammers> type Handler = ScottyT Text (ReaderT ServerState IO)
06:42:59 <tdammers> yeah, no, I think the middleware is pretty much completely outside the realm of scotty
06:43:30 <tdammers> middleware functions work on the raw requests and responses
06:43:42 <tdammers> all scotty does in that regard is provide a convenience function to install them
06:43:49 <zmbmartin> tdammers: Yeah I think so to. So passing in TnConfig to middleware is my only option then?
06:44:05 <zmbmartin> Then I can runReaderT fine, I just thought is felt wrong.
06:44:27 <tdammers> I think so, yes
06:45:10 <tdammers> but, consider this
06:45:20 <tdammers> middleware typically has a very specific purpose
06:45:37 <tdammers> and most likely, most of your middleware modules don't need access to the entire configuration
06:45:52 <tdammers> you could use this opportunity to make your dependencies more narrow
06:46:09 <tdammers> i.e., pass only the needed subset of config information to your middleware when you construct it
06:46:22 <tdammers> just a thought
06:46:30 <zmbmartin> tdammers: I thought of that a little. I really only need to pool to run a query against the db
06:46:46 <zmbmartin> *the pool (connection)
06:47:01 <tdammers> hmm, db queries from middleware... not sure if I like that idea...
06:47:39 <zmbmartin> tdammers: I want to do token based auth. Thought middleware would be a good place. No?
06:49:50 <Yutht> someone here is an expert of cinema 4d ?
06:49:56 <meretrix> Is it possible to tell cabal to include the 100's of packages installed in my home directory as dependencies when using a sandbox rather than having to install them all again in every new sandbox?
06:50:03 <tdammers> zmbmartin: not really... the thing is, you don't want to do the token auth on routes that don't require authentication
06:50:20 <tdammers> zmbmartin: which means your middleware would also have to hook into your routes
06:50:26 <tdammers> zmbmartin: things can get messy
06:51:10 <tdammers> zmbmartin: I prefer just having a wrapper that turns a regular Action into one that requires authentication and handles failure appropriately
06:51:21 <tdammers> then I just stick that onto every route that requires authentication
06:51:25 <tdammers> so for example:
06:51:34 <zmbmartin> tdammers: So my first approach was a to pass the Action to a checkAuth func that if the user was auth then pass the action through.
06:52:00 <zmbmartin> But then I wasn't sure how to use the Req vault to stash the currentUser for down the chain.
06:52:42 <tdammers> ah
06:52:52 <tdammers> in my case, authentication failure just redirects
06:53:02 <zmbmartin> tdammers: So I started going down this road. I just filter out the routes that I don't want auth in in the middleware (granted I did think this was weird) but I am just trying different options.
06:53:04 <tdammers> it doesn't pass through at the routing level, it actively redirects
06:53:11 <Ulrar> Scotty looks awesome, didn't know it existed
06:53:26 <tdammers> so basically, my authentication wrapper is of type:
06:53:40 <tdammers> (User -> Action) -> Action
06:53:56 <tdammers> something like:
06:54:19 <tdammers> get "/pages/edit" $ withAuthenticatedUser $ \user -> do {  ... }
06:54:36 <tdammers> where the ... is the actual workload
06:54:42 <zmbmartin> tdammers: Hmm‚Ä¶ I just need a way to checkAuth modify the Req so I can stash the user in the req vault to be able to do other authorization or db scope later.
06:54:59 <zmbmartin> tdammers: Hmm‚Ä¶ I wonder if your approach would work for me.
06:56:22 <zmbmartin> So with your approach I would need to use Req vault because I have access to the user in the lambda.
06:56:49 <zmbmartin> tdammers: Is that right. So I could pass user to the model to scope/authorize.
06:57:06 <tdammers> the model should not know anything about the request
06:57:16 <tdammers> but yes, you'd pass the user to the model for authorization
06:57:33 <zmbmartin> I agree just trying to get into web dev with haskell.
06:58:51 <zmbmartin> tdammers: So what does withAuthenticatedUser look like?
07:00:16 <felixsch> Anyone know if there is a function to set the WM Class name of a window in gtk3 haskell package?
07:03:53 <tdammers> zmbmartin: something like get user ID from session (through a session cookie read from the request), call into persistance layer to get the corresponding user, call the payload action with the user if found, redirect to a "no dice" route if any of the steps fail
07:04:03 <tdammers> I think I use a MaybeT there or something like taht
07:04:26 <zmbmartin> tdammers: OK I will try that approach. Thanks!
07:06:57 <tdammers> only thing I'm not completely happy with is how it makes unauthenticated access the default and requiring authentication the exception
07:10:43 <raphi011> tdammers: thanks for the help, this is my solution http://pastebin.com/X5hv4ahg
07:10:58 <Evilsparza> hey, what do I have to import to use "if'" (if with apostrophe)?
07:11:09 <Evilsparza> neither hoogle nor google returned anything
07:11:31 <kadoban> Evilsparza: What's it supposed to do?
07:12:28 <Evilsparza> it was returned from a pointfree query (it's just short for if-then-else) as stated here http://www.haskell.org/haskellwiki/If-then-else
07:13:18 <zeitgeist> ‚Äú
07:14:06 <tdammers> if' c t f = if c then t else false -- that's about it, right?
07:14:18 <tdammers> uhm s/false/f/
07:17:11 * hackagebot yesod-gitrepo 0.1.0.0 - Host content provided by a Git repo  http://hackage.haskell.org/package/yesod-gitrepo-0.1.0.0 (MichaelSnoyman)
07:17:12 <shiona_> btw is there a base library function g :: (a -> Bool) -> (a -> a) -> a -> a; g p f x = if p x then f x else x?
07:18:16 <tdammers> shiona_: smells a bit like the maybe function with boolean blindness added
07:18:32 <tdammers> :t maybe
07:18:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:19:01 <shiona_> yes, but I feel sometimes the boolean version would also be nice
07:20:29 <zmbmartin> tdammers: Thanks again! I think I can live with this approach for now.
07:27:12 * hackagebot persistent-odbc 0.2.0.0 - Backend for the persistent library using ODBC  http://hackage.haskell.org/package/persistent-odbc-0.2.0.0 (gbwey)
07:31:10 <Evilsparza> is there something like takeWhile for two lists? i.e. take something from 2 lists while a function in one list is True
07:31:57 <bartavelle> anyone could venture a good data structure for a key/value ordered, constant size database, where the key is time and the oldest is evinced at every write ? It needs to be persisted on disk so it would be better if it minimized the amount of IO during writing (it can be slow for reading)
07:32:08 <vanila> Evilsparza, you could do it nicely with a list comprehension
07:32:25 <Evilsparza> ah forgot about those, thanks
07:32:42 <bartavelle> I suppose it should be designed like some kind of cache system, but I have no idea on how to get good disk efficiency
07:34:04 <bartavelle> hum, I'll just say you can't insert data with a key that's less than the currently highest key and make it a round robin data structure
07:34:14 <bartavelle> thanks for rubber ducking :/
07:36:39 <EvanR> basically a queue?
07:36:42 <Ferdirand> bartavelle: so what if the insert key is lower than the lowest key in the database ? the write gets ignored ?
07:36:51 <ocharles> That's weird... if I have `data Window = MkWindow (Ptr ()) Int` and define `pattern Window ptr <- MkWindow ptr _`, pattern matching like `foo (Window ptr) = ...` is non-exhaustive
07:36:54 <ocharles> Am I missing something?
07:36:56 <bartavelle> Ferdirand, or you get an error, yes
07:37:05 <ocharles> GHC wants me to add `foo _ = ...`, but that case looks impossible
07:37:06 <bartavelle> EvanR, sort of, but constant size
07:37:39 <EvanR> like, its starts with N things in it already?
07:37:42 <EvanR> or max size
07:37:44 <bartavelle> yes
07:37:53 <bartavelle> it's start with dummy values
07:37:58 <bartavelle> it starts
07:38:01 <EvanR> spooky ;)
07:38:08 <bartavelle> oh not that much ;)
07:38:39 <EvanR> what happens if you use a dummy value
07:39:15 <bartavelle> it doesn't matter, it's for time series, so I'll just put 0's at 1970-01-01 00:00:00
07:39:53 <EvanR> about how big is N?
07:39:59 <bartavelle> ~1000
07:40:18 <bartavelle> it's like RRD, but with varying intervals between values if you want
07:40:57 <Lewix> please
07:41:10 <Lewix> how's the job market for haskell
07:41:33 <Lewix> it doesn't seem very fruitfull
07:41:53 <sinelaw> purely functional.
07:43:04 <Kinnison> http://careers.stackoverflow.com/uk/jobs/tag/haskell
07:43:26 <bartavelle> Lewix, I would say there aren't many opportunities, but most of them seem great. The only problem is that everyone wants to work in Haskell, and most of them are better than me.
07:44:05 <Lewix> any functional programming languages out there that has a good demand in the workplace?
07:44:24 <vanila> fp is niche
07:44:30 <tdammers> statistically speaking the workplace doesn't want FP
07:44:33 <vanila> learn many of them to maximize your chances
07:44:37 <bartavelle> I *think* the biggest might be scala
07:44:39 <S11001001> Lewix: skip to 13:45 http://www.haskellcast.com/episode/008-ollie-charles-on-24-days-of-hackage-and-nix
07:44:59 <Lewix> vanila: I don't have that luxury
07:45:11 <Lewix> tdammers: good to know
07:45:19 <tdammers> an alternative strategy is to go for languages that sneak FP in through the back door
07:45:23 <tdammers> C# for example
07:45:31 <tdammers> JavaScript, too
07:45:47 <tdammers> (I know, it's kind of a shitty language, but still - at least you get real closures and such)
07:45:49 <Lewix> javascript?
07:45:54 <tdammers> sure
07:45:55 <Lewix> ruby
07:45:58 <Lewix> then
07:45:58 <komanda1> scala
07:46:01 <Lewix> how about Go
07:46:13 <komanda1> no
07:46:13 <tdammers> not a huge demand for go yet
07:46:13 <Lewix> if we're just talking about closures
07:46:20 <EvanR> Lewix: clojure
07:46:39 <bartavelle> also Go doesn't seem to have much FP features
07:46:41 <tdammers> if we're talking mainstream languages, the most functional ones are probably C# and JS
07:46:49 <Lewix> i would say ruby
07:46:53 <Lewix> too
07:46:53 <tdammers> scala, if you consider that mainstream
07:46:59 <tdammers> ruby, not so sure
07:47:15 <EvanR> ruby is very dysfunctional
07:47:22 <EvanR> the ecosystem, the practice
07:47:25 <Lewix> a lot of C# features  were inspired a lot by ruby
07:47:40 <Lewix> EvanR: what do you based that on
07:47:43 <Lewix> I disagree
07:47:46 <EvanR> having used it for years
07:47:47 <tdammers> C# incidentally owes a lot to Haskell, actually
07:48:18 <Lewix> vanila: I have just listened to it. I see
07:48:31 <Lewix> tdammers: is it fun working with C#
07:48:32 <tdammers> ruby looks somewhat nice as a language... python minus some of the bad design decisions
07:48:50 <EvanR> ruby can be good, but it will not really be functional at any point
07:49:00 <tdammers> but the community and what I've seen in terms of library ecosystem doesn't look very promising, really
07:49:17 <EvanR> there are few good libraries
07:49:17 <ddellacosta> EvanR: for some definition of functional--it's a lot more functional than many languages, in the sense of functions being first-class
07:49:30 <stelleg> So I thought I remember Data.Typeable being able to handle polymorphic functions, but now I can't seem to get that to work. Am I remembering incorrectly?
07:49:31 <bartavelle> the "official" implementation is a mess too
07:49:39 <Lewix> tdammers: the ruby community is probably  one of the strongest - this is why they took the web by storm with ruby on rails
07:50:08 <EvanR> ddellacosta: you can make a lambda or proc locally and use it, and it will be non-idiomatic, and it will be clumsy. You can't use functions in general though, its too clumsy and unpopular
07:50:09 <tdammers> "took the web by storm"?
07:50:12 <Lewix> tdammers: I don't know much about C#
07:50:16 <Lewix> maybe I should look into it
07:50:20 <tdammers> last time I checked, PHP is still king
07:50:24 <tdammers> for better or worse
07:50:29 <tdammers> (much worse, but hey)
07:50:30 <S11001001> Scala has some niceties like higher kinds and a funky encoding of typeclasses, but beware: https://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu (by way of edwardk)
07:50:43 <ddellacosta> EvanR: yeah, I mean, it's all relative--compared with Python I find it a lot easier to write "functional" code
07:50:48 <ddellacosta> (in Ruby)
07:50:52 <tdammers> and frankly, outside of Rails, I haven't seen a lot of killer apps
07:51:17 <Lewix> tdammers: chef, puppet...
07:51:23 <tdammers> now, Ruby-the-language combined with Pythons library ecosystem; I could live with that
07:51:49 <tdammers> Lewix: neither of which are specifically web-related
07:51:56 <ddellacosta> tdammers: Rails is a killer app, but the codebase is awful in my experience
07:52:10 <EvanR> ruby libs like to advertise "DSLs" which equates to overloading method missing so the user can stream side effecting instructions
07:52:18 <EvanR> with less typing
07:52:19 <bartavelle> for some reason, people accept things in ruby they wouldn't accept with other technologies
07:52:32 <bartavelle> for example the main implementation is horribly slow
07:52:36 <Lewix> people i met who used django and rails mostly prefer rails because of the libraries that come with it
07:52:45 <bartavelle> the preferred method to keep memory usage under control for long lived process is to restart them
07:52:49 <tdammers> django and rails are both pretty terrible
07:52:50 <Lewix> pyton is favored in the scientific world not the web
07:53:00 <bartavelle> I had to rewrite most of server-side puppet because it had terrible performance problems
07:53:15 * Lewix loves how people diss technloogy they never really used
07:53:15 <tdammers> but that's mostly because they don't match up with my minimalist approach
07:53:26 <EvanR> bartavelle: that is a good thing, people should be more concerned with getting correct software written fast and easy
07:53:30 <ddellacosta> Lewix: I was a Rails dev for three years
07:53:41 <bartavelle> Lewix, I have had to maintain a handful of ruby apps in production
07:53:44 <Lewix> ddellacosta: what's a good stack for you ?
07:53:50 <tdammers> also, as far as web dev goes, there are two schools of thought
07:53:54 <bartavelle> Lewix, I think ruby appeals to the people that sell a website, then start to work on another
07:54:02 <bartavelle> Lewix, maintenance is terrible
07:54:03 <ddellacosta> Lewix: it is a piece of shit and bad practices are endemic in the Ruby community
07:54:05 <sivteck> TALK ABOUT HASKELL!
07:54:15 <ddellacosta> sivteck: good point.  I will bow out now
07:54:19 <bartavelle> sivteck, yup
07:54:19 * ddellacosta takes his leave
07:54:29 <Lewix> ddellacosta: bad practices is everywhere, it's a matter of luck
07:54:37 <tdammers> one of them is about understanding things, building a good model, and writing code that is easy to reason about
07:54:55 <Lewix> do you work on a app that was well designed or not..you can't really choose your luck sometimes
07:54:59 <tdammers> the other one is about picking a black box, and then fiddling with the buttons on it until you get something that looks about right
07:55:11 <tdammers> sadly, most web dev folks subscribe to the latter
07:55:29 <Lewix> ddellacosta: I'm just curious, what's the stack that is on point IYO then
07:55:38 <S11001001> sivteck: sorry *sheepish*
07:56:05 <tdammers> Lewix: the one framework to rule them all doesn't exist, and likely never will. That is the most important lesson I guess.
07:56:25 <absence> this being #haskell it would have to be yesod or something :D
07:56:33 <Lewix> well to judge that something is bad or good you need a unit of measurement
07:56:36 <Lewix> what you base it on
07:56:37 <tdammers> If you want to build a blog, then by all means, pick an existing blogging framework and build on top of that
07:56:52 <Lewix> what do you compare it ot
07:57:01 <tdammers> but if you need to build something novel, it's kind of a stupid idea to use a framework that makes other assumptions
07:57:21 <tdammers> and for what it's worth, both django and rails make an awful lot of assumptions
07:57:36 <tdammers> which is great for projects where those assumptions hold
07:57:42 <EvanR> i compare web programs reality with some abstract sense of something that "just makes more sense and is simpler" that i get from writing haskell programs
07:57:59 <mgsloan> bartavelle: That's an interesting, and scary point.  I hadn't really thought of the case of engineering software without regard to maintainability...
07:58:19 <bartavelle> mgsloan, I would say it's the norm for "service companies"
07:58:33 <bartavelle> but I'm French, where the culture is peculiar
07:58:37 <bartavelle> or perhaps it's not :/
07:58:51 <Lewix> ah un francaise, maintenant je comprends
07:59:07 <Lewix> you should have started by saying that
07:59:32 <bartavelle> my experience maintaining ruby applications is irrelevant because of my nationality ?
07:59:42 <mgsloan> Of the european countries, france is not the one I would associate with laziness / software malpractice, but you know better than I!
07:59:46 <Lewix> no
08:00:00 <Lewix> bartavelle: it just give me some clue whether I'm wasting my time or not arguing
08:00:04 <Lewix> you're never right with a french
08:00:10 <bartavelle> mgsloan, it's more than working in a technical position is considered a failure by many people
08:00:14 <EvanR> trololol
08:00:44 * Lewix attended French schools
08:01:22 <mgsloan> bartavelle: Ah, very strange!  Maybe this is why france has so many good theory people?
08:01:38 <mgsloan> (all the Coq stuff, logicians, etc etc)
08:02:06 <bartavelle> mgsloan, mathematics and abstract stuff are however highly regarded, and are also what paves the road to higher studies (ie. you're good at math, you're going to enter a pretigious engineering school)
08:02:43 <bartavelle> anyway this is quite off topic :/
08:02:59 <mgsloan> Right, people who would end up in engineering if in a different system end up going after abstract stuff
08:03:10 <mgsloan> yup yup, carry on with your regularly scheduled #haskell :)
08:03:32 <Lewix> bartavelle: yea this is why when I graduated , my teacher said oh you're american so I suppose you're going to a University in your home country. Lucky you, school over there is so easy
08:03:43 <Lewix> they certainly think they're the ish
08:03:51 <Lewix> well, in theory
08:04:54 <ddellacosta> are lists actually used much by developers building Haskell software in production settings?  Seems strange how much lists are taught, but when I show people my code they're like, "don't use lists, use vectors" or whatnot
08:05:04 <Lewix> "pretigious engineering school"
08:05:08 <EvanR> we dont need no education, we dont need no thought control
08:05:21 <JagaJaga> how to ask lambdabot for a point free conv/
08:05:25 <JagaJaga> ?
08:05:37 <silver> we just need objects and arrows
08:05:37 <Lewix> true true. My apologies, I went on a tangent =)
08:06:05 <ajcoppa> JagaJaga: use @pl for that
08:06:10 <ajcoppa> @pl \x -> x + 1
08:06:10 <lambdabot> (1 +)
08:06:10 <JagaJaga> ajcoppa: thx.
08:06:12 <RchrdB> ddellacosta: depends how much you're chasing performance, I think.
08:06:15 <absence> ddellacosta: i don't write in production, but i would assume that it's fine to use lists until it's not (i.e. profile)
08:06:30 <silver> JagaJaga, depends on your irc client, try right clicking on lambdabot's name or /query lambdabot
08:06:41 <ddellacosta> RchrdB, absence: okay, thanks, I guess the answer as always is "context is important"
08:06:41 <JagaJaga> silver: I know that.
08:06:44 <bartavelle> ddellacosta, they are good for lots of case, and you might hit some fusion rule that will give you good performance anyways
08:06:45 <silver> oh I see
08:06:51 <EvanR> ddellacosta: a lot of times lists are not used as much as data but as control structures, due to lazy evaluation
08:07:14 <absence> ddellacosta: unless you know from experience that lists will be slow for the problem you're solving. which i guess is also context :)
08:07:15 <RchrdB> ddellacosta: type String = [Char] is usually avoided in production stuff, but lots of stuff that builds and immediately consumes lists performs just fine because fusion rules tend to kick in.
08:07:21 <EvanR> for lots of text though, probably should default to Text and not String
08:07:37 * ddellacosta goes to look up fusion rules
08:07:37 <Hijiri> the Foldable/Traversable Prelude use is supposed to help fix the overuse of lists in the wrong places, right?
08:08:12 <ddellacosta> thanks all
08:08:19 <EvanR> another thing is that vectors are a drop in replacement for lists
08:08:23 <EvanR> are NOT
08:08:28 <RchrdB> heh
08:08:36 <EvanR> stupid negation
08:08:45 <zmbmartin> tdammers: I started with Rails and the black box holds well with that. It took me a while to figure out what was going on because I just adhered to the Rails way.
08:08:55 <tdammers> yeah
08:08:58 <tdammers> I tried Rails
08:09:02 <JagaJaga> silver: thying this and getting error
08:09:05 <JagaJaga> @pl splay x (Node _ left right)               =  Node x left right
08:09:05 <lambdabot> (line 1, column 15):
08:09:05 <lambdabot> unexpected "_"
08:09:05 <lambdabot> expecting variable, "(", operator or ")"
08:09:08 <tdammers> started reading the code trying to figure out how it works
08:09:10 <JagaJaga> @pl splay x (Node a left right)               =  Node x left right
08:09:10 <lambdabot> (line 1, column 44):
08:09:11 <lambdabot> unexpected " "
08:09:11 <lambdabot> expecting operator
08:09:14 <JagaJaga> ?
08:09:15 <tdammers> hours later, I gave up
08:09:18 <zmbmartin> Sinatra isn't so bad if you like Ruby as a language.
08:09:28 <tdammers> yeah, sinatra kind of makes sense, mostly
08:09:35 <EvanR> sinatra and sequel are a great replacement for rails
08:09:40 <gigabytes> JagaJaga: it wants a lambda
08:09:52 <gigabytes> @pl \x (Node a left right) -> Node x left right
08:09:52 <lambdabot> (line 1, column 10):
08:09:52 <lambdabot> unexpected "a"
08:09:52 <lambdabot> expecting operator or ")"
08:09:53 <tdammers> but then, why not go all the way and use scotty :D
08:10:01 <gigabytes> ah no
08:10:04 <zmbmartin> tdammers: That is what I am doing now :)
08:10:08 <tdammers> yeah
08:10:11 <tdammers> same here
08:10:12 <absence> Hijiri: i'm not sure it will help much with that in particular. the Foldable/Traversable functions still work for lists
08:10:27 <zmbmartin> Wanted to learn haskell. So no better way then to build something I need or can use.
08:10:30 <EvanR> tdammers: whats scotty
08:10:36 <tdammers> in a nutshell; ruby is nice and all, but between Python and Haskell, it doesn't give me enough of a benefit
08:10:42 <JagaJaga> gigabytes: hmmmm
08:10:43 <geekosaur> "@pl" can't remove that kind of point, you need something like lens for that
08:10:48 <tdammers> EvanR: a lightweight web "framework" for Haskell
08:10:52 <geekosaur> (the (Node a left right) thing)
08:11:19 <tdammers> EvanR: similar to sinatra, flask, or node.js, in terms of scope
08:11:20 <geekosaur> or it would need to know a record-style declaration but I don't think there's a way to tell it about those
08:11:35 <tdammers> "microframework", if you're into fancy hipster names
08:11:57 <EvanR> microfoo
08:12:23 <tdammers> microsoft
08:12:39 <mgsloan> ddellacosta: Yeah, unless you're doing really quick operations on large lists (like numeric operations), the extra overhead ought to be a small percentage of overall cpu time.  So, in practice, lists are fine
08:12:57 <ddellacosta> mgsloan: thanks
08:13:36 <mgsloan> ddellacosta: Welcome!  Of course, if you're indexing on lists a lot, that can get slow rather fast..
08:13:40 <EvanR> again String ops on large strings will blow you up
08:14:24 <mgsloan> True!  Gotta be wary of (++) particularly
08:14:24 <zwer> depends what operations
08:14:53 <EvanR> things you take for granted in like javascript, split join zip group etc
08:15:04 <Lewix> C++ is so bad that they named the language after the ++ operator
08:15:21 <EvanR> :t (C ++)
08:15:22 <lambdabot> Not in scope: data constructor ‚ÄòC‚Äô
08:15:34 <Lewix> Javascript is so bad that there's a book title the good part of javascript
08:16:30 <Lewix> ok enough trolling around for me.
08:16:38 <S11001001> > succ 41
08:16:40 <Lewix> I'll give Haskell a try, where should I start
08:16:40 <lambdabot>  42
08:16:52 <S11001001> haskell succs instead
08:17:07 <S11001001> @where lyah
08:17:07 <lambdabot> http://www.learnyouahaskell.com/
08:17:10 <S11001001> Lewix: ^
08:17:15 <Lewix> thanks
08:17:24 <crazydave> listen to lambdabot, that's the best reference.
08:17:49 <JagaJaga> EvanR: in russia the char `–°` means `with` when we use it in sentence. So C++ -> With++...
08:17:52 <zmbmartin> tdammers: Thanks again for you help!
08:18:05 <S11001001> crazydave: I've found I'm not too happy with lyah's treatment of monads, after hearing dibblego's.  But it's pretty good, so
08:18:07 <tdammers> zmbmartin: np. Does it work?
08:18:19 <zmbmartin> Everyone in here has been great with my Newbie haskell questions.
08:18:21 <crazydave> Real World Haskell is good too.  If you get stuck
08:18:50 <Hijiri> not enough people are shilling bitemyapp's guide
08:18:58 <crazydave> Yeah, lyah is for beginning, so I don't think it matters that they don't treat monads well.  At the point you want to understand them you need to be reading something more advanced.
08:19:02 <EvanR> > "C –°"
08:19:04 <lambdabot>  "C \1057"
08:19:11 <zmbmartin> tdammers: Yup so far until I reach my next bottleneck :)
08:19:28 <Hijiri> https://github.com/bitemyapp/learnhaskell
08:19:29 <EvanR> > "–°–°–°–†"
08:19:31 <lambdabot>  "\1057\1057\1057\1056"
08:20:14 <zmbmartin> Hijiri: Awesome, I am going to check that out.
08:20:15 <tdammers> Lewix: Haskell is so bad that the tutorial titled "A Gentle Introduction To Haskell" can reduce a seasoned programmer with 20 years of experience in more than half a dozen languages to a helpless pile of tears and frustration within hours
08:20:29 <ajcoppa> Lewix: bitemyapp's guide linked above along with the #haskell-beginners channel here on freenode contain a set of recommendations about how to get started
08:20:47 <tdammers> also, Endosemicofunctoroid
08:20:52 <FireFly> CCPP, the communistic C pre-processor
08:21:10 <tdammers> all joking aside, yeah, lyah and rwh
08:21:22 <Lewix> thanks
08:21:31 <tdammers> and, back to the joking:
08:21:41 <tdammers> just like Lisp is not an appropriate Lisp, Haskell is not an appropriate Haskell
08:21:48 <tdammers> maybe even more so
08:22:42 <S11001001> crazydave: I'm a fan of dibblego's because he takes it out of the realm "advanced" and says look, this is simple, this is all there is to it, nbd.
08:22:54 <S11001001> s/realm/realm of/
08:23:02 <FireFly> tdammers: what is that supposed to mean?
08:23:48 <crazydave> maybe I should read dibblego then, because I don't really understand monads yet (or more monad transformers)
08:23:54 <tdammers> FireFly: that Haskell isn't perfect either
08:24:04 <FireFly> Ah
08:24:13 <EvanR> in more curious about the lisp comment
08:26:19 * dramforever keeps seeing people say "haskell" when they mean "ghc"
08:26:44 <crazydave> "lisp is not an acceptable lisp": http://steve-yegge.blogspot.de/2006/04/lisp-is-not-acceptable-lisp.html
08:27:08 <S11001001> crazydave: at the risk of being accused of propagating monad tutorials, http://www.blumenfeld-maso.com/2010/01/what-does-monad-mean-by-tony-morris/
08:27:24 <EvanR> ah, its part of a series like considered harmful
08:28:24 <dramforever> To me, monads = super powered functors
08:28:32 <dramforever> applicatives = powered functors
08:29:02 <S11001001> dramforever: lol
08:29:06 <S11001001> dramforever: what about profunctors?
08:29:16 <EvanR> that blog refers to lisps type system, which made me huh
08:29:17 <dramforever> never heard of it
08:29:18 <pantsman> that's easy, they're "pro" functors
08:30:02 <S11001001> pantsman: like, they're functor supporters, or professional functors?
08:30:10 <dramforever> ha, does this exist? class Cofunctor where cofmap :: (f a -> f b) -> a -> b
08:30:17 <crazydave> S11001001: thanks, I'll have a listen some time.  I need the help on them that's for sure
08:30:43 <pantsman> S11001001: not like those amateur functors.
08:31:39 <S11001001> dramforever: I feel like the only instances would be for fs isomorphic to Identity
08:31:39 <dramforever> oh, cofunctor is not like that...
08:32:00 <dramforever> yeah, and cofunctors are not like this
08:32:02 <S11001001> dramforever: there's contravariant, but it is notably not the categorical dual of Functor; Functor it its own Co
08:32:15 <S11001001> *is its* own Co
08:32:19 * hackagebot persistent-mysql 1.3.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.3.1 (MichaelSnoyman)
08:32:21 * hackagebot persistent-mysql 2.1.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1.1 (MichaelSnoyman)
08:32:32 <dramforever> yeah, I know. I'm just joking
08:32:43 <absence> dramforever: either way i'd hope the function was called comap, unless it clashed with a ([a] -> [b]) -> a -> b
08:33:16 <S11001001> pamf = flip fmap
08:33:58 <pantsman> doesn't that have a name already, like <&>
08:34:06 <dramforever> let (-:+%^^%|..) = (+) in 24 -:+%^^%|.. 2
08:34:10 <dramforever> > let (-:+%^^%|..) = (+) in 24 -:+%^^%|.. 2
08:34:12 <lambdabot>  26
08:34:58 * dramforever would like to point out that one of my friends told me that he can't stand haskell because there are so many weird operators
08:35:29 <EvanR> -:+%^^%|.. is perfect sensible
08:35:32 <dramforever> I told him that anyone can define them, since the "operator system" is open, and he went away
08:35:33 <EvanR> ly
08:35:38 <pantsman> I never know what to say to that, except maybe, "well, newsflash: the concepts will be weirder to you than the operators"
08:36:20 <dramforever> pantsman: by "can't stand" he meant "can't stand looking at", as far as I can tell
08:36:30 <yukko> that's actually the reason I learned Haskell
08:36:31 <nshepperd> "Operators are just functions, man. execvpe()"
08:36:41 <yukko> I saw all the weird operators and thought it looked scary and hard
08:36:46 <bartavelle> dramforever, I felt the same about all the Applicative menagerie, now I like them a lot
08:37:02 <bartavelle> and it was the same with lens
08:37:12 <EvanR> opengl ;)
08:38:13 <pantsman> I'm sure there were mathematicians who hated math notation and thought it would be better if all reasoning would be done with english sentences
08:38:37 <dramforever> and has anyone heard of APL?
08:38:41 <vanila> yes
08:38:42 <EvanR> i still prefer english sentences for a lot of math
08:38:43 <pantsman> ultimately there are advantages to having a dense, precise notation, but it takes training to get used to it
08:39:11 <pantsman> (at which point someone will say "what, I don't want to need training just to code")
08:39:28 <pantsman> ("just point me at the keyboard")
08:39:48 <EvanR> you can write QBasic in anything
08:40:49 <dramforever> forall a. If I can't understand a's documentation, and I cannot find a good explaination of a, I will not use a
08:41:25 <pantsman> I am mostly the same except when a is from a Kmett library
08:42:13 <silver> then you ask him?
08:42:47 <geekosaur> if its froma  kmett library, the explanation may go flying high overhead :p
08:42:52 <pantsman> well, yeah, there is that
08:43:00 <pantsman> usually by the 2nd sentence my brain has overheated
08:43:11 <silver> :)
08:43:17 <pantsman> but from past experience, it's worth being persistent
08:43:31 <nshepperd> nah, you just bang the code until it compiles without type errors and then try to figure out what you did
08:43:46 <pantsman> pretty much that
08:44:21 <pantsman> for example, I wanted to use trifecta, and I could not find any docs, apart from the haddocks (which have sparse explanation), and some slides from a talk which went way over my head and I couldn't tell if they were even related to the implementation I was looking at
08:45:59 <absence> pantsman: that begs the question: why did you want to use it? :)
08:46:21 <pantsman> absence: why not? :)
08:47:01 <pantsman> I just had a suspicion it would be better than what I was already using (Parsec)
08:47:13 <yukko> what didn't you like about Parsec?
08:47:40 <bartavelle> (I found that most things I don't like with parsec are solved by using the parsers interface to parsec)
08:48:10 <zmbmartin> S11001001: Do you have a link to this dibblego you were talking about?
08:48:17 <absence> what i don't like about parsec is the apparent lack of binary parsing
08:48:28 <dramforever> absence: well, nope
08:48:39 <S11001001> zmbmartin: http://www.blumenfeld-maso.com/2010/01/what-does-monad-mean-by-tony-morris/
08:48:46 <pantsman> yukko: I wanted something I could incrementally feed input, but with better error reporting than attoparsec
08:48:47 <dramforever> you can write a Stream instance for ByteString
08:49:01 <zmbmartin> S11001001: Thanks!
08:49:37 <absence> dramforever: i think parsec comes with one? it still doesn't let you extract a "big-endian 64-bit floating point value" from it
08:49:44 <yukko> pantsman ah, I see
08:51:16 <bartavelle> absence, well you can write it easily ? but you'd rather use something like cereal
08:51:23 <dramforever> absence: that makes me thing of Data.Binary.Get
08:52:16 <dramforever> s/thing/think/
08:52:19 <pantsman> I know attoparsec is designed for speed over diagnostics, but I couldn't get it to give me any error other than "failed: satisfy", in ANY case
08:52:50 <dramforever> well, It's worse here: I keep getting "failed: endOfInput"
08:53:18 <pantsman> I think there's a bug where some combinator basically discards the info you give it via <?>
08:53:34 <absence> bartavelle, dramforever: i don't think either of those are monad transformers, so you can't seek the underlying file while parsing
08:53:54 <bartavelle> absence, good point
08:54:21 <bartavelle> absence, https://hackage.haskell.org/package/cereal-conduit
08:55:09 <Raghs> my ghci still shows base language is: Haskell98. I am using GHC 7.8.3
08:55:16 <Raghs> how do i change it to Haskell2010?
08:55:19 <absence> bartavelle: i use pipes-binary, but they're probably quite similar, unless cereal-conduit allows seeking inside a parser?
08:55:35 <dramforever> Raghs: :set -XHaskell2010
08:56:04 <bartavelle> absence, I don't understand what that would mean ? you mean jumping at different places in a file instead of stream-deserializing ?
08:56:16 <bartavelle> like for disassembling a file ?
08:56:49 <absence> bartavelle: a file might contain an offset to a different part of the file where there's more data
08:57:07 <bartavelle> yeah, in that case it won't work well
08:57:35 <bartavelle> I would really like a composable approach to that problem
08:57:51 <Raghs> dramforever : Thank you very much
09:01:32 <absence> bartavelle: me too. currently i split the parsers into smaller sub-parsers that can be run individually, and seek between them. it works, but is a bit verbose due to needing additional temporary types
09:02:22 * hackagebot binary-list 0.3.5.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.5.0 (DanielDiaz)
09:02:24 * hackagebot country-codes 0.1.1 - ISO 3166 country codes and i18n names.  http://hackage.haskell.org/package/country-codes-0.1.1 (JeanPhilippeMoresmau)
09:02:27 * hackagebot snmp 0.1.0.2 - API for write snmp client.  http://hackage.haskell.org/package/snmp-0.1.0.2 (chemist)
09:12:23 * hackagebot mangopay 1.9.7 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.7 (JeanPhilippeMoresmau)
09:25:39 <kuznero> Hi All!
09:27:22 <shapr> oh sure, say hi and then leave
09:27:31 <shapr> edwardk: OH HAI
09:27:43 <shapr> edwardk: you have a scary twitter profile pic
09:32:26 * hackagebot authinfo-hs 0.1.0.0 - Password querying for .authinfo  http://hackage.haskell.org/package/authinfo-hs-0.1.0.0 (robgssp)
09:38:34 <edwardk> shapr: hah, haven't seen me in "corporate tool mode" before?
09:39:55 <shapr> edwardk: once for five minutes maybe, when you were dealing with Raytheon management
09:40:21 <shapr> edwardk: what cool code are you working on these days?
09:40:42 <edwardk> shapr: github.com/ekmett/quine (pretty screenshots below)
09:41:18 <mgaut72> edwardk: you have Raytheon affliiations?
09:42:04 <shapr> edwardk: pretty! does it run on Linux?
09:42:07 * shapr tries to build
09:42:23 <edwardk> mgaut72: used to run the tech side of a company named SM&A, which is a company full of retired generals who know how to win big government contracts.. A good chunk of the technology team there was embedded in Raytheon on a few projects for a while.
09:43:01 <edwardk> shapr: i have no idea if it'll run on linux. haven't tried =)
09:43:20 <Fuuzetsu> ‚Äòfix the fix‚Äô commits are the best
09:43:27 <shapr> edwardk also hired me to work with him. I really enjoyed working with Ed and hanging out after work hours.
09:44:12 <edwardk> in exchange shapr taught me how to contact juggle
09:44:15 <mgaut72> ah, I have worked there myself, and am always interested to hear about the "cool" stuff that isn't the same "rocket science" that has been happening since before I have been alive
09:45:07 <shapr> edwardk: and Amy introduced me to Capoeira, my favorite form of exercise
09:45:18 <glguy> edwardk: I have this on my desk ^_^ http://www.galois.com/~emertens/quine.jpg
09:45:40 <edwardk> glguy: hah
09:46:00 <edwardk> then i chose an appropriate first shader toy. maybe i should go texture it to match ;)
09:47:01 <shapr> dang, sdl2 wants >=2.0.3 and I only have 2.0.2 on this Ubuntu desktop :-(
09:47:27 * hackagebot lens 4.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.5 (EricMertens)
09:47:28 <edwardk> you can _probably_ build on 2.0.2 by tweaking the .cabal file
09:47:33 <edwardk> i don't use anything exotic
09:48:05 * shapr tries
09:48:08 <edwardk> glguy++
09:48:34 <absence> edwardk: were you in a famous demoscene group?
09:49:09 <edwardk> absence: i pretty much sat in the #coders channel and helped other folks figure out algorithms for interesting problems back in the day
09:49:25 <shapr> lemme guess, base >= 4.7 is in ghc 7.8 ?
09:49:30 <edwardk> so you'll find props to me in productions, but not stuff done directly by me
09:49:33 <edwardk> shapr: yep
09:49:41 <shapr> dangit
09:49:42 <edwardk> shapr: and there i do use language features not present before
09:49:55 <edwardk> so you need current ghc
09:50:40 <shapr> edwardk: done anything neat with datatype promotion?
09:51:25 <edwardk> github.com/ekmett/hask to some extent uses fancy promoted data types
09:51:45 <edwardk> shapr: hop on google chat? maybe i can just show it off my machine ;)
09:53:06 <ReinH> glguy: missed you at the Galois thing on Monday :)
09:53:25 <glguy> You're right, I did. Were you there?
09:53:41 <ReinH> glguy: Yep
09:54:13 <ReinH> shapr: his profile pic is pretty scary
09:54:17 <glguy> I vacillate over when to go. Sometimes we have (what feels like) an overwhelming Galois presence ^_^
09:56:18 <albeit> Are there any rules of thumb / ideas to reduce memory allocations and GCs?
09:57:49 <levi> albeit: Usually judicious application of strictness and unboxing annotations can help with that, guided by profiling.
09:57:54 <CodeWeaverX> The section in Real World Haskell that talks about optimizations may help.  Particularly where it talks about space profiling.
09:57:56 <CodeWeaverX> http://book.realworldhaskell.org/read/profiling-and-optimization.html
10:00:10 <albeit> Will do, thanks CodeWeaverX levi
10:01:18 <CodeWeaverX> But yeah, learning about strictness helps.  Learning about stream fusion helps (using Data.List.Stream in the stream-fusion library instead of Data.List‚Ä¶ or using Data.Vector).  Learning about boxed vs unboxed types helps.
10:02:31 <CodeWeaverX> albeit: and in a pinch, using GHC primitives, but that should be a last resort, as you may find you‚Äôre not as clever as the compiler. ;)
10:03:10 <levi> There are some good presentations out on Youtube and various places on the web, though I don't have any links handy.
10:04:08 <cryzed> Is pattern matching for a tuple of length 2 preferred, or using fst and snd? For example if I write a lambda for a filter function that filters a list of (String, Int)
10:04:52 <cryzed> would \(a, b) -> a == be preferable to \x -> fst x ==
10:05:05 <cryzed> I guess it's a question of style
10:05:25 <pjdelport> cryzed: You could also say uncurry (==)
10:05:35 <pjdelport> in that particular case
10:05:48 <cryzed> I'll have to read up on that then, thank you pjdelport
10:06:33 <albeit> CodeWeaverX: I thought stream fusion happened even with Data.List?
10:06:38 <pjdelport> cryzed: Generally speaking, pattern matching is probably preferable to using fst and snd, though, especially if you want to use both parts.
10:06:41 <CodeWeaverX> Pattern matching forces the tuple to be evaluated at least to the outer tuple level (doing work), where using fst and snd will and more deferred functions to the expression.
10:07:10 <cryzed> CodeWeaverX, so fst and snd is "lazier"?
10:07:14 <CodeWeaverX> Yes.
10:07:19 <cryzed> alright, thank you
10:07:26 <cryzed> I suppose pattern matching is more useful for tuples >= 3
10:07:29 * hackagebot lens-aeson 1.0.0.2 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-1.0.0.2 (EricMertens)
10:07:41 <geekosaur> lazy pattern matching is also an option
10:07:50 <geekosaur> ~(f,s)
10:08:08 <cryzed> thank you for letting me know
10:08:37 <CodeWeaverX> cryzed: But that also could mean that if the expression of the tuple hits bottom, and throws an exception, it will happen there, rather than when fst and snd tries to do the evaluation.  So there could be a difference in behaviour if the expresison is later thrown away.
10:08:57 <CodeWeaverX> cryzed:  Other than that possibility, its just a laziness thing.
10:09:10 <cryzed> alright, thank you
10:09:19 <cryzed> I think I'm too new to Haskell to worry about that yet
10:09:24 <cryzed> but I'll try to keep it in mind
10:09:33 <CodeWeaverX> Maybe.  Just go with the laziness issue for now.
10:09:54 <cryzed> yeah :)
10:10:37 <CodeWeaverX> albeit:  Data.List does try, but Data.List.Stream in stream-fusion is a drop-in replacement that has been written from the ground up to make stream-fusion easier to recognize patterns that can fuse streams.  It is considerably better at it in practice, especially when you have many chains of transformations on lists, and especially when the optimizer inlines things so that it happens more often.
10:11:23 <albeit> CodeWeaverX: Good to know! Why isn't Data.List.Stream just made default the Data.List?
10:11:34 <Armel`> Hi! I need to handle control-flow graphs (build for binaries compiled for C sources in order produce automata). I've seen that there is some specific modules in the GHC API to do so (MkZipCfg from earlier versions of GHC, it seems to be called MkGraph now). Do anyone know if it could do the thing or is it too Haskell-specific?
10:13:29 <cdk> albeit: Stream cannot yet optimize concatMap as well as the current foldr/build fusion, so it hasn't replaced regular Data.List yet.
10:13:54 <CodeWeaverX> cdk:  Didn‚Äôt know that ‚Äî is that something someone is working on?
10:15:23 <dcoutts_> Armel`: have a look at hoopl
10:15:42 <dcoutts_> Armel`: it's a generic framework, not specific for optimising Haskell/C--
10:16:50 <dcoutts_> CodeWeaverX: yes, see http://www.ittc.ku.edu/~afarmer/concatmap-pepm14.pdf
10:17:02 <CodeWeaverX> Nifty!
10:18:34 <Armel`> Thanks dcoutts_!
10:24:13 <torpet> Hi, how can I "force" this method to return Integer instead of "int"
10:24:14 <torpet> http://lpaste.net/1658198379479433216
10:24:26 <torpet> The method signatures are given.
10:24:30 <fragamus> I'm really loving this language
10:24:51 <S11001001> @ty length
10:24:53 <lambdabot> [a] -> Int
10:24:56 <S11001001> @ty integralLength
10:24:57 <lambdabot> Not in scope: ‚ÄòintegralLength‚Äô
10:25:03 <S11001001> @ty integerLength
10:25:04 <lambdabot> Not in scope: ‚ÄòintegerLength‚Äô
10:25:08 <Igloo> @ty genericLength
10:25:09 <lambdabot> Num i => [a] -> i
10:25:12 <geekosaur> genericLength (not necessarily a good idea) or fromIntegral
10:25:15 <S11001001> ah, thanks Igloo
10:25:35 <S11001001> @hlint
10:25:35 <lambdabot> What module?  Try @listmodules for some ideas.
10:25:35 <indiagreen> torpet: the trouble is that length returns Int, so you want either a variant of length that returns Integer (i.e. genericLength) or explicit conversion (i.e. fromIntegral $¬†maximum $ map length t)
10:25:40 <S11001001> too bad
10:26:11 <S11001001> @ty fromIntegral
10:26:12 <lambdabot> (Num b, Integral a) => a -> b
10:26:32 <glguy> geekosaur: There's a rule that genericLength on Integer uses an alternate implementation
10:26:42 <torpet> S11001001: thanks, would that be considered "unclean"?
10:29:23 <S11001001> torpet: nah
10:36:51 <jdeisenberg> Hello. Am trying to build haskell-platform on Linux Fedora 18; (can't install elm without latest version, apparently)
10:38:21 <jdeisenberg> getting error: Haskell CPP command not found in build/ghc-bindist/local/lib/ghc-7.6.2/settings
10:39:48 <crobbins> jdeisenberg: i would just install haskell platform from your ditro repos, like yum, apt-get, or whatever fedora uses
10:40:04 <crobbins> then you can update cabal with `cabal install cabal-install`
10:40:24 <crobbins> then you'll have the latest version of cabal and can do the sandbox style install from the github page
10:40:55 <jdeisenberg> OK will give that a shot; thanks.
10:42:47 <jdeisenberg> my compiler is GHC 7.4.1; I hope that will be sufficient to compile elm.
10:48:23 <jdeisenberg> (still updating the cabal-install)
10:56:33 <torpet> S11001001: thanks
10:58:29 <jdeisenberg> crobbins: Looks like it's going well so far. Thanks for the assist!
10:58:46 <crobbins> np!  glad it helped jdeisenberg
11:01:44 <Yxven> e-mail
11:07:36 * hackagebot snaplet-hslogger 1.0.0.0 - Snap framework snaplet for the Logger API library.  http://hackage.haskell.org/package/snaplet-hslogger-1.0.0.0 (ParnellSpringmeyer)
11:08:50 <piskrist> how can I (show CreateProcess) ?
11:09:21 <johnw> piskrist: what would that mean?
11:12:36 * hackagebot snaplet-hslogger 1.0.0.1 - Snap framework snaplet for the Logger API library.  http://hackage.haskell.org/package/snaplet-hslogger-1.0.0.1 (ParnellSpringmeyer)
11:12:38 <gfixler> can I paginate GHCi output, e.g. from the :browse command?
11:27:35 <zipper> Test
11:27:38 * hackagebot snaplet-hslogger 1.0.0.2 - Snap framework snaplet for the Logger API library.  http://hackage.haskell.org/package/snaplet-hslogger-1.0.0.2 (ParnellSpringmeyer)
11:28:14 <piskrist> Not in scope: data constructor `Test`
11:28:54 <zipper> Okay anyone know how I can create a type such as [[1,2] [3,4]] ? Note this is not [[Int]]
11:29:07 <zipper> I am wondering how to represent []
11:29:17 <piskrist> maybe you want [(Int, Int)]
11:29:23 <johnw> that's invalid syntax
11:29:30 <johnw> did you mean [[1,2], [3,4]]?
11:29:42 <johnw> in which case, that's [[Int]]
11:29:49 <johnw> perhaps explain more
11:30:40 <zipper> Give me a minute. It's a homework assignment.
11:30:43 <eitan_chatav> :t [[1,2],[3,4]]
11:30:44 <lambdabot> Num t => [[t]]
11:30:59 <zipper> Exercise 3 in http://www.seas.upenn.edu/~cis194/hw/05-type-classes.pdf
11:31:12 <zipper> johnw: piskrist I posted above
11:32:30 <johnw> ah
11:32:32 <johnw> you are writing a parser
11:32:43 <eitan_chatav> data Mat2x2 = Mat2x2 { a :: Integer, b :: Integer, c :: Integer, d :: Integer }
11:32:50 <johnw> it would be ((1,2), (3,4)), or what eitan_chatav wrote
11:32:54 <johnw> the two being isomorphic
11:34:01 <zipper> but why are they using the square brackets?
11:34:04 <eitan_chatav> instance Ring Mat2x2 where addId = Mat2x2 1 0 0 1; ...
11:34:19 <zipper> I don't know much about parsers and I'm super confused right now.
11:34:28 <zipper> eitan_chatav: Ok nice
11:35:03 <eitan_chatav> the square brackets thing "[[1,2][3,4]]" is a string representing a 2x2 matrix
11:35:26 <eitan_chatav> you gotta read the first part of your homework ;-)
11:35:36 <zipper> eitan_chatav: Did you notice that their value constructor was a square bracket and not Mat2x2
11:35:42 <eitan_chatav> end of page 2 + page 3
11:36:45 <zipper> eitan_chatav: Let me see :) I feel ignorant.
11:37:05 <zipper> It's not really my homework but that doesn't really matter.
11:37:18 <eitan_chatav> it's your task to figure out an implementation for a function parse :: String -> Maybe (Mat2x2, String) which will send "[[1,2][3,4]]" to (Just Mat2x2 { a = 1, b = 2, c = 3, d = 4 },"")
11:37:19 <zipper> Just an internet resource for learning haskell.
11:37:39 * hackagebot persistent 2.1.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.0.2 (GregWeber)
11:38:23 <eitan_chatav> "The parse method looks at a string and tries to extract a specific element. If it can do so, it returns the element extracted and the re- mainder of the string. This way, parsing can continue."
11:38:58 <sivteck> `/j ##PROGRAMMING
11:39:06 <sivteck> oops, sorry
11:39:31 <eitan_chatav> zipper: do the Ring instance first. It will likely be easier
11:39:45 <zipper> eitan_chatav: I thought I'd have to rewrite a Show for it to show Mat2x2 differently.
11:39:53 <zipper> eitan_chatav: I have an issue writing the type itself.
11:40:22 <DATHASKELL> DAT HASKELL THO
11:40:33 <eitan_chatav> mine was just an example for Mat2x2. You can define it how you like and you can always put "deriving Show" to get a Show instance for free.
11:41:44 <eitan_chatav> anyone have trouble compiling wreq-0.2.0.0? I swear I compiled it just the other day :-/
11:43:08 <DATHASKELL> WHERE IS THAT BITE GUY
11:43:26 <zipper> eitan_chatav: I am almost unable to use []
11:43:41 <zipper> I can't use [] as a data constructor.
11:44:10 <eitan_chatav> The list type has data constructors [] for the empty list and (:) for cons
11:44:20 <eitan_chatav> :t []
11:44:21 <lambdabot> [t]
11:44:33 <eitan_chatav> :t (:)
11:44:34 <lambdabot> a -> [a] -> [a]
11:44:43 <DATHASKELL> LAMDA KALULUS
11:45:34 <eitan_chatav> zipper: the square brackets expression in your problem is not a list of integers, it's a string of characters
11:45:41 <zipper> eitan_chatav: In my mind I wish this worked --> data Mat2x2 = [[Int] [Int]]
11:46:09 <eitan_chatav> zipper: a 2x2 matrix consists of four integers, right?
11:46:11 <zipper> eitan_chatav: and I shouldn't try to recreate that scenario.
11:46:23 <zipper> I was trying to perfect it I guess. Visually.
11:46:28 <zipper> eitan_chatav: Righr
11:46:30 <zipper> right
11:46:31 <eitan_chatav> not an arbitrarily sized list of list of integers
11:46:45 <DATHASKELL> I COMMAND YOU TO ANSWER ME BITE GUY
11:46:48 <eitan_chatav> [[Integer]] is the type of lists of lists of integers
11:47:07 <eitan_chatav> It's not what you want because it's too general
11:47:08 <fragamus> @edwardk https://gist.github.com/fragamus/0dbc6523954f00d81665
11:47:08 <lambdabot> Unknown command, try @list
11:47:55 <edwardk> that is the kinda case that linear is bad at talking about
11:48:02 <eitan_chatav> you can do "type Mat2x2 = ((Integer,Integer),(Integer,Integer))"
11:48:10 <fragamus> yeah but I love it i want to use it
11:48:18 <zipper> eitan_chatav: Yes. IMO integers would have been better.
11:48:22 <zipper> I mean a list of tuples
11:48:25 <fragamus> so what are the alternatives
11:49:05 <zipper> or a tuple of tuples
11:49:23 <eitan_chatav> tuples are more appropriate than lists for this case
11:50:18 <edwardk> fragamus: dunno. i wrote linear to handle nice small operations involving quaternions, plucker coordinates and little 4x4 matrices ;)
11:50:22 <edwardk> fragamus: i tend to give up and write big matrix stuff by hand
11:50:28 <edwardk> and thats a terrible solution
11:50:42 <fragamus> edwardk: so basically I'm out in the cold cruel world
11:50:50 <edwardk> but the representable trick needs to know dimensionality
11:50:52 <edwardk> is your matrix dense or sparse?
11:50:55 <eitan_chatav> lunch time!
11:50:58 <fragamus> dense
11:51:02 <edwardk> if its sparse you can use IntMap, etc.
11:51:13 <sepp2k> zipper: Note that if you define Mat2x2 as a type alias, you won't be able to instantiate a type class for it without also instantiating it for the aliased types. So that's probably not the ideal solution with regards to the assignment.
11:51:24 <torpet> I am trying to parse a [String]
11:51:32 <fragamus> my matrix is sometimes thousands on a side
11:51:46 <fragamus> big-ish
11:51:50 <edwardk> then thats probably not the best option =)
11:52:00 <edwardk> this is where i'd lean on repa or vector or something
11:52:10 <torpet> ["This is a sentence. ", "This is sentence 2. ", "Has", "kell"]
11:52:14 <fragamus> repa or vector
11:52:18 <edwardk> linear's pretty but this is very much outside of what its designed to do well
11:52:26 <torpet> bascially Haskell counts as a single word
11:52:38 <torpet> because there is no space either after "Has_" or before "_kell"
11:52:58 <fragamus> it sure is pretty
11:53:01 <Ankhers> I have an executable I am making. I want to have tests to go along with it. So, I have my `executable` section in my cabal file, I also have a `test-suite` section in the file. When trying to run `cabal test`, I get the error "can't find source for Life in spec, dist/build/autogen". Could someone please explain how I am supposed to expose this module to my test?
11:53:14 <torpet> How would i re-create a list to make it look like ["This is a sentence. ", "This is sentence 2. ", "Haskell"]
11:53:42 <humanoyd> How can I "cabal build" from outside a sandbox?
11:53:58 <Cale> torpet: words . concat ?
11:54:12 <Cale> > words . concat $ ["This is a sentence. ", "This is sentence 2. ", "Has", "kell"]
11:54:14 <lambdabot>  ["This","is","a","sentence.","This","is","sentence","2.","Haskell"]
11:54:18 <Cale> oh, right
11:54:27 <dcoutts_> Ankhers: I'm assuming Life is from your library. You have two options, have your testsuite use the source module from the lib, or have your testsuite depend on your lib.
11:54:28 <Cale> you don't actually want to break things further
11:54:49 <dcoutts_> humanoyd: you can cabal install from outside a sandbox
11:54:50 <Cale> all right...
11:54:52 <edwardk> fragamus: i mostly wrote it because i wanted to write a little toy physics engine and then acowley talked me into releasing it in its own right
11:55:03 <torpet> Oh wait
11:55:10 <torpet> I'm actually trying to find the longest word
11:55:12 <torpet> So that might work
11:55:19 <Cale> Well, okay :)
11:55:26 <sm> Ankhers: ie, add a library section as well, and make both the executable and the test-suite depend on it
11:55:33 <fragamus> It's really deep in terms of category theoretical foundations
11:55:42 <torpet> That lambdabot is a brilliant. I'm new here btw.
11:55:47 <torpet> *is brilliant
11:55:49 <Cale> Welcome :)
11:55:51 <Ankhers> dcoutts_, sm: Alright, thanks.
11:55:58 <Cale> torpet: Feel free to ask lots of questions :)
11:56:04 <edwardk> there are parts that are deep and there are parts that are hacks that just work ;)
11:56:16 <johnw> deep hacks
11:56:16 <dcoutts_> Ankhers: oh, sorry you don't have a lib. In that case the simplest is just to have your testsuite use the source file directly. So just add the exe dir to the hs-source-dirs of the test suite
11:56:18 <edwardk> the representable functor thing was something i was quite proud of
11:56:21 <fragamus> I wanted to use linear so that I could soak up some category theory plus its pretty
11:56:27 <sm> also, AFAIK make sure your executable and test-suite specify a different source directory from the library, to avoid redundant compilation
11:56:27 <edwardk> the way matrix multiplication works in it is a horrible hack to extend those foundations to cover stuff johnw needed ;)
11:56:35 <humanoyd> dcoutts_: Sorry, I wasn't clear enough...I have set up a sandbox in which I usually run "cabal build" and I get sandbox/dist/.../binary
11:56:57 <humanoyd> Now I would like to create a bash script in the parent folder of the sandbox folder which runs "cabal build" and executes the binary
11:57:23 <dcoutts_> humanoyd: then the script needs to cd into the dir to run cabal build.
11:57:39 <dcoutts_> or just cabal exec thething
11:57:41 * hackagebot pure-cdb 0.1.1 - Another pure-haskell CDB (Constant Database) implementation  http://hackage.haskell.org/package/pure-cdb-0.1.1 (BorisSukholitko)
11:59:22 <fragamus> so which do I want   repa    or vector
11:59:33 <fragamus> if I was you which would I want
11:59:41 <dcoutts_> depends what you're doing
12:00:30 <dcoutts_> repa is parallel, vector is serial
12:00:41 <fragamus> that's cool
12:00:44 <dcoutts_> repa is more restrictive because it has to be parallel
12:01:01 <fragamus> is there a transpose in repa
12:01:18 <dcoutts_> check the api docs
12:01:46 <gregnwosu> whats the fastest haskell matrix library?
12:02:15 <Cale> gregnwosu: It probably depends on the specific details of the operations you're using
12:02:33 <edwardk> fragamus: repa's neat. i can never figure out how to do anything with it, but its neat.
12:02:42 <Cale> But I don't really know a whole lot about how they compare. It would be cool if someone did a bunch of benchmarking using criterion.
12:02:50 <edwardk> fragamus: vector is easy to use and streams nicely
12:03:03 <gregnwosu> Cale: just simpele stuff like matrix multiplication mainly
12:03:04 <fragamus> cool
12:03:04 <edwardk> gregnwosu: probably something carter is still hacking on in #numerical-haskell
12:03:17 <fragamus> thanks for the info
12:03:23 <gregnwosu> edwardk: is that in hackage?
12:03:26 <edwardk> on the other hand vector has no matrix ops, etc. so you roll your own
12:03:34 <edwardk> gregnwosu: github probably, you'd have to ask carter
12:03:43 <gregnwosu> carter: ?
12:04:08 <edwardk> i have some code for morton ordered sparse matrices but it was mostly to show off morton ordering techniques, coherence, etc.
12:09:52 <zipper>  eitan_chatav I'm giving up on this parsing thing.
12:10:08 <eitan_chatav> zipper: don't give up :-)
12:10:27 <zipper> eitan_chatav: I'll move to the next exercise Monads and IO
12:10:46 <zipper> eitan_chatav: I was trying to write a Ring instance for Bool.
12:11:06 <eitan_chatav> Bool is a good ring, it's the integers modulo 2
12:11:46 <zipper> eitan_chatav: Wow I hadn't thought about it that way.
12:12:01 <eitan_chatav> Ordering is another one, the integers modulo 3
12:12:10 <zipper> Yeah it's so obvious now that I look at it as Int modulo 2
12:12:29 <zipper> eitan_chatav: You're really good at this.
12:12:36 <eitan_chatav> :-)
12:14:42 <gregnwosu> hi ive install random with cabal can anyone tell me where on my system it should lie?
12:15:16 <sbrg> gregnwosu: ~/.cabal
12:15:35 <kadoban> gregnwosu: ~/.ghc usually
12:15:41 <sbrg> oh.
12:15:59 <zipper> eitan_chatav: You really helped btw
12:15:59 <zipper> Well that got me off the ledge.
12:16:01 <sbrg> kadoban: doesn't seem to be true.
12:16:15 <eitan_chatav> zipper: happy to be of help
12:16:22 <dcoutts_> gregnwosu: but where the files are installed isn't really important. Do you need to know? Is there some other problem?
12:16:36 <sbrg> packages are in ~/.cabal/lib/ for me. package.conf files are in .ghc/lib
12:19:04 <kadoban> Hmm, yeah I guess so.
12:26:14 <gregnwosu> dcoutts_: I was getting this error: /usr/bin/ld cannot find
12:26:14 <gregnwosu> 	    -lHSrandom-1.0.1.1-ghc7.8.3.20140804
12:27:02 <albeit> Is container's IntSet the fastest Set for something that does just insertions, and then iterating over all elements?
12:28:07 <gregnwosu> dcoutts:_ but its all fixed now yey
12:28:14 <dcoutts_> ok good
12:28:29 <dcoutts_> reinstalled lib for dynamic linking?
12:32:47 <albeit> Is there a mutable equivalent of Data.IntMap, where the keys are not in successive order?
12:33:16 <monochrom> hash table :)
12:34:33 <albeit> monochrom: Ah looks good, thanks
12:37:45 <albeit> For the has table, if I can guarantee that the keys I try to insert are unique Int's, can I somehow make it skip the hashing work and use the keys directly as hashes?
12:37:46 * hackagebot haskakafka 0.2.0.2 - Kafka bindings for Haskell  http://hackage.haskell.org/package/haskakafka-0.2.0.2 (tdimson)
12:38:32 <c_wraith> albeit: Data.IntMap
12:39:58 <k00mi> albeit: hash for Int is just id
12:40:42 <mauke> your keys won't be unique; otherwise you'd be using an array
12:41:01 <mauke> and by that I mean they won't be sparse, so they have to be reduced somehow
12:41:29 <c_wraith> I was assuming unordered-containers, which uses a HAMT (or something) as a sparse array
12:43:04 <albeit> k00mi: How do they check for uniquness?
12:43:34 <Evilsparza> hey, is there something for Data.Map like group(By) for Lists? groupBy will only group adjacent items, but Data.Map.fromList will group *all* items
12:43:35 <c_wraith> uniqueness is enforced, not checked
12:43:49 <c_wraith> Evilsparza: the typical idiom is to sort first
12:44:25 <Evilsparza> c_wraith no I mean it the other way around. I *want* only adjacent items to be grouped for Data.Map :)
12:44:47 <sinelaw> what is "adjacent"?
12:44:54 <c_wraith> Evilsparza: oh. Your problem is that Data.Map isn't considered to be an ordered container
12:44:54 <albeit> c_wraith: Can you clarify what that means? Is it they put the onus on the user to ensure uniqueness?
12:45:05 <k00mi> albeit: uniqueness of what?
12:45:12 <c_wraith> albeit: no.  Only keys are hashed.  There is a maximum of one value associated with a key
12:45:34 <c_wraith> albeit: if you insert at a key that already existed, you just overwrote the previous value
12:45:48 <c_wraith> albeit: uniqueness is a side effect of that
12:45:52 <albeit> c_wraith: Ah okay
12:46:56 <albeit> mauke: So I have unique keys that are extremely sparse (say 60 in a range of 10000000), I should be using a mutable arrray?
12:47:06 <mauke> albeit: no
12:47:17 <kadoban> Evilsparza: Then you're probably using the wrong data structure. What are you using it for?
12:47:23 <mauke> you should probably use Data.IntMap, or maybe a hash table
12:48:20 <albeit> mauke: Yeah I just want it to be mutable to save on memory. So back to hash table I guess
12:48:53 <mauke> how will that save memory?
12:48:54 <albeit> But then again there no way to skip the uniquness enforcement by hashing in a hash table, if the I already have hashes in the form of unique Ints?
12:49:05 <mauke> wtf
12:49:20 <mauke> it sounds like you don't understand how hash tables work
12:49:20 <albeit> mauke: I need to make many modifications to the structure, overwriting the same key
12:49:33 <albeit> definitely a possibility! ;)
12:49:36 <mauke> use IntMap
12:50:23 <albeit> Can you explain a bit why that is preferable over a hash table?
12:50:29 <dcoutts_> albeit: IntMap is probably a good choice. Mutability and saving memory are not really related.
12:50:33 <biglama> hi, I'm trying to install cairo with cabal but it returns  Not in scope: `LBI.getComponentLocalBuildInfo'
12:51:00 <dcoutts_> biglama: you probably need a newer Cabal library to build it
12:51:31 <biglama> dcoutts_: i'm using the latest cabal on a sandbox
12:51:41 <biglama> (at least i think)
12:52:23 <dcoutts_> biglama: or possibly an older version, but clearly the cairo package Setup.hs requires a different version of the Cabal lib from the one you're using
12:53:12 <dcoutts_> biglama: you can use --cabal-lib-version=x.y.z, to use a different version assuming you have that Cabal lib version available
12:53:30 <biglama> dcoutts_: shouldn't the installer check the cabal version and returns an error ?
12:53:55 <albeit> dcoutts_: If I used IntMap, and I modify a value at a key, the old value will be "forgotten" and garbage collected (eventually), and the IntMap will "point" to a new value. But if I use a mutable structure, won't the new value be written to the same memory location of the old value, so no (eventual) garbage collection?
12:54:09 <albeit> (My terms probably aren't ideal...)
12:54:13 <dcoutts_> biglama: it's currently not possible for packages to declare what versions of things they need for their custom Setup.hs scripts.
12:54:20 <dcoutts_> biglama: this is actually something I'm working on.
12:55:05 <dcoutts_> albeit: what is the type of value (value not key) that you're storing?
12:55:25 <biglama> dcoutts_: okay, I was asking as an install yesterday complained the cabal version was too old
12:55:27 <dbushenko> can anyone tell me why I failed to install hdbc? the log is: Failed to install HDBC-2.4.0.0
12:55:27 <dbushenko> cabal: Error: some packages failed to install:
12:55:27 <dbushenko> HDBC-2.4.0.0 failed during the building phase. The exception was:
12:55:27 <dbushenko> ExitFailure 1
12:55:46 <dbushenko> cabal-install version 1.20.0.3
12:56:00 <albeit> dcoutts_: A type of (Double, Int)
12:56:02 <dcoutts_> dbushenko: see the log file that the error message (probably) mentions
12:56:19 <dcoutts_> albeit: ok, in that case no, the behaviour will be exactly the same in terms of GC.
12:56:50 <dcoutts_> albeit: it's useful to understand why: suppose you have a mutable array and you replace the value at some entry,
12:56:52 <dbushenko> dcoutts_: no logs :-(
12:57:20 <dcoutts_> dbushenko: look higher in the output, there'll be something somewhere
12:57:28 <dcoutts_> dbushenko: at the point where it was installing that one
12:57:55 <dbushenko> dcoutts_, I have messages like this: atabase/HDBC/SqlValue.hs:265:29:
12:57:56 <dcoutts_> dbushenko: or ask it to install that one specifically so the output doesn't get lost with the rest
12:57:56 <dbushenko>     Ambiguous occurrence `defaultTimeLocale'
12:58:02 <dcoutts_> dbushenko: ok there we go
12:58:11 <dcoutts_> so it's a compile failure
12:58:22 <dbushenko> so what can I do here?
12:58:23 <dcoutts_> and that's the error reported by ghc
12:59:28 <torpet> I am trying to compare a list of strings against their reversed strings.
12:59:38 <dcoutts_> albeit: the array is really an array of pointers, pointers to (Double, Int) heap objects. So you'll allocate a new (Double, Int) and write the pointer to that into the mutable array. The old (Double, Int) is now garbage and will be collected later.
12:59:42 <torpet> So compared String s1 against rev_s2, rev_s3 and so on
13:00:06 <torpet> My idea was to put the reversed strings in a separate list and then just iterated over each original unreversed string to compare them agsinst this list.
13:00:16 <dcoutts_> albeit: so you see this is exactly the same in terms of GC as using an IntMap. And using an IntMap is simpler because it's a purely functional data structure.
13:00:20 <torpet> But that sounds very precedural to me, is there a better way?
13:00:27 <albeit> dcoutts_: Ah okay. What would be a value type that would benefit form a hash table for GC?
13:01:09 <dcoutts_> albeit: you wouldn't differentiate on memory use typically.
13:01:32 <dcoutts_> there can be other reasons for preferring pure containers vs mutable hashes, or indeed pure hashes
13:01:53 <dcoutts_> but memory use (as in total memory required), is not really a big point of difference
13:01:57 <albeit> Would hash tables be any faster than IntMaps?
13:02:18 <dcoutts_> if you're doing a lot of updates then maybe
13:02:29 <dcoutts_> there are also pure maps based on hashing
13:02:36 <mauke> you only have like 60 elements
13:02:38 <dcoutts_> you probably don't need to use a mutable one
13:02:40 <mauke> that's tiny
13:03:51 <albeit> Okay, if I'm doing 4000 lookups/updates on 60 elements, would I see a speed advantage moving away from IntMaps?
13:04:55 <dcoutts_> albeit: 4000 is trivially small. The time will be approx 0 for any ordinary container type :-)
13:05:41 <albeit> The entire functions take 40 microseconds right now, and any improvement would help...
13:05:49 <albeit> Thinking this may be an avenue to improve it
13:06:00 <dcoutts_> ah ok, if you really care about microseconds...
13:06:31 <dcoutts_> albeit: benchmark your code using IntMap (from containers) and HashMap (from unordered-containers)
13:07:19 <dcoutts_> albeit: and if you really really need to shave off microseconds then there are other options
13:07:31 <dcoutts_> albeit: depending on your mix of updates vs lookups
13:07:49 * hackagebot ConfigFile 1.1.3 - Configuration file reading & writing  http://hackage.haskell.org/package/ConfigFile-1.1.3 (JohnGoerzen)
13:08:10 <haasn> Shaving off microseconds is not fun
13:08:16 <albeit> Lookups will be much greater (10x or so) than updates
13:08:28 <albeit> I shall benchmark HashMap against IntMap for sure
13:08:58 <haasn> Especially once you start ignoring the ADTs and instead represent your trees unboxed arrays
13:09:50 <dcoutts_> albeit: also, change from (Double, Int) to a custom type like data Blah = Blah {-# UNPACK #-} !Double  {-# UNPACK #-} !Int
13:10:07 <CodeWeaverX> Ooooohkeydokee, my googlehooglefu is failing me‚Ä¶ anybody know of a Haskell package like Data.Map that allows duplicate keys?
13:10:07 <dcoutts_> will save two allocations and indirections
13:10:36 <dcoutts_> CodeWeaverX: Map k [a]?
13:11:13 <albeit> dcoutts_: Nifty, thanks
13:11:14 <CodeWeaverX> okay, yes, that would work, except when removing elements, I‚Äôd like there not to be a dead entry in the tree.  Not that I can‚Äôt manage that myself reasonably easily.
13:12:20 <dcoutts_> CodeWeaverX: you can do your deletes using Map.alter, where you can return Nothing if you're deleting the last entry
13:12:41 <CodeWeaverX> Oh, interesting.  Didn‚Äôt notice that.  My thanks, dcoutts_
13:12:43 <chrisdone> apparently these days !Int and !Double are automatically unpacked in ghc 7.8, so i heard
13:12:56 <albeit> dcoutts_: Actually I misspoke, the values are of type (Int, Int), does that affect anything?
13:13:22 <dcoutts_> CodeWeaverX: ah, see http://hackage.haskell.org/package/multimap
13:13:37 <dcoutts_> CodeWeaverX: it's a wrapper around Map k [a]
13:13:46 <chrisdone> tuples are lazy, they're boxed
13:13:53 <dcoutts_> albeit: no
13:13:53 <CodeWeaverX> dcoutts_: Even better.  So my even more thanks. :)
13:14:13 <chrisdone> so when dealing with performance it's good to carefully consider whether you want a tuple or a strict data type
13:14:14 <dcoutts_> CodeWeaverX: the magic keyword here is "multi" multimap / multiset
13:14:23 <dcoutts_> that's the standardish name for this concept
13:14:31 <CodeWeaverX> dcoutts_:  I see that now, and I‚Äôm having a facepalm moment for not using that as a search keyword.
13:14:57 * dcoutts_ is pleased that the hackage search worked nicely in this case
13:14:58 <dcoutts_> http://hackage.haskell.org/packages/search?terms=multimap
13:17:50 * hackagebot semi-iso 0.2.0.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.2.0.0 (pawel834)
13:17:52 * hackagebot syntax 0.1.0.0 - Abstract syntax descriptions for parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-0.1.0.0 (pawel834)
13:19:46 <Evilsparza> is there a "written" function for (+) like subtract for - in the base library?
13:20:17 <dcoutts_> Evilsparza: no, because it's not needed
13:20:57 <mauke> subtract only exists because unary minus is a kludge in the syntax
13:20:59 <CodeWeaverX> The only reason subtract exists is because you can‚Äôt use an operator section with (-), like (-3) because that means unary negation.
13:21:07 <CodeWeaverX> Beaten by milliseconds.
13:21:13 <solrize> http://www.urbandictionary.com/define.php?term=Warm%20Fuzzy%20Thing
13:21:18 <albeit> dcoutts_: Beauty, the strictifying and unpacking cut about 15% off the time
13:21:44 <Evilsparza> well, ok, thanks anyway
13:22:50 * hackagebot syntax-attoparsec 0.1.0.0 - Syntax instances for Attoparsec.  http://hackage.haskell.org/package/syntax-attoparsec-0.1.0.0 (pawel834)
13:22:52 * hackagebot syntax-pretty 0.1.0.0 - Syntax instance for pretty, the pretty printing library.  http://hackage.haskell.org/package/syntax-pretty-0.1.0.0 (pawel834)
13:22:54 * hackagebot syntax-example 0.1.0.0 - Example application using syntax, a library for abstract syntax descriptions.  http://hackage.haskell.org/package/syntax-example-0.1.0.0 (pawel834)
13:24:57 <dbushenko> what is best way to access mysql from haskell?
13:25:40 <dcoutts_> albeit: and once you've benchmarked IntMap and HashMap, and if you still want it faster then you can try the hashtables package (3 different hash tables), but it's less easy to use because it operates in either the ST or IO monads
13:25:44 <dcoutts_> rather than being pure
13:26:15 <dcoutts_> use ST if you can, IO if you must
13:26:38 <kadoban> dbushenko: I've used HDBC and it seemed okay
13:26:58 <dbushenko> kadoban, I looked at hdbc-mysql, and it looks abandoned
13:27:46 <albeit> dcoutts_: So probably going to have to resort to unsafePerformIO? (For my first time!)... unless I move everything into ST/IO, but that may be cumbersome
13:28:35 <kadoban> dbushenko: Well, it wasn't too long ago that I used it and it seemed to work fine. Not sure beyond that.
13:28:56 <dbushenko> it says, the driver is tested against mysql 5.1
13:29:02 <dbushenko> which is very old...
13:30:13 <dcoutts_> albeit: using unsafePerformIO would be wrong, very wrong. But you can use ST and runST
13:30:54 <albeit> dcoutts_: Ah okay, gotta get more familiar with ST
13:31:41 <jhance> Is there a specialized type function of return for map? return <$> ... does not make it particularly clear that return is a -> [a]
13:31:48 <jhance> for lists*
13:32:11 <jhance> (:[]) just looks ugly
13:34:29 <ThreeOfEight> jcurbo: not according to Hoogle, no
13:34:32 <ThreeOfEight> sorry
13:34:37 <ThreeOfEight> that was for jhance
13:35:03 <ThreeOfEight> there is ‚Äòpure‚Äô, of course, but that is no better than ‚Äòreturn‚Äô
13:35:09 <Fuuzetsu> let singleton = return
13:41:20 <jarlg> Hello! Whenever I compile using ghc I get a msg I'm using a new, untested LLVM and after compiling a simple hello world prog. I get "schedule: re-entered unsafely. perhaps a foreign import unsafe should be safe?". Also I'm running ARM, and I think this happened after cancelling a bit cabal install (that took too long). I'm kind of at a loss here. Any ideas how I can get ghc to compile properly?
13:41:46 <torpet> I am working on this function: reverseCheck t = filter (\(a,b) -> (a == b)) $ map (\x -> (x, reverse x)) $ words .concat $ t
13:41:46 <trap_exit> is there a way to create  "singleton mvar" in haskell ?
13:41:48 <joe9> Want to check if anyone knows of more examples regarding "delimited continuations" usage? http://www.haskell.org/haskellwiki/Library/CC-delcont https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html
13:41:57 <trap_exit> is there a way to create  "singleton mvar" in haskell ? -- without using unsafeperformIO
13:42:31 <torpet> I am having a list of tuples, and want to check if a==b, but the problem is that is always true since tuple1.a will be compared against tuple1.b, which always returns true
13:42:53 * hackagebot bindings-libusb 1.4.5.0 - Low level bindings to libusb.  http://hackage.haskell.org/package/bindings-libusb-1.4.5.0 (BasVanDijk)
13:44:46 <Fuuzetsu> torpet: it's unclear what you want to do
13:45:18 <torpet> Fuuzetsu: http://lpaste.net/2885392495837970432
13:46:21 <torpet> So, basically I am trying to compared if a list of strings contains 1 or more strings that are equal to the "reverse" of another string.
13:46:39 <josephle> so you're checking for palindromes?
13:46:45 <torpet> exactly
13:46:53 <joe9> http://okmij.org/ftp/continuations/ZFS/ZipperM.hs I am trying to get this code to compile and am getting these errors: http://codepad.org/Ui21dCH5 . just want to check if these are easy to fix.
13:46:56 <Fuuzetsu> are you just trying to check that every word given is a palindrom?
13:46:58 <Fuuzetsu> palindrome*
13:47:14 <torpet> Fuuzetsu: I am just trying to find out if a single one exists and then return true
13:47:29 <Fuuzetsu> :t any (\x -> x == reverse x)
13:47:30 <lambdabot> Eq a => [[a]] -> Bool
13:47:59 <Fuuzetsu> > any (\x -> x == reverse x) ["abc", "def", "aba"]
13:48:00 <lambdabot>  True
13:48:49 <albeit> dcoutts_: HashMap seems to be slower by about 20%, but may be because I had to write my own mapMaybeWithKey, as one is in IntMap but not HashMap. If HashMap is slower, is it worthwhile to try hashtables?
13:49:03 <torpet> Fuuzetsu: wow
13:49:05 <phaazon> quick question: do we have to add LICENSE in the extra-files in cabal if it‚Äôs already in license-file?
13:49:06 <torpet> thanks!
13:49:32 <Fuuzetsu> phaazon: no
13:49:39 <phaazon> ok
13:49:42 <phaazon> thanks! :)
13:50:37 <dfeuer> I'll palinyourdrome.
13:51:46 <torpet> Fuuzetsu: Just out of interested, a specific string is checked against itself, but fails
13:51:52 <torpet> is that correct?
13:52:54 * hackagebot linux-namespaces 0.1.1.0 - Create new or enter an existing linux namespaces  http://hackage.haskell.org/package/linux-namespaces-0.1.1.0 (MariosTitas)
13:52:56 * hackagebot monad-journal 0.5.0.1 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.5.0.1 (DimitriSabadie)
13:53:21 <Fuuzetsu> torpet: it just checks if the string given is the same in reverse
13:53:24 <Fuuzetsu> not sure what your question is
13:53:33 <vanila> joe9, how are you getting CCXe?
13:53:36 <torpet> Fuuzetsu: Lol, dumbest question ever, sorry.
13:53:57 <torpet> I was confused by what I made up in my brain until you showed me your simple solution.
13:54:05 <torpet> All clear. :)
13:55:21 <NemesisD> i noticed the prelude's definition of or uses foldr. it could just as easily use foldl right?
13:55:36 <S11001001> NemesisD: No; that wouldn't be as lazy
13:55:54 <mauke> foldl can't short-circuit
13:56:05 <NemesisD> ah
13:59:05 <vanila> joe9 ah I got it to compile
14:01:43 <albeit> Is "data Foo = Foo {-# UNPACK -#} Int! {-# UNPACK -}  !Int" any different than "data Foo = Foo !Int !Int" when -funbox-strict-fields is enabled?
14:01:56 <joe9> vanila: cool.  http://codepad.org/9v5wOomF is how you did it ?
14:02:16 <vanila> yeah
14:02:29 <joe9> vanila: http://codepad.org/VSwqgyjy error: http://codepad.org/hKVZkAwJ
14:02:37 <joe9> vanila: any suggestions on how to fix that?
14:02:43 <joe9> I read that it is deprecated.
14:02:49 <vanila> hm i dont know about that one
14:02:49 <joe9> s/it/try/
14:03:01 <vanila> if you find out plpease tell me, im looking into it too
14:03:45 <joe9> vanila: if you are, this file might also be of use to you: http://codepad.org/VmNWUBDH
14:04:09 <joe9> https://ghc.haskell.org/trac/ghc/ticket/4865 vanila
14:04:54 <joe9> tryIOError is the fix
14:04:59 <joe9> vanila: ^^
14:05:31 <joe9> vanila: that worked.
14:05:35 <vanila> oh nice!
14:06:02 <joe9> vanila: thanks for your help. Are you interested in ZipperFS? or continuations?
14:06:09 <vanila> yeah both
14:06:55 <joe9> vanila, do you understand "delimited continuations"? I think I get it theoretically.
14:07:07 <joe9> but, having some examples to try it out is what I am looking for.
14:07:33 <joe9> vanila: Is there any material that helped you to understand "delimited continuations"?
14:07:43 <vanila> joe9, A little - the ZFS stuff usees multiprompt continuations which are harder though (i don't realy get them yet)
14:07:57 <vanila> joe9, one thing that really helped me was understand their CPS semantics
14:08:09 <vanila> in particular that RESET sets the identity cont and SHIFT composes two continuations
14:08:13 <vanila> it was in some danvy paper
14:10:03 <joe9> vanila: oh, ok. do you remember the paper name by any chance?
14:10:09 <eitan_chatav> http://okmij.org/ftp/papers/LogicT.pdf
14:10:12 <eitan_chatav> this one?
14:13:18 <vanila> hm
14:20:09 <johnw> joe9: also see https://www.fpcomplete.com/user/dolio/monad-transformers-and-static-effect-scoping and maybe http://parametricity.net/dropbox/yield.subc.pdf
14:20:23 <johnw> and then there is http://repository.readscheme.org/ftp/papers/plsemantics/danvy/db_thesis.pdf
14:21:53 <joe9> https://github.com/joe9/zipperfs vanila
14:21:59 <joe9> johnw: ok, thanks a lot.
14:29:20 <jessicah> in ghc's settings file, how do I set the global package path?
14:30:06 <jonsterling> Question on STM:
14:30:52 <jonsterling> I'm getting "thread blocked indefinitely in an STM transaction", and I think it is coming from where I try to wait indefinitely on a TQueue. Now, I really do want to wait forever until something appears in the queue. If this is indeed the source of the exception, how can I get the behavior I want?
14:31:18 <MitchellSalad> doesn't "retry" do exactly that?
14:31:30 <jonsterling> Oh, you might be right!
14:31:34 <MitchellSalad> =)
14:31:49 <MitchellSalad> feels good giving advice to jon sterling
14:32:02 <joe9> jonsterling: Do you know about Chan?
14:32:21 <jonsterling> MitchellSalad: Oh, sadly `peekTQueue` (which is what I was doing) actually does retry.
14:32:34 <jonsterling> joe9: I've used it, but I am not knowledgeable on it...
14:33:05 <joe9> oh, ok. just wanted to check if you are aware of it.
14:33:33 <torpet> why is the following code not working? http://lpaste.net/701086766064467968
14:33:36 <torpet> the error message means nothing to me
14:33:42 <jonsterling> So any ideas then MitchellSalad?
14:34:11 <monochrom> jonsterling, I conjecture that the problem is elsewhere
14:34:23 <jonsterling> monochrom: Thanks, you might be right...
14:34:59 <MitchellSalad> jonsterling: I haven't seen that exact error message, it seems to indicate that there are no writers to your tqueue
14:35:08 <jonsterling> monochrom: Do you know which things can lead to that exception?
14:35:18 <monochrom> that will depend on actual code
14:35:32 <jonsterling> MitchellSalad: How would it know that there are no writers to the queue?
14:36:08 <indiagreen> torpet: in ‚Äúlet (a,b) = splitAt n t in a : formatText' b n‚Äù, ‚Äúa‚Äù is a list of lines, right?
14:36:11 <jonsterling> monochrom: Indeed. If it helps, in this code I am only using TQueue, TChan, and TVar.
14:36:28 <indiagreen> and ‚ÄúformatText' b n‚Äù is a list of lines as well
14:36:57 <jonsterling> So it sounds like probably a thread which was meant to write to one of these things died at some point
14:37:10 <indiagreen> you should be using ‚Äú++‚Äù instead of ‚Äú:‚Äù to stick them together
14:37:49 <torpet> indiagreen: n is an Int, number of chars per line
14:37:53 <torpet> b is the reminaing text
14:38:22 <indiagreen> but your Text is a list of strings, not chars
14:38:24 <torpet> indiagreen: i was using ++ until a few days ago when i discovered lpaste. lpaste recommends the : syntax
14:38:39 <MitchellSalad> jonsterline: i'm not exactly sure how it knows, but a `retry` will only run when one of the contended variables was written to, so that's just my best guess
14:38:43 <jessicah> mm, nvm. better question: how do I regenerate my package.conf.d contents? the paths are all incorrect
14:38:44 <indiagreen> okay, can you explain what you want ‚ÄúsplitAt n t‚Äù to do?
14:39:06 <latk> is there a pattern to deal with cascading case statements, where you want to do something else if the case fails?
14:40:27 <jessicah> (in both the individual .conf files and the package.cache file)
14:40:58 <jonsterling> Ok, thanks everyone for the input
14:41:05 <torpet> indiagreen: splitAt n t takes Text t and split it after char n
14:41:12 <MitchellSalad> do you have any hunches?
14:41:14 <torpet> indiagreen: http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:splitAt
14:41:35 <indiagreen> torpet: and ‚ÄúText‚Äù is a list of lines, right?
14:41:39 <torpet> yes
14:41:45 <torpet> so a string array
14:41:53 <MitchellSalad> jonsterling: if you can make an hpaste of all the relevant moving parts i can take a closer look
14:41:54 <torpet> Wow I am an idiot
14:42:00 <indiagreen> in this case, ‚ÄúsplitAt n t‚Äù would split not at the n-th char, but n-th line
14:42:02 <c_wraith> latk: Depends..  If it's cascading matches on Maybe or Either values, the monad interface cleans that up nicely
14:42:13 <c_wraith> latk: (guessing based on your use of the word "failure")
14:42:17 <torpet> :D
14:42:52 <torpet> So I am going to merge the String Array into one first
14:42:53 <latk> c_wraith: Well, lists. I guess I want something related to bind, but I don't know what
14:42:54 <torpet> and be done
14:44:07 <torpet> indiagreen: any reason why I should be using ++ instead of :?
14:44:28 <n4x> @type (++)
14:44:29 <lambdabot> [a] -> [a] -> [a]
14:44:31 <n4x> @type (:)
14:44:32 <lambdabot> a -> [a] -> [a]
14:44:39 <indiagreen> torpet: use ‚Äú++‚Äù when you have 2 lists, ‚Äú:‚Äù when you have a single element and a list
14:45:00 <dal0> why is this not working? when i try and compile i get the error that ‚ÄúCouldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòLetter‚Äô‚Äù http://pastebin.com/LBLM24w6
14:45:07 <dal0> thank you!
14:45:08 <torpet> indiagreen: thanks
14:45:26 <indiagreen> dal0: you forgot backticks around ‚Äúmod‚Äù
14:45:53 <dal0> ok will try again
14:47:00 <dal0> doesnt help error
14:48:02 <indiagreen> dal0: you also got fromEnum and toEnum wrong
14:48:04 <geekosaur> haven't you got your fromEnum/toEnum backwards?
14:48:13 <indiagreen> @type fromEnum
14:48:14 <lambdabot> Enum a => a -> Int
14:48:16 <indiagreen> @type toEnum
14:48:17 <lambdabot> Enum a => Int -> a
14:48:47 <dal0> this has come straight from a textbook
14:48:55 <dal0> that specific line
14:49:24 <dal0> i think issue is to do with the conversion of Letter to have Enum properties
14:49:29 <dal0> because i get ‚ÄúCouldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòLetter‚Äô‚Äù
14:49:34 <dal0> am i using deriving correctly?
14:52:18 <Fuuzetsu> your deriving is fine
14:52:58 <Fuuzetsu> fromEnum (toEnum l + 1 `mod` 26) should work
14:53:26 <Fuuzetsu> dal0: why don't you use succ though
14:53:27 <Fuuzetsu> :t succ
14:53:28 <lambdabot> Enum a => a -> a
14:53:33 <indiagreen> it doesn't wrap
14:53:50 <indiagreen> @let data Letter = A | B | C | D deriving (Eq, Ord, Enum)
14:53:52 <lambdabot>  Defined.
14:53:59 <indiagreen> > fromEnum A
14:54:01 <lambdabot>  0
14:54:05 <indiagreen> > toEnum A
14:54:06 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
14:54:07 <lambdabot>              with actual type ‚ÄòL.Letter‚Äô
14:54:17 <Fuuzetsu> :t \l -> if l == maxBound then minBound else succ l
14:54:18 <lambdabot> (Eq a, Enum a, Bounded a) => a -> a
14:55:29 <dal0> indiagreen does that work for u
14:55:58 <indiagreen> dal0: does what work?
14:56:30 <dal0> oh i thought u were reworking it
14:56:40 <dal0> basically we have to figure this out using our own data type and deriving
14:56:55 <dal0> i am just not sure why i am getting this error though so succ isnt allowed im afraid
14:57:02 <indiagreen> okay, without succ
14:57:04 <indiagreen> here we go
14:57:43 <indiagreen> > fromEnum A -- this is how you get the position of letter
14:57:44 <Fuuzetsu> you need to stop saying ‚Äòdoesn't work‚Äô and start posting 1. The code you're using 2. The error message for that code
14:57:45 <lambdabot>  0
14:58:03 <indiagreen> > fromEnum A + 1 -- this is how you get the position of the next letter
14:58:04 <lambdabot>  1
14:58:39 <indiagreen> I won't continue, but now you should figure out how to use toEnum and `mod` and so on to finish the deed
14:58:54 <dal0> ok thanks will give a try
14:59:04 <dal0> apologies also we‚Äôve just started learning haskell like a week ago
14:59:27 <benzrf> dal0: hella
15:03:01 * hackagebot linear 1.11 - Linear Algebra  http://hackage.haskell.org/package/linear-1.11 (EdwardKmett)
15:15:35 <dfeuer> :t fromEnum fromEnum
15:15:36 <lambdabot>     No instance for (Enum (a0 -> Int)) arising from a use of ‚ÄòfromEnum‚Äô
15:15:36 <lambdabot>     In the expression: fromEnum fromEnum
15:15:36 <lambdabot>     No instance for (Enum a0) arising from a use of ‚ÄòfromEnum‚Äô
15:20:07 <torpet> I have been trying to debug this function the last 30 mins, but to no avail: http://lpaste.net/4057800292836573184
15:20:18 <torpet> Text is just [String]
15:21:14 <mauke> fromInteger only takes 1 argument, not 2
15:21:46 <piskrist> I wish I could write my girlfriend in haskell
15:22:39 <eitan_chatav> like write a letter to her, or create her, weird science style?
15:23:27 <acowley> Do you realize it's snowing in my room?
15:23:42 <torpet> mauke: thanks, but that's why i put the $ there
15:23:57 <torpet> could this be written without braces?
15:24:30 <mauke> torpet: what
15:24:44 <mauke> you put the $ there to get a type error? or what do you mean?
15:25:05 <chrisdone> eitan_chatav: that can only end weirdly
15:25:19 <glguy> torpet: If your goal is lack of parentheses above all other considerations:   fromInteger n `splitAt` s
15:25:30 <glguy> but it would be better with parentheses.
15:25:46 <chrisdone> eitan_chatav: like this http://i.ytimg.com/vi/I71OlRUDCQQ/hqdefault.jpg
15:26:05 <eitan_chatav> chrisdone: mst3k!!!
15:26:05 <torpet> glguy: thats what ive been trying to do yeah
15:26:08 <chrisdone> <3
15:26:17 <torpet> im very new to haskell and thought i had figured out $ and ., but apparently i didn't
15:26:48 <bernalex> f xs = xs >>= \a -> case a of mzero -> mempty; Just x -> return x
15:27:09 <glguy> splitAt $ fromInteger n s   is     splitAt $ (fromInteger n s)     is    splitAt (fromInteger n s)
15:27:14 <bernalex> why on earth does Just overlap mzero here?
15:27:23 <n4x> that is going to return mempty all the time
15:27:30 <chrisdone> @src ($)
15:27:30 <lambdabot> f $ x = f x
15:27:37 <glguy> bernalex: Because you're defining a new variable called mempty
15:27:45 <glguy> You aren't using the existing one
15:27:48 <fragamus> hey this function parseCSVFromFile takes a path to a file, and I want it to read from stdin...   so....  I'm screwed right
15:27:50 <bernalex> glguy: erwat
15:28:08 <bernalex> glguy: why does it work the other way around, with Just first?
15:28:11 <chrisdone> fragamus: pass it /dev/stdin ( Õ°¬∞ Õú ñ Õ°¬∞)
15:28:17 <glguy> bernalex: It's the same as this:   case a of freshName -> mempty; Just x -> return x
15:28:19 <n4x> glguy: "something var = ...", you are not pattern matching
15:28:29 <n4x> well, you're matching against everything
15:28:30 <fragamus> ooh nice
15:28:39 <n4x> not "comparing" to the variable
15:28:48 <chrisdone> fragamus: are you using the csv package?
15:28:54 <bernalex> glguy: oh how do I check if it's mzero?
15:29:05 <fragamus> http://hackage.haskell.org/package/csv-0.1.1/docs/Text-CSV.html
15:29:16 <bernalex> oh of course
15:29:22 <bernalex> sorry, minutes of ssh lag here
15:29:24 <glguy> bernalex: You could pattern match against   Nothing, or:   case a of whatever | whatever == mempty ->
15:29:52 <chrisdone> fragamus: FWIW, this is not a very efficient or configurable CSV package
15:30:15 <bernalex> ok so how on earth does this desugar: f xs = do { Just x <- xs ; return x } ?
15:30:25 <chrisdone> fragamus: cassava is better http://hackage.haskell.org/package/cassava-0.4.2.0/docs/Data-Csv.html
15:30:25 <glguy> ?undo do { Just x <- xs ; return x }
15:30:25 <lambdabot> xs >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
15:30:43 <bernalex> yeah that's my best bet so far
15:31:34 <BMeph> f :: m (Maybe a) -> m a
15:32:16 <monochrom> safeFromMaybeM :: Monad m => m (Maybe a) -> m a :)
15:32:44 <torpet> :r
15:33:04 <torpet> epic fail
15:33:34 <torpet> glguy: none of the above methods work
15:33:47 <glguy> torpet: I won't know what you did wrong unless you show me what you tried
15:33:51 <torpet> splitAt (fromInteger n) s
15:34:15 <torpet> glguy: http://lpaste.net/5510932405046738944
15:34:58 <mauke> > (\n s -> splitAt (fromInteger n) s) 3 "hello"
15:34:59 <lambdabot>  ("hel","lo")
15:35:12 <glguy> torpet: Your type signature doesn't match your implementation, did you mean to return a [Text] ?
15:35:23 <mauke> no, Text = [String]
15:35:24 <glguy> rather:
15:35:53 <torpet> mauke: yes
15:37:49 <Sonderblade> how would you do the following in haskell:
15:37:52 <Sonderblade> given a req, take its "content-length" header, signal error A if missing
15:38:02 <Sonderblade> convert it to a number, signal error B if you cant
15:38:16 <Sonderblade> check if it is >= 0, signal error C if not?
15:38:39 <Sonderblade> i can do it using ugly nested ifs
15:38:48 <n4x> what is the format of a "Req"?
15:39:20 <Sonderblade> a http Request record, basically a hash
15:39:23 <indiagreen> Sonderblade: you can use the Either monad
15:39:51 <Sonderblade> i dont see it
15:40:28 <EvanR> its the exception pattern, which Either monad does
15:40:36 <EvanR> Either Error a
15:40:49 <indiagreen> here's a tutorial, if you don't mind spending 15 or so minutes reading it: https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/10_Error_Handling
15:43:05 * hackagebot purescript 0.5.7 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.7 (PhilFreeman)
15:43:36 <Sonderblade> i still dont see how either is applicable
15:43:54 <nomeata> Hi. It seems that http-client is a bit low-level. Do we have something more higher level? For example something that manages cookies behind my back?
15:45:00 <glguy> nomeata: Have you looked at Network.Browser? http://hackage.haskell.org/package/HTTP-4000.2.18/docs/Network-Browser.html
15:46:01 <indiagreen> > Left "error A" >> Right 13 -- an example for Sonderblade which shows how Either doesn't care about the later ‚Äúsuccess‚Äù if there was an early error
15:46:03 <lambdabot>  Left "error A"
15:46:29 <indiagreen> > Right 0 >> Right 13
15:46:30 <lambdabot>  Right 13
15:47:48 <lpaste> cdk pasted ‚Äúeither error handling‚Äù at http://lpaste.net/113418
15:47:59 <nomeata> glguy: thx, I guess I should
15:48:00 <cdk> Sonderblade: take a look at that paste
15:49:20 <indiagreen> cdk: ‚Äúif n >= 0 then True else C‚Äù won't work, will it
15:49:38 <cdk> indiagreen: you're right, i just edited it. Forgot to use Left/Right
15:53:57 <Sonderblade> cdk: thanks. doesn't seem like Either gains me so much over nested ifs in this case though
15:53:59 <Sonderblade> maybe im wrong
15:55:45 <absence> is there an operation similar to Data.List.group that instead of grouping a bunch of duplicate elements stores them once along with a length?
15:56:01 <acowley> Sonderblade: It would mean you wouldn't have to nest things.
15:56:21 <indiagreen> absence: not to my knowledge, but it's easy to write it yourself
15:56:30 <piskrist> How do I parse yaml file and then add defaults?
15:56:37 <cdk> > map (head &&& length) . group . sort $ [1,2,3,1,2,1] -- absence
15:56:39 <lambdabot>  [(1,3),(2,2),(3,1)]
15:56:40 <acowley> :t map (\xs@(x:_) -> (x, length xs)) . group
15:56:41 <lambdabot> Eq a => [a] -> [(a, Int)]
15:56:56 <piskrist> I'm using Data.Yaml and the deriving (Genric) way
15:57:08 <lpaste> glguy pasted ‚Äúchecking requests?‚Äù at http://lpaste.net/113422
15:57:16 <glguy> Sonderblade: Are you just looking for something like this?
15:57:21 <piskrist> https://github.com/yaccz/code-snippets/blob/master/haskell/parsing-yaml/main.hs like here
15:57:45 <absence> thanks :)
15:58:19 <acowley> piskrist: I do this using my yaml-light-lens package and prisms
15:58:33 <Sonderblade> glguy: that ones wrong because it doesn't convert the value to an int isn't it?
15:58:59 <piskrist> acowley: do you have a code example?
15:59:10 <glguy> Sonderblade: It can't be wrong, it's just trying to give an example of structure
15:59:26 <glguy> Sonderblade: your question is vague to me and I'm hoping to pin it down
16:01:52 <piskrist> acowley: I have come up with https://github.com/yaccz/yac-build-server/blob/wip/library/YacBuildServer/Ybs.hs#L59 but that's ugly and mainly error-prone
16:03:08 <acowley> piskrist: Well it would just be something like, fromMaybe Default (doc ^? field)
16:03:58 <Sonderblade> glguy: ic. its about the "onion unpeeling idiom". you unpeel one layer, check if it errored, unpeel the next one, check for error etc
16:04:38 <Sonderblade> like in c you write: foo->bar->baz->and->so->on but you have to check if each -> is a null pointer before continuing
16:05:16 <cdk> Sonderblade: that's exactly the pattern Maybe (or Either) captures
16:05:52 <chrisdone> foo >>= bar >>= baz
16:06:00 <acowley> piskrist: If you don't want Maybes everywhere, you might want to not hard code them in the record definition. You could have one version with Maybes, and another with naked fields. Or you could parameterize ConfigServer by an f that wraps your fields.
16:06:06 <chrisdone> 'tis a very handy trick
16:06:24 <acowley> piskrist: Then you could have  ConfigServer Maybe, or ConfigServer Identity
16:07:08 <acowley> piskrist: If clients of this module always want all fields set, then you might define ConfigServerF f = ..., then type ConfigServer = ConfigServerF Identity
16:09:13 <acowley> Is there a common newtype (or name) for something like newtype T f b a = T { runT :: f a -> f b }
16:09:16 <acowley> ?
16:09:56 <cdk> acowley: looks like a partially applied fmap
16:10:07 <chrisdone> looks like Functor?
16:10:08 <acowley> Yeah
16:10:10 <acowley> with a little flip
16:10:19 <Fuuzetsu> could have sworn there was stuff on free monads somewhere on fpcomplete but I can't find it again
16:10:19 <piskrist> acowley: yeah, getting rid of Maybe is not really the problem there
16:10:27 <indiagreen> does anyone have a nice Writer example which isn't about logging?
16:10:39 <acowley> But I want the newtype (or data) so I can partially apply the type constructor
16:11:01 <piskrist> acowley: main problem is checking for one field but erroneously setting another. Effectively creating an infinite loop. It's not DRY
16:11:12 <absence> is &&& available somewhere else than Control.Arrow, or was that something i read about in a proposal for changing Arrow?
16:11:39 <acowley> piskrist: Then I'd just do, cfg & foo %~ fromMaybe defaultFoo & bar %~ fromMaybe defaultBar
16:11:44 <chrisdone> acowley: is there a polykind trick for not having to use Identity?
16:11:45 <acowley> piskrist: Or something like that
16:11:59 <chrisdone> acowley: sucks having to unwrap the Identity with runIdentity or coerce
16:12:21 <piskrist> :t (&)
16:12:22 <lambdabot> a -> (a -> b) -> b
16:12:38 <chrisdone> acowley: perhaps with a type family
16:12:49 <piskrist> :t (%~)
16:12:50 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:13:01 <piskrist> whoa what
16:13:06 <Fuuzetsu> oh, http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html is what I read
16:13:12 <cdk> indiagreen: you can use Writer with any Monoid, so
16:13:15 <chrisdone> piskrist: welcome to the `lens' package
16:13:17 <absence> :t (&&&)
16:13:18 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:13:29 <cdk> > execWriter $ mapM Sum [0..5] -- indiagreen
16:13:31 <lambdabot>  Couldn't match type ‚ÄòData.Monoid.Sum‚Äô
16:13:31 <lambdabot>                with ‚ÄòControl.Monad.Trans.Writer.Lazy.WriterT
16:13:31 <lambdabot>                        w Data.Functor.Identity.Identity‚Äô
16:13:31 <lambdabot>  Expected type: b0
16:13:31 <lambdabot>                 -> Control.Monad.Trans.Writer.Lazy.WriterT
16:13:44 <cdk> > execWriter $ mapM (tell . Sum) [0..5] -- indiagreen
16:13:46 <lambdabot>  Sum {getSum = 15}
16:14:15 <indiagreen> cdk: yeah, but I'm having trouble with finding an example which would use listen/pass/censor as well, wouldn't be about logging, and wouldn't be totally contrived
16:15:12 <edwardk> absence: you can get it out of any cartesian category: https://hackage.haskell.org/package/categories-0.59/docs/Control-Category-Cartesian.html
16:16:19 <dal0> why wont my function compute age well! its off by about 10 years
16:16:31 <dal0> actually no worries!
16:16:33 <dal0> haha
16:19:28 <absence> edwardk: interesting
16:20:00 <Sonderblade> cdk: but in the example you gave, the function were already in the either monad, a pointer dereferencing function, or a function for converting string>int likely isn't
16:21:34 <cdk> well a pointer dereferencing function doesn't really mean much in the context of Haskell. A function String -> Int cannot fail anyways, so using Maybe or Either doesn't make sense. I'm afraid I'm missing your point.
16:22:21 <cdk> If your function String -> Int can fail, then it should be String -> Maybe Int
16:23:10 * hackagebot yi-language 0.1.0.8 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.8 (JaredHance)
16:23:35 <piskrist> Sonderblade: are you trying to understand functors?
16:23:53 <cdk> Sonderblade: of course, you can take a pure function "f :: String -> Int" (that can never fail) and put it in the Maybe monad with "return . f :: String -> Maybe Int"
16:24:08 <cdk> but thats kind of pointless
16:25:40 <acowley> groan
16:25:43 <piskrist> Sonderblade: let's say you have Maybe Int and want to double the ammount if it is Just x. You can either make a branch with case mx of Just x -> x*2; Nothing -> Nothing. Or you can just fmap (*2) (Just 10)
16:25:44 <EvanR> note that it is possible to write a String -> Int that totally can fail
16:25:50 <EvanR> badly
16:26:39 <EvanR> > undefined :: String -> Int
16:26:41 <lambdabot>  <[Char] -> Int>
16:26:42 <cdk> acowley: I didn't even notice the pun :)
16:27:01 <EvanR> > let x = x in x :: String -> Int
16:27:02 <lambdabot>  <[Char] -> Int>
16:27:07 <acowley> cdk: It was brilliant in its own horrible way :)
16:27:15 <acowley> cdk: I'm just jealous I didn't say it
16:36:03 <Sonderblade> cdk: i meant: String -> Maybe Integer for the conversion string>number and Data.Map.lookup for lookups in a Data.Map
16:36:25 <Sonderblade> cdk: they are in the Maybe monad
16:36:51 <cdk> Sonderblade: well you're in luck, do-notation works just as well for the Maybe monad as it does the Either monad :)
16:37:19 <cdk> they both short-circuit on failure (Left for Either, Nothing for Maybe)
16:37:56 <Sonderblade> cdk: but i want different errors so the maybe monad doesn't fit
16:38:03 <cdk> then you want Either
16:38:53 <cdk> you need to pattern match (or use the "maybe" function) to return an Either value from your Maybe results
16:39:27 <cdk> case lookup key map of Nothing -> Left KeyNotFound; Just val -> Right val
16:39:50 <cdk> or: fromMaybe (Left KeyNotFound) $ lookup key map
16:40:11 <cdk> :t fromMaybe
16:40:12 <lambdabot> a -> Maybe a -> a
16:40:31 <cdk> ahh thats wrong
16:40:47 <cdk> maybe (Left KeyNotFound) Right $ lookup key map
16:40:55 <cdk> :t maybe
16:40:56 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:41:22 <benzrf> > maybe "no number" show (Just 3)
16:41:23 <lambdabot>  "3"
16:41:26 <benzrf> > maybe "no number" show Nothing
16:41:28 <lambdabot>  "no number"
16:42:31 <EvanR> NoN
16:45:55 <Sonderblade> cdk: doesn't that lead to nested case statements? how else would you continue from "Right val"?
16:46:48 <cdk> Sonderblade: with monads!
16:46:50 <acowley> > do { x <- Just 3; y <- Just 2; return (x,y) }
16:46:51 <lambdabot>  Just (3,2)
16:47:02 <cdk> > Left "error" >>= Right 4
16:47:04 <lambdabot>  Couldn't match expected type ‚Äòa0
16:47:04 <lambdabot>                                -> Data.Either.Either [GHC.Types.Char] b‚Äô
16:47:04 <lambdabot>              with actual type ‚ÄòData.Either.Either a1 b0‚Äô
16:47:10 <cdk> > Left "error" >>= \x -> Right 4
16:47:12 <lambdabot>  Left "error"
16:47:13 <haasn> > liftM2 (,) (Just 3) (Just 2)
16:47:15 <lambdabot>  Just (3,2)
16:47:18 <n4x> cdk: >>
16:47:29 <cdk> > Right "error" >>= Right . length
16:47:30 <acowley> > do { x <- Right 2; y <- Right 3; return (x,y) }
16:47:31 <lambdabot>  can't find file: L.hs
16:47:31 <lambdabot>  Right (2,3)
16:48:26 <acowley> do { x <- Right 2; y <- Left "boop"; return (x,y) }
16:48:33 <acowley> > do { x <- Right 2; y <- Left "boop"; return (x,y) }
16:48:35 <lambdabot>  Left "boop"
16:49:08 <cdk> Sonderblade: the monads for Maybe/Either handle all the "short circuit on failure, otherwise get the result and continue" logic
16:49:33 <acowley> Sonderblade: Those little examples show how the nesting is eliminated with the normal vertical layout of a do block
16:52:02 <Sonderblade> acowley: can you make an example with the functions i specified?
16:52:34 <haasn> What's the easiest way to get something similar in behavior and performance to scanf("%d", &n); ?
16:52:38 <haasn> n <- something :: IO Int
16:53:32 <acowley> Sonderblade: I think I missed the specification of the functions, but it's likely that cdk already said whatever I'd say
16:53:57 <monochrom> not easy yet. but I think the time is ripe to apply adjunction to Text.Printf to obtain Text.Scanf :)
16:54:42 <haasn> My particular use case is spoj.pl. It's a huge pain having to write like 10-20 lines of ByteString boilerplate for what's just one line in C
16:54:45 <Sonderblade> acowley: Data.Map.lookup, Text.Read.readMaybe (Maybe Integer), check >= 0 + a different error on each step
16:57:21 <monochrom> but if you're using ByteString, then there is already readInt
16:57:25 <EvanR> there the basic monad, should be simple extension to C monad
16:58:17 <acowley> Sonderblade: do { x <- fromMaybe (Left ErrA) Right $ lookup blah >>= readMaybe >>= \x -> x <$ guard (x >= 0); y <- ... }
16:58:48 <haasn> monochrom: Not quite the same thing; readInt fails if it can't parse anything, while scanf keeps reading input until it finds something
16:59:00 <haasn> Important distinction here :/
16:59:00 <acowley> Sonderblade: But I'd write a helper function of the form aux key pred = lookup key >>= readMaybe >>= \x -> x <$ guard (pred x)
16:59:07 <acowley> Sonderblade: And maybe pipe the error through that helper, too
16:59:27 <acowley> Sonderblade: Because you want the main control flow to be do { x <- aux ....; y <- aux ....}
16:59:30 <haasn> I also have to pass around the remaining input explicitly (eg. if using a lazy ByteString + getContents), rather than it being implicit
16:59:53 <haasn> those are two reasons I need so much boilerplate
17:00:00 <acowley> haasn: attoparsec?
17:01:18 <haasn> Not sure if that improves the situation
17:01:34 <haasn> I guess I could write a parser like many (junk *> integer)
17:02:10 <haasn> OTOH, I don't think spoj.pl has attoparsec :)
17:02:14 <haasn> It seems to only have GHC installed
17:09:46 <bitemyapp> johnw: moment of your time? Need to validate something about streaming libraries that isn't making a ton of sense to me.
17:10:29 <benzrf> bitemyapp: im good at pipes :^)
17:10:37 <bitemyapp> benzrf: https://twitter.com/strmpnk/status/527613059804954624
17:10:43 <johnw> bitemyapp: I'm here
17:11:07 <bitemyapp> johnw: see above link. What he's saying doesn't make a ton of sense/
17:11:13 <bitemyapp> (to me)
17:11:46 <benzrf> i do not understand eithre
17:11:55 <benzrf> i mean
17:11:56 <benzrf> yes
17:12:01 <benzrf> streaming libraries are pretty nonlazy
17:12:04 <benzrf> that's kind of the point
17:12:10 <johnw> i don't really understand his point at all
17:12:14 <bitemyapp> johnw: I don't either.
17:12:29 <benzrf> it looks like
17:12:42 <benzrf> he seems to think what you're arguing is whether laziness causes space leaks
17:12:46 <benzrf> not whether haskell implies space leaks
17:12:53 <benzrf> so he's saying "no streaming doesnt count cuz it isnt lazy"
17:13:09 <acowley> Yep
17:13:26 <indiagreen> haasn: by the way (just in case you haven't heard about it), Codeforces is another site with ACM-style tasks which has Haskell among supported languages, and it seems to be nicer than SPOJ (for instance, there are weekly contests)
17:13:30 <bitemyapp> that is ridiculous.
17:13:34 <glguy> Twitter is for writing, not reading
17:13:34 <acowley> Space leak due to laziness, but if you use something non-lazy, that's not laziness, therefore space leak
17:14:05 <acowley> bitemyapp: I guess the point would be to show something that is lazy that doesn't leak
17:14:52 <haasn> indiagreen: Sounds neat! Unfortunately, this is for uni, and there's not much I can do to change which system I'm forced to use
17:15:00 <acowley> bitemyapp: You could just have a list that you fold over in constant memory, for example
17:15:22 <bitemyapp> acowley: foldl' doesn't count because it's strict. So what, sum?
17:15:36 <bitemyapp> pseudo-constant memory, Integer being what it is.
17:16:34 <acowley> Well you want to evaluate something at some point, so there will be evaluation
17:16:50 <Welkin> isn't a stream lazy?
17:16:53 <Welkin> or does that not count?
17:17:00 <acowley> But the list itself is at least lazy
17:17:01 <glguy> bitemyapp: I'd expect that the argument is that laziness makes it too easy to have production defeating space leaks, rather than that it's impossible to come up with any examples of laziness that don't leak.
17:17:07 <Welkin> and it doesn't stay in memory either
17:17:21 <jayunit100_m> hi haskell ! https://gist.github.com/jayunit100/ec3e997d9bf3e85efee9 <-- this is causing an infinite loop for me, or some kind of stall (just a copy out of http://book.realworldhaskell.org/read/using-typeclasses.html )
17:17:44 <Welkin> haha
17:17:49 <Welkin> jayunit100_m: you made bos quit
17:17:50 <jayunit100_m> *Main> (read "Red")::Color
17:17:50 <jayunit100_m> ^CInterrupted.  -- i.e. i have to interrupt my terminal :(
17:18:00 <jayunit100_m> hahaha
17:18:07 <Welkin> the author of the book about which you are complaining
17:18:08 <jayunit100_m> :( well its a pretty boring snippet
17:18:37 <jayunit100_m> its a GREAT book
17:18:52 * Welkin imagines bos throwing his computer across the room and shouting after looking at jayunit100_m's snippet
17:18:56 <jayunit100_m> i learned lots of haskell from it.  i leave a lot of comments , hope they arent taken as criticism
17:18:58 <jayunit100_m> hahahahaha
17:19:08 <spopejoy> @msg carter
17:19:08 <lambdabot> Not enough privileges
17:19:18 <carter> spopejoy: /msg
17:19:21 <spopejoy> :)
17:20:04 <Welkin> jayunit100_m: compile it with runhaskell
17:20:21 <Welkin> to check what the compiler says
17:23:16 <indiagreen> jayunit100_m: 1. it should be ‚Äúdrop (length attempt) value‚Äù and not ‚Äúdrop (length attempt)‚Äù; 2. it works for me
17:23:16 * hackagebot stripe-haskell 0.1.0.3 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.3 (DavidJohnson)
17:23:23 <dmj`> ^ yea yea
17:23:38 <indiagreen> are you sure it's exactly the snippet you're compiling
17:23:44 <bitemyapp> dmj`: :)
17:23:52 <dmj`> bitemyapp: ;)
17:24:09 <bitemyapp> the new stripe library looks exciting.
17:24:12 <bitemyapp> I might take some hints from it.
17:24:21 <bitemyapp> 100% api coverage is a good goal.
17:25:24 <dmj`> bitemyapp: thanks, yea took a long time
17:25:42 <Welkin> haha
17:25:46 <Enigmagic> 100% api coverage is morally correct
17:25:49 <Welkin> what a coincidence
17:26:03 <Welkin> the stripe-haskell package shows up just as I was about to look it up
17:26:37 <dmj`> bitemyapp: the Types file 2072 lines, takes ghc like 20 seconds to compile it
17:26:43 <dmj`> is like*
17:27:22 <Fuuzetsu> isn't there an operator for sum type anywhere? Thought there was :+:
17:27:52 <mauke> `Either`
17:28:21 <Fuuzetsu> ‚Ä¶guess that will have to do
17:28:23 <bitemyapp> dmj`: yeah. I know them feels: https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Types.hs
17:28:37 <bitemyapp> dmj`: 1900 LOC, 47 newtypes.
17:28:49 <bitemyapp> dmj`: still nowhere near 100% api coverage because Elasticsearch is the Cthulhu of APIs.
17:29:40 <jayunit100_m> thats weird i did that replacement and it has no effect
17:30:32 <jayunit100_m> https://gist.github.com/29a1d380c6f99e6d6d6c <-- line 361 looks good to you ?
17:30:35 <dmj`> bitemyapp: recursive imports, the struggle is real
17:30:48 <jayunit100_m> indiagreen:  ^
17:30:59 <jayunit100_m> thanks , by the way for helping me :)
17:31:04 <torpet> How would you solve finding out the n of a ROT-n-encoded text when both cleartext and encoded phrase are given
17:31:05 <haasn> Hmm. Doesn't Stripe support XBT as well?
17:31:25 <vanila> torpet, just subtract the character codes
17:31:29 <Fuuzetsu> https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Types.hs#L991 missingwhitespace/10
17:31:36 <Luke> haasn: they haven't made the XBT API public yet
17:31:44 <haasn> Ah, okay
17:31:52 <torpet> vanila: do i just cast the chars to integer?
17:31:53 <bitemyapp> Fuuzetsu: ah nuts.
17:31:55 <bitemyapp> Fuuzetsu: thanks
17:32:04 <Fuuzetsu> I have already informed the authorities.
17:32:06 <bitemyapp> Fuuzetsu: how'd you find that so quickly?
17:32:08 <indiagreen> jayunit100_m: indent ‚ÄúreadsPrec‚Äù a bit
17:32:17 <bitemyapp> now wondering if hlint was supposed to catch that
17:32:28 <vanila> torpet, you can use ord to get the charcode
17:32:30 <vanila> :t ord
17:32:31 <lambdabot> Char -> Int
17:32:37 <Fuuzetsu> bitemyapp: I just happened to stop there when scrolling, maybe my brain caught the attrocity
17:32:39 <dmj`> haasn: someone on #stripe told me they were looking into their own currency or something.. https://www.stellar.org/
17:32:46 <benzrf> what is Stripe
17:32:53 <dmj`> http://stripe.com
17:33:05 <jayunit100_m> hmm parse errors now ....
17:33:11 <haasn> dmj`: How will people acquire it?
17:33:22 <Fuuzetsu> bitemyapp: no Show on TimeInterval?
17:33:31 <indiagreen> jayunit100_m: http://lpaste.net/113430
17:33:34 <Fuuzetsu> oh, you give it a manual one
17:33:34 <Luke> haasn: how will people aquire stellar?
17:33:48 <indiagreen> and now ‚Äúread "Red" ::¬†Color‚Äù works for me
17:34:05 <bitemyapp> Fuuzetsu: yeah had to.
17:34:11 <Luke> haasn: you have to get it via "trusted gateways" which are companies you send money to
17:34:11 <bitemyapp> Fuuzetsu: to match Elasticsearch's...stuff.
17:34:13 <jayunit100_m> indiagreen: okay ill try that out
17:34:35 <jayunit100_m> whoa ! It compiled
17:34:39 <torpet> vanila: any way to to that without data.char?
17:34:51 <torpet> charToInt
17:34:59 <jayunit100_m> indiagreen: how did you fix that ?
17:35:11 <jayunit100_m> it works, but im curious, how would i ever do it on my own ! :)
17:35:14 <iteratee> oddball request: anyone here from fpcomplete willing to talk about employment?
17:35:20 <dmj`> haasn: unsure but they have wallets, a protocol, ledger and client libs
17:35:22 <dmj`> https://github.com/stellar
17:35:31 <indiagreen> jayunit100_m: you accidentally defined an empty instance of ‚ÄúRead‚Äù and an unrelated ‚ÄúreadsPrec‚Äù function
17:36:05 <indiagreen> jayunit100_m: you could've noticed it because GHCi gives a warning: http://lpaste.net/113431
17:36:44 <jayunit100_m> yeah i saw that warning
17:37:08 <jayunit100_m> but how did you know that the error was whitespace relateD?
17:37:28 <bitemyapp> Fuuzetsu: thanks for catching that and reviewing my code out of nowhere. Find anything else?
17:37:51 <indiagreen> jayunit100_m: I'm afraid there's no answer for that apart from ‚ÄúI looked at it and the 1st thing I noticed was that indentation wasn't right‚Äù
17:38:12 <jayunit100_m> ah ok .  indentation rules in haskell are usually quite flexible
17:39:08 <dmj`> Fuuzetsu is the man
17:39:19 <jayunit100_m> looks like with this function, they are not quite so forgiving though
17:39:22 <indiagreen> it's actually a bit hard for me to predict whether some indentation choice would be right or wrong because I always indent everything and so ‚Äúno indentation‚Äù seems wrong even when it's not wrong
17:40:02 <boxrick> Howdy
17:40:54 <boxrick> How is everyone this evening?
17:41:04 <dmj`> boxrick: good you
17:41:35 <boxrick> Im good, I just came across Haskell never used it before and it looked interesting so thought id come for a ponder :)
17:42:37 <bitemyapp> boxrick: I've got a guide with a bag of links for learning Haskell and exploring various topics, want it?
17:43:19 * hackagebot stripe-haskell 0.1.0.4 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.4 (DavidJohnson)
17:43:59 <dmj`> bitemyapp: maybe he was intimidated?
17:44:22 <bitemyapp> well, I did ask permission beforehand in the hopes of not inundating them.
17:44:43 <MP2E> quickest ponderance ever
17:45:18 <trap_exit> I have define dmy own monads, FooM and BarM. What do I have to do to allow "lift" to do FooM -> BarM ?
17:45:29 <Lewix> do you have a list of websites entirely built with haskell? I know hundreth time you heard this question this month
17:45:58 <boxrick> bitemyapp: Sorry got thrown off! I would love those links ta very much :)
17:46:17 <bitemyapp> boxrick: yeah no problem: https://github.com/bitemyapp/learnhaskell
17:46:25 <bitemyapp> MP2E: LOL
17:46:31 <MP2E> :P
17:46:37 <simpson> :t lift -- trap_exit
17:46:38 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:46:50 <simpson> trap_exit: You're defining transformers, right?
17:46:54 <trap_exit> :t lift
17:46:55 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:47:02 <trap_exit> no
17:47:19 <trap_exit> I'm doing things like FooM a = StateT Foo HA.Client a
17:47:26 <trap_exit> type FooM a = StateT Foo HA.Client a
17:47:34 <trap_exit> type BarM a = StateT Bar HA.client a
17:47:41 <trap_exit> where HA.client is sorta like "IO" (I'm doing web dev in haskell)
17:47:48 <trap_exit> I'm not defining my own transformers
17:47:57 <ReinH> Then lift is not what you want. There's a package for monad morphisms called mmorph, but I don't think it's what you want
17:48:07 <trap_exit> okay
17:48:11 <trap_exit> so what do I really want?
17:48:15 <emmanueloga> hi, playing with least comprehensions here. Any ideas on how to implement the one on this paste will be appreciated :) http://lpaste.net/113432
17:48:17 <trap_exit> I don't know either.
17:48:27 <ReinH> trap_exit: Do you have a function f :: Foo -> Bar ?
17:48:55 <trap_exit> I have a function which is "update_bar :: Bar -> Foo -> Bar"
17:49:08 <bsummers> I'm having trouble installing wreq, since the compilation fails with a type error. How can I work around this, and is this a bug or a mistake on my part? This is with a fresh install of the haskell platform with the latest cabal-install. The packages that lead to the type error are lens-4.5 and wreq-0.2. https://gist.github.com/anonymous/f59359af9f8ab85cd111
17:49:15 <trap_exit> "Foo" is like a sub-data structure of "Bar", if this vague statement makes any sense, ReinH
17:49:44 <dbp> does anyone know how to get binaries to be as static as possible on macs? I'm building a program that links against the postgres client libraries, and I have libpq.a on my system, but the binary is linked against libpq.dynlib instead...
17:49:49 <trap_exit> ohhhh
17:49:51 <trap_exit> I got this figured out
17:49:58 <trap_exit> runStateT + manually patching the diffs
17:50:00 <trap_exit> yeah, this works :-)
17:50:29 <ReinH> You may be looking for something like https://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Zoom.html
17:51:32 <ReinH> dbp: try ghc --make -static -optc-static -optl-static
17:52:10 <dbp> ReinH: no, that doesn't work, because the system libraries only exist as dynamic libraries (hence why this is a specific problem on macs - linux works fine...)
17:52:25 <dbp> libcrt and libSystem are _only_ provided as dynamic libraries...
17:52:44 <ReinH> Unsure then, sorry
17:53:13 <dbp> ReinH: np, thanks for trying :)... this is what happens when I try to build cross platform tools...
17:53:40 <ReinH> dpn`: I just ship everything in docker containers trollolol
17:54:05 <dbp> ReinH: ironically, one of said tools main purposes is setting up the rest of the haskell code inside docker containers :)
17:54:10 <trap_exit> emmanueloga : has anyone resolved your list lpaste issue ?
17:55:08 <ReinH> dpn`: put that tool in a docker container. That's what I did.
17:56:56 <emmanueloga> trap_exit: no
17:57:06 <trap_exit> okay, so this is what you need
17:57:23 <trap_exit> a function foo :: Int -> Int -> Bool, where (foo a b) = is a multiple of all numbers <= b ?
17:57:40 <trap_exit> then you use filter + foo
17:57:54 <trap_exit> now that I've said this, this sounds sorta like a HW question
17:57:56 <trap_exit> please tell me it's not a HW question
17:58:20 * hackagebot acme-io 0.1.0.0 - The only true way to do IO in Haskell!  http://hackage.haskell.org/package/acme-io-0.1.0.0 (benzrf)
17:58:22 * hackagebot acme-io 0.1.0.1 - The only true way to do IO in Haskell!  http://hackage.haskell.org/package/acme-io-0.1.0.1 (benzrf)
17:58:39 <bsummers> Explicitly depending on lens-4.4 fixed my issue. Should I file a bug? lens-4.5 and wreq-0.2 seem to cause a conflict.
17:58:45 <trap_exit> acme-io spam
17:59:11 <benzrf> sorry
17:59:23 <trap_exit> benzrf: you wrote acme-io ?
17:59:27 <benzrf> ?
17:59:34 <benzrf> dude it just came into existence 3 seconds ago
17:59:46 <benzrf> /bin/sh: 1: Syntax error: Unterminated quoted string
17:59:48 <benzrf> crap
17:59:50 <benzrf> it's an acme package ( Õ°¬∞ Õú ñ Õ°¬∞)
18:00:06 <trap_exit> http://hackage.haskell.org/package/acme-realworld ... wtf are the acme packages ?
18:00:28 <kadoban> They're joke packages.
18:00:37 <trap_exit> http://hackage.haskell.org/packages/#cat:ACME <-- argh, what is acme ?
18:00:45 <benzrf> hilarious
18:01:34 <MP2E> acme is the company from looney toons cartoons, most notably from the Road Runner cartoons
18:01:36 <vanila> > unfoldr (\(n,i) -> Just (n, (lcm (i+1) n, i+1))) (1,1)
18:01:37 <lambdabot>  [1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12...
18:01:42 <MP2E> they always sold the coyote stuff that would fail to work :P
18:01:46 <emmanueloga> trap_exit: hahah a HW question. I wish I could go back to school :)
18:02:05 <shlomocomputer> Haskell newb.  Does anyone use Maybe () as an alternative to Bool?
18:02:27 <emmanueloga> I was playing with comprehensions and thought of that sequence... it is a funky sequence isn't it.
18:02:29 <shlomocomputer> I don't see any particular advantages, other that sometimes library functions return Maybies
18:02:49 <benzrf> shlomocomputer: that's terribly unuseful
18:02:53 <MP2E> shlomocomputer: that's exactly what it's for, often talked about is something called 'boolean blindness' which is the idea that booleans throw away all information other than true or false
18:02:54 <benzrf> shlomocomputer: but, i mean, like, you could do it
18:03:07 <MP2E> Maybe allows you to encode more information into the type besides just true or false
18:03:10 <ReinH> shlomocomputer: Not really, but using a Bool in place of a type that provides more information isn't great either
18:03:15 <ReinH> MP2E: Except that Maybe () doesn't do that
18:03:21 <MP2E> oh right
18:03:22 <MP2E> heh
18:03:23 <ReinH> Since it is isomorphic up to bottoms
18:03:34 <shlomocomputer> indeed, that's a good way of looking at it, they convey exactly the same amount of information
18:03:36 <ReinH> MP2E is right about boolean blindness though
18:03:39 <shlomocomputer> but Bool is more direct
18:04:12 <shlomocomputer> I was playing with shuttling Maybies around using >>= notation
18:04:18 <ReinH> You might prefer data MyFlag = On | Off or some other meaningful names :)
18:04:50 <shlomocomputer> Are Either and Alternative types used much in real world stuff?
18:05:07 <emmanueloga> vanila: nice.
18:05:08 <shlomocomputer> I read Either is good for exceptions
18:05:34 <benzrf> exceptionish
18:05:58 <benzrf> shlomocomputer: to be precise there are handy combinators that let you chain functions where if one returns an Either then the chain terminates
18:06:02 <benzrf> which is exceptiony
18:06:02 <kadoban> shlomocomputer: Either is quite useful, sure. Alternative too, slightly less used probably (btw, it's a typeclass, not a type)
18:06:36 <ReinH> shlomocomputer: Both are used frequently.
18:06:44 <shlomocomputer> ReinH:  cool
18:06:49 <ReinH> (Note that Alternative is a typeclass, not a type)
18:07:03 <shlomocomputer> Yeah, I knew that, I made it sound like they were both types
18:07:17 <ReinH> Alternative is used frequently in things like parsers
18:07:32 <shlomocomputer> benzrf:  You mean, returns a particular side of an Either?
18:07:54 <ReinH> shlomocomputer: Consider the Monad instance of Either a
18:08:22 * hackagebot ConfigFile 1.1.4 - Configuration file reading & writing  http://hackage.haskell.org/package/ConfigFile-1.1.4 (JohnGoerzen)
18:08:32 <shlomocomputer> ReinH:  Funny you mention, parsing is my next challenge.  I can't see right now how Haskell is a win with that, but experience tells me it'll be cool once I learn about it
18:09:23 <benzrf> shlomocomputer: turns out,
18:09:37 <benzrf> functor/applicative/monad is the *perfect* interface for parsers
18:10:03 <shlomocomputer> I love strong claims.  ;)
18:10:15 <ReinH> So does benzrf
18:11:40 <shlomocomputer> Knowing that Hugs exist(ed) is heartening.  Parsing is one of those things that seems easier to express abstractly/recursively/functionally, but knowing how performance-sensitive the task can be, I'm scared of ghc and how opaque performance can be.
18:12:04 <ReinH> shlomocomputer: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
18:12:08 <shlomocomputer> I wrote a simple parser in C for something I was doing, and basically tried to make it as efficient as possible.
18:12:29 <ReinH> shlomocomputer: What do you mean by "how opaque performance can be" with ghc?
18:12:57 <shlomocomputer> GHC scares me because it's not particularly well defined how things fuse algorithmically and how laziness works.
18:13:07 <shlomocomputer> I have zero intuition about it (being a noob)
18:13:59 <benzrf> shlomocomputer: do you understand how to do IO in haskell?
18:14:27 <shlomocomputer> I mean, try me, I'm no expert, but "yeah"
18:14:49 <structuralist> when/how should I use unboxed tuples?
18:15:17 <benzrf> shlomocomputer: ok, parsec has parsers that act kinda like IO actions
18:15:26 <benzrf> at least, in terms of how functor/applicative/monad work on them
18:15:45 <shlomocomputer> benzrf:  so you say attoparsec is a good starter parsing lib?
18:15:57 <benzrf> i'd go with vanilla parsec to start
18:16:00 <kadoban> shlomocomputer: Parsec is probably better to start with.
18:16:04 <benzrf> it's orders of magnitude slower but it's friendlier
18:16:17 <shlomocomputer> I listened to a podcast re: Pipes and [something else, forgot] and it sounded complicated
18:16:23 <benzrf> pish
18:16:39 <ReinH> shlomocomputer: Pipes and Conduit, which are only tangentially related to parsing
18:16:44 <ReinH> (That's my podcast btw)
18:17:20 <shlomocomputer> ReinH:  I was wondering about that.   the author of one of them said he basically made the project for his own use, which was just parsing.
18:17:41 <shlomocomputer> Oh awesome!  I've heard all 8, kudos
18:17:44 <ReinH> shlomocomputer: Parsec provides better error messages, attoparsec is generally faster. Parsec is probably better for parsing human input, where you get errors more frequently. attoparsec is probably better for parsing computer input (like a new protocol or something) where you care more about speed.
18:18:40 <ReinH> Thanks :)
18:19:37 <kadoban> shlomocomputer: Parsec and attoparsec have very similar interfaces as well, if that wasn't clear. So if you learn one you can easily adapt to the other.
18:20:21 <shlomocomputer> kadoban:  Thanks, I was just going to say, I'll look at parsec first and guessed what you just said
18:22:17 <shlomocomputer> Haskell is definitely the language I love to hate, and as a consequence, the one I spend by far the most time in
18:22:34 <shlomocomputer> I want to learn more about it and be better at it so I can hate it even more
18:23:12 <indiagreen> an admirable goal indeed
18:23:22 <shlomocomputer> Haskellers being nice is definitely a big impediment to my hatred, so that sucks
18:24:28 <athan> Has anyone else had issues installing ghc 7.8.3 on ubuntu because of libgmp?
18:26:15 <jayunit100_m> whats the diff between (take (length x)) == "xyz" -- and "xyz"=="xyz" ?
18:26:40 <jayunit100_m> i see that in the snippet for "instance Read Color" in the RWH exersize : http://book.realworldhaskell.org/read/using-typeclasses.html
18:26:41 <ReinH> jayunit100_m: Um, a lot of things?
18:27:01 <ReinH> :t (take (length x)) == "xyz"
18:27:02 <lambdabot>     Couldn't match expected type ‚Äò[a1]‚Äô with actual type ‚ÄòExpr‚Äô
18:27:02 <lambdabot>     In the first argument of ‚Äòlength‚Äô, namely ‚Äòx‚Äô
18:27:02 <lambdabot>     In the first argument of ‚Äòtake‚Äô, namely ‚Äò(length x)‚Äô
18:27:17 <benzrf> bwomp bwoomp
18:27:24 <ReinH> jayunit100_m: Why do you expect them to be similar?
18:27:28 <jayunit100_m> sorry, i meant (take 3 "xyz") == "xyz" and "xyz=xyz"
18:27:43 <athan> What's a good distro to run ghc in? Debian?
18:27:52 <jayunit100_m> centos wokrs great for me
18:27:55 <jayunit100_m> and os x to
18:27:57 <ReinH> jayunit100_m: they are equivalent, which you can prove using the definition of take
18:28:13 <jayunit100_m> funny that they have that in the http://book.realworldhaskell.org/read/using-typeclasses.html exersize, dont you think ReinH ?
18:28:23 <athan> jayunit100_m: Thanks :)
18:29:05 <jayunit100_m> athan: i suggest using tmux, ghci in one panel, NERDTree vim in other, w vim haskell plugin installed, before you write your first line of code.  like this
18:29:07 <ReinH> jayunit100_m: well, it's only true when the number is the same as the length
18:29:11 <ReinH> your example is true
18:29:31 <ReinH> It isn't true for any integer and any lists
18:29:49 <ReinH> take (length xs) xs == xs -- is always true
18:30:02 <ReinH> take (length ys) xs == ys -- is not always true
18:30:22 <jayunit100_m> http://tinypic.com/r/qp49ds/8
18:30:29 <jayunit100_m> athan:  ^^ thats how i do it
18:30:55 <ReinH> athan: Debian is fine
18:31:14 <athan> ReinH: It doesn't do any weird naming with libgmp? :S
18:31:19 <ReinH> You'll need to install some packages either first on debian or ubuntu
18:31:19 <jayunit100_m> ah yes good point.  it is just a minor optimization
18:31:31 <jayunit100_m> ReinH: i guess they are only doing it so that its optimized ?
18:31:33 <athan> I'm on the latest lubuntu right now, ReinH
18:31:58 <ReinH> athan:  apt-get install libgmp-dev should be sufficient on ubuntu
18:32:22 <ReinH> Well, it's a bit strange, isn't it
18:32:26 <athan> Hmm. It's still giving me the same error, and every google search leads me to libgmp :S
18:33:15 <athan> jayunit100_m: Thanks :) I'll check it out. I've been meaning to get good at tmux
18:33:25 <ReinH> jayunit100_m: Well, that function checks if ys is a prefix of xs, right?
18:33:39 <ReinH> @src isPrefixOf
18:33:39 <lambdabot> isPrefixOf [] _          = True
18:33:39 <lambdabot> isPrefixOf _  []         = False
18:33:39 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
18:34:06 <jayunit100_m> its sposed to just match "Red" to Red
18:34:12 <jayunit100_m> i dont see why its so comple
18:34:23 <ReinH> jayunit100_m: It's also supposed to match "Redfoo" to "Red"
18:34:25 <ReinH> It's a prefix match
18:34:45 <athan> ReinH: This is the error I'm getting: http://lpaste.net/113437
18:34:49 <ReinH> > take (length "Red") "Redfoo" == "Red
18:34:51 <lambdabot>  <hint>:1:37:
18:34:51 <lambdabot>      lexical error in string/character literal at end of input
18:34:55 <benzrf> hheh. redfoo
18:34:56 <ReinH> > take (length "Red") "Redfoo" == "Red"
18:34:57 <lambdabot>  True
18:35:01 <ReinH> benzrf: someone got it!
18:35:24 <benzrf> he is not parituclarly obscure
18:35:35 <ReinH> True
18:35:36 <jayunit100_m> (read "[Red,Red,Blue]")::[Color]
18:35:45 <benzrf> somebody should release nerdy parodies of his stuff as 'redbar' :v
18:35:49 <jayunit100_m> ohhhh i see its actually supporting alot of complex usecases
18:35:53 <thoughtpolice> ReinH: i saw the haskell cast mentioned earlier... when are you going to do another cast, btw? :)
18:35:56 <jayunit100_m> not just "Red" -> Red
18:36:18 <ReinH> thoughtpolice: Once Chris and my lives settle down a bit and we can schedule conal
18:36:31 <ReinH> thoughtpolice: Chris recently moved across the world and got really sick :(
18:36:41 <ReinH> Also yay conal
18:36:44 <thoughtpolice> ReinH: oh right, he works for Zalaora now right? Singapore?
18:36:53 <thoughtpolice> *Zalora
18:37:03 <ReinH> jayunit100_m: Well, it supports exactly one use case: is the right hand side a prefix of the left hand side ;)
18:37:11 <ReinH> They could have just used isPrefixOf
18:37:38 <benzrf> what kind of cast is this ReinH
18:37:41 <ReinH> thoughtpolice: I think he just moved back to the western hemisphere actually, but I'm not sure of why
18:37:50 <ReinH> benzrf: my podcast
18:38:04 <benzrf> collaboration with conal & bitemyapp or sth?
18:38:13 <ReinH> thoughtpolice:  I've been too busy with my own $NEWJOB to care about other people
18:38:25 <ReinH> benzrf: Chris Forno, not bitemyapp. We have guests on and talk about Haskell and stuff.
18:38:29 <benzrf> ah
18:38:34 <benzrf> der
18:38:34 <ReinH> haskellcast.com
18:38:49 <torpet> http://lpaste.net/7672125348137402368
18:39:01 <benzrf> somehow i managed to assume there is only one haskeller named chris :y
18:39:07 <thoughtpolice> ReinH: oh, i see. does $NEWJOB involve Haskell? and shouldn't it be 'newJob :: Work'? :)
18:39:08 <torpet> why am i getting this error? isn't x supposed to be a string?
18:39:11 <benzrf> even though there is literally a chrisdone in the channel
18:39:20 <benzrf> thoughtpolice: more like :: Job
18:39:27 <ReinH> thoughtpolice: :p Yes, I work at pivotcloud n√© alephcloud
18:39:39 <benzrf> alephcloud?
18:39:47 <benzrf> is that one of those weird infinities?
18:39:59 <thoughtpolice> benzrf: depends on how you look at it I guess, Job is certainly a subtype of Work
18:40:02 <structuralist> ReinH: what do they do?
18:40:20 <ReinH> structuralist: "cloud" crypto stuff
18:40:28 <thoughtpolice> ReinH: oh, neato
18:40:50 <ReinH> thoughtpolice: vincent does most of our crypto for us :)
18:40:52 <thoughtpolice> I should release nacl. :( I actually did some work on it in my private branch the other day...
18:41:01 <ReinH> nice
18:41:41 <benzrf> torpet that's pretty odd
18:41:43 <benzrf> that code looks fine to me
18:41:45 <thoughtpolice> i've also got another sekret project to release, which luckily isn't so dependent on that.
18:41:54 <benzrf> torpet: fyi you can just write that as:
18:42:00 <ReinH> Athas: there are packages for GHC though... one sec
18:42:10 <benzrf> decode s dist = map (map (\c -> toEnum ( fromEnum c + dist ) :: Char )) s
18:42:12 <yukko> emmanueloga I dunno if this helps you but I wrote some code that describes the list you mentioned
18:42:15 <yukko> > take 10 $ (flip map) [1..] (\x -> head [ y | y <- [1..], and ((flip map) [1..x] (\y' -> y `mod` y' == 0))])
18:42:16 <lambdabot>  [1,2,6,12,60,60,420,840,2520,2520]
18:43:01 <ReinH> Athas: try the packages managed at http://deb.haskell.org/
18:43:12 <vanila> don't write your own crypto! ;-)
18:43:21 <emmanueloga> thanks yukko! checking your solution out too now.
18:43:24 <ReinH> vanila: (unless you know how to write your own crypto)
18:43:26 * hackagebot linear 1.11.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.11.1 (EdwardKmett)
18:43:30 <thoughtpolice> ReinH: I'm not sure if deb.h.o actually offers STABLE packages...
18:43:36 <thoughtpolice> Maybe Joachim added them recently
18:43:50 <ReinH> thoughtpolice: like at http://deb.haskell.org/stable/ ?
18:43:51 <ReinH> ;)
18:44:07 <thoughtpolice> oh, I see
18:44:13 <ReinH> vanila: this is the Vincent in question http://hackage.haskell.org/user/VincentHanquez
18:44:23 <thoughtpolice> I mostly let Joachim manage that machine; it's not like I ever use a package manager for GHC anyway :)
18:44:26 <ReinH> thoughtpolice: :)
18:45:05 <ReinH> Only back to 7.0 though. Sadness.
18:45:16 <thoughtpolice> Herbert's PPA has GHC 6.12 :)
18:45:26 <thoughtpolice> which you can actually use just fine on Debian too
18:46:24 <ReinH> Oh, athan is gone, sorry Athas
18:47:49 <ReinH> torpet: looks like you want (:) instead of (++)
18:48:03 <torpet> ReinH: whats the difference?
18:48:38 <ReinH> x is a String, so map (...) x will be a String. decode xs dist will be a [String]
18:49:13 <benzrf> aaahhh
18:49:15 <benzrf> theres the problem
18:49:16 <ReinH> :t (++) :: [String] -> [String]
18:49:17 <lambdabot>     Couldn't match type ‚Äò[String] -> [String]‚Äô with ‚Äò[String]‚Äô
18:49:17 <lambdabot>     Expected type: [String] -> [String]
18:49:17 <lambdabot>       Actual type: [String] -> [String] -> [String]
18:49:23 <ReinH> :t (++) :: [String] -> [String] -> [String]
18:49:24 <lambdabot> [String] -> [String] -> [String]
18:49:31 <ReinH> :t (:) :: String -> [String] -> [String]
18:49:32 <lambdabot> String -> [String] -> [String]
18:49:45 <benzrf> tfw no explicit type application
18:50:36 <ReinH> torpet: btw, decode is itself a map
18:51:17 <ReinH> decode = map (map (\c ...))
18:51:34 <torpet> you guys are right, with : it's working
18:51:35 <torpet> :)
18:51:40 <Fuuzetsu> bitemyapp: wasn't planning on a review or anything like that, it just jarred me ;)
18:51:41 <ReinH> Oh no, you need to put the dist first
18:52:06 <ReinH> but generally, if you are writing something like go f (x:xs) = f x : go f xs, you are writing a map
18:52:09 <ReinH> @src map
18:52:09 <lambdabot> map _ []     = []
18:52:10 <lambdabot> map f (x:xs) = f x : map f xs
18:53:27 <ReinH> benzrf: well, it would be nicer if the inferrer picked String for [Char]
18:53:35 <ReinH> :t (:) `asAppliedTo` "foo"
18:53:35 <lambdabot> [Char] -> [[Char]] -> [[Char]]
18:53:36 <ReinH> :(
18:53:40 <torpet> ahhh ok thanks
18:54:02 <torpet> i think i got it
18:54:17 <ReinH> decode dist = map (map (\c -> toEnum ( fromEnum c + dist ) :: Char ))
18:54:19 <ReinH> should work
18:54:20 <emmanueloga> yukko: what's the $ for in take n $ ["some", "list"] ?
18:54:33 <ReinH> emmanueloga: nothing :)
18:55:11 <emmanueloga> heh I tried it without $ and it worked... but I did not want to jump to conclusions :)
18:55:32 <ReinH> @src ($)
18:55:32 <lambdabot> f $ x = f x
18:56:29 <benzrf> :t uncurry id
18:56:30 <lambdabot> (b -> c, b) -> c
18:56:34 <benzrf> mm
18:56:39 <benzrf> :t fmap (uncurry id)
18:56:40 <lambdabot> Functor f => f (b1 -> b, b1) -> f b
18:56:45 <benzrf> mmmmmmmm
18:56:53 <ReinH> :t ((uncurry id) .)
18:56:54 <lambdabot> (a -> (b -> c, b)) -> a -> c
18:57:06 <ReinH> I don't know how to play this game
18:57:07 <benzrf> :t \f g -> fmap (uncurry id) $ liftA2 (,) f g
18:57:08 <lambdabot> Applicative f => f (b1 -> b) -> f b1 -> f b
18:57:13 <emmanueloga> so where is $ generally used?
18:57:21 <benzrf> emmanueloga: when you  wanna save on parens
18:57:29 <emmanueloga> ah, ok
18:57:33 <ReinH> emmanueloga: think of f $ x as (f) (x)sd
18:57:37 <ReinH> s/sd//
18:57:55 <ReinH> so, for instance, (f . g . h) xs = f . g. h $ xs
18:58:30 <ReinH> or withThing $ \x -> do {...} = withThing (\x -> do {...})
18:58:53 <emmanueloga> cool. Btw, that @src thing lookshandy, how can I make that work on ghci?
18:58:58 <ReinH> emmanueloga: you can't :)
18:59:01 <ReinH> it's a lambdabot-ism
18:59:03 <emmanueloga> great :)
18:59:15 <ReinH> But there are ctags generators for haskell
18:59:20 <ReinH> @hackage hasktags
18:59:20 <lambdabot> http://hackage.haskell.org/package/hasktags
18:59:39 <ReinH> and especially...
18:59:52 <ReinH> Ah. https://github.com/aloiscochard/codex#codex
19:00:11 <ReinH> Those will let you add "jump to definition" to a lot of editors
19:00:42 <ReinH> emmanueloga: @src actually uses a hand-curated list of things that aren't always exactly the same as implemented in base
19:01:12 <ReinH> They are denotationally equivalent, but may not optimize the same, etc
19:01:28 <merijn> chrisdone: Ping?
19:01:43 <ReinH> @src foldr
19:01:43 <lambdabot> foldr f z []     = z
19:01:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:01:46 <ReinH> Compare with http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#foldr
19:02:14 <emmanueloga> cool, txs for the info. ftr after years of using irc is the first time it occurred to me it is ok to have conversation with bots. I'm having one with lambdabot now :)
19:02:46 <ReinH> :)
19:02:52 <ReinH> lambdabot is very patient
19:03:23 <torpet> Is it possible to create a mapping between two strings?
19:03:32 <torpet> a -> r, b -> m and so on
19:03:36 <torpet> considering both strings are given
19:03:45 <torpet> and both are of the same length
19:04:26 <ReinH> torpet: I'm not quite sure what you're asking
19:04:40 <torpet> i want to create a ROT-n mapping between two strings
19:04:52 <torpet> the encryted one and the decoded one
19:05:03 <ReinH> What do you mean by "a mapping between two strings"?
19:05:16 <ReinH> How would you use this mapping?
19:05:25 <rmorgan> I'm having some odd IO progblems: http://lpaste.net/113438. When attempting to output to stdout, ghc says that an IO a is expected, but that I'm trying to putStrLn a double
19:05:26 <torpet> To decode other Rot-N encoded strings
19:08:47 <ReinH> rmorgan: what actual error are you getting?
19:08:55 <ReinH> torpet: I'm not following, sorry
19:09:22 <rmorgan> ReinH: snatchLoadAvg.hs:4:19:
19:09:23 <rmorgan>     Couldn't match expected type ‚ÄòIO a0‚Äô with actual type ‚ÄòDouble‚Äô
19:09:24 <torpet> sorry for my terrible explanation. i have the "the quick brown fox..." sentence given as well as the decoding
19:09:26 <rmorgan>     In a stmt of a 'do' block: avg1 <- sample_1 ldavg
19:09:27 <rmorgan>     In the expression:
19:09:29 <rmorgan>       do { ldavg <- getLoadAvg;
19:09:31 <rmorgan>            avg1 <- sample_1 ldavg;
19:09:33 <rmorgan>            print $ show avg1 }
19:09:35 <ReinH> rmorgan: Use a pastie next time please.
19:09:44 <torpet> so what i want to do is to create a simple mapping a la [(char), (char)] between those two
19:09:49 <torpet> so i can decode other strings
19:10:07 <rmorgan> ReinH: sorry about that -- noted
19:10:20 <ReinH> rmorgan: what are the types of getLoadAvg and sample_1?
19:10:57 <seafood> Hey everyone, where would be the right place to go to ask a question about Cabal and cross compilation?
19:11:03 <ReinH> torpet: Ah, I see.
19:11:13 <ReinH> > zip "abcde" "cbdae"
19:11:14 <lambdabot>  [('a','c'),('b','b'),('c','d'),('d','a'),('e','e')]
19:11:18 <ReinH> torpet: like that?
19:11:26 <ReinH> seafood: sure
19:11:37 <torpet> jesus
19:11:42 <torpet> how easy is that
19:11:43 <torpet> :D
19:11:45 <torpet> thanks
19:11:47 <ReinH> torpet: pretty easy :)
19:12:09 <rmorgan> ReinH: in ghci getLoadAvg has a type: IO LoadAvg
19:12:12 <ReinH> torpet: look at lookup for using this "association list", as it's called
19:12:37 <torpet> ReinH: that would have been my next question. :)
19:12:39 <torpet> i love haskell so far
19:13:17 <seafood> ReinH: Here‚Äôs acceptable? Okay, well I‚Äôll go ahead. It seems to me that cross compilation, in general, is not supported. I‚Äôve got a GHC 7.8.2 ARM cross compiler built and it works fine on some packages. But, it doesn‚Äôt work (and I think quite obviously so) when you have to compile your own ‚Äúsetup‚Äù as part of ‚Äúcabal configure‚Äù. When this happens it‚Äôs compiled to the target architecture and thus can‚Äôt run on your host architecture.
19:13:41 <seafood> ReinH: I just want to confirm with someone in the know that this is a known issue and whether there are any workarounds.
19:13:46 <rmorgan> ReinH: I have been unable to access it directly in ghci, but sample_1 seems to be a "!Double" based on the documentation: http://hackage.haskell.org/package/loadavg-0.1/docs/System-Posix-LoadAvg.html
19:14:18 <ReinH> rmorgan: The ! sigil is a strictness annotation, it doesn't change the type of Double
19:14:36 <ReinH> rmorgan: what is `:t sample_1' in ghci?
19:15:01 <rmorgan> ReinH: sample_1 :: LoadAvg -> Double
19:16:25 <dfeuer> Is there any difference at all between mapM_ and traverse_, except that mapM_ has a more restricted type?
19:17:05 <ReinH> rmorgan: so far so good then
19:17:11 <ReinH> dfeuer: Nope.
19:17:25 <ReinH> dfeuer: Traversable is the generalization of mapM :)
19:17:46 <ReinH> > let decoder alist = catMaybes . map (flip lookup ring); ring = zip "nopqrst" "abcdefg" in decoder ring "qrnqorrs" -- torpet
19:17:48 <lambdabot>  "deadbeef"
19:18:14 <ReinH> Heh, should be: let decoder alist = catMaybes . map (flip lookup alist); ring = zip "nopqrst" "abcdefg" in decoder ring "qrnqorrs" actually
19:18:14 <dfeuer> ReinH, so the only reason for Data.Foldable *not* to define mapM_ = traverse_ is in case of broken instances where they're not the same?
19:18:38 <rmorgan> ReinH: yeah, it's a little strange -- I'd think that putStrLn $ show avg1, should print to standard out
19:18:45 <ReinH> dfeuer: Same reason Monad doesn't define fmap, probably
19:18:53 <ReinH> dfeuer: the inference is in the wrong direction
19:18:58 <dfeuer> Hmm?
19:19:05 <ReinH> An fmap defined in Monad would class with one defined in Functor
19:19:14 <ReinH> (there is no inference, actually)
19:19:19 <dfeuer> ReinH, these are functions, not class methods.
19:19:28 <ReinH> dfeuer: same problem though
19:19:32 <dfeuer> ?
19:19:44 <ReinH> Well, maybe not
19:19:47 <ReinH> Dunno then
19:19:53 <dfeuer> I don't think you can use them to define the class members.
19:20:26 <dfeuer> I guess just in case of broken instances, maybe. Horrible reason, that.
19:20:40 <ReinH> rmorgan: Oh no
19:21:12 <ReinH> rmorgan: Sorry, don't know why I missed this. sample_1 gives a Double, not an IO Double
19:21:22 <ReinH> so oyu want let avg1 = sample_1 ldavg
19:21:24 <ReinH> *you
19:21:42 <ReinH> avg1 <- sample_1 ldavg would work if sample_1 :: LoadAvg -> IO Double
19:22:12 <rmorgan> ReinH: Oh yay!! It worked :)
19:22:43 <rmorgan> i guess i missed that sample_1 isn't something that needs to be bound to a name with <-
19:22:56 <ReinH> rmorgan: also you can use print x instead of putStrLn (show x)
19:23:14 <rmorgan> yeah, i may do that
19:23:15 <ReinH> rmorgan: <- "binds to a name" in a specific way
19:23:33 <ReinH> @undo { x <- k; return x }
19:23:33 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
19:23:37 <ReinH> @undo do { x <- k; return x }
19:23:37 <lambdabot> k >>= \ x -> return x
19:23:51 <ReinH> rmorgan: It is syntasic sugar for >>= and a lambda binding
19:23:56 <rmorgan> yeah, i guess it probably needs to be impure to need to be bound to a name
19:24:01 <ReinH> let x = y also binds to a name
19:24:21 <rmorgan> ahh i see
19:24:29 <rmorgan> yeah, the >>= is starting to make more sense to me
19:24:39 <rmorgan> this all in service of a little xlib programming i'm doing in haskell
19:24:59 <ReinH> rmorgan: As you're learning monad syntax, it's best to make sure that you're confortable with how your do notation desugars to >>= and >>
19:25:10 <ReinH> And that you understand what the >>= and >> do for the monad in question
19:25:15 <rmorgan> tried to do it in C, but i spent a very long time upsettedly playing with Xlib, then tried it in haskell and it took like 45 min
19:26:04 <rmorgan> yeah, it's taken a while to get my head around lambda notation, but I found this: https://en.wikibooks.org/wiki/Haskell/do_Notation, and found it to be very helpful
19:27:12 <ReinH> rmorgan: ok!
19:28:39 <rmorgan> ReinH: yeah! it's exciting when this stuff starts to click
19:29:06 <ReinH> Awesome :)
19:29:42 <bitemyapp> rmorgan: I don't know if anybody linked it already, but: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
19:29:49 <mgaut72> Hi all,  I am working with parsec, Lens and MonadState right now, and I would appreciate a sanity check. If I have a normal State monad with a Lens on some field (call it _foo :: Int) in the record that is my state, i can do something like `foo += 1` thanks to lenses.
19:29:49 <mgaut72> I observe that (+=) requires a MonadState instance.  Now, I want to be able to use (+=) on user state in Parsec, but Parsec's declared instance of MonadState is with respect to the stream.  Would I be able to override that instance of MonadState with one that is in respect to the user state?
19:30:03 <benzrf> mgaut72: mabey
19:30:18 <benzrf> mgaut72: but youd need a newtype wrapper and a lot of boilerplate nonsense
19:30:32 <mgaut72> benzrf: jeez that was fas
19:30:34 <mgaut72> t
19:30:38 <ReinH> Well
19:30:53 <benzrf> mgaut72: it might be more expedient to just define your own operator
19:31:07 <rmorgan> bitemyapp: Thanks for that link! it seems to lay out the sugaring pretty well
19:31:27 <mgaut72> benzrf: my own (+=) operator you mean?
19:31:43 <benzrf> sth like that
19:32:00 <edwardk> mgaut72: unfortunately parsec's state isn't "MonadState" so you are kinda in a rough spot
19:32:01 <bitemyapp> rmorgan: it's pretty good. Whiffs on a couple minor details, otherwise excellent and more comprehensive than most.
19:32:19 <bitemyapp> rmorgan: most other articles of that sort only covered do notation, which is disappointing and not at all the only example of "sugar" in Haskell
19:32:21 <edwardk> mgaut72: you could use trifecta instead of parsec, which supports StateT, etc.
19:32:29 <mgaut72> edwardk: I'
19:32:39 <mgaut72>  I'm already pretty invested in parsec
19:32:44 <bitemyapp> rmorgan: I would note, however, that typeclasses in Haskell get optimized above and beyond simple record passing though. Otherwise a lot of things would be relatively slow.
19:33:18 <edwardk> mgaut72: fair nuff, i wrote trifecta explicitly because parsec and monad transformers don't work together, so i don't know what to tell you =P
19:33:50 <torpet> can i somehow print ugly output of [Maybe Char] as a String?
19:33:50 <bitemyapp> edwardk: I didn't know that was the original motivation. Neat.
19:34:06 <bitemyapp> edwardk: how do trifecta and parsec compare WRT perf lately?
19:34:11 <rmorgan> bitemyapp: very interesting! since recently venturing into C, i have way more appreciation for haskell's sugar and syntax
19:34:20 <mgaut72> edwardk: damn.  Parsec wooed me with its fancy things like `buildExpressionParser` and other niceities
19:34:37 <bitemyapp> rmorgan: using a lower level language has a way of doing that, yeah. If you want even more tedium, take a look at FORTRAN :)
19:35:12 <torpet> http://lpaste.net/6421692147287719936
19:35:21 <indiagreen> > map (fromMaybe '_') [Just 'a', Nothing, Just 'o', Just 'e', Nothing]
19:35:22 <lambdabot>  "a_oe_"
19:35:25 <codygman> Can anyone show me an example of using wreq sessions with a state monad transformer? I've been trying unsuccesfully for a while: http://lpaste.net/113440
19:35:33 <rmorgan> bitemyapp: the only way I really use Fortran is via R :-p
19:36:05 <crobbins> can you import packages in `cabal repl` without adding them to your dependencies?
19:36:05 <bitemyapp> rmorgan: you and a bunch of other people.
19:36:11 <indiagreen> torpet: you can apply catMaybes to just get all the characters
19:36:42 <indiagreen> or you can apply sequence to get either ‚ÄúJust string‚Äù if all are Justs, or a Nothing if there's a Nothing somewhere
19:37:15 <xpika> This sounds basic. But what's the easiest way to do a doWhile (IO Bool) IO  ?
19:37:23 <codygman> crobbins: You can add "import Package.Name" directly to your ~/.ghci file.
19:37:23 <indiagreen> or you can do ‚Äúmap (fromMaybe '_')‚Äù to get Nothings replaced with underscores
19:37:46 <crobbins> codygman: won't i get a "hidden module" error though?
19:38:03 <codygman> crobbins: Oh... cabal... not ghci.
19:38:09 <codygman> crobbins: I'm not sure in that case.
19:38:15 <crobbins> drat, thanks codygman
19:39:19 <ReinH> xpika: perhaps doWhile k l = whenM k (l >> doWhile k l) using whenM from Control.Conditional
19:39:26 <ReinH> monad-loops might have something
19:40:14 <xpika> @hoogle (IO Bool) -> IO () -> IO ()
19:40:16 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
19:40:17 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
19:40:17 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
19:41:48 <edwardk> mgaut72: trifecta has the same buildExpressionParser stuff ;)
19:41:55 <edwardk> mgaut72: the API is basically parsec cleaned up
19:43:08 <torpet> How does that function work? http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Maybe.html#catMaybes
19:43:35 <dmj`> > catMaybes [Just 1, Nothing]
19:43:37 <lambdabot>  [1]
19:43:55 <c_wraith> torpet: if a pattern binding inside a list comprehension fails, it skips that element of the list it's iterating over
19:44:24 <dmj`> :t \xs -> [ x | Just x <- xs ]
19:44:25 <lambdabot> [Maybe t] -> [t]
19:44:28 <crobbins> codygman: figured it out: cabal configure --ghc-option="-package <name>"
19:44:56 <xpika> ReinH: yep. monadloops. thanks/
19:45:42 <bitemyapp> torpet: it's conflating possibilities.
19:46:01 <mgaut72> edwardk: Then I must be big good.  How come I see all the niceities here: http://hackage.haskell.org/package/trifecta-0.37 but not here: https://hackage.haskell.org/package/trifecta
19:46:10 <mgaut72> big goof*
19:49:05 <torpet> c_wraith: so that "Just x <- ls" means only those characters get returned that were created with contructor "Just"?
19:50:29 <c_wraith> torpet: it pattern-matches every element of ls against that pattern - if the pattern fails to match (ie, not the Just constructor) the element is skipped.  That's just how pattern matches in binds in list comprehensions are defined to work
19:50:36 <bitemyapp> torpet: the guard in the list comprehension is "failing" out
19:50:52 <bitemyapp> torpet: the fail for [a] returns []. That gets concatenated with the other results.
19:50:57 <bitemyapp> > [1, 2, 3] ++ []
19:50:59 <lambdabot>  [1,2,3]
19:51:17 <torpet> bitemyapp: thanks
19:51:19 <torpet> c_wraith: thanks
19:51:33 <shlomocomputer> edwardk:  Would you recommend your parsing library over parsec for a first parsing library to learn?
19:51:37 <bitemyapp> > fail "blah" :: [a]
19:51:39 <lambdabot>  []
19:51:41 <bitemyapp> torpet: ^^
19:51:54 <bitemyapp> torpet: properly, fail isn't part of Monad, but rather MonadPlus. This should get fixed later.
19:52:08 <bitemyapp> torpet: the "fail" is used when the pattern match...uh...fails. Doesn't match.
19:52:36 <bitemyapp> it's just a way to avoid specifying the unhappy case. *shrug*
19:52:39 <bitemyapp> case(s)
19:52:46 <torpet> and te guard is exactly "Just x"
19:52:48 <torpet> ?
19:52:52 <torpet> nothing more, nothing less
19:53:04 <ReinH> bitemyapp: there is no fail in list comprehensions
19:53:12 <ReinH> There is only pattern matching
19:53:23 <ReinH> fail is used in monad comprehensions
19:54:29 <ReinH> See http://www.haskell.org/onlinereport/exps.html#list-comprehensions
19:54:40 <torpet> ReinH: thanks for all your help today
19:54:50 <torpet> I could manage to finish most of the stuff I wanted to learn
19:54:51 <ReinH> torpet: you're welcome
19:56:43 <begriffs> I'm trying to profile a ghc app on mac but get this weird error about "Perhaps you haven't installed the profiling libraries" for the text package. What should I do?
19:57:09 <indiagreen> mgaut72: apparently some of the goodies now live in the ‚Äúparsers‚Äù module, at least judging by this giant commit claiming that it was just some refactoring: https://github.com/ekmett/trifecta/commit/8b16cd4df09ede356a4a60dacf6bd9dee201097c
19:57:28 <indiagreen> s/module/package/
19:57:44 <bitemyapp> ReinH: based on the Core, it takes advantage of knowing it's a list vs. monad comprehension, and just skips the element if it doesn't match.
19:57:49 <bitemyapp> ReinH: sound right?
19:58:21 <bitemyapp> lpaste needs a GHC Core highlighter
19:58:21 <ReinH> bitemyapp: Pretty much. List comprehensions desugar to pattern matching directly, fail is only used if monad comprehensions are enabled
19:58:49 <bitemyapp> ReinH: http://lpaste.net/1139617963666571264
19:58:54 <mgaut72> indiagreen: While that might have been the "right way" for many reasons, I feel lied to when I look through the trifecta documentation on hackage
19:59:27 <ReinH> [ e | p <- l ] ==> let ok p = [ e ]; ok _ = [] in concatMap ok l
19:59:35 <ReinH> Ignoring guards, that's the translation
19:59:50 <ReinH> edwardk: stop lying to mgaut72
19:59:53 <ReinH> :p
20:00:05 <ReinH> bitemyapp: that would be nice
20:00:25 <bitemyapp> I'm not sure such a thing even exists.
20:00:45 <ReinH> Dunno
20:04:04 <mgaut72> ReinH: I know right, is that so much to ask =P
20:08:04 <edwardk> mgaut72: trfiecta's docs are almost all in parsers
20:08:19 <edwardk> mgaut72: there is a parsers package that trifecta depends on that supplies all the parsecisms
20:08:34 <edwardk> mgaut72: if you look at trifecta and not parsers nothing will look familiar =P
20:09:30 <mgaut72> I wish I would have known that 2 months ago.  When I was evaluating which parser library to use, I saw the docs in trifecta proper, and when running scared.
20:09:42 <mgaut72> ah well.  there will be other parsers =P
20:10:29 <shlomocomputer> edwardk:  I was just advised here to learn parsec as a first parsing lib in haskell.  Would you recommend trifecta as an alternative first library?
20:11:19 <edwardk> shlomocomputer: not sure. parsec has tons of documentation out there. trifecta is a bit more of a moving target, but gives prettier error messages and works with monad transformers
20:11:31 <edwardk> shlomocomputer: and its being actively used and maintained ;)
20:12:01 <shlomocomputer> forgive ignorance, but are monad transformers things like (>>=) etc.?
20:13:01 <shlomocomputer> nope n/m, don't wanna be a help vampire
20:13:39 <indiagreen> no-ope, you already asked
20:13:46 <indiagreen> now you can't avoid getting help
20:13:50 <benzrf> shlomocomputer: thats just regular monads
20:14:00 <benzrf> shlomocomputer: a monad is a functor plus (>>=) (really join)
20:14:03 <benzrf> and return
20:14:11 <mgaut72> edwardk: I saw this post that suggests the way to do user state in trifecta is to wrap it in a StateT: http://stackoverflow.com/questions/18806586/custom-state-in-trifecta
20:14:12 <mgaut72> why isnt that also feasible in parsec? or is there a better way in trifecta?
20:14:53 <shlomocomputer> benzrf:  thanks, that's advanced for me atm
20:15:29 <benzrf> do you not know functors yet?
20:15:49 <edwardk> mgaut72: trifecta's combinators don't work with the surrounding StateT
20:15:51 <edwardk> parsers's combinators do
20:15:51 <shlomocomputer> No.
20:15:59 <benzrf> shlomocomputer: you dont or you dont not -_-
20:16:38 <shlomocomputer> I don't no.  I mean know.  :)
20:16:57 <benzrf> >>>#haskell-beginners for extensive didactix :3
20:17:34 <mgaut72> edwardk: I think I am seeing that now.  I should have done more comprehensive googling first.  All the combinators work with MonadParser, and StateT s m where m is a MonadParser is also a MonadParser
20:17:37 <shlomocomputer> benzrf:  Thanks, hope to see you back here in a while
20:17:42 <Welkin> #haskell-beginners?
20:17:53 <edwardk> mgaut72: also note that parsec is also an instance
20:18:23 <edwardk> mgaut72: so you _could_ use parsers on top of parsec and use a StateT'd Parser
20:18:29 <edwardk> and never touch trifecta
20:19:12 <benzrf> Welkin: optimal channel for people who do not yet grok the fundamental concepts necessary to fully understand a nontrivial app
20:22:06 <Welkin> I never knew about that when I was new
20:22:46 <vanila> cabal ;/
20:27:08 <vanila> QuickCheck-2.7.6 failed during the final install step. The exception was:
20:27:10 <vanila> /tmp/pkgConf-QuickCheck-2.77314.6: hGetContents: invalid argument (invalid
20:27:15 <vanila> why dos this still happen?
20:29:12 <mgaut72> edwardk et al. -  thanks for the discussion on parsers.  I am convinced that I want trifecta for my next parsing problem, expecially if user state is involved.  I'm outta here for now
20:32:51 <benzrf> oh noooooooo more people sucked into the edwardk vortex
20:33:19 <edwardk> its inescapable really
20:33:49 <edwardk> now it is spreading into #haskell-game =P
20:42:38 <Fuuzetsu> ugh, reminds me that I should probably finish my game‚Ä¶
20:45:44 <dmj`> Fuuzetsu: and your bitorrent client
20:46:53 <Fuuzetsu> dmj`: all you have to do is magically shift all the stuff I have to do about 2 years so I have time to do it
20:47:41 <Fuuzetsu> maybe I should pull an edwardk and hack every waking second until collapse
20:47:53 <edwardk> the collapse part kinda sucks
20:48:30 <piskrist> actually I find extremely pleasurable
20:48:47 <piskrist> s/find/find it/
20:49:01 <piskrist> unfortunately, it doesn't fit very well with standard work hours
20:49:26 <Fuuzetsu> well it sure feels good to get to bed when super tired, but it doesn't feel good to try to think when in such a state
20:49:28 <edwardk> piskrist: more that sort of feeling you get when you've been doing 3 hours of sleep a night for 6 months and your joints start to ache
20:50:07 <edwardk> piskrist: the 'sleep of the triumphant hacker' is another feeling entirely and that i enjoy =)
20:50:40 <piskrist> yeah that sucks but that's not the collapse. That's overcoming the tiredness. The collapse is when you finally given in (or rather be able to, for some of us)
20:52:11 <piskrist> or maybe we are on entirely different time resolutions. 6 months is way too long for me
21:03:27 <trap_exit> for giving a formal presentation, is there a way to make black pants + white jacket to work?
21:13:51 <mayk> I have a question about using maximumBy on a list of tuples. How do I get it to max only on the second list of tuples?
21:14:56 <nkar> you could use pattern matching
21:15:17 <indiagreen> :t maximumBy (comparing snd)
21:15:18 <lambdabot> Ord a => [(a1, a)] -> (a1, a)
21:16:16 <nkar> ah, I misunderstood the "second list" part.
21:16:22 <indiagreen> > maximumBy (comparing snd) [("a", 5), ("b", 3), ("c", 8), ("d", 2)]
21:16:23 <lambdabot>  ("c",8)
21:16:34 <indiagreen> mayk: you want something like this?
21:16:49 <mayk> indiagreen yes, that's exactly what i want
21:17:05 <haasn> ‚Äúsecond list‚Äù‚Äã is misleading - there's only one list here
21:17:10 <haasn> It just happens to contain tuples
21:17:21 <mayk> I tried seaching Hoogle for compare / compareBy, but comparing was what i was looking for
21:17:34 <haasn> compare `on` snd  also works
21:17:39 <mayk> haasn, apologies, I meant the second element of the tuples
21:17:55 <Welkin> how can I specify that I want a list of lists stored in the database in yesod?
21:18:00 <Welkin> [[Double]] won't work
21:18:22 <Welkin> [Double] works
21:18:44 <Welkin> I believe it is stored as JSON, so it shouldn't matter how arbitrary my nesting is
21:28:19 <Welkin> is anyone around that know about persist/yesod?
21:28:23 <Welkin> knows*
21:30:08 <jack_rabbit> Can someone help me figure out why this is insanely slow? http://lpaste.net/113443
21:31:06 <Fuuzetsu> Don't use GHCi and expect any kind of performance
21:31:18 <Fuuzetsu> start with ghc -O2 and go from there
21:31:27 <jack_rabbit> okay, thanks. I'll give that a shot.
21:31:54 <Fuuzetsu> it won't fix your problem but should be much better than in GHCi
21:39:13 <jack_rabbit> fg
21:39:19 <jack_rabbit> whoops. :)
21:40:06 <jack_rabbit> Okay. More like what I expected with the compiled version. Thanks, Fuuzetsu
21:40:42 <jack_rabbit> I figured the slowness was due to realizing the huge structure, but the second search should be fast then. This wasn't the case with GHCI, but the compiled version behaved as expected.
21:41:09 <Fuuzetsu> the chances are is that you still have problems, look into profiling
21:42:14 <jack_rabbit> realizing a tree structure of 1000000 Ints taking ~ 1 second is reasonable, I think.
21:42:58 <Fuuzetsu> well if it's good enough for you then sure but I'd still profile anyway
21:43:35 <jack_rabbit> Does that sound like a reasonable amount of time?
21:44:15 <jack_rabbit> There is *LOTS* of rotating going on. I'm inserting 1 .. 1000000 into an AVL tree.
21:44:47 <jack_rabbit> Just about the most inefficient way to get a tree of that sequence.
21:46:30 <wei2912> taking 1 second is rather reasonable
21:46:44 <wei2912> there's not much urgent need to speed that up
21:49:14 <jack_rabbit> That's what I figured. Thanks.
21:53:47 * hackagebot vty 5.2.5 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.5 (CoreyOConnor)
21:53:57 <nkar> Welkin: there's #yesod
21:54:29 <jessicah> is this a good place to ask questions about hacking on ghc compiler?
21:54:48 <nkar> there's #ghc
21:55:20 <jessicah> oh! cheers :)
22:14:56 <trap_exit> rawr
22:15:54 <tigrennatenn> anyone here familiar with helm / SDL?
22:16:47 <tigrennatenn> i'm trying to set up a signal that triggers only on mouseclick
22:24:04 <Axman6> tigrennatenn: edwardk might be able to help you, he's been playing with SDL peripherally recently
22:24:55 <jle`> tigrennatenn: try poppin on by #haskell-game :)
22:30:36 <pharpend> tigrennatenn: if you don't know, edwardk is the all-seeing, all-knowing God of Haskell
22:30:43 <tigrennatenn> wow
22:30:49 <tigrennatenn> not sure I'm up to talking to a God of Haskell
22:31:02 <tigrennatenn> particularly since I just discovered that the writer of Helm added the function I want two weeks ago X-)
22:31:04 <pharpend> tigrennatenn: He's American, so he's probably asleep.
22:31:06 <pharpend> haha
22:31:06 <edwardk> tigrennatenn: i know SDL, but not Helm, sorry
22:31:23 <edwardk> you might try #haskell-game though
22:32:06 <pharpend> edwardk: since when do you program games?
22:32:40 <cbarrett> heh
22:32:59 <solatis> if Helm is inspired by Elm, does that mean Helm isn't FRP either?
22:33:14 <pharpend> Welkin: Hey, just saw your question. You would want to write an instance of PersistSomething (can't remember the exact class name)
22:33:59 <cbarrett> solatis: I don't recall all of Conal's objections to Elm specifically, but Helm does appear to have continuous time, at least at a cursory glace, which is one of the big ones you need to be FRP
22:34:34 <solatis> hold on, i had a discussion with him about it a few days ago
22:34:34 <pharpend> Welkin: It's PersistField - http://hackage.haskell.org/package/persistent-2.1/docs/Database-Persist-Class.html#t:PersistField
22:34:39 <edwardk> pharpend: since the early 90s, i stopped pretty much cold turkey for 20 years or so =P
22:34:48 <cbarrett> solatis: oh perfect
22:34:56 <edwardk> i guess 14 years actually
22:35:18 <pharpend> edwardk: i have to say, I'm a bit star struck. I only know you as that hairy guy on YouTube who talks about Lenses.
22:35:29 <MP2E> hahah
22:35:30 <kadoban> Haha
22:35:44 <cbarrett> i guess the fact that I learned a lof about 3D and graphics stuff from your tutorials edwardk dates me, then
22:35:54 <cbarrett> Jeez was it really that long ago?
22:35:54 <edwardk> cbarrett: hahaha
22:36:08 <edwardk> 1999 was when i stopped game programming and wrote those flipcode articles i think
22:36:12 <pharpend> edwardk: you are also a maintainer on base, aren't you?
22:36:25 <cbarrett> edwardk: yeah that sounds about right. i was still in school
22:36:31 <Axman6> edwardk is no star, he's single handedly responsible for global warming because of the impack compiling lens brings to packages
22:36:36 <edwardk> pharpend: technically i just chair a committee for that
22:36:44 <pharpend> ah
22:36:54 <solatis> cbarrett: denotational semantics apparently was the other one
22:36:54 <Axman6> impact even
22:37:23 <edwardk> Axman6: heh lens is secretly a covert ploy to get the entire haskell ecosystem to convert to nixos
22:37:31 <cbarrett> solatis: As in Elm doesn't have them?
22:37:34 <cbarrett> hahahaahah
22:37:52 <MP2E> haha
22:37:57 <MP2E> well it worked :V
22:37:58 <MP2E> i'm using nixos
22:38:14 <pharpend> edwardk: I've watched through about 2/3 of your episode of the Haskell Cast. Comprehension of lenses still evades me, sad to say, so I got pretty lost. Sorry.
22:38:16 <solatis> cbarrett: yeah
22:38:18 <jle`> elm is mired in operational semantics apparently
22:38:24 <jle`> not that that's a bad thing
22:38:33 <jle`> elm is a pretty awesome tool to doing amazing things
22:38:39 <jle`> but it's just weird to call it FRP
22:38:43 <Axman6> edwardk: how would it do that?
22:39:01 <edwardk> pharpend: yeah I let them wander with me down into the weeds about 2/3rds of the way through that interview. It comes back up to higher level stuff before the end
22:39:18 <solatis> cbarrett: ok, apprently in Elm everything is driven by the timestep
22:39:25 <solatis> that is a big no-no in FRP
22:39:27 <edwardk> Axman6: if you use nixos, you pretty much install lens once and it comes out of the cache all the time
22:39:31 <conal> cbarrett: right. FRP was about two principles: continuous time and simple, precise denotation. as i understand it (after talking with evan cz), elm has neither.
22:39:31 <cbarrett> Right. Elm definitely doesn't have continuous time.
22:39:55 <Axman6> edwardk: right, I thought that might be the case
22:40:05 <cbarrett> Apparently we were initially talking about Helm, which I'd never heard of before tonigh
22:40:12 <conal> cbarrett: see https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 and pointers
22:40:13 <pharpend> I somehow wrapped my head around Yesod, you would think that lenses wouldn't be so bad, by comparison
22:40:26 <cbarrett> conal: Thanks!
22:40:33 <conal> cbarrett: you bet :)
22:40:53 <edwardk> pharpend: there is a #haskell-lens channel which pretty much has 150 people in it happy to answer lens questions ;)
22:40:55 <conal> cbarrett: by "and pointers", i means the links in that answer.
22:41:03 <pharpend> edwardk: i'll take a look
22:42:18 <solatis> seems like Helm still is based on timesteps
22:46:58 <conal> There are some about why continuous time matters at https://github.com/conal/talk-2014-bayhac-denotational-design . i hope the video of the extended version of this talk (2.5 hours at lambdajam in chicago) is up soon, as it makes a more coherent case about continuous space & time.
22:47:27 <cbarrett> conal: awesome
22:47:44 <cbarrett> I was working on a system inspired (loosely) by this at work but it's since been shelved :\
22:47:48 <cbarrett> prob for the best I guess
22:48:12 <Hijiri> the title of the README.md and the project description seem to contradict each other
22:48:35 <Hijiri> the description says programs to meanings, while the readme says meanings to programs
22:58:24 <solatis> ok, so, i was busy implementing a threadpool myself yesterday, which people here claimed to be an anti-pattern
22:58:57 <solatis> i'm building a http crawler, which gets input urls from socket S1 and needs to fetch those urls and needs to send the html body to socket S2
22:59:07 <solatis> urls coming in faster than the crawler can process
22:59:17 <solatis> i was told to just forkIO for every new URL coming in
22:59:58 <solatis> but that does *not* work -- it results in a fork bomb and my http client requests dying because there are hundreds of concurrent requests going on
23:00:21 <kadoban> That sounds pretty expected, heh.
23:00:25 <solatis> yes
23:00:26 <solatis> exactly
23:00:41 <solatis> but i was told that haskell handles all nice epoll and thread pools in the background
23:00:50 <solatis> well, guess not, in this case
23:00:55 <solatis> so
23:01:00 <solatis> what i'm considering to do
23:01:30 <kadoban> Hmm, maybe. I don't know haskell well enough to say about that...seems unlikely it could figure it out magically though.
23:02:05 <solatis> is to use http://hackage.haskell.org/package/threads-0.5.1.2/docs/Control-Concurrent-Thread-Group.html and use waitN before forking off any new threads
23:02:25 <solatis> yes well the c++ programmer in me wants to use a thread pool here
23:02:52 <solatis> or in this case, a thread group, to avoid spawning too many concurrent http requests
23:03:18 <solatis> the thread group keeps track of the running threads, and i have a nice blocking function to ensure max N threads are active
23:03:26 <solatis> does that seem reasonable?
23:03:47 <solatis> or am i focussing too much on implementation details, and can this problem be solved by, for example, conduit?
23:04:07 <kadoban> I've done...almost nothing with threads in haskell. I'll let someone who knows what they're talking about answer :-/
23:04:11 <solatis> (i am under the impression that conduit doesn't actually handle concurrency, just a nice way to process streams)
23:04:18 <liyang> solatis: read the URLs into a Chan and just fork off N threads to consume them.
23:04:43 <solatis> liyang: i had that exact code yesterday and was specifically told not to do that :)
23:04:49 <solatis> since that means i'm maintaining a thread pool
23:04:55 <solatis> which is haskell already doing in the background
23:05:19 <solatis> and i should fiddle with haskell's thread pool settings instead
23:06:34 <solatis> http://lpaste.net/113382
23:06:39 <solatis> thats the code i had yesterday
23:10:04 <peddie> solatis: forkIO won't result in a fork bomb in the sense of "too many OS threads"; it might overload the HTTP server or the connection, though
23:10:42 <solatis> no i understand, but i was told haskell *also* manages TCP connections in an intelligent fashion
23:11:05 <solatis> but that doesn't seem to be the case
23:11:05 <peddie> solatis: well, it manages file descriptors for you, I guess, but you might run into an OS-specific limit on those
23:11:27 <peddie> for what it's worth, liyang's suggestion seems good to me
23:11:47 <solatis> peddie: yes well, that's exactly what i was doing initially, so apparently my gut feeling was right
23:12:00 <peddie> good for you :)
23:12:10 <solatis> i was just afraid that was too much the c++ programmer in me coming up with that design
23:12:50 <peddie> I guess I'd hope a C++ programmer would be afraid of a threadpool and prefer to use epoll() directly :P
23:13:05 <liyang> solatis: I skimmed through yesterday's conversation and I can't really see an argument against that‚Ä¶ what better way to limit yourself to N concurrent threads than to just only fork N threads?
23:14:35 <solatis> peddie: yes well, that was my initial thought yes, but there seem to be no async/callback-like http libraries in haskell, they're all exposed in a synchronous matter
23:14:56 <solatis> so that makes using epoll directly a bit hard :)
23:15:39 <solatis> besides, one might hope the c++ programmer uses a library that does not expose epoll directly but rather something like Boost.Asio :)
23:16:17 <peddie> if you mention boost, I've lost hope :P
23:16:36 <pharaun> solatis: internally the i/o manager uses epoll/whatever
23:16:36 <solatis> tsk
23:16:46 <peddie> solatis, yes, the runtime lets you program with threads without paying much cost for abstraction on top of epoll()
23:16:51 <pharaun> just that most network lib are done sync cos threads are so cheap and its usually easier to reason about
23:17:00 <pharaun> its nice to avoid callback hell
23:17:06 <solatis> pharaun: i understand
23:17:39 <solatis> but if i want to impose a limit on the concurrency amount, what are my options?
23:17:57 <pharaun> i would just do a chan, read from that and spawn N threads, and call it a day?
23:18:09 <solatis> yes
23:18:18 <solatis> well, it's more of a learning excercise for me also
23:18:38 <solatis> to see if i was coming up with the most reasonable design
23:18:42 <solatis> apparently i was
23:19:37 <kadoban> Sounds reasonable, to a guy who doesn't know anything XD
23:19:44 <pharaun> also actually one thing you could do. would make your code more complicated, but you could basically 1) limit calls to the same root dns to like 1 thread, 2) have N many threads for different domains, up to whatever your OS socket limit is (1024 or whatever)
23:20:38 <solatis> pharaun: yeah, that rather sounds like i would need to use a resource pool
23:20:44 <Hijiri> you could also use QSem
23:20:51 <pharaun> solatis: why resource pool?
23:21:15 <pharaun> is that an C++ism? i'm looking it up
23:21:26 <Haskellfant> geekosaur: why is this not a good idea?
23:21:27 <solatis> oh no, it's actually a haskell library
23:21:41 <pharaun> oh?
23:21:44 <Haskellfant> geekosaur: oh nvm I was 10 pages up in the buffer
23:21:53 <Hijiri> actually there are better semaphore libraries
23:21:54 <pharaun> http://hackage.haskell.org/package/resource-pool-0.2.1.0 ?
23:21:59 <Hijiri> like one with bracketing
23:22:03 <solatis> Hijiri: yeah i'm now using Thread.Group.waitN , which blocks until at most N threads are still alive
23:22:21 <solatis> and registering my threads with that group
23:22:33 <solatis> which might actually use QSem under the hood
23:22:47 <solatis> http://hackage.haskell.org/package/threads-0.5.1.2/docs/Control-Concurrent-Thread-Group.html
23:23:36 <pharaun> TVar (Map Domain (Pool HttpWhatever))
23:23:41 <mrenaud_> Is there a reason why there is no EitherT?
23:24:24 <pharaun> well that's probably not the best way of doing it ^ but you get the gist
23:24:40 <pharaun> a map of domain -> resource pools, then you can limit to like X thread for each domain
23:24:54 <lpaste> solatis pasted ‚ÄúConcurrent task‚Äù at http://lpaste.net/113446
23:25:05 <solatis> that's what i actually have right now
23:25:10 <peddie> @hackage either
23:25:10 <lambdabot> http://hackage.haskell.org/package/either
23:25:13 <peddie> mrenaud_: ^
23:25:42 <mrenaud_> Ah thanks :) Not in the standard libraries though?
23:25:45 <pharaun> oh ThreadGroup? that's a new thing to me
23:25:48 <pharaun> looking it up
23:25:56 <peddie> mrenaud_: guess not; don't know much about why
23:26:09 <pharaun> oh that's neat
23:26:13 <solatis> http://hackage.haskell.org/package/threads-0.5.1.2/docs/Control-Concurrent-Thread-Group.html
23:26:17 <pharaun> ya
23:26:22 <solatis> especially the waitN function introduced in 0.5
23:26:26 <solatis> that's basicly what i want
23:26:42 <solatis> without too much of a pain, i can limit the concurrency amount
23:26:51 <solatis> and haskell is most likely using only a single thread in the background anyway
23:27:29 <pharaun> depends on your runtime
23:27:47 <pharaun> if you compile -threaded it is N threads for N cores or something by default (iirc)
23:27:59 <peddie> solatis: https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#setting-rts-options
23:28:10 <pharaun> yeah what peddie linked
23:28:12 <solatis> yeah i know
23:28:19 <peddie> oh, sorry
23:28:21 <solatis> but I still have to run with -N :)
23:28:28 <peddie> no you don't :)
23:29:04 <solatis> oh snap
23:29:20 <solatis> well anyway
23:29:25 <solatis> it doesn't matter
23:29:34 <solatis> if haskell wants to use 4 threads for 4 cores, it's fine by me
23:29:46 <pharaun> well
23:29:51 <pharaun> that's os threads
23:29:57 <solatis> yeah i know
23:30:11 <solatis> i just assumed haskell didn't spawn off any OS thread if it didn't need one
23:31:07 <peddie> solatis: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Conc.html as well :)
23:32:09 <solatis> i was looking at https://www.haskell.org/haskellwiki/Concurrency
23:32:27 <solatis> " As of GHC v6.12, you can leave off the number of cores and all available cores will be used (you still need to pass -N however, like so: +RTS -N)."
23:32:45 <kadoban> Huh, I never realized you could use RTS options on ghc itself...makes sense, just never thought about it.
23:32:58 <solatis> 07:28:24      solatis | but I still have to run with -N :)
23:32:59 <peddie> solatis: the first doc I linked describes how to build in different default RTS options when you compile your program
23:33:10 <peddie> which can let you get around having to pass -N on the command line
23:33:23 <solatis> i know, but i was claiming you should still run your program with -N if you want actual OS threads
23:33:34 <pharaun> if you didn't compile that setting in
23:33:39 <xpika> what is the definition of a safe function ?
23:33:41 <peddie> the second doc I linked describes how to get the number of processors your kernel knows about at runtime and to set the number of OS threads GHC will use at runtime
23:33:59 <solatis> ah yes
23:34:14 <solatis> we were talking about different things then
23:34:16 <peddie> e.g. getNumProcessors >>= setNumCapabilities
23:34:23 <kadoban> xpika: Probably a total function? One that can handle any input you can throw at it and behave sanely, essentially.
23:34:25 <solatis> you can avoid using -N if you write code that does it for you
23:34:37 <peddie> yes
23:35:04 <kadoban> xpika: Could mean something else in other contexts, or I might be totally wrong.
23:35:36 <klugez> solatis: Or compile with ghc --with-rtsopts="-N" so that it's the default.
23:35:43 <Haskellfant> I agree with kadoban so it's probably not totally wrong :)
23:35:55 <kadoban> Huzzah :)
23:36:08 <Haskellfant> xpika: and example of a non safe function is head because it doesn't handle the empty list
23:36:10 <solatis> klugez: jesus so many ways to achieve the exact same result
23:36:16 <solatis> i hate options
23:36:24 <solatis> now i have to decide what's best
23:36:26 <kadoban> Haha
23:37:00 <pharaun> tbh i tend to prefer rts opt during compile time, more flexible
23:37:06 <pharaun> then other folks can customize as they want
23:37:07 <peddie> solatis: next time I'll only link one doc :)
23:37:10 <pharaun> and its less code for you to write
23:38:22 <solatis> yeah exactly, that was my initial thought
23:38:36 <solatis> so you can still use -N1 if you want to
23:38:39 <pharaun> yup
23:39:12 <pharaun> or you can do the other way around and just link in the threaded runtime and let the user do -N if they want that etc
23:39:37 <solatis> yeah, that's why i hate these kind of choices
23:40:05 <solatis> but since the only user will be me, i'm going to leave it to the choice with the least amount of code
23:44:13 <pharaun> then stick it into rts opt at compile time and call it a day
23:44:16 <pharaun> is what i would do fwiw
23:46:23 <solatis> nah, it doesn't really fit in my containerized devops machanism
23:47:33 <solatis> i like that i can make the assumption that 1 container = 1 OS core
23:47:36 <Hijiri> you could link the user to articles on choosing the right number of OS threads, and then prompt them interactively for how many they want to use
23:47:45 <Hijiri> +citations
23:48:49 <solatis> yes, and don't forget to add a Clippy clipart somewhere to remind the user that he is not using the optimal number of cores
23:49:00 * hackagebot linear 1.11.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.11.2 (EdwardKmett)
23:49:45 <pharaun> there's probably an package for that!
23:50:42 <solatis> in true Haskell fashion, it will probably only be a paper discussing a possible implementation, a proof of concept and unmaintained code that doesn't compile since GHC 7
23:51:23 <solatis> or am i being too snarky here?
23:54:30 <gfixler_> omg
23:54:39 <gfixler_> cabal installs more than 52k files
23:54:48 <gfixler_> in more than 74k directories
23:54:55 <gfixler_> what on earth are you people creating?
23:55:21 <pharaun> magic?
23:55:23 <gfixler_> is thing sentient yet?
23:55:28 <pharaun> gfixler_: what's up?
23:55:44 <pharaun> like is that # of files/directory causing you trouble?
23:55:52 <gamegoblin> Any of you folks used the fgl graph library?
23:56:12 <gfixler_> pharaun: no, though it did make me wait for a few minutes as I watched the output of 'tree'
23:56:37 <pharaun> haha dang
23:56:43 <sivteck> cobol cabal
23:56:58 <gfixler_> am I seeing 20 years of development here?
23:57:23 <solatis> cabal is already being developed for 20 years?
23:58:02 <gfixler_> not cabal, but haskell code
23:58:08 <liyang> cabal is more like 10.
23:58:19 <liyang> (Less than, I'm pretty sure.)
23:58:19 <solatis> if you installed all haskell packages, yes
23:58:23 <gfixler_> I wonder how much of this is in active use
23:58:56 <gfixler_> more specifically, I wonder if there are branches that haven't been used by anyone in years
23:59:06 <solatis> gfixler_: someone did a nice analysis of NPM's database about that recently
23:59:42 <gfixler_> solatis: NPM?
