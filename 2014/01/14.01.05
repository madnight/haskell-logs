00:03:08 <roboguy_> is there a function that filters takes two predicates and when one of them is met, it stops filtering and just gives you the rest of the list unfiltered
00:03:44 <carter> foldl?
00:05:19 <roboguy_> carter: I was wondering if there was something a little more specific. also I'm working with an infinite list
00:05:44 <carter> you want a foldl that can terminate early
00:06:21 <roboguy_> carter: wouldn't it be a foldr?
00:06:49 <carter> how would it know when the finite prefix is done?
00:07:06 <carter> (seriously, i'm tired and tipsy, so i'm just thinking out loud :p)
00:07:37 <roboguy_> I thought foldl never terminates on an infinite list?
00:07:46 <roboguy_> regardless of the function
00:08:06 <roboguy_> @src foldl
00:08:07 <lambdabot> foldl f z []     = z
00:08:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:10:12 <Feuerbach> roboguy_: yes, you need a foldr
00:10:28 <carter> yeah
00:10:34 <carter> or something differnt
00:10:44 <carter> yeah
00:11:18 <Feuerbach> roboguy_: do you need some specific help with it?
00:11:40 * hackagebot identifiers 0.2.0.1 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.2.0.1 (awagner83)
00:11:40 * hackagebot time-patterns 0.1.0.2 - Patterns for re-occurring events.  http://hackage.haskell.org/package/time-patterns-0.1.0.2 (jfmueller)
00:14:41 <roboguy_> Feuerbach: well, I made a couple working implementations but I was wondering if it could be faster. now that I think about it though, that's probably not the performance problem
00:15:25 <Feuerbach> roboguy_: so why don't you show us your version?
00:16:14 <marx2> why doesn't foldl terminate if the function is lazy in its first arguments?
00:16:19 <marx2> > let f _ x = x in foldl f 0 [1..]
00:16:24 <lambdabot>  mueval-core: Time limit exceeded
00:16:48 <Feuerbach> marx2: try to evaluate it by hand, using the definition of foldl
00:16:49 <marx2> > let f x _ = x in foldr f 0 [1..]
00:16:50 <lambdabot>  1
00:17:37 <marx2> oh right, it keeps recursing and fetching next element
00:17:51 <roboguy_> Feuerbach: here's what I have so far. I'm working on a Project Euler problem: http://lpaste.net/97990
00:18:24 <roboguy_> I think the real problem is in the fundamental concept of the algorithm I'm using for the primes though
00:19:16 <Feuerbach> roboguy_: indeed. But writing it with foldr is still a nice exercise
00:20:54 <Feuerbach> roboguy_: OTOH, if your goal is just to solve the PE problem, there are some fast prime libraries on hackage
00:21:30 <roboguy_> Feuerbach: good point, I forgot about that. I think I'll work on the foldr version for practice and then find a prime library
00:22:07 <roboguy_> although, it might be good to try to implement a true sieve of Eratosthenes
00:22:43 <carter> just use a lazy infinite self referential corecusrive thingy
00:25:08 <roboguy_> Feuerbach: If I was using foldr, I'd have to use Either or something like that to represent the early termination, right?
00:28:15 <Feuerbach> roboguy_: there are a couple of ways to do that. But I don't think you need Either
00:28:42 <Feuerbach> one way is to return a tuple
00:29:12 <Feuerbach> whose elements correspond to two different paths of execution (filtering, not filtering)
00:35:36 <randomclown> What the hell is MonadBaseControl?
00:35:59 <Feuerbach> randomclown: that's a good description of it
00:41:38 * hackagebot hsimport 0.2.6.3 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.3 (DanielTrstenjak)
00:44:42 <roboguy_> aha, I figured it out. I needed a irrefutable lazy pattern match on the tuple
00:46:19 <Feuerbach> roboguy_: I don't think it should matter
00:46:24 <Feuerbach> can you show the code?
00:48:29 <roboguy_> Feuerbach: sure! http://lpaste.net/97992
00:50:42 <roboguy_> first time I've actually needed that, actually
00:50:49 <roboguy_> *ever needed that
00:50:50 <mirpa> can I force Haddock to put documentation of record field on same line? ", a :: A --^ 'Some.Other.Module.Type.A'" ...so that this produces just one line in doc
00:51:22 <Feuerbach> mirpa: no, you have no control over that kind of formatting
00:51:35 <Feuerbach> roboguy_: hmm, that doesn't seem to return the rest of the list
00:51:51 <roboguy_> Feuerbach: oh, oops. I forgot about that part
00:51:52 <Feuerbach> filterWhile even  (<10) [1..]
00:52:50 <mirpa> Feuerbach: damn...
00:52:58 <tectonic> fpcomplete seems pretty cool
00:54:16 <Gorroth> whatever you do, don't do ['K','K'..'Z']
00:54:21 <Gorroth> i don't even know what that does, but it isn't good
00:54:50 <Ralith> spam K a lot?
00:54:59 <Gorroth> yeah
00:55:07 <Ralith> what's so scary about that?
00:55:09 <A1kmm> > take 10 [0,0..1]
00:55:10 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
00:55:23 <A1kmm> Gorroth: Basically it is an infinite list of 'K'.
00:55:26 <Gorroth> i didn't say it was scary; i said it isn't good
00:55:29 <mirpa> Gorroth: I once tried [0..255] to get range of Int8 which gives empty list of course :-)
00:55:47 <maxs`> > ['K', 'L'..'Z']
00:55:48 <lambdabot>  "KLMNOPQRSTUVWXYZ"
00:56:11 <Gorroth> mirpa: hmm?  that returns 256 elements
00:56:23 <jtcwang> is there a way to do tuple assignment in haskell?
00:56:31 <flebron> > take 10 $ enumFromThenTo 'K' 'K' 'T'
00:56:32 <lambdabot>  "KKKKKKKKKK"
00:56:42 <erisco> > let (a, b) = (5, 10) in a + b
00:56:43 <lambdabot>  15
00:56:44 <jtcwang> like (varA, varB) = functionreturningtuple
00:56:45 <flebron> jtcwang: "assignment"? You can say (a, b) = (1, 2) if you want.
00:56:51 <jtcwang> cool
00:56:58 <mirpa> > [0..255] :: [Int8]
00:56:59 <lambdabot>  []
00:57:16 <Gorroth> oh, i don't now anything about that.  i thought you just wanted [0..255]
00:57:16 <erisco> jtcwang, note that any pattern matching is valid
00:57:22 <mirpa> > [minBound..maxBound] :: [Int8]
00:57:23 <lambdabot>  [-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,...
00:57:33 <roboguy_> Feuerbach: alright, this should be fixed: http://lpaste.net/97992 (it looks like both ~s are necessary for infinite lists)
00:57:35 <erisco> > let (x:y:_) = [1..10] in x + y
00:57:35 <lambdabot>  can't find file: L.hs
00:57:37 <jtcwang> erisco, can you eleborate on that? i'm not quite catching it
00:57:38 <Gorroth> i don't really know haskell yet
00:57:49 <jtcwang> erisco, right
00:57:50 <erisco> lambdabot get a grip
00:58:10 <jtcwang> ^
00:58:17 <roboguy_> actually, it still doesn't have the right termination properties, hmm
00:58:27 <maxs`> > [0..127] :: [Int8]
00:58:28 <jtcwang> lambdabot going to lose his job soon due to automation
00:58:28 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:58:36 <Cale> Gorroth: Well, it does exactly what you'd expect, in that it starts with 'K' and repeats the difference between 'K' and 'K' until it reaches 'Z', which it never does :)
00:58:50 <Cale> > ['a','c'..'z']
00:58:50 <lambdabot>  "acegikmoqsuwy"
00:58:57 <Feuerbach> roboguy_: filterWhile even  (<10) [1..] still doesn't seem to work
00:58:58 <roboguy_> although it seems to work well enough
00:59:06 <Cale> > ['a','d'..'z']
00:59:07 <lambdabot>  "adgjmpsvy"
00:59:12 <jtcwang> erisco, in your last example should we do [x:y:_] instead of brackets?
00:59:14 <Gorroth> nope, not what i expect, because i don't know what to expect
00:59:19 <Cale> > [0,2..20]
00:59:20 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20]
00:59:26 <Cale> > [0,3..20]
00:59:27 <lambdabot>  [0,3,6,9,12,15,18]
00:59:34 <Cale> > [1,3..20]
00:59:35 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
00:59:39 <maxs`> > 128 :: Int8
00:59:40 <lambdabot>  -128
00:59:48 <Feuerbach> roboguy_: and you shouldn't need (++) at all for that
01:00:00 <Cale> > [3,5..]
01:00:01 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
01:00:03 <Gorroth> so, if i do ['k','k'..'z'] here, would i be in trouble? :)
01:00:10 <mirpa> > 255 :: Int8
01:00:11 <lambdabot>  -1
01:00:15 <Cale> > ['k','k'..'z']
01:00:16 <ion> gorroth: no
01:00:16 <lambdabot>  "kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk...
01:00:17 <erisco> jtcwang, that does not mean the same thing
01:00:23 <Gorroth> > ['k','k'..'z']
01:00:24 <lambdabot>  "kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk...
01:00:24 <flebron> [a,b..c] == enumFromThenTo a b c
01:00:30 <Cale> The bot is smart enough not to continue forever :)
01:00:35 <Gorroth> that's good
01:00:46 <mirpa> > [0..(-1)]
01:00:47 <lambdabot>  []
01:01:09 <Gorroth> > [0..]
01:01:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:01:11 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
01:01:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:01:17 <flebron> [a..b] == enumFromTo a b, [a..] == enumFrom a
01:01:18 <maxs`> > [0..256] :: [Int8]
01:01:19 <lambdabot>  [0]
01:01:27 <mirpa> poor lambabot... :-)
01:01:27 <Cale> Infinite lists are fun :)
01:01:30 <erisco> > let [x:y:_] = [[1,2]] in x + y -- jtcwang
01:01:32 <lambdabot>  3
01:01:35 <ion> flebron: Also, =
01:02:13 <jtcwang> erisco, hmm i see
01:02:19 <Gorroth> Cale: so that prime example... is it adding numbers to 'primes' as it goes along?  it looks like you're using a history to determine if a number is prime or not?
01:02:27 <jtcwang> can we do without the brackets though?
01:02:31 <erisco> jtcwang, note that x:y:[] is equiv to [x,y]
01:02:40 <jtcwang> x:y:_ = w/e
01:02:44 <jtcwang> would that be legal?
01:02:47 <flebron> Gorroth: He's writing primes in terms of primes.
01:02:54 <flebron> In the same manner,
01:02:58 <erisco> jtcwang, do you have ghci? try it
01:03:01 <Cale> Gorroth: Well, we're defining the list of all prime numbers as being 2 followed by the elements of the list [3,5..] (i.e. odd numbers 3 and up) which satisfy isPrime
01:03:28 <flebron> > let fib = 0:zipWith (+) fib (tail fib) in fib
01:03:32 <lambdabot>  mueval-core: Time limit exceeded
01:03:32 <Gorroth> i know that.  does your isPrime check if 'primes' already has a number in it?
01:03:33 <Cale> Gorroth: and then isPrime n tests all the primes less than or equal to the square root of n to see if they divide n
01:03:37 <flebron> Well that was unexpected.
01:03:37 <jtcwang> erisco, ok it works, but i guess brackets make it clearer
01:03:52 <Gorroth> okay.  so you are using your history of primes
01:04:05 <Gorroth> yeah, i meant to say if something is divisible by it.. not if it's in it
01:04:08 <Cale> yeah, as the computation goes along, the list of primes becomes more and more computed
01:04:13 <Gorroth> ah
01:04:15 <flebron> > let fib = 0:1:zipWith (+) fib (tail fib) in fib
01:04:16 <Gorroth> nice
01:04:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:04:25 <jtcwang> erisco, but with tuples you need () to do assignment
01:04:36 <Cale> (It's a constant, so once it's computed, it'll stay in memory until nothing references it any more)
01:04:46 <flebron> "once it's computed"
01:04:53 <erisco> jtcwang, yup
01:06:12 <Cale> Gorroth: That initial 2 is very important though...
01:06:24 <Gorroth> hmm, i'll just have to get more fmailiar with haskell.  i know how these functions work imperatively, but i don't know what haskell is doing exactly
01:06:26 <Cale> > let primes = filter isPrime (2 : [3,5..]); isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
01:06:29 <lambdabot>  mueval-core: Time limit exceeded
01:06:44 <Gorroth> Cale: i know.  that 2 is important no matter what language you use
01:06:58 <Cale> Well, you can choose a different algorithm
01:07:26 <Gorroth> i can only think of worse algorithms, unless you wanted to save memory
01:07:26 <Cale> This is really just doing trial division, but it is a little faster than most trial division things because it only tests whether primes divide each number
01:07:59 <Cale> There are better ones. A real sieve of Eratosthenes is faster (but probably can't be implemented as such a nice one-liner :)
01:08:08 <erisco> and primes become more sparse the larger they get so it is a good deal :)
01:08:20 <Cale> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
01:08:41 <tectonic> Cale: it's just interesting that you can reference primes inside of the left hand side of the let.  that's cool
01:09:04 <Cale> tectonic: Yeah, let is recursive
01:09:28 <Cale> (And Haskell allows recursively defined values, not just recursively defined functions.)
01:09:43 <tectonic> how are those implemented under the hood?
01:10:00 <Cale> Well, there's a representation of expressions at runtime
01:10:32 <roboguy_> Cale: mutual recursion is a good idea
01:10:40 <roboguy_> (in this case at least, hah)
01:10:41 <Cale> Expressions are only evaluated when you pattern match on them, at which point evaluation proceeds up to determining the top-most data constructor.
01:10:52 <Feuerbach> roboguy_: yes, I now agree irrefutable patterns are needed here (although you could simply replace them with fst/snd, of course)
01:11:01 <Cale> (In this case, it's the Show instance for lists which is pattern matching and forcing things to be evaluated)
01:11:25 <Cale> The way GHC does it is that all variables are pointers to code
01:11:41 <roboguy_> Feuerbach: strangely, that version of filterWhile seems to work in primes
01:11:55 <roboguy_> not quickly, but still
01:12:10 <tectonic> Cale: it's quite cool
01:12:12 <Feuerbach> roboguy_: here's my version http://lpaste.net/97994
01:12:21 <Cale> When this code is entered the first time, the value (i.e. minimally just the constructor and the expressions it's applied to) is evaluated, and the pointer is rewritten to point at a shorter piece of code which will return that value immediately
01:12:49 <tectonic> Haskell internals must be pretty crazy
01:13:10 <Cale> Actually, immediately after it's entered, before the computation begins, the pointer is rewritten to point at a "black hole", which is a bit of code that signals an error if it's re-entered, which detects some infinite loops.
01:13:45 <Cale> In the threaded runtime though, that has to be replaced by a "grey hole" which just blocks until the thing is evaluated, because some other thread might be evaluating the variable.
01:13:47 <erisco> Feuerbach, roboguy_ what is the filterWhile function?
01:14:21 <Aetherspawn> anyone used c2hs/ffi ? http://stackoverflow.com/questions/20931099/using-c2hs-to-marshal-a-void
01:14:23 <Feuerbach> erisco: <roboguy_> is there a function that filters takes two predicates and when one of them is met, it stops filtering and just gives you the rest of the list unfiltered
01:14:24 <tectonic> Cale: interesting
01:14:24 <roboguy_> erisco: it acts like filter while the second function returns True and when it's False it just gives the unfiltered list
01:14:52 <roboguy_> Feuerbach: hmm, that implementation makes sense
01:14:53 <Cale> (that turns an infinite loop which would use 100% CPU into code which blocks silently and uses 0% CPU though, so still usually a win)
01:15:14 <tectonic> Gotta go.  Thanks for answering my question, Cale.  gnight!
01:15:19 <Cale> g'night!
01:15:42 <Aetherspawn> If you're using ViewPatterns
01:15:43 <erisco> Feuerbach, roboguy_ filter (\x -> f x || g x)  ?
01:16:16 <Aetherspawn> nevermind
01:16:27 <Aetherspawn> I had a solution but it blew up in my face when trying to reason about performance
01:16:30 <roboguy_> erisco: that won't filter the first part of the list
01:16:51 <roboguy_> actually, maybe filter (\x -> f x == g x)
01:16:52 <erisco> roboguy_, oh, I guess I do not understand :(
01:17:04 <Aetherspawn> he wants something like this
01:17:08 <roboguy_> since == is xor
01:17:30 <Feuerbach> no, because you're supposed to ignore the first predicate after the second is satisfied
01:17:33 <Aetherspawn> let (filter (pred) -> x, y) = splitWhile pred
01:17:49 <Aetherspawn> where splitWhile is imaginary and filter(pred) -> is supposed to be a ViewPattern
01:17:58 <Feuerbach> it's inherently stateful, so it cannot be a simple filter
01:18:02 <erisco> roboguy_, so in filterWhile f g, if g x is true then elemented are removed, and what if g x is false?
01:18:04 <roboguy_> hmm, yeah
01:18:22 <Cale> I feel like that's an abuse of ViewPatterns
01:18:23 <Aetherspawn> Oh, two predicates?
01:18:30 <Aetherspawn> Then mine is already most performant <_<
01:18:39 <Aetherspawn> let (filter (pred2) -> x, y) = splitWhile pred1
01:18:51 <Aetherspawn> Cale: yes, the feels
01:18:52 <roboguy_> erisco: for example, take 15 $ filterWhile even (<= 10) [1..] == [2,4,6,8,10,11,12,13,14,15,16,17,18,19,20]
01:18:54 <Aetherspawn> it feels like abuse <.<
01:20:18 <erisco> roboguy_, filter (\x -> not $ f x && g x)
01:20:52 <Aetherspawn> erisco: he wants the unfiltered part I think
01:20:59 <Aetherspawn> so its like, split a list using a predicate
01:21:04 <erisco> roboguy_, oh sorry I got the true/false mixed up
01:21:05 <Aetherspawn> and then filter the left part of the split using another predicate
01:21:24 <erisco> well I am confused because that is not what roboguy_'s example shows
01:21:35 <Aetherspawn> roboguy_: what you want, foo.
01:21:40 <Cale> What's the original question here?
01:21:51 <roboguy_> haha, I want it to work as in the example I gave
01:22:11 <Cale> Is it this? <roboguy_> is there a function that filters takes two predicates and when one of them is met, it stops filtering and just gives you the rest of the list unfiltered
01:22:27 <erisco> roboguy_, filter (\x -> f x || not (g x))
01:22:28 <roboguy_> Cale: I was just trying to make an infinite prime list, but only comparing up to p*p <= n. your method is nicer though
01:22:35 <roboguy_> Cale: yeah
01:23:11 <erisco> does Haskell have an implication operator?
01:23:14 <roboguy_> erisco: actually yeah, I think that works
01:23:59 <mm_freak_> roboguy_: if this is for something practical, arithmoi gives you a very fast infinite prime list
01:24:06 <mm_freak_> it uses sieving
01:24:31 <Aetherspawn> Data.Primes or something like that
01:24:33 <Aetherspawn> in the primes package
01:24:36 <Aetherspawn> uses a fast wheel sieve
01:24:48 <mm_freak_> Aetherspawn: a wheel is not a sieve
01:24:50 <erisco> @let (==>) f g x = not (f x) || g x
01:24:51 <roboguy_> mm_freak_: nah, I was just trying some different things to see how fast I could get the primes code for a Project Euler problem
01:24:52 <lambdabot>  Defined.
01:25:07 <Aetherspawn> I recall it saying that it's a sieve.
01:25:21 <Cale> You can combine a wheel and a sieve
01:25:22 <erisco> @let filterWhile f g = filter (g ==> f)
01:25:22 <lambdabot>  .L.hs:149:29:
01:25:22 <lambdabot>      Ambiguous occurrence `==>'
01:25:22 <lambdabot>      It could refer to either `L.==>', defined at .L.hs:150:4
01:25:22 <lambdabot>                            or `Lambdabot.Plugin.Haskell.Eval.Trusted.==>',
01:25:22 <lambdabot>                               imported from `Lambdabot.Plugin.Haskell.Eval.Tr...
01:25:31 <mm_freak_> Aetherspawn: either it's a wheel (optimized trial division) or it's a sieve (no division at all, just bit operations)
01:25:34 <erisco> oh damn I am sorry :P
01:26:12 <Cale> Well, just multiplication and comparison :)
01:26:14 <mm_freak_> Aetherspawn: and to be honest, i don't think any package on hackage outperforms arithmoi for integer/number theory operations ;)
01:26:36 <erisco> @let filterWhile f g = filter (g L.==> f)
01:26:36 <lambdabot>  Defined.
01:26:42 <mm_freak_> for most of its algorithms it's close to GMP/C native speed
01:26:47 <erisco> > filterWhile even (<= 10) [1..20]
01:26:49 <lambdabot>  [2,4,6,8,10,11,12,13,14,15,16,17,18,19,20]
01:27:00 <roboguy_> alright well, I need to go to bed. good night, thanks for the help!
01:30:56 <erisco> is Norman Ramsey on this channel?
01:33:46 <Aetherspawn> I wish people put their IRC usernames as their github thing
01:33:57 <Aetherspawn> I'm a hipocrit, I should be using mine.
01:35:55 <qnix> hlint-1.8.55 depends on haskell-src-exts-1.14.0 which failed to install. because haskell-src-exts-1.14.0 depends on cpphs >=1.3 where the current latest version is 1.17, 1.3 is old! something wrong while cheacking the version
01:36:12 <qnix> seems cpphs consider 1.3 < 1.17.1
01:40:24 <Feuerbach> qnix: can you lpaste the output of cabal install -v haskell-src-exts ?
01:41:04 <Feuerbach> or cabal install -v hlint
01:43:37 <qnix> Feuerbach: http://lpaste.net/97996 <- -v haskell-src-exts
01:43:43 <Aetherspawn> Anyone good at c2hs?
01:44:06 <danilo2> Hello! does anybody now how we can type such 3 line code to make it working? http://lpaste.net/97997  I was trying to use RankNTypes, but without success here
01:44:38 <qnix> Feuerbach: http://lpaste.net/97998 hlint
01:45:32 <Feuerbach> qnix: wierd, it doesn't say anything about the error. Can you do the same with -v3?
01:45:32 <Aetherspawn> danilo2: I don't think that's allowed.
01:45:48 <Aetherspawn> You might be looking for ExistentialTypes ?
01:45:58 <Aetherspawn> RankNTypes sounds like a compile time thing
01:46:36 <Feuerbach> danilo2: bind makes it monomorphic
01:47:39 <danilo2> Aetherspawn, Feuerbach: Here is my previous example, where rankNTypes was able to solve the problem :http://lpaste.net/97988
01:48:09 <danilo2> Feuerbach: Could you tell more? So cannot I get a function from monad, which is polymorphic?
01:48:12 <Feuerbach> danilo2: right, because there's no bind there
01:48:15 <qnix> Feuerbach: http://lpaste.net/98000 v3
01:48:36 <Feuerbach> danilo2: you can wrap it into a newtype, for example
01:48:47 <Feuerbach> newtype Poly = Poly (forall a. a -> a)
01:48:55 <danilo2> Feuerbach: why bind makes it monomorphic? Is bind not a normal function call ?
01:49:39 <Feuerbach> danilo2: exactly, bind is an ordinary function. Any ordinary function, unless it's expecting a polymorphic argument, will instantiate its argument to a monotype
01:50:52 <Feuerbach> it becomes clear if you rewrite it in Core or System F
01:51:26 <danilo2> Feuerbach: hmm, ok, I'll try to understand it. Could you be so nice and show me the way with newtype here?
01:51:39 <qnix> Feuerbach: I do it manually runghci Setup.hs configure and it complains cpphs >= 1.13 "I have version 1.17 installed via cabal"
01:51:55 <Aetherspawn> newtype sounds like it probably needs ExistentialTypes ?
01:52:12 <Feuerbach> no, just RankNTypes
01:52:16 <Feuerbach> it's not an existential
01:52:25 <qnix> so this says that 1.17 < 1.13 where 1.17 is > 1.13 according to math
01:52:52 <danilo2> Feuerbach: how can we do it? :)
01:53:49 <Feuerbach> qnix: where does it say that? I fail to see
01:53:52 <Feuerbach> danilo2: do what?
01:53:57 <augur> Aetherspawn: gadt's make it easier to see why its not existential
01:54:11 <qnix> Feuerbach: cabal fetch haskell-src-exts and then I do it manually
01:54:16 <augur> data Poly where Poly :: (forall a. a -> a) -> Poly
01:54:18 <augur> vs
01:54:35 <augur> data Wrap where Wrap :: forall a. a -> Wrap
01:54:43 <augur> observe the scope of the quantifier.
01:54:55 <danilo2> Feuerbach: Oh, I did not notice what time is it ... I have to go for a while, but I will be back in an hour or so - you have told me, that I can wrap it i n newtype to make it working - I was asking If you could show how to do it, because all my triues failed.
01:54:59 <Aetherspawn> the second is existential
01:55:00 <Feuerbach> qnix: I'm confused. In the log you pasted it doesn't say anything about the versions, does it?
01:55:01 <Aetherspawn> the first is not?
01:55:04 <augur> Aetherspawn: right
01:55:15 <Aetherspawn> ok, I guess that makes sense.
01:55:31 <Feuerbach> danilo2: define idM as return $ Poly id
01:55:31 <augur> Aetherspawn: the reason its called existential is because of what Wrap is sort of doing
01:55:41 <augur> Aetherspawn: another view of wrape is
01:55:43 <Feuerbach> danilo2: and after you get it from the bind, unwrap it
01:55:57 <danilo2> Feuerbach: ok, thank you :)
01:56:02 <Feuerbach> yw
01:56:04 <augur> data Wrap where ExistsSomeType :: forall a. a -> Wrap
01:56:14 <augur> in a sense, the constructor is saying
01:56:19 <qnix> Feuerbach: nothing in the logs I gave you
01:56:35 <Feuerbach> qnix: so can you paste the log that says something? :)
01:56:41 <augur> there is a type, a, and here is some proof that it's inhabited, namely, an element of it
01:57:20 <Feuerbach> qnix: regarding that first log, I'd file a cabal bug. It ought to give some kind of error message
01:57:46 <Aetherspawn> I kind of get it, but not fundamentally
01:57:49 <qnix> It fails with unkown reason I had to do it manually to see why it fails, found that haskell-src-exts fail on dependency cpphs => 1.13 as defined in the .cabal file where I have cpphs version 1.17 installed from cabal. No logs I have say that thing, I found out manually by fetching the source code and doing runghci Setup.hs configure
01:58:00 <Aetherspawn> I can't see how the second one doesn't produce an existential because of the right hand side part
01:58:02 <Aetherspawn> -> a
01:58:11 <Aetherspawn> *first one
01:58:33 <qnix> Feuerbach: I tried to generate useful error/data/logs/..etc from cabal it doesn't spit anything useful. Error:failed isn't a useful message
01:58:49 <augur> Aetherspawn: the first one is just saying, if you can give me a polymorphic function, ill give you a Poly
01:59:19 <augur> Aetherspawn: the thing thats existential here, fwiw, is the type a
01:59:22 <Feuerbach> qnix: what do you mean no logs? Can you paste what's on the console?
01:59:25 <augur> Wrap :: forall a. a -> Wrap
01:59:44 <augur> what this is doing, basically, is taking two arguments: a type `a` and an element of a
01:59:49 <augur> and wrapping them up together
02:00:05 <Feuerbach> qnix: I want to see some evidence that the problem is indeed due to the versions
02:00:12 <Feuerbach> so far I haven't seen it
02:01:16 <augur> Aetherspawn: in dependent types, could write something equivalent like this, using agda:   wrap :: (A : Set) -> A -> Wrap
02:01:35 <augur> where it's clear that wrap takes two arguments: a set A, and an element of that set
02:01:57 <qnix> Feuerbach: solve it
02:02:34 <augur> Aetherspawn: now you're probably wondering why that's called existential at all
02:02:49 <Aetherspawn> Yeah, I think I need to read some from scratch tuts
02:03:05 <Aetherspawn> I've honestly only picked up fragments of type stuff outside haskell 2010
02:03:22 <qnix> Feuerbach: cabal doesn't spit useful errors, it was because PATH doesn't have ~/.cabal/bin
02:03:26 <augur> consider the true existential type in agda:  data Exists (A : Set) (P : A -> Set) : Set where exists : (x : A) -> P x -> Exists A P
02:03:41 <augur> Aetherspawn: the type of exists is very similar
02:04:07 <qnix> Feuerbach: the 'searching feature' can find cpphs but the configuration files can't find cpphs due to it not being in PATH
02:04:38 <Aetherspawn> does agda use OCaml'ey types, a : Int ?
02:04:44 <augur> so in general: existential quantification is a special pair-like thing: Exists A P is like (A,B) except that the type B depends on the value chosen for the first element
02:04:46 <Aetherspawn> instead of ::
02:04:47 <qnix> Feuerbach: the finding is capabile of searching in ~/.cabal/bin no via $PATH while the other configuration files 'the one for haskell-src-ext' depends on ~/.cabal/bin/ being in PATH. anyway solved
02:04:48 <augur> Aetherspawn: yes
02:04:51 <qnix> Feuerbach: thanks
02:05:07 <augur> Aetherspawn: so what happens then if you have a of this type:   foo :: Exists A P -> ...
02:05:15 <augur> if its basically a pair, you should be able to curry it
02:05:22 <Feuerbach> qnix: still, could you please describe this in a cabal bug, for the benefit of the future users?
02:05:32 <augur> instead of taking as arguments a pair (a,p) where a :: A and p :: P a
02:05:39 <augur> it takes in an argument a :: A
02:05:40 <Feuerbach> qnix: github.com/haskell/cabal/issues
02:05:42 <qnix> Feuerbach: Ofcourse will do
02:05:44 <augur> and then another argument p :: P a
02:06:01 <augur> that is, foo has its type (a :: A) -> P a -> ...
02:06:14 <augur> hey presto, its what we saw before!
02:06:34 <augur> if you curry `exists`, or you curry `wrap`, it has as its argument an existential!
02:06:49 <augur> er, uncurry
02:07:10 <augur> so, in haskell, we might write Wrap as an uncurried thing:   data Wrap where Wrap :: (exists a. a) -> Wrap
02:07:22 <augur> same thing as before, just uncuried.
02:07:35 <augur> and now you see why you more or less have existential types, maybe
02:07:47 <Aetherspawn> did you mean to write exists
02:07:51 <augur> yes
02:07:55 <Aetherspawn> or is that a dependent type thing
02:07:55 <Aetherspawn> oh
02:08:04 <augur> i dont know if haskell actually supports it or not tho
02:08:06 <augur> but
02:08:32 <augur> `exists a. a` is the type of pairs (a,x) where a :: * and x :: a
02:08:48 <augur> "there is some type a, such that i have a proof/element of a"
02:09:01 <augur> its just a pair: a type, together with an element of that type
02:09:56 <augur> in general, ofcourse, you can write things like  exists a. f a   for some choice of f
02:10:14 <augur> actually thats not quite right sorry
02:10:45 <augur> no thats correct actually, derp.
02:11:01 <Aetherspawn> How do you add extensions in GHCI again?
02:11:12 <augur> dunno :\
02:11:21 <Aetherspawn> oh, :set didnt worlk the first time
02:11:25 <augur> value-level existentials arent possible in haskell tho
02:11:27 <Aetherspawn> I think I typo'd it
02:11:38 <augur> so normally you just have things like this:   exists a :: *. f a
02:11:42 <Aetherspawn> This wiki seems to maybe suggets exists, well, exists
02:11:44 <Aetherspawn> so I'm testing it.
02:11:54 <augur> where your pairs are (a,x)   a :: * and x :: a
02:12:12 <augur> so f :: * -> *
02:12:14 <augur> but sometimes you want things like   exists x :: a. p x
02:12:27 <augur> where your pairs are (x,y)   x :: a, y :: p x
02:12:30 <augur> so p :: a -> *
02:13:00 <augur> exists x :: Int. Even x
02:13:26 <augur> so you might have like... (2, SucSuc Zero) :: (exists x :: Int. Even x)
02:13:38 <augur> where Even is define as something like
02:14:40 <augur> data Even (n :: Int) where   Zero :: Even 0   ;   SucSuc :: (n :: Int) -> Even (n - 2) -> Even n
02:15:00 <augur> notice that SucSuc has an existential type too:   i could just as well write it as
02:15:14 <augur> SucSuc :: (exists n :: Int. Even (n - 2)) -> Even n
02:15:29 <augur> but that wont quite work since i need to have n available for the return type
02:15:45 <augur> i'd need to use some nasty stuff to get n out of the pair
02:15:57 <augur> blegh. im blabbering. sorry :p
02:16:00 <Aetherspawn> Sorry, I have little or no idea what's going on anymore
02:16:01 <Aetherspawn> rofl
02:16:06 <augur> :)
02:18:07 <CaveJohnson> @version
02:18:07 <lambdabot> lambdabot 5.0-int-e
02:18:07 <lambdabot> git clone git://github.com/int-e/lambdabot.git
02:22:03 <augur> Aetherspawn: you should of course learn some dependently typed programming
02:22:08 <augur> and/or some type theory
02:22:24 <Aetherspawn> is Idris as powerful as agda for tha?
02:23:31 <Aetherspawn> woo got +1'd by ekmett on facebook, life is complete.
02:23:44 <Kaidelong> Idris is turing complete and far more familiar (?)
02:24:26 <Kaidelong> probably not as strong of a proof engine
02:24:28 <Aetherspawn> I was thinking about trying Idris because its been on reddit and the news and stuff lately
02:24:30 <augur> Aetherspawn: yes
02:24:32 <augur> perhaps even more so
02:24:33 <Aetherspawn> ok
02:24:39 <augur> since it has type classes, etc.
02:25:00 <augur> so i think probably idris is in a good place. i havent used it, but
02:25:17 <augur> afaik it can do everything agda can, just with a more haskell look and feel
02:28:08 <augur> Aetherspawn: dependent types are fundamentally very simply things
02:28:29 <augur> the tricky bit is realizing how incredibly powerful they are for thinking and programming
02:31:34 <Aetherspawn> Maybe there are paralells in how long it will take dependent types to be adopted and FPLs in general
02:33:03 <augur> i think we'll see them adopted by the FP community once we really know how to use them well
02:33:06 <mm_freak_> idris misses a few things that agda has
02:33:13 <augur> mm_freak_: oh? what did you have in mind?
02:33:34 <mm_freak_> a good termination checker and a substitute for agda-mode
02:33:55 <augur> there's an idris mode now afaik
02:34:05 <mm_freak_> sure, but it's not quite agda-modey =)
02:34:06 <randomclown> Is there any sigificicance of liftIO as opposed to just lift?
02:34:11 <augur> as for termination checking, yeah, i dont know. thats good and useful, but
02:34:21 <mm_freak_> randomclown: yes, if you're not exactly one step above IO
02:34:31 <mm_freak_> randomclown: ReaderT X (WriterT Y IO) Z
02:34:48 <mm_freak_> you'd use either 'lift . lift' or just liftIO
02:35:08 <randomclown> Oh so just a shortcut
02:35:56 <mm_freak_> randomclown: not just a shortcut…  when you use MonadReader you assume that there is some ReaderT in your monad stack, so you can use 'ask' instead of 'lift (lift (lift (lift ask)))'
02:36:05 <mm_freak_> liftIO is the same thing, except for general IO actions
02:36:08 <Aetherspawn> doesnt liftIO use like a recursive thing to walk the stack
02:36:24 <Aetherspawn> then why shouldn't there exist liftState and such?
02:36:36 <mm_freak_> MonadReader/MonadWriter/MonadIO/… liberate you from thinking about the precise monad stack
02:36:48 <mm_freak_> Aetherspawn: see MonadState in mtl
02:37:01 <hpk> (/close
02:37:16 <mm_freak_> just use get/put, even if your StateT is deeply buried
02:37:53 <Aetherspawn> I dont think transformers does that
02:38:01 <mm_freak_> it doesn't
02:38:02 <mm_freak_> mtl does
02:38:14 <Aetherspawn> why do some prefer transformers then?
02:38:31 <mm_freak_> mtl is a convenience wrapper for transformers
02:38:56 <Aetherspawn> Oh I thought it was the other way around
02:38:58 <Aetherspawn> my bad.
02:39:00 <mm_freak_> if all you need is MonadIO or a simple State/Writer, you can use transformers
02:39:13 <mm_freak_> i.e. nothing that depends on extensions
02:52:19 <Fuuzetsu> Is there a way to build only dependencies inside a sandbox? Say, I download someone's package and want to build it but I don't want to clutter my system with whatever deps it has but I don't want to simply cabal sandbox init and then cabal build because that will pull in all dependencies it can, including stuff I already have.
02:52:32 <Fuuzetsu> I don't want to rebuild ‘text’ for every bloody package I want to sandbox
03:03:01 <randomclown> monad-control is another whole can of worms
03:03:02 <randomclown> apparently
03:06:17 <akegalj> what is "Mutator Time" in GHC statistics?
03:08:43 <akegalj> oh i found out, it's just a running time.
03:08:56 <Cale> akegalj: It's the time spent mutating expression graphs
03:09:03 <Cale> i.e. getting actual work done
03:10:02 <akegalj> Cale: yes, thnx
03:10:09 <randomclown> is there a way to specify TCP options i.e. TCP_NODELAY in conduit TCP client?
03:11:47 <Cale> randomclown: I don't know about conduit, but you can fiddle with things like that using e.g. setSocketOption NoDelay sock
03:11:53 <Cale> If you have a Socket
03:12:09 <Cale> er, oops, you'll need an Int value too
03:12:18 <randomclown> I did want to use conduit or pipes or something similar
03:12:23 <Cale> setSocketOption sock NoDelay 1
03:12:24 <Cale> I suppose
03:12:43 <Cale> Does conduit give you access to the Socket?
03:12:56 <randomclown> Cale: not that I can see
03:13:26 <Cale> Which conduit-related library are you using?
03:13:40 <Cale> Sockets are lower level stuff than most of the conduit libraries I've ever seen
03:13:43 <randomclown> network-conduit is what I'm looking at
03:14:16 <Cale> Right, so that library provides things which *take* a Socket parameter
03:14:34 <Cale> So presumably you just configure the Socket however you like beforehand
03:15:00 <randomclown> Oh right I was looking at the simpler runTCPClient stuff
03:15:34 <randomclown> which actually make the socket for you
03:17:30 <Aetherspawn> randomclown: pipes-network gives you a socket option
03:17:52 <Aetherspawn> well, a socket.
03:19:32 <randomclown> Aetherspawn: Pipes vs Conduits?
03:21:09 <Cale> I'd always think twice about introducing pipes/conduits/etc. into my code. It's heavy machinery which I think for many applications is somewhat unwarranted. Many people would disagree with me though.
03:22:20 <Cale> I think pipes is my current favourite though, in terms of organising the complication somewhat nicely.
03:23:19 <randomclown> So pipes/conduits play well with STM?
03:23:38 <Aetherspawn> pipes is 5.5x faster than conduits for pure operations
03:23:56 <Aetherspawn> and slightly faster than conduits for IO (althought for IO, the overhead is VERY negliable for using either)
03:24:04 <randomclown> Do* not so
03:24:23 <Cale> randomclown: Well, to the extent that you can do IO actions inside them, and STM transactions count as IO actions, I would say they kind of have to play well with STM?
03:24:27 <Aetherspawn> why wouldn't they play with STM?
03:24:45 <Cale> (STM transactions count as IO actions via atomically)
03:26:02 <Aetherspawn> https://gist.github.com/kvanberendonck/7622803
03:26:26 <Cale> Can anyone, without checking the documentation, tell me what the type of (>>~) is from the pipes library?
03:26:55 <Aetherspawn> something to do with applying a function
03:27:04 <Aetherspawn> ~ I think means function
03:27:10 <rioch> Is a Data.Map homogenous?
03:27:14 <Cale> rioch: yes
03:27:15 <Aetherspawn> *shrug* I assume you're trying to make a point about the operators
03:27:35 <Cale> Aetherspawn: Well, the fact that it's infix doesn't bother me *too* much
03:27:48 <abaranosky> what does a state of the art Emacs configuration look like for Haskell?  Do any of you have links to your dotfiles? Or a good blog?
03:28:09 <rioch> thanks
03:28:13 <Cale> Aetherspawn: It's more the fact that the types themselves are almost impossible to remember or reproduce because there are so many type parameters involved and they get wired around in funny ways
03:28:43 <Aetherspawn> you mostly only use >->
03:28:54 <Aetherspawn> and Producer/Consumer aliases for things that create or eat respectively
03:29:01 <Aetherspawn> and then for/cat for applying functions over streams
03:29:50 <Cale> Okay, so what's the type of (>->)?
03:30:00 <Cale> (without looking!)
03:31:29 <Cale> Okay, I'll admit when you specialise it in various ways to Producer/Consumer/Pipe, it's not that terrible
03:32:07 * hackagebot scotty-hastache 0.2.0 - Easy Mustache templating support for Scotty  http://hackage.haskell.org/package/scotty-hastache-0.2.0 (DaniilFrumin)
03:32:23 <Aetherspawn> oh
03:32:32 <Aetherspawn> >-> is something like Pipe -> Pipe -> Pipe
03:32:37 <Aetherspawn> I think
03:33:03 <Cale> (>->) :: Monad m => Proxy a' a () b m r -> Proxy () b c' c m r -> Proxy a' a c' c m r
03:33:04 <Aetherspawn> I just remember that if I need to join two things in the direction flowing of the arrows, I can use it most the time.
03:33:33 <Aetherspawn> Oh, might be Producer -> Consumer -> Pipe then.
03:33:51 <Cale> It's Producer -> Consumer -> Effect
03:34:00 <Cale> and Producer -> Pipe -> Producer
03:34:07 <Cale> and Pipe -> Consumer -> Consumer
03:34:14 <Cale> and Pipe -> Pipe -> Pipe
03:34:21 <Aetherspawn> heh
03:34:24 <Aetherspawn> it's pretty overloaded.
03:34:26 <Cale> (with appropriate type arguments)
03:34:35 <Cale> Those are all type synonyms of Proxy though
03:34:45 <Cale> with various bits replaced by ()
03:34:51 <Cale> (or Void)
03:36:42 <Cale> and even Pipe throws away half of the communication that Proxy allows for
03:36:55 <Cale> type Pipe a b = Proxy () a () b
03:37:59 <Cale> (There's really bidirectional communication that's possible everywhere)
03:38:17 <abaranos`> what does a state of the art Emacs configuration look like for
03:38:18 <abaranos`>              Haskell?  Do any of you have links to your dotfiles? Or a good
03:38:18 <abaranos`>              blog?
03:38:46 <abaranosky> my mistake for the triple post there
03:38:48 <Cale> abaranos`: Uh, people have different opinions on that. Minimally turn on the option which makes emacs turn tabs into spaces.
03:39:02 <Cale> There's a haskell-mode
03:39:19 <Cale> and it has a bunch of settings you can fiddle with to your liking
03:39:32 <Aetherspawn> I think the idea is that Pipe is easy to grog
03:39:49 <Aetherspawn> I find Proxy has too many parameters for me to err, read.
03:40:01 <Cale> abaranosky: and then there's Chris Done's fancy structured-haskell-mode: https://github.com/chrisdone/structured-haskell-mode
03:40:26 <Cale> Aetherspawn: yes :)
03:40:36 <abaranosky> I see there is a scion mode too
03:41:36 <abaranos`> Cale: interesting. It is like paredit for Haskell
03:44:09 <Cale> abaranosky: Personally, I don't worry about configuring my editor much beyond getting tabs to spaces, syntax highlighting, and maintaining the last line's indent when I press enter. If you're programming correctly in a language as decent as Haskell, the edits you have to make shouldn't be *too* onerous even if your editor is not very fancy.
03:44:56 <Cale> That said, there is one point of pain that Chris' stuff deals with (at least somewhat), in automatically realigning blocks whenever an edit causes the first non-whitespace character after a layout keyword to move.
03:45:09 <abaranos`> Cale: I'm less interested in structured editing (though I do love paredit), but more interested in REPL integraiton and compiler integration.
03:45:26 <Cale> Mostly I just run GHCi in a separate window anyway
03:45:54 <Cale> I tried running it inside emacs, but sometimes that can be obnoxious, especially when you do something that prints an infinite list.
03:46:22 <adnap> What is a good way to check if a file is an image?
03:46:22 <Cale> Whenever you save your file, you can just tap :r in ghci to reload
03:46:40 <Cale> adnap: The unix file command?
03:46:49 <adnap> Cale: (In Haskell)
03:46:56 <adnap> Something that does what file does
03:47:08 <adnap> That is cross-platform
03:47:28 <Cale> Get some image processing library and just try to load the file?
03:47:59 <adnap> Cale: That sounds bad. I don't want to depend on a whole image processing library for that
03:48:08 <darthdeu> http://ro-che.info/ccc/23 lol
03:48:19 <adnap> The best thing I have found is: https://hackage.haskell.org/package/mime-types
03:48:27 <Cale> darthdeu: :D
03:48:43 <ion> darthdeu: heh
03:49:20 <Cale> adnap: Well, I was thinking that since your program cared whether the file contained an image, it would probably also be interested in the contents of the file :)
03:49:29 <adnap> Cale: Nope
03:49:36 <darthdeu> so i'm having trouble explaining to people why i actually enjoy haskell .... most of the time all i can do is "it feels less wrong than other things" -_-
03:50:27 <Komier> lol
03:50:44 <Komier> most common response I get is "Why not just learn Python?"
03:50:52 <Cale> darthdeu: Equational reasoning, meaningful types which actually catch errors that you'd spend large amounts of time in a debugger trying to find, compositionality through laziness/nonstrict semantics, a good story for concurrency and parallelism...
03:50:57 <ion> komier: :-D
03:51:36 <FliPPeh> Urgh Python
03:51:55 <FliPPeh> All my desire to ever use python again was completely destroyed in one somewhat larger project that I had to maintain
03:52:06 <FliPPeh> Nothing has been spoiled faster than python
03:52:10 <Cale> Useful ways of abstracting over things and writing code which is *actually* reusable rather than code which pretends to be reusable but turns into a mess the moment you try to do so.
03:52:54 <FliPPeh> Nothing says "viable programming language" like having to fix typos that don't get noticed until you happen to run that rarely needed code path they are in
03:53:03 <Cale> adnap: http://hackage.haskell.org/package/magic
03:53:26 <FliPPeh> Duck typing can go to hell
03:53:36 <Komier> *shrug* people just find it weird I'm learning Haskell as a first language.  "Why not just learn Python, it's easy!"
03:53:53 <darthdeu> isn't duck typing kinda exactly the type of polymorphism haskell has? :P
03:54:06 <FliPPeh> But you get type safety afterwards
03:54:15 <darthdeu> yes
03:54:40 <Cale> Oh, the ability to refactor things by just changing something and then steamrolling the compiler over it and letting GHC tell you what to change until it compiles, and then having everything work after hundreds of lines touched over a library which is a few thousand lines.
03:55:10 <Cale> That's a pretty big selling point imo.
03:55:12 <Cale> :)
03:55:27 <darthdeu> Cale: yeah but there's the contra-argument of saying that in order to change something you have to change 40 other things because you can't really hide side effects, at least my noob observation
03:55:33 <adnap> Cale: I wonder what the heck the String is in magicFile :: Magic -> FilePath -> IO String
03:55:35 <FliPPeh> Yeah, I had to refactor a big (2000+ lines) python module into smaller modules
03:55:43 <FliPPeh> I have been hunting missing imports for hours
03:56:01 <darthdeu> i've found that the bigger codebase i have (max hundreds of lines), and then when i decide to change how i think about some part of the system, like some data type, i have to change everything :\
03:56:08 <Cale> darthdeu: My response to that is that you'd have to change those things anyway. It's just that if the compiler let you get away with it, any one of those 40 things would become a bug if you missed it.
03:56:31 <Gorroth> Komier: if someone said to go learn python, i'd say... c++
03:56:33 <darthdeu> Cale: well that's not entirely true, because you could use reflection for some things and never have to touch other parts of the code
03:56:43 <ion> adnap: A MIME type perhaps?
03:56:44 <Gorroth> but if they said to go learn haskell first, i'd say... eh, sounds good enough :)
03:56:52 <Cale> This is a *huge* mental relief, not having to worry about all those places in the code which a change would potentially affect. The compiler can *tell* you.
03:57:00 <FliPPeh> C++ actually got usable with C++11
03:57:18 <Gorroth> c++ was usable with boost before, but i agree that c++11 made it a lot better
03:57:24 <Gorroth> and i'm looking forward to c++14
03:57:27 <Cale> There are refactorings which I would do in Haskell which I simply would not attempt in Python.
03:57:36 <FliPPeh> But boost inflated your compilation times like nothing else could
03:57:46 <FliPPeh> Boost.Asio is especially bad
03:57:52 <darthdeus> Cale: you would have tests in python, which allow you to refactor :)
03:57:54 <Gorroth> FliPPeh: yeah, but at least we have incredibuild and distcc to help with it
03:57:56 <Cale> You couldn't, because it would amount to rewriting everything, because you'd start making changes and everything would just be fucked, and then you'd be lost.
03:58:12 <Gorroth> oh, we don't use boost.asio at work
03:58:44 <FliPPeh> It let me build a very simple HTTP server in under 400 lines, but the price I paid...
03:58:53 <Cale> Even with tests, "Okay, all my tests don't work now. Now what?"
03:58:58 <Gorroth> Cale: btw, what are you talkinga bout?  what are you using to let you do refactors?  some sort of IDE or testing framework or something?
03:58:59 <FliPPeh> I think that one c++ file takes 4 seconds to compile
03:59:15 <Cale> Gorroth: I'm just talking about running the compiler on code which isn't going to compile
03:59:23 <Gorroth> oh, okay
03:59:25 <Cale> Gorroth: because you've started making a change to some types
03:59:38 <Gorroth> Cale: ah, and haskell does strong type checking in advance/
03:59:38 <Cale> Gorroth: and then having the compiler point out where the type errors are
03:59:54 <Cale> yes, and types actually mean things in Haskell about what the things actually do
04:00:06 <Gorroth> okay, cool.. i'm sure i'll figure that out eventually
04:00:18 <Cale> So many more kinds of problems with the code are reflected as type errors, and the compiler will tell you where you need to fix things.
04:00:21 <Gorroth> FliPPeh: yes.  for me, the compile times are nothing thanks to incredibuild, but it's the link time that really hurts
04:00:41 <darthdeus> yeah but generally you don't need to do such a big refactoring in a dynamic language, because things are abstracted in small pieces ... in my noob view of haskell i feel that because everything is completely static i would have to change thousands of lines if i decide to change some of the core types of the app
04:01:03 <darthdeus> but i'm probably wrong about that
04:01:03 <darthdeus> :)
04:01:16 <Cale> darthdeus: It's not that you don't need to, it's that even if it would be beneficial, you wouldn't do it, because it's not something you can reasonably attempt.
04:01:53 <darthdeus> you just said refactoring is easy :P
04:01:54 <lingxiao> happy sunday morning all! :)
04:02:02 <lingxiao> could someone take a look at my question on SO?
04:02:03 <lingxiao> http://stackoverflow.com/questions/20933021/how-do-you-express-a-computation-that-recursively-descend-a-tree-and-keep-a-fres
04:02:32 <lingxiao> it looks like a simple question for those who know the right "tools"
04:02:37 <Gorroth> Cale: the things you're talking about with duck typing is a big reason i'm not using python anymore.  i'm always afraid to refactor things, because then i have to figure out a way to do a whole set of tests, and i may still miss something
04:02:54 <darthdeus> let's say i have data User = ..., which is the core for everything in the app, and suddenly i decide i need to make half of the data User into data UserAccountInfo ...
04:02:58 <Cale> When I was working at iPwn Studios on making some refactorings in our 8000-or-so line FRP library, I recall making a fundamental change, and then spending a few hours making hundreds of edits to many many places in the code as directed by GHC, and then at the end of it having the game still work as soon as it compiled again.
04:03:16 <adnap> Cale: Okay, so magicfile gives something like "JPEG image data, JFIF standard 1.01" I wonder if 'contains "image"' is a decent test, or if that would screw up on something that is not a picture
04:03:27 <Cale> adnap: I dunno! :)
04:03:30 <Gorroth> Cale: nice.  strong type checking and tests ftw :)
04:03:48 <darthdeus> Cale: hmm interesting
04:04:05 <FireFly> adnap: "ISO image"? :p
04:04:48 <darthdeus> Cale: is there a book that's kinda like "how to build large things in haskell and not commit suicide"?
04:04:58 <darthdeus> i'm not trolling
04:05:05 <darthdeus> i genuinely don't understand how
04:05:57 <adnap> FireFly: I checked that. It doesn't contain image
04:06:28 <adnap> FireFly: "# ISO 9660 CD-ROM filesystem data 'sysrcd-3.7.1' (bootable)"
04:06:30 <FireFly> Oh, okay
04:06:48 <FireFly> adnap: what do you want to check this for?
04:07:11 * hackagebot scientific 0.2.0.0 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.2.0.0 (BasVanDijk)
04:07:14 <adnap> FireFly: I want to display all images in a directory in a web page, and I need to know which are displayable
04:07:20 <Cale> darthdeus: I've never really thought too much about it, I've just gone ahead and done things, and it's mostly worked out. As long as you keep thinking about your types, and get that design right, it's easy enough to refactor things as need arises.
04:07:39 <Cale> (and if you need to change the types, well, I just gave you a story about that :)
04:07:54 <darthdeus> Cale: but how do i think about my types? people always say i should get the types right first, but how do i even begin when i've never done this?
04:08:03 <Cale> Well, hmm
04:08:05 <Cale> :)
04:08:21 <Gorroth> go with the trial-and-error process :)
04:08:22 <Cale> I suppose like anything it's just writing smaller things and working your way up.
04:08:26 <Gorroth> aka iterative approach
04:08:30 <FireFly> adnap: I guess that's good enough, as long as false positives isn't catastrophic (I think it'd be possible to engineer a file that would yield a string containing 'image')
04:08:43 <Cale> I don't think I would believe any single methodology that someone was fanatical about here
04:08:54 <adnap> FireFly: Well, I'm concerned that magic is slower than just checking the extension
04:09:06 <Cale> If someone calls something "X driven development", they are trying to scam you.
04:09:10 <adnap> FireFly: 'Cause it has to load (at least part of) the file in RAM
04:09:33 <FireFly> Fair point
04:09:44 <darthdeus> "X driven development" helps in the beginning when you have no clue what you're doing
04:09:58 <adnap> Makes me think of "enterprise"
04:10:01 <akegalj> Cale: ipwn bloodknight is written in haskell?
04:10:04 <lingxiao> heyall: how would you describe a monadic computation that recurively descend a tree, and spawn a new local state at each split?
04:10:29 <Cale> akegalj: Yeah, though it's not finished and we're on indefinite hiatus while Ryan maybe gets together some more money to make another run at it
04:10:54 <Cale> (I'm actually okay with my experiences there, I got paid for my time, and learned a lot, but it would be nice to release *something* eventually)
04:11:02 <akegalj> Cale: wau, it looks great. i hope u'll finish it!
04:11:04 <adnap> Why not just make it for free
04:11:39 <Cale> adnap: Well, I suppose I could go back and work on it, but some of the people involved can't realistically work for free. I might be able to get away with a bit of that.
04:13:01 <Cale> darthdeus: So, first think about the problem you're trying to solve. You presumably have some context of information available to you, and you have some result which you'd like to get from that.
04:13:50 <Cale> darthdeus: That's more or less the type of a function. Maybe give the type of your input and the type of your result names directly, maybe not. Think about how you might turn it into smaller problems. What types will those problems have?
04:14:09 <Cale> It's impossible to be too specific here, because there are so many different sorts of problems.
04:14:25 <Cale> and so many different ways that you might want your program to grow in the future
04:14:48 <Cale> One approach which seems to work often is to design a miniature language in which your problem is easy to express
04:15:07 <Cale> That language will have some primitive problems which are (hopefully!) trivial to solve
04:15:16 <Cale> and some ways to glue problems together into more complicated ones
04:15:24 <darthdeus> hmm that's an interesting approach
04:15:29 <Cale> (and hopefully in such a way that the solutions can also be glued together)
04:15:31 <Hail_Spacecake> I have a function using guard syntax
04:16:00 <adnap> https://hackage.haskell.org/package/mime-types-0.1.0.3/docs/src/Network-Mime.html#defaultMimeMap uses fromAscList to make a Map Text ByteString, where the ByteStrings are literals within quotes. I want to convert these back to Text using http://hackage.haskell.org/package/text-0.11.0.7/docs/Data-Text-Encoding.html. How do I tell what the encoding is? Is it whatever the encoding of the source file is, or is there some default for ByteStri
04:16:01 <Hail_Spacecake> and in one of the guard conditions, I'd like to use an @-pattern to capture part of the eexpression that builds up into a boolean
04:16:07 <Cale> You'll recognise this pattern in many many libraries in Haskell
04:16:13 <Hail_Spacecake> and use it in the expression for that function if that bool is true
04:16:29 <Cale> Every monad is kind of an example of it. Every Applicative too. Many things which are neither are also still examples of this idea.
04:16:35 <Hail_Spacecake> but apparently haskell doesn't allow as-patterns in guards?
04:16:52 <Cale> Hail_Spacecake: I think you're looking for PatternGuards
04:17:08 <Cale> There are no patterns in guards usually
04:17:13 <Cale> Guards are just boolean values
04:17:28 <Hail_Spacecake> right
04:17:29 <Cale> But PatternGuards generalises guards so they can perform additional matching
04:17:32 <Hail_Spacecake> ooh
04:17:38 <Cale> and any sort of patterns are allowed there
04:17:53 <lingxiao> Cale: could you some examples of projects that "design a miniature language in which [the] problem is easy to express"
04:18:00 <Hail_Spacecake> this is new syntax?
04:18:04 <Hail_Spacecake> or new as of 2010?
04:18:09 <lingxiao> aside from Diagrams which is amazing, and huge
04:18:16 <Cale> lingxiao: SPJ has a wonderful talk about this
04:18:28 <Cale> (and a paper or two to go with it, let me dig them up)
04:18:38 <lingxiao> Cale: nice, thanks!
04:19:08 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm -- the paper and slides, I'll find the video
04:19:29 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/ -- here it is
04:19:56 <lingxiao> Cale: ah I actually have it saved! It did strike me as really really elegant
04:19:59 <Cale> Another great example is Parsec (or any parser combinator)
04:20:18 <Cale> and yet another is all the prettyprinter libraries
04:20:31 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
04:20:57 <adnap> Oh, cool. There's an isPrefixOf for ByteString
04:21:15 <Cale> Another is all the variations of Lava
04:21:31 <Cale> http://raintown.org/lava/
04:21:35 <lingxiao> so here by language you mean a set of primitive combinators that should span every function you'd ever need to write in the domain?
04:21:36 <dmj`> adnap: I don't believe bytestrings have an associated encoding, you can use Data.ByteString.Char8 to assume ASCII though, if you call Data.Text.Encoding.decodeUtf8 it will attempt convert a ByteString to a UTF8 encoded string. That's my understanding
04:23:27 <Cale> lingxiao: Yeah, the idea is that you're constructing this domain specific embedded language for building up descriptions of "problems" compositionally, and then you can provide various different "solutions" which take those descriptions and break them down again, solving them recursively in some way
04:24:21 <Cale> SPJ gives the somewhat frivolous example of a cookbook EDSL where you have ways of describing various puddings by specifying their ingredients (as primitive desserts), and then various ways to manipulate and combine those
04:24:39 <Cale> and perhaps you could provide a function on that sort of thing which produces an English language description of how to make it
04:24:50 <Cale> (along with a separated ingredients list, perhaps)
04:25:13 <Cale> Or perhaps you can do other things like figure out nutritional information
04:25:31 <adnap> Is is possible to define a ByteString value with literal text in quotes?
04:25:31 <Cale> (maybe not always, but so long as you're not cooking anything ;)
04:25:43 <lingxiao> Cale: when you wrote this sentence " and then you can provide various different "solutions" which take those descriptions and break them down again, solving them recursively in some way"
04:25:49 <dmj`> adnap: yes, use the overloadedstrings pragma
04:26:09 <adnap> I just tried in GHCI and it's saying "couldn't match expected type ByteString with [Char]"
04:26:16 <adnap> dmj`: Okie
04:26:30 <lingxiao> I take it mean the *combinators* recursively break down the *problem*, applying some existing function(solution) to each bit?
04:26:49 <dmj`> adnap: :set -XOverloadedStrings
04:26:51 <adnap> I can't figure out why BS.pack isn't working
04:27:01 <adnap> let b = BS.pack "hi" :: ByteString
04:27:13 * hackagebot hsimport 0.2.6.4 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.4 (DanielTrstenjak)
04:27:14 <adnap> Couldn't match type `Char' with `GHC.Word.Word8'
04:27:24 <adnap> Do I need a double pack?
04:27:33 <adnap> To pack a String into a Word8?
04:27:42 <dmj`> adnap: If you call ":set -XOverloadedStrings" then "let g = "hey" :: ByteString" should work
04:27:47 <Cale> Well, abstractly, we might have some primitives (or non-primitives) X and Y, and supposing that we know how to solve X and solve Y, we should be able to solve C X Y (where C is some combining operator in our language) by combining the solutions to X and Y.
04:27:50 <dmj`> adnap: no packing needed w/ the pragma
04:28:08 <adnap> dmj`: I want to know how to define a ByteString without the pragma
04:28:36 <Cale> lingxiao: Like, if we have desserts X and Y, and maybe C represents some instruction like whipping them together in a bowl.
04:28:57 <dmj`> ":m + Data.ByteString" then "let g = pack "stuff""
04:29:00 <Cale> Then to compute the amount of sugar in C X Y, we can add the amount of sugar in X to the amount of sugar in Y
04:29:28 <k00mi> adnap: ByteStrings consist of Word8s, if you want to pretend they consist of Chars (bad idea!) have a look at Data.ByteString.Char8
04:29:51 <lingxiao> Cale: Ahh got it, thanks!
04:30:11 <adnap> Oh, so the pragma saves me from figuring out the binary representation of a string literal
04:30:12 <dmj`> adnap: oops, you'll have to use Data.ByteString.Char8
04:30:15 <Cale> Or to combine the English recipes, we might combine the ingredient lists, concatenate the instructions for making X and Y, and add an instruction to whip them together in a bowl to the end.
04:30:38 <lllllllllllll> Cale, thanks for the video link
04:30:42 <dmj`> adnap: exactly, it works with Text, ByteString, String and Word's
04:31:12 <Cale> No problem :)
04:31:46 <k00mi> adnap: the pragma inserts a function "fromString" in front of every String literal
04:32:14 * hackagebot scientific 0.2.0.1 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.2.0.1 (BasVanDijk)
04:32:19 <adnap> Okay, now I've got isImage :: FileName -> Bool; isImage = BS.isPrefixOf "image" . defaultMimeLookup
04:32:52 <Cale> darthdeus, everyone: I've also found it to be quite a valid approach to build some sort of strand from the very high level part of my program down to the details of what it's going to do to begin with, basically to get something running, and then expand out around that, if that makes any sense.
04:33:22 <adnap> But I don't know which images types web browsers are required to support. Maybe isImage is too general
04:33:29 <darthdeus> Cale: you mean like interfaces?
04:33:58 <Cale> I mean like get some little bit of the problem solved, and get a little bit of the UI done, and make something which actually runs
04:34:13 <mauke> web browsers are not required to support any image types
04:34:23 <Cale> and then expand outward and grow the thing in complexity around that
04:34:24 <darthdeus> ah yeah, that does make sense
04:34:39 <adnap> mauke: Wow, I didn't know that
04:34:43 <mauke> wtf
04:35:02 <mauke> you need to use more lynx or w3m
04:35:07 <lingxiao> Cale: do you have any heuristics on how to represent the prob domain with appropriate formulation of data types?
04:35:08 <adnap> I have used those
04:35:27 <adnap> mauke: I was under the impression those browsers were not compliant with web standards
04:35:32 <lingxiao> because I normally do what you just told darthdeus, which is to "organically" grow my program
04:35:44 <Cale> Yeah, I think there's nothing too wrong with that
04:35:53 <mauke> adnap: and blind people?
04:35:58 <Cale> because refactoring is "easy" (not really easy, but easier than in most languages)
04:36:12 <adnap> mauke: ?
04:36:29 <Cale> and often code is kind of short, so it won't be too painful to throw things away and try something else if it's not working out
04:36:45 <ivanm> in attoparsec, what is the purpose of the Added field/type? Just to record all the input that was ever received?
04:36:54 <mauke> also, the alt="..." attribute
04:37:14 <adnap> mauke: You're not speaking in complete sentences. I have no idea what you're talking about
04:37:22 <lingxiao> Cale: hmm ok that's exactly what I do haha, iterative approximation. It would be nice if there is semi-formulaic way to break the prob down to its most atomic constitutients on the first go
04:37:34 <Cale> Designing types so that they're meaningful and so that they really tell you something about what your program is doing takes a bit of experience, and also involves a wide spectrum of how much information about your problem you're willing to make static.
04:37:34 <skypers> hi
04:37:49 <mauke> adnap: browsers for blind people don't display any images. did you think they were non-compliant too? what did you think the alt attribute is for?
04:37:55 <skypers> do you  know a way to fold through Map’s keys?
04:38:03 <skypers> without using toList
04:38:18 <Cale> But I think problem solving is something which is too general to formalise entirely. If there were a program you could follow to solve any problem, then we'd have written that program and we'd all be out of work.
04:38:19 <adnap> mauke: It doesn't make sense to restrict web standards to the limitations of blind people
04:38:23 <ivanm> skypers: is Map an instance of Foldable?
04:38:26 <skypers> yes
04:38:32 <skypers> and it iterates over values
04:38:33 <ivanm> then you could use that, can't you?
04:38:33 <skypers> not keys
04:38:37 <ivanm> ahhh, gotcha
04:38:47 <skypers> it’s quite obvious actually
04:38:49 <ivanm> skypers: get the Set of keys from the Map?
04:38:53 <skypers> since the instance works for Map k
04:39:02 <ivanm> yeah, yeah, I wasn't thinking, get over it :p
04:39:11 <adnap> mauke: HTML5 has a canvas element. Blind people can't see that
04:39:11 <ivanm> @hoogle keySet
04:39:12 <lambdabot> No results found
04:39:12 <Cale> The various methodologies that people espouse are usually full of hot air. Some of them at least contain some kernel of truth, but it's often obvious truth.
04:39:14 <ivanm> @hoogle keysSet
04:39:14 <lambdabot> Data.IntMap.Strict keysSet :: IntMap a -> IntSet
04:39:14 <lambdabot> Data.IntMap.Lazy keysSet :: IntMap a -> IntSet
04:39:14 <lambdabot> Data.Map.Lazy keysSet :: Map k a -> Set k
04:39:18 <ivanm> skypers: ^^
04:39:23 <Cale> "Testing that things work is good"
04:39:28 <skypers> hm, thank you
04:39:28 <mauke> adnap: so how about that alt thing?
04:39:33 <ivanm> @instances-import Data.Set Foldable
04:39:33 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
04:39:37 <Cale> "Working together with another person sometimes is good"
04:39:48 <ivanm> ummmm... how do I import two modules with instances-importing? :p
04:40:02 <skypers> hm so Set is just a Map without values?
04:40:08 <mauke> @help instances-importing
04:40:08 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
04:40:09 <skypers> like Map k ()?
04:40:13 <ivanm> skypers: one way of looking at it, yeah
04:40:14 <skypers> no mapping
04:40:19 <skypers> ok
04:40:23 <skypers> it’s ordered set?
04:40:27 <ivanm> yes
04:40:30 <adnap> mauke: Oh, right. That's for when images aren't loaded for some reason.
04:40:31 <skypers> nice
04:40:33 <skypers> thank you
04:40:35 <lingxiao> Cale: ha true! yeah I guess prob solving is an ambigous human problem
04:40:35 <ivanm> np
04:40:47 <mauke> @instances-importing Data.Set Data.Foldable Foldable
04:40:48 <lambdabot> ErrorT e f, Maybe, Set, WriterT w f, []
04:40:51 <adnap> mauke: Please be nice to me.
04:40:59 <lingxiao> so when you say: "and also involves a wide spectrum of how much information about your problem you're willing to make static."
04:41:07 <ivanm> mauke: :o didn't know you could do multiple imports
04:41:07 <Cale> Oh, yeah
04:41:20 <ivanm> skypers: so Set has a Foldable instance, so you can fold over that
04:41:22 <Cale> So, when you design types, you have choices to make about how much those types say about what the data is.
04:41:24 <mauke> ivanm: that's why I used @help
04:41:36 <skypers> ivanm: I actually look for keys
04:41:43 <skypers> oh no
04:41:45 <skypers> not keys
04:41:55 <ivanm> mauke: wait, @help gives helpful messages? since when? :p
04:41:56 <skypers> nor keysSet
04:42:03 <ivanm> skypers: what are you after then?
04:42:06 <skypers> actually, toList sounds to be the unique solution to my problem
04:42:12 <skypers> ivanm: I have a map of sections
04:42:18 <skypers> Map String [String]
04:42:27 <skypers> I want to discard all sections using a filter
04:42:42 <skypers> and use the values of the remaining items
04:42:52 <ivanm> a filter on the key or the value?
04:42:57 <skypers> that map represents something like .INI sections
04:42:59 <Cale> Haskell gives you a fair amount of room to express finer details of what the possible values of your type are. You can use something more structured than String, for instance, in many cases, and even then, you have everything from making a newtype, to constructing some recursive algebraic datatype which expresses all the possibilities with lots of structure.
04:43:00 <skypers> (on the keys)
04:43:09 <skypers> I have the list of all correct sections
04:43:16 <skypers> then I can just mapM the map
04:43:23 <skypers> and when I find an incorrect section
04:43:27 <skypers> I can print it out
04:43:34 <skypers> the idea is to filter not the correct sections
04:43:47 <skypers> and the remaining sequence must be null for a correct file
04:43:51 <skypers> you got the idea?
04:43:57 <Cale> Dependently typed languages go even farther in letting you express the meanings of your types (they become exactly like first order logical formulas which express a theorem you can try to prove by producing a value of that type)
04:44:18 <ivanm> skypers: Data.Map.updateWithKey
04:44:24 <klrr> is there anything similar like "x <- many1 (not "!")" from parsec that works in attoparsec?
04:44:45 <ivanm> klrr: many1satisfy (/= '!') ?
04:44:49 <ivanm> or something like that
04:44:56 <skypers> I think filter (\(s,_) -> not $ s `elem` correctSections) . toList $ theMap is quite nice here
04:45:10 <klrr> ivanm: which module is that in?
04:45:30 <skypers> oh
04:45:31 <Cale> (But even without all that, you have lots of options available to you in something like Haskell)
04:45:38 <skypers> updateWithKey sounds great too!
04:45:43 <ivanm> klrr: probably from the one the parser is defined in (Data.AttoParsec.Text, etc.)
04:45:43 <skypers> thank you
04:45:57 <skypers> but hm
04:46:00 <ivanm> skypers: I'd be tempted to use a HashSet or something rather than a list of correct ones
04:46:15 <ivanm> and do you want a list of sections remaining?
04:46:18 <ivanm> or go back to a Map?
04:46:21 <skypers> no
04:46:26 <skypers> a list will do it
04:46:29 <klrr> ivanm: hmm, there is no function like that in it
04:46:33 <skypers> filter pred . toList will do it
04:46:44 <ivanm> maybe even look at unordered-containers; since you're using a String as a key, that'll probably perform better
04:46:57 <ivanm> skypers: except don't use pred as the variable name :p
04:46:59 <skypers> I need order
04:47:00 <ivanm> @type pred
04:47:00 <lambdabot> Enum a => a -> a
04:47:04 <ivanm> @hoogle many1Satisfy
04:47:04 <dmj`> I wrote a letter frequency printer, prints vertically, would like feedback
04:47:04 <lambdabot> No results found
04:47:12 <dmj`> why don't my lpastes show in #haskell ?
04:47:14 <skypers> ivanm: import Prelude hiding ( pred ) ;)
04:47:33 <SimonJF> dmj`: i had the same problem in another channel the other day
04:47:38 <ivanm> skypers: yeah, don't do that...
04:47:45 <ivanm> dmj`: maybe the bot is sleeping?
04:47:54 <klrr> is there anything similar like "x <- many1 (not "!")" from parsec that works in attoparsec?
04:47:55 <Cale> lingxiao: Does that make any sense? :)
04:47:55 <ivanm> preflex: seen lpaste
04:47:56 <preflex>  lpaste was last seen on #haskell 36 days, 23 hours, 39 minutes and 14 seconds ago, saying: henk pasted “diddohs” at http://lpaste.net/96371
04:48:00 <lingxiao> Cale: ah that makes sense. even in my short experience I've felt such tension of how finely i want to describe something. when i read good prorams with well designed data types, it looks like the the solutions just "tumble out"
04:48:03 <ivanm> klrr: I'm looking, hold your horses!
04:48:04 <skypers> I got something like that:
04:48:05 <ivanm> ;-)
04:48:07 <dmj`> here --> http://lpaste.net/98003
04:48:13 <ivanm> klrr: do you want a list back?
04:48:15 <skypers> filter (\s -> not $ s `elem` correctSections) . toList $ sections
04:48:22 <skypers> if that list is null
04:48:24 <dmj`> SimonJF: strange
04:48:25 <Cale> lingxiao: Yeah, and in languages like Agda, they even have code inference which works remarkably often
04:48:31 <skypers> then the document is wrong-sections-free
04:48:32 <lingxiao> which is not the case, but reading such programs, everything is just very compact and just "should be"
04:49:05 <Cale> lingxiao: You can specify a type, tell it to split up the cases for you automatically, and then mash a key and have it fill in the definition magically because there's only one function of the type you wanted and the compiler is smart enough to write it for you.
04:49:46 <klrr> ivanm: well, in my parsec code i got "n <- many1 (noneOf "!"); char '!'; ..." i want to translate it to parsec but i dont quite find a obvious way to do such a operation
04:49:51 <henk> ivanm: Was my code in that paste that bad that it broke the bot?
04:49:55 <klrr> to atooparsec*
04:50:00 <ivanm> henk: *shrug*
04:50:18 <ivanm> klrr: well, you could just use many1 (satisfy (/='!'))
04:50:44 <ivanm> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Combinator.html
04:50:55 <ivanm> klrr: what type are you parsing?
04:50:57 <klrr> ivanm: thanks!
04:51:30 <FliPPeh> I wonder, (and just for curiousity), have there been made efforts to typeclassify standard things like lists under a type class so that, for example, (:) :: List l => a -> l a -> l a?
04:51:32 <klrr> ivanm: im parsec my own type "data Prefix = Prefix Text Text Text"
04:51:36 <klrr> parsing*
04:51:39 <lingxiao> Cale: woa I guess I gotta read more about that, or play with it.
04:51:41 <ivanm> klrr: you could also try the notInClass if you actually have more than one character you don't want
04:51:51 <dmj`> I love this pattern matching thing w/ case statements
04:51:52 <ivanm> klrr: so the Text parser?
04:52:03 <ivanm> FliPPeh: see the ListLike package
04:52:11 <ivanm> it's not that popular though AFAIK
04:52:18 <dmj`> > case 5 of { x | x == 5 -> "5" | otherwise -> "..." }
04:52:20 <lambdabot>  "5"
04:52:33 <lingxiao> do you mean the data type is so restraining there's only one way to destructure it
04:52:34 <Cale> lingxiao: It's pretty cool. The language isn't very practical for writing desktop applications (yet?)
04:52:34 <klrr> ivanm: yes the Text one i use
04:52:44 <klrr> been told i should stay away from bytestring xD
04:53:10 <ivanm> klrr: right; so you could also do: many1 (notInClass "!")
04:53:14 <Cale> lingxiao: Well, and destructuring it determines additional things about what the result should be
04:53:15 <FliPPeh> Because one of the more recurring pains I have had in Haskell was dealing with all the list like things like Vector, ByteString, ... that all ACT like lists and all individually implement the usual takeWhile, filter, ...
04:53:27 <FliPPeh> So the type class thing seems like a bonus for everyone
04:53:36 <Cale> lingxiao: The thing about dependent types is that the type of the result of a function can depend in some way on the *value* of the argument
04:53:59 <Okasu> Cale: There is Idris which has same(maybe a bit less powerfull) code inference features and it feels more practical.
04:54:00 <klrr> ivanm: okey, thanks for all help!
04:54:01 <Cale> lingxiao: So when you take the argument apart by cases, you discover some things about the type of the result
04:54:10 <ivanm> klrr: if you want a result of type Text rather than a list, use takeWhile (notInClass "!")
04:54:13 <Cale> Okasu: Yes, I was also going to mention Idris and Coq
04:54:15 <Okasu> It(code inference) was added recently.
04:54:26 * ivanm couldn't remember attoparsec's name for polyparse's many1Satisfy
04:54:33 <Okasu> With Emacs and Vim support.
04:54:58 <Cale> lingxiao: and often (more often than what would happen if you tried this with Haskell), this helps uniquely determine what the result should be
04:55:18 <Cale> Or at least restrict it in some way that lets the compiler fill it in partially.
04:55:53 <funfunctor> :t splitAt
04:55:54 <lambdabot> Int -> [a] -> ([a], [a])
04:56:27 <Okasu> lingxiao: http://vimeo.com/77168227 It'll give you some taste of agda programming.
04:56:43 <Cale> lingxiao: In Haskell, whenever you have an if/then/else expression, you could always swap the two branches of the conditional, and the code would still typecheck
04:56:52 <Cale> lingxiao: That's not true in dependently typed languages
04:57:15 <Cale> The type of the result can depend on the outcome of the conditional in such a way that you can't swap them :)
04:57:19 <funfunctor> how can I use splitAt to split a list in the middle then check the two lists are equal after reversing the second one? (I realise there is two edge cases)
04:58:07 <ivanm> funfunctor: palindrome check?
04:58:09 <bennofs> funfunctor: Do you want to check if a given list is a palindrome?
04:58:25 <Cale> xs == reverse xs  is a nicer way to check
04:58:42 <lingxiao> Cale: that is really cool, I'll take a look at the video, and maybe come back with better questions :)
04:58:56 <lingxiao> not bad for a sunday morning :)
04:58:59 <Okasu> Cale: Well, there is no built-in if then else thing in Agda, but you can define it in a way you want like "if_then_else : {A : Set} → Bool → A → A → A"
04:59:30 <Okasu> With or without posibility of branch swapping. :)
04:59:47 <Cale> Okasu: I mean, you can do better though:  if_then_else : {A : Set} -> (x : Bool) -> A True -> A False -> A x
04:59:57 <dmj`> what are the main differences between agda and idris?
05:00:07 <lingxiao> I guess some types can only be inhabited by certain values, and that information is encoded in agda
05:00:23 <dmj`> are they both dependently typed and eagerly evaluated
05:00:29 <funfunctor> ivanm: bennofs yes exactly
05:00:31 <Cale> dmj`: yes
05:00:39 <bennofs> > let isPalindrome = reverse >>= (==) in map isPalindrome ["abcdefedcba", "adad"]
05:00:41 <lambdabot>  [True,False]
05:00:46 <ivanm> funfunctor: Cale's solution is the nicest
05:00:53 <ivanm> funfunctor: just to be clear though, is this homework?
05:01:11 <bennofs> Aw, compiling yi takes ages
05:01:13 <funfunctor> no no, I don't do CS at `school`
05:01:17 <Cale> The main big difference is that Idris is trying to be relevant for people who are writing desktop applications and programs you actually run.
05:01:34 <Cale> Agda has some capacity for that
05:01:45 <funfunctor> I'm trying to refresh my memory of the prelude/syntax of Haskell by doing Euler problems..
05:01:49 <Cale> but it's mainly aimed at people trying to do constructive mathematics with a computer
05:01:51 <ivanm> funfunctor: OK then; if you want to do your solution, then the brief outline is:
05:01:55 <funfunctor> prelude is big
05:02:17 * hackagebot threads 0.5.1.0 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.1.0 (BasVanDijk)
05:02:33 <ivanm> 1) Find the length of the list; 2) split it correctly (deal with the odd/even cases differently); 3) reverse the second list; 4) check equality
05:02:33 <Cale> Similarly for Coq
05:02:35 <funfunctor> I was _thinking_ along these lines isPalindromic x | (even . length . digs) x = splitAt (((length . digs) x)/2) x == 3
05:02:47 <Cale> You can write real programs with Coq, but mostly it's aimed at theorem proving.
05:03:01 <ivanm> funfunctor: I don't know what digs is, but you probably don't want to be re-calculating the length each time
05:03:08 <ivanm> use a where clause to save the length of the list
05:03:22 <ivanm> and / won't work for Ints
05:03:26 <ivanm> @type (/)
05:03:27 <lambdabot> Fractional a => a -> a -> a
05:03:27 <funfunctor> yea it was starting to get very 'hacky' so I thought I should ask..
05:03:29 <Cale> (There is a verified C compiler written in Coq, with a proof that the programs it emits have the same meaning as the programs it compiles)
05:03:36 <ivanm> @type div -- for funfunctor
05:03:36 <lambdabot> Integral a => a -> a -> a
05:03:42 <ivanm> > 5 `div` 2
05:03:43 <lambdabot>  2
05:03:55 <ivanm> ^^ rounds towards zero
05:04:01 <ivanm> (which is what you want!)
05:04:44 <Cale> http://compcert.inria.fr/doc/
05:04:53 <Okasu> Coq has really cool feature named "Extraction" which allows you to extract programms writen in coq to Scheme/OCaml/Haskell. That one is really cool.
05:04:55 <funfunctor> ah `div` yea, see prelude always screwing me.. C's type-system is such a joke its hard to learn doing typeing so rigously each time you have a idea
05:05:28 <Cale> Yeah, it's perhaps not as practical to really use as one might hope, from what I understand, but it's possible at least :)
05:05:30 <aleksejs_> Why does this fail? notIn = not . elem
05:05:55 <Cale> aleksejs_: because when you apply elem to some argument x, you get a function
05:06:04 <Cale> aleksejs_: and then applying not to that function is a type error
05:06:23 <Cale> aleksejs_: So what you want to do is compose not with that resulting function
05:06:33 <Cale> You could write  notIn = (not .) . elem
05:06:43 <dmj`> or `notElem`
05:06:45 <Cale> But it's probably clearer to provide an argument:
05:06:54 <Athas> Is there a ghci flag for limiting the amount of heap space it's permitted to use?
05:07:01 <Cale> (or yes, use the one in the Prelude ;)
05:07:10 <dmj`> :)
05:07:15 <Cale> notIn x = not . elem x
05:07:26 <Cale> notIn x xs = not (elem x xs)
05:07:39 <aleksejs_> notIn = (not .) . elem << this also fails
05:07:42 <bennofs> Athas: I think you can do something with +RTS -someflag, try +RTS -h and look if there is some option
05:07:53 <aleksejs_> notIn x = not . elem x << works
05:08:01 <Cale> :t let notIn = (not .) . elem in notIn
05:08:02 <lambdabot> Eq a => a -> [a] -> Bool
05:08:06 <Cale> ^^ are you sure?
05:08:26 <dmj`> Athas: "eg. to increase the maximum heap size for a compilation to 128M, you would add +RTS -M128m -RTS to the command line."
05:08:29 <dmj`> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
05:08:38 <aleksejs_> > let notIn = (not .) . elem
05:08:38 <aleksejs_> > notIn 1 [1,2,3]
05:08:38 <aleksejs_> <interactive>:135:7:
05:08:38 <aleksejs_>     No instance for (Num ())
05:08:38 <aleksejs_>       arising from the literal `1'
05:08:39 <lambdabot>  not an expression: `let notIn = (not .) . elem'
05:08:39 <lambdabot>  can't find file: L.hs
05:08:46 <Cale> oh
05:08:52 <Cale> Okay, that's a different problem :)
05:08:55 <Athas> dmj`: thanks.  (Wow, that must be old documentation - I doubt GHC can compile anything with less than 128MiB of heap!)
05:09:02 <Cale> GHCi aggressively defaults the types of things
05:10:13 <Cale> and you stepped right into the monomorphism restriction, which applies to pattern bindings (i.e. not function bindings, the sort which have no explicit arguments), of type class polymorphic things which don't have explicit type signatures
05:11:29 <klrr> is attoparsec's try combinator the same as parsec's optional?
05:11:31 <Cale> Haskell 98 says that such bindings can't be polymorphic, and defaulting will apply to them to attempt to resolve that. Normally in this case, that would result in an error, because there's no Num constraint to try to default the thing to a sort of number (defaulting exists because numeric literals are polymorphic)
05:11:52 <Cale> But GHCi is super aggressive and will try to default types of things to ()
05:11:56 <dmj`> parsec has try
05:12:06 <Cale> because when you type something like  Nothing  at the GHCi prompt
05:12:18 <Cale> You don't want to get an error about how it can't infer which type of Maybe you wanted
05:12:38 <Cale> The monomorphism restriction itself is a silly rule
05:13:01 <Cale> which was put in place because when things are type class polymorphic, they are actually secretly implemented by functions
05:13:33 <Cale> (functions which take the dictionary of the type class methods as a parameter)
05:13:43 <aleksejs_> hmm, I think this is a thing to study for me, thanks for explanation
05:13:48 <Cale> and so when you have a binding which looks like it defines a constant
05:13:57 <Cale> then some people don't like it to be evaluated more than once
05:14:05 <aleksejs_> and you were right: it works in .hs, not in ghci
05:14:15 <Cale> But if it's type class polymorphic, it's really a function, and it will be evaluated more than once
05:14:37 <Cale> If you give it an explicit type signature, it will work
05:14:54 <Cale> Or if you add {-# LANGUAGE NoMonomorphismRestriction #-}
05:15:08 <Cale> Or in GHCi, you can :set -XNoMonomorphismRestriction
05:15:13 <Cale> (I believe you can tab complete that)
05:15:31 <aleksejs_> it's better to put it inh ghci config
05:15:34 <Cale> yeah
05:15:44 <Cale> though you have to remember that it's there sometimes ;)
05:15:46 <dmj`> is 7.8 close?
05:16:04 <sipa> :set -XNoMonoMorphismRestriction
05:16:38 <Cale> sipa: I'm pretty sure the second M is lowercase
05:17:31 <sipa> i suppose lambdabot doesn't accept :set either?
05:17:36 <Cale> But yeah, this is something which should in my opinion have been a *warning* but the language spec defined it as an error.
05:17:49 <Cale> Right, it doesn't
05:17:52 <mirpa> dmj`: Why? Is there someting interesting in 7.8?
05:18:12 <mirpa> *something
05:19:15 <dmj`> mirpa: I read a paper about a new I/O manager and heard it would be in 7.8
05:19:44 <Cale> Well, I'm presenting it *somewhat* onesidedly... there are some benefits to the monomorphism restriction for certain kinds of code where numeric types would be ambiguous, and the MR helps them get defaulted correctly without explicit type signatures.
05:20:08 <Cale> But for every one of those, there are 10 or 20 cases where it's horribly obnoxious
05:20:09 <dmj`> wanted to see if it would make snap-server handle more requests
05:22:06 <adimit> there are lots of interesting things in 7.8. I'm waiting for a mundane thing though: :complete support.
05:22:25 <klrr> maybeResult returns Nothing if the parser fails?
05:22:39 <klrr> in attoparsec that is
05:22:47 <mirpa> dmj`: Mio? Hi-perf paralel IO manager?
05:22:55 <Cale> At one point, before forM was in Control.Monad, I once wrote a piece of code which used the ST monad to do some rather imperative sort of computation, and I somewhat frivolously wrote  forM = flip mapM  and proceeded to use it in my ST code in a couple places
05:23:20 <srhb> klrr: Or if the parser is not done yet.
05:23:51 <dmj`> mirpa: yea
05:23:54 <Cale> I spent like 45 minutes figuring out why the hell my ST computation wouldn't get through runST because its type was something like ST () t
05:23:55 <klrr> srhb: okey
05:23:58 <klrr> thanks
05:24:20 <Cale> before I realised that it was the monomorphism restriction applying to my definition of forM :)
05:24:47 <Aetherspawn> Oh boy!
05:24:48 <hpc> Cale: you would like acme-php ;)
05:24:52 <Aetherspawn> I always needed something like this
05:24:53 <Aetherspawn> http://hackage.haskell.org/package/plumbers-0.0.2/docs/Control-Plumbers-Monad.html
05:24:57 <ivanm> Cale: yay :s
05:25:29 <bennofs> Aetherspawn: that thing is missing an acme prefix
05:25:39 <Aetherspawn> ^
05:25:40 <Aetherspawn> that
05:25:42 <Aetherspawn> rofl
05:26:02 <hpc> what the shit, that's even worse than lens
05:26:16 <Aetherspawn> I hope that was generated with a script
05:26:20 <Cale> hpc: ahaha
05:26:22 <Aetherspawn> and someone didn't manually write like 400 functions
05:26:30 <Cale> instance Floating String where
05:26:31 <Cale>   pi = "3.14"
05:27:14 <ivanm> heh
05:27:19 <bennofs> does that also define instance Num String where (+) = (++); a - b = show $ read a - read b; ... ?
05:27:54 <hpc> Cale: somewhere in there i demonstrate a rather large wtf in how imports work; see if you can find it...
05:27:56 <ivanm> bennofs: though + isn't reliable in that definition...
05:28:02 <shlevy> join yesod
05:28:05 <shlevy> whoops
05:28:45 <shlevy> (asking here and in #yesod): Can Persistent be applied to existing data types?
05:28:57 <mirpa> Aetherspawn: someone use that? Looks like brainfuck.
05:29:06 <Aetherspawn> I hope not.
05:29:15 <Aetherspawn> going to ask once more before I go to sleep
05:29:22 <Aetherspawn> anyone with some c2hs-fu please: http://stackoverflow.com/questions/20931099/using-c2hs-to-marshal-a-void
05:29:40 <Komier> :t Maybe
05:29:41 <lambdabot> Not in scope: data constructor `Maybe'
05:29:54 <Cale> :k Maybe
05:29:55 <lambdabot> * -> *
05:30:10 <Cale> (Maybe is a type level thing, so rather than a type, it has a kind)
05:30:23 <Aetherspawn> kinds are types of types
05:30:23 <Komier> ah ok ty Cale
05:30:27 <Aetherspawn> :P
05:30:29 <hpc> shlevy: you can write your own instances, yes
05:30:34 <Komier> so it's not a type it's a type of type?
05:30:35 <Cale> Aetherspawn: hmm
05:30:39 <Aetherspawn> Are type families types of kinds?
05:30:40 <Aetherspawn> <.<
05:30:59 <shlevy> hpc: Which typeclass?
05:31:05 <Aetherspawn> You can probably express all this using differentiation
05:31:15 <Cale> Aetherspawn: It's been literally about a decade since I last used c2hs myself, so let me see if I can remember anything about it :)
05:31:25 <Aetherspawn> ooh goodie :)
05:31:33 <hpc> shlevy: PersistField is the class for Bool, Int, etc
05:31:41 <hpc> shlevy: PersistEntity is the backend that you save to
05:31:57 <hpc> shlevy: and it looks like the classes at the top of the haddock just deal with which monad you happen to be in
05:32:00 <hpc> http://hackage.haskell.org/package/persistent-1.3.0/docs/Database-Persist-Class.html
05:32:17 <Aetherspawn> I would have thougth my problem kind of something that you're supposed to cover in the docs in huge bold letters
05:32:25 <Aetherspawn> lets be honest, C is C, and half the stuff returns void*
05:32:35 <Aetherspawn> But the c2hs docs are rubbish imho.
05:33:03 <Cale> Where *are* the c2hs docs?
05:33:06 <shlevy> hpc: thanks! Hmm now to figure out how to represent relations...
05:33:11 <Aetherspawn> uh, somewhere
05:33:11 <Cale> I can't find the ones I remember reading
05:33:33 <Aetherspawn> I got it through edwardk's blog
05:33:34 <Cale> and Manuel's page redirects to github for some reason
05:34:11 <Aetherspawn> theres some here http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html
05:34:35 <Cale> okay, that's vaguely familiar
05:34:37 <Aetherspawn> it does talk about pointers, but only marshalling structs and stuff
05:34:56 <Aetherspawn> You can't just do *void because its a primitive type
05:35:08 <Aetherspawn> and everything else like wrapping it in an empty struct or something, is kind of a hack
05:35:35 <Cale> You don't want c2hs to be doing anything here
05:35:55 <Aetherspawn> hm?
05:35:59 <Aetherspawn> oh dear the splits
05:36:05 <Cale> There was some way to tell it that you want to use the identity function
05:36:27 <shlevy> How can I look at the code a TemplateHaskell function generates?
05:36:34 <bennofs> shlevy: -ddump-splices
05:36:39 <shlevy> bennofs: thanks
05:36:42 <klrr> given parser X with type Parser Y can i somehow make it return Just Y in case of success and Nothing if it fails?
05:37:25 <hpc> klrr: yes; you'll likely be writing it yourself though
05:37:30 <Cale> klrr: optionMaybe
05:37:35 <hpc> oh, or that
05:37:42 <Cale> Possibly in conjunction with try
05:38:02 <hpc> klrr: i recommend doing Either something Y, just so you can print a nicer parse error or something like that
05:38:08 <Aetherspawn> I can't find anything documenting it
05:38:22 <klrr> im using attoparsec here so i dont have optionMaybe
05:38:56 <klrr> hpc: well, if it fails i dont want a error, i want nada since it parsing a optional "thing"
05:39:24 <hpc> klrr: ah; somehow i read that as you wanting Maybe Y out of runParser or something
05:39:39 <Aetherspawn> I guess I could just buggerit and return an int.
05:39:39 <hpc> optionMaybe p       = option Nothing (liftM Just p) -- here's parsec's version
05:39:41 <Cale> Aetherspawn: there used to be documentation that was produced with docbook or something
05:40:01 <vektor> so me and cabal. yeah. damn it just doesn't seem to work as I expect. There's always some error, and I kinda believe the cause is me.
05:40:13 <Cale> Aetherspawn: What happens if you don't `Ptr ()' but just write Ptr ()
05:40:23 <Aetherspawn> I'll try.
05:40:28 <vektor> $ cabal install ncurses
05:40:56 <vektor> cabal: The program c2hs version >= 0.15 couldn't be found, but is required.
05:41:08 <Cale> vektor: cabal install c2hs
05:41:32 <shlevy> If I use semver to version my packages, will that clash with idiomatic package versioning?
05:41:34 <hpc> vektor: and once you install c2hs you will need to copy the binary onto your path or add its location to your path
05:41:35 <vektor> seriously? why doesn't cabal do that stuff for me in the first place? is that too much to ask from a package manager?
05:41:43 <Cale> vektor: (and make sure that ~/.cabal/bin is in your $PATH
05:41:44 <Cale> )
05:41:51 <hpc> vektor: cabal isn't really a package manager, it's more of a build system
05:41:56 <hpc> vektor: but yes, i agree it's quite silly
05:41:58 <Cale> It won't install executable programs for you
05:42:01 <shlevy> e.g. cabal init by default uses 0.1.0.0 but semver only has x.y.z
05:42:07 <Cale> Only libraries
05:42:11 <hpc> only zuul
05:42:18 <Aetherspawn> Cale: parse error
05:42:24 <Cale> Aetherspawn: okay
05:42:38 <vektor> now cabal requires alex as well to install c2hs
05:42:40 <Cale> Aetherspawn: let me see if I can use the wayback machine
05:42:52 <Aetherspawn> heh
05:43:48 <vektor> so what's that about installing the programs I just cabal'd?
05:44:00 <Cale> https://web.archive.org/web/20040625000520/http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs.html
05:44:49 <Cale> hmm, this might be pretty similar to the newer stuff
05:44:53 <vektor> cabal installed the executable to ~/.cabal/bin . Where does it need to go?
05:45:03 <vektor> alex executable that is
05:45:06 <hpc> vektor: it just needs to go somewhere on your path
05:45:13 <vektor> that is?
05:45:31 <hpc> the simplest way is to just add ~/.cabal/bin to your path
05:45:41 <Aetherspawn> cheers, lets take a look
05:45:44 <hpc> which on my system is the environment variable PATH
05:45:48 <hpc> colon-separated
05:46:00 <Cale> oh
05:46:14 <Cale> Aetherspawn: What if you use  id `Ptr ()' id
05:46:33 <Aetherspawn> isn't Ptr () boxed?
05:46:41 <Aetherspawn> I'm unsure how that's going to turn out, but I'll try.
05:46:51 <Aetherspawn> Addr# might be better
05:46:54 <Cale> The point is that you don't want to do anything
05:47:04 <Cale> The FFI already takes care of this
05:47:13 <Cale> c2hs doesn't need to do anything extra here
05:48:21 <augur> how very strange
05:48:26 <Aetherspawn> Hmm, ok
05:48:29 <Aetherspawn> it works
05:48:39 <Aetherspawn> a few errors not related to C2hs I can fix I think
05:48:45 <klrr> basically, i want attoparsec to perform the parser prefix, if it fails it turns it consumed input back and return Nothing , if it succeed i want it to return Just x, im trying to do it like this but get type errors "option Nothing $ fmap Just $ try prefix" any ideas? full code and type errors here https://gist.github.com/klrr/8268390
05:48:47 <Cale> cool
05:48:51 <Aetherspawn> thanks :)
05:49:32 <klrr> that is i want "Maybe Text" but got "Maybe (Maybe a0)"
05:49:39 <vektor> so I do "sudo nano /etc/profile" and add ":~/.cabal/bin" to the line "PATH= ...."
05:49:41 <vektor> ight?
05:49:46 <vektor> *right
05:50:01 <mauke> what, globally?!
05:50:33 <vektor> what's wrong with that?
05:50:45 <klrr> wait i got it to compile nvm :)
05:51:02 <vektor> I wouldn't need to reconfigure it if I ever decided another user account would be in order.
05:51:07 <Cale> klrr: Yeah, I was trying to figure out what could possibly be wrong with the code you had there
05:51:15 <vektor> just'd need to rebuild the packages
05:51:20 <Cale> klrr: I'd have used more . and less $, but other than that it's fine :)
05:52:34 <augur> ok
05:52:34 <Cale> vektor: Another option is to just replace ~/.cabal/bin with a symlink to ~/bin. Yet another is to adjust ~/.cabal/config so that it places the executables in ~/bin or something
05:52:38 <augur> deep interesting question here
05:52:41 <augur> main = go where go = putStr "foo" >> getLine >> go
05:52:48 <augur> why does this never doo anything
05:53:06 <Cale> augur: buffering
05:53:13 <augur> Cale: elaborate?
05:53:20 <Cale> hSetBuffering stdout NoBuffering
05:53:29 <Aetherspawn> yay it works
05:53:32 <Aetherspawn> I think
05:53:32 <augur> elaborate more? :)
05:53:34 <mauke> Cale: noooo :-(
05:53:36 <Aetherspawn> not tested runtime yet
05:53:41 <Cale> no?
05:53:46 <mauke> never NoBuffering
05:53:48 <kqr> augur, it should do stuff when you press return
05:54:00 <augur> kqr: it does nothing!
05:54:04 <mauke> augur: http://perl.plover.com/FAQs/Buffering.html
05:54:12 <Cale> The default iirc is LineBuffering which means that you don't see any output until a newline happens
05:54:14 <mauke> augur: perl specific but the problem it describes is more general
05:54:40 <kqr> Cale, could it really be buffering problems if it does nothing when he presses return?
05:54:42 <augur> i see, so the problem is not haskell IO but rather terminal behavior?
05:54:42 <Cale> augur: another option is to explicitly flush
05:54:45 <mauke> kqr: yes
05:54:49 <mauke> augur: no
05:54:52 <augur> oh?
05:54:54 <Cale> Wait, what?
05:54:58 <mauke> Cale: NoBuffering is horribly inefficient
05:55:03 <Cale> mauke: Who cares?
05:55:06 <mauke> I do
05:55:07 <klrr> Cale: where  exactly did i use too much $? always want to write as good code as possible :)
05:55:09 <Cale> It's an interactive program
05:55:14 <Cale> It can be inefficient :)
05:55:29 <mauke> still no reason to do a write() for every single character
05:55:36 <kqr> klrr, probably something along the lines of f $ g $ h $ x which could be f . g . h $ x
05:55:36 <Cale> klrr: I tend to prefer  f . g . h $ x  to  f $ g $ h $ x
05:55:37 <augur> mauke: its a haskell-specific choice that relates to terminals?
05:55:40 <mauke> augur: no
05:55:50 <Cale> klrr: f . g . h means something on its own
05:55:56 <augur> mauke: then what is it! dont make me read this long as thing, tell me!
05:55:58 <mauke> augur: it's a feature of I/O libraries in all languages I know
05:56:01 <Cale> klrr: while f $ g $ h will be a type error
05:56:07 <mauke> augur: also, fuck you
05:56:11 <augur> :(
05:56:17 <augur> no sense of humor, some people
05:56:23 <augur> but its still terminal-related IO
05:56:31 <Cale> Can we please be polite to each other?
05:56:48 <Cale> augur: Pretty much
05:56:56 <shlevy> I want to represent a user name, but can't decide whether to newtype String or Text. How do I decide?
05:57:11 <klrr> Cale: i know the difference of them i just didnt know f . g $ h x was prefered over f $ g $ h x
05:57:14 <klrr> thanks
05:57:20 <augur> using putStrLn makes it play nice
05:58:04 <Cale> klrr: Well, different people have different preferences, but I personally prefer (.) where I can get it because (.) is associative, visually a bit quieter, and that associativity helps a bit when refactoring things.
05:58:34 <JuanDaugherty> over 1200, 2X since I first began to frequent in '05/06
05:58:41 <Cale> Also, once you start doing that, it changes the way you think about functions a little bit, even though it seems trivial. :)
05:59:20 <Cale> augur: yeah, that's because of LineBuffering
05:59:28 <augur> hmm hmm
05:59:51 <Cale> augur: If you're just writing a program for the user to interact with, and don't give a shit about efficiency (as I suspect is the case)
06:00:13 <mauke> efficiency and debuggability
06:00:16 <augur> yes, im just writing something to do terminal interaction
06:00:19 <mauke> because it will wreck strace output
06:00:28 <Cale> Then the easiest way to solve the issue is just to  import System.IO  and  hSetBuffering stdout NoBuffering
06:00:37 <mr-> augur: you might want to look at haskeline, though
06:00:58 <augur> Cale: where would i do that?
06:01:04 <srhb> Just throw newlines when you need it, or flush manually, rather than setting NoBuffering
06:01:06 <Cale> augur: at the start of main
06:01:09 <augur> ok
06:01:12 <mauke> Cale: I'd use putStr' s = putStr s >> hFlush stdout instead
06:01:21 <mauke> or maybe a better name
06:01:25 <Cale> Yeah, that works too
06:01:35 <augur> i like mauke's solution better
06:01:45 <srhb> That's because it's better. :-)
06:01:58 <mauke> that's because it's what perl does ω̈
06:02:24 <srhb> NoBuffering on stdin is one thing, on stdout, eeek.
06:02:30 <augur> srhb: and also because it does what i want: putStr' puts the string now, damnit
06:02:40 <augur> ooo alas it doesnt!
06:02:54 <skypers> I friend just told me he thought Haskell was a brainfuck’s variant
06:02:55 <augur> how interesting
06:03:02 <srhb> skypers: OK.
06:03:30 <Cale> skypers: Tell him it's actually a variant of Befunge
06:03:30 <augur> ahh wait
06:03:50 <mr-> skypers: I guess there are some similarities. Both have got quite "small" syntax..
06:04:42 <skypers> Cale: I don’t like that way
06:04:56 <Cale> skypers: wat
06:05:07 <skypers> “lol Haskell sucks” “lol it seems to be a brainfuck new language“
06:05:20 <skypers> “lol no famous programs written in Haskell exist”
06:05:21 <augur> thank you, mauke, this helps a great deal :)
06:05:22 <augur> <3
06:05:42 <Cale> skypers: Help Haskell to avoid success at all costs pls.
06:05:49 <skypers> why?
06:05:51 <skypers> because of that?
06:06:00 <skypers> that kind of reaction?
06:06:03 <maurer> Cale: I'd disagree. You do that, and we end up like ocaml in a year or two :P
06:06:04 <Cale> It is our secret weapon :D
06:06:15 <augur> ahhhh this is nice. :D
06:06:15 <skypers> what’s about ocmal?
06:06:21 <Cale> maurer: Well, if we do, then we deserve to :)
06:06:37 <maurer> Dying compiler support, community that only writes libraries when jane street pays them to do so
06:06:41 <augur> ok, now that i feel like i understand what im doing, im going to not do.
06:06:51 <skypers> maurer: woh
06:07:05 <skypers> so you think Haskell should be famous
06:07:17 <Cale> maurer: Part of that is that a lot of the OCaml people are now doing Haskell, I think
06:07:19 <skypers> I actually think it’s better that way, not famous
06:07:21 <maurer> skypers: Not necessarily, but I don't think that obsurity is a good tactic
06:07:34 <Cale> If people end up moving along to the next functional programming language, I think that's okay
06:07:44 <skypers> maurer: the problem up to now in my friends circle is that all of them think Haskell is a toy
06:07:58 <maurer> skypers: I mean, I am part of a lab group that programs primarily in ocaml
06:08:05 <maurer> So I constantly feel like I'm using 1980s tech
06:08:14 <maurer> While knowing I have a better option
06:08:15 <Cale> Languages which are super-popular also end up sucking for other reasons. Primarily that they can't change.
06:08:19 <skypers> maurer: you mean Haskell? :)
06:08:27 <maurer> skypers: Haskell has actually evolved
06:08:33 <maurer> skypers: For example, in haskell, you can have threads
06:08:38 <maurer> There are no threads in ocaml
06:08:38 <skypers> maurer: it’s always evolving :)
06:08:45 <skypers> you can’t in ocaml?
06:08:45 <maurer> skypers: Sure, but ocaml isn't
06:08:49 <maurer> Correct
06:08:53 <maurer> ocaml currently has no threading
06:09:03 <skypers> woh
06:09:04 <maurer> if you want parallel stuff, you fork, and then roll your own communication protocol
06:09:06 <skypers> I didn’t know that
06:09:35 <Cale> Haskell can evolve rapidly because it doesn't have the kind of user-base that Java does. If you have a huge user-base, and you try to make changes to the language, you end up in a quagmire of people complaining that you're breaking everything.
06:09:39 <maurer> There are lots of other random stuff too, like TH being nicer than CamlP4, polymorphic comparison being the slowest thing on the planet in ocaml, etc
06:09:53 <maurer> Cale: I agree that we don't want java's userbase
06:09:59 <maurer> Cale: I disagree that we want to be obscure :P
06:10:24 <Cale> I'm always happy to help individual people learn Haskell, but I also don't want to actively go around promoting it.
06:10:37 <skypers> Cale: yeah
06:10:57 <skypers> let’s family grow but avoid massive groups
06:11:00 <maurer> Cale: So, we want to be legit enough that when some guy says to his boss "Hey, I think I can build this thing better in haskell"
06:11:06 <maurer> he doesn't respond with "wtf?"
06:11:14 <Cale> yes, probably
06:11:26 <maurer> I feel that we have not yet reached this point in terms of public image
06:11:32 <skypers> maurer: so far, it’s impossible in France
06:11:34 <Cale> I don't know about that
06:11:35 <maurer> (fpcomplete may help some there)
06:11:38 <Cale> There's work :)
06:11:38 <skypers> they’d laugh at me
06:11:46 <Cale> Actually I think FPComplete is going too far.
06:11:55 <maurer> Oh?
06:12:02 <Cale> If I didn't know Haskell, some of the things which I've seen from FP Complete would turn me off of it.
06:12:11 <maurer> Any examples?
06:12:15 <Cale> They're full of marketing speak :)
06:12:26 <maurer> I am not using it because pay-for-git-push means I can't really try it for dev before buying
06:12:27 <Cale> Well, I dunno, their front page has improved
06:12:50 <maurer> (if it turned out to be convenient, I might be willing to buy the 10/mo version)
06:13:09 <mauke> what is fpcomplete?
06:13:44 <maurer> mauke: It is a company that built a browser based haskell ide
06:13:49 <merijn> Cale: Well, maybe something that doesn't appeal to existing haskellers is exactly what's lacking in terms of getting more converts
06:13:57 <Cale> At least when you go there now, they're more about "let's learn Haskell" moreso than "Haskell is awesome"
06:14:01 <maurer> mauke: Combined with some git integration and the ability to deploy some webapps to servers they run
06:14:18 <maurer> mauke: They also have some haskell teaching/training programs, but I haven't looked at those at all
06:14:18 <mauke> wtf, why would I want to code in a browser
06:14:24 <Cale> merijn: My point is I think we're growing naturally at a rate which is perfectly acceptable
06:14:29 <Cale> and doesn't need acceleration
06:14:38 <maurer> mauke: So you don't have to manage your software stack would be the first thing
06:14:45 <Clint> so you can livetweet all your code
06:14:46 <skypers> when I see reactions to Haskell
06:14:50 <skypers> I prefer us to be discrete
06:14:53 <skypers> but effective
06:14:54 <mauke> maurer: "software stack"? as in vim?
06:14:59 <vektor> back. still not quite working. cabal install c2hs still doesn't find alex.
06:15:11 <maurer> mauke: No, as in ghc + platform + exact versions of libraries such that your dependencies work out :P
06:15:15 <ion> I for one am a discrete person.
06:15:17 <Cale> There are aspects of how Haskell is developing now which make me think that in a couple years I won't actually be programming in it.
06:15:21 <maurer> mauke: cabal can be quite fussy
06:15:22 <merijn> mauke: All the people messing up their platform install because of sucky linux package managers :)
06:15:36 <maurer> mauke: They also have a more complete  hoogle than the standard one
06:15:37 <Cale> (Probably something dependently typed will have overtaken it)
06:15:39 <srhb> Cale: I suppose that depends if a better alternative materializes. :P
06:15:43 <Cale> Yeah
06:15:43 <skypers> 15:10 < Cale> There are aspects of how Haskell is developing now which make me think that  in a couple years I won't actually be programming in it.
06:15:46 <skypers> why?
06:15:48 <srhb> But the lack of libraries, scary.
06:16:07 <Cale> Because the core language is hard to change now, and has been for some time
06:16:18 <skypers> 2010
06:16:20 <Cale> There's a lot of code, and it's hard to make the language better because of that.
06:16:21 <skypers> it’s quite young
06:16:21 <vektor> what changes do you think would have to be made?
06:16:28 <Cale> skypers: 2010?
06:16:33 <skypers> Haskell2010
06:16:34 <Cale> Haskell's been around since 1990
06:16:40 <skypers> yeah sure
06:16:45 <skypers> so let’s talk about C
06:16:46 <skypers> or C++
06:16:49 <srhb> No...
06:16:53 <FliPPeh> Whatever happened to Haskell Prime I wonder?
06:16:55 <skypers> I think we are in a good mood :)
06:16:57 <Cale> Well, Haskell98 was the last standard which actually mattered
06:17:14 <Cale> Haskell 2010 didn't really do much at all
06:17:27 <vektor> what changes would have to be made to the language?
06:17:31 <Taneb> Cale, Haskell2010 officially removed n+k patterns and added the FFI
06:17:36 <vektor> couldn't one write a converter to port all the old code?
06:17:40 <Cale> But the standard doesn't matter, it's what GHC does that matters at this point.
06:17:40 <Taneb> Which I guess is sooomethiiiing
06:17:52 <Cale> Taneb: Well, it merged the official FFI addendum into the standard
06:17:56 <Cale> (woo!)
06:18:05 <FliPPeh> I'd like a Haskell version push that worked like Python 3, do a reset and break some compatibility for the sake of fixing past mistakes like Monads not being required to be Applicative, the likes of that
06:18:13 <FliPPeh> Clean up the duplicated functions
06:18:19 <FliPPeh> liftM, fmap, ..
06:18:24 <dv-> nicer record update syntax
06:18:28 <FliPPeh> ^
06:18:34 <skypers> dv-: +1
06:18:45 <Cale> vektor: There are deeper changes which I think are pretty important and which are not easy. Basically, dependently typed languages are *really* cool.
06:19:12 <vektor> what is dependent typing?
06:19:16 <PTBD> hello. If I have a function written using foldl is there some kind of formula or easy wat to transfer it using foldr?
06:19:21 <Cale> Types which can depend on values
06:19:34 <Cale> In Haskell, we have types which depend on types
06:19:36 <augur> vektor: dependent types are types which can make reference to, and rely on, values
06:20:00 <mauke> PTBD: what are you trying to achieve?
06:20:31 <PTBD> mauke, i wrote this using foldl http://pastie.org/8603601
06:20:37 <Cale> vektor: You can have functions for which the type of the result (and thus the properties it's required to satisfy) depend on the value of the parameter to the function.
06:20:45 <mauke> PTBD: why?
06:20:46 <PTBD> now I'm wondering what I have to change when I want to use foldr
06:20:56 <PTBD> mauke, learning purpose
06:20:59 <Cale> vektor: That lets you express way more things about what the functions actually accomplish
06:21:04 <augur> PTBD: a few style notes: you can just write p x instead of ((p) x)
06:21:07 <vektor> Cale: so for example stronly typed tuples with kinda dynamic length?
06:21:09 <FliPPeh> Isn't foldr just foldl with arguments switched?
06:21:14 <Cale> vektor: For sure
06:21:15 <mauke> PTBD: change \acc x to \x acc
06:21:18 <FliPPeh> At the interface at least
06:21:18 <augur> FliPPeh: yes and no
06:21:25 <FliPPeh> I know it works differently underneath
06:21:30 <PTBD> mauke, and that's it?
06:21:35 <FliPPeh> But for the user it's just switched args basically
06:21:42 <augur> PTBD: in this case its simple because && and True form a monoid
06:21:54 <augur> a commutative monoid, rather
06:22:00 <PTBD> if I'm not mistaking I got an error when I switched, hold on
06:22:02 <augur> PTBD: in general, no, it's not that simple
06:22:17 <Cale> vektor: and  append :: Vec A n -> Vec A m -> Vec A (n + m)
06:22:17 <vektor> anyway, back to my cabal issue. cabal install c2hs still doesn't find alex, even though alex is installed, and the build dir ("~/.cabal/bin") is in PATH.
06:22:33 <augur> vektor: a goodexample of dependent types are, ironically, what are called vectors!
06:22:34 <Cale> hmm
06:23:00 <PTBD> ok, it works. don't know what I did wrong last time.
06:23:04 <augur> vektor: in dependently typed land, a list who's type specifies its own length is called a vector
06:23:09 <Cale> vektor: Another good example: in every Haskell program right now, you can swap the branches of any if/then/else expression and it'll still typecheck.
06:23:10 <vektor> can I actually use "~" as a path in this context? how do I check whether the folder actually gets scanned?
06:23:19 <PTBD> augur, what would be needed to change otherwise?
06:23:29 <mauke> vektor: 'type -a alex'
06:23:34 <Cale> vektor: In a dependently typed language, that's not always the case, because the type of the result can depend on the outcome of the conditional.
06:23:35 <mauke> assuming the program is called alex
06:23:47 <augur> PTBD: well, you have to be aware of how the fold transforms the list, so it depends
06:23:57 <vektor> that prints out a path. seems to be ok then, huh?
06:24:27 <augur> Cale: you've been watching old 60s television again havent you
06:24:31 <PTBD> augur, ok, so there is no formula or ... simple 3 steps to change from foldl to foldr for all cases?
06:24:41 <augur> Cale: Caution! If-Then-Else really was a great show
06:24:48 <dagano> cabal seems to be pulling an old version of a package....is it not sufficient to run 'cabal update'?
06:24:50 <vektor> so why does cabal install c2hs error?
06:25:01 <augur> PTBD: the formula is, know your problem domain. :)
06:25:05 <vektor> I'll try
06:25:10 <skypers> Cale: the other argument I also hear is “It’s been something like 24 years haskell exist and there’s no solid material about it”
06:25:13 <PTBD> augur, ok, thank you
06:25:55 <Cale> skypers: hah
06:25:58 <augur> PTBD: here is the general behavior of foldr. suppose that * is just some generic binary operator, not multiplication
06:26:23 <Cale> skypers: Well, yeah, that's also kind of a problem. Our ability to document what's going on hasn't been the best.
06:26:25 <bennofs> Is there something like 'canonicalizePath' but that also works for paths that do not exist?
06:26:38 <augur> PTBD: then:   foldr (*) z [a,b,c,d]   ==   a * (b * (c * (d * z)))
06:26:39 <skypers> Cale: he actually meant programs
06:26:42 <skypers> famous ones
06:26:55 <skypers> he think we only work on the language for the language
06:26:59 <augur> PTBD:    foldl (*) z [a,b,c,d]  ==  (((z * a) * b) * c) * d
06:27:03 <Cale> Er, I dunno. Haskell has had a small community for most of that time.
06:27:05 <skypers> and not for a better cause, like making programs
06:27:20 <Cale> There's only so much that a few hundred people can do :)
06:27:34 <vektor> damn, seems like it's gonna be a bit of an update session then. Hope I still remember what I wanted to do when I pulled all the updates.
06:27:39 <Cale> Now of course we've seen a sharp uptick in the number of Haskell users
06:27:40 <skypers> sure Cale
06:27:44 <PTBD> augur, yes, I understand that
06:27:45 <augur> PTBD: if your choice of  (*) and z make those two things equal, then you can translate quite easily, but if not ...
06:28:03 <augur> well, you have to do some thinking to figure out when you can do this.
06:28:11 <skypers> I just don’t like the idea Haskell will never be used to make great programs
06:28:12 <Cale> But it was maybe 2005 or 2006 when you really started to see Haskell becoming usable for real world applications.
06:28:16 <skypers> like video games
06:28:19 <skypers> or whatever useful
06:28:31 <Cale> Well, I've worked on video game development in Haskell
06:28:32 <boom583> I want to make web apps in Haskell. Happstack vs. Yesod vs. Snap? How do I make the decision? I don't know where to start.
06:28:42 <skypers> Cale: do you have some links?
06:28:43 <PTBD> augur, I will do that. well I'm still learning and practicing. I think I will get the hang of it. thank you
06:28:45 <augur> its wrong to think that haskell isnt being used for that, skypers
06:28:52 <Cale> boom583: It's a hard decision because they're all pretty good.
06:28:58 <skypers> augur: it’s not on me!
06:29:02 <skypers> it’s on my frineds
06:29:04 <skypers> friends*
06:29:10 <skypers> who think haskell is about to fail
06:29:15 <vektor> Cale: where'd you put haskell in a video game? what code would you write in haskell? how does haskell perform in games?
06:29:21 <dagano> cabal seems to be pulling an old version of a package....is it not sufficient to run 'cabal update'? i am trying to download gloss 1.8 and cabal gives me 1.7.7.
06:29:28 <augur> well thats your friend's problem, skypers :P
06:29:39 <Cale> boom583: I would probably go with Happstack myself. Yesod isn't something I could recommend to a Haskell beginner, because it's a conglomeration of additional languages to learn in addition to Haskell.
06:29:48 <skypers> vektor: have seen the latest lambdacube post?
06:29:52 <Cale> boom583: Snap is also not bad though.
06:29:54 <skypers> Quake 3 in Haskell :)
06:29:55 <vektor> uhmnope
06:30:04 <skypers> augur: yeah but now I wonder
06:30:10 <skypers> why isn’t there some great programs?
06:30:10 <Cale> vektor: For a PC game, you could probably do the whole thing in Haskell just fine.
06:30:14 <skypers> aren’t*
06:30:17 <augur> skypers: maybe there are
06:30:20 <augur> how would you know?
06:30:20 <boom583> Cale: ok, what templating lang does Happstack use?
06:30:21 <Cale> vektor: We were writing an iPhone game
06:30:22 <Clint> happstack is more labor-intensive than yesod though
06:30:25 <skypers> augur: I know pandoc
06:30:27 <skypers> which is great
06:30:28 <skypers> darcs
06:30:29 <boom583> Cale: yesod has Hamlet
06:30:30 <skypers> xmonad
06:30:37 <skypers> and that’s actually all about it
06:30:44 <augur> i dont know what languages are used for programs i use
06:30:56 <augur> i could guess, but thats guessing
06:30:56 <bennofs> skypers: there are a few websites write in haskell
06:31:10 <skypers> bennofs: do you know some famous ones?
06:31:11 <bennofs> skypers: like bazqux
06:31:21 <vektor> Cale: I suppose except the super-heavy hardware stuff like gfx and physics lib?
06:31:24 <augur> i mean, were it not for people making a point to mention it, i wouldnt know that xkcd was backended by haskell
06:31:38 <Cale> boom583: I believe you can use Heist or Hamlet or hstringtemplate or a few other things with happstack
06:31:44 <boom583> ok
06:31:45 <Cale> boom583: They're pretty interchangeable
06:31:46 <bennofs> Also, haskell seems to be used at facebook somewhere (there was a post about the haxl project)
06:31:53 <Clint> also hsx/hsp
06:31:55 <mauke> HPHP
06:32:05 <augur> john carmack is big into haskell lately
06:32:11 <Cale> In fact, with any of the frameworks, the templating is pretty interchangeable. Hamlet is Yesod's specific answer to that though.
06:32:18 <augur> and thinks FP is the One True Future of game programming, or something like that
06:32:58 <skypers> augur: I hear of that, and that’s great
06:33:11 <skypers> xkcd is written in Haskell?
06:33:19 <Cale> vektor: You can actually do most of that in Haskell too, but you might want to relegate some inner loop that puts animations on the screen to some lower level C or C++ code which doesn't have to stop when the GC happens, if you're running on a phone.
06:33:26 <vektor> wtf, cabal? while (true){cabal install cabal-install; - done; cabal update; - Nope, there's a new version of cabal install available. Install that first;}
06:33:33 <FliPPeh> skypers: I know that the backend behind some of the event comics is
06:33:46 <Cale> vektor: On a desktop machine, I wouldn't worry about the GC that much.
06:33:46 <FliPPeh> Like Time
06:34:16 <skypers> Cale: the GC is slow on mobile-oriented app?
06:34:26 <Cale> On the oldest iPhones we were targetting at the time (this was a few years ago), major GCs could take up to 300ms
06:34:34 <Cale> (that's about once every 5 minutes or so)
06:34:42 <vektor> why the hell does cabal do such stuff? I don't get it. Argh!
06:35:04 <Cale> That's a pretty noticeable frame drop
06:35:05 <srhb> vektor: Do you have the correct version in PATH?
06:35:20 <Cale> On newer phones, maybe not such an issue now? I don't have any real recent data.
06:35:24 <skypers> Cale: yeah, but I thought it’s was worse
06:35:30 <vektor> yeah. PATH is up to date, i.e. printenv PATH prints ~/.cabal/bin as well
06:35:39 <srhb> vektor: Before the system wide one?
06:35:45 <skypers> what kind is the Haskell’s GC?
06:35:45 <mauke> vektor: what does 'type -a cabal' say?
06:35:54 <skypers> I know it’s generational
06:36:00 <skypers> but I don’t know much further
06:36:12 <vektor> cabal is /usr/bin/cabal; cabal is /home/vektor/.cabal/bin/cabal
06:36:17 <srhb> vektor: There you go.
06:36:20 <Cale> skypers: It's a generational combination mark/sweep and copy collector
06:36:28 <skypers> I see
06:36:35 <vektor> I don't see? it uses the old version, because the paths are in wrong order?
06:36:36 <skypers> it sounds pretty fast
06:36:37 <srhb> vektor: You keep running the system wide one which is not being updated. You want your local one first.
06:36:40 <srhb> vektor: Yes.
06:36:59 <Cale> https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
06:37:01 <vektor> how do I do that? swap the order in /etc/profile ?
06:37:10 <srhb> vektor: In your user profie, more likely.
06:37:24 <merijn> vektor: Swap the order in the PATH environment profile, usually set from ~/.profile or ~/.bashrc
06:38:03 <vektor> I used /etc/profile to set it up, so I guess that's my place to go
06:38:20 <lllllllllllll> if [ -d "$HOME/.cabal/bin" ] ; then
06:38:20 <lllllllllllll>     export PATH=$HOME/.cabal/bin:$PATH
06:38:20 <lllllllllllll> fi
06:38:22 <bennofs> Also note that bash caches the paths to executables, so you might need to restart it
06:38:26 <Cale> skypers: It's pretty fast, and it's really quite good at dealing with short-lived garbage
06:38:33 <mauke> bennofs: or just do 'hash -r'
06:38:48 <mauke> but you'll have to restart to set the new variable anyway
06:38:56 <merijn> bennofs: bash does not
06:39:00 <lllllllllllll> vektor, use the user profile or it coult happen that  /etc/profile is overridden by a system update
06:39:13 <merijn> bennofs: I've never encountered that. tcsh does that, amongst others
06:39:28 <vektor> I don't think arch linux would break such stuff in a system update.
06:39:31 <bennofs> bash doesn't cache autocompletion, but I think it caches the absolute path of executables
06:39:52 <vektor> (@ nick I don't even try to type out that is)
06:39:56 <merijn> bennofs: I regularly switch cabal/ghc versions by changing path and never had trouble with getting the wrong version
06:40:01 <mauke> vektor: l<tab>
06:40:24 <geekosaur> merijn, explicitly setting $PATH flushes the cache
06:40:35 <vektor> mauke: thx, that one's nice
06:40:49 <merijn> geekosaur: Right, so the cache warning is useless
06:41:08 <merijn> geekosaur: As the only two ways to update his path are changing .profile and restarting OR explicitly setting it
06:41:22 <geekosaur> no, if you have $PATH set already and add a new binary that is before one the shell has seen in the current session then you need `hash -r` to make it look again
06:41:27 <merijn> Either of which will flush the cache
06:41:39 <merijn> geekosaur: Right, but that doesn't apply to the current discussion
06:41:44 <merijn> As both binaries are already there
06:43:11 <shlevy> If my data type is Hashable, should I indiscriminately use unordered-containers or are there cases where I should just use Containers?
06:44:48 <vektor> this is kinda frustrating
06:45:27 <vektor> cabal install c2hs still doesn't find alex, even though it shows up nicely in type -a alex
06:46:08 <bennofs> vektor: did you check if the version matches (alex --version) at least the required one?
06:47:28 <vektor> alex version is 3.1.3. I'm not sure what c2hs requires
06:47:49 <Rarrikins> What license are libraries usually released under?
06:48:20 <mauke> Rarrikins: bsd something, but mine are often lgpl
06:48:27 <Clint> the cabal init default is 3-clause bsd for some horrible reason
06:48:39 <merijn> Rarrikins: BSD/LGPL is very popular
06:48:40 <Rarrikins> Ahh, OK. Thanks :)
06:48:44 <merijn> Clint: What's horrible about that?
06:49:24 <merijn> Clint: Actually, you're wrong. The default is no license when I run cabal init here
06:49:41 <vektor> how do I figure out which version c2hs requires? it's not listed on the hackage page explicitly, which leads me to believe that it's a dependency of a dependency
06:50:05 <Clint> merijn: i just have an irrational hatred of 3-clause
06:50:42 <merijn> Clint: MIT might be a bit more professional, but 3-clause isn't particularly bad
06:50:55 <Clint> technically no, but there's no point when there are better and clearer licenses that do the same thing
06:51:08 <Clint> and MIT is harder to fuck up
06:51:23 <Clint> since there's no search&replace involved
06:52:06 <bennofs> Clint: who does BSD3 need search&replace?
06:52:12 <bennofs> how*
06:52:15 <boku> Hi, guys! Can you help me with this problem? http://www.spoj.com/problems/APS/ I suppose this task can be solved with simple recursion. So what technique should I use?
06:52:35 <klrr> is PONG a real IRC message or a special case? (it doesnt start with ':' so i presume it's a special case)
06:52:59 <mauke> klrr: why do you think messages have to start with : ?
06:53:30 <klrr> mauke: thought that was the syntax rules?
06:53:53 <mauke> and why did you think that?
06:54:05 <Clint> bennofs: because you have to replace "The Regents of the University of California" and "THE REGENTS AND CONTRIBUTORS" with appropriate entities, and non-lawyers screw this up more often than not, one way or another
06:54:33 <klrr> mauke: all messages seem to start with it exept PING and PONG, source https://github.com/Tehnix/PyIRCParser/blob/master/test/data.py and http://calebdelnay.com/blog/2010/11/parsing-the-irc-message-format-as-a-client
06:54:56 <mauke> klrr: so you didn't look at the spec
06:55:07 <klrr> nope
06:55:11 <merijn> Clint: cabal init does that for you, though
06:55:13 <vektor> boku: first you'd need to implement f(n). you might use a list comprehension here, but that's mostly up to you.
06:55:56 <klrr> mauke: ive not find a clear defition of the syntax in standard
06:55:58 <vektor> boku: After that, the whole problem practically collapses. you define the edge case if your recursion, and implement the rest following the given definition
06:56:32 <merijn> klrr: The RFC has a pseudo BNF for message syntax
06:56:42 <klrr> merijn: what's that+
06:56:47 <klrr> s/+/?
06:56:50 <merijn> I dunno how much clearer you want it than that
06:56:51 <mauke> klrr: a clear definition of the syntax
06:56:52 <Clint> merijn: well, that's true. but MIT's boilerplate is still nicer
06:57:09 <klrr> mauke: got link?
06:57:14 <merijn> klrr: Backus-Naur Form
06:57:20 <mauke> klrr: what
06:57:21 <klrr> thanks
06:57:30 <mauke> I thought you already had the spec
06:57:44 <klrr> yeah but not sure where in it BNF is
06:57:56 <merijn> klrr: There's even an RFC for the syntax of BNF in RFCs
06:57:57 <klrr> now i gogoel what merijn said and i know where to look now
06:58:15 <merijn> klrr: There's literally an sub-chapter in the IRC RFC called "pseudo BNF"
06:58:18 <mauke> presumably in the section called "Message format in 'pseudo' BNF"
06:59:15 <klrr> merijn: yup thanks
06:59:32 <boku> vektor: I defined all functions but have NZEC error: http://ideone.com/R8fDDj So I think that recursion isn't good option to solve this task.
07:00:56 <boku> Sorry, there is working example. http://ideone.com/ou0FSI
07:02:20 <vektor> don't know that error.
07:02:44 <klrr> merijn, mauke: the BNF definition was super clear and easy! thanks :)
07:04:05 <zett_zelett> What’s “RFC” for?
07:04:46 <boku> vector: NZEC stands for Non Zero Exit Code. For C users, this will be generated if your main method does not have a return 0; statement. Other languages like Java/C++ could generate this error if they throw an exception. Perhaps, it means that I have exception because of stack overflow.
07:05:54 <geekosaur> zett_zelett, the Internet standards stuff started out as very informal; RFCs were "Request for Comments"
07:06:00 <merijn> zett_zelett: Request For Comment, the IETF publishes them to describe protocols, over time if the RFC is well received it will become official standard
07:06:01 <Dodek> can you actually be sure that C will return non-zero exit code when lacking return 0; in main?
07:06:11 <merijn> Dodek: No
07:06:13 <Dodek> isn't it rather undefined or indeed 0?
07:06:24 <Dodek> in c++ it's defined as 0 when there's no return statement in main
07:06:37 <geekosaur> the terminology was kept after they changed from informal requests to actual standards, because the people who worked with them all called them that etc.
07:07:16 <mauke> Dodek: in C99 you get 0, in C89 it was unspecified
07:07:50 <boku> Dodek: I don't use C++, I use Haskell, so I think it's exception.
07:08:06 <mauke> once I had to golf a C program so I arranged it in a way that left 0 in %eax - no explicit return required
07:08:48 <merijn> mauke: "had to golf"? In which situation is golfing mandatory? :p
07:09:14 <mauke> merijn: http://spoj.pl exercise where score = length of program :-)
07:15:29 <Cale> wow the Haskell syntax highlighting on ideone is horrible
07:19:26 <geekosaur> yes, and last I checked it still used hugs :(
07:22:28 <FliPPeh> I wish GHC was called Hugs
07:22:35 <FliPPeh> Such a huggable name
07:22:59 <Rarrikins> When did webchat.freenode.net die?
07:23:15 <Cale> Haskell User's Gofer System
07:23:35 <Cale> Gofer = Good for equational reasoning
07:23:52 <FliPPeh> Abbreviation inside an abbreviation?
07:24:16 <geekosaur> well, Gofer was a language
07:24:32 <Rarrikins> It's very anacronystic.
07:24:48 <mirpa> Is there something better than (sort >>> group) (and sortBy/groupBy variant)?
07:24:59 <SrPx> so, new attempt to install Haste, another error when running `hastec Elem.hs` -> Elem.hs:1:1:     Could not find module `Prelude'
07:25:00 <SrPx> Any idea?
07:25:06 <jimstutt> Hi, I'm failing to compile
07:25:06 <jimstutt>                  digestive-functors/examples/snap-heist with the
07:25:06 <jimstutt>                  latest snap, heist, digestive functors from github
07:25:06 <jimstutt>                  with ghc-7.6.3 on Centos6. l. 83 bindSplices can't
07:25:06 <jimstutt>                  match types. I've posted msg, pkglist on
07:25:07 <jimstutt>                  http://lpaste.net/98002. Seems to be something to do with Old.hs. Any suggestions.
07:25:11 <FliPPeh> gah
07:25:44 <Rarrikins> It's nicely outdented by your client!
07:25:47 <Cale> mirpa: I don't know what you mean by that question. That's probably the best way to do what it does.
07:26:02 <FliPPeh> Nice hanging paragraph
07:27:18 <Cale> mirpa: (of course, I'd write group . sort rather than using the Arrow combinator)
07:27:32 <shlevy> I want to represent a series of ascii bytes with a specific format (specifically [a-z][a-z0-9.0]*). Should I just wrap a Text with a safe constructor, or is there a better way to represent it?
07:27:40 * hackagebot resource-effect 0.1.1 - A port of the package 'resourcet' for extensible effects.  http://hackage.haskell.org/package/resource-effect-0.1.1 (ClarkGaebel)
07:27:48 <shlevy> erm
07:27:51 <shlevy> smart constructor I meant
07:28:16 <Cale> shlevy: There's not really anything better.
07:28:45 <shlevy> Cale: OK, thanks
07:29:09 <mm_freak> shlevy: you could represent the string as an automaton that can only produce correct strings
07:29:27 <mm_freak> not too complicated to do, but may be overkill depending on your situation
07:30:21 <shlevy> mm_freak: Trying to represent link relations (http://tools.ietf.org/html/rfc2616). [a-z][a-z0-9.-]* is the allowed format for registered types
07:30:34 <shlevy> mm_freak: Can you point me to something that would describe that approach?
07:30:36 <donri> data Letter = A | B ... Z; data Case = Lower | Upper; data Digit = Zero | One | ... | Nine; data Format = Letter Letter Case | Digit Digit  -- ;)
07:30:57 <shlevy> donri: hoo boy :D
07:31:21 <shlevy> donri: Well if I could hook into overloadedstrings somehow...
07:31:29 <shlevy> and generate that in TH
07:31:31 <mirpa> Cale: I can read it from left to right with arrow, which looks like Unix shell pipes
07:31:33 <shlevy> that would be awesome actually
07:31:42 <donri> you lose the safety with IsString
07:31:54 <donri> but you could use TH or QQ for literals
07:32:23 <Cale> mirpa: But you're still going to apply it to a value on the other side, unless you use something weird like that & operator from lens
07:32:24 <donri> in which case my silly types aren't necessarily necessary :)
07:32:47 <Cale> (group . sort) xs = group (sort xs)
07:32:54 <shlevy> Hmm anyway for now I'll just wrap a Text and export a smart constructor
07:33:00 <shlevy> And make a note
07:33:05 <shlevy> thanks all
07:33:25 <Cale> (sort >>> group) xs = group (sort xs) -- slightly weirder, I think ;)
07:34:32 <mirpa> Sometimes it is better to use (.) like: return . isJust instead of isJust >>> return; but for filtering functions like sort, group... I find it easier since I don't have to look at the end of line and then read it backward
07:34:41 <donri> "the groups of the sorted result" declarative; "sort and then group" imperative! don't you want to be declarative?!
07:34:55 * donri snickers
07:35:38 <mirpa> "sort then group variable x"
07:35:49 <mirpa> (sort >>> group) x
07:35:51 <Peaker> mirpa: you could use the & operator from lens:  x & sort & group & ...
07:35:54 <donri> yep, totally imperative
07:36:31 <Peaker> >>> is so heavy-weight
07:36:32 <mirpa> Peaker: I also like that >>> has "direction"
07:36:38 * donri neither serious nor completely facetious
07:36:55 <shlevy> So is there an easy way to run a regex over Text?
07:38:39 <mirpa> with >>> you keep order of: function then parameters
07:38:43 <donri> text-icu has bindings to a regex library and operates directly on text
07:39:17 <shlevy> donri: hmm seems to require being in the IO monad
07:39:43 <donri> ah yeah
07:40:03 <shlevy> ok maybe it's parsec time? :D
07:40:45 <donri> that's the sane thing to do yes
07:42:29 <donri> if you must go the regex route, i like the "rex" package. it works with String but you can always pack/unpack...
07:42:38 <shlevy> no parsec is fine
07:42:44 <shlevy> good for me to finally learn it anyway
07:43:51 <donri> might also want to take a look at the parsers package, which provides generic combinators that work with parsec, trifecta, readp, and arguably a bit cleaner than direct parsec
07:44:00 <shlevy> donri: thanks
07:46:49 <shlevy> donri: Are there examples using parsing anywhere?
07:47:06 <donri> shlevy: parsing?
07:47:12 <shlevy> sorry
07:47:14 <shlevy> parsers
07:47:37 <merijn> shlevy: Real World Haskell has a chapter on Parsec
07:47:53 <merijn> shlevy: It's about Parsec 2 instead of Parsec 3, so some of the API they use is out of date
07:47:58 <donri> oh, duno. the api is all applicative/alternative taking naming conventions from the other parser combinators
07:48:21 <merijn> shlevy: But the general principles between Parsec 2 and Parsec 3 are so similar that reading the chapter + hackage docs should be enough to get you started
07:50:54 <k00mi> shlevy: there is not a lot of documentation on parsers, but in once you learn how to use Parsec (which has a lot of documentation/tutorials) parsers isn't very different
07:51:11 <shlevy> k00mi: OK, thanks
07:52:24 <dmj`> shlevy: out of curiosity, what are you trying to build
07:55:10 <shlevy> dmj`: Right now, a data type to represent link relations. Overall goal, an authorization web service where authorization is determined by group membership, source resource, target resource, link relation, and method
07:57:56 <bennofs> Can I use 'callPackage' when I have a default.nix outside of nixpkgs?
07:58:03 <bennofs> oops, wrong channel
07:58:16 <shlevy> bennofs: the answer is yes ;)
07:59:53 <vektor> dammit. Cabal still won't find c2hs
08:00:50 <vektor> version matches, type -a prints the correct path first (~/.cabal/bin)
08:01:10 <vektor> yet still, cabal install ncurses complains it can't find c2hs.
08:01:16 <vektor> type -a
08:01:34 <vektor> *type -a c2hs
08:01:50 <bennofs> vektor: so path is set to ~/.cabal/bin; c2hs --version reports correct version; yet cabal won't find it?
08:02:04 <vektor> apparently.
08:05:11 <klrr> for IRC messages, what is the most appropriate type to use, text or bytestring?
08:05:40 <merijn> klrr: ByteString, IRC doesn't define an encoding
08:06:09 <bennofs> klrr: from the server, you will probably receive bytes. Then, when you process them, you might need to decode them and they will become Text
08:06:29 <hpc> IRC is defined such that the control parts of a message fit within 7-bit ascii
08:06:30 <boom583> Is it good practice in Haskell to put an "interface" into a separate file? For example, creating a Vehicle type class with a few functions (without implementations): drive, repair, destroy. Should this interface be put in a single small Vehicle.hs file?
08:06:43 <hpc> and it's generally understood that when using unicode you pick utf8
08:07:12 <klrr> okey, thanks!
08:07:36 <merijn> boom583: It's rather uncommon to use typeclasses for that
08:07:43 <boom583> oh
08:07:45 <identity> mauke: you're the maintainer of Data.Default, correct?
08:07:49 <hpc> be prepared for malformed input though; there's still some people who stubbornly use latin-1 and i have had crashes before from that
08:07:54 <shlevy> does do{ have different meaning from do?
08:08:01 <mauke> identity: yes
08:08:10 <boom583> merijn: why? isn't this is the same as Eq with its == /=?
08:08:12 <boom583> or Ord with <
08:08:12 <merijn> shlevy: No, haskell supports braces in addition to layout
08:08:15 <hpc> shlevy: the {;} is just so you don't have to use layout
08:08:19 <bennofs> shlevy: I don't think so. You can write do { a; b; c; d } instead of layouting
08:08:22 <shlevy> Ah ok
08:08:46 <merijn> shlevy: See https://en.wikibooks.org/wiki/Haskell/Indentation for how layout translates to braces
08:08:48 <hpc> > do {[1, 2]; [3, 4]; [5]} -- very helpful with lambdabot
08:08:49 <lambdabot>  [5,5,5,5]
08:09:07 <vektor> has anyone got any ideas how to fix my issues with cabal?
08:09:14 <bennofs> Can lambdabot do GHCi-style multiline input?
08:09:22 <hpc> bennofs: yes, but i forget how
08:09:23 <mauke> > do ["lay", "out"]; "hpc"
08:09:24 <lambdabot>  "hpchpc"
08:09:33 <hpc> it's something like :{ at the start of a block and :} at the end
08:09:37 <mauke> bennofs: no
08:09:55 <bennofs> :{
08:09:57 <merijn> boom583: Usually you'd do the following instead: "data Vehicle = Vehicle { drive :: Speed -> Direction -> IO (); repair :: Int -> IO Vehicle; destroy :: IO () }" or something similar
08:10:17 <merijn> boom583: How would you expect to use the "Vehicle" typeclass?
08:10:21 <identity> mauke: I take it you haven't looked at pull requests for it on github for a while? I submitted one, adding instances for Data.Text a while ago
08:10:37 <boom583> merijn: by creating type instances of it. Car, Airplane, etc.
08:10:45 <boom583> (Vehicle v) => ...
08:11:00 <mauke> identity: this may take a while
08:11:01 <merijn> boom583: But you can't have both Car and Airplane in the same list, so how would you have a collection of vehicles?
08:11:05 <bennofs> vektor: Did you try running cabal with -v3 and see if that gives any hints? (Or maybe try -v2 first)
08:11:12 <boom583> merijn: ok i see
08:11:14 <mauke> I have about 2000 unread mails
08:11:16 <FliPPeh> Ahh, vehicular examples
08:11:16 <merijn> boom583: See also
08:11:20 <FliPPeh> It's like learning OOP all over again
08:11:21 <bennofs> vektor: what package are you trying to install, btw?
08:11:26 <merijn> @where existential-antipattern
08:11:26 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
08:11:26 <vektor> ncurses
08:11:47 <merijn> boom583: That blogposts explains what the better solution to your problem is
08:11:48 <identity> mauke: hmm? Oh, I don't expect you to do anything within any timeframe. I just looked at my github account, remembered I had made a pull request, saw your name and remembered seeing you in here, active, etc, so figured you probably just hadn't noticed.
08:11:52 <hpc> bennofs: http://lpaste.net/98007 -- here's how it works
08:11:53 <boom583> merijn ok thx
08:12:03 <merijn> FliPPeh: Word. :)
08:12:09 <vektor> trying -v3 now
08:12:38 <bennofs> hpc: I know, does this work in lambdabot too?
08:12:56 <hpc> no; lambdabot is annoying
08:13:06 <hpc> > :{
08:13:07 <lambdabot>  <hint>:1:1: parse error on input `:'
08:13:31 <hpc> also it specifically protects against such antics to avoid people trying
08:13:34 <hpc> > :! rm -rf /
08:13:35 <lambdabot>  <hint>:1:1: parse error on input `:!'
08:14:12 <shlevy> So I see Text.Parser.Combinators.many gives f [ a ]. If I'm building up a Text would it be better to somehow add each char incrementally?
08:15:26 <shlevy> Or maybe the question doesn't even make sense :D
08:15:54 <vektor> bennofs: http://lpaste.net/98008
08:17:22 <bennofs> vektor: and echo $PATH says "~/.cabal/bin:..." ?
08:17:28 <vektor> yeah
08:17:42 <shlevy> Or maybe instead of many I want to call a subparser recursively?
08:17:48 <shlevy> I'll try that
08:17:52 <ChongLi> wackelkontakt is pretty cool :)
08:18:14 <bob1> hi
08:18:29 <bob1> can anybody have a look at this question? http://stackoverflow.com/questions/20935572/haskell-why-does-this-work-an-example-of-memoization
08:18:54 <bob1> thanks a lot
08:19:15 <quchen> India launched a indigenous cryogenic engine rocket! For journalists, that means telling people how proud India is about its indigenous cryogenic engine and under no circumstances explain what a indigenous cryogenic engine is.
08:19:17 <vektor> bennofs: any idea?
08:19:18 <quchen> Thank you internet.
08:19:58 <bennofs> bob1: You might want to look at the series about the haskell heap: http://blog.ezyang.com/2011/04/the-haskell-heap/
08:22:30 <bennofs> vektor: maybe try using $HOME/.cabal/bin instead of ~/.cabal/bin
08:23:11 <shlevy> using parsers, what is the equivalent of the parsec Parser type constructor?
08:23:20 <vektor> type -a c2hs prints a valid path, it seems
08:23:57 <bennofs> vektor: It might be that cabal chokes on the ~. You could try to use an absolute path, without ~
08:24:11 <vektor> alright. I'll try that
08:25:58 <static_> hi all, trying to get some help with decoding json that contains unicode symbols with aeson
08:26:44 <static_> seems like aeson's 'decode' fun takes Data.ByteString.Lazy.Char8 type as argument
08:27:17 <shlevy> Using parsec to generate a Text, is it best to internally create a [ Char ] then use pack at the end, or should I build up the Text as I go?
08:28:35 <quchen> shlevy: Text's purpose is avoiding to use [Char].
08:29:01 <static_> so anyone knows how to parse json containing unicode?
08:29:08 <quchen> static_: Use Aeson?
08:29:12 <boom583> merijn: i don't get this pattern. how does this pattern enforce that my Car implements all those Vehicle functions?
08:29:37 <quchen> shlevy: You may want to have a look at the Builder module in Text.
08:29:59 <static_> it looks like AESON decode takes Data.ByteString.Lazy.Char8 which is not unicode friendly from what i understand
08:30:31 <shlevy> quchen: Ah!
08:30:33 <shlevy> Thank you
08:30:37 <vektor> bennofs: http://lpaste.net/98009
08:30:47 <vektor> bennofs: Updated the PATH variable
08:30:49 <shlevy> quchen: Only for lazy text? Any idea why?
08:31:14 <quchen> static_: Aeson uses lazy bytestrings, not Char8 BS.
08:31:21 <quchen> Ambiguity intended.
08:31:32 <FliPPeh> static_: After throwing a few umlauts into my RPC server that's using Aeson, I'm pretty sure it's unicode friendly
08:31:39 <static_> i see what you did there :)
08:31:48 <quchen> shlevy: Not really, no. But you can easily convert between strict and lazy BS.
08:31:55 <quchen> Ambiguity not intended ;-)
08:32:55 <bennofs> vektor: you need to install the ncurses headers
08:33:33 <bennofs> vektor: on ubuntu, it's libncurses[something]-dev iirc
08:33:40 <static_> from examples, i use Data.ByteString.Lazy.Char8 type to feed the decode function. Is there another way sans Char8?
08:34:22 <vektor> ahh, alright
08:34:51 <quchen> Don't use .Char8 unless you know you absolutely need that hack. I don't know what you want to do, so I can't recommend anything instead.
08:37:47 <vektor> bennofs: arch linux know lib32-ncurses. sounds good?
08:38:13 <bennofs> vektor: I think you only need the package 'ncurses' then
08:38:23 <simukis_> vektor: in arch linux ncurses development libraries are installed with ncurses package.
08:38:29 <vektor> That I already have.
08:38:50 <bennofs> Wat
08:39:30 <philed> boom583: Records in Haskell aren't like dictionaries. You can't use any other fields than those declared in the type, and you'll get compiler warnings if you don't set all fields.
08:39:45 <static_> quchen: I dont really need to use Char8, just trying to satisfy AESON. I basically have a String that may contain unicode and i try to parse it with AESON. Any ideas on simpliest way to do this?
08:39:45 * bennofs chroots into arch
08:40:34 <FliPPeh> static_: turn the string into a bytestring
08:40:44 <benmachine> static_: the name Aeson isn't an acronym, btw
08:40:53 <quchen> static_: Uhmm. Why do you have a String in the first place? Anyway, there are encoding functions to convert strings to various byte representations.
08:40:59 <FliPPeh> BS.pack with whatever BS aeson expects
08:41:18 <boom583> philed: but how would I make a car from it? let car = Vehicle { drive :: ... } ? But that's just one car. All cars should have the same functions
08:41:36 <FliPPeh> I just read the raw JSON data directly as a bytestring, much less hassle
08:41:37 <boom583> s/drive::/drive=
08:43:20 <quchen> FliPPeh: pack doesn't work on String generically I think. pack :: [Word8] -> BS
08:43:22 <benmachine> static_: I guess the right thing to do is to encode the string in UTF8 or something
08:43:35 <simukis_> boom583: abstract it with makeACar vars… = Vehicle {  drive = defaut, … }
08:43:36 <FliPPeh> boom583: You build a function that constructs you a Vehicle that passes in those same functions
08:43:36 <FliPPeh> makeCar = Vehicle { ... }
08:43:36 <FliPPeh> let car = makeCar ...
08:43:36 <FliPPeh> At least that's what I would do
08:43:48 <benmachine> but yes, it's reasonable to ask where the String comes from, and if you can get a ByteString at the source instead
08:44:45 <boom583> ok are there any nice tutorials out there on this pattern?
08:44:46 <boom583> that Luke site was a bit hard to get imo
08:44:49 <boom583> s/site/post
08:44:54 <philed> boom583: Well, that's the advantage here! You can have vehicles with any old drive function, and you can be creating them at runtime.
08:45:52 <static_> getting the string to be parsed from curl package (curlGetString)
08:45:56 <Komier> copying an example from LYAH straight to my text editor, and ghc-mod is giving me errors :-/
08:46:27 <philed> boom583: It's down to what you want to do. Typeclasses don't give you subtyping, which is what you get in other OO languages. If you want late-binding, this solution with records works, but only gives you one type.
08:46:28 <philed> *-other
08:46:30 <simukis_> boom583: alternatively you can make yourself `defaultCar = Vehicle { drive = default }` and then make yourself cars with `let car = defaultCar { color = Red }` or something.
08:47:30 <simukis_> boom583: downside is that you'll have to put dummy values in defaultCar (e.g. White for color).
08:47:32 <quchen> static_: Have you seen the curl-aeson package?
08:47:38 <boom583> hmok
08:48:02 <static_> quchen: no, that sounds useful, i'll take a look
08:48:23 <bennofs> vektor: do you have 'pkg-config' installed?
08:48:37 <boom583> philed: ok is there really a need to have a special type for Car?
08:48:42 <boom583> one type sounds fine
08:48:43 <vektor> bennofs: yeah
08:48:44 <boom583> for just vehilce
08:48:46 <quchen> I just found it while looking for that curl module. It sounds like exactly what you're looking for.
08:49:00 <boom583> the rest is just funcs
08:49:18 <boom583> i.e. the "interface" is the type. the instances are just funcs
08:49:43 <shlevy> For the parsers package, what's the equivalent of the 'parse' function in parsec?
08:49:48 <philed> boom583: What's the application? Programming isn't about creating random taxonomies  :P
08:51:09 <boom583> philed: web cart. Item. And then various types. Book, CD, etc.
08:51:15 <boom583> Item, Vehicle
08:51:17 <boom583> Book, Car.
08:51:47 <philed> Do you need to have a "drive" function for that?
08:52:16 <boom583> no but i'll need some print functions, a price function, perhaps, etc.
08:53:41 <boom583> drive was just for my Vehicle example
08:53:43 <philed> If you're just aggregating things like print-strings and prices, I wouldn't be thinking in terms of functions at all. You've just got a simple record of values.
08:53:50 <bennofs> vektor: Ok, I can reproduce your error
08:54:59 <boom583> ok
08:55:07 <vektor> bennofs: good to hear for me :D
08:56:38 <boom583> Different topic: How do you give something, some thing, a "state" in Haskell? In OO you just instance/member variables to store the state.
08:56:48 <boom583> A car might have numberOfDrives
08:56:53 <boom583> where to store this?
08:57:31 <ion> data Car = Car { numberOfDrives :: Integer }
08:57:53 <FliPPeh> We have a State monad if you really hate passing around the state as parameters
08:58:16 <FliPPeh> Although for simple things, ion's solution may be better
08:58:25 <ion> flippeh: They are not exclusive.
08:58:45 <boom583> ion: after doing, let foo = Car {numberOfDrives=0} how do you change foo's numberOfDrives later?
08:59:03 <maurer> boom583: You can't. You can create a new value based on foo though
08:59:06 <FliPPeh> foo { numberOfDrives = (numberOfDrivers foo) + 1 }
08:59:11 <FliPPeh> Like that
08:59:15 <maurer> boom583: e.g. let foo' = foo  numberOfDrives = (numberOfDrivers foo) + 1 }
08:59:29 <maurer> err, with a {, but yeah
08:59:31 <FliPPeh> Clunky record update syntax
08:59:32 <dv-> warning: redundant parens
08:59:34 <FliPPeh> But it works
08:59:37 <Kaidelong> @ty put
08:59:38 <lambdabot> MonadState s m => s -> m ()
09:00:08 <Clint> _lens
09:00:11 <FliPPeh> And you can combine that with the state monad by saving the copy you generate with the record update as the new state
09:00:56 <ion> With lens, non-State: foo & numberOfDrives +~ 1. With lens and State: numberOfDrives += 1
09:01:52 <dv-> suddenly, incomprehensible error messsages :p
09:02:03 <FliPPeh> Lenses are way too magical for me
09:02:38 <FliPPeh> Something so superficially simple shouldn't require so many complicated sounding concepts :(
09:03:11 <bennofs> How can I tell cabal to use different cc-options?
09:03:29 <bennofs> (Without editing the .cabal file)
09:04:45 <shlevy> Documentation for Text.Parser.Char.lower says 'a character between a-z' but the implentation uses isLower, not isAsciiLower
09:04:48 <shlevy> Is that a bug?
09:06:07 <bennofs> vektor: The issue is that arch merged ncursesw and ncurses
09:06:34 <static_> thanks all, looks like i solved my problem with using Data.ByteString.Lazy.UTF8 to feed aeson's decode (used fromString)
09:06:45 <simukis_> shlevy: I guess it's more of a misdocumentation rather than incorrect behaviour.
09:06:47 <boom583> FliPPeh, maurer, why could you do "foo {"? Why not "Car {" again?
09:06:48 <bennofs> vektor: you can fix it by editing the cabal file for ncurses
09:07:02 <FliPPeh> boom583: Because Haskell records are disgusting
09:07:08 <shlevy> simukis_: Right
09:07:13 <bennofs> vektor: to do this, first get the source with 'cabal unpack ncurses' (this will create a ncurses-0.2.4 directory)
09:07:14 <shlevy> I'll open an issue
09:07:25 <FliPPeh> Also, because you would create a *new* Car with "Car {"
09:07:40 <FliPPeh> "foo {" updates the existing one by copying it with updated values
09:07:52 <simukis_> To chanmaster: mantiss should be banned for spamming.
09:07:59 <FliPPeh> It leaves the unspecified fields intact
09:08:03 <bennofs> vektor: then, edit the cabal file and add "cc-options: -DHSNCURSES_NARROW_HEADER
09:08:12 <bennofs> " right below ghc-options
09:08:23 <bennofs> vektor: then, cd to the directory and do cabal install
09:08:26 <bennofs> vektor: that worked for me
09:08:40 <boom583> FliPPeh: ok
09:11:56 <boom583> FliPPeh: this aspect doesn't seem to be in LYAH. is it in real world haskell?
09:12:04 <boom583> this aspect of records
09:14:24 <Rarrikins> What is the upcoming extension that allows two types with record syntax to share some member names?
09:15:28 <quchen> Rarrikins: Overloaded records?
09:22:25 <defanor> hello. i'm trying to learn haskell, and have some questions. here is the first: is there a way to ensure that there's no non-exhaustive patterns in a function?
09:22:49 <quchen> defanor: Compile with -W and you'll get warnings
09:22:51 <vektor> system just crashed. Thus haven't received any messages since I last wrote stuff. Anything I missed?
09:23:03 <defanor> quchen: thanks
09:24:07 <quchen> You can also use ":set -W" in GHCi if you prefer that. Loading (interpreted) modules will then emit the warnings.
09:24:38 <bennofs> vektor: The issue is that arch merged ncursesw and ncurses
09:24:42 <bennofs> vektor: you can fix it by editing the cabal file for ncurses
09:24:55 <bennofs> vektor: to do this, first get the source with 'cabal unpack ncurses' (this will create a ncurses-0.2.4 directory)
09:25:04 <defanor> quchen: yeah, that's even better for now (using interpreter to learn)
09:25:13 <bennofs> vektor: then, edit the cabal file and add "cc-options: -DHSNCURSES_NARROW_HEADER" right below ghc-options: ...
09:25:20 <bennofs> vektor: then, cd to the directory and do cabal install
09:25:24 <bennofs> vektor: that worked for me
09:25:50 <maurer> boom583: http://book.realworldhaskell.org/read/monads.html it's mentioned, but not in the records section
09:26:11 <boom583> ok
09:26:31 <maurer> boom583: The short version is that if you have a record x, and you write x { field = value}, it means "Call x's constructor with all the same arguments as x except the ones I list here"
09:26:52 <boom583> maurer: ok, and it's faster than creating it from scratch?
09:27:03 <maurer> boom583: No, it's just syntactic
09:27:05 <boom583> ok
09:27:07 <maurer> boom583: No effect on speed
09:27:53 <zett_zelett> Following the types, I just defined κ :: Monad m => m (a -> b) -> m a -> m b; κ f = \x -> join $ liftM (x >>=) (liftM (return .) f) as some sort of (<$>) (in order to understand why every monad is an applicative functor) – can anyone help me understand what I just did?
09:29:35 <philed> zett_zelett: liftM2 ($)?
09:30:27 <zett_zelett> Wow.
09:30:41 <zett_zelett> How does liftM2 work, though?
09:30:56 <quchen> @src liftM2
09:30:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:31:08 <zett_zelett> Yeah, of course.
09:31:19 <maurer> k f' x' = do {f <- f'; x <- x; return $ f x}
09:31:29 <maurer> might be clearer if you don't have liftM2 internalized
09:31:38 <maurer> (there's a reason people use do notation for monads)
09:31:49 <maurer> err, that should be x <- x'
09:31:52 <maurer> but you get the idea
09:31:57 <boom583> thanks all
09:31:58 <zett_zelett> Yeah, I see.
09:32:02 <boom583> Haskell is HARD
09:32:14 <maurer> boom583: What do you find hard about it?
09:33:13 <quchen> zett_zelett: Exercise: rewrite your definition until you reach liftM2
09:33:33 <boom583> new way of thinking. instead of having an OO object whose state changes many times after a series of steps, it looks like I will have a function that will return my result AND new parameters to put into the next function call, recursively until I get my thing
09:33:54 <boom583> this is badass
09:34:32 <mangaba_leitosa> types are hard. haskell should guess what one means instead of throwing 10-line type errors
09:34:41 <threestrikes> I made this simple function to help me understand a few of the functions I can use on text.  After playing around with it and looking at how a function can be basically embedded into another function.  How do you keep track of it all?  Eventually it all gets confusing right?  What am I missing.
09:34:46 <maurer> If you haven't done functional programming before, I can see how it might be tricky.
09:34:50 <threestrikes> http://lpaste.net/98010
09:34:50 <maurer> mangaba_leitosa: Are you joking, or serious?
09:35:09 <mangaba_leitosa> maurer: it would be useful for haskell to have some AI
09:35:20 <quchen> Yeah, strong AI would be a nice feature for any compiler.
09:35:38 <quchen> main = hey I want some program that prints hello world
09:35:40 <watermind> maurer: not sure if he's joking but there is a bit of truth to that... unification can result in some pretty unreadable errors
09:35:53 <quchen> Parse error: did you mean 'putStrLn "hello world"'?
09:35:55 <maurer> watermind: I agree that better error messages are a thing to strive for
09:36:05 <mangaba_leitosa> quchen: :-)
09:36:10 <maurer> watermind: It is one of the things that sets haskell's tooling apart from ocaml's or sml's
09:36:15 <philed> zett_zelett: liftM2 is actually an applicative function. liftM2 f x y = ap (ap (pure f) x) y
09:36:27 <philed> But you call it liftA2, obviously.
09:36:40 <watermind> maurer: as in haskell is better or worse? I don't find either very good to be honest
09:36:49 <maurer> watermind: Haskell's are much better
09:37:03 <maurer> watermind: I have to use OCaml primarily, and occasionally SML for my work
09:37:28 <zett_zelett> That does make a lot of sense, philed.
09:37:51 <quchen> mangaba_leitosa: The new holes extension will suggest things that fit into gaps though
09:37:55 <philed> Replace ap with <*>. Not sure where I got "ap" from.
09:38:13 <watermind> maurer: my impression was that part of that is because in OCaml/SML it's not common to provide type signatures at all and instead all it's left to be inferred, which results in more abstraction and therefore worse messages
09:38:20 <quchen> main = putStrLn _noIdea  →  Hole found, type: String. Here are some String values in scope: …
09:38:29 <maurer> watermind: that is part of the problem, but not the whole problem
09:38:30 <mangaba_leitosa> what usually happens when you just forget to specify an argument to a function?
09:38:38 <watermind> maurer: right
09:38:38 <maurer> watermind: For example, they also stop on the first error and report only that
09:38:43 <mangaba_leitosa> you have about 10 errors that do not fit on one screen
09:38:55 <quchen> I would think you have one error.
09:39:03 <watermind> maurer: fair point
09:39:03 <maurer> mangaba_leitosa: Can you give me an example that causes that?
09:39:21 <maurer> mangaba_leitosa: I would expect similar to quchen, that I'd get one or maybe two errors depending on how much I'd signed my code
09:39:34 <jonasw> threestrikes: You don't have to keep track of how every function is implemented in order to use them
09:39:42 <monochrom> w00t new lambdacat!
09:40:12 <maurer> threestrikes: So, I'm unclear on what you feel you need to keep track of there. Your example doesn't do anything haskell-specific in terms of functions
09:40:24 <quchen> When you don't write top-level type signatures sometimes "wrong" types can be inferred and the type error appears in a place that seems unrelated to the programmer.
09:40:35 <watermind> maurer: I don't have any magic solution, but my feeling is that some interactive querying of error messages could help
09:40:40 <quchen> But that's still not 10 different messages.
09:40:58 <maurer> watermind: I mean, my solution if I get an error message I don't understand is sort of a "check your assumptions" process
09:41:29 <maurer> watermind: I go find things that I think have a certain type, sign them that way, and see what happens to the error message.
09:41:43 <watermind> maurer: exactly, that's preciely what I do
09:41:52 <mangaba_leitosa> maurer: ok, maybe there will be 2 errors indeed. each 10 lines long :-0
09:42:05 <quchen> And 10 lines long is bad in what way?
09:42:10 <watermind> maurer: I think maybe there's a way to introduce something like that in the interpreter
09:42:26 <maurer> watermind: Have you ever worked with interactive theorem provers before?
09:42:45 <maurer> watermind: If you wanted to consider a way for the programmer to do what you want, perhaps it might be useful to examine how some of them work
09:42:47 <watermind> maurer: providing what you expect the type of certain subexpressions be,  and/or partial signatures
09:43:04 <watermind> maurer: yeap I did a bit
09:43:09 <magicman> Have a function with 11 non-unifyable arguments, and forget the first one. That'd probably give lots of errors >_>
09:43:40 <mangaba_leitosa> quchen: I would prefer one error saying "missing argument" :-)
09:43:44 <quchen> Functions only have one argument.
09:44:10 <philed> maurer: HOL user?
09:44:22 * monochrom has used HOL4 and PVS
09:44:24 <threestrikes> I woudln't need to keep track of anything.  I'm curious to know if and when functions do get more complicated with bigger programs how would you just look at it and know what a program is doing?
09:44:34 <quchen> mangaba_leitosa: Well, intended currying is indistinguishable from accidentially omitted parameters, so you can't simply do that. You'll get used to reading the error messages though.
09:44:48 <shlevy> Is there a good way to represent the constraint (uniqueRecordName a == uniqueRecordName b) -> a == b?
09:44:58 <quchen> mangaba_leitosa: I'm often just looking for the suggested error location and don't worry too much about the actual error.
09:45:21 <monochrom> threestrikes: I write comments to explain the program to myself
09:46:22 <mangaba_leitosa> quchen: ok, so you do agree that error messags are often not helpful at all :-)
09:46:27 <quchen> No.
09:46:39 <quchen> They're tremendously useful.
09:47:01 <mangaba_leitosa> quchen: but you said you "don't worry too much about the actual error"
09:47:07 <quchen> I also said "often".
09:47:15 <mangaba_leitosa> I also said often :-)
09:47:17 <quchen> Because many times the error location makes the mistake obvious.
09:47:22 <mangaba_leitosa> "error messags are often not helpful at all" :-)
09:47:29 <quchen> And I said no.
09:47:34 <quchen> Error messages are always helpful.
09:47:49 <quchen> In particular the line where it gives me the error location.
09:47:58 <mangaba_leitosa> ok, messages are helpful, but the exact content of the message is not :-)
09:48:07 <mangaba_leitosa> ah, ok :-0
09:48:45 <quchen> The exact content of the message is also often helpful. Let's stop playing the "no" game.
09:49:00 <magicman> And then you know it's probably within the 40 lines surrounding that one line. Except when it's not.
09:49:26 <magicman> In my coding routine, I find the expected/inferred types the most useful.
09:50:00 <magicman> Which is basically "reload in ghci every so often, any type errors will be in the recently modified code".
09:50:33 <maurer> philed: No, I've used agda and a bit of coq
09:50:33 <magicman> Location is probably more useful if I'd add type signatures. I should probably make that a habit >_>
09:51:02 <monochrom> also, it is not like I explain a monolith of 100 lines. a program is never a monolith. never.
09:51:57 <Rarrikins> quchen: Thanks, that was it
09:52:33 <monochrom> instead, it's 100 lines because the main task can be done by 10 subtasks, each subtask taking 10 lines. therefore, I first explain why the 10 subtasks combine to do the main task correctly, then why each 10-line chunk does its respective subtask correctly.
09:52:45 <Rarrikins> mantiss is spamming in query windows.
09:53:07 <Rarrikins> It's an on join spam.
09:53:21 <Nik05> hm im thinking i improve my program but time says its running slower :(
09:53:22 <monochrom> therefore, every explanation just has to say why 10 line combine to 1 line correctly. it is always just 10 lines each time.
09:54:05 --- mode: ChanServ set +o monochrom
09:56:30 <Rarrikins> Does anyone know in what version of GHC -XOverloadedRecordFields is coming? Or, alternatively, is there some place where these things are listed?
09:56:43 <shlevy> Is there a typeclass for "serializable to Text.XML.Document"?
09:57:00 --- mode: monochrom set -o monochrom
09:57:09 <shlevy> Or rather to Node I guess
09:58:07 <Kaidelong> should I use HXT or blaze-html for outputting XML files?
09:58:15 <Kaidelong> or is there a better option?
10:00:35 <monochrom> I use HXT because I have already learned it (and nothing else). sunk cost.
10:00:52 <monochrom> YMMV because you are under different, unrevealed constraints.
10:00:53 <foozbaz> hello! if i "import X" and X re-exports module Q, is there any way of saying "import X hiding (Q)" that hides the contents of Q?
10:01:20 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:01:30 <Kaidelong> most of the documentation for using HXT seem to be either about serializing haskell data structures or parsing XML
10:01:37 <Kaidelong> neither of which I actually need to do
10:02:18 <monochrom> so don't use HXT
10:02:34 <Kaidelong> what I'm trying to do is to make a haskell DSL that generates a kind of custom serialization to an existing XML based system
10:02:53 <foozbaz> alo? any way to hide annoying reexports?
10:03:23 <Kaidelong> so if I need to generate XML but am not looking for straightforward deserialize/serialize or to parse XML, where do I go?
10:03:40 <bennofs> foozbaz: no, that's not possible afaik
10:03:51 <Kaidelong> what kind of library lets me have types for things like Tags and Attributes and get a nice "printXML" function?
10:03:53 <maurer> I used xml-conduit when i needed to work with xml
10:04:03 <maurer> but I was doing network stuff, so it might have made a little more sense
10:04:09 <foozbaz> bennofs: so it's just something i have to take up with the module dev?
10:04:10 <foozbaz> got it.
10:04:28 <monochrom> almost all xml libraries do
10:04:48 <monochrom> HXT does, HaXML does, even tagsoup kind of does.
10:05:29 <merijn> Rarrikins: I would guess 7.10 at the earliest
10:05:43 <foozbaz> bennofs: thanks!
10:05:52 <merijn> Rarrikins: Certainly not the (seemingly continuously delayed) 7.8 release
10:07:59 * hackagebot aeson-pretty 0.7.1 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.7.1 (FalkoPeters)
10:08:54 <Rarrikins> merijn: Thanks
10:09:30 <merijn> Rarrikins: As for how to find out, the ghc-users list and release notes are probably the best sources?
10:19:55 <NemesisD> does anyone know if creating bindings for a GPLv3 library could be MIT?
10:20:26 <NemesisD> i'm pretty sure you have to be GPLv3 if you're including the source of the library, but this package just binds to the library already installed on the system
10:20:56 <Clint> NemesisD: any binaries you'd distribute would be de facto GPL
10:21:19 <bennofs> Clint: even if you link dynamically?
10:21:39 <NemesisD> yeah i'm linking dynamically and providing a library, so i wouldn't generate binaries but my end users would
10:21:40 <Clint> depends on the judge's interpretation of derivative works
10:22:09 <flux> well, you dual-license under MIT
10:22:14 <flux> though I'm not sure if that would be of any use
10:22:25 <flux> later someone could change the bindings to be for another library :)
10:22:26 <NemesisD> because doesn't gplv3 require you to distribute the source code? i could care less if someone includes the source of my binding library
10:22:39 <Clint> source code or offer of source
10:23:08 <flux> I think you are allowed to have a more free (ie. MIT) license, that of course does not affect the license that applies to using the original library
10:23:20 <NemesisD> cool im gonna do that then
10:27:00 <vektor> bennofs: that workaround doesn't quite work for me. c2hs still not found.
10:27:28 <bennofs> vektor: wait, c2hs was found in the log you posted some time ago
10:27:45 <bennofs> vektor: the problem was that there was an error, with the #include
10:28:54 <vektor> hmmm. must've done something wrong somewhere
10:29:05 <epta> How to highlight matched parens in ghci?
10:29:44 <geekosaur> afaik you don't
10:31:55 <geekosaur> yeh, haskeline doesn't support that
10:32:18 <vektor> how was that command "XYZ -a c2hs" -> searches PATH for c2hs.
10:32:41 <bennofs> vektor: type
10:32:42 <geekosaur> type c2hs
10:33:00 <bennofs> vektor: did you use an absolute path to ~/.cabal/bin or did you use '~/.cabal/bin' ?
10:33:08 <bennofs> vektor: iirc, that was the problem you had before
10:33:13 <vektor> now using an absolute path
10:36:40 <Nik05> hey guys and girl
10:37:03 <raek> does someone know a guide or something for designing quickcheck properties?
10:37:53 <raek> (e.g. whether to test functions individually or test properties spanning multiple functions)
10:39:20 <valtih> what does it meant that `Leaf is logically a function Int -> Tree` in https://en.wikipedia.org/wiki/Algebraic_data_type?
10:39:39 <Nik05> does anyone know why the first is twice as fast as the second? http://ideone.com/3ezCJW http://ideone.com/3E3n24
10:40:22 <Nik05> i thought the second one should been faster because i thought an extra read would be faster than an extra show
10:41:27 * geekosaur wonders if that's even reproducible in ghc
10:41:49 <Nik05> geekosaur what do you mean?
10:42:00 <geekosaur> ideone uses hugs, which is ancient and unsupported
10:42:06 <vektor> bennofs: works. f'ed up the PATH after a restart
10:42:16 <geekosaur> (as in, has not been updated for many years)
10:42:27 <Nik05> oh ok, but i did it with ghc first, and the first one also was twice as fast there
10:42:46 <SrPx> So, I'm understanding how steram fusion works, but I have a question. Considering I'm implementing a toy language that is pretty much lambda calculus + lists + numbers, would it be unwise to just substitute lists for streams so stream fusion takes place naturally?  It is pretty much the same
10:43:19 <lllllllllllll> valtih, Leaf is a data constructor that takes an int to give you a tree so Int -> Tree
10:45:52 <raek> can anyone point to a test suite that uses quickcheck? (I would like to see how quickcheck is used in practice)
10:46:26 <donri> xmonad?
10:46:30 <bennofs> raek: xmonad uses quickcheck in a pretty nice way
10:46:49 <donri> text? http://www.serpentine.com/blog/2013/12/30/testing-a-utf-8-decoder-with-vigour/
10:47:36 <donri> myself i used quickcheck with TH to test type class laws in safecopy https://github.com/acid-state/safecopy/blob/master/test/instances.hs
10:48:05 <shlevy> Is there a version of Data.Text that stores and shows everyting in NFD? It's annoying to have to use Data.Text.ICU.Normalize whenever operating on Texts
10:48:35 <geekosaur> NikO5, one thing that occurs to me is that it's not just an extra Show (actually two of them) but also (==) on String vs. Integer
10:49:05 <Twey> SrPx: There are a lot of lambda calculi and a lot of ways of implementing them :þ  Generally streams are used to provide lazy-list behaviour in a strict language; you can't just replace streams with lists unless you also make your evaluator non-strict
10:49:39 <Nik05> geekosaur yes so shouldnt that be slower? But it actually runs faster...
10:49:43 <Twey> Nik05: read is pretty slow
10:49:50 <geekosaur> but I have not profiled it
10:50:02 <Nik05> Twey but slower than show?
10:50:04 <Twey> It's a parser, and it handles ambiguous parses
10:50:25 <jmcarthur> SrPx: the conversion back and forth between streams and manifest lists (with rewrite rules to eliminate it when it makes sense) is still important for sharing
10:50:34 <benmachine> why should show be slow?
10:50:48 <SrPx> jmcarthur: sharing?
10:50:54 <Nik05> benmachine well i thought Integer -> String would be slower than String -> Integer
10:50:54 <Twey> Well, yes: show doesn't have to do nearly as much work, generally (though it depends what you're show'ing, I suppose)
10:51:03 <benmachine> Nik05: but why?
10:51:12 <jmcarthur> SrPx: e.g. replacing the head of a list with something else doesn't copy the tail of the list
10:51:36 <jmcarthur> SrPx: with just plain streams, you don't get that behavior. you have to reevaluate the whole list every time you use it, if you use it more than once
10:52:00 <jmcarthur> SrPx: so the ability to turn it into a lazy, manifest list is important sometimes
10:52:40 <EvanR2> im trying to buildExpressionParser to parse "a b" as function application and "a + b" as addition but with arbitrary amounts of space, but the two operator parsers overlap in case theres space so the one that fails consume input, cant figure out how to get the "try" effect for lookahead
10:53:02 <Nik05> benmachine because for Integer -> String you need to extract all digits using division and remainder, and with String -> Integer you can just add a Char and multiply by 10
10:53:36 <benmachine> Nik05: I see what you mean
10:53:44 <benmachine> however, read is weird
10:53:53 <benmachine> > read "((0))" :: Integer
10:53:54 <lambdabot>  0
10:54:17 <Nik05> is there a read that does less parsing and just stupid String -> Int?
10:55:03 <EvanR2> should i be trying to figure out how to tokenize
10:55:12 <benmachine> you might try Numeric.readDec but I'm not sure if it's what you want
10:55:14 <Nik05> oh right hoogle :P
10:55:16 <Twey> > reads "((0))" :: [(Integer, String)]
10:55:17 <lambdabot>  [(0,"")]
10:55:23 <Nik05> ah thanks benmachine i will check
10:56:14 <Twey> Read isn't defined in terms of read, it's defined in terms of readsPrec (parse with ambiguous parses and precedence)
10:59:18 <Nik05> benmachine: i think readDec does something else
11:00:14 <benmachine> > Numeric.readDec "0"
11:00:15 <lambdabot>  [(0,"")]
11:00:24 <Nik05> oh maybe it does :P
11:00:31 <benmachine> empty list = parse failure
11:00:39 <Nik05> ah ok
11:00:40 <benmachine> second component = unparsed input
11:00:44 <benmachine> > Numeric.readDec "0 bananas"
11:00:45 <lambdabot>  [(0," bananas")]
11:00:50 <shlevy> Is there a common function with type (b -> c) -> (a -> a -> b) -> a -> a -> c ?
11:01:08 <Twey> :t (.:)
11:01:09 <lambdabot>     Not in scope: `.:'
11:01:09 <lambdabot>     Perhaps you meant one of these:
11:01:09 <lambdabot>       `.' (imported from Data.Function),
11:01:44 <shlevy> Twey: where is that defined?
11:01:49 <Nik05> ok benmachine i changed read to fst . head . readDec
11:01:55 <Twey> @let (f .: g) x y = f (g x y)
11:01:56 <lambdabot>  Defined.
11:02:02 <Nik05> yep thats faster :)
11:02:11 <Twey> shlevy: Folklore; it's probably floating around in a few Hackage packages
11:02:14 <shlevy> ah
11:02:18 <shlevy> ok
11:02:18 <Nik05> but not faster than show :S
11:02:26 <Twey> :t (.) . (.)
11:02:27 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:03:37 <raek> donri: bennofs: thanks!
11:07:28 <FreeFull> @let (.:) = fmap . fmap
11:07:28 <lambdabot>  .L.hs:146:4:
11:07:28 <lambdabot>      Multiple declarations of `.:'
11:07:28 <lambdabot>      Declared at: .L.hs:142:1
11:07:29 <lambdabot>                   .L.hs:146:4
11:09:37 <Twey> @undefine
11:09:37 <lambdabot> Undefined.
11:09:55 <Twey> @let (.:) = fmap <$> fmap -- might as well go the whole hog…
11:09:55 <lambdabot>  .L.hs:142:8:
11:09:56 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'
11:09:56 <lambdabot>      The type variable `f0' is ambiguous
11:09:56 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
11:09:56 <lambdabot>      Note: there are several potential instances:
11:10:05 <magnap> :t fmap fmap fmap
11:10:06 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:10:10 * Twey blinks.
11:10:14 <benmachine> :D
11:10:16 <Twey> :t fmap <$> fmap
11:10:17 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:10:28 <Twey> I'm confused.
11:10:46 <benmachine> by what?
11:11:06 <Twey> Oh, is that the MMR?
11:11:19 <magnap> You fmap fmap over fmap.
11:11:27 <Twey> By lambdabot's complaint about a definiton of a well-typed term.
11:11:36 <benmachine> oh, yeah, probably
11:11:49 <Twey> magnap: Right; that's what I wanted to do.  :þ
11:12:06 <benmachine> @let (.:) :: (a -> b) -> f (f a) -> f (f b); (.:) = fmap fmap fmap
11:12:07 <lambdabot>  .L.hs:144:13:
11:12:07 <lambdabot>      No instance for (Functor f) arising from a use of `fmap'
11:12:07 <lambdabot>      Possible fix:
11:12:07 <lambdabot>        add (Functor f) to the context of
11:12:07 <lambdabot>          the type signature for .: :: (a -> b) -> f (f a) -> f (f b)
11:12:10 <benmachine> huh.
11:12:25 <benmachine> oh
11:12:25 <Twey> Well, that's wrong.  =)
11:12:26 <benmachine> wait
11:12:27 <benmachine> duh
11:12:37 <benmachine> @let (.:) :: Functor f => (a -> b) -> f (f a) -> f (f b); (.:) = fmap fmap fmap
11:12:38 <lambdabot>  Defined.
11:12:41 <benmachine> woo
11:12:55 <shlevy> :t (.:)
11:12:56 <lambdabot> Functor f => (a -> b) -> f (f a) -> f (f b)
11:13:06 * hackagebot phash 0.0.1 - Haskell bindings to pHash, the open source perceptual hash library  http://hackage.haskell.org/package/phash-0.0.1 (MichaelXavier)
11:13:09 <mauke> :t fmap fmap fmap
11:13:10 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:13:11 <Twey> benmachine: They don't have to be the same functor, though
11:13:15 <Twey> Right
11:13:20 <benmachine> oh, whatevs
11:13:25 <Twey> Hehe
11:13:29 <Twey> @undefine
11:13:29 <lambdabot> Undefined.
11:13:44 <Twey> @let (.:) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b);  (.:) = fmap <$> fmap
11:13:45 <lambdabot>  Defined.
11:13:59 <shlevy> :t (.:)
11:14:00 <lambdabot> (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:21:09 <NemesisD> does anyone know why you can't comment on the http://www.reddit.com/r/haskell_proposals subreddit?
11:21:26 <NemesisD> i just released a package for something that was requested 2 years ago :P
11:24:58 <lilred> hey guys, is there a standard entry point to ekmett's libraries?
11:25:09 <lilred> There's a lot of stuff, it looks really useful but I'm not sure where to start
11:26:02 <shergill> so who maintains ghc-7.6.3 on nix? when trying to install cabal-install 1.18 i get the following error: /nix/store/zlkc3mnixmkjccq841i5ir7cl4l780hi-binutils-2.23.1/bin/ld: cannot find -lz
11:26:30 <shergill> any idea how to fix it?
11:26:58 <countoren> hello everyone , i have a yesod app that got scafoold with yeso 1.2.4.1 i want to clone it to new machine , i use the cabal install yesod-platform yesod-bin command which install yesod 1.2.5.5 and now i have problem to do cabal install . is there away to downgrade the yesod platform in the new machine?
11:33:32 <Fristi> Hello
11:34:58 <Fristi> What would be the best strategy to work with lazy bytestring and strict bytestring api? My data structures have Binary (lazy) type class instances whie the api (leveldb, FFI C binding) has a strict bytestring api.
11:35:48 <Fristi> If I put 1,000,000 keys in there with the strict api it takes about 7 s on macbook, which is good .. but when i use the toStrict conversion with a lazy bytestring it takes about 18 seconds
11:35:53 <Fristi> what can i do about ?
11:37:37 <countoren> hello everyone , i have a yesod app that got scafoold with yeso 1.2.4.1 i want to clone it to new machine , i use the cabal install yesod-platform yesod-bin command which install yesod 1.2.5.5 and now i have problem to do cabal install . is there away to downgrade the yesod platform in the new machine?
11:39:18 <Athas> Hm, how do pure compilers usually deal with generating fresh names (to prevent name clashes) during transformations?
11:39:27 <Athas> I use a state monad with a counter.
11:39:55 <simpson> Athas: de Brujin indices are normally the way to do it, and your implementation isn't wrong, although it might be a little cumbersome.
11:40:29 <Athas> simpson: it is, at times.  I've never worked with de Bruijn indices in a compiler, but isn't it a bit onerous to keep track of them when moving code around?
11:40:33 <simpson> Athas: Maybe the bound package would help; a writeup is here: https://www.fpcomplete.com/user/edwardk/bound
11:40:51 <Athas> simpson: thank you, I will take a look.
11:50:53 <Fristi> ah found it :) blaze builder to the rescue
12:02:35 <SLi> Hey, I have a problem with ghc -M (dependencies for Makefile). It correctly generates the dependencies for each of the object files (*.o), making each of them depend from their source (*.hs) and the *.hi of the modules it imports. However that's only the dependencies for the compile phase; it seems that having to list the modules to link into a binary (apart from the main module) somewhat defeats the purpose of ghc -M...
12:02:36 <SLi> So currently I use ghc --make for linking (only), which works otherwise great, but naturally I wouldn't want to invoke it for each binary, whether it needs to be relinked or not, so I would need to know the .o dependencies anyway.
12:02:39 <FliPPeh> Stop breaking freenode!
12:05:38 <derdon> meh. when running my QuickCheck tests, one of them reports "*** Gave up! Passed only 22 tests." which results in the output "False" by the call of quickCheckAll
12:06:30 <derdon> how can I handle this case? the test checks the transitivity of a custom <= function so that only very few cases meet the necessary requirement
12:06:47 <derdon> prop_antisymmetric_lt n1 n2 = n1 <= n2 && n2 <= n1 ==> n1 == n2
12:07:09 <derdon> *I meant antisymmetric, sorry
14:43:37 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
14:43:37 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
14:49:03 <flebron> Can I ask QuickCheck to generate a list of Integers without repeats?
14:50:25 <ion> You could use nub.
14:51:31 <flebron> Well, then it'd be generating large instances with repeats, and nub isn't exactly performant for large lists :s
14:51:59 <flebron> (And yes, I know I can sort and then nub from Data.List.Ordered, but that'd give me only increasing lists.)
14:57:20 <yyyyy> flebron, what if you create an instance of a monad that carries an IntMap around. you then make sure that when you take a value out of it, it has to be a new value, which subsequently gets into the IntMap for further uses along?
15:04:04 <zipper> Uh where can I find the source of conjure? or any other implimentation of the bittorrent protocol in haskell?
15:04:52 <Seit6> hello
15:06:38 <pavonia> Is it possible to make the GHCi prompt only display the first loaded module name/the module loaded by :load?
15:06:42 <Seit6> can you please help me with data structure? currently i have flat list of all points inside 2d polygon and i want to access to all outermost points of that polygon in effcient way
15:06:53 <Seit6> outermost - points which are at borders of that octagon
15:07:14 <Seit6> i'm not sure which data structure is suitable for that purpose
15:09:15 <pavonia> Seit6: Not sure I understand correctly, maybe you want to store two partition sets of all points in the structure, where the first set includes the boundary and the second all inner points
15:09:16 <FreeFull> Seit6: You could use a list that stores the points in a different order
15:09:34 <FreeFull> What pavonia suggested is probably more reasonable
15:11:35 <Seit6> pavonia: it will be perfect to have "layers" of polygon accessible in efficient way, that is, first layr is outermost(borders) set of points, second is next to outermost and last one is a center of polygon
15:14:08 <pavonia> Seit6: What's the difference between next to outermost and center?
15:14:54 <pavonia> Like when you remove the hull of the polygon, you get the next layer?
15:18:49 <Seit6> pavonia: exactly
15:22:19 <pavonia> Seit6: maybe something like "data Polygon a = Center | Hull [a] (Polygon a)". That provides efficient retrieving, but not sure if updating is efficient too
15:22:52 <Rarrikins> Are there any niceties in making constructor types (like type Currency = Rational -> Amount) into instances of Eq, Ord, Show, etc. or must it all be done manually?
15:23:13 <quchen> "deriving (Eq, Ord, Show)"
15:23:32 <pavonia> that won't work here
15:23:32 <Rarrikins> It's not a data definition.
15:23:33 <quchen> Well, you can't make *type*s instances.
15:23:40 * hackagebot herringbone 0.0.6 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.6 (hdgarrood)
15:23:45 <Rarrikins> I mean with the appropriate extensions.
15:23:55 <Rarrikins> Like FlexibleInstances.
15:24:44 <quchen> -XTypeSynonymInstances may be what you're looking for then.
15:25:26 <quchen> But that just makes the instance declaration syntax nicer, it still won't allow you to have a `type`-specific instance.
15:26:01 <Rarrikins> Ahh, OK. So, no way to derive them automatically?
15:26:33 <quchen> If the type you're `type`ing already has an instance you get all the classes for free.
15:26:43 <quchen> All the instances, I mean.
15:26:53 <Rarrikins> I mean to get the instances.
15:27:05 <Rarrikins> Like deriving Eq for Rational -> Amount functions.
15:27:25 <quchen> type Foo = Bar  --  Foo is an instance of everything that Bar is (because Foo is identical to Bar).
15:27:46 <quchen> And you can't make Foo an instance of something that Bar isn't (and vice versa).
15:27:57 <Rarrikins> So, I have to manually make instances for Rational -> Amount?
15:28:31 <boom583> In Haskell functional programming, if I have a function that returns a pair, how can I call the function and do something to the first element (fst) and do something to the second element (snd)?
15:28:50 <quchen> `type` defines *synonyms*, it does not create a new type (that's what data and newtype do).
15:28:52 <erisco> :t uncurry
15:28:52 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:28:59 <erisco> boom583, ^
15:29:00 <sipa> let (foo,bar) = boomfunction some arguments go here
15:29:03 <Taneb> :t (***)
15:29:04 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:29:17 <Taneb> :t (***) `asAppliedTo` id
15:29:17 <lambdabot> (a -> a) -> (b' -> c') -> (a, b') -> (a, c')
15:29:23 <quchen> boom583: There is (***) in Control.Arrow.  (f *** g) (x,y) = (f x, g y)
15:29:33 <sipa> :t asAppliedTo
15:29:34 <lambdabot> (a -> b) -> a -> a -> b
15:29:39 <Taneb> :t (***) `asAppliedTo` (undefined :: a -> b)
15:29:40 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
15:29:49 <Taneb> :t (***) `asAppliedTo` (undefined :: a -> c)
15:29:50 <lambdabot> (a -> c) -> (b' -> c') -> (a, b') -> (c, c')
15:30:59 <Syao> I am new to functional programming and I am interested in how flexible/optimized FP can be in respect of program modification (source).
15:32:46 <jle`> Syao: your question is slightly unclear, could you be a little more specific?
15:33:18 <jle`> FP though is in general though more composable/flexible than imperative/impure coding
15:33:57 <boom583> thanks
15:37:15 <Syao> How flexible FP is in respect of effort needed to make logical change in the code? example: some data structure needs to be changed.
15:38:39 <quchen> That's typically pretty easy to the point where it's dull.
15:38:43 * hackagebot cheapskate 0.1 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1 (JohnMacFarlane)
15:38:43 <ChongLi> Syao: in some cases it's just a one-liner
15:38:44 * hackagebot SHA 1.6.2.1 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.2.1 (AdamWick)
15:38:52 <ChongLi> changing an import, for example
15:39:01 <quchen> Change data structure, compile, fix error, repeat. When it compiles it usually works (for small changes at least, not when you re-structure everything).
15:39:57 <ChongLi> going from Strings to ByteStrings can be really easy if you turn on OverloadedStrings
15:40:21 <shachaf> :-(
15:40:25 <quchen> Eww.
15:40:45 <ChongLi> what's wrong with that?
15:40:46 <shachaf> Don't do that. Strings and ByteStrings mean different things, and the instance IsString ByteString is broken.
15:40:53 <ChongLi> oh
15:41:07 <shachaf> (And there's no non-broken instance, really.)
15:41:13 <Taneb> <ChongLi> going from lazy Text to strict Text can be really easy, especially if you turn on OverloadedStrings
15:41:18 <Taneb> Better example
15:41:35 <Taneb> Throw String in there, why not
15:41:41 <Syao> I am talking about theoretical point of view, how flexible it can be.
15:41:46 <ChongLi> how about OverloadedLists for specifying Vectors?
15:42:24 <quchen> The issue is with the "convert to BS", not with the Overloaded* extensions.
15:43:46 <nh2> shachaf: the ByteString instance is broken? How did you mean
15:43:46 <quchen> Converting text to byte representations always comes with the "which encoding" issue.
15:44:37 <boom583> Suppose I want to create a function that generates random number given some initial state:   random :: Double -> (Double,Double)     It takes in a state and returns a pair of (new state, the random number)
15:44:38 <boom583> The returned new state will be the state for the next function call.
15:44:39 <boom583> But the first call to the function has NO STATE. Would you use Maybe to do this? Like so:  random :: Maybe Double -> (Double, Double)
15:44:42 <boom583> is this good practice?
15:45:11 <boom583> so Nothing denotes initial state
15:45:18 <quchen> Char is just a Unicode character, as far as I know. By having an automatic String->BS conversion, you implicitly assume some encoding (such as UTF-8).
15:46:46 <quchen> And when you have a BS that corresponds to some high codepoint "encode.decode" is typically broken. If you want to convert String to BS you'll have to do it manually, and keep the encoding in mind.
15:48:16 <flebron> Hi. Is my Arbitrary instance wrong here? http://lpaste.net/98018 . Running the test never ends.
15:48:28 <Syao> boom583, just a question, how the much "random" number can be in Parallel/Concurrency system when you have this kind of generator?
15:48:28 <jle`> Syao: question is pretty vague, can you be more specific?
15:49:04 <flebron> Err, it's not even the Arbitrary instance, just the test. The test doesn't actually use the instance :s
15:49:09 <quchen> boom583: The initial state is typically a seed here. But if you want to have no initial seed (i.e. an internal default), Maybe sounds like a solution (to an odd problem).
15:49:24 <boom583> ok thanks
15:50:11 <quchen> I think a better solution would be writing it with an explicit seed and then in the end providing a "add default seed" wrapper.
15:50:29 <jle`> randomSeedless :: (Double, Double)
15:50:42 <boom583> good point
15:50:46 <jle`> randomSeedless = random def
15:50:51 <jle`> default seed
15:51:08 <roboguy_> hmm, I'm not sure I really understand the reflection package. the motivation is for passing around global configuration data, right?
15:54:42 <Syao> jle', it's a very abstract question. the main idea is
15:55:29 <jle`> Syao: well then could you clarify the question?
15:55:55 <jle`> how flexible is x ?
15:56:08 <jle`> flexible in what contexts?
15:56:14 <jle`> compared to whawt?
15:57:27 <jle`> what does flexible even mean in your question?
15:59:17 <Syao> jle', whether fp can abstract the things in such high level that you will not need to rewrite/fix a lot of code every time you need some minor changes.
15:59:42 <erisco> boom you have left
15:59:50 <erisco> I was going to tell you that you probably want an unfold
15:59:57 <jle`> Syao: then we already said yes :)
16:00:28 <quchen> Syao: "FP" is a very general term. In Haskell small changes are usually trivial.
16:01:00 <erisco> also depends on what changes you're talking about
16:01:38 <erisco> but typically dependencies are a bit weaker when there is no state
16:01:58 <erisco> or at least you won't be as surprised by changes (more likely to be statically caught)
16:04:47 <Syao> in other words, can we create certain base elements of world view in FP, like the math does by layering absolutely correct mathematical rules to complex rules.
16:08:43 <Syao> quchen, I specially not talking about Haskell, it might be that the Haskell needs to go up to a certain level before it is possible to do that..
16:09:51 <frohe> In Learn You a Haskell the author states: "Aaay! When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of them polymorphic functions, [a] or (Ord a) => Maybe a and stuff."
16:10:40 <frohe> Well, I don't understand. [a] or Ord a => Maybe a are concrete types ?
16:10:56 <simpson> frohe: They are polymorphic, but they are concrete.
16:11:00 <geekosaur> compare to something like "Maybe"
16:11:10 <geekosaur> it is incomplete and cannot have values
16:11:13 <frohe> Maybe is a type constructor, I see this
16:11:15 <simpson> frohe: `Maybe` is not concrete; it needs to have one more type applied to it to become concrete.
16:11:41 <Syao> I think its a hard question what I am asking, but I hope there are some very smart people that does know something regarding the situation.
16:11:44 <ChongLi> quchen: ahhh, I completely forgot about encoding
16:12:13 <Syao> Ūdo
16:12:24 <Syao>  **do know
16:12:25 <frohe> thanks :)
16:16:53 <Syao> p.s. excuse my English mistakes. English is not my native language..
16:17:19 <ChongLi> Syao: that's fine, Haskell is a global language :)
16:17:47 <flebron> Syao: I don't think the question is particularly hard, it's just a bit vague. Yes, changing things is often easy in Haskell, since you can reason about components separately, due to referential transparency.
16:20:56 <colprofdrmcbeard> Anyone here using the chart package? I can't get the Grid type to render properly.
16:22:30 <roboguy_> If I'm writing a program to play a board game and somewhere (somewhat) deep in the function calls something needs the board size, is there a good way to pass that information implicitly with the reflection package?
16:23:07 <ChongLi> the reflection package?
16:23:37 <roboguy_> ChongLi: yeah, http://hackage.haskell.org/package/reflection
16:23:43 <ChongLi> seems like an odd choice for a board game
16:23:52 <roboguy_> ChongLi: how so?
16:24:35 <Syao> flebron, ChongLi gave me an idea to a better formation of my question: How much effort would be required to my "simple" humane thoughts to express in ex. Haskell language, that the other person/computer could understand? Second question is: what could be effort difference in FP vs OO?
16:25:03 <ChongLi> roboguy_: hmmm, that's a difficult question to answer
16:25:15 <ChongLi> I guess I'd just have to ask why?
16:25:52 <roboguy_> ChongLi: well, I would rather not pass the board size explicitly when only one function needs it and it's deeply nested in the function calls
16:25:58 <Syao> flebron, I think the question is on a different level then a simple math problem, that's why I think its hard.
16:26:12 <roboguy_> ChongLi: I was thinking about using the reader monad, but it would be nice if there was a way to make it even more implicit
16:26:37 <ChongLi> roboguy_: it can't be a top-level binding?
16:26:45 <ChongLi> I guess it's probably configurable
16:26:49 <roboguy_> ChongLi: it depends on the input
16:26:49 <roboguy_> yeah
16:27:23 <roboguy_> also, I'm curious about the different ways this kind of problem could be solved, since it's somewhat common
16:27:31 <ChongLi> how deeply-nested are we talking about?
16:28:28 <ChongLi> and that subtly implies a possible answer
16:28:33 <ChongLi> reduce the levels of nesting
16:28:38 <roboguy_> ChongLi: about 5+ calls deep
16:28:59 <roboguy_> the only thing that needs it is a function called "valid" that checks to see if a given point is a valid board point
16:29:06 <tristan_1> http://plv.mpi-sws.org/backpack/backpack-poster.pdf
16:29:42 <ChongLi> what sort of data type are you using to represent the game state itself?
16:29:52 <ChongLi> seems like you could just shove it in there
16:30:35 <roboguy_> ChongLi: actually, that's a good point. I'll try that out and see how it works
16:30:41 <ChongLi> it's a common idiom in Haskell to have one or two data types with a lot of records
16:31:07 <roboguy_> It's just a type synonym for a vector of vectors, but that probably wouldn't be hard to change
16:31:10 <ChongLi> a good example of that is Xmonad's config
16:31:29 <ChongLi> http://hackage.haskell.org/package/xmonad-0.11/docs/XMonad-Core.html#t:XConfig
16:32:11 <ChongLi> basically all the user-facing config is in that one type
16:32:19 <roboguy_> some day I need to figure reflection out though
16:32:22 <colprofdrmcbeard> roboguy_: sounds like you could just make a function that computes the board size based on the vector type
16:32:47 <roboguy_> colprofdrmcbeard: that's another good point. didn't think of that
16:32:50 <boom583> How can I write the "first machine" run function using parameters? https://pastee.org/fcks7
16:32:58 <imandric1> Hi, haskell community! Can anybody explain me where haskell is used in the real life? I would like to study this nice language, but I am not sure if there is a sense in doing that...
16:33:11 <ChongLi> roboguy_: it's a smart thing that you used a type synonym, by the way :)
16:33:13 <boom583> run x =
16:33:26 <colprofdrmcbeard> imandric1: A lot of financial companies use it, among others.
16:33:29 <ChongLi> it gives you a hook to change into a full data type
16:33:37 <geekosaur> @quote academia
16:33:37 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
16:33:38 <boom583> then I can do cases run x |x==0 =
16:33:38 <ChongLi> with less refactoring
16:33:39 <boom583> etc
16:33:40 <roboguy_> ChongLi: yeah, I tried to abstract things out for just this sort of thing (in case I have to change something about the board representation)
16:33:41 <imandric1> colprofdrmcbeard: really? which ones?
16:33:55 <ChongLi> roboguy_: have you looked at lens?
16:34:21 <roboguy_> ChongLi: a little bit, yeah. I've never really used it for anything practical, but I've played with it a little and I think I understand the basics
16:34:24 <colprofdrmcbeard> imandric1: http://www.haskell.org/haskellwiki/Haskell_in_industry
16:34:36 <stolaruk> roboguy_: You probably could use the Reader monad or the State monad. Like ChongLi said you could put all your state into one record type. Lenses offer an elegant way to deal with state as a record.
16:34:40 <colprofdrmcbeard> facebook also uses it.
16:34:42 <boom583> imandric1: A famous one: http://www.janestreet.com They use OCaml which is similar to Haskell
16:34:45 <ChongLi> roboguy_: it's really nice
16:35:02 <imandric1> When trying to install some packages via cabal, I very often have troubles because of some incompatibilities... that is making me think that it is not so developped...
16:35:07 <boom583> Noone?
16:35:10 <imandric1> thanks guys for the links
16:35:10 <colprofdrmcbeard> ChongLi: I've been out of the haskell world for a while and I never heard of lens before... is it new?
16:35:19 <roboguy_> ChongLi: yeah it is. the main problem I've been having with it is that I'm not used to it, so I rarely think of solving problems in terms of it (unfortunately). I guess that comes with practice
16:35:25 <ChongLi> colprofdrmcbeard: relatively
16:35:38 <ChongLi> colprofdrmcbeard: http://hackage.haskell.org/package/lens
16:35:42 <roboguy_> stolaruk: I think I might just keep the board representation the same and use the vector size
16:35:49 <ChongLi> don't look at the flow chart :)
16:35:54 <colprofdrmcbeard> ChongLi: know of a good intro?
16:36:04 <Taneb> colprofdrmcbeard, lens pretty much takes Haskell and adds onto it something ridiculous
16:36:12 <ChongLi> colprofdrmcbeard: there's some good links right on that page
16:36:15 <Syao> lle', what do think of my question?
16:36:21 <colprofdrmcbeard> ChongLi: kthx
16:36:23 <ChongLi> the readme on github and the youtube video
16:36:23 <Taneb> colprofdrmcbeard, http://youtu.be/cefnmjtAolY?hd=1 is good
16:36:24 <roboguy_> colprofdrmcbeard: lens is probably the next really important thing with haskell
16:36:33 <Syao> jle', what do think of my question?
16:36:45 <zRecursive> Taneb: Lens is ridiculous ?
16:36:55 <stolaruk> colprofdrmcbeard: Very good intro here: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
16:37:10 <ChongLi> zRecursive: it's really mind-boggling
16:37:15 <Taneb> zRecursive, as someone who uses lens a lot, I can tell you it is ridiculous
16:37:16 <ChongLi> in a good way
16:37:22 <flebron> Syao: I'm sorry, I still think the question is too vague for any meaningful answer. Haskell expresses programs, not general communication.
16:37:50 <stolaruk> That talk on YouTube is a serious deep dive.
16:38:03 <zRecursive> too bad, i am preparing to study lens later
16:38:11 <ChongLi> zRecursive: wh ytoo bad?
16:38:15 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] & sumOf (traverse . _Left . decimal)
16:38:17 <lambdabot>  99
16:38:31 <stolaruk> Lens is as rediculous as you wanna make it
16:38:44 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] & sumOf (traverse . _Left . decimal . filtered (< 50))
16:38:45 <lambdabot>  5
16:38:47 <zRecursive> ChongLi: maybe i will give up learning it
16:38:57 <ChongLi> zRecursive: don't do that!
16:39:06 <Taneb> zRecursive, I use ridiculous as a compliment
16:39:20 <zRecursive> really ?
16:39:23 <stolaruk> A Haskell newbie can pick up the basics if they read through some of the easier tutorials.
16:39:33 <colprofdrmcbeard> boom583: use a lambda?
16:39:40 <boom583> colprofdrmcbeard: how?
16:39:41 <roboguy_> sometime, I need to just say "I'm going to use lens for this project" so that I can get used to it
16:39:56 <ChongLi> zRecursive: what I mean to say is that it's so powerful and elegant you'll think you've learned a new programming language
16:40:01 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] & traverse . _Left . decimal . filtered (< 50) .|.~ 2
16:40:02 <lambdabot>  [Left "7",Left "hello",Right True,Left "94"]
16:40:06 <boom583> colprofdrmcbeard: oh i see!!!!
16:40:12 <stolaruk> It kinda is like a new lang on top of Haskell
16:40:15 <boom583> colprofdrmcbeard: THANKS.
16:40:17 <zRecursive> I am learning using IORef to share variables between functions now
16:40:27 <colprofdrmcbeard> boom583: np
16:40:32 <zRecursive> next will be Lens
16:40:49 <zRecursive> ChongLi: i see now
16:41:39 <ChongLi> for a long time people were jealous of the power Lisp programmers have to steal their hard-coded language features and make them into macros
16:41:39 <ChongLi> well, lens is something for Lispers to be jealous of
16:41:47 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] ^.. traverse . _Left . decimal . filtered (< 50) . taking 8 bits
16:41:48 <lambdabot>  [True,False,True,False,False,False,False,False]
16:42:01 <zRecursive> because i donot want to pass it around among the functions. By googling, i found IORef ...
16:42:09 <stolaruk> ChongLi: Wow that's a great point.
16:42:14 <stolaruk> haha
16:42:38 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] ^.. traverse . _Left . decimal . filtered (< 50) . byteAt 1 .~ 1
16:42:40 <lambdabot>  Couldn't match type `[GHC.Word.Word8]'
16:42:40 <lambdabot>                with `(a0 -> Control.Lens.Internal.Setter.Mutator b0)
16:42:40 <lambdabot>                      -> s0 -> Control.Lens.Internal.Setter.Mutator t0'
16:42:40 <lambdabot>  Expected type: Control.Lens.Setter.ASetter s0 t0 a0 b0
16:42:40 <lambdabot>    Actual type: [GHC.Word.Word8]
16:42:45 <roboguy_> well, I would imagine you could do lens in lisp
16:42:50 <colprofdrmcbeard> ChongLi: so basically, you get your C-like field accessors and can tinker with state?
16:42:52 <Taneb> > [Left "5", Left "hello", Right True, Left "94"] & traverse . _Left . decimal . filtered (< 50) . byteAt 1 .~ 1
16:42:54 <lambdabot>  [Left "261",Left "hello",Right True,Left "94"]
16:42:56 <roboguy_> the static typing probably helps the implementation though
16:43:09 <Taneb> roboguy_, it relies a lot on higher-kinded type classes
16:43:12 <stolaruk> ChongLi: Still would be great if Haskell did have something like Lisp macros; google around tho and you'll find Haskellers talking about how they are actually not really needed in Haskell
16:43:29 <ChongLi> colprofdrmcbeard: the difference is that the "field" accessors are entirely abstract
16:43:43 <zRecursive> Will lens take down the performance of haskell program ?
16:43:57 <roboguy_> colprofdrmcbeard: it's a lot more powerful than that, actually
16:44:07 <ChongLi> stolaruk: yeah, the only real need is to generate some boilerplate
16:44:13 <Taneb> Z
16:44:14 <ChongLi> and that's covered by TH
16:44:15 <Taneb> ...
16:44:22 <Taneb> zRecursive, barely, it's very finely tunee
16:44:23 <stolaruk> ChongLi: I haven't gotten into TH much yet.
16:44:24 <Taneb> *tuned
16:44:40 <zRecursive> ok
16:44:40 <roboguy_> Taneb: if you were determined, you could probably implement some fancy static typing in lisp. I'm not sure how much it would be worth it though
16:44:42 <ChongLi> stolaruk: the main use for it, for me, is to generate lenses :)
16:44:42 <Syao> flebron, I know, may be it is not the best channel to ask such a question.. May be you know better one? I think that the haskell channel do have smartest people that's why I came here.. P.S. don't you think that this is biggest problem in programming world?
16:44:44 <stolaruk> ChongLi: I've only used it to setup my lenses. :)
16:44:49 <ChongLi> haha
16:44:49 <stolaruk> hehe
16:45:37 <stolaruk> flebron: Go ahead and learn Haskell if you think you
16:45:41 <stolaruk> want to code something in it.
16:45:56 <ChongLi> or even if you don't
16:45:57 <zRecursive> @hoogle IORef
16:45:58 <lambdabot> Data.IORef module Data.IORef
16:45:58 <lambdabot> Data.IORef data IORef a
16:45:58 <lambdabot> package IORefCAS
16:46:05 <ChongLi> you'll be glad you learned it
16:46:35 <stolaruk> will be especially hard to grasp if you don't bother to code some nontrivial thing in it
16:46:37 <colprofdrmcbeard> this reminds me, is there something in lambdabot's code that makes hoogle suggest packages that the cli hoogle doesn't have?
16:47:03 <ChongLi> colprofdrmcbeard: the cli hoogle has commands for rebuilding its database
16:47:17 <ChongLi> there is an "all" option
16:47:32 <ChongLi> but last time I tried it it failed on reactive-glut :(
16:47:38 <flebron> stolaruk: ?
16:47:49 <maxiepoo> so what's the best package for markdown->html? Pandoc is pretty heavy and seems to only handle Strings so I'm looking for alternatives
16:48:01 <colprofdrmcbeard> ChongLi: +all never works for me. I installed rehoo to just combine everything but that sounds like using an atomic bomb to squash an ant.
16:48:08 <stolaruk> ChongLi: Have you seen http://newartisans.com/2009/03/hello-haskell-goodbye-lisp/ Kinda interesting.
16:48:15 <stolaruk> flebron: Hmm?
16:48:39 <flebron> stolaruk: You said my name a minute ago. "stolaruk | flebron: Go ahead and learn Haskell if you think you want to code something in it."
16:48:58 <ChongLi> stolaruk: yeah
16:49:16 <ChongLi> one thing not many people mention is the added power of haskell functions vs lisp macros
16:49:17 <stolaruk> flebron: I thought you are considering whether or not to learn Haskell? Maybe I misunderstood.
16:49:24 <aleksejs_> which is the fastest prime generator on Haskel?
16:49:44 <ChongLi> lisp macros disappear at runtime, thus they can't be passed to a higher-order function
16:49:55 <boom583> I have two simple "machines": https://pastee.org/z8325
16:49:55 <boom583> One adds 1, the other adds 2.
16:49:56 <boom583> Problem: Machines should ALWAYS turn Nothing into Nothing. How do I avoid the code repetition in both machines?
16:50:05 <flebron> stolaruk: Perhaps you misread someone else's name as mind :p
16:50:08 <flebron> *mine
16:50:18 <stolaruk> I don't think Lisp has currying and partial application, either.
16:50:24 <stolaruk> flebron: Ok, sorry.
16:50:38 <colprofdrmcbeard> boom583: hint: Maybe is an instance of Functor
16:50:41 <roboguy_> boom583: fmap?
16:50:50 <ChongLi> boom583: turn the constants 1 and 2 into arguments
16:51:21 <eazar001> aleksejs_: I don't know about fastest, but i might be worth check this out -> http://hackage.haskell.org/package/primes
16:51:23 <ChongLi> oh, and fmap
16:51:24 <ChongLi> haha
16:51:33 <boom583> hmm, gotta look that up
16:51:37 <boom583> thanks
16:51:44 <danilo2> Hello! Is it possible to make this 4 line code working? I was trying toi write explicite rankNTypes or wrap a function in a newtype, but still without success: http://lpaste.net/97997
16:52:00 <ChongLi> > fmap (+1) (Just 3)
16:52:01 <lambdabot>  Just 4
16:52:07 <ChongLi> > fmap (+1) Nothing
16:52:08 <lambdabot>  Nothing
16:52:55 <roboguy_> boom583: you should read the chapters on Functors, Applicatives and Monads in Learn You a Haskell
16:53:08 <boom583> roboguy_: yeah i haven't gotten to those yet
16:53:24 <colprofdrmcbeard> @where lyah
16:53:24 <lambdabot> http://www.learnyouahaskell.com/
16:53:27 <roboguy_> Functor is what you want for this
16:53:28 <stolaruk> > (fmap . fmap) odd $ Just (Just 1))
16:53:28 <lambdabot>  <hint>:1:34: parse error on input `)'
16:53:43 <stolaruk> > (fmap . fmap) odd $ Just (Just 1)
16:53:44 <lambdabot>  Just (Just True)
16:53:48 <boom583> roboguy_: thanks
16:54:28 <roboguy_> > duplicate . fmap . join . odd $ Just (Just 1)
16:54:29 <lambdabot>  Not in scope: `duplicate'
16:54:29 <lambdabot>  Perhaps you meant one of these:
16:54:29 <lambdabot>    `replicate' (imported from Data.List),
16:54:29 <lambdabot>    `BSC.replicate' (imported from Data.ByteString.Char8),
16:54:29 <lambdabot>    `BSLC.replicate' (imported from Data.ByteString.Lazy.Char8)
16:54:36 <roboguy_> hmm, no comonads I guess
16:54:42 <aleksejs_> boom583, this also is helpful for beginners http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:55:08 <boom583> aleksejs_: thx i'll look at that too
16:55:20 <jle`> i like <$> :D you can read it like "apply inside"
16:55:26 <jle`> > (*2) $ 3
16:55:28 <lambdabot>  6
16:55:32 <jle`> > (*2) <$> Just 3
16:55:32 <ChongLi> costate comonad coalgebras :)
16:55:33 <lambdabot>  Just 6
16:55:39 <ChongLi> lenses
16:55:45 <Eduard_Munteanu> danilo2: your function isn't polymorphic, it's tied to that 'a' in 'Poly a'
16:55:48 <jle`> (*2) <$> Nothing
16:55:55 <roboguy_> actually there wouldn't be a Maybe Comonad anyway, never mind
16:56:11 <Eduard_Munteanu> danilo2: instead, you want   newtype Poly = Poly { fromPoly :: forall a. a -> a }
16:57:38 <danilo2> Eduard_Munteanu: hmm, interesting, thannk you :)
16:58:20 <mauke> danilo2: http://lpaste.net/98021
16:58:32 <roboguy_> aleksejs_: I feel like it could cause problems later if someone continues to think of it as a box, but I guess that's okay as an introduction
16:59:02 <mauke> I think it boils down to >>= being unhelpful
16:59:55 <Eduard_Munteanu> Ah, I see.
17:00:04 <colprofdrmcbeard> This code http://lpaste.net/98022 doesn't make the Grid I'd expect
17:00:29 <colprofdrmcbeard> In reference to my original question. I get two graphs atop one another, not two rows of three.
17:00:40 <udevd> > id (+2) 1
17:00:42 <lambdabot>  3
17:00:50 <ChongLi> colprofdrmcbeard: why all the newStdGens?
17:01:00 <roboguy_> colprofdrmcbeard: couldn't you just use one StdGen?
17:01:19 <colprofdrmcbeard> honestly never used random numbers. I was just making some fake data.
17:01:54 <ChongLi> :t randoms
17:01:55 <lambdabot> (RandomGen g, Random a) => g -> [a]
17:02:18 <ChongLi> with one StdGen you can have an infinte stream of random values :)
17:02:34 <ChongLi> well, it's not really infinite; it will eventually repeat
17:02:48 <colprofdrmcbeard> ChongLi: wouldn't I have to drop the values from it I've previously used?
17:02:53 <jle`> well..an infinite stream of values ;)
17:03:46 <ChongLi> colprofdrmcbeard: no
17:04:00 <roboguy_> colprofdrmcbeard: it depends on how exactly you use it. you could map over it and take a certain number of items for instance
17:04:01 <ChongLi> just discard the head and move forward
17:04:06 <ChongLi> the GC will take care of the rest
17:04:46 <Eduard_Munteanu> You can make a generator that automatically drops using State.
17:04:49 <ChongLi> or if you'd prefer to do explicit recursion (maybe a forever loop?) you can use a State monad to keep track
17:04:53 <ChongLi> yeah
17:05:04 <colprofdrmcbeard> I mean when I take 100, I'd have to do something before I use it again with take 100
17:05:43 <ChongLi> colprofdrmcbeard: that's because your flow of control is returning to the same place
17:05:55 <ChongLi> you want to forget about that and move forward
17:06:12 <ChongLi> does that make sense?
17:06:52 <colprofdrmcbeard> yes, although for pulling 6 100-element lists, it sounds like keeping track of the state is overkill
17:07:01 <colprofdrmcbeard> even dispensing with the values seems unnecessary.
17:07:25 <roboguy_> colprofdrmcbeard: why would you have 6 of them?
17:07:37 <colprofdrmcbeard> definitely the multiplicity of bindings in that code is egregious, but I'm testing why I can't get the graph to work.
17:07:54 <roboguy_> colprofdrmcbeard: what's the graph doing?
17:07:58 <colprofdrmcbeard> roboguy_ I just needed 6 different lists to simulate different data sets for graphing.
17:08:38 <colprofdrmcbeard> I can't get the Grid layout to display properly. I get one graph above another, but I expect two rows of three graphs.
17:08:48 <colprofdrmcbeard> the PNG file is the right dimension, but four graphs are missing.
17:09:29 <ChongLi> colprofdrmcbeard: have you discovered the composition operator?
17:09:41 <ChongLi> :t (.)
17:09:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:09:45 <colprofdrmcbeard> yeah
17:10:36 <ChongLi> you could do this: let gs = map tval . (addMargins (2,2,2,2)) . sparkLineToRenderable . mkSmSpk . mkRandList $ gl
17:10:41 <ChongLi> err
17:10:53 <ChongLi> let gs = map (tval . (addMargins (2,2,2,2)) . sparkLineToRenderable . mkSmSpk . mkRandList) $ gl
17:11:28 <colprofdrmcbeard> ChongLi: oh yeah, I know I can boil that down a lot more. It's just a throwaway test.
17:12:38 <ChongLi> does anyone know the URL to luite's paste thingy?
17:13:03 <ChongLi> it evaluates and can do drawing of haskell code in the browser?
17:13:11 <ChongLi> I don't know if it'd be relevant here
17:13:56 <colprofdrmcbeard> I'm hoping that my cairo library isn't broken. I don't suspect a bug in the library and I don't see what's wrong with my invocation.
17:15:15 <Fylwind> wait, you could do crazy things like say ((== x) -> True) in view patterns and make arbitrarily complicated custom pattern matching?
17:15:22 <ChongLi> yeah, there's no real way for me to know why the code doesn't work
17:16:03 <colprofdrmcbeard> well, other than installing chart and chart-cairo and running it
17:16:23 <colprofdrmcbeard> i was hoping i'd bump into someone that's used chart tonight
17:17:02 <ChongLi> I would if I had more time
17:17:07 <ChongLi> I'm about to go to bed
17:17:42 <Fylwind> Eduard_Munteanu: [this was from a few days ago] thanks for the help btw, your idea does actually work :3  Show (f (Fix f)) => Eq (Fix f) with Undecidable on; however now i'm kinda regretting the decision of using Fix because now I have Fx's littering everywhere in my code
17:19:42 <Syao> exit
17:20:54 <colmcbeardman> man my internet sucks.
17:23:00 <udevd> @type map (flip id)
17:23:01 <lambdabot> [a] -> [(a -> c) -> c]
17:23:08 <udevd> @type map (flip.id)
17:23:09 <lambdabot> [a -> b -> c] -> [b -> a -> c]
17:23:21 <udevd> @type map . flip id
17:23:22 <lambdabot> a -> [a -> b] -> [b]
17:23:24 <Fylwind> @info (<$>)
17:23:24 <lambdabot> (<$>)
17:23:36 <udevd> @type flip $ map . flip id
17:23:36 <lambdabot> [a -> b] -> a -> [b]
17:25:14 <ChongLi> now that's rather itneresting
17:28:55 * hackagebot herringbone 0.0.7 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.7 (hdgarrood)
17:29:32 <Fylwind> is there a lambdabot feature that allows me to check fixity of an operator?
17:30:32 <k00mi> @info ($)
17:30:32 <lambdabot> ($)
17:30:46 <Fylwind> tried that earlier :c
17:30:51 <mauke> there never has been an info command
17:30:58 <k00mi> hm, :info in ghci tells you the fixity
17:31:17 <colprofdrmcbeard> hoogle --info doesn't know.
17:31:46 <jle`> yeah you probably need to ghci it
17:32:55 <colprofdrmcbeard> it wouldn't be too hard for something like hoogle to learn how to do that, though
17:33:17 <Fylwind> i need to like print a chart or something because I can never remember the precedences
17:34:46 <mauke> I just use intuition
17:35:31 <AVM> can anyone explain why I get an "Illegal polymorphic or qualified type: EventSystemT MyEvent m" in this line of code
17:35:41 <k00mi> I use parentheses :)
17:35:41 <AVM> instance (Monad m) => MonadEventSystem MyEvent (EventSystemT MyEvent m) where
17:35:42 <srhb> Function application is high, $ is low, everything else is rarely an issue... :P
17:35:49 <colprofdrmcbeard> Flywind: ghci > chart <<EOF \ :info ListOfOperators \ EOF
17:36:01 <colprofdrmcbeard> :P
17:36:14 <AVM> or even what that error means exactly
17:36:44 <AVM> i think it might be a problem with my kinds but im not sure
17:37:29 <Fylwind> colprofdrmcbeard: heh :)
17:38:07 <AVM> error starts at MonadEventSystem
17:39:39 <k00mi> AVM: does it say something like "enable FlexibleInstances"?
17:39:48 <roboguy_> why isn't there a Functor instance for First?
17:40:01 <AVM> nope it doesnt suggest any extensions
17:40:45 <srhb> roboguy_: What is First?
17:40:54 <roboguy_> srhb: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:First
17:40:54 <AVM> im trying to write a monad transformer in the same style as in mtl
17:41:44 <maxiepoo> roboguy_, I guess you're just supposed to unwrap it into a maybe asap
17:42:03 <srhb> Indeed.
17:42:08 <roboguy_> maxiepoo: hmm, that seems less convenient that it could be
17:42:35 <maxiepoo> you might be able to use an Iso for this?
17:42:39 <maxiepoo> or a lens
17:42:55 <roboguy_> maxiepoo: yeah I was thinking about that
17:43:38 <AVM> or you could write ur own instance
17:44:47 <colprofdrmcbeard> lulz
17:45:18 <ccnp123> sry to be a noob but im stuck in cabal hell trying to install Happy... output looks like this: Configuring happy-1.19.2... Building happy-1.19.2... Preprocessing executable 'happy' for happy-1.19.2... setup: The program happy is required but it could not be found
17:45:36 <AVM> windows or unix
17:46:20 <ccnp123> unix
17:46:26 <ccnp123> i think its a path thing
17:46:32 <derdon> ccnp123: I think so too
17:46:43 <derdon> ccnp123: I once had the exact same problem and it was my PATH
17:46:56 <eazar001> ccnp123: check your /home/.cabal/bin
17:47:00 <derdon> ccnp123: start a new shell to be sure the updated PATH is used
17:47:03 <eazar001> is happy there?
17:47:22 <geekosaur> happy needs itself to build?
17:47:33 <ccnp123> just not sure what dirs to add... i tried doing this in a cabal sandbox to get out of the other hell i was stuck in, not really sure how this all works though
17:47:42 <eazar001> or actually /usr/local/bin
17:48:04 <eazar001> and like everyone else suggested make sure that it is on your $PATH
17:48:14 <ccnp123> in ~/.cabal i have no bin dir, which is weird
17:48:22 <eazar001> i was wrong sorry
17:48:25 <eazar001> try /usr/local/bin
17:48:27 <eazar001> there right?
17:48:42 <ccnp123> no happy in /usr/local/bin
17:48:49 <ccnp123> and /usr/local/bin is on my PATH
17:48:52 <eazar001> that could be the problem
17:49:19 <eazar001> that should have been one of the first things installed when building your haskell platform
17:49:34 <ccnp123> right what do you suggest i do about it?
17:49:34 <colprofdrmcbeard> unless they installed it from a package mangler.
17:49:56 <eazar001> you could go back to the source ....
17:50:02 <eazar001> and find the Happy package
17:50:05 <eazar001> and build it manually
17:50:15 <eazar001> then manually drop it in your /usr/local/bin
17:50:22 <ccnp123> :( I guess (such a pain in the ass)
17:50:23 <eazar001> or just rebuild the platform .... but that could break things
17:50:27 <colprofdrmcbeard> ccnp123: what flavor of lunix are you on?
17:50:27 <eazar001> yea ....
17:50:32 <eazar001> that's why i say don't rebuild platform
17:50:52 <eazar001> yea that is a good question ...
17:50:57 <eazar001> what is your linux distro?
17:51:08 <ccnp123> freebsd 9.1
17:51:19 <srhb> Saw that coming. :-)
17:51:20 <colprofdrmcbeard> did you install haskell from ports?
17:51:27 <ccnp123> yup
17:51:38 <colprofdrmcbeard> ccnp123: look for happy in ports.
17:51:46 <eazar001> [=
17:51:46 <ccnp123> ooh good idea
17:51:57 <colprofdrmcbeard> ubongo packages it separately.
17:52:22 <colprofdrmcbeard> i keep meaning to dike out all the haskell stuff i have installed with crapt and redo it all by hand.
17:53:51 <srhb> I just use the package from hackage.org, least troublesome way in my experience.
17:53:57 <srhb> Er, haskell.org
17:54:36 <srhb> Sheesh, and by that I mean haskell.org/ghc
17:54:48 <ccnp123> ok stuff is installing, i'll let you know how it goes
17:54:55 <L8D> How can I fix the precedence of this code block so I don't need parenthases? https://gist.github.com/L8D/8276925
17:55:22 <srhb> L8D: Holy batman, use a do block.
17:55:33 <L8D> I'm trying not to
17:55:37 <colprofdrmcbeard> srhb: yeah, i honestly regret not compiling haskell platform instead of crapt-getting it.
17:55:47 <srhb> sectioned (.) and "flip" in the same line -- yikes
17:56:15 <eazar001> whats crapt?
17:56:24 <colprofdrmcbeard> crapt = apt, if you hate apt.
17:56:27 <eazar001> lol
17:56:29 <eazar001> i see
17:56:35 <colprofdrmcbeard> likewise with ubongo and lunix.
17:56:43 <eazar001> yea .... i use arch's pacman ....
17:56:55 <eazar001> but the platform is outta date .... even for a supposedly "cutting edge" distro
17:57:03 <colprofdrmcbeard> in a perfect world, plan 9.
17:57:06 <eazar001> so i opted for manual compilation ... it just made sense
17:57:08 <arpunk> colprofdrmcbeard: amen
17:57:09 <geekosaur> doesn't arch stow the up to date one in an overlay?
17:57:17 <eazar001> does it?
17:57:24 <simpson> I think that that's Gentoo, not Arch.
17:57:33 <colprofdrmcbeard> arpunk: someone ported ghc to plan9
17:57:36 <colprofdrmcbeard> or maybe it was hugs.
17:57:38 <dario`> aur probably has more recent haskell-platform
17:57:43 <eazar001> i checked AUR ... i'm pretty sure 2012 was the latest
17:58:04 <arpunk> colprofdrmcbeard: I think it was hugs
17:58:06 <eazar001> oh wow
17:58:08 <eazar001> just checked
17:58:10 <geekosaur> mmm, arch used to havew the problem of not having the platform because the platform isn't rolling release
17:58:13 <eazar001> i guess they recently updated it
17:58:40 <geekosaur> so they had all the platform's packages, but out of date in main and bleeding edge in aur and *nowhere* a version compatible with the platform
17:58:49 <eazar001> hmmm
17:58:52 <geekosaur> so building anything not already in arch was nearly impossiblke
17:58:54 <colprofdrmcbeard> this problem I'm having with chart is pretty strange... I can get all 6 graphs in one column just fine.
17:59:15 <ccnp123_> k guys all set with happy, thanks
17:59:29 <eazar001> congrats ccn
17:59:56 <colprofdrmcbeard> ccnp123_: hopefully you don't have to constantly make cabal and ports fight to the death
18:00:24 <arpunk> colprofdrmcbeard: https://ghc.haskell.org/trac/ghc/wiki/Building/Porting :P
18:00:26 <ccnp123_> do you know of any browser based haskell tools? something like jsfiddle.net but for haskell?
18:00:39 <flebron> Well this is nasty. I had "instance Foo Bar where\n\tf = ...". This worked. Adding comments, I removed the \t. It still compiled, but it hangs when I want to use that function for my type. :s
18:01:38 <colprofdrmcbeard> arpunk: I keep hoping russ or someone will backport 8c to lunix so code can move the other way more easier.
18:01:54 <flebron> That's... particularly nasty. :s
18:02:17 <colprofdrmcbeard> ccnp123_: you mean like running haskell in a browser window on someone's server?
18:03:08 <L8D> Why does this not parse? https://gist.github.com/L8D/8276925
18:03:09 <srhb> L8D: (flip scotty . get "/" . text) "hi" . maybe 3000 read -- and I still want to gouge my eyes out :P
18:03:26 <eazar001> snap
18:03:34 <srhb> L8D: because you've not indented the last line?
18:03:48 <srhb> L8D: What's the equal sign?
18:03:55 <eazar001> ccnp123_: snap is a framework for haskell if that's what you're asking??
18:03:58 <L8D> How do I get the do block to cover the first level of indentation?
18:04:13 <eazar001> along with a handful of others
18:04:52 <ccnp123_> nah I mean like collaborative and interactive stuff... there are many online interactive tutorials for javascript and ruby and other languages but I haven't found anything similar for Haskell
18:05:05 <colprofdrmcbeard> @where tryhaskell
18:05:05 <lambdabot> http://tryhaskell.org/
18:05:40 <colprofdrmcbeard> ccnp123_: then type help
18:05:40 <srhb> L8D: The where opens a block, so it needs to be further indented than the 'b' in 'block' or it will try to find further definitions belonging to the where clause, afair
18:06:02 <ccnp123_> cool thats exactly what I was looking for, thanks again
18:06:07 <arpunk> colprofdrmcbeard: They are use Mac OS now
18:06:35 <arpunk> colprofdrmcbeard: No help is coming
18:06:53 <colprofdrmcbeard> arpunk: so sad.
18:07:10 <L8D> srhb: I'll just move the block definition to outside of the where clause
18:07:27 <srhb> L8D: As in top level?
18:07:32 <L8D> yep
18:07:37 <srhb> L8D: Okay. :P
18:07:37 <L8D> https://gist.github.com/L8D/8276925
18:08:04 <srhb> L8D: Superfluous do block there. Also forgot indenting the last line
18:08:31 <L8D> srhb: I want to have the code zero-indented
18:08:43 <L8D> and the do is there because I will be adding several more lines
18:09:08 <eazar001> hmmm i like, TryHaskells type feedback
18:09:40 <srhb> L8D: What do you mean zero-indented? The last line there is an error, naked top level expression
18:09:48 <L8D> nope
18:10:03 <L8D> https://gist.github.com/L8D/8276925 compiles fine
18:10:25 <L8D> Haskell let's you move blocks to the same indentation as the starter
18:10:39 <L8D> which is why several module definitions do:
18:10:45 <L8D> module MyModule where
18:11:01 <L8D> at the top of the file, then the rest of the file is inside the where block
18:11:05 <srhb> Right, of course. I never applied that to this case.
18:12:19 <L8D> of course
18:12:33 <L8D> several syntax highlighters don't recognize this...
18:12:46 <srhb> Indeed. It does seem pretty abominable.
18:12:51 <SrPx> What is the relation between foldl/foldr and the map/reduce function they love so much on databases?
18:15:23 <jmcarthur> SrPx: Data.Foldable.foldMap is probably a better function to compare with
18:15:46 <jmcarthur> SrPx: basically if you write a parallel version of foldMap, you have map/reduce
18:16:12 <FreeFull> You can write a merge sort with foldMap
18:17:26 <SrPx> interesting, where can I read about its properties? is it universal like foldr? can you write every other function with it too?
18:17:29 <jmcarthur> SrPx: not sure in what sense you believe foldr is universal
18:17:38 <FreeFull> Although depending on how the results are appended, it might not be the merge sort
18:17:44 <jmcarthur> SrPx: foldr is a fundamental combinator for lists, but not necessarily for everything else
18:17:59 <jmcarthur> FreeFull: use merge instead of append
18:18:28 <L8D> > foldr1 (+) [1, 2, 3, 4]
18:18:29 <lambdabot>  10
18:18:40 <SrPx> jmcarthur: forge about that property just, can you write every other list function with foldMap?
18:18:46 <SrPx> and does it has a fusion law
18:18:48 <jmcarthur> FreeFull: the only complication is that you want foldMap to be as balanced as possible, for mergesort
18:18:49 <L8D> map (+ 1) [1, 2, 3, 4]
18:18:56 <L8D> > map (+ 1) [1, 2, 3, 4]
18:18:57 <lambdabot>  [2,3,4,5]
18:19:06 <FreeFull> jmcarthur: Yeah, I mean the pattern it merges in
18:19:14 <FreeFull> You usually want a balanced binary tree
18:19:16 <jmcarthur> SrPx: foldMap isn't even (just) a list function
18:19:33 <eazar001> :t foldMap
18:19:34 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:19:57 <FreeFull> I wonder if my Sorted type is still around
18:20:05 <FreeFull> :t Sorted
18:20:06 <jmcarthur> SrPx: foldMap isn't quite as general as foldr for lists, i think
18:20:06 <lambdabot> Not in scope: data constructor `Sorted'
18:20:07 <SrPx> jmcarthur: hmm then it is not what I'm talking about,..
18:20:15 <FreeFull> :t MkSorted
18:20:16 <lambdabot> Not in scope: data constructor `MkSorted'
18:20:21 <FreeFull> I don't think so
18:20:28 <FreeFull> Any way to look at lambdabot's current L.hs?
18:20:51 <eazar001> foldmap works with any foldable type
18:21:02 <eazar001> but with monoid restriction
18:21:58 <FreeFull> Well, the monoid restriction isn't on the foldable
18:22:04 <eazar001> true
18:22:10 <eazar001> just on the function
18:22:29 <jmcarthur> if you consider the type class dictionary as just normal function arguments, foldMap for lists looks like this (quite similar to foldr!), but with some restrictions on the first two arguments and an overall less general type:  foldMap :: (m -> m -> m) -> m -> [a] -> m
18:22:47 <jmcarthur> ah i fail
18:23:03 <jmcarthur> foldMap :: (m -> m -> m) -> m -> (a -> m) -> [a] -> m
18:23:38 <jmcarthur> that's not actually less general... huh
18:23:43 <eazar001> well ....
18:23:54 <eazar001> it depends
18:24:24 <eazar001> :t foldr
18:24:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:24:28 <eazar001> :t foldM
18:24:29 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:24:55 <eazar001> foldM is just more restricted
18:24:56 <jmcarthur> of course. i'm an idiot. foldr can be written in terms of foldMap
18:24:56 <hellertime> I tried to see the result of a specific optimization flag by compiling with '-O0' and then with '-O0 -fspec-constr' and the resulting Core is the same. should using optimization flags with -O0 have no effect on GHC?
18:25:02 <eazar001> but doesn't seems less "general"
18:25:09 <jmcarthur> there is even an implementation in Data.Foldable
18:25:19 <jmcarthur> not sure what i was thinking
18:25:40 <eazar001> foldr is written in terms of FoldMap?
18:25:53 <eazar001> did you find this in source?
18:26:09 <jmcarthur> the dumb way is to convert to a list and apply Data.List.foldr to the result
18:26:19 <jmcarthur> conversion to list can be done with foldMap
18:26:28 <eazar001> oh
18:26:30 <eazar001> right right
18:26:46 <jmcarthur> maybe that's cheating, but now i'm curious if there is a direct way
18:27:17 <jmcarthur> i guess it wouldn't be "cheating" to build up a church encoded list or something, which is about the same thing
18:28:37 <SrPx> hmm...
18:28:50 <SrPx> I still don't know the answer to my question
18:28:55 <SrPx> but I like to see you guys debating (:
18:29:11 <jmcarthur> SrPx: i still don't understand your question
18:29:41 <eazar001> something about merge?
18:29:45 <eazar001> i forget lol
18:29:50 <flebron> Hi. I've a function f :: a -> Maybe a. Given a starting value x :: a, what's an idiomatic way of saying [f x, f (f x), ..., f^k x], such that f^{k+1} x is the first Nothing?
18:29:50 <jmcarthur> something about map/reduce
18:30:04 <SrPx> I want to know wether you can implement all list functions with it like you can with foldr (filter, map, zip, etc). Also wether there is a fusion rule for it (as in, foldr/build and unfold/destroy)
18:30:22 <jmcarthur> flebron: some combination of unfoldr and last?
18:30:27 <flebron> SrPx: All recursive functions, sure.
18:30:35 <eazar001> those tings you mentioned yep
18:30:36 <flebron> jmcarthur: I thoight of unfoldr, but it wants -> Maybe (a, b) :s
18:30:44 <flebron> *thought
18:30:50 <jmcarthur> flebron: in your case it would be -> Maybe (a, a)
18:30:58 <flebron> Sure.
18:31:13 <flebron> (For context, my f is an iterator, I want to iterate until there's nothing more.)
18:31:53 <jmcarthur> flebron: alternatively, you could use iterate with Maybe's (>>=), takeWhile isJust, and last
18:32:12 <flebron> Why do you want last?
18:32:23 <jmcarthur> oh i misunderstood is all
18:32:27 <jmcarthur> thought you wanted the final value
18:32:42 <flebron> Ah, nah, just the list. Yeah, iterating >>= seems reasonable, and taking while is Just.
18:32:50 * flebron just destroyed English.
18:33:04 <flebron> Thanks :)
18:33:28 <jmcarthur> :t \f -> catMaybes . takeWhile isJust . iterate (>>= f) . return
18:33:29 <lambdabot> (a -> Maybe a) -> a -> [a]
18:34:02 <flebron> Yeah :)
18:34:19 <SrPx> flebron: so just out of curiosity is there a reason for favoring foldr on Prelude?
18:34:30 <flebron> SrPx: Over...?
18:34:42 <eazar001> yea
18:34:43 <Twisol> flebron: You have clearly been far even as decided to use even fo want to do look more like.
18:34:46 <eazar001> it works with infinite lists
18:34:51 <SrPx> flebron: over unsided fold
18:34:56 <flebron> What's an unsided fold?
18:34:58 <eazar001> hence lazy evaluation
18:35:08 <eazar001> foldl' .... gives you advantage in terms of memory space
18:35:15 <eazar001> but forces you to evaluate entire list
18:35:20 <eazar001> foldr can terminate prematurely
18:35:23 <roboguy_> SrPx: unsided fold?
18:35:55 <SrPx> flebron: eh foldMap, that one that databases love. That receives an associative binary function and can be done in any order such as ((1 + 2) + (3 + 4)) or (((1 + 2) + 3) + 4)
18:36:11 <flebron> That's not really a specific fold.
18:36:12 <jmcarthur> SrPx: foldMap is not "unsided". note that it requires the result to be a Monoid. it relies on associativity to not have to be "left" or "right". it's not really the same thing.
18:36:12 <roboguy_> SrPx: but it does it in a specific order...
18:36:18 <SrPx> not sure what is the name, that was the function I was asking about, which you answered can be used to define any recursive list function flebron
18:36:35 <flebron> If you have a Monoid, then it doesn't matter what order you use, and your function can do whichever it wants.
18:36:44 <SrPx> jmcarthur: I don't know much about foldMap, sorry, I'm talking about this one I described, consider it please
18:37:01 <flebron> SrPx: Haskell functions are deterministic.
18:37:10 <jmcarthur> SrPx: what you describe sounds like foldMap to me
18:37:13 <flebron> A fold will be done one way, and one way only.
18:37:30 <jmcarthur> > foldMap Sum [1, 2, 3, 4]  -- SrPx
18:37:31 <lambdabot>  Sum {getSum = 10}
18:37:35 <flebron> There are two canonical folds which we call foldr and foldl, but as you note, you can have an infinite number of possible folds.
18:38:06 <flebron> A database could then pick whichever order it wanted to, but that would be a sort of "meta-algorithm", based on things other than just the list.
18:38:14 <flebron> (For instance, memory pressure.)
18:39:00 <jmcarthur> SrPx: the benefit of foldMap over foldr is that it's folding with the append function of a monoid, so it is more free to work with whatever associativity is convenient or efficient
18:39:12 <eazar001> hmmm
18:39:20 <jmcarthur> SrPx: the downside is that a Monoid instance has to be involved, whether its convenient for you or not
18:39:24 <jmcarthur> *it's
18:39:25 <eazar001> jmcarthur makes good point
18:39:26 <danilo2> Hello! (Small ranNTypes question here) - would somebody be so nice and tell me why the function "testM2" DOES compile, while "testM3" does not? What is the difference, that allows for writing "testM2"? I would love to understand the difference from Haskells point of view: http://lpaste.net/98024
18:39:29 <flebron> (And thus it is less reusable.)
18:40:59 <eazar001> but monoids can allow more flexibility
18:41:00 <eazar001> in some cases
18:41:02 <jmcarthur> danilo2: ghc monomorphizes let bindings. if you give the f function a signature it will work
18:41:11 <jmcarthur> danilo2: this is not specific to higher rank types
18:41:22 <eazar001> you can swap out for instance bytestrings with strings
18:41:32 <eazar001> if you're working with things like mplus
18:41:51 <eazar001> it's highly dependent on what you're doing and how you implement
18:42:37 <eazar001> or sorry mappend
18:42:47 <danilo2> jmcarthur: hmm, I did not know it monomorphises the let bindings, thank you. I have to check smthing out, brb
18:43:20 <jmcarthur> danilo2: you can use NoMonoLetBindings (i think it's called) to change that behavior
18:44:04 <jmcarthur> actually, did i get that wrong? is this only true when GADTs are enabled?
18:44:16 <jmcarthur> i stand a good chance of being wrong
18:44:47 <geekosaur> I think it always does now? but the behavior changed in early 7.x
18:44:51 <colprofdrmcbeard> would anyone be willing to cabal install chart and chart-cairo and that code i hpaste'd before and tell me whether or not I'm losing my mind?
18:44:51 <jmcarthur> in any case, monomorphic let bindings is a property of ghc that is actually divergent from the spec
18:45:05 <danilo2> jmcarthur: NoMonoLocalBinds? It does not help in this case
18:45:16 <jmcarthur> sorry i must have been wrong then
18:45:25 <enthropy> jmcarthur: that used to be the case
18:45:27 <jmcarthur> i would still encourage you to try an explicit type signature for that local function definition
18:45:33 <enthropy> maybe around ghc-7.0 ish?
18:45:49 <Cale> Of course, depends on what you take to be the spec. If you read the OutsideIn(X) paper, it describes things reasonably well ;)
18:45:57 <jmcarthur> heh
18:47:26 <randomclown> Is there no way to to set Linux specific TCP options anywhere
18:47:48 <carter> to paraphrase matthias felleisen "you could put all the people who've read the outside in paper on a plane and have it crash, and the world wouldn't care"
18:47:53 <carter> wellll,w e'd care
18:47:54 <carter> but yeah
18:48:14 <carter> randomclown: have you looked at the network docs?
18:48:57 <randomclown> i.e. TCP_KEEPIDLE isn't in setSocketOptions
18:48:57 <randomclown> carter: only the standard ones are there, there is also no way to specify custom ones
18:49:03 <carter> randomclown: i think you can set a socket, then pass it to the network lib http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-Socket-Internal.html
18:49:14 <carter> randomclown: i suspect patches would be welcome
18:49:19 <carter> but in the mean time, i think you could use http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-Socket-Internal.html
18:49:36 <carter> and do a wee c thing to setup the socket, then haskellify it
18:49:55 <randomclown> that would be the dumbest thing, might as well just go full c
18:50:09 <carter> the haskell c ffi is really easy
18:50:25 <danilo2> jmcarthur: I'm uable to type it by hand. I've tried "let f = method1 v :: a -> IO()" and "let f = method1 v :: forall a. a -> IO()" but none worked
18:50:49 <carter> danilo2: do you have locallyscoped type vars eneabled?
18:51:00 <geekosaur> let f :: ...; f = method1 v
18:51:05 <danilo2> carter: No, but I will try to enable it
18:51:20 <carter> err, lexically scoped I think
18:51:20 <danilo2> carter: the exampe I'm talking about is here: http://lpaste.net/98024
18:52:13 <danilo2> carter: "If you want to use GHC's lexically scoped type variables, you also have to use explicit universal quantification. That is, you have to add forall declarations to your functions' type signatures"
18:52:24 <carter> you do?
18:52:25 <danilo2> carter: sO I've tried to use forall, but without success
18:52:50 <geekosaur> you use the forall on the original outer-scope variable
18:53:03 <geekosaur> then you can refer to it in your let f
18:53:41 <randomclown> carter: so how does one peek into C for a bit then come back?
18:53:41 <flebron> If I have an .Internal module, where I've defined a function f, is there a way to export it from the external module as g? (Other than, you know, saying g = f in the external module.)
18:54:00 <geekosaur> oh, that wouldn't be relevant here anyway
18:54:08 <danilo2> geekosaur: Maybe this is very simple and I do not see it, but could you tell me how and where should I put this "forall"
18:54:11 <geekosaur> flebron: no
18:54:18 <flebron> Thanks :)
18:54:30 <geekosaur> danilo2, as I just said, having looked at your code, that's not going to help here
18:54:35 <randomclown> oh right take out the socket fd, and just send it to c
18:54:39 <danilo2> geekosaur: Ah, ok
18:55:13 <carter> randomclown: https://github.com/haskell/network/blob/master/Network/Socket/ByteString.hsc#L92-L95 is a good example
18:55:51 <geekosaur> actually I am wondering if it's something about the partial application there
18:56:08 <carter> randomclown: for you it'd be like
18:56:16 <danilo2> geekosaur, carter, jmcarthur: Do you have any ideas if my problem is somehow solvable? (I post alink, not to force you to scroll up: http://lpaste.net/98024)
18:56:17 <carter> foreign import ccall unsafe "recv"
18:56:17 <carter>   c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
18:56:24 <carter> danilo2: probably solvable
18:56:36 <carter> whats the actual goal?
18:56:41 <mauke> recv returns ssize_t
18:56:47 <geekosaur> sadly I think this is a bit above my pay grade :(
18:56:54 <danilo2> carter: I'm generating the code and I want to simply run it :)
18:57:04 <danilo2> carter: I would love to make such let bindings working
18:57:13 <randomclown> carter: so I need a compiled c object somewhere in the build?
18:57:22 <carter> not nesccarily
18:57:27 <carter> it needs to link to the fnction
18:57:39 <carter> sooo, if theres some linux specific c function that does the thing
18:57:41 <carter> you can just ffi to it
18:57:51 <carter> you'll then have to wrap it upt
18:57:53 <carter> not to hard
18:58:05 <carter> i've some thorny ffi work of my own afoot https://github.com/wellposed/hOpenBLAS
18:58:13 <carter> danilo2: add top level types to the code too
19:00:49 <danilo2> carter: here you go: http://lpaste.net/98024
19:01:00 <danilo2> carter: bottom annotation - there are top level types
19:02:36 <carter> danilo2: so whats the type of f?
19:02:44 <carter> give f the type annotation
19:02:45 <carter> of
19:02:58 <carter> (f :: Show b => b -> String)
19:03:24 <danilo2> carter: f's type is (Show b => b -> IO ())
19:03:34 <carter> ok that
19:03:37 <carter> give it that type
19:03:50 <danilo2> carter: I've tried, it does not help
19:03:50 <carter> explicitly
19:03:59 <carter> did you write it that way?
19:04:09 <geekosaur> [06 02:46] <geekosaur> let f :: ...; f = method1 v
19:04:21 <danilo2> carter: http://lpaste.net/98027
19:04:38 <randomclown> carter: is there a easy way to get the constant out of the header?
19:04:40 <carter> danilo2: write it as let (f :: blah) = yatayatta
19:04:50 <carter> randomclown: hsc shoud let you
19:04:51 <geekosaur> or see what I have repeated a couple times now
19:05:08 <carter> danilo2: did you try geekosaur 's approach
19:05:26 <carter> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/hsc2hs.html
19:05:32 <geekosaur> and there are some differences between doing it that way and doing it the way you keep doing it
19:05:51 <carter> randomclown: in fact, the network lib has some good examples
19:06:27 <danilo2> carter: hmm If I write geekosaurs approach it really works! Hmm this is very strange
19:06:41 <carter> danilo2: well, its unclear what is getting the type annotation your way
19:06:43 <danilo2> carter: but can we tell GHC to infer such type, or is it impossible?
19:06:55 <carter> danilo2: add parens to your version woudl work too
19:07:06 * enthropy wonders about NoMonomorphismRestriction
19:07:07 <carter> danilo2: you had a syntax error in assocativitivy :)
19:07:16 <enthropy> maybe it applies to your f
19:07:27 <carter> enthropy: that doesn't resolve the type annotation sisue
19:07:31 <enthropy> it should after all
19:07:34 <enthropy> yes
19:07:39 <carter> danilo2: try f = (blah ):: type
19:07:40 <carter> that woudl work
19:08:11 <danilo2> carter: I've just tried it. It does not work that way
19:08:16 <carter> well
19:08:22 <carter> you solved it
19:08:23 <carter> yay
19:08:30 <carter> its also weird weird code you're writig too
19:08:32 <carter> :)
19:08:42 <danilo2> enthropy: Wow, you are right!
19:09:06 <danilo2> carter: enthropy is right. If I add -XNoMonomorphismRestriction it just works
19:09:10 <carter> ok
19:09:14 <carter> cool
19:09:19 <enthropy> you can also write let f x = method1 v x
19:09:24 <enthropy> and not enable that extension
19:09:30 <danilo2> carter, enthropy, geekosaur, jmcarthur: thank you :)
19:10:11 <danilo2> enthropy: without that NoMonomorphismRestriction id does not compile
19:10:59 <enthropy> does here if I add the argument
19:11:01 <geekosaur> MMR should not apply if you include the explicit parameter
19:14:33 <flebron> Does this function have a name? \p x -> if p x then Just x else Nothing
19:15:20 <carter> probably
19:15:27 <carter> :t maybe
19:15:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:15:45 <flebron> It's ~kind of~ the inverse of that.
19:16:05 <stolaruk> flebron: It's a bit like guard
19:16:10 <stolaruk> :t guard
19:16:11 <lambdabot> MonadPlus m => Bool -> m ()
19:16:12 <geekosaur> Maybe is MonadPlus; would guard work?
19:16:16 <geekosaur> heh, that
19:16:17 <carter> http://hackage.haskell.org/package/base-4.3.1.0/docs/Data-Maybe.html
19:16:49 <carter> it's related to whats in Data.Maybe
19:16:55 <colprofdrmcbeard> mfilter?
19:16:59 <roboguy_> I think I've searched for a function like that before and haven't been able to find anything quite the same
19:17:24 <roboguy_> oh, mfilter would be close
19:17:38 <carter> :t mfilter
19:17:38 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
19:17:52 <flebron> Seems that's it :)
19:17:53 <erisco> > mfilter (<= 10) (return 5)
19:17:54 <lambdabot>  No instance for (Control.Monad.MonadPlus m0)
19:17:54 <lambdabot>    arising from a use of `e_1105'
19:17:54 <lambdabot>  The type variable `m0' is ambiguous
19:17:54 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:17:54 <lambdabot>  Note: there are several potential instances:
19:18:12 <erisco> > mfilter (<= 10) (return 5) :: Maybe Int
19:18:13 <lambdabot>  Just 5
19:18:13 <flebron> Well, almost, but as close as I'm going to get.
19:18:21 <colprofdrmcbeard> > mfilter (<=10) (Just 5)
19:18:22 <lambdabot>  Just 5
19:18:34 <colprofdrmcbeard> > mfilter (>10) (Just 5)
19:18:35 <lambdabot>  Nothing
19:18:52 <roboguy_> :t flip $ flip mfilter . Just
19:18:53 <lambdabot> (a -> Bool) -> a -> Maybe a
19:18:53 <carter> mfilter (<= 50) [1,10]
19:18:59 <carter> > mfilter (<= 50) [1,10]
19:19:00 <lambdabot>  [1,10]
19:19:03 <roboguy_> ^ that's specifically the same as the function you want
19:19:06 <carter> > mfilter (<= 50) [1,10,1000]
19:19:07 <lambdabot>  [1,10]
19:19:18 <flebron> roboguy_: Yeah :p
19:20:07 <flebron> But at the point I'm typing "flip $ flip", I'm likely going to confuse more than if I just straight-up "if".
19:20:27 <zRecursive> :hoogle mfilter
19:20:52 <roboguy_> flebron: well, it could also be filterMaybe predicate x = mfilter predicate (Just x)
19:21:02 <roboguy_> I was just having fun with some pointless style
19:22:08 <roboguy_> or maybe, if you want a *little* pointlessness, filterMaybe predicate = mfilter predicate . Just
19:30:16 <roboguy_> how many monoidal type classes are there in base? 3? I wonder if there's a way to consolidate them
19:30:39 <startling> what's a "monoidal" type class? You mean Alternative/MonadPlus?
19:30:44 <roboguy_> startling: yeah
19:31:02 <startling> yeah, they can be consolidated with the updated Applicative/Monad hierarchy I think.
19:31:07 <startling> They probably won't be though.
19:31:43 <startling> well, I don't know anything, they might be updated. I just feel like that's too drastic of a change for it to be.
19:32:57 <startling> oh, interesting.
19:33:18 <startling> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal : "Alternative becomes a superclass of MonadPlus (in addition to Monad, of course)."
19:33:37 <stolaruk> So mfilter applies an everyday predicate to a MonadPlus value and returns mzero if it isn't True, otherwise it returns the value itself?
19:33:39 <roboguy_> startling: huh, that is interesting
19:34:41 <roboguy_> startling: yep
19:34:48 <roboguy_> I mean stolaruk
19:34:50 <startling> I guess the idea is not to break old code, but to have default implementations for MonadPlus
19:34:58 <stolaruk> roboguy_: Cool thanks
19:35:11 <startling> I sort of wish we could just dump MonadPlus, but ...
19:35:28 <startling> I guess MonadPlus m => is shorter than (Alternative m, Monad m) =>
19:36:17 <roboguy_> startling: isn't there a proposal about type class synonyms or something like that?
19:36:47 <roboguy_> like you could have MonadPlus m => be translated to (Alternative m, Monad m) =>
19:37:48 <startling> roboguy_: I think you can do it already with ConstraintKinds or something
19:38:11 <startling> yeo
19:38:13 <startling> yep
19:38:48 <jfischoff> startling: huh…yeah
19:39:27 <roboguy_> hmm, well that would be another possibility
19:39:57 <startling> there's probably weird edge-cases
19:40:15 <startling> I bet you can't have a typeclass synonym as a superclass
19:40:35 <roboguy_> maybe. if there aren', you could probably implement that ConstraintKinds thing without breaking any existing code
19:40:40 <roboguy_> *aren't
19:41:24 <startling> I feel like "breaking existing code" isn't such a bad thing for fixing typeclass hierarchies.
19:42:07 <startling> Like, there's a finite number of broken instance declarations per type. It shouldn't be hard to fix it.
19:42:42 <startling> but then again, backwards compatibility is really nice when you need t. :)
19:43:10 <erisco> I hate legacy
19:45:10 <roboguy_> it seems like this wouldn't be much of a compromise though, as far as improving things goes
19:46:05 <startling> I perpetually wish we could just throw out all old code and start again, but ...
19:48:18 <roboguy_> startling: well, I don't know if it's *that* bad, especially compared to some other languages' standard libraries
19:49:44 <pdxleif> Why do they gotta write "ONE MILLION" in uppercase? http://hackage.haskell.org/package/xmonad-contrib-0.8/docs/XMonad-Util-Run.html#v%3Aseconds
19:49:45 <startling> yeah.
19:52:11 <randomclown> Does the main file for an executable have to be named Main?
19:52:25 <randomclown> i.e is there a way MyModule.Main could work?
19:54:17 <roboguy_> randomclown: I never really name my main file Main.hs. is that what you mean?
19:54:28 <randomclown> the module name
19:54:46 <randomclown> but I just checked the spec again it says the module name must be Main
19:55:01 <joelteon> isn't it implicitly Main
19:55:24 <roboguy_> randomclown: the stuff before the dot has to do with what directory it's in, which probably doesn't really matter
19:55:58 <randomclown> I'm fairly sure it doesn't accept Blah.Main as the entry point
19:57:32 <roboguy_> randomclown: well, I just put a main file in a Test subdirectory called "Main.hs" and ghc seemed okay with it
19:58:17 <randomclown> yeah that's fine but if you have a line inside Main.hs with 'module Test.Main where' then it won't
19:58:53 <roboguy_> randomclown: actually, that worked for me too
19:59:28 <roboguy_> oh, it didn't make an executable though
19:59:52 <roboguy_> use -main-is I think
20:00:12 <randomclown> Exactly
20:00:21 <roboguy_> randomclown: like this: ghc -main-is Blah.Main Main.hs
20:01:04 <randomclown> I thought -main-is only took a path
20:01:54 <tristan_1> hm, Network.HTTP.Types.Status has
20:01:56 <jfischoff> . o O (:O http://hackage.haskell.org/package/ghc-syb-utils-0.2.1.2/docs/GHC-SYB-Utils.html#t:Stage)
20:01:58 <roboguy_> randomclown: that seemed to work for me. made an executable
20:02:12 <randomclown> roboguy_: cabal's main-is won't accept anything other than a path
20:03:52 <roboguy_> randomclown: try adding -main-is Blah.Main in the ghc-options
20:13:23 <pdxleif> Is "maybe (return ())" already defined somewhere?
20:14:07 <pdxleif> Maybe I could say "maybe mzero"?
20:14:12 <geekosaur> guard? (Maybe hasa MonadPlus instance)
20:14:33 <geekosaur> or, hm, no
20:14:42 <geekosaur> not quite, guard wants a predicate
20:15:06 <pdxleif> guard is close
20:15:29 <pdxleif> I could use guard + isJust and fromJust
20:15:48 <pdxleif> or maybe when
20:16:24 <shachaf> :t traverse_
20:16:25 <lambdabot>     Not in scope: `traverse_'
20:16:25 <lambdabot>     Perhaps you meant one of these:
20:16:25 <lambdabot>       `F.traverse_' (imported from Data.Foldable),
20:16:27 <shachaf> :t F.traverse_
20:16:28 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
20:17:56 <pdxleif> Ah, perfect - thanks!
20:18:44 <roboguy_> is the instance Monoid a => Monad ((,) a) defined somewhere?
20:19:41 <simpson> roboguy_: Yes; it's called Writer.
20:19:42 <startling> roboguy_: I remember not being able to find it.
20:19:45 <shachaf> Alas, not in base (or any standard place that I know of).
20:19:49 <startling> simpson: that's not what he asked.
20:19:56 <roboguy_> simpson: yeah but that's all wrapped up in a new type
20:20:06 <simpson> Oh, I see. Sorry.
20:20:12 <startling> > return 12 :: ((), Int)
20:20:13 <lambdabot>  No instance for (GHC.Base.Monad ((,) ()))
20:20:14 <lambdabot>    arising from a use of `GHC.Base.return'
20:20:14 <lambdabot>  Possible fix:
20:20:14 <lambdabot>    add an instance declaration for (GHC.Base.Monad ((,) ()))
20:20:22 <roboguy_> strange
20:21:08 <pdxleif> Using traverse_ that way feels like mapM_ (fmapM_ ?), which I guess is a synonym. I shoulda thought of that to begin with. :/
20:21:23 <startling> roboguy_: yeah, it bugs me too.
20:24:48 <tristan_1> been fighting profiling for a while tonight..
20:24:56 <tristan_1> Could not find module `Data.ByteString.Base64'
20:24:57 <tristan_1> Perhaps you haven't installed the profiling libraries for package `base64-bytestring-1.0.0.1'?
20:25:15 <tristan_1> just install all the base64/bytestring prof packages from apt and still won't compile!
20:25:39 <geekosaur> are you sure you don't also have cabal installed copies?
20:26:30 <tristan_1> of the profile lib?
20:26:51 <Clint> of the profile-less lib
20:27:16 <tristan_1> oh, yea, probably do
20:27:16 <Clint> nuke those
20:28:53 <tristan_1> ah ok, trying that
20:43:29 <tristan_1> argh, going to be a pain in the ass it seems... would break a lot of packages it says
20:44:52 <Clint> tristan_1: what says?
20:46:32 <tristan_1> Clint: unregistering the package. I tried just blowing away my cabal-dev dir and cabal-dev install only deps but that didn't work either (thought it might grab the local)
20:47:24 <Clint> tristan_1: i recommend rm -rf ~/.ghc ~/.cabal; cabal update; and then install everything you want through apt if you can, -{dev,doc,prof}
20:47:44 <stolaruk> Is there a nice succinct way to say "not null" other than "length > 0"
20:47:53 <joelteon> "not null"
20:47:53 <geekosaur> not . null?
20:47:59 <joelteon> not . null
20:48:05 <stolaruk> hehe ok thx
20:48:18 <shachaf> Pattern-matching is even better.
20:48:30 <geekosaur> also length is a bad way to do it because it requires Eq
20:48:36 <shachaf> Don't use length if you can avoid it. :-( length x > 0 is broken on infinite lists and inefficient on finite lists.
20:48:42 <geekosaur> or something like that
20:48:43 <shachaf> Er, Eq?
20:48:45 <joelteon> length doesn't require Eq
20:48:48 <joelteon> length :: [a] -> Int
20:48:52 <stolaruk> Yeah length has bitten me before
20:48:53 <tristan_1> Clint: thanks, I'll give that a shot tomorrow, falling asleep now :)
20:48:56 <geekosaur> no, I realized I was thinking the wrong thing there
20:49:02 <stolaruk> There's really nothing wrong with "not null"
20:49:05 <shachaf> Oh, you're thinking of == []
20:49:32 <shachaf> I think == [] is still better than using length. It'll either behave roughly optimally or give you a type error.
20:49:50 <geekosaur> yeh
20:49:52 <geekosaur> sorry
20:50:05 <stolaruk> Well I guess I'm thinking of "/= []"
20:50:18 * geekosaur should be asleep but there are reasons to wait out this cold front that is refusing to move through
20:50:30 <shachaf> Anyway, using Bool is kind of ugly in the first place.
20:50:42 <shachaf> Don't use Bool if you can easily avoid it.
20:50:43 <stolaruk> I want a predicate
20:50:56 <shachaf> OK.
20:50:58 <geekosaur> :t not . null
20:51:00 <lambdabot> [a] -> Bool
20:51:31 <eviltheta> @pl (\x-> \y-> (y (x x y))) (\x-> \y-> (y (x x y)))
20:51:35 <lambdabot> (ap id . ap id id) (ap id . ap id id)
20:51:35 <lambdabot> optimization suspended, use @pl-resume to continue.
20:53:37 <erisco> :T ap
20:53:41 <erisco> :t ap
20:53:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:56:00 <eazar001> :h
20:56:32 <pavonia> :t ap id
20:56:32 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
20:59:17 <L8D> :t return id
20:59:18 <lambdabot> Monad m => m (a -> a)
20:59:31 <pavonia> So @pl doesn't do any type checking it seems
20:59:38 <shachaf> Yep.
20:59:52 <shachaf> It's not really Haskell, it's an untyped Haskellish thing.
21:05:28 <zRecursive> :t id
21:05:29 <lambdabot> a -> a
21:07:28 <L8D> zRecursive:
21:07:34 <L8D> > id "asdf"
21:07:35 <lambdabot>  "asdf"
21:07:39 <L8D> id x = x
21:08:34 <zRecursive> L8D: why ":t ap id" => ((a -> b) -> a) -> (a -> b) -> b ?
21:08:47 <L8D> :t ap
21:08:48 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:08:48 <joelteon> :t ap id id
21:08:49 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
21:08:49 <lambdabot>     Expected type: (a0 -> b0) -> a0
21:08:49 <lambdabot>       Actual type: (a0 -> b0) -> a0 -> b0
21:09:12 <L8D> well, ap id shouldn't work
21:09:20 <L8D> because id isn't inside a monad
21:09:22 <zRecursive> :t ap id
21:09:23 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
21:09:48 <L8D> :t fmap
21:09:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:09:56 <L8D> :t ap
21:09:56 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:10:01 <pavonia> "(->) e" is a monad
21:10:01 <scott_> ap id uses the ((->) r) monad instance
21:10:15 <L8D> weird
21:10:39 <scott_> ap :: (r -> a -> b) -> (r -> a) -> r -> b
21:10:47 <shachaf> (e ->) is a monad whenever e is a comonoid. But every type is a comonoid.
21:10:56 <scott_> Applying ap to id forces r = a -> b
21:11:20 <scott_> What is a comonoid?
21:11:34 <roboguy_> scott_: a monoid with the function arrows flipped
21:11:36 <shachaf> The dual of a monoid. In Haskell it's a very boring concept.
21:11:53 <roboguy_> shachaf: is there a more interesting non-Haskell example of a comonoid?
21:11:55 <shachaf> But I like the duality between (e ->) and (e,)
21:12:19 <shachaf> Sure. For example in linear logic comonoids are more interesting.
21:12:19 <eazar001> you mean like flip mappend ?
21:12:28 <scott_> roboguy_: Which function arrows? I don't quite get that
21:12:32 <shachaf> Comonads are comonoids in a particular category (where monads are monoids).
21:12:43 <JoeyA> mappend :: a -> (a -> a)
21:12:54 <eazar001> :t mappend
21:12:55 <lambdabot> Monoid a => a -> a -> a
21:12:59 <JoeyA> co_mappend :: (a -> a) -> a ?
21:13:00 <shachaf> Comonoids in Chu spaces are interesting: http://boole.stanford.edu/pub/comonoids.pdf
21:13:06 <shachaf> mappend :: (a,a) -> a
21:13:11 <shachaf> comppend :: a -> (a,a)
21:13:18 <roboguy_> comempty :: m -> ()
21:13:23 <shachaf> mempty :: () -> a; comempty :: a -> ()
21:13:25 <shachaf> Yes.
21:13:38 <scott_> Hmm
21:13:52 <shachaf> And the laws require that comappend = \x -> (x,x)
21:13:56 <scott_> Thanks for the explanation
21:14:19 <shachaf> Anyway, what these mean is that you can "duplicate" and "eliminate" values.
21:14:35 <shachaf> But in Haskell you can always do that anyway.
21:14:38 <joelteon> comempty is the most easily implementable function ever.
21:14:45 <shachaf> In linear logic you can't, so they're more interesting.
21:14:51 <scott_> Whereas monoid can "combine" and "introduce" values?
21:14:59 <shachaf> Look at the Monad instance for (r ->):
21:15:02 <shachaf> return x = \_ -> x
21:15:14 <shachaf> join f = \x -> f x x
21:15:50 <jfischoff> > join (+) 5
21:15:51 <lambdabot>  10
21:16:07 <shachaf> And look t the Monad instance for (r,):
21:16:15 <shachaf> return x = (mempty,x)
21:16:27 <shachaf> join (a,(b,x)) = (a <> b, x)
21:16:31 <shachaf> I like the duality there.
21:16:53 <shachaf> Even if Haskell doesn't force you to notice it.
21:18:15 <zRecursive> yeah
21:23:41 <stolaruk> :t Data.Text.pack "haha"
21:23:42 <lambdabot> Data.Text.Internal.Text
21:24:12 <stolaruk> > guard (1 > 0) >> "haha"
21:24:13 <lambdabot>  "haha"
21:24:36 <stolaruk> > guard (1 > 0) >> (Data.Text.pack "haha")
21:24:37 <lambdabot>  Not in scope: `Data.Text.pack'
21:25:17 <stolaruk> > guard (1 > 0) >> (Data.Text.Internal.Text.pack "haha")
21:25:19 <lambdabot>  Not in scope: `Data.Text.Internal.Text.pack'
21:25:49 <stolaruk> > guard (1 > 0) >> (pack "haha")
21:25:50 <lambdabot>  Not in scope: `pack'
21:25:51 <lambdabot>  Perhaps you meant one of these:
21:25:51 <lambdabot>    `BS.pack' (imported from Data.ByteString),
21:25:51 <lambdabot>    `BSL.pack' (imported from Data.ByteString.Lazy),
21:25:51 <lambdabot>    `BSLC.pack' (imported from Data.ByteString.Lazy.Char8)
21:33:13 <jmcarthur> shachaf: i also like the corresponding duality   extract (_, b) = b; duplicate (a, b) = (a, (a, b))  and  extract f = f mempty; duplicate f a b = f (a <> b).  they all go together so well.
21:33:54 <shachaf> jmcarthur: Yep.
21:34:57 <shachaf> jmcarthur: It's things like this that make me feel like I'm missing out by not knowing anything about linear types.
21:40:35 <jmcarthur> shachaf: substructural types are covered in one of the TaPL books. i think it's in ATTaPL. it's a fun introductory chapter. it's also a superset of my knowledge on the topic already.
21:40:54 <shachaf> I should read TaPL and ATTaPL.
21:41:20 <jmcarthur> shachaf: i was amused when i discovered the relationship with the BCKW combinator calculus
21:41:52 <L8D> :t (,) (+) (+)
21:41:53 <lambdabot> (Num a, Num a1) => (a -> a -> a, a1 -> a1 -> a1)
21:42:19 <L8D> :t (,) id id
21:42:20 <lambdabot> (a -> a, a1 -> a1)
21:42:31 <jmcarthur> shachaf: B = (.); C = flip; K = const; W = join
21:42:54 <L8D> :t join
21:42:55 <lambdabot> Monad m => m (m a) -> m a
21:42:59 <shachaf> jmcarthur: Hmm, K and W corresponding to duplication and elimination, I guess, and C corresponding to reordering or something?
21:43:04 <jmcarthur> yup
21:43:25 <shachaf> Makes sense.
21:43:32 <jmcarthur> and C i think fits with the commonly assumed axiom of associativity
21:43:41 <jmcarthur> err
21:43:43 <jmcarthur> B
21:43:58 <jmcarthur> in a fuzzier sense than the others though
21:44:24 <shachaf> I already noticed that K corresponds to elimination and S corresponds to duplication (and I corresponds to doing neither) in SKI.
21:44:36 <jmcarthur> S = ap
21:44:41 <shachaf> Right.
21:46:37 <jmcarthur> but S is clearly other stuff as well, since S can take the place of B and C as well (when combined with K at least)
21:47:19 <shachaf> Sure.
21:47:52 <shachaf> The transformation of a lambda expression to a SKI expression is really nice and straightforward.
21:48:38 <jmcarthur> yeah, i haven't seen (or looked for) a direct translation from LC->BCKW
21:49:23 <shachaf> You have \x -> E. Either E is x (I case), or E is some other value that doesn't involve x (K case), or E is an application E1 E2, in which case you pass x to both of them and recurse. So the duplication is pretty apparent.
21:49:35 <shachaf> I should figure out at how BCKW works.
21:53:38 <shachaf> What's "the sentential axiom F -> A"?
21:54:26 <jmcarthur> i have no idea what that is
21:54:32 <cgag> haskell noob here, could i get a quick code review on this?  I feel like the way i'm handling not being passed enough cmd args is dumb: http://lpaste.net/98028
22:00:11 <pavonia> cgag: What about http://lpaste.net/98029 ?
22:00:42 <pavonia> cgag: Err sorry, replace "error" by "putStrLn"
22:01:46 <zuserm> It's probably better to use a case than an if. Then you could also print an error for too many args.
22:05:10 <cgag> pavonia: i like it, i like the let, i figured there was a way to avoid using "return" there
22:05:30 <randomclown> So how do I get bytestring using the network package?
22:05:36 <cgag> thanks
22:06:24 <randomclown> Oh rght read directly from fd
22:25:10 <foobar_> how can I convert raw mongodb query results to entity
22:25:21 <foobar_> is there any function for that?
22:25:41 <shachaf> jmcarthur: Do you know if there's a nice "structural" translation of lambda calculus into BCKW described anywhere?
22:26:01 <jfischoff> BCKW?
22:26:10 <shachaf> https://en.wikipedia.org/wiki/BCKW
22:26:30 <shachaf> jmcarthur was just talking about its relation to substructural logic.
22:30:23 <zRecursive> What is the canonical way to make a value from config file visible for serveral IO functions wihout changing its signatures ?
22:31:32 <pdxleif> value providers?
22:31:36 <startling> zRecursive, readConfigFile >>= flip runReaderT myThing
22:31:38 <pdxleif> unsafePerformIO?
22:32:04 <startling> zRecursive, "make available" is the wrong way to think of it, I think
22:32:13 <jfischoff> pdxleif: using an IORef would make more sense, but still a hack
22:32:16 <zRecursive> startling: Do it in every functions ?
22:32:24 <startling> zRecursive, no.
22:32:43 <startling> zRecursive, make every function a "ReaderT MyConfigurationType IO whatever"
22:33:05 <startling> zRecursive: then, when you want to run one in IO, read the config file and runReaderT it.
22:33:15 <zRecursive> then need to change signatures
22:33:16 <jfischoff> usually one changes the type signature, our use a ReaderT or the reflection package
22:33:26 <startling> zRecursive, sure.
22:33:48 <startling> zRecursive, it's not unusual to have to change code to get different behavior. :)
22:34:58 <jfischoff> you could do the top level global data hack. unsafePerformIO and a NOINLINE
22:35:11 <jfischoff> but … why
22:35:12 <zRecursive> but those functions are depended by many places, so we cannot change its signatures now
22:35:35 <startling> zRecursive, search-and-replace
22:35:55 <jfischoff> zRecursive: http://www.haskell.org/haskellwiki/Top_level_mutable_state
22:36:13 <zRecursive> jfischoff: rhx
22:36:18 <zRecursive> thx
22:36:37 <jfischoff> But do read proposal 1 ;)
22:36:56 <zRecursive> reading ...
22:37:12 <startling> the "right" way to do this is to do everything in MonadIO. Then adding the configuration would just add a MonadReader constraint to the declarations that nead it.
22:45:22 <zRecursive> jfischoff: proposal 1 makes me give it up :)
22:46:06 <zRecursive> @hoogle MonadIO
22:46:06 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
22:46:07 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
22:46:07 <lambdabot> package monadIO
22:46:36 <jfischoff> zRecursize: \o/
22:47:06 <suaaarez> https://github.com/ekmett/ad what is the 'tensors' function used in one of the examples/
22:47:17 <suaaarez> i searched in hoogle and came up with nothing
22:47:58 <jfischoff> suaaarez: link to the actual src file
22:48:15 <suaaarez> its in the wiki
22:48:24 <suaaarez> i mean readme file..
22:48:55 <suaaarez> scroll down to find it in one of the examples..
22:48:58 <suaaarez> headJet $ tensors $  grads (\[x,y] -> exp (x * y)) [1,2]
22:49:18 <suaaarez> or simply ctrl + f tensors
22:49:44 <suaaarez> :t headJet
22:49:45 <lambdabot> Not in scope: `headJet'
22:50:17 <suaaarez> import Numeric.AD.Types
22:50:24 <shachaf> Maybe it's renamed to something related to "Jet" now?
22:51:17 <jfischoff> that appears to be true: https://github.com/ekmett/ad/commit/3e52341a22c2b9482f581f866dff02feba28fa1a#diff-837cdd8218e31f51f1b34692380f9b00
22:51:45 * jfischoff makes an issue
22:52:05 <shachaf> I'd like to figure out Jet and its dual at some point.
22:52:19 * jfischoff nods
22:52:36 <jfischoff> trying to write ad is something I would to do
22:53:01 <shachaf> The dual is the thing conal mentioned in his talk once: data Froo f a = Leaf a | Branch (Froo f (f a))
22:53:31 <suaaarez> does hoogle search in hackage packages? its returning nothing when i search headJet
22:53:52 <jfischoff> suaaarez: hoogle searches some of them, hayoo does more
22:53:57 <shachaf> Hoogle only searches base, but maybe try adding +ad to your query.
22:55:32 <suaaarez> how does ekmett everything..
22:55:44 <suaaarez> how does ekmett remember everything
22:55:55 <startling> suaaarez, no, hoogle doesn't search hackage
22:56:16 <jfischoff> @remember suaaarez how does ekmett everything..
22:56:16 <lambdabot> Done.
22:56:36 <startling> suaaarez, http://holumbus.fh-wedel.de/hayoo/hayoo.html <- this does, though, aiui
23:07:05 <juhp> luite, hdiff seems to have stopped updating?  sorry if I am the xth person to mention it
23:16:12 <randomclown> Hmm using Data.Conduit for tcp may seem like a good idea at first, but you give up so much control of the actual socket making it totally not worth it
23:17:10 <startling> randomclown: how do you mean?
23:17:31 <simpson> randomclown: What are you building?
23:17:46 <randomclown> tcp proxy
23:18:10 <simpson> Shouldn't be too hard; there's oodles of examples on how to do it.
23:18:45 <randomclown> Say the upstream connection timed out
23:18:51 <randomclown> and I had a conduit attached to the socket
23:19:04 <randomclown> I have no idea what's going to happen
23:24:42 <startling> randomclown: hm, neither does anyone else, apparently :x
23:28:07 <randomclown> does hGetLine ever throw exceptions/
23:28:15 <randomclown> how does it know if the read failed?
23:28:42 <startling> http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#v:hGetLine
23:29:30 <randomclown> Data.ByteString didn't day anything
23:29:33 <randomclown> say*
23:29:45 <startling> oh, you're using Data.ByteString.hGetLine?
23:29:49 <startling> You shouldn't, anyway.
23:29:49 <randomclown> yeah
23:29:52 <randomclown> why
23:30:02 <startling> ByteStrings don't have lines.
23:30:25 <randomclown> My data stream has new lines though
23:30:45 <randomclown> as the terminator for a segment
23:51:01 <donri> randomclown: there's no such thing as a newline in a bytestring
23:51:22 <donri> maybe you mean it's terminated by a particular byte
23:51:47 <donri> maybe that byte happens to correspond to a newline in a certain encoding, such as ASCII ;)
23:51:57 <randomclown> donri: let's not get too pedantic here
23:52:20 <donri> well it's an important distinction
23:52:26 <randomclown> point taken
23:52:26 <donri> people get unicode wrong all the time
23:52:42 <randomclown> it still annoys me that the Network libary is completely unusable
23:53:01 <randomclown> can't even set a timeout on 'connect'
23:53:42 <zRecursive> randomclown: you need pedantic things :)
23:54:01 <randomclown> these are things that people can't live without man
23:54:13 <startling> randomclown, I think you can.
23:54:18 <randomclown> default connect timeout is 75 seconds
23:54:20 <startling> randomclown, yeah, setSocketOption.
23:54:26 <randomclown> startling: not on connect
23:54:38 <randomclown> you can set timeout for receive sure
23:54:50 <startling> randomclown, SendTimeOut?
23:54:57 <randomclown> and send
23:55:04 <startling> oh, I see.
23:55:05 <randomclown> but 'connect' is different
23:55:08 <donri> @hoogle timeout
23:55:09 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
23:55:09 <lambdabot> package timeout-control
23:55:09 <lambdabot> package timeout-with-results
23:55:23 <donri> it doesn't provide any way to clean up on timeout though :(
23:55:34 <randomclown> there is a proper way to do it without using System.Timeout
23:55:48 <randomclown> and doesn't result in the socket being messedup
23:55:50 <startling> randomclown: yeah, you're right.
23:56:01 <startling> that is odd.
23:56:17 <randomclown> this library is utter garbage, might as well just do everything in semi-C
23:57:00 <startling> yeah, you can write connectWithTimeout in the Haskell FFI but obviously it's not ideal.
