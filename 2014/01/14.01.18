00:29:12 <jle`> if i didn't have auto error highlighting on my ide i don't know how i would ever work with proc do blocks and retain my sanity
00:34:02 <jle`> this is new... "feedback broken by inhibition"
00:34:19 <jle`> oh it's from netwire
01:00:37 <halvorg> Hm, is there a function that does (\x -> [x]) builtin?
01:01:30 <halvorg> not very important, but I think I've seen it somewhere
01:02:24 <supki> halvorg: return
01:02:43 <supki> > return 3 :: [Int]
01:02:45 <lambdabot>  [3]
01:02:53 <halvorg> ah thanks
01:03:50 <Cale> halvorg: There's also the robot monkey (:[])
01:03:51 <Lethalman> halvorg, (:[])
01:24:22 <dsrx> > (:[]) "foo"
01:24:23 <lambdabot>  ["foo"]
01:25:28 <dv-> > return "foo" :: [String]
01:25:29 <Redz> lol. robot monkey. :D
01:25:29 <lambdabot>  ["foo"]
01:27:06 <aleksejs_> there is an app for android, it allows to send expressions to tryhaskell.org and shows the result. Recently it stopped working, because tryhaskell guys have changed api. I've contacted author, and he promised to fix it, but not fixed yet. Is there any alternative?
01:27:31 <Redz> lambdabot implies a list monad?
01:28:41 <AshyIsMe> aleksejs_: you can set up a linux machine somewhere and use connectbot to ssh into it and just use ghci
01:29:36 <aleksejs_> AshyIsMe, it's not an option, because I don't have that kind of machine
01:29:39 <jle`> Redz: what brings you to that conclusion?
01:32:05 <Bohio> virtualbox
01:34:56 <Redz> oh i'm an idiot. i should read code carefully.
01:36:56 <AshyIsMe> aleksejs_: can you just load tryhaskell.org in the browser?
01:37:18 <aleksejs_> AshyIsMe, it doesn't work in mobile browsera
01:37:22 <aleksejs_> s*
01:38:26 <aleksejs_> if you open tryhaskell, you can't type anything
01:43:41 <aleksejs_> I wonder why haven't anyone implemented native interactive haskell env on phones yet
01:46:04 <Redz> there aren't much people who code on a phone. tablet maybe.
01:46:41 <Axman6> aleksejs_: there's a haskell interpreter for iOS I believe
01:48:33 <aleksejs_> Redz, nowadays there's no much difference between phones and tablets. But also I haven't heard about interpreters on tablets, except maybe for windows tablets
01:49:41 <Redz> all in all. there aren't much haskell ide's.
01:49:45 <frx> There's hugs on cydia. raskell looks interestin too
01:49:52 <frx> +g
01:50:10 <Redz> *many
01:51:31 <frx> looks interesting from description, that is. I have never tried it
01:52:19 <arr0w> does fmap work on all monads?
01:55:01 <Kneiva> > :type fmap
01:55:02 <lambdabot>  <hint>:1:1: parse error on input `:'
01:55:10 <Kneiva> :(
01:55:14 <awestroke> arr0w: all monads are functors, and fmap works on all functors
01:55:24 <Kneiva> :type fmap
01:55:28 <arr0w> I see thanks
01:55:32 <Kneiva> :t fmap
01:55:34 <frx> :t fmap
01:55:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:55:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:57:37 <awestroke> Or, all monads are also applicative functors, and all applicative functors are also functors. but somehow there's no "class Applicative m => Monad m where"  constraint on monads
02:05:01 <Redz> a mad scientist would hack it.
02:05:01 <Redz> {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
02:05:01 <Redz> instance Monad a => Functor a where fmap f m = m >>= return . f
02:09:15 <awestroke> Redz: wat
02:10:48 <monoidal> awestroke: adding this constraint is planned in GHC 7.10; GHC 7.8 will warn you if you declare a monad with no applicative instance
02:11:33 <monoidal> Redz: see http://stackoverflow.com/questions/3213490 for disadvantages of this approach
02:19:08 <rawtass> hi, could anyone help me with this code example http://lpaste.net/98722
02:19:32 <rawtass> it fails on the "where". How should I write this type of function?
02:20:25 <monoidal> rawtass: you can use "<-" only in a do block
02:20:43 <rawtass> ah, right..
02:20:48 <rawtass> so I need a do in the where?
02:21:20 <rawtass> I want to use the foo <- getFoo in the guarded expressions
02:21:29 <monoidal> rawtass: do you want to perform getFoo and getBar in both bases y == 1 and y == 2?
02:21:38 <rawtass> yes
02:21:59 <monoidal> rawtass: foo x y = do f <- getFoo; b <- getBar; case y of 1 -> ...; 2 -> ...
02:23:42 <jle`> rawtass: what is your Get type?
02:23:46 <jle`> do you mean IO Int?
02:24:08 <jle`> also...what are you trying to do exactly?
02:24:17 <jle`> you getBar but you don't ever use it
02:24:20 <jle`> ?
02:24:27 <rawtass> it was just a sily example for the syntax
02:25:13 <jle`> ah
02:25:44 <jle`> do you know what <- is supposed to do?
02:25:53 <awestroke> I'm afraid of these {-# LANGUAGE X  #-} pragmas. What are they for? What's wrong with vanilla haskell? Is there any web framework that  uses plain haskell?
02:25:59 <jle`> it's not an assignment and is not the same as ==
02:26:20 <rawtass> jle`: syntactic sugar for the bind expression?
02:26:42 <jle`> awestroke: don't worry about it :) you'll get used to it.  Haskell is inherently an experimental language and new things get added all the time and no standards committee can be bothered to update it and keep up to date
02:26:55 <jle`> you can be comfortable using language pragmas
02:26:58 <jle`> for the most part
02:27:12 <jle`> except for a set of esoteric uses
02:27:33 <awestroke> jle`: {-# LANGUAGE CPP             #-} throws me off though
02:27:36 <awestroke> I'd rather avoid c++
02:27:44 <monoidal> it means c preprocessor, not C++
02:27:45 <jle`> CPP /= c++
02:27:46 <prophile> CPP isn't C++
02:27:49 <prophile> it's the C preprocessor
02:28:16 <prophile> I like to rephrase things
02:28:18 <awestroke> for ifdefs and stuff?
02:28:18 <jle`> you can think of cpp as a glorified awk/perl over the text of your source code
02:28:26 <monoidal> awestroke: yes
02:29:22 <jle`> rawtass: kinda. it doesn't really make sense outside of a do block
02:29:26 <jle`> it's not an assignment
02:31:11 <rawtass> jle`: yes.. I forgot it needs to be in a "do". I am mixing guards, where, case, let, in etc. .. :)
02:31:27 <jle`> :)
02:31:32 <marx2> :t unsafeCoerce
02:31:34 <lambdabot> Not in scope: `unsafeCoerce'
02:31:36 <monoidal> rawtass: did you get it to compile?
02:33:50 <Aetherspawn> oooh wierd
02:34:39 <Aetherspawn> Either im using TChan wrong or lazy IO is messing stuff up :_;
02:34:41 <Aetherspawn> https://github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/pull/17
02:38:52 <rawtass> monoidal: monoidal: no, not yet.. Could you see what I'm doing wrong here https://github.com/Toeplitz/haskell/blob/master/foo.hs on line 123?
02:39:58 <rawtass> it reports incorrect indentation or brackets
02:40:54 <Aetherspawn> rawtass: line 130
02:40:57 <Aetherspawn> you're missing =
02:41:04 <Aetherspawn> after otherwise.
02:41:30 <FreeFull> Aetherspawn: I wonder how you managed to make it so it only works in Linux
02:41:51 <Aetherspawn> FreeFull: it doesn't work on Linux
02:41:53 <Aetherspawn> :/
02:41:54 <monoidal> rawtass: line 127: case sampleInterval of; then you can write 5 -> return $ Trace ...; 1 -> return $ Trace  ..; _ -> error ...
02:42:04 <FreeFull> Aetherspawn: Doesn't work at all then?
02:42:30 <Aetherspawn> yeah
02:42:31 <Aetherspawn> :/
02:42:39 <Aetherspawn> actual code is here
02:42:40 <Aetherspawn> https://github.com/kvanberendonck/Haskell-Pipes-Concurrency-Library/blob/pipes-broadcast/src/Pipes/Concurrent/Broadcast.hs
02:43:10 <FreeFull> This is where you wish you had a debugger
02:43:16 <Aetherspawn> :/
02:43:28 <Aetherspawn> I have no idea how I'm going to debug this
02:45:07 <FreeFull> Comment code out until you get somewhere
02:45:22 <FreeFull> Maybe write dummy replacements for stuff
02:48:53 <jle`> been debugging the same code for days but just realized now that i did my math wrong when calculating one of the constants :|
02:49:03 <jle`> where are you when i need you most, static type checking system
02:49:05 <jle`> :'(
02:49:08 <darthdeus> anyone here using emacs?
02:49:28 <jle`> actually if I had done my entire calculation in my haskell source...maybe things would be different :)
02:50:50 <rawtass> monoidal: all right, thanks. that is cleaner
02:54:41 <eazar001> darthdeus: very seldomly, why?
02:55:02 <darthdeus> eazar001: do you know how to turn on -Wall in the inferior haskell mode?
02:55:23 <eazar001> darthdeus: sorry don't know
02:55:28 <darthdeus> :(
02:55:31 <eazar001> perhaps someone will catch it
02:56:08 <FreeFull> jle`: You could try using a dependently typed system, but nothing will really stop you from telling the computer to calculate the wrong thing
02:56:13 <eazar001> darthdeus: i'll take a look at my emacs and see if can can find something
02:56:34 <darthdeus> i've been trying to google it, but the documentation for haskell-mode doesn't mention this
02:57:26 <awestroke> why are extensions like OverloadedStrings not part of the language yet?
02:59:48 <FreeFull> awestroke: Haskell 2014 might standardise some extensions to be part of the language
03:03:13 <Aetherspawn> I hope they standardise things like PatternGuards
03:03:22 <Aetherspawn> I can't code without those ;_;
03:03:31 <supki> PatternGuards are haskell2010
03:03:38 <Aetherspawn> oh, cool!
03:04:33 <FreeFull> GHC compiles code as Haskell2010 by default too
03:05:00 <Aetherspawn> never really noticed, I use cabal as a build system and I always add PatternGuards under extensions:
03:05:42 <FreeFull> Aetherspawn: I'm guessing you've been using Haskell for over 4 years?
03:06:18 <Aetherspawn> no, just a year and a half now.
03:06:22 <Aetherspawn> or less.
03:06:34 <Aetherspawn> but I used material like LYAH and RWH to learn
03:06:40 <Aetherspawn> they dont teach patternguard syntax
03:06:57 <FreeFull> And you assumed you needed the extension?
03:07:17 <Aetherspawn> yea
03:07:30 <Aetherspawn> I learnt about the syntax reading the wiki
03:07:50 <Aetherspawn> same w/ ViewPatterns which are also very neat
03:08:27 <FreeFull> I like ViewPatterns too
03:08:33 <FreeFull> I hope they'll be in the 2014 standard
03:09:02 <Aetherspawn> They make some awkward functions 1-liners
03:09:27 <Aetherspawn> instead of needing let/where which can look ugly on 1-liners
03:11:52 <jle`> FreeFull: it was actually a dimensional analysis problem...multipled by the square of a mass instead of a mass.  i think there are some libraries that catch this
03:12:01 <jle`> but anyonyways my original concept was sort of a tongue-in-cheek joke
03:12:18 <jle`> referring to the common 'if it compiles it does what you intended' phrase tossed around
03:18:29 <FreeFull> jle`: Ah, yeah, that would be catchable
03:28:02 <darthdeus> what's the difference between "ghci" and "cabal-dev ghci"?
03:28:16 <jle`> darthdeus: ghci uses your global (user) packages etc
03:28:39 <jle`> cabal-dev ghci uses the sandboxed packages and also loads the library you are developing
03:28:47 <jle`> in the sandbox
03:30:19 <JohnnyR_> are there any specific plans when ghc 7.8 will be released?
03:31:32 <monoidal> JohnnyR_: I presume when release blockers are fixed
03:32:12 <JohnnyR_> sounds logical, what might these release blockers be?
03:32:52 <monoidal> JohnnyR_: https://ghc.haskell.org/trac/ghc/query?priority=highest&status=infoneeded&status=merge&status=new&status=patch&col=id&col=summary&col=status&col=owner&col=type&col=priority&col=milestone&order=priority
03:33:07 <monoidal> JohnnyR_: though I can't vow that everything there is a release blocker
03:33:22 <monoidal> there are also plans for merging pattern synonyms to 7.8
03:34:51 <JohnnyR_> hm ok, seems to be mostly stuff related to linking
03:36:02 <jle`> has anyone had problems installing edwardk's linear on 7.7 ?
03:55:02 <monoidal> jle`: what error do you get?
03:55:34 <awestroke> .... why are [Char] and Text incompatible
03:55:34 <jle`> monoidal: https://github.com/ekmett/linear/issues/28
03:55:36 <awestroke> "Couldn't match type `[Char]' with `Text'"
03:55:47 <jle`> can't find type constructor or class 'KnownNat'
03:55:59 <jle`> awestroke: in general...you can't match types with other types
03:56:03 <jle`> unless they are type synonyms
03:56:09 <jle`> this is the whole basis behind type safety :)
03:56:19 <jle`> you can't pass in an Int where you expect a Double
03:56:25 <jle`> you can't pass in a String where you expect a Bool
03:56:27 <jle`> etc.
03:56:38 <awestroke> but strings ===== text!
03:56:44 <jle`> type synonyms are basically lexical aliases
03:56:51 <jle`> Strings and Text aren't the same type
03:56:59 <jle`> a String is a linked list of chars
03:57:06 <awestroke> then what good is Text if I can't bloody use it
03:57:08 <jle`> a Text is a binary blob representing a sequence of chars
03:57:14 <jle`> you can use it for a lot of things
03:57:17 <monoidal> jle`: KnownNat is in GHC.TypeLits in 7.7
03:57:21 <jle`> it's actually more performant than String
03:57:24 <jle`> because it's not a linked list
03:57:34 <jle`> you can use it just as much as you can use a String ... ?
03:57:47 <awestroke> jle`: I'm trying to:  split (=='\n') txt, but since txt is not a Text instance it doesn't work
03:57:48 <jle`> monoidal: hm. so maybe my installation doesn't have TypeLits?
03:58:00 <monoidal> awestroke: use pack/unpack to convert between String and Text. also look at OverloadedStrings
03:58:02 <jle`> :t split
03:58:04 <lambdabot> Splitter a -> [a] -> [[a]]
03:58:09 <monoidal> jle`: I believe it's part of base
03:58:10 <jle`> oh that's unhelpful
03:58:18 <awestroke> monoidal: I'm already using overloadedstrings
03:58:27 <jle`> @hoogle Text -> String
03:58:29 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
03:58:29 <lambdabot> Data.Text.Internal showText :: Text -> String
03:58:29 <lambdabot> Data.Text.Lazy unpack :: Text -> String
03:58:37 <jle`> you probably want unpack
03:58:41 <jle`> it turns a Text into a String
03:58:44 <jle`> but
03:58:52 <byorgey> awestroke: if you are working with Strings, then you probably don't want the split function from Data.Text.
03:58:54 <jle`> i feel like there is a split that works on Text
03:59:11 <byorgey> awestroke: juse use the 'lines' function
03:59:41 <jle`> monoidal: hm i guess this installation does not have it in Base
03:59:44 <jle`> i'm using a pre-built virtual box
04:00:02 <jle`> i'll just build one myself i guess.
04:00:51 <monoidal> jle`: that's extremely weird. it might be an older version of 7.7, there were some changes in TypeLits
04:01:00 * hackagebot Dish 0.0.0.2 - Hash modules (currently Murmur3)  http://hackage.haskell.org/package/Dish-0.0.0.2 (zcourts)
04:01:02 * hackagebot Dish 0.0.0.3 - Hash modules (currently Murmur3)  http://hackage.haskell.org/package/Dish-0.0.0.3 (zcourts)
04:01:04 <jle`> monoidal: yeah i'll try building it myself.
04:01:14 <jle`> was wondering why i couldn't find this error anywhere else
04:01:16 <monoidal> jle`: but the module should be there, even in 7.6
04:01:16 <jle`> thanks
04:02:27 <awestroke> I'm trying to split a multi-line string into parts separated by lines consisting of "-------------- next part --------------"
04:03:55 <Rembane> awestroke: There's a join-function in Data.List but I've forgotten it's name.
04:05:15 <byorgey> awestroke: how about    map concat . splitOn ("-------" `isPrefixOf`) . lines
04:05:22 <byorgey> using splitOn from the 'split' package
04:06:13 <byorgey> uh, sorry, I meant    map concat . splitWhen ("-------" `isPrefixOf`) . lines
04:07:17 <byorgey> one more try:   map unlines . splitWhen ("-------" `isPrefixOf`) . lines
04:07:33 <byorgey> @let s = map unlines . splitWhen ("--------" `isPrefixOf`) . lines
04:07:36 <lambdabot>  Defined.
04:08:00 <byorgey> > s "foo\n----------- next part ------------\nbar\nbaz\n------------------ next part ---------------\nquux"
04:08:02 <lambdabot>  Ambiguous occurrence `s'
04:08:02 <lambdabot>  It could refer to either `L.s', defined at L.hs:149:1
04:08:02 <lambdabot>                        or `Debug.SimpleReflect.Vars.s',
04:08:02 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
04:08:02 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
04:08:24 <byorgey> @let splitParts = map unlines . splitWhen ("--------" `isPrefixOf`) . lines
04:08:25 <lambdabot>  Defined.
04:08:28 <troydm> ohh gawd
04:08:36 <troydm> how i hate it when something fails
04:08:41 <nadirs> Hi everyone! I'm trying to get lambdabot working on my local machine. I've cabal-installed lambdabot and GOA packages and set up .ghci according to the docs.
04:08:42 <nadirs> What I can't get to work is the `sourcePlugin` (a.k.a `@src` here on IRC). I can `import Lambdabot.Plugin.Source (sourcePlugin)`, but it does nothing. It seems I'm missing the file "sourcePlugin" inside the folder "~/.lambdabot/State/". Do you know where I can retrieve a copy of it?
04:08:44 <byorgey> > splitParts "foo\n----------- next part ------------\nbar\nbaz\n------------------ next part ---------------\nquux"
04:08:48 <lambdabot>  mueval-core: Time limit exceeded
04:08:57 <troydm> Failed to install Cabal-1.18.1.2
04:09:15 <troydm> i have latest ghc 7.6.3 installed
04:09:18 <byorgey> troydm: can you paste the error somewhere?
04:09:32 <nadirs> (also, on Debian wiki they report similar issues: https://wiki.debian.org/Haskell/CollabMaint/Lambdabot)
04:09:50 <troydm> byorgey: that is the error i see, should there be detailed error somewhere?
04:10:48 <awestroke> byorgey: can't find splitWhen on hoogle
04:11:09 <monoidal> troydm: look above
04:11:25 <byorgey> awestroke: it's from the 'split' package
04:11:52 <byorgey> (which is part of the Haskell Platform, so you might already have it)
04:11:59 <troydm> also this thing takes long time to compile and then fials silently
04:12:18 <byorgey> hoogle really ought to search all packages from the Platform.
04:12:31 <byorgey> troydm: what command did you use to install it?
04:12:48 <troydm> monoidal: nothing above, only this -> [54 of 72] Compiling Distribution.Simple.BuildTarget ( Distribution/Simple/BuildTarget.hs, dist/build/Distribution/Simple/BuildTarget.o )
04:13:00 <troydm> byorgey: cabal install cabal-install
04:13:07 <monoidal> troydm: lpaste whole output?
04:13:18 <byorgey> oh, hmm, that is strange.  So it stops for a long time on [54 of 72] and then just fails?
04:13:30 <troydm> monoidal: sure, wait a sec
04:15:27 <Redz> i've written `let f = any ((>2) . length) . group . sort` in ghci, but it tells me, that f is `[()] -> Bool` , which isn't correct. it should be `Ord a => [a] -> Bool` . what goes wrong?
04:15:56 <troydm> monoidal: i'll try raising verbosity lvl
04:16:13 <jle`> Redz: sounds like the DMR
04:16:20 <byorgey> Redz: this is the monomorphism restriction in conjunction with ghci's extended defaulting rules.
04:16:24 <jle`> :set -XNoMonomorphismRestriction
04:16:28 <nadirs> Redz: what happens if you add a type signature
04:16:29 <nadirs> ?
04:16:37 <byorgey> adding a type signature works too.
04:16:57 <jle`> is () really an Ord, haha
04:16:57 <byorgey> but turning off the monomorphism restriction, as jle` suggests, is the best path
04:17:08 <nadirs> jle`: does the D in DMR stand for "dreaded"?
04:17:17 <zcourts> When is use of unsafePerformIO actually unsafe? I'm calling a C function which will always return the same value for the same inputs so if the compiler inlines stuff or does whatever, it doesn't affect the fn. Or is there something else I'm missing about unsafePerformIO?
04:17:17 <jle`> nadirs: yes :)
04:17:19 <byorgey> I even suggest putting :set -XNoMonomorphismRestriction  in your .ghci file
04:17:19 <jle`> @where dmr
04:17:20 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:17:59 <byorgey> zcourts: that is an acceptable use of unsafePerformIO (in fact, that was the original motivation for including it)
04:18:05 <nadirs> jle`: :)
04:18:12 <rtpg> Anyone know of a place with good examples of things that are a lot easier to do with monadic IO than with standard imperative programming languages?
04:18:16 <rtpg> In terms of ease of use
04:18:27 <jle`> rtpg: i'm not sure if there is a collection of them
04:18:35 <jle`> but
04:18:40 <Redz> thank you. :)
04:18:42 <jle`> there are things scattered here and there
04:19:10 <jle`> Redz: the problem is that ghc sees "let f =" and thinks "oh, f is a constant that i can precompile!", and picks a concrete type so it can optimize for it.
04:19:25 <zcourts> byorgey: oh good, thanks
04:19:34 <Redz> interesting.
04:19:50 <jle`> it seems pretty dumb in this case
04:20:02 <jle`> but
04:20:14 <jle`> collapsing the polymorphism allows for some nice optimications
04:20:24 <jle`> for example, every function that uses only (+) etc. can be used for any Num
04:20:36 <Redz> language design is very difficult. probably it prevents even worse things.
04:20:48 <jle`> but if you know it's only going to be used for ints or doubles, GHC can compile it down knowing that it is an int/double
04:20:57 <jle`> if you leave it as Num a =>
04:21:01 <jle`> then it can't relaly...do anything
04:21:06 <jle`> what if someone comes along and writes their own Num instance
04:21:10 <jle`> that does really weird things?
04:21:27 <jle`> usually though the DMR harms programmer expressiveness for the benefit of compilers
04:21:33 <jle`> so it's typically thought of as a bad idea kinda maybe
04:21:44 <jle`> it's offloading the work of the compiler to the programmer which is usually something to be avoided
04:22:13 <jle`> there really aren't any cases where the monomorphism restriction helps someone be more expressive or reason about their program better etc.
04:22:47 <jle`> but it also prevents silly things like x = 1 + 1 being recomputed every single time it's referred to
04:24:00 <monoidal> that's the point of DMR - avoiding surprising recomputation
04:24:09 <Redz> theoretically, there is a solution for both problems .
04:25:13 <jle`> rtpg: one commonly cited thing is concurrency
04:25:25 <jle`> although it doesn't technically have to do with "monadic" IO
04:25:34 <jle`> it is more a consequence that in Haskell IO objects are just...objects
04:25:37 <jle`> representing commands
04:25:58 <jle`> so you can generate arbitrary representations of commands and give them names
04:26:15 <jle`> with full programmatic power
04:26:27 <jle`> kind of like a super-lisp or a super macro language
04:26:37 <jle`> and sequence, compose programs
04:26:47 <jle`> and then just name them as a variable
04:27:22 <jle`> all of these little program objects are self-contained
04:27:48 <jle`> you can think of them as little chunks of assembly code you can compose and sequence and manipulate first-class, or little C source files etc.
04:27:54 <jle`> all self-contained, independent
04:28:09 <jle`> in the context of concurrency it is convenient because you can just pop one of those in a fork
04:28:38 <jle`> you pass the fork command a self-contained standalone program object
04:29:20 <jle`> idk there are a lot of really neat things you can do once you stop working with actual imperative commands and work with objects representing them
04:29:23 <rtpg> jle`, I was thinking about the macro argument, yeah
04:29:36 <jle`> but also there is equational reasoning http://www.haskellforall.com/2013/12/equational-reasoning.html
04:29:45 <Redz> sounds like oop. ;)
04:30:05 <jle`> which is more or less impossible to do in the same way with imperative code
04:30:48 <jle`> Redz: it's not really object oriented in most sensible definitions of oop
04:31:10 <jle`> even if you use objects...the entire programming model/semantic model etc. is pretty different from the ground up
04:31:47 <rtpg> I have such a hard time explaining to people how the combination of lazy evaluation and combinator-based programming makes everything awesome
04:32:57 <jle`> in the vein of combinator based programming...
04:33:03 <jle`> there's also kind of functor-based programming
04:33:20 <jle`> which is pretty neat
04:33:58 <jle`> it's that you can do your program in any 'domain' that you want...and all you have to do is to write code that turns a function in one domain into a function in another
04:34:43 <jle`> like if I want to work in the context of Maybe's...i can do everything in the context of normal values and more...all i need is a way to turn a function on normal values into a function on Maybe values, and i'm set
04:34:51 <jle`> and you can mix and match together different contexts
04:34:57 <jle`> Parsers, for example
04:35:14 <jle`> so you have all of the power of normal functions, maybe functions, etc.
04:35:21 <jle`> in any domain that you can use
04:35:34 <jle`> as long as you have that function transformer
04:35:54 <jle`> which in haskell is fmap :: (a -> b) -> (f a -> f b)
04:36:26 <jle`> it sort of frees you to be able to work in whatever context you want and seamlessly transition from one to another because you can carry all your functions with you
04:36:31 <Redz> lambda/functor is something, that frequently breaks my mind. like a additional dimension to think in.
04:37:23 <jle`> http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
04:40:45 <rtpg> I wonder if there's any real use cases for (f a -> f b) -> (g a -> g b)
04:40:55 <rtpg> like , would such a thing even be really feasable for certain f /g
04:41:05 * hackagebot vcsgui 0.0.2 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.0.2 (StephanFortelny)
04:43:16 <bezirg> Hi guys, I am working on a "kind-of" functional language that has let nonrec constructs. I am translating this language to Haskell and I am thinking to just translate let x = e1 in e2 with (\ x -> e1) e2  , since I think that my language does not need let-polymorphism. How can I test if this language supports let-polymorphism? Any examples in Haskell?
04:44:53 <monoidal> let f x = x in (f "a", f True)
04:45:49 <bezirg> monoidal: thx! I'll try that
04:48:59 <bezirg> monoidal: I think my language does not even have lambdas :) So, you can only introduce variables with let and not functions. Can I conlude from this that the language does not have let-polymorphism?
04:51:06 * hackagebot vcswrapper 0.0.3 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.0.3 (StephanFortelny)
04:52:38 <Guestt> can anyone help me with my code? i'm new to Haskell and cant seem to figure out the problem. http://lpaste.net/98725
04:52:51 <monoidal> bezirg: does it have polymorphism at all?
04:53:06 <monoidal> bezirg: can you write let f x = x to get polymorphic identity?
04:54:43 <Guestt> anyone?
04:55:13 <Cale> Guestt: sure
04:55:24 <allsystemsarego> > runStateT (replicateM 2 (StateT select)) [1,2,3]
04:55:25 <lambdabot>  Not in scope: `select'
04:55:26 <Guestt> thanks!
04:55:48 <Cale> Guestt: Okay, let's rethink prefix (x:xs) a bit
04:56:18 <Guestt> okay
04:56:26 <Cale> we know, from the example, that prefix (1 : [2,3]) is supposed to be [] : [[1],[1,2],[1,2,3]]
04:56:42 <Cale> i.e. its first element is an empty list
04:56:52 <Guestt> yea
04:57:36 <Guestt> it will not work with (x:xs)?
04:57:54 <Cale> We'd like to somehow write the list [[1],[1,2],[1,2,3]] in terms of 1, and the list prefix [2,3] which, assuming that it works as it's supposed to, will produce [[],[2],[2,3]]
04:58:14 <Cale> Well, before we get to that, we know that:
04:58:23 <Cale> prefix (x:xs) = [] : ...
04:58:46 <Guestt> empty list added to ...?
04:58:52 <Cale> yeah
04:59:01 <Cale> i.e. the first element of our result will always be the empty list
04:59:35 <Cale> now, suppose I gave you  prefix xs  for free
04:59:37 <Guestt> yeah
05:00:11 <Cale> How can we use x to build the rest of prefix (x:xs)?
05:00:20 <Guestt> ok let met think on it
05:00:27 <Guestt> 1 sec
05:00:27 <Cale> For example, how can we use 1 to get from [[],[2],[2,3]] to [[1],[1,2],[1,2,3]]
05:00:42 <Cale> (hopefully you know about some other basic list functions at this point)
05:01:16 <Cale> We want to add the element 1 to the beginning of each of the lists, right?
05:01:24 <Guestt> yea
05:01:31 <Guestt> use map?
05:01:32 <zomg> klrr_: failed your trolling on #Node.js huh
05:01:34 <Cale> yes
05:01:34 <zomg> klrr_: lol
05:02:29 <Cale> > map (1:) [[],[2],[2,3]]
05:02:30 <lambdabot>  [[1],[1,2],[1,2,3]]
05:02:35 <Cale> Or:
05:02:41 <bezirg> monoidal: you can't write let f x = x but you can write top-level identity. So it has polymorphism only at the top-level
05:02:41 <Cale> > map (\xs -> 1:xs) [[],[2],[2,3]]
05:02:43 <lambdabot>  [[1],[1,2],[1,2,3]]
05:03:50 <monoidal> bezirg: can you write let i = id in (i "a", i True)?
05:04:16 <Cale> > let i = id in (i "a", i True)
05:04:17 <lambdabot>  ("a",True)
05:04:44 <Cale> Thank you lack of polymorphism restriction!
05:04:59 <quchen> :-)
05:04:59 <Cale> (actually, I'm not sure the MR applies to that anyway)
05:05:49 <Cale> actually though, wasn't let supposed to not be generalised in GHC now?
05:05:56 <Cale> If you didn't give type signatures?
05:06:03 <hpc> it always takes me a while to remember why that line works, because of how forall is implicit everywhere
05:06:50 <Cale> hpc: Well, it's because the last step in inferring the type of a let bound thing is to generalise the type
05:06:57 <Cale> It's not *everywhere*
05:07:07 <Cale> > (\i -> (i "a", i True)) id
05:07:08 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
05:07:08 <lambdabot>              with actual type `GHC.Types.Bool'
05:08:29 <bezirg> monoidal: no, because you cannot refer to id without fully applying it. No eta-reduction, no higher-order functions, no function arrow (->) type supported
05:08:49 <Cale> I believe if you turn on certain extensions, the default is to switch off the let generalisation step in type inference
05:09:19 <Cale> it apparently interacts poorly with some of the type system extensions in GHC
05:09:49 <Cale> But you can still give polymorphic local definitions with explicit type signatures then
05:11:07 * hackagebot Dish 0.0.0.4 - Hash modules (currently Murmur3)  http://hackage.haskell.org/package/Dish-0.0.0.4 (zcourts)
05:14:47 <monoidal> bezirg: it seems you cannot define a polymorphic value using let then
05:16:14 <bezirg> monoidal: that's what I suspected. ty for making it cler
05:16:18 <bezirg> monoidal: clear*
05:31:09 * hackagebot console-program 0.3.1.2 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.1.2 (AriePeterson)
05:40:19 <troydm> monoidal: http://lpaste.net/98726
05:40:34 <troydm> monoidal: sorry for delay, i had some other business to attend
06:02:06 <jonkri> Is it possible to derive SafeCopy for complex constructors (such as for existentially qualified types)?
06:13:46 <curried> The maybe monad is quite brilliant in all its simplicity, how often in java and C dont you have this problem of a failing function and you dont want to return -1 or null. sure you can have n inparameter but in java you can only modify it if it is an object and it is nicer to return something.
06:18:11 <troydm> i've even set higher verbose level
06:18:14 <troydm> and now it says
06:18:17 <troydm> Could not find module `Network.URI'
06:18:28 <troydm> There are files missing in the `network-2.4.2.2' package
06:21:12 * hackagebot hedis 0.6.3 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.3 (FalkoPeters)
06:22:32 <merijn> troydm: Which OS is this?
06:25:15 <XniX23> i've just seen John Carmack's talk about haskell on quakecon, you guys think its ok to use it for hardcore game dev?
06:25:44 <merijn> XniX23: I think it depends on the type of game
06:25:46 <Aetherspawn> XniX23: from what I've seen C++ looks easier IMO
06:26:01 <Aetherspawn> but thats probably just because I come from a C++ gamedev background
06:26:32 <merijn> XniX23: Twitchy FPS? Probably not? The kind of stuff people implement in Lua/JS/Java these days? Probably possible, but you won't have as much tooling
06:26:35 <Aetherspawn> I have no trouble reading some of the haskell gamedev stuff, but 3d inparticular just looks convuluted IMO
06:26:38 <XniX23> Aetherspawn: he mentioned that they spend a lot of time fixing bugs caused by all global flags etc
06:26:59 <Aetherspawn> disclaimer: I'm more talking about LambdaCube
06:27:06 <Aetherspawn> since thats the engine I tried to learn
06:27:12 <XniX23> merijn: why not twitchy fps?
06:30:05 <merijn> XniX23: Those require really tight timing constraints on network (and usually due to that) frame rendering, which means getting enough speed in a GC'ed language might be hard
06:36:31 <troydm> merijn: ArchLinux x86 64-bit
06:39:25 <merijn> troydm: I don't really see an error in your paste?
06:39:28 <troydm> merijn: i think i got myself into so called 'cabal hell'
06:39:45 <troydm> merijn: yes that's because, there was none
06:39:54 <troydm> merijn: i've runned ghc-pkg check
06:40:22 <troydm> merijn: and it reports bunch of packages not working
06:41:43 <jophish_> Yo yo yo
06:41:49 <merijn> troydm: You installed it from the arch package manager I'm guessing?
06:41:57 <jophish_> How can I pass flags to ld when compiling with cabal?
06:42:24 <merijn> troydm: People mean something else when refering to "cabal hell" (and that's not as big a problem as the interwebs make it seem)
06:43:52 <merijn> troydm: Usually when "ghc-pkg check" complains about packages not working it's the fault of the OS package manager. From the complaints I see in here some linux distros (including Arch, of course) insist on having their package managers install haskell packages globally, which is not recommended (and inevitably, this breaks things)
06:44:45 <merijn> troydm: I don't really have experience with arch or the other distros, though. Did you install the haskell platform?
06:45:32 <Aune> I installed lens, which depends on monads-tf-0.1.0.1, but now I get "Ambiguous module name `Control.Monad.State':   mtl-2.1.2, monads-tf-0.1.0.1"
06:45:42 <Aune> what is the recommended solution?
06:47:36 <bob4> hi I have written up my questions in this stackoverflow post, if you can have a look I will be deeply grateful http://stackoverflow.com/questions/21205213/haskell-tail-recursion-version-of-depth-of-binary-tree
06:51:17 <merijn> bob4: The notion of "tail recursion can be turned into a loop that doesn't consume extra stack" is wrong in Haskell
06:51:57 <merijn> bob4: If you're experienced in other languages, you're probably familiar with the fact that every function call pushes an extra stack frame and when you run out of stack space you crash with a stack overflow
06:52:14 <troydm> merijn: yes, i've installed it from pacman
06:52:22 <merijn> bob4: However, Haskell doesn't use a stack/stack frames for function calls, so this entire notion is irrelevant
06:52:42 <bob4> merjin: so how does a haskell program execute?
06:52:52 <troydm> merijn: never mind i'm reinstalling all failed packages
06:53:16 <merijn> bob4: In haskell tail recursion helps mostly by not building up large thunks, not by eliminating the need for stack frames (as we don't have those)
06:53:49 <merijn> troydm: I know others have had better results with just manually installing GHC + cabal and installing all haskell stuff using cabal. But as I said, I'm not an Arch user, so your mileage may vary
06:54:28 <troydm> merijn: yeah okey
06:54:36 <darthdeus> i'm getting the following error when i run cabal-dev ghci "cabal-dev: user error (cabal: Can't parse --info output of GHC" when following http://www.youtube.com/watch?v=-IpE0CyHK7Q, any thoughts on why?
06:55:00 <darthdeus> also, where can i find a good cabal tutorial? :)
06:55:08 <skuggi> merijn: it doesn't have stack frames at all? why do you get stack overflows then?
06:55:22 <merijn> bob4: Haskell evaluation works as follows (this is a very operational view), when you apply a function you create a "thunk" (that is, an unfinished computation)
06:55:39 <merijn> skuggi: Haskell uses a pattern matching stack, which can overflow but is unrelated to number of function calls/tail calls
06:56:11 <Cale> Or GHC does, anyway
06:56:14 <skuggi> merijn: oh, ok.
06:56:24 <merijn> skuggi: So you *can* stack overflow, it's just completely unrelated (well, not entirely as there is a corelation between number of function calls and pattern matches, obviously) to function calls
06:56:39 <skuggi> yeah, that makes sense
06:57:09 <merijn> bob4: So, what happens when you try to pattern match against a thunk? The code gets evaluated *just* far enough to produce a constructor that GHC can match
06:58:12 <merijn> bob4: For example, when I do "case map (+1) xs of (y:ys) -> y" the map call creates a thunk, GHC tries to match the thunk against the pattern (y:ys) and sees it needs to evaluate the thunk
06:58:51 <merijn> bob4: Now, map is defined as "map f (x:xs) = f x : map f xs"
06:59:56 <merijn> bob4: Of course, the "f x" and "map f xs" just produce thunks without further evaluation too. But the pattern match was only looking for a ':' so "<thunk 'f x'> : <thunk 'map f xs'>" is sufficient to return a result ('y', which is the thunk of 'f x')
07:00:07 <darthdeus> :(
07:01:09 <bob4> merjin: so thunk is just like a stack but without computing the expression out explictly?
07:01:19 <merijn> bob4: Now, trying to match this pattern may force us to first do another pattern match, which means we create a new pattern match stack entry for that new pattern.
07:01:46 <merijn> bob4: If we run out of pattern matching stack space before being able to return a value, you get a pattern match stack overflow and crash
07:02:34 <merijn> bob4: In the "map f (x:xs) = f x : map f xs" example, the code isn't tail recursive. But since we can pattern match on ':' directly, without any other matches, we don't consume any stack space. Efficiency!
07:03:27 <merijn> bob4: If we take a simpler version of your tree depth function (i.e. length on a list), we have "length [] = 0; length (x:xs) = 1 + length xs"
07:04:57 <merijn> bob4: When I do "case length xs of 2 -> True" we have to pattern match '2' against the result of "length xs", we try to evaluate it and get "1 + <thunk 'length xs'>".
07:05:14 <merijn> bob4: Now, + needs to match on it's second argument before we get a result and can tell if we match '2'.
07:05:53 <merijn> bob4: So we add a new pattern match stack frame and use it to evaluate "<thunk 'length xs'>", but that looks the same as the old one (although the list is now one item shorter)
07:06:15 <merijn> bob4: So the problem is that if 'xs' is long, we need a new pattern match for every item in 'xs', which can overflow our pattern match stack
07:07:24 <merijn> bob4: So now we have one efficient non-tail recursive function and one non-efficient one, so we can already see we don't necessarily need tail recursion for efficiency
07:07:45 <merijn> bob4: Another problem is that tail recursion doesn't even always make your code efficient in all occassions
07:08:04 <merijn> If we make 'length' tail recursive, we avoid the pattern match stack overflow, but introduce a new problem
07:08:22 <bob4> but rewrite it as "length l [] = l; length l (x:xs) = length (l+1) xs" can make your pattern matching stack reusable can't it?
07:09:01 <Cale> No, it creates a problem
07:09:15 <merijn> bob4: Yes, that one doesn't overflow the pattern match stack, BUT since haskell is lazy "l+1" doesn't get evaluated, it just produces a thunk "<thunk 'l'> + 1"
07:09:46 <Cale> Let's not use the word thunk, let's just consider how the expressions reduce:
07:09:49 <bob4> Cale: what problem?
07:09:53 <Cale> length 0 [1,2,3]
07:10:00 <Cale> -> length (0+1) [2,3]
07:10:05 <Cale> -> length ((0+1)+2) [3]
07:10:15 <Cale> oops :)
07:10:18 <Cale> length, not sum
07:10:24 <Cale> -> length ((0+1)+1) [3]
07:10:25 <Cale> rather
07:10:32 <Cale> -> length (((0+1)+1)+1) []
07:10:56 <Cale> no stack (well, maybe one stack entry for matching the list) has been required to this point
07:10:59 <Cale> but now:
07:11:05 <Cale> -> (((0+1)+1)+1)
07:11:35 <Cale> Remembering that expressions are evaluated outermost-first, the outermost (+) sees  (...) + 1
07:11:50 <bob4> Cale: what about it? it sees fine, you just need to evaluate it
07:12:00 <Cale> It needs to pattern match on its left argument to decide which number to product
07:12:01 <Cale> produce*
07:12:12 <nadirs> Cale: I see you often write the "unrolled" (or how it is called) representation of a function expression in Haskell. Is there a tool that does it automatically?
07:12:24 <Cale> So, this pattern match goes on the stack while we evaluate the expression (...)
07:12:25 <Cale> which is ((0+1)+1)
07:12:35 <benmachine> nadirs: I tried to write such a tool but it had bugs
07:13:05 <Cale> and now we're in the same position as before, the outermost (+) needs to pattern match on the number on its left
07:13:06 <Cale> and so that pattern match waits on the stack, and we evaluate (0 + 1)
07:13:18 * darthdeus feels powerless fighting with the cabals
07:13:25 <nadirs> benmachine:  I've installed Debug.SimpleReflect, but it does not exactly the trick
07:13:34 <darthdeus> http://lpaste.net/98728 any thoughts please? :P i've only managed t o google another lpaste of the same error
07:13:44 <Cale> and now 0 and 1 will be pattern matched on causing their evaluation (which I won't worry about making visible here)
07:14:03 <idnar> is there a "standard" implementation of http://lpaste.net/98729 anywhere?
07:14:06 <merijn> darthdeus: Doesn't cabal 1.18 obsolete cabal-dev?
07:14:08 <Cale> and finally this innermost (+) will be able to produce the result 1
07:14:13 <merijn> darthdeus: Might wanna upgrade cabal and use that instead
07:14:28 <darthdeus> merijn: this is the first time i'm doing something in cabal-dev so i have no idea
07:14:45 <Cale> and then popping the stack the pattern match in 1 + 1 will go through, and then 2 + 1, and finally we'll compute 3
07:14:48 <merijn> darthdeus: Oh, then I would definitely just update cabal to 1.18 and use that instead
07:14:58 <darthdeus> merijn: i have 1.18 :) but there's no cabal ghci
07:15:16 <Cale> bob4: So the problem isn't that length itself needed lots of pattern matches, it's that (+) did, once length had finished its work
07:15:27 <klrr_> im trying to write a parser that accept this syntax ":<user!nick@>host ", it accept ":foo!bar@localhost " but not ":localhost ", anyone can help me? http://lpaste.net/98731 it's written in attoparsec
07:16:16 <darthdeus> oh there's cabal repl, i guess that's the same thing
07:16:27 <nadirs> ghci> let len n (x:xs) = len (n+1) xs; len n [] = n
07:16:27 <nadirs> ghci> len x [1,2,3]
07:16:27 <nadirs> Loading package simple-reflect-0.3.1 ... linking ... done.
07:16:27 <nadirs> x + 1 + 1 + 1
07:16:27 <nadirs> benmachine: ↑
07:16:31 <merijn> darthdeus: I was about to say, that :)
07:16:34 <bob4> Cale: cool I understand that right now, can you force that l+1 to be evaluated when length is involked?
07:16:40 <darthdeus> merijn: thanks :)
07:16:43 <bob4> invoked*
07:16:58 <merijn> bob4: Yes!
07:17:10 <Cale> bob4: Yes, well, you can use a bang pattern or seq to ensure that things don't get out of hand
07:17:10 <bob4> merjin: how?
07:17:20 <merijn> bob4: This is where the BangPatterns extension comes in, it says "force this before continuing"
07:17:40 <Cale> Or you could (somewhat perversely) just make length pattern match on its numeric argument as it goes
07:17:55 <Cale> (just to show that it's equivalent :)
07:18:06 <bob4> ok let me google for a bit
07:19:00 <Cale> length [] !n = n; length (x:xs) n = length (n+1) xs
07:19:02 <jonasw> klrr_: Did something similar a while ago https://github.com/nlogax/norby/blob/master/src/Parser.hs
07:19:08 <idnar> I've found a few throwaway examples that implement something similar, but I was hoping for something more widely used
07:19:23 <Cale> actually, let's be careful :)
07:19:26 <Cale> length [] !n = n; length (x:xs) !n = length (n+1) xs
07:19:41 <bob4> Cale: what does !n mean?
07:19:47 <bob4> bang patter?
07:19:50 <Cale> bob4: So what this does is to force the parameter n to be evaluated, as if we were pattern matching on it
07:19:51 <bob4> pattern*?
07:20:06 <bob4> cool that's nice
07:20:15 <Cale> (So, in general, as much evaluation as is required to determine the top-level constructor)
07:20:40 <Cale> oops, lol, I swapped the parameters there
07:20:54 <bob4> haha that's fine
07:20:59 <Cale> (I will blame the lack of coffee in the house)
07:21:08 <bob4> Thanks merjin and cale, that's helpful
07:23:02 <Cale> bob4: Generally when trying to understand the performance of Haskell programs, I pretend that expression graphs (or even just trees) are simply being manipulated at runtime, and that evaluation is lazy, i.e. that it's outermost-first, and that any work done to evaluate an expression bound to a variable will apply to all the occurrences of that variable
07:23:34 <klrr_> jonasw: thanks, reading code now
07:23:54 <Cale> bob4: What GHC actually does is close enough to that, that you'll only ever be pleasantly surprised when things run faster or in less space than you'd think.
07:24:33 <Cale> (GHC actually is allowed by the standard to choose other evaluation orders, so long as it doesn't affect the termination behaviour of the program, and it frequently does)
07:25:34 <b80905> how does haskell compare functions?
07:25:44 <c_wraith> it doesn't
07:25:57 <c_wraith> > id < (+)
07:25:58 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
07:25:58 <lambdabot>  Expected type: a0 -> a0
07:25:58 <lambdabot>    Actual type: a0 -> a0 -> a0
07:26:03 <c_wraith> err, hah.
07:26:13 <c_wraith> > (+) < (-)
07:26:14 <lambdabot>  No instance for (GHC.Classes.Ord (a0 -> a0 -> a0))
07:26:14 <lambdabot>    arising from a use of `GHC.Classes.<'
07:26:14 <lambdabot>  Possible fix:
07:26:14 <lambdabot>    add an instance declaration for (GHC.Classes.Ord (a0 -> a0 -> a0))No insta...
07:26:14 <lambdabot>  The type variable `a0' is ambiguous
07:26:46 <Cale> The choice of explicit module qualifications there is unfortunate
07:26:51 <c_wraith> The important part there is that there's no Ord instance for functions
07:27:10 <merijn> Evil idea: "instance (Bounded a, Eq b) => Eq (a -> b)"
07:27:32 <geekosaur> there's a module for that, I think
07:27:38 <c_wraith> it's a little slow
07:27:42 <merijn> geekosaur: acme-php? :p
07:27:50 <merijn> geekosaur: Only for some functions!
07:28:07 <merijn> I imagine it's quite fast for "Bool -> Bool" :p
07:28:21 <merijn> Or "() -> a"
07:28:28 <Guest24> so the difference is that haskell manipulates expression trees at runtime, whereas other languages simply compile to expression trees at compile time and don't manipulate expression trees at runtime?
07:28:58 <geekosaur> no, there's a module that adds the idea of finite types and allows that kind of operation, IIRC
07:28:59 <merijn> Guest24: Haskell doesn't manipulate expression trees at runtime, it's just a sufficiently good model for what *actually* happens that it's useful to think that way
07:29:00 <c_wraith> Guest24: no, it's not that simple.  the compiler does things smarter than that.
07:29:19 <geekosaur> (Bounded is not enough for this, IIRC)
07:29:22 <b80905> well, why does let {find k t = [v | (k,v) <- t]} in find (\x->2) [((\x->2),4)] evaluates to [4] then?
07:29:46 <merijn> geekosaur: Well, I guess "(Enum a, Bounded a, Eq b) => Eq (a -> b)", then
07:29:48 <Guest24> ahh i see, I think it's a good abstraction though to help understand things
07:30:16 <merijn> Guest24: It is, hence why people use it. But what GHC actually does is far smarter and more elaborate :p
07:30:26 <c_wraith> b80905: err.  that definition of find ignores its first argument
07:30:29 <geekosaur> http://hackage.haskell.org/package/universe
07:30:42 <c_wraith> b80905: pattern matches shadow names previously in scope
07:30:49 <geekosaur> IIRC there are infelicities in both Enum and Bounded that cause problems
07:30:53 <c_wraith> b80905: rather than perform equality comparisons
07:30:53 <Cale> Guest24: Also, there's a way of looking at what it actually does (which involves lots of code pointers) as being analogous to this
07:31:15 <Cale> Where by 'it', I mean GHC specifically
07:31:39 <Cale> Haskell the language doesn't specify how, or even in which order, expressions are meant to be evaluated
07:31:51 <c_wraith> b80905: your find function there is equivalent to map snd
07:32:09 <Cale> It only specifies what the results and termination behaviour of those expressions ought to be.
07:33:39 <Guest24> so there's the "runtime" which implements this behavior.  Do other languages have an analogy to the haskell "runtime" which does the dirty work, or is this uniquely a haskell innovation to have this split
07:33:55 <c_wraith> nearly every language with garbage collection has that
07:34:36 <Guest24> it's mainly the specified vs unspecified behaviors then. similiarly GC isn't specified in most langs
07:34:40 <merijn> Guest24: Hell, even hosted C (i.e. anything that's not baremetal C code) has a runtime
07:35:54 <c_wraith> GHC's runtime handles concurrency operations, IO scheduling, and garbage collection.  The evaluation/execution bits are actually handled by the compiler.
07:36:01 <Guest24> yeah, I just wasn't sure if it in the same category of "runtimes" (it's  not the word thats important), sinece haskell has the fancy stuff going on
07:36:48 <c_wraith> actally, GHC has two different runtimes that handle those things in entirely different ways, depending on whether you want your program to support multiple native threads or not.
07:36:49 <Guest24> I think I'm hampered by my lack of understanding language internals ;)  never implemented a lang
07:36:57 <merijn> Guest24: Sure, Haskell definitely has one of the more elaborate runtimes. At some point all the native code, byte code, interpreted, compiled, virtual machine, runtime terms bleed into each other :p
07:37:40 <Guest24> yeah that's confusing ;)
07:37:47 <merijn> Guest24: You should, my compiler course was one of the more enlightening courses I ever took. We implemented a compiler for "C-like" language to ASM for a stack VM, it was surprisingly easy
07:38:16 <merijn> Guest24: Have you had a look at "Write Yourself a Scheme in 48 Hours"?
07:40:29 <Guest24> i've heard of it.  made an attempt at doing the Coursera compilers course but was work intensive, i intend to give it another go
07:40:41 <lingxiao> uh syntax question
07:40:46 <c_wraith> Yeah, I think most people's conclusion at the end of a compiler's course is that it's conceptually not that hard.  Though handling bigger languages and doing more code transformation is a lot more work.
07:41:05 <c_wraith> *compilers* course.  (Too early to grammar)
07:41:27 <lingxiao> if I want to write combinator of typogrpahical form (;), how do I do it?
07:41:47 <c_wraith> lingxiao: that symbol is reserved, it's part of the language syntax
07:41:53 <lingxiao> ohhh...
07:41:56 <Guest24> thats encouraging though that its at least approachable
07:42:29 <merijn> Guest24: Another bonus, functional languages *rock* at compilers :)
07:43:11 <troydm> monoidal: it seems something went wrong with ArchaLinux anyway i've decided to go with Ubuntu 12.04 instead
07:43:29 <troydm> monoidal: should i install Haskell from source? or go with sudo apt-get install haskell-platform ?
07:43:47 <Guest24> interesting video: https://www.youtube.com/watch?v=TS1lpKBMkgg in a guy working on the scala compiler basically calls it quits because it's such a mess
07:44:14 <c_wraith> troydm: use the pre-compiled binaries on haskell.org/ghc .  Even though they say that they're probably not what you want.  they are what you want.
07:44:41 <merijn> Guest24: Scala is a...rather complicated language :)
07:45:11 <merijn> Guest24: Compilers don't always have to be complicated, especially if you don't plan to do a lot of optimisations or target a higher level language as output
07:45:17 <c_wraith> Yeah, Scala is probably the most complicated non-joke language ever implemented.
07:45:33 <Guest24> I liked it a lot at first, I can read my own code.  I'm not sure about others code
07:45:46 <b80905> how do you check if a list is sorted?
07:46:31 <merijn> b80905: Why do you wanna check that?
07:46:50 <b80905> merijn: it's an exercise
07:46:53 <Guest24> also want to try this one out http://www.stephendiehl.com/llvm/ , but I'm happy with just doing the exercisim.io problems for now
07:47:00 <c_wraith> :t all . (zipWith (<) `ap` tail)
07:47:02 <lambdabot>     Couldn't match type `a0 -> Bool' with `[Bool]'
07:47:02 <lambdabot>     Expected type: [b0] -> [b0] -> a0 -> Bool
07:47:02 <lambdabot>       Actual type: [b0] -> [b0] -> [Bool]
07:47:05 <c_wraith> drat
07:47:23 <merijn> c_wraith: Sounds like homework, not very helpful to just hand him a solution
07:47:26 <c_wraith> I was hoping to be clever without checking
07:47:34 <c_wraith> merijn: no one sane would consider that a solution. :)
07:47:51 <merijn> c_wraith: Oh, reminds me of a nice StackExchange post
07:48:26 <lieven_> sorted x = x == sort x
07:48:27 <merijn> c_wraith: https://codegolf.stackexchange.com/questions/16226/i-need-a-program-where-the-user-inputs-an-array-of-doubles-and-the-program-outpu
07:48:32 <c_wraith> also, even if I'd got it right, it has a clever bug in it.
07:49:21 <StoneToad> lieven_: ouch, folding (<) or (>) is much more effecient
07:50:05 <c_wraith> Oh, I see.  I wanted and, not all
07:50:30 <StoneToad> :t and
07:50:31 <lambdabot> [Bool] -> Bool
07:50:33 <StoneToad> :t all
07:50:34 <lambdabot> (a -> Bool) -> [a] -> Bool
07:50:55 <lieven_> StoneToad: it's just a factor log n. I'm assuming the compiler will not have the smarts to bail out early
07:50:55 <b80905> merijn: my textbook solves the problem by defining a function pairs xs = zip xs $ tail xs and then sorted xs = and [x<=y | (x,y)<- pairs xs]. i wonder if there is a shorter solution
07:51:00 <c_wraith> b80905: StoneToad and is the same as all id
07:51:26 <c_wraith> err, whoops
07:51:47 <c_wraith> b80905: conceptually, no.  in practice, you can always write it shorter
07:51:51 <c_wraith> :t and . zipWith(<=)`ap`tail
07:51:52 <lambdabot>     Precedence parsing error
07:51:52 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
07:52:02 <c_wraith> :t and.(zipWith(<=)`ap`tail)
07:52:03 <lambdabot> Ord b => [b] -> Bool
07:52:10 <c_wraith> But it's really the exact same code
07:52:38 <c_wraith> as a fun exercise, figure out why it's the same. :)
07:52:55 <b80905> c_wraith: what's ap?
07:53:09 <c_wraith> b80905: the hardest part of the exercise
07:53:16 <c_wraith> :t ap
07:53:17 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:54:03 <b80905> c_wraith: my ghc implementation says 'not in scope `ap''
07:54:13 <StoneToad> import Control.Monad
07:55:50 <StoneToad> oh gads, importing that split the channel
07:57:01 <LinearInterpol> o_O
07:57:35 <monochrom> <insert joke on monad and side effect>
08:04:11 <b80905> c_wraith: sorted xs = and $ zipWith (<=) xs $ tail xs
08:09:43 <b80905> ap f g = \x -> f x (g x) ?
08:11:26 <b80905> c_wraith: ap f g = \x -> f x (g x) ?
08:11:28 <Cale> b80905: For functions, yeah
08:11:32 <dario|> @pl \x -> f x (g x)
08:11:32 <lambdabot> ap f g
08:12:40 <b80905> Cale: why is its name `ap'?
08:12:51 <merijn> APplication
08:13:06 <Cale> :t ap
08:13:07 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:13:53 <Cale> ap x y will form the action which first runs x to get some function (say f), and then runs y to get some value (say v), and return the result of applying f to v
08:15:59 <jrmithdobbs> the first part's important so you can you do ap (something :: (..) -> (a -> b)) y, or another reason?
08:16:07 <jrmithdobbs> s/^/is/
08:17:27 <Cale> i.e.  ap x y = do { f <- x; v <- y; return (f v) }
08:17:28 <Cale> In the specific case of the function monad, "running" a function means applying it to the parameter that the overall function has been applied to
08:17:29 <jrmithdobbs> why is that phrasing re: "runs x" important vs saying ap f g = f x (g x); ?
08:17:47 <jrmithdobbs> oh i think that makes more sense
08:17:58 <Cale> Well, consider that you can use ap to combine some IO actions
08:18:25 <`Jake`> > map (\x -> map (+(3*(x-1))) $ [1..3]) [1..3]
08:18:26 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
08:18:36 <c_wraith> > Just (+5) `ap` Just 17
08:18:37 <lambdabot>  Just 22
08:18:50 <`Jake`> It seems like there should be an easier way to get a list like that
08:18:56 <`Jake`> maybe not though
08:19:05 <jrmithdobbs> oh, so by run you mean bind
08:20:08 <mjga> does anybody know if I can find GHC nightly builds for ARM anywhere?
08:20:23 <mjga> or just any kind of beta to test on RasPi?
08:22:32 <Cale> jrmithdobbs: Well, I'm explaining what the combined action does when "run" whatever that means in context :)
08:22:33 <Cale> For example, we could explain bind that way too:
08:22:35 <Cale> x >>= f is the action which when run, will first run x to obtain some result (say v) and then run the action (f v), producing the result of that action as its own
08:22:36 * hackagebot scrypt 0.5.0 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.5.0 (FalkoPeters)
08:28:01 <jrmithdobbs> Cale: I think I was confused because the original context was a function specifically not a generic monad and so I read run as call/invoke, but thinking about it for a moment i think i see why it shouldn't have now
08:30:26 <jrmithdobbs> s/it shouldn't/i shouldn't/
08:32:37 <jrmithdobbs> :t ((\x -> x) >>=)
08:32:40 <lambdabot> (a -> a -> b) -> a -> b
08:32:52 <frohe> hi, I'm reading LYAH and I don't see why the following implementation of withFile uses lambdas. can anyone help me? http://lpaste.net/98733
08:32:54 <jrmithdobbs> that being the "thinking about it for a moment" ;p
08:34:55 <ion> frohe: For pedagogic purposes.
08:35:24 <jrmithdobbs> :t (>>= (\x -> x))
08:35:27 <lambdabot> Monad m => m (m b) -> m b
08:35:27 <Philonous> Is there a cut function in attoparsec?
08:37:20 <jrmithdobbs> Philonous: as in cut(1) ?
08:37:38 <jophish_> Yo yo yo
08:37:55 <Philonous> jrmithdobbs, The inverse to try. "Don't backtrack before this point"
08:38:01 <frohe> ion: "withFile name mode f = bracket (openFile name mode) hClose f" is all okay, right?
08:38:04 <jophish_> I'm writing a compiler for a language with Haskell's syntax, It will have strict evaluation, no recursion and no recursive data types
08:38:12 <ion> frohe: yes
08:38:29 <jophish_> Would GHC make a suitable front end for this language, compile to Core with ghc and codegen myself from there?
08:38:32 <ion> frohe: Even that can be eta-reduced once.
08:39:41 <jophish_> The problem I've found is that it seems tricky to filter out these features using ghc
08:39:52 <jrmithdobbs> Philonous: that's default behavior? the point to which you wont backtrack before is the last successful parse
08:40:14 <jrmithdobbs> Philonous: maybe you need to break up your parser a bit more?
08:40:15 <Philonous> jrmithdobbs, That's true in parsec, but not in attoparsec
08:40:54 <frohe> ion: eta-reduced? you mean this? http://www.haskell.org/haskellwiki/Eta_conversion
08:41:32 <ion> frohe: Exactly what you did for the “\handle -> f handle”s.
08:41:36 <jrmithdobbs> Philonous: huh? you sure you don't have that backwards? a parse fail in attoparsec always fully backtracks
08:42:07 <Philonous> jrmithdobbs, Yes, exactly. And I want to cut after a successful parse
08:43:50 <jrmithdobbs> Philonous: um, you want to set the backtrack point after setting the backtrack point?
08:45:20 <catsup> is there a haskell library for transforming haskell source code?
08:45:40 <rtpg> catsup, what sort of transformation?
08:45:41 <Philonous> jrmithdobbs, attoparsec always backtracks and tries all branches. I want to prevent it from backtracking once a certain point is reached.
08:45:43 <rtpg> like, metaprogramming?
08:45:47 <catsup> no
08:45:53 <catsup> changing names
08:45:59 <jrmithdobbs> Philonous: so succeed
08:45:59 <frohe> ion: thanks. with "openFile" i say explicitly what the handle is (e.g. "handle <- openFile "foo.txt" ReadMode).
08:46:31 <frohe> ion: how the "withFile" function knows what the handle is?
08:46:45 <stephenmac7> If I have a list like this: data TestData = Test1 | Test2 String; [Test2 "SomeString]
08:46:48 <ion> frohe: I mean, \f -> bracket (openFile name mode) hClose f = bracket (openFile name mode) hClose
08:46:53 <stephenmac7> *["SomeString"]
08:47:04 <ion> @src bracket
08:47:04 <lambdabot> bracket before after thing = block $ do
08:47:04 <lambdabot>     a <- before
08:47:04 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
08:47:04 <lambdabot>     after a
08:47:04 <lambdabot>     return r
08:47:06 <jrmithdobbs> Philonous: myparser = parser1 >>= {- parser1 is a SUCCESS!! -} parser2 <|> parser3 <|> parser4
08:47:07 <stephenmac7> How would I check if Test2 is in the list and, if it is, get the value?
08:47:16 <rtpg> catsup, there's haskell-src
08:47:16 <ion> frohe: “a <- before”
08:47:35 <rtpg> http://hackage.haskell.org/package/haskell-src-1.0.1.3
08:47:37 <catsup> oh sweet
08:47:42 <jrmithdobbs> Philonous: make sense?
08:47:47 <catsup> that didn't come up in my searches
08:48:16 <Philonous> jrmithdobbs, If parser2, parser3 and parser4 all fail it will backtrack beyond parser1. That's what I want to avoid.
08:49:11 <rtpg> that's a slightly older version I linked though, newest is 1.0.1.5. Not sure if it parses everything well though (maybe just Haskell98?), though I can't think of anything apart from proc notation that wouldn't be included
08:49:13 <jrmithdobbs> Philonous: what will? there's nothing left to backtrack
08:49:38 <jrmithdobbs> Philonous: that's a parse failure / partial
08:50:39 <rtpg> catsup, out of curiousity, what are you trying to accomplish?
08:50:45 <Philonous> jrmithdobbs, You don't know that. I could have (and indeed have) myparser <|> someOtherParser and when parser1 succeeds but parser2 to 4 all fail someOtherParser will be tried. I want to prevent that.
08:51:01 <frohe> ion: thanks :))) i see now
08:51:17 <Philonous> jrmithdobbs, Well, I can just make myParser succeed with Nothing (and fmap Just over the rest) in that case/
08:51:22 <Philonous> I guess that solves it.
08:51:46 <stephenmac7> Seems a comprehension works
08:56:26 <PTBD> hello. I need some experts opinion. would you consider this definition of subbtrees to a tree as correct? http://pastie.org/private/7ujenkvvwq9a3u7oczxaw
08:56:30 <jrmithdobbs> Philonous: i do know that because it was my statement and other than the undefined variables i didn't use myparser anywhere else
08:56:38 <stephenmac7> Is it okay to use ++ with paths?
08:56:49 <stephenmac7> Assuming we want things to work with windows and linux?
08:56:56 <stephenmac7> (or mac)
09:00:49 <jrmithdobbs> Philonous: the point I was making is you can only fail/return, if you need to prevent backtracking past the top-level of the defined parser you have to reframe what the top-level is through some form of indirection (changing your parser into a Maybe x instead of x is one way to perform it, though it seems unclean to me)
09:01:02 <geekosaur> you could, but there is a portability API http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/filepath-1.3.0.1/System-FilePath.html
09:01:25 * hackagebot hub 1.3.0 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.3.0 (ChrisDornan)
09:01:30 <jmcarthur> PTBD: looks okay to me
09:02:30 <PTBD> jmcarthur, thank you. I'm supposed to write a function depthTree which shuld give me the depth of the tree using subtrees. I have no idea how and though subtrees is wrong
09:03:22 <jmcarthur> PTBD: hmm, i don't know how that is supposed to be done, either
09:03:23 <jrmithdobbs> Philonous: that solution will make it annoying/impossible to use incrementally (and if your overall parser can't be used this way why are you using attoparsec vs parsec?)
09:03:55 <jmcarthur> PTBD: can you paste the exact phrasing of the problem?
09:04:26 <PTBD> jmcarthur, it's not englisch
09:04:29 <jmcarthur> ah
09:04:51 <jmcarthur> unfortunately i pretty much only speak english :\
09:04:56 <PTBD>  but maybe I'm wrong. maybe I am not supposed to use subtrees. I just do it my way. but thank you jmcarthur
09:05:17 <Philonous> jrmithdobbs, It's locally contained. And I'm using attoparsec because my project already has it as a dependency.
09:06:58 <jrmithdobbs> Philonous: ah, well ya, basically a get doesn't really make sense in attoparsec because of the overall design is the answer to your original question
09:07:56 <Philonous> "No" is an acceptable answer.
09:09:28 <monoidal> troydm: I don't know what could be the reason looking at the cabal log. Anyway, both installing from source and apt-get should work
09:15:31 <lingxiao> hey all I have a question about how to express something using GADTs
09:15:44 <lingxiao> https://gist.github.com/anonymous/004f17295a568a45e120
09:16:08 <zett_zelett> How can I create a simple stackoverflow error in ghci?
09:16:30 <lingxiao> so I've got a STLC universe defined as above, and I'd like to write some function `pfst` that takes the first projection of the pair
09:17:03 <lingxiao> but I don't want to write someting like: `pfst :: Term -> Maybe Term` since the signature suggest the function maybe take something that's not a pair
09:17:24 <lingxiao> is it possible to write something like: `pfst :: Pair -> Term` even though Pair is a value constructor
09:17:31 <lingxiao> not a type constructor
09:17:45 <rtpg> no, not directly at least
09:18:48 <danharaj> Cale: Is the univalence axiom "If you have an isomorphism of types, then you can say they are equal and the content of the isomorphism is actually part of the higher groupoid structure of that type, so nothing is lost."
09:18:48 <rtpg> what you could do is transform your Term type to Term a, and then use that extra parameter to put in the symbol type
09:18:51 <zett_zelett> Nevermind, found that: http://www.haskell.org/haskellwiki/Stack_overflow
09:21:02 <rtpg> linhttps://gist.github.com/rtpg/a80517c750a6c0983b09 lingxiao , I think something like this can work
09:21:11 <rtpg> https://gist.github.com/rtpg/a80517c750a6c0983b09
09:23:27 <lingxiao> rtpg: that's acutally a rather clever way to pump information about the value constructor into the type constructor
09:23:51 <lingxiao> is this a common pattern? I have yet to see this anywhere (not sarcastic, since internet tone is sometimes ambigous)
09:23:53 <rtpg> I spent a while doing type-level programming, it's a good way to fake dependent types
09:24:39 <rtpg> haskell doesn't have dependent types, but people have been able to write some clever code by putting a lot of info into the data parameters
09:24:39 <lingxiao> ha! ok as long as people don't look at this and go: http://www.globalnerdy.com/wordpress/wp-content/uploads/2010/01/codinghorrorlogo.jpg
09:24:46 <lingxiao> I'm all in for abusing this pattern
09:25:23 <lingxiao> yeah.. I guess it just requires enumeration of some value constructors.. as types..
09:25:46 <lingxiao> def some secret arts of the craft thingy
09:25:51 <jrmithdobbs> lingxiao: you may also wish to look into -XDataKinds?
09:26:10 <lingxiao> hmm.. may I ask how that would help?
09:26:31 <lingxiao> by quantifiying the "arity" of the value constructor? or even more info than that?
09:26:42 <hpc> data kinds will automatically lift data declarations up a level
09:26:47 <jrmithdobbs> lingxiao: A data constructor of that name is in scope; did you mean -XDataKinds?
09:26:57 <hpc> data Bool : Set where True : Bool, False : Bool
09:27:00 <hpc> gets lifted to
09:27:15 <hpc> data Bool' : Set 1 where True' : Bool', False' : Bool'
09:27:17 <jrmithdobbs> lingxiao: or, you can write things like DataCon -> DataCon -> TypeCon
09:27:23 <hpc> (roughly speaking)
09:27:40 <hpc> it's a way of pretending you can lift values to the type level
09:27:53 <hpc> but you don't get all the interaction between type and value levels that you usually do
09:28:23 <lingxiao> jrmithdobbs: could you expand on what you mean by: DataCon -> DataCon -> TypeCon
09:28:29 <hpc> some of it is made up with type class/family tricks
09:29:17 <jrmithdobbs> lingxiao: that's the general affect of -XDataKinds ignoring the semantics... data CondVal (a :: KeyState) where
09:29:51 <lingxiao> hmm.. tbh Im not too familiar with Kind polymorphism and promotion
09:30:02 <lingxiao> I'm reading this to familiarzize myself: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
09:30:12 <lingxiao> are there other resources I could read?
09:30:18 <rtpg> lingxiao, honestly, though, in your case, I would suggesting breaking your datatypes up a bit
09:30:28 <rtpg> I doubt there's a situation where you want to regroup a bunch of terms
09:30:59 <rtpg> in reality, you have things such as a Pair holding two expressions (and not a Let, for example)
09:31:29 <lingxiao> rtpg: ohh design suggestions, this gold :)
09:31:52 <lingxiao> so you mean have a univ of pure terms: https://gist.github.com/anonymous/6a15bd5e5413df350b55
09:32:09 <lingxiao> and then another data type built from it?
09:32:26 <lingxiao> or something else entirely ..
09:34:18 <lingxiao> also are you saying I should distinguish between pairs hold expressions vs let bindings? or pairs should not hold let bingings?
09:34:20 <lingxiao> bindings*
09:35:12 <jrmithdobbs> lingxiao: there's what i was trying to paste already in lpaste ;p http://lpaste.net/633657965655621632
09:35:34 <jrmithdobbs> slightly different problem
09:36:51 <rtpg> lingxiao, does it make sense for pairs to hold let bindings?
09:37:15 <rtpg> as in, just a binding,  one could argue that (let ... in expr) is different from (let ....) by itself
09:38:15 <lingxiao> wait in my formulation let is "Let  :: Id -> Term -> Term", so it has to be bound ... unless you create some partial data .. where the second Term is not present
09:38:25 <rtpg> now that I look at your code again though, there doesn't seem to be a "more" correct way
09:38:30 <rtpg> I misread your initial structure
09:38:53 <lingxiao> word I had to do a double take on the Let I wrote to make sure it was right haha
09:39:20 <lingxiao> jrmithdobbs: still trying to decipher what's going on :)
09:40:15 <rtpg> I think writing a projection function for your pair might not be necessary.... if you have a function taking terms, you can deconstruct your Pair in the pattern match
09:40:31 <rtpg> and you can always write the function prfst (Pair a b) = a ... it will just be a partial function ;)
09:41:31 <rtpg> in Haskell there are a decent amount of partial functions, like the (!!) operator for getting the nth element . It's in bad style when it can be avoided but I think here we're in a slightly unavoidable case
09:41:55 <rtpg> either rise all of your language grammar to the syntax level (ugly) or just deal with partial functions (kinda scary)
09:42:27 <jrmithdobbs> lingxiao: believe it or not that (with some glue code) is used, basically, to define an Iso for a stupid string transform for a shitty api
09:43:15 <jrmithdobbs> lingxiao: that decided they were too lazy to write a parser and so randomly puts the operators as transforms in the key name in it's search api
09:43:39 <jrmithdobbs> (not randomly ;p)
09:44:39 <jrmithdobbs> lingxiao: so you do things like define a date regex search by adding ~ something after the keyname in random (undefined) application order
09:45:21 <bob1> hi why the standard library define foldr to be like this
09:45:22 <bob1> foldr k z = go
09:45:23 <bob1>           where
09:45:23 <bob1>             go []     = z
09:45:23 <bob1>             go (y:ys) = y `k` go ys
09:45:32 <bob1> is that because for tail recursion?
09:45:55 <lingxiao> man that is one, not-responsible, api
09:46:18 <jrmithdobbs> ya it's bad, so to cope i made the code interacting with it more fun
09:46:19 <jrmithdobbs> ha
09:46:22 <lingxiao> but your solution have no functions! aside from "condPlain = FinalKey . FieldName"
09:46:58 <jrmithdobbs> not in that paste because i'd pasted it trying to find a way to do it with Fix
09:46:58 <jrmithdobbs> ha
09:47:07 <lingxiao> you should show your soln to the api designers ...
09:47:43 <skuggi> bob1: i think it's so it can be inlined.
09:47:46 <eacameron> I'm writing tests for a list-like type of mine and any tests on "empty-list" give issues because Haskell cannot deduce the type of the list, even though it doesn't matter. how do others normally deal with this? I just created emptyIntList = emptyMyList :: MyList Int
09:48:03 <bob1> skuggi: when a function can be inlined?
09:48:09 <lingxiao> rtpg: hey one more question about your gist
09:48:28 <skuggi> bob1: well, recursive functions aren't inlined.
09:48:38 <lingxiao> if I want to define a product type of arb size ... https://gist.github.com/anonymous/91ad2f69798d94f6ba55
09:48:54 <skuggi> so if it was defined with recursion directly it wouldn't be inlined.
09:49:18 <lingxiao> in this line: "Tup  :: [Term a] -> Term Tu ", the signature looks very restricting... any suggestions on how to improve that?
09:49:44 <bob1> skuggi: but it is implemented using go so how can that be inlined?
09:50:10 <darthdeus> any thoughts why am i getting parse error here, while it works in the tutorial? :X http://i.imgur.com/idlJRlm.png
09:50:41 <AncientPC> What does `~(_:t)` do in this expression: let (h, ~(_:t)) = span (<4) [1..10]
09:50:54 <AncientPC> I understand that it's dropping the head of the 2nd list
09:51:02 <AncientPC> but I don't understand what the tilde is for
09:51:30 <geekosaur> ~ makes it lazy; it's only checked if evaluated, instead of the usual behavior of strict evaluation of patterns
09:51:45 <AncientPC> geekosaur: thx!
09:52:06 <jmcarthur> lingxiao: i think i still don't understand your Let constructor. there's an Id, which makes sense, but there's only one other Term. is that the one you are binding or the one in which the binding is used? either way, where is the other?
09:52:22 <rtpg> lingxiao, you're right in that it would be restricting.... I don't really think there's a way around it apart from using something like HLists
09:52:40 <skuggi> bobry: i'm not exactly sure how it works in detail.
09:52:45 <lingxiao> so let x = v1 in t2 would be Let (Var "x") v1 t2
09:52:52 <rtpg> there are some very strong reasons for not allowing it (replace Term with List and you can see that it wouldn't be very safe)
09:52:57 <lingxiao> ohhh shooot ...
09:53:02 <lingxiao> "Let  :: Id -> Term a -> Term b -> Term Le"
09:53:06 <lingxiao> is what it should be ...
09:53:13 <lingxiao> never learned my 'rithmatic
09:53:40 <rtpg> It would be Let "x" v1 t2 I'd imagine
09:53:40 <jmcarthur> lingxiao: okay
09:53:48 <lingxiao> thanks for checking my work :)
09:54:10 <jmcarthur> lingxiao: so another question... what if you do   pfst (Var v)  ? that would be type correct, after all
09:54:21 <jmcarthur> lingxiao: same for App, too
09:54:34 <lingxiao> yeah it wouldn't, so right now I have "pfst :: Term -> Maybe Term"
09:54:34 <petantik> I have the choice to use haskell (ghc) on mac or debian. what has better support?
09:54:41 <supki> darthdeus: do you have LANGUAGE Arrows pragma at the top of the file?
09:54:57 <lingxiao> and rtpg is helping me to find a better solution by revealing the value constructor in the type constructor for Term
09:55:15 <jmcarthur> lingxiao: well, i was trying to add some type information to your GADT, but those two constructors would still be allowed if that's all i do
09:55:16 <darthdeus> no :X i just played the rest of the video and found that it didn't compile for him as well :D thanks though :) i would've never figured it out otherwise
09:55:27 <lingxiao> he's got this: https://gist.github.com/rtpg/a80517c750a6c0983b09
09:55:33 <jmcarthur> lingxiao: ah, i guess you could put the syntax in the types that way, but it's not very pretty
09:55:46 <rtpg> it's not pretty at all, it's a way of doing it
09:56:31 <lingxiao> yeah people were also suggesting Kind polymorphism and promotion
09:56:38 <rtpg> I have a sneaking suspicion you won't actually need pfst that much though
09:56:51 <lingxiao> hmm how so ?
09:56:57 <rtpg> if you write an eval/apply loop, you'll be pattern matching on all terms anyways, so you'll destruct your pair
09:57:04 <lingxiao> like I could just be pattern mathcing
09:57:19 <rtpg> right
09:57:40 <lingxiao> oh right yeah... I guess I'm just trying to muse over how I would do it ... if I was to build a lang from the ground up
09:57:42 <lingxiao> "ground"
09:57:52 <rtpg> in these sorts of situation (99% pattern matching) having a convenience function that is only partial is fine I think
09:58:17 <rtpg> :t fromJust
09:58:18 <lambdabot> Maybe a -> a
09:58:19 <lingxiao> ha I get a sense that you and jmcarthur have different values :)
09:58:48 <rtpg> fromJust is a very similar function to what you want: it's partial (fails on a Nothing), but kinda accepted when you know more than the type system does
09:59:01 <jmcarthur> lingxiao: https://gist.github.com/jmcarthur/102631e47210f2e0159f
09:59:09 <jmcarthur> lingxiao: but mine is incomplete
09:59:22 <jmcarthur> lingxiao: to be honest, i think i just wouldn't define such a function because it doesn't make much sense to me anyway
09:59:44 <Cale> danharaj: Yeah, it asserts that the paths in a universe are the equivalences of its types.
09:59:57 <rtpg> oh
10:00:02 <rtpg> jmcarthur has a good point
10:00:03 <jmcarthur> lingxiao: or perhaps i would make that function another constructor in my syntax
10:00:07 <rtpg> pfst would work on values, but here we're on terms
10:00:27 <rtpg> so if you do x = (1,2) , pfst x =1 but how do you figure that one out?
10:01:23 <danharaj> Cale: How do isomorphisms act on introduction/elimination rules?
10:01:34 <danharaj> (say I present a type in two ways and construct an iso)
10:02:04 <rtpg> lingxiao, I'd suggest just continuing working on your program and seeing if you end up actually needing it :)
10:02:35 <Cale> danharaj: Well, the more precise form of it is that it says that the canonical map (A = B) -> (A iso B) is itself an equivalence, and that lets you go the other way from (A iso B) -> (A = B)
10:02:52 <danharaj> Is that definitional equality?
10:02:56 <Cale> no
10:02:58 <lingxiao> yeah, the truth is I don't see myself using this STLC even after I make it, the most interesting issue arising here is how to make types more descriptive
10:03:03 <danharaj> oh ok.
10:03:06 <Cale> Definitional equality can't appear in types.
10:03:16 <danharaj> ah.
10:03:36 <jmcarthur> lingxiao: also, my proposed GADT doesn't capture any sort of environment in its types, so i wouldn't use it verbatim anyway. you might stuck when trying to match variables with their bindings
10:03:38 <Cale> (It's a judgment, at the same level as saying "p : A"
10:03:41 <Cale> )
10:03:41 <rtpg> a general rule is to avoid abusing things though: sometimes we want to make very general things but it ends up not being necessary (see overuse of typeclasses)
10:04:17 <Cale> danharaj: btw, do you know about ##hott ?
10:04:36 <danharaj> vaguely
10:04:53 <lingxiao> jmcarthur: how were you able to write "Tru :: Term id Boolean" if Boolean is a value constrcutor?
10:05:24 <lingxiao> ditto with (a:->b) in "App :: Term id (a :-> b) -> Term id a -> Term id b"
10:05:35 <lingxiao> but that is very awesomly descriptive
10:05:57 <jmcarthur> lingxiao: the DataKinds extension
10:06:24 <lingxiao> rtpg: yes, I remember tekmo cautioning me about typeclasses, glad to hear another experienced person echoing this sentiment! :)
10:06:35 <jmcarthur> lingxiao: h/o. i'll go ahead and add some kind of environment, then it should actually be a usable type
10:06:35 <lingxiao> ahhh...
10:06:47 <lingxiao> yes please! thank you !
10:07:41 <lingxiao> do datakinds allow you to embed values in your type, so it's like of like dependant types? how is it different?
10:08:33 <catsup> rtpg: i'm probably not actually going to do it.  but i had the idea of modifying an editor to permit the use of subscripts in names, using a text convention to represent them like name__subscript
10:09:22 <catsup> rtpg: then i also had the idea that you could strip the subscripts and put a let name = name__subscript in ... if you had a block where the subscript was being used a lot
10:10:07 <jmcarthur> lingxiao: no, DataKinds only allows you to use value constructors at the type level statically. you can't lift values to the type level dynamically or anything.
10:10:24 <jmcarthur> lingxiao: that said, you can make data types like my TypeWit that associate values with types one-to-one
10:11:36 <lingxiao> ping
10:12:11 <jmcarthur> lingxiao: https://gist.github.com/jmcarthur/102631e47210f2e0159f   <-- with the environment like that it is no longer necessary to assign identifiers for lambdas and lets for the bindings, so i dropped them. the variables can pick out what they refer to from the environment anyway
10:12:19 <lingxiao> yeah that was my next question, about type wit
10:12:40 <jmcarthur> lingxiao: technically the type witness in lambda bindings isn't really necessary either, but it can be easier to think about that was anyway, so i left it
10:13:16 <jmcarthur> lingxiao: disclaimer: that gadt could still be wrong. i didn't think hard about it and i definitely didn't try to use it
10:15:01 <jmcarthur> lingxiao: the kind of Term is   ([Type] -> Type -> *) -> [Type] -> Type -> *   in case it isn't clear
10:15:28 <jmcarthur> lingxiao: the idea is that whatever you use for id should be some sort of index into the environment
10:15:57 <jmcarthur> lingxiao: e.g. de bruijn indices
10:16:03 <lingxiao> ohhh... I was wondering what id was, so it's an index
10:16:38 <lingxiao> haha ok awsom, yeah i was going to send the whole Term to some TermIn, where everytjing was relabedl with indices
10:17:02 <jmcarthur> ah, well then this could maybe be the target type after type checking and relabeling your original term then
10:17:27 <jmcarthur> it's kind of tricky to inject untyped ADTs into much more type safe GADTs like this though
10:17:32 <jmcarthur> it can be done
10:18:33 <jmcarthur> lingxiao: https://github.com/shayan-najd/MiniFeldspar/tree/master/Philip
10:19:01 <lingxiao> what is an untyped ADT?
10:19:30 <jmcarthur> lingxiao: one which admits programs that don't type check
10:19:32 <lingxiao> woa did you make the proj above? it's very similar to what I'm trying to accomplish ...
10:19:38 <jmcarthur> lingxiao: no, that's not mine
10:20:09 <jmcarthur> i've done similar things, but never publicly
10:20:46 <hpc> jmcarthur: can you give an example? "untyped ADT" => "untyped algebraic data type" => "untyped type" => "bamboozled hpc"
10:21:32 <lingxiao> yes, it's a good way to learn, at least I'm learning tons
10:21:51 <lingxiao> so I've given the concept of type witness a cursory read before, but never understood it really
10:22:12 <lingxiao> may I ask you what its advantages are, in the case where th env is not stored in the AST
10:22:21 <jmcarthur> hpc: the project i just linked to does such a conversion from untyped ADT to typed GADT of the lambda calculus
10:22:27 <jmcarthur> hpc: via type checking and such
10:22:40 <jmcarthur> lingxiao: in your original type?
10:22:54 <lingxiao> hmm in this gist: https://gist.github.com/jmcarthur/102631e47210f2e0159f
10:22:59 <lingxiao> so yes ..
10:23:14 <jmcarthur> lingxiao: you mean before that gist, right?
10:23:15 <lingxiao> more or less w/o the id.. but that's a detail I guess
10:23:29 <lingxiao> oh shoot.. https://gist.github.com/jmcarthur/102631e47210f2e0159f
10:23:32 <lingxiao> yeah I sent the wrong link
10:23:41 <lingxiao> ahh sent it again, but yes the one before that
10:23:46 <jmcarthur> lingxiao: the TypeWit is a direct translation from how you were previously using Type
10:24:10 <jmcarthur> lingxiao: you had some way to express what the type of the binding was at the value level. this does the same thing.
10:24:37 <lingxiao> but the type witness is much more descriptive?
10:24:43 <jmcarthur> lingxiao: it's just written in such a way that it has to match the actual type that has been lifted into the GADT
10:24:50 <jmcarthur> lingxiao: i wouldn't say it's more descriptive
10:24:52 <jmcarthur> it's optional
10:25:42 <jmcarthur> lingxiao: my version with environments was probably not useful at all
10:26:00 <jmcarthur> lingxiao: and for your original version, the presence of that Type field is very help when you get to implementing type checking
10:26:02 <lingxiao> I guess I just didn't know you could store the env right in the AST
10:26:06 <jmcarthur> *helpful
10:26:09 <lingxiao> not that you couldn't
10:27:00 <lingxiao> by Type field, you mean TypeWit in "lam :: id a -> TypeWit a -> Term id b -> Term id (a :-> b)"
10:27:13 <jmcarthur> lingxiao: your original ADT had one
10:27:33 <lingxiao> oh yes, "Lam :: Id -> Type -> Term a -> Term L"
10:27:42 <jmcarthur> lingxiao: i only included it because yours had it
10:27:51 <jmcarthur> lingxiao: mine is just type checked by the compiler
10:28:07 <lingxiao> yeah ... I'll stick with it as you suggested
10:28:14 <jmcarthur> lingxiao: or at least once environments are added
10:28:29 <jmcarthur> lingxiao: you original one is probably much easier for you right now
10:28:31 <lingxiao> just to be clear, the env maps id to type right?
10:29:10 <lingxiao> yeah ... I think in a few days I'll come back to your design w/ the env in the AST, and give it a good look over
10:29:27 <jmcarthur> the env doesn't actually "exist" there, although when you do things like implement an interpreter the env type param in the GADT will match some type parameter of your heap
10:29:45 <jmcarthur> and the ids will be the references into your heap
10:29:54 <jmcarthur> err
10:29:56 <jmcarthur> s/heap/stack/
10:30:56 <jmcarthur> note that the env is basically a stack of types, so you can imagine how that might map to a stack of values
10:31:29 <jmcarthur> the ids are basically offsets from the top of the stack
10:31:58 <lingxiao> hmm..make sense
10:32:38 <lingxiao> my prev type checker looks like this: https://gist.github.com/anonymous/00e233c78b6ac7d31835
10:32:39 <rtpg> I'm not sure storing the environment in the AST is useful...
10:33:00 <rtpg> if your objective is just to make a simple interpreter you're probably making your life a lot more difficult than it needs to be
10:33:23 <lingxiao> so the computation is descending the ast and spawning a new env for each lambda abstraction
10:34:17 <lingxiao> here `->>` is the arrow in Type -> Type
10:34:32 <lingxiao> anyways, just my 2 cents
10:36:52 <jmcarthur> rtpg: it's useful when your AST includes bound variables, since it allows you to check that they are in scope and such
10:37:00 <jmcarthur> rtpg: all this assuming you want a typed AST at all
10:37:24 <jmcarthur> rtpg: i agree that untyped ASTs are more convenient to work with (although you are less likely to write correct code)
10:37:45 <rtpg> Yeah, I guess I wouldn't consider a typed AST to be worth the pain, it's a lot easier to write a scope-checker on the value level
10:38:08 <rtpg> if Haskell's type-level prog wasn't a major pain for non-trivial programs I wouldn't mind, but I'm not a good prolog programmer
10:39:42 <jmcarthur> the code generally ends up looking almost exactly the same. it's only the types that usually look significantly different
10:41:09 <stephenmac7> Why are my executables gigantic?
10:41:33 <stephenmac7> A 300 line piece of software ends up being 22 MB
10:41:38 <ReinH> rtpg: "type-level prog"?
10:41:46 <jmcarthur> stephenmac7: because ghc statically links
10:42:03 <stephenmac7> jmcarthur: Can I turn off static linking?
10:42:06 <rtpg> programming
10:42:08 <ReinH> stephenmac7: 300 lines, how many imports?
10:42:35 <ReinH> rtpg: Haskell's type system is what allows me to write non-trivial programs without them imploding under the weight of their own unmanaged complexity
10:42:43 <stephenmac7> ReinH: aeson, async, http-conduit, optparse-applicative
10:43:05 <ReinH> stephenmac7: just saying that loc isn't as much of a determinant as imports
10:43:21 <stephenmac7> jmcarthur: Any way to turn on dynamic linking?
10:44:46 <jmcarthur> stephenmac7: yes, but i forget how
10:44:58 <jmcarthur> stephenmac7: i see little reason to be concerned about executable size anyway
10:45:07 <jmcarthur> stephenmac7: hard drive space is cheap these days
10:45:20 <stephenmac7> jmcarthur: But bandwidth?
10:45:44 <jmcarthur> stephenmac7: if you are transferring exes to others they will need the libraries anyway. might as well statically link
10:46:07 <jmcarthur> stephenmac7: also, ghc requires that the library versions match *exactly*, due to very aggressive cross-module inlining
10:46:09 <stephenmac7> jmcarthur: Guess so, unless you're distributing using a linux package manager
10:46:38 <jmcarthur> stephenmac7: in that case you would still have to upgrade every executable that depends on a library as soon as you upgrade the library
10:46:51 <maxiepoo> stephe, : http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
10:47:03 <stephenmac7> jmcarthur: strip myexec seemed to make a differenc
10:47:09 <maxiepoo> woops I meant stephenmac7
10:47:12 <jmcarthur> yeah that tends to help some
10:47:26 <stephenmac7> It cut the size in half
10:52:03 * hackagebot hsqml 0.2.0.2 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.2.0.2 (RobinKay)
10:52:46 <arr0w> is there an extension that allows two records to use the same field name?
10:53:31 <BMeph> TH! ;þ
10:54:07 <Lethalman> arr0w, lens
10:54:15 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
10:54:21 <geekosaur> as long as they have the same type
10:56:31 <arr0w> geekosaur: they do. and I was just looking at that. but I wanted fieldName function to accept both types. I guess that is not possible?
10:56:48 <geekosaur> not possible, no (aside from lens)
10:57:41 <monoidal> planned for GHC 7.10 afaik
10:58:02 <Twey> arr0w: Modules :þ
10:58:26 <Twey> Ah, no, lens is the way in that case
10:58:37 <arr0w> I can name both fields _field, use makeLenses, and lens will magically figure it out?  or is that wishful thinking? :)
10:59:59 <Twey> Hm
11:00:18 <Twey> Lethalman: How does lens actually work here?  You'll still get a name clash from Haskell
11:00:36 <Lethalman> Twey, I've read somewhere it creates a class for that field
11:01:11 <enthropy> Lethalman: but then you can potentially have conflicts if _field and _field are defined separately?
11:02:00 <enthropy> at some point somebody had a preprocessor for type-level strings
11:02:07 <enthropy> but that's obsolete since -XDataKinds
11:02:23 <Lethalman> enthropy, http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html
11:03:21 <Twey> Lethalman: Doesn't seem to be the case with makeLenses, at least
11:03:29 <Lethalman> Twey, makeFields, in fact
11:03:29 <Twey> Ah, a link
11:04:47 <Twey> Oh, that's cool
11:05:14 <arr0w> Yeah neat
11:05:39 <Twey> Even if it does generate type variables like: class HasQuux c_a2Zp e_a2Zq | c_a2Zp -> e_a2Zq  :þ
11:05:46 <arr0w> what is difference between makeLenses and $(makeLenses ..) btw?
11:06:44 <Twey> arr0w: Nothing
11:06:47 <ChongLi> one is a bit more clear
11:06:50 <Twey> You can omit the $() at the top-level
11:07:02 <Twey> (since it's obvious that it's a splice by the lack of an =)
11:07:06 <ChongLi> normally naked expressions at the top level are an error
11:07:18 <dgpratt> in general, how does one check or scheck with lambdabot?
11:07:36 <enthropy> interesting, makeFields catches the situation where the HasX class is already defined (and imported)
11:08:01 <guesting> If I am profiling a compiled program with -xc, it tells me a (THUNK_STATIC) exception occurued and the stack trace pointed to a specific function, where is it occurring specifically? Is it within the main definition of that function, a function in the "where" clause, a function called by the problem, or all of the above?
11:08:02 <enthropy> but it fails if you have Vec2 and Vec3 in separate modules
11:08:12 <enthropy> and then try to import both into a third one
11:10:08 <ReinH> Twey: alpha equivalence is hard :)
11:14:26 <arr0w> that lens trick is nice, but unfortunately you still have to use field names when creating data
11:15:00 <Lethalman> that's ugly but flexible, you don't have many corner cases to handle with ghc disambiguation
11:15:13 <Lethalman> and at all you write it once
11:15:22 <EvanR2> http://lpaste.net/98737
11:15:28 <EvanR2> :(
11:16:49 <EvanR2> having trouble using polymorphic functional arguments
11:17:10 <Lethalman> EvanR2, f can't be Int and Double at the same time
11:17:27 <EvanR2> f is supposed to be Num a => a -> a -> a
11:17:33 <EvanR2> so its not
11:17:55 <pavonia> No, it's fixed to one specific type when the function is called
11:18:31 <EvanR2> that explains that
11:18:37 <pavonia> (forall a . Num a => a -> a -> a) would work, I think
11:19:07 <Lethalman> pavonia, you don't know whether "a" is Int or Float then, you can't construct a Value
11:19:21 <tertl3> ow do you screenshot in xmonad?
11:19:38 <geekosaur> you install something that can do screenshots. scrot is popular
11:20:05 <geekosaur> (make sure to delay it slightly if you use a keybinding, or the keyboard grab will probably not be released soon enough for it to do its server grab)
11:20:20 <pavonia> Lethalman: You know from the constructors
11:21:05 <Lethalman> pavonia, uhm
11:21:07 * hackagebot hoodle-builder 0.2.2.0 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.2.2.0 (IanWooKim)
11:22:21 <dmj`> is there a way to cabal install a specific version of a pkg or is installing from the tarball the only option?
11:23:47 <EvanR2> well i fixed my problem, and my fix is awesome
11:23:49 <EvanR2> http://lpaste.net/98737
11:23:52 <bergey> dmj`: cabal install <pkg>-<version>
11:24:11 <EvanR2> math "+" (+) (+) v1 v2 ;)
11:24:54 <EvanR2> the first and second plus are for Integer and Double respectively, determined at who-knows-what-time
11:25:19 <EvanR2> polymorphism ftw
11:28:53 <dmj`> bergey: thank you!
11:46:41 <joelteon> heh...
11:46:43 <joelteon> "Cannot decode byte '\x72': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
11:46:45 <joelteon> '\x72' is just 'r', isn't it?
11:46:47 <joelteon> yes it is
11:47:45 <copumpkin> it might be part of another utf8 sequence and be invalid in that context
11:47:51 <Twey> joelteon: But UTF-8 is a multi-byte encoding; it may not be valid everywhere
11:47:54 <copumpkin> doesn't seem like an ideal error message
11:49:14 <ParahSailin> it might be one of those things that is invalid because its not canonical encoding of a char
11:49:53 <ParahSailin> for example a 2 byte encoding of a regular ascii code point
11:50:17 <joelteon> oh, it turns out that the substring was "k\230rli"
11:50:29 <joelteon> what I'm actually receiving is latin-1
11:50:32 <joelteon> makes sense
11:50:52 <matheus23> Huh... I'm asking a lot of questions recently :/ anyways... "$ cabal install gpipe" doesn't work for me, because it fails to install "GLUT-2.3.0.0" :/ What can I do?
11:52:15 <Twey> matheus23: Why does it fail to install it?
11:52:32 <matheus23> To be more precise: It fails to build/compile GLUT, you can see the error here: http://pastebin.com/qHkWYhSW
11:52:36 <mauke> The paste qHkWYhSW has been copied to http://lpaste.net/98739
11:54:24 <matheus23> Twey: What are my options? Can I somehow force it to install GPipe, even though _that_ GLUT version is not available? I think I have a GLUT hanging around on my PC
11:55:00 <Twey> matheus23: That looks like a bug in GLUT-2.3.0.0.  Try GPipe 1.4 instead: it depends on an earlier version of GLUT.
11:55:09 <matheus23> or to be more precise again: I have GLUT-2.5.0.1 installed
11:55:11 <matheus23> okay...
11:56:08 <matheus23> Twey: That, unfortunately, doesn't work, too: http://pastebin.com/KdJabzvS
11:56:13 <mauke> The paste KdJabzvS has been copied to http://lpaste.net/98740
11:56:43 <matheus23> but intrestingly, it installed GLUT-2.5.0.2, which is a newer version :O
11:56:52 <matheus23> (if not the newest)
11:56:55 <Twey> Ugh
11:57:35 <Twey> matheus23: GPipe 1.4.1 depends specifically on GLUT 2.3.0.0, but GPipe 1.4 only depends on >=2.1.2.1
11:58:02 <matheus23> ah okay, that seems... odd somehow
11:58:05 <Twey> (which is a bad idea on GPipe's 1.4's part and theoretically fixed in GPipe 1.4.1)
11:58:29 <Twey> But that should mean you can install GLUT 2.1.2.1 and GPipe 1.4
11:58:35 <Twey> Which is a combination that presumably works
11:58:41 <monoidal> matheus23: The error seems to be caused by a change in GHC; Num is no longer a superclass of Bits; newer version of the package should fix it.
11:59:01 <Twey> monoidal: When did that happen?
11:59:07 <matheus23> Can I fix that myself?
11:59:53 <matheus23> or: Can I force GPipe 1.4.1 to work with GLUT 2.5.*
11:59:56 <matheus23> ?
12:00:06 <Twey> matheus23: It might work already; you can try just changing the dependency in the .cabal file
12:00:18 <Twey> If not, there will be errors, and you can fix them
12:00:23 <matheus23> And: GLUT 2.1.2.1 doesn't compile for me, too :(
12:00:32 <Twey> Yeah, that won't help if it's a GHC change
12:00:48 <Twey> You'll have to patch GPipe to work with newer GLUT
12:01:01 <matheus23> how do I change the dependency in the .cabal file? I mean, I haven't even got the .cabal file yet, do I?
12:01:02 <Twey> (or downgrade your GHC, but don't do that)
12:01:13 <bergey> If you use a new version of GLUT, you'll need a new version of OpenGL, and that will require a bunch of patching to GPipe.  But that's probably the best answer.
12:01:28 <matheus23> I think I'll be able to do that :)
12:01:40 <Twey> matheus23: You can clone it from the repo specified in Hackage
12:01:42 <matheus23> I'm just wondering where I can find GPipe's .cabal
12:01:48 <Twey> Or download the tarball
12:01:48 <matheus23> okay, thanks
12:03:58 <Twey> bergey: Is that necessarily true?  GLUT just seems to depend on OpenGL >= 2.2
12:04:19 <Twey> I don't think OpenGL and GLUT have that much interaction
12:05:07 <Twey> And GPipe already depends on >= 2.5.0.0
12:05:16 <Twey> s/>/=/
12:14:22 <erisco> Twey, I think everything panned out very well for the tree module. I was even able to adapt my ListTree to work with it
12:14:32 <arcke> i want pairs to return a list of all possible valuepairs from the input list of Integers and tried "pairs l = [(x,y) | (x:xt) <- l, y <- xt]", why does this not work?
12:15:06 <arcke> list is ascending and contains unique elements
12:16:05 <kristof> Zippers are so cool
12:16:21 <erisco> Twey, I re-implemented everythig in Data.Tree except for the breadth-first unfold
12:17:38 <erisco> and nothing changed for rose trees, so it seems purely an upgrade
12:20:53 <arcke> how can i write pairs l s.t. pairs [0, 1, 2, 3] == [(0,1), (0,2), (0,3), (1,1), (1,2),...,(2,2),(2,3),(3,3)]?
12:21:27 <bergey> Twey: Where do you see that?  I see GLUT-2.5.* requiring OpenGL>=2.8
12:22:01 <stelleg> so I've realized I have my own strategy with regards to cabal hell: nuke my entire cabal periodically (when I have a dependency issue), and then reinstall as needed. Anyone else do this?
12:22:12 <Clint> i do that
12:22:26 <Clint> but largely i don't install things through cabal so it's not a big deal
12:22:42 <stelleg> oh?
12:22:50 <stelleg> make installs?
12:22:55 <Clint> .debs
12:22:59 <stelleg> ah
12:23:14 <stelleg> is there a good debian repo for hackage?
12:23:30 <stelleg> i tried one on arch for a while
12:23:42 <stelleg> but had a few issues and went back to nuke mode
12:24:09 <Clint> as long as you're not using debian stable, it's fine
12:24:19 <erisco> > let l = [1,2,3] in [(x,y) | x < l, y <- l]
12:24:20 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:24:20 <lambdabot>              with actual type `[t0]'
12:24:23 <buck11> does anyone know of a 'haskell for pythonistas" guide?
12:24:37 <erisco> > let l = [1,2,3] in [(x,y) | x <- l, y <- l]
12:24:38 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:25:09 <erisco> arcke ^
12:26:01 <rtpg> buck11, there's a haskell for c programmers
12:26:01 <rtpg> http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
12:26:24 <arcke> erisco: ok, clean, thnx
12:26:42 <buck11> thanks ^_^
12:26:46 <rtpg> It's not python, but I think python is similar and dissimilar to haskell in a similar way
12:26:59 <buck11> i could agree
12:27:09 <buck11> i leanred python with the free 'dive into python'
12:27:30 <rtpg> > The entire language of Haskell has this short-circuit behavior, including the functions that you write yourself.
12:27:31 <lambdabot>  <hint>:1:21: parse error on input `of'
12:27:37 <rtpg> whoops ^^
12:27:49 <rtpg> that's a nice way of putting lazy evaluation
12:28:16 <rtpg> buck11, you might be better off with going with learn yourself a haskell  though
12:28:24 <kristof> *Learn You a Haskell
12:28:31 <buck11> got that one for christmas :)
12:28:35 <kristof> buck11: And after that fantastic introduction, read Real World Haskell
12:28:49 <Twey> bergey: I'm not sure.  >.<
12:28:56 <Twey> erisco: Neat!
12:29:03 <kristof> buck11: And after you read Real World Haskell, write MORE MORE MORE Haskell and learn how to use black magic like Lenses and Monad Transformers
12:29:05 <buck11> i tried it before and got turned off by the many @#$!^& operators
12:29:28 <rtpg> Real World Haskell has some great parts but also some pretty iffy parts ( I am not able to grok the monad transformer chapter no matter how many times I read it)
12:29:32 <buck11> white magic plz
12:29:35 <Rembane> It's old
12:29:36 <kristof> buck11: I don't like the operators too (prefix syntax Lisp spoiled me) but that's just an aesthetic concern and you'll get 'em eventually
12:29:40 <Twey> stelleg: I do that too, except I do it through Portage so I have a script that does it for me
12:29:47 <kristof> buck11: For every operator there's almost always a prefix version anyway
12:30:03 <buck11> kristof: a way to ask haskell to tell me the mapping?
12:30:20 <kristof> buck11: hoogle
12:30:29 <rtpg> http://www.haskell.org/hoogle/
12:30:29 <erisco> Twey, do you know the typical review process and submission to Hackage? it undoubtedly needs refining
12:30:37 <rtpg> you can search for a function by its type
12:30:50 <rtpg> the amazing thing about Haskell and its libs is that searching by type usually works
12:30:53 <stelleg> Twey: cool, sounds nice
12:30:54 <pdxleif> Is there a way to get a repl in the project scope, like this does? https://github.com/atnnn/cabal-ghci
12:31:06 <buck11> in clojure i can pass magical syntax through the reader and it de-magics it
12:31:10 <Twey> rtpg: I never found a satisfactory explanation of monad transformers, so I don't think the problem is LYAH's fault :þ
12:31:25 <epta> pdxleif: cabal sandbox repl?
12:31:31 <rtpg> pdxleif, I think ghci has an api you can use...
12:31:34 <Twey> I just went away and programmed Haskell for a bit, and at some point I realized I understood monad transformers
12:31:46 <rtpg> Twey, LYAH doesn't talk about monad transformers I think, I was talking about real world haskell
12:31:53 <kristof> Monad Transformers are just monads that have monads. No biggie
12:31:55 <buck11> monads in disguise?
12:31:56 <Twey> Ah, right; same applies, though
12:31:57 <rtpg> I get the idea, I just don't get the implementations
12:32:01 <kristof> Yo dawg, I heard you like ______
12:32:08 <pdxleif> epta: Not necessarily sandbox, just hiding stuff that's not in the .cabal file
12:32:23 <pdxleif> mtl and monads-tf are fighting, again. :(
12:32:24 <kristof> rtpg: The Real World Haskell chapter on monad transformers is a lot better than you're letting on, you know.
12:33:11 <rtpg> yeah, it's probably more me than the book
12:33:22 <Twey> erisco: You sign up for a Hackage account, then send an email to admin@hackage.haskell.org asking for upload privileges, then you upload stuff — there's no review process
12:33:24 <rtpg> my apologies to the authors
12:40:49 <ReinH> Well, I thought I'd write a text-adventure game in Haskell. Now I'm writing a Z-Machine interpreter.
12:42:15 <rtpg> somehow all Haskell projects turn into language projects at one pooint
12:42:40 <kristof> rtpg: Where you'd have a lot of effectful statements separated by semicolons, and then call a bunch of procedures that launch missiles into various Eastern Bloc puppet governments, "stacking" monads allows you to have all that neat pipeline/chaining pattern while letting the "stacks"... touch each other.
12:43:10 <pdxleif> Hmm, guess I can just use "ghci -hide-package monads-tf"
12:43:15 <kristof> rtpg: But even though you're launching missles, you still got all the arbitrary order and control flow that monads provide; reverse the order of computation, map it over a functor, who knows!
12:44:41 <erisco> Twey, I see, okay. I imagine there is a mailing list I could post to though
12:45:53 <Twey> erisco: To do what, exactly?
12:46:11 <rtpg> I get the idea behnind monad transformers (having multiple monads in the same "context" so that you can drag along IO and some seperate writer), I just had a pretty hard time getting mtl . I just looked at it again now and am having less trouble...
12:47:14 <erisco> Twey, marketing. and to improve the module. if someone quietly uploads their work and does not share it around, what good is it?
12:47:45 <skypers> hi
12:47:52 <skypers> I have a weird issue with parsec
12:48:05 <Twey> erisco: Oh, well, you can announce on haskell-cafe, and lambdabot will also announce when you upload a package
12:48:10 <skypers> string "a", in ghci, yields a correct type
12:48:28 <skypers> if I try to compile it importing Text.Parsec
12:48:35 <skypers> I get an instance error
12:48:36 <skypers> any idea?
12:48:42 <skypers>     No instance for (Stream s0 m0 Char)
12:48:49 <triliyn> :t string
12:48:51 <lambdabot>     Not in scope: `string'
12:48:51 <lambdabot>     Perhaps you meant one of these:
12:48:51 <lambdabot>       `storing' (imported from Control.Lens),
12:49:09 <skypers> string :: Stream s m Char => String -> ParsecT s u m String
12:49:18 <Twey> skypers: You've forgotten to specify the relevant constraints in your context
12:49:22 <triliyn> skypers: oh, it's a defaulting issue then
12:49:35 <Twey> So GHC is trying to do it for *every* s and m
12:49:39 <triliyn> GHCi will pick types for s, u, and m (I think) arbitrarily
12:49:48 <skypers> oh yes
12:49:53 <triliyn> In a compiled program you need to provide them
12:49:55 <skypers> m = Identity
12:49:59 <skypers> ok
12:50:02 <skypers> thank you
12:50:05 <dhrosa> hello, in Verilog, you can do this kind of matching on binary values: http://lpaste.net/98742
12:50:08 <skypers> but what is u?
12:50:11 <dhrosa> how would I emulate this in haskell?
12:50:50 <Twey> dhrosa: View patterns seem applicable
12:51:19 <ChongLi> and if you want to manipulate bits, Data.Bits.Lens is pretty nice'
12:51:27 <triliyn> skypers: I'm not sure about this, but you could try leaving it polymorphic in u? It's not constrained by an instance so that might work...
12:51:58 <skypers> hm
12:51:59 <roboguy_> triliyn: I think ghci has some specific rules for picking those types
12:52:07 <skypers> gonna try
12:52:09 <triliyn> u is the type for your user state apparently
12:52:48 <roboguy_> dhrosa: what are you trying to do?
12:52:53 <ChongLi> extended defaults?
12:54:01 <monoidal> Twey: since 7.6 Bits no longer has a Num superclass
12:55:17 <dhrosa> takinga look at data.bit.lens
12:55:42 <dhrosa> roboguy_: I'm making a simulator for the AVR microcontroller for fun, and I need to convert machine code into my own data types
12:56:07 <roboguy_> dhrosa: ah. yeah, lens would probably be a good choice for this
12:56:58 <erisco> *every* s and m -- Twey
12:57:43 <erisco> dhrosa, I do not know Verilog. Are those binary numbers?
12:57:43 <erisco> or are they lists of bits?
12:57:59 <li[bl]> I know verilog.
12:58:10 <erisco> dhrosa, what would the type of 'val' be in Haskell? an Int? [Bool]?
12:59:38 <li[bl]> 4'b11?? says "a 4-bit value of base 2 with two unknown values at the two lower positions of the nibble."
12:59:45 <li[bl]> ? is wildcard.
12:59:46 <Twey> let toBits s n = map (testBit n) [s - 1, s - 2 .. 0] in case 12 of (toBits 4 → [True, True, _, _]) → "foo"; (toBits 4 → [True, _, False, _]) → "bar"
13:00:00 <roboguy_> erisco: probably something with a Bits instance
13:00:07 <Twey> It's a little more notationally clumsy, but the same idea
13:00:44 <Twey> dhrosa: ↑
13:01:03 <Twey> monoidal: Thanks
13:01:48 <matheus23> Will anybody kill me, when I say "GPipe's code is quite ugly?"? :S
13:02:13 <erisco> or you can use a 4-tuple
13:02:35 <Twey> I presume the ‘4’ in the original is variable
13:03:01 <Twey> And while a Vec would be nicer, it adds some notation and a dependency
13:03:53 <dhrosa> erisco: those are 4-bit binary numbers yes
13:03:53 <erisco> I know, but if you are dealing with 4-bit values then a 4-tuple would work well too
13:04:00 <matheus23> (If you don't know what I'm speaking about, take a look at https://github.com/tobbebex/GPipe/blob/master/src/Resources.hs)
13:04:07 <erisco> and then you can potentially use the shorter (-> (True, True, x, y))
13:04:14 <dhrosa> my actual numbers will be 16 bits
13:04:16 <Twey> erisco: That's not shorter :þ
13:04:47 <dhrosa> 4'b in verilog means this is a 4 bit literal in binary (b)
13:04:52 <erisco> Twey, yes it is, you can omit the view name... presuming that got implemented
13:04:52 <erisco> I have not played with view patterns much
13:05:51 <Twey> Ooh, via a typeclass?
13:06:30 <enthropy> erisco: no it didn't
13:06:50 <skypers> is `many` really fast?
13:06:51 <enthropy> but a similar thing is coming with -XPatternSynonyms (or whatever it's called)
13:06:53 <Twey> Hm, doesn't seem to exist
13:06:55 <dhrosa> hmm,i'm not sure  I get what's going on in data.bit.lens
13:06:58 <skypers> I mean it outputs [a]
13:07:09 <skypers> and I wonder if lists are really that fast
13:07:10 <erisco> enthropy, oh :(
13:07:20 <Twey> skypers: Parsec isn't very fast
13:07:21 <enthropy> considering that -> is as much noise as an actual constructor
13:07:41 <skypers> Twey: I thought it was
13:07:54 <jmcarthur> no, parsec is actually not very fast at all
13:07:55 <skypers> what’s about atoparsec?
13:08:02 <jmcarthur> attoparsec is fast when used correctly
13:08:10 <Twey> Attoparsec can be quite fast.
13:08:19 <skypers> ok so if I want to parse hughe files
13:08:23 <skypers> parsec will just fail?
13:08:33 <erisco> enthropy, yes, but how is this new module avoiding that?
13:08:35 <jmcarthur> btw, lists are sometimes fast and sometimes not. it depends on how much fusion ghc can do
13:08:49 <jmcarthur> skypers: that's not related to speed...
13:08:49 <skypers> what’s the point about parsec if it’s slow then?
13:08:58 <skypers> jmcarthur: it might be
13:09:03 <jmcarthur> skypers: the point is it's easy to write a parser
13:09:07 <Twey> I doubt it will *fail*; it might just be slow.  But Parsec isn't built with speed in mind, so if you're worried about potential performance hits from lists, you're using the wrong library.
13:09:11 <erisco> dhrosa, in any case, you cannot pattern match on digits in a number, so if you want to pattern match you'll have to expand to some other structure
13:09:48 <dhrosa> I was considering making a  function like val `matches` "11??", to make the notation compact
13:09:55 <skypers> well, I’m gonna try to parse my 20MB .obj mesh file with parsec
13:10:00 <skypers> and see how it behaves
13:10:19 <erisco> dhrosa, but alternatively you can use the Bits class as roboguy_ suggests and write branching functions that way
13:10:40 <skypers> why is parsec slow btw?
13:10:44 <dhrosa> what was roboguy suggesting again?
13:10:45 <skypers> what makes it slow
13:10:55 <erisco> skypers, if you really want speed for complex grammars then you really want a parser generator, but those are more complicated to use
13:11:09 <skypers> a parser generator?
13:11:10 <Twey> dhrosa: The problem with that is that you don't get matches out of it; but maybe you don't care about that
13:11:21 <erisco> skypers, that is why parser combinators are useful. slower, but more convenient. also, for simple cases, the difference can be negligible
13:11:26 <skypers> are lex/bison such parsers?
13:11:43 <skypers> I see
13:11:51 <dhrosa> Twey: the problem with what, my matches function?
13:11:56 <Twey> Yes
13:12:00 <roboguy_> dhrosa: well, I didn't really suggest anything yet, but you could write a function that is something like nibbles :: SomeNumberType -> [(Bool, Bool, Bool, Bool)]
13:12:06 <Twey> Well, I guess you could return a list from it
13:13:24 <dhrosa> I was thinking of emulating the verilog syntax using my helper function and a pattern guard, | val `matches` "11??" = expr; | val `matches` "0?1?" = expr2;
13:13:35 <skypers> btw, what’s the difference between parser combinators and parser generators?
13:17:51 <Twey> skypers: Rather, the difference is between parser libraries and parser generators.  The former is a library you can invoke from your program to parse some text, whereas the latter is a program run on a description of a language that generates code to parse that language in some programming language
13:18:10 <meretrix> What's the cleanest HTTP library that can repeatedly download a small text file on a poll using a single keep-alive connection?
13:18:21 <skypers> Twey: ok, then bison
13:18:24 <skypers> or flex
13:18:26 <Twey> Like that, yes
13:18:27 <skypers> are parsers generators
13:18:29 <skypers> ok
13:18:33 <skypers> I see
13:18:54 <Twey> Our Haskell equivalent is Alex/Happy, I believe
13:18:56 <skypers> do such parsers exist in Haskell?
13:19:02 <erisco> skypers, yes they are
13:19:03 <skypers> oh
13:19:03 <skypers> ok
13:19:06 <erisco> skypers, for maximum efficiency analysis of the grammar needs to be done. this is not practical with parser combinators (although possible, it would require a potentially expensive compilation step during runtime)
13:19:16 <erisco> skypers, also knowing the entire grammar ahead of time is necessary for many of the parser models. parser combinators are flexible in that they can be combined at runtime
13:19:31 <skypers> erisco: yeah I see
13:19:39 <skypers> I learned at school about derivation
13:19:40 <skypers> and so on
13:19:52 <skypers> parsing is not that simple
13:20:21 <erisco> depends on what you need to parse. it can be trivial :)
13:22:21 <erisco> Twey, I am not sure I would equate "parser combinator" with "parser library" because there is no reason a parser generator cannot be a library
13:23:50 <Twey> erisco: True; I was just thinking about such a thing myself, actually
13:23:50 <skypers> ok so in parser generator grammars are more explicit and restricted than combinators
13:24:04 <erisco> skypers, parser combinators take the approximate form of combine :: Parser -> Parser -> Parser
13:24:05 <erisco> skypers, that is, they take two parsers and join them together into one new parser
13:24:26 <Twey> It might be nice to have a DSL for grammars that can be compiled to a parsing function ahead of time
13:24:34 <skypers> erisco: yes
13:24:46 <skypers> but i don’t undearstand why it’d be slow
13:24:47 <roboguy_> dhrosa: you could do something like this http://lpaste.net/98743
13:26:40 <jmcarthur> skypers: try implementing parsec then
13:26:44 <erisco> lambdabot is gone too!
13:26:49 <erisco> skypers, ah hello again I split out
13:26:50 <zq> erf
13:26:55 <jmcarthur> @botsnack
13:26:55 <erisco> skypers, there are two fundamental combinators, and they get different names, but I will call them "then" and "else"
13:26:55 <lambdabot> :)
13:27:31 <erisco> skypers, let 'parse x' create a parser to recognize the string x, then  parse "x" `then` parse "y" == parse "xy"
13:27:36 <Lethalman> what very simple gui can I use that both works on linux and win from haskell platform?
13:27:38 <zq> the python equivalent would be lambda n: int(bin(n)[2:])
13:27:43 <erisco> skypers, parse "x" `else` parse "y"  parses the string "x" or the string "y"
13:27:43 <dhrosa> is there really a need to use lens for that? that function would look practically the same without
13:27:46 <Lethalman> simple as in: a file chooser, a button and a label
13:28:07 <Lethalman> the easiest to deploy
13:28:17 <erisco> skypers, with these two combinators alone you can construct any context free grammar (though the definitions are more complex)
13:28:46 <enthropy> gtk2hs is not that bad
13:28:50 <maxiepoo> Lethalman, https://hackage.haskell.org/package/threepenny-gui just uses the browser so it should work cross platform
13:28:51 <enthropy> or maybe try threepenny-gui?
13:28:59 <lingxiao> hey guys, I have a problem concerning MultiParamTypeClasses and DataKinds that's beyond me
13:29:12 <erisco> skypers, that is because they correspond directly to BNF notation.   A -> aA | a  =>   parseA = (parse "a" `then` parseA) `else` parse " a"
13:29:21 <erisco> skypers, so there is my short tour :)
13:29:22 <roboguy_> dhrosa: it's not necessary, but I can't think of another easy way to get a list of bits as bools
13:29:27 <Lethalman> maxiepoo, not in haskell platform
13:29:31 <dv00> currently my goal is to (assuming you have ghc installed etc) document a quick, easy, clean way to start a project with unit tests.. I'm going to demo HS to some people
13:29:41 <maxiepoo> ah I missed that constraint
13:29:42 <Lethalman> mh looks like there's only glut
13:29:45 <dhrosa> roboguy_: map (testBit x) [0..15]
13:29:51 <roboguy_> ah, right
13:29:59 <Lethalman> :(
13:30:00 <skypers> erisco: I still don’t understand
13:30:05 <lingxiao> https://gist.github.com/anonymous/79396a484630a450677a
13:30:21 <roboguy_> dhrosa: you're going to have 16-bit patterns?
13:30:26 <dhrosa> roboguy_: yes
13:30:29 <dv00> I keep getting confused about which tools I should be using such as cabal and/or virthualenv
13:30:34 <Twey> dv00: http://stackoverflow.com/questions/1044555/how-can-i-set-up-a-simple-test-with-cabal
13:30:41 <erisco> skypers, another name is "executable grammar" because the programs look close to the grammar definition, yet are an executable parser
13:30:45 <dhrosa> doesn't cabal provide its own virtualenv-like thing with sandboxes?
13:30:53 <erisco> skypers, which part did I not explain well?
13:30:59 <mada> I'm doing 20 intermediate exercises, and I can't do this one (mapM): moppy :: (Misty m) => [a] -> (a -> m b) -> m [b]
13:31:07 <lingxiao> https://gist.github.com/anonymous/93b8f62aaaf24a51871b
13:31:12 <skypers> erisco: I don’t understand why BNF grammars would be slow
13:31:12 <lingxiao> a better version ..
13:31:19 <dv00> Twey: reading now
13:31:39 <erisco> skypers, BNF grammars are not programs. they are just formal notation for grammars
13:31:42 <mada> I feel like I should map f to get [m b] but I don't know how to get the entire list of results instead of the list of computations
13:31:46 <lingxiao> basically I have some Typeclass relating two datatypes: `Class Two a b | a->b, b -> a where ...`
13:31:47 * hackagebot stm-conduit 2.2 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.2 (ClarkGaebel)
13:31:52 <Twey> mada: Hint: try a fold
13:32:07 <dv00> dhrosa: I think so, but which should I use?
13:32:19 <mada> Twey: ok, thank you
13:32:41 <erisco> skypers, I was pointing out that the 'then' and 'else' operators correspond to adjacency and '|' in BNF grammars, and given that BNF grammars are sufficient to describe and CFG, then our combinators also describe any CFG
13:32:44 <lingxiao> except now a is some type parameterized by the value constructor or another type
13:33:02 <lingxiao> thus my typeclass no longer work ..
13:34:42 <Twey> lingxiao: Why not?
13:35:19 <lingxiao> Couldn't match type `a' with `a0 :-> b0'
13:35:19 <lingxiao>       `a' is a rigid type variable bound by
13:35:19 <lingxiao>           the instance declaration at STLCplus.hs:76:29
13:35:20 <lingxiao>     Expected type: Term a
13:35:23 <lingxiao>       Actual type: Term (a0 :-> b0)
13:35:25 <lingxiao> so this is the error verbatum:
13:35:29 <lingxiao> oops..didnt mean to past in channel
13:35:41 <erisco> skypers, and we should be more careful about what we mean by "slow". In this context, "slow" means overhead. That is, the big-O complexities are not different
13:35:47 <lingxiao> but basically the instance declaration is "instance DeBrujinPair (Term a) TermIn where"
13:36:12 <lingxiao> but really it relates Term a to TermIn, and also Term (a:->b) to TermIn
13:36:18 <lingxiao> and Term (a:*:b) to TermIn
13:36:19 <erisco> skypers, so for a given CFG, the parser generators can do just as well as a generated grammar in terms of time complexity (I am not sure about space)
13:36:39 <skypers> yeah that was my question :)
13:37:29 <erisco> skypers, however, the parser generators can perform deep analysis on the grammar and use sophisticated and efficient execution models, such as tables, which cannot be written by hand
13:38:15 <Twey> lingxiao: Oh, I see: it's no longer bidirectional, because there are multiple a's for each b
13:38:28 <Twey> lingxiao: You can propagate the type info into your TermIn
13:38:37 <Twey> To maintain the bijection
13:38:48 <skypers> I like combinators
13:38:59 <skypers> I just wonder if the runtime performances will be ok…
13:39:40 <Twey> lingxiao: Then you relate (Term a) to (TermIn a) instead
13:39:41 <erisco> skypers, also my claim about same time complexity may be too bold. typically it will hold, but I cannot be certain about all cases (particularly middle recursion)
13:39:50 <lingxiao> but then i get this error:
13:39:57 <lingxiao> https://gist.github.com/anonymous/90c6561784dd8e8c21bd
13:40:27 <Twey> lingxiao: I can't see your code
13:40:32 <lingxiao> I don't even know how `a` could have kind 'Type', why is the kind type?
13:40:43 <Twey> But it sounds like you might benefit from KindSignatures
13:40:56 <lingxiao> https://gist.github.com/anonymous/9d8ce43cf9b711cb7be5
13:41:00 <roboguy_> lingxiao: are you using DataKinds?
13:41:16 <roboguy_> lingxiao: App :: Term (a :-> b) -> Term a -> Term b
13:41:17 <lingxiao> yeah
13:41:52 <Twey> lingxiao: That's what DataKinds does: it lifts every datatype declaration of the sort A :: B where A is a term and B is a type so that there's an equivalent declaration where A is a type and B is a kind
13:42:01 <dhrosa> does ghci get confused with all-caps module names?
13:42:10 <Twey> dhrosa: No
13:42:20 <dhrosa> I have  a file named AVR/ALU.hs, and I  cannot load it in ghci, because it cannot find the module
13:42:26 <dhrosa> I have this problem with none of my other files
13:42:42 <roboguy_> dhrosa: can you be more specific? what's the error?
13:42:51 <dhrosa> Could not find module `AVR.ALU' It is not a module in the current program, or in any known package.
13:43:01 <roboguy_> dhrosa: what directory are you in, relative to the file?
13:44:25 <dhrosa> actually it seems ghci just can't figure out where to import my project's files from
13:44:29 <roboguy_> dhrosa: also, what module name do you give it in the "module ... where" part?
13:44:37 <dhrosa> my top level dir has a folder called AVR, and in AVR is AVR/ALU.hs, AVR/StatusReg.hs, etc
13:44:43 <dhrosa> the module names are AVR.ALU, AVR.StatusReg, etc
13:44:54 <roboguy_> dhrosa: are you using cabal?
13:44:59 <lingxiao> roboguy_: ahh got it, now it works
13:45:04 <dhrosa> executing ghci -i AVR/ALU.hs says that it cannot find AVR.StatusReg
13:45:09 <lingxiao> Twey: ok I got it to work, thanks!
13:45:15 <dhrosa> roboguy_: my project uses cabal yes
13:45:37 <Twey> lingxiao: Works fine for me
13:45:37 <dhrosa> everything works when compiled with cabal, but I want to load things in ghci
13:45:46 <Twey> Oh, no problem
13:45:54 <lingxiao> yeah my def was incompleete, now it's completed and works fine
13:46:01 <Twey> Okay =)
13:46:41 <roboguy_> dhrosa: do you module declarations have the full module name (like module AVR.StatusReg (...) where ...)?
13:46:57 <dhrosa> I got it working by passing the -i. flag to ghci
13:47:21 <dhrosa> roboguy_: yes
13:48:05 <solarus> dhrosa: you could look at cabal repl also
13:49:04 <dhrosa> unrecognized command :(, I also don't have  cabal run, which I've seen referenced on the internet before
13:50:54 <roboguy_> dhrosa: really? what version of cabal?
13:51:12 <dhrosa> i'm using version 1.16 of cabal, which is what the newest ubuntu has in its repos
13:51:23 <dhrosa> should I install the newer cabal using cabal?
13:51:35 <dv00> could not find module HUnit
13:52:24 <roboguy_> dhrosa: probably, yeah. cabal update && cabal install cabal-install
13:52:41 <dv00> dammit i just want to run a test
13:52:58 <dv00> isn't the point of cabal, that I put something in build depends and it goes and gets it?
13:53:08 <dv00> if its like other build systems I've used.
13:53:17 <skypers> how would you do to parse a string that can have both leading and trailing spaces, but only one word within parsec?
13:53:28 <roboguy_> dv00: isn't the module Test.HUnit?
13:53:36 <skypers> spaces >> many noneOf " \n\r," >> spaces
13:53:45 <skypers> it doesn’t actually behave the way I’d like it to
13:53:53 <skypers> for instance, it parses "   i  * "
13:53:59 <skypers> it must not
13:54:22 <ReinH> Hmm, simplest way to turn a ByteString into [Word16] (i.e. take every 2 bytes)?
13:54:29 <dv00> roboguy_ ok, getting somewhere now =]
13:54:34 <ReinH> (dropping any extra byte)
13:55:31 <dv00> need to put a w/u online, even if its just for my own refrence
13:55:33 <roboguy_> dv00: it might be something else actually if you're using it with some kind of testing framework (like test-framework or Tasty)
13:56:02 <dv00> every couple weekends I go to do some hacking on Haskell, then I spend the whole day trying just to get a project to run
13:56:03 <Twey> skypers: I think you mean: spaces >> many (noneOf " ") >> spaces
13:56:39 <Twey> skypers: Which will parse the first "   i  "; it will still accept the string, though (with the rest left over) because you haven't told it to expect an end-of-input next
13:56:54 <skypers> Twey: yeah, my function is actually ok
13:56:58 <zq> @equiv flip fmap
13:56:58 <lambdabot> Not enough privileges
13:56:59 <skypers> as you said
13:57:08 <skypers> I have to write a bit more :)
13:57:45 <ReinH> anything better than `let (<<) = shiftL in zipWith (\a b -> (fromIntegral a) << 8 .|. (fromIntegral b)) bs (tail bs)'?
13:58:20 <dv00> roboguy_ would you start with virthualenv cabal sandbox or something else?
13:58:47 <dhrosa> is there a difference between the Cabal and cabal-install packages?
13:59:37 <dv00> i see the yesod readme sugesting cabal sandbox
14:00:16 <Twey> dhrosa: Cabal is a library that handles the build process; cabal-install is an executable that invokes Cabal and also fetches dependencies &c.
14:00:28 <dv00> i started by looking at my last toy project, and I saw virthualenv ... but now I remember having screwed with multiple systems and I see a cabal sandbox as well
14:00:35 <dhrosa> ahhh
14:00:43 <dhrosa> no wonder I couldn't find the cabal executable
14:01:38 <roboguy_> dv00: I've never used cabal sandboxes, but I know they're recommended
14:01:40 <skypers> ok so hm
14:01:49 * hackagebot courier 0.1.0.6 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.6 (PhilHargett)
14:02:06 <roboguy_> dhrosa: confusingly, the cabal-install executable is called "cabal"
14:02:07 <skypers> do { a <- aParser; chap sep; b <- aParser; return (a,b) }
14:02:12 <skypers> this will just parse a pair!
14:02:16 <skypers> that rocks!
14:02:24 <skypers> s/chap/char/
14:02:27 <roboguy_> dhrosa: I think they're planning on merging them and renaming cabal-install to just cabal
14:03:11 <skypers> I wonder how I can provide an error message if the char parser fails
14:03:12 <skypers> any idea?
14:03:13 <roboguy_> skypers: don't you need some kind of brackets?
14:03:24 <skypers> roboguy_: brackets? no
14:03:42 <roboguy_> skypers: so you pairs are just things like 1,2?
14:04:30 <roboguy_> dv00: I think virthualenv is deprecated in favor of hsenv
14:04:39 <skypers> yep
14:04:44 <skypers> my formats are really simple
14:04:46 <skypers> like .INI
14:04:51 <skypers> key = value
14:05:02 <ReinH> Hmm, pretty happy with BL.zipWith go <*> BL.tail where go a b = fromIntegral a << 8 .|. fromIntegral b
14:05:03 <skypers> my lexeme parser for that is just htat:
14:05:20 <skypers> between spaces spaces (many1 . noneOf $ sep : "\n\r ,")
14:06:03 <skypers> this is my first shot with parsec
14:06:15 <skypers> and I already like it :)
14:06:43 <roboguy_> ReinH: you could call it .<<.
14:06:50 * hackagebot courier 0.1.0.7 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.7 (PhilHargett)
14:06:56 <skypers> I’m off
14:06:58 <skypers> see you guys
14:07:00 <skypers> no more battery
14:07:41 <roboguy_> << makes me think flip (>>)
14:09:03 <aristid> :( apparently still not there https://ghc.haskell.org/trac/ghc/ticket/4092
14:09:59 <ReinH> roboguy_: hmm not bad
14:10:10 <Twey> ReinH: zipWith ((.|.) . (<< 8) `on` fromIntegral) `ap` tail
14:10:23 <ReinH> Twey: I always forget about `on` :)
14:10:27 <ReinH> and `ap` is <*> :)
14:10:41 <Twey> <*> sorry
14:10:44 <Twey> Old habits die hard
14:11:02 <dv00> roboguy_: thanks for the information
14:11:09 <ReinH> Twey: not sure if that's more readable though. Was hoping for something I missed in the ByteString library, not new pointfree versions of my function ;)
14:11:31 <Twey> Aww. :þ  But it's so much prettier.
14:11:52 <ReinH> Twey: heh, dunno about that
14:11:54 <ReinH> lots of parens
14:12:12 <ReinH> Anyway, what's a better idiom for `(k =<<) . f'?
14:12:18 <Twey> Fewer than yours (you never need brackets around function applications unless they're going in another function application, by the way)
14:12:25 <ReinH> Twey: yep, I removed my parens :)
14:12:30 * Twey nods.
14:12:37 <ReinH> I have: go a b = fromIntegral a .<<. 8 .|. fromIntegral b
14:12:46 <ReinH> roboguy_: good call :)
14:12:48 <Twey> Oh hey, I know how you could remove some
14:13:07 <Twey> ReinH: zipWith ((.|.) . flip shiftL 8 `on` fromIntegral) <*> tail
14:13:08 <Twey> :þ
14:13:16 <ReinH> Twey: heh :)
14:13:21 <ReinH> I think mine is ok ;)
14:13:39 <ReinH> now, (>>= k) . f, what do I really want for that?
14:14:27 <ReinH> This is the list monad, so I'm doing `concat . map k . f'
14:14:45 <copumpkin> why concat . map?
14:14:53 <ReinH> because that's what >>= is for []?
14:15:02 <copumpkin> k <=< f :P
14:15:11 <ReinH> :t (<=<)
14:15:12 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:15:16 <Twey> I think that's not quite the same
14:15:18 <ReinH> copumpkin: f isn't a monadic action
14:15:36 <copumpkin> it returns a list doesn't it?
14:15:49 <ReinH> oh wait, ofc it is
14:15:57 <ReinH> copumpkin: I'm mixing my levels up
14:16:01 <copumpkin> :)
14:16:50 <meretrix> Is there any way to tell what exceptions a function could possibly throw without just going through all the source code by hand?
14:17:14 <ReinH> copumpkin: <3
14:17:16 <Twey> By trying to avoid exceptions :þ
14:17:23 <meretrix> I'm missing Java's checked exceptions..
14:17:32 <Twey> There's an explicit-exceptions package
14:17:39 <meretrix> Can't avoid exceptions caused by IO..
14:17:54 <ReinH> the only "unchecked" exception your function can return is undefined
14:18:07 <Twey> But Haskell exceptions are a pain in general
14:18:21 <ReinH> So make sure you aren't writing/using partial functions
14:18:22 <Twey> Presumably meretrix means from IO or a similar monad
14:18:25 <aristid> meretrix: i have sometimes wished that IO didn't automatically include all of SomeException, but i don't know if there would be a feasible alternative
14:18:36 <ReinH> Twey: Ah, right.
14:20:03 <Cale> I disagree that exceptions are a pain. They're rather nice if used appropriately. If you want checked exceptions, that's what Either is for.
14:20:33 <aristid> Cale: or EitherT :)
14:20:48 <meretrix> I just don't like when they're forced on me by the authors of HTTP packages.
14:21:04 <Cale> Which package?
14:21:08 <aristid> meretrix: you can write a wrapper.
14:21:15 <Twey> Cale: I don't like the fact that there *are* unchecked exceptions.  And the Eithers tend to stack up if you want to handle exceptions far away from where they're caused.
14:21:17 <meretrix> http-conduit
14:21:55 <Cale> Twey: Well, you can use the Exception machinery in an explicit way
14:21:58 <Twey> Then there's the whole ‘exceptionally unsafe’ thing
14:22:03 <Cale> (Exception e) => Either e a
14:22:06 <meretrix> I first to need find all the exceptions that can be thrown before I write the wrapper. :)
14:22:34 <Cale> Or Either SomeException a, depending on what you mean :)
14:23:47 <Twey> Cale: And rely on the Typeable tag for handling?
14:24:04 <Cale> yeah
14:25:18 <Kaidelong> @check \a b c -> a && (b || c) == (a && b || a && c)
14:25:20 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
14:25:20 <lambdabot>  False False False
14:26:04 <Kaidelong> what
14:26:15 <Cale> Of course, it doesn't have to be SomeException, you can use some more specific type which captures all the exception types you want to have.
14:26:21 <Kaidelong> > False && (False || False)
14:26:22 <lambdabot>  False
14:26:34 <Kaidelong> > False && False || False && False
14:26:35 <lambdabot>  False
14:26:45 <Twey> But wait, you still don't have explicit exceptions
14:26:52 <Cale> That's the nice thing about the Exception class, is that you can define arbitrary refinements and unions
14:26:52 <Kaidelong> what is going on!
14:27:28 <maxiepoo>  > (\a b c -> a && (b || c) == (a && b || a && c)) False False False
14:27:33 <Twey> You can use SomeException and declare *every exception ever*, or you can make your own sum type that's just every exception you'll ever use, or you can have a different sum type for every possible combination of exceptions
14:27:47 <rtpg> > (\a b c -> a && (b || c) == (a && b || a && c)) False False False
14:27:48 <lambdabot>  False
14:28:02 <Cale> Twey: Right, you have to make the trade-off in one way or another.
14:28:12 <rtpg> ah it's probably order of operations
14:28:12 <Kaidelong> > False == False
14:28:13 <lambdabot>  True
14:28:25 <Kaidelong> oh of course
14:28:31 <Cale> The Exception class gives you arbitrarily many ways to make it :)
14:28:32 <rtpg> a && ( (b || c) == (a && b  || a && c) ) = a && False
14:28:40 <Kaidelong> the precendent of == must be set for doing comparisons on things over than bool
14:28:43 <Kaidelong> precedence*
14:28:58 <maxiepoo> hah
14:29:15 <Twey> Which to my way of looking at it is clearly inferior to e.g. Java's checked exceptions, where you can just define a list of exceptions on a per-use basis… I guess you could make a generic sum type, nowadays, which would solve a lot of the pain, or do the whole algebraic effects thing
14:29:34 <Cale> Twey: Well, you know how to make a type representing a specific set of exceptions with Exception, right?
14:29:51 <Cale> You can define fromException yourself for a new datatype
14:30:13 <Cale> in such a way that catching one of those is equivalent to catching exactly the exceptions you're interested in
14:30:17 <Kaidelong> I'm wwondering if instead of All or Any and Product or Sum, Sum and Any like monoids should be the default, and a Ring class should be provided
14:30:32 <Twey> Cale: Sure, but you have to have one for each new combination of exceptions
14:30:47 <Cale> Yes, well, one for each combination of exceptions you actually care about
14:31:04 <Cale> It would also be easy to define type-level operations for that
14:31:43 <Cale> e.g. just using Either perhaps
14:31:54 <Kaidelong> (and then Product could be made general for more than one types by having some constructor in the form (Ring a, Monoid (c a)) => a -> c a)
14:32:50 <Cale> actually, I've done that before, it's super cute
14:33:03 <Cale> Let me write it again :)
14:34:12 <Cale> http://lpaste.net/98747
14:34:22 <Cale> er
14:34:52 <Cale> there, edited, that was clearly wrong before :)
14:36:21 <Cale> Defining an infix operator at the type level for Either would make that syntactically perhaps a bit more pleasant
14:36:34 <Cale> Then you get arbitrary lists of exceptions
14:37:39 <Cale> I have no idea why this code is not in Control.Exception as it is
14:38:04 <Cale> edwardk: Do you suppose you could do something about that? :)
14:38:20 <Cale> edwardk: i.e. put http://lpaste.net/98747 into Control.Exception
14:38:47 <derekv> or cabal-dev... I'm seeing more recent blogs recommending cabal-dev over hsenv
14:39:00 <edwardk> the problem is it infers for crap
14:39:15 <Cale> edwardk: ?
14:39:29 <edwardk> when you go to match with it using Control.Exception
14:39:43 <edwardk> often one branch will be underdetermined
14:39:51 <shapr> edwardk: y0, how do I do log decay in arduino or C ?
14:39:58 <erisco> who maintains Data.Foldable?
14:40:08 <shapr> edwardk: or if you're busy, I'll ask you later :-)
14:40:23 <Cale> edwardk: Oh, I suppose *that's* true, you'll have to be explicit about which things your handler is meant to catch
14:40:30 <edwardk> erisco: that'd be in base so the libraries@ mailing list in general and the core libraries committee in particular
14:40:33 <shapr> whoops, thought this was #haskell-blah
14:40:37 * shapr disciplines himself
14:41:01 <edwardk> cale: you can lobby libraries@ to add it to the main control.exception module i suppose
14:41:35 <edwardk> i'd rather not make an orphan for it, but a standard version 'd be fine =)
14:41:55 <Cale> Right, that's why I asked :)
14:42:00 <erisco> how likely is it that I can get    length = getSum . foldMap (const $ Sum 1)    into Data.Foldable by mailing the list?
14:42:03 <derekv> there's a problem in general with the internet or maybe, a shortcoming of google... if three weeks ago, the best way to address a cold was to drink orangejuice, then a bunch of people make blog posts about orangejuice cures, then a week later the goverment puts mind control drugs in the OJ and everyone switches to ginger tea, up till a few day ago someone discovers whiskey and honey works much better... a guy does a google search for "c
14:42:26 <Cale> derekv: ???
14:42:26 <edwardk> of course Either ArithException ArithException will do annoying things like switch sides, throw (Right x) `catch` \(Left x) -> ...
14:42:49 <hexagoxel> whats the type signature of a function returning b, where b is some instance of a given type class T? it must be a known problem, but i do not know the right keywords
14:42:54 <derekv> Cale: like, replace with virthualenv vs hsenv vs cabal-sandbox
14:43:15 <nooodl> f :: T b => a -> b ?
14:43:15 <jmcarthur> hexagoxel: foo :: T b => ... -> b
14:43:19 <Cale> derekv: Your message was cut off at "a guy does a google search for"
14:43:30 <derekv>  guy does a google search for "colds" he's going to get a bunch of
14:43:40 <derekv> advice to drink orange juice
14:43:45 <derekv> irssi fail?
14:44:15 <Cale> derekv: All IRC clients implicitly have this problem because the IRC protocol just sucks
14:44:30 <derekv> irc fail.
14:44:57 <hexagoxel> jmcarthur: is that not a signature for "returning _any_ b, where b is an instance of type class T"?
14:45:04 <Cale> derekv: There's an arbitrary line limit, and that limit *includes* a bunch of text that your client can never see, because messages don't come back to you
14:46:05 <StoneToad> derekv: irc messages are limited to 512 bytes, including the CR/LF 2 byte ending, and your nick+hostmask prefix
14:46:06 <Cale> derekv: Some clients will just guess at it and break the line conservatively early though
14:46:21 <StoneToad> the server will silently truncate the message when it adds the prefix
14:47:21 <Cale> edwardk: The intention is that you probably have no interest in throwing an Either
14:47:41 <Cale> edwardk: since SomeException is already implicitly a union of all exception types
14:48:13 <Cale> and you also have no interest in catching an Either with two of the same type
14:48:55 <Cale> It would be possible to define a new datatype expressly for this purpose though
14:49:13 <jmcarthur> hexagoxel: that's what it sounded like you wanted to me
14:49:20 <Cale> Perhaps to make the intention that it's not really a disjoint union a bit clearer.
14:49:47 <jmcarthur> hexagoxel: are you looking for an existential type? there is *some* b with this constraint, but you aren't letting the user of the function know what that b is?
14:49:51 <ReinH> edwardk: you do a lot of bit twiddling... am I doing anything obviously dumb here? https://gist.github.com/reinh/8497833
14:50:06 <jmcarthur> hexagoxel: i know of a couple ways to do that
14:50:13 <Cale> edwardk: I suppose we could also define an instance for type-level lists...
14:50:23 <hexagoxel> jmcarthur: yeah, thats what i want
14:50:31 <jmcarthur> hexagoxel:    data SomeT = forall b. T b => SomeT b;   f :: ... -> SomeT    -- one way
14:50:35 <Twey> Expected type: Any (fromList ((':) * Int ((':) * Char ((':) * () ('[] *))))); Actual type: Any (fromList ((':) * Char ((':) * Int ((':) * () ('[] *))))) -- oh well, guess I didn't really expect that to work
14:50:41 <DigitalKiwi> derekv: there are irssi plugins to break long messages
14:50:56 <DigitalKiwi> onto multiple lines so that they go through
14:51:32 <jmcarthur> hexagoxel:  f :: ... -> (forall b. T b => b -> r) -> r    -- just another encoding for existential types, so long as r is allowed to be chosen by the caller
14:51:37 <Cale> Twey: Are you already trying what I just mentioned? :)
14:51:57 <jmcarthur> hexagoxel:  f :: ... -> (forall r. (forall b. T b => b -> r) -> r)   -- in other words
14:52:31 <Twey> Cale: I thought it would be nice to use type-level sets, which would sidestep a lot of unpleasantness
14:52:53 <Twey> But it looks like the type-checker won't evaluate something like (fromList [Int, Char]) before unifying
14:52:53 <jmcarthur> hexagoxel: the first version uses -XExistentialQuantification. the second uses -XRankNTypes
14:55:50 <hexagoxel> jmcarthur: thanks, that answers my question
14:55:55 <derekv> its OK, I suck at IRC.  I've made my peace with that fact.
14:56:12 <ozgura> I want to use CPP to do some simple code generation. If a #define the macro in the same file it works, but I cannot seem to be able to #define it in a separate module and use it from another. Ideas?
14:56:36 <Cale> Twey: Did you try making an instance of Exception for that?
14:56:42 <ozgura> I import the module, just double-checked. :)
14:56:52 <Cale> Twey: It should be possible to define one recursively :)
14:56:53 <merijn> ozgura: The only way to see define froms other files is to #include that file, but that will also include the non #define bits of the file
14:57:07 <merijn> ozgura: CPP is a really terrible solution for code generation, tbh
14:57:16 <merijn> ozgura: Have you considered using Template Haskell instead?
14:57:28 <Cale> Twey: also, you only really need lists, because you'll only specify the list when you're trying to catch
14:57:32 <jmcarthur> ozgura: i normally just write a .h file, like in C, and include it via CPP
14:57:37 <ozgura> merijn: too heavy-weight for this purpose, I thought.
14:57:59 <Cale> Twey: Errr... maybe that's a little ambitious for Haskell yet...
14:58:04 <ozgura> the purpose is, for completeness: I derive the same set of type-classes for a bunch of data types
14:58:28 <ozgura> and don't want to type them again and again, especially since when adding/removing I'll do it to all at the same time
14:58:36 <Cale> You need here/there sort of type indexed naturals.
14:58:40 <jmcarthur> ozgura: i use CPP when it's meant to be used in just my own project, but if i want to help anybody else generate instances of their own then i would use template haskell
14:59:02 <derekv> Is cabal-dev still awesome or is there a something better now (whiskey and honey)?  I ask so that later when I have some weird dependancy problem, i won't be in here and having someone telling me "WTF are you using that? Thats from 2013..."
14:59:04 <merijn> ozgura: You could implement the typeclass using Generics and then just "deriving (Generic)" the different datatypes?
14:59:09 <ozgura> sth like: data Blah = ... | ... | ... DERIVE_STANDARD
14:59:26 <merijn> derekv: cabal 1.18 has sandbox support built-in
14:59:30 <hargettp> ^^
14:59:37 <ozgura> I also want to derive type-classes such as Eq, Ord and Show
14:59:56 <jamiis> attempting to get all combinations of a list (with limits -- not just 0-9)... so, e.g., [2,2] would generate [ [1,1], [1,2], [2,1], [2,2] ] and [3,3,3] -> [ [1,1,1], [1,1,2], [1,1,3], [1,2,1] ... etc ]. Can anyone think of a solution? been boggling my mind for a little while now
15:00:22 <merijn> jamiis: Always starting from 0?
15:00:24 <ozgura> jmcarthur: I'll probably do the .h thing after all, thanks.
15:00:25 <merijn> jamiis: eh, 1?
15:00:38 <jamiis> merijn yes
15:00:57 <jmcarthur> hmm... it would be nice if you could derive constraints defined as a collection of derivable classes using ConstraintKinds
15:01:18 <jmcarthur> e.g.   type Standard a = (Eq a, Ord a, Read a, Show a);   data Foo = Foo deriving Standard
15:01:20 <derekv> merijn: iow, just use "cabal" where I might have used "cabal-dev"?
15:01:53 <derekv> cabal-install version 1.18.0.2
15:02:19 <ReinH> > sequence $ fmap (enumFromTo 1) [3,3,3] -- jamiis
15:02:20 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
15:02:26 <merijn> derekv: They use some extra commands, here is a simple intro: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
15:02:50 <ozgura> jmcarthur: that would indeed be very nice
15:02:55 <merijn> derekv: Includes a cabal-dev to cabal translation
15:03:03 <copumpkin> jamiis: are the three always the same?
15:03:06 <jamiis> ReinH holy jeebus. thanks.
15:03:25 <derekv> merijn: ok cool, I've seen this tutorial.  its the one I'll go with then
15:03:37 <ozgura> jmcarthur: especially when defining non-trivial AST-like things, you generally have to derive the same classes for many data types anyway
15:03:47 <jmcarthur> yup
15:03:49 <jamiis> copumpkin no. it looks like ReinH gave an correct answer that takes that into acct.
15:04:06 <copumpkin> was just wondering if it could be simplified further :)
15:04:15 <copumpkin> for example
15:04:26 <copumpkin> > mapM (enumFromTo 1) [3, 3, 3]
15:04:27 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
15:04:45 <ReinH> copumpkin: oh, sequence . fmap = mapM, I am dumb :)
15:05:07 <ReinH> @src mapM
15:05:07 <lambdabot> mapM f as = sequence (map f as)
15:05:10 <ReinH> yeppppp
15:05:34 <ReinH> er, not sequence . fmap, that
15:06:04 <copumpkin> :D
15:06:09 <ReinH> (sequence .) . map, if you must
15:06:57 * hackagebot haggis 0.1.1.2 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.1.2 (TychoAndersen)
15:07:26 <ReinH> Hmm, isn't there an easy way to turn an Int into a list of its bytes (big endian), i.e. Int -> [Word8]
15:07:55 <copumpkin> ReinH: you could use Data.Binary for easy stuff, or write a simple loop with Data.Bits :P
15:08:10 <ReinH> copumpkin: yeah I thought Data.Binary would export something :/
15:08:17 <copumpkin> well, not lists
15:08:18 <copumpkin> but bytestrings
15:08:35 <copumpkin> runPut . putInt32be . fromIntegral
15:08:36 <copumpkin> or something
15:11:45 <ozgura> jmcarthur: update. neither #include "file" nor {-# INCLUDE "file" #-} seem to work with ghc 7.6.3
15:12:12 <jmcarthur> umm... pretty sure it should work. you probably just need to set up some include path on command line
15:12:12 <ozgura>     -#include and INCLUDE pragmas are deprecated: They no longer have any effect
15:12:17 <jmcarthur> oh gross
15:12:41 <jmcarthur> umm... what are you supposed to do then? i know there are some packages that still do it
15:12:53 <ozgura> I have no idea.
15:14:22 <jmcarthur> :t \n -> map (fromIntegral . ord) $ showIntAtBase 256 chr n "" :: [Word8]  -- ReinH: a kind of odd implementation
15:14:24 <lambdabot> (Integral a, Show a) => a -> [Word8]
15:14:55 <jmcarthur> :t reverse . takeWhile (/=0) . unfoldr (Just . swap . (`divMod` 256))  -- ReinH: another
15:14:55 <lambdabot> Integral a => a -> [a]
15:15:07 <triliyn> Wouldn't that still work if you fed it through cpp first? Or does ghc apply some additional helpful processing to #includes?
15:16:37 <jmcarthur> ozgura: e.g. vector uses it
15:16:51 <ozgura> tiffany: I don't actually wanted to use a custom preprocessor
15:17:00 <ozgura> LANGUAGE CPP is hardcore enough :)
15:17:20 <ozgura> jmcarthur: I shall investigate
15:17:27 <tiffany> irc client nick autocomplete is pretty terrible
15:22:11 <ozgura> jmcarthur: aha! it works when listed in the cabal file (as per vector) and compiled via cabal
15:22:16 <ozgura> I was trying itin ghci
15:23:02 <eitanchatav> Hi. I have data in a Reader monad that I want to encode and decode with Data.Binary. What is the idiomatic way to do this? What should the type signatures be? Specifically, my data is of a form like "Reader Curve PrivateKey" and I need to read the curve parameters to decide how to encode/decode.
15:25:45 <Lethalman> eitanchatav, instance Binary Curve ?
15:25:59 <eitanchatav> Lethalman: no
15:26:08 <eitanchatav> Curve is a record of parameters
15:26:36 <eitanchatav> I need to read one of those parameters to decide how to encode/decode
15:26:48 <hexagoxel> ghci question: when using :r repeatedly, rather often i can not see where the previous output ends and the current one starts. suggestions for solutions?
15:26:52 <Lethalman> eitanchatav, instance Binary (Curve, TheData)
15:27:04 <Lethalman> :P
15:27:27 <eitanchatav> Lethalman: aha, simple and obvious ;-) thanks
15:27:36 <Lethalman> eitanchatav, I would create a data type with both parameters and the data to encode though
15:27:43 <Lethalman> with only the parameters needed for encoding
15:28:35 <eitanchatav> hmmm...i see why you say that and it kinda gets at a problem
15:28:54 <eitanchatav> i don't actually encode the parameter
15:29:00 <hexagoxel> to answer my own question: i can use !def to make :r insert some newlines into output
15:29:11 <eitanchatav> in another lang it would just be a global constant...hence reader
15:29:12 <hexagoxel> neat
15:29:21 <Lethalman> eitanchatav, if (Curve, TheData) is not a problem, neither is the new data type
15:29:36 <jmcarthur> ozgura: oh, i don't think i would expect it to work in ghci, so this makes sense
15:30:00 <eitanchatav> yeah, but it is kind of a problem
15:30:04 <awestroke> > 1
15:30:05 <lambdabot>  1
15:30:15 <eitanchatav> i'm using the parameters from Curve, but not encoding them...
15:30:20 <Lethalman> eh ok
15:30:26 <Lethalman> but you have some data to encode, no?
15:30:29 <eitanchatav> yes
15:30:31 <jmcarthur> i don't think i understand the problem
15:30:32 <eitanchatav> the PrivateKey
15:30:38 <eitanchatav> which is just an Integer
15:30:39 <Lethalman> so, you have a (Curve, PrivateKey)
15:30:52 <jmcarthur> you mean the Curve should inluence how you use Binary?
15:31:03 <eitanchatav> jmcarthur: yes
15:31:21 <eitanchatav> so i don't think i will have an instance of Binary
15:31:24 <eitanchatav> just functions
15:31:27 <eitanchatav> like
15:31:35 <Lethalman> eitanchatav, you can have (Curve, PrivateKey)
15:31:45 <eitanchatav> getPrivateKey :: Get (Reader Curve PrivateKey)
15:31:48 <Lethalman> just bundle them together in whatever way, and make an instance of it
15:31:50 <eitanchatav> but that makes no sense...
15:32:07 <Lethalman> getPrivateKey :: Get ((Curve, PrivateKey))
15:32:13 <eitanchatav> Lethalman...that might be the right way...i have to think about it...thanks!
15:32:21 <jmcarthur> eitanchatav: ReaderT Curve Get PrivateKey?
15:32:23 <aristid> Lethalman: the double parens there are not necessary:)
15:32:30 <Lethalman> aristid, ah :)
15:32:34 <eitanchatav> jmcarthur...that was my first thought
15:32:42 <eitanchatav> i kinda wish there was a GetT though
15:32:46 <jmcarthur> eitanchatav: e.g.  Curve -> Get PrivateKey
15:33:05 <aristid> @unmtl  ReaderT Curve Get PrivateKey
15:33:05 <lambdabot> Curve -> Get PrivateKey
15:33:10 <aristid> good bot
15:33:15 <eitanchatav> jmcarthur...yes that was my first thought too
15:33:25 <eitanchatav> how about putPrivateKey...what should be its signature?
15:33:30 <jmcarthur> eitanchatav: yeah, there really could be a GetT. Get is just a fancy continuation monad
15:33:35 <Lethalman> but then, how do you implement get for PrivateKey?
15:33:43 <jmcarthur> continuation/state
15:34:06 <eitanchatav> Lethalman...i read some parameters from the Curve and then do some getting of bytes
15:34:14 <eitanchatav> based on what that parameter reads
15:34:15 <Lethalman> eitanchatav, yes, but you can't have Curve -> Get PrivateKey
15:34:24 <Lethalman> ah yes you can sorry
15:34:25 <jmcarthur> you could still implement Get (Reader Curve PrivateKey), but it won't really do what i think you want... would just read in the data and save the parsing for later when you have the Curve
15:34:48 <eitanchatav> ReaderT is fine I guess...I would prefer GetT but whatever
15:34:58 <eitanchatav> how about putPrivateKey though?
15:35:05 <aristid> Get (Reader Curve PrivateKey) is also just Get (Curve -> PrivateKey)
15:35:15 <Lethalman> eh, you can't read it back, you have to pass the Curve elsewhere...
15:35:20 * Lethalman doesn't like this approach
15:35:27 <eitanchatav> putPrivateKey :: PrivateKey -> ReaderT Curve PutM ()
15:35:29 <eitanchatav> ???
15:35:38 <jmcarthur> that would work i think
15:35:49 <jmcarthur> i think this is a misuse of Reader (both Get and Put)
15:35:50 <eitanchatav> yes, i'm passing the key everywhere
15:35:52 <aristid> why not just use the Builder stuff instead of Put?
15:36:00 <jmcarthur> i would just use (->)
15:36:08 <aristid> Curve -> Builder
15:36:24 <eitanchatav> aristid: i'm just learning binary and haven't learned builder
15:36:36 <aristid> eitanchatav: the builder interface is simpler IMHO:)
15:36:50 <eitanchatav> aristid: thanks...i'll look into it too then!
15:37:06 <aristid> PutM is just a Writer Builder basically
15:37:24 <eitanchatav> jmcarthur: why do you consider it a misuse of Reader?
15:37:46 <eitanchatav> the Curve is an immutable global state variable
15:38:48 <aristid> eitanchatav: Reader a b is literally just a newtype around a -> b. and (->) a is a Monad instance in itself (the same instance). there is no reason to use Reader.
15:38:51 <eitanchatav> :-( I wish there were GetT and PutT...it would be more symmetrical with my other code
15:39:23 <eitanchatav> aristid: I know...but by that logic there's no reason to use any Monad...just use their underlying definition...
15:39:51 <aristid> eitanchatav: well no, for example EitherT really does add convenience over m (Either a b) :)
15:40:17 <aristid> ReaderT can also be useful
15:40:28 <eitanchatav> well, i wrote a bunch of the code with (Curve ->) first and it reads more elegantly with Reader Curve
15:40:39 <aristid> no it doesn't
15:41:13 <eitanchatav> how can you know that? ;-) obvs this was a personal aesthetic question
15:41:48 <dhrosa> what's the best way to take an even-length list, and combine elements 0,1 into  something, 2,3, etc?
15:42:34 <dhrosa> I guess I could just make my own function and pattern match
15:42:42 <hopf> So, I'm playing around with Data.Bson, and this happens: http://lpaste.net/2424248853768175616 . What would cause a type constructor to be bound to a particular version of a library?
15:42:49 <nooodl> > chunksOf 2 [1..10]
15:42:49 <erisco> dhrosa, what do you mean "combine elements 0,1 into something 2,3" ?
15:42:50 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
15:43:19 <dhrosa> I want to take elements 0 and 1, and apply a binary operation to them, the same operation onto elements 2 and 3, etc
15:43:19 <aristid> dhrosa: yeah manual recursion would not be such a bad way to do that i think
15:43:26 <nooodl> that's in... i have no idea where it's in. Data.List.Split?
15:43:32 <dhrosa> nooodl: yeah
15:43:53 <FreeFull> > map foldl1 (+) . chunksOf 2 $ [1..10]
15:43:54 <lambdabot>  Couldn't match expected type `[[e0]] -> c0'
15:43:54 <lambdabot>              with actual type `[[a0] -> a0]'Couldn't match expected type `[a0...
15:43:54 <lambdabot>              with actual type `a1 -> a1 -> a1'
15:44:04 <verement> > let pairs (x:y:rs) = (x, y) : pairs rs; pairs [] = [] in pairs [1..10]
15:44:05 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
15:44:09 <FreeFull> > map (foldl1 (+)) . chunksOf 2 $ [1..10]
15:44:10 <lambdabot>  [3,7,11,15,19]
15:44:38 <aristid> > let f [] = []; f (x:y:xs) = (x+y):f xs in f [0..10]
15:44:39 <lambdabot>  [1,5,9,13,17*Exception: <interactive>:3:5-38: Non-exhaustive patterns in fun...
15:44:48 <dhrosa> I feel dirty bringing in another dependency for a single function
15:45:07 <erisco> dhrosa, that is quite common
15:45:19 <aristid> > let f [] = []; f (x:y:xs) = (x+y):f xs in f [0..9] -- now with properly even-sized list :D
15:45:20 <lambdabot>  [1,5,9,13,17]
15:45:22 <FreeFull> You can write your own function that does what you want
15:45:35 <nooodl> imo everyone should have the "common miscellaneous list operations" thingies installed anyway
15:46:13 <FreeFull> I think split might be in the platform
15:46:19 <dhrosa> it is
15:46:37 <eitanchatav> thank you Lethalman, jmcarthur and aristid!
15:46:40 <meretrix> If I have "data X = A|B|C" and some function "f :: a -> X", is it possible to check that f is surjective?
15:47:11 <FreeFull> Anything that is in the platform is something you can assume will be on most systems
15:47:19 <shachaf> That depends on what you mean by "check".
15:47:29 <shachaf> And also on how that "a" is quantified.
15:47:45 <meretrix> shachaf: Have GHC throw a warning like it does for incomplete pattern matching.
15:48:08 <aristid> meretrix: you could try to randomly generate elements of a and wait until you have seen all elements of X. if that doesn't happen after 10 minutes it's not a good sign:D
15:48:59 <aristid> could probably use some of the quickcheck machinery
15:49:29 <meretrix> Yeah I guess it would basically involve unit tests.
15:52:00 * hackagebot hOpenPGP 0.12 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.12 (ClintAdams)
15:55:49 <Twey> meretrix: Well, if you can write a right inverse, it's surjective
15:59:31 <Twey> You can't check it's a right inverse in Haskell, but it should be fairly obvious; if that's not good enough for you, you can write it in Agda
16:02:18 <shachaf> Well, you have to be careful about "surjective" and "right inverse".
16:02:40 <shachaf> ("has a right inverse", I mean.)
16:09:01 <Twey> shachaf: Why's that?
16:13:18 <shachaf> Well, "every surjective function has a right inverse" is equivalent to the axiom of choice.
16:15:52 <triliyn> shachaf: what about "every computable surjective function has a right inverse"?
16:15:57 <Twey> shachaf: Which is only a problem if you want to use it constructively to produce one, no?
16:16:55 <AncientPC> What's the right way to solve missing libgmp.so.3 problem besides symlinking it?
16:17:08 <Twey> AncientPC: Install the required version
16:17:22 <Twey> Or rebuild the software to depend on the version you have, if it supports it
16:17:30 <shachaf> Twey: Well, that's sort of what you're proposing, isn't it?
16:17:43 <AncientPC> Twey: install the required version of what?
16:17:52 <AncientPC> the library?
16:18:05 <Twey> shachaf: No, I was proposing that meretrix write one to prove a particular function surjective (f has a right inverse → f is surjective)
16:18:11 <shachaf> What I mean is that showing that a right inverse exists is generally harder than just showing that a function is surjective.
16:18:14 <Twey> AncientPC: The library or program that depends on it
16:18:47 <shachaf> Though if you can do it it's an easy method, of course.
16:19:01 <AncientPC> Twey: I'm trying to build ghc 7.6.3 but it has libgmp.so.3 as a dependency. Online search reveals that some people symlink it to fix the issue, but that's not the correct solution and leads to problems down the road.
16:20:06 <Twey> shachaf: Agda defines Surjective by a right inverse
16:21:01 <shachaf> Well, things are a bit different in that world. The "axiom of choice" is also easy in Agda.
16:22:39 <Twey> shachaf: I'm confused.  The ‘axiom of choice’ is; the axiom of choice isn't.  What is it about Agda that makes writing right inverses easier than in whatever world you were talking about before?
16:22:57 <Twey> AncientPC: What version of libgmp do you have?
16:23:58 <shachaf> I don't think there's even a distinction between "surjective" and "has a right inverse", because Agda's version of "exists" is so strong.
16:24:37 <Twey> Right
16:24:58 <Twey> I think we're on the same page about the Agda; I'm just not sure what you were contrasting it to, or why
16:25:20 <shachaf> I don't think I brought up Agda.
16:26:39 <Twey> No, you didn't: I did, and then you made assertions that I assumed were about Agda, since that seemed to be the relevant context, but apparently they weren't
16:27:11 <Twey> So I now don't know what context you *were* talking about
16:27:47 <Twey> s/about Agda/meant to be interpreted in the context of using Agda\/MLTT to prove surjectivity/
16:27:49 <shachaf> Oh well, never mind. Maybe I have no point.
16:28:01 <Twey> Oh.  Okay.
16:29:49 <shachaf> Is a hash function like sha1 surjective? If it is, you can write an inefficient "right inverse" easily but then proving that it's total is as hard as proving that the function is surjective in the first place.
16:33:23 <Saizan> Twey: agda defines surjective that way because that's the most useful when given as an extra assumption about a function, not because it's the easier to prove
16:33:41 <Twey> shachaf: It doesn't have to be hard, just big (hash a bunch of things until you've seen all the output cases)
16:33:56 <Twey> Well, I guess that makes *producing* the function pretty hard :þ
16:34:08 <Twey> But that's just because SHA1's codomain is big
16:34:13 <shachaf> How will you know whether you've seen all the output cases?
16:34:29 <Twey> shachaf: Because the codomain is finite
16:34:53 <Twey> Saizan: Hm, how else would one define it?
16:35:48 <shachaf> The codomain is finite but the domain isn't.
16:36:09 <Cale> The domain is also finite
16:36:09 <Saizan> Twey: at worst you could wrap the thing in double negation
16:36:28 <Cale> SHA1 is only formally defined for sequences of bits up to 2^64 - 1 bits
16:36:34 <shachaf> I'm wrong. The maximum -- yes, what Cale said.
16:37:16 <Saizan> a similar one is injectivity, in agda you want f a = f b -> a = b, because a /= b -> f a /= f b is quite weaker
16:37:31 <shachaf> But that's not really relevant. Use SHA-3 instead.
16:37:39 <Cale> If someone could prove that your cryptographic hash function is surjective, it would be extremely suspicious
16:37:48 <shachaf> Yep.
16:37:51 <Cale> We don't have proofs of this even for very broken ones
16:38:15 <shachaf> "f is injective" means "(f .) is injective"; "f is surjective" means "(. f) is injective"
16:39:03 <Twey> Cale: Really?  I'd imagine you shouldn't have to test much more than the size of the output to get
16:39:13 <Twey> … a case for each output
16:39:25 <Twey> Unless your hash function has a *really* high collision rate
16:39:48 <shachaf> You should clarify whether you mean "codomain" or "image" when you say "size of the output" or "all the output cases"
16:39:52 <Cale> Twey: yeah, but the number of values in the codomain is very large
16:40:10 <shachaf> Anyway, the codomain and the image are both way too big to test.
16:40:20 <Twey> Oh, okay
16:41:13 <Cale> And yeah, by that measure the hash function definitely does have a really high collision rate :)
16:41:23 <Twey> Hm, I guess if the image were smaller than the codomain then you'd have to test the whole domain in order to prove it
16:41:48 <shachaf> Yes. "image is equal to codomain" is what surjective means.
16:42:01 <Cale> Yeah, ideally, unless the thing is horribly broken.
16:42:07 * Twey nods.
16:42:15 <Saizan> (Anyhow, i do think it might be practical to go for the right inverse as a programmer, no idea of which is the original function though)
16:42:28 <Cale> If you have a *constructive* proof that the hash is surjective, then you have a right inverse.
16:42:39 <Twey> Still, hopefully this is all a little academic for meretrix' data X = A | B | C :þ
16:42:57 <Cale> heh
16:43:08 <Cale> I wasn't here for the start of the discussion :)
16:43:09 <shachaf> Cale: If I have a nonconstructive proof that a hash is surjective, then I can use it to claim that my brute-force search is total.
16:43:39 <arcke> @src sum
16:43:39 <lambdabot> sum = foldl (+) 0
16:43:43 <Cale> shachaf: Sure! You kind of expect brute force searches to work though.
16:44:06 <Cale> i.e. you *expect* that SHA1 is surjective, but you don't expect anyone to be able to prove it
16:44:12 <shachaf> Not if the function isn't surjective, I wouldn't!
16:44:27 <Cale> shachaf: I mean, on practical terms
16:45:04 <shachaf> Eh. If someone proved that there was a particular "SHA-1 hash" that nothing could actually hash to, I wouldn't be that surprised.
16:45:05 <kazagistar> I'm learning haskell, and was thinking of porting a little python simulation I have... what functional reactive programming library would you recommend? there are a lot of options, and I am not really able to evaluate them well yet
16:45:24 <Cale> I would be!
16:45:25 <jle`> kazagistar: well...can you tell us mroe about your simulation?
16:45:26 <Twey> If I were designing a hash algorithm I'd make sure to leave one possible hash unused, just to annoy everyone
16:45:39 <jle`> Twey: me too, and i would cardcode it in
16:45:47 <jle`> *hardcode
16:45:57 <Twey> kazagistar: It depends on your simulation
16:46:07 <jle`> hash x = if hash' x == 5 then hash' (x+1) else hash x'
16:46:54 <jle`> keep in mind that direct ports will probably not be very meaningful unless you are using just a state monad based loop
16:47:17 <jle`> (and not frp)
16:47:40 <kazagistar> jle': sure, its mostly a kinetic monte carlo simulation, with bits of discrete event simulation hooked to the side. So I have some events whose rate varies according to state, and some which are triggered at specific time or time delays
16:48:06 <kazagistar> by time I mean simulation time of course
16:48:51 <jle`> typically simulations that are driven by time/clock ticks are better using AFRP/arrowized FRP...netwire being an example
16:49:20 <jle`> if your thing is driven by push/pull/event mechanics then something like sodium/reactive-banana would be more fitting
16:49:35 <kazagistar> its not tick based, it is all discrete events
16:49:48 <Cale> shachaf: Cryptographic hash functions are designed to be very difficult to reason about. Someone being able to prove that it's not surjective without effectively doing a brute force search through the entire input space is a sign that its structure is probably too well-understood for the hash to be relied on.
16:49:55 <kazagistar> unless I misunderstood what you meant by tick based
16:49:57 <jle`> kazagistar: do you have anything continuous?
16:50:07 <jle`> by tick based i mean, the progression of the simulation is driven by a clock
16:50:14 <kazagistar> no, nothing continuous
16:50:16 <jle`> instead of discrete events
16:50:28 <jle`> so things like physics simulators etc.
16:50:41 <shachaf> Cale: I'd take it as good evidence that sha-1 is broken in a probably pretty bad way, of course.
16:50:42 <jle`> video games
16:51:19 <jle`> hm
16:51:38 <kazagistar> gotcha, no, no nothing numerical or like games or whatever... I pick which event happens next, that event changes the state, repeat
16:51:55 <jle`> so like some kind of markov model?
16:52:22 <kazagistar> jle: well, mostly, but not entirely?
16:52:22 <jle`> *chain
16:52:38 <kazagistar> and I do keep track of event timestamps
16:52:46 <Twey> I wonder if Heinrich will fix that memory leak with switched reactive-banana…
16:53:00 <Twey> Is he still working on reactive-banana, does anyone know?
16:53:48 <Saizan> i saw him recently in here talking about API issues
16:54:05 <Saizan> so it'd seem so
16:54:48 <jle`> kazagistar: if your sim does not have a concept of quantities varying/changing or events happening over continuous time then AFRP/netwire might not be a good fit
16:55:06 <jle`> i haven't used enough of sodium/reactive-banana to be able to comment on how well they can fit
16:55:37 <jle`> but for something like i think i would personally use a RandT over a State or something.
16:55:42 <jle`> unless this is specifically for learning FRP
16:56:13 <kazagistar> hmm, not sure I understand?
16:56:21 <jle`> which part?
16:57:08 <Twey> Saizan: Oh good
16:57:13 <kazagistar> um, still working out an intuition for monads...
16:57:23 <jle`> i think AFRP might work if you simulate "over time", with events happening with probability P or something at every frame
16:57:30 <Twey> kazagistar: If you don't have monads down pat yet, you might want to hold off on FRP.
16:57:39 <jle`> ah
16:57:53 <subleq_> is the prelude's monad instance for [] the only possible one? (i think it is)
16:57:55 <jle`> yeah at this stage FRP might not be the right thing to tackle now
16:57:58 <jle`> subleq_: it's not
16:58:00 <jle`> :)
16:58:00 <kazagistar> well, I am trying to find a use for them so I can get them down pat
16:58:11 <jle`> kazagistar: ah. well this one actually might be a good application for State monad
16:58:23 <jle`> or if you have random things, RandT over State
16:58:29 <Twey> kazagistar: You can port your simulation pretty directly with a State monad (and whatever other inputs to your simulation there are)
16:58:47 <jle`> porting into State monad would be more or less line for line kinda
16:58:49 <jle`> sort amaybe
16:58:53 <jle`> results may vary
16:59:07 <kazagistar> hmm
16:59:11 <subleq_> jle`: what else is possible?
16:59:20 <hpc> jle`: what's the other instance?
16:59:25 <hpc> it's certainly not ZipList
16:59:49 <hpc> and i don't think there's another applicative for [] besides those two
17:01:08 <jle`> johnw sent me one :|
17:01:10 <jle`> https://gist.github.com/jwiegley/7941440
17:01:18 <jle`> it's sort of a loose analogy to ziplist
17:01:21 <jle`> extended to monads
17:01:43 <jle`> it behaves sorta usefully
17:01:44 <kazagistar> eh, I guess I will pass on it for now and take on easier tasks
17:01:49 <tpsinnem> what's the most pleasant way to fake dependent types in haskell atm? the singletons library?
17:02:14 <jle`> kazagistar: if it helps...my first real haskell project was a numerical simulation
17:02:26 <Twey> Is that even total?
17:02:28 <jle`> and it was a rough road
17:02:33 <Twey> tpsinnem: Yeah
17:02:45 <jle`> but i learned State/RandT from it...and moved from State to ST
17:03:10 <Twey> tpsinnem: There's a paper called ‘Hasochism’ that gives the current state-of-the-art
17:03:24 <Twey> singletons gives you some of that pre-written
17:03:35 <tpsinnem> Twey: thanks, i'll look into that
17:04:24 <hodapp> Hasochism? hmmm
17:04:30 <subleq_> jle`: join == concat?
17:05:05 <jle`> subleq_: not quite
17:05:08 <triliyn> subleq_: it's defined in that paste
17:05:15 <subleq_> also, what does the ~ mean?
17:05:26 <jle`> it's a lazy pattern match
17:05:42 <jle`> it matches in all cases, without inspecting the contents
17:05:45 <subleq_> triliyn: yeah, but i'm having trouble understanding it
17:05:48 <jle`> and then breaks it up later
17:06:02 <jle`> when you use them
17:06:09 <jle`> it's not...really necessary in this case
17:06:23 <triliyn> subleq_: it takes the first element of the first list, the second element of the second list, the third element of the third list, ...
17:06:47 <subleq_> oh i see
17:09:49 <Twey> jle`: That's not total: try [[]] >>= id
17:10:05 <jle`> oh yeah.
17:10:14 <jle`> it's in general not expected to be total for non-infinite lists
17:10:31 <Twey> Which I think knocks it out of the running for a ‘possible instance’
17:10:54 <jle`> maybe for a special list type with no Nil
17:11:00 <Twey> Yeah
17:11:07 <jle`> conceeded
17:11:13 <Twey> data Stream a = Stream a (Stream a)
17:12:27 <Twey> subleq_: ~ means the pattern match will always succeed, but if you try to use the components later and it should have failed, you get an error
17:12:39 <Twey> > let ~(x : xs) = [] in 5
17:12:41 <lambdabot>  5
17:12:43 <Twey> > let ~(x : xs) = [] in x
17:12:45 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern (x ...
17:13:21 <subleq_> Twey: ok, but why is that useful?
17:13:31 <hodapp> here's a possibly silly question: why use dependent typing in Haskell at all?
17:13:44 <jle`> hodapp: presumably to get all the benefits of dependent typing
17:13:58 <jle`> ;)
17:14:01 <triliyn> subleq_: pattern matches are normally strict; sometimes you want to name the parts of a thing but not be strict in that thing
17:14:26 <Twey> subleq_: You can delay checking the constructor, which can be a performance gain
17:14:54 <Twey> (my let example was bad, because that wouldn't be checked anyway — oops)
17:15:15 <kazagistar> how would you avoid dependent typing, hodapp?
17:15:16 <Twey> hodapp: Because dependent types let you specify arbitrary invariants in your types.
17:15:40 <hodapp> kazagistar: because people write papers referring to it as "Hasochism"? ;)
17:15:56 <Twey> hodapp: It's worth the pain.  If you have the time.  :þ
17:16:32 <Twey> hodapp: Also, the subtitle is something like ‘The Pleasure and Pain of Dependent Types in Haskell’, so it's not exactly a slur :þ
17:19:54 <AncientPC> hmm... I can't install cabal-nirvana due to bad line: "<html>\r". Looks like a carriage return snuck in.
17:21:15 <AncientPC> oh it's a dead project
17:21:16 <AncientPC> doh
17:21:49 <Hafydd> Cause of death: carriage return.
17:24:55 <hodapp> Twey: So, more like BHSM?
17:28:07 <Twey> hodapp: That's the one :þ
17:30:33 <hodapp> 9_9
17:50:43 <maxiepoo> wouldn't it be nice if Text.PrettyPrint exported a pretty class: `class Pretty a where { pretty :: a -> Doc }`
17:50:53 <maxiepoo> since it seems like everyone ends up doing that themselves anyway
18:08:06 <biscarch> Is there a way to dynamically build a Data.Configurator.Values.Config without using a file?
18:09:28 <biscarch> I have an ENV variable (String) I need to parse into a few fields, then pass as a Config into an init function.
18:14:00 <mxi> where is a good reference for how the numeric typeclasses are related? i found this chart but it is 4 years old: http://lh4.ggpht.com/_PiUWFeprZSw/Sd72lQjUr3I/AAAAAAAAKfA/4PLE8uFQqUk/s720/hs-nums.png
18:16:17 <roboguy_> mxi: I'm not sure that it's changed all that much in that time
18:17:31 <mxi> ok. ill just blow up that graph then. hard on the eyes, lol
18:18:12 <jle`> mxi: http://lh4.ggpht.com/_PiUWFeprZSw/Sd72lQjUr3I/AAAAAAAAKfA/4PLE8uFQqUk/s0/hs-nums.png
18:19:10 <mxi> fantastic. thank you so much.
18:19:20 <jle`> idk how, but google chrome automatically redirected me to the higher res one
18:19:30 <jle`> some kind of black magic
18:22:42 <FreeFull> mxi: I don't think Num should be pointing to Eq there
18:23:01 <FreeFull> Not if you go by Haskell2010
18:23:20 <mxi> yea i was actually going to ask that.
18:23:30 <pavonia> biscarch: You have to use a temp file it seems
18:23:47 <mxi> i didn't think it was
18:24:22 <mxi> i didnt think it was "safe" to do == on floats and doubles. figured they just did it to be practical?
18:24:56 <kazagistar> its safe if you know what you are doing?
18:25:08 <biscarch> pavonia: it's one of the paths I've considered. Thanks.
18:25:22 <kazagistar> but, so is C, so that sort of philosophy has its flaws
18:25:58 <Twey> It's safe to do 3.0 == 3.0; it's only a problem if you do different operations on each value before comparing (which I guess is when you're most likely to compare things…)
18:27:05 <FreeFull> In Haskell, two floats or doubles that have different values will display differently
18:27:14 * hackagebot pipes-bytestring 1.0.3 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-1.0.3 (GabrielGonzalez)
18:27:22 <pavonia> biscarch: The documentation says you can retrieve the value for a field from an OS environment variable. So I'm wondering if that reference is also updated when the whole file is reloaded
18:27:24 <quchen> (==) on Double is safe iff what you want to compare is Double, and not the real numbers you're approximating.
18:29:01 <stelleg> @src (read :: Int)
18:29:01 <lambdabot> Source not found. You speak an infinite deal of nothing.
18:29:07 <pavonia> biscarch: Ah, never mind, you wouldn't get that parsed, just as a plain string :p
18:29:11 <stelleg> @src (read :: String -> Int)
18:29:12 <lambdabot> Source not found. Do you think like you type?
18:29:16 <stelleg> @src read
18:29:16 <lambdabot> read s = either error id (readEither s)
18:30:01 <mxi> in standard ml reals are not equatable bc nan != nan http://www.smlnj.org/doc/Conversion/types.html#Real-equality
18:30:55 <kristof> Does using "over" with a lens actually mutate the data structure or does it return a new one with the differing element?
18:31:06 <Axman6> the latter
18:31:10 <kristof> Ah, of course
18:31:15 <Axman6> ;)
18:31:19 <biscarch> pavonia: yes, therein lies my issue :). I'm looking at probably modifying the snaplet I'm using to take the full string.
18:35:01 <jle`> is ther esome sort of handy reference for haskell syntax
18:35:06 <roboguy_> kristof: you can use it with instances of MonadState, but none of those instances do in-place modification either (as far as I can think of)
18:35:10 <jle`> i don't define instances often enough to have it memorized
18:35:30 <kristof> roboguy_: Well, I wasn't trying to mutate something, just wondering about the semantics of a certain library :)
18:35:46 <roboguy_> ah
18:36:01 <roboguy_> it wouldn't work well with a lot of other Haskell things if it actually modified anything
18:36:17 <jle`> well..it wouldn't really make sense either
18:37:01 <jle`> because haskell doesn't really have a concept of objects that can exist and be modified
18:37:03 <roboguy_> yeah. I've used a haskell library that modified arguments and it did not feel good
18:37:18 <roboguy_> it was a wrapper for a C library
18:37:36 <jle`> the main reason is because evaluation order in haskell is more or less unpredictable
18:38:01 <jle`> well among other reasons
18:38:35 <zRecursive> does unpredictable scare anyone here ?
18:39:20 <jle`> there are various associated feelings of vertigo
18:39:25 <jle`> :)
18:39:29 <triliyn> zRecursive: it's not scary, but it prevents you from doing things that depend on evaluation order
18:39:56 <roboguy_> zRecursive: not too much. in Haskell, things don't get modified (well, they shouldn't anyway) so it isn't really dangerous
18:40:29 <zRecursive> isnot monad ensure evaluation order ?
18:40:38 <jle`> zRecursive: no, not really
18:40:53 <zRecursive> how about `seq` ?
18:40:56 <roboguy_> zRecursive: monad doesn't really have to do with evaluation order
18:41:16 <Twey> jle`: It's quite consistent.  Blocks in general look like ‘<keyword> <name> where <definitions>’
18:41:19 <zRecursive> @src seq
18:41:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:41:24 <roboguy_> zRecursive: seq does
18:41:30 <roboguy_> seq can't be written in haskell
18:41:39 <roboguy_> the definition of seq can't
18:41:41 <jle`> it's magic :)
18:41:48 <zRecursive> :t seq
18:41:48 <Twey> jle`: class Num a where …  instance Num Int where …  module Algebra.Ring where …  data Nat where …
18:41:49 <lambdabot> a -> b -> b
18:42:13 <jle`> Twey: do i just list type signatures then?
18:42:18 <jle`> for class
18:42:21 <jle`> and i guess..
18:42:21 <Twey> jle`: Yes
18:42:22 <jle`> methods
18:42:24 <jle`> for instance
18:42:27 <Twey> Yes
18:42:41 <jle`> i guess i can just play around until vim stops yelling at me
18:42:43 <Twey> You can also give things implementations in class, which will become defaults
18:42:50 <jle`> but i guess it's consistent/predicatable
18:42:59 <Twey> Yep
18:43:02 <jle`> how do i provide implemenations?  just put them in the class declaration block?
18:43:07 <Twey> Yep
18:43:32 <jle`> hm. cool
18:45:26 <jle`> ty
18:45:31 <Twey> Haskell syntax is mostly quite predictable; the only things I sometimes forget all seem to be related to contexts, which seem to be a bit of an afterthought
18:45:38 <Twey> No problem
18:50:29 <Cale> Twey: What in particular?
18:50:57 <Cale> The fact that you can't necessarily plug in specific types in various places without FlexibleInstances/FlexibleContexts?
18:52:17 <Twey> That's part of it; also things like contexts on type declarations used to trip me up (is it data Num a ⇒ Foo a = Foo a or data Foo a = Num a ⇒ Foo a, &c.) though that's largely irrelevant now
18:52:37 <Cale> Oh, yeah. The stupid context
18:52:53 <Twey> And generally the fact that they look like tuples but aren't
18:53:14 <Cale> Various rules ended up in the Haskell Report just because type classes were still somewhat new at the time, and I'm not sure how much sense it makes to cling to them.
18:53:15 <Twey> Oh, I'm still not sure about some of the module export syntax for things like classes and instance methods, either
18:54:15 <Cale> Usually you just want C(..) in your export list, where C is the name of the class, similar to a data type.
18:54:41 <Twey> But how do I e.g. export a particular method without exporting the class?
18:55:23 <Cale> You can include the methods explicitly in the export list if you want, even outside of that
18:55:30 <Twey> Ah, okay
18:55:46 <Twey> I can figure them out, it just takes some experimenting sometimes if it's been a while since I've been reminded of them :þ
18:55:47 <c_wraith> Twey: you can export the name of the function, but note that that results in the terrible situation where the type of the function references a class that isn't exported.
18:55:59 <Cale> It would be weird not to export the class if you export its methods
18:56:04 <Twey> Yeah
18:56:29 <roboguy_> wouldn't it be really hard to use a module that did that?
18:56:35 <Cale> yes
18:56:45 <Twey> It's awkward, yes
18:56:54 <c_wraith> I'm sure you can find some examples of it on hackage.  it can be done, it's just unpleasant
18:56:58 <Twey> I think I ran into one of those a few weeks back.  Very frustrating.
18:57:01 <Cale> You couldn't use the class name in your own types, so it would force you not to write things which were polymorphic
18:57:08 <Twey> GLUT or GLutils or something
18:58:49 <Cale> I still think it would be very cool to be able to export a type synonym, but not the equality that the synonym represents.
18:59:09 <Cale> There was a big missed opportunity there with 'type'
18:59:16 <Twey> Oh, speaking of syntax: I ran into something fun with DataKinds today
18:59:59 <Cale> oh?
19:00:02 <roboguy_> Cale: sort of something between newtype and type?
19:00:13 <Cale> roboguy_: Yeah, it would be like a module-level newtype
19:00:22 <roboguy_> hmm, that is an interesting idea
19:00:25 <Twey> There's no way to refer to a qualified value on the type level.  foo ∷ Any (Set.fromList [Int]) is a parse error.  foo ∷ Any ('Set.fromList [Int]) is a parse error.  You have to import it unqualified or rebind and say foo ∷ Any (fromList [Int]), which is then fine.
19:00:34 <Cale> roboguy_: You'd lose the ability to directly construct values of that type at the module boundary
19:00:52 <Cale> and inside, you wouldn't have to use an extra data constructor
19:01:05 <Twey> That sounds nice
19:01:14 <roboguy_> that would be cool
19:01:17 <Twey> I'd also very much like to be able to export qualified modules
19:01:30 <Cale> Yeah, I think everyone would like that :)
19:01:36 <Twey> Maybe Backpack will give us all these nice things
19:01:57 <Cale> What about Set.'fromList ?
19:01:58 <Twey> Someone posted that at me again recently, so I assume there's been renewed interest
19:02:13 <Cale> Also, how is fromList okay?
19:02:33 <Cale> I wasn't aware that they lifted functions like that
19:02:57 <Twey> Cale: No luck.  ‘Illegal symbol '.' in type’
19:03:05 <Cale> hm!
19:03:06 <Twey> Amusingly it then recommends I enable RankNTypes, even if RankNTypes is enabled
19:03:14 <Cale> :)
19:03:24 <Twey> I think all values get lifted to the type level, don't they?
19:03:33 <Cale> I thought it was just constructors
19:03:34 <Twey> Otherwise it would be kind of hard to do computations with them.
19:03:48 <Cale> and to do computations you'd have had to write type families
19:03:53 <Cale> But that's nice if it's everything
19:04:18 <Twey> Oh, well, it seems to lift everything
19:04:36 <Twey> Though it doesn't seem to actually evaluate applications, just kind-check them
19:04:46 <Cale> ah, I see
19:05:07 <Cale> Yeah, I didn't think we had full-on dependent types :)
19:05:27 <Cale> (yet)
19:05:35 <Twey> ‘No instance for (Num (id Int)) arising from …’
19:05:41 <Cale> cute
19:05:45 <Twey> Oh
19:05:48 <roboguy_> didn't SPJ say he wants to avoid a turing complete type system?
19:05:53 <Twey> Actually, it will accept anything there
19:06:00 <Twey> I guess it's just a type variable.  Hah!
19:06:13 <Cale> roboguy_: It's not that he'd rather avoid it, it's that he wants to hang on to as much type inference as possible
19:06:17 <zq> what're the consequences of a Turing-complete type sys?
19:06:28 <Cale> Also, there's already a Turing complete type system
19:06:31 <roboguy_> zq: possible non-termination of the type checker for one
19:06:35 <roboguy_> although, that's already possible
19:06:41 <Cale> You can write a lambda calculus evaluator with fundeps in 3 lines
19:06:50 <Twey> You could trivially add termination-checking to the kind-checking process, though
19:06:52 <roboguy_> ah, really?
19:07:13 <roboguy_> I've used fundeps a little, but I've hardly done any type-level computation
19:07:58 <roboguy_> Cale: type level lambdas interfere with type inference, right? I think that's the context I heard him say that in
19:08:21 <Cale> yes
19:08:29 <Cale> http://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level
19:08:51 <Cale> (okay, it's a few more lines really, but pretty much :)
19:10:51 <Cale> There's more features and examples in the .lhs there
19:12:18 <kristof> What's the most advanced book about functional programming that anyone here has come across?
19:12:36 <Cale> kristof: Perhaps the Homotopy Type Theory book counts?
19:12:47 <kristof> Cale: Nope, because that's not about programming.
19:12:52 <Cale> It is too!
19:13:01 <Cale> Barendregt's bible would be another
19:13:33 <roboguy_> kristof: it's not the most advanced certainly, but Pearls of Functional Algorithm Design is one of my favorites
19:13:48 <kristof> Cale: Aaaah but you know what I mean. I really think it would be beneficial to the greater FP community if there were a collection of vetted design principles which will persist for at least two decades
19:13:58 <kristof> roboguy_: Saw that, looks interesting
19:14:01 <gienah> Algebra of Programming is a more crazy book like Pearls of Functional Algorithm Design
19:14:27 <Cale> kristof: I'm mildly anti-design-principles
19:14:56 <Cale> kristof: If a design principle is good enough to be worth its salt, it's good enough to make into a library
19:14:58 <kristof> Cale: Don't think of them like commandments, but more like an Almanac.
19:15:21 <kristof> Cale: I'm thinking about stuff like the "monad transformer" pattern.
19:15:27 <Cale> and if you can't make the pattern you see cropping up into a library, then your language needs adjustment
19:15:36 <kristof> that's true
19:15:42 <Cale> Well, monad transformers are a library :)
19:15:54 <kristof> But recognizing that you need one?
19:15:58 <roboguy_> kristof: those patterns can usually be abstracted quite a bit, hence the libraries
19:16:03 <Cale> But yeah, maybe we should have a book about some of the really good libraries
19:16:19 <roboguy_> Cale: lens could easily be a book on it's own, haha
19:16:24 <Cale> Indeed!
19:16:28 <kristof> Cale: Whether or not monad transformers are implemented in a popular library is irreverent to their usefulness as a concept.
19:16:29 <Twey> kristof: Recognizing that you need one takes experience, even with traditional OO design patterns
19:16:45 <kristof> Twey: I was just about to say this
19:16:57 <roboguy_> kristof: are you talking about *using* monad transformers or *making* new ones?
19:17:00 <Twey> It's not really the sort of thing you can put in a book
19:17:06 <kristof> Twey: But I think reading about it in a book counts as some kind of experience.
19:17:15 <kristof> In the same way that people share insights through blog posts.
19:17:17 <Twey> For a simple listing of possible abstractions, we have the Typeclassopedia
19:17:22 <kristof> roboguy_: Making ones you use.
19:17:37 <kristof> Real World Haskell makes you go through it, and it's a great chapter, I think.
19:17:41 <Cale> My recommendation is not to start with the abstraction
19:17:55 <Cale> Be aware of the abstractions which are available, sure
19:17:57 <roboguy_> kristof: well, that's the sort of thing that's usually general enough that it usually doesn't involve many problem specific details
19:18:05 <zq> any guides on how to read Core? the #s are really blinding me
19:18:12 <Cale> But write and design your library independently of that, and see which abstractions then apply to it
19:18:14 <roboguy_> kristof: it's different than how design patterns work in OO, for example
19:18:23 <kristof> There are no good design patterns in OO, that's why
19:18:27 <Cale> zq: -dsuppress-all
19:19:18 <roboguy_> kristof: I think the reason the OO design patterns exist is more that it's harder to abstract things out in OO
19:19:37 <kristof> Exactly.
19:19:38 <Cale> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/options-debugging.html#supression
19:19:56 <kristof> roboguy_: And yet in an expressive language like haskell, patterns still show up, and in a more meaningful way.
19:19:59 <roboguy_> kristof: which is also why "design patterns" don't really exist in haskell. not really in the same sense
19:20:04 <Cale> There are some general ways of thinking
19:20:15 <kristof> The "general ways of thinking" are what I'm talking about.
19:20:28 <roboguy_> ahh, so more like problem solving as it applies to programming?
19:20:29 <zq> "how to read core syntax", thanks Cale
19:20:41 <roboguy_> and program structuring?
19:21:30 <kristof> roboguy_: I think it would be a mix between "program structuring" and walking through some very common data types / use cases.
19:21:41 <Cale> One of them is that rather than solving a problem directly, you can instead form an embedded language consisting of primitive simple problems in your problem space which you know how to solve, together with ways of combining those problems in such a way that you know how to compose the solutions.
19:21:56 <Cale> and you hopefully design this language in such a way that your original problem is easy to express
19:22:10 <Cale> Then your program is very flexible to changes in requirements
19:22:16 <kristof> Of course, however
19:22:19 <roboguy_> Cale: I guess that could be considered a design pattern of some sort. it's a pretty general one though
19:22:50 <kristof> Cale: I'm mostly thinking about all those wonderful blog posts about monads, applicatives, comonads, arrows, etc. that abound on the net. What if you could find that in a book?
19:23:01 <Cale> hm
19:23:27 <roboguy_> it would be nice to have all that together in a coherent, somewhat linear form
19:23:35 <roboguy_> well, not *all* but some of it, at least
19:23:42 <yayutf> kristof: there's http://martinfowler.com/dslCatalog/ , I suppose, though that's more patterns for implementing DSLs
19:23:44 <kristof> You have to admit that those aren't anything like OO design patterns and yet they still take the form of "I came across this problem, had these constraints, and this seemed to capture the ESSENCE of the problem most directly"
19:23:59 <Cale> Yeah, well, I've wanted to write a book about Haskell and include at least some of that. (I also think I could do a somewhat better job of the basics for some audiences than is otherwise available)
19:24:03 <roboguy_> kristof: the thing is, I'm not sure to what degree that can be *taught*
19:24:08 <roboguy_> hmm
19:24:08 <kristof> Like how you might represent cellular automata using comonads.
19:24:31 <Cale> kristof: But I think it's really okay for some stuff to be blog posts and papers
19:24:39 <Cale> Especially the papers
19:25:24 <kristof> Papers should inevitably find their way into books
19:25:41 <Cale> I feel like the papers relevant to ordinary programming in Haskell have kind of slowed down a bit though
19:25:48 <kristof> Academics evaluate and propose ideas until the sand settles
19:26:08 <Twey> I think people got bored with the ‘look, you can do this in functional programming too!’ papers
19:26:59 <kristof> Twey: So people should start doing what hasn't been done before :)
19:27:01 <Twey> Now it's ‘look, you can encode X with dependent types and get checks for Y!’ for a while
19:27:22 <kristof> I read this excellent expose on fold, unfold, and hylomorphisms.
19:27:38 <Cale> Well, not just those ones, but stuff like Wadler's "Hey look, that egghead Moggi was using monads to explain the semantics of programming, and we could just use them directly!"
19:27:42 <kristof> That's something that could be called a "design pattern" but isn't existing because of a lack of language expressiveness.
19:27:45 <Twey> kristof: Sadly, a lot of stuff-that-hasn't-been-done-before seems to take place in industry and not be shared
19:28:03 <kristof> Cale: Nobody cares
19:28:07 <kristof> Oh, I said that wrong
19:28:17 <roboguy_> Twey: it probably will be at some point
19:28:23 <Twey> Cale: That's kind of in the first category, albeit a particularly profound example of such
19:28:36 <Twey> roboguy_: Hopefully
19:29:07 <roboguy_> Twey: yeah. I'm very curious about the companies that use Haskell and other functional languages (especially for large projects)
19:29:14 <Cale> also stuff like the QuickCheck paper and things about how to do parsers and pretty printers
19:29:14 <Twey> I think the equivalent direction of research now is into formalizing imperative programming
19:29:14 <kristof> Cale: Sorry, what I meant to say was "Wadler's results were of fundamenal importance to functional programming but it takes a lot of refinement to understand how to apply that to typical programming."
19:29:41 <Cale> kristof: That's much truer of Moggi's results than Wadler's
19:29:44 <Twey> kristof: Eh?  We use monads all the time now.
19:29:59 <kristof> After people stopped and thought about what you could do with monads
19:30:09 <Twey> Wadler brought them into the vernacular of the programmer (or, well, at least the PL researcher, whence they eventually found their way to the programmer)
19:30:31 <kristof> Twey: that last transition is more important in the context of what I'm talking about
19:30:35 <Cale> Wadler was the guy who actually started using them in code and showing others how to do that
19:30:39 <kristof> Oh
19:30:42 <kristof> Then there you go!
19:30:59 <Cale> (In his papers)
19:31:13 <Cale> also, I suppose, in the standard library
19:31:34 <johnw> did he invent the IO monad?
19:31:49 <Cale> I think so
19:31:50 <Twey> Essentially
19:32:34 <yayutf> Cale: I'd say no - http://okmij.org/ftp/Computation/IO-monad-history.html
19:32:38 <kristof> Cale: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf I think a book would look a little something like a collection of these kinds of papers.
19:33:09 <Cale> I mean, it's a little hard to attribute the ideas entirely to him, because this is what monads were used for in explaining the semantics of programming languages for a long time before that
19:33:15 <Cale> Especially by Moggi
19:33:21 <roboguy_> kristof: that Pearls of Functional Programming book is a collection of Functional Programming Pearl papers
19:33:31 <kristof> roboguy_: Ah, that's very cool
19:33:40 <yayutf> Cale: the above link mentions Landin-1965
19:33:53 <yayutf> kristof: yeah, it's a great book - I got it for christmas
19:34:15 <kristof> roboguy_: But anyway I would like to imagine that there are more than just "pearls" involved in the principled design of very big systems
19:34:31 <Cale> Yeah, I kind of feel that's a bit of a stretch.
19:34:44 <kristof> What is?
19:34:46 <yayutf> kristof: there's no end of books on software architecture
19:35:03 <yayutf> the 'pearls' book is a lot of small but interesting pieces, which is entirely different
19:35:16 <Cale> That the use of monads in programming languages and semantics is due to Landin
19:35:33 <kristof> yayutf: software engineering courses are hijacked by the java programming language
19:35:34 <Cale> You're not really using monads until you're abstracting over them
19:35:35 <yayutf> Cale: I wouldn't say 'due to', for sure.
19:35:52 <yayutf> kristof: the best books on the topic predate Java :-)
19:36:05 <johnw> Cale: you made that point the other day and I thought it was a really good one
19:36:11 <Cale> Even if you write a library which might include the operations which would make it into a monad
19:36:18 <johnw> you're not really using monads if you're just using a particular instance of Monad
19:36:30 <Cale> That's not "using monads", that's "you accidentally defined a monad without realising it"
19:36:40 <Cale> and that's something which is by no means hard to do
19:38:14 <Cale> But yeah, the more important aspect of IO, which is not that it's a monad, but that it's a datatype at all? Perhaps we can attribute that to Landin.
19:42:37 <L8D> What is a good library for doing HTTP requestS?
19:43:11 <Cale> L8D: download?
19:43:17 <L8D> Cale: yep
19:43:18 <Cale> HTTP
19:43:29 <Cale> That was also a suggestion
19:43:33 <Cale> "download"
19:43:38 <L8D> oh
19:43:51 <L8D> Cale: thanks
19:43:58 <Cale> If all you want to do is grab the content from them, that's probably what you want
19:45:01 <L8D> Cale: download looks good
19:45:02 <L8D> thanks
19:45:43 <Cale> but yeah, for somewhat fancier stuff, I'd use http://hackage.haskell.org/package/HTTP
19:46:21 <L8D> :(
19:46:33 <L8D> the current version of download doesn't build
19:46:36 <Cale> wat
19:46:38 <Cale> really?
19:46:45 <Cale> I'll check it out
19:46:48 <L8D> Deprecated: "Use System.IO.Unsafe.unsafePerformIO instead; This function will be removed in the next release"
19:47:18 <L8D> and then a bunch of compile errors in cbits/ftp.c
19:47:33 <Cale> Probably missing C deps there
19:48:08 <Cale> wait, mine built and installed fine
19:48:18 <Cale> There were warnings, but no errors
19:48:39 <Cale> The unsafePerformIO thing is a warning
19:49:30 <Cale> What C error in ftp.c did you get?
19:51:04 <ReinH> Writing a virtual machine in Haskell is fun
19:51:05 <Cale> oh, wow, but I have a different problem
19:51:11 <Cale> Loading package download-0.3.2 ... linking ... <interactive>: /home/cale/.cabal/lib/x86_64-linux-ghc-7.6.3/download-0.3.2/libHSdownload-0.3.2.a: unknown symbol `stat64'
19:52:08 <Cale> http://www.archivum.info/glasgow-haskell-bugs@haskell.org/2008-07/00074/Missing-symbol-when-loading-cbits-in-ghci.html -- lol?
19:52:34 <Cale> I wonder if Don solved his problem
19:52:56 <verement> ReinH: what kind of virtual machine are you writing?
19:54:08 <Cale> L8D: anyway, you might also try download-curl
19:54:10 <ReinH> verement: a Z-Machine for Zork and other infocom games
19:54:25 <Cale> That had a dependency on curl too, but perhaps it'll work, I'm trying it now
19:54:46 <verement> ReinH: oh fun, I've written one of those before
19:55:30 <ReinH> verement: ZSCII makes me so glad we have more sensible encodings now...
19:55:37 <verement> hah
19:55:56 <Cale> lol, how does ZSCII work?
19:56:18 <ReinH> Cale: a lot like other 5-bit teletype codes (Baudot)
19:56:29 <ReinH> shift codes and such
19:56:45 <Cale> ah, it's 5 bit, lol
19:56:58 <Cale> L8D: download-curl works for me
19:57:05 <Cale> L8D: and it's a drop-in replacement
19:57:54 <ReinH> 5 bit chars packed into 16-byte words :D
19:58:30 <Cale> 16 bit, surely
19:58:45 <ReinH> woops typo
19:58:49 <ReinH> 16-bit words indeed
19:58:55 <Cale> 16 byte words would be remarkably luxurious :)
19:59:00 <ReinH> indeed
19:59:49 <Cale> Just in case you needed 340282366920938463463374607431768211456 distinct memory locations.
19:59:52 <ReinH> :D
20:01:08 <c_wraith> I thought I was the only one
20:01:54 <ReinH> Cale: that would be a pretty long text adventure game
20:02:13 <Cale> 5444517870735015415413993718908291356671 BASIC BYTES FREE
20:02:29 <Cale> READY.
20:05:56 <Ralith> c_wraith: I considered mapping that much space once, before immediately realizing it was impossible
20:07:22 <ReinH> heh
20:07:30 <webstrand> I'm trying to make a function that produces the sum of a list of numbers return a polymorphic type, for example http://lpaste.net/98749 . Is there any way to do this?
20:08:16 <shachaf> webstrand: Well, you can't convert an arbitrary Num type to another arbitrary Num type.
20:08:44 <shachaf> (What would it mean to convert a complex number to an integer?)
20:09:03 <webstrand> I understand that, but I don't believe Haskell supports function overloading, so I can't create specialized functions.
20:09:04 <shachaf> And (+) always returns a value of the same type as its arguments, so you'll have to introduce some explicit conversion.
20:09:24 <ReinH> webstrand: (+) does not coerce into a "larger" type (like Int to Integer) in cases of overflow
20:09:42 <ReinH> > (maxBound :: Int) + (maxBound :: Int)
20:09:43 <lambdabot>  -2
20:09:53 <ReinH> so sum is behaving "correctly"
20:10:05 <shachaf> webstrand: Well, what do you want to do?
20:10:23 <shachaf> You can restrict the argument to Integral, for instance.
20:10:51 <webstrand> I want to be able to call sum on an arbitrary list, either rational or integral and have it return the total sum.
20:10:52 <shachaf> And then use toInteger/fromIntegral on it.
20:11:01 <Twey> webstrand: You should probably just have said sumProblematic [1 .. 100 ∷ Integer] (or sumProblematic $ map fromIntegral [1 .. 100 ∷ Int8] ∷ Integer)
20:11:12 <webstrand> shachaf: as soon as i do that floating point numbers wouldn't work
20:11:32 <shachaf> webstrand: Right. What do you want to happen with floating point values?
20:11:52 <webstrand> shachaf: I'd like the function to return a Rational type.
20:12:08 <webstrand> Twey: That'd introduce significant overhead I'd think
20:12:41 <shachaf> And with a list of complex numbers?
20:13:10 <webstrand> shachaf: I don't know how haskell handles complex numbers
20:13:30 <Twey> webstrand: Probably not, actually: the Int → Integer conversion shares most of the data (small Integers are just wrapped Ints)
20:13:34 <Twey> (in GHC)
20:13:52 <shachaf> I,I unsafeCoerce :: Int -> Integer
20:14:02 <shachaf> webstrand: As a type which is an instance of Num.
20:14:26 <Axman6> Twey: well, wrapped Int#'s
20:14:46 <ReinH> It's possible to write a typeclass for Num types which have a "larger" representation, map the numbers into that "larger" representation, and then sum them. This would avoid overflows and such.
20:14:52 <ReinH> I'm not sure how generally useful it would be though
20:15:11 <ReinH> sum . fmap fromIntegral and similar seem pretty suitable
20:15:15 <Twey> But that's irrelevant.  The point is that you have to return the sum as some type.  (+) works on homogeneous types, so you'll get back the type you put in.  If you want something else back out, you need to convert to that other thing.
20:15:28 <ReinH> Twey: yes, you have to map over the list first
20:16:01 <Axman6> class DirtyNum a b c where (+) :: a -> b -> c; instance DirtyNum Word8 Word8 Word16 where ..
20:16:06 <Axman6> gross
20:16:07 <ReinH> generally speaking you have
20:16:09 <ReinH> :t (+) `on` fromIntegral
20:16:10 <lambdabot> (Integral a, Num c) => a -> a -> c
20:16:19 <Twey> Axman6: You'd still have to convert in the instance
20:16:24 <webstrand> I guess what i'm trying to do is like overloading functions in procedural languages, if the arguments are type class Integral then the function should return an Integer, otherwise if the argument type class is Rational it should return rational.
20:16:26 <Axman6> Twey: right
20:17:02 <Twey> webstrand: But you'd still have to convert in order to return an Integer
20:17:17 <Axman6> :t toInteger
20:17:18 <lambdabot> Integral a => a -> Integer
20:17:19 <ReinH> one way or another you need to convert each number in your list from one representation to another.
20:17:26 <Twey> Overloading is just convenient syntax: you don't magically get to use different types because of it
20:17:45 <webstrand> Twey: Wouldn't that be faster than mapping a conversion from Int -> Integer?
20:17:49 <Twey> (you can actually do basically the same thing with typeclasses and functional dependencies, but it doesn't solve your problem)
20:17:59 <Twey> webstrand: No, it would be exactly the same conversion
20:18:11 <ReinH> I don't see a more general solution than sum . fmap fromIntegral or sum . fmap fromRational
20:18:24 <Twey> Unless you're planning to sum them all as Int8's and then convert the result to Integer, but you'd still get the overflow that way
20:18:36 <webstrand> Okay, that makes sense
20:19:01 <ReinH> the sum . fmap conversion solutions should fuse
20:19:14 <webstrand> fuse?
20:19:28 <ReinH> @src foldl
20:19:28 <lambdabot> foldl f z []     = z
20:19:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:19:36 <ReinH> woops sorry
20:19:38 <ReinH> @src sum
20:19:38 <lambdabot> sum = foldl (+) 0
20:21:22 <ReinH> you can combine a fold and an fmap
20:21:33 <ReinH> for foldr it's foldr f z . fmap g = foldr (f . g) z
20:21:37 <ReinH> is the foldl version the same?
20:22:05 <ReinH> the point being, the compiler should be able to fuse sum . fmap f into a single loop
20:22:13 <ReinH> so you aren't actually looping over the list twice
20:23:05 <dolio> It's not quite the same, because the arguments to f are reversed for foldl.
20:23:13 <ReinH> dolio: right, I didn't want to figure it out
20:23:32 <dolio> Also the rules used in the standard library don't fuse foldl with anything, I think.
20:23:38 <ReinH> dolio: well crap
20:23:52 <ReinH> you can still write foldr ((+) `on` fromIntegral) 0 if you want
20:23:53 <dolio> That's one of the reasons stream fusion is a lot better.
20:24:32 <ReinH> dolio: right now we have foldr/build, yeah
20:25:02 <ReinH> why is sum a foldl anyway?
20:25:19 <Axman6> because you know it's not going to need laziness
20:25:24 <dolio> Because it's a lot better that way for almost every numeric type.
20:25:25 <Axman6> you almost always want foldl' though
20:25:38 <ReinH> dolio: why?
20:26:02 <dolio> Because almost none of them can give partial results.
20:26:11 <ReinH> sure
20:26:18 <dolio> And will just stack overflow with foldr on large lists.
20:26:21 <Axman6> except for Nat
20:27:21 <ReinH> well then why doesn't it just use foldl'? :p
20:28:26 <dolio> For most types, there are rules that make it use foldl', I think.
20:28:57 <ReinH> ah
20:29:01 <ReinH> alrighty then
20:29:52 <dolio> I think that was missing for floating point types for a while. Not sure if that's changed.
20:31:10 <joe9> sometimes my xmonad writes out the error 'divide by zero'. I am not sure if that would be a haskell question or an xmonad question. Any suggestions on how to go about trying to find out where the error is coming from, please?
20:32:17 <enthropy> @where stacktrace
20:32:17 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
20:33:48 <enthropy> joe9: so to get those flags in, I would do something like   ghc  -prof -fprof-auto -rtsopts ~/.xmonad/xmonad.hs -o ~/.xmonad/xmonad_conf
20:33:58 <webstrand> The problem with foldl (+) 0 (map toInteger [1..100 :: Int8]) is that an Int8 can be summed with a bignum with less effort than two bignums can. Is there something I'm still missing?
20:34:03 <enthropy> then  ~/.xmonad/xmonad_conf +RTS -xc # as your window manager
20:34:46 <Twey> webstrand: Summing an Int8 with an Integer means converting the Int8 into an Integer and then summing them
20:34:49 <enthropy> probably getting profiling to happen means you have to re-install xmonad with profiling enabled
20:35:07 <dolio> There's no easier way in the GHC primops.
20:35:10 <Twey> Probably; I don't know what support gmp has for doing that
20:35:23 <webstrand> Twey: Not really
20:35:38 <dolio> The off-diagonal cases just convert the machine word into a GMP value and add.
20:35:39 <Twey> But it wouldn't be surprising if, if such a thing existed, GHC were to use it to optimize a fromIntegral a + b expression
20:36:02 <joe9> enthropy: thanks a lot.
20:36:36 <webstrand> dolio: I've never looked at gmp internals, but in another bignum library there were optimized pathways for primitive integers
20:37:23 <dolio> webstrand: It doesn't really matter if GMP can do it, because it's not exposed in GHC.
20:37:36 <roboguy_> webstrand: I wouldn't think that would make a huge difference
20:38:22 <enthropy> @src Integer
20:38:22 <lambdabot> data Integer = S# Int#
20:38:22 <lambdabot>              | J# Int# ByteArray#
20:38:37 <dolio> Either both values are machine integers and the result can fit in a machine integer, in which case you get back a machine integer, or you convert to GMP values if applicable and add.
20:38:41 <roboguy_> enthropy: that's not the gmp Integer, that's the other one
20:38:50 <roboguy_> I think
20:38:56 <webstrand> It wouldn't make a huge difference for most code, but it means for heavy math code a different language should be used. I'm just trying to get a feel for haskell.
20:39:00 <enthropy> the ByteArray is what gmp uses
20:39:22 <Axman6> and the Int I believe
20:39:34 <roboguy_> oh, right doesn't the other one use a haskell list?
20:39:35 <webstrand> Okay, is there any way in haskell to dispatch depending on the types of the arguments?
20:39:35 <Axman6> GMP stores numbers as a length and an array of words I believe
20:39:39 <geekosaur> I think the J# is a size and a bytearray
20:39:44 <roboguy_> webstrand: type classes
20:39:46 <geekosaur> S# is the machine word version
20:40:35 <kristof> What's the difference between an IntMap and a 1-dimensional array?
20:40:39 <Twey> webstrand: Profile before you make optimization decisions like that.  GHC does a *lot* of optimizations.
20:40:49 <webstrand> roboguy_: How would that work for the Integral and Rational type classes?
20:40:55 <roboguy_> webstrand: ?
20:41:10 <Twey> kristof: The array will be more compact, and the IntMap will waste less space for sparse data?
20:41:27 <roboguy_> kristof: if you store a value in the 10000000th position in an array, the array must have at least that many elements
20:41:29 <kristof> Twey: Does an IntMap eventually have to rebalance?
20:41:31 <webstrand> roboguy_: I don't know of any syntax that lets me pick alternative functions based on the types of their arguments.
20:41:39 <kristof> roboguy_: So IntMaps can be sparse, got it
20:41:49 <dolio> kristof: No. It's not a balanced tree.
20:41:55 <roboguy_> webstrand: that's exactly what type classes do...
20:42:00 <geekosaur> webstrand, that's correct, you can't do type case except via typeclass instances
20:42:04 <kristof> ..........but there are such things as sparse arrays.
20:42:06 <kristof> Bah, never mind
20:42:11 <geekosaur> note, you cannot select between two *typeclasses*
20:42:51 <Axman6> I thought IntMap was balancing
20:42:54 <webstrand> Just to be clear, can I write two different functions with the same name that behave differently given differing argument types?
20:43:01 <roboguy_> webstrand: yes
20:43:12 <roboguy_> in fact, you can even do that based on return type
20:43:16 <Twey> « The implementation is based on big-endian patricia trees. »
20:44:30 <webstrand> Where can I read up on this? The book i'm using has gone over type classes but i've never found any way to do that?
20:44:53 <kristof> webstrand: Learn You a Haskell
20:44:56 <roboguy_> wait, how can it have gone over type classes but not that? that's pretty much exactly what type classes are...
20:44:57 <kristof> everything shall be explained
20:45:03 <geekosaur> then I think you failed to understand them, or you are fixated on it being a style that it is not
20:45:10 <roboguy_> webstrand: I'll write an example
20:45:38 <Twey> :t (+) -- this is a function that dispatches based on the types of its arguments
20:45:40 <lambdabot> Num a => a -> a -> a
20:45:52 <maxiepoo> :t show
20:45:52 <lambdabot> Show a => a -> String
20:46:13 <Twey> :t maxBound -- this dispatches based on the type you expect its value to be
20:46:14 <lambdabot> Bounded a => a
20:46:27 <c_wraith> :t read -- dispatches based on its return value
20:46:28 <lambdabot> Read a => String -> a
20:47:36 <maxiepoo> :t read . show
20:47:37 <lambdabot> (Read c, Show a) => a -> c
20:47:44 <maxiepoo> :t show . read
20:47:44 <lambdabot> String -> String
20:48:06 <Twey> That one will error
20:48:16 <maxiepoo> yea definitely
20:48:19 <Twey> > show . read $ "5"
20:48:20 <lambdabot>  "*Exception: Prelude.read: no parse
20:48:40 <maxiepoo> interesting
20:48:40 <Twey> I was hoping for a more informative error than defaulting gives, of course :þ
20:48:53 <L8D> Does someone have a link to what ZSCII is?
20:48:54 <Twey> lambdabot defaulted to (), and "5" is not a valid representation of ()
20:49:03 <roboguy_> webstrand: http://lpaste.net/98751
20:49:03 <maxiepoo> > show . read $ "()"
20:49:04 <lambdabot>  "()"
20:49:07 <webstrand> I had mostly equated type classes with interfaces.
20:49:29 <geekosaur> they're not and thinking that can get you into weird type errors
20:49:35 <Twey> L8D: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
20:49:36 <roboguy_> webstrand: type classes are only *very* roughly similar to interfaces
20:49:36 <geekosaur> they share some similarities
20:49:48 <L8D> > show (read "5" :: Num a => a)
20:49:49 <lambdabot>  Could not deduce (GHC.Read.Read a)
20:49:50 <lambdabot>    arising from a use of `Text.Read.read'
20:49:50 <lambdabot>  from the context (GHC.Num.Num a)
20:49:50 <lambdabot>    bound by an expression type signature: GHC.Num.Num a => a
20:49:50 <lambdabot>    at <interactive>:1:7-28
20:49:55 <geekosaur> but enough significant differences that it will mislead you
20:49:55 <L8D> > show (read "5" :: Int)
20:49:56 <lambdabot>  "5"
20:50:13 <webstrand> Thanks for the example
20:50:17 <Zettablade> Am I crazy for wishing Google had written android's application layer with haskell instead of java?
20:50:23 <L8D> > read "[1, 2, 3, 4]" :: [Int]
20:50:24 <lambdabot>  [1,2,3,4]
20:51:03 <Axman6> Zettablade: no, but Google probably would've been
20:51:21 <roboguy_> webstrand: the difference from interfaces becomes more apparent when you have things like multiple type class parameters
20:51:45 <roboguy_> when you have multiple parameters, it basically becomes a relation between types
20:52:59 <maxiepoo> how do I get runhaskell to use my cabal sandbox?
20:53:12 <Twey> maxiepoo: You have to ‘cabal run’
20:53:27 <maxiepoo> I don't have a cabal package
20:53:36 <hodapp> oy, I'm having a hard time following this Hasochism paper
20:53:43 <hodapp> it'd help if I read up on what 'kinds' are
20:53:49 <maxiepoo> I just put it in a sandbox to avoid polluting my global package db with all the yesod stuff
20:54:08 <mm_freak> hodapp: just like values have types, types have kinds
20:54:16 <mm_freak> Maybe :: * -> *
20:54:17 <mm_freak> Int :: *
20:54:20 <mm_freak> Maybe Int :: *
20:55:00 <mm_freak> hodapp: you can ask for the kind of a type by using :k (similar to :t)
20:55:05 <hodapp> hmmmm
20:57:45 <maxiepoo> oh wtf why do I have ghc 7.4?
20:57:50 <maxiepoo> gr
20:59:48 <joe9> enthropy: quick question: is this what you expect http://codepad.org/XAiaqTSt and just start xmonad_stacktrace from xinitrc?
21:00:13 <joe9> enthropy: I mean the command exec ~/etc/xmonad/xmonad_stacktrace +RTS -xc
21:00:40 <enthropy> joe9: That's what you get if you have another window manager running at the same time or so
21:00:50 <L8D> Is there some documentation on what the '#' at the end of variable names does?
21:01:05 <roboguy_> L8D: it doesn't really *do* anything, it just means they're unboxed
21:01:08 <joe9> enthropy: I agree. just wanted to check that I am doing it right.
21:01:22 <L8D> roboguy_: It's just a convention then?
21:01:28 <joe9> enthropy: does it write the stack trace to the xinit.log?
21:01:44 <roboguy_> L8D: as far as I'm aware, yes. but you need MagicHashes to use it
21:02:01 <enthropy> I don't think you get a stack trace unless the program exits with an exception
21:02:07 <roboguy_> L8D: also, the kind of an unboxed type is #
21:02:32 <joe9> enthropy: yes, when it exits how does it report the stacktrace?
21:02:36 <joe9> through xinit.log?
21:03:45 <enthropy> no, it'll be somewhere else
21:03:58 <L8D> roboguy_: So is # a type constructor?
21:04:04 <joe9> where, please? so, I know where to search for it.
21:04:50 <enthropy> probably it'll just print on the console
21:09:58 <joe9> enthropy: also found this : http://web.archiveorange.com/archive/v/j8BnAhpTUcMw9uloZCmQ , can I do gdb <xmonad-binary> >/var/log/errors.txt to figure out where I am getting core dumps from?
21:10:14 <joe9> this is a different issue regarding random core dumps from xmonad or xmobar.
21:11:11 <joe9> this is what I have in my .xinitrc: http://codepad.org/m1EV3wbw
21:11:16 <joe9> enthropy, good enough?
21:11:24 <enthropy> seems irrelevant
21:11:43 <enthropy> your divide-by-zero error is from haskell code, right?
21:11:51 <enthropy> > 1 / 0 :: Int
21:11:52 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
21:11:52 <lambdabot>    arising from a use of `GHC.Real./'
21:11:52 <lambdabot>  Possible fix:
21:11:52 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
21:12:01 <Axman6> > div 1 0
21:12:02 <lambdabot>  *Exception: divide by zero
21:12:09 <roboguy_> L8D: no, it's a kind
21:12:17 <roboguy_> L8D: * isn't a type constructor either
21:12:33 <roboguy_> @kind Maybe
21:12:34 <lambdabot> * -> *
21:12:36 <joe9> enthropy: but, I do not where the code is.
21:12:52 <joe9> enthropy, I have 2 issues.
21:12:56 <roboguy_> let's see if this works...
21:12:58 <roboguy_> @kind Int#
21:12:58 <lambdabot>     Not in scope: type constructor or class `Int#'
21:12:58 <lambdabot>     Perhaps you meant one of these:
21:12:58 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
21:13:01 <roboguy_> nope
21:13:08 <joe9> one is the 'divide by zero' and the other is 'random core dumps.'
21:16:02 <joe9> enthropy: ^^
21:23:52 <osa1> is backpack going to be added to Haskell/GHC in the future?
21:24:07 <Axman6> backpack?
21:25:53 <roboguy_> backpack is an upgrade to the module system, right?
21:26:40 <Clint> what does it do?
21:26:43 <osa1> yeah, I guess. there's a paper in POPL.
21:26:49 <osa1> Clint: module system for Haskell
21:27:01 <Axman6> http://plv.mpi-sws.org/backpack/
21:33:36 <Zettablade> are there any good haskell based operating systems?
21:35:53 <td123> Zettablade: the only one I know of is nixos
21:39:58 <roboguy_> what do you mean by good and what do you mean by based?
21:40:37 <tertl3> hehe
21:40:45 <tertl3> nice question Zettablade
21:42:22 <johnw> td123: how is nixos haskell-based?
21:42:32 <Gracenotes> linux is a based operating system
21:43:10 <Gracenotes> also, you can't really have OSes for languages with significant runtime systems
21:43:14 <Zettablade> Interesting
21:43:36 <Zettablade> I've seen some of the stuff the haskell wiki points too
21:43:54 <roboguy_> Gracenotes: well, you might be able to but you'd need to write a whole new runtime system at a pretty low level
21:44:21 <tertl3> Zettablade: just for fun Ive been looking for tools written in haskell, have you seen the yi editor?
21:44:32 <Zettablade> a haskell based os wouldn't be all haskell though. some low-level parts of the os would have to be in asm and c, but the application layer of the os could be written in haskell.
21:44:41 <Zettablade> no I haven't
21:45:04 <ChongLi> Zettablade: what about using a Haskell DSL to generate the low-level C?
21:45:07 <tertl3> check it out
21:45:13 <tertl3> did you try xmonad yet?
21:45:50 <ChongLi> depending on how you design it, you might gain a lot of the benefits of the type system despite the low-level result
21:46:20 <ChongLi> one example of such a DSL is Atom
21:46:22 <tertl3> what youd have to do is get a chip made for for haskell
21:46:23 <Zettablade> ChongLi: That's possible? Holy wow!
21:46:31 <tertl3> like the lisp machines
21:46:34 <ChongLi> http://hackage.haskell.org/package/atom
21:47:22 <Zettablade> Yi looks neat. I've been using FPComplete for messing aroudn with haskell
21:47:23 <Gracenotes> I've seen a couple of toy operating systems in Rust. It looks promising. (hope its type system bends more towards Haskell than C++ in the future, though)
21:47:33 <tertl3> ChongLi: does it work that way if you compile it back to C?
21:47:42 <tertl3> u still get the benefits?
21:47:55 <ChongLi> tertl3: as long as you don't modify the resultant C
21:48:17 <tertl3> cool
21:48:43 <Zettablade> is rust a good language? How does it compare to haskell?
21:49:01 <tertl3> Zettablade: FPComplete is cool, i have an account on therre but it expired
21:49:26 <AshyIsMe> Zettablade: learn them both!
21:49:30 <AshyIsMe> (but haskell first of course)
21:49:43 <ChongLi> I don't know much about Rust, though it seems to be quite complicated
21:50:03 <ChongLi> it does a lot to bring memory safety to a low-level systems language
21:50:29 <bjz> ChongLi: it used to be horribly complex, but in recent months it is really starting to come together
21:50:55 <Gracenotes> I'm looking at using it in situations when it really does matter what bits in memory you touch in what order.
21:51:00 <roboguy_> bjz: did they ever implement higher kinded types?
21:51:08 <roboguy_> *higher kinded polymorphism
21:51:27 <bjz> roboguy_: not yet, but they are very open to it. they just have a lot on their plate heading into 1.0
21:51:38 <roboguy_> bjz: ah, cool
21:51:38 <tertl3> i like D
21:52:01 <bjz> roboguy_: HKTs should be backwards compatible, so they are probably going to hold off until after 1.0
21:52:06 <ChongLi> Rust: supporting pure-functional, concurrent-actor, imperative-procedural, and object-oriented styles.
21:52:17 <Zettablade> ugh, I'm having enough trouble mastering all the concepts in haskell right now to tackle rust
21:52:20 <ChongLi> that's quite a grab bag
21:52:33 <Zettablade> slowly working through the real world haskell book online
21:52:40 <bjz> ChongLi: yeah, I don't really like that description
21:52:53 <ChongLi> bjz: it makes it sound unprincipled
21:53:00 <tertl3> thats too much
21:53:07 <AshyIsMe> Zettablade: learn you a haskell is also really good
21:53:17 <AshyIsMe> !lyah
21:53:24 <AshyIsMe> damn ive forgotten the syntax
21:53:32 <tertl3> The TAO (Monad) that can be told is not the eternal TAO (Monad).
21:53:34 <ChongLi> they've got some mechanism similar to type classes
21:53:39 <ChongLi> and I would assume they have generics
21:53:40 <pavonia> @where lyah
21:53:40 <lambdabot> http://www.learnyouahaskell.com/
21:53:45 <ChongLi> why do they also need inheritance?
21:54:09 <ChongLi> oh, they don't have classes
21:54:11 <roboguy_> ChongLi: it can still come in handy to have a notion of subtyping
21:54:23 <ChongLi> so calling it "inheritance" is a misnomer
21:54:28 <tertl3> how does FP complete work?
21:54:30 <Zettablade> maybe I haven't read far enough into lyah, but I don't feel like it really teaches functional programming well
21:54:38 <tertl3> they have servers running GHC for you?
21:54:41 <ChongLi> does Rust have sum types?
21:55:00 <Twey> tertl3: Yes
21:55:03 <bjz> ChongLi: Rust has as much inheritance as Haskell does with its typeclasses, and is as object oriented as haskell is
21:55:11 <bjz> ChongLi: yes
21:55:25 <ChongLi> bjz: ahh, so it's not inheritance in the same "classical" style as Java
21:56:02 <bjz> ChongLi: trait contraints if you like, with default implementations
21:57:50 <ChongLi> so does it have sum types?
21:58:44 <bjz> ChongLi: the main focus of rust is to provide the tools to create safe abstractions over unsafe memory management. The client should have control over how their memory is allocated without having to worry about data races, dangling pointers, buffer overflows etc
21:58:58 <tertl3> fpcomplete is really nice actaully aside from it being cloud based or whatever.  it would be nice if it were native too though
21:59:35 <ChongLi> looks like "enumerated types" fill the role
21:59:41 <bjz> ChongLi: yes, it uses has Option implemented as a library for example
22:00:11 <Zettablade> I remember when I first got FPComplete and then my trail ended, and FP Complete was like "hey I'm a $700 program buy me"
22:00:22 <bjz> ChongLi: although Option has to implement its own monadic functions for now
22:00:56 <ChongLi> it's just weird how they take these established ideas and rename them for apparently no reason
22:02:29 <bjz> ChongLi: yeah - partly to make it less intimidating to C or C++ programmers. Something I don't really agree with, but I can get over. Option/Some/None comes from SML though (which predated Maybe I think)
22:02:31 <tertl3> its like visula studio for haskell
22:03:03 <ChongLi> bjz: I don't mind Option/Some/None
22:03:17 <ChongLi> but enumerated types and traits is a bit weird
22:03:20 <bjz> ChongLi: `enum` is... weird, but yeah
22:03:22 <bjz> yeah
22:03:46 <ChongLi> I'd find it confusing, coming from C where enums are just numbers
22:03:56 <roboguy_> ChongLi: well, when they were planning on adding haskell type class-like stuff to C++ they called them traits
22:04:15 <bjz> ChongLi: I think using `class` would confuse OO programmers
22:04:15 <bjz> ChongLi: :P
22:04:17 <roboguy_> "class" is probably more confusing, actually
22:04:19 <roboguy_> yeah
22:04:39 <ChongLi> well, there's just not enough words available!
22:04:40 <ChongLi> damnit
22:04:43 <bjz> heh
22:05:05 <ChongLi> but would C programmers really have been scared by "algebraic data types"?
22:05:21 <roboguy_> well, that does sound kind of fancy
22:05:30 <bjz> hoity toity
22:05:33 <bjz> xD
22:05:39 <ChongLi> or just "sum and product types"
22:05:42 <bjz> jk :P
22:06:33 <ChongLi> at any rate, if I had to choose between C, C++ and Rust it looks like Rust would be easiest for me, coming from Haskell
22:06:54 <bjz> ChongLi: I am an advocate of the `type` keyword, but I haven't yet convinced anyone. but yeah - you get over this stuff if the semantics is attractive enough
22:08:27 <LinearInterpol> Rust is awesome.
22:08:39 <ChongLi> also, the C-style function definition with types mixed in is just so clunky compared to Haskell's separate type annotation and pattern match
22:08:41 <bitemyapp> Rust is promising, but it has a lot of flaws already.
22:08:54 <LinearInterpol> Rust actually introduced me to Haskell, if you can believe that.
22:08:59 <bitemyapp> I haven't decided if any of them are deal-breakers. The main "usability" problem I have right now is that type signatures are fuck-ugly.
22:09:13 <LinearInterpol> What..
22:09:28 <bitemyapp> LinearInterpol: non-trivial Rust code, look at the type signatures.
22:09:29 <LinearInterpol> fn blah(i:int) -> int { i + i }
22:09:39 <LinearInterpol> Eh, I will agree they look a tad ugly.
22:09:43 <LinearInterpol> At first.
22:09:47 <bitemyapp> LinearInterpol: why would you even present a trivial example like that when you should know exactly what I mean?
22:09:48 <bjz> ChongLi: the non-curriedness is partly to make it nicer to work with what the machines know, I think
22:09:49 <LinearInterpol> But if you look a them again..
22:09:59 <bitemyapp> LinearInterpol: that it needs a "periodic table" of types says a lot.
22:10:02 <LinearInterpol> They slowly make sense.
22:10:08 <bitemyapp> LinearInterpol: same combinatorial type combinations mistake Scala made.
22:10:09 <ChongLi> bjz: curried functions are just so cool though
22:10:19 <LinearInterpol> 'ey, it looks nice to me. It's a subjective thing.
22:10:21 <ChongLi> though I guess they're also kind of confusing for beginners
22:10:22 <bitemyapp> LinearInterpol: I've probably used Rust longer than you have, I don't need to spend more time hating the type signatures.
22:10:24 <roboguy_> bitemyapp: what do you mean?
22:10:32 <LinearInterpol> Jesus, hostility much.
22:10:39 <bitemyapp> I don't feel hostile.
22:10:40 <LinearInterpol> Chill your shit, dude.
22:10:43 <flebron> Hi. How can I transform an Integer into a [Word8]?
22:10:47 <bitemyapp> I am chill, although I could use some tea.
22:10:49 <ChongLi> yeah, this is not a place for fighting
22:10:52 <bitemyapp> thirsty.
22:10:58 <bitemyapp> roboguy_: ever use Scala?
22:11:04 <bjz> bitemyapp: you seem chill enough to me
22:11:08 <roboguy_> bitemyapp: I meant about the "periodic table of types" thing
22:11:22 <bitemyapp> roboguy_: http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/
22:11:31 <roboguy_> ahh
22:11:31 <ChongLi> flebron: you could use Data.Binary to turn it into a ByteString
22:11:45 <ChongLi> and from there to a [Word8]
22:11:47 <flebron> Thanks :)
22:11:49 <bitemyapp> roboguy_: now imagine a non-trivial type signature for a procedure that had multiple arguments.
22:12:08 <bitemyapp> roboguy_: the type signatures turn into exploded guts of what looks like a knife-fight gone wrong like Scala.
22:12:39 <bitemyapp> I'm grateful that Rust is taking traits seriously, but zomg.
22:13:12 <bitemyapp> roboguy_: don't forget to manipulate the checkboxes on the side
22:13:20 <bitemyapp> roboguy_: there are *MORE* variations than the initial table state.
22:13:22 <joneshf-laptop> LinearInterpol, do you really have to type that example?
22:13:28 <bjz> ChongLi: anyway, will stop promoting here
22:13:29 <LinearInterpol> >
22:13:30 <LinearInterpol> *?
22:13:33 <joneshf-laptop> LinearInterpol, or would rust infer the type?
22:13:39 <ChongLi> bjz: I didn't see it as promoting
22:13:42 <LinearInterpol> I think honestly rust would infer the type.
22:13:48 <bjz> ChongLi: the language is not perfect
22:13:56 <LinearInterpol> not yet. :)
22:14:05 <ChongLi> yeah, I think it starts from a flawed premise
22:14:10 <roboguy_> bitemyapp: wow that is complicated
22:14:11 <ChongLi> but that's just my opinion :)
22:14:14 <bjz> ChongLi: which?
22:14:25 <ChongLi> that we should use a machine model for writing programs
22:14:31 <bitemyapp> roboguy_: see?
22:14:31 <ChongLi> rather than a language/equational model
22:14:44 <bjz> ChongLi: yeah, it's a difficult thing
22:14:55 <LinearInterpol> joneshf-laptop: I'm honestly not sure. I think rust would infer the type, but.. I doubt it.
22:14:57 <bitemyapp> roboguy_: I get that Rust can do systems-y things languages like Java and Haskell aren't as well suited to, but my god do they seem to make me want to shed some blood for it.
22:15:01 <bjz> ChongLi: pluses and minuses for both.
22:15:10 <ChongLi> whenever you use a machine model, you assume some sort of machine
22:15:21 <ChongLi> and that machine may change, breaking your model
22:15:24 <bitemyapp> roboguy_: doesn't have H-M either :(
22:15:26 <Twey> ChongLi: Writing programs by drawing Turing machines?  :þ
22:15:31 <bitemyapp> roboguy_: inference is only for let expressions.
22:15:40 <LinearInterpol> ChongLi: I.. agree with that. You kinda tie yourself down to an execution model that mirrors a mechanical machine of some sort.
22:15:46 <Twey> ChongLi: The Center for Bits and Atoms have RALA, which looks like it could be neat
22:15:52 <LinearInterpol> You can't express your computations without that kind of machine.
22:16:05 <bitemyapp> LinearInterpol: really?
22:16:10 <LinearInterpol> not easily.
22:16:22 <bitemyapp> LinearInterpol: really?
22:16:28 <ChongLi> you see it all the time when people try to write concurrent code in C
22:16:34 <ChongLi> it's just a mess
22:16:36 <bitemyapp> LinearInterpol: how sure are you?
22:16:57 <LinearInterpol> bitemyapp: Quite sure. I could be wrong, but I really don't care. :)
22:17:05 <bitemyapp> LinearInterpol: what do you think is more likely, the universal negative probability of what you're proposing or a lack of familiarity on your part with existing work to the contrary?
22:17:16 <ChongLi> but the other flaw in the assumption is that a machine model is better for performance
22:17:18 <bitemyapp> LinearInterpol: but if you don't care and quite possibly don't know, then why say anything?
22:17:26 <LinearInterpol> What the fuck is up with you?
22:17:27 <ChongLi> that may be the case right now
22:17:32 * hackagebot egison-tutorial 3.2.0 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.0 (SatoshiEgi)
22:17:41 <ChongLi> but will it always be?
22:17:57 <LinearInterpol> Pardon my french but you're being an asshat. Sorry for saying absolutely anything.
22:18:00 <bitemyapp> LinearInterpol: don't let your ego flare up, just entertain the question.
22:18:10 <bitemyapp> LinearInterpol: what were you attempting to accomplish?
22:18:17 <bitemyapp> LinearInterpol: exercise some critical distance.
22:18:20 <LinearInterpol> I'm out. Argue amongst yourselves.
22:18:29 <ChongLi> wow, what the hell?
22:18:32 <DigitalKiwi> wtf just happened
22:19:12 <bitemyapp> apparently some people don't come to IRC for dialogue.
22:19:25 <bitemyapp> that's not really new for me, but it's new for me for this channel.
22:19:36 <ChongLi> it's one thing to have dialogue, another just to aggressively challenge someone
22:20:11 <bitemyapp> ChongLi: I was legitimately curious as to the point of the assertion.
22:20:34 <bitemyapp> ChongLi: they almost immediately disowned it when I asked if they were sincere, then got angry when I asked why they were insincere.
22:20:39 <ChongLi> well, you could have used a less aggressive tone
22:21:00 <bitemyapp> I guess, but there was definitely no malice intended there.
22:21:06 <DigitalKiwi> i didn't see bitemyapp do anything wrong, from the start that guy was accusing bitemyapp of behaviors that bitemyapp was not exhibiting but he was
22:21:08 <bitemyapp> I can really only coddle ego up to a point.
22:21:20 <ChongLi> DigitalKiwi: I saw it
22:21:33 <bitemyapp> in general you really cannot discuss subjects to any depth if you're going to make it personal instead of a subject of curiosity.
22:21:52 <jle`> how can i turn an arrow on a data field into an arrow on the data itself?
22:22:24 <jle`> if i have an (Arrow r) => r a a
22:22:30 <jle`> and I have Foo b a
22:22:47 <jle`> can i get an (Arrow r) => r (Foo b a) (Foo b a) ?
22:22:52 <jle`> leaving b unchanged
22:22:55 <bitemyapp> ChongLi: I'll observe your behavior to see if I can extract examples of the less aggressive approach you want.
22:23:17 <bitemyapp> ChongLi: but if you don't inquire into anything, I'm not going to have any material to work with.
22:23:19 <DigitalKiwi> bitemyapp: what are these other models
22:23:35 <ChongLi> bitemyapp: alright, but you may have to wait a while, I'm just about to go to bed
22:23:44 <bitemyapp> ChongLi: no big. I've got Fay to poke at anyway.
22:24:23 <ChongLi> at any rate, I don't typically inquire into people's sincerity or anything like that (here anyway)
22:24:31 <bitemyapp> DigitalKiwi: most people I run into that think "lower level" languages like C or C++ match the way their machine works, in my experience, know neither how the languages nor the machine work.
22:25:09 <bitemyapp> DigitalKiwi: let alone any "alternative" models of computation, which you as a user of Haskell, can probably surmise coexist happily with "efficiency"
22:25:29 <flebron> How can I convert a lazy bytestring into a bytestring?
22:25:32 <ChongLi> bitemyapp: right, but what's wrong with people being ignorant of something?
22:25:46 <bitemyapp> ChongLi: nothing at all.
22:25:54 <flebron> (Data.Byteable requires ByteString, I have a Lazy.ByteString)
22:25:55 <bitemyapp> ChongLi: you're missing a parameter though.
22:25:57 <ion> flebron: toStrict
22:26:03 <flebron> Thanks :)
22:26:04 <DigitalKiwi> it was the "but i don't care" that is worrisome
22:26:25 <bitemyapp> ChongLi: people ignorant of something making ignorant assertions but disclaiming any sincerity in their assertions.
22:26:45 <c_wraith> DO the recent haddock changes make the signature of toStrict in the haddocks look saner?
22:26:48 <ChongLi> bitemyapp: I view ignorance as an opportunity to inform
22:27:07 <DigitalKiwi> ChongLi: he said he was unwilling to be informed
22:27:18 <bitemyapp> ChongLi: well I was headed in that direction had they found a way to keep their ego from enveloping what they'd just gotten done saying they didn't care about.
22:27:24 <jle`> actually my problem is a little less simple...
22:27:24 <ChongLi> and I see nothing wrong with people making misinformed statements out of ignorance, so long as others step in to correct and nobody is deceived
22:27:27 <bitemyapp> the contradictory nature of which I cannot begin to fathom.
22:27:44 <bitemyapp> ChongLi: do I need to repeat myself?
22:27:48 <ChongLi> talking to someone about their "ego" is aggressive
22:27:53 <bitemyapp> ChongLi: I just said what aspect of it was problematic.
22:27:54 <ChongLi> it's needlessly personal
22:27:54 <jle`> turning an (Arrow r) => r [a] [a] and Foo b a to an (Arrow r) => r [Foo b a] [Foo b a]
22:27:58 <flebron> bitemyapp: "why would you even present a trivial example like that when you should know exactly what I mean?" is better written "I was thinking or more complicated examples :)"
22:28:17 <bitemyapp> ChongLi: I also wasn't particularly concerned with the ignorance when I explained what I found troubling.
22:28:18 <Zettablade> What's the worst thing about haskell?
22:28:23 <flebron> It's not a matter of ego stroking, it's a matter a human - human interface.
22:28:25 <Axman6> all of it
22:28:27 <bitemyapp> Zettablade: having to use things that aren't Haskell.
22:28:45 <Zettablade> Axman6: hahahaha
22:28:46 <bitemyapp> ChongLi: despite having explained that the concern wasn't the ignorance at all (I find it an opportunity as well) you choose to continue to beat that drum.
22:28:51 <ChongLi> Zettablade: that it doesn't have enough people to write all the libraries I want to see
22:28:59 <Axman6> but more accurately what bitemyapp said
22:29:06 <flebron> Likewise, "Shall we exchange in fluid exchange?" is not a very useful one liner.
22:29:08 <bitemyapp> ChongLi: I'm happy to discuss the exchange with you, but I need you to be a bit more responsive to what I'm saying.
22:29:35 <flebron> *Shall we engage (4am typing...)
22:29:44 <Zettablade> Rust looks completely disgusting
22:29:45 <Zettablade> I'd rather use c
22:29:49 <bitemyapp> LOL
22:29:54 <bitemyapp> Zettablade: ouch.
22:30:05 <tertl3> will someone write a haskell for gpu?
22:30:19 <bitemyapp> I'd be a bit more gracious to pcwalton et al's work than that, but I can see why you'd find it hairy initially.
22:30:35 <bitemyapp> I'd use Rust over C for the (potentially) more helpful type system.
22:30:37 <DigitalKiwi> I hadn't ever read about Ada until yesterday, looked pretty interesting...
22:31:09 <Axman6> Ada is a fantastic language
22:31:13 <Zettablade> What's wrong with types in C?
22:31:16 <Axman6> IMO it puts C++ to shame
22:31:19 <ChongLi> bitemyapp: yeah, I had a look back over the log
22:31:21 <enthropy> c_wraith: I think not. It would be ugly to see Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString too
22:31:42 <Axman6> tertl3: you can already use GPUs from Haskell. see Accelerate
22:31:43 <ChongLi> I still can't figure out what LinearInterpol did that was so bad
22:31:54 <ChongLi> that deserved being called out for ego
22:32:13 <bitemyapp> ChongLi: misverbing now.
22:32:26 <bitemyapp> ChongLi: my intent wasn't to "call out", it was to get them to set it aside for a moment so we could pursue the conversation.
22:32:32 <bitemyapp> calling out implies a focus on ego.
22:32:41 <bitemyapp> the whole point was to put ego aside so the subject could be pursued.
22:32:53 <bitemyapp> There's a consistency of intent here you may not be picking up on, even if my approach was flawed.
22:32:58 <ChongLi> I didn't see what was so egotistical about what they were saying
22:33:10 <Zettablade> eh, I'd have to get accustomed to using rust. But I don't see the dislike of C. It's actually a good language.
22:33:42 <bitemyapp> Zettablade: it's just too late in human civilization for me to put up with languages like that.
22:34:36 <flebron> bitemyapp: I gave you an example where your wording was poor enough to sound confrontational, if that was not your intention.
22:34:38 <Zettablade> My biggest problem with it is how slow it's code compiles
22:34:54 <Zettablade> I used D for a bit, and code would compile isntantly. It was cool.
22:34:58 <bitemyapp> flebron: it wasn't and I told ChongLi I'd look for cues from them as well for better approaches.
22:35:00 <Zettablade> instantly*
22:35:11 <Chris> Go compiles fast, bitemyapp loves Go.
22:35:46 <ChongLi> my approach is always to make people feel as welcome as possible
22:36:10 <flebron> The statement "I've probably used Rust longer than you have" is also quite weird.
22:36:25 <flebron> There does not seem to be nearly enough information in his words for you to deduce anything close to that.
22:37:07 <flebron> And it comes off as, on your part, posturing.
22:37:14 <bitemyapp> flebron: I don't really like being told I'll enjoy something I don't enjoy if I do more of the thing I don't enjoy.
22:37:23 <DigitalKiwi> maybe bitemyapp has been using rust since it was iron
22:37:29 <flebron> You must've hated vegetables.
22:37:36 <bitemyapp> DigitalKiwi: more like 0.4 or 0.5
22:37:43 <bitemyapp> flebron: yeah, actually.
22:37:49 <bitemyapp> I mean, I eat vegetables now.
22:37:54 <bitemyapp> but the ones I didn't like - no dice.
22:37:59 <ChongLi> that's common with kids
22:38:19 <ChongLi> it can just take a while to build up a palette
22:38:26 <Zettablade> How extensible is haskell? Can I reimplement c in haskell?
22:38:41 <ChongLi> Zettablade: what do you mean by reimplement?
22:39:10 <ChongLi> with the FFI you can write some pretty low-level imperative code in Haskell
22:39:14 <bitemyapp> flebron: quickest way to short-circuit that entire avenue was to just explain that I'd used Rust over the course of enough changes and developments that I knew exactly how I felt about the type signatures at this juncture.
22:39:21 <Zettablade> Well, make a fancy notation for the {} brackets and a fancy notation for ; and somehow force it i dunno
22:39:40 <ChongLi> Zettablade: Haskell already has support for {} and ;
22:39:41 <Zettablade> I know haskell is extensible somehow, but I'm still learning the darn language
22:39:52 <ChongLi> it's an alternative to layout (indentation)
22:40:00 <Zettablade> oh wow really?
22:40:03 <Zettablade> that's sweet
22:40:10 <bitemyapp> Zettablade: have you gone through a book of any kind?
22:40:19 <Zettablade> not completely
22:40:21 <bitemyapp> Zettablade: there's a couple of free ones you might like.
22:40:23 <ChongLi> bitemyapp: Zettablade has been going through RWH
22:40:29 <bitemyapp> Zettablade: I have a favorite tutorial too.
22:40:38 <Zettablade> yea?
22:40:44 <Zettablade> I'm interested
22:40:45 <bitemyapp> ChongLi: not a bad choice. Some preliminary material might help though.
22:40:49 <bitemyapp> Forest for the trees type situation.
22:41:01 <ChongLi> generally, people around here recommend LYAH first
22:41:05 <ChongLi> followed by RWH
22:41:13 <bitemyapp> Zettablade: it's not perfect: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ but this gives a nice high level overview that prepares you for the more detailed approach of RWH.
22:41:19 <bitemyapp> Zettablade: I don't like LYAH at all.
22:41:22 <bitemyapp> except as a reference.
22:41:23 <ChongLi> unless the person in question is coming from a different background
22:42:05 <Zettablade> I don't like LYAH, it's too slow for my tastes
22:42:16 <ChongLi> okay
22:42:30 <bitemyapp> Zettablade: then you might be like me!
22:42:36 <ChongLi> there's also the infamous "Gentle Introduction
22:42:37 <ChongLi> "
22:42:37 <bitemyapp> Zettablade: in which case, give that esposito tutorial a shot :)
22:42:41 <Zettablade> and I don't feel like it's explaining everything correctly either
22:42:51 <ChongLi> http://www.haskell.org/tutorial/
22:43:06 <Zettablade> omg reading through teh comments for RWH sometimes those guys get stuff wrong too
22:43:24 <ChongLi> the "Gentle Introduction" assumes prior functional programming experience, though
22:43:32 <flebron> I enjoyed LYAH.
22:43:39 <bitemyapp> flebron: you're a patient person :)
22:43:52 <ChongLi> the key is to skim
22:43:53 <bitemyapp> I prefer to skip to the parts I don't know and confront them.
22:43:57 <flebron> I simply wasn't under time pressure.
22:44:02 <bitemyapp> I wasn't either.
22:44:04 <bitemyapp> I just get bored easily.
22:44:10 <Zettablade> I enjoyed a couple chapters of it, but it got boring after a bit
22:44:36 <Zettablade> maybe i just lack the metal to finish it haha
22:44:37 <bitemyapp> I like LYAH as a reference when I'm teaching somebody Haskell and want a quick but simple example.
22:44:42 <bitemyapp> Zettablade: mettle?
22:44:46 <Zettablade> yea
22:45:38 <Zettablade> "The conventional method to learning Haskell is to read two books. First “Learn You a Haskell”† and just after “Real World Haskell”†. I also believe this is the right way to go. But to learn what Haskell is all about, you’ll have to read them in detail."
22:45:39 <Zettablade> haha
22:53:29 <jle`> is there any way to pop off the last field in a data constructor call?  i guess you'd need access to the constructor, but some way to turn Foo x y :: Foo into Foo x :: y -> Foo
22:54:12 <enthropy> if Foo has a Data instance sure
22:54:27 <enthropy> in general you aren't allowed to do that
22:55:04 <joneshf-laptop> wouldn't a function work?
22:55:23 <enthropy> but you need one function per type then
22:55:42 <jle`> enthropy: how would i do it if it had a Data instance?
22:55:42 <ChongLi> jle`: you can partially apply constructors
22:56:18 <ChongLi> I'm not sure if that's what you're trying to do
22:56:19 <Axman6> @let data Foo x y = Foo x y
22:56:22 <lambdabot>  Defined.
22:56:26 <Axman6> :t Foo
22:56:26 <lambdabot> x -> y -> Foo x y
22:56:29 <Axman6> :t Foo 1
22:56:30 <lambdabot> Num x => y -> Foo x y
22:56:34 <jle`> yeah....
22:56:43 <jle`> but i want to turn a Foo 1 2 into a Foo 1
22:57:06 <Axman6> @let f (Foo x y) = Foo x
22:57:08 <lambdabot>  Defined.
22:57:10 <joneshf-laptop> yeah
22:57:11 <Axman6> hmm, bad idea
22:57:17 <Axman6> @let toFoo (Foo x y) = Foo x
22:57:18 <lambdabot>  Defined.
22:57:19 <joneshf-laptop> :t f
22:57:20 <lambdabot>     Ambiguous occurrence `f'
22:57:20 <lambdabot>     It could refer to either `L.f',
22:57:20 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:157:1
22:57:20 <Axman6> :t toFoo
22:57:21 <lambdabot> Foo x t -> y -> Foo x y
22:57:33 <enthropy> jle`: with gfoldl. Lemme make up an example
22:57:39 <jle`> yeah...but i'd hope there was a cleaner way
22:58:07 <ChongLi> a few more steps here and we're going to start resembling lenses :)
22:58:14 <Axman6> how is that not clean?
22:58:22 <Axman6> also yes, lenses
22:58:28 <Axman6> they solve everything
22:58:31 <Axman6> or so I've heard
22:58:42 <joneshf-laptop> jle`, what are you trying to do exactly?
22:58:52 <jle`> Axman6: well, i ahve to do it for every data type...and also it'd be nice if there was a point free version
22:59:08 <joneshf-laptop> @pl toFoo
22:59:08 <lambdabot> toFoo
22:59:10 <joneshf-laptop> erm
22:59:19 <ChongLi> there you go :)
22:59:24 <Axman6> @pl \(Foo x _) -> Foo x
22:59:24 <lambdabot> (line 1, column 7):
22:59:24 <joneshf-laptop> @pl  toFoo (Foo x y) = Foo x
22:59:24 <lambdabot> unexpected "x"
22:59:24 <lambdabot> expecting operator or ")"
22:59:24 <lambdabot> (line 1, column 18):
22:59:24 <lambdabot> unexpected " "
22:59:26 <lambdabot> expecting operator
22:59:36 <jle`> joneshf-laptop: well on a high level i am pulling out the last item and feeding it to an (Arrow r) => r y y, and then re-adding the Foo x at the end
22:59:50 <joneshf-laptop> ah
22:59:59 <jle`> so in this case it would be Foo 1 <$> (arrow on y)
23:00:06 <joneshf-laptop> jle`, so you want like a `last` arrow?
23:00:06 <jle`> acutally that isn't what i'm doing
23:00:11 <jle`> but yeah
23:00:16 <jle`> it's actually an arrow r () y
23:00:20 <jle`> but taking y as a parameter
23:00:24 <jle`> y -> r () y
23:01:20 <jle`> so if f :: Arrow r => y -> r () y
23:01:27 <jle`> i'm doing Foo 1 <$> f 2
23:01:38 <jle`> (from Foo 1 2)
23:01:58 <jle`> there might be a better way to do this...
23:04:35 <enthropy> jle`: http://lpaste.net/98753
23:06:29 <jle`> enthropy: thanks :)
23:07:35 * hackagebot zip-conduit 0.2.2.1 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2.2.1 (TimCherganov)
23:09:04 <jle`> i just realized...from the type sigature
23:09:15 <jle`> that this is exactly the same as replacing the last field
23:09:21 <jle`> with a given value
23:09:25 <Axman6> yes...
23:09:27 <jle`> Foo x y -> y -> Foo x y
23:09:36 <jle`> this sounds very lensy
23:09:40 <jle`> to me
23:10:05 <jle`> is there a lense to access the nth element of a data thing?
23:10:21 <Axman6> _1 .. _9 apparently
23:10:43 <jle`> whoa those work for more than just tuples?
23:10:53 <Axman6> which I believe you get for free when using the derived instances, but I'm not sure
23:11:47 <apples> it works for any IndexedLens, apparently
23:11:59 <apples> er no, i'm misreading
23:12:18 <Axman6> hmm. maybe I'm wrong
23:13:36 <jle`> according to http://hackage.haskell.org/package/data-lens-template-2.1.7/docs/Data-Lens-Template.html it doesn't make them automatically
23:13:58 <jle`> maybe i'm wrong
23:19:32 <Twey> If I write an inductively-defined instance like instance Foo (Vec n) ⇒ Foo (Vec (S n)) where … GHC will accept it, but it doesn't seem to understand that means I have an instance for an arbitrary Vec n.  If I remove the constraint, on the other hand, it won't accept it.  How can I have both?  ☺
23:48:57 <joe9> need some advice, please? http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Actions-CycleRecentWS.html in this module, the line "cycref l i = l !! (i `mod` length l)" is causing a 'divide by zero' error. I want to send a patch ensuring that it captures that error and prints a more easily trackable message.
23:49:10 <joe9> Any suggestions on how I can go about it, please?
23:49:22 <joe9> I can add a null list pattern match and add a error "..."
23:49:35 <joe9> but, not sure if that would be the recommended way.
23:50:56 <zRecursive> joe9: maybe #xmonad
23:51:34 <dottedmag> joe9: looks like it's a bug in a caller, not in cycref though.
23:51:35 <joe9> zRecursive: that channel is kinda slow. and it seemed to be a haskell question..
23:51:53 <Twey> joe9: You should definitely do that; it might be good to then add a case to the caller to check for that case, though, to avoid triggering it unnecessarily
23:51:54 <joe9>  module code: http://codepad.org/pkBy8tl7
23:52:10 <joe9> Twey: ok, thanks.
23:52:24 <Twey> Alternatively you can modify cycref to return Maybe a and check for Nothing in the caller
23:52:36 <Twey> Which is better but could be notationally awkward
23:52:39 * hackagebot cryptohash 0.11.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.2 (VincentHanquez)
23:54:09 <DigitalKiwi> where's MD3!? We must find it!
23:54:23 <DigitalKiwi> that cryptohash module
23:55:04 <DigitalKiwi> for that matter MD1 is also MIA
