00:07:46 <mikeplus64> @pl /rd rn rm -> (rd < 0 && rn >= 0 && rm >= 0) || (rd >= 0 && rn < 0 && rm < 0)
00:07:47 <lambdabot> (line 1, column 1):
00:07:47 <lambdabot> unexpected "/"
00:07:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:07:58 <mikeplus64> @pl \rd rn rm -> (rd < 0 && rn >= 0 && rm >= 0) || (rd >= 0 && rn < 0 && rm < 0)
00:07:58 <lambdabot> ap (ap . (liftM2 (||) .) . (. ((. (>= 0)) . (&&) . (>= 0))) . (.) . (&&) . (< 0)) ((. ((. (< 0)) . (&&) . (< 0))) . (.) . (&&) . (>= 0))
00:08:14 <ChongLi> wow
00:08:15 <ChongLi> haha
00:08:20 <ChongLi> not recommended
00:09:13 <mikeplus64> 100% more readable
00:10:40 <lispy> People who use @pl in production code deserve a raise!
00:11:10 <maxiepoo> @pl \x y -> y <*> pure x
00:11:10 <lambdabot> flip (<*>) . pure
00:13:00 <maxiepoo> :t flip id
00:13:01 <lambdabot> b -> (b -> c) -> c
00:13:16 <maxiepoo> :t flip
00:13:16 <lambdabot> (a -> b -> c) -> b -> a -> c
00:13:40 <maxiepoo> :t id
00:13:41 <lambdabot> a -> a
00:13:47 <maxiepoo> how does that work?
00:14:24 <maxiepoo> how can id be used as an (a -> b -> c)?
00:15:10 <ChongLi> > (fmap . fmap . fmap) toUpper [Just "foo"]
00:15:11 <lambdabot>  [Just "FOO"]
00:15:12 <ChongLi> I like this one
00:18:04 <yesthisisuser> I didn't know stuff like this worked with guards: http://lpaste.net/97951
00:18:42 <ChongLi> yeah, guards are part of pattern expressions
00:18:52 <ChongLi> anywhere you do a pattern match, you can use guards (afaik)
00:18:57 <lispy> maxiepoo: id :: a -> a, but a can be b -> c -> d if you like.
00:19:14 <yesthisisuser> ChongLi: yes but i thought i had to always include a | otherwise
00:19:24 <lispy> eg., id :: (b -> c -> d) -> b -> c -> d
00:19:34 <yesthisisuser> but ok, yes i see what you mean
00:19:39 <ChongLi> no, Haskell doesn't care if you write partial functions
00:20:07 <ChongLi> it will crash if you encounter an unmatched pattern at runtime
00:20:15 <Fuuzetsu> How's the state of GUI libraries in Haskell these days? I think I'll have to write myself a music player but I don't know whether I should strip my existing one down to bare bones (C++ with Qt) or whether to just write one
00:20:20 <Fuuzetsu> I think it'd be a good exercise anyway
00:20:28 <lispy> Fuuzetsu: well...
00:20:33 <Fuuzetsu> welp
00:21:04 <lispy> Fuuzetsu: you can use vty-ui for a console gui. Then there is gtk2hs (if you can manage to build it), and wx-haskell (probably easier to build).
00:21:51 <yesthisisuser> i would like to see a gui library with a more "pure" functional approach
00:22:07 <Fuuzetsu> lispy: Out of console for music player. I love me some TUIs but sometimes a guy has to see some graphics
00:22:07 <lispy> Fuuzetsu: you could do something crazy like use GLFW-b and then build a 'gui' library on top of opengl but that seems silly.
00:22:16 <ChongLi> yesthisisuser: netwire
00:22:17 <Fuuzetsu> That does seem silly.
00:22:24 <ChongLi> okay, it's not a gui library
00:22:32 <ChongLi> but it provides the pure functional part
00:22:43 <Fuuzetsu> ChongLi: Basically sorted, right?
00:22:46 <yesthisisuser> ChongLi: is that FRP?
00:22:51 <lispy> Fuuzetsu: if you really want a GUI, then I would try wx first and only if that doesn't work gtk2hs.
00:22:52 <ChongLi> netwire is FRP
00:22:55 <Fuuzetsu> @package netwire
00:22:56 <lambdabot> http://hackage.haskell.org/package/netwire
00:23:00 <yesthisisuser> i guess FRP is the way to go
00:23:08 <ChongLi> lispy: hey, don't laugh
00:23:09 <Fuuzetsu> lispy: I'll look at wx then.
00:23:26 <ChongLi> there are big time applications written in opengl like that
00:23:32 <ChongLi> Modo, for one
00:23:44 <Fuuzetsu> Never heard of it.
00:24:08 <lispy> ChongLi: never heard of it. I know you can do it and make it work, but it's weird :)
00:24:08 <ChongLi> polygon and subdivision surface modeling, sculpting, 3D painting, animation and rendering!
00:24:33 <ChongLi> lispy: it is weird, but if somebody put in the hard labour we could have a beautiful functional GUI
00:24:42 <ChongLi> and it'd be portable wherever OpenGL runs
00:25:10 <ChongLi> and in another sense, it's something game engine developers do
00:25:57 <Fuuzetsu> ChongLi: The problem is that no one capable has the cycles to spare for such a thing.
00:25:58 <lispy> ChongLi: IMO, we should make platform specific bindings first. Get those working and then build an abstraction (like wx) on top so that we can have cross platform stuff for those that want it.
00:26:12 <Fuuzetsu> And people less capable also are unlikely to have time to spare…
00:26:12 <randomclown> conduits vs pipes?
00:26:14 <mgsloan> Bottle (used by lamdu) uses opengl for UI: https://github.com/Peaker/lamdu/tree/master/bottlelib/Graphics/UI/Bottle
00:26:17 <ChongLi> Fuuzetsu: yeah, I'm just dreaming of some big company doing it
00:26:24 <ChongLi> and open sourcing it for us all to use :)
00:26:27 <mgsloan> It's kinda pretty, in its own way :D
00:26:45 <mgsloan> the code is certainly pretty
00:27:03 <Fuuzetsu> I'm unsure how well it'd fare for a music player, with you know, rows of stuff etc.
00:27:11 <Fuuzetsu> disclaimer: I haven't sude lamdu
00:27:13 <Fuuzetsu> used*
00:27:46 <ChongLi> Fuuzetsu: what sort of music player would you write?
00:28:00 <ChongLi> would you interface to something like mpd?
00:28:12 <ChongLi> or actually write your own MP3 codecs in Haskell
00:28:15 <mgsloan> It's pretty classic to use OpenGL for anything related to video game HUDs or 3d modelling, etc.  It's just plain less buggy than attempting to overlay native widgets on 3d
00:28:53 <ChongLi> well, video game HUDs is one thing
00:28:57 <mgsloan> (or DirectX of course)
00:28:58 <Fuuzetsu> ChongLi: I effectively want Clementine but without all the broken shit on top I genuinely don't care about and without 1189 open issues in my issue tracker because of them
00:29:10 <mgsloan> sure, but video game HUDs commonly have many of the same widgets as standard UIs
00:29:19 <ChongLi> but those 3D apps often have very extensive widget toolkits
00:29:23 <mgsloan> right
00:29:36 <Fuuzetsu> ChongLi: Not sure about the back-end. I might go with gstreamer like Clementine does and re-use their database (and logic)
00:29:38 <ChongLi> often enough to write any sort of app
00:29:52 <ChongLi> Fuuzetsu: mpd is a higher level abstraction than that
00:29:58 <mgsloan> Now, using 3d graphics for an IDE is a rather nonstandard choice, but one I highly approve of :D
00:30:16 <ChongLi> it handles the database, the playback, everything
00:30:35 <ChongLi> you just tell it what to do with a simple control API
00:30:44 <Fuuzetsu> ChongLi: The problem with mpd is that all my music is on a separate box and I'd have to stream. I think it's more responsive to mount my music and have the database locally. I actually tried mpd the other day and I wasn't too impressed…
00:30:58 <ChongLi> mgsloan: I wish NVidia's path rendering extension would become standard
00:31:08 <Fuuzetsu> I don't want to plug in my speakers to my file server before you suggest that.
00:31:13 <lispy> designing an IDE for something like the oculus rift would be interesting, but I'm highly skeptical anyone can pull it off.
00:31:28 <erisco> lispy, you want to wear that thing for hours on end?
00:31:29 <ChongLi> it would be really awesome to do all your GUI and font rendering with a GPU-accelerated vector graphics library
00:31:47 <lispy> erisco: so far no. I have one but I can only do about 15 minutes before I get sick :(
00:31:56 <ChongLi> https://www.youtube.com/watch?v=0IDyZof2pRI
00:32:00 <lispy> erisco: otherwise I'd probably just live in minecraft :)
00:32:12 <SrPx> OK I have a new task. I'm going to write some completely pure functions that manipulate arrays using Haskell, and I want to compile that to non-bloated JavaScript, taking advantage of GHC optimizations such as stream fusion. What is the best way Haskell->JS solution for this case?
00:32:31 <lispy> SrPx: ghcjs
00:32:35 <funfunctor> how do I lift a [Char] to a IO String again?
00:32:38 <mgsloan> lispy: Not anytime soon, I agree.  There's an interesting thread about this here: https://groups.google.com/forum/#!topic/augmented-programming/aKy84s5MZ18
00:32:42 <Fuuzetsu> funfunctor: return
00:32:51 <SrPx> lispy: thanks!
00:32:53 <lispy> SrPx: luite has done an amazing job with that backend
00:33:02 <NemesisD> ChongLi: so is #include still used anymore in recent ghc?
00:33:03 <ChongLi> funfunctor: return
00:33:27 <lispy> mgsloan: thanks. Link saved. I'll read it later.
00:33:50 <funfunctor> yea, i have something like this though, splitOn "," (readFile "..")
00:33:59 * lispy should probably crash soon
00:34:01 <ChongLi> NemesisD: on the haskell wiki, they use {-# INCLUDE <math.h> #-}
00:34:08 <SrPx> lispy: just to make it clear, it is the fastest then?
00:34:09 <Fuuzetsu> funfunctor: you probably want fmap then
00:34:10 <NemesisD> i think that might be deprecated
00:34:21 * SrPx could benchmark
00:34:23 <mgsloan> Hmm, while I agree that luite's done great work with ghcjs, I think haste also benefits from GHC optimizations, and maybe less bloated output?
00:34:23 <funfunctor> :t fmap
00:34:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:34:32 <Fuuzetsu> :t undefined :: (String -> a) `fmap` readFile "abc"
00:34:33 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): "abc"
00:34:34 <NemesisD> but it looks like i'm going to have to hint at ghc at where to look for the headers
00:34:40 <Fuuzetsu> :t (undefined :: String -> a) `fmap` readFile "abc"
00:34:40 <lambdabot> IO b
00:34:43 <lispy> SrPx: It's the most mature by leaps and bounds. There is Fay, but it supports only a *subset* of Haskell.
00:35:02 <lispy> mgsloan: I guess I'm not familiar with Haste.
00:35:15 <ChongLi> lispy: haste is pretty good
00:35:17 <SrPx> Which is that subset, and is it faster on it?
00:35:40 <ChongLi> Fay doesn't have type classes *yet*
00:35:41 <mgsloan> lispy: Me neither really.  I haven't done much Haskell->Js beyond Fay
00:35:49 <funfunctor> Fuuzetsu: thanks
00:35:54 <lispy> SrPx: I'm not Fay expert, but at one point I got the impression their experiment was more, "what if we had a Haskell-like language for JS?"
00:35:55 <funfunctor> looks werid though..
00:36:04 <ChongLi> haste has type classes and it can handle a lot of Haskell libraries out of the box
00:36:28 <lispy> I think ghcjs can compile itself?
00:36:29 <mgsloan> lispy: Right, it's kinda like "let's reuse GHC's typechecker, and use HSE as our parser", but it's a little bit of a different language
00:36:38 <SrPx> Listen, which of those use GHC most? Specifially I'd like stream fusion to work on my code
00:36:55 <roboguy_> funfunctor: it's worth getting some experience with that though. Functors are pretty useful and important in haskell
00:36:56 <lispy> ghcjs is just a backend for ghc. So it uses GHC extensively.
00:37:14 <ChongLi> SrPx: that may not always give you the best performance
00:37:19 <mgsloan> I don't think ghcjs can compile itself, but luite had a neat demo where he compiled fay using it
00:37:22 <SrPx> Interesting!
00:37:28 <ChongLi> doesn't ghcjs have a complicated runtime?
00:37:30 <Fuuzetsu> are the Hackage docs going to be fixed any time soon? A huge amount of documentation is missing for things, I basically had to click on an older version of a ton of stuff in recent months…
00:37:51 <mgsloan> ChongLi: Last time I checked, it does.
00:38:12 <lispy> Fuuzetsu: good question. I'm not sure. Maybe the hackage admins don't realize some packages are still broken.
00:38:15 <mgsloan> I think the ghcjs heyday is going to come after ghc 7.8.  My impression is that after that it's going to get a whole lot easier to install
00:38:27 <ChongLi> yeah, that's the other issue
00:38:28 * lispy -> bed
00:38:32 <ChongLi> haste is really easy to install
00:38:37 * Fuuzetsu -> #hackage to bitch
00:38:37 <ChongLi> as is fay
00:38:53 <mgsloan> Yup, it's funny how many practical options there are
00:39:21 <ChongLi> yeah, and people on reddit complain about how all Haskell users do is talk
00:39:23 <SrPx> (I can't understand GHCJS installation, though, I don't get vagrant... I guess I did everything correct but now I'm inside a VM without access to my files wat? lol)
00:39:26 <ChongLi> and that they're unproductive
00:39:52 <ChongLi> vagrant is a tool for running managing virtual machines
00:40:13 <SrPx> But seriously, with so many options has nobody done a bunch of benchmarks yet? For statistics, you know
00:40:26 <NemesisD>  ChongLi do you know how i'd be able to specify a header relative to the dir i'm in? i just keep getting linking errors
00:40:33 <ChongLi> SrPx: it's a moving target
00:40:39 <ChongLi> these things are under active development
00:41:32 <randomclown> Should I use conduits or pipes?
00:42:05 <ChongLi> NemesisD: did you specify your c code in extra-source-files ?
00:43:03 <NemesisD> ChongLi: i'm trying to do this without cabalizing first until i get the simplest possible thing working
00:44:28 <ChongLi> ahh, so you're just calling ghc foo.hs ?
00:45:06 <ChongLi> or did you write a makefile?
00:45:16 <NemesisD> just calling ghc
00:45:47 <NemesisD> it seems like somewhere i need to tell something where to find .h files
00:50:48 <ChongLi> NemesisD: no, you specify the .o file
00:50:59 <ChongLi> err
00:51:00 <ChongLi> here
00:51:08 <ChongLi> http://www.haskell.org/haskellwiki/FFI_Introduction#Compiling_FFI-using_modules
00:51:38 <ChongLi> it is broken, however :)
00:53:33 <NemesisD> ohhhhh
00:54:46 <Fuuzetsu> What are ‘Web 2.0 buttons’? I'm looking at some applications using wxWidgets and there's one that promotes website building and mentions this.
00:56:10 <ChongLi> Fuuzetsu: not sure
00:56:18 <ChongLi> evil facebook tracking buttons?
00:56:39 <Fuuzetsu> I'm sure it's something terrible because it's in the same sentence as ‘continuous text’…
00:56:49 <maxiepoo> hey we can't hate on facebook they use haskell
00:57:03 <NemesisD> ChongLi: http://lpaste.net/97952 seems like i need pthread?
00:57:27 <Fuuzetsu> maxiepoo: yes we can
00:57:34 <funfunctor> :t fmap (splitOn "," . filter (/= '\n')) read
00:57:35 <lambdabot> String -> [[Char]]
00:57:52 <funfunctor> how do I fix that up to read out an array of array of Int's?
00:58:11 <NemesisD> woah, things went crazy when i added -lpthread
00:58:18 <ChongLi> haha
00:58:46 <ChongLi> crazy how? printing garbage to STDOUT?
00:59:02 <Fuuzetsu> funfunctor: you want [[Int]]? So you want Char -> Int?
00:59:36 <Fuuzetsu> :t map read . splitOn "," . filter (/= '\n')
00:59:37 <lambdabot> Read b => [Char] -> [b]
00:59:54 <NemesisD> ChongLi: tons of undefined functions. i wonder if -Iphash-0.9.6/src/ is not additive and is losing my normal include dir?
00:59:54 <Fuuzetsu> hm
01:00:05 <Fuuzetsu> map (read :: Char -> Int) . splitOn "," . filter (/= '\n')
01:00:09 <Fuuzetsu> :t map (read :: Char -> Int) . splitOn "," . filter (/= '\n')
01:00:10 <lambdabot>     Couldn't match type `[Char]' with `Char'
01:00:10 <lambdabot>     Expected type: Char -> Int
01:00:10 <lambdabot>       Actual type: String -> Int
01:00:26 <roboguy_> Fuuzetsu: it sounds to me like he wants [Char] -> Int
01:00:32 <Fuuzetsu> funfunctor: you'll have to be more specific on what you want… perhaps a file and sample output?
01:00:38 <ChongLi> NemesisD: well, try adding -Ihs/src/dir
01:00:41 <Fuuzetsu> roboguy_: Yes, indeed, but he did say array of arrays
01:00:46 <roboguy_> hmm
01:00:51 <funfunctor> :t map (read :: Int) . splitOn "," . filter (/= '\n')
01:00:52 <lambdabot>     Couldn't match expected type `Int' with actual type `String -> a0'
01:00:52 <lambdabot>     In the first argument of `map', namely `(read :: Int)'
01:00:52 <lambdabot>     In the first argument of `(.)', namely `map (read :: Int)'
01:01:12 <NemesisD> ChongLi: well the src dir is correct, i mean the system includes
01:01:22 <Fuuzetsu> funfunctor: after split you'll get [String] so read has to be Read a => String -> a
01:01:26 <funfunctor> :t fmap (splitOn "," . filter (/= '\n')) (read :: Int)
01:01:27 <lambdabot>     Couldn't match expected type `Int' with actual type `String -> a0'
01:01:27 <lambdabot>     In the second argument of `fmap', namely `(read :: Int)'
01:01:27 <lambdabot>     In the expression:
01:01:33 <Fuuzetsu> :t map (read :: String -> Int) . splitOn "," . filter (/= '\n')
01:01:34 <lambdabot> [Char] -> [Int]
01:01:35 <roboguy_> funfunctor: how do you want to split it into an list of lists?
01:02:42 <Fuuzetsu> I think he's confused about fmap
01:02:50 <funfunctor> Fuuzetsu: solution works.. thanks
01:02:56 <funfunctor> :t fmap
01:02:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:02:59 <funfunctor> :t map
01:02:59 <lambdabot> (a -> b) -> [a] -> [b]
01:03:03 <SrPx> How do I get my own files into vagrant to compile them? Why can't I use GHCJS from my own machine? :/
01:03:08 <funfunctor> yea makes more sense now :)
01:03:18 <ChongLi> NemesisD: hmmmm
01:03:19 <roboguy_> funfunctor: map = fmap, but the type for map is restricted to just lists
01:03:27 <ChongLi> NemesisD: add them explicitly as well!
01:03:34 <ChongLi> just include everything!
01:09:35 <NemesisD> ChongLi: http://lpaste.net/97953
01:09:36 <NemesisD> i got the same thing when i did -I/usr/include -IpHash-0.9.6/src
01:09:36 <NemesisD> hmm, getting closer, got fewer errors when i added -lstdc++
01:12:27 <roboguy__> NemesisD: are you still getting errors about C++ stuff (like new, delete and catch)?
01:34:30 <erisco> no I think he meant "brain fuck" the expression, not the language
01:34:30 <erisco> more people! welcome
01:34:30 <onix> are they bot or real human :P
01:34:30 <mello> no functional programming might be brainfuck at first if you come from strictly imperative language
01:34:30 <mello> and i meant brain fuck as an expression not a language
01:34:38 <erisco> mostly idlers
01:34:38 <mello> wtf is happening?
01:34:46 <NemesisD> this is panemonium
01:34:57 <Twisol> A net split is healing
01:34:57 <ChongLi> oh no, did I just miss 23 minutes?
01:35:16 <ChongLi> netsplit?
01:35:34 <startling> SrPx: usually the directory around your Vagrantfile is mounted as /vagrant
01:35:37 <erisco> how long until we rejoin with the other half?
01:35:38 <NemesisD> i was listening to a ruby podcast today and they did an episode on functional programming
01:35:38 <erisco> how many nodes went down? this is quite the intense split
01:35:38 <NemesisD> unfortunately the guy was pretty ill informed and was peddling clojure i think
01:35:38 <NemesisD> he was arguing for a design pattern of all data basically being loosely structured hash maps
01:35:38 <ChongLi> NemesisD: how are things going?
01:35:47 <NemesisD> then saying that this approach makes things easier to reason about :(
01:36:08 <Twisol> It looks like the network split into multiple disconnected graphs...
01:36:10 <ChongLi> yeah, it makes maps easier to reason about
01:36:22 <ChongLi> and then you have your program to worry about
01:36:34 <erisco> welcome peoples! :)
01:37:10 <erisco> Twisol, I know... it must have been a big node that went down
01:38:07 <startling> NemesisD: ummmm
01:38:15 <startling> what even
01:39:33 <NemesisD> ChongLi: well it was a hell of a lot easier when i just ran make install on the shared library, but i don't know if thats the right thing to do IRL
01:39:49 <NemesisD> startling: it was pretty maddening
01:39:49 <ChongLi> NemesisD: oh, that's the right thing to do
01:39:58 <ChongLi> so now you've got a working binding?
01:40:08 <ChongLi> you can get phashes into haskell?
01:40:23 <NemesisD> startling: a meme seems to be going around in my circles that in FP it is a virtue to use primitive types for everything
01:41:00 <NemesisD> ChongLi: hehe not quite. it is failing to get me a result it seems
01:42:31 <NemesisD> ChongLi: actually oddly enough the code seems to say it returns -1 for failure, 1 for success but seems to be returning 0... :[
01:43:09 <ChongLi> hmmm
01:43:50 <NemesisD> YEP straight up lying
01:44:02 <ChongLi> the API doc lies?
01:44:25 <ChongLi> this is why error codes are so bad
01:44:29 <ChongLi> intly-typed programming
01:44:42 <ChongLi> this is why we use Haskell!
01:44:42 <NemesisD> https://github.com/sdepold/pHash/blob/master/src/pHash.h#L331
01:45:09 <NemesisD> https://github.com/sdepold/pHash/blob/master/src/pHash.cpp#L404
01:45:30 <ChongLi> hahahaha
01:46:39 <mello> hm
01:47:00 <mello> anyone got a good tutorial on bouncers/screens ? /offtopic
01:47:32 <NemesisD> man that library is slow, but it works!
01:48:27 <NemesisD> ChongLi: im not quite sure how installing the shared lib in the cabal package is the right thing, sinc that seems like it would require sudo access no?
01:49:33 <ChongLi> NemesisD: oh, you installed the lib to your system?
01:49:46 <ChongLi> you should be able to just build the lib and link to the build dir?
01:50:21 <NemesisD> ChongLi: oh, no i could not get that working
01:50:57 <NemesisD> ChongLi: i'm using -lpHash, but i don't know how i can get that to load from the build dir
01:51:27 <ChongLi> hmmm
01:52:04 <ChongLi> do you have an -L/path/to/lib in your ghc call?
01:53:23 <NemesisD> bingo!
01:53:38 <ChongLi> sweet
01:54:12 <NemesisD> so i should be able to run this in parallell since i'm not using unsafe ffi then right?
01:54:40 <NemesisD> the haskell side of ffi seems pretty damn slick
01:55:01 <ChongLi> NemesisD: yeah, as long as the C code isn't doing anything fun with global state
01:55:04 <ChongLi> and it seems not to be
01:56:43 <cuci> hi guys! I'm new to programming and I want to program this flow chart: http://img.medscape.com/article/710/517/710517-thumb1.png. How do I do that without making just a huge multi branched if?
01:56:54 <cuci> there must be a better way
01:57:48 --- mode: calvino.freenode.net set +o ChanServ
01:58:53 <NemesisD> ChongLi: im gonna go off to bed now. thanks so much for sharing your expertise on FFI. I would not have been able to get this far without your guidance
01:59:21 <ChongLi> NemesisD: glad to help :)
01:59:44 <NemesisD> hopefully i can release this as a library at some point. phash is pretty nifty
01:59:58 <NemesisD> we may be using it at work, altnough unfortunately via ruby and not haskell
02:00:32 <ChongLi> NemesisD: yikes
02:00:43 <ChongLi> now it makes sense why you'd want the filepath api
02:00:47 <ChongLi> rather than passing in raw data
02:00:58 <NemesisD> ?
02:01:11 <heyguys> hey guys. i am faced with question: how do you deal with big data in haskell? for example matrices or trees
02:01:13 <ChongLi> ruby is slow, generally
02:01:31 <ChongLi> heyguys: *big data*?
02:01:54 <heyguys> like matrices 500x500 that constantly needs to be changed
02:01:57 <NemesisD> ohh. i thought it was mainly just the devs of the c api not exposing a way to send in raw bytes. ruby is probably plenty fast at reading bytes off disk
02:02:05 <ChongLi> heyguys: ahh, that's not really big data :)
02:02:12 <NemesisD> but i think from the code it may be more complicated because it gets into CImg territory
02:02:14 <ChongLi> you probably want something like Repa for that
02:02:34 <heyguys> what about images?
02:02:39 <heyguys> 1920x1080
02:02:43 <ChongLi> Repa works fine with images
02:02:48 <ktosiek> how are images different?
02:03:07 <ChongLi> millions of elements is not big data, really
02:03:20 <heyguys> i haven't tested performance yet, but still a bit confused with this immutability thing
02:03:20 <ChongLi> big data is trillions of elements
02:03:58 <ChongLi> heyguys: Repa uses a model where you build up delayed computations
02:04:06 <ChongLi> and then they get fused into a tight loop
02:04:14 <ChongLi> and run in parallel (if you want)
02:05:01 <ChongLi> Repa provides high performance, regular, multi-dimensional, shape polymorphic parallel arrays. All numeric data is stored unboxed. Functions written with the Repa combinators are automatically parallel provided you supply +RTS -Nwhatever on the command line when running the program.
02:05:10 <cuci2> [#haskell] hi guys! I'm new to programming and I want to program this flow chart: http://img.medscape.com/article/710/517/710517-thumb1.png. How do I do that without making just a huge multi branched if?
02:06:05 <heyguys> i guess i have a lot to read
02:06:05 <NemesisD> lol cuci2 that's a real tiny image
02:06:07 <heyguys> thank you
02:06:11 <ChongLi> cuci2: data directed programming
02:06:16 <ChongLi> http://mitpress.mit.edu/sicp/full-text/sicp/book/node45.html
02:06:53 <cuci2> NemesisD: it's from here:http://www.medscape.org/viewarticle/710517_4
02:07:29 <cuci2> ChongLi: thanks!
02:08:00 <NemesisD> ChongLi: this is not haskell i am reading D:
02:08:08 <ChongLi> yeah, it's SICP
02:08:33 <ChongLi> I figured cuci was asking more of a functional programming question than a haskell-specific one
02:08:56 <ChongLi> but the principle of data-directed programming and dispatch applies to Haskell quite nicely
02:09:08 <cuci> a haskell tutorial would be nice
02:09:23 <NemesisD> ChongLi: so is the equivalent in haskell pattern matching and each dimension of the "table" is an arugment?
02:09:48 <NemesisD> i.e. chooseYourFate :: XAxisChoice -> YAxisChoice -> ???
02:09:50 <ChongLi> haskell pattern matching is the equivalent of ifs
02:10:09 <NemesisD> ok so this is not that?
02:10:14 <ChongLi> it's closed, in that you have to define all the patterns in one place
02:10:26 <ChongLi> type classes, on the other hand, are open
02:11:17 <ChongLi> you can write instances for a type class in many different places
02:11:31 <ChongLi> but type classes are not necessary for this
02:11:33 <NemesisD> hmm, im not sue how that would work the farther down this decision tree you got
02:12:00 <ChongLi> the other thing you can do is to write a little DSL
02:12:16 <ChongLi> or use one of the existing ones, such as list, Maybe or Either monads
02:13:07 <ChongLi> there's also free monads
02:13:23 <notadog> I am having trouble making a simple(I thought) program in haskell. When run it displays a smallish window with 9 buttons in a grid that each either launch the program they say, or read a new set of buttons from the file that is set as the label. I am new to haskell and this is my first program, and I have enjoyed myself immensely, however I cannot remove  the old signals from the buttons(using gtk2hs).
02:13:23 <ChongLi> tons and tons of ways to do this sort of decision-tree stuff
02:15:07 <notadog> I must misunderstand how IORefs work, or how gtk2hs works, but I am at a loss as to where to start. I have tried many ways to remove the old signals from the buttons but I can't find a solution. My code is here https://github.com/instantepiphany/qsrun/blob/testing/qsrun.hs
02:15:19 <NemesisD> my path down the free monad route is littered with failed projects
02:16:17 <cuci2> ChongLi: so are any of those ideas written in a haskell tutorial ? I fear my many syntax errors
02:16:41 <ChongLi> okay, I'm back
02:17:08 <notadog> To be clear, when I get the first lot of buttons up, everything is fine. I can run any command I could normally run in a terminal, by clicking on the appropriate button, and it works brilliantly. But lets say the command "urxvt -e vim" is on button 1. On button 2, is "anotherfile.txt", which when clicked changes button one's label to "chromium". If I then click button 1, both "urxvt -e vim" and "chromium"
02:17:10 <notadog> will be executed.
02:17:11 <ChongLi> cuci2: how far have you gotten in a haskell tutorial?
02:17:32 <cuci> ChongLi: here http://learnyouahaskell.com/functors-applicative-functors-and-monoids
02:17:49 <heyguys> one more question about *big data* :) will this work efficient on full hd image-sized matrices? deleteRow i m = (λ(x, y:z) → x ++ z) $ splitAt i m
02:17:55 <ChongLi> cuci: ahhh, yeah
02:18:11 <ChongLi> you may want to reach a higher comfort level with that stuff
02:18:21 <ChongLi> those are crucial to idiomatic haskell
02:18:30 <cuci2> I find it very hard to follow a tutorial/book without having a project to work on
02:18:44 <valdyn> heyguys: you know that ++ does not scale up
02:19:06 <ChongLi> ++ is list concatenation
02:19:24 <heyguys> what do you mean doesn't scale up?
02:19:41 <valdyn> heyguys: its slow for large lists
02:20:08 <notadog> unless you are only appending things to the start of the list, or is that incorrect?
02:20:10 <heyguys> thats sad. so is there a solution then?
02:20:10 <ChongLi> the algorithm has to traverse one of the lists completely
02:20:22 <ChongLi> so that it can begin consing onto the other list
02:20:30 <valdyn> heyguys: use a better suited data structure
02:20:38 <NemesisD> i think sequences have better performance
02:21:21 <ChongLi> for large matrices (megapixel images) you probably want Repa
02:21:23 <NemesisD> also if you're only doing appends, revlists are pretty simple and should be O(N) on insert
02:21:29 <NemesisD> erm O(1)
02:21:59 <NemesisD> revlist is pretty clever, just a newtype over list that reverses the list when you convert it to a list, IIRC
02:23:04 <NightRa> Hello everyone!
02:23:10 <NightRa> I found an issue
02:23:10 <heyguys> i'm actually not dealing with images, but with clustering problem and thus i need matrices
02:23:13 <Cale> The standard trick to get fast concatenation is to replace [a] with [a] -> [a], (++) with (.), [] with id, and [x] with (x:)
02:23:14 <ChongLi> NightRa: related to WhiteRa?
02:23:23 <Cale> and then apply the resulting function to [] at the end
02:23:35 <ChongLi> special tactics!
02:23:42 <NightRa> Hehe. I chose the name when I was a fan of Starcraft and WhiteRa. So yeah
02:23:44 <heyguys> Cale: do you have some more info on that?
02:23:49 <NightRa> In Data.List,
02:23:51 <Cale> heyguys: sure
02:23:58 <NightRa> transpose . transpose \= id
02:24:03 <NightRa> When it should be
02:24:10 <NightRa> for [[]]
02:24:10 <Cale> NightRa: No it shouldn't ;)
02:24:14 <NightRa> Why not?
02:25:13 <ChongLi> NightRa: because all Haskell types have this nasty little bugger called bottom
02:25:14 <Cale> Well, transpose compresses lists of ragged shape
02:25:24 <Cale> no, it's more basic a reason than that
02:25:52 <Cale> > transpose . transpose $ [[1],[2,3],[4,5,6]]
02:25:53 <lambdabot>  [[1,3,6],[2,5],[4]]
02:26:20 <ChongLi> ahhh
02:26:26 <Cale> The list of lists produced by transpose . transpose will never contain an empty list, and will always be in weakly descending order of length
02:26:45 <NightRa> Heh. Weird
02:27:21 <ChongLi> yeah so if you want a proper transpose, you need to type-check the matrix to ensure that it's rectangular?
02:27:34 <heyguys> https://hackage.haskell.org/package/matrix
02:27:42 <heyguys> what do you think about this lib btw?
02:27:58 <ChongLi> it's relatively new
02:28:24 <ChongLi> only 21 commits
02:29:12 <Cale> Oh, I was going to explain that list trick
02:29:21 <NightRa> ?
02:29:23 <heyguys> i'm still waiting :)
02:29:39 <Cale> So, the idea is that since xs ++ ys takes O(length xs) steps to fully compute
02:29:41 <ChongLi> heyguys: that's all I think of it, really
02:29:43 <ChongLi> I haven't used it
02:30:03 <Cale> We'll instead work with functions that add elements to the beginning of a list
02:30:13 <Cale> and then concatenation will become function composition
02:30:21 <Cale> (.) only takes one step to evaluate
02:30:34 <ChongLi> isn't that trading space for time?
02:30:36 <Cale> So we can concatenate these in constant time
02:30:41 <Cale> Not really
02:31:02 <Cale> The functions are about as large as the lists would be
02:31:22 <ChongLi> but what if you don't need the whole list? :)
02:31:24 <Cale> So for example, consider something like:
02:31:37 <ChongLi> I guess you don't want to be concatting them then
02:31:45 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
02:31:53 <Cale> inorder Tip = []
02:31:58 <ChongLi> or at least, the list you want to keep lazy should be the second one
02:32:04 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
02:32:15 <ChongLi> unevaluated, rather
02:32:17 <heyguys> well for now i'm using [[a]] as a type and seems to me i wouldnt be able to handle [a]->[a]
02:32:22 <Cale> This has the problem that on left-leaning trees, it ends up being quadratic time complexity
02:32:34 <Cale> So let's fix that:
02:32:38 <Cale> inorder' Tip = id
02:32:43 <ktosiek> and you don't have to build the whole function at a time, it will get built as you try to use elements from the list
02:32:51 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
02:33:10 <Cale> and now to get an equivalent to the original inorder, we apply the result to an empty list:
02:33:15 <Cale> inorder t = inorder' t []
02:33:20 <ChongLi> that's really nice
02:33:21 <Cale> and now it's linear time
02:33:42 <heyguys> hmm
02:33:52 <ChongLi> but this is all besides the point
02:34:10 <ChongLi> you don't want to represent multi-megapixel images as lists of Ints anyway, do you?
02:34:20 <ChongLi> not unless you're crazy!
02:34:21 <Cale> Oh, well, I didn't see the original problem :)
02:34:30 <Cale> But yeah, probably not!
02:34:31 <ChongLi> ahh, yeah
02:34:32 <heyguys> thats not really an images. its more like distance maps
02:34:36 <heyguys> so its [[Float]]
02:34:37 <heyguys> :)
02:35:00 <ChongLi> yeah, go with repa :)
02:35:00 <Cale> However, I once used this trick on a program which manipulated large ByteStrings
02:35:12 <ChongLi> you probably won't be disappointed with its speed
02:35:39 <ChongLi> Cale: isn't repa doing a more sophisticated version of this trick?
02:35:42 <Cale> and the program magically went from taking half an hour and around a gigabyte of memory to process our data down to about 16 megabytes and around a minute
02:35:58 <ChongLi> it has explicit delayed and manifest representations
02:36:22 <Cale> I'd applied it without even attempting to understand what the actual performance problem was, and it worked well enough that I didn't actually have to :)
02:36:37 <ChongLi> yeah
02:36:48 <Cale> Repa does lots of stuff, but I don't know if it does anything *quite* like this
02:36:58 <ChongLi> people often say that to fix a slow/leaky haskell program you need to add strictness
02:37:03 <Cale> Well, perhaps the delayed representations are kind of like this
02:37:04 <ChongLi> but sometimes you actually want more laziness
02:37:05 <Fuuzetsu> there's nothing *quite* like Cale's tricks ;)
02:37:39 <heyguys> i'm actually going to try this
02:39:32 <ChongLi> heyguys: if you're really serious about performance, use fromFunction rather than fromList
03:08:54 <bernalex> I have three functions i, j, k, that are a -> b -> b. f = do i; j; k;. how do I write f without dos?
03:10:10 <philed> What's f supposed to do?
03:10:45 <Polarina> What's dos?
03:10:46 <bernalex> philed: i, j and k. i, j and k are rules. http://jaspervdj.be/hakyll/reference/Hakyll-Core-Rules.html#t:Rules
03:10:53 <bernalex> Polarina: "do"s.
03:11:41 <bernalex> philed: i, j and k do http://jaspervdj.be/hakyll/reference/Hakyll-Core-Rules.html#v:match -- so they all return Rules (). then I have a function that takes Rules (), so f makes a Rules () of all the matches.
03:11:55 <bernalex> if you're still confused I can paste the code, if desirable.
03:12:19 <philed> Cheers.
03:13:05 <philed> Do you just mean you want something like f = i >> j >> k or f = sequence [i,j,k]?
03:13:15 <bernalex> philed: here's an example http://lpaste.net/2201666799332753408
03:13:26 <bernalex> philed: how do I write matchSites without "do"s?
03:14:47 <merijn> bernalex: You can write it using >>, but the entire reason for rules being in a monad is to conveniently use do notation
03:15:40 <bernalex> merijn: ah. thanks. I just wanted to see how.
03:16:01 <bernalex> merijn: further, I find that do sort of encourages bad taste in me. I end up with longer functions than I normally would.
03:20:58 <fikusz> are there any alternatives to IntMap from containers?
03:23:21 <ifesdjeen> is it any possible to perform IO (print to stdout) within State monad?
03:24:48 <philed> ifesdjeen: Not safely.
03:25:03 <ifesdjeen> philed: with unsafePerformIO?..
03:25:28 <philed> ifesdjeen: Yeah, but you can use that anywhere, so I assume you don't want that.
03:25:54 <ifesdjeen> philed: hm... what would be an alternative?
03:26:03 <ifesdjeen> philed: to use IO monad only?
03:26:13 <philed> Is it for debugging?
03:27:00 <Kaidelong> there is Debug.Trace if you want that perhaps
03:27:06 <Kaidelong> or whatever it was called
03:27:08 <ifesdjeen> philed: mostly, I'm implementing a lisp interpreter in haskell
03:27:27 <ifesdjeen> and need to add an stdout output
03:27:38 <Kaidelong> unsafePerformIO is okay if the result is indistinguishable from a pure function
03:27:42 <ifesdjeen> ok
03:27:47 <ifesdjeen> thanks Kaidelong
03:27:57 <ifesdjeen> thanks philed!
03:28:25 <Kaidelong> that implies that you do not care when, or if, the IO is actually done, too
03:28:42 <ifesdjeen> Kaidelong: that's also quite true
03:29:21 <philed> ifesdjeen: I'd just stick the evaluator in IO.
03:29:41 <fikusz> hm, IntMap seems to have linear lookup while the more generic Map has a logarithmic one... any ideas why that is?
03:29:42 <ifesdjeen> philed: i just rewrote an entire interpreter to state monad :)
03:29:43 <ktosiek> or free monad!
03:30:07 <Kaidelong> ifesdjeen: why not give it its own data structure that is an instance of MonadIO?
03:30:22 <ifesdjeen> Kaidelong: could you elaborate a bit?..
03:30:35 <ifesdjeen> Kaidelong: sounds like a good idea but i'm not totally familiar with what you mean
03:31:21 <Kaidelong> it allows you to tag IO values with extra information, you need to define a method liftIO
03:31:30 <Kaidelong> liftIO :: IO a -> m a
03:31:38 <alpounet> fikusz: IntMap's lookup is in min(n, W)
03:31:42 <Kaidelong> where m is your MonadIO instance
03:32:10 <fikusz> alpounet: isn't that basically linear with an upper bound?
03:32:30 <alpounet> fikusz: that upper bound is pretty damn low
03:32:58 <Kaidelong> http://hackage.haskell.org/package/monadIO-0.10.1.3
03:32:59 <fikusz> alpounet: oh, it's only 32/64? that's great!
03:33:33 <Kaidelong> I believe MonadIO was made for Orc, which is a kind of concurrent IO monad
03:33:40 <Kaidelong> but it is useful for lots of things
03:33:47 <Kaidelong> also simple
03:34:04 <merijn> Kaidelong: You forgot an important point, not only does it imply you don't care where/if the IO gets done, it also implies you don't care if it gets done 10 times
03:34:10 <philed> ifesdjeen: To save on editing, you can code against your own monad. To begin with, you could just have a type alias for State.
03:34:26 <alpounet> fikusz: yep! Really, depending on the use case at hand, map, hashmap and intmap can be candidates
03:34:29 <merijn> Kaidelong: monadIO was made for transformer stacks with IO at the bottom...
03:34:54 <philed> ifesdjeen: State itself is pretty generic. get, put and modify work on arbitrary monads which implement the MonadState class.
03:35:11 <fikusz> alpounet: I'm currently nesting intmaps 2-deep (I do a lookup on the result of the first lookup to get my final value)
03:35:45 <Kaidelong> merijn: for magic of inferring MonadIO out of MonadTrans?
03:35:49 <fikusz> alpounet: I'm just wondering if I would do better with Map (Int, Int) Result
03:36:02 <merijn> Kaidelong: Yes
03:36:14 <vektor> can't wrap my head around functors. So if I'm getting this right, functor is a very abstract typeclass, and all there is to it is "class Functor f where fmap :: (a -> b) -> f a -> f b", so what do we have? a functor must implement a fmap function, which maps from one type of itself to another via a mapping function. Correct? So basically, every data structure that contains only instances of...
03:36:16 <vektor> ...the same type (so lists - yep; Tuples - nope) could be a functor.
03:36:42 <merijn> vektor: Tuples can be functors, but you can only change *one* of the types
03:37:00 <merijn> vektor: You can think of "(a,b)" as being syntactic sugar for "(,) a b"
03:37:10 <merijn> vektor: Which means the partially applied "(,) a" can be a functor
03:37:17 <merijn> And, in fact, it is
03:37:26 <merijn> > fmap (+1) ('a',1)
03:37:28 <lambdabot>  ('a',2)
03:37:50 <merijn> > fmap odd ('a',1)
03:37:52 <lambdabot>  ('a',True)
03:37:54 <Kaidelong> merijn: although that's important, if doing the IO 0 times can lead to different results than doing it a hundred times, then you kind of violated the notion that your function is indistinguishable from a pure one anyway, haven't you?
03:38:15 <merijn> Kaidelong: Well, yes, that's kinda the danger of unsafePerformIO :)
03:38:55 <merijn> vektor: And actually, Functor can even work on things that can't really be said to "contain" something
03:39:01 <merijn> vektor: For example, functions are functors
03:39:17 <Kaidelong> merijn: but functions are key-value maps
03:39:25 <philed> A more pressing danger of unsafePerformIO is the ability to trivially write segfaulting code.
03:39:36 <merijn> vektor: Just like "(a,b)" can be seen as "(,) a b", "a -> b" can be seen as "(->) a b"
03:39:44 <Kaidelong> so they can be seen as containing something
03:39:53 <merijn> Kaidelong: Yes, no, maybe. But it helps to kill the notion of containing things
03:40:03 <vektor> whoops, system just went down. Can I have a paste of what happened since my last msg?
03:40:32 <Kaidelong> )
03:40:32 <Kaidelong> [03:34] <merijn> vektor: And actually, Functor can even work on things that can't really be said to "contain" something
03:40:43 <merijn> vektor: http://lpaste.net/97955
03:41:54 <vektor> thanks
03:41:57 <merijn> So if we look at "fmap" for functions, we have "instance Functor ((->) e) where fmap :: (a -> b) -> ((->) e a) -> ((->) e b)"
03:42:35 <merijn> If we write that more conventionally, you get: "(a -> b) -> (e -> a) -> (e -> b)", which is...function composition!
03:42:55 <merijn> > fmap (+1) (+3) $ 0
03:42:56 <lambdabot>  4
03:43:23 <Kaidelong> (->) is also a good example because it's also a contravariant functor if you flip its arguments
03:43:51 <Kaidelong> probably the best functor to use to explain covariance and contravariance
03:44:27 <merijn> vektor: So basically Functor is the incredibly generic notion of "want to change the type argument of a type"
03:45:21 <vektor> damn, mindblow. I can't even.
03:45:43 <merijn> Consider also "Either e a" which has the functor instance "Either e", so "fmap :: (a -> b) -> Either e a -> Either e b"
03:45:50 <merijn> > fmap (+1) (Left True)
03:45:51 <lambdabot>  Left True
03:45:56 <merijn> > fmap (+1) (Right 5))
03:45:57 <lambdabot>  <hint>:1:20: parse error on input `)'
03:46:00 <merijn> > fmap (+1) (Right 5)
03:46:01 <lambdabot>  Right 6
03:46:34 <vektor> is there some way to flip the type arguments?
03:46:35 <mangaba_leitosa> @let foo = (+1)::((->) Int) Int
03:46:36 <lambdabot>  Defined.
03:46:38 <mangaba_leitosa> > foo 10
03:46:39 <lambdabot>  mueval-core: expectJust cpeBody:collect_args
03:46:44 <vektor> i.e. have fmap use the left value?
03:46:44 <mangaba_leitosa> what does this error mean?
03:46:54 <merijn> vektor: In haskell that's a bit difficult, you would usually use a newtype for that
03:47:00 <Kaidelong> a precise way of saying it is that haskell functors map haskell functions to haskell functions on the type with the functor instance
03:47:30 <Kaidelong> the overall structure has to map 1 to 1, which is what the functor laws ensure
03:47:34 <merijn> vektor: So "newtype FlippedEither e a = Flipped (Either a e)" and then implement a custom typeclass for that newtype
03:47:36 <mangaba_leitosa> is 'mueval-core: expectJust cpeBody:collect_args' even a sensical error message?
03:48:06 <Kaidelong> fmap a . fmap b can't be different from fmap (a . b)
03:48:38 <vektor> merjin: or, if possible, just use a the arguments in flipped order, since with Either it doesn't really matter.
03:48:47 <Kaidelong> (a contravariant functor does exactly the same thing except all the functions end up in reversed directions)
03:48:51 <merijn> vektor: Incidentally, there's the notion of a "Bifunctor" which has "bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a b -> f c d"
03:49:41 <merijn> vektor: Yes, you'd usually pick your "either" order to be convenient. Which is why usually right is "result" and left is "error", you can fmap over the result and get a propagating error :)
03:50:09 <merijn> Bifunctor is not in the base libraries, though. There's a package on Hackage for them
03:50:43 <merijn> vektor: In essence, the reason why functor, applicative and monad usage is so widespread in haskell is because people figured out these thigns are *really* flexible and generic interfaces
03:50:57 <vektor> In case Maybe isn't expressive enough, huh?
03:51:25 <merijn> vektor: Yes, for example if you want to have verbose error reporting. Something like "Either String a" is common, where String is the error message
03:53:55 <vektor> I should probably put a log of this convo under my pillow :D
03:54:19 <donri> of course, String is *too* expressive ;)
03:54:57 <Kaidelong> Profunctor is pretty useful
03:56:49 <vektor> well, using String in this place doesn't seem to be a problem to me. Of course, you can encode errors more performant as ints. But since I guess the error won't even be evaluated unless it occurs, it's no problem, huh?
03:57:59 <mangaba_leitosa> superperformant errors!
03:59:02 <merijn> vektor: His point was that "String" doesn't tell you which errors can occur
03:59:06 <mangaba_leitosa> and 'mueval-core: expectJust cpeBody:collect_args' is a superexpressive, but poorly performant, string error
03:59:31 <merijn> vektor: As opposed to "data MyErrors = FileNotFound | ConnectionTimeOut" and using "Either MyErrors a"
03:59:33 <vektor> ahh.
04:00:12 <vektor> magaba_leitose: Well, since you're taking this so lightly, I assume you have never seen a java coder handle "element not found in container" with a try-catch block? That shit is awful.
04:00:46 <vektor> try-catch all the things :D
04:00:55 <mangaba_leitosa> vektor: java errors also have a stack strace that never fits on the screen :-)
04:01:09 <vektor> which makes it even worse
04:01:25 <vektor> all that stack trace needs processing when unwinding the error in try-catch.
04:03:00 <merijn> mangaba_leitosa: mueval is the library used for haskell evaluation, so "mueval-core:" sounds like the interpreter is crashing
04:05:42 <mangaba_leitosa> merijn: if I try it in ghci, the prefix 'muevel' goes away, but the rest stays the same :-)
04:06:00 * hackagebot hsimport 0.2.6.2 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.2 (DanielTrstenjak)
04:06:17 <mangaba_leitosa> ghci> let f::((->) Int) Int; f = (+ 1)
04:06:17 <mangaba_leitosa> ghci> f 10
04:06:17 <mangaba_leitosa> *** Exception: expectJust cpeBody:collect_args
04:06:36 <merijn> mangaba_leitosa: ghci doesn't use mueval, afaik
04:06:51 <mangaba_leitosa> merijn: right. But any idea about what this error means?
04:07:01 <merijn> mangaba_leitosa: Which version of ghc?
04:07:04 <merijn> It works fine here
04:07:10 <mangaba_leitosa> merijn: it's too "expressive" for me to understand :-)
04:07:23 <mangaba_leitosa> merijn: it works the same in lambdabot
04:07:34 <mangaba_leitosa> @let f::((->) Int) Int; f = (+ 1)
04:07:36 <lambdabot>  Defined.
04:07:38 <mangaba_leitosa> > f 10
04:07:39 <lambdabot>  Ambiguous occurrence `f'
04:07:39 <lambdabot>  It could refer to either `L.f', defined at L.hs:147:1
04:07:39 <lambdabot>                        or `Debug.SimpleReflect.Vars.f',
04:07:39 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
04:07:39 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
04:07:44 <mangaba_leitosa> oops :-(
04:07:48 <mangaba_leitosa> > f666 10
04:07:49 <lambdabot>  Not in scope: `f666'
04:07:52 <mangaba_leitosa> @let f666::((->) Int) Int; f = (+ 1)
04:07:53 <lambdabot>  .L.hs:149:1:
04:07:53 <lambdabot>      The type signature for `f666' lacks an accompanying binding
04:07:53 <lambdabot>  
04:07:53 <lambdabot>  .L.hs:150:1:
04:07:53 <lambdabot>      Multiple declarations of `f'
04:08:07 <mangaba_leitosa> @let f666::((->) Int) Int; f666 = (+ 1)
04:08:08 <lambdabot>  Defined.
04:08:11 <mangaba_leitosa> > f666 10
04:08:12 <lambdabot>  mueval-core: expectJust cpeBody:collect_args
04:08:21 <mangaba_leitosa> sorry for flood :-(
04:08:31 <mangaba_leitosa> merijn: ghc 7.6.3
04:08:43 <mangaba_leitosa> merijn: and not sure about lambdabot's ghc version, but the error is the same
04:08:51 <merijn> Looks like a bug
04:11:09 <mangaba_leitosa> merijn: 'f::((->) Int) Int' must have the same effect as 'f::Int -> Int', is that correct?
04:11:32 <mangaba_leitosa> merijn: I just tried to play with (->) and stumpled upon this :_)
04:11:52 <merijn> mangaba_leitosa: It should, yeah
04:19:52 <rioch> In OO languages, I create objects from nouns and operations from verbs (roughly). Is there an equivalent way of thinking in haskell? My broader question is: I want to write an app in haskell, where do I start? :)
04:20:41 <vektor> rioch: you read through learn you a haskell already?
04:20:53 <Kaidelong> you can take a language oriented approach and start by writing some of the application in some mock language that would be ideal for writing the application in
04:21:14 <merijn> rioch: I'm a firm believer in Linus' notion that you should first design the data your program will work on and then the operations you'd like to perform on that data
04:21:16 <rioch> vektor: I'm about halfway through. It's a lot of new terms, and I want to start using it, before I'm overwhelmed.
04:21:26 <vektor> rioch: same here.
04:22:01 <vektor> Though I must admit I got quite overwhelmed as well by the yet-unknown concepts I have to apply to get where I wanna get.
04:22:02 <philed> I just type random junk to a terminal until something type-checks, and then declare mission accomplished.
04:22:04 <Kaidelong> then you try to eke something out of haskell that resembles that language using haskell's own syntax
04:22:11 <vektor> philed: lol
04:22:37 <Kaidelong> and then you implement the data types that define the concepts in your target language
04:23:03 <Kaidelong> I am probably not explaining that too well, but it seems to be the kind of thing the ML languages were designed to do
04:23:07 <merijn> rioch, vektor: tbh, it'll be hard not being overwhelmed. My approach (I'm not saying you should necessarily follow it) was to just keep reading the entire thing (even if I didn't get the latter bits entirely) and then go back to where I lost track and start exploring from there
04:23:40 <merijn> rioch, vektor: The advantage is that finishing LYAH first gives you some context/bigger picture for the bits at the start, even if you don't understand the bigger picture quite yet
04:24:17 <vektor> for me, the approach usually is to explore what data I need for a specific task, and what data should pop out. THen I define any data structures I need, write a function header, and start from there. If I see I need subfunctions, I put them on a mental wishlist
04:24:21 <merijn> rioch, vektor: Which means that when you go back to go over it again in detail, you can figure out how the details fit in that big picture)
04:24:36 <rioch> merijn: I suppose patience is also an issue. I'm excited and want to code
04:24:53 <aristid> rioch: do you have ghci installed?
04:25:03 <catalyst> <philed> I just type random junk to a terminal until something type-checks, and then declare mission accomplished. <-- it's a lot like Perl, except with rules
04:25:28 <vektor> rioch: maybe you could try coding up some of the tasks in project euler. That's a very low level, but it at least gets you familiar with the basic concepts
04:25:29 <Kaidelong> also a much more ancient use of functional programming was a kind of process for designing software where you worked by breaking down your objectives into mathematical functions so that you can use algebra to simplify your idea as much as possible before you start writing all the FORTRAN you will implement it in, for some kinds of applications, I've used that and gotten things working
04:25:49 <Kaidelong> of the term functional programming*
04:27:19 <merijn> vektor: I actually kinda dislike project euler, the problems are focussed on number theory and not actual programming problems and the solutions by other haskellers frequently use mystifyingly complex tricks to code golf it
04:27:24 <merijn> @where exercises
04:27:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
04:27:28 <vektor> merijn: I've started working on some crazy genetic AI kinda thing. I'm not understanding all the GHC magic that I need (a friend is coding that stuff for me, thankfully) and I have occasionally just pasted code I found via google or was given here. But mostly, it's great fun, and I'm grasping more and more of the code I didn't understand back then.
04:27:34 <Kaidelong> the approach I use is generally to define the "goal" code first and work back from it to the implementation
04:27:34 <merijn> Those have more programming type exercises
04:28:50 <Komier> The programming challenges on reddit are quite fun.
04:29:02 <Komier> they feel more practical than just doing Euler.
04:29:31 <Kaidelong> IE if you want to describe a zip file with a certain structure you need to generate you say something like "data ModZip = ModZip Images XML" and then you define the types Images and XML and you work your way down
04:29:31 <vektor> merijn: I'd describe my AI thing as a algorithm midway between a gödel machine and a genetic algorithm. And it's meant to be put into an Artificial Life scenario.
04:29:38 <merijn> I've been looking for more sources for exercises, but I haven't found many
04:29:45 <Kaidelong> and as you define your data structures you can write fucntions that relate them
04:30:16 <merijn> vektor: I'm not very familiar (that's code for: never heard of) gödel machines, so no clue what that'd look like :p
04:30:29 <rioch> The 99 exercises looks good. Thanks.
04:30:35 <Kaidelong> (and the functions themselves can expose other requirements working down to fundamentals as they call functions on the component data structures that don't exist yet)
04:30:57 <Lethalman_> rioch, take something small you've written in another language and rewrite it in haskell
04:31:12 <merijn> rioch: They're a bit overly list focussed, but for complete beginner level they're nice :)
04:31:16 <vektor> gödel machines are machines that basically are a problem solver, and a self-rewriter. The self-rewriter implements the gödel machine all new, but only if it can prove that it will be advantageous.
04:31:32 <Kaidelong> oh is he looking for simple projects to do to learn the language?
04:31:59 <merijn> Lethalman_: tbh, I feel that reimlementing a previous project in haskell without having finished all of LYAH might be frustratingly hard
04:32:11 <Lethalman_> after finishing lyah :S
04:32:39 <merijn> Lethalman_: Sure, but he wanted something he could start with now :p
04:32:39 <Kaidelong> "shell scripting" and automation works well for that, use haskell to do things like batch renaming
04:33:12 <Kaidelong> they're generally simple and they illustrate thinking about IO haskell style, especially about functions like sequence
04:33:15 <Kaidelong> @ty sequence
04:33:15 <lambdabot> Monad m => [m a] -> m [a]
04:33:26 <Komier> I understand the feeling to be honest.  LYAH throws an awful lot of terms and new concepts at you, and functions from the standard library etc.  There is definitely a temptation to do something interesting to try and cement what you have already learned.
04:34:05 <Kaidelong> I've found LYAH more useful as a reference than as a tutorial honestly
04:34:19 <Kaidelong> I think it is right to be using it concurrently with writing actual code
04:34:33 <merijn> Komier: I think that's actually one of the main humps to get to writing practical code. There's an awful lot of "new" things you need to know to write anything remotely useful/resembling idiomatic haskell
04:38:27 <Komier> I agree merijn.  I'm new to programming itself as well, so I'm hitting quite a few walls.  But it's still interesting so it keeps me motivated.  Just saying I can understand the temptation to want to put LYAH to one side and try and write something.
04:38:56 <Komier> Must be worse for people who can already program in other languages.
04:39:24 <Kaidelong> I don't understand why such temptation should be resisted
04:39:44 <Kaidelong> sure you may get stuck but then you better understand the motivation for the examples in LYAH
04:40:00 <Cale> Yeah, if there's something you want to write, go ahead and make an attempt at it. If nothing else, you'll learn what it is you need to learn :)
04:40:53 <awestroke> how is $! implemented?
04:41:18 <donri> @src ($!)
04:41:18 <lambdabot> f $! x = x `seq` f x
04:42:12 <xxx-man> Cale: hi
04:42:18 <Komier> I don really resist it as such Kaidelong, just hit walls very frequently :D
04:42:26 <Kaidelong> @src seq
04:42:27 <lambdabot> Source not found. My mind is going. I can feel it.
04:42:27 <Cale> seq is an unimplementable primitive, but for specific types it could be implemented by pattern matching on its first argument before producing its second
04:42:51 <Kaidelong> seq !x = x   ??
04:42:55 <rioch> Is there a coding standard for haskell (like pep8 for python)?
04:43:19 <Cale> Oh, you could implement seq in terms of bang patterns as seq !x y = y
04:43:26 <Cale> But it's actually the other way around
04:43:28 <kqr> rioch, not that i know of
04:43:38 <Kaidelong> bang patterns use seq?
04:43:40 <kqr> rioch, but you can look at the sources of known good libraries and get a hint
04:43:42 <Cale> yes
04:43:42 <Kaidelong> you mean?
04:43:53 <xxx-man> Cale: hi
04:43:54 <Kaidelong> is seq standard haskell?
04:43:57 <Cale> yes
04:43:58 <Kaidelong> I'd imagine it is
04:44:22 <Cale> The actual specification in the Report is that seq _|_ y = _|_ and seq x y = y otherwise
04:44:23 <Kaidelong> I wrote a long blog post about seq and par a while ago, I wonder if I can still find it
04:44:35 <Kaidelong> and pseq
04:44:56 <Komier> rioch:  When i asked similar the other day, someone gave me this link. https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
04:46:31 <rioch> Komier: Lovely, thank-you.
04:47:24 <xxx-man> Cale: sn :(
04:47:59 <Cale> rioch: see also http://urchin.earth.li/~ian/style/haskell.html
04:48:13 <Cale> xxx-man: What do you need to know about strong normalisation?
04:49:21 <xxx-man> Cale: i have looked book from benjamin u recomended, I have few questions still about proof steps...
04:49:55 <xxx-man> Cale: could u please see pm
04:50:16 <Cale> You haven't asked your questions there either
04:50:22 <Cale> Ask your damn question already!
04:52:44 <merijn> rioch, Komier: Personally I (and many others) take exception to the "align if/then/else" recommendation, as that's not valid in haskell98 without an extension (not even sure that it *is* valid in haskell2010)
04:53:37 <merijn> (also, personally I use a 3 space indent for then/else so they line up with the condition following the if)
04:53:45 <rioch> merijn: ok, understood. I'll take the links as guidelines instead of hard rules.
04:54:53 <merijn> Other than that it looks mostly fine
04:55:08 <merijn> although "-Wall -Werror" might be a bit strict...
04:55:31 <merijn> You *should* use -Wall, though. It'll warn you about incomplete pattern matches, etc.
04:56:59 <Komier> ok ty
04:57:00 <monoidal> merijn: DoIfThenElse is h2010
04:57:13 <monoidal> merijn: though it is my personal opinion it's the only thing h2010 got wrong
04:57:15 <merijn> monoidal: Yeah, that's what I thought. But I take that as a personal affront :p
04:57:45 <merijn> Well, h2010 is missing out on some obvious extensions too
04:58:02 <merijn> I would've liked GADTs and RankNTypes enabled by default
04:58:28 <merijn> I guess GADTs is a bit controversial because it implies ExistentialQuantification
04:58:30 <donri> isn't the standard intended to be reasonably easy to implement
04:59:06 <merijn> donri: I wasn't under the impression that RankNTypes was overly hard to implement (GADTs might be), just that they break inference
04:59:30 <merijn> But the things they break *already* don't work in haskell, so that's no issue, imo
05:00:51 <donri> duno :)
05:01:10 <donri> also i'm confused by FFI being h2010 and wondering how that relates to things like JS backends
05:01:30 <donri> or does it only standardize the syntax, not the C-specifics?
05:01:54 <merijn> donri: It standardises specifics for specific ffi backends
05:02:15 <merijn> At least, that was my impression, I only skimmed
05:02:24 <donri> i don't understand
05:02:43 <merijn> donri: C uses ccall/capi, JS does not
05:02:48 <donri> does being h2010 compliant imply supporting a C ffi?
05:03:02 <merijn> donri: Not sure
05:03:06 <donri> exactly! :)
05:03:24 <merijn> I haven't read it, I would wager the FFI standardisation is more along the lines of
05:03:32 <donri> it could be pulled of with emscripten but that gets us back to "relatively easy to implement" :P
05:03:37 <merijn> iff you implement a ccall FFI, this is how you should do it
05:03:41 <donri> OK
05:03:58 <monoidal> regarding the standard, I'm missing ConstrainedClassMethods. both hugs and ghc supports it silently even in H98 mode.
05:04:28 <merijn> donri: It makes no sense to mandate a specific FFI, but it does make sense to mandate that any optional ones are compatible
05:05:00 <donri> agreed
05:06:06 <donri> but i didn't mean whether it specifies a JS FFI. i mean it specifies a C FFI as part of the standard and that doesn't always make sense.
05:06:23 <donri> like, I think part of Foreign.* is standard, but can you even sensibly compile that to JS?
05:06:47 <donri> then again you probably could, considering all the crazy things ghcjs pulls off
05:06:48 <merijn> donri: Most of the C specific bits are in Foreign.C
05:06:59 <donri> merijn: but isn't Foreign.C standard?
05:07:04 <merijn> donri: Foreign has stuff like marshalling, array allocation, etc.
05:07:13 <merijn> I'm not sure
05:07:41 <donri> exported by http://hackage.haskell.org/package/haskell2010
05:14:15 <donri> from the standard: "Any implementation of the Haskell FFI must at least implement the C calling convention denoted by ccall."
05:18:08 <merijn> donri: That'll probably change in the future
05:18:23 <merijn> I guess no one considered the possibility of full-blown GHC for the browser
05:18:29 <donri> :)
05:18:43 <donri> which is sort of my point, on the subject of "things haskell2010 got wrong"
05:18:56 <merijn> right
05:19:45 <merijn> 7.8 really needs to be released so we can have a real ghcjs release...
05:20:38 <donri> but more than that, i think mandating support for C FFI is too much in general... consider a simple interpreter implemented using haskell-src-exts, say. it's not standards-compliant unless it can interface with C libraries
05:21:13 * hackagebot lambdacube-core 0.1.0 - LambdaCube 3D is a domain specific language and library that makes it possible to program GPUs in a purely functional style.  http://hackage.haskell.org/package/lambdacube-core-0.1.0 (CsabaHruska)
05:21:19 <JuanDaugherty> so you're complaining about the effort to do that
05:21:23 <JuanDaugherty> or the merits?
05:21:28 <donri> maybe the standard is/should be modular, heh... like what you said: FFI is optional, but if you implement it *this* is how you should implement it
05:22:24 <donri> JuanDaugherty: duno, i think the standard should aim to be not too complicated and relatively trivial to implement, not a big monolith. or it should be "modular" with optional parts. or something.
05:23:27 <donri> a standard is useless if no-one implements it, and that's less likely the more complicated it is
05:23:28 <JuanDaugherty> FFI and the like keep the helium filled haskell on the ground
05:23:52 <merijn> donri: It's not so much mandating C FFI support as it is saying "c calling convention", which kinda implies it concerns native code calls
05:24:10 <merijn> donri: Which bypasses the entire notion of compiling haskell to a higher level language
05:24:25 <donri> merijn: but that in turn implies that you must be able to deal with native code calls, to me, but maybe i'm reading too much between the lines
05:24:35 <merijn> donri: Because all the other calling conventions specified are native code too
05:25:02 <merijn> donri: Sure, but that's mostly because I don't think the Haskell Prime committee really thought of compiling haskell to higher than native
05:25:12 <Kaidelong> gofer and helium are both basically hugs?
05:25:14 <merijn> Which was a mistake, but an excusable one
05:25:40 <donri> certainly, i'm not pointing fingers
05:26:39 <donri> but again, even ignoring things like JS backends, it reads to me as that you can't call your interpreter haskell2010 unless it can call native code
05:28:46 <Kaidelong> donri: you sure that might not have been what the people drafting the standard intended? It could be that they intended Haskell to be more an alternative to C++ than a versatile standard like ECMAScript
05:29:04 <donri> no clue
05:29:38 <merijn> gah
05:29:41 <donri> i suspect it was mostly "we have the FFI in GHC, it's very useful and mostly stable, let's standardize it"
05:30:00 <merijn> who decided to use an up arrow for "undefined" functions, while bottom is a divergent result >.<
05:30:55 <merijn> This explains why the LamdaPi tutorial was so confusing to me...
05:31:14 * hackagebot lambdacube-samples 0.1.0 - Samples for LambdaCube 3D  http://hackage.haskell.org/package/lambdacube-samples-0.1.0 (CsabaHruska)
05:34:17 <monoidal> it's notation from recursion theory
05:36:32 <monoidal> if that helps, my mnemic is that down arrow means the result "settles down"
05:37:18 <merijn> Yeah, I can see that. It's just mildly confusing when used together with the notion of bottom
05:38:51 <Twey> merijn: I don't remember LambdaPi having undefined functions…
05:40:29 <merijn> The type checking/inference functions had two versions, up arrowed and down arrowed
05:43:24 <Twey> merijn: Up-arrowed functions are those for which the type can be read off, down-arrowed can only be checked against a known type
05:52:23 <vektor> @src []
05:52:23 <lambdabot> data [] a = [] | a : [a]
05:53:07 <vektor> [a] is syntactic sugar for [] a I assume?
05:53:29 <monoidal> vektor: yes
05:53:39 <vektor> @src :
05:53:39 <lambdabot> Source not found. Take a stress pill and think things over.
05:53:44 <vektor> lol
05:53:47 <monoidal> @src (:)
05:53:47 <lambdabot> Source not found. There are some things that I just don't know.
05:54:17 <nadirs> @src []
05:54:17 <lambdabot> data [] a = [] | a : [a]
05:54:33 <nadirs> I think (:) is a constructor
05:54:54 <monoidal>  it is
05:54:56 <Hafydd> What gave it away?
05:55:02 <nadirs> oh, my bad, didn't see vektor's first @src :P
05:55:19 <vektor> > :t (:)
05:55:21 <lambdabot>  <hint>:1:1: parse error on input `:'
05:55:25 <vektor> uhh
05:55:29 <nadirs> @ty (:)
05:55:30 <lambdabot> a -> [a] -> [a]
05:55:46 <vektor> thx
05:56:18 <nadirs> probably lambdabot's hint refers to the semicolon in ":t"
05:56:26 <vektor> yeah, I guess
05:56:47 <mauke> :t (:)
05:56:48 <lambdabot> a -> [a] -> [a]
05:56:50 <Twey>  :t is a separate command
05:57:09 <Twey> (> and :t are convenient synonyms for @run and @type, respectively)
05:57:32 <mauke> @eval hey
05:57:43 <Twey> @run 5
05:57:44 <lambdabot>  5
05:57:45 <vektor> well, ghci uses :t as a valid command, in a context similar to @run. Well, derp
05:57:55 <nadirs> @help eval
05:57:55 <lambdabot> eval. Do nothing (perversely)
05:58:02 <nadirs> wat
05:58:08 <Twey> Haha
05:58:43 <vektor> lambdabot is an awesome piece of software. I guess that's the result of the rule "programmers like to program for programmers."
05:59:03 <nadirs> haha
05:59:33 <vektor> also, ghc threw a funny error the other day... something about it's head exploding.
06:00:05 <nadirs> Easter eggs: programmers like them.
06:00:12 <mauke> vektor: that's simon's head, actually
06:00:57 <nadirs> mauke: is there such a universe where simon's head can explode (even figuratively?)
06:03:49 <mauke> does lambdabot have an existential type in scope?
06:06:23 * hackagebot tkyprof 0.2.1.1 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.2.1.1 (MitsutoshiAoe)
06:08:56 <Hafydd> I love doing nothing perversely.
06:10:51 <zett_zelett> Why isn’t Haskell popular with the industry?
06:11:04 <merijn> zett_zelett: Depends on which industry you refer too
06:11:17 <zett_zelett> Like, finance?
06:11:23 <Cale> zett_zelett: The industry in general likes to be able to easily hire new people
06:11:35 <merijn> zett_zelett: I know of at least 4-5 big companies in finance that use haskell
06:12:09 <Cale> It's not *that* hard to hire a Haskell programmer now, but it's not like we're in huge supply.
06:12:11 <merijn> Hell, Standard Chartered have their own "strict haskell" compiler (Lennart was at SC, right? Or did I mix up companies again?)
06:13:07 <zett_zelett> Which companies use Haskell, merijn?
06:13:50 <aristid> i believe there is a wiki page somewhere
06:14:09 <zett_zelett> http://www.haskell.org/haskellwiki/Haskell_in_industry yeah, this.
06:14:10 <aristid> zett_zelett: http://www.haskell.org/haskellwiki/Haskell_in_industry
06:14:19 <aristid> so there is a list of companies there
06:14:21 <merijn> oh
06:14:29 <merijn> ABN Amro is using haskell now? Neat
06:16:02 <funfunctor> Hi, any style tips on my bloom filter implementation? https://gist.github.com/victoredwardocallaghan/8255720 and any advice on hashing?
06:16:51 <mirpa> I can construct value like this: Ab <$> getChar <*> getChar; Is there easy way howto construct Ab using ['a', 'b']?
06:17:41 <merijn> mirpa: What do you want to do if the list has to few/many items?
06:18:12 <mirpa> merijn: error - doesn't matter
06:18:52 <aristid> good that google usually finds free versions of papers
06:19:03 <merijn> mirpa: Then I'd just pattern match, probably "f (x:y:_) = Ab x y" or something
06:19:17 <merijn> aristid: I know, right!
06:19:36 <aristid> merijn: aren't you in a university that is supposed to have all the subscriptions? :P
06:19:37 <merijn> funfunctor: Looks mostly good stylewise, I'd personally have some minor layout changes
06:19:45 <merijn> aristid: Yes, but I don't wanna VPN from home
06:20:02 <aristid> merijn: true, that was quite annoying when i was still in uni
06:21:24 <skypers> @index both
06:21:24 <lambdabot> bzzt
06:21:53 <merijn> funfunctor: I'd probably change it like this, style wise: https://gist.github.com/merijn/8255781/revisions
06:22:08 <skypers> @hoogle (Bifonctor p a a) => (a -> a) -> p a a -> p a  a
06:22:09 <lambdabot> Warning: Unknown class Bifonctor
06:22:09 <lambdabot> Control.Monad.Trans.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
06:22:09 <lambdabot> Control.Monad.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
06:22:15 <frohe> Let a and b be integer lists of length n. I'm trying to translate the following pseudocode in haskell: a[i] = b[i-1] * a[i-1] + a[i-2], 2 <= i <= n. I wrote a recursive relation but I found it too "hairy". Is there a standard way to implement this?
06:22:33 <skypers> @hoogle (Bifunctor p a a) => (a -> a) -> p a a -> p a  a
06:22:33 <lambdabot> Warning: Unknown class Bifunctor
06:22:33 <lambdabot> Control.Monad.Trans.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
06:22:33 <lambdabot> Control.Monad.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
06:22:39 <merijn> funfunctor: Also, I'd use <$> (infix fmap) over `liftM`
06:22:55 <mauke> frohe: that looks like you're iterating 3 lists in parallel
06:22:57 <skypers> it’s surprising
06:23:05 <funfunctor> merijn: thanks!
06:23:24 <funfunctor> merijn: sorry could you explain <$> a little more please?
06:23:40 <aristid> <$> is just fmap
06:23:40 <merijn> funfunctor: "f <$> x = fmap f x"
06:23:51 <funfunctor> ah
06:24:00 <merijn> funfunctor: If your datatype is both a Functor and a Monad, then liftM == fmap == <$>
06:24:01 <skypers> @let both :: (Bifunctor p a a) => (a -> b) -> p a a -> p b b; both f = bimap f f
06:24:01 <lambdabot>  Parse failed: MultiParamTypeClasses is not enabled
06:24:07 <skypers> dammit
06:24:16 <merijn> funfunctor: So <$> is preferable to `liftM` imo
06:24:24 <merijn> It's exported from Control.Applicative
06:24:26 <frohe> mauke, this is python-like code, but I can't find a way to translate it
06:24:28 <mauke> > let a = [1 .. 5]; b = [2,10,9,8,1] in zipWith3 (\x y z -> x * y + z) b a (drop 1 a)
06:24:29 <lambdabot>  [4,23,31,37]
06:25:22 <Twey> frohe: What's a[0 .. 2]?
06:25:36 <merijn> funfunctor: Oh and allM already exists :)
06:25:54 <merijn> @hackage monad-loops
06:25:55 <lambdabot> http://hackage.haskell.org/package/monad-loops
06:26:07 <merijn> funfunctor: That has allM and a billion other monadic loops predefined :)
06:26:09 <frohe> Twey, a[0] = 1, a[1] = 0
06:26:17 <mauke> > let a = [1 .. 5]; b = [2,10,9,8,1] in 1 : 0 : zipWith3 (\x y z -> x * y + z) b a (drop 1 a)
06:26:18 <lambdabot>  [1,0,4,23,31,37]
06:26:25 * hackagebot acme-numbersystem 0.2.0.0 - Define the less than and subtraction for nats  http://hackage.haskell.org/package/acme-numbersystem-0.2.0.0 (MaxwellSwadling)
06:27:22 <funfunctor> merijn: where is <$> from and where is allM? Should I get <$> from Data.Functor?
06:27:29 <frohe> mauke, thanks, awesome
06:27:33 <jonasw> @pl (\x y z -> x * y + z)
06:27:34 <lambdabot> ((+) .) . (*)
06:27:55 <merijn> funfunctor: <$> is from Control.Applicative, allM is from Control.Monad.Loops (which is part of the monad-loops package on hackage I just linked)
06:27:58 <frohe> i forgot the zipWithN function :D
06:28:16 <funfunctor> ah sorry missed that, thanks thanks
06:28:19 <merijn> Data.Functor might also have <$>, I'm not sure about that
06:28:29 <ocharles> Bah. I have a 'Maybe String' and I want to turn this into Nothing if the String is empty. I feel there is some MonadPlus magic to ease this
06:28:38 <Twey> frohe: a' = 1 : 0 : zipWith (+) a' (zipWith (*) b (tail a'))
06:28:45 <ocharles> guard . not . null :: String -> m (), so that's not what I want
06:28:49 <mello_> what module should i import to use C.pureslice, C.textSplice etc? There is no tutorial that mentions which import to use
06:29:40 <Twey> s/a'/a/
06:29:47 <ocharles> I want some sort of guard/return, but I can't think of any simple way to get that.
06:29:54 <ocharles> as in, without writing it myself
06:29:54 <identity> ocharles: I've ran into so many cases recently where I needed that myself
06:29:59 <identity> but it's not a library function for some reason
06:30:04 <frohe> mauke, Twey, how come that function has a on both sides?
06:30:07 <ocharles> identity: do you know if anyone has proposed it?
06:30:13 <mauke> frohe: what function?
06:30:30 <frohe> a' = 1 : 0 : zipWith (+) a' (zipWith (*) b (tail a'))
06:30:34 <identity> ocharles: I searched on hoogle and asked in here and no one really answered(I think it was on two seperate occasions, even) so maybe the need isn't so great
06:30:42 <mauke> frohe: that doesn't have any a
06:30:43 <identity> or it's some .. antipattern or something, though it doesn't feel like it
06:30:46 <mauke> frohe: and it's not a function
06:30:48 <identity> so no, I don't know if anyone has
06:31:06 <Twey> frohe: Haskell is lazy: a definition can refer to itself
06:31:09 <ocharles> identity: I might ask libraries
06:31:16 <ocharles> though people are generally against extending base
06:31:17 <Twey> > let x = 1 : x in take 5 x
06:31:18 <lambdabot>  [1,1,1,1,1]
06:31:28 <frohe> this is an infinite list, right?
06:31:36 <ocharles> identity: hey, there is mfilter
06:31:38 <Twey> x = 1 : x = 1 : 1 : x = 1 : 1 : 1 : x = …
06:31:43 <Twey> frohe: It's as long as b
06:31:44 <ocharles> > mfilter (not . null) (Just "")
06:31:45 <lambdabot>  Nothing
06:31:53 <Twey> frohe: It'll be infinite if b is infinite, yes
06:31:55 <ocharles> > mfilter (not . null) (Just "Hello")
06:31:56 <lambdabot>  Just "Hello"
06:32:01 <identity> oh
06:32:01 <ocharles> identity: so it looks like that is what I want
06:32:06 <frohe> ah, ok, dammit I'm a bit confused :D thanks
06:32:08 <identity> that does seem to be it, yes
06:32:19 <ocharles> <3 hoogle
06:32:26 <identity> but IMO there should be a function that does this, perhaps in a more general manner, in Data.Maybe
06:32:36 <ocharles> :t mfilter
06:32:37 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
06:32:40 <ocharles> identity: how can you get more general than that?
06:32:44 <ocharles> you mean less general, I think
06:32:49 <ocharles> (and I'm against that :))
06:33:07 <identity> hmm, I guess you're right
06:33:17 <funfunctor> merijn: thanks, it looks a lot better now.. I didn't really like the if else statments in there.. Any advice on a hash family?
06:33:24 <identity> I'm just thinking something like "toNothingIf"
06:33:51 --- mode: calvino.freenode.net set +o ChanServ
06:34:02 <identity> ocharles: I may also have been wrong in that I didn't have a Maybe, but just something like an Int which I wanted to turn into Nothing if it was zero or some such
06:34:03 <mello_> why does for instance show March work, and show $ toEnum 2 :: Month
06:34:03 <mello_>  doesnt?
06:34:25 <identity> > show $ toEnum 2 :: Month
06:34:26 <lambdabot>  Not in scope: type constructor or class `Month'
06:34:32 <merijn> funfunctor: I've never really looked into hashing, so no useful contribution about that :)
06:34:33 <ion> mello: That’s (show (toEnum 2)) :: Month
06:34:33 <mauke> mello_: because show returns String, not Month
06:34:40 <identity> mello_: maybe show $ (toEnum 2 :: Month) ?
06:34:51 <ion> Redundant $
06:34:56 <identity> ^
06:35:06 <identity> ion: thank you hlint
06:35:11 <Twey> frohe: Sorry, that ‘b’ should be ‘tail b’ — the first element of b is never used in your definition
06:35:24 <FliPPeh> λ> toEnum 2 :: Month
06:35:25 <FliPPeh> Mar
06:35:28 <FliPPeh> Works fine here
06:35:40 <funfunctor> ok thanks, my little module looks pretty neat now ^_^
06:35:44 <identity> FliPPeh: that's not his problem
06:35:49 <FliPPeh> aw
06:35:51 <ocharles> identity: ah, fair enough
06:35:52 <identity> he was trying to tell show to return a Month
06:36:05 <ocharles> identity: liftng Int -> Maybe Int first doesn't seem so bad
06:36:07 <mello_> mauke, but toEnum 2 :: Month returns something of type Month, and Month is an instance of Show. I don't get the difference between the two, on both im calling show on a month right
06:36:10 <identity> ocharles: true
06:36:18 <aleksejs_> what's wrong here? http://vpaste.net/u1LXm
06:36:19 <ocharles> identity: we need Pointed for ful generality!
06:36:21 * ocharles runs
06:36:27 <frohe> Twey, i just love how concise Haskell code is.
06:36:30 <merijn> funfunctor: For longer code bits you can also try the r/haskell reddit, it's fairly common to ask for code criqitues there
06:36:35 <ion> aleksejs: Have you asked the compiler?
06:36:38 <mauke> mello_: yes, but one does :: Month
06:36:47 <identity> ocharles: I naturally didn't run into mfilter because I was rather looking for something like a -> (a -> Bool) -> Maybe a
06:37:01 <identity> ocharles: I don't know what Pointed is
06:37:20 <ocharles> identity: ah. are you familiar with MonadPlus? I tend to use it a lot, especially with Maybe
06:37:24 <ocharles> so that was my first port of call
06:37:37 <identity> ocharles: Yes, I am, but I feel like I should be using it more often really
06:37:40 <ocharles> identity: Pointed is a fairly ill-conceived type class that lots of people think they want. point :: a -> f a
06:37:48 <ocharles> so that was me trolling myself
06:37:52 <identity> ocharles: i see
06:37:59 <Twey> ocharles: Why ill-conceived?
06:38:10 <identity> but isn't point just .. pure?
06:38:12 <identity> @ty pure
06:38:13 <lambdabot> Applicative f => a -> f a
06:38:21 <merijn> Twey: No useful laws
06:38:23 <Twey> identity: It's pure, and it's return
06:38:26 <identity> yeah
06:38:30 <ocharles> identity: yes, but it's a type class with nothing else
06:38:32 <identity> oh
06:38:33 <identity> silly
06:38:34 <Twey> The idea behind Pointed is to give it a single name
06:38:48 <mello_> mauke, this does work: show $ (toEnum 2 :: Month) why?
06:38:54 <merijn> Twey: Which is a bit useless, you can literally not say anything about the result you get from Pointed
06:38:55 <funfunctor> merijn: yep, good point thanks
06:39:05 <ion> mello: What you wrote earlier parses as ((show (toEnum 2)) :: Month)
06:39:12 <merijn> Other than "it has an 'a' in it's type"
06:39:17 <mauke> mello_: because now you're not telling the compiler that show returns a Month
06:39:27 <ocharles> Twey: http://www.haskell.org/haskellwiki/Why_not_Pointed%3F
06:39:32 <mello_> ion, ahhh okay, thanks
06:39:36 <aristid> i think there are many instances for Pointed for lists for example: replicate 3 is one
06:39:43 <ocharles> Twey: edward makes a good argument with monoid there
06:39:47 <ocharles> oh god, why did I mention pointed
06:39:53 <funfunctor> I just forget things too quickly so IRC RT chat makes it easier on my limited space-efficient/limited brain
06:40:02 * ocharles desparately tries to put all the worms back in the can
06:40:27 <SrPx> I can't compile Haste no matter what I try. https://github.com/valderman/haste-compiler I do exactly as told but I get the error hastec: can't find a package database at /Users/foo/.haste/packages . Ideas?
06:41:21 <Twey> ocharles: Hm, indeed
07:07:30 <zcourts> Give a typeclass defined as Protocol a and instance V1 and V2, can I write a function that returns either V1 or V2 depending on the arg? My attempt at it yields, "Couldn't match expected type V1 with actual type V2"
07:08:54 <Spacejoker> Hello, I'm going through the excellent openGL-tutorials found on https://github.com/dagit/nehe-tuts and have run into trouble. There is a (for me) weird import in lesson06.hs: "import Paths_nehe_tuts" which apparently imports the "getDataFileName"-fuction, and I get an error saying that the file doesn't exist.  Is this some special type of import? Has anyone seen anything similar before?
07:09:25 <philed> zcourts: I don't think so.
07:10:01 <nadirs> zcourts: what's the function type signature currently?
07:10:12 <zcourts> https://gist.github.com/zcourts/8256200
07:11:16 <philed> zcourts: You might be able to use type families for that.
07:12:11 <Twey> zcourts: You can create an existentially-qualified data type and return that, but http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:12:51 <zcourts> philed: Ok, I'll look into that.
07:13:02 <zcourts> Twey: Thanks, will check that out now too
07:14:36 <bennofs> Spacejoker: that file is generated by cabal.
07:15:08 <Taneb> Is there any reason why there isn't a (Storable a, Storable b) => Storable (a, b) instance?
07:15:08 <bennofs> Spacejoker: you need to compile using cabal if you want the import to work
07:17:00 <aristid> Taneb: i guess you can't use Unboxed?
07:17:18 <Taneb> Yeah
07:17:26 <Spacejoker> bennofs: Ah cool, thank you.
07:18:03 <aristid> Taneb: which memory layout would you envision for a vector of those? have two vectors, one for a and one for b?
07:19:19 <Taneb> aristid, no, a vector alternating, a/b/a/b
07:19:29 <Taneb> Which probably is leading to the grand reason why not
07:19:56 <aristid> hmm not sure:) alignment craziness maybe?
07:22:27 <Taneb> Probably
07:23:22 <aristid> Taneb: the storable/unboxed split in vector is painful at times :/
07:31:33 * hackagebot universe 0.4.0.5 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4.0.5 (DanielWagner)
07:48:35 <bennofs> Productivity -90.7% of total user, -39.3% of total elapsed
07:48:42 <bennofs> :O how can this happen?
07:49:05 <philed> Twey: I've only really thought about existential types in the context of abstract data types. The sort of cases where you'd have a collection of those would be in odd situations where you wanted to pass around, say, several different implementations of, say, integer sets, choosing between them at runtime. For that, you don't want to implement the sets in on OOP fashion by using dictionaries, because how would you deal with 
07:49:05 <philed> operations such as union :: Set -> Set -> Set.
07:49:23 <philed> Not sure what zcourts needs with his protocols, though.
07:52:41 <nadirs> does the standard library have an `isPrime` function? I've found the package "primes" (which should end up under Data.Numbers.Primes once installed)
07:53:22 <derdon> I don't think there is anything related to prime numbers in the standard library.
07:53:38 <nadirs> I'm writing a sieve of Sundaram function as an exercise and would like a function to feed QuickCheck tests
07:54:17 <nadirs> derdon: ok, I'll just install that. Thanks
07:56:20 <derdon> nadirs: and thanks to you for giving me a nice excercise :) haven't heard of Sundaram's sieve before
07:57:28 <nadirs> derdon: :D If you're interested, I'm working on the exercises of Brent Yorgey's course (CIS194): http://www.cis.upenn.edu/~cis194/lectures.html
08:03:08 <SLi> With (-> a) being an instance of Monad, I started to wonder if it would make sense for a -> a to be an instance of Monoid (with mempty=id, mappend=(.))?
08:03:57 <aristid> :t Endo
08:03:58 <lambdabot> (a -> a) -> Endo a
08:04:01 <aristid> SLi: yup.
08:04:35 <SLi> Ah, Endo does that. :) Right.
08:08:02 <frohe> > 5.559638e7 == fromInteger (round 5.559638e7)
08:08:03 <lambdabot>  True
08:09:11 <frohe> how to discard a Float like 5.559638e7?
08:09:33 <SLi> Discard?
08:09:57 <frohe> well, i have a list of floats and i want to check which floats are integers
08:10:10 <frohe> i use the == test above
08:10:28 <aristid> > round 5.559638e7
08:10:29 <lambdabot>  55596380
08:10:35 <aristid> frohe: it is an integer.
08:12:20 <frohe> aristid, ah i need some rest :D thanks
08:12:27 <aleksejs_> x == fromIntegral (round x)
08:13:01 <frohe> i didn't notice the scientific notation
08:13:06 <simon> truncate
08:13:09 <frohe> with e
08:13:15 <aristid> frohe: lol
08:13:22 <frohe> yeap, lol :D
08:13:27 <SLi> Hmm, so folding function applications (I'm working with [ShowS]) could be expressed as appEndo . mconcat . map Endo. (Is there an easier way to do this, without folding with (.)? And on a more meta level, am I doing something wrong when I always end up with lists of ShowS :)
08:21:09 <absence> are there known practical problems that can't be solved with total functional programming, or is it theoretical because it's not turing complete?
08:22:29 <merijn> absence: "most of them"
08:22:34 <SLi> absence: solved in practice or in theory?
08:22:38 <aristid> absence: there are many things that are currently not very practical with existing total languages
08:22:40 <jmcarthur> absence: it is known that all practical problems can be solved in total languages since in the worst case all you have to do is feed the function a sufficiently large input that it has time to run to completion before the input is depleted. add an extra natural number argument that decreases on each step and feed it something huge.
08:22:51 <aristid> but advocates of total programming insist that there's no fundamental reason for this
08:23:01 <jmcarthur> absence: of course that trick is just a hack, but it serves as a good enough proof
08:23:13 <merijn> aristid: The main reason is "there's not all that many advocates of total programming" :p
08:23:42 <aristid> merijn: they are probably overrepresented in this channel :D
08:23:44 <jmcarthur> absence: turing completeness is not the problem, as evidenced by the fact that our real computers, which we get real work done with, are not turing complete
08:24:20 <Cale> Finitely many states should be enough for anyone.
08:24:28 <SLi> absence: In theroy I guess most interesting problems can be solved using total fp. In practice writing the proof of termination for many interesting problems is not trivial.
08:24:36 <Cale> ;)
08:24:37 <aristid> 2^128 is the largest number that exists anyways
08:24:42 <ChongLi> how does total functional programming jive with nondeterminism such as IO?
08:24:46 <simon> Cale, 640K states should be!
08:25:14 <aristid> ChongLi: monads, basically.
08:25:15 <SLi> ChongLi: You can always require that a program terminates with any bounded input.
08:25:19 <aristid> it's still possible
08:25:32 <ChongLi> SLi: but network delays are unbounded
08:25:32 <Cale> 2^(640 * 8) states
08:25:43 <Cale> 2^(640 * 8000) states rather
08:25:47 <ChongLi> as is the amount of data
08:25:53 <jmcarthur> well, and don't forget all the registers, hard storage, etc.
08:26:06 <simon> Cale, right. :)
08:26:08 <Cale> well, yes
08:26:15 <SLi> ChongLi: Well, why is it a problem that cat does not terminate when given infinite input?
08:26:15 <ChongLi> and also: what happens when you run out of memory?
08:26:34 <simon> ChongLi, your program crashes?
08:27:00 <ChongLi> simon: it was a rhetorical question :)
08:27:21 <funfunctor> is there a function in the prelude or other that counts the number of times an element occurs in a list effiently?
08:27:42 <Cale> funfunctor: length . filter (== x)
08:27:58 <beardtree> Hey, why are there two separate things: types, and typeclasses?
08:28:10 <simon> Cale, can GHC fuse those two functions?
08:28:14 <Cale> beardtree: Type classes are like predicates on types
08:28:27 <Cale> (things which may or may not be true of any given type)
08:28:30 <beardtree> Cale: I understand, but aren't types like predicates on values?
08:28:33 <funfunctor> Cale: thanks thats more elegant to mine
08:28:36 <jmcarthur> simon: yes
08:28:41 <aristid> hmm IntMap wouldn't benefit from a higher arity than 2, would it?
08:28:43 <Cale> beardtree: Sort of, sure.
08:28:46 <simon> jmcarthur, cool. I thought it only did map-fusion.
08:28:58 <Cale> beardtree: Though, the manner of classification is quite different
08:29:05 <Cale> beardtree: The types of types are called kinds
08:29:12 <absence> wow, thanks for all the feedback. i know computers aren't actually turing complete due to finite resources, but i don't know if there are other differences in capability between total fp and a finite turing machine
08:29:13 <Cale> :k Maybe
08:29:14 <lambdabot> * -> *
08:29:26 <SLi> BTW does GHC do inter-module optimization?
08:29:37 <Cale> :k Integer
08:29:38 <lambdabot> *
08:29:41 <Cale> :k Maybe Integer
08:29:42 <lambdabot> *
08:29:44 <ChongLi> can you have laziness in a total functional language? what do you do about bottom?
08:29:45 <Cale> :k Ord
08:29:46 <lambdabot> * -> Constraint
08:29:47 <bennofs> SLi: it does inter-package inlining
08:29:51 <Zetaeta> :t (.).(.)
08:29:52 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:29:58 <geekosaur> to some extent. it does cross-module inlining, which is the real source of "Cabal hell"
08:29:59 <bennofs> SLi: but it doesn't do full whole program optimization
08:30:17 <Cale> beardtree: anyway, the reason that type classes exist is to constrain type variables
08:30:18 <beardtree> :k 1
08:30:19 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 1
08:30:24 <SLi> bennofs: Ah, nice. Is there a heuristic that marks functions inlinable or are they only if explicitly declared so?
08:30:27 <geekosaur> (since it means you need the *exact same* compiled module for the inlined code to work with)
08:30:40 <Cale> beardtree: Consider the type of a polymorphic sort function
08:30:42 <bennofs> SLi: there is a heuristic, yes.
08:30:45 <SLi> Nice.
08:30:54 <Scigheras> the problem has not been solved yet and I have a deadline to meet :)
08:30:55 <ChongLi> Cale: or to put it more simply, to let us reuse names and operators :)
08:30:56 <Cale> beardtree: You might hope to be able to write something like  sort :: [a] -> [a]
08:30:57 <bennofs> SLi: if the function is short, GHC puts the source code in the interface (.hi) file
08:30:58 <Scigheras> can somebody take a look at my stackoverflow haskell question? http://stackoverflow.com/questions/20890971/how-to-use-rundb-correctly-in-yesod-persistent
08:31:03 <Scigheras> the problem has not been solved yet and I have a deadline to meet :)
08:31:04 <SLi> bennofs: ok :)
08:31:08 <beardtree> Cale: but a must be Ord
08:31:11 <Cale> ChongLi: It's more than name reuse
08:31:17 <Cale> beardtree: right
08:31:20 <bennofs> SLi: but there is also a pragma to force that (iirc, INLINEABLE)
08:31:31 <Cale> beardtree: We need some ordering comparison on values of type a for sorting to make sense
08:32:07 <beardtree> Cale: one thing I don't understand is whether there is inheritance with types
08:32:17 <Cale> beardtree: no
08:32:24 <ChongLi> beardtree: there isn't :)
08:32:30 <beardtree> But there is multi-inheritance of typeclasses
08:32:31 <jmcarthur> simon: you may be interested in reading chapter 1 of http://code.haskell.org/~duncan/thesis.pdf . it explains a few flavors of fusion. the one GHC uses for lists is foldr/build fusion.
08:32:46 <ChongLi> beardtree: no, type classes don't have inheritance either
08:32:47 <Cale> beardtree: kind of? There's no implementation inheritance.
08:32:53 <ChongLi> they have a hierarchy
08:33:00 <jmcarthur> simon: after reading that it should be pretty easy for you to tell from looking at base's source code what list functions fuse
08:33:32 <ChongLi> but it's more like a set of properties than a family tree
08:33:35 <Cale> You can define one class as demanding that certain other instances exist, which will mean that anyone writing an instance for that class *also* has to write instances for the others.
08:33:49 <beardtree> :k reverse
08:33:50 <lambdabot> Not in scope: type variable `reverse'
08:33:53 <Cale> like,  class Eq a => Ord a where ...
08:33:53 <ChongLi> it's statements like "if you are to be an applicative, you must also be a functor"
08:34:05 <absence> jmcarthur: did you mean that total fp is as capable as a finite turing machine by limiting the number of iterations?
08:34:15 <Cale> means that if you write an instance Ord Foo, then somewhere in your program there also has to be an instance Eq Foo
08:34:39 <jmcarthur> simon: hmm... actually, i think length doesn't fit will into the foldr/build scheme, although i do know it fuses. i guess i should look at the source.
08:34:51 <jmcarthur> *fit well
08:34:52 <Cale> and in exchange, whenever some type variable is constrained by Ord, you're allowed to use Eq operations like (==) on it
08:35:33 <beardtree> Cale: that's the kind of inheritance I'm talking about
08:35:57 <ChongLi> beardtree: it's not inheritance though
08:35:59 <beardtree> So neither types nor typeclasses define any sort of implementation, right?
08:36:26 <ChongLi> beardtree: typeclasses mandate an implementation, type instances implement it
08:36:54 <ChongLi> if you want to implement Ord for your type
08:36:59 <ChongLi> first you must implement Eq
08:37:00 <Cale> beardtree: Depends on what you mean by implementation
08:37:08 <ChongLi> Ord does not give you Eq for free
08:37:11 <SLi> Learning Haskell has been an interesting experience in one sense. I'm starting to feel comparatively proficient in Haskell, but there are still languages I know slightly better (such as Python and C++). Even given that I'm still not sure how of some of the concepts in Haskell, even those I think I understand, map to those other languages. And I think thinking that through could improve my coding in C++ and Python. (And it's not only that it's functional;
08:37:12 <SLi> somehow I didn't have the same experience with ocaml, grokking it in a comparative fashion was easier :)
08:37:24 <beardtree> Cale: type and typeclass definitions don't deal with values, just types, right?
08:37:25 <Cale> Data declarations define data constructors and perhaps a bunch of field extractors
08:37:26 <jmcarthur> absence: i mean the only difference between total fp and partial fp is that the former has a finite running time. if you constrain both styles to the same finite running time, as you would want to do in a real-world situation, they are equivalent in power.
08:37:46 <ChongLi> having said that, the compiler is able to automatically derive implementations for both Eq and Ord, but that is not relevant
08:38:24 <Cale> beardtree: (that is, data declarations create values at the same time as types)
08:38:34 <ChongLi> beardtree: type classes specify a set of methods which instances implement
08:38:41 <absence> jmcarthur: ok, that made it pretty clear for me, thanks :)
08:38:42 <ChongLi> some of those methods are optional, some are required
08:38:43 <jmcarthur> absence: also, my argument has been quite simplistic, but you can even do something that feels like less of a hack and doesn't require you to bound the running time at all. just define your program as a step function instead of as a recursive function.
08:38:57 <ChongLi> (the optional ones being defined in terms of the required ones)
08:39:00 <Cale> class declarations don't say how methods are implemented, but can provide default implementations which will be used if an instance leaves the definition of a method out
08:39:00 <jmcarthur> absence: you can just drive the step function as many times as you want
08:39:18 <SLi> I've also started to wonder how to measure "I know programming language X". Somehow in Haskell there's always more nicer deeper abstractions to understand, more so than in most other languages. So I think it's possible to know more about Haskell programming than about, say, C programming, while still knowing a smaller proportion of useful things to know about it.
08:40:02 <ChongLi> SLi: there is definitely a lot more to learn in Haskell
08:40:27 <ChongLi> that is not to say you couldn't write any program in C that you'd write in Haskell
08:40:28 <bennofs> SLi: I think C++ is also really complex if you include all the template things and the complexity of the C++ standard.
08:40:32 <jmcarthur> but most of those things aren't the language, but more general compsci stuff
08:40:54 <ChongLi> but learning to use Haskell is more than just learning how to write programs in the language
08:41:00 <SLi> bennofs: It is, and I still think I understand those quite well (and it's a deep language with those and everything that's done with those, but still Haskell somehow seems even deeper).
08:41:00 <jmcarthur> the Haskell *language* is really not that much to learn
08:41:01 <bennofs> SLi: IMO, more/nicer abstractions are more useful than knowing all of the C++ standard :D
08:41:10 <SLi> bennofs: certainly.
08:41:13 <ChongLi> it's also about learning to use the compiler and other tools
08:41:44 <SLi> bennofs: And the same is true with Haskell; that's really what I meant, knowing "programming in language X" instead of just knowing the language technically :)
08:43:43 <funfunctor> how can I improve this, freqtable s = [((fromIntegral . count c $ s)/(fromIntegral . length $ s))*100 | c <- ['a'..'z']], so that its not padded out with so many zeros?
08:44:04 <bennofs> @ty count
08:44:05 <lambdabot>     Not in scope: `count'
08:44:05 <lambdabot>     Perhaps you meant one of these:
08:44:05 <lambdabot>       `BS.count' (imported from Data.ByteString),
08:44:06 <Psycho_pr> Is there an iPhone app that will act like ghci?
08:44:45 <ChongLi> Psycho_pr: raskell?
08:45:01 <ChongLi> https://www.youtube.com/watch?v=EuavMYjKFAc
08:45:22 <ChongLi> I guess it's iPad only? hmm
08:45:38 <Psycho_pr> iPad would also work
08:45:44 <Psycho_pr> but I see it's a ruby->haskell bridge
08:45:45 <funfunctor> woops, sorry bennofs count = length . filter (== e)
08:46:53 <beardtree> Cale: hmm
08:47:14 <beardtree> If you were to design Haskell, how would you design the type system?
08:48:15 <ChongLi> beardtree: I don't have much of an idea how to improve on it
08:48:31 <ChongLi> some might say dependent types, but those are a trade-off
08:49:09 <Cale> beardtree: I might change a couple of smaller things, but largely it would be as it is.
08:49:17 <Cale> ScopedTypeVariables should be the default
08:49:36 <Cale> GADTs should also be in from the beginning :)
08:49:47 <Cale> (or at least the syntax)
08:49:55 <ChongLi> I might change a few things syntactically
08:50:19 <ChongLi> the module system could use a few improvements (but not crazy like ML's module system)
08:50:34 <merijn> Cale: Don't forget RankNTypes by default
08:50:38 <ChongLi> it'd be nice to have a bit more control over what we import
08:50:45 <ChongLi> for example, type classes
08:51:02 <Cale> merijn: Yeah, that might be good :)
08:51:06 <ChongLi> I don't know how that would actually change things in practice, though
08:51:07 <Cale> oh
08:51:13 <Cale> Yes, I would change type synonyms
08:51:24 <Cale> So as to make them actually useful :)
08:51:33 <merijn> Cale: How?
08:51:35 <ChongLi> would it make any sense to have different type classes use the same name and thus have to be qualified?
08:51:46 <ChongLi> that might end up being really ugly
08:52:11 <Cale> In particular, if you didn't export a type synonym, it would not export the type equality between the synonym and the original type.
08:52:29 <merijn> oh, that'd be nice, yeah
08:52:57 <ChongLi> wait, so you'd give type synonyms actual semantics?
08:52:57 <Cale> Or rather, I'd have some syntax for exporting the synonym separately from the equality
08:53:10 <funfunctor> so I am doing Euler 59 to practice a little.. Would I be correct to use a χ² distribution?
08:57:00 <arnsholt> funfunctor: I think just comparing letter frequencies to the distribution of letters in English is a good start
08:58:00 <arnsholt> Not sure how you'd use chi-square for it
08:58:46 <funfunctor> does that not fit the χ² pdf though?
08:59:04 <Eduard_Munteanu> Cale: I think Agda can already do it, if you look at 'abstract', which basically lets you define functions (including type functions) which don't reduce outside the 'abstract' block.
08:59:17 <funfunctor> i.e. parameterise it with `English` and look for the best fit..
08:59:53 <funfunctor> arnsholt: I'm sort of trying to think of a bit 'advanced' maybe
08:59:58 <Cale> Eduard_Munteanu: you're right, I think it can
09:00:01 <arnsholt> Might work, I guess
09:00:28 <funfunctor> I was curious to make something that is re-usable later as a fun tool
09:00:28 <arnsholt> But if you want to do this the fancy way, there are algorithms used to break ciphers like this automatically
09:00:39 <Eduard_Munteanu> Not sure how to go about controlling instantiations of typeclasses, if you want to.
09:00:43 <arnsholt> Things like EM (Expectation Maximisation)
09:00:44 <funfunctor> arnsholt: yea, I can't remember its name?
09:00:45 <ChongLi> funfunctor: just brute-force the thing
09:00:54 <arnsholt> But yeah, what ChongLi
09:01:27 <funfunctor> ChongLi: that's boring.. Sure there is the easy way..
09:01:28 <arnsholt> Just rank all the possible keys by how far the frequency of 'e' and maybe some others is from the known distribution in English
09:01:41 <ChongLi> or the word the
09:01:54 <ChongLi> which is pretty much guaranteed to be in the plaintext
09:02:11 <arnsholt> Or you can train a letter markov chain and use the probability of the plaintext to rank
09:02:13 <ChongLi> the word the surrounded by spaces, that is
09:02:26 <funfunctor> hmm, maybe a Kalman filter would be cool
09:02:53 <funfunctor> markov chain would also be cool
09:02:58 <arnsholt> Nah, don't think Kalman filter is what you want
09:03:07 <croyd> taking the dot product is a simple & effective option
09:03:21 <ChongLi> actually, this is even simpler than I thought
09:03:28 <ChongLi> you can break the key one byte at a time
09:03:32 <ChongLi> or at least, narrow it down
09:03:42 <ChongLi> the only allowed characters are lowercase alphabetical
09:03:52 <ChongLi> right?
09:04:49 <arnsholt> funfunctor: There's http://en.wikipedia.org/wiki/Vigenere_cipher#Cryptanalysis as well
09:04:58 <arnsholt> Since this is essentially a vigenere cipher
09:05:07 <ChongLi> they would've made this much harder if they'd used cipher-block chaining :)
09:05:37 <arnsholt> =)
09:06:05 <ChongLi> oh, I was wrong what I said earlier
09:06:20 <bennofs> Wow, is it normal that GHCi uses 193 MB ?
09:06:21 <ChongLi> the key is only lower case
09:06:25 <bennofs> (ram)
09:06:31 <ChongLi> the plaintext is unrestricted
09:07:25 <aristid> bennofs: yes
09:07:25 <arnsholt> funfunctor: Anyways, if you want to have more fun with this than just letter frequencies, I think the two best options are either using markov-chain probs to rank the keys or full-on EM to find the key
09:07:40 <arnsholt> Doing EM is likely to be really non-trivial though
09:08:03 <funfunctor> I'm looking into doing EM now arnsholt
09:09:03 <funfunctor> arnsholt: yep I know its a Vigenere cipher
09:09:04 <arnsholt> To the extent that there have been conference papers in my field (computational linguistics) doing this kind of stuff
09:09:23 <ChongLi> hmm, never thought of this
09:09:42 <SrPx> I've been trying to compile Haste for hours without success. It compilers, but running it produces an error saying Haste needs to be rebooted. I've done so.
09:09:45 <arnsholt> So unless you have a couple of weeks at least to spend on this problem, I'd go with the Markov chains =)
09:09:47 <funfunctor> arnsholt: I'm aware its non-trivial..
09:09:50 <ChongLi> but isn't it a bit weird that there's no simple http function hin the prelude?
09:10:36 <arnsholt> ChongLi: Using EM? Yeah, it's pretty clever. Kevin Knight (http://www.isi.edu/~knight/) has a couple of papers on code-breaking
09:10:36 <SrPx> Anyone has an idea what I can do?
09:13:11 <ChongLi> just something like fetchURL :: String -> IO (StatusCode,Maybe String)
09:13:15 <funfunctor> arnsholt: http://www.ics.uci.edu/~agelfand/pub/ConstrainedCrypto-EMAlgorithm.pdf
09:14:06 <bennofs> Can hp2ps use color?
09:16:14 <arnsholt> funfunctor: Yup, that looks more or less like it. Since it's for monoalphabetic ciphers (AFAICT), doing the column transform described on the wikipedia page and solving the three monoalphabetics independently is probably the easiest way
09:17:12 <swingster> do we like todays xkcd?
09:18:00 <zett_zelett> The other day I saw a chart on how Monoids/Monads/Functors and other things are related.
09:18:00 <zett_zelett> Does anyone know what I’m talking about and where I can find it?
09:18:01 <zett_zelett> .
09:18:13 <geekosaur> @where typeclassopedia
09:18:13 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:18:17 <bennofs> Ah, nvm, I found the -c switch
09:18:26 <funfunctor> arnsholt: arnsholt and the markov way you were thinking of was a Gibbs sampler with MCMC right?
09:18:32 <zett_zelett>  The other day I saw a chart on how Monoids/Monads/Functors and other things are related.
09:18:32 <zett_zelett> Does anyone know what I’m talking about and where I can find it?
09:18:50 <geekosaur> should I repeat myself?
09:18:54 <geekosaur> @where typeclassopedia
09:18:55 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:19:00 <geekosaur> ...leaves first
09:19:06 <geekosaur> guess they didn't really want to know
09:19:16 <mello_> how do you bind runtime splices with heistLocal, or is this not possible like you do it with interpreted splices?
09:19:17 <geekosaur> @where typeclassopedia
09:19:18 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:19:21 <zett_zelett> The other day I saw a chart on how Monoids/Monads/Functors and other things are related.
09:19:21 <zett_zelett> Does anyone know what I’m talking about and where I can find it?
09:19:21 <geekosaur> zett_zelett, ^^
09:19:24 <geekosaur> dammit
09:19:31 <swingster> clownfest
09:19:36 <zett_zelett> What happened.
09:19:38 <geekosaur> I can repeat it yet again if you prefer
09:19:40 <geekosaur> @where typeclassopedia
09:19:41 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:19:58 <zett_zelett> Yeah, thanks!
09:20:14 <arnsholt> funfunctor: No, just train a Markov chain and use the probability of the plaintext to rank all the possible keys (just 17k of them or something) and find the right one by looking at the top 50 keys or something
09:20:15 <zett_zelett> Sorry for doubleposting (or maybe even tripleposting), I lost connection and wasn’t sure.
09:20:54 <arnsholt> But I think Knight has a Gibbs sampling thing to crack vigenere-style ciphers
09:21:38 <funfunctor> arnsholt: ah ok.. nar, I think χ² gives a reasonable distribution of ranking any way with the correct parameter k.
09:22:22 <funfunctor> arnsholt: The EM one sounds more exciting, should help me deepen my understanding of haskell which is my intent
09:22:59 <funfunctor> Gibbs sampler should be a pretty neat fit to the problem, its what came to my mind
09:24:45 <skypers> http://www.xkcd.com/1312/
09:24:50 <skypers> outch :D
09:26:52 * hackagebot unicode 0.0 - Construct and transform unicode characters  http://hackage.haskell.org/package/unicode-0.0 (HenningThielemann)
09:36:26 <mello_> DanielDiaz, on http://stackoverflow.com/questions/19741599/snap-rendering-table-with-compiled-splices  in the end you put it in a heistConfig. How can I bind it with something similar as you do with heistLocal and interpreted splices?
09:37:11 <mello_> DanielDiaz, or alternatively how do you put it in SnapInit?
09:44:32 <nadirs> is there a way to refresh available libraries in ghci after installing a new package without quitting the session? If not, is there a way to backup the current session's definitions (`let`s) and reload them in a new one?
09:45:22 <bennofs> How do I interpret a heap profile? For example, take http://imgur.com/AOpxLaX. Are there ~ 70 MB THUNK_1_0 or only ~ 10 MB?
09:50:42 <allsystemsarego> @hoogle runMaybeT
09:50:43 <lambdabot> Control.Monad.Trans.Maybe runMaybeT :: MaybeT m a -> m (Maybe a)
09:50:46 <frohe> is there any number type such that I can use div, mod, (/) and other functions everywhere without the need to convert from one type to another?
09:50:55 <caulagi> hello - I am trying to install yesod but I get this - http://lpaste.net/97960
09:51:08 <caulagi> Any ideas?
09:51:53 <geekosaur> frohe: not really
09:51:55 <monochrom> nadirs: no to both
09:51:57 <nadirs> bennofs: I think the latter, the quantities are stacked up
09:52:16 <geekosaur> there's some joke stuff but trying to use it in practice will get you into trouble pretty quickly I think
09:52:18 <nadirs> monochrom: thanks, good to know
09:54:57 <NickKidman> practically, does one actively view typing systems as lambda calculus via kinds
09:54:57 <NickKidman> http://en.wikipedia.org/wiki/Kind_%28type_theory%29#Kinds_in_Haskell
09:56:06 <NickKidman> I know dependend type systems (specifically the logical ones, with "\Pi" and "\Sigma"). I guess this is just another formalization of type polynormphism, a tool to formalize the idea of having types depending on types, right?
09:56:52 <merijn> NickKidman: Well, haskell kinds can only use "*" and "->" (well, they can use other things using DataKinds)
09:57:03 <merijn> NickKidman: You can't use arbitrary values at the kind level
09:57:18 <merijn> NickKidman: With dependent types it *is* possible to use arbitrary values at the kind level
09:57:39 <merijn> i.e. one could have the kind "Int -> *" in standard haskell this is a kind error
09:57:45 <merijn> As Int is a type, not a kind
09:58:10 <merijn> There should be a comma between that kind and the "in standard haskell"
09:58:13 <NickKidman> is this done to avoid stuff like Girads paradox?
09:58:30 <triliyn> Does that work in DataKinds or does Int not get promoted?
09:58:42 <triliyn> I guess it doesn't really have constructors so it wouldn't be that useful
09:58:44 <merijn> triliyn: Int can get promoted, you just can't really inspect it's value
09:58:51 <triliyn> Right
09:58:58 <merijn> triliyn: Or rather
09:59:17 <merijn> triliyn: DataKinds includes Nat (type level naturals) and Symbol (type level strings)
09:59:29 <merijn> So you'd probably use Nat over Int
09:59:36 <merijn> but I have to go eat dinner :)
09:59:53 <NickKidman> for which sort of programs do you actually sit down and think of the type constructions in terms of * and -> and write everythign down?
10:00:07 <NickKidman> bonn apety
10:00:37 <aristid> NickKidman: did you deliberately spell that wrong? :)
10:00:43 <NickKidman> yes
10:01:27 <NickKidman> (because I'd surely make an error if try to do it correctly, so I rather go full wrong and then it looks ironic)
10:02:16 <jonasw> :D
10:03:42 <yyyyy> are you two talking about appétit or girard :p ?
10:04:09 <frohe> geekosaur, well I'm stuck, I don't know what type declarations I need to make so that I can run this code. http://lpaste.net/97961
10:06:56 * hackagebot Condor 0.1 - Information retrieval library  http://hackage.haskell.org/package/Condor-0.1 (klangner)
10:14:20 <Twey> SLi: I think part of that is just that it stretches your mind.  If you come from a traditional imperative background, Haskell breaks a lot of assumptions you pick up about coding, which can only be good for your understanding.  :þ
10:21:58 * hackagebot hOpenPGP 0.11 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.11 (ClintAdams)
10:27:23 <udevd> @type round
10:27:23 <lambdabot> (Integral b, RealFrac a) => a -> b
10:27:34 <scshunt> @type square
10:27:35 <lambdabot> Not in scope: `square'
10:27:38 <scshunt> useless
10:28:30 <SparkySparkyBoom> has anyone used this library before>
10:28:33 <SparkySparkyBoom> https://github.com/egonSchiele/HandsomeSoup
10:29:12 <aristid> :t (^2) -- scshunt
10:29:12 <lambdabot> Num a => a -> a
10:31:37 <SrPx> Can someone please tell me how do I uninstall EVERYTHING related to haskell from my computer so I can try reinstalling GHC to see if Haste works?
10:32:45 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/sicp.xhtml
10:32:45 <ChongLi> okay, so brute-forcing euler 59 is pretty fast
10:32:46 <ChongLi> haha
10:33:06 <bennofs> SrPx: What operating system?
10:34:03 <ion> srpx: Depends on how you installed it. If you installed it like <https://gist.github.com/ion1/2815423>, rm -fr ~/.ghc ~/.cabal. If you installed it using the system package manager, you’ll have to uninstall it using it.
10:34:50 <aleksejs_> is it me or this can be reduced to simple equation without any map/filter/etc http://projecteuler.net/problem=28 ?
10:35:41 <mello_> Can i use compiled splices just as i can use interpreted ones in my templates? (Snap)
10:50:26 <PebkacJones> hello
11:00:13 <flebron> Hi guys. Say I have a project with Foo.hs, and Foo/Internal.hs. Internal.hs declares a datatype that Foo.hs later re-exports, to be user visible. In doing the Haddock documentation, I'd like users to see the documentation for this type in Foo.hs's docs (the public interface), is this possible?
11:02:24 <pavonia> aleksejs_: Looking at the series of numbers on the lower left to upper right diagonal I'm pretty sure it can
11:02:46 <frx> frohe assuming your code is correct try removing the signatures and then check the inferred types in ghci
11:02:59 <aleksejs_> I've already found out that equation
11:03:18 <aleksejs_> (n*(4*n^2 + 3*n + 8) - 6) `div` 6
11:04:10 <bennofs> flebron: yes it is possible, although I don't know what you have to do to make it work.
11:04:54 <bennofs> flebron: look for example at http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-Set.html
11:04:57 <merijn> flebron: Haddock should automatically copy the docs from Foo/Internal.hs *if* you explicitly reexport the thing from Foo.hs
11:05:24 <merijn> flebron: i.e. if you export "Foo (..)" from Foo.hs then it will just use the docs from Foo/Internal.hs for that
11:05:25 <frohe> frx, it actually typechecks. my bad. the problem is that it can't run. trying "wiener 238123333 293719721" gives me: No instance for (RealFrac a0) arising from a use of `wiener'
11:05:38 <frohe> and No instance for (Num a0) arising from the literal `238123333'
11:05:49 <bennofs> why does cabal not handle the import/export shortcut: module Z ( module X ) where import A as X; import B as X; ... ?
11:05:54 <merijn> frohe: Put your code on lpaste?
11:05:54 <bennofs> Eh, I meant haddock
11:06:09 <merijn> bennofs: Then it just includes a link directly to the docs for module X
11:06:17 <bennofs> merijn: no, it doesn't
11:06:33 <merijn> bennofs: Lemme, check pretty sure it did when I tried
11:06:35 <bennofs> that only works when I write module Z (module A, module B, ...)
11:06:48 <bennofs> But not when I write module Z (module X) where import A as X; import B as X
11:07:44 <merijn> bennofs: How would you expect it to magically resolve that?
11:07:47 <frohe> merijn, http://lpaste.net/97967
11:07:52 <merijn> bennofs: What would it link too?
11:07:57 <bennofs> module A and module B
11:07:58 <frohe> frx, http://lpaste.net/97967 that's the version that typechecks
11:08:11 <bennofs> just like GHC does re-export module A and B
11:08:46 <monochrom> bennofs: I say: because not enough money has been paid to get haddock do it right
11:09:48 <monochrom> it is in fact a particularly thorny case. "module" in the export list has a pretty tricky semantics.
11:10:06 <josephjnk> Is this the proper place to ask general theoretical FP questions, or is there a better channel? I'm designing a pattern matching system for a toy language and I'm looking for resources on some questions I have
11:10:24 <merijn> josephjnk: I usually just ask here :p
11:10:28 <monochrom> see my http://www.vex.net/~trebla/haskell/module.xhtml , it is pretty interesting
11:10:36 <merijn> frohe: Way too complicated to figure out what that's doing without the types
11:11:09 <bennofs> monochrom: yeah, it's interesting that module Z (module X) where import qualified A as X doesn't work :p
11:11:31 <Eduard_Munteanu> josephjnk: ask first, meta-ask later. :)
11:12:14 <josephjnk> Awesome. Does anyone know anything about "forgetful" vs "non-forgetful" pattern matching? I was reading something (I think by Gilad Bracha) that was really critical of pattern matching systems (like haskell's) that forget the details of the patterns that were matched after a match occurs
11:12:26 <frx> inferred type of wiener is (Floating a, Integral a, RealFrac a) => a -> a -> Maybe (a, a), and there is no numerical type that implements all those type classes.
11:12:31 <Eduard_Munteanu> Questions are opposite to functions, higher order ones aren't very useful. :P
11:12:44 <josephjnk> As in, a typeclass was matched vs a concrete type
11:12:53 <merijn> frx: Good catch :)
11:13:11 <josephjnk> And while I don't like losing information, I can't understand why this would matter/be a good thing
11:13:48 <frohe> merijn, sorry for that. i'm actually trying to implement Wiener's algorithm from the book Cryptography: Theory and Practice, Third Edition.
11:14:27 <frohe> frx, is there any way to solve this?
11:14:35 <merijn> frohe: As frx points out your function has contradicting constraints
11:14:40 <Eduard_Munteanu> josephjnk: possibly in the context of GADTs or other non-trivially indexed types it might matter
11:15:22 <merijn> frohe: The problem is that euclidean uses div and mode, which requires Integral
11:15:31 <merijn> frohe: The rest of your code uses / which requires Floating
11:15:48 <frohe> i should use fromInteger, right?
11:15:57 <merijn> frohe: Since you never convert between the two, the result is a contradicting type
11:16:07 <joelteon_> @hoogle (Rational a, Integral b) => a -> b
11:16:08 <lambdabot> Warning: Unknown class Rational
11:16:08 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
11:16:08 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
11:16:13 <joelteon_> whoops
11:16:16 <merijn> frohe: Since there are (at least not by default) no types that are both Floating and Integral
11:16:18 <monochrom> I have never heard of "forgetful pattern matching". did someone make that up?
11:16:25 <merijn> frohe: You'll want either fromIntegral or realToFrac
11:16:29 <merijn> :t fromIntegral
11:16:30 <lambdabot> (Integral a, Num b) => a -> b
11:16:36 <merijn> :t realToFrac
11:16:37 <lambdabot> (Fractional b, Real a) => a -> b
11:16:37 <josephjnk> I'll see if I can track down the article
11:16:44 <Eduard_Munteanu> josephjnk: not exactly sure what they're talking about, but I guess matching and reconstructing terms can be lossy if you e.g. unpack polymorphic values, instantiate them, then repack.
11:16:51 <merijn> frohe: Those can convert between types
11:16:56 <frohe> ok, let me try again :)
11:17:07 <merijn> frohe: You might want to explicitly write down the type for weiner
11:17:21 <bennofs> monochrom: Wow, I boomarked your site. Really enlightening :p
11:17:29 <merijn> frohe: That way GHC will yell at you if your code has a different type (instead of inferring a correct, but unusable type)
11:17:35 <monochrom> thank you for choosing monochrom!
11:18:06 <aristid> next time, remember to choose monochrom again and enjoy the monochrom satisfaction guarantee
11:18:23 <frohe> merijn, i first tried: wiener :: Num a => Integer -> Integer -> Maybe (a,a)
11:18:38 <Eduard_Munteanu> josephjnk: to contrast, Agda tends to shove information about the type onto the constructor as implicit parameters, so arguably the constructor says all there is to say
11:19:25 <merijn> frohe: Right, so if it complains that you're using Integer where it expects Floating (i.e. when using /), then you just convert using fromIntegral there
11:19:37 <bearclaw_> I'm having a hard time with MVector, what should be the signature if I only want mutable array of int type? http://lpaste.net/97968 can't figure out which is Int
11:19:43 <Eduard_Munteanu> But yeah, a reference would be good before we make wild guesses like that ^. :)
11:20:02 <yyyyy> Eduard_Munteanu, is this a consequence of the dependent typing inference rules or is it an implementation choice?
11:20:06 <frohe> merijn, but ghci complained again that Could not deduce (a ~ Integer)  from the context (Num a)
11:20:19 <josephjnk> Eduard_Munteanu: That might have something to do with it. Looking back, I heard the term when looking up dependent types here: http://www.haskell.org/haskellwiki/Dependent_type
11:20:21 <merijn> frohe: Then you're returning Integer in your code
11:20:45 <merijn> frohe: i.e. you need to use fromIntegral on the result to make it polymorphic
11:21:10 <josephjnk> Pattern matching is contrasted with "Views" in Epigram, which I wasn't able to wrap my head around... I'm relatively new to the high level, strongly typed thing
11:21:34 <merijn> frohe: Haskell doesn't do silent type coercion, so Integer is never automatically "upcast" to some other type. So if your code is working with Integer and you want to return a polymorphic type (like "Num a"), you'll have to convert explicitly
11:21:41 <Eduard_Munteanu> yyyyy: directly, a consequence of the way scoping works... but it's made possible by having first-class constraints, unlike Haskell.
11:22:10 <merijn> josephjnk: Haskell's pattern guards are the weaker little brother of Epigram views
11:22:27 <alabaster> hey guys, I was wondering if anyone was able to function type hints in emacs. For example wirting toUpper will show me function type somewhere below the buffer.
11:22:29 <Eduard_Munteanu> Is that like view patterns?
11:22:54 <frohe> merijn, thank, i'll use again fromIntegral function everywhere
11:22:59 <merijn> alabaster: There's ghc-mod which can do that for vim, so presumably wrote an emacs thing for it too
11:23:28 <alabaster> merijn: thank you, I was using haskell-mode, got to check that.
11:23:35 <frohe> merijn, i was looking for another way, to write less code
11:24:31 <Eduard_Munteanu> yyyyy: in other words you can pass equality proofs around, pass types as parameters to data constructors and so on
11:25:03 <Komier> http://www.haskell.org/haskellwiki/Emacs
11:25:23 <monochrom> frohe: "wiener :: Integer -> Integer -> Maybe (Integer, Integer)" does not need fromIntegral. "wiener :: Num a => a -> a -> Maybe (a,a)" does not need fromIntegral either. but you're cross-breeding them.
11:26:03 <merijn> monochrom: That's not sufficient, he uses both div, mod and /, he'll have to convert somewhere
11:26:05 <josephjnk> I guess what I don't understand is, are the things that would be enabled by epigram's views actually beneficial? I can't think of a case where I'd want to reconstruct the exact pattern that was matched unless I was doing something that I probably shouldn't be
11:26:05 <alabaster> merijn: awesome, works!
11:26:21 <yyyyy> Eduard_Munteanu, thank you. I guess at this point I don't understand enough of Agda to realize the sort of idioms this leads to. I'll look more into it :)
11:26:33 <monochrom> then that's worse than cross-breeding
11:26:55 <merijn> Well, yes
11:26:58 <monochrom> it's like a fornication party of a horse, a snake, and a dragon
11:27:20 <Eduard_Munteanu> yyyyy: for example   record Foo {l : Level} (A : Set l) : Set l where field Bar : A -> A   gives you a   Bar :: {l : Level} -> (A : Set) -> (A -> A) -> Foo {l} A   if you don't open the record module explicitly.
11:27:52 <Eduard_Munteanu> Err, a constructor I mean.
11:28:35 <Eduard_Munteanu> ... where constructor Bar; field bar : ...
11:29:08 <josephjnk> for context, I'm looking into this because I'm working on a library/mini language for declarative data processing. It's aimed at sanitizing and typing inputs for data-driven coding in Javascript
11:29:25 <Eduard_Munteanu> Anyway, the reason that's possible is because you can pass those types as parameters in the first place.
11:29:27 <josephjnk> I'm not sure if this is a feature that's irrelevant, or if I'll regret leaving it out in 6 months
11:30:04 <monochrom> I bet that both will be true.
11:30:19 <josephjnk> lol
11:32:32 <yyyyy> Eduard_Munteanu, sorry for the notational confusion, but what does {} marks versus ()? If I'm understanding correctly this means that defining a record is only notational convenience to a sort of 'curried type-level function'?
11:32:50 <Fuuzetsu> yyyyy: {} are implicit arguments
11:32:51 <Eduard_Munteanu> yyyyy: {} is implicit parameters
11:33:26 <Eduard_Munteanu> yyyyy: no, it's like constructors yield functions in Haskell.
11:33:40 <yyyyy> Fuuzetsu, Eduard_Munteanu thank you. that was quick.
11:33:40 <Eduard_Munteanu> data Foo a = Bar (a -> a)
11:33:53 <Eduard_Munteanu> Bar :: (a -> a) -> Foo a
11:35:53 <josephjnk> It looks like I'll be looking through the Epigram tutorial. Thanks for the help.
11:36:45 <yyyyy> hm, i think i see the benefit now. you can carry around much more information of the computation types that led to that point. i'm assuming this is what leads to e.g. types carrying array sizes.
11:37:29 <Eduard_Munteanu> yyyyy: yeah, though for that alone, you can already do it in Haskell :)
11:37:49 <Eduard_Munteanu> In GHC Haskell.
11:38:20 <yyyyy> How come? I thought I couldn't use types as values in Haskell.
11:40:28 <Eduard_Munteanu> yyyyy: see the DataKinds extensions. Aside from the type-level naturals GHC gives you, you can define kinds inductively just by saying "data N = Z | S N" which gives both a normal type N and a kind N with types Z :: N and S :: N -> N (the rhs'es are kinds, sure)
11:40:49 <yyyyy> data Nat = Z | S Nat is not the same I think, even if I extend it to a larger usage - i.e. Nat `plus` Nat.
11:40:56 <yyyyy> ah
11:41:33 <yyyyy> sorry, your message took a while. I'll look into the extension.
11:41:45 <Eduard_Munteanu> yyyyy: you can do it even without DataKinds but it's not as nice... data Z; data S n
11:43:04 <Eduard_Munteanu> (because you have Z :: *, S :: * -> *, which is eww)
11:43:24 <Eduard_Munteanu> (it needs EmptyDataDecls though)
11:43:40 <yyyyy> pattern matching would explode on larger data cases, though, wouldn't it?
11:44:28 <Eduard_Munteanu> yyyyy: what pattern-matching? Note you can't match them as values, you have to use GADTs, typeclasses or type families to operate on those.
11:44:44 <allsystemsarego> @hoogle runST
11:44:45 <lambdabot> Control.Monad.ST runST :: (forall s. ST s a) -> a
11:44:45 <lambdabot> Control.Monad.ST.Lazy runST :: (forall s. ST s a) -> a
11:44:45 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
11:45:00 <yyyyy> Eduard_Munteanu, cumbersome.
11:46:02 <allsystemsarego> @hoogle writeSTRef
11:46:02 <lambdabot> Data.STRef.Lazy writeSTRef :: STRef s a -> a -> ST s ()
11:46:02 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
11:46:15 <Eduard_Munteanu> yyyyy: you can use a GADT to construct a bounds proof, then you pass it around
11:48:09 <Eduard_Munteanu> yyyyy: you should be able to write stuff like   vecLookup :: Fin n -> Vec a n -> a  where Fin n represents a natural less than n.
11:49:18 <Eduard_Munteanu> data Vec :: * -> Nat -> * where Nil :: Vec a 0; Cons :: a -> Vec a n -> Vec a (n + 1)
11:52:22 <Eduard_Munteanu> data Fin :: Nat -> * where Zero :: Fin (n + 1); Succ :: Fin n -> Fin (n + 1)
11:53:46 <Eduard_Munteanu> Someone should make a fake deptypes stuff library for Haskell, now that I think about it.
11:56:01 <Eduard_Munteanu> Actually with singleton types you should be able to write   data Fin :: Nat -> * where Fin :: Sing k -> Fin (n + k + 1)
11:56:24 <yyyyy> Eduard_Munteanu, i'm having to turn on TypeOperators as well.
11:56:32 <Eduard_Munteanu> Yeah, for (+).
11:57:23 <Eduard_Munteanu> Not entirely sure the current implementation of type-level nats are nice to work with, since they're type families and may cause issues. You can define them yourself then and use S instead of + 1.
11:57:42 <yyyyy> there'so some scope errors in the example. i can't compile it.
11:58:18 <Eduard_Munteanu> yyyyy: can you pastebin the code as you wrote it?
11:58:23 <yyyyy> what's a good reference to understand GHC's support for this?
11:58:36 <Eduard_Munteanu> yyyyy: the GHC manual is alright
11:59:02 <Eduard_Munteanu> yyyyy: http://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html
11:59:40 <yyyyy> Eduard_Munteanu, sure. here it is: http://lpaste.net/97970
12:00:08 <Eduard_Munteanu> yyyyy: you need   LANGUAGE GADTs
12:00:21 <Eduard_Munteanu> yyyyy: also   import GHC.TypeLits
12:00:58 <Eduard_Munteanu> Assuming you have GHC 7.6.x
12:01:27 <yyyyy> had to add KindSignatures as well, but it typechecks now!
12:01:35 <Eduard_Munteanu> Ah yeah.
12:02:58 <yyyyy> interesting. i'll try to read through the linked paper on the one you sent, at http://dreixel.net/research/pdf/ghp.pdf.
12:03:28 <Eduard_Munteanu> Hm, I haven't. :)
12:03:32 <yyyyy> thanks for the patience :)
12:03:39 <aristid> it appears to be a fashion to use single characters repeated multiple times as the nick recently. :P
12:03:41 * Eduard_Munteanu should, perhaps
12:04:16 <Eduard_Munteanu> Maybe they're compression-friendly nicks. :P
12:04:44 <Eduard_Munteanu> You can't really RLE Eduard_Munteanu.
12:06:28 <yyyyy> it was more as λy.yyyyy
12:06:28 <yyyyy> , a somewhat useless combinator. a stupid joke with my industrial design degree. i'm not a computing scientist, though after haskell i like type theory to the point of reading articles.
12:08:16 <yyyyy> (and recently got hott, and pierce's two books on types)
12:09:08 <merijn> yyyyy: Have you read Fun with Type Functions?
12:09:16 <merijn> yyyyy: That goes into type families in haskell
12:10:05 <yyyyy> merijn, i think you mentioned it the other day. i downloaded it but haven't read it yet.
12:10:07 <Komier> oh my god i got Vim running
12:10:10 <Komier> miracle lol
12:10:19 <Eduard_Munteanu> yyyyy: FWIW, if you want dependent types, Agda is cleaner and more natural at that, besides being a lot more powerful
12:10:34 <Eduard_Munteanu> That is, as long as you only want your code to typecheck. :)
12:11:08 <bernalex> are there any hackage responsible people here?
12:11:22 <yyyyy> Eduard_Munteanu, I was deciding upon agda or idris as next hobby languages, with haskell having already overtaken python for mundane tasks.
12:11:46 <Eduard_Munteanu> "hackage responsible" sounds like "eco-friendly" :P
12:11:49 <yyyyy> agda seems more unicode-mad in its code in my opinion, though i reckon it's a cultural thing.
12:11:52 <mirpa> Wow, I've just realized how clever record syntax is - it says nothing about internal data representation so you can change it at will.
12:11:53 <Eduard_Munteanu> There should be, yes.
12:11:59 <Eduard_Munteanu> bernalex: there's #hackage too
12:12:08 <bernalex> Eduard_Munteanu: I'll just email
12:12:51 <theorbtwo> yyyyy: As in "everything is unicode-clean", or as in "you need to input unicode characters to program idiomatially"?
12:13:23 <yyyyy> theorbtwo, i think the latter, though keeping your codes in the former might help :p
12:14:30 <Eduard_Munteanu> yyyyy: unicode is handy if you want the code to look like the original thing you're proving / writing, Coq is awkward to read as math
12:14:49 <yyyyy> i saw some proofs in agda that looked like typeset latex. i can't imagine what someone would have to go through to code like this. is it a \U+XXX thing in emacs?
12:14:54 <yyyyy> for every codepoint?
12:15:38 <Eduard_Munteanu> yyyyy: absolutely not, agda-mode has \ expansions to type characters similar to LaTeX, e.g. \nu for nu
12:16:25 <lllllllllllll> can someone help me with http://lpaste.net/6501104104020901888 trying to map over a list in the state monad
12:16:48 <yyyyy> a while ago seeing agda - and being an industrial designer - i tried empirically to set up a keyboard encoding for it based on common math characters.
12:17:01 <Eduard_Munteanu> yyyyy: that is, you type \nu, but it inserts the symbol
12:17:06 <yyyyy> coming to think of it i should have used character frequency in codebases... https://github.com/yghor/Progrorak
12:17:35 <ion> lllllllll: What do you want to do with the value?
12:17:47 <lllllllllllll> like map (+1) xs
12:18:21 <ion> What do you want to do with that value?
12:18:36 <ion> Just computing it will do nothing more than heat your room slightly.
12:18:51 <dv-> lllllllllllll: put (map (+1) xs)
12:19:01 <Eduard_Munteanu> yyyyy: note Epigram not only uses unicode as well, it also requires laying things out in a specific fashion, like in typing rules
12:19:26 <Eduard_Munteanu> So it does require a special editor (mode, at least).
12:19:38 <lllllllllllll> ion, this is small example...i didn't want to paste the whole code i need it in
12:19:46 <yyyyy> Eduard_Munteanu, : colon is on your strongest finger, with the arrow → right next to it to enable chording - e.g. you logically then progress from outer to inner finger to declare types.
12:20:09 <yyyyy> Eduard_Munteanu, ah, but then you would need editor support. i don't think this can be encoded on a keyboard.
12:20:30 <yyyyy> (obviously)
12:20:48 <ilmig> Hi, what is the idiomatic way to create the cartesian product of two sum types? Or, to give an example: http://lpaste.net/97971
12:20:53 <ilmig> (warning: Haskell beginner here, didn't exactly know what to google for...)
12:21:21 <lllllllllllll> dv-, thanks but i get http://lpaste.net/6501104104020901888
12:21:33 <Eduard_Munteanu> yyyyy: yep... but you sorta need editor support for all dependently typed provers, it's very annoying to use one without holes, tactics or looking up information about types and terms.
12:21:34 <ion> ilmig: (Car, CarManufacturers)
12:21:37 <Thooms> ilmig: type Car = (Foo, Bar)
12:21:46 <ion> err, (Color, …)
12:21:55 <ilmig> thanks, that was easy :)
12:22:02 <ilmig> is there a specific name for this feature?
12:22:04 <yyyyy> Eduard_Munteanu, 'one without' meaning anything that is not emacs i suppose :p
12:22:10 <Thooms> ilmig: type aliases
12:22:25 <ion> (Foo, Bar) is a tuple, “type Baz = Quux” is a type alias
12:22:28 <Eduard_Munteanu> yyyyy: heh, possibly... Coq has a special IDE though.
12:22:48 <ilmig> thanks, this will help me to read about this :)
12:23:05 <Eduard_Munteanu> ilmig: more commonly they're called type synonyms
12:23:27 <ion> lllllllllll: data X = X [Int] deriving (Show, Functor), put (fmap (map (+1)) xs)
12:23:53 <ion> lllllll: You’re working on an X [Int], not on an [Int].
12:23:55 <nooodl> i'd write "data Car = Car Color Manufacturer"
12:24:24 <dv-> lllllllllllll: http://lpaste.net/97972
12:24:45 <dv-> lllllllllllll: or what ion did
12:25:20 <ilmig> nooodl: ahh, now I get why this is called a product type :)
12:25:24 <lllllllllllll> ion, oh right, thanks
12:25:25 <bearclaw_> 404 on http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Generic-Base.html
12:25:36 <binroot> @pl \(x,y) -> concat x y
12:25:36 <lambdabot> uncurry join
12:25:46 <binroot> @pl \(x,y) -> f x y
12:25:46 <lambdabot> uncurry f
12:27:08 <lllllllllllll> dv-, thanks
12:28:52 <dv-> lllllllllllll: you can also just pattern match
12:29:11 <dv-> (X xs) <- get; put (X (map (+1) xs))
12:30:09 <lllllllllllll> dv-, yeah, my mistake was taking X [Int] for [Int]
12:30:55 <lllllllllllll> "You’re working on an X [Int], not on an [Int]"
12:32:18 * hackagebot MonadCatchIO-mtl 0.3.1.0 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.1.0 (DanielGorin)
12:35:40 <Komier> gah
12:36:06 <SrPx> ion: thanks
12:36:36 <SrPx> ion: but the gist is invalid
12:42:18 <Komier> Anyone use Haskell plugins for Vim?
12:43:52 <derdon> Komier: yes.
12:44:49 <derdon> Komier: this one is quite cool: https://github.com/Twinside/vim-haskellConceal
12:45:03 <Komier> do you just download the files from github and put them in your plugin folder?  Or do you have to manually edit the vimrc file?
12:45:18 <zipper> http://www.urbandictionary.com/define.php?term=poopsock
12:45:30 <derdon> Komier: I install vim plugins always manually, perhaps not the best way
12:46:33 <Komier> ok ta
12:46:41 <Feuerbach> Komier: I recommend pathogen for plugin installation
12:47:37 <Komier> I just found that as you said it Feuerbach, thanks! :)
12:48:21 <yesthisisuser> I use something called vundle for Vim to manage plugins. It's pretty easy
12:48:28 <Feuerbach> as for the actual vim plugins, I use donri's vim2hs and my own vim-hs-module-name and ariadne-vim
12:50:27 <hpc> it's kind of a bummer that vim's :! doesn't do shell completion
12:50:32 <hpc> only files/directories
12:50:49 <dwcook> hpc, it does.
12:51:03 <dwcook> At least, mine does.
12:51:08 <yesthisisuser> what is haskell conceal doing?
12:51:09 <Komier> tbh I'm clueless about all of it, but I thought i'd give it a whirl
12:51:35 <hpc> dwcook: odd; i tested with ghc-man-completion and couldn't get -X to expand to anything
12:52:02 <dwcook> hpc, ah, I must have misunderstood what you meant. Though, are you sure your normal shell would expand that?
12:52:12 <hpc> it does
12:52:17 <Komier> The only vim folder i can find is in usr/share/vim
12:52:26 <dwcook> Okay, then I simply misunderstood. I thought you meant the actual command name.
12:52:30 <hpc> @hackage ghc-man-completion
12:52:31 <lambdabot> http://hackage.haskell.org/package/ghc-man-completion
12:52:59 <hpc> it outputs a file that you can source in .bashrc
12:53:03 <hpc> parsed from the ghc man page
12:57:03 <pavonia> For types that can have two different Functor instances, is there a typeclass that represents some kind of secondary Functor instance?
12:57:33 <simpson> pavonia: A type shouldn't be able to have two different Functor instances.
12:57:41 <simpson> Could you give an example?
12:57:54 <pavonia> (a, b)
12:58:29 <pavonia> :t fmap succ (10, 20)
12:58:29 <lambdabot> (Enum b, Num t, Num b) => (t, b)
12:58:33 <pavonia> > fmap succ (10, 20)
12:58:34 <lambdabot>  (10,21)
12:58:41 <simpson> fmap f (a, b) = (a, f b)
12:58:42 <hpc> doesn't parametricity guarantee that if a type has a valid Functor instance, it has exactly one such instance?
12:58:44 <simpson> What's the other instance?
12:58:47 <simpson> hpc: Yeah, it does.
12:59:02 <pavonia> simpson: Mapping over the first value
12:59:14 <simukis_> simpson: I suppose he wants (f a, f b), or (f a, b)
12:59:17 <Feuerbach> pavonia: perhaps you're looking for Bifunctor
12:59:19 <simpson> pavonia: Can't do that in Haskell using Functor, because of the kind of Functor.
12:59:40 <pavonia> simpson: That's why I'm aksing for another typeclass
12:59:53 <pavonia> Feuerbach: Thanks, I'll have alook
13:00:10 <simpson> Bifunctor might be it. http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
13:00:40 <pavonia> Yeah, exactly what I need, thanks!
13:00:58 * hpc waits patiently for Data.Septuacentifunctor
13:03:17 <wXeno> hi, any of you aware of any pretty active language independent language theory channel?
13:03:57 <allsystemsarego> > (succ &&& succ) (10,20)
13:03:58 <lambdabot>  No instance for (GHC.Show.Show t1)
13:03:58 <lambdabot>    arising from a use of `M64869250218472395837345.show_M64869250218472395837...
13:03:58 <lambdabot>  The type variable `t1' is ambiguous
13:03:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:03:58 <lambdabot>  Note: there are several potential instances:
13:05:29 <Feuerbach> wow, that succs
13:05:33 <Thooms> :D
13:05:57 <allsystemsarego> > (succ *** succ) (10,20)
13:05:58 <lambdabot>  (11,21)
13:06:21 <Happy0> waht ease zease '***' ;x
13:06:33 <allsystemsarego> :T (***)
13:06:40 <allsystemsarego> :t (***)
13:06:40 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:07:13 <Happy0> hhmmm :|
13:07:45 <pavonia> :t (***) `asAppliedTo` (undefined :: a -> b)
13:07:46 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
13:10:08 <allsystemsarego> @hoogle asAppliedTo
13:10:08 <lambdabot> No results found
13:10:33 <Hafydd> @index asAppliedTo
13:10:33 <lambdabot> bzzt
13:10:41 <Lethalman> it's in lambdabot
13:10:51 <Lethalman> mh no
13:10:55 <dwcook> @type asAppliedTo
13:10:55 <lambdabot> (a -> b) -> a -> a -> b
13:11:05 <flebron> What does Cabal mean when it asks "Include documentation on what each field means (y/n)"? Fields of what?
13:11:13 <dwcook> flebron, the fields in the cabal file.
13:11:29 <flebron> Include this documentation where, in the console output? In the cabal file?
13:11:36 <dwcook> In the cabal file, I believe.
13:12:00 <dwcook> You can also check the online cabal documentation.
13:12:02 <flebron> Ah, OK. I assume I can look up what each field means online :p
13:12:07 <dwcook> Yep.
13:12:13 <dwcook> I think it gives you the url too.
13:12:23 * hackagebot hopenpgp-tools 0.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.1 (ClintAdams)
13:12:23 <ion> asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a }; infixl 0 `asTypeIn`; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x); infixl 0 `asAppliedTo`
13:12:50 <dwcook> Yeah, included in the cabal file is this: http://haskell.org/cabal/users-guide/
13:13:02 <dwcook> Regardless of whether you include documentation or not.
13:16:14 <kylcarte> has anyone here used ekmett's Linear.V ? I'm having a terrible time getting all the kinds to line up
13:16:34 <flebron> Is there no way to have Haddock comments on GADT ctors?
13:17:05 <binroot> @pl (\(v,w) -> f (g v w) w)
13:17:05 <lambdabot> uncurry (join . (f .) . g)
13:17:23 * hackagebot commsec-keyexchange 0.3 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.3 (ThomasDuBuisson)
13:22:24 * hackagebot commsec-keyexchange 0.3.1 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.3.1 (ThomasDuBuisson)
13:26:06 <flebron> Ouch, Haddock throws a parse error when faced with my KindSignature. :s
13:26:27 <Komier> you Vim users use it in terminal or via the Gui?
13:26:58 <allsystemsarego> the gui being gvim?
13:26:59 <zett_zelett> I use it in the terminal.
13:27:03 <Komier> aye gvim
13:27:11 <allsystemsarego> terminal
13:27:25 <zett_zelett> But then again, I don’t use a desktop, so it’s more natural, I guess.
13:27:36 <zett_zelett> Desktop environment, that is.
13:27:58 <Komier> Don't use a desktop?
13:28:00 <allsystemsarego> gvim is a transitional compromise to attract IDE people
13:31:14 <zett_zelett> Yeah, I use i3.
13:31:28 <zett_zelett> I assume people here rather tend to use xmonad, though.
13:32:31 <zipper> I use kwin
13:32:46 <Clint> :t mempty `asAppliedTo` compare
13:32:47 <lambdabot> (Ord a, Monoid b) => (a -> a -> Ordering) -> b
13:33:30 <tippenein> curious, is the reason liftM1,M2,M3,M4,M5 exist because haskell is lazy and can't generalize this?
13:33:37 <benmachine> tippenein: no
13:33:42 <benmachine> nothing to do with laziness
13:33:47 <nisstyre> tippenein: it's because of the type system
13:34:03 <benmachine> but... you can generalise it, in a sense
13:34:10 <tippenein> ok, that makes sense
13:34:18 <benmachine> I mean, it depends what you're thinking of as a generalisation
13:34:19 <tippenein> seems like one of those things you can generalize around tho
13:34:33 <tippenein> liftM where lifting a function to any amount of monads
13:34:56 <flebron> Consider the type of liftM.
13:35:03 <benmachine> but liftM2 f is different from liftM3 f, how would it know which to use?
13:35:11 <flebron> What would it be? What would it take as a parameter, and what would it output?
13:35:24 <benmachine> flebron: I wouldn't call it liftM, because that's already a thing :P
13:35:34 <flebron> OK, liftMagic then.
13:35:38 <flebron> What would its type be?
13:36:22 <benmachine> I could type it in Agda
13:36:37 <benmachine> but that's another thing entirely
13:36:49 <tippenein> liftM :: Monad m => ([a] -> r) -> m [a] -> m r
13:36:49 <Thooms> you indeed need dependant types
13:37:01 <tippenein> oh, I see
13:37:27 <benmachine> tippenein: that's a function which exists
13:37:31 <benmachine> indeed, is even called that :P
13:37:54 <flebron> (Only a bit more general :p)
13:37:57 <tippenein> I was just thinking of a list of functions and monads
13:38:16 <benmachine> tippenein: fyi a value of type "m a" is not a monad
13:38:28 <benmachine> for a thing to be a monad it has to be a type constructor
13:38:33 <benmachine> e.g. Maybe
13:38:47 <tippenein> m is the monad, a is the value it takes, correct?
13:39:03 <shachaf> a is a type, not a value.
13:39:51 <tippenein> ah... that's why you can't generalize it I suppose, because each a and m are dependent
13:39:59 <shachaf> ?
13:40:15 <tippenein> :t liftM3
13:40:16 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
13:40:29 <shachaf> You might ask a similar question about, say, composition: I can write dot :: (b -> c) -> (a -> b) -> a -> c, and dot3 :: (c -> d) -> (b -> c) -> (a -> b) -> a -> d, and so on, if I want.
13:40:35 <allsystemsarego> it's an arity thing
13:41:02 <benmachine> you might ask a similar question about birds: what are birds? we just don't know.
13:41:11 <tippenein> lolwhut
13:41:23 <shachaf> But writing something that takes n arguments is kind of strange, for the most part. And people prefer to write (f . g . h) instead of (dot3 f g h).
13:41:33 <shachaf> benmachine: Yes, exaactly.
13:41:50 <SrPx> I'm just wondering, if we redefine foldl such that it receives an additional argument, an index for list access... and the recursion happens by decreasing that index... and the stop condition is when idx is 0 (not when arr = nil)... then can it now operate on infinite lists ?
13:41:52 <benmachine> tippenein: once upon a time I'd've given you a youtube link but then APPARENTLY there's this thing called "copyright law" :(
13:42:12 <tippenein> :C
13:42:18 <SrPx> (in other words, it receives the array length and decreases it until it reaches 0)
13:42:21 <tippenein> now I'll never know what birds are
13:42:21 <SrPx> list*
13:43:44 <sjoerd_visscher> Could not deduce (d2 ~ d3) from d ~ (1 + d2) .. or from d ~ (1 + d3)
13:43:49 <shachaf> http://www.youtube.com/watch?v=Kh0Y2hVe_bw
13:43:55 <allsystemsarego> SrPx, you want to apply foldl to the result of a takeWhile
13:44:02 <benmachine> shachaf: <3
13:44:04 <sjoerd_visscher> that's from GHC 7.8, am I doing something wrong?
13:44:15 <sjoerd_visscher> GHC 7.7 I mean
13:44:17 <rasfar> SrPx: I think precomposing with (drop n) would be more idiomatic
13:44:25 <Komier> does anyone know of any good Vim newbie guides? :)
13:44:30 <SrPx> rasfar: allsystemsarego I see, that makes sense. Thanks!
13:44:43 <croyd> Komier: vimtutor
13:44:51 <Komier> croyd : ty
13:45:30 <zett_zelett> Komier: There are a lot of vim cheatsheets out there which I found helpful. I don’t know much vim though.
13:45:44 <SrPx> Komier: learn about :w :e :q, learn all keys for the 2 main modes using a keyboard cheat sheet and practice a lot - is better than any guide IMO. VIM is a motor skill not a knowledge
13:46:05 <zett_zelett> Komier:  Also, http://www.vim.org/
13:46:38 <hpc> http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118 -- you might also read this once you have had a week-ish to get used to vim
13:46:52 <Komier> ty guys :)
13:46:57 <rasfar> it would be neat to see stats on peoples' Vim use, whether there's trends with PLs used etc.
13:47:02 <SrPx> Komier: also there's #vim . Also learn how to write .vimrc and remap keys. And please remap R or something to a command that will compile your code and show it on your screen, that is awesome.
13:47:06 <erider> :x is mine :-)
13:47:21 <zipper> Its late. I go sleep now. Good night.
13:47:44 <rasfar> i use a very small subset of Vim commands -- probably 15-20 in all
13:48:21 <Komier> SrPx: I been installing plugins and playing with my .vimrc.  Seems relatively straight forward to change things in there.
13:49:51 <croyd> Komier: Syntastic is a really great plugin if you haven't run into it yet
13:50:05 <croyd> Komier: and NERDTree
13:50:13 <startling> SrPx, did you figure out your vagrant stuff?
13:50:38 <SrPx> Komier: yea once you get that it is pretty much up to you and your creativity to get the most comfortable setting. I've remapped every key that is not directly around asdf/jkl so it now is, including special characters. That helps a lot as VIM's idea is never to move your hands and never look the keyboard
13:50:41 <startling> SrPx, I saw your question and went to answer it but I think you were gone (or had netsplit from me) at that point.
13:51:32 <SrPx> startling: vagrant worked, thanks. I was trying to use Haste but that now is what don't work, I think I will try to reinstall everything later... now I'm again trying to implement stream fusion on my language instead. I'm really lost
13:51:47 <startling> SrPx, why did you need vagrant?
13:52:24 <flebron> If my project uses KindSignatures, is there a way to still use Haddock?
13:52:37 <SrPx> for GHCJS, it seems promising but I'm not sure I'm willing to accept my 1kb apps will now have 2mb because I can't optimize my own compiler and have to turn to haskell
13:53:13 <Komier> croyd: i think i have Syntastic installed.  Assuming my Pathogen is working correctly.
13:53:29 <startling> SrPx: oh, the supported way to do GHCJS is in a vagrant machine? weiiird
13:53:35 <Thooms> @pl (\p -> return . (processConfigCandidate <=< (showLeft . parseConfig)) =<< readFile p)
13:53:35 <lambdabot> ((processConfigCandidate <=< (showLeft . parseConfig)) `fmap`) . readFile
13:53:55 <SrPx> startling: yes, really weird! They haven't officially released though so I can't blame them
13:54:00 <startling> SrPx (fwiw the directory with yr Vagrantfile is mounted as /vagrant automatically)
13:54:11 <SrPx> I'm angry that Haste won't work. I don't understand, Cabal never works for me.
13:54:27 <startling> SrPx: I guess it makes sense so you don't conflict with your existing ghc
13:54:37 <SrPx> startling: yea, in case of ghcjs they renamed the shared folder
13:55:42 <startling> SrPx: ah.
13:56:16 <conklech> I've got a question about the current (GHC 7.6) implementation of type-level strings. With optimization on, 'fromSing (sing :: Sing "s")' _almost_ compiles to 'unpackCString# "s"', but there's a cast in the Core that looks redundant to me--it casts from String to String.
13:56:24 <conklech> Example code is at http://lpaste.net/97977
13:56:44 <startling> conklech, I think it might be a DataKinds thing
13:56:59 <conklech> Yeah, that's what I'm doing.
13:57:03 <startling> conklech, iirc how DataKinds works is that it creates a type and a kind with identical names
13:57:07 <SrPx> startling: (:
13:58:06 <vrih> I've been hitting my head against a brick wall all day trying to get testing working with cabal today and I'm nearly there. does anyone have a bit of experience?
13:58:12 * SrPx is still sure somewhere in the world there is exactly what he needs and I'm wasting my night reinventing the wheel I don't know :(
13:58:27 <vrih> my test file is tests = testCase "t" $ assertEqual "1-2" 1 2 main = defaultMain tests
13:58:28 <conklech> If you look at the example, the Core contains two values: s1 = unpackCString# "s"; s = s1 `cast` ...
13:58:44 <startling> vrih: are you using the not-exitcode testing method with cabal?
13:59:00 <vrih> it fails correctly in ghci but cabal always says the test passes
13:59:10 <vrih> startling: I'm using exitcode-stdio
13:59:13 <startling> oh, ok.
14:00:18 <conklech> The problem is that the `cast` blocks further optimization. In particular, I want a Text value; but the RULE to inline building Text from unpackCString# can't fire with the intermediate cast.
14:02:08 <startling> conklech: interesting.
14:02:08 <conklech> So the whole pack function from Data.Text gets inlined, and it's a big mess.
14:02:26 <startling> conklech: you might try #ghc
14:02:35 <conklech> Okay.
14:02:46 <conklech> I didn't see that on the list.  :)
14:02:47 <startling> conklech: sorry, wish I could help. :(
14:03:07 <conklech> No problem. It's a bit arcane.
14:04:19 <adimit> @pl \a b -> k n a b
14:04:19 <lambdabot> k n
14:04:23 <adimit> XP
14:04:45 <adimit> @pl \a b -> k n (f a) (f b)
14:04:45 <lambdabot> (. f) . k n . f
14:05:08 <adimit> I think this calls for applicative.
14:06:49 <adimit> or actually just lambdas. lambdas aren't toxic.
14:07:20 <mauke> k n `on` f
14:07:56 <vrih> startling: after hours of struggling it turned out to be how a module was named. I'm definitely struggling with the lack of documentation on what should be fairly standard tools in haskell.
14:08:08 <vrih> Determined to get there in the end though
14:08:15 <startling> vrih: what did you name the module?
14:08:16 <adimit> mauke: right! I completely forgot about on.
14:08:18 <adimit> thanks.
14:08:37 <vrih> startling: I didn't realise that the main Test module needed to be named Main
14:08:56 <startling> vrih: oh. yeah, it does.
14:08:59 <startling> vrih: sorry. :(
14:09:12 <startling> vrih: anything with a "main" that you want to be run needs to be named Main
14:09:15 <vrih> startling: I had it named similar to the module that the tests related to
14:09:33 <vrih> startling: It's just a case of getting used to the structure of a haskell project
14:10:33 <startling> vrih: yeah. it
14:10:42 <startling> 's definitely strange that the tests just weren't run.
14:11:43 <startling> (maybe your other main was being run? idk.)
14:13:55 <vrih> startling: there are definitely things I like about haskell. it just needs more people using it so there will be better entry level blogs
14:14:17 <Komier> Don't wish to bore anyone, but does one of you Vim guys fancy letting me see their .vimrc file with the haskell settings?
14:15:06 <nisstyre> Komier: did you read this? http://projects.haskell.org/haskellmode-vim/
14:15:34 <eikke> Komier: https://github.com/NicolasT/dotvim contains mine
14:15:41 <Komier> ah no, didn't see that page, only found the one on github, which is slightly different.
14:15:49 <Komier> ty both
14:16:03 <nisstyre> Komier: you can also get vim-style keybindings in ghci
14:18:24 <edwardk> kylcarte: what're you trying to do?
14:21:13 <eikke> huh, this sucks. I have some code (ghc 7.6something) which works when compiled to binary, but not when running in ghci
14:21:46 <eikke> receiving data from the network fails in ghci, succeeds in compiled form
14:22:51 <pavonia> eikke: Are you on a Windows system?
14:24:42 <eikke> pavonia: nope
14:25:21 <lispy> eikke: any C libraries involved?
14:25:49 <NemesisD> anyone ever written haskell bindings to c libraries?
14:25:51 <lispy> eikke: try running ghci with the -fno-ghci-sandbox flag. Does that fix it?
14:26:50 <eikke> lispy: no C libs, might try that sandbox thing later
14:29:53 <frege> is there something like goroutines in haskell?
14:30:00 <frege> or coroutines
14:30:06 <frege> or gevent from python
14:31:46 <eikke> frege: why would you want that?
14:31:54 <Luke> hey guys. Just posted my Haskell startup to HN. Would you all mind up voting it? https://news.ycombinator.com/newest - it's the "Show HN: Simple Race Registration (Haskell, PostgreSQL, JS)"
14:32:26 <Taneb> frege, if I remember what coroutines are, I think you just want to return a list
14:32:31 <Taneb> See Data.List.unfoldr
14:33:36 <frege> I want child processes that I can control
14:33:36 <NemesisD> frege: do you actually mean a child process or a thread?
14:33:36 <NemesisD> haskell chas Chans like go does
14:33:36 <NemesisD> you can use those for concurrent message passing
14:34:00 <frege> I mean a separate process so I can continue the main thread and e.g. keep updating another process that shows a graph and in another process log it etc.
14:34:06 <frege> oh cool
14:34:11 <Luke> Oh it's on the front page now! Thanks guys!
14:34:25 <frege> navaati: but how do you spawn off a new process?
14:34:43 <NemesisD> frege: yeah i find that my programs usually involve concurrent worker threads that message with Chans/TChans
14:35:00 <frege> NemesisD:  I meant
14:35:05 <frege> navaati: wrong nick sorry
14:35:20 <frege> NemesisD: I love that kinda design
14:35:25 <NemesisD> you mean actually fork the process and have 2 separate processes? or do you mean a main *thread* and child *thread*
14:35:25 <lispy> Luke: nice! (I don't have a HN account so I won't vote) Good luck!
14:35:37 <Luke> thank you =)
14:35:42 <NemesisD> in haskell id recommend using threads there
14:35:45 <maxiepoo> hey so I just installed lens from source and I had to install cpphs
14:35:50 <maxiepoo> shouldn't that be a dependency?
14:35:59 <frege> okay so the base code for my software is written in python NemesisD , I'm using ZMQ for communication and I can redirect data to a haskell module
14:36:03 <maxiepoo> I had to install cpphs manually*
14:36:11 <frege> NemesisD: I mean child thread
14:36:12 <edwardk> maxiepoo: oh head or something?
14:36:20 <edwardk> er on GHC head?
14:36:37 <maxiepoo> not ghc head
14:37:01 <edwardk> maxiepoo: hrmm, guess i should add build-tools: cpphs somewheere
14:37:03 <maxiepoo> I'm on ghc 7.6.3
14:37:06 <NemesisD> frege: start here http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html and then look at hackage.haskell.org/package/async-2.0.1.5
14:37:15 <maxiepoo> edwardk, thanks
14:37:19 <frege> thanks
14:37:32 * hackagebot rascal 1.1.5 - A command-line client for Reddit  http://hackage.haskell.org/package/rascal-1.1.5 (soli)
14:42:42 <Komier> hmm
14:43:30 <Komier> ghc-mod can't load hdevtools
14:43:40 <Komier> in vim, muchly odd
14:49:38 <dhrosa> does the >> operator make sense without monads w/ side effect?
14:51:29 <geekosaur> define side effect. (State's `put` isn't really a side effect...)
14:53:32 <dhrosa> oh yeah, I forgot about things like State
14:56:57 <dmwit> ?where reversedeps
14:56:57 <lambdabot> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
14:57:19 <dmwit> seems down
14:57:20 <dmwit> bummer
14:58:59 <eikke> grr, heisenbug in some client-server thing. when running the server as-is, the client fails most of the time (resource vanishing), but when i strace the server, client alsways succeeds
15:00:53 <geekosaur> sounds like a race condition of some kind, since strace slows things down a little bit
15:01:01 <pavonia> dmwit: http://packdeps.haskellers.com/reverse ?
15:01:07 <eikke> gereedy: indeed
15:01:22 <eikke> gereedy: problem is I didnt write the server, so now have to investigate that :)
15:01:50 <geekosaur> oh, that's always fun
15:02:16 <eikke> geekosaur: more exactly, it's rpcbind, so nice old-skool C
15:06:09 <pavonia> Bah, it seems I've refactored my code to much, now everything is broken :(
15:07:19 <Komier> muwahhaha
15:07:36 <Komier> got ti all working.. i think
15:21:28 <bennofs> Is anyone here using yi?
15:21:56 <Hail_Spacecake> is there something in the standard library that will do find/replace on strings?
15:22:17 <Hail_Spacecake> googling it looks like there is a replace function in Data.String.Utils
15:22:21 <Hail_Spacecake> but I don't have this on my system
15:22:26 <Hail_Spacecake> and I'm not sure if it's part of the standard library or not
15:22:51 <bennofs> it's not part of the haskell platform
15:23:02 <bennofs> You could use a regex library to do it
15:23:16 <bennofs> But that is also not in the standard library iirc
15:23:31 <bennofs> @hackage regex-tdfa
15:23:31 <lambdabot> http://hackage.haskell.org/package/regex-tdfa
15:23:49 <Hail_Spacecake> there's Text.Regex, which is available on my system
15:26:13 <bennofs> @hoogle subRegex
15:26:13 <lambdabot> Text.Regex subRegex :: Regex -> String -> String -> String
15:30:03 <flebron> Dumb question: Haddock only documents the things I export from a module?
15:30:27 <erisco> ivanm, heya
15:30:56 <watermind> just realised the GHC Runtime System is written in C (and C--)
15:31:22 <enthropy> flebron: yes unless you give some options to ignore the export list
15:31:24 <erisco> does that mean there is a C flat too?
15:31:46 <watermind> I get it that it makes sense... but I heard so many times that GHC is written in Haskell that it seems almost a bit deceiving... :/
15:33:16 <eikke> watermind: the compiler is ;)
15:33:20 <Hail_Spacecake> well the compiler is not necessarily the runtime system
15:34:21 <twiceler> watermind: Check out Github's analysis: 77% Haskell https://github.com/ghc/ghc
15:34:47 <geekosaur> the low level runtime system is in C/Cmm. higher levels of it (for example, most of the IO.Handle implementation) are in Haskell
15:34:48 <m3ga> watermind: the rutime is all about garbage collection, and scheduling threads and stuff. C is good at that.
15:35:19 <eikke> m3ga: hmh, not sure C is specifically 'good' to write a GC ;)
15:35:22 <geekosaur> and given that system services are in C and are best not reinvented (meaning, linking against libc) at some point you're going to be in C regardless
15:35:25 <flebron> enthropy: Is doing so recommended for projects on Hackage? (I was planning on uploading one, but I've never done so :p)
15:35:38 <m3ga> eikke: do you know of something better?
15:35:50 <eikke> geekosaur: actually, ocaml doesnt go through libc iirc
15:35:51 <geekosaur> or else implementing a minimalist Haskell-- that is closer to the underlying memory model and libc etc.
15:36:39 <enthropy> flebron: I dunno, there's such a pragma in http://hackage.haskell.org/package/uu-parsinglib-2.8.1.1/docs/src/Text-ParserCombinators-UU-Demo-Examples.html, but that might be wrong
15:36:40 <geekosaur> no? how often do kernel changes force them to rework things because someone's introduced a new syscall to replace the older one? (see for example stat() which has had this happen several times)
15:36:43 <m3ga> eikke: ocaml's bytecode interpreter is written in C and it links to libc
15:36:46 <enthropy> because no export list means export everything
15:36:56 <eikke> m3ga: I mean, .native units
15:37:01 <geekosaur> really, you want libc as a buffer against such things
15:37:04 <enthropy> so the ignore-exports thing won't help (if it's even the right syntax)
15:37:12 <m3ga> eikke: natice ocaml links to libs
15:37:22 <m3ga> s/libs/libc/
15:37:28 <geekosaur> linux in particular is happy to change things with wild abandon because glibc protects programs from it
15:37:48 <m3ga> geekosaur: its called progress :-)
15:38:10 <geekosaur> sure, but you still want that buffer zone or else expect stuff to break somewhat regularly
15:38:30 <m3ga> true
15:38:36 <geekosaur> linux has this right, actually: change stuff and make user programs use a well defined interface
15:38:47 <eikke> m3ga: hmh, my bad
15:39:48 <m3ga> eikke: not wanting to rub it in, but ocaml's lex and yacc equivalents (used to build the ocaml compiler) are also written in C :-)
15:42:13 <hattmammerly> So I followed along with http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and now I'm extending the bot to post the title of URLs sent to the channel. I'm having some disorganized type problems between lines 55 and 75 of http://bpaste.net/show/164765/ and I'd appreciate it if somebody could point me in the right direction!
15:42:41 <m3ga> eikke: my knowledge is old. it seems they have replaced C ocamlyacc (in C) withe menhir (in ocaml) some time in the last couple of years.
15:43:43 <danharaj> hattmammerly:
15:43:46 <danharaj> :t liftIO
15:43:47 <lambdabot> MonadIO m => IO a -> m a
15:45:28 <hattmammerly> danharaj: oh, that's even used elsewhere in the program >.> thank you, I'll try with that
15:47:07 <jcristovao> hey! is there any significant diference on GHC head / TH 2.9 with regard to the scope of types (in the same file)
15:47:13 <jcristovao> this: data Pane = Pane { paneTitle :: String, paneIndex :: Int } ; test = $(join (fmap (stringE . show) (reify ''Pane)) )
15:47:22 <jcristovao> works in ghc 7.6.3
15:47:28 <jcristovao> but not in GHC head
15:47:45 <watermind> eikke: well... isn't the runtime part of the compiler?
15:47:59 <watermind> twiceler: yes I understand the majority is haskell
15:48:06 <geekosaur> is crt0.o part of gcc or part of libc?
15:48:08 <watermind> m3ga: and yes it's a perfectly sensible choice
15:48:34 <geekosaur> (granted, the haksell runtime is more tightly tied to the compiler, because more of a runtime is needed)
15:48:39 <geekosaur> *haskell
15:48:42 <jcristovao> with works i mean compiles in 7.6, returns ‛Pane’ is not in the type environment at a reify in GHC Head
15:49:02 <watermind> geekosaur: right
15:49:40 <merijn> watermind: Most people use the runtime shipping with GHC, but there are others
15:49:41 <geekosaur> that said, the runtime doesn't change as much as the rest of the compiler
15:50:04 <vektor> http://xkcd.com/
15:50:04 <geekosaur> there have occasionally been attempts at alternative runtimes, but it's something of a nasty job
15:50:07 <merijn> watermind: house is a project with a bare metal runtime for haskell and HaLVM has a runtime that can run directly in Xen
15:50:34 <merijn> watermind: And, of course, ghcjs has a runtime implemented in Javascript
15:51:43 <watermind> merijn: I see
15:51:45 <jedai> vektor: Yes, that's an inside joke since xkcd has been using Haskell in some projects
15:52:38 <merijn> watermind: So while the runtime is tied rather strongly to the compiler you can replace it and it has been done
15:52:47 <vektor> Yeah, there's some haskell/Functional Programming jokes in xkcd every now and then lately.
15:52:56 <watermind> merijn: got it, I didn't know it was that modular
15:55:24 <jedai> vektor: Do you remember the 1st april comic that was different for different people ? That was done in Haskell for instance
15:57:15 <hattmammerly> danharaj: http://bpaste.net/show/164771/ I"m a little confused about how to use liftIO; I'm trying to apply a function that applies a transformed IO, not apply an IO
15:58:02 <vektor> no, don't remember that one.
15:58:15 <dmwit> pavonia: thanks!
15:58:26 <dmwit> ?where reversedeps
15:58:26 <lambdabot> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
15:58:48 <dmwit> ?where+ reversedeps http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html http://packdeps.haskellers.com/reverse
15:58:48 <lambdabot> It is stored.
16:01:02 <Komier> merijn: I blame you for me installing and trying Vim.  I been messing with this thing for hours now. :)
16:01:20 <Hanoi> Hi. I am trying to parse the string "(a,b) (c,d)" into two tuples of type (int,int) but I don't know how to find more information about how to do this.
16:01:47 <enthropy> jcristovao: yes they changed it
16:01:56 <danharaj> hattmammerly: where are you trying to apply the `io` function?
16:02:26 <danharaj> also you probably want `post [] = return ()`, not `privmsg [] …`. Also you can replace post with `mapM_ privMsg`
16:02:45 <jcristovao> enthropy, thanks... any useful link? a simple search for template haskell in ghc trac yield me not aparent useful resources
16:03:09 <enthropy> Smart Completions
16:03:11 <enthropy>  
16:03:32 <enthropy> https://ghc.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal is what I meant to paste jcristovao
16:03:43 <enthropy> mid-way down at "what reify sees"
16:03:53 <dmwit> Hanoi: You want it fast or easy to write?
16:03:56 <danharaj> hattmammerly: Oh I see, you have that in a comment. What you want is to put `io` in front of your do block. so `scan s = io $ do …`
16:03:59 <dmwit> Hanoi: fast: use a parsing library
16:04:03 <dmwit> Hanoi: easy to write: use reads
16:04:10 <danharaj> hattmammerly:  That will make scan s :: String -> Net ()
16:04:19 <dmwit> > reads "(32, 46) (57, -55)" :: [((Int, Int), String)]
16:04:21 <lambdabot>  [((32,46)," (57, -55)")]
16:05:16 <danharaj> hattmammerly: Nevermind. I am not reading your code carefully. You are mixing IO and Net in your scan code.
16:05:19 <dmwit> > let f s = do (p1, rest) <- reads s; (p2, "") <- reads rest; return (p1, p2) in f "(32, 46) (57, -55)"
16:05:20 <lambdabot>  []
16:05:28 <hattmammerly> danharaj: yeah, it's getting confused when I call privmsg
16:05:44 <dmwit> > let f s = do (p1, rest) <- reads s; (p2, "") <- reads rest; return (p1, p2) in f "(32, 46) (57, -55)" :: [((Int, Int), (Int, Int))]
16:05:45 <lambdabot>  [((32,46),(57,-55))]
16:05:51 <Hanoi> thank you dmwit
16:06:16 <dmwit> probably safer to do something like this, though
16:06:25 <danharaj> hattmammerly: So your first action is IO [String], right? The one that binds `a` in the line `a <- liftM rights ...`
16:06:39 <dmwit> > let f s = do (p1, rest) <- reads s; (p2, rest') <- reads rest; guard (all isSpace rest'); return (p1, p2) in f "(32, 46) (57, -55)  \n" :: [((Int, Int), (Int, Int))]
16:06:40 <lambdabot>  [((32,46),(57,-55))]
16:06:54 <enthropy> jcristovao: maybe it'll work better if you change your code to something like:   fmap (:[] $ valD (varP (mkName "test")) (join (fmap (stringE . show) (reify ''Pane)) []
16:06:54 <dmwit> > let f s = do (p1, rest) <- reads s; (p2, "") <- reads rest; return (p1, p2) in f "(32, 46) (57, -55)  \n" :: [((Int, Int), (Int, Int))] -- for comparison
16:06:55 <lambdabot>  []
16:07:25 <hattmammerly> danharaj: a at that point should just be [String]. Hmm, wondering now why getTitle is returning an IO (Either ParseError String) heh
16:08:05 <jcristovao> enthropy: I'm reading your link, thanks... I'll see what I can make of it
16:08:08 <danharaj> hattmammerly: well anyway, you can add io to that line: a <- `io $ liftM rights $ …`
16:08:14 <jcristovao> let me test your suggestion
16:08:16 <TheKing__> Is there a version of the extension "Overlapping Instances" for functional dependencies.
16:08:26 <geekosaur> ???
16:08:53 <TheKing__> So that if there is a general instance and specific instance, that have the same first type, the general one is ignored.
16:09:41 <TheKing__> (I am trying to make a restricted monad typeclass, but when making all monads a RMonad, it says the functinal dependencies conflict.)
16:10:39 <enthropy> TheKing__: instead of  class C a b c | a b -> c; instance C T T T, you can also write  class C a b c; instance (T ~ t) => C T T t
16:10:41 <geekosaur> I think if you're getting an error involving fundeps, your problem is deeper than OverlappingInstances
16:10:48 <hattmammerly> danharaj: that did it. thank you so much!
16:11:01 <danharaj> np
16:11:05 <hattmammerly> now to stare at the code and figure out where I went wrong, and if I can clean it up a little more heh
16:11:17 <TheKing__> let me try that
16:11:39 <TheKing__> (that seems like its getting around fundeps fundamentally, but oh well)
16:11:52 <enthropy> TheKing__: in that case you essentially have the same "functional dependency" but on a per-instance basis
16:11:56 <TheKing__> wait, I wonder if I even need fundeps
16:12:24 <TheKing__> yea, I do
16:13:37 <jcristovao> enthropy: actually, just following the suggestion given on the end of "What reify sees" did the trick
16:13:49 <TheKing__> yeah, I was right
16:13:49 <jcristovao> adding $(return []) between the expressions
16:14:10 <TheKing__> entropy: it seems it took away its fundepness, maybe, let me see
16:14:15 <enthropy> jcristovao: yeah that's the same strategy.
16:14:16 <jcristovao> but thanks... I don't thing I would got there alone
16:14:40 <jcristovao> yeah, you force it to evaluate till that point
16:14:50 <jcristovao> if I understand it correctly
16:15:09 * enthropy would say it has more to do with the DecsQ splice there splitting up the file into two for all practical purposes
16:15:50 <enthropy> you won't be able to refer to things defined below the "return []" above the return []
16:15:51 <TheKing__> never mind, my code is broken in some other way
16:15:59 <TheKing__> I will get back to you entropy.
16:16:23 <jcristovao> ok, I see
16:16:39 <jcristovao> but I don't believe that would be a problem in my particular use case
16:16:58 <jcristovao> still used to top down from other languages :)
16:21:40 <TheKing__> >prim where prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  primes)
16:21:54 <TheKing__> > prim where prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  primes)
16:21:56 <lambdabot>  <hint>:1:6: parse error on input `where'
16:22:08 <sipa> you're missing a second ]
16:22:15 <TheKing__> > let prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  primes) in prim
16:22:16 <lambdabot>  <hint>:1:90: parse error on input `in'
16:22:22 <shachaf> Missing many things.
16:22:42 <TheKing__> @def prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  primes)
16:22:42 <lambdabot>  Parse failed: ViewPatterns is not enabled
16:23:00 <TheKing__> @def prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  primes)]
16:23:00 <lambdabot>  Parse failed: ViewPatterns is not enabled
16:23:09 <TheKing__> @def prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (p'->p'*p'<=p)  prim)]
16:23:10 <lambdabot>  Parse failed: ViewPatterns is not enabled
16:23:36 <shachaf> I recommend trying it in /msg lambdabot until you get it working.
16:24:07 <geekosaur> I think that p'-> needs to be \p'-> ?
16:24:13 <TheKing__> yeah
16:24:29 <TheKing__> @def prim=2:[p|p<-[3..], not $ any (\f->p `mod` f ==0) (takeWhile (\p'->p'*p'<=p)  prim)]
16:24:29 <lambdabot>  .L.hs:157:1:
16:24:30 <lambdabot>      Multiple declarations of `prim'
16:24:30 <lambdabot>      Declared at: .L.hs:151:1
16:24:30 <lambdabot>                   .L.hs:157:1
16:24:40 <TheKing__> > prim
16:24:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:25:26 <TheKing__> oh well, just playing around
16:25:48 <TheKing__> there we go
16:25:57 <shachaf> I recommend playing around in /msg lambdabot.
16:26:26 <TheKing__> or, there he popped up
16:26:38 <TheKing__> I didn't see his reply, so I assumed it was broken.
16:26:58 <shachaf> Or in ghci. > in the channel is mainly for communicating with others in the channel.
16:28:47 <narens> cabal question: I want to have global build-depends but this is only in cabal versions below 1.8... but i'd also like to use test-suite but this seems to require cabal 1.9.2 atleast... how can I get both?
16:31:42 <tristan_1> is there a nice fsm lib?
16:32:14 <tristan_1> I see fsmActions
16:33:05 <TheKing__> Okay, now I am having the error, where I am using flexible instances. The problem is, the internal functions don't know it is the right type.
16:33:11 <bennofs> what's fsm?
16:33:14 <erisco> finite state machine
16:33:21 <TheKing__> like I do: instance (Prelude.Monad m)=>RMonad m All where
16:33:22 <Cale> tristan_1: I don't know if you'd consider it nice, but I have some code here: http://cale.yi.org/share/Regular.hs
16:33:26 <erisco> I presume you are looking at http://hackage.haskell.org/packages/ already tristan_1. that is all I see too =\
16:33:52 <tristan_1> hm, ok
16:33:53 <Cale> (It's not really intended for general finite state machines or anything, but it does contain an implementation of NFAs
16:33:55 <Cale> )
16:33:55 <TheKing__> But then the internal functions don't know it is a monad
16:34:01 <tristan_1> Cale: thanks, I'll look at this too
16:34:39 <Fuuzetsu> didn't know there was a yi.org… maybe I should fetch editor.yi.org
16:34:44 <tristan_1> implementing logic for connect, disconnect, reconnect, ... and in erlang I'd just do a gen_fsm :)
16:35:21 <Cale> tristan_1: Oh, so you're not parsing :)
16:35:55 <tristan_1> Cale: na, so yea, not this :)
16:36:56 <erisco> Cale, ivanm, mkay this is a quick sum-up of the ideal general purpose graph library. Each representation has a purpose http://lpaste.net/97978
16:37:06 <Cale> tristan_1: Would a collection of mutually recursive functions do?
16:37:30 <erisco> I realized that the direct representation was useful after all because it is the only way to have O(n) inductive construction in circumstances that you cannot predict the size of the result
16:37:53 <SrPx> There is no ~/.cabal/bin, now what?
16:38:13 <Cale> SrPx: Make one, or put a symlink to ~/bin there
16:38:29 <SrPx> Cale ok
16:38:42 <Cale> (I believe cabal will make one for itself the first time you install anything which includes an executable)
16:38:46 <SrPx> Hope this time I manage to compile Haste ...
16:39:22 <tristan_1> Cale: well was looking for sometihng for easily describing conditions for state changes and what state to go to
16:39:55 <Cale> Well, there is the State monad.
16:40:53 <Cale> But I'm not entirely sure what the thing you want looks like
16:40:54 <epta> For given xs and f how to get (f xn) . ... . (f x1) ?
16:41:08 <identity> tristan_1: you could use the state monad as mentioned and just use pattern matching to determine which state to run, depending on which state has been entered
16:41:22 <Cale> epta: foldl (.) id . map f ?
16:41:41 <Cale> epta: are you sure you want them composed in reverse order like that?
16:42:05 <Cale> oh, that should be (flip (.))
16:42:17 <epta> Cale: yep
16:42:23 <Cale> but anyway, use foldr and reverse, like  foldr (.) id . map f . reverse
16:42:28 <Cale> Probably easier to read
16:42:34 <tristan_1> Cale: identity ah, good point, I'll play around with doing it that way
16:43:29 <Cale> Even without the State monad, what's wrong with just writing one function for each state, and have those functions call each other according to the transitions?
16:44:12 <Cale> You might be able to pull that pattern out into some kind of construction which takes a list of the states and transitions and what to do on each transition, say
16:44:28 <Cale> But you'd have to wonder whether you actually needed that.
16:45:43 <roboguy_> is there at most one valid Monad instance for any given type?
16:46:58 <Cale> roboguy_: You can't rely on that.
16:47:07 <Cale> roboguy_: In practical terms, typically.
16:47:20 <epta> Cale: (.) and f could be composed inside foldr like `(foldr ((.) . f) id . reverse'
16:47:26 <Cale> But for instance, there's more than one valid way to make State s into a monad.
16:47:37 <tristan_1> yea, guess I was thinking too much in an erlang fashion. where I send messages to a fsm and it reacts based on the state it is in. probably not going to be doing that here
16:47:45 <Cale> epta: they could, but it's clearer if you pull it apart
16:48:05 <roboguy_> Cale: there is?
16:48:13 <Cale> tristan_1: I'm sure you could write that abstraction for yourself if you wanted it :)
16:48:46 <tristan_1> yea, I may :), if I can't keep clean code for this.
16:48:48 <Cale> roboguy_: Recall that the usual definition of >>= looks like:
16:49:23 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
16:49:42 <Cale> roboguy_: There's nothing here which says we have to thread the s's in that order
16:50:06 <Cale> x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'',w))
16:50:16 <Cale> This is also valid and produces a monad
16:50:34 <Cale> The state travels in the opposite direction
16:50:50 <Cale> (so when you do a 'get', you see the value from the *following* put)
16:51:04 <roboguy_> huh, I didn't think of that
16:51:56 <Cale> It's rather easy to write infinite loops with it
16:52:06 <erisco> that'd be a good April fool's for the next ghc release amirite?
16:52:08 <Cale> like do x <- get; put (1:x); return x
16:52:16 <Cale> will produce an infinite list of 1's as its result
16:53:26 <roboguy_> Cale: so it wouldn't really be possible to have a DeriveMonad extension, in the same way it wouldn't be possible to have a DeriveApplicative extension?
16:53:55 <Cale> Well, you might have a way to canonically derive monad instances for certain types
16:54:03 <shachaf> There are much simpler examples of multiple monad instances than the slightly questionable backwards State thing.
16:54:05 <Cale> But yeah, it's not an easy thing to do.
16:54:14 <pavonia> Is there a way to flip around type variables in an instance declaration? Say I have a type "Foo f t" and want to make it a Functor such that it maps f not t.
16:54:17 <shachaf> For example, (w,) is a monad for any monoid w.
16:55:22 <Cale> shachaf: and I suppose you have two different ways to define join there, which I think should both work
16:55:23 <roboguy_> hmm, I thought I heard some people say a while ago that Monad was like Functor, as far as having only at most one valid instance per type. I guess they were wrong
16:55:45 <shachaf> Cale: Well, that just gives you the dual monoid.
16:56:12 <Cale> shachaf: Yes, but the question was whether there are single types for which there's more than one way to define a Monad instance
16:56:26 <shachaf> Yes, (w,), for most values of w.
16:56:43 <shachaf> The choice of the Monoid type class is kind of arbitrary.
16:56:53 <Cale> shachaf: You need to pick a w, and then show two instances?
16:57:08 <Cale> (The dualising thing works though)
16:57:09 <shachaf> OK, (Int,) and the instance with (+)/0 and with (*)/1
16:57:20 <Cale> Oh, sure.
16:57:43 <shachaf> The point is that you can pick any monoid. So switching the multiplication around is just like picking (Dual w,)
16:57:46 <Cale> yes
16:58:12 <shachaf> The monad laws even correspond to the monoid laws for w.
16:58:38 <shachaf> You can break just associativity for w to break just associativity for (w,), etc.
17:01:39 <Komier> can't get syntastic working properly. Argh
17:05:30 <benmachine> Komier: I think I have an improperly-working syntastic in use at work
17:05:49 <benmachine> I think that's always been my strategy for vim, stumble blindly through having no idea what is going on
17:05:52 <benmachine> uh
17:05:53 <benmachine> don't follow my example
17:06:06 <Komier> benmachine: It recognises haskell as the file, but says i have no available syntax checkers
17:06:39 <benmachine> Komier: the more I said the more I realised I was extremely unlikely to be of any use to you
17:06:49 <benmachine> you have my sympathy, that's the best I can offer :P
17:06:58 <Komier> hahaha thankyou!
17:07:02 <Komier> :D
17:07:14 <aristid> why doesn't unordered-containers use Data.Bits' popCount but defines its own?
17:07:19 <croyd> Komier: what checker are you trying to use?
17:07:28 <geekosaur> predates it?
17:07:37 <geekosaur> popCount is fairly recent
17:07:45 <Komier> croyd: haskell ones.  I have it configured in my .vmrc to use ghc-mod
17:07:50 <benmachine> there was a bug in it
17:08:03 <benmachine> popCount for Integer used to be hopelessly wrong
17:08:08 <croyd> Komier: is ghc-mod on your runtime path?
17:08:12 <aristid> benmachine: it doesn't use Integer
17:08:39 <Cale> I know that for almost any vim plugin I can imagine, that I will almost certainly waste more time trying to configure it than I will ever get back from using it.
17:08:44 <Komier> croyd: As in the directory I'm at in terminal when I run Vim?
17:08:56 <Cale> The same goes for learning to use probably 99% of vim's features.
17:09:05 <benmachine> aristid: https://ghc.haskell.org/trac/ghc/ticket/5872
17:09:08 <Komier> croyd: It's in the appropriate place in my ./bundles directory.
17:09:12 <aristid> geekosaur: but that could be, or it was too slow at the time
17:09:54 <aristid> benmachine: ouch, smells like completely untested code
17:09:55 <croyd> Komier: as in does the command "which ghc-mod" find the executable?
17:10:35 <benmachine> aristid: yeah :(
17:10:37 <Komier> hmm doesn't look like it, no. hmm
17:11:02 <croyd> Komier: how did you install ghc-mod? cabal?
17:11:09 <Komier> croyd aye
17:11:34 <croyd> Komier: try adding ~/.cabal/bin to $PATH
17:11:47 <croyd> Komier: (that's where it is for me)
17:11:57 <aristid> benmachine: now it's fixed though, so there's no good reason not to use it for new code (well, it's still slow for Integer i guess but then it's Integer)
17:12:10 <benmachine> aristid: what if people are using your library with old GHC?
17:12:22 <aristid> benmachine: 7.4.1 may die in a fire .oO(debian)
17:12:52 <benmachine> that's only one major version behind, will probably take a while to die
17:12:55 <Komier> hmm still nothing, how odd
17:13:32 <benmachine> I think I vaguely remember something about having to add $HOME/.cabal/bin instead of ~/.cabal/bin
17:13:38 <geekosaur> yes
17:13:49 <geekosaur> shells expand ~, other programs mostly don't
17:13:58 <croyd> yeah, that's right
17:14:15 <randomclown> Why is there no examples for network-conduit
17:14:38 <randomclown> or should I be using the pipes version instead
17:15:01 <Komier> can you add a path for ghcmod in your .vimrc then?
17:15:28 <croyd> you want your shell config file
17:15:44 <Komier> gah ok ta
17:16:40 <croyd> add the line 'export PATH="$HOME/.cabal/bin:$PATH"'
17:16:59 <Komier> ok thanks mate, will do when i find the config file :D
17:17:17 <croyd> it's probably ~/.bashrc or ~/.bash_profile or something along those lines
17:19:21 <epta> What happens there http://lpaste.net/97979 ?
17:21:01 <benmachine> epta: "[SomeEmpty, SomeSmall, SomeLarge]" ← what's the type of that list?
17:22:55 <epta> benmachine: ok, there is no such type, only typeclass. There is no way to build homogenous list like this?
17:23:09 <benmachine> possibly you mean heterogenous?
17:23:24 <geekosaur> there are ways to make heterogeneous lists, but it's usually a bad idea
17:23:34 <benmachine> it's not impossible to build them, but it's probably more trouble that it's worth
17:23:42 <benmachine> usually it's possible to do what you want without them
17:24:05 <roboguy_> epta: why do you want to avoid that "a"?
17:24:15 <epta> So to achive that I need another type data X = SomeEmpty | SomeSmall | SomeLarge?
17:24:38 <epta> roboguy_: because it unused
17:25:11 <benmachine> epta: it's unclear to me what your aim is
17:25:28 <benmachine> the a is not unused
17:25:28 <roboguy_> epta: oh, just change those methods so that they aren't functions
17:25:43 <benmachine> roboguy_: you can't have a class with no type variables!
17:25:49 <roboguy_> benmachine: oh yeah, haha
17:26:32 <benmachine> epta: be aware that data X = SomeEmpty | SomeSmall | SomeLarge is very different from data X = A SomeEmpty | B SomeSmall | C SomeLarge
17:26:47 <benmachine> it's confusing because you have both SomeEmpty as a type and a constructor
17:27:50 <roboguy_> epta: what are you trying to do?
17:27:52 <SrPx> How does shipping Haskell programs work? If I create a graphical application that responds to mouse input etc, is it automatically able to be compiled to windows, osx, linux and javascript without modifications on code? And will work the same?
17:28:26 <roboguy_> I'm thinking a phantom type w/ a GADT might be useful, but I'm not totally sure what you want
17:28:54 <roboguy_> SrPx: it depends on how you do it
17:28:58 <benmachine> roboguy_: I think i's probably something more basic than that
17:29:24 <zRecursive> Why does "-Wall" warns me "A do-notation statement discarded a result of type ghc-prim:GHC.Prim.Any" and "Warning: Defined but not used: `...'" even there is "ghc-options: -fno-warn-missing-signatures -fno-warn-unused-do-bind -Wall -O2" in *.cabal ?
17:29:42 <SrPx> roboguy_: how it depends. ......
17:29:49 <roboguy_> SrPx: what library are you using?
17:30:10 <SrPx> roboguy_: I'm considering using haskell for this project actually, I've been for long wanting to learn it
17:31:00 <roboguy_> SrPx: but which *library*? some of them are portable. actually, all of the ones I can think of are portable
17:32:08 <benmachine> zRecursive: wild guess: try putting -Wall before the -fno- options
17:32:14 <roboguy_> SrPx: this might help some, if you're looking for GUI stuff http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
17:32:37 <SrPx> roboguy_: what I meant is that I have no idea what library I could use at all
17:33:02 <roboguy_> SrPx: ahh. well that link has a list of GUI libraries
17:33:15 <SrPx> roboguy_: maybe I could just use multidimensional arrays instead of images?
17:33:27 <SrPx> yes I'm looking thanks
17:33:40 <roboguy_> SrPx: multidimensional arrays instead of images?
17:34:52 <SrPx> if the code involving messing with the graphics card isn't cross platform, I could code the game using arrays and then just write wrappers that observe that array and render the game for each specific compile target, I guess? I'm not sure, but I just don't see how the game could be ported for, say, JS, if I wrote it using, say, native opengl
17:35:57 <roboguy_> SrPx: porting opengl to javascript might be hard, but I'm pretty sure it would be hard to make any graphical application portable across desktop applications *and* js...
17:36:26 <roboguy_> I'm no expert with this stuff, but I have a feeling that there isn't a great option for that
17:36:55 <roboguy_> portable across desktop OSes probably wouldn't be too hard though
17:39:00 <epta> roboguy_: I write an answer what am I trying to do and understood that it is fine with tuples (EType, [Int]) without classes. Thanks :)
17:39:03 <Aetherspawn> does Elliott Hird pop around here?
17:39:18 <zRecursive> benmachine: it works now. Odd order question :)
17:39:49 <zRecursive> benmachine: thx
17:40:11 <benmachine> well, you know, odd order means soluble.
17:40:55 <benmachine> preflex: seen ehird
17:40:56 <preflex>  ehird was last seen on #haskell 3 years, 333 days, 2 hours, 38 minutes and 33 seconds ago, saying: yairchu: She.
17:41:01 <benmachine> umm.
17:41:15 <zRecursive> How does GHC manipulate options in such an weird way ?
17:41:47 <SrPx> Hmm I see
17:41:48 <benmachine> zRecursive: it sort of makes sense, each option is applied left-to-right
17:41:57 <benmachine> -Wall turns them all on, -fno-stuff turns some off
17:42:19 <SrPx> ... why do I feel like we are in really early days of programming and CS in general... /sighs
17:42:23 <roboguy_> SrPx: Although, I should point out I doubt there would be a good way to make it portable across OSes *and* js in any language
17:43:15 <SrPx> roboguy_: it would be pretty easy on mine if I just had my optimizing compiler :( but ok
17:43:19 <zRecursive> Why canot ghc make options order independent ? i.e., using the intersection between options ?
17:43:43 <Fuuzetsu> is there an Arrow equivalent of ‘fail’?
17:44:06 <jfischoff> Fuuzetsu: no fail is for do notation pattern match failures
17:44:21 <jfischoff> so wait
17:44:32 <roboguy_> SrPx: the difficulty comes in with library support rather than the language itself. unless your language has a good FFI with C or something like that, then it probably wouldn't have the library support yet
17:44:34 <jfischoff> I guess there could be for arrow notation
17:45:44 <Fuuzetsu> Alright, how can I make an arrow fail? At the moment I'm just using Maybe but I think that HXT has the concept of failure when arrows don't succed
17:46:09 <Fuuzetsu> so for example list arrow would return empty list (which it does in HXT), I just don't know how to indicate that my own arrow is failing
17:46:24 <Fuuzetsu> I'm using ‘arr’ to lift a function into an arrow but I think I'm doing it wrong
17:46:55 <jfischoff> There is ArrowPlus
17:46:59 <Fuuzetsu> Basically I have ‘x >>> y >>> arr (\x -> if something then Just x else Nothing)’
17:47:41 <Komier> That worked, have the ghc-mod option available in syntastic now ty :)
17:47:46 <jfischoff> well wait, I should think harder before I respond :p
17:47:47 <roboguy_> Fuuzetsu: ArrowZero might work
17:48:00 * jfischoff runs and hides
17:48:16 <Fuuzetsu> hmm
17:48:41 <roboguy_> Fuuzetsu: there doesn't seem to be anything about the ArrowZero laws, but I would suspect that arrowZero >>> x = arrowZero
17:49:01 <zRecursive> :t (>>>)
17:49:01 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
17:49:13 <roboguy_> > flip runKleisli undefined $ (Kleisli $ const Nothing) >>> (Kleisli $ const $ Just 1)
17:49:14 <lambdabot>  Nothing
17:50:34 <roboguy_> > flip runKleisli undefined $ zeroArrow >>> (Kleisli $ const $ Just 1)
17:50:35 <lambdabot>  Nothing
17:51:47 <Fuuzetsu> I'm not sure how to call arrowZero after doing a ‘pure’ test
17:52:15 <Fuuzetsu> x >>> (if something then returnA x else arrowZero )
17:52:22 <Fuuzetsu> how do I get that if into arrows?
17:52:56 <Fuuzetsu> I think I can easily with arrow syntax but without it?
17:54:21 <jmcarthur> if 'something' depends on the output from x, i don't see how an arrow could express that
17:54:41 <bennofs> @ty left
17:54:42 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
17:55:06 <jmcarthur> ah
17:55:09 <roboguy_> jmcarthur: doesn't (>>>) feed the output of the left argument into the right argument?
17:55:12 <jmcarthur> encode the bool into Either
17:55:40 <jmcarthur> roboguy_: but to dynamically, in full generality at least, generate the next part of the graph you need something more like a monad
17:55:55 <jmcarthur> roboguy_: but ArrowChoice can probably be made to work. i am no Arrow expert.
17:56:39 <bennofs> @ty left mzero
17:56:39 <Fuuzetsu> jmcarthur: Well, I can get it to work with Maybe and such and then filter the results based on that but I'm wondering how to do it with zeroArrow, so that the whole thing just fails then and there
17:56:40 <lambdabot> (MonadPlus (a b), ArrowChoice a) => a (Either b d) (Either c d)
17:56:50 <bennofs> @ty left zeroArrow
17:56:51 <lambdabot> (ArrowZero a, ArrowChoice a) => a (Either b d) (Either c d)
17:57:41 <jmcarthur> :t \x -> x >>> arr (\y -> if y then Right () else Left ()) >>> left zeroArrow
17:57:41 <lambdabot> (ArrowZero cat, ArrowChoice cat) => cat a Bool -> cat a (Either c ())
17:57:49 <zRecursive> How can i make the values passed from command line(by calling getArgs) global, which means some functions in a module can use it directly without passing it around ?
17:58:21 <geekosaur> if you're thinking of anything global you are falling away from haskell
17:58:34 <bennofs> @ty runKleisli (arr (const $ Left ()) >>> left zeroArrow) 3 :: Maybe Int
17:58:35 <lambdabot>     Couldn't match type `Either c0 b0' with `Int'
17:58:35 <lambdabot>     Expected type: Kleisli Maybe (Either () b0) Int
17:58:35 <lambdabot>       Actual type: Kleisli Maybe (Either () b0) (Either c0 b0)
17:58:40 <roboguy_> Fuuzetsu: zeroArrow needs a MonadPlus (like Maybe) to work with Kleisli arrows
17:58:58 <beardtree> "powm :: Integer -> Integer -> Integer -> Integer -> Integer # <interactive>:6:1: Not in scope: `powm'" -- why?
17:59:01 <Fuuzetsu> I think it's best that I show some code
17:59:04 <roboguy_> zRecursive: the reader monad would be an option
17:59:07 <jmcarthur> :t \x -> x >>> arr (\y -> if y then Right () else Left ()) >>> returnA ||| zeroArrow
17:59:08 <lambdabot> (ArrowZero cat, ArrowChoice cat) => cat a Bool -> cat a ()
17:59:25 <jmcarthur> some variation on that should work, i think ^^^
17:59:35 * beardtree just copying and pasting code from Rosetta Code
18:00:06 <bennofs> @ty runKleisli (arr (const $ Left ()) >>> returnA ||| zeroArrow) 3 :: Maybe Int
18:00:06 <lambdabot>     Couldn't match type `()' with `Int'
18:00:07 <lambdabot>     Expected type: Kleisli Maybe () Int
18:00:07 <lambdabot>       Actual type: Kleisli Maybe () ()
18:00:25 <roboguy_> beardtree: you need to put it into a file. ghci works differently than normal Haskell
18:00:32 <roboguy_> that's the short story anyway
18:00:36 <bennofs> @ty runKleisli (arr (const $ Left ()) >>> returnA ||| zeroArrow) 3 :: Maybe ()
18:00:37 <lambdabot> Maybe ()
18:00:41 <bennofs> > runKleisli (arr (const $ Left ()) >>> returnA ||| zeroArrow) 3 :: Maybe ()
18:00:42 <lambdabot>  Just ()
18:00:44 <bennofs> :O
18:00:44 <beardtree> roboguy_: how do I do it in ghci? Is it possible at all?
18:01:00 <bennofs> > runKleisli (arr (const $ Right ()) >>> returnA ||| zeroArrow) 3 :: Maybe ()
18:01:01 <lambdabot>  Nothing
18:01:03 <bennofs> > runKleisli (arr (const $ Right ()) >>> returnA ||| zeroArrow) 3 :: Maybe Int
18:01:04 <nisstyre> beardtree: you can give things types by doing <exp> :: <type>
18:01:04 <lambdabot>  Nothing
18:01:16 <roboguy_> beardtree: it is, but the syntax is a bit different. top level declarations need a "let" before them and you have to use multi line input (which you can do with :{ and :})
18:01:20 <Fuuzetsu> see http://lpaste.net/97981
18:01:41 <roboguy_> beardtree: it would probably be easier just to put it into a file, then load the file from ghci
18:01:48 <zRecursive> roboguy_: reader monand ?  ok, thx
18:03:21 <bennofs> Fuuzetsu: parsePackages = hasName "a" >>> getAttrValue "href" >>> arr (\x -> if "/package/" `isPrefixOf` x then Left x else Right ()) >>> returnA ||| zeroArrow should work
18:03:41 <bennofs> Fuuzetsu: then you should be able to just use runLA
18:03:55 <Fuuzetsu> I'll try it now although I don't understand why it works
18:03:57 <Fuuzetsu> :t (|||)
18:03:58 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
18:05:48 <Fuuzetsu> bennofs: That works fine. Oh, and I just got how it works too. Should have read the type more closely.
18:07:57 * hackagebot charset 0.3.6 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.6 (EdwardKmett)
18:07:59 * hackagebot identifiers 0.2.0.1 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.2.0.1 (awagner83)
18:11:26 <NemesisD> i've got some real rudimentary ffi questions
18:11:29 <flebron> Should a .Internal module export everything it defines?
18:12:14 <NemesisD> if i plan to distribute my package with the c source it binds to, how do the shared object files work? when the user compiles something that uses my library, they don't have the shared object files systemwide or anything
18:15:36 <donri> flebron: that's what i do. others might only export internals that could be useful but are still considered internal. some might export such functions from .Unsafe or something instead, though
18:20:39 <intrados> Would I be better off implementing type-level `elem` with type families or type classes?
18:22:05 <enthropy> intrados: what version of ghc do you want it to work with?
18:23:24 <intrados> enthropy: I guess 7.6.3
18:23:38 <donri> you can't do it with type families in 7.6
18:23:52 <donri> you need overlap to implement equality testing
18:24:14 <intrados> That's what I thought. That becomes available in a later GHC?
18:24:15 <enthropy> if you have a finite universe of types, you could enumerate all the equal and unequal pairings
18:24:28 <enthropy> but I hope you don't do that
18:24:32 <donri> well sure, i was assuming kind * :)
18:30:11 <intrados> Wow. That was surprisingly manageable
18:30:15 <enthropy> donri: I'm not?
18:30:15 <randomclown> Which is better conduits or pipes?????
18:32:20 <donri> randomclown: in theory, pipes. in practice, conduit
18:32:48 <donri> enthropy: hm not sure how you mean to do equality at * without closed tf?
18:32:54 <notadog> How can I reduce boilerplate code like "labelSetJustify label1 JustifyCenter" (for an arbitrary number of labels)? If it was the last argument that took the label name, then I could use map right, like "map (labelSetJustify JustifyCenter) [label1,label2(etc)].
18:33:17 <randomclown> donri: alright ok
18:33:21 <donri> :t flip
18:33:22 <lambdabot> (a -> b -> c) -> b -> a -> c
18:33:29 <notadog> But I ican't, because it is the second argument which determines which label you are modifying.
18:33:45 <donri> or use a section map (`labelSetJustify` JustifyCenter)
18:33:48 <enthropy> donri: I mean  type instance Eq Int Int = True; type instance Eq Int Double = False
18:33:56 <enthropy> which is not sane
18:34:19 <notadog> donri: hmmmmm.
18:34:32 <donri> enthropy: but is * finite? it's open...
18:35:21 <enthropy> right, it won't work in general
18:35:38 <notadog> donri: I need to have it changed from (a -> b -> c) to a -> c -> b, or am I missing something? I dont kno wwhat section maps are, ill research those.
18:35:53 <enthropy> so that's might not qualify as an implementation of type-level equality
18:35:55 <epta> preflex: seen ehird
18:35:55 <preflex>  ehird was last seen on #haskell 3 years, 333 days, 3 hours, 33 minutes and 32 seconds ago, saying: yairchu: She.
18:36:41 <donri> enthropy: maybe i misunderstood what you meant by finite universe, but it sounds like kind promotion :) where it can be trivial to enumerate all types
18:37:03 <enthropy> I mean "enumerate all the types manually"
18:37:32 <donri> but not sure it's even possible with the open kind *, since you end up with circular dependencies if a module imports your type equality and defines types
18:37:49 <erisco> epta, that was almost an entire line of 3's
18:38:07 <donri> hah one second too early ;)
18:38:26 <donri> i think maybe ehird = elliot?
18:38:39 <donri> at least elliet = elliot hird
18:38:42 <epta> Not again :[
18:39:42 <Syao> hello, I read about haskell's boxed arrays. It's written "... immutable arrays (IArray) just creates a new copy of the array..". Do boxed arrays copy values too?
18:41:42 <Syao> or just creates new Array with existing ref of elements?
18:43:20 <donri> side-note: you usually want vector rather than array
18:44:33 <enthropy> it will copy values if you can read/write without having to be in IO or ST
18:44:40 <notadog> How can I use list comprehension to build a list of IO actions in a do block
18:44:50 <intrados> This is my first real attempt at type class prolog. Does this type-level `elem` seem to make sense? http://lpaste.net/97983
18:45:15 <ivanm> erisco: I've played with Vector-backed graphs; they're good for reading, horrible at editing (unless you use MVector...)
18:45:23 <ivanm> notadog: sequence?
18:45:31 <donri> :t sequence
18:45:31 <lambdabot> Monad m => [m a] -> m [a]
18:45:33 <simpson> intrados: Okay, that's pretty nifty.
18:45:44 <notadog> possibly, I will try it
18:46:41 <enthropy> intrados: there's another trick for getting nicer error messages when you have (Bar `In` '[Baz, Baz]) that might be worth doing
18:47:03 <donri> incidentally enthropy wrote this for me some time ago http://lpaste.net/93900
18:47:05 <erisco> ivanm, indeed. I think what needs to happen is for the plurality of representations, each with their unique performance characteristics, to be brought under the same umbrella
18:47:30 <Syao> wait, so you are saying that I when I operate on immutable boxed Arrays / Vectors and forced to make a change to an array/vector, the whole thing is copied including values in boxes?
18:47:49 <darthdeus> can i somehow invoke ghc in a way that it cleans all of the .o and .hi files?
18:48:05 <erisco> Syao, well that is what immutable means
18:48:33 <Syao_> wait, so you are saying that when I operate on immutable boxed Arrays / Vectors and forced to make a change to an array/vector, the whole thing is copied including values in boxes?
18:48:43 <simpson> Syao: As I understand, the references to the boxes are copied, not the boxes' contents, just like any other persistent structure.
18:49:31 <lingxiao> hey all I have what appears to be a super basic problem that I just cannot solve :(
18:49:51 <lingxiao> I'm trying to traverse a syntax tree of a untyped pure lambda calculus
18:50:11 <lingxiao> and replace variables with de-brujin index
18:50:51 <DarkFox> What should one do when attempting to install pandoc and cabal says it can't find a program that is required: alex?
18:50:59 <DarkFox> Other than try to find it :P
18:51:22 <donri> DarkFox: make sure it's installed and in $PATH
18:51:24 <lingxiao> and i just cannot figure out how to describe how to "parralellize" the traversal at each split of the branch
18:51:30 <donri> cabal/ghc-pkg doesn't track executables
18:51:33 <simpson> DarkFox: Alex can be installed via cabal-install with `cabal install alex` if you can't get one from the same place where you got GHC. It comes with the Platform.
18:51:33 <DarkFox> donri: cabal should install it?
18:51:46 <donri> DarkFox: cabal install alex might work, but it doesn't work as a build-depends
18:51:55 <DarkFox> Strange
18:52:00 <donri> DarkFox: it comes with platform though, i'd suggest grabbing that
18:52:06 <Syao> simpson, that is what I was hoping for. The documentation needs to be changed to include this kind of information. I couldn't find such an information.
18:52:15 <DarkFox> donri: Nah, but this should be fine now :)
18:52:20 <geekosaur> not strange; cabal relies on ghc's library manager. alex isn't a library, it's a program
18:52:27 * DarkFox is just updating his hakyll
18:52:35 <simpson> Syao: I believe that the important part to grok is that the immutable boxed arrays are completely non-magical.
18:53:07 <DarkFox> Take 3 for installing hakyll!
18:53:11 <DarkFox> (Upgrading) lol
18:56:06 <Syao> simpson, as it should be.
18:59:28 <flebron> I'm using Haddock to document a type's Foldable instance. If my function is fold :: (b -> b -> a -> b) -> b -> T -> b, how can I document "The function passed as the first parameter will be given these arguments." (that is, the first b is the left side of my tree, the second is the right side, and the third argument is the value at a given node)
19:04:57 <solrize> anyone know why quot/rem is faster than div/mod ?
19:06:35 <Syao> simpson, then one more question. As we know to "modify" immutable data structure we create new copy of it with changed values. So if I do have immutable boxed Array/Vector having those "objects", and I need to "change" some  value of that "object" the new  "object" is created and to update array i need to update array manually? right?
19:06:36 <shachaf> Corresponds to a machine instruction?
19:07:46 <NemesisD> is there something fancy i gotta do to bind to C++ in haskell? i seem to be getting an error when ghc calls into gcc: cstdio no such file or directory
19:08:18 <roboguy_> NemesisD: did you try compiling with g++?
19:08:25 <Cale> solrize: AIUI There's some fiddly reason for why quot/rem are cheaper to implement in hardware, so that's what the CPU manufacturers give you.
19:08:27 <simpson> Syao: IIUC, yes.
19:08:34 <NemesisD> roboguy_: can i get cabal/ghc to do that for me?
19:08:50 <simpson> Syao: Tools like the lens package can make it *much* easier to do these changes.
19:08:57 <roboguy_> NemesisD: hmm, I don't know, sorry
19:09:25 <Syao> solrize, just to remind you http://stackoverflow.com/questions/339719/when-is-the-difference-between-quotrem-and-divmod-useful
19:09:55 <solrize> Syao, yes thanks, i know what the difference is, i'm wondering why quot/rem is faster
19:09:56 <roboguy_> NemesisD: you can't compile with g++ then link with ghc?
19:10:28 <solrize> i.e. division is a pretty slow instruction, so div/mod = quot/rem + a comparison + a possible subtraction wouldn't slow it down by that much
19:12:20 <beardtree> How do I use these functions in my code? http://hackage.haskell.org/package/primes-0.2.0.0/docs/Data-Numbers-Primes.html
19:12:26 <shachaf> I'd expect a possibly mispredicted branch to be way more expensive than division.
19:12:27 <NemesisD> roboguy_: i could but my goal is to have everything go through cabal
19:12:28 <Cale> I think to see the actual reason, you'd have to compare the actual transistor layouts for them
19:12:34 <shachaf> Not that I know anything about how those are actually implemented.
19:12:48 <beardtree> I tried `import Data.Numbers.Primes (isPrime)` but I get "Could not find module `Data.Numbers.Primes'"
19:13:12 <roboguy_> NemesisD: you could also add the location of cstdio with -I
19:13:20 <shachaf> Cale: Well, it's not as if you get to lay out transistors yourself anyway.
19:13:20 <Cale> beardtree: Probably you don't have that package installed
19:13:42 <NemesisD> roboguy_: id do that but doesn't that vary by platform?
19:13:50 <beardtree> Cale: `cabal list primes` only shows some third-party lib
19:13:51 <roboguy_> NemesisD: yeah, that's true
19:13:52 <NemesisD> and even distro/os
19:14:04 <Cale> shachaf: I mean, the reason that Intel provides one pair and not the other is because it probably requires fewer transistors
19:14:16 <novochar> I realize this isn't the best way example code, but it does have more than one line to step through: https://pastee.org/ju36m I want to step through this code, and I'm struggling to do this
19:14:27 <Cale> beardtree: ... whose documentation you linked
19:14:42 <novochar> within ghci, I'm trying `:load *Foobar`
19:14:45 <novochar> :break 2
19:14:47 <beardtree> Cale: ?
19:14:49 <roboguy_> NemesisD: is there a way to get cabal to run a makefile?
19:14:52 <novochar> :reload
19:14:55 <shachaf> Ah, the question isn't about what GHC provides but about what Intel provides?
19:15:12 <beardtree> How do you know that?
19:15:12 <Cale> shachaf: Well, the question was why quot/rem were faster than div/mod
19:15:20 <novochar> :run gives the error `Couldn't find command in "`
19:15:28 <NemesisD> roboguy_: that would work for me. anyone know if there's a "supported" way for have cabal shell out to a makefile to build a shared library?
19:15:40 <Cale> shachaf: and I believe that's because quot/rem are what the CPU provides, and it provides those because they were slightly cheaper to implement
19:16:06 <novochar> Tips on how to step through this sample code?
19:16:07 <shachaf> OK, sure.
19:16:18 <beardtree> Forgive my being skeptical, I just don't want to install untrusted code
19:16:38 <Cale> beardtree: Well, you linked documentation from the primes package on Hackage
19:16:58 <Cale> beardtree: cabal list will do lookups on hackage, so it would have shown you the primes package on Hackage.
19:17:23 <Cale> beardtree: If you're going to get a package for prime generation, I think my main recommendation would be arithmoi
19:17:49 <Cale> http://hackage.haskell.org/package/arithmoi -- it has lots of useful number theoretical stuff, and the implementations are quite fast as I recall
19:18:09 <beardtree> alabaster: sick, thanks
19:18:16 <beardtree> Err Cale
19:18:41 <Syao> solrize, the cpu implements mod that the remainder can be positive and negative, in today's math remainder is always positive or 0.
19:19:19 <Syao> solrize, see http://en.wikipedia.org/wiki/Moadulo_operation
19:19:33 <Cale> Of course, div/mod can result in negative remainders too, when the divisor is negative
19:19:45 <solrize> syao thanks but i know that.  i'm wondering why there's such a slowdown to check for a negative remainder and sometimes adjust it.  my question isn't about the math, it's about the machine isntruction timings.
19:20:08 <novochar> Also, is there an equivalent `pwd` command for ghci?
19:20:30 <roboguy_> novochar: you can run any command in ghci by putting a ! before it. like !pwd
19:20:35 <roboguy_> *any shell command
19:20:57 <Syao> solrize, write those operatons in assembly and see your self :)
19:21:14 <Cale> :!pwd rather
19:21:22 <novochar> thanks roboguy_
19:21:33 <NemesisD> i really don't get how this is supposed to work. if some how get ghc to build this c code that i bind to, how is it going to make sure it has access ot the shared object files it generates
19:23:01 <Syao> solrize, If the slowdown will be much less than in haskell's then we need to recheck. You can use C/Fortran instead of Assembly
19:23:53 <solrize> i was hoping someone already had the info.  i've looked at the instruction timings from agner.org
19:24:15 <solrize> i'll have to look at the asm code from ghc
19:26:33 <Syao> solrize, sorry. I guess yes.
19:30:27 <novochar> Tips on how to step through this sample code using ghci? https://pastee.org/ju36m
19:32:47 <NemesisD> has anyone written a cabal package that goes and compiles stuff before running?
19:37:22 <kazagistar> I'm just barely learning some basic haskell, and I am getting a parse error when I try to use guards, what am I doing wrong? http://lpaste.net/97985
19:37:49 <solrize> otherwise =
19:38:02 <solrize> on line 11
19:38:29 <randomclown> why does conduit need a monadic wrapper
19:38:48 <solrize> because it does i/o?
19:39:25 <kazagistar> solrize: doh, thanks!
19:40:18 <novochar> `:show breaks` results in this message: No active breakpoints.
19:40:21 <frege> is there a good book on distributed systems, concurrency models and parallel processing?
19:40:30 <frege> general not only for haskell
19:40:37 <Syao> solrize, found the spot of mod?
19:40:38 <novochar> I thought `:break 2` would have set a breakpoint
19:40:51 <solrize> syao haven't been looking.
19:43:23 <novochar> okay, `:break 2` did work and `:show breaks` shows there being a breakpoint, `[1] Main Foobar.hs:2:7-34`
19:43:46 <novochar> now to walk through the sample code and hopefully watch it break...
19:43:54 <novochar> From here, would I do `:reload`?
19:44:09 <novochar> Okay, doing that clears the breakpoints
19:44:28 <novochar> How would run the app stopping at the breakpoint?
19:47:18 <zRecursive> Why does "-Wall" warn me "Foo.hs:274:1: Warning: Defined but not used: `foo'" ? foo is a function in Foo.hs, which will be compiled into a library.
19:49:03 <carter> zRecursive: maybe becuase you don't have an explicit export list?
19:49:17 <zRecursive> carter: yeah
19:49:35 <carter> its good engineering to have explicit import and export lists
19:49:42 <carter> esp since we don't have "module types"
19:49:44 <carter> (yet)
19:50:08 <zRecursive> i see now
19:51:00 <novochar> Okay, I needed to do `:step main` after setting the breakpoint
19:51:10 <randomclown> @pl \a b -> return $ a + b
19:51:10 <lambdabot> (return .) . (+)
19:51:50 <randomclown> why is it (return .) instead of return . (+)
19:52:41 <erisco> :t (return .) . (+)
19:52:41 <shachaf> Expand out the definition of (.). One step at a time.
19:52:42 <lambdabot> (Monad m, Num b) => b -> b -> m b
19:52:44 <shachaf> @src (.)
19:52:44 <lambdabot> (f . g) x = f (g x)
19:52:44 <erisco> :t return . (+)
19:52:44 <lambdabot> NB: In lambdabot,  (.) = fmap
19:52:45 <lambdabot> (Monad m, Num a) => a -> m (a -> a)
19:52:46 <Iceland_jack> randomclown: there are two .'s
19:53:18 <erisco> :t (.:)
19:53:19 <lambdabot>     Not in scope: `.:'
19:53:19 <lambdabot>     Perhaps you meant one of these:
19:53:19 <lambdabot>       `.' (imported from Data.Function),
19:53:30 <erisco> @let (.:) = (.) . (.)
19:53:31 <lambdabot>  Defined.
19:53:33 <shachaf> (return . (+)) a b  =  return ((+) a) b
19:53:37 <erisco> :t return .: (+)
19:53:38 <lambdabot> (Monad m, Num b) => b -> b -> m b
19:54:01 <shachaf> Bringing up (.:) when someone doesn't understand why plain old (.) doesn't work is *really* unhelpful.
19:54:25 <erisco> shachaf, I disagree
19:54:32 <erisco> it is a point of comparison
19:56:00 <erisco> @let (.:) f g a b = f (g a b)
19:56:01 <lambdabot>  .L.hs:146:4:
19:56:01 <lambdabot>      Multiple declarations of `.:'
19:56:01 <lambdabot>      Declared at: .L.hs:142:1
19:56:01 <lambdabot>                   .L.hs:146:4
19:56:09 <erisco> oh :( well that definition is much clearer
19:57:04 <randomclown> where is .: defind anyway?
19:57:33 <erisco> I don't think it is defined in any standard module
19:59:51 <beardtree> What's wrong with line 5? https://gist.github.com/beardtree/4ee98ce1f13fdcec4ffc
20:00:31 <erisco> huh it seems that (.) (.) (.) works too
20:00:52 <erisco> that would make sense :)
20:03:04 <brisbin> beardtree: you seem confused about the type of (.) vs ($)
20:03:39 <beardtree> brisbin: solving one problem at a time
20:03:41 <brisbin> (.) needs two functions. you've given it a function (not) and a value (null line)
20:04:07 <brisbin> which is what ($) is for. application, not composition
20:04:20 <erisco> or the precedence is not clear
20:04:59 <erisco> (not . null) line    not $ null line      (not . null) $ line
20:05:02 <erisco> these are equivalent
20:05:04 <beardtree> OK, now line 6 is messed up
20:05:08 <brisbin> there are many problems in this gist
20:05:10 <beardtree> I fixed line 5 with a let
20:05:13 <beardtree> No shit
20:05:15 <frege> is this book legit? http://www.amazon.com/The-Art-Concurrency-Parallel-Applications/dp/0596521537
20:05:15 <brisbin> that was the issue on line 5
20:05:58 <brisbin> beardtree: the then branch and else branch have to return the same type
20:06:11 <brisbin> you've got one returning Integer and another IO Integer
20:06:18 <kazagistar> why is the parens needed in this expression?  ('a':"b"):["c","d"]
20:06:36 <brisbin> 'a' :: Char, "b" :: [Char]
20:06:36 <beardtree> brisbin: how do I get an integer into modulus?
20:07:09 <brisbin> beardtree: both branches should return IO Integer, then use modulus <- if...
20:07:32 <erisco> kazagistar, I think the default precedence is    'a':("b":["c","d"])
20:07:36 <erisco> :info (:)
20:07:42 <nooodl> it is
20:07:47 <erisco> infix 5 :
20:07:51 <erisco> infixr I mean
20:07:57 <beardtree> brisbin: pardon?
20:07:59 <kazagistar> huh, why? I thought it would be the other way around I guess
20:08:12 * hackagebot time-patterns 0.1.0.2 - Patterns for re-occurring events.  http://hackage.haskell.org/package/time-patterns-0.1.0.2 (jfmueller)
20:08:13 <erisco> yeah, well, you can have infixl operators and infixr operators
20:08:17 <frege> do you guys recommend this book? http://chimera.labs.oreilly.com/books/1230000000929
20:08:18 <brisbin> beardtree: what didn't make sense?
20:08:25 <beardtree> brisbin: what I should change
20:08:28 <erisco> infixl groups left-most and infixr groups right-most
20:08:39 <jfischoff> frege: yes
20:08:54 <kazagistar> erisco: how can I tell which is which?
20:09:06 <erisco> kazagistar, using :info on ghci or looking at the source
20:09:20 <kazagistar> ... oh
20:10:06 <erisco> @let (>:) = (:); infixl 5 >:
20:10:07 <lambdabot>  Defined.
20:10:22 <erisco> > 'a' >: "b" >: ["c","d"]
20:10:24 <lambdabot>  ["ab","c","d"]
20:10:42 <brisbin> beardtree: you're going to have to change the then branch to return IO Integer to match the else branch's type. then (since if is returning IO Integer) use modulus <- if... on line 5.
20:10:51 <stolaruk> Am I in cabal hell? "ghc-pkg: unregistering text-0.11.3.1 would break the following packages: blah blah blah"
20:11:22 <stolaruk> I want (need) to use the newer version of text that I already have installed.
20:11:49 <stolaruk> I don't know where this older version came from, unless it came with the Haskell platform
20:12:06 <NemesisD> hey folks. i've got a bunch of shared object files I want to link against
20:12:31 <NemesisD> im new to this. if i don't want these files to have to be installed globally, do i need to do static linking?
20:13:03 <erisco> NemesisD, no but I do not know all the details either
20:13:10 <jfischoff> slolaruk: when that happens recursively unregister the packages that would break and reinstall everything together with the version I want
20:13:37 <stolaruk> jfischoff: Ok, I'll try that. Thanks.
20:13:46 <NemesisD> erisco: i finally threw my hands up trying to get ghc to coordinate building this C++ code and just called the makefile from a cabal hook
20:13:57 <jfischoff> stolaruk: this could help https://github.com/glguy/GhcPkgUtils
20:13:58 <NemesisD> but now i have a bunch of object files and i need to make those functions available to ffi
20:14:02 <erisco> NemesisD, there are a series of paths dynamic loading will look at. typically the local directory is one of them
20:14:15 <erisco> (and the first one)
20:14:17 <brisbin> i keep a list of packages i use to automate a wipe-reinstall. call it "upgrading"
20:14:46 <stolaruk> jfischoff: Interesting, I'll try that.
20:15:04 <erisco> NemesisD, sorry I don't know :( not my forte eitehr
20:15:19 <erisco> that is sys admin stuff :P
20:19:29 <NemesisD> woo. well it compiles, but it can't find the shared object file when run now
20:19:50 <erisco> NemesisD, a typical location is the same directory as the executable
20:20:47 <NemesisD> aristid: should i move them? in the cabal file i tell it an include-dirs, but that doesn't seem to carry over to the executable
20:20:54 <NemesisD> they're in a subdirectory of the package
20:22:07 <erisco> NemesisD, there might be a flag on the linker to change where it looks for the libraries
20:22:57 <NemesisD> aristid: i'm woefully ignorant of this process, but shouldn't the compile fail if it the linker oculdn't find them
20:23:04 <ivanm> if I import a module qualified (specificall Control.Category), how do I write the names of the methods when defining the instance of a class from it?  Is it "class Cat.Category Foo where id = bar" ?
20:23:24 <erisco> NemesisD, I mean the path that is used at runtime
20:23:26 <NemesisD> for example, if i run the bin with LD_LIBRARY_PATH=path/to/custom/libs ./test it works
20:24:02 <NemesisD> aristid: ah. so the linker is configuring the binary to just look in the regular places or the current dir?
20:24:25 <erisco> approximately that, yes
20:24:46 <erisco> there are different setups depending on platform and formats and etc, which is why it is all confusing to me
20:25:06 <NemesisD> would it be easier to try to statically link?
20:25:13 <erisco> but generally, when your runtime tries to call a function in the dynamic library, it actually invokes a stub that asks the OS to load the lib
20:25:20 <NemesisD> from what i know that seems like it would be fine to statically link just this library
20:25:38 <NemesisD> the library is not globally installed, so i imagine the os won't know where to find it
20:25:56 <erisco> that depends on the OS and how it is configured :P
20:27:02 <simpson> ivanm: Sounds about right.
20:27:30 <ivanm> looks a bit weird having the module imported but not needing to qualify the method names :/
20:28:35 <enthropy> ivanm no you don't have to qualify the methods because the methods have to be in the class that is already qualified
20:28:42 <ivanm> *nod*
20:28:50 <erisco> NemesisD, I do not know if LD_LIBRARY_PATH is used by the OS to locate the libraries or if it is the user process that reads the environment variable *shrug*
20:29:18 <enthropy> it's not like  instance Cat.Category where f Prelude.. g = -- could ever make sense
20:29:19 <erisco> NemesisD, but I would like to think there is a way to configure someone of that nature into the binary itself
20:32:46 <dagano> can I be confident that cabal is getting the most recent release of a package if i've run cabal update?
20:33:13 <erisco> NemesisD, the system uses an environment variable to look for libraries
20:33:48 <NemesisD> i wonder if i should just have the user install libphash
20:33:55 <NemesisD> it looks like it is available on ubuntu
20:34:17 <erisco> well, the path usually includes whatever the cwd is
20:34:33 <erisco> which is where your binary is located
20:34:55 <NemesisD> so maybe i could copy the so file to the bin dir
20:35:14 <geekosaur> LD_LIBRARY_PATH is used by ld.so, on the systems that use it. note that it does *not* search $PATH, nor the current directory, by default.
20:35:34 <erisco> NemesisD, you could symlink likely
20:35:55 <erisco> mm
20:36:06 <geekosaur> (and is not portable; OS X uses a different mechanism. not just a different environment variable --- you can seriously break stuff by treating DYLD_LIBRARY_PATH like Linux LD_LIBRARY_PATH)
20:36:11 <erisco> I think on windows it is a progression of local dir, then system32 and a couple others, then the GAC
20:36:16 <geekosaur> correct fix for local libraries is -rpath
20:36:50 <geekosaur> which does the right thing on Linux/*BSD/Solaris where it's needed, and is generally ignored on OS X which hardcodes dylib paths anyway
20:37:19 <geekosaur> not sure what happens on Windows but often the current directory *is* searched (but this can vary between Windows versions!)
20:37:42 <slack1256> How do I tell ghc to look for libraries on a cabal-dev sandbox I got?
20:37:50 <NemesisD> geekosaur: so in your opinion i should use rpath in cabal somehow?
20:37:52 <erisco> geekosaur, I think in NemesisD's case the shared libs are not in the same directory. Is there a way for the binary to inform the OS the correct relative path to look in?
20:38:24 <NemesisD> geemaybe i should back up and explain the whole problem, maybe i should put it on the user to install the shared library to their system
20:39:25 <geekosaur> NemesisD: yes, probably as a ghc option -optl-rpath -optl(path here)
20:39:38 <NemesisD> geekosaur: i'm writing haskell bindings for libphash, which is a library that people don't typically have but seems to be available in package managers and can be installed from source
20:40:25 <NemesisD> so my options are distribuute the source with my cabal package, run configure and make in the pre configure hook in cabal, use rpath, or to put in the docs to go install libphash
20:40:41 <geekosaur> oh, -rpath s not quite right, -R is more portable
20:41:25 <geekosaur> if you are embedding it in your cabal project then you want -optl-R. if you are requiring that others install it then you need to have them install it in a standard place (the usual solution) or find a way to locate it (configure?) and get -R from that
20:41:52 <geekosaur> configure might be the right answer here
20:42:22 <NemesisD> if they install it out of band isn't that handled by their package manager? its gonna put it in with all the other shared libraries
20:42:45 <geekosaur> if they get it from their package manager, yes
20:43:11 <geekosaur> if they install it from source or from an add-on package manager (think macports or homebrew on OS X) then additional work usually needs to be done
20:43:34 <erisco> aint package management fun
20:43:55 <geekosaur> indeed. this is a very large part of *why* autoconf exists
20:44:45 <NemesisD> this whole thing has been an eye opening experience
20:45:06 <NemesisD> i mean really i've spent probably 5 hours on this and only 10 minutes writing code to bind to 2 cpp functions
20:45:20 <zedik> hi everybody! what's wrong with the function?
20:45:20 <zedik> subs n (x:xs) = bg ++ en
20:45:20 <zedik>     where
20:45:20 <zedik>         bg =  [take n xs]
20:45:33 <zedik>         en =  [subs n xs ]
20:45:52 <jmcarthur> zedik: in the future, please use lpaste for multiline snippets
20:45:57 <geekosaur> use the paste site in the /topic, please
20:46:03 <geekosaur> but my guess is that you are confusing levels of lists
20:46:40 <zedik> ok! sorry
20:46:41 <geekosaur> in particular you have one more level of lists on en than on bg, so you will get a type mismatch (likely expressed as an "infinite type")
20:47:32 <jmcarthur> zedik: if you try adding type signatures for subs, bg, and en, i think you are likely to discover what the problem is.
20:47:53 <slack1256> guys sorry for the insistence
20:48:04 <slack1256> But how do I tell ghc to search for libraries on a cabal-dev sandbox
20:48:15 <geekosaur> I saw your question but I do not know the answer
20:48:36 <zedik> jmcarthur: thanks, i'll try
20:48:37 <slack1256> oh, sorry
20:48:37 <geekosaur> if you're not gettiung an answer here, try asking on the haskell-cafe mailing list
20:48:40 <erisco> slack1256, "cabal list" is the search command. beyond that, I dunno.
20:48:40 <geekosaur> not everyone is active on irc all the time
20:49:45 <lightquake> slack1256: what are you trying to do?
20:50:11 <stolaruk> jfischoff: So unregistering and forcing reinstall of my packages seems to have worked. However "ghc-pkg check" reports a lot of errors about "file doesn't exist"... Do you think this is anything I should be concerned about?
20:50:32 <stolaruk> Well not errors, warnings...
20:50:51 <jfischoff> stolaruk: not sure, feel free to paste the warning
20:50:53 <dagano> why does cabal grab an old version of a package .. if i've run 'cabal update'?
20:51:51 <stolaruk> jfischoff: There are many warnings, all similar to this: "Warning: haddock-interfaces: /home/jason/.cabal/share/doc/x86_64-linux-ghc-7.6.3/Cabal-1.18.1.2/html/Cabal.haddock doesn't exist or isn't a file"
20:52:11 <jj_556> If I have a record : data Employee = Employee { id :: String
20:52:11 <jj_556>                          , firstName :: String
20:52:11 <jj_556>                          , lastName :: String
20:52:11 <jj_556> 	                 , phone :: String
20:52:11 <jj_556> 	                 } deriving (Show)
20:52:25 <jj_556> do I have to use all the fields when I create it?
20:52:38 <jfischoff> stolaruk: its warning about documentation, but I don't why that happens
20:52:41 <slack1256> lightquake: make ghc-mod (which take ghc options) to play nice with some packages in a sandbox
20:52:48 <jj_556> or can I partially use certain fields?
20:53:07 <stolaruk> jj_556: You have to give a value for all fields.
20:53:26 <slack1256> you can give undefined to the ones you don't like
20:53:26 <jj_556> stolaruk: darn
20:53:27 <Polarina> jj_556, if you want optional fields, you can wrap them up in a Maybe.
20:53:36 <lightquake> slack1256: somewhere in the cabal-dev sandbox folder there's a file whose name ends in .package.conf.d
20:53:37 <stolaruk> You can use record update syntax to create a new object from an existing one, changing only certain fields.
20:54:03 <lightquake> if you pass -no-user-package-db -package-db path/to/whatever.package.conf.d it should work
20:54:35 <jj_556> Polarina: I would still have call them all at "construction"
20:54:51 <jj_556> I guess "invocation" is proper?
20:55:24 <lightquake> slack1256: though if you can I suggest using cabal 1.18 sandboxes, they have better integration with the rest of cabal. though you'd still probably have to specify the package db, since ghc-mod isn't smart enough.
20:55:40 <stolaruk> jfischoff: Yes all those warnings are indeed about Haddock. Strange. All I did was unregister the packages and then do a reinstall with cabal, forcing reinstall... Well at least my code is compiling now.
20:56:45 <Polarina> jj_556, what is it you're trying to achieve?
20:57:44 <stolaruk> jj_556: You can just do Employee myEmp = "Joe" "" "" ""
20:57:51 <kazagistar> data Encoded a = Single a | Multiple Int a  -- I want a to be of typeclass Eq, how can I add this?
20:57:57 <lightquake> stolaruk: ew, gross
20:58:03 <stolaruk> haha
20:58:11 <lightquake> kazagistar: you can't. not in any nice way, at least.
20:58:27 <jj_556> Polarina: Just playing with the language...understanding
20:58:32 <Polarina> kazagistar, you can not. Add a (Eq a) constraint to your functions that uses that structure.
20:58:46 <slack1256> lightquake: It worked like a charm
20:58:54 <lightquake> slack1256: good to hear :)
20:59:13 <slack1256> well as a temporal measure a little bit of vimL can be set to "toogle" the cabal sandbox
20:59:20 <slack1256> heck, that can even be a patch
21:00:13 <lightquake> ugh, that reminds me of that really awful project I wanted to work on... the ghc api is so hoary.
21:00:38 <kazagistar> lightquake, Polarina: Is there some kind of decidability reason, or is that just a style thing?
21:00:58 <slack1256> but this is a little patch. ghc-mod pass the option directly to ghc api, so is problem for another folk
21:01:14 <slack1256> seriously, thanks lightquake, this is very good
21:01:41 <lightquake> kazagistar: Haskell's type system doesn't let you do what you're trying to do, it doesn't have anything to do with decidability
21:01:54 <roboguy_> lightquake: it doesn't? I just did it...
21:02:04 <lightquake> roboguy_: -XDataContexts doesn't count
21:02:24 <roboguy_> lightquake: ... no extensions ...
21:02:29 <lightquake> roboguy_: what did you do, then?
21:02:59 <roboguy_> lightquake: like this http://lpaste.net/97986
21:03:37 <lightquake> ah, that's not what kazagistar asked, I think. kazagistar wanted a way to make it so that you can't have, say, Encoded (Int -> Int) since there's no Eq instance for (Int -> Int)
21:03:37 <jj_556> If I have a type parameter named id, all hell breaks lose when I try to use it in a record
21:04:07 <lightquake> jj_556: paste code? it sounds like you're confusing type-level things and variable-level things somewhere.
21:04:08 <roboguy_> lightquake: ahh. I thought that was the data type he wanted
21:04:19 <kazagistar> yes, lightquake, that is what I was asking
21:04:28 <jj_556> ok
21:04:42 <lightquake> kazagistar: so, you can *technically* do that, but you'll still have to write the Eq a constraint everywhere you actually want to make use of it.
21:04:54 <roboguy_> yeah, you can't really have an Eq instance for Int -> Int
21:05:33 <stolaruk> jj_556: There is already a standard function named "id".
21:05:38 <lightquake> ... oh wait can you reify the context into a witness and then use that? i know there's a *lot* of black magic.
21:06:08 <jj_556> lightquake, stolaruk: http://pastebin.com/LetjDv3D
21:06:13 <mauke> The paste LetjDv3D has been copied to http://lpaste.net/97987
21:06:51 <jj_556> lightquake, stolaruk:  Ambiguous occurrence `id'
21:06:51 <jj_556>     It could refer to either `Main.id',
21:06:51 <jj_556>                              defined at PatternMatching.hs:5:28
21:06:51 <jj_556>                           or `Prelude.id',
21:07:15 <lightquake> jj_556: in your code, `id` is being used as a field name, not a type parameter
21:07:31 <danilo2> Hello! Is there a way to make this 6-line program working? I completely do not understand why haskell does not allow me to write it: http://lpaste.net/97988 :(
21:07:46 <danilo2> I would be very thankful if someone could explain it to me
21:07:51 <lightquake> when you use that syntax, the compiler automatically constructs a function id :: Employee -> String in the current module. then, later, you try to call it and it gets confused because there are two functions with name `id` in scope
21:08:17 <lightquake> edwardk: can you reify a context into a witness somehow and then pull it back out again? I know your reflection package does terrifying things along these lines
21:08:20 <Cale> danilo2: It's because if we put the explicit quantifier in,  test :: forall a. (a -> a) -> (Int, String)
21:08:26 <jj_556> lightquake: is there a way to descriminate so I can set the right one?
21:08:40 <lightquake> jj_556: yes, but you probably want to just call it something else instead
21:08:41 <edwardk> context in what sense?
21:08:42 <Cale> danilo2: but the code you wrote uses the function parameter as if the type was
21:08:47 <kazagistar> ok, I see. It works as long as you rely on inference and use the flag -XDataTypeContexts, but it is ugly to use
21:08:52 <Cale> test :: (forall a. a -> a) -> (Int, String)
21:09:24 <Cale> danilo2: If you add {-# LANGUAGE RankNTypes #-} to the top of your file, and give that explicit type signature, it should work.
21:09:25 <lightquake> edwardk: something like eqWithWitness :: Witness Eq a -> a -> a -> Bool
21:09:30 <jj_556> lightquake: noted, but I am just learning, so if you have other information I would love it
21:09:39 <lightquake> kazagistar: no, you can't even infer it.
21:09:44 <danilo2> Cale: It works, you are right - I forgot about rankNTypes
21:10:03 <stolaruk> jj_556: Yeah change your "id" to "empId" and it should work.
21:10:05 <edwardk> lightquake: oh that. yes you can do that with reflection
21:10:07 <lightquake> all that it gives you is a constraint at construction time; you would still have to write the context everywhere you actually use the value of type `a`.
21:10:15 <Cale> danilo2: Basically, you can imagine that there's an invisible parameter to test which specifies the type a
21:10:33 <danilo2> Cale: hmm, ok, could you please tell me, without the forall keyword, haskell assumed (forall a. (a->a) -> (Int,String)) am I right?
21:10:42 <Cale> yes
21:10:51 <edwardk> lightquake: see the examples folder of the reflection package and reflection-extras by jfischoff which packages up the idea i implemented there.  also  there is a tutorial by thoughtpolice on how that works
21:11:00 <Cale> Well, sort of
21:11:14 <jj_556> thanks everyone
21:11:18 <Cale> That's what it took from your explicit signature anyway
21:11:22 <lightquake> edwardk: reflection uses GHC's internal typeclass implementation and unsafeCoerce, right?
21:11:40 <edwardk> lightquake: n a way that is also compatible with hugs, but yes
21:11:40 <danilo2> Cale: And what it would infer without my signature? I think the same ?
21:11:41 <Cale> The code itself doesn't typecheck, because GHC will never infer a polytype
21:11:57 <Cale> You can remove the explicit signature and see for yourself
21:12:08 <Cale> It'll have trouble in the same way when trying to decide the type of f
21:12:17 <Cale> and it will never guess that f needs to be polymorphic
21:12:21 <edwardk> lightquake: with 7.10 we'll probably move 'reify' into GHC proper. we started to do it a month or two ago in 7.8, bu the release at the time seemed more iminent, so we backed off.
21:12:40 <edwardk> had i known how long the release cycle was going to run i'd have probably stuck with pushing it into ghc this time aroun
21:13:01 <lightquake> oh, neat. as it is using it makes the hair on the back of my neck stand up because of how black the magic is but if it's going to be part of ghc itself i feel better about it :)
21:14:13 <danilo2> Cale: Ok, I started to recognize this - I was bothering with it in the past. There was some Microsoft documents about making type checker, that could infer polymorphic types and even a sample implementation in Haskell. I'm wondering why GHC could not do it :(
21:14:35 <Cale> Usually it's not what you want.
21:15:22 <danilo2> Cale: but sometimes it would be helpfull -  with for example flag "-XAutomaticRankNTypes"
21:15:50 <Cale> Usually if you come across code like your test there, that's an honest type error
21:16:27 <Cale> Deferring that error to the usage site by inferring a fancy type for test probably isn't usually the right thing to do.
21:16:37 <danilo2> Cale: http://research.microsoft.com/en-us/um/people/simonpj/Papers/higher-rank/
21:17:09 <Cale> Yeah, did you read that paper?
21:17:34 <danilo2> Cale: Not yet, but I feel you did :)
21:19:10 <danilo2> Cale: am I right? If yes does this article does not present such automatic type inferencer?
21:19:49 <Gorroth> um, i'm very sorry
21:19:55 <Gorroth> i think i spammed some people with sysinfo stuff
21:20:00 <Gorroth> i messed up my sysinfo script
21:20:20 <Gorroth> i didn't mean to do that
21:21:15 <Cale> Well, actually, this isn't quite the paper that I thought it was... but I think all they do is work out how to do type inference in the face of explicitly given higher-rank types, without inferring those types automatically.
21:21:48 <Cale> but hmm
21:22:46 <Cale> Oh, it looks like they do infer polytypes here
21:22:56 <Cale> In any case, the actual system which GHC uses doesn't.
21:23:56 <pyon> How do I use ghci with sandboxes?
21:24:29 <pyon> I have a sandbox in ~/test, and I am on a terminal with ~/test as the current directory.
21:26:09 <danilo2> Cale: exactly
21:26:28 <Cale> (You'll note later work by SPJ on System F_C)
21:27:37 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
21:28:45 <Cale> That paper I believe is somewhat current with respect to the basic system of how things are inferred. I could be mistaken :)
21:29:32 <subleq> what's the equivalent of ((lambda (x) (x x)) (lambda (x) (x x)))?
21:29:38 <danharaj> Cale: do you Agda much?
21:29:45 <Cale> danharaj: Just a little bit
21:29:47 <lightquake> edwardk: hm. I'm looking at https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs and trying to figure out how to turn that into what I want, but I can't manage to get rid of the constraint
21:29:54 <Cale> subleq: In Haskell?
21:29:56 <jmcarthur> subleq: syntactically,  (\x -> x x) (\x -> x x), but it won't pass the type checker that way
21:30:00 <danharaj> Cale: I'm trying to figure out what the most efficient way to learn Agda and Emacs at the same time is.
21:30:01 <subleq> Cale: yeah
21:30:08 <Cale> subleq: You'll need some isorecursive type to make it typecheck
21:30:11 <subleq> jmcarthur: right, I can't figure out how to make it type
21:30:19 <Cale> data Rec a = In { out :: Rec a -> a }
21:30:39 <Cale> loop = (\x -> out x x) (In (\x -> out x x))
21:30:39 <lightquake> right now I have using (Eq $ \_ _ -> True) (id == id), but it's still trying to find an Eq instance for a -> a
21:30:43 <danilo2> Cale: hmm, interesting. I have to read it - or at least start and see whats going on there
21:30:44 <danilo2> :)
21:31:31 <jmcarthur> subleq: it's unfortunate that we so often direct learners of haskell to the lambda calculus, because the untyped lambda calculus tends to confuse with examples like this :)
21:31:32 <Cale> danilo2: Anyway, it might be possible to infer polytypes sometimes, but I think it's complicated in general once you throw in all the other things that the GHC type system has to worry about
21:31:47 <Fylwind> @pl (>.#) f = (>#) (f . F)
21:31:47 <lambdabot> (line 1, column 10):
21:31:47 <lambdabot> unexpected " "
21:31:47 <lambdabot> expecting operator
21:31:51 <binroot> Hi, I'm trying to parse JSON from a website using Aeson, but Aeson requires Data.ByteString.Lazy.Internal.ByteString. Am I supposed to convert the retrieved String into this strange data structure?
21:32:08 <Fylwind> g f = h (f . F)
21:32:13 <Cale> danharaj: Well, I haven't bothered ever learning emacs
21:32:13 <Fylwind> @pl g f = h (f . F)
21:32:14 <lambdabot> g = h . (. F)
21:32:24 <danharaj> Cale: Isn't Agda a pain to use without emacs?
21:32:26 <danilo2> Cale: That ddoes not make me happy, but well, I cannot do nothing with it :(
21:32:27 <Cale> danharaj: I just use the menus
21:32:32 <danharaj> menus?
21:32:41 <Cale> danharaj: Oh, I use emacs, but I use it the same way I'd use gedit.
21:32:48 <danharaj> ah
21:32:55 <danharaj> If I use emacs like that Ryan will make fun of me.
21:32:58 <Fylwind> same way as gedit?
21:33:27 <Cale> I don't think it's worth learning how to use any better than that
21:33:42 * lightquake grabs a pitchfork
21:33:46 <danharaj> hm alright
21:34:00 <Cale> Text editors are something you can sink arbitrary amounts of time into for essentially no return
21:34:13 <danharaj> true enough
21:34:25 <Fylwind> it gets confusing sometimes
21:34:52 <augur> danharaj: agda sans emacs is insane
21:34:56 <ChongLi> Cale: so you don't even know the hotkeys for jumping around text in emacs?
21:34:58 <augur> never do it
21:35:05 <Cale> ChongLi: I just use the mouse
21:35:07 <Fylwind> sometimes i find myself pressing C-p C-n in nonemacs
21:35:09 <Cale> and the arrows
21:35:16 <ChongLi> ahhh!
21:35:16 <Cale> also, page up and down
21:35:40 <ChongLi> you're lucky
21:35:55 <augur> i rather like these text editors with rich commands tho
21:36:00 <Cale> Anything which involves pressing a modifier key and which isn't part of Agda-mode, you can basically be sure I'm not pressing that
21:36:10 <ChongLi> oh, you use agda-mode
21:36:20 <Fylwind> i learned the emacs key bindings so that if I ever get stranded on an island with only a laptop and ssh access, I can at least get some work done
21:36:23 <ChongLi> I don't think gedit has that
21:36:29 <augur> you need to use agdamode when coding in agda
21:36:36 <Cale> ChongLi: Well, sure.
21:36:59 <Cale> ChongLi: I said that to get across the idea of how I edit text in emacs.
21:37:25 <Fylwind> it'd be nice if emacs behaved more like a modern text editor
21:37:30 <Cale> At one point I knew a few dozen emacs keys, but I've since forgotten them all, and I don't even care.
21:37:33 <ChongLi> you also know how to kill and yank?
21:37:45 <jmcarthur> counterpoint: i know of nobody who regrets spending the time to learn to use emacs or vim
21:38:18 <ChongLi> jmcarthur: it's one of those things
21:38:24 <dolio> Whenever I pair program with someone using an editor on the level of gedit, it seems awful.
21:38:25 <ChongLi> you can feel a lot more productive
21:38:29 <Fylwind> several times i would select some text, M-W only to realize that I accidentally pressed M while I was selecting, and it turned into a secondary selection
21:38:40 <ChongLi> but you may have taken hours and hours to configure your editor and learn all this stuff to get there
21:38:52 <Cale> ChongLi: I just use the menu, since the standard keys don't work, and I'm not going to be bothered memorising other ones.
21:38:52 <brokenzebra> is there a built-in version of 'fold blah start . map blah2'?
21:38:53 <startling> ctrl-a, ctrl-e, alt-f, alt-b, and alt-d are killer
21:38:56 <jmcarthur> even if it only *feels* more productive, it's probably still worth it
21:39:07 <Cale> (but largely, I just don't cut and paste)
21:39:07 <jmcarthur> (but i think it *is* actually more productive in the grand scheme of things)
21:39:12 <startling> especially for doing things in windows that aren't emacs
21:39:17 <ChongLi> jmcarthur: well it's worth it to me
21:39:25 <ChongLi> but that's because I have an annoying optimizing brain
21:39:32 <ChongLi> if I feel like I'm doing a repetitive task
21:39:38 <ChongLi> I can't let it go
21:39:45 <ChongLi> I have to figure out a way to automate it
21:39:51 <Fylwind> someone needs to invent a more ergonomic set of keybindings for text editors though
21:39:52 <Cale> I don't do anything all that repetitive when editing Agda code
21:40:07 <ChongLi> what about editing other files?
21:40:14 <Cale> I don't use emacs for that
21:40:14 <jmcarthur> it's worth it to me because i have spent so many times more hours *using* emacs than i have spent *learning* to use it
21:40:20 <ChongLi> ah, what do you use then?
21:40:40 <Cale> Mostly vim, because it loads faster. I don't use it like vim users would want me to though.
21:40:41 <jmcarthur> i also took the time to learn vim even though it is redundant, and i don't regret that either
21:40:48 <Cale> I use it much like I use emacs :)
21:41:02 <ChongLi> but you do know how to substitute and stuff?
21:41:05 <jmcarthur> (well, it's not really redundant either)
21:41:11 <Cale> yes
21:41:14 <ChongLi> okay
21:41:18 <ChongLi> I was gonna say
21:41:22 <jmcarthur> (i have ended up using evil-mode in emacs, primarily)
21:41:27 <roboguy_> brokenzebra: maybe foldMap?
21:41:30 <ChongLi> there are some editing tasks that would be insane without some form of search/replace
21:41:39 <Cale> Though I almost never use it
21:41:52 <Cale> I guess every once in a blue moon it's useful to know
21:42:00 <ChongLi> so if there was an agda-mode for vim
21:42:04 <ChongLi> would you use that?
21:42:11 <Cale> I don't really care
21:42:22 <Cale> Maybe?
21:42:43 <Cale> If there was something like coqide for Agda, I would use that
21:42:51 <ChongLi> I guess you're not bothered at all when your workflow is interrupted by having to figure out what context you're in
21:43:05 <ChongLi> that happens to me all the time when I switch between vim and emacs
21:43:18 <ChongLi> I start using the wrong key commands
21:43:22 <Cale> Well, my workflow doesn't involve anything very particular to either of those editors
21:43:28 <dolio> If you're using it like he does, it doesn't matter which he's in.
21:43:43 <ChongLi> ah, so you just hit i when you start vim
21:43:45 <ChongLi> and that's that?
21:43:49 <Cale> Pretty much!
21:44:05 <ChongLi> so why not just use nano?
21:44:07 <ChongLi> haha
21:44:08 <startling> Cale, in all seriousness, why not nano?
21:44:08 <startling> haha
21:44:10 <startling> jinx
21:44:16 <dolio> You know, vim has a setting that makes it behave more like a regular text editor.
21:44:36 <stolaruk> Isn't that the aforementioned i?
21:44:39 <Cale> startling: Not sure if nano has the option to convert tabs to spaces automatically?
21:44:50 <ChongLi> aha!
21:44:51 <Cale> also syntax highlighting is nice
21:44:55 <ChongLi> so you've configured vim!
21:44:58 <ivanm> Cale: there is syntax highlighting for nano
21:45:01 <Cale> Basically, those two things are the only things I care about
21:45:02 <Clint> i suspect that nano doesn't understand either tabs or spaces
21:45:18 <Fylwind> probably the second most useful thing in emacs is C-S, M-S-5, and C-M-S-5
21:45:21 <Cale> If tab characters end up in my source files, I'm unhappy
21:45:42 <ChongLi> ahh, so you don't just mash the space bar to line up every line of code?
21:46:07 <Cale> I have tab configured to insert two spaces, more or less.
21:46:08 <enthropy> System.IO.Unsafe.unsafePerformIO and Foreign.unsafePerformIO are not the same definition?
21:46:20 <Cale> So I'll mash that to make things line up :)
21:46:35 <ChongLi> haha
21:46:39 <Cale> enthropy: They ought to do the same
21:46:51 <ChongLi> though it must suck sometimes if you get an off-by-one
21:46:57 <Cale> ChongLi: I suppose I also have it set up to continue the next line at the same indentation level as the last
21:46:59 <Cale> which is useful
21:47:04 <enthropy> Cale: they broke my file to add this warning: Deprecated: "Use System.IO.Unsafe.unsafePerformIO instead; This function will be removed in the next release"
21:47:05 <ChongLi> oh, definitely
21:47:14 <Fylwind> i swear no language makes me more OCD about indentations than Haskell-esque ones
21:47:15 <Cale> Most editors will do that
21:47:33 <ChongLi> if only there was an editor that understood Haskell's layout rules
21:47:53 <Cale> ChongLi: Well, there's Chris Done's fancy emacs stuff
21:48:07 <ChongLi> I've looked at it
21:48:12 <ChongLi> sometimes it makes a mistake
21:48:14 <Cale> https://github.com/chrisdone/structured-haskell-mode
21:48:17 <ChongLi> and then you're scrambling
21:48:21 <Cale> mm
21:48:51 <ChongLi> it's no good at all if some automation task fails occasionally and you're forced to intervene
21:48:58 <Cale> I decided that the autoreindenting would almost be worth trying to get it set up, but it was pretty unusable for me.
21:49:14 <startling> yeah, I've been meaning to try that too.
21:49:54 <Cale> I pretty much hate all of the emacs haskell-mode indenting things.
21:50:08 <roboguy_> Cale: I agree with you there
21:50:09 <subleq> I'm getting a stack overflow and I don't know where to start debugging. I've got too much code to isolate the issue
21:50:25 <startling> I have very strong opinions about indenting haskell, and editors rarely share them.
21:50:34 <shachaf> @where rts-xc # might help if you haven't tried it
21:50:35 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
21:50:38 <Cale> subleq: Look for operations which are accumulating state somehow.
21:50:43 <subleq> And i am using foldl'
21:50:49 <roboguy_> subleq: you could put in some calls to trace and traceShow from Debug.Trace
21:51:51 <Cale> subleq: The usual thing which kills the stack is that you end up with a big unevaluated expression in memory which is composed of strict functions, and when it gets evaluated, those strict functions matching on their arguments uses up lots of stack.
21:52:13 <augur> what should i read to make sure im doing IO in haskell right, without the risk of laziness causing effect ordering to be weird?
21:52:43 <augur> i just need IO like putStr and getStr, nothing fancy
21:52:56 <Fylwind> if you're not using unsafePerformIO i don't see how the ordering can get screwed up
21:52:58 <enthropy> those don't use lazy IO
21:53:20 <enthropy> Fylwind: readFile does the IO when you actually use the string it produces
21:53:28 <augur> ive had weird experiences with laziness in the past using just those two, but ok
21:53:51 <subleq> shachaf: Perhaps you haven't installed the profiling libraries for package `curl-1.3.8'?
21:53:54 <subleq> i don't know how to do that
21:53:59 <Fylwind> enthropy: ah I see
21:54:13 <enthropy> augur: maybe the problem you call "laziness" is buffering?
21:54:21 <augur> enthropy: who knows
21:54:29 <shachaf> subleq: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
21:54:30 <roboguy_> augur: did you throw in some flushes?
21:55:00 <enthropy> or hSetBuffering stdout NoBuffering
21:55:16 <augur> roboguy_: i dont know what that means :D
21:55:32 <enthropy> augur: read the docs for System.IO
21:55:56 <augur> enthropy: which where did you have in mind huh
21:55:58 <augur> 0.0
21:56:09 <enthropy> @docs System.IO
21:56:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/system-io.html
21:56:24 <enthropy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
21:56:43 <augur> ok
21:57:25 <ChongLi> if you actually want laziness in your IO but don't want issues with file handles
21:57:45 <ChongLi> would one of the pipes/conduit style libs be good?
21:58:43 <roboguy_> augur: hFlush flushes a buffer. if buffering was the problem, that isn't related to laziness and is something you might run into in strict languages (like C++, for instance)
21:58:58 <augur> interesting
21:59:31 <augur> well, the problem i was having was that i would do something like print a sigil thing for an input line, and then do getLine, and if would request the line before printing the sigil, etc.
22:00:57 <roboguy_> augur: put hFlush stdout after your putStr and see if that helps
22:01:40 <augur> roboguy_: ill see if that helps, if it comes up again, thanks :)
22:01:48 <subleq> when I run with -xc I just get: stack trace: Main.CAF
22:02:07 <roboguy_> subleq: did you compile with -auto-all?
22:03:23 <subleq> roboguy_: there we go
22:09:17 <ivanm> is there a class that has a method/operator like <<< or >>> from Control.Category without the id method as well?
22:09:47 <roboguy_> ivanm: Semigroupoid
22:10:06 <ivanm> is that in base?
22:10:15 <roboguy_> ivanm: no, it's in semigroupoids
22:10:35 <ivanm> :(
22:10:40 <roboguy_> ivanm: what's wrong with that?
22:10:48 <ivanm> was hoping to minimise non-base dependencies
22:11:05 <roboguy_> ivanm: ahh. I generally never really care about that
22:11:07 <ivanm> and this is more a "it'd be nice to use an existing operator for this function rather than defining my own"
22:11:21 <ivanm> speak of the developing devil... :p
22:11:44 <roboguy_> ivanm: it's used by lens, and a lot of people already have lens these days
22:11:56 <ivanm> roboguy_: I'm still resisting! ;-)
22:12:02 <roboguy_> (or they should, hah)
22:12:48 <ivanm> in theory lens sounds cool, but in practice when I've looked at it I found it too big to work out where to get started, and IIUC it can have a performance hit
22:13:10 <subleq> I'm using minimumBy (comparing expensiveFunction), and it's calling expensiveFunction many times on the same argument
22:13:35 <ivanm> subleq: you want a schwartzian transform aka decorator-undecorator
22:13:35 <osa1> can I create a module with same name with another package's module while exporting some modified versions of same names from original module? (I also want to import original module from my custom module)
22:13:54 <ivanm> osa1: you can use the named imports extension from GHC... but you shouldn't
22:14:05 <subleq> i'm trying to get the semantics of python's min(..., key=expensiveFunction)
22:14:12 <osa1> ivanm: why I shouldn't?
22:14:16 <ivanm> @google decorator undecorator
22:14:17 <lambdabot> http://www.merriam-webster.com/dictionary/undecorative
22:14:17 <lambdabot> Title: Undecorative - Definition and More from the Free Merriam-Webster Dictionary
22:14:35 <ivanm> osa1: IIRC, it isn't exactly always safe, and can cause confusion
22:14:40 <ivanm> you might as well use a new module
22:15:06 <startling> :t minBy
22:15:06 <lambdabot> Not in scope: `minBy'
22:15:07 <ivanm> subleq: https://en.wikipedia.org/wiki/Schwartzian_transform
22:15:37 <ivanm> subleq: you typically do something like: fst . minimumBy (comparing snd) . map (\ x -> (x, f x))
22:16:13 <ivanm> subleq: this is a manual version of python's behaviour
22:16:23 <subleq> startling: yeah, i think there's another function that works similarly so i was surprised
22:16:26 <subleq> ivanm: ok, thanks
22:17:22 <ivanm> roboguy_: the other issue being that Semigroupoid's `o' function doesn't have a cool operator symbol like (.), (<<<) or (>>>) :p
22:17:38 <roboguy_> ivanm: haha, well I guess they ran out
22:17:54 <roboguy_> you could do f `o` g, but I guess that's not quite the same
22:18:33 <ivanm> yeah
22:19:16 <maxs`> :t unsafeCoerce . unsafeCoerce
22:19:17 <lambdabot> Not in scope: `unsafeCoerce'
22:19:17 <lambdabot> Not in scope: `unsafeCoerce'
22:19:23 <ivanm> I'm trying to define this for a parser; the problem being that I can't really define Category's `id' method as I have no way of writing "empty input" without some restriction on the input
22:20:08 <dmwit> Isn't there sortOn and friends lying around somewhere?
22:20:28 <ivanm> @hoogle sortOn
22:20:28 <lambdabot> No results found
22:20:39 <ivanm> dmwit: there's probably _some_ library with utility functions like it
22:20:40 <subleq> dmwit: i thought i saw one, but now i can't find it
22:21:11 <dmwit> http://hackage.haskell.org/package/data-ordlist-0.4.5/docs/Data-List-Ordered.html#v:sortOn
22:21:12 <ivanm> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=sorton
22:21:39 <subleq> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Exts.html#v:sortWith
22:21:56 <subleq> there it is
22:22:41 <dmwit> Oh, hooray, a conflicting naming convention.
22:22:51 <ivanm> is that an exposed module?
22:23:02 <subleq> i dunno, i only found it with hoogle and the type
22:23:28 <dmwit> It seems to be usable in ghci.
22:23:33 <ivanm> ahhh, it is
22:23:41 <edwardk> ivanm: if there is any performance hit for common operations that would be considered a bug. almost everything you want to do that doesn't involve gratuitous use of folds should be the same speed as the hand rolled code or faster
22:24:00 <edwardk> there are some cases with folds that we can write that perhaps you shouldn't if you care about speed
22:24:11 <ivanm> edwardk: oh? I seem to recall you saying when you first started work on lens that there would be a hit
22:24:21 <edwardk> there was, we fixed that
22:24:34 <ChongLi> that's pretty awesome
22:24:35 <ivanm> dammit, there's one excuse for not using lens gone!
22:24:40 <ivanm> thank you very much edwardk! :p
22:24:41 <Fylwind> i'm using view patterns atm with something like: f (view -> Left a) = ...; f (view -> Right a) = ... but GHC is complaining that it's a nonexhaustive match; is there a way to avoid this somehow without turning off the warning altogether?
22:24:52 <edwardk> for pretty much any case where you are applying a concrete lens to a concrete combinator it should be fine
22:25:11 <edwardk> Fylwind: view patterns trigger that warning all the damn time, sadly
22:25:20 <edwardk> you can turn off the warning, yes
22:25:32 <ChongLi> ahh, so big compositions of lenses, traversals and all that can be costly?
22:25:40 <Clint> edwardk: representable-functors
22:25:42 <dmwit> f x = case view x of Left a -> ...; Right a -> ... -- though you lose many of the benefits of view patterns
22:25:48 <Fylwind> well that's a shame :(
22:25:54 <ivanm> Fylwind: mightn't hurt to have a f _ = error "f" case though just in case you use some other data-type and it gets a new constructor
22:26:08 <ChongLi> edwardk: what about extensive use of Data.Bits.Lens ?
22:26:11 <Fylwind> well it wouldn't happen here because I'm using Either
22:26:18 <edwardk> ChongLi: some gratuitous ones. there are 'folds' for iterated, taking, etc. that to implement we have to tie the compiler in knots it can't fgure out how to unknot gracefully
22:26:26 <Fylwind> and "Left" is meant to handle "everything else"
22:26:28 <dmwit> ivanm: That kind of thing is what the warning is *supposed* to catch. =)
22:26:43 <ivanm> dmwit: true, but since it doesn't work...
22:26:45 <edwardk> Data.Bits.Lens.bits in particular will spent a fair bit of time using setBit and clearBit it doesn't need.
22:26:45 <binroot> any help here would be appreciated: http://stackoverflow.com/questions/20930783/parsing-json-from-webserver-in-haskell
22:26:53 <ChongLi> edwardk: ahh, okay
22:26:58 <edwardk> if its your bottleneck by all means optimize it
22:27:03 <ChongLi> so if you're actually doing serious stuff with bits
22:27:10 <edwardk> but its the kind of thing included for completeness
22:27:15 <ChongLi> like writing some bitvector library
22:27:23 <ChongLi> you probably want to hand-roll it
22:27:25 <Fylwind> f _ = error "you're not supposed to see this and don't post this to dailywtf"
22:27:31 <ivanm> edwardk: with semigroupoids, did you choose not to re-use >>> and <<< just to avoid clashing issues (in case someone also makes something an instance of Category)?
22:27:46 <ivanm> Fylwind: f _ = error "blame GHC"
22:27:53 <edwardk> i use the lens approach because it is damn convenient, 5% of the time i have to do something better. but that happens no matter what i write with as a baseline ;)
22:28:00 <ivanm> heh
22:28:04 <Fylwind> ivanm: :)
22:28:21 <edwardk> ivanm: I hate (<<<) and (>>>) from a verbosity perspective. the operator is supposed to be nigh invisible.
22:28:22 <ivanm> edwardk: so is that video you did still applicable as an intro into lens, or is there something better?
22:28:30 <ivanm> fair enough
22:28:33 <edwardk> ivanm: its pretty close to accurate
22:29:01 <edwardk> ivanm: you can take what i say about isomorpisms in the video to be a lie, replaced by a more elegant stoy these days about profunctors
22:29:13 <edwardk> ivanm: but until that point it is still accurate
22:29:15 <ivanm> I was thinking of writing a function with that type and remembered that Arrow had it with those operators; alas, I can't write an id instance
22:29:28 <ivanm> edwardk: is there a textual tutorial/intro as well?
22:29:39 <ChongLi> edwardk: ahhh, what about all the runIdentity . Identity stuff?
22:29:44 <ChongLi> getConst . Const
22:30:11 <ChongLi> I thought those were pretty clever ideas
22:30:35 * ivanm "eeks" at the number of transitive dependencies semigroupoids would add to his project
22:30:38 <edwardk> ChongLi: note lens doesn't do that. it uses runIdentity #. l (Identity #. f)  -- note the hashes, tose turn into unsafecoerces and avoid the eta expansion wrappers
22:30:55 <ChongLi> ahhh
22:31:05 <carter> ChongLi: i have a strictIdentty monad thats handdy for bit fidlding cod
22:31:26 <ivanm> though I suppose that's the issue of needing to write instances for all those types, since the libraries defining the types don't depend on semigroupoid et. al.
22:31:26 <carter> it helps make writing strict bit fiddling code easy
22:31:28 <ChongLi> I thought I heard somewhere that ghc was eventually going to let you do stuff like:
22:31:39 <ChongLi> map runIdentity [Identity foo]
22:31:50 <ChongLi> and it turning into [foo] at compile time
22:32:05 <Clint> i thought i heard somewhere that ghc was going to release last month
22:32:25 <carter> ChongLi: ghc does that with the identity monad
22:32:29 <carter> i have a strict one
22:32:36 <carter> i can throw it on hackage
22:32:41 <carter> https://gist.github.com/cartazio/5842883 heres the example
22:33:04 <edwardk> ChongLi: that is slowly coming along, but it doesn't work like you'd expect. the coercible machinery likely won't be very user facing until 7.10
22:33:09 <ChongLi> ahh, but can we do it for arbitrary newtypes we define in our code?
22:33:43 <ChongLi> it would make it so much easier to work with libraries that don't implement enough type classes for their stuff
22:34:01 <carter> ChongLi: look at my example if you want to see one way to write fast bit fiddling in haskell
22:34:33 <ChongLi> carter: yeah, that's really nice
22:34:59 <carter> lemm go hackageify it
22:35:16 <carter> m3ga may be using it or a similar trick soon
22:35:18 <edwardk> ChongLi: the coercion machinery will only work if the roles are set up properly on the data type
22:35:29 <edwardk> and there are many functors for which they can't be
22:35:53 <edwardk> the newtypes aren't the problem, its the functor itself containing it
22:36:00 <ChongLi> ahh, okay
22:36:14 <carter> mind you, this strictIdentiy monad is only a valid monad for terminating expression
22:36:19 <ivanm> how ugly is it to have: ` id :: Parser a a, id = P $ \ inp -> (inp, error "no more input") ' ? (it technically satisfies Category's requirements for it to form a monoid with (.) and the rules will remove usage of it...)
22:36:21 <carter> i think
22:36:22 <ChongLi> so if I've got functors that define the roles properly, all my newtypes will coerce automatically?
22:36:36 <ChongLi> so it solves my problem
22:36:38 <carter> ChongLi: or you can just write your own coercions :)
22:36:56 <carter> and use a very very very careful unsafeCoerce
22:37:03 <carter> as the "proof"
22:37:14 <ChongLi> ahh, I need to investigate that
22:37:28 <ChongLi> I don't use unsafeAnything at this point
22:38:11 <carter> soke
22:38:15 <carter> its better not to
22:38:22 <carter> only do it if benchmarks start screaming
22:38:32 <ChongLi> yeah
22:46:20 <m3ga> carter: what trick?
22:46:41 <m3ga> oh, your StrictIdentity monad? yeah
22:47:04 <flebron> Is there a way to document, using Haddock, how a type is an instance of a typeclass?
22:47:53 <Clint> aside from the instance declaration?
22:48:33 <Fylwind> Seq.(<|)   Not in scope data constructor `Seq'.  Huh?
22:48:52 <Fylwind> how do i refer to a qualified infix operator then?
22:49:44 <flebron> Clint: That just tells me that it is, not how it is.
22:49:56 <roboguy_> ivanm: I don't think that's a monoid
22:49:58 <Clint> ah
22:50:00 <Fylwind> never mind, figured it out
22:50:59 <roboguy_> well, maybe it would depend on the definition of (.) I guess
22:52:56 <frege> hey guys
22:53:34 <frege> I'm a smart person and I know a bunch of programming languages, etc. can I learn haskell tomorrow in 6 hours?
22:53:53 <frege> syntax and basic workflows
22:54:08 <roboguy_> frege: it depends on what you mean by "learn"
22:54:08 <Feuerbach> frege: perhaps. You tell us tomorrow :)
22:54:15 <frege> which book do you recommend for something like that?
22:54:36 <roboguy_> frege: probably Learn You a Haskell
22:54:40 <roboguy_> @where lyah
22:54:40 <lambdabot> http://www.learnyouahaskell.com/
22:55:10 <frege> I mean learning enough so I can write a code to lets say make a connection, use zmq, receives data, put them in lists, process them, etc..
22:55:25 <erisco> not a chance
22:55:44 <roboguy_> frege: probably not. it's a lot different from most other languages
22:55:47 <frege> seriously?
22:55:50 <m3ga> frege: even if you know a bunch of other languages haskell is likely to be very different from all the others.
22:56:06 <roboguy_> frege: I know quite a few languages too and I can safely say that it is very different
22:56:13 <frege> even if I know basic functional concepts?
22:56:14 <augur> frege: that basic law 5... what a mistake, huh
22:56:19 <frege> lambda, lazy evaluation, etc..?
22:56:57 <flebron> It's not enough to just know about the existence or have at one point used a given set of features.
22:56:57 <Feuerbach> frege: lazy evaluation won't matter that much. The main thing to learn is Haskell's type system
22:57:10 <flebron> Haskell is purely functional, it's not that if you want, you can use functional programming, like Python.
22:57:33 <frege> right, I'm a python coder
22:57:35 <roboguy_> frege: also the fact that "variables" don't vary and the lack of loops (in the usual sense)
22:57:39 <frege> actually
22:57:39 <flebron> There will likely be ideas you have that take time in order to learn to express in a different programming paradigm.
22:57:42 <augur> Feuerbach: stop conjecturing.
22:57:49 <Feuerbach> augur: yes sir!
22:58:00 <roboguy_> frege: there's one way to find out though!
22:58:21 <frege> try it out right?
22:58:27 <roboguy_> yep!
22:58:30 <frege> okay I have to get my environment ready
22:58:33 <roboguy_> (although I wouldn't expect to learn it in one day. I'd give it a little longer)
22:58:45 <frege> I got ghci
22:58:57 <m3ga> frege: i've seen a newbie to haskell become pretty decent in about 2 months of 30 hour weeks.
22:59:00 <frege> of course
22:59:18 <m3ga> as in able to contribute to an existing project.
22:59:21 <frege> well I could learn GoLang in 3 days
22:59:28 <frege> even less
22:59:39 <m3ga> golang is just like C and C++ and java and python
22:59:44 <frege> yeah
23:00:00 <m3ga> with golang there is nothing new to learn if you know 2 of the others.
23:00:25 <roboguy_> frege: I would definitely say it's worth putting enough time into haskell to give it a good chance. if nothing else, it's good mental exercise
23:00:28 <carter> m3ga:what should i name it on hackage? perf-utils or strictlyid or strict-idenity ?
23:00:33 <frege> well exccept, channels, goroutines, the law of reflection, etc..
23:00:39 <frege> m3ga: there is actually
23:00:44 <m3ga> carter: strict-idenity
23:00:46 <carter> ok
23:00:50 <carter> will do
23:01:13 <frege> roboguy_: I will, it has a strong gravitation
23:01:15 <m3ga> frege: those are all well above and beyond the basics of the language.
23:01:31 <carter> yeah, you have to be pretty sophisticated to understand why bounded channels are a good idea
23:01:38 <flebron> goroutines and channels are above and beyond the basics of go?
23:01:39 <carter> some golang folks want unbounded channels
23:01:40 <m3ga> the basics of gloang are the same as most other imperative langauges.
23:01:56 <m3ga> carter: some people are nuts :-)
23:02:00 <carter> m3ga: crazy fact, golang channels are fixed sized array buffers
23:02:17 <carter> so they have worse space usage in the average case than haskell bounded channels
23:02:26 <m3ga> when using STM channels i always use the bounded ones.
23:02:41 <carter> yeah, and they on average have much less mem usage than peak load
23:02:45 <carter> golang... no dice
23:02:51 <frege> golang is a dumb language, seriously
23:03:07 <kazagistar> goroutines and channels are pretty core ideas and are used heavily in go... certainly one of the things you learn pretty early
23:03:18 <flebron> indeed...
23:03:32 <frege> GC is pretty fucked
23:03:37 <carter> oh?
23:03:40 <flebron> if you're not using goroutines or channels, i have to wonder why you're not doing just java or c++
23:03:44 <frege> so you can't actuallyy over use go routines
23:03:54 <carter> i know theres problems with the go GC in 32bit land
23:04:06 <frege> even in 64bit
23:04:21 <frege> it's not meant to be used in a serious system
23:04:25 <kazagistar> I might have used golang more if they had generic containers...
23:04:25 <carter> m3ga: there was an amusingly daft not quite flame war on the Rust lang mailing list about whether Rust Channels should be bounded or not, blocking or not
23:04:37 <carter> kazagistar: i want me some parametricity in my engineering!
23:04:46 <carter> either i'm wrong in every way, or always rigth :)
23:04:56 <frege> yeah no generics
23:05:24 <m3ga> frege: on yeah, no generics just sucks!
23:05:25 <erisco> they have duck typing
23:05:27 <erisco> same shiz
23:05:29 <frege> what's a good book on parallel and concurrency models?
23:05:35 <carter> ooooo
23:05:43 <frege> erisco: it's not reall duck typing
23:05:56 <carter> theres a great one that uses real haskell libs to show many of the models erisco
23:06:00 <frege> their duck typing is different, read on the law of reflection
23:06:02 <frege> it sucks
23:06:10 <frege> way too much overhead for coders
23:06:10 <erisco> carter, what do you mean?
23:06:23 <carter> http://chimera.labs.oreilly.com/books/1230000000929
23:06:35 <erisco> frege, what I am saying is generics are redundant
23:06:46 <frege> carter: that's mine?
23:06:55 <carter> yes frege
23:06:58 <carter> erisco: nope
23:07:06 <carter> run time type instrosection can be pretty bad
23:07:08 <erisco> carter, you are confusing me
23:07:09 <frege> thanks
23:07:30 <frege> carter: nah, why?
23:07:42 <kazagistar> erisco: you cant have compile time checking of element types in containers
23:07:44 <carter> frege: lemme show you by example
23:08:02 <erisco> kazagistar, oh, then I guess it is f'd then
23:08:09 <erisco> I have only had a cursory look
23:08:24 <carter> erisco: frege  what could the follwoing function do?  f :: (a -> b) -> a -> b  ?
23:08:33 <carter> tell me what it would do in haskell
23:08:37 <erisco> carter, why do you keep putting my name in there?
23:08:46 <carter> erisco: you asked about relfection
23:08:53 <erisco> I didn't
23:08:55 <carter> oh
23:08:56 <carter> darn
23:08:58 <carter> i'm tired :)
23:08:58 <kazagistar> erisco: I understand, I missed it at first too, until I started using it
23:09:06 <erisco> carter, but it does ($) since you asked :P
23:09:11 <carter> yes
23:09:30 <erisco> kazagistar, how do they manage to not make it statically checkable?
23:09:39 <carter> erisco: now pretend you were in a lang that oculd reflect all the types?
23:09:55 <frege> http://learnyouahaskell.com has a bit of overhead
23:09:59 <frege> I wish it was leaner
23:10:01 <erisco> carter, mkay then what
23:10:18 <carter> ok
23:10:24 <roboguy_> frege: what do you mean?
23:10:24 <carter> now imagine a function like
23:10:26 <erisco> frege, yeah I honestly can't bear that style either :P
23:10:28 <carter> :t ($)
23:10:28 <lambdabot> (a -> b) -> a -> b
23:10:34 <carter> but it could look at the types of its input
23:10:43 <carter> and do different things
23:10:50 <erisco> yes okay, and?
23:10:51 <subleq> where can i find the monad instance for functions?
23:10:53 <carter> could you describe the behavior then
23:10:54 <carter> ?
23:11:13 <roboguy_> subleq: GHC.Base
23:11:16 <carter> there might be arbitrary case analysis inside
23:11:27 <roboguy_> subleq: you can find that by putting ":i (->)" in ghci
23:11:36 <erisco> carter, I am not entirely sure what you are saying, but in that case I cannot make a statement about arbitrary choices for a and b
23:11:38 <frege> roboguy_: too many unnecessary texts, from my point of view a programming books should be just example codes. and diagrams perhaps to show a concept
23:11:47 <carter> exactly!
23:11:56 <frege> no need to fuck around so much
23:11:56 <roboguy_> frege: ah, yeah. well, I kind of skimmed parts of it
23:12:00 <subleq> roboguy_: cool, thanks
23:12:20 <carter> erisco: thats exactly why unconstrained compiletime/runtime type reflection makes generic code hard to write sanely
23:12:39 <roboguy_> frege: I think those parts are to ease people into programming that have never programmed before
23:12:48 <carter> in haskell we write nonuniform generic code like
23:12:48 <erisco> carter, oh, so GO has runtime reflection
23:12:54 <frege> yeah true
23:12:54 <carter> i spose!
23:12:56 <ivanm> roboguy_: the definition of (.) is to let you change the input type; specifically, parse one type of input into something else, then parse that something else
23:13:03 <erisco> well that is understandable then
23:13:04 <carter> in haskell that would be expressed with
23:13:06 <frege> is there a book for people who already know programming?
23:13:11 <zRecursive> How can all those functions returning "IO (...)" share global values without passing it around ?
23:13:11 <frege> but new to haskell?
23:13:21 <carter> (Thingy a, Lala b)=> (a->b)->a -> b
23:13:22 <ivanm> frege: there's RWH, but it's out of date in many areas
23:13:31 <kazagistar> erisco: by not having generics... check out their "list" implementation http://golang.org/src/pkg/container/list/list.go ... notice how they cannot create a parameterized container type, so every list can hold any object of that type
23:13:36 <carter> and you would then look up the haskell type classses Thingy and Lala
23:13:42 <frege> umm
23:14:19 <erisco> kazagistar, shame on them :P
23:15:42 <erisco> that is OO though... can't really avoid the runtime reflection (well, C++ at least does not have it in by default)
23:15:53 <carter> erisco: not true
23:15:59 <carter> there are static type OO langs
23:16:01 <carter> somewhere
23:16:10 <carter> like Scala... somtiems
23:16:11 <m3ga> frege: i know a number of very advanced programmers (in numerous langauges) who found learnyouahaskell very good.
23:16:13 <frege> goLang is a frankestine from some really old ppl
23:16:14 <kazagistar> erisco: I mean, most of the time it isn't a big deal, since Arrays and Slices and such ARE parameterized as part of the language spec for go, and mixing up types in a collection is not THAT common of an error, but it is annoying
23:16:34 <carter> frege: LYAH is a great quick read
23:17:34 <erisco> carter, most practical OO code I've seen eventually makes use of instanceof tests and the like
23:17:35 <kazagistar> is LYAH even very good for nonprogrammers? it seems to move pretty damn fast compared to most introductory texts
23:17:53 <NemesisD> oh fun i gotta free memory allocated in C via FFI
23:17:58 <erisco> carter, but of course the equivalent is to roll your own RTTI, which would then play nicely with the static type system
23:18:03 <erisco> clearly superior
23:18:18 <carter> erisco: give me parametricity or give me a huge ass paycheck for the pain i'll sufer
23:18:58 <frege> LWH , is it really old?
23:19:01 <erisco> kazagistar, well that is about the speed my course on Miranda went
23:19:07 <frege> RWH*
23:19:15 <erisco> kazagistar, and that was a first year course
23:19:19 <kazagistar> money has diminishing returns on its conversion rate to happyness... some things I wont touch for any paycheck :P
23:19:34 <carter> :)
23:19:45 <roboguy_> ivanm: but does f . id = f and id . f = f, for all f?
23:19:57 <flebron> yes
23:20:03 <erisco> carter, you love void* and you know it
23:20:15 <carter> nah, hard to optimize code that way
23:20:25 <NemesisD> so i've got an array of ulong64_t's. i've got ulong64* and an int length. so should i do something like mapM (replicate (length - 1)) (\slot -> free (plusPtr slot arrHead)) ?
23:20:30 <carter> though if i ever do any large IOS code and ghc-ios or xamarin aren't options, i may be forced to
23:20:49 <roboguy_> ivanm: if you use the second element of the tuple the error call might mess that up
23:20:50 <carter> erisco: void* is a poor sad mans polymorphic variable
23:20:58 <ivanm> roboguy_: from what I can tell, yes; it's just that if you do "f . id" (including "id . id") then you better not want to parse anything more because _then_ the error will occur
23:21:43 <roboguy_> ivanm: so you can always replace "id . f" with "f" and get the exact same behavior? where is the second element of the pair used?
23:21:53 <erisco> carter, objective C has better methods for genericity than void* does it not?
23:22:15 <subleq> @pl foo x = (\a b -> f a b)
23:22:15 <lambdabot> foo = const f
23:22:17 <ivanm> roboguy_: in "g . f", the rest of the input to g is discarded; so "id . f" will have the error discarded
23:22:19 <carter> erisco: unclear, i've seen people rant about those nicer ways
23:22:23 <subleq> @pl foo a = (\a b -> f ab)
23:22:23 <lambdabot> foo = const (const (const (f ab)))
23:22:30 <subleq> @pl foo a = (\a b -> f a b)
23:22:30 <lambdabot> foo = const (const (join f))
23:22:47 <subleq> is that a bug?
23:22:54 <NemesisD> wow except i got the mapM arg order wrong and replicate is totally wrong, it should be [0..length-1]
23:23:07 <kazagistar> surely you mean void *(*a)(void*), if I remember my C correctly
23:23:18 <ivanm> roboguy_: so the only potential issue is if you do something like "(f . id) <* eof"
23:23:24 <kazagistar> seeing as that is the type of every curried haskell function in C :P
23:23:56 <roboguy_> ivanm: huh, okay
23:23:59 <erisco> lol
23:24:13 <ivanm> roboguy_: so is that forgiveable? ;-)
23:24:18 <augur> subleq: yes, very much a bg
23:24:27 <ivanm> I explicitly note the behaviour of id as a haddock comment on the instance
23:24:51 <roboguy_> ivanm: hah, well I'd still worry about it introducing subtle hard-to-track errors in other parts of the code, but maybe it's okay
23:25:07 <roboguy_> ivanm: it's a shame you can't have a Monoid restriction
23:25:07 <ivanm> roboguy_: well, I don't expect anyone to actually _use_ id... :p
23:25:21 <ivanm> yeah; I use Monoid elsewhere
23:27:00 <roboguy_> frege: when I was reading LYAH, once I got the basic syntax down I pretty much skipped ahead to chapter 7 or 8 and used the chapters before that as a reference if when I needed it
23:27:35 <roboguy_> type classes are important to know about too, though
23:28:34 <roboguy_> you might already know lambdas, map, filter and the folds from python though (reduce is a fold in python)
23:30:20 <roboguy_> If I remember my python right, reduce is specifically equivalent to foldl1
23:30:54 <marx2> it can do foldl too, default is optional
23:31:09 <roboguy_> marx2: huh, I don't think I ever knew that!
23:34:24 <marx2> reduce(lambda x,y: x + y, [1,2,3], 100)  =>  106
23:34:43 <frege> have you guys read this? http://repository.cmu.edu/cgi/viewcontent.cgi?article=2846&context=compsci
23:34:54 <marx2> had to double check, but yeah I remembered right
23:34:55 <augur> roboguy_: reduce is the lisp-tradition's word for fold
23:35:01 <augur> hence MapReduce
23:35:38 <kazagistar> roboguy_: its cause it is rarely actually useful or recommended to do any non-trivial reduce which would require a default in python; usually people just stick to a loop
23:35:49 <roboguy_> kazagistar: true
23:36:53 <erisco> frege, no but I look forward to reading it. I have been looking for something on category theory
23:37:07 <erisco> I see conal is credited in the paper :) must be good then
23:37:23 <marx2> not sure whyy it would reduce with default be any less useful in python than other languages. python community does discourage the use of reduce though (as well as some other functional idioms)
23:37:33 <marx2> s/it//
23:37:54 <roboguy_> frege: I haven't seen that yet. looks like it could be good
23:38:21 <erisco> frege, do they manage to apply it somehow?
23:38:35 <erisco> I have read over the definition (it is rather brief) but it gives me no sense of what it really is
23:40:03 <erisco> their notation looks somewhat legible so that is great :D they must of really had comp sci people in mind
23:41:15 <frege> I thought haskell was based on category theory
23:41:21 <kazagistar> I have had trouble finding category theory resources that actually follow reasonable teaching methods, like showing examples instead of just piling on proofs :/
23:41:30 <frege> am I way off?
23:41:42 <erisco> frege, it is not necessary to know category theory to use Haskell, but there is much inspiration from it
23:41:45 <roboguy_> frege: it sort of is, you don't really need to know category theory to understand it reasonably well. you pick up some category theory as you go
23:42:24 <erisco> kazagistar, yeah =\ after they prove some property I am left wondering "mkay, so this matters because... ?"
23:42:37 <roboguy_> frege: in my experience you learn some "practical" category theory as you work with the language and see practical applications of different concepts
23:43:23 <frege> gotcha
23:48:38 <Cale> frege: Also, "based on" would be an overstatement. There's a way to examine what's going on in Haskell from the point of view of category theory, and some libraries take inspiration from category theory, but that's about the extent of it.
23:49:33 <carter> the relation ship is that people invented haskell to be nice
23:49:52 <carter> then discovered it was nice enough that they could steal ideas from mathematicians and turn them into useful code
23:50:09 <carter> and that abstractions that were useful happened to reflect ideas math people had also had
23:50:15 <zRecursive> @docs implicit parameters
23:50:15 <lambdabot> implicit parameters not available
23:50:24 <zRecursive> @hoogle implicit parameters
23:50:25 <lambdabot> No results found
23:51:20 <zRecursive> @google haskell implicit parameters
23:51:21 <lambdabot> http://www.haskell.org/haskellwiki/Implicit_parameters
23:51:21 <lambdabot> Title: Implicit parameters - HaskellWiki
23:53:36 <Aetherspawn> question related to c2hs/ffi : http://stackoverflow.com/questions/20931099/using-c2hs-to-marshal-a-void
23:56:08 <zRecursive> @src sort
23:56:08 <lambdabot> sort = sortBy compare
