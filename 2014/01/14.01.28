00:05:41 <Hafydd> Someone found a way to make websites even more annoying than they previously were, I see.
00:06:18 <Axman6> ?
00:06:23 <jrmithdobbs> it's a presentation using html instead of powerpoint, not a website
00:06:40 <grohne> Twey: I believe I will stick with Agda for proofs for a while. ;-)
00:06:42 <Hafydd> Who would want to present that to anyone?
00:06:48 <pharaun> that page was terrible
00:07:29 <ij> mirpa, ping
00:07:37 <mirpa> ij: echo
00:07:50 <jrmithdobbs> Hafydd: no idea
00:08:09 <Hafydd> I see; but some people actually do make websites like that.
00:08:13 <Hafydd> "Click to scroll down", etc.
00:08:33 <jrmithdobbs> i just liked the first two slides ok! :)
00:08:38 <ij> mirpa, I'm looking at the JP interface and as I understand I've got to make my Image a MutableImage to readPixel`s from it? How do I go about doing that?
00:10:28 <ij> Do you have experience doing that? If not, I'll just keep on thinking.
00:10:51 <mirpa> ij: mutable? http://lpaste.net/99161 can't you use something like this?
00:10:53 <shachaf> sigh, those slides
00:12:24 <mirpa> ij: why do you need MutableImage in order to read img pixels?
00:13:04 <ij> Oh, I'm just silly. I didn't notice pixelAt, but readPixel.
00:13:35 <ij> Thanks!
00:13:36 <mirpa> ij: tell me about being silly: Ix.inRange ((0,0),(h' - 1, w' - 1)) (x,y)
00:13:40 <mirpa> :-)
00:19:21 <jle`> haskell is a pretty good imperative language
00:20:23 <mirpa> jle`: why?
00:21:31 <ion> Because IO is a first-class thing.
00:21:33 <Fuuzetsu> Twey: I don't know why '[] shows up as `[]`…
00:22:31 <Fuuzetsu> I `[]` like 2 days ago but I thought it was by design
00:29:21 <haasn> haskell is good at pretending to be a pretty good imperative language
00:34:08 <johnw> Haskell makes imperatives clear to the reader
00:37:51 <johnw> sccrstud92: ping
00:39:28 <qrada> my biggest hurdle to haskell thus far, without a doubt, is cabal
00:39:30 <qrada> HEH
00:40:33 <qrada> i keep finding myself in these dependency hell situations.. maybe im getting better at it though.. when I get into dep hell, I ghc-pkg-clean, cabal install cabal-install, then make sure I have all of my packages on one line with a constraint with my next cabal install... dno, it seems to take most of my time
00:40:48 <qrada> lens/hedis installs kept getting all tweaked over 'bytestring'
00:40:51 <qrada> got it now though
00:40:56 <qrada> is this normal or am i just a wreck ;f
00:41:30 <enthropy> that's normal I think
00:41:49 <enthropy> for whatever reason cabal is happy to install two versions of bytestring side-by-side
00:42:03 <qrada> ya it always seems to be bytestring
00:42:04 <enthropy> even thought that rarely will work out
00:42:07 <qrada> hehe
00:42:38 <enthropy> in you ~/.cabal/config, you can add  constraint: bytestring installed
00:43:20 <qrada> cool thanks, will do
00:43:50 <qrada> will see if that helps next time
00:44:05 <mirpa> qrada: are you using sandbox?
00:45:07 <qrada> nope? im 'nub', havnt heard of that
00:45:11 <qrada> will look it up tho
00:45:15 <qrada> you recommend it?
00:45:33 <mirpa> in version cabal 1.18
00:45:49 <mirpa> cabal sandbox - it solved most of my problems
00:46:15 <qrada> nice
00:46:34 <qrada> will check it out tmw for sure, thanks alot
00:46:36 <mirpa> there is older cabal-dev, if you have cabal <1.18
00:47:08 <mirpa> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
00:47:34 <qrada> eek im at 1.14
00:47:37 <qrada> daym
00:48:22 <mirpa> try cabal-dev then or install newer version of cabal through hackage
00:48:53 <Fuuzetsu> qrada: use sandboxes
01:01:13 <johnw> @tell sccrstud92 Snoyman and I found the memory problem in your code: Attoparsec just has a lot of overhead in this case.  If you use a manual parser which modifies a mutable vector, you can get down to like 3MB resident memory used.  Here's an example of some trimmed down parsing code: https://www.fpcomplete.com/user/jwiegley/autocloned/parsing-lots-of-lines
01:01:13 <lambdabot> Consider it noted.
01:03:12 <Lethalman> johnw, that's a 404 though
01:04:35 <johnw> oh, whoops
01:06:14 <johnw> huh, it clones the project for me
01:06:22 <Axman6> 40 here too
01:06:25 <Axman6> 404*
01:06:28 <johnw> that's very interesting
01:06:46 <johnw> sorry: https://www.fpcomplete.com/user/snoyberg/random-code-snippets/parsing-lots-of-lines
01:06:54 <johnw> @tell sccrstud92 Sorry, that link should be: https://www.fpcomplete.com/user/snoyberg/random-code-snippets/parsing-lots-of-lines
01:06:55 <lambdabot> Consider it noted.
01:07:04 <johnw> I had copied in the "post cloned" link
01:26:55 <skypers_> hi!
01:26:55 <markovirc_> Hello skypers_
01:26:59 <skypers_> where’s fruit?!
01:27:25 <skypers_> there’s wxFruit
01:27:31 <skypers_> but I can’t find fruit anymore
01:53:34 <dibblego> shachaf: ?
01:56:00 <shachaf> ?
01:56:12 <dibblego> what about those slides?
02:00:49 <zett_zelett> There’s an upcoming exam and I don’t quite grok leftmost-outermost reduction – is e.g. `map not` a redex?
02:01:25 <pranz> I don't even understand what those slides were trying to explain
02:01:41 <pranz> It just glossed over the basics of category theory accompanied with annoying images
02:02:31 <shachaf> Yes, more or less.
02:03:14 <zett_zelett> shachaf: Was that directed to me? If so, in which sense is it less a redex?
02:07:30 <killy9999> do {foo <- mapM f [a]} where f :: a -> b -> c
02:07:53 <killy9999> I'd expect that foo will contain [b -> c]
02:08:03 <killy9999> but that does not seem to be the case
02:08:07 <killy9999> what am I missing here?
02:08:52 <Axman6> killy9999: well, as you've written it it's invalid syntax
02:09:03 <killy9999> aside from syntax
02:09:04 <pranz> :t mapM
02:09:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:09:13 <pranz> okay so
02:09:29 <Axman6> :t mapM (undefined :: a -> b -> c) [undefined :: a]
02:09:30 <lambdabot> b -> [c]
02:09:34 <pranz> (b ->) is a monad
02:09:55 <pranz> if you used normal map you would indeed get [b -> c]
02:09:56 <killy9999> sorry, f should be a -> b -> m c
02:10:00 <killy9999> now I see the problem
02:10:06 <killy9999> a -> b -> m c
02:10:07 <Axman6> :t mapM (undefined :: a -> b -> m c) [undefined :: a]
02:10:08 <lambdabot> b -> [m c]
02:10:08 <killy9999> should be
02:10:13 <killy9999> a -> m (b -> c)
02:10:42 * killy9999 wonders if there is a way out of this
02:12:47 <pranz> killy9999: the mapM functions is passed (a -> m b), where m is (-> e) and b is m c
02:12:54 <pranz> that's why you're getting those types
02:13:03 <skypers_> is there a parser for floating values within parsec?
02:13:10 <skypers_> or do I have to use getInput / setInput
02:13:15 <skypers_> and a Numeric function?
02:13:18 <killy9999> pranz: right, I see that now
02:13:20 <pranz> killy9999: try to explain what you want to do
02:13:28 <pranz> this feels like an X/Y problem
02:16:45 <skypers_> ok I guess I have to write my own function
02:16:51 <skypers_> with Numeric.readFloat
02:19:59 <ij> How could I get RGB out of the pixel data: http://hackage.haskell.org/package/JuicyPixels-3.1.3.2/docs/Codec-Picture.html#t:PixelRGBA8
02:20:43 <Axman6> ij: pattern match on it? :\
02:21:15 <ij> Ah. Thanks.
02:37:19 * hackagebot parconc-examples 0.3.2 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.3.2 (SimonMarlow)
03:33:23 <pxqr> what the difference between Foo {} and Foo {..} in context of expressions?
03:34:01 <pxqr> (i've discovered that (Foo {..}) is valid expression)
03:34:21 <Axman6> Foo {..} gives you variables de3fined for all the record parameters in the Foo
03:34:36 <CaptainK> : t (Foo {..})
03:34:49 <pxqr> :t Just {..}
03:34:50 <lambdabot>     Illegal `..' in record construction
03:34:50 <lambdabot>     Use -XRecordWildCards to permit this
03:35:12 <pxqr> Axman6: well, that is for patterns
03:35:15 <Axman6> so, data Foo = Foo {bar :: Bar, baz::Baz}, f Foo {..} means you have variables named bar and baz of type Bar and Baz available inside your function
03:35:50 <pxqr> Axman6: i rather wondering what does mean (f = Foo {..})
03:36:22 <kuribas> isn't the type of bar "Foo -> Bar"?
03:36:28 <Axman6> that'll make a Foo with its values bar and baz set from values named bar and baz that are in scope
03:37:33 <Axman6> so let bar = 1, baz = "Hello", f = Foo {..} will set bar to 1 and baz to "Hello" in f
03:37:41 <Axman6> (changing types from the previous example)
03:38:13 <pxqr> λ> let foo = 1 in Foo {..}
03:38:13 <pxqr> Foo {foo = *** Exception: <interactive>:21:16-23: Missing field in record construction :I
03:38:13 <pxqr> nteractive.foo
03:38:27 <pxqr> where data Foo = Foo { foo :: Int }
03:38:54 <Axman6> right, you need to define all fields
03:39:11 <mgsloan> you probably aren't importing the constructor or fields
03:39:24 <mgsloan> maybe
03:39:31 <CaptainK> those damn constructors!
03:39:33 <pxqr> mgsloan: it is from ghci
03:39:54 <Axman6> pxqr: you have to define all fields that a Foo expects
03:40:09 <mgsloan> maybe the module isn't exporting them?
03:40:12 <Axman6> so if there's no bar in scope in the above example, then you'd get that error
03:40:27 <pxqr> Axman6: i've defined all field; i've used data Foo = Foo {foo::Int}
03:40:32 <pxqr> *fields
03:40:39 <Axman6> hmm, odd
03:40:54 <Axman6> do you have RecordWildCards enabled?
03:40:57 <pxqr> yes
03:41:21 <Axman6> no idea then. it's not a feature I've ever used
03:42:27 <pxqr> let f Foo {..} = Foo {..} complaining about uninitialized fields
03:43:25 <pxqr> Axman6: i've always thought {..} is part of patterns syntax *only*
03:44:15 <Tracki> can someone tell me why i get the error message "Segmentation fault (core dumped)"?
03:44:17 <Tracki> http://lpaste.net/2369275677561061376
03:44:37 <mgsloan> pxqr: does (foo $ Foo 1) work?
03:45:52 <pxqr> mgsloan: yes
03:46:04 <Axman6> Tracki: which version of ghc? and how're you compiling it?
03:46:34 <mgsloan> hrmm, really odd yeah
03:46:58 <pxqr> probably Foo {..} and Foo {} is equiv
03:46:59 <Tracki> i am using hugs
03:48:04 <Axman6> ah, there's ya problem :P
03:48:05 <Tracki> i am new at haskell, just the function qapp is mine
03:48:13 <Axman6> there's basically no reason to use Hugs these days
03:48:37 <nicoo> Axman6: You don't *need* a reason for Hugs.
03:48:43 * nicoo hugs Axman6 :3
03:48:54 <Axman6> hugs are always good, Hugs not so much
03:49:04 <nicoo> ^^
03:49:23 <mgsloan> pxqr: nah, Foo {..} definitely means to take the fields from the scope
03:50:10 <Tracki> so with ghc it should work?
03:50:30 <Axman6> can't see why not
03:50:49 <Tracki> ok i'll try, thx so far :D
03:52:28 * hackagebot static-resources 0.1.7 - JavaScript and Css files concat for http optimization. Now with LESS support.  http://hackage.haskell.org/package/static-resources-0.1.7 (MariuszRak)
03:53:19 <Axman6> Tracki: you're best off to install the haskell platform
03:53:23 <Axman6> @where platform
03:53:23 <lambdabot> http://hackage.haskell.org/platform/
04:07:29 * hackagebot tokenize 0.2.0 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.2.0 (GrzegorzChrupala)
04:11:53 <Tracki> got a new problem -.- . Compiling works now but when i try the function qapp it says " Not in scope: data constructor Q" did i write the function wrong? at hugs i wrote "qapp (Q [2,3] [3]) (Q [4] [3])" that worked
04:17:29 <icanc>  /whois icanc
04:17:33 <Tracki> hmm it seems that the function does not terminate could it be? it does not finish -.-
04:34:33 <dv-> has anyone make anything for android with ajhc?
04:34:50 <dv-> made*
04:35:41 <skypers_> hey
04:35:42 <markovirc_> Hello skypers_
04:35:49 <skypers_> is there a function for <?> ?
04:36:07 <skypers_> parserFailure and unexpected aren’t what I’m looking for
04:36:16 <supki> (<?>)
04:36:28 <skypers_> sure…
04:36:38 <skypers_> but it’s like using (</>) instead of combine
04:37:20 <skypers_> ok well, my issue is quite different
04:37:40 <supki> looking at source <?> is just an alias for label
04:37:49 <skypers_> I’d like the same behavior as (<?>) but with just a String
04:38:02 <skypers_> I’m defining a parser in terms of getInput and setInput
04:38:58 <skypers_> ok so
04:39:21 <supki> skypers_: how do you mean?
04:39:28 <supki> <?> only makes sense if some parser failed
04:39:36 <skypers_> yeah
04:39:37 <skypers_> well
04:39:43 <skypers_> I’m writing a number parser
04:39:46 <skypers_> when the reads fails
04:40:00 <skypers_> I might express the fact I’m expecting a number
04:40:02 <skypers_> so
04:40:07 <skypers_> I can just yields mzero
04:40:20 <skypers_> and glue the resulting parser with wrapped <?> "number"
04:40:22 <skypers_> right?
04:41:30 <skypers_> yeah it works!
04:42:27 <mornfall> anyone know if there's a JDK that builds/works?
04:42:32 <skypers_> something like { … [(n,s)] -> …; _ -> parserZero } <?> "number"
04:42:33 * hackagebot network-conduit-tls 1.0.4 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.4 (MichaelSnoyman)
04:43:34 <mornfall> hmm, or maybe it's just libreoffice that depends on broken jdk?
04:44:23 <skypers_> do we have parsec in there?
04:44:28 <skypers_> :t ParsecT
04:44:29 <lambdabot> Not in scope: data constructor `ParsecT'
04:46:51 <skypers_> supki: https://github.com/skypers/skyoralis/blob/parsec/Graphics/Rendering/Sky/Utils/Parsers/Common.hs#L81
04:46:59 <skypers_> that just made it through! :)
04:48:51 <skypers_> btw, I just wanted to discuss about something
04:49:22 <skypers_> don’t State, Writer, Reader and so on somewhere add some side-effects code?
04:49:44 <skypers_> for instance, modify can be seen as a function that creates a side-effect because we don’t see the implicit parameter
04:49:48 <skypers_> what do you think?
04:50:01 <skypers_> I guess implicit parameters ≠ side-effects
04:50:03 <skypers_> but still
04:56:15 <skypers_> rah network connection!
04:57:12 <dibblego> no, they are no side-effects and is evident by measuring it — preservation of equational reasoning
05:00:27 <kuribas> How can I make M.lookup use (Data.Map), but lookup use Prelude?
05:00:34 <skypers_> ok dibblego
05:00:48 <Maior> kuribas: import qualified Data.Map as M
05:01:55 <kuribas> Then I need to use M.Map instead of Map right?
05:02:07 <dibblego> import Data.Map(Map) -- as well
05:03:37 <kuribas> I cannot hide unqualified names only?
05:05:14 <drbean> Is there any other way of getting a list of the data constructors of a type other than deriving enum.
05:05:39 <drbean> And using [minbound .. maxbound]
05:07:15 <drbean> With a type declaration?
05:10:29 <int-e> @type Data.Data.dataTypeOf
05:10:30 <lambdabot> Data a => a -> DataType
05:11:53 <int-e> > Data.Data.dataTypeOf (Left 0 :: Either Int Bool)
05:11:54 <lambdabot>  DataType {tycon = "Prelude.Either", datarep = AlgRep [Left,Right]}
05:12:42 * hackagebot persistent-redis 0.2.0 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.2.0 (PavelRyzhov)
05:20:39 <Fuuzetsu> @tell hamishmack Can you have a look at https://github.com/yi-editor/yi/issues/510 when you can?
05:20:40 <lambdabot> Consider it noted.
05:24:48 <staffehn> Hi, would someone take a look at these Functions that are about type safe formatted printing: http://hastebin.com/pahaxabeto.hs
05:24:51 <markovirc_> Hello staffehn
05:26:30 <Fuuzetsu> I wish people stopped using that site, it requires JavaScript to view plain-text pastes…
05:27:00 <staffehn> what was your suggestion to use?
05:27:21 <HugoDaniel> lpaste.net is fine
05:28:34 <Fuuzetsu> Yes, lpaste is fine.
05:29:10 <Fuuzetsu> staffehn: regarding those functions, what about them?
05:29:16 <staffehn> http://lpaste.net/99168
05:29:28 <staffehn> you can look at the demo at the bottom
05:30:12 <Fuuzetsu> Right, but is there a problem that you need solving?
05:30:56 <staffehn> I thought about the use of printf as a readable formatted printing method, and what you can do for similar conviniences in a way that wouldn’t throw runtime errors if you give it the wrong amount/kind of arguments.
05:31:19 <staffehn> *conveniences
05:31:54 <Fuuzetsu> staffehn: you might be interested in http://okmij.org/ftp/typed-formatting/
05:32:42 <staffehn> I was just interested in if someone knows something similar or maybe more extended.. I'll take a look at that link..
05:33:02 <Fuuzetsu> Yes, that link ;)
05:35:52 <staffehn> You know, it basically took me hours to get a version of that (\/)-function that compiles. I think the type system in haskell, when used with some language extensions even, is a bit counterintuitive ;)
05:37:18 <Fuuzetsu> Language extensions aren't designed to be obvious to understand and use, they are meant to do more advanced stuff. I think counterintuitive is a completely wrong word to use here.
05:51:19 <qrada> hey, is there any haskell 'preprocessor macro' where I can pass strings as ByteString's.. i have this hedis module, and all arguments are ByteString's.. im messing with it in ghci, so I have to use B.pack etc for every arg. Is tehre something I can do to just pass strings 'inferred' as packed bytestrings? curious
05:51:21 <markovirc_> Hello qrada
05:51:58 <bennofs> qrada: try to put {-# LANGUAGE OverloadedStrings #-} at the top of your file
05:52:00 <keko_> qrada: there's a language extension called OverloadedStrings
05:52:12 <keko_> ...see above :)
05:52:15 <bennofs> qrada: or in GHCi, you can use :set -XOverloadedStrings
05:52:26 <qrada> ah
05:52:29 <qrada> awesome, thanks folks!
05:52:49 <qrada> i tried 'Qualified' on a whim, thinking it may be the solution, .. overloaded tho, cool, this helps
05:52:52 <qrada> bbiab, cya
06:03:44 <kqr> i have a value x :: Maybe a, I want to run a function f :: a -> IO b, such that I get a new value IO (Maybe b)
06:03:47 <kqr> is that possible to do easily?
06:04:50 <bennofs> @ty traverse
06:04:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:05:08 <bennofs> @ty for :: Maybe a -> (a -> IO b) -> IO (Maybe b)
06:05:09 <lambdabot>     Not in scope: `for'
06:05:09 <lambdabot>     Perhaps you meant one of these:
06:05:09 <lambdabot>       `T.for' (imported from Data.Traversable),
06:05:13 <bennofs> @ty T.for :: Maybe a -> (a -> IO b) -> IO (Maybe b)
06:05:14 <lambdabot> Maybe a -> (a -> IO b) -> IO (Maybe b)
06:05:18 <bennofs> kqr: ^^
06:05:34 <kqr> that's neat, but not at all what i expected
06:05:39 <kqr> i've never touched Traversables before
06:06:14 <bennofs> kqr: I recommend you to take a look at them (also Foldable). They're pretty useful
06:06:22 <bennofs> kqr: Typeclassopedia has a section about them
06:06:33 <Tracki> can someone tell me why the data constructor Q is not in scope?
06:06:37 <Tracki> http://lpaste.net/5959504402963234816
06:06:53 <kqr> bennofs, i've always just dismissed them as arcane magic only useful for creating libraries
06:06:57 <Tracki> http://lpaste.net/873926214379634688
06:06:58 <kqr> bennofs, but i can see now how they're actually useful
06:09:42 <rawtass> I want to do the following code: do if something d <- getThing else d <- getThang ; return d
06:09:50 <rawtass> how should I go about that?
06:10:34 <kqr> rawtass, do { d <- if something then getThing else getThang ; return d }
06:10:37 <kqr> rawtass, or, equivalently
06:10:37 <quicksilver> rawtass: d <- if something then getThing else getThang; return d
06:10:44 <quicksilver> or, even simpler
06:10:44 <kqr> rawtass, if something then getThing else getThang
06:10:47 <lieven_> do {d <- if something getThing else getThans; return d}
06:10:50 <quicksilver> rawtass: if something then getThing else getThang
06:10:55 <quicksilver> kqr: ^5
06:11:54 <staffehn> Tracki, you don’t export the constructor from the Queue module.
06:13:41 <rawtass> ok, nice
06:14:49 <Tracki> can you tell me what exactly the constructor is? i thought (Queue,emptyQueue,queueEmpty,enqueue,dequeue,front) is it but ghc says itś not
06:15:20 <staffehn> (Queue(Q),emptyQueue,queueEmpty,enqueue,dequeue,front)
06:20:40 <ketil> I'm getting a strange error:  Not in scope: data constructor `W#'
06:20:55 <ketil> The line in question doesn't contain W#, but W##.  Any idea where this comes from?
06:21:46 <Tracki> thank you, but i am retarded it does not work -.-
06:21:46 <bennofs> ketil: Maybe ## is an escape sequence for # when using the preprocessor? Or maybe it's something to do with MagicHash?
06:22:26 <Raydiation> whats the purpose of a monad? to decide how and if a function will be exected based on the return of another function?
06:22:42 <Raydiation> so its basically an encapsulated if?
06:24:08 <tdammers> Raydiation: no
06:24:41 <tdammers> a monad is based on the observation that many things in programming follow a common pattern
06:25:01 <ion> No. Its purpose in Haskell is to give a name and laws (to help with reasoning) for a pattern a lot of code follows. We also get useful generic functions for all monadic code.
06:25:12 <ion> That is, in response to Raydiation, not tdammers.
06:25:21 <tdammers> ion: yeah, figured this much :D
06:25:51 <Raydiation> i know of the maybe monad, is there something else?
06:25:56 <tdammers> Raydiation: some of those things are about conditional execution or short-circuiting (e.g. the Maybe and Exception monads)
06:25:57 <FireFly> sure
06:25:57 <Raydiation> leaving out IO
06:25:59 <FireFly> the list monad
06:26:21 <int-e> > [1,2] >>= \a -> [3,5] >>= \b -> return (a+b) -- list monad
06:26:22 <lambdabot>  [4,6,5,7]
06:26:30 <tdammers> but others are about carrying state between computations, doing things in a predetermined order, doing things in parallel, etc.
06:26:58 <FireFly> Raydiation: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#control.i:Monad are some instances of Monad
06:26:58 <ion> raydiation: Why leave out IO? It’s a good example. We need to have a function that puts together two IO actions, and that just happens to follow the pattern, so we can just use (>>) and (>>=) instead of IO-specific names.
06:27:09 <tdammers> the monad laws and the definition of the Monad typeclass are really all that can reasonably be said about monads without going into the specifics of any particular implementation
06:27:27 <Raydiation> exactly thats whats kinda confusing imo
06:27:34 <Raydiation> the explanations are really abstract
06:27:38 <int-e> ion: IO is arguably less useful for learning because you can't look inside without getting down to implementation details.
06:27:38 <FireFly> Have you read Typeclassopedia, Raydiation?
06:27:45 <Raydiation> FireFly: nope
06:28:04 <FireFly> Well, you should :p
06:28:08 <Raydiation> oh cool :)
06:28:09 <Raydiation> thanks
06:29:50 <tdammers> Raydiation: learning monads by example is not a bad idea
06:29:57 <maxiepoo> so I found the bug in pygments' lhs detection
06:30:02 <tdammers> you just need to keep in mind that monads *are* a very abstract concept
06:30:17 <int-e> Raydiation: I don't think that "Monad" as a concept can be appreciated without first looking at a couple of concrete instances. Maybe, State, List, Reader should cover enough of the spectrum to see the underlying abstraction.
06:30:24 <maxiepoo> it only uses latex style if the first character of the file is a backslash
06:30:27 <maxiepoo> https://github.com/tmm1/pygments.rb/blob/4f9c1c1672884d5286257388f0f5cfed40b8f545/vendor/pygments-main/pygments/lexers/functional.py#L1088-L1150
06:31:24 <int-e> Raydiation: (The list is far from complete. Cont is a mind-bending monad, and of course from a software engineering perspective monad transformers are most interesting.)
06:31:27 <Raydiation> int-e: exactly, nearly everytime people use the maybe monad to explain it
06:31:44 <Raydiation> thats why i was wondering if all other monads are like that
06:31:46 <maxiepoo> which doesn't work for a file like: https://raw2.github.com/ghc/ghc/master/compiler/typecheck/TcArrows.lhs that starts with latex comments
06:32:01 <int-e> I'll stop here, but there's more :)
06:33:43 <Philonous> Raydiation, Answering your original question (purpose of monads): Monad the type class allows you to abstract over a certain kind of data. That is, it facilitates the implementation of algorithms independently of the concrete type. Of course, this is true for basically all type classes.
06:33:51 <DMcGill_work> Hi, does unpacking newtypes do what I want it to? I.e. is "newtype Value = V Int; data Foo = Foo {value :: {-# UNPACK #-} !Value}" the same as "data Bar = Bar {value ::  {-# UNPACK #-} !Int}"?
06:33:54 <markovirc_> Hello DMcGill_work
06:36:22 <Philonous> Raydiation, For a type class to be interesting it has to be strong enough to allow the implementation of interesting algorithms and at the same time weak enough so that a lot of types can implement it.
06:37:07 <Philonous> Raydiation, So to understand why monads are interesting you have to study which types are instances and which algorithms can be implemented in terms of members of the Monad class.
06:38:04 <maxiepoo> looks like the literate agda lexer checks to see if the first character is a backslash or a percent sign
06:38:14 <maxiepoo> better, but still not great
06:39:06 <flebron> Needed to share this here: What do you call someone who reads papers on category theory?               A coauthor.
06:39:20 <staffehn> DMcGill_work: "The unpacker can see through newtypes, too." from: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/pragmas.html
06:39:33 <maxiepoo> oh wait no the comment lied to me I think :(
06:39:37 <ketil> bennofs: yes, I think that was it.  Anyway, turns out I must import GHC.Exts when using an old (7.0) GHC.
06:39:58 <DMcGill_work> thanks staffehn
06:40:42 <Phlogistique> flebron: lol
06:41:40 <staffehn> flebron: lol, and I just recently learned what comonads are :D
06:48:42 <Fuuzetsu> are they comonoids in the category of endofunctors?
06:49:17 <Fuuzetsu> flebron: sigh
07:15:52 <remdezx> Hello! Does anybody know how to fix ths problem with lens?  http://lpaste.net/99171
07:15:52 <markovirc_> Hello remdezx
07:18:20 <Fuuzetsu> markovirc_: Are you a bot?~
07:18:28 <byorgey> remdezx: that is bizarre
07:19:05 <byorgey> remdezx: oh, wait, I get it
07:19:09 <supki> remdezx: yes, use ^?/preview
07:19:24 <byorgey> remdezx: what is v ^. x  supposed to be if  v happens to be a  Y ?
07:20:54 <remdezx> supki: thanks!
07:20:58 <byorgey> that's what the Monoid instance is for (it uses mempty as a default)
07:21:12 <Fuuzetsu> oh, clever
07:21:46 <byorgey> the really clever bit is that it just falls out naturally, since a Monoid instance is required for the Const instance of Applicative
07:21:57 <danilo> supki: Whatif we know exactly what is the element? Can we use something like ^? but not retunring Maybe? Just as normal element accessor?
07:22:17 <byorgey> danilo: then you use ^? and fromJust
07:22:22 <byorgey> but don't do that
07:22:27 <supki> :t (^?!)
07:22:28 <lambdabot> s -> Getting (Endo a) s a -> a
07:22:41 <ion> (^‽)
07:22:57 <danilo> supki: Thank you! :)
07:23:16 <xedir> Hey guys
07:23:54 <byorgey> hi xedir
07:24:42 <xedir> i have a question about random numbers
07:25:01 <xedir> is it possible to get a random number i.e. between 1 and 120 wihtout monads?
07:25:15 <ion> yes
07:25:26 <defanor> pseudorandom, at least
07:25:40 <xedir> yeah, it doesnt have to be super secure
07:25:42 <remdezx> supki: thanks twice! :)
07:26:02 <xedir> i just wrote a "programm" that should suffle a team of 5 players and their position
07:26:03 <ion> > randomR (1,120) (mkStdGen 42)
07:26:05 <quicksilver> you can't have a function pick_random :: Int -> Int which returns a random number each time
07:26:05 <lambdabot>  (72,1720602 40692)
07:26:19 <quicksilver> that defeats the point of having 'functions' in your language
07:26:30 <quicksilver> you can write programs which use random number generators in lots of ways though.
07:26:51 <ion> > randomRs (1,120) (mkStdGen 42)
07:26:53 <lambdabot>  [72,112,38,35,117,32,79,72,19,76,46,100,37,39,105,26,48,32,34,97,87,25,13,95...
07:27:51 <xedir> http://lpaste.net/1529845802984275968 this is my code
07:28:23 <xedir> i just woudl like to have different numbers for "zuweisung" each time i execute the code so i dont have to tyoe in two values
07:28:33 <novochar> How can you use lambda functions within ghci?
07:28:46 <ion> ghci> (\x + 1) 42
07:28:51 <ion> err
07:28:55 <ion> ghci> (\x -> x + 1) 42
07:29:15 <LowPotential> Hello. I'm trying to use the 'shelly' package to build up a small support library for running applications. Mostly it's okay, but the biggest issue is that 'shelly' exports 'FilePath' from 'system-filepath' so I'm forced to add 'import Prelude hiding (FilePath)' to the top of ALL of my files to avoid GHC complaining about an ambiguous reference. Is there any way to get around this? It's also rather annoying that it doesn't rexport
07:29:15 <LowPotential> 'Filesystem.Path.CurrentOS.encodeString' to convert to the prelude's idea of a 'FilePath', since so many functions elsewhere expect THAT 'FilePath'. That's another issue, though.
07:29:20 <markovirc_> Hello LowPotential
07:29:30 <novochar> thank you ion
07:30:21 <ion> xedir: Would it be that bad to use the IO monad? main = do { a <- randomRIO (1,120); b <- randomRIO (10,20); print (lederhose a b) }
07:30:35 <Tekmo> LowPotential: Yes, it is a bit annoying and verbose and clutters up your imports.  However, it does greatly cut down on path errors
07:30:50 <Tekmo> LowPotential: The best you can do is submit a pull request to at least add the re-export
07:31:03 <xedir> i just used this coding as a training for our upcoming exams and we dont have to use monads for it
07:31:22 <xedir> so i just dont rly know how to use monads etc.
07:31:22 <ion> xedir: Btw, code that uses (!!) most likely shouldn’t use lists.
07:31:50 <novochar> ideas why this is failing? https://gist.github.com/novodinia/1d7ccc1e78ad02314371
07:31:57 <LowPotential> Tekmo: Okay. Just wanted to make sure I wasn't missing something obvious. Thanks!
07:32:32 <Tekmo> LowPotential: You're welcome!
07:32:40 <Fuuzetsu> LowPotential: How about you import shelly twice, one of the qualified and one of them normally, hiding FilePath
07:32:41 <ion> novochar: Two reasons: print (\x -> x * x) doesn’t work because you can’t print a function; (print something) 2 doesn’t work because IO () isn’t a function.
07:32:42 <LowPotential> Tekmo: I might in fact make a pull-request. It's not a horrible idea, since the 'shelly' package doesn't really indicate from _which_ package it gets the 'FilePath' definition. Had to go digging in GitHub.
07:32:43 <Tekmo> xedir: Note that monads are just one way to interface with `IO`
07:32:45 <Fuuzetsu> then refer to FilePath by your qualified name
07:32:46 <novochar> print $ (\x -> x) 2
07:33:00 <Tekmo> xedir: You can also interface with it using `Functor` and `Applicative`
07:33:19 <ion> novochar: print ((\x -> x * x) 2) should work.
07:33:36 <Tekmo> xedir: For example, let's say you want to add two random numbers
07:33:38 <xedir> would i have to rewrite my code or just paste the main = d {.....} in it?
07:33:42 <Tekmo> xedir: You can do that using just `Applicative`
07:33:49 <novochar> ion: why () instead of $?
07:34:02 <ion> novochar: Either works.
07:34:24 <Tekmo> xedir: liftA2 (+) (randomRIO (1, 4)) (randomRIO (10, 14))
07:34:25 <LowPotential> Fuuzetsu: If I'm understanding you correctly, then that would mean that I'm using the Prelude's 'FilePath'. But I want shelly's.
07:34:59 <LowPotential> Fuuzetsu: Oh, I see. But writing "Shelly.FilePath" would be necessary. I guesss that's an alternative.
07:35:00 <Fuuzetsu> LowPotential: You'd use Shelly.FilePath wherever FilePath comes up
07:35:20 <LowPotential> Fuuzetsu: Hm... Definitiely an option. Thanks.
07:35:27 <Fuuzetsu> it's probably easier to hide Prelude's FilePath
07:35:43 <xedir> :Tekmo okay, so i could just say i = liftA2 (+) (randomRIO (1,2)) (RandomRIO (0,117)) and would get a "random" number?
07:36:31 <ion> xedir: An IO action that will result in one.
07:36:42 <Fuuzetsu> more or less, xedir, but as ion says, it's probably easier to just use the do notation
07:37:43 <Tekmo> xedir: It's type would be: IO Int
07:38:07 <xedir> how would i implement such a do notation?
07:38:09 <Tekmo> xedir: Think of an `IO a` as a set of instructions for how to retrieve an `a`
07:38:31 <Tekmo> xedir: When you combine things using the `Functor`/`Applicative`/`Monad` instances of `IO`, you are basically combining sets of instructions
07:38:58 <Tekmo> xedir: So `randomRIO (1, 2)` is an instruction for how to retrieve an `Int` (i.e. `IO Int`)
07:39:00 <ion> xedir: liftA2 f foo bar is equivalent to do { a <- foo; b <- bar; return (f a b) }
07:39:35 <Tekmo> xedir: When you chain `IO` actions together using `do` notation you are just combining their behaviors into a single behavior
07:40:01 <xedir> :D
07:40:05 <xedir> I got it i guess
07:40:44 <Tekmo> xedir: Note that `do` notation is just syntactic sugar for `(>>=)` and `(>>)`
07:40:53 <Tekmo> xedir: For example, consider the function `putStrLn`
07:40:59 <Tekmo> :t putStrLn
07:41:00 <lambdabot> String -> IO ()
07:41:17 <Tekmo> When you apply it to a `String` you get a runnable `IO` action that prints out a single string
07:41:27 <Tekmo> You can sequence two `IO` actions using `(>>)`
07:41:33 <Tekmo> (>>) :: IO a -> IO b -> IO b
07:41:39 <xedir> Tekmo: have a look at the paste
07:42:25 <Tekmo> xedir: What about it?
07:42:44 <xedir> Tekmo: i guess i just implemented the do notation thingy :P
07:43:15 <Tekmo> xedir: I annoted your paste showing how you can use `do` notation without braces and semicolons: http://lpaste.net/1529845802984275968
07:43:52 <xedir> ahhh
07:44:08 <xedir> that looks much more like code i will understand ;)
07:44:10 <Tekmo> But keep in mind that `do` notation just gets translated to `(>>)` and `(>>=)`
07:44:15 <Tekmo> For example, if you write:
07:44:28 <Tekmo> do { putStrLn "Hello"; putStrLn "world" }
07:44:30 <merijn> Tekmo: >>, >>= and fail :)
07:44:32 <Tekmo> That gets translated to:
07:44:40 <Tekmo> putStrLn "Hello" >> putStrLn "world"
07:44:40 <Fuuzetsu> xedir: http://lpaste.net/99173 example of do notation for your use
07:44:50 <c_wraith> merijn: we don't talk about fail in polite company
07:45:02 <Tekmo> ^
07:45:46 <klrr_> Tekmo: may i ask a question regarding taking next step into haskell?
07:46:22 <Tekmo> klrr_: Of course!
07:46:37 <xedir> Fuuzetsu: Thanks for this
07:46:50 <Fuuzetsu> np
07:47:01 <klrr_> what do i need to learn before digging into type theory and category theory etc.? i plan to study CS in future but currently only got one year experience with haskell
07:47:14 <xedir> Tekmo: also thanks, really appreciate it
07:47:28 <klrr_> (i dont know any CS that's what i meant)
07:47:31 <Tekmo> Note that digging into type theory and category may not necessarily improve your Haskell programming a whole lot
07:47:36 <Tekmo> klrr_: I would actually recommend the opposite
07:47:37 <Fuuzetsu> klrr_: Just pick up an entry level TT and CT book
07:47:53 <Tekmo> klrr_: Learn Haskell programming to improve your understanding of type theory and (a little bit less) category theory
07:48:19 <xedir> klrr_: i found fpcomplete very useful to solve a lot of the 99 haskell problems after reading learnyouahaskell
07:48:20 <Tekmo> xedir: You're welcome
07:48:21 <narendraj9> What is the best resource for learning about monads?
07:48:37 <Tekmo> narendraj9: This, hands down: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:49:08 <narendraj9> Tekmo: thanks :) will go through it :)
07:49:09 <klrr_> hmm, i mean how do i get more general knowledge and more advnaced regarding these (and other related or required) topics?
07:49:28 <Tekmo> klrr_: Writing Haskell programs and trying to find ways to make them more elegant
07:49:38 <klrr_> okey
07:50:05 <xedir> i was very happy when i found the first use of recursive functions in haskell :P
07:50:10 <Tekmo> klrr_: In other languages, attempts to make programs more elegant just end up creating useless abstractions and architectural astronauts
07:50:20 <Tekmo> klrr_: In Haskell, making things more elegant actually pays off
07:51:13 <klrr_> so i dont need to know any advanced mathematics or CS stuff to get into it? ive heard "functional data structures" is good book but kinda scared it will be too advanced
07:51:26 <Tekmo> I've never read functional data structures
07:51:44 <Tekmo> All you need to do is just study the API of the `containers` and `unordered-containers` libraries and you are good to go
07:52:23 <Dodek> klrr_: category is most useful and illuminating when you see it in many contexts
07:52:34 <xedir> may i ask you one more thing guys :P
07:52:40 <Dodek> klrr_: and mathematics provides lots of contexts to look at category theory in
07:52:46 <Tekmo> klrr_: Category theory is highly useful for library writing
07:52:51 <Tekmo> klrr_: It's less useful for application writing
07:52:53 <xedir> how could i export this "programm" to get an .exe out of it?
07:53:10 <Tekmo> xedir: You can compile it
07:53:17 <klrr_> what kind of mathemtics will be useful? i dont need univ knowledge ?
07:53:17 <Dodek> klrr_: the problem is that it requires lots of work to grasp what's mathematics about
07:53:22 <Tekmo> xedir: `ghc -O2 YourProgram.s`
07:53:25 <Tekmo> Oops
07:53:30 <Tekmo> xedir: `ghc -O2 YourProgram.hs`
07:53:43 <dv-> or even ghc -O2 YourProgram
07:53:44 <merijn> klrr_: As far as I know Purely Functional Data Structures are really accessible
07:53:46 <Dodek> klrr_: and the kind of math category theory is most useful in is most certainly advanced university math.
07:53:48 <xedir> okay, and this will make an .exe out of it?^^
07:53:57 <Tekmo> Yes
07:54:04 <xedir> this is so magic :P
07:54:06 <xedir> thanks
07:54:07 <Fuuzetsu> is there an lpaste API?
07:54:07 <Tekmo> It makes `YourProgram.exe`
07:54:12 <merijn> klrr_: Basically, inventing new data structures/algorithms and proving them right is hard, but understanding them after someone else has done the hard work is not nearly as hard
07:54:12 <Tekmo> xedir: You're welcome
07:54:12 <klrr_> okey, well sounds quite promising, quite opposite from what my math teacher would say (he's awesome at scaring people away from his courses)
07:54:29 <klrr_> okey
07:54:44 <merijn> klrr_: Additionally, if you want a "practical" (i.e. invent your own language for fun and learning) intro to type theory, you want to pick up TaPL
07:54:47 <merijn> @where tapl
07:54:47 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:55:02 <kqr> is there a short guide-like thing somewhere that teaches you to use regexes in haskell with the tdfa backend? i'm always confused when i'm trying to do that
07:55:14 <klrr_> thanks
07:55:14 <merijn> klrr_: Imagine the difference between saying quicksort explained and having to invent quicksort
07:55:21 <klrr_> aa
07:55:22 <merijn> s/saying/seeing
07:55:23 <klrr_> yeah
07:55:59 <merijn> Fuuzetsu: "lpaste API" you mean curl? :p
07:56:49 <xedir> Tekmo: mh, should this work with ghci as well?
07:56:57 <Fuuzetsu> merijn: Yeah, I do. I'd rather not do the legwork myself, getting fields and all
07:57:02 <Fuuzetsu> (to post)
07:57:15 <klrr_> okey, TaPL, okasaki, studying containers and unordered-containers API's
07:57:23 <klrr_> or source perhaps
07:57:26 <merijn> Fuuzetsu: There used to be an hpaste program on hackage
07:57:31 <Tekmo> xedir: Yes, it does
07:57:42 <merijn> klrr_: Also Introduction to Algorithms (not really functional, but still important)
07:57:42 <Tekmo> xedir: If you load your file into `ghci` you can then type `main` to run your program
07:58:00 <klrr_> thanks
07:58:08 <xedir> yeah, but i just want to get a .exe that i can send arround
07:58:11 <klrr_> gonna make a gist since i know some friends who might be interested in this aswell
07:58:26 <merijn> klrr_: Don't be intimidated by the first 1 or 2 chapters on math proofs, you can skim past those and go on to the algorithms
07:58:41 <klrr_> okey!
07:58:51 <Tekmo> xedir: That's what `ghc -O2 YourProgram.hs` does
07:58:58 <Tekmo> xedir: It creates a `YourProgram.exe` that you can run
07:59:07 <ToJans> Hi
07:59:08 <markovirc_> Hello ToJans
07:59:33 <ToJans> I have a question regarding the scotty web fw
07:59:45 <ToJans> or maybe even every fw :D
07:59:45 <Fuuzetsu> merijn: yeah but it's the whole server and all
08:00:11 <ToJans> Can I ask it?
08:00:16 <xedir> uhm, i get errors like not in scope ghc and not in scope Spiel.hs
08:00:17 <Fuuzetsu> @where justask
08:00:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
08:00:27 <ToJans> hehe
08:00:34 <merijn> Fuuzetsu: Something like: https://code.google.com/p/pastepipe/
08:01:16 <Fuuzetsu> merijn: well, I'm looking for a simple Haskell lib rather than an executable… Seems I'll just have to write one
08:01:39 <ToJans> some bg first: I have over 10years of experience in imperative languages, and about 1 in Erlang/Elixir etc
08:01:53 <dv-> xedir: paste the exact output on lpaste.net
08:01:58 <ToJans> I discovered Haskell so I'd like to learn it
08:02:32 <Maior> ToJans: learnyouahaskell.com
08:02:43 <ToJans> I figured the best way to learn it (after skimming a lot of the available books etc) was to take a task for applying somewhere
08:02:56 <Fuuzetsu> Maior: I think he wasn't finished typing ;P
08:02:59 <ToJans> Maior: thanks, I did read that
08:03:00 <xedir> will a screenshot work, i cant get in icr with my PC cuz of the java update so i'm at my mac atm
08:03:01 * hackagebot ssh 0.2.12.2 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.12.2 (SimonMichael)
08:03:19 <ToJans> (at least big parts of it)
08:03:28 <BrianHV> Fuuzetsu: it shouldn't be hard to use pastepipe as a lib
08:03:34 <Fuuzetsu> xedir: Just copy and paste the output to http://lpaste.net and post the link, if you can get a screenshot then you can do that
08:04:00 <ToJans> So I now have this simple web app I constructed by copy-pasting something from here and there
08:04:19 <ToJans> the task is an assignment from a company in Singapore: Zalora
08:04:36 <ToJans> http://functionaljobs.com/jobs/8678-haskell-developer-at-zalora
08:04:53 <xedir> mh, i cant paste in new stuff in the irc box, just things i copy from here.
08:05:31 <Maior> lol
08:05:49 <ToJans> I wanted to create the simplest thing possible to check how far I was
08:05:53 <ToJans> https://gist.github.com/ToJans/8670469
08:06:30 <Maior> ToJans: so you're in touch with Mr. Roux?
08:06:49 <ToJans> No, not AFAIK
08:07:13 <ToJans> I'd just like to figure out how hard/easy it is to write a real haskell app
08:07:42 <ToJans> Ah, sorry, there's some errors in there
08:07:47 <ToJans> I'll fix them first :D
08:08:08 <xedir> Tekmo: just killed my IRC here :P http://gyazo.com/c4cd891f80b9245b8cedefd10bfffdc7 thats the error i get
08:08:09 <ToJans> (I was experimenting with it before I copied it)
08:08:56 <dv-> xedir: exit ghci and run ghc
08:11:43 <xedir> keep getting exact the same error
08:12:56 <dv-> you can't run ghc in ghci. you need to exit and run ghc -O2 YourProgram in the window prompt
08:13:13 <xedir> ah
08:13:22 <xedir> i get an error but it created the file :P
08:13:51 <xedir> but i just discovered an other problem, how do i keep it from closing itslef instantly after beeing executed?
08:13:59 <macerto> ciao
08:14:06 <macerto> !list
08:14:06 <monochrom> macerto: http://hackage.haskell.org/packages/archive/pkg-list.html
08:14:15 <c_wraith> xedir: I think that's windows doing that, not your program
08:14:47 <dv-> xedir: start cmd.exe somehow to get a windows terminal prompt
08:14:58 <c_wraith> xedir: if my guess is right, you fix that by running it from a terminal, rather than double-clicking on it in explorer
08:14:59 <dv-> then cd to the directory that your file is in, and run ghc
08:15:54 <xedir> okay, now i can start the programm by typing its path in cmd
08:16:26 <xedir> is there any way to start it and keep it untill i close it with doubleklick?
08:23:25 <Fuuzetsu> xedir: you could prompt for user input at the end of the program
08:24:01 <Fuuzetsu> for example, add ‘readLine’ in the end of ‘main’
08:24:27 <Fuuzetsu> it's just a Windows hack thing though, you're better off just opening cmd manually first and then running the program
08:24:57 <xedir> I'm currently working on a new feature :P
08:25:10 <xedir> you have to type in "New Team" and you get a new list
08:25:22 <xedir> so this would keep the window open and make sense^^
08:26:36 <klrr_> hmm, is the machines exprimental branch OK to work with? only found examples compatible with that but none for 2.3*
08:29:23 <novochar> When I think about purity, I think of functions we were taught about in algebra class during primary/middle school, i.e. f(x) -> x * x. We call these pure functions right, because?
08:29:41 <novochar> Because they only do one thing or because given the same input they will always produce the same output?
08:30:04 <klrr_> yes
08:30:32 <Phlogistique> novochar: because given the same input they will always produce the same output
08:30:58 <novochar> Typically you will see code like this: f x = answer = x * x; print answer; return answer; is this considered impure?
08:31:11 <klrr_> well
08:31:38 <Maior> Int -> IO Int? ;)
08:31:54 <novochar> haskell has code which looks like f x = do let answer = x * x; print answer; return answer; so wouldn't this make this function impure?
08:32:09 <klrr_> not really sure what you mean by "f x = answer = x * x" but print computation would be impure as it does a side-effect, e.g. prints to the screen
08:32:19 <jle`> novochar: well
08:32:29 <jle`> if i am understanding your question right
08:32:34 <mada> I think that function would actually return an action that, when performed, would execute those steps
08:32:41 <klrr_> that function would be of type "Int -> IO Int"
08:32:43 <jle`> it generates an IO Object
08:32:49 <jle`> that when read by a run time system
08:32:53 <jle`> executes a print
08:32:53 <mada> it is still a pure function
08:33:03 <jle`> the function is pure in that it always generates the same IO Object
08:33:18 <jle`> how the run time system/your computer processor deals with the IO object is of its own, separate business
08:33:34 <jle`> in Haskell, we reason about the pure process of generating an IO Object
08:33:37 <klrr_> but
08:33:41 <klrr_> you are using stdout here
08:33:43 <jle`> and we can do this mathematically
08:34:08 <jle`> we can, for example, use a major 'benefit' of purity
08:34:12 <jle`> which is referential transparency
08:34:41 <jle`> which says that you can expand out any function into its definition and the entire thing will be the same
08:35:10 <jle`> so we could, say, expand out "print answer" into the definition of print, "putStrLn . show"
08:35:19 <jle`> and then similarly, we can substitute show for the definition of show
08:35:25 <jle`> defined for Ints
08:35:28 <jle`> defined in Base
08:35:40 <jle`> and then the definition of print
08:35:42 <jle`> etc.
08:35:45 <jle`> in an impure language, this is not the case.
08:35:55 <jle`> you cannot in general replace a function call by its definition and expect things to remain the same.
08:36:03 <klrr_> i would say its impure, because you do call unsafePerformIO
08:36:08 <frx> klrr_ putStrLn "hello" just returns a value (IO) with instructions to print something to stdout. calling the function by itself does not print anything
08:36:22 <jle`> your function f x is pure because it always assembles the same IO object.
08:36:26 <klrr_> well that's true
08:36:29 <jle`> every single time you run it
08:36:42 <jle`> this purity is just as strong as every other 'purity' that we talk about
08:36:47 <jle`> and it confers all of the benefits of purity
08:36:51 <jle`> and all of the power of purity
08:36:54 <jle`> the equational reasoning, etc.
08:37:02 <jle`> the guaruntees
08:37:13 <jle`> you can always write f x and expect it to generate the exact same IO object
08:37:15 <jle`> for the same x
08:37:56 <jle`> because remember in Haskell we don't really work with things that execute
08:37:59 <jle`> we work with generating IO objects
08:38:05 <jle`> not generating, per se
08:38:07 <jle`> but composing them
08:38:19 <jle`> composing big IO objects out of smaller IO objecs
08:39:03 <jle`> Prelude provides an IO object that represents the act of printing a line.  putStrLn x.  you can think of putStrLn x as a little textual chunk of C code...and imagine that Haskell is a macro language.
08:39:27 <jle`> when you write putStrLn x in Haskell...you don't write something that executes.  you reference that little chunk of C code, and you can do whatever you want with it
08:39:38 <jle`> however you want with it
08:39:42 <jle`> with pure functions.
08:39:59 <jle`> and it'll always compose, go through functions, etc. etc., purely.
08:40:33 <jle`> for example...i have this instruction chunk putStrLn "hello", and another instruction chunk putStrLn "world"...these are both self-contained little programs.  C programs.  Assembly programs.
08:40:35 <mada> jle`: my main confusion when thinking about IO <-> purity is the magic implementation of IO
08:40:45 <mada> everything else in Haskell is just normal haskell
08:40:53 <mada> nothing is "special"
08:41:02 <jle`> GHC gives lets us combine two IO programs into one, using >>
08:41:19 <jle`> putStrLn "hello" >> putStrLn "world" is a new IO program, a new C program, a new Assembly program, C chunk, etc. that prints both hello and world
08:41:29 <jle`> mada: i don't really feel like IO is too special
08:41:45 <jle`> the way we work with IO in haskell is really the way we work with any other data type
08:42:04 <mada> jle`: I get that from the haskell side, it behaves as any other type
08:42:11 <jle`> anyways, putStrLn "hello" >> putStrLn "world" always returns the same IO object every time
08:42:14 <jle`> that's why it's pure
08:42:26 <mada> but with any other monad one can go and check the implementation and see that it's just normal haskell
08:44:03 <jle`> well...if you can apply all the benefits of purity and equational reasoning and referential transparency
08:44:04 <AlainODea> mada: there's some magic with the STM and Eval monads.  It's not a bad thing IMO.  It embraces side-effects, but contrains them within the type system.  For example IO effects aren't allowed in STM
08:44:18 <jle`> then how can you say it's too different?
08:44:22 <jle`> what parts about the implementation are relevant?
08:44:43 <jle`> if you can compose them purely and reason about them purely
08:45:02 <jle`> then for all intents and purposes, it's pure
08:45:04 <mada> AlainODea: I don't think it's a bad thing either, and I do get that all that matters is that the data type behaves and allows equational reasoning and referential transparency
08:45:23 <mada> whatever the implementation is
08:50:15 <AlainODea> mada: I like the trade-off a lot. The imperative part of Haskell is good enough to be better than most imperative languages I use.  Side-effects aren't evil, and purity isn't always best.  Haskell lets you choose for your own code and (modulo abuse of unsafe*) trust libraries
08:51:38 <mada> AlainODea: I don't quite get the unsafe* functions
08:51:58 <mada> are they thought of as shortcuts? hacks?
08:52:01 <monochrom> the important point to me is that an effectful thing has a different type from an uneffectful thing. when I see "x :: Char" I know that it stays the same. when I see "y :: IO Char" I know what to expect.
08:52:45 <AlainODea> mada: from what I understand, they are an escape hatch intended for unresolvable scenarios (which I can't think of) or performance optimizations (which really belong in GHC or other Haskell runtime itself)
08:52:52 <monochrom> in fact, see my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
08:53:19 <mada> monochrom: seeing, thanks
08:53:48 <mada> AlainODea: well I can't think of any scenario like that either, they must be quite the corner cases
08:53:54 <benbangert> when trying to install haskell-platform on 12.04, I get this error after successfull configure, http://paste.ofcode.org/QWdnRdmETVE9Uyp7D6AVfB
08:53:58 <benbangert> any ideas whats wrong?
08:55:30 <henk> http://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html says »the Value data type is just the sum of string, array, object, number and null constructors«. What does that imply? Which possibilities does that create? Can I treat a Value as a String somehow?
08:55:40 <AlainODea> benbangert: do you have all required dependencies installed. https://gist.github.com/AlainODea/6629115
08:56:12 <AlainODea> benbangert: I'm not really sure if my Gist fully covers them especially since it's for Ubuntu 13.04.
08:56:38 <benbangert> yea, ghc is 7.4 on a 12.04 system
08:57:03 <benbangert> I found https://ghc.haskell.org/trac/ghc/ticket/7949 which seems to be the error I'm having, gonna try that fix
08:59:20 <benbangert> heh, well, build is proceeding now that I did that
08:59:34 <monochrom> I wonder how many people actually read your paste before answering
08:59:39 <henk> What does the ! in "data Value = Object !Object | String !Text" mean? What is that notation called?
08:59:57 <c_wraith> henk: "strictness annotation"
09:00:15 <henk> c_wraith: thanks
09:00:15 <c_wraith> henk: it means that when the constructor is evaluated, that argument is evaluated to WHNF
09:00:26 <monochrom> it is strictness annotation. it makes the marked field more strict.
09:01:06 <monochrom> I really need to update my article on that
09:01:29 <monochrom> then again I wonder how many people read it
09:03:07 <implementation> How to I get (reify) a TypeQ from a name like "Maybe Int"?
09:03:24 <dwcook> henk, it means that it might represent a JSON string, among those other possibilities. You can't treat it like one until you know for sure it is one though.
09:03:31 <mmachenry> henk: It's strictnes
09:03:35 <c_wraith> implementation: you have the name as a string?
09:03:35 <mmachenry> *strictness
09:03:46 <dwcook> henk, (referring to your question about the link)
09:03:58 <implementation> c_wraith, yes. mkName and then the ordinary reification procedure doesn't work :/
09:04:35 <c_wraith> implementation: yeah, mkName is limited in that way.  I'm not actually sure how to do that. I've made sure to always pass wround at least a Name
09:04:50 <joelteon> You can't remove stuff from hackage, right?
09:05:21 <c_wraith> joelteon: admins can.  maintainers can't
09:05:26 <joelteon> heh
09:05:35 <joelteon> alright
09:06:15 <sm> you can deprecate packages
09:06:23 <cschneid> monochrom: when do you use strictness vs. not in data? How would I make that decision
09:07:41 <monochrom> usually, when you do not care about strict vs non-strict, but rather eager vs lazy, and you want that field to be evaluated more eagerly
09:09:09 <seschwar> I am trying to add a nice error message to my Parsec parser
09:09:42 <djahandarie> I sometimes wish =<< had a more "application"-looking symbol
09:09:49 <seschwar> here is the code: https://gist.github.com/seschwar/8671346
09:10:20 <monochrom> you can always call it "=$"
09:10:29 <c_wraith> can you?
09:10:36 <c_wraith> Oh, yeah, you can.
09:10:46 <Clint> looks conduitty
09:10:51 <monochrom> well, it is not like you can change Prelude
09:11:02 <cschneid> monochrom: sure, of course. But I still don't know when to make that decision on a given data type.
09:11:05 <djahandarie> monochrom, well, the point of it would be for increased clarity. Defining my own adhoc symbols would not accomplish that goal in all likelyhood.
09:11:06 <seschwar> i am using "try" to prevent the parser from consuming the input when it fails
09:12:08 <seschwar> but it does not seem to work properly and the alternative "unexpected ..." is not reached
09:12:21 <c_wraith> fun fact!  when GHC compiles an executable, if it has a module named Prelude in its source tree, that gets used instead of base's.  This can be a handy thing or a super terrible thing.
09:12:27 <monochrom> cschneid, if you know what things are more efficent when lazy, and what things are more efficient when eager, then you can decide. if you don't know, then read my http://www.vex.net/~trebla/haskell/lazy.xhtml to learn the very very basic of laziness
09:12:56 <cschneid> monochrom: yeah, I understand a lot of the detail of implementation, but I have no practical feel for when to prefer one vs other. Reading your post now.
09:13:09 <monochrom> I say "very very basic of laziness" because I haven't completed it. there are many more things and case studies I haven't covered
09:13:10 * hackagebot htsn 0.0.6 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.6 (MichaelOrlitzky)
09:13:21 <Clint> c_wraith: is that really handier than NoImplicitPrelude?
09:13:26 <henk> My question is basically about parsing json input like http://lpaste.net/99174 without using my own datatype but working on the AST directly. I’m trying to print "host" ++ "path" for every service that is "not NORMAL". The problem is that I cannot tell what to decode that last Value to because they are mixed Strings, Bools, etc … Is there any way around creating my own datatype and parsing the json to
09:13:28 <henk> that?
09:13:34 <seschwar> i can't quite see what's going wrong there
09:14:02 <monochrom> ok, "understand a lot of the detail of implementation" and "can't decide when to be eager" is a clear contradiction.
09:14:13 <monochrom> but you can always hire me to decide for you
09:14:47 <c_wraith> Clint: it is if you want to add a bunch of default imports.  Whether adding a bunch of default imports is a win or not is another question.  (it makes writing code easier, but reading it harder)
09:15:59 <supki> henk: you can use lens(-aeson) to work on AST directly
09:16:15 <supki> it'd be simpler to make a datatype probably, though
09:19:10 <klrr_> anyone know any project who uses machines? i know of the slides and the machines-play doc but wonder if there is some real code using it
09:20:00 <henk> supki: ok, thanks
09:22:00 <henk> It’s a little frustrating to see how I wrote the same program in python in about 1.5 hours without having done anything in python before ever while I need about 5 hours and still have nothing usable in haskell which I have already invested so many hours of learning on ):
09:22:14 <ToJans> Hello guys
09:22:24 <ToJans> 'm back with the question about the Zalora project
09:22:34 <ToJans> So I created a github repository here:
09:22:36 <ToJans> https://github.com/ToJans/zalora/blob/master/main.hs
09:22:37 <sm> henk: you've done things in languages very similar to python though
09:22:51 <ToJans> which should process a json post request
09:22:57 <ToJans> however
09:23:07 <ToJans> this is the error I get back from the server:
09:23:28 <ToJans> response <h1>500 Internal Server Error</h1>jsonData - no parse: {"photo":"","description":"a","color":"b","size":"1"}
09:23:38 <ToJans> which I think is odd
09:24:07 <ToJans> here's what I do:
09:24:18 <ToJans> postShoes = do   shoesData <- jsonData   html $ shoesData
09:24:35 * Clint squints.
09:24:44 <ToJans> (split in 3)
09:24:53 <Clint> ah
09:24:54 <ToJans> https://github.com/ToJans/zalora/blob/master/main.hs#L36-L37
09:25:48 <c_wraith> ToJans: if you want to make something a one-liner for us, it's often worth throwing in {;} stuff to make it actually compilable
09:26:08 <ToJans> Yes sorry
09:26:12 <ToJans> I copy/pasted it
09:26:33 <ToJans> postShoes = do  { shoesData <- jsonData ;  html $ shoesData }
09:26:36 <c_wraith> ah.  Need a smarter IRC program, to recognize haskell pastes and dynamically reformat them. :)
09:26:40 <ToJans> hehe
09:27:12 <ToJans> this looks like valid JSON ?
09:27:34 <sm> henk: though, that's not the only issue at work here. I agree it can be frustrating.
09:27:37 <henk> sm: oh, good point. Yes, true, I have tried learning a few imperative languages and thus have a grasp of the programming concepts (:
09:28:26 <xedir> And its me again, i still have some problems with making a executeable file out of my .hs files
09:28:29 <sm> other factors: python has a much larger community, and beginner friendliness has been a higher priority from the beginning
09:29:19 <ToJans> so I checked the Scotty source code
09:29:22 <xedir> if someone would like to have a look at my code its posted here: http://lpaste.net/58652545840578560  what i did in ghc was "ghc -02 Spiele.hs"
09:29:35 <ToJans> and it uses Aeson decode underneat
09:29:42 <ToJans> (if I understood correctly)
09:30:08 <Clint> ToJans: does it work if you remove the "id" field?
09:30:22 <ToJans> I'll try
09:30:55 <ToJans> but why would it use the Shoes data type?
09:31:06 <ToJans> or do I need to cast it explicitly
09:31:26 <Clint> oh
09:31:26 <ToJans> or does it auto-ref the "instance FromJSON Shoes"
09:31:45 <ToJans> in one magic way or another?
09:32:00 <Clint> no, good point
09:32:33 <ToJans> can I invoke a FromJSON directly to the Shoes type?
09:32:52 <monochrom> I don't understand comparisons of "after 1.5 hours of learning python vs after 1.5 hours of learning haskell"
09:33:17 <klrr_> ok this "let planb = (do x <- await; print x) :: Plan Char IO ()" apperantl have type "IO ()" according to GHC, what type does it have to work?
09:33:21 <ToJans> i.e. something like  { b <- body; Shoes.decode b }
09:33:26 <monochrom> suppose you grew up with SML, Agda, and Idris, and never heard of C, C++, and Java. now compare again?
09:33:26 <klrr_> oh shit im stupid, forgot lift the print
09:33:29 <Clint> ToJans: you can say that you want jsonData to be "ActionM Shoes" or something
09:34:09 <ToJans> aha, so I need to add the typedef ?
09:34:28 <ToJans> I'll take a look at the scotty examples again
09:35:03 <xplat> is neil mitchell on irc?
09:35:12 <Fuuzetsu> monochrom: While I see where you're coming from, a large majority of people grew up with imperative languages.
09:35:24 <Fuuzetsu> xplat: No but he's very responsive over e-mail.
09:35:34 <monochrom> I'm pretty sure if you grew up with Agda and Idris, then after 1.5 hours of learning Haskell you would be already on to FRP. as for 1.5 hours of python, I'm pretty sure it would be a case of "I can't still get lambda to work"
09:35:40 <henk> monochrom: Would probably be the same result … Or even worse? However the "community" argument is a good one. Even when "bigger" does not necessarily mean "better", but you just find more stuff about popular (imperative) languages …
09:36:19 <Fuuzetsu> monochrom: I'm pretty sure they'd be saying that about lambda even after 15 hours ;)
09:36:20 <henk> monochrom: uhm, "the same" meaning "the other way round" … Well, I guess you know what I mean (:
09:36:32 <monochrom> yes Fuuzetsu that's what I'm relying on :)
09:37:19 <c_wraith> python's kind of a special case, in terms of having language features that seem like they *should* support functional programming mixed with a culture (led from the top) that hates it
09:37:26 <monochrom> but there is "after 1.5 hours you haven't found out that python's lambda is intended to be castrated, after 15 hours someone tells you"
09:38:00 <Fuuzetsu> s/python's lambda/python/
09:38:12 * hackagebot monadcryptorandom 0.6.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.6.1 (ThomasDuBuisson)
09:38:33 <monochrom> in fact, bloody hell, several years ago, python's if-then-else was only a command, not an expression. "if x==0 then 5 else 4" was forbidden. you would likely spend 1.5 hours getting stuck on that if not told.
09:38:36 <xedir> Fuuzetszu: do you think you can help me :P
09:38:46 <Fuuzetsu> is there a limit on a package name length allowed on Hackage?
09:38:48 <rtpg> anyone have a good use case for fix? All I can find is use cases that are contrived ("oh hey we can do anyonymous recursion yay!")
09:38:54 <rtpg> well, they seem contrived to me anyways
09:38:58 <notdan> monochrom: hm what do you mean by that?
09:39:04 <notdan> monochrom: why was it forbidden?
09:39:06 <xplat> this discussion thread about haskell vs python seems kind of pointless.  let's have an even more pointless discussion about whether we should continue discussing it
09:39:08 <c_wraith> monochrom: did they only change that one because of ruby's sudden popularity?
09:39:24 <monochrom> I don't know. to all 3 questions.
09:39:34 <c_wraith> rtpg: sometimes it makes anonymous loops look a little cleaner.  Other than that, it's only good for clever one-liners
09:39:34 <Fuuzetsu> xedir: What's the problem? I don't see you seeking help anywhere and I'd rather not commit to something I might not be able to answer. Ask away on the channel and if someone can help you, they will.
09:39:52 <sm> xplat: before we do that, let's ask ourselves if this is really the place for that discussion
09:40:14 <xedir> u're one of the haskell pros i recogniced :P
09:40:18 <ToJans> Hmmz can't seem to find a solution in the scotty code
09:40:28 <ToJans> How would one solve this? fire up ghci?
09:40:41 <xedir> http://lpaste.net/58652545840578560
09:40:51 <monochrom> well, I guess I know afterall. GvR was heard to say "python is a statement language, not an expression language". therefore, he castrated everything that encouraged expressions.
09:41:11 <xedir> this is my code and this is the error i get when i try to make an executeable file out of it http://gyazo.com/112e4ba289af34cf14bcbff2209ee443
09:41:46 <sm> xedir: run ghc at the command prompt, not inside ghci
09:42:14 * Redz sitting around and click random lpaste links. 
09:42:18 <xedir> you mean cmd -> ghc -> ghc -02 Spielev01.hs
09:42:24 <Fuuzetsu> Speaking of Ruby and Haskell: http://fuuzetsu.co.uk/images/haskell_and_ruby_together.png
09:42:33 <sm> or just run your program inside ghci, after you successfully loaded it, by typing :main
09:42:44 <c_wraith> rtpg: in particular, fix allows you to write the occasional real-world loop without declaring a named loop function
09:42:44 <zomg> weeaboo alert
09:42:49 <xedir> i want to send an .exe arround :P
09:43:42 <c_wraith> rtpg: fix $ \loop -> do { some logic ; something that executes loop conditionally ; some other logic ; something else that executes loop conditionally ; etc.. }
09:43:51 <Fuuzetsu> xedir: You shouldn't be inside of ‘ghci’… If you want to do it that way, add the colon before the ghc command, just like you did with all the other commands
09:44:24 <Fuuzetsu> zomg: I'll make sure to call a weeaboo trigger warning the next time in case your pure eyes get burned.
09:44:37 <zomg> lol
09:44:45 <sm> :! ghc ..blah blah.., perhaps. Also it's -O2 not -02
09:44:59 <zomg> yeah just joking :P
09:45:00 <xedir> like :ghc -02 Spielev01.hs
09:45:07 <Fuuzetsu> oops, right, :!
09:45:10 <Redz> -O99 of course.
09:45:16 <Fuuzetsu> :! ghc -O2 Speliev01.hs
09:45:24 <Fuuzetsu> (letter O, not number 0)
09:45:33 <xedir> oh
09:45:41 <Fuuzetsu> and honestly, you should not be in ghci for this which is where your problem is coming from…
09:45:53 <monochrom> rtpg: I don't use fix often. so don't you worry.
09:46:00 <xplat> hyphen capital oh two
09:46:14 <monochrom> but you, you alone, should decide what you use. don't worry about other people.
09:46:14 <Fuuzetsu> O²
09:46:51 <ToJans> Ok, I need to wrap it up here, but I'll probably be back
09:46:51 <Fuuzetsu> Redz: I actually ran -O9999 earlier today
09:46:55 <xplat> > let cy = fix (++) in cy "lon"
09:46:57 <lambdabot>  Couldn't match type `[a0] -> [a0]' with `[a0]'
09:46:58 <lambdabot>  Expected type: [a0] -> [a0]
09:46:58 <lambdabot>    Actual type: [a0] -> [a0] -> [a0]
09:46:58 <Fuuzetsu> I feel like it should have at least complained…
09:47:14 <ToJans> %s/probably/most definitely/g
09:47:23 <xplat> > let cy = fix . (++) in cy "lon"
09:47:26 <lambdabot>  "lonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlon...
09:47:28 <Fuuzetsu> > fix (++ "lon")
09:47:31 <lambdabot>  mueval-core: Time limit exceeded
09:47:55 <xplat> > fix ("lon"++)
09:47:56 <lambdabot>  "lonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlonlon...
09:48:39 <Fuuzetsu> > take 10 $ fix ("lon"++)
09:48:40 <lambdabot>  "lonlonlonl"
09:48:50 <Fuuzetsu> @src cycle
09:48:50 <lambdabot> cycle [] = undefined
09:48:50 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:48:58 <Fuuzetsu> how boring
09:49:15 <Hexagenic> > "Tro" ++ $ fix ("lo"++)
09:49:16 <lambdabot>  <hint>:1:10: parse error on input `$'
09:49:24 <xplat> > cycle ""
09:49:25 <lambdabot>  "*Exception: Prelude.cycle: empty list
09:49:39 <FreeFull> Hexagenic: Infix operators don't work like that
09:49:47 <FreeFull> > "Tro" ++ fix ("lo"++)
09:49:48 <lambdabot>  "Trololololololololololololololololololololololololololololololololololololo...
09:49:55 <Hexagenic> oh right.
09:51:03 <dgpratt> it seems like it should be: cycle [] = []  no?
09:51:14 <Fuuzetsu> no
09:51:21 <dgpratt> at least then it wouldn't be partial :)
09:51:27 <monochrom> cycle xs is meant to be an infinite list. is [] an infinite list?
09:51:50 <dgpratt> well...I suppose not :)
09:52:21 <Fuuzetsu> I wonder if there's cycleM :: Monoid m => [m] → [m] somewhere
09:52:44 <Fuuzetsu> Damn, I mixed regular syntax with UnicodeSyntax, I truly am the worst.
09:53:26 <FreeFull> Fuuzetsu: What would it do?
09:53:35 <xedir> it works, it works yay
09:53:45 <xedir> Fuuzetsu: Thanks alot :*
09:53:50 <xedir> and the rest ofc as well ;)
09:54:01 <c_wraith> Fuuzetsu: how is that different from cycle?
09:55:01 <Fuuzetsu> c_wraith: FreeFull: it'd cycle [mempty] in case you passed in []
09:55:27 <FireFly> Does that provide anything meaningful?
09:55:34 <Fuuzetsu> it makes it total!
09:55:38 <FreeFull> > cycle mempty
09:55:39 <lambdabot>  *Exception: Prelude.cycle: empty list
09:55:41 <sm> xedir: nice
09:55:44 <FreeFull> > cycle [mempty]
09:55:45 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
09:55:50 <Fuuzetsu> nice defaulting as always
09:56:12 <Fuuzetsu> > cycle [mempty] :: Sum Integer
09:56:14 <lambdabot>  Couldn't match expected type `Data.Monoid.Sum
09:56:14 <lambdabot>                                  GHC.Integer.Type.Integer'
09:56:14 <lambdabot>              with actual type `[a0]'
09:56:18 <Fuuzetsu> uh
09:56:21 <Fuuzetsu> :t Sum
09:56:21 <lambdabot> a -> Sum a
09:56:33 <Fuuzetsu> Sum 7
09:56:40 <Fuuzetsu> > Sum 7
09:56:41 <lambdabot>  Sum {getSum = 7}
09:56:59 <Fuuzetsu> it's over, I can't think of a monoid off the top of my head
09:57:21 <Fuuzetsu> > cycle [mempty] :: [Sum Integer]
09:57:22 <lambdabot>  [Sum {getSum = 0},Sum {getSum = 0},Sum {getSum = 0},Sum {getSum = 0},Sum {ge...
09:57:28 <kqr> what's the recommended way to parse command-line arguments in haskell? there seems to be so many alternatives
09:57:48 <Fuuzetsu> kqr: Pick the one you like, there's no one way
09:58:22 <Fuuzetsu> I heard optparse-applicative getting some praise recently
09:58:40 <ReinH> +1
09:58:59 <ReinH> although even getopts can be serviceable
09:59:43 <Fuuzetsu> if it's something really simple, you might want to just DIY with getArgs and elem or something
09:59:58 <kqr> optparse-applicative looks nice
10:04:34 <sm> cmdargs is the most featureful
10:05:16 <klrr_> what's the appropriate type for this Plan (talking about edwardk 's machines library): "foo = do c <- await; liftIO $ print c" where c is a Char?
10:05:45 <edwardk> klrr_: i honestly can't remember the current public API :)
10:05:48 <edwardk> klrr_: hrmm
10:05:52 <klrr_> oh wait
10:05:57 <klrr_> it's machines 0.3
10:06:05 <klrr_> forgot to mention
10:06:11 <edwardk> 0.3 is broken
10:06:18 <edwardk> hence why it isn't released
10:06:34 <edwardk> i was an attempt to grossly simplify the API, but it didn't work in the end
10:06:40 <jle`> > repeat mempty
10:06:41 <klrr_> aa :s worked thoruhg this tutorial which required it https://github.com/alanz/machines-play/blob/master/Main.hs
10:06:42 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:06:43 <edwardk> so we backed up
10:07:08 <jle`> Fuuzetsu
10:07:17 <klrr_> in what way is it broken? is it abandonned?
10:07:37 <xplat> cmdargs is samsara.  getopts is pain.  optparse-applicative is love.  that is all.
10:08:01 <sm> xplat: what if you want subcommands
10:09:28 <xplat> sm: doesn't optparse-applicative have that through an Alternative instance or something?  or did i dream that?
10:09:39 <sm> I don't know, I'm curious
10:09:50 <supki> optparse-applicative supports subcommands
10:09:51 <Clint> i do subcommands with optparse-applicative all the time
10:10:04 <xplat> well there you go
10:10:06 <Clint> or rather i only do subcommands
10:10:08 <sm> great.. documented ?
10:10:38 <klrr_> edwardk: what are the advantages for machines vs pipes?
10:11:43 <edwardk> machines is still a work in progress, but the goal is to find a simpler API that is more compositional, but which avoids the cases where pipes/conduit can lead to asymptotic slowdowns in long running code that mixes composition and binding.
10:12:05 <edwardk> it isn't there yet, but it is something i've been chewing on a little at a time each time i have a data processing problem
10:12:30 <klrr_> okey, so currently pipes or conduits are to be prefered?
10:12:35 <supki> sm: yeah, readme has examples
10:13:12 <sm> supki: I'm not seeing it, could you point me a little closer ?
10:13:34 <sm> oh "A command can be used to specify a sub-parser to be used when a certain string is encountered in the command line." ? I see
10:13:40 <novochar> I want to use >>=
10:13:46 <edwardk> klrr_: i'd use pipes or conduit in production code today, yes, unless i really needed the benefits machines offers
10:13:54 <novochar> (\x -> 3) 2 -- produces 3 as a result
10:14:06 <novochar> (\x -> 3) 2 >>= ??
10:14:27 <novochar> isn't do syntax sugar for >>=?
10:15:15 <tac> > (\x -> 3) 2
10:15:16 <lambdabot>  3
10:15:31 <xplat> novochar: do { x <- a; b } is syntax sugar for a >>= (\x -> b)
10:15:39 * sm will give optparse-applicative a try next time
10:17:18 <sm> one thing it does not have is a short easy to type name. Can't have everything I guess
10:17:40 <leino> I just wanted to announce that I have come up with the perfect Haskell blog name
10:17:47 <novochar> in a do block, the arrow represents some form of an io computation? x <- someIOActionOn foo.txt
10:18:05 <klrr_> edwardk: so there are benefits?
10:18:17 <geekosaur> novochar, do is not specific to IO
10:18:56 <tac> novochar: It's more general than that. But if you're just beginning, you can lie to yourself and pretend results <- someIOFunction "runs" the IO action
10:19:10 <edwardk> Well, machines provides a more compositional model in many ways where you can ave a machine that takes multiple inputs and which can block on them in various ways, e.g. with Wye you can do non-deterministic blocking, which doesn't fit the pipes/conduit model.
10:19:25 <tac> That is, if someIOFunction has type `IO stuff`, then results has type `stuff`
10:19:28 <edwardk> but pipes/conduit are way more mature from a resource consumption/management perspective
10:19:51 <klrr_> okey, thanks!
10:21:39 <jle`> why do i need parentheses for type cosntraints
10:22:00 <jle`> when are the parentheses ever not redundant
10:22:03 <monochrom> not all of them, just somtimes
10:22:07 <jle`> (parentheses for multiple constraints)
10:22:15 <jle`> (Eq a, Num a) => a
10:22:25 <monochrom> I don't know. fork GHC and try your better syntax
10:22:28 <jle`> mk
10:22:33 <tac> jle`: Because Haskell
10:22:44 <jle`> i guesss....it looks like a tuple.
10:22:54 <tac> The same reason modules require "where" at the end :)
10:23:10 <jle`> that kind of makes sense though :|
10:23:12 <jle`> for consistency
10:23:20 <tac> It does kind of act like a tuple in a sense
10:23:27 <jle`> with class k a where...instance i a where...
10:24:07 <edwardk> jle: Foo a => a   works fine
10:24:31 <edwardk> jle: In many cases you can even curry them, Foo a => Bar b => a -> b  works in modern ghcs for most things
10:24:37 <monochrom> syntax design usually prefers uniformity over Huffman coding
10:25:04 <jle`> fair enough
10:25:11 <monochrom> but you're welcome to design syntax that does solely Huffman coding and see what happens
10:25:27 <jle`> i don't feel like Eq a, Num a => a is any less expressive/readable
10:25:38 <edwardk> jle, the issue is one of fixity: , binds with the wrong precedence to sit 'under' the left hand side of =>
10:25:42 <monochrom> and that's my answer to almost all "why" questions. do it your way, see what happens.
10:25:43 <jle`> ah
10:25:45 <Redz> is reading from MVar concurrent?
10:25:56 <jle`> yeah i guess i can understand that
10:28:15 <edwardk> consider     (Foo a, (Baz a, Quaffle a) => Quux a)        with your proposal the notation would want to be   (Foo a, Baz a, Quaffle a => Quux a) ;)
10:28:18 * hackagebot yesod-static-angular 0.1.0 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.0 (JohnLenz)
10:29:04 <edwardk> and we do sometimes need constraints in funny positions that look like that
10:29:10 <edwardk> :t conjoined
10:29:11 <lambdabot> Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
10:29:34 <rtpg> Seriously is there a reason why there's no show instance for functions inside ghci?
10:29:47 <Clint> how would you show them?
10:29:49 <edwardk> rtpg: what should it do?
10:30:14 * monochrom feels like applying his method again
10:30:18 <rtpg> well you could just do something like what a bunch of languages do : just say it's a function of a certain type
10:30:24 <monochrom> why don't you fork GHC and add that show instance?
10:30:42 <leino> rtpg: show is usually meant to represent the value it shows "fully", i.e. if you have the show of something you should be able to turn it back into the value (as far as I understand the convention)
10:30:49 <rtpg> I get why it's not in prelude, but when working in an interactive session ...
10:31:02 <monochrom> yes, so why don't you fork GHC and add that show instance?
10:31:04 <rtpg> leino, oh I guess that makes sense, I have heard similar things
10:31:16 <edwardk> rtpg: there are several somewhat viable alternatives, none of them are "correct". Given several bad options we as a rule simply don't supply one, leaving it open to you.
10:31:53 <edwardk> rtpg: some folks use instances that say "<function>" some use Data.Typeable and show the types. other folks use code to enumerate (small parts of) the domain  and show tabulations...
10:32:09 <edwardk> rtpg: whatever instance you choose cuts off perfectly valid scenarios for some users
10:32:16 <rtpg> yeah I guess I get that
10:32:20 <edwardk> so we don't choose one, leaving it open to you to do what you want
10:32:35 <rtpg> I didn't know that people were doing "interesting" things with show instances
10:32:36 <levi> The nice thing about instances is you can always supply your own if one doesn't exist. If one did exist, it would be very awkward, if possible at all, to use your own.
10:32:37 <edwardk> if we picked we'd be forcing you to never get that extra information wthut pain
10:34:08 <tac> Are "type family" and "data family" used as synonyms?
10:34:15 <edwardk> no
10:34:17 <monochrom> not really
10:34:19 <edwardk> they are distinct
10:34:45 <tac> Ah, so they are.
10:34:59 <edwardk> given a type family F a,    a ~ b entails F a ~ F b, but you can't go backwards. given a data family a ~ b entails F a ~ F b, but F a ~ F b also entails a ~ b
10:35:06 <monochrom> "type family" still says you have a type synonyms. "data family" still says you do not.
10:35:09 <Fuuzetsu> Why are changes like https://ghc.haskell.org/trac/ghc/changeset/4a8ffcf55c897851b534c700951a0b5bdd43eb97/base effective? We save having to pass ‘k’ and ‘z‘ around but I would have imagined GHC would already do this as an optimisation…
10:35:54 <tac> edwardk: Ah, so data families are... injective type families?
10:36:04 <edwardk> Fuuzetsu: because what happens is by inlining foldr2, the particular function k passed to it is visible to 'go', which can now use strictness information about that function
10:36:16 <monochrom> and the consequence of type synonyms is precisely that non-injectivity. TS Int and TS Char can be both synonyms for Bool
10:36:23 <edwardk> tac: yes, which is then enforced by the fact that you have to put a newtype/data type in
10:36:52 <edwardk> Fuuzetsu: without it, ghc doesn't 'pull the choice of k' out of the loop, as it isn't smart enough to see that it remains constant
10:37:05 <Fuuzetsu> Right.
10:37:34 <edwardk> in general if you have a constant argument and ghc may get benefit from strictness analysis on it, factoring it out into that go style is often a win.
10:37:34 <chirpsalot> Hmmmm. So somebody was showing me how in Common Lisp they can make map act kind of like zipWith, but they can do it across more than two lists... So, (map 'list #'+ '(1 2 3) '(2 4 8) '(7 8 9) '(10 12 42)) = '(20 26 62)
10:37:57 <chirpsalot> I was wondering what might be the best way to do this in Haskell... I came up with: foldl (zipWith (+)) [0,0,0] [[1,2,3], [2,4,8], [7,8,9], [10,12,42]]
10:38:15 <chirpsalot> But I'm new, so I am sure there is a much better way.
10:40:02 <chirpsalot> Actually, maybe that's reasonable!
10:40:18 <edwardk> chirpsalot: we tend to be more explicit about folds than the scheme/lisp community by choosing binary operators in general.
10:40:59 <chirpsalot> edwardk: yeah, and the initial accumulator value is necessary.
10:41:22 <edwardk> we have zipWith3, zipWith5, etc. for heterogenous list splicing like that, but foldl1 (zipWith (+)) or foldr1 (zipWith (+)) is a pretty haskelly way to do it
10:41:44 <companion_cube> why isn't it generalized for monoids?
10:41:50 <kuribas> > foldl1 (zipWith (+)) [[1,2,3], [2,4,8], [7,8,9], [10,12,42]]
10:41:52 <lambdabot>  [20,26,62]
10:42:02 <edwardk> why isn't what generalized?
10:42:23 <companion_cube> hmm, wait, does it fail on an empty list?
10:42:27 <companion_cube> > foldl1
10:42:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
10:42:30 <lambdabot>    arising from a use of `M428787127240432907411577.show_M4287871272404329074...
10:42:30 <lambdabot>  The type variable `a0' is ambiguous
10:42:30 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:42:30 <lambdabot>  Note: there are several potential instances:
10:42:34 <companion_cube> :t foldl1
10:42:36 <lambdabot> (a -> a -> a) -> [a] -> a
10:42:38 <chirpsalot> edwardk: awesome :). I'm used to coming up with solutions and then find that somebody has a much more concise and clean solution. Guess this isn't going to get much better :). Thanks!
10:42:46 <kuribas> companion_cube: it does
10:42:56 <monochrom> foldl1 wants non-empty list. but you can generalize foldl to all monoids. you do it.
10:43:01 <kuribas> > foldl1 (+) []
10:43:02 <companion_cube> that should be  (Monoid a) => [a] -> a, shouldn't it?
10:43:03 <lambdabot>  *Exception: Prelude.foldl1: empty list
10:43:10 <edwardk> :t foldMap
10:43:11 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:43:18 <companion_cube> nice
10:43:45 <edwardk> for the zipWith (+) case you can always use the infinite list of 0's as a base case
10:43:53 <monochrom> you can also generalize foldl1 to all monoids-who-don't-pick-a-default-mempty.
10:44:02 <edwardk> :t foldr (zipWith (+)) [0..]
10:44:02 <haasn> :t mconcat
10:44:03 <lambdabot> Monoid a => [a] -> a
10:44:03 <lambdabot> (Enum b, Num b) => [[b]] -> [b]
10:44:18 <edwardk> er
10:44:21 <edwardk> :t foldr (zipWith (+)) [0,0..]
10:44:22 <lambdabot> (Enum b, Num b) => [[b]] -> [b]
10:44:36 <edwardk> :t foldr (zipWith (+)) (repeat 0)
10:44:36 <lambdabot> Num b => [[b]] -> [b]
10:44:38 <edwardk> better
10:47:50 <tac> Reading through this page, I can't get over the feeling that Data Families are just a really complicated way to do something very simple with dependent types :<
10:48:17 <monochrom> I don't find it complicated
10:48:55 <monochrom> I am also not unconvinced that dependent typing does it
10:49:20 <monochrom> err, s/un//
10:49:45 --- mode: ChanServ set +o shachaf
10:49:54 <tac> I guess *I* am the one who is not un-convinced :)
10:50:00 --- mode: ChanServ set +o geekosaur
10:50:09 <tac> I'm sure dependent types can do the job better, but I don't have a constructive proof of that.
10:50:21 <tac> though, the double negative ;)
10:50:38 <monochrom> dependent typing just says "map value to type". it doesn't say "map type to type". is that right?
10:50:44 --- mode: shachaf set +b boemekeld!*@*$##fixyourconnection
10:50:50 --- mode: shachaf set -o shachaf
10:51:01 <geekosaur> beat me to it, although I think it's ##fix_your_connection?
10:51:03 --- mode: geekosaur set -o geekosaur
10:51:21 <shachaf> I tried #fixyourconnection first and it told there was no such channel.
10:51:30 <shachaf> So I'll take success as "there is such a channel".
10:51:43 <shachaf> (Or is there a special significance to the one with _s?)
10:51:47 <ion> Heh, those bans are causing more noise than the connection problems due to the “smart filter”.
10:51:50 <tac> Type constructors become functions no different from any other. But I guess I should spend less time complaining and more time just learning it as I'm confronted with it.
10:51:51 <geekosaur> I don't know
10:51:56 <shachaf> Oh, hmm.
10:52:24 <mornfall> ion: only if you have a smart filter I suppose
10:52:31 <ion> mornfall: sure
10:52:32 <shachaf> I guess so.
10:52:33 --- mode: ChanServ set +o shachaf
10:52:36 <novochar> What are a few things you can do in Haskell that you can't do in other languages, due to purity and oter things which are pretty unique about the language?
10:52:59 --- mode: shachaf set -b+b-o boemekeld!*@*$##fixyourconnection boemekeld!*@*$##fix_your_connection shachaf
10:53:01 <mornfall> that's a weird question :-)
10:53:13 <novochar> > let x = [1..] -- what can you do with this, this doesn't seem like a mind blowing example
10:53:14 <lambdabot>  not an expression: `let x = [1..] -- what can you do with this, this doesn't...
10:53:32 <Taneb> > let x = [1..] in sum $ takeWhile (< 1000) x
10:53:33 <lambdabot>  499500
10:54:15 <tac> novochar: In-language parsers, software transactional memory, type-safe distributed computing are three pretty neat uses
10:54:30 <levi> novochar: Lazy evaluation lets you program in a more compositional style, and purity makes laziness a reasonable implementation strategy.
10:54:45 <tac> There's also the case study that the GHC compiler is 20+ years old and still considered maintainable, with people making sweeping changes to it every few years.
10:56:09 <spindles> is (::) a actual function when you declare type signature?
10:56:17 <levi> See Hughes, "Why Functional Programming Matters": http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
10:56:37 <monochrom> novochar: I put an immutable Data.Set into an MVar. many threads can read it and write to it. there is neither race condition nor inefficiency.
10:56:42 <tac> spindles: It begins with a : so it's a constructor
10:56:48 <tac> So yes, it's a function.
10:56:59 <geekosaur> o.O
10:57:04 <geekosaur> :: is syntax
10:57:21 <monochrom> I don't say you "can't" do the same elsewhere. but it's highly discouraged elsewhere.
10:57:37 <augur> conal: you have to make the font bigger for your code in your latest blog post
10:57:39 <haasn> So are we ever going to get a Num instance for WrappedApplicative or something
10:57:45 <augur> its miniscule right right, almost unreadably so
10:58:06 <spindles> how does (::) work exactly?
10:58:28 <augur> oh. conal: nevermind. its not a recent blog post. its just recently posted to reddit. :X
10:58:43 <spindles> :t (::)
10:58:44 <lambdabot> parse error on input `::'
10:58:45 <RichyB> monochrom, partly that's a mindset thing; once you have immutable data and garbage collection, CAS on a pointer is practically a high-level operaton. :)
10:58:47 <geekosaur> it is syntax, it tells the compiler the expected type for an expression
10:58:56 <geekosaur> it is not a function, notwithstanding what tac told you
10:59:02 <geekosaur> neither is it a constructor
10:59:19 <tac> @type (::)
10:59:20 <lambdabot> parse error on input `::'
10:59:23 <tac> oops
10:59:35 <tac> I've been spending too much time with Idris I think
10:59:38 <tac> @type (:)
10:59:39 <lambdabot> a -> [a] -> [a]
11:00:04 <novochar> levi: that paper talks about lazy evaluation and higher order functions, it isn't specific to Haskell
11:00:05 <tac> No. :: is magical. Not a function.
11:00:11 <novochar> Erlang, e.g., has these
11:00:21 <haasn> :t ala ZipList (\f -> foldr (liftA2 (+) . f) (pure 0))
11:00:23 <lambdabot> Num a => [[a]] -> [a]
11:01:02 <levi> novochar: How many other languages do you know with lazy evaluation and higher-order functions? Haskell is definitely the primary example of languages with those traits.
11:01:38 <companion_cube> lazy evaluation as an opt-in is not so rare
11:01:43 <companion_cube> as a default, much more so
11:01:52 <novochar> levi: erlang has them
11:01:59 <monochrom> at the lexical level, "::" is a reserved word, therefore not under the rule of "starts with :"
11:02:25 <novochar> erlang's been around longer and is generally seen as a more industrial strength language for networking
11:02:28 <levi> novochar: But not in the sense that Hughes argues.
11:02:53 <levi> Read the paper, and tell me if you can think of a current language besides Haskell it applies to.
11:02:57 <monochrom> I would not go out of my way to find what haskell can do and other languages absolutely cannot
11:03:11 <novochar> levi: does it apply to haskell because of it's purity?
11:03:14 <novochar> its*
11:03:36 <monochrom> in the particular case of haskell vs erlang, I would simply ask "where is erlang's type system?" and that should be the end of the story.
11:03:56 <companion_cube> what about ML then? higher order functions and optional lazyness
11:03:58 <levi> Just the *ability* to do lazy evaluation is not sufficient. It must be pervasive in the language in order to enable the compositional style that Haskell encourages.
11:04:26 <levi> And for that to be the case, the language must also be pure, or else reasoning about the order of side-effects becomes very problematic.
11:05:01 <tac> Also, something Haskell has that Yer Average Language doesn't have that is underappreciated: sum types.
11:05:17 <levi> There's a little blog discussion between Robert Harper and Lennart Augustsson about this.
11:05:17 <companion_cube> so does ML
11:05:18 <companion_cube> :D
11:05:21 <guesting> So...in a where clause, should I have a "function" or a "variable" (where it takes no arguments). That is, if I call the function from the where clause twice on the SAME input, will it calculate the result twice or is the laziness with garbage collection smart enough to just return it?
11:05:21 <tac> Just being able to pattern match on alternatives, rather than constructing your own if statements, is a very convenient way to do things.
11:05:24 <platz> lots of languages allow lazy/streaming data (through yield, etc..), though which can provide some level of decoupling as well
11:06:43 <levi> Wherin Harper, who is usually pretty down on Haskell, admits he is occasionally jealous of the compositional style and notes that strict-by-default pretty much forces ML programmers to write explicitly recursive programs far more often than Haskellers do.
11:06:49 <guesting> like: in a where clause I have "sum' xs = foldl' (+) 0", in the actual function in I say "sum [1..10]" and again in another place in that same function "sum [1..10]", will it calculate it twice?
11:07:14 <defanor> i wrote my first parser in haskell and with parsec, and it'd be nice if somebody will point on bad style, redundant code, etc. now it just returns [[Char]], but going to add types next: http://paste.uberspace.net/irc-parser.hs.html
11:07:16 <guesting> Or should I have "sumResult = foldl' (+) 0 [1..10]" and call sumResult twice in the function?
11:07:43 <levi> guesting: Yes. If you want something to evaluate only once, bind it to a variable.
11:07:54 <dhrosa> < foldl1 (.) [(*2), (+1)] $ 0
11:08:00 <dhrosa> > foldl1 (.) [(*2), (+1)] $ 0
11:08:01 <lambdabot>  2
11:08:17 <levi> Haskell doesn't look for similar patterns of code and automatically merge them if they happen to calculate the same thing.
11:08:39 <guesting> levi: Darn. So I would do sumResult instead of sum'?
11:08:52 <guesting> like, that notation would be "bound"?
11:08:59 <Heffalump> levi: where did he admit that?
11:09:32 <levi> The discussion can be found: http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/ and http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
11:09:36 <Heffalump> ta
11:10:39 <levi> guesting: sum is already defined for you, but yes, you'd want something like: let sumResult = sum [1..10] in <expression that uses sumResult twice>
11:10:57 <xplat> anyone here know shake well enough to write an example shake script that compiles "*.c" and "*.cc" to "*.o" (not "*.c.o" and "*.cc.o")?
11:11:03 <ReinH> dhrosa: foldr (.) id
11:11:14 <ReinH> dhrosa: is the endofunction monoid
11:11:21 <guesting> levi: Which is the same as <expression that uses sumResult twice> where sumResult = sum[1..10]
11:11:27 <ReinH> endomorphism monoid
11:11:30 <guesting> correct?
11:11:31 <dhrosa> ReinH: I was checking that the functions composed  in the order I expected
11:11:31 <xplat> i've read in the changelog that that is now possible
11:11:45 <ReinH> dhrosa: ah
11:11:53 <haasn> edwardk: is it just me or are _Unwrapping and _Wrapping backwards?
11:12:06 <haasn> > 5 ^. _Unwrapping Sum -- huh?
11:12:07 <lambdabot>  Not in scope: `_Unwrapping'
11:12:07 <lambdabot>  Perhaps you meant one of these:
11:12:07 <lambdabot>    `unwrapping' (imported from Control.Lens),
11:12:07 <lambdabot>    `unwrappings' (imported from Control.Lens),
11:12:07 <lambdabot>    `wrapping' (imported from Control.Lens)
11:12:18 <haasn> (returns Sum 5)
11:12:44 <xplat> haasn: _Wrapping should be like _Left, not _1
11:13:07 <ReinH> dhrosa: foldl and foldr won't change the order of composition
11:13:23 <levi> guesting: let and where bindings are mostly the same, but see: http://www.haskell.org/haskellwiki/Let_vs._Where
11:13:25 <ReinH> dhrosa: and since composition is associative, it won't change the behavior either
11:13:31 <xplat> haasn: since it's a fake constructor, not a fake accessor
11:13:44 <haasn> xplat: hmm, I guess it makes sense since you can turn it around with ‘re’ to get the wrapped version
11:13:45 <dhrosa> I know, I was making sure foldl/r (.) composed last-to-first
11:13:49 <ReinH> either way it's ((*2) . (+1)) 0
11:13:52 <haasn> _Unwrapping still really throws me off
11:14:34 <guesting> levi: Thank you! I got some rewriting to do to speed my programs up...
11:15:24 <edwardk> > _Wrapping Sum # 2
11:15:25 <lambdabot>  Not in scope: `_Wrapping'
11:15:25 <lambdabot>  Perhaps you meant `wrapping' (imported from Control.Lens)
11:15:54 <edwardk> the inversion is because of how 'backwards' all prisms/isos are
11:16:57 <xplat> > _Left . _Right # 2
11:16:59 <lambdabot>  Left (Right 2)
11:18:05 <xplat> > Left (Right 2) ^._Left . _Right
11:18:06 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
11:18:06 <lambdabot>    arising from a use of `e_12'
11:18:06 <lambdabot>  The type variable `a0' is ambiguous
11:18:06 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:18:06 <lambdabot>  Note: there are several potential instances:
11:18:56 <xplat> > Left (Right "hi") ^? _Left . _Right
11:18:58 <lambdabot>  Just "hi"
11:19:21 <xplat> er, double fix, but whatever
11:40:41 <tpsinnem> hey -- is there a name for a sort of 'associativity by proxy' where you'd have 1) '(*) :: Foo -> Foo -> Foo', 2) 'behave :: Foo -> Bar' and knowledge of 3) 'behave ((a * b) * c) = behave (a * (b * c))'?
11:40:58 <tpsinnem> i'm pondering that such a thing might couple nicely with 4) 'relax :: Bar -> Foo' and knowledge of 5) behave . relax = id
11:49:36 <tac> In a quasiquotes, should I parse the general syntax as something like [stuff| content goes in between the pipes |optional stuff]?
11:51:11 <Redz> is there a way to safely quit getChanContents ? it seems, that the only way to break out of it is to kill the thread.
11:51:54 <supki> tac: [name|contents|]
11:52:02 <tac> ah
11:52:03 <tac> thanks
11:52:13 <supki> name :: QuasiQuoter
11:52:33 <tac> thanks++
11:55:13 <c_wraith> Redz: well, interrupting the thread will always work, and needn't kill it.  You can always catch the interruption.
11:55:52 <c_wraith> Redz: but more fundamentally, that's not really a case getChanContents was designed for.  It was designed for the case of "run forever, handling whatever's written"
11:56:52 <c_wraith> Redz: you can always add in-band signalling, though.  Like, instead of a Chan a, use a Chan (Maybe a) that terminates itself when it hits Nothing
11:57:13 <c_wraith> Redz: err, the reading process terminates the loop when it hits Nothing, that is
11:57:18 <Redz> yes. but sometimes, the program quits faster than the chan need to finish, which is my problem.
11:58:00 <Redz> i actually working on an alternative. i hoped, someone written already one.
11:58:11 <Redz> *work
11:59:52 <c_wraith> Redz: It probably isn't in a library, because it's both easy to implement and has hundreds of reasonable variations.
12:00:18 <verement> edwardk: thanks for chiming in on #8695, though I have trouble following you once you get to (x `quot` -1) in Z mod 2^n
12:00:28 <verement> edwardk: would you mind expounding?
12:01:46 <edwardk> verement: if we say (q,r) = quotRem minBound (-1) then we know a few things about q and r.
12:02:39 <Redz> are you sure? i can imagine that a quitable and checkable for quit  chan is used more often.
12:04:46 <edwardk> (q,r) = a `quotRem` b means that a = q*b + r and r = 0 or f(r) < f(-1) holds. let's say f = abs . toInteger
12:06:11 <verement> ok
12:06:30 <edwardk> then you get pigeon holed into one possibe definiton (q,r) = minBound `quotRem` (-1)  means minBound = -q + r, abs (-1) = 1, so to be below that you need f(r) = 0, so r = 0, ten minBound = -q   => q = minBound
12:06:45 <edwardk> er then
12:07:07 <edwardk> so the only definition consistent with the definition of a Euclidean domain is the one pushed forward in the proposal
12:08:09 <edwardk> and it passes all the necessary laws to comply with both the euclidean domain definition and the fact that 'all arithmetic is performed modulo 2^n without referencing 2s complement
12:08:30 * hackagebot htsn 0.0.7 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.7 (MichaelOrlitzky)
12:08:54 <verement> how do you get from minBound = -q to q = minBound?
12:10:56 <ilmig> is there a way to get a more helpful error message from read? I'm trying to read a very long string with many new lines and somewhere is a syntax error and read won't even report the line or charactor where the parsing failed
12:11:23 <quchen> ilmig: No. Use a parser, Read is usually pretty hacky.
12:11:37 <quchen> Also don't use read instead of readEither.
12:11:49 <ilmig> quchen: hm ok, I find parsec a bit intimidating for a beginner...
12:12:01 <ilmig> but I think I don't have any choice then...
12:12:09 <bitemyapp> ilmig: parsec is really nice and pretty easy to use.
12:12:20 <bitemyapp> ilmig: did you see that teensy-tiny JSON parser in Parsec?
12:12:35 <c_wraith> Redz: http://lpaste.net/99180  *shrug*.  That's about how much work it is.
12:12:37 <bitemyapp> ilmig: the use of read/show was inadvisable, but it's a decent Parsec example: https://github.com/ajg/yocto/blob/master/Text/JSON/Yocto.hs
12:14:02 <ilmig> bitemyapp: thanks, I will have a look at this
12:14:51 <c_wraith> Hmm.  I wish there was a better version of map fromJust . takeWhile isJust in Data.Maybe
12:14:59 <tpsinnem> hey -- is there a name for a sort of 'associativity by proxy' where you'd have 1) '(*) :: Foo -> Foo -> Foo', 2) 'behave :: Foo -> Bar' and knowledge of 3) 'behave ((a * b) * c) = behave (a * (b * c))'?
12:15:03 <tpsinnem> i'm pondering that such a thing might couple nicely with 4) 'relax :: Bar -> Foo' and knowledge of 5) behave . relax = id
12:15:38 <quchen> c_wraith: map fromJust ⇒ catMaybes
12:16:02 <c_wraith> quchen: Eh.  Not really.  catMaybes means something else.
12:16:24 <quchen> It does?
12:16:33 <c_wraith> quchen: I mean, yes, it will do the same thing when every element of the list is Just
12:16:45 <quchen> Yes, which is what you have.
12:16:47 <c_wraith> quchen: but it also means something when the list isn't all Just values
12:17:09 <c_wraith> quchen: so it means something different.  it's total
12:18:49 <quchen> It's the same as map fromJust except it's total.
12:18:51 <c_wraith> Redz: admittedly, that sample is broken if you want multiple readers from each chan.  If you want that, you need to do more to make reading and closing interact properly. It's not hard, it's just a bit more code.
12:19:24 <c_wraith> quchen: it hides how terrible the hack is.  If I write hacky code, I'd much prefer it show that it's hacky.
12:20:30 <quchen> In that case stick with "map fromJust . takeWhile isJust", it's very suitable for looking hacky.
12:20:33 <Redz> well, i'm happy that my code isn't far from your code. so i haven't much wrong.
12:20:57 <c_wraith> Redz: if you want multiple readers, though, it does need significant change.  Want me to demo it on my code?
12:21:29 <Redz> no. i'll get it.
12:21:42 <enthropy> @check \xs -> catMaybes (takeWhile isJust xs) == (map fromJust (takeWhile isJust xs) :: [Int])
12:21:44 <lambdabot>  +++ OK, passed 100 tests.
12:22:22 <c_wraith> @hoogle unsafeInterleaveIO
12:22:23 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:24:27 <enthropy> @check \xs -> catMaybes (takeWhile isJust xs) == unfoldr (\a -> do Just x:xs <- Just a; return (x,xs)) xs
12:24:29 <lambdabot>  +++ OK, passed 100 tests.
12:24:44 <c_wraith> I always forget unfoldr
12:25:07 <enthropy> well the catMaybes/map fromJust is going to be more familiar
12:25:24 <bitemyapp> c_wraith: e'rybody forgets the anamorphism.
12:25:24 <enthropy> or just write out the recursion by hand... it's not so bad
12:26:06 <thetallguy> Is there a way to get ghc to list what flags changed when it forces recompilation instead of just [flags changed]?
12:26:29 <c_wraith> Yeah, writing it out by hand is what I'd do if I was doing it right.  But I really would want it to be in Data.Maybe
12:28:21 <scriptor> hi everyone, sorry if this is a bit of a dumb question, but does anyone have a link handy explaining the difference between a difference list and lazy lists?
12:28:56 <c_wraith> scriptor: how much time do you have? :)
12:29:08 <scriptor> oof, good question
12:29:28 <c_wraith> scriptor: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/ is a very in-depth description of "difference lists"
12:29:45 <Fuuzetsu> I never know how tightly :: binds… for example, ‘x <- foo :: Stuff’, the signature belongs to foo. What about in cases like x `someInfix` y :: Stuff… From experience I know it's going to be the whole expression, but are there other cases except do notation where that isn't the case?
12:30:04 <scriptor> ah, thanks, I was going to try to tackle "functional representation of data structures with a hole" but this should be a better intro
12:30:13 <c_wraith> Fuuzetsu: the only weird interaction is with lambdas.  Otherwise, it's "the entire preceding expression"
12:31:32 <c_wraith> Let's see if I can remember the craziness...
12:33:32 <rawtass> i am returning a data structure in a monad: Data.Binary.Get Foo, until isEmtpy is true. Then there is nothing to more to return. How should I handle this?
12:33:33 * hackagebot lens 3.10.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.2 (EdwardKmett)
12:36:32 <Hoksbergen> Does anyone happen to know the etymology behind the 'Functor' typeclass?
12:36:38 <Hoksbergen> (Got curious.)
12:37:23 <c_wraith> :t \f -> map $ \x -> f 0 x :: Int :: [Int] -> [Int] :: (Int -> Int -> Int) -> [Int] -> [Int] -- Fuuzetsu
12:37:24 <lambdabot> (Int -> Int -> Int) -> [Int] -> [Int]
12:38:10 <c_wraith> Hoksbergen: it's from category theory
12:38:25 * Hoksbergen looks it up.
12:38:37 <c_wraith> Hoksbergen: haskell's Functor is a categorical endofunctor with from haskell types to haskell types
12:38:40 <Hoksbergen> c_wraith: Ah, I see. Awesome, thanks!
12:39:16 <c_wraith> -with
12:40:14 <Fuuzetsu> c_wraith: I see
12:40:20 <c_wraith> Fuuzetsu: I hope that made it clear as mud. :)
12:40:44 <Fuuzetsu> yup; now all you need is to throw some type signatures for the arguments for no apparent reason and we're set
12:41:30 <Cale> scriptor: The main difference has to do with the complexity of concatenation
12:43:08 <lllllllllllll> are there use cases where fromjust is ok to use?
12:43:27 <Clint> according to which religion?
12:44:03 <Cale> scriptor: xs ++ ys takes O(length xs) steps to fully reduce out all the occurrences of (++), so in a case where one is accumulating new short lists which need to be added to the end (or might, depending on the input), you might end up with an expensive algorithm
12:44:05 <c_wraith> lllllllllllll: sure. It's just nice to not use it, even when it's ok.
12:44:32 <c_wraith> lllllllllllll: because using it says "partial function here! beware!"
12:44:43 <c_wraith> lllllllllllll: it says that to people reading the code, that is.
12:45:18 <Cale> scriptor: So the standard trick is to replace lists of type [a] with functions [a] -> [a] that add elements to the beginning of a given list, and then (++) becomes (.) (which is constant time), and [] becomes id, and [x] becomes (x:)
12:45:26 <fizbin> Can you statically prove that you will only pass (Just x) into it?
12:45:43 <Cale> scriptor: and then at the end, you can just apply the resulting function to an empty list to recover the usual result
12:45:48 <lllllllllllll> c_wraith, ok thx
12:46:36 <Cale> lllllllllllll: One thing which certainly indicates a problem is if you're using isJust and then fromJust. You should just pattern match in that case.
12:47:08 <fizbin> @type maybe
12:47:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:47:24 <c_wraith> hmm...
12:47:29 <fizbin> Cale: Or possibly use "maybe"
12:47:55 <Cale> Yeah. I often find that uses of maybe end up being less clear than just using case, but sometimes it can be nice.
12:48:10 <c_wraith> :t foldr (\a r -> fromMaybe [] (:r)) []
12:48:10 <lambdabot>     Couldn't match expected type `Maybe [a0]'
12:48:11 <lambdabot>                 with actual type `a0 -> [a0]'
12:48:11 <lambdabot>     In the second argument of `fromMaybe', namely `(: r)'
12:48:28 <c_wraith> heh, oops
12:48:28 <lllllllllllll> Cale, i have a library function that takes a Text but the Datatype that contains it has Maybe Text and the function makes no sense if no Text is given so prefer erroring out if it is not given
12:48:33 <c_wraith> :t foldr (\a r -> fromMaybe [] (:r) a) []
12:48:34 <lambdabot>     Couldn't match expected type `a0 -> [a2]' with actual type `[a1]'
12:48:34 <lambdabot>     In the first argument of `fromMaybe', namely `[]'
12:48:34 <lambdabot>     In the expression: fromMaybe [] (: r) a
12:49:06 <fizbin> lllllllllllll: Perhaps your function needs a different return type then.
12:49:15 <c_wraith> oh, did I get the args to fromMaybe backwards?
12:49:17 <c_wraith> :t fromMaybe
12:49:18 <lambdabot> a -> Maybe a -> a
12:49:28 <lllllllllllll> fizbin, it is from an external library
12:49:32 <c_wraith> oh..  I just wanted maybe
12:49:49 <c_wraith> :t foldr (\a r -> maybe [] (:r) a) []
12:49:50 <lambdabot> [Maybe a] -> [a]
12:49:59 <c_wraith> Yeah, that's what I want!
12:50:31 <fizbin> @type justs
12:50:32 <lambdabot> Not in scope: `justs'
12:50:33 <xedir> Heyo guys
12:50:35 <Cale> lllllllllllll: It can be nice to explicitly case on the thing and use 'error' in that case, just in case the thing ever happens to be Nothing.
12:50:48 <c_wraith> fizbin: were you looking for catMaybes?
12:50:59 <fizbin> Yeah.
12:51:04 <bennofs> @let import Safe
12:51:06 <lambdabot>  Defined.
12:51:11 <c_wraith> fizbin: it has the same type, but it's not the same thing
12:51:17 <bennofs> @ty fromJustNote
12:51:18 <lambdabot> String -> Maybe a -> a
12:51:43 <Cale> bennofs: nice
12:52:03 <Redz> awww. i hate it. i write code and after hours i realize that this what i do is stupid.
12:52:16 <xedir> is there a "what you see is what you get" thing for a haskell gui like there are for html?
12:52:53 <sm> :)
12:53:06 <fizbin> c_wraith: Oh. So you want the result list to stop at the first Nothing.
12:53:10 <c_wraith> fizbin: yep
12:53:31 <xedir> Redz: lucky you, i know it before i code and i think its stupid as well :D
12:53:35 <lllllllllllll> Cale, ok thx
12:54:06 <sm> xedir: there's a web-based one at http://fpcomplete.com or one that you add to Eclipse (EclipseFP)
12:54:07 <fizbin> Redz: Only hours? Lucky...
12:54:34 <c_wraith> enthropy: I'm very amused that the problem you solved with unfoldr, I solved with...  foldr
12:54:38 <sm> did I get your question right ?
12:54:54 <xedir> i'm using fpcomplete to code but after i did my first .exe thingy programm today i would like to build some gui for it
12:55:11 <sm> aha
12:55:13 <Redz> :p
12:55:22 <sm> I think the short answer is no
12:55:28 <xedir> i know it from java and html that you can just create a button and stuff in netbeans
12:56:09 <sm> you can do GTK apps in haskell, and there's some wysiwyg layout tool, but I don't think you can do GTK with fpcomplete (could be wrong)
12:56:10 <xedir> is there a good guide/book that covers just the basics?
12:56:43 <sm> many people make browser-based guis instead, it's easier
12:57:01 <xedir> what i've done today is not the exciting just taking 5 inputs and printing out strings and a list, but i would like to make a gui for it :P
12:58:10 <sm> xedir: do you want to just run it yourself, or have other people run it ? just windows, or other platforms too ?
12:58:47 <xedir> uhm, just me and my friends, most likely windows - guess i'm the only one who has a macBook as well :P
12:59:55 <sm> I'm thinking http://hackage.haskell.org/package/threepenny-gui is a good option here, maybe others will chime in
13:00:20 <sm> example: http://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html'
13:01:38 <xedir> cool, i will have a loot ;)
13:01:42 <xedir> look*
13:01:57 <sm> there ought to be an easier way to add a very simple gui, but I can't think of one
13:02:18 <xedir> no pain no gain^^
13:02:53 <sm> I'm opposed to that :)
13:03:18 <xedir> :P
13:04:00 <zett_zelett> I’m trying to get leftmost-outermost reduction.
13:04:08 <zett_zelett> Can anyone give me feedback on this? http://lpaste.net/5036748877194067968
13:04:34 <agibiansky> Does anyone know whether the MissingPy library actually works with GHC 7.6?
13:04:56 <agibiansky> I am trying to compile it and it complains about lack of Control.OldException, and it looks like there's a PR on Github that's been untouched for a year...
13:05:30 <robertberry> Hello ... sorry if this is a stupid question. Is there a standard data type I should be using to work with dates / times in Haskell?
13:05:31 <markovirc_> Hello robertberry
13:05:36 <robertberry> Hey :)
13:05:37 <markovirc_> Hello robertberry
13:07:13 <geekosaur> hrm, that thing is a bot
13:09:23 <verement> robertberry: I've found UTCTime from Data.Time useful
13:09:39 <robertberry> Cheers, I'll look at that
13:10:55 <bernalex> http://lpaste.net/3371542214894157824 -- while I could make this *a bit* nicer using wheres and stuff, do any of you have suggestions for making it *drastically* prettier?
13:11:48 <c_wraith> bernalex: does that even typecheck?
13:11:56 <bernalex> c_wraith: what do you mean? it works great
13:12:02 <c_wraith> bernalex: oh, I see.  the unlines is really being abused
13:12:28 <bernalex> well, I could use concat
13:12:56 <bernalex> that makes more sense in the context anyway, so I'll do that
13:13:02 <c_wraith> Neither makes particularly good sense as a way to handle multiple inputs
13:13:44 <bernalex> oh, I just realised I need to rewrite it
13:13:58 <bernalex> BRB lol
13:14:09 <c_wraith> bernalex: overall, though, I think you'd get a lot of improvement from let statements inside the do block
13:14:40 <dibblego> putStrLn on the outside of the case
13:14:42 <bernalex> I tried that, but I didn't think it was *that* much better. I thought maybe you guys had some ideas for changing the logic more radically. but I have to rewrite it anyway, so... :-)
13:15:35 * sm adds http://hackage.haskell.org/package/uni-htk to the list of simple gui options
13:16:25 <robertberry> I'm trying to write a Haskell API client for the Guardian's content API. Does anyone know any Haskell API clients I could look at for inspiration?
13:16:58 <dhrosa> thanks so much whoever helped explain the (r->) monad, it's extremely useful for my current project
13:17:17 <maxiepoo> edwardk, hey, why does the right functor in Data.Functor.Adjunction need to be Representable isntead of just Functor: http://hackage.haskell.org/package/adjunctions-4.0.1/docs/Data-Functor-Adjunction.html?'
13:18:07 <c_wraith> > let dropRWhile p = foldr (\c r -> if p c && null r then [] else c : r) [] in dropRWhile (/= '/') "/foo/bar/baz" -- bernalex: this may not be any shorter, but it's actually much better than the double-reverse approach
13:18:09 <lambdabot>  "/foo/bar/"
13:18:19 <maxiepoo> or is it just because every right adjoint in Hask is Representable for some reason?
13:18:22 <edwardk> maxiepoo: because all the instances are isomorphic to a function, so they all better be. ;)
13:18:46 <edwardk> maxiepoo: i could require MonadReader, Monad, Applicative, and a bunch of other things
13:19:39 <edwardk> provably given F -| G :: Hask -> Hask, G is isomorphic to (->) x for some x.
13:20:05 <maxiepoo> hmm why
13:20:39 <maxiepoo> and is that true for a more general class of Categories than Hask?
13:22:04 <edwardk> it arises because if for any F -| G :: C -> Set    you can choose the singleton set and send it through the unit of the adjunction. and get a representation for G
13:22:20 <edwardk> it works for any adjunction _to_ Hask or Set
13:23:07 <edwardk> If C is a category with small powers G :: C -> Set is representable iff it is a right adjoint
13:23:20 <edwardk> er
13:23:24 <edwardk> small copowers
13:24:31 <edwardk> uniqueness is trickier to show, one way uses the role of the singleton set, the other uses small copowers
13:24:36 <maxiepoo> oh this is what tabulateAdjunction and indexAdjunction are for?
13:24:41 <edwardk> yeah
13:24:48 <maxiepoo> icic
13:25:05 <edwardk> they give you a viable definition for the representable i demand
13:25:16 <edwardk> the left adjoint could also have a pretty strong statement made
13:25:25 <edwardk> as it is isomorphic to (,) x  for some x as well
13:25:40 <maxiepoo> ok, that's what I was going to ask next
13:25:48 <edwardk> so you can always lens in to get its value out, and get a ton of properties for free
13:26:07 <maxiepoo> is that Corepresentability?
13:26:16 <edwardk> no
13:27:01 <edwardk> a corepresentable functor is a Functor isomorphic to (x ->)     a representable contravariant functor is isomorphic to (-> x)
13:27:09 <maxiepoo> ah
13:27:44 <maxiepoo> wait is that backwards
13:28:04 <edwardk> Representable is commonly used to talk about contravariant functors classically
13:28:05 <maxiepoo> I thought representable was G isomorphic to (x ->)
13:28:25 <edwardk> but the term is often used interchangeably when it is unambiguous
13:28:38 <edwardk> Data.Functor.Rep uses it in that interchangeable sense
13:28:39 * hackagebot HaRe 0.7.1.2 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.2 (AlanZimmerman)
13:28:46 <edwardk> but should be talking about Corepresentable
13:29:41 <maxiepoo> so is there a name for the corresponding property on the left functor? isomorphic to ((,) a) for some a?
13:30:28 <jrmithdobbs> edwardk: do you elaborate on this statement somewhere I missed? "In practice, cofree comonads are quite useful for annotating syntax trees, or talking about streams."
13:31:47 <Dodek> maxiepoo: i find it hard to come up with an interesting example of a functor isomorphic to (a ,)
13:32:03 <jrmithdobbs> edwardk: or concrete examples of it at least?
13:32:47 <edwardk> http://comonad.com/reader/2009/incremental-folds/
13:32:58 <edwardk> maxiepoo: not really
13:33:16 <edwardk> Dodek: there are lots of them, but they get made out of simpler parts practically
13:33:19 <jrmithdobbs> the title of that is promising as that's exactly what thinking they'd be useful for, ha
13:33:45 <Redz> @hoogle IO a -> IO () -> IO a
13:33:45 <lambdabot> Network.HTTP.Base catchIO_ :: IO a -> IO a -> IO a
13:33:46 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
13:33:46 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
13:33:47 <Dodek> edwardk: for example?
13:33:57 <int-e> Dodek: church encoding? newtype CPair a b = CPair (forall r. (a -> b -> r) -> r)
13:34:51 <edwardk> Dodek: left adjoints of functors from hask -> hask all take that form. its kinda boring, but it arises a lot. Writer, composition of left adjoints, etc. data Named a = Named String a.  they all 'feel' like boring pairs with information because well. they are.
13:35:36 <shachaf> weren't we going to call them "linear"
13:35:43 <Dodek> >left adjoints of functors from hask -> hask all take that form.
13:35:47 <Dodek> okay, this sounds interesting
13:35:54 <edwardk> Dodek: representability is the same thing for right adjoints. they are all isomorphic to functions from some representation, but we don't kick Complex, V2, V3, V3, V4, Quaternion, etc out because they are all alike
13:36:15 <shachaf> maxiepoo: That's what I said yesterday! http://ircbrowse.net/browse/haskell?id=17347328&timestamp=1390788015#t1390788015
13:36:24 <ReinH> :t (flip (>>)) -- Redz
13:36:25 <lambdabot> Monad m => m b -> m a -> m b
13:36:30 <maxiepoo> shachaf, yeah I was about to say that
13:36:42 <ReinH> Redz: except that change the ordering
13:37:12 <Redz> thanks. :)
13:39:02 <ReinH> Redz: you might want finally
13:39:55 <Redz> yes. but i dont need something that do something with exceptions.
13:40:24 <Redz> a finally without exception-related behavior.
13:40:40 <ReinH> Redz: you probably just want do { a <- ma; mb; return a}
13:41:06 <Redz> yep. i'll need to write a helper function.
13:41:29 <shachaf> ma <* mb
13:41:37 <shachaf> no need for Monad
13:41:43 <ReinH> oh duh
13:42:07 <fizbin> @type (<*)
13:42:07 <maxiepoo> so given an adjunction F -| G of endofunctors in Hask, you get G b ~ () -> G b ~ F () -> b so G ~ ((->) F ())
13:42:08 <lambdabot> Applicative f => f a -> f b -> f a
13:42:16 <ReinH> @hoogle f a -> f b -> f a
13:42:16 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
13:42:16 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
13:42:16 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:42:17 <ReinH> whoops
13:42:32 <Redz> oh my brain explodes.
13:43:43 <shachaf> maxiepoo: Yes.
13:44:07 <shachaf> And F ~ (F (),)
13:44:15 <Redz> thanks. :)
13:45:15 <maxiepoo> yeah I'm trying to derive that one
13:45:29 <Redz> i really need to take a closer look at applicative.
13:45:37 <shachaf> Well, it's left adjoint to (F () ->)
13:45:53 <bernalex> c_wraith: ty
13:45:54 <bitemyapp> Redz: just take the stroll from Functor -> Applicative -> Monads
13:46:35 <maxiepoo> oh that's clever
13:46:51 <maxiepoo> so it's isomorphic to (F(), )
13:47:26 <bernalex> c_wraith: I'm tired and not braining properly -- what do you mean by 'c' and 'r'?
13:47:39 <maxiepoo> thanks I remember you saying that yesterday but I hadn't worked through it yet
13:47:41 <nominolo> Aetherspawn: pong
13:47:55 <Aetherspawn> oh hi
13:48:05 <Aetherspawn> heh, are you on pluto? :P
13:48:26 <Aetherspawn> can I /msg you?
13:48:30 <c_wraith> bernalex: c is "current", r is "rest"
13:48:30 <nominolo> sure
13:48:56 <bernalex> c_wraith: ah
13:50:18 <shachaf> maxiepoo: If you want another adjunction that's "almost" just in Haskell, there's (-> r) -| (-> r)
13:50:21 <maxiepoo> so yeach it only depends on the equivalence between (() -> G b) and G b, so does that mean there's a similar result for any category with terminal object?
13:51:01 <shachaf> Well, usually it goes the other way around.
13:51:07 <fizbin> Are there any good full examples of building a compiler in haskell besides ghc? Say, for a language targeting some sort of embedded platform?
13:51:43 <c_wraith> fizbin: does jhc count?
13:51:44 <prophile> purescript?
13:51:56 <fizbin> I've been trying to get my brain around various Free Monad blog articles and it isn't working. I can't map the simple examples in the blog to my problem.
13:51:59 <shachaf> Given the adjunction (e,) -| (e ->), we can get the correspondence between Hom(A,B) and Hom(1, B^A)
13:52:25 <maxiepoo> fizbin, examples as in real world projects? There's ermine and elm
13:52:35 <maxiepoo> oh and agda of course
13:54:02 <maxiepoo> shachaf, which is the entire point of exponentials, right?
13:54:46 <shachaf> Well, it's the definition of an exponential.
13:54:55 <shachaf> Hmm, I think I might have misunderstood your question, though.
13:55:21 <maxiepoo> yeah wait what do you mean we get that correspondence from the adjunction?
13:55:30 <erisco> "createProcess: does not exist" any ideas? it does not seem to be searching my PATH (windows 8.1)
13:55:34 <maxiepoo> well let's see
13:56:07 <shachaf> Anyway, Set isn't always a great category for getting intuition about this.
13:56:13 <maxiepoo> (-> A) means the exponential functor (-^A) right
13:56:25 <maxiepoo> er
13:56:27 <shachaf> (-> A) means (A^-)
13:56:28 <maxiepoo> ((->) A)
13:56:34 <maxiepoo> (A ->)
13:56:45 <shachaf> Yes, ((->) A) -- what I've been writing as (A ->) -- means the same as (-^A)
13:56:48 <bernalex> http://lpaste.net/1013093501346250752 I don't like the shape of this. ugly! tips for beautificationining it?
13:57:52 <maxiepoo> bernalex, I would put that lambda after forM_ into a where clause and give it a name
13:58:12 <shachaf> maxiepoo: What was it you were saying about a correspondence?
13:58:32 <maxiepoo> you said something about a correspondence
13:58:52 <shachaf> There's no notion of "an element of A" in general for most categories.
13:59:02 <maxiepoo> right
13:59:04 <shachaf> Or, well, there is, but it's often defined as "an arrow : 1 -> A"
13:59:46 <maxiepoo> but this adjunction occurs in what, any category with product and exponentials?
14:00:22 <erisco> bernalex, I annotated wtih a different way of aligning things
14:00:37 <bernalex> erisco: thanks
14:01:43 <maxiepoo> well the isomorphism is just curry/uncurry so I would suppose so
14:01:51 <erisco> bernalex, what does reverseAndDropWhile do?
14:02:19 <shachaf> The definition of an exponential is that it's right adjoint to a product.
14:02:49 <maxiepoo> ohhh
14:03:00 <bernalex> erisco: it's sort of reverse . dropWhile . reverse
14:03:52 <erisco> why not write it that way then?
14:04:03 <bernalex> erisco: reverse . reverse is super slow
14:05:31 <shachaf> (A "cartesian closed" category has all finite products and all exponentials. Maybe that's what you're looking for, though I don't remember your question at this point.)
14:05:35 <maxiepoo> so then any right adjoint endofunctor on a category with exponentials is representable
14:06:35 <dv-> bernalex: use takeBaseName
14:06:40 <shachaf> Hmm, I don't think so.
14:07:09 <shachaf> "representable" specifically means : C -> Set, and isomorphic to a hom functor
14:07:28 <maxiepoo> oh
14:07:34 <bernalex> dv-: figures there'd be something like that. thanks. :-)
14:07:48 <maxiepoo> I just meant isomorphic to a hom functor I think
14:08:21 <shachaf> Well, you said it's an endofunctor.
14:08:37 <shachaf> So if it's isomorphic to a hom functor it has to be in Set.
14:08:48 <maxiepoo> oh right
14:12:21 <bernalex> dv-: oh btw that's the opposite of what I want, is there an opposite?
14:19:27 <dv-> ah i didn't look at it carefully :p
14:19:36 <dv-> there's splitFileName
14:19:39 <dv-> @hoogle splitFileName
14:19:39 <lambdabot> System.FilePath.Windows splitFileName :: FilePath -> (String, String)
14:19:39 <lambdabot> System.FilePath.Posix splitFileName :: FilePath -> (String, String)
14:20:17 <dv-> and also takeDirectory
14:21:09 <shackleford_> Is there a standing convention on breaking up the construction of lists over multiple lines? http://lpaste.net/99185 This is how I've been doing it, but is there another way it's usually formatted?
14:21:42 <bernalex> dv-: takeDirectory doesn't quite work like I need. in "/foo/bar/fu/baz/", baz is a file. but takeDirectory treats it as a directory (which it of course also is), so it gives /foo/bar/fu/baz instead of /foo/bar/fu/ which is the directory where the file/directory baz lies.
14:22:02 <bernalex> or /foo/bar/fu rather, is the result I'd want
14:22:09 <hpc> shackleford_: one extra space on the (++) indentation
14:22:24 <hpc> unless you are using tabs, in which case SHAAAAAME
14:22:37 <bernalex> > splitFileName "/foo/bar/fu/baz/"
14:22:38 <lambdabot>  Not in scope: `splitFileName'
14:22:48 <hpc> er, nvm it's 4-space indent
14:22:52 <bernalex> oh. well. it doesn't work either. :-P
14:23:12 <hpc> shackleford_: yeah, indentation like that is one of the things people sometimes do
14:23:14 <bernalex> both of them would work if not for them treating the last directory as a directory rather than a file.
14:23:31 <hpc> usually you will go with layout for something like that
14:23:46 <hpc> where you make things line up
14:24:10 <hpc> (fun fact, trying to spell "line" after typing "align" is a weird mental challenge)
14:24:17 <shackleford_> hpc: Oh, I learned my lesson about tabs and Haskell. The hard way. My hatred for GHC's parser will likely remain for years. But anyway, http://lpaste.net/99185 this is what you meant?
14:24:32 <hpc> yeah, something like that
14:24:45 <dhrosa> (woo english spelling rules)
14:24:50 <shackleford_> Awesome. Thanks!
14:25:03 <hpc> for actual list literals, there's a few styles too
14:25:06 <hpc> [foo,
14:25:08 <hpc>  bar,
14:25:09 <hpc> ...
14:25:23 <dv-> bernalex: so joinPath $ init $ splitPath "/foo/bar/fu/baz/" ?
14:25:27 <hpc> or for people who love to exploit their editor,
14:25:29 <hpc> [ foo
14:25:30 <hpc> , bar
14:25:33 <hpc> , ...
14:26:08 <bernalex> dv-: oooh, that works. thanks!
14:26:11 <hpc> i personally go for 2-space indentation and keeping ordinary expressions on one line
14:26:32 <hpc> i have 150 characters of width, why waste it on 80x24 formatted code from the 70s
14:26:34 <dv-> haskell indentation is quite liberal
14:26:45 <bernalex> dv-: it's clever even.
14:26:52 <hpc> basically, do whatever so long as other people can understand what you wrote
14:27:25 <hpc> if a person can read it, so can a compiler
14:28:15 <hpc> also fun fact about tabs, it's not ghc's fault
14:28:28 <hpc> the haskell language specification says tabs are 8-stop
14:28:46 * hackagebot persistent-redis 0.2.1 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.2.1 (PavelRyzhov)
14:28:56 <shackleford_> hpc: So a width 4 tab is an automatic parse error?
14:28:58 <hpc> probably to make sure every editor renders haskell the same way
14:29:26 <hpc> shackleford_: "\t" => go right to the next multiple of 8
14:29:34 <erisco> lol I just spent the time to read and parse the PATH env var only to find 'getSearchPath' in System.FilePath
14:29:43 <hpc> if you render tabs differently in your editor, you will see the Wrong Thing(tm)
14:30:20 <hpc> it's probably inspired ada(?) which specifies 3-space tabs
14:30:30 <hpc> or something along those lines
14:30:34 <shackleford_> I use Sublime, so the transition from tabs to 4 spaces was seamless
14:30:56 <hpc> i use vim with :set list
14:31:01 <bernalex> how can I putStrLn foo if it's not empty else bar?
14:31:03 <hpc> so tabs get translated to either ^I or ^@
14:31:18 <bernalex> so print foo if not foo == [], else bar
14:31:20 <hpc> depending on what system i am on, hilariously
14:31:44 <pranz> bernalex: doesn't it work just like that?
14:31:53 <dhrosa> bernalex: putStrLn (if foo == [] then "foo" else "bar")
14:31:55 <dhrosa> is one way
14:32:00 <hpc> if not (null foo) then print foo else print bar
14:32:08 <bernalex> dhrosa: my foo is a very long expression
14:32:08 <hpc> or something
14:32:22 <hpc> bernalex: let foo = foo in if ... then ...
14:32:37 <bernalex> so when foo is joinPath $ init $ splitPath file, this will be zomg optimise, and not performed twice?
14:32:39 <hpc> (first rule of programming, if you like something give it a name)
14:32:40 <shackleford_> bernalex: use a let or where binding to shorten it?
14:33:01 <bernalex> I was not worried about the length of characters, but of computation
14:33:23 <pranz> bernalex: lazy eval only computes when it is needed
14:33:54 <bernalex> call-by-need to the rescue.
14:34:05 <dv-> you would have to process a truly enormous amount of filepaths for it to matter
14:34:18 <quchen> dhrosa: Don't use (== []), it has an unnecessary Eq constraint. `null` is what you want.
14:34:22 <quchen> :t (== [])
14:34:23 <lambdabot> Eq a => [a] -> Bool
14:34:24 <quchen> :t null
14:34:24 <lambdabot> [a] -> Bool
14:34:37 <bernalex> quchen: that was or me, I assume, and yes, I am using null. :-)
14:34:51 <bernalex> *for me
14:35:12 <quchen> Oh. Well, *nobody* should be using (== []) anyway.
14:35:26 <hpc> quchen: they're strings anyway
14:35:30 <hpc> (== "") is perfectly fine
14:35:40 <hpc> > [1, 2, 3] == ""
14:35:41 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
14:35:42 <lambdabot>    arising from the literal `1'
14:35:42 <lambdabot>  Possible fix:
14:35:42 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
14:35:49 <monochrom> bernalex: you should also read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
14:35:50 <hpc> :(
14:36:01 <quchen> "" is not the empty list, it's the empty [Char]
14:36:19 <hpc> monochrom: good god, you have a page for everything on your website
14:36:32 <monochrom> no, I still doesn't have a monad tutorial!
14:36:40 <hpc> haha
14:37:02 <bernalex> monochrom: that was a very botlike post...
14:37:02 <monochrom> the monad tutorial I want to write was already written by Wadler
14:37:03 <shackleford_> Does anyone know if theres a LaTeX-generator lib for Haskell?
14:37:14 <bernalex> monochrom: but sure, your blog is probably informative. I'll check it out tomorrow.
14:37:22 <bernalex> shackleford_: like pandoc?
14:37:28 <monochrom> what is "botlike"?
14:37:41 <bernalex> monochrom: suddenly jumping into a conversation with a link "you should read this"
14:37:52 <monochrom> then yes
14:38:03 <geekosaur> it does have a similarity to that markov bot...
14:38:05 <monochrom> customers who like crossroad.xhtml also like...
14:38:20 <bernalex> monochrom: something something viagra?
14:38:31 <quchen> monochrom is an authoritative source, I've double-checked with his theorem prover.
14:38:33 <monochrom> no, prerequisite.xhtml
14:39:16 <shackleford_> bernalex: More like this https://github.com/JelteF/PyLaTeX I was thinking
14:39:56 <bernalex> shackleford_: oh. OK. I've only used hakyll to make html from latex and markdown.
14:40:01 <hpc> monochrom: also congrats on writing the only valid xhtml documents in known history ;)
14:40:08 <monochrom> haha
14:40:17 <bernalex> shackleford_: I understand now what you mean by latex generator.
14:40:21 <monochrom> yes I read the xhtml spec several times
14:41:04 <ReinH> monochrom: I'm so sorry
14:42:16 <monochrom> well, it is not like Haskell 2010's own section 3.17.3 is any simpler
14:42:27 <shackleford_> bernalex: Pandoc looks pretty useful, but it's just for some proofs homework. Might as well not be lazy and write it by hand.
14:42:29 <monochrom> and I read 3.17.3 several times, too
14:43:29 <bernalex> dv-: need init $ joinPath $ init $ splitPat heh...
14:43:38 <bernalex> joinPath readds the / at the end that I don't want
14:43:48 * hackagebot hbro 1.1.2.1 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.1.2.1 (koral)
14:44:27 <bernalex> so I do,
14:44:29 <bernalex>       let dirname = joinPath $ init $ splitPath file
14:44:31 <bernalex>       in  putStrLn $ if null dirname then "." else init dirname
14:47:06 <mornfall> anyone has a link to the original "g machine" paper(s)?
14:48:59 <erisco> I have a list of file paths, IO [FilePath], and I want to return the first that passes doesFileExist :: FilePath -> IO Bool
14:49:29 <erisco> having trouble getting the types to line up... presumably I'd want to use find :: (a -> Bool) -> [a] -> Maybe a  but I am not sure it can be
14:50:13 <mornfall> (presumably the one by Kieburtz?)
14:50:39 <Clint> erisco: do you want filterM?
14:50:53 <erisco> Clint, I suppose that could work
14:51:11 <erisco> then I could listToMaybe
14:51:49 <shackleford_> How would a purely functional language deal with explicit memory management?
14:53:02 <mornfall> shackleford_: by not freeing anything ever?
14:53:04 <mornfall> :-)
14:53:31 <simpson> shackleford_: Depends on what "purely functional" means, probably.
14:53:42 <erisco> there we go thanks for the help Clint
14:53:56 <erisco> http://lpaste.net/99187 maybe this will solve my problems wrt createProcess not searching my path
14:53:59 <erisco> I'll just do it myself!
14:54:04 <lllllllllllll> can lambdabot reload commands online?
14:54:46 <tac_> shackleford_: like anything else, you'd work in some model of the thing you care about. Some explicit memory management DSL, for instance.
14:55:15 <shackleford_> tac_: I'm not sure I follow you
14:55:48 <tac_> The naive way might be to do it in a monad.
14:56:00 <tac_> IO can do memory allocation and deallocation, for instance
14:56:57 <Twey> shackleford_: You can introduce regions like the ST monad uses, using the type system to promise not to use anything defined inside that region outside of it, and then your ‘runST’ (equivalent) can safely free everything allocated inside the region
14:56:59 <mornfall> why is getting papers such an ordeal...
14:57:15 <Twey> shackleford_: The MLKit ML compiler even has an algorithm to do this automatically
14:57:18 <erisco> wow what?!?
14:57:30 <erisco> now createProcess is bitching "invalid argument (Exec format error)"
14:57:30 <mornfall> Twey: that's borderline pure :)
14:57:34 <Twey> Yeah
14:57:39 <erisco> yet once again, the command works perfectly fine
14:58:04 <Twey> I don't know of a fully satisfactory explanation; it's something I've thought about quite a lot (along with everyone else :þ)
14:58:07 <mornfall> erisco: createProcess doesn't take a command though, not in the shell sense, just a path to an exeucatble file
14:58:27 <erisco> mornfall, can it not deal with bash or cmd scripts?
14:58:35 <Twey> Careful usage of linear types can give you a nice solution in most simple cases so long as your language is also strict
14:58:48 <mornfall> erisco: if they are properly hashbanged and +x, then it probably can
14:59:25 <mornfall> Twey: For everyone but functional programmers, it also qualifies as automatic memory management :P
14:59:38 <nisstyre> Twey: Rust is the only language I know of that has all of that
14:59:40 <nisstyre> maybe Mercury?
14:59:45 <nisstyre> is that strict?
14:59:51 <mornfall> all of what?
14:59:56 <Twey> Well, only in the same sense as C/C++'s automatic storage area
14:59:58 <erisco> oh, I think the issue is that createProcess is picking up the bash scripts on my windows machine
15:00:01 <erisco> instead of the cmd scripts
15:00:05 <nisstyre> mornfall: linear types and strict evaluation
15:00:06 <platz> are linear types a lvar's the same thing?
15:00:12 <Twey> platz: No
15:00:13 <nisstyre> and explicit memory management
15:00:23 <mornfall> nisstyre: rust is not a functional language
15:00:30 <nisstyre> mornfall: functional enough
15:00:38 <Twey> mornfall: You can do true explicit memory management with linear types if you want, with a ‘free’ function that consumes its argument
15:00:43 <Twey> But it doesn't look nearly so pure any more
15:00:56 <Twey> nisstyre: Rust is about as functional as Python :þ
15:00:57 <nisstyre> Twey: what would be the point?
15:01:09 <shackleford_> I don't trust rust at all, man. It's changing so quick that I feel like it'll be C++ all over again, just quicker
15:01:18 <companion_cube> doesn't rust have proper scopng and closures?
15:01:20 <nisstyre> shackleford_: let's start writing libraries for Clean
15:01:41 <Twey> nisstyre: You get more explicit control over where things are free'd, which can sometimes be important (any automatic inference algorithm is going to have to make some conservative guesses sometimes, which is liable to cost you performance)
15:01:51 <bitemyapp> shackleford_: I don't think so, they've been aggressively *removing* unnecessary things from core and moving them to libraries.
15:02:02 <bitemyapp> shackleford_: that's very un-C++
15:02:15 <Twey> Of course, if you don't have any sharing the problem is trivial, but then you don't have any sharing, which introduces performance issues of its own :þ
15:02:24 <nisstyre> companion_cube: if you mean does it have the ability to access free variables if they were bound in the environment something was created, I think it does depending on how you use the type system
15:02:28 <mornfall> bitemyapp: no, it's very un-deployed, not un-C++
15:02:30 <bjz_> shackleford_: Rust is stabilising in lots of areas, but where it needs work, it most certainly needs work. Biggest thing now is the package management situation.
15:02:42 <Twey> nisstyre: ATS has a linear typing–based explicit memory management system
15:02:55 <erisco> how can I detect which platform is being used (windows or posix) in my Haskell program?
15:02:57 <nisstyre> Twey: that's another one then
15:02:57 <companion_cube> nisstyre: I mean that functions introduce a new scope that also contain values of the enclosing scope
15:03:00 <Twey> Which also doesn't really feel satisfactory to me, but I guess it's more functional than Rust at least
15:03:02 <erisco> I don't care if it is compile flags or whatever
15:03:11 <nisstyre> companion_cube: that's what I said, and it depends on the types of things IIRC
15:03:24 <companion_cube> well you need to know the lifetimes, I guess
15:03:26 <nisstyre> I'm not a Rust programmer though
15:04:35 <bjz_> Twey: Rust is pretty imperative, but at least mutability is heavily contained, and the type system is very inspired by ML/Haskell
15:04:37 <Twey> platz: Linear typing is a type system that tracks whether or not a value has been ‘used up’.  So you can have functions that ‘consume’ variables, after which they go out of scope and can't be used any more
15:04:40 <nisstyre> companion_cube: yeah, you have to explicitly tell it that you want the variables to stick around
15:05:09 <bjz_> Twey: DDC looks interesting, but I have no idea where they are at in development https://github.com/DDCSF/ddc
15:05:27 <nisstyre> bjz_: it's not ready to be used seriously afaict
15:05:31 <nisstyre> more of a research project
15:05:49 <bjz_> nisstyre: DDC?
15:05:51 <nisstyre> yeah
15:05:58 <bjz_> nisstyre: that's a shame
15:06:04 <nisstyre> at least that's what I saw from the developer(s)
15:06:04 <Twey> platz: LVars (by analogy with MVars, TVars, &c.) are a way of constraining non-deterministic parallel computation by specifying a ‘minimum bound’ the result has to meet before you'll accept it.  Very neat, but completely unrelated.  :þ
15:06:22 <lllllllllllll> @pl (\b -> head b == 'c')
15:06:22 <lambdabot> ('c' ==) . head
15:06:22 <nisstyre> bjz_: Clean is mature but there are no libraries really
15:06:23 <Twey> bjz_: DDC is a research project, but it's a very old one.  It's currently undergoing a complete rewrite.
15:06:26 <bjz_> nisstyre: without momentum and a community languages have trouble getting anywhere :(
15:06:31 <lllllllllllll> urgs
15:06:41 <nisstyre> bjz_: yep
15:06:43 <platz> Twey: yeah, i understand neither linear types nor lvars, but after reading http://c2.com/cgi/wiki?LinearTypes it seemed like it could solve some of the same problems that you could solve with lvars.  but i digress...
15:07:01 <bjz_> nisstyre: despite it's flaws, Rust at least has that, so I have confidence it will at least make a mark
15:07:05 <nisstyre> platz: uniqueness types (a kind of linear typing) let you have mutability with purity
15:07:06 <platz> with regards to making things more "deterministic" (using that word loosely)
15:07:07 <davean> nisstyre: it seems odd to call a language "mature" when it lacks libraries
15:07:12 <aleksejs_> Why when I try to compile with -O2 -dynamic it cannot find any Text.* ?
15:07:20 <nisstyre> davean: the compiler is matured
15:07:21 <Twey> bjz_: I wasn't arguing against Rust, which I think is pretty cool in many ways (even if it doesn't have TCO…) but the question was about pure functional approaches, so I was trying to stick to that as closely as possible
15:07:22 <davean> nisstyre: One needs rather a lot of code in a language to figure out what the issues are
15:07:32 <mornfall> there's no mention of linear types in TAPL ... how did that happen?
15:07:37 <davean> nisstyre: Proposing one gets to that point without libraries seems unlikely
15:07:38 <Twey> mornfall: There is
15:07:43 <Twey> Oh, actually
15:07:48 <Twey> mornfall: No, it's in ATITAPL
15:07:50 <nisstyre> davean: I've been told people've written substantial programs in it
15:07:56 <Twey> One of the first chapters covers substructural systems
15:08:00 <bitemyapp> nisstyre: they have.
15:08:01 <bjz_> Twey: yeah definitely. I'm sure in the future there will be a viable purely functional systems lang
15:08:01 <nisstyre> but the library ecosystem is non-existent more or less
15:08:10 <davean> nisstyre: You need a lot of substantial programs to shake out the issues in most languages
15:08:13 <bitemyapp> nisstyre: little game engines and stuff.
15:08:20 <bitemyapp> nisstyre: the game-dev community is pretty excited about it
15:08:26 <nisstyre> bitemyapp: yeah, I was interested in using it for something, maybe a compiler
15:08:33 <Twey> bjz_: It's one of my back-burner projects ☺
15:08:40 <davean> nisstyre: I mean, Haskell is still shaking the issues out
15:08:40 <bitemyapp> nisstyre: game-dev is my interest in it, I can use Haskell for the rest of what I do.
15:08:46 <bjz_> Twey: but at the moment Rust is the only one that has enough momentum
15:08:55 <bjz_> Twey: what are you working on?
15:08:56 <nisstyre> davean: yeah that's true I guess
15:09:09 <davean> nisstyre: I don't think Haskell has reached "maturity"
15:09:22 <davean> C sure has
15:09:29 <bjz_> bitemyapp: are you on #rust-gamedev?
15:09:31 <nisstyre> davean: in comparison to Clean it has
15:09:38 <mornfall> now please, anyone who's *not* schemeing a language of their own, raise their hand? :-)
15:09:39 <Twey> bjz_: I'm trying to find a semantically satisfying way of combining manual (or at least fully predictable) memory management with functional programming
15:09:47 <davean> mornfall: me
15:09:51 <bitemyapp> bjz_: yes.
15:09:53 <bjz_> Twey: linear types and regions?
15:09:56 <davean> mornfall: unless you count some eDSLs
15:10:51 <nisstyre> Twey: I'm working on a javascript based language I'll admit
15:11:00 <mornfall> Twey: I don't have a hardcopy of ATITAPL. Or any copy, for that matter.
15:11:09 <athan> can someone help me install hs-ffmpeg? Cabal hell all over the place :S
15:11:10 <Twey> bjz_: That's certainly a step in the right direction, but it's not quite what I'm looking for — the algorithm breaks down for complicated cases, and it's still not ‘predictable’ in the sense that C++ or ATS code is (where the programmer actually has explicit control over scopes)
15:11:40 <bjz_> Twey: the most exciting thing about rust is how a combination of linear types, regions, and unsafe stuff can give you the building blocks of both static and dynamic memory management implement in libraties
15:11:59 <skypers> Twey: what’s your problem?
15:12:04 <Twey> I was thinking about concatenative languages as a (partial?) solution to this problem, but I'd also like to have dependent types, and the stack-shuffling gets pretty noisy
15:12:24 <bjz_> Twey: dependent types would be amazing
15:12:46 <bjz_> Twey: they capture lots of templates in a more principled way
15:12:52 <Twey> bjz_: You might want to look into ATS.  It's theoretically done a bit better than Rust, I think, although it's somewhat… idiosyncratic in many ways
15:12:56 <bjz_> *lots about templates
15:13:26 <Twey> They capture everything about templates, I think, and some more besides
15:13:46 <bjz_> Twey: I've look at it and.... ack. Rust at least has been trying to cut down on complexity
15:14:01 <Twey> (it's the ‘more besides’ that's the problem; you have to be quite cunning to avoid passing proof arguments around at runtime, though I believe edwinb is making some impressive progress on the issue)
15:14:13 <Twey> skypers: Problem?
15:14:16 <bjz_> Twey: and again, community is a huge part
15:14:20 <mornfall> Twey: From a first look, ATS looks like L4 ... looks good on paper, has a number of implementations and nobody ever uses it.
15:14:27 <skypers> Twey: yeah what are you working on?
15:14:39 <Twey> mornfall: ATS doesn't look good in any form ;þ
15:14:40 <nisstyre> Twey: my problem with all of these languages like ATS, Clean, Mercury, Disciple, etc... is just that they lack many well designed libraries to actually DO stuff
15:14:58 <Twey> nisstyre: You can solve this problem :þ
15:15:08 <athan> How do you install a package that depends on base <4?
15:15:10 <nisstyre> Twey: I could _help_ solve it
15:15:10 <Twey> ATS at least compiles to C, so you can use C libraries trivially
15:15:12 <bjz_> Twey: If I'm going to be making a game in it, I want a certain confidence that I will have some support heading into the future, and won't have to do *too* much compiler hacking
15:15:22 <bjz_> Twey: that also kinda sucks
15:15:23 <nisstyre> Twey: first problem: which one do I help?
15:15:45 <bjz_> Twey: I'd like a lang for which the only thing underneath is IR or assembly
15:15:48 <skypers> how do you leave a message with lambdabot to somebody?
15:15:53 <Twey> nisstyre: Clean is proprietary, so not that one
15:16:34 <nisstyre> Twey: well DDC is written in Clean isn't it?
15:16:38 <bjz_> Twey: the idris stuff is exciting. idris+rust would be amazing.
15:16:39 <Twey> nisstyre: I think Mercury and Disciple solve are solving a different problem
15:16:52 <darthdeus> some languages are just so wrong
15:16:53 <nisstyre> yeah true
15:17:08 <Twey> nisstyre: So if that's what you want, ATS I guess
15:17:14 <mornfall> bjz_: amazing hodgepodge indeed
15:17:15 <bjz_> Twey: what is disciple solving?
15:17:29 <Twey> bjz_: Idris is nice for ‘higher-level’ stuff for which I'd currently use Haskell, but it's still garbage-collected all the way down, so it doesn't really fill C++'s niche yet
15:17:37 <bjz_> Twey: yes
15:18:02 <bjz_> Twey: looking at the C runtime makes a systems programmer recoil in horrror
15:18:03 <darthdeus> i've spent 3 hours today trying to write a hello world http server using scala and some crappy library ... in 7 java developers in the room, and nobody could figure out what was going on with all that stuff :P
15:18:28 <bjz_> Twey: you really need unboxed types, and the ability to pass by value
15:18:47 <Lethalman> scala complexity = O(c++ complexity)
15:18:52 <Twey> bjz_: I don't think Disciple intends to solve a specific problem.  It's just a research effort to see whether you can get most of the benefits of Haskell by using effect typing, so you can generalize functions across effects (so you don't have separate functions like map/mapM, filter/filterM, &c.)
15:19:02 <Lethalman> = O(rust complexity)
15:19:03 <Lethalman> :P
15:19:18 <Twey> bjz_: Yeah
15:19:19 <bjz_> Twey: and monomorphisation of "generics"
15:19:28 <nisstyre> Twey: Mercury sounds like it intends to be practical and theoretically sound
15:19:42 <mornfall> nisstyre: who doesn't?
15:19:48 <Twey> Heh
15:19:51 <nisstyre> mornfall: Disciple
15:20:00 <bjz_> Twey: composibility with regions can be challenging though
15:20:09 <Twey> nisstyre: But not for low-level programming, right?  I thought it was more of a high-level thing, like Prolog for actual programs
15:20:21 <nisstyre> Twey: yeah it's a logic language
15:20:32 <nisstyre> Twey: probably not amazing if you want to create a high performance 3D game
15:20:44 <Twey> Right
15:20:54 <bjz_> Twey: haskell is so nicely composable because you don't have to worry about if your regions match up
15:21:15 <bjz_> Twey: like, whether some parameters are passed by val or by ref
15:21:24 <nisstyre> Twey: there's also Kanren which is like a bunch of Scheme macros, so you could find the best Scheme compiler and try to use that :D
15:21:25 <mornfall> Twey: prolog!
15:21:47 <mornfall> Twey: prolog is rotten to the core
15:22:00 <bjz_> Twey: Rust makes a trade off for control over allocation over composibility
15:22:07 <Twey> bjz_: Right; I feel that's to some extent an unavoidable complexity, though
15:22:31 <Twey> You *want* to know whether your parameter was passed by value or by reference in order to perform optimally
15:22:42 <Twey> mornfall: Preachin' to the choir.  :þ
15:22:45 <bjz_> Twey: yeah, folks say Rust is complex, but it's a necessary complexity if you want control.
15:23:09 <Twey> bjz_: I don't think people seriously say Rust is complex.  Not people who've used C++, anyway.
15:23:15 <bjz_> no
15:24:04 <bjz_> Twey: those who are more used to CGed langs do. Because everything they use is boxed - you don't know the difference
15:24:05 <nisstyre> Twey: Rust is a bit overwhelming
15:24:27 <bjz_> Twey: if you did not have mutability, it might be more composable
15:24:34 <dibblego> people who have used java say scala is "complex" — it is used as a synonym for "unfamiliar"
15:24:45 <Twey> Agreed
15:24:55 <bjz_> Twey: atm Rust has by val, by ref, and by mutable ref
15:25:16 <Twey> bjz_: That's no worse than C
15:25:20 <Twey> Let alone C++
15:25:27 <mornfall> rvalue references!
15:25:30 <nisstyre> dibblego: yeah, Scala is considered "ivory tower" by those people
15:25:36 <nisstyre> which is pretty funny
15:25:37 <bjz_> Twey: no, but if you're looking at the future, beyond rust
15:25:48 <mornfall> I don't like Scala purely on looks.
15:25:55 <mornfall> I didn't get any further with it. :-)
15:25:59 <mornfall> Also, Java runtime stinks.
15:26:14 <bjz_> Twey: pure functional could reduce the complexity of the type signatures
15:26:34 <skypers> lambdabot: how do you leave I message?
15:26:41 <bjz_> Twey: and hence improve composibility
15:27:26 <mornfall> nisstyre: it seems like Scala is to Java what C++ is to C... retrofit of a type system
15:27:42 <skypers> does someone even know? :D
15:27:44 <bjz_> Twey: do you have a project page?
15:27:44 <Twey> bjz_: Mm, but you lose mutability, which is important for performance at that level
15:27:50 <bjz_> Twey: yes
15:27:55 <Twey> No
15:28:07 <bjz_> Twey: that is the question
15:28:12 <Twey> I did have, but I threw it away last time my approach didn't work and I had to start all over again :þ
15:28:29 <bjz_> Twey: so does your lang have mutabilty?
15:28:50 <Twey> bjz_: Kind of
15:29:07 <mornfall> name capture is such a bother
15:29:37 <Twey> It is (or was) a stack language, so ‘mutating a variable’ and ‘destroying and recreating a variable’ are the same concept
15:29:44 <bjz_> Twey: nice
15:29:46 <mornfall> completely spoils lambda calculus... could have been a perfectly good formalism
15:30:05 <Twey> mornfall: Beg pardon?  :þ
15:30:24 <Twey> mornfall: Use de Bruijn, everything's fine
15:30:34 <bjz_> Twey: anyway, gotta head out, but I'm certainly interested in your project
15:30:49 <Twey> bjz_: Adieux!
15:30:54 <nisstyre> mornfall: I assume you're referring to the fact that alpha-renaming or whatever can change the meaning of your expression if you rename something to a name that's already bound?
15:31:07 <bjz_> Twey: I definitely don't think Rust is the 'final systems lang'
15:31:15 <matsuda> I wanted to try -XTypeHoles.  I pulled the ghc git repo and built it but -XTypeHoles doesn't seem to be supported.  do I have to build some specific branch?
15:31:16 <platz> Scala isn't just complex because it inherits Java cruft.  Also, since it has both OO and FP features in it's type system, you end up with an N by N grid of possibilites when you combine the FP and OO type features
15:31:24 <skypers> colDrMcBeardman: I don’t know how to leave a message through lambdabot, so I hl you; yes I saw that, and I don’t really understand why! floor (0/0)’s behavior is clearly a bug to me :( I deplore that
15:31:34 <nisstyre> mornfall: oh and other stuff I guess
15:31:37 <mornfall> nisstyre: I mainly refer to beta
15:31:41 <nisstyre> yeah
15:31:59 <nisstyre> mornfall: well it's not that bad if you're implementing it, but I wouldn't want to do it all by hand
15:32:15 <mornfall> nisstyre: it's bad even when you implement it
15:32:23 <mornfall> it's ugly, and ugly things are always bad
15:32:35 <mornfall> it's so pretty under an assumption of globally unique names
15:35:49 <dibblego> I wish criticisms of scala were properly levelled :(
15:36:01 <Twey> nisstyre: DDC appears to be written in Haskell, by the way
15:36:05 <dwcook> dibblego, how so?
15:36:41 * tac spent a long time looking at DDC.
15:36:48 <dibblego> in such a way to coincide with also being true
15:36:59 <jle`> is there a typeclass for a monotraversable with return
15:37:07 <jle`> Char -> String
15:37:15 <tac> I think I spent more time reading Ben's thesis than anything else.
15:37:15 <dwcook> dibblego, what false criticisms of Scala did you have in mind?
15:37:21 <jle`> Char -> Text
15:37:38 <jle`> Bool -> ByteString
15:37:46 <dibblego> dwcook: edwardk's critique of scala is the only accurate thing I have seen, except in less formal channels, and even that was too generous
15:38:17 <nisstyre> dibblego: do you have a link to that?
15:38:40 <dibblego> I will try
15:39:01 <heatsink> dibblego, what did you think of the Scala Corrections Library?
15:39:08 <dibblego> you mean Collections?
15:39:22 <heatsink> No, there was a presentation called A Scala Corrections Library
15:39:28 <dibblego> I have not seen it
15:39:50 <heatsink> http://www.slideshare.net/extempore/a-scala-corrections-library
15:40:04 <dibblego> oh yes I have seen and heard of that, waiting for a video
15:43:00 <bitemyapp> dibblego: btw, <3
15:43:09 <dibblego> ha :)
15:43:10 <bitemyapp> dibblego: don't despair :)
15:43:39 <dibblego> I'm not, I'm about to head out for a ride instead
15:43:40 <bitemyapp> dibblego: the NICTA course was a massive help to me in not only understanding the Prelude more directly but helped me to be a better teacher of Haskell.
15:43:56 <bitemyapp> dibblego: ah, I'm envious, I'm between bikes at the moment. Thinking of getting a CBR600 or a dual-sport next.
15:44:02 <dibblego> nisstyre: I cannot find it, but it was around here http://www.reddit.com/r/scala/comments/1tijwv/a_review_by_edward_kmett_of_functional/
15:44:09 <dibblego> bitemyapp: I sold my YZF-R1 for a Triumph 800XC
15:44:13 <heatsink> dibblego, is this it? http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu
15:44:24 <dibblego> heatsink: yes thanks!
15:44:25 <bitemyapp> dibblego: fun? pros/cons?
15:44:43 <dibblego> the R1 will wheelstand from 170kph, the 800 only in first or second gear
15:44:54 <dibblego> but AU has lots of dirt tracks
15:44:56 <bitemyapp> heatsink: puffnfresh's wart-remover is also a litancy of scary Scala defaults.
15:45:06 <dibblego> and I am tired of puncture repairs on expensive tyres
15:45:14 <dibblego> anyway we are blahing
15:45:16 <bitemyapp> dibblego: I haven't ridden in the dirt since I was a teen. Miss that.
15:45:22 <bitemyapp> woops!
15:47:26 <heatsink> I noticed that many timing packages use getCPUTime, and getCPUTime has low precision.
15:47:35 <heatsink> getClockTime is more precise, but is deprecated.
15:47:52 <heatsink> Is there a time function with precision comparable to gettimeofday?
15:48:44 <heatsink> I'm measuring the elapsed time spent in an IO action.
15:49:55 <skypers> http://tryhaskell.org/#step8
15:50:06 <skypers> is the font Ubuntu Mono?
15:50:09 <mornfall> Twey: De Bruijn causes an awful lot of shifting...
15:50:57 <novochar> https://gist.github.com/novodinia/8679004
15:51:10 <novochar> I'm trying to load this file and step through it
15:51:14 <novochar> I'm failing to do so though
15:51:21 <novochar> The error is in that gist
15:51:35 <novochar> https://gist.github.com/novodinia/8679004#file-error-txt-L3 is probably the better link
15:51:39 <novochar> I want to load it
15:51:48 <novochar> Then I would I would like to step through the file
15:51:51 <novochar> setting break points
15:52:06 <novochar> How would you utilize the :back option as well?
15:52:25 <novochar> Sorry for all the newbish questions, just doing my best to become familiar with the debugging tools
15:53:43 <Twey> mornfall: But shifting is more more elegant than renaming, and doesn't carry around useless information all over the place
15:54:07 <Twey> much more**
15:55:00 <heatsink> It looks like Menlo, Skypers
15:55:02 <heatsink> skypers
15:56:57 <jle`> novochar: are you running with CPP?
15:57:23 <novochar> jle`: I don't know
15:57:39 <jle`> try adding {-# LANGUAGE CPP #-} at the top
15:57:41 <jle`> of the file
15:57:50 <mornfall> jle`: every time you use CPP, a kitten dies
15:58:03 <jle`> mornfall: he is trying to compile a file he found
15:58:06 <athan> hahahaha
15:58:13 <jle`> also i do'nt care much for kittens
15:58:22 <novochar> jle`: That gave many errors
15:58:25 <jle`> alternatively when you compile, -XCPP
15:58:34 <novochar> I will be back soon, thanks! I'll try -xcpp
15:58:35 <jle`> novochar: what kind of errors?
15:58:41 <jle`> -XCPP is the same as language cpp
15:58:46 <novochar> oh
15:58:50 <jle`> except at the command line level instead of the source code level
15:58:57 <novochar> bb soon
15:59:02 <jle`> bye
15:59:29 <skypers> heatsink: Menlo, ok, thank you
15:59:56 <mornfall> Twey: I don't dispute that.
16:00:19 <mornfall> (even if I thought I wanted to, I am too busy chewing)
16:06:39 <oakwhiz_> Why is an Int guaranteed to work up to +/- 2^29 and not +/- 2^31
16:07:30 <oakwhiz_> is there some architecture that GHC targets with 30 bit integers?
16:07:31 <Iceland_jack> @hackage Data.Int
16:07:32 <lambdabot> http://hackage.haskell.org/package/Data.Int
16:07:32 <heatsink> Some implementations use tagged words, where one or two bits hold other information
16:07:41 <jle`> i tag my words.
16:07:45 <shachaf> I think the idea was that some implementations could use a few tag bits.
16:07:56 <shachaf> But GHC does not. Nothing to do with architecture.
16:08:03 <shachaf> The Report isn't written for GHC.
16:08:30 <heatsink> I recall that some lisp implementations did that.  The low bit of each word would tell whether the word holds an integer or a pointer.
16:08:58 <jle`> http://stackoverflow.com/questions/3773985/why-is-an-int-in-ocaml-only-31-bits
16:10:57 <shachaf> GHC does use pointer tagging, but not for this. Int is boxed and machine-word-sized.
16:11:20 <oakwhiz_> So does this mean that on 32-bit x86 platforms, Int will work up to +/- 2^31?
16:11:47 <jle`> oakwhiz_: it depends on the implementation
16:11:56 <verement> > (minBound, maxBound) :: (Int, Int)
16:11:58 <lambdabot>  (-9223372036854775808,9223372036854775807)
16:12:20 <jle`> a 128-bit x86 platform might still only have  +/- 2^29
16:12:49 <jle`> or are you asking about GHC
16:13:14 <oakwhiz_> I was asking about GHC but that is still interesting since I know other compilers exist like ajhc
16:13:15 <heatsink> A typical 32-bit representation of Int cannot represent +2^31
16:14:43 <heatsink> It would be -2^31 .. 2^31 - 1
16:15:42 <Fuuzetsu> are POPL talks going to be up somewhere?
16:16:09 <heatsink> in 32-bit two's complement form
16:17:20 <oakwhiz_> > (toInteger (2^31 - 1 :: Int)) == (2147483647 :: Integer)
16:17:21 <lambdabot>  True
16:18:14 <jle`> totally forgot that toInteger existed
16:18:19 <verement> > maxBound :: Int32
16:18:20 <lambdabot>  2147483647
16:18:23 <Twey> Fuuzetsu: Yes, there will be videos and slides up for a month
16:18:35 <jle`> up for a month? or in a month?
16:18:39 <merijn> oakwhiz_: Report guarantees *at least* 27 bits for Int
16:18:48 <merijn> oakwhiz_: If you need exact sizes, use Word32/Int32
16:19:35 <oakwhiz_> merijn: thanks, I wasn't aware of those
16:20:19 <merijn> There's also 8, 16 and 64 bit versions
16:20:24 <mmachenry> What are those other bits being used for, exactly? Seems like Haskell and OCaml are both 31 bit integers or 63 bit integers. They are reserving one bit. Is that being used by the garbage collector or something?
16:20:45 <verement> it is used for the sign
16:20:48 <the_berserker> > fix$(<$>)<$>(:)<*>((<$>((:[{- Jörð -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
16:20:49 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:20:57 <mmachenry> And what am I losing if I use CInt instead?
16:21:15 <simpson> the_berserker: Salud.
16:21:21 <mmachenry> verement: Really? It's not stored the same way C stores singed integers?
16:21:26 <the_berserker> > iterate (*2) 1
16:21:27 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:21:32 <Twey> Hm, Fuuzetsu: Might be just proceedings.  There's a list of papers here: https://github.com/gasche/popl2014-papers
16:21:37 <heatsink> It's implementation-dependent, mmachenry
16:21:52 <verement> mmachenry: perhaps I misunderstood you
16:21:57 <merijn> mmachenry: CInt is guaranteed to match "int" on said platform
16:22:08 <merijn> mmachenry: But the C standard doesn't strictly define what size that is
16:22:16 <merijn> mmachenry: i.e. could be 32 bit, could be 64
16:22:26 <verement> could be 16!
16:22:27 <merijn> mmachenry: Could conceivably be 35 in some weird world
16:22:40 <merijn> verement: Not sure what minimum is guaranteed, either 16 or 32, yeah
16:22:43 <oakwhiz_> mmachenry: isn't CInt from the foreign function interface?
16:22:56 <the_berserker> @unpl fix$(<$>)<$>(:)<*>((<$>((:[{- Jörð -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
16:22:56 <lambdabot> (fix ((((<$>) <$> ((:))) <*> ((((\ l m -> m >>= l) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ f -> (\ d -> d) ((+) f) f)) 1))
16:23:28 <Twey> the_berserker: Yes, that's much more legible.
16:23:55 <mmachenry> merijn:  I know that and it doesn't address my question.
16:24:17 <merijn> mmachenry: oh, you mean why is Int different from CInt?
16:24:29 <mmachenry> Integers in C are architecture dependent. I know. But why on … yes. Why the 1 bit reserved?
16:24:48 <mmachenry> Is it for GC or flagging as some kind of type or what?
16:24:52 <merijn> mmachenry: 1) Up until Haskell98 there was no FFI in the report, and in 98 it was only an addendum
16:25:04 <heatsink> There are 2^32 values in [-2^31 .. 2^31-1]
16:25:17 <heatsink> no reserved bits
16:25:29 <mmachenry> Oh, maybe Simon Payton Jones wrote a small program that skims 1 bit off of every integer and drops them into some swiss integer account!
16:25:31 <merijn> mmachenry: Actually, since the report only guarantees 27 bits, there's 5 bits reserved, the idea was that implementations could use them for pointer tagging, GC, etc. whatever they wanted
16:25:55 <merijn> mmachenry: But GHC actually uses full machine words for Int (i.e. it doesn't reserve any bits)
16:26:05 <verement> mmachenry: Int in Haskell is only guaranteed to cover at least [-2^29 .. 2^29 - 1], i.e. 30 bits
16:26:33 <mmachenry> verement:  Yes yes, the question was "why".
16:26:41 <mmachenry> merijn:  Got it, thanks.
16:27:25 <verement> mmachenry: I thought this was already answered; some implementations might want to use a few bits for tagging
16:27:48 <mmachenry> verement:  Yes it was already answered.
16:31:33 <defanor> i want to parse Either String Int with parsec (there are separate cases for string and int, separated by <|>), what's the proper way to do it?
16:31:38 <verement> merijn: where do you get 27 bits/5 bits reserved?
16:32:02 <verement> merijn: was that the case for Haskell 98?
16:32:33 <Fuuzetsu> defanor: (Left <$> parseString) <|> (Right <$> parseInt)
16:32:59 <defanor> Fuuzetsu: thanks, will try
16:34:27 <defanor> Fuuzetsu: getting type `Either (ParsecT s1 u1 m1 [Char]) b0' this way
16:34:53 <defanor> oh, no, it's right
16:34:57 <defanor> wrote it wrong
16:35:21 <Fuuzetsu> I'm glad
16:36:01 <merijn> verement: I remember that from the 98 report, but I might be misremembering
16:37:59 <verement> looking at the report now, it looks like 30 bits [-2^29 .. 2^29 - 1]
16:38:02 <ReinH> Fuuzetsu: uh, doesn't that just throw away the left value?
16:38:08 <verement> same as in Haskell 2010
16:42:52 <monochrom> but GHC doesn't reserve. it gives you the full 32 bits or 64 bits
16:43:29 <monochrom> at the expense of using another 32 bits or 64 bits for what would go into reserved bits :)
16:44:05 <Fuuzetsu> ReinH: Why would it?
16:44:25 <hpc> but with the nice side benefit of being able to use the same memory layout for Int as everything else ;)
16:46:29 <ReinH> Fuuzetsu: Left "" <|> Right ""
16:46:33 <ReinH> er
16:46:39 <ReinH> > Left "" <|> Right ""
16:46:40 <lambdabot>  Right ""
16:47:03 <ReinH> because that's what alternate does (although for Either it requires a rather annoying Error instance)
16:47:16 <Fuuzetsu> ReinH: No, because the type isn't Either a b
16:47:24 <Fuuzetsu> It's ‘Parser (Either a b)’
16:48:05 <ReinH> ah
16:49:21 <Fuuzetsu> ReinH: http://lpaste.net/99190
16:50:48 * Fuuzetsu goes back to bed
16:56:04 <dhrosa> how do you do multi-line do's in lambdabot? I have a multi-line do that works in ghc but not on lambadbot
16:56:38 <Iceland_jack> :t do print 1; print 2
16:56:39 <lambdabot> IO ()
16:56:40 <maxiepoo> dhrosa, use ;
16:56:55 <Iceland_jack> :t do { print 1; print 2 }
16:56:56 <lambdabot> IO ()
16:57:04 <dhrosa> @pl fetch = do first <- readPMem16 =<< programCounter; second <- readPMem16 =<< ((+1) . programCounter); return (first, second)
16:57:05 <lambdabot> (line 1, column 50):
16:57:05 <lambdabot> unexpected ';'
16:57:05 <lambdabot> expecting letter or digit, variable, "(", operator, "=<<", ">>>", "^>>", "^<<", ">>", ">>=" or end of input
16:57:09 <dhrosa> that works in my ghc :(
16:57:13 <geekosaur> you may need (extra) braces sometimes, notably things like let will need an additional set of braces so it can tell where they end
16:57:16 <jrmithdobbs> :t print 1 >> print 2
16:57:17 <lambdabot> IO ()
16:57:30 <geekosaur> oh, @pl. it's not a full language parser
16:57:35 <dhrosa> aww
16:57:41 <geekosaur> @. pl undo fetch = do first <- readPMem16 =<< programCounter; second <- readPMem16 =<< ((+1) . programCounter); return (first, second)
16:57:41 <lambdabot> (line 1, column 43):
16:57:41 <lambdabot> unexpected "\\"
16:57:41 <lambdabot> expecting space
16:57:41 <lambdabot> ambiguous use of a left associative operator
16:57:51 <Iceland_jack> :t do first <- undefined =<< undefined; second <- undefined =<< ((+1) . undefined); return (first, second)
16:57:52 <lambdabot> a -> (t, t1)
16:57:53 <FUZxxl> 'Hello!
16:57:53 <Twey> dhrosa: (,) <$> (programCounter >>= readPMem16) <*> (readPMem16 >>= (+ 1) . programCounter)
16:57:54 <FUZxxl> Is there an open source PCP solver / brute forcer?
16:57:56 <FUZxxl> I know it's not decidable, but is there a program that tries?
16:58:10 <dhrosa> Twey: isn't that the same as liftM2?
16:58:12 <geekosaur> @undo fetch = do first <- readPMem16 =<< programCounter; second <- readPMem16 =<< ((+1) . programCounter); return (first, second)
16:58:12 <lambdabot> fetch = readPMem16 =<< programCounter >>= \ first -> readPMem16 =<< ((+ 1) . programCounter) >>= \ second -> return (first, second)
16:58:20 <Iceland_jack> :t do first <- ?readPMem16 =<< ?programCounter; second <- ?readPMem16 =<< ((+1) . ?programCounter); return (first, second)
16:58:21 <lambdabot> (Num a, ?readPMem16::a -> a1 -> t, ?programCounter::a1 -> a) => a1 -> (t, t)
16:58:22 <Twey> dhrosa: Yep, and liftA2
16:58:23 <FUZxxl> I have this CS assignment where the extra credt requires solving a certain PCP instance
16:58:33 <geekosaur> @pl fetch = readPMem16 =<< programCounter >>= \ first -> readPMem16 =<< ((+ 1) . programCounter) >>= \ second -> return (first, second)
16:58:33 <lambdabot> (line 1, column 43):
16:58:33 <lambdabot> unexpected "\\"
16:58:33 <lambdabot> expecting space
16:58:33 <lambdabot> ambiguous use of a left associative operator
16:58:38 <FUZxxl> but the program I wrote won't terminate.
16:58:46 <Twey> dhrosa: I prefer the <$> … <@> idiom, though, because it generalizes to n arguments
16:58:51 <Twey> Er, <*>
16:58:52 <geekosaur> also seems @pl is not good enough to handle that desugaring
16:59:03 <geekosaur> it is pretty mindless
16:59:23 <Twey> Isn't it just upset about not knowing operator precedence?
17:01:12 <Twey> @pl programCounter >>= (readPMem16 >>= (\ first -> ((+ 1) . programCounter) >>= (readPMem16 >>= (\ second -> return (first, second))))
17:01:12 <lambdabot> (line 1, column 131):
17:01:12 <lambdabot> unexpected end of input
17:01:12 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or ")"
17:01:59 <Twey> Er
17:02:02 <Twey> @pl programCounter >>= (readPMem16 >>= (\ first -> ((+ 1) . programCounter) >>= (readPMem16 >>= (\ second -> return (first, second)))))
17:02:03 <lambdabot> (((1 +) . programCounter >>=) . (`fmap` readPMem16) . (,) =<< readPMem16) =<< programCounter
17:09:19 <ReinH> how could cabal configure fail with requires Cabal library version 1.18.1 but no
17:09:28 <ReinH> if my Cabal is 1.18.1.2?
17:12:32 <ReinH> where is that constraint even coming from?
17:15:38 <FUZxxl> Is there an open source PCP solver / brute forcer?
17:16:31 <ReinH> never mind. That was weird.
17:19:33 <Platz> @unmtl MaybeT (State s) a
17:19:33 <lambdabot> (State s) (Maybe a)
17:30:14 <S11001001> @ty coerce
17:30:15 <lambdabot> (Functor f, Contravariant f) => f a -> f b
17:30:54 <Twey> ReinH: 1.18.1 and 1.18.1.2 are different versions in Cabal's versioning scheme (1.18.1 < 1.18.1.2)
17:31:13 <ReinH> Twey: right, but I don't even know how that constraint attached in the first place
17:31:18 <ReinH> I just blew some stuff away and started over
17:31:23 <Twey> Heh
17:34:09 * hackagebot vector-th-unbox 0.2.0.2 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2.0.2 (LiyangHu)
17:45:37 <lllllllllllll> is there a function to split a Text at whitespaces?
17:46:42 <m3ga> @hoogle words
17:46:42 <lambdabot> Prelude words :: String -> [String]
17:46:42 <lambdabot> Data.List words :: String -> [String]
17:46:42 <lambdabot> Data.String words :: String -> [String]
17:46:46 <m3ga> lllllllllllll: ^^^^
17:47:19 <m3ga> there's also a Data.Text.words and Data.Text.Lazy.words
17:47:37 <lllllllllllll> thx m3ga
17:47:46 <Hafydd> If you'd made even a cursory attempt to read the documentation, you'd have seen that.
17:49:54 <mm_bureau> Hafydd: searching for "split" or "whitespace" does not yield 'words'
17:50:03 <lllllllllllll> Hafydd, yeah sorry i somehow missed it
17:50:22 <mm_bureau> Hafydd: so no reason to be rude here
17:50:27 <Hafydd> mm_bureau: reading through the synopsis does.
17:50:52 <jle`> the synopsis?
17:51:07 <Hafydd> The list of values defined in Data.Text.
17:51:17 <mm_bureau> jle`: the stuff that is well hidden on the right side with the new haddock stylesheet
17:51:31 <jle`> ah.
17:51:51 <jle`> @hoogle Text -> [Text]
17:51:51 <lambdabot> Data.Text group :: Text -> [Text]
17:51:51 <lambdabot> Data.Text.Lazy group :: Text -> [Text]
17:51:51 <lambdabot> Data.Text inits :: Text -> [Text]
17:52:21 <mm_bureau> point is, 'words' isn't all that easy to find, when you're not familiar with the usual haskell idioms
17:52:41 <jle`> yup this is in clear violation of courtesy protocols.
17:52:48 <jle`> you have been eliminated.
17:52:58 * jle` eliminates
17:53:20 <m3ga> i'm pretty sure i wrote the words function myself a couple of times before finding it in the docs
17:53:27 <Hafydd> It's also in a section called "Substrings".
17:53:33 <m3ga> its a rookie mistake
17:54:00 <mm_bureau> Hafydd: so what, some people rely on their browser's search functionality and the idioms they have brought with them from other languages
17:54:10 <Hafydd> They shouldn't.
17:54:15 <mm_bureau> searching for "split" and "space" is a lot more common than "break" and "words"
17:56:32 <mm_bureau> the terms the usual perl programmer searches for will be more technical than semantic compared to what a haskell programmer searches for
17:57:09 <Sonarpulse> can one change the location of ghc-pkg databases, and communicate it to cabal?
17:57:19 <Hafydd> If you're not able to negotiate a structured piece of documentation, you just aren't living your life very effectively.
17:57:47 <Sonarpulse> I do not have root, but what like to have to cabal install --global in a directory which is accessible to multiple users
17:58:04 <Sonarpulse> cabal-install is fine getting a custom location for global installs
17:58:23 <Sonarpulse> but still tries to update ghc-pkg post-install in the normal location /var/...
17:58:23 <m3ga> and the haskell community should continue to be welcoming of newbies even one with bad habits learnt elsewhere
17:58:24 <mm_bureau> Hafydd: a physics textbook is well structured, yet you will have trouble finding things related to measurables, when their terminology for it is "hermitian operator"
17:59:17 <jle`> the point has been made for both sides, guys.  hate cannot drive out hate. only love can.
18:01:04 <mm_bureau> true
18:01:32 <mm_bureau> Sonarpulse: what's the purpose?
18:02:00 <Sonarpulse> i would like to install packages locally and globally
18:02:31 <mm_bureau> Sonarpulse: that doesn't answer my question…  /why/ do you want to install globally?
18:02:33 <Sonarpulse> but by globally i mean something besides /usr/local where multiple users including myself have apermisions
18:02:47 <Sonarpulse> to avoid redundant downloads
18:05:21 <mm_bureau> Sonarpulse: setting the --prefix doesn't do it?
18:05:33 <mm_bureau> Sonarpulse: (you can set it in ~/.cabal/config)
18:05:48 <Sonarpulse> --prefix affects only cabal things, not ghc pacakge
18:05:57 <mm_bureau> conal: what about --package-db?
18:06:00 <mm_bureau> uhm
18:06:05 <mm_bureau> Sonarpulse: what about --package-db?
18:06:24 <Sonarpulse> hmm
18:06:34 <Sonarpulse> that might help
18:06:55 <Sonarpulse> wish default value was included in generated config thoguh
18:07:08 <mm_bureau> if all else fails, tell the administrator to switch to NixOS =)
18:07:53 <Sonarpulse> hahah I'd like to, but this is my school
18:08:23 <Sonarpulse> at least we have debian
18:23:51 <Sonarpulse> mm_buraeu thanks!
18:24:02 <Sonarpulse> * mm_bureau
18:24:39 <Sonarpulse> might need to specify two to allow it to see packages installed via apt
18:24:53 <Sonarpulse> so there is my apt, my global and user dbs
18:25:02 <Sonarpulse> but even ignoring apt will still be useful
18:25:03 <Sonarpulse> thanks
18:32:25 <erisco> is there a way to create something for cabal which will automatically install the dependencies for my script?
18:33:59 <mirpa> erisco: could you be a little bit more specific?
18:34:46 <mirpa> what kind of dependency?
18:34:49 <erisco> I have a single .hs file. It imports packages that can be installed by cabal
18:34:56 <erisco> imports modules I should say
18:35:21 <cmears> I think "cabal init" does some package-guessing-from-imports
18:36:16 <mirpa> list packages of those imported modules in cabal file
18:36:38 <mirpa> build-depends option
18:37:46 <erisco> hmm not sure I understand. I don't want a package per se
18:38:06 <erisco> I would just prefer to execute one command that installs all the necessary packages
18:38:13 <Twey> ‘cabal install’ :þ
18:38:20 <erisco> yeah I guess
18:38:37 <mirpa> if you use Data.Vector then you need 'vector' package listed in build-depends ...for example
18:39:24 <mirpa> cabal will tell you, if you are missing such dependency in cabal file
18:39:39 <mirpa> cabal configure && cabal build
18:39:48 <mirpa> or cabal install
18:40:33 <andresrtm> hello everyone, i'm newbe
18:40:58 <FUZxxl> andresrtm: Hello!
18:40:58 <meretrix> My application is mostly idle, but wakes up every 200ms to do a simple check.  Without "-threaded", it uses about 0.5% cpu. If I enable "-threaded", it used about 2x more cpu for every core, so with 32 cores, it used about 400
18:41:03 <FUZxxl> Welcome to Go!
18:41:13 <meretrix> %cpu.  Why is this?
18:41:44 <meretrix> I disabled "idle GC", which helps, but still get spikes of 50% cpu. Is that normal?
18:42:36 <geekosaur> meretrix, what version of ghc?
18:42:40 <meretrix> 7.6.3
18:43:21 <meretrix> Is the threaded runtime just not efficient for mostly idle processes?
18:43:29 <andresrtm> i'm learning haskell, and i try to build an app with Happstack to retrive latest tweets from my timeline from twitter :)
18:44:28 <andresrtm> i'm follow this https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
18:44:46 <levi> Happstack doesn't seem like quite the right tool to grab things from twitter. But if you've got a tutorial you're following, don't mind me. :)
18:45:22 <shackleford> So, I really like Haskell, and have a morbid fascination with compilers. Any ideas on what to attempt after Write Yourself a Scheme?
18:46:42 <levi> meretrix: You should probably not scale a ghc 7.6.3 app to that many cores. The ghc 7.8 runtime is supposed to scale better to higher numbers of cores.
18:47:38 <carter> meretrix: ghc HEAD has much better behavior in the >= 8 cores regime
18:47:46 <carter> and GHC 7.8 is due to come out very very soon
18:47:58 <carter> GHC will have Win64 support for the first time in years too!
18:48:12 <carter> or will resume having less broken windows support :)
18:48:25 <carter> but yeah, if you are using MANY cores, have a go building GHC head
18:48:27 <carter> and using that
18:48:37 <carter> because travis CI is a thing, for a change most libs work with HEAD :)
18:48:47 <andresrtm> for learning purposes, i try to make a REST service with my last tweets
18:49:16 <carter> cool
18:49:20 <carter> andresrtm: hows that gong?
18:49:25 <carter> *going
18:50:00 <andresrtm> i'm use this for  https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json fetch tweets, but i can't connect with Happstack
18:51:04 <carter> why not?
18:51:09 <carter> are you using AESON?
18:51:13 <carter> connect how?
18:52:08 <andresrtm> yes, i'm using aeson
18:52:55 <andresrtm> i try :
18:52:57 <andresrtm> tweetPage :: S.ServerPart S.Response
18:53:00 <andresrtm> tweetPage = S.ok $ S.toResponse $ timeline "andresrtm"
18:53:09 <andresrtm> using timeline function for tutorial
18:53:31 <andresrtm> but i got Couldn't match type `[]' with `IO'
18:54:11 <andresrtm> i'm newbie, and i don't understad well IO monad or somerhing
18:54:35 <xpika> is there a combinator for maybe where when you compose them will return the first Just value?
18:56:10 <xpika> eg. (Just 3) `op` (Just 6) `op` Nothing => Just 3
18:56:17 <FUZxxl> xpika: try mappend
18:56:31 <FUZxxl> From the Monoid typeclass
18:56:36 <FUZxxl> >
18:56:44 <shachaf> mappend will not do it, unless you use First (the newtype from Data.Monoid).
18:57:14 <shachaf> mplus -- or, better, <|> from Control.Applicative -- will do it
18:57:17 <FUZxxl> > Just 0 <|> Just 1
18:57:18 <lambdabot>  Just 0
18:57:23 <FUZxxl> Ah yes
18:57:56 <xpika> FUZxxl: excellent
19:00:49 <Tekmo> xpika: Also, to do this for a list of values using `msum` from `Control.Monad`
19:01:22 <andresrtm> carter http://lpaste.net/99198
19:01:41 <carter> if you want to do a REALLY simple REST service, people tend to reocmmend scotty as being super nice and simple
19:02:02 <carter> andresrtm: you seem to be missing some imports
19:02:17 <carter> module Main where
19:02:19 <carter> import FOO
19:02:24 <carter> import Baz
19:02:25 <carter> etc
19:02:25 <carter> :)
19:03:04 <andresrtm> carter, i'm only put few code, but i will put all
19:03:17 <carter> well, partial code is like seeing a foot,
19:03:20 <carter> you know a person may be there
19:03:25 <carter> but you cant tell if theyr'e alive
19:03:26 <carter> :P
19:03:39 <carter> i g3g
19:03:46 <carter> but others will be happy to help
19:03:58 <fragamus> offtopic question: there's some old code that calls these two functions: V3MulPointByMatrix and V3MulVectorByMatrix.    Can anyone conjecture what the difference is
19:04:18 <carter> yup
19:04:21 <fragamus> the functions source is not available
19:04:23 <carter> yup
19:04:24 <carter> fragamus:
19:04:25 <carter> ;)
19:04:54 <fragamus> offtopic question: there's some old code that calls these two functions: V3MulPointByMatrix and V3MulVectorByMatrix.    Can anyone conjecture what the difference is
19:05:06 <fragamus> (since edwardk just joined)
19:05:18 <sccrstud92> fragamus: points and vectors are different things
19:05:20 <carter> yes
19:05:27 <carter> point == scalar
19:05:36 <sccrstud92> fragmus: is the matrix representats a translation that translation will affect the poinbt but no the vector
19:05:47 <carter> oh its game code
19:05:49 <carter> yeah ;)
19:06:20 <fragamus> well I need to conjure the definitions of these
19:06:36 <edwardk> fragamus: guessing x*M and m*x
19:06:38 <edwardk> oh point vs vector
19:06:40 <edwardk> so its whether you include translation
19:06:45 <edwardk> pretend the Point x y z  = x y z 1   an Vector x y z = x y z 0
19:06:50 <FUZxxl> Can anybody here help me with this PCP instance?
19:07:16 <fragamus> so if I have a 4x4 matrix I would add a one on the end of the vector right?
19:07:17 <edwardk> then the translation component won't affect the vector (see the 0) but it will afffect the vector (due to the 1)
19:07:30 <fragamus> zero
19:07:36 <sccrstud92> this is for a 4x4 matrix, correct ed?
19:07:36 <fragamus> yah
19:07:44 <fragamus> yay thanks guys
19:07:52 <fragamus> all the best brains on this channel
19:08:27 <fragamus> and sorry for the offtopicness
19:11:16 <\Tau> is here the most autistic channel on freenode
19:12:22 <FUZxxl> \Tau: I don't think so.
19:12:44 <\Tau>  FUZxxl i dont have good memories from here.
19:13:22 <FUZxxl> This is a nice place. Let me demonstrate.
19:13:38 <\Tau> alright.
19:13:46 <FUZxxl> Can anybody explain me what a histomorphism is?
19:14:06 <sccrstud92> @wiki Histomorphism
19:14:07 <lambdabot> http://www.haskell.org/haskellwiki/Histomorphism
19:14:19 <sccrstud92> i just wanted to see if that worked lol
19:14:39 <FUZxxl> \Tau: See? Helpful people everywhere
19:14:50 <FUZxxl> Even the bots are helpful
19:15:09 <FUZxxl> Still, nobody wants to help me with my PCP instance...
19:15:34 <FUZxxl> Perhaps I am in the wrong neighborhood with my *actually relevant concrete problems*
19:15:44 <pavonia> @where Histomorphism
19:15:44 <lambdabot> I know nothing about histomorphism.
19:15:47 <Tekmo> FUZxxl: I don't even know what PCP is
19:15:57 <FUZxxl> PCP: Posts correspondence problem
19:16:02 <\Tau>  FUZxxl i think they help because they want to expose themselves as capable of solving problems. it is merely ego not helpful intention.
19:16:08 <jrmithdobbs> i know what PCP is, but I doubt it's the one he's referring to
19:16:31 <sccrstud92> did you know you can get PCP by the gallon?
19:16:35 <sccrstud92> science man
19:17:06 <pavonia> sccrstud92: Did you make any progress with your space leak problem?
19:17:29 <sccrstud92> johnw and snoyman said it was a problem with attoparsec
19:17:34 <sccrstud92> in this specific instance
19:18:02 <pavonia> So were you able to fix it?
19:18:49 <Tekmo> Fuuzetsu: So what's the problem?
19:18:51 <sccrstud92> i just found the messages he left
19:18:52 <jrmithdobbs> sccrstud92: oh? can you elaborate?
19:19:12 <Tekmo> Oops
19:19:23 <Tekmo> FUZxxl: So what's the problem
19:19:36 <sccrstud92> jrmithdobbs: i wrote a counting sort implementation that included a parser
19:19:38 <FUZxxl> Tekmo: How can I find the minimal solution for the PCP instance ((aaba, baab, a), (a, aa, aab))
19:19:47 <sccrstud92> the input was a file with 1000001 lines
19:20:00 <FUZxxl> The excercise says it can be done in less than 1000 pairs
19:20:03 <sccrstud92> and i was getting a space leak
19:20:07 <jrmithdobbs> and attoparsec is holding on to the whole thing?
19:20:14 <Tekmo> FUZxxl: Do you have an lpaste I can look at?
19:20:21 <FUZxxl> Tekmo: lpaste?
19:20:24 <sccrstud92> i dont understand what the problem was exactly
19:20:31 <FUZxxl> I wrote some code to brute force it, yes.
19:20:33 <sccrstud92> but something along those lines i think
19:20:38 <FUZxxl> http://fuz.su/~fuz/pcp.go
19:20:49 <jrmithdobbs> sccrstud92: i ask because i'm chasing something similar, do you have the code pasted somewhere? ;p
19:20:56 <FUZxxl> It's not exactly in Haskell though
19:21:24 <Tekmo> FUZxxl: So do you want to translate it to Haskell?
19:21:29 <FUZxxl> No.
19:21:30 <jrmithdobbs> FUZxxl: so, you're trolling then and don't want help?
19:21:50 <FUZxxl> I want to know whether it can be solved intelligently, i.e. faster than through brute force.
19:22:10 <sccrstud92> jrmithdobbs: is there a way to find old pastes ive made?
19:22:44 <Tekmo> sccrstud92: Yes
19:23:02 <FUZxxl> It's a bit offtopic but I think #haskell contains quite a lot brilliant people who can give excellent advise
19:23:05 <sccrstud92> oh i found it
19:23:10 <Tekmo> sccrstud92: http://lpaste.net/browse?author=YourName&page=0
19:23:12 <sccrstud92> jrmithdobbs: http://lpaste.net/99155
19:23:25 <sccrstud92> i should not post anonymously next time
19:24:07 <sccrstud92> jrmithdobbs: profile http://lpaste.net/99156
19:24:22 <sccrstud92> entryParser makes most of the allocations
19:24:56 <FUZxxl> \Tau: Ever been to #jsoftware?
19:25:05 <sccrstud92> the guys helping me wrote a manual parser
19:25:07 <sccrstud92> https://www.fpcomplete.com/project/18089/jcIzIr8hbb
19:25:10 <FUZxxl> These guys write programs less legible than perl scripts
19:25:19 <sccrstud92> they said it uses a lot less memory
19:25:30 <Tekmo> FUZxxl: So wikipedia says this problem is undecidable
19:25:44 <FUZxxl> Tekmo: It's undecidable in general.
19:26:20 <FUZxxl> The halting problem is also undecidable in general yet we can definitly decide it in certain instances.
19:27:13 <Tekmo> FUZxxl: So what's the reason you want to solve this problem?
19:27:51 <FUZxxl> Tekmo: It's extra credit for college homework.
19:28:14 <sccrstud92> FUZ: what class?
19:28:14 <Tekmo> FUZxxl: So I haven't studied your Go solution just yet, but if it were me I would just do some sort of backtracking search
19:28:19 <FUZxxl> I've already given up on solving it on my own. Deadline is 10 hours from now, but I really want to know how to solve this
19:28:33 <Tekmo> FUZxxl: Haskell makes backtracking searches easy, especially if you use something like the `logict` library
19:28:42 <FUZxxl> It's called ETI (Einführung in die theoretische Informatik; Introduction to theoretical computer science)
19:28:47 <carter> theres a lot of neat solver  libs
19:28:51 <carter> though theres room for moe
19:29:15 <FUZxxl> carter: Any pointers?
19:29:21 <carter> SO MANY
19:29:28 <Tekmo> FUZxxl: I'll see if I can sketch a simple backtracking solver for you
19:29:45 <FUZxxl> Tekmo: That could be wonderful
19:30:08 <FUZxxl> I think it is important that the solver accounts for loops
19:30:16 <Tekmo> What do you mean?
19:30:47 <FUZxxl> If you have a collection of PCP pairs, you have the upper and lower string.
19:30:59 <FUZxxl> One is a prefix of the other, the difference is called "overhang"
19:31:21 <FUZxxl> In a minimal PCP solution, the same overhang never occurs twice for if it did, you could remove the string inbetween
19:31:31 <FUZxxl> this is a loop
19:31:33 <sccrstud92> this reminds me of the type of problems solved in those functional pearls things
19:32:15 <FUZxxl> (none of these words are in any way official or in common usage)
19:32:26 <FUZxxl> I SHOULD probably go to bed anyway, it
19:32:37 <FUZxxl> I SHOULD probably go to bed anyway its already 4:30 AM
19:32:54 <FUZxxl> Thank you all for your help!
19:33:02 <Tekmo> You're welcome
19:34:35 <carter> FUZxxl: go sleep
19:34:37 <carter> its important
19:34:55 <m3ga> says "carter the man who never sleeps"
19:34:59 <FUZxxl> carter: Yeah, thank you. First class is 1 PM tomorrow
19:35:59 <oakwhiz_> I just cut and pasted some example code, tweaked it to make it work, and now I'm seeing some neat 3D graphics. Amazing!
19:36:05 <Tekmo> FUZxxl: Sleep improves retention of things you learn
19:36:49 <carter> yes
19:36:58 <carter> i have terrible sleep health problems
19:37:55 <joelteon> which means that we get GHC hacked on faster, so I'm ok with it
19:38:08 <m3ga> carter: those only get worse as you get older.
19:39:20 <johnw> sccrstud92: ping
19:39:20 <carter> joelteon: nope
19:39:31 <joelteon> :X
19:39:35 <sccrstud92> johnw: hey
19:39:37 <carter> joelteon: mean i get nothing done but argue on email threads and comment on tickets
19:39:41 <johnw> sccrstud92: I wouldn't say it's a problem in attoparsec per se, but in the way that the parser builds its results into a list.  If you iterate over the input and store the results in a mutable, unboxed vector, that's what makes the difference
19:40:01 <sccrstud92> johnw: my mistake
19:40:15 <carter> granted, m3ga  rightly thinks it important that osmeone who understands GHC intervenes on those threads
19:40:27 <carter> lets at X to ghc
19:40:35 <sccrstud92> how can it be stored in a uvector if its not a primitive type?
19:40:38 <m3ga> true
19:40:42 <johnw> sccrstud92: I was ever getting ready to make a problem report with bos, but we were able to reproduce the memory blowout using a simplistic parser with a list accumulator
19:40:54 <carter> me : "no, ghc actually has enough  nice stuff that you can do that as a user land library"
19:40:54 <sccrstud92> bos?
19:41:01 <johnw> Brian O'Sullivan
19:41:06 <johnw> or Bryan, I guess
19:41:11 <sccrstud92> attoparsec maintainer im guessing?
19:41:14 <johnw> yeah
19:41:22 <carter> them: "but it won't be as pretty because we'll have to deal with linkers instead of you dealing with linkers"
19:41:39 <carter> me : "so? its easier to patch if its userland"
19:41:51 <sccrstud92> so johnw
19:41:58 <sccrstud92> if you are parsing a list of n things
19:42:07 <sccrstud92> is the memory used greater than O(n)?
19:42:10 <carter> then m3ga  : "the fact that you can do it user land and admit that the start of the thread speaks for itself, please try that first in earnest"
19:42:26 <carter> *that at the
19:43:39 <johnw> sccrstud92: it shouldn't be, but the factor at each n is larger than you might think
19:43:59 <johnw> it's 1,000,000 elements, and we were seeing ~600 MB of memory used, so 600 bytes per elements
19:44:25 <sccrstud92> so half gave ~300 MB?
19:44:37 <johnw> with a mutable, unboxed vector and a custom data type with unboxed fields, we got it down to ~10 bytes per element
19:44:42 <johnw> sccrstud92: I didn't actually test with half
19:44:48 <johnw> I leave that as an exercise to the reader :)
19:44:52 <sccrstud92> hahaha
19:45:01 <sccrstud92> very cool
19:45:14 <sccrstud92> so basically with a custom parser
19:45:22 <sccrstud92> you just need lazy IO
19:45:31 <sccrstud92> and small bytes/element
19:45:35 <sccrstud92> and I should be okay?
19:45:42 <AshyIsMe> is there a good library for abstracting out database storage in haskell?
19:45:51 <johnw> yep
19:45:58 <AshyIsMe> i'd like to be able to swap in mongodb or riak as a backend
19:46:02 <Tekmo> sccrstud92: Why are you parsing a list of things, though?
19:46:12 <AshyIsMe> and if i could also swap in postgresql aswell that'd be pretty sweet
19:46:17 <sccrstud92> Tekmo: I implementing counting sort
19:46:25 <AshyIsMe> preferably without having to write a lot of manual mapping code
19:46:26 <Tekmo> sccrstud92: Carry on, then :)
19:46:38 <m3ga> AshyIsMe: Persistent does mongo, postgres and others. not sure about riak.
19:46:46 <sccrstud92> Tekmo: ty =) I like ur working btw
19:46:52 <Tekmo> sccrstud92: Thank you :)
19:47:24 <sccrstud92> does spj ever show up here?
19:47:39 <AshyIsMe> m3ga: ah cool, thanks
19:47:59 <Tekmo> sccrstud92: I've never seen him on here
19:48:09 <m3ga> sccrstud92: i've never knowingly seen him on irc. the other simon used to show up on other haskell related channels.
19:49:01 <sccrstud92> johnw: thanks for everything btw. and snoyman
19:49:47 <johnw> sccrstud92: sure thing, I'll let him know
19:49:48 * shapr grins evilly
19:50:00 <johnw> hi shapr!
19:50:03 <shapr> sccrstud92: not in many years
19:50:06 <shapr> oh hai johnw!
19:50:16 <shapr> johnw: How's the life of a paid Haskeller treating you?
19:51:11 <johnw> very nicely
19:51:22 <shapr> johnw: Writing anything nifty lately?
19:51:34 <shapr> johnw: had any flashbacks of TC++ ? :-)
19:51:46 <johnw> shapr: I've been adding functions to stm-conduit
19:51:59 <johnw> in fact, I'm writing a new function for conduit right now
19:52:11 <shapr> cool!
19:52:22 * m3ga knows for a fact that johnw is not the *only* paid haskeller around here :-)
19:52:46 <shapr> m3ga: are you a paid haskeller?
19:53:20 <m3ga> when i code at work its haskell (and yesod). do more management etc than i'd like to.
19:53:24 <Tekmo> If anybody is looking for a Haskell job, Facebook is hiring Haskell programmers
19:53:37 <shapr> Tekmo: Are you working at facebook?
19:53:39 <Tekmo> No
19:53:44 <shapr> aw
19:53:45 <Tekmo> I'll be working at Twitter in Feburary
19:53:47 <shapr> I could go for a Haskell job.
19:53:50 <shapr> Tekmo: yay!
19:53:57 <Tekmo> I got an offer from Facebook, but I preferred Twitter
19:54:05 <shapr> I haven't applied to either of them.
19:54:13 <Tekmo> They are both great companies
19:54:37 <mcjohnalds> The last sentence for the documentation of .= in the lenses package....      hackage.haskell.org/package/lens-3.10.1/docs/Control-Lens-Setter.html#v:.-61-
19:54:57 <edwardk> mcjohnalds: ahahahah
19:55:07 <edwardk> mcjohnalds: forgot about writing that
19:55:18 <edwardk> oh its linked, ba
19:55:27 <mcjohnalds> edwardk: You did that?
19:55:48 <shapr> edwardk: hey, I have a simple math question about incremental averages... should I ask on some other channel?
19:55:57 <johnw> #incrementalaverages
19:55:59 <edwardk> mcjohnalds: yeah, slow day =)
19:56:33 <edwardk> shapr:  terriberry's or chan's algorithm solves it well
19:56:46 <edwardk> shapr: just shoot and i'll tackle it as i get time
19:57:26 <shapr> I'm worried that the act of phrasing the question will cause the answer to be lazily fetched from my mind.
19:57:33 <novochar> Would someone point me to an example of how you would go about stepping through an application with ghci and setting break points, using the :back functionality, etc.?
19:58:01 <edwardk> shapr: then phrase it and explain it to the rabbit that is the channel. ;)
19:58:13 * shapr looks around for the rabbit
19:58:13 <edwardk> shapr: in the process you learn one way or the other
19:58:17 <shapr> heh, fair enough
19:58:31 <m3ga> oh wow, i know terriberry. didn't know he had an algorithm named after him :-)
19:59:23 <novochar> brb
20:02:42 <shapr> Is there really a rabbit on this channel?
20:03:04 <dsrx> not on the channel... it is the channel
20:05:36 <edwardk> shapr: i was referring to the habit of explaining things to the stuffed rabbit you used to have here in boston ;)
20:05:46 <shapr> ohhhh, THAT rabbit
20:05:53 <shapr> I gotta find that rabbit
20:07:20 <shapr> I gotta take it to work.
20:07:35 <shapr> and put it on my monitor like I had it setup in Boston.
20:08:33 <shapr> In case anyone is wondering, I had the rabbit up as an example of http://c2.com/cgi/wiki?CardboardProgrammer
20:11:40 <andresrtm> hello again, i put a simple example in http://lpaste.net/99198 to use happstack and twitter but doesn't works :( in a terminal works but not in a browser
20:12:23 <sccrstud92> shapr: like this http://en.wikipedia.org/wiki/Rubber_duck_debugging?
20:13:05 <shapr> sccrstud92: Yeah, rubber ducking is another term for that.
20:13:26 <dagle> andresrtm: I might be tired and wrong, but maybe you shouldn't share your keys like that?
20:13:29 <shapr> I think I may substitute the GNU I bought from RMS in place of the rabbit.
20:14:24 <andresrtm> dable: sure, i remove the keys after resolve :)
20:16:48 <heatsink> Are there extra steps involved in compiling Template Haskell on OS X?  When I try, GHC can't load imported modules.
20:17:44 <heatsink> It works with 7.4.1, but not 7.7
20:19:27 <pavonia> andresrtm: What behaviour do you get when browsing the latest_tweets page?
20:20:58 <heatsink> Ah—it's bug #8180.
20:22:32 <andresrtm> pavonia, i can't compile, i got "No instance for (ToMessage (IO (Either String [Tweet])))" Error
20:22:42 <heatsink> Then the next question is, how do I get cabal to pass the -dynamic-too flag to GHC?
20:24:00 <L8D> Is there a difference between (
20:24:03 <darkf> Is there a way to use, say, `Rand g a` inside a `RandT g m a` (from MonadRandom) without `runRand`ing them and mucking with the generator? I'd like one function to be in IO but the rest not
20:24:06 <pavonia> andresrtm: Does "liftIO (timeline "Hackage") >>= \res -> ok (toResponse res)" work?
20:24:08 <L8D> ((a, b), c) and (a, b, c)
20:24:24 <shapr> edwardk: speaking of Boston... I ran across a funny quote recently
20:24:27 <shapr> @quote accent
20:24:27 <lambdabot> shapr says: Luckily, I still had my Alabama tag, the thickest Alabama accent I could dredge up, and I'd just had one of my front teeth knocked out at a sci-fi con, so I got out of the ticket.
20:24:32 <andresrtm> pavonia: i learning, and i try to get lastest tweets in json, in the Main works with case stament, but i don't know how works in response
20:24:40 <andresrtm> pavonia: i'll try
20:24:52 <edwardk> oh yeah. forgot about the toot
20:24:54 <L8D> WHY CAN'T TUPLES BE SIMPLE?
20:25:08 <L8D> LIKE FUNCTIONS
20:25:09 <shapr> edwardk: it nearly fell on you :-P
20:25:10 <L8D> gawd
20:25:32 <pavonia> andresrtm: The problem is you can't convert an IO action to a Response, you have to run it first and pass the result to toResponse
20:25:33 <enthropy> (a -> b) -> c isn't the same as (a -> b -> c)
20:25:44 <edwardk> L8D: yes there is a difference
20:25:46 <enthropy> L8D: functions are so complicated
20:26:19 <L8D> oh yeah...
20:26:31 <L8D> because tuple in and of themselves, are types too
20:26:39 <L8D> gawd damnit
20:26:48 <Twey> L8D: They're isomorphic but different types, unfortunately.
20:26:49 <heatsink> Tuples _have_ types
20:26:58 <andresrtm> pavonia: and how can run the IO action with the liftIO ?
20:27:08 <L8D> I thought it would have been beautiful if (,) (1,2) 3 == (1, 2, 3)
20:27:11 <darkf> or, more generally, is there a way to drop from a monad transformer to the non-transformed monad?
20:27:35 <edwardk> L8D: the issue is you accumulate extra bottoms
20:27:41 <pavonia> andresrtm: It should lift it to whatever server monad happstack is using
20:27:48 <Twey> L8D: The usual formulation is that (a, b, c) = (a, (b, (c, ())))
20:27:52 <edwardk> L8D: so while initially appealing it has other problems
20:28:09 <L8D> Twey: I thought everyone just disproved that
20:28:18 <Twey> Or (a, (b, c)) at least
20:28:20 <Twey> L8D: Hm?
20:28:21 <heatsink> darkf, you can lift operations from the underlying monad into the transformed monad
20:28:28 <heatsink> :t lift
20:28:28 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
20:28:32 <Twey> How does one ‘disprove’ a tuple?  :þ
20:28:40 <darkf> heatsink: yeah, I want to do the opposite (RandT to Rand)
20:28:41 <L8D> Twey: if that was the case, then (a -> (b -> c)) is the same as (a -> b -> c)
20:28:43 <L8D> oh wait
20:28:46 <L8D> ...
20:28:49 <L8D> nvm
20:28:57 <Twey> L8D: It's not the case in Haskell, mind
20:29:04 <Platz> darkf: wouldn't the monad transformer have to provide a special function to unwrap the monadic value?
20:29:08 <L8D> > (,) 1 (2, 3)
20:29:09 <lambdabot>  (1,(2,3))
20:29:13 <L8D> :(
20:29:15 <L8D> I wanna cry
20:29:21 <Twey> But languages like Agda or Idris adhere to that convention, so you can write functions on arbitrary tuples that start with a particular prefix
20:29:22 <darkf> or rather Rand to RandT, actually
20:29:50 <darkf> Platz: I'm assuming it does, which is sad because I want to promote non-IO-using functions to IO-using ones :)
20:29:58 <heatsink> I don't think there's a general way to do that
20:30:02 <L8D> Twey: is it possible to implement that kind of behaviour in haskell?
20:30:13 <Twey> L8D: Sure; I posted something along those lines the other day
20:30:25 <L8D> Twey: link! link! link!
20:30:33 <Twey> L8D: http://lpaste.net/99120
20:31:37 <Twey> L8D: HList is basically a heavyweight implementation of this (with batteries included)
20:32:04 <Twey> Vinyl is similar but the components get names
20:32:07 <Platz> darkf: can't you just map the non-io function over the IO value ?
20:32:27 <L8D> Twey: Why doesn't haskell adhear to this? It would make a ton a class instances easier
20:32:45 <Tekmo> darkf: If you implement `MFunctor` for `RandT`, then you can just do `hoist generaliez`
20:32:59 <andresrtm> pavonia: i'm confused, should be "dir "latest_tweets" $ liftIO (timeline "Hackage") >>= \res -> ok (toResponse res)" or how?
20:33:15 <Tekmo> hoist generalize :: (Monad m, MFunctor t) => t Identity a -> t m a
20:33:20 <L8D> > 1, 2
20:33:21 <lambdabot>  <hint>:1:2: parse error on input `,'
20:33:38 <pavonia> andresrtm: I think so
20:34:08 <Twey> L8D: I don't know specifically why; it may just be a historical accident.  There are some disadvantages too, though (as edwardk says, you get extra bottoms, and tuple lookup becomes O(n) in the length of the tuple instead of constant-time unless your compiler optimizes it out)
20:34:10 <andresrtm> pavonia: that generate "No instance for (ToMessage (Either String [Tweet])) arising from a use of `toResponse'"
20:34:22 <Twey> I agree that it would be nicer, though
20:34:30 * hackagebot x509-store 1.4.4 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.4.4 (VincentHanquez)
20:34:33 <edwardk> its the bottoms that really force the issue
20:34:37 <Twey> L8D: Currently GHC just has tuple types hardcoded for 2 through 36 ☺
20:34:56 <pavonia> andresrtm: (toResponse $ show res)
20:35:05 <edwardk> its ugly but think of it instead as the equivalent to people making data Foo a b c = Foo a b c for you for all sizes
20:35:08 <L8D> Twey: perhaps it's because they wanted tuples to be compatible with products and those things that use braces
20:35:12 <edwardk> and giving it special syntax
20:35:12 <heatsink> Huh, I didn't know that
20:35:22 <pavonia> andresrtm: But this is just to check if it works
20:35:24 <edwardk> rather than the more heterogeneous list style you're talking about
20:35:40 <heatsink> :t (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37)
20:35:41 <lambdabot> (Num t, Num t1, Num t2, Num t3, Num t4, Num t5, Num t6, Num t7, Num t8, Num t9, Num t10, Num t11, Num t12, Num t13, Num t14, Num t15, Num t16, Num t17, Num t18, Num t19, Num t20, Num t21, Num t22, Num t23, Num t24, Num t25, Num t26, Num t27, Num t28, Num t29, Num t30, Num t31, Num t32, Num t33, Num t34, Num t35, Num t36) => (t, t1, t2, t3, t4, t5,
20:35:41 <lambdabot>  t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36)
20:35:52 <Twey> edwardk: That doesn't really feel right to me
20:36:00 <ihm123> quit
20:36:02 <Twey> heatsink: Hm, maybe not 36; there's some number, though
20:36:03 <edwardk> the problem with (a, (b,(c,(d,..)))) is getting to z takes 26 dereferences!
20:36:23 <edwardk> but getting to z in (a,....,z) is O(1)
20:36:39 <Twey> :t (1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8)
20:36:40 <lambdabot>     A 64-tuple is too large for GHC
20:36:40 <lambdabot>       (max size is 62)
20:36:40 <lambdabot>       Workaround: use nested tuples or define a data type
20:36:47 <heatsink> ah
20:36:47 <Twey> 62 apparently
20:36:55 <andresrtm> pavonia: yes ! that works
20:37:38 <Twey> edwardk: It would be a fairly trivial optimization to expose a recursive API but flatten it during compilation, though, no?
20:37:49 <shachaf> trivial!
20:38:03 <heath> shapr!
20:38:04 <shachaf> Are you suggesting unlifted products?
20:38:10 <edwardk> Twey: and when someone takes your flat rep and bolts something on th front?
20:38:17 <edwardk> Twey: and its polymorphic?
20:38:37 <andresrtm> pavonia: why "just to check if it works" ?
20:38:39 <edwardk> Twey: garbage collector interactions, representational issues, all sorts of things drop out of this
20:38:44 <mirpa> Q: Data.Ix is part of Base package and that is part of Ghc so bug report for Data.Ix goes to Ghc?
20:38:49 <magicman> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:38:49 <lambdabot>     A 69-tuple is too large for GHC
20:38:49 <lambdabot>       (max size is 62)
20:38:49 <lambdabot>       Workaround: use nested tuples or define a data type
20:38:50 <Twey> Oh, that's unfortunate
20:39:05 <magicman> Heh. My GHCi gave a type to that.
20:39:15 <magicman> But it gave the same error with the filled-in one O_o
20:39:18 <Twey> I'd assume the polymorphism wouldn't be a problem, though — the elements of the tuple don't have to be forced, just the spine
20:39:24 <pavonia> andresrtm: Well, the output now is just plain text, right?
20:39:31 * hackagebot tls 1.2.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.2 (VincentHanquez)
20:40:57 <andresrtm> pavonia: right, like "Right [Tweet {text = "ve....."
20:41:04 <enthropy> Twey: have you seen my https://github.com/aavogt/DimMat ?
20:41:29 <enthropy> is an example of hlist-y stuff where the underlying data is stored in something more compact
20:41:54 <pavonia> andresrtm: Yeah, the next step probably would be displaying that as HTML code
20:42:33 <heatsink> Twey, as I recall, that kind of flattening is one of the things that the TIL compiler did
20:42:48 <Twey> heatsink: TIL?
20:43:05 <heatsink> Um... the one Greg Morrisett and David Tarditi worked on
20:43:15 <heatsink> with Robert Harper I think
20:43:40 <Twey> Hm, an ML compiler
20:43:49 <Twey> Neat, thanks
20:43:53 <andresrtm> pavonia: i was trying display it in JSON
20:44:07 <mirpa> or to Haskell Platform?
20:46:12 <shapr> tromp: lambda playground?
20:46:37 <mirpa> I've got it...
20:46:47 <tromp> hi, shapr
20:46:47 <markovirc_> Hello tromp
20:46:57 <shapr> hoi tromp!
20:47:26 <tromp> what about the playgroundf?
20:51:17 <pavonia> andresrtm: Oh, then converting it to JSON and showing it afterwards should work. I haven't done happstack programming for a long time, so I'm not familiar with what text conversions have to be done
20:53:06 <andresrtm> yes, thank you very much, i change the show with Aeson.encode :) and it works perfectly
20:54:47 <pavonia> nice, you're welcome
20:55:31 <andresrtm> pavonia: but I would like to understand what makes the code you gave me, if its not too much trouble, for example what type is res ?
20:56:42 <heatsink> Is there a way to make cabal pass the -dynamic-too flag to GHC?
20:57:20 <andresrtm> in this moment that code is "magic code don't touch" for me !
20:58:38 <pavonia> andresrtm: the result type is the same as what the IO monad yields you
20:59:20 <pavonia> happstack works in a special monad, like IO but with a lot of other stuff internally. So when you lift timeline "something" with liftIO you get your IO result in that monad
21:00:35 <pavonia> (m1 >>= \res -> m2) just combines two server monads to a bigger one, where res takes the result of m1 so it can be used in m2
21:00:37 <Cale> another way of putting it is that liftIO transforms IO actions into actions in that monad.
21:01:25 <pavonia> andresrtm: Are you already familiar with monads in general?
21:01:35 <pavonia> in Haskell, that is
21:01:42 <shachaf> pavonia: There's only one monad involved there. :-(
21:02:21 <pavonia> IO doesn't count?
21:03:02 <andresrtm> pavonia: just met them today !
21:03:06 <shachaf> m1 is not a monad.
21:03:09 <maxiepoo> mobits
21:03:13 <tertl3-laptop> hello markovirc_
21:03:14 <markovirc_> Hello tertl3-laptop
21:03:53 <pavonia> Oh, m1 and m2 are monadic actions, not monads, excuse my wording :p
21:05:20 <pavonia> andresrtm: I'd say start with a monad tutorial first because you'll need the basics a lot in happstack
21:07:47 <andresrtm> pavonia: i'll do, thanks for all and the advice, nice day/nigth, it's my first time in a IRC chat :)
21:08:22 <pavonia> no problem :)
21:14:30 <joelteon> Is there a package that provides non-English TimeLocales?
21:16:07 <tertl3-laptop> you mean theres a language other than english?
21:16:29 <tertl3-laptop> preposterous
21:30:49 <joelteon> just in case someone decides to write one
21:32:57 <pavonia> joelteon: Do you need a specific one?
21:33:26 <joelteon> Not at the moment
21:33:30 <joelteon> I'm overarchitecting for no real reason
21:52:40 <xifeng> Has anyone tried to install ihaskell on mavericks, by any chance?
21:53:40 <xifeng> cereal-0.3.5.2 won't build. :/
22:05:09 <xifeng> oh, never mind. I changed the dependency to cereal-0.4.0.1 and everything works now. :)
22:07:46 <jorendorff> blert
22:59:53 <jle`> hm. is there any performance cost to using a data type with to empty constructors, instead of a Bool?
23:00:23 <jle`> for example, data Completion = Incomplete | Complete
23:00:34 <jle`> just for the same of expressiveness
23:01:07 <ij> @src Bool
23:01:08 <lambdabot> data Bool = False | True deriving (Eq, Ord)
23:01:16 <ij> That suggests me, they should be the same.
23:01:30 <ij> Though I'm not an expert.
23:01:34 <jle`> yes but there might be magic compiler stuff going on
23:01:37 <jle`> or unboxing stuff
23:01:42 <jle`> idk :|
23:02:58 <c_wraith> there's nothing magic about bool
23:03:09 <c_wraith> *Bool
23:03:10 <Twey> I don't think there'd be anything magic about Bool that you wouldn't get with a different type
23:03:42 <Twey> If such optimizations exist there's no reason to apply them just to Bool as opposed to, say, any type whose constructors have no arguments
23:03:43 <c_wraith> the only potentially magical thing is actually magic in other types - like Unbox instances for unboxed vectors
23:03:46 <jle`> hm. okay, good.  so there would be no performance boost?  are they both represented by the same low-level data structure?
23:03:54 <pdxleif> You know if you can write plugins for custom content embedded in pandoc?
23:04:01 <pdxleif> I know you can do something like that w/ gitit
23:04:48 * hackagebot network-conduit-tls 1.0.4.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.4.1 (MichaelSnoyman)
23:09:48 * hackagebot slidemews 0.2 - ws convert markdown to reveal-js  http://hackage.haskell.org/package/slidemews-0.2 (j4pe)
23:14:49 * hackagebot slidemews 0.3 - ws convert markdown to reveal-js  http://hackage.haskell.org/package/slidemews-0.3 (j4pe)
23:15:11 <jfeltz> Is there a way to operate on a newtype as if it were the type of its payload?
23:15:48 <supki> .. what's the point of newtyping it then?
23:17:10 <jfeltz> supki, you can't expect to create classes instances or similar constructs on on non-newtype(s)
23:19:50 * hackagebot ggtsTC 0.5 - A type checker and runtime system of rCOS/g (impl. of ggts-FCS).  http://hackage.haskell.org/package/ggtsTC-0.5 (brianchon)
23:28:23 <Macfiron> hi!
23:28:24 <markovirc_> Hello Macfiron
23:29:08 <c_wraith> why do we have a bot to respond to greetings?
23:29:34 <Ralith> we don't
23:30:06 <c_wraith> Well.  "we have" in the same sense that we might have an infection.
23:30:23 <Ralith> right
23:31:38 <shachaf> Uh, who's running that bot?
23:34:40 <Ralith> probably the only person here with IP 67.43.244.27
23:38:13 <Macfiron> I'm trying to install pandoc on my system and followed the install which says to: cabal install alex happy; cabal update; cabal install pandoc. Upon the last command, I get an error: "http-client-tls-0.2.0.2 failed during the building phase." Since I've never done anything with haskell or cabal I don't even know where to start looking for (googleing the error didn't help), to get pandoc installed. Can somebody please have a look into this err
23:38:13 <Macfiron> or?
23:39:34 <pdxleif> were there any errors before that?
23:39:45 <pdxleif> try just "cabal install http-client-tls"?
23:40:00 <Macfiron> it bails, mompls
23:40:12 <pdxleif> mompls?
23:40:18 <Macfiron> (moment please :))
23:40:36 <pdxleif> pandoc is normally as a pre-compiled binary for most platforms / package managers
23:41:21 <pdxleif> E.g. mac, win, most linuxes have it in their packange manager: http://johnmacfarlane.net/pandoc/installing.html
23:43:01 <Macfiron> I now, but the pdf creation gives me problems, so I thought to try the current version 1.12.3. ubuntu 13.10 is behind: 1.11...
23:43:13 <Macfiron> pdxleif: so here is a paste of the error message: http://pastebin.com/ckUZkgKQ
23:48:11 <levi> That's pretty weird.
23:49:25 <levi> What kind of pdf creation problems were you having with the pre-packaged version?
23:49:31 <pavonia> Macfiron: What version of connection do you have installed?
23:49:56 <Macfiron> * connection       (library)
23:49:56 <Macfiron>     Versions installed: 0.2.0
23:51:04 <Macfiron> levi: this is part of a README i wrote: """like `eval \"\$(lesspipe)"` is"""
23:51:42 <Macfiron> levi: I tried different combinations of escaping ", $ and ( but none worked
23:52:08 <Macfiron> (though the error message for pdf creation differs, depending on the escaping)
23:52:36 <Macfiron> the html generation works as expected (escaped or without escapes)
23:53:04 <Macfiron> I had a similar problem with references (I think) in headers
23:53:18 <levi> Have you tried output to latex and then running the latex-to-pdf yourself?
23:53:20 <the_berserker> Why is the catch-all guard written "otherwise" instead of "else"
23:53:35 <Macfiron> levi: ah, didn't think of that
23:53:44 <levi> the_berserker: Because someone thought it ought to be that way?
23:53:46 <pavonia> Weird, connection-0.2.0 defines a Default instance for TLSSettings
23:53:46 <simpson> the_berserker: `else` is a keyword that is part of the if-then-else syntax.
23:53:51 <simpson> > otherwise -- the_berserker
23:53:53 <lambdabot>  True
23:53:57 <levi> the_berserker: It's nothing special, just an alias for True
23:54:54 <the_berserker> > not otherwise
23:54:55 <lambdabot>  False
23:55:17 <levi> latex installs vary, and sometimes templates need a bit of tweaking.
23:55:32 <the_berserker> Why doesn't Haskell overload the keyword else for this?
23:55:58 <simpson> Because guards take Bools and special syntax is unnecessary here.
23:56:49 <Macfiron> levi: I'll try the latex method.
23:56:52 <the_berserker> > do {if True; then 1; else 0}
23:56:53 <lambdabot>  1
23:56:53 <pavonia> One could argue that if-then-else is unnecessary too
23:57:06 * Macfiron is afk for some minutes
23:57:16 <levi> the_berserker: If you object to writing so many characters, just use True.
23:57:52 <levi> Haskell has a complex enough syntax already.
23:58:46 <levi> One could argue that perhaps half of it was unnecessary. :P Might be hard to get agreement on which half, though.
