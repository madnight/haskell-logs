00:00:10 <b80905> in hugs
00:00:23 <Redz> uh oh. i dont know. sorry.
00:00:46 <b80905> for compiling?
00:02:16 <Redz> b80905: maybe this helps: http://stackoverflow.com/questions/15262955/loading-file-in-98-hugs
00:04:47 <b80905> how do i use the \\ function?
00:05:38 <Redz> :t (\\)
00:05:39 <lambdabot> Eq a => [a] -> [a] -> [a]
00:06:06 <b80905> Redz: undefined variable..
00:07:00 <c_wraith> @hoogle (\\)
00:07:01 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
00:07:01 <lambdabot> Data.IntMap.Strict (\\) :: IntMap a -> IntMap b -> IntMap a
00:07:01 <lambdabot> Data.IntMap.Lazy (\\) :: IntMap a -> IntMap b -> IntMap a
00:07:08 <c_wraith> looks like you need to import it
00:07:23 <jle`> is there any sort of TH i can use to make my new shiny monad transformer get all the typeclasses to fit in with the mtl suite?
00:07:31 <b80905> c_wraith: how do you import things?
00:07:58 <c_wraith> b80905: in a file or in ghci?
00:08:05 <jle`> well...it's the same in both
00:08:12 <jle`> kinda
00:08:24 <jle`> import Name.Of.Module at the type of the file
00:08:31 <jle`> or import Name.Of.Module on ghci
00:08:49 <jle`> actually with ghci you can load the file directly, :l path/to/file/List.hs
00:09:52 <c_wraith> jle`: loading and importing are very different
00:10:07 <c_wraith> jle`: and if you looked at context, this is Data.List, which is an import
00:10:20 <jle`> it looks like he just wants to load a List.hs file
00:11:05 <Redz> or just the List module from haskell98 .
00:11:56 <b80905> jle`: why do i have to to know where  list.hs is on my system in order to be able to load it?
00:12:09 <jle`> oh okay
00:12:20 <jle`> he probably does want to load Data.List
00:12:22 <jle`> >.>
00:12:23 <c_wraith> b80905: the :load directive is for code you're developing
00:12:30 <c_wraith> b80905: import is for code in libraries
00:14:27 <b80905> c_wraith: well, hugs says 'ERROR - Syntax error in expression (unexpected keyword "import")'. do i have to switch to ghci?
00:15:01 <c_wraith> b80905: best to use a file.  But hugs probably has a directive for importing modules that uses different syntax
00:15:18 <c_wraith> b80905: but why does everyone use hugs anyway? It's unmaintained and way out of date.
00:15:24 <Hafydd> :m or :m+, I think.
00:15:58 <Hafydd> Perhaps it's because it isn't massive like GHC.
00:16:41 <Redz> or strange professors.
00:19:57 <ski> @tell erisco "it is that at the final stage (the algorithm terminates) it must return the root node" -- ok, a bit like bottom-up merge-sort `mergeSort as = loop (map (:a) as) where loop [as] = as; loop ass = loop (merge ass0 ass1) where (ass0,ass1) = halve ass' ?
00:19:57 <lambdabot> Consider it noted.
00:20:27 <ski> @tell erisco "actually no I am not \"forced to return the root node before recursing\"" -- hm, ok. perhaps the earlier remark isn't helpful here, then
00:20:28 <lambdabot> Consider it noted.
00:20:58 <b80905> Hafydd: "ERROR - Cannot find module "List""
00:21:32 <Redz> b80905: and module Data.List ?
00:21:51 <b80905> Redz: "ERROR - Cannot find module "Data.List""
00:23:54 <randomclown> is getting everything typechecked the greatest pleasures of Haskell
00:24:12 <randomclown> better than my first kiss
00:26:00 <Redz> b80905: maybe hugs is in a bad mood. :p
00:26:04 <shachaf> preflex: seen joeyh
00:26:04 <preflex>  joeyh was last seen on #haskell 9 days, 1 hour, 37 minutes and 59 seconds ago, saying: recently a new version of text has been causing some problems like this
00:26:16 <randomclown> is this the stalker bot?
00:28:02 <b80905> i have loaded a file with 'import Data.List' in it and hugs says 'undefined variable "\\"' still
00:28:32 <randomclown> :t (//)
00:28:33 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
00:28:37 <randomclown> :t (\\)
00:28:38 <lambdabot> Eq a => [a] -> [a] -> [a]
00:28:53 <randomclown> :src (\\)
00:29:29 <b80905> i will try to install ghci
00:29:49 <randomclown> @src (\\)
00:29:49 <lambdabot> (\\) = foldl (flip delete)
00:29:50 <shachaf> joeyh: Why this telehash thing?
00:29:52 <Redz> b80905: best way is to install the haskell-platform .
00:31:29 <Redz> b80905: http://www.haskell.org/platform/ includes ghc/ghci and other useful things.
00:36:56 <osa1> do this two code have same semantics http://lpaste.net/98568 ?
00:37:27 <osa1> or does that depend on implementation of (&&&&) ?
00:37:30 <osa1> sorry, (&&&)
00:38:09 <osa1> nope, (&&&) is not part of the typeclass
00:38:36 <ski> b80905 : did you try `:l List' (with no `.hs') in Hugs ?
00:39:45 <keep_learning> Hello all
00:39:54 <ski> hello keep_learning
00:39:58 <shiona> hello
00:40:11 <Thooms> morning all
00:40:43 <Redz> Thooms: not everywhere is morning. ;)
00:40:48 <keep_learning> I am looking for regular expression library ( function ) in which I pass the regular expression and it returns mein any valid string that it can identify.
00:41:08 <Thooms> Redz: my bad, I'm not fully awaken :D
00:41:09 <b80905> ski: :l List seems to be working
00:41:14 <keep_learning> Something like this https://code.google.com/p/xeger/
00:42:15 <shiona> There are a few choices under Text.Regex
00:42:44 <Redz> or if you dont like Text.Regex , there are many alternatives: http://hackage.haskell.org/packages/search?terms=regex&
00:42:50 <ski> b80905 : iirc, if you add the `.hs', it assumes you mean a file in the current directory (or maybe alternatively on some search path), while without `.hs', it also considers the Hugs libraries
00:44:23 <keep_learning> shiona: Redz Thank you
00:44:25 <shiona> keep_learning: ah, sorry, misread
00:44:44 <Redz> keep_learning: you could generate every permutation and check it for your regex.
00:44:49 <shiona> keep_learning: you want the regex.genex from redz's link
00:45:12 <osa1> anyone here experienced with HXT? I'm trying to parse a document that has layout like: <tag1><tag2><tag1><tag2>... and I want to have pairs (<tag1>, <tag2>) for not all combinations of tag1 and tag2 but for every neighbor tag1 and tag2 where tag1 comes before tag2 in the document
00:45:49 <shiona> "From regex, generate all possible strings it can match", that was what you were looking for, right?
00:47:00 <keep_learning> shiona: Regex.Genex is great. This is what I was looking for. Thanks again  :)
00:47:54 <shiona> no prob
00:57:30 <osa1> guys, can anyone help me with my hxt problem?
00:57:36 <osa1> > I'm trying to parse a document that has layout like: <tag1><tag2><tag1><tag2>... and I want to have pairs (<tag1>, <tag2>) for not all combinations of tag1 and tag2 but for every neighbor tag1 and tag2 where tag1 comes before tag2 in the document
00:57:37 <lambdabot>  <hint>:1:54: parse error on input `<'
01:32:41 <SaBer> I'll be doing some simple statistical analysis and visualization on some poll results. R would be the obvious choice for a language, but I was wondering if there are some haskell libraries that would do similar things easily? I'd rather improve on my haskell skills than my R skills...
01:33:37 <merijn> SaBer: Tbh, the statistical analysis probably exists (I'm not aware of any, but then again I haven't looked). But my gut tells me the visualisation will probably be easier in R
01:46:47 <eevar> SaBer: https://news.ycombinator.com/item?id=5552109
01:47:18 <eevar> not sure if how it's coming along, tho
01:49:03 <eevar> umm.. and I meant to link a similar comment that was more recent, sorry
01:57:03 * hackagebot happy 1.19.3 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.3 (SimonMarlow)
01:58:18 <maxs`> How would I write a function to do: SqlPersistT IO a -> LoggingT (SqlPersistT (NoLoggingT (ResourceT IO))) a
01:58:18 <maxs`> (I'm using persistent)
01:59:03 <maxs`> sorry, \that should be: SqlPersistT IO a -> SqlPersistT (NoLoggingT (ResourceT IO)) a
01:59:09 <c_wraith> Maxdamantus: probably lift
01:59:38 <maxs`> Yeahh….. run something lift something
01:59:55 <c_wraith> no, really.  lift should have that type
02:00:22 <c_wraith> :t lift
02:00:22 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
02:00:56 <c_wraith> oh, I see.  There's a ResourceT in the middle
02:01:00 <maxs`> yeah
02:01:22 <merijn> mmorph?
02:01:40 <merijn> mmorph lets you lift "inside" a transformer stack
02:01:41 <c_wraith> yeah, the mmorph stuff..  hoist matches that
02:01:48 <merijn> @hackage mmorph
02:01:49 <lambdabot> http://hackage.haskell.org/package/mmorph
02:01:52 <maxs`> awesome yeah, I will give that a shot
02:02:16 <merijn> "hoist lift" or some combination thereof should work
02:02:27 <c_wraith> yeah, that's what it looks like
02:15:08 <maxs`> (hoist lift . hoist lift) works, but I just need an instance of MFunctor for SqlPersistT
02:15:24 <maxs`> so I used: hoist nat m = SqlPersistT (mapReaderT nat (unSqlPersistT m))
02:16:06 <merijn> maxs`: Why not "hoist (lift.lift)"? :)
02:16:31 <maxs`> merijn: just changed it :)
02:16:35 <maxs`> thanks
02:24:47 <Dobiasd> Hi, as an exercise I want to rewrite this toy python code in haskell. http://ideone.com/OPYig7 My solution works but is quite ugly. http://ideone.com/lAheSR I am trying to find a solution without explicit recursion using a fold or something, but did not have an idea yet on how to do it. Can anybody help me out? :)
02:29:58 <Axman6> Dobiasd: for one you could use iterate and dropWhile
02:30:29 <Axman6> Dobiasd: remember, looks in haskell = lists 99% of the time
02:33:57 <Dobiasd> Axman6: Yes, I tried ...
02:35:41 <eazar001> Dobiasd: where is your haskell source code?
02:36:38 <Dobiasd> eazar001: here http://ideone.com/lAheSR
02:36:59 <eazar001> thanks
02:37:35 <eazar001> okay something straight off the bat ....
02:37:48 <eazar001> you can use guards for your step function instead of if statements
02:38:02 <eazar001> you don't need a let ... in
02:38:14 <eazar001> just a guard with three conditions, the third being `otherwise`
02:38:24 <eazar001> but there are probably other ways to accomplish that
02:38:53 <eazar001> f x is straightforward nothing else to do there
02:40:13 <Redz> maybe some new function names and stuff. approximate and eps or so.
02:40:26 <eazar001> you also don't need a let statement for improve, try a where clause, much better
02:40:40 <mangaba_leitosa> Dobiasd, eazar001: I would use 'until errorTolerable (imrove f) initialGuess'
02:41:36 <Dobiasd> mangaba_leitosa: until sounds good. I guess that is what I was looking for.
02:41:48 <Redz> @hoogle until
02:41:49 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
02:41:50 <Dobiasd> eazar001: Thanks. I will also do the things you suggested.
02:42:16 <eazar001> Dobiasd: good luck
02:42:45 <ski> Dobiasd : just so you know, `(Num a) =>' and `(Fractional a) =>' could be written as `Num a =>' and `Fractional a =>'
02:43:45 <merijn> Dobiasd: I'd probably use a layout more like this: http://lpaste.net/98570
02:44:00 <jtcwang> i'd like to do an iteration on a function, passing its output to the nxt iteration
02:44:03 <merijn> eazar001: I don't think the guard adds much readability, tbh
02:44:05 <jtcwang> is there a function for that?
02:44:14 <merijn> :t iterate -- ?
02:44:15 <lambdabot> (a -> a) -> a -> [a]
02:44:48 <Redz> yep. list as a monad can be a brain killer.
02:45:04 <eazar001> merijn: it was to pretty up the code
02:45:32 <merijn> eazar001: Sure, but if you get rid of the let/in the guard becomes kinda redundant for prettifying :)
02:45:39 <eazar001> I always found it more straightforward than an 'if' statement
02:45:43 <jtcwang> merijn, that's right! I'll give it a try thanks
02:48:00 <eazar001> merijn: hmmm, i guess you're right
02:48:43 <jtcwang> doBet :: Auto Double BetRecord ->  IO (Auto Double BetRecord)
02:48:53 <jtcwang> i'm getting the error:     Couldn't match type `Auto Double BetRecord' with `()'
02:49:03 <jtcwang> seems to be expecting IO()
02:51:52 <jtcwang> any ideas?
02:51:56 <ski> jtcwang : iterate until ?
02:52:23 <jtcwang> ski, I'm getting type error
02:52:35 <ski> when is the iteration supposed to stop ?
02:53:03 <jtcwang> it's not suppose to (for now), does it matter in solving my error?
02:53:11 <jtcwang> I'll adding a Either check later
02:53:41 <ski> @let iterateM_ :: Monad m => (a -> m a) -> (a -> m b); iterateM_ env var = iterateM_ env =<< env var
02:53:43 <lambdabot>  Defined.
02:54:40 <jtcwang> ski, thanks for that, but I'm having trouble with type errors when I'm trying to define an IO function
02:54:51 <jtcwang> with return type Auto Double BetRecord
02:55:00 <jtcwang> doBet :: Auto Double BetRecord ->  IO (Auto Double BetRecord) gives me  Couldn't match type `Auto Double BetRecord' with `()'
02:55:26 <jtcwang> actually I think the error might not be in the definition
02:59:23 <ski> > runWriter . runErrorT $ iterateM_ (\n -> do when (n > 1000) $ throwError ("stopped at " ++ show n); tell [n]; return (2*n)) 1
02:59:24 <lambdabot>  (Left "stopped at 1024",[1,2,4,8,16,32,64,128,256,512])
03:00:14 <ski> jtcwang : ^ is an example of how it could be used, using the `ErrorT String (Writer [Integer])' monad, since lambdabot doesn't do `IO'
03:00:41 <ski> jtcwang : yes, it sounds like your error is coming from the use of `doBet'
03:16:13 <shiona> for a cryptochallange I would need to create [ s : w ++ [s] | s <- ['\x20'..'\7e'], w <- replicateM 4 (['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']) ] and then make those into bytestrings
03:16:42 <shiona> is there an efficient way of making these?
03:28:09 <randomclown> use the builder
03:28:13 <randomclown> bytestring.builder
03:28:26 <randomclown> if you are going to be concating a lot
03:29:03 <shiona> randomclown: thanks, that sounds good
03:30:04 <Dobiasd> eazar001, mangaba_leitosa, merijn: Thank you all. Now my code looks much better to me: http://ideone.com/JS4do1
03:31:23 <Philonous> Wow. The package download statistics on hackage seem to be screwed up pretty badly.
03:31:50 <Philonous> I've got 39 downloads on a package that I'm pretty sure nobody knows about.
03:33:54 <Aetherspawn> Philonous: bots automatically download new packages
03:33:58 <Aetherspawn> so they can index them or mirror them or whatnot
03:34:11 <Aetherspawn> theres quite a high number of bots and scripts which probe hackage
03:34:16 <Aetherspawn> so that could make up for your downloads
03:34:48 <Philonous> Well, that makes the number of package downloads moot, doesn't it?
03:34:59 <Aetherspawn> nah
03:35:06 <Aetherspawn> the number of bot downloads is usually pretty constant
03:35:06 <Philonous> OK, I suppose it works for higher numbers.
03:35:53 <Aetherspawn> but sure, maybe it needs a ?dontcount parameter or something
03:36:03 <Philonous> That would be helpful
03:36:06 <Aetherspawn> so that things like hoogle and hayoo and whatnot can pull the packages without counting
03:36:33 <zebr> hi all. is there a way to promote (f :: Monad m => a -> b -> m c) to (g f :: Monad m => m a -> m b -> m c) or equivalent?
03:36:55 <mr-> zebr: yes
03:37:13 <zebr> sorry, is there a standard function, rather.
03:37:29 <mr-> zebr: use fmap to get ma -> mb -> m m c and then use join to get from m m c to m c
03:39:03 <Aetherspawn> Philonous: there 'yer go
03:39:03 <Aetherspawn> https://github.com/haskell/hackage-server/issues/184
03:39:16 <Aetherspawn> now it'll echo into eternity
03:39:35 <mr-> zebr: I probably should have said liftM2, not fmap
03:40:10 <zebr> ah! that works. great, thanks.
03:40:51 <Philonous> @type \f x y -> join $ f <$> x <*> y
03:40:51 <lambdabot> (Monad m, Applicative m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
03:42:45 <Philonous> Aetherspawn, Hah, ok, thanks. I guess the bigger issue will be to get bots to actually use that feature.
03:43:22 <mr-> :t \f x y -> join $ return f `ap` x `ap` y -- :-)
03:43:23 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
03:48:09 <shiona> how do I get to compare a md5digest with a (byte)string?
03:48:55 <Philonous> shiona, MD5DIgest should have be Binary instance, so you can encode it
03:49:03 <Philonous> have a*
03:50:46 <Aetherspawn> sure, people can be evil and not do it.
03:50:50 <Aetherspawn> but if it
03:50:59 <Aetherspawn> *it's ever implemented, it'd get put into the major ones.
03:51:43 <Philonous> It's not so much that they would be evil just that they couldn't be bothered.
03:52:21 * hackagebot xss-sanitize 0.3.4.2 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.4.2 (GregWeber)
03:55:01 <shiona> Philonous: bytestring doesn't seem to be thought
03:55:10 <shiona> though*
03:56:23 <Philonous> shiona, I don't follow? You can convert the MD5Digest to a byteString with encode from Data.Binary and then compare it to your ByteString.
03:57:22 * hackagebot som 7.0.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.0.0 (AmyDeBuitleir)
04:05:56 <keep_learning> Hello All
04:06:18 <keep_learning> I have two infinite list and I am trying to combine them
04:06:19 <keep_learning> http://lpaste.net/98571
04:06:38 <keep_learning> but getting error
04:07:23 * hackagebot som 7.0.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.0.1 (AmyDeBuitleir)
04:07:25 <keep_learning> http://hackage.haskell.org/package/streams-3.1/docs/Data-Stream-Infinite.html ( Like interleave funtion )
04:11:48 <dv-> > let f (x:xs) (y:ys) = x:y:f xs ys in take 20 $ f [1..] [10..]
04:11:49 <lambdabot>  [1,10,2,11,3,12,4,13,5,14,6,15,7,16,8,17,9,18,10,19]
04:12:52 <Philonous> keep_learning, splitAt gives you a pair of lists, not the head and the tail
04:13:33 <Philonous> keep_learning, If you're sure that (generate r1) is not empty you can instead have (let (x:xs) = generate r1 ...)
04:15:32 <Philonous> keep_learning, glancing at your code, that doesn't seem to be the case, though.
04:16:15 <keep_learning> Philonous: It will be only in case Star
04:16:23 <keep_learning> otherwise it's finite list
04:16:42 <Philonous> So you should match on the lists and handle the empty case.
04:17:32 <Philonous> Oh, wait, it can't be empty.
04:19:11 <Philonous> But infiniStream should have clauses for the case where either of the list is empty
04:19:57 <ocharles> Anyone know of a concatMapM type thing? I have Monoid a => [m a] and want an  m a
04:20:28 <Philonous> @type mconcat
04:20:28 <lambdabot> Monoid a => [a] -> a
04:20:33 <Philonous> Oh
04:20:55 <ocharles> asum is almost right, but the monad I'm working under doesn't have a MonadPlus
04:21:23 <ocharles> Monoid b => [a -> b] -> a -> b  is actually the exact type I want, I guess
04:21:37 <keep_learning> Philonous: Now I changed to http://lpaste.net/98571
04:21:48 <Philonous> @type liftM mconcat . sequence
04:21:49 <lambdabot> (Monad m, Monoid r) => [m r] -> m r
04:21:57 <ocharles> well sure
04:22:04 <ocharles> I wondered if there was already something capturing that :)
04:22:25 * hackagebot persistent 1.2.3.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.3.3 (MichaelSnoyman)
04:22:45 <keep_learning> Philonous: Thank you
04:30:43 <ghorn__> was vector SIMD stuff reintroduced after this? http://www.haskell.org/pipermail/ghc-devs/2013-November/003262.html
04:30:53 <ghorn__> Data.Vector, that is
04:32:13 <ghorn__> see previous message too http://www.haskell.org/pipermail/ghc-devs/2013-November/003261.html
04:37:01 <apfelmus> Hello. :)
04:38:42 <apfelmus> I am in need of a second opinion on naming.
04:38:47 <Philonous> Hi
04:39:12 <apfelmus> I'd like to make a small helper module containing stuff for event-driven programming.
04:39:20 <apfelmus> That is  type Handler a = a -> IO ()
04:39:31 <apfelmus> type AddHandler a = Handler a -> IO (IO ())
04:39:32 <apfelmus> and so on.
04:39:56 <apfelmus> But I wonder what the best module name would be.
04:40:23 <apfelmus> Currently, I am trying to decide between
04:40:26 <apfelmus> Control.Handler
04:40:29 <apfelmus> and
04:40:34 <apfelmus> Control.Event
04:40:50 <Philonous> Control.EventHandler ?
04:40:54 <apfelmus> (At the moment, I have put it in Reactive.Banana.Frameworks.AddHandler, but I want to get rid of that.)
04:41:30 <apfelmus> @Philonous I feel uneasy about the CamelCase without a dot in between.
04:41:30 <lambdabot> Unknown command, try @list
04:43:42 <`Jake`> How about... Control.Event.Handler
04:43:54 <Philonous> Control.Handler seems a bit too generic, Control.Event seems confusing.
04:44:09 <Philonous> Or drop the Control: Event.Handler
04:44:33 <apfelmus> Good point about Control.Handler and Control.Event
04:45:38 <apfelmus> I'd like to have the Control prefix, though, because Control is about programming paradigms (monads, concurrency, etc.), so I think it fits well there.
04:47:39 <apfelmus> `Jake`: Hm, too many levels look ugly on Hackage. But I think I like your suggestion anyway. :)
04:47:51 <`Jake`> apfelmus: that's true
04:48:34 <Philonous> Control.Event_Handlers (no camel case) ;)
04:48:48 * apfelmus throws a lambda after Philonous
04:49:41 <apfelmus> Alright, thanks a lot! I will go with Control.Event.Handler . :)
04:50:14 <Philonous> Event.Handler implies there are is a distinct concept of Events and htis are the handlers for them
04:50:24 <Philonous> I'm not sure that's what you mean.
04:50:42 <apfelmus> Philonous: Well, there is Event from functional reactive programming, too.
04:51:09 <Philonous> apfelmus, Does Control.Event.Handler pertain to them? Because that's what I would expect.
04:51:44 <apfelmus> Philonous: Well, Control.Event.Handler only pertains to the event handlers.
04:52:13 <apfelmus> In the traditional imperative style, you only ever talk about event handler. You never get to see an event as a first class value.
04:52:58 <apfelmus> In functional reactive programming, you do see them as first class values, but Control.Event.Handler is not intended to talk about those.
04:53:50 <tdammers> apfelmus: idk, many of the imperative event-driven systems I've worked with did use first-class events
04:54:08 <apfelmus> tdammers: Example?
04:54:33 <tdammers> let me think
04:54:36 <Philonous> apfelmus, It maybe nit picking, but Control.Event.Handler does seem to imply that there is some particular data structure or concept called "Event".
04:54:47 <tdammers> Win32 is like you describe, mostly
04:55:29 <apfelmus> tdammers: Ah, the things you get when you call `WaitForEvents` or whatever this function is called?
04:55:55 <tdammers> nah, Win32 has event handlers and passes parameters to them
04:56:06 <tdammers> I don't think there is an explicit data type for events
04:56:35 <tdammers> but the differences with a system where you group those parameters into a struct is marginal
04:57:24 <apfelmus> tdammers: Well, the events in an FRP sense are slightly different in that they are the things you can register event handlers to.
04:57:47 <tdammers> ah, so it's more like a source/sink thing?
04:58:01 <apfelmus> Yup. Let just me link to the relevant definition in Reactive.Banana:
04:58:02 <apfelmus> http://hackage.haskell.org/package/reactive-banana-0.7.1.3/docs/Reactive-Banana-Combinators.html#t:Event
04:58:32 <tdammers> a bit like how events work in C#, then
04:58:51 <tdammers> I think Java uses a similar pattern a lot
04:59:07 <apfelmus> Philonous: Yup, there is a concept of 'Event', though it can be found in the module 'Reactive.Banana.Combinators' or 'Reactive.Threepenny'.
04:59:13 <tdammers> although the events aren't first-class there
04:59:56 <apfelmus> Philonous: I could put one of these in the Control.Event module, but that would still be a little presumptions, so I leave that open for now.
05:00:19 <apfelmus> tdammers: What are they called? "Event handler registrar" or something, I guess?
05:00:27 <Psycho_pr> apfelmus: goon tag
05:00:53 <apfelmus> Psycho_pr: Pardon?
05:02:30 * hackagebot hasktags 0.68.5 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.5 (MarcWeber)
05:03:21 <apfelmus> Darn, gotta go. Lunch. Thanks a lot for the discussion!
05:05:22 <tdammers> apfelmus: more like implicitly calling SomeObject.registerSomethingHandler(SomeOtherObject)
05:07:39 <Cale> tdammers, apfelmus: Stephen Blackheath talks about the relationship between the Observer pattern and FRP here. http://www.youtube.com/watch?v=gaG3tIb3Lbk
05:08:20 <Cale> The talk is aimed at quite a general audience though, so mind that :)
05:10:01 <tdammers> ah, cool. Observer pattern, yes, that's what I'm thinking of.
05:10:48 <`Jake`> Would you guys say it's possible to do object oriented programming in haskell?
05:11:31 <Cale> `Jake`: sure
05:11:52 <`Jake`> Ok, thanks. Just wanted to make sure I'm not crazy
05:11:56 <Cale> But it depends on what you mean by object oriented programming. People have lots of different opinions about what that is :)
05:12:12 <`Jake`> right
05:12:20 <Cale> The way I'd usually do it is to define a type of objects as simply a record of its methods
05:12:35 <`Jake`> That's what I was thinking, yeah
05:12:58 <Cale> and then functions which construct such records will take some parameters which will act as the "private" state
05:13:55 <`Jake`> yeah, ok
05:13:58 <Cale> and you can have some of the methods perhaps produce an object of the same type to simulate "mutation" in a pure way, or you can have the methods be IO actions which really cause effects and stuff
05:14:25 <Cale> (and construct things like IORefs to contain the state when you build the objects initially)
05:14:33 <`Jake`> I haven't even thought about mutations, actually
05:17:53 <Cale> `Jake`: Of course, this does nothing about the subtype polymorphism that most typed OO language people focus so much on, but the cool thing about this is that since you don't have to define a new type every time you want different implementations of the methods, you typically hardly need it.
05:18:46 <`Jake`> Cale: Are you talking about typeclasses now? I'm not sure
05:18:48 <Cale> I tend to view the heavy focus on subtyping and the red herring of inheritance as a symptom of the pain caused by tying the method implementations to the definitions of classes.
05:18:54 <Cale> (OO classes)
05:20:29 <Cale> I'm talking about how when you know (say in Java) that some object x is of a class Y which is a subclass of X, then you can pass it to a function which demands an X.
05:20:52 <`Jake`> Ah, ok
05:21:19 <Cale> The main reason you need subclasses so much is that in Java you can't vary what the methods do without defining a subclass.
05:21:38 <Cale> But in this Haskell encoding, you certainly can :)
05:21:43 <`Jake`> Right
05:21:54 <`Jake`> thanks for all those thoughts
05:22:36 <Cale> (also, I consider this truer to the notion of OO in more dynamically-typed settings like smalltalk)
05:23:03 <`Jake`> I should look at smalltalk some of these days
05:42:12 <DarkUnicorn> is there a way to create a newtype for a build-in list? I want a general list type which I can replace for Vector or something later
05:42:59 <tdammers> DarkUnicorn: sure, but it depends what you want to do with it
05:43:00 <merijn> DarkUnicorn: You can newtype lists the same way you can newtype anything?
05:43:06 <Hafydd> Do you mean this? newtype List a = List [a]?
05:44:59 <DarkUnicorn> when I write functions on Lists, for example f :: [Int] -> [Int], and I later want to use Vector, I have to change the type signature (to Vector Int -> Vector Int). I want to define f as List Int -> List Int and than just change the definition of "List" instead
05:45:17 <mauke> type List = []
05:45:49 <DarkUnicorn> so "[] Int" is the same as "[Int]"
05:46:26 <mauke> > [1,2,3] :: [] Int
05:46:27 <lambdabot>  [1,2,3]
05:46:37 <mauke> :t [1,2,3] :: [] Int
05:46:38 <lambdabot> [Int]
05:46:45 <mauke> hmm
05:46:51 <mauke> > typeOf (undefined :: [] Int)
05:46:52 <lambdabot>  [Int]
05:47:12 <mauke> > typeOf (undefined :: (,) Int Char)
05:47:14 <lambdabot>  (Int,Char)
05:47:22 <DarkUnicorn> mauke: seems to work, thanks! why does "newtype List = []" not work?
05:47:56 <mauke> because newtype needs a constructor name
05:48:09 <`Jake`> > newtype List = List []
05:48:10 <lambdabot>  <hint>:1:1: parse error on input `newtype'
05:48:21 <mauke> @let newtype List = List []
05:48:21 <lambdabot>  .L.hs:149:21:
05:48:22 <lambdabot>      Expecting one more argument to `[]'
05:48:22 <lambdabot>      In the type `[]'
05:48:22 <lambdabot>      In the definition of data constructor `List'
05:48:22 <lambdabot>      In the newtype declaration for `List'
05:48:31 <mauke> @let newtype List a = List [a]
05:48:32 <lambdabot>  Defined.
05:48:42 <mauke> @undefine
05:48:43 <lambdabot> Undefined.
05:49:03 <DarkUnicorn> oh i see, thank you!
05:51:03 <Maior> hm is [] an instance of Traversable? would that do it?
05:51:13 <Maior> can you even do something like that?
06:02:31 <boothead> hi folks, is there a cabal command to list dependencies of a package in a suitable form to pass to cabal install? I basically want cabal install --only-dependencies without the install bit :-)
06:03:34 <chrra> cabal install --dry-run
06:04:57 <boothead> chrra, yes, perfect! thanks
06:05:13 <chrra> You're welcome.
06:06:00 <savask> Hello. http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Practical_Graph_Handling shows a cool functional graph processing approach, based on folding and unfolding. Is there a full library based on these ideas?
06:07:48 <Cale> savask: I believe that's describing what's done in fgl
06:08:17 <savask> Cale: But isn't FGL outdated?
06:08:31 <Cale> savask: Kind of?
06:09:06 <Cale> I don't tend to use any particular library for graphs, I just use Map Vertex (Set Vertex) or some similar thing based on what I need.
06:09:44 <Cale> Though there are a bunch of them. I suppose if I needed any nontrivial algorithms, I'd go shopping. :)
06:10:28 <Cale> It's not like fgl has gone unmaintaned too though
06:11:17 <Cale> Its Gr type is based on IntMap
06:11:28 <savask> Cale: I was just afraid that it is :C
06:11:29 <Cale> I don't particularly like its naming scheme though
06:12:38 * hackagebot esqueleto 1.3.4.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4.3 (MichaelSnoyman)
06:12:40 * hackagebot skein 1.0.8.1 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.8.1 (MichaelSnoyman)
06:14:04 <savask> Cale: I think I will take a look at FGL. Thanks!
06:14:28 <Cale> There's no sensible reason that a function for finding the articulation points of a graph should have to be called 'ap', for instance, and if you can remember the differences between dfs, dfs', dff, dff', dfsWith, dfsWith', dffWith, dffWith', xdfsWith, xdfWith, and xdffWith, then you've a better memory than I do.
06:14:54 <savask> Eh
06:14:56 <Cale> http://hackage.haskell.org/package/fgl-5.4.2.4/docs/Data-Graph-Inductive-Query-DFS.html
06:15:09 <savask> Well
06:15:19 <Cale> But it's good to have the stuff anyway :)
06:15:19 <savask> Maybe something with better names? xD
06:15:37 <mr-> And it is nicely documented too!
06:15:40 <mauke> .oO( eq, eql, equal, equalp, =, string= )
06:15:50 <notdan> depth first search , depth first forest
06:16:02 <notdan> it is a bit annoying
06:16:17 <notdan> mr-: there are no haddocks for the DFS module, for example
06:16:35 <mr-> notdan: I was being sarcastic
06:16:43 <notdan> oops sorry
06:17:22 <savask> Why there is no good functional graph libraries then? It seems like something which would be really cool to have
06:17:27 <savask> *are
06:18:19 <Iceland_jack> mauke: Horrible memories..
06:19:02 <Cale> http://hackage.haskell.org/package/metamorphic-0.1.2.3/docs/A.html -- who names their module "A"?
06:20:15 <klrr_> is it in some way possible to use forkIO on a function of a type that derives MonadIO?
06:20:28 <Cale> also, wow, such roman numerals
06:20:45 <Cale> klrr_: Not necessarily
06:21:28 <Cale> klrr_: You need a way to turn the M a into IO a, while MonadIO only gives you the other way around.
06:21:57 <Cale> (you need a 'run' of some sort)
06:22:41 <Cale> http://hackage.haskell.org/package/metamorphic-0.1.2.3/docs/src/A.html#I -- what is this? :D
06:23:58 <Cale> There's also some masterful formatting of types if you scroll down.
06:24:17 <Cale> (fold/unfold/trans/transit/via)
06:26:12 <klrr_> okey, thanks. think i solved it another way
06:26:18 <Cale> http://hackage.haskell.org/package/metamorphic-0.1.2.3/docs/src/Alib.html
06:26:50 <Cale> This is the most amusingly formatted code ever
06:26:56 <Philonous> Cale, That can be improved. Types should all be called T and Classes all be called C.
06:27:06 <Cale> Philonous: ahahha
06:27:28 <Philonous> Cale, The sad thing is, such code exists.
06:27:40 <mauke> no, the sad thing is I kind of agree
06:28:15 <Philonous> You do?
06:28:15 <Cale> q23    ( _, x, y, _) = (x,y)
06:28:28 <Cale> I don't *wanna* write a lambda!
06:29:13 <mauke> foo :: Map.T String Int -> [String]
06:29:18 <Cale> I kind of almost see why he called it A now.
06:29:20 <mauke> foo m = Map.keys m
06:29:23 <hodapp> you'll write a lambda and you'll like it :|
06:29:27 <Cale> But still
06:29:41 <Cale> This is both extremely masterful code, and absolutely horrible
06:29:54 <Cale> at the same time
06:30:36 <mr-> Is the formating the masterful part?
06:30:43 <Cale> Not just the formatting
06:30:55 <Cale> The ideas are also pretty cool
06:32:21 <Lethalman> serious, 22 data structures like that? :P
06:32:40 * hackagebot yamemo 0.5.0 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.5.0 (NobuoYamashita)
06:32:51 <mr-> in 22 lines! :-)
06:33:25 <ski> Cale : reminds me slightly of my formatting ..
06:33:35 <ski> (especially the type aligning)
06:33:59 <FireFly> Cale: they also apparently reinvent Maybe with a less verbose alternative
06:34:20 <FireFly> (near the bottom of Alib)
06:34:27 <Lethalman> wait, I'm lost
06:34:31 <Lethalman> I is Int?
06:34:43 <Cale> FireFly: lol
06:34:56 <Lethalman> I see in the comments I = 1 + Id (= Mabye a)
06:35:00 * Lethalman lost
06:35:01 <Cale> data    I    a   = U_I_U | I     a
06:35:10 <Cale> It's another Maybe!
06:35:15 * ski . o O ( datatype 'a option = SOME | NONE of 'a )
06:35:18 <FireFly> Maybes for everyone!
06:35:27 <Cale> data   II    a b = UII_U | II    a b
06:35:28 <FireFly> (Maybe)
06:35:43 <Lethalman> Cale, ah, where's it defined?
06:35:44 <Cale> data   IIV   a b = UIIVU | IIV   a b b
06:35:48 <Cale> in A
06:35:54 <Cale> http://hackage.haskell.org/package/metamorphic-0.1.2.3/docs/src/A.html#I
06:35:55 <FireFly> Lethalman: http://hackage.haskell.org/package/metamorphic-0.1.2.3/docs/src/A.html#I
06:36:03 <Lethalman> can't find it, of course because I was looking for data I not data         I
06:36:03 <Lethalman> :P
06:36:22 <FireFly> Haha
06:36:42 <Cale> I also like how he chose the nonstandard IIV for 3
06:36:51 <Lethalman> ahhahhahaha
06:37:53 <ski> and `IIX' (which i've seen used before)
06:38:15 <Cale> He can't use VIII, it'd throw off the formatting!
06:38:16 <FireFly> To be fair the package description mentions that it uses unusual code layout
06:38:58 <ski> also, why `U_V_U' instead of `U___V_____U' ?
06:42:37 <ski> (an example of my type aligning is <http://lpaste.net/10060>)
06:45:03 <joe9> Are there any haskell libraries that have the functionality of the command "watch"? I have many lines of output that I want to keep re-writing and also highlighting the differences.
06:45:19 <Cale> btw, it seems Erwig's original code was a good deal saner looking
06:45:42 <mm_freak> joe9: for displaying you can use vty or vty-ui, for the differences you can use the various diff libraries like Diff
06:47:30 <mm_freak> vty-ui gives you actual widgets with a GTK-like interface (you probably want to use reactive-banana)…  vty acts more like a canvas, where you can draw composed text "images"
06:47:31 <FireFly> Cale: did you find it somewhere?
06:47:38 <FireFly> Oh
06:49:15 <pxqr> how to make headings in haddock markup? i have did this http://www.haskell.org/haddock/doc/html/ch03s08.html#idp1371429988 but my cabal haddock does not recognize heading's blobs
06:50:38 <pxqr> though i can remember i've seen headings in some packages at hackage
06:51:01 <pxqr> specifically, at module Foo () where items
06:51:04 <geekosaur> you need an empty line (aside from comment) before... and there are some odd restrictions to where headers can be used, that are supposed to be removed in the next release
06:54:56 <pxqr> geekosaur: why this <http://lpaste.net/98579> doesn't recognized properly then?
06:59:52 <t7> @hoogle Bool -> ma -> ma
06:59:53 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
06:59:53 <lambdabot> Control.Exception assert :: Bool -> a -> a
06:59:53 <lambdabot> Control.OldException assert :: Bool -> a -> a
07:00:04 <t7> @hoogle Bool -> m a -> m a
07:00:05 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
07:00:05 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
07:00:05 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
07:04:29 <merijn> pxqr: You can't have headers in the module preamble
07:04:53 <merijn> pxqr: You create headers by adding commented entries in the module export list
07:05:28 <geekosaur> see "odd resrictions"
07:06:06 <t7> @hoogle Maybe a -> Either a ()
07:06:07 <lambdabot> Prelude Left :: a -> Either a b
07:06:07 <lambdabot> Data.Either Left :: a -> Either a b
07:06:07 <lambdabot> Prelude Right :: b -> Either a b
07:07:45 * hackagebot tree-view 0.3 - Render trees as foldable HTML and Unicode art  http://hackage.haskell.org/package/tree-view-0.3 (EmilAxelsson)
07:07:54 <ocharles> https://twitter.com/HaskellLens I may come to regret this...
07:09:03 <bergmark> :-)
07:09:11 <alpounet> ocharles: no room for a minimalistic example I guess
07:09:37 <ocharles> alpounet: there might be for some tweets
07:10:11 <alpounet> or maybe a link to a lpaste/gist
07:11:03 <ocharles> alpounet: well I link to the documentation, and the documentation should have an example :)
07:11:26 <pxqr> i didn't even knew we can add "-- | comments" in the module export list, except "-- * Section" thing; though i still can't see how heading should be added; could you give some example?
07:12:16 <ocharles> pxqr: what do you mean by "can be added"?
07:12:27 <ocharles> you add headings with -- *, but you know that - because you just said it :)
07:13:07 <pxqr> ocharles: i mean "-- = Heading" there
07:13:53 <pxqr> just like "# Heading" or "Heading\n=========" in markdown
07:14:09 <ocharles> I'm still not understanding what you're asking
07:14:35 <pxqr> http://www.haskell.org/haddock/doc/html/ch03s08.html the last section, namely 3.8.15
07:15:06 <ocharles> Oh, I wonder if that's out of date. Does * work instead of = ?
07:15:21 <ocharles> Or does that only work in the module export part?
07:15:24 <joe9> mm_freak: ok, thanks
07:15:53 <pxqr> doesn't -- * is context sensitive?
07:16:10 <pxqr> -- * in export list make module "index"
07:16:26 <merijn> pxqr: Haddock doesn't support markdown
07:16:30 <MasseR_> muttlist
07:16:36 <pxqr> -- * in item documentation makes bulleted list
07:17:44 <merijn> pxqr: If you want an example, see: http://hackage.haskell.org/package/transformers-supply-0.1.0/docs/src/Control-Applicative-Supply.html
07:18:03 <merijn> pxqr: You can see the result in the hackage documentation
07:18:42 <pxqr> merijn: ah, i see;
07:18:47 <pxqr> thanks, nive example
07:18:53 <pxqr> *nice
07:19:10 <joe9>  what is the package name for the haskell generics diff?
07:19:44 <joe9> Data.Generic.Diff
07:19:51 <ocharles> merijn: interesting library, what are you using it for?
07:23:05 <merijn> ocharles: I was using it to have a convenient way of producing unique identifiers when playing with FRP
07:23:20 <ocharles> supplying [0..] or something?
07:23:36 <prinsen> TH question: I'm in a Q do block and have a Exp, how do I make it into a Q Exp to use with $?
07:23:54 <merijn> ocharles: For example, or using an iterate approach (i.e. 'a' and 'a -> a')
07:24:10 <merijn> prinsen: return?
07:24:19 <merijn> Q is a monad
07:25:05 <prinsen> merijn: yes I ḱnow, quite new at this so I forgot
07:25:09 <merijn> :)
07:25:52 <prinsen> merijn: thanks
07:27:46 <t7> are there any other (hypothetical) potentially useful kinds apart from *, ->
07:30:18 <merijn> t7: In haskell or in general?
07:30:31 <t7> general
07:30:47 <merijn> Yes, that's why dependent languages give you an infinite number of kinds
07:30:47 <t7> i know haskell has unboxed and stuff?
07:31:01 <t7> merijn: lets say i dont have dependant types
07:31:27 <merijn> t7: Habit, the (I presume dead) strict haskell dialect proposed a special kind for memory allocations so you can have type safe pointers
07:32:15 <dmj`> if I spawn a process w/ runInteractiveCommand and getProcessExitCode returns, do I still need to call terminateProcess?
07:32:41 <ski> t7 : rows
07:34:51 <geekosaur> dmj`: no
07:35:17 <geekosaur> I would inf act say that under normal circumstances you should not be using terminateProcess at all. do you normally `kill` random stuff st the shell?
07:36:06 <tommd> merijn: Habit is a quiet team but certainly not dead.
07:36:57 <tommd> merijn: The "Ivory" EDSL borrows MJ's memory ideas and implements them using DataKinds along with a number of other extensions.
07:38:33 <dmj`> geekosaur: It's just that I'm calling runInteractiveCommand inside a loop (forM_) and I want the handle completely deallocated before I call it again. Also, in cases where the process fails I'm reading from stderr, I want to close this too so I don't leak memory, but the haskellwiki tells me that's a bad idea.
07:38:48 <dmj`> it says, "It is important never to call hClose on a file-handle which has had hGetContents run on it already. The file handle is in a semi-closed state, and will be closed when the resulting string is garbage collected. Closing it manually may result in a random truncation of the input."
07:41:41 <merijn> dmj`: If you want control over deallocation, you essentially want to avoid lazy IO
07:42:02 <merijn> dmj`: i.e. you want something like pipes or conduit
07:43:34 <joe9> I have a loop process which gets some data and displays it. I want it to highlight the differences between the data now and the previous data, similar to how the watch command works. I am checking out the Diff library but that does not seem to be geared towards this.
07:43:37 <joe9> Any thoughts, please?
07:46:16 <dmj`> merijn: didn't know conduits had a process library.
07:50:07 <lingxiao> hey all I'm having a little issue and would like to know what some of the existing solutiosn are
07:50:59 <prinsen> I use newName "Test" to generate the name for a datatype. However I get 'Multiple declarations of `Test`', what can cause this?
07:51:01 <saml> hey,  i have  c :: H -> R;  f :: H -> H;  g :: C -> C;  (g c) (f h) = c h;   I want to find such g  given f. is it possible?
07:51:12 <enthropy> joe9: how not? I won't do the highlighting, but for sure you can take a [Diff Char] and make something colorful
07:51:27 <saml> f h gives you h';  g c gives you c';   so  c' h' = c h = r
07:51:54 <saml> f is arbitrary transformation of h.   so given h, i want a g such that (g c) (f h) = c h
07:52:33 <saml> g :: (H -> R) -> (H -> R)
07:52:41 <lingxiao> So I built an ULC interpretor already, and now I'm building one for STLC
07:53:21 <lingxiao> now it makes sense that after type checking, I can just erase the type in STLC ADT and use the ULC interpretor. however the result is untyped!
07:53:52 <prinsen> any idea?
07:54:08 <enthropy> saml: so is g :: C -> C, or is it g :: (H -> R) -> (H -> R)?
07:54:12 <mr-> lingxiao: don't you know what the type is supposed to be and can just add it again?
07:54:24 <merijn> dmj`: I dunno if it does, but conduits and pipes should just work with handles, so I'd just use that
07:54:36 <lingxiao> one way around this is to not erase the type per se, but store it elsewhere in each node, and "jimmy" the ULC interpreter so that it igornes the extra store, then add it back
07:54:36 <saml> type C = H -> R
07:54:47 <saml> they are the same
07:55:14 <lingxiao> mr-: uh then I would have to store a mapping between variable and type, and then descend the fully evaluated AST and annotate th types right?
07:55:33 <lingxiao> I was looking for someway that required less "work" :)
07:56:18 <saml> c is stylesheet. h is html.  f is DOM manipulation. c is stylesheet manipulation such that the result rendering is identical to previous rendering, before DOM manipulation.
07:59:11 <joe9> enthropy: thanks. I did not know abut the [Diff Char]. let me check on that.
08:01:01 <eacameron> I'm finding myself doing this more often than I would like: (f <$>) <$> data; is there some abstraction for that?
08:01:10 <joe9> enthropy: I am using box to print the output. I was not sure how I could use Diff Char on box'es?
08:01:56 <enthropy> joe9: look at the constructors for Diff
08:02:28 <enthropy> [Diff Char] is pretty much String with a bit of extra information
08:02:51 <ion> eacameron: (fmap . fmap) f data might look nicer.
08:03:21 <eacameron> ion: oh cool, I wasn't sure if that was equivalent
08:03:50 <prinsen> merijn: How do I generate unique data type names?
08:06:32 <enthropy> saml: probably not in general? If f had an inverse: g f f_inv c fh = f $ c $ f_inv fh
08:06:49 <enthropy> but probably you can't find one (say f deletes elements or whatever)
08:07:04 <saml> ah thanks
08:07:24 <enthropy> doesn't mean you can't find g to work in specific cases
08:08:12 <t7> @kind a -> b
08:08:13 <lambdabot> Not in scope: type variable `a'
08:08:13 <lambdabot> Not in scope: type variable `b'
08:08:16 <saml> i wanted to randomize html markup for each user. and supply dynamically generated css so that the page renderes the same for all users. but markups are all different
08:08:19 <t7> @kind forall a b. a -> b
08:08:20 <lambdabot> *
08:13:42 <eacameron> is there a tutorial explaining the type "substition" that happens with (fmap . fmap). I'm having trouble seeing how the type signatures end up the way they do
08:15:24 <joe9> enthropy: ok, thanks.
08:15:26 <zett_zelett> Today, a classmate said to me that he thougt Java was more *beautiful* than Haskell.
08:15:30 <mauke> eacameron: it's all intuitively obvious
08:15:33 <zett_zelett> Not fun.
08:15:35 <zett_zelett> Not useful.
08:15:45 <zett_zelett> *Beautiful*.
08:15:49 <zett_zelett> :/
08:16:01 <mauke> eacameron: but seriously, where are you stuck?
08:16:08 <eacameron> mauke: I sense that you're right...my faulty intuition is the issue
08:16:10 <mm_freak> zett_zelett: someone on this planet finds cobol beautiful
08:16:14 <mm_freak> don't worry about it
08:16:53 <eacameron> mauke: perhaps I am substituting incorrectly based on right or left associativity
08:17:58 <mauke> what exactly are you substituting where?
08:18:26 <eacameron> for fmap . fmap; does (.)'s first arg (b -> c) map to fmap like this: (((b -> c) -> f b) -> f c)? (extra parens for clarity)
08:18:37 <mauke> no
08:18:41 <eacameron> ah
08:18:49 <mauke> -> is right associative
08:20:57 <eacameron> mauke: so (b -> c) is substituted as ((b -> c) -> (f b -> f c))?
08:21:37 <zett_zelett> mm_freak: I just don’t know what to say to him. I was literally speechless. I just can’t imagine someone finding more beauty in Java than in Haskell. Anyway, that really frazzled me out, so I had to get that off my chest.
08:21:58 <mauke> eacameron: that looks good
08:22:20 <mauke> fmap takes a function a -> b and returns a lifted function f a -> f b
08:22:47 <eacameron> mauke: good point...ok..I'll work it out from there and hopefully that's where I went wrong
08:22:57 <mm_freak> zett_zelett: people have different senses of beauty
08:23:31 <jcristov1o> hi... in order to see if I understand the (.).(.), I've tried to devise something with a diferent signature, (b -> c -> d) -> (a -> b) -> (a -> c -> d)
08:23:50 <jcristov1o> but I can't seem to get there just with (.) or fmap
08:24:10 <zett_zelett> mm_freak: I dunno. I don’t want to turn this into a discussion, but I always thought that people have different *notions* of beauty many of which are naïve, immature or simply wrong.
08:24:17 <mm_freak> zett_zelett: also beauty is one in a group of related properties:  aesthetics, beauty, elegance, intuitiveness, etc.
08:24:34 <mm_freak> zett_zelett: someone may find java code more beautiful, but still find haskell code more elegant
08:26:36 <mm_freak> zett_zelett: notions of beauty cannot be naive/wrong…  in the same way that it's not wrong for someone else to love spaghetti, when you hate it =)
08:28:57 <zett_zelett> mm_freak: I disagree wholeheartedly. Just like someone may think "Only candy tastes good." (immature) or "To me, something tastes good if it contains peppers or bananas or red meat." (naïve), notions of beauty can be immature or naïve. It can also be wrong, like saying "Everything that is good for my body tastes good."
08:31:02 <mm_freak> zett_zelett: so what is "right" beauty?  how do you define it?
08:33:03 <zett_zelett> mm_freak: Well, I don’t know. I don’t think it can be defined suitably. But I think it can be discovered by anyone which is a quest of refining one’s notion of beauty.
08:33:12 <mm_freak> zett_zelett: or why is it wrong to find java beautiful?  isn't it just your sense that java must be found ugly by everybody, because you find it ugly?  don't get me wrong, i find it ugly as hell, but i don't believe in a globally uniform sense of beauty
08:34:11 <mm_freak> in fact i have found that many people find haskell ugly, simply because it doesn't have the hordes of C-style braces scattered around in the code
08:34:46 <hodapp> I actually find Java fairly clean if one ignores the annoying level of verbosity.
08:35:08 <mm_freak> hodapp: if you ignore that it looks pretty much like C
08:35:18 <mm_freak> and that's what many people expect from a programming language
08:36:20 <zett_zelett> Well, it can’t be inheritly wrong to find Java beautiful.
08:36:29 <mm_freak> for example what makes code beautiful for me is arrows, ∀, ◇ and the letter F
08:36:54 <zett_zelett> There are two important points:
08:36:55 <t7> @kind forall a. Maybe
08:36:56 <lambdabot> * -> *
08:37:12 <mm_freak> there is no logical reason for this preference, but it makes haskell with emacs' haskell-mode a lot more beautiful to me than plain haskell
08:37:26 <zett_zelett> 1. The question is about thinking Java is beautiful *in comparison* to Haskell.
08:38:20 <hodapp> mm_freak: What I'm talking about is more the absence of tons of complete warts that are present and often necessary in C++, and some things that make it much more amenable to static analysis.
08:38:43 <XniX23> is the tutorial functors,applicative functors, monads in pictures explaining exactly what a monad is? Or will i later find out that it's not exactly the way its described?
08:39:09 <XniX23> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#just-what-is-a-functor-really thats the tutorial
08:39:16 <mm_freak> XniX23: you will later find out that monads are nothing but what their specification requires
08:39:20 <zett_zelett> 2. What I left out, is that he didn’t seem to have put any thought into that assertion.
08:39:21 <mm_freak> XniX23: just like monoids
08:39:50 <XniX23> mm_freak: sounds easy
08:39:57 <ski> @type (.) :: (b -> c -> d) -> (a -> b) -> (a -> c -> d)  -- jcristov1o
08:39:57 <lambdabot> (b -> c -> d) -> (a -> b) -> a -> c -> d
08:40:24 <mm_freak> zett_zelett: 1. there is nothing wrong with finding java more beautiful than haskell…  you don't, i don't, most people here probably don't, but some people do, and you have to respect that
08:40:30 <zett_zelett> mm_feak: My sense of beauty is more developed than his, since I put thought to this notion, while he did carelessly use it.
08:40:32 <joe9> enthropy: quick question, can I do something similar with gdiff too? Is it similar in functionality to Diff? Sorry for the bother.
08:40:46 <mm_freak> zett_zelett: 2. you don't have to put thought into what is more beautiful…  it's an emotion
08:40:48 <zett_zelett> mm_freak: Why do I have to respect that?
08:41:26 <jcristov1o> ski, thanks...  I can define this as (f **.* g) x y = f (g x) y , for example
08:41:33 <zett_zelett> mm_freak: I mean, I know I sound pretty dickish right now and probably did so from the very beginning on, but I don’t feel that this reflects the world accurately.
08:41:47 <jcristov1o> but I want to know if there's a better solution, before defining a new operator
08:42:49 <zett_zelett> mm_freak: Saying "Everyone is entitled to their opinion." and leave it at that. I think there are developed opinions and non-developed opinions.
08:43:00 <zett_zelett> Anyway, I didn’t what to get too deep into a discussion, which we now are.
08:43:01 <hodapp> I don't know that it's meaningful to just say 'Beauty is purely subjective, end of story'.
08:43:22 <mm_freak> zett_zelett: because what someone likes and dislikes is an inherent part of their personality…  you can disagree, but don't turn your own preferences into a religion…  allow people to have other preferences
08:43:55 <zett_zelett> mm_freak: It’s not about preferences. It’s about the way of describing them.
08:43:57 <hodapp> You can allow people to have other preferences without completely dismissing the notion that their preferences might have any factual basis to them.
08:44:41 <mm_freak> zett_zelett: in my own view, anyone who willingly uses a non-static language is a complete retard (in most domains)
08:44:48 <zett_zelett> I mean, people may prefer, I dunno, Microsoft Word over vim for coding.
08:44:58 <zett_zelett> (If it’s possible to save in plain text?)
08:45:27 <mm_freak> zett_zelett: i have good reasoning for my view…  nevertheless there will be people who disagree — in fact there will be a lot of them…  they can still be good and smart people
08:45:30 <zett_zelett> Anyway, if they do so saying "I find word is more hackable and I can be more efficient with it.".
08:45:31 <zett_zelett> …
08:46:11 <RevJohnnyHealey> I find piet to be the most beautiful programming language.
08:46:20 <zett_zelett> I interpret that you find many people are retards, but they are entitled to be?
08:47:13 <Maior> can we use the word "retard" less please?
08:47:46 <enthropy> joe9: use whatever you like
08:47:47 <zett_zelett> Yes.
08:47:54 <mm_freak> Maior: sorry
08:48:01 <Maior> cheers
08:48:59 <zett_zelett> Or saying "I find you can express your ideas in less code with Java than in Haskell." is not *definitely* a falsifiable assertion, but everyone knows, it’s pretty false.
08:49:26 <ski> jcristov1o : (**.*)  ={eta}=  \f -> (f **.*) f  ={eta}=  \f g -> f **.* g  ={eta}=  \f g x -> (f **.* g) x  ={eta}=  \f g x y -> (f **.* g) x y  ={DEF}=  \f g x y -> f (g x) y  ={eta}=  \f g x -> f (g x)  ={DEF}=  \f g x -> (f . g) x  ={eta}=  \f g -> f . g  ={eta}=  \f -> (f .)  ={eta}=  (.)
08:49:35 <zett_zelett> Anyway.
08:49:46 <mm_freak> zett_zelett: none of this is beauty, and even beauty has many aspects
08:49:52 <yogurt_truck> zett_zelett: how is it not falsifiable? one example is enough.
08:49:57 <mm_freak> for example i hate the ($) operator in haskell
08:50:04 <mm_freak> many people overuse it
08:50:09 <zett_zelett> Yeah, me too.
08:50:19 <jcristov1o> ski, thanks
08:50:24 <zett_zelett> (Hating it, not overusing it (I hope).)
08:50:32 <mm_freak> but yet this sense of beauty is /my/ sense
08:50:38 <mm_freak> some people agree with me, many don't
08:50:40 <zett_zelett> Well, it’s okay.
08:50:43 <Hafydd> What's an example "overuse" of $?
08:50:45 <zett_zelett> But you can talk about it.
08:50:46 <yogurt_truck> also, of course beauty is _entirely_ subjective. it's just that some things happen to be more intersubjectively beautiful than others
08:50:54 <mm_freak> Hafydd: a $ b $ c $ d $ e
08:51:06 <Hafydd> What's the problem there?
08:51:08 <enthropy> there's just one extra one in there
08:51:11 <zett_zelett> Instead of (a . b. c . d) e, Hafydd.
08:51:11 <mm_freak> Hafydd: and yes, in fact i do prefer (a . b . c . d) e
08:51:14 <ski> Hafydd : `f x $ g $ x'
08:51:27 <mm_freak> Hafydd: also:  print $ sin x
08:51:27 <kristof> Hi
08:51:30 <cschneid> mm_freak, zett_zelett: if those two structures are the same functionality - why prefer one over the other
08:51:32 <mm_freak> i do prefer:  print (sin x)
08:51:38 <ion> mm_freak: verily
08:51:44 <zett_zelett> cschneid: Why not?
08:51:44 <Hafydd> I agree with ski's example (because it's redundant), but the (.) alternative is longer.
08:51:51 <RevJohnnyHealey> @type ($) $ ($) $ ($) $ ($) $ ($)
08:51:52 <lambdabot> (a -> b) -> a -> b
08:51:57 * ski also (in most cases) prefers `(a . b . c . d) e' to `a . b . c . d $ e' (and that to `a $ b $ c $ d $ e')
08:51:58 <RevJohnnyHealey> overuse if $
08:52:02 <mm_freak> Hafydd: longer doesn't mean worse
08:52:27 * enthropy prefers a (b (c (d e)))
08:52:29 <cschneid> zett_zelett: that's not too good of a reason. They end up being the same, so does the (a . b) form give more flexibility in changing code?
08:52:41 <yogurt_truck> counting characters in an expression is kind of a silly way to decide what's better or worse
08:52:50 <kristof> In the way that fold and unfold are usually used together in a Hylomorphism, are monads and comonads used together in some way?
08:53:00 <mm_freak> kristof: not really
08:53:06 <mr-> yogurt_truck: silly in the sense of "fun and lets do it"?
08:53:07 <ski> Hafydd : with `a . b . c' we can decide to factor out whichever of `a . b' and `b . c' we like, giving it a name. with `a $ b $ c $ x', we can't
08:53:12 <Hafydd> Any aesthetic advantage gained by adding parentheses doesn't seem to overcome the practical advantage of having shorter lines.
08:53:25 <kristof> mm_freak: Aw :( I thought there was going to be something cool at the end of that thought
08:53:38 <mm_freak> kristof: categorically there is, but not in practical haskell
08:53:43 <kristof> ok
08:53:46 <ski> enthropy's version also has merit. brackets aren't scary in themselves. not everything has to be written with `.' or `$'
08:54:00 <zett_zelett> cschneid: I dunno, probably not. Do they give less flexibility? If so, do you have an example?
08:54:13 <Hafydd> Reasonable point.
08:54:13 <cschneid> zett_zelett: I was looking for the thing that ski just mentioned
08:54:22 <enthropy> (ski and I sometimes write text like this)
08:54:23 <cschneid> zett_zelett: ie, does it make life as a programmer easier one way or the other
08:55:06 <ski> (but if you get many more contiguous trailing close brackets at "the end", that can be a sign that `.' (or `$') could be useful)
08:55:40 <zett_zelett> cschneid: While this is a very important feature of code, I think, it is more important to beauty of code, whether it denotes meaning.
08:56:18 <zett_zelett> cschneid: So, function composition is more denotational than function application. At least it is to me, as a mathematician.
08:56:18 <cschneid> zett_zelett: right, but being able to easily refactor components leads to making better names (if only because of less friction to do it).
08:56:23 <ski> also, in some cases it might be nicer to think of a piece of code as a "pipeline" (that is being built), rather than thinking about it as how to further process a particular individual input ("point")
08:56:25 <yogurt_truck> mr-: silly as in absurd and context-less (i.e. the kind of claim that is immediately be disproven with examples of whatever the contrary is)
08:56:34 <cschneid> zett_zelett: sure, and I'm coming to haskell as a programmer, not a math focused person
08:57:04 <zett_zelett> cschneid: Anyway, that’s a point where I easily say that’s a matter of where are you coming from and how you are looking at things.
08:57:26 <mr-> yogurt_truck: spoilsport
08:57:44 <zett_zelett> mm_freak: So this is a good example. You can talk about your senses of beauty. If you have a notion of it, in order for it to be somewhat meaningful, you should be able to talk about a bit.
08:57:47 <ski> cschneid : in the end, after considering options and alternatives, you should probably choose the version you consider most readable and most refactorable&"reasonable"
08:58:05 <zett_zelett> mm_freak: Else it isn’t very communicative to name it "beauty" at all.
08:58:13 <ski> (it is possible to overdo pointlessness)
08:58:22 <yogurt_truck> mr-: :)
08:58:29 <zett_zelett> mm_freak: And maybe in talking about it, you can make out the differences in your senses of beauty, and you can talk about them as well.
08:58:31 <cschneid> ski: yeah, it's hard to give rules about this kind of things. Was mostly looking for the tradeoffs between $ and . and () approaches :)
08:58:58 <mm_freak> zett_zelett: beauty is the property to be pleasing to my senses or to my mind
08:59:13 <mm_freak> zett_zelett: i think that makes beauty both reasonably defined and subjective
08:59:28 <zett_zelett> mm_freak: So why shouldn’t it be possible that it turns out that some of the reasons why someone finds something beautiful are rather immature or naïve?
08:59:34 <prinsen> I got a TH question about name generation, anyone??
08:59:57 <RevJohnnyHealey> What if someone finds beauty in things that are aesthetically displeasing?
09:00:03 <ski> (by "reasonable", i mean the properties of code that make it easier to *reason* about -- like checking whether the code does something or does *not* do something, whether it upholds some invariant, whether it satisfies a postcondition given a precondition being true, whether it satisfies a particular property you're interesting it, and whether a particular refactoring step is valid)
09:00:04 <zett_zelett> mm_freak: The conception of beauty might be subjective, but you can still attribute immatureness to it – why not?
09:00:13 <Philonous> prinsen, Please don't ask to ask, just ask.
09:00:14 <zett_zelett> To the conception, that is.
09:00:31 <prinsen> Philonous: ok
09:00:39 <mm_freak> zett_zelett: you can only do that in relation to other things
09:00:42 <zett_zelett> mm_freak: The only thing added is that you are allowed to qualify your sense of beauty, describe it.
09:00:46 <cschneid> ski: right. I need to go sit down and read a bunch of "professional" haskell code and see how people lay stuff out. How do they organize functions, when to use `where` blocks vs. top level
09:01:01 <cschneid> ski: and other similar approaches to laying out the program
09:01:01 <mm_freak> zett_zelett: example:  the person may have found java /visually/ pleasing, if you look at code as art
09:01:02 <zett_zelett> mm_freak: Can do what in relation to which things?
09:01:25 <mm_freak> zett_zelett: certainly you can't assign a value of maturity to this kind of beauty
09:01:34 <RevJohnnyHealey> mm_freak: AbstractPleasureFactoryProxy?
09:01:41 <mm_freak> ;)
09:01:47 <mm_freak> some people love long identifies
09:01:49 <mm_freak> identifiers
09:02:02 <zett_zelett> mm_freak: I don’t understand what you mean
09:02:08 <prinsen> I got a function that takes a value and generates a Dec ( a record type ), using newName to generate the data type name with newName "Test". I map this function over several values and return them in a list to top-level, where I get 'multiple declaration of "Test"' error, why?
09:02:17 <zett_zelett> mm_freak: That is, I don’t understand your example.
09:02:37 <LinearInterpol> dgpratt: o/
09:02:52 <mauke> prinsen: what's your code and error message?
09:02:56 <mm_freak> zett_zelett: visually i sometimes find 'f(x)' more pleasing than 'f x'…  only visually
09:03:06 <Philonous> @where hpaste
09:03:06 <lambdabot> http://lpaste.net/new/haskell
09:03:14 <Philonous> ^ prinsen
09:03:17 <mauke> some people are allergic to punctuation
09:03:21 <zett_zelett> mm_freak: But anyway, this guy just didn’t like haskell, because he didn’t grok it and therefore was calling Java more beautiful which is a wrong notion of beauty.
09:03:34 <zett_zelett> mm_freak: Of course, that’s my interpretation of it, but I’m pretty damn sure.
09:03:58 <mm_freak> zett_zelett: that's okay…  you can't make everyone love haskell =)
09:03:59 <dgpratt> hi LinearInterpol :)
09:04:03 <LinearInterpol> :)
09:04:12 <mauke> theyFind(codeLikeThis, inherentlyMoreReadable) than code <+> like{ this = or $ whatever }
09:04:39 <LinearInterpol> I do, unfortunately.
09:05:02 <LinearInterpol> Teach me your ways, strange ones. *cue OoOoOoOoOoOo*
09:05:20 <prinsen> mauke: http://lpaste.net/98585
09:05:33 <zett_zelett> mm_freak: No, but you shouldn’t call it less beautiful if that’s not what you mean. He probably thinks that Java is really more beautiful, but that’s because he has no or little concept of beauty. And this is what was frazzling me out.
09:05:49 <mauke> LinearInterpol: I'll just force you to do arithmetic in roman numerals
09:05:58 <LinearInterpol> I alreay do it in church numerals.
09:06:02 <LinearInterpol> :)
09:06:20 <mauke> LinearInterpol: too easy
09:06:25 <LinearInterpol> hehehe.
09:06:43 <mm_freak> zett_zelett: he probably said this, because he liked java more…  this is quite a valid sense of beauty
09:06:43 <zett_zelett> mm_freak: The thought of so many people studying computer science, not even developing a sense of beauty for code.
09:06:52 <LinearInterpol> Seriously, though, I'm a C programmer, and upon learning a tad bit of Rust, I kind of caught the flexibility bug.
09:07:00 <zett_zelett> mm_freak: There’s no way that’s a valid sense of beauty.
09:07:03 <LinearInterpol> For the next month, I'm putty in the hands of Haskell and Rust.
09:07:12 <ReinH> LinearInterpol: beauty is in the eye of the beholde. Unless you like Java. Then you're wrong.
09:07:18 <LinearInterpol> I hate Java.
09:07:41 <LinearInterpol> There's a reason that it lacks standardization.
09:07:56 <LinearInterpol> At least, recognition by a standards organization.
09:08:10 <prinsen> mauke: any idea?
09:08:39 <chirpsalot> LinearInterpol: standardization doesn't necessarily make things good.
09:08:55 <chirpsalot> It helps, though :P.
09:09:02 <LinearInterpol> chirpsalot: no, but it does give a framework for improvement. :)
09:09:03 <mm_freak> zett_zelett: he finds java more pleasing…  what's wrong with that?  it's the definition of beauty as defined at least by the oxford advanced learner's dictionary
09:09:25 <chirpsalot> LinearInterpol: "putty in the hands of Haskell and Rust"?
09:09:43 <zett_zelett> Oxford’s advanced learner’s dictionary then has a very unadvanced notion of beauty.
09:09:57 <LinearInterpol> chirpsalot: let me preface this: I'm an embedded programmer. I use C for far more than I really should on a daily basis.
09:10:06 <LinearInterpol> So I'm abandoning C in favor of brighter horizons.
09:10:14 <zett_zelett> No, of course, there’s much truth to that. Beauty is about finding things pleasing.
09:10:18 <LinearInterpol> dgpratt here is gonna convert me. :)
09:10:19 <mr-> prinsen: maybe it is case insensitive? ;-)
09:10:19 <chirpsalot> LinearInterpol: I am guilty of C for more than I probably should :(>
09:10:27 <zett_zelett> But not just and exclusively.
09:10:45 <chirpsalot> LinearInterpol: C is still handy. I wouldn't "abandon" it :P
09:10:48 <mbrock> Wittgenstein advised focusing on "the enormously complicated situation in which the aesthetic expression has a place" instead of looking for a final definition of terms like "beauty" :)
09:10:49 <prinsen> mr-: I think not!
09:10:49 <zett_zelett> It can be quite pleasing to sneeze, yet there is no beauty in it.
09:10:59 <LinearInterpol> When rust exists, why would I use it?
09:11:17 <LinearInterpol> I usually run with the pattern of C and Python, C for work, Python for prototyping.
09:11:23 <chirpsalot> LinearInterpol: because it's everywhere.
09:11:24 <pdpi> LinearInterpol: well, wait until Rust is a bit more mature, then.
09:11:28 <mm_freak> zett_zelett: don't you think that the problem at least /might/ be your own arrogance?  no offense intended
09:11:31 <mr-> prinsen: I really have no idea about anything in your code.. sorry
09:11:36 <LinearInterpol> I'm hoping to change that to Rust and Haskell.
09:11:49 <zett_zelett> mm_freak: What problem?
09:11:50 <hodapp> LinearInterpol: Which one for work and which for prototyping?
09:11:50 <LinearInterpol> pdpi: I'm watching it. Closely. Thinking of contributing, actually.
09:12:03 <LinearInterpol> hodapp: Both for both! :)
09:12:14 <tiffany> rust doesn't even have async IO yet, so you shouldn't get your hopes up that it can fully replace C
09:12:16 <pdpi> LinearInterpol: cool stuff. I was actually present when Graydon announced it to the world, it was pretty exciting.
09:12:23 <hodapp> at $jerb we use MATLAB for prototyping and for real work we use..... MATLAB, very painfully
09:12:24 <mm_freak> zett_zelett: your insistence that your coworker must have a wrong sense of beauty
09:12:27 <LinearInterpol> eeeee, wish I could've been there..
09:12:36 <mm_freak> s/sense/notion/
09:12:38 <zett_zelett> mm_freak: This is no problem, is it?
09:12:54 <mm_freak> zett_zelett: it's not
09:12:54 <LinearInterpol> tiffany: It's suitable for my needs right now. :)
09:13:11 <chirpsalot> hodapp: engineering?
09:13:27 <mm_freak> zett_zelett: not in general
09:13:30 <zett_zelett> mm_freak: You are right, though, that this stand seems very arrogant and it probably is.
09:14:04 <mm_freak> zett_zelett: i didn't want to state this too directly earlier, because you might find it offending =)
09:14:26 <zett_zelett> mm_freak: Yeah, I got that from subtext anyway.
09:14:54 <eacameron> is there terminology to describe algorithms on lists that can operate with constant memory on eath item as opposed to those that require the entire list before producing output?
09:15:28 <mm_freak> eacameron: right folds
09:15:31 <pdpi> mm_freak: to be honest though: Beauty is subjective, but there's some objectively ugly stuff out there. early Java was in that bag.
09:15:48 <mm_freak> eacameron: but right folds do not cover all such algorithms
09:15:50 <RevJohnnyHealey> One could make the argument that Java's beauty is in its minimalism. It does away with everything that is deemed unnecessary, like functions and closures.
09:16:02 <zett_zelett> mm_freak: But still, if you take the point of view that notions can be immature, wrong or whatever, and you find a certain notion of beauty to be wrong, what’s the problem?
09:16:04 <mm_freak> pdpi: is there?  i disagree
09:16:11 <pdpi> I mean, "I can't use a collection effectively without casting things left and right" is objectively ugly.
09:16:41 <RevJohnnyHealey> It has a type system that reduces programming to only the abstractions that are needed, objects and primitives.
09:16:56 <mm_freak> zett_zelett: there is no problem, but it's still just your opinion and you'll find that there will be people who don't share it
09:17:10 <XniX23> which parts of abstract algebra are good to know when haskelling?
09:17:10 <zett_zelett> mm_freak: It might be arrogant and offending to other people, but it’s not like I’m not willing to discuss the notions or my view of them. So what’s wrong with being arrogant? (I mean, I really don’t intend to and I don’t like being arrogant, but I just can’t help but seriously think that his notion of beauty is wrong or at the very least immature.)
09:17:51 <mm_freak> XniX23: basic group theory, basic category theory
09:18:15 <zett_zelett> mm_freak: I also tried hard to make that not too obvious, which is why I needed to let that out here.
09:18:21 <mm_freak> zett_zelett: don't worry about it, i'm arrogant as well =)
09:18:39 <XniX23> mm_freak: does that include homomorphism?
09:18:39 <halvorg> Hi, I want to memoize, lookup and update 1.5m million numbers loads of times, which data type should I use? Data.Map has O(log n) insertion and lookup, which seems a bit slow.
09:18:50 <zett_zelett> mm_freak: Yeah, you just offended a whole class of people using non-static languages.
09:18:53 <halvorg> in a tail recursive manner preferably
09:18:59 <mm_freak> XniX23: i would count that to basic group theory =)
09:19:00 <XniX23> or just what's a group, monoid, etc
09:19:16 <XniX23> ok
09:19:48 <mm_freak> XniX23: you don't need multi-operator structures (rings) most of the time
09:19:51 <mr-> halvorg: log 15000000 is about 6.2
09:19:54 <mr-> :-)
09:20:10 <halvorg> well, mr-. Good point
09:20:12 <eacameron> mm_freak: so let's say I have a function that *should* behave as a right fold, but doesn't; am I likely dealing with some overly-lazy code that I need to strictify?
09:20:12 <mm_freak> XniX23: it's good to know about semigroups, monoids and perhaps groups, and about *morphisms between them
09:20:14 <halvorg> : )
09:20:31 <mm_freak> eacameron: no
09:20:32 <zett_zelett> mm_freak: It’s also arrogant to complain about people studying computer science or mathematics with no interest in the subject at all, but yet I do and I don’t think it’s wrong to complain about it.
09:21:04 <ilmig_> in my experience O(log n) is the same as O(1) in practice...
09:21:04 <eacameron> mm_freak: great, thanks; guess I'll be on my way then.. ;)
09:21:43 <mm_freak> ilmig_: O(1) sometimes has an important advantage for raw code speed:  it's branchless
09:22:23 <ilmig_> mm_freak: hm, that's true!
09:24:39 <ChongLi> ilmig_: depends on the log's base
09:24:56 <ChongLi> log base 2 is a big difference from log base 32
09:25:24 <mbrock> even with base 2 you can binary search your entire memory space in a few dozen steps, right? :)
09:25:38 <mr-> ChongLi: a constant factor! :-P
09:25:39 <ilmig_> still, log2 is a _really_ slowly increasing function...
09:26:15 <ChongLi> > logBase 2 10^9
09:26:16 <lambdabot>  49262.00102085778
09:26:24 <ChongLi> > logBase 32 10^9
09:26:25 <lambdabot>  2.5222144522679187e-2
09:26:36 <mauke> SPACES AROUND OPERATORS PLZ
09:26:42 <mauke> > logBase 32 10 ^ 9
09:26:44 <lambdabot>  2.5222144522679187e-2
09:26:49 <mauke> ah, much better
09:26:55 <ChongLi> :)
09:27:17 <mr-> > logBase 32 (10 ^ 9) -- and brackets, of course
09:27:18 <lambdabot>  5.979470570797252
09:27:26 <ChongLi> oh, good point
09:27:27 <mauke> > logBase 32 1e9
09:27:28 <lambdabot>  5.979470570797252
09:27:30 <mauke> come at me bro
09:27:35 <boothead> is there any way to delete a package from hackage? I have a private hackage and want to remove an accidentally uploaded package..
09:27:41 <mbrock> > logBase 2 (2^64)
09:27:42 <lambdabot>  64.0
09:27:42 <ChongLi> logBase 2 1e9
09:27:43 <mbrock> ;)
09:27:50 <ChongLi> > logBase 2 1e9
09:27:51 <lambdabot>  29.897352853986263
09:27:52 <ilmig_> ChongLi: actually O(log2 n) = O(log32 n) ;)
09:28:17 <ChongLi> ilmig_: yeah, but that doesn't tell you about the practical difference in performance
09:28:39 <ChongLi> there's also the issue of constant factors, as alluded to earlier
09:28:51 <ChongLi> a binary search tree uses equality at every step
09:29:04 <ilmig_> ChongLi: the practical difference is a constant factor and the O-notation doesn't tell you anyting about constant factors anyway...
09:29:05 <ChongLi> and equality for large elements might be very expensive
09:29:06 <ski> RevJohnnyHealey : the Visitor Pattern (<http://c2.com/cgi/wiki?VisitorPattern>,<http://en.wikipedia.org/wiki/Visitor_pattern>) is ugly. it's needed in Java because it doesn't support proper sum / variant / coproduct / discriminated-union types (hence i don't buy "It has a type system that reduces programming to only the abstractions that are needed, objects and primitives.")
09:29:38 <ChongLi> whereas a HAMT uses hashing which might really cut down the constant factor
09:29:44 <mbrock> the visitor pattern appeals to my postmodern sense of beauty
09:30:04 <zett_zelett> What’s the visitor pattern?
09:30:29 * geekosaur sees two URLs there, consider visiting one of them?
09:30:40 <mbrock> it's sort of a hairy way to do double dispatch in single dispatch languages
09:31:23 <ski> zett_zelett : simulating variant types (more or less "algebraic data types", sans the multiple-argument-constructors), by multiple concrete subclasses of an abstract base class (or interface), one for each alternative
09:33:01 <prinsen> How do i print an IORef as a number
09:33:02 <prinsen> ?
09:34:49 <ski> zett_zelett : in Haskell terms, it's roughly like instead of doing `data Either a b = Left a | Right b' and `case parse stuff of Left parseError -> ..parseError..; Right parseResult -> ..parseResult..', ...
09:35:50 <ski> zett_zelett : ..., you do `data EitherBranches a b c = EB {onLeft :: a -> c,onRight b -> c}; data Either a b = E {visit :: forall c. (EitherBranches a b c -> c) -> c}', and `visit (parse stuff) (EB {onLeft = \parseError -> ..parseError.. , onRight = \parseResult -> ..parseResult..})'
09:36:08 <ski> zett_zelett : needless to say, the actual Java code is even uglier
09:36:32 <mbrock> an OO advocate might say that the Haskell case is equivalent to just branching with instanceof checks, which you can easily do in Java, whereas the visitor pattern gives you some flexibility that's actually kinda tricky to achieve in Haskell, too
09:36:48 <mm_freak> ChongLi: logBase c n = log n / log c
09:37:10 <mm_freak> ChongLi: 1/log c is a constant factor
09:37:13 <ski> it can be seen as related to CPS (Continuation-Passing-Style, which is known for "turning things inside-out") -- also sometimes one calls this a "Church representation" of the `Either' datatype
09:37:21 <ski> prinsen : no
09:37:42 <ski> prinsen : if you mean how you get from `IORef Integer' to `Integer', then try using `readIORef'
09:37:43 <ChongLi> mm_freak: good point
09:37:50 <mm_freak> ChongLi: which also indicates that a log-32 algorithm can usually be expressed in terms of a log-2 algorithm
09:38:11 <ski> zett_zelett : also see the links i provided
09:38:21 <ChongLi> mm_freak: now that I need more help with
09:38:29 <ChongLi> how would you express a HAMT in terms of binary trees?
09:39:11 <prinsen> ski: when I (show n) (n <- readIORef count) I get {tc 4P} (and GHC crashes)
09:40:13 <ski> prinsen : can you state (a) exactly what the input to GHC was; and (b) exactly how GHC responded
09:40:17 <ski> @paste
09:40:17 <lambdabot> Haskell pastebin: http://lpaste.net/
09:40:35 <ski> could be used to put it online if it's larger than a couple of lines
09:42:01 <prinsen> ski: http://lpaste.net/98587
09:42:42 <prinsen> ski: I know it's ugly, but I need to declare unique global names for data declarations
09:43:03 * hackagebot matrix 0.2.4.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.2.4.0 (DanielDiaz)
09:43:12 <levi> Regarding the earlier discussion; I'm also an embedded systems programmer and I'm excited about Rust, though I wish it had a bit of a better story for managing low-level representation of data than structs with a pack pragma.
09:45:06 <levi> And the reason I'm excited is that it gets rid of the things I like least about C syntax and adds some of the nice stuff from Cyclone without requiring a big runtime.
09:46:12 <mjboa> what are my options if I want to use a package that depends on older versions of packages than are installed on my system?
09:46:31 <geekosaur> cabal sandbox?
09:46:52 <enthropy> change the package
09:46:56 <geekosaur> note: if one of those packages is base then your option is to use hsenv to install an older compiler
09:47:09 <enthropy> change your mind about using that package
09:47:11 <prinsen> ski: any ideas?
09:47:31 <ChongLi> levi: what about something like Jhc?
09:47:32 <enthropy> just install the older versions (might be possible)
09:48:06 <ski> prinsen : i suspect there's something wrong with `createDataD', unrelated to `count', though i'm not sure
09:49:13 <prinsen> ski: It 'works' if I use newName, but the names are not globally unique, so I tried IORef
09:49:14 <mjboa> if I'm interpreting cabal's output correctly, I can't because base needs unix 2.6 but the package needs unix 2.5
09:49:15 <ski> (iow, related to the TH portions of the code)
09:49:21 <enthropy> prinsen: why can't you use mkName?
09:49:37 <enthropy> if you make the prefix "Data" a bit more creative it won't collide
09:49:54 <prinsen> enthropy: I need to generate globally unique names
09:50:18 <enthropy> right, your count IORef there is going to make that happen
09:51:00 <prinsen> enthropy: That was my plan
09:51:09 <enthropy> so does that work?
09:51:18 <levi> ChongLi: It's still got a reasonably large runtime, from an embedded systems perspective. I do want to play with it and the Ajhc fork, but I don't think it covers the same domain as Rust.
09:51:19 <prinsen> enthropy: http://lpaste.net/98587
09:51:30 <mjboa> do i have to enable library profiling in my sandbox config somehow?
09:51:31 <enthropy> that still uses mkNameU
09:51:43 <ski> @type mzero  -- t7 ?
09:51:44 <lambdabot> MonadPlus m => m a
09:51:54 <ChongLi> levi: I guess it depends on what sorts of embedded platforms we're talking about
09:51:54 <ski> @type guard  -- more specifically
09:51:55 <lambdabot> MonadPlus m => Bool -> m ()
09:52:17 <ChongLi> sometimes it makes sense to use a slightly more expensive chip if it saves a lot of developer time and bugs (due to a higher-level language)
09:52:18 <prinsen> enthropy: for 'name', but it fails at fieldName which uses mkName
09:52:32 <prinsen> enthropy: I can try to change both to mkName
09:52:56 <levi> I wish that Rust would have borrowed from the 'bitdata' idea from the Hobbit/Habit languages developed as part of the HASP project.
09:53:19 <ski> levi : what's that and why's that ?
09:53:37 <levi> http://hasp.cs.pdx.edu/
09:54:11 <levi> And specifically http://web.cecs.pdx.edu/~mpj/pubs/bitdata.html
09:54:46 <ChongLi> levi: sounds interesting
09:54:57 <ChongLi> I know that lens has some nice tools for working with bits
09:55:05 <ChongLi> but I don't know if they're optimal
09:55:39 <levi> In my day-to-day work, I do a lot of work with device drivers and network protocols, and I'm not happy with existing abstractions for dealing with that level of programming.
09:56:37 <hodapp> levi: have you made your case to Rust folks?
09:57:11 <hodapp> they might be willing to oblige
09:58:23 <levi> I should probably do that, but it's probably a bit late in the game for that now.
09:58:41 <hodapp> I don't know. Things hardly seem set in stone.
09:59:16 <bstrie> levi: is it something that could be done using a macro?
10:02:16 <levi> bstrie: Possibly macros could approximate it, but for a language at the level of Rust, it seems like something you might want baked-in.
10:06:20 <bstrie> levi: wouldn't hurt to suggest it to the mailing list, though I think they're aiming more for the C++ "very efficient application code" level than the C "device driver code" level. also they're approaching 1.0, so new features would have to pass a high bar at this point
10:06:58 <bstrie> if it *can* be done as a macro, then I'm sure that their response will be "just do it as a macro for now, and we'll think about it for rust 2.0" :P
10:08:41 <levi> Well, they were originally aiming in that direction, but they've done a lot of work recently to enable running without the runtime/stdlib for OS-level projects.
10:09:05 <ski> levi : hm, reminds me of "Compiler Generation for Interactive Graphics using Intermediate Code" in 1996-02 at <http://draves.org/cmu-research/dag/dag.html>,<http://repository.readscheme.org/ftp/papers/draves-nitrous.p(ps.gz|df)>, ...
10:09:09 <ski> ... "Implementing Bit-addressing with Specialization" in 1997 at <http://draves.org/cmu-research/bit-addr/bit-addr.html>,<http://repository.readscheme.org/ftp/papers/draves-bit-addr.p(ps.gz|df)>, "Automatic Program Specialization for Interactive Media" in 1997-07-23 at <http://draves.org/cmu-research/diss/main.html>,<http://repository.readscheme.org/ftp/papers/draves-thesis.p(s.gz|df)>, and "Partial Evaluation for Media Processing" in 1998-09 at <htt
10:09:16 <ski> hrm
10:09:21 <ChongLi> yikes
10:09:44 <ski> cut off parts in separate lines :
10:09:57 <ski> "Automatic Program Specialization for Interactive Media" in 1997-07-23 at <http://draves.org/cmu-research/diss/main.html>,<http://repository.readscheme.org/ftp/papers/draves-thesis.p(s.gz|df)>
10:10:04 <ski> "Partial Evaluation for Media Processing" in 1998-09 at <http://dl.acm.org/citation.cfm?id=289121.289142> (sorry for ACM)
10:10:11 <ski> all these four papers by Scott Draves
10:11:13 <ski> (also being aware of bit-pattrn-matching syntax in Erlang might be good)
10:11:38 <levi> Wow, those seem very cool, but more general (and a lot more work) than just bitdata.
10:12:56 <levi> And yeah, I Erlang bit patterns are something I often want as well. Of course I often want algebraic data and pattern matching in general when writing C.
10:13:21 <ski> <http://www.erlang.org/doc/programming_examples/bit_syntax.html>
10:13:27 <darkpassenger> total::Integer->Integer
10:13:29 <darkpassenger> total 0 = 0
10:13:37 <darkpassenger> total n = n + total n-1
10:13:41 <darkpassenger> gives me a stack overflow
10:13:45 <darkpassenger> always
10:13:45 <levi> Of course, this is somewhat similar to Wadler's work on Views as well.
10:13:51 <ski> darkpassenger : `total (n-1)'
10:14:16 <levi> darkpassenger: Beware the tight binding of function application.
10:14:20 <ski> levi : which work of his are you more specifically thinking of ?
10:14:33 <flebron> total n - 1 = (total n) - 1
10:14:39 <darkpassenger> ah hell
10:14:51 <mauke> SPACES AROUND OPERATORS PLZ
10:14:55 <darkpassenger> fine
10:14:56 <mauke> (quoting myself)
10:14:58 <levi> http://homepages.inf.ed.ac.uk/wadler/papers/view/view.ps
10:14:58 <darkpassenger> thanks guys
10:15:13 <flebron>  ( quoting myself )
10:15:17 <ski> darkpassenger : also, following mauke's advice, i'd prefer `total :: Integer -> Integer' as well
10:15:44 <darkpassenger> why ? (noob)
10:15:50 <flebron> reads a bit cleaner
10:15:57 <ski> (brackets are not operators, they (usually) prefer not having auxilary spaces directly on their insides)
10:15:58 <darkpassenger> oh , right
10:15:59 <mauke> are you french?
10:16:01 <flebron> same reason we put a space after a comma in english
10:16:02 <ski> darkpassenger : looks better
10:16:05 <mauke> (spaces before punctuation)
10:16:08 <levi> The space bar is really big for a reason. :)
10:16:21 <flebron> i learned that french people do that yesterday
10:16:28 <flebron> "hello ?"
10:16:47 * ski does it for `:' and `?'
10:18:22 <ski> (oh, and `!' of course)
10:19:10 * flebron wonders what's the number of LaTeX errors one has to get before one starts using ` in regular conversation
10:19:35 <merijn> flebron: It's proper in ascii too
10:19:44 <merijn> flebron: The fact that everyone else does it wrong is no excuse!
10:19:59 <FireFly> It's still a grave accent
10:20:05 <FireFly> and ' is an apostrophe
10:20:50 * mm_freak wonders what's the number of pandoc rendering errors one has to get before one stops abusing ` altogether
10:21:27 <mm_freak> well, as a LaTeX author you can't really stop abusing ` =)
10:22:46 <nstdloop> what is the name of >>?
10:22:51 <flebron> i was pleasantly surprised the other day when pandoc turned my "foo" into correctly directioned quotes
10:23:03 <mauke> nstdloop: >>
10:23:03 <flebron> nstdloop: bindgnore?
10:23:25 <ski> nstdloop : it's sometimes pronounces as "then"
10:23:26 <jedai> "then" ?
10:23:31 <nstdloop> I like then
10:23:32 <mm_freak> nstdloop: join . fmap . const
10:23:34 <nstdloop> it's short.
10:23:40 <mauke> >> is even shorter
10:23:50 <mm_freak> :t join . fmap . const
10:23:51 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
10:23:51 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
10:23:51 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
10:23:59 <FireFly> "greater-than greater-than" really isn't shorter
10:24:27 <magneticduck> hey guys, any ideas on a nice library in haskell to make drawing to openGL buffer things (still learning how to use openGL) a easier and functional?
10:24:51 <monoidal> liftM2 (const id)
10:24:56 <magneticduck> I mean, not Cish
10:25:05 <flebron> :t (. const) . (>>=)
10:25:06 <lambdabot> Monad m => m b -> m b1 -> m b1
10:25:46 <magneticduck> (s/a/a bit)
10:27:01 * ski . o O ( "Using Python to Code by Voice" by Tavis RuddTwo in 2013-03-20 at <http://www.youtube.com/watch?v=8SkdfdXWYaI> )
10:28:41 <magneticduck> huhu?
10:28:48 <magneticduck> coding by voice sounds... fun
10:28:54 <magneticduck> </sarcasm>
10:29:09 <bergey> magneticduck: I like GLUtil, or vinyl-gl if you're using custom shaders with a bunch of custom inputs.
10:29:13 <magneticduck> for people who have some sort of problem that disables them from using their hands, that sounds nice
10:29:14 <ski> (hrm, s/RuddTwo/Rudd/)
10:29:14 <Hafydd> open angle parenthesis slash sarcasm close angle parenthesis
10:29:17 <magneticduck> for everybody else, no thank you!
10:29:31 <magneticduck> bergey: btw what is that vinyl thing?
10:29:35 <simpson> magneticduck: It's a fascinating talk; go watch.
10:29:39 <magneticduck> is it just a name? or does it mean something
10:29:47 <bergey> I have some example code here: https://github.com/bergey/haskell-OpenGL-examples/tree/master/wikibook </plug>
10:29:55 <magneticduck> oh man, not making much sense today
10:29:57 <magneticduck> thanks
10:30:00 <magneticduck> (I
10:30:09 <magneticduck> (I'm not constructing sentences very well for some reason)
10:30:33 <FireFly> magneticduck: that video is pretty fascinating anyway, though
10:31:08 <darkpassenger> how do you guys deal with error message in function that does not return a String ?
10:31:09 <bergey> vinyl provides exensible, structurally-typed records
10:31:59 <bergey> It lets you write things like "this function argument must have a field named firstName of type Text", and provide records that fulfill that.
10:32:07 <bergey> http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
10:32:26 <darkpassenger> is that part of prelude ?
10:34:21 <geekosaur> darkpassenger, in Haskell you want to use something like Either. so you produce Left some_kind_of_error_indication or Right the_value
10:36:41 <flebron> darkpassenger: or if the error is nondescript, meaning you just know "there's an error", you can use Maybe instead of Either
10:37:04 <PaulFertser> Hi. A newbie question here. I see ncurses bindings wrap IO into Curses to perform mandatory housekeeping tasks before and after all curses operations. And I understand I can use liftIO and perform abritrary IO actions intermixed with curses actions. But imagine I have another library like that, that has some housekeeping tasks to perform in the very beginning and at the very end too. How to combine them?
10:37:09 <darkpassenger> I wanna warn the user about a negative square root...
10:37:19 <darkpassenger> squareroot function returns a float
10:37:24 <darkpassenger> Float
10:37:42 <flebron> darkpassenger: Then you could create squareRoot:. Float -> Either String Float
10:38:02 <darkpassenger> wow
10:38:05 <darkpassenger> ok
10:38:06 <darkpassenger> :)
10:38:20 <flebron> square_root x | x < 0 = Left "Nope, no negative square roots for you."
10:38:28 <flebron> otherwise = Right (sqrt x)
10:39:25 <int-e> > sqrt (-0) -- ridiculous
10:39:26 <lambdabot>  -0.0
10:39:37 <darkpassenger> square_root x | x < 0 = Left "Nope, no negative square roots for you."
10:39:45 <darkpassenger> sorry
10:39:55 <ski> > gcd 0 0  -- yay
10:39:56 <lambdabot>  0
10:40:01 <nadirs> flebron, darkpassenger: in such a case, do you think that using Maybe instead of Either would make sense?
10:40:07 <int-e> ski: that one makes sense
10:40:19 <ski> > 5 `mod` 0  -- unfortunately this errors
10:40:20 <lambdabot>  *Exception: divide by zero
10:40:23 <monoidal> gcd 0 0 was fixed relatively recently
10:40:38 <monoidal> ski: unfortunately?
10:40:44 <nadirs> I'm still trying to figure out when to use Maybe/Either in similar situations
10:40:45 <ski> it ought to give `5', imo
10:40:48 <bergey> sqrt :: Float -> Either (Complex Float) Float :)
10:41:05 <monoidal> ski: you couldn't rely on 0 <= mod a b < b then
10:41:18 <ski> yes
10:41:25 <int-e> hmm. 5 `divMod` 0 should be (bottom, 5)?
10:41:34 <flebron> nadirs: I use Maybe when there's only a single imaginable user why it failed
10:41:50 <flebron> (and by imaginable, i mean the user's imagination, not an implementation's)
10:42:19 <flebron> *imaginable reason
10:42:48 <ski> however, it would be nice if `flip mod n' (and `flip rem n') would give the appropriate representative of the input in `|Z / (n * |Z)'
10:42:57 <ski> int-e : imo, yes
10:42:59 <int-e> monoidal: 0 is funny because it is the largest element in the divisibility order (everything divides 0).
10:43:16 <int-e> monoidal: it's the exception that a
10:43:17 <monoidal> I know this
10:43:51 <PaulFertser> Folks, if I'm asking in an inappropriate way or doing anything else wrong, please just tell me.
10:43:51 <int-e> monoidal: it's the exceptional value of b for a|b implying a<=b in the naturals.
10:44:19 <monoidal> so if we think that (`mod` n) :: Z -> Z/n, there's some justification to (`mod` 0) = id
10:44:21 <int-e> (that said I don't feel very strongly about the value of a `mod` 0.)
10:44:59 <leino> PaulFertser: can you paste a link to the function in question?
10:45:25 <darkpassenger> when it is infered it compiles and it works but when I specify the type it just wont compile
10:45:29 <lpsmith> erg,  Data.Time.Format doesn't have a convenient way to show a time to the centisecond or millisecond.
10:46:01 <monoidal> darkpassenger: this sometimes happens; what is your code?
10:46:01 <PaulFertser> leino: runCurses from http://hackage.haskell.org/package/ncurses-0.2.7/src/lib/UI/NCurses.chs
10:46:57 <darkpassenger> http://pastebin.com/J0KstuaL
10:47:01 <darkpassenger> monoidal:
10:47:05 <mauke> The paste J0KstuaL has been copied to http://lpaste.net/98592
10:47:32 <monoidal> darkpassenger:
10:47:33 <monoidal> :t sqrt
10:47:34 <lambdabot> Floating a => a -> a
10:47:51 <monoidal> sqrt returns a value of the same type as input
10:48:05 <shachaf> Also :t Left and :t Right
10:48:19 <magneticduck> oh man, I wish I could just get down to making my game xD
10:48:28 <magneticduck> learning openGL is annoyin'.
10:48:53 <monoidal> darkpassenger: also as shachaf noted you've got Left and Right mixed; the convention is that Left is an error
10:49:01 <shachaf> ski: What's Z/0Z?
10:49:23 <ski> shachaf : iso to `|Z'
10:49:24 <monoidal> shachaf: quotient ring presumably
10:50:04 <darkpassenger> monoidal: how can sqrt returns an integer for an input like the number 3 ?
10:50:27 <monoidal> darkpassenger: you can't call sqrt on an integer - you have to convert it to a Floating value such as Double
10:50:33 <shachaf> You already can't rely on 0 <= mod a b, by the way
10:50:44 <monoidal> shachaf: where?
10:50:46 <shachaf> > 1 `mod` (-2)
10:50:47 <lambdabot>  -1
10:50:51 <monoidal> oh
10:51:06 <ski> `a' and `b' are considered equal in `|Z / (n * |Z)' exactly when `n | a - b', iow exactly when `exists k : |Z. k * n = a - b'
10:51:14 <ski> when `n = 0', this amounts to `a = b'
10:51:15 <shachaf> I'd think something like "if a `mod` n = b, then there should exist k such that a = kn + b",
10:51:18 <darkpassenger> monoidal: ah !
10:51:20 <shachaf> Right, what ski said.
10:51:21 <kristof> darkpassenger: You did see the typeclass restraint, didn't you?
10:51:31 <shachaf> ski: But k should also be unique.
10:51:33 <darkpassenger> kristof: typeclass restraint ?
10:51:50 <kristof> Typeclass constructor => paramtype -> paramtype
10:51:50 <magneticduck> so guys, if I want to go ahead and try making something using Gloss, is there any way to get around the fact that composing a whole lot of filled squares to make a pixelated display is really slow?
10:51:54 <ski> shachaf : it is, except when `n = 0'
10:52:08 <kristof> darkpassenger: I meant "constraint", not restraint, sorry
10:52:28 <monoidal> darkpassenger: in Floating a => a -> a, that's the "Floating a" part, which restricts possible choices for 'a'
10:52:34 <ski> (<http://en.wikipedia.org/wiki/Divisor>)
10:52:37 <kristof> darkpassenger: But yes, the bit before the "=>" specifies what types a can be
10:52:59 <simpson> magneticduck: Doesn't have to be slow. You want to make the faux-80s-screen style?
10:53:14 <darkpassenger> i use ->
10:53:22 <darkpassenger> what's => in haskell &
10:53:31 <magneticduck> kind of, a bit more fancy though (I want them to change their size slightly relative to each other to give a sense of layering and depth)
10:53:49 <magneticduck> simpson: but last I tried, composing around 500 filled squares was.. really slow with gloss
10:54:15 <kristof> darkpassenger: I just spelled it out for you! if you've got a function with signature a -> a and you ONLY want to be able to have Orderable inputs, then you'd write :: Ord a => a -> a
10:54:16 <magneticduck> probably the fact that Gloss is composing a *list* of squares
10:54:17 <simpson> magneticduck: I guess that'd be a problem with how gloss draws stuff. A VBO of 500 polys would *not* be hard for even an older graphics card.
10:54:26 <kristof> darkpassenger: Go read Learn You a Haskell
10:54:29 <magneticduck> yeah, I know
10:54:32 <magneticduck> it's how gloss does it
10:54:43 <magneticduck> but my problem is that openGL is a bit confusing xD
10:54:47 <magneticduck> oh well, I'll just have to get through this
10:55:13 <darkpassenger> kristof: I learned haskell yesterday
10:55:25 <magneticduck> nobody learns haskell in a day lol
10:55:28 <magneticduck> ^^
10:55:28 <ski> darkpassenger : `3' is overloaded. it can have type `Int', or `Integer', or `Float', or `Double', or `Rational', or `Complex Double', or indeed any type `a' which is an instance of the `Num' class
10:55:34 <kristof> darkpassenger: You learned some Haskell, go learn some-more :)
10:55:38 <ski> > 3 :: Int
10:55:39 <lambdabot>  3
10:55:40 <ski> > 3 :: Double
10:55:41 <lambdabot>  3.0
10:55:44 <ski> > 3 :: Rational
10:55:45 <lambdabot>  3 % 1
10:55:48 <darkpassenger> kristof: yeaaa
10:56:24 <ski> note that the `:: ...' here is *not* a cast in any way. it is a "type ascription", which ascribes a specific type out of many possible, to choose for `3'
10:56:27 <darkpassenger> its not haskell 98 is it
10:56:28 <darkpassenger> :p
10:56:37 <monoidal> => is haskell 98
10:56:43 <jhasse> If I have a state monad (STM Int Char) and for debugging I want to see its "content" in ghci. How would I do that?
10:56:53 <ski> type classes and class constraints are Haskell 98, yes
10:56:57 <leino> PaulFertser: it is a bit hard to answer in general, but in the case of this particular function (runCurses), I guess you can't.
10:57:18 <shachaf> jhasse: STM doesn't take two arguments (and isn't a state monad), so it's hard to tell what you mean.
10:57:26 <ski> @kind Control.Concurrent.STM.STM
10:57:27 <lambdabot> * -> *
10:57:28 <shachaf> Do you mean State?
10:57:43 <ski> @kind Control.Monad.State.State
10:57:44 <lambdabot>     Type synonym `State' should have 1 argument, but has been given none
10:57:44 <lambdabot>     In a type in a GHCi command: State
10:58:10 <PaulFertser> leino: well then, how do I design another library that needs some init/deinit (just like curses) and would be easily composable with this curses one?
10:58:13 <ski> @kind Control.Monad.State.StateT Identity  -- bah
10:58:13 <lambdabot>     Expecting one more argument to `Identity'
10:58:14 <lambdabot>     In a type in a GHCi command: StateT Identity
10:58:16 <jhasse> shachaf: It's not a standard haskell monad, I have a file where the STM monad is implemented given for my class.
10:58:40 <ski> er
10:58:42 <shachaf> Oh. Does it stand for "STate Monad" or something like that? :-(
10:58:58 <kristof> shachaf: ...software transactional memory? :)
10:59:07 <shachaf> kristof: What?
10:59:10 <jhasse> http://lpaste.net/98594
10:59:19 <shachaf> jhasse: Anyway, you have the file, so you should know better than we do.
10:59:32 <shachaf> Oh, this thing.
10:59:40 <kristof> shachaf: Oh, I misinterpreted the situation
10:59:45 <jhasse> I now have a function "shift :: Type -> STM Int Type". How would I "see" its return value?
10:59:54 <shachaf> Someone was just talking about this monad yesterday.
10:59:59 <monoidal> jhasse: the name "STM" is already commonly used for a different monad; I would change it so you will not confuse readers
11:00:03 <shachaf> I guess being an assignment for a class explains it.
11:00:17 <ski> jhasse : just use `runStateT' to see its "content"
11:00:23 <shachaf> Wait, and "runStateT"?
11:00:27 <jhasse> monoidal shachaf: yes its an assignment. I have to use this code
11:00:37 <ski> (of course it's a function, so to inspect it, you'll have to apply it to some values)
11:00:54 <shachaf> Anyway, in order to get anything useful from shift, you have to give it a Type and an Int.
11:01:10 <shachaf> It'll give you a Type and an Int back.
11:01:26 <shachaf> (Or an error.)
11:01:55 <leino> PaulFertser: you could do otherLibraryInit >> runCurses curses >> doOtherLibraryDeinit, but the runCurses thing is always going to be a solid block where only curses will run at any one time, due to the way that the API is designed there (although maybe the ncurses bindings expose more granular functions?)
11:02:22 <k0ral> Hello, what is the proper way to implement monad morphism ? I'm manipulating various libraries that use distinct monads to manage errors (e.g. Either and Error) and I'd like to define a generic way to morph one to the other
11:02:31 <shachaf> By the way, this assignment looks confusing to me. You might consider learning how State works independently and then going back to the assignment, rather than doing it this way.
11:02:34 <PaulFertser> And in general: how do I think about a problem which involves combining two different unrelated init-actions-deinit things in general? How should that ncurses wrapper be written to faciliate combining with other libraries like that?
11:02:35 <magneticduck> hmm, what I would like would be a kind of template openGL game project ....
11:02:38 <magneticduck> can't seem to find anything simple
11:02:59 <magneticduck> I'm just too lazy to learn openGL properly and I really need to make something that gloss can't do
11:03:06 <adelbertc> has anyone read The Haskell Road to Logic, Maths, and Programming? http://www.amazon.com/Haskell-Programming-Second-Edition-Computing/dp/0954300696/ref=sr_1_fkmr1_1?ie=UTF8&qid=1389898550&sr=8-1-fkmr1&keywords=haskell+introduction+to+math+logic
11:03:09 <jhasse> shachaf: If I pass an Int to shift I get the following: http://lpaste.net/98595
11:03:11 <ski> (possibly using `Debug.Hood.Observe.observe' to observe the function that you get by `runStateT' ..)
11:03:16 <ski> @hackage hood
11:03:16 <lambdabot> http://hackage.haskell.org/package/hood
11:03:20 <leino> PaulFertser: it could have been provided as three functions (and again, maybe it is): initCurses, runCurses, deinitCurses
11:03:34 <jhasse> shachaf: ah wait, saw my mistake, sry
11:04:12 <MedDev> is there any graphing library for haskell where I can generate animated graphs? like a bar chart or line graph that will let me step through a time domain and see values at varying time values? It seems like all the ones out there (graphviz, and gnuplot in particular?) only generate static graphs
11:04:22 <PaulFertser> leino: that's what I want to avoid. Those curses bindings force both init and deinit, the user can't avoid it, it's good thing. I want my library to be as good (hehe), I want to guarantee init/deinit too.
11:04:32 <ski> jhasse : yes, it's easier at first to understand state monads if you skip the `Either' and `fail' stuff
11:04:35 <leino> PaulFerster: hmm.. or runCurses could have had the type: runCurses :: IO (Curses a) -> IO a, perhaps?
11:05:19 <jhasse> ski: I'm forced to use the STM monad though :/
11:05:32 <leino> PaulFertser: that way you can do runCurses $ otherLibraryInit >> ... >> otherLibraryDeinit; return curses
11:06:14 <ski> jhasse : but you could possibly follow shachaf's advice "You might consider learning how State works independently and then going back to the assignment, rather than doing it this way."
11:06:20 <darkpassenger> well the haskell crowd is sure less difficult than the C crowd :P
11:06:22 <PaulFertser> leino: yes, but I want to have otherLibraryInit/Deinit being forced upon the user too, I want to guarantee that.
11:06:38 <magneticduck> ahah I found https://github.com/shangaslammi/haskeroids/
11:06:58 <magneticduck> alright, time to take it apart and make myself some pixels
11:07:34 <jhasse> shachaf ski: Do you guys know a good tutorial? I read a wiki page about it, but it wasn't that helpful. I already know about Maybe/do/<<= and stuff
11:07:47 <leino> PaulFertser: ok, I see what you mean.
11:08:10 <PaulFertser> leino: two orthogonal libraries, each doing the "right thing", yes :)
11:08:13 * hackagebot mysql 0.1.1.6 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.6 (BryanOSullivan)
11:09:07 <PaulFertser> I really am puzzled, the answer must be somewhat obvious here. Just as obvious as using liftIO inside Curses.
11:10:21 <jrmithdobbs> PaulFertser: you would add a monad that contains both in it's type and lift between them (kind of what you're stuck with from what i see, why are you using curses in 2014 again?)
11:11:04 <davean> jrmithdobbs: Do you know of a better library?
11:11:28 <ski> jhasse : which wiki page ?
11:11:55 <jhasse> ski: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
11:11:55 <PaulFertser> jrmithdobbs: yes, what should I be using instead of curses? Low-level Gtk+ bindings? ;)
11:12:05 <Mait_> Is there good tutorial for QuickCheck? I've read FPComplete's one.
11:12:26 <leino> PaulFertser: oh! is Curses an instance of MonadIO? that changes things.. :)
11:12:36 <PaulFertser> jrmithdobbs: it's still unclear to me how to have two different independent libraries that would allow such a combining. I'm really new to all this fine stuff.
11:12:42 <ski> jhasse : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> (iiuc the first monad tutorial for programmers) might perhaps be interesting
11:12:50 <PaulFertser> leino: it it wasn't, I wouldn't mention liftIO, right?
11:13:13 <leino> PaulFertser: right!
11:13:22 <shachaf> Understanding "monads" is good, but here you don't have "monads", you just have this one type, which happens to be a monad.
11:14:40 <shachaf> So I would go with understanding the type first. You can use it with or without knowing about monads in general.
11:14:46 <davean> jrmithdobbs: ?
11:15:43 <defanor> "let g = (\x -> return (x+1)) <=< (\x -> return (x*100))" -- should it work? i'm getting an ambiguity-related error if not providing types explicitly (like :: Int -> Maybe Int)
11:16:35 <ski> jhasse : what shachaf is saying is one reason why it could be better to start with the simpler `data MyState sigma alpha = MS { runMS :: sigma -> (alpha, sigma) }' to understand, rather than the more complex `data STM sigma alpha = STM { runStateT :: sigma -> Either String (alpha, sigma) }'
11:17:07 <jrmithdobbs> davean: that's a hard question to answer with no context on what the ui is actually for but curses has hardly ever been the answer to "what should i use for x" ;p
11:17:08 <PaulFertser> leino: please do not get me wrong, I'm still learning. Have thought about this question for quite some time, but couldn't find the right way.
11:17:34 <ski> jhasse : iow, understanding the type `sigma -> (alpha, sigma)' is easier than understanding `sigma -> Either String (alpha, sigma)'; and understanding code using the former is easier than understanding code using the latter
11:19:03 <davean> jrmithdobbs: well, it sure beats doing it directly most of the time
11:19:37 <jrmithdobbs> davean: my point was more "if you're writing a ui for a tty in 2014, maybe you should reconsider whether you need a ui"
11:19:57 <leino> PaulFertser: but you can do it now since you have a MonadIO instance on Curses, right? For instance; curses in curses:  runCurses (liftIO $ runCurses (curses :: (Curses (Curses a))))
11:20:25 <davean> jrmithdobbs: Why?
11:20:37 <PaulFertser> jrmithdobbs: I just want some interactivity for an app that might be running on non-X terminal.
11:21:00 <jrmithdobbs> PaulFertser: why not just readline or editline then?
11:21:07 <PaulFertser> leino: yes, but I need to intermix calls to curses with calls to my other library (that I haven't written yet).
11:21:11 <davean> jrmithdobbs: I can list the times I've seen a GUI UI that beat a terminal UI in usability on two hands, and they all involve images
11:21:36 <davean> jrmithdobbs: the ease of interacting with a terminal is far greater
11:21:39 <jrmithdobbs> davean: i'll agree with that with the stipulation that none of the useful console apps involved curses.
11:21:40 <PaulFertser> jrmithdobbs: in fact I'm considering writing an interactive real-time robot control app.
11:23:14 <PaulFertser> And that robot needs proper init and deinit and I'd like to guarantee it, just like this curses libraries guarantees that for one's  screen.
11:24:12 <jrmithdobbs> PaulFertser: in that case i'd do a small rest interface for the actual controls so you could do simpler frontends where the code you speak of doesn't directly interact
11:25:27 <jrmithdobbs> PaulFertser: that's cleaner any how seeing as the robot probably shouldn't get stuck in a repetative task if the ui faults
11:26:26 <PaulFertser> jrmithdobbs: I see. So do you mean my initial question lacks sense because it should never be done and there're always better ways?
11:26:42 <ski> defanor : it should work, if you either add a type signature for `g', or eta-expand, or enable `NoMonomorphismRestriction'
11:27:06 <ski> (DMR strikes again !)
11:27:48 <jrmithdobbs> PaulFertser: even for mocking up the rest interface is quicker and easier to test for correctness, ya, it doesn't make sense to start with ncurses for anything
11:28:09 <ski> by "eta-expand" here i mean something like `g x = ((\x -> return (x+1)) <=< (\x -> return (x*100))) x' (adding an explicit argument to the left of the `='
11:28:42 <PaulFertser> jrmithdobbs: but that ncurses thing just made me think more about composability of such libraries. It's quite common for the real world when you need to mandate init/deinit.
11:28:51 <ski> to "enable `NoMonomorphismRestriction'", you can either pass `-XNoMonomorphismRestriction' to `ghc' or `ghci', or you can add `{-# LANGUAGE NoMonomorphismRestriction #-}' as the first line in your file
11:28:55 <ski> defanor ^
11:29:10 <jrmithdobbs> PaulFertser: oh sure, the general question is a good one
11:29:21 <defanor> ski: thanks, will try
11:30:02 <jhasse> ski: ic. Thank you! I hope I can do it, the assignment is due tomorrow
11:30:27 <ski> defanor : the summary of why this is needed is : it was thought that adding the monomorphism restriction would make some things easier to understand for newbies in Haskell -- with the result that some other things become harder to understand for newbies, such as your example above
11:30:46 <PaulFertser> jrmithdobbs: I'd also appreciate any hints about how exactly to start mocking that rest interface.
11:30:55 <defanor> ski: got it, thanks
11:30:58 <ski> (defanor : i hope you understand what i meant by the "add a type signature for `g'" option)
11:31:32 <ski> defanor : if you're ever curious about what issue the monomorphism restriction was supposed to improve, just ask
11:31:40 <defanor> ski: i hope so too. ":: Int -> Maybe Int" in the end?
11:32:09 <ski>   let g :: Int -> Maybe Int
11:32:15 <ski>       g = (\x -> return (x+1)) <=< (\x -> return (x*100))
11:32:28 <defanor> ski: i'm going to finish a book now, and then will have a bunch of questions, most likely. i'm curious, but have not learned more simple things yet, so i think i should learn them first
11:32:30 <jrmithdobbs> PaulFertser: i like yesod, other people really like scotty, others like the snap stuff ... they're all more than complete enough for writing rest interfaces
11:32:36 <ski> or with the more general `g :: Monad m => Int -> m Int' instead
11:32:57 <ski> (you could also generalize `Int' here to `a' adding a class constraint `Num a' before the `=>')
11:33:25 <defanor> i see, thanks for the explanation
11:33:48 <ski>       g = (\x -> return (x+1)) <=< (\x -> return (x*100)) :: Int -> Maybe Int  -- would also work in this particular case
11:34:08 <PaulFertser> jrmithdobbs: that all sound like web-frameworks. Did you mean REST over HTTP to control it with a web-browser?
11:34:17 <ski> (doing that type ascription instead of the type signature, i mean)
11:34:45 <jrmithdobbs> PaulFertser: i didn't say anything about a browser but the rest yes
11:35:35 <leino> PaulFertser: have you read about monad transformers yet?
11:36:00 <jrmithdobbs> PaulFertser: http over, eg, unix domain sockets, is as good an ipc mechanism as any. http != web browser
11:36:06 <PaulFertser> leino: I have, sure thing, just haven't really understood how and when to use them.
11:36:23 <leino> PaulFertser: they are for mixing monads together :)
11:36:55 <PaulFertser> jrmithdobbs: I sort of understand that but still feeling uneasy; don't like web-browsers much, so anything related raises an alarm you know :)
11:37:30 <JakeE> Does GHC use uses of a generic function to overcome the monomorphism restriction? I have a function which must be explicitly typed to overcome the monomorphism restriction. when I don't supply a type the compiler infers the type to be the EXACT type used in a call I make to the function. This is really strange and unexpected behavoir IMO
11:37:31 <PaulFertser> leino: I know but, ahem, I am yet to understand how to apply this knowledge, including to the problem I discussed initially.
11:37:54 <jrmithdobbs> PaulFertser: well welcome to the world we live in, http is used all over the place so the related libraries in any given language tend to be fairly mature so it's a pretty sane choice for things like this just out of practicality really.
11:38:14 <darkpassenger> whats the deal with the division in haskell
11:38:33 <leino> PaulFertser: I'd go check out a monad transformer tutorial and write some code using those, then write a transformer. They take a while to get used to, but I'm fairly sure that will answer your questions.
11:38:37 <geekosaur> are you trying to divide integers?
11:38:39 <JakeE> darkpassenger: it gives you a choice unlike other languges
11:38:44 <ski> JakeE : what if you disable the DMR ?
11:38:54 <JakeE> ski: what is "DMR"
11:39:02 <ski> Dreaded Monomorphism Restriction
11:39:04 <geekosaur> ?where dmr
11:39:04 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:39:07 <jrmithdobbs> PaulFertser: but yes, monad transformers are what you're looking for to get back on topic.
11:39:16 <JakeE> ski: O lol. let me check
11:40:21 <JakeE> ski: it infers the correct generic type when I disable DMR
11:41:00 <PaulFertser> leino: do you mean if I read monad transformers chapter on wikibooks again and actually do the exercises I'll understand how to solve the initial problem? That would be nice :)
11:41:22 <leino> PaulFertser: I guarantee it! (joking)
11:41:48 <PaulFertser> That said, after reading it for the first time I thought that Curses should be a transformer itself to make composing easier.
11:42:07 <ski> JakeE : the DMR (unless disabled) triggers when : (a) the definition has no explicit type signature; (b) the definition has no explicit arguments (to the left of the `='); and (c) the definition would otherwise be inferred to have a type involving constraints (iow `=>') (at the "top-level", to be pedantic)
11:42:09 <PaulFertser> But it's not, so I decided I'm missing something in my reasoning.
11:42:14 <darkpassenger> Instance of frationnal integer required for def...what does it mean ?
11:42:45 <leino> PaulFertser: If I understood your API design problem correctly, then yes I believe it could be done nicely (foolproof -- like you want) with transformers... but this is just me talking: I haven't actually written such code yet
11:43:04 <PaulFertser> leino: thank you for your suggestions, appreciated!
11:43:13 <leino> PaulFertser: no problem
11:43:14 <PaulFertser> jrmithdobbs: thank you too.
11:43:18 * hackagebot hspec-expectations-lens 0.2.0.0 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.2.0.0 (MatveyAksenov)
11:44:01 <ski> darkpassenger : it means you attempted to use `Integer's with `Fractional' operations, like `/'
11:44:20 <ski> > (16 :: Integer) / 7
11:44:22 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
11:44:22 <lambdabot>    arising from a use of `GHC.Real./'
11:44:22 <lambdabot>  Possible fix:
11:44:22 <lambdabot>    add an instance declaration for
11:44:22 <lambdabot>    (GHC.Real.Fractional GHC.Integer.Type.Integer)
11:44:26 <ski> > (16 :: Integer) `div` 7
11:44:28 <lambdabot>  2
11:45:04 <JakeE> ski: all of those things are true of my equation. it should be of type (ZipperTree a => Zipper a [a]). I make 7 calls to functions that have "ZipperTree a =>" as part of their type. It for sure needs a type by the monomorphism restriction as far as I can tell. It infers a very specific type (one used elswhere in the code) if I do not give it a type. If I take out the bit of code that uses it then GHCi tells me I need the type becuase of the monomorphism resi
11:45:04 <JakeE> trction
11:45:04 <ski> darkpassenger : `div' and `(/)' have different behaviour, they are not merely working on different types
11:45:25 <PaulFertser> leino: it's still funny my "common" question has no obvious answer.
11:45:35 <darkpassenger> fg::Integer->Integer
11:46:02 <aleksejs_> Hi, yesterday someone mentioned some cool function that did simething like map&fold. What was that function?
11:46:03 <darkpassenger> does div or / return an integer ? or do I have to return a "higher" type
11:46:09 <ski> JakeE : i'm not sure how to interpret "It for sure needs a type by the monomorphism restriction as far as I can tell." here
11:46:15 <joejev> :t div
11:46:16 <lambdabot> Integral a => a -> a -> a
11:46:28 <joejev> :t (/)
11:46:28 <lambdabot> Fractional a => a -> a -> a
11:46:34 <nstdloop> Is anyone here familiar with hakyll?
11:46:35 <ski> darkpassenger : `div' *can* return an `Integer' (it can also return an `Int')
11:46:48 <JakeE> ski: I mean that I have to give the function a type explicitly. I'll comment the code and post it on lpaste so you can see
11:47:07 <ski> `(/)' *can* return a `Double' (or a `Float', or a `Rational', or a `Complex Double')
11:47:27 <aleksejs_> :t toInteger . div
11:47:28 <lambdabot> (Integral (a -> a), Integral a) => a -> Integer
11:48:08 <darkpassenger> ski: my function returns an Integer, i don't understand the error message
11:48:09 <darkpassenger> lastf::Integer->Integer
11:48:09 <darkpassenger> lastf 1 = 0
11:48:19 <ski> JakeE : however, in each use, both `div' and `(/)' requires that both the inputs and the output have the same type, so you can't e.g. pass (directly) a `Float' and a `Double' to `(/)' and get back a `Rational'
11:48:30 <ski> er
11:48:32 <ski> darkpassenger ^
11:48:50 <JakeE> ya lol I was a bit confused for a second
11:48:57 <ski> JakeE : what if you disable the DMR ?
11:49:08 <ski> (did i already ask this ?)
11:49:18 <maxime_> lastf n = if even n then (2*n+1) else (n )
11:49:19 <maxime_> that was the last line
11:49:33 <JakeE> ski: when DMR is disabled it infers the proper type as expected. and yes you already asked that
11:49:50 <ski> @let lastf :: Integer -> Integer; lastf 1 = 0; lastf n = if even n then (2 * n + 1) else n
11:49:51 <lambdabot>  Defined.
11:50:34 <aleksejs_> can anyone remind me that function that took parameters as fold and returned (a,[a]), folded and mapped values?
11:51:02 <joejev> mapAccum?
11:51:12 <aleksejs_> :t mapAccumL
11:51:14 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:51:20 <aleksejs_> thanks
11:51:57 <ski> JakeE : since your `Zipper a [a]' (presumably) isn't equal (though maybe iso) to a function type, you can't employ the "or eta-expand" i suggested to defanor above
11:52:32 <ski> so it's either add a type signature (or maybe a type ascription), or disable DMR
11:52:57 <JakeE> I'm find with giving the type explicitly I just think the behavoir I am seeing is VERY odd
11:53:01 <ski> @type mapAccumR  -- aleksejs_, also this
11:53:02 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:53:21 <maxime_> else n / 2 actually...
11:53:25 <maxime_> either div or / would work
11:53:43 <JakeE> ski: look at this: http://lpaste.net/98603
11:53:44 <ski> @let swap = arr snd &&& arr fst
11:53:45 <lambdabot>  .L.hs:144:16:
11:53:45 <lambdabot>      No instance for (Arrow a0) arising from a use of `&&&'
11:53:45 <lambdabot>      The type variable `a0' is ambiguous
11:53:45 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
11:53:45 <lambdabot>      Note: there are several potential instances:
11:54:00 <eacameron> is there a list type that keeps track of length so that length operations are trivial?
11:54:10 <eacameron> but still linked list
11:54:31 <ski> @botsmack
11:54:32 <lambdabot> :)
11:54:38 <ski> @let swap :: Arrow ar => ar (a,b) (b,a); swap = arr snd &&& arr fst
11:54:39 <lambdabot>  Defined.
11:54:46 <joejev> Is abstract algebra helpfull for programming in haskell?
11:54:59 <zennist> In using 'spawn', I constantly get utf8 problems.. how to solve it?
11:55:19 <JakeE> joejev: well I can't speak from experience but it and catagory theory are banddied about quite a bit
11:57:31 <aleksejs_> is there any option to take values from infinite list while the sum of those values is less than n?
11:57:59 <Twey> joejev: About as helpful as for programming in general (i.e. really quite helpful)
11:58:22 <Twey> Haskell programmers have a tendency to give things mathematically-inspired names, so perhaps a bit more than most
11:58:26 <monoidal> aleksejs_: takeWhile (<n) . scanl (+) 0?
11:58:28 <maxiepoo> Aleksejs: takeWhile (< n) . scanl (+)
11:58:38 <JakeE> haha!
11:58:39 <Twey> eacameron: Yes, there's a package called ‘vec’ that implements such a thing
11:58:41 <maxiepoo> !
11:58:49 <eacameron> Twey: sweet
11:58:51 <Twey> ‘Vec’, even
11:58:59 <Twey> Oh
11:59:07 <Twey> eacameron: I think I misinterpreted your request, sorry
11:59:30 <eacameron> Twey, so sweat; I can easily write my own, just wondering if someone else already did
11:59:33 <Twey> Maybe Seq or something?
11:59:48 <joejev> Twey: do you know of any topics in particular to look out for?
11:59:55 <Twey> I'm sure *something* keeps a runtime length, I just don't remember which something in particular :þ
11:59:59 <aleksejs_> monoidal, maxiepoo, thanks, this is great! Haskell rocks! :)
12:00:03 <Twey> ‘Vector’ is popular these days (but isn't quite a list)
12:00:15 <erisco> is there a variant of a rose tree which allows for empty leaves? for example, you would need this to model an incomplete binary tree
12:00:24 <zennist> anyone gives me a hand? utf8 encoding/decoding in haskell is driving me mad
12:00:47 <eacameron> Speaking of lists, is there a language extension like OverloadedStrings for lists? Seems like it would be useful
12:00:49 <Twey> erisco: The tree in Data.Tree *only* allows empty leaves
12:00:51 <dgpratt> can one invite lambdabot to another channel? how is it done?
12:00:55 <joejev> zennist: doesnt Data.Text handle that?
12:00:57 <Twey> eacameron: Not yet, but I hear it's on its way
12:00:58 <monoidal> eacameron: yes, In upcoming GHC
12:01:17 <eacameron> monoidal: Twey: good...about time
12:01:31 <zennist> joejev: how exactly? what function?
12:01:34 <ski> @type mapAccumL
12:01:35 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:01:35 <Twey> joejev: I'm not really a mathematician
12:01:36 <ski> @type mapAccumR
12:01:37 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:01:39 <ski> @type flip . (((swap .) . runState) .) . mapM . ((state . (swap .)) .) . flip
12:01:39 <lambdabot> (b -> a -> (b, b1)) -> b -> [a] -> (b, [b1])
12:01:40 <erisco> Twey, you cannot use Data.Tree to model an incomplete binary tree
12:01:41 <ski> @type flip . (((liftM swap .) . runStateT) .) . mapM . ((StateT . (liftM swap .)) .) . flip
12:01:42 <lambdabot> Monad m => (b -> a -> m (b, b1)) -> b -> [a] -> m (b, [b1])
12:02:02 <Twey> joejev: I don't know how the subject is broken down, but I'm sure some things in there would be helpful
12:02:21 <erisco> Twey, by "empty leaf" I mean an empty constructor
12:02:24 <Twey> Just knowing the laws for the various different structures is pretty helpful to begin with
12:02:24 <ski> aleksejs_ : if you squint a bit, as above, `mapAccumL' is really `mapM'
12:02:39 <ski> (for the state monad, i.e.)
12:02:43 <Twey> erisco: Oh, I was thinking of something else, sorry
12:03:12 <Twey> Yeah, I guess Data.Tree isn't what you want
12:03:43 <JakeE> ski: did you look at the lpsate at all?
12:04:11 <JakeE> *lpsate link I posted
12:04:14 <erisco> data Rose a = Rose a [Maybe (Rose a)]   would work, for example, but this is not a traditional rose tree
12:04:31 <erisco> so if there is not a module for this, what I am seeking is the given name for such a tree
12:04:52 <ski> joejev : i suppose it's good to know what a monoid is .. also to be familiar with algebra laws in general, like the monoid laws, or the ones of groups or abelian groups or rings or fields or vector spaces
12:05:10 <platz> aleksejs_: traverse might also be an option?
12:05:13 <platz> :t traverse
12:05:14 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:05:41 <joejev> ski: Are there typeclasses for groups and such, as there are for monoid?
12:05:41 <platz> where f has your applicative effects
12:05:48 <dgpratt> @seen Cale
12:05:48 <lambdabot> cal3
12:05:56 <Twey> joejev: Not in base, but they're around
12:06:01 <JakeE> joejev: yes and a ring as well
12:06:01 <dgpratt> huh?
12:06:12 <nooodl> @seen is the best thing in lambdabot
12:06:12 <lambdabot> iS t|-|3 bES+ T|-|inG iN L4mbdAB07
12:06:20 <nooodl> (autocorrects to @leet)
12:06:23 <dgpratt> Cale, you around, good sir?
12:06:26 <erisco> Twey, one could hijack a rose tree using  Data.Tree (Maybe a)  perhaps
12:06:27 <ski> joejev : i'm not really talking about any advanced knowledge about those, but knowing what kind of things they are, what the laws are for (in general), and perhaps some important examples of such algebraic structures, and examples of using the laws to prove simple theorems
12:06:32 <joejev> JakeE: I guess that could be usefull for abstracting specifics
12:06:40 <Twey> erisco: Seems ugly if you always want to fill from the left, though
12:06:42 <ski> joejev : there could be a type class for groups
12:06:49 <ski> (and there probably is, in some package)
12:07:22 <Twey> erisco: (and even if you don't, since you don't get static guarantees about the size of each branch)
12:07:22 <erisco> Twey, I do not want to always fill from the left, which is what I mean by "incomplete" binary tree
12:07:26 <joejev> wait, is Maybe a group under composition?
12:07:56 <Twey> erisco: Well, I guess that suits, then
12:08:11 <ski> joejev : i mentioned monoids,groups,abelian groups,rings,fields,vector spaces since those are the most commonly known algebraic structures in mathematics -- however it appears that perhaps monoids are more important in CS than in Math, at least for "simpler" applications
12:08:37 <c_wraith> associativity turns out to be a really useful property in practical applications.
12:09:02 <joejev> ski: Yeah, I already had learned a lot about them from haskell and folds
12:09:10 <ski> joejev : it also helps to know what an "abstract data type" is (which is quite related to the mathematical concept of an "algebraic structure")
12:09:52 <ski> (though of course the ADT concept (at least as we're used to phrasing it) comes from CS, not from Math)
12:10:10 <joejev> ski: yes, I had some books, and I am taking a data structures course now
12:11:09 <ski> (also note than an "abstract data type" isn't the same as what object-oriented programming gives you -- these two are actually quite different ways of achieving data abstraction in programming (regardless of whether some people may claim the opposite))
12:11:45 <mm_freak> ski: "abstract" or "algebraic"?
12:11:53 <platz> I saw a video of someone converting an ADT to it's polynomial representation, differentiating it, and the output told you how to create a zipper for that ADT
12:12:08 <platz> or something to that effect
12:12:11 <mm_freak> platz: did you see a video or wikibooks?
12:12:24 <platz> video
12:12:26 <joejev> ski: The first book I got on data structures was in Pascal so I doubt it was using any OO concepts
12:13:02 <platz> http://www.youtube.com/watch?v=YScIPA8RbVE
12:13:06 <ski> joejev : yes, but some people have been claiming those two "are basically the same thing, just expressed differently in different languages"
12:13:26 <platz> the type caclulus stuff is around 42:00
12:14:12 <platz> "The derivative of a Regular Type is its Type of One-Hole Contexts" - Conor McBride
12:14:26 <joejev> ski: how do they differ?
12:14:42 <ski> see "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> for a discussion of the difference
12:14:57 <ski> that paper is an update on parts of the also good "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
12:15:33 <hodapp> ah, yes, that's a decent paper
12:15:40 <ski> (if you want to learn about "weak vs. strong", "dynamic vs. static" typing, about four kinds of "polymorphism", and also other stuff, the latter is a good read)
12:15:50 <erisco> Twey, hm, it seems a bit ugly to work with... I think it will be better to define a new data type
12:17:23 <joejev> ski: going through this now, tyvm
12:18:04 <ski> joejev : a short summary of the (former) paper is that ADTs work by exposing a type *name*, but hiding its *representation*; while object-orientation works by hiding stuff inside *functions* (closures) (aka "methods", in the OO literature)
12:19:21 <ski> (so in OO (according to the paper), you don't expose a *type* name, while hiding its representation. however, many "OO" support this as well. the claim in the paper is that that's then an ADT feature, not an OO feature)
12:20:04 <joejev> ski: so like, he refers to integer as an ADT, but he was grouping pascal and other languages. Now I know that in java and Haskell, Integer is a boxed type, so is that what he means? How Integer is represented internally is irrelevent as long as we know how to act on it using exposed functions?
12:20:52 <ski> no, "boxed" is about the low-level representation
12:21:20 <Twey> erisco: I would agree, probably something using a Vec
12:21:25 <ski> in Haskell, `Int',`Integer',`Double',`IO' are ADTs, because it's not known how they're implemented (in the language)
12:21:42 <joejev> ski: not known, or not exposed?
12:21:52 <ski> (the fact that *GHC* defines them in a particular way doesn't matter. in the language standard they are abstract data types)
12:22:01 <joejev> ski: ahh, okay
12:22:04 <ski> joejev : same thing, for our purposes here
12:22:27 <Twey> erisco: data VTree n f a = VTree (Vec n (f (VTree n f a))) -- or so
12:22:39 <Twey> Err
12:22:40 <ski> (also `(->)' is an abstract type. not even GHC defines it)
12:22:46 <Twey> erisco: data VTree n f a = VTree a (Vec n (f (VTree n f a))) -- or so
12:22:53 <erisco> Twey, I suppose it is unlikely to need an empty constructor unless the branching factor is constant
12:23:03 <joejev> ski: so if the Haskell standard said, for example, Char will be represented in memory as an unsigned char from range 0 to 255 or something, then it would not be an ADT?
12:23:15 <ski> no
12:23:34 <ski> if `Char' was defined as
12:24:07 <ski>   data Char = C0 | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | ...
12:24:18 <ski> (up to whatever the maximum is)
12:24:36 <ski> then it wouldn't be an ADT (assuming that definition is exposed)
12:24:47 <Twey> Hm, Vec n isn't a Functor?
12:25:14 <joejev> ski: but if the constuctor wasn't exposed and we could only work with Chars through other functions, then it would be?
12:25:21 <erisco> Twey, what is the purpose of 'f'?
12:25:26 <mm_freak> Twey: if Vec is the length-indexed list type, then it is a functor
12:25:37 <ski> joejev : it isn't about how things are represented in memory, it's about the API used to access it, and whether it's defined by any of the type-defining constructs in the language
12:26:25 <Twey> erisco: It was me being stupid: I thought to parameterize out the functor used to represent the branching structure, but then I went ahead and used a concrete Vec n instead
12:26:32 <Twey> mm_freak: But it doesn't seem to be a Functor, in Vec
12:26:44 <mm_freak> Twey: i'm not familiar with the Vec library
12:26:53 <mm_freak> but Vec is a functor
12:26:55 <joejev> ski: so an Interface in Java is an ADT where a class is not?
12:27:00 <mm_freak> forall n. Vec n
12:27:00 <Twey> mm_freak: And edwardk said something about not making his vectors size-indexed in Linear because he wanted them to be Functors
12:27:15 <ski> joejev : then for all we care, it would be an ADT, yes (and this is basically what GHC does for `Int',`Integer',`Float',`Double',`IO' .. and yes, also `Char')
12:27:24 <Twey> But indeed, I'd expect some kind of instance like that, too
12:27:30 <erisco> Twey, ah, I see. That sounds like a good idea though. I am surprised I cannot find a module which does so already
12:27:34 <mm_freak> Twey: but they are functors
12:27:46 <mm_freak> edwardk certainly meant something else
12:27:51 <Twey> Maybe
12:28:07 <joejev> ski: okay, I think I get it now. I will go over this paper though to be sure.
12:29:01 <mm_freak> Twey: it's even an applicative functor
12:29:07 <mm_freak> a zipping one
12:29:30 <kristof> joejev: An interface in Java is like a Typeclass in Haskell. "This is a thingy-kind-of-thing that can do this, this, and this!"
12:29:33 <Twey> Right.  So I wonder what edwardk meant, and why there's no instance in Vec.
12:30:01 <joejev> kristof: I know, I was just trying to relate them to the article
12:30:20 <kristof> joejev: I wouldn't use the word "ADT" in Haskell unless you're talking about Algebraic Data Types (There are Things in the world, which can be composed of Thingy-Things, Thingy-Thongs, Thongalongs, . . .)
12:31:02 <kristof> joejev: What article? I'm curious now.
12:31:09 <Twey> Also, where's the ‘succ’ function in GHC.TypeLits?
12:31:12 <notdan> mm_freak: what's a zipping functor?
12:31:39 <mm_freak> notdan: a zipping list
12:31:43 <mm_freak> not a zipping functor
12:31:52 <joejev> kristof: http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
12:31:59 <mm_freak> notdan: a zipping Applicative instance for a list-like functor
12:33:42 <notdan> NOt sure I get this
12:34:02 <Twey> I always end up writing (n + 1) and then struggling with the fact that (+) isn't injective
12:34:16 <XniX23> is the monoid in category theory just something more abstract than monoid in group theory?
12:34:51 <djahandarie> XniX23, yes. Often called a 'monoid object' to disambiguate, but sometimes just called a 'monoid'.
12:35:13 <kristof> joejev: My initial reaction is "hogwash!" "Abstract Data Types" is a funny complicated word, and I think it obfuscates the simple idea in computer science that we can have different kinds of Thingy-Things (Types) and then interact with those Thingy-Things in different ways (Polymorphism)
12:35:32 <mm_freak> notdan: compare liftA2 as it acts for [] and for ZipList
12:35:44 <XniX23> djahandarie: which one do tutorials in haskell refer to?
12:36:02 <djahandarie> XniX23, the one in abstract algebra.
12:36:22 <mekeor> XniX23: afaik, monoids are the same in both category and group theory. – what different in your eyes?
12:36:35 <ski> joejev : if we could use a class (say `class Counter { private final int n; Counter(int n) { this.n = n; } int count(void) { return n; } Counter increment(void) { return new Counter(n + 1); } Counter reset(void) { return new Counter(0); } }') in Java without the ADT aspect
12:36:43 <ski> joejev : then it would be like saying `type CounterInterface = {count :: Int,increment :: Counter,reset :: Counter}' (imagining we had proper record types), and then `newCounter :: Int -> CounterInterface; newCounter n = {count = n,increment = newCounter (n + 1),reset = newCounter 0}'
12:37:15 <ski> `CounterInterface' corresponds to the implicit interface specified by the Java class `Counter'
12:37:33 <djahandarie> mekeor, they are not the same... a monoid in category theory can exist in any monoidal category, and is only the same as a monoid in abstract algebra inside Set (with the cartesian product as multiplication)
12:37:46 <guesting> What can cause a stack size overflow?
12:38:05 <ski> er, rather `type CounterInterface = {count :: Int,increment :: CounterInterface,reset :: CounterInterface}' (so we need equi-recursive types as well, not just ordinary iso-recursive types. O'Caml does this)
12:38:13 <erisco> Twey, perhaps something like this? http://lpaste.net/98604
12:38:17 <mekeor> djahandarie: hmm. okaay...
12:38:42 <kristof> guesting: recursion that is not of the tail-call kind
12:38:54 <ski> (iow, in the Haskellish version, there is no type `Counter', there is only the type `CounterInterface', and the function (constructor) `newCounter')
12:39:18 <kristof> ski: Does Haskell not have proper record types, in your opinion?
12:39:21 <joejev> ski: okay, so that could be done in haskell fairly easily, right?
12:39:30 <guesting> kristof: What about binary recursion?
12:39:51 <ski> guesting : also when building a too-deeply-nested computation by (essentially) nesting `case's
12:39:54 <JakeE> kristof: actully I think that is not an issue. pattern matching stack is the issue. there are some good examples of foldl and foldr both producing stack overflows for a summation
12:39:57 <kristof> guesting: Is not tail call recursive, I think
12:40:01 <ski> joejev : yes
12:40:09 <hakujin> using a free monad (I guess free applicative would work here too, although I'd lose some power), is there a way to track dependencies where the return value of a function is used as an argument to a subsequent function? e.g. do { r1 <- func "example"; r2 <- func $ toExample r1}?
12:40:25 <guesting> ski: What do you mean by too-deeply-nested computation?
12:40:26 <joejev> ski: So in haskell, is everything an ADT?
12:40:32 <ski> joejev : (interface) inheritance, or even (implementation) inheritance would be harder to mimic nicely in Haskell, though
12:40:43 <ski> joejev : no
12:40:45 <joejev> ski: what about typeclasses?
12:41:11 <kristof> JakeE: Is it the binding that results from matching patterns that causes the stack overflow?
12:41:32 <ski> type classes are more or less ADT, except when you use one, you may know the representation type (it's more like "translucent modules" in the SML)
12:41:52 <JakeE> kristof: I don't know the specifics but to say somthing to the effect of "only non tail recursive functions produce stack overflows" is not true of haskell
12:42:08 <JakeE> http://www.haskell.org/haskellwiki/Stack_overflow\
12:42:44 <ski> kristof : each time you have a `case blah of ...' (or a `foo blah', where `foo' is defined by pattern-matching), you have to set aside the `...' and compute (the head part of) `blah', *then* to resume with `...'
12:42:45 <JakeE> foldl (+) 0 [1..10000000] can cause a stack overflow even though foldl is tail recursive
12:42:54 <ski> kristof : it's this "set aside" that requires stack
12:43:55 <ski> kristof : "Does Haskell not have proper record types, in your opinion?" -- right. what we have is a (thin) syntax to simulate them
12:44:09 <guesting> ski: If I have a binary tree of height 18, it is fine when each node has it's height. What if instead it had a bunch of data in it, would it stack overflow?
12:44:12 <Twey> erisco: Your Pair/Triplet &c. generalizes to Vec n
12:44:18 <ski> guesting : binary recursion is probably not related
12:45:15 <JakeE> guesting: haskell in general wont stack overflow. I have only seldom had it happen to me. languages like ML, F#, C++, etc... are far more likely to overflow than haskell it seems
12:45:17 <erisco> Twey, indeed which is  newtype VecTree a = Tree Vector a (VecTree a)   yes?
12:45:22 <guesting> ski: I am running into a stack size overflow, and I don't know why. I thought it was the height of the tree, but that isn't it. I thought it was me "foldMap"ing over the tree to get the leaves, but that doesn't seem to be it. I don't have any other folds in the program at all though...
12:45:51 <erisco> Twey, however, Bool and Ordering are common, so for convenience of pattern matching, I think specialised versions can be justified
12:46:05 <ski> guesting : by "too-deeply-nested computation", i mean that if you write (explicitly, in the program source) `case xs0 of [] -> (); _:xs1 -> case [] -> (); _:xs2 -> case xs2 of ... -> case xs100000000000000 of [] -> (); _:_ -> ()', then you will probably also get a stack overflow
12:46:14 <Twey> erisco: newtype VecTree n a = Tree (Vec n) a s
12:46:26 <guesting> ski: But I have no cases...hmmm
12:46:32 <Twey> Er, s/ s//
12:46:37 <ski> guesting : of course, noone would write such things in the source, but similar things can implicitly get constructed (and not yet evaluated) at run-time
12:47:08 <erisco> Twey, what is the "Vec" type? I am guessing this is not Data.Vector
12:47:12 <guesting> ski: What if the binary recursion was in the form of a guard?
12:47:18 <ski> guesting : using `foldl' with "small" data types like `Int' is a common example of this
12:47:19 <Twey> erisco: I'm not totally convinced about the s parameter: you should be able to do without it, I think
12:47:20 <guesting> ski: That's like a case, right?
12:47:36 <Twey> erisco: No, http://hackage.haskell.org/package/Vec
12:47:39 <ski> guesting : tail-recursion or not is very different from binary-recursion or not
12:47:46 <ski> i think "binary recursion" is a red herring here
12:47:53 <erisco> Twey, well how would I do BiTree without the 's' parameter?
12:48:11 <erisco> I am not convinced that pulling out the (label, subForest) tuple is worth anything
12:48:38 <ski> guesting : yes, guards (roughly) correspond to `if' (and thus `case') on `Bool' values
12:49:12 <ski> also, pattern-matching like `f [] = ...; f (x:xs) = ..x..xs..' gets desugared to `case' as well
12:49:36 <Twey> erisco: type BiTree a = Tree (Maybe :. Vec n) a
12:49:49 <Twey> (if you switch the composition, you get incomplete trees)
12:49:52 <erisco> what is 'n'?
12:49:53 <guesting> ski: So...pattern matching would be the same as guarding?
12:50:01 <Twey> erisco: Sorry, that's supposed to be 2
12:50:09 <ski> guesting : no, rather both of them amounts to `case'
12:50:17 <erisco> Twey, does this depend on some extension?
12:50:19 <Twey> And type TriTree a = Tree (Maybe :. Vec 3) a, &c.
12:50:25 <Twey> Oh, lots
12:50:31 <Twey> :þ
12:50:32 <guesting> ski: I mean so they both are like case, so the deep computation would be effected...
12:50:36 <ski> guesting : however, there may also be pattern-matching (iow essentially `case') in functions you're calling
12:50:52 <Twey> You can do the same with your PairTree/TriTree/&c. as well, though, which shouldn't require any
12:50:56 <ski> guesting : anyway, to say anything specific, we'd have to take a look at the code in question
12:51:52 <Twey> erisco: You might be interested to know that we're converging on W-types (up to laziness)
12:51:52 <guesting> ski: Hold on, let me try to reproduce it
12:53:33 <erisco> Twey, but I want incomplete trees, so that definition for BiTree seems insufficient
12:54:00 <JakeE> why are you so dead set on using a rose tree for a binary tree?
12:54:15 <erisco> JakeE, I am not
12:54:40 <mekeor> is there anything special about my function f with the type "f :: Input -> Data -> Either ErrorString (Output,Data)"? – i mean, i know, this question is very vague but i'm supposing that this kind of type signature occurs quite often and maybe there is something which can be useful for me.
12:54:42 <JakeE> I must have missed somthing then; sorry
12:54:53 <Twey> erisco: Like I said, if you want incomplete trees you just switch the composition, so the functor becomes (Vec 2 :. Maybe) (for a binary tree)
12:55:21 <erisco> Twey, ah that is what you meant. Yes that would work
12:55:22 <mekeor> mekeor: ¯\(°_0)/¯ Dunno
12:55:38 <Twey> erisco: In general, Tree (Vec n :. Maybe) is an incomplete n-ary tree, and Tree (Maybe :. Vec n) is a complete one
12:55:53 <JakeE> mekeor: knowing what it is might help. It looks like you might want an error monad or somthing. the tuple at the end suggests a stat monad as well
12:56:12 <merijn> mekeor: Looks like a combination of EitherT and StateT?
12:56:29 <erisco> Twey, I worry that nesting too many types will become more cumbersome than it is worth, but I do not know if that is rational
12:56:30 * mekeor didn't ever use FoobarT
12:56:45 <JakeE> merijn: ya that is what I was thinking
12:57:02 <merijn> @unmtl Input -> StateT Data (Either ErrorString) Output
12:57:03 <lambdabot> Input -> StateT Data (Either ErrorString) Output
12:57:14 <merijn> @unmtl StateT Data (Either ErrorString) Output
12:57:14 <lambdabot> Data -> (Either ErrorString) (Output, Data)
12:57:36 <merijn> I guess, you could also see Input as a Reader :)
12:57:40 <JakeE> ErrorT ErrorString (State Data) Output
12:58:09 <merijn> @unmtl ReaderT Input (EitherT ErrorString (StateT Data) Output
12:58:09 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
12:58:14 <merijn> @unmtl ReaderT Input (EitherT ErrorString (StateT Data)) Output
12:58:15 <lambdabot> Input -> (EitherT ErrorString (StateT Data)) Output
12:58:24 <Twey> erisco: It doesn't have to be; you can always define nice accessors
12:58:38 <frankbro> Is there a way I could do what is written in the comment here? That is, assign the type of a data? https://www.refheap.com/24171
12:58:56 <erisco> Twey, I will work with the nesting approach and see what happens.
12:59:02 <mekeor> JakeE: it's the parser of a toy programming language. the "Data" is the list of defined functions and data types. the user can define new functions and data types. if the input is invalid, f returns an error message; if the user defined a new function or data type, this thing is added to Data; otherwise output.
12:59:10 <kristof> Here's a philosophical question for you are: is encapsulation actually important?
12:59:11 <mekeor> so it's actually even Maybe Output...
12:59:21 <JakeE> mekeor: you want Parsec I think
12:59:31 <mekeor> JakeE: no. it uses RPN
12:59:42 <mekeor> i wanna parse it myself
12:59:53 <geekosaur> frankbro: no, you can't match a constructor into a variable like that
13:00:22 <frankbro> geekosaur, ah :(
13:00:23 <mekeor> (i guess, you could use Parsec to implement RPN, too, right?)
13:00:30 <JakeE> mekeor: what is RPN? also if you take my advice and use the ErrorT StateT combo you are just making an abstraction that ends up being a worse version of Parsec
13:00:46 <mekeor> mmm
13:00:53 <mekeor> JakeE: why worse?
13:01:05 <mekeor> JakeE: RPN is reverse polish notation
13:01:28 <JakeE> it's lower level that that of parsec. also you can just write your postfix parser in Parsec; easy
13:02:08 <erisco> Twey, I annotated http://lpaste.net/98604 and am having a problem getting type check for the Maybe type. I am not sure how to compose the type constructors correctly
13:02:33 <JakeE> mekeor: if you wrapped another type called "Parser" around the ErrorT StateT combo it would effectivlly be Parsec but you would've gone to all that work just to do what is already there
13:03:01 <mekeor> JakeE: hmmm
13:04:53 <mekeor> JakeE: is it a problem that the toy-prog-lang is stack-based?
13:05:10 <JakeE> mekeor: why would it be?
13:05:25 <Twey> erisco: Oh, I think you might have to wrap it in a newtype to avoid infinite types
13:05:27 <mekeor> i don't know. i'm not sure how parsec can be used...
13:05:54 <merijn> mekeor: RWH has a decent chapter on using Parsec
13:06:04 <JakeE> mekeor: it can parse just about anything. it would take a very complex or dubious grammar for parsec not to be able to parse it
13:06:26 <merijn> mekeor: They cover Parsec 2 instead of 3 so some of the APIs changed (i.e. don't expect to directly copy their code), but it should explain how parsec works
13:06:27 <Twey> mekeor: Actually, the problem is the opposite: parsers for concatenative languages are so trivial that you won't see much of Parsec
13:06:48 <JakeE> also does your toy language have lambda functions in brackets or function definitions? if not I think what you are looking for is just split by spaces
13:06:56 <erisco> Twey, well it compiles (annotated) http://lpaste.net/98604
13:07:01 <mekeor> merijn: how abou the official parsec intro/docs/tutorial/howto (which afaik exists(?))?
13:07:13 <mekeor> Twey: :D
13:07:21 <merijn> mekeor: I don't remember, I think I mostly used RWH + hackage docs
13:08:03 <Twey> mekeor: Unless your language has quotations or other special forms, you can literally just use ‘words’
13:08:10 <JakeE> "2 3 + 4 *" can just be parsed by spliting it all by spaces. if you need function definitions like "foo { + 4 * }" or lambdas like "[2 3 + *]" then that is diffrent
13:08:18 <Twey> If you want strings you should probably use a one-line Parsec parser
13:08:39 <mekeor> Twey: the problem is in addition that isn't only parsed from left to right but instead you have to check some property first and then parse it from left to right.... this is all possible with parsec?
13:08:58 <mekeor> Twey: yeah, it doesn't have quotes
13:09:14 <Twey> mekeor: What property is that?  But yes, Parsec lets you keep state and do various other things
13:09:45 <Twey> erisco: Cool!
13:10:15 <mekeor> well. so "f" gets a String. it first checks whether this string contains none, one, or more commas. then it knows whether the user typed in a value, a function definition, or a data type definition.
13:10:15 <JakeE> mekeor: give us a contex free grammar. it will be very easy to tell you what tools would be best from there. I bet parsing this is just 'words' and mapping some kind of conversion function of those stings
13:10:25 <guesting> ski: Is there some option that can let me know where the stack size overflow happened? It might not even be my fault--it may be due to sparse-lin-alg in hackage
13:10:45 <mekeor> JakeE: yeah, it's mostly words. that's true
13:11:06 <mekeor> JakeE: but i can't give you a context-free grammar :P
13:11:29 * mekeor decided to go for parsec!
13:11:33 <JakeE> mekeor: why not? if you don't know how I reall highly recomend you learn to read and write grammars
13:11:37 <Twey> mekeor: Parsec can do that, but it doesn't sound like a great way to do it
13:12:19 <Twey> mekeor: Because you're relying on the termination of the user's input to differentiate between different forms, which is a loss of the concatenativity property
13:13:23 <mekeor> Twey: :O
13:13:44 <mekeor> Twey: what would you recommend then?
13:14:39 <mekeor> JakeE: i can actually read them, i think. (i guess, we are talking about BNF notation?) (i mean, mostly they are like "data" definitions, arent they? ;D)
13:15:05 <triliyn> Twey: wouldn't that be well-behaved if you gave "termination of user's inpt" its own token?
13:16:26 <mekeor> what does termination mean in this context actually?
13:16:31 * ski . o O ( "Magic with Types" by R. John M. Hughes in 2000-10-26 at <http://web.archive.org/web/20050128014256/http://www.cs.chalmers.se/Cs/Research/Functional/Meeting/2000/index.html#John-Oct-26>,"Polish Parsers, Step by Step" (functional pearl) by R. John M. Hughes,S. Doaitse Swierstra in 2003-08 at <http://www.staff.science.uu.nl/~swier101/Papers/2003/p224-swierstra.pdf> )
13:16:50 <Twey> triliyn: Somewhat (you ‘fix’ the problem by making the whole input one big token)
13:16:55 <ski> (apropos reverse polish notation)
13:17:32 <Twey> mekeor: Is this your language, or are you writing a parser for an existing language that you can't change?
13:17:40 <ski> (also stack-based, aka concatenative, is distinct from reverse polish)
13:17:57 <mekeor> ski: in fact, i'm not exactly using reverse polish notation, but what i call "reverse prefix notation". instead of "f x y z" (prefix) or "x y z f" (rpn), i write "z y x f"...
13:18:04 <mekeor> Twey: it's mine
13:18:04 <ski> (as i suppose JakeE was hinting at)
13:19:10 <ski> mekeor : but can you write `b a f' (with no word before the `b'), with an `f' like that one ?
13:19:22 <Twey> mekeor: Then I'd make the definition form obey the rules of the rest of the language: push some kind of value(s) representing the constructors for the type onto the stack, followed by a name, then have a word that makes a new type
13:19:50 <mekeor> ski: no, that'd give an error. what should it do?
13:19:54 <Twey> You keep track of what types are defined as part of the state in your interpreter
13:20:24 <JakeE> or seperate syntactic and semantic analysis like a normal person
13:20:35 <mekeor> ski: you can put a function without applying it with a preceding comma. that is you can write something like "[] 1 : 2 : 3 : ,sin map", e.g.
13:20:37 <Twey> Yes
13:20:45 * ski agrees with "but it doesn't sound like a great way to do it","termination of the user's input to differentiate between different forms, which is a loss of the concatenativity property"
13:22:06 <ski> (perhaps a good way of saying this is that "parsers ought to be (have the property of being) concatenative" ?)
13:22:26 <JakeE> mekeor: so the value of "[] 1 : 2 ,sin map" should be [sin 1, sin 2]?
13:22:27 <kristof> Someone explain universal and existential types to me in a way that takes advantage of the fact that I'm already quite familiar with universal and existential quantifiers in logic.
13:22:29 <Twey> All parsers?
13:22:35 <kristof> *pretty please :)
13:22:35 <JakeE> if so you are looking for quotation
13:22:37 <mekeor> JakeE: yeah
13:22:51 <ski> mekeor : in concatenative languages, you can do `3 dup *', this is not reverse polish notation (which is a syntax thing)
13:23:07 <guesting> Who was the person working on a good matrix library with sparse support and sparse svd support?
13:23:08 <JakeE> mekeor: in a stack based language like Cat or Joy this would look like "nil 1 cons 2 const [sin] map"
13:23:14 <mekeor> ski: that's also possible in this language
13:23:28 <mekeor> JakeE: yeah
13:23:35 <Twey> kristof: Just like in logic, a universal type is chosen by the caller and an existential type is chosen by callee
13:23:38 <Twey> by the**
13:23:48 <mekeor> hmm.
13:23:55 <JakeE> mekeor: why not use that syntax? quotation is needed if you are going to use a stack based language in a higher order fashion
13:24:02 <ski> (in my understanding) reverse polish notation is a way of systematically "inserting brackets"
13:24:27 <kristof> Twey: So it's where the logic goes that's the difference?
13:24:28 <mekeor> JakeE: yeah. actually you are right. i have been using this syntax because it was easy to implement.
13:24:46 <ski> so that `1 2 3 + *' becomes `(1 (2 3 +) *)' and `1 2 + 3 *' becomes `((1 2 +) 3 *)'
13:24:49 <Twey> kristof: I don't know what that means
13:24:50 <mekeor> but yeah, if i use parsec, i could make a much nicer syntax
13:24:59 <ski> (reverse lists at all levels to get a lispy representation)
13:25:06 <kristof> Twey: I didn't quite understand what caller and callee meant, even though you said "Just like in logic"
13:25:22 <ski> (or .. possibly move the last item (operator) to the front instead of reversing)
13:26:44 <merijn> kristof: It means that if a function has type "a -> a", that function claims to work for any 'a' that I (the caller) pick
13:26:46 <mekeor> (actually, you can find a version of this programming language on hub.darcs.net/mekeor/Garepinoh – but this version only handles values of one type. (you can define functions but not data types.) (in the next version, there will be no pre-defined value-type but you can only define your own types. and the destructor of this type will automatically be available.)
13:26:47 <Twey> kristof: Say you have a proposition ∀x. ∃y. p(x, y).  In order to prove this proposition, you have to show that it holds for *any* x someone could pass in there, whereas with the y you can just choose one yourself
13:26:47 <ski> kristof : to prove `forall x : A. P(x)', you must assuming someone will hand you an `x' value, about which you know nothing about (it's "arbitrary"), except that it's of the type/sort `A'
13:26:49 <mekeor> )
13:27:20 <ski> kristof : to *use* a `forall x : A. P(x)' in a proof, you must provide an element of type `A' to use in place of `x'
13:27:23 <merijn> kristof: Which is different from (not real haskell syntax) "exists a . a -> a" which says there is *an* value 'a' that I work with, but you don't get to pick
13:27:43 <c_wraith> merijn: an value?
13:27:45 * mekeor is wondering whether he wants to use reverse prefix notation then at all...
13:28:01 <ski> kristof : to prove `exists x : A. P(x)', you must (a) construct some value `x' of type `A'; and (b), prove `P(x)', but with this value in place of `x'
13:28:13 <merijn> c_wraith: English is dumb and I'm tired >.>
13:28:18 <Twey> kristof: Likewise, if you have a type ∀ x. ∃ y. P x y, your function has to work for any possible x that the caller (the code where the value is actually used) could decide on, whereas for the existential type you're free to pick any type you like yourself and just return that
13:28:23 <c_wraith> mekeor: ..  reverse prefix?  Is that different from postfix?
13:28:36 <mekeor> JakeE: i was also using the stack and the reverse prefix notation because it was easy to implement. i think i'm gonna use a complete new syntax
13:28:41 <mekeor> c_wraith: uhm...
13:28:43 <mekeor> :D
13:28:45 <mekeor> oh
13:28:58 <Twey> kristof: (pretending Haskell has ∃ notation for a moment; in practice it's implemented as a separate newtype with a ∀ in it)
13:28:59 <kristof> Twey: It's times like these where I get angry that my client doesn't support unicode
13:29:10 <Twey> kristof: Oh, you should fix that
13:29:15 <kristof> Twey: Windows command prompt
13:29:18 <mekeor> c_wraith: ¯\(°_0)/¯ Dunno
13:29:22 <mekeor> c_wraith: is it?
13:29:23 <Twey> kristof: Use PuTTy?
13:29:35 * JakeE agrees with kristof about unicode support
13:29:41 <kristof> Twey: Never bothered since I always had a beautiful, working Linux installation. Temporarily borked, it's on my to-do-list
13:29:45 <ski> kristof : to use an `exists x : A. P(x)' in a proof, you get to use a value (here named by `x') about which you know nothing except that it's of type `A' *and* that `P(x)' (for this value in place of `x') is true -- *and* you'll have to make sure that eventually your conclusion doesn't mention this `x'
13:29:54 <Twey> kristof: Say you have a proposition forall x. exists y. p(x, y).  In order to prove this proposition, you have to show that it holds for *any* x someone could pass in there, whereas with the y you can just choose one yourself
13:30:01 <Twey> kristof: Likewise, if you have a type forall x. exists y. P x y, your function has to work for any possible x that the caller (the code where the value is actually used) could decide on, whereas for the existential type you're free to pick any type you like yourself and just return that
13:30:17 <c_wraith> mekeor: postfix notation has the really nice property that it can be processed online..  You can set up an interpreter that will work with expression trees interactively, because you can always make the current expression the child of a new one after seeing what it results in
13:30:26 <Twey> kristof: (pretending Haskell has exists notation for a moment; in practice it's implemented as a separate newtype with a forall in it)
13:30:37 <XniX23> does monad just say how things should be computed or is there something more behind this?
13:30:41 <ski> mekeor : s/there is *an* value 'a'/there is *a* type 'a'/
13:30:42 <c_wraith> mekeor: this is the insight underlying HP's use of postfix notation in its scientific calculators
13:30:54 <kristof> Twey: One practical example and then I'll be satisfied
13:31:53 <erisco> Twey, why is a newtype needed for :.? I do not see the reasoning
13:31:56 <mekeor> ski: really talking to me?
13:32:19 <mekeor> c_wraith: did HP's calculators use postifx notation or RPN?
13:32:31 <merijn> mekeor: RPN *is* postfix
13:32:35 <mekeor> c_wraith: wait.
13:32:40 <mekeor> c_wraith: okay i see.
13:33:33 <erisco> "Adding fully fledged lambdas at the type level means adding higher-order unification, which is a huge can of worms." -- simonpj
13:33:40 <mekeor> c_wraith: the differece between RPN/postifx and reverse prefix notation is that "x y z f" (postifx) is "z y x f" (reverse prefix notation)
13:33:41 <erisco> not sure what that really means
13:34:49 <ski> mekeor : er, no
13:34:55 <mekeor> no?
13:34:55 <ski> merijn : s/there is *an* value 'a'/there is *a* type 'a'/
13:35:01 <mekeor> ah okay
13:35:50 <Twey> kristof: data P x y = P x y; newtype ExistsYSTPxy x = forall y. ExistsYSTPxy (P x y); foo :: forall x. ExistsYSTPxy x; foo = ExistsYSTPxy (P undefined someValueOfAnyTypeYouLike)
13:36:01 <ski> mekeor : i think HP calculators used concatenative (aka stack-based), not RPN / postfix
13:36:03 <FreeFull> mekeor: 3 4 / in RPN is the same as 3 / 4 infix
13:36:17 <FreeFull> Pretty sure
13:36:34 <FreeFull> RPN is postfix
13:36:49 <ski> yes (but Forth isn't RPN)
13:36:58 <Twey> kristof: The first argument to P *has* to be bottom, because you've said that you'll produce a value of type x for *any* type x the caller cares to name, and bottom is the only value that inhabits every type
13:37:01 <kristof> Twey: ExistsYSuchThatPxy is such a mouthful
13:37:06 <FreeFull> Actually, Hmm
13:37:17 <kristof> Ooooooooooooook.
13:37:34 <FreeFull> Actually, I might be wrong about the ordering
13:37:41 <Twey> kristof: The second argument to P is an existential type, though, which means that *you* choose it, not the calling code, so you can put literally anything in there you want
13:37:52 <FreeFull> Nope, I was right
13:37:57 <merijn> ski: Yeah, I meant value in the english sense, not the programming sense
13:38:06 <Twey> kristof: 3, 57.5, "hello Grandma"
13:38:21 <kristof> That makes sense now. :)
13:38:54 <kristof> Thank you, Twey.
13:38:58 <Twey> No problem
13:38:59 <mekeor> AFAIK: let f :: X -> Y -> F. "f x y" is prefix. "x f y" is infix. "x y f" is reverse polish notation or postfix. "y x f" is what i call reverse prefix notation.
13:39:10 <ski> kristof : an `[exists a. (IORef a,a -> IO ())]' is a list of pairs of io-references and "handler" functions, the `a' in each pair "agreeing", but possibly different `a's are using in different pairs. so you can only pass an `a' extracted via an `IORef a' to the "handler" of the same pair
13:39:39 <FreeFull> mekeor: I'd think it'd be reverse postfix
13:39:50 <Twey> erisco: What would the type of ‘subForest someTree’ be without the newtype?
13:39:53 <FreeFull> Since the function shouldn't be counted as an argument
13:40:12 <ski> FreeFull : wouldn't `f y x' be "reverse postfix" ? :)
13:40:22 <mekeor> :D
13:40:33 <FreeFull> ski: Not if you only apply the reverse to the arguments
13:40:47 <mekeor> FreeFull: reverse "f x y" == "y x f" -- that's why i call it like that
13:41:01 <mekeor> FreeFull: true
13:41:11 * ski was construing it as being applied to the whole of the program text (or at least to maximal bodies inside definitions or something like that)
13:41:20 <mekeor> it's matter of definiton/taste/whatever. -- irrelevant
13:41:32 * ski tastes the reverse
13:41:42 <mekeor> > reverse "taste"
13:41:43 <lambdabot>  "etsat"
13:41:53 <erisco> Twey, presuming :. is an alias, then (:.) Maybe Pair a == Maybe (Pair a), therefore the type would be Maybe (Pair (Tree (Maybe (Pair (Tree ... I see
13:43:19 <erisco> Twey, an absolute pain to work with at the value level though
13:43:52 <ski> @. google run reverse "taste"
13:43:53 <lambdabot> http://www.youtube.com/watch?v=WuedBOCtjCU
13:43:54 <lambdabot> Title: Sissel Tolaas on TASTE-ETSAT - YouTube
13:45:11 <mekeor> @. google run map succ "reverse"
13:45:15 <lambdabot> http://www.csidesigns.com/alfalaval/PDFs/SparesCD/PDF/Valves/700%20series%20771%20reverse.pdf
13:45:15 <lambdabot> Title: 24 882T Sfwfstf Bdujoh 38 - 58
13:45:24 <mekeor> coool
13:45:49 <mekeor> > map pred "Bdujoh"
13:45:50 <lambdabot>  "Acting"
13:45:53 <mekeor> WOW
13:45:54 <mekeor> haahha
13:46:02 <FreeFull> mekeor: Why are you including the f?
13:46:03 <Twey> erisco: Perhaps a little ☺
13:46:13 <erisco> Twey, what does that mean?
13:46:36 <mekeor> FreeFull: ¯\(°_0)/¯ Dunno :P
13:46:41 <Twey> erisco: Sorry?  I was just agreeing with you
13:46:49 <erisco> oh, okay
13:46:57 <Twey> I think it's worth it for the type-level flexibility, though
13:47:09 <cschneid> anybody aware of a hubot equivalent written in haskell?
13:47:17 <cschneid> (irc bot, easily customizable with plugins)
13:47:25 <joelteon> why haskell?
13:47:30 <erisco> Node 1 . (:.) . Just $ Pair (Node 2 $ (:.) Nothing) (Node 3 $ (:.) Nothing)
13:47:37 <erisco> this does not ring beauty :P
13:47:47 <cschneid> why not! mostly because it'd be a fun project to get better at writing haskell, as an irc bot for our company channel
13:48:48 <mekeor> there is lambdabot ε>
13:50:12 <FreeFull> mekeor: ?
13:50:21 <saml> > "mekeor"
13:50:22 <lambdabot>  "mekeor"
13:54:10 <nadirs> talking about lambdabot: is there a function in ghci that works like lambdabot's `@src`?
13:54:40 <Twey> erisco: Maybe call the constructor something other than (:.), like ‘O’.  Then you get Node 1 . O . Just $ Node 2 (O Nothing) `Pair` Node 3 (O Nothing)  ;)
13:54:54 <Twey> nadirs: No, you need GoA
13:55:09 <Twey> nadirs: It just consults a big database anyway, though
13:55:59 <nadirs> Twey: I should seriously read the wiki before asking questions (http://www.haskell.org/haskellwiki/Ghci). I'm sorry :)
13:57:29 <nadirs> Twey: I know there's Hoogle and others, but being able to check some function's source without switching context is useful. GoA is the way to go. Thanks!
13:57:41 <Twey> nadirs: Enjoy setting it up ;)
14:06:32 <merijn> nadirs: You realise lambdabot's @src is filled with lies, right?
14:07:31 <erisco> I am so confused on how to instance Show1
14:08:17 <merijn> erisco: In what way?
14:08:38 <erisco> merijn, I cannot get anything to type check or make sense :(
14:08:54 <merijn> erisco: Pastebin code + errors?
14:10:32 <nadirs> merijn: is it?
14:10:56 <geekosaur> they are implementations, but not necessarily the ones that are actually used
14:11:16 <geekosaur> also the @src database is very incomplete
14:11:35 <merijn> @src sortBy
14:11:35 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:11:40 <nadirs> geekosaur: well, sometimes being able to read some kind of source helps more than just the signature
14:11:48 <erisco> mkay http://lpaste.net/98609
14:11:58 <merijn> nadirs: sortBy in GHC is actually implemented differently than that, and there's more examples
14:12:08 <merijn> nadirs: The difference between @src and implementation varies
14:12:21 <erisco> that is my most reasonable attempt
14:12:54 <nadirs> merijn: out of curiosity, who wrote lambdabot's sources?
14:12:55 <ij> What can I do to fix this? http://sprunge.us/hWPW
14:13:16 <nadirs> merijn: the lambdabot's author(s)?
14:13:33 <geekosaur> lambdabot has had many maintainers
14:14:28 <merijn> nadirs: They're just a "database" (i.e. file) with keywords and implementations :)
14:14:43 <erisco> Show (f a) is required, so I understand why it is asking for Show (g a)
14:14:48 <nadirs> hackage's `sortBy` does match, though → http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#sortBy
14:14:53 <erisco> but I do not know how to fix it
14:15:06 <nadirs> so I guess `Hackage /= GHC`?
14:15:27 <erisco> do I actually need Show3?
14:16:20 <merijn> nadirs: Careful, that definition is commented out using CPP
14:16:30 <merijn> nadirs: That's the definition defined in the Haskell report
14:16:44 <nadirs> merijn: this is still me not reading the whole thing :P
14:17:11 <merijn> nadirs: There's an #ifdef right above it which only uses that implementation if USE_REPORT_PRELUDE is defined, which isn't defined by default
14:17:37 <nadirs> I should probably add an alert "Confirm message submit" to my XChat installation :/
14:17:51 <merijn> nadirs: :)
14:18:10 <merijn> nadirs: You see below it that it uses an optimised merge sort (plus a bunch of historical sort implementations)
14:19:19 <zett_zelett> http://lpaste.net/98610 This won’t compile: ms.hs:3:10:
14:19:20 <zett_zelett>     parse error (possibly incorrect indentation or mismatched brackets)
14:19:21 <zett_zelett> Why?
14:19:55 <nadirs> zett_zelett: line 3 hould probably be `x == 0`
14:20:00 <nadirs> instead of `x = 0`
14:20:05 <zett_zelett> Ah, yes. Other than that?
14:20:24 <zett_zelett> (This isn’t the error.)
14:21:03 <nadirs> zett_zelett: seems fine. What do you mean "it isn't the error"?
14:21:39 <zett_zelett> It says, that it’s incorrectly indented or patterns are mismatched.
14:21:44 <zett_zelett> Eh, brackets.
14:22:05 <zett_zelett> It still doesn’t compile after fixing the "==" thing.
14:22:08 <mauke> misindentation
14:22:16 <geekosaur> the |s need to be indented to at least just beyond the 'n' of 'notes' ion line 2
14:22:21 <mauke> | needs to be indented more than notes
14:22:32 <zett_zelett> Whoa.
14:22:34 <zett_zelett> Didn’t know this.
14:22:50 <mauke> should've newlined after 'where'
14:22:51 <nadirs> me neither. Learning something new every day :)
14:23:18 <mauke> if the first token after 'where' is not '{', it determines the base indentation for the following block
14:23:19 <nadirs> in that case I usually put where on the first line and then indent the rest
14:23:48 <mauke> the first token after 'where' is 'notes', so the whole block needs to be indented more
14:24:02 <zett_zelett> This is good to know.
14:24:09 <zett_zelett> Thanks!
14:25:08 <zett_zelett> This is only true for "where" used for local binding?
14:25:20 <geekosaur> hm? layout is pervasive
14:25:23 <erisco> merijn, any ideas?
14:25:27 <erisco> it is a rats nest of contexts =\
14:25:30 <geekosaur> in general, anything indented more is continuation
14:25:40 <aspidites> is there an idiomatic haskell testing framework? hunit seems shoehorned
14:25:49 <merijn> aspidites: QuickCheck?
14:25:59 <mauke> zett_zelett: 'where', 'of', 'let', 'do'
14:26:02 <geekosaur> indented less must therefore belong to something outer, but in your case there is nothing outer to the declaration of notes that could take it
14:26:09 <merijn> erisco: Not really, I'm not familiar with Show1
14:26:12 <aspidites> merijn: was thinking of that. looks pretty sexy. does it make sense to do TDD with quickcheck?
14:26:14 <aspidites> or  better question...
14:26:31 <merijn> aspidites: I dunno, but than I'm not a big believer in TDD anyway
14:26:49 <aspidites> whats the best way to design by contract (assuming i'm using the phrase properly). that is, i want to write a spec and from that create a program that implements it
14:27:06 <merijn> zett_zelett: All you ever wanted/needed to know about haskell indentation: https://en.wikibooks.org/wiki/Haskell/Indentation
14:27:20 <aspidites> i'm not a HUGE believer in TDD, but eventually felt natural in python
14:28:00 <aspidites> or even more generally -- what guidance is there on designing haskell programs? is there a book or article that covers the topic?
14:28:08 <merijn> aspidites: I tend to worry more about finding types for my code that will prevent me from introducing bugs in the first place (like using newtypes and explicit conversion to distinguish unescaped and escaped strings before outputting)
14:32:52 <Twey> erisco: You can just ‘deriving Show’
14:33:33 <erisco> Twey, and it does not derive something sufficient to show the maybe-pair tree
14:34:45 <erisco> I worked something out using Foldable
14:35:02 <aspidites> merijn: so how do you go from idea to code? from an OOP background its natural (enough) for me to think of my problem as a group of objects that interact with each other
14:35:43 <aspidites> functionally, i can't seem to translate that. i assume i should be thinking of my problem as a set of transformation of data, but don't have an intuition for what that looks like
14:37:59 <stephenmac7> Here: http://hackage.haskell.org/package/zip-archive-0.2/docs/Codec-Archive-Zip.html#g:1
14:38:04 <stephenmac7> What does OptDestination do?
14:40:23 <nadirs> stephenmac7: «OptDestination FilePath	Directory in which to extract» is this it?
14:40:31 <stephenmac7> nadirs: Yes
14:40:39 <stephenmac7> Is that only for extraction?
14:41:00 <aspidites> stephenmac7: http://hackage.haskell.org/package/zip-archive-0.2/src/src/Codec/Archive/
14:41:21 <eacameron> is cabal-dev still useful now that cabal 1.18 is out?
14:41:22 <aspidites> lines 144 and 248
14:41:31 <nadirs> stephenmac7: seems valid for both directions → «Options for addFilesToArchive and extractFilesFromArchive.»
14:41:47 <stephenmac7> nadirs: Hm. Then why isn't it working?
14:41:50 <badkins> I'm having trouble attempting to get strict evaluation. I have the following simple function which is blowing the stack:
14:41:52 <badkins> foo :: Integer -> Integer
14:41:52 <badkins> foo 0 = 1
14:41:52 <badkins> foo n = 1 + foo (n-1)
14:41:55 <badkins>  
14:42:06 <badkins> I've tried various things with seq and $1
14:42:48 <benjaminfjones> eacameron: the cabal-dev maintainers recommend to use the new cabal sandboxes
14:42:56 <mauke> strict evaluation won't help
14:43:02 <stephenmac7> nadirs: It's like addFilesToArchive ignores it
14:43:13 <badkins> mauke: I'm just looking for a traditional "tail call" situation
14:43:19 <nadirs> stephenmac7: wait, forgive me, I wasn't even thinking. http://hackage.haskell.org/package/zip-archive-0.2/docs/Codec-Archive-Zip.html#v:addFilesToArchive
14:43:26 <mauke> badkins: but this isn't a tail call
14:43:33 <eacameron> benjaminfjones: thanks
14:43:40 <badkins> I've also tried let to make it a tail call
14:43:48 <mauke> badkins: how?
14:43:50 <badkins> let m = n - 1 in 1 + foo
14:43:52 <badkins> bah
14:43:59 <badkins> let m = n - 1 in 1 + foo m
14:44:01 <mauke> badkins: ... do you know what a tail call is?
14:44:01 <nadirs> stephenmac7: only OptRecursive and OptVerbose seem valid in addFilesToArchive
14:44:04 <koala_man> that's still not a tail call. the final operation is "+"
14:44:12 <stephenmac7> nadirs: Yes, I've used them both
14:44:16 <Twey> erisco: Hm, how did you do it?
14:44:23 <mada> badkins: how about passing the count to the inner calls?
14:44:54 <erisco> Twey, I do not think Show1 does what I need in this case (its workings are half mystery to me though) so I used Foldable instead
14:45:09 <erisco> Twey, I convert to a list and use its show instance, which is reasonable for debug printing
14:45:13 <nadirs> stephenmac7: if you think about it, it makes sense. What would you specify a destination for? You're adding files, not extracting them to somewhere
14:45:18 <badkins> ah, so I just made it ... (+) 1 (foo m)
14:45:31 <erisco> Twey, and Foldable can be defined for (.:) presuming f and g are Foldable also
14:45:36 <erisco> sorry, for (:.)
14:45:42 <stephenmac7> nadirs: If I want to add "file.txt" to "somedir/file.txt"
14:46:04 <stephenmac7> I just checked, it seems the OptDestination option is only used in writeEntry which is only used for extraction
14:46:11 <nadirs> stephenmac7: "somedir/file.txt" is not an archive though?
14:46:22 <stephenmac7> nadirs: somedir/file.txt in the archive
14:46:48 <stephenmac7> So that it when extracted, it would end up in "somedir/file.txt" in the filesystem
14:46:52 <Twey> erisco: Hrm, that doesn't seem like the right answer
14:46:55 <erisco> Twey, here is the module as of now http://lpaste.net/98613 I am going to eat supper but will later try and write some generic tree algorithms
14:47:34 <erisco> Twey, well, I am open to other solutions. I was getting frustrated with the contexts
14:47:54 <nadirs> stephenmac7: got it, now. Honestly I don't know how to do that even with regular "zip" CLI program :P
14:48:08 <stephenmac7> Hm.
14:48:27 <stephenmac7> Thing is, I don't want to mess with the files in order to create a zip file in a specific format
14:48:54 <nadirs> stephenmac7: I would probably create a folder "somedir" with just the file "file.txt" in it and add it with OptRecursive
14:49:15 <stephenmac7> Seems I can create an entry with readEntry then change the path
14:49:45 <nadirs> stephenmac7: seems nice
14:50:13 <stephenmac7> I'm new to haskell, so do I have to fill in every field in order to create a new Entry?
14:50:13 <nadirs> stephenmac7: then, you can define a single function that does that 2-step action, maybe
14:50:37 <nadirs> stephenmac7: "field" you mean argument?
14:50:42 <stephenmac7> Yes
14:51:09 <stephenmac7> Every argument to the Entry function
14:51:33 <stephenmac7> Or is there a way to get a modified version an existing Entry?
14:54:18 <nadirs> stephenmac7: since the data Entry uses record syntax, I think you can use the field names (which are actually functions) to create a new Entry from an existing one with just that field changed
14:54:49 <stephenmac7> nadirs: But would I still have to state every field name?
14:55:32 <stephenmac7> So, if I had: data Test = {field1 :: String, field2 :: Int} then how would I create a function that modifies just field1?
14:56:31 <nadirs> stephenmac7: ah, I think you're right.
14:57:26 <c_wraith> no, you don't
14:57:53 <geekosaur> foo x v = x { field1 = v}
14:58:09 <badkins> mauke: ok got it, I converted to a proper tail call and compiling with -O2 did the trick no seq or $! needed
14:58:28 <stephenmac7> geekosaur: Really? Things made with record syntax become a function?
14:58:36 <stephenmac7> Or is it syntatic sugar?
14:58:40 <stephenmac7> syntactic
14:58:43 <c_wraith> it's a function
14:58:48 <geekosaur> that was a function
14:58:51 <c_wraith> but the symbol is also overloaded to do other things
14:58:54 <jrmithdobbs> stephenmac7: what else would it create? everything's a function
14:58:58 <geekosaur> sadly, record update syntax is not first class
14:59:04 <mauke> jrmithdobbs: nonsense
14:59:10 <c_wraith> jrmithdobbs: no.  strings are not functions
14:59:30 <stephenmac7> jrmithdobbs: But how can x be a function?
14:59:39 <geekosaur> x is not a function
14:59:48 <stephenmac7> You just said it was
14:59:59 <c_wraith> he said "foo" was a function
15:00:04 <geekosaur> recordvalue { field = newvalue } -- is a copy of recordvalue with field's value replaced by newvalue
15:00:04 <stephenmac7> Ah
15:00:17 <stephenmac7> Okay, that's what I wanted geekosaur
15:02:03 <jrmithdobbs> c_wraith: the reference to them is a param-less function, essentially, no?
15:02:15 <c_wraith> nope
15:02:25 <c_wraith> functions are functions.  everything else is not
15:02:47 <c_wraith> functions are things with a type that has -> as the top-level type constructoor
15:03:28 <mauke> jrmithdobbs: every function takes exactly one argument
15:04:25 <sipa> jrmithdobbs: "everything is a function" is a fable
15:04:27 <frx> jrmithdobbs see http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:04:29 <jrmithdobbs> so the difference between \_ -> [...] and [...] is ?
15:04:38 <sipa> "everything is a value, including functions" is true
15:04:48 <nadirs> :i (->)
15:04:51 <jrmithdobbs> sipa: oh!
15:04:56 <sipa> jrmithdobbs: both are expressions that evaluate to a value
15:04:59 <jrmithdobbs> sipa: that actually clarifies greatly
15:05:08 <sipa> jrmithdobbs: the first one is guaranteed at compile time to be a value of a function type
15:05:12 <sipa> the second one is not
15:05:43 <frx> the second one is guaranteed not to be of a function type
15:05:54 <sipa> frx: ... it can be anything
15:06:00 <jrmithdobbs> sipa: ok, I see why the distinction is important then. thanks as usual :)
15:06:05 <geekosaur> no, the second one might happen to produce a function
15:06:09 <sipa> "function" is basically a property of an expression, namely that its type is known to be of type (a -> b)
15:06:17 <frx> geekosaur how?
15:06:32 <sipa> while in many languages "function" is a syntax element to define a symbol
15:06:34 <lllllllllllll> how can i avoid the double submit thing (csrf security measure) in yesod?
15:06:37 <geekosaur> frx: consider that [...] is (map someFunc)
15:06:47 <sipa> frx: or "id"
15:06:51 <geekosaur> (or, in generral, partial application)
15:06:58 <shachaf> CSRF and avoiding double submits are two different issues.
15:07:02 <mm_freak> lllllllllllll: if you use yesod's builtin form functionality, then you get CSRF protection for free
15:07:26 <mm_freak> each form gets a hidden input element with a CSRF token
15:07:33 <jrmithdobbs> mm_freak: that's not 100% true
15:07:41 <jrmithdobbs> mm_freak: FormInput does not have that property.
15:07:48 <jrmithdobbs> or InputForm whichever it is
15:08:06 <mm_freak> ok, it used to be true, when i was using yesod =)
15:08:06 <boom583> if-else in Haskell is not just a regular function. 1. Then what the hell is it REALLY?  2. Why wasn't it implemented as a regular function - three parameters (the condition, the true stuff and the false stuff) one return value?
15:08:30 <boom583> s/one return value/and one return value
15:08:45 <zq> seems like the value restriction's only impact is with currying
15:08:47 <jrmithdobbs> mm_freak: ya, I only know from trying to expilictly get rid of the middleware on certain routes
15:08:47 <mm_freak> boom583: you can implement it as a regular function, but then you don't get the code layout features of if-then-else
15:08:56 <triliyn> boom583: I think it compiles to a case expression in Core
15:08:58 <lllllllllllll> mm_freak, https://github.com/c3d2/vms/blob/master/Handler/Stock.hs#L40 there i have to submit the form twice saying something about csrf in the formfailure msg
15:09:04 <jrmithdobbs> mm_freak: because csrf was not approriate eg
15:09:05 <Twey> erisco: How about: instance (Functor f, Show1 f, Show1 g) ⇒ Show1 (f :. g) where showsPrec1 n (O f) = ("O " ++) . showsPrec1 (n + 1) (fmap show1 f)
15:09:12 <triliyn> You could write a function yourself if you wanted one, but it's rarely something that you need a function for
15:09:20 <shachaf> @where yesod is a good place to ask Yesod questions.
15:09:20 <lambdabot> #yesod - http://yesodweb.com/
15:09:37 <boom583> Are you sure? If it's just like a function, then why the hell can we mix IO actions with if-else within main?
15:09:45 <boom583> we're not supposed to do that with functions
15:09:49 <lllllllllllll> shachaf, yeah sorry i know but nobody answered there so tried here
15:10:01 <mm_freak> boom583: why not?
15:10:08 <kakos> So, I'm toying around with zipper trees. Here's my little toy code: https://gist.github.com/lambdaknight/8465187  My question is with the "withins" function. Shouldn't "withins" do it's magic to all of the elements in the traversal? If so, why does my test function only apply the change to the first child and not the other one?
15:10:08 <mm_freak> you could do that with a function as well
15:10:10 <jrmithdobbs> boom583: i don't understand your statement
15:10:12 <triliyn> boogie: you can use functions as long as they return an IO action
15:10:17 <triliyn> er, boom583
15:10:21 <boom583> oh
15:10:39 <triliyn> And you can use if-then-else as long as the result type is IO something
15:10:59 <mrack> boom583: I wish if was a function. it could be passed to other functions. I would also find it a lot more readable in a single line, ie: (\x -> if (x > 10) x y)  vs  (\x -> if x > 10 then x else y)
15:11:11 <mm_freak> boom583: if-then-else acts like an if-function, except that it has layout rules, which can be handy
15:11:18 <ski> boom583 : I/O actions are values. `if' can work with any values. functions can return any values
15:11:31 <mm_freak> the only disadvantage of if-then-else is that you can't use currying easily
15:11:37 <triliyn> boom583: if' :: Bool -> a -> a -> a; if' True a b = a; if' False a b = b
15:11:48 <mrack> mm_freak: but it doesnt. you cant pass syntax to higher order functions
15:11:58 <ski> boom583 : btw "if-else in Haskell is not just a regular function" -- it could have been
15:12:02 <triliyn> (mrack too)
15:12:06 <boom583> ok, but if functions are evaluated lazily, why are the IO do blocks evaluated step-by-step within if-else?
15:12:23 <mm_freak> mrack: sure
15:12:26 <boom583> 1sec, let me grab an example
15:12:50 <Twey> boom583: They're not, they're also evaluated lazily.  But they're *executed* action-by-action by the runtime, because that's how the runtime handles IO actions.
15:12:51 <jrmithdobbs> boom583: because each statement requires the result of the previous because do syntax is cleverly hidden CPS using the monad typeclass
15:12:51 <LinearInterpol> This is an incredibly noobish question.. what exactly do monads "look" like?
15:12:52 <ski> boom583 : `if' is orthogonal to `do' -- `if' inside `do' works just like any other `if'
15:13:20 <platz> kakos: what is & and <&> ?
15:13:22 <mauke> LinearInterpol: class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
15:13:37 <ski> LinearInterpol : not very much, since they're not values (like numbers, strings, and lists are values)
15:13:56 <Twey> LinearInterpol: Kind of like this: http://en.wikipedia.org/wiki/File:Monad_mult.png ;)
15:13:58 <LinearInterpol> They're control constructs, right?
15:14:07 <boom583> Still dont' really get it
15:14:13 <boom583> Take this example: http://pastie.org/private/ay1jbff7hidakjl9bk022a
15:14:18 <boom583> It's recursive
15:14:24 <boom583> and if things are done lazily
15:14:29 <boom583> why does anything ever get executed?
15:14:30 <mauke> LinearInterpol: they're type constructors
15:14:40 <kakos> platz: Two operators defined in Control.Lens.Combinators.
15:14:47 <mauke> boom583: because the runtime executes the value of main
15:14:47 <Twey> LinearInterpol: A monad is a type constructor, not a value.  Types don't generally have visible representations.
15:14:53 <triliyn> boom583: things get executed because "main" is executed when you run a program
15:15:01 <kakos> (&) :: a -> (a -> b) -> b
15:15:02 <kakos> (<&>) :: Functor f => f a -> (a -> b) -> f b
15:15:05 <boom583> oh
15:15:09 <triliyn> And they get evaluated because execution forces evaluation
15:15:14 <ski> LinearInterpol : `Monad' is more or less a (particular) Abstract Data Type interface, just like "priority queue" -- both of these can have multiple implementations (which are types with accompanying operation implementations, satisfying laws specified by the interface)
15:15:20 <triliyn> (Otherwise how do you know what to execute?)
15:15:30 <LinearInterpol> Ah.. I'll be honest.. Iiii have no idea what that means.
15:15:34 * LinearInterpol goes back to lurking, sorry.
15:15:44 <Twey> LinearInterpol: Values of a monadic type *can* have reasonable representations; like all values, some do, some don't (Just 3 is fairly easy, but \x → x + 3 is a bit harder, and IO actions are opaque, so there's not much you can show of them)
15:15:49 <ski> LinearInterpol : a particular monad is a particular type implementing the `Monad' ADT interface (together with an implementation of the operations `return' and `(>>=)')
15:15:55 <boom583> interesting
15:15:56 <platz> kakos: ah thanks.. I'd seen & before, but not <&>
15:16:09 <jrmithdobbs> boom583: read the "demystifing do syntax" or w/e section of learnyouahaskell
15:16:10 <Twey> platz: It's from lens
15:16:22 <Twey> It's just flip fmap
15:16:29 <boom583> jrmithdobbs: w/e?
15:16:36 <geekosaur> "whatever"
15:16:38 <jrmithdobbs> boom583: "whatever"
15:16:40 <boom583> ok
15:17:28 <kakos> platz: It's apparently just a flipped fmap
15:17:39 <ski> LinearInterpol : however, unlike priority queues, we normally use different monads, expecting them to have different *auxilary* behaviour (apart from the standard `Monad' one) -- with priority queues, we expect the same behaviour (but possibly not the same complexity and performance)
15:17:45 <boom583> jrmithdobbs: ok there is one such section on the monad chapter
15:17:52 <boom583> ain't there yet
15:17:55 <boom583> but thanks, good to know
15:18:07 <slack1256> in "case (m s) of { (# new_s, r #) ->" (code from the strict ST monad)
15:18:12 <slack1256> what does the # stand for?
15:18:14 <ski> LinearInterpol : do you know what a priority queue is ?
15:18:29 <ski> slack1256 : `(# ... , ... #)' is unboxed pair
15:18:34 <LinearInterpol> ski: Yes.
15:18:48 <ski> LinearInterpol : do you know what an Abstract Data Type is ?
15:18:53 <LinearInterpol> No. :(
15:19:33 <ski> LinearInterpol : do you know about several differing implementations of priority queues (or queues, or stacks, or dequeues, or ...)
15:19:36 <ski> ?
15:19:47 <LinearInterpol> I don't know if I do or not.
15:19:48 <slack1256> oh, so That's the way the ST strict monads is stricter
15:19:51 <LinearInterpol> Let's assume no.
15:20:05 <geekosaur> so, a Monad is just a pair of operations and a set of rules those operations follow. what makes Monads confusing is that they're very abstract; you can't point to something and say it's a Monad in the same sense that you can point to something and say it's (say) an animal.
15:20:43 <geekosaur> that is, we kinda expect everything that is an animal to have certain characteristics. ts *does* apply to Monads, but the characteristics are not easy to pin down with examples
15:20:43 <LinearInterpol> geekosaur: You are slowly making sense. Continue. :)
15:21:23 <ski> LinearInterpol : an Abstract Data Type is specified by specifying a type *name* (not an implementation), and a couple of *operations* (like functions) that operate on potential values of this type (and possibly on values of other, already known types), and a couple of laws that restrict the possible behaviour of these operations (the laws are usually described in comments rather than in code)
15:21:29 <jrmithdobbs> boom583: basically this is the gist: do { x  <- something; _ <- something ; return x } = something >>= (\x -> something >>= return x)
15:21:41 <jrmithdobbs> err that first >>= should be >> but ya
15:21:47 <geekosaur> (although a lot of people try, and miss --- because they aren't thinking absrctlyenugh, because once you are thinking abstractly enough you stop being able to come up with comprehensible examples)
15:21:54 <boom583> ok
15:22:00 * geekosaur glares at keyboard
15:22:00 <platz> has anyone tried the haskell exercices on exercism.io ?
15:22:06 <boom583> thanks
15:22:15 <LinearInterpol> I'm gonna need to do a bit more reading.. thanks.
15:22:22 <triliyn> platz: I've started one of them but not finished
15:22:23 <geekosaur> @where you could have invented monads
15:22:23 <lambdabot> I'm right here, silly.
15:22:27 <geekosaur> meh
15:22:34 <geekosaur> @google you could have invented monads
15:22:35 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:22:35 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
15:22:47 <geekosaur> gives some idea of how flexible the "monad" concept is
15:23:07 <geekosaur> simple examples, the mindbending part is that they all happen to be characterizeable by the same concept
15:23:27 <ski> LinearInterpol : e.g. for an ADT "stack of `Expr's", we specify a name `ExprStack', and operations : `emptyStack :: ExprStack; isEmptyStack :: ExprStack -> Bool; push :: Expr -> ExprStack -> ExprStack; pop :: ExprStack -> ExprStack; top :: ExprStack -> Expr'
15:23:38 <LinearInterpol> ski: You lost me. Sorry.
15:23:40 <LinearInterpol> :(
15:23:46 <boom583> can you access this site? https://pastee.org
15:23:51 * LinearInterpol goes back to reading LYAH.
15:24:03 <boom583> appears to be down atm
15:24:13 <triliyn> boom583: looks down to me
15:24:15 <platz> I'm trying to figure out where to go next.  read lyah, lots of articles { incl all_about_monads (i think i get transformers now }.  Should I read RWH or just start writing code?
15:24:16 <boom583> ok
15:24:21 <boom583> been down for a few days
15:24:33 <Twey> platz: Just code stuff
15:24:34 <ski> LinearInterpol : anything that actually *implements* the type `ExprStack' and the mentioned operations is an implementation of the ADT "expression stack"
15:24:51 <Twey> platz: RWH has some project ideas if you're stuck for them
15:25:10 <LinearInterpol> ski: clarification. You are speaking to a rather dumb C programmer.
15:25:22 <ski> LinearInterpol : one implemenation is e.g. `type ExprStack = [Expr]; emptyStack = []; push expr exprs = expr : exprs; ...', iow an `ExprStack' is just a list of `Expr's here
15:25:28 <platz> Twey: sounds good, yeah too much books, not enough practice
15:25:38 * LinearInterpol runs away.
15:25:49 <stephenmac7> Anyone know of a function that copies a whole directory?
15:25:59 <kristof> Into a tree?
15:26:00 <joneshf-laptop> cp
15:26:30 <stephenmac7> joneshf-laptop: <interactive>:2:1: Not in scope: `cp'
15:26:49 <stephenmac7> kristof: No, to another directory
15:27:10 <stephenmac7> Like the gnu coreutils: cp -r
15:27:49 <joneshf-laptop> stephenmac7, I was being a smart butt, but you could do `:!cp` ;)
15:28:29 <Twey> erisco: http://lpaste.net/98613
15:28:43 <stephenmac7> joneshf-laptop: It needs to be platform-independent
15:28:48 <ski> LinearInterpol : in terms of C, the ADT is specified by a header file which specifies `struct expr_stack; static const struct expr_stack *empty_stack; bool is_empty_stack(struct expr_stack *es); struct expr_stack *push(struct expr *e,struct expr_stack *es); ...'
15:29:08 <ski> LinearInterpol : any implementation that conforms to this header file is an implementation of the ADT
15:29:09 <LinearInterpol> Oh my. o_o
15:29:21 <LinearInterpol> So.. can you give me a simpler example of an ADT?
15:29:30 <jrmithdobbs> LinearInterpol: Maybe
15:29:43 <LinearInterpol> I'm also coming from a bit of Rust.
15:29:57 <LinearInterpol> data Maybe a = Nothing | Some a
15:30:00 <LinearInterpol> right?
15:30:03 <notdan> ADT as in algebraic data types?
15:30:08 <jrmithdobbs> s/Some/Just/ but yes
15:30:09 <LinearInterpol> Abstract Data Type.
15:30:24 <joneshf-laptop> stephenmac7, http://hackage.haskell.org/package/shelly-1.4.1/docs/Shelly.html#v:cp_r
15:30:24 <stephenmac7> So, no recursive copy?
15:30:28 <ski> LinearInterpol : the important point being that the reader of the header file does *not* know how `struct expr_stack' is implemented, so *can't* peek inside any such values, *except* by using the public operations in the header file (or ones derived from those)
15:30:38 <joneshf-laptop> stephenmac7, maybe that?
15:30:39 <LinearInterpol> jrmithdobbs: hehe, kinda "derived" it from enum Some<T>{None, Some(T)} in rust.
15:30:48 <notdan> Well abstract data types requires some weird type mechanics in Haskell
15:31:08 <LinearInterpol> ski: But how is the implementation defined then?
15:31:13 <stephenmac7> joneshf-laptop: Let me check
15:31:14 <LinearInterpol> There has to be some underlying code.
15:31:22 <joneshf-laptop> stephenmac7, oh, i'm not sure if Shelly is platform independednt
15:31:29 <stephenmac7> It's not
15:32:20 <ski> LinearInterpol : `int' is an ADT, as is `size_t' and `clock_t'
15:33:11 <LinearInterpol> Alright.. so, we can't define our own ADTs then? Since they're already "integrated"?
15:33:23 <jrmithdobbs> LinearInterpol: huh? no
15:33:24 <ski> yes, there has to be some underlying implementation, but the user of the ADT isn't supposed to worry about it (or at least, they are not supposed to be able to mess with the internal representation, inspecting ior changing parts "behind the back" of the "official" ADT operations)
15:33:38 <jrmithdobbs> LinearInterpol: you define it like this: data Maybe a = Nothing | Just a
15:33:42 <stephenmac7> Who knew this would be so hard?
15:33:45 <LinearInterpol> Woah, seriously?
15:33:49 <jrmithdobbs> @src Maybe
15:33:50 <lambdabot> data Maybe a = Nothing | Just a
15:33:55 <jrmithdobbs> seriously.
15:34:05 <LinearInterpol> There's no sort of.. explicit "transformation" under the hood?
15:34:13 <ski> LinearInterpol : we can define our own, by not specifying the full definition of the `struct' in the header file (instead fully defining it only in the corresponding implementation C source file)
15:34:25 <LinearInterpol> You just blew my mind. o_o
15:34:29 <LinearInterpol> ..Tell me more, you have my attention.
15:34:41 <jrmithdobbs> LinearInterpol: why? rust has this capability too?
15:34:45 <LinearInterpol> Yeah.
15:35:02 <LinearInterpol> According to them, enumerations are Haskell's algebraic data types.
15:35:18 <defanor> i've finished reading "Learn You a Haskell for Great Good!", and i think i need to practice now. but i feel like it'll be hard to figure out where to use which features (and afraid that i'll just write everything with ugly functions and a few of standard types), so, where could i find some exercises with explicitly pointed ways to solve them in haskell or smth like that?
15:35:24 <ski> LinearInterpol : `data Maybe a = Nothing | Just a' is not an example of an ADT -- at least not if you make public the fact that it has the constructors `Nothing' and `Just' (as is done with the standard `Maybe' in Haskell, though you could define your own one, hiding the constructors of it)
15:35:30 <jrmithdobbs> LinearInterpol: what i'd expect to blow your mind vs rust is * -> * kinds and Functor/Applicative
15:35:42 <jrmithdobbs> LinearInterpol: because the latter don't seem feasible in rust without the former
15:35:47 <ski> LinearInterpol : "algebraic data type" is not the same as "abstract data type"
15:35:59 <LinearInterpol> I'm sorry, I'm new. :(
15:36:02 <LinearInterpol> Functional programming is new to me.
15:36:12 <kristof> Shouldn't be.
15:36:15 <kristof> Pretty simple concepts.
15:36:16 <ski> jrmithdobbs : hm, Rust doesn't have higher kinds ?
15:36:23 <LinearInterpol> kristof: :\
15:36:25 <kristof> LinearInterpol: What's the question, anyway
15:36:33 <jrmithdobbs> ski: not yet, they're talking about it i think
15:36:35 <LinearInterpol> Just asking noobish questions.
15:36:48 <LinearInterpol> Getting my handle on Haskell and abstract datatypes.
15:36:48 <ski> LinearInterpol : Abstract Data Types have been around for a long time, and are pretty common in imperative programming
15:36:49 <jrmithdobbs> ski: it's why there's no Enumerable (ruby)/Traversable (haskell)
15:37:05 <kristof> LinearInterpol: ADT = interface, that's really the only way to put it
15:37:15 <joneshf-laptop> defanor, i liked htcofp, most people recommend rwh
15:37:18 <ski> jrmithdobbs : i hope they add them, they can be really useful
15:37:22 <jrmithdobbs> ski: you can do a monad in rust but you have to specialize to a specific list =/
15:37:23 <notdan> LinearInterpol: no prob, the ADT abbreviation can be confusing
15:37:32 <jrmithdobbs> ski: for values of list that == vector
15:37:33 <jrmithdobbs> heh
15:37:39 <defanor> joneshf-laptop: will google it now, thanks
15:37:49 <LinearInterpol> So.. effectively Abstract Data Types are just.. header files? lol.
15:37:53 <kristof> Huh? Maybe is not an Abstract Data Type
15:38:10 <notdan> LinearInterpol: kinda yeah
15:38:13 <kristof> It is an Algebraic one
15:38:20 <joneshf-laptop> LinearInterpol, like ski said, Abstract Data Types aren't Algebraic Data types
15:38:34 <LinearInterpol> Awesome. Can you show me an example of defining your own Abstract Data Type?
15:38:35 <notdan> Right; that's the third time it has been pointed out
15:38:48 <jrmithdobbs> ski: higher kinds is the one thing it doesn't have that i'd like (other than death to {}, but i'll digress on that, ha)
15:39:01 <ski> LinearInterpol : i'd rather say that making a header file where the `struct' declaration(s) doesn't specify the actual implementation of the type is the way to make Abstract Data Types in C
15:39:27 <ski> jrmithdobbs : hm, higher-rank types ?
15:39:55 <monochrom> you should learn one of Modula-3, Ada, SML, Haskell to see what's abstract data types
15:40:01 <kristof> LinearInterpol: Algebraic Data Types = ThingyThing. We describe ThingyThings in terms of being a ThingyThang or a ThongyThong. In type systems without ADTs we can only define ThingyThings in terms of ThingyThangs, or ThingyThings in terms of ThongyThongs, not both at the same time.
15:40:13 <jrmithdobbs> ski: that'd be nice i guess, but just nice, at least a way to imply * -> * kinds if nothing more complicated seems like a major oversight considering the rest of the language
15:40:59 <ski> LinearInterpol : when LYAH said "enumerations are Haskell's algebraic data types.", note they were talking about *algebraic* data types, not *abstract* data types (completely different things, can't even be compared to each other)
15:41:12 <notdan> LinearInterpol: if you want to have an abstract data type in Haskell you make a module wich cointins a type, it's operations, but do not export the concrete implementation
15:41:27 <notdan> I think Data.Set can be seen as an abstract datatype
15:41:30 <LinearInterpol> notdan: Thank you.
15:41:39 <kristof> LinearInterpol: A Card can consist of a Heart-Card, a Spade-Card, a Club-Card, or a Diamond-Card. That would be an example of an algebraic datatype
15:41:40 <LinearInterpol> That's seriously what I was aiming for.
15:41:49 <jrmithdobbs> IO could be considered an abstract datatype
15:41:50 <ski> jrmithdobbs : imho, if you have parametric types, you ought to have higher-order parametric types, in any modern languag
15:41:53 <jrmithdobbs> but that's probably just confusing
15:41:57 <ski> yes, `IO' is abstract
15:42:07 <ski> as is `Int'
15:42:14 <ski> and `Data.Map.Map'
15:42:28 <joneshf-laptop> LinearInterpol, what problem are you attempting to solve at the moment?
15:42:32 <LinearInterpol> So effectively, an Abstract Data Type in C is just a structure with operations, only export the structure with the operations.
15:42:37 <rik_> well look who
15:42:39 <ski> (and what notdan said)
15:42:40 <joneshf-laptop> LinearInterpol, or just asking for knowledge's sake
15:42:41 <jrmithdobbs> Data.HashMap.* are abstract too
15:42:49 <LinearInterpol> joneshf-laptop: knowledge's sake.
15:42:55 <LinearInterpol> rik_: Hi rik.
15:42:56 <kristof> LinearInterpol: That's a good way of putting it.
15:43:21 <hpc> imo you can still export the constructors for a data type as long as that's not "the preferred way" of interacting with it
15:43:22 <ski> LinearInterpol : it's a structure with operations, where the implementation details of the structure isn't exported (that's the "abstractness" of it)
15:43:25 <LinearInterpol> Oh. Well shit. I've been writing those for a long time. :P
15:43:26 <kristof> LinearInterpol: The trick with Abstract Data Types is that you can't mix and match them, even if they're the same kind of ADT, because internally their structure might be different.
15:43:30 <hpc> so for instance, i would consider StateT an abstract type
15:43:40 <hpc> but the intention is the same
15:43:46 * hackagebot SHA 1.6.4 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.4 (AdamWick)
15:43:49 <kristof> Well, I guess what I meant was you can't always expect to ADTs to play nicely with each other.
15:43:57 <ski> hpc : something similar could be said in dynamically typed languages
15:44:18 <jrmithdobbs> ski: i kixnd of agree but am pretty impressed by the rest of what has been accomplished with rust that i think forgoing rankntypes is probably fine if they can at least handle the common * -> * case ... there's enough other fun features of the language to make up for it even if it causes some inconvenience i think
15:44:32 <LinearInterpol> Alright. Now algebraic data types.. I assume I can learn about these by bringing the concept over from Rust.
15:44:54 <kristof> LinearInterpol: Did you read my Card example?
15:44:55 <hpc> ski: yeah; in perl i occasionally use [$foo, $bar, $baz] or similar in place of a proper object
15:44:56 <jrmithdobbs> ski: for it's intended use you really just need "higher order enough to abstract lists" kinds
15:44:59 <notdan> if they are called algebraic datatypes they are probably the same thing
15:45:03 <LinearInterpol> kristof: Yeah.
15:45:09 <ski> LinearInterpol : the main *point* of abstract data types is to allow the implementor of it to improve the implementation of it (and perhaps also to add new operations), *without* having to worry that clients that were already using it will now break
15:45:15 <joneshf-laptop> jrmithdobbs, you know,i get rust mixed up with go, rust is the good one right?
15:45:22 <jrmithdobbs> joneshf-laptop: right
15:45:29 <hpc> and hashes/dict/maps are the building block of just about everything in dynamic typed languages
15:45:33 <jrmithdobbs> i was going to qualify that, but no, that's right in that context ;p
15:45:35 <LinearInterpol> enum Card { Heart-Card, Spade-Card, Club-Card };
15:45:36 <hpc> (almost to the point of being stringly typed)
15:46:10 <kristof> LinearInterpol: Enumerable types, I believe, also have an order associated with them, which is useful sometimes.
15:46:18 <LinearInterpol> Yeah.
15:46:23 <notdan> LinearInterpol: does Rust support polymorphic algebraic datatypes?
15:46:27 <jrmithdobbs> joneshf-laptop: go's the one that feels like it was designed by a sophmore in highschool that just discovered the reactor pattern, rust is the interesting fun high-but-low level impure functional language. ;p
15:46:33 <LinearInterpol> notdan: Not sure, I can ask.
15:46:37 <LinearInterpol> oh.
15:46:38 <LinearInterpol> yes.
15:46:40 <companion_cube> notdan: I think so, there is option<T>
15:46:40 <kristof> LinearInterpol: But in that case, you can have an Algebraic Data Type Card which also participates in an Enumerable Typeclass/Abstract-Data-Type! And then you're set!
15:46:43 <ski> LinearInterpol : as a simple example, changing the internal representation of a set from a list of elements to a tree of elements (which can have better insert and lookup times)
15:46:44 <LinearInterpol> Via that generic. :D
15:46:52 <hpc> jrmithdobbs: ooh, summarize scala!
15:46:56 <joneshf-laptop> jrmithdobbs, haha
15:46:59 <hpc> :P
15:47:09 <LinearInterpol> kristof: So effectively what I just defined was an Abstract Data Type as well?
15:47:10 <LinearInterpol> :o
15:47:16 <notdan> Well then you know algebraic datatypes probably
15:47:23 <LinearInterpol> Yeah.
15:47:29 <ski> LinearInterpol : if the implementation type is exposed, then there might be clients that depend on the particular implementation type that is currently in use, so then when that is changed, they will cease to work
15:47:38 <kristof> LinearInterpol: Enum defined an algebraic data type that was also an Enumerable-thing, where Enumerable-Thing was an Abstract Data Type
15:47:40 <LinearInterpol> Maybe in Rust: enum Maybe<T> { Nothing, Just(T) };
15:47:58 <kristof> LinearInterpol: You didn't DEFINE a an abstract data type because you didn't make... er
15:48:03 <jrmithdobbs> hpc: i would but when i heard about scala i stopped reading at jvm
15:48:06 <kristof> LinearInterpol: Abstract Data Types in Rust are Traits
15:48:16 <jrmithdobbs> hpc: actually, i guess that fullfills your request. you're welcome.
15:48:16 <LinearInterpol> Oooooooh.
15:48:17 <LinearInterpol> Right.
15:48:19 <LinearInterpol> Sorry.
15:48:33 <kristof> LinearInterpol: Right? There's an abstract operation defined but no concrete implementation.
15:48:41 <LinearInterpol> Yep!
15:48:47 <LinearInterpol> And you can define a trait for Card that does something.
15:48:52 <LinearInterpol> Making it an Abstract Data Type.
15:48:56 <LinearInterpol> As well as an Algebraic Data Type.
15:48:59 <kristof> Yeah
15:48:59 <LinearInterpol> Correct?
15:49:02 <notdan> I thought traits were more like typeclasses
15:49:02 <LinearInterpol> WOO! :D
15:49:05 <LinearInterpol> Hells yeah!
15:49:07 <notdan> eh but w/e
15:49:10 <jrmithdobbs> it's an abstract algebraic data type
15:49:12 <ski> notdan : i presume you mean "*parametric* (algebraic data) types" ? -- having them polymorphic would be quite another thing (afaiu, GHC Haskell doesn't have this, except maybe with `PolyKinds')
15:49:15 <kristof> notdan: Abstract Data Types are Typeclasses
15:49:24 <ski> kristof : no
15:49:34 <kristof> ski: Yes! "Here's a thing that supports doing this kind of thing."
15:49:56 <notdan> ski: yep, you are right, I ment parametric
15:50:02 <ski> type classes allows you to know the actual representation type (and also allows you in some cases to not depend on it, in case you're polymorphic enough)
15:50:18 <LinearInterpol> Example?
15:50:19 <ski> abstract data types does not allow you to know the representation type
15:50:26 <notdan> wait what. abstract data types are NOT typeclasses
15:50:36 <LinearInterpol> So.. what exactly is a typeclass?
15:50:44 <kristof> I hold little respect for encapsulation :P
15:50:44 * LinearInterpol is full of questions, sorry.
15:51:14 <ski> LinearInterpol : more or less like an abstract data type, except that you (possibly) get to know the representation of the type :)
15:51:18 <notdan> LinearInterpol: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
15:51:50 <jrmithdobbs> typeclasses can be used to define abstract datatypes but neither the typeclass nor anything being a member of said typeclass makes it an abstract data type
15:51:57 <kristof> ski: Preventing people to know the underlying representation type instead of just asking them politely to ignore it is too maternal for me
15:52:04 <ski> also, for any specific type class and any specific representation type, there can't be more than one way to make that the representation type fitting into an implementation of the type class
15:52:31 <ski> e.g., you can't have two different ways in which `String' fits into the `Ord' class
15:52:42 <XniX23> is it ok to thing of typeclass as some property of a type?
15:52:50 <XniX23> think*
15:52:52 <Twey> kristof: You just don't *know* the underlying representation, because it could be anything
15:53:02 <LinearInterpol> Alright, so.. effectively traits are typeclasses.
15:53:05 <ski> otoh, at least in languages that allow multiple implementations of an ADT to coexist in the same program, this *is* allowed
15:53:11 <notdan> XniX23: sometimes it can be very useful to think exactly in that way
15:53:13 <tac> XniX23: For single-parameter type classes, yeah, that works
15:53:13 <LinearInterpol> In Rust.
15:53:28 <tac> XniX23: If you have a multi-parameter typeclass, you think about them as those types having some relation to each other.
15:53:40 <kristof> Twey: In most implementations of ADT, you are restricted by the compiler and type system to do something that breaks encapsulation even if you and the computer both know the underlying representation.
15:54:02 <Twey> kristof: Saying ‘encapsulation is for wimps’ is okay for Python, because the single type Python supports has some useful operations on it; in Haskell, that's not usually the case
15:54:20 <Mathnerd314> are there GHC snapshots anymore? http://www.haskell.org/ghc/download links to http://darcs.haskell.org/ghcBuilder/uploads/ which has nothing since August
15:54:22 <Twey> s/usually //
15:54:41 <ski> kristof : for traditional cases of ADTs, the compiler knows the representation. if you use `forall' or `exists', though, then not even the compiler might know the representation (at *compile-time*)
15:54:57 <kristof> I just think it's an unnecessary restriction. You shouldn't. But you also shouldn't smoke. If you're going to break encapsulation, you're either going to have a very good reason... or you deserve what's coming.
15:55:34 <kristof> It's why public/private keywords in OO languages make me cringe. I treat them like namespace functions, not important-encapsulation-nonsense.
15:55:39 <XniX23> tac: whats some example of multi-param typeclass?
15:55:51 <kristof> XniX23: Writer
15:56:24 <Twey> kristof: It's not that you shouldn't, it's that you can't.  You have no idea what the underlying type looks like, so you couldn't do anything with it even if you had access to it.  public/private are quite different.
15:56:33 <ski> kristof : one could imagine some kind of unsafety/impurity contagion, so that if you (*explicitly*) break the encapsulation, then one can easily find the part(s) of the code that (potentially) did it (and assign blame there)
15:56:35 <tac> XniX23: amusingly, I don't know any off the top of my head
15:56:36 <joneshf-laptop> <ski> also, for any specific type class and any specific representation type, there can't be more than one way to make that the representation type fitting into an implementation of the type class // wait what?
15:56:59 <joneshf-laptop> ski, i must misunderstand what you mean, isnt that why we need Sum and Product for Monoid?
15:57:01 <notdan> With typeclasses you can do stuff like instance (Monoid a, Monoid b) => Monoid (a, b). Can you do the same with traits?
15:57:04 <ski> kristof : however, this doesn't apply to the `forall' and `exists' case, since in that case you simply don't know
15:57:39 <merijn> Mathnerd314: Some people in here were hosting private snapshots, but I forgot the URL
15:57:41 <notdan> I thought traits were just like interfaces in OO languages with default implementations for some values/fnctions
15:58:00 <kristof> Twey: It depends.
15:58:13 <ski> kristof : also, in some "ordinary" ADT cases (e.g. with separate compilation), the compilation of the user of the ADT doesn't know the representation (and not by static checking restriction), so there the user can't know the representation either
15:58:20 <kristof> ski: I can't think of any good reasons to break encapsulation, anyway.
15:58:42 <XniX23> tac: Writer is a typeclass? i thought it was a monad
15:58:45 <jrmithdobbs> kristof: there's always a good reason to at some point in a project
15:58:54 * geekosaur is gettimng a headache...
15:58:57 <kristof> XniX23: That was me, I misread
15:59:11 <XniX23> oh sorry, i misread too
15:59:17 <ski> joneshf-laptop : yes, `Sum Integer' is a type that is different from `Product Integer' -- you can't attach both those two implementation of the `Monoid' interface to the type `Integer' (which in this case happens to be an ADT on its own, though unrelated to the `Monoid' interface)
15:59:26 <tac> XniX23: Well, there's Writer which is the monad, but also MonadWriter, which is a class
15:59:27 <tac> http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Writer-Class.html
15:59:40 <tac> vs http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Writer-Strict.html#t:Writer
15:59:43 <notdan> also in case of traits there can be several implementations IIRC
16:00:17 <tac> XniX23: although a better example might be state, because MonadWriter involves another typeclass called Monoid
16:00:33 <tac> so http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-State-Class.html
16:00:34 <tac> vs http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-State-Lazy.html
16:01:09 <tac> So if s :: * is any type, then State s :: * -> * is a monad
16:01:23 <tac> and automatically, you have MonadState s (State s) holds
16:01:49 <tac> So MonadState is a relationship that holds between some type (kind *) and some type constructor (kind * -> *)
16:02:20 <ski> kristof : perhaps debugging machinery, or marshalling, could be reasons to break it
16:02:24 <ski> (perhaps not)
16:02:40 <joneshf-laptop> ski, I don't think that explanation helped, but it's whatever, I think i get whatyou're saying
16:02:41 <notdan> ok I'll get going, have fun everyone
16:03:05 <jle`> is it safe to say that categories, as expressed in Data.Category, simply represent morphisms?
16:03:07 <Mathnerd314> merijn: how recently?
16:03:12 <jle`> that follow certain laws?
16:03:18 <jle`> (composable, has indentity)
16:04:46 <ski> joneshf-laptop : iow, it's because we can only attach at most one instance for a type class for a given type, that we need to wrap with `Sum' or `Product'
16:05:05 <XniX23> i should take a look at monads a bit more, just started with them today, i dont understand them yet :P
16:05:07 <joneshf-laptop> ski, right :)
16:05:56 <Twey> jle`: Well, they represent categories :þ
16:06:09 <jle`> Twey: haha. okay, is that what categories are?
16:06:26 <jrm2k6> Hi, why are those giving different results http://lpaste.net/98617?
16:06:31 <Twey> jle`: Unfortunately the laws can't be expressed in Haskell, but you're meant to follow them anyway
16:07:36 <joneshf-laptop> jrm2k6, desugar the do syntax
16:07:53 <jle`> it feels like these Data.Category categories are just..."arrows"
16:07:55 <jrm2k6> joneshf-laptop: hm mkay
16:08:01 <merijn> Well, you can *express* the laws in haskell, you just can't get GHC to prove that they're actually followed :p
16:08:01 <jle`> but do categories have a concept of objects?
16:08:06 <jle`> that aren't 'arrows'?
16:08:22 <merijn> jle`: Yes, objects are what arrows are between
16:08:24 <ski> jle` : a category consists of a collection of "objects", and for each pair of objects `A' and `B', a collection of "morphisms". to specify that a morphism `f' belongs to the collection corresponding to `A' and `B', we write `f : A -> B'
16:08:40 <ski> also "arrow" is just a synonym for "morphism" ("map" is also sometimes used)
16:08:48 * hackagebot jespresso 1.0 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-1.0 (AndreyChudnov)
16:08:52 <jle`> but in Data.Category it looks like "f-like things" are the instances of Category
16:09:06 <jle`> ie the (->) a b instance
16:09:21 <Twey> jle`: The arrows are the interesting parts of a category
16:09:25 <jle`> so is  (->) the "category"?
16:09:31 <merijn> jle`: Yes, the objects in Category are the haskell types
16:09:33 <jle`> just like Maybe is "the monad"
16:09:35 <jle`> ?
16:09:38 <ski> furthermore, for any object `A', there has to be a morphism `id_A : A -> A', and for any three objects `A',`B',`C', and any two morphisms `f : A -> B' and `g : B -> C' there has to be a morphism `g . f : A -> C'
16:09:41 <jrm2k6> joneshf-laptop: how can i do that? any link to some doc?
16:10:02 <jle`> is (->) "a category" the same way that Maybe is "a monad"?
16:10:13 <jle`> or is that an unfortunate consequence of how the library is structured in Haskell
16:10:54 <jle`> or do you say "category of (->)"'s, more properly
16:10:58 <jle`> "category of kleisli arrows"
16:11:07 <jle`> becuase you wouldnt say "Monad of maybes"
16:11:22 <jle`> (or would you?)
16:11:27 <Mathnerd314> merijn: I found http://newartisans.com/2013/06/nightly-builds-of-ghc-head-for-ubuntu-12-04-2-lts/, but those are 2 months old
16:11:34 <jrmithdobbs> i thought it was "The maybe monad"
16:11:36 <ski> furthermore, these two operations (`id' and `.') has to satisfy three laws : for any two objects `A',`B' and any morphism `f : A -> B', `id_B . f' should be equal to `f', also `f' should be equal to `f . id_A', and for any four objects `A',`B',`C',`D', and any three morphisms `f : A -> B',`g : B -> C',`h : C -> D', `(h . g) . f' has to be equal to `h . (g . f)'
16:11:49 <ski> jle` : and that's the full definition of what a category is
16:12:11 <Cale> jle`: Usually categories are somewhat (though weakly) identified with their collections of objects, but it is really the arrows which do all the work.
16:12:45 <ski> `Data.Category' in Haskell can only describe categories where the collection of objects is `*', though
16:12:48 <Cale> (actually, that's somewhat of a lie, as the composition maps do quite a good bit as well!)
16:13:04 <Twey> jle`: The class in this case is applied to the type family of arrows in that category.  The objects of a Category are always members of Hask.
16:13:08 <Cale> Data.Category or Control.Category?
16:13:15 <jle`> sorry i meant Control.Category
16:13:20 <Twey> I don't understand why it's under Control
16:13:28 <Cale> Because Arrow is
16:13:31 <Twey> Ah
16:13:43 <Cale> But... I don't understand why *anything* is under Control
16:13:45 <Twey> I think the Data/Control segregation was a little short-sighted :þ
16:13:51 <Cale> It's silly
16:13:58 <ski> jle` : for `instance Category (->)', the collection of objects is `*', and the collection of morphisms from `a' to `b' is `a -> b'
16:14:06 <Cale> You could move everything in both of those upward a level and it would hurt nothing.
16:14:18 <Twey> Aye
16:14:20 <Cale> and safe a lot of typing while importing stuff
16:14:25 <Cale> save*
16:14:26 <jle`> maybe we can just make a ControlData
16:14:28 <jle`> :)
16:14:33 <ski> jle` : so the argument `cat' to `Category cat' describes the morphism collection (given the "from" and "to" objects as type arguments)
16:14:33 <jle`> and DataControl
16:14:35 <Twey> And mental load of trying to remember what's in Data and what's in Control.
16:14:45 <jle`> you should use your discretion on if your package belongs in ControlData or DataControl
16:14:53 <mmmm> jrm2k6: http://stackoverflow.com/questions/5818377/how-do-i-write-the-following-function-with-the-operator
16:15:00 <jrm2k6> thanks mmmm
16:15:21 <jle`> ski: okay, so cat in Category cat is simply the set of morphisms in that "Category"
16:15:33 <ski> more or less, yes
16:15:34 <Cale> The other "weird" thing about Control.Category is that the composition can't be just anything, since it has to be polymorphic, it will inevitably satisfy various "naturality" conditions.
16:15:35 <Twey> jle`: It's a type family, not a concrete set
16:15:41 <ski> and the collection of objects is fixed to `*'
16:15:51 <jle`> so instance Category Kleisli means that you have a category with Kleisli arrows as your morphisms
16:15:55 <ski> (though indeed `* -> *' would also make sense, and possibly be useful)
16:16:02 <jle`> i guess your morphisms characterize your category i guess
16:16:06 <mmmm> jrm2k6: So basically try writing your code without the do block with >>= and >> and you'll see what's up
16:16:15 <jle`> and in every Haskell category, the objects are of set Hask
16:16:17 <jrm2k6> ok, trying
16:16:34 <Twey> jle`: So you're allowed to know the objects when deciding the type of the morphism
16:16:35 <ski> jle` : well, they characterize your category, unless you can have polymorphic types (which, iiuc, Haskell doesn't have atm)
16:16:51 <Twey> ski: ‘Polymorphic types’?
16:17:52 <ski> Twey : like `Flip :: forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *', which would be the natural general kind for `Flip', given `newtype Flip f b a = MkFlip {unFlip :: f a b}'
16:18:05 <jle`> Twey: do you mean that a morphism isn't fully defined until you get both a and b in (->) a b?
16:18:32 <Twey> jle`: Not only is the morphism not defined, the *type* of the morphism isn't defined until a and b are known
16:18:59 <Twey> jle`: Int → Char and Bool → Float are different types and have different members (even though in this case they happen to look the same)
16:19:19 <tac> Twey: what about id :: a -> a ;)
16:19:44 <Cale> tac: polymorphic functions are actually many arrows at once :)
16:20:04 <ski> Twey : so that you can both use `Flip Either Int Bool' as well as `Flip ListT String IO', e.g.
16:20:10 <merijn> And infinite set of arrows, even!
16:20:14 <Cale> There's no object in the category for the type variable 'a'
16:20:15 * tac continues to stuggle learning about fibred categories
16:20:16 <merijn> s/And/An
16:20:23 <Twey> ski: We can't do this?
16:20:25 <jle`> Twey: ah i see
16:20:31 <Cale> So id defines a separate arrow for each object of the category
16:21:24 <ski> Twey : maybe with `PolyKinds' (which is probably a misnomer), i don't recall
16:21:37 <Cale> jle`: btw, have you seen Awodey's lectures on YouTube (really from OPLSS)
16:21:54 <ski> tac : note i said `id_A : A -> A' for a reason :)
16:21:54 <Cale> http://www.youtube.com/watch?v=ZKmodCApZwk
16:23:09 <Cale> He gives some really nice introductory lectures. The pace is pretty brisk for an intro, but I think he does a really good job.
16:24:15 <XniX23> is it possible for a monad to have more than 1 param wrapped?
16:24:39 <merijn> XniX23: Define "wrapped"
16:24:40 <Cale> XniX23: It's possible to have a family of monads which has additional type parameters apart from the last one.
16:24:47 <ski> can you clarify what you mean by "param wrapped" ?
16:24:48 <mmmm> Do you have a recommended introductory text Cale?
16:24:58 <Cale> mmmm: Awodey's text!
16:25:16 <Cale> mmmm: http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
16:25:17 <ski> mmmm : "Conceptual Mathematics" by Lawvere and Schanuel. it's very kindergarten-style
16:25:20 <merijn> mmmm: Most people recommend Awodey, but I found it to mathy (in that it explains things from a math background I don't have)
16:25:21 <Twey> ski: Interesting: I can *write* that type, but without PolyKinds set in my GHCi it turns k0 and k1 into *, and with PolyKinds it turns them all into k
16:25:36 <mmmm> Thanks ha, I asked my tutor once and he just said to use his notes from a course he once lectured
16:25:58 <Cale> Awodey's text tries quite hard to avoid having too many prerequisites
16:26:19 <Cale> But it does mention some of the examples from the rest of mathematics, because it would be a crime not to mention them
16:26:21 <Twey> This is a text about what, exactly?
16:26:32 <merijn> mmmm: I actually kinda like Pierce's Basic Category for Computer Scientists
16:26:32 <Twey> Category theory?
16:26:35 <Cale> and it develops the really important examples internally
16:26:36 <Cale> yes
16:26:49 <Cale> Twey: see my link there if you'd like :)
16:26:50 <XniX23> i look at monad as some context, in the Just example, you have only 1 param, the value.
16:26:59 <Twey> I went to a talk by Awodey on HoTT once and found it really easy to grasp; maybe I should read it
16:27:09 <merijn> mmmm: It seems very comparable in difficulty to Awodey, but I find the examples in Pierce easier
16:27:14 <Twey> Thanks!
16:27:26 <Cale> I didn't *really* understand the Yoneda lemma and the surrounding results until I read Awodey's explanation :)
16:27:32 <ski> Twey : yeah, of course you can write it, the point is that we don't want to default (or error out on) the kind of the unconstrained type variables, but instead generalize over their (unknown) kinds
16:27:54 <ski> just like in normal polymorphic values, where we generalize over unconstrained type variables
16:28:08 <Cale> Twey: The lectures of his on YouTube that I linked are also really good :)
16:30:08 <XniX23> ah nevermind, i think i get it, you'd probably just define at bind the way the func is called with multiple params
16:30:09 <Cale> XniX23: Saying that some type constructor M is a monad just means that there exist functions of the appropriate types:  return :: a -> M a  and  (>>=) :: M a -> (a -> M b) -> M b  which satisfy some conditions
16:30:16 <davidtan> hey guys, how do i update my cabal version. i used "cabal install cabal-install" and it said "Installed cabal-install-1.18.0.2" but cabal --version returns version 1.16.0.2
16:30:31 <Cale> XniX23: M itself might involve some additional type parameters, but really at that point, you're defining *many* monads at once.
16:30:51 <Cale> For example,  newtype State s a = S (s -> (s,a))
16:30:58 <Cale> instance Monad (State s) where ...
16:31:04 <Twey> davidtan: You've probably installed the new cabal-install under your home directory; make sure ~/.cabal/bin is in your path
16:31:06 <Cale> State s is a monad for each type s
16:31:19 <Cale> XniX23: Make sense?
16:31:24 <Twey> davidtan: (and before the global cabal)
16:31:48 <davidtan> Twey could you guide me how to do that? I see the cabal download page mentioning program search $PATH as well, but I'm kinda a noob here :)
16:33:07 <Cale> XniX23: It's possible to imagine defining other sorts of type classes which aren't Monad, but which capture operations of a similar flavour that operate on more parameters perhaps.
16:34:05 <XniX23> Cale: would it be possible to have something like this? State s a = S (s a -> (s,a))
16:34:07 <mekeor> davidtan: edit the file ~/.bash_profile (create it if it doesn't exist) and insert "export PATH="$PATH:/home/USERNAME/.cabal/bin" and then re-login
16:34:19 <Cale> XniX23: That would be a kind error
16:34:31 <XniX23> which would probably be S (s -> a -> (s,a))
16:34:47 <ski> that's ok
16:34:59 <Cale> That's a valid definition, but it won't define a Monad
16:35:13 <Cale> (there's no way to turn that into a Monad any more)
16:35:27 <Cale> Or even a Functor
16:35:54 <ReinH> Cale: I've been reading Awodey and watching his lectures on youtube. They're pretty great.
16:35:59 <XniX23> hmmm, i dont see why :\
16:36:11 <ReinH> Starting to figure out some of this abstract nonsense stuff
16:36:16 <Cale> Because if I give you both a function f :: a -> b and a function  g :: s -> a -> (s,a),  there's no way you can turn that into a function  s -> b -> (s, b)
16:36:37 <mmmm> Try defining return and >>= for the type you defined and make them satisfy the monad laws
16:36:44 <davidtan> thanks mekeor!
16:36:56 <ReinH> Can you even write fmap?
16:37:01 <Cale> and if there's to be any hope that the type will be a Monad, you're going to get liftM for free, which would do that for you
16:37:06 <Cale> :t liftM
16:37:06 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:37:16 <Cale> sigh
16:37:26 <Cale> liftM :: (Monad m) => (a -> b) -> (m a -> m b)
16:37:50 * Cale feels obligated to alpha convert the variables to something nicer ;)
16:38:08 <quchen> So did Lambdabot ;-)
16:38:37 <ReinH> Sometimes it's easier to build a monad from fmap, return and join. I wonder if you can even write fmap for this type.
16:38:38 <Cale> quchen: Yeah, those aren't the default inferred variables, they're the ones used in the definition in Control.Monad
16:38:44 <Cale> You can't.
16:38:51 <ReinH> Ok that's what I thought
16:38:55 <Cale> XniX23: *however*
16:39:20 <Cale> XniX23: If all you wanted was to talk about functions s -> a -> (s,a), well, that's the same as a function a -> s -> (s,a), surely
16:39:31 <Cale> and that means a -> (s -> (s,a))
16:39:32 <davidtan> hmm, it still says version 1.16.0.2
16:39:45 <quchen> I guess in Control.Monad the a* names make sense when there are a multitude of similar types.
16:39:55 <Cale> XniX23: which, once we wrap things up in the State s packaging, becomes  a -> State s a
16:39:59 <quchen> Anyway, well alpha-equivalated.
16:40:16 <Cale> quchen: yeah
16:40:46 <Cale> quchen: Once you put it next to liftM2 and liftM3 etc. those names make some kind of sense :)
16:41:29 <mekeor> is there something like Text.Parsec.Char.string but for parsing lists of strings, that is, of type :: ... => String -> ParsecT s u m [String] -- ?
16:41:30 <Cale> XniX23: That State s a being the original one, the one which was actually a monad
16:41:57 <Cale> mekeor: many . string ?
16:42:06 <mekeor> :O
16:42:19 <mekeor> oh
16:42:27 <Cale> mekeor: or perhaps you really wanted  mapM string ?
16:42:39 <Cale> (your type made it look like you didn't though)
16:44:01 <XniX23> i see i have a poor understanding of this... i'd just do: Just x y >>= func = func x y; and then: f x y = Just x y
16:44:13 <Cale> Just only takes one parameter
16:44:15 <Twey> davidtan: echo 'export PATH=~/.cabal/bin:$PATH' >> ~/.bash_profile
16:44:19 <Cale> :t Just
16:44:20 <lambdabot> a -> Maybe a
16:44:28 <Twey> davidtan: Assuming you're using GNU and bash
16:44:30 <Cale> :t Just "Hello"
16:44:31 <lambdabot> Maybe [Char]
16:44:40 <XniX23> i know, replace Just with something, my bad
16:44:45 <Twey> davidtan: Other operating systems or shells may be different; I'd need to know more about your system
16:44:58 <geekosaur> I would very strongly suggest not using ~ in a PATH setting. use $HOME
16:45:06 <Twey> mekeor: It needs to go before the rest of the path, not after it
16:45:10 <Cale> XniX23: With...
16:45:16 <tippenein> does ~/ even work in a PATH setting..?
16:45:18 <Cale> I'm confused :)
16:45:22 <geekosaur> the rules by which bash decides to expand ~ are somewhat baroque, and nothing else will expand them
16:45:23 <mekeor> Twey: why?
16:45:29 <Twey> geekosaur: It will be expanded by bash before it goes into the variable
16:45:38 <mekeor> geekosaur: that's why i wrote /home/USERNAME/..
16:45:51 <Twey> mekeor: Because he has a global /usr/bin/cabal that he wants to shadow
16:45:52 <XniX23> I don't know with what tbh, i'm just thinking out loud if its possible (and would make sense) to have 2 params instead of one
16:46:09 <mekeor> Twey: oh, i see, oops
16:46:10 <davidtan> i'm running OS X Mavericks 10.9.1
16:46:11 <geekosaur> Twey: at least in some versions, if it immediately follows the =. nowhere else can that be relied on, and even so not reliable with older bash versions
16:46:17 <Cale> XniX23: Well, we could do something like invent a whole new type class.
16:46:29 <Twey> geekosaur: o.@
16:46:32 <davidtan> i think i just messed lots of things up. i tried following what this guy did: https://stackoverflow.com/questions/18290416/path-for-installation-binaries-for-cabal
16:46:38 <geekosaur> really, I meant what I said
16:46:58 <davidtan> now my terminal can't even recognise commands like ls, cd
16:47:03 <Twey> geekosaur: Citation?
16:47:05 <geekosaur> the rules are strange and have changed (a few versions did expand it after a colon but most do not)
16:47:21 <mekeor> davidtan: oh. that's very bad
16:47:32 <Twey> Oh, never mind, I see what you're saying
16:47:33 <Cale> XniX23:  class MonadTwo m where returnTwo :: a -> b -> m a b; (>>==) :: M a b -> (a -> b -> M c d) -> M c d
16:47:35 <Twey> Yes, good point
16:47:53 <geekosaur> ...what? I'm afraid to ask what you'd accept as a citation. I am speaking of (a) observed behavior (b) REPORTED behavior, in this channel and elsewhere
16:48:13 <geekosaur> do I have to go read its git repo to you?
16:48:43 <Cale> geekosaur: You missed that he said he got it ;)
16:48:47 <Twey> davidtan: You probably overwrote your path; just set it back to its default value (probably something like: export PATH=/bin:/usr/bin)
16:49:19 <geekosaur> zsh is more reliable about expanding ~, btw, but I don't trust it there either. it's just easier to remember "don't use ~" than to remember all the special cases
16:49:38 <Cale> XniX23: Then we could have something like  newtype StateTwo s a b = S2 (s -> (s,a,b))
16:49:40 * mekeor nods
16:49:48 <Cale> instance MonadTwo (StateTwo s) where
16:49:48 <Twey> Agreed
16:49:58 <XniX23> Cale: oh, i see you're making someting less abstract in order to provide the change needed right?
16:50:08 <davidtan> i used to open the bash_profile from the terminal, but now the terminal don;t accept all the commands to open it up. and the files are hidden in Finder. is there another way to access it?
16:50:09 <Cale>   return v w = S2 (\s -> (s,v,w))
16:50:22 <geekosaur> (aaaand let's not even get started on bizarre bash bugs that pop up in minor releases)
16:50:24 <Cale> XniX23: Well, this is a new abstraction really.
16:50:34 <Twey> davidtan: export PATH=/bin:/usr/bin
16:50:34 <Cale> XniX23: There aren't a whole lot of libraries which fit into this shape
16:50:47 <Cale> XniX23: So it's unclear whether we really need a class like the one I'm defining
16:50:48 <Earnestly> geekosaur: POSIX defines tilde expansion and basically every shell does it except when $HOME is unset, that is undefined
16:50:49 <Twey> davidtan: Do that in your terminal and everything should be back to normal for that terminal.  Then you can edit your .bash_profile.
16:51:16 <Cale> XniX23: But if you want your computations to have additional *results* at least, this would make sense.
16:51:17 <geekosaur> Earnestly, POSIX defines it, many shells extend it (inconsistently)
16:51:22 <Twey> Earnestly: Yes, but the problem is that it will only do it when ~ is ‘on its own’.  bash doesn't consider it to be ‘on its own’ if it's, e.g., preceded by a colon.
16:51:30 <Cale> Just for completeness' sake:
16:51:36 <XniX23> Cale: or i could wrap them into something probably
16:51:45 <mmmm> If you want additional results, you would just use a record or tuple though
16:51:49 <Earnestly> geekosaur: ksh, bash, (solaris) sh, csh, zsh are all consistent
16:51:54 <geekosaur> POSIX doesn't promise where you can get away with using it. it certainly does not specify the bash behavior where an embedded ~ in $PATH works inside bash but nowhere else (!)
16:51:57 <Cale> runStateTwo (S f) s = f s
16:52:00 <Earnestly> Except whrn $HOME is unset
16:52:11 <Earnestly> geekosaur: What?
16:52:26 <geekosaur> if bash itself is processing $PATH, an embedded ~ will work
16:52:34 <geekosaur> (unexpanded ~)
16:52:47 <Earnestly> embedded how?
16:52:49 <Cale> x >>== f = S2 (\s -> let (s',v,w) = runStateTwo x s; (s'',v',w') = runStateTwo (f v w) s' in (s'',v',w'))
16:52:56 <Earnestly> Just PATH=~/foobar:~/baz ?
16:53:09 <Cale> So, that's a MonadTwo :)
16:53:19 <Cale> And we could do a similar thing and define MaybeTwo
16:53:19 <Twey> Are there any plans for integrating ixdo notation into GHC?
16:53:23 <geekosaur> the first of those would be expanded by most non-buggy bash versions; the second might or might not be
16:53:25 <mrack> is there a lens equivalent of lookup?
16:53:26 <Earnestly> geekosaur: bash certainly expands ~ in $PATH
16:53:33 <geekosaur> the second would even if not expanded still work *in bash*
16:53:34 <Cale> data MaybeTwo a b = NothingTwo | JustTwo a b
16:53:39 <Cale> and make that into a MonadTwo
16:53:40 <edwardk> > M.fromList [(1,2)]^.at 1
16:53:43 <quchen> Is this Bash talk Haskell-related? Just wondering, because there's actual Haskell going on between the lines.
16:53:43 <lambdabot>  Just 2
16:53:52 <edwardk> > M.fromList [(1,2)] & at 3 .~ Just 100
16:53:54 <Cale> instance MonadTwo MaybeTwo where
16:53:55 <lambdabot>  fromList [(1,2),(3,100)]
16:53:59 <geekosaur> and yes, we very regularly get people who used ~ after a colon in bash and it did not get expanded
16:54:05 <edwardk> mrack: ^- yes
16:54:05 <Earnestly> geekosaur: Sorry, but I've never seen this but then I've only ever used bash 3+ so maybe it is a very old bug?
16:54:07 <Cale>   returnTwo v w = JustTwo v w
16:54:09 <Earnestly> fwiw: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_01
16:54:11 <geekosaur> maybe they changed that again recently but it has most certainly NOT been standard behavior
16:54:18 <Cale>   NothingTwo >>= f = NothingTwo
16:54:23 <geekosaur> no, I am not talking about ancient bash
16:54:27 <Cale>   JustTwo v w >>= f = f v w
16:54:35 <Cale> oops, I mean >>==
16:54:38 <geekosaur> I am talking about people using recent ubuntu and arch
16:54:55 <Twey> Earnestly: Try: echo foo:~
16:54:55 <Cale> XniX23: So yeah, you can do that, but it's not something which comes up all the time like Monad does.
16:54:58 <Earnestly> geekosaur: They're most likely just quoting it or doing something weird.  Bash by default wordsplits on the IFS which zsh, thankfully, doesn't.
16:55:03 <Earnestly> Twey: That's not valid
16:55:21 <geekosaur> um, what makes you think : is in the default IFS
16:55:26 <Earnestly> geekosaur: It isn't
16:55:37 <geekosaur> then why does IFS apply to whether ~ expands after a colon?
16:55:41 <Earnestly> It doesn't
16:55:53 <geekosaur> then why did you bring it up as a response?
16:55:56 <Earnestly> foo:~ won't expand
16:56:02 <geekosaur> yes. exactly
16:56:05 <davidtan> Thanks Twey. Terminal is back to normal. but echo 'export PATH=~/.cabal/bin:$PATH' >> ~/.bash_profile didn't solve the problem. cabal --version still says 1.16
16:56:12 <Earnestly> foo:~bar will
16:56:17 <Earnestly> If (bar has a home)
16:56:24 <XniX23> Cale: which the double == ?
16:56:25 <Cale> XniX23: Such things really *are* abstractly monads (from a category theory perspective), but they're not monads on the category of Haskell types, but a closely related category
16:56:33 <Twey> davidtan: After doing that you need to ‘source ~/.bash_profile’ to load the changes into your current shell
16:56:40 <geekosaur> that sounds like bizarre special casing to me
16:56:42 <Earnestly> geekosaur: "A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>."
16:56:43 <mrack> edwardk: I cant seem to find it. what is it called?
16:56:49 <edwardk> "at"
16:56:51 <edwardk> > M.fromList [(1,2)]^.at 1
16:56:53 <lambdabot>  Just 2
16:56:55 <geekosaur> I really do not want to know wtf the bash developers think they are doing in that case
16:57:00 <mrack> neat
16:57:00 <Earnestly> geekosaur: So, yeah, it's just PEBCAK
16:57:13 <Earnestly> Bash is POSIX compliant wrt expansion of ~
16:57:14 <geekosaur> right, but : does not start a word
16:57:19 <Twey> davidtan: And as geekosaur says, it's probably safest to replace ‘~’ with ‘${HOME}’ in your .bash_profile, just in case ☺
16:57:20 <Cale> XniX23: I named my new variant of (>>=) as (>>==) just to hint at the fact that it's passing two results along to the function
16:57:21 <joneshf-laptop> edwardk, do you have the word "lens" on notify or something? :)
16:57:37 <Cale> XniX23: It's just another name :)
16:57:42 <edwardk> joneshf-laptop: my notifications rotate =)
16:58:06 <Cale> XniX23: We could also have called it bind2 or something
16:58:06 <Earnestly> Twey: (Not much point in using braces there, but you should quote the expansion. `"$HOME"/foo`
16:58:25 <XniX23> Cale: ah i missed the second = before
16:58:52 * hackagebot bzlib-conduit 0.2.1.1 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.2.1.1 (HideyukiTanaka)
16:58:54 * hackagebot language-bash 0.5.0 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.5.0 (KyleRaftogianis)
16:59:22 <XniX23> thank you for your help, with this in mind i'm ready for some monadic nightmares
16:59:36 <Cale> hehe
16:59:50 <davidtan> hmm, like this? export PATH='$HOME/.cabal/bin':$PATH
16:59:54 <Earnestly> davidtan: No
17:00:05 <Earnestly> davidtan: 'this is literal quoting'
17:00:28 <Earnestly> davidtan: PATH="$HOME"/.cabal/bin:"$PATH"
17:00:37 <mekeor> export PATH="$HOME/.cabal/bin:$PATH"
17:00:51 <Earnestly> You don't need to quote the whole thing :/
17:01:00 <mekeor> but you can
17:01:04 <jrmithdobbs> davidtan: PATH="$HOME"'/.cabal/bin:'"$PATH"; export PATH; is the semantically quoted version
17:01:15 <Earnestly> mekeor: In this case, yeah, but be careful with that assumption
17:01:18 <geekosaur> but why bother
17:01:36 <Cale> XniX23: There's not really a whole lot to the idea of what a monad is, but the sort of library which would define one would have to be very much in the spirit of functional programming, so most people coming to Haskell for the first time don't have a lot of examples in their head of what we're trying to abstract.
17:01:36 <Earnestly> Sigh, bash is not near as hard as haskell guys, seriously.  I suck at haskell though
17:01:50 <mekeor> :D
17:01:56 <mekeor> we all do
17:02:05 <Earnestly> Well, I'm worse then :p
17:02:09 <jrmithdobbs> Earnestly: disagree, writing performant bash is just as hard as performant haskell and actually requires similar thinking
17:02:25 <Earnestly> jrmithdobbs: hah
17:02:44 <Earnestly> jrmithdobbs: So tell me about them literal quotes in the path?
17:02:52 <davidtan> hmm, ok it doesn't work still. echo $PATH gave me this:
17:02:58 * Cale kind of hates the word "performant"
17:02:59 <davidtan> "/Users/davidtan/.cabal/bin:/Users/davidtan/.cabal/bin:$HOME/.cabal/bin:/bin:/usr/bin"
17:03:01 <jrmithdobbs> Earnestly: there are no quotes in the path
17:03:09 <davidtan> is that what i should be expecting?
17:03:19 <Earnestly> davidtan: Because you're constantly appending $PATH…
17:03:37 <Earnestly> jrmithdobbs: "jrmithdobbs davidtan: PATH="$HOME"'/.cabal/bin:'"$PATH""
17:03:50 <jrmithdobbs> Earnestly: there are quotes inside of that word (token) which disambiguate the quoting behavior requested of the interpretter
17:04:02 <jrmithdobbs> that is all one word though
17:04:10 <Earnestly> You don't need to quote '/.cabal/bin'
17:04:33 <XniX23> Cale: yeah, in imperative programming, you don't really do this type of abstraction much i guess
17:04:50 <jrmithdobbs> Earnestly: you don't need any of the quoting in that case unless PATH already contains a space, actually
17:04:54 <Cale> XniX23: One of the operations we're abstracting over has a function parameter! :)
17:04:57 <jrmithdobbs> Earnestly: at all
17:05:13 <SamanthaD> In Bash one should quote EVERYTHING
17:05:13 <jrmithdobbs> Earnestly: export PATH=$HOME/.cabal/bin:$PATH
17:05:19 <Cale> XniX23: and the other one is polymorphic in the type of its result, in a way which can't be determined by the argument!
17:05:21 <SamanthaD> unless you can't quote it, of course
17:05:22 <mrack> how about a lens equivalent of Prelude.lookup?
17:05:44 <Earnestly> jrmithdobbs: Or a tab, or newline, but when expanding anything in *bash* which does wordsplitting on IFC by default where you don't know what value it might expand to, you quote it.
17:05:55 <edwardk> that one we don't do, because it doesn't have a proper 'insert' to go with it
17:06:01 <hpc> i wonder if lens has the necessary framework to implement (=~) so it isn't horrifying to use
17:06:05 <XniX23> Cale: exactly. dafaq.
17:06:28 <Cale> jrmithdobbs: Just before I got into Haskell, I wrote an entire IRC bot as what effectively amounted to a single long shell pipeline with netcat at one end, and a FIFO tying the knot.
17:06:29 <jrmithdobbs> Earnestly: no
17:06:33 <jrmithdobbs> Earnestly: you *can* quote it
17:06:34 <mrack> edwardk: ah right.
17:06:34 <davidtan> ok i cleaned up $PATH and echo $PATH now gives "/Users/davidtan/.cabal/bin:/bin:/usr/bin"
17:06:47 <davidtan> cabal --version still gives the old version...
17:07:07 <Cale> jrmithdobbs: So, I was fairly well-prepared to deal with lazy evaluation :)
17:07:08 <Earnestly> davidtan: type cabal
17:07:09 <jrmithdobbs> Cale: ya i have a bash (one builtin away from POSIX sh) CGI impl
17:07:20 <Twey> Earnestly: I think bash is much harder than Haskell :þ
17:07:21 <edwardk> mrack: you can make one, if you're willing to accept the not quite proper lens nature of it
17:07:38 <Earnestly> Twey: It's not
17:07:56 <Twey> Haskell's pretty easy.  bash is much less consistent and has many more special cases.
17:07:57 <jrmithdobbs> Cale: i've written change control software with revision tracking and multitenant simultaneous editing in bash ;p
17:08:02 <mrack> edwardk: would it not be a proper lens if we wrote insert for association lists?
17:08:07 <geekosaur> oh, you're on OS X and everyone has misled you
17:08:08 <jrmithdobbs> Cale: bash doesn't get the respect it deserves.
17:08:09 <Twey> Also no type system, which always doubles the difficulty level :þ
17:08:13 <geekosaur> $HOME/Library/Haskell/bin
17:08:16 <Earnestly> Twey: Bash has a few special cases, but nearly as much.  It's just extremely limited
17:08:23 <Cale> jrmithdobbs: If you use any of bash's loop operations though, it's cheating ;)
17:08:26 <geekosaur> not $HOME/.cabal/bin
17:08:28 <edwardk> well, the ssue is the insert may change the list as it s going to put the entry wherever it wants
17:08:33 <Earnestly> Twey: And doing simple stuff like matrices is… convoluted
17:08:44 <edwardk> probably at the front, even if it was the 20th entry in the list.
17:08:45 <Twey> Matrices… in bash?  Eek.
17:08:52 <edwardk> assoc lists aren't necessarily sorted lists
17:08:55 <jrmithdobbs> Cale: no, <() is cheating, that one addition gets rid of the utility of 90% of my stupid bash tricks
17:08:58 <jrmithdobbs> ha
17:09:03 <Cale> lol, BashLAS
17:09:19 <Twey> Ha
17:09:24 <geekosaur> davidtan: $HOME/Library/Haskell/bin not $HOME/.cabal/bin --- the people here know linux, don't generally realize the Platform on OS X uses a different path
17:09:31 <Twey> jrmithdobbs: What does that do?
17:09:35 <mrack> edwardk: I mean if we wrote ascInsert, not use Prelude.insert
17:09:48 <Earnestly> davidtan: (Please say which OS you're using in future in any technical discussion, it does help :S)
17:09:52 <edwardk> :t Prelude.lookup
17:09:53 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
17:09:57 <jrmithdobbs> Twey: it's a postfix redirection operator that lets you cheat and avoid the fact that while/for create subshells
17:09:57 <geekosaur> they mentioned Mavericks early on
17:10:04 <edwardk> well, lookup isn't in ascending order too
17:10:07 <jrmithdobbs> Twey: without resorting to named pipes
17:10:12 <Twey> jrmithdobbs: But what does it redirect from?
17:10:16 <edwardk> but if you fixed both of them, sure, then you just have a much slower map
17:10:23 <jrmithdobbs> Twey: the statement between the ()
17:10:30 <Twey> Ohh
17:10:31 <Earnestly> Twey: https://github.com/geirha/templates/blob/master/matrix
17:10:36 <davidtan> yes Earnestly. I will do that in future. Thanks everyone for helping
17:10:39 <jrmithdobbs> Twey: cat <(cat ~/.bashrc)
17:10:46 <Twey> Right, got it.
17:11:00 <Earnestly> Twey: <() creates a filedescripter with the contents of the commands stdout
17:11:01 <Cale> jrmithdobbs: One trick that I rather like is taking a list of files output from something, manipulating it with sed or awk or whatever into a script and then piping it to bash
17:11:06 <edwardk> mrack: what is driving you to use alists?
17:11:15 <Twey> Earnestly: That's not a matrix
17:11:22 <mrack> yeah. but more convenient occasionally
17:11:45 <edwardk> mrack: you can write a traversal that edits the key bu can't insert something missing very easily at least
17:11:49 <Earnestly> Twey: http://wiki.bash-hackers.org/syntax/expansion/proc_subst explains <() fwiw
17:11:54 <jrmithdobbs> Cale: my favorite trick/observation re: bash is that | == haskell's . in most contexts if you squint right
17:11:55 <davidtan> i'm trying to install a library called gloss: http://hackage.haskell.org/package/gloss-1.2.0.1/docs/Graphics-Gloss-Geometry-Line.html
17:11:56 <Cale> jrmithdobbs: that's probably more useful interactively (to be able to check that you're going to do the right things), but it also helps you avoid using loops :)
17:11:57 <edwardk> er edits the value at a key
17:12:15 <davidtan> I get this output "12 warnings and 1 error generated.
17:12:16 <davidtan> Failed to install binary-0.7.1.0
17:12:17 <davidtan> cabal: Error: some packages failed to install:
17:12:18 <davidtan> binary-0.7.1.0 failed during the building phase. The exception was:
17:12:20 <davidtan> ExitFailure 1
17:12:21 <davidtan> bmp-1.2.5.2 depends on binary-0.7.1.0 which failed to install.
17:12:22 <davidtan> gloss-1.8.1.1 depends on binary-0.7.1.0 which failed to install.
17:12:23 <davidtan> "
17:12:29 <mrack> edwardk: I have a tree of values (asc list, with value being another asc list). speed is not important, and it is nicer without spamming M.fromList all over the place
17:12:43 <geekosaur> davidtan: did you apply the Xcode 5 fix? (see the end of the /topic)
17:13:13 <geekosaur> the next Platform release (and the next ghc release, eventually) will include it but for now it needs to be done manually
17:13:18 <Earnestly> Twey: It reads a file which contains a rectangular set of text "a b\nc d, etc.
17:13:32 <FreeFull> Is there a backend to diagrams that displays something on screen rather than outputting a file?
17:13:52 <hpc> FreeFull: http://hackage.haskell.org/package/diagrams-gtk
17:13:58 <mrack> edwardk: btw what did you mean by this? "lookup isn't in ascending order"
17:13:58 <edwardk> > [(1,2),(3,4),(5,6)] & traverse.itraversed.Lens.index 3 +~ 200
17:14:00 <lambdabot>  [(1,2),(3,204),(5,6)]
17:14:05 <edwardk> > [(1,2),(3,4),(5,6)] ^? traverse.itraversed.Lens.index 3
17:14:07 <lambdabot>  Just 4
17:14:17 <hpc> FreeFull: won't create the window for you, but can put the diagram inside it
17:14:24 <edwardk> @let mrack i = traverse.itraversed.Lens.index i
17:14:26 <lambdabot>  Defined.
17:14:29 <jrmithdobbs> Cale: I've done that a few times but rarely keep the intermediary step past initial debugging, I'm ok with using while in bash so long as it's leftmost on the pipeline
17:14:33 <davidtan> geekosaur i think i saw that before. not sure if i did. let me run through it again
17:14:33 <Earnestly> Twey: But yes, not exactly.  There are other examples of highly "tuned" bash for various thing.  But anything more complex and you wonder why you don't just use a more suited language
17:14:37 <FreeFull> hpc: Too gooey
17:14:42 <edwardk> > [(1,2),(3,4)] ^? mrack 3
17:14:45 <lambdabot>  Just 4
17:14:46 <edwardk> > [(1,2),(3,4)] ^? mrack 5
17:14:50 <lambdabot>  Nothing
17:14:54 <jrmithdobbs> Cale: the moment the loop introduces a subshell and makes you think is the moment it loses it's utility imho
17:14:58 <hpc> gooey?
17:15:10 <FreeFull> GUI-oriented
17:15:16 <edwardk> there you go
17:15:26 <jrmithdobbs> Cale: also, no TEC optimization in bash so there's a real reason to use them ;p
17:15:32 <edwardk> that'll give you a traversal of the entries in an alist that match a given key
17:15:33 <FreeFull> If I wanted to embed diagrams into some GTK program, It'd be great
17:15:45 <edwardk> and is a law abiding traversal
17:15:49 <hpc> FreeFull: you mean you just want something like imagemagick's "view" stuff, where it just goes "whelp here's an image, plop it into X"
17:15:55 <FreeFull> Yeah
17:16:01 <hpc> doesn't appear to exist
17:16:09 <edwardk> you can't insert with it, but you can modify existing values
17:16:11 <erisco> is foldMap not inefficient if you are using list monad to mappend the result?
17:16:12 <mrack> [(1, [(2, "foo")])] ^? mrack 1 ^? mrack 2
17:16:16 <lingxiao> hey all, is there a way to represent unit or "()" in pure STLC
17:16:28 <hpc> FreeFull: silly thought: output to image and then system call imagemagick
17:16:31 <lingxiao> by that I mean the value unit, not the type unit
17:16:39 <mrack> > [(1, [(2, "foo")])] ^? mrack 1 ^? mrack 2
17:16:41 <lambdabot>  Nothing
17:16:42 <hpc> possibly using a tmpfile package
17:16:43 <Cale> lingxiao: What kind of representation are you looking for?
17:16:52 <FreeFull> > [(1, [(2, "foo")])] ^? mrack 1
17:16:55 <lambdabot>  Just [(2,"foo")]
17:16:58 <Cale> lingxiao: Usually there's a unit type which gets stuck in as primitive
17:17:01 <FreeFull> > [(1, [(2, "foo")])] ^? mrack 1 . mrack 2
17:17:02 <lambdabot>  Just "foo"
17:17:08 <mrack> ah right
17:17:17 <mrack> brainfart :)
17:17:17 <Cale> lingxiao: But if you want something like a Church encoding, that's just the identity function
17:17:21 <lingxiao> Cale: yeah I was wondering if you can represent unit using just functions ..
17:17:31 <lingxiao> right church encoding
17:17:35 <mrack> thanks edwardk, FreeFull
17:17:36 <lingxiao> but why is it the identity function?
17:17:46 <FreeFull> > [(1, [(2, "foo")])] ^? mrack 1 . mrack 0
17:17:48 <lambdabot>  Nothing
17:17:57 <FreeFull> Hmm, I wonder how it gets the index there
17:18:10 <erisco> are you expected to override foldl, foldr, etc to give more efficient versions for Foldable?
17:18:11 <Cale> lingxiao: If you have any algebraic datatype, then the Church encoding of a value of that type is obtained by writing a lambda which has the constructors as parameters
17:18:33 <Cale> lingxiao: For example, consider the binary tree type:  data Tree a = Tip | Branch a (Tree a) (Tree a)
17:18:50 <Cale> and the value   Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)  say
17:19:10 <Cale> That could be encoded as (\tip branch -> branch 1 (branch 2 tip tip) (branch 3 tip tip))
17:19:34 <erisco> ah nevermind it is  [1] ++ ([2] ++ ([3] ++ ...))) which is linear
17:19:34 <Cale> So, if we have  data Unit = Unit
17:19:46 <Cale> then the encoding of the value Unit is just
17:19:49 <Cale> (\unit -> unit)
17:20:25 <Cale> lingxiao: Make sense? :)
17:20:57 <lingxiao> yes it does :)
17:21:22 <lingxiao> thanks for breaking it down the general case of church encoding as well!
17:21:42 <lingxiao> now there's not church encoding for types right?
17:21:55 <lingxiao> so even if I assign unit := (\x ->x)
17:22:00 <Cale> Well, depends what you mean...
17:22:08 <Cale> It's going to do *something* at the type level
17:22:15 <lingxiao> I still would have to stick in BaseType = Unit | ...
17:22:29 <lingxiao> hmm.. what do you something? and what's it
17:22:53 <Cale> Well, yes, okay, in STLC, you're still hosed if you have no base types
17:23:16 <Cale> in pure STLC with no base types, there are no well-typed terms
17:23:31 <Cale> You have to put something in to get anywhere :)
17:23:48 <lingxiao> but what if you have Type = Atom | Type -> Type, where Atom is abstract, and doesn't map to anything at all
17:23:54 <lingxiao> is that possible? or are you still hosed?
17:23:57 <Cale> In System F though, you could start giving these things polymorphic types
17:24:09 <davidtan> the cabal install problem still persist even after adding the clang-xcode5-wrapper and editing ghc settings
17:24:28 <lingxiao> polymorphic, as in a variable that ranges over all types?
17:24:39 <Cale> yeah
17:25:13 <Cale>  /\a. (\(x:a) -> x) : forall a. a -> a
17:25:42 <Cale> (In Haskell, the type lambda /\ is implicit and hidden from view)
17:26:21 <lingxiao> real quickly on a tangent if I may, does it make sense to think of haskell, or any typed lambda calc as two languages/
17:26:32 <Cale> Which two? :)
17:26:37 <lingxiao> the language of terms and lang of types?
17:26:48 <lingxiao> so types is the meta lang over the object lang of terms? or no..
17:26:50 <Cale> Most languages have a fairly clear split between those two
17:27:08 <Cale> Though note here that in System F we have types which appear in terms
17:27:11 <lingxiao> I guess there's the lang of kinds too in haskell
17:27:25 <Cale> (\(x:a) -> x)  -- the a here is a variable which denotes a type
17:27:44 <lingxiao> what do you mean types that appear in terms? oh you mean like it's literally in there, typographically..
17:27:46 <jrmithdobbs> kinds are part of the types really
17:27:51 <Cale> and in dependently typed languages, you can have terms which appear in types
17:27:58 <Cale> yes
17:28:01 <jrmithdobbs> they're a meta-observation of the types, if you will
17:28:38 <Cale> http://en.wikipedia.org/wiki/Lambda_cube
17:28:44 <lingxiao> so what if you seperate them typogrphically? is it still possible for types to refer to terms in any way?
17:28:45 <Cale> You might enjoy that :)
17:29:04 <lingxiao> hah! I'm working on a project called AroundTheCube
17:29:05 <Cale> lingxiao: Terms which depend on types gives us polymorphism
17:29:14 <lingxiao> so one day I'll get to system Fw
17:29:30 <Cale> Types which depend on types gives us type operators (like Maybe for instance)
17:30:02 <randomclown> @pl \x -> (b . f $ x) + (a . f $ x)
17:30:03 <lambdabot> ap ((+) . b . f) (a . f)
17:30:21 <Cale> and types which depend on terms gives us dependent types (which can be used to do very powerful computation at the type level and ensure very fine properties of our programs)
17:31:10 <lingxiao> type operator as in function over types?
17:31:19 <Cale> yeah
17:31:29 <Cale> Functions from types to types
17:32:00 <Cale> lingxiao: So while in the STLC, the terms and types are very separate, there are a lot of advantages to be had from blurring the lines between the two
17:32:20 <Cale> (and a lot of implementation nightmares :)
17:32:58 <lingxiao> hah! can't wait to find out about those
17:33:10 <jrmithdobbs> system f is definitely interesting, is there much realworld utility to be had from studying it though? eg, it's not like there's an optimized compiler and i'm not going to have some great insight and unleash my System F Widgets on the world
17:33:21 <lingxiao> so if you keep on building this tower of languages, each depending on each other.. do you get something far far more expressive?
17:33:41 <Cale> In Haskell we have both polymorphic functions (terms depending on types), and we have type constructors (types depending on types)
17:33:42 <lingxiao> assuming the programmer's mental capacity is unlimited
17:34:27 <mrack> is there a nice high level UI library for haskell that works on both linux and windows or should I stick to gtk?
17:34:30 <lingxiao> jrmithdobbs: I would think if someone's studying system F, the fact that it involves programming is kind of an afterhtought ... the "math" of it is the most interesting?
17:34:37 <lingxiao> just my 2cents
17:35:27 <Twey> jrmithdobbs: The idea of calculi like this is mostly to help us understand type systems in a minimalistic context without distractions and interactions with other features making it complicated.
17:35:32 <Cale> lingxiao: Well, once you have dependent types, you sort of don't need kinds, as the difference between types and terms is so blurred that you can do something like introduce an infinite sequence Type n :: Type (n+1)
17:36:35 <lingxiao> wait.. so does that expression mean the datatype Type n has type annotation Type (n+1)
17:36:36 <Cale> lingxiao: But there are also languages like Omega, which introduce an infinite hierarchy of terms : types : kinds : ... which all remain separate, but definitions made at one level are automatically lifted to all higher ones as well.
17:36:41 <Twey> lingxiao: Thankfully you don't need infinite mental capacity to make sense of an infinite tower of types, for the same reason you don't need infinite mental capacity to make sense of infinite loops :þ
17:36:47 <Cale> lingxiao: yes
17:37:22 <Cale> lingxiao: The idea being that ordinary types like Integer might belong to Type 0
17:37:29 <lingxiao> so is n here a term? like an Int?
17:37:33 <Cale> yes
17:37:37 <Cale> a Nat
17:38:24 <Cale> (This sequence of universes will tend to have to be somewhat built into the language though)
17:38:39 <Cale> There are a bunch of minor variations on how you do this
17:38:51 <Cale> But if you make Type :: Type
17:39:06 <Cale> then you lose some of the utility of your language for proving things in mathematics :)
17:39:16 <Cale> (It's probably okay for practical programming languages though)
17:39:43 <Twey> Cale: I think Type : Type gives you unsafeCoerce
17:39:52 <lingxiao> what's wrong with Type :: Type?
17:40:05 <lingxiao> such that you can't prove things with it?
17:40:06 <Cale> Twey: I don't think so (but I'd be interested if you could prove me wrong!)
17:40:14 <Cale> It just lets you write nonterminating programs
17:40:26 <Cale> (Even if the language has no other way to do that)
17:40:47 <lingxiao> wait.. but in haskell I can write nonterminating programs right?
17:40:50 <Cale> Which means that your "proofs" might take forever to reach their conclusions, and won't really be logically valid.
17:41:07 <Cale> Yes, the Haskell type system is a really bad way to reason about what's true :)
17:41:19 <Cale> There is still a sort of connection though:
17:41:59 <lingxiao> so back there you're saying even if the program of terms, if you will, does terminate, the type checker that runs over the types will not?
17:42:07 <Cale> In logic, if you know that (A -> B) (read: "A implies B", or "if A then B"), and you know that A, then you can conclude B
17:42:17 <hpc> lingxiao: the opposite
17:42:26 <hpc> lingxiao: write a program that typechecks, and then fails to terminate when run
17:42:27 <Cale> In functional programming, if you have f :: A -> B, and you have x :: A, then you can obtain f x :: B
17:42:48 <lingxiao> hpc: oh ok .. I guess I got tripped up by this "(Even if the language has no other way to do that)"
17:42:55 <Twey> Cale: That's sufficient to let you write unsafeCoerce, because you can write a non-terminating member of A → B
17:42:56 <Cale> In logic, if you want to prove that A -> B, you start by assuming that you know A, and try to follow some reasoning to conclude that B
17:43:19 <lingxiao> ahh.. so application shortens the string of types
17:43:21 <Cale> Twey: oh, but is that really unsafeCoerce, or is it (const undefined)?
17:43:49 <Twey> I'm not totally convinced there's a difference
17:43:59 <Twey> (modulo implementation, of course)
17:43:59 <hpc> Cale: any defined outputs of unsafeCoerce are operational detail
17:44:09 <hpc> semantically, unsafeCoerce doesn't have a defined output
17:44:14 <Cale> In functional programming, in order to construct a function f :: A -> B, we assume that we have x :: A, and try to construct a term y :: B, and conclude that (\x -> y) :: A -> B
17:44:35 <hpc> Cale: it's from the same world where (os :: String) is considered impure
17:44:39 <Cale> hpc: Well... okay
17:44:56 <Cale> hpc: The point is that the term restricts to the identity when A and B are really the same
17:45:28 <Cale> i.e. when you try to compute with it, it will work when A and B happen to be equal
17:45:30 <lingxiao> wait, so if you have Type :: Type, how does that get you "f :: A -> B, x :: A  therefore f x :: A -> B"
17:45:38 <jle`> Cale: I don't think I have
17:45:47 <Cale> lingxiao: Oh, this has nothing to do with that specifically
17:45:52 <hpc> lingxiao: Twey is getting ahead; stick with Cale's train of thought for a bit ;)
17:46:02 <Cale> lingxiao: I'm describing a general connection between logic and programming
17:46:08 <lingxiao> oh sorry.. haha .. yeah channel heated up for a second I got lost
17:46:11 <Cale> lingxiao: As a kind of setup for everything else
17:46:18 <lingxiao> ok sweet, go on
17:46:36 <lingxiao> please
17:46:59 <Cale> Okay, so we can interpret function types as being like implications. Similarly pair types behave exactly like "and", and sum types (such as Either) behave like "or"
17:47:16 <Cale> The unit type behaves like "true" and the empty type behaves like "false"
17:47:32 <Cale> In Haskell, we have general recursion
17:47:37 <Cale> So we have an operation:
17:47:39 <Cale> :t fix
17:47:40 <lambdabot> (a -> a) -> a
17:47:57 <Cale> which logically, says "If A implies A, then A"
17:48:06 <Cale> but of course A implies A!
17:48:10 <Cale> :t fix id
17:48:11 <lambdabot> a
17:48:17 <hpc> everything is true!
17:48:18 <Cale> and so we have a "proof of anything"
17:48:19 <joelteon> > fix id 1
17:48:20 <ski> it's the logical principle of reasoning in a circle
17:48:23 <lambdabot>  mueval-core: Time limit exceeded
17:49:01 <ski> "if, assuming `A', you can show `A', then this constitutes a proof of `A'"
17:49:03 <kristof> I smell dark magic and Curry-Howard perversion.
17:49:24 <Cale> So, the fact that we can write nonterminating programs means that our logic's ability to reason about what is true is destroyed. We care about the differences between the proofs of the same proposition though, because our programs have meaning beyond "this type is inhabited!"
17:49:40 <Cale> So, not all is lost, but as a system in which to do mathematics, the language is bad.
17:49:40 <hpc> kristof: the stench is overpowering, you faint and a spider eats you - game over
17:50:19 <kristof> hpc: At least it wasn't a Grue
17:50:30 <jrmithdobbs> Cale: but still less bad than most options
17:50:33 <hpc> :D
17:50:49 <kristof> hpc: How nerdy are we to get that reference?
17:51:07 * kristof snorts
17:51:08 <ski> (considered as a logic, the type system of Haskell is inconsistent. however, usually if we say a type system is inconsistent, we mean that if an expression has type `A', then if we reduce (simplify) it a bit, it will still have type `A')
17:51:22 <Twey> ski: ?
17:51:35 <Cale> lingxiao: It turns out that you can construct extremely powerful programming languages which still don't have general recursion. They're technically not quite Turing complete, but because they're so expressive, it's actually surprisingly close enough for most purposes.
17:51:39 <ski> Twey.
17:51:55 <kristof> Cale: Examples?
17:51:59 <kristof> Or reference papers
17:52:00 <Twey> ski: That (preservation) seems like a criterion for a *consistent* type-system to me :þ
17:52:01 <Cale> lingxiao: Such languages include Coq and Agda, and pretty much anything people would call a "theorem prover"
17:52:06 <kristof> ...ah
17:52:14 <jrmithdobbs> Cale: an (uninteresting, but timely) example being the bitcoin script language
17:52:21 <ski> Twey : .. oh, sorry, flip the second "inconsistent" to "consistent"
17:52:58 <ski> Cale : or proof assistant
17:53:03 <Cale> The are some other dependently typed languages like Idris, which admit general recursion, but still keep a close enough eye on things that they can still check for you that various functions must terminate, if you don't use general recursion.
17:53:22 <lingxiao> so in theorem provers, the type "(a->a)->a" is uninhabited... is that right?
17:53:30 <Cale> right.
17:53:55 <ski> (and there's Cayenne, a dependently typed language based on Type theory where just anything might not terminate, including type checking)
17:54:35 <lingxiao> that's really cool actually, I didn't know that about Agda, not that I knew much about it at all
17:54:35 <ski> @where Cayenne
17:54:35 <lambdabot> Dependently typed FPL with turing-complete type system, by Lennart Augustsson (augustss), at (broken) <http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>, <http://web.archive.org/web/*/www.cs.chalmers.se/~augustss/cayenne/index.html>. Also see `Agda'
17:54:53 <Cale> lingxiao: These languages tend to insist that when you write a recursive function, in at least one parameter, you must be applying the function to a variable which was matched from the corresponding structure in the pattern match from that parameter.
17:55:14 <Cale> lingxiao: e.g. in a function on trees, the recursive call must be made on a subtree.
17:55:45 <Cale> lingxiao: (or else, there must be some other parameter which is "decreasing in size")
17:55:50 <jrmithdobbs> to garauntee reduction on each step that makes sense
17:56:37 <lingxiao> how does the type checker know the data is decreasing in size?
17:56:57 <jrmithdobbs> because the type gets shallower
17:57:18 <Twey> lingxiao: Agda's literally just checks to see that any recursive calls to the current function have at least one parameter that's a subterm of a parameter passed in
17:57:28 <jrmithdobbs> lingxiao: the data structure needs to reduce, not the data
17:57:32 <jrmithdobbs> the distinction matters here
17:57:56 <lingxiao> is its size encoded in the type?
17:57:57 <lingxiao> sorry yeah that's what I meant
17:57:58 <lingxiao> Twey: so the type checker is "reading" the terms in this case
17:57:59 <Twey> lingxiao: You can also have ‘sized types’, where every type carries a ‘size’ parameter that increases with constructors, so the type system takes care of finding out the size of a term for you
17:58:03 <ski> (<http://web.archive.org/web/20100103222945/http://www.cs.chalmers.se/~augustss/cayenne/index.html> looks like the most recent capture of the Cayenne page. i'm actually not sure why the other link was there above)
17:58:23 <Twey> lingxiao: In a system like Agda's, the type-checker and the termination-checker are completely independent
17:58:55 <Twey> The termination checker is just a simple mechanical check on the forms of recursive calls
17:58:58 <heatsink> The first strategy is structural recursion
17:59:10 <heatsink> What is the sized data termination strategy called?
17:59:12 <dolio> Not totally.
17:59:13 <Twey> lingxiao: With sized types, the type-checker is used to figure out the size of parameters passed to recursive calls, so it's a good bit smarter
17:59:30 <lingxiao> Twey: so the termination checker is not reasoning about termination in terms of types? in the case of *not* sized types
17:59:46 <Twey> lingxiao: Right, it's just looking at the shape of terms
17:59:57 <lingxiao> which is different than what Cale was saying about inferring termination from types
18:00:25 <Twey> lingxiao: I don't think he said anything like that
18:00:29 <lingxiao> but even the sized types, isn't that a clever and totally sensible solution, but still not in the same spirit as what Cale is saying?
18:00:47 <lingxiao> because now you have a Nat, a term, inside the type, so you're still checking terms
18:00:48 <Cale> lingxiao: Well, it's kind of an extension of what I'm saying
18:01:23 <Cale> oh, sorry, I missed part of the conversation
18:01:26 <lingxiao> unless 0 | succ 0 are types
18:01:29 <Twey> lingxiao: You're always going to be ‘checking terms’ in that sense
18:01:33 <Cale> (had to go ban some idiots in another channel)
18:01:54 <lingxiao> Cale: so you said: lingxiao: e.g. in a function on trees, the recursive call must be made on a subtree.
18:02:02 <Twey> lingxiao: Oh, sorry — I was thinking in terms of languages without the term/type distinction
18:02:11 <Cale> So, "sized" in this sense, means that we keep track of the sizes of the values in the types, but those sizes aren't involved in termination checking
18:02:17 <Twey> lingxiao: It'll be a term of whatever language its containing data-type is
18:02:36 <lingxiao> oh, ok so that's what Cale meant by blurring those two makes them more expressive
18:02:40 <Twey> (or just magic)
18:03:03 <Cale> lingxiao: Yeah, you can define something like
18:03:24 <Cale> data Vector a :: Nat -> Type where
18:03:43 <Cale>   VNil :: Vector a 0
18:03:58 <Cale>   VCons :: a -> Vector a n -> Vector a (S n)
18:04:32 <heatsink> Is the Nat type parameter the size?
18:04:39 <heatsink> in the termination sense
18:04:49 <Twey> heatsink: It can be
18:04:51 <Cale> heatsink: Not in the termination sense, but in the other sense :)
18:05:11 <Cale> But yeah, it's possible to use that Nat to show that programs are going to terminate.
18:05:20 <heatsink> Yes
18:05:24 <Cale> Because when you write a recursive function on Vector, that Nat is going to be a parameter
18:05:32 <heatsink> but I think that qualifies as structural recursion on the nat
18:05:44 <Cale> and you're going to make the recursive call probably at a type where it's the thing you pattern matched out
18:06:02 <Cale> (but you'll also be doing structural recursion on the Vector term at the same time)
18:06:09 <heatsink> sure
18:06:32 <Twey> heatsink: It doesn't have to be; one of the advantages of sized types is that you can reason about them in your own program to show that they've decreased
18:06:40 <scott_> :t (+1) :: Int => Int
18:06:41 <lambdabot> Int -> Int
18:06:43 <scott_> ^ Why is that?
18:06:55 <Twey> So you could end up with a neutral size term like (n + 2 - 3)
18:06:56 <scott_> Notice the =>
18:06:59 <Cale> scott_: lol...
18:07:07 <Twey> scott_: It's a bug, fixed in 7.8
18:07:10 <lingxiao> so basically with these things size has to be decreasing all the time?
18:07:18 <scott_> Okay, thanks for the info :)
18:07:23 <lingxiao> it can't be eventually decreasing?
18:07:36 <lingxiao> so somwhere in the middle lengthening
18:07:37 <Twey> scott_: From an incautious translation to Core, where constraints are actually passed around as dictionaries ☺
18:07:45 <heatsink> wow
18:07:49 <LinearInterpol> I just wrote my first two haskell functions!
18:07:52 * LinearInterpol feels immensely proud.
18:08:03 <catalyst> :D
18:08:06 <heatsink> Do... do they compile?
18:08:10 <LinearInterpol> I. Am not sure.
18:08:17 <Cale> lingxiao: Yes. If you want the thing to decrease eventually, you're typically going to need to add some other "invariant" parameter to prove it.
18:08:20 <jrmithdobbs> premature celebration ;p
18:08:25 <LinearInterpol> I was working through this with someone who's experienced in Haskell.
18:08:35 <lingxiao> is there an example of that, just out of curiousity
18:08:36 <dolio> It's just a bug in GHC 7.6.3 (exclusively, I think).
18:08:51 <Twey> lingxiao: You're talking about terms in a function — so if it hasn't decreased by the next call, it's never going to
18:08:54 <LinearInterpol> I'm getting a parse error on "|"
18:09:06 <LinearInterpol> 	| p x  = x:filter p xs
18:09:13 <LinearInterpol> (where the first space is a tab.)
18:09:33 <lingxiao> Twey: how do you know in the next next call, it won't switch to shortening?
18:09:47 <lingxiao> like a fucntion that grows a tree to size 5, then deconstruct to Tip
18:09:47 <heatsink> LinearInterpol, Can you paste the code in lpaste so we see the whole thing?
18:09:52 <LinearInterpol> Sure.
18:09:53 <lingxiao> or am I missing the point
18:10:15 <Cale> lingxiao: I don't have an easy one off-hand, but very generically, if you can write a function which can determine ahead of time how many steps your untyped lambda term is going to take to reduce to normal form, or how many steps your Turing machine will need in order to terminate, then you can write a helper function which takes an additional Nat parameter which is decreasing, and supply it with an initial value based
18:10:16 <Cale>  on that computation.
18:10:16 <ski> lingxiao : there has to be a "measure" on the inputs which are decreasing
18:10:18 <LinearInterpol> http://lpaste.net/6983381270109618176
18:10:53 <heatsink> LinearInterpol, the guard belongs before the = sign
18:10:55 <Cale> lingxiao: So basically, you need to be able to *prove* that it's going to stop.
18:11:01 <LinearInterpol> Oh.
18:11:02 <LinearInterpol> Sorry.
18:11:04 <heatsink> You have filter p (x : xs) = | p x = x : filter p xs
18:11:12 <LinearInterpol> My bad. :)
18:11:15 <Cale> lingxiao: and if you can't do that, then the system won't let you write your program :)
18:11:19 <nstdloop> I'm implementing Monads (at a basic level) in python for a project. What are the key features I absolutely must have?
18:12:28 <Twey> lingxiao: The measure in that case is 5 - size of tree
18:12:29 <ski> lingxiao : iow, there must be some well-ordering on the function input
18:12:29 <Twey> nstdloop: A type system ;)
18:12:29 <nstdloop> :)
18:12:29 <Cale> lingxiao: For programs which are intended to run forever, such as operating systems, these systems also tend to have what are called coinductive types, where the condition on recursion is modified.
18:12:31 <lingxiao> coinductive, very sexy name if I may say so
18:13:02 <prooftechnique> I'm working on some convenience Show instances for data structures, and I want to make sure that the way I'm doing it is at least vaguely safe and sensible. Example for Map: http://lpaste.net/7840932672565149696
18:13:03 <Cale> lingxiao: Instead of having the recursive call required to be applied to a subterm, you instead *must* introduce a constructor of that type between the match and the recursive application.
18:13:13 <lingxiao> ok so I see the general gist, I guess this is a matter of detail... but if you're reading the size of the data structure to prove the function termiantes
18:13:24 <Twey> nstdloop: I'm not sure it makes sense to talk about ‘implementing Monads’ in Python.  You can't write a type, and it's types that are Monads.  You could maybe write some functions or syntactic sugar on objects that support bind and return.
18:13:42 <Cale> lingxiao: and that way, it ensures that you *keep going*, rather than getting stuck somewhere
18:13:57 <ski> lingxiao : an example of a well-ordering on `A * B', composed from two well-orderings, on `A' resp. `B', is the lexicographic ordering. it says that if `a0 < a1' then `(a0,b0) < (a1,b1)' (regardless of how `b0' and `b1' compares), while if `b0 < b1' then `(a,b0) < (a,b1)', and that's all the ways the `<' on the pairs can be true
18:14:12 <Cale> and you can't recursively eliminate a coinductive type to get an inductive one
18:14:49 <Twey> Hm, it feels like you should be able to specify a productivity check in terms of sized types, too
18:14:49 <nstdloop> Twey: I have to worry about python being dynamic, but I'm going to implement it in a way that's more just "trust the user" to not break things
18:14:55 <Cale> (unless you do structural recursion on something)
18:15:12 <nstdloop> Twey: I'm thinking just a class that you can subtype and implement bind, then, and return wit
18:15:34 <ski> lingxiao : this corresponds to recursion `f(a1,b1) = ..f(a0,b0)..' where we know `(a0,b0) < (a1,b1)', iow either we keep the same `a' and have to decrease `b1' to `b0', or we decrease `a1' to `a0' (and may increase `b1' to `b0', if we want to)
18:15:38 <nstdloop> But what other important features of Monads would I really want to have
18:15:50 <Twey> nstdloop: That's not really the issue: it's more that Monads are a type-level construct, and Python doesn't have a (useful) type-level
18:15:58 <Cale> nstdloop: return is a problem!
18:16:12 <nstdloop> I'd probably just call it monad_return or something
18:16:13 <Cale> nstdloop: Because return is only polymorphic in the type of its result
18:16:23 <nstdloop> ah
18:16:26 <Cale> :t return
18:16:27 <lambdabot> Monad m => a -> m a
18:16:34 <Cale> ^^ this is hard to do in an OO language
18:17:03 <Cale> Unless you add a function parameter to everything, turning  Monad m => a -> m a  into   Monad m -> a -> m a
18:17:04 <nstdloop> def monad_return(value, monad): return monad(value)
18:17:11 <Cale> i.e. take a dictionary of the monad operations
18:17:12 <ski> Twey : you can implement specific monads, and talk abstractly about them, and you can implement operations that will work for any monad (given a record, say, containing the `return' and `bind' operations of it)
18:17:20 <lingxiao> so if i can ask a question about details...
18:17:23 <nstdloop> (which would actually be attached to a class and have self be the implicit parameter)
18:17:37 <ski> Twey : types can still be in your head in a dynamically typed language
18:18:05 <lingxiao> in the case where you proove a recurisive function over  some tree must terminate but enforcing the constraint that at each step, the data structure tree must be smaller, or you must use some subterm
18:18:14 <Twey> ski: You can just write normal Python code and imagine you're using monads, sure :þ
18:18:17 <Cale> nstdloop: def monad_return(value, monad): return (monad.ret(value))
18:18:18 <lingxiao> how do you you proove that without running the program..
18:18:43 <ski> Twey : well, "normal Python code" presumably wouldn't usually make use of monads :)
18:18:44 <lingxiao> and at each step type check ...
18:18:53 <Cale> nstdloop: def monad_bind(x, f, monad): return (monad.bind(x, f))
18:18:55 <dolio> That's monads in whatever formal system you're using to talk about your Python code.
18:18:59 <dolio> Not in Python. :)
18:19:29 <nstdloop> Cale: Ya, something along those lines. But besides just having bind, return and then functions (which are really just monad specific) what else do I need to implement
18:19:33 <Cale> nstdloop: and now everything you write involving the monad needs to take the monad instance as an extra parameter
18:19:42 <lingxiao> nstdloop: hey douglass crockford wrote a monad impl in js, if you're interested. https://github.com/douglascrockford/monad
18:19:47 <Cale> nstdloop: So when you translate from Haskell, it's going to be *messy*
18:19:51 <lingxiao> it might be somewhat relevant
18:19:56 <arcke> whats better than 'tmax a b = if (snd a) > (snd b) then a else b'?
18:20:07 <nstdloop> Cale: I'm doing it for a school project/intellectual exercise instead of real code
18:20:10 <Twey> ski: But there can be monads in your head!  You can pretend the newline is a >> :þ
18:20:13 <Cale> but it'll at least be an honest translation, instead of the BS that you find on most "HEY GUYS MONADS IN JAVASCRIPT" blog posts.
18:20:25 <nstdloop> I wouldn't usually think about using monads in python
18:20:34 <nstdloop> So it's ok if it's messy
18:20:51 <dolio> Monads in python will have other problems, too.
18:20:56 <Cale> nstdloop: If you want to make sure that you've got the abstraction right, a good check is implementing sequence
18:21:13 <Cale> nstdloop: in such a way that it works with *any* monad, not just, e.g. the Maybe monad.
18:21:24 <Twey> Fuuzetsu recommends having a giant global dictionary indexed by ‘type’ values for the instances
18:21:26 <lingxiao> ski: when you say well ordering on function input, you mean comparing from one recursive call to the next right
18:21:27 <Cale> i.e. you write the code once, and use that one version forever
18:21:33 <dolio> Like, the way you build up structure is bad for most applications unless you have proper tail calls.
18:21:35 <ReinH> lingxiao: douglas crockford wrote a thing that he claims is a monad in javascript
18:21:42 <dolio> Which cpython doesn't.
18:21:45 <dolio> Same with javascript.
18:21:53 <ReinH> lingxiao: I've watched the keynote where he talks about it. It's basically him being wrong about what monads are for an hour.
18:21:57 <Twey> So you can write monads[typeof(foo)].monad_return(a) for return a ∷ foo
18:21:58 <nstdloop> Cale: Right. You have any thoughts on what specific things I might want to make sure I do right/avoid?
18:22:06 <Twey> Er
18:22:16 <ReinH> it's literally "if you can chain methods together then *hand wave hand wave* monad"
18:22:20 <ReinH> o_O
18:22:43 <Twey> … that notation is horribly broken but I don't know how to write it better
18:23:04 <lingxiao> ReinH: oh haha, I regrettably did not watch that keynote
18:23:13 <ReinH> lingxiao: you didn't miss much
18:23:25 <Twey> monads[list].monad_return(a) for return a ∷ [A], where a ∷ A, I guess
18:23:34 <Cale> nstdloop: Well, just what I kind of just said: remember that the whole point of abstracting over monads is to be able to write things like the stuff in Control.Monad which works for an arbitrary monad. If you can write sequence and mapM and stuff in a generic way, then you've done it right.
18:23:34 <lingxiao> haha yeah .. I wish I can go back and unread all monad tutorials for that matter
18:23:45 <ReinH> yep
18:24:09 <triliyn> Are python types hashable? I don't think I've ever tried doing that
18:24:19 <Twey> I think all Python objects are hashable
18:24:29 <Cale> nstdloop: If you can't write code which works in an arbitrary monad, then you've missed the point of talking about monads in the first place.
18:24:37 <nstdloop> ok
18:24:50 <nstdloop> Twey: yes
18:24:57 <nstdloop> Twey: Except for mutable things
18:25:20 <Twey> They're still hashable, aren't they?  They just break everything if you use them as keys and then mutate them
18:26:38 <Twey> Oh, no, I guess not
18:26:39 <ReinH> python is weird
18:26:39 <Twey> TypeError: unhashable type
18:26:39 <nstdloop> If you try to do a = {[5, 6]: 5}
18:26:39 <nstdloop> ya
18:26:39 <nstdloop> exactly
18:26:39 <nstdloop> Cale: I'll keep that in mind.
18:26:54 <ratzes> is there a way to make a (newtype a) deriving everything that a has as an instance?
18:26:59 <Fuuzetsu> cast the mutable to string~
18:27:08 <Cale> nstdloop: I don't actually believe that monads are implementable in Python in a way which is practically usable.
18:27:21 <triliyn> ratzes: there's an extension for that I think, though I've heard it's moderately unsafe
18:27:28 <Cale> nstdloop: *specific* things which would happen to be monads, were they in Haskell, you can do.
18:27:34 <ratzes> general new type deriving?
18:27:37 <triliyn> GeneralizedNewtypeDeriving?
18:27:45 <Twey> That's not quite the same
18:27:54 <Cale> nstdloop: But you kind of have to do this extra explicit parameter transformation to make it work in python
18:28:00 <Twey> You can say ‘deriving a’ for any a that the inner type implements, but you still have to tell it
18:28:05 <ratzes> my issue is that "a" implements some pretty weird classes that you can just type deriving for
18:28:14 <Cale> nstdloop: and that makes it pretty obnoxious to actually use
18:28:15 <ratzes> *can'
18:28:18 <ratzes> *can't
18:28:23 <AshyIsMe> hmm, wonder if it'd take me longer than a weekend to rewrite my small nodejs webapp in haskell and use riak instead of mongodb
18:28:25 <ratzes> lol, yeah it does
18:28:27 <Twey> ratzes: You can with GeneralizedNewtypeDeriving
18:28:35 <nstdloop> Cale: I think what you can do is have a master Monad class which has Not implemented bing/then/return, then write all kinds of control functions that just assume that those functions have been implemented correctly
18:28:58 <ratzes> just not something with multiple parameters
18:29:03 <Cale> nstdloop: The problem is getting an instance of that class to where you need it.
18:29:17 <Cale> nstdloop: (i.e. a real instance)
18:29:21 <triliyn> It would be funny to be able to say "data Whatever = ... deriving (..)"
18:29:25 <triliyn> I don't think that works though
18:29:26 <nstdloop> Most of the control functions take some instance of a monad as some parameter, right?
18:29:32 <triliyn> *newtype
18:29:34 <ReinH> Or knowing that you're actually giving bind an a -> m b
18:29:38 <ratzes> that would be awesome
18:29:52 <dolio> The tail calls thing also makes it impractical, unless you do a lot of work to get around it.
18:30:03 <Cale> nstdloop: If by "instance" you mean the same thing as "instance" means in Haskell, and not simply "value of some type which happens to be in the particular monad"
18:30:34 <Cale> nstdloop: sequence [] = return []
18:30:36 <ReinH> For example, please do this with your monad class:
18:30:37 <ReinH> chat.meatspac.es
18:30:39 <ReinH> not that
18:30:40 <nstdloop> I was thinking more instance in the OO sense, which still gives you access to the functions - albeit in an unsafe and rickety manner
18:30:45 <Cale> ^^ think about how that translates into Python...
18:30:46 <ReinH> the thing I meant to put in my paste buffer
18:30:57 <ReinH> > "foo" >>= const (return "bar") :: [String]
18:30:58 <lambdabot>  ["bar","bar","bar"]
18:31:01 <ReinH> and no, that link was not porn
18:31:22 <ReinH> you can't get that kind of polymorphism
18:31:22 <Cale> nstdloop: You have 0 values of the type of action you want to produce, and you need to pull a value of that type out of thin air.
18:31:30 <Cale> nstdloop: So, something is missing.
18:31:41 <nstdloop> right...
18:31:48 <nstdloop> So you do need to pass around the class
18:31:51 <nstdloop> darn
18:31:56 <Cale> nstdloop: When the Haskell compiler compiles functions involving a type class constraint, it turns those type class constraints into additional function parameters
18:32:06 <Cale> and that's what makes all the magic work in Haskell
18:32:09 <nstdloop> which you'd have to do manually in python
18:32:12 <Cale> right
18:32:52 <nstdloop> That's what the monomorphism restriction is about too, right
18:32:56 <heatsink> No
18:32:57 <Cale> Kinda
18:33:29 <Cale> The reason the MR is there is because of this implementation mechanism meaning that things which look like constants won't act like constants operationally
18:33:37 <Cale> i.e. they'll get recomputed everywhere they're used
18:33:45 <nstdloop> Which is because of those extra arguments
18:33:50 <heatsink> yes
18:33:52 <nstdloop> it turns a constant lookup into a functionc all
18:33:53 <Cale> That's a really bad reason for the MR, but it's the only real one.
18:34:10 <ski> lingxiao : i mean that there has to be a well-ordering on the input, and that the input to all the recursive calls must be less than the current input to the function, in that well-ordering
18:34:18 <nstdloop> Ok. So these functions are all going to be ugly, but at least they're possible.
18:34:24 <Cale> yes
18:34:33 <kristof> Why are functions not instances of Read?
18:34:44 <Cale> kristof: How would you read a function?
18:34:58 <Cale> kristof: parse Haskell code? :)
18:35:06 <kristof> hmmm
18:35:14 <Cale> (and compile it!)
18:35:33 <kristof> Cale: I guess so, then
18:35:50 <heatsink> Which global variables would the Read parser know about?
18:36:09 <Cale> It's probably just that making all programs a few hundred megabytes larger by including an entire GHC into the runtime system would be considered a bit unfortunate.
18:36:25 <kristof> ......................................................that is true
18:36:43 <Twey> Well, Common Lisp does it!
18:37:08 <kristof> heh
18:37:09 <kristof> well
18:37:18 <kristof> You have the entire compiler in every Common Lisp program
18:37:20 <kristof> by default
18:37:57 <triliyn> And indeed, most open source common lisp compilers produce executables that are Pretty Large!
18:38:03 <lingxiao> ahh got ya, thanks
18:38:04 <lingxiao> !
18:38:30 <triliyn> (I've heard some of them make use of a magical art called Tree Shaking, but at the time I heard of this none of the major open source ones did?)
18:38:31 <kristof> triliyn: Well, expecting a Common Lisp executable to be small is like expecting a jar executable to be runnable and small even though the person running it has no JVM
18:38:42 <triliyn> hehe, right
18:38:55 <AshyIsMe> how does erlang handle function serialization?
18:39:01 * hackagebot encoding 0.7 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.7 (DanielWagner)
18:39:19 <AshyIsMe> does cloud haskell have the same hotloading that erlang has?
18:39:27 <kristof> no
18:39:28 <kristof> Not the same
18:39:30 <kristof> but it has hotloading
18:39:36 <Cale> It has TH-based explicit closure formation.
18:40:42 <lingxiao> hey all this might be a silly question
18:41:21 <lingxiao> but in STLC, if I have a base type that just has the unit type... so:
18:41:30 <lingxiao> Type = A () | Type -> Type
18:41:35 <kristof> Philosophical question. Why are functions that have the type a -> m a so interesting? As opposed to functions that have the signature m a -> a or m a -> m a
18:41:59 <Cale> kristof: Those other types are interesting too!
18:42:11 <lingxiao> a -> m a is born pure but becomes dirty
18:42:11 <kristof> Cale: but people never talk about comonads as much as they talk about monads :P
18:42:12 <triliyn> kristof: there are no polymorphic functions with the signature Monad m => m a -> a
18:42:12 <heatsink> m a -> a is a comonad
18:42:12 <lingxiao> like life
18:42:40 <triliyn> But yes, there are comonads, which are interesting but haven't entered the common vocabulary
18:42:47 <Cale> heatsink: or (if a is not polymorphic), a monad algebra...
18:43:05 <djahandarie> Cale, granted, I think m a -> m a is not very interesting if a is polymorphic. :p
18:43:08 <triliyn> And Functor f => f a -> f b is fmap, which is also pretty interesting
18:43:11 <lingxiao> so if I want to represent boolean val true using church encoding, tru := λx ∈ T1 λy ∈ T2  . x
18:43:14 * heatsink knowsn't anything about monad algebras
18:43:19 <lingxiao> what types should T1 and T2 be
18:43:21 <Cale> djahandarie: control structures
18:43:33 <Twey> kristof: m a → a is born dirty but becomes pure, like Life ;þ
18:43:51 <copumpkin> :t forkIO
18:43:52 <lambdabot> Not in scope: `forkIO'
18:44:04 <heatsink> lingxiao, it's polymorphic, and T1 = T2
18:44:05 <dolio> lingxiao: Strictly speaking, you can't represent booleans.
18:44:09 <kristof> Cale: Also, cellular automata, apparently
18:44:16 <randomclown> am I being trolled hard or something
18:44:24 <randomclown> is hPutStr not threadsafe?
18:44:24 <ski> kristof : for a monad `m', both `A -> m B' and `m A -> m B' can be useful -- however the latter type in a sense includes all the functionality of the former (and more)
18:44:30 <lingxiao> uhh... but if I'm doing STLC, which have no type variables, how would I represent it?
18:44:33 <Cale> randomclown: ???
18:44:34 <dolio> You have to choose when you make the 'boolean' what type it can be eliminated over.
18:44:39 <lingxiao> dolio: how so?
18:44:44 <Cale> randomclown: In what way is it not threadsafe?
18:44:55 <lingxiao> ohh... so a boolean value true for every conceivable type?
18:44:59 <copumpkin> randomclown: it's not atomic, if that's your issue
18:45:01 <Twey> kristof: Comonads are nice for cases where you have some context and you ‘condense’ it to get a single value, like in cellular automata or signal processing
18:45:02 <dolio> Right.
18:45:04 <lingxiao> so I have to define tru1, tru2 ..
18:45:05 <Cale> randomclown: If you're printing stuff from multiple threads to the same handle, the strings will be spliced together.
18:45:10 <kristof> ski: Ok, I accept that answer, but the inverse of the first type signature is what I'm mostly thinking about
18:45:12 <lingxiao> ahh, I see the limitations of STLC
18:45:19 <copumpkin> randomclown: it's perfectly threadsafe though, or should be
18:45:21 <kristof> Twey: Ah, that's true
18:45:22 <lingxiao> Twey: I'll know when my life is m a -> a
18:45:34 <ski> kristof : so, for functionality that we can write in `m A -> m B', but where we also can write it in `A -> m B', we prefer writing it in `A -> m B', to make it obvious that we're not relying on the extra functionality probably present in `m A -> m B'
18:45:36 <randomclown> Well I'm printing a lazy Text
18:45:43 <zRecursive> :t lift
18:45:44 <randomclown> and it's splicing with another lazy Text
18:45:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:45:56 <Twey> lingxiao: Your life might be a → m a, but your Life will be w a → a ;)
18:45:59 <Cale> randomclown: Well, what did you expect? :)
18:46:15 <ski> kristof : `w A -> B' would probably be more interesting if `w' is a comonad (though that's not the only interesting case)
18:46:17 <randomclown> Cale: you don't expect chunks of lazy text to splice do you?
18:46:19 <kristof> ski: right, so we can just use >>= to worry about "unboxing" the monadic A and hence get more flexible functions, yeah?
18:46:19 <Cale> randomclown: That one thread completely finish its printing before the other begins?
18:46:21 <copumpkin> randomclown: my usual approach to that sort of issue is to fork another thread (they're cheap) and send things to output over a chan to it
18:46:35 <ski> kristof : i'm not sure what you're asking
18:46:36 <Cale> randomclown: It's just going to fire characters at that handle.
18:46:40 <dolio> lingxiao: There isn't even a single identity function.
18:46:42 <kristof> ski: I'm not sure either
18:47:09 <Cale> randomclown: and if you do that from two different threads, you end up with some interleaving of the characters
18:47:15 <lingxiao> dolio: so one has to be defiend for each type as well right? I remeber reading this arg for polymoprhic types, it's like the fav toy argument
18:47:19 <randomclown> Cale: even printf provides guarenttes of non interleaving characters
18:47:32 <lingxiao> Twey: that's deep, even for this channel
18:47:40 <Cale> randomclown: The answer is just to make another thread, and have a Chan Text
18:47:46 <lingxiao> and that inversion of m to get w
18:47:51 <Twey> lingxiao: Cellular automata jokes grow on you.
18:48:14 <dolio> lingxiao: Sometimes people correct this by assigning type schemas to terms in the STLC. Which is more or less like Hindley-Milner.
18:48:24 <Cale> randomclown: Then you can send whole texts at once to the channel, and the writer thread will write one out before starting the next
18:48:43 <dolio> So (\x -> x) has a type schema 'a -> a' which isn't a type in the STLC, but a schema for generating all the types it could have.
18:48:52 <randomclown> So clearly hPutStr is not thread safe
18:49:07 <Cale> randomclown: It's thread safe, it's just not atomic.
18:49:24 <lingxiao> dolio: woa I've never hear of that ... uh are a's type variables? or is it something completely different
18:49:31 <Cale> There's not some global lock which it takes while it operates.
18:49:45 <Cale> The other threads will continue to run and do whatever they were going to do
18:49:47 <dolio> lingxiao: They're variables, but the type language of the STLC doesn't have variables.
18:49:57 <dolio> So it's more correct to say that they're meta-variables, I guess.
18:50:22 <Cale> This won't cause your program to crash, but it might involve interleaving output in a way which you find unpleasant.
18:50:34 <lingxiao> uh so they're outsidef of the STLC formal system?
18:50:56 <lingxiao> so if I want to implement it for example, do I need  a universe of schemas?
18:51:05 <lingxiao> not that I would want to implement it
18:51:37 <ski> kristof : typically, if you have `g :: m A -> m B' such that the functionality of it can be expressed as an `f :: A -> m B', this means that `g ma = ma >>= \a -> f a' (iow `g = (>>= f)', or equivalently, that `f a = g (return a)' (iow `f = g . return')
18:51:41 <dolio> I guess that's right. Yes.
18:51:51 <lingxiao> dolio: ok thanks!
18:52:11 <dolio> It's a lot nicer to work with schemas of types than STLC types themselves.
18:52:21 <dolio> Because the former stand in for infinitely many of the latter.
18:52:23 <ski> kristof : so a "trivial" `g' in this sense is one that always first "executes" its action input immediately, and then doesn't execute it any more times
18:52:39 <dolio> Well, potentially.
18:52:47 <ski> kristof : sometimes i call such a `g' a "referentially transparent" `g' :)
18:52:57 <dolio> And there are pretty well-known ways for working with schemas directly.
18:53:24 <dolio> Like, the type systems for ML and Haskell and the like.
18:53:25 <kristof> ski: Yes, I see it now. :) Silly me.
18:54:04 <kristof> ski: I'm still unconvinced that stringing comonads and monads together isn't useful somewhere, like hylomorphisms stringing folds and unfolds...
18:54:27 <ski> kristof : in many of the cases, our functions doesn't *need* to take actions as inputs, since they would just immediately execute them (without any "wrapping" or "deferral" or "zero or multiple execution")
18:54:45 <lingxiao> dolio: what's an example of schema in haskell?
18:54:55 <dolio> :t \x -> x
18:54:56 <lambdabot> t -> t
18:55:01 <lingxiao> btw is there a #oCaml channel haha
18:55:07 <lingxiao> wait but I thought t is a type variable?
18:55:16 <lingxiao> and t -> t is just a  type
18:55:26 <kristof> ski: I understand.
18:55:37 <dolio> Haskell (sans extensions) doesn't have quantifiers for the variables.
18:55:43 <Cale> kristof: Something which is both a monad an a comonad in a compatible way is sometimes called a Hopf algebra.
18:55:54 <Twey> Cale: What's it for?
18:55:56 <kristof> Cale: Neat!
18:55:56 <dolio> So it's pretty much like Haskell types are STLC type schemas.
18:55:57 <Cale> kristof: I've never seen them show up in functional programming
18:55:58 <ski> kristof : for the cases where we *do* need that, we can use stuff like `replicateM :: Monad m => Int -> m a -> m [a]', `forkIO :: IO () -> IO ThreadId', `catch :: Exception e => IO a -> (e -> IO a) -> IO a'
18:56:02 <lingxiao> so t -> t is not the same thing as forall t. t -> t
18:56:23 <lingxiao> the former is a schema over type universe, the latter is an existentially quanittified type?
18:56:35 <ski> s/exisentially/universally/
18:56:42 <Cale> (actually, the generality is usually made a little higher, it's something which is a monoid object and a comonoid object in a compatible way)
18:56:43 <edwardk> ski: well, if m has a left adjoint then every m a -> m b can be written as a -> Codensity m b instead, and then there are no exotic 'm a -> m b' arrows =)
18:57:07 <ski> edwardk : yeah, talking about the general case here :)
18:57:09 <lingxiao> opps sory..
18:57:22 <kristof> Cale: What's a comonoid? Besides being the categorical dual of a monoid. :)
18:57:34 <ski> (also `Codensity m b' is more complicated than `m b')
18:57:39 <Cale> kristof: They're somewhat uninteresting in the category of sets
18:57:42 <edwardk> kristof: there are no intesting comonoids in Set/Hask
18:58:03 <Twey> lingxiao: You're mixing notations.  Haskell t → t is the same as Haskell ∀ t. t → t.  In STLC you have free type variables τ, which are concrete; but the schema dolio is talking about introduces its own (meta-)variables, that can be later unified with concrete STLC variables.
18:58:18 <dolio> Twey: (forall t. t -> t) does not exist in Haskell.
18:58:32 <lingxiao> wait it doesnt?
18:58:37 <dolio> No.
18:58:40 <Twey> dolio: Pardon?
18:58:43 <dolio> forall is a GHC extension.
18:58:54 <dolio> And Hugs, and....
18:58:54 <Twey> Oh, true.
18:59:03 <Cale> kristof: There's essentially one example, for which you have the trivial map A -> 1 for the counit, and the diagonal map A -> A x A,  diag x = (x,x)  for the comultiplication.
18:59:13 <lingxiao> ok see this is why I'm confused, so dolio is saying without extension t -> t is a schema over types
18:59:33 <lingxiao> but Twey is saying they're the same thing .. w/ or w/o extensions?
18:59:37 <edwardk> ski: sure. just figured i'd mention it because this came up for me today earlier =)
18:59:55 <ski> Twey : rather Haskell `x ∷ α → α' is the same as `x ∷ ∀ α. α → α'
19:00:11 <Twey> Indeed
19:00:23 <dolio> Whether that is true also depends on context.
19:00:26 <ski> (it's important that it's top type in a type signature)
19:00:37 <lingxiao> ski: what's α here?
19:00:45 <edwardk> you get a similar story for comonads with a right adjoint and Density, sadly, this is pretty boring, as there is only one adjunction from hask -> hask, so these statements are almost vacuous.
19:00:59 <dolio> Anyhow, what quantifiers do is sort of like making schemas first-class types themselves.
19:01:06 <dolio> Which adds a lot of power.
19:01:19 <Cale> kristof: In the category of vector spaces, where in the place of the Cartesian product there, you have the tensor product, you get a somewhat similar thing but which is a little more interesting
19:01:19 <ski> yes, namely on whether the type variable `α' occurs free in the type of some (value) variable (or constraint) of the expression defining `x'
19:01:28 <roboguy_> lingxiao: it's a type variable
19:01:34 <dolio> So, you can have 'true :: r -> r -> r' in Haskell.
19:02:07 <ski> dolio : but Church exponentiation doesn't work, iirc
19:02:11 <Cale> kristof: Where diag : V -> V ⊗ V is the linear map:  diag x = x ⊗ 1 + 1 ⊗ x
19:02:31 <Cale> er, I suppose we need V to be a tensor algebra, so that there's a suitable 1
19:02:33 <dolio> But if you try to do something like: "foo b = (b 5 6, b 'x' 'y')" It's not going to work.
19:02:43 <ski> edwardk : well, it's good that you mentioned it, because i hadn't thought about it from that angle before
19:02:50 <dolio> So in a sense, you still can't represent booleans adequately.
19:03:03 <dolio> Without genuine polymorphism.
19:03:07 <ski> @type ContT . (>>=)  -- only from this angle
19:03:08 <lambdabot> Monad m => m a -> ContT r m a
19:03:09 <Cale> kristof: (I'm thinking of a whole Hopf algebra)
19:03:43 <kristof> Cale: Did you mean the tensor algebra in your last example?
19:04:27 <edwardk> When F -| G, then Codensity G is isomorphic to GF, and Density F is isomorphic to FG
19:04:28 <Cale> kristof: So, yeah the exterior algebra (of alternating tensors) and symmetric tensor algebra are examples
19:04:44 <dolio> ski: I think you can define exponentiation, can't you? It's just not 'm ^ n = n (*m) 1'.
19:04:54 <dolio> You have to get into the representation.
19:04:54 <Cale> of Hopf algebras in the category of vector spaces with the tensor product as the monoidal operation on objects
19:05:26 <lingxiao> dolio: ok awesome thanks!
19:05:30 <edwardk> danharaj earwormed me with the comonad case, but i'd known the monad version, sadly, the limited palette of adjunctions from hask -> hask kind of limits the utility of this realization
19:05:34 <ski> dolio : hm, at least it doesn't fit the schema of `tau -> tau -> tau'
19:06:08 <Cale> kristof: I don't know what your background is, but you seem like you're comprehending this anyway :)
19:06:09 <ski> (unless you have higher-rank, iow)
19:06:23 <kristof> Cale: Just barely but I'm grasping enough
19:06:41 <ski> edwardk : and conversely ?
19:07:03 <edwardk> conversely?
19:07:21 <kristof> Cale: As far as programming is concerned, though, there are no interesting uses of Hopf algebras, yeah?
19:07:27 <dolio> ski: Oh, I'm thinking of predicative vs. impredicative pi.
19:07:28 <ski> edwardk : if "Codensity G is isomorphic to GF", does "F -| G" hold ?
19:07:37 <ski> edwardk : or if you add the other one as well
19:08:02 <edwardk> probably. never worked it out
19:08:12 <ski> dolio : hm, could be that's relevant here as well (or perhaps only, instead of higher-rank ?)
19:08:14 <dolio> You can define exponentiation for a predicative church numeral, even though you can't eliminate over church numerals.
19:08:20 <dolio> I'm pretty sure.
19:08:37 <Cale> kristof: I wouldn't say that, but there aren't really well-known examples. A Hopf algebra in the category of sets is a group, so maybe if you count groups, but even then, it's somewhat rare for those to appear directly in programming.
19:08:40 <ski> for untyped, sure
19:09:01 <ski> and for typed as well, but not (iirc), with a type matching the schema `tau -> tau -> tau'
19:09:12 <edwardk> well, you'll be able to define the unit/counit via codensity, so it looks like it should work
19:09:15 <ski> .. unless you use some more advanced stuff, i.e.
19:09:32 <Cale> kristof: I haven't seen the ones in the category of endofunctors (i.e. making them analogous to a monad rather than a monoid) used in programming
19:10:56 <Cale> kristof: It's basically a way to capture the idea of "things which look like groups in other categories"
19:11:22 <kristof> Cale: Unless I'm misunderstanding something, I'm just surprised that comonads and monads are useful constructs, but somehow being both does not grant a unique flexibility
19:11:47 <edwardk> kristof: being both doesn't mean that the monad/comonad structure are usefully related
19:12:08 <edwardk> non-empty lists are both, but the action of the monad and the comonad have little to do with one another.
19:12:27 <kristof> edwardk: I would say they're orthogonal to one another
19:12:41 <Cale> Well, they interact *somehow*
19:12:57 <Cale> It's just not in a way which is anything nice at the abstract level
19:13:03 <kristof> Ok.
19:13:07 <edwardk> there is this notion of a hopf algebra in linear algebra, if there was something similar relating the return/bind of the monad to the extract/extend of the comonad you'd probably have something richer.
19:14:17 <Cale> edwardk: and indeed, the Hopf algebras I was talking about were the ones where you pick up the definition from the category of vector spaces and generalise it to monoidal categories.
19:14:45 <Platyp> cool website
19:15:04 <Cale> http://www.youtube.com/watch?v=p3kkm5dYH-w -- The Catsters have a series on this
19:17:57 <ChongLi> I'm going through this: http://www.aosabook.org/en/ghc.html
19:18:07 <ChongLi> I'm finding it enjoyable and enlightening
19:18:56 <ChongLi> I wonder, how possible would it be to defer errors through each of the first few stages (parse, rename, typecheck) so that they can be collected up at once and returned to the user?
19:19:01 <mercuryrising> has anyone done the exercism haskell exercises?
19:19:27 <ChongLi> it's a bit annoying to have only one error to fix, only for more to crop up in a later stage :)
19:20:17 <Cale> ChongLi: I suspect it's pretty tricky...
19:20:48 <Cale> ChongLi: But in my experience, GHC actually does a pretty damn good job of reporting multiple usefully-different errors at the same time.
19:21:04 <dolio> ski: http://lpaste.net/98625
19:21:11 <ChongLi> Cale: yeah, I mean I get that it'd be hard to give a type error for a value that can't be found in any modules
19:21:26 <Cale> (without overreporting, where one thing goes wrong and then causes 100 other stupid errors which are really the same problem)
19:21:39 <ChongLi> and after a parse error, it's pretty hard to figure out what is supposed to be going on
19:21:39 <subleq_> \a b -> foo $ bar a b == \a -> foo . bar a    right?
19:22:26 <Cale> ChongLi: It would be nice, after finding a parse error in a definition, for GHC to be able to elide the definition entirely, and try to proceed with typechecking the rest
19:22:41 <ChongLi> Cale: yeah, that might make sense
19:22:49 <Cale> (well, and resume parsing the rest!)
19:23:08 <ChongLi> but the elision might cause errors that wouldn't exist if the parse error hadn't happened
19:23:15 <Cale> for sure
19:23:37 <ChongLi> so maybe it'd be best to replace the definition with undefined
19:23:40 <Twey> The worst thing is ‘too many errors’ syndrome, though, surely
19:23:53 <Cale> You'll get lots of stupid errors, but maybe you'll be able to do enough to be able to give some information about the types of some of the terms at least, which would be important for interactive editing.
19:23:55 <Twey> ChongLi: That can still cause errors
19:24:25 <Twey> E.G. if that thing's type was necessary to fix the type of something else
19:24:52 <ChongLi> Twey: well, what if the parse error occurs in the term but its type is intact?
19:24:53 <edwardk> cale: missed you talking about hopf algebras =)
19:25:13 <Cale> subleq_: yes
19:25:14 <ChongLi> it might still be useful enough to type check the rest
19:25:36 <augur> hopf algebras!
19:25:40 <augur> there's an episode of catsters on hopf algebras!
19:25:47 <Cale> augur: already linked it!
19:25:50 <ChongLi> oh, and I don't know why people give GHC a hard time (if they do)
19:25:51 <augur> :D
19:25:55 <ChongLi> it's pretty amazing
19:25:55 <augur> <3cale
19:25:57 <subleq_> Cale: I'm having trouble when foo = runST
19:25:59 <hopf> hmm, i chose the wrong nickname... keep getting notifications :)
19:26:02 <Cale> (actually there's like 6 or something)
19:26:10 <ChongLi> it does so much and yet it's such a small program, code-wise
19:26:16 <augur> hopf: shouldntve invented an algebra then
19:26:20 <Cale> subleq_: oh, runST's type means it interacts badly with higher order functions
19:26:31 <Cale> :t runST
19:26:32 <lambdabot> (forall s. ST s a) -> a
19:26:33 <dolio> ski: Pretty sure you can't do Ackermann that way, though.
19:26:42 <subleq_> Cale: the rankN thing?
19:26:45 <Cale> subleq_: yes
19:26:51 <Twey> ChongLi: That'd be better
19:27:00 <Cale> subleq_: GHC does not like substituting polytypes for type variables.
19:27:23 <Cale> and if runST works with ($) it's only because of an explicit one-off hack to make it work
19:27:45 <subleq_> Cale: I don't understand that statement
19:28:00 <Cale> :t (.)
19:28:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:28:08 <Cale> :t (.) runST
19:28:09 <lambdabot> (a -> forall s. ST s c) -> a -> c
19:28:17 <Cale> hm!
19:28:55 <Cale> :t (\x -> (.) x runST)
19:28:56 <lambdabot> (b -> c) -> (forall s. ST s b) -> c
19:29:18 <Cale> It's a little surprising to me that this isn't complaining :)
19:29:28 <Cale> But I recall seeing other things like this working lately...
19:29:49 <ChongLi> Haskell programs are guaranteed not to crash at runtime! (excluding FFI and exceptions, of course)
19:30:08 <Cale> subleq_: What's going on in your code?
19:30:18 <ChongLi> and unsafe stuff
19:30:21 <Cale> subleq_: also, which version of GHC?
19:30:33 <subleq_> Cale: 7.4.1
19:30:37 <Cale> ah, okay
19:30:42 <subleq_> too old?
19:30:53 <Cale> I think the above stuff which worked is something new
19:30:56 <Fuuzetsu> ChongLi: You can use this approach with most languages… Guaranteed not to crash at runtime except for the stuff that makes it crash
19:31:09 <Cale> 7.4.1 probably behaves like I'd expect, and will complain
19:31:40 <Cale> when it tries to substitute the variable 'a' or 'b' in the type of (.) for a polymorphic type like (forall s. ST s a)
19:32:15 <Cale> 7.6.x seem to be able to do this without complaint, which is honestly pretty nice!
19:32:52 <ski> dolio : *nod*, there you have the quantifier in `Nat', which enables `_^_' (iirc)
19:33:21 <dolio> ski: Right. But it's a predicative quantifier.
19:33:28 <dolio> So there are still some things you can't write.
19:33:28 <subleq_> I'm going to post the code anyway, I'd like to get some feedback
19:33:28 <ski> (namely the `n (R -> R)' part)
19:33:33 * ski nods
19:33:42 <dolio> Relative to the impredicative one.
19:34:03 <hakujin> I want to write a database library that automatically optimally pipelines requests. the database supports sending multple queries at once. right now I'm using a free monad to build an AST and I can get about 75% of the way there but I'm struggling with how to determine if the result of a function is used as input to a subsequent function
19:34:05 * hackagebot vect-floating 0.1.0.3 - A low-dimensional linear algebra library, operating on the Floating typeclass  http://hackage.haskell.org/package/vect-floating-0.1.0.3 (cdurham)
19:34:11 <Cale> subleq_: So yeah, normally you'd get a similar error when using ($) :: (a -> b) -> a -> b  with runST
19:34:31 <Cale> subleq_: but a few versions of GHC had a special case to make that work out
19:34:41 <subleq_> Cale: that's interesting
19:34:44 <Cale> Just because it was especially common and obnoxious
19:34:54 <ski> hm, i recall reading somewhere that (iirc) primitive recursion plus allowing higher-order stuff enables ackermann ?
19:35:06 <dolio> Yes.
19:35:08 * ski tries to recall the details of the claim
19:35:19 <hakujin> e.g. do { r <- query "blah"; query "blah"; r2 <- query "blah"} should send 2 http requests, one for the the first two queries and one for the last. how can I determine that the 3rd statement depends on the result of the first?
19:35:20 <dolio> ski: But, that requires you to eliminate over Nat.
19:35:24 <ski> (iow, which "higher-order" stuff ?)
19:35:52 <dolio> You build Nat -> Nat. But you can't do that with a predicative Church numeral.
19:35:59 <ski> so, not just ordinary higher-order functions, i take it ?
19:36:10 <hakujin> err... e.g do { r <- query "blah"; query "blah2"; r2 <- query $ fromBlah r }
19:36:18 <pingu> Simple ReaderT question: What am I doing wrong here? Shouldn't this totally work? http://lpaste.net/98626
19:36:28 <dolio> And I don't think you can do it with any single choice of Rs.
19:36:34 <Cale> hakujin: "Not using a monad", but I suspect you'll find that unfortunate :)
19:36:35 <ski> dolio : why can't i ?
19:36:39 <pingu> I get: Couldn't match expected type `Inner t0' with actual type `m0 a0 -> t1 m0 a0'
19:36:49 <ski> (build `Nat -> Nat', i.e.)
19:36:55 <dolio> ski: Because Nat is a Set1, but Nat quantifies over Set0.
19:37:03 <hakujin> Cale: I looked into free applicatives a bit, but I really like being able to use monad here. no dice?
19:37:07 <dolio> So you can't build things that involve Nat.
19:37:14 <dolio> By eliminating a Nat.
19:37:33 <Cale> hakujin: The trouble is that the second parameter to every >>= is a black box which you can't inspect in any way ahead of time
19:37:43 <hakujin> Cale: yep that's where I'm stuck
19:37:53 <ski> hm, and (impredicatively) instantiating `R' with `Nat' would be needed for this scheme ?
19:38:04 <Cale> hakujin: I can imagine having RULES pragmas to try to rewrite things into a form where you could do better
19:38:10 <dolio> ski: My attempts to write ackermann lead me to believe that.
19:38:21 <ski> i see
19:38:28 <Cale> hakujin: But even that's pretty tricky...
19:38:30 <subleq_> This is the first time I've had to use mutable arrays: http://lpaste.net/98627
19:39:01 <ski> .. istr Coq allowing impredicative quantification in its "propositions"
19:39:06 * hackagebot vect-floating-accelerate 0.1.0.3 - Accelerate instances for vect-floating types  http://hackage.haskell.org/package/vect-floating-accelerate-0.1.0.3 (cdurham)
19:39:11 <subleq_> I'm wondering if the way I'm doing it is good, and I'm wondering if there's a way to do it without mutability at all
19:39:12 <ski> dunno whether that would be related
19:39:40 <Cale> subleq_: btw, this is mostly just a style thing, but most people lay out if/then/else differently from that
19:39:55 <dolio> ski: Like, For ^ I can eliminate over R and R -> R to get the result. But Ackermann seems to require eliminating over infinitely many expressions in R. Which is hidden by eliminating over Nat -> Nat.
19:40:22 <dolio> Or, at least, arbitrarily many, based on one of the arguments.
19:40:25 <hakujin> Cale: I can get about 75% of the way by having 2 commands in my AST: statement (), and query [[Something]] and assuming the library users understand about the dependencies it will automatically optimally pipeline, but in a perfect word there would be only one command and it would handle everything optimally
19:40:25 <derdon> hi, I have a QuickCheck question: how do I assert that a certain error is returned?
19:40:26 <Cale> (in the old days, what you've written would have been a syntax error, but now they allow random semicolons in the middle of if/then/else just to let people do it wrong ;)
19:40:34 <subleq_> Cale: Is there a style guide for stuff like that?
19:40:37 <Cale> if foo
19:40:40 <Cale>    then bar
19:40:42 <Cale>    else quux
19:40:44 <pingu> Does *anyone* know how to make this compile? http://lpaste.net/98626
19:40:57 <Cale> or, well, any layout where 'then' and 'else' line up
19:41:02 <pingu> It's using mtl, so, magic I don't quite understand completely.
19:41:29 <Cale> (and preferably start in a deeper column than the 'if')
19:41:46 <subleq_> ok
19:42:00 <dolio> ski: Putting it that way, maybe it's possible to devise something with polymorphic recursion to accomplish it.
19:42:06 <Cale> subleq_: The golden rule is that anything which is conceptually a "sibling" should line up, and anything which is conceptually a "child" should start in a deeper column.
19:42:25 <Cale> subleq_: The *actual* rule is a lot more flexible
19:42:41 <Cale> (and doesn't explicitly mention 'if')
19:42:47 <dolio> ski: Except, that doesn't make sense, I think.
19:43:01 <L8D> @hoogle maybeRead
19:43:02 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
19:43:08 <L8D> wut
19:43:09 <dolio> You don't have polymorphic recursion.
19:43:15 <dolio> You don't have explicit recursion at all.
19:43:36 <Cale> subleq_: There's http://urchin.earth.li/~ian/style/haskell.html which is all stuff that pretty much everyone agrees about
19:43:42 <dolio> And polymorphic recursion is probably equivalent to eliminating into something with a quantifier, which you can't do.
19:43:50 <Cale> (apart perhaps from the "less than 80 columns" bit)
19:44:05 <ski> subleq_ : `runSTArray' might be interesting
19:44:06 * hackagebot oculus 0.1.0.0 - Oculus Rift ffi providing head tracking data  http://hackage.haskell.org/package/oculus-0.1.0.0 (cdurham)
19:44:14 <mgsloan> pingu: It compiles for me using ghc 7.4.2 and latest mtl
19:44:59 <pingu> mgsloan: mgsloan wow, okay. thanks.
19:44:59 <mgsloan> pingu: Err nvm, I made a stupid mistake :P
19:45:10 <ski> dolio : mhm
19:45:19 <Fuuzetsu> > tan 45
19:45:20 <lambdabot>  1.6197751905438615
19:45:22 <mgsloan> (turns out that ghci accepts empty files with no complaint :D )
19:45:26 <pingu> hah.
19:45:44 <Cale> subleq_: (but you'll also note that they state that rule as just something to strive for, even if you can't hit it all the time)
19:45:49 <pingu> Yeah. I'm thinking the deriveg MonadState is trying to lift for me or something.
19:45:52 <pingu> *derived
19:46:42 <L8D> How do I add hoogle to GHCi?
19:47:20 <Fuuzetsu> :!hoogle
19:47:38 <L8D> oh
19:48:10 <Fuuzetsu> afaik jekor made a video on how to make this more friendly
19:48:24 <Fuuzetsu> http://www.youtube.com/watch?v=QpDQhGYPqkU here
19:49:28 <hakujin> pingu: on line 17 change it to hai <- Inner. lift $ ask
19:49:43 <ski> dolio : hm, yes a polyrec primrec on `Nat's for nesting lists deeper could be `(forall a. [a] -> String) -> (Nat -> (forall a. [a] -> String) -> (forall a. [a] -> String)) -> (forall a. [a] -> String)', iiuc
19:50:11 <ski> (so that if you're called on `[a]' you can recur on `[Tree a]' or whatever you want)
19:50:14 <dolio> ski: Seems plausible.
19:50:26 <pingu> hakujin: thankyou. perfect.
19:50:36 <pingu> hakujin: um. how did you work that magic out?
19:51:08 <pingu> It's because I'm taking apart the Inner in the runInner I suppose?
19:51:17 <hakujin> pingu: the error message plus a little bit of experience
19:51:34 <pingu> hakujin: okay, thanks. It makes sense now.
19:52:11 <pingu> hakujin: having a bit of experience with this, do you prefer monads-tf or mtl?
19:52:37 <hakujin> pingu: I don't have enough experience to comment. I've never used monads-tf :)
19:53:00 <pingu> cool, I'll certainly stick with mtl now that I've gotten most of the use cases down pat
19:53:30 <hakujin> mtl & transformers are the usual go-to. either has EitherT which is nice occasionally too.
19:54:59 <pingu> hakujin: I usually write my "runMonad" methods as runMagicMonad (MagicMonad action) = runStateT action state
19:55:03 <dolio> ski: Maybe you can write a Nat1 : Set2 that computes a Nat0 : Set1 result of the ackermann function. I haven't tried that, but it seems plausible.
19:55:04 <pingu> is there another common idiom?
19:55:11 <dolio> But that's Nat1 -> Nat1 -> Nat0.
19:55:15 <pingu> I presume If I don't pattern match the MagicMonad I can just lift . ask
19:56:01 <pingu> Maybe. Actually. No. I can't get around that, can I?
19:56:14 <hakujin> pingu: yeah that's fine. alternatively you can define your newtype with a "runMonad" instance and use it in the function body rather than pattern binding in the arguments but it's all the same in the end
19:56:46 <dolio> And you can't go back from Nat0 to Nat1.
19:57:14 * ski supposes hakujin means something like `newtype TheMonad ... = MagicMonad {runMagicMonad :: ...}'
19:57:24 <hakujin> ski: correct
19:57:27 <ski> dolio : hm, interesting
19:57:47 <ski> (hakujin : i wouldn't call that "a \"runMonad\" instance", though)
19:58:24 <hakujin> I'd agree
19:58:42 <nstdloop> Can you make foldr tail recursive?
19:59:40 <L8D> How should I generate a number type that has a specified limit?
20:00:35 <Twey> :t maxBound
20:00:35 <lambdabot> Bounded a => a
20:00:41 <L8D> thanks
20:00:54 <Twey> L8D: There's a typeclass Bounded that provides minBound and maxBound; you should make your type an instance of that
20:01:08 <L8D> Twey: thanks, that's what I was looking for
20:01:11 <Twey> If you want static checking, though, you need to make a Fin type or something
20:01:30 <Twey> Okay, cool ☺
20:01:33 <L8D> I am going to set the limit to 256
20:01:44 <L8D> or 255...whatever
20:01:53 <Twey> L8D: Are you sure you don't want Word8, from Data.Word?
20:02:23 <L8D> Twey: I might. I'll look into it
20:02:28 <Twey> (unsigned wrapping eight-bit numerical value)
20:02:33 <L8D> I'm writing a brainf*ck interpreter
20:02:52 <L8D> Which uses and array of  byte-sized chars
20:03:28 <Twey> Word8 seems appropriate
20:03:49 <Twey> In a Vector or whatever, I guess
20:04:07 * hackagebot google-dictionary 0.1.0.1 - Simple interface to the google.com/dictionary API  http://hackage.haskell.org/package/google-dictionary-0.1.0.1 (mitchellwrosen)
20:04:09 * hackagebot oculus 0.1.0.1 - Oculus Rift ffi providing head tracking data  http://hackage.haskell.org/package/oculus-0.1.0.1 (cdurham)
20:04:29 <subleq_> or a two stacks, like a zipper
20:04:33 <roboguy_> nstdloop: yeah
20:04:50 <nstdloop> roboguy_: How
20:05:17 <L8D> Why doesn't someone use some reflection and implement and instance for Show (a -> b)
20:05:35 <roboguy_> nstdloop: use a function type accumulator. keep composing f x with it, where x is the current element of the list
20:05:37 <Twey> L8D: Because we don't want to break function opacity
20:06:27 <L8D> Twey: What does that supposed to mean? What is "function opacity"?
20:06:29 <roboguy_> nstdloop: I'm not sure if you'd really want to though. I don't know that you'd get too much benefit out of it
20:06:45 <nstdloop> roboguy_: I'm asking because I'm trying to implement it as a loop in non-haskell
20:07:01 <Twey> L8D: Functions are opaque: you're not supposed to be able to observe their private parts.  They're just things that do things when something's applied to them.
20:07:08 <roboguy_> nstdloop: oh, then the function accumulator might help, depending on the language
20:07:12 <roboguy_> *might not help
20:07:14 <Twey> L8D: They might be compiled blobs of binary, for example.
20:07:16 <L8D> Twey: Oh no...I'm just talking about showing the types
20:07:22 <Twey> Ah
20:07:31 <Twey> That's not really a Show instance for (a → b), then
20:07:32 <L8D> show const == "a -> b -> a"
20:07:41 <Twey> You can do that, if you like
20:07:47 <L8D> show putStrLn == "String -> IO ()"
20:07:52 <L8D> How would I implement that?
20:07:54 <roboguy_> nstdloop: here's how I'd do it in Haskell http://lpaste.net/98629
20:08:08 <subleq_> L8D: do you know :t in ghci?
20:08:13 <L8D> subleq_: yes
20:08:41 <L8D> i just hate getting a 20-line error message when I forget the type of an argument or forget an argument alltogether
20:08:46 <nstdloop> roboguy_: ooh clever, build up a huge composed function then apply it all at once
20:08:55 <simpson> L8D: That will fade with practice.
20:09:06 <hakujin> L8D: sounds like you want a better editor
20:09:08 * hackagebot oculus 0.1.0.2 - Oculus Rift ffi providing head tracking data  http://hackage.haskell.org/package/oculus-0.1.0.2 (cdurham)
20:09:59 <roboguy_> nstdloop: yep. that might be awkward in some languages though
20:12:01 <L8D> For now I'll just use: instance Show (a -> b) where show = const "λ"
20:12:32 <nstdloop> roboguy_: darn. That still hits the recursion limit in python
20:12:37 <nstdloop> was worth a shot
20:12:53 <roboguy_> nstdloop: that makes sense. python doesn't have tail call elimination
20:13:09 <nstdloop> roboguy_: I'm implementing it as a loop
20:13:24 <nstdloop> It hits the recursion limit trying to dig all the way to the bottom of 1000 nested lambdas
20:13:28 <roboguy_> ahhh
20:13:28 <dmwit> Tail recursion is for strict languages.
20:13:33 <dmwit> Guarded recursion is for lazy languages.
20:13:45 <Twey> L8D: http://lpaste.net/98631
20:14:09 <roboguy_> dmwit: except when languages don't have TCO. then I guess you mostly avoid recursion altogether, except in relatively small cases
20:14:24 <roboguy_> strict languages anyway
20:14:41 <dmwit> What I'm getting at is that the original question (can foldr be made tail-recursive?) is misguided in #haskell.
20:14:49 <roboguy_> nstdloop: your best bet is mutable state
20:14:50 <L8D> Twey: Why are all your arrows little unicode thingies
20:15:07 <dmwit> L8D: Because it's pretty. ;-)
20:15:25 <L8D> OMG
20:15:30 <L8D> I just had an awesome idea
20:15:35 <roboguy_> dmwit: well, he wanted to convert foldr to python in a way that avoids the recursion limit rather than use a tail recursive foldr in haskell
20:15:39 <nstdloop> roboguy_: If I reverse the list first or iterate through it backwards, is that going to get me foldr behavior in a strict language where the laziness issue doesn't work?
20:15:48 <L8D> Haskell -> LaTeX
20:16:09 <Twey> Because I like using the characters I mean, instead of attempting to approximate them in an outdated character set :þ
20:16:23 <dmwit> roboguy_: Hence the "in #haskell" part of my comment. This is kind of the wrong channel. =P
20:16:25 <chirpsalot> L8D: there are a lot of Haskell / LaTeX things, no?
20:16:27 <Twey> L8D: You should check out Epigram
20:16:38 <dmwit> L8D: lhs2tex exists
20:16:53 <L8D> I mean...Taking haskell code and turing it into LaTeX to look like fancy mathematical expressions
20:17:07 <dmwit> ...yes, lhs2tex exists.
20:17:07 <nstdloop> dmwit: probably, but everybody is just going to ask me why I would ever bother in #python
20:17:08 <roboguy_> nstdloop: hmm, does python provide an efficient reverse iterator? that might be the way to go
20:17:12 <Twey> :t asTypeOf
20:17:13 <lambdabot> a -> a -> a
20:17:19 <dmwit> nstdloop: That's not really our problem.
20:17:55 <roboguy_> dmwit: I wouldn't say it's *too* off-topic. it does involve Haskell code after all, which is more than can be said about some of the high-level math discussion that goes on sometimes, hah (not that I'm opposed to those topics either)
20:17:57 <dmwit> nstdloop: But I won't stop you from discussing it here. I'm self-aware enough to know when I'm just being grumpy. =)
20:17:57 <nstdloop> dmwit: It also is haskell related, considering I'm asking about getting haskell-like behavior, or as close as you can get in a strict setting.
20:18:21 <nstdloop> roboguy_: Probably. Seems like my best bet. Thanks for the help.
20:18:31 <L8D> What is the purpose of asTypeOf?
20:18:39 <roboguy_> L8D: to restrict the type of something
20:18:40 <dmwit> L8D: It predates type ascription.
20:18:47 <L8D> woah
20:19:00 <L8D> It predates (~) ?
20:19:12 <dmwit> Yes, but more to the point it predates (::).
20:19:17 <subleq_> what's type ascription? the ::?
20:19:20 <dmwit> yes
20:19:21 <dolio> ski: Trying it out, I'm thinking maybe it's not even possible then.
20:20:14 <dmwit> It's also sometimes useful for avoiding the ScopedTypeVariables extension.
20:20:21 <dmwit> If avoiding extensions is your cup of tea.
20:20:43 <roboguy_> dmwit: does ScopedTypeVariables mix with RankNTypes?
20:20:51 <dmwit> All extensions mix.
20:20:59 <dmwit> Which fact is shocking to me every time I remember it.
20:21:14 <roboguy_> really? huh, that surprises me
20:21:26 <L8D> What library should I use to make HTTP requests easier?
20:21:41 <dmwit> Everything just gets compiled to system Fc-pop anyway.
20:21:52 <dmwit> So what the heck, why shouldn't they mix? =)
20:22:03 <Twey> L8D: http://lpaste.net/98631 — you can do this without ScopedTypeVariables
20:22:35 <Twey> All extensions mix, but sometimes the mix makes Haskell (more) inconsistent :þ
20:22:58 <chirpsalot> Hmmmm. I feel like there is a neater way to do this, but I am too new to know what it is... I have a function base16decode :: String -> Maybe [Word8]. Then I have two base 16 strings str1, and str2. How would you go about xor'ing the two word by word? My solution is this: liftA2 (zipWith (fmap xor)) (base16decode str1) (base16decode str2)
20:23:02 <L8D> Twey: Cool
20:23:03 <chirpsalot> Seems a bit silly :(.
20:23:10 <subleq_> Twey: that's clever
20:23:33 <dmwit> zipWith (fmap xor `on` base16decode) str1 str2
20:23:37 <roboguy_> does anyone know about an issue with integer-gmp in GHC head?
20:23:44 <dmwit> err, no
20:23:46 <dmwit> dmwit--
20:24:03 <roboguy_> when I try to install some cabal packages, I get Failed to load interface for ‛GHC.Integer.Type’//Perhaps you haven't installed the "p_dyn" libraries for package ‛integer-gmp’?
20:24:16 <chirpsalot> dmwit: damn, that looked exactly like the kind of thing I was hoping for :P.
20:25:09 <dmwit> (liftA2 (zipWith (fmap xor)) `on` base16decode) str1 str2 -- is not obviously better, really
20:25:28 <chirpsalot> Monad stuff always seems so graceful and elegant when other people do it... Feels so awkward first hand sometimes :(.
20:25:43 <hakujin> chirpsalot: this is applicative stuff!
20:26:02 <chirpsalot> hakujin: oh crap, you're right!
20:26:15 <chirpsalot> hakujin: well I am bad at it too!
20:26:26 <chirpsalot> Practice practice.
20:26:47 <chirpsalot> dmwit: thanks. Didn't know about 'on'.
20:26:48 <Twey> on (zipWith xor) base16decode <$> str1 <*> str2 ?
20:27:07 <Twey> Not sure if I'm completely misinterpreting
20:27:48 <dmwit> Where's the package that has align as a typeclass method?
20:27:48 <mus1cb0x> speaking in terms of citation of an online or 'temporal' source of data, shall this date provided be referred to as retrieval date or access date?
20:28:07 <dmwit> ah, these
20:28:58 <dmwit> chirpsalot: make it base16decode :: String -> (Maybe `O` []) Word8 and then use alignWith. ;-)
20:29:20 <dmwit> http://hackage.haskell.org/package/these-0.3/docs/Data-Align.html
20:30:19 <jle`> does anyone have any examples of using arrow loop with lists?
20:30:22 <chirpsalot> (Maybe `O` []) o_O?
20:30:29 <jle`> as in having each element in a list recursively depend on eachother?
20:30:29 <dmwit> mus1cb0x: I didn't know there was a difference between "access" and "retrieval" dates.
20:30:46 <dmwit> chirpsalot: newtype O f g a = O (f (g a))
20:30:47 <dmwit> roughly
20:31:11 <L8D> What library should I use to make HTTP requests easier?
20:31:15 <qrada> hey, nub q.. im firing off a command via executeFile, but im doing it like so: pid <- forkProcess $ executeFile $ ...  Then, im issuing getProcessStatus False False pid afterwards.. im still getting incremental zombies, eveyr exec yields more zombies.. any idea?
20:31:32 <chirpsalot> dmwit: oh, it's like composition. Makes sense.
20:31:35 <johnw> zombies mean you aren't examing the exit status
20:31:44 <johnw> oh, I see
20:31:46 <dmwit> chirpsalot: Yes, it is type-level composition.
20:31:54 <Twey> Does getProcessStatus interleave IO?
20:31:58 <qrada> am i just doing getProcessStatus wrong then? like is my 'do chain' wrong..
20:32:06 <Twey> That would be unpleasant
20:32:13 <qrada> not sure what interleave io means sorry
20:32:23 <joe9> I am trying to figure out how to print to a terminal in reverse_video. I could not find any good documentation of vty package. wanted to check if anyone knows of any.
20:32:24 <dmwit> chirpsalot: http://hackage.haskell.org/package/TypeCompose-0.9.9/docs/Control-Compose.html#t::.
20:32:45 <Twey> joe9: http://www.termsys.demon.co.uk/vtansi.htm
20:33:01 <dmwit> joe9: The Hackage documentation looks pretty good to me...?
20:33:26 <joe9> twey, thanks.
20:33:56 <Twey> Oh yeah, there's even a reverse_video Style
20:34:14 <Twey> joe9: http://hackage.haskell.org/package/vty-4.7.0.10/docs/Graphics-Vty-Attributes.html#v:reverse_video
20:34:15 <joe9> twey, I could not figure out how to use the reverse_video Style.
20:34:16 <qrada> ah, i think getAnyProcessStatus helped.....
20:34:20 <qrada> now im down to 'one zombie'
20:34:45 <qrada> since it's not running until another exec occurs, cool, that 'temporarily fixed' it.. probably have to issue that after this interval im using to poll
20:34:48 <qrada> ok thanks ;f!
20:35:21 <Twey> joe9: All the drawing functions take an Attr
20:35:28 <joe9> twey,dmwit: how do I print a single char in reverse_video?
20:35:56 <tippenein> why does map head . group work, but map (head . group) doesn't?
20:36:18 <dmwit> Define "doesn't work".
20:36:24 <tippenein> doesn't compile
20:36:24 <Twey> joe9: char (with_style def_attr reverse_video) 'a'
20:36:31 <dmwit> :t map (head . group)
20:36:31 <Twey> Looks like
20:36:31 <lambdabot> Eq a => [[a]] -> [[a]]
20:36:38 <dmwit> tippenein: Compiles fine here. =)
20:36:53 <dmwit> tippenein: It works, it just doesn't do the same thing as (map head) . group.
20:37:02 <roboguy_> it seems like cabal doesn't work if you enable library profiling with GHC HEAD
20:37:18 <roboguy_> that's frustrating
20:37:18 <dmwit> :t (map head) . group
20:37:19 <lambdabot> Eq b => [b] -> [b]
20:37:24 <tippenein> dmwit: I see, my type signature was right, but my interpretation of map head . group wasn't
20:38:45 <dmwit> tippenein: Right; function application binds tighter than anything else except record update.
20:38:58 <tippenein> record update?
20:39:07 <dmwit> foo { bar = baz }
20:39:21 <tippenein> oh, sure.
20:39:37 <tippenein> thanks for that.
20:40:48 <joe9> twey, sorry for the bother. How do I present the resulting Image?
20:41:10 <joe9> Twey: http://codepad.org/hWT1fyIF
20:41:23 <qrada> i wrote my first 'real hs program today', not just the 99 problems ive been working on... it has LOTS of iO in it, it's just a daemon which relocates files based on if they havn't been modified in a certain time span (porting some go and node daemon over).. man it looks like a wreck.. i think trying to make it 'pretty' is going to teach me alot though.. it's already much 'simpler code' but it looks nuts.
20:42:28 <hakujin> qrada: have you used hlint before?
20:42:32 <joe9> qrada: one of the things when I started using haskell was that the programs were crazy. Then pastorn taught me how to use types and modules as much as you can.
20:42:52 <joe9> qrada: it really helps if you can break up the code into as many different modules and types as possible.
20:43:09 <joe9> then the code will be more type definitions and less actual code.
20:43:27 <qrada> hakujin: nope not yet
20:43:32 <qrada> thanks joe9, what's 'pastorn' ?
20:43:38 <qrada> someone in here or.. ?
20:44:00 <joe9> pastorn is a person who hangs out here. He is a grad student who was taught haskell at school.
20:44:41 <qrada> ya i have 3 different modules, and a bunch of functions.. but i think i have way too many functions.. i was trying to really have lots of small composable functions, whichi  still think is good? but, i think i need to take a step back and figure out how I can trim it
20:44:45 <qrada> ah
20:44:47 <qrada> cool
20:45:01 <qrada> more types less functions sounds nice
20:45:17 <hakujin> qrada: http://community.haskell.org/~ndm/darcs/hlint/hlint.htm is the manual, basically 'cabal install hlint' and then run 'hlint program.hs', substituting your program file for program.hs. it will give you suggestions on how you can improve your code.
20:45:20 <joe9> qrada: it also helps if you can paste the code. There are a lot of brilliant comments that come out of this channel.
20:46:06 <qrada> ya maye tomorrow or something ill link it.. this channel has been very helpful already
20:46:17 <qrada> cool hakujin , ill try that out for sure.. about to go do that now
20:47:18 <qrada> i cant wait to run this, it's going to bark loudly at me lmoa
20:47:23 <roboguy_> maybe I should just wait until ghc 7.8 is released...
20:49:01 <qrada> daym, hlint is dope :F
20:49:42 <chirpsalot> Twey: (zipWith xor) <$> (base16decode str1) <*> (base16decode str2) is what I have it currently nailed down to, which is close to what you suggested. Thanks :).
20:51:28 <chirpsalot> Not sure if there is a good way to pull out the base16decode... Probably. To Hoogle!
20:52:23 <dmwit> You can eliminate all of those parentheses. If you like.
20:53:00 <chirpsalot> dmwit: oh. I would like! Need more practice recognizing that. Thanks :).
20:54:13 <roboguy_> chirpsalot: I think you'd probably just end up with something like this if you try to factor out the base16decode: (liftA2 (zipWith xor) `on` base16decode) str1 str2
20:54:30 <joe9> Twey: got this working. http://codepad.org/ePbqZIVj
20:54:36 <joe9> thanks for your help. Twey.
20:54:46 <L8D> Is there anything wrong with this code? https://gist.github.com/L8D/8449655
20:54:59 <chirpsalot> roboguy_: hmmmm... Yeah :(. That seems less readable to me? Maybe best to keep it as is?
20:55:18 <roboguy_> chirpsalot: I'd probably keep it with the <$> and <*>
20:59:57 <dmwit> It's a bit odd to use both putStrLn and interact. But otherwise looks very clean to me.
21:00:07 <kazagistar> the words function almost does what I want, but I want to not separate words when they are inside of double quotes... should I recombine them at the end?
21:00:08 <dmwit> Might want to work on that optimizer, though. ;-)
21:00:29 <dmwit> kazagistar: Unfortunately, unwords . words is not id.
21:00:38 <dmwit> kazagistar: It may be time to graduate to writing a real parser.
21:00:58 <L8D> kazagistar: no
21:01:26 <L8D> Either write a parser, or split the string at double quotes and only use words on the stuff not inside the double quotes
21:01:57 <L8D> > break (== '"') "foo bar baz \"quux\""
21:01:59 <lambdabot>  ("foo bar baz ","\"quux\"")
21:02:18 <L8D> Do some kind of loop around that
21:02:19 <chirpsalot> unwords . words == replace all whitespace with single spaces?
21:02:24 <raphie> how do I derive show for a type synonym? type Fn = Float -> Float deriving Show doesn't work
21:02:33 <dmwit> chirpsalot: correct
21:02:43 <dmwit> raphie: can't
21:02:45 <roboguy_> raphie: you don't
21:02:58 <raphie> how should I print a string representation of it then?
21:03:04 <dmwit> raphie: But see the universe package, for example.
21:03:10 <dmwit> raphie: Almost certainly you shouldn't.
21:03:18 <L8D> dmwit: Is there any faultpoints of the optimizer besides what's described in the comment?
21:03:23 <raphie> dmwit: why not?
21:03:24 <kazagistar> I mean, I just want to take a string "hello there \"cool dude\" yay" and make a string ["hello", "there", "\"cool dude\"", "yay"]... L8D's suggestion seems right
21:03:29 <roboguy_> raphie: well, for one thing you can't make a non-trivial Show instance for a function type
21:03:34 <enthropy> updateLookupWithKey differing between IntMap and Map is devious
21:03:37 <roboguy_> regardless of it being a type synonym
21:03:42 <raphie> oh, true
21:03:47 <dmwit> raphie: Because there's a bloody lot of Floats.
21:03:54 <dmwit> roboguy_: false
21:03:58 <enthropy> for no sane reason it seems
21:04:00 <dmwit> roboguy_: See, e.g., the universe package. ;-)
21:04:01 <roboguy_> dmwit: well, practically speaking
21:04:12 * hackagebot ihaskell 0.3.0.2 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.3.0.2 (gibiansky)
21:04:34 <roboguy_> I imagine any method would be really inefficient
21:04:48 <subleq_> L8D: you can convert the common idioms for zeroing a cell, adding two cells, etc into higher level operations
21:04:52 <dmwit> L8D: Iterating the refinement step until it terminates is probably a pretty slow way to do things. (It will duplicate a lot of work if most of the program can't be refined further.)
21:05:22 <dmwit> L8D: And, as subleq_ is mentioning, there's a lot of fun stuff you can do to make the refine step itself more effective.
21:05:49 <L8D> Oh, I understand
21:06:10 <erisco> length = getSum . foldMap (const $ Sum 1) -- not sure why this is not in Data.Foldable
21:06:13 <L8D> I've just never done static analysis in Haskell
21:06:42 <roboguy_> raphie: if you want to make type class instances for a type synonym, it should probably be a newtype. or you could make a separate function to show it, if that's all you want
21:06:51 <subleq_> L8D: here's a list of some idioms: http://esolangs.org/wiki/Brainfuck_algorithms
21:07:11 <dmwit> I had fun designing a monoid for brainfuck optimization once, but got kind of bored with it before it did anything really useful.
21:07:30 <subleq_> how does brainfuck optimization form a monoid?
21:07:32 <dhrosa> how do qualified imports interact with record syntax? If I have a type data Test = {foo :: Bool} in a module  that is imported qualified as T, can I still pattern match on T.Test {foo = myFoo}, or would it have to be   T.Test {T.foo = myFoo} ?
21:07:50 <dmwit> the latter
21:07:51 <L8D> subleq_: I think I'm planning on setting up a static analyser that will look at which cells are being modified to what extent in each block of code, so I could then optimize those
21:07:59 <dhrosa> record fields should be unambigious :/
21:08:17 <dmwit> There have been several proposals for type-directed name resolution or similar things.
21:08:37 <dhrosa> are there any extensions for this in ghc?
21:08:41 <L8D> subleq_: What monoid?
21:08:50 <dmwit> They generally are either too complicated, too vague, or cover too few of the use cases to get implemented.
21:09:01 <subleq_> L8D: for dmwit
21:09:05 <roboguy_> subleq_: good question, I'm curious too
21:09:09 <dmwit> subleq_: A brainfuck program is a monoid; mappend combines two optimized programs into a larger optimized program.
21:09:44 <dmwit> I'll just paste some code. It's probably easier that way.
21:09:55 <subleq_> yeah, i'd be interested to look at it
21:10:24 <dmwit> http://lpaste.net/98633
21:10:34 <roboguy_> dmwit: makes sense since it's almost concatenative
21:11:42 <joe9>  with haskell vty, there is a set_cursor_pos. But, I cannot find a get_cursor_pos. Any suggestions on how to get that, please?
21:11:45 <dmwit> Perhaps the most relevant bit is data BF = BF Int (Zipper Word8); instance Monoid BF
21:12:10 <dmwit> The idea of that is that BF Int (Zipper Word8) gives a motion and a bunch of additions to do to the memory cell.
21:12:39 <dmwit> So e.g. +++>+++>+++ would be move right 2, and add three to each of three cells, i.e. roughly BF 2 [3,3,3].
21:13:34 <dmwit> Maybe a better example is +++>+>++, which would be roughly BF 2 [3,1,2] or something like that.
21:13:37 <dmwit> anyway
21:14:21 <dmwit> It's easy to spot loops that stay in one spot during the loop body this way, for example.
21:14:59 <dmwit> joe9: I'm not sure terminals have a way to query the current position.
21:15:49 <subleq_> they do, it's not pretty though
21:18:55 <td123> hello, I'm trying to understand how some of yesod persistent works, and I've come upon this type signature: UserId :: typ ~ KeyBackend SqlBackend User => EntityField User typ , could someone explain what that tilde means?
21:19:53 <roboguy_> td123: it's the type equality operator
21:23:04 <roboguy_> it means that typ is KeyBackend SqlBackend User. I'm not really sure why it would be used there, but then I'm not too familiar with it's uses
21:23:18 <dmwit> Perhaps UserId is a constructor of a GADT.
21:24:18 <dmwit> ...which are just a nice DSL for type equalities and existential types. ;-)
21:25:46 <roboguy_> I'm still not sure I understand why you couldn't do the substitution in a GADT constructor
21:27:42 <joe9> dmwit: ok, thanks.
21:28:26 <pavonia> > return 123 :: (Int ~ i, [] ~ m, r ~ m i) => r
21:28:27 <lambdabot>  [123]
21:29:49 <td123> hmm, I guess that's good to know :)
21:30:12 <randomclown> ~~~~~
21:31:07 <ski> td123 : (assuming it's really `UserId :: forall typ. typ ~ KeyBackend SqlBackend User => EntityField User typ', which i suppose it would have to be), it's equivalent to `UserId :: EntityField User (KeyBackend SqlBackend User)' -- at least in case `KeyBackend' is an ordinary type, or `KeyBackend' is a `type'/`data' family (or associated `type'/`data') that is known to be defined from those two particular arguments
21:32:11 <mgsloan> Yeah, KeyBackend is a data family
21:32:29 <mgsloan> Errrr
21:32:31 <mgsloan> it used to be
21:32:37 <mgsloan> :D
21:33:19 <mgsloan> Nvm, EntityField is the one that's a datafamily
21:33:43 <ski> i'm not sure exactly how `~' interacts with `type'/`data' families (or associated `type's/`data's), but i suspect that in the presence of those, you couldn't always substitute away in `forall a. a ~ F T => ..a..'
21:34:49 <ski> (namely in the case where `F T' is not known to be defined, possibly one couldn't do the substitution)
21:36:35 <mgsloan> Right, in this case nothing tricky is going on, though since KeyBackend is a newtype (which represents a key for a particular backend / entity)
21:38:20 <prooftechnique> What do you think of this for an lpaste script? http://lpaste.net/2144562687986630656
21:38:40 <prooftechnique> Any obvious things I can improve (other than adding comments, I suppose)
21:38:44 <prooftechnique> ?
21:39:25 <roboguy_> prooftechnique: you should avoid fromJust
21:40:09 <roboguy_> > let Just x = Nothing in x
21:40:10 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
21:40:12 <roboguy_> > fromJust Nothign
21:40:13 <lambdabot>  Not in scope: data constructor `Nothign'
21:40:13 <lambdabot>  Perhaps you meant `Nothing' (imported from Data.Maybe)
21:40:14 <roboguy_> > fromJust Nothing
21:40:15 <lambdabot>  *Exception: Maybe.fromJust: Nothing
21:40:28 <roboguy_> prooftechnique: note that fromJust gave no information about the code line that failed
21:40:51 <prooftechnique> Mmm, that's a good point. I'll throw a pattern match on that, then.
21:41:06 <erisco> I am trying to get this: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)
21:41:23 <erisco> and am stumbling around without much intuition
21:42:44 <erisco> oh nevermind, got it
21:42:56 <enthropy> :t \x y -> ((<$>) (<*>) x) <*> y
21:42:57 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
21:42:59 <erisco> I was using liftA and forgot that <$> was binary
21:43:06 <erisco> :t liftA2 (<*>)
21:43:07 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
21:43:39 <kazagistar> assuming I have a string, what would be the best way to try if it is possible to read it as a int or float?
21:43:51 <prooftechnique> roboguy_: I changed it to use fromMaybe and give a useful error. Better? :D
21:43:54 <roboguy_> kazagistar: read or reads probably
21:44:04 <roboguy_> prooftechnique: yep, I think so!
21:44:33 <enthropy> readMaybe
21:44:39 <enthropy> from Text.Read
21:46:29 <kazagistar> thanks enthropy, that seems right
21:51:07 <hkr> Where can I get a starter guide to haskell ? I don't know any other language other than python.
21:51:41 <gienah> @where lyah
21:51:41 <lambdabot> http://www.learnyouahaskell.com/
21:53:09 <hkr> Thanks a lot lambdabot
21:53:16 <ChongLi> hkr: lambdabot is a bot :)
21:53:20 <hkr> Not sure if a bot
21:53:24 <hkr> ok ChongLi Lol
21:53:26 <ChongLi> gienah is the one you should be thanking :)
21:53:51 <hkr> Okay, thanks ginmaniac
21:53:55 <hkr> shit. gienah
21:54:05 <ChongLi> hahaq
21:54:11 <gienah> :)
21:54:17 <hkr> :D
21:57:27 <hkr> Haskell is interpreted right ?
21:57:38 <ChongLi> both
21:57:38 <hkr> I'm a total noob. Just asking. :\
21:57:46 <ChongLi> ghc compiles it
21:57:47 <hkr> both ? how does that work ?
21:57:47 <nisstyre> hkr: "interpreted" is a tricky word
21:57:58 <ChongLi> but ghci uses a bytecode interpreter
21:58:02 <nisstyre> there are different ideas of what it means
21:58:12 <hkr> ChongLi: Okay.
21:58:14 <ChongLi> ghc is meant for deployment, ghci for interactive development
21:58:29 <hkr> Whats deployment?
21:58:35 <nisstyre> most modern languages that have interpreters are really some kind of bytecode interpreter
21:58:37 <nisstyre> as ChongLi said
21:58:48 <nisstyre> and they might do some native code generation
21:58:51 <hkr> nisstyre: Dont you mean compiler ?
21:58:55 <ChongLi> compiling your program to a binary application and then instalilng it somewhere, such as a target machine
21:58:59 <nisstyre> hkr: yes I would call it a compiler
21:59:01 <hkr> Okay thanks a lot.
21:59:08 <nisstyre> I'm just explaining why some people call them interpreters
21:59:15 <hkr> Okay.
21:59:20 <nisstyre> e.g. the most popular version of python is actually a compiler
21:59:25 <ChongLi> programs compiled by ghc are statically linked by default
21:59:26 <hkr> What??
21:59:30 <nisstyre> it compiles your code to a bytecode and runs it in a VM
21:59:36 <hkr> Python is interpreted...?
22:00:01 <subleq_> hkr: see, it's not quite so clear cut
22:00:03 <nisstyre> hkr: just forget about "interpreters" for now
22:00:24 <subleq_> ghc does produce native binaries
22:00:41 <subleq_> but you can also play around in a repl
22:00:42 <nisstyre> hkr: how your code gets run is usually not so important
22:00:48 <ChongLi> Haskell has all the advantages of an interpreter (with ghci) but also has extremely fast native binaries
22:00:52 <nisstyre> unless you're relying on specific optimizations or things like that
22:00:53 <hkr> Okay...
22:01:01 <ChongLi> so don't worry about performance
22:01:06 <hkr> :D
22:01:12 <ChongLi> just focus on learning and having fun :)
22:01:23 <hkr> Thanks a lot guys :)
22:01:41 <ChongLi> and if you get stuck or frustrated, make sure to ask questions in here
22:02:03 <ChongLi> learning Haskell in some ways is like starting over again as a programmer
22:02:16 <ChongLi> it's not like going from python to ruby or something
22:02:23 <simpson> ChongLi: I respectfully disagree.
22:02:31 <hkr> okay.
22:02:34 <simpson> If you have an ML in your background, it's not that different.
22:02:38 <simpson> Or a Lisp, to some extent.
22:02:48 <nisstyre> ChongLi: I've been told that new programmers learn Haskell much easier than people with some experience, and the newbies have a much easier time of it than e.g. Java
22:02:50 <edwardk> ChongLi: it is more like AD&D 2nd edition dual classing.
22:02:58 <nisstyre> the second part isn't surprising
22:02:58 <ChongLi> simpson: right, but hkr only has experience with Python
22:03:02 <simpson> ChongLi: I could probably get away with saying to you, "Learning FORTH in some ways..." and you'd not be surprised.
22:03:03 <ChongLi> I was responding directly to that
22:03:09 <cwraith> edwardk: so you keep your hitpoint total?
22:03:20 <edwardk> ChongLi: eventually you get to enjoy the benefits of both skillsets, but it takes a while
22:03:28 <edwardk> cwraith: that too. =)
22:03:31 <hkr> I'll be learning java in college soon. Need to learn haskell within a couple of months...
22:03:35 <ChongLi> edwardk: yeah, that's a great point
22:03:58 <nisstyre> hkr: it's good you're looking at Haskell then, you'll be able to intelligently criticize Java
22:04:16 <edwardk> glad i decided to take those levels of code warrior first. those d10 hit die are valuable in the later game.
22:04:24 <simpson> ChongLi: Python has first-class functions, good garbage collection, extensive tutorial documentation, and a package manager, so I'd say that Python's a much better preparation than the traditional C++/Java education! >:3
22:04:58 <ChongLi> simpson: well, you're definitely right there
22:05:15 <ChongLi> I was mainly referring to the issue of state
22:05:17 <simpson> I see so many people twitch uncontrollably when they first see first-class functions or GC.
22:05:33 <ChongLi> which in my experience seems to frustrate people at first
22:05:36 <nisstyre> simpson: is Python's GC really that good? Better than Ruby's I guess...
22:05:49 <ChongLi> the most recent example I went through on here was with Walther
22:06:05 <simpson> nisstyre: PyPy's is extremely good; CPython's is mediocre but rarely invoked due to reference counting.
22:06:10 <erisco> Twey, hmm not sure if :. can be a Monad
22:06:20 <nisstyre> simpson: does it fall back to mark/sweep or something when refcounting fails?
22:06:22 <ChongLi> he was trying to translate a highly-imperative version of Dawkins' weasel to Haskell
22:06:23 <simpson> IronPython and Jython leverage their VMs' GCs.
22:06:56 <simpson> nisstyre: I only remember that it's non-generational, mark-and-sweep, uses arenas of homogenous objects for primitives, and can move things.
22:07:08 <simpson> Oh, and I *think* it's not Boehm/libgc.
22:07:08 <ChongLi> edwardk: hey, did you see the proggit post on Cache-Oblivious Search Trees?
22:07:19 <edwardk> nope
22:07:30 <ChongLi> http://www.reddit.com/r/programming/comments/1vc5xu/cacheoblivious_search_trees/
22:07:49 <ChongLi> I haven't had a chance to look at the actual linked papers yet
22:07:57 <subleq_> simpson: wait, are you talking about cpython?
22:08:03 <ChongLi> so I don't know how relevant they'll be
22:08:12 <edwardk> oh that approach
22:08:16 <simpson> subleq_: Yes. Did I get anything wrong? I haven't looked at the code in eons.
22:08:19 <edwardk> yeah that has crossed /r/systems before
22:08:37 <ChongLi> are these mutable data structures?
22:08:45 <edwardk> yes
22:08:50 <subleq_> simpson: they call it a cycle detector. it is generational, not mark and sweep, and is nonmoving
22:09:11 <ChongLi> and probably not amenable to a persistent implementation?
22:09:14 <edwardk> i prefer to the cache oblivious streaming b-tree / structures package approach
22:09:23 <subleq_> the reason for most of those things is the c api, they don't have much room for anything
22:09:25 <edwardk> i already hit the same asymptotics as it and am persistent ;)
22:09:44 <erisco> anyone know if   newtype (:.) f g a = O (f (g a))  can be a Monad? it seems impossible
22:09:56 <edwardk> the approach they take there is a dead end to me
22:10:02 <ChongLi> ahhh, okay
22:10:08 <edwardk> but the asymptotics can be realized by other means
22:10:29 <ChongLi> I figured you'd probably already explored this stuff
22:10:53 <edwardk> yeah PMAs are a useful building block, but not good for persistence
22:10:53 <triliyn> erisco: not in general; you need a function commute :: f (g a) -> g (f a) I think
22:10:55 <apples> erisco, it can if you have a function f (g a) -> g (f a)
22:10:55 <simpson> subleq_: Yeah, you're right. Looks like three generations, no nursery. I could have sworn that there was moving and pinning; I must be thinking of PyPy.
22:10:59 <subleq_> simpson, nisstyre, here's an overview of the algorithm http://www.arctrix.com/nas/python/gc/  https://mail.python.org/pipermail/python-dev/2000-March/002385.html
22:11:10 <nisstyre> subleq_: thanks for the info
22:11:30 <erisco> triliyn, apples is there a type class set up for this?
22:11:39 <subleq_> that article is very old, but i did recently read some of the code and it's still mostly accurate
22:12:23 <apples> not that i know of
22:12:29 <edwardk> the COSB trees that came out of that group can be generalized into very nice structures. they also came up with the 'fractal trees' that back tokudb and maintain really high throughput and don't 'age' as badly as regular b-trees.
22:13:03 <ChongLi> that's really cool
22:13:04 <triliyn> erisco: there's not one in prelude (and maybe not even in base), but I wouldn't be surprised if it existed somewhere
22:13:06 <apples> erisco, but this is the distributive law between monads: http://en.wikipedia.org/wiki/Distributive_law_between_monads
22:13:57 <edwardk> the approach i described in my succinct data structures talk can be viewed as a variant on the bentley-saxe dynamization scheme that is used underneath the COSB tree, repurposed to work with wavelet trees rather than flat arrays
22:14:14 <ski> hkr : "interpreter" is different from "interactor", and "compiler" is different from "batched"
22:14:17 * hackagebot attoparsec-enumerator 0.3.2 - Pass input from an enumerator to an Attoparsec parser.  http://hackage.haskell.org/package/attoparsec-enumerator-0.3.2 (JohnMillikin)
22:14:24 <ChongLi> ahhh, that's really cool
22:15:05 <ChongLi> would wavelet trees themselves be useful as a small library for Haskell?
22:15:08 <ChongLi> seems like they might
22:15:19 <edwardk> they'll wind up in my succinct package eventually
22:15:28 <ChongLi> that'll be great
22:15:28 <edwardk> that was what github.com/analytics is all about
22:15:51 <edwardk> kind of got distracted, but it'll pick up eventually =)
22:15:52 <ChongLi> wow, you got lucky with that name
22:16:19 <edwardk> i asked github for it and they were nice enough to take it back and give it to me
22:16:20 <ChongLi> ooh, Datalog-style EDSL!
22:16:38 <ChongLi> ahhh, I guess whoever was previously using it was dormant?
22:16:42 <edwardk> same with github.com/lens
22:16:54 <ChongLi> that's really cool of them
22:17:02 <ski> hkr : the 2007-07-14 entry "Summarizing several issues with compilation and interpretation" in Riastradh's blag at <http://mumble.net/~campbell/blag.txt> (RSS <http://home.ccil.org/~cowan/blag.xml>) might be interesting
22:17:06 <ChongLi> it'd be much harder if it were domain names
22:17:10 <edwardk> never hurts to ask
22:17:39 <ChongLi> and I guess they know who you are and that you're not just messing around
22:17:45 <edwardk> yeah. domain names are more expensive =)
22:17:50 <hkr> ski I'll check out all these later.
22:18:20 <edwardk> wound up with rebase.org and coinductive.com for the project along with a couple dozen others, but we'll see if i ever use them
22:18:20 <hkr> Right now, I need to learn a functional lang and C
22:18:45 <hkr> and I choose haskell first and C second because someone told me to...
22:18:49 <ChongLi> edwardk: it's almost like you're at the point where you could use a staff
22:19:16 <edwardk> trick is finding a way to pay them ;)
22:19:43 <ChongLi> that's always the issue
22:20:00 <edwardk> right now i mostly suborn them into helping maintain things by giving away commit access, but too many people have caught on to my wiley ways
22:20:22 <levi> Has anyone hooked haskell-mode up to -XTypeHoles yet?
22:20:39 <edwardk> levi: good question. don't know
22:20:42 <ski> hkr : fine
22:21:07 <ChongLi> yeah, it'd be nice to have a little tiny bit of that Agda goal-directed programming magic
22:21:19 <ChongLi> it seems like a really nice workflow
22:21:39 <c_wraith> seems better when the compiler automatically inserts things that fit.
22:21:41 <edwardk> ChongLi: you have been able to 'fake' holes for a while with ImplicitParams
22:21:46 * ski misses Alfa with automatic hole-filling
22:22:04 <edwardk> > length ?wut
22:22:05 <lambdabot>  mueval-core: internal error: PAP object entered!
22:22:05 <lambdabot>      (GHC version 7.6.3 for x86_64_unknown_linux)
22:22:05 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
22:22:11 <edwardk> bah
22:22:12 <ski> @botsmack
22:22:13 <lambdabot> :)
22:22:25 <ChongLi> I've been doing a bit of rudimentary stuff with undefined and ghc-mod type
22:22:28 <ski> @ghc
22:22:28 <lambdabot> yi-static: internal error: TSO object entered!
22:23:34 <ChongLi> hey, would there be any use for a structure based on unordered-containers HAMTs but without the hashing part?
22:23:42 <ChongLi> that is, a Clojure-style persistent vector
22:23:59 <ChongLi> at least, that's my understanding of how they work
22:24:07 <Dacto> Is there a cleaner way of mapping putStrLn over an IO [String]  than using (<- in do notation) and 'IO [String] >>= (\x -> mapM_ putStrLn x)'?
22:24:08 <c_wraith> ChongLi: you can consider it a sparse array, and then all the sparse array use cases apply
22:24:15 <levi> Idris appears to have nifty type-hole auto-programming now too.
22:24:58 <c_wraith> Dacto: that lambda is entirely useless verbosity
22:25:17 <c_wraith> Dacto: foo >>= mapM_ putStrLn
22:25:29 <kazagistar> I want to do something like map, but have the ability to make changes to Map as a "side effect", should I use a monad or something? I am just learning the basics...
22:26:02 <ChongLi> in Clojure people tend to avoid using lists wherever possible since they can efficiently conj stuff onto their vectors
22:26:11 <erisco> Twey, well I think the module is quite successful
22:27:54 <levi> Dacto: BTW, turning '\x -> f x' into 'f' is sometimes called 'Eta reduction' and if you use hlint, it will tell you about places where you could do it.
22:29:19 * hackagebot purescript 0.2.15 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.15 (PhilFreeman)
22:30:23 <Dacto> Ah thanks c_wraith and levi
22:38:30 <NemesisD> is it not possible to document what particular instances of a typeclass do?
22:38:54 <NemesisD> nobody does it and it boggles my mind that so many people could have such capacity for cruelty
22:40:16 <silasm> NemesisD: I practicaly wrote an essay reprimanding myself for breaking the monad laws (didn't end up using the instance). Does that count?
22:41:15 <zRecursive> Husk-scheme seems work now. However, huski seems not to mainipulate multi-lines ?
22:41:18 <silasm> still a little confused that there doesn't seem to be a typeclass for something like (a -> a -> Reader s a) forming a monoid.
22:41:50 <silasm> (I did make one myself)
22:42:38 <NemesisD> silasm: peace be unto you
22:43:08 <silasm> oh monoid, monoid, not monad.
22:43:12 <NemesisD> i'm looking at the Validation library by tony morris and then diving into a bunch of libraries like semigroups
22:43:39 <NemesisD> i noticed each of these have tons of defined instances with not a stitch of doucmentation about the semantics for each concrete type.
22:43:45 <zRecursive> @where husk-scheme
22:43:45 <lambdabot> I know nothing about husk-scheme.
22:43:54 <NemesisD> how is someone supposed to use that?
22:44:03 <zRecursive> @google husk-scheme
22:44:04 <lambdabot> Plugin `search' failed with: user error (https not supported)
22:44:34 <silasm> NemesisD: what are you looking up Semigroups for?
22:45:09 <silasm> everything I've seen uses Monoid even when it seems like it could use Semigroup.
22:47:26 <NemesisD> silasm: http://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html peep that laundry list of typeclass instances
22:49:37 <silasm> yeah I can see how that'd be frustrating D:
22:51:17 <supki> NemesisD: why would you document an instance if it does not break any laws?
22:51:49 <silasm> supki: if it's something like the list monad which could be made an instance in different ways?
22:52:05 <silasm> that's definitely a compelling reason.
22:52:33 <levi> There's a handy src link.
22:54:22 * hackagebot purescript 0.2.15.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.15.1 (PhilFreeman)
22:54:24 * hackagebot HaskellNet-SSL 0.2 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2 (DanielWright)
22:54:28 <NemesisD> supki: it isn't always obvious what the instance does
22:54:35 <NemesisD> other than not break laws
22:56:07 <levi> Well, it does tell you what the instances do.
22:56:13 <levi> They accumulate errors.
22:57:22 <NemesisD> i just don't get the aversion to practical examples
22:58:55 <hkr> You can't change the value of a variable in a purely functional programming language ?
22:59:15 <levi> hkr: Nope.
22:59:27 <hkr> levi Can I or can I not ?
22:59:30 <hkr> lol
23:00:12 <NemesisD> you cannot
23:00:24 <hkr> Okay. Functions cannot change it either right ?
23:00:29 <levi> hkr: When you say x = 3, you can't later say x = 4. The '=' means the two things are equivalent.
23:00:46 <NemesisD> hkr: think of it as functions produce new values
23:01:00 <levi> You can, however, introduce a new variable also named x in some other scope with a different value.
23:01:05 <NemesisD> functions aare not modifying their arguments, they are producing new values
23:01:56 <levi> NemesisD: I'm not understanding what your confusion is with the Validation library.
23:02:39 <hkr> So if I make a variable x = 9, there is no way to increment it or change it ?
23:02:52 <hrah> there's no need to increment it or change it, either
23:02:54 <levi> Functions map input values to output values. Saying that they 'produce' them might be misleading.
23:03:08 <hrah> you have to think about problems a bit differently than in an imperative language
23:03:36 <NemesisD> levi: i don't understand how i could use it
23:03:37 <hkr> Okay.
23:03:57 <hkr> Maybe I'll understand when I learn more haskell...
23:04:02 <kazagistar> ok, so I think I get it... I have to mapM using the State Map monad...
23:04:15 <levi> hkr: You might want to start with 'Learn You a Haskell'
23:04:21 <levi> If you haven't found it already.
23:04:39 <hkr> levi: I've been suggested that book in here :)
23:05:29 <kazagistar> hkr, the = sign does not mean assignment, it means equality in a much more mathematical way
23:05:50 <NemesisD> levi: just looking through the typeclasses to see 1 that would make practical sense for the use case i have in mind
23:06:25 <hrah> yea, think of the equals sign as "is"
23:06:30 <supki> NemesisD: Validation is Either that accumulates errors instead of shortcutting on the first Left
23:06:38 <levi> NemesisD: Well, you'd use it like you would Either, but you'd have to use a type at one of the instances as your error parameter.
23:07:23 <supki> NemesisD: so I doesn't have a useful Monad instance but you can use Applicative to combine as many errors as you can
23:08:24 <NemesisD> hmm
23:08:43 <supki> you probably want NonEmptyList as an error parameter
23:08:50 <supki> not sure why it does not reexport it
23:08:58 <Aetherspawn> @src foldl
23:08:58 <lambdabot> foldl f z []     = z
23:08:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:09:16 <Aetherspawn> @src foldr
23:09:16 <lambdabot> foldr f z []     = z
23:09:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:09:43 <NemesisD> hmm so what instance would i want to use for something like applying a list of validations
23:10:38 <NemesisD> supki: ah good point
23:13:26 <levi> NemesisD: The type exists to be a return type for validation functions, which you would use instead of something like Either.
23:15:42 <NemesisD> i like that the semigroups version of nonempty has a :| instead of |:. Makes my code look bummed out to be consing
23:15:51 <zRecursive> e
23:16:35 <shachaf> A constructor can't be named |:
23:18:50 <kazagistar> let me rephrase my question from a while back... does there exist something like a foldlWithState :: (a -> b -> (a, b)) -> a -> [b]
23:19:06 <kazagistar> sorry, I mean mapWithState
23:19:23 * hackagebot libjenkins 0.3.0.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.3.0.0 (MatveyAksenov)
23:20:06 <shachaf> :t mapAccumL
23:20:07 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:20:34 <shachaf> I'm not sure I understand the type of your function.
23:20:44 <kazagistar> doh, I see what I did wrong
23:20:51 <kazagistar> and why hoogle didn't find it lol
23:21:57 <kazagistar> I forgot to input the list, and expected to throw away the accumulator (which would be a super silly implementation)
23:22:11 <shachaf> You can also get it via mapM/traverse using State.
23:24:17 <shachaf> :t \f a xs -> runState (traverse (state . f) xs) a
23:24:18 <lambdabot> Traversable t => (a -> s -> (b, s)) -> s -> t a -> (t b, s)
23:24:22 <shachaf> Something like that.
23:24:30 <NemesisD> i'm confused, i've got an AccValidation (NonEmpty String) (), but i can't do v1 <> v1 (with <> from semigroups)  i get the error no instance for (Semigroup (AccValidation (NonEmpty String) ())), but AccValidation supposedly has Semigroup e => Semigroup (AccValidation e a)
23:25:15 <shachaf> You should @paste your full code and full error.
23:25:30 <shachaf> If your full code is too long, extract a minimal test case from it.
23:28:17 <NemesisD> shachaf: http://lpaste.net/98634
23:30:17 <shachaf> If I answer "according to what you said, it sounds like it should", will that help?
23:30:39 <NemesisD> i don't want to be told i'm right :P
23:30:46 <shachaf> That file isn't enough to reproduce it.
23:31:02 <NemesisD> it isn't?
23:31:17 <shachaf> Not without installing some random package.
23:32:10 <shachaf> You should apply the usual debugging strategy, which in this case means things like "define your own copy of AccValidation with the same instance and see if it still fails" and "check in ghci whether AccValidation actually has that instance" and "get rid of all the extra functions and things in this file that aren't really relevant to the issue".
23:32:51 <NemesisD> oh, yes it require semigroups and Validations. this is the documentation which states Semigroup e => Semigroup (AccValidation e a) http://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html
23:33:33 <shachaf> Are you sure you're using the right version of Validation, and the right version of semigroups, and that they're using the right version of each other?
23:33:58 <shachaf> Doing the things I suggested would be a big hint if that happened not to be the case (not that I know).
23:34:15 <NemesisD> so in ghci would :i tell me the implied instances?
23:34:35 <NemesisD> i don't know if there's a better term for them
23:35:00 <shachaf> The usual term is just "instance"
23:35:22 <shachaf> It happens to have a constraint but that's not all that relevant most of the time.
23:36:19 <NemesisD> hmm, how could i get what package ghci is getting a constructor from?
23:36:33 <shachaf> I don't know. Try asking it to be verbose?
23:36:45 <NemesisD> you may be onto something here in that there's a NonEmpty package and the one defined in semigroups and both use the same module name
23:38:41 <shachaf> An easy way to find that out would be to use a type other than NonEmpty.
23:39:34 * ski . o O ( refinement types )
23:39:59 <shachaf> That entire test file could be replaced with one line or so: foo = let { x :: AccValidation String (); x = success () } in x <> x
23:40:34 <NemesisD> hmm, i used package imports and specified semigroups for my import of Data.List.NonEmpty
23:41:57 <NemesisD> shachaf: you're right. from that i get No instance for (Data.Semigroup.Semigroup (AccValidation String ())))
23:44:17 <NemesisD> man this is weird. it is being selective about instances when I run :i AccValidation. i see the instance Monoid e => Moinoid (AccValidation e a), but no semigroup anywhere
23:44:45 <shachaf> Maybe you don't have semigroups imported.
23:44:52 <shachaf> Or maybe you have multiple versions of semigroups installed.
23:45:26 <shachaf> Keep applying the usual debugging strategy until you find out what's going on.
23:45:30 <NemesisD> i guess its really not safe to do anything outside of cabal
23:45:36 <NemesisD> cabal sandbox time
23:45:48 <shachaf> I've never used cabal sandbox.
23:46:09 <levi> The only thing you imported from Data.Semigroup was <>
23:46:21 <NemesisD> OH
23:46:26 <NemesisD> not instances duh
23:46:50 <shachaf> Instances are automatically imported.
23:47:00 <shachaf> You can't not import instances.
23:47:07 <shachaf> You can't not be on a boat.
23:47:08 <NemesisD> oh. damn
23:47:52 <shachaf> But you didn't import the class, so maybe ghci wouldn't print the instance.
23:48:03 <levi> The Semigroup instance for NonEmpty appears to be commented out in the source.
23:48:53 <rose> \msg schahaf you around?
23:49:08 <levi> Maybe it's provided by Semigroup now?
23:49:10 <NemesisD> levi: oh no. wonder why that is. the docs are misleading then
23:50:03 <shachaf> hi rose
23:50:10 <levi> Oh, yes, it's provided by Semigroup now.
23:51:15 <NemesisD> i still don't understand  why this isn't working but i have little hope that debugging it at this hour will be fruitful
23:51:35 <NemesisD> also installing everything in a cabal sandbox failed with a type error while installing Store
23:52:33 <levi>  Beats me.
23:52:41 <zRecursive> @hoogle haskline
23:52:42 <lambdabot> No results found
23:54:50 <jle`> what is "Use import export shortcut"?
