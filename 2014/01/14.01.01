00:02:40 <dibblego> thanks
00:04:35 <bitemyapp> dibblego: I linked Clojure's juxt (effectively the same as sequence) as a means of showing an example where you might not have provided a compelling reason for having monads to a Lisper.
00:04:56 <bitemyapp> it would also be a bit misleading if they were trying to understand the point of monads in terms of sequence.
00:04:57 <dibblego> bitemyapp: I would not call this function sequence
00:05:03 <bitemyapp> there are better examples out there.
00:05:34 <bitemyapp> dibblego: well fine, but sequence is implemented in terms of foldr and return.
00:05:51 <bitemyapp> dibblego: you might be a little too high on the ladder to understand why many might not see the difference.
00:05:58 <dibblego> sequence specifically abstracts on the monad type
00:06:06 <dibblego> sure, maybe
00:06:15 <bitemyapp> dibblego: I understand that, but the way you described it isn't going to explain anything to anybody.
00:06:17 <dibblego> if twitter allowed more constructive discussion, I'd have made that clearer
00:06:20 <dibblego> right
00:06:30 <bitemyapp> dibblego: there are ways to better explain monads in 140 characters.
00:06:39 <dibblego> I don't want to explain monads
00:06:41 <bitemyapp> sequence isn't a good place to start.
00:06:50 <dibblego> I want to explain what it means to me, when you say "I understand monads"
00:06:56 <dibblego> I think sequence is a great place to start
00:07:08 <dibblego> twitter is not a great place to start
00:07:11 <bitemyapp> dibblego: the thing is, you don't need monads to accomplish the same objectives as sequence.
00:07:24 <bitemyapp> at least not from a typical programmer's perspective.
00:07:40 <dibblego> you need at least Applicative
00:07:53 <dibblego> an important objective is that you write it once, for every monad
00:07:54 <bitemyapp> Not really.
00:08:12 <dibblego> how might I achieve all the objectives as sequence without it?
00:08:19 <dibblego> that clojure code does not meet the objectives
00:08:21 <dibblego> it is not sequence
00:08:44 <bitemyapp> It matters if you're trying to express in terms of some reified-to-the-type-system structure, but if all you want is a HOF that takes functions and returns a list of results for each input then all you actually need is a fold.
00:09:02 <dibblego> but I don't
00:09:04 <bitemyapp> dibblego: the problem here is you're being obtuse and it's not going to help you if you encounter somebody Haskell naive.
00:09:11 <dibblego> I want that function to also take Maybe and State s
00:09:27 <bitemyapp> dibblego: you spend a lot of time marketing to the other side of the fence on Twitter and I'm trying to help you do a better job of it in future.
00:09:32 <dibblego> I am specifically asserting that this point is important — the most important
00:09:44 <dibblego> I don't really market on twitter — twitter is not useful for helping people imo
00:09:50 <bitemyapp> if you're working in an impure FP language, there is no distinction to be made.
00:09:54 <dibblego> yes there is
00:10:07 <dibblego> I think you might be missing the important point
00:10:14 <dibblego> pure or not is completely irrelevant
00:10:20 <bitemyapp> I'm not, I'm explaining how your way of thinking about it is completely alien to most programmers.
00:10:21 <dibblego> abstracting on the type constructor is entirely the point
00:10:28 <dibblego> how might you express this important point otherwise?
00:10:47 <dibblego> but I didn't explain anything, other than "what is required before taking the position seriously"
00:10:48 * hackagebot simple-session 0.7.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.7.0 (AmitLevy)
00:10:48 * hackagebot simple-postgresql-orm 0.7.0 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.7.0 (AmitLevy)
00:10:53 <bitemyapp> sequence wouldn't be the first place I'd start.
00:10:56 <dibblego> I did not explain, "this is how to understand monads"
00:10:58 <bitemyapp> probably Maybe instead.
00:11:05 <dibblego> I explained, "this is how I test that you understand monads"
00:11:20 <dibblego> I think you are a) answering a different question b) not answering it correctly
00:12:00 <dibblego> I have sat down with hundreds of people and had them understand the purpose of "monad" in just a few hours, by having them write sequence for 3 or 4 monads, then ask the question, "how do we fix this code repetition?"
00:12:02 <bitemyapp> I am approaching it from a different angle, most certainly.
00:12:08 <araujo> containers and sequences are certainly two of the common beginner's explanations for monads
00:12:09 <dibblego> but again, this is a completely different question now
00:12:20 <bitemyapp> dibblego: that's a great approach and something you should document.
00:12:35 <dibblego> if you can show me a more efficient way, then great, but be aware that I have probably tried it and I will disagree
00:12:48 <dibblego> it is documented
00:12:54 <bitemyapp> dibblego: your approach? where?
00:12:55 <dibblego> https://github.com/NICTA/course
00:13:05 <dibblego> plus a few bits in our heads
00:13:19 <bitemyapp> dibblego: I've been using a variety of methods to teach monads lately. Some more effective than others.
00:13:33 <dibblego> bitemyapp: yes, it is not easy and lots of failures to be had
00:13:34 <bitemyapp> dibblego: part of the challenge is that I have to make it relatable to people that think they know "FP" but actually have been using untyped langs.
00:13:50 <dibblego> right, deleting supposed knowledge — always hard
00:13:57 <bitemyapp> and it's a bit jarring when you think you've been doing "FP" but have in actuality been missing out on 95% of it.
00:14:03 <dibblego> yes agree
00:14:16 <dibblego> I use my psychology degree more than computer science, when in this situation
00:14:29 <bitemyapp> dibblego: I come from a Lisp background originally, Lispers are smart but difficult to teach sometimes.
00:15:00 <dibblego> I work with a persistent clojure programmer who is coming to terms with this, but he is young and easy to teach
00:15:00 <shachaf> I suggest that #haskell-overflow is better for this argument.
00:15:05 <dibblego> shachaf: agree
00:15:19 <bitemyapp> shachaf: I don't think it's an argument, but duly noted.
00:38:35 <Aetherspawn> does anyone keep logs of #haskell?
00:38:54 <Aetherspawn> How big (in mb, say) are the logs for #haskell for the last year or so.
00:39:06 <dv-> Aetherspawn: /topic
00:39:29 <Aetherspawn> I meant local logs, sorry. I want to know the size, not browse them
00:40:03 <Aetherspawn> although, that is a heuristic. 500kb a day, thanks.
00:40:58 <dv-> mine is 56mb and it starts on jan 29 2013
00:43:04 <Aetherspawn> cool, thats much less than I expected.
00:43:08 <Aetherspawn> I calculated about 180mb.
00:48:36 <augur> Aetherspawn: my logs go back to may 2008 and are ~535mb
00:48:50 <Aetherspawn> :S
00:48:52 <Aetherspawn> thats a lot.
00:48:58 <augur> is it?
00:49:02 <augur> lets see
00:49:21 <augur> thats ~2000 days
00:49:40 <augur> or 268kb a day
00:49:46 <augur> average over 5.5 years
00:50:27 <augur> which is actually less than what you calculated
00:50:32 <augur> by quite a lot!
00:56:00 <JuanDaugherty> mine go back to '06 or 5 but i'm to lazy to du em and their under different nicks
00:56:08 <JuanDaugherty> *too
00:56:18 <JuanDaugherty> *they're
00:57:07 <bjorkintosh> keeping logs for the lulz?
00:57:20 <JuanDaugherty> maybe further ; there was a breach when the logs went their current location
00:57:42 <JuanDaugherty> from tunes or whatever
00:57:52 <mm_freak> Aetherspawn: for 2013 i have 2.0M lines, 164.2 MiB
00:57:52 <JuanDaugherty> i.e the public ones
00:58:17 <jtcwang1> happy new year guys!
00:58:36 <dv-> depends on the client too. i have it ignore everything except messages
00:59:00 <mm_freak> --- Logging started: 07/06/28 12:00:39 (4)
00:59:02 <JuanDaugherty> jtcwang1, I wait for the 31st
00:59:10 <mm_freak> so june 2007
00:59:22 <mm_freak> 1012 MiB total
01:00:14 <mm_freak> which is interesting
01:00:24 <jtcwang1> hey guys, i'm trying to do a margingale strategy simulator
01:00:26 <jtcwang1> http://lpaste.net/97821
01:00:31 <jtcwang1> this is one of the functions
01:00:34 <mm_freak> i have a total of 2.6 GiB logs, going back to 1999
01:00:37 <JuanDaugherty> bjorkintosh, if you meant me, I don't see a reason to delete irc logs ever
01:00:48 * hackagebot coordinate 0.0.3 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.3 (TonyMorris)
01:00:51 <mm_freak> #haskell accounts for about a third of this
01:00:53 <jtcwang1> part of the logic is that if i don't have enough to take the next bet i stop
01:01:22 <jtcwang1> basically the function is generating a list of BetRecord
01:01:38 <augur> interesting. ive got 2 gigs with haskell as 1/4
01:01:40 <augur> hm!
01:02:13 <mm_freak> oh, i should note that my old logs are compressed
01:09:25 <augur> dibblego: hello!
01:09:31 <dibblego> hello augur
01:10:15 <augur> dibblego: im @psygnisfive
01:10:44 <dibblego> oh yeah something about something on twitter?
01:10:50 <augur> so what i meant by imperative was specifically implicit effects
01:11:00 <dibblego> maybe #haskell-overflow too?
01:11:17 <augur> as opposed to reifying them into a type-system with nice functional interpretations
01:12:16 <mm_freak> oh, and…
01:12:25 <mm_freak> happy Succ 2013 everyone
01:12:50 <augur> haskell's "imperative" content is all through factoring through a relatively nice (conceptually speaking) barrier
01:14:15 <augur> i think to some extent it's kind of deceptive to say that haskell _really_ is imperative, and in an important sense it's just false
01:14:29 <dibblego> I think quite the contrary
01:14:56 <dibblego> it is important to acknowledge the correct definition of imperative programming (i.e. programming imperatively), to prevent lots of confusion
01:14:57 <augur> which isnt to say there's no sense in which it can be made true, but it requires a quite real redefinition
01:15:12 <dibblego> It requires a strict and useful definition
01:15:23 <augur> requires and has arent the same thing
01:15:45 <augur> i can give it a precise definition, but that wont be the definition programmers generally use
01:15:47 <dibblego> (to prevent misinformation)
01:15:53 <bjorkintosh> haskell? imperative?
01:15:56 <bjorkintosh> who said that?
01:15:58 <dibblego> they use a confused non-definition
01:16:02 <dibblego> it is important to correct them
01:16:12 <augur> dibblego: well, they may use a confused non-definition
01:16:20 <augur> but that doesnt matter
01:16:23 <dibblego> yes, and this confusion halts learning progress
01:16:24 <augur> that is _the_ definition
01:16:30 <augur> when you like it or not
01:16:32 <dibblego> no, it is confusion, not a definition
01:16:37 <augur> it doesnt matter
01:16:46 <dibblego> whether I like or not, it is not a definition (I would in fact, like it if it was a definition)
01:16:59 <augur> it doesnt matter, dibblego
01:17:14 <augur> if you go to a java programmer and say "haskell is imperative!"
01:17:16 <dibblego> ok, yes, the non-definition is a definition and this doesn't matter (WTF?)
01:17:16 <augur> you're just lying
01:17:24 <augur> what you mean is
01:17:25 <dibblego> I would never say such a thing
01:17:33 <dibblego> I don't care if a language is imperative
01:17:35 <augur> "haskell is imperative in this very specific sense that i've invented"
01:17:54 <dibblego> no, I mean this expression exploits imperative programming in exactly the sense that imperative programming means
01:17:57 <augur> but if you're going to invent a definition, even a sensible one
01:18:00 <bjorkintosh> i thought haskell was purely ... non-imperative :)
01:18:04 <dibblego> I am not inventing anything, you are
01:18:16 <augur> thats demonstrably false
01:18:23 <dibblego> and this is fine on its own, but in practice, it has pretty bad consequences
01:18:39 <dibblego> http://apocalisp.wordpress.com/2011/05/30/imperative-vs-functional-programming/
01:18:42 <augur> you want to redefine (or even define) a term that is already in common practice
01:18:46 <augur> er
01:18:47 <augur> in common use
01:18:54 <dibblego> I cannot progress while you believe this thing
01:19:07 <dibblego> you will just keep saying it I assume
01:19:10 <augur> you already said that the word is primarily used in a fuzzy, meaningless sense
01:19:15 <dibblego> No I didn't
01:19:21 <augur> yes you did
01:19:31 <augur> now you're lying in full view of the entire channel
01:19:31 <dibblego> I said there are confused people and there are people who use the appropriate definition of imperative programming
01:20:18 <augur> you said that programmers generally use a confused non-definition
01:20:39 <dibblego> I will not be baited anymore, thanks bye
01:20:58 <augur> thats what you said, dibblego
01:21:19 <augur> i will happily quote five minutes ago but i dont think that's necessary, since its only a few lines up
01:21:21 <dibblego> yes, exactly as you replayed it back — that's what I said, yep
01:21:44 <augur> <dibblego> they use a confused non-definition
01:21:49 <augur> do you deny saying that?
01:22:01 <dibblego> I am finished with you, thanks
01:22:05 <augur> yes or no, dibblego
01:22:09 <augur> do you deny saying that
01:22:10 <dibblego> not even no
01:22:18 <augur> and who is "they" there, dibblego
01:22:56 <augur> well. that was fun.
01:23:10 <bjorkintosh> the romulans, of course.
01:23:11 <bjorkintosh> who else?
01:23:22 <shachaf> Hmm, looking at the channel, this does look excessive.
01:23:25 <shachaf> Er.
01:24:19 <augur> shachaf: ?
01:26:37 <jle`> omg i just changed half of my program from monadic to pure/functional and everything feels so much cleaner
01:27:39 <augur> lol
01:37:16 <augur> i dont understand how someone could get into the position of being so ideological about programming :\
01:38:02 <augur> oh dibblego is back
01:38:47 <iglootree> augur, it is not ideology; it is craftmanship.
01:39:35 <augur> im not sure what sort of craftmanship involves denying things youve just said when it turns out they imply things you dont like
01:40:13 <iglootree> degeneration starts by usimg terms anc concepts inappropriately; gradually you end up losing your art because you can't reason in it.
01:41:01 <augur> i agree with that
01:41:21 <iglootree> augur, I do not see that in my logs, perhaps I am missing something; but still...
01:43:46 <alan1> hello world
01:43:54 <augur> hello!
01:44:28 <benmachine> augur: the thing is, if a person says something apparently self-contradictory, the helpful response is not really "ha! how do you explain THAT!!"
01:44:48 <iglootree> people sjould not confuse monads with gonadscand monoids with steroids just because they rhyme to domething more approachable
01:44:58 <augur> i dont think i responded like that, benmachine
01:45:16 <iglootree> my android chat client sucks
01:45:54 <benmachine> augur: you said he was lying, and (it seemed to me) demanded an explanation
01:46:37 <iglootree> that is a really strong use of words
01:46:46 <augur> benmachine: i said he was lying about what he said, which is certainly true
01:47:05 <iglootree> quote please, of said statement
01:47:13 <dibblego> guys, can we take this to #haskell-blah please?
01:47:18 <benmachine> augur: it's unlikely, it's more likely he was either mistaken about what he said, or misunderstood you
01:47:41 <benmachine> dibblego: I don't care enough about it to continue it there, but it's not like there's much else going on here
01:47:46 * benmachine shrug
01:47:54 <iglootree> yup
01:48:00 <benmachine> I should probably eat this year, haven't done that yet
01:48:05 <augur> lol
01:48:19 <benmachine> iglootree: p.s. if you want to see quotes, there's a link to logs in the topic
01:48:31 <iglootree> benmachine, I stackoverflowed....
01:48:59 <iglootree> my android client sucks very much, damn.
01:49:08 <jle`> do you guys prefer (==) x or (== x) ?
01:49:58 <Cale> Or (x ==) ? :)
01:50:09 <Cale> I'd probably use (== x)
01:50:27 <augur> i think i'd use (x ==)
01:51:04 <Cale> Just from a reading standpoint, (== x) reads nicely in English
01:51:49 <alan1> so, i'm learning haskell and have read lyah up to ch7 and RWH up to ch3, can i program any projects like a raytracer without any knowledge of monads? the main function looks simple enough...
01:51:55 <augur> Cale: do you think so?
01:51:56 <Axman6> yeah, I prefer (== x) for that reason
01:52:10 <augur> i like (x ==) because it looks nice with map, etc.
01:52:18 <Axman6> filter [all those that] (== x)
01:52:25 <augur> given how map is supposed to be some kind of lifting
01:52:28 <Cale> alan1: Go for it and see where/if you get stuck!
01:52:48 <augur> Axman6: true, for filter its nice
01:53:41 <Axman6> alan1: most of it should be fine, if you want to write images or read in scene data you'll need a little IO, but you should be able to get a long way without it. You should also be able to parallelise it quite simply =)
01:53:48 <alan1> Cale: usually i get a really good feel for the language by just programming a project in the language, but coming from C++ and lua, haskell is just like wut
01:54:02 <dv-> but filter keeps the elements matching the predicate, not keep them
01:54:20 <Axman6> C++ and lua are just wut to me. C++ is especially mentally defective
01:54:23 <Cale> alan1: Well, yeah, you kind of have to expect it to be like relearning how to program
01:54:24 <dv-> er, filter them*
01:54:37 <Axman6> dv-: you filter the water to keep the water, not the dirt :P
01:55:30 <jtcwang1> hey Cale, how would i copy the error msg from ghci?
01:55:51 <Cale> jtcwang1: Select the text in your terminal and paste it into lpaste.net?
01:57:06 <jtcwang1> let's say i have a value a
01:57:29 <jtcwang1> i have a function that requires [A] where A is type of a
01:57:37 <jtcwang1> can i do func [a]
01:57:43 <jtcwang1> it doesn't seem to be working
01:57:52 <jtcwang1> i tried both a:[] and [a]
01:58:03 <Axman6> the latter should work
01:58:27 <Axman6> the former should work with brackets: (a:[]), but [a] is just sugar for that
01:58:45 <Axman6> so your error is probably something else
01:59:27 <jtcwang1> yeah
01:59:31 <jtcwang1> i see
01:59:45 <iglootree> augur, you did not side with the actual meaning of the terms you use; dibblego was referentially transparent you simply had side effects all over the place in your discussion with him. I just read the logs.
01:59:48 <jtcwang1> so how would we debug a haskell programme?
02:00:04 <Axman6> jtcwang1: well, errors are the best place to start. what's the error say?
02:00:15 <augur> iglootree: what?
02:00:16 <augur> lol
02:00:23 <jtcwang1> sec lemme put them onto lpaste
02:00:24 <philed> jtcwang1: If it type-checks, it works >:(
02:00:33 <philed> Debugging is heresy.
02:01:18 <jtcwang1> philed, it runs, my logic is flawed somewhere i think
02:01:29 <jtcwang1> i'm getting empty list errors
02:01:36 <iglootree> at times our dislike towards what we hear augur, makes us throw exceptions...
02:02:23 <augur> iglootree: in this case im throwing a type error :)
02:02:47 <benmachine> throwing exceptions is such an aggressive thing to do, maybe Python had the right idea with "raise"
02:02:58 <iglootree> but as wiener said, you don't have to dislike an idea, it also has to be wrong; remember that.
02:03:08 <jtcwang1> http://lpaste.net/97821
02:03:17 <jtcwang1> error is empty list
02:03:23 <augur> iglootree: who what
02:03:39 <jtcwang1> i'm trying to write a martingale simulator
02:04:13 <iglootree> http://en.wikipedia.org/wiki/Norbert_Wiener
02:04:29 <augur> ok, now what are you saying about him/in reference to him?
02:04:31 <benmachine> jtcwang1: there's nothing wrong with having empty lists, but using head on them causes problems
02:04:49 <jtcwang1> benmachine, yeah that's my problem, it shouldn't be empty
02:04:53 <dibblego> jtcwang1: where does simulate guarantee that it returns non-empty lists?
02:04:55 <jtcwang1> so the logic is probably flawed
02:05:02 <iglootree> laterz
02:05:07 <jtcwang1> cya
02:05:31 <jtcwang1> so what do you guys use for debugging?
02:05:35 <jtcwang1> just ghci?
02:06:10 <augur> benmachine: now see, this is an example of being confused -- i have no idea whats going on in this conversation anymore. lol
02:07:04 <benmachine> jtcwang1: debugging? all my programs are perfect first try!
02:07:06 <benmachine> (joking)
02:07:23 <jtcwang1> benmachine, well that's what i'm trying to achieve
02:07:34 <jtcwang1> that's why i'm here in the first place :P
02:07:36 <aristid> benmachine: indeed, i bet they are only perfect once they typecheck
02:07:41 <benmachine> aristid: :P
02:07:48 <benmachine> jtcwang1: ghci is a pretty good tool, yeah
02:07:55 <benmachine> also unit tests, sometimes
02:07:56 <dv-> you can use Debug.Trace.trace to print stuff in pure functions
02:08:02 <benmachine> quickCheck is great for finding failures I can understand
02:08:14 <jtcwang1> ok
02:08:18 <jtcwang1> i'll look into them in the future
02:08:24 <jtcwang1> thx
02:08:49 <philed> jtcwang1: Where does your simulate function return a non-empty list?
02:09:07 <philed> Looks like all your base-cases return []
02:09:40 <jtcwang1> but shouldn't (Win:rs) or (Lose:rs) run first?
02:10:10 <jtcwang1> since i've provided nonempty parameters
02:10:37 <benmachine> jtcwang1: sure, but they only call simulate again
02:10:37 <philed> Yeah, but you never return a non-empty list.
02:10:56 <jtcwang1> ahh
02:10:58 <benmachine> jtcwang1: a call to simulate either turns into another call to simulate, or an empty list
02:11:04 <jtcwang1> right
02:11:05 <benmachine> so either it loops forever or returns []
02:11:20 <jtcwang1> ok let me think
02:11:54 <jtcwang1> oh its on line 43
02:11:58 <jtcwang1> i should be returning the whole list
02:12:02 <jtcwang1> instead of []
02:12:04 <jtcwang1> lol
02:12:11 <jtcwang1> lemme try changing that
02:13:01 <jtcwang1> ok i don't get the error anymore, now i just need to debug the logic
02:13:32 <philed> jtcwang1: You got the exception, though? You're failing on a call to head, and you've only got one of those, on line 24, and "simulate ..." is the thing that doesn't have a head.
02:13:40 <jtcwang1> any suggestion to make my code more 'haskelly' is welcome!
02:14:30 * benmachine has previously written similar code that extremely elaborately calculated an empty list
02:14:31 <jtcwang1> philed, i changed line 43 to return the whole list
02:14:52 <jtcwang1> so in the case where i run out of money to bet, i just return all the results
02:15:14 <jtcwang1> i can probably do some tail optimisation with line 41 and 50
02:15:38 <philed> jtcwang1: Sounds good. Just hoping that the exception GHCi threw was helping at least somewhat :)
02:16:12 <jtcwang1> yeap it was haha
02:16:21 <jtcwang1> probably the easiest ones to find
02:16:38 <jtcwang1> ctrl-f []
02:17:04 <benmachine> jtcwang1: re haskelliness, we try to avoid "head" wherever possible
02:17:12 <benmachine> many people think the fact that it is in the Prelude is a mistake
02:17:21 <jtcwang1> oh ok
02:17:27 <jtcwang1> what should I use instead?
02:17:31 <benmachine> well, that depends
02:17:42 <Cale> Usually, pattern match
02:17:48 <Cale> Or use higher order functions
02:18:09 <benmachine> if your function really does always return a nonempty list and this is obvious from its structure, you can modify it so that it shows that in the type
02:18:23 <benmachine> well, ok, pattern-matching is the simplest
02:18:33 <Cale> Well, that would be the one case where I think head is okay
02:18:46 <Cale> things like  map head . group . sort  are pretty much fine
02:19:05 <benmachine> Cale: sure, but I'm also fond of functions that return (a, [a]) instead of just [a]
02:19:15 <benmachine> but possibly that's just me
02:19:31 <Cale> (Obviously it would be better if it were easier to reflect that sort of thing in the type, but sometimes it makes the program awkward)
02:19:55 <philed> Cale: concatMap (take 1) . group . sort wouldn't throw errors. An important question is whether a non-empty list is a logic error.
02:20:09 <philed> And then there's another question: should you be throwing away the tail of the list anyway?
02:20:13 <Cale> philed: map head . group . sort already can't throw errors
02:20:40 <Cale> because group will never produce an element of its resulting list which is empty
02:21:04 <Cale> and that's a standard idiom for finding the unique elements of a list
02:21:12 <benmachine> jtcwang1: http://lpaste.net/5187489155403218944
02:21:14 <philed> Ah yes. Didn't look at the stuff after head.
02:21:15 <Cale> > map head . group . sort $ "mississauga"
02:21:16 <lambdabot>  "agimsu"
02:22:15 <jtcwang1> benmachine, thanks. I'm still trying to remember the syntax for guards etc
02:22:45 <jtcwang1> but yeah my programme is working fine
02:22:46 <benmachine> jtcwang1: guards are the things that start with |
02:22:52 <jtcwang1> yeap
02:22:55 <dv-> you can take the putStrLn out and do putStrLn (case ...
02:22:59 <jtcwang1> like i used to do function =
02:23:02 <benmachine> dv-: also true
02:23:03 <jtcwang1>     |
02:23:05 <jtcwang1> but that was wrong
02:23:09 <jtcwang1> its function
02:23:15 <jtcwang1>      |   (no =)
02:23:21 <jtcwang1> so yeah i'm getting there
02:23:26 <jtcwang1> haskell is so readable though
02:23:32 <benmachine> jtcwang1: yeah, I did that when I was starting as well, I think
02:23:50 <Cale> Trivia: guards used to occur after the function body
02:24:04 <jtcwang1> example Cale?
02:24:09 <Cale> but they were moved to the other side because knowing the condition is rather important, and code could be long
02:24:15 <Cale> like
02:24:19 <jtcwang1> oh i see
02:24:25 <Cale> f x = 1 | x > 0
02:24:34 <jtcwang1> yeah i agree with the change
02:24:34 <Cale>       0 | x == 0
02:24:38 <Cale> etc.
02:24:49 <Aetherspawn> I'd write (== x)
02:25:03 <jtcwang1> haskeller inventors love their math eh
02:25:23 <jtcwang1> is (x ==) and (== x) equivalent?
02:25:28 <Cale> jtcwang1: almost
02:25:40 <Cale> (x ==) is the partial application (==) x
02:25:50 <Cale> (== x) means (\y -> y == x)
02:26:28 <Cale> Since you usually expect that x == y if and only if y == x (i.e. you expect equality to be a symmetric relation), they're pretty much equivalent.
02:26:30 <jtcwang1> i can't seem to grasp why (x ==) won't give you an error
02:26:41 <jtcwang1> is it cause it assumes you're using it in infix form?
02:26:47 <Cale> It's an operator section
02:26:50 <Cale> Like (2 *)
02:26:58 <Cale> > map (2 *) [1..10]
02:26:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
02:27:15 <benmachine> it's a special thing, it's not handled the same way as other parenthised expressinos
02:27:20 <Cale> > map (100 +) [1..10]
02:27:21 <lambdabot>  [101,102,103,104,105,106,107,108,109,110]
02:27:27 <Cale> yeah
02:27:35 <jtcwang1> yeah its like (3 `plus`)
02:27:38 <jtcwang1> yeah?
02:27:40 <Cale> yes
02:27:51 <Cale> Which could also be written  plus 3
02:28:07 <augur> Cale: now see, thats what i like
02:28:12 <jtcwang1> so with self-defined operators you'll do something like (3 `(===)`)
02:28:13 <augur> map with arg-then-op
02:28:14 <jtcwang1> right?
02:28:32 <Cale> no
02:29:04 <Cale> Drop the parens and backticks
02:29:09 <Cale> (3 ===)
02:29:21 <jtcwang1> it automatically assumes infix form?
02:29:36 <Cale> Anything whose name is composed of symbol characters is automatically infix
02:29:36 <FireFly> All operators are "infix by default" unless you parenthesize them
02:29:42 <Cale> Putting parens around an infix operator makes it prefix
02:29:52 <FireFly> == infix, (==) prefix. foo prefix, `foo` infix
02:30:04 <Cale> Putting backticks around a *non* infix function name will make it infix
02:30:29 <jtcwang1> i see so any custom operator is infix by default
02:30:39 <Cale> yeah, and you can define them like that too
02:30:49 <jtcwang1> i see
02:31:00 <Cale> > let x $#@ y = x^2 + y^2 in 3 $#@ 4
02:31:01 <lambdabot>  25
02:31:45 <Cale> It's not something that you really want to go overboard with (*cough* lens *cough*), but sometimes it can be nice.
02:32:00 <jtcwang1> haskell strikes me as very similar to using vim
02:32:12 <Cale> oh?
02:32:18 <jtcwang1> it has a lot of 'plugins'
02:32:26 <jtcwang1> the more plugins you can utilize the better you become
02:32:37 <jtcwang1> more efficient*
02:32:53 <jtcwang1> from stuff like map
02:32:55 <kqr> both vim and haskell has a high skill ceiling
02:32:57 <jtcwang1> to lens
02:32:59 <kqr> there's a lot to learn
02:33:04 <jtcwang1> yeah
02:33:06 <kqr> i guess is the thing to take away from that
02:33:13 <jtcwang1> idk about vim though
02:33:26 * Cale doesn't bother to deal with vim's skill ceiling.
02:33:28 <jtcwang1> i've been using it for almost 2 months now
02:33:34 <Cale> (or any editor's for that matter)
02:34:05 <jtcwang1> vim's default feature is pretty comprehensive already
02:34:26 <jtcwang1> i wouldn't really call installing a plugin 'raising my skill ceiling'
02:34:32 <jtcwang1> but i guess writing a plugin counts
02:37:26 <kqr> i was more thinking about the learning experience
02:37:52 <kqr> you can spend a lot of time learning about ever cooler features in vim – more so than many other editors
02:38:44 <jtcwang1> yeah
02:38:48 <Cale> (Until you spend more time thinking about which command to use to accomplish something than it would take to just have done it by hand ;)
02:39:15 <jtcwang1> kqr i swear i spend 1/4 of my time customizing vim
02:39:29 <jtcwang1> for the first 2 weeks of my new work
02:39:31 <jtcwang1> haha
02:39:47 <AshyIsMe> i like having a vimannoyances.md file
02:39:49 <jtcwang1> cuz i was starting with vim as well as new work
02:39:53 <latermuse> cale: eventually you get to know the commands that are used in your personal workflow and dont need to think anymore
02:40:00 <AshyIsMe> anything that i feel like tweaking i can just put straight in there as a reminder to do it later
02:40:05 <AshyIsMe> when im finished with productive stuff
02:40:08 <jtcwang1> AshyIsMe, are you me?
02:40:10 <Cale> latermuse: I get by with very very little
02:40:21 <jle`> jtcwang1: you can imagine something like (3 ==) taking in a value to go in the 'missing' position on the right. just a mneumonic
02:40:34 <AshyIsMe> jtcwang1: i dunno, do you have vimstickies.md for notes you're trying to remember too? :P
02:40:53 <kqr> jle`, is a mneumonic a mnemonical pneumonic?
02:41:07 <jtcwang1> AshyIsMe, i have pen and paper
02:41:20 <jtcwang1> but i also have an abbreviation that let's me edit my vimrc
02:41:23 <jle`> kqr: :P
02:41:39 <jtcwang1> so minor things i just add it in
02:41:57 <AshyIsMe> <leader> ev  - edit my vimrc,  <leader> es - edit my vimstickies.md,  <leader> ea - edit my vimannoyances.md
02:42:00 <AshyIsMe> heh
02:42:18 <Cale> dd, /, :%s, :s thing with visual mode, insert, escape, :w, :q, typing stuff.
02:42:28 <Cale> That's about as much as I need from vim
02:42:58 <jtcwang1> DAE map their esc to something else
02:43:19 <jtcwang1> i just map it to jk/kj. one of the best decisions i've made
02:43:20 <kqr> tab
02:43:26 <kqr> is great as well
02:43:34 <kqr> and colon to semicolon
02:43:36 <jtcwang1> i use tab for indenting stuff in normal mode
02:43:48 <kqr> shift-tab indents for me
02:44:04 <kqr> because most often my editor knows how to indent the next line anyway
02:44:39 <dv-> haskell seems hard to indent properly
02:44:47 <dv-> i spend a lot of time fixing the formatting in haskell-mode
02:44:47 <jtcwang1> it is my experirence
02:45:05 <dv-> in something like C you just press tab and it's perfect
02:45:15 <Cale> dv-: I never liked any of the indent modes in emacs
02:45:20 <jtcwang1> C is easy to indent
02:45:28 <Cale> I just want tab to insert 2 spaces
02:45:56 <jtcwang1> do you always use 2 space cale?
02:46:20 <Cale> Well, I use the tab key as a faster version of the spacebar
02:46:26 <DigitalKiwi> emacs lua mode is(or at least was) 3 spaces
02:46:30 <DigitalKiwi> super crazy
02:46:34 <Cale> I indent by whatever's needed to make things line up
02:46:41 <jtcwang1> right
02:46:47 <kqr> i don't indent haskell code most of the time, i align it
02:46:59 <jtcwang1> my first day i'm already wishing there's a way to line up the = signs for let blocks
02:47:07 <AshyIsMe> sounds like something we could make into a vim plugin
02:47:20 <jtcwang1> AshyIsMe, :P
02:47:32 <jtcwang1> there is a haskell indent plugin
02:47:34 <jtcwang1> i got it now
02:47:37 <jtcwang1> its pretty good
02:48:08 <jtcwang1> Bundle 'merijn/haskellFoldIndent'
02:48:32 <jtcwang1> i don't think it has got into my way yet
02:48:39 <jtcwang1> its just sometimes you need to indent yourself
02:48:41 <Cale> I'm mildly interested in Chris Done's structural mode for emacs, but I don't know. I'm really not convinced that it does what I want. It does appear to deal with code blocks properly when you make edits that cause them to move, which is something I've wanted for a while.
02:48:58 <Cale> But the rest of it is kind of strange, and I'm not convinced it's actually helpful.
02:49:32 <jtcwang1> idk for haskell i think some stuff are impossible to guess right
02:49:47 <jtcwang1> such as let blocks
02:49:58 <jtcwang1> you never know whether there are other variables you want to define
02:50:19 <kqr> you do if you use the {;}-syntax
02:50:28 <kqr> or indent properly the first time
02:50:51 <Cale> Well, that's why his structural editing mode lets you move up a level by pressing ) so that it knows where you want to go next
02:50:58 <Cale> But I find that really unnatural, personally
02:51:04 <jtcwang1> if i type let var = blablabla
02:51:17 <jtcwang1> how would you know whether i want to define another variable kqr?
02:51:27 <jtcwang1> that's what i'm referring to
02:51:38 <jtcwang1> an you use {} for let?
02:51:51 <jtcwang1> oh i see that's what you were talking about
02:51:57 <jtcwang1> i totally ignored the {} around ;
02:52:01 <jtcwang1> nvm me
02:52:09 <kqr> let { var = bla; another = bloop; }
02:52:10 <kqr> kinda
02:52:12 <Cale> Well, in structural mode, because it will put a selection around the let declarations, and as you hit ) it will move the selection outward
02:52:39 <jtcwang1> Cale, i can't visualize that
02:53:15 <Cale> https://github.com/chrisdone/structured-haskell-mode#features
02:53:17 <AshyIsMe> lisp has some nice emacs mode editing like that, because you're coding directly in the ast
02:53:23 <AshyIsMe> i think that's chris done's inspiration for it
02:53:29 <kqr> most likely
02:53:37 <kqr> it's possible to do it with haskell as well
02:53:41 <Cale> ^^ there are gifs there to show you what it looks like
02:53:46 <kqr> at least i would think the haskell syntax is fairly predictable
02:54:49 <AshyIsMe> that's weird the gifs don't load for me
02:54:51 <jtcwang1> Cale, that looks pretty neat
02:56:06 <Cale> In the amount of time it takes to press whatever key it is that you have bound to expanding your context to the right place, it seems like someone could have just tabbed over though.
02:56:21 <jtcwang1> but the other features are very interesting
02:56:24 <Cale> yes
02:56:25 <jtcwang1> not sure how often they are used
02:56:34 <jtcwang1> emacs has some crazy things
02:56:47 <Cale> Well, very specifically, the auto-reindenting thing is big
02:56:59 <jtcwang1> yeah
02:57:17 <jtcwang1> like their semi-visual selection
02:57:30 <jtcwang1> not sure how to do that in vim
02:57:39 <Cale> That enables you to avoid the awkward compromises with indentation that everyone makes because reindenting stuff sucks
02:57:52 <jtcwang1> yeah
03:29:01 <jle`> so i spent an hour making half of my library pure/non-monadic, and then just spent another half hour making it monadic again but with a different monad/structure. i don't know anything anymore about how i feel about anything
03:36:25 <Aetherspawn> lpsmith: you around?
03:40:33 <merijn> jle`: :D
03:41:06 * hackagebot persistent-template 1.3.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.1 (MichaelSnoyman)
03:41:16 <merijn> jle`: tbh, I spent a lot of time doing that in the past. It takes a while before you get comfortable guesstimating what will work out the best
03:45:33 <xcvx> Is there a way to combine eof with other parsers using <|>? For example, eof <|> space.
03:45:51 <jle`> i realized that i was only ever querying my database, so i decided to just load it as a Map to be passed around.  i rewrote all of my queries into simple haskell logic in pure functional/composition style with many of those 'where''s that i have missed so much. then i realized that i should throw everything in a Reader, so I did.  so many let's now :/
03:51:15 <merijn> xcvx: I'm guessing eof returns "empty" on failure and <|> tries left-to-right
03:51:26 <merijn> xcvx: So you'd want "space <|> eof"
03:51:32 <xcvx> merijn: Nope, the types don't match.
03:51:36 <xcvx> It doesn't typecheck.
03:51:44 <xcvx> eof :: (Show t, Stream s m t) => ParsecT s u m ()
03:51:48 <xcvx> space :: Stream s m Char => ParsecT s u m Char
03:51:56 <merijn> xcvx: Actually what I just said makes no sense anyway :)
03:51:59 <merijn> xcvx: Use void?
03:52:01 <merijn> :t void
03:52:02 <lambdabot> Functor f => f a -> f ()
03:52:12 <xcvx> Oh, didn't know about this one.
03:52:15 <merijn> :t  "void space" should work
03:52:16 <lambdabot> Not in scope: `should'
03:52:16 <lambdabot> Not in scope: `work'
03:52:19 <merijn> eh
03:53:54 <xcvx> OK, it compiles. Let's see if it works as intended.
04:00:08 <Saizan> jle`: i'd really like parametrized modules for that
04:00:50 <Saizan> jle`: instead of a Reader you basically have a lambda that covers the whole module
04:01:08 <Saizan> jle`: though that only works well if you don't need "local"
04:17:10 <xcvx> Meh, got an exception from Parsec.
04:42:37 <zett_zelett> Do applicative functors have an analogue in category theory?
04:45:40 <d-snp> what is the common way of testing functions that return io monads?
04:47:09 <zett_zelett> Like, if C and D are concrete locally small categories whose arrow sets are objects in them, then a functor F: C → D is set to be applicative if there is a commuting diagram of arrows η_{X,Y} : FAr(X,Y) → Ar(FX,FY)?
04:47:17 <zett_zelett> said*
04:47:45 <absence> zett_zelett: seen this? http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
04:48:03 <zett_zelett> Nope. Thanks.
05:04:59 <avaritia> eh could someone explain to me what are the profits of using category theory in haskell?
05:05:49 <Axman6> well, I believe that by using haskell, you are using category theory. there's no escaping it!
05:06:29 <avaritia> i'm a newbie so maybe i dont possess such in depth look as some people on this channel
05:06:44 <avaritia> but some features like monads are concepts you will naturally come to
05:06:50 <avaritia> without embedding it in math
05:07:15 <avaritia> so why are people embedding it in math, is it allowing them to do some more reasoning about the code or sth?
05:07:41 <Axman6> Cale is probably a better person than I to answer that
05:07:50 <Axman6> and edwardk
05:14:24 <mr-> avaritia: math is the science of structuring information. Where better to look when trying to structure computation?
05:16:07 <mr-> avaritia: And math can provide answers and hints for some questions that come up. For example, what can be done when the composition of monads is no monad
05:16:33 <mr-> (admittedly, that's not the best example)
05:16:48 <xcvx> avaritia: Read about lens here http://ocharles.org.uk/blog/posts/2013-12-01-24-days-of-hackage-intro.html for a quick example.
05:17:36 <vektor> Is there a built-in function in haskell that allows me to get the x biggest Elements of a list?
05:18:43 <avaritia> vektor: (take x).sort ?
05:19:09 <d-snp> woop woop it works :)
05:19:21 <vektor> that might become a bit too complex, but I'm not sure
05:19:28 <avaritia> xcvx: thx will take a look
05:19:34 <vektor> i.e. complexity might skyrocket, but I'm not sure
05:21:43 <avaritia> mr-: hmm so the example simply says what if we pass something to a function and the output is not what we've expected? or am i trivializing it too much?
05:21:57 <d-snp> avaritia: what did you mean by 'embedding it in math' ?
05:22:05 <vektor> Seen how what I need is merely an incomplete selection-sort, I think sorting the whole thing isn't required.
05:23:12 <avaritia> d-snp: hmm the things that are not from the ascii universe, that keep staring at you when you read something about advanced haskell
05:23:50 <vektor> (solution I came up with: http://pastebin.com/0v1eZUVb ... a bit more extensible. Just pass maximum as 2nd param and off you go.
05:23:52 <mauke> The paste 0v1eZUVb has been copied to http://lpaste.net/97823
05:24:00 <Axman6> vektor: take k . sort runs in O(n log k) time, which isn't bad
05:24:12 <skypers> happy new year from France! \o/
05:24:18 <vektor> really, n log k?
05:24:25 <vektor> that's actually neat then
05:24:28 <Axman6> yes, because the sort is lazy
05:24:38 <vektor> gotta love haskell :D
05:24:39 <xcvx> avaritia: I found a simple example. Think about 'map', for instance.  If you know about functors, you can generalize it.
05:24:53 <Axman6> head . sort completes in O(n) time
05:24:56 <bennofs> Axman6: I thought head . sort ran in O(log n) time?
05:25:03 <Axman6> but, maximum is always going to be faster
05:25:06 <vektor> isn't it O(k log n) , which'd be even better in most cases?
05:25:34 <Axman6> bennofs: how can it? you must look at all n items to know you have the largest item
05:25:36 <avaritia> xcvx: the problem is that i can generalize it even without knowing what a functor is
05:26:02 <bennofs> Axman6: hmm, right
05:26:10 <d-snp> avaritia: but to convey your understation of the generalisation, you need a term for it
05:26:16 <d-snp> and the term is functor :)
05:26:18 * hackagebot coordinate 0.0.4 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.4 (TonyMorris)
05:26:38 <Axman6> hmm, now I can't remember which one it is... but by my last argument if k=1, then it can't be O(k log n)
05:27:40 <avaritia> d-snp: yes but i can still do it without coming to a conclusion like this one here http://semantic-domain.blogspot.com/2012/08/a-computational-lambda-calculus-for.html , which is kinda sitting and uncomfortably staring at the reader
05:28:33 <d-snp> avaritia: I don't think that article is written for me
05:29:15 <d-snp> I had terrible grades at discrete mathematics :P
05:29:31 <d-snp> so I see an article like that, ok cool now show me what we can do with it
05:29:47 <d-snp> let the scientist science, and the technologists tech :)
05:30:33 <d-snp> that you can model SQL queries in set notation, does not mean that you have to use set notation to create SQL statements
05:30:37 <avaritia> d-snp: you know i cant even read the notation used in it, and i'm on the 4th year of cs -_-'
05:30:38 <d-snp> it just means you can if you have to
05:31:28 <d-snp> avaritia: 4th year, is your bsc 4 years or are you in your msc?
05:31:37 <avaritia> d-snp: msc
05:32:13 <d-snp> right, I had a msc course called advanced logic, it has most of this notation, the rest is probably category theory from discrete mathematics
05:32:17 <vektor> 1st yr Bsc here :D learning haskell in my freetime.
05:32:28 <d-snp> but, it's a quite specific subject
05:32:47 <d-snp> so odds are that in a general msc you won't ever encounter exactly that notation
05:33:50 <d-snp> vektor: good :D
05:33:53 <avaritia> d-snp: my specialty rather covers diff eq, control theory and ai so nope eh
05:34:28 <avaritia> d-snp: but i've got a course in fp and i'm trying to learn a bit more than the course covers
05:35:44 <vektor> there's just so much stuff I wanna do in haskell. My game project I started in c++, I wanna write in haskell (3d gfx, physics, FPS. pretty ambituous) and I got a crazy AI project I am doing. Haskell is awesome.
05:36:26 <d-snp> I don't think knowing category theory or logic is at all a requisite for being even an advanced haskell programmer, there's just much more exposure from that side of CS to haskell
05:36:35 <avaritia> haskell is nice but sometimes you dont get the pretty solutions your are expecting eh
05:36:49 <avaritia> i'm coding graph coloring in it and some parts are ugh
05:36:58 <d-snp> if you go into testing theory, you'll find much notation like that in for example Temporal Logic, about languages like C and Java as well
05:37:29 <d-snp> but you'll never find anything about temporal logic in tech articles about Java, because Java programmers just usually aren't scientists
05:37:41 <vektor> hahaha
05:37:45 <vektor> too right
05:38:02 <d-snp> though sadly, scientists almost always learn java in their Bsc :P
05:38:10 <vektor> java is a typical "fake it till you make it" language - you just hack and hack until it doesn't error anymore :D
05:38:26 <d-snp> vektor: that's how I code Haskell :P
05:38:26 <vektor> d-snp: correct again :D
05:38:36 <vektor> well, it's different
05:38:44 <vektor> with java, you usually have no idea why it stops erroring
05:38:46 <avaritia> d-snp: eh dont remind me about that, i had some tough fights while i was trying to avoid that beautiful language -_-'
05:38:59 <vektor> java is a clusterfuck of a patchwork language. Barely floats.
05:39:02 <avaritia> with java you have no idea why your program works
05:39:56 <avaritia> also java killed code compl in my vim so i was forced to use some netbeans/eclipse
05:40:03 <avaritia> which wasnt a pleasant experience either eh
05:40:38 <vektor> haha
05:40:58 <vektor> yeah, I also like to code using a fancy editor and a console
05:41:15 <vektor> haven't gotten around to even test haskell in eclipse. Dont feel the need to.
05:42:09 <Axman6> java's not that bad, but the systems built around it are pretty horrible
05:42:48 <vektor> I *hate* swing and AWT with a vengeance.
05:42:50 <avaritia> maybe its not that bad but there are plenty of more pleasant alternatives
05:42:52 <yogurt_truck> java is an abomination
05:43:12 <avaritia> vektor: last year i had to code something in swing i was sick for 2 weeks
05:43:17 <d-snp> java is not an abonimation, it's perhaps a little too lean to be pleasant
05:44:14 <avaritia> d-snp: but you must admit that its hard to find a problem for which java would be the best solution
05:44:21 <d-snp> microsoft made an improved java that I think is actually one of the best languages ever designed
05:44:36 <Komier> c#?
05:44:44 <d-snp> avaritia: well, I think java is close to a good solution for what vektor is trying to do, games ;)
05:44:49 <d-snp> Komier: yes :)
05:44:56 <yogurt_truck> java is probably the biggest cause of anti-type hate out there, which makes it even worse for the world
05:44:57 <vektor> d-snp: hell no
05:45:00 <d-snp> not a very popular opinion, but it's really a very good language
05:45:02 <avaritia> d-snp: its too slow for that
05:45:15 <avaritia> d-snp: if you want to code games for serious you need to go with c++
05:45:18 <xcvx> #haskell-blah, maybe?
05:45:26 <dibblego> #haskell-blah please
05:45:33 <d-snp> k sorry :)
05:45:57 <dibblego> thanks
05:46:01 <avaritia> sorry, lets continue there gentlemans
05:48:26 <xcvx> How can I define a parser that matches until the last occurrence of a symbol is found?  For example, for "foo. bar . baz. qux", I'd like to get "foo. bar . baz.".
05:49:20 <Taneb> Just realised I've reinvented the State monad
05:49:41 <xcvx> Oh, maybe I should try a recursive defintion.
05:53:37 <Komier> implementing the sieve of eratosthenes in Haskell seems way more complicated than in Python for example. hmm
05:54:23 <bennofs> Komier: http://jozefg.bitbucket.org/posts/2013-12-03-primes-in-haskell.html
05:55:21 <ezyang> what ever happened to haskell-prime?
05:55:25 <Komier> ty bennofs
05:57:19 <Komier> I have just been working through LYAH and some of the early Euler problems.  Some of the problems are crazy easy in Haskell, but a prime generator seems more complicated :)
05:57:49 <benmachine> ezyang: I think no-one actually took that much of an interest?
05:57:54 <Komier> Possibly just that I'm not "thinking" haskell yet :)
05:58:02 <benmachine> ezyang: at this stage no-one much stands to gain from further standardisation
05:58:51 <ezyang> I think a lot of people would be happy if Haskell got a memory model
05:59:02 <codh> greeting and happy new year, I'm reading this http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter, but found it's not accurate. The time of two version are almost the same on my machine.
05:59:04 <ezyang> But sure, I can totally understand the petering out of interest
05:59:09 <maurer> I would be happy if we got any kind of cost semantics :P
05:59:16 <maurer> Either for space or time
05:59:31 <ezyang> maurer: We do have a cost semantics!
05:59:39 <maurer> Oh?
05:59:44 <ezyang> It's not terribly useful for static analysis though ;)
05:59:49 <maurer> heh
05:59:55 <ezyang> (the semantics used for the profiler)
06:00:26 <maurer> Oh, sure, I meant more along the lines of "I would like to be able to prove that this function will run in blah time"
06:01:46 <ezyang> People have wanted this for a long time. I'm not sure why, in the circles I have my ear pressed to, there hasn't been any credible process
06:01:56 <ezyang> *progress
06:03:36 <benmachine> ezyang: the people who want it should volunteer :P
06:04:26 <ezyang> "Memory models" :: "I am glad people are working on it, and I'm glad I'm not."
06:04:31 <ezyang> :D
06:06:25 <zett_zelett> Should show/read be isos?
06:06:41 <ezyang> zett_zelett: Yeah
06:13:59 <haasn> I don't think that's true for all prelude instances, mind
06:14:11 <haasn> > show (read "1.00" :: Double)
06:14:12 <lambdabot>  "1.0"
06:14:21 <ezyang> "iso-ish"
06:14:30 <haasn> rather, read should be a left inverse of show?
06:15:33 <Komier> hmm looks like I might be better off  leaving the prime generator until I'm further along in LYAH :D
06:19:16 <xcvx> Komier: What's the task, and what chapter are you reading?
06:20:48 <Komier> xcvx: Only up to chapter 5, and was also attempting some Euler problems.  Most of the prime generators deal with parts of Haskell I'm not familiar with yet :)
06:21:22 <xcvx> Komier: So, you'd like to generate an infinte sequence of primes, right?
06:22:27 <xcvx> Komier: Yeah, I think you should read the sixth chapter first.
06:22:41 <Komier> xcvx : yeh, whilst being able to specify a stopping point.
06:22:42 <xcvx> So you could compose your functions.
06:23:00 <Komier> xcvx : yeh, not quite far enough along yet :)
06:23:53 <Komier> the post bennofs linked is interesting though, will save that for later.
06:23:59 <FreeFull> Komier: I would just use a library to generate the primes for you
06:24:07 <d-snp> Komier: which euler problem is that?
06:24:09 <d-snp> 3?
06:24:49 <Komier> d-snp : yeh but if i get a decent prime generator lots of other problems will use it, with variations
06:24:53 <FreeFull> The primes library has worked well for me
06:25:07 <Komier> Free:full there is a library for it?
06:25:19 <FreeFull> Yeah
06:25:25 <FreeFull> http://hackage.haskell.org/package/primes
06:25:34 <zett_zelett> What.
06:25:35 <FreeFull> It offers you an infinite list of primes, and is fairly fast
06:25:35 <d-snp> my implementation looks pretty elegant, no idea if it is fast, do you want to look at it?
06:25:39 <zett_zelett> Primes library.
06:25:51 <zett_zelett> What’s the point of solving euler problems with a library?
06:25:56 <d-snp> zett_zelett: exactly..
06:26:06 <Komier> d-snp: sure, always open for looking.  I can save it for later if I can't entirely follow it yet.
06:26:18 <FreeFull> zett_zelett: Generating prime numbers is a well known thing though
06:26:33 <d-snp> --- warning this is a spoiler for euler problem 3: https://github.com/d-snp/euler/blob/master/3.hs ---
06:26:49 <zett_zelett> FreeFull: Yeah, but if you can’t do it, you should do it.
06:26:53 <FreeFull> Although problem 3 is simple enough that you can even do it by hand
06:27:07 <FreeFull> A lot of the early problems you can do by hand fairly quickly
06:27:31 <d-snp> would be quite embarassing if it turns out now my thing is not correct
06:28:12 <d-snp> wait.. my thing doesn't sieve primes does it?
06:28:18 <d-snp> it just finds factors?
06:28:34 <zett_zelett> It woud be nicer to replace "last" by "maximum" I think.
06:28:59 <Komier> FreeFull: Indeed it is.  But primes feature heavily in a lot of the other problems.  Coming up with a half decent prime generator you can re-use in other problems is very handy.
06:29:49 <zett_zelett> Komier: Can you check in Haskell whether a given positive integer is prime or not?
06:30:28 <Axman6> zett_zelett: why couldn't you? you just write a function that does it
06:30:30 <FreeFull> zett_zelett: maximum would compare all the numbers, while you know the last one is the biggest one anyway
06:30:42 <sipa> zett_zelett: haskell is turing complete; of course you can :)
06:31:09 <sipa> @faq Can haskell check whether a given positive integer is prime or not?
06:31:10 <lambdabot> The answer is: Yes! Haskell can do that.
06:31:21 <d-snp> yes, I believe maximum would introduce at least n unnecessary comparisons
06:31:27 <sipa> even lambdabot concurs
06:31:58 <Axman6> > let isPrime n = all (f -> n `rem` f /= 0) [1.. n `div 2 + 1] in isPrime 12
06:31:59 <lambdabot>  <hint>:1:55: parse error on input `2'
06:32:06 <Axman6> > let isPrime n = all (f -> n `rem` f /= 0) [1.. n `div` 2 + 1] in isPrime 12
06:32:07 <lambdabot>  Pattern syntax in expression context: f -> n `rem` f /= 0
06:32:23 <Axman6> > let isPrime n = all (\f -> n `rem` f /= 0) [1.. (n `div` 2) + 1] in isPrime 12
06:32:24 <lambdabot>  False
06:32:27 <Axman6> > let isPrime n = all (\f -> n `rem` f /= 0) [1.. (n `div` 2) + 1] in isPrime 13
06:32:29 <lambdabot>  False
06:32:38 <Axman6> > let isPrime n = all (\f -> n `rem` f /= 0) [2.. (n `div` 2) + 1] in isPrime 13
06:32:39 <lambdabot>  True
06:32:44 <Axman6> obviously...
06:32:57 <zett_zelett> Yeah, my point was to give Komier a hint how to create a prime generator.
06:32:59 <Axman6> (please don't use that, it's very inefficient)
06:33:31 <Komier> haha aye I won't.  My computer would explode with larger numbers :D
06:33:37 <d-snp> I gave up euler after I couldn't find an efficient solution for problem 4
06:34:02 <zett_zelett> Palindrome numbers?
06:34:20 <d-snp> I even posted a question on the math stackexchange, apparently there just isn't an efficient solution
06:34:23 <d-snp> zett_zelett: yes
06:35:02 <Axman6> d-snp: it does help to start with the largest numbers first though, that saves like heaps of time
06:35:05 <Axman6> :P
06:35:35 <Axman6> I remember doing several where my first go created all solutions, which was pretty dumb
06:35:48 <d-snp> yeah, but apparently there just isn't an efficient way of exactly generating them in order
06:35:57 <d-snp> which frustrated me so that I lost interest :P
06:35:59 <Komier> d-snp: I was discussing that one in here yesterday.
06:36:16 <d-snp> oh you were? did you reach the same conclusion?
06:36:45 <zett_zelett> What do you mean by efficient?
06:37:43 <d-snp> you can look at my problem here: https://github.com/d-snp/euler/commit/c01a1ece7810bb8e31d4f0cceb2a6e372c5a2cfb in the comment block you see a list of palindromes it generated, they are sort of from larger to smaller, but not exactly
06:38:07 <d-snp> an efficient solution would have the largest palindrome at the top, and you could select it with head
06:38:16 <d-snp> but that seems to be a mathematical impossibility
06:38:33 <d-snp> at least, if you want to keep it clean
06:39:17 <d-snp> I think the list is in order with some small error, so perhaps you could deduce what the error is, and use that information to check ahead and reorder if necessary
06:39:19 <zett_zelett> What’s the problem with an O(n) operation on a list?
06:39:31 <d-snp> honour zett_zelett, honour
06:39:59 <zett_zelett> Do you come from C or something?
06:40:02 <Axman6> nah, I'm sure there's a way to make sure. if you imagine it as a 1000x1000 array with the product in each cell, then to find the largest you just need to look at each diagonal starting at 999x999 and moving back towards 1x1. I think you only need to check the other numbers in the ne-sw direction
06:40:50 <d-snp> zett_zelett: ruby :P
06:40:54 <zett_zelett> Ah.
06:40:57 <d-snp> the slowest language in existance :D
06:41:22 <Komier> I ended up just doing that one with a dirty one liner, but it didn't sit very well.
06:41:38 <zett_zelett> Dirty one liner?
06:41:46 <zett_zelett> Show.
06:42:14 <d-snp> (\thedirty -> do thedirty)
06:42:16 <Komier> 2 secs
06:43:09 <Komier> maximum[x*y | x <- [999,998..900], y <- [999,998..900], reverse(show(x*y)) == show(x*y)]
06:43:46 <Komier> Don't judge me :P
06:43:49 <d-snp> my 20 liner is no more elegant or less dirty
06:44:05 <zett_zelett> Wouldn’t call it dirty. How did you figure there even was a palindromic numbet between 999..900?
06:44:11 <zett_zelett> Oh, no.
06:44:20 <zett_zelett> That is implied in the question.
06:45:07 <zett_zelett> No, it’s not.
06:45:10 <zett_zelett> What am I saying.
06:45:16 <zett_zelett> How did you figure that out?
06:46:28 <Komier> I assumed.
06:46:42 <zett_zelett> That’s the only dirty part in my opnion.
06:46:48 <zett_zelett> (I did let isPalindrome l = (l == reverse l) in maximum  [x*y | x <- [100..999], y <- [100..999], isPalindrome . show $ x*y], btw.)
06:47:05 <twiceler> So I'm getting some strange linking error using GHC with OS X Mavericks
06:47:10 <twiceler> http://lpaste.net/97825
06:47:12 <Komier> You can do it [100..999] and it doesnt seem appreciably slower to be honest.
06:47:16 <d-snp> twiceler: solution is in the topic :)
06:47:28 <twiceler> Thanks!
06:48:10 <geekosaur> no, that;s a different problem I suspect
06:48:15 <geekosaur> xcode-select --install
06:48:16 <d-snp> oh
06:48:43 <geekosaur> the /topic has a fix for preprocessor errors. this looks like the command line tools are missing.. xcode-select --install
06:48:50 <d-snp> yeah you're right
06:49:02 <Komier> zett-zelett: I like that.
06:49:32 <zett_zelett> It’s the same thing, just written in a cleaner manner.
06:50:26 <Komier> yeh, there is a lot to be said for clean though.
06:50:30 <d-snp> hmm I always prefere ".. where .." over "let .. in .."
06:50:51 <zett_zelett> Me too, but this way you can feed it to ghci directly.
06:50:56 <d-snp> oh right
06:51:01 <zett_zelett> Else you can only compile it if I’m not mistaken.
06:51:07 <zett_zelett> Or can you even do that?
06:51:38 <Axman6> d-snp: my untested attempt in C... I think it makes sense
06:52:51 <d-snp> well it sounded interesting
06:53:51 <Axman6> in fact, the the highest values are guaranteed to be on the right edge/top, so it could be a bit shorter if I started there and just looked for another palindrome in the same diagonal from the high end...
06:54:34 <osa1> -funbox-strict-fields looks charming
06:54:55 <Axman6> it's pretty handy
06:56:41 <twiceler> geekosaur: Thanks; it does seem that I'm missing the Xcode command line tools. Pains of upgrading the OS... (I had them before I upgraded)
06:56:58 <geekosaur> yep, that always seems to remove or at least damage them
06:57:09 <boom583> I have a module in Shapes.hs
06:57:14 <boom583> How do I import the module in GHCI?
06:57:18 <boom583> :m + Shapes doesn't work
06:57:22 <Axman6> ghci Shapes.hs
06:57:25 <dv-> import Shapes
06:57:39 <boom583> import Shapes doesn't work: Could not find module `Shapes'
06:57:46 <boom583> I'm running GHCI from the same folder
06:58:09 <Komier> :l Shapes
06:58:49 <twiceler> geekosaur: It works now after installing the command-line tools; thanks!
06:58:49 <boom583> ok thanks
06:59:07 <Komier> boom583 did that work?
07:00:18 <boom583> yeah
07:00:20 <boom583> thx
07:00:27 <Komier> cool np
07:00:34 <zett_zelett> On the topic of primes again.
07:01:01 <zett_zelett> Can anyone explain to me why approach B is more efficient than approach A?
07:01:02 <zett_zelett> http://lpaste.net/7291379679917768704
07:01:11 <zett_zelett> In creating a list of primes.
07:02:51 <Axman6> danger will robinson, danger! l ++ [h] -- that's a greay way to make O(n^2) algorithms
07:02:56 <Axman6> great*
07:04:03 <Axman6> zett_zelett: approach A checks less numbers against the input
07:05:30 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\x -> n `rem` x /= 0) . takeWhile (\x -> x*x <= n) $ primes in primes
07:05:31 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:05:40 <Axman6> mutual recursion!
07:05:58 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\x -> n `rem` x /= 0) . takeWhile (\x -> x*x <= n) $ primes in primes !! 1000
07:05:59 <lambdabot>  7927
07:06:01 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\x -> n `rem` x /= 0) . takeWhile (\x -> x*x <= n) $ primes in primes !! 10000
07:06:03 <lambdabot>  104743
07:07:27 <c_wraith> zett_zelett: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf covers just about every question you might have about simple sieves.
07:08:27 <Komier> http://jozefg.bitbucket.org/posts/2013-12-17-haskell-sieves.html
07:09:29 <zett_zelett> Oh no, a long paper.
07:09:46 <zett_zelett> Actually, it’s quite short.
07:10:02 <zett_zelett> But it’s a paper nonetheless.
07:10:05 <c_wraith> It's also very readable, and has real code
07:10:09 <zett_zelett> Oh no, a paper.
07:10:19 <zett_zelett> Ha, already found a typo.
07:16:31 * hackagebot coordinate 0.0.5 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.5 (TonyMorris)
07:16:38 <zett_zelett> i still don’t get it Axman6:
07:16:55 <ImUrBreda> anyone here using the postgres-simple package?
07:17:15 <Clint> only indirectly
07:17:17 <Axman6> zett_zelett: hmm?
07:17:31 <zett_zelett> Say, haskell has computed the first 100 entries of primes'. What happens when computing the next entry? It takes the head of buildlist nextPrime (l++[nextPrime l]), where nextPrime l and l are already computed.
07:17:35 <ImUrBreda> Clint: was that for me?
07:18:16 <zett_zelett> Then it would create from that list the next prime.
07:18:18 <Clint> ImUrBreda: yes
07:18:45 <ImUrBreda> Clint: do you know how transactions work? can i reuse the same db connection from multiple threads?
07:18:56 <ImUrBreda> while doing transactions?
07:18:56 <vektor> can someone express this without lambda: (\ a b -> compare (id a) (id b)) -- id is a record-syntax data accessor.
07:19:36 <byorgey> vektor: comparing id
07:19:54 <Clint> ImUrBreda: i don't know
07:19:55 <vektor> seriously?
07:20:02 <vektor> that's beautiful
07:20:13 <byorgey> @type comparing
07:20:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
07:20:26 <ImUrBreda> Clint: thanks
07:20:33 <byorgey> vektor: I think you have to import Data.Ord
07:21:00 <vektor> that is simply gorgeous. Thanks
07:21:34 <vektor> and, I must say, gorgeously simple.
07:22:05 <Happy0> @type foldMap
07:22:06 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:22:19 <ZetaPrime> Hello. Has anyone tried to install wx on an arch install recently?
07:22:59 <zett_zelett> Well, I’m betting on you.
07:24:04 <ZetaPrime> I tried to install it. But it failed for different reason on different systems.
07:25:05 <ZetaPrime> Both fail when trying to compile wxc against wxgtk2.9.
07:27:43 <Komier> hmm i only got 2.8 on Mint.
07:28:07 <Komier> i didn't think most repositories had 2.9 for any distro
07:28:12 <Komier> supposedly unstable or something
07:30:31 <ZetaPrime> Arch does have it in the community repo.
07:31:29 <ZetaPrime> But maybe I can try the old wx for 2.8.
07:33:30 <ZetaPrime> The compilation errros seem fairly serious. Like functions that take 3 arguments, but only 2 being provided.
07:35:34 <Komier> Can't help ya there mate I'm afraid.  I just have it installed in case I ever know enough to use it.  Just remember reading about the 2.8 > 2.9 issue when I was installing Mint 16. :)
07:37:42 <ZetaPrime> Thanks anyway. I'll see if I can get the 1.13 branch installed instead.
07:40:42 <Guest45048> anyone here? i am new to haskell. I am trying to solve http://projecteuler.net/problem=46 in haskell. my haskell code is working but is taking 2 seconds where as the C# one is taking 10ms. can someone tell me how i can optimize it
07:41:06 <Pupnik> you will need to post your code for that
07:41:17 <FreeFull> Guest45048: I think you'll need to find someone who's done that problem themselves
07:42:21 <Guest45048> actually the problem is quite simple and my code too. i shared my code here http://pastebin.com/1ZND0bZD. I strongly feel i am making some newbie mistake
07:42:23 <mauke> The paste 1ZND0bZD has been copied to http://lpaste.net/97828
07:42:54 <epta> Guest45048: could you please add C# code too?
07:43:54 <Guest45048> epta: I don't have it immediately, but i can quickly code it. please hold on
07:44:18 <vektor> Guest25048: When I implemented mergeSort first in haskell (among my 100 first lines of haskell code) I did the mistake of using list ++ [elem] instead of elem : list. THat turned out to be quite a performance hit. I had to reverse some stuff, but it was way faster afterwards. Talking about newbie mistakes :D
07:44:54 <FreeFull> vektor: You can do a fast mergesort without any reverse step
07:45:10 <Axman6> indeed...
07:45:28 <FreeFull> Make sure to split the lists up efficiently on the divide step
07:45:52 <Axman6> merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = merge (x:xs) ys
07:46:03 <vektor> FreeFull, yeah, well I didn't need to reverse the list, just had to reverse the logic in a way.
07:46:05 <Axman6> with appropriate base cases
07:47:14 <vektor> Guest45048: well, I'd guess your problem is the sqrt function you use... just a guess though
07:47:52 <FreeFull> Axman6: You just threw the y away there
07:48:11 <aleksejs_> Guest45048, try to do the opposite
07:48:12 <Axman6> FreeFull: bleh, yes. it's almost 3AM here :P
07:48:26 <Guest45048> epta: fortunately i found some code online http://ideone.com/BuaA15
07:48:38 <aleksejs_> generate all sums of primes + 2xn^2
07:48:53 <FreeFull> Axman6: Your merge sort would end up only returning some of the items =P
07:48:58 <FreeFull> I think only one
07:49:09 <vektor> I'd try to optimize isPerfectSquare. imo, you don't need a slow sqrt :: double call, if all you do is floor the result.
07:49:51 <vektor> FreeFull: only the left side of two lists. yep. Only the smallest element.
07:49:53 <Guest45048> aleksejs_: but the same algorithm works faster in C#.
07:50:09 <Axman6> Guest45048: it's definitely not the same algorithm :\
07:50:20 <vektor> That's a bit too complex for selecting the smallest element of a list.
07:50:51 <Guest45048> Axman6: how come? what do you see that is different?
07:51:24 <aleksejs_> Guest45048, also take a look on this http://en.wikipedia.org/wiki/Prime_gap maybe will help
07:52:24 <Axman6> why are there so many people doing PE tonight? has it been mentioned somewhere recently?
07:52:52 <Guest45048> vektor: can you suggest anything better alternative to the sqrt call?
07:53:06 <FreeFull> I think you could implement a mergesort with foldMap and an appropriate Monoid
07:53:13 <FreeFull> :t foldMap
07:53:14 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:53:14 <vektor> the c# algo seems to iterate two variables and determine if the number they generate is of some property. Your hs algo seems to iterate the possible results and tries to reverse-engineer the n and m required for that.
07:54:05 <FreeFull> At least, I think foldMap mappends in a tree structure
07:54:06 <Komier> Axman6: Because it's fun? :D
07:54:14 <aleksejs_> Komier, ++
07:56:22 <Komier> Axman6: But seriously, I'm using it because I'm a newbie programmer, trying to learn Haskell, and it's fun to mix things up rather than just reading through LYAH.
07:56:50 <Guest45048> vektor: actually in C# the first while loop is looping over all the odd numbers which corresponds to my [3,5..] and the second while loop in C# is just bruteforcely testing for the first prime less than the number which satisifies the property which my satisfiesGoldbach  function is doing
07:56:51 <vektor> Komier: I started my own small project instead.
07:56:58 <Axman6> right, I don't have a problem wiht it, it just seems like a big spike in the number of people asking about it, and it seems there should be some cause for the spike
07:57:18 <Axman6> I mean there's been like 4 people in the last hour, that's quite a coincidence
07:57:34 <vektor> Komier: let me tell you, I run into problems that are over my head all day long ... doesn't matter, still fun.
07:59:14 <Komier> vektor: Yeh I think I will do something similar once I'm a little further along.  Only just doing higher order functions chapter.  What kind of project you working on?
07:59:55 <Komier> Axman6: Maybe we spurred people on with all the waffle about primes earlier. lol
08:00:29 <vektor> Komier: some crazy shit about AI and genetic algorithms and artificial life.
08:00:45 <vektor> If all goes well, I'll be releasing SkyNet's source code within 3 months :D
08:00:59 <Komier> hahaha
08:01:12 <vektor> Open Source, of course.
08:01:14 <FreeFull> @let newtype Sorted a = Sorted [a];
08:01:16 <lambdabot>  Defined.
08:01:41 <Guest45048> sorry guys for wasting your time. i found the issue.
08:02:15 <vektor> tell us :-)
08:02:24 <yitz> FreeFull: let newtype?
08:03:30 <FreeFull> @instance (Ord a) => Monoid (Sorted a) where mempty = Sorted []; mappend (Sorted xs) (Sorted ys) = Sorted (merge xs ys) where merge [] [] = []; merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = if x < y then x : merge xs (y:ys) else y : merge (x:xs) ys
08:03:30 <lambdabot> Maybe you meant: instances instances-importing
08:03:35 <FreeFull> @let instance (Ord a) => Monoid (Sorted a) where mempty = Sorted []; mappend (Sorted xs) (Sorted ys) = Sorted (merge xs ys) where merge [] [] = []; merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = if x < y then x : merge xs (y:ys) else y : merge (x:xs) ys
08:03:38 <lambdabot>  Defined.
08:04:10 <FreeFull> > (\(Sorted xs) -> xs) $ foldMap Sorted [1,5,3,6,7,2]
08:04:12 <lambdabot>  No instance for (GHC.Show.Show t0)
08:04:12 <lambdabot>    arising from a use of `M405339189327081070429142.show_M4053391893270810704...
08:04:12 <lambdabot>  The type variable `t0' is ambiguous
08:04:12 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:04:12 <lambdabot>  Note: there are several potential instances:
08:04:16 <Axman6> you'd also want a toSorted :: a -> Sorted a, and to hide the constructor
08:04:24 <FreeFull> > (\(Sorted xs) -> xs) $ foldMap Sorted [1,5,3,6,7,2] :: [Integer]
08:04:25 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
08:04:25 <lambdabot>    arising from the literal `1'
08:04:25 <lambdabot>  Possible fix:
08:04:25 <lambdabot>    add an instance declaration for
08:04:25 <lambdabot>    (GHC.Num.Num [GHC.Integer.Type.Integer])
08:04:41 <FreeFull> Hmm, I did something wrong
08:04:43 <Axman6> FreeFull: remember it takes [a] not a
08:04:51 <FreeFull> Ah, yeah, you're right
08:05:03 <FreeFull> > (\(Sorted xs) -> xs) $ foldMap (Sorted . (:[])) [1,5,3,6,7,2] :: [Integer]
08:05:05 <lambdabot>  [1,2,3,5,6,7]
08:05:09 <FreeFull> Robot monkey to rescue
08:05:12 <Axman6> so you'd want mkSorted a = Sorted [a] or something
08:05:30 <FreeFull> It sorts
08:06:14 <FreeFull> Axman6: or a Pointed instance
08:06:33 <Lethalman> eek how can to sort? :S
08:06:38 <Axman6> yeah
08:06:39 <Lethalman> :t foldMap
08:06:40 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
08:06:49 <Lethalman> *how can that sort
08:07:32 <FreeFull> Lethalman: Why wouldn't it sort?
08:07:41 <Lethalman> I see no comparison
08:07:48 <FreeFull> Lethalman: It's in the Monoid instance
08:07:51 <donri> Lethalman: it's in the @let instance
08:07:55 <Lethalman> ah
08:07:57 <Lethalman> didn't see
08:08:02 <Lethalman> cool
08:08:16 <Guest45048> vektor: i found the issue. i was testing my code in fpcomplete which is showing wrong time. when i ran in ideone it ran quite fast. thanks for your time
08:11:19 <Komier> Think I need to make up some shortcuts for  things like  ->
08:24:07 <BlankVerse_> is it possible to search hackage for all packages that depend on another package say foo
08:24:44 <geekosaur> http://packdeps.haskellers.com/
08:24:48 <ocharles> ya, http://packdeps.haskellers.com/reverse
08:26:02 <BlankVerse_> thanks, geekosaur and ocharles
08:26:43 <ocharles> Welcome
08:34:09 <yitz> Komier: here's one: →
08:43:59 <L8D> How does Aeson know the field names of structures?
08:44:31 <L8D> structures as in: data Response = Response { type :: String, date :: Int }
08:44:46 <L8D> Is that some kind of reflection thing?
08:46:03 <bennofs> L8D: Yes, it uses either Typeable/Data or TemplateHaskell
08:46:50 <L8D> Interesting...
08:48:39 <BlankVerse_> my ghc-pkg registry has broken packages, how do I fix it? or do I start from scratch?
08:49:28 <BlankVerse_> can I use packages in cabal sandboxes to compile my haskell program?
08:49:54 <Ankhers> Is it common / good practice to use ("?" `T.isSuffixOf` message) where T is Data.Text?
08:50:20 <dv-> why not?
08:50:27 <epta> BlankVerse_: sure
08:50:55 <BlankVerse_> epta: without writing a cabal file and doing cabal build?
08:51:24 <BlankVerse_> ghc --make Main.hs where Main.hs has modules which are in the sandbox
08:52:22 <epta> BlankVerse_: cabal sandbox is just small addition to global packages store, so it is usefull when some cabal project have some dependencies and you don't wanna install them globally
08:53:06 <jonasw> BlankVerse_: `cabal sandbox init` should be all that's needed. After that, install will use the sandbox
08:53:11 <bennofs> BlankVerse_: why don't you write a cabal file?
08:53:12 <sm> BlankVerse_: ghc --package-db .cabal-sandbox/somethingsomething
08:53:24 <epta> BlankVerse_: you don't need to remove all packages to fix ghc-pkg, btw
08:53:32 <monochrom> -package-db, not --package-db
08:53:47 <BlankVerse_> jonasw: no, ghc --make can't find the package inside the sandbox, I just tried
08:54:52 <epta> I think it's better to start with fixing ghc-pkg
08:55:12 <epta> BlankVerse_: show please `ghc-pkg check'
08:55:13 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
08:56:47 <Ankhers> Which would be more idiomatic Haskell? Using overloaded strings, or to use (T.pack "?" `T.isSuffixOf` message)?
08:57:19 <BlankVerse_> epta: http://lpaste.net/97829
08:57:28 <jonasw> BlankVerse_: What about cabal build/install?
08:57:38 <BlankVerse_> jonasw:
08:57:44 <bennofs> Ankhers: I like using overloaded strings more, but other people might disagree
08:57:58 <monochrom> misfortune :)
08:58:07 <Ankhers> bennofs: Can you explain why you like using overloaded strings?
08:59:11 <bennofs> Ankhers: it is shorter and has less clutter (T.pack is only verbose boilerplate IMO)
08:59:13 <SLi> Hi. I'm trying to write my first parallel haskell program, and am wondering about how to best approach this. Basically my program is a filter which reads input (lazy bytestrings), splits it into lines and processes the lines one by one (some regexp matching etc.). I'm looking into parListChunks; a chunk of a few hundred lines would probably be a good task size. Now the problem is that the input is too big to fit in memory, so only a bounded number of lines
08:59:14 <SLi> should be forced ahead...
09:00:22 <epta> BlankVerse_: it means that you still have registered all these guys, but you cannot use them unfortunately. So, if I understand you correctly, your *.hs file depends on some of them and it just don't compile
09:00:42 <SLi> Right now I have processBuf :: ByteString -> ByteString; processBuf = B8.unlines . (withStrategy $ parListChunk 1000 rdeepseq) . map processLine . B8.lines, but that explodes the memory use.
09:01:04 <Ankhers> bennofs: Are there any performance trade offs?
09:01:24 <BlankVerse_> epta: But I have unregistered plugins from user db and installed it in sandbox, shouldn't it be picked from sandbox?
09:02:15 <epta> BlankVerse_: if you don't have *.cabal file with listed dependencies you'll need to use this global ghc-pkg. If you have *.cabal file, `cabal sandbox init && cabal build' will fetch all of them automatically to the sandbox
09:02:43 <epta> BlankVerse_: yes, it should
09:02:54 <bennofs> Ankhers: There shouldn't be, GHC will probably compile both to the same code. Even if it wouldn't, the performace difference would be so minor that it won't matter (And if it does, you should profile and check anyway)
09:03:39 <epta> BlankVerse_: paste cabal file and build errors
09:04:51 <BlankVerse_> epta: wait, so only cabal build/install can access packages in the sandbox? ghc --make wont?
09:05:03 <Ankhers> bennofs: Noted, thanks.
09:06:21 <Nelicus> hello guys
09:07:14 <Nelicus> i need help figuring out how do verify nº of repetions on a list of a certain element i have. Can you give me a hand?
09:07:17 <epta> BlankVerse_: ghc --make could, but you need to fetch them with cabal-sandbox
09:08:22 <BlankVerse_> cabal sandbox hc-pkg list , shows that the packages are in the list
09:08:39 <bennofs> Nelicus: So you want to count how many times a certain element appears in a list?
09:10:50 <bennofs> Nelicus: If you want to count how often an ellement x occurs in a list, you could do it like this: filter the list so that only contains elements equal to x and then take the length of that list
09:10:56 <Nelicus> yes... i mean, kind of. For example consider the list [(a,a,d), (a,a,d), (b,b,d), (c,c,d),(c,c,d)] based on the first two components i want to know how many times it repeats X number of times. If i wanted to know what elements repeat 2 times for example my outcome would be [(a,a,d),(c,c,d)]
09:11:44 * hackagebot OpenVGRaw 0.4.0 - Raw binding to OpenVG (ShivaVG-0.2.1 implementation).  http://hackage.haskell.org/package/OpenVGRaw-0.4.0 (StephenTetley)
09:11:46 * hackagebot OpenVG 0.7.0 - OpenVG (ShivaVG-0.2.1) binding  http://hackage.haskell.org/package/OpenVG-0.7.0 (StephenTetley)
09:11:47 <oolo> Nelicus: Repeat in a row or just in the list?
09:12:10 <bennofs> Nelicus: oh, so you probably want "group"
09:12:39 <bennofs> > group [(a,a,d), (a,a,d), (b,b,d), (c,c,d),(c,c,d)]
09:12:40 <lambdabot>  [[(a,a,d),(a,a,d)],[(b,b,d)],[(c,c,d),(c,c,d)]]
09:12:49 <Nelicus> this is already a group. It's a group based on the third component, that's why i have "d" in all :*
09:13:14 <bennofs> > group $ sort [(a,a,d), (e,a,b), (a,a,d), (b,b,d), (c,c,d),(c,c,d)]
09:13:16 <lambdabot>  [[(a,a,d),(a,a,d)],[(b,b,d)],[(c,c,d),(c,c,d)],[(e,a,b)]]
09:14:14 <epta> BlankVerse_: what about 'cabal sandbox hc-pkg check'?
09:14:47 <Nelicus> ok i can do that, and then you sugest i make a if function to compare the lenght of each one and if its equal to my X, then take the one component of that list?
09:15:07 <Axman6> sure
09:15:39 <Axman6> though, to be safe, you should write a function which takes n and tells you if the list is of length n. avoids problems of infinite lists
09:16:08 <bennofs> Nelicus: yes
09:17:12 <Nelicus> ok, so sort my list, group it, compare lenght with value of X and return element if True
09:20:15 <BlankVerse_> epta: its ok, anyways, I made a cabal file and I am using now cabal build instead of ghc-make
09:20:32 <yitz> Axman6: or write the function sameLength :: [a] -> [a] -> Bool which is probably faster anyway.
09:20:48 <BlankVerse_> epta: thanks for the help
09:22:06 <yitz> Axman6: which doesn't avoid the problem if they are *both* infinite, but that's not the case here.
09:22:40 <Axman6> yitz: isLength :: Int -> [a] -> Bool -- guaranteed to halt :P
09:25:48 <yitz> > let isLength 0 xs = null xs; isLength n (_:xs) = isLength (n-1) xs; isLength _ _ = False in isLength (fix id) [1..10] -- Axman6
09:25:52 <lambdabot>  mueval-core: Time limit exceeded
09:26:14 <Axman6> except for divergent Ints
09:26:21 <SLi> Hmm, compiling my program with ghc --make -O3 -parallel says "<command line>: cannot satisfy -package concurrent". Any idea what I'm missing?
09:26:42 <SLi> Hmm, maybe -parallel was not the right switch :)
09:26:44 <Axman6> are you trying to use DPH?
09:26:50 <Axman6> you probably want -threaded
09:27:35 <SLi> Axman6: No, not DPH. Yeah, -threaded was the right switch. Thanks :)
10:01:50 * hackagebot module-management 0.18 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.18 (DavidFox)
10:06:51 * hackagebot system-random-effect 0.4.1.1 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.4.1.1 (ClarkGaebel)
10:12:02 <flebron> Hi guise. I'm trying my hand at DataKinds. I wanted to (perhaps) shorten my code here: http://fedelebron.com:8000/static/AVL.hs by adding the "left" and "right" functions. First of all, am I correct in thinking that the reason left and right don't compile, is that the height of (say) a left subtree of a Rightie of height n, and a left subtree of a Leftie of height n, have different heights, and thus m can't
10:12:04 <flebron> unify with both of them?
10:12:36 <flebron> Second, is there any way to say "This gives you a tree of some (unspecified) height"?
10:14:07 <Taneb> For the first time, just now I have thought, "mfix is the answer", and then written a solution that uses mfix and works
10:14:19 <ocharles> Taneb: oh?
10:14:25 <jmcarthur> i love mfix
10:15:06 <jmcarthur> my most common use for mfix is self-referencing IORefs
10:15:40 <Taneb> ocharles, inserting something in an unoccupied index in an IntMap in a State monad such that the thing I insert depends on the index it gets inserted
10:16:03 <jmcarthur> yeah that has the right flavor indeed
10:16:32 <ocharles> indeed
10:16:33 <jmcarthur> s/index/reference/ and s/IntMap/heap/ and s/State/IO/, then you have basically the same situation
10:16:36 <skypers> hi
10:16:36 <ocharles> mfix is very cool
10:16:50 <ocharles> I only use it informally in netwire to do feedback loops
10:17:33 <skypers> I have a String, and I’d like to parse it in order to produce a [Float]
10:17:47 <jmcarthur> i have also used mfix in an assembler DSL, probably my favorite use. allows to forward reference labels for jumps and such.
10:17:48 <skypers> the values are convenient to write
10:18:05 <skypers> like 1 1 1 instead of (1,1,1) or [1,1,1]
10:18:13 <mauke> map read . words
10:18:30 <skypers> oh words
10:18:31 <skypers> <3
10:18:35 <skypers> thank you mauke
10:18:54 <skypers> or read . words
10:19:03 <skypers> [a] is in Read right?
10:19:12 <geekosaur> if a is
10:19:24 <skypers> yeah, sure
10:19:25 <flebron> read wants a String
10:19:38 <jmcarthur> flebron: yeah it looks like to define left and right you will sometimes need to rotate some elements from the other subtree into the result, to make it the right size. even then i'm not 100% sure it will work every time, and you might end up having to just return a Maybe subtree
10:19:42 <flebron> words gives you a [String], so you can't unify
10:20:15 <flebron> jmcarthur: Is there a way to say "-> AVLNode m a", where m changes in each definition, a-la GADTs?
10:20:19 <jmcarthur> flebron: you can indeed return trees of some unspecified height by using an existential type
10:20:30 * flebron would like to know more about this
10:20:56 <jmcarthur> flebron: data Node a = forall n. Node (AVLNode n a)
10:21:05 <jmcarthur> flebron: so just return a Node instead of an AVLNode
10:21:30 <flebron> :o Could this work during insertion, when I sometimes need to rotate things?
10:21:45 <flebron> Or does wrapping it in a Node make ghc discard the type information?
10:21:53 * hackagebot set-cover 0.0.4 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  http://hackage.haskell.org/package/set-cover-0.0.4 (HenningThielemann)
10:21:59 <flebron> (Which I'll need to prove that the rotated thing is indeed an AVL tree)
10:22:25 <jmcarthur> flebron: ghc can't know the actual type when pattern matching, or else that would defeat the purpose
10:22:53 <jmcarthur> flebron: so yes, you will have to come up with some bookkeeping scheme to prove to ghc that your operations are legit
10:23:21 <jmcarthur> flebron: on the plus side, it's still that GADT underneath the existential type wrapping constructor, so you still reveal type information to GHC when you pattern match on it
10:23:45 <jmcarthur> flebron: just not always everything
10:24:06 <flebron> Well, enough info to know what the heights of my subtrees are.
10:24:28 <jmcarthur> i don't think so, unless you pattern match all the way to the leaves
10:25:13 <Ankhers> I have a function of type String -> String. I am attempting to replace all occurrences of the letter "T" with "U". So I created a function of String -> String that will return "U" if you pass in a "T". No matter what I do, I am getting type errors. 'couldn't match type Char with [Char]' for the second argument of map. What am I doing wrong?
10:25:14 <jmcarthur> flebron: in any case, probably the best way forward is to experiment
10:25:55 <jmcarthur> Ankhers: maybe you are using string literals instead of character literals?
10:25:58 <jmcarthur> Ankhers: hard to tell without code
10:26:05 <jmcarthur> Ankhers: lpaste it
10:26:32 <flebron> jmcarthur: Thank you :)
10:26:34 <jmcarthur> Ankhers: oh, right, that is the problem after all. i can tell from your description
10:26:44 <jmcarthur> Ankhers: you want your function to have this type:  Char -> Char
10:26:52 <Guest9431> i need help finding support for plexconnect anyone?
10:27:14 <jmcarthur> Ankhers: type String = [Char], so mapping over a String should be transforming Chars
10:28:48 <skypers> is there a function like delete but that takes a predicate instead of a value?
10:29:06 <Ankhers> jmcarthur: You are awesome. Sorry for the lack of paste.
10:29:18 <skypers> like removing the first element that satisfies the predicate
10:29:37 <jonasw> :t deleteBy
10:29:38 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
10:29:46 <skypers> it’s not what I want
10:29:50 <jonasw> Oh
10:30:00 <mauke> @hoogle (a -> Bool) -> [a] -> [a]
10:30:00 <skypers> I want (a -> Bool) -> [a] -> [a]
10:30:01 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
10:30:01 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
10:30:01 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
10:30:59 <skypers> filter is not really what I want
10:31:10 <skypers> because it will pass through the whole list
10:31:46 <FreeFull> skypers: It wouldn't be too hard to write
10:32:11 <Saizan> skypers: deleteBy should work
10:32:13 <skypers> it’s surprising it’s not in Data.List
10:32:22 <skypers> Saizan: ?
10:32:38 <FreeFull> Ankhers: You should have made a Char -> Char function instead, that makes 'T' into 'U'
10:32:45 <Saizan> > deleteBy (\_ -> even) undefined [1..3]
10:32:46 <lambdabot>  [1,3]
10:32:47 <skypers> give me an   example then to delete the first occurence that is either a '.'' or a '/'
10:33:16 <skypers> this function is really weird
10:33:22 <FreeFull> Ankhers: If you take a look at map's type and keep in mind that String is [Char], you'll see why
10:33:25 <skypers> why does it take an extra value?
10:33:38 <skypers> it could be embedded in the predicate
10:33:46 <Saizan> > deleteBy (\_ c -> c `elem` "./") undefined "foo,bar"
10:33:47 <lambdabot>  "foo,bar"
10:33:57 <Saizan> > deleteBy (\_ c -> c `elem` "./") undefined "foo.bar"
10:33:58 <lambdabot>  "foobar"
10:34:16 <skypers> I see
10:34:17 <skypers> thank you
10:34:19 <Saizan> skypers: yeah, it's a bit weird, but it's a generalized delete
10:34:20 <Rylee> @hoogle deleteBy
10:34:21 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:34:30 <Rylee> hmm
10:34:30 <Saizan> delete = deleteBy (==)
10:34:42 <Ankhers> FreeFull: Aye, I have since realized this. I do not understand how I missed that. Thank you.
10:35:02 <Rylee> what's the second argument to deleteBy?
10:35:03 <Rylee> wait.
10:35:03 <skypers> :t groupBy
10:35:04 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
10:35:05 <Rylee> @src deleteBy
10:35:06 <lambdabot> deleteBy eq x []        = []
10:35:06 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
10:35:13 <skypers> this one is ok
10:35:16 <FreeFull> :t deleteBy
10:35:17 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
10:35:55 <Rylee> Oh, I get it now, okay cool
10:36:22 <Rylee> > delete 2 [1, 2, 3, 4, 5, 2]
10:36:23 <lambdabot>  [1,3,4,5,2]
10:38:27 <skypers> :t sortBy
10:38:28 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
10:38:51 <skypers> deleteBy is not that great
10:39:50 <td123> is there a cleaner way of writing solvable minD startD maxD xs = not . null $ solutions minD startD maxD xs
10:39:57 <skypers> its correct version could be emulated with deleteBy' p = deleteBy (flip const p) undefined
10:40:14 <td123> what I'm wondering is if there is a way to remove the need to specify the parameters
10:40:26 <jmcarthur> skypers: delete = deleteBy (==); group = groupBy (==); sort = sortBy compare   -- they are all pretty consistent
10:40:47 <skypers> jmcarthur: well
10:40:59 <skypers> “delete by” sounds like “delete using a predicate”
10:41:03 <skypers> not a predicate and a value
10:41:18 * jmcarthur points to the consistency of naming, too
10:41:25 <skypers> and as I said, the value could be embedded in the predicate
10:41:39 <Saizan> deleteBy fits the pattern of the others *By, but it's quite awkward if you look at it
10:41:41 <jmcarthur> embedding the value in the closure would not be consistent though
10:41:43 <donri> deleteBy sounds like filter (not . f)
10:41:47 <benzrf> @pl \f x y -> z (f x) (f y)
10:41:47 <lambdabot> flip =<< (((.) . z) .)
10:41:51 <jmcarthur> i do agree that it looks weird by itself
10:41:51 <benzrf> hrm
10:42:37 <skypers> maybe I can get rid of it
10:42:42 <benzrf> why are hetereogeneous lists by typeclass considered a bad idea?
10:43:12 <skypers> I’m using getDirectoryContents
10:43:23 <skypers> and I filter its output with that:
10:43:24 <skypers> filterDir = deleteBy (\_ d -> not $ d `elem` [".",".."]) undefined
10:43:42 <skypers> it’s not really lisible to me
10:44:45 <c_wraith> benzrf: because all you've done is the same thing as putting a bunch of records into a list, except you've made it complicated
10:44:56 <benzrf> a bunch of records?
10:45:03 <c_wraith> yes, the typeclass dictionaries
10:45:10 <benzrf> ?
10:45:24 <benzrf> what is a typeclass dictionary
10:45:38 <c_wraith> typeclasses are implemented as dictionaries of functions that are passed around implicitly
10:45:50 <benzrf> ahihi:
10:45:51 <benzrf> *ah
10:46:19 <benzrf> u see a while back I was writing a simple lisp impl
10:46:54 <benzrf> and i wanted to have different lisp data types be diff haskell data types, but with one typeclass
10:46:54 <c_wraith> So all you're doing is creating a list of those dictionaries, except making the implementation more conceptually complicated
10:47:10 <benzrf> but then I could not have a list of them, which is necessary ofc
10:47:35 <benzrf> so i ended up making the worst possible decision, which was making the separate types and then making a generic wrapper type that was a sum of wrappers around each regular type
10:47:38 <benzrf> >_>
10:47:48 <JuanDaugherty> ofc?
10:47:56 <benzrf> of course
10:47:59 <JuanDaugherty> ah
10:48:03 <c_wraith> well, that approach isn't the worst possible
10:48:10 <c_wraith> Because it enables runtime type checking
10:48:14 <benzrf> it ended up bugging the hell out of me
10:48:34 <c_wraith> and you need runtime type checking in lisp, anyway
10:48:42 <benzrf> the amount of wrapping and unwrapping probably multipled the number of characters in the code by 1.5 alone
10:49:54 <skypers> seriously this deleteBy thing makes me sick
10:49:59 <c_wraith> Sometimes it's worth making constructor names 1 character. :)
10:50:21 <skypers> I really wonder why it’s called that way, because the argument “we can then state delete = deleteBy” is kinda stupid to me
10:50:33 <skypers> + (==)
10:51:32 <skypers> btw
10:51:45 <c_wraith> skypers: Do you hate code reuse or something?
10:51:51 <skypers> if deleteBy was :: (a -> Bool) -> [a] -> [a]
10:51:59 <skypers> we could state that delete = deleteBy . (==)
10:52:10 <c_wraith> That would be filter, not deleteBy
10:52:21 <skypers> ?
10:52:25 <skypers> no
10:52:32 <skypers> filter traverses the whole list
10:52:41 <skypers> delete stops at the first occurence
10:56:26 <skypers> let deleteBy' :: (a -> Bool) -> [a] -> [a]; deleteBy' _ [] = []; deleteBy' p (x:xs) = if p x then xs else x : deleteBy' p xs
10:56:36 <skypers> @let deleteBy' :: (a -> Bool) -> [a] -> [a]; deleteBy' _ [] = []; deleteBy' p (x:xs) = if p x then xs else x : deleteBy' p xs
10:56:38 <lambdabot>  Defined.
10:56:48 <skypers> @let delete' x = deleteBy' (==x)
10:56:50 <lambdabot>  Defined.
10:56:57 * hackagebot hoogle 4.2.27 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.27 (NeilMitchell)
10:56:57 <skypers> > delete' 3 [1..10]
10:57:00 <lambdabot>  [1,2,4,5,6,7,8,9,10]
10:57:00 <td123> when declaring a type with a type variable, is there a way I can constrain the variable to a type class?
10:57:14 <skypers> to me deleteBy' is here seriously better
10:57:19 <benzrf> td123: i believe that is gadts
10:57:21 <benzrf> but i am not sure
10:57:30 <skypers> and c_wraith, I reuse code ;)
10:57:33 <benzrf> td123: you can declare a constraint on an instantiation
10:57:41 <c_wraith> td123: in general, it's been determined that that's mostly an antifeature
10:58:12 <benzrf> td123: you can specify that your type is only an instance of Monad when the variable is a Functor, or someting
10:58:20 <benzrf> td123: but you cannot keep people from putting non functors in it
10:59:19 <skypers> no one around deleteBy ?
10:59:22 <skypers> :t deleteBy'
10:59:23 <lambdabot> (a -> Bool) -> [a] -> [a]
10:59:36 <skypers> isn’t there a way to add that to Data.List?
10:59:44 <skypers> please, it’s christmas eve.
10:59:45 <pyon> Just wondering, is there anything on "base" to generate random values, or do I absolutely need to use the stuff from System.Random?
11:00:04 <c_wraith> pyon: nope, random was pulled out of base intentionally.
11:00:08 <benzrf> pyon: referential transparency innit
11:00:21 <pyon> c_wraith: Ah, okay, thanks!
11:00:29 <c_wraith> pyon: note that the quality of random numbers matters for many uses, and System.Random is not good quality
11:01:09 <benzrf> cat /dev/random
11:01:16 <pyon> c_wraith: I do not particularly care about quality in this case. The main reason I want something from "base" is that I want to show an example on ideone.
11:01:44 <td123> benzrf: thanks
11:01:49 <benzrf> td123: yup :)
11:02:05 <td123> benzrf: gadts look like overkill for my need but I will keep looking
11:02:13 <benzrf> td123: whats the use case?
11:03:04 <td123> benzrf: I have 4 variables that describe a problem, and I would like to store them into a data type, they should all be the same class (Num a)
11:03:48 <benzrf> data Foo a = Bar a a a a
11:03:49 <jonasw> pyon: You could use codepad too http://codepad.org/0Kgk9q8N
11:05:03 <pyon> jonasw: Does codepad provide access to more packages beyond "base"? If so, I am switching.
11:05:17 <pyon> jonasw: oh, nice, ty :-)
11:06:16 <td123> benzrf: right, but I wanted to constrain a to Num :)
11:06:21 <benzrf> why?
11:06:25 <benzrf> just specify that in your function
11:06:35 <benzrf> foo :: Num a => Foo a -> whatever
11:06:48 <td123> hmm ok
11:07:17 <td123> I will give that a shot
11:11:34 <marshjello> If I want to do something with internet security, do I learn haskell?
11:11:43 <benzrf> marshjello: wat?
11:12:01 <marshjello> I want to build a security system
11:12:13 <benzrf> you mean like an antivirus?
11:12:13 <marshjello> revolutionize anti virus
11:12:15 <marshjello> yeah
11:12:18 <klrr_> does haskell got a equaliant to clojure's nrepl?
11:12:38 <benzrf> marshjello: i dont see why you couldnt use haskell
11:12:40 <benzrf> its up to you
11:12:46 <L8D> klrr_: mghci
11:12:48 <L8D> nghci*
11:12:49 <benzrf> whats your big idea anyway?
11:14:29 <L8D> marshjello: Here's how to revolutionize anti-virus:
11:14:34 <L8D> Use linux
11:14:39 <L8D> BOOM!
11:14:49 <L8D> The viruses just disappear
11:15:01 <marshjello> does it really?
11:15:01 * benzrf hi fives L8D 
11:15:05 <benzrf> marshjello: yes
11:15:14 <marshjello> what if i purposely open a virus on linux? woudl that not affect it?
11:15:16 <benzrf> marshjello: nobody targets gnu/linux because it has 1% market share
11:15:27 <benzrf> marshjello: if you can find a virus intended for linux then it would affect it probably
11:15:30 <benzrf> but those barely exist
11:15:33 <L8D> Also, because linux is hard as fuck to penetrate
11:15:35 <benzrf> gnu/linux has 1% market share
11:15:44 <benzrf> L8D: eh
11:15:48 <L8D> There are tons of viruses for linux because they target servers
11:15:52 <benzrf> userspace is plenty exploitable
11:16:05 <benzrf> you can steal peoples credit card info without needing root
11:16:13 <L8D> But they only work under special conditions that they were made for
11:16:13 <benzrf> you can infect their bashrc without needing root
11:16:16 <klrr_> L8D: you have a link, google doesnt find anything with that name?
11:17:02 <L8D> klrr_: Sorry, I'm mistaken...I'm thinking about nirb
11:17:27 <L8D> Though you could probably hack one together with an encrypted socket
11:17:34 <L8D> or ssh
11:17:41 <td123> benzrf: thanks, i managed to write my previously long line into: solvable = not . null . solutions
11:17:49 <benzrf> ;p
11:17:59 <td123> much cleaner
11:18:14 <benzrf> i find it all too easy to outwit yourself in haskell
11:18:29 <ocharles> mm_bureau / mm_freak_ : Odd idea occured to me... does it make sense to put user input in the session type?
11:18:29 <L8D> benzrf: the only way something can infect a bashrc is if the user runs a script they downloaded
11:18:42 <ocharles> Giving Wire (Timed NominalDiffTime SDLInput) or something
11:18:58 <benzrf> td123: creating new adts and doing fancy type magic all over the place is the haskell equivalent of Making Everything A Class in oop
11:19:07 <benzrf> *abusing inheritance actually probly
11:38:14 <jmcarthur> bennofs: are you saying that creating many adts is a code smell? don't think i'd ever heard that before
11:38:31 <jmcarthur> i don't think i agree, if so
11:39:03 <ocharles> How much does it "cost" me to do  Vector.fromList <$> unfoldM foo  with unfoldM :: IO (Maybe a) -> IO [a] ? Do I pay for having [a] as my intermediate data type?
11:39:52 <Saizan> ocharles: you will get that list built in memory, yep
11:39:57 <jmcarthur> ocharles: yes. it is very unlikely that fusion is possible, unless you defined unfoldM with stream fusion in mind
11:40:08 <ocharles> Hmm
11:40:14 <ocharles> Would I be better off writing my own loop and using Vector.append or something then?
11:40:17 <jmcarthur> ocharles: and also, i guess, made your own rewrite rule
11:40:35 * jmcarthur pulls up the vector haddocks
11:40:38 <Saizan> jmcarthur: can stream fusion handle IO?
11:40:55 <jmcarthur> yes
11:41:11 <jmcarthur> vector's flavor of stream fusion is monadic
11:41:21 <jmcarthur> necessary to support array recycling
11:41:32 <Saizan> nice
11:41:37 <jmcarthur> see Data.Vector.Fusion.Stream.Monadic
11:42:29 <ocharles> Hmm, Data.Vector.Fusion.Stream.Monadic has an unfoldM
11:42:48 <jmcarthur> yup
11:42:56 <jmcarthur> would be nice to port that over to the other vector modules
11:42:56 <ocharles> should I be doing that and then turning it into a Vector?
11:43:08 <jmcarthur> that's what i would do, if i really wanted the fusion
11:43:34 <ocharles> i'll admit I'm being a little OTT, but I'd like to pay for as little as possible
11:44:08 <jmcarthur> all i can think of for that is Observational Type Theory...
11:44:30 <hiptobecubic> over the top?
11:44:33 <jmcarthur> ah!
11:44:34 <ocharles> yea :)
11:44:45 <jmcarthur> over the top is what i do best
11:44:47 <ocharles> 'foo' in this case is 'SDL.pollEvent', so it's going to be a list of like two elements anyway... but this seems some knowledge worth knowing about
11:45:57 <jmcarthur> FYI, unfold is one of the most fundamental operations for stream fusion
11:46:07 <jmcarthur> so it has a very simple implementation.
11:46:18 <jmcarthur> and it's a shame that unfoldM isn't available outside of that module :(
11:46:55 <ocharles> Sounds like that's a good patch for me to make
11:47:02 <jmcarthur> huh, it's interesting that it's a right fold...
11:47:04 <ocharles> Should I run proposals like this past libraries?
11:47:10 <ocharles> (the libraries ml)
11:47:22 <jmcarthur> oh i see why. generating a stream. duh
11:47:37 <ocharles> you say duh, but it's not clear to me why it's only right :)
11:47:51 <ocharles> because it could be infinite?
11:48:01 <jmcarthur> streams are "lazy" in a sense anyway
11:48:10 <jmcarthur> they are just producers
11:48:28 <jmcarthur> and yes, it could be infinite
11:48:28 <jmcarthur> i was just mixing up streams and arrays is all
11:48:48 <ocharles> ok
11:49:09 <jmcarthur> anyway, it seems to me that this is such a clear change that there's basically no point in putting it up for vote. i would just issue a pull request on github (i think it's on github...)
11:49:35 <jmcarthur> i consider it almost on the level of a bug fix
11:49:45 <marshjello> can you be a haskelll literate but not know C++ at all?
11:49:48 <henk> I’m trying to get to terms with GetOpt. The function getOpt returns a list of flags given in the arguments (as in http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Console-GetOpt.html#g:3) so I get something like [Verbose,InFile "some/file",OutFile "-i"]. How do I get "some/file" out of there?
11:49:55 <jmcarthur> marshjello: umm... yes?
11:49:58 <marshjello> I'm going to start learning/reading haskell today
11:50:12 <jmcarthur> marshjello: C++ is definitely not a prerequisite for learning Haskell
11:50:30 <kqr> jmcarthur, some people would argue you will find it easier learning haskell if you don't know c++ (or similar languages)
11:50:35 <ocharles> jmcarthur: Ok. I'm going to open an issue and say "I'd like to try and solve this, if people agree it's a bug that we don't have this function"
11:50:42 <jmcarthur> kqr: indeed
11:50:46 <marshjello> good, i thought I needed C++ all this time
11:51:08 <kqr> jmcarthur, oh i was going to direct that to marshjello. sorry!
11:51:11 <jmcarthur> ocharles: sounds fine to me, although i wouldn't quite phrase it as literally a bug
11:51:32 <ocharles> sure
11:52:20 <jfeltz> marshjello: C++ and Haskell are apples and oranges, or arguably, model-T ford vs 2014 bugatti
11:52:23 <henk> It seems all examples for GetOpt leave that part of how to use ReqArgs properly out ):
11:52:29 <marshjello> ALl these years I just thought everyone had C++ as a backbone like English grammar
11:53:02 <marshjello> I mean C++ just doesn't interst me. but it woudl be nice if i could use a more refined method to code
11:54:57 <danilo2> Not a question - just a notice: It makes really no sense, that Parsec has got hardcoded SourcePos data type and it counts only line and column number (we cannot count number of current character nor change the setting, that tab is 8 characters) - this is simply stupid -.-
11:55:00 <hiptobecubic> The problem with C++ is it doesn't solve the problems it solves.
12:00:28 <henk> https://github.com/ryo1kato/haskell-getopt-learning/blob/master/main.hs Taking this simple getOpt code as an example: how would one get the interval given as an argument to the program?
12:07:15 <pavonia> henk: [i | Interval i <- fst result] should do it
12:08:21 <SLi> Does FFI somehow prevent concurrency from happening? I'm parsing POSIX regexps from parallel code, but it performs at sub-sequential speeds no matter what I do... (And it's my impression that the regex library implements some parts in c)
12:09:16 <jmcarthur> SLi: you need to build with -threaded, and the bindings need to be safe (which is the default, but it's no good if it explicitly says unsafe) or else the system calls need to be short enough that the concurrency isn't needed
12:09:31 <carter> C++ is compleicated
12:10:08 <jmcarthur> SLi: note also that the regex library might have some TLS that is making it impossible to use concurrently anyway
12:10:10 <carter> jmcarthur: for my matrix mult bindings, i'm setting things up so that on small matrices it does unsafe ffi, and above a certain size, switches to safe
12:10:18 <jmcarthur> SLi: such is the pain of many C libraries :(
12:10:27 <jmcarthur> carter: oh that sounds really nice
12:10:33 <carter> what do they gain by doing TLS?
12:10:48 <jmcarthur> carter: some regex libraries are just stateful like that
12:10:51 <carter> jmcarthur: idk if i told you, but i'm taking this week to write the start of a simple simple blas / lapack binding
12:11:01 <carter> github.com/wellposed/hopenblas
12:11:21 <carter> i'm also simplifying things by saying "you have to use openblas"
12:11:22 <carter> :p
12:11:33 <carter> rather than "anything that says its blas"
12:12:15 <carter> mind you, after I do the blas / lapack binding, i'm not interested in FFIing much more code for a while
12:12:17 <jmcarthur> carter: that is, i don't think they gain anything in particular
12:12:23 <carter> huh
12:12:26 <SLi> jmcarthur: OK. I think I'm using regex-posix, but need to look at my code to verify :) Kind of surprising if it turns out it cannot be used from multiple threads simultaneously...
12:12:28 <pavonia> danilo2: You can create you own position counting with use of the functions in module Prim, IIRC
12:13:19 <jmcarthur> carter: i think i said TLS when i meant just thread-unsafe, global state
12:13:43 <carter> jmcarthur: SLi  : regexposic does unsafe calls
12:13:46 <carter> http://hackage.haskell.org/package/regex-posix-0.95.2/src/Text/Regex/Posix/Wrap.hsc
12:13:55 <carter> grep for "foreign import ccall unsafe"
12:15:24 <carter> huh, regex.posix hasn't been touched in a year and ahalf
12:16:13 <SLi> carter: OK,  thanks.  That explains at least why I cannot get any benefit from parallelism... I wonder if there's a reasonable regex library that can parallelize (doesn't need to be posix).
12:16:24 <carter> SLi: not quite
12:16:36 <carter> unsafe calls don't prevent parallelism
12:16:48 <carter> they just block one of the "capabiliiteies"
12:16:56 <carter> from doing anything else until the call returns
12:17:20 <carter> SLi: wheres your code?
12:17:21 <SLi> Hmm.
12:17:47 <jmcarthur> but if you have several threads on one capability, they could all block, especially if the other capabilities are also too busy to pick them up
12:18:17 <jmcarthur> g2g
12:18:44 <carter> SLi: heres a quick way to figure out if thats the problem
12:18:50 <carter> cabal unpack regex-posix
12:18:59 <Taneb> Hmm
12:19:10 <carter> change all the foreign import unsafe to safe
12:19:14 <carter> and rebuild
12:19:18 <carter> and bench with that intead
12:19:22 <Taneb> Is (Int, Int -> Sprite) what I want?
12:19:26 <carter> for what?
12:19:32 <Taneb> No, it isn't
12:19:38 <Taneb> carter, sorry, I am thinking outloud
12:19:45 <carter> sok
12:20:25 <derekkadwell> Objective-c
12:21:01 <carter> derekkadwell: i'm sorry
12:21:08 <SLi> carter: http://sliedes.kapsi.fi/ollycalltrace.hs
12:21:19 <carter> SLi: cool
12:21:27 <carter> so it'd be fast to try that patched posix!
12:21:41 <SLi> carter: not sure if I'm doing things right, this being my first parallel haskell program :P
12:21:56 <skypers> http://fr.reddit.com/r/haskell/comments/1u6cx6/deleteby_type_signature_is_ill_to_me/
12:22:59 <carter> huh
12:23:46 <mr-> skypers: that is weird
12:23:48 * bennofs wondered why reddit was suddenly french
12:23:52 <skypers> mr-: what is weird?
12:24:18 <skypers> bennofs: arf, that’s weird indeed :D
12:24:31 <jle`> deleteBy seems to match more closely the semantics of delete
12:24:36 <jle`> as it is
12:24:49 <mr-> skypers: that it's french, and also deleteBy, I think
12:25:00 <skypers> http://www.reddit.com/r/haskell/comments/1u6cx6/deleteby_type_signature_is_ill_to_me/
12:25:00 <bennofs> deleteBy matches the pattern of all the other ...By functions: sortBy, groupBy,
12:25:06 <skypers> yeah
12:25:15 <skypers> and is not what it sounds to be
12:25:26 <skypers> with by function
12:25:39 <skypers> I can delete the first even number of a list
12:25:46 <skypers> > deleteBy' even [1..10]
12:25:47 <lambdabot>  [1,3,4,5,6,7,8,9,10]
12:25:58 <skypers> with deleteBy, it’s really ugly.
12:26:27 <skypers> > deleteBy (flip const even) undefined [1..10]
12:26:28 <lambdabot>  Occurs check: cannot construct the infinite type:
12:26:29 <lambdabot>    a0 = a0 -> GHC.Types.Bool
12:26:29 <lambdabot>  Expected type: a0 -> (a1 -> GHC.Types.Bool) -> a0 -> GHC.Types.Bool
12:26:29 <lambdabot>    Actual type: a0 -> (a1 -> GHC.Types.Bool) -> a0
12:26:33 <pavonia> @src deleteBy'
12:26:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:26:43 <skypers> pavonia: the source is here:
12:26:48 <skypers> http://lpaste.net/97833
12:26:54 <skypers> I just @let it
12:26:59 <skypers> a few minutes ago
12:27:06 <jle`> > filter (not . even) [1..10]
12:27:08 <lambdabot>  [1,3,5,7,9]
12:27:17 <pavonia> Oh, I see
12:27:22 <skypers> jle`: you’re wrong
12:27:29 <skypers> you removed all occurences
12:27:33 <mr-> bennofs: yes, but that is because all the other functions need ordering
12:27:47 <mr-> also, they don't have that extra argument
12:27:48 <bennofs> > uncurry (++) $ second tail $ break even [1..10]
12:27:49 <jle`> oh, it's the first
12:27:49 <lambdabot>  [1,3,4,5,6,7,8,9,10]
12:27:56 <mr-> but anyway.. nobody cares
12:28:03 <bennofs> mr-: nubBy?
12:28:06 <bennofs> @ty nubBy
12:28:07 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
12:28:35 <skypers> huh
12:28:38 <skypers> seriously
12:28:43 <skypers> you think it’s okay?
12:28:51 <skypers> you really think deleteBy is ok?
12:28:56 <jle`> if deleteBy was different
12:28:59 <jle`> it wouldn't follow the convention
12:29:01 <jle`> of sortBy, groupBy
12:29:03 <jle`> etc.
12:29:04 <skypers> ?!
12:29:04 <lambdabot> Maybe you meant: v @ ? .
12:29:06 <jle`> that would be more unexpected
12:29:16 <skypers> jle`: sortBy has a correct type signature
12:29:18 <bennofs> it is consistent
12:29:22 <skypers> it expects a predicate
12:29:27 <skypers> a binary one
12:29:32 <skypers> because when you SORT things
12:29:39 <skypers> you COMPARE them
12:29:45 <skypers> but when you DELETE things
12:29:57 <skypers> who the hell needs a binary function?
12:30:03 <mr-> bennofs: I don't agree with that logic.. when a predicate is enought it shouldn't take more imho
12:30:08 <bennofs> nubBy, deleteBy, deleteFirstBy, unionBy, intersectBy, groupBy, ... all follow the same pattern
12:30:08 <skypers> do you see my point?
12:30:27 <skypers> .
12:30:28 <jle`> i see your point, and the name suggests a predicate, but it just differs from the other "By" functions
12:30:36 <skypers> it’s the same NAME pattern
12:30:44 <skypers> but the semantics are broken
12:30:48 <jle`> sortBy lets you provide a custom comparison on which to sort
12:30:51 <bennofs> > deleteFirstBy (flip $ const . even) 0 [1,2,3,4]
12:30:52 <lambdabot>  Not in scope: `deleteFirstBy'
12:30:52 <lambdabot>  Perhaps you meant `deleteFirstsBy' (imported from Data.List)
12:30:54 <jle`> deleteBy lets you provide a custom comparison on which to delete
12:30:55 <skypers> jle`: then, just use my function
12:31:01 <bennofs> > deleteFirstsBy (flip $ const . even) 0 [1,2,3,4]
12:31:02 <lambdabot>  No instance for (GHC.Show.Show a0)
12:31:02 <lambdabot>    arising from a use of `M108152486881099483329974.show_M1081524868810994833...
12:31:02 <lambdabot>  The type variable `a0' is ambiguous
12:31:02 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:31:02 <lambdabot>  Note: there are several potential instances:
12:31:02 <skypers> deleteBy' takes a predicate
12:31:08 <skypers> and we follow the same By convention
12:31:08 <bennofs> > deleteFirstsBy (flip $ const even) 0 [1,2,3,4]
12:31:10 <lambdabot>  No instance for (GHC.Show.Show a0)
12:31:10 <lambdabot>    arising from a use of `M888368468281785786029983.show_M8883684682817857860...
12:31:10 <lambdabot>  The type variable `a0' is ambiguous
12:31:10 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:31:12 <lambdabot>  Note: there are several potential instances:
12:31:13 <skypers> what’s wrong?
12:31:36 <skypers> 21:27 < jle`> deleteBy lets you provide a custom comparison on which to delete
12:31:37 <skypers> no
12:31:38 <jle`> deleteBy compares every element to the element-to-be-deleted, and deletes the first one for which the comparison returns 'true'
12:31:39 <skypers> that’s wrong.
12:31:47 <bennofs> skypers: All by functions take the function of their typeclass (Eq => a -> a -> Bool, Ord => a -> a -> Ordering)
12:31:50 <skypers> it lets you provide a stupid _equality_ test
12:31:52 <skypers> not a predicate.
12:32:17 <jle`> delete compares every element to the element-to-be-deleted, and deletes the first one for which the comparison shows that they are equal
12:32:22 <skypers> 21:28 < jle`> deleteBy compares every element to the element-to-be-deleted, and deletes  the first one for which the comparison returns 'true'
12:32:26 <bennofs> > deleteBy (flip $ const True) 0 [1,2,3,4,5]
12:32:27 <lambdabot>  Couldn't match expected type `a0 -> GHC.Types.Bool'
12:32:27 <lambdabot>              with actual type `GHC.Types.Bool'
12:32:27 <jle`> deleteBy allows you to specify your custom comparison function
12:32:31 <skypers> I think it’s not the way it should be considered
12:32:40 <skypers> deleteBy delete something that doesn’t match a predicate
12:32:44 <jle`> delete does
12:32:49 <skypers> no equality test should be performs
12:32:53 <jle`> delete compares everything to the item given
12:32:58 <skypers> the implementation uses eq, that’s not ok to me
12:32:59 <bennofs> > deleteBy (const even) 0 [1,2,3,4,5]
12:33:00 <lambdabot>  [1,3,4,5]
12:33:01 <jle`> and deletes the first one for which the comparison is true
12:33:10 <jle`> deleteBy allows you to specify your custom comparison function
12:33:23 <skypers> > deleteBy (const even) undefined [1..5]
12:33:24 <lambdabot>  [1,3,4,5]
12:33:26 <skypers> see?
12:33:29 <skypers> how it’s stupid.
12:33:42 <bennofs> > const even undefined 2
12:33:44 <lambdabot>  True
12:33:58 <jle`> skypers: it looks stupid, but that's the only way it can match delete
12:34:05 <skypers> ?!!!
12:34:05 <lambdabot> Unknown command, try @list
12:34:07 <jle`> :t delete
12:34:07 <skypers> hey
12:34:08 <lambdabot> Eq a => a -> [a] -> [a]
12:34:09 <jle`> :t deleteBy
12:34:10 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
12:34:12 <jle`> :t sort
12:34:13 <skypers> have you heard or read my version?
12:34:13 <lambdabot> Ord a => [a] -> [a]
12:34:15 <jle`> :t sortBy
12:34:16 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:34:23 <skypers> > delete' 2 [1..10]
12:34:24 <lambdabot>  [1,3,4,5,6,7,8,9,10]
12:34:31 <skypers> it matches delete' as well
12:35:06 <bennofs> skypers: it doesn't. The convention is that Eq constraints get replaced by a -> a -> Bool
12:35:16 <jle`> compare the differences in the type signatures; both are the same function, except it has an (a -> a -> Bool) first
12:35:20 <jle`> :t delete'
12:35:20 <lambdabot> Eq a => a -> [a] -> [a]
12:35:23 <jle`> :t deleteBy'
12:35:23 <lambdabot> (a -> Bool) -> [a] -> [a]
12:35:26 <jle`> see?
12:35:29 <bennofs> skypers: I think your function is useful, but I wouldn't call it deleteBy
12:35:48 <skypers> bennofs: how would you call it?
12:35:54 <skypers> removeBy?
12:35:58 <skypers> it’s quite the same thing…
12:36:04 <bennofs> skypers: deleteWhen?
12:36:05 <skypers> deleteWhen?
12:36:08 <skypers> yeah
12:36:11 <jle`> sortBy, deleteBy, etc.By, all are the same function, with the same type signature, except with a (a -> a -> Bool) first.
12:36:11 <skypers> it’s quite the same thing to me
12:36:40 <pavonia> So is there a reason for the deleteBy type signature other than being consistent with the other *By functions?
12:36:52 <skypers> pavonia: I don’t think so
12:36:58 <skypers> and this the reason that makes me sad
12:37:00 <bennofs> deleteBy is not as useful as deleteWhen
12:37:09 <skypers> yes
12:37:14 <bennofs> but if you're going to provide deleteWhen, don't call it deleteBy
12:37:20 <skypers> ok
12:37:21 <skypers> sure
12:37:49 <jle`> bennofs sounds sensible to me
12:38:06 <jle`> it doesn't make any sense to break the *By convention for one single function
12:38:39 <danilo2> pavonia: I'm sorry I didnt saw your answer. How? SourcePosition is hardcoded - even Parser errors need it
12:38:59 <Ankhers> Can anyone tell me why the second method does not work? I thought that was how curried functions work. http://lpaste.net/97842
12:39:11 <jle`> also, all of the *By -> normal conversions are trivially point-free
12:39:20 <jle`> sort = sortBy compare
12:39:25 <jle`> delete = deleteBy (==)
12:39:33 <jle`> and point-free in the same manner
12:40:03 <mr-> Ankhers: the type signature is wrong
12:40:05 <jle`> union = unionBy (==)
12:40:07 <danilo2> pavonia: If SourcePos would be abstract (a type class), then we could define not only counting mechanisms, but also memoizing of last character for example, which would be very needed in my current compile
12:40:12 <bennofs> jle`: well, that delete = deleteBy' . (==)
12:40:26 <mr-> Ankhers: toRNA' still has type String -> String
12:40:37 <jle`> bennofs: it's different, though
12:40:57 <jle`> it's the one out of all of them that needs the composition?
12:41:39 <jle`> if i had been doing union = unionBy (==), sort = sortBy compare, i would be surprised if delete /= deleteBy (==)
12:42:09 * hackagebot force-layout 0.3 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3 (BrentYorgey)
12:42:09 <Ankhers> mr-: That makes sense. Thank you!
12:43:21 <pavonia> danilo2: The type of SourcePos is fixed but not the way the next position is calculated. Have a look at the token and token Prim functions
12:45:45 <danilo2> pavonia: Ah, so this fixes the problem with custom tab width, but does not fix with 2 others: 1) I want to store the current character count (not only column and line) 2) I want to store the last character parsed
12:46:03 <flebron> Semi-offtopic: Has anyone installed ghcmod-vim?
12:46:14 <donri> flebron: i have
12:47:15 <flebron> donri: I may just be dumb but... how does one install this? I've only ever installed pathogen plugins. I think I installed vimproc by executing the 3 commands in https://github.com/Shougo/vimproc.vim , but now I don't know what to do with the ghcmod .zip file :s
12:48:11 <flebron> The GitHub page says "ghcmod.vim contains ftplugin.". There's two ghcmod.vim files, one in each of after/ and autoload/.
12:48:45 <pavonia> danilo2: I guess that's possible with use of the user state, but you probably would have to write your own tokenizing functions then
12:48:51 <donri> flebron: cd ~/.vim/bundle; git clone https://github.com/Shougo/vimproc.vim && make -C vimproc.vim && git clone https://github.com/eagletmt/ghcmod-vim
12:49:06 <donri> flebron: cabal install ghc-mod
12:49:29 <flebron> Yep, ghc-mod is cabal-install'd.
12:49:55 <merijn> edwardk: So, what's the selling point that makes trifecta better than Parsec?
12:50:08 <donri> flebron: you install vimproc and ghcmod-vim like any other pathogen-compatible repo. just need to run `make` in the vimproc repo after cloning that's all
12:50:26 <danilo2> pavonia: of course - then it is possible, but then Ihave to code **a lot** of things - tokenizer, stram instances, conversion to Parsec hardcoded SourcePos (to display errors) etc. Do you thing there are any contrarguments for making this a type class?
12:51:09 <donri> merijn: colorful error messages with column pointers and (originally) syntax highlighting (though seems to have been lost in a refactor)
12:51:43 <pavonia> danilo2: No, I don't think so
12:51:46 <flebron> donri: Ah, thanks!
12:51:48 <donri> merijn: and the rope stuff which i'm not quite sure what it's for but i think random access or something
12:54:01 <donri> flebron: lastly you probably want at least let g:ghcmod_ghc_options = ['-isrc'] and seems you have to cabal install [--only-dependencies] [--enable-tests] because ghc-mod wasn't working for me if test deps weren't installed (even if not configured with tests)
12:54:10 <donri> i should report that ...
12:54:10 <merijn> donri: The documentation of rope can be described as mildly crytic, yes :)
12:54:17 <danilo2> pavonia: Hmm I'm thinking about making a patch to Parsec. It would be even compatible with Parsec 3, because if we look at the type of (ParsecT s u m a), then "m" is hardcoded right now as (State SourcePos), so the signature of ParsecT would not change
12:54:18 <donri> merijn: :)
12:55:04 <donri> flebron: uh that was meant to be  cabal install [--only-dependencies] --enable-tests  ie. the first flag optional but not the second
12:55:25 <Fritiof> So what is the status of Haskell on smartphones?
12:55:32 <danilo2> pavonia: do you think, there is a chance such patch to be accepted (it is pretty big change) - or only some special people are allowed to make patcs to Parsec?
12:55:35 <donri> flebron: and i mean for the project you're hacking on, not for when installing ghc-mod
12:55:48 <henk> pavonia: Thank you!
12:56:24 <pavonia> danilo2: I don't know. I suggest to first start a discussion on the mailing list about that
12:56:59 <danilo2> pavonia: I have sent today morning mail to the maintainers. If they do not reply, I'll start the discussion. Thank you :)
12:57:09 <FliPPeh> Is there some way to import a certain version of a module?
12:57:11 * hackagebot diagrams-contrib 1.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1 (BrentYorgey)
12:57:13 * hackagebot diagrams 1.0.0.1 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.0.0.1 (BrentYorgey)
12:57:37 <FliPPeh> GHC keeps yelling at me because Data.Vector.Vector Value does not match vector-0.10.0.1:Data.Vector.Vector Value
12:57:40 <FliPPeh> Which is ridiculous
12:57:59 <merijn> FliPPeh: It means two bits of your program are using different versions of vector
12:58:05 <FliPPeh> I know
12:58:10 <FliPPeh> Hence my original question
12:58:16 <merijn> FliPPeh: They are not binary compatible
12:58:26 <merijn> FliPPeh: Are you using cabal to build your code?
12:58:37 <FliPPeh> Nope
12:58:57 <merijn> FliPPeh: Might wanna start, then. Cabal will try to select versions of installed libraries that are compatible
12:59:10 <merijn> (or complain that it can't find any mutually compatible versions)
13:07:12 * hackagebot diagrams-postscript 1.0.0.2 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.0.2 (BrentYorgey)
13:09:55 <erisco> how do you access the inner monad with monad transformers? for example StateT
13:11:09 <geekosaur> lift
13:11:17 <erisco> :t lift
13:11:18 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:12:25 <merijn> erisco: That, or use the mtl stuff
13:12:49 <merijn> erisco: Control.Monad.State has a "MonadState s m" typeclass that lets you access a state lower in your transformer stack
13:13:01 <merijn> :t Control.Monad.State.get
13:13:02 <lambdabot> MonadState s m => m s
13:13:21 <erisco> I just crashed ghc =\
13:14:19 <jle`> =\
13:14:26 <erisco> I have no idea how they expect me to report it as a bug
13:15:27 <erisco> but it happened when I added 'lift' to my code :)
13:15:50 <SLi> I wonder what's the deal with regex-pcre and regex-pcre-builtin packages. They both export Text.Regex.PCRE.
13:16:36 <geekosaur> the latter has its own copy of the pcre c libs, for convenience on windows
13:16:47 <SLi> Ah. Thanks :)
13:17:27 <SLi> If I have both installed, can I somehow uninstall or deregister one with cabal?
13:17:36 <geekosaur> ghc-pkg unregister ...
13:17:43 <SLi> Thanks :)
13:19:04 <nedbat> i'm a haskell newb, though experienced in other languages. I'm doing exercises in Real-World Haskell.  I don't understand why this is a parse error: http://lpaste.net/97845
13:19:27 <nedbat> and now I do! :)
13:19:33 <skypers> btw
13:19:48 <skypers> why do we use *When convenion instead of *If?
13:19:49 <jle`> nedbat: congrats!
13:19:54 <skypers> like splitIf
13:20:12 <skypers> convention*
13:20:12 <nedbat> jle`: now I just need to figure out the 20-line error message I got when I added the parens… :(
13:21:03 <jle`> error messages in haskell are an art :P it's like learning a language within a language
13:21:48 <skypers> C++ has such a convention, and it’s actually pretty nice
13:21:56 <skypers> like find_if
13:22:07 <skypers> count_if
13:22:37 <nedbat> jle`: yes, I always thought more detail in error messages would be a good things.  Then Haskell… :)
13:24:13 <jle`> nedbat: haha. don't worry, you'll get the hang of it, i promise
13:24:50 <SLi> Turns out regex-pcre is clearly the fastest regex solution for me (faster than posix regexs by a factor of 4 or so). Still didn't manage to parallelize, but it's tolerably fast now for my use case.
13:25:39 <SLi> While regex-tdfa is slower than -posix.
13:26:19 <Sgeo> Ok.... warp --help (from warp-static) has warp calling itself the args program
13:26:21 <Sgeo> On windows
13:26:22 <Sgeo> wtf
13:39:10 <JuanDaugherty> holiday overload on freenode prolly
13:40:13 <threestrikes>  I am practicing with the ghci and attempting to do the doubleMe  function from "Learn you a Haskell" .  Once I have it loaded and attempt to use it works fine when I type the command correctly.   My issue is if I'm forced to use the backspace button for any reason the terminal doesn't recognize it.  Is this normal  to not be able to edit commands after a function is loaded, if so can someone explain?
13:40:55 <sipa> what terminal?
13:41:19 <skypers> is there something in Read that can be read through "1u"?
13:41:21 <threestrikes> it's prompted with *main>
13:41:24 <skypers> for unsigned type
13:41:40 <sipa> threestrikes: that's ghci; what terminal are you running it in?
13:42:15 <threestrikes> linux terminal in ubuntu
13:43:15 <nedbat> threestrikes: does ctrl-h work?
13:43:53 <threestrikes> it just echoed ^H
13:45:34 <danilo2> Errr, why there is no instance (Monoid Int) in the standard library? I was sure it is until I get error telling me the other thing
13:46:01 <skypers> oh…
13:46:09 <skypers> > read "1." :: Float
13:46:10 <lambdabot>  *Exception: Prelude.read: no parse
13:46:20 <skypers> I thought it would have worked
13:46:46 <mauke> danilo2: what would it do?
13:47:10 <danilo2> mauke: mempty :: Int should be 0 and mappend should be (+)(
13:47:16 <mauke> danilo2: why?
13:47:30 <skypers> yeah why?
13:47:34 <skypers> it’s Plus
13:47:36 <skypers> not Int
13:47:41 <mauke> @let instance Monoid Int where mempty = maxBound; mappend = max
13:47:43 <lambdabot>  Defined.
13:47:50 <mauke> > 1 <> 2 :: Int
13:47:52 <lambdabot>  2
13:48:04 <mauke> oops
13:48:06 <mauke> @undefine
13:48:06 <lambdabot> Undefined.
13:48:17 <danilo2> mauke: because it fills the rules and is intuitive: mappend mempty mempty === mempty
13:48:27 <threestrikes> I should be able to use the backspace button after loading a function in GHCI, correct?
13:48:34 <jle`> danilo2: hm
13:48:34 <mauke> danilo2: so does 1/(*) and minBound/max and maxBound/min
13:48:43 <jle`> it makes more sense for me that mempty is 1 and mappend is *
13:49:32 <danilo2> skypers, jle`, mauke: Ahh Plus! I forgot about it
13:49:48 <danilo2> skypers, jle`, mauke: Ok, you are right, I was a little biased with my use case :)
13:49:59 <danilo2> skypers, jle`, mauke: thank you :)
13:50:42 <jle`> threestrikes: hm i had a similar problem when starting out
13:50:48 <jle`> how are you building ghc?
13:51:05 <threestrikes> Synaptic
13:51:30 <threestrikes> I used haskell-platform
13:51:33 <c_wraith> oh.  Yeah, all those special builds from package managers tend to break things.
13:51:37 <skypers> danilo2: np, and you also have Product, and so on…
13:51:49 <jle`> yeah if you're on ubuntu, i recommend you build from source
13:51:53 <jle`> make sure to use checkinstall or something
13:52:04 <jle`> so that it's registered as a package so you can remove it/uninstall when you want cleanly
13:52:11 <threestrikes> ok I'll deinstall it all and start from scratch
13:52:19 <c_wraith> forget building from source, just install from the pre-packaged binaries on haskell.org/ghc
13:52:30 <jle`> :o
13:52:55 <jle`> that makes sense
13:52:59 <c_wraith> You should only build from source if you want HEAD or want to modify GHC
13:53:20 <threestrikes> no where that advanced yet lol
13:53:24 <threestrikes> near*
13:53:48 <jle`> if that still doesn't work
13:54:05 <danilo2> skypers: yes I know - I was reading the "Learn the Haskell for great God" months ago and I remember it was described there - I forgot about it :) Thank you for remindering me :)
13:54:09 <jle`> make sure that you have libreadline-dev and stuff like that from synaptic
13:54:18 <threestrikes> I just needed confirmation before I started ripping in to this thing for no reason
13:54:23 <threestrikes> thanks for the help
13:54:42 <c_wraith> jle`: ghci doesn't use readline anymore.  but you will need libgmp's -dev package
13:54:55 <nedbat> Sorry for the OT question, but in the lpaste.net pastebin, what is the channel picker for?
13:55:03 <Aetherspawn> https://github.com/Gabriel439/Haskell-Pipes-Library/commit/5110b4696c65655429f6ba40dcbbbe98b817e522
13:55:05 <jle`> c_wraith: good to know
13:55:05 <Aetherspawn> that's really sadface
13:55:12 <Aetherspawn> I wonder why they didn't add INLINABLE
13:55:13 <c_wraith> nedbat: if you select a channel, it notifies that channel when you post the paste
13:55:41 <jle`> danilo2: Haskell is indeed for great God
13:56:07 <nedbat> c_wraith: hmm, i selected #haskell when I made my paste, I didn't see the notification (I think?)
13:56:13 <danilo2> jle`: heh :) misspeling :P
13:56:33 <jle`> nedbat: it doesn't work sometimes
13:56:35 <c_wraith> nedbat: well, it might be broken. :)
13:56:35 <danilo2> jle`: *misspelling
13:56:38 <nedbat> jle`: :)
14:02:59 <jmcarthur> Aetherspawn: INLINABLE is newer than the module. probably just wasn't put there because it didn't exist at the time
14:03:53 <Aetherspawn> hm
14:04:20 <jmcarthur> i wonder how much additional space the .hi files would take if base was just built with -fexpose-all-unfoldings
14:05:29 <merijn> Any hints where I would start looking if I want to study the various ASTs GHC uses?
14:06:21 <conehead> Just out of curiosity: does anyone have an example of the usefulness of Monoids like All or Sum? I'm (probably naively) not immediately understanding their usefulness.
14:06:55 <conehead> (I understand the usefulness of other Monoids, just not these in particular)
14:07:29 <Cale> merijn: http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/HsSyn.html ?
14:07:48 <merijn> conehead: The Sum newtype exists because multiplication and addition both form Monoids for numbers
14:08:07 <merijn> conehead: So you have Sum/Product newtype for the different instances
14:08:24 <merijn> conehead: Same goes for "and" and "or" both being monoids for Bool
14:08:28 <Cale> merijn: Also http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/CoreSyn.html
14:09:22 <Cale> and there are some other -Syn modules for the syntax of various other intermediate languages
14:09:33 <merijn> Cale: That looks like what I wanted :)
14:09:44 <merijn> I just want some AST design inspiration :)
14:10:06 <merijn> :t mconcat
14:10:07 <lambdabot> Monoid a => [a] -> a
14:10:33 <merijn> > getSum . mconcat $ map Sum [1..10]
14:10:35 <lambdabot>  55
14:10:45 <merijn> > getProduct . mconcat $ map Product [1..10]
14:10:46 <lambdabot>  3628800
14:11:04 <jmcarthur> merijn: the Core AST is so delightfully simple
14:11:16 <Cale> I love that there's still code in GHC which uses monads that were written before there was a Monad class.
14:11:29 <Cale> and which still somehow don't have instances of Monad
14:11:45 <merijn> conehead: So, in essence they All and Sum monoids exist because there's no way to have multiple Monoid instances for a single type
14:11:57 <zvcvx> What's the proper type to store ligatures in Haskell? "ﬄ" returns "\65533\65533\65533", which is a list of replacement chars.
14:12:41 <merijn> > 'ﬄ'
14:12:42 <lambdabot>  '\64260'
14:12:55 <merijn> zvcvx: Char :)
14:13:08 <Cale> > "ﬄ"
14:13:09 <lambdabot>  "\64260"
14:13:17 <conehead> merijn: thanks for the explanation (:
14:13:26 <zvcvx> merijn: Hm...
14:13:28 <merijn> zvcvx: Keep in mind Char is unicode character, not one of these silly broken "wide char that can't quite hold all unicode" things
14:13:36 <Cale> zvcvx: There's probably something going weird with your terminal or text encoding somehow
14:13:58 <zvcvx> Cale: Yeah, I suspect that. Going to check this.
14:14:18 <Aetherspawn> jmcarthur: is this something that should be proposed on the library mailing list or raised as an issue or something
14:14:52 <zvcvx> Cale: Hm, hSetEncoding stdout utf8; 'ﬄ' returns a parse error. Ideas?
14:14:57 <jmcarthur> Aetherspawn: yeah, i would propose it on the library mailing list and go through the usual procedure to get it included.
14:15:24 <jmcarthur> Aetherspawn: i doubt there would be any objections, but you never know
14:15:28 <shachaf> zvcvx: Parse error? What are you actually typing and where?
14:16:31 <shachaf> ghci doesn't support semicolon-separated statements like that, if that's what you're doing.
14:16:44 <zvcvx> shachaf: In GHCi, if I type 'ﬄ' (that's the ligature for ffl) and hit RET, I get <interactive>:39:2: parse error on input `*** Exception: <stderr>: hPutChar: invalid argument (invalid character).
14:16:54 <zvcvx> shachaf: Nope, that was just a way to show the code here.
14:17:31 <merijn> zvcvx: You just said "hSetEncoding stdout" are you setting the right encoding on stdin?
14:18:18 <zvcvx> merijn: Well, I've just tried stdin too, nothing has changed.
14:18:28 <zvcvx> merijn: I should try in a different terminal.
14:18:49 <merijn> What's your terminal locale?
14:19:30 <zvcvx> merijn: OK, I see '\64260' in a different terminal. I suppose I should configure my locale properly.
14:19:43 <merijn> :)
14:19:46 <aleksejs_> hi, how do I write 123 + 456 + 789 with each number on it's own line?
14:21:53 <timthelion> aleksejs_: indent
14:22:09 <byorgey> aleksejs_: in an .hs file or at a ghci prompt?
14:22:18 <aleksejs_> .hs
14:22:24 <byorgey> then what timthelion said
14:22:40 <Aetherspawn> shrug, there was some discussion back in July about it
14:22:44 <Aetherspawn> it's not clear they did anything though
14:23:38 <zvcvx> merijn: Also, what's the proper way to convert ligatures to ASCII?  There's a package called ligature.  Is it OK?
14:24:13 <hny2014> are there examples of constructing DSLs using free monads?
14:24:38 <aleksejs_> timthelion, maybe some example?
14:25:01 <aleksejs_> nvm
14:25:06 <zvcvx> merijn: 'expand, which is defined in that package, accepts Data.Text.Lazy.Internal for some reason.
14:25:15 <zvcvx> Any ideas why?
14:25:34 <donri> hny2014: text-icu normalize maybe
14:25:47 <donri> uh that was for zvcvx
14:26:01 <zvcvx> donri: Will take a look. Thanks!
14:26:13 <donri> hny2014: free-game maybe?
14:31:34 <timthelion> arg, github doesn't display .lhs properly anymore :/
14:31:37 <zvcvx> donri: Meh, it requires C libraries. Any other ideas?
14:31:39 <timthelion> aleksejs_: sorry, I cannot find anything
14:32:05 <donri> zvcvx: is that a blocker? i think it should be available for windows even
14:32:28 * hackagebot leankit-api 0.1 - LeanKit API  http://hackage.haskell.org/package/leankit-api-0.1 (dtorok)
14:32:29 <timthelion> aleksejs_: http://pastebin.com/K4g0vEvT
14:32:31 <mauke> The paste K4g0vEvT has been copied to http://lpaste.net/97848
14:32:44 <zvcvx> donri: Not a blocker, but I'd rather use something else, if possible.
14:32:55 <aleksejs_> timthelion, I've already figured it out, but thanks
14:33:05 * timthelion needs to find a paste service that lpaste won't steal from.
14:33:19 <aleksejs_> vpaste?
14:33:40 <zvcvx> timthelion: What do you mean by "steal"?
14:33:43 <timthelion> aleksejs_: I'll try it next time
14:33:46 <donri> timthelion: just use lpaste? :P
14:34:11 <timthelion> zvcvx: I don't like fpcomplete. I feel that they're highjacking the opensource efforts of the haskell comunity for their own profit
14:34:29 <donri> lpaste is not fpcomplete's thing'
14:34:48 <geekosaur> and neither is mauke's pastebot thing
14:35:07 <jtcwang1> i wrote a program which uses getStdGen as seed, but the results are all the same across different runs
14:35:10 <timthelion> donri: it has an open in ide button doesn't it?
14:35:13 <geekosaur> and, to be quite honest, I do not like using the pastebins that mauke's bot "steals" from
14:35:21 <Cale> timthelion: lpaste is Chris Done's project, and it's open source, there's even a link to the source on every post
14:35:46 <jtcwang1> does GHCi keep the same implicit global seed through runs?
14:35:47 <donri> timthelion: yeah that's a recent addition. chrisdone works for fpcomplete but his lpaste service predates it and is open source
14:36:08 <timthelion> donri: I know, I used to use it before that clone in ide button appeared
14:36:29 <donri> timthelion: so i take it you don't use github right
14:36:40 <timthelion> donri: I do. But there is a difference
14:36:43 <donri> also lol using pastebin.com because "open source reasons"
14:37:08 <twiceler> jtcwang1: Use newStdGen to generate a new seed
14:37:15 <mauke> timthelion: you've got it backwards
14:37:32 <mauke> I don't copy pastes to lpaste; I copy away from pastebin.com
14:37:34 <jtcwang1> twiceler, does newStdGen refreshes the implicit global seed?
14:38:22 <twiceler> jtcwang1: Yep; give it a try!
14:38:28 <jtcwang1> ok
14:38:54 <timthelion> mauke: OK, but I have a reasoning behind my madness http://www.reddit.com/r/haskell/comments/1tg25w/why_github_is_good_and_fp_complete_is_evil/
14:39:58 <timthelion> donri: that's to you too
14:40:46 <jfeltz> timthelion: fpcomplete needs to provide legitimate dev tools, instead of catering to the omg sexy cloud app cloud :)
14:41:21 <jfeltz> cloud app crowd *
14:41:33 <epta> timthelion: it sounds like "Why chair is good and pencil is evil"
14:41:44 <timthelion> jfeltz: If they are a purely high quality dev tool company, than they wouldn't provide the weird "community edition"
14:41:56 <jtcwang1> twiceler, cool it seems to be working. thanks
14:41:58 <epta> timthelion: iow, what is the point in comparing these two things?
14:42:10 <geekosaur> you mean, like how github provides a community tier and a commercial tier?
14:42:29 * hackagebot clckwrks 0.21.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.21.0 (JeremyShaw)
14:42:31 * hackagebot clckwrks-cli 0.2.10 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.10 (JeremyShaw)
14:42:33 * hackagebot clckwrks-plugin-page 0.3.0 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.0 (JeremyShaw)
14:42:35 * hackagebot clckwrks-plugin-media 0.6.3 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.3 (JeremyShaw)
14:42:39 <timthelion> epta: the point is, that if people start developing code behind the wall of fpcomplete's garden, than they will end up with a set of shared code that is non-accessible to non-fpcomplete users
14:43:01 <geekosaur> also, I can see why they'd do their tools the way they did --- not because "oo could sexy" so much as the same reasoning as threepenny-gui. "there's only one @#$%* portable gui for haskell and it's the web"
14:43:13 <timthelion> geekosaur: I would prefer fpcomplete to provide no free level, than a free to put in costs to get out level.
14:44:20 <donri> i don't disagree about fpcomplete. i disagree about lpaste and github :P
14:44:36 <timthelion> donri: hm?
14:46:05 * timthelion feels a bit like he's not in a great position to make this argument, as his contributions to the overal haskell library base are pretty minimal.
14:46:46 <zvcvx> timthelion: That's not important since the issue is political, not technical.
14:46:48 <Cale> geekosaur: It doesn't mean that they have to make it a web service. They could just as easily have sold a standalone product which runs as a webserver on your local machine.
14:46:50 * timthelion but he still feels overwhelmed by the positiveness towards fpcomplete, and than "his" comunity has become "theirs".
14:47:24 <timthelion> s/than/that/
14:47:31 <Cale> I think timthelion is somewhat overreacting, but I also think that fpcomplete comes off as a bit weird and cultish sometimes.
14:47:54 <merijn> Cale: Same argument could be made about haskell ;)
14:48:14 <Cale> There's way too much marketing-speak which if I didn't already know about Haskell would probably put me off.
14:48:49 <SLi> :t join
14:48:50 <lambdabot> Monad m => m (m a) -> m a
14:48:53 <SLi> :t join (,)
14:48:54 <lambdabot> a -> (a, a)
14:48:58 <SLi> What's m here?
14:49:02 <Cale> (->) e
14:49:11 <Cale> join :: (e -> (e -> a)) -> (e -> a)
14:49:12 <zvcvx> SLi: Monad.
14:49:32 <timthelion> merijn: well I think that Paul Hudak's cult of lazy evaluation haskell is pretty well balanced by SPJ's extreme sanity.
14:49:35 <SLi> Ah.
14:49:42 <SLi> Thanks :)
14:50:08 <Dodek> hey, i have some trouble with using conduits. i want to create conduit with type Conduit FilePath m (Metadata, Line), where type Line = ByteString
14:50:21 <zvcvx> SLi: Here, f is Functor, for instance: fmap :: Functor f => (a -> b) -> f a -> f b
14:50:39 <Cale> I don't find Paul Hudak very cultish.
14:50:41 <Dodek> so i wanted to use sourceFile :: FilePath -> Producer m ByteString, and use mapOutput to attach metadata in some way
14:51:17 <Cale> zvcvx: I'm pretty sure that SLi just wanted to know which m was being used in join (,)
14:51:22 <SLi> Yeah :)
14:51:24 <timthelion> Cale: actually, now that I think about it, you're right he's not that bad :P
14:52:30 * hackagebot leankit-api 0.2 - LeanKit API  http://hackage.haskell.org/package/leankit-api-0.2 (dtorok)
14:52:32 * hackagebot clckwrks-plugin-ircbot 0.6.5 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.5 (JeremyShaw)
14:52:34 * hackagebot clckwrks-plugin-bugs 0.6.5 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.5 (JeremyShaw)
14:53:03 <Dodek> hmm wait
14:53:47 <SLi> Though I'm still not sure I understand it :) (->) e is a type?
14:53:58 <merijn> SLi: Partially applied
14:54:07 <merijn> SLi: "a -> b" == "(->) a b"
14:54:15 <SLi> Hmm, right.
14:54:19 <timthelion> Cale: Today I was reading John Hughes "programming with arrows" and I felt it was a bit cultish.  The first page is like "here, lets start with a bad idea and make it elegant,  because we can...
14:54:33 <merijn> SLi: "(->) e" is a function that takes an 'e' as first argument
14:54:50 <merijn> timthelion: What was the "bad idea" it started with?
14:55:01 <SLi> And that's an instance of Monad. Right.
14:55:05 <timthelion> merijn: mixing IO and pure code
14:55:17 <merijn> I think Arrow is a good idea, it's the "arr" function that's bad
14:55:28 <merijn> timthelion: I don't consider that a bad idea either, see pipes
14:55:59 <merijn> timthelion: Also, I don't see how arrows are about IO?
14:56:02 <bennofs> Wow, was there no way to pass -no-global-package-db to GHC 7.4.2? :(
14:56:19 <SLi> Hmm, so this means that join can be used on any function that takes at least one parameter?
14:56:26 <timthelion> merijn: well his specific example of being able to pipe a file through a transformation and printing to stdout in one line IS a bad idea, because it can be implemented trivially in two lines in a way that still separates the IO from the pure code
14:56:29 <merijn> SLi: At least two
14:56:30 <twiceler> merijn: What do you dislike about arr? That it makes it too hard to make something an instance of arrow?
14:56:39 <merijn> twiceler: Ask Cale :)
14:56:57 <timthelion> merijn: see page 1 here http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
14:57:00 <twiceler> SLi: join f x = f x x        for a function f (right?)
14:57:11 <SLi> twiceler: seems so. Ok :)
14:57:14 <twiceler> join (,) x = (,) x x
14:57:25 <Cale> I don't hate arr, it's just that Arrow is missing some stuff that arr presently gets used for, and that ends up destroying most of the point of Arrow.
14:57:30 * hackagebot clckwrks-theme-bootstrap 0.3.0 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.3.0 (JeremyShaw)
14:57:32 * hackagebot clckwrks-theme-clckwrks 0.4.0 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.4.0 (JeremyShaw)
14:57:34 * hackagebot clckwrks-dot-com 0.3.5 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.5 (JeremyShaw)
14:57:49 * bennofs tries to make his GHC API code work with GHC 7.4
14:57:51 <timthelion> merijn: My point is, that the "count" function as a pure function is portable and great, and there is no reason to inline it into an IO bound mess.
14:57:57 <merijn> timthelion: The next stream example is much nice
14:58:02 <merijn> +r
14:58:16 <jmcarthur> :t flip
14:58:17 <timthelion> merijn: yes, I agree
14:58:17 <lambdabot> (a -> b -> c) -> b -> a -> c
14:58:26 <Cale> A major selling point of Arrow as an interface is that its primary means of composition, (>>>) takes parameters in a datatype that you have control over
14:58:31 <jmcarthur> there was a generalized flip in lambdabot before. does anybody remember what it was?
14:58:41 <shachaf> :t (??)
14:58:41 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:58:45 <Cale> So, the implementation of (>>>) can do clever things to inspect those and perhaps simplify computations before they run
14:58:50 <Kanisterschleife> hi! I want to use the function strokeString from Graphics.UI.GLUT.Fonts, but even though I imported the latter, ghc cannot find strokeString. What can be the problem here?
14:58:54 <timthelion> merijn: though the circutes are a bit of a strech for me, how many flipflops do I need in order to implement a flipflop with arrows?
14:59:00 <jmcarthur> :t (??) `asTypeOf` flip
14:59:01 <lambdabot> (a1 -> a -> c) -> a -> a1 -> c
14:59:01 <merijn> SLi: "m (m a)" with m = "(->) e" becomes: "(->) e ((->) e a)" becomes "e -> ((->) e a)" becomes "e -> (e -> a)" which is the same as "e -> e -> a"
14:59:02 <Cale> But arr messes with that, because functions are black boxes
14:59:04 <jmcarthur> yeah that's it
14:59:05 <jmcarthur> thanks
14:59:13 <SLi> merijn: Right. I think I got it :)
14:59:21 <SLi> merijn: Thanks!
14:59:21 <merijn> jmcarthur: generalised flip was just fmap, I think :p
14:59:26 <merijn> eh
14:59:30 <merijn> derp
14:59:36 <merijn> That was generalised (.)
14:59:46 <merijn> I should stop giving advice.
15:00:18 <timthelion> Cale: I think that Arrow is a fine idea, but in his paper it is presented without any understanding of actual engineering.  Which is a bit odd. If he's smart enough to formalize the idea, why is he so bad at placing it into real life.
15:00:19 <shachaf> jmcarthur: Even more generalized: distribute
15:00:26 <merijn> timthelion: Well, I have colleagues that use a similar arrow based design of circuits to model hardware in haskell :)
15:00:41 <shachaf> :t Data.Distributive.distribute
15:00:41 <bennofs> @ty distribute
15:00:42 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
15:00:42 <lambdabot>     Not in scope: `distribute'
15:00:42 <lambdabot>     Perhaps you meant `distrib' (imported from Control.Lens)
15:00:57 <bennofs> @ty sequenceA `asTypeOf` flip
15:00:58 <lambdabot>     Not in scope: `sequenceA'
15:00:58 <lambdabot>     Perhaps you meant one of these:
15:00:58 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
15:01:02 <Cale> Kanisterschleife: do you mean renderString? http://hackage.haskell.org/package/GLUT-2.5.0.2/docs/Graphics-UI-GLUT-Fonts.html
15:01:03 <bennofs> @ty T.sequenceA `asTypeOf` flip
15:01:04 <lambdabot> Traversable ((->) a) => (a -> b -> c) -> b -> a -> c
15:01:07 <zvcvx> merijn: Any links?
15:01:28 <jmcarthur> huh, didn't occur to me that sequenceA is generalized flip
15:01:42 <bennofs> jmcarthur: it's not, because (->) a is not Traversable
15:01:47 <shachaf> jmcarthur: It sn't.
15:01:53 <jmcarthur> oh!
15:01:54 <shachaf> But distribute is.
15:01:56 <bennofs> @ty distribute `asTypeOf` flip
15:01:56 <jmcarthur> i see
15:01:57 <lambdabot>     Not in scope: `distribute'
15:01:57 <lambdabot>     Perhaps you meant `distrib' (imported from Control.Lens)
15:02:10 <jmcarthur> derp
15:02:13 <merijn> zvcvx: This is one of the main things they're working on: http://hackage.haskell.org/package/clash
15:02:14 <bennofs> @ty distribute `asTypeOf` flip
15:02:15 <lambdabot> (a -> b -> c) -> b -> a -> c
15:02:17 <triliyn> :t asTypeOf
15:02:18 <lambdabot> a -> a -> a
15:02:36 <jmcarthur> triliyn: it's a specialized const
15:02:57 <Cale> timthelion: I'm not sure what you mean by "actual engineering" here. One criticism I do have about the original Arrow paper is that he explicitly chooses to forego the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
15:03:06 <triliyn> I guess it's just used to demonstrate that things can unify?
15:03:08 <triliyn> oh wait, no
15:03:11 <Kanisterschleife> Cale: ah, thank you! didn't notice strokeString is again wrapped by another function
15:03:12 <triliyn> That's how you're using it here
15:03:15 <Cale> timthelion: That law lets you draw the circuit diagrams without explicitly boxing every operation
15:03:19 <jmcarthur> triliyn: typically to constrain the type a bit
15:03:20 <triliyn> But it could also be used instead of a type declaration
15:05:01 <Cale> timthelion: There is value in talking about interfaces to libraries abstractly, I think, and there are enough things which are somewhat close to Arrow conceptually. I think the Arrow class as implemented falls a bit short of what it could be though.
15:06:00 <Cale> Specifically, if you formalise the idea of a symmetric monoidal category (extending Control.Category's sort of definition), you end up with a much nicer sort of Arrow class, which has explicit operations for doing wiring.
15:06:11 <monoidal>  Is Distributive essentially the same as representable functor?
15:06:19 <Cale> (which is important because it then becomes possible to analyse things before you run them)
15:06:30 <carter> Cale: would that arrow class look like?
15:07:06 <udevd> http://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#t:MMonad >A monad in the category of monads
15:07:09 <udevd> welp
15:07:26 <timthelion> Cale: Well I'm just dissapointed by the first example being a completely bad design choice. And also his explanation for why he does some tricks with delay in order to make list lengths match up.  If I'm processing a string of events, simply dropping one of them is not really acceptable.
15:08:31 <twiceler> I don't think I've ever used an instance of Arrow that analyzed before it ran. Really I've only used Netwire, which as I've used it ends up basically being the Kleisli arrow
15:09:16 <Cale> carter: It would have rassoc :: ((a,b),c) ~> (a,(b,c)) and its inverse, as well as the isomorphisms a ~> (a,()) on each side, and swap :: (a,b) ~> (b,a)
15:09:36 <carter> and current arrow cant?
15:09:37 <donri> the way i understood it no useful and efficient monad is possible for netwire
15:09:47 <Cale> carter: It *doesn't*
15:09:48 <carter> would a useful applicative exist?
15:10:02 <Cale> carter: The current arrow relies on arr to provide these things
15:10:16 <carter> which messes with introspection
15:10:16 <jmcarthur> arr destroys most of the benefits of Arrow :(
15:10:17 <Cale> which makes all the wiring between computations into black boxes
15:10:41 <carter> could you write an alternative Arrow (ab)using rebindable syntax?
15:10:43 <donri> there's a useful applicative yes
15:10:54 <donri> duno how introspective
15:11:02 <Cale> carter: At iPwn we wrote our own preprocessor for the arrow syntax sugar
15:11:15 <jmcarthur> i thought http://www.cs.berkeley.edu/~megacz/garrows/ had promise, but it looks abandoned
15:11:19 <carter> yeah
15:11:24 <carter> why dind't it get merged in?
15:11:29 <twiceler> donri: what does that mean? (about netwire)
15:11:39 <Cale> Yeah, garrows is pretty much identical to what we came up with, only with different naming :)
15:11:48 <donri> twiceler: that it's not just kleisli
15:11:57 <jmcarthur> i wasn't a huge fan of the syntax, but even just the type class and promise of convenient syntax would have been good
15:12:11 <Cale> carter: Because we never got around to figuring out what we should open source
15:12:13 <carter> i was amazed when i read some code recently that used rebindable syntax to get indexed monads with do notation
15:12:22 <carter> Cale: gr
15:12:27 <td123> I've been noticing a pattern lately: f (f' i) (f'' i) is there a way of writing this without writing i twice?
15:12:54 <Cale> @pl (\i -> f (f' i) (f'' i))
15:12:54 <lambdabot> liftM2 f f' f''
15:13:00 <Kanisterschleife> I was wondering if it's possible in Haskell to include conditions/relations in the definition of type classes. For example, mathematically a monad is required to obey the associativity axiom, but this is nowhere enforced in the Haskell definition of monads, is it? Can one do such a thing in a language with dependent types, where propositions can be encoded as data types? E.g., can one, in such a situation, enforce relations by requi
15:13:00 <Kanisterschleife> to be given particular elements of the data types that state the validity of the desired relations?
15:13:13 <mauke> td123: http://mauke.hopto.org/tmp/flow.png
15:13:15 <Cale> Kanisterschleife: yes
15:13:40 <Cale> Kanisterschleife: Not so easy in Haskell, but in a dependently typed language, it's trivial to demand proofs that the laws hold
15:13:58 <timthelion> mauke: when did you draw that?
15:14:06 <Kanisterschleife> Cale: cool
15:14:12 <mauke> timthelion: I don't remember
15:14:26 <mauke> mtime is from 2009
15:14:53 <timthelion> I always feel overwhelmed when I come to this channel with some comments on a concept I just learned and people start arguing about it at a much higher level...
15:15:13 <donri> Kanisterschleife: (example of that in agda: https://theorylunch.wordpress.com/2013/12/03/natural-numbers-with-addition-form-a-monoid/ )
15:15:31 <timthelion> mauke: I wondered if you had drawn it in the time between td123's asking and your linkposting
15:16:53 <ocharles> mm_bureau / mm_freak : http://lpaste.net/2202789413589614592 is how things are looking at the moment. I'm restarting the project to be a bit more organised - this gets a running mario
15:17:03 <Cale> http://lpaste.net/97851
15:17:10 <Cale> Kanisterschleife: ^^ some monad stuff I wrote in Coq
15:17:22 <ocharles> mm_bureau / mm_freak : not sure what you think about the 'loadImage' Wire (which loads an image once and is then pure)
15:17:35 <Cale> (that was like my first Coq program, lol)
15:17:39 <ocharles> Though it loads an image into the state of the monad, so entering the wire multiple times doesn't keep reloading the image
15:18:29 <Cale> There's probably a lot of stuff which could be cleaned up
15:18:45 <Cale> I didn't really learn about how implicit arguments worked until about halfway through
15:18:50 <Kanisterschleife> Cale: cool, thank you :) Are you a mathematician?
15:19:03 <Cale> Yes, I suppose :)
15:19:07 <Cale> Not professionally
15:19:20 <Cale> But my degree is in mathematics
15:19:22 <Kanisterschleife> Cale: ah, ok :)
15:19:36 <Kanisterschleife> Cale: what topic did you write about?
15:19:51 <Cale> It was just a BMath in Pure Mathematics, no thesis
15:20:41 * JuanDaugherty me too
15:21:12 <Kanisterschleife> Cale: hopefully I'll find some time to see if I can understand your code. I'll probably come back and ask you then :)
15:21:30 <Cale> Kanisterschleife: You'll have to load it into Coq for the proofs to make any sense
15:21:32 <Kanisterschleife> But it's nice to know that such things can be and actually have been done
15:21:42 <Cale> It's impossible to read Coq proofs.
15:21:50 <Cale> (at least, without assistance)
15:22:09 <Cale> (Because they indicate the steps to take in a context which is invisible from the source code alone)
15:23:08 <td123> Cale: thanks for showing me liftM2
15:23:13 <td123> that worked
15:25:19 <Kanisterschleife> gtg, bye!
15:40:01 <greg`> whats the best way to modify a vertex in a Data.Graph
15:40:21 <greg`> does one have to recreate the whole graph or is there some kind of trick i can use
15:41:28 <Cale> greg`: You have to recreate the graph. I don't really like Data.Graph for much
15:41:56 <Cale> I usually just invent my own graph representation something along the lines of Map Vertex (Set Vertex)
15:42:27 <greg`> ah i will look at that
15:42:46 <greg`> im thinking of writing a neural net in haskell
15:43:21 <greg`> i thought it would be better to reuse existing data structures rather than reinvent the wheel
15:43:30 <greg`> but perhaps not
15:44:00 <greg`> it does look a little complex for what i want to do
15:44:13 <Cale> Well, it depends on what sort of algorithms you need
15:44:34 <Cale> If you need anything fancy, you might find it better to use fgl or something.
15:44:55 <greg`> whats fgl?
15:45:26 <shachaf> @whats fgl
15:45:26 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
15:45:42 <frohe> hello! happy 2014! why can we match a value of type [[a]] against [] pattern? here is my code: http://lpaste.net/97852
15:46:04 <shachaf> frohe: Because a list of lists can be empty.
15:46:20 <greg`> yes you can match
15:46:25 <shachaf> Instead of [[a]], pretend the type is List (List a)
15:47:02 <greg`> though note [[]] isnt empty
15:47:12 <shachaf> [foo] is just crazy Haskell syntax for the type of a list of foo. It's mostly unrelated to the *value* [foo], which is a list with one element.
15:47:13 <frohe> shachaf, the list is defined as "data [] a = [] | a : [a]" right ?
15:47:14 <Cale> also note that you're missing a pair of parens in the last line
15:47:21 <Cale> It should be  myConcat (x:xs)
15:47:40 <shachaf> frohe: It would be defined that way, conceptually, though that's probably a syntax error.
15:47:43 <Cale> frohe: That's pseudocode, but effectively
15:47:50 <shachaf> The type "[] a" is the same as the type "[a]".
15:48:03 <maxiepoo> is [] the only type that gets its own syntax like that? I guess `->` too
15:48:06 <shachaf> Very different from the value level meaning of those strings.
15:48:52 <mauke> maxiepoo: (,)
15:49:00 <maxiepoo> oh yeah (,,,,,,,,,,,,,)
15:49:51 <Cale> (^,,,^) <-- Cthulhu
15:49:53 <maxiepoo> not sure they're really worth it over something like `Pair a` and `List a`
15:50:10 <maxiepoo> maybe `Two a`, `Three a`,...
15:50:12 <frohe> in pattern matching, haskell matches value constructors and their fields against patterns?
15:50:31 <Cale> maxiepoo: Pair takes two type parameters
15:51:00 <Cale> frohe: yes
15:51:02 <maxiepoo> yeah `Two a b` `There a b c`
15:51:07 <maxiepoo> Three*
15:51:34 <Cale> TwentySix a b c d e f g h i j k l m n o p q r s t u v w x y z
15:51:54 <threestrikes> is any one using haskellmode for vim?
15:58:37 <mreh> quicksilver: wondering if you knew if there's been any developments in the state of an efficient implementation of reactive
15:59:13 <stepkut> is there an older version of ghc where linking against HsOpenSSL required that the C libraries ssl and cryptocpp be installed?
16:02:31 <mreh> preflex seen conal
16:02:32 <preflex>  conal was last seen on #haskell 35 days, 3 hours, 20 minutes and 5 seconds ago, saying: (now with changelog)
16:02:57 <mreh> nooo, I saw him about a week ago
16:03:49 <Dodek> what's the nicest way to check if Data.Array is empty? doing (0 ==) . rangeSize . bounds seems a bit ugly
16:04:50 <rose> class Arrow a where
16:04:50 <rose>   arr :: (b -> c) -> a b c
16:05:31 <rose> What does the a b c mean here?
16:05:37 <rose> class Arrow a where
16:05:41 <rose> arr :: (b -> c) -> a b c
16:05:50 <zvcvx> donri: Thanks, normalize works. For instance, putStr $ unpack $ normalize NFKD (pack ['ﬄ']) returns ffl.
16:05:52 <triliyn> That `a` is a type constructor like the `m` in Monad
16:06:04 <triliyn> Except this one takes two arguments
16:06:26 <triliyn> It can be helpful to imagine it as like an alternative to the function arrow
16:07:30 <rose> triliyn: The function arrow means, apply a function to input b, and you'll get an output c. I'm not sure how the input and output here rate to the values given to the type constructor
16:08:13 <shachaf> rose: Imagine "a" was "(->)" (since that's the only instance of Arrow people ever actually use)
16:08:20 <shachaf> arr :: (b -> c) -> (->) b c
16:08:32 <shachaf> Of course, (->) b c means the same thing as (b -> c)
16:08:32 <rose> thanks
16:12:31 <bennofs> Is there a way to use package databases that are directories with GHC 7.4?
16:14:56 <threestrikes> I'd like to use vim to help me learn haskell.  I'm looking at a few plugins but I can't tell if they're outdated.  Has anyone used or is using haskell mode for vim?  If not what other options do I have?  Thank you.
16:18:46 <jtcwang> haskell mode is way outdated according to the author
16:19:00 <jtcwang> i'm using it atm though cuz i'm really only using its type display
16:19:07 <jtcwang> nothing else
16:19:25 <jtcwang> but yeah i guess it's not bad
16:20:20 <threestrikes> I'm more concerned about being able to run what's in the buffer through ghci
16:21:03 <threestrikes> I find myself having mutiple window's open and I feel as though there is an easier way to be able to switch between the text editor and running snippets
16:21:48 <L8D> threestrikes: you could setup a key to move your clipboard to an environment variable
16:22:10 <L8D> then you would have a script that would run ghci with whatever the environment variable is
16:22:26 <L8D> So you could copy a line or two and run it in a new or running ghci session
16:22:37 <threestrikes> ahh
16:23:16 <Fylwind> "Fortunately, starting with Cabal 1.8.0.4, executables can also declare the package that they are in as a dependency, and Cabal will treat them as if they were in another package that dependended on the library."
16:23:16 <jfeltz> threestrikes, GhcMod for vim is a good start
16:23:18 <L8D> Otherwise you can copy to system clipboard and paste the text through your terminal
16:23:21 <bigos> threestrikes: you could try using GNU screen if you are in a console ...
16:23:32 <Fylwind> that was from the Cabal User Guide; does anyone know what it's referring to?
16:24:17 <donri> threestrikes: best way to do that sort of thing from vim is via tmux
16:25:06 <donri> threestrikes: (don't have to run vim inside tmux, even works with gvim, although staying in tmux has its benefits i imagine)
16:25:08 <jfeltz> threestrikes, you might also consider learning emacs, I think that has a superior haskell editing environment atm, I just haven't had time to make the switch, i've written lots of viml to make vim work with haskell dev, but if I could do it again, I would have started from emacs
16:25:12 <BMeph> Fylwind: cabal treats packages that compile to executables and ones that make libraries differently. Apparently, this annoyed some folks enough that it's being resolved. :)
16:25:24 <jtcwang> is throwDice (nxt:rs) BetRecord {betResult=Win, betAmount=b, betReturned=returned, betBalance=balance}
16:25:30 <jtcwang> and legal pattern matching and binding?
16:25:45 <threestrikes> I looked at emacs but from what I've read you use the ctrl button a lot
16:25:52 <jtcwang> so i want to match where betResult in the record syntax is Win
16:25:56 <jtcwang> and bind all other variables
16:26:08 <jfeltz> threestrikes, emacs evil plugin
16:26:09 <donri> threestrikes: there's evil-mode to emulate vim in emacs, and god-mode to stick to emacs concepts but with modality
16:26:20 <threestrikes> ic
16:26:26 <Fylwind> BMeph: it's "being" resolved? so is there a solution atm? :/
16:26:44 <BMeph> jtcwang: throwDice (nxt:rs) (BetRecord {betResult=Win, betAmount=b, betReturned=returned, betBalance=balance}) , I'd say.
16:27:02 <jtcwang> BMeph, ok
16:27:03 <donri> threestrikes: also i suggest repurposing caps lock as a ctrl key system-wide; generally useful
16:27:07 <d-snp_> threestrikes: I use Sublime Text with the HaskellSublime plugin, and vim mode
16:27:18 <d-snp_> works better than haskellmode for vim ever worked for me
16:27:30 <d-snp_> though vim mode is not really as nice as real vim, the rest of sublime makes up for it
16:27:31 <Fylwind> BMeph: specifically, I'm just wondering if there's a way to avoid duplicating all the library dependencies
16:27:41 <donri> yeah don't use haskellmode, there are better alternatives for most of its features
16:27:52 <donri> ghcmod, neco-ghc, unite-haddock
16:28:02 <bennofs> Fylwind: you can depend on the library defined in the current cabal file
16:28:34 <Fylwind> bennofs: ah i see, thanks
16:28:36 <BMeph> Fylwind: It sounds as if what you read means that a library, and an executable based on that library, may now be in one package, with some background hand-waving so that Cabal doesn't object to it.
16:29:20 <dhrosa_> what's the objection against the actual control key, too far in the corner?
16:29:43 <d-snp_> emacs-pinky perhaps?
16:29:48 <jfeltz> threestrikes, with emacs, you can capitalize on knowing the functional paradigm, and extend the editor via elisp :), this is almost killing 2 birds with one stone, but not quite :)
16:30:08 <bennofs> I've also rebound it, but I still use Ctrl (I just don't remeber to use caps lol)
16:30:09 <BMeph> Fylwind: The problem isn't duplicating the library's dependencies, so much as needing to have a separate package for an executable, even when all it dependy on is the library.
16:30:17 <Watabou> What vim plugins do people use? I just go with haskellmode. Any others that I should know about?
16:30:29 <Fylwind> BMeph: I see
16:30:29 <Watabou> Specifically for haskell I mean
16:30:56 <BMeph> Fylwind: That's the way I read it, but I Am Not A Cabal Expert, so take my words with a lick's worth of salt. :)
16:30:57 <Dodek> hmm, regex libraries don't work on Text?
16:31:02 <threestrikes> I'll check all of these out and do some more reading but I think until I truly get a better grasp of haskell I'm going to keep it simple with what L8D suggested.  Thanks for all the input.
16:31:11 <Fylwind> BMeph: Hehe OK
16:31:36 <donri> Watabou: ghcmod, neco-ghc, unite-haddock. also popular: hdevtools. maybe not quite ready for prime time: hsimport, ariadne, hindley. my own, not recommended yet: haskell, cabal, hare
16:31:58 <Watabou> Thanks, that's quite a list
16:32:17 <donri> Watabou: also my vim2hs which is more complete but i don't use it myself anymore ;)
16:32:41 <bennofs> donri: you develop hare?
16:32:51 <donri> bennofs: no, there was an implicit "vim-" there ;)
16:33:05 <donri> vim-hare, but it's like 20 lines of almost useless experiments
16:33:50 <BMeph> dhrosa_: Some folks hit the Caps Lock when they don't want to. This way, it gives a nicer result when they do so. Also, yes, it allows more convenient home-row positioning to be maintained.
16:34:14 <bennofs> donri: I was also surprised that cabal and haskell are not usable from prime time yet, thought it was a joke :) What does vim-cabal do?
16:34:35 <bennofs> Although we don't have haskell-prime yet, so it kind of fits ...
16:34:47 <donri> bennofs: ;) syntax, compiler, ftdetect, ftplugin...
16:35:04 <bennofs> compiler?
16:35:21 <donri> :compiler cabal and then you can :make to run cabal build and parse errors into quickfix
16:36:11 <bennofs> Hmm, I'd like a way to tell cabal configure: Hey, enable everything you can, but if the deps are not met, just disable this target
16:37:00 <donri> what for
16:37:36 <bennofs> For my DWIM emacs haskell syntax checking. I'd like to configure haskell projects automagically, but don't fail if the test suite doesn't have the required deps
16:38:32 <donri> aha, that's a problem with ghc-mod i had. it requires test suite deps even if not configured with tests
16:39:34 <bennofs> donri: well, my syntax checker does only require the deps that were enable via cabal configure. But it requires you to run cabal configure manually, and cabal configure cannot selectively enable executables or test suites if there are no flags iirc
16:40:49 <bennofs> YAY, my GHC api program finally compiled fine with GHC 7.4 AND GHC 7.6
16:42:43 * hackagebot nimber 0.1.2 - Finite nimber arithmetic  http://hackage.haskell.org/package/nimber-0.1.2 (AndersKaseorg)
16:42:45 * hackagebot cruncher-types 1.0.3 - Request and Response types for Eval.so's API  http://hackage.haskell.org/package/cruncher-types-1.0.3 (RickyElrod)
16:44:27 <Eduard_Munteanu> How does Alex handle complex tokens? I'm switching to a startcode that parses strings, can I avoid parsing "foo" into [StartString, Contents "foo", EndString], assuming I need to assemble the string from fragments?
16:44:51 <Eduard_Munteanu> (e.g. handle escaped characters)
16:45:33 <Eduard_Munteanu> I'd rather like to get a String [...] token.
16:46:35 <Eduard_Munteanu> I guess I can use a stateful wrapper.
16:51:38 <martingale_> does anyone know when 7.8 will be released?
16:55:07 <L8D> martingale_: Next month
16:55:17 <martingale_> thanks
17:02:14 <ParahSailin> Eduard_Munteanu: https://github.com/rcallahan/selectors/blob/master/XML/Selectors/CSS/Tokens.x an example, you dont need to use statecodes
17:03:14 <Eduard_Munteanu> ParahSailin: I need to handle escape sequences like \" and variable references like $foo
17:04:03 <ParahSailin> ah, probably do need the startcodes then, but not hard to make it lex to one token i think
17:06:04 <Eduard_Munteanu> I'm thinking of   <0> \" { Str <$> (runWriterT . lift . begin) string }   or something like that.
17:06:31 <Eduard_Munteanu> Not sure if Alex is ok with that.
17:10:41 <benzrf> whats a free theorem?
17:11:27 <Iceland_jack> benzrf: Not to be rude but have you done some research?
17:11:28 <Eduard_Munteanu> benzrf: it's a theorem you can derive from a type, due to parametricity
17:11:29 <bennofs> What does reordering of stores mean? Does it mean that writeIORef ref 3 >> writeIORef ref 4 >> readIORef ref could produce a different result, depending on the reordering?
17:11:36 <ParahSailin> Eduard_Munteanu: see @strchar in https://github.com/ghc/ghc/blob/master/compiler/cmm/CmmLex.x
17:11:40 <Eduard_Munteanu> @google theorems for free
17:11:42 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
17:11:43 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
17:12:22 <ParahSailin> \" (($printable # [\"\\]) | @escape)* \# {strtoken string}
17:12:34 <Iceland_jack> benzrf: Wadler's paper is good :) you should check it out if you're interested
17:12:52 <benzrf> ok
17:13:02 <Eduard_Munteanu> bennofs: it often refers to CPUs rearranging writes such that they may occur in a different order while preserving the same result, concurrency aside.
17:13:58 <bennofs> Eduard_Munteanu: so the problem occurs with concurrency, that I could see the IORef writes in a different order?
17:14:02 <Eduard_Munteanu> ParahSailin: oh, I didn't know you could do that BNF-ish '|', especially in macros
17:14:02 <mm_freak> @duckduckgo theorems for free
17:14:02 <lambdabot> Unknown command, try @list
17:14:32 <bennofs> Maybe in write 3 >> write 4 >> write 5 >> read, I could observer 4,3,5 from another thread if I'm not careful?
17:14:33 <ParahSailin> Eduard_Munteanu: thats just regular regexp |
17:14:43 <c_wraith> bennofs: yeah.  Though atomicModifyIORef inserts memory fences such that writes won't be reordered around it.
17:14:44 <Eduard_Munteanu> Oh, hm.
17:15:10 <mm_freak> bennofs: if in doubt, MVars have much more well-defined concurrency semantics
17:15:58 <Eduard_Munteanu> bennofs: it's not usually a big deal because IORefs are plain variables, not hardware stuff or anything
17:16:32 <Eduard_Munteanu> I mean if locking isn't warranted, likely a memory barrier isn't either.
17:17:02 <Eduard_Munteanu> Besides, they're already atomic.
17:17:15 <c_wraith> writes are atomic.  Updates aren't.
17:17:26 <Eduard_Munteanu> Yeah, sure.
17:17:57 <Axman6> bennofs: I'd be extremely surprised if this is something you actually have to worry about. there's usually enough going on between consecutive writes that they will be written in order. the issue comes when the writes are within a few cycles of each other
17:18:06 <aristid> c_wraith: atomicModifyIORef isn't atomic?
17:18:20 <Eduard_Munteanu> aristid: modifyIORef isn't atomic
17:18:26 <mm_freak> also i think write reordering is not a multi-threading issue
17:18:41 <mm_freak> if you can observe the reordering, the CPU is buggy
17:18:42 <c_wraith> aristid: I was responding to the "they're already atomic" remark.
17:18:56 <aristid> Eduard_Munteanu: is there much reason to use modifyIORef over atomicModifyIORef?
17:19:23 <mm_freak> aristid: yes:  atomicModifyIORef (\x -> x^300000)
17:19:48 <mm_freak> (types aside)
17:20:00 <aristid> mm_freak: well that will just update the thunk:) being lazy:P
17:20:09 <mm_freak> indeed
17:20:15 <mm_freak> aristid: yes:  atomicModifyIORef var (\x -> return $! x^300000)
17:20:20 <aristid> but there's atomicModifyIORef'
17:20:23 <c_wraith> atomicModifyIORef can loop under contention, because of the atomicity
17:20:27 <Eduard_Munteanu> mm_freak: it can arise when reentrancy is required, more generally
17:20:43 <Eduard_Munteanu> Even if not multithreaded per se.
17:21:01 <aristid> c_wraith: it's implemented with optimistic concurrency?
17:21:15 <c_wraith> aristid: yes.
17:21:22 <aristid> interesting
17:22:02 <c_wraith> it reads the current value, creates a thunk, then does an atomic compare and exchange.  If it fails, it loops.
17:22:22 <Eduard_Munteanu> And barriers may be cheaper than locking / atomic ops, depending on the situation.
17:22:29 <aristid> c_wraith: oh yeah that makes a lot of sense
17:23:22 <mm_freak> that's why atomicModifyIORef takes a pure function
17:23:26 <mm_freak> interesting
17:23:56 <mm_freak> why is there an atomicWriteIORef, if it's optimistic?
17:24:03 <mm_freak> and if writes are atomic anyway
17:24:24 <c_wraith> you can't get that with the non-atomic primitives, afaik
17:24:38 <c_wraith> In particular, you can't do the atomic compare and exchange part
17:25:29 <c_wraith> which means you can never be sure that you didn't miss a write.
17:25:30 <Eduard_Munteanu> cmpxchg would be nice to have as a separate operation
17:28:29 <bennofs> Is a processor also allowed to entirely skip writes followed by another write to the same memory location?
17:28:51 <Eduard_Munteanu> bennofs: yes
17:29:42 <Eduard_Munteanu> bennofs: well, wait, no... not the CPU (not generally anyway), but compilers can do that optimization
17:30:05 <bennofs> But reordering is also done by the CPU, isn't it?
17:30:17 <Eduard_Munteanu> bennofs: yes
17:30:24 <c_wraith> compilers *usually* can, though it depends on if the language has a precise memory model specification.  I think every language that has a precise memory model specification does allow it.
17:31:10 <bennofs> Why doesn't the CPU skip duplicate writes?
17:31:24 <bennofs> Too complex?
17:31:45 <Eduard_Munteanu> bennofs: in many cases they do, when you write to regular memory
17:32:24 <monochrom> sometimes the cache absorbs two writes to the same location
17:32:49 * hackagebot chronograph 0.2.0.1 - measure timings of data evaluation  http://hackage.haskell.org/package/chronograph-0.2.0.1 (JohnLato)
17:32:52 <Eduard_Munteanu> bennofs: they won't postpone writes indefinitely though, and the reordering only happens if the data dependencies allow it
17:34:13 <Eduard_Munteanu> (but it can still reorder writes wrt parallel threads)
17:34:14 <Axman6> bennofs: depending on the CPU, writing to the same memory location may have more than the effect of writing a value to RAM, many CPUs have addresses that map to registers of other components
17:35:01 <monochrom> ah, I forgot memory-mapped I/O
17:35:20 <bennofs> interesting. I have to go now, good night :)
17:35:25 <Eduard_Munteanu> That's usually the only reason you care for exact ordering.
17:35:35 <Eduard_Munteanu> G'night.
17:36:49 <monochrom> perhaps Intel 8086 was right to separate memory space and I/O port space.
17:38:43 <Eduard_Munteanu> monochrom: nah, that's a mess... you can just turn off caching for MMIO spaces
17:39:24 <Eduard_Munteanu> You get to use regular instructions on it, e.g. rep movsd
17:40:44 <cdk> could someone provide the Category and Arrow instance for newtype Hyper b c = Hyper { runHyper :: Hyper c b -> c } ? I've been unable to figure it out
17:41:41 <Eduard_Munteanu> cdk: where have you seen that?
17:42:38 <cdk> http://www.haskell.org/arrows/index.html at the examples section near the bottom
17:43:31 <Eduard_Munteanu> There's a paper linked there.
17:43:58 <monochrom> heh ok
17:44:00 <donri> dead link though
17:45:05 <cdk> I think theres some fixpoint trickery needed for Category.id
17:45:14 <Axman6> speaking of memory mapped IO, this course showed me just how lacking C is for embedded applications compared to Ada. starting at page 258 it goes through exactly specifying the interface for a PPC microcontroler with some memory mapped ADC's and processing bits http://cs.anu.edu.au/student/comp4330/Lectures/RTES-03%20Interfaces.01.pdf
17:45:34 <Eduard_Munteanu> cdk: possibly, that constructor type isn't strictly positive wrt Hyper
17:45:54 <Axman6> shows exactly you can specify layout of data in Ada, which you can't do portably in C
17:46:04 <Axman6> hmm, that message probably got cut
17:46:13 <RustyShackleford> do you need a plugin for syntax highlighting in vim?
17:46:51 <donri> RustyShackleford: no, one is included with vim
17:46:53 <Eduard_Munteanu> If you mean packing structs exactly as they are declared, I suppose so... though any reasonable compiler offers some way.
17:46:55 <donri> although it's not very good
17:47:10 <Eduard_Munteanu> Axman6: it ends in the link, I don't think so
17:47:19 <RustyShackleford> i'll try sublime text i guess
17:47:27 <RustyShackleford> also, does haskell work well on windows?
17:47:58 <donri> RustyShackleford: well there are plugins for alternative syntax highlighting
17:48:11 <Eduard_Munteanu> RustyShackleford: mostly yes, I think
17:54:32 <nisstyre> Axman6: usually undefined behaviour in C is because they want to allow compilers more freedom to generate efficient code
18:02:51 <RustyShackleford> i suppose it doesn't matter, but I'm curious how haskell maps to machine code
18:03:13 <RustyShackleford> I took a class where we studied how C code maps to asm, it was cool
18:04:19 <L8D> RustyShackleford: Where did you take this class?
18:04:30 <Eduard_Munteanu> RustyShackleford: that's more of a compiler+runtime thing
18:04:52 <Eduard_Munteanu> Unless you mean it from a strictly conceptual POV.
18:05:18 <benzrf> are there any significant contravariant functors where contramap isnt just function composition with a field?
18:05:30 <L8D> @src hPutStr
18:05:30 <lambdabot> Source not found. Whoa.
18:05:41 <L8D> @src putStr
18:05:41 <lambdabot> putStr s  = hPutStr stdout s
18:05:42 <Eduard_Munteanu> Because compilers transform code a lot, usually.
18:06:01 <mm_freak> RustyShackleford: there are many ways to compile haskell (or lazily evaluated languages in general)
18:06:28 <mm_freak> RustyShackleford: the one GHC uses is based on the 'STG machine'
18:06:31 <L8D> Why doesn't Haskell do a lot of compile-time optimization?
18:06:39 <mm_freak> L8D: it does
18:07:11 <L8D> I mean...Compile-time running
18:07:14 <L8D> or evaluation
18:07:22 <L8D> when it sees a pure functions
18:07:26 <benzrf> L8D: doesnt it?
18:07:30 <L8D> Sometimes
18:07:55 <mm_freak> L8D: it does for simple cases where it knows that the compile-time evaluation will neither run for a long time, nor will it produce huge results
18:08:05 <L8D> I see
18:09:33 <mm_freak> L8D: but it's a difficult problem
18:09:36 <mm_freak> x = 1 + 1
18:09:50 <mm_freak> this may run for years and use terabytes of memory
18:11:07 <roboguy_> benzrf: what do you mean by composition with a field?
18:11:40 <benzrf> contramap f (Foo func) = f . func
18:11:44 <benzrf> contramap f (Foo func) = Foo (f . func)
18:11:55 <benzrf> or rather
18:11:56 <benzrf> func .c
18:11:57 <benzrf> *f
18:12:21 <roboguy_> benzrf: Product, Proxy and Const are all not really like that
18:13:23 <Eduard_Munteanu> benzrf: if you're ok with the same pattern on the contravariant bit, there are the indexed state monad / indexed store comonad which are contravariant in some argument.
18:13:57 <Eduard_Munteanu> (but covariant in the other 2)
18:16:44 <benzrf> i just dont see how (a -> b) can turn a b into an a unless the b is the first arg of a function and youre composing
18:18:22 <roboguy_> benzrf: phantom types (like with Proxy and Const) are another possibility
18:18:40 <Eduard_Munteanu> benzrf: how can an 'a' be turned into a 'b' other than composing on the left with an 'a -> b' for covariant functors?
18:19:05 <benzrf> Eduard_Munteanu: function application'
18:19:15 <benzrf> roboguy_: what are phantom types?
18:19:40 <Eduard_Munteanu> benzrf: that's just composing with id, conceptually :)
18:19:42 <roboguy_> benzrf: if you have a type argument in a data type definition that isn't used as a value, like this: data Const a b = Const a
18:19:58 <benzrf> :|
18:19:59 <roboguy_> benzrf: they are useful with GADTs especially
18:20:04 <Fuuzetsu> benzrf: check wiki
18:20:21 <Eduard_Munteanu> With id or possibly through some projection.
18:20:26 <roboguy_> benzrf: http://www.haskell.org/haskellwiki/Phantom_type
18:20:36 <benbangert> I'm trying to parse a phrase and split it such that I retain all 'non-words' and handle apostrophes in between letters, so far my attoparsec only seems to return Partial's, what am I missing? (code: http://paste.ofcode.org/33k8bKTRPNzG9eg7V87hNSZ )
18:21:57 <Eduard_Munteanu> benzrf: Partial is related to how you feed it the input
18:22:13 <benbangert> I'm running it with: parseTest parsePhrase $ pack "How are you doing?"
18:23:22 <benbangert> oh!, using parseOnly made it work
18:24:15 <Eduard_Munteanu> Hm, weird.
18:25:04 <Eduard_Munteanu> parseTest p s = print (parse p s)
18:26:01 <L8D> DustyDin1o: parseText = (print .) . parse
18:26:05 <L8D> whoops
18:26:12 <Eduard_Munteanu> benbangert: manyTill can take more input, I suspect 'parseTest' is wrong.
18:26:13 <L8D> Eduard_Munt: parseText = (print .) . parse
18:26:43 <Eduard_Munteanu> L8D: the above is the actual definition from the package
18:26:55 <L8D> Well that package needs a pull request
18:29:56 <aleksejs_> I have a problem: I defined a function in .hs file, and it works. Now I moved it to module, and haskell started to shout that "blah blah ambiguous type blah". So I decided to add a type declaration, and tried to declare this function in ghci to see it's type with :t. But when I call it in ghci, it fails
18:30:04 <Polarina> When making language bindings, what would be the most appropriate way to configure the package to compile some C files needed for the bindings?
18:30:08 * Polarina is making a library.
18:31:18 <twiceler> Polarina: Have you read this? http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/
18:31:57 <pavonia> aleksejs_: What fails?
18:31:57 <Polarina> twiceler, I've done everything with cabal and hsc2hs. There are several functions that need a special wrapper because they return a struct by value.
18:32:03 <aleksejs_> ghci shows function type foo :: () -> Int
18:32:32 <aleksejs_> and when I call this function, it shows No instance for (Num ())
18:33:04 <pavonia> How do you call it?
18:33:10 <aleksejs_> foo 123
18:33:13 <twiceler> Polarina: Oh, it's just a good explanation of how to package C code. Don't worry about the c2hs/hsc2hs if that's what you're saying
18:33:36 <Fuuzetsu> aleksejs_: that function expects a value of type ‘()’
18:33:40 <aleksejs_> function is: foo = sum . map digitToInt . show
18:33:40 <Fuuzetsu> which happens to be ()
18:34:02 <Polarina> twiceler, thanks. :)
18:34:04 <Fuuzetsu> what's your digitToInt?
18:34:13 <tristan_1> ugh, AES encryption with hsakell driving me nuts. anyone familiar?
18:34:18 <pavonia> :t digitToInt
18:34:18 <lambdabot> Char -> Int
18:34:22 <aleksejs_> Fuuzetsu, it's not mine
18:34:26 <Eduard_Munteanu> > 123 :: ()
18:34:27 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal `123'
18:34:27 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num ())
18:34:40 <Fuuzetsu> what module? Data.Char?
18:34:46 <aleksejs_> yes
18:34:57 <Fuuzetsu> sum . map digitToInt . show :: Show a => a -> Int
18:35:12 <Eduard_Munteanu> tristan_1: maybe you should call out to a crypto program
18:35:14 <Fuuzetsu> that's not () -> Int, can you show us the code?
18:35:56 <pavonia> aleksejs_: The problem is, it doesn't know which Show instance to use, so it defaults to ()
18:36:23 <tristan_1> Eduard_Munteanu: well I think I may have got the issue "figured out". and it being an issue with string<->ByteString conversion
18:36:25 <aleksejs_> this code works when it's in .hs: http://vpaste.net/kSgqI
18:36:56 <aleksejs_> but doesn't work in ghci
18:37:02 <twiceler> Polarina: I should mention that I never got that smooth Cabal method to work (but it's because I was using CUDA C and Cabal forces you to compile with gcc). So I did the backdoor "install the C library yourself and then link to it" kind of deal
18:37:14 <Eduard_Munteanu> tristan_1: why use a String in the first place?
18:37:49 <tristan_1> since the api involves the key taking the first 32 chars of the 64 hex char sha256 hash and then converting each ASCII char of that string to the hex value for the decimal represnetation of the character
18:37:49 <aleksejs_> also, if fails, if I move function to module
18:38:22 <pavonia> aleksejs_: Give it an explicit type signature
18:38:54 <tristan_1> so then I have a string like 3637613466343566306431643962633630363438366663343264633439343136, which is a 32 element byte array
18:39:12 <Eduard_Munteanu> tristan_1: aside from OverloadedStrings, the bulk of your data has no reason to ever be a String... if it is, you should probably look at the Bytestring IO module.
18:39:52 <tristan_1> hm
18:40:03 <tristan_1> maybe there is a better way
18:40:42 <tristan_1> I get the right key, just not as a byte array
18:42:01 <Eduard_Munteanu> tristan_1: "byte array"?
18:42:23 <aleksejs_> pavonia, thanks, it helped
18:44:26 <tristan_1> Eduard_Munteanu: yea, not sure how else to say it :)
18:45:15 <Eduard_Munteanu> tristan_1: well, is it really a bunch of bytes or some text representation of it? If so, what encoding?
18:45:37 <tristan_1> like openssl takes a hex string, say 363761, which is an array [36, 37, 61]
18:46:51 <Eduard_Munteanu> tristan_1: so it is binary data?
18:47:17 <tristan_1> it is a string of hex values
18:47:36 <Eduard_Munteanu> tristan_1: not sure what a string or a hex value is, exactly
18:48:10 <Eduard_Munteanu> Is it "FF" or 255 as a byte?
18:48:27 <tristan_1> "FF"
18:48:37 <Eduard_Munteanu> Ok.
18:49:06 <Eduard_Munteanu> tristan_1: and what encoding does that text have? ASCII, UTF8, something else?
18:49:17 <tristan_1> ascii
18:50:12 <Eduard_Munteanu> tristan_1: you should be using a Data.Bytestring.Char8 then
18:51:11 <Eduard_Munteanu> tristan_1: is there any place you're still using a plain String?
18:52:06 <tristan_1> yes
18:52:45 <Eduard_Munteanu> Why and where?
18:52:55 <tristan_1> https://gist.github.com/tsloughter/8214243
18:53:42 <tristan_1> which gives the key I want, but not as a byte string
18:54:16 <tristan_1> and I can't just pack it, that is not the representation I want
18:54:51 <Eduard_Munteanu> > intToDigit 10
18:54:52 <lambdabot>  'a'
18:55:46 <Eduard_Munteanu> tristan_1: I don't get it, what is the desired representation, binary form?
18:56:18 <tristan_1> it has to be ByteString for the crypto libs
18:56:46 <Eduard_Munteanu> tristan_1: oh
18:57:11 <tristan_1> hey wait i think I found it
18:57:22 <Eduard_Munteanu> tristan_1: but you need to establish a byte order
18:57:41 <tristan_1> decode from Data.ByteString.Base16
18:58:36 <Eduard_Munteanu> tristan_1: link?
18:59:06 <Eduard_Munteanu> @hoogle Data.Bytestring.Base16.decode
18:59:07 <lambdabot> package decoder-conduit
18:59:07 <lambdabot> package ghczdecode
18:59:07 <lambdabot> package mp3decoder
18:59:11 <tristan_1> http://hackage.haskell.org/package/base16-bytestring
18:59:20 <Eduard_Munteanu> Ah.
19:00:27 <erisco> I was excited with monads but the more I use them the less I like them... is that normal? they seem cumbersome and complicated
19:00:28 <Eduard_Munteanu> tristan_1: I don't think that does what you want, have you seen the 'encode' example?
19:00:48 <tristan_1> yea
19:00:58 <Eduard_Munteanu> Is that what you want?
19:01:14 <tristan_1> yup
19:01:19 <Eduard_Munteanu> decode "666f6f" = ("foo", "")
19:01:30 <tristan_1> yea, thats what I'm looking for
19:01:45 <Eduard_Munteanu> Ok.
19:03:18 <rose> What's an elegant way to code this? I have 100 actions that I can run, and I want to run the one with the lowest index. Each action has a condition that makes it possible to run the action.
19:04:01 <erisco> rose, that sounds a tad vague to me. what is the type of the container holding the actions?
19:04:24 <rose> The actions are just functions I create
19:04:49 <erisco> okay so is the type [a -> b] or what?
19:04:56 <rose> sure
19:05:07 <Eduard_Munteanu> rose: what is the index then?
19:06:10 <Eduard_Munteanu> > sequence_ [putStr "Hi ", putStrLn "there!"]  -- like this?
19:06:11 <lambdabot>  <IO ()>
19:06:36 <rose> I only mention index to emphasize that the functions have priority. Like you're choosing what to do, and you could choose to bike if it's sunny, if it's not, go swimming. And if the pool is closed, go for a rainy hike.
19:06:49 <rose> so biking has a higher priority over swimming
19:07:01 <rose> and swimming has a higher priority over hiking
19:07:19 <Eduard_Munteanu> rose: you can sort the list if the priorities are static
19:07:29 <alan1> test
19:07:51 <Eduard_Munteanu> Test failed, insert coin. <blink> <blink>
19:07:52 <rose> ak, given I have a sorted list of functions that all have the same type, what's a good way to say, keep trying actions until you hit one that works?
19:07:53 <RustyShackleford> how would you generate prime numbers?
19:08:05 <RustyShackleford> I've used a sieve before
19:08:31 <RustyShackleford> i don't know how you'd do it efficiently and without side effects
19:09:40 <erisco> rose, how do you determine if a function works?
19:09:41 <Eduard_Munteanu> rose: foldr (<|>) empty
19:10:08 <Eduard_Munteanu> If you have an Alternative.
19:10:28 <erisco> > [1,2] <|> [3,4]
19:10:29 <lambdabot>  [1,2,3,4]
19:10:39 <erisco> I don't know if that would be the idea of "trying until one worked"
19:11:03 <Eduard_Munteanu> > ZipList [1,2] <|> ZipList [3,4]
19:11:05 <lambdabot>  Could not deduce (Control.Applicative.Alternative
19:11:05 <lambdabot>                      Control.Applicative.ZipList)
19:11:05 <lambdabot>    arising from a use of `Control.Applicative.<|>'
19:11:05 <lambdabot>  from the context (GHC.Num.Num a)
19:11:05 <lambdabot>    bound by the inferred type of
19:11:21 <Twisol> > foldr <|> empty [const Nothing, const Nothing, const (Just 4)]
19:11:22 <lambdabot>  Could not deduce (Control.Applicative.Alternative
19:11:23 <lambdabot>                      ((->) [b0 -> Data.Maybe.Maybe a0]))
19:11:23 <lambdabot>    arising from a use of `Control.Applicative.empty'
19:11:23 <lambdabot>  from the context (Control.Applicative.Alternative
19:11:23 <lambdabot>                      ((->) (a -> b -> b)))
19:13:18 * flebron wonders if he can ask for help with some code that's using DataKinds and GADTs to have some dependent typing
19:13:48 <rose> Why is the <|> implementation for Alternative []   this: (++) ?
19:13:53 <Eduard_Munteanu> > foldr (<|>) empty [Nothing, Nothing, Just 3, Just 4]
19:13:54 <lambdabot>  Just 3
19:14:17 <erisco> the Maybe Alternative would make sense, rose
19:14:19 <flebron> I'm writing up a statically checked AVL tree. The code currently is at http://fedelebron.com:8000/static/AVL.hs .
19:14:21 <erisco> as Eduard_Munteanu shows :)
19:14:34 <rose> Eduard_Munteanu: That'll work, thanks
19:14:35 <Eduard_Munteanu> rose: because that's valid wrt the laws too
19:14:43 <erisco> rose, it is that because it can be (ie it satisfies the Alternative laws)
19:15:24 <flebron> The issue is that during AVL insertion, in the last case for insertUnbalancedAt, the case _should_ be (Rightie p (Leftie b g t1) (Rightie a t2 d)) (don't worry, I checked). However, I can't do this, because I'm inserting a AVLNode (Succ n) a, so I know its height is >= 1, but GHC can't prove it's >= 2.
19:15:47 <Eduard_Munteanu> rose: in particular it works for [] ++ anything
19:15:47 <Eduard_Munteanu> flebron: ok...
19:16:10 <flebron> So GHC can't say "OK, I'll just construct a context for height n >= 2, ...", because it can only prove (due to it being (Suc n)) it's >= 1.
19:16:18 <flebron> How could I do this insertion, then?
19:16:59 <flebron> Note in insert :: Ord a => a -> AVLTree a -> AVLTree a, AVLTree is an existential type, so I no longer know the height of the tree (so GHC can't use it to prove "Oh hey, this branch only exists when n >= 2".)
19:17:13 <Eduard_Munteanu> flebron: you can use classes
19:17:23 <flebron> How would that go?
19:18:10 <Eduard_Munteanu> flebron: each instance can pattern-match your natural
19:18:10 * flebron is really new to this whole pseudo-dependent-typing business, so I've been hitting my head against this for a few hours :p
19:18:23 <flebron> Ohhhhh
19:18:27 <flebron> I have an insert defined in the _typeclass_
19:18:42 <flebron> And each height has its own insert code!
19:18:49 <Eduard_Munteanu> Yes.
19:19:01 <flebron> Cool, that seems like it'd work. I'll give it a think :)
19:20:30 <Eduard_Munteanu> flebron: you can also use an existential GADT to decide whether something's 0, 1 or 2.
19:20:40 <flebron> How would that be?
19:22:26 <Eduard_Munteanu> flebron: data NonEmptyAVL :: * where OneLevel :: AVLNode (Succ Zero) -> NonEmptyAVL; AtLeastTwoLevels :: AVLNode (Succ (Succ n)) -> NonEmptyAVL
19:22:43 <Eduard_Munteanu> Er, add another * argument for the element type.
19:24:56 <Eduard_Munteanu> flebron: as a rule of thumb, GADTs like that are much like typeclasses except you have manual instance resolution. You can even combine the two with data families, if e.g. you don't want to bother the user to provide a proof, but you'd like to keep your stuff out of typeclasses.
19:25:56 <cdk> @src inits
19:25:57 <lambdabot> inits []     =  [[]]
19:25:57 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
19:27:04 <frege> what's the best book for haskell?
19:27:30 <Eduard_Munteanu> frege: for a newcomer, or how do you mean?
19:27:40 <Eduard_Munteanu> @where lyah
19:27:40 <lambdabot> http://www.learnyouahaskell.com/
19:27:46 <dhrosa_> frege: learn you a haskell is excellent for starting out ^
19:28:13 <frege> I've been coding in Python, C, java, GoLang,.. for some years now
19:28:40 <frege> know a bit of functional programming; lambda map/reduce generators,..
19:28:53 <twiceler> frege: Have you programmed in frege at all? :)
19:28:54 <frege> considering that; what do you suggest?
19:29:02 <dilinger> still suggest LYAH
19:29:02 <frege> no I haven't :)
19:29:14 <frege> ok
19:29:33 <kleinucopia> is there a way to make a local hoogle search all packages by default?
19:32:47 <flebron> Eduard_Munteanu: Many thanks, by the way - I still can't believe you went and read a fat blob of code and understood it just to help some poor schmuck with a very involved question :p
19:33:34 <tippenein> ^ the reason #haskell is the greatest
19:33:39 <zRecursive> Eduard_Munteanu: what's "manual instance resolution" ?
19:34:36 <Twisol> he timed out :S
19:35:24 <SLi> Hm, is it expected that enabling OverloadedStrings in GHC can make otherwise good code not compile (for example, makeRegex "foo")?
19:36:57 <afsmi> Am i mistaken or does DeriveFunctor create instances of the sort where fmap (Foo (Bar a)) = Foo (fmap (Bar a)) when Bar is a data constructor of another Functor? (where Foo is a constructor of a type (Baz a))
19:38:57 <shachaf> afsmi: That looks like a type error, and also looks like it's matching two constructors deep at a time, so it's probably at least a bit mistaken.
19:39:13 <erisco> Cale, sorry what was that name you gave me yesterday? I've lost it
19:39:55 <shachaf> DeriveFunctor's derived instance is very structural, corresponding in a pretty simple way to the definition your ADT.
19:41:54 <afsmi> but if fmap :: Baz a -> Baz b  then must it map into the contained functor somehow?
19:42:16 <shachaf> fmap :: Baz a -> Baz b is a type error. :-(
19:42:41 <shachaf> Can you give an example of what you mean?
19:42:49 <afsmi> Ok. hold on
19:43:37 <afsmi> data Act = Quit | Readstuff (String -> Next) deriving (Functor)
19:43:48 <afsmi> (i am taking another look at free monads)
19:44:07 <afsmi> errr
19:44:09 <afsmi> sorry
19:44:29 <afsmi> Act next = Quit | Readstuff (String -> next) deriving (Functor)
19:45:07 <shachaf> data
19:45:10 <shachaf> OK.
19:45:16 <shachaf> And what's the question?
19:45:26 <maxiepoo> so is it impossible to catch an exception thrown by pure code?
19:45:40 <maxiepoo> like if I have a non-IO function f :: a -> b
19:45:45 <shachaf> maxiepoo: You can catch it using IO.
19:46:47 <shachaf> (But possibly you shouldn't.)
19:47:17 <afsmi> fmap Pure (Readstuff id)  is an an Act (Free f String)  and not an Act (Free f (String -> String)) or something like that
19:47:23 <flebron> How can I write this in a valid way? class GreaterThanOne; instance GreaterThanOne (Succ (Succ n));
19:47:47 <maxiepoo> shachaf: how? the stuff in System.IO.Error looks like it all only works if the code throwing the error is in IO
19:47:56 <flebron> Err, class GreaterThanOne n;, of course.
19:48:16 <afsmi> and I am wondering if fmap (Readstuff id) = Readstuff (fmap id)
19:48:20 <afsmi> err
19:48:27 <maxiepoo> and I have a good reason
19:48:28 <shachaf> afsmi: whoa, whoa, whoa, you're bringing a lot of complicated things into the mix here.
19:48:35 <twiceler> flebron: instance (GreaterThanOne n => GreaterThanOne (Succ n)) where
19:48:36 <afsmi> Well you asked for an example :)
19:48:40 <afsmi> sorry
19:48:42 <shachaf> maxiepoo: Maybe look at how spoon does it.
19:49:10 <flebron> twiceler: That by itself means nothing is an instance of GreaterThanOne
19:49:20 <shachaf> afsmi: Yes, but I think simplifying will help you understand.
19:49:27 <shachaf> maxiepoo: http://hackage.haskell.org/package/spoon-0.3.1/docs/src/Control-Spoon.html
19:49:29 <jtcwang> I have a module in martingale.hs and the test function is in martingaleTest.hs, how do I load the modules in martingale.hs?
19:49:34 <flebron> Oh, I should manually say instance GreaterThanOne (Succ (Succ Zero))?
19:49:35 <twiceler> flebron: Along with the base case of instance (GreaterThanOne (Succ Zero))
19:49:40 <flebron> Yeah :)
19:49:51 <twiceler> oh, right, 1 is not greater than 1
19:50:13 <shachaf> afsmi: Anyway, what's the question?
19:50:36 <maxiepoo> oof deepest and unsafePerformIO
19:51:03 <shachaf> Ignore the deepseq. teaspoon is the one true spoon.
19:51:09 <shachaf> And also spoon is a hack.
19:51:21 <flebron> twiceler: I get http://lpaste.net/6888989992161378304
19:51:25 <afsmi> Ok, here's another. fmap Just (Readstuff id) :: Act (Maybe String) , and (Readstuff (String -> next) is an Act next) , so does fmap Just (Readstuff id) = Readstuff (fmap Just id)?
19:51:59 <flebron> (I have data Nat = Zero | Succ Nat, and DataKinds.)
19:51:59 <AshyIsMe> jtcwang: this section of lyah should help: http://learnyouahaskell.com/modules#making-our-own-modules
19:52:00 <afsmi> from the derived Functor
19:52:39 <afsmi> ((-> r) being a Functor)
19:52:40 <shachaf> afsmi: I think you're confusing values and types here a lot, so I'd suggest being careful about that.
19:52:42 <afsmi> ok
19:52:43 <twiceler> twiceler: Ahh DataKinds! Not familiar with them. Not sure what to do then
19:52:55 <Twisol> shachaf: IIRC, afsmi's question was what the code DerivingFunctor generates for fmap looks like.
19:53:07 <shachaf> afsmi: Is that the question?
19:53:47 <afsmi> it does load in ghci for me
19:53:50 <afsmi> just fine
19:53:54 <shachaf> Here's one answer to that: Compile your file with -ddump-deriv and GHC will tell you exactly.
19:53:57 <afsmi> OK
19:54:01 <afsmi> thank you
19:54:05 <afsmi> i will try that.
19:54:34 <maxiepoo> hm maybe there's some other way of doing this? Basically I have a library and a server that uses that library. The library uses error to say "an internal assumption was violated"
19:54:51 <jtcwang> AshyIsMe, it still says: "    Could not find module `MartingaleSim'
19:54:51 <jtcwang> " even though I have done the module thing as well as exported functions. They're in the same directory
19:55:09 <shachaf> afsmi: Are you looking for this id business to be some sort of functor law? If so, it isn't.
19:55:11 <twiceler> flebron: You could just do data Zero; data Succ a and forget DataKinds if you don't need it for something else
19:55:16 <jtcwang> I can load martingale.hs but not the other
19:55:21 <flebron> twiceler: I indeed do :p
19:55:32 <maxiepoo> so an error is only triggered if you've found a bug in the library
19:55:35 <twiceler> flebron: I have never been happy doing type-level arithmetic in Haskell
19:55:43 <shachaf> maxiepoo: Well, it looks like spoon is handling an ErrorCall exception there.
19:55:49 <shachaf> maxiepoo: Sounds like you should be able to do the same thing/
19:55:52 <shachaf> ?
19:56:36 <shachaf> (But also notice that it uses evaluate.)
19:57:28 <AshyIsMe> jtcwang: hmm not sure, maybe you can only have one module per file and they need to match the file name?
19:57:50 <AshyIsMe> slight case of the blind leading the blind if you listen to me :/
19:57:52 <jtcwang> i'll look into that
19:57:54 <afsmi> if  Readstuff (a :: String -> next) constructs an (Act next), then must an Act (Maybe String) be  constructed by Readstuff (b :: String -> (Just next)) effectively speaking
19:57:58 <maxiepoo> ah evaluate
19:58:01 <maxiepoo> that's what I need
19:58:04 <maxiepoo> thanks
19:58:19 <Twisol> AshyIsMe: I suspect that is the case.
19:58:28 <afsmi> i am wondering how liftF from the free monad does this
19:58:42 <afsmi> err
19:58:43 <afsmi> sorry
19:58:52 <shachaf> afsmi: That sounds right.
19:58:57 <afsmi> i am wondering what's going on, in my code, using derived functors
19:58:58 <jtcwang> AshyIsMe, yeah its the file name, which makes sense
19:59:05 <jtcwang> should've thought of that
19:59:12 <shachaf> afsmi: What are you wondering in particular?
20:01:34 <afsmi> liftF = Free . fmap Pure,  and i have a derived instance of Functor for my (Act next) type, and liftF $ (Readstuff id) makes a Free Act String
20:01:41 <afsmi> I am wondering how it gets into that function
20:01:52 <afsmi> supplied to Readstuff
20:02:04 <shachaf> The Functor instance for data Act a = Quit | Read (String -> a) would look like this, if that's the question:
20:02:07 <shachaf> instance Functor Act where fmap _ Quit = Quit; fmap f (Read k) = Read (fmap f k)
20:02:27 <shachaf> The inner fmap here happens to be function composition, i.e. "fmap f k" is "f . k"
20:02:30 <afsmi> yes
20:02:34 <shachaf> OK, this is a question about Free?
20:02:40 * flebron got it to compile but needed UndecidableInstances... this is likely bad :s
20:02:40 <afsmi> it's not
20:02:44 <afsmi> specifically
20:02:53 <afsmi> but that is what i was wondering in particular
20:03:04 <afsmi> but you answered my question
20:03:23 <shachaf> The fact that your Functor instance is derived has little to do with how it behaves, since Functor instances are unique.
20:04:25 <flebron> shachaf: Does this smell good? http://lpaste.net/2166977903261122560
20:05:25 <shachaf> flebron: help
20:05:25 <afsmi> shachaf: Ok i figured there must be some kind of uniqueness property. I wondered how i was getting that type
20:05:28 * flebron is needing UndecidableInstances, FlexibleInstances, and TypeSynonymInstances for it, so it smells...
20:06:15 <afsmi> shachaf: Thanks again for your help
20:06:45 <flebron> shachaf: What should I help with? O.o
20:06:46 <twiceler> flebron: Welcome to type-level arithmetic in Haskell. Eventually it will break you! But that code looks fine. Replace Two with Succ (Succ Zero) and you can remove TypeSynonymInstances if you want
20:07:03 <flebron> Well, is my code actually "unsafe"?
20:07:10 <flebron> (As per undecidableinstances)
20:07:23 * flebron isn't sure what that extension entails
20:07:35 <twiceler> flebron: What error do you get without UndecidableInstances?
20:08:17 <flebron> Err, it's complaining about another instance declaration, specifically:
20:08:25 <flebron> instance (GreaterThanOne n) => Insertable n where
20:08:49 <flebron>  Constraint is no smaller than the instance head in the constraint: GreaterThanOne n (Use -XUndecidableInstances to permit this)
20:08:51 <twiceler> flebron: Ahah! You can rectify that
20:08:56 <shachaf> flebron: I don't know, why did you ask me?
20:08:57 <flebron> Ohh
20:08:59 <flebron> Let me guess
20:09:02 <flebron> GreaterThanZero
20:09:07 <flebron> Insertable (Succ n)?
20:09:26 <twiceler> flebron: Actually, yes that should work I think
20:09:39 <jtcwang> I have an ADT WinLose = Win | Lose
20:09:56 <jtcwang> how would i export that so i can do pattern matching using Win or Lose in another file?
20:10:03 <twiceler> I was thinking of something more painful (just *use* GreaterThanOne instead, or rederive what it means to be GreaterThanOne in Insertable)
20:10:32 <flebron> :D
20:10:52 * flebron has no idea what he's doing, by the way
20:11:06 <Twisol> jtcwang: module MyWinLoseModuleName (WinLose(..)) where
20:11:48 <flebron> Is FlexibleInstances unsafe, btw?
20:12:10 <jtcwang> Twisol, got it thanks
20:12:15 <Twisol> no problem
20:12:44 <shachaf> flebron: It's possible to make GreaterThanOne without UndecidableInstances or FlexibleInstances.
20:13:12 * hackagebot optional 0.0.1 - Using type-classes for optional function arguments  http://hackage.haskell.org/package/optional-0.0.1 (TonyMorris)
20:13:17 <shachaf> Should be possible?
20:13:17 <flebron> How?
20:13:40 <twiceler> flebron: I don't think that FlexibleInstances is unsafe... but I'm not sure
20:13:50 <shachaf> How about class GT0 n; instance GT0 (S n); class GT1 n; instance GT0 n => GT1 (S n) or something.
20:14:40 <twiceler> shachaf: Ooh clever
20:14:47 <flebron> Oh, instance GreaterThanZero (Succ n) seems to work.
20:16:50 <smith_> Is there a good library for working with git? I'm looking to do a git clone from a Haskell program.
20:17:03 <smith_> Besides just calling git itself from System.Process, that is.
20:17:45 <blaenk> probably some libgit2 bindings
20:17:50 <blaenk> is what you'll want to look for
20:18:28 <maxiepoo> http://hackage.haskell.org/package/gitlib ?
20:19:24 <maxiepoo> it's those fp-complete guys so probably good
20:20:05 <smith_> I'll check out gitlib; thanks.
20:25:18 <zacts> lo
20:39:44 <erisco> @src filter
20:39:44 <lambdabot> filter _ []     = []
20:39:44 <lambdabot> filter p (x:xs)
20:39:44 <lambdabot>     | p x       = x : filter p xs
20:39:44 <lambdabot>     | otherwise = filter p xs
20:40:30 <maxiepoo> in what sense is "linear pattern-matching" linear? Like linear logic or what?
20:41:08 <shachaf> What is linear pattern-matching?
20:41:24 <erisco> ah, you can implement filter with fold
20:41:26 <maxiepoo> as opposed to non-linear pattern matching
20:41:32 <erisco> of course. so the class for filtering is Foldable
20:41:39 <maxiepoo> like how in Haskell you can't do
20:41:44 <shachaf> Where does the term come up?
20:41:46 <maxiepoo> same x x = True
20:41:52 <maxiepoo> same _ _ = False
20:42:09 <Twisol> I ran up against that myself recently. Nice to have in Prolog, sort of sad it's not in Haskell.
20:42:16 <maxiepoo> but you can in prolog/erlang
20:42:17 <shachaf> Oh. I've never heard that.
20:42:24 <shachaf> Where did you read it?
20:42:43 <shachaf> I'm sort of glad that it's not in Haskell because I can't imagine a meaning for it that I would like.
20:42:57 <maxiepoo> I heard it when talking to someone at a workshop thing
20:43:05 <maxiepoo> here's a mailing list post about it http://www.mail-archive.com/haskell@haskell.org/msg03721.html
20:43:12 <Twisol> I suppose it depends on there being a valid Eq instance for the type of the two values.
20:43:15 <maxiepoo> I agree with the argument against it
20:43:27 <Twisol> Prolog has a much simpler type system IIRC, so it can get away with having it built in
20:43:33 <maxiepoo> Twisol: right, that's why I don't think it's a good idea
20:44:10 <yggr> can anyone help me resolve this?: http://npaste.de/p/st3/
20:44:15 <maxiepoo> it bakes Eq into the syntax
20:44:18 <shachaf> Eq equality is a different sort of thing from pattern-matching (structural) equality.
20:44:35 <shachaf> Except in a few cases, like Num instances (and IsString in GHC).
20:45:05 <maxiepoo> oh so that's even worse
20:45:21 <Twisol> right, which is why it makes sense for that not to be baked into Haskell. Hence why we have guards. :D
20:45:37 <maxiepoo> yeah I just never understood the term
20:45:42 <shachaf> Miranda had it.
20:46:00 <maxiepoo> kind of like I never understood what fix was taking a fix point of
20:46:07 <shachaf> In his book SPJ talks about how it's a headache so he chooses to ignore it.
20:46:11 <shachaf> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/065.HTM
20:46:19 <shachaf> Anyway, "linear" -- in a lot of cases, like linear logic and linear types and linear algebra -- often means something like "exactly one".
20:46:35 <shachaf> Maybe in that context you should call patterns "affine" instead!
20:47:39 <maxiepoo> oh well I don't know what affine means either
20:48:30 <shachaf> "at most one"
20:48:54 <maxiepoo> ah
20:49:05 * shachaf waves hands around
20:53:16 * hackagebot readable 0.1.0.2 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.1.0.2 (DougBeardsley)
20:59:07 <maxiepoo> ugh I hate libraries that implement monads that are just monoids
20:59:16 <maxiepoo> Blaze, Binary
20:59:20 <maxiepoo> not cool!
21:01:59 <shachaf> Writer is not uncool
21:02:16 <ltze> how would I go about diagnosing errors like "HandshakeFailed (Error_Packet_unexpected "Alert [(AlertLevel_Fatal,BadRecordMac)]" " expected: change cipher")" and "HandshakeFailed (Error_Packet_Parsing "Failed reading: invalid header type: 69\nFrom:\theader\n\n")" from haskell-tls?
21:02:59 <maxiepoo> oh wait Binary is actually a writer
21:03:11 <maxiepoo> but Blaze is not
21:04:00 <CosmikDaniel> You all work for Brother Miguel, so that you may keep me his.
21:04:08 <maxiepoo> it has (>>=) = (>>)
21:04:55 <ParahSailin> hows that typecheck..
21:05:11 <ParahSailin> ltze: first with an lpaste
21:06:09 <ltze> I was hoping for instantaneous gratification, let me minimize a test case down ;)
21:06:33 <maxiepoo> h1 >>= f = h1 >> f (error "Text.Blaze.Internal.MarkupM: invalid use of monadic bind")
21:07:08 <maxiepoo> it's just a hack so you can use `do` notation
21:07:08 <ParahSailin> ltze: it looks like its expecting tls records when the other side of the socket thinks you are in plaintext mode
21:07:47 <ltze> true enough, but I'm connecting to IRC servers on SSL ports as far as I can ascertain
21:09:56 <ParahSailin> maybe IRC needs a STARTTLS message before the server expects a TLS ClientHello?
21:10:45 <ParahSailin> wireshark a tls connection to freenode or whatever
21:11:14 <ParahSailin> im curious to know for myself as well
21:13:19 * hackagebot hOpenPGP 0.10 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.10 (ClintAdams)
21:13:40 <erisco> :t (.) ($)
21:13:41 <lambdabot> (a -> a1 -> b) -> a -> a1 -> b
21:13:51 <erisco> can I get a -> a1 -> (a -> a1 -> b) -> b simply?
21:15:13 <erisco> @pl \x -> (.) ($) x a b
21:15:14 <lambdabot> flip ($ a) b
21:15:21 <CosmikDaniel> You all work for Brother Miguel, so that you may keep me his.You all work for Brother Miguel, so that you may keep me his.
21:18:13 <erisco> :t \x y -> flip ($ x) y
21:18:14 <lambdabot> a -> b -> (a -> b -> c) -> c
21:21:40 <ltze> hm, tls-simpleclient https://github.com/vincenthz/hs-tls/blob/master/debug/src/SimpleClient.hs from tls-debug seems to work without any starttls-alike
21:23:05 <maxiepoo> @options
21:23:05 <lambdabot> Unknown command, try @list
21:23:08 <maxiepoo> @list
21:23:08 <lambdabot> What module?  Try @listmodules for some ideas.
21:23:14 <maxiepoo> @listmodules
21:23:14 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
21:23:16 <ParahSailin> ltze: connects to the ircd?
21:23:28 <ParahSailin> /msg lambdabot
21:23:35 <maxiepoo> yea sorry
21:24:28 <xexonixxexillion> Does anyone have an estimate of what percentage of people use a Haskell compiler other than ghc?
21:25:11 <ltze> well. I changed pConnectVersion = TLS10 (was TLS12 before) in my client parameters and it works *sometimes*
21:26:33 <erisco> how does the type signature work at the top level when you have (a, b) = foo?
21:27:07 <jle`> erisco: you can specify type signatures anywhere
21:27:13 <jle`> they don't have to be next to the function
21:27:15 <udevd> did anyone from you used Numeric.GSL.Minimization functions? I have "gsl: simplex2.c:372: ERROR: non-finite function value encountered\inInterrupted." error and I don't really see why --- all initial datas are finite and function does not have singularities
21:27:22 <jle`> so you can just independently specify a and b, if they are different
21:27:27 <erisco> hm not sure why I get type scope problems
21:27:38 <jle`> erisco: post source?
21:27:41 <erisco> they are not different
21:28:10 <erisco> http://lpaste.net/97856
21:28:31 <jle`> you can also use the handy a, b :: Something
21:28:58 <jle`> which might be useful here
21:29:02 <erisco> I have the rror "cannot match type n with n1"
21:29:09 <erisco> even with the comma thing
21:31:54 <erisco> I annotated with the full error report http://lpaste.net/97856
21:31:55 <jle`> that doesn't sound like a scoping error, that sounds like a type error
21:32:13 <jle`> oh
21:32:19 <jle`> just read the error
21:32:25 <erisco> I did
21:32:30 <erisco> I do not understand it
21:33:02 <jle`> *i just read the error
21:33:21 * hackagebot hOpenPGP 0.10.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.10.1 (ClintAdams)
21:34:13 <erisco> Cale, hey can I get the name you gave me yesterday? I've lost it. thanks
21:34:38 <flebron> erisco: Perhaps you can use MemoServ to send Cale a memo?
21:35:00 <Polarina> When making a library binding, is it possible to have cabal use pkg-config to check the foreign library version and set C flags such as where to find the include headers?
21:36:57 <erisco> hm I realize now that I need a different notion of height
21:37:05 <erisco> but nonetheless, not sure how to repair the type error
21:38:00 <shachaf> maxiepoo: secret bonus mode: /msg lambdabot ?
21:38:31 <erisco> I thought that kind of TLD was allowed but perhaps not
21:39:04 * flebron is losing his mind, it seems...
21:39:12 <shachaf> That is, sending a question mark.
21:39:14 <Cale> erisco: what name?
21:39:25 <erisco> the graph person
21:39:34 <Cale> Oh ivanm
21:39:40 <erisco> ah thanks
21:39:51 <Polarina> Nevermind, I found it. It's 'pkgconfig-depends'. :-)
21:40:09 <maxiepoo> oh cool thanks
21:40:10 <flebron> shachaf: Can you think of any reason why line 111 isn't typing? It's _literally_ the same thing I'm pattern matching against, ::'d to the same type I have in my type signature. http://lpaste.net/7319506428601827328
21:40:35 <maxiepoo> @free
21:40:35 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
21:40:38 <maxiepoo> !
21:41:03 <flebron> (I apologize for the crappy type, I'm just trying everything I can think of to make this damned thing compile.)
21:41:16 <shachaf> flebron: I wonder why you keep addressing me specifically.
21:41:29 <shachaf> I hardly know anything about fancy type-level business.
21:41:33 <erisco> cuz shachaf has the skillz
21:41:42 <flebron> Oh haha, I thought you did from the UndecidableInstances thing.
21:41:51 <flebron> But yeah, question for "the audience" I guess: What is GHC smoking there? :s
21:42:22 <shachaf> Usually it turns that that it's you and not GHC who's smoking.
21:42:59 <flebron> Well, I'd be inclined to agree, but I have something similar to f :: a -> b, f x = let y = x :: a in undefined, and ghc's complaining.
21:43:22 <shachaf> Maybe you want to turn on ScopedTypeVariables.
21:43:43 <flebron> I mean for a and n to be the same ones as in the type signature. Isn't that the default?
21:43:43 <shachaf> Since that "a" on the inside isn't the same as the "a" on the outside.
21:44:09 <flebron> It isn't? How can I make it so, just enabling ScopedTypeVariables?
21:44:16 <shachaf> No, it isn't a thing that happens in regulation Haskell.
21:44:30 <shachaf> Enable ScopedTypeVariables and use a forall (which you're already using).
21:44:55 <shachaf> You can tell they're different by how GHC renamed one of them to "a1".
21:45:22 <flebron> :o That worked.
21:45:33 <flebron> Thanks :) (See why I pester you? ;) Just kidding.)
21:47:13 <ParahSailin> yeah, i was wondering why type variables are not scoped, by default
21:47:46 <ParahSailin> because it seems pretty "obvious" to anyone who does not know that they aren't, that they should be
21:48:39 <erisco> so the extension is "exists. ..." ? :)
21:49:48 <Polarina> Why would cabal give me this error when I do `cabal sdist'? cabal: cbits: inappropriate type
21:56:52 <stolaruk> @type forall
21:56:53 <lambdabot>     Not in scope: `forall'
21:56:53 <lambdabot>     Perhaps you meant `forAll' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
21:57:19 <stolaruk> @type forAll
21:57:20 <lambdabot> (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
21:57:20 <osa1> "The function `postsSplice' is applied to one argument, but its type `[Post] -> [b0]' has only one" hm
21:58:13 <ltze> ParahSailin: it looks like, after using TLS10 to connect, I get failures when the server sends back a "reconnecting too fast" message, which is sent unencrypted and which also confuses wireshark
21:58:24 * hackagebot coordinate 0.0.6 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.6 (TonyMorris)
21:59:25 <ParahSailin> ltze: sounds like non-compliant server
22:01:06 <ltze> ParahSailin: were it one server rather than every one I've tried I'd agree entirely, but now I'm curious what OpenSSL and friends do here
22:01:31 <ParahSailin> so it does this on the first connection
22:02:01 <ltze> with TLS10 I've only seen it do this after several attempts when sending the too-many-reconnects message
22:04:33 <jle`> i answered an innocent haskell question on twitter and the guy sent off four tweets yelling at me for being unnatural and calling him a dumbass -.-
22:04:41 <jle`> (which i didn't)
22:04:43 <jle`> oh well
22:04:59 <Rileld> Hi all. I'm fairly new to haskell and am trying to install yesod. yesod-bin fails to install: http://lpaste.net/97859. Can anyone help me out?
22:04:59 <erisco> Cale, for functors, I am finding that mapping 'a' to (a, s) to keep state type 's' is more practical than using the State monad
22:05:13 <blaenk> jle`: yell right back at him
22:06:13 <shachaf> #yesod might know about Yesod questions.
22:07:07 <Rileld> shachaf: I don't think it's a Yesod question. It seems like there's a dependency missing or something. But I'm not sure how to figure out what's going wrong.
22:07:29 <Rileld> It's definitley possible I'm wrong though...
22:07:41 <shachaf> Maybe try -vvv or -v3 or whatever the flag is?
22:07:49 <shachaf> There's a way to get more information.
22:09:29 <Aetherspawn> is there something like unfoldr (:: (b -> Maybe (a, b)) -> b -> [a]) where b is specialized to be a list with some remaining elements (and cancels early if it's completely consumed)?
22:10:52 <Fylwind> when using TypeFamilies is "family" a reserved keyword?
22:11:20 <lpsmith> Aetherspawn, I am now.
22:11:43 <Aetherspawn> Oh wow, heh
22:11:46 <Polarina> Fylwind, yes.
22:11:51 <Aetherspawn> uhh, I forget the question I had.
22:12:04 <lpsmith> hah,  oh well.
22:12:05 <Aetherspawn> it was something about one of your repos, sec.
22:12:46 <Aetherspawn> oh yeah, I was going to ask if the only way to subscribe to notifications in postgre-simple was to use execute_
22:12:50 <Fylwind> Polarina: thanks
22:12:56 <lpsmith> aye
22:13:30 <Aetherspawn> and if so, it'd be nice if something higher level was added in the Notifications module because execute_ kind of feels low level
22:13:44 <ltze> ParahSailin: aha, wireshark to the rescue
22:14:05 <Heffalump> can anyone point me at a reference that explains how top-level TH declaration splices break the normal dependency analysis in a Haskell module?
22:14:07 <ltze> in the case of reconnecting too fast, I connect on an SSL port and start speaking SSL to the server, but it doesn't speak SSL back until *after* it gives the "reconnecting too fast" message
22:14:16 <lpsmith> what would you suggest,  and how would that be an improvement?
22:14:18 <ltze> (at which point it sends a fatal TLS error to end the connection)
22:16:07 <Aetherspawn> I was more concerned yesterday when I was sifting through the docs, but along the lines of execute_ "LISTEN whatever" ==> subscribeNotification "whatever" or something. Whatever the case, don't worry too much
22:17:47 <Polarina> Could someone explain to me how Hackage generates the Haddock documentation for library bindings, without having the library itself?
22:18:24 <lpsmith> ahh,  well,  I suppose that might be useful assuming the "whatever" was properly quoted.    If it uses the syntax I _think_ it uses though,  I really need to update postgresql-libpq to require libpq  9.1 or later.
22:19:18 <lpsmith> Err, 9.0,  but I'm feeling ready to drop support for libpq 8.4's client libraries.
22:20:39 <erisco> how do I download all the haskell documentation possible easily
22:20:45 <erisco> going to lose Internet for a while
22:25:41 <TallerGhostWalt> So have there been any new updates on the status of ghc 7.8 since october?
22:25:49 <TallerGhostWalt> was there an unexpected snag?
22:25:52 <jle`> erisco: set the documentation flag on for your config file in .cabal
22:26:04 <erisco> what does that do
22:26:20 <erisco> can I get all of hackage and hoogle perhaps?
22:26:25 <jle`> it renders the haddock of all of your installed packages
22:26:33 <jle`> when you install a new one
22:26:38 <jle`> and you can go back and do the ones you've already installed
22:26:51 <jle`> oh, you want all of hackage? not just the packages you have?
22:27:05 <erisco> I mean the doc pages like this http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html
22:27:05 <jle`> seems not so useful if you don't have internet so you can't use any packages you don't have anyway
22:27:10 <jle`> erisco: yes, that is haddock
22:27:11 <erisco> is that the haddock?
22:27:12 <erisco> okay
22:27:34 <jle`> um there is a command to re-build all the documentation for all of your currently installed packages somewhere
22:27:56 <jle`> because just turning the flag on only affects future installations
22:32:36 <erisco> I am still trying to find .cabal
22:35:01 <lpsmith> erisco, ~/.cabal/config if you are using unix or MacOS
22:35:07 <erisco> windows
22:35:22 <Aetherspawn> erisco: set the flag and then run `cabal install world`
22:35:25 <lpsmith> ahh, I think somewhere in appdata then
22:35:36 <Aetherspawn> that should reinstall every package hence generating docs
22:35:55 <Aetherspawn> the docs are in ~/.cabal/docs/ or something like that
22:36:10 <Aetherspawn> theres an index.html file somewhere, although it only works with chrome and not firefox if you are on Windows
22:36:14 <Aetherspawn> this was fixed in cabal 18 sometime
22:58:31 * hackagebot sdl2 1.0.0 - Bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.0.0 (Polarina)
22:59:54 <Polarina> Yay!
23:02:17 <huser2014> Beginner question, why in ghc (hugs also) an evaluation is guarantee to be lazy even at the cost of memory?
23:02:17 <huser2014> Consider the foldl vs foldl' on big list with +. The runtime should see that if it runs out of stack memory and it has some unevaluated redex, it should reduse them and free memory.
23:02:17 <huser2014> I mean, lazy is a gift not an obligation, right?
23:02:57 <Polarina> huser2014, because if it would decide to evaluate it, it would change the meaning of the program.
23:04:48 <shachaf> huser2014: There have been some implementations that have tried things like that with various heuristics.
23:05:01 <shachaf> edwardk: You were talking about that at one point -- what was it called?
23:05:03 <huser2014> why? lazy as I understand it means "expression will be evaluated sometime between now and the time you actually need it" so why not when I am at memory full? It is like the cache.
23:05:36 <Polarina> huser2014, no. Lazy means it will *only* be evaluated when you need it.
23:05:39 <shachaf> huser2014: There's no guarantee that evaluating something is a good idea.
23:06:10 <shachaf> Polarina: Well, Haskell doesn't require laziness, that's just GHC's strategy for implementing what Haskell does require.
23:07:07 <shachaf> huser2014: And figuring out when it's a good idea isn't easy.
23:07:08 <shachaf> GHC does do strictness analysis and such to figure out when things are going to be evaluated anyway, but only as a static thing at compile-time.
23:08:51 <huser2014> so the problem is much harder then the problem memorization (cache) is solving? like if i have enough memory I can save (possibly) some cpu by not reevaluating something, but if i have no memory i will forget some evaluations that were done.
23:09:51 <huser2014> it is clear that if a reduction will not free the stack then a foldl' will fail too. so you are crashing but you were crashing anyway.
23:14:27 <zRecursive> huser2014: I feel that "strict"" just guarantees evaluation not "stack overflow"
23:15:34 <huser2014> Yes and that is my point, by trying to reduce what you can reduce in hope of making more memory available cannot hurt.
23:15:50 <huser2014> you are trading cpu cycles over memory.
23:15:56 <shachaf> Aha, I think I was looking for http://www2.berkeley.intel-research.net/~rennals/pubs/thesis.pdf
23:16:21 <huser2014> but only when it is clear that you have no more memory.
23:17:51 <zRecursive> will foldr' be tail recursive optimization by compiler ?
23:17:59 <huser2014> because if reducing the expressions will not get you more memory then you will not solve the problem if you try to do seq.
23:18:03 <shachaf> Or maybe for http://csg.csail.mit.edu/pubs/haskell.html
23:18:29 <shachaf> But I think the first one.
23:20:27 <flebron> Is there a way to ask GHC "does my function cover all cases of its input"?
23:21:04 <shachaf> -Wall
23:21:16 <flebron> Cool, thanks :) It even gives me the actual cases!
23:21:17 <huser2014> I'll read these articles and come back. The idea is that I was looking for projects to do in my spare time and this was bugging me for some time. Why not the runtime in times of need (no memory) will not choose to do some evaluations to free some.
23:22:00 <huser2014> this problem cannot be resolve at compile time, it is a problem similar to cache and io thread pool.
23:22:16 <shachaf> Because forcing a thunk will not necessarily free memory.
23:24:04 <huser2014> but if by forcing the thunk that consumes the most memory will not solve the problem, then by forcing the same evaluation by use of seq in the source code will not solve it either.
23:26:42 <huser2014> this runtime code will try to make foldl become foldl' WHEN you have no more memory. And not shift this burden to you, because maybe just transforming your source code from foldl to foldl' will not solve it either, so you are not in a good state, but you are int the best state posible without modifying the algorithms in source code.
23:30:20 <huser2014> in the eager haskell article is about the think that i want exept that i whould go lazy by default and become eager when no memory. not the other way around.
23:30:27 <zRecursive> Maybe "foldl -> foldl'" costs much memory than the lazy foldl :)
23:32:00 <huser2014> if foldl->foldl' will cost more and foldl is wasting all the stack that you can give to the program then even when you will change your program to use foldl' you will get in no better place.
23:32:06 <zRecursive> As lazy foldl is just thunk before evluation
23:33:49 <huser2014> the only benefit of strict foldl is when you are using a constant size acumulator, in this particular case foldl->foldl' process will surely free memory.
23:35:00 <zRecursive> What is "constant size acumulator" ?
23:35:46 <huser2014> as an example: foldl' + over ints.
23:35:59 <huser2014> so the acumulator will be an int.
23:36:04 <huser2014> constant size.
23:36:52 <zRecursive> ok
23:36:59 <huser2014> mind you the fold will still fail after you overflow the int but this is the classical example for the utility of foldl'  http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
23:38:35 * hackagebot sdl2 1.0.1 - Bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.0.1 (Polarina)
23:39:36 <ChongLi> anyone around?
23:40:40 <zRecursive> huser2014: foldl' will not create a big thunk, right ?  If so, then it will help .
23:42:10 <zRecursive> for a big list. but overflow the int still fails.
23:43:02 <huser2014> zRecursive: yes it will help but I had manually do a strictness constraint that will surely burn my cpu cycles and maybe save me from stack overflow.
23:43:49 <zRecursive> yeah
23:43:50 <huser2014> in this particular case the runtime is better equiped to decide if it needs to reduce some expressions by burning cpu.
23:45:09 <zRecursive> that depends
23:46:59 <huser2014> the cache works by the same reasoning.
23:47:59 <huser2014> the cache for instance can also misfire and you can have some algorithms that are better if you would not use cache.
23:48:31 <huser2014> but the average benefit of the cache is worth using it.
23:49:24 <maxiepoo> @pl \x -> fmap x . f
23:49:24 <lambdabot> (. f) . fmap
23:49:29 <zRecursive> Is "using cache" implicit ?
23:49:35 <maxiepoo> ew
23:49:59 <huser2014> I don't think that you can turn off the memorization of evaluations in ghc or hugs.
23:51:13 <zRecursive> i think so. then do we need to tweak the cache manually ?
23:52:37 <zRecursive> In fact i dont know how to adjust the cache
23:53:31 <huser2014> no, but here we have the problem that we don't have this cache equivalent code in the runtime, that will try to free some memory by reducing the thunks that it can.
23:53:37 * hackagebot GeBoP 1.7.3 - Several games  http://hackage.haskell.org/package/GeBoP-1.7.3 (HenkJanVanTuyl)
23:55:12 <huser2014> if we compare the laziness with the cache, we are now in laziness like we have a cache that is missing the code that forgets some cached values when the memory is full.
23:57:06 <huser2014> So to close the issue, I think that I will spend some time to learn how to put this kind of code in the runtime (ghc/hugs/ajhc, what ever will be easier).
23:57:18 <huser2014> thanks, all.
23:59:49 <zRecursive> I will be a interesting codes running when memory is full.
