00:00:56 <structuralist> class NotAFunctor (f :: U -> *) where notFmap :: (forall γ. γ ⊢ τ -> γ ⊢ τ') -> f τ -> f τ'
00:01:02 <structuralist> ^ correction
00:01:03 <structuralist> then
00:01:14 <structuralist> instance NotAFunctor Lifted where notFmap f (X t) = X (f . t)
00:01:15 <structuralist> works
00:03:35 <supki> AfC: interesting; could you paste project's .cabal file?
00:04:15 <structuralist> Twey: btw, what do you use for typing unicode?
00:04:43 <AfC> supki: ok, update: it's using GHC directly that's now generating it. The problem would seem to be there's a Control.Monad.Error in both monads-tf and mtl
00:04:47 <AfC> (what the hell)
00:05:10 <AfC> supki: and so GHC is bombing out with various things having caused both to be installed on the system
00:05:25 <AfC> [but cabal was doing it before. Now I have mtl listed there it seems happier]
00:05:25 <Twey> structuralist: A bunch of things depending where I am and what I want to type
00:05:41 <Twey> I have compose sequences for everything Haskell uses
00:05:47 <AfC> I guess I'll have to manually to a -package or whatever. How tedious
00:06:21 <supki> AfC: well, both monads-tf and mtl having the same module names should not be a problem for cabal if you depend only on one of them
00:07:58 <supki> AfC: there is an option of -XPackageImports extension, if things get really annoying
00:09:15 * hackagebot http-conduit 2.0.0.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.4 (MichaelSnoyman)
00:09:15 * hackagebot http-client 0.2.1.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.1.1 (MichaelSnoyman)
00:11:19 <anthezium> why does (> let bar = 4 :: Num a => a) typecheck, but (> let foo n = True :: Testable a => a) does not?
00:12:06 <peddie> AfC: can you use -XPackageImports and say 'import "monads-tf" Control.Monad.Error' ?
00:12:17 <Twey> anthezium: Because True has type Bool, not type Testable a ⇒ a
00:12:53 <Twey> anthezium: Whereas 4 has type Num a ⇒ a by default (check :t 4)
00:13:00 <Twey> :t 4
00:13:02 <lambdabot> Num a => a
00:13:11 <anthezium> Twey: but foo has type a -> Bool, not Bool
00:13:19 <anthezium> but this is a bad example
00:13:29 <anthezium> the actual example i'm trying to deal with
00:13:33 <anthezium> involves Integer -> Bool
00:13:38 <anthezium> which should be in the Testable typeclass
00:13:56 <AfC> peddie: I assume you mean "mtl", and yes, I just tried that. Seems to work
00:14:03 <AfC> peddie: how clumsy to have to do that.
00:14:15 <AfC> peddie: might as well tell us we have to package qualify all our imports :(
00:15:08 <Twey> anthezium: The annotation only applies to the left-hand side; you'll need a separate annotation if you want to talk about the whole function
00:16:01 <supki> anthezium: numeric literals are overloaded
00:16:17 <anthezium> let foo n = n == (4 :: Integer) :: Testable a => a
00:16:28 <Twey> anthezium: (but you can't give it that signature anyway: by saying it has type Testable a ⇒ a you're promising that it can be of *any* type Testable a ⇒ a, which isn't true, since it only has type Integer → Bool)
00:16:48 <supki> anthezium: when you type  4  it's actually  (fromInteger (4 :: Integer))
00:16:57 <mikeplus64> :t fromInteger
00:16:58 <lambdabot> Num a => Integer -> a
00:17:36 <Twey> > let x = 4 ∷ Num a ⇒ a in x ∷ Float
00:17:37 <lambdabot>  4.0
00:18:25 <Twey> anthezium: You can't later decide that a function of type Integer → Bool should have some other Testable type
00:18:40 <anthezium> whereas for the numbers
00:18:57 <anthezium> there are distinct concrete values of all of the e.g. Integral types for 4
00:19:24 <anthezium> so you can somehow say let n = 4 :: Integral a => a without loss of generality?
00:19:35 <Twey> anthezium: Right
00:19:43 <anthezium> that makes sense
00:20:13 <Twey> anthezium: Basically, when you give something a variable type like that, you're saying *somebody else* gets to choose which concrete type it gets
00:20:14 <anthezium> is it built-in magic or can you overload any old value like that?
00:20:31 <Rokko> magic
00:20:34 <Twey> So you have to be able to produce a value for any possible type that matches that signature
00:20:54 <jle`> basically
00:20:56 <jle`> it's a literal
00:21:01 <Twey> anthezium: You can write types like that for anything, but the number syntax being overloaded for any Num type by default is magic
00:21:09 <anthezium> okay, and this kind of magic is restricted to numbers and perhaps some other built-in types>
00:21:11 <anthezium> ?
00:21:18 <jle`> built in type classes
00:21:26 <Twey> jle`: ?!
00:21:36 <jle`> is he talking about literals?
00:21:44 <jle`> there are only a couple of overloaded literals
00:21:50 <jle`> maybe i jumped in at the wrong time
00:22:02 <anthezium> yeah, overloaded literals like "4"
00:22:15 <Twey> Oh, I see what you mean
00:22:24 <jle`> basically a literal is a fragment of source code that is translated into a data type by the compiler
00:22:29 <jle`> literally.
00:22:46 <Twey> anthezium: You can't define your own literal syntax, but you can give polymorphic types to anything that can take them
00:22:47 <jle`> it saves you the trouble of something like having to define a String by a list of bytecode
00:22:52 <Twey> :t mempty
00:22:53 <lambdabot> Monoid a => a
00:22:56 <Twey> :t maxBound
00:22:57 <lambdabot> Bounded a => a
00:22:59 <Twey> &c.
00:23:10 <anthezium> okay
00:23:15 <zRecursive> >maxBound
00:23:16 <jle`> imagine a world with no literals
00:23:30 <anthezium> so what i'm actually trying to do is make a heterogeneous list of quickCheck properties
00:23:35 <jle`> anyways in Haskell literals can be overloaded in a rigorous way
00:23:46 <Twey> anthezium: There's an extension to overload string syntax similarly (OverloadedStrings) and soon to be an extension to overload the list syntax.
00:24:01 <AfC> peddie, supki: solved it by adding `-hide-package monads-tf` to the ghc invocation. Thanks for your help.
00:24:11 * hackagebot network-conduit 1.0.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.2 (MichaelSnoyman)
00:24:12 <jle`> an integer-like literal can be any instance of the Num typeclass...and actaully i can define my own Num type and have it parse into that
00:24:13 <anthezium> I was doing something like let tests = [ stuff ] :: (forall a. Testable a => [a])
00:24:40 <jle`> a decimal-like literal can be any instance of Fractional
00:24:43 <Twey> anthezium: That's not heterogeneous.  You'll need to wrap the forall in a newtype to get actual existential types
00:24:50 <jle`> a string literal can be any instance of IsString
00:24:54 <anthezium> jle`: because the compiler gets to decide what type it gives to its "(Literal 4)" AST node or whatever?>
00:25:10 <anthezium> o snap
00:25:19 <jle`> well, you need an extension for overloaded string literals
00:25:20 <anthezium> Twey: thanks!
00:25:29 <jle`> and...are there any other overloaded literals?
00:25:36 <erisco> does createProcess not work with the windows PATH? it does not find my exe (does not exist)
00:26:01 <Twey> anthezium: newtype ATestable = ∀ a. Testable a ⇒ ATestable a; let tests = [ ATestable a, ATestable b, ATestable c ]
00:26:04 <supki> jle`: lists in HEAD
00:26:23 <Twey> jle`: Not yet
00:26:23 <anthezium> this overloaded literal thing is a crazy corner of Haskell I've never thought too clearly about before
00:26:29 <supki> anthezium: why do you need a list of properties?
00:27:06 <anthezium> purely because i want to test them in a slicker way than do { quickCheck prop1; quickCheck prop2; ... }
00:27:14 <supki> hmm
00:27:16 <anthezium> like mapM quickCheck listOfTests
00:27:23 <supki> I'd use a test framework then
00:27:40 <anthezium> i suppose that is the correct way to do this
00:27:45 <anthezium> it's a one-off .lhs file
00:28:02 <anthezium> i'm trying to fit everything i need in one file and minimize dependencies
00:28:19 <anthezium> but reinventing the wheel is rarely a good idea
00:28:47 <johnw> I bet you someday, someone is actually going to make a better wheel, and then we'll all be wondering why we avoided doing it for so long...
00:29:25 <anthezium> like the wheels in snowcrash with little telescoping robotic arms instead of treads!
00:29:32 <johnw> yeah, exactly!
00:30:04 <Twey> People are reinventing the wheel all the time
00:30:20 <AfC> Does anyone know whether blaze-builder is deprecated in favour of bytestring's new Builder module, or are they the same, or...
00:30:22 <Twey> Michelin are particularly famous for it
00:30:53 <anthezium> the devs @ my last job were really into reinventing the wheel
00:32:01 <anthezium> i ended up having to fix some recursive file copier thing in java that didn't do loop detection for links
00:32:15 <anthezium> there are already some nice wheels out there
00:36:52 <erisco> createProcess on windows is not heeding the PATH... any ideas?
00:39:13 * hackagebot hmemdb 0.3.1.2 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.3.1.2 (MiguelMitrofanov)
00:41:21 <johnw> AfC: good question, and I don't know
00:46:47 <jle`> hey, is it normal to use η = return
00:46:48 <markovirc> Hello jle`
00:46:58 <jle`> i kind of like it
00:47:03 <jle`> markovirc: hi markovirc
00:47:08 <DarkFox> Anyone here know of any Base62 libraries?
00:47:29 <johnw> jle`: you mean, is it normal to see it in Haskell code?
00:47:35 * DarkFox wrote one a while back... Gone through the logs here; somehow, it was never sent to hpaste........ ix.io and shell provider that is now dead . Lol
00:47:37 <jle`> johnw: yeah
00:47:41 <DarkFox> No links that still work </3
00:47:43 <johnw> not at all
00:47:44 <jle`> or if i started using it, would be it be anything new
00:47:50 <jle`> idk i kind of like it
00:47:59 <johnw> it's your source code!
00:48:03 <jle`> :)
00:48:09 <jle`> what if i started a tend
00:48:11 <jle`> trend
00:48:26 <jle`> idk, it's a better name than return.
00:48:38 <johnw> unicode operators/names in general are frowned upon mostly
00:48:51 <DarkFox> johnw: Indeed
00:49:07 <DarkFox> johnw: Otherwise we would probally have → as an alternate to -> :P
00:49:10 <dagle> Unless you are a fortress user? :)
00:49:29 <jle`> johnw: but that unicode-base package is so neat
00:49:33 <johnw> well, except in Agda of course :)
00:49:36 <ion> darkfox: I see what you did there.
00:50:00 <jle`> who doesn't want to use ¬ as not
00:50:10 <johnw> my Emacs displays not to me as ¬
00:50:17 <DarkFox> ion: You'd be surprised how much haskell code gets edited to have the → when displayed on a blog or website.
00:50:26 <DarkFox> ion: Or slides in a talk
00:50:26 <jle`> DarkFox: you can already use it i think with an extension
00:50:34 <ion> johnw: And breaks alignment?
00:50:35 <DarkFox> jle`: Probally
00:50:45 <jle`> johnw: ah. i have a couple of conceals on my vim too but i have disabled most of them
00:50:48 <jle`> i like my alignment
00:52:10 <johnw> it's true, alignment is an issue
00:52:22 <johnw> but I like seeing → λ ∧, etc., much more
01:01:18 <Kaidelong> @src Bounded
01:01:18 <lambdabot> class  Bounded a  where
01:01:18 <lambdabot>     minBound, maxBound :: a
01:12:32 <Kaidelong> is it okay to use error in code that should under no circumstances actually be reached by control flow?
01:13:04 <grohne> Kaidelong: http://www.haskell.org/haskellwiki/Error
01:13:12 <grohne> Kaidelong: short answer: yes
01:13:30 <maurer> Kaidelong: That is the main valid use of error
01:13:38 <Twey> Long answer: the fact that you have code that should under no circumstances be reached means you haven't designed your types right
01:13:54 <maurer> Twey: Not necessarily, the type system can't express some constraints
01:14:09 <grohne> like tail, fromJust, ...
01:14:10 <Twey> maurer: I didn't say designing them right was necessarily an option :þ
01:14:19 <Kaidelong> Twey: I'd need to be able to feed an indexer Int -> ElementalType to the type system
01:14:36 <maurer> Kaidelong: If you have a branch that you think shouldn't be reachable, just put error with a message explaining why you think this shouldn't happen
01:14:43 <maurer> so that at least when it fails, you'll know why you thought it was ok
01:14:46 <Twey> Kaidelong: And?  :þ
01:15:14 <Twey> maurer: The Haskell type system is pretty powerful, though.  I don't imagine there are many constraints left that it can't express.
01:15:45 <Kaidelong> I really don't know how to build this into the types, if you'd like to take a look at it Twey, you're welcome to, I can paste it
01:15:45 <grohne> Twey: then look into Agda, Coq and isabelle.
01:16:20 <Twey> Kaidelong: If your function can fail, you can always indicate so in the type (if that's what you're saying)
01:16:38 <Twey> grohne: Again?  :þ
01:16:50 <grohne> Twey: try for instance, to give a type for rational numbers with unique representation :)
01:16:54 <Kaidelong> it should not fail, if it gets called in a way that makes it fail the bug is not in the function but in what is calling it
01:17:00 <Kaidelong> I'll post it so you can see
01:17:29 <Twey> grohne: I'm pretty sure it's possible, though it might be rather long-winded
01:18:17 <grohne> Twey: great, can you show me? you can omit negative numbers. ;-)
01:18:23 <Twey> Haskell's type system is Turing-complete, so I imagine there's an appropriate encoding.  Not sure how I'd do it in Haskell, though.
01:19:02 <merijn> Twey: I thought Haskell's type system has a recursion limit, which would imply it's not Turing complete
01:19:29 <Twey> merijn: Well, in the same sense that x86 isn't Turing-complete because of the memory limit
01:19:40 <Twey> (Turing machines have infinite tape)
01:19:59 <merijn> Twey: Well, I don't think anyone really argued x86 was Turing-complete in a pure sense :)
01:20:41 <zomg> Twey: if you interpret it that precisely is it possible for anything to be turing-complete?
01:20:42 <merijn> Fun fact, C without a filesystem API isn't Turing-complete either :)
01:20:45 <Twey> Right; that wasn't my intention WRT the type system, either :þ
01:20:50 <merijn> zomg: Yes, Haskell is Turing complete
01:20:52 <Kaidelong> http://lpaste.net/99131
01:20:54 <Twey> zomg: Probably not, at least as we currently understand physics :þ
01:20:56 <merijn> zomg: So is python and many other languages
01:21:09 <zomg> merijn: but in practice they don't have infinite memory
01:21:22 <merijn> zomg: There are not Turing complete *implementations* of those
01:21:36 <merijn> zomg: But the languages *as defined* are Turing complete
01:21:51 <zomg> Yeah I'm not talking about something that in theory is turing complete, I mean in practice
01:21:52 <merijn> zomg: i.e. they can express Turing complete problems, even if they may not be able to be run
01:22:05 <Twey> merijn: Is there a *standard* recursion limit?  I don't know of such a thing
01:22:15 <Kaidelong> anyway to improve on that code?
01:22:33 <merijn> zomg: As Twey points out Turing-completeness only makes sense in a theoretical way as in practice you run into physics
01:22:34 <augur_> is there an interactive hole-based editor for haskell yet? i feel like i heard about one recently
01:22:38 <augur_> like an emacs mode or something
01:22:44 <zomg> merijn: heh, I guess so
01:22:50 <merijn> Twey: Is there a standard recursion limit for what? I don't understand the question?
01:22:53 <johnw> a hole-based editor?  It should be called DOnut
01:23:07 <merijn> augur_: Lamdu? Except that's not really Haskell and not really practical yet :)
01:23:19 <FireFly> a hole-based editor? is that what you use for code-golf?
01:23:20 <augur_> merijn: and therefore completely not what i need :p
01:23:36 <augur_> merijn: im @HaskellTips-ing
01:23:44 <Twey> Kaidelong: What does xpIso do?
01:23:50 <Kaidelong> a hole based editor is presumbly one that gives you suggestions for type holes, perhaps wih a drop down menu
01:24:10 <merijn> augur_: Actually, a colleague of mine is working on something like this for Haskell
01:24:12 <Twey> augur_: Are you @HaskellTips?
01:24:19 <augur_> Twey: no, i'm @ing em tho
01:24:20 <Kaidelong> xpIso :: (a -> b) -> (b -> a) -> PU a b
01:24:25 <Twey> Aha
01:24:28 <Twey> It's a mystery
01:24:31 <augur_> Twey: jfischoff is haskell tips
01:24:37 <Twey> Oh, okay
01:24:47 <Kaidelong> essentially it takes a function for unpickling, a function for pickling, and gives you a pickler
01:24:47 <Twey> It's less of a mystery now
01:24:51 <augur_> Kaidelong: it ought to give you the type of the hole, plus a list of things in scope
01:25:35 <Kaidelong> my first comment is backward, the error is thrown when the wrong index is used in pickling, not unpickling
01:25:39 <Kaidelong> unpickling is unambiguous
01:26:01 <Twey> Kaidelong: I would probably leave that code roughly as it is: it's pure so long as purity assumptions about the value hold
01:27:02 <Twey> So the error is a nice check just in case that fails, but it's not realistically something you should have to think about
01:29:01 <Twey> (you could improve your formatting, but that's less interesting)
01:30:51 <Twey> https://github.com/seliopou/typo — huh, this is neat
01:33:38 <jle`> is there a .cabal/config option that makes my builds parallel by default?  i remember there being one and i remember putting it in, but it's missing now for some reason
01:34:14 <supki> jle`: jobs: $ncpus
01:34:21 <jle`> supki: thanks! that's it
01:37:07 <jle`> idk how it disappeared from my config file
01:38:18 <jle`> it's kinda weird that some packages list quickcheck as a dependency so i have to spend time building it every time
01:38:50 <jle`> my package bloat has gotten pretty out of hand though
01:39:12 <merijn_> How does Free relate to type level fix? At first I thought it was just Fix, but I guess Fix would have kind (* -> *) -> * whereas Free doesn't seem to fit that kind?
01:42:01 <notdan> merijn: Free has a "base case"
01:43:57 <merijn> notdan: I know, I'm just not sure what that implies in terms of different behaviour :)
01:45:10 <Kaidelong> unionWith appears to have the wrong type
01:45:33 <Kaidelong> what stops you from using (a -> b -> c) -> Map k a -> Map k b -> Map k c
01:45:50 <merijn> Kaidelong: What happens to the elements that are unique in either Map?
01:45:55 <Kaidelong> why is it constrained to (a -> a -> a) -> Map k a -> Map k a -> Map k a
01:45:59 <Kaidelong> oh I see
01:46:07 <Kaidelong> Well
01:46:10 <Kaidelong> then why not
01:46:14 <merijn> The (a -> a -> a) is just to smartly deal with collisions
01:46:17 <Kaidelong> (Maybe a -> Maybe b -> c)
01:46:28 <merijn> Kaidelong: Then it's no longer a union
01:46:45 <merijn> Kaidelong: union is "Map k a -> Map k a -> Map k a"
01:46:47 <johnw> Kaidelong: you can use Data.Align from the 'these' package to implement what you're thinking of
01:47:20 <notdan> merijn: some functors, like data F a = Const Int a will not be inhabitede by finite values under FIx
01:47:22 <jle`> Kaidelong: what do you expect a union to be?
01:47:28 <merijn> Kaidelong: What you're asking for is more of a "zipWith" for Map
01:47:35 <Kaidelong> yes
01:47:44 <notdan> ok sorry g2g
01:47:52 <merijn> Kaidelong: Right, but then you should suggest that, rather than breaking union ;)
01:48:29 <jle`> ExitFailure 127?
01:49:16 <merijn> Kaidelong: Maybe something like mergeWithKey
01:49:54 <merijn> jle`: 127 is usually "command not found"
01:49:58 <johnw> merijn: or, what alignWith does :)
01:50:29 <johnw> although, maybe it's type isn't specific enoughi n this case
01:52:53 <Kaidelong> These does look like what I'm after
01:52:56 <johnw> merijn: type Free f a = Fix (Compose (Either a) f)
01:53:03 <Kaidelong> (what an awkward sentence)
02:03:14 <merijn> johnw: Ah, right :)
02:04:23 * hackagebot tls 1.2.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.1 (VincentHanquez)
02:04:25 * hackagebot GlomeVec 0.2 - Simple 3D vector library  http://hackage.haskell.org/package/GlomeVec-0.2 (JimSnow)
02:04:27 * hackagebot GlomeTrace 0.2 - Ray Tracing Library  http://hackage.haskell.org/package/GlomeTrace-0.2 (JimSnow)
02:07:16 <Twey> grohne: http://lpaste.net/99134
02:10:45 <SamanthaD> I'm having problems with emacs hanging in haskell mode when I try to do things like C-c C-t or C-c C-l
02:11:42 <Twey> SamanthaD: Does your ghci work, and is haskell-program-name set to it?
02:11:59 <SamanthaD> let me check
02:12:05 <SamanthaD> ghci works in a normal terminal, yes
02:13:02 <t7> @djinn (forall A. A -> A) -> Int
02:13:02 <lambdabot> Error: Undefined type A.
02:13:29 <SamanthaD> Twey: haskell-program-name is an unrecognized variable
02:14:24 * hackagebot GlomeView 0.2 - SDL Frontend for Glome ray tracer  http://hackage.haskell.org/package/GlomeView-0.2 (JimSnow)
02:14:26 * hackagebot warp-tls 2.0.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.2 (MichaelSnoyman)
02:17:34 <Twey> SamanthaD: That sounds like you don't have inferior-haskell-mode installed at all
02:18:16 <SamanthaD> Twey: Yes, that might be the case. Thanks, I'll look into it.
02:18:52 <SamanthaD> I have a bunch of inferior-haskell-foo functions though
02:20:07 <Twey> Hm, odd
02:21:57 <grohne> Twey: impressive.
02:22:58 <grohne> Twey: it has the little downside that you can insert bottoms at odd places, but I guess you cannot work around that issue yet
02:23:45 <remdezx> hello! Does anybody know how to make ghc see packages in custom packageDb?
02:23:45 <markovirc> Hello remdezx
02:23:49 <grohne> Twey: and it looks a hell lot like Agda %-)
02:24:09 <supki> remdezx: -packagedb option
02:24:20 <singularity-> Ave Haskelian!
02:24:38 <remdezx> supki: okay, but how to add it in API?
02:25:51 <remdezx> Sorry, I wasn't clear. How to make GHC API see packages in custom packageDb?
02:26:48 <supki> oh, no idea :(
02:27:49 <grohne> Twey: maybe I should look into more extensions, is there also something similar to agda-mode for haskell? I guess that's call djinn-mode then, right?
02:36:01 <satc> I just need the sizeOf function from Storable class and dont want the user to define the rese (peek,poke etc). So I created a new class Foo with just one function call mySizeOf and added a default instance for already storable types as instance Storable a => Foo a where ... But it is not possible without undecidable instances and I am little skeptical about doing that.
02:37:11 <merijn> satc: Default instances like that tend to break things
02:37:41 <merijn> satc: The problem is this: Suppose we have datatype Bar which has a Storable instance. Now a user writes "instance Foo Bar where", now what?
02:38:59 <merijn> Maybe a default signature would work?
02:40:54 <merijn> satc: i.e. http://lpaste.net/99135
02:41:21 <merijn> satc: But that still requires you to write "instance Foo Bar", but if Bar is Storable then those 3 words are all you need to write
02:42:53 <satc> merijn: Ohh... Is there an alternate design to this problem... I dont want to write that for all storable types.
02:44:02 <merijn> satc: Not really, tbh
02:44:19 <merijn> At least, I'm not aware of any other tricks
02:45:51 <satc> merijn: Ok thanks..
02:49:28 * hackagebot annotated-wl-pprint 0.5.1 - The Wadler/Leijen Pretty Printer, with annotation support  http://hackage.haskell.org/package/annotated-wl-pprint-0.5.1 (dchristiansen)
02:55:53 <Kaidelong> johnw: amidoinitrite http://lpaste.net/99131
02:56:42 <Kaidelong> oh well it should be compare `on` fst
02:56:57 <Kaidelong> but I more meant the use of the functions from Data.These and Data.Align
02:58:14 <skypers_> hi. I finally came up with something that might interests some of you. I wrote a type that can be either a list of int, floats or unsigned values, and expose a descent FFI interface to emulate void* pointers that maps C arrays of different types
02:58:15 <markovirc> Hello skypers_
02:58:16 <skypers_> https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Utils/IUFList.hs
02:58:25 <skypers_> interest*
02:59:00 <johnw> Kaidelong: does it work? :)
02:59:25 <skypers_> (I use that type in my 3D engine to represents vertices)
02:59:29 * hackagebot annotated-wl-pprint 0.5.2 - The Wadler/Leijen Pretty Printer, with annotation support  http://hackage.haskell.org/package/annotated-wl-pprint-0.5.2 (dchristiansen)
02:59:31 <skypers_> represent*
02:59:31 <Kaidelong> mm, I suppose I could make some simple test cases
02:59:44 <skypers_> why so many typo on this morning :D
03:00:38 <skypers_> hello markovirc
03:00:38 <markovirc> Hello skypers_
03:00:46 <skypers_> oh, a bot
03:01:09 <johnw> Kaidelong: I guarantee they'll give a better answer than I can right now
03:25:50 <SamanthaD> I figured out why inferior-haskell-mode was hanging emacs. I changed the GHCI prompt in .ghci which caused inferior-haskell-wait-for-prompt to wait forever
03:27:30 <SamanthaD> all hail debug messages :3
04:01:06 <zebr> hi all. is there a lambda calculus that is to Hindley-Milner as System F-omega is to System F? i.e. with type operators, yet decidable type inference. or is that not possible in general?
04:02:56 <augur_> zebr: System-Fomega
04:03:17 <augur_> http://en.wikipedia.org/wiki/System_F#System_F.CF.89
04:04:00 <zebr> augur_: surely System F-omega has undecidable type inference?
04:04:03 <augur_> zebr: tho interestingly, system F is very powerful in its own right, to the point where many of the type operators are somewhat redundant
04:04:15 <augur_> zebr: mm.. i cant imagine why it would
04:04:36 <zebr> well, System F has undecidable type inference, even without type operators
04:04:57 <augur_> does it? interesting
04:05:13 <augur_> well then, HMomega
04:05:13 <augur_> :)
04:06:00 <zebr> ;) i've not been able to find such a thing, sadly
04:06:50 <augur_> it seems like HM is general enough that people refer to HM-with-ops as HM
04:07:17 <bernalex> what was the "words on f" function? heh
04:07:34 <bernalex> I think there was a function where you could essentially do what words/lines does, but supply what char to separate on
04:08:51 <Tekmo> bernalex: split
04:08:54 <Tekmo> @hoogle split
04:08:55 <lambdabot> Data.Text split :: (Char -> Bool) -> Text -> [Text]
04:08:55 <lambdabot> Data.Text.Lazy split :: (Char -> Bool) -> Text -> [Text]
04:08:55 <lambdabot> Data.ByteString.Char8 split :: Char -> ByteString -> [ByteString]
04:08:56 <bernalex> ah
04:08:58 <bernalex> ty
04:08:58 <zebr> augur_: i think 'HM' is used rather loosely most of the time. which is a bit annoying, as its used for type systems that actually have undecidable type inference. whereas i want to know if 'HM-omega' is actually decidable. >.>
04:09:02 <Tekmo> bernalex: You're welcome
04:10:25 <bernalex> Tekmo: oh, right it doesn't operate on [Chra]
04:11:01 <bernalex> *[Char]
04:11:17 <Tekmo> bernalex: So I don't know off the top of my head a function which does this, but you can piece this together from `split` and `elem
04:11:17 <zebr> bernalex: Data.List.Split.split will. hackage package 'split'
04:11:25 <Tekmo> :t elem
04:11:26 <lambdabot> Eq a => a -> [a] -> Bool
04:11:35 <Tekmo> for example
04:11:42 <bernalex> I guess
04:11:43 <Tekmo> :t (`elem` "asdf")
04:11:44 <lambdabot> Char -> Bool
04:11:51 <bernalex> better than duplicating words/lines really
04:12:22 <Tekmo> It's not that bad
04:12:27 <Tekmo> split (`elem` "asdf")
05:03:34 <haasn> Tekmo: interesting, split and words differ in their treatment of an empty input
05:04:18 <haasn> (both for Data.Text and Prelude/Data.List.Split)
05:04:20 <Tekmo> haasn: Yes, `split` behaves weirdly in general
05:21:02 <Tekmo> haasn: Never mind.  `split` is actually consistent
05:21:23 <haasn> What's the motivation behind of split _ "" = [""]?
05:23:33 <Tekmo> haasn: Think of it this way
05:23:57 <zgredzik> hello, does anyone know any good math library that has a function calculating median implemented in it?
05:23:58 <markovirc> Hello zgredzik
05:24:04 <haasn> Oh, I guess I can rationalize it - I'm partitioning my string into chunks
05:24:05 <Tekmo> haasn: split (== 'x') "xx" = ["", "", ""]
05:24:08 <zgredzik> hi markovirc :D
05:24:11 <Tekmo> haasn: split (== 'x') "x" = ["", ""]
05:24:11 <haasn> If my string is empty, I've splitted it
05:24:11 <markovirc> Hello zgredzik
05:24:15 <Tekmo> haasn: split (== 'x') "" = [""]
05:24:21 <remdezx> Hello zgredzik
05:24:22 <haasn> or that, yes
05:24:32 <haasn> I guess this further exemplifies that “words” is *not* “split”
05:24:47 <haasn> words isn't concerned with splitting a string by spaces, it's concerned with extracting the non-space bits.
05:26:23 <Tekmo> Yeah
05:26:49 <legoulash> heh, you've just described the difference between split and m//g in perl :-)
05:27:15 <legoulash> (use split if you know what you want to throw away, use m//g if you know what you want to extract)
05:30:26 <udevd> http://lpaste.net/99138 hey, i have rather simple question: why is rounds.sqrt.fromIntegral halting the program (computation doesn't end)? this is trying to perform partial transpose of matrix
05:31:08 <legoulash> is that second n a typo?
05:31:13 <lieven_> zgredzik: Math.Statistics.median in hstats
05:31:17 <udevd> i'm using Numeric.LinearAlgebra, which uses Data.Packed.Matrix
05:31:45 <udevd> legoulash: well, thanks, i haven seen it xD
05:31:50 <legoulash> because n = round.sqrt.fromIntegral$ n says n is the rounded square root of n, which is the rounded square root of n, which is ...
05:31:54 <Tekmo> udevd: You're defining `n` in terms of itself
05:32:06 <Tekmo> udevd: So you have a recursive call that never completes
05:32:10 <udevd> yeah i just saw what i've done...
05:32:19 <Tekmo> :)
05:32:27 <udevd> thanks :)
05:32:36 <Tekmo> You're welcome
05:32:37 <legoulash> ghc should just check for infinite loops
05:32:46 <legoulash> -Wnontermination
05:32:59 <udevd> erm, it's useful
05:33:06 <Tekmo> legoulash: Usually it does
05:33:13 <legoulash> only at runtime
05:33:18 <udevd> fix function is `infinite loop`...almost
05:33:20 <legoulash> without threads
05:33:23 <Tekmo> legoulash: If you compile the program and use a value that loops it will sometimes detect this and output `<<loop>>`
05:33:55 <Tekmo> legoulash: However, it cannot do this in general because that would imply solving the halting problem
05:34:17 <legoulash> (that was the joke)
05:34:22 <Tekmo> Oh :)
05:34:32 <legoulash> but the halting problem is actually solvable
05:34:45 <legoulash> assuming finite memory
05:35:51 <noahmaizels> Hello
05:35:52 <markovirc> Hello noahmaizels
05:36:53 <dhrosa> legoulash: what if the program depends on user input?
05:37:02 <Tekmo> legoulash: Or just use a total programming language
05:37:09 <legoulash> Tekmo: totally
05:37:41 <legoulash> dhrosa: such a program can be assumed to halt because the user will get tired or die at some point
05:39:21 <Tekmo> legoulash: Technically, if the universe is guaranteed to end, then we can solve the halting problem, too
05:41:52 <tdammers> Tekmo: feels like cheating though
05:42:05 <tdammers> let isHalting a = True
05:42:52 <Tekmo> I'm willing to wait until the end of the universe for my program to finish compiling
05:45:48 <zgredzik> lieven_: hstats doesn't compile because it's too old
05:46:49 <shiona> is there a "iterate until value does not change" function?
05:47:16 <shiona> fix is close, I guess, but at I cannot get it to work
05:47:49 <Tekmo> :t until
05:47:51 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
05:47:58 <Tekmo> No, that's not it
05:48:22 <lieven_> zgredzik: too bad. if you're not all that much concerned with a factor log n inefficiency: it's the middle element of the sorted list.
05:49:16 <Tekmo> shiona: I can't find any such function on Hoogle or Hayoo
05:49:40 <shiona> me neither, but I thought that it may be hidden somewhere in Endo or something
05:50:05 <lieven_> zgredzik: otherwise, implement a recursive k-th order statistics function from scratch using partition
05:50:19 <shiona> I guess fix' f = until (\x -> f x == x) f  could work
05:51:44 <supki> :t fix (\f g x -> let y = g x in if x == y then x else f g y)
05:51:45 <lambdabot> Eq a => (a -> a) -> a -> a
05:54:50 * hackagebot yesod-bin 1.2.5.7 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.7 (MichaelSnoyman)
05:54:52 * hackagebot yesod-newsfeed 1.2.0.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.2.0.1 (MichaelSnoyman)
05:55:06 <haasn> Tekmo: we can?
05:55:32 <haasn> as far as I'm aware the halting problem states nothing about our universe
05:55:44 <Tekmo> haasn: It was just a joke
05:58:09 <legoulash> :t \f -> fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate f
05:58:10 <lambdabot> Eq b => (b -> b) -> b -> b
06:01:00 <kuribas> Is there a function (b -> c -> d) -> (a, b) -> (a, c) -> (a, d)?
06:01:07 <zgredzik> lieven_: tx, I guess I have no other choice
06:03:01 <supki> kuribas: what happens to values of type a?
06:03:02 <dagle> kuribas: Looks like uncurry + (.)
06:03:18 <kuribas> supki: It takes the first
06:03:25 <kilian0815> Hi, I'm working through Simon Marlows Parallel/Concurrent Haskell book. Has anyone solved the task in chapter 4 p. 69 "Rate Limiting The Producer"? I wonder why the Fork data constructor of the IList type is "Fork (Par ()) (IList a)" and not "Fork (Par ()) (IVar (IList a))". Or in other words, I don't see how to solve the task the way the type is stated.
06:03:29 <markovirc> Hello kilian0815
06:03:54 <dhrosa> @pl stackPush val state = incSP $ writeDMem (getSP state) val state
06:03:54 <lambdabot> stackPush = (incSP .) . join . flip (writeDMem . getSP)
06:03:57 <dhrosa> no.
06:04:36 <kuribas> like (\a b f -> (fst a, f (snd a) (snd b)))
06:06:36 <danilo2> Hello! Is there any sort algorithm in accelerate? I cannot find one and I think it is such base thing it is implemented somewhere?
06:06:37 <markovirc> Hello danilo2
06:06:39 <legoulash> @pl \a b -> a <$ ((f `on` snd) a b)
06:06:39 <lambdabot> liftM2 (.) (<$) (f `on` snd)
06:08:23 <kuribas> :r (<$)
06:08:29 <kuribas> :t (<$)
06:08:30 <lambdabot> Functor f => a -> f b -> f a
06:08:41 <legoulash> yeah, that was wrong
06:09:34 <Kaidelong> is that from control.applicative?
06:11:17 <dhrosa> @pl writeDMem' v a s = writeDMem a v s
06:11:17 <lambdabot> writeDMem' = flip writeDMem
06:11:33 <dhrosa> hmm, that makes sense actually
06:11:51 <kuribas> \f -> (fmap . f . snd)
06:11:53 <fizbin> Once in a while, @pl delivers a non-wtf.
06:12:07 <legoulash> @pl \a b -> (f `on` snd) a b <$ a
06:12:08 <lambdabot> flip =<< ((<$) .) . (f `on` snd)
06:12:12 <fizbin> @pl \f -> (fmap . f . snd)
06:12:12 <lambdabot> (fmap .) . (. snd)
06:12:57 <dhrosa> that's kind of elegant, but too much mental work on first glance
06:13:54 <kuribas> yeah
06:15:04 <identity> How /win 8
06:15:09 <identity> eh, excuse me
06:15:35 <kuribas> \f a -> fmap (f $ snd a)
06:15:43 <kuribas> @pl \f a -> fmap (f $ snd a)
06:15:44 <lambdabot> (fmap .) . (. snd)
06:17:01 <legoulash> :t fmap (?f $ snd ?a)
06:17:03 <lambdabot> (Functor f, ?f::b1 -> a -> b, ?a::(a1, b1)) => f a -> f b
06:21:04 <yitz> @pl \a ->  fmap (f $ snd a)
06:21:05 <lambdabot> fmap . f . snd
06:23:29 <dawik> > "oops"
06:23:30 <lambdabot>  "oops"
06:23:34 <legoulash> :t (second .) . (. snd)
06:23:35 <lambdabot> Arrow a => (b1 -> a b c) -> (a1, b1) -> a (d, b) (d, c)
06:24:00 <legoulash> :t (second <$>) <$> (<$> snd)
06:24:01 <lambdabot> Arrow a => (b1 -> a b c) -> (a1, b1) -> a (d, b) (d, c)
06:26:20 <zettablade> If I run foldl1 (+) [1,2..10000] i get a stack overflow. Is there a way to avoid this an carry out the computation?
06:26:51 <kuribas> Use foldl1'
06:26:55 <legoulash> try foldl'
06:27:55 <kuribas> I don't get overflow with foldl1...
06:28:27 <zettablade> thanks, I'm running the function on fpcomplete.com
06:28:38 <zettablade> might have left off a zero
06:31:15 <haasn> edwardk: a Functor being Representable, loosely speaking, means it has a constant number of holes?
06:33:14 <dhrosa> @pl stackPop = liftM2 (,) (readDMem =<< getSP) decSP
06:33:14 <lambdabot> stackPop = liftM2 (,) (readDMem =<< getSP) decSP
06:33:20 <dhrosa> lol
06:34:07 <dhrosa> understanding that a reader is the same as r-> has made my life much easier
06:34:54 * hackagebot modulo 1.8.0 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.8.0 (HansHoglund)
06:36:23 <notdan> haasn: not necessary!
06:36:44 <notdan> haasn: coincidentally, I am doing a small write up about representable functors in Haskell, hoping to put it up soon
06:36:55 <haasn> notdan: awesome
06:45:48 <augur> notdan: Representable a r = a -> r !
06:46:00 <HugoDaniel> hi
06:46:00 <markovirc> Hello HugoDaniel
06:46:41 <augur> hm thats fun
06:46:59 <augur> the representable functor is the Reader functor! \o/
06:47:40 <augur> i wonder if there's an interesting relationship in CT
06:48:50 <edwardk> haasn: yes
06:49:00 <edwardk> haasn: and a fixed shape
06:49:10 <augur> i bet edwardk knows
06:49:21 <edwardk> augur: yes it is
06:49:37 <augur> edwardk: is there a nice relationship between reader and yoneda, beyond the obvious one?
06:49:47 <tertl3> hello
06:49:48 <markovirc> Hello tertl3
06:49:56 <augur> markovirc: :|
06:49:58 <tertl3> markovirc: how are you?
06:49:58 <edwardk> augur: every Representable is isomorphic to x -> r for some (x ->)
06:50:11 <augur> tertl3: pay no mind to markovirc, it's a greeter bot
06:50:19 <augur> edwardk: indeed, but i mean
06:50:22 <tertl3> i know
06:50:23 <augur> thats the obvious one :)
06:50:36 <tertl3> i wanted him to do some NLP :P
06:51:11 <augur> edwardk: is there something more interesting, like, the monadicity of (x ->) gets you some interesting consequences from the lemma, etc
06:52:22 <tertl3> does jekor ever come in here?
06:52:25 <augur> i mean, the monadic properties of (x ->) dont really come up in YL, and vice versa, so i was curious if there were any cute side effects of the coincidence
06:56:47 <haasn> edwardk: what do you mean by fixed sha-- oh, because eg. Join Either isn't Representable?
06:56:52 <haasn> even though it always has one hole
06:57:38 <edwardk> haasn: exactly
06:57:52 <t7> hello
06:57:52 <markovirc> Hello t7
06:58:20 <eriksensei> 'ello
06:58:23 <edwardk> augur: there is probably something because of the preservation of limits, etc. w/ (x ->) being a right adjoint, but nothing obvious
06:58:26 <haasn> edwardk: “fixed shape” to me seems like it implies “fixed number of holes”
06:58:44 <edwardk> haasn: yes, just figured i should mention that the condition was stronger
06:59:30 <haasn> edwardk: would that be the same as saying “f Void has only one inhabitant”
06:59:48 <haasn> (with ⊥ everywhere ‘Void’ appears)
07:00:24 <edwardk> haasn: well f ()  'd be saner. avoids dealing with _|_'s
07:00:35 <haasn> you're right
07:00:47 <haasn> f () has only one inhabitant that contains no ⊥s
07:01:05 <haasn> (is there a better term for that? total inhabitant?)
07:01:11 <haasn> (normal form inhabitant?)
07:01:20 <edwardk> preserves all limits? =)
07:01:37 <edwardk> being a right adjoint has a lot of power
07:03:29 <Yep> hi, how might one increment a ByteString (as in literally. e.g. char c[2]; c[0]++; if c[0] == 0; c[1]++;)
07:03:32 <markovirc> Hello Yep
07:04:50 <merijn> Yep: Well, you can't ByteString's are immutable like everything else
07:04:54 <klrr_> edwardk: sry for asking again but how "hardcore" is the ICFP/CUFP conf? reason i ask is that im pretty new to programming (been coding haskell in one year now without any programming experiences before that (unless you count bash scripts and graphical programming like game maker). sry if its a stupid questsion
07:05:00 <merijn> Yep: You'd create a new ByteString with an changed value
07:06:36 <edwardk> klrr_: it is the main functional programming conference, so the high end is pretty high, but i think there is a lot to see even if you are relatively new to the field, and a great opportunity to meet people an find out about things you didn't know existed. The CUFP tutorials can be pretty accessible as well.
07:06:57 <edwardk> I think we're trying to do more advanced tutorials this year though.
07:06:58 <klrr_> okey thanks
07:07:17 <Yep> merijn: yes, that's fine, but I couldn't fund a function for it in the bytestring module
07:07:54 <legoulash> Yep: a function for what?
07:08:17 <klrr_> some other languages conferences seem to even encourage beginners to join just wanted to check if this was similar just in case ( i guessed it wouldnt ;))
07:08:28 <haasn> Yep: may I ask why you need one?
07:08:36 <Yep> legoulash: a literal binary bytestring increment
07:09:26 <legoulash> Yep: you can't modify bytestrings
07:09:43 <legoulash> you have to create a new value
07:09:52 <Yep> i understand
07:10:18 <Yep> increment :: Bytestring -> Bytestring
07:10:29 <Yep> increment bs =
07:10:32 <Yep> don't know the rest
07:10:34 <legoulash> yeah, you'd have to write that yourself
07:10:39 <aji> increment bs = haskell
07:10:42 <aji> ( ¬‿¬)
07:11:03 <legoulash> what do you need that for, btw?
07:11:22 <colDrMcBeardman> ah, the lisp school of development.
07:11:46 <Yep> incrementing a nonce for a hmac
07:12:08 <legoulash> doesn't the n stand for number?
07:12:09 <Tekmo> Yep: Do you want to "cast" the bytestring to some sort of integer?
07:12:11 <legoulash> i.e. Integer?
07:12:19 <legoulash> :t foldl' (\z x -> z * 256 + fromIntegral x) (0 :: Integer) . BS.unpack
07:12:20 <lambdabot> BSC.ByteString -> Integer
07:12:53 <Tekmo> lambdabot: You can use `Data.ByteString.foldl'`
07:13:09 <Yep> seems slow though
07:13:25 <Tekmo> Yep: You can also directly cast using its `Storable` instance
07:13:38 <legoulash> :t BS.foldl' (\z x -> z * 256 + fromIntegral x) (0 :: Integer)
07:13:39 <lambdabot> BSC.ByteString -> Integer
07:13:39 <Tekmo> Yep: OOps, not for bytestring
07:13:43 <colDrMcBeardman> Tekmo, i don't think she can hear you.
07:13:55 <Tekmo> colDrMcBeardman: What makes you say that?
07:13:58 <int-e> Yep: how big are your numbers?
07:14:03 <legoulash> Tekmo: because lambdabot is a bot
07:14:04 <haasn> Yep: enumerating all possible bytestrings would be a simpler task I think
07:14:10 <Yep> int-e 256bit
07:14:12 <haasn> Yep: especially if your length is fixed
07:14:13 <Tekmo> legoulash: Oops
07:14:43 <Tekmo> Yep: You can access the buffer behind the bytestring and directly cast that to an Int using the `Storable` instance for `Int`s
07:14:43 <legoulash> Word8
07:14:48 <Tekmo> Yep: That will be very fast
07:14:56 <legoulash> Tekmo: and may SIGBUS
07:15:10 <legoulash> also, Int doesn't have a fixed size
07:15:17 <Tekmo> legoulash: You can use Word32
07:15:21 <Tekmo> legoulash: Or however many bytes he needs
07:15:27 <legoulash> still SIGBUS
07:15:52 <Tekmo> Hmm
07:16:05 <Tekmo> I've done this in my code and never had problems.  I never knew about that potential issue, though
07:16:21 <legoulash> "yay"
07:16:29 <legoulash> C style bugs in Haskell
07:16:34 <legoulash> :-(
07:16:54 <Tekmo> Then perhaps `Data.ByteString.foldl'` is the best route
07:17:55 <legoulash> incws :: [Word8] -> [Word8]
07:17:56 <Yep> tekmo: thanks, seems slower then it needs to be though :(, will do for now... thanks
07:17:56 <Tekmo> Actually, maybe he could do it in one go using `scanl`
07:18:00 <Tekmo> Yep: Wait
07:18:28 <Tekmo> There's also `Data.ByteString.mapAccumL`, too
07:18:38 <Tekmo> You may be able to avoid the conversion to `Int` by using that
07:18:49 <legoulash> incws [] = [0]; incws (x : xs) | x == 255 = 0 : incws xs | otherwise = (x + 1) : xs
07:18:53 <Tekmo> or `mapAccumR`, depending on which end is the one's place
07:18:58 <legoulash> increment = BS.pack . incws . BS.unpack
07:19:24 <Tekmo> legoulash: I think he can avoid the conversion to another type or unpacking by using mapAccum{R/L}
07:20:33 <Yep> tekmo: I think your right
07:22:11 <Tekmo> mapAccumR (\carry w8 -> let (carry', w8') = quotRem (carry + w8)) 1 :: ByteString -> (Int, ByteString)
07:22:22 <Tekmo> Oops, remove the `let (...) = `, part
07:22:33 <Tekmo> mapAccumR (\carry w8 -> quotRem (carry + w8)) 1 :: ByteString -> (Int, ByteString)
07:22:38 <Tekmo> Sometihng like that
07:22:48 <Tekmo> mapAccumR (\carry w8 -> quotRem (carry + w8) 256) 1 :: ByteString -> (Int, ByteString)
07:23:21 <Tekmo> Here, let me try it out
07:23:23 <legoulash> that looks like a type error
07:24:06 <Tekmo> No type error.  It type checks
07:25:00 <legoulash> :t BS.mapAccumR (\carry w8 -> quotRem (carry + w8) 256) 1 :: BS.ByteString -> (Int, BS.ByteString)
07:25:01 <lambdabot>     Couldn't match type `Int' with `Word8'
07:25:01 <lambdabot>     Expected type: (Int, Word8)
07:25:01 <lambdabot>       Actual type: (Int, Int)
07:25:23 * legoulash looks disapprovingly
07:25:26 <Tekmo> It works in my ghci
07:25:37 <Tekmo> Data.ByteString.mapAccumR (\carry w8 -> quotRem (carry + w8) 256) 1 :: ByteString -> (GHC.Word.Word8, ByteString)
07:25:48 <legoulash> oh look, you changed the code
07:25:57 <Tekmo> Oh, I just let it infer the type
07:26:22 <legoulash> > BS.mapAccumR (\carry w8 -> quotRem (carry + w8) 256) 1 (BS.pack [255])
07:26:23 <lambdabot>  *Exception: divide by zero
07:26:26 <Tekmo> However, ther'es still a division error
07:26:28 <Tekmo> Yeah, that one
07:26:55 <Tekmo> Oh, duh
07:26:59 <Tekmo> 256 = 0 for Word8
07:27:15 <Tekmo> I need to temporarily upcast to Word16
07:27:24 <yitz> @type BS.mapAccumR
07:27:25 <lambdabot> (acc -> Word8 -> (acc, Word8)) -> acc -> BSC.ByteString -> (acc, BSC.ByteString)
07:28:21 <Yep> lol, I'm starting to think this would be one of those shitty questions u get for a job interview, lol
07:28:25 <yitz> @type BS.mapAccumR (\carry w8 -> quotRem (carry + w8) 256) 1 :: BS.ByteString -> (Int, BS.ByteString)
07:28:28 <lambdabot>     Couldn't match type `Int' with `Word8'
07:28:30 <lambdabot>     Expected type: (Int, Word8)
07:28:32 <lambdabot>       Actual type: (Int, Int)
07:28:44 <int-e> > BS.mapAccumR (\c w -> if c then (w == 255, w+1) else (c, w)) True (BS.pack [255,255])
07:28:45 <yitz> @type BS.mapAccumR (\carry w8 -> second fromIntegral $ quotRem (carry + w8) 256) 1 :: BS.ByteString -> (Int, BS.ByteString)
07:28:45 <lambdabot>  (True,"\NUL\NUL")
07:28:46 <Tekmo> Okay, I got it
07:28:46 <lambdabot>     Couldn't match expected type `Int' with actual type `Word8'
07:28:47 <lambdabot>     In the second argument of `(+)', namely `w8'
07:28:47 <lambdabot>     In the first argument of `quotRem', namely `(carry + w8)'
07:29:19 <Tekmo> Data.ByteString.mapAccumR (\carry w8 -> let (q, r) = quotRem (fromIntegral carry + fromIntegral w8) (256 :: Word16) in (fromIntegral q, fromIntegral r)) 1
07:29:41 <Tekmo> That works from right-to-left
07:29:51 <Tekmo> Replace with `mapAccumL` if you need left-to-right
07:30:50 <Tekmo> Also, optionally throw in a `fst` if you want to throw away the final carry bit
07:30:59 <Yep> thanks tekmo legoulash int-e!
07:31:01 <Tekmo> fst . Data.ByteString.mapAccumR (\carry w8 -> let (q, r) = quotRem (fromIntegral carry + fromIntegral w8) (256 :: Word16) in (fromIntegral q, fromIntegral r)) 1
07:31:13 <Tekmo> Oops, `snd`, not `fst`
07:31:18 <Tekmo> snd . Data.ByteString.mapAccumR (\carry w8 -> let (q, r) = quotRem (fromIntegral carry + fromIntegral w8) (256 :: Word16) in (fromIntegral q, fromIntegral r)) 1
07:31:26 <legoulash> > BS.mapAccumR (\carry w8 -> fromIntegral <$> quotRem (carry + fromIntegral w8) 256) 1 (BS.pack [255])
07:31:27 <lambdabot>  (1,"\NUL")
07:32:24 <Tekmo> legoulash: Note that I'm interpreting his question as one that would not allocate a new bit for overflow
07:32:32 <Tekmo> legoulash: So that is the expected behavior
07:33:08 <Yep> no, no new bit, should never get there
07:33:34 <Tekmo> legoulash: For example, if you already have the bit there, then it works
07:33:43 <Tekmo> legoulash: Do the same thing with [0, 255] as input
07:33:51 <Tekmo> legoulash: ... and also `unpack` the result for clarity
07:34:01 <legoulash> I know
07:34:01 <Tekmo> > BS.mapAccumR (\carry w8 -> fromIntegral <$> quotRem (carry  + fromIntegral w8) 256) 1 (BS.pack [255])
07:34:02 <lambdabot>  (1,"\NUL")
07:34:05 <yitz> Tekmo: "his question"? you already knew that Yep is a he?
07:34:10 <Tekmo> > unpack$ BS.mapAccumR (\carry w8 -> fromIntegral <$> quotRem (carry  + fromIntegral w8) 256) 1 (BS.pack [0, 255])
07:34:10 <legoulash> I'm just demonstrating that you only need 2 fromIntegrals
07:34:12 <lambdabot>  Not in scope: `unpack'
07:34:12 <lambdabot>  Perhaps you meant one of these:
07:34:12 <lambdabot>    `BS.unpack' (imported from Data.ByteString),
07:34:12 <lambdabot>    `BSL.unpack' (imported from Data.ByteString.Lazy),
07:34:12 <lambdabot>    `BSLC.unpack' (imported from Data.ByteString.Lazy.Char8)
07:34:19 <Tekmo> > BS.unpack $ BS.mapAccumR (\carry w8 -> fromIntegral <$> quotRem (carry  + fromIntegral w8) 256) 1 (BS.pack [0, 255])
07:34:20 <lambdabot>  Couldn't match expected type `Data.ByteString.Internal.ByteString'
07:34:20 <lambdabot>              with actual type `(a0, Data.ByteString.Internal.ByteString)'
07:34:22 <Tekmo> legoulash: Oh
07:34:30 <Yep> yitz: yep, must have
07:34:58 <Tekmo> Yep: Are you a "he"?
07:35:40 <Yep> depends, which will benefit me for future questions :P?
07:35:45 <Yep> lol
07:35:49 <Tekmo> haha
07:36:43 <yitz> Tekmo: best is to be in the habit of saying things like "Yep's question". either assuming he or asking can feel threatening to channel participants who happen to be she.
07:36:57 <Tekmo> yitz: It was a mistake.  Usually I use "their" for this purpose
07:37:03 <yitz> that works too
07:37:10 <Yep> anyways, thanks very much for ur help... makes sense, mapAccumR is indeed the missing piece i needed
07:37:36 <Yep> yitz: also talking like i'm not in the room might feel threatening too :P
07:38:15 <yitz> Tekmo: Yep thinks that talking about Yep as if Yep isn't in the room might feel threatening. what do you think?
07:38:34 <Yep> lol
07:39:02 <raichoo> yep
07:39:12 <Yep> anyways, thanks very much Tekmo, much appreciated
07:39:28 <Tekmo> You're welcome!
07:40:45 <hattmammerly> stupid question, but is there a way to alias a value? say I have data PlayingCard = Card {Value :: Int, Suit :: String} - can I rename 10 'Jack' or something of that effect? Different games use different cards, and I don't want to impose restrictions by enforcing a standard deck
07:40:47 <Yep> another quiz for u ;), 2:38am here so i'm going to bed, bye...
07:43:05 <colDrMcBeardman> hattmammerly, why don't you make types for suits and values?
07:43:20 <colDrMcBeardman> and then just derive show for them?
07:43:44 <Tekmo> hattmammerly: What do you mean by rename 10 'Jack'?
07:43:51 <sleepynate> hattmammerly: what are you working on? i had someone ask me the same question at CodeMash and told them exactly what colDrMcBeardman told you
07:44:12 <hattmammerly> colDrMcBeardman: because that would enforce the standard 2-Ace, four-suit card deck
07:44:21 <hattmammerly> sleepynate: card game engine for an IRC bot
07:44:23 <colDrMcBeardman> hattmammerly, no, you could have different card types
07:44:29 <sleepynate> hattmammerly: weird
07:44:31 <colDrMcBeardman> err, deck types
07:44:45 <Tekmo> hattmammerly: Will it always be a 52 card deck?
07:44:50 <Clint> are there any handy examples of using Store or StoreT?
07:45:49 <colDrMcBeardman> so you could do data 52Card = Card {Denom, Suit}, data Denom = Ace | Deuce | Tre | Four ... | King and data Suit = Hearts | Clubs...
07:45:53 <hattmammerly> Tekmo: nope. euchre, uno, etc don't have 52 cards (and uno has totally different cards)
07:45:59 <Tekmo> The only example I know is a post of mine: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html.  The third example is the Store comonad
07:46:19 <colDrMcBeardman> but then for something like uno you could do data UnoDeck = Card {Color, Number} etc etc
07:46:29 <colDrMcBeardman> then you could tie things together with type classes.
07:46:30 <hattmammerly> colDrMcBeardman: I could make types for every case I run into but I was hoping there was a general solution
07:46:45 <Tekmo> hattmammerly: Do all of your decks have some notion of "suit" and "value"?
07:46:50 <legoulash> colDrMcBeardman: that smells like OO
07:47:01 <hattmammerly> Tekmo: I don't know, that's the issue. I want to impose as few restrictions as possible
07:47:14 <hattmammerly> current implementation assumes yes
07:47:26 <legoulash> as few restrictions as possible? use String
07:47:34 <Tekmo> hattmammerly: So the most general solution is to just define a new `Card` type for each game type
07:47:34 <hattmammerly> legoulash: then ordering is broken
07:47:37 <colDrMcBeardman> well, you could make it better if you factored stuff out with classes.
07:47:46 <legoulash> hattmammerly: write your own ordering
07:47:56 <legoulash> some games have a custom order
07:48:05 <Tekmo> hattmammerly: I guess the question is, what operations do you want cards to support?
07:48:24 <colDrMcBeardman> using just integers to represent card values smells like C, though
07:48:28 <hattmammerly> Tekmo: operations would be done on lists of cards, not cards themselves. so that doesn't really matter
07:48:42 <Tekmo> hattmammerly: Okay, so what operatoins should lists of cards support that lists don't already support?
07:49:28 <hattmammerly> Tekmo: that's not the issue - i want the same engine to use uno cards for uno and poker cards for poker without having to hard-code multiple games in the engine itself
07:49:29 <kstt> Hello. I'm making a medium-size application using GTK. It will have about 10 dialogs. I am halfway, and it is getting really messy. I need guidance about how to organize and articulate my GTK code. What is your advice please ?
07:49:32 <markovirc> Hello kstt
07:50:01 <sleepynate> haha is markovirc what i think it is
07:50:04 * hackagebot annotated-wl-pprint 0.5.3 - The Wadler/Leijen Pretty Printer, with annotation support  http://hackage.haskell.org/package/annotated-wl-pprint-0.5.3 (dchristiansen)
07:50:19 <Tekmo> hattmammerly: Right.  I'm just trying to figure out what shared functionality your engine will provide for all these games
07:50:30 <colDrMcBeardman> legoulash, i was thinking something more like data (Suit a, Value b) => Card = Card a b
07:50:41 <colDrMcBeardman> with "suit"able type classes.
07:50:42 <kstt> I am using glade to design the UI, so at some point I must build-up the haskell objects from the glade XML.
07:50:49 <legoulash> colDrMcBeardman: fortunately that's an error
07:51:00 <hattmammerly> Tekmo: shuffling, drawing cards, popping arbitrary indices (playing a card), uhhh and a notion of 'score'
07:51:03 <kstt> One module per dialog. Does that make sens ?
07:51:27 <Tekmo> hattmammerly: So shuffling can be done on arbitrary lists, so you get that for free as long as you represent your deck as a list of something
07:51:27 <hattmammerly> (which can be chips held, cards left, whatever. it's just an int to be implemented in game logic)
07:51:36 <hattmammerly> Tekmo: again, that's a solved problem
07:51:53 <Tekmo> hattmammerly: So what's the shared functionality that's not a solved problem?
07:51:56 <hattmammerly> I don't think what i'm looking for is something that is done, so i'll have to define types for all the stuff
07:52:13 <colDrMcBeardman> legoulash, pseudocode
07:52:25 <hattmammerly> Tekmo: I don't want a distinct card type for every single different card. i was hoping i could define a game-ambiguous card
07:52:26 <augur> carter: ping
07:52:35 <legoulash> colDrMcBeardman: what are the semantics of your pseudocode?
07:52:40 <Tekmo> hattmammerly: Why do you have to provide a shared card type at all?
07:52:59 <Tekmo> hattmammerly: None of the shared functionality you described requires even knowing what kind of elements the list holds
07:53:18 <Tekmo> hattmammerly: Those are all generic list operations
07:53:20 <klrr_> which command line arg library is to be prefered?
07:53:21 <hattmammerly> Tekmo: because types are organized
07:53:47 <Tekmo> hattmammerly: As far as I can tell, your card game engine is just a list engine
07:53:57 <hattmammerly> Tekmo: it is, yes
07:54:08 <colDrMcBeardman> legoulash, I'm thinking you could have a single deck represent everything if it contained values restricted to Suit and Value type classes.
07:54:23 <Tekmo> hattmammerly: The reason I'm asking is that figuring out the shared card functionality will guide you towards the structure of the type
07:54:33 <colDrMcBeardman> so for uno, the suit would be color and the value 1..whatever the highest num is in uno
07:54:35 <Tekmo> hattmammerly: If there is no shared card functionality, then you leave the type generic (i.e. polymorphic)
07:55:05 <napping> hattmammerly: I'm not sure what you mean by "because types are organized", or what that has to do with the constraints you need on a type to do whatever it is that you are doing
07:55:41 <Tekmo> hattmammerly: For example:
07:55:49 <Tekmo> hattmammerly: shuffle :: [card] -> [card]
07:55:58 <Tekmo> I've left the `card` intentionally lowercase because it's a generic type variable
07:56:08 <hattmammerly> napping: if I can generalize things about cards, a type is very convenient. the question I am posing helps me figure out what generalizations can be made
07:56:09 <Tekmo> It can be anything, including things that are not cards at all
07:56:31 <Tekmo> hattmammerly: So I think you can assume some useful things about cards
07:56:36 <kstt> klrr_: I have used System.Console.GetOpt with success
07:56:47 <Tekmo> hattmammerly: For example, card might be sortable (i.e. implement `Ord`)
07:57:00 <Tekmo> hattmammerly: They are probably also enumerable (i.e. they implement `Enum` and `Bounded`)
07:57:01 <kstt> klrr_: I is a very basic and explicit one, but that worked well for me
07:57:25 <klrr_> okey, will try that one trhanks
07:57:57 <napping> If you can generalize enough, then some operations may need no assumptions at all, so you can use a completely free type varible, and others might just need simple constraints like Ord - you need quite a bit more structure before you really want to require one specific type rather than just setting some constraints
07:58:24 <hattmammerly> Tekmo: again, the goal of this question was to avoid implementing one card type per game, and I can't implement ord without enumerating the values that cards can have
07:58:39 <Tekmo> hattmammerly: You don't have to implement the type at all
07:58:48 <Tekmo> hattmammerly: So Haskell has something very similar to OO-like style
07:59:03 <hattmammerly> Tekmo: i'll just use tuples, what the hell
07:59:09 <Tekmo> hattmammerly: There is an extension called ExistentialQuantification that lets you write something like this:
07:59:31 <Tekmo> hattmammerly: data Card = forall a . (Ord a, Enum a, Bounded a) => Card { getCard :: a }
07:59:40 <Tekmo> hattmammerly: Then you can stick anything in there that implements those classes
07:59:48 <Tekmo> hattmammerly: And you can write functions that accept a generic `Card`
08:00:01 <kstt> Tekmo: don't give this type of advice in public :)
08:00:02 <legoulash> this is a famous antipattern
08:00:20 <Tekmo> I consider it an antipattern IF the equivalent record alternative is better
08:00:32 <hattmammerly> Tekmo: how do you order String "Jack" with Int 9
08:00:51 <Tekmo> hattmammerly: You don't
08:00:54 <S11001001> probably you want an f parameter on Card, and getCard :: f a
08:00:57 <Tekmo> hattmammerly: Yo uhave to unify them into a single type
08:00:58 <hattmammerly> then my problem is unsolved
08:01:09 <kstt> hattmammerly: I think you should read more about how the Haskell type system works :)
08:01:10 <hattmammerly> I wanted to alias 10 to "Jack" to do exactly that
08:01:19 <legoulash> forget about Jack; use 10 instead
08:01:23 <hattmammerly> kstt: definitely, I came to IRC hoping to learn
08:01:32 <napping> hattmammerly: what kinds of cards do you have in mind? If a bunch are played with a standard deck, you should just define that once and use it, and if a game has it's own special cards, I don't see how to avoid defining them
08:01:55 <kstt> The gentle introduction is a good start. Learn you a Haskell is good as well.
08:02:09 <Tekmo> hattmammerly: What you are describing sounds like a game-specific issue, not one that should be handled by the engine
08:02:11 <hattmammerly> napping: that's the conclusion I reached a while ago, i don't really know why i'm still here bickering haha
08:02:21 <Tekmo> hattmammerly: the notion of a Jack or 10 only makes sense for that type of deck
08:02:33 <greg`> ive been working through rwh, its so full of errors
08:02:43 <napping> hattmammerly: well, the other part is that you should be able to write most of your functions to work with any kinds of cards
08:02:43 <hattmammerly> it's pretty clear what I want isn't something that is done, so I won't do it
08:02:52 <hattmammerly> napping: that's already done
08:02:58 <Tekmo> hattmammerly: You can always define a `Num` instance for your card type
08:03:04 <napping> what else did you want then?
08:03:13 <Tekmo> hattmammerly: Then just tell `fromIntegral` to convert 10's to Jacks, if that's what you mean
08:03:21 <napping> If you've already written some generic stuff that works just fine both with standard and non-standard decks?
08:03:21 <Tekmo> hattmammerly: It will then automatically convert numeric 10 literals to jacks
08:03:41 <greg`> i wouldnt recommend buying the book,i would only read rwh on the web
08:03:44 <hattmammerly> Tekmo: oh maybe that helps
08:04:01 <Tekmo> hattmammerly: Numeric literals are really syntactic sugar for `fromIntegral`
08:04:09 <jle`> anyone have any idea why network-2.4.2.0 is throwing an ExitError 127
08:04:15 <jle`> when being built
08:04:22 <hattmammerly> napping: I wanted a 'Card' type that worked well with standard and nonstandard cards. you can feed in arbitrary values and suits, alias them, and ordering etc is taken card of
08:04:32 <legoulash> jle`: no error message?
08:04:46 <Tekmo> jle`: Scroll up and look for the real error message
08:04:53 <jle`> greg`: yeah i stopped recommmending rwh recently these days :/
08:05:03 <jle`> legoulash, Tekmo how do i view the error messages?
08:05:09 <jle`> maybe it's because i have parallel builds on
08:05:10 <hattmammerly> I should get back to work. thanks all
08:05:20 <Tekmo> jle`: When you compile the program it will output any compilation error messages
08:05:24 <jle`> oh i used -v
08:05:28 <jle`> *i will use -v
08:05:38 <Tekmo> jle`: It should do this by default even without -v
08:05:41 <napping> sounds like you want something to help defining card types
08:06:18 <napping> or do you want to change that stuff at runtime?
08:06:20 <jle`> thanks, this is helpful
08:06:26 <jle`> Tekmo: i think it might be because i have parallel builds on?
08:06:32 <Tekmo> jle`: Maybe
08:08:09 <jle`> hm i still didn't get any error messages
08:08:18 <jle`> only the output of ./configure
08:08:35 <kstt> So can anybody give me advices regarding GTK UI code organisation in haskell please ? A well-designed project could help. Anything that helps we avoid the huge mess I am getting into. :)
08:09:31 <kstt> This is my first GTK project, and it is also the first time I feel so miserable in a Haskell project.
08:10:06 <colDrMcBeardman> kstt, ui toolkits in general make you feel miserable.
08:10:19 <Tekmo> So what's the main source of complexity you encounter?
08:13:04 <athan> is there a version declaration system in haskell? Like saying that this program depends on '98 instead of '10, like a doctype in html or a #! in shell scripts?
08:13:33 <legoulash> that's done in .cabal files
08:13:42 <jle`> what is libexec?
08:13:52 <athan> Awesome, thank you. I need to learn how to get cabal working with my projects.
08:14:10 <Tekmo> athan: `Default-Language` is what you want
08:14:23 <Tekmo> athan: i.e. `Default-Language: Haskell2010` or `Haskell98`
08:14:44 <athan> Tekmo: Perfect!!
08:17:21 <Tekmo> kstt: Describe your issue in greater detail
08:17:26 <jle`> even with -v3, the only thing it says is "sh returned exitfailure 127", sh being just running "./configure"
08:18:10 <legoulash> and configure says nothing?
08:18:22 <Tekmo> jle`: Why is `sh` returning the exit code?
08:18:32 <jle`> Tekmo: not even sure why that is
08:18:36 <Tekmo> jle`: Why not just run the configure file directly?
08:18:55 <augur> i wonder if there's a clean way to have totality in haskell
08:19:41 <jle`> hm. i'm not sure where this configure file is. it must be in package's directory?
08:19:47 <jle`> also this package seems to have installed before so that's weird
08:19:48 <kstt> Tekmo: I can't do that concisely. It is a general impression of heaviness and complexity. Every simple thing is taking forever a 100 lines of codes in various files ... I want to know if there are general patterns for GTK/Glade UI management. Where to put code, when and how to bind Events to Handlers, how to manage the running state of the program ...
08:20:32 <kstt> augur: ?
08:21:07 <kstt> The compiler can warn (and even fail) if pattern matching is partial.
08:21:16 <athan> Does anyone know if Applicative is going to be a superclass of Monad in Haskell2014?
08:21:21 <augur> kstt: haskll is a partial language, with no type-level indications of partiality
08:21:26 <Tekmo> kstt: Totality means also avoiding non-terminating programs
08:21:39 <augur> Tekmo: wwweeelll maybe.
08:21:56 <Tekmo> augur: Well, always productive programs are allowed, too
08:22:08 <augur> Tekmo: they're really two distinct issues which can be handled separately, but haskell doesnt do that
08:22:24 <Tekmo> augur: Yeah, I meant more like avoiding _|_
08:22:43 <kstt> athan: yes, the Applicative < Monad should be officially annouced soon, in 2 monthes and 4 days.
08:22:57 <Tekmo> kstt: So the main issue with the way GTK is set up is that it pretty much mandates use of global state to coordinate callbacks
08:23:10 <athan> kstt: Wow, great! How did you find that out?
08:23:12 <Tekmo> kstt: You have to swallow that pill pretty early on
08:23:39 <Tekmo> kstt: You can make working with global state easier if you are comfortable using lenses
08:23:55 <augur> anyway, what would be nice is if like... -> was type-level partial
08:25:16 <kstt> athan: you should ask Tekmo for the details.
08:25:23 <jle`> this is weird because network installed fine before...but today it doesn't like to
08:25:38 <Tekmo> Me?
08:25:49 <jle`> maybe i should just destroy the vm
08:25:52 <Tekmo> I have no part in the AMP
08:25:56 <kstt> Tekmo: you
08:26:22 <kstt> http://www.reddit.com/r/haskell/comments/1bfojn/functor_is_now_a_superclass_of_monad_in_ghc_head/
08:26:27 <Tekmo> That was an April Fool's joke
08:26:45 <kstt> Tekmo: hum ... yes. I know that ...
08:26:50 <athan> lol
08:26:58 <Tekmo> I've never commited a line of code to GHC or base, ever
08:27:00 <athan> thank you haha.
08:27:03 <Tekmo> *committed
08:27:05 <kstt> hence the "in 2 months in 4 days"
08:27:14 <Tekmo> Actually, I'm not sure what the right spelling is
08:27:27 <Tekmo> kstt: Ooooooh
08:28:24 <Clint> Tekmo: thanks
08:28:32 <Tekmo> Clint: You're welcome
08:28:33 <kstt> This has been a recurring joke in the past few years :)
08:28:34 <colDrMcBeardman> Tekmo, the latter.
08:28:42 <Tekmo> colDrMcBeardman: Yeah, you're right
08:29:19 <Tekmo> kstt: Obligatory *whoosh* :)
08:29:34 <colDrMcBeardman> committee has two ms, two ts, and two es, because, well, you know how committees are.
08:31:02 <kstt> Tekmo: regarding GTK UI : so far I have managed to avoid global state, by delaying the event/handler binding to the point where the data is available in the Reader environment.
08:31:15 <kstt> but it looks so messy
08:31:34 <Tekmo> kstt: If you fight global state with GTK you will have a bad time
08:31:52 <kstt> but how can I use a global state in haskell ??
08:32:00 <Tekmo> kstt: Stick it in an IORef
08:32:05 <kstt> Do you think of the unsafePerformIo IORef hack ?
08:32:09 <Tekmo> kstt: It's ugly, but it's the only thing that works with IO-callbacks
08:32:11 <Tekmo> kstt: No
08:32:25 <Tekmo> kstt: Initialize the IORef properly at the beginning of your main and then pass it to all callbacks
08:32:34 <kstt> yes ok
08:32:35 <jle`> mm_freak: so far i've been trying to avoid using unique "object id"s for games/sims...i've seen these used a lot but it feels unclean to me.  but it's getting harder to avoid.  is this pursuit a noble one, a futile one, or is it even considered bad to use unique id's?
08:33:36 <napping> jle`: I haven't done games, but if you need object identity unique ids sound good to me
08:33:45 <napping> what's the alternative, pointer equality tests?
08:33:53 <kstt> Tekmo: this is more or less what I am doing, except that some stuff like the db connection handle in undefined up to a point of execution. But sticking it in a maybe is non-sens either as I have nothing to do if I find a nothing when I expect Just the handle.
08:34:18 <Tekmo> kstt: Yes, I know how ugly it is
08:34:22 <jle`> napping: so far i have been getting away with working on and returning ordered lists
08:34:28 <Tekmo> kstt: This is the reason why I hate callback-based frameworks in general
08:34:33 <jle`> with interactions marked
08:34:46 <kstt> Tekmo : any alternative ready for consumption ?
08:34:49 <jle`> and the occasional Eq hack
08:34:50 <Tekmo> kstt: They put you in the awkward position that you have to rely on really weakly typed solutions like the "sticking in a `Maybe`"
08:35:08 <jle`> i don't think pointer equality even makes sense
08:35:34 <napping> jle`: sounds find, I just don't think using unique IDs if you need object identity between otherwise possibly identical things is sounds ugly
08:35:41 <Tekmo> kstt: So there is a more principled way to do this that I'm working on, but it's still very experimental
08:36:00 <yitz> jle`: i agree with napping
08:36:03 <Tekmo> kstt: It probably won't be ready in time for whatever you are working on, which is why I haven't mentioned it
08:36:37 <Tekmo> kstt: However, I can give you a small tip that might help
08:36:39 <jle`> napping, yitz: fair enough. it just feels kind of out of place because i haven't really ever needed to do it before in haskell
08:36:45 <kstt> Tekmo: do you have GTK code from your hand available for reading on the web ? I have appreciated your style since the first public release of pipes, so I am confident I would find inspiration there.
08:37:25 <Tekmo> kstt: No, I don't have any GTK code with me.  It's on my old computer which I've decommissioned and I can't access it because I'm on vacation
08:37:35 <kstt> are you ??
08:37:38 <Tekmo> kstt: However, I have a general-purpose trick I like to use for escaping callback hell that might help you
08:37:41 <Tekmo> Yes
08:37:42 <jle`> it feels inelegant now but maybe it's just because i'm not usted to it
08:38:01 <kstt> Tekmo: I'm standing, eyes wide opened
08:38:11 <yitz> Tekmo enjoys his vacation by spending time with us here on #haskell
08:38:15 <Tekmo> Haha
08:38:16 <kstt> (or is it just "open")
08:38:19 <Tekmo> I'm a programming addict
08:38:24 <Tekmo> I literally spend all my free time programming
08:38:31 <jle`> #haskell is a perfect vacation
08:38:42 <yayutf_> it is
08:38:52 <Tekmo> It's night time and my kids are asleep, so I'm just chilling here a little bit before sleeping
08:39:48 <Tekmo> kstt: So anyway, a general purpose trick for escaping callbacks is to use channels
08:40:10 <Tekmo> kstt: It's kind of hacky, but it works
08:41:12 <Tekmo> kstt: So usually I will have a data type that represents all possible callbacks (i.e. one constructor per callback)
08:41:16 <misterbee> kstt, athan,  Tekmo, Wait, too many jokes. This one is a non-joke announcement:  http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
08:41:39 <misterbee> (Or an awful troll)
08:41:47 <Tekmo> misterbee: Yes, there is a serious effort to complete it
08:42:12 <Tekmo> kstt: Then I will have each callback push a message into the channel wrapped in their respective constructor
08:42:35 <kstt> Do you put form data in the constructor ?
08:42:47 <Tekmo> I put everything in there
08:43:02 <Tekmo> I move all the program logic out of the callbacks and instead place it downstream of the channel
08:43:26 <Tekmo> So usually I use `pipes-concurrency` for this purpose
08:43:28 <kstt> Ok, so no Gtk-UI parsing in the consumer module.
08:43:44 <Tekmo> I'm not sure what that means
08:43:51 <Tekmo> My GTK knowledge is very limited, though
08:44:16 <athan> I would like to start using TideSDK for all my UI's
08:44:32 <athan> I feel like that would make deployment a lot easier cross-platform
08:44:48 <athan> (and hopefully soon, cross-device, too)
08:44:57 <kstt> Well, if you have a form dialog with 10 fields and a "OK" button for creating the stuff, you put the 10 fields extracted from the UI in your event constructor, before pushing into the channel. Right ?
08:45:10 * hackagebot Yocto 0.1.0 - A Minimal JSON Parser & Printer for Haskell  http://hackage.haskell.org/package/Yocto-0.1.0 (ajg)
08:45:40 <Tekmo> kstt: Oh, yeah, you can do that
08:45:55 <Tekmo> kstt: The purpose of this channel stuff is just to centralize all state management into a single location
08:46:08 <kstt> ok
08:46:13 <Tekmo> kstt: So where this really shines is that you can actually purify your core application logic
08:46:25 <Tekmo> kstt: I typically do this in conjunction with `pipes-concurrency`
08:46:50 <Tekmo> kstt: I will `spawn` an `Output Event` (i.e. where I stuff message) and an `Input Event` (where I read messages from)
08:46:59 <Tekmo> kstt: Then I write my core application logic as something of type:
08:47:14 <Tekmo> kstt: Pipe EventIn EventOut (State MyApp) r
08:47:37 <kstt> I see. Thank you for this advice.
08:47:48 <Tekmo> kstt: There is also an `Output` which handles GTK application updates
08:47:56 <Tekmo> kstt: Something like: `Output EventOut`
08:48:15 <Tekmo> kstt: Then you connect it like:
08:48:47 <Tekmo> kstt: fromInput eventsIn >-> hoist (hoist generalize) (logic :: Pipe EventIn EventOut (State MyApp) r) >-> toOutput eventsOut
08:48:59 <Tekmo> kstt: This keeps your core logic pure and quick-checkable and concurrency-free
08:49:24 <Tekmo> kstt: As a bonus, you odn't need an `IORef`, since you are just doing everything through a pure `State` monad
08:49:25 <athan> what does >-> mean?
08:49:30 <Tekmo> athan: Oh, that's pipe composition
08:49:36 <Tekmo> The arrow points in the direction of information flow
08:49:40 <Tekmo> athan: Here's a simple example
08:49:45 <athan> Tekmo: why do you have it in the type sig?
08:49:59 <Tekmo> athan: It's not in the type signature
08:50:18 <Tekmo> athan: The type signature ends at the ` r)`
08:50:19 <kstt> Thank you tekmo. This is getting a bit beyond my current skills, but it looks good. I'll go back to the code and see how that will help.
08:50:52 <athan> Tekmo: Oh, wait, that was just for coersion, right?
08:50:55 <magneticduck> I've come to the conclusion that Floats and Doubles are disgusting
08:50:56 <Tekmo> kstt: I think just the IORef + global state is enough for your purpose
08:51:01 <magneticduck> anything better to use for efficent number types? :D
08:51:09 <Tekmo> athan: It was just because I forgot to mention which part was the pipe
08:51:23 <Tekmo> athan: That was to clarify that `logic` was the part that was supposed to be the pure pipe
08:51:24 <athan> Tekmo: Oooooooh, cool haha. Sorry.
08:51:28 <Tekmo> athan: No worries :)
08:51:51 <Tekmo> magneticduck: `Int` is pretty efficient
08:51:59 <athan> what are the benefits of quick-check?
08:52:11 <magneticduck> Tekmo: you're suggesting Ratio?
08:52:30 <Tekmo> athan: QuickCheck will not only test properties, but if the property fails it will find the border case that triggers the failure
08:52:41 <Tekmo> magneticduck: I would prefer `Double` over `Ratio`
08:52:49 <magneticduck> I mean, Rational
08:52:49 <Tekmo> magneticduck: I'm surprised `Double` doesn't work well for you
08:52:51 <Tekmo> magneticduck: It should be fast
08:52:53 <magneticduck> it works
08:52:55 <magneticduck> it's fast
08:52:57 <magneticduck> but it's kind of icky
08:53:05 <magneticduck> > [1.0, 1.1..5]
08:53:07 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
08:53:11 <magneticduck> =P
08:53:14 <Tekmo> athan: That's why QuickCheck requires that all tests are pure
08:53:27 <Tekmo> athan: When it finds a failing test case it will then repeatedly narrow it down to the boundary case
08:53:28 <magneticduck> that kind of error can add up after a while
08:53:39 <Tekmo> athan: It can't do this kind of narrowing unless the test is reproducible and pure
08:53:48 <magneticduck> so it's not optimal to use it for, for instance, complicated geometry
08:54:23 <Tekmo> magneticduck: So you want only exact arithmetic?
08:54:36 <magneticduck> yeah
08:54:44 <Tekmo> magneticduck: Then maybe `Rational` would work
08:55:17 <jle`> welp guess it's time to destroy the vm
08:55:20 <jle`> and rebuild everything
08:55:23 <athan> oh my god
08:55:28 <athan> that is friggin amazing
08:55:38 <Tekmo> athan: Yeah, it's sweet
08:55:55 <legoulash> @check \x -> x > 5
08:55:57 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:55:58 <lambdabot>  0
08:55:58 <Tekmo> athan: For example
08:56:09 <legoulash> @check \x -> x < 5
08:56:11 <lambdabot>  *** Failed! Falsifiable (after 14 tests):
08:56:11 <lambdabot>  5
08:56:28 <athan> NICE
08:56:29 <athan> WOW
08:56:44 <athan> holy crap
08:56:50 <legoulash> @check \xs ys -> reverse (xs ++ ys) == reverse ys ++ reverse xs
08:56:52 <lambdabot>  +++ OK, passed 100 tests.
08:56:54 <athan> are there any testing frameworks for quick-check?
08:56:58 <Tekmo> athan: Tons
08:57:05 <athan> Or good guidelines for organizing your tests?
08:57:07 <athan> aweosme!!!!!!
08:57:14 <athan> ...for Yesod?
08:57:31 <Tekmo> Maybe, I'm not sure
08:57:44 <legoulash> @check \xs -> sum xs >= length xs
08:57:45 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1 shrink):
08:57:46 <lambdabot>  [0]
08:57:55 <legoulash> shrink!
08:58:06 <athan> I'm going to try and make a Warp middleware / addition to Hamlet that makes your websites browser-bug free
08:58:17 <Tekmo> athan: Here's a sophisticated example I wrote up some time ago: http://www.haskellforall.com/2013/11/test-stream-programming-using-haskells.html
08:58:17 <athan> I feel like this will be vital
08:58:49 <Tekmo> athan: Also, there is a `test-framework-quickcheck2` library
08:58:51 <athan> Thank you.
08:59:05 <Tekmo> athan: That's what I've been using, although I'm not sure if it's the best one or not
08:59:12 <athan> WAIT
08:59:16 <joelteon> @check \xs -> sum xs <= length xs
08:59:18 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 2 shrinks):
08:59:18 <lambdabot>  [2]
08:59:18 <athan> YOU'RE GABRIEL?!?!?!
08:59:23 <Tekmo> athan: Yes :)
08:59:28 <athan> Holy shit!!!!!
08:59:31 <joelteon> Who doesn't know Tekmo
08:59:34 <magneticduck> @check \(x :: Float) -> x + x == (x + 1.0) + (x - 1.0)
08:59:34 <lambdabot>  <unknown>.hs: 1: 15:ScopedTypeVariables is not enabled
08:59:35 <joelteon> Get with the program mang
08:59:42 <athan> I just read your papers on category thery!!
08:59:44 <magneticduck> @check \x -> (x :: Float) + x == (x + 1.0) + (x - 1.0)
08:59:45 <legoulash> oh, you're the pipes guy?
08:59:46 <lambdabot>  *** Failed! Falsifiable (after 6 tests):
08:59:46 <lambdabot>  3.771527
08:59:48 <Tekmo> Papers?
08:59:48 <magneticduck> hehehe
08:59:52 <athan> And I was literally going through constant epiphanies
08:59:55 <Tekmo> I've only written blog posts
08:59:55 <athan> thank you so much
08:59:59 <Tekmo> You're welcome!
09:00:08 <athan> you're a supergod hahaha
09:00:10 <Tekmo> Haha
09:00:30 <athan> wow. Awesome.
09:00:57 <athan> I really want to make a visual interpretation of the language
09:01:12 <athan> I feel like it would make it a lot more popular
09:01:29 <Tekmo> Of which language?
09:01:45 <athan> well, actually, a lot of languages
09:01:49 <Guest25598> What's the current status of modules w/ module level interfaces in Haskell? I know backpack is a thing - are there others? Any apparent favorite of the community?
09:01:52 <athan> I'm going to need to design a framework for it
09:01:53 <athan> but
09:02:00 <athan> haskell would be a nice one
09:02:15 <magneticduck> btw does anybody know why Floats have the weird property?
09:02:29 <jle`> magneticduck: this is only the most asked question about computers ever :)
09:02:38 <magneticduck> ikr
09:02:42 <magneticduck> and for some reason I don't know it
09:02:49 <Earnestly> Because it's binary, base 2
09:02:49 <legoulash> http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
09:02:50 <Tekmo> magneticduck: You mean how they are enumerated?
09:02:51 <magneticduck> today I find out
09:02:53 <athan> It's going to be difficult to design my framework polymorphically, so different features of the language (like language extensions) would work
09:02:57 <athan> It's gonna be tricky
09:03:16 <magneticduck> @check \x -> (x :: Float) + x == (x + 1.0) + (x - 1.0) -- talking about this property
09:03:17 <Dodek> magneticduck: because floats are not associative.
09:03:17 <lambdabot>  <hint>:1:107:
09:03:18 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
09:03:22 <jle`> magneticduck: http://stackoverflow.com/questions/588004/is-javascripts-floating-point-math-broken
09:03:35 <magneticduck> Dodek: well yeah, that's the effect
09:03:54 <legoulash> (guess what the answers link to)
09:03:55 <Dodek> magneticduck: if you think about how floats work, this shouldn't be very surprising
09:04:03 <magneticduck> ure
09:04:06 <magneticduck> sure*
09:04:15 <Earnestly> magneticduck: What is 0.1 in base 2?
09:05:01 <magneticduck> as a float it's just <zeroes>1 * 10*-1
09:05:05 <magneticduck> uh, do they do it like that?
09:05:10 <legoulash> magneticduck: there is no 10 in floats
09:05:22 <Earnestly> 0.00011001100110011001100110011001100110011…
09:05:29 <jle`> http://www.smbc-comics.com/index.php?db=comics&id=2999#
09:05:29 <magneticduck> yeah gotcha
09:05:39 <magneticduck> okay
09:05:49 <Tekmo> athan: So you might find the following post (actually the entire series) interesting, and I'll explain why: http://conal.net/blog/posts/haskell-to-hardware-via-cccs
09:05:50 <magneticduck> legoulash: wiki article says that the exponent base is sometimes in 10
09:06:13 <legoulash> not in practice
09:06:20 <Tekmo> athan: That post is about how Conal was trying to basically "overload" lambda calculus so he could port it to domains outside of software (i.e. hardware in that particular case)
09:06:23 <jle`> magneticduck: what architecture is your computer?
09:06:38 <jle`> do you use x86?
09:06:49 <magneticduck> yep
09:07:04 <jle`> then it's not base 10 :P
09:07:04 <Tekmo> athan: Category theory is all about finding patterns between diverse domains so that you can port ideas and tools between those domains
09:07:05 <athan> Tekmo: How do you mean?
09:07:13 <magneticduck> jle`: I know that
09:07:20 <magneticduck> I was talking about the exponent base, silly
09:07:23 <magneticduck> xP
09:07:28 <magneticduck> lol base ten computers
09:07:29 <athan> Tekmo: Please go on!
09:07:30 <jle`> i mean, the exponent base for your floating points
09:07:35 <Tekmo> athan: So whenever you formalize something in terms of category theory (i.e. a "categorical semantics") you've bsaically made it possible to port that "thing" to very diverse platforms
09:07:39 <jle`> floating point is implemented at the hardware level
09:07:48 <jle`> so your x86 doesn't have base 10 exponent bases
09:07:56 <Tekmo> athan: For example, lambda calculus is one of those things that has been formalized in terms of category theory, specifically "cartesian closed categories"
09:08:11 <athan> Tekmo: Wow. So... ASICs are being generated from Haskell code now?
09:08:20 <Tekmo> athan: That means that you can port lambda calculus to anything that supports cartesian closed categories
09:08:35 <Tekmo> athan: Yeah, integrated circuits are an example of a domain that supports cartesian closed categories
09:08:37 <athan> Wow! I didn't know that!
09:08:44 <magneticduck> jle`: I mean, it can't be represented, even at the hardware level, as 1e-1 using 10 as the base for the exponent?
09:08:54 <scshunt> erm what.
09:08:57 <athan> Tekmo: Oh my god
09:09:04 <napping> that's a bit of an exaggeration, I don't think asics actually implement exponentials very well
09:09:08 <athan> Tekmo: Holy crap hahahahaha
09:09:10 <Tekmo> athan: The reason I mention this is that if you can make a visual programming environment that supports cartesian closed categories then you can port lambda calculus to it and, vice versa, port it to lambda calculus
09:09:33 <scshunt> Tekmo: are you trying to dumb things down to the point where they become misleading?
09:09:49 <Tekmo> scshunt: No, I don't think so.  Why?
09:10:03 <napping> But it was still very categorical, something about traced monoidal categories or something that circuits can actually implement, that can handle at least some restricted lambdas (like linear ones)
09:10:08 <rien_> Tekmo: so if I want in I should start here? : http://www.haskellforall.com/2012/08/the-category-design-pattern.html
09:10:11 <napping> or maybe using memory to do closures?
09:10:17 * hackagebot diagrams-haddock 0.2.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2 (BrentYorgey)
09:10:20 <Tekmo> rien_: You should start with something much more advanced than that
09:10:22 <yitz> Tekmo: are proteins a domain that supports cartesian closed categories?
09:10:30 <Tekmo> rien_: I'd recommend a more formal category theory text
09:10:46 <rien_> Tekmo: more advanced? surely you overestimate my math abilities? :)
09:10:46 <Tekmo> rien_: My blog only touches on very rudimentary category theory
09:11:03 <Tekmo> yitz: I have no clue.  I've never really thought about it
09:11:23 <Tekmo> yitz: I'm not even sure that visual programming supports it
09:11:24 <ciaranm> a category is not a design pattern
09:11:31 <scshunt> how do you "support" categories or "port" lambda calculus?
09:11:32 <Tekmo> yitz: It's just an idea I'm throwing out there for athan
09:11:34 <legoulash> it is now
09:11:43 <scshunt> those don't even make any sense
09:12:00 <athan> Tekmo: Yeah, that's where I'm at, too
09:12:01 <rien_> can you give a hint of the practical implications of integrated circuits being compatible with CT?
09:12:08 <rien_> just so I understand roughly
09:12:17 <Tekmo> scshunt: So "porting" lambda calculus definitely makes sense.  I think that's pretty defensible terminology
09:12:24 <yitz> rien_: there's also this: http://en.wikibooks.org/wiki/Haskell/Category_theory
09:12:40 <Tekmo> rien_: Read Conal's series
09:12:42 <napping> scshunt: "admits" a category would probably be more standard terminology
09:12:47 <Tekmo> rien_: He does a good job of motivating this
09:12:57 <rien_> Tekmo: ok I like Conal a lot
09:12:59 <Tekmo> rien_: That post is the first of several consecutive posts on this topic
09:13:06 <athan> Tekmo: So if I make anything that supports the design of lambda calculus, I'll get something that supports cartesian categories?
09:13:51 <Tekmo> athan: The other way around
09:13:52 <greg`> you guys are soo far ahead of me
09:13:53 <rien_> Tekmo: I've seen that link before and it makes me think I lack the sufficient foundational math (or familiarity with math notation) to follow the explanations
09:14:07 <athan> Tekmo: Why is that?
09:14:12 <rien_> Tekmo: that's what made me start googling on stackoverflow for "math literacy" posts and recommendations
09:14:26 <athan> Tekmo: Because the category is more generic?
09:14:29 <Tekmo> rien_: Yeah, Conal is on a very high level
09:14:47 <Tekmo> athan: I like to think of category theory concepts as type classes
09:14:51 <Tekmo> athan: You instantiate them in various domains
09:14:53 <rien_> Tekmo: I still remember his TV keynote (beginning of FRP or something similar)
09:15:08 <yitz> Tekmo: i'll bet it's possible to design a class of proteins, and a transformation on them, that is a turing complete cellular autonoma. that would be fun.
09:15:10 <athan> Tekmo: And lambda calculus being one domain, correct?
09:15:11 <Tekmo> athan: Haskell programs are just one way to instantiate ideas from category theory
09:15:12 <napping> yitz: you'd need more than just proteins, at least some ribosomes and RNA editing and maybe vesicles for pairing arbitrary things - and then perhaps it's maybe not all reliable enough
09:15:37 <Tekmo> yitz: Yeah, that would :)
09:15:40 <athan> Tekmo: Right, okay, cool. Yeah, I agree, this framework should be as generically defined as possible
09:15:43 <Tekmo> athan: Right
09:15:55 <napping> Turing complete is easier, even turing machines are turing complete.
09:16:04 <athan> Tekmo: But allowing for complexity. Hmm, that's a good point
09:16:18 <napping> Actually getting pairing and stuff to hold precisely is probably harder
09:16:32 <magneticduck> hehe "even turing machines are turing complete"
09:16:38 <conal> I'm very pleased with this CCC angle on compiling Haskell to hardware. It poses a small set of compelling questions to answer. A great design focuser.
09:16:40 <napping> not original, but very true
09:16:47 <Tekmo> athan: I just want to warn you that I can't guarantee that you can implement an interface to cartesian closed categories using a visual interface, or that it will be an easy to use interfac
09:17:29 <rien_> I think I will probably pay a mathematician by the hour to teach me CT, it'll go much faster
09:17:40 <athan> I accept the responsability haha, I think it's a healthy challenge.
09:17:46 <yitz> Tekmo: it appears people have proposed using a mechanism found in stichotrichous cilliates. looks like no one has actually built it yet though.
09:18:01 <Tekmo> yitz: Do you have a link to that?
09:18:04 <yitz> napping: ^^
09:18:18 <rien_> conal: what do you think of the new wave of FRP libraries coming out? are we going in the right direction?
09:19:18 <yitz> Tekmo: papers of Prescott referenced here: http://network.nature.com/groups/natural_computing/forum/topics/3582
09:19:41 <Tekmo> yitz: Thanks
09:19:50 <Tekmo> Alright, I have to head out.  It was a pleasure chatting with you all
09:19:58 <rien_> Tekmo: o/
09:20:04 <rien_> likewise
09:20:07 <Tekmo> \o
09:20:13 <conal> rien_: i've ween quite a lot of libraries that use the term "FRP", but most neglect the two properties that have always defined "FRP" for me. Which libraries do you have in mind?
09:22:04 <rien_> conal: Bacon.js
09:22:15 <rien_> are the two properties Signals and EventStreams?
09:23:16 <rien_> and also FrTime in Racket though I haven't looked deep into it yet as I have played with Bacon.js
09:23:24 <conal> rien: for the two properties, see http://stackoverflow.com/a/5878525/127335
09:23:40 <conal> rien: iirc, Bacon.js discards both.
09:24:19 <rien_> wow it helps so much even though they got it "wrong" then :)
09:24:25 <kazagistar> is it just me, or do library authors not write example uses very often in haskell? :/
09:24:50 <rien_> I wonder if it's one of those things like monads where one can easily benefit from a somewhat monadic context without proving all the rules, but making something a proper monad takes more elbow grease
09:24:58 <yayutf_> kazagistar: that's certainly my impression
09:25:58 <td123> kazagistar: I feel like the larger the project, the more likely that it will have examples
09:26:16 <rien_> conal: I'll read that link carefully and check the links and educate myself. btw thanks for just being online making all these concepts more accessible for everyone. I run into material by you all the time.
09:26:40 <conal> rien_: :)
09:27:18 <kazagistar> like, I cannot find out how to use regex.tdfa...
09:28:37 <napping> conal: I see the argument for continuity in animation, but what about just structuring event handling for user interfaces?
09:29:26 <yitz> conal: ugh, your why-program-with-continuous-time post doesn't seem to be loading...
09:29:34 <conal> napping: i used continuity for mouse motion in GUIs.
09:30:19 * hackagebot BlogLiterately-diagrams 0.1.4 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.4 (BrentYorgey)
09:30:57 <conal> yitz: hm. just loaded for me. i don't know what makes my blog load slowly. maybe a wordpress thing. maybe an underpowered (virtual) server. wish i knew.
09:32:26 <Kaidelong> conal: you have a blog post somewhere about actually getting wxHaskell working on windows?
09:32:52 <conal> Kaidelong: no, i don't. sorry.
09:35:53 <napping> conal: That's also pretty nice, though even there it's really not possible to scale the speed of mouse input, but I really had in mind systems where the events are already all discrete. Thinkinging of a browser or UI toolkit handling all the input and just generating mouse clicks and so on (and not wanting to implement your own drag-and-drop), or more generally a denotative message passing model.
09:38:02 <magneticduck> humm, the code "let (test :: IO ()) = return () in test" fails with error "illegal type signature"
09:38:06 <magneticduck> uhmm..
09:38:17 * magneticduck stares blankly
09:38:27 <magneticduck> I had no idea GHC worked like that
09:38:47 <magneticduck> you can't just put type signatures wherever you feel like it?
09:38:55 <jle`> not in ghci
09:38:56 <geekosaur> no, there's an extension needed
09:39:01 <notdan> augur: yes
09:39:06 <notdan> augur: or (r -> a) :)
09:39:28 <conal> napping: low-level implementation substrates for input deliver things like "motion events", but i always considered that property to be a bug, and so fixed it (signal reconstruction) before the information enters a frp program. dually, rendering/presentation substrates present discrete consumption, so i sampled the logically continuous model.
09:39:28 <magneticduck> btw is there any particular reason why?
09:39:52 <levi> Hmm, http://conal.net/ has been deemed by my network administrator to be unsafe or unsuitable for me to access. :P
09:39:54 <napping> you can put type signatures anywhere in an expression, but putting them in patterns needs ScopedTypeVariables
09:40:15 <magneticduck> mm alright
09:40:37 <napping> also, you can't put them literally *anywhere*. module Main :: Integer where ... is not a good start to a file.
09:41:07 <notdan> edwardk: Maybe also has a fixed number of holes, but it's not representable
09:41:26 <notdan> unless I misunderstood what does "a fixed number of holes" mean
09:41:56 <geekosaur> the current ghc manual is somewhat confusing, you need to dig upward a couple levels to find that pattern type signatures are covered by ScopedTypeVariables now
09:43:29 <ski> geekosaur : which imo is unfortunate
09:43:40 <conal> levi: hrmf.
09:44:20 <napping> conal: Perhaps it would be clearer with another domain. What if you want to something like an SMTP server in an FRP style? Is your claim that continuous time is necessary for UI work, or that discrete time is inherently unsatisfactory in any domain?
09:45:51 <levi> conal: Wow, it took over a minute to grab one of the .gif files from your home page. I suspect something is wrong with your VPS.
09:45:52 <conal> napping: "necessary" is generally a very strong claim, and i don't know how one might make the claim precise, let alone prove it. similarly for "unsatisfactory in any domain".
09:46:13 <conal> levi: i guess i'd better reboot. thanks!
09:47:33 <conal> napping: when i look at modeling a domain aspects via discrete (events) and/or continuous (behaviors), i ask myself which is natural (for each aspect) and which is merely habitual.
09:48:58 <levi> If you've got any PHP stuff running that you installed yourself, it's possible that someone has exploited a security hole and compromised it. You might want to see if there's anything suspicious in your process lists before rebooting.
09:49:01 <conal> napping: and pay particular attention to habitual choices that appear to be motivated by discreteness of computers (really their discrete abstractions from a continuous implementation) and imperative programming frameworks.
09:49:51 <conal> levi: i have a sinking feeling that may be the case. my blog has a few wordpress extensions.
09:50:30 <conal> maybe i'd be better off migrating to wordpress.com. or somehow migrating out of wordpress altogether.
09:50:32 <napping> magneticduck, geekosaur: ScopedTypeVariable is just what ghci suggested to me on that same error
09:50:51 <notdan> Is there a way to put restrictions on libraries when compiling code with 'ghc --make'?
09:51:34 <dennda> conal: I'm quite happy with static blogging solutions if that fits your use case
09:51:37 <Platz>  /lastlog conal
09:51:41 <Platz> ahh sorry
09:52:29 <levi> If you are not inclined to sysadmin tasks, hosted solutions can save a lot of grief. The amount of malware actively probing for vulnerable systems now is really sad. :(
09:53:08 <dennda> I just push static (blog) files to github pages.
09:53:17 <conal> levi: sounds like a good choice for me.
09:53:21 <Maior> Hakyll is rather good
09:53:58 <conal> i wonder how i might migrate the comments/discussion as well as the posts. and continue supporting disucssion.
09:54:01 <augur> notdan: feh! r -> a! horrible!
09:54:25 <levi> Yeah, tools like Hakyll are handy. Depends on how much time you want to spend on your website tools, and how much you want to just publish without spending time on it.
09:54:57 <levi> Hosted comment thread platforms like Disqus are used frequently with static sites.
09:55:14 <levi> I believe many of them can automatically import comments from Wordpress sites.
09:55:21 <Maior> I went from WordPress.com to Hakyll / Jekyll with a bunch of sites and oh gosh it was so worth it
09:55:27 <Maior> (Octopress in the Jekyll cases)
09:55:29 <Platz> looking at hakyll blogs, I've noticed haskellers tend not to put a whole of effort into visual design- focus more on the "signal" rather than "noise"
09:55:53 <levi> Hosting your own comment threads is a nightmare of its own due to comment spammers.
09:56:28 <dennda> I never really saw the value in comment threads; All I ever received was crap.
09:56:31 <dennda> YMMV
09:56:33 <Fuuzetsu> Who needs ‘pretty visuals’ anyway. If you have something pretty to show, then do it. If not, then concentrate on the content.
09:58:31 <conal> i use Akismet to filter spam, and then moderate the comments that get through to weed out spam and low-content comments.
09:59:05 <Maior> I don't have comments
09:59:32 <Maior> people can tweet or send emails or something
09:59:38 <jle`> http://www.codinghorror.com/blog/2006/04/a-blog-without-comments-is-not-a-blog.html
10:00:05 <Platz> Fuuzetsu: 'pretty' is be superfluous, but good designs can make reading content less grating
10:00:16 <Maior> jle`: predates the spread of Twitter, but sure
10:00:17 <levi> Random bloggers opinions on what is or is not a blog are... opinions.
10:01:43 <merijn> Speaking of Hakyll blogs, anyone aware of a nice Hakyll library for generating a bibliography from a BibTeX file?
10:02:30 <Platz> at least jeff atwood tries to be controversial
10:03:00 <levi> I know someone wrote a gitit plugin to allow BibTeX entries to be embedded in documents. Perhaps that could be repurposed.
10:06:12 <levi> I use gitit to store notes about stuff I'm studying, which is handy because it's got good mathjax integration.
10:07:05 <sm> Platz: it's enough work to set up and maintain a hakyll blog that there isn't much time left for styling
10:07:28 <merijn> sm: Really? I'm mostly stuck on the styling, rather than the setup/maintenance
10:07:43 <Fuuzetsu> Platz: The poster of that seems to have never heard of this new and cool ‘e-mail’ thing
10:07:48 <conal> levi: i just rebooted my server. would you please try at .gif again (or something else) to see whether the responsiveness improved?
10:08:15 <levi> conal: It was pretty much instant that time.
10:08:24 <Platz> sm: I don't think everyone needs to do a custom job.  something like "themes" are popular elsewhere
10:08:48 <conal> levi: super. thanks again.
10:09:01 <Fuuzetsu> oops, meant to highlight jle`
10:09:03 <Platz> but yeah I don't have much room to speak.  no blog.. yet :(
10:09:51 <shachaf> hm, it is tricky to define
10:09:54 <shachaf> er
10:10:02 <levi> conal: Are you planning on writing any more about modeling of circuits?
10:10:09 <sm> yst is a more opinionated/focussed static site builder than hakyll, but I don't know if it is up to building a blog with tag feeds etc.
10:10:24 * hackagebot concurrent-state 0.6.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.6.0.0 (JoelTaylor)
10:11:14 * sm would really like to see something like gitit polished up to the level of a blog-capable, thousand-plugin wiki like dokuwiki
10:11:19 <conal> levi: yes, i am. it's my main project, and i'm making more progress. now i have a working elegant story for exponentials/closures.
10:12:00 <levi> Nice. Looking forward to seeing what you have to say on it.
10:12:50 <ParahSailin> hm, looks like trifecta on hackage is broken-- it requires 0.01 <= fingertree < 0.1, and one of its dependencies, reducers requires fingertree == 0.1.*
10:12:58 <shachaf> broken++
10:13:00 <Fuuzetsu> conal: didn't think you were the type of person that would want ‘Bionic Men's Elite Gardening Gloves, Silver, XXX-Large’, especially in XXXL
10:13:00 <Fuuzetsu>  
10:13:01 <merijn> conal: Speaking of modelling circuits, are you familiar with cλash?
10:13:04 <ParahSailin> can anyone confirm that cabal install trifecta is broken?
10:13:29 <conal> merijn: i've read some papers and chatted with one of the authors a few times.
10:14:13 <conal> Fuuzetsu: i have long fingers. hard to find gloves that fit.
10:14:19 <levi> sm: It's definitely a do-able project. I don't think the current maintainers have a lot of time to do it, though. Most work seems focused on pandoc itself.
10:14:47 <merijn> conal: Ok, I was just wondering, the blog posts I read about you stuff reminded me of what they were doing (and I always try to pimp my colleagues work in the hope they do the same ;)
10:14:48 <sm> levi: absolutely. jgm has his hands full with that monster!
10:15:25 * hackagebot yaml 0.8.5.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.5.4 (MichaelSnoyman)
10:17:06 <levi> There's a gitit2 on github, which I was going to try to massage into something else, but I couldn't even figure out how to update it to the latest yesod at the time.
10:17:37 <Redz> how can i automate to generate functions like  (String -> Bool) -> (Int -> Bool) -> Foo -> Bool  for data Foo = Foo String Int  for any data type?
10:17:38 <sm> levi: I was wondering about that. It seems he was experimenting and dropped it ?
10:17:44 <levi> It does seem that way.
10:18:03 <Fuuzetsu> Redz: Template Haskell?
10:18:56 <Fuuzetsu> could probably use lens to handle it for you
10:19:23 <Redz> and Generics?
10:19:36 <levi> There's a lot of customization you could do to the mainline gitit, though. Pretty much all of the HTML is generated via simple templates.
10:19:59 <ski> Redz : you will have to decide how to handle recursive ones. and then possibly whether you want to allow irregular as well
10:20:05 <levi> I think it might be the same template code hakyll uses?
10:20:26 * hackagebot git-annex 5.20140127 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140127 (JoeyHess)
10:20:36 <sm> levi: part of dokuwiki's charm is the ease of modifying it with plugins. I'm not sure how doable that is for a haskell wiki. The nearest practical approach I see would be using helper executables as plugins
10:20:47 <ski> Redz : btw, itym `(String -> Int -> Bool) -> (Foo -> Bool)' here ?
10:20:55 <levi> gitit already has a plugin system, actually.
10:20:56 <Clint> gitit has plugins
10:21:45 <sm> really  ? it has been a while since I looked at it. Do they, y'know, Just Work ?
10:21:58 <levi> The Happstack guys are basing their Clckwrks (sp?) CMS on a plugin architecture as well.
10:22:04 <Redz> hmm. maybe i can curry it from (String -> Int -> Bool) .
10:22:16 <sm> all these plugin systems so far seem to be a bit fragile
10:22:54 <ski> well, `(String -> Bool) -> (Int -> Bool) -> (Foo -> Bool)' would be more appropriate for `data Foo = FooOfString String | FooOfInt Int', no ?
10:23:02 <levi> I haven't tried them. The combination of Pandoc guts and git integration has met most of my needs for it.
10:23:06 <Redz> no.
10:23:15 <ski> why ?
10:25:05 <Redz> i would like to match for every single element in a data type. for example to write something like  `filter (xFoo (isPrefixOf "lol") True)`
10:25:32 <Redz> i mean (const True)
10:25:36 <sm> levi: I'd like to be able to write a few lines of code and glue in a hledger rendering step.. or install a plugin and start coding UML diagrams, like the one at at http://hledger.org/wiki/developer-guide#data-model
10:27:07 <ski> Redz : `filter (yFoo (\s i -> isPrefixOf "lol" s))' ?
10:27:27 <ski> with this variant, you can check whether `s' and `i' satisfies some relating condition
10:27:48 <ski> as opposed to only being able to check whether they satisfy conditions of their own, separately
10:28:44 <Redz> i was looking for more usability. especially when building something like prolog.
10:28:53 <levi> sm: Good point. It'd be nice to have some kinds of code blocks replaced with their execution, like in org-mode.
10:29:07 <Redz> make it more composable etc.
10:29:35 <ski> i'm not sure how this is like Prolog
10:29:42 <ski> (nor how it's more composable)
10:30:26 <levi> sm: It looks like one of the plugins is for dot support, so you might be able to do it with the current gitit: https://github.com/jgm/gitit/blob/master/plugins/Dot.hs
10:30:41 <PTBD> does somebody know if there is a explanation or turorial on how to determine types manually? ... given some functions etc
10:31:12 <levi> PTBD: You mean how to infer the same types that Haskell would?
10:31:20 <sm> interesting, thanks
10:31:21 <PTBD> yes
10:31:23 <levi> PTBD: Or how to assign types to things in general?
10:31:25 <Redz> hm. i should write a test case.
10:31:45 <sm> "
10:31:50 <PTBD> levi, if given something like "concat . concat" I am supposed to write down the type
10:32:38 <jle`> start from outside inside out
10:32:40 <levi> PTBD: Well, the gist of such a tutorial would be to break the expression into sub-expressions and find the types of those.
10:32:45 <bennofs> :t (.)
10:32:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:32:48 <bennofs> :t concat
10:32:49 <lambdabot> [[a]] -> [a]
10:34:44 <PTBD> lets take "concat . concat" as an example. I know that concat is awaiting [[a]] and return [a]... [a] (lets call it x) is given to the second concat but it must be [[x]] so I have [[[a]]]
10:35:23 <PTBD> but how is the return [a] and not [[a]]
10:35:32 <ski> i think doing it with explicit `forall's would help
10:36:14 <levi> PTBD: The point of concat is to remove one layer of list structure. The fact that the resulting type may still have extra layers of list structure is transparent to the concat function.
10:36:48 <jle`> > concat [[[1,2,3],[5,6,7]],[[7,8,9],[1,2,3]]]
10:36:50 <lambdabot>  [[1,2,3],[5,6,7],[7,8,9],[1,2,3]]
10:37:05 <jle`> i'm concatting two lists of int lists
10:37:06 <levi> Due to paremetricity, it can't see into 'a' to tell whether it's a list or not.
10:37:06 <merijn> PTBD: Haskell infers that your second "[[a]] -> [a]" gets results from the first concat, which returns a "[x]", so x must be "[a]" (else it doesn't match the input of the second concat)
10:37:47 <jle`> > concat . concat $ [[[1,2,3],[5,6,7]],[[7,8,9],[1,2,3]]]
10:37:48 <lambdabot>  [1,2,3,5,6,7,7,8,9,1,2,3]
10:38:06 <merijn> PTBD: So if the first "concat" has "[[x]] -> [x]" and 'x' has to be "[a]" as we just discovered
10:38:22 <merijn> PTBD: So the first concat has to have type "[[[a]]] -> [[a]]"
10:38:34 <ski> PTBD : do you want intuition or an algorithm ?
10:39:21 <levi> The thing to keep in mind is that the type signature inferred is the *most general* one that is correct.
10:40:10 * ski stares hard at PTBD
10:40:29 * hackagebot diagrams-builder 0.5.0.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.1 (BrentYorgey)
10:40:31 <PTBD> ski, primarily I want somehint I understand and I am able to do myself
10:40:43 <PTBD> hold on, I still try to get this one right
10:41:05 <jle`> look at the type of (.)
10:41:13 <jle`> see (b -> c) and (a -> b)
10:41:18 <jle`> the b's have to be the same then
10:41:36 <jle`> the input of the first concat has to be the output of the second concat
10:41:50 <jle`> take some guesses at what b has to be.
10:41:54 <merijn> PTBD: if you look at the output of two concats (i.e. [[a]] -> [a] and [[x]] -> [x]) together then you see that [a] must match [[x]]
10:41:56 <PTBD> I did use the (.) type and end up always at [[[a]]] -> [[a]]
10:42:06 <jle`> :t concat . concat
10:42:07 <merijn> PTBD: Therefore 'a' must be '[x]'
10:42:08 <lambdabot> [[[a]]] -> [a]
10:42:36 <jle`> okay, now let's guess that b is [t]
10:42:46 <jle`> if b is [t] then a must be [[t]]
10:43:08 <ski> PTBD : the general rule you use is that if `e :: tau0 -> tau1' and `e0 : tau0', where `tau0',`tau1' are types, and `e',`e0' are expressions, then `e e0 :: tau1'
10:43:31 <ski> s/ : / :: /
10:43:57 <ski> PTBD : in your case, you start from
10:44:19 <ski>   (.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)
10:44:20 <shachaf> ski: "PTBD :: "?
10:44:35 <ski> shachaf : sounds ok to me :)
10:44:48 <ski>   concat :: forall a. [[a]] -> [a]
10:45:44 <ski> PTBD : the `forall's saying that `(.)' and `concat' have the respective types, *for all* possible types you can replace the type variables `a',`b',`c', respectively `a' by
10:46:00 <ski> btw, you have to remember here that
10:46:02 <ski>   (.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)
10:46:09 <ski> really means
10:46:14 <ski>   (.) :: forall a b c. (b -> c) -> ((a -> b) -> (a -> c))
10:46:16 <ski> and that
10:46:20 <ski>   concat . concat
10:46:22 <ski> really means
10:46:26 <ski>   (.) concat
10:46:29 <ski> which really means
10:46:31 <ski> er
10:46:38 <ski>   (.) concat concat  -- rather :)
10:46:40 <ski> which really means
10:46:48 <ski>   ((.) concat) concat
10:47:33 <ski> PTBD : now, each occurance of e.g. `concat' in the expression to be typed may use a different *instance* of the type for `concat'
10:47:39 <ski> PTBD : do you understand this ?
10:48:13 <ski> (e.g., do you know what an "instance" of a universal type (iow a type beginning with `forall') is ?)
10:49:25 <PTBD> its hard
10:49:47 <ski> one possible instance of
10:49:55 <ski>   concat :: forall a. [[a]] -> [a]
10:49:56 <ski> is
10:50:04 <ski>   concat :: [[Integer]] -> [Integer]
10:50:08 <ski> another is
10:50:17 <ski>   concat :: [[[Char]]] -> [[Char]]
10:50:25 <ski> however
10:50:30 * hackagebot simple 0.7.0.1 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.7.0.1 (AmitLevy)
10:50:34 <ski>   concat :: [[[Char]]] -> [Integer]
10:50:37 <ski> isn't an instance
10:51:28 <ski> so, you have to replace the type variable `a' (removing the `forall a. ') by the *same* type throughout, to get an actual instance of the type
10:52:03 <ski> > (reverse [0,1,2],reverse [False,False,True,False])
10:52:05 <lambdabot>  ([2,1,0],[False,True,False,False])
10:52:39 <sm> Clint: speaking of gitit2.. are you using it ?
10:53:02 <ski> here, the first `reverse' is being used at the type `[Integer] -> [Integer]', and the second at type `[Bool] -> [Bool]', both of which are *instances* of the general type `forall a. [a] -> [a]' for `reverse'
10:53:08 <ski> PTBD : do you follow that ?
10:53:13 <PTBD> yes
10:53:17 <ski> ok
10:53:43 <Clint> sm: no, i haven't had the time to add the (what should be pretty simple) auth glue to it
10:53:51 <ski> now, if we just look at an expression, it might not be obvious immediately what the actual instance of a *use* of some polymorphic thing is
10:54:07 <sm> nod
10:54:42 <ski> (remember, things which have types which start with `forall's (iow universal types) are *polymorphic* things. e.g. `reverse' is a polymorphic function, and `Nothing' is a polymorphic (non-function) value)
10:54:46 <ski> @type Nothing
10:54:47 <lambdabot> Maybe a
10:55:11 <ski> so, we had
10:55:13 <ski>   (.) :: forall a b c. (b -> c) -> ((a -> b) -> (a -> c))
10:55:16 <ski>   concat :: forall a. [[a]] -> [a]
10:55:22 <ski> and we wanted to consider the expression
10:55:23 <identity> why on earth is gitit2 library all in one file? :|
10:55:27 <ski>   ((.) concat) concat
10:56:11 <ski> so, since we don't know yet what the actual instances are which will be used for the two `concat' occurances, we'll invent some "placeholder" names for the yet-unknown types
10:56:33 <ski> that's just so we can write *something* about the situation, even though we don't know all yet
10:56:55 <ski> and, i'll also do that for `(.)', since we don't know either at which instance it will be used
10:56:58 <ski> so
10:57:31 <ski>   (.) :: (_b0 -> _c0) -> ((_a0 -> _b0) -> (_a0 -> _c0))  -- for the first (only) use of `(.)'
10:57:45 <sm> identity: maybe he got tired of rummaging around in a zillion files ?
10:57:53 <ski>   concat :: [[_a1]] -> [_a1]  -- for the first use of `concat'
10:57:58 <identity> ... okay then.
10:58:01 <ski>   concat :: [[_a2]] -> [_a2]  -- for the second use of `concat'
10:58:10 <augur> :t flip (.)
10:58:11 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:58:19 <PTBD> ski, I understand that a and a1 etc. are only placeholder for different types. that is not the problem
10:58:22 <sm> I imagine if/when it grows larger & more stable it'd be split up some
10:58:52 <augur> i like that both co- and contra-variant hom functors have such a simple relationship
10:58:56 <ski> PTBD : my `_a0',`_b0',`_c0',`_a1',`_a2' are my placeholder types, that we can think of as in the end standing for `Integer' or `[Char]' or other concerete types
10:58:59 <ski> PTBD : ok
10:59:01 <augur> fmap = (.)   cofmap = flip (.)
10:59:08 <augur> as it should be
10:59:14 <ski> now we look at the actual expression again
10:59:18 <ski>   ((.) concat) concat
10:59:24 <ski> let's focus first on the part
10:59:27 <ski>   (.) concat
10:59:43 <Soft> I there someway to see all packages in hackage that depend on a certain package
10:59:47 <Soft> Is*
11:00:13 <ski> PTBD : we know : if `f :: tau0 -> tau1' and if `e :: tau0', then `f e :: tau1', for any expressions `f',`e' and types `tau0',`tau1'
11:00:34 <ski> PTBD : in the case `(.) concat', this `f' corresponds to `(.)', and `concat' corresponds to `e'
11:00:40 <Soft> I was just thinking It would be a good way to see some actual uses for stuff
11:01:05 <ski> PTBD : so since `(.) :: (_b0 -> _c0) -> ((_a0 -> _b0) -> (_a0 -> _c0))', `tau0' corresponds to `(_b0 -> _c0)', and `tau1' corresponds to `(_a0 -> _b0) -> (_a0 -> _c0)'
11:01:18 <ski> PTBD : and the rule says that `f e :: tau1', iow that
11:01:25 <pavonia> @where revdeps
11:01:25 <lambdabot> http://packdeps.haskellers.com/reverse
11:01:27 <ski>   (.) concat :: (_a0 -> _b0) -> (_a0 -> _c0)
11:01:30 <ski> PTBD : ok, so far ?
11:01:34 <pavonia> Soft: ^
11:01:41 <PTBD> yes
11:01:52 <Soft> thanks
11:02:07 <ski> PTBD : however, this only holds if also `e :: tau1', i.e. in our case `concat :: _b0 -> _c0'
11:02:33 <ski> PTBD : however, we already know that *this* `concat' is supposed to have the type `concat :: [[_a1]] -> [_a1]'
11:03:24 <ski> PTBD : iow, for this to work out, we must require that the "actual parameter type" `[[_a1]] -> [_a1]' and the "formal parameter type" (coming from the function type) `_b0 -> _c0' are *equal* :
11:03:33 <ski>   _b0 -> _c0  =  [[_a1]] -> [_a1]
11:04:01 <ski> however, this equation can only be true in case the following two equations are true :
11:04:07 <ski>   _b0  =  [[_a1]]
11:04:14 <ski>   _c0  =  [_a1]
11:04:29 <ski> so, what do we know so far ?
11:04:51 <ski>   (.) :: (_b0 -> _c0) -> ((_a0 -> _b0) -> (_a0 -> _c0))  -- only occurance
11:04:55 <ski>   concat :: [[_a1]] -> [_a1]  -- first occurance
11:05:06 <ski>   concat :: [[_a2]] -> [_a2]  -- second occurance
11:05:18 <ski>   (.) concat :: (_a0 -> _b0) -> (_a0 -> _c0)
11:05:25 <ski>   _b0  =  [[_a1]]
11:05:29 <ski>    _c0  =  [_a1]
11:06:27 <ski> now, since both these two equations have a single variable on one of their sides, we can "replace equals for equals" simplifying the situation a bit, so that we don't have to bother about those variables and equations anymore :
11:07:07 <ski>   (.) :: ([[_a1]] -> [_a1]) -> ((_a0 -> [[_a1]]) -> (_a0 -> [_a1]))  -- only occurance
11:07:16 <ski>   concat :: [[_a1]] -> [_a1]  -- first occurance
11:07:22 <ski>   concat :: [[_a2]] -> [_a2]  -- second occurance
11:07:41 <ski>   (.) concat :: (_a0 -> [[_a1]]) -> (_a0 -> [_a1])
11:07:46 <ski> PTBD : ok, so far ?
11:08:02 <PTBD> hold on
11:08:09 * ski holds on
11:09:01 <PTBD> ok I guess
11:09:07 <ski> ok
11:09:24 <ski> so now we go back to considering
11:09:30 <ski>   ((.) concat) concat
11:09:43 <ski> we have already considered the application of `(.)' to `concat'
11:09:54 <dhrosa> is there a notion of Reader for multi-arg functions?
11:10:07 <ski> now we must consider the other application in the expression, the application of the result of the above application, to `concat'
11:11:14 <ski> PTBD : so, as before, we match `((.) concat) concat' with the general pattern `f e', matching the types `tau0 -> tau1',`tau0' to their concrete types here `(_a0 -> [[_a1]]) -> (_a0 -> [_a1])',`[[_a2]] -> [_a2]'
11:11:18 <ski> as before, we get
11:11:33 <ski>   ((.) concat) concat :: _a0 -> [_a1]
11:11:36 <jle`> dhrosa: elaborate?
11:11:47 <ski>   _a0 -> [[_a1]]  =  [[_a2]] -> [_a2]
11:11:59 <ski> this latter equation simplifies to
11:12:05 <ski>   _a0  = [[_a2]]
11:12:13 <ski>   [[_a1]]  =  [_a2]
11:12:24 <ski> the latter of these simplifies to
11:12:35 <ski>   [_a1]  =  _a2
11:12:52 <ski> so, the new information added here is then
11:12:55 <ski>   ((.) concat) concat :: _a0 -> [_a1]
11:13:00 <ski>   _a0  = [[_a2]]
11:13:06 <ski>   _a2  =  [_a1]
11:14:05 <ski> PTBD : as before, both of these equations have a variable on one of their sides, so we replace `_a0' everywhere with `[[_a2]]' and `_a2' everywhere with `[_a1]', in all the preceding knowledge, getting :
11:14:47 <ski>   (.) :: ([[_a1]] -> [_a1]) -> (([[[_a1]]] -> [[_a1]]) -> ([[[_a1]]] -> [_a1]))  -- only occurance
11:14:51 <ski>   concat :: [[_a1]] -> [_a1]  -- first occurance
11:15:06 <ski>   concat :: [[[_a1]]] -> [[_a1]]  -- second occurance
11:15:30 <ski>   (.) concat :: ([[[_a1]]] -> [[_a1]]) -> ([[[_a1]]] -> [_a1])
11:15:46 <ski>   ((.) concat) concat :: [[[_a1]]] -> [_a1]
11:15:57 <ski> PTBD : ok, so far ?
11:16:02 <PTBD> jup
11:16:14 <ski> at this point, we have considered *every* construct in the expression
11:16:35 <ski> we started by generating fresh/new instances for each identifier occurance, `(.)',`concat',`concat' in the expression
11:17:10 <ski> then we went on by considering every other expression construct combining those into the whole expression, in this case there were only applications (apart from the identifiers)
11:17:36 <ski> taking care to introduce type equations for each application, and simplifying the equations
11:17:57 <ski> (if you prefer, you can simplify the equations at the end instead of along the way -- though it's probably more work)
11:18:17 <ski> if we had at any time got an equation like
11:18:31 <ski>   Maybe _a3  =  [_a2] -> _a4
11:18:41 <ski> then this would have meant there was a type error
11:19:04 <ski> in this case there was no equations with no solutions, so no such type errors
11:19:39 <ski> PTBD : what we now know is that, for *any* type that we replace `_a1' with, our expression *can* have the type `[[[_a1]]] -> [_a1]'
11:19:56 <ski> e.g. it can have type `[[[Integer]]] -> [Integer]' if we like
11:20:13 <ski> alternatively it can have type `[[[[Char]]]] -> [[Char]]', if we prefer
11:20:34 * hackagebot yocto 0.1.1 - A Minimal JSON Parser & Printer for Haskell  http://hackage.haskell.org/package/yocto-0.1.1 (ajg)
11:20:45 <ski> this is because `_a1' here is unconstrained (there's e.g. no equation or other thing adding a constraint on what type it could possibly be)
11:21:13 <PTBD> this process is almost too long for the few points I get.
11:21:34 <PTBD> but this was an excellent answer to my question
11:21:43 <ski> PTBD : so, as a final step, we can now *generalize* this type *schema* (/ template) to a universal type, by replacing each of the remaining placeholders by a (proper) type variable, and reintroduce a `forall' for each one of them (here only one) :
11:21:56 <ski>   ((.) concat) concat :: forall a. [[[a]]] -> [a]
11:22:36 <ski> PTBD : yes, in practice (if you do it on paper or in head) you can skip most of the details -- but i wanted to show all the details, for completeness, so you can grok the process
11:23:29 <PTBD> but making it in the head or paper I got the wrong solution every time. I understand why now and it seems very easy in this case.
11:24:01 <ski> one key thing which i suspect newbies often forget is to make a *separate* instance for each occurance
11:24:44 <ski> also, one should systematically check *every* construct in the expression, from the identifiers and literal constants, up through all applications and possible other constructs (like `if'-`then'-`else')
11:25:26 <ski> PTBD : i hope this helped
11:25:38 <PTBD> it did
11:25:52 <PTBD> thank you alot
11:25:58 * ski bows
11:26:11 * PTBD claps
11:26:26 <PTBD> ^^
11:28:10 <mm_freak> jle`: well, in principle, when you use FRP, you don't need ids
11:29:20 <jle`> mm_freak: yeah, that's how I "feel"
11:29:38 <jle`> but sometimes i can't conceive a way around it
11:29:49 <jle`> is it worth trying to restructure in order to be free of id's?
11:30:18 <etandel> If I have a pure computation, does haskell somehow caches / memoizes the result if I call the same computation multiple times on the same (pure) function?
11:30:25 <jle`> i guess my question is if it's a normal thing to do and something worth not worth avoiding, or if it's as un-frp as i feel it is so i should put in effort to avoid it
11:31:03 <jle`> etandel: if it's a constant value, then it's like an evaluated thunk.  if it's a function...no, haskell doesn't do ad-hoc memoization
11:31:24 <magneticduck> hey guys, is there an easy way to get lambdabot to join a new channel?
11:31:34 <shachaf> etandel: No.
11:31:39 <jle`> magneticduck: besides compiling and running him/her yourself?
11:31:53 <etandel> so something like `sum myList` is not memoized? Hmmm. Ok, then. Thanks, jle` and shachaf
11:31:54 <shachaf> If you write let x = ... in (x,x) the ... will be evaluated at most once.
11:32:07 <shachaf> magneticduck: Run your own lambdabot.
11:32:25 <magneticduck> shachaf: kk
11:32:32 <jle`> ad-hoc probably wasn't the right word
11:32:39 <magneticduck> it's just that I've seen lambdabot in a few other small channels
11:32:49 <etandel> shachaf: that's what I'm doing, but I got curious if ghc was able to make that optimization. Thx anyway! =D
11:32:59 <magneticduck> I was just wondering how it got there...
11:33:04 <magneticduck> shachaf: how do they do that?
11:33:12 <magneticduck> for instance, lambdabot is joined to #tanuki
11:33:25 <magneticduck> the real lambdabot, not another instance
11:33:47 <shachaf> magneticduck: By justifying it to the person running lambdabot.
11:34:02 <shachaf> etandel: It isn't just a question of being able to, but of whether it's a good idea.
11:34:28 <mada> magneticduck: lambdabot is cool to be accessible even when offline
11:34:33 <magneticduck> shachaf: alright, just wondering if it was a built-in feature
11:34:49 <magneticduck> I mean, joining other channels via a command
11:34:53 <shachaf> It's a built-in feature to be in multiple channels that an administrator has asked it to join, yes.
11:35:57 <mm_freak> jle`: at this point perhaps i should tell you that all the important monads and arrows in FRP are MonadFix or ArrowLoop =)
11:36:17 <mm_freak> jle`: in netwire Wire is an ArrowLoop and in reactive-banana Moment is a MonadFix
11:36:45 <mm_freak> so things can indeed refer in all directions, including to each other (value recursion)
11:40:36 * hackagebot linux-inotify 0.1.0.1 - Thinner binding to the Linux Kernel's inotify interface  http://hackage.haskell.org/package/linux-inotify-0.1.0.1 (LeonSmith)
11:41:41 <jle`> mm_freak: so i have two collections interacting with eachother, possibly destructive.  i'm implementing this as both collections are wires that take the output of the other and yield the processed version of themselves.  but i also one one collection to be able to destroy an item in the other.  i was thinking of then the arrow outputting not just the processed version of itself, but also a list of 'signals'
11:41:42 <jle`> to send to the other collection to tell it which ones to destroy
11:41:48 <jle`> if...i'm making any sense.
11:42:29 <napping> In shake, is there any way to test if a target name is phony?
11:42:48 <jle`> but i can't coordinate how to have one collection tell the other collection to destroy something without either giving it full access to modify the other selection, or to output a list of 'destroy this' signals for the other to take in and process internally
11:45:44 <mm_freak> jle`: collection A wants to delete stuff from collection B
11:46:02 <mm_freak> one way is to let B take an Event (Collection -> Collection) from A
11:46:06 <jle`> mm_freak: yes...and i don't want to give it full access to modify collection B as much as it wants
11:46:37 <jle`> and the destruction events need to be cleaned-up and post-processed...preferably by collection B's wire
11:46:47 <mm_freak> sure
11:46:50 <jle`> if that even makes sense to organize that way
11:46:59 <jle`> hm. okay, go on
11:47:22 <jle`> i'm still trying to internalize events in my mental frameworks
11:47:40 <mm_freak> haskell's answer to "not free access" is a quantified type variable
11:47:44 <jle`> so A would emit a tuple of the updated A and an Event (Collection -> Collection) ?
11:48:02 <jle`> mm_freak: is that that data Foo = forall a. trick?
11:48:10 <mm_freak> no, that's existential
11:48:20 <mm_freak> newtype CollMap f = CollMap (forall a. f a -> f a)
11:48:35 <mm_freak> change stuff in 'f' without looking at the values
11:49:44 <jle`> hm
11:49:46 <jle`> okay
11:50:23 <jle`> so to make a CollMap, you specify a function that takes an f a to another f a?
11:50:35 <jle`> and that would be what your Event contains?
12:03:28 <Zhaoliang> hi
12:03:29 <markovirc> Hello Zhaoliang
12:03:34 <Zhaoliang> hi, mark
12:03:35 <markovirc> Hello Zhaoliang
12:04:01 <Zhaoliang> do you know how to write union-find in haskell
12:05:39 * hackagebot HaRe 0.7.1.1 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.1 (AlanZimmerman)
12:07:12 <identity> Is it possible to put a typeclass constraint on a parametrized ADT?
12:07:21 <identity> data Foo a => Bar a = ..
12:07:21 <bergmark> @hackage union-find -- maybe like this Zhaoliang? :)
12:07:21 <lambdabot> http://hackage.haskell.org/package/union-find -- maybe like this Zhaoliang? :)
12:08:28 <bergmark> identity: https://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why
12:08:49 <identity> aah
12:09:01 <identity> so I need GADTs
12:09:02 <identity> I see.
12:10:40 * hackagebot yocto 0.1.2 - A Minimal JSON Parser & Printer for Haskell  http://hackage.haskell.org/package/yocto-0.1.2 (ajg)
12:11:04 <piezoid> hi
12:11:05 <markovirc> Hello piezoid
12:11:38 <piezoid> i'm trying to derive the Church encoding for free categories
12:12:22 <piezoid> i started with http://lpaste.net/99141
12:13:35 <piezoid> but i got stuck for the definition of (.)
12:13:38 <klrr_> what is the best style for let's? "let foo = bar in\nexpr" or "let foo = bar\nin expr"?
12:15:39 <klrr_> i go with the former
12:15:43 <path[l]> klrr_: next line, since there can be more than one let
12:17:22 <klrr_> path[l]: true, although the former lets you save space
12:18:15 <path[l]> *shrug*
12:18:49 <Hildar> Hmm, why does my memory usage still climb when I recurse (using a tail-call)? Is that normal? http://pastebin.com/tzynLYvV
12:19:14 <klrr_> i got some problems with html-blaze, i currently cant change a AttributeValue and not sure what it want me to do, http://lpaste.net/99142 . basically i got a String and it wants a AttributeValue but everywhere else i do *essentiall* the same but in this case it doesnt work, any ideas?
12:20:47 <BrianHV> klrr_: with OverloadedStrings, double-quoted string literals look like String values, but they're probably implicitly converted to something else
12:20:57 <dhrosa> I'm designing a simulator program, and one piece of hardware  I'm simulating is memory. I want to be able to randomly access it, so a vector would be preferrable there, but I will also be very frequently generating a new copy of the memory with only 1-2 elements modified, in which case a  list would be  better
12:21:02 <dhrosa> what should  I  do?
12:21:16 <dhrosa> or do Vectors share state between copies?
12:21:29 <BrianHV> klrr_: if you explicitly convert the string value l to an AttributeValue, it should work. I don't know offhand how to do that, but it's probably pretty simple.
12:21:40 <klrr_> how do i do that though?
12:22:37 <BrianHV> klrr_: a glance at the docs suggests fromString l should do it
12:22:49 <BrianHV> http://hackage.haskell.org/package/blaze-html-0.1/docs/Text-Blaze.html#t:AttributeValue
12:22:50 <klrr_> aa, thanks a lot!
12:23:19 <klrr_> aa i wondered what that instance was for :3
12:23:32 <dhrosa> from the docs  it seems every update will be O(n)
12:24:13 <bergmark> klrr_: tip: OverloadedStrings
12:24:57 <bergmark> oh BrianHV already said that :3
12:25:16 <mm_freak> jle`: yes
12:27:34 <supki> Hildar: it's not really a tail call (hint: desugar do-notation) but memory usage shouldn't increase anyway
12:29:45 <jle`> mm_freak: how would i emit/use these events in the proc blocks for an individual Collection?
12:30:14 <jle`> without using Event.Internal stuff
12:30:18 <Hildar> supki Ah, the desugaring make sense. Memory usage definately climbs though, if I restrict the heap size to something low like 16k it allows only a few connections then dies with OOM.
12:30:26 <dhrosa> maybe I want to use a map instead?
12:30:30 <jle`> er, Unsafe.Event
12:30:54 <dhrosa> as a middleground between fast-access and uneccessary copies?
12:32:03 <dhrosa> I also purposely want to keep the previous states of the memory, so I can't just use a mutable vector
12:34:29 <identity> aeson is god damn beautiful
12:34:54 <bergmark> it has some ugly parts :-(
12:38:47 <bergmark> it bugs me that encode (1::Int) = "1", but decode "1" :: Maybe Int = Nothing
12:45:45 <pavonia> bergmark: That actually a bug, IIRC
12:45:46 <augur> anyone interested in starting a conor mcbride reading group?
12:45:50 <pavonia> *That's
12:46:49 <jle`> pavonia: i think there was an intentional decision to only allow decoding arrays and objects?
12:47:23 <pavonia> Hhm, not sure
12:47:25 <bergmark> but encoding it shouldn't be valid either then
12:47:42 <bergmark> the json spec only allows arrays and objects at the top level
12:49:29 <bergmark> i'd be happiest if they were allowed both ways
12:49:50 <int-e> pavonia: it's documented behavior
12:49:52 <path[l]> why does the json spec only allow arrays and objects at the top level
12:49:57 <path[l]> I've never understood the reason for that
12:49:59 <mm_freak> jle`: to construct your own events you need to access the Event constructors…  the most important rule is to remember that events are discrete
12:50:06 <bergmark> path[l]: i don't know if there is a reason
12:50:22 <mm_freak> jle`: in other words, it's wrong to have a stream of Event, but it's not wrong to have a stream of NoEvent with occasional Event
12:50:41 <napping> bergmark: it does make well-formed JSON self-delimiting
12:50:45 * hackagebot acme-cutegirl 0.1.0.0 - Maybe gives you a cute girl  http://hackage.haskell.org/package/acme-cutegirl-0.1.0.0 (MateuszKowalczyk)
12:50:58 <mm_freak> jle`: your intuition is probably enough to do the right thing
12:51:54 <napping> I think edwardk has some fancy parsing scheme taking advantage of that, actually
12:53:49 <jle`> mm_freak: got it. was just a little scared by the Unsafe label and was under the impression that only...engines/frameworks should use them and applications should never have to
12:54:29 <mm_freak> jle`: you are now an engine/framework developer =)
12:54:45 <mm_freak> jle`: usually you would try to construct events from the existing primitives
12:55:12 <mm_freak> the Unsafe stuff is used to connect netwire to e.g. toolkits
12:55:44 <bergmark> almost shipped broken code today because the type checker didn't catch my invalid top level json :-(
12:55:45 * hackagebot acme-cutegirl 0.2.0.0 - Maybe gives you a cute girl  http://hackage.haskell.org/package/acme-cutegirl-0.2.0.0 (MateuszKowalczyk)
12:55:53 <mm_freak> jle`: the rule of thumb is:  if you use one of the mk* functions, you probably need the unsafe event API as well
12:56:07 <mm_freak> if you don't use mk*, then you should think twice before using Unsafe
12:57:55 <greg`> ok i see the bar is set very low for entry into hackage
12:58:21 <joelteon> there is no bar, except for registration
12:58:22 <geekosaur> anything under Acme can generally be assumed a joke...
12:58:23 <catalyst> greg`: I was thinking that
12:58:31 <joelteon> greg`: the acme- prefix is for joke packages, also
12:58:36 <Clint> i don't get the joke
12:59:18 <jle`> mm_freak: thanks :) i'll play around with this
12:59:26 <geekosaur> it might be somewhat US specific... roadrunner and wyle e. coyote, coyote's nonfunctional traps and stuff are all branded ACME
12:59:33 <greg`> i think its an "in joke" for the author and his school friends
12:59:36 <geekosaur> but I suspect we got the acme for jokes prefix from perl
12:59:42 <joelteon> yeah, it's a perl thing
13:00:03 <joelteon> People get pretty upset about Acme packages, I'm not really sure why
13:00:04 <geekosaur> (cpan has a large and thriving Acme:: joke hierarchy)
13:00:15 <Clint> no, i don't get the acme-cutegirl joke
13:00:24 <greg`> i wonder if we should introduce some form of rating system for libraries
13:00:30 * geekosaur doesn't either but that's another issue
13:01:08 <bergmark> greg`: that's coming on hackage
13:01:12 <geekosaur> (actually, I sort of do "get" it, in the sense that I know all too well there are programmers who think it's funny)
13:01:43 <catalyst> I get it, but I also feel a little frustrated at the objectification
13:01:43 <jrmithdobbs> they're typically not people you want to remember exist
13:02:03 <mm_freak> my favorites are acme-dont, acme-php and acme-schoenfinkel
13:02:04 <greg`> i thought he was just making fun of some non-cute girl he and his buddies know
13:02:31 <geekosaur> enh, it's fine to be a 12 year old... as long as you grow out of it
13:02:34 <mm_freak> > let unschön = uncurry in unschön (/) (3, 5)
13:02:35 <lambdabot>  0.6
13:02:52 <joelteon> I think acme-schoenfinkel is pretty clever
13:02:54 <jrmithdobbs> geekosaur: i met none of said people until long after i and they were not 12 yos :P
13:03:03 <joelteon> acme-cutegirl is some anime in-joke, I think
13:03:15 <geekosaur> exactly
13:03:15 <greg`> bergmark glat to hear it, there are new libraries being added constantly on hackage i made the mistake of subscribing to the hackage twitter feed
13:03:20 <joelteon> just checked the source
13:03:44 <mm_freak> hässlich :: Schoenfinkel cat => cat a (cat b c) -> cat (a, b) c
13:03:48 <mm_freak> "Another appropriate name for 'uncurry'/'unschoen'." =)
13:03:59 <jle`> foldl' f b xs = xs `seq` foldl f b xs
13:04:08 <jle`> sounds legit
13:04:08 <dart> hi
13:04:12 <jle`> hi dart
13:04:18 <markovirc> Hello dart
13:04:49 <dart> i'm trying to pass CB.sinkFile to forkExecuteFile
13:04:50 <dart> http://hackage.haskell.org/package/unix-process-conduit-0.2.2.2/docs/Data-Conduit-Process-Unix.html
13:04:51 <greg`> . o  O (darts a popular guy)
13:05:10 <dart> popular ?
13:05:37 <jle`> markovirc is a bot i think
13:05:39 <shachaf> Fuuzetsu: Seriously?
13:05:42 <greg`> well known
13:06:11 <bergmark> greg`: oh they fixed it, it wasn't working for quite some tim
13:06:24 <dart> greg`: what do you mean ?
13:06:52 <greg`> dart no big deal everyone rushed in with the greets
13:06:58 <dart> greg`: ahhhh
13:07:00 <greg`> just an observation
13:08:54 <dart> btw, how i do this " Possible fix: add an instance declaration for (MonadResource IO)" ?
13:09:02 <joelteon> context?
13:09:11 <dart> yeah, sorry, http://hackage.haskell.org/package/unix-process-conduit-0.2.2.2/docs/Data-Conduit-Process-Unix.html
13:09:15 <dart> forkexecutefile
13:09:31 <dart> i'm trying to pass to stdout CB.sinkFile "/tmp/test"
13:09:54 <joelteon> Hang on, let me install that and try it
13:10:35 <dart> joelteon: ok
13:10:56 <epta> Why tuple is not a functor and why (+2) `fmap` (1,2) is not (3,4)?
13:11:19 <joelteon> @kind Functor
13:11:20 <lambdabot> (* -> *) -> Constraint
13:11:23 <joelteon> @kind (,)
13:11:24 <lambdabot> * -> * -> *
13:11:29 <joelteon> kind mismatch, epta
13:12:06 <pavonia> @kind Bifunctor
13:12:07 <jle`> also it'd only make sense for homogenious tuples
13:12:07 <lambdabot> (* -> * -> *) -> Constraint
13:12:26 <pavonia> > join bimap (+2) (1,2)
13:12:28 <lambdabot>  (3,4)
13:12:42 <napping> Partially applied tuples are functors, things can only be a functor in the last type argument
13:12:53 <epta> yep, got it
13:16:17 <joelteon> dart: not sure why sinkFile incurs a MonadResource constraint. as an alternative, you could use CB.sinkHandle, which uses MonadIO
13:16:25 <joelteon> dart: and pass sinkHandle an opened filehandle to /tmp/test
13:16:41 <dart> joelteon: got it
13:16:53 <dart> joelteon: thanks
13:18:52 <joelteon> not as pretty, but I think that's the only option
13:23:10 <jrmithdobbs> I don't understand why -XTupleSections requires an extension instead of being builtin for that syntax, (fmap ((,) a)) is just weird vs (fmap (a,))
13:23:28 <joelteon> jrmithdobbs: it's not in the haskell spec, afaik
13:24:09 <benmachine> yeah, just because something's an extension doesn't mean it's controversia
13:24:09 <benmachine> l
13:24:23 <benmachine> although tuplesections also enables things like (,a,) which are a bit weird
13:24:48 <jrmithdobbs> benmachine: why that's just flip (,,) a
13:25:07 <jrmithdobbs> why is it weird i mean
13:25:11 <benmachine> :t flip (,,) a
13:25:12 <lambdabot> a -> c -> (a, Expr, c)
13:25:22 <benmachine> it's different from other sections, at least
13:25:45 <joelteon> (+ a +) is invalid
13:26:05 <benmachine> right
13:27:37 <jle`> also why can't we infix partially applied functions
13:28:16 <jle`> 1 `id (+)` 2
13:28:31 <jle`> not partially applied but yea
13:29:13 <jle`> 'a' `comparing ord` 'b'
13:29:33 <shachaf> , is not an operator so everything involving it is a special case
13:29:40 <dwcook> I don't suppose there's a convenient way to pattern match against the first several characters of a string without doing 't':'h':'i':'s':rest?
13:30:03 <Rembane> dwcook: I think guards are more suitable for that.
13:30:10 <dwcook> Hmm, I could use a function that takes the prefix and the string and returns a pair
13:30:14 <Rembane> dwcook: Without knowing what you want to do of course.
13:30:21 <Rembane> dwcook: Indeed.
13:30:52 <dwcook> Maybe a pair, that is.
13:31:01 <jle`> maybe not?
13:31:10 <etandel> dwcook: it's called splitAt
13:31:42 <jle`> case splitAt 4 string of ("this",rest) ->
13:31:43 <etandel> splitAt 4 "123456..."  == ("1234", "56...")
13:32:20 <dwcook> That's not quite what I wanted, but I have a better idea what to do now. Thanks.
13:34:28 <dwcook> Okay, I've thought through the problem better – I'm accepting commands where the first word says what to do and the rest is a string the command needs. So I just need to split at the first space.
13:34:39 <yitz> let match str | "this" `isPrefixOf` str = "The rest is: " ++ drop 4 str; | otherwise = "Nope." in match "this one"
13:34:43 <yitz> > let match str | "this" `isPrefixOf` str = "The rest is: " ++ drop 4 str; | otherwise = "Nope." in match "this one"
13:34:45 <lambdabot>  <hint>:1:74: parse error on input `|'
13:35:03 <yitz> > let match str | "this" `isPrefixOf` str = "The rest is: " ++ drop 4 str | otherwise = "Nope." in match "this one"
13:35:04 <lambdabot>  "The rest is:  one"
13:35:04 <etandel> dwcook: then use words, I guess?
13:35:10 <dwcook> Yeah, maybe.
13:35:51 <jle`> there's also span
13:36:10 <jle`> > span (== " ") "hello world how are you"
13:36:11 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
13:36:11 <lambdabot>  Expected type: [[GHC.Types.Char]]
13:36:11 <lambdabot>    Actual type: [GHC.Types.Char]
13:36:14 <dwcook> Ah, yeah, that's what I was looking for
13:36:16 <dwcook> Thanks
13:36:19 <jle`> > span (== ' ') "hello world how are you"
13:36:20 <lambdabot>  ("","hello world how are you")
13:36:23 <jle`> oh
13:36:34 <ion> > let match str | ("this", xs) <- splitAt 4 str = xs | otherwise = "Nope" in match "this one"
13:36:34 <jle`> > span (/= ' ') "hello world how are you"
13:36:35 <lambdabot>  " one"
13:36:35 <lambdabot>  can't find file: L.hs
13:36:40 <dwcook> Oh, no it wasn't
13:36:55 <dwcook> Or… I'm confused
13:37:01 <jle`> what's going on lambdabot
13:37:02 <jle`> > span (/= ' ') "hello world how are you"
13:37:04 <lambdabot>  ("hello"," world how are you")
13:37:12 <jle`> i got snubbed :/
13:37:19 <ion> lambdabot is going on
13:37:35 <dwcook> Well that's indeed almost what I want. Just need to take off the space
13:37:58 <jle`> let (com:rest) = words "hello world how are you" in (com,unwords rest)
13:38:03 <jle`> > let (com:rest) = words "hello world how are you" in (com,unwords rest)
13:38:05 <lambdabot>  ("hello","world how are you")
13:38:09 <sleepynate> @faq did you snub jle` ?
13:38:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:38:15 <sleepynate> well then.
13:38:21 <etandel> lol
13:38:22 <dwcook> Haskell can snub jle`, apparently
13:38:25 <dwcook> It can snub anyone though :P
13:38:36 <jle`> what a sneaky dodge
13:38:48 <sleepynate> <3
13:38:53 <sleepynate> > <3
13:38:54 <lambdabot>  <hint>:1:1: parse error on input `<'
13:39:00 <etandel> Haskell is turing complete; snub is computable. Therefore, Haskell can snub.
13:39:01 <sleepynate> no love :(
13:39:02 <jle`> you need parentheses
13:39:04 <jle`> around sections
13:39:06 <jle`> :t (<3)
13:39:07 <lambdabot> (Num a, Ord a) => a -> Bool
13:39:23 <jle`> that's deep
13:39:24 <sleepynate> jle`: that makes the joke not nearly as funny
13:39:28 <sleepynate> :D
13:39:37 <jrmithdobbs> jle`: haha
13:39:44 <jle`> it makes it profound. what is the type of love?
13:39:46 <codygman> Does anyone know where I can find the library described here (or if I can): http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/integer_pt1.html
13:39:47 <napping> > (<3)>
13:39:48 <lambdabot>  <hint>:1:6:
13:39:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:39:49 <napping> > (<3)
13:39:51 <lambdabot>  <Integer -> Bool>
13:40:07 <napping> oh, it's got a working show. Well, ghci doesn't like that much either
13:40:19 <jle`> it's just from Typeable
13:40:26 <jle`> i have my ghci working the same way
13:40:53 <codygman> Also, does "build a custom libgmp with the -fno-common flag set. This library is needed for the Integer support in Haskell" still hold true when building static binaries for Haskell?
13:40:55 <jrmithdobbs> > :t ((<3)>)
13:40:56 <lambdabot>  <hint>:1:1: parse error on input `:'
13:41:04 <jrmithdobbs> :t ((<3)>)
13:41:05 <lambdabot> (Num a, Ord (a -> Bool), Ord a) => (a -> Bool) -> Bool
13:41:25 <jle`> instance (Typeable a, Typeable b) => Show (a -> b) where show f = typeOf f
13:41:43 <jle`> er, show. typeOf $ f
13:41:53 <etandel> "Dad, what is <3?" "Son, it's a function from an orderable number to a bool."
13:42:45 <colDrMcBeardman> etandel, what is 8=D ?
13:42:57 <Axman6> a face
13:43:05 <jle`> a very happy and wide-eyed face
13:43:27 <etandel> > :t 8-D
13:43:28 <lambdabot>  <hint>:1:1: parse error on input `:'
13:43:30 <etandel> > :t 8=D
13:43:31 <Platz> to be fair, a lot of these results come from the same repos (i.e. openglraw) but still a lot.  Does anyone actually use -XSafe ? github search: unsafePerformIO size:>10000 -> https://github.com/search?q=unsafePerformIO+size%3A%3E10000&ref=cmdform&type=Code
13:43:31 <lambdabot>  <hint>:1:1: parse error on input `:'
13:43:35 <etandel> nope, can't do
13:44:21 <jle`> Platz: there are uses of unsafePerformIO that don't break semantics
13:44:34 <jfeltz> other than stream-parsing, is there a way to order the warnings that GHC outputs on imported modules after the errors in the current module?
13:44:52 <jle`> oh, you'are asking about -XSafe?
13:45:13 <Platz> jle`: well i guess i did two things together
13:45:25 <Platz> but you point is good.  i guess if you're already in IO it doesn't matter much
13:45:43 <benmachine> Platz: -XSafe is pretty rarely used
13:45:51 <benmachine> it's a relatively recent invention
13:46:09 <benmachine> and kind of niche
13:46:23 <benmachine> it may well develop better as time goes on
13:46:31 <jle`> http://www.haskell.org/haskellwiki/Top_level_mutable_state
13:46:49 <maxiepoo> bleh
13:46:49 <Platz> but isn't that the point?  any random library could be unsafePerformIO'ing on you
13:47:10 <maxiepoo> is there a way to write Category using a type operator? I switched on TypeOperators
13:47:20 <maxiepoo> but `class Category (:->) where` doesn't work
13:48:00 <etandel> http://spl.smugmug.com/Humor/Lambdacats/i-8gBC6Wb/L
13:48:03 <napping> That's not a type operator name, operators starting with : are like identifiers starting with a capital letter
13:48:06 <jle`> maxiepoo: what are you trying to do?
13:48:19 <napping> only for concrete types / constructors.
13:48:27 <maxiepoo> I'm just trying to define a category typeclass that looks nice
13:48:29 <napping> Try class Category (~>) where ...
13:48:49 <maxiepoo> hm, (~>) gives the same error
13:48:59 <napping> well, that's a different error then
13:49:13 <maxiepoo> "Unexpected type (~>) where type variable expected
13:49:15 <maxiepoo> "
13:49:44 <Aetherspawn> nominolo: ping
13:50:26 <maxiepoo> guess I can't do it :/
13:51:01 <jle`> that's interesting
13:52:23 <napping> I suppose you have to declare it without an operator, which is weird
13:52:42 <napping> you should still be able to use an operator as the type variable when you use the class as a constraint
13:52:54 <shachaf> maxiepoo: Nope, operators can't be used as type variables anymore.
13:52:59 <shachaf> As of GHC 7.something.
13:53:06 <benmachine> yeah, I was sad when that happened
13:53:20 <maxiepoo> shachaf: do you have a link to some reasoning behind that?
13:53:23 <napping> Is that what happened? I've got 7.6 here
13:53:45 <maxiepoo> or was it just a style choice
13:53:55 <shachaf> Here's conal being unhappy about it: http://www.haskell.org/pipermail/glasgow-haskell-users/2012-September/022845.html
13:54:17 <shachaf> I think the idea was that people want lots of type things like (+) without prefixing them all with :
13:54:17 <napping> and the 7.6.3 user's guide still claims it works, but it doesn't seem to
13:57:33 <shachaf> You can still define class Category k where (.) :: b `k` c -> a `k` b -> a `k` c
13:57:37 <shachaf> But it's probably not worth it.
13:57:47 <shachaf> k b c -> k a b -> k a c is not so bad
13:59:37 <maxiepoo> ah k is a good single letter choice
13:59:40 <maxiepoo> I was using cat
13:59:47 <Twey> grohne: Right, Haskell would need termination-checking to be actually consistent, but you can tacitly agree to only write terminating programs and everything's okay (although that particular example would be hell to actually use because you'd need to convince it what types to use in the foralls and we don't have explicit type application; a more practical implementation would use singletons more to allow
13:59:49 <Twey> passing of arguments).
14:00:00 <shachaf> cat is fine too
14:00:03 <Twey> grohne: It's actually a direct translation from the Agda
14:00:06 <shachaf> Just don't use 'a' :-(
14:00:14 <maxiepoo> haha of course not
14:00:15 <Twey> grohne: There's nothing like agda-mode for Haskell yet.
14:00:19 <dwo> whois dwo
14:01:16 <Twey> grohne: You can probably do the same thing without most of the extensions (ask Oleg :þ) but that's a lot more pain than I'm willing to go through for a random IRC discussion :þ
14:13:26 <athan> Are there any good libraries out there for simple video processing?
14:13:42 <athan> I just want to take a video and clip-out portions of it.
14:14:17 <acowley> @hackage hs-ffmpeg
14:14:17 <lambdabot> http://hackage.haskell.org/package/hs-ffmpeg
14:14:54 <acowley> You *might* be able to get easy-mode ffmpeg bindings through OpenCV, but that could be a little fragile
14:15:21 <acowley> I do all my programatic video editing with Haskell doing frame-by-frame things and ffmpeg to tie it all together
14:15:33 <athan> awesome!!! Thank you!
14:15:35 <athan> wow!!!
14:15:54 * hackagebot wai-session 0.1.1 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.1.1 (StephenWeber)
14:16:54 <athan> have you ever toyed with gstreamer?
14:17:39 <Kinnison> Anyone here an MVar guru?  I'm trying to determine the correct way to have an MVar which contains a list of strings (updated in one thread, consumed in another) such that the computation always happens in the thread which updates the mvar
14:19:45 <misterbee> dhrosa it's a hard question, there are tradeoffs . Discussion at http://www.haskell.org/haskellwiki/Arrays For example, do you want persistence of each version of memory (for running a simulation backwards, perhaps)? or are destructive updates in ST or IO OK?
14:19:45 <Axman6> Kinnison: do you need to write to the end and read from the front?
14:19:46 <Twey> Kinnison: Force it first?  But if you're updating a list in an MVar, you might want a Chan instead
14:20:15 <dhrosa> misterbee: yes, I want to be able to run it backwards
14:20:23 <Kinnison> I am not trying to run a channel
14:20:27 <Kinnison> I want an MVar [String]
14:20:41 <dhrosa> misterbee: so I want persistence of each version
14:20:47 <Axman6> Kinnison: we're asking because we're not sure you do want that ;)
14:20:52 <Kinnison> The writer may update some or all of the strings
14:20:58 <Kinnison> the reader wants to snapshot the content of the list
14:20:59 <Axman6> ok
14:21:13 <Axman6> Kinnison: does it matter if the reader misses some information?
14:21:24 <misterbee> I tried DiffArray once, but got burned by http://trac.haskell.org/diffarray/ticket/2
14:21:33 <Twey> Kinnison: I did say ‘might’; if you're updating the whole thing at once, you probably don't want a Chan.  But like I said, you can just force the list before you store it.
14:21:33 <Kinnison> Axman6: No, it doesn't matter if the reader misses updates
14:22:01 <misterbee> I think the Array interface is clean enough that you can just pick one and get to work, and try swapping out backends for comparison
14:22:01 * Kinnison was thinking it should be a Control.Concurrent.MVar.Strict which seems to place NFData a => constraints on things
14:22:10 <Axman6> Kinnison: then an IORef would be more suitable.
14:22:20 <Kinnison> does that sound right?  (I'm not yet au-fait on forcing computation etc yet)
14:22:58 <Kinnison> Axman6: I'm using MVars for other things which serialise operation, so I figured on only learning one API :-)
14:24:36 <dhrosa> that seems kind of bad
14:24:55 <Axman6> well, they're all quite simple interfaces. IORefs are like ordinary mutable references. MVars are a box which is either empty or full, and blocks if you try to fill a full one or empty and empty one. there's some overhead associated with that of course, which is why an IORef is better if you don't need blocking
14:25:31 <Twey> Kinnison: That sounds right
14:25:58 <Kinnison> Axman6: I see, hmm
14:26:08 <Kinnison> Axman6: I guess I should learn IORef anyway :-)
14:26:21 <Kinnison> Twey: cool, it's nice to know I'm not going completely mad -- even if I can't formulate good questions tonight
14:26:27 <benmachine> Kinnison: atomicModifyIORef' sounds like it might be interesting for you
14:26:31 <Twey> The problem with using an iIORef is that you don't know when it changes, so not only do you miss some updates, you might end up storing (or checking for equality) a lot of copies of the same thing
14:26:33 <benmachine> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-IORef.html
14:26:43 <tom212> Suppose I have a bytestring that represents a struct (e.g. first 2 bytes are an Short, next 4 bytes are an ascii string, next byte is a byte), how can I decode/deserialise this to be a datatype?
14:26:55 <Kinnison> Twey: I have reasonably well defined reader/writer semantics, with individual threads in each place
14:26:59 <Axman6> thats a good point Twey
14:27:00 * Kinnison now wants to work out how to kill threads
14:27:00 <Twey> tom212: Using binary/cereal/whatever serialization library is cool this week
14:27:18 <tom212> Twey: Thanks. I'll look at those, and consult hackernews for the latest cool thing!
14:27:44 <Twey> Kinnison: You can pass a ‘kill channel’ that ends the thread when it's written to, or you can use throwTo to raise an exception inside the thread
14:27:48 <Axman6> hackernews won't know
14:28:06 <Axman6> or killThread
14:28:12 <Axman6> @hoogle killThread
14:28:12 <Twey> killThread is GHC-only
14:28:13 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
14:28:13 <lambdabot> GHC.Conc.Sync killThread :: ThreadId -> IO ()
14:28:13 <lambdabot> GHC.Conc killThread :: ThreadId -> IO ()
14:28:22 <Twey> (and it's just a special case of throwTo anyway)
14:28:33 <novochar> > x = 1; main = do putStrLn show x
14:28:34 <lambdabot>  <hint>:1:3: parse error on input `='
14:28:42 <Kinnison> I'm fine with GHC-only tbf
14:28:43 <novochar> > x = 1; putStrLn x
14:28:44 <lambdabot>  <hint>:1:3: parse error on input `='
14:28:47 <benmachine> Twey: what Haskell implementation are you worried about leaving out in the cold, exactly? >_>
14:28:49 <novochar> > let x = 1; putStrLn x
14:28:50 <Kinnison> This is for my own delight and edification right now
14:28:51 <lambdabot>  <hint>:1:22:
14:28:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:29:00 <novochar> > let x = 1; putStrLn show x
14:29:01 <lambdabot>  <hint>:1:27:
14:29:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:29:04 <Twey> benmachine: All those Hugs-users out there
14:29:11 <benmachine> Twey: do they even have actual threads?
14:29:17 <Twey> benmachine: No :þ
14:29:17 * Kinnison wonders if a thread stopped in takeMVar can be killThread'd
14:29:17 <Axman6> novochar: read the errors instead of blindly filling the channel :\
14:29:17 <geekosaur> novochar: lambdabot is not ghci
14:29:25 <benmachine> Kinnison: it can
14:29:43 <henk> I’m trying to use http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson.html to parse some json. At one point I have "Value"s. AFAIU a Value can be one of Object, Array, String, etc. What I don’t understand is how to use them as such when I just have them as a Value. I’m probably missing principle about types or something. Does anyone understand what I mean or is even able to point me in the
14:29:45 <henk> right direction?
14:29:45 <benmachine> or thrownTo, to abuse grammar slightly
14:29:50 <Kinnison> benmachine: ta
14:29:55 <Twey> I'm not really bothered by it in practice, but if there's a non–implementation-specific version of something that requires perhaps one more argument in the call, I'd probably choose that instead on principle
14:30:03 <novochar> I expect this to work, but I guess I have a misunderstanding of what type show is expecting? I want to putStrLn a number, I figure I can use show to obtain the string representation of whichever number I want to display
14:30:07 <Kinnison> And final annoying question (for a while) -- can I determine if a thread is still alive easily?
14:30:13 <benmachine> Twey: but if that's all it takes then when another implementation comes along it will just support that thing
14:30:29 <benmachine> Twey: surely the only things worth being principled about are the exotic things that might be /hard/ to implement, like TH
14:30:30 <Axman6> > let x = 1 in putStrLn (show x) -- novochar
14:30:30 <Twey> benmachine: And that's how the Web happens :þ
14:30:31 <lambdabot>  <IO ()>
14:30:33 <novochar> Axman6: I'm not going to blindly fill the channel, I just want whoever happens to help me see what I'm trying to do
14:30:59 <Axman6> novochar: well, ask a question instead of abusing lambdabot
14:31:02 <geekosaur> henk: a top level JSON value must be an aggregate? http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson.html#g:6
14:31:19 <benmachine> Twey: except that killThread is objectively a better idea than <marquee> :P
14:31:30 <frxx> novochar note that print already does this for you
14:31:33 <frxx> @src print
14:31:33 <lambdabot> print x = putStrLn (show x)
14:31:52 <triliyn> novochar: "putStrLn show x" is "(putStrLn show) x"
14:32:04 <triliyn> Because function application is left-associative
14:32:09 <Twey> benmachine: I'm not so sure about that
14:32:23 <napping> Kinnison: the Control.Concurent documentation mentions things
14:32:25 <benmachine> Twey: I'm so sure about that
14:32:27 <Twey> I hate exceptions, and *asynchronous* exceptions even more
14:32:40 <Twey> Personally, I'd just pass an MVar in
14:33:03 <novochar> Ah, it was the parens, I needed putStrLn (show x), thanks frxx for pointing out print
14:33:07 <Kinnison> napping: I'm currently suffering from my computer having a control.concurrent which lacks forkFinally so I'm worried about the docs a little
14:33:10 * Kinnison pokes it more
14:33:23 <Twey> novochar: It's putStrLn . show actually
14:33:28 <benmachine> ok, *but* (a) async exceptions are useful to interrupt blocking operations, (b) you already have throwTo, so building killThread on top of that is obviously sensible, (c) putting chilli powder in your eyes is still a better idea than <marquee>
14:33:28 <Twey> Er, triliyn
14:33:34 <henk> geekosaur: At that point I’m already kneedeep in nestings (: Toplevel is an object containing one object containing one array containing several objects
14:34:11 <triliyn> Twey: what? "putStrLn show x" is "putStrLn . show"?
14:34:15 <geekosaur> but the outermost is an object? that is forbidden by the JSON spec, which the normal aeson parser follows punctiliously
14:34:16 <Twey> Oh, right, no
14:34:17 <napping> even if you don't count on forkFinally, using try or finally or something and an MVar works pretty well
14:34:20 <Twey> print is putStrLn . show
14:34:23 <benmachine> oh wait, you don't
14:34:27 <benmachine> throwTo is also GHC only
14:34:36 <benmachine> but that's because Hugs doesn't actually have actual threads, so there :P
14:34:39 <Twey> putStrLn show x is a type error
14:34:45 <geekosaur> oh, hm, it's an object which sould be ok
14:35:14 <geekosaur> although it might help to see actual values (and code) to be certain... but at some point I go outside my depth, as JSON is not something I use regularly
14:35:17 <triliyn> Twey: yeah, but that was the error someone made earlier
14:35:40 <napping> Is there a channel for shake?
14:35:42 <Kinnison> napping: certainly seems to be the approach I should take, which is fine
14:36:26 <novochar> twey, the function application operator didn't have the exact result as using parens: https://gist.github.com/novodinia/8658688
14:37:09 <novochar> Twey: the function application symbol worked though
14:37:10 <novochar> $
14:37:55 <napping> I think I mostly solved what I was trying to do and posted it to the mailing list
14:41:49 <monochrom> if you write "putStrLn show x", you should change it to "putStrLn (show x)"
14:42:31 <monochrom> "putStrLn show x" is the same as "(putStrLn show) x"
14:42:49 <henk> geekosaur: "statsJson = fromJust $ (decode statsIn :: Maybe (HM.HashMap String (HM.HashMap String (Vector (HM.HashMap String Value)))))" this is how I decode my input. The last value can be either of Bool, String, Int, etc in the input, so I guess I can be more specific here and get a Value back in any case. How do I use that as what it actually is? Adding ":: Bool" e.g. does not seem to work …
14:43:11 <novochar> Is it possible to manipulate memory pointers with haskell?
14:43:21 <Axman6> novochar: yes. don't
14:43:28 <novochar> I'm looking at https://en.wikipedia.org/wiki/Strong_and_weak_typing#Pointers
14:43:43 <novochar> I'm trying to figure out which of these definitions fits within the haskell definition of strong typing
14:44:03 <monochrom> perhaps none of them does
14:44:14 <Axman6> indeed
14:44:20 <novochar> I've always considered implicit type conversions as weak typing, and the opposite to be strong typing. My idea of strong typing was misinformed it seems
14:44:39 <shachaf> "strong typing" is meaningless
14:44:49 <shachaf> or alternatively overly meaningful
14:44:58 <Axman6> shachaf: no it's not, that's how O code when I'm angry and it hurts my fingers
14:45:14 <Axman6> I*
14:45:32 <geekosaur> henk: you need to specify an actual type in place of Value for aeson to know how to decode the JSON
14:45:45 <jle`> henk: give an example json and what you want to get out of it
14:45:48 <geekosaur> no double colon, you're already specifying a type
14:45:58 * hackagebot wai-session 0.2 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.2 (StephenWeber)
14:46:17 <monochrom> I have decided that I don't know what are strong and weak typing, and I don't want to know
14:46:39 <jle`> novochar: yeah strong/weak don't really have any useful meaning.  but of that list, haskell falls under static type checking.
14:46:47 <jle`> er
14:46:55 <jle`> haskell qualifies as a language with static type checking
14:47:04 <novochar> Thank you jle`
14:47:16 <novochar> And everyone else for the feedback, as well
14:47:18 <jle`> it also has type inference of course
14:47:26 <monochrom> but I do have my own notion of type safety vs type cavalierism. type cavalierism means "can use list operations on booleans". type safety is the opposite.
14:48:13 <jle`> it definitely does not have implicit type conversions, untyped pointers, untagged unions, dynamic type checking
14:48:50 <dsrx> implicit type conversions don't necessarily make a type system non-static
14:48:58 <henk> jle`: Not my data and kinda sensitive, I’ll have to obfuscate. I’ll get back to that.
14:49:13 <jle`> henk: just give a sample structure
14:49:21 <jle`> with the structure you want to access
14:49:36 <Axman6> novochar: the definition of haskell doesn't mention pointers at allas far as I'm aware. there' no restriction on its implementation
14:50:20 <novochar> I'm looking for a function of type: Int a, String b => a -> b
14:50:31 <Platz> i kind of like this graph from odersky http://i.imgur.com/ToqCOsh.png?1  (from http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/31/slides/martin.pdf)
14:50:42 <jle`> novochar: Int and String are types, not typeclasses
14:50:42 <novochar> I want something which takes an int, say 2, and returns "2"
14:50:59 <jle`> show will do that for you
14:51:19 <jle`> show takes anything Showable (ie, has a "toString" method if you've used Java etc.), and returns a string
14:51:29 <jle`> > show 2
14:51:30 <lambdabot>  "2"
14:51:49 <jle`> :t show
14:51:50 <lambdabot> Show a => a -> String
14:53:24 <Platz> the Strong/Coarse and Weak/Detailed corners are interesting
14:53:47 <novochar> https://gist.github.com/novodinia/b0515556783935e05616
14:53:56 <defanor> i want to write simple parser/composer of irc messages (for practice, i'm a newbie), found haskell regexps, but they do not seem nice in/for haskell (just some intuitive/subjective opinion, most likely i'm wrong here), some bnfc-meta thing, documentation for which i can't find and which is probably now nice for practice in haskell, and some text parsing tutorial, which uses attoparsec, but i'm not sure how nice will be code with it. oh,
14:53:56 <defanor> and also some stuff for binary data parsing, which is probably overkill here too. what would you recommend to use, in order to practice and get a nice code?
14:54:03 <novochar> That is why I was looking for an Int -> String function
14:54:28 <Axman6> :t show `asAppliedTo` (1:: Int)
14:54:29 <lambdabot> Int -> String
14:54:36 <merijn> defanor: Have you looked into Parsec yet?
14:54:42 <defanor> s/now/not
14:54:56 <verement> :t asAppliedTo
14:54:57 <lambdabot> (a -> b) -> a -> a -> b
14:55:00 <merijn> defanor: There's also attoparsec for binary data, which is sufficiently similar that if you understand parsec the other should be easy
14:55:06 <defanor> merijn: just seen it's name somewhere. is it suitable for such a task? thanks, will check
14:55:10 <jle`> defanor: parsec/parser combinators is how most would recommend idiomatically parsec-ing
14:55:11 <jle`> er
14:55:13 <jle`> parseing
14:55:41 <Axman6> novochar: the problem is that read can't read the string "3" as a String. if it were "\"3\"" it could read it
14:55:43 <defanor> jle`: oh, nice, idiomatic approaches is what i want to find/learn. thanks
14:55:51 <merijn> defanor: Parsec is a good parsing library. Real World Haskell has a chapter on it (mind you, the chapter is on Parsec 2, instead of Parsec 3, but the general ideas and explanations still apply)
14:56:11 <Axman6> novochar: read . show is only sort of id
14:56:15 * Axman6 -> work
14:56:15 <merijn> defanor: I would definitely recommend reading the chapter, even if not all the code samples in there work
14:56:44 <defanor> merijn: will read right now
14:57:01 <jle`> > (read . show) 2
14:57:02 <lambdabot>  *Exception: Prelude.read: no parse
14:57:14 <merijn> jle`: Defaults to () for read :)
14:57:22 <jle`> merijn: heh
14:57:35 <merijn> > (read . show) 2 :: Int
14:57:37 <lambdabot>  2
14:58:05 <novochar> If standard ML has static types that can be rebound, how is it that it is a statically typed language? I thought that a statically typed languages meant that variables couldn't be reassigned to a new a value.
14:58:06 <jle`> Axman6: it can't read "3" as a string because "3" does not represent a string literal
14:58:15 <merijn> jle`: In case of polymorphic types (like "Read a => a") lambdabot will default to something, such as ()
14:58:35 <jle`> Axman6: but if you show the string "3"...
14:58:38 <jle`> > show "3"
14:58:40 <lambdabot>  "\"3\""
14:58:51 <merijn> novochar: You're confusing static with purely functional
14:59:03 <merijn> novochar: static typing just means types are known/checked at compile time
14:59:15 <Platz> shadowing is different from aliasing
14:59:17 <novochar> merijn: I updated the gist to include what you have written: https://gist.github.com/novodinia/b0515556783935e05616
14:59:21 <merijn> novochar: C for example is statically typed, but also weakly typed (can convert anything to anything)
14:59:24 <novochar> It's throwing an error as well
14:59:52 <jle`> novochar: when you have a ++ b
14:59:56 <merijn> novochar: "2" is not a valid String for read
14:59:58 <jle`> both sides have to be lists of the same type
15:00:00 <jle`> :t (++)
15:00:01 <lambdabot> [a] -> [a] -> [a]
15:00:06 <jle`> the right hand side is a list of Char's
15:00:08 <merijn> > read "\"2\"" :: String
15:00:09 <jle`> :t "hello"
15:00:10 <lambdabot>  "2"
15:00:10 <lambdabot> [Char]
15:00:15 <companion_cube> novochar: it's not "rebound", it's a new definition that shadows the old one
15:00:15 <dhrosa> @pl readIOReg addr state = ioRegs state !! (fromIntegral addr)
15:00:16 <lambdabot> readIOReg = flip ((!!) . ioRegs) . fromIntegral
15:00:17 <merijn> > read "\"2\"" ++ "test"
15:00:19 <lambdabot>  "2test"
15:00:26 <jle`> so...the left hand side must also be a String
15:00:30 <jle`> (a list of CHars)
15:00:36 <jle`> so it tries to read 2 as a String
15:00:40 <jle`> however, 2 isn't a string....
15:00:46 <jle`> "2" is a string.
15:01:22 <jle`> so it tries to read 2 as a string (but it can't be read as a string, strings start and end with quotse)...and it fails
15:01:29 <novochar> Thanks for the help, I'll be back in just a little bit!
15:02:32 <Platz> unless you're using refs with assignment though
15:03:36 <jle`> mm_freak: what if i wanted Container A to just "ask" container B to delete something?  (or modify something).  What can Container B do with the Event (C -> C) that Container A pops out besides *applying* it?
15:04:01 <jle`> mm_freak: i was thinking of tupling each item in the container with an Event
15:04:11 <jle`> that corresponds to that specific item
15:04:19 <jle`> but that seems slightly silly
15:04:37 <mm_freak> jle`: that's exactly what you're doing with the event
15:04:53 <mm_freak> the other container is free to handle the event in whatever way it likes
15:05:04 <henk> geekosaur: unsatisfying
15:05:27 <rtpg> oh my IHaskell is a thing that exists https://github.com/gibiansky/IHaskell
15:05:44 <henk> jle`: Yeah, I probably will soon, just a bit more fiddling around (:
15:05:54 <rtpg> you get the IPython notebook with Haskell, ipython notebook is so great
15:05:59 <Platz> rtpg: I was a little rough when released but I want to give it another shot
15:06:07 <Platz> I=it
15:06:22 <mm_freak> jle`: in FRP you don't generally "do" stuff…  stuff rather "is"
15:06:36 <rtpg> I've been playing with IPython's notebook and really want to be able to use it as my main IDE
15:06:45 <rtpg> I feel like it's the end result of literate programming
15:07:06 <Platz> rtpg: yeah, i assume you saw it from http://andrew.gibiansky.com/blog/linguistics/homophony-groups/ ?
15:07:10 <conal> mm_freak: exactly. thx.
15:07:48 <jle`> mm_freak: and you're talking about just passing out (Container, Event (Container -> Container)) ?
15:08:02 <zRecursive> @google IPython's notebook
15:08:04 <lambdabot> http://ipython.org/notebook.html
15:08:04 <lambdabot> Title: The IPython Notebook — IPython
15:08:21 <jle`> out of the container wire, that is
15:08:23 <rtpg> Platz, actually I just found it looking at github Haskell projects out of curiosity
15:09:14 <jle`> if container A decides that Item X in Container B has to be removed...it has to pass an even ttupled with Item X, right?
15:09:31 <jle`> hm
15:09:35 <jle`> maybe i am thinking about things too imperatively
15:09:48 <mm_freak> jle`: that might be =)
15:09:55 <mm_freak> jle`: what's your interpretation of a wire?
15:10:22 <jle`> I guess I want Container A to process Container B, and then say "hey, item x has to go."  and container B receives this message and decides if item x is allowed to go, depending on other conditions within the container
15:10:31 <jle`> to go as in be removed
15:10:43 <jle`> mm_freak: well...i shift back and forth between contradictory views
15:10:53 <jle`> heh.
15:11:32 <mm_freak> jle`: well, your confusion comes from an AFRP peculiarity
15:11:46 <mm_freak> f :: MyWire a b
15:11:56 <merijn> jle`: I can recommend reading conal's Push-Pull FRP paper
15:12:08 <mm_freak> the input to f is a behavior, unless it is wrapped by Event, in which case it is an event
15:12:09 <merijn> jle`: It's very nice and explains the basic ideas of FRP quite nicely
15:12:14 <jle`> i've implemented a simple nbody simulator and there are no discrete events...things run pretty snoothly
15:12:23 <mm_freak> the output of f again is a behavior, unless it is wrapped by Event, in which case it is an event
15:12:46 <jle`> wrapped by an event?
15:12:49 <jle`> as in MyWire a (Event b) ?
15:12:52 <mm_freak> by Event
15:12:55 <mm_freak> not an event
15:12:57 <mm_freak> yeah
15:12:58 <jle`> ah
15:14:03 <mm_freak> it would probably be a good idea to wrap behaviors in an actual Behavior functor
15:14:05 <jle`> so MyWire a (Event b) is an arrow that takes an a and returns Event a | NoEvent...but such that Event a is supposed to semantically be a discrete blip
15:14:11 <mm_freak> but it would really just be Identity
15:14:13 <jle`> *event b
15:14:24 <mm_freak> newtype Behavior a = Behavior a
15:14:42 <mm_freak> more importantly it takes a /behavior/ a
15:14:46 <mm_freak> and return an /event/ b
15:14:56 <jle`> hm.
15:15:12 <mm_freak> in reactive-banana the same thing would look like this:  f :: Behavior t a -> Moment t (Event t a)
15:15:28 <mm_freak> or sometimes just Behavior t a -> Event t a
15:15:29 <jle`> ok
15:15:43 <mm_freak> and Wire acts like Moment
15:17:37 <henk> geekosaur, jle`: Got it. I can use a Value that is actually a String like this: 'my_value == String (pack "NORMAL")'
15:17:43 <jle`> so, my thing right now would be proc _ -> do rec (contA, messagesForB) <- contAWire -< (contB, messagesForA); (contB, messagesForA) <- contBWire -< (contA, messagesForB); returnA -< (contA, contB)
15:18:17 <henk> geekosaur, jle`: Thanks for your attention and help (:
15:18:23 <mm_freak> jle`: looks reasonable to me
15:18:24 <jle`> where contXWire :: MyWire (Container a, Event Message)
15:18:33 <jle`> er
15:18:33 <mm_freak> jle`: that's a kind error
15:18:37 <jle`> (Container a, Event Message)
15:18:54 <jle`> MyWire (C a, Event Message) (C a, Event Message)
15:19:18 <jle`> i guess i'm having problems having a Message address a specifc item in the container
15:19:36 <jle`> especially if the items don't necessarily have a meaningful Eq instance
15:19:41 <mm_freak> well, there are two approaches
15:20:01 <mm_freak> 1. you assign identifiers to each item, 2. you use some form of mapping
15:20:02 <jle`> the container has to be able to process the message and decide to act on it in whatever way it wishes
15:20:25 <jle`> but the mssage addresses a specific item
15:20:31 <jle`> yeah, i was playing around with (1)
15:20:42 <jle`> by (2), do you mean...Container (a, Event Message) ?
15:20:58 <mm_freak> no
15:21:31 <mm_freak> jle`: the items of a container are defined in terms of some input behavior and some events
15:21:38 <mm_freak> ask yourself whether you really want those events to be delete events
15:21:54 <mm_freak> or whether the container should rather pick up environmental events and make the decision to delete based on those itself
15:22:21 <jle`> well, i'll be more specific
15:22:44 <jle`> it's a simulation of archers on different teams shooting arrows at eachother
15:23:01 <jle`> i would think the responsibility of the army/team
15:23:07 <jle`> is to look at all the arrows on the field
15:23:15 <jle`> see which ones kill who
15:23:18 <jle`> and kill them internally
15:23:25 <jle`> but then, each arrow belongs to a team (to prevent friendly fire)
15:23:40 <jle`> if i detect an arrow hitting my archer...i can kill my own archer
15:23:48 <jle`> but how do i convey that the arrow has hit?
15:23:52 <jle`> if the arrow belongs to the other army?
15:24:11 <jle`> so that the other army can delete the arrow from its list of arrows in flight
15:24:23 <mm_freak> that is a lot more difficult than it sounds
15:24:36 <jle`> i could assign each team an identifier
15:24:43 <mm_freak> in general it is easy to construct behaviors from events, but difficult to construct events from behaviors
15:24:46 <jle`> and then have a global shared bank of arrows flying around
15:25:02 <jle`> and so either army can delete any arrow they want
15:25:20 <jle`> and check for firendly fire by the team id on the arrow
15:25:43 <jle`> i think that this problem would be pretty simple if all of the arrows had an ID
15:25:50 <monochrom> next, your game will have nuclear weapons that don't harm owners and friends.
15:25:53 <mm_freak> jle`: understanding the fundamental problem will help you understand how to structure your program
15:26:06 <mm_freak> jle`: let's simplify our world slightly:  there is just one archer and one arrow flying in their direction
15:26:13 <jle`> so that if i register my archer being hit by an arrow...i can emit an event telling the other team to get rid of that arrow
15:26:14 <mm_freak> the position of the arrow is a behavior
15:26:24 <jle`> mm_freak: mk
15:26:38 <mm_freak> how do you construct a "hit" event?
15:26:48 <mm_freak> in wordfs
15:26:49 <mm_freak> words
15:27:04 <jle`> hm
15:27:30 <jle`> it's always NoEvent normally
15:27:35 <jle`> but when the archer and the arrow collide
15:27:38 <jle`> it is Event Hit
15:27:45 <jle`> and then the next tick, back to NoEvent
15:27:49 <mm_freak> no, stop
15:27:55 <mm_freak> type Behavior a = Time -> a
15:28:00 <mm_freak> type Event a = [(Time, a)]
15:28:12 <mm_freak> turn the arrow position behavior into a hit event
15:28:30 <jle`> turnIntoHitEvent . arrowPosition ?
15:28:45 <jle`> hm.
15:28:57 <mm_freak> let's assume a one-dimensional space
15:29:00 <jle`> i admittedly don't understand events with that type signature
15:29:17 <mm_freak> arrowPos :: Behavior Double
15:29:18 <jle`> hm.
15:29:26 <mm_freak> that's Time -> Double
15:29:39 <mm_freak> the arrow is considered to be hitting, when its absolute value is below 1
15:29:48 <mm_freak> so when it's in the unit "circle"
15:30:12 <mm_freak> now convert the behavior into a hit event
15:30:18 <mm_freak> hit :: Behavior Double -> Event ()
15:30:51 <mm_freak> and if this gets you some headaches, don't worry…  this is intentional =)
15:30:59 <jle`> hit loc | abs(loc time) < 1 = Event () | otherwise = NoEvent ?
15:31:17 <mm_freak> hit :: [(Time, ())]
15:31:21 <jle`> ah
15:31:24 <mm_freak> hit :: (Time -> Double) -> [(Time, ())]
15:31:26 <mm_freak> rather
15:31:40 <mm_freak> and there is no NoEvent
15:31:46 <jle`> okay
15:31:47 <mm_freak> an Event is a list of occurrences
15:32:10 <mm_freak> the problem boils down to this:  hit :: (Time -> Double) -> [Time]
15:32:17 <mm_freak> find the times, when the arrow hits
15:33:02 <mm_freak> and i repeat:  headaches are intended =)
15:33:35 <jle`> pardon my taking some time
15:33:43 <mm_freak> take as much time as you need =)
15:34:36 <jle`> hit loc | loc time < 1 = [time]:hit loc ?
15:34:39 <jle`> hm.
15:34:50 <mm_freak> that's a type error
15:34:58 <mm_freak> allow yourself to put this in an actual haskell file
15:35:05 <mm_freak> type Behavior a = Time -> a
15:35:09 <mm_freak> type Event a = [(Time, a)]
15:35:18 <jle`> hit loc time | loc time < 1 = time:hit loc (time+dt) | otherwise = hit loc (time+dt)
15:35:21 <jle`> hm okay
15:35:22 <jle`> i'll try it out in a file
15:35:24 <mm_freak> arrowPos t = 15 - t
15:35:31 <mm_freak> now write 'hit'
15:35:50 <mm_freak> it should take the arrow position as its argument and produce a hit event
15:35:56 <mm_freak> hit :: Behavior Double -> Event ()
15:36:14 <jle`> and Event () = [(Time, ())]
15:36:21 <mm_freak> (note the distinction between "event" and "occurrence")
15:36:27 <mm_freak> yeah
15:36:37 <mm_freak> just use the types i wrote above
15:36:43 <jle`> ok
15:36:51 <mm_freak> what you're doing right now is barebones FRP =)
15:36:57 <jle`> hm wait.
15:37:10 <jle`> i'm not supposed to be using the analytic form of arrowPos t
15:37:12 <jle`> right?
15:37:26 <mm_freak> why not?
15:37:35 <jle`> becuase in general it might not be known?
15:37:57 <jle`> oh i mean, in my definition of hit
15:37:58 <mm_freak> well, 'hit' does not know how the arrow position is defined
15:38:05 <jle`> yeah, what i meant
15:38:12 <mm_freak> don't worry, the types won't allow you to make mistakes =)
15:39:00 <jle`> that's encouraging
15:39:55 <mm_freak> oh, btw…  you may want Time to be an actual type
15:40:01 <mm_freak> type Time = Rational
15:40:25 <jle`> haha yeah, thanks
15:40:43 <mm_freak> in general it is rather something abstract…  in netwire's FRP model it is a generic topological space
15:41:01 <mm_freak> don't worry about that for now
15:41:27 <jle`> trying to figure out how to deal with a continuous time
15:41:40 <jle`> if i can't...step through anything
15:42:00 <mm_freak> you are now understanding the problem =)
15:42:02 <mm_freak> now solve it
15:47:18 <jle`> aw i solved it with timesteps. do i lose
15:47:19 <jle`> http://lpaste.net/99143
15:47:45 <mm_freak> you don't lose, because that's the best you can do =)
15:47:53 <jle`> haha. wait really?
15:47:55 <jle`> oh
15:47:56 <jle`> i see
15:48:12 <jle`> oh i guess i could do the head of the list as hit, so it's just one discrete event
15:48:23 <mm_freak> yeah
15:48:42 <mm_freak> now you also understand why this is so difficult to express in netwire
15:48:49 <jle`> hm
15:48:49 <mm_freak> because it does not make sense in FRP
15:49:03 <mm_freak> there is simply no exact hit
15:49:33 <jle`> so is the solution that there is another way to rephrase things?
15:49:38 <jle`> within afrp?
15:49:52 <jle`> or is frp not the right tool?
15:50:16 <mm_freak> FRP is the right tool…  just accept that there is no exact hit, and that you can't handle things framewise
15:50:23 <mm_freak> because frames do not exist in FRP
15:50:33 <mm_freak> whenever you have a problem like this, try translating it into this barebones FRP model
15:51:06 <jle`> ah. ok
15:51:11 <mm_freak> you will benefit from trying to express your logic in this model
15:51:13 <identity> wow.
15:51:28 <mm_freak> once you have a working model, you can translate it into an actual simulation using netwire
15:51:34 <identity> did a node shit itself or did something go wrong somewhere in the internets?!
15:52:10 <eviltwin_b> oh, that might explain why znc isn't reconnecting
15:53:28 <jle`> mm_freak: hm okay
15:54:12 <jle`> i think i better understand what events actually are now
15:54:47 <mm_freak> jle`: and you now also understand why Event's constructors are not exposed =)
15:55:15 <jle`> heh. why is that?
15:55:16 <mm_freak> and why there is a huge "UNSAFE!!111" label on them =)
15:55:26 <jle`> all of this stuff
15:55:29 <jle`> expoeses the internal dt?
15:55:37 <aleksejs_> very strange problem: I'm installing happstack, it removes mysql-simple, I install mysql-simple again, it removes happstack O_o
15:55:42 <mm_freak> jle`: the internal dt is not exposed by FRP.Netwire
15:56:13 <aleksejs_> it's on remote machine, but I somehow managed to install both on local machine
15:56:13 <stepcut> aleksejs_: likely some sort of conflicting depends -- happstack-server should be up to date for most everything except text 1.1
15:56:39 <stepcut> aleksejs_: are you installing via cabal or debian?
15:56:44 <stepcut> or something else..
15:56:44 <aleksejs_> cabal
15:56:45 <phulin> Is there a regex library for Texts?
15:56:55 <jle`> hm i can't really totally connect this notion of list for events with netwire's Event
15:56:58 <phulin> or is it easy to define a RegexLike class for them?
15:57:01 <stepcut> what happens if you say, cabal install happstack-server mysql-simple
15:57:14 <jle`> does it just crawl through the time andreturn Event whenever there is a match in the event list?
15:57:51 <jle`> (conceptually)
15:57:52 <mm_freak> jle`: remember that the list-of-occurrences Event is just a model
15:57:54 <mm_freak> and netwire follows the model
15:57:56 <jle`> ah okay
15:58:13 <mm_freak> imagine the following wire (with Event constructors exposed):
15:58:18 <mm_freak> pure (Event ())
15:58:21 <jle`> how i would implement hit would be...a wire that is usually NoEvent, then Event for one tick when ther eis a hit
15:58:29 <mm_freak> this is an event that occurs at every time instant
15:58:47 <jle`> ah
15:58:52 <mm_freak> try to translate this into the list-of-occurrences model
15:58:58 <mm_freak> you will see that it does not make sense
15:59:19 <jle`> hm yeah not really.
16:00:20 <jle`> hm. i actually have to head out now
16:00:33 <jle`> i'll ponder this.
16:00:59 <jle`> should my multi-army multi-arrow mulit-archer solution scale from this toy model
16:01:02 <jle`> ?
16:01:15 <mm_freak> jle`: yes
16:01:21 <mm_freak> well, almost
16:01:21 <jle`> okay.
16:01:29 <mm_freak> the model does not include netwire's intervals
16:01:36 <jle`> is the way i am approaching it wrong?
16:01:41 <mm_freak> which are not easy to model in haskell
16:01:46 <jle`> actually i do'nt even know how i'm approaching it now.
16:01:51 <mm_freak> well, it's the imperative way
16:01:56 <jle`> hm
16:02:02 <mm_freak> which, as you see, does not work in netwire =)
16:02:05 <jle`> haha
16:02:11 <mm_freak> it wants stuff to "be" rather than to "do"
16:02:21 <mm_freak> however…
16:02:29 <mm_freak> 'hit' is actually easy to write in netwire
16:02:45 <jle`> yeah, i think so, i have written similar ish things.
16:02:48 <jle`> hm.
16:02:53 <mm_freak> using 'periodic' will give you this sampling hitter that you wrote in the pure FRP model above
16:03:08 <mm_freak> periodic :: Time -> MyWire Double (Event Double)
16:03:24 <jle`> so when Team B's arrow hits Team A's archer...both Team B's arrow and Team A's archer have to die somehow
16:03:26 <mm_freak> the input is a behavior, and the output is an event that samples the behavior at regular intervals
16:03:29 <mm_freak> then you can just use filterE
16:04:01 <roboguy_> does hlint not support DataKinds?
16:04:07 <jle`> mm_freak: ah that's nice. good to see those event combinators actually used
16:04:10 <jle`> heh
16:04:14 <aleksejs_> stepcut, it's installed now, but shows some errors with Data.Text
16:04:53 <mm_freak> jle`: in any case…  try to express your simulation in the pure model (you can actually display it by really just applying a behavior to times)
16:05:33 <mm_freak> once that works, it will be rather easy to translate it into the corresponding wire
16:05:40 <jle`> mm_freak: ah okay. and lose the neat recursion tricks of ArrowLoop?
16:05:47 <mm_freak> no, why?
16:05:58 <jle`> by pure model do you mean the toy model?
16:06:10 <jle`> i'll be writing these behaviors and events from scratch then right?
16:06:11 <mm_freak> let behavior1 = … behavior2 …; behavior2 = … behavior1 …
16:06:17 <mm_freak> for the pure model you get value recursion for free =)
16:06:17 <jle`> ah
16:06:19 <jle`> haha
16:06:28 <jle`> that's awesome
16:06:43 <mm_freak> and yes, you will be writing them from scratch =)
16:06:59 <jle`> okay, i'll try working this through and et back to you then
16:07:24 <jle`> i just keep on jumping back into the Eq box
16:07:33 <jle`> when trying to think of things
16:07:42 <mm_freak> =)
16:07:43 <jle`> but maybe if i can pound it out here i'll get it out of me.
16:09:05 <jle`> thanks again :)
16:09:20 <mm_freak> you're welcome…  the more people get FRP right, the happier i am =)
16:09:29 <mm_freak> and conal, too =P
16:09:34 <conal> :)
16:11:22 <mm_freak> jle`: one more interesting thing:  you may find it useful that Behavior is an applicative functor
16:20:05 <colDrMcBeardman> skypers, you there?
16:22:35 <colDrMcBeardman> @tell skypers did you see the ticket got closed as a dupe?
16:22:35 <lambdabot> Consider it noted.
16:22:38 <joneshf-laptop> i tell you, one thiing i like about his channel, questions get answered
16:23:16 <colDrMcBeardman> joneshf-laptop, #haskell is the best forum i've ever been on. no one is a dick and people actually help you.
16:24:13 <hpc> colDrMcBeardman: you should see how we deal with trolls :D
16:24:21 <colDrMcBeardman> hpc ??
16:24:26 <hpc> we melt them with niceness
16:24:39 <defanor> is there parsec 3 documentation anywhere? looks like documentation on it's homepage was written in 7 years before it's release
16:25:11 <mm_freak> defanor: most of it still applies…  just get your imports right
16:25:48 <colDrMcBeardman> i'm having a problem with aeson via fb... i get "expecting a (), got an Object instead"
16:25:54 <hpc> defanor: hackage is going to be your best bet for anything more detailed than a quick tutorial
16:26:11 <defanor> mm_freak: hpc: thanks
16:26:15 <hpc> (if you can get past the module re-exports)
16:26:25 <hpc> colDrMcBeardman: can you paste your code?
16:26:26 <hpc> @hpaste
16:26:26 <lambdabot> Haskell pastebin: http://lpaste.net/
16:26:34 <colDrMcBeardman> i don't understand why fromJSON dies when it sees an Object
16:26:45 <colDrMcBeardman> hpc, err, if you haven't used the fb library it's a pain in the ass.
16:27:20 <hpc> oh my
16:28:07 <colDrMcBeardman> hang on, i'm posting the json string... gonna take aminute to show up.
16:28:19 <colDrMcBeardman> http://lpaste.net/99146
16:28:49 <hpc> i am not sure what i would have done with a facebook package, but definitely not "module Facebook where"
16:28:50 <Clint> you could've run that through aeson-pretty
16:28:50 <colDrMcBeardman> so that gets processed with eitherDecode, which fails with the "expecting a ()" error
16:29:10 <hpc> oh, i meant the code
16:29:18 <hpc> to figure out the type error
16:29:24 <colDrMcBeardman> hpc, it's not a type error.
16:29:54 <colDrMcBeardman> it's eitherDecode returning a Left.
16:30:13 <hpc> oooh
16:30:16 <colDrMcBeardman> Clint, sorry, i'm not in the habit of using syntax highlighting or anything like that.
16:31:03 <colDrMcBeardman> hpc, yeah, i have no idea why that isn't coming back to me as an Object, why aeson is expecting ()....
16:32:16 <hpc> should it have an opening "{"?
16:32:41 <colDrMcBeardman> hpc, actually it does.
16:33:12 <colDrMcBeardman> i didn't catch it when i snarf-pastes.
16:33:14 <colDrMcBeardman> pasted*
16:33:48 <Clint> it's missing a closing } too
16:34:55 <colDrMcBeardman> Clint, yeah, i didn't snarf them, but they are being returned.
16:35:35 <Clint> with those added it parses for me
16:36:10 * hackagebot direct-sqlite 2.3.11 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.11 (IreneKnapp)
16:36:22 <colDrMcBeardman> oops.... i just figured it out.
16:36:31 <colDrMcBeardman> damn fb library...
16:37:04 <colDrMcBeardman> weird what happened, though.... i had to add a type sig because the fb function i was calling returned a "Pager a"
16:37:22 <colDrMcBeardman> so since a wasn't specified, i guess aeson just assumed i wanted ()
16:37:40 <colDrMcBeardman> i would have expected a complaint that a was ambiguous....
16:37:56 <hpc> yeah, it parses for me too
16:38:12 <hpc> (using perl because i can deal with json a bit easier there)
16:38:26 <hpc> oh lol, DMR
16:38:33 <hpc> (dreaded monomorphism restriction)
16:40:37 <colDrMcBeardman> hpc, is that what it is? i thought dmr would give me errors...
16:40:47 <hpc> no, it just borks your types
16:40:53 <colDrMcBeardman> oh, AWESOME.
16:40:54 <hpc> and then maybe errors if it can't make it work
16:40:59 <hpc> well, it has to
16:41:13 <hpc> it's designed with numeric code in mind
16:41:46 <hpc> the goal being to take things that are too polymorphic and make them monomorphic, in cases where you get stupendous slowdown
16:42:24 <hpc> (which you do with numbers, because it's easy to make things excessively polymorphic and because monomorphic variants are so damn fast otherwise)
16:42:43 <hpc> it's a fairly old and controversial feature
16:43:25 <colDrMcBeardman> hpc, i don't see how -XNoMonomorphismRestriction would help
16:43:34 <colDrMcBeardman> well, lemme go see if it blows up. muaha
16:43:56 <hpc> i wouldn't do that, just give it a type signature
16:44:32 <colDrMcBeardman> actually, same problem.
16:44:34 <pera> Hi, I was looking an article about security in Lambdabot's evaluator I read a while ago, I think it was on Haskell's wiki but I can't find it
16:44:34 <markovirc_> Hello pera
16:44:42 <colDrMcBeardman> just silently lets aeson think i wanted a ()
16:44:56 <colDrMcBeardman> so i guess it's not the DMR.
16:44:58 <colDrMcBeardman> ?
16:45:26 <pera> (or maybe I was dreaming and that article actually never existed :P)
16:45:57 <hpc> pera: i vaguely remember it existing; short version of the article is that lambdabot doesn't let you run IO and it keeps out stuff that does questionable stuff to the type system
16:46:13 <pera> hpc: yeah! :D
16:46:15 <hpc> (which theoretically prevents one from producing an IO a -> a function)
16:48:11 <pera> oh oh here I found it: http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
16:49:54 <hpc> heh, i forgot all about the memory allocation stuff
16:52:19 <pera> :3
17:10:15 <dart> hi
17:10:17 <markovirc_> Hello dart
17:10:34 <dart> why there is no dupTBMChan ?
17:11:08 <dart> the doc says "    -- I don't know how to define dupTBMChan with the correct semantics
17:16:15 * hackagebot hspec-webdriver 0.2.0 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.2.0 (JohnLenz)
17:26:28 <johnw> dart: what semantics do you think it should have?
17:27:22 <mindleyhilner> :t flip (!!0
17:27:23 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:27:23 <mindleyhilner> :t flip (!!)
17:27:24 <lambdabot> Int -> [c] -> c
17:27:30 <mindleyhilner> 4 `flip (!!)` [1..20]
17:27:35 <mindleyhilner> > 4 `flip (!!)` [1..20]
17:27:37 <lambdabot>  <hint>:1:9: parse error on input `('
17:27:47 <johnw> you can't put expressions inside ``
17:27:52 <johnw> only identifiers
17:28:10 <mindleyhilner> i wanna do (really long expression) !! 4 without the parens
17:28:27 <johnw> define a helper function
17:28:44 <sipa> flip (||) 4 $ really long expression
17:32:42 <defanor> what's the proper way to make parsec parser for something like 2*5(%x01-23 / %x32-4F) in ABNF (that is, for character ranges and for upper/lower limits for number of occurrences)?
17:36:42 <defanor> probably i could check ranges with 'satisfy', which is almost nice, but what to do with limits?
17:38:07 <defanor> or maybe it's not parsing task, but a validation task
17:40:16 <pavonia> defanor: Is that 2 to 5 characters of the given range?
17:42:31 <defanor> pavonia: yep. but i think it'll be fine to check it after parsing even
17:42:57 <defanor> pavonia: could be nice to fail on parsing if it's not correct though
17:43:24 <Twey> defanor: fromTo 0 0 p = empty; fromTo 0 n p = maybe [] ((fromTo 0 (n - 1) p ++) . pure) <$> optional p; fromTo m n p = (fromTo 0 (n - 1) p ++) . pure <$> p -- something like this (if empty succeeds; I can't remember)
17:43:36 <Twey> (oh, it should be pure [] anyway)
17:43:58 <defanor> Twey: thanks
17:44:19 <Twey> I'd probably use oneOf rather than satisfy, too
17:44:54 <pavonia> or combining "count n" and "option (count m)" for n to m matches
17:44:56 <defanor> but oneOf will require full list of characters. not sure if it's nice to enlist them all
17:44:58 <Twey> Well, depends on what you want to do, but if it's some kind of continuous range it feels like you should have an Enum instance
17:45:14 <pavonia> err, option (count (m-n))
17:45:45 <Twey> pavonia: The problem with that is that you only get n matches or m matches, not anything in between
17:46:02 <Twey> If you have ‘two to four digits’ then three digits is an acceptable input
17:46:09 <pavonia> aww, you're right
18:02:59 <johnw> what set of characters can appear in a Haskell module name?
18:03:23 <johnw> it looks like inClass "a-zA-Z0-9'", separated by periods
18:03:59 <johnw> the report says _ can occur, but the grammar doesn't specify it
18:04:17 <joelteon> johnw: I have a list
18:04:32 <joelteon> https://i.joelt.io/module-start.html
18:04:37 <Cale> It's the same as the list of characters in a constructor, plus periods.
18:04:48 <joelteon> and this, which is pretty big https://i.joelt.io/module-end.html
18:04:52 <johnw> awesome, thanks
18:05:05 <johnw> for now, I'm just using:
18:05:07 <johnw>     identClass = "A-Za-z0-9'_"
18:05:07 <johnw>     identifier = (:) <$> inClass identClass <*> many (inClass ('.':identClass))
18:07:12 <Twey> johnw: Haskell's syntax is based on Unicode codepoint properties in general, so I'd be surprised if you couldn't have characters like é
18:07:14 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010 -- if you search here for conid, that'll tell you
18:07:24 <johnw> Cale: yeah, that's what I was looking at
18:07:35 <johnw> I don't suppose anyone has already written a complete parsec parser for module headers?
18:07:37 <Cale> conid	→	large {small | large | digit | ' }
18:07:43 <Cale> large	→	ascLarge | uniLarge
18:07:53 <Cale> uniLarge	→	 any uppercase or titlecase Unicode letter
18:08:14 <Cale> I don't really know why it branches there
18:08:14 <Twey> I wonder why ascLarge is a separate thing
18:08:16 <Twey> Heh
18:08:30 <Twey> johnw: _ is included in ‘small’
18:08:37 <johnw> ah, ok
18:08:42 <Twey> small→ascSmall | uniSmall | _
18:08:45 <Cale> I guess it means that if Unicode ever ends up removing support for A, ..., Z we'll still be covered
18:08:46 <dwcook> You might try checking whether Data.Char's isLetter and isUpper conform with the spec's expectations
18:08:54 <Twey> Cale: I can see that being a concern
18:09:07 <dwcook> and if so use those to construct your parser or whatever it is
18:09:09 <Twey> I wonder whether ‘letter’ means ‘codepoint’ or ‘glyph’
18:09:22 <Twey> :t isLetter
18:09:23 <lambdabot> Char -> Bool
18:09:28 <Twey> I guess codepoint
18:09:32 <geekosaur> normalized codepoint, I suspect
18:09:36 <Twey> That's a shame
18:09:41 <dwcook> Chars represent codepoints?
18:09:46 <Twey> Yeah
18:10:02 <dwcook> Then a correct version would use Text, I guess
18:10:32 <dwcook> @hoogle Text -> Bool
18:10:32 <lambdabot> Data.Text null :: Text -> Bool
18:10:32 <lambdabot> Data.Text.Lazy null :: Text -> Bool
18:10:32 <lambdabot> Data.Text.Lazy.Internal strictInvariant :: Text -> Bool
18:10:35 <Twey> I suppose a truly correct implementation would have Char be multi-codepoint and then a String be a list of Char
18:10:54 <Twey> So that a Char can be a glyph… but that would be awkward to enforce
18:10:57 <geekosaur> although I don't know offhand whether ghc normalizes its input, and NFC has its own confusing issues
18:11:06 <Twey> Unicode is hard
18:11:18 <geekosaur> twey: if you look around you can find people asking for an NFG (glyph) normalized form
18:12:28 <Earnestly> Twey: The hardest thing about Unicode is getting rid off decades of bad terminology.  E.g. `char`
18:12:30 <Twey> geekosaur: But it would be awkward to enforce that a sequence of codepoints is NFG
18:12:37 <geekosaur> yep
18:12:38 <Twey> (Turing-complete, in fact)
18:13:04 <Twey> Earnestly: That is certainly a hard thing about Unicode
18:13:15 <Twey> I'm not sure it's the hardest
18:13:41 <Twey> Ultimately it comes down to the fact that computers are bad at human language
18:13:53 <geekosaur> there are so many hard things about unicode, and which one is hardest is probably undecidable :p
18:14:09 <Twey> ‘The hardest thing about Unicode is deciding which problem is hardest’
18:15:06 <ij> Pardon my ignorance, but why is unicode hard? It seems simple to me.
18:15:10 <Earnestly> *shrgu*
18:15:46 <Twey> ij: Because human languages are massively complicated
18:16:12 <Twey> And every time you think you've figured out a consistent and sane way to represent all of them in the same data structure, you find another exception
18:16:16 <Earnestly> ij: It's not hard, programming languages are just broken, e.g. Java, C++ Strings, etc.
18:16:21 * hackagebot BlogLiterately 0.7.1.2 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.2 (BrentYorgey)
18:16:44 <Twey> Earnestly: It's hard in general
18:17:04 <ij> Twey, You mean like stuff like RTL/LTR?
18:17:06 <Twey> Java and company just give up earlier :þ
18:17:20 <Earnestly> Twey: *shrug*, I don't think it's hard.
18:17:33 <Twey> ij: No, that's reasonably easy to do — more difficult is things like deciding what constitutes a grapheme
18:17:33 <Earnestly> Just new and novel
18:17:45 <Twey> (and enforcing it at the type level)
18:17:48 <Earnestly> A giant lookup table
18:18:09 <Twey> Earnestly: That would need to be an infinite lookup table
18:18:29 <Earnestly> Twey: How do you figure that?
18:18:29 <Twey> A Unicode grapheme can consist of arbitrarily many combining codepoints
18:18:33 <Earnestly> (It's not)
18:18:43 <Earnestly> That's correct
18:19:32 <Twey> I guess you could do something like data Grapheme = Grapheme BaseCodepoint [CombiningCodepoint]
18:19:52 <Twey> Hmm
18:20:21 <Earnestly> http://www.unicode.org/reports/tr29/
18:20:55 <Twey> I like that.  Some combining codepoints have to appear before the base codepoint and some after, but I guess that can just be done on a per-codepoint basis when combining.
18:22:34 <colDrMcBeardman> ij, Twey: then there's the fun things like ligatures, which as much as they belong in text, don't (IMHO) belong in Unicode.
18:23:03 <Earnestly> colDrMcBeardman: Unicode will include every glyph that has ever existed in computing
18:23:13 <Earnestly> And ligatures certainly have, so have floating business men ;p
18:23:20 <colDrMcBeardman> Earnestly, yes, eventually it will.
18:23:21 <Earnestly> But they're not adding new ones
18:23:22 <Twey> colDrMcBeardman: Then you have to decide whether ß is a ligature
18:23:31 <colDrMcBeardman> Twey, or ij in dutch!
18:23:39 <Twey> Or ij, indeed :þ
18:23:57 <Twey> Isn't there a theory that it's actually supposed to be ÿ, and it just got misanalysed?
18:23:57 <colDrMcBeardman> someday we'll need 128-bit chars
18:24:00 <ij> They don't use it anymore though, do they?
18:24:08 <colDrMcBeardman> ij, yes, they do.
18:24:13 <ij> hmm
18:24:22 <ij> I mean single char one.
18:24:24 <colDrMcBeardman> Twey, that is fascinating
18:24:26 <johnw> asking about Unicode in here is like the perfect troll, now that I think about it...
18:24:48 * ij was just generally uninformed about the hardships of dealing with it.
18:25:02 <johnw> yeah, it never really gets easy
18:25:13 <johnw> and just what you think you have a grasp, they'll hit you with normalizations
18:25:25 <Earnestly> I don't understand why you think unicode is hard
18:25:30 <Earnestly> It's complicated, yeah
18:26:08 <johnw> it's hard in the way that terminfo stuff was hard back in the day; not intellectual hard, just laborious and you always forget something
18:26:10 <Twey> ij: ij is also fun to think about in text, because it's treated as a single letter for all purposes in Dutch — so you never hyphenate in the middle of it, for example, and if you capitalize a word like ‘ijmuiden’ it becomes ‘IJmuiden’
18:26:36 <ij> I read about that just yesterday. :) I'm learning dutch.
18:26:41 <colDrMcBeardman> Twey, and then you have eszett, which *does* break
18:26:47 <Twey> Right
18:27:07 <colDrMcBeardman> plus vanilla english ones can break.
18:27:16 <Twey> And whether you should break or not properly depends on the language of the word in question, which is almost never marked up in text, so you end up doing things like uppercasing differently depending on locale
18:27:42 <colDrMcBeardman> heh. it's a nest of vipers.
18:27:49 <Twey> This is why I laugh at people who think case-insensitivity in names is a good idea :þ
18:27:54 <colDrMcBeardman> if only we all spoke something more logical!
18:28:02 <Twey> ro ko jbobau!
18:28:12 <Twey> Er, se jbobau.
18:28:16 <Earnestly> And thanks to null terminated strings we have Modified UTF-8 which is not actually valid UTF-8, yay
18:28:28 <Twey> Earnestly: Whaaat?
18:28:39 <colDrMcBeardman> heheh
18:28:44 <Twey> I thought NUL was always invalid in a UTF-8 string just so that it could still be used as a string-terminator
18:30:02 <Earnestly> But a NUL character can appear in a valid UTF-8 string, so Modified UTF-8 encodes it as C0 80, which is not the shortest possible representation
18:30:14 <Twey> Oh, I thought it couldn't
18:30:16 <Twey> Eek
18:30:37 <Earnestly> NUL terminated strings are dumb anyway
18:30:59 <colDrMcBeardman> Earnestly, you mean you don't pine for the grand days of C and buffer overflow exploits?
18:31:06 <Earnestly> ;<
18:31:13 <Twey> Heh
18:31:23 * hackagebot webdriver-angular 0.1.3 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.3 (JohnLenz)
18:31:27 <colDrMcBeardman> I used to be a C nazi....
18:32:17 <colDrMcBeardman> I got better.
18:32:35 <jle`> anyone here went to popl? have to do laundry and was wondering if there were any good talks
18:32:39 <jle`> to pass the time
18:32:50 <koala_man> utf-8 doesn't disallow NUL
18:35:21 <byorgey> jle`: are videos of the talks already up?
18:36:03 <jle`> byorgey: oh, probably should have checked that before asking :)
18:36:22 <byorgey> I would be surprised if they are already up, though I suppose it's possible
18:37:43 <byorgey> jle`: the Backpack talk was great
18:37:54 <byorgey> NetKAT is also cool
18:38:12 <Twey> What's happening with Backpack?  I ran into it at least a year or two ago, but suddenly there's a lot more buzz about it.  Did something happen I'm not aware of?
18:38:25 <byorgey> Twey: yes, they published a POPL paper
18:38:58 <roboguy_> did they record the talk?
18:39:05 <Twey> byorgey: But there was already a paper
18:39:10 <jle`> sad i couldn't make it, i live in san diego
18:39:14 <jle`> *sigh*
18:39:17 <byorgey> all the talks were recorded
18:39:46 <byorgey> Twey: was there?  I think maybe it's the same one
18:39:48 <Twey> All the talks were recorded and will be available for download for a month after the conference, is my understanding
18:40:20 <byorgey> continuing with my list of recommended talks, everyone should watch "The Essence of Reynolds"
18:40:31 <byorgey> the LVars talk was great
18:41:17 <byorgey> cardinality analysis and "profiling for laziness" were both great
18:42:04 <byorgey> obviously this is not an exhaustive list, since (a) I could only attend half the talks, (b) I skipped some, (c) I wasn't there on Friday
18:47:27 <maxiepoo> wait are their videos already up?
18:48:10 <jle`> byorgey: thanks :)
18:49:40 <maxiepoo> there(
18:49:42 <maxiepoo> there*
18:50:12 <byorgey> maxiepoo: not that I know of.
19:00:58 <jrm2k6> Hi guys, http://lpaste.net/99151
19:01:05 <jrm2k6> I dont understand why it is complaining
19:01:17 <jrm2k6> oh wait
19:02:29 <joneshf-laptop> @pl \x -> unwords x
19:02:29 <lambdabot> unwords
19:02:35 <joneshf-laptop> jrm2k6,
19:03:17 <jrm2k6> hm
19:03:26 <jrm2k6> whats wrong with it?
19:03:27 <byorgey> hint already made that suggestion at the bottom of the paste =)
19:03:38 <ReinH> for both of them
19:03:50 <byorgey> jrm2k6: joneshf-laptop was just pointing out that you can write simply  'unwords' in place of  '\x -> unwords x'
19:03:50 <jrm2k6> but if i dont use a do statement
19:03:56 <jrm2k6> ah right
19:03:57 <joneshf-laptop> jrm2k6, it's just saying to use the function itself rather than wrapping it in a lambda
19:03:57 <jrm2k6> yes
19:03:58 <jrm2k6> sorry
19:04:20 <byorgey> jrm2k6: if you are getting an error message, please paste the error message along with the code
19:04:30 <byorgey> it's very hard to just stare at some code and deduce "what is wrong"
19:04:31 <jle`> also we usually generally avoid using a lot of $'s in the same line
19:04:46 <ReinH> it's nice to write type signatures for your functions :)
19:04:52 <jle`> > (\x -> unwords x) "hello world"
19:04:53 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
19:04:53 <lambdabot>  Expected type: [GHC.Base.String]
19:04:53 <lambdabot>    Actual type: [GHC.Types.Char]
19:04:59 <jle`> er
19:05:05 <jrm2k6> ok
19:05:06 <jle`> > (\x -> unwords x) ["hello","world"]
19:05:07 <lambdabot>  "hello world"
19:05:12 <jle`> > unwords ["hello","world"]
19:05:13 <lambdabot>  "hello world"
19:05:20 <jrm2k6> i will give a new paste explaining my issue
19:05:38 <lingxiao> jrm2k6: welcome back! I'm glad to see you're going at it :)
19:05:54 <pavonia> jrm2k6: And don't mix tabs and spaces (avoid tabs completely, if possible)
19:06:01 <jrm2k6> lingxiao: yep i m just trying something before dinner
19:06:22 <jle`> f $ g $ h $ x
19:06:26 <jle`> is the same as f . g . h $ x
19:06:49 <jrm2k6> jle`: thanks i will change it
19:06:52 <jle`> or (f . g . h) x
19:06:56 <jle`> if you don't like $'s
19:07:01 <athan> liftM (f . g . h) = f <=< g <=< h
19:07:04 <athan> correct?
19:07:04 <jrm2k6> http://lpaste.net/99151 -> putStrLn should work no?
19:07:29 <jle`> jrm2k6: try putting type sigantures on your functions
19:07:38 <icanc> k
19:07:41 <jrm2k6> jle`: ok modifying right now
19:07:51 <pavonia> :t (<=<)
19:07:52 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:07:55 <intrados> What do I need  between 'ix 0' and 'filtered' to make this work? `["foo", "bar"] ^? ix 0 . filtered ('o' ==)` => "oo"
19:08:05 <pavonia> athan: no
19:08:22 <intrados> err... Just "oo"
19:09:40 <jle`> jrm2k6: do you know what <- is supposed to do?
19:10:25 <jle`> in particular...the difference between a <- f and let a = f
19:11:27 <jrm2k6> jle`: not really i am reading about it
19:11:48 <jrm2k6> <- extracts the value from a monad
19:11:55 <djahandarie> Man, algorithms in ST get damn ugly.
19:11:56 <geekosaur> sort of
19:12:42 <djahandarie> edwardk, dolio, have either of you already written fractional cascading for multi-Vector searches or am I doing something useful?
19:12:49 <jrm2k6> but if the right part of my assignment is a list, it should work, jle`
19:13:19 <dolio> djahandarie: Nope.
19:13:52 <jle`> <- extracts the value from the monad
19:13:56 <jle`> kinda yea
19:14:03 <djahandarie> dolio, I'll take that as a "no I haven't" rather than a "neither". :p
19:14:06 <jle`> but what is map unwords (...) ?
19:14:20 <jle`> :t map
19:14:21 <lambdabot> (a -> b) -> [a] -> [b]
19:14:33 <dolio> That's what I meant. But I think the answer is actually neither.
19:14:37 <jrm2k6> it will be another list of strings in this case
19:14:43 <jrm2k6> so still a list
19:15:05 <structuralist> can I have view patterns with two arguments?
19:15:06 <djahandarie> dolio, oh well. At least it's fun. Maybe someone will eventually find it useful. Saving precious space!
19:15:07 <dolio> I've heard Ed talk about fractional cascading, and then a couple days later tell me about how he discovered how he didn't have to implement it.
19:15:14 <jle`> jrm2k6: so it's extracting the value from the list monad
19:15:23 <jrm2k6> ok
19:15:25 <jle`> but
19:15:31 <jle`> you can't combine monads within one do block
19:15:34 <jle`> that doesn't really make sense
19:15:34 <dolio> Happily.
19:15:46 <jle`> your whole block is a giant list monad
19:15:57 <jrm2k6> jle`: so i should do the unwords before the do statement
19:15:57 <jle`> so you can't throw in putStrLn "LOL"
19:16:07 <structuralist> i.e. do view patterns support writing something like f (something -> ...) instead of  f a b = case (something a b) of ...
19:16:09 <jle`> you can do that
19:16:14 <jle`> or you can use a let binding
19:16:15 <djahandarie> dolio, yeah, it's not the nicest thing -- at least the version that works on non-equally sized lists (and is efficient) is not terribly nice.
19:16:26 <jle`> do { let r = map ...; putStrLn "hey" }
19:16:29 <jrm2k6> but what i dont get is that if i put putStrLn alone
19:16:31 <jrm2k6> it will work
19:16:44 <jrm2k6> ok
19:16:45 <jle`> try putting the type signature
19:16:47 <jle`> on tablen
19:16:48 <jle`> and you'll see
19:16:54 <jle`> hm.
19:17:08 <jle`> so how do blocks work
19:17:21 <jle`> is they basically squish IO actions together
19:17:39 <jle`> kind of like && in bash
19:17:47 <jle`> every line has to be an IO action
19:17:51 <jle`> or else it doesn't make any sense
19:18:03 <jrm2k6> oh ok
19:18:07 <jle`> a do block takes several IO action objects and returns one big IO action object
19:18:11 <jrm2k6> got that
19:18:21 <jrm2k6> so if one of them is not an IO -> BIM
19:18:29 <jle`> remember that putStrLn "hello" isn't really an action that when is evaluated prints hello
19:18:36 <jle`> it's actually a plain old object
19:18:51 <jle`> that represents the act of printing hello
19:18:59 <jrm2k6> wait what, 'plain old object'?
19:19:02 <jrm2k6> ok
19:19:04 <jle`> it's an object
19:19:05 <jle`> like a list
19:19:07 <jle`> or a map
19:19:07 <jrm2k6> ok
19:19:09 <jle`> or a string
19:19:12 <jrm2k6> i see
19:19:14 <jle`> it's not any different than any other object.
19:19:35 <jrm2k6> yeah i ot it
19:19:38 <jle`> you can think of it as...maybe...a little packet of C code.
19:19:49 <jrm2k6> it is just funny to read 'object' for a functional language
19:19:52 <jle`> it represents an instruction
19:19:54 <jle`> ah yeah.
19:19:57 <jrm2k6> but i know what you mean
19:20:10 <jle`> so when you do { putStrLn "hello"; putStrLn "world" }
19:20:17 <jle`> you are combining the two separate objects representing actions
19:20:20 <jle`> into one "big" action
19:20:22 <jle`> that prints both lines
19:20:24 <jrm2k6> yes
19:20:33 <jle`> now every action has a result
19:20:37 <jle`> but when you do do notation like this
19:20:40 <jle`> you lose the result
19:20:42 <jle`> it's gone forever
19:20:49 <jrm2k6> yes
19:20:51 <jle`> however, do notation gives you a way to "name" the result, to use it in a later sequence
19:20:57 <jrm2k6> because in this case, it is just the action which is visible
19:21:16 <jle`> well, only the result of the final action is the result of the entire IO action
19:21:19 <jle`> the entire big IO.
19:21:26 <jle`> so you lose the results of all the intermediates.
19:21:30 <jrm2k6> yes
19:21:35 <jle`> do notation allows us a way to capture the results and name them for usage later
19:21:37 <jle`> and that's <-
19:21:45 <jle`> and it only makes sense in this case for IO actions
19:21:46 <edwardk> djahandarie: i did. it was too slow to be useful for me though below abut 50 billion items. look in old branches of structures
19:21:51 <jrm2k6> so it is just a let for monads.
19:21:53 <jle`> because remember...all you're doing is squishing IO actions together
19:22:01 <jle`> you can kind of think of it that way
19:22:10 <jle`> for now
19:22:11 <jrm2k6> as a huge simplification
19:22:35 <jle`> yeah when you start out you can just think of it like a way of extracting out of an IO
19:22:39 <jle`> don't worry about monads
19:23:00 <jle`> but remember that every line in a do block
19:23:03 <jle`> has to be an IO action
19:23:07 <jle`> (or has to be the same monad, etc.)
19:23:14 <danharaj> edwardk: have you thought about the relationship between the coalgebras of a comonad w and the monad transformer CoT w? I have and I haven't gotten many ideas.
19:23:14 <jle`> because that's the only way it makes sense
19:23:34 <jle`> do blocks are a way to squish multiple IO actions into one giant IO action...so you can't have a line that isn't an IO action, what would it even mean?
19:23:47 <jrm2k6> ok
19:23:58 <jrm2k6> i see
19:24:38 <djahandarie> edwardk, what were you comparing it to? Just building a big vector and binary searching it?
19:24:47 <djahandarie> Or binary searching the individual vectors?
19:24:53 <jrm2k6> so if i do : do {r <- functionGivingBackAList; putStrLn "lol"} it is not the same monad which is use
19:24:54 <jrm2k6> used
19:25:12 <jle`> functionGivingBack has to be IO a
19:25:33 <jle`> because it's the same as do { functionGivingBackAList; putStrLn "lol" }
19:25:35 <jle`> and if it helps you
19:25:41 <jle`> the semicolon is just an operator
19:25:43 <jle`> it's called (>>)
19:25:45 <jle`> :t (>>)
19:25:46 <lambdabot> Monad m => m a -> m b -> m b
19:25:53 <jrm2k6> yes i ve seen that but havent digged into that yet
19:25:55 <jle`> functionGivingBackAList >> putStrLn "lol"
19:25:58 <jrm2k6> i wanna understand the reste of it
19:25:59 <edwardk> djahandarie: comparing it to... both using bloom filters per level and to just doing nothing and paying the log^2 cost for searching too much
19:26:06 <edwardk> djahandarie: the constants are relatively trrible
19:26:12 <jle`> yeah, i'm just letting you know that the semicolon has a "type"
19:26:18 <jle`> the semicolon can only "glue" two things of the smae monad
19:26:22 <jrm2k6> jle`: so how do i make functionGivingBackList an IO?
19:26:26 <jle`> well
19:26:36 <jle`> you can wrap any value in an IO
19:26:39 <jle`> using return
19:26:42 <jle`> but that's probably not what you want
19:26:45 <jle`> you can just use let
19:26:47 <djahandarie> edwardk, hm. But the asymptotics are so cool!
19:26:56 * djahandarie implements it anyways just to see what happens.
19:26:59 <edwardk> danharaj: not really beyond what we talked about on facebook on the related front
19:27:02 <jrm2k6> ok
19:27:05 <danharaj> ah.
19:27:05 <jle`> let a = f
19:27:07 <jle`> is the same as
19:27:09 <jle`> er
19:27:12 <jle`> let a = f
19:27:14 <jle`> is the same as
19:27:18 <jle`> a <- return f
19:27:27 <edwardk> djahandarie: check the back history of structures it is in there. it is just hugely slower (e.g. 50x+)
19:27:28 <jle`> so don't do that heh.
19:27:49 <jrm2k6> ok
19:28:03 <jle`> you've used bash before?
19:28:04 <jrm2k6> so using a let is better
19:28:05 <jrm2k6> yep
19:28:09 <jle`> the semicolons/>>'s are like &&'s
19:28:15 <edwardk> djahandarie: i'm currently wrking on making the new fully deamortized form for structures faster by using more dirty tricks
19:28:20 <jle`> so you can't do echo "hello" && 6 && cat file
19:28:25 <jle`> only a command can go there
19:28:28 <jrm2k6> yep
19:28:30 <jle`> so what you can do, in bash-land
19:28:34 <jle`> is we use echo
19:28:42 <jle`> or something
19:28:44 <jle`> idk
19:28:50 <jle`> well, echo works in this context kinda
19:28:52 <jrm2k6> i get your point
19:28:55 <jle`> echo 6 && cat file
19:29:04 <jle`> because >>= and _ <-
19:29:09 <jle`> is kinda like a pipe
19:29:18 <jle`> echo "hello" | cat
19:29:44 <jle`> a pipe is like a && but you get to use the result of the left hand side
19:30:04 <jrm2k6> yep
19:30:06 <jrm2k6> nice analogy
19:30:07 <jle`> so 'return 6' in this case would be like 'echo 6'
19:30:13 <jle`> turns the value into an action, so you can pipe it.
19:30:15 <cmears> Is there any easy way to make "cabal build" faster?  For my project it takes nearly 2 seconds to figure out nothing needs to be built
19:30:25 <jrm2k6> jle`: ok using a let it works well
19:30:35 <jrm2k6> i think i should practice on a bigger do statement
19:30:44 <jrm2k6> to really see whats going on
19:30:54 <jrm2k6> gonna do it in a while
19:31:09 <jrm2k6> thanks for your explanations! really useful
19:31:20 <jle`> try doing something like asking for a name, an age, then printing out a greeting.
19:31:30 * hackagebot split-tchan 0.1.0.0 - STM's TChan split into sending and receiving halves.  http://hackage.haskell.org/package/split-tchan-0.1.0.0 (LeonSmith)
19:31:35 <jrm2k6> yes
19:31:43 <jle`> no problem! channel is always open
19:31:45 <jrm2k6> example from LYAH
19:31:51 <jle`> haha yeah
19:31:51 <jrm2k6> I ve seen that! Thats really cool
19:33:02 <mm_freak> cmears: you can try to circumvent cabal and use Setup.lhs instead
19:33:16 <mm_freak> ./Setup.lhs build
19:34:30 <cmears> mm_freak, I'm afraid that doesn't work with the cabal sandbox ):
19:34:55 <cmears> What I really need is "cabal sandbox shell"
19:35:08 <mm_freak> alternatively you can use nix for building, but it has a learning curve
19:35:56 <mm_freak> that would give you sandboxes without cabal
19:36:10 <cmears> Ah, thanks for the suggestion
19:36:26 <cmears> I guess I could give hsenv another go too
19:38:13 <mm_freak> one interesting feature of nix is that you get sandboxes with sharing
19:40:24 <cmears> This shell hack is enough for me for now: https://github.com/haskell/cabal/issues/1627#issuecomment-32062545
19:49:31 <defanor> just finished that range thing, but now have some error which i don't understand: when trying (with Text.Parsec) special = oneOf "[]\\`_^{|}", getting "No instance for (Stream s0 m0 Char) arising from a use of `oneOf'". what does it mean?
19:50:15 <enthropy> defanor: have you tried to use special in code that actually calls some runParser?
19:50:36 <defanor> enthropy: nope. is it the problem?
19:50:39 <enthropy> @where dmr
19:50:39 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
19:51:16 <defanor> uh, that thing again. thanks
19:51:28 <pavonia> What does the 'd' stand for?
19:51:33 <enthropy> dreaded
19:51:40 <pavonia> heh
19:53:26 <enthropy> defanor: it's not so bad
19:53:44 <enthropy> you could just add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file
19:53:54 <enthropy> of special :: Parser Char
19:54:04 <enthropy> *or
19:55:12 <defanor> enthropy: nice, thanks again
19:55:27 <sccrstud92> ive got some code with a space leak (I think) and i was wondering if anyone was bored enough that they would like to take a look at it
19:55:40 <sccrstud92> ive spent about 5 days trying to fix it but no luck
19:56:15 <enthropy> sccrstud92: impressive. How much code is it?
19:57:53 <sccrstud92> around 50 lines of actual code
19:58:05 <sccrstud92> its a counting sort implementation with parsing of input
19:58:10 <sccrstud92> nothing crazy
19:59:05 <bergey> I'm trying to learn Data.Vinyl, and have my first-ever kind error:  http://lpaste.net/99154
19:59:34 <bergey> What am I doing wrong?  How do I convince ghc that [Color] is a list at the kind level?
19:59:35 <enthropy> bergey: '[Color]
20:00:12 <bergey> enthropy: Ah, thanks.  Is that only needed when the list has a single member?
20:00:21 <sccrstud92> this is the counting sort im having trouble with http://lpaste.net/99155
20:00:29 <enthropy> or zero
20:00:44 <bergey> Makes sense.  Working now, great.
20:01:42 <enthropy> learn hlist instead :p
20:04:03 <sccrstud92> when i give it a list of 1000000 inputs
20:04:08 <sccrstud92> it used 320mb
20:04:21 <sccrstud92> actually
20:04:31 <sccrstud92> when i run with +RTS -p
20:04:47 <sccrstud92> it says total alloc is 900,000,000 bytes
20:04:54 <sccrstud92> which seems like too much
20:05:51 <bergey> enthropy: is there an hlist-gl? :)
20:09:23 <Twey> Huh, for some reason Haddock renders '[] as `[]`
20:09:44 <Twey> Fuuzetsu: ↑ http://hackage.haskell.org/package/HList-0.3.0.1/docs/Data-HList-HList.html#t:HList
20:10:54 <enthropy> bergey: not yet?
20:11:07 <novochar> What is static typing?
20:11:33 <sccrstud92> novochar: i believe it means that everything's type is known at compile time
20:11:41 <novochar> My intuition is that once you declare a variable, that variable cannot change. I think, though, there is more to this definition, and maybe even a way of formalizing this definition.
20:11:52 <carter> novochar: theres a book or two on this
20:12:06 <carter> TAPL is high school / undergrad friendly
20:12:10 <carter> and theres fancier books too
20:12:48 <enthropy> Twey: there's a long list of reasons haddock doesn't do justice. I think some of the blame lies in how the ghc-api prints stuff
20:13:41 <td123> novochar: maybe you're thinking about referential transparency?
20:14:05 <carter> oh boy
20:15:40 <Twey> novochar: In a CS context, typing is the ability to infer properties that code will have at runtime by inspecting the structure of the terms before runtime
20:16:34 <Twey> novochar: ‘Dynamic typing’ is an analogous but unhelpful name for the concept of attaching similar information to values at runtime
20:17:04 <Twey> enthropy: I can't imagine the GHC API is responsible for that one
20:17:13 <maxiepoo> ew github's lhs rendering is pretty bad: https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcArrows.lhs
20:17:21 <Twey> 'foo and `foo` are quite different things
20:17:36 <Twey> maxiepoo: What LHS rendering?
20:17:46 <enthropy> lack thereof
20:18:04 <enthropy> Twey: haddock doesn't even support type family instances
20:18:08 <ReinH> maxiepoo: yeah it thinks you're using markdown basically and doesn't understand TeX-style
20:18:11 <ReinH> :/
20:18:16 <ReinH> but if you're doing it the way github wants it's quite nice
20:18:24 <enthropy> proper support for datakinds is going to arrive by 2020
20:18:27 <ReinH> maxiepoo: like https://gist.github.com/reinh/8587382
20:18:30 <Twey> maxiepoo: It only even recognized the last bit as code because you accidentally triggered the GH-Markdown ~~~~ syntax
20:18:30 <maxiepoo> does anyone know where that's implemented? Maybe I'll submit a patch
20:18:47 <ReinH> it does support bird ticks
20:18:51 <maxiepoo> ah so it only works with the birds
20:19:19 * enthropy thought > were Bird tracks
20:19:49 <Twey> Yeah
20:19:58 <Twey> I think they're named after the fact that they look like bird footprints, though there might be some connection to Bird there :þ
20:21:54 <ReinH> bird tracks yeah
20:22:00 <ReinH> whatever
20:22:19 <ReinH> we don't really strive for accuracy with our pun namings
20:23:25 <pavonia> sccrstud92: Can you paste your profiling report too?
20:23:45 <sccrstud92> is that the one generated by +RTS -p?
20:23:55 <sccrstud92> pavonia: is that the one you mean?
20:24:07 <pavonia> yes
20:25:11 <sccrstud92> pavonia: http://lpaste.net/99156
20:28:41 <dhrosa> what does CAF mean?
20:28:43 <pavonia> sccrstud92: And how big is your input data in bytes?
20:28:53 <lingxiao> hey all, could someone take a glance at this question on SO please :)
20:28:54 <lingxiao> http://stackoverflow.com/questions/21394879/how-would-you-abstract-away-the-boilerplate-in-this-pair-of-similar-shaped-dat
20:28:58 <lingxiao> thanks you!
20:29:03 <maxiepoo> looks like the lhs renderer is here: https://github.com/jm/literati
20:29:37 <maxiepoo> writing an lhs compiler in ruby feels so wrong though >.<
20:29:38 <sccrstud92> pavonia: 5,762 KB
20:29:50 <pavonia> Oh wow
20:29:57 <ski> @wiki Constant applicative form
20:29:58 <lambdabot> http://www.haskell.org/haskellwiki/Constant_applicative_form
20:30:00 <sccrstud92> smaller or larger than you expected?
20:30:03 <ski> dhrosa ^
20:30:09 <pavonia> much smaller
20:30:19 <sccrstud92> yeah each string is only 2 chars
20:30:25 <sccrstud92> in this test case
20:30:28 <sccrstud92> but not in general
20:36:38 * hackagebot network-conduit 1.0.2.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.2.1 (MichaelSnoyman)
20:39:45 <pavonia> sccrstud92: Just a shot in the dark, does it help to give strictness annotations in the accumulation functions ('f')?
20:42:25 <maxiepoo> looks like there's already a pygments version so maybe I should just submit a patch that uses pygments instead of literati
20:42:26 <maxiepoo> http://pygments.org/docs/lexers/
20:42:40 <sccrstud92> pavonia: i added a bang in front of "acc" but the memory usage is exactly the same. might have sped it up a tiny bit though
20:44:06 <pavonia> the problem seems to be entryParser but I have no idea why
20:45:05 <sccrstud92> yeah thats as far as i got as well
20:58:04 <lispy> unneeded bangs usually slow programs down
20:58:20 <pavonia> sccrstud92: The implementation of takeWhile1 looks suspicious, try to rewrite "takeWhile1 (not . isEndOfLine)" to "many1 (satisfy (not . isEndOfLine))" or so
20:58:26 <lispy> ghc doesn't track which thunks are already normalized so it can cause redundant computations
20:58:28 <dhrosa> there should be a contest to see the best lambadbot pl output vs. number of input chars
20:59:08 <lispy> (deepSeq is much worse about that than just seq/!, of course)
20:59:34 <sccrstud92> pavonia: strange, i used takeWhile1 because it was recommended over many1 in the Data.Attoparsec library notes
20:59:38 <jle`> @pl \xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -> f xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
20:59:38 <lambdabot> f
20:59:45 <jle`> dhrosa
20:59:52 <sccrstud92> pavonia: http://hackage.haskell.org/package/attoparsec-0.8.0.2/docs/Data-Attoparsec.html
20:59:52 <shachaf> deepSeq is the scow of forcing. Don't use it unless you know what you're doing.
20:59:54 <pavonia> sccrstud92: Yeah, I saw that too
20:59:58 <sccrstud92> ah k
21:00:03 <sccrstud92> ill rewrite and try
21:00:22 <lispy> shachaf: it's great for debugging, but I often delete the instances before commiting :)
21:00:39 <shachaf> lispy: "forcing" a forced thunk usually isn't such a big deal -- it'll just check the tag bit anyway.
21:00:45 <dhrosa> jle`: I mean in the opposite direction :)
21:01:03 <shachaf> I think a bigger issue is forcing things that don't need to be forced.
21:01:13 <dhrosa> (length of pl output) / (length of input)
21:01:22 <shachaf> And also not having any idea what your code is doing. That's a pretty big issue.
21:02:18 <lispy> I've been learning some 6502 programming and it's interesting how you could know so much more about what your program was doing than you do these days.
21:02:40 <johnw> lispy: I know, right?
21:02:47 <johnw> 6502 was my first real language
21:02:50 <lispy> The C runtime is pretty big and complex, the OS even more so, and then you have all the microarchitecture stuff.
21:04:08 <lispy> johnw: there is a competition to make an NES game. Ends in April. If you like 6502 programming, it might be a fun side project :)
21:04:22 <johnw> those days are rather long past :)
21:05:00 <lispy> I've been looking at cc65 a C compiler for 6502 to automate as much as I can. I've also considered making an eDSL for doing it. Haskell is great for that.
21:05:02 <sccrstud92> pavonia: "total alloc = 1,214,657,484 bytes"
21:05:13 <sccrstud92> i dont think it worked
21:05:23 <pavonia> :)
21:05:32 <sccrstud92> T.T
21:05:39 <pavonia> okay, I'm out then
21:05:47 <sccrstud92> T.T
21:05:55 <sccrstud92> thx for looking at it
21:06:05 <sccrstud92> i might post on SO
21:06:10 <sccrstud92> or /r/haskell
21:06:19 <lispy> sccrstud92: can I see your code?
21:06:30 <sccrstud92> lispy: http://lpaste.net/99155
21:06:36 <lispy> thanks
21:06:38 <pavonia> I'd try to investigate all functions individually
21:06:47 <sccrstud92> lispy: profile report http://lpaste.net/99156
21:07:30 <johnw> sccrstud92: the result of f at the very bottom will be a pair of hunks that will hold every generation of "acc" in memory
21:07:36 <lispy> sccrstud92: you can upload the graphs too for us to visualize: http://heap.ezyang.com/
21:07:41 <sccrstud92> the input was a file with 1 million entries and each string was 2 chars long
21:07:46 <lispy> sccrstud92: are you trying to get rid of a memory leak?
21:07:51 <sccrstud92> yeah
21:07:57 <sccrstud92> im assuming there is one
21:08:14 <sccrstud92> i added a bang to "acc" param in f
21:08:20 <sccrstud92> memory usage was exactly the same
21:08:34 <sccrstud92> maybe optimizer is taking care of that already?
21:08:36 <johnw> sccrstud92: I'd try:  f acc e = let !x = acc + e; !y = acc + e in (x, y)
21:08:44 <johnw> oh, hehe
21:08:47 <sccrstud92> k
21:08:54 <johnw> let !x= acc + e in (x, x)
21:09:19 <sccrstud92> oh i changed the wrong f before lol
21:09:45 <sccrstud92> thats what i get for uninspired naming conventions
21:09:47 <johnw> btw, is this a heap leak or a stack overflow?
21:10:11 <lispy> :t uncurryv
21:10:12 <lambdabot>     Not in scope: `uncurryv'
21:10:12 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
21:10:19 <lispy> :t uncurry
21:10:19 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:10:30 <lispy> oh, I see what hlint is saying
21:10:46 <lispy> (and I would ignore it)
21:10:56 <Anpheus__> Anyone here confident in answering some tricky (to me) FFI questions?
21:11:11 <shachaf> @where justask
21:11:12 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
21:11:25 <Anpheus__> Hah, okay.
21:11:36 <johnw> Anpheus__: shoot
21:11:42 <sccrstud92> no change
21:11:50 <Anpheus__> https://github.com/AaronFriel/hyhac/blob/master/src/Database/HyperDex/Internal/Attribute.chs
21:11:59 <johnw> sccrstud92: is this a heap leak or a stack overflow?
21:12:06 <sccrstud92> how can i tell?
21:12:17 <sccrstud92> it runs to completion so im assuming its not a stack overflow
21:12:18 <Anpheus__> This code works for me but isn't ideal because the Storable instance allocates additional data (it's a complex object)
21:12:24 <johnw> is your program crashing because it's exceeded stack size, or is the process memory size climbing into the stratosphere?
21:12:33 <sccrstud92> second one
21:12:39 <sccrstud92> it doesnt crash
21:12:50 <Anpheus__> It doesn't make sense to me that the Storable class doesn't have a "free" function for instances
21:13:04 <johnw> ah; so, you are either allocating tons of hunks, or a few hunks that are preventing memory from being GC'd, or both
21:13:25 <sccrstud92> sounds about right
21:13:32 <johnw> Anpheus__: what does Storable have to do with allocation?
21:13:39 <sccrstud92> and lispy yeah i purposefully didnt use uncurry
21:13:42 <johnw> you allocate the memory, then serialize the Storable into it
21:13:46 <Anpheus__> Creating the pointers to and from stuff - `alloca`, etc
21:14:00 <Anpheus__> The problem is that if you use `alloca` with this class, you're screwed.
21:14:13 <Anpheus__> Alloca doesn't know to free the C-strings inside the class
21:14:15 <johnw> Anpheus__: can you show me some code?
21:14:21 <Anpheus__> https://github.com/AaronFriel/hyhac/blob/master/src/Database/HyperDex/Internal/Attribute.chs
21:14:30 <lispy> sccrstud92: Is this actually efficient with attoparsec? (endOfLine <|> endOfInput)
21:14:42 <lispy> sccrstud92: If you change that to endOfLine for now, does it improve things?
21:14:55 <sccrstud92> i think i tried that before but ill check again
21:15:04 <johnw> endOfLine <|> endOfInput is incorrect, btw
21:15:11 <sccrstud92> how so?
21:15:12 <johnw> imagine the string ".<EOF>".  That parser will match that
21:15:17 <Anpheus__> johnw: this is FFI interop stuff, so when I allocate the object it must have a particular implementation
21:15:23 <johnw> because endOfLine will consume the ".", fail, then parse the EOF and succeed
21:15:30 <johnw> use: try endOfLine <|> endOfInput
21:15:36 <lispy> johnw: that's for parsec
21:15:40 <lispy> johnw: this is atto parsec
21:15:42 <johnw> ahh
21:15:43 <Anpheus__> one second
21:15:48 <sccrstud92> oh thx lispy
21:15:50 <sccrstud92> i was confused lol
21:15:52 <Anpheus__> (will be right back)
21:15:58 * ski . o O ( `endOfInput' :/ )
21:16:42 * hackagebot highlighting-kate 0.5.6.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.6.1 (JohnMacFarlane)
21:17:19 <sccrstud92> lispy: that change changed total alloc to "874,668,432 bytes"
21:18:03 <sccrstud92> which would be a good savings if it wasnt so high to begin with
21:18:11 <lispy> sccrstud92: did it lower the total memory usage? It would help if you could upload a .hp file when using type based profiling or retainer profiling.
21:18:21 <sccrstud92> sure i can do that
21:18:26 <sccrstud92> which options do you want to see
21:18:37 <sccrstud92> and do u want the hp or the ps file
21:18:38 <lispy> I think type based is -y
21:18:38 <johnw> sccrstud92: everywhere that you have are constructing a tuple is a potential memory leak in this scenario, btw
21:18:51 <lispy> sccrstud92: upload it here
21:18:53 <lispy> http://heap.ezyang.com/
21:19:02 <lispy> That website is a .hp visualizer
21:19:21 <lispy> sccrstud92: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
21:19:27 <lispy> sccrstud92: that says -hy for types
21:19:35 <sccrstud92> k
21:19:40 <lispy> sccrstud92: and you have to profile it separately for retainer, which is -hr
21:19:57 <lispy> and -hc is also useful
21:20:33 <lispy> I'm pretty sure that a few things are going on. So, that alternative in the parser causes thunks to stick around (it's waiting to figure out if it needs to backtrack)
21:21:01 <sccrstud92> ooh that is pretty http://heap.ezyang.com/view/bd28ee5734e6967b1e741d875ce988822db9fe08#form
21:21:14 <sccrstud92> that is types
21:21:33 <lispy> Also, the mapAccumL mapAccumR places (cumSum and replace) are both going to be very lazy. Depending on how the input representation compares to the final representation that might not be good.
21:21:39 <lispy> thanks, lookjing
21:21:54 <johnw> sccrstud92: this module may help you: http://hackage.haskell.org/package/strict-0.3.2/docs/Data-Strict-Tuple.html
21:21:57 <lispy> sccrstud92: Okay, so how to read this.
21:21:59 <johnw> since you are using tuples all over the place
21:22:30 <lispy> sccrstud92: Notice how it goes up mostly monotonically and then has this steep drop off? That means that it's building up lots of stuff in memory and then finally it gets to a point where it reduces it all down to the answer.
21:22:33 <danharaj> edwardk: http://ncatlab.org/nlab/show/adjoint+monad
21:22:44 <danharaj> think I found a good lead. intrigued by these 'mates' I keep hearing about.
21:23:12 <lispy> sccrstud92: and if you switch to "overlayed area graph" you see that the bytestring is initially the big space waster
21:23:12 <sccrstud92> http://heap.ezyang.com/view/c3eb8f48249f6a4b36577c8ec43cf4f8c159f9f7#form retainers
21:23:25 <lispy> sccrstud92: but then that switches to tuples
21:23:45 <sccrstud92> i see
21:23:46 <lispy> sccrstud92: that's a hint that the parser is initially holding all the strings in memory until tuples are constructed
21:23:57 <sccrstud92> will the strict tuple fix that?
21:24:20 <lispy> I'm not sure. It could be that the container for the tuple should be strict.
21:24:45 <lispy> So now looking at the retainer stuff.
21:24:46 <johnw> even better might be to use your own data types and make them strict
21:24:54 <lispy> This tells us where the expensive thunks are located.
21:25:06 <lispy> I'm not sure what SYSTEM means :(
21:25:13 <lispy> That's probably related to bytestring's storage
21:25:35 <lispy> So at the beginning we see that entryParser is holding on to a lot. That matches what we saw before.
21:25:44 <sccrstud92> i couldnt find any string-type that was more memory efficient than bytestring
21:25:50 <lispy> next up is "freqs.\"
21:26:01 <lispy> sccrstud92: Yeah, bytestring is good. It's how you're using it.
21:26:10 <sccrstud92> good
21:26:20 <lispy> sccrstud92: Things get evaluated as they're needed. If you have a term, it evaluates outside in.
21:26:31 <lispy> also, replace is costly
21:26:46 <lispy> oh, SYSTEM could also be vector
21:27:08 <sccrstud92> replace is costly because im not evaluating the string until im printing it?
21:27:14 <sccrstud92> right?
21:27:30 <sccrstud92> so half the elements will have thunks from that
21:27:38 <lispy> oh that could be
21:28:18 <sccrstud92> alright can i switch to strict tuple and see if that makes a difference?
21:28:25 <lispy> Yeah
21:28:27 <sccrstud92> k
21:28:37 <sccrstud92> might take 5-10 minutes cuz i havent used em before
21:28:52 <johnw> sccrstud92: if it doesn't help, I'd be very surprised to learn what is keeping the values in memory
21:29:15 <johnw> since you aren't really using any other structures here
21:29:16 <sccrstud92> do you know how strict vectors are?
21:29:53 <johnw> I *think* boxed vectors should be like anything else, but I'm not that familiar with vectors
21:29:58 <lispy> the unboxed ones are strict. So I bet the boxed ones (which is what you have to use) is lazy?
21:31:07 <lispy> I kind of what what would happen if you had: return (numLines, fromList entries) -> return $! (numLines, rnf (fromList entries))
21:31:25 <sccrstud92> i can try that next
21:31:26 <johnw> lispy: that won't evaluate the contents of the tuple
21:31:33 <AaronFriel_> Hey, johnw - this is the guy earlier asking about FFI and Storable
21:31:34 <markovirc_> Hello AaronFriel_
21:31:38 <lispy> johnw: You're right. I was just about to say that :)
21:31:40 <AaronFriel_> I'm trying to figure out how to get my name to correctly show up
21:31:41 <johnw> it just evaluates the tuple to WHNF, which it already is :)
21:31:49 <AaronFriel_> The underscore after the nick is frustrating me
21:32:04 <lispy> AaronFriel_: /msg nickserv help
21:33:26 <sccrstud92> does data.strict.tuple come with ghc?
21:33:42 <sccrstud92> *haskell platform
21:33:52 <johnw> sccrstud92: I think that usually if people start needing strict tuples, they're already close enough to needing their own strict data types that they don't bother with Pair
21:34:53 <lispy> sccrstud92: you just need something like data Pair a b = !a :*: !b deriving (Read, Show, Eq, Ord)
21:35:02 <sccrstud92> k ill do that
21:35:37 <lispy> if you don't mind enabling TypeOperators you can even make it data a :*: b = !a :*: !b
21:35:59 <shachaf> data a * b = !a :*: !b
21:36:00 <sccrstud92> i already have Pair typed everywhere XD
21:36:11 <shachaf> (Though :*: usually means something else. And so does *, really.)
21:36:25 <lispy> shachaf: ML has strict pairs :)
21:36:37 <sccrstud92> doesnt ML have strict everything?
21:36:42 <lispy> yes
21:37:04 <lispy> I was just jokingly justifying * as the operator name.
21:37:56 <shachaf> ML?
21:38:44 <Twey> shachaf: MetaLanguage.  It's a formally-specified, strict, impure functional language.
21:39:03 <Twey> (well, SML is)
21:39:38 <lispy> right and the types of tuples use * to make you think of cartesian products
21:40:25 <Twey> ML syntax is weird, though.  I don't understand why they decided to make the syntax of type functions backwards from the syntax of value functions.
21:40:25 <AaronFriel> I return
21:40:42 <sccrstud92> lispy: its okay to keep using normal tuples for mapAccumL and mapAccumR right? or do I have to rewrite those?
21:40:47 <AaronFriel> I think I just registered several accounts on FreeNode but that is their problem now, I think
21:40:54 <Twey> ‘floor a’ but ‘'a list’
21:41:03 <lispy> sccrstud92: sure
21:41:06 <ski> integer-list vs. `int list'
21:41:21 <AaronFriel> johnw: Sorry for my frequent departures, did I convey my problem with alloca and Storable well enough?
21:41:24 <lispy> sccrstud92: could you please update the lpaste code when you're done so I can check?
21:41:28 <sccrstud92> ofc
21:41:39 <johnw> AaronFriel: not at all yet; did you paste me some code?
21:41:42 <sccrstud92> do i actualy edit the old one or make a new one?
21:41:54 <Twey> ski: And then they have ‘of’ in datatype definitions — so instead of ‘list of int’ you get ‘cons of 'a * list’
21:41:59 <AaronFriel> I sent a link to github - is it getting filtered out or somesuch?
21:42:04 <shachaf> Twey: I know what ML is.
21:42:26 <johnw> let me scroll back
21:42:36 <ski> Twey : yes
21:42:39 <johnw> ah, found it
21:42:42 <lispy> sccrstud92: I think you can do both. "Edit" is update and I'm not sure what the other things do :)
21:42:44 <Twey> shachaf: I thought you probably did, but didn't know how else to interpret your question
21:42:49 <johnw> AaronFriel: what line should I be looking at?
21:42:56 <shachaf> "what does ML have to do with anything?"
21:43:23 <Twey> Ah, but lispy already explained that it was a joke
21:43:44 <AaronFriel> Well, the deal is I have this Storable instance for a C-type, and the spec for the C type is here: https://github.com/AaronFriel/hyhac/blob/unified-backend/include/hyperdex/client.h
21:44:01 <Twey> lispy: ‘Edit’ creates a new paste ☹
21:44:04 <AaronFriel> The problem is, if I use this Storable instance with say, "alloca", or even "malloc" and "free", I have a memory leak
21:44:04 <ski>   val foldr : ('a * 'r -> 'r) -> 'r -> 'a list -> 'r  (* tuple types are written with `*'s *)
21:44:17 <dhrosa> Twey is the unicode wizard
21:44:18 <lispy> Twey: I see. It seems that things have changed.
21:44:37 <AaronFriel> Is this normal for interop code? Is there something else I should be using?
21:44:38 <Twey> They've always been that way — I was confused about it a while ago
21:45:03 <johnw> AaronFriel: I would use Bindings-DSL and then you shouldn't need to deal with a Storable instance at all
21:45:07 <sccrstud92> lispy: johnw: updated http://lpaste.net/99155
21:45:13 <lispy> thanks, looking
21:45:14 <johnw> sccrstud92: what's the behavior now?
21:45:27 <sccrstud92> negligible difference
21:45:33 <Twey> ski: I'm okay with the tuple syntax and I think the explicit quotation of type variables is nice
21:45:35 <johnw> ok, I'm going to run it here
21:45:43 <johnw> sccrstud92: do I need an input data set?
21:45:49 <sccrstud92> yeah
21:45:54 <sccrstud92> should i just paste the file?
21:45:59 <sccrstud92> its kinda large
21:46:08 <Twey> It's just that type function syntax that gets me
21:46:10 <johnw> sure
21:46:10 <sccrstud92> for pasting i mean
21:46:13 <sccrstud92> k
21:46:16 <johnw> i don't mind where you put it
21:46:37 <ski> Twey : iirc, Ur doesn't do that
21:46:44 <lispy> sccrstud92: I bet the .hp is different. I bet the peaks shuffled about. You might want to change your $s to $!s
21:46:50 <Twey> Neat
21:46:57 <johnw> sccrstud92: Are you sure about this code?  ghc says that cumSum is not defined
21:47:15 <AaronFriel> johnw: Is there some place I should be looking at for an example of a project that has used bindings-DSL?
21:47:24 <lispy> sccrstud92: I see why it didn't change anything.
21:47:25 <johnw> AaronFriel: sure, one sec
21:47:28 <lispy> sccrstud92: You didn't add the rnf
21:47:54 <sccrstud92> lispy i was doing just strict first
21:48:10 <sccrstud92> i can add the other suggestion now
21:48:10 <Twey> Ur looks more Haskellish, actually
21:48:22 <Twey> (on the type level)
21:48:29 <sccrstud92> johnw i made a mistake in the copy step or the paste step but i fixed it now
21:48:35 <johnw> AaronFriel: for example: https://github.com/fpco/gitlib/blob/master/hlibgit2/Bindings/Libgit2/Types.hsc#L92
21:48:43 <sccrstud92> -- Enter your code here. Read input from STDIN. Print output to STDOUT
21:48:44 <sccrstud92> {-# LANGUAGE BangPatterns, OverloadedStrings #-}
21:48:45 <sccrstud92> import Control.Arrow
21:48:45 <sccrstud92> import Control.Applicative hiding (empty)
21:48:45 <sccrstud92> import Control.Monad hiding (forM_)
21:48:45 <sccrstud92> import Control.Monad.ST
21:48:51 <johnw> using those macros (and hsc2hs), will generate all the stuff you need
21:48:51 <lispy> sccrstud92: Just so you know, seq (or bang) on a list just focuse the head cons of the list. The rest of the spine is left unevaluated.
21:49:16 <Twey> ski: Do you know how the Ur compiler works?  Is it MLKit-based?
21:49:18 <johnw> AaronFriel: it also generates the Storable instances
21:49:29 <defanor> i have three parsec parsers in a single expression here, all of them are strings; want to make a single string. can make up only smth like liftM3 + lambda with three args, or a separate higher-order function, but i suspect there should be some standard/proper way for that. what that way is?
21:49:31 <sccrstud92> sorry!
21:49:34 <AaronFriel> johnw: I don't think I'm quite conveying my problem with Storable :(
21:49:38 <sccrstud92> lispy and johnw u still here?
21:49:42 * lispy nods
21:49:44 <sccrstud92> fixed the paste http://lpaste.net/99155
21:49:54 <sccrstud92> okay i had to refresh
21:49:57 <johnw> AaronFriel: can you try again?
21:50:00 <sccrstud92> wat was that rnf change lispy?
21:50:04 <johnw> sccrstud92: where is the data set?
21:50:09 <sccrstud92> use $! and rnf the tuple?
21:50:12 <AaronFriel> johnw: The issue is the data type I am marshalling has pointers to C-Strings contained in it - and that won't get freed when you do say, an "alloca" or a "allocArray" and so on
21:50:17 <sccrstud92> oh right srry johnw
21:50:43 <lispy> sccrstud92: Okay, so what I'm trying to get at is that in the `fromList blah` putting that in a strict tuple doesn't do much of anything.
21:50:46 <AaronFriel> johnw: Storable seems to have been designed for purely flat (continguous) data structures
21:50:47 <johnw> AaronFriel: you'll need to wrap the value in a ForeignPtr and write a finalizer that does the freeing you need done
21:51:06 <AaronFriel> Contiguous, rather
21:51:08 <lispy> sccrstud92: In order to evaluate either the vector or the list we need to traverse it and evaluate it. That's where deepSeq (rnf) comes in.
21:51:09 <johnw> Storable has nothing to do with memory allocation, it's about serialization into memory buffers
21:51:09 <ski> Twey : i don't
21:51:13 <lispy> :t rnf
21:51:13 <lambdabot> Not in scope: `rnf'
21:51:19 <lispy> @hoogle rnf
21:51:20 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
21:51:38 <AaronFriel> johnw: Serialization for flat C structures :)
21:51:44 <johnw> right
21:51:52 <johnw> in what context are you using Storable?
21:51:54 <sccrstud92> so it doesnt return anything, how do I use it?
21:52:10 <ski> Twey : i suppose you could ask Smerdy on #ur
21:52:19 <lispy> :t seq
21:52:20 <lambdabot> a -> b -> b
21:52:23 <johnw> sccrstud92: do you have a link for that data?
21:52:27 <AaronFriel> johnw: This is foreign function interface code, with a C function that will hold onto the pointer created for some indefinite length of time before returning it
21:52:40 <sccrstud92> it take a long time to paste because i dont know why
21:52:47 <sccrstud92> im working on it
21:52:50 <johnw> AaronFriel: ok, so what problem are you having?
21:53:00 <lispy> sccrstud92: Sorry, rnf is the wrong one to use here.
21:53:01 <AaronFriel> johnw: Ensuring there are no memory leaks
21:53:05 <lispy> sccrstud92: http://hackage.haskell.org/package/deepseq-1.3.0.1/docs/Control-DeepSeq.html
21:53:19 <johnw> AaronFriel: I'm still missing something; do you have the code where you are using Storable anywhere?
21:53:29 <AaronFriel> sure, one second
21:53:37 <sccrstud92> so deepseq is like seq but evals all the way down to normal form, right?
21:53:44 <sccrstud92> not just WHNF
21:53:52 <ski> i doesn't evaluate inside functions
21:53:54 <johnw> sccrstud92: deepseq is very rarely needed
21:53:59 <lispy> return $ numLines :!: fromList entries -> return $!! numLines :!: fromList entries
21:54:01 <ski> s/i /it /
21:54:08 <johnw> sccrstud92: typically you want to strictify evaluation while building up the structure that you would have deepseq'd
21:54:09 <AaronFriel> https://github.com/AaronFriel/hyhac/blob/unified-backend/src/Database/HyperDex/Internal/HyperdexClient.chs#L246-L260
21:54:20 <AaronFriel> johnw: In the code above you can see the coding style
21:54:25 <johnw> AaronFriel: what in this code is being leaked?
21:54:32 <lispy> sccrstud92: and as johnw says, we rarely need it. I use it when trying to pin point a leak, but I rarely leave it in my code.
21:54:47 <AaronFriel> johnw: I am trying to change it so that memory management is more automatic and exception-safe
21:55:15 <johnw> AaronFriel: this is usually what ForeignPtr's are for; do they not work for you in this case?
21:55:36 <AaronFriel> johnw: No, because for the duration of the asynchronous call, who is holding onto the ForeignPtr?
21:55:40 <AaronFriel> johnw: Not Haskell!
21:55:47 <lispy> sccrstud92: BTW, you'll need NFData instance for your Pair type. Or, you could revert that change and use the built in pairs with the $!!
21:56:09 <johnw> you can always pass a StablePtr to C
21:56:12 <AaronFriel> johnw: If I use ForeignPtr, I understand that a garbage collection could cause the memory allocated to be freed while the C library still believes it's safe
21:56:45 <lispy> sccrstud92: If you want to write the NFData instance it's something like, instance (NFData a, NFData b) => NFData (Pair a b) where rnf (a :!: b) = a `seq` b `seq` ()
21:56:47 <AaronFriel> johnw: What is the difference between a StablePtr and something allocated with malloc?
21:56:58 <johnw> a StablePtr can hold Haskell values
21:57:06 <johnw> malloc can only hold something that is Storable
21:57:21 <lispy> sccrstud92: And actually, that's redundant, but we're going to throw it away later so it's fine.
21:57:23 <AaronFriel> How does that help me with a C library that wants C-structs?
21:57:40 <johnw> I guess i still don't get the flow here
21:57:49 <johnw> you want a finalizer, but you want to control when the finalizer is run?
21:57:51 <AaronFriel> Yes
21:57:57 <johnw> for that I would use ResourceT
21:58:13 <johnw> so that the ResourceT monad governs the whole range during which the values can live
21:58:48 <sccrstud92> johnw: input file is too large for pastebin or lpaste
21:59:09 <johnw> sccrstud92: it's bizarre that in this day and age you can't just easily transfer me a large file!  I'd use Dropbox sharing for this
21:59:19 <AaronFriel> johnw: I think I'll just have to hack something up of my own, ResourceT isn't particularly FFI oriented
21:59:29 <sccrstud92> email?
21:59:35 <lispy> johnw: cf. http://xkcd.com/949/
21:59:36 <johnw> AaronFriel: ResourceT IO should be sufficient to use FFI
21:59:48 <johnw> sccrstud92: I'm fine with that: johnw@fpcomplete.com
21:59:48 <sccrstud92> lispy i know exactly which xkcd that is lol
22:00:01 <AaronFriel> johnw: :/ I do not think so - I cannot run the foreign call inside runResourceT
22:00:07 <johnw> sure you can
22:00:14 <AaronFriel> johnw: No, because the C call is asynchronous
22:00:14 <johnw> liftIO $ call_your_c_function
22:00:23 <AaronFriel> johnw: It holds onto the data for some indefinite duration of time
22:00:30 <johnw> you mean, the C call forks, or you fork before calling the C function?
22:00:35 <AaronFriel> Yes.
22:00:42 <AaronFriel> the details aren't relevant here but
22:00:45 <AaronFriel> there is an event loop
22:00:52 <johnw> well, you can use lifted-async in that case
22:00:53 <sccrstud92> ty based google
22:00:58 <sccrstud92> johnw: sent
22:01:02 <AaronFriel> all calls to the foreign library hit the event loop and return a handle
22:01:03 <johnw> and it will handle the asynchronicity in conjunction with ResourceT
22:01:14 <AaronFriel> later a handle comes back to me (in a disconnected place)
22:01:24 <AaronFriel> and then I can free the associated data
22:01:54 <johnw> so, with lifted-async the type of the handle would be: Async (StM (ResourceT IO) Handle)
22:02:13 <johnw> so that when you use restoreM =<< wait, it communicates state back into the part ResourceT
22:02:15 <athan> Guys, why aren't there any haddocks for the gstreamer library?
22:02:25 <athan> + Ladies, my bad, my bad
22:02:58 <lispy> athan: the hackage server isn't the best about building docs. Users can upload them, but that requires the maintainer to do it.
22:03:08 <lispy> athan: So, probably its just an oversight?
22:03:14 <johnw> AaronFriel: so, if you're thinking about maintaining a finalizer table yourself with IORef, I'm just saying that this is exactly what ResourceT does under the hood :)
22:03:27 <athan> lispy: Do you know of any good alternatives?
22:03:40 <AaronFriel> johnw: Okay, I'm trying to wrap my head around the type you gave me
22:03:42 <johnw> sccrstud92: got it
22:03:49 <athan> lispy: Possibly, I'll check the repo
22:04:04 <sccrstud92> lispy: i updated the code
22:04:14 <lispy> athan: you should try the second option here: http://stackoverflow.com/questions/1587635/haddock-for-cabal-installed-modules
22:04:19 <sccrstud92> still high memory
22:04:30 <lispy> athan: the one that says to add documentation: True and rebuild
22:04:31 <johnw> AaronFriel: it means: fork a thread and return me a Handle when you're done embedded along with some ResourceT state.  When I'm ready to consume this value, I'll merge whatever changes you made to ResourceT into my (the caller's) ResourceT, ensuring that anything allocated on both sides is freed deterministically
22:04:31 <sccrstud92> you want the hp graphs again?
22:04:55 <johnw> sccrstud92: I'm analyzing now locally
22:04:57 <lispy> sccrstud92: I already know what they will look like :)
22:05:06 <lispy> sccrstud92: So, here is what is going on.
22:05:24 <lispy> sccrstud92: The parser builds up a lot of thunks but it doesn't actually build the vectors.
22:05:37 <lispy> sccrstud92: (you know, those tuples that contain a vector of pairs)
22:05:43 <lispy> sccrstud92: and then your mapAccums are lazy.
22:05:45 <AaronFriel> johnw: How does this help with the event loop? I am storing right now a HashMap of Handles to HandleCallbacks that store the state
22:06:14 <lispy> sccrstud92: so when the final answer is demanded, it starts actually parsing and interleaves that with the mapAccums)
22:06:25 <AaronFriel> johnw: The C-functions are not asynchronous w.r.t. the Handle they return, rather, they return a Handle which the event loop will eventually return. The C functions asynchronously return associated data via out pointers that are only valid after the event loop returns.
22:06:52 <sccrstud92> even though $!! should be deepseqing the vector?
22:06:53 <ReinH> johnw: is snoyman around on irc?
22:06:54 <johnw> AaronFriel: I'm not sure yet if it even helps.  What I'm describing in a scenario where you wrap some FFI-calling code, async or not, within a runResourceT, and ResourceT will guarantee that any allocated resources are freed the moment runResourceT is finished.  I'm not sure if this fits your model or not.
22:07:06 <johnw> ReinH: I don't think so, he's pretty rarely on IRC
22:07:14 <ReinH> johnw: ok I'll have to email him then thanks
22:07:15 <lispy> sccrstud92: If you want to fix this, you could either make it process a line at a time or make your mapAccums stricter. If you go the latter route (and I suspect you should), then you may also need to make the result of the parser be fully demanded before the mapAccums
22:07:28 <AaronFriel> johnw: So all of the foreign functions are of a type like this: https://github.com/AaronFriel/hyhac/blob/unified-backend/include/hyperdex/client.h#L115-L121
22:07:31 <lispy> sccrstud92: That will help with the parsing for sure.
22:07:39 <johnw> AaronFriel: it almost sounds like you want to allocate some memory, and let it be GC'd, except that you want a "guarded region" during which time it cannot be GC'd
22:07:51 <lispy> sccrstud92: You can try that independent of the mapAccum stuff, but I strongly suspect you'll end up wanting to make that strict too.
22:07:57 <AaronFriel> johnw: They return an int64_t immediately, but they are passed a bunch of pointers that absolutely must remain valid for some duration of time
22:07:58 <johnw> which is almost the inverse of what ResourceT does
22:08:06 <AaronFriel> yeah sort of
22:08:38 <AaronFriel> johnw: then, later, this deceptively simple function will return the int64_t I got earlier: https://github.com/AaronFriel/hyhac/blob/unified-backend/include/hyperdex/client.h#L614-L616
22:08:47 <sccrstud92> lispy: are you suggesting rewriting my own version or mapAccum that is more strict to adding !(s) somewhere
22:08:52 <johnw> AaronFriel: in that case you still make your ForeignPtr, but just put it into some kind of stable wrapped in a StablePtr until you're ready to let it be freed ordinarily by the GC.  Having it be in a StablePtr will prevent it from being GC'd
22:08:53 <AaronFriel> johnw: When that function returns my int64_t that I've been waiting for, I can finally evaluate those pointers and get a value out
22:08:54 <lispy> sccrstud92: the latter
22:08:59 <sccrstud92> k
22:09:08 <ReinH> sccrstud92: just put !s everywhere then remove them until the leak comes back
22:09:10 <ReinH> then put them back
22:09:10 <ReinH> :p
22:09:12 <lispy> sccrstud92: only rewrite it as a last resort (and proably someone has a strict one you could use)
22:09:28 <ReinH> that's what Real Haskellers do (not really)
22:09:46 <lispy> sccrstud92: Think about the terms being evaluated outside to inside and how things don't get evaluated unless something demands them. That's a pretty good way to think about laziness.
22:10:06 <sccrstud92> lispy: that usually works for me with simple types
22:10:12 <lispy> sccrstud92: And hopefully ou know what demands a value :)
22:10:13 <johnw> AaronFriel: there's another thing you can do
22:10:19 <sccrstud92> lispy: but when other libraries get involved i have trouble
22:10:28 * lispy nods
22:10:37 <lispy> sccrstud92: FWIW, I think you're really close to the solution.
22:10:43 <johnw> allocate your memory with alloca, but do it in a closure that makes the call and blocks waiting for the result.  Invoke this closure in its own thread, as a way of manages the memory
22:11:03 <AaronFriel> johnw: hm
22:11:06 <lispy> sccrstud92: Do you think you have this from here? I want to go read about NES mods :)
22:11:31 <AaronFriel> johnw: that is a neat solution.
22:11:38 <johnw> so: async $ alloca $ \mem -> do handle <- call_c_code mem; block_on handle; return some_result
22:11:51 <johnw> this gives you back a future for the final value, and has all the properties you wanted
22:11:54 <sccrstud92> lispy: im not saying i think i can get it, but I am going to try. thanks for looking at it. go have fun with ur mods
22:12:23 <lispy> sccrstud92: cool and thanks! Good luck, and if you do get stuck after this you might ping Cale.
22:12:33 <sccrstud92> lispy: who is Cale?
22:12:49 <lispy> He's really good at helping people via IRC
22:12:52 <AaronFriel> johnw: Yeah, I'm going to look into that, it might be exactly what I want. I will have to check with the folks that were asking for the library to a better job of bracketing allocations to see if that will do the job
22:12:53 <lispy> And he's here a lot
22:13:27 <sccrstud92> do I ping by typing his name in front of something with a colon like I have been doing with you? (I'm not very hip to the ways of IRC...)
22:13:27 <johnw> sccrstud92: sorry for the delay, looking at the code now
22:13:35 <lispy> sccrstud92: yeah
22:13:39 <johnw> I see it using 1G
22:13:39 <sccrstud92> johnw: no worries
22:13:50 * lispy ducks out
22:13:52 <sccrstud92> lispy: thanks
22:14:10 <lispy> yw!
22:14:26 <Cale> hi
22:14:27 <markovirc_> Hello Cale
22:17:30 <sccrstud92> Cale, how do you feel about kale?
22:20:31 <Cale> I haven't had it often enough to know
22:20:56 <sccrstud92> youre not missing anything
22:22:36 <WalrusPony> Aetherspawn: Hi
22:24:57 <Aetherspawn> I don't know you.
22:25:06 <mcjohnalds> Does anyone know of an example of shaders in HOpenGL? I can't get them working.
22:25:34 <WalrusPony> Aetherspawn: Oh yes you do
22:28:18 <ij> Are Codec.{Image,Picture}.PNG just different implementations of PNG readers?
22:33:48 <Twey> mcjohnalds: You should use acowley's vinyl-gl and GLUtil stuff — makes your code much shorter
22:35:33 <mcjohnalds> Twey: Those look really helpful, thanks for pointing them out
22:35:53 <johnw> sccrstud92: still here?
22:35:59 <sccrstud92> yup
22:36:51 * hackagebot purescript 0.3.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.4 (PhilFreeman)
22:37:10 <johnw> well, I'm starting to think this is not a laziness issue, but just your algorithm, though I could be wrong
22:38:11 <sccrstud92> maybe
22:38:19 <sccrstud92> i was using a different algorithm before
22:38:34 <johnw> i've confirmed it's not the parser at all
22:38:36 <johnw> that only uses 1MB
22:38:37 <sccrstud92> but that was taking too much sapce as well
22:38:46 <johnw> it's "solve" that's killing you
22:38:58 <johnw> and I really can't make anything any more strict than I have: https://gist.github.com/8663181
22:40:11 <sccrstud92> so how did u determine that the parser is only using 1 mb?
22:41:33 <johnw> by forcing its evaluation and commenting out the call to solve
22:42:12 <sccrstud92> i see
22:42:25 <sccrstud92> the other algorithm i was using
22:42:44 <johnw> oh, wait
22:42:48 <sccrstud92> i had an array of bytestring builders
22:42:49 <johnw> i didn't do that correctly
22:42:58 <johnw> in fact, the parser is taking 60% of the memory!
22:43:02 <johnw> i was looking in the wrong place
22:43:06 <sccrstud92> lol
22:43:20 <sccrstud92> yeah according tot he profile it does a majority of the allocations
22:49:37 <ij> I want to read PNGs' pixels. Which pkg should I use?
22:49:46 <ij> or would recommend
22:52:33 <pavonia> ij: Have you already tried pngload?
22:53:48 <ij> I was just looking at it. I'm puzzled by this type sig: imageData :: PNGImage -> StorableArray (Int, Int) Word8
22:53:54 <ij> How can a Word8 contain a pixel?
22:53:59 <ij> http://hackage.haskell.org/package/pngload-0.1/docs/Codec-Image-PNG.html
22:54:28 <pavonia> No, it's an array with indices of type (Int, Int) mapping to Word8 values
22:54:39 <nkpart> Hey conduit question. How can I push a source through 2 conduits at the same time. ie. I'm looking for xxx such that: (r1, r2) <- mySource $$ xxx conduitOne conduitTwo
22:55:00 <nkpart> I'm looking to both do something with a stream of bytes off a socket, and also count the bytes, if that helps
22:55:02 <ij> pavonia, May you tell me what those Word8 values mean?
22:55:08 <pavonia> Oh wait, I see what you mean
22:55:09 <johnw> sccrstud92: I've got it down to this: https://gist.github.com/8663294
22:55:17 <johnw> which is taking 679MB of memory, and I don't know why
22:57:29 <Sibi__> Is there a way in emacs haskell-mode, to set custom prompt for ghci in the inferior process ? (Changing ~/.ghci leads to some other problem.)
22:57:57 <johnw> sccrstud92: oh, wait...
22:58:05 <mirpa> ij: I am just writing some code with JuicyPixels
22:58:40 <lispy> johnw: I don't think _ <- evaluate (V.length l) does what you expect
22:58:45 <johnw> no?
22:58:49 <lispy> _ is lazy
22:58:56 <shachaf> lispy: ?
22:58:58 <lispy> how is evaluate implemented
22:59:04 <johnw> but IO isn't
22:59:13 <shachaf> Executing (evaluate e) evaluates e.
22:59:21 <shachaf> That is the point of evaluate.
22:59:32 <nkpart> Solved my own problem, zipSinks in Data.Conduit.Util
22:59:34 <shachaf> (Evaluates it in a particular way so you get IO exceptions.)
22:59:55 <johnw> nkpart: sorry, I didn't see your question; yes, zipSinks will do it
23:00:34 <johnw> nkpart: see also sinkCacheLength in http://hackage.haskell.org/package/conduit-1.0.12/docs/Data-Conduit-Binary.html
23:01:23 <johnw> nkpart: make sure that counting the bytes doesn't hold large ByteString chunks in memory
23:01:48 <ij> pavonia, No idea then?
23:02:02 <qrada> on the menu for tonight, Lens and Hedis, eeeeugggghuhgughgu
23:02:03 <johnw> lispy: I thought it might be that even tiny lazy ByteString's have a minimum chunk size, but that wasn't it
23:02:50 <pavonia> ij: Looking at the code ... the height seems to be the original image height, the width is (image width)*(bytes per pixel)
23:03:28 <ij> Frightening...
23:03:30 <johnw> lispy: actually, switching from Lazy to Strict reduces consumption from 655 to 542, so it does have some impact
23:04:22 <lispy> johnw: you're still only evaluating the spine of the vector
23:05:27 <pavonia> ij: Yeah, I can't see if the bytes denote the different color channels or something else. Maybe there's a simpler interface
23:05:44 <ij> I think I'm going with mirpa's juicy pixels, then.
23:05:58 <johnw> lispy: https://gist.github.com/8663380
23:06:01 <ij> I'm not in the mood to use this kind of shady interface.
23:06:09 <johnw> i don't think there's anything left unevaluated there, is there?
23:06:49 <johnw> is attoparsec somewhere creating basically a scanl-like list of strings of the input, with each being a copy?
23:07:39 <ij> pavonia, mirpa, Thanks for help/suggestions!
23:08:08 <mirpa> ij: you are welcome
23:08:51 <nkpart> johnw: thanks, I'll check it out
23:09:54 <lispy> johnw: I'm pretty sure that the boxed vector is lazy. So this does nothing, right? map (\(!i, !s) -> (i, s))
23:10:38 <lispy> http://hackage.haskell.org/package/vector-0.10.9.1/docs/src/Data-Vector.html#Vector
23:10:56 <sccrstud92> does it do the same thing with and without that call to map?
23:11:09 <sccrstud92> in terms of memory  i mean
23:11:11 <lispy> I think !(Array a) is like !([a])
23:11:12 <sccrstud92> then u could tell
23:11:13 <johnw> yes
23:11:34 <pavonia> ij: There's also a png loader for the bitmap package but reading single pixels from a bitmap seems harder than expected :p
23:12:53 <lispy> johnw: if you imported deepseq you could write: void $ evaluate (force (V.length l))
23:13:18 <mirpa> If I use Vector.!? then I can't get: *** Exception: Error in array index, right?
23:13:18 <lispy> although, I don't think that's what I would recommend
23:13:26 <shachaf> deepSeq :-(
23:13:47 <lispy> shachaf: You don't like debugging?
23:14:09 <lispy> johnw: I would pick part that applicative mess that builds the tuples and try doing it more strictly.
23:14:21 <lispy> Either way, late here
23:14:24 * lispy heads to bed
23:15:02 <sccrstud92> lispy and johnw, are you guys on here often?
23:15:09 <johnw> sccrstud92: every day
23:15:29 <sccrstud92> cool
23:15:39 <sccrstud92> if i stop responding it means i fell asleep
23:15:45 <sccrstud92> but i will be back on tomorrow
23:16:10 <sccrstud92> this will keep bugging me until i understand what is going on
23:18:50 <pavonia> ij: JuicyPixels has a nice interface, I'd try out that package
23:45:47 <Yep> I'm looking for a function for literal Int64 -> [word8]
23:46:06 <Yep> where 0 = [0,0,0,0,0,0,0,0]
23:46:16 <Bynbo7> and 1 = ?
23:46:40 <Yep> [0,0,0,0,0,0,0,1]
23:47:16 <Axman6> well, using the functions shiftR, .&. and fromIntegral, you can accompish that easily
23:48:05 <Axman6> :t unfoldR
23:48:06 <lambdabot>     Not in scope: `unfoldR'
23:48:06 <lambdabot>     Perhaps you meant one of these:
23:48:06 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
23:48:09 <Axman6> :t unfoldr
23:48:10 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:49:31 <Yep> Thanks Axman6
23:50:32 <Axman6> > let f num =  unfoldr (\(n,i) -> if i == 0 then Nothing else Just (n .&. 0xFF, (n `shiftR` 8, (i-1)) (num,8) in f 12345678901234567
23:50:33 <lambdabot>  <hint>:1:109: parse error on input `in'
23:50:49 <Axman6> > let f num =  unfoldr (\(n,i) -> if i == 0 then Nothing else Just (n .&. 0xFF, (n `shiftR` 8, (i-1))) (num,8) in f 12345678901234567
23:50:50 <lambdabot>  <hint>:1:110: parse error on input `in'
23:50:58 <Axman6> whateverm something like that
23:51:20 <Yep> yep, i'll take it from there, thanks Axman6
23:51:58 <Axman6> you can also use divMod but the bit shifting is probably faster since I'm not sure GHC is very good at recognising those
23:52:32 <Yep> okay
23:57:06 <jrmithdobbs> hahahaha, i think this is my favorite slide deck i've seen that uses these words, the second slide is perfect ;p
23:57:10 <jrmithdobbs> http://slid.es/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/fullscreen#/
23:58:15 <joelteon> I think I sorta understand that quote now
